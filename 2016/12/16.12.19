00:07:53 <saurabhnanda> how do I get this to compile?  “import qualified Data.Time as Cal; data DateOrTime = Cal.Day | Cal.LocalTime”
00:17:35 <pavonia> saurabhnanda: What is this supposed to do?
00:17:47 <pavonia> Do you want "data DateOrTime = MyDay Cal.Day | MyLocalTime Cal.LocalTime" perhaps?
00:17:52 <saurabhnanda> pavonia: create an ADT based on two data-types defined by the time library
00:46:16 <kadoban> I actually managed to use ST and STArray without fighting the type system for once, hah.
00:52:13 <MarcelineVQ> what'd you make?
00:55:41 <kadoban> A useless competitive programming problem solution ... well, part of one.
01:07:55 <haskellnoob> Hey everyone, got a question, let say I have a function which uses apostrophe call it function', how do I use infix this
01:08:33 <kadoban> `function'`
01:08:40 <liste> > let foo' = (+) in 5 `foo'` 6
01:08:42 <lambdabot>  11
01:08:45 <kadoban> ` isn't the same as ', as much as they look similar in some fonts
01:08:57 <haskellnoob> ahhhh
01:09:05 <haskellnoob> thank you
01:32:42 <onintza> Does there not exist some "Int -> [a] -> Maybe a" list lookup function?
01:33:11 <merijn> :t \n -> listToMaybe . drop n
01:33:12 <lambdabot> Int -> [a] -> Maybe a
01:33:36 <merijn> Although you should really avoid indexing into lists, tbh\
01:33:48 <kadoban> onintza: Maybe in the 'safe' package? Though, yeah that ^
01:33:53 <Ferdirand> :t (listToMaybe .) . drop
01:33:55 <lambdabot> Int -> [a] -> Maybe a
01:34:04 <onintza> It is a requirement to get the 6th element in a list
01:34:22 <onintza> I was hoping I could find some predefined safe version of !!
01:36:56 <merijn> It doesn't really exist, because that would encourage people doing stuff they shouldn't. I don't see why a "predefined" version would be better than just definining "l !? n = listToMaybe $ drop n l"?
01:37:53 <onintza> merijn: !! is far far worse and it does exist
01:39:00 <merijn> onintza: For historical reasons
01:39:26 <onintza> I don't see how adding a safe version of it makes it worse
01:40:30 <merijn> onintza: Also, see Fairbairn Threshold
01:40:54 <merijn> "The Fairbairn threshold is the point at which the effort of looking up or"
01:40:55 <merijn> keeping track of the definition is outweighed by the effort of rederiving
01:41:41 <onintza> Meh, if we are strict with that a lot of small utility functions shouldn't exist
01:41:49 <onintza> The stdlib is full of those
01:42:32 <onintza> Idk, I consider list lookup by index fairly important
01:42:46 <onintza> There even exists a lookup function for [(a, b)] lists
01:42:55 <merijn> onintza: If you want to lookup by index you'd want Array or Vector anyway
01:43:15 <onintza> Why? Lists allow indexing
01:43:19 <merijn> onintza: Yes, because a lot of stuff was defined 20+ years ago when Haskell was an obscure research language and deleting stuff now would break decades of code
01:43:36 <merijn> onintza: Because, as I said earlier, indexing lists has terrible performance
01:44:15 <onintza> merijn: So, accepting that !! will likely never go away, I think we should add some !? that will never go away :þ
01:44:29 <merijn> Indexing a list is O(n), indexing an array/vector is O(1), that's a pretty big difference
01:44:52 <cocreature> onintza: or we just start using appropriate data structures when we need to index :)
01:44:54 <onintza> merijn: Yes, but sometimes that performance penalty doesn't matter -- like when you are getting the 6th element of a list
01:45:33 <merijn> Depends on how often you index the 6th element...
01:45:48 <onintza> Correct me if I'm wrong, but converting a list to an array is O(n) too
01:46:34 <onintza> So if you are getting a list from somewhere and want to get the 6th element, it is of little use converting it into an array
01:47:10 <onintza> In my use case, I'm getting the 6th element a single time per list
01:47:16 <onintza> But I'm doing it for many different lists
01:47:48 <kadoban> That's correct
01:48:17 <EvanR> lazy code at runtime is a network of objects connected via pointers like a list
01:48:24 <EvanR> thats so inefficient, make it all arrays!
01:49:05 <onintza> EvanR: it's not inneficient if you just need to traverse it once, it would be more inneficient to traverse it once to make it an array and then use it
01:49:26 <cocreature> onintza: there is https://hackage.haskell.org/package/safe-0.3.10/docs/Safe.html#v:atMay so just use that :)
01:49:47 <kadoban> I'm fairly sure they were being sarcastic, onintza
01:50:09 <onintza> kadoban: oh :S
01:50:09 <cocreature> you are not going to get anywhere by arguing that it should exist in base, it doesn’t exist atm and changing base can take a while so unless you can wait a few years you have to deal with that fact :)
01:50:21 <merijn> cocreature: I don't see the point of adding a new package for what is a 1 line definition
01:50:33 <merijn> cocreature: Which was literally like the first response to the question...
01:50:55 <cocreature> merijn: I was just trying to end what I see as a pretty useless discussion …
01:50:59 <onintza> cocreature: i wasn't expecting to get it added to base, it was more of a rant :D
01:53:20 <onintza> in practice, i changed my code a bit so i don't need it: i was using isPrefixOf to make sure the first 5 elements where some xs', so instead now i (p, c) = splitAt xs, compare p to xs' and use listToMaybe c
01:54:01 <onintza> sorry, (p, x) = splitAt 5 xs
02:01:36 <lyxia> stripPrefix does isPrefixOf then drop
02:03:26 <onintza> oh, nice -- take that Fairbairn Threshold :þ
02:06:11 <kadoban> Nice :)
02:15:37 <MarcelineVQ> semantically you mean?
02:20:44 <MarcelineVQ> that might not be the right word, it's pretty overloaded :X What I mean is: Do you mean stripPrefix acts like using isPrefixOf and drop?
02:20:48 <puregreen> why does Foldable.toList for NonEmpty use foldr instead of a simple `(a:|as) -> a:as` definition?
02:22:05 <cocreature> puregreen: probably because the person who wrote the Foldable instance forgot to overwrite toList :)
02:22:57 <quchen> toList does exactly that for NonEmpty
02:23:06 <quchen> It seems it was simply forgotten in the class
02:23:19 <quchen> http://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.List.NonEmpty.html#line-194
02:23:31 <quchen> »toList ~(a :| as) = a : as«
02:23:40 <quchen> Patch? :-)
02:28:46 <zaquest> toList (and many other functions) wasn't always in Foldable
02:30:42 <puregreen> okay, patch it is! 
02:31:15 <puregreen> (if anybody has got a tutorial on how to get one's patches accepted into GHC, I'd appreciate that)
02:31:19 <puregreen> (if not, I'll ask a friend)
02:31:34 <ij> If I've defined an instance for X Y, then is it usable in other modules without imports? Can it be redefined to something else in other modules?
02:32:23 <merijn> ij: Instances are globally unique
02:32:50 <merijn> ij: So GHC will yell at you loudly if you try and redefine it. You can trick GHC into accepting it, but it will make your life filled with woe and misery
02:33:11 <ij> Ah, good to know.
02:33:49 <merijn> ij: The safest solution is to avoid orphan instances (an instance is an orphan if it's not defined in either 1) the module defining the datatype or 2) the module defining the class)
02:34:13 <merijn> Because that guarantees GHC will notice if you're redefining or otherwise messing up
03:36:03 <quchen> I usually put my orphans in a Orphans.hs, carefully. Frequent example: Arbitrary instances for QuickCheck tests.
03:36:50 <quchen> »Carefully« means that one has to make sure that nothing about that orphan can leak out of your package.
03:42:55 <Axman6> don't export from the package and include in test files? anything more that needs to be done?
03:43:51 <quchen> You can’t not export instances from a module, so you have to not export the entire module.
03:44:25 <quchen> And you also have to have the governance over the types the instances are defined for, otherwise someone else can orphan them as well, and the instances clash again.
03:50:32 <Gurkenglas> Do backpack or the like allow attaching package dependencies to definitions, so the dependencies don't have to go in your whole project?
03:52:15 <Gurkenglas> (Then lens could come including batteries that are transparent unless you need them)
04:05:06 <shlevy> If I'm interfacing with a C API that takes text a null-terminated char *, can I do better than this? \t -> unsafeUseAsCString (encodeUtf8 $ snoc t '\0')
04:14:37 <maerwald> shlevy: useAsCString
04:18:21 <shlevy> maerwald: That makes a copy though right? THe C API takes a const char *
04:18:29 <shlevy> Oh
04:18:32 <shlevy> I'm making a copy anyway :D
04:18:45 <shlevy> Right, that's definitely better then
04:21:00 <maerwald> also, it appears the documentation of CString is wrong https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#t:CString
04:21:24 <Netwolf> jfn
04:22:46 <maerwald> since the CString type alone doesn't give any guarantee about NUL-termination
04:22:51 <maerwald> someone should fix the documentation
04:24:37 <oherrala> maerwald: maybe you could?
04:24:58 <maerwald> I'm too lazy to go for a PR for such a triviality
04:25:08 <shlevy> Should my low-level wrapping of a C api return error codes or turn them into exceptions?
04:26:10 <merijn> shlevy: Golden rule: libraries should return errors, applications should use exceptions internally
04:26:32 <merijn> shlevy: Alternatively, provide an optional throwing version of your API
04:26:42 <shlevy> OK, thanks
04:27:10 <merijn> shlevy: But I'd say by default don't throw (you could even wrap the non-throwing API with a throwing one in a different module, letting users chose)
04:27:50 <oherrala> and if it throws something, then at least document what it throws
04:38:47 <kuribas> What is a good interface for a GUI canvas?
04:39:11 <kuribas> (gtk2hs or wxHaskell)
04:40:49 <kuribas> I currently have a mutable variable with all the elements (paths, curves, lines, etc), and callbacks embedded in the handles.
04:42:35 <kuribas> So "drawing" is simply changing the element variable, and refreshing the canvas.
04:43:31 <AndreasK> Do you want a gui or just be able to draw? For simply drawing gloss or sdl2 might be an option
04:44:57 <kuribas> AndreasK: A gui, and interacting with the drawing.
04:45:11 <kuribas> Currently only using "handles".
04:47:09 <AndreasK> afaik there is no gui functionality in either of those :(
04:50:18 <kuribas> AndreasK: drawing itself is no problem, since wxHaskell has primitives for that.
04:50:27 <kuribas> But I need a good interface for interactive use.
04:51:01 <kuribas> The ability to zoom in, scroll, manipulate handles, etc...
04:54:19 <hoppfull> Hello! I just wanted to ask a quick question. Does foldr exist in mathematics or is it purely a programming concept? I guess we'd need concatenation in order for foldr to work.
04:57:30 <Akii> hoppfull: https://wiki.haskell.org/Catamorphisms
04:57:39 <Akii> mathy enough? :D
04:58:03 <yulax> well... technically *all* of haskell is expressed in terms of Lambda calculus...
04:58:06 <merijn> hoppfull: Depends on how broadly you define mathematics...
04:58:10 <yulax> so ... it does exist!
04:58:40 <merijn> hoppfull: foldr is certainly meaningful in lambda calculus which is sort of a gray area between computer science and math
04:58:51 <Ferdirand> what do you mean by "we'd need concatenation in order for foldr to work" ?
04:59:27 <hoppfull> Akii, yulax, merijn: Thanks!
04:59:30 <merijn> foldr is really just a Scott-encoding (I think? Or was it Church, I always get them mixed up) for lists
04:59:54 <Ferdirand> > foldr (:) [] [1,2,3,4]
04:59:59 <lambdabot>  [1,2,3,4]
05:00:23 <merijn> hoppfull: tbh, IMO all of programming is just math, so...
05:00:39 <merijn> hoppfull: Many programmers just like to pretend it's not, which is why they're bad at it :p
05:01:31 <tdammers> unfortunately, quite a lot of developers are also convinced that programming is *only* math
05:01:32 <hoppfull> Yeah, uhm. You're right. I've only slept for three hours tonight. Actually, I meant to ask if we can do concatenation as well as foldr. Because if we could, we could do filter and map as well. And if we can do them, we can do sorting.
05:02:14 <merijn> hoppfull: Well that's a bit open ended
05:02:14 <tdammers> which is of course ridiculously inappropriate when you produce mathematically sound solutions to the wrong problem
05:02:37 <merijn> hoppfull: I mean, what if I don't actually have lists, but can make something that behaves exactly like one, is that a list?
05:02:57 <hoppfull> merijn: To brag a little: Once in class our teacher solved a problem in 20 lines of code. I could see that it was just a geometric sum so I could reduce the problem to three lines of code. ; ) Mathematics has helped me in programming and I think programming is helping me with math. Especially functional programming.
05:03:04 <merijn> tdammers: Sure, you also need to be able to do operational reasoning to be an effective coder, but that seems more common :)
05:03:49 <merijn> hoppfull: Lambda calculus is capable of expressing every possible computation [citation needed ;)], but only has functions, function applications and variables
05:03:59 <hoppfull> merijn: Can't I express anything I want in mathematics as long as it doesn't contain any contradictions?
05:04:10 <merijn> hoppfull: But it turns out that's all you need to mimic lists and other datatypes
05:04:16 <Ferdirand> > foldr (:) [4,5,6] [1,2,3]
05:04:18 <lambdabot>  [1,2,3,4,5,6]
05:05:02 <hoppfull> Well, I need to get back to work! Thanks all!
05:05:50 <Ferdirand> > foldr ((*2).(:)) [] [1,2,3]
05:05:53 <lambdabot>  error:
05:05:53 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M587122739084...
05:05:53 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
05:06:33 <Ferdirand> > foldr ((:).(*2)) [] [1,2,3]
05:06:35 <lambdabot>  [2,4,6]
05:06:37 <Ferdirand> duh
05:13:34 <mohsen_> Hi. How should I utilize happstack-lite project created by stack? There is no template for it.  
05:17:08 <mohsen_> in project*
05:45:48 <ark> 14:44 -!- Irssi: #haskell: Total of 1635 nicks [1 ops, 0 halfops, 0 voices, 1634 normal]
05:45:51 <ark> 1635 nicks
05:45:55 <ark> pls
05:46:47 <ongy> what is a halfop?
05:48:02 <mlehmk> kind of helper, who can kick/ban and voice/devoice, but cannot op/deop
05:48:50 <cousteau`> the -> "operator"(?) is right-associative, right?  so for example function :: a -> b -> c -> d is the same as function :: a -> (b -> (c -> d))
05:49:06 <merijn> cousteau`: Correct
05:49:35 <cousteau`> so function doesn't really take an a, b, c and return a d; it actually takes an a and returns a (b -> c -> d)
05:49:44 <merijn> cousteau`: Also correct
05:49:49 <cousteau`> I see, thanks!
05:50:28 <merijn> cousteau`: Which in turn explains exactly how/why partial application works :)
05:50:37 <notark> abcdef
05:50:51 <n123123> asa
05:50:57 <cousteau`> that explains the weird a -> b -> c -> d syntax which didn't make much sense; I'd have written it as... dunno, maybe a,b,c -> d
05:51:06 <cousteau`> but with that in mind, it does make sense
05:51:30 <n123123> yeah it was weird for me as well
05:51:41 <merijn> cousteau`: More generally (this is a bit of an overgeneralisation compared to what GHC actually does): "foo x y z = bar" is really just syntactic sugar for "foo = \x y z -> bar" which just syntactic sugar for "foo = \x -> \y -> \z -> bar"
05:52:20 <merijn> cousteau`: GHC does some more direct things and optimisations when compiling functions, but that's the basic idea
05:52:21 <cousteau`> I see
05:52:21 <Ferdirand> there is another type (a,b,c) -> d indeed
05:52:28 <Ferdirand> but it's less convenient to work with
05:52:36 <cousteau`> Ferdirand: I guess in that case you're passing a tuple
05:52:38 <mlehmk> understand currying
05:52:49 <mlehmk> function returns a function...
05:52:56 <mlehmk> functions take a single argument each
05:52:56 <cousteau`> I think (a,b,c) -> d resembles more what I'd think of when I think of a function
05:53:12 <Ferdirand> you can transform one into the other
05:53:31 <Ferdirand> the curried versions are more convenient though, because they let you partially apply them
05:53:44 <cousteau`> yep
05:54:20 <mlehmk> there is something that ((a,b) -> c) -> a -> b -> c
05:54:43 <merijn> cousteau`: I would say the leap to "so it returns 'b -> c -> d'" is probably the hardest/most important leap in making sense of type signatures :)
05:55:36 <mlehmk> https://wiki.haskell.org/Currying
05:57:17 <cousteau`> mlehmk: I see, thanks!
05:59:57 <cousteau`> man, dunno why I suddenly felt like learning Haskell... I like the idea of learning a functional language and Haskell looks rather mathy and "pure", plus for some reason the rules don't feel weird to me even if I'm used to imperative languages, but this "A gentle introduction to Haskell" thing is confusing as hell
06:00:45 <merijn> @quote Brend Gentle
06:00:45 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
06:01:33 <merijn> cousteau`: Note, the gentle introduction was written to introduce Haskell to people *already* familiar with existing functional languages when Haskell was invented (so SML and friends)
06:01:33 <cousteau`> lol
06:01:49 <merijn> cousteau`: I would not recommend it as intro for someone not familiar with an existing functional language :)
06:01:50 * cousteau` Learns himself a Haskell
06:02:10 <mlehmk> try to avoid monads and applicatives until you feel confident in the functional domain
06:02:23 <merijn> cousteau`: I've heard good things about www.haskellbook.com and Richard Bird's book is good
06:02:24 <Cale> You might also check out http://www.cis.upenn.edu/~cis194/spring13/
06:02:34 <mvdw> Haskellbook is working well for me so far.
06:02:37 <merijn> And cis194 is also well known
06:02:38 <Cale> Also, Programming in Haskell by Hutton
06:03:00 <mvdw> Very descriptive, with interesting exercises.
06:03:32 <merijn> mvdw: Yeah, I skimmed bits. They seemed decent. But I've also heard loud complaints from other experienced Haskellers, so I'm hedging my recommendation ;)
06:09:14 <Ferdirand> I really liked Real World Haskell when it came out, but it is a bit dated. Is there something in the same vein that would also touch modern things like optics and pipes ?
06:09:53 <JuanDaugherty> 'optics' means lenses?
06:10:08 <Ferdirand> yes
06:11:36 <merijn> JuanDaugherty: plus prisms
06:11:46 <JuanDaugherty> ah
06:11:53 <merijn> hence, optics ;)
06:12:14 <JuanDaugherty> and pipes is applicative?
06:12:16 <lyxia> Traversals and Isos kinda fall under the same term too
06:13:05 <Ferdirand> pipes or conduits or iteratees
06:13:17 <kadoban> pipes is the pipes package I'm pretty sure
06:14:04 <JuanDaugherty> heard of conduits
06:14:15 <JuanDaugherty> not recently
06:16:11 <maerwald> merijn: what do you mean with "heard good things"? Did you read it?
06:17:11 <merijn> maerwald: I mean "people in here said they liked it/thought it was good"
06:17:24 <maerwald> people say that about lyah too
06:17:32 <merijn> I didn't see the point of paying for and reading a several hundred page book when I already know Haskell
06:17:43 <merijn> LYAH is a complicated case
06:17:53 <maerwald> so is a non-free book, recommended by hearsay
06:17:59 <merijn> It came out just after (or just before?) I started learning Haskell
06:18:10 <synProgrammer> You can read the web of lyah
06:18:15 <merijn> At that time it was better than anything else, but it is not particularly good
06:18:31 <synProgrammer> It's not neccesary to buy the book
06:18:39 <merijn> The structuring is bad in terms of pedagogy, it skips over important things and focusses on some unimportant ones
06:19:28 <merijn> Haskell Book was written explicitly to fix these pitfalls. The chapters I proofread were good and much sounder in terms of teaching than LYAH.
06:20:05 <JuanDaugherty> i like art of FP too, but it's not free
06:20:30 <JuanDaugherty> and doesn't address those topics, is basic hs
06:21:03 <ventonegro> another vote for haskellbook.com
06:21:14 <merijn> maerwald: So it boils down to: LYAH, which I know objectively is NOT good for teaching and Haskell Book where I know the parts I've seen are good and community opinion mostly seems to be "excellent" with a few detractors
06:23:17 <maerwald> I find it troubling that non-free teaching material has become so widely recommended here. People come in here these days to learn a bit of haskell and what they get is an advert for a 50+ $ book.
06:23:30 <kadoban> merijn: Ya, I read like 80% of a friend's copy, since I couldn't bring myself to buy it to learn stuff I already know. It's ... how I wish I had learned haskell.
06:23:35 <merijn> maerwald: Well, feel free to write a better one for free
06:23:45 <tdammers> lyah is also plain out wrong on a few things IIRC
06:24:17 <merijn> maerwald: Not all good things are free. Should I tell people to learn from shoddy writing instead just because it doesn't cost money?
06:24:34 <maerwald> there are free teaching materials that work pretty well
06:24:34 <tdammers> also, non-free books are much less problematic than non-free software
06:24:50 <merijn> Especially considering bitemyapp has been more than willing to provide students and people from poor countries with cheaper/free versions
06:24:52 <zomg> People learn just fine from imperfect material too.. somehow all of the people here learned Haskell before a "pedagogically sound" book existed :)
06:25:11 <maerwald> tdammers: I strongly disagree when it comes to education
06:25:13 <merijn> zomg: Sure, and it tooks me months if not years to unlearn some wrong things
06:25:13 <kadoban> Well, free in the sense being currently discussed is of the gratis variety, not the libre variety. But it's not libre either.
06:25:14 <quchen> tdammers: LYAH’s wrong in saying that foldr folds from the right, but that’s about it. The other thing is that it was written pre-AMP, but that’s about it.
06:25:16 <maerwald> this is not about cool sci-fi books
06:25:34 <quchen> Wow, I just added »that’s about it« twice in a two-liner without noticing.
06:25:38 <tdammers> maerwald: all the complaints against non-free books also apply to non-free software, but for non-free software, there are additional complaints that do not apply to books
06:25:54 <maerwald> tdammers: I don't care if the games I play are non-free
06:25:56 <zomg> merijn: frankly I doubt that any material could fully incorporate all the right things about something as large in scale as programming, so regardless of where you learn, I think that would happen
06:25:59 <tdammers> maerwald: I do
06:26:11 <kuribas> maerwald: I learned haskell from a lot of free material then I bought "real world haskell".  I could have saved time by reading RWH first.
06:26:36 <ventonegro> let's add a disclaimer then. "this is the best resource, but if you wish to trade a little pain for some dollars, use these free resources instead"
06:26:37 <tdammers> maerwald: but it doesn't matter whether you care or not; non-free software has strictly more issues than non-free books
06:26:40 <kuribas> tdammers: most free games are crappy.
06:26:45 <merijn> I'm pragmatic, I recommend the best teaching material. If someone complains they want something free I can recommend some things there, but I don't think I should optimise for that case
06:27:01 <maerwald> I think we should
06:27:11 <merijn> maerwald: Why?
06:27:11 <tdammers> the free/non-free debate is -blah material, so I won't discuss this any further here
06:27:14 <zomg> Yeah agreed, recommend best, if they have a complaint, recommend something else :)
06:27:26 <kadoban> kuribas: Some of the really cheap ones are amazing though.
06:27:49 <maerwald> merijn: because I find it unethical
06:27:49 <kadoban> (which has ... nothing to do with the conversation, just saying)
06:28:31 <kuribas> kadoban: like?  There will no free game like the witcher though...
06:28:43 <merijn> maerwald: Well, then I suggest you put your money (well time in this case, but they're convertible) where your mouth is and contribute to the free learning material?
06:28:53 <tdammers> kuribas: which is why I have pretty much stopped gaming entirely
06:29:05 <maerwald> merijn: again: there are already free learning materials
06:29:07 <quchen> This sounds a bit offtopic. Suggesting a certain book should not make the Haskell channel a dispute about whether things should be free.
06:29:12 <kadoban> kuribas: Thinking of things like super meat boy and dustforce and a bunch of other crap I got on humblebundle for essentially nothing compared to how much time I spent on them, heh.
06:29:20 <merijn> maerwald: I optimise for the time I spend teaching and fixing misconceptions here, not price in dollars
06:29:27 <zomg> best actually free game I've ever played is Team Fortress 2.. I can't really think of anything else
06:29:47 <tdammers> zomg: not free though, only gratis
06:29:48 <zomg> I suppose there might be some mobas and such as well but not something I personally enjoyed much
06:29:52 <mlehmk> TF2 isn't free
06:29:57 <kuribas> kadoban: "the witcher 2" costs 3 dollars at sales.  No free game could ever achieve this.
06:29:58 <Gurkenglas> quchen, it's a dispute about what to recommend here, though
06:30:07 <maerwald> tdammers: in case of education, I mean both
06:30:22 <kadoban> kuribas: That sounds familiar, but I've never played it, I'll look it up.
06:30:23 <maerwald> I'm aware that "free" in terms of software does not mean "gratis"
06:30:34 <mlehmk> and neither gratis
06:30:40 <tdammers> maerwald: I was strictly only talking about "free as in speech"
06:30:47 <kuribas> maerwald: free or open source doesn't make sense for games, but at makes sense for gaming engines.
06:30:54 <zomg> OpenTTD? :P
06:30:55 <maerwald> kuribas: yes
06:30:56 <mlehmk> TF2 is more freemium... it costs money to really use additional features
06:31:20 <zomg> mlehmk: what features do they make you pay for? Last time I played which admittedly was a while ago it was just for the items which are mostly cosmetic
06:31:26 <quchen> Gurkenglas: We’re talking about the price of The Witcher 2. Not liking something is not a good reason to derail the thread. I don’t like to discuss GPL vs BSD in here for the same reasons.
06:31:27 <maerwald> kuribas: well, we could debate "make sense", but I don't mind proprietary games... I consider them untrusted and run them in an appropriate environment
06:31:39 <merijn> kuribas: tbh, almost every major engine has switched to open source recently (but that's more for -blah/-offtopic)
06:31:56 <merijn> Also, can we move the free game discussion to -blah/-offtopic
06:32:15 <maerwald> -blah randomly bans people, better use -offtopic
06:32:27 <ventonegro> I'd rather pay for a 1000+-page, well-written book, than chase hundreds of disconnected tutorials all over the Internet. But I won't suggest other people they *cannot* do that.
06:32:28 <tdammers> actually, can we please move the entire free anything debate to -whatever
06:32:30 <Hijiri> switched to "open source"
06:32:40 <kuribas> maerwald: for being on-topic?  :-O
06:32:44 <Gurkenglas> Recommending books one has to pay for makes people that were already going to write educational material think it's okay to charge money, which reduces public learning.
06:32:50 <quchen> »Move the discussion«, the IRC version of euthanasia
06:32:54 <kuribas> ventonegro: +1
06:33:18 <maerwald> Gurkenglas: good point
06:33:28 <tdammers> Gurkenglas: recommending books one has to pay for might also be a signal that apparently there is room for gratis learning materials
06:38:10 <quchen> Has anyone heard from sinelaw? Haven’t seen him around lately, and he doesn’t answer emails it seems
06:38:10 <stobix> I was showing Haskell to a friend of mine yesterday, exemplifying funtions by making a simple factorial function. He asked "how do I make it only valid for x∈ℕ?" So, I ask this here as well: Is there a good way to say that a function is only valid for integers greater than 0?
06:38:30 <quchen> stobix: There are types for that, yes.
06:38:44 * cousteau` just realized that "euthanasia" means "good death"
06:38:47 <stobix> quchen: nice. Like PositiveInt or something?
06:38:54 <quchen> Natural is the natural numbers, for example. Like Integer is for umm integers.
06:39:07 <stobix> Oooh.
06:39:19 <quchen> For bounded integers, there is Word.
06:39:29 <quchen> > [minBound, maxBound] :: Word
06:39:31 <lambdabot>  error:
06:39:31 <lambdabot>      • Couldn't match expected type ‘Word’ with actual type ‘[t0]’
06:39:31 <lambdabot>      • In the expression: [minBound, maxBound] :: Word
06:39:38 <quchen> > [minBound, maxBound] :: [Word]
06:39:40 <lambdabot>  [0,18446744073709551615]
06:39:40 <quchen> Woops.
06:39:44 * stobix actually had no idea, for some reason. Probably because he hasn't used the feature the last 10 years or so.
06:39:58 <quchen> > 1 :: Natural
06:40:01 <lambdabot>  1
06:40:02 <cousteau`> isn't 0 natural?  (I think this is a topic of discussion in math; some include 0 in the N set and some exclude it)
06:40:05 <quchen> Natural is a relatively recent addition to Base though
06:40:15 <Hijiri> > 1 - 2 :: Natural
06:40:17 <lambdabot>  *Exception: Natural: (-)
06:40:25 <stobix> cousteau`: depending on which university you go to, you'll get different answers to that.
06:40:32 <Hijiri> > 1 - 1 :: Natural
06:40:34 <lambdabot>  0
06:40:45 <quchen> Some people start the natural numbers at 0, some at 1, some maybe at π.
06:40:55 <quchen> In Haskell, we include 0.
06:40:56 <stobix> cousteau`: Some mathematicians do ℕ\{0} or ℕ∪{0} to be specific.
06:41:11 <cousteau`> there's the N and the N* set; one of them includes the 0 and the other excludes it.  Different mathematicians assign one meaning or the other.
06:41:47 <stobix> Nice.
06:41:53 <stobix> Consensus is for weaklings. ;)
06:42:17 <stobix> quchen: good to know. As long as it is well-defined in Haskell, everything's cool.
06:42:50 <cousteau`> A friend of mine got a math degree and whenever his professor wrote ℕ* he added a note saying "my ℕ*, not the other one"
06:43:11 <kadoban> Haha ...
06:43:53 <cousteau`> ...and then there's VHDL (which I think inherits this from Ada) where `natural` includes 0 and `positive` excludes it
06:44:14 <stobix> hehe, nice
06:44:30 <kadoban> Isn't N+ some kind of notation, with the + as a superscript? I thought I've seen that before for [1..]
06:44:38 <cousteau`> (both being subsets of `integer`, which is not really the set of integer numbers because it's limited; it doesn't go to +/- infinity)
06:45:07 <stobix> VHDL is weird anyways.
06:45:11 <cousteau`> kadoban: I've seen it with a *
06:45:35 <Ferdirand> i knew R*, where the * denotes the set of units (invertible elements) wrt to the ring operation
06:45:41 <quchen> Hm. So I wrote the factorial function and I can’t figure out why it overflows.
06:45:42 <quchen> > let fac :: Natural -> Natural; fac = fac' 1; fac' !r 0 = r; fac' r n = fac' (r*n) (n-1) in unfoldr (\i -> Just ((i,fac i), i+1)) 0
06:45:45 <lambdabot>  [(0,1),(1,1),(2,2),(3,6),(4,24),(5,120),(6,720),(7,5040),(8,40320),(9,362880...
06:45:52 <Ferdirand> in the case of R it excludes 0 only, but that does not generalize to Z or N
06:46:02 <quchen> Hah, the overflow occurs at 10. Private session shows it, channel does not.
06:46:05 <quchen> Phew! ;-)
06:46:21 <quchen> > let fac :: Natural -> Natural; fac = fac' 1; fac' !r 0 = r; fac' r n = fac' (r*n) (n-1) in fac 10
06:46:23 <lambdabot>  *Exception: stack overflow
06:46:34 <cousteau`> https://en.wikipedia.org/wiki/Natural_number#Notation uses the "asterisk excludes" convention, apparently
06:46:37 <quchen> Idas, anyone?
06:47:43 <kadoban> Oh it shows Z+, I wonder if that's what I was thinking of.
06:47:55 <cousteau`> kadoban: shows N+ as well
06:48:00 <kadoban> Oh
06:48:02 <stobix> quchen: what is the point of the exclamation mark?
06:48:04 <Cale> > let fac :: Integer -> Integer; fac = fac' 1; fac' !r 0 = r; fac' r n = fac' (r*n) (n-1) in unfoldr (\i -> Just ((i,fac i), i+1)) 0
06:48:07 <lambdabot>  [(0,1),(1,1),(2,2),(3,6),(4,24),(5,120),(6,720),(7,5040),(8,40320),(9,362880...
06:48:13 <Cale> > let fac :: Integer -> Integer; fac = fac' 1; fac' !r 0 = r; fac' r n = fac' (r*n) (n-1) in drop 9 $ unfoldr (\i -> Just ((i,fac i), i+1)) 0
06:48:14 <cousteau`> honestly I think N0 and N1 are the best representations
06:48:15 <lambdabot>  [(9,362880),(10,3628800),(11,39916800),(12,479001600),(13,6227020800),(14,87...
06:48:21 <quchen> stobix: Making fac' strict in r, so the r*n does not build up a thunk
06:48:45 <Cale> ^^ It's something to do with whatever type lambdabot has in scope as Natural
06:48:59 <quchen> Cale: Oooh.
06:49:06 <stobix> quchen: Ah, so basically forcing evaluation at each end point?
06:49:08 <quchen> Cale: It’s not Unsigned-Integer?
06:49:14 <quchen> stobix: Yes. It’s a bang pattern.
06:49:28 * stobix has never used them, actually :/
06:50:12 * stobix probably should've used them once or twice. They seem like a good way to save memory sometimes.
06:50:30 <quchen> stobix: They just add nicer syntax compared to seq.
06:51:04 <quchen> > let fac :: GHC.Natural -> GHC.Natural; fac = fac' 1; fac' !r 0 = r; fac' r n = fac' (r*n) (n-1) in fac 10
06:51:07 <lambdabot>  error:
06:51:07 <lambdabot>      Not in scope: type constructor or class ‘GHC.Natural’
06:51:07 <lambdabot>      No module named ‘GHC’ is imported.error:
06:51:12 <quchen> ಠ_ಠ 
06:51:27 * stobix googles seq
06:51:30 <Cale> Yeah, whatever it is, it's not from GHC
06:53:06 <quchen> stobix: (seq x y) is y iff x is not ⊥, otherwise it's ⊥. We use it to avoid thunk buildups by telling the compiler that it’s beneficial to evaluate this one value a bit further, basically.
06:53:11 <Cale> stobix: seq x y is _|_ whenever x is _|_, but y otherwise. Basically it informs the compiler that x will eventually need to be evaluated, thereby giving it the option of evaluating it immediately (which it will typically take)
06:53:28 <quchen> stobix: foldl' is the canonical example of something that makes good use of »seq«.
06:54:53 <stobix> ah, nice. I actually started reading https://wiki.haskell.org/Seq just now to kinda get the same thing. "Artificial dependencies forcing evaluation"-ish.
06:55:48 <quchen> Yes, pretty much.
06:56:16 <quchen> Seq is a bit complicated because there are a lot of wrong facts about it around. The core principle is very simple though.
06:56:27 <stobix> Sounds like monads. ;)
06:56:43 <merijn> stobix: But worse, because seq can't be defined *in* haskell
06:56:46 <quchen> seq is way more subtle ;-)
06:57:58 <stobix> ooh, since there's no way of expressing bottom?
06:58:15 <stobix> :t undefined
06:58:16 <lambdabot> a
06:58:20 <stobix> thanks, lambdabot 
06:59:23 <merijn> stobix: And no way of expressing evaluation order either
06:59:25 <stobix> Someone™ should do something about the syntax highlighting at https://wiki.haskell.org/Seq btw. ' is not a quote character in Haskell.
06:59:41 <kadoban> :t stobix
06:59:43 <lambdabot> error: Variable not in scope: stobix
06:59:44 <quchen> stobix: Someone™ should do that for Github as well
06:59:45 <merijn> Cale: seq has more guarantees than you said
06:59:45 <kadoban> :t seq
06:59:47 <kadoban> lol, sorry
06:59:47 <lambdabot> a -> b -> b
06:59:52 <stobix> merijn: ah, I guess.
07:00:21 <Cale> merijn: In particular?
07:00:31 <Cale> merijn: I gave the actual definition...
07:00:32 <merijn> "seq x y" guarantees both 'x' and 'f' are evalauted to WHNF after seq returns IFF both 'x' and 'y' are not bottom
07:00:54 <merijn> Cale: Pretty sure that GHC guarantees both arguments to be in WHNF after evaluation assuming no bottoms
07:01:16 <kadoban> Does it? I didn't actually know that
07:01:18 <merijn> stobix: Note, in particular, that there is no statement about the order in which 'x' and 'y' are evaluated
07:01:37 <quchen> merijn: No! :-þ
07:01:47 <stobix> quchen: Oh? I usually use bitbucket, so I'm fairly oblivious to githubs parsefails.
07:01:48 <Cale> merijn: I don't know if it ever makes use of the option, but it would be within its rights not to evaluate x if it already knew for some reason that y would be bottom.
07:01:49 <merijn> GHC docs state: "Evaluates its first argument to head normal form, and then returns its second argument as the result."
07:02:03 <quchen> seq (error "a") (error "b") might not evaluate the "a" branch, since the "b" branch is ⊥ already
07:02:08 <Cale> merijn: It usually never discovers this.
07:02:09 <stobix> merijn: Not even if statements?
07:02:10 <merijn> Cale: Right, but that's not something I covered in my description ;)
07:02:49 <Cale> merijn: Well, I'm assuming you meant 'y' when you wrote 'f'
07:03:02 <merijn> eh, yes
07:03:11 <merijn> Cale: I did
07:03:20 <merijn> Cale: But I did specify IFF both 'x' and 'y' are not bottom
07:03:42 <merijn> As the order of evaluation of 'x' and 'y' is not guaranteed you cannot say anything about seq behaviour if one or both are bottom
07:03:50 <quchen> merijn: That sounds strange. Got a link to the docs?
07:04:00 <tabaqui1> I have a directory with stack package and sources in src
07:04:18 <Cale> merijn: Well, you can say that it won't result in any value which isn't bottom ;)
07:04:22 <tabaqui1> one of my modules want to import library from another directory
07:04:28 <merijn> "A note on evaluation order: the expression seq a b does not guarantee that a will be evaluated before b. The only guarantee given by seq is that the both a and b will be evaluated before seq returns a value. In particular, this means that b may be evaluated before a."
07:04:33 <Cale> Yes
07:04:39 <merijn> Cale: Sure, but we can distinguish bottoms in IO :)
07:04:48 <Cale> So, e.g. seq x (seq y z) = seq y (seq x z)
07:04:56 <Cale> and  seq x x = x
07:05:13 <merijn> quchen: https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#v:seq
07:05:18 <tabaqui1> if I put this directory in extra-header-dirs, my sources still cannot find them
07:05:35 <merijn> Cale: I think you're "not disagreeing" with me, but misinterpreting what I said? :)
07:05:37 <tabaqui1> how can I import code without creating project for it?
07:06:14 <Cale> merijn: Possibly, I'm pretty distracted at the moment
07:06:46 <merijn> Cale: Your intial description said the compiler "may" evaluate x when evaluating "seq x y", but GHC pretty clearly states that it *will* do that
07:06:54 <merijn> Cale: Which is a lot more reliable
07:06:56 <markus3> tabaqui1: if your stack root is same as cabal root, then hs-source-dirs in the cabal file
07:07:06 <markus3> tabaqui1: note that I've never tried this
07:07:09 <quchen> merijn: I know that sentence, but not the first one you mentioned, »Evaluates its first argument to HNF, and then …«
07:07:29 <quchen> merijn: Maybe that’s a GHC thing. The Report does not demand this.
07:07:38 <merijn> quchen: That's what the hoogle results for "seq" showed
07:08:01 <merijn> quchen: Sure, the report doesn't specify a thing about seq because the report doesn't cover evaluation order at all
07:08:04 <tabaqui1> markus3: it works, thanks
07:08:11 <quchen> Hah, so Hoogle has hardcoded wrong information. :-s
07:08:15 <merijn> quchen: You can't reason about 'seq' at all if you only consider the report
07:08:37 <merijn> quchen: Whereas you *can* reason about GHC's implementation of seq
07:08:40 <markus3> tabaqui1: yw
07:09:28 <quchen> merijn: Sure you can reason about the Report’s seq. You know that when you get a non-bottom value out of it, the first argument was not bottom.
07:09:54 <merijn> quchen: ok, but that's not quite what I meant :)
07:10:01 <quchen> Agreed. :-)
07:10:04 <merijn> I meant reasoning about performance/program behaviour
07:10:36 <merijn> i.e., the only reason seq actually is useful in foldl' is because we know more than just the report :)
07:12:02 <Cale> merijn: If y is bottom, then it may not evaluate x.
07:12:22 <merijn> Cale: Sure, but that doesn't contradict what I said
07:12:29 <Cale> Uh, okay.
07:12:31 <quchen> merijn: seq enables a sufficiently smart compiler to do optimizations during strictness analysis, it’s not all about directly evaluating it
07:12:56 <merijn> Cale: I said that IFF neither are bottom both 'x' and 'y' will be in WHNF at the end. Which is stronger than "they may or may not be evaluated"
07:13:03 <quchen> For example, (seq x (seq y z)) is equivalent to (seq y (seq x z)) according to the Report.
07:13:25 <merijn> Cale: If either are bottom you get a random choice of bottom (assuming we consider bottoms distinguishable in IO) and you can't know which
07:13:31 <Cale> merijn: I said that seq x y will be bottom when x is, and will be equal to y otherwise
07:13:50 <Cale> Which is a fairly complete description of what it means
07:13:50 <merijn> Cale: Right, but that omits the fact that 'x' will be WHNF
07:13:57 <merijn> (in GHC)
07:14:07 <quchen> Cale: The »otherwise« is a bit misleading, it suggests an order.
07:14:31 <quchen> Cale: It’s fine to first force y and let everything finish, and then decide to crash at the last moment because x is ⊥.
07:14:35 <merijn> By objection is not an implied order, but that it implies there is no change in 'x' as a result of seq
07:14:48 <Cale> quchen: Also, that sometimes occurs.
07:15:02 <Cale> GHC *may* evaluate y first
07:15:17 <quchen> Yes.
07:15:34 <Cale> It tends not to, but it's okay to do so, and there are cases in which it will.
07:16:11 <quchen> Yes. (We’re arguing for the same side here I think.)
07:16:13 <merijn> quchen: Yes, I agree with the "seq x (seq y z)" == "seq y (seq x z)" claim
07:16:43 <quchen> merijn: Ah, I see now, that does not contradict your (and the GHC manual’s) claim
07:16:46 <quchen> I thought it did
07:16:47 <merijn> Yes, I'm pretty sure Cale took my clarification as contradiction and we're basically arguing nothing :)
07:17:08 <Cale> I was just confused that you claimed that I didn't completely specify seq
07:17:19 <Cale> But I gave its definition according to the Report.
07:23:20 <quchen> Cale: The GHC manual specifies a specialized version of the Reports seq.
07:23:28 <quchen> That’s what we talked about, I think. :-)
07:23:55 <merijn> Yes, because the report doesn't actually help you understand why, say, seq makes foldl' better
07:27:52 <c_wraith> What's a case where seq actually has desirable properties over pseq?
07:27:53 <quchen> A sufficiently stupid compiler could still overflow foldl', yes.
07:28:04 <Cale> A compiler would be within its rights not to compile foldl' any better than foldl, but in practice the additional strictness guarantee is enough of a hint for it to do the evaluation more efficiently.
07:28:09 <merijn> c_wraith: You care about order of operations?
07:28:24 <c_wraith> merijn: pseq gives stronger guarantees about ordering, not weaker
07:28:41 <merijn> c_wraith: Oh, I read it reverse
07:28:41 <quchen> c_wraith: seq is somewhat commutative, leaving the compiler more liberties in optimizing things
07:29:00 <jhrcek> Can someone please explai to me why the following doesn't result in: Left "error"?
07:29:01 <merijn> c_wraith: Stronger ordering rules out, say, evaluating in parallel
07:29:08 <jhrcek> ghci> fail "error" :: Either String ()
07:29:23 <merijn> :t fail
07:29:24 <lambdabot> Monad m => String -> m a
07:29:26 <jhrcek> It results in  *** Exception: error
07:29:39 <quchen> jhrcek: You cannot implement error for the (Either a) Monad, only for (Either String)
07:29:43 <c_wraith> jhrcek: several years ago, the Monad instance for Either was changed to work for Either a, instead of Either String
07:29:54 <Cale> jhrcek: Because the instance of Monad for Either e you have in scope is polymorphic in e
07:29:57 <merijn> Also, fail is a horrible abomination
07:30:01 <c_wraith> jhrcek: Which made it more generally useful, but it meant fail must behave this way
07:31:38 <quchen> merijn: Wait a couple of releases until MonadFail ;-)
07:31:44 <merijn> quchen: I know :)
07:31:55 <Cale> Wait, what?
07:31:58 <c_wraith> Is MonadFail slated for 8.4?
07:32:05 <bollu> quchen: do you have some time? I had questions on STG implementation :)
07:32:07 <c_wraith> I guess 8.2 is "soon" now.
07:32:18 <c_wraith> or maybe soon™
07:32:20 <quchen> c_wraith: Go-live certainly not, but maybe the warnings are switched on by default then.
07:32:25 <quchen> Maybe in 8.6.
07:32:38 <quchen> There’s a strong bias towards not breaking things (or people).
07:33:06 <bollu> quchen: when trying to evaluate a lambda, (vs \pi xs -> expr) ws
07:33:11 <c_wraith> This seems much slower than FTP or AMP...  Too many people broken by those?
07:33:17 <bollu> quchen: what exactly are the "vs" and the "xs"?
07:33:29 <bollu> quchen: I understand that they are "free" and "bound" variables
07:33:37 <bollu> quchen: but with reference to STG, what are they?
07:33:41 <quchen> bollu: xs are the lambda parameters, just like in Haskell’s \xs -> expr
07:34:03 <quchen> vs are the free variables in expr, for example (take) is free in \xs -> take 1 xs
07:34:04 <bollu> quchen: yep, but, like, for the machine, how do I evaluate "expr" with respect to xs?
07:34:11 <quchen> It’s stuff that has to be "in scope"
07:34:12 <bollu> quchen: I'm asking with respect to operational semantics
07:34:18 <bollu> quchen: the paper isn't super clear on this
07:35:01 <merijn> bollu: Heap allocations for the closure
07:35:16 <quchen> You evaluate expr by pushing the arguments onto the stack, then evaluating the lambda. That in turn pops the arguments and binds them to variables (in a local environment) and evaluates expr in that environment.
07:35:22 <kqr> is there a haskell library to parse arbitrary dates? (i.e. dates where you don't know the exact format)
07:35:44 <bollu> quchen: I see. and, where will the free variables be? (how does the expression access the free variables)? will that be through the heap?
07:35:44 <merijn> kqr: I don't think such a thing is unambiguously possible?
07:35:51 <quchen> merijn: There’s no heap allocation in lambda evaluation, only »let« allocates on the heap
07:36:03 <c_wraith> quchen: misfire! :)
07:36:15 <kqr> merijn, absolutely not unambiguously possible. but I'm happy with ambiguously possible!
07:36:16 <merijn> quchen: I'm unsure about the exact part we're talking about :)
07:36:25 <merijn> kqr: I'm not aware of one
07:36:33 <quchen> c_wraith: Huh?
07:36:39 <merijn> kqr: And godspeed...
07:36:46 <c_wraith> quchen: pretty sure that last message was meant for bollu, not merijn 
07:36:50 <quchen> c_wraith: There are some people that are very much opposed to AMP even
07:37:04 <merijn> quchen: I wasn't implying lambda evaluation allocated
07:37:08 <quchen> Graham Hutton for example
07:37:25 <bollu> Cale: equality of functions in HoTT is pointwise equality right?
07:37:27 <merijn> quchen: But that the free variables are stored in a heap allocation, presumably done by an earlier partial application
07:37:33 <quchen> Oh. Yes.
07:37:35 <bollu> Cale: I'm now reading the fibrations part
07:37:57 <merijn> bollu: ^^
07:38:02 <mlehmk> well, how would you know, whether 10-03-2016 is either 2016-10-03 or 2016-03-10?
07:38:04 <quchen> bollu: Free variables have to be in the environment. There are two environments: global and local.
07:38:25 <Ferdirand> parse this -> Haskellday, Blahbedyblah the 42+5i'th, year zAn+u/d==
07:38:25 <quchen> Global is »all top-level definitions«, local is »everything else bound during the run of the program«, roughly
07:38:29 <kqr> merijn, hehe thanks. I might get lazy and call out to an external binary that does this... or I make the user specify which date format they intend to use
07:38:36 <bollu> quchen: I see.
07:38:38 <quchen> bollu: »let« adds definitions to the local environment, for example.
07:38:38 <kqr> mlehmk, you wouldn't, you'd guess
07:38:48 <mlehmk> kqr, or just get it from locale
07:38:58 <quchen> »case x of k -> expr« adds »k« to the local environment.
07:39:13 <mlehmk> the current locale should tell you whether month or day first
07:39:29 <quchen> merijn: Actually, case-patterns might also allocate on the heap. Not sure about this anymore. 
07:39:30 <bollu> quchen: I see
07:39:48 <kqr> mlehmk, in this case it's about dates emitted from arbitrary third-party applications, which I don't think I can assume follows the locale
07:40:27 <mlehmk> kqr, then just hope you have a day > 12 somewhere
07:40:41 <mlehmk> and of course 4 digit years
07:40:54 <mlehmk> 15.10.12
07:41:39 <kqr> hehe. I have trouble parsing expiration dates on food. I don't expect my computer to do very well
07:42:02 <kqr> though I could hard-code a few common formats and give the user the option to specify in more detail
07:42:08 <kqr> that's probably the best compromise
07:42:25 <quchen> bollu: In Haskell, you don’t have to hand the free variables’ values explicitly to functions, they read them automatically from »what’s in scope«. In STG, this is made explicit.
07:42:55 <quchen> This explicitness is very annoying to write by hand. It’s *so* annoying that PHP has it as a feature.
07:43:12 <mlehmk> variables in haskell?
07:43:27 <mniip> there are variables in haskell yes
07:43:36 <mvdw> Imagine programming without assignment.
07:43:37 <mlehmk> that's a new one to me
07:43:42 <mniip> "\x -> ...", x is a variable
07:43:48 <mlehmk> no
07:43:49 <bollu> quchen: hm
07:43:50 <quchen> Haskell doesn’t have assignment, it has bindings.
07:43:54 <mniip> yes it is
07:44:02 <mniip> mathematically speaking
07:44:05 <mlehmk> x is a parameter there
07:44:15 <quchen> SKI doesn’t even have bindings. :-)
07:44:17 <mlehmk> or function argument
07:44:21 <mniip> x is called a variable
07:44:35 <Cale> bollu: Equality of functions in HoTT is via the identity type like anything else.
07:44:47 <mlehmk> I understand variable as a mutable holder for values
07:44:47 <bollu> Cale: ah
07:45:03 <mniip> mlehmk, well the mathematical definition of a variable is different
07:45:19 <Cale> bollu: However, once you get univalence, that implies functional extensionality
07:45:26 <mlehmk> indeed
07:45:46 <merijn> mlehmk: That's a perversion of the mathematical notion of variables
07:45:49 <bollu> Cale: oh, interesting. so, to show that ap_f (p . q) = ap_f p . ap_f q, I need to use path induction?
07:45:57 <merijn> mlehmk: "f(x) = x^2" <- is x called a variable?
07:46:26 <Cale> bollu: In MLTT (the system without univalence or higher inductive types), it's consistent that for some functions f and g: A -> B, we have Pi (x:A), f x = g x, but not (f = g)
07:46:27 <merijn> They're called variables, because they vary across applications of the function
07:46:47 <merijn> This idea that variables are mutable is a post-hoc invention by programmers
07:47:01 <mniip> I think "because their value can change within the context of the same mathematical expression" is clearer
07:47:57 <bollu> Cale: oh, that is interesting
07:48:04 <bollu> Cale: does that hold in HoTT as well?
07:48:12 <Cale> bollu: In HoTT that doesn't happen.
07:48:14 <bollu> Cale: so, "pointwise equality does not mean 'true' equality"?
07:48:44 <Cale> bollu: You can prove it in a couple ways: one uses univalence, and another uses the interval higher inductive type.
07:49:16 <bollu> Cale: I see. I haven't reached univalence yet. I plan on getting through chapter 2 first
07:49:21 <bollu> Cale: I'll keep that in mind though, ty
07:50:03 <Cale> bollu: The book defines f ~ g := Pi (x:A), f x = g x
07:50:10 <Cale> read as "f is homotopic to g"
07:51:02 <Cale> The idea being that we're providing a (continuously varying) choice of path from f x to g x, for each point x in the domain.
07:51:32 <bollu> Cale: ah
07:51:49 <bollu> Cale: and does the univalence axiom allow us to convert homotopy to equality?
07:52:04 <tsahyt> does hsc2hs handle unions? I've got quite a few tagged unions in C here that I need to marshal back and forth, and I've got a segfault happening
07:52:08 <Cale> It's a well known basic result in classical homotopy theory that this is the same as a path in the function space
07:52:32 <tsahyt> for example https://github.com/tsahyt/clingo-haskell/blob/master/src/Clingo/Raw/AST.hsc#L398
07:52:59 <tsahyt> running an example with valgrind results in a few invalid reads and I'm having serious trouble tracking this down
07:53:01 <Cale> and yeah, with univalence, it's possible to prove an analogous result
07:53:45 <tsahyt> the corresponding struct: https://github.com/potassco/clingo/blob/master/libgringo/clingo.h#L2039
07:53:58 <bollu> Cale: why is it that in HoTT, the underlying space is assumed to be continuous? it's almost as if you apply the discrete topology to every space we have and then use topological language
07:54:09 <bollu> Cale: is there an intuitive reason for assuming thing?
07:54:10 <bollu> this*
07:54:33 <Cale> bollu: Spaces aren't continuous, continuity is a property of functions.
07:55:11 <bollu> Cale: but the discrete topology allows every function "from" it to become continuous, correct? since the pre-image of anything will be open?
07:55:25 <Cale> Oh, sure.
07:55:27 <tsahyt> hmm, apparently the sdl2 package does exactly the same thing, so that's probably not it
07:57:32 <Cale> bollu: Well, the reason we say that functions in HoTT are continuous is that this gives the right intuition about what sorts of functions you may have when combined with everything else regarding paths.
07:58:34 <Cale> bollu: When we have some path p: x = y, we obtain some path ap f p: f x = f y
07:59:32 <Cale> bollu: Which, regarded as a statement about equality, is blindingly obvious
07:59:37 <bollu> yes
07:59:53 <Cale> But regarded as a geometric statement about paths, is less obvious, if you're considering that f might be a discontinuous function.
08:00:43 <bollu> Cale: exactly! so it appeared as if HoTT simply applies the discrete topology to make everything continuous. But that's the wrong geometric intuition?
08:01:05 <Cale> No, not every type has the discrete topology
08:01:34 <Cale> But all the h-sets could be thought of that way.
08:04:02 <bollu> Cale: so, what is the actual geometry of a type?
08:04:15 <Cale> It depends on the type
08:06:08 <Cale> We expect it to be possible to define types corresponding to the homotopy type of any sufficiently well-behaved topological space. So for example, you can get circles and spheres and tori, as well as higher dimensional things.
08:06:19 <bollu> hm
08:06:30 <bollu> but we also choose to interpret haskell types in HoTT
08:06:50 <Cale> Do we?
08:06:59 <bollu> I mean, we can, right?
08:07:13 <Cale> Haskell types are a bit strange, due to bottoms
08:07:29 <Cale> I don't know, it might be possible to provide a faithful representation of some sort.
08:07:40 <Cale> But it's not entirely straightforward.
08:07:43 <bollu> ah, hm.
08:07:54 <bollu> also, you were telling me how to encode set theory the other day in HoTT
08:07:57 <bollu> can we pick that up? :)
08:07:59 <bollu> again?
08:08:34 <quchen> Isn’t there a chapter about this in HoTT?
08:08:36 <Cale> I have a fair amount of work I should really get to
08:09:01 <bollu> Cale: ah, OK
08:09:06 <Cale> and yeah, the HoTT book talks about all this stuff :)
08:09:15 <bollu> Cale: ah :)
08:09:22 <Cale> But later I wouldn't mind going over it
08:10:03 <Cale> I don't remember bringing up set theory as a whole
08:10:13 <Cale> But there are some bits of set theory which work out really nicely in HoTT
08:10:38 <petercommand> The first chapter of HoTT is comparing set theory and type theory IIRC
08:10:54 <petercommand> the HoTT book
08:11:33 <Cale> You can define a type of all h-sets:  Set := Pi(A: Type), isSet(A) -- where isSet(T) := Pi(x,y: T), Pi(p,q: x = y), p = q
08:13:17 <Cale> It turns out that Set itself is not an h-Set, but rather a 1-type: the paths in Set correspond to bijections, so there will generally be n! paths between two sets of n elements.
08:15:12 <Cale> There's an operation called 0-truncation which will turn any type into an h-Set (something of dimension 0), and if you do that to Set, you get a reasonable definition for a type of cardinalities.
08:22:57 <ph88> does guard in the list monad do the same as filter ?
08:23:28 <bollu> Cale: wow, okay
08:23:33 <bollu> Cale: that sounds super cool
08:23:51 <quchen> ph88: filter can be implemented in the list monad, yes.
08:24:32 <quchen> :t [\p xs = do { x <- xs; guard (p x); pure x }, filter]
08:24:33 <lambdabot> error:
08:24:33 <lambdabot>     parse error on input ‘=’
08:24:33 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
08:24:37 <quchen> :t [\p xs -> do { x <- xs; guard (p x); pure x }, filter]
08:24:39 <lambdabot> [(b -> Bool) -> [b] -> [b]]
08:27:03 <quchen> We can even Quickecheck in here:
08:27:04 <quchen> ?check \p xs -> do { x <- xs; guard (p x); pure x } == filter p (xs :: [Int])
08:27:09 <lambdabot>  +++ OK, passed 100 tests.
08:27:16 <quchen> ph88: ^ :-)
08:33:17 <ph88> oh didn't know we had qc here :P
08:35:44 <quchen> ph88: Just be careful, it likes to default things to (), leading to awkward results sometimes.
08:35:49 <quchen> ?check \xs -> xs == reverse xs
08:35:51 <lambdabot>  +++ OK, passed 100 tests.
08:35:57 <quchen> ?check \xs -> xs == reverse (xs :: [Int])
08:35:59 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 1 shrink):
08:36:00 <lambdabot>  [2,1]
08:36:58 <ph88> oh right
08:37:39 <ph88> how can i create a record without sugar ?
08:40:26 <ph88> can i create it as a tuple ?
08:41:32 <quchen> Record without sugar?
08:42:58 <ph88> yes without naming the fields .. just using the same order as it was defined
08:43:37 <quchen> data ManyFields = ManyFields Int Char Bool
08:43:38 <ph88> data Foo = F { field1 :: String, field2 :: String }      let a = F "hello" "world"   or  something like this
08:43:56 <quchen> let ManyFields i c b = … in …
08:44:12 <ph88> i like for the field names to be optional, so keep a record
08:44:29 <ph88> i know you can pattern match records as tuples ... so i thought maybe i can create them this way as well
08:44:42 <quchen> Sure you can
08:44:49 <ph88> i can't find the syntax for it
08:44:50 <quchen> Your example should work
08:45:20 <quchen> ?let data Ph88 = Ph88 { field1 :: Text, field2 :: Text }
08:45:22 <lambdabot>  .L.hs:158:28: error: Not in scope: type constructor or class ‘Text’
08:45:22 <lambdabot>  
08:45:22 <lambdabot>  .L.hs:158:44: error: Not in scope: type constructor or class ‘Text’
08:45:27 <quchen> Wat.
08:45:41 <quchen> ?let data Ph88 = Ph88 { field1 :: String, field2 :: String } deriving (Eq, Ord, Show)
08:45:44 <lambdabot>  Defined.
08:45:51 <quchen> > Ph88 "hello" "world"
08:45:53 <lambdabot>  Ph88 {field1 = "hello", field2 = "world"}
08:45:58 <ph88> oooh
08:46:12 <ph88> i was getting an error in my program .. i guess it was not related to this then :/
08:46:39 <ph88> oh i had 1 field too many haha
08:50:41 <NibbleNinja> [1,3..7] why is this = [1,3,5,7]
08:50:51 <NibbleNinja> What does ".." mean?
08:51:36 <kadoban> NibbleNinja: It means continue the pattern
08:51:37 <allenj12> .. is like telling haskell to "fill" in the pattern where the default is 1,2 etc...
08:51:51 <NibbleNinja> Aha
08:51:53 <allenj12> so [1..3] is [1,2,3]
08:52:02 <allenj12> NibbleNinja: you can also do [1..]
08:52:16 <NibbleNinja> So in this sense it's bc they is a 2 difference+
08:52:21 <allenj12> which is an "infinite" list, accomplished my lazyness
08:52:23 <NibbleNinja> ?*
08:52:24 <allenj12> yes
08:52:27 <lambdabot> Maybe you meant: v @ ? .
08:52:29 <NibbleNinja> Alright, thx.
08:52:48 <NibbleNinja> allenj12 have time for uno more?
08:52:50 <allenj12> how do i activeate lambdabot?
08:52:53 <allenj12> yea
08:52:56 <NibbleNinja> woo
08:53:19 <allenj12> ,take 5 [1..]
08:53:20 <c_wraith> to be very exact about it, [a, b .. c] is desugared into enumFromThenTo a b c
08:53:41 <NibbleNinja> what does desugared mean?
08:53:42 <allenj12> c_wraith: how do i lambdabot? haha im an irc scrub
08:53:47 <NibbleNinja> allenj12 https://gist.github.com/anonymous/51732651457f892ea4116bc3fe26c168, tell me the answer of this.
08:54:17 <c_wraith> allenj12, > then a space, then the expression 
08:54:35 <allenj12> > take 5 [1..]
08:54:37 <lambdabot>  [1,2,3,4,5]
08:54:43 <allenj12> c_wraith: thanks
08:55:36 <allenj12> NibbleNinja: kinda of an odd little snippit, but lets break it down
08:55:46 <allenj12> the first X correlates with the last line here
08:55:50 <NibbleNinja> it's from an old test so
08:56:08 <allenj12> the second, x in f y just applies to that line
08:56:28 <allenj12> so f takes a 'y' and x is y+1
08:56:45 <allenj12> in x+y
08:56:48 <NibbleNinja> oh right, they're trolling with that second x.
08:57:14 <allenj12> NibbleNinja: that last part is actually confusing,
08:57:19 <NibbleNinja> it really is
08:57:37 <allenj12> because how can you have two seperate non-related computations in a 'in' like that
08:57:46 <allenj12> maybe someone can clarify if im missing something
08:57:56 <ph88> if i have multiple functions for filter like  a -> Bool   how can i chain them together so all apply to the input list ?
08:58:20 <glguy> ph88: You could use 'all'
08:58:56 <ph88> all also just takes 1 function
08:59:08 <allenj12> NibbleNinja: im not a haskell expert but i would assume that dosnt even compile
08:59:19 <NibbleNinja> allenj12 it does, since it's part of a test
08:59:49 <allenj12> NibbleNinja: that last part might be an actual test constraint
08:59:58 <allenj12> which could make sense
09:00:02 <NibbleNinja> it's just added to confuse or?
09:00:45 <NibbleNinja> https://gist.github.com/anonymous/557682ffd786f5dce7869a571f33db1c
09:00:47 <NibbleNinja> looks so weird
09:01:13 <glguy> ph88: Yeah, that's OK. Your list goes in the second argument, not the first
09:01:25 <NibbleNinja> oh I got it
09:01:36 <ph88> glguy, where goes the second function ?
09:01:44 <allenj12> NibbleNinja: i feel like i need to see more code
09:01:49 <allenj12> but if you got it good
09:02:43 <glguy> ph88: Your mission is to reason out how to use 'all' with a list :: [a -> Bool], to produce a new function  a -> Bool
09:03:00 <NibbleNinja> allenj12 https://gist.github.com/anonymous/b0693baf90e871f22c0d2b352a03bfb7
09:03:14 <NibbleNinja> I believe it's just a troll thing, to confuse you, it will never reach that part I assume.
09:04:34 <cousteau> I think I already asked this a long time ago when I haskell'd for the first time but... why does [0.1,0.3..1] stop at 1.0999999 and not at 0.899999?  (as pointed out in http://learnyouahaskell.com/starting-out)
09:05:34 <cousteau> [1,3..10] does stop at 9, and although there's a small difference between 0.9999 and 1, there's a huge difference between 1 and 1.09999
09:06:16 <cousteau> and for some reason this jumps from 0.9-ish to 1.1-ish
09:07:38 <c_wraith> cousteau, because that's the way it's specified to work. why is it specified that way? who knows, it's nonsense, never use the Enum instance for Float or Double. 
09:08:02 <cousteau> *how* is it specified?
09:08:22 <NibbleNinja> allenj12 i dont think i solved it correctly, ugh.
09:08:45 <cousteau> "if the value is a float, then iterate until you get past that float, but include that float"?
09:09:42 <c_wraith> cousteau, https://www.haskell.org/onlinereport/basic.html section 6.3.4
09:09:51 <cousteau> c_wraith, also, [1,3..10] is an Enum, not just a list?
09:10:41 <c_wraith> cousteau, desugaring any list expression that uses .. goes through the Enum class. 
09:11:04 <cousteau> I see
09:11:36 <allenj12> NibbleNinja: sorry, was eating lunch haha, on very quick glance it seems to work out
09:11:43 <cousteau> oh wait, a class is not like a C++/Python class, but more like a constructor?
09:11:44 <NibbleNinja> I fixed it
09:11:51 <NibbleNinja> it's quite simple, once i saw it
09:12:26 <allenj12> cousteau: class more like a java interface
09:12:41 <c_wraith> cousteau, well, it's certainly not like a C++ or python class. it's just a set of operations a type can choose to support. 
09:12:53 <NibbleNinja> What is a variant definition?
09:13:00 <cousteau> I see
09:13:06 <cousteau> so more like a module
09:13:09 <kuribas> cousteau: Integer is Enum not [Integer]
09:13:14 <c_wraith> cousteau, an instance declares that a type supports a class's operations, and how. 
09:13:16 <allenj12> c_wraith: whats the C++ version of interface called again? it might be better to explain
09:13:40 <cousteau> ...well, a bit related to inheritance I guess
09:13:42 <c_wraith> cousteau, yeah, it overlaps with an ml module in a lot of ways. 
09:14:36 <c_wraith> cousteau, the main difference is that instances must be unique. a type can only implement a class in one way globally. 
09:17:07 <matrium> hi, what's the right way to sequence dependent operations until a certain goal is reached? something like a fold until or so
09:17:57 <lyxia> that description is too vague
09:18:39 <lyxia> matrium: what do are your actual operations? What types do they have?
09:19:08 <matrium> I have to perform an operation on some data until I reach a termination criterion
09:19:54 <matrium> more a transformation than an operation
09:20:05 <lyxia> operation :: a -> a ?
09:20:12 <lyxia> terminationCriterion :: a -> Bool ?
09:20:13 <NibbleNinja> What does this mean "x:y:xs", what is x and y in this?
09:20:22 <glguy> :t until
09:20:24 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
09:20:40 <c_wraith> matrium, in general, we can provide much better answers when given types. 
09:21:00 <lyxia> NibbleNinja: a list, with first element x, second element y, and remaining elements xs
09:21:06 * cousteau enumFromThenTo' a b c = if (b>a && c<a) || (b<a && c>a) then [] else a : (enumFromThenTo' b (b+b-a) c)  --this works properly
09:21:07 <c_wraith> matrium, because types really specify things concisely and accurately 
09:21:27 <matrium> lyxia: yes
09:21:30 <NibbleNinja> lyxia oh can I do that like this to get the third element? (x:y:z:xs)
09:21:37 <lyxia> yes
09:21:44 <NibbleNinja> what happens if there are only 2 elements?
09:21:51 <lyxia> then it doesn't match.
09:22:02 <NibbleNinja> aha
09:22:51 <matrium> lyxia: thanks, until looks like what I was searching for
09:22:52 <cousteau> damn, Haskell reminds me of C++ templates
09:23:04 <cousteau> and variadic templates and all that
09:23:08 <Cale> cousteau: Why is that?
09:23:10 <NibbleNinja> cousteau if you write Haskell backwards you get C++.
09:23:11 <NibbleNinja> magic.
09:23:14 <c_wraith> cousteau, the syntax is better. :) 
09:23:23 <lyxia> matrium: thank glguy! 
09:23:24 <cousteau> I thought you got lleksah
09:23:46 <cousteau> Cale, I think it is because I understand neither and both look like magic to me
09:23:52 <Cale> ah, okay
09:24:02 <c_wraith> Cale, it's not a unique observation. have you seen the series of blog posts on category theory that do everything in Haskell and c++ templates? 
09:24:22 <cousteau> well, basically I recently decided to learn about variadic templates in C++ without knowing C++, so go figure...
09:24:23 <matrium> glguy: sry, thanks for the hint!
09:24:35 <Cale> Yeah, it's not like they have nothing in common, just seemed like an observation which could use more exposition :)
09:25:06 <NibbleNinja> What do you call the O(n), omega(n) and beta(n) things? I need to look it up.
09:25:36 <lyxia> NibbleNinja: https://en.wikipedia.org/wiki/Big_O_notation
09:25:41 <NibbleNinja> Danke.
09:25:52 <cousteau> one of the things that gave me this idea was what lyxia said about "then it doesn't match"
09:26:08 <cousteau> basically both haskell and C++ templates seem to revolve around the idea of variadic templates
09:27:31 <AndreasK>  Has anyone here used sdl2-ttf? I seem to always overwrite my buffer when i clip the fonts to the window :/
09:27:33 <cousteau> ...then again C++ can limit the length of the arguments whereas haskell returns a function to be called multiple times
09:27:42 <lyxia> NibbleNinja: I've never seen beta(n) in this context though
09:28:08 <NibbleNinja> Ω
09:28:10 <NibbleNinja> Isn't that omega?
09:28:31 <NibbleNinja> or is that alpha?
09:28:55 <lyxia> Omega.
09:29:12 <allenj12> i know theres a haskell-game but its pretty slow right now. Does anyone have opinions on Helm or Hgammer3D
09:29:22 <allenj12> or anyother ways to create games in haskell
09:30:51 <shapr> I repeatedly want iterateUntil
09:30:54 <NibbleNinja> why not switch language for that allenj12 ?
09:32:02 <rgollamu> quit
09:32:22 <bollu> can I have some explain Cata to me? the bannanas paper just throws the definition at you and doesn't explain why that is cata
09:32:28 <allenj12> NibbleNinja: i worked on a game full time in java for 8 months as a possible startup prototype, I also tried Unity before that. Although Jmonkey was a good engine etc... I really did miss haskell for alot of reasons. This time this game is more of a passion project, so theres no reason to go for something else
09:32:40 <bollu> or is there a reference for cata/ana/hylo 
09:32:46 <bollu> in the "general" form given in the paper?
09:32:54 <NibbleNinja> What about not using java allenj12
09:33:04 <allenj12> NibbleNinja: and using...
09:33:21 <NibbleNinja> Python, yeee
09:34:02 <allenj12> NibbleNinja: Pygame, is ok, but at that point why would i go with it. If im not using the big engines like unity or unreal
09:34:25 <NibbleNinja> Was just joking, but it's more legit than using Haskell I assume?
09:34:28 <NibbleNinja> for game purposes
09:34:54 <shapr> bollu: cata is fold/reduce, ana is unfold, hylo is unfold/transform/fold
09:34:56 <NibbleNinja> I saw someone who used Haskell + Swift to make Flappy Bird
09:34:59 <allenj12> NibbleNinja: well, i mean the only legit way to build games is in 
09:35:09 <allenj12> lisp that you can inline assembly
09:35:18 <allenj12> (pressed enter by accident)
09:36:06 <bollu> shapr: yes, but like, that's a very "narrow" view of it, right?
09:36:18 <bollu> shapr: I want to see it the way its described in the paper (with respect to Fix)
09:36:44 <shapr> bollu: oh, I can't help there, sorry.
09:40:17 <NibbleNinja> allenj12 what is the VARIANT for in Haskell?
09:41:57 <puregreen> after my revision on GHC Phab has been accepted, should I do “arc land” by myself or someone else has to do it? https://phabricator.haskell.org/D2882
09:42:26 <allenj12> NibbleNinja: id have to see what you mean,"variant type is also used to refer to an algebraic data type (comparable to a tagged union), whose constructors are often called variants. In languages such as OCaml and Haskell," pulled from wikipedia haha
09:45:26 <NibbleNinja> allenj12 lets me show u an example
09:47:49 <allenj12> ok
09:50:16 <NibbleNinja> allenj12 https://gist.github.com/anonymous/93c9017d7f719ceb5b62af8279dfa739
09:51:47 <allenj12> NibbleNinja: that seems to not really show anything unless im missing it, variant is only referred to the question and the one before it. It dosnt seem to point out a "variant" beast in the language itself
09:52:12 <NibbleNinja> true, but do you understand the question? because I surely don't.
09:54:13 <allenj12> NibbleNinja: its asking the difference between the function in that question and the function in the question before
09:54:14 <allenj12> i think
09:54:43 <NibbleNinja> no there is only 1 function called rempos.
09:55:48 <benzrf> does ghc have any dead code detection featuresd
09:55:56 <allenj12> NibbleNinja: are they written in different ways
10:00:23 <AndreasK> benzrf: https://wiki.haskell.org/GHC_optimisations#Dead_code_elimination. There might be more eliminated by the cmm stage as well
10:02:30 <benzrf> ah.... i meant something that will tell me which parts of my code are dead so that i dont accidentally leave them around :)
10:03:24 <AndreasK> benzrf: If you want to be warned about unused code (Why do you have it there if it's unused? Did you forget to type something?) you can use the -fwarn-unused-binds option (or just -Wall). 
10:03:32 <benzrf> oh, cool thanks!
10:04:13 <benzrf> i have it because i was refactoring something, stopped working on it, just came back to it like a month later
10:04:25 <benzrf> i dont remember which parts i was leaving there because they werent fully replaced yet
10:27:43 <fizbin> Micro-optimization request. I have a bunch of sorted lists (w/ no duplicate elements) and want to produce the sorted list that's the union of all the sorted lists. Is in fact the best way to do that S.toAscList . S.unions . map S.fromAscList ?
10:29:09 <kadoban> fizbin: Best by what measure?
10:30:16 <nitrix> Hi, I have a curious question.
10:30:25 <kadoban> That's not the most computationally efficient way, asymptotically. But that rarely matters all that much.
10:30:55 <nitrix> I'm aware of bottom values having the type `forall a. a`, but I've somewhat managed to create a bottom value of type `Int`. I'd like to know how it relates to the original concept.
10:30:57 <fizbin> kadoban: I suppose runtime is what I'm after. Doing this is currently 7.7% of my code's runtime according to the profile.
10:31:14 <nitrix> Presumably, it isn't bottom, it's just non-terminating?
10:31:21 <nitrix> a = b + 1; b = a + 1 ?
10:31:29 <pavonia> nitrix: Bottom is element of all types in Haskell
10:31:43 <nitrix> This wouldn't be a bottom then.
10:31:59 <nitrix> So what is it?
10:32:34 <AndreasK> Buttom is a value not a type afaik
10:32:56 <glguy> nitrix: There's no one distinguished "bottom" element
10:33:19 <nitrix> These three answers seems unrelated to the question.
10:33:29 <kadoban> fizbin: Offhand what comes to mind as more efficient is inserting all lists into a heap, with the key being the first element. Then, take the minimum, take the head of that list, put it back in (unless it's []). Repeat until the heap is empty.
10:33:37 <glguy> so if you have defined an Int value that never reduces to its normal form, then it's a "bottom"
10:34:12 <nitrix> glguy: But it doesn't inhabit every types though.
10:34:27 <glguy> that's fine, it doesn't have to
10:34:31 <kadoban> fizbin: Not sure that's the best possible thing, or even all that good. But it's better than O(n lg n), it's like ... O(n lg k), where k is the number of lists I believe? So unless the number of lists is huge it should eventually win by a lot. The question becomes "when is eventually?". But it's what I'd probably try.
10:34:35 <nitrix> Oh?
10:34:58 <kadoban> It's likely a lot more code than your one liner though too, though maybe not a ton.
10:35:24 <glguy> The notion of bottom inhabits all the boxed types, that's not to say that all bottom values inhabit all types
10:36:20 <monochrom> actually lifted types rather than boxed types
10:36:51 <AndreasK> For my former statement it seems I was wrong. Bottom is actually a type with no values at least according to wiki :x
10:37:26 <monochrom> but this runs dangerously closed to tautological because "lifted" just means "has bottom"
10:39:02 <monochrom> (unlifted boxed type is for the corner case of primitive array. primitive so you want no bottom, array so you have to put it on the heap and pass around a pointer, i.e., boxed)
10:39:27 <AndreasK> Just going by the definition any type of bottom is a subtype to every type. So wouldn't every bottom type also have type Int in a sense?
10:39:40 <AndreasK> At least for lifted types
10:39:49 <monochrom> there is no subtype. what wiki is this?
10:40:26 <AndreasK> https://en.wikipedia.org/wiki/Bottom_type: In subtyping systems, the bottom type is the subtype of all types
10:40:32 <mohsen_> Hi. I try to install happstack-server using cabal but I get this output: https://ptpb.pw/Soy1 the command I'm running is "cabal install happstack-server"
10:40:45 <monochrom> then it is not talking about Haskell. clearly.
10:40:55 <monochrom> go to #haskell-offtopic if you want to continue.
10:40:55 <nitrix> Isn't bottom a value?
10:41:09 <nitrix> Or can it exists at the type level too?
10:41:33 <orion> In "f x y = ..." is it more correct to call x and y "parameters" or "arguments"?
10:41:42 <glguy> parameters
10:41:43 <nitrix> orion: Parameters.
10:41:45 <zaquest> fizbin, i think this looks a lot like merge step from merge sort, so i'd do something like this http://lpaste.net/350159
10:41:52 <nitrix> orion: f x y, now x and y are arguments.
10:41:56 <dcoutts> mohsen_: it's saying you need a different version of ghc, check what ghc version you've got and what version the package needs
10:44:29 <AndreasK> nitrix: https://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Bottom_and_Partial_Functions seems to have more detail, but it mentions buttom as value as well as a buttom type
10:44:34 <mohsen_> dcoutts: It's written base ==4.* in the dependencies section of the package
10:45:16 <kadoban> zaquest: It is the merge step from merge sort, though that way of doing it seems inferior. If you think about it, you do every element from the first list (k-1) times, or sometihng like that. It should end up O(nk), for equal length lists, instead of O(n lg k)
10:45:32 <kadoban> Though to be fair the constants will likely be much better.
10:46:03 <dcoutts> mohsen_: and what version of ghc are you using?
10:46:18 <monochrom> No, there is still no "bottom type".
10:46:26 <mohsen_> dcoutts: there is a package installed on my machine named ghc and it's version 7
10:46:40 <dcoutts> mohsen_: what exact version?  ghc --version
10:47:24 <xcmw> Does anyone here know how to use vinyl? I know acowley does but he is away.
10:47:33 <dcoutts> mohsen_: (there were 5 major releases of ghc version "7", spanning several years)
10:47:34 <monochrom> oh, there is, but I think it's wrong.
10:47:38 <mohsen_> dcoutts: The Glorious Glasgow Haskell Compilation System, version 7.0.4
10:47:54 <glguy> xcmw: Always just ask the actual question
10:48:13 <dcoutts> mohsen_: ok, so that's too old. It'll have base 4.2 or something like that, and this package needs >= 4.4
10:48:22 <dcoutts> mohsen_: 7.0 is really very old now.
10:48:25 <cocreature> xcmw: I used it some point but as glguy said, without asking an actual question I can’t help you
10:48:59 <Gurkenglas> kadoban, "n*log n" <- are you sure? fromAscList is linear
10:49:40 <mohsen_> dcoutts: Is base version different from ghc version? I just ran yum update, so why is such an old version of ghc is still installed on my machine?
10:50:11 <xcmw> Am I doing this correctly? http://lpaste.net/350160 The built in rapply function did not work for me. Is there a better way?
10:50:28 <dcoutts> mohsen_: the base version is tied to the version of ghc, they are always upgraded together.
10:50:45 <monochrom> who wrote this? this is so full of self-contradictions on multiple dimensions.
10:50:51 <dcoutts> mohsen_: check where you're getting ghc from, /usr/bin vs say /usr/local/bin
10:51:08 <dcoutts> mohsen_: what distro & version has that old a ghc?
10:51:22 <Gurkenglas> fizbin, Data.List.sort is pretty much optimal for this case - just concat the lists and feed them into sort, or for what might be ridicolously little extra optimization copy mergeAll from http://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.OldList.html#local-1627439874 into your sourcecode
10:51:43 <Gurkenglas> (so the concat + split pass disappears)
10:51:56 <kadoban> Gurkenglas: Hmm ... no I'm wrong then I think. Though I'm also wrong because unions doesn't do what I thought it does. It ... does the O(nk) thing I think, in the worst case.
10:51:56 <int-e> good question, even debian wheezy (oldstable) has ghc 7.4.1
10:51:57 <fizbin> Gurkenglas: Except I want duplicates in the whole thing eliminated.
10:52:42 <fizbin> That is, each list by itself has no duplicates, but there may be stuff in one list that's repeated in another.
10:53:46 <kadoban> Gurkenglas: Ya, that pairwise merge thing is better, though I'm not sure how to analyze it. I'm not sure how that compares with the heap thing.
10:53:50 <mohsen_> dcoutts: How can I check that(where does binary come from)? uname -r returns this: 2.6.32-573.el6.x86_64 
10:54:07 <dcoutts> mohsen_: which ghc
10:54:23 <cocreature> xcmw: I don’t think your TKi types make sense, what are you actually trying to do?
10:54:29 <Gurkenglas> fizbin, then add a line to the definition of merge: "| a `cmp` b == EQ = b:merge as' bs'" (probably replacing those guards with a caseof on the compare)
10:54:43 <mohsen_> dcoutts: It's comming from /usr/bin
10:54:49 <cocreature> oh wait I missed that it’s MyRec and not Rec
10:54:56 <dcoutts> mohsen_: ok, then your distro does just supply a really old version
10:54:58 <Gurkenglas> fizbin, or just do another pass on the sorted concatted list, by passing it through map head . group at the end
10:55:25 <mohsen_> dcoutts: what should I do then?
10:55:43 <dcoutts> mohsen_: I'd suggest installing a new one in /usr/local or /opt or something (generic binaries are available from haskell.org/ghc)
10:55:47 <xcmw> cocreature: The TKi types specify which set of field to type mappings to use.
10:55:53 <Gurkenglas> Why isn't unions a pairwise merge, by the way?
10:55:53 <dcoutts> mohsen_: assuming you have no other reason to want to use such an old version
10:56:22 <xcmw> cocreature: The code works. I just want to know if there is a better way.
10:56:55 <kadoban> Gurkenglas: Do you know in particular the analysis for the pairwise merge thing, in the worst case or anything?
10:57:20 <kadoban> But ya, that strikes me as a good question.
10:57:40 <kadoban> Though the pairwise merge probably works better if the sizes are all similar, maybe?
10:58:54 <mohsen_> dcoutts: Isn't this weird? why should my distro provide such an old version of ghc?
10:59:06 <dcoutts> mohsen_: what distro & version?
10:59:06 <int-e> mohsen_: lsb_release -a ... my guess now would be some CentOS.
10:59:11 <xcmw> cocreature: I am to try to do this. {x: (read :: String -> Int), y: (id :: String -> String)} `rapply` {x: "5", y: "Hi"}
10:59:38 <xcmw> cocreature: and then z add a property to the result
11:00:05 <mohsen_> int-e: I think it's centos, I chose centos as the OS when I was filling the form.
11:00:57 <int-e> in fact... I've just found a server with CentOS 6.4 that has ghc-7.0.4 in /usr/bin. (no lsb_release executable though; I've found the version in /etc/issue)
11:01:02 <dcoutts> mohsen_: yes that's seriously old, June 2011 was when 7.0.4 was released
11:01:32 <Gurkenglas> kadoban, my calculations say pairwise merge should be about twice as fast
11:01:45 <kadoban> Gurkenglas: Than non-pairwise merge?
11:01:49 <mohsen_> dcoutts: What should I do then?
11:02:06 <Gurkenglas> That that foldl thing unions currently does. Assuming "/O(m*log(n/m + 1)), m <= n/" from union's doc
11:02:06 <dcoutts> mohsen_: as I said, install a recent ghc in /usr/local
11:02:10 <Gurkenglas> *Than
11:02:35 <dcoutts> mohsen_: grab a binary tarball from haskell.org/ghc and ./configure && make && sudo make install
11:02:36 <Gurkenglas> (For equal-size sets)
11:03:16 <kadoban> A little confused by that bound
11:03:29 <mohsen_> dcoutts: Ah okay, by the way, why doesn't this happen with other packages? does it mean all my other packages are also out of date?
11:04:01 <dcoutts> mohsen_: you were lucky with the other things you installed, that there were versions available that worked with old ghc versions (& the older other libs)
11:04:02 <kadoban> Isn't union O(n+m), or are we talking about something else?
11:04:06 <cocreature> xcmw: I’ll play around with it and see what I can come up with
11:04:38 <mohsen_> dcoutts: No I mean every other package provided by centos and epel repositories I have installed now
11:05:22 <dcoutts> mohsen_: I can't say
11:05:27 <Gurkenglas> kadoban, inserting 10 elements into a 2^20 set lets it share most of the subtrees
11:05:44 <mohsen_> This is all weird
11:06:12 <xcmw> cocreature: Ok. Thanks. acowly gave me a version without variable names. http://lpaste.net/350163
11:06:48 <dcoutts> mohsen_: I've heard generally that "enterprise" distros are often very far behind on certain packages, but this case is a bit extreme
11:06:53 <kadoban> Hmm true. Are you just looking at a different version of containers, I wonder? Mine just straight up says O(n+m) *looks around for other versions*
11:07:30 <Gurkenglas> kadoban, http://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-Set.html#v:union
11:07:53 <kadoban> Ah, yes. Okay I was looking at the old ones. My bad xD
11:10:12 <shapr> Is there a utility that checks for unused imports in a Haskell source file?
11:10:23 <roman> hola
11:10:31 <glguy> shapr: GHC
11:10:58 <shapr> glguy: oh, good point
11:12:21 <roman> hola
11:13:06 <Gurkenglas> Would someone escape that / in http://hackage.haskell.org/package/containers-0.5.8.1/docs/src/Data.Set.Base.html#union 's doc
11:14:47 <Gurkenglas> (kadoban, of course "twice as fast" doesn't mean anything because I was calculating using O bounds. Someone would have to criterion)
11:15:00 <cocreature> xcmw: you can use rmap like this http://lpaste.net/350164 but whether that’s an improvement is debatable :)
11:16:01 <xcmw> cocreature: Interesting
11:16:15 <kadoban> Gurkenglas: Right, though it's quite interesting. Intuitively it seems like it'd have to be better, but having trouble thinking it through (though in large part that's probably because I just got done coding for about 40 of the last 48 hours and haven't slept, it might not actually be that complicated xD)
11:16:35 <cocreature> xcmw: the reason why rmap didn’t work before is that it expects the record to be parmetrized by "Lift …" while your record was parametrized by Attr
11:17:14 <mohsen_> dcoutts: https://www.haskell.org/ghc/download_ghc_8_0_1#linux_x86_64 should I download the package for centos and do what?
11:17:24 <xcmw> cocreature: Is the ElF type family with two args the right way to do what I want?
11:18:07 <cocreature> xcmw: I think so but I’ve never really used vinyl for named records so take that with a grain of salt
11:18:53 <xcmw> cocreature: Ok thanks. When acowly comes back, I ask him to be sure.
11:19:32 <dcoutts> mohsen_: follow the instructions: untar, ./configure --prefix=/usr/local (or /opt if you prefer); make; sudo make install
11:26:19 <mohsen_> dcoutts: thanks
11:32:00 <fizbin> Oddly enough, the fastest way to do that list merging in my program turned out to be sort . myNub . concat , even after trying what had been suggested here. (myNub is just a re-implementation of ordNub from https://github.com/nh2/haskell-ordnub/blob/master/ordnub.hs)
11:33:11 <int-e> fizbin: wait, that is faster than Set.toAscList . Set.fromList ?
11:33:29 <int-e> (. concat)
11:33:52 <fizbin> Um... hrm. I suppose I should try that too.
11:39:52 <fizbin> int-e: That appears to be so close I can't reliably tell whether Set.toAscList . Set.fromList . concat or sort . myNub . concat is faster.
11:40:40 <fizbin> In the test I just tried, sort . myNub . concat seemed faster, but the difference was well within the jitter I'm seeing in this test.
11:40:57 <c_wraith> fizbin, you can't, or criterion can't? 
11:41:39 <mohsen_> dcoutts: Now when I run cabal install cabal-install or the same old command to install happstack it returns this message: cabal: failed to parse output of 'ghc-pkg dump'
11:41:54 <kadoban> fizbin: How big are these problem instances, by the way? Just out of curiosity. (number of lists and size of lists)
11:43:31 <fizbin> kadoban: The number of lists ranges from 1-2 to 30,000. Each list has at most ~50 elements in it.
11:44:03 <ph88> glguy, when i put in my list i get this error  Couldn't match type ‘State’ with ‘t a’   runNegatives predicates = filter (all predicates) (states :: [State])
11:44:04 <int-e> fizbin: the main reason I'm asking is that myNub will build the result of Set.fromList internally anyway. But it's always hard to predict actual performance. (Are you looking at productivity, too? (see +RTS -sstderr -RTS))
11:44:47 <fizbin> c_wraith: I'm not using criterion. I'm using this production app with a workload that has profiling data that says 7% of the compute time is being spent in this function that I'm playing with.
11:45:22 <Zemyla> Oh, I don't know if I've asked this before, but...
11:45:58 <mohsen_> Guys any idea?
11:46:32 <Zemyla> If an Applicative parser is equivalent to a context-free grammar, and a Monad one is equivalent to a context-sensitive parser, then is there a formalism that an ArrowChoice-based parser is equivalent to?
11:46:38 <glguy> mohsen_: GHC 8 needs cabal-install 1.24
11:47:23 <mohsen_> glguy: Should install that manually too?
11:49:28 <ph88> mohsen_, any reasons you don't use stack ?
11:49:42 <dcoutts> mohsen_: check that running ghc, or ghc-pkg works
11:50:52 <mohsen_> ph88: I don't know, I'm trying to use happstack based on this guide: http://www.happstack.com/page/view-page-slug/2/download
11:52:34 <mohsen_> ph88: It tells I need to use cabal 
11:53:46 <mohsen_> dcoutts: Ran ghc-pkg I got this output: 
11:53:49 <mohsen_> ghc-pkg: missing command
11:53:51 <mohsen_> For usage information see 'ghc-pkg --help'.
11:54:33 <xenon-> :t lookup
11:54:34 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
11:54:47 <xenon-> is there lookupBy?
11:55:58 <xenon-> @hoogle (a -> a -> Bool) -> [(a, b)] -> Maybe b
11:56:01 <mohsen_> Does stack prevent cabal hell?
11:56:01 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
11:56:01 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
11:56:01 <lambdabot> Data.List span :: (a -> Bool) -> [a] -> ([a], [a])
11:56:21 <ezyang> mohsen_: Define "cabal hell" 
11:56:50 <mohsen_> ezyang: when packages have version incompatiblities
11:57:02 <mohsen_> That's what I read on the web actually
11:57:23 <ezyang> If you use Stack with Stackage, you will not have to worry about version solving for packages in the Stackage set 
11:57:49 <mohsen_> ezyang: Does Stackage have all packages that Hackage has?
11:58:38 <ezyang> mohsen_: No. 
11:58:57 <mohsen_> ezyang: How can I find out whether it provides a specific package or not?
11:59:25 <ezyang> https://www.stackage.org/ 
12:00:45 <kadoban> mohsen_: You can use packages from hackage using stack, by the way. You just have to do a quite minor amount of extra work.
12:01:06 <ezyang> kadoban: But arguably, once you do that you can get back into "Cabal hell" again 
12:09:19 <ezyang> Although it's probably better, because the number of packages the solver solves for is smaller so it's harder to get into insane situations 
12:10:40 <begriffs> Is there an option for `stack list-dependencies` to list modules required by my tests as well?
12:12:56 <mohsen_> ezyang: https://www.stackage.org/lts-7.14/hoogle?q=happstack does this mean stack provides happstack?
12:18:55 <mohsen_> dcoutts: What should I do now?
12:19:37 <sainthubert> help
12:19:44 <sainthubert> #help
12:24:26 <charms> why does my list not work? http://lpaste.net/350172
12:27:16 <lyxia> charms: how does it not work
12:27:32 <lyxia> charms: is to_elongate a function or a list
12:27:48 <charms> it is a function
12:27:53 <charms> oops
12:27:56 <charms> i meant it is a string
12:28:29 <lyxia> then applying it to [x] is an error
12:28:53 <lyxia> to_elongate[x] does not type check.
12:29:07 <c_wraith> it's an error anyway, since there's no x in scope there
12:30:40 <charms> i'm trying to have it so that you got like a word like 'bang' becomes 'baannngggg!!!!!' well I guess I should have used to_elongate !! x
12:30:45 <charms> how would I make x in scope there?
12:33:29 <jmnoz> f :: [LB.ByteString] -> [Text] f cs = do let l = map decodeUtf8 cs ; map toStrict l  -- how can I put this more succinctly?
12:34:03 <onintza> Is there something like sequence but that only keeps the last result?
12:34:32 <uiop> onintza: what does that mean?
12:34:32 <lyxia> jmnoz: f = map (toStrict . decodeUtf8)
12:34:42 <jmnoz> lyxia: cheers
12:34:46 <uiop> onintza: oh, as in sequence()
12:35:17 <glguy> onintza: There isn't necessarily a "last result" in sequence
12:35:35 <lyxia> :t foldr1 (*>)
12:35:37 <lambdabot> (Foldable t, Applicative f) => t (f a) -> f a
12:35:42 <uiop> you could check for an empty list, then do last i guess
12:36:05 <onintza> glguy: are the monads not applied in order?
12:36:50 <uiop> onintza: he means if the list given to sequence is empty, the result will be empty, and there wont be a "last" result
12:37:20 <uiop> > return . last =<< sequence [] :: Maybe ()
12:37:22 <lambdabot>  Just *Exception: Prelude.last: empty list
12:37:31 <delYsid> > (\s -> concat $ snd $ mapAccumL (\s x -> (s+1, replicate s x)) 1 s)) "bang!"
12:37:33 <lambdabot>  <hint>:1:68: error: parse error on input ‘)’
12:38:11 <delYsid> > (\s -> concat $ snd $ mapAccumL (\s x -> (s+1, replicate s x)) 1 s) "bang!"
12:38:13 <lambdabot>  "baannngggg!!!!!"
12:41:16 <delYsid> charms: ^
12:43:47 <charms> delYsid: I don't really understand how that works sorry. I just started learning haskell like half an hour ago
12:48:01 <onintza> Ended up being more readable: https://paste.debian.net/903256/
12:50:12 <srhb> charms: It might be simpler to start with direct recursion. Consider making a function that replicates a character into a list of n of that character. Once you have that, you will need to recursively go through your string, using your helper function and increasing the n at each recursive call.
12:50:34 <mohsen_> Unstable internet connection here, was there any answer to my question?
12:51:16 <srhb> mohsen_: http://ircbrowse.net/day/haskell/today/recent
12:51:44 <charms> srhb I ended up with this later and am now trying to stitch it wirecbut haven't quite figured out yet how to stitch it together http://lpaste.net/350174
12:51:59 <charms> with recursion but*
12:52:55 <srhb> charms: Consider this instead, perhaps
12:53:09 <charms> what does this refer to?
12:54:05 <srhb> charms: Actually, have you used map at all before?
12:54:10 <charms> nope srhb
12:54:41 <charms> I'm using a book called The Haskell Road to logic, math and programming
12:56:34 <EvanR> > map ord "pizza"
12:56:36 <lambdabot>  [112,105,122,122,97]
12:56:50 <srhb> charms: I think you're going down the wrong path. Consider the result here
12:57:07 <charms> pizza to ascii representation?
12:57:15 <srhb> > [ (c,n) | c <- "foo", n <- [1 .. length foo]]
12:57:17 <lambdabot>  error:
12:57:17 <lambdabot>      • Variable not in scope: foo :: [a0]
12:57:17 <lambdabot>      • Perhaps you meant ‘for’ (imported from Data.Traversable)
12:57:26 <srhb> > [ (c,n) | c <- "foo", n <- [1 .. length "foo"]]
12:57:28 <lambdabot>  [('f',1),('f',2),('f',3),('o',1),('o',2),('o',3),('o',1),('o',2),('o',3)]
12:58:01 <srhb> I'm guessing you wanted [('f',1),('o',2),('o',3)]
12:58:02 <charms> oh btw I already have that function srhb in my previous paste sorry I forgot ot include it
12:58:09 <charms> that's what build is
12:59:38 <charms> srhb I got each character multiplied by whatever number to make a string of n characters
13:00:22 <srhb> charms: Yeah, the problem with using list comprehensions for this is that you essentially need an extension to make zip, which I think is what you want in order to use build. :)
13:01:07 <charms> so i need to make it the other way in order to use list comprehensions in the end
13:01:28 <srhb> > [ (c,n) | c <- "foo" | n <- [1 .. "foo"]] -- With parallel list comprehensions
13:01:31 <lambdabot>  error:
13:01:31 <lambdabot>      • No instance for (Enum [Char])
13:01:31 <lambdabot>          arising from the arithmetic sequence ‘1 .. "foo"’
13:01:45 <srhb> > [ (c,n) | c <- "foo" | n <- [1 .. length "foo"]] -- sigh, tired
13:01:59 <lambdabot>  [('f',1),('o',2),('o',3)]
13:02:26 <srhb> charms: I think the direct recursion route would be more educational, really. :)
13:02:26 <srhb> Especially if you already have build.
13:02:27 <charms> i'm trying it now
13:04:10 <srhb> charms: A hint might be the "outer" function that gets everything started. create to_elongate = helper to_elongate 1
13:16:23 <SegFaultAX> Is there a suggested guide for setting up a "complete" (for whatever definition of complete you think makes sense) development environment on macOS? vim-based would be ideal, but open to just about anything other than emacs.
13:17:12 <SegFaultAX> It's been a while since I've hacked on anything substantial in Haskell and even when I did my environment was basically just a few syntax plugins for vim and not much else. Not terribly friendly.
13:24:45 <markus3> SegFaultAX: am just trying hdevtools together with stack, gives rather good linter feedback
13:25:23 <markus3> SegFaultAX: apparently it also integrates with neovim/neomake/stack without any configuration
13:25:34 <markus3> SegFaultAX: so might be good to try
13:25:44 <stevenjohnson> Hi There...so I've heard that this is a great place to get help if you're having some trouble with Haskell. I really like what I've learned so far, but I'm having a heck of a time with figuring out a particular function I'm trying to write. Would anyone mind if I posted the issue here?
13:26:15 <markus3> anyway, off to sleep now
13:26:17 <koala_man> stevenjohnson: sure, go for it
13:26:56 <SegFaultAX> markus3: Cheers, thanks for your input!
13:27:00 <stevenjohnson> Thanks, Koola_man! So, I will try my best to explain. In effect, this is a fancy case of "oh noes, the IO monad!" question. Let me give you the code of the (not compiling) code I"m working on:
13:27:02 <int-e> http://lpaste.net/ is our preferred pastebin, if the question is longer than 1 or 2 lines
13:27:12 <stevenjohnson> rollMany :: MonadIO m => String -> Maybe Int -> m [RollData]
13:27:12 <stevenjohnson> rollMany formula numDice = case numDice of
13:27:12 <stevenjohnson>         Nothing -> rollMany formula (Just 1)
13:27:14 <stevenjohnson>         Just x ->  
13:27:16 <stevenjohnson>             let results = map parseRoll (replicate x formula)
13:27:18 <stevenjohnson>             in  liftIO $ (RollData formula) <$> results
13:27:20 <stevenjohnson>                  --Just x -> liftIO $ take x . map (RollData formula) . randomRs (1, (read formula :: Int)) <$> newStdGe
13:27:23 <stevenjohnson> er...let me see if I can clean that up. I don't IRC often
13:27:31 <stevenjohnson> rollMany :: MonadIO m => String -> Maybe Int -> m [RollData]
13:27:31 <stevenjohnson> rollMany formula numDice = case numDice of
13:27:31 <stevenjohnson>         Nothing -> rollMany formula (Just 1)
13:27:32 <glguy> don't paste code into IRC
13:27:33 <SegFaultAX> stevenjohnson: No multiline paste in IRC :(
13:27:51 <int-e> . o O ( I was too late and too subtle, sigh? )
13:27:53 <koala_man> oh dear.
13:28:06 <charms> RIP steven
13:28:23 <int-e> Sigyn is quite merciless
13:29:45 <SegFaultAX> So what do people like to use for development of Haskell "in the large", so to speak?
13:32:02 <maerwald> I use ghc
13:32:16 <charms> srhb embarassingly I still haven'gt got it can you show me how to do it
13:37:32 <hodapp> What library/stack do folks prefer for making REST clients in Haskell?
13:38:52 <johnw> servant and wreq are too recent ones
13:38:59 <johnw> two
13:39:06 <sm> SegFaultAX: check the haskell reddit for setup discussions, there are a lot
13:39:11 <johnw> i'd probably start with servant these days
13:39:19 <sm> good one just recently detailing Atom setup
13:39:22 <hodapp> oh, servant can be a client?
13:39:44 <johnw> hodapp: https://haskell-servant.github.io/client-in-5-minutes.html
13:40:06 <hodapp> thanks!
13:48:58 <SegFaultAX> sm: Thanks!
13:50:03 <Steve__> Hi There - it's me again (stevenJohnson). Is there a paste utility I can use to avoid getting banned?
13:50:15 <johnw> lpaste, hpaste, gist
13:50:21 <johnw> any of them
13:50:22 <SegFaultAX> Steve__: Welcome back. :)
13:50:29 <Steve__> haha, thanks :)
13:51:33 <lpaste> Steve pasted “Rolling” at http://lpaste.net/350182
13:51:47 <Steve__> There we go
13:52:06 <Steve__> So, in that code (working) I had a little function that would roll a die. It worked pretty great.
13:52:17 <Steve__> Recently I wrote a parser that has a function (parseRoll) that also seems to work great
13:52:40 <Steve__> So, I thought I'd revamp my function and have it take my parser instead (pass "3d8+4" or just "8") if I feel like it
13:52:49 <Steve__> Here is my (not compiling) attempt:
13:53:31 <lpaste> Steve pasted “Rolling” at http://lpaste.net/350183
13:54:45 <Steve__> The trouble I"m having is that I simply can't figure out how to get lines 5 and 6 to work properly. Line 5 seems to work great - I replicate the formula and map my parseRoll function. That function returns type IO Int
13:55:18 <Steve__> but then I need to map my "RollData" constructor to it with the formula as a string as the first argument, i.e.
13:55:38 <Steve__> map (RollData "3d8") [1, 23, 12]
13:56:01 <Steve__> but I just can't escape the IO monad and figure out how to properly map my functions to make haskell not angry wih me.
13:56:05 <Steve__> I hope that makes some form of sense...
13:57:16 <johnw> I'm not seeing the type of parseRoll, but maybe try "traverse" instead of "map" there
13:58:01 <Steve__> parseRoll is String -> IO Int
13:58:27 <Steve__> so the trouble is that I get a list of IO Ints and I need to map a function that just takes an int across it
13:58:51 <johnw> if you traverse, you'll end up with IO [Int]
13:59:34 <johnw> so, results <- traverse parseRoll ...; return $ fmap (RollData "3d8") results
13:59:44 <johnw> would be one way to satisfy the typechecker; I'm not sure yet if it's what you mean
14:00:18 <Steve__> I think that might work, at least it's looking ok i the interpreter
14:00:23 <Steve__> let me try that for a minute...
14:00:56 <johnw> note that traverse call also be called mapM here, if that's more familiar
14:01:07 <byorgey> Steve__: why does parseRoll have type  String -> IO Int ?
14:01:36 <Steve__> It takes a string type "3d8+4-2d6" Or whatever you like and then has to acesss System.Random to roll the dice
14:01:48 <byorgey> oh ok, I see
14:04:13 <Steve__> ok, so how could I get this to work...
14:04:14 <Steve__> map (RollData "3d8") (traverse parseRoll $ (replicate 3 "3d8"))
14:04:33 <johnw> traverse (RollData "3d8" . parseRoll) $ (replicate 3 "3d8")
14:05:01 <johnw> traverse (fmap (RollData "3d8") . parseRoll) $ (replicate 3 "3d8")
14:05:29 <Steve__> oh lord. That makes sense.
14:05:33 <johnw> if you map after traversing, you'll be apply RollData "3d8" to the list of Int inside the IO action
14:05:37 <Steve__> These type signatures are kind of hard to  get your head around.
14:05:53 <johnw> you can help yourself by calling out the intermediate values, and giving them types
14:05:54 <ph88^> hi guys, i have this function https://paste.fedoraproject.org/509872/82185076/ which NEEDS the type annotation on line 34. My question is how can i factor out all type specific stuff to ContextClause and give it as an argument to qcrp instead ?
14:06:01 <johnw> I had a friend that found that really useful
14:06:13 <johnw> turn on ScopedTypedVariables, and then you can say:
14:06:28 <johnw> (x :: Type) <- ioAction
14:06:37 <johnw> just to be sure you see what's happening at each step
14:07:23 <Steve__> ok I'll try that! Thank you
14:09:49 <Steve__> @johnw that worked amazingly. Thank you so much. That was such a pain to figure out. 
14:09:49 <lambdabot> Not enough privileges
14:09:59 <glguy> Steve__: @ is for bot commands
14:10:10 <Steve__> ah, sorry. not an irc guy. Was just trying to say thanks.
14:10:15 <Steve__> anyway, thanks ;)
14:19:24 <ph88^> can i maybe make a fuction like   x = x   and put a type constraint on it ?
14:20:34 <athan> ph88^: Like at the type level?
14:20:39 <athan> @kind (~)
14:20:40 <lambdabot> k -> k -> Constraint
14:21:26 <athan> > let foo :: (a ~ b) => a -> b -> Bool; foo () () = True in foo () ()
14:21:28 <lambdabot>  error:
14:21:29 <lambdabot>      • Couldn't match type ‘b’ with ‘()’
14:21:29 <lambdabot>        ‘b’ is a rigid type variable bound by
14:21:33 <athan> :U
14:21:54 <athan> > let foo :: (a ~ b) => a -> b -> Bool; foo _ _ = True in foo () ()
14:21:56 <lambdabot>  True
14:21:58 <athan> :D
14:22:14 <athan> check 'em ph88^
14:22:18 <petercommand> > let foo :: (a ~ b) => a -> b -> Bool; foo _ _ = True in foo () 1
14:22:20 <lambdabot>  error:
14:22:20 <lambdabot>      • No instance for (Num ()) arising from the literal ‘1’
14:22:20 <lambdabot>      • In the second argument of ‘foo’, namely ‘1’
14:22:29 <petercommand> > let foo :: (a ~ b) => a -> b -> Bool; foo _ _ = True in foo () (1 :: Int)
14:22:31 <lambdabot>  error:
14:22:31 <lambdabot>      • Couldn't match type ‘()’ with ‘Int’ arising from a use of ‘foo’
14:22:31 <lambdabot>      • In the expression: foo () (1 :: Int)
14:23:11 <ph88^> athan, that's beautiful :P
14:23:21 <athan> blame the authors :)
14:28:01 <Soldalma> Hi, it is my first day with Haskell. I managed to install the Haskell Platform and Leksah. I can compile and run code in Leksah but I cannot do interactive sessions, is this the way it is?
14:29:27 <athan> Soldalma: I'm not sure about leksah, but you should be able to run `ghci` in a command prompt
14:29:32 <kadoban> I haven't heard a lot of people using leksah. I just use my favorite text editor and a separate terminal window with ghci
14:29:56 <hodapp> this is the first I've heard of Leksah. Of course, I'm not really paying attention. Ever.
14:30:41 <hodapp> mostly I use Emacs & intero myself though
14:30:42 <Soldalma> athan, I will try. I can get a command prompt in Haskell Platform but when I paste code it complains of formatting
14:31:27 <ph88^> athan, i have this now https://paste.fedoraproject.org/509879/82186631/ and i get error on line 2: Not in scope: type variable ‘b’
14:32:10 <monochrom> You are not supposed to paste code to a prompt. You are supposed to use :load
14:32:43 <ph88^> are you talking to me ?
14:32:48 <monochrom> no
14:34:30 <EvanR> does Hask have power objects
14:34:50 <Gurkenglas> Is type inference for impredicative types ambiguous, uncomputable or merely hard?
14:34:52 <Soldalma> I copied and pasted some code from the web into ghci. It gave me this: <interactive>:2:1: error:     Variable not in scope: factorial :: a1 -> a1
14:34:55 <hodapp> what's a catchy name for Haskell bindings for hypothes.is?
14:35:11 <hodapp> hypothes.hs? haskpothesis? maybe I'll just do hypothesis-hs.
14:35:13 <monochrom> Again, you are not supposed to paste code to a prompt. You are supposed to use :load
14:35:58 <Gurkenglas> As in, paste some code from the web into a file.hs, do :load file.hs from a command prompt in that folder, then use names defined in the file
14:36:21 <Gurkenglas> (after starting ghci. "from a ghci prompt" i should have said)
14:36:24 <Soldalma> monochrom: thanks, that is helpful. It is my first day, so I am strugling. 
14:37:26 <ph88^> if i have something like   forall a. (Num a) =>     can i put a `b` there like this?   forall a. (Num a, Show b) ? or should i do like   forall a b. (Num a, Show b)   ?
14:37:56 <monochrom> I have never used leksah, but I could find its user manual. Maybe you should read the user manual.
14:38:40 <lyxia> ph88^: I think you have to bind all variables
14:38:46 <athan> ph88^: IIRC, type variables declared must be used
14:38:56 <athan> otherwise the compiler won't know how to chose them
14:39:08 <athan> @type undefined :: forall a. Int
14:39:09 <lambdabot> Int
14:39:14 <athan> er... D:
14:39:18 <ph88^> you guys mean the stuff after  =>   ?
14:39:20 <athan> @type undefined :: forall a. Num a => Int
14:39:22 <lambdabot> Int
14:39:31 <athan> wtf, I guess I'm wrong lol
14:39:32 <monochrom> I'm sure ph88^ will use b.
14:39:44 <ph88^> thx for the confidence :P
14:39:45 <athan> @type id :: forall a. Num a => Int -> Int
14:39:47 <lambdabot> Int -> Int
14:40:04 <lyxia> @type undefined :: forall a. Num b => Int
14:40:05 <lambdabot> error: Not in scope: type variable ‘b’
14:40:34 <JuanDaugherty> monochrom, its author (hamishmack) is in blah
14:40:35 <monochrom> but if you have a "forall" then you have to list all type variables.
14:40:38 <athan> yeah idk what I was thinking :s
14:40:40 <ph88^> i never really understood forall, i get a feeling this is part of the problem :P
14:40:52 <athan> ahh, thanks monochrom
14:41:08 <Soldalma> Gurkenglas: can I enter the whole file path?
14:41:22 <Gurkenglas> dunno probably try it
14:41:58 <johnw> ph88^: forall a really just means "for every possible choice of a"
14:42:18 <ph88^> why is that not the default thing ?
14:42:23 <ph88^> i was reading that anyway without  forall
14:42:26 <johnw> it is the default in Haskell, if you use a type variable
14:42:52 <johnw> foo :: (a -> b) -> a -> b is the same as foo :: forall a b. (a -> b) -> a -> b
14:43:02 <ph88^> oh
14:43:07 <ph88^> so basically it's noise ?
14:43:11 <ph88^> the forall keyword
14:43:16 <johnw> sometimes, yeah
14:43:24 <johnw> you need it to be explicit in several circumstances
14:43:28 <johnw> but not in the basic cases
14:43:34 <monochrom> it is noise if your world does not have rank-2 types or existential types
14:43:42 <ph88^> if you are not explicit .. what else could it be ?
14:44:02 <johnw> (forall a. a -> b) is very different from forall a. (a -> b)
14:44:09 <monochrom> like the way "real number" is redundant (just say "number") if your world does not have complex numbers.
14:44:10 <johnw> so, to distinguish the former from the latter in Haskell, you need an explicit forall
14:44:22 <Soldalma> Gurkenglas: Entering the full path (without quotes) works, but it said "Parse error: naked expression at top level"
14:44:57 <ph88^> when would you use  (forall a. a -> b)  ?
14:45:17 <monochrom> No, "forall a. a -> b" is a poor example.
14:45:23 <johnw> ph88^: to pass a polymorphic function as a value, using Rank-N types
14:45:30 <johnw> it's not a great example, granted
14:45:33 <monochrom> Better example is writing out the whole "(forall a. a -> b) -> Int"
14:45:34 <Gurkenglas> Soldalma, into the file you put definitions like "timesthree x = x+x+x", not expressions like "2+2+2"
14:45:41 <johnw> yes, thank you monochrom 
14:46:08 <monochrom> "(forall a. a -> b) -> Int" /= "forall a. (a -> b) -> Int"
14:46:32 <Soldalma> Gurkenglas: Ok, and how do I run the timesthree function?
14:47:01 <ph88^> alright i'll make note
14:47:46 <Gurkenglas> In ghci, after the :load thingy, you write "timesthree 2" without quotes
14:48:06 <Gurkenglas> In ghci, you can also say "2+2+2", but I don't think you can have more than one line of code
14:48:30 <ph88^> if i have   Num a -> BlaBla a -> (b -> b) -> Bool     how can i say that "BlaBla a" should be equal to "b" ?
14:49:10 <monochrom> that line has typos. please fix them first.
14:49:23 <Soldalma> Gurkenglas: Cool! It works!
14:49:23 <johnw> Num a, b ~ BlaBla a => ...
14:49:33 <johnw> ~ is a type equality constraint
14:49:50 <ph88^> yeah athan just told me that .. i just didn't know i could BlaBla before the  =>
14:50:02 <johnw> the need for which is exceedingly rare, unless you using some specific features
14:50:32 <ph88^> it actually compiles :|
14:56:44 <ph88^> but then i run into problems with putting my  b -> b  function at work  https://paste.fedoraproject.org/509887/88143148/
14:59:06 <johnw> why bother with a type variable there?
14:59:13 <ph88^> where exactly ?
14:59:16 <johnw> 'b'
14:59:18 <ph88^> oh
14:59:27 <johnw> i mean, if it can only ever be one type, it's not "forall" anymore :)
14:59:53 <ph88^> what you mean one type ?
14:59:59 <jle`> Num a => BlaaBla a -> (BlaBla a -> BlaBla a) -> Bool
15:00:34 <johnw> yeah
15:00:43 <johnw> you can just instantiate 'b' yourself in the signature
15:00:46 <ph88^> ooh
15:00:56 <EvanR> it can be any type you want as long as its Black
15:01:10 <jle`> "give me any number X as long as it's 1"
15:01:14 <mceier>  /win 26
15:01:57 <johnw> lol
15:02:18 <jle`> pick a card any card.  not that card.  only the three of herats
15:03:42 <lyxia> ph88^: transformOut <$> a $ b $ c   means   (transformOut <$> a) (b c)   is that really what you mean
15:04:26 <ph88^> are you talking about the comments ?
15:07:45 <lyxia> ph88^: I'm talking about the source of your error
15:09:10 <ph88^> yeah that seems strange as well .. but it actually worked. Don't know why
15:09:12 <delYsid> > concat . snd . mapAccumL ((.) . (,) . succ <*> replicate) 1 $ "Bang!"
15:09:15 <lambdabot>  "Baannngggg!!!!!"
15:09:32 <ph88^> i'm just trying to make my function polymorphic .. but the implementation seemed to do what it was suppose to ^^
15:09:49 <mniip> and the dirt iisss ggggooooonnnnnneeeeeee
15:10:42 <monochrom> pick any positive even prime integer. then it is the smallest degree of a quadratic Galois field extension.
15:12:08 <EvanR> wrong channel
15:12:20 <ph88^> if i make a type hole will the compiler tell me what type was infered there? even if it was not on top level ?
15:12:32 <monochrom> sure, but I'm catching the last train on "pick any number, but it has to be..."
15:12:38 <EvanR> ph88^: try it and see!
15:17:36 <sshine> with Hspec, I'd like to test that a predicate holds for each element in a list. I'm going from: it "testing one" $ 'a' `shouldSatisfy` predicate -- to: it "testing many" $ forM_ xs (`shouldSatisfy` predicate) -- but I get a type-error saying it expected a Spec but got a SpecWith (Arg a0). what's the proper syntax?
15:18:03 <ph88^> perhaps it's better to make a more simple example to explain what i'm trying to do instead of throwing in the big function
15:18:10 <ph88^> i'll come back tomorrow
15:23:56 <lyxia> sshine: that snippets looks right though
15:26:26 <jle`> ph88^: you can put it in the middle of a big declaration but ghc might not pick the type variable names you expect
15:27:42 <sshine> lyxia, I'm an idiot. I forgot to 'import Control.Monad'. :)
15:28:57 <lyxia> oh :)
15:31:37 <onintza> How would I parse any char but whitespace?
15:32:15 <johnw> you can use 'satisfy' to create a custom char matcher
15:32:26 <onintza> oh, true
15:32:28 <Roxxik> http://hayoo.fh-wedel.de/?query=noneOf
15:33:08 <Roxxik> and depending on your lib there might be some kind of parser negation
15:33:27 <onintza> stdlib, i don't want to add any dependencies
15:33:51 <yhhko> are there any rules of thumb on preventing cyclic data structures from involving a whole load of thunks, or otherwise becoming inefficient?
15:34:17 <jle`> you can add strict fields?
15:34:19 <johnw> yhhko: that would depend on how you build value of that type, more than the type itself, I'd think
15:34:40 <johnw> too much strictness can be bad too
15:34:55 <yhhko> johnw: can you give common mistakes and pitfalls?
15:35:12 <jle`> ah yeah, adding strictness can mean more thunks
15:35:14 <jle`> my bad
15:35:34 <yhhko> what's a typical way in which strictness creates thunks?
15:36:06 <jle`> map (sum [1..1000000] +) [1..100]
15:36:17 <jle`> it'd allocate a hundred thunks for a strict list
15:36:35 <yhhko> okay, but in my cyclic data structure everything can be evaluated... in theory, anyway
15:37:04 <yhhko> it's basically a couple of tables with cross-references
15:37:06 <johnw> if you show us some code, we can give better guesses
15:37:11 <jle`> do you *want* it to be evaluated?
15:37:38 <yhhko> jle`: well i suppose i'd rather it be completely evaluated once and for all
15:37:50 <yhhko> johnw: i don't have any code yet as i'm still in the design phase :)
15:38:12 <hackrilege> I found a nice looking set of papers following the work of moggi, but I can't understand the syntax, for example in Monad Translating Inductive
15:38:13 <hackrilege> and Coinductive Types, e.g. ::= where can I find references to decipher this syntax, what is it called?
15:38:31 <yhhko> but my program needs to deal with a certain protocol specification which is supplied at runtime. and there are various kinds of messages that can be sent over this protocol, and in the specification these messages refer to eachother
15:39:19 <hackrilege> https://goo.gl/qrsfY2
15:39:24 <yhhko> so i was thinking i'd first read this protocol specification into an uncyclic map, and then tie the knot
15:40:28 <yhhko> jle`: so, put differently: if i want the entire thing to be evaluated anyway, strictness should never get in my way?
15:40:39 <hackrilege> see e.g. The section headed, typing rules
15:40:58 <johnw> yhhko: if you always just "want an answer", and don't ever gain a benefit from partially evaluated values in any way, then complete strictness might be the way to go
15:41:31 <yhhko> okay
15:42:10 <monochrom> You started on the wrong foot by hoping for rules of thumb.
15:42:20 <yhhko> hackrilege: which "typing rules"? :)
15:42:24 <yhhko> monochrom: why's that?
15:42:27 <johnw> yeah, it's very hard to generalize these things without code to examine
15:42:39 <hackrilege> On page 301 of the linked paper
15:42:57 <monochrom> Suppose I have this very simple cyclic list: z = () : z
15:43:12 <johnw> hackrilege: do you mean, reading the typing judgments?
15:43:26 <monochrom> Now, length is a pretty eager function, it will evaluation all of the list spine. length z is going to be an infinite loop.
15:43:46 <hackrilege> Is that what they are called? I'll look that up and see if it gives me some kid of cheat sheet
15:43:53 <hackrilege> Kind*
15:44:12 <monochrom> Now, "take 2" is also a pretty eager function, it will evaluate all of z's spine (because z is so small), and yet "take 2 z" is finite time.
15:44:52 <monochrom> In conclusion "I will evaluate everything anyway" is unsufficient information, even irrelevant information, on whether your program even terminates or not.
15:45:00 <yhhko> monochrom: okay. but i'm not worried about converge/diverge, as my structure is very finite.
15:45:11 <yhhko> the answer exists, the question is just how to represent it most efficiently
15:45:14 <monochrom> There are no rules of thumb. There is only one meta rule of thumb: It depends, learn lazy evaluation for real.
15:45:30 <monochrom> z = () : z is a very finite cyclic structure too.
15:45:38 <johnw> hackrilege: https://courses.cs.washington.edu/courses/cse505/00au/lectures/09-typing-judgments.txt
15:45:50 <monochrom> It only takes 24 bytes.
15:45:52 <hackrilege> References indicate agda...
15:46:03 <hackrilege> Thanks johnw
15:46:26 <yhhko> monochrom: i suppose i see your point :)
15:49:36 <yhhko> jle`, johnw, monochrom: thanks for your input :)
15:49:59 <EvanR> 12 bytes for the (, the other 12 for )
15:50:21 <monochrom> Walking a cyclic data structure in Java spending only finite time is very easy, because it provides pointer equality, you can always ask "am I back to the starting point yet?" and you will always get the correct answer.
15:50:55 <monochrom> There is no pointer equality in Haskell, not at this non-FFI level anyway. length diverges because length doesn't know it is back at the beginning.
15:51:07 <yhhko> right
15:51:10 <hackrilege> It looks like Gamma |- a : Int is equivalent to a :: Int in Haskell, is that about right?
15:51:19 <yhhko> hackrilege: yeah
15:51:33 <yhhko> where "a" is an expression
15:51:37 <monochrom> https://ro-che.info/ccc/9
15:51:51 <monochrom> this is basically what "length" is running into
15:52:02 <EvanR> getting the length of something like let x = () : x in x would break referntial transparency and the fabric of the sapce time continuum
15:52:04 <monochrom> and you will run into this too
15:52:31 <yhhko> well i don't need a length function, but it's good to realise that i can't have that in the representation i have in mind
15:52:31 <EvanR> but you can try with observable sharing
15:53:16 <yhhko> all i really need is follow the cross-references around with finitely many steps, and retrieve data here and there along the way
15:54:03 <monochrom> If you're doing the like of "take 2" you will be fine of course.
15:54:49 <yhhko> essentially yes. but again, it's good to realise that i can't even wish to do other things, like your example
15:54:50 <hackrilege> https://hackage.haskell.org/package/data-reify
15:54:58 <hackrilege> That looks great!
15:55:58 <EvanR> yhhko: on the subject of represnting graphs... i saw this blog post: http://blog.higher-order.com/blog/2016/04/02/a-comonad-of-graph-decompositions/ sorry its in scala
15:56:31 <EvanR> you can traverse inductive graphs by decomposing them
15:57:07 <c_wraith> isn't that what fgl does? 
15:57:30 <EvanR> does it?
15:57:52 <yhhko> EvanR: hm, this might be useful for me at some point, but yeah i don't speak a word of scala
15:57:54 <EvanR> if so, cool ;)
15:58:05 <hackrilege> That looks alot like duplicate for a zipper
15:58:53 <c_wraith> EvanR, well that's the interface fgl gives. may not be the same implementation underneath, but the contexts thing is just like fgl. 
15:59:19 <yhhko> hackrilege: uh, can you use zippers with cyclic structures?
15:59:20 <EvanR> a graph is either the empty graph, or its the decomposition of a node+half edge and a graph missing that node+half edge
15:59:42 <EvanR> with zippers, i only ever saw acyclic structures
16:00:05 <Koterpillar> can't see why not though
16:00:28 <EvanR> well you wouldnt be able to update it
16:00:37 <yhhko> well this is not a research project, if it's not known to work i'll just use an old-school method
16:00:48 <hackrilege> There is an isomorphism between infinite lists and zipper so I guess cyclic foldable things should have zippers, but I'm not quite down with the formal derivation :(
16:01:19 <c_wraith> you can create a zipper of an infinite list. it just may get far larger than the original. 
16:02:18 <hackrilege> More large than infinite!
16:02:31 <hackrilege> Probably should be avoided
16:02:56 <c_wraith> infinite can be quite small. :) 
16:03:38 <hackrilege> Is there a way to do pointer equivalence in Haskell?
16:03:45 <hodapp> graaaaah... https://haskell-servant.github.io/client-in-5-minutes.html seems to be outdated
16:04:09 <hodapp> which is most unhelpful when I have no idea how to fix it because if I were that knowledgeable I'd have no reason to read a tutorial
16:04:43 <dmwit_> hackrilege: Yes, `Ptr` and `IORef` both have `Eq` instances that do not rely on the contained type having an `Eq` instance.
16:04:45 <hackrilege> Fgl looks quite large, is there a bitesize introduction or paper somewhere?
16:06:43 <hackrilege> I'm seeing MuRef in data.reify is that the same thing dmwit?
16:07:07 <Zemyla> If f is an Applicative Comonad, does duplicate (pure a) = pure (pure a)?
16:07:38 <dmwit> hackrilege: re: fgl; Yes, the linked website includes both an excellent User Guide (http://web.engr.oregonstate.edu/~erwig/fgl/haskell/old/fgl0103.pdf) and a very readable paper about the techniques used (http://web.engr.oregonstate.edu/~erwig/papers/InductiveGraphs_JFP01.pdf).
16:07:38 <hackrilege> (monochrom) There is no pointer equality in Haskell, not at this non-FFI level anyway. length diverges because length doesn't know it is back at the beginning. --dmwit
16:07:55 <hackrilege> Thanks!
16:08:17 <jmnoz> can someone recommend an alternative for Heroku where I can deploy a Haskell app with acid-state storage? 
16:08:37 <dmwit> MuRef is not the same thing. "There is no pointer equality in Haskell" is an approximation of the truth.
16:08:53 <dmwit> Certainly `length` does not use pointer equality.
16:09:04 <dmwit> Or any equality, for that matter.
16:11:11 <dmwit> You may like to read through some StackOverflow posts about pointer equality: http://stackoverflow.com/q/30175974/791604, http://stackoverflow.com/q/5701893/791604, and writeups linked from those.
16:11:23 <hackrilege> Awesome, cheers
16:12:12 <hackrilege> I'm seeing StableName about the place, is that the right way to go?
16:14:01 <hodapp> okay, code copied verbatim from https://haskell-servant.readthedocs.io/en/latest/tutorial/Client.html is not working either
16:15:02 <hodapp> it is giving me http://lpaste.net/350186 at: position :<|> hello :<|> marketing = client api
16:16:24 <dmwit> hackrilege: "Is that the right way to go?" Depends on the location you're trying to arrive at.
16:16:33 <jle`> hackrilege: be aware that pointer equality in haskell is often a lie
16:16:47 <jle`> you'll get false positives and false negatives
16:16:53 <jle`> so like, why even
16:17:33 <hackrilege> I guess its about wanting to navigate the cyclic graph and recognise a repeated element, perhaps for a more intelligent length function
16:17:41 <jle`> oh, the stack overflow answers address my comments
16:18:11 <jle`> hackrilege: you mean a repeated tail...?
16:18:17 <hackrilege> I guess they could be indexed with Int, so actually maybe I don't quite understand the problem
16:18:26 <hackrilege> Yes jle'
16:18:45 <dmwit> What are you going to do with the output of this length function?
16:19:13 <jle`> because if the same item appears in a list twice, it doesn't mean that the list is cyclic
16:19:20 <dmwit> I am concerned, because: it could plausibly answer differently for `z = ():z` and `z = ():():z`. Are you sure you want that to be so?
16:19:51 <yhhko> you could recognize if the remainder of the list is the same as z
16:19:58 * yhhko ducks
16:20:31 <jle`> Zemyla: no
16:20:38 <jle`> Zemyla: conter-example: almost every Comonad instance
16:21:09 <jle`> er wait, let me make sure
16:22:10 <hackrilege> :t duplicate . pure
16:22:11 <lambdabot> error:
16:22:12 <lambdabot>     • Variable not in scope: duplicate :: f0 a -> c
16:22:12 <lambdabot>     • Perhaps you meant one of these:
16:22:20 <hackrilege> Sorry :/
16:23:36 <hackrilege> dmwit, I guess they are indeed different, the latter having two identical elements before the recursive call
16:23:36 <sm> drat.. how to calculate the difference between successive items, eg [1,3,7,15] -> [2,4,8] ?
16:24:02 <hackrilege> zipwith and tail
16:24:06 <dmwit> > let f xs = [y-x | x:y:_ <- tails xs in f [1,3,7,15]
16:24:08 <lambdabot>  <hint>:1:37: error: parse error on input ‘in’
16:24:14 <dmwit> > let f xs = [y-x | x:y:_ <- tails xs] in f [1,3,7,15]
16:24:16 <lambdabot>  [2,4,8]
16:24:34 <sm> thanks.. no way to do it with scanl, right ?
16:24:35 <dmwit> > ap (zipWith subtract) tail [1,3,7,15]
16:24:40 <lambdabot>  [2,4,8]
16:24:58 <hackrilege> :t ap
16:25:00 <lambdabot> Monad m => m (a -> b) -> m a -> m b
16:25:46 <hackrilege> Wow that's difficult to typecheck
16:26:16 <dmwit> sm: It is probably possible to use scanl if you're insistent on that.
16:27:55 <dmwit> > drop 2 . map fst . scanl (\old new -> (new - snd old, new)) undefined $ [1,3,7,15]
16:27:57 <lambdabot>  [2,4,8]
16:30:05 <sm> the task was a little harder than I expected
16:31:45 <dmwit> I mean, there are also dead simple solutions.
16:32:09 <dmwit> > let f (x:y:rest) = y-x:f (y:rest); f _ = [] in f [1,3,7,15] -- can't get much simpler
16:32:11 <lambdabot>  [2,4,8]
16:33:29 <sm> well, yes; using a one-liner from standard libs I mean
16:34:02 <dmwit> You don't like `zipWith subtract <*> tail`? =P
16:34:16 <hackrilege> > let f xs = zipWith (-) xs (tail xs) in f [1,3,7,15]
16:34:18 <lambdabot>  [-2,-4,-8]
16:34:28 <hackrilege> Oops!
16:35:40 <hackrilege> dmwit, again, that last example you gave is pretty difficult to understand!
16:38:05 <hnfmr> hi, on stack LTS 7.14 package list, there are three libraries for Google protobuf, which is the one recommended?
16:38:13 <hnfmr> protobuf-0.2.1.1
16:38:21 <hnfmr> protocol-buffers-2.4.0
16:38:38 <hnfmr> protobuf-simple-0.1.02
16:38:38 <hackrilege> Ok, thanks for the material on cyclic graphs and such, I have plenty to read ill return soon! Peace
16:50:29 <stefan-__> is there a Data.Ix which yields Integer instead Int?
16:57:51 <pikarudolph> stefan-__: which function are you talking about
16:58:10 <stefan-__> pikarudolph, Data.Ix maps some index to an Int
16:58:26 <stefan-__> this can lead to an overflow for large indexes
16:58:43 <stefan-__> > index ((0,0,0,0),(500000,500000,500000,500000)) (180000,100,200,10)
16:58:44 <pikarudolph> just out of curiosity, in what scenario are you getting an overflow?
16:58:46 <lambdabot>  -4892744655452791210
16:59:30 <pikarudolph> why not write your own Ix-like class that uses Integers?
16:59:36 <pikarudolph> I'm assuming it uses Ints for performance reasons
16:59:37 <tyoverby> Why does cabal require absolute paths for extra-lib-dirs?
16:59:38 <stefan-__> pikarudolph, i want to code a sparse array
16:59:51 <tyoverby> I'm trying to make a program that will build on more than just my machine...
17:00:47 <stefan-__> pikarudolph, i am indexing a sparse list of n-grams from some vocabulary
17:01:50 <pikarudolph> well, the question stands, can't you reimplement `index` and make it return an Integer?
17:02:05 <stefan-__> yep, that would work
17:02:07 <uiop> :t index
17:02:08 <lambdabot> Ix a => (a, a) -> a -> Int
17:02:27 <stefan-__> i just wondered that this seems to be an uncommon use case ;)
17:02:32 <pikarudolph> it looks that way
17:02:38 <uiop> stefan-__: there are only so many bits in an Int
17:03:17 <pikarudolph> what you'd need is to implement rangeSize such that it returns an Integer
17:05:18 <uiop> stefan-__: also any dense structure you need all the bits in a machine word to index by definition basically will exhaust all addressable ram
17:06:08 <uiop> so since you presumably dont plan to exhaust all ram, then the structure is sparse wrt indices (or something)
17:06:41 <uiop> maybe a different indexing scheme (and data structure) rather than using Integer and whatever the data structure is now
17:06:48 <uiop> stefan-__: just playing devils advocate
17:07:00 <uiop> i maybe very well be missing your point
17:08:23 <stefan-__> uiop, tries might be an alternative
17:09:08 <stefan-__> http://wiredspace.wits.ac.za/bitstream/handle/10539/15329/dissertation537887CD.pdf
17:09:17 <stefan-__> here are a few approaches
17:32:04 <stefan-__> > import Data.Vector as V
17:32:07 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
17:32:13 <stefan-__> > data SparseVector a b = SparseVector { ds :: Vector a , is :: Vector Integer } deriving (Show)
17:32:15 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
17:57:29 <dmwit> tyoverby: The documentation has a section on that: https://www.haskell.org/cabal/users-guide/developing-packages.html#system-dependent-parameters
17:58:04 <dmwit> tyoverby: There are also several examples of packages on Hackage that bundle C libraries; you might look at one of those for inspiration.
17:59:50 <dmwit> tyoverby: e.g. Hipmunk looks like a good example, and uses build-type Simple (so must not be doing anything system-dependent)
18:01:04 <dmwit> oh
18:01:56 <aweinstock> On page 27 of the "making a fast curry" paper, it says that (id f x) has to treat (id f) as an unknown function. why isn't arity propagation doable via typechecking? (x :: a, f :: a -> b, id :: (a -> b) -> (a -> b), so since f's arity is known, (id f)'s arity should also be known)
18:02:08 <dmwit> ?tell tyoverby You can bundle the C library; see e.g. Hipmunk on Hackage as an example of how to do that. If you want to use the system library and don't want the user to specify --extra-lib-dirs, you could look at the documentation section on system-dependent parameters: https://www.haskell.org/cabal/users-guide/developing-packages.html#system-dependent-parameters
18:02:08 <lambdabot> Consider it noted.
18:02:49 <dmwit> aweinstock: That's not type-checking, that's evaluation.
18:03:36 <dmwit> You know `id f`'s arity is the same as `f`'s arity because `id f` evaluates to `f`. But the *type system* doesn't know that. It just knows it evaluates to something with the same type as `f` -- not necessarily the same arity.
18:04:43 <aweinstock> id :: (a -> b) -> (a -> b) doesn't constrain the arity?
18:06:13 <dmwit> No.
18:07:00 <aweinstock> even if a and b are already statically known to not be function types?
18:07:30 <dmwit> Pretty much the first paragraph of the paper summarizes the problem: just because `f :: a -> b -> c` and `x :: a` doesn't mean `f x` is immediately a function. It might do some computation first.
18:08:00 <jmnoz> is there a way to find out which is the most widely used redis package?
18:12:33 <aweinstock> dmwit: thanks
18:21:43 <gouwe> hi all - trying the example on https://github.com/haskell-gi/haskell-gi
18:21:54 <gouwe> hlint is complaining: Parse error in expression: # title := "Hi there"
18:22:01 <gouwe> looks like it does not recognize OverloadedLabels
18:22:09 <gouwe> hlint: Unknown extension: OverloadedLabels
18:22:16 <gouwe> is that correct?
18:23:27 <c_wraith> very likely
18:23:30 <c_wraith> It's a new extension
18:23:52 <gouwe> @c_wraith ok, thanks - any way to disable per file?
18:23:52 <lambdabot> Unknown command, try @list
18:24:07 <c_wraith> the lint messages, you mean?
18:24:17 <gouwe> correct
18:24:17 <byorgey> gouwe: what version of hlint do you have?
18:24:38 <gouwe> byorgey: HLint v1.9.35, (C) Neil Mitchell 2006-2016
18:24:56 <byorgey> gouwe: ok, you should upgrade your hlint
18:25:12 <byorgey> it looks to me like the latest version should support OverloadedLabels
18:25:22 <gouwe> hm... just installed that using stack
18:26:00 <vozz> I'm using streaming and streaming-bytestring, and I have a stream with the type Stream (B.ByteString IO) IO (), how do I turn it into a stream of Strings? 
18:26:11 <gouwe> byorgey: lts-7.14, which is the latest atm
18:26:32 <c_wraith> gouwe: stack doesn't always give you the newest things.  That's kind of the reason it exists.
18:27:59 <byorgey> gouwe: if you want to try a newer version, add e.g. 'hlint-1.9.39' to the 'extra-deps' list in your stack.yaml
18:30:57 <gouwe> byorgey, tried stack install hlint-1.9.39, but that gives haskell-src-exts-1.17.1 must match >=1.18 && <1.20
18:31:41 <athan> Can anyone see why this failed? http://lpaste.net/3914574051321839616
18:31:56 <athan> It's an x86_64 :(
18:32:28 <Koterpillar> athan: can you find that config.log?
18:33:00 <dfeuer> kosmikus, did you ever work out a way to make Generics.SOP.Show.gshow work right? I just wrote some sensible defaults for Data.Functor.Classes.Eq1 and Ord1, but defaults for Show1 and Read1 will be much trickier.
18:34:37 <athan> Koterpillar: Sorry, this tablet has next to 0 ram
18:34:44 <athan> but no I can't seem to find it
18:34:59 <Koterpillar> that might be the problem...
18:35:08 <athan> no this is on a linode server
18:35:09 <Koterpillar> if it ran out of memory compiling
18:35:12 <athan> it has 2G ram
18:35:29 <Koterpillar> where did you look?
18:35:31 <athan> (no swap for now because linode manager sucks eggs)
18:35:47 <athan> ~/.stack/, but by hand
18:35:53 <athan> I don't know how to `find` :x
18:36:06 <athan> if I try again I'll logout lol
18:36:20 <athan> because this tablet can only handle one program at a time or something
18:36:34 <Koterpillar> configure: error: in `/tmp/stack4778/network-2.6.3.1
18:36:38 <Koterpillar> that might be the path you need
18:36:52 <athan> ahh okay
18:36:58 <gouwe> athan, beside what Koterpillar says, try find /|grep config.log (hope not too many matches :)
18:37:15 <athan> alright, I'll be back after these messages :v
18:37:57 <gouwe> vozz, maybe Data.ByteString.Char8.unpack?
18:38:25 <Koterpillar> gouwe: hey, find -name
18:38:49 <gouwe> Koterpillar, or that :)
18:39:28 <athan> Rofl, nothing was found, even with `find / | grep "config\.log"
18:40:07 <athan> -/tmp/stack* doesn't exist
18:45:03 <gouwe> athan: can you try https://goo.gl/wNbRxk
18:45:55 <hodapp> has Servant any mechanisms to avoid gigantic chains of Maybe ... -> Maybe ... -> Maybe ... when using a web API call with many QueryParam chained together?
18:48:53 <gouwe> any way to a) make hlint ignore the whole file or b) install latest hlint (1.9.39) with stack lts-7.14?
18:50:35 <athan> I apparently don't have a /tmp mount :|
18:53:07 <peddie> gouwe: add the updated dependencies like `haskell-src-exts-<version>` to `extra-deps` as well
18:53:23 <athan> So I installed build-essential, but am still getting the error
18:53:48 <athan> and doing `mount -o remount,exec,suid /tmp` tells me /tmp isn't a mount point :(
18:53:54 <athan> or hasn't been mounted or something
18:54:08 <athan> when I list /, /tmp looks like it's a symlink to somewhere
18:54:14 <athan> (this is a linode server btw)
18:54:27 <athan> and I'm also running this all as root
18:54:31 <gouwe> peddie: tried, but still getting: haskell-src-exts-1.17.1 must match >=1.18 && <1.20 (latest applicable is 1.19.1)
18:54:52 <gouwe> athan: where does tmp point to?
18:55:02 <peddie> gouwe: so then add `haskell-src-exts-1.19.1` to extra-deps
18:55:21 <athan> gouwe: You might need to add a custom dependency in your stack.yaml
18:55:24 <athan> under extra-deps
18:55:40 <athan> stack --solver usually adds them automatically
18:55:43 <kwantam> athan: coming into this late, but if /tmp resides on a noexec/nosuid partition you might try making a temporary directory elsewhere and then setting TMPDIR=<that other location>. I don't know for sure but it seems reasonable to hope that stack will respect this environment variable.
18:55:52 <peddie> gouwe: the point is to tell stack it's allowed to use a newer version of `hlint` and any packages it depends on than the version it has in the LTS release you're using
18:59:00 <athan> gouwe: I was wrong actually, /tmp is set to a+wrx, that's why it looked funny
18:59:12 <athan> but no, $TMPDIR has no effect :/
18:59:33 <gouwe> peddie: got it, misinterpreted the message, works now, ty!
19:00:00 <gouwe> athan: so it's not a mount, it's a regular folder in root mount)?
19:00:18 <athan> i believe so gouwe
19:00:29 <athan> It's not listed under `mount`
19:01:11 <athan> the odd thing is I can see other folders in /tmp, but any /tmp/stack folders don't exist
19:01:39 <gouwe> it might be deleted after stack finishes, cleanup
19:01:58 <athan> hmh
19:02:09 <athan> mer
19:02:47 <athan> to whomever can answer this question, can you tell me via lambdabot's @tell? Thank you ;-;
19:05:17 <gouwe> athan: do findmnt --target /tmp
19:06:54 <gouwe> if it lists noexec / nosuid, you may try to rename and mount tmpfs there, this should work mount -o exec,suid -t tmpfs /tmp
19:07:17 <MarcelineVQ> @tell athan the error you pasted says "Logs have been written to: /root/.stack/global-project/.stack-work/logs/network-2.6.3.1.log"
19:07:17 <lambdabot> Consider it noted.
19:07:54 <MarcelineVQ> though, idk how useful those are of if they just repeat what athan saw already
19:16:00 <athan> I feel like I should mess with the fstab or soemthing
19:18:23 <athan> MarcelineVQ: It's the exact same output :/
19:21:25 <gouwe> athan: for testing, you can do it without messing with fstab, rename then: mount -o exec,suid -t tmpfs /tmp
19:21:35 <gouwe> athan: though, confirm that it's noexec or nosuid by: findmnt --target /tmp
19:25:57 <athan> `mount -o exec,suid -t tmpfs /tmp` complains that there's no /tmp entry in fstab lol
19:26:06 <athan> (after I moved the old /tmp)
19:26:10 <athan> but yeah, getting closer I think
19:26:36 <athan> I tried an entry like `/tmp none tmpfs exec,suid 0 0`, but I don't think it's right
19:26:43 <athan> "no mount point none"
19:31:44 <athan> ffs, linode does something to create a /tmp on boot
19:38:15 <gouwe> athan: sorry, try: mount -o exec,suid -t tmpfs tmpfs /tmp
19:45:22 <athan> Oddly enough actually, it looks like my /tmp is working correctly. It's still 777, but idk if that matters
19:45:38 <gouwe> athan: sorry, try: mount -o exec,suid -t tmpfs tmpfs /tmp
19:45:40 <athan> the new /tmp I mean
19:45:45 <athan> :O
19:46:59 <athan> gouwe: I don't think that's right
19:47:18 <gouwe> athan: i tried locally, the above mounted fine
19:47:31 <gouwe> not sure if that's causing the issue with the install tho
19:47:41 <athan> er, derp i don't think Iused -t
19:47:46 <athan> i can't see above :(
19:56:44 <glguy> Doing adventofcode.com tonight? Make sure you're on the #haskell leaderboard. Key in /topic
19:58:25 <athan> advent of code? :o
19:59:18 <kadoban> Ya'll should do https://www.hackerrank.com/w27 too :) You can use haskell, heh.
20:00:50 <athan> *shrug*
20:11:51 <byorgey> gouwe: I think you'll have to add haskell-src-exts-1.19.1 as an extra-dep as well
20:17:51 <Lokathor> http://lpaste.net/350189
20:18:48 <Lokathor> so i wrote an IO wrapper that I think is cool, but like all things MVar it's still seemingly dangerous to use
20:19:03 <glguy> Lokathor: You should use 'withMVar' for that so that the MVar is restored in the case of iob throwing an exception
20:19:44 <Lokathor> ah hmm
20:20:12 <Lokathor> passes an extra param, which is why i glazed over it when i scanned the library
20:24:09 <Lokathor> guess all i need is (withMVar_ :: MVar a -> IO b -> IO b) then
20:24:22 <Lokathor> which is simple enough
20:39:09 <Lokathor> the more i think about what i want, the more it becomes clear that a TChan is actually needed here
20:57:17 <Lokathor> nope, worse, i need to intermix mvar and Tvar/tchan i think
21:08:12 <Cale> Lokathor: Note also that there is TMVar
21:09:10 <Lokathor> for all my variable trademark needs?
21:10:00 <Lokathor> ah, no, this is almost the exact opposite of what i wanted :P
21:11:31 <Lokathor> I need to connect IO actions and STM actions together, so the MVar must be outside STM
21:13:07 <osa1> any distributed-process users here? how do I wait a process created by forkProcess?
21:13:16 <Cale> Lokathor: What do you mean by "connect"?
21:13:25 <Cale> Lokathor: Usually, it's "atomically" which does this.
21:13:51 <Cale> Lokathor: Any STM action can be turned into an IO action.
21:14:03 <Lokathor> in this case, there will be console effects
21:14:13 <Lokathor> and the console effects must be precisely lined up with the STM side of things
21:14:23 <Cale> Lokathor: Note also that since STM actions are allowed to have any sort of result, you may in some cases want to produce an IO action as a result of your STM transaction.
21:15:36 <Cale> It's generally not possible for STM actions to cause IO to occur during their execution (because they may be retried arbitrarily often, in a somewhat unpredictable fashion, even if you were allowed to do this, you usually wouldn't want to)
21:15:47 <Lokathor> yes exactly
21:15:47 * ertes is wondering whether what Lokathor needs is FRP
21:16:08 <Lokathor> ertes, not unless FRP gracefully interacts with blocking FFI calls :P
21:16:09 <Cale> However, you can produce a result which is an IO action, and run that after the transaction commits
21:16:35 <Cale> Or of course, you can carry out some IO before the transaction, and pass the results from that in.
21:16:50 <ertes> Lokathor: events/behaviours can be connected to MVar/STM
21:17:00 <Lokathor> Cale, there would still be no way to ensure that the IO result executed before another IO action in another thread did its own thing, which is why i want the MVar to lock around console access
21:17:31 <Cale> Oh, it's common to just have a single thread manage the console
21:17:41 <Cale> and have other threads communicate with that one
21:17:54 <Lokathor> Cale, yes. In this case there's two threads that will mange the console, and TChan stuff going places to get data around
21:18:03 <ertes> Lokathor: a special use case of it is to "keep the UI up to date" in response to things that happen async
21:18:47 <Lokathor> ertes, hmm, does it still work if user input is a blocking FFI call?
21:19:40 <ertes> Lokathor: sure…  if that's the only input source, you can put it into the same thread…  if not you put it into a different thread…  your thread graph actually wouldn't change at all
21:20:09 <Lokathor> ertes, interesting. If only I knew how FRP actaully worked :P
21:20:24 <Lokathor> i always see it being done with web UI stuff
21:20:54 <Lokathor> and I have zero interest in web UI stuff, I just want idle games and console games and other dumb things
21:21:13 <ertes> well, i have to leave now, but i'm happy to explain later, if nobody else does in the meantime =)
21:21:23 <Lokathor> okay
21:22:08 <Lokathor> Cale, in this case, I want to have one thread that constantly reads each key of input, and then when enter is pressed that buffered up "line" gets put into the main portion of the program.
21:22:40 <Lokathor> however, in the mean time, output signals that go out delete the current buffered text on screen, do their output, and then restore the buffer visually
21:22:51 <Lokathor> so that the user will see no interruption to their partial command
21:38:05 <osa1> I'm wondering about how distributed-haskell nodes and processes map to OS processes and GHC threads. any resources on this?
22:44:32 <Lokathor> the pipes documentation implies that the ListT from transformers doesn't obey the monad laws
22:44:40 <Lokathor> do people know what that's about?
22:44:50 <geekosaur> it should be docuemnted with ListT
22:45:23 <geekosaur> "Note: this does not yield a monad unless the argument monad is commutative."
22:45:38 <dmwit> ?hackrilege Oh yeah, and I almost forgot this one, in which I show how to use data-reify to implement an equality that would say that `z = ():():z` and `z' = ():():z'` are equal. http://stackoverflow.com/q/28243314/791604
22:45:38 <lambdabot> Unknown command, try @list
22:46:38 <geekosaur> Lokathor, also see https://wiki.haskell.org/ListT_done_right
22:47:59 <Lokathor> oh boy, the highlighting on the wiki really leaves a lot to be desired it seems
22:48:06 <geekosaur> yes :(
22:49:55 <dmwit> Oops, of course I meant `z = ():z`. Oh well.
22:51:01 <Lokathor> so, i'm a little confused
22:51:16 <Lokathor> if there's correct versions of ListT that exist... why does transformers have a wrong version?
22:51:33 <geekosaur> because too many programs expect the broken one
22:51:46 <Rotaerk> **** em
22:51:55 <dmwit> I'm with Rotaerk. And Lokathor.
22:52:13 <Lokathor> i'm with me and Rotaerk too
22:52:14 <jle`> Lokathor: historical reasons
22:52:21 <dmwit> Completely unrelatedly: none of my packages on Hackage has ever gotten popular! I wonder why.
22:52:32 <Lokathor> :3
22:52:43 <geekosaur> and I gather there's no way to make e.g. LogicT a drop in replacement
22:52:45 <Lokathor> i don't put things on hackage, that's my problem
22:54:39 <jle`> well, you can deprecate ListT and tell people to write (MonadPlus m) => ... instead of ListT
22:54:53 <jle`> er, MonadPlus (m t)
22:55:01 <jle`> then you can keep on using ListT if you want i guess
22:55:47 <jle`> *t 
22:55:50 <jle`> m
22:56:22 <johnw> I don't think that the ListT m a which is defined as m [a] is even terribly useful
22:56:57 <johnw> more useful is the LogicT from package-I-forget-its-name
22:58:10 <nshepperd> package logict :)
22:58:20 <dmwit> listt is also a fine package.
22:58:37 <dmwit> Sorry, list-t
22:58:57 * nshepperd notes that all of the cool packages seem to be written by people named Oleg
22:59:47 <jle`> yeah, it's not useful, but MonadPlus (m t) should be usable as both if people ever decide they really don't want ListT
23:01:35 <johnw> I don't really see how that's equivalent
23:02:28 <Lokathor> I think I could hook pipes into my desired program
23:02:39 <Lokathor> but i'm not sure it would help compared to just TChan use
23:03:06 <Lokathor> is there perhaps a free 400 page book to convince me to use pipes like there is for haskell concurrency?
23:04:17 <jle`> Lokathor: what are you looking for?
23:04:34 <Lokathor> i'm not sure
23:04:45 <Lokathor> that is, i happened to read the pipes docs just now on a whim
23:04:58 <Lokathor> and i wasn't intendeing to use them until i saw "hey this is actually pretty cool"
23:05:38 <Lokathor> aside: does the monad instance for list on its own, not ListT, follow the monad laws and also achieve maximum lazyness?
23:06:05 <geekosaur> list monad itself is fine
23:06:17 <Lokathor> oh good
23:06:22 <Lokathor> my for loops are safe
23:06:31 <jle`> it's one of the more famous monads actually :)
23:08:33 <Lokathor> yeah i read about it in the book
23:13:14 <Lokathor> jle`, https://github.com/Lokathor/galaxy-break/blob/master/lib/Control/Console.hs#L33 i'm looking to make that concurrent, basically
23:13:21 <Lokathor> I think in this case, pipes is overkill
23:15:10 <jle`> concurrent how?
23:16:17 <Lokathor> uh, the buffer would end up in an mvar, inputs would grab the mvar, add to the buffer, display the char (because the terminal is in noecho mode), and then put that back into the mvar and loop without holding the mvar
23:17:16 <Lokathor> outputs would grab the mvar, erase the current buffered text, print the entire desired message, and then print the partial buffer, and then put the buffer back into the mvar
23:19:40 <dmwit> Sounds like you kind of just want some curses-alike instead maybe?
23:19:48 <dmwit> Have you looked into brick?
23:19:57 <Lokathor> yeah, curses would be cool, if windows did it :P
23:20:23 <dmwit> Oh, yeah, Windows doesn't have many good VTY emulators. =)
23:20:35 <Lokathor> brick depends vty, which depends unix = no good >_<
23:23:33 <banjo> cygwin has rxvt and urxvt
23:24:34 <liste> @hackage ansi-terminal -- this works on Windows too
23:24:34 <lambdabot> http://hackage.haskell.org/package/ansi-terminal -- this works on Windows too
23:26:12 <liste> it's not as fully-featured as vty/brick though
23:38:13 <Lokathor> to read in one character at a time in the windows console you need to enable a special mode
23:38:36 <Lokathor> otherwise the terminal itself buffers the input until return is hit
23:39:14 <Lokathor> GHC doesn't support doing this properly, and it has had this bug in trac since it was 6.x
23:41:45 <Lokathor> however, given ansi-terminal and a little platform specific code, one could totally rig up a curses interface within windows if they wanted
23:42:04 <Lokathor> directly emualting curses is madness of course, because curses is terrible in a billion ways
23:43:45 <dmwit> Maybe something curses-like. But curses (and more modern alternatives) do a bunch of other stuff not related to output.
23:44:52 <dmwit> There's a bunch of stuff I don't understand about terminal capabilities, for example; and I think those libraries typically do some mapping of low-level input events into more abstract forms (like converting "\ESC[B" into up arrow and stuff).
23:45:12 <geekosaur> that part is less important since ANSI X3.64
23:45:33 <Lokathor> the thing is, SetConsoleMode allows you to do basically cbreak(), but it also forces noecho(), so it's not *quite* the same as (hSetBuffering stdin NoBuffering)
23:45:43 <geekosaur> the main points of curses were (a) managing independent panes without each having to know about the others (b) optimal screen updates when rendering/updating those panes
23:46:18 <geekosaur> (b) is another thingt hat is largely unimportant now. it mattered a *lot* when your terminal was over a 1200 baud dialup
