00:00:24 <cocreature> the problem is the one nshepperd explained: to see if a number is prime you are testing against all primes but you don’t have these calculated yet
00:00:43 <nshepperd> like, as written you are testing every single prime before you can even declare that 3 is prime
00:00:52 <NextHendrix> cocreature: but i do have 2, which should be enough to get 3
00:01:24 <cocreature> NextHendrix: no, 3 could be divisble by a number larger than 3
00:01:33 <cocreature> ofc it isn’t but ghc isn’t smart enough for that
00:01:39 <NextHendrix> good point
00:01:43 <NextHendrix> takewhile is a good shout
00:01:48 <NextHendrix> forgot about that
00:02:53 <nshepperd> also I am not sure but it looks like this is actually not quite right because it is saying "for all x, and all y, if x % y = 0, then produce x"
00:03:09 <nshepperd> which I suppose is why you manage to get 3
00:03:39 <nshepperd> you actually want "for all x, if [x % y = 0 for all y] then produce x"
00:03:44 <cocreature> oh right I just had a typo that caused me to not getg 3
00:07:29 <sophiag> so you're doing this as a list comprehension? mine should be about the same except in a do block: http://lpaste.net/349701
00:13:11 <NextHendrix> primes = 2 : [x | x <- [3,5..], y <- (takeWhile (<x) primes), rem x y /= 0]
00:14:29 <NextHendrix> lol seems to work apart from repeating every prime a ton of times
00:14:50 <NextHendrix> stick a (not (elem x primes)) in there stops it working again
00:15:08 <cocreature> this doesn’t work, it will give you nonprimes
00:15:41 <cocreature> specifically it will give you every number for which there is a prime number that does not divide it
00:15:45 <sophiag> you're just repeating odds
00:16:02 <NextHendrix> every number where a prime doesnt divide it is prime
00:16:06 <sophiag> the idea is to feed the primes back into the list you test rem or mod with
00:16:40 <cocreature> NextHendrix: no every number where _all_ other primes don’t divide it is prime
00:17:46 <sophiag> oh, i have that error in my code too...
00:18:24 <sophiag> i can't get it to compile tho
00:18:36 <NextHendrix> lol, im going to eat some breakfast and reformulate
00:19:16 <sophiag> i'm just wondering if anyone would look at five lines and tell me where my syntax is off
00:19:34 <cocreature> sophiag: do you still have the same code you posted earlier?
00:20:08 <cocreature> sophiag: also it would be helpful to add the errors you’re seeing to your lpaste
00:20:22 <sophiag> yeah i've been posting it intermittently while i read
00:21:06 <cocreature> sophiag: instead of pattern matching on xs and calling head and tail you should pattern match on (x:xs) and use x inplace of head xs and xs in place of tail xs
00:21:11 <sophiag> no one has been looking at the lpaste or responding so i didn't add the errors...
00:21:41 <sophiag> well, i tried that initially and it still didn't compile. i'll modify it and update
00:22:12 <cocreature> you probably need a mapM if you’re working in do notation
00:23:00 <cocreature> sophiag: what are you trying to achieve by using do notation?
00:23:19 <cocreature> it seems like you are trying to use do notation for lists but you are not really
00:23:29 <sophiag> i'm learning haskell...
00:23:47 <sophiag> i'm just trying to implement a familiar algorithm in order to help learn haskell...
00:23:52 <cocreature> sophiag: are you trying to learn do notation or are you trying to learn how to calculate the primes in haskell?
00:24:04 <cocreature> because I don’t think using do notation is useful for implementing the latter
00:24:28 <Cale> It's not un-useful... it's good for the same stuff list comprehensions are good for
00:24:29 <sophiag> well i *could* use do notation
00:24:38 <sophiag> that doesn't explain the syntax errors
00:25:01 <cocreature> you still haven’t shown us the syntax errors
00:25:11 <cocreature> there are a few type errors but I haven’t spotted syntax errors yet
00:25:57 <Cale> Yeah, I don't see syntax errors, only type errors: specifically, you're comparing the function  when (head xs `mod` test)  to  0
00:26:06 <sophiag> http://lpaste.net/349701
00:26:18 <Cale> and of course, (head xs `mod` test) isn't a Bool, so it's not an appropriate argument to when
00:26:36 <sophiag> i guess since i chose do notation i'd like to make sure i'm getting it right before i move to a more appropriate syntax
00:26:43 <Cale> Yeah, you meant to write  when (x `mod` test /= 0)
00:26:48 <sophiag> rather than just abandoning it without understanding what i'm doing
00:27:10 <Cale> But also, it doesn't tend to be so helpful to ignore the results of actions in a do-block for the list monad
00:27:50 <cocreature> "return primes" should also be a type error
00:28:01 <Cale> "Running" a list means picking an element from it in all possible ways. If you don't capture the result, all it does is multiply the number of elements in the eventual list produced by this branch of the computation by the length of whatever list it was (since you're picking each of the elements, and ignoring it)
00:28:17 <Cale> e.g...
00:28:26 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
00:28:28 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
00:28:36 <Cale> if we ignore the result of y...
00:28:42 <Cale> > do x <- [1,2,3]; [4,5]; return x
00:28:44 <lambdabot>  [1,1,2,2,3,3]
00:28:58 <Cale> > do [1,2,3]; [4,5]; return ()
00:29:01 <lambdabot>  [(),(),(),(),(),()]
00:29:23 <Cale> > do [1,2,3]; [4,5]; return [2,3,5,7]
00:29:25 <lambdabot>  [[2,3,5,7],[2,3,5,7],[2,3,5,7],[2,3,5,7],[2,3,5,7],[2,3,5,7]]
00:29:42 <sophiag> ok, i don't understand what that has to do with this
00:29:56 <sophiag> i understand about the return
00:30:10 <sophiag> not about why /= isn't producing a Bool
00:30:12 <Cale> Well, you have what are presumably a couple lists there on the first two lines in your do-block
00:30:39 <Cale> One of which is sieve xs, the other of which is some type-errory thing :)
00:30:58 <Cale> and you're picking an element from each of those in all possible ways, ignoring what elements you picked
00:31:03 <Cale> and then returning [2,3,5,7]
00:31:39 <Cale> So even once this typechecks, it's just going to produce a list of some number of copies of [2,3,5,7]
00:31:44 <cocreature> sophiag: let’s go back a step: can you explain how you thought your implementation works?
00:32:08 <sophiag> um...this is the sieve of eratosthenes
00:32:16 <cocreature> sophiag: first of all: what argument do you pass to sieve to get the list of primes
00:32:30 <sophiag> it's what the guy you just spent a half hour talking to was trying to do
00:32:50 <Cale> (except it's... very much not that)
00:33:01 <cocreature> I know the sieve of eratosthenes but your implementation doesn’t calculate it
00:33:08 <cocreature> so I’d like to help you understand why it doesn’t
00:33:21 <cocreature> but to do so I need to understand why you wrote it that way
00:33:22 <sophiag> you pass it a list of ints of bignums
00:33:30 <cocreature> which list?
00:33:38 <sophiag> (x:xs)
00:33:55 <sophiag> it's also customary to start off with some primes
00:34:01 <sophiag> those are provided
00:34:08 <Cale> cocreature means which *actual* list will you pass it in the end to really compute primes?
00:34:42 <sophiag> [2..100000000000000000000]
00:34:45 <sophiag> something like that
00:34:51 <sophiag> but probably smaller
00:35:47 <sophiag> i know the algorithm, that's why i chose it. i don't know haskell well obviously :D
00:35:47 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
00:35:50 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
00:37:09 <Cale> > let sieve (x:xs) = x : sieve (filter (\y -> y `mod` x /= 0) xs) in sieve [2..]
00:37:12 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
00:37:52 <Cale> > let sieve (x:xs) = x : sieve (do y <- xs; guard (y `mod` x /= 0); return y) in sieve [2..]
00:37:54 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
00:38:01 <sophiag> ah ok
00:38:30 <Cale> (It's not really the sieve of Eratosthenes, it's more like trial division, but it sort of looks like it anyway.
00:38:32 <Cale> )
00:38:32 <sophiag> so that's how you'd go about feeding the output of a function into the lambda to test it
00:38:47 <sophiag> no, trial division would mean you have the list of primes readymade
00:38:54 <sophiag> not from a feedback loop
00:39:06 <sophiag> like i had a file i loaded
00:39:20 <Cale> Well, you end up trial dividing by every number from 2 up to n in order to check if n is prime with that last one
00:39:30 <sophiag> oh, that's not what i'm trying to do....
00:39:42 <Cale> My first one is a little bit better, it only checks *primes* from 2 up to the square root of n
00:39:51 <sophiag> i want y in that lambda to loop through the list of primes...that's the whole point
00:39:51 <Cale> (and discovers what the primes are as it goes)
00:40:17 <sophiag> it doesn't seem like either do that
00:40:29 <sophiag> you just test by odds
00:40:29 <Cale> https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
00:40:43 <sophiag> the square root one?
00:40:48 <sophiag> i know that?
00:41:00 <sophiag> i'd like to get the basic one down at least
00:41:04 <sophiag> feed the list of primes back in
00:41:11 <sophiag> before returning the result
00:41:22 <Cale> Which basic one?
00:41:35 <sophiag> Eratosthenes
00:41:39 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes -- this mutually recursive one?
00:41:41 <sophiag> so you don't divide by odds
00:41:42 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
00:41:53 <sophiag> you divide by the list of primes as you build it up
00:41:55 <Cale> Neither of these is the sieve of Eratosthenes really.
00:42:02 <sophiag> yes, exactly
00:42:08 <sophiag> so neither answers my question
00:42:23 <cocreature> sophiag: how about http://lpaste.net/349708
00:42:28 <sophiag> here's the thing: i know the algorithm
00:42:38 <sophiag> what would help is fixing my syntax in haskell
00:42:49 <sophiag> for example, i still don't know what was wrong with that paste
00:43:28 <Cale> Well, the do-block in your paste didn't make any sense at all...
00:43:45 <cocreature> sophiag: the thing is: your code does not mainly have a syntactic problem
00:43:54 <cocreature> it doesn’t calculate what you are trying to calculate
00:44:05 <cocreature> and fixing the syntax won’t fix your code
00:44:11 <Cale> do for lists is a way of iterating through a bunch of choices -- it's the same as a list comprehension really
00:44:23 <sophiag> well, that's what sieving is
00:44:36 <sophiag> none of your examples is this algorithm
00:44:45 <sophiag> they may as well be ran strict
00:46:03 <cocreature> sophiag: one syntax error in your code is that "when x `mod` test /= 0" needs parantheses so it is "when (x `mod` test /= 0)"
00:46:19 <sophiag> so you're saying it doesn't make sense to implement as a do block, but also you can't tell me any other way to do it and i should instead use a slower algorithm?
00:46:27 <cocreature> eh even more when ((x `mod` test) /= 0)
00:46:44 <Cale> The real algorithm would use some sort of priority queue to keep track of what the next values to consider are, or else some sequence type from which we can very efficiently delete elements.
00:46:47 <sophiag> cocreature: yup, i saw you say that initially and corrected it. thanks
00:46:53 <Cale> (by index)
00:47:01 <sophiag> Cale: no. that's not how it works
00:47:04 <cocreature> tbh I think my algorithm comes pretty close
00:47:25 <sophiag> the idea is very very simple. i've implemented this in several other languages
00:47:36 <Cale> I mean, something which really matches the proper asymptotic complexity of the Sieve of Eratosthenes
00:47:45 <sophiag> you simply feed your output back in
00:48:03 <cocreature> I give up I don’t understand your problem
00:49:01 <sophiag> ok the input is a list like [1..100]. got that?
00:49:18 <sophiag> then you start off your primes with say [2,3,5]
00:49:49 <cocreature> sry I need to do other things now
00:49:53 <sophiag> then you loop through testing modulo on each number in the input with each number in the list of primes
00:50:24 <Cale> See, if we say "oh, the first element n of this list is prime, let's filter it to remove the multiples of n", so each prime will end up getting modded out by every number less than it by the time we discover it's prime. So working our way through k of the primes will require O(k^2) work
00:50:44 <sophiag> wow ok
00:51:01 <Cale> The real sieve of Eratosthenes avoids that. :)
00:51:15 <NextHendrix> theres an interesting paper about it
00:51:23 <Cale> I actually linked that paper ;)
00:51:26 <sophiag> this is literally the simplest algorithm used to teach lazy evaluatoin
00:51:41 <NextHendrix> oh right been away cooking quesadillas
00:52:17 <Cale> Well, yeah, if you write the naive thing, it's easy to understand, and yeah, you can take advantage of lazy evaluation, but it's not *really* the Sieve of Eratosthenes proper
00:52:41 <Cale> It's possible to do a real one, but it involves something a bit more subtle to keep track of the work left to be done
00:52:51 <sophiag> yeah, i finally got some folks to look at my code after posting a past for an hour and they said it "doesn't make sense" and they'd never heard of this algorithm and instead i should just divide by all odd numbers
00:53:06 <cocreature> wut?
00:53:17 <Cale> The code you wrote indeed made no sense :)
00:53:30 <uiop> heh
00:53:34 <Cale> Probably do-notation for lists does something completely different from what you expected
00:53:42 <Cale> (but I have no idea what you expected)
00:53:42 <MarcelineVQ> if that's what you want to take away from it, what I see though is that you may be missing the three puzzle pieces, what does do syntax desugar to, what does return do, what does it mean for things to be immutabe
00:53:50 <NextHendrix> https://en.wikipedia.org/wiki/Sieve_of_Atkin
00:54:07 <sophiag> the sieve of atkins is for testing primes i believe
00:54:10 <sophiag> not for finding primes
00:54:25 <NextHendrix> finds all primes up to a specified integer
00:54:29 <uiop> sieve of atkins, no carbs, only protein
00:54:30 <cocreature> “In mathematics, the sieve of Eratosthenes (Ancient Greek: κόσκινον Ἐρατοσθένους, kóskinon Eratosthénous), one of a number of prime number sieves, is a simple, ancient algorithm for finding all prime numbers up to any given limit.” wikipedia disagrees
00:54:31 <uiop> and primes
00:54:35 <cocreature> oh I misread
00:54:37 <cocreature> sry
00:54:55 <sophiag> oh not atkins is the one that uses squares
00:55:20 <sophiag> anyway...i was going for the simplest one
00:55:46 <sophiag> the simplest one other than just dividing by every odd number.....
00:55:57 <sophiag> basically the simplest one you'd use a computer for
00:56:19 <cocreature> sophiag: if it’s so simple, how about you implement it so we can take a look and learn from it?
00:56:32 <uiop> sophiag: efficiency of the (machine code of the) haskell you might write is a function of the compiler, not of the universe
00:57:23 <uiop> sophiag: in theory theory and practice are the same, in practice they arent
00:57:30 <uiop> etc equival;ent rephrasings
00:57:33 <sophiag> ok, how would you like? i found over a half dozen haskell versions on google
00:58:03 <cocreature> yeah we’ve given you a few ourselves
00:58:12 <Cale> sophiag: Many of them won't really have the right asymptotic complexity though...
00:58:56 <cocreature> Cale: well it depends on how you define the “right asympotics”. I think most people just associate the naive sieve with the name
00:59:20 <uiop> it should be pretty clear what big O you're pulling
00:59:23 <cocreature> e.g. the wikipedia pseudocode also does the naive thing
00:59:35 <sophiag> if you're just dividing by all odd numbers then you're worse than random children 3000 years ago drawing in sand
00:59:48 <sophiag> the point of the algorithm is to feed the input back in to test by
00:59:58 <sophiag> it's literally in the name
01:00:01 <sophiag> "sieve"
01:00:25 <sophiag> it's not called "brute force of Eratosthenes"
01:00:46 <cocreature> sophiag: alright, explain to me how http://lpaste.net/349708 is the same as dividing by all odd numbers
01:00:52 <NextHendrix> its still brute force
01:01:16 <Cale> Well, according to the actual sieve algorithm as Eratosthenes described it, where you start out with a list of the numbers 2 up to n, and cross off all *multiples of 2*, and so on, with the *multiples* of whatever the first number was remaining
01:01:25 <Cale> Rather than ever computing mod
01:01:29 <sophiag> i think that looks good, rigtht?
01:02:07 <cocreature> Cale: ah that’s what you were referring to
01:02:15 <Cale> and so you perform n/p crossings-off for each prime less than n
01:03:01 <Cale> and, using an estimate for the number of primes less than n (the prime number theorem), this means the algorithm performs around n log log n steps.
01:03:40 <Cale> (n log log n + O(n) steps)
01:04:29 <uiop> heh what was that one quote at one point, something like "the list monad: making exponential time algorithms so easy a 5 year old could do it since <date-of-haskell-inception>" or something (i'm paraphrasing a vague recollection)
01:04:59 <uiop> that was my favorite
01:05:12 <Cale> heh
01:05:44 <Cale> Well, it's not quite exponential in this case, the really naive sieve is just quadratic.
01:06:16 <Cale> (plain trial division is a bit better than that, it's roughly O(n sqrt(n))
01:06:19 <Cale> )
01:08:02 <Cale> Well, very slightly better than quadratic, it does O(n^2 / (2 (log n)^2)) divisions.
01:08:18 <Cale> (you can see the paper I linked for details like this)
01:09:05 <sophiag> cocreature: i'm just trying to modify that snippet so you can start with a list of primes to append to. also not sure i understand why it requires a guard around the return?
01:10:39 <Cale> The trouble is, if you want to work with the multiples of p when expressing a real Sieve of Eratosthenes, you need a priority queue to help keep track of the order in which the next multiples you already know you've crossed off occur
01:11:25 <Cale> (It's just sort of something nice that paper and your eyes do for you when you carry out the sieve on paper for yourself)
01:12:25 <cocreature> Cale: you only need that queue if you want to calculate the primes lazily right? otherwise you can just loop over the array with multiples of p
01:13:29 <Cale> Well, I suppose you can use the array itself as a poor-man's priority queue, and just have lots of physical blanks that just sit there until you're done.
01:14:15 <Cale> (supposing that you're mutating it)
01:14:24 <Cale> Actually, that might work all right with a Map... hmm
01:14:42 <uiop> cocreature: probably, the greatest trick the devil ever played is beating you in reality-time with a slower big O algorithm because your constant is just too yuge
01:14:43 <Cale> or a Set
01:14:58 <cocreature> uiop: heh, true
01:15:54 <Cale> P = NP, but the constant factor is Graham's number
01:16:53 <uiop> in other words, hail satan :D
01:18:27 <Cale> I often think that we don't properly appreciate what sort of stuff might go on at the large end of P
01:18:58 <Cale> Almost all our sensible mechanisms for producing polynomial time algorithms don't really expand the degree of the polynomial very rapidly.
01:21:22 <Cale> Who knows? There might be some Ramsey-theoretical sort of things that go on when the degree gets really large.
01:23:55 <Cale> An interesting result (not really relevant to this, but illustrative of the weird kinds of things that go on with large numbers) is that for any number of players c, and any board side length n, there is a number of dimensions H such that H-dimensional generalised tic-tac-toe on an n*n*...*n = n^H board can't end in a draw.
01:26:17 <Cale> i.e. eventually H is large enough so that no matter which way you colour in the board with c different colours, there's forced to be a row along some axis or some diagonal which is all the same colour.
01:26:26 <uiop> interesting
01:27:22 <nighty> Guys, just a quick question 
01:27:28 <Cale> sure
01:27:42 <nighty> is there a place where you can post job offers for haskell ?
01:27:53 <uiop> loosely in the same vein, that new graph iso in P (right?) proof sounds super interesting
01:27:57 <uiop> been meaning to check it out
01:28:07 <Cale> nighty: Well, the haskell subreddit seems like a good place to get some attention
01:28:24 <nighty> Ah I did not know that one
01:28:31 <Cale> uiop: Not quite P
01:28:41 <nighty> Cale, thanks I will try that
01:29:18 <Cale> It's in quasipolynomial time
01:30:04 <Cale> exp((log n)^f(n)) time where f(n) is O(1)
01:30:49 <uiop> i always thought it would go down by doing something like iterated vaniching of intersection graphs of sets of cycles (or something) (this is my own paraphrasing of a personal vague thought, excuse the autasm), but from my understanding it got done by some technical i-dont-recall-actually (:D)
01:31:09 * uiop passes out
01:32:03 <Cale> uiop: There are some video presentations about it that Babai gave as he was publishing the result
01:32:23 <Cale> https://www.youtube.com/watch?v=r-nCYbX_Au0
01:32:30 <uiop> Cale: cool, thx
01:54:48 <piyush-kurur> uiop: The algorithm is like n^(poly(log n))
01:57:32 <piyush-kurur> uiop: if you want to understand it you might want to read a bit of previous work particularly the Luks polytime algorithm for bounded valence graphs
02:21:18 <arianvp2> Hey
02:21:36 <arianvp2> When I spawn a thread that forks a process,  the process gets terminated if I send SIGINT to the main thread
02:21:47 <arianvp2> but if I send SIGTERM to the main thread,  haskell doesn't clean up the child processes
02:21:54 <arianvp2> I have no idea where or how this distinction is made
02:21:58 <arianvp2> and it feels very buggy..
02:22:48 <arianvp2> this happens in both of the cases that:  delegate_ctlc=False and delegate_ctlc=True
02:24:45 <orion> hmm. Does anyone know why cabal-install 1.24.0.1 fails to compile with GHC 8.0.1 installed?
02:38:33 <srhb> orion: As far as I know, it doesn't. more information needed.
02:42:51 <bollu> I'm writing bindings to sympy, and I have both matrices and regular "symbols". How do I implement (*), (+), etc on things like matrices? the Num typeclass has "too much"
02:42:56 <bollu> do I use some other numeric tower?
02:43:22 <bollu> if I do use a separate tower, how will end users be effected?
02:44:19 <merijn> bollu: The simplest approach is, generally, to use different operators than *
02:45:02 <merijn> @hackage vector-space
02:45:02 <lambdabot> http://hackage.haskell.org/package/vector-space
02:45:06 <merijn> See that for examples
02:45:16 <bollu> merijn: hm
02:45:22 <merijn> Or maybe you just want to directly use the classes in there
02:45:24 <bollu> merijn: is there some consensus on operators for matrices?
02:45:55 <bollu> merijn: sounds reasonable, though I don't have a notion of a "vector space" in symengine
02:46:20 <bollu> in the library, a matrix is more "grid of numbers" than "linear transformation representation with a choice of basis" :)
02:47:34 <bollu> or are you saying that I should consider the matrices themselves as a vector space with respect to my scalars
02:47:35 <bollu> ?
02:47:43 <bollu> but then what about matrix multiplication?
02:48:06 <merijn> bollu: You can have a look at what hmatrix, hblas, etc. all do?
02:48:32 <bollu> merijn: oh, thank you for the pointer
02:48:52 <merijn> I don't have a lot of experience with this stuff, the only solid advice I can give you is "trying to force it into fitting in Num will make you miserable, so abandon that idea now" :)
02:50:46 <Cale> If you only care about square matrices of a fixed size, then Num is okay.
02:53:09 <merijn> Cale: That seems like an oddly specific and unlikely restriction :)
02:53:53 <bollu> merijn: looks like they define the monoid instance for multiplication, and use "add" for addition
02:54:00 <bollu> dang, I really wish I could express rings :(
02:54:27 <bollu> what is the general opinion on breaking prelude by using a different numeric tower?
02:54:31 <bollu> "bad citizen">
02:54:33 <bollu> ?
02:54:50 <Cale> merijn: If you're just doing a specific sort of geometry, it comes up
02:56:05 <bollu> Cale: 3d game programming? :)
02:56:13 <Cale> bollu: yeah, like that
03:01:32 <lpaste> dramforever pasted “What's going on here? (GHC 8.0.1)” at http://lpaste.net/349710
03:02:59 <dramforever> Hi. <context>A question of showing the evaluation status of values in GHCi was brought up in a Chinese Haskell chatroom.</context>
03:03:05 <Cale> heh, good question
03:03:15 <dramforever> We found this puzzling behaviour while talking about it
03:03:24 <orion> srhb: I figured it out: http://lpaste.net/939951840382943232 I just switched to 1.24.0.0 and it seems to be working.
03:03:37 <merijn> bollu: Well, using a different numeric tower doesn't break the prelude, unless you use one that uses the same operators
03:06:12 <lpaste> dramforever revised “What's going on here? (GHC 8.0.1)”: “What's going on here? (GHC 8.0.1)” at http://lpaste.net/349710
03:07:23 <dramforever> <wild-guess>Maybe GHC considers "xy" unevaluated but ['x', 'y'] evaluated</wild-guess>
03:08:06 <Cale> oh, of course
03:08:15 <Cale> OverloadedStrings
03:08:24 <dramforever> It's not on
03:08:29 <Cale> Perhaps even so
03:08:46 <dramforever> Hmm, could be
03:08:56 <dramforever> Perhaps I should go get an old GHC?
03:09:01 <bollu> merijn: which is a tower that has different operators?
03:09:12 <bollu> also, for quickCheck, I need IO to generate an Arbitrary
03:09:48 <bollu> what do I do in this case?
03:11:00 <Cale> dramforever: You'll notice that if you apply fromString to the ['x','y'], it'll be lazy about it again. It still doesn't quite make sense to me why it starts showing it as a String literal.
03:11:42 <Cale> But there must be some heuristic for deciding that it's okay to show something of type [Char] as a string literal, and that's going wrong
03:13:45 <dramforever> But 'let x = error "x"' then ':sprint x' shows 'x = _'
03:14:09 <dramforever> And I typed 'x' to get the error message, ':sprint x' still has 'x = _'
03:14:17 <bollu> if some API allocates memory, can I unsafePerformIO it? because according to semantics, it is referentially transparent right?
03:16:15 <Cale> dramforever: Yeah, it's not supposed to error like that -- it's guessing incorrectly that it will be okay to apply Show, and show is too strict.
03:17:12 <Cale> bollu: perhaps this will be useful? https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Monadic.html
03:17:43 <dramforever> Cale: Strange thing, the trick only works for strings
03:18:32 <dramforever> the 'trick' only 'works'. by that I mean, 'let x = error "Uh" : [1, 2] :: [Int]' gives 'x = [_,1,2]'
03:18:55 <Cale> dramforever: not too strange -- for one if it didn't treat strings specially, it would have to always show them as explicit lists of Chars
03:19:37 <dramforever> Yeah, but GHC *should* show explicit lists of Chars if they contain thunks, shouldn't it?
03:19:46 <Cale> Yes, this is a bug.
03:20:14 <dramforever> Ok. Reporting it
03:21:25 <bollu> Cale: thanks :)
03:25:12 <dramforever> Cale: Thanks for the confirmation, so to speak. Not reporting it in case this is the bug: https://ghc.haskell.org/trac/ghc/ticket/8925
03:37:04 <ij> Can you make regexes that work like DFAs and will run forever?
03:38:14 <ij> The answer should be no. Then is there such a hs regex implementation? Application: matching arbitrary regexes.
03:38:45 * ij → lunch.
03:39:11 <Cale> ij: What do you mean by "run forever"?
03:39:37 <ij> Very long counts as well.
03:39:47 <Cale> I don't understand what we're counting here
03:41:08 <Cale> Do you mean it's supposed to handle infinite inputs in some way?
03:41:19 <ij> I've seen people write regexes for simple inputs that take very, very long.
03:41:35 <dramforever> Pathological regexes?
03:42:51 <Cale> Oh, you're talking about regex libraries which parse way more than just regular expressions, and so end up being asymptotically far less efficient in some cases than a regular expression compiled to a DFA would be.
03:43:02 <ij> Yeah, sorry for being imprecise.
03:43:15 <ij> I don't remember how the long-taking regexes worked.
03:43:28 <dramforever> Do you remember the expression?
03:43:42 <ij> No, someone else wrote it on IRC years ago and took down someone's bot.
03:43:55 <ij> He was a cool smart dude.
03:43:56 <ij> :D
03:45:36 <Cale> Usually something like matching a?a?...a?aaa...a with n occurrences of a? followed by n occurrences of a against a string of n occurrences of a
03:45:38 <Axman6> things like "((((a*)*)*)*" can take a long time to run
03:46:09 <dramforever> But if they *really* compiled it to DFAs/NFAs it wouldn't take that long really
03:46:11 <Cale> So that all the optional things have to fail (which involves an exponential amount of backtracking, if you're doing backtracking)
03:46:16 <Cale> yeah
03:46:21 <Cale> and some libraries do
03:46:39 <ij> Well grep can handle that.
03:47:10 <ij> grep -P
03:48:45 <Cale>  cale@petra  ~  grep -P "a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" 
03:48:45 <Cale> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
03:48:45 <Cale> grep: exceeded PCRE's backtracking limit
03:50:23 <Cale> It just gives up. :P
03:50:31 <Cale> (but at least it gives up quickly)
03:51:42 <dramforever> ij: I'm thinking, maybe you should just timeout and kill the thread in case that happens
03:52:17 <ij> That would be suboptimal, if we can just get a regex engine that never runs too long.
03:52:33 <dramforever> You give up backreferences
03:52:43 <ij> Would you consider giving grep arbitrary input in ["grep", "-P", "--", here] safe?
03:53:17 <ij> dramforever, so regex-dfa?
03:54:30 <Cale> regex-tdfa should be good
03:54:30 <dramforever> I would say 'yes', but I wanted to check befor saying so, but it's still installing
03:54:41 <Cale> Well, for some value of good
03:54:43 <dramforever> *before
03:55:19 <dramforever> Oh, regex-dfa no longer works with GHC 8.0.1 (regex-tdfa looks fine)
03:55:45 <Cale> It'll take O(n) time to match input of length n, and use memory bounded by the pattern size, not scaling with the input length.
03:56:31 <Cale> Roughly anyway
03:56:58 <Cale> If you're going to use regular expressions at all, you almost certainly should be using such a library
03:57:11 <dramforever> For the example Cale gave, regex tdfa says yes in about 0.1s
03:57:13 <dramforever> ij: ^
03:57:15 <Cale> Regular expressions are otherwise a really horrible way to write a parser
03:57:54 <dramforever> Cale: I think ij is handling arbitrary regexes coming from end users
03:58:29 <dramforever> presumably writing a 'bot' (search bot?)
03:58:47 <Cale> Yeah, so some end users depending on the application might be upset not to have backreferences and stuff
03:59:00 <Cale> But whatever :)
03:59:32 <bollu> okay, I don't understand unsafePerformIO
03:59:38 <bollu> can I unsafePerformIO a constructor?
03:59:45 <bollu> a constrctor through an FFI
04:00:02 <dramforever> In case it was not clear, dramforever votes for timing out the thread. But if that isn't an option I will vote for regex-tdfa
04:00:21 <bollu> can this be run through unsfePerformIO? https://github.com/bollu/symengine.hs/blob/master/src/Symengine/BasicSym.hs#L126
04:01:40 <dramforever> bollu: Looks bad. You risk creating two BasicSym's where you mean one
04:02:15 <dramforever> no, more serious: You risk creating one BasicSym for your whole program
04:03:28 <rohit_> Hi.Kindly help. I was following to install haskell using STack . http://lpaste.net/1813490545633263616 I'm getting this
04:03:40 <rohit_> it just stopped there. I'm not sure how to install else way
04:03:55 <dramforever> Wait for a while
04:05:08 <dramforever> bollu: When you have 'x :: BasicSym' created through unsafePerformIO, x could be evaluated 0 or more times, which means that basicsym_new could be called 0 or more times
04:05:23 <dramforever> which seems to be against what you wish
04:05:27 <orion> I am using the FFI to block on a serial console connected to an NFC reader. How do I prevent the blocking call from blocking the rest of my application?
04:06:55 <merijn> orion: Compile with -threaded (threaded runtime) and done :p
04:07:29 <merijn> orion: The default behaviour for all foreign calls is to run in a dedicated separate since it is assumed they may block for indefinite time
04:07:43 <merijn> That might even happen in the single-threaded runtime, but I'm not sure
04:08:21 <rohit_> anyone plz help
04:09:13 <orion> merijn: I already use -threaded, but it doesn't seem to help.
04:10:02 <orion> I have two async actions: 1. fetch data from Internet, 2. block on NFC reader. I am finding that #1 does *not* occur until I swipe a NFC tag.
04:10:51 <merijn> orion: Can you show some code? I don't know enough what you're doing to say
04:11:16 <merijn> Specifically the foreign import of your FFI call and where you're creating threads
04:11:32 <orion> merijn: https://github.com/centromere/nfc/blob/master/src/Bindings/NFC.chs
04:11:41 <merijn> oh...
04:11:49 <orion> Line 72
04:11:51 <merijn> Actually, I have a pretty obvious question :)
04:12:01 <merijn> orion: Are you actually running with multiple threads? :p
04:12:34 <merijn> orion: Line 72 is doing an unsafe import, that's not the default and certainly fucking up your code
04:12:57 <merijn> orion: Never do unsafe foreign imports, unless you know what you're doing. And actually, don't do them then either :p
04:16:16 <orion> It doesn't make sense to me to declare a foreign import such as fire_the_missiles() as pure.
04:20:23 <merijn> orion: unsafe is not declaring the function unsafe
04:20:37 <merijn> orion: unsafe specifies "call in an unsafe manner"
04:20:57 <merijn> orion: It has nothing to do with purity
04:21:25 <merijn> Purity is controlled by whether the foreign interface returns a value of type 'IO a' or not
04:21:39 <merijn> Which I can't tell from this code, because I'm not too familiar with c2hs
04:25:26 <orion> I see.
04:25:41 <merijn> orion: See especially this blog post: http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/
04:26:17 <merijn> Incidentally, I would also recommend reading chapter 8 (the FFI chapter) of the Haskell Report to everyone using the FFI
04:28:25 <hpc> rohit_: it just stops at the line where it's downloading stuff?
04:28:39 <rohit_> not sure hpc 
04:29:05 <rohit_> I was once said stack is the best way to go , now I feel sudo apt-get was more easier than this
04:29:49 <rohit_> It was just stuck there, hpc . I Wasn't sure what it was doing, was it downloading or just hungup, not sure. So thought to ping here and get some inputs 
04:30:05 <hpc> keep waiting for it to download
04:30:15 <orion> merijn: Thank you for that piece of advice. What I needed to do was remove the "unsafe" keyword rather than replace it with "pure".
04:30:21 <hpc> and use whatever monitoring utilities you have to see if it's doing any disk or network IO
04:30:31 <orion> merijn: As soon as I did that, everything started to magically work.
04:30:55 <rohit_> how to install haskell completely using stack, hpc ? Was that the same command stack ghci"/
04:30:58 <hpc> rohit_: stack and apt solve different sub-problems that relate to the same base problem
04:31:33 <rohit_> So how to install. Since Nothing actually shows what's happening in the background which makes it so complex
04:31:35 <hpc> apt solves your usual distro package management-y problems like "i should be able to install pandoc and have the OS manage it for me"
04:31:57 <hpc> which includes the problem of "i need a compiled version of pandoc"
04:32:08 <hpc> stack solves the problem of reproducible package builds
04:32:17 <hpc> which includes the problem of "i need a compiled version of pandoc"
04:32:27 <hpc> both have their shortcomings though
04:32:28 <rohit_> what does "wget -qO- https://get.haskellstack.org/ | sh" this comand do? I didn't give that. I got Ubuntu 14.04 version
04:32:47 <hpc> that downloads a shell script from the stack website and then runs it
04:32:56 <hpc> i don't recommend doing anything like that ever
04:33:10 <kadoban> rohit_: You can just download the script and read what it does first
04:33:12 <rohit_> plz help . I was going through this tutorial https://docs.haskellstack.org/en/stable/install_and_upgrade/#ubuntu
04:33:22 <sdx23> it's a shame this way of installing stack is propagated.
04:33:30 <rohit_> I was following ubuntu install using stack
04:33:37 <hpc> anyway, which one is best for you will depend on what you are using it for
04:33:44 <Axman6> don't you just apt-get install stack?
04:33:48 <hpc> using apt has the issue of things you want not always being packaged
04:34:25 <hpc> using stack has the issue of sometimes a package isn't configured for stack already and you have to do a bit of finagling
04:34:31 <rohit_> I once used apt-get earlier, and was using it, and later something happened I guess while trying new stuff, so someone in here told me to get haskell using stack
04:34:48 <hpc> but stack's sandbox-y reproducible nature means you can easily set one up yourself manually
04:35:10 <hpc> so really the question is what's your goal with this?
04:35:26 <rohit_> I'm going for web development using yesod. 
04:35:44 <hpc> you should probably keep using stack then
04:36:08 <rohit_> ok
04:36:32 <merijn> orion: Glad it works :) Although I would recommend still reading the things I mentioned to understand the how and why in more detail :)
04:36:34 <hpc> since you need something to handle building your website anyway, and stack's as good as anything else out there
04:36:45 <rohit_> ok
04:36:49 <rohit_> trying to download it again
04:37:26 <rohit_> after this command "sudo apt-get update && sudo apt-get install stack -y" what should I do. Does it install just stack or it comes with GHCI
04:38:32 <kadoban> rohit_: It installs just stack, but stack manages GHC (and ghci and etc) for you
04:38:38 <hpc> stack is going to manage everything for you
04:38:47 <rohit_> ok. So after than what should I do 
04:39:06 <rohit_> I just completed the process.But the doc doesn't state how to get ghci
04:39:08 <hpc> a project's stack configuration captures everything needed to compile it in the same way every time
04:39:11 <hpc> and stack makes it happen
04:39:22 <hpc> including using a specific version of ghc that it handles on its own
04:39:29 <opqdonut> rohit_: "stack ghci"
04:39:31 <hpc> it's very all-in-one
04:39:41 <rohit_> Thank you.
04:39:42 <opqdonut> rohit_: might need to run "stack setup" to install ghc first though
04:39:57 <opqdonut> rohit_: but stack will tell you if you need to do that, I think
04:40:21 <rohit_> so stack setup and than stack ghci, is it opqdonut ?
04:40:27 <hpc> stack's model should really be explained under https://docs.haskellstack.org/en/stable/README/#why-stack
04:40:54 <rohit_> thanks so much hpc opqdonut kadoban for sharing informations
04:44:14 <rohit_> So ,after stack setup, I need to give stack ghci to install it.. I hope that works.. thanks guys.. 
04:45:06 <kadoban> rohit_: You don't particularly need to remember 'stack setup' ever. If it needs to be run, it'll tell you.
04:45:13 <kadoban> Just FYI
04:45:19 <rohit_> ok
04:45:39 <hpc> strictly speaking, all you need to remember is 'stack help' ;)
04:52:01 <orion> merijn: Are you aware of any mechanisms to cancel a blocking FFI call wrapped in runResourceT, but doing so in such a way that the cleanup function actually gets run?
04:53:43 <hpc> have you tried turning it off and on again?
04:55:50 <hpc> orion: theoretically as long as cancelling that call lands you back in the ResourceT action you should be able to just release the relevant RelaseKey
04:56:43 <merijn> orion: GHC supports interruptible foreign calls now, but that way lie dragons :)
04:57:05 <merijn> orion: So, it should be possible to make such a mechanism, but it will be an...experience :)
04:58:04 <orion> merijn: Link?
04:58:36 <orion> hpc: Do you mean that I should install a signal handler which contains the ReleaseKey?
04:58:56 <hpc> dunno, that falls under "how do i cancel a blocking FFI call"
04:59:10 <hpc> but the part of it in the ResourceT api is pretty straightforward
04:59:20 <hpc> basically the problem decomposes
05:01:48 <merijn> orion: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/ffi.html
05:01:57 <merijn> orion: See the InterruptibleFFI part
05:02:02 <orion> Thanks.
05:42:51 <zipper> I can't use guards in a case expression, can I? after the  ->
05:43:15 <kadoban> zipper: You can. I think they go before the ->
05:43:44 <zipper> No I mean after the ->
05:43:52 <zipper> wait what do you mean before the ->?
05:43:58 <zipper> really? let me try
05:44:08 <lyxia> pattern | guard -> stuff
05:45:39 <zipper> WOW nice
05:45:43 <zipper> Thanks
06:03:46 <jchia1> is there a good source code automatic formatter besides hindent?
06:05:13 <merijn> Not one that makes everyone happy, afaik
06:06:58 <Profpatsch> What’s the best way to catch file IO exceptions and give the user feedback?
06:07:56 <Profpatsch> in my case I want to write a function withConfigFile :: (Handle -> IO r) -> IO r
06:08:18 <Profpatsch> (not sure about the return type)
06:08:51 <Tuplanolla> How about `bracket`, Profpatsch?
06:08:51 <Profpatsch> And I want to tell the user if his config could not be opened and also why.
06:09:42 <Profpatsch> Tuplanolla: I am going to use withFile, so the cleanup is already done by that.
06:09:58 <Profpatsch> But I’m not sure
06:10:29 <Profpatsch> 1) How to filter out three exceptions and pattern match on their type
06:10:42 <Profpatsch> 2) How I should best return that to the user.
06:11:26 <merijn> Profpatsch: Write a handler that catches those three and rethrows the rest?
06:11:53 <Profpatsch> merijn: I can’t imagine how that looks like.
06:12:00 <Profpatsch> The existentials get to me. :(
06:12:07 <t0by> I'm sorry, does anybody happen to know of something that approximates "Comonads for Dummies"?
06:13:33 <Profpatsch> merijn: Oh, hm, should I use catches for that?
06:14:54 <Profpatsch> I also don’t understand the difference between try and tryJust.
06:15:26 <Profpatsch> I thought I can select the caught exceptions with (e :: MyException)?
06:15:46 <merijn> Profpatsch: Yes
06:16:26 <merijn> Profpatsch: File exceptions tend to be IOException
06:17:02 <merijn> Profpatsch: System.IO.Error lets you check which it is https://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO-Error.html#v:isEOFError 
06:17:39 <Profpatsch> Ah, so I can only select the whole tree by default.
06:17:53 <Profpatsch> And then select the leaves with predicates.
06:17:58 <merijn> This should work: foo `catch` \(e :: IOException) -> if isDoesNotExistError e then {- whatever -} else {- whatever -}
06:18:10 <merijn> Profpatsch: IOException predates the fancier exceptions
06:18:30 <merijn> Profpatsch: In general you can create arbitrary nested hierarchies that you can match on, etc.
06:19:21 <Profpatsch> So I’d use a pattern guard for the predicates
06:20:56 <Profpatsch> merijn: And then there’s non-linked errors, like InappropiateType
06:21:09 <merijn> Profpatsch: Pattern guards would work, yes
06:21:11 <Profpatsch> It’t not obvious how to catch those.
06:21:25 <Profpatsch> So I can catch isAlreadyExistsError / AlreadyExists The operand refers to a directory that already exists. [EEXIST]
06:21:34 <Profpatsch> But apparently not InappropriateType The path refers to an existing non-directory object. [EEXIST]
06:21:54 <merijn> Profpatsch: Right, so you want to catch both IOException and InappropiateType ?
06:22:16 <Profpatsch> So InappropriateType is another exception tree?
06:22:33 <merijn> Profpatsch: I don't know where you got it from? :)
06:22:54 <Profpatsch> merijn: https://hackage.haskell.org/package/directory-1.3.0.0/docs/System-Directory.html#v:createDirectory
06:23:28 <Shockk> mniip: regarding what we had talked about yesterday
06:23:35 <Shockk> would something like the following work for what I was wanting?
06:23:41 <Shockk> https://hackage.haskell.org/package/constrained-dynamic-0.1.0.0/docs/Data-MultiConstrainedDynamic.html
06:24:01 <merijn> Profpatsch: I don't see it in in System.IO.Error, so I would assume so
06:25:09 <merijn> Profpatsch: In which case you have 3 options: 1) install two separate handlers using 'catch' (one for each type), 2) still write separate handlers, but install them in one go using 'catches' and 'Handler' 3) write a handler that catches SomeException and use fromException/toException to check whether it's a type you care about in the handler
06:27:52 <Tuplanolla> Is this a step up from checking `errno`?
06:30:14 <merijn> Well, errno isn't thread safe, so this already wins by default :p
06:32:27 <sras> Is it possible to use newrelic monitoring service with a haskell web app. I found a lib called helics, and have installed the agent-sdk. But I am not sure how to proceed..
06:33:27 <Tuplanolla> It's thread-local, merijn.
06:33:55 <merijn> Tuplanolla: I doubt that's a portable assumption
06:34:24 <Tuplanolla> I don't mind calling POSIX portable.
06:34:42 <merijn> Tuplanolla: It's not in SUSv2, which POSIX spec specifies that?
06:35:04 <Tuplanolla> I don't know. The first one?
06:35:31 <Tuplanolla> Could be some amendment too.
06:37:01 <merijn> Ah, POSIX.1c apparently ammends it's definition
06:41:07 <Cale> sras: Well, the documentation for the last few versions doesn't show up on Hackage, so I would start by looking through the source code of the package a bit and figuring out what things I need. I have no idea what New Relic is, but the type signatures in https://github.com/philopon/helics/blob/master/src/Network/Helics.hs don't take long to skim and get an idea for what's in the API
06:42:12 <ocramz> anyone familiar with `criterion` here? What does 'Error: none of the specified names matches a benchmark' mean? Code compiles fine, this is a runtime error
06:42:45 <ocramz> in particular when passing in an environment to `defaultMain`
06:42:48 <Cale> sras: It looks like you're meant to wrap your main in withHelics $ do ...
06:43:20 <Cale> sras: and then there's sampler, which you execute to record the cpu and memory usage with the service
06:43:32 <lyxia> ocramz: it means you told it to run a benchmark which doesn't exist
06:44:08 <Cale> sras: I don't know what the transaction stuff is about, but presumably that makes some kind of sense
06:45:33 <ocramz> lyxia: I have a single call to defaultMain, which containes a single `bench`
06:46:05 <ocramz> I just call the binary, without mentioning any specific benchmark
06:46:25 <ocramz> so I don't understand what it wants
06:49:20 <ocramz> lyxia: and this behaviour only appears when I add an `env` bracket within defaultMain. If I hardcode the parameters (not passing them from CLI), it works fine
07:12:18 <alipang> @djinn (Profunctor p, Functor f) => (a -> f b) -> p b r -> f (p a r)
07:12:19 <lambdabot> Error: Class not found: Profunctor
07:13:03 <alipang> @djinn (Functor f) => ((c -> a) -> (b -> d) -> p a b -> p c d) -> (a -> f b) -> p b r -> f (p a r)
07:13:03 <lambdabot> -- f cannot be realized.
07:13:32 <lpaste> ocramz pasted “CLI parameters to criterion” at http://lpaste.net/349722
07:13:58 <alipang> @djinn (Traversable f, Bitraversable p, Functor f) => ((c -> a) -> (b -> d) -> p a b -> p c d) -> (a -> f b) -> p b r -> f (p a r)
07:13:58 <lambdabot> Error: Class not found: Traversable
07:14:07 <ocramz> lyxia : ^ a small paste with the criterion bug
07:14:31 <ocramz> or, I'm sure it's not a bug but I don't understand why it complains
07:18:22 <ocramz> if anyone has experience with passing environment to `criterion` and can give me some feedback on my lpaste above, I'd be extremely grateful
07:21:30 <ij> Cale, Not even that timeouts for me, btw.
07:27:04 <Shockk> I just want to check something against whoever might be knowledgeable in this area of haskell
07:27:07 <Shockk> https://github.com/jh3141/constrained-dynamic/issues/1
07:27:30 <Shockk> does what I've said in this issue make sense? am I understanding how constraints work correctly, like, can you do what I do there with c a => HasClass c a True?
07:35:12 <lyxia> Shockk: the compiler will not be able to pick the right instance between HasClass c a True and HasClass c a False. Instance selection does not look at the instance context.
07:36:11 <Shockk> lyxia: hmm, I'm not sure I undersatnd
07:36:14 <Shockk> understand*
07:48:46 <lyxia> Shockk: Given a class C and a type T, you want to find an instance HasClass C T b. but now there are two: HasClass C T True (from instance ... => HasClass c t True) and HasClass C T False (from instance ... => HasClass c t False).
07:49:49 <lyxia> The compiler does not look on the left of "=>" to pick the instance. So it can't decide.
07:50:42 <lyxia> but if instead you declare an explicit one   "instance C T True"
07:50:46 <Shockk> ohh I see
07:50:59 <lyxia> then instance C T True is more specific than instance c t False
07:51:07 <Shockk> what if the False instance is declared as {-# OVERLAPPABLE #-} ?
07:51:33 <lyxia> though I find the functional dependency rather disturbing.
07:51:53 <Shockk> this seems to be what the False instance is declared as
07:51:57 <Shockk> instance {-# OVERLAPPABLE #-} False ~ b => HasClass c t b
07:52:33 <lyxia> OVERLAPPABLE is what allows you to pick instance C T True over instance c t False
07:52:42 <Shockk> ahh right
07:52:46 <lyxia> From https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overlapping-instances
07:52:55 <Shockk> I'm not sure I understand the False ~ b part though
07:52:58 <lyxia> "Eliminate any candidate IX for which both of the following hold:"
07:53:14 <Gurkenglas_> Syntax feature request: Make "x <- foo" a special case of "x <-- (>>=) foo", allowing lines like "i <-- forM [1..10]".
07:53:37 <lyxia> Shockk: I believe it's to work around the functional dependency.
07:53:42 <Shockk> ah okay
07:53:55 <merijn> Gurkenglas: I don't understand what you mean by that
07:54:19 <lyxia> Shockk: instance c t False and instance C T True would contradict each other
07:55:24 <Gurkenglas> merijn, desugar "x <-- bar" to "bar $ \x -> do"
07:55:50 <Gurkenglas> as "x <- foo" is currently desugared to "foo >>= \x -> do"
07:57:06 <merijn> I don't quite see the point of that? Why not just write that?
07:57:39 <ab9rf> i'm not really seeing the benefit
07:58:32 <Shockk> I think Gurkenglas's example would be something like
07:58:35 <Shockk> i <-- forM [1..10]
07:58:37 <Shockk> print i
07:59:24 <ab9rf> sugar to makep eople who miss foreach loops happier?
08:00:05 <lyxia> maybe that would allow to keep the same indentation for nested handlers/loops
08:00:06 <Gurkenglas> It's the same benefit of do notation itself: Replace the nesting of contexts by subsequent commands on one indentation level
08:00:32 <codedmart> I have a ByteString and I just want to see if it contains `<` and `>` and pull the contents between those out. I feel like using a parser is more overhead then I need. Should I just use a parser or is it not that hard to do it manually?
08:01:01 <ab9rf> codedmart: why not use a parser?
08:01:29 <lyxia> codedmart: what about dropWhile/takeWhile
08:01:33 <codedmart> Just to not add the extra dep. Is that a dumb reason?
08:01:46 <ab9rf> lyxia: yes, but make sure you handle all the edge cases correctly
08:01:50 <kadoban> codedmart: You can do dropWhile/takeWhile, but if it gets much more complicated, I'd do a parser.
08:02:14 <codedmart> OK I will see what I can come up with. Thanks!
08:02:17 <Gurkenglas> If you would keep nesting forMs, that's the usecase for ListT, but you can mix, say, any traversals to the rights of <--.
08:02:35 <ab9rf> i.e. if there's no < or no > you want to return Nothing
08:03:29 <codedmart> ab9rf: RIght
08:04:55 <ab9rf> you can either write a bespoke handcrafted solution with dropWhile, takeWhile, and lots of guards
08:05:35 <ab9rf> or you can write a parser that does the same thing but is expressively much more succinct
08:05:53 <kadoban> Ya ... a parser really does seem like just a better idea already.
08:06:10 <ab9rf> esxpecially since this parser is a one-liner in parsec
08:06:32 <Gurkenglas> You can blur the line by using span and break with StateT
08:07:40 <codedmart> ab9rf: I haven't use parsers either so might try both ways to see.
08:07:52 <codedmart> partially learning exercise as wlel.
08:07:54 <codedmart> well.
08:07:56 <ab9rf> codedmart: nothing wrong with doing that as a learning exercise
08:08:14 <ab9rf> from a standpoint of writing maintainable code, the parser is going to be a better solution long-term
08:08:47 <codedmart> fair enough
08:09:01 <ab9rf> although gah, a ByteString? not a Text?
08:09:12 <ab9rf> i suppose that means attoparsec is a better choice
08:09:45 <kadoban> Well, it could be not text, it's actual bytes. Though it doesn't really sound like it.
08:09:51 <Gurkenglas> :t evalState (state (break (=='<')) *> modify (drop 1) *> state (break (=='>')))
08:09:52 <lambdabot> [Char] -> [Char]
08:11:12 <codedmart> attoparsec doesn't have a `between`?
08:11:23 <codedmart> Or am I missing it.
08:11:55 <Gurkenglas> codedmart, if you're parsing HTML look at TagSoup
08:14:03 <codedmart> Gurkenglas: it isn't HTML. Basically I will have bytestrings of emails that could be "Test Person <test@person.com>" or just "test@person.com". I am using Text.Email.Validate to validate the emails. So I want to check if the ByteString contains `<` and `>`. If so grab the contents between out and validate with Text.Email.Validate otherwise just validate with
08:14:03 <codedmart> Text.Email.Validate.
08:15:28 <shapr> I've been doing the Advent of Code puzzles, and I ran across a case where I wanted an Enum typeclass that "wraps around"
08:15:53 <barrucadu> shapr: I want that every time I use Enum/Bounded, heh
08:16:12 <shapr> for example, I wanted to make an Enum instance for "data Orientation = North | South | East | West" where "turn Left North = West"
08:16:45 <Gurkenglas> I just used Ints and took (`mod` 4)
08:16:46 <shapr> I thought about using succ and pred, but Enum doesn't "wrap around" is there a way to make that work anyway?
08:17:09 <shapr> Gurkenglas: and I bet your solution was faster because you didn't use a typeclass :-)
08:17:17 <ab9rf> heh
08:17:21 <shapr> Gurkenglas: did you create a private #haskell leaderboard?
08:17:43 <shapr> Even so, I wanted to know if there's some sort of Enum instance where succ and pred wrap around? Ever heard of such a thing?
08:17:54 <Gurkenglas> Nah I only do the advent stuff every few days so I can stream it for more than a few minutes at a time
08:18:01 <ab9rf> you'd have to write as a typeclass
08:18:03 <barrucadu> :t \a -> let enumEq :: Enum a => a -> a -> Bool; enumEq = (==) `on` fromEnum in if a `enumEq` maxBound then minBound else succ a
08:18:04 <lambdabot> (Enum t, Bounded t) => t -> t
08:18:19 <barrucadu> For going the other way you compare against minBound and use pred
08:18:28 <shapr> barrucadu: hm, that makes sense
08:18:51 <shapr> barrucadu: yeah, that's simpler, thanks!
08:19:04 <kadoban> shapr: I don't particularly see anything in Enum that disallows wrapping around. Just don't give a Bounded instance?
08:19:10 <barrucadu> If you're willing to add the Eq constraint, you can just use ==, rather than that enumEq I defined
08:19:16 <Shockk> http://stackoverflow.com/questions/5684049/is-there-some-way-to-define-an-enum-in-haskell-that-wraps-around
08:19:17 <kadoban> I mean you'll have to make the instance yourself I guess, but w/e.
08:19:32 <shapr> Shockk: oh, I never thought about asking google :-/
08:20:34 <ertes> hmm…  my backlog is too short…  could someone search their logs/backlog who highlighted me?
08:21:03 <kadoban> "[16:01] <ezyang> ertes: Well, I'm happy to answer questions about it. It's not type classes because it's not type directed, and compiled all away (you never have dictionaries)"
08:21:07 <shapr> ertes: I use znc on my VPS, then I can search the logs!
08:21:20 <shapr> kadoban: that's also a good point, thanks!
08:21:24 <ertes> kadoban: thanks
08:22:03 <kadoban> Anytime. I can post the log if it's helpful, though I don't see other text immediately before that that's related (didn't look hard)
08:22:23 <ertes> shapr: yeah, i don't have one right now, and ERC is terrible at logging (it syncs after every write)…  i could set up ZNC locally though
08:22:43 <shapr> I do love ERC
08:22:54 <joeyh> I want to read a line from a Handle, but only read a maximum of N bytes (to avoid super-long-line memory DOS), and keep data after the line available for later reads from the Handle. I wonder what is the best way to do this?
08:23:18 <ertes> ezyang: [backpack] i think i understand the basic idea now…  i'll check it out once it becomes part of GHC
08:23:30 <ertes> ezyang: thanks!
08:23:40 <joeyh> so far the best I have is repeated hLookAhead and hGetChar, which ... doesn't perform as horribly as it might
08:23:54 <shapr> joeyh: I think richard braakman had a pile of "upTo n" and "atLeast n" helpers for playing with infinite streams, something like that?
08:24:17 <ezyang> ertes: Cool 
08:24:24 <ertes> joeyh: are you using stream processing?  (conduit, pipes, io-streams or even enumerator/iteratee)
08:25:00 <joeyh> I'm game for using anything, was looking around and failing to find anything better than character at a time reading
08:25:02 <ertes> (there are other, less popular ones)
08:25:50 <ertes> joeyh: the approaches differ between frameworks…  i think the easiest (coding-/effortwise) is pipes
08:26:53 <ertes> joeyh: it's not the easiest w.r.t. learning curve though; i would do it with pipes-group, which may require some work to wrap your head around
08:27:06 <joeyh> are you just envisioning awaiting 1 character at a time until newline, or is there a primitive that handles it more efficiently?
08:28:08 <ertes> joeyh: technically you read in blocks, and you maintain leftovers, but that's only an implementation detail…  the API looks like you're splitting a string into lines, and then take the required amount from each individual line…  and everything happens in constant memory
08:28:29 <joeyh> I suppose taking the lazy IO stream from the handle and using conduit/pipes to manage the stream processing is a valid way
08:28:42 <ertes> no, you don't do lazy I/O with those
08:30:25 <ertes> (fun OT fact: the command to disable a service permanently with s6 is `touch down`)
08:33:24 <shapr> ertes: what's s6?
08:33:58 <shapr> oh, I found it.
08:34:17 <ertes> shapr: i use it as my xsession
08:34:24 <shapr> neat
08:34:32 <ertes> for mpc, xscreensaver, urxvtd, etc.
08:34:54 <shapr> huh, is your setup on a blog post somewhere?
08:35:14 <ertes> not right now, but if you're interested, i'm happy to write one
08:35:42 <shapr> ertes: yeah, I'd like to read about it.
08:36:28 <ertes> shapr: in the meantime see `services`, `files/.xsession` and `bin/update-xorg-services.sh` in <https://github.com/esoeylemez/config>
08:37:34 <ertes> i might switch away from s6 at some point, because honestly the UX is quite terrible (no (useful) --help)
08:37:55 <ertes> but it's good enough
08:47:40 <sm> hmm, what caused this levelling-off of debian GHC installs ? https://qa.debian.org/popcon.php?package=ghc
08:47:51 <sm> HP & stack ?
08:48:03 <Welkin> people stopped using debian?
08:48:26 <Clint> possibly all the people in this channel shrieking about how you should never use the .debs
08:48:32 <Welkin> lol
08:48:39 <Welkin> use stack or nix :D
08:48:52 <Clint> no
08:53:01 <Jello_Raptor> So I've been skimming the Liuid Haskell thesis and I'm curious
08:53:10 <maerwald> +q
08:53:38 <Jello_Raptor> would it be possible to determine is tying the knot would diverge with a dependent type system?
08:53:56 <theDon> [/win 55
08:54:02 <theDon> (sorry)
08:54:19 <Jello_Raptor> i.e could we tell, for most 'foo' whether 'let (out,c) = foo inp c in out' would diverge? 
08:55:14 <Jello_Raptor> I mean making sure the causal graph is ayclic is something I do manually in knot tying 
08:55:48 <Jello_Raptor> but I'm not sure where I would even start encoding those semantics in a type system
08:56:20 <Tuplanolla> There are dependent type systems where that's possible, so "yes" at least holds in one direction.
08:57:04 <codedmart> Char8 ByteString and ByteStrings are different? I can't find how to go between the two.
08:57:22 <Tuplanolla> Search for "totality checking".
08:58:01 <kadoban> codedmart: ByteString.Char8 is pretty awful, you really shouldn't use it. It's a throwback to ASCII-only nonsense, when there's no reason to do that.
08:58:34 <maerwald> there is reason, but not generally, which means: if someone asks, he's probably using it wrong
08:58:45 <kadoban> codedmart: If what you have is encoded bytes, decode it into Text, then work with that.
08:58:46 <Welkin> or she
08:58:53 <Welkin> or they
08:58:57 <Jello_Raptor> even simpler cases like "rep e = e : rep e" which, because they're infinite need to be marked as "codata" rather than "Data" which just looks like another predicate in a dependent type system
09:00:27 <maerwald> kadoban: Text is not bytes
09:00:46 <maerwald> I'd ask for the actual use case first before recommending stuff
09:01:41 <kadoban> maerwald: I didn't say it was. You know that's tedious, right? You finding some reason to contradict even things I say that are fine?
09:02:45 <Jello_Raptor> Tuplanolla: but is this a case of totality checking? I thought that depended on detecting instances of bottom and ensuring those are dead code. Isn't the issue here detecting whether an instance of bottom exists at all? 
09:02:49 <maerwald> "ASCII-only nonsense, when there's no reason to do that" <- I could put it this way: I think it's a wrong statement, so yeah, I like to express my opinion on that
09:03:18 <kadoban> maerwald: Then I'd like to express my opinion that I find you tedious and if it continues I'll be putting you on ignore.
09:04:01 <maerwald> kadoban: can you stop with ad-hominem stuff? I'm not interested in that or what you do with your ignore list
09:04:01 <exio4> maerwald: but that's what pretty much what ByteString.Char8 is :P
09:04:06 <exio4> remove one what*
09:04:20 <maerwald> exio4: well, it's fine if you are in an ASCII-only domain (e.g. a certain protocol)
09:04:27 <maerwald> and e.g. Text is a terrible choice for filepaths
09:04:31 <Tuplanolla> What's the difference, Jello_Raptor? You just extend the checking from program-level to term-level.
09:08:32 <Jello_Raptor> Tuplanolla: I was under the impression that totality checking extended from being able to type values like "error" and "undefined" as bottom, and other instances like incomplete pattern matches were added on a case-by-case basis, so this type of cylicality would be another special case for detecting those cases in which a value becomes bottom
09:09:13 <maerwald> Jello_Raptor: there's a #liquidhaskell channel, but it doesn't have 1600+ users
09:10:03 <Jello_Raptor> maerwald: this isn't a liquid haskell question except insofar as that what prompted the idea. It's more about dependent types in general. 
09:10:25 <Tuplanolla> That might be the case for LH, but doesn't generalize, Jello_Raptor. I thought you were looking at another one when you said "a type system".
09:11:39 <Jello_Raptor> Tuplanolla: I'm curious whether there's any solutions rather than whether there's a LH solution in particular. Are there any others I should look at?
09:12:00 <Tuplanolla> Gallina perhaps?
09:13:31 <Tuplanolla> It tracks "decreasing" arguments to determine the termination of recursion.
09:14:28 <Jello_Raptor> Tuplanolla: that's true of LH as well, but does that solve the knot tying problem? since the recursion isn't explicit anymore.   
09:15:12 <Tuplanolla> Yes. The language is a bit more restricted to allow it.
09:16:21 <Jello_Raptor> hmm
09:19:09 <hodapp> : yeah, I've heard of some of the approaches in totality checking that 
09:19:30 <hodapp> ...make sure that at least one argument is being reduced in some fashion
09:19:39 <hodapp> or "destructured" or something
09:22:34 <codedmart> ab9rf: This actually works well for me, but I am sure it can be done better. https://gist.github.com/codedmart/9bf8e1a2aa9a8c00129e237a93713284
09:30:34 <Jello_Raptor> hodapp, Tuplanolla: the only way I can think to do it is to have some set of predicates for every `function :: in -> out` which says "tying the knot with `ol :: Lens' out a` and `il :: Lens' inp a` using `\ inp -> let out = function (set il (out .^ ol) inp) in out` requires these constraints on `inp` in order to converge)
09:31:39 <Jello_Raptor> along with type level lenses, algebras to compose them, and an algebra to compose the predicate/
09:33:37 <Shockk> I have a quick question; using unsafeCoerce, is it possible to coerce a value to a polymorphic one constrained by a particular typeclass? for example:  show (unsafeCoerce x :: Show a => a) or something similar to that?
09:33:51 <Shockk> what I'm asking for may not make sense, which I can accept
09:36:19 <kadoban> Shockk: Not 100% sure, but I don't think that makes sense, unless or defaults or something dictate which actual type it ends up. There I think you'd just get a complaint that it can't decide what instance of Show you want, or something?
09:37:44 <Shockk> hmm ah rightr
09:37:46 <Shockk> right*
09:41:43 <nshepperd1> Shockk: what do you want that for?
09:43:07 <Shockk> nshepperd1: I'm trying to figure out if it'd possible to implement something like what I had been talking about earlier + yesterday, where I can store the constraints that a type has, along with its Dynamic, and then look up an arbitrary one of those constraints to check if it has it or not
09:43:15 <mpickering> the actual question is how you expect unsafeCoerce to even be safe if it were possible
09:44:50 <geekosaur> I don't think unsafeCoerce can conjure dictionaries out of thin air
09:45:04 <Shockk> hmm okay
09:45:12 <Shockk> that makes sense
09:45:19 <geekosaur> in fact I'm pretty sure it can't; iirc it's what C++ calls reinterpret_cast
09:45:50 <geekosaur> so it would only work if you had manually constructed something that would be a valid dictionary + value to begin with
09:46:37 <Shockk> ahh
09:46:44 * geekosaur just woke up and still working on coffee; brain not fully online yet >.>
09:47:02 <Shockk> I feel sick so me neither
09:48:16 * geekosaur suspects some kind of type level tagging is what you'd need here, but is not so hot at type level even when fully awake
09:49:29 <Shockk> the funny thing is I have a way to do what I want to do but for some reason I want it to look more elegant by using typeclass instances, instead of attaching separate values of data types to something, but I'm spending far too long trying to figure it out
09:51:38 <geekosaur> the problem is that constraints don't exist as constraints, they exist as a single typeclass dictionary that contains functions. introspection for anything other than its intended purpose is unlikely to help you, since you can only use it if you already know the constraints
09:51:59 <Shockk> ohhh right
09:52:01 <Shockk> :(
09:52:03 <geekosaur> (in normal usage, the typechecker knows those constraints and therefore has no problem)
09:52:18 <nshepperd1> Well, nonexistence of typeclass instance is sort of non observable by design
09:53:00 <Shockk> hmm okay, I should stick to what I'm doing currently then, it sounds like it's really not possible
09:53:48 <nshepperd1> But you could have like a table mapping types to instances
09:55:02 <nshepperd1> A Map from TypeRep to some existential holding a Dict (TheClass a)
09:55:18 <Shockk> hmm
09:55:48 <nshepperd1> But you write have to manually add instances that you want to use to that collection
09:56:51 <Shockk> I sort of know what you're meaning because constrained-dynamic does this by manually adding every instance
09:57:30 <Shockk> its problem for me though is that ConstrainedDynamic is parameterized by the constraint type list
09:58:18 <Shockk> i.e. someDyn :: ConstrainedDynamic '[Enum, Show, Num, Position, Physics, Sprite, ..]
09:58:38 <Shockk> so I can't just store a bunch of those values in a single collection since they're different types
09:59:31 <glguy> Shockk: I wrote some code related to these kinds of types https://github.com/glguy/operations/blob/master/src/Example.hs
09:59:51 <glguy> with helpers for using subsets of the lists or rearranging the lsits
10:00:07 <Shockk> ah I see
10:01:25 <ph88> why is  shrink Nil = []  in https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Arbitrary.html#v:shrink  and not  shrink Nil = [Nil]  ?
10:01:49 <glguy> Because Nil isn't smaller than Nil, I'd expect
10:05:33 <ph88> what if i have a list of things actually, how do i shrink that ?  i have a type like   Foo String [Int]
10:07:24 <geekosaur> iirc if you can't figure out anything else to do you just return the original value? but presumably you would look at the value given and remove anything from the list that would likely be already considered / contextually "larger"
10:07:40 <dfeuer> Thanks, edwardk.
10:07:55 <ph88> i was thinking of shrinkList (\x -> [x]) lst   is that right ?
10:07:55 <edwardk> easy peasy. nice patches
10:08:30 <dfeuer> ph88, not everything shrinks *usefully*. That's okay. The whole shrink thing is a sometimes thing.
10:08:38 <dfeuer> :-)
10:08:54 <ph88> btw is there a short for  (\x -> [x])  ?
10:09:06 <edwardk> (:[]) or return or pure
10:09:06 <geekosaur> (:[])
10:10:21 <Clint> @pl \x -> [x]
10:10:22 <lambdabot> return
10:10:30 <dfeuer> edwardk, Ross Paterson and I were discussing the Alternative instance for Reverse. I initially thought the current one backwards, but now think there are *two* reasonable ones. Do you have an opinion?
10:10:49 <dfeuer> Ross doesn't much like the idea of having two different Reverse variants to get different Alternative instances.
10:11:04 * dfeuer waves to wrengr.
10:11:17 <wrengr> heya, how goes?
10:11:20 <ph88> this code compiles https://paste.fedoraproject.org/502510/13070331/ i'm just not quite sure if this is how i'm supposed to do it
10:11:20 <edwardk> i'm generally okay with the current instance. it make it so only one thing gets changed by picking up Reverse.
10:11:40 <edwardk> i've had a bunch of folks try to make the case that Reverse and Backwards should merge, etc.
10:11:53 <dfeuer> edwardk, the current instance is good for things like a fixed number of parallel threads.
10:11:56 <ph88> edwardk, i recently found about lens biplate, thanks
10:12:10 <dfeuer> Whereas the swapped version is good for reversing sequences.
10:12:12 <edwardk> ph88: glad to see someone finding it useful
10:12:30 <ph88> well i'm sure others think it's useful too !
10:12:40 <dfeuer> I tend to think of Reverse as turning queue with snoc and uncons into one with cons and unsnoc, for instance.
10:12:45 <edwardk> dfeuer: sure. one could construct a ReverseAlt that just reversed (<|>), etc.
10:13:12 <edwardk> and it would fit in with the backwards/reverse school, each one reversing one thing
10:13:43 <dfeuer> edwardk, oh, you mean newtype ReverseAlt f a = ReverseAlt (Reverse f a) ?
10:14:19 <edwardk> no i meant making a Whatever f a = Whatever (f a) which only reversed the <|>) definition
10:14:29 <dfeuer> Oh.....
10:14:38 <ph88> if a thing itself can not be shrink but one of the parts can be shrinked, do i still have to write a shrink function for it?  for example:  data Foo = Foo [Int]   data Bar = Bar String Foo     now Foo has it's shrink function, but i'm not sure if i should implement one for Bar
10:14:40 <edwardk> then Whatever (Reverse f) reverses both (<*>) and (<|>) etc.
10:14:48 <dfeuer> Why do some people want to merge Reverse with Backwards?
10:14:59 <edwardk> dfeuer: no well articulated reason
10:15:09 <nshepperd1> Isn't shrink supposed to return the empty list if there aren't any ways to shrink? Although shrinking x to [x] probably wouldn't do any harm, it would just waste some cpu randomly shrinking things to themselves
10:15:10 <edwardk> just a 'hey we're reversing stuff right, lets reverse all the stuff'
10:15:32 <edwardk> nshepperd1: if the shrink doesn't actually reduce the size how do you terminate?
10:15:46 <dfeuer> I see your point, edwardk. Although each layer adds to the Traversable cost :/
10:16:02 <edwardk> nshepperd1: this would require you to be able to check for equality, rather than just shrinking until the check passes
10:16:18 <ph88> nshepperd1, well (\x -> [x]) was the function to apply over members of the list. So i guess when i use shrinkList and the list has 3 items [1,2,3] it would try [1,2], [1,3] .. and so on]
10:16:35 <edwardk> dfeuer: clearly you should smack it with yoneda first to fuse the two back to back fmaps. ;)
10:16:46 <dfeuer> Ouch.
10:17:13 * edwardk hands dfeuer a bazooka to swat a fly
10:17:31 <dfeuer> Do you know if anyone's working on a better approach to type roles?
10:17:42 <dfeuer> Their limitations keep hitting me over the head.
10:17:48 <nshepperd1> edwardk: oh, i suppose i assumed that quickcheck would give up after some finite number of shrinks regardless of whether things are actually getting smaller
10:17:55 <edwardk> nobody is at last check
10:18:14 <nshepperd1> I suppose one shouldn't rely on that anyway
10:18:18 <edwardk> nshepperd1: the problem is how many should it stop after?
10:18:19 <dfeuer> We ideally want some sort of higher-order role annotation that can be more general than what would be inferred, but that can still be checked.
10:18:29 <edwardk> sure
10:18:37 <edwardk> the best i have is my silly little Representable class
10:18:43 <edwardk> but even that isn't good enough for StateT
10:19:02 <edwardk> https://github.com/ekmett/roles/blob/master/src/Data/Roles.hs
10:19:13 <edwardk> er Representational
10:19:22 <nshepperd1> ph88: it should do that if you give (const [])
10:19:27 * ski thinks the current roles systems feels messy/inadequate
10:19:40 <dfeuer> edwardk, I think you can combine Forall with Representational variants to do some more stuff, maybe?
10:19:56 <edwardk> mebbe.
10:20:15 * dfeuer agrees with ski, and also adds TypeFamilyDependencies to the shit list.
10:20:26 <edwardk> the problem with Representational for StateT s m a = s -> m (s, a)  -- is that s is representational if m is representational, but m comes later in the argument list
10:20:54 <edwardk> so you really need a way to make a full 'fun-dep' like set of dependencies for representations
10:21:12 <dfeuer> Fun times.
10:21:49 <edwardk> er s -> m (a, s) -- which actually makes it even a little more awkward, because now you need to know stuff about a
10:22:06 <edwardk> well, you don't, but good luck tricking the type system into that knowledge
10:22:12 <dfeuer> Yeah.
10:22:36 <dfeuer> Do "operational" monads coerce any more easily?
10:24:23 <edwardk> yes. it depends on the encoding of course. but in general operational works better than free for representational, as (Free f) is only representational if f is while Operational f = Free (Coyoneda f) doesn't care if f is
10:25:09 <edwardk> but that is really more about coyoneda than operational
10:25:16 <dfeuer> *nod*
10:25:17 <edwardk> operational just borrows the benefit
10:26:05 <dfeuer> Do you have beef with operational monads like you do with effect systems?
10:26:26 <codedmart> Anyone have some suggestions on making this code better? https://gist.github.com/codedmart/9bf8e1a2aa9a8c00129e237a93713284
10:27:03 <ph88> for shrinking Text should i first unpack it to [Char] and then use shrinkList and then pack it ?
10:27:49 <dfeuer> codedmart, yes. Start by adding Haddock documentation to every top-level binding. Then add explanatory comments to non-trivial helpers like getEmail.
10:28:28 <nshepperd1> For GND could you justify the coercion by writing an explicit implementation in terms of applied newtype wrappers?
10:28:36 <dfeuer> codedmart, as for the code proper,  either Left (\_ -> Right ue) q is better written  ue <$ q
10:28:56 <codedmart> dfeuer: Thanks, is the if else ok. Feels like there should be a better way.
10:29:04 <dfeuer> nshepperd1, I think the trouble is recursion that may not terminate.
10:30:54 <nshepperd1> dfeuer: i see... Can you give an example?
10:31:29 <codedmart> dfeuer: Not sure I follow `either Left (\_ -> Right ue) q is better written  ue <$ q`.
10:32:23 <codedmart> dfeuer: Ah I see
10:38:56 <ezyang> maerwald: Text is actually a surprisingly good choice for filepaths on Windows haha 
10:39:31 <Gurkenglas> codedmart, elemT c is any (==c)
10:40:17 <Gurkenglas> codedmart, getEmail will take all nonarrow symbols after the opening tag. I think you want to stop after the '>'
10:40:46 <glguy> For the text package the way to do elem is: elem x xs = singleton x `isInfixOf` xs
10:41:59 <Gurkenglas> (I mean T.any (==c), of course)
10:42:35 <glguy> When elem was removed from the text package, a RULE was added so that what I wrote above would be the efficient solution
10:42:53 <Gurkenglas> Why would Text.Email.Validate.validate take a Bytestring? Doesn't it have to choose an encoding then?
10:43:57 <Gurkenglas> glguy, a guard, you mean? "| isSingleton needle = S.elem (unsafeHead needle) . S.stream $ haystack"
10:44:45 <glguy> Gurkenglas: No, I don't mean that
10:45:23 <ph88> shrinkText txt = map T.pack $ shrinkList (:[]) $ T.unpack txt
10:45:23 <Gurkenglas> Oh wait there's the rule I thought rules are written above the relevant top-level definition.
10:47:28 <codedmart> OK the if else feels weird to me. Is that just me?
10:49:13 <codedmart> Gurkenglas: I don't care about stopping after the `>` because `Text.Email.Validate` takes care of it from there. So if someone gives me "Test Person <test@test.com> some other text" it will fail. 
10:51:06 <Gurkenglas> codedmart, 'validate . encodeUtf8 =<< if elemT '<' b && elemT '>' b then Right (getEmail b) else Left "Unsupplied <> tags"' better?
10:51:25 <haskellNoob> Hey, does anyone mind answering a question for me? It's about sepBy for parser combinators
10:52:04 <Gurkenglas> codedmart, in fact you could do "validate . encodeUtf8 =<< getEmail b" if you modify getEmail to return an Either. Perhaps you can even get rid of having elemT at all
10:52:17 <haskellNoob> if i'm using the instance of an applicative for sepBy, would this be a working definition? " sepBy :: Parser a -> Parser sep -> Parser [a]"
10:53:22 <Gurkenglas> attoparsec, yes?
10:54:42 <codedmart> Gurkenglas: How would I get rid of elemT? Was the attoparsec for me?
10:54:51 <Gurkenglas> codedmart, no, for haskellNoob
10:54:55 <codedmart> Ah
10:54:57 <haskellNoob> I think attoparsec was for me
10:55:13 <Gurkenglas> :t Data.Attoparsec.Text.sepBy
10:55:14 <lambdabot> Alternative f => f a -> f s -> f [a]
10:55:33 <haskellNoob> Okay that's cool
10:55:51 <Gurkenglas> :t Data.Attoparsec.Text.sepBy :: Data.Attoparsec.Text.Parser a -> Data.Attoparsec.Text.Parser sep -> Data.Attoparsec.Text.Parser [a]
10:55:53 <lambdabot> attoparsec-0.13.0.2:Data.Attoparsec.Text.Internal.Parser a -> attoparsec-0.13.0.2:Data.Attoparsec.Text.Internal.Parser sep -> attoparsec-0.13.0.2:Data.Attoparsec.Text.Internal.Parser [a]
10:56:04 <Gurkenglas> So looks like the answer to your question is yes, haskellNoob 
10:56:18 <haskellNoob> So, from what i understand (looked at realworldhaskell) it's essentially a delimiter?
10:56:26 <shapr> Is there a #haskell private leaderboard for Advent of Code?
10:56:41 <glguy> shapr: I'll join yours if you make one
10:56:47 <Gurkenglas> shapr, in terms of how soon after a problem was revealed you supply an answer?
10:57:08 <shapr> Gurkenglas: I just finished the first half of day 2 just now.
10:57:19 <shapr> I've been distracted, but I hope to complete more problems this weekend.
10:57:23 <Gurkenglas> How's the leaderboard ranked, then?
10:57:31 <shapr> How many stars completed, that's all
10:57:37 <codedmart> Gurkenglas: I am not sure I see how I could remove elemT?
10:58:05 <glguy> shapr: or I can make it if you want. I haven't seen such a leaderboard discussed in channel yet
10:58:14 <shapr> glguy: feel free to do it
10:58:14 <haskellNoob> (Nevermind i just realised i'm stupid and figured it out thanks!) Gurkenglas
10:58:27 <shapr> I'm at work, just did the first half of day 2 during my lunch break.
10:58:42 <glguy> shapr: Your private leaderboard has been created. Others can join it with the code 43100-84040706. 
10:58:55 <shapr> w00t!
10:59:04 <shapr> I wonder if there's room in the topic?
10:59:19 <codedmart> Gurkenglas: Really I just want to check if `<` and `>` exist in the string. If they do run getEmail else just return the original text.
10:59:29 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org | AoC: 43' by ChanServ
10:59:32 <glguy> nope
10:59:41 <Gurkenglas> codedmart, why return the original text, rather than failing?
10:59:44 <shapr>  what could we remove?
10:59:51 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | AoC: 43100-84040706' by ChanServ
10:59:54 <Gurkenglas> The http:// parts?
10:59:56 <codedmart> Because validate handle fail for me.
11:00:03 <shapr> glguy: thanks!
11:01:11 <codedmart> Gurkenglas: I only want to pass the text between `<` `>` to validate if the text contains `<``>`. Otherwise just pass text. validate from Text.Email.Validate handles the fail for me.
11:01:46 <Gurkenglas> codedmart, but you're passing validate an argument that you don't even expect to be an email, which I'm heuristically seeing as smelly.
11:02:17 <codedmart> Gurkenglas: OK fair enough
11:02:26 <shapr> glguy: are your AoC solutions on github?
11:02:35 <glguy> Yeah
11:02:44 <glguy> https://github.com/glguy/advent2016
11:03:01 <shapr> cool, I'll look at them when I'm finished with a particular day.
11:03:25 <shapr> Some Go lang coworkers were pointing to how much faster their code was than my Haskell solutions.
11:03:27 * shapr shrugs
11:04:02 <ph88> do you guys have that too when you abort in ghci that afterwards ghci gets really slow ?
11:04:23 <shapr> I've never noticed that
11:04:36 <shapr> ph88: except inside emacs if the buffer is really large, then it can get slow
11:05:34 <glguy> byorgey: Welcome :)
11:05:41 <byorgey> glguy: thanks =)
11:05:48 <codedmart> Gurkenglas: Not sure how to handle it then. Because these are both valid "Test Person <test@person.com>" and "test@person.com" so failing with "Unsupplied <> tags" doesn't seem right.
11:06:12 <Gurkenglas> Ohh I see
11:06:15 <ertes> shapr: it's probably just a matter of data structures and algorithms…  GHC itself should get close enough to gcc/clang performance (and sometimes even outperform them)
11:07:16 <codedmart> But either way the code still feels like it could be better even though it works.
11:08:34 <brandon> If I define types in Project.Types and define typeclasses and instances for those types in Project.Class, how do I ensure all modules have access to the typeclass instances? Assuming all modules will import Project.Types.
11:09:03 <Gurkenglas> Yeah, parsers would make this look better probably. (If that Text was a String, improvising with takeWhile would work better methinks)
11:09:27 <dfeuer> nshepperd1, sorry, I was away.
11:09:40 <ertes> brandon: define the instances at the type definition sites
11:09:52 <ertes> brandon: ideally .Class doesn't depend on .Types at all
11:10:11 <codedmart> Gurkenglas: Well I shall look at a parser then. I haven't used them yet. Just wanted to see if I could do it without one first.
11:10:21 <ertes> it defines the API, and the instances define the semantics
11:12:32 <ski> shapr : hm, perhaps that "Hackage status?" <https://status.haskell.org> should be added to the `hackage' item in `@where' ? or somewhere else ?
11:12:35 <codedmart> Gurkenglas: Thanks!
11:13:14 <glguy> The interesting status page appears to be http://auto-status.haskell.org/
11:13:56 <shapr> Gurkenglas: oh it looks like who gets a star first gets 100 points, second is 99, down to 1 point for being the 100th person to get that star
11:14:08 <ski> @where hackage
11:14:09 <lambdabot> <http://hackage.haskell.org/package/>, also see `revdeps'
11:14:16 <Gurkenglas> codedmart, it should end up looking something like this: "validateEmail = validate . encodeUtf8 . runParser (many anyChar *> char '<' *> many anyChar <* char '>' <|> many anyChar)"
11:14:48 <shapr> Gurkenglas: also turns out that glguy is ranked 100 on the global AoC leaderboard
11:14:53 <codedmart> Gurkenglas: That would work for "test@person.com" as well>
11:14:54 <codedmart> ?
11:15:06 <Gurkenglas> codedmart, yep that's the "<|> many anyChar" part
11:15:13 <nshepperd1> (Would it even be possible to automatically generate correct code for GND then validly optimise down to a coercion?)
11:15:14 <codedmart> Ah I see. Thanks!
11:15:17 <codedmart> Is that parsec?
11:15:29 <ski> @where+ hackage <http://hackage.haskell.org/package/>. Status of Hackage (and other things related to <haskell.org>) <https://status.haskell.org>,<http://auto-status.haskell.org/>. Also see `revdeps'
11:15:29 <lambdabot> I will never forget.
11:15:39 <ski> glguy,shapr : is that good ?
11:16:02 <byorgey> codedmart: that will work for pretty much any parser framework as long as it has instances of Applicative and Alternative.
11:16:17 <byorgey> codedmart: in that code 'char' and 'anyChar' are the only parts that might be specific to a particular parser framework
11:16:33 <glguy> ski: Maybe? I was doing better last year, there are around 10k people playing
11:16:57 <glguy> OH, sorry.
11:17:02 <glguy> yes, your where seems good
11:17:09 <ski> @where revdeps
11:17:09 <lambdabot> http://packdeps.haskellers.com/reverse
11:17:16 <ski> @where+ revdeps <http://packdeps.haskellers.com/reverse>,<http://packdeps.haskellers.com/>,<http://www.yesodweb.com/blog/2011/02/reverse-packdeps>
11:17:16 <lambdabot> I will remember.
11:17:24 <ski> the latter also seemed relevant
11:18:06 * ski idly wonders whether it would be better to have a separate `status' item
11:18:10 <shapr> glguy: ha, I think that's good :-)
11:18:41 <shapr> glguy: what's your average time to completion after a daily puzzle is announced?
11:19:05 <ski> @where status
11:19:05 <lambdabot> I know nothing about status.
11:19:30 <ski> @where+ status <https://status.haskell.org>,<http://auto-status.haskell.org/>
11:19:30 <lambdabot> Done.
11:19:56 <ski> @where+ hackage <http://hackage.haskell.org/package/>, also see `revdeps',`status'
11:19:56 <lambdabot> Nice!
11:21:19 <ski> (feels a bit cleaner, since it's not only the status of Hackage on those pages)
11:21:30 <glguy> shapr: somewhere between 2:30 in the best case and 15 minutes in the worst
11:21:57 <shapr> glguy: wow
11:21:59 <glguy> best case http://adventofcode.com/2015/leaderboard/day/10
11:22:00 <isovector> does anyone have experience with the `constraints` package? in particular the `Deferred` pieces? :)
11:22:50 <isovector> i'm trying to get a `Maybe Dict` depending on whether or not the constraint can be satisfied
11:23:08 <Welkin> Dict? You mean Map?
11:27:54 <isovector> Welkin: no, like the "pass constraints around at the value level" thing. http://hackage.haskell.org/package/constraints-0.8/docs/Data-Constraint.html#t:Dict
11:31:18 <shapr> glguy: I want to know how to solve problems quickly, got any tips? Perhaps you have a blog post you've written about that?
11:34:32 <codedmart> Gurkenglas or byorgey I understand what the error is saying, but am not sure why -> https://gist.github.com/codedmart/771ac8bd695dac269a54ec8ba16b3195
11:44:31 <geekosaur> because many is a generic combin ator returning a list. only with String does that exactly correspond to a string; you need to pack it for Text
11:45:16 <geekosaur> (if many were specialized so that it worked automatically with Text, you then couldn't use it to parse a collection of numbers and produce them as e.g. Parser [Int])
11:45:39 <codedmart> geekosaur: pack which part? many?
11:45:47 <geekosaur> the result of it, yes
11:45:58 <geekosaur> so, fmap T.pack over it
11:46:34 <codedmart> ok thanks! I get it now.
11:46:46 <codedmart> Maybe :)
11:47:19 <nmdanny> can lambdabot @pl refactor two lines?
11:47:42 <geekosaur> one expression
11:48:10 <geekosaur> if it's a do, you can compose it with @undo or you can manually translate it
11:48:36 <geekosaur> @. pl undo do { x <- y; return (frob x) }
11:48:36 <lambdabot> frob `fmap` y
11:48:58 <geekosaur> (and it still doesn't grok Applicative >.> )
11:49:19 <nmdanny> @. pl undo do { accsToken <- liftIO $ fetchAccessToken mgr oauth authCode;     accsToken' <- eitherToError $ mapLeft (\bs -> err401 { errBody = bs }) accsToken; return accsToken' }
11:49:20 <lambdabot> (line 1, column 104):
11:49:20 <lambdabot> unexpected "{"
11:49:20 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
11:50:05 <geekosaur> mm, right, it can't pointfree record update syntax
11:50:11 <ertes> isovector: you can't branch on whether an instance exists or not, neither statically nor dynamically
11:50:16 <geekosaur> because record update syntax is not first class
11:50:33 <nmdanny> hmm
11:50:41 <ertes> isovector: and if you find a way to do it, don't do it anyway ;)
11:50:53 <nmdanny> @. pl undo do { accsToken <- liftIO $ fetchAccessToken mgr oauth authCode;     accsToken' <- eitherToError $ mapLeft (mapF) accsToken; return accsToken' }
11:50:53 <lambdabot> liftIO (eitherToError . mapLeft mapF =<< fetchAccessToken mgr oauth authCode)
11:56:59 <codedmart> What am I missing here https://gist.github.com/codedmart/11651f67a4951f959e6bc7ae9f7ed365
11:57:47 <mekeor> codedmart: i don't know but i'd guess it's about operator precedence
11:58:05 <kadoban> codedmart: The first part eats everything, "many AnyChar", then there's no < left, so that never does anytihng.
11:58:32 <mekeor> oops, i was thinking you're getting a compiler error, sorry =D
11:59:30 <kadoban> codedmart: I believe you need something like   many (satisfy (\x -> not (x == '<')))   or many (noneOf "<") or something like that
11:59:49 <kadoban> codedmart: You'll need something similar for inside the <> too, can't eat the >
12:02:09 <mekeor> Q: i want to define a data type but i'm not sure which style is best. in particular, i'm not sure whether to use pre-defined data types like Maybe, Either and tuples to define a data type or if it's better to use haskell syntax... see -> http://sprunge.us/EHHa –  what do you think?
12:02:25 <Gurkenglas> Oh right, sorry codedmart. manyTill probably also applies?
12:03:51 <Gurkenglas> mekeor, do you consume Limbs valus in more than one place?
12:03:57 <Gurkenglas> *values
12:04:27 <mekeor> Gurkenglas: yes
12:04:45 <mekeor> ("consume" meaning "use", right?)
12:05:02 <Gurkenglas> As opposed to making them, yes
12:06:42 <mekeor> yeah, Limbs are constructed at three places in my library while it's they are constructed many many times
12:07:02 <Gurkenglas> Are you sure there should be one style as opposed to two in the BothLimbs case?
12:07:04 <mekeor> whut. correction:
12:07:59 <mekeor> Limbs are produced/constructed at three places in my library while it's they are consumed/deconstructed/pattern_matched many many times
12:08:12 <mekeor> Gurkenglas: yes
12:09:21 <christiansen> when building hinotify-0.3.8.1, I get this message:
12:09:24 <christiansen>  /usr/bin/ld: final link failed: Nonrepresentable section on output
12:09:35 <Gurkenglas> If the limbs are qualitatively different, I'd by default point to the second one, but might change my mind to some other third option upon seeing the code
12:10:05 <christiansen> this is on Debian, with LTS Haskell 7.10, building with Stack
12:10:10 <christiansen> anyone know how to diagnose this?
12:11:16 <dazednconfused> How can I get a list of all the typeclasses and the functions they declare?
12:11:43 <c_wraith> what does "all" mean? 
12:11:52 <c_wraith> exported from a module? 
12:12:01 <dazednconfused> Sorry. Just in the prelude
12:12:30 <dazednconfused> Like Eq, Show, Read, Num etc. These are all defined in the prelude, yes?
12:12:32 <ertes> dazednconfused: :bro(wse)
12:12:40 <ertes> (in GHCi)
12:12:43 <c_wraith> well, they're exported from the Prelude. 
12:12:58 <dazednconfused> Thanks ertes
12:13:00 <c_wraith> most fittings in the Prelude are actually defined elsewhere. 
12:13:06 <c_wraith> err, most things 
12:13:15 <ertes> dazednconfused: Prelude mostly reexports stuff that is defined elsewhere…  to see where something is defined use :i(nfo)
12:13:28 <dazednconfused> c_wraith: Sorry, I wasn't aware. I'm more or less a newb
12:13:41 <ertes> dazednconfused: to see where an instance is defined use :i on the type
12:14:04 <ertes> like: :i Maybe
12:14:27 <ertes> it shows you definition site, instances and some other infos…  use :i on type classes to see all instances in scope
12:14:42 <dazednconfused> Actually I want to define an algebraic data type called Direction = North | East | South | West. I know I must derive (Enum, Ord, Eq, Bounded) so that I can do something like succ North to get East
12:16:48 <tdammers> humm, why is succ North == East and not West?
12:16:50 <dazednconfused> Is there a way to define it such that when I do succ West (which is the maxBound), I get North (which is the minBound)
12:16:56 <tdammers> bit of an arbitrary choice innit
12:17:12 <ertes> tdammers: order of constructor definition
12:17:13 <dazednconfused> tdammers: Cos I'm turning clockwise
12:17:23 <tdammers> dazednconfused: then make dedicated functions for that
12:17:27 * christiansen has fixed his own problem, it seems that a C compiler flag needs to be -no-pie instead of -fno-PIE
12:17:33 <christiansen> in the GHC settings
12:17:36 <tdammers> dazednconfused: clockwise :: Direction -> Direction
12:17:48 <ertes> dazednconfused: you could write your own Enum instance, but better write separate functions
12:18:05 <ertes> dazednconfused: your type would be inconsistent with other types, if you'd do that
12:18:07 <joe9> http://codepad.org/T8TC4dVU any suggestions on what I am missing, please? I want stack to use 8.0.1 ghc.
12:18:10 <tdammers> ertes: yes, but the constructor definition order is still arbitrary
12:18:13 <joe9>  I cannot figure out why it (stack setup 8.0.1) does not install it.
12:18:26 <tdammers> North | West | South | East would be just as sensible
12:18:26 <ertes> > length ([0..] :: [Word8])
12:18:29 <lambdabot>  256
12:18:57 <ertes> dazednconfused: ^ with the derived Enum instance you would get 4 for your type, but if succ West = North, you would get an infinite list there
12:19:13 <dazednconfused> tdammers: I just felt going clockwise was better, that's all
12:19:16 <Gurkenglas> dazednconfused, there was also another discussion about that earlier in the channel, you can search the log of this day
12:19:30 <dazednconfused> ok I'll just write a function :)
12:19:41 <tdammers> dazednconfused: sure, it's a perfectly valid choice; I just think it's nice for succ / pred to align with Ord
12:20:17 <ertes> dazednconfused: hint: derive Bounded as well
12:20:34 <dazednconfused> ertes: yep I have derived bounded too
12:20:47 <ertes> @let data Direction = North | East | South | West  deriving (Bounded, Enum, Eq, Ord, Show)
12:20:50 <lambdabot>  Defined.
12:21:01 <ertes> > [minBound..maxBound] :: [Direction]
12:21:02 <dazednconfused> tdammers: "I just think it's nice for succ / pred to align with Ord". I'm sorry I didn't understand that bit
12:21:04 <lambdabot>  [North,East,South,West]
12:21:26 <tdammers> dazednconfused: you want succ a > a == True
12:21:41 <ertes> dazednconfused: Ord defines a total order on your type, and the derived Enum instance satisfies for all x: succ x > x
12:22:16 <ertes> > [ succ x > x | x <- [North..West] ]
12:22:19 <lambdabot>  error:
12:22:19 <lambdabot>      Not in scope: ‘North..’
12:22:19 <lambdabot>      No module named ‘North’ is imported.error:
12:22:24 <ertes> > [ succ x > x | x <- [North .. West] ]
12:22:26 <lambdabot>  [True,True,True,*Exception: succ{Direction}: tried to take `succ' of last ta...
12:22:33 <ertes> well, almost for all x =)
12:22:43 <tdammers> hehe
12:24:26 <dazednconfused> Thanks guys :)
12:26:50 <MarcelineVQ> joe9: are you sure you don't have 8.0.1 already and that your global resolver is set to use 7.10.3?
12:27:34 <MarcelineVQ> when you run stack outside of a project directory it uses the lts version from .stack/global-project/stack.yaml
12:27:58 <ertes> @let pairs = snd . foldr (\x0 ~(xs, ys) -> foldr (\x1 _ -> (x0:xs, (x0, x1) : ys)) ([x0], ys) xs) mempty
12:28:00 <lambdabot>  Defined.
12:28:09 <byorgey> glguy: up to day 3 now. =)
12:28:32 <ertes> > [ x < y | (x, y) <- pairs [North .. West] ]
12:28:36 <lambdabot>  [True,True,True]
12:28:39 <ertes> there we go =)
12:29:13 <MarcelineVQ> joe9: if the resolver in your global stack.yaml isn't lts-7something then stack exec ghc --version won't say 8.0.1
12:29:33 <ertes> > [ x < y | x : y : _ <- tails [North .. West] ]  -- that works, too, i guess
12:29:35 <lambdabot>  [True,True,True]
12:30:27 <ski> (oh, not "cyclic" pairs)
12:31:42 <ertes> ski: hmm?
12:33:29 <ski> i was first thinking `pairs [a,b,c] = [(a,b),(b,c),(c,a)]'
12:34:43 <ertes> ah
12:44:07 <ertes> @let cyclicPairs xs0 = foldr (\x xs -> maybe (xs (Just (x, x))) (\(x', x0) -> (x', x) : xs (Just (x, x0)))) (maybe [] pure) xs0 Nothing
12:44:09 <lambdabot>  Defined.
12:44:13 <ertes> > cyclicPairs "abc"
12:44:15 <lambdabot>  [('a','b'),('b','c'),('c','a')]
12:44:19 <ertes> ski: like that? =)
12:46:23 <nitrix> I think you can do it without using Maybe.
12:47:12 <ski> yes (and yes)
12:48:55 <ertes> nitrix: you mean without a failure case?
12:49:34 <nitrix> @let pairs = [a,b,c]
12:49:36 <lambdabot>  .L.hs:187:1: error:
12:49:36 <lambdabot>      Multiple declarations of ‘pairs’
12:49:36 <lambdabot>      Declared at: .L.hs:181:1
12:49:49 <nitrix> @let thePairs = [a,b,c]
12:49:52 <lambdabot>  Defined.
12:50:11 <nitrix> > zipWith (,) thePairs (drop 1 thePairs ++ head thePairs)
12:50:13 <lambdabot>  error:
12:50:13 <lambdabot>      • Couldn't match expected type ‘[Expr]’ with actual type ‘Expr’
12:50:13 <lambdabot>      • In the second argument of ‘(++)’, namely ‘head thePairs’
12:50:26 <nitrix> You can come up with nice arrangements of list comprehensions or zipWith or whatever.
12:50:33 <ertes> nitrix:
12:50:37 <nitrix> > zipWith (,) [] []
12:50:39 <lambdabot>  []
12:50:40 <ertes> > cyclicPairs []
12:50:43 <lambdabot>  []
12:50:52 <nitrix> The empty case is covered just fine.
12:51:09 <ertes> ah, i see…  but the point was to write it in terms of foldr
12:51:33 <ertes> you need Maybe or some other failure wrapper for that
12:52:04 <nitrix> This is how we end up with zygohistomorphic prepremorphisms lol.
12:52:11 <nitrix> Recursion strategies that preserves history -.-
12:52:33 <ertes> i can't memorise those names…  was it paramorphisms?
12:53:37 <nitrix> Histo apparently gives you access to previous results.
12:54:34 <ertes> well, you need all those crazomorphisms, if you disallow calling a pattern like (\xs -> foldr f z xs s) to be named "in terms of foldr"
12:54:42 <cocreature> zygomorphism all the things
12:55:03 <ertes> if you allow extra arguments and perhaps post-processing, then foldr can do pretty much anything that consumes a list
12:56:27 <cocreature> at one point I knew a lot of these names. then I forgot about them and just used foldr
12:56:39 <nitrix> ertes: I think it's doable without Maybe, if, you can provide the folding function some kind of additional stateful information, which cannot be done solely with the accumulator because that'd affect it.
12:57:05 <nitrix> ertes: I think you could have something like  foldr (magical xs) [] xs
12:57:25 <nitrix> Or.. no, you need to tie the knot o.<
12:59:05 <ertes> nitrix: if you construct a *function* as the result of a fold, then the third argument to the folding function is forward state, and the recursive result is reverse state…  to keep track of the first element you need forward state
12:59:37 <ertes> and you need failure, because the empty case only receives the information "empty" along with the forward state
12:59:58 <ertes> so it needs to branch on the state to figure out whether there was a head or not
13:03:32 <nitrix> @let crazy xs = reverse (xs ++ xs) !! (length xs * 2 - 1)
13:03:35 <lambdabot>  Defined.
13:03:48 <nitrix> err
13:15:08 <nitrix> Ahah, you'll hate me.
13:15:55 <nitrix> > foldr (\x acc -> (x, (reverse (thePairs ++ thePairs) !! (length acc + length thePairs - 1))) : acc) [] thePairs
13:15:58 <lambdabot>  [(a,b),(b,c),(c,a)]
13:16:29 <nitrix> > foldr (\x acc -> (x, (reverse ([] ++ []) !! (length acc + length [] - 1))) : acc) [] []
13:16:32 <lambdabot>  []
13:16:46 <nitrix> At least I proved it's doable :P
13:17:51 <nitrix> All that !! and length hackery can become part of that trapped variable and memoized. There are ways :P
13:22:22 <nitrix> > foldr (magic [1,2,3]) [] [1,2,3] -- ertes 
13:22:25 <lambdabot>  [(1,2),(2,3),(3,1)]
13:22:36 <nitrix> ertes: It's probably a little weird for the folding function to take the foldable as an argument :P
13:24:43 <mmaruseacph2> any sufficiently advanced function is undistinguishable from magic
13:25:48 <ertes> nitrix:
13:25:52 <ertes> > cyclicPairs [0..]
13:25:56 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12...
13:26:16 <nitrix> ertes: Boom :)
13:27:15 <mmaruseacph2> cyclicPairs l = zip l (tail l) -- still a valid definition based on output given so far, but definetely not cycling
13:28:20 <ertes> mmaruseacph2: the reason i don't like that one is that you're relying on the strictness of zip
13:28:42 <ertes> > (\xs -> map swap (zip (tail xs) xs)) ""
13:28:48 <lambdabot>  *Exception: Prelude.tail: empty list
13:29:01 <nitrix> Yeah, that was my little exploit earlier.
13:29:05 <nmdanny> is there a way for a servant/warp endpoint to determine which IP and port its being ran on?
13:30:15 <nmdanny> nvm
13:31:34 <haskell296> a
13:31:53 <mmaruseacph2> > map swap . cyclicPairs $ ""
13:32:00 <lambdabot>  []
13:32:05 <mmaruseacph2> you win, ertes 
13:32:50 <ertes> mmaruseacph2: no, your function is correct, but only because 'zip' happens to pattern-match on its first argument first =)
13:33:08 <ertes> > (\xs -> zip xs (tail xs)) ""  -- that one works
13:33:10 <lambdabot>  []
13:34:27 <ertes> in other words: you can only use 'tail' in the second argument…  it's just a little fragile to rely on that, i think…  but maybe it's just me
13:34:43 <mmaruseacph2> it's cool :)
13:36:01 <dazednconfused> newb question. What is ".." in let's say [1..5]? Is it a function? Is it a constructor?
13:36:14 <nitrix> dazednconfused: Syntax for a range.
13:36:21 <ertes> dazednconfused: [x..y] = enumFromTo x y
13:37:15 <dazednconfused> thanks. is there a way to check how a function is defined in ghci?
13:37:38 <glguy> No, but you can ask *where* it is defined using :info
13:37:41 <nitrix> :info can tell you where its location and from there you can look at the implementation.
13:38:15 <dazednconfused> so how do i see enumFrom's implementation? hoogle?
13:38:34 <nitrix> enumFrom will depend on the type being enumerated, afaik.
13:39:05 <glguy> If anyone's doing adventofcode.com and is interested, I've created a "private leaderboard" and added it to the topic of #haskell http://adventofcode.com/2016/leaderboard/private/view/43100 43100-84040706
13:39:19 <glguy> Might be useful to help find other people playing with the problems each day
13:39:43 <ertes> nitrix: you use :i to see where the Enum instance for the type is defined
13:39:54 <nitrix> dazednconfused: It's from the Enum type class, so each type that wants to be enumerated has to provide an instance implementation.
13:39:59 <ertes> whoops
13:40:02 <ertes> dazednconfused: you use :i to see where the Enum instance for the type is defined
13:40:19 <dazednconfused> :info fromEnum
13:40:23 <nitrix> :i Enum (the type class)
13:40:36 <ertes> or `:i Int` (the type)
13:41:44 <dazednconfused> ok so Enum Int is defined in GHC.Enum. How do i check the implementation of the Enum Int instance? I want to see how fromEnum is implemented for Ints
13:42:32 <mmaruseacph2> glguy: thanks, I'll join it when I get home and can work on more of the problems
13:42:39 <dazednconfused> I meant enumFrom
13:42:47 <ertes> dazednconfused: you get the source code of the base library and read the GHC.Enum module
13:42:48 <mmaruseacph2> so far I only finshed 2 or 3 of them one night
13:43:15 <ski> ertes : presumably (?) nitrix meant without constantly interpreting the `Maybe', despite it only transitioning from `Nothing' to `Just', and not the other way around
13:43:21 <mmaruseacph2> fromEnum for Int is most likely id?
13:43:45 <mmaruseacph2> at least from an observational point of view, it should act the same
13:45:58 <nitrix> dazednconfused: Unfortunately, once you reach the GHC.* modules, not everything will be there.
13:48:09 <nitrix> GHC.Enum doesn't seem to define the instance. Presumably GHC.Types would have it along the definition for `Int`, but then one might ask if Int is a wrapper around Int#, then where is Int defined, and so you find GHC.Prim and then it's even more blurry what is a compiler primitive and what isn't.
13:48:27 <nitrix> s/Int/Int#/
13:49:28 <nitrix> dazednconfused: I try to leave the GHC modules alone :P
13:51:37 <nitrix> dazednconfused: Found it. http://lpaste.net/349726  in GHC.Enum.
13:52:56 <nitrix> "-- Blarg: technically I guess enumFrom isn't strict!"
13:52:57 <nitrix> cute :P
13:53:13 <dazednconfused> nitrix, thanks 
13:58:24 <mekeor> assume `data Foo = One Bool | Two Bool`. it'd be awesome, if Haskell / GHC supported pattern matching like `f (_ b) = not b :: Foo -> Bool` :D
14:01:42 <dario`> that seems like a very specific case, how often do stumble upon that situation?
14:01:47 <nitrix> Prisms would probably let you do this.
14:01:53 <mmaruseacph2> pattern synonim it if you have multiple functions with that situation
14:01:56 <mmaruseacph2> or prisms
14:02:01 <mekeor> nitrix: what's that?
14:02:27 <mekeor> oh, it's a ghc language extension right
14:02:53 <mekeor> http://prismsscapeghc.com/ lol
14:03:07 <dolio> Or `data Foo = One { bool :: Bool } | Two { bool :: Bool }`
14:03:39 <mekeor> dolio: oh cool. which language extension is that?
14:03:46 <dolio> It's not an extension.
14:03:50 <nitrix> > matching _Just (Just 12)
14:03:53 <lambdabot>  Right 12
14:03:58 <nitrix> > matching _Just Nothing
14:04:00 <lambdabot>  Left Nothing
14:04:07 <mekeor> dolio: wow, really? and it works? wow coool
14:04:30 <nitrix> dolio's solution you gotta be careful with :x
14:04:57 <mekeor> why so?
14:05:00 <dolio> It's been in Haskell since 1.3.
14:05:17 <nitrix> @let data Bomb = Dangerous | Safe { defuse :: Bool }
14:05:20 <lambdabot>  Defined.
14:05:38 <nitrix> > defuse (Safe True)
14:05:40 <lambdabot>  True
14:05:42 <mekeor> oh, i see. so defuse is unsafe
14:05:46 <nitrix> > defuse Dangerous
14:05:48 <mekeor> i mean, incomplete
14:05:49 <lambdabot>  *Exception: No match in record selector defuse
14:05:51 <glguy> No, it's safe, it's also partial
14:05:55 <nitrix> It's partial.
14:07:01 <mekeor> but if all constructors are structured the same way, that's a nice hack
14:11:42 <athan>  /msg nickserv identify Thisisntmyfreenodeaccount
14:11:49 <athan> ffs
14:12:00 <glguy> It was probably worth changing that anyway
14:12:41 <mekeor> lol
14:12:50 <geekosaur> *snrk*
14:12:55 <mmaruseacph2> (hunter2'ing): I only see ******************* instead of the password
14:13:13 <glguy> Hopefully your password generation scheme isn't Thisisntmy_____account
14:13:15 <athan> that was a test actually
14:13:22 <athan> :|
14:13:34 <athan> glguy: is that bad? :v
14:13:44 <glguy> It wasn't until about 2 minutes ago :-p
14:13:59 <mmaruseacph2> now, if that's your scheme, we know all of your passwords
14:14:02 <athan> meh. My channel is unencrypted anyway
14:14:11 <athan> damned android app
14:14:23 <athan> also obama
14:14:47 <glguy> Every Android IRC app I've tried hasn't bothered actually validating the certificates used to protect TLS connections
14:15:07 <nitrix> I can confirm the weechat one does that.
14:15:15 <athan> v_v oye. I wish i could just load gentoo on this thing and be done with it
14:15:29 <glguy> Does weechat have a standalone android app? I thought it was more for a weechat remote client
14:15:32 <athan> hmm, Im using andchat
14:17:26 * athan goes back to the shame corner
14:18:03 <nitrix> glguy: It connects to your existing weechat client, more or less acting like a bouncer.
14:18:33 <nitrix> With the benefit that it knows which messages have been read and stuff.
15:15:02 <shapr> Gurkenglas: are you going to join the #haskell private leaderboard?
15:15:16 <haisheng`> hi there, I'm using `httpLBS` from `http-conduit` to fetch some data from thirdparty. is there an way to "mock the response" otherwise each time I run the code, I hit the thirdparty. 
15:15:29 <Gurkenglas> Why not, but dont expect me to try getting 100s
15:15:41 <Gurkenglas> (Saving up several days at a time to stream)
15:15:46 <glguy> It'll be easy to be in the top 100 on our leaderboard
15:15:50 <glguy> (only 100 people can join)
15:16:23 <glguy> shapr: You know to go back and finish the second half of the problems, right?
15:16:26 <shapr> yes
15:16:45 <shapr> I've been busy organizing events, as usual.
15:16:52 <glguy> OK, just making sure. I'd missed that my first day last year
15:17:02 <shapr> glguy: thanks :-)
15:17:14 <shapr> glguy: if you weren't so far away, I'd suggest you come to the drum building class I'm organizing.
15:17:23 <athan> haisheng: Sure, just fake it with `return`
15:17:46 <athan> @type return "some http response" :: IO String
15:17:48 <lambdabot> IO String
15:17:54 <shapr> Gurkenglas: you stream on periscope or youtube?
15:18:02 <athan> haisheng: but instead of a string it's a LBS
15:18:08 <Gurkenglas> shapr, livecoding
15:18:21 <shapr> oh neat, hadn't heard of that
15:20:25 <haisheng`> athan are you saying modify the function only for testing?
15:21:14 <haisheng`> I guess my point is I dont want to change the source code only for unit test. but trying to "mock" so that unit test works as well as actual code
15:21:46 * shapr looks for Haskell videos on https://www.livecoding.tv/
15:32:41 <monochrom> What does "AoC" in the topic mean?
15:32:48 <Shockk> advent of code
15:32:49 <Shockk> I think
15:35:50 <MarcelineVQ> what does the number mean?
15:41:18 <Shockk> MarcelineVQ: no idea
15:41:22 <Shockk> but I do see glguy on the global leaderboard
15:41:25 <Shockk> in 100th place
15:48:44 <byorgey> MarcelineVQ: it's the code to join a private leaderboard on the AoC site
15:48:55 <byorgey> MarcelineVQ: presumably with other people solving AoC problems with Haskell
15:50:45 <monochrom> I almost thought it was a bank account number for drug dealers to exchange money.
15:52:59 <michbad> What's AoC?
15:53:47 <monochrom> haha
15:56:48 <hpc> what's AoC? ;)
15:57:11 * monochrom decides to make a fake answer.
15:58:09 <monochrom> It's Age of Empires 2 with the Conqueror expansion pack. (So people call it "Age of Conqueror, AoC" colloquially.) The number afterwards is a product key.
16:01:01 <hpc> oh, it could be the axiom of choice
16:01:06 <hpc> according to https://duckduckgo.com/?q=aoc&t=ffsb&ia=meanings
16:10:02 <glguy> https://adventofcode.com releases a 2-part programming problem each day of December up to the 25th
16:10:57 <glguy> the leaderboard is just for people see how far along channel regulars are
16:14:32 <orion> Does anyone else have trouble installing the 'store' package?: http://lpaste.net/2116572669586440192
16:15:29 <glguy> orion: What architecture are you building for?
16:16:03 <orion> armv7-a
16:16:09 <glguy> store doesn't support arm
16:16:24 <glguy> or at least version 0.2.1.2 doesn't
16:16:27 <orion> Oh, so stack is unsupported on arm too?
16:16:58 <glguy> It looks like you can use store-0.3 , however
16:20:43 <danilo2> Hello! The answer to my question is probably "no", but I'll give it a try. Is there any magic that allow me to "convert" type families to functions working on TypeRep ? I suspect TH could do this, but maybe there is something else?
16:26:17 <ij> Shouldn't latest stack's lts have the latest packages?
16:27:00 <glguy> No
16:27:10 <ij> http-client-tls 0.3.3 was out in Sept, but (almost) yesterday's new lts-7.12 has http-client-tls 0.2.4.1.
16:32:54 <kadoban> If the latest lts was just all the newest packages, there'd be no reason to have a lts.
16:33:19 <glguy> lts has whatever major versions were around in nightly at the time when the lts started
16:33:21 <geekosaur> ij, nightly usually has latest packages, provided they work with everything else. lts is just a known good and fully (or as much as possible) tested set
16:33:58 <geekosaur> that won't change out from under you
16:34:05 <geekosaur> (which nightly will)
16:37:20 <ij> ah
16:45:25 <ezyang> In your opinion, is the IsString ByteString instance (1) obviously good, (2) necessary evil, (3) bad 
16:46:05 <c_wraith> 2
16:46:06 <danilo2_> edwardk: Hi Edward! Do you know why when using Reflection library `reifyTypeable A $ \p -> typeRep p` gives different result then `typeRep (Proxy :: Proxy A)` ? 
16:46:30 <glguy> I guess I'd go with 2
16:46:42 <c_wraith> ezyang: I'd never call it good, but I'd defend its existence as too useful to abandon
16:47:32 <edwardk> danilo2_: you mean like reifyTypeable A $ \(_ :: Proxy a) -> typeRep (Proxy :: Proxy a) 
16:47:34 <edwardk> ?
16:47:45 <kadoban> ezyang: Confusing? What does it even do?
16:48:20 <ezyang> kadoban: Interprets each Char as a Word8 
16:48:29 <ezyang> if you have a Unicode char outside of 0-255 that's an error 
16:48:29 <kadoban> ezyang: Ew
16:48:31 <dibblego> (3)
16:48:47 <kadoban> Hmm, if it's an error I guess that's something. Not much though.
16:48:49 <edwardk> i think you may be getting confused about value level A lifted to the type level and the A you have at the type level. A vs. 'A
16:48:59 <edwardk> consider data A = A
16:49:00 <danilo2_> edwardk: isnt it the same than my code? Anyway it gives me the same result of `Stable (W T59 T0 T0 T0) (W T0 T0 T0 T0) A`
16:49:31 <geekosaur> ezyang, count me as (2) on ByteString
16:49:38 <edwardk> there is type A, which inhabits kind *, and a type 'A which is a type that inhabits a kind A.
16:49:52 <edwardk> :t Data.Typeable.typeRep
16:49:54 <lambdabot> forall k (proxy :: k -> *) (a :: k). Typeable a => proxy a -> TypeRep
16:50:03 <ezyang> nevermind, it does something completely insane 
16:50:09 <ezyang> > "«" :: ByteString 
16:50:12 <lambdabot>  error:
16:50:12 <lambdabot>      Not in scope: type constructor or class ‘ByteString’
16:50:12 <lambdabot>      Perhaps you meant one of these:
16:50:19 <ezyang> > "«" :: Data.ByteString.ByteString 
16:50:22 <lambdabot>  error:
16:50:22 <lambdabot>      • Couldn't match expected type ‘BSC.ByteString’
16:50:22 <lambdabot>                    with actual type ‘[Char]’
16:50:26 <edwardk> when you ask for typeRep (Proxy :: Proxy A) you're asking for the former
16:50:29 <ezyang> > fromString "«" :: Data.ByteString.ByteString 
16:50:32 <lambdabot>  "\171"
16:50:49 <dibblego> of course it does, since it is unnecessarily bad :)
16:50:52 <glguy> > fromEnum '«' `mod`  256
16:50:55 <lambdabot>  171
16:50:57 <ezyang> lol 
16:51:39 <edwardk> when you ask for reify A typeRep   -- you are turning a value (that happens to be A at the term level) into a unique type, then you happen to be asking for what type that is. the type that reflects this particular 'A' is a unique pointer to it in memory (by using some trickery)
16:52:51 <edwardk> you can reify all sorts of things, but ultimately the job of reify is to craft a type that turns anything at the value level into a unique type that has an instance that lets you get back the value
16:52:58 <danilo2_> edwardk: hmm, ok that's very interesting. So is it even possible to "lift" such value to type level in such way, that the following equation will result in true? 
16:53:28 <edwardk> reify does this by just playing unsafeCoerce games. reifyTypeable has to make an instance that is actually Typeable. This requires me to go back and basically do what was done in the original oleg paper. making it much much heavier weight
16:53:28 <danilo2_> edwardk: data A = B; typeRep (Proxy :: Proxy A) == (reifyTypeable A $ \(_ :: Proxy a) -> typeRep (Proxy :: Proxy a))
16:53:52 <edwardk> no. that isn't the job of reifyTypeable
16:54:38 <edwardk> reifyTypeable (x :: a) is trying to make any type 's' it can such that reflect :: Reifies s a => proxy s -> a gives you back 'x' and s is Typeable.
16:54:50 <edwardk> s isn't the type 'a'
16:55:01 <mtn`> this isn't much of an interesting question, but i get a crazy long string or errors when I try to compile things I know should compile. is there any way i can uninstlal haskell platform if i got it through the full installer (downloaded tar.gz)
16:55:08 <edwardk> s determines a single value of type a.
16:55:13 <edwardk> and is typeable
16:55:15 <ezyang> Hmm, I'm designing the Str signature for Backpack and I'm wondering if I should split up operations that refer to Word8/Char into their own little bin 
16:55:18 <danilo2_> edwardk: oh snap. I understand now where I confused things!
16:55:28 <danilo2_> edwardk: of course! Thank you so much for clarification!
16:55:53 <danilo2_> edwardk: thanks for your time!
16:56:16 <edwardk> danilo2_: the reason reifyTypeable exists is because we have things like Exception, which randomly decided to bake in Typeable as the means of embedding/projecting the individual exception type into SomeException
16:56:53 <mtn`> (or perhaps there's a more appropriate place to ask a technical question like this?)
16:57:01 <edwardk> so if you want to have Reifies Whatever x => Exception (Foo x) -- you still need Typeable x. or Foo x can't be typeable. that is the role of reifyTypeable
16:57:16 <edwardk> i used to be able to hack it directly by making a manual Typeable instance for Foo x
16:57:30 <edwardk> but since ghc took that over i had to come up with a way to manufacture a fully legal Typeable instance
16:57:54 <edwardk> and the way that i do that now is with that Stable (W T59 T0 T0 T0) (W T0 T0 T0 T0) A nonsense
16:57:59 <glguy> mtn`: There's information about uninstalling the Haskell Platform available by searching on Google
16:58:28 <edwardk> Stable there is taking two 32 bit arguments written out byte by byte, and the type of 'A', and each of the components of it is Typeable, so the result is Typeable
16:58:57 <mtn`> glguy, I didn't install it through apt-get or anything, so I have run those but it's not finding any instance of haskell-platform
16:58:58 <edwardk> and those arguments are the address of the 'a' you gave me, converted first into a StablePtr temporarily to make it serializanle
16:59:04 <edwardk> er serializable
16:59:17 <glguy> mtn`: You'll have to find the uninstall script
16:59:26 <edwardk> then i remove the stableptr to avoid leaking it after playing some games with the instance to force it to be evaluated first
17:00:01 <mtn`> glguy, Should it have come in the same directory as my install?
17:00:11 <glguy> I don't know
17:04:00 <erisco> when flip, reverse, and swap are all taken...
17:04:26 <MarcelineVQ> fleversap
17:04:37 <Shockk> invert?
17:04:48 <Shockk> revert?
17:04:52 <erisco> good enough
17:04:53 <Shockk> reversePolarity?
17:08:17 <mniip> turnaround
17:08:59 <glguy> aboutFace
17:11:05 <danilo2_> edwardk: I've got last one question regarding reflection-like things. Do you think it will be somehow magically possible to create a function like reifyTypeRep, which will take a TypeRep and will give acces to Proxy value, which we can use to get the TypeRep? Something like reifyNat
17:12:01 <dazednconfused> hi room. if i have a 'ones' defined as 'ones = [1..]', how can i rewrite ones recursively without the '..'? 
17:12:06 <dazednconfused> i came up with this "ones = 1:map succ ones"
17:12:35 <danilo2_> edwardk: It could of course not be exctly `typeRep` and `Typeable` (I know GHC disallows some magic now) - this could work with custom typeclass 
17:12:41 <dazednconfused> is there a better way to do it?
17:13:12 <mniip> dazednconfused, that's good enough
17:13:27 <pavonia> ones = 1 : ones
17:13:33 <pavonia> Oh wait
17:13:37 <mniip> pavonia, [1..] not [1,1..]
17:13:43 <erisco> the name is misleading
17:13:44 <mniip> dazednconfused, there's also this depending on which you think it's clearer:
17:13:49 <pavonia> Yeah, it's confusingly named
17:13:51 <mniip> > fix $ (1:) . map succ
17:13:53 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:14:34 <dazednconfused> the reason i ask is that if i have a data type like "data List a = Nil | Cons a (List a)"
17:14:52 <dazednconfused> I want to be able to rewrite the "ones" function for this data type
17:15:34 <dazednconfused> i know i should end up with an answer of "Cons 1 (Cons 2 ( Cons 3..."
17:15:36 <mckeankylej> Can you use aeson's th support to deriveJSON instances for GADTs?
17:15:46 <dazednconfused> but I'm not sure how to go about doing it
17:15:47 <erisco> isn't the map version quadratic?
17:16:38 <mniip> sure is
17:17:07 <glguy> I think it's not as long as the list has a monomorphic type
17:17:23 <mniip> dazednconfused, you need a fold/map operation on that datatyp
17:17:23 <mniip> e
17:18:12 * glguy gets out a pen and paper to try and make some sense of it
17:19:08 <mniip> oh
17:19:10 <mniip> right
17:19:12 <mniip> it is linear
17:19:21 <mniip> or maybe not
17:19:27 <mniip> yeah, paper is what I need
17:19:45 <erisco> it craps in ghci at 100M on my machine
17:19:48 <dazednconfused> mniip, i dont understand what you mean by a fold/map on that datatype
17:20:02 <mniip> dazednconfused, you need to define map for your list typee
17:20:05 <mniip> or at least fold
17:20:28 <glguy> erisco: You're probably just running out of memory
17:20:34 <glguy> when I print the list it doesn't get slower
17:20:35 <erisco> yes
17:20:58 <erisco> what is it using the memory for?
17:21:02 <glguy> storing the list
17:21:06 <edwardk> @tell danilo2_ yes. you can do it using reflection style tricks to construct the Typeable dictionary from whole cloth
17:21:06 <lambdabot> Consider it noted.
17:21:33 <erisco> seems wasteful
17:22:34 <monochrom> Recall that each cons cell takes 24 bytes, and this is only cons cells, the list skeleton, not even actual data.
17:25:05 <erisco> here is my Rube Goldberg
17:25:14 <erisco> > fmap getSum (join (flip (scanl mappend) . repeat) (Sum 1))
17:25:16 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:26:10 <mckeankylej> erisco: what is the complexity of that alg? n additions?
17:26:44 <erisco> my guess is linear
17:27:22 <lpaste> dazednconfused pasted “List” at http://lpaste.net/349731
17:27:30 <dazednconfused> mniip, does this look right?
17:27:47 <erisco> iterate succ 0   or   iterate (+1) 0    is simpler
17:28:31 <mniip> you can do something like this too
17:28:32 <mniip> > fix $ (0:) . foldr ((:) . succ) undefined
17:28:35 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
17:28:48 <mniip> dazednconfused, sure
17:29:00 <mniip> now just translate your [] implementation to List
17:29:01 <Gurkenglas> dazednconfused, yep. By the way you can add "deriving Functor" to line 1 so you can use fmap whereever you would use map'
17:29:13 <mniip> Gurkenglas, but {-# LANGUAGE #-}
17:29:25 <Gurkenglas> Oh, I thought that was default
17:29:29 <mniip> no
17:29:38 <mniip> default is haskell2010
17:30:17 <dazednconfused> ok mniip , so using this map and my List type, how do i define something like [1..]
17:30:34 <mniip> well how did you do it with : and map
17:31:15 <dazednconfused> I tried this but it throws an error "ones = 1 `Cons` (map succ ones)"
17:31:30 <erisco> map works on lists only
17:31:44 <dazednconfused> oh sorry i must try with map'
17:33:10 <dazednconfused> awesome this works "ones = 1 `Cons` (map' succ ones)"
17:36:43 <Myrl-saki> :t map'
17:36:45 <lambdabot> error:
17:36:45 <lambdabot>     • Variable not in scope: map'
17:36:45 <lambdabot>     • Perhaps you meant one of these:
17:36:54 <Myrl-saki> dazednconfused: map'?
17:36:58 <mtn`> thing's aren't working well with haskell installations on my computer (ubuntu 16.1), so i'd like to remove all instances on my computer. where should i look/ what should i delete?
17:37:09 <dazednconfused> check my lpaste
17:37:40 <dazednconfused> Myrl-saki, this was for an assignment. Check my lpaste 
17:38:09 <geekosaur> mtn`, we have no way to guess what way(s) you used to install it.
17:38:13 <kadoban> mtn`: Depends. How/what did you install?
17:38:30 <monochrom> give us your ssh password :)
17:38:30 <geekosaur> but, yes, known issues with current ubuntu, will be fixed in upcoming 8.0.2
17:38:42 <Myrl-saki> dazednconfused: Can you link it again?
17:38:53 <monochrom> http://lpaste.net/349731
17:38:59 <mtn`> geekosaur, kadoban At least one way was the haskell platform-independent installer, but i believe I already got rid of that stuff
17:39:02 <kadoban> monochrom: lol
17:39:10 <mtn`> perhaps it's just an issue with 8.01 and ubuntu 16.1?
17:39:26 <mtn`> i've been working on 16.04 with no problems, but a new laptop required the new version
17:39:47 <kadoban> I know stack has some issues correctly installing GHC on 16.10, but I dunno otherwise.
17:39:50 <Myrl-saki> dazednconfused: Errr. I understand now. Don't worry. xD
17:39:51 <erisco> are "domain" and "codomain" used for relations?
17:40:29 <geekosaur> mtn`, 16.10 turned on position independent executables by default in the linker and ghc < 8.0.2 doesn't know how to generate them
17:40:31 <slack1256> what exactly is lens-based parsing? I read it on the context of pipes-parse
17:40:56 <geekosaur> there are some hacks to enable ghc to force the linker to old style executables, but they require patching more than just ghc's config
17:41:16 <monochrom> yes erisco
17:41:19 <mtn`> geekosaur, got it, thanks. yeah that's probably above my level of understanding
17:41:19 <geekosaur> (which is also what trips stack up)
17:41:30 <mtn`> geekosaur, typing commands i don't understand probably isn't a good idea
17:41:37 <mtn`> geekosaur, is 8.02 imminent?
17:42:26 <erisco> monochrom, thanks
17:43:02 <geekosaur> there is an 8.0.2 prerelease with some known bugs
17:43:12 <geekosaur> which they're whacking down to get it to release
17:44:03 <mtn`> geekosaur, Ah I see, I found the logs. Thanks for letting me know! Was thinking i was doing something wrong with the installation for sometime
17:44:19 <geekosaur> https://launchpad.net/~hvr/+archive/ubuntu/ghc should have the prerelease and its prerequisites
17:44:26 <geekosaur> as PPAs for ubuntu
17:45:07 <erisco> should rewrite rules avoid using function composition in preference of lambdas?
17:45:41 <lpaste> dazednconfused pasted “List” at http://lpaste.net/349732
17:46:06 <dazednconfused> why doesn't this work?
17:46:21 <monochrom> What is "doesn't work"?
17:46:43 <dazednconfused> Sorry i was typing..
17:47:00 <glguy> Enter key has a mind of its own
17:47:11 <monochrom> And I am surprised at pulling the ()->Stream trick. This is something you would do in SML, but too proud to do in Haskell.
17:47:25 <dazednconfused> I get a type error. at the "map' f rest" it says it's a Stream b type
17:47:36 <mtn`> geekosaur, Sorry, this might be a stupid question. But does it not get automatically added to path or something on install? If I run ghci it runs 7.10.3
17:47:43 <dazednconfused> but expects a () -> Stream b
17:47:46 <glguy> dazednconfused: You can't change the type of the second field of Cons but not update all of the uses of it
17:47:52 <mtn`> (I added the ppa and run sudo apt-get install ghc-8.0.2)
17:48:26 <geekosaur> no, it doesn't add to $PATH. the original intent was to allow multiple versions to be installed in parallel for things like build farms
17:48:53 <monochrom> You have a type sig that causes "map' f rest" to have type "Stream b". But the Cons field wants "() -> Stream b".
17:48:57 <dazednconfused> glguy, the second field is a function from () to Stream. How do I write it in my map'?
17:49:10 <monochrom> Write a function there.
17:49:58 <monochrom> This sounds tautological, yes. The field wants a function, so give it a function.
17:50:15 <monochrom> The trouble with humans is that they don't take these tautologies seriously.
17:50:37 <monochrom> They trust their intuition more than they trust obvious tautologies.
17:50:39 <geekosaur> "The GHC packages install into `/opt/ghc/$VER/` so in order to use them, one way is to bring a particular GHC version into scope by placing the respective `/opt/ghc/$VER/bin` folder early in the PATH environment variable."
17:50:56 <monochrom> The trouble with intuition is that by definition it is "without reason".
17:51:09 <dazednconfused> monochrom, i don't understand :(
17:51:10 <geekosaur> I also have a wrapper script https://github.com/geekosaur/ghc-wrapper but it's kinda raw at present
17:51:25 <monochrom> Cons (f a) (write a suitable function here)
17:51:28 <dazednconfused> i'm dazednconfused 
17:51:57 <mtn`> geekosaur, Thank you. i think i need to learn more about unix to make this less of a black box :0
17:53:02 <monochrom> OK let us go back to square zero.
17:53:05 <dazednconfused> monochrom, i still don't get it
17:53:14 <monochrom> Do you agree that "() -> whatever" is a function type?
17:53:19 <dazednconfused> yes i do
17:53:55 <monochrom> OK, write me an example value of your Stream type. Let's say Stream Int. Write me an example value of type Stream Int.
17:54:14 <dazednconfused> Cons 1 (\() -> Nil)
17:54:22 <monochrom> OK good.
17:54:33 <ertes> ski: yeah, a fold where the cons case can be switched would make things easier/faster
17:54:37 <monochrom> So similarly you need a function at that position in your map' coding.
17:54:53 <dazednconfused> that is the part i don't understand
17:54:54 <ertes> ski: for example 'drop' in terms of foldr would benefit from this
17:55:20 <monochrom> what is not understood?
17:55:59 <dazednconfused> "you need a function at that position in your map' coding"
17:56:06 <dazednconfused> can you give me an example?
17:56:23 <monochrom> map' f (Cons a rest) = Cons (f a) (need a function here)
17:56:24 <hpc> not so much "need" as you have a function at that position
17:56:42 <hpc> dazednconfused: if you pattern matcn (Cons a b), b is a function
17:56:50 <dazednconfused> yes it is
17:57:18 <dazednconfused> hang on, is this a legal Stream type?
17:57:19 <monochrom> No, hpc, "rest" is what we have, but I am not talking about rest.
17:57:39 <dazednconfused> 1 `Cons` 2 `Cons` (\() -> Nil)
17:57:50 <monochrom> I am talking about Cons (f a) (___fill in the blank here___)
17:58:23 <hpc> oh, on the rhs of the definition
17:58:24 <mniip> dazednconfused, that is wrong
17:59:12 <Myrl-saki> monochrom: Cons (f a) id ?
17:59:21 <Myrl-saki> jk jk
17:59:28 <dazednconfused> why is it wrong? not trying to be a dick. just trying to understand
17:59:44 <Myrl-saki> dazednconfused: Different types.
17:59:48 <monochrom> 1 `Cons` (need a function here. 2 `Cons` whatever isn't a function)
18:00:13 <monochrom> I can be more precise than "need a function here" if you want.
18:00:34 <Myrl-saki> monochrom: Mmm. A funcall, actuallym
18:00:51 <monochrom> Not a funcall.
18:01:10 <monochrom> "sin" is a function, "sin 5" is a funcall, aka application.
18:01:22 <klop> can someone explain if i'm missing something? repa has been in development ~ 6 years and the defacto method for doing an SVD is to convert to hmatrix and solve using hmatrix ...
18:01:28 <Myrl-saki> monochrom: Yes. Exactly what I'm saying.
18:01:44 <monochrom> OK yes.
18:02:17 <klop> kind of disheartening for the state of numerics in haskell =(
18:02:21 <Myrl-saki> We're still in map', right? Or am I embarrassing myself?
18:02:31 <dazednconfused> yes we're still in map'
18:02:32 <monochrom> We're still in map'
18:02:57 <dazednconfused> Myrl-saki, you're good. I'm the embarrassment here
18:03:34 <dazednconfused> ok i think i got it
18:03:40 <dazednconfused> 1 `Cons` (\() ->  2 `Cons` (\() -> Nil))
18:03:42 <dazednconfused> ??
18:03:46 <monochrom> yes that works
18:03:51 <erisco> ghc is complaining that a field projector may inline... I guess this rewrite rule is not definable? oO
18:04:03 <erisco> it is equivalent to the rule  swap . swap = swap
18:04:03 <dazednconfused> aargh my brain hurts
18:04:17 <Myrl-saki> Errr
18:04:18 <erisco> but it complains swap will inline, so then I try defining it just with constructors and projectors
18:04:23 <erisco> complains the projectors will inline
18:04:26 <monochrom> because you try to think intuitively.
18:04:40 <monochrom> if you follow rules logically and mechanically it's easy.
18:04:46 <dazednconfused> err..
18:04:54 <dazednconfused> i'm still not sure how to write map' though
18:05:05 <erisco> as easy as speaking Chinese
18:05:24 <Myrl-saki> I'm lost myself. Is the definition "List a = Cons a (\() -> List a) | Nil"?
18:05:39 <monochrom> data Stream a = Nil | Cons a (() -> Stream a)
18:05:41 <dazednconfused> yes.. just replace List with Stream
18:05:44 <erisco> I mean  swap . swap = id
18:06:30 <Myrl-saki> Oh. monochrom, yeah. you're right. It is a function. My mistake. >.<
18:06:33 <mniip> erisco, depends
18:06:53 <monochrom> Yes map' is difficult for this Stream type. But you can always start with "Cons (f a) (\() -> ???)"
18:07:16 <mniip> why are we even doing () ->?
18:07:19 <mniip> is this an assignment?
18:07:27 <mniip> from an ML person?
18:07:30 <erisco> you can mark swap as NOINLINE, but that is stupid
18:07:40 <monochrom> But you should rejoice at the progress of going from "I thought I was right" to "I now know what counts as wrong".
18:07:58 <monochrom> Because it's progress from self-deception to reality.
18:08:03 <Myrl-saki> monochrom: ++
18:08:22 <dazednconfused> mniip, yes it's an assignment
18:08:42 <dazednconfused> monochrom, i knew i was wrong, i just didn't know why :(
18:08:52 <dazednconfused> now i know i'm wrong and why
18:09:02 <dazednconfused> i must now set it right
18:09:46 <dazednconfused> can i have a function in the pattern matching bit?
18:09:50 <exio4> mniip: it is perfectly fine - for assignments you can often ignore things like this until later on the course :p 
18:09:55 <monochrom> how do you mean?
18:10:05 <monochrom> But you won't need it.
18:10:25 <dazednconfused> as in "map' f (Cons a (\() -> rest)) = Cons (f a) (\() -> map' f rest)"
18:10:40 <monochrom> But you won't need it.
18:10:59 <monochrom> rest :: () -> Stream a  --- this is given
18:11:16 <monochrom> If you desire a "Stream a" you just need to do "rest ()"
18:11:28 <monochrom> Again, from just following rules, no intuition necessary.
18:11:53 <monochrom> Intuition is why people suffer through headaches and then still end up being wrong.
18:12:04 <monochrom> Worst of both worlds.
18:12:13 * dazednconfused cries
18:13:33 <dazednconfused> ok please tell me how to do it. i really don't know
18:13:46 <monochrom> Let me spell out the rules I use, so you don't see me as just saying "follow the rules" without how.
18:14:00 <dazednconfused> ene if you say follow the rules, it's clear i do not know all the rules
18:14:11 <monochrom> You have this pattern-matching beginning "map' f (Cons a rest) = ..."
18:14:18 <dazednconfused> ok
18:14:42 <dazednconfused> rest is () -> Stream
18:14:49 <monochrom> So that pattern promises you "a :: a" and "rest :: () -> Stream a" because they are the respective fields of Cons.
18:15:07 <dazednconfused> yes i agree
18:15:23 <monochrom> Another rules is that whenever you have "gee :: X -> Y", then "gee (something of type X) :: Y"
18:15:38 <dazednconfused> yes i agree again
18:16:04 <monochrom> In case X=(), the something is simply (), no need to think up a smart choice.
18:17:14 <erisco> where's my mapKeysWithMonotonic
18:17:16 <monochrom> OK, so you are coding up "map' f (Cons a rest) = Cons (f a) (dunno what to do here but it's () -> Stream b)"
18:17:18 <dazednconfused> ok so i need a function there that returns a Stream and map on that?
18:18:04 <monochrom> But it's easy to make a small move and have map' f (Cons a rest) = Cons (f a) (\() -> OK now I just need Stream b here)
18:18:43 <monochrom> And it's easy to say you anticipate recursion and this might as well be a good time to play the recursion card.
18:18:48 <orion> If you're using the LLVM backend, shouldn't ARM support be fairly straight forward?
18:19:05 <dazednconfused> yeah that's what i think
18:19:21 <monochrom> map' f (Cons a rest) = Cons (f a) (\() -> map' f (??? :: Stream a) :: Stream b)
18:19:59 <monochrom> The trick is to play the recursion card after you have "\() ->" so you get the right types.
18:20:22 <monochrom> OK so now we're wondering how to conjure a ??? :: Stream a
18:20:35 <dazednconfused> yes
18:20:39 <monochrom> with the given "rest :: () -> Stream a"
18:20:49 <monochrom> or rather maybe s/given/promised/
18:20:57 <dazednconfused> yes yes
18:21:12 <monochrom> At this point the code writes itself, no?
18:21:49 <dazednconfused> Sorry man i just don't get it
18:21:57 <monochrom> rest () :: Stream a
18:22:41 <dazednconfused> rest () :: Stream a?
18:22:54 <monochrom> Yes, you agreed before.
18:23:08 <monochrom> Let me find where you signed...
18:23:20 <dazednconfused> yes yes
18:24:18 <dazednconfused> ok i get it
18:24:50 <dazednconfused> wow
18:25:02 * dazednconfused is mind blown
18:25:25 <monochrom> You break the big problem into small subproblems and solve subproblems piecemeal. You don't look at the whole thing holistically.
18:25:45 <monochrom> Holistically is too overwhelming. Too much memory required.
18:26:23 <monochrom> To be sure, I did and do look holistically sometimes. But only when I'm hunting for the next point to zoom in, the next subproblem to solve.
18:26:35 <monochrom> When solving a subproblem I don't care about the big picture.
18:26:45 <dazednconfused> Hmmm..
18:26:59 <mniip> well
18:27:13 <mniip> there's also that thing where you look at the big picture
18:27:13 <monochrom> For example there was a time I worried about "how do I conjure () -> Stream b"
18:27:29 <mniip> you ignore the little detail though
18:27:46 <mniip> the small detail I mean
18:27:48 <monochrom> But then after we decided "it will look like \() -> something", I zoomed into "??? :: Stream b" and now I forget about the -> and the lambda.
18:28:21 <monochrom> mniip, that's when you marvel at someone's marvelous solution. Not when you are the one creating the solution.
18:28:34 <mniip> not really
18:28:57 <mniip> sometimes you have to reevaluate your program's architecture
18:29:02 <monochrom> OK, also when you are decomposing the problem, but that's what I said.
18:29:45 <erisco> there should be some function like (f (Sum a) -> Sum a) -> f a -> a but I cannot find it
18:30:35 <mniip> :t (getSum .) . (. fmap Sum)
18:30:37 <lambdabot> Functor f => (f (Sum a) -> Sum c) -> f a -> c
18:31:00 <erisco> yes I know but there is a function like this named already
18:31:20 <mniip> coerce?
18:31:35 <mniip> :t Data.Coercible.coerce :: (f (Sum a) -> Sum a) -> f a -> a
18:31:37 <lambdabot> error:
18:31:37 <lambdabot>     Not in scope: ‘Data.Coercible.coerce’
18:31:37 <lambdabot>     No module named ‘Data.Coercible’ is imported.
18:31:47 <mniip> :t Data.Coerce.coerce :: (f (Sum a) -> Sum a) -> f a -> a
18:31:48 <lambdabot> error:
18:31:48 <lambdabot>     • Couldn't match representation of type ‘f1 (Sum a1)’
18:31:48 <lambdabot>                                with that of ‘f1 a1’
18:31:52 <mniip> maybe not
18:31:53 <dazednconfused> ok but now my "ones" is broken
18:32:07 <erisco> asSum fold :: Foldable t, Num a => t a -> a   for example
18:32:12 <monochrom> Yes ones needs to be rewritten too.
18:32:33 <mniip> oh well, it can't work with a polymorphic 'f' since it needs a nominal role
18:32:42 <monochrom> everything needs to be rewritten.
18:33:08 <erisco> this is a case of someone mentioning such a function a few months ago
18:33:17 <erisco> and now I wants it
18:34:11 <erisco> I guess it picks up a Functor t as well, but whatever
18:34:18 <dazednconfused> ones = 1 `Cons` (\() -> map' succ ones)
18:34:39 <dazednconfused> phew
18:34:41 <monochrom> does that type-check?
18:34:46 <erisco> maybe the secret is in foldMap...
18:34:56 <monochrom> @type foldMap
18:34:57 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
18:35:19 <dazednconfused> monochrom, yes it's ones :: Stream Integer
18:35:23 <monochrom> Good
18:35:40 <dazednconfused> thank you so much monochrom 
18:35:44 <monochrom> you're welcome
18:35:46 <dazednconfused> and also mniip and Myrl-saki 
18:36:00 <dazednconfused> all the folks who helped
18:36:19 <erisco> asSum :: ((a -> Sum a) -> b -> Sum c) -> b -> c   then  asSum foldMap
18:36:39 <erisco> which just has Foldable and Num ... but this function is not found either, hm
18:36:42 <erisco> maybe it is more generic!
18:37:27 <erisco> it would have to abstract getSum/Sum though... but there is such a wrap/unwrap abstraction out there (or a few)
18:38:22 <ezyang> I wonder what ever happened to the "adding structure to monoids" paper 
18:40:31 <erisco> there is a class for it, if anyone can remember
18:43:00 <erisco> class Wrapper f where wrap :: a -> f a; unwrap :: f a -> a;   laws: wrap . unwrap = id; unwrap . wrap = id
18:45:28 <erisco> then you have  as :: Wrapper f => (f a -> f b) -> a -> b; as f = unwrap . f . wrap;   use as   as @Sum f   and things like this
18:45:40 <monochrom> I think I've heard of it.
18:46:10 <monochrom> No, I haven't, the "wrap" I've heard of belonged to a class for free monads.
18:49:53 <erisco> wrap has same sig as pure/return, unwrap as extract
18:50:10 <erisco> and (f a -> f b) -> a -> b suspiciously like (a -> b) -> f a -> f b but not cofunctor
18:50:48 <mniip> that's a functor
18:51:16 <erisco> what is?
18:51:23 <mniip> (f a -> f b) -> a -> b
18:51:35 <mniip> and endofunctor on Hask, though I don't think I can come up with anything other than Identity there
18:52:02 <erisco> I mean not Cofunctor, I don't know about the CT stuff
18:52:17 <mniip> no such thing as cofunctor
18:52:18 <ertes> mniip: V2
18:52:19 <erisco> not comap or whatever they call it
18:52:35 <erisco> http://hackage.haskell.org/package/cofunctor-0.1.0.1/docs/Data-Cofunctor.html
18:52:37 <ertes> data V2 a = V2 a a
18:52:52 <mniip> that's a contravariant functor
18:52:56 <mniip> not a cofunctor per se
18:53:04 <erisco> well, I didn't name it :P
18:53:08 <mniip> ertes, what's the 'map'?
18:53:17 <mniip> ah, nevermind I see
18:53:36 <ertes> mniip: it has zipWith semantics
18:53:44 <Welkin> a coprofunctor
18:53:47 <erisco> actually I know conal knows what I am looking for
18:54:03 <ertes> erisco: what's the application?
18:55:00 <erisco> well it started as looking for the function which wraps and unwraps with Sum so that I can, for example, asSum foldMap
18:55:10 <erisco> but it doesn't seem to be exactly that, but I know something like it exists
18:55:29 <Welkin> coerce?
18:55:32 <mniip> ertes, nit: if f = \(V2 x y) -> V2 x undefined
18:55:39 <Welkin> no
18:55:42 <Welkin> that is for marshaling
18:55:51 <mniip> then 'cofmap (id . f) /= cofmap id . cofmap f'
18:56:25 <ertes> mniip: the one i had in mind actually has strict fields
18:56:32 <mniip> not really a serious argument, but it's there
18:56:45 <ertes> mniip: it's V2 from Linear.V2 from 'linear'
18:58:23 <ertes> that should satisfy even the slow and fast reasoners =)
18:58:31 <ertes> uh…
18:58:40 <ertes> let's say slow and firm instead
18:58:56 <EvanR> reasoners who are both slow and fast?
18:59:06 <EvanR> so nobody!
18:59:06 <ertes> yeah, i realised =)
18:59:34 <ertes> ("what's the opposite of fast? slow! what's the opposite of loose? fast!")
18:59:40 <EvanR> that will satisfy both even and odd numbers
19:00:03 <Welkin> ertes: you mean tight
19:01:18 <ertes> you heff to imägine everysing i say with se german äccent
19:02:08 <MarcelineVQ> erisco: are you perhaps thinking of ala?
19:02:39 <MarcelineVQ> > ala Sum foldMap [1..10]
19:02:45 <lambdabot>  mueval-core: Time limit exceeded
19:02:54 <MarcelineVQ> > ala Sum foldMap [1..5] -- robuts :>
19:03:02 <lambdabot>  15
19:03:07 <EvanR> that...
19:03:15 <EvanR> should be more efficient
19:03:43 <MarcelineVQ> She works for multiple employers.
19:03:52 <EvanR> the abacus salesmen would have beat lambdabot in that contest
19:04:27 <erisco> @definition ala
19:04:27 <lambdabot> Unknown command, try @list
19:04:30 <MarcelineVQ> Chances are good around here that multiple other requests were being muevaleded at the same time
19:04:34 <erisco> @source ala
19:04:34 <lambdabot> Unknown command, try @list
19:04:35 <ertes> > ala Sum foldMap [1..10]
19:04:38 <lambdabot>  55
19:04:45 <ertes> lambdabot was just a bit sleepy
19:04:49 <HoloIRCUser3> >grep
19:04:51 <erisco> :t ala
19:04:53 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
19:04:56 <MarcelineVQ> erisco: http://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Wrapped.html#v:ala
19:04:58 <EvanR> MarcelineVQ: interesting privacy leak
19:05:00 <HoloIRCUser3> >
19:05:06 <erisco> ah, figures to be in lens -.-
19:05:16 <erisco> but yes, that is what I was looking for, thanks
19:05:19 <MarcelineVQ> it's not only from lens iirc but you can get it from there
19:05:34 <MarcelineVQ> there's probably a newtype package which would have it
19:05:57 <MarcelineVQ> ah yeah http://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html
19:06:49 <erisco> yeah this was what I was trying to find. thanks
19:41:51 <alx741> I just ended up with a 'Maybe Maybe Int', IIRC there is a way to make that a 'Maybe Int', but how?
19:42:09 <geekosaur> join
19:43:35 <geekosaur> :t join
19:43:37 <lambdabot> Monad m => m (m a) -> m a
19:43:42 <divVerent> alx741: not sure whether that was clear - but join turns m (m a) into m a for all monads, including Maybe
19:44:04 * geekosaur got diverted by trying the wrong demonstration
19:44:35 <divVerent> now that you know it's possible, can you guess how join is defined in terms of the usual monad operations? :)
19:44:42 <alx741> yep that was it! thanks guys!
19:44:57 <geekosaur> :t join `asAppliedTo` (Just (Just "x"))
19:45:01 <lambdabot> Maybe (Maybe [Char]) -> Maybe [Char]
19:45:17 <divVerent> hehe, asAppliedTo is nice
19:45:57 <divVerent> a somewhat nicer way to do some type assertions
19:46:09 <divVerent> anyway, here is how join COULD have been defined:
19:46:43 <divVerent> join mmx = do { mx <- mmx; mx; }
19:47:06 <divVerent> which can again be written in like a thousand different ways :)
19:48:30 <xcmw> Is there a way to write the all of the return values of a type class must implement eq and show?
19:52:43 <EvanR> Maybe Maybe Int looks so wrong
19:52:55 <EvanR> like lisp without parentheses
19:53:31 <divVerent> hehe, yes
19:54:09 <divVerent> xcmw: regular typeclasses can't do that, I'd look in FunctinalDependencies and TypeFamilies
19:54:14 <geekosaur> "return values of a typeclass"?
19:54:32 <divVerent> I think he means a typeclass in which some functions shall return Eq-able types
19:54:33 <geekosaur> you can require typeclass instances for a type variable in a typeclass, and use that in a result
19:55:07 <divVerent> right - just, multi-param typeclasses are an extension
19:55:14 <geekosaur> but, it depends on how you are using it and yes, if this gives you a multiparameter typeclass then you will want either fundeps or type families to remain sane
19:55:16 <divVerent> and if you need that, you'll liikely want FunctinalDependencies too
19:55:29 <divVerent> and probably want to check if what you do is better expressed with TypeFamilies
19:55:39 <geekosaur> (you can work wothout them but you'll need a type ascription on ~every use)
19:55:42 <divVerent> oh, same as what geekosaur said
19:55:44 <xcmw> Wait. I meant Type Family not type class.
19:55:57 <geekosaur> ...now I think I want to see an example use
19:56:04 <geekosaur> since type families don't have results
19:57:06 <glguy> xcmw: no, you can't require that: forall a. Show (YourTypeFamily a)
19:57:37 <glguy> Oh, maybe as an associated type family
19:57:42 <geekosaur> ^
19:58:02 <geekosaur> because the typeclass can constrain the type family instance
19:58:25 <geekosaur> in the same way it can constrain other type variables in the typeclass head
19:58:53 <glguy> class (Show (F a), Eq (F a)) => C a where type F a
20:00:10 <glguy> That doesn't mean that you'll know that given some 'a', Show (F a), however
20:01:28 <xcmw> glguy: I will try that
20:12:35 <xcmw> glguy: I need to know that for any a, Show (F a)
20:12:57 <glguy> yeah, but we covered that you can't
20:13:18 <glguy> just that you can restrict it
20:18:08 <dazednconfused> is there a function in haskell which returns the type of some value?
20:18:36 <dazednconfused> apart from :t in the ghci
20:18:46 <geekosaur> no, because all types are known at compile time
20:19:25 <geekosaur> unless you mean Typeable, which has limited uses because you really want to use compile time typing as much as possible, to catch type errors at compile time instead of runtime
20:21:26 <dazednconfused> this is from a school assignment: "Define a value of any type and call it b such that you have b :: a"
20:21:43 <dazednconfused> So b is of type a, correct?
20:22:14 <dazednconfused> Considering the b just defined, and k defined as "k a b = a"
20:23:07 <dazednconfused> So the statement here means that k is a function that takes 2 parameters of a and b and returns a.
20:23:18 <dazednconfused> But b :: a
20:23:56 <dazednconfused> So k is a function that takes a type a and a value b and returns the type?
20:24:02 <dazednconfused> I don't understand
20:25:19 <geekosaur> I feel like you have confused values and types on some level, or maybe the assignment did. possibly type the full text of the assignment into an lpaste?
20:25:21 <geekosaur> @paste
20:25:21 <lambdabot> Haskell pastebin: http://lpaste.net/
20:26:21 <pavonia> dazednconfused: In "k a b = a" a is a value; in "b :: a" is a type
20:26:44 <pavonia> *"b :: a" a is a type
20:26:49 <dazednconfused> geekosaur, I could but that'd be malpractice on my part right?
20:27:10 <geekosaur> the assignment? as long as you don't include an answer, I'd think not
20:27:40 <geekosaur> (and nobody else adds one afterward)
20:28:19 <geekosaur> but you've already quoted from it in here and this channel is logged, so if pastebinning it is wrong then so was that ")
20:28:30 <geekosaur> :)
20:29:16 <dazednconfused> pavonia, the two statements are right after one another. so i'm confused
20:30:27 <geekosaur> (if anything, quoting it in here was potentially worse; professors and TAs *are* known to hang out in here watching for cheating...)
20:30:33 <dazednconfused> geekosaur, well the assignment says "you may take advantage of any written or internet resources :)"
20:31:09 <xcmw> Is it possible to convert Eq a => a into a kind? I'm guessing that it is impossible.
20:31:23 <geekosaur> :k Eq
20:31:25 <lambdabot> * -> Constraint
20:31:56 <Axman6> :k Eq a => a
20:31:57 <lambdabot> error: Not in scope: type variable ‘a’
20:31:58 <lambdabot> error: Not in scope: type variable ‘a’
20:32:35 <geekosaur> otherwise I'm not sure what you're asking. unless you want kind aliases, which are just `type`s with the ConstraintKinds extension iirc
20:33:24 <exio4> :k forall a. Eq a => a
20:33:26 <lambdabot> *
20:33:42 <exio4> xcmw: what do you exactly need?
20:36:22 <xcmw> exio4: It is not possible. I was trying to garentee that Eq (F a) for any given a where F is a type family
20:38:38 <exio4> xcmw: where do you need that? maybe there's a workaround 
20:41:03 <xcmw> exio4: It is very complicated. If you have time to look at it I will post the code. I am trying to write a better records system with GADTs. I am trying to write a generic show function.
20:41:13 <exio4> I have some time =)
20:41:30 <exio4> xcmw: unless it's going to take 1+ hour, I guess I can check :P 
20:42:05 <xcmw> exio4: Less than an hour
20:43:37 <lpaste> xcmw pasted “Code” at http://lpaste.net/349734
20:44:33 <xcmw> exio4: I am tring to write a generic equal function
20:46:19 <xcmw> exio4: What I have works but I was hoping to find a better way
20:51:31 <xcmw> exio4: Any better way? I was hoping to restrict the Thing instead of the key. Sorry for the terrible variable names
20:51:57 <exio4> xcmw: have you tried using ConstraintKinds and parametrizing on it? data CKey (c :: * -> Constraint) a k = forall t. (c (Field k t)) => CKey (a t)
20:53:18 <xcmw> exio4: Good idea
20:55:09 <exio4> I am trying to see why stack isn't working here, and I am checking much how this works :/
20:55:15 <exio4> not*
20:55:32 <xcmw> exio4: Is there a way to restrict the Thing instead of the keys. Is there a way to write (Think a k where all keys are showable) -> [A u] -> String
20:55:52 <EvanR> a better record system with better generic show is really... something that should be baked into the language
20:56:12 <EvanR> or else easily programmable in the language, neither of which is happening in haskell
20:56:34 <flappynerd> what are your favorite things about haskell
20:57:14 <flappynerd> I'm looking for various bits of information to help me decide on a next language and I have done some haskell before but I'm also looking at a couple other FP related options
20:58:37 <glguy> xcmw: Your examples don't list all the extensions you use. You might forgetting some because they're listed in your .cabal file
20:58:44 <xcmw> EvanR: I got generic get, set, and lens working as long as the GADT contructors implement TestEquality
20:58:54 <xcmw> With the help of glguy
20:58:55 <LordBrain> this is a purely aesthetic thing, but i like that type signatures are easy to spot at a glance, do to that :: they contrast with the definitions
20:58:57 <EvanR> i tried what youre talking about
20:59:03 <EvanR> but its still a pain in the ass
20:59:33 <xcmw> TemplateHaskell, MultiParamTypeClasses, FunctionalDependencies, FlexibleInstances, DisambiguateRecordFields, LambdaCase, ScopedTypeVariables, MultiWayIf, RankNTypes, TypeOperators, TypeFamilies, DataKinds, DeriveGeneric
20:59:56 <LordBrain> idris makes it a single colon, and i know that is "like the math notation" or ocaml or whatever, but its sad because i think the double colon is better
21:00:49 <exio4> xcmw: if I understand correctly you want something akin to Show (forall t. Field g t) =>, right?
21:01:07 <xcmw> Yes
21:01:14 <lambda-11235> flappynerd: Purity, strict typing, algebraic data types, first class functions, and type classes are what I miss the most when coding in other languages.
21:01:39 <flappynerd> lambda-11235, which you say "other languages" which ones are you thinking of specifically?
21:01:56 <xcmw> Where is Contraint defined?
21:02:01 <flappynerd> I'm only really considering FP oriented langs atm
21:03:04 <exio4> xcmw: GHC.Types 
21:04:15 <lambda-11235> flappynerd: C++, python, java, etc. and to a lesser extent SML (missing purity and type classes, as well as higher kinded types).
21:04:45 <flappynerd> lambda-11235, ok so I'm wondering I guess more about what people like about haskell compared to other FP langs
21:04:55 <lambda-11235> I do miss SML's module system, though.
21:04:57 <flappynerd> I have at least an idea of what people don't like about C++ and Java :)
21:04:59 <exio4> xcmw: I don't know any way to do that - but I'll try to do something :P
21:08:59 <c_wraith> flappynerd: what I like most about Haskell is that the language design makes it easy to follow rules that have been observed to result in more maintainable code in every language - isolate your IO, use immutable data structures, correctly document what your functions expect and what they return, etc.  In many languages, those rules require discipline, because they aren't the natural approach.  In haskell, those are usually the most natural ways of doing
21:08:59 <c_wraith>  things.
21:16:58 <flappynerd> does haskell use an "actor" model?
21:17:03 <flappynerd> like Scala has Akka
21:17:18 <flappynerd> (iirc scala got that idea from haskell or maybe erlang?)
21:19:29 <Bynbo7> definitely from Erlang
21:19:43 <flappynerd> ah ok
21:19:47 <flappynerd> is that good or bad? :)
21:19:54 <Bynbo7> it's a tool
21:20:14 <flappynerd> right
21:20:26 <Bynbo7> we have some thing similar to the functionality Erlang offers with distributed-process, but it hasn't seem a huge amount of adoption
21:20:57 <lambda-11235> flappynerd: Software transactional memory is more popular, I think.
21:24:01 <exio4> xcmw: I can't seem to get anything useful :/
21:28:57 <EvanR> actor model isnt available as an abstract in haskell because actor model isnt an abstraction
21:29:11 <EvanR> as an abstraction*
21:29:28 <EvanR> that is, its not precisely defined
21:30:12 <EvanR> i noticed haskell really tries hard not to make irreversible choices for you, especially if the choice isnt well defined
21:30:39 <EvanR> for example the lack of a "bog standard number type" like in ruby, js
21:31:44 <EvanR> for concurrency you get threads and an abstract communication primitive MVar, and "do what you will with it"
21:33:52 <flappynerd> does the M in MVar stand for mutex?
21:35:22 <mniip> I doubt as that's not what it does
21:35:28 <EvanR> in the original paper, concurrent haskell, it stod for mutable variable
21:37:04 <EvanR> wait...
21:40:55 <EvanR> MVars and IVars are based on M-structures and I-structures, since I in IVar stands for "immutable", M must stand for mutable, QED ;)
21:41:22 <EvanR> IVars are like MVars which can be written to at most once
21:42:50 <hodapp> huh, this is the first I've heard of an IVar
21:43:13 <exio4> I remember hearing about them in some paper about pure concurrency
21:43:25 <exio4> ... I think
21:44:47 <hodapp> Cloud Haskell did something like that (actor model) but what I found interesting is that Tweag who wrote it in the first place seemed to be more about integrating with existing Apache infrastructure (i.e. Spark via Sparkle)
21:45:50 <hodapp> but https://www.functionalgeekery.com/episode-75-eric-b-merritt/ was also a great listen, and he described an approach that wasn't so much actor model as just microservices written for IaaS platforms that could accomodote various languages
21:46:19 <hodapp> though he seemed to prefer Akka and the like (though maybe that was a different podcast)
21:48:26 <EvanR> turns out you can have a pure function IVar a -> a which "doesnt not violate RT"
21:48:43 <EvanR> which is interesting
21:49:26 <EvanR> yes as far as erlang goes, theres cloud haskell
21:49:46 <flappynerd> EvanR, I don't quite follow, what does that mean?
21:50:03 <flappynerd> erlang and haskell are the same?
21:51:49 <EvanR> no
21:52:05 <EvanR> cloud haskell is a layer on top of concurrent haskell to make it act like erlang
21:52:18 <EvanR> i.e. processes that may or may not be on the other side of the internet
21:52:30 <EvanR> which communicate with messages
21:52:55 <flappynerd> hmm, interesting ok
21:53:05 <flappynerd> distributed stuff is certainly an interest for me
21:53:32 <EvanR> the interesting intersection here is the theoretical reliability
21:53:33 <flappynerd> EvanR, so is this what you were talking about with MVar ? https://en.wikipedia.org/wiki/Concurrent_Haskell
21:53:39 <EvanR> yeah
21:53:48 <flappynerd> ok cool
21:54:09 <flappynerd> EvanR, intersection of which things?
21:54:20 <EvanR> distributed + haskell
21:54:31 <flappynerd> ah
21:54:41 <flappynerd> so, theoretical reliability meaning it's not currently reliable?
21:54:45 <flappynerd> or, no one knows? :)
21:55:24 <EvanR> "its distributed, now what sort of reliability guarantees can we expect"
21:55:40 <EvanR> and getting precise about that
21:56:07 <flappynerd> I see
21:56:25 <flappynerd> do you suppose there are strong guarantees of reliability with distributed haskell programming?
21:57:11 <bollu> hey all
21:57:19 <bollu> I want to learn how to use type level natural
21:57:21 <EvanR> i havent gotten into distributed stuff really
21:57:23 <bollu> do I use GHC's typed nats?
21:57:59 <jle`> bollu: yeah, from GHC.TypeLits
21:58:09 <jle`> but GHC.TypeLits is a very bare-bones API
21:58:13 <bollu> hm
21:58:18 <bollu> so what would you recommend?
21:58:25 <bollu> I want to encode matrix sizes etc
21:58:27 <jle`> if you want to do anything practical, the 'singletons' package offers functions to make them usable
21:58:44 <bollu> I ese
21:58:46 <bollu> thank you
21:58:47 <jle`> i'd recommend singletons, which wraps over the GHC.TypeLits api
21:59:21 <bollu> okay
21:59:40 <bollu> is there a tutorial you would recommend?
22:00:04 <jle`> umm i have a tutorial series i have ongoing, but it's unfinished. (2 parts out of 3)
22:00:37 <jle`> bollu: https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html
22:00:42 <bollu> thank you
22:02:41 <jle`> no problem!  let me know if you have any questions, and also if you find any other tutorials that i can refer peopel too haha.  there's surprisingly very little in this category
22:02:51 <bollu> heh, okay :)
22:10:03 <chetshah> Hello all, I am a haskell beginner, Had following question : 
22:10:43 <chetshah> [] acts as both type constructor and a value constructor ? e.g. [String] is where [] is a type constructor and [4] is case where it is a value constructor right?
22:12:06 <geekosaur> yes
22:12:18 <Rotaerk> similar to data Foo = Foo
22:13:16 <chetshah> Yes got it, Thanks for the example.
22:17:34 <glguy> byorgey: Maybe do tonight's AoC so I can share with you ^_^
22:36:35 <orion> After you've successfully compiled GHC as a cross compiler targeting ARM, what do you do next?
22:37:46 <MarcelineVQ> write a blog post
22:38:37 <geekosaur> heh
22:39:08 <MarcelineVQ> Really though someone could find it useful. if that sort of thing belongs on the haskell wiki then that's a good place too
22:40:25 <MarcelineVQ> Or an update to the ghc trac if you found the info there lacking
22:40:44 <MarcelineVQ> *ghc trac wiki
22:45:13 <exio4> orion: get your nobel prize 
22:51:06 <orion> Oh, I meant to add: I have a stack project I want to compile and then deploy to a Raspberry Pi.
22:51:38 <orion> Is it as simple as installing stack via the host compiler, then use the stack.yaml file to choose the GHC cross-compiler?
23:27:55 <bollu> jle`: quick question, can I do multiplication with typed naturals?
23:28:29 <bollu> jle`: can I have something like mkMat :: (KnownNat r, KnownNat c) => R (r * c) -> Matrix r c?
23:29:44 <jle`> bollu: yes, should be possible
23:30:11 <bollu> jle`: okay. oh, neat, (*) is defined
23:30:12 <jle`> there are some cases where type inference would get mad at you
23:30:16 <bollu> jle`: thanks
23:30:20 <bollu> do tell
23:30:43 <jle`> well, it's not possible to infer the type of the result of `mkMat (xs :: R 12)`
23:30:57 <jle`> so you'd have to have the type inferrable from somewhere else
23:31:16 <bollu> ah
23:31:17 <jle`> alternatively you could `mkMat @3 @4 (xs :: R 12)`
23:31:28 <bollu> right, that's new syntax
23:31:32 <jle`> which is basically treating mkMat as if it took two arguments for 'r' and 'c'
23:31:37 <jle`> mhm, it makes this a little nicer to work with
23:31:42 <bollu> jle`: why is the vector defined as "L" and the matrix defined as "R"?
23:31:52 <bollu> in LinearAlgebra.Static
23:32:00 <bollu> I'm trying to understand the naming convention
23:32:11 <jle`> it's a bit weird and i'm trying to rewrite the APi to be a little more generic
23:32:17 <jle`> but there are two vector types, 'R' and 'C'
23:32:26 <jle`> R is a vectof reals and C is a vector of potentially complex numbers
23:32:44 <bollu> I'm writing the symEngine bindings to haskell. I want to encode the matrix with type level nats
23:32:44 <jle`> L is a matrix of reals and M is a matrix of complex numbers but i don't understand that one, heh
23:32:52 <bollu> ah, I see. thanks :)
23:33:06 <bollu> jle`: I was using, L, U, D etc for lower triangular, upper triangular, diagonal, etc
23:33:13 <jle`> no problem!ah
23:33:14 <bollu> jle`: do you think I should change the names?
23:33:43 <jle`> well, if you write your own matrix types, feel free to use `Vector r a` and `Matrix r c a` 
23:34:01 <bollu> hm, okay.
23:34:02 <jle`> or 'Vector r' and 'Matrix r c' if you don't need them to be polymorphic/generic
23:34:06 <bollu> yeah
23:34:08 <bollu> I don't
23:34:16 <jle`> look into the implementation of the vector-sized package to see a nice way to implement those
23:34:21 <jle`> @hackage vector-sized
23:34:21 <lambdabot> http://hackage.haskell.org/package/vector-sized
23:34:59 <jle`> the library is pretty clean and the code should be in Data.Vector.Generic.Sized
23:35:26 <cocreature> meh vector-sized has broken source links
23:35:49 <jle`> basically you'd treat the dimensions as phantom types, and use 'natVal' to reflect the values back, with the help of ScopedTypeVariables to make it a little more convenient
23:36:24 <jle`> and look at the implementation of 'withSized' for type parameters that get determined at runtime.  like vectors whose lengths you won't know until runtime
23:38:14 <bollu> I see
23:38:16 <bollu> lemme do that
23:38:19 <bollu> ty :)
23:40:10 <jle`>  i used to use 'linear''s sized vector types but i didn't always want to pull in the entirety of lens just for sized vectors
23:40:18 <cocreature> ^ that
23:40:36 <jle`> so i found out about vector-sized and i've been submitting some PR's to get it up to date
23:40:43 <jle`> i'm trying to push it as the de facto sized vector package now
23:41:11 <jle`> i used it for a recent package :)
23:41:20 <cocreature> I think I know which :)
23:41:28 <jle`> ;)
23:41:52 <jle`> i like it because it pretty much mirrors the API of the vector package.  also i wonder if it'd be meaningful to have it for mutable vectors, too, hm.
23:43:05 <cocreature> seems like a reasonable thing to want
23:45:19 <EvanR> seems like size information should theoretically make vectors faster
23:45:25 <EvanR> or take up less space, or something
23:45:31 <c_wraith> how's that?
23:46:25 <cocreature> you can already get the length of a vector at runtime in O(1) (and the constants are small too) so I doubt you’ll gain anything
23:46:34 <jle`> i mean, i guess you can use unsafeIndex safely
23:46:39 <bollu> jle`:  the type "a" and then type "a" in Vector v n a?
23:46:42 <jle`> so you don't need to implement index with bounds checks
23:46:44 <EvanR> if the size is statically known to be a small value at compile time, you could do loop specializations... the count of elements doesnt need to do a lookup, the size doesnt even need to exist in memory...
23:47:08 <jle`> ah so opportunities for rewrite rules
23:47:15 <EvanR> no bounds check is a big one
23:47:30 <jle`> bollu: 'Vector v n a' is a 'v a' w/ length n
23:47:39 <bollu> and "v a" is?
23:47:40 <jle`> where 'v' is an instance of Data.Vector.Generic's Vector typeclass
23:47:44 <bollu> ohh
23:47:44 <bollu> oh
23:47:45 <bollu> hm
23:47:50 <jle`> so like Data.Vector a, Data.Vector.Storable a, etc.
23:47:56 <jle`> um i botched that
23:47:56 <bollu> ah
23:48:04 <jle`> Data.Vector.Vector a, Data.Vector.Storable.Vector a, etc.
23:48:19 <bollu> Vector (Data.Vector.Vector) Symbol 10 is legit?
23:48:39 <jle`> 'Vector Data.Vector.Vector 10 Int
23:48:45 <bollu> I see
23:48:46 <bollu> thanks
23:48:53 <jle`> but you're supposed to use the library by importing a specialized type directly
23:49:04 <bollu> hm
23:49:06 <bollu> like?
23:49:08 <jle`> if you import Data.Vector, you get just 'Vector 10 Int', which uses normal Data.Vector.Vector
23:49:20 <jle`> er, Data.Vector.Sized
23:49:34 <jle`> and if you import Data.Vector.Storable.Sized, you get 'Vector 10 Int', which uses Data.Vector.Storable
23:49:41 <bollu> I see
23:49:43 <EvanR> for 4x1 and 4x4 vectors/matrices, the computer may have specialized instructions to do stuff
23:49:45 <jle`> it shadows the generic type with a specialized type alias
23:49:58 <bollu> vector-sized is not on stackage :(
23:50:08 <jle`> it should be in the nightlies
23:50:25 <jle`> https://www.stackage.org/nightly-2016-12-10/package/vector-sized-0.4.1.0
23:51:04 <EvanR> double camera[4][4]; C had dependent types before all yall!
23:51:12 <bollu> xD
23:51:19 <jle`> haha
23:52:18 <jle`> i know it's a joke but to those following at home, the actual dependently typed version would be to enable 'double camera[n][m]' where n and m are parameters to a function
23:52:44 <jle`> oh wait, that's legal, isn't it?
23:52:59 <EvanR> yes
23:53:01 <jle`> neat
23:53:04 <jle`> all hail C
23:53:25 <EvanR> i cant recall if you can do [N+M]
23:53:27 <bollu> jle`: quick question, how do I get a value out a type level nat?
23:53:31 <EvanR> where N and M are defined constants
23:53:43 <bollu> EvanR: I it does I think, any arithmetic is allowed on constants IIRC?
23:53:45 <jle`> bollu: from the bare GHC.TypeLits interface, 'natVal (Proxy @10)`
23:53:49 <bollu> I see
23:53:58 <jle`> or natVal (Proxy @n) if 'n' is a type parameter
23:54:04 <jle`> (you need ScopedTypeVariables for that to work)
23:54:14 <liste> you can do "void func(int a) {int arr[a]; }" in C99
23:55:07 <jle`> hm, does that only work for inputs passed as parameters?
23:55:16 <EvanR> actual dependently typed version would enable 'double c[f(i)][g(j)]' 
23:55:21 <jle`> ah yeah.
23:55:50 <jle`> i don't think that should be *impossible*, it'd just require an intermediate call stack or something
23:55:51 <bollu> liste: yeah, that would hide the dynamic memory allocation :)
23:56:14 <EvanR> its not dynamic, its automatic!
23:56:19 <EvanR> "thats the beauty of it"
23:56:31 <jle`> because it has to know how much space on the call stack to give to arr before jumping into the function body, right?
23:56:32 <liste> it can chomp the stack pretty fast
23:56:58 <EvanR> the first thing a function does is reserve space on the stack
23:57:08 <EvanR> so it just needs to know how much somehow
23:57:40 <bollu> jle`: how much does the type fangling business affect compile time? :)
23:57:52 <bollu> jle`: and is it possible to encode circuits at the type level? I saw boolean operators
23:58:17 <jle`> for just basic usage of TypeLits, probably not significantly
23:58:34 <EvanR> for sequential logic (cycles in the circuit) you would need a type level fixed point
23:58:43 <bollu> EvanR: we don't have that?
23:58:52 <bollu> EvanR: Fix f = f (Fix f)?
23:59:04 <bollu> Fix f = Fix (f Fix f)?
23:59:04 <cocreature> bollu: iirc vector-sized was created because the original sized vector implementation used in the vulkan bindings took ages to compile. so at least it’s somewhat optimized for compile time
23:59:08 * EvanR pushes bollu's boat away from land
23:59:11 <bollu> xD
23:59:14 <bollu> why? :)
23:59:22 <bollu> cocreature: ahh, I see, neat :)
23:59:34 <bollu> cocreature: oh, haskell has vulkan bindings? :D
23:59:38 <EvanR> because youre under your own power now! good luck ;)
