00:14:29 <haskell673> helloo... i was trying whether a number is square of a number of not without using sqrt and i write something like this I know there are many mistakes can someone fix it http://lpaste.net/350269
00:20:21 <haskell673> anybody there?
00:20:48 <cocreature> haskell673: what error are you seeing?
00:21:30 <cocreature> that looks like a bunch of syntax errors
00:22:11 <haskell673> no error... just can;t solve it i know it has many mistakes
00:22:35 <cocreature> haskell673: 1. "do" notation is for Monads which you don’t use so you shouldn’t use "do" notation
00:22:44 <haskell673> it is... i am new to haskell
00:22:58 <cocreature> haskell673: 2. the syntax for let is "let x = y in e" you don’t have "in" anywhere
00:23:32 <cocreature> haskell673: 3. "if mid*mid > n then end = mid else start = mid" doesn’t do anything, you can’t modify variables in haskell as they are immutable
00:24:13 <haskell673> i see... then how can i write it.. :(
00:24:29 <cocreature> haskell673: give me a minute, I’ll write it up for you and then we can discuss the changes
00:24:44 <haskell673> ok grand... thats perfect
00:25:27 <cocreature> haskell673: what is "end" supposed to be if mid*mid is not bigger than n? you are not assigning it to anything in that case are you?
00:25:28 <haskell673> that way i can know many things... i know little bit of C and I am getting confused with C and haskell
00:27:21 <haskell673> no... but i am using later when my mid is changing
00:27:43 <haskell673> so i thought i should us it early and assign it n
00:27:57 <cocreature> haskell673: so this is what I came up (haven’t tested it) http://lpaste.net/350270
00:28:17 <cocreature> haskell673: but I really recommend you start with some introductory haskell text, you seem to be making a lot of incorrect assumption about how haskell works
00:29:09 <haskell673> let me try to run and see
00:29:16 <cocreature> looks like it loops forever
00:30:55 <moet> is exception-transformers:Control.Monad.Exception just classy base:Control.Exception ?
00:31:17 <cocreature> haskell673: do you really want to check whether a _float_ is square? that’s not really a meaningful concept for a float
00:31:33 <haskell673> corcreature: in GHCi i write is_square 1024 and its not showing anything
00:31:43 <cocreature> haskell673: yeah because your code is incorrect
00:31:57 <cocreature> (and I just fixed haskell errors not logic errors :))
00:32:35 <cocreature> haskell673: repeatWhile never stops
00:32:53 <haskell673> no i only want to check int but when I was finding mid its showing error and after chaging it into float it was not showing error
00:35:15 <EvanR> hmm, the space of floats which have a square root
00:35:38 <EvanR> > 2 = sqrt 2 * sqrt 2
00:35:41 <lambdabot>  <hint>:1:3: error:
00:35:41 <lambdabot>      parse error on input ‘=’
00:35:41 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
00:35:43 <EvanR> > 2 == sqrt 2 * sqrt 2
00:35:46 <lambdabot>  False
00:36:03 <haskell673> so to stop it in repeatWhile, i need to put condition if mid*mid > n && diff > 0.05
00:36:21 <cocreature> diff > 0.05 makes no sense if you are talking about integers
00:36:36 <haskell673> it should be > 1
00:42:21 <cocreature> haskell673: so a working solution would be http://lpaste.net/350272 but I can only repeat, that you should start with some introductory material to clear up some misconceptions
00:44:20 <haskell673> thanks bro... i have done introductory material... thanks alot
00:45:16 <haskell673> but i am getting confused with C alot
00:45:52 <haskell673> but really appreciate your help... I understand much better now
00:51:31 <cocreature> somehow I doubt that
01:30:23 <osa1> is there a GHCi command to see what package exports a module?
01:30:38 <osa1> I wish :info worked on module names too
01:39:54 <quchen_> osa1: Hayoo/Hoogle? I don’t think GHCi has a command for this
01:40:20 <osa1> quchen_: yeah I have a hayoo command line client that I use for this but GHCi would be faster
01:40:40 <osa1> also, can't use hayoo offline
01:40:53 <MarcelineVQ> you can call cli programs from ghci
01:41:03 <osa1> how?
01:41:20 <MarcelineVQ> e.g. https://wiki.haskell.org/Hoogle#GHCi_Integration
01:41:42 <osa1> nice, ty
01:46:07 <Sergio965> ezyang
01:53:54 <tmpz> Hello, I'm tryin to use :set -XBinaryLiterals in ghci but when I do (read "0b000101010") :: Integer I get a parse error
01:54:27 <tmpz> I swear it worked yesterday. Is there anything obvious I'm doing wrong?
01:56:48 <Profpatsch> is there a when, but with  foo :: (a -> Bool) -> m a -> m a
01:56:51 <Ferdirand> it seems logical that -XBinaryLiterals would change the behaviour of ghci's parser, but not the one of the library
01:57:30 <Ferdirand> Profpatsch: and what would the definition be ?
01:57:35 <lyxia> Profpatsch: mfilter?
01:57:46 <tmpz> I swear it worked. 
01:58:27 <tmpz> it has been implemented for a while https://ghc.haskell.org/trac/ghc/ticket/9224
01:59:50 <Profpatsch> foo p ma mb = ma >>= \a -> if p a then mb else pure a
01:59:55 <lyxia> tmpz: does it say anything about read
02:00:26 <Profpatsch> that’s foo :: (a -> Bool) -> m a -> m a -> m a
02:01:54 <lyxia> tmpz: the extension allows you to write 0b000101 :: Integer
02:02:04 <merijn> tmpz: read is not affected by things like BinaryLiterals, that wouldn't even make sense
02:02:50 <merijn> Profpatsch: I don't think that exists, no
02:04:45 <tmpz> @lyxia as far as I can tell it does not mention read. However let i = 0b0001 and then i :: Integer works
02:04:45 <lambdabot> Unknown command, try @list
02:05:17 <lyxia> which is fine
02:05:47 <lyxia> read is just a function in the standard library, not controlled by language extensions
02:06:41 <tmpz> ok so why does read "0x001" work for example? should it not be the same?
02:06:45 <merijn> tmpz: There's a reason it's called Binary*Literals*, it only works on numeric literals
02:06:56 <merijn> tmpz: Because read is coded to follow the language standard
02:07:10 <merijn> tmpz: And the language standard specifies 0x notation
02:07:25 <merijn> tmpz: It does not specify 0b notation, so read was not programmed to use that
02:07:42 <merijn> tmpz: Read isn't magic, it's just another library function
02:08:35 <merijn> I *hope* the current Haskell Prime will extend the report with binary (and octal? I forget if those are already in there), but that's not the case yet
02:09:21 <tmpz> thanks for you explanation. I would have expected that the behavior of read would change too
02:09:27 <Profpatsch> merijn: Okay; it’s trivial, but maybe I’m missing the bigger picture.
02:10:22 <tmpz> octal work
02:11:01 <merijn> tmpz: There's no real sensible way to change the implementation of a typeclass like that and you really don't want to. It would mean the behaviour of libraries could depend on the flags used at compile time...that'd be a testing nightmare
02:11:08 <tmpz> read "0o124177" :: Integer works perfectly 
02:11:31 <tmpz> I was just expecting that with the language extenstion it would work for binary literal too. the 0[bB][0-1]* syntax is supported by most other languages.
02:11:37 <merijn> Profpatsch: Oh, wait, you wanna compare with the monadic value... so two things that'd make that suck less:
02:11:46 <merijn> Profpatsch: 1) monad-loops package 2) LambdaCase
02:12:04 <merijn> "foo >>= \case True -> blah; False -> xyzzy"
02:12:14 <sbrg> tmpz: how should the behavior of 'read' change? read is a function which parses the string. it's not some magical function either. so enabling an extension can't magically change the way to parses its input
02:12:30 <merijn> tmpz: Sadly, in my experience 0b isn't supported by most languages :\
02:14:46 <tmpz> merijn: java, swift, rust ...
02:14:47 <Saizan> i mean in principle the compiler could swap out the implementation of read, but it's just a library function and there's no such special case
02:14:55 <tmpz> C++14
02:15:44 <EvanR> you can use rewrite rules to make it swap out
02:16:03 <EvanR> hmm maybe not because read "whatever" all looks the same
02:16:09 <merijn> That all ignores my earlier point that that would make library behaviour depend on compile time flags which is a nightmare
02:16:46 <tmpz> anyways now I know why it doesn't work. I will roll my own. A little awkward though since it works in other major languanges.
02:16:59 <Ferdirand> do you really need 0b when you have 0x anyway ?
02:17:18 <tmpz> yes, for a parser of another language
02:17:22 <merijn> tmpz: The fundamental assumption of typeclasses is that they are globally unique. Let's assume I have one library that uses Read and was compiled with BinaryLiterals and one that uses Read and compiled without. Now the same function could do different things depending on which library calls it, which I hope you can agree would be a nightmare
02:17:30 <merijn> tmpz: tbh, don't use Read for parsers
02:17:36 <merijn> tmpz: It's performance is shit
02:17:46 <Ferdirand> what merijn said
02:17:52 <merijn> Ferdirand: Yes, I want it a lot when I care about the specific layout of bits
02:18:14 <merijn> Ferdirand: If you do binary protocols/file formats you often care at subbyte level which bits are on/off and binary literals are easier than hex for that
02:18:48 <tmpz> it's more of a toy so I just want to get a proof of concept running. I hope 0[bB][0-1]* syntax will be added to the language definition one day :)
02:19:14 <merijn> tmpz: Even for toys I would recommend using (mega)parsec, more flexible and faster
02:19:25 <merijn> tmpz: And lots of libraries for boilerplate like "parsing numbers" :)
02:19:43 <tmpz> I'm using alex and happy. is this the wrong way?
02:20:08 <Ferdirand> merijn: has someone ported Erlang's bit syntax to a haskell lib already ?
02:20:28 <tmpz> I've looked into other language interpreters written in Haskell and they seem to use Alex & Happy
02:20:48 <tmpz> just following suit
02:21:30 <merijn> tmpz: alex and happy generally perform better, but not enough to care for a toy language. And I know multiple languages implemented using parsec or similar libraries :)
02:21:54 <merijn> alex/happy is more based on the traditional flex/yacc apporach. Which I wouldn't call wrong, but which I would, generally, call painful :p
02:22:54 <tmpz> pretty painful considering I have no clue what I am doing... seems to work however.
02:24:54 <sbrg> eh it's not too bad IMO. 
02:25:06 <sbrg> it's better than using the classic yacc/lex combo 
02:25:15 <merijn> god...
02:25:47 <merijn> I need to teach lex/yacc again in February when compiler construction starts. I can already hear the miserable sighs of reduce/reduce and shift/reduce conflicts :)
02:25:53 <sbrg> haha yeah. 
02:26:44 <merijn> They're right too
02:27:26 <merijn> If we'd use something like ANTLR or another GLR parser generator they could just write a trivial grammar :)
02:28:32 <sbrg> I'm currently in the process of rewriting the compiler I wrote in C for my BSc in haskell, and it's such a difference, so even though happy/alex aren't exactly a pleasure to work with(and the documentation, particularly for alex, is rather bad), it still feels like a whole new world heh
02:32:27 <haskell480> is there any in built function to make string in to lower case?
02:32:46 <merijn> haskell480: "map toLower" if you want the hacky version
02:33:05 <merijn> Data.Text.toLower if you want slightly less hacky
02:33:36 <merijn> And Data.Text.ICU if you really care
02:34:16 <merijn> tmpz: I assume you know the rough basics of, say, language grammar and BNF?
02:34:46 <haskell480> not really... new to language
02:35:01 <merijn> haskell480: That last one wasn't for you :)
02:35:13 <tmpz> yes. Unfortunately it was 10 years ago or more I last implemented anything language related
02:35:13 <haskell480> lol... sorry
02:35:54 <haskell480> I typed in GHCi Data.Text.ICU "HEllo"
02:36:14 <tmpz> so, I am just wildly guessing what should be a token in the lexer by reading the language's BNF
02:36:21 <haskell480> and not work
02:36:23 <merijn> tmpz: Parser combinator libraries (like megaparsec, etc.) are basically libraries for writing recursive descent parsers. To the point where it becomes trivial to write one. The main downside is that you need to think ahead abit to avoid bad performance if you backtrack a lot
02:37:15 <merijn> tmpz: alex/happy are parser generators which will generate an LALR parser (LALR(1) most likely), which means they'll almost always perform well, but you can spend a lot of time finnicking with getting the parser specification right
02:37:22 <tmpz> I have used parsec before but I thought it would be quicker with Alex&Happy I have (almost) Integer literals working 
02:37:23 <merijn> > map toLower "HEllo"
02:37:25 <lambdabot>  "hello"
02:37:46 <merijn> tmpz: Well, it depends on the complexity of you parser, I suppose :)
02:37:56 <cocreature> who doesn’t like manually left-factoring grammars
02:38:05 <merijn> > Data.Text.toLower $ text "HEllo"
02:38:06 <tmpz> here: https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/zzSummaryOfTheGrammar.html
02:38:08 <lambdabot>  error:
02:38:08 <lambdabot>      Not in scope: ‘Data.Text.toLower’
02:38:08 <lambdabot>      Perhaps you meant ‘Data.Char.toLower’ (imported from Data.Char)
02:38:13 <merijn> cocreature: Oh! Oh! oh! I know this one!
02:38:20 <merijn> cocreature: Me and all my future students? :D
02:38:37 <cocreature> tmpz: https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Expr.html can take some of the pain out of parsec
02:38:44 <cocreature> merijn: :)
02:39:22 <merijn> tmpz: For something like Swift I would probably pick a parser combinator library of struggling with parser generators :)
02:42:04 <tmpz> for now I'm trying with what I have. First goal is to get all literals to parse correctly (don't know if it's a good goal or not but looked feasible)
02:42:51 <merijn> tmpz: Is there a specific reason you're parsing Swift? Or you just want a toy language that's Swift-like?
02:43:41 <tmpz> so far I have this: http://imgur.com/a/kDMnR
02:43:42 <tmpz> I work in swift 8-10 hours a day and I'm not happy with it
02:44:53 <merijn> I have a simplistic toy language using parser combinators you could peak at for inspiration, but be warned that the type checker is currently buggy as hell as I can't find time to get around to fixing it :p
02:45:25 <tmpz> the compiler is very very slow and there are no proper meta tools
02:45:25 <tmpz> so I though I would give it shot at parsing the language fisrt and see where I can go from there.
02:45:42 <tmpz> my goals are very limited atm. So type checking is not even on the radar :D
02:45:49 <merijn> tmpz: https://github.com/merijn/lambda-except the AST is in AST.hs and for parsing the relevant stuff is in Lexer.hs and Parser.hs (although a bunch is a bit messy)
02:46:18 <tmpz> thanks I will take a look
02:46:45 <merijn> tmpz: Additionally, if you care about programming languages and type checking is something you might care about in the future, I would strongly recommend reading TaPL, which is the de facto introduction to type theory and checking, including working implementations of the algorithms described
02:46:50 <merijn> @where tapl
02:46:51 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
02:47:17 <merijn> The examples are ocaml, but basic enough that anyone writing haskell and/or swift should have no issue reading it without knowing ocaml :p
02:47:45 <tmpz> ok thanks for the pointer!
02:48:46 <merijn> tmpz: It starts from untyped lambda calculus and covers basically everything you could ever want to implement standard haskell and much more (like java inheritance, subtyping, etc.)
03:14:00 <lpaste> ottanta pasted “No title” at http://lpaste.net/9170271247345385472
03:14:16 <ottanta> ^ I do not understand the ch4 code 
03:15:07 <ottanta> like which is to be expected, they're using it to introduce concepts, I just have no idea why I get a syntax error on args
03:15:19 <lyxia> indent past the beginning of the function name
03:15:38 <ottanta> past mainWith?
03:16:22 <lyxia> yes
03:17:03 <ottanta> kk
03:17:14 <merijn> ottanta: I would strongly recommend reading this: https://en.wikibooks.org/wiki/Haskell/Indentation
03:17:35 <merijn> ottanta: Which should once and for all explain all curious errors about indentation and how to fix them :)
03:17:50 <ottanta> yeah there was a part about indentation before I just, apparently, didn't get it 
03:18:01 <ottanta> so I think I'll re-read the part of RWH that talks about it as well as the article you linked
03:18:15 <merijn> ottanta: Well, the problem is that SUPERFICIALLY it looks very similar to, say, python
03:18:18 <ottanta> I just figured it was like python where indentation levels just had to be consistent but I think that was wrong
03:18:20 <ottanta> yeah
03:18:24 <merijn> ottanta: But in reality it's a lot more flexible than that
03:18:26 <ottanta> that's exactly where Iwent wrong
03:18:32 <ottanta> it's more flexible than python?
03:18:48 <merijn> ottanta: Yes
03:18:59 <ottanta> oh also I have a typo in that code
03:19:02 <merijn> The rules are rather simple, but if you don't know them, they can trip you up a lot :)
03:19:20 <ottanta> yeah I guess I'll have to familiarize myself with them
03:19:34 <ottanta> the thing is I feel like I learn the language better when having to use it rather than when like, studying its parts
03:19:41 <ottanta> but the help is appreciated
03:20:57 <merijn> It's only about a page or so and has lots of examples :)
03:21:35 <merijn> And literally like 4 rules with no real special cases :)
03:22:13 <ottanta> oo
03:22:17 <ottanta> yeah i was just looking at it
03:23:30 <merijn> ottanta: oh, there's one thing missing there in the rules: "if you see something indented more and NOT following a layout keyword, it's a line continuation"
03:23:47 <Cale> ottanta: The general rule is that 'let', 'where', 'do', and 'of' are the layout keywords, and the first non-whitespace character following them sets the indentation level for a block
03:24:04 <merijn> ottanta: So, unlike python you don't have to write \ at the end of a line to continue it, just make sure the start is indented more than the start of the original line and it's automatically continued
03:24:10 <ottanta> that's kinda confusing for me 
03:24:20 <Cale> Lines which then start in a shallower column than that close the block
03:24:23 <ottanta> what Cale said not what merijn said
03:24:38 <ottanta> yeah merijn I kinda figured from code that everything is like a continuation
03:24:43 <merijn> ottanta: Looking at the examples on the page should clarify what he said :)
03:24:58 <Cale> Lines which start in the same column are new things in the same block, and lines starting in a deeper column are the continuation of a previous line
03:25:17 <Cale> So here, when you write 'where', the first non-whitespace character after that is the m in mainWith
03:25:37 <Cale> and things need to line up with that m to be declarations in the 'where' block
03:25:59 <merijn> ottanta: Incidentally, I would also strongly recommend avoiding do notation at first as a beginner and understand how the syntactic sugar for it works (only switching to do notation once you're confident you can write the same code without it) https://en.wikibooks.org/wiki/Haskell/do_notation
03:26:07 <Cale> and the lines need to be deeper than that m if they're going to be a continuation of the definition of mainWith
03:26:44 <merijn> ottanta: do notation is wonderfully readable, but in my experience beginners imagine too much magic in it, rather than understanding that it simply does something simple and deterministic :)
03:27:13 <ottanta> yeah but then, confusingly, the myFunction thing like, is part of the original where 
03:27:27 <ottanta> so it has to be in the same level of indentation as the mainWith
03:27:38 <jophish> What's that package which uses oeis to continue a sequence?
03:27:38 <Cale> ottanta: yeah, so the m in myFunction should line up with the m in mainWith, that's right.
03:28:46 <Cale> ottanta: Because they're siblings in that block, so they should start in the same column
03:29:03 <lyxia> @hackage oeis
03:29:04 <lambdabot> http://hackage.haskell.org/package/oeis
03:30:02 <Cale> It's basically: if a line is part of something else, it should start in a deeper column, and if it's the sibling of that other thing, it should start in the same column
03:31:07 <jophish> lyxia: Hmm, that's not how I remember it, but perhaps I've imagined a different interface :)
03:31:19 <jophish> oh, SequenceData is [Integer]
03:31:23 <Cale> merijn: I'm always a bit torn on that -- sometimes there's a bit of confusion around the meaning of (>>=) which can be alleviated by looking at things in do-notation too.
03:31:31 <Cale> merijn: It's probably good to see both at once.
03:31:47 <haskell169> hiii can someone tell me why there is a problem.... http://lpaste.net/350276..... when i multiple by 100 its giving me result but when i multiple bt 0.1 its giving me error
03:31:49 <Mortomes|Work> Return is particularly toxic if you're learning haskell while coming from a language like java
03:32:25 <Cale> Yeah, you have to learn that return is a function and means something a bit different than the keyword return means in most imperative languages
03:32:33 <Cale> I don't think it's a bad name given what it does though.
03:32:54 <Cale> (return v is always an action which does nothing except to, well, return v)
03:33:29 <Cale> It just returns it *in place* though, not to some wider scope.
03:34:33 <quchen_> haskell169: length gives you an Int, and you cannot multiply an Int with a fraction (0.1). You can use »fromIntegral« to convert from Int to Float (which you can multiply with fractional values).
03:36:33 <haskell169> quchen : how can i fix it... i use formIntegral and still showing error
03:37:15 <quchen_> That’s a bit hard to tell without knowing the (new) code and the error.
03:38:34 <Mortomes|Work> Maybe because you used formIntegral instead of fromIntegral >.>
03:44:05 <haskell169> like this? http://lpaste.net/350276
03:44:52 <quchen_> fromIntegral is a conversion function, not a type. You put it in the type signature. Float was fine there :-)
03:45:08 <quchen_> You want to use fromIntegral on the result of the »length« call
03:45:14 <haskell169> lolcsorry i new to this
03:47:21 <haskell169> quchen: I used cant fingure out where exactly... can u tell me
03:48:52 <quchen_> c = 0.1 * (fromIntegral . length . filter (==x)) …
03:49:21 <quchen_> lenth gives you an Int, so »fromIntegral . length« gives you a Float in your example.
03:49:27 <haskell169> oh pity i was not aware i have to use dot also
03:49:37 <haskell169> thanks let me try
03:49:59 <quchen_> Without the dot, you have »fromIntegral length«, which tries to convert the »length« function to a number. 
03:50:46 <haskell169> i understand now but now it showing not in scope error
03:51:11 <Mortomes|Work> (Playing around with :t  in ghci can help a lot with figuring this stuff out)
03:51:40 <haskell169> sorry it works now
03:59:32 <haskell636> hiiii http://lpaste.net/350278 can somebody tell me why there is error
04:00:19 <quchen_> Read the error message.
04:00:34 <oherrala> haskell636: are you familiar with lookup function?
04:00:37 <oherrala> :t lookup
04:00:39 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
04:02:59 <Cale> haskell636: Did you figure it out? There's a 'loan' there where presumably you intended 'loans'
04:03:51 <Cale> (which is pretty much what the error message says)
04:12:29 <vozz> How would I go about writing something like 'tail -f' in conduit? I want a conduit that opens a file, skips all the current lines in the file, keeps watching the file without closing it, and streams any new lines that are added. I think https://gist.github.com/snoyberg/a422d558e9142e37d2aa does something similar, but I don't quite understand it and it's using Sinks and Sources rather than Conduits..
04:16:33 <sbrg> vozz: those are just specializations of the more general Conduit. A Source is something that produces values downstream but doesn't accept any from upstream. a sink is the opposite.
04:16:41 <sbrg> this is all in the documentation for conduit
04:17:54 <vozz> I thought Producers and Consumers did that, ans Sinks and Sources are the old version?
04:20:39 <sbrg> A Producer is more general than a Source. Source takes no input values, but produces something. Producer takes any input values and produces something.
04:21:04 <sbrg> the converse applies to Consumer, basically
04:21:12 <vozz> hm, okay
04:21:47 <kuribas> is the mtl library a superset of the transformer library?
04:24:57 <kuribas> StateT in mtl is the same as StateT in transformers, right?
04:24:59 <sbrg> vozz: just to make it clear: type Source m o = ConduitM () o m (), type Sink i = ConduitM i Void, type Producer m o = forall i. ConduitM i o m (), type Consumer i m r = forall o. ConduitM i o m r. 
04:25:52 <sbrg> where we have ConduitM input output monad result
04:36:40 <jaspervdj> kuribas: They are different (but compatible) types
04:37:17 <kuribas> jaspervdj: why does mtl import transformers then?
04:37:21 <ertes> vozz: i'm not sure i got this right (i have little experience with conduit), but doesn't this code busy-loop while waiting for new data?  if yes, that would be a terrible way to do it
04:38:30 <ertes> vozz: an older version of 'tail' used polling, but it had a one-second delay between each poll…  newer versions use notifications (inotify on linux)
04:38:32 <vozz> I think so, I guess you'd want it to be watching the file with System.IO
04:38:45 <jaspervdj> kuribas: ah, you're right, seems like they actually share types since mtl-2.0
04:38:53 <ertes> vozz: i suggest using the fsnotify (portable) or hinotify (linux) package
04:39:07 <vozz> fsnotify, thats the one
04:40:34 <ertes> vozz: that way you can also properly respond to the file disappearing and reappearing the way 'tail' does
04:40:39 <ertes> (think logrotate)
04:40:41 <kuribas> jaspervdj: so mtl is transformers + typeclasses, right?
04:41:28 <ertes> it's still unsafe, but way safer than polling =)
04:41:46 <jaspervdj> kuribas: Yes
04:44:37 <kuribas> ok, thanks
05:33:42 <vozz> For anyone interested, I figured out the tail stream! http://lpaste.net/350280 
05:34:03 <vozz> Could probably do with neatening up
05:42:02 <kuribas> is "newtype MyMonadT m = MyMonadT (StateT MyState (ExceptT MyErr m) a)" less efficient than "newtype MyMonadT m = MyMonadT (s -> m (Either MyError (a, s)))"?
05:42:26 <merijn> kuribas: "It Depends (TM)"
05:42:40 <lordcirth> vozz, so you open the file, SkipContents in a loop till you hit the end, then wait on sourceFileChanges events?
05:42:44 <kuribas> merijn: on?
05:43:08 <vozz> yep!
05:43:28 <merijn> kuribas: How much things improve due to GHC being (un)able to inline, etc. how much of the code uses it, etc.
05:43:37 <lordcirth> Nice.  Being far better at Bash than Haskell, I too would have piped tail :P
05:43:58 <merijn> vozz: FYI you can make that a lot simpler
05:44:10 <kuribas> merijn: and now (using-ghc 8.0)?
05:44:16 <merijn> oh, wait, that has conduits code
05:44:26 <merijn> kuribas: Same
05:44:47 <merijn> vozz: Does conduit have a way to turn a Handle into a source? (I'm assuming yes)
05:45:13 <kuribas> merijn: so writing my own stack is just boilerplate, with no gain?
05:45:17 <vozz> I think sourceIOHandle does that
05:45:36 <merijn> vozz: Because you could simplify things a lot by using hSeek
05:45:39 <merijn> :t hSeek
05:45:39 <kuribas> merijn: I was going be this? https://wiki.haskell.org/Performance/Monads
05:45:41 <lambdabot> error: Variable not in scope: hSeek
05:45:51 <merijn> hSeek :: Handle -> SeekMode -> Integer -> IO ()
05:45:56 <vozz> ah, so I could seek to the end?
05:46:03 <merijn> You can just do "hSeek handle SeekFromEnd 0"
05:46:17 <merijn> And then turn the handle into a source
05:46:24 <merijn> And then you don't need any logic at all :)
05:47:04 <vozz> Haha that would be a lot simpler
05:47:12 <merijn> kuribas: The point is, transformer stacks have overhead, but whether that overhead *matters* depends on your code
05:47:18 <vozz> The source would close once it hits the end though
05:47:26 <merijn> kuribas: I mean, do you have a nanosecond latency innner loop or some IO boilerplate...
05:48:00 <merijn> vozz: ok, so you'd need a little more logic, but at least you can simplify the skipping part :)
05:48:41 <kuribas> merijn: why doesn't ghc specialize?
05:49:02 <kuribas> merijn: or inline "ask, get, etc..."
05:49:39 <vozz> yep, just changed that, a lot nicer!
05:49:56 <merijn> kuribas: Unpacking/specialising arbitrary datatypes is a lot of work/complex and not necessarily that worthwhile for overall performance
05:50:11 <merijn> vozz: I'm guessing "yield" is to sort of "unschedule" the thread doing the read if there's nothing?
05:50:38 <vozz> yield means to produce a value in the stream
05:50:49 <vozz> await means to wait for a value from upstream
05:50:51 <merijn> ah, right I'm thinking of a different yield :)
05:50:57 <merijn> :t Control.Concurrent.yield
05:50:59 <lambdabot> IO ()
05:51:02 <vozz> :)
05:54:35 <vozz> If instead of using linesUnboundedC I wanted to chunk the data by matching outer square brackets, does anyone know of a conduit function that would make that easy?
05:55:42 <vozz> so "[[[","]]][]" would turn into "[[[]]]" "[]"
05:56:02 <merijn> I'm more of a pipes person, so not really :)
05:56:07 <kuribas> merijn: I should benchmark it...
05:56:22 <merijn> kuribas: Yes
05:56:31 <ertes> vozz: are you using fsnotify there?
05:56:35 <ertes> i can't tell from the snippet
05:56:44 <merijn> kuribas: What exactly are you doing with the transformer?
05:56:54 <vozz> yes, I'm using fsnotify-conduit which is that events stream
05:57:13 <ertes> great…  then i like it =)
05:57:16 <vozz> :)
05:57:30 <kuribas> merijn: The one from mfsolve is a state and error monad, for solving linear equations.
05:58:11 <kuribas> merijn: the one from hmetafont read, state and error, for solving equations, drawing on a canvas, reading parameters, etc...
05:58:36 <merijn> Basically, I would assume optimising a transformer stack is premature optimisation until benchmarks show it's a bottle neck
05:59:03 <kuribas> merijn: yeah, true
05:59:08 <ertes> vozz: of course in my opinion the fact that one ever needs something like `tail -F` is a symptom of an epidemic in the unix world:  syslogd and similar approaches
05:59:50 <merijn> ertes: How so?
05:59:50 <vozz> ertes: What would be the alternative?
06:00:20 <ertes> vozz: receiving log lines directly from the logger of the specific process(es)
06:01:26 <merijn> ertes: I mostly use tail -F to monitor output of longer running computations, tbh
06:01:44 <merijn> ertes: So it certainly has plenty of use beyond monitoring logs
06:01:51 <ertes> merijn: because i believe that logging chains are a fundamentally better solution in that they are both more robust and more flexible (supporting log-catching without watching file changes)
06:01:53 <merijn> I actually don't think I've used tail for that
06:02:05 <merijn> (that = log checking)
06:02:20 <vozz> hmm, this time it's my own doing... I've got some existing java jar that I've used aspectJ to recompile so it logs decoded network messages to file, figured it'd be the simplest way to get that information out
06:02:40 <ertes> merijn: well, i would probably look for ways to just print stdout/stderr =)
06:03:06 <merijn> ertes: I usually want to store results in a file for later processing
06:03:19 <merijn> ertes: And building dual output into my code for no real reason is a hassle
06:03:19 <ertes> merijn: tee =)
06:03:34 <ertes> it's not the program's responsibility to do that anyway
06:04:01 <merijn> ertes: The main usecase for me is batch processes, so defaulting to stdout instead of a file is really undesirable, especially since the output name is usually computed from parameters
06:04:05 <tdammers> the challenge with logging is to make it not slow down the producer (so no back pressure), but also not to drop anything
06:04:15 <merijn> ertes: So then I'd just be moving code from my program into bash
06:06:28 <ertes> merijn: i see what you mean
06:07:53 <maerwald> Want to write a parser library that allows me to construct sub-languages of SQL, so performance is (imo) not the primary concern, but correctness and error messages. I guess attoparsec is not the best fit there?
06:08:26 <merijn> attoparsec basically has no error messages, so correct
06:08:30 <ertes> maerwald: what features do you want from the parser?  if speed is not primary, what about good diagnostics on error?  e.g. trifecta
06:08:45 <merijn> maerwald: trifecta has pretty decent errors, I heard megaparsec is also better than parsec
06:09:07 <maerwald> megaparsec is a transformer that would allow me to stuff in state afair, which I find nice
06:09:16 <maerwald> but not sure I want that (complexity)
06:09:37 <ertes> maerwald: if you need state, you should probably use StateT on top of the parser
06:09:44 <merijn> You can wrap State around attoparsec/trifecta too
06:09:44 <sm> megaparsec++, maerwald 
06:10:06 <merijn> maerwald: See, for example: https://github.com/merijn/lambda-except/blob/master/Lexer.hs#L36-L40
06:11:11 <ertes> megaparsec is "parsec done right", but it still shares a number of short-comings, including internal complexity for little actual gain (it doesn't have *good* error reporting, just more correct than parsec; it doesn't have incremental input)
06:11:17 <ertes> therefore i generally recommend trifecta
06:11:49 <merijn> ertes: Yeah, but trifecta is a bit trickier to wrap your head around :)
06:11:49 <maerwald> mh, trifecta depends on lens
06:11:55 <merijn> Does it?
06:11:57 <maerwald> so that's out of the way
06:12:15 <ertes> just never look at the definition of 'Parser', if you're not used to church encoding =)
06:12:32 <maerwald> I don't like libraries with overly tricky types
06:12:48 <merijn> maerwald: tbh trifecta doesn't have tricky types
06:12:54 <ertes> it's not tricky, it's just differently encoded
06:12:57 <merijn> maerwald: it just exposes lenses for some stuff
06:12:59 <ertes> similar to FreeT vs. FT
06:13:25 <maerwald> sm: how are error messages in megaparsec?
06:14:30 <ertes> trifecta could probably be patched not to depend on lens without giving up the functionality
06:18:11 <cocreature> maerwald: slightly better than parsec in my experience, but worse than trifecta
06:19:28 <sm> maerwald: very good, at least it provides everything you need to produce excellent error messages
06:19:55 <sm> aside from that, the usability and maintenance of the project are best in class
06:20:02 <AndreasK> Is there a library implementing a binary (or other tree) efficiently? I assume Data.Tree has a decent amount of overhead given it stores the branches in a list compared to an ADT implementation
06:20:30 <cocreature> yep, docs & maintenance of megaparsec are really good
06:20:32 <sm> I admit I haven't used trifecta, I haven't heard a trifecta user say otherwise
06:20:32 <Gurkenglas> Is there full text search on hackage package sources?
06:20:35 <ertes> AndreasK: same library, different module:  Data.Map.{Lazy|Strict}
06:21:02 <ertes> AndreasK: and Data.Set
06:21:42 <AndreasK> ertes: Maybe I'm slow today but how would I encode a tree as Map/Set? Or do you mean that as an example for implementing trees?
06:22:03 <ertes> AndreasK: what's the use case?
06:22:29 <AndreasK> Basically state space search
06:22:41 <ertes> AndreasK: ah, so you need the actual tree
06:23:00 <ertes> AndreasK: and all choices are binary?
06:23:02 <cocreature> AndreasK: what do you expect the library to do? the adt for a binary tree is pretty short :)
06:23:18 <quchen_> maerwald: Trifecta is almost entirely undocumented, which makes it fairly hard to get used to it. That said, it’s not a complicated library at all, and once you understand that, it’s pretty cool! I implemented my STGi parser in Trifecta, for example. merijn’s lambda-except project was what I used for the first steps.
06:23:26 <Gurkenglas> And is there a simple way like "curl -sSL https://get.haskellstack.org/ | sh" to install stack without root privileges?
06:23:46 <merijn> quchen_: Glad that my 2 week struggle to figure out the simple idea wasn't for naught :)
06:23:49 <sm> Gurkenglas: why does that require root ?
06:24:03 <quchen_> merijn: You’ve written the best documentation for Trifecta so far, yes.
06:24:03 <Cale> AndreasK: I don't think I've ever actually used Data.Tree for anything. Typically, you just make a recursive data type for whatever your particular use case is.
06:24:24 <merijn> quchen_: Which is ironic, considering it's not documentation and has like 1 line of non-source code ;)
06:24:31 <Gurkenglas> sm, dunno: http://lpaste.net/413403847919140864
06:24:37 <quchen_> maerwald: Look at the source here, it’s fairly similar to what you’d write in Parsec. https://github.com/quchen/stgi/blob/master/src/Stg/Parser/Parser.hs
06:24:44 <sm> 7919140864                                                                                                                                                  
06:24:45 <quchen_> merijn: I said best, not good ;-P
06:24:58 <cocreature> at some point I was planning to contribute docs to trifecta, then I got lazy …
06:25:02 <AndreasK> The functionality in Data.Tree would be good enough, but I'm about optimizing laziness and i've reimplemented trees a few times so far and it does get boring :D
06:25:24 <Cale> Well, what operations do you care about?
06:25:27 <sm> Gurkenglas, read the script, do whatever its doing by hand
06:25:30 <AndreasK> So I guess I will make it work with Data.Tree and just swap out the implementation later.
06:25:38 <quchen_> cocreature: I did the same for wl-pprint. Cost me quite some time, but now I really understand how it works ;-)
06:26:04 <cocreature> quchen_: heh, I found wl-pprint (or rather wl-pprint-text) fairly easy to understand
06:26:12 <maerwald> quchen_: well, if it's undocumented, then I definitely won't use it
06:26:30 <AndreasK> cale: Constructing it lazily and removing branches that fail a filter
06:26:33 <quchen_> maerwald: The payoff is awesome user experience.
06:26:48 <ertes> AndreasK: do you even need the tree type itself?  binary search doesn't necessarily require an explicit tree type
06:26:53 <maerwald> I care about simplicity
06:26:53 <Cale> AndreasK: and you only need binary tree nodes?
06:27:07 <merijn> maerwald: No one said it was complex or hard
06:27:14 <Gurkenglas> sm, can I see where it crashed so I can do the next part, or do I do binary search by pasting halves of that script on I guess lpaste and supplying raw links to that curl thing and seeing where it fails, and is there a problem with doing things that it already did another time?
06:27:16 <quchen_> cocreature: Turns out it’s not that hard, no, but remembering all the different width-sensitive group-sensitive functions and what not took me a bit
06:27:22 <maerwald> merijn: if it's undocumented, then it is hard
06:27:26 <merijn> But anyway, you seem to have your mind made up without looking, so
06:27:31 <maerwald> yes
06:27:37 <merijn> So I don't understand why you're arguing
06:27:50 <merijn> You seem to want recommendations, but then won't consider them :)
06:27:56 <maerwald> huh?
06:28:03 <cocreature> quchen_: fair point, so far I’ve got away with a relatively small subset of the functions it provides
06:28:20 <ertes> megaparsec is fine, if you can live with non-incremental input and simplistic error messages =)
06:28:32 <Cale> AndreasK: with labelled branches and unlabelled leaves?
06:28:40 <maerwald> merijn: I have considered it and given the comments decided that I won't use it. I don't understand what you are saying. I must have 50+ hours of experience on them before I can make a decision?
06:29:31 <grazie> the `:.` symbol on line 36 of this haskell course file https://gist.github.com/5c8d1e1cd11abd1816feee3ac0b1c0f3 ... my question is...
06:29:31 <quchen_> You should see the error messages. :-þ
06:29:57 <grazie> does line 36 define that function `:.`? or is it imported from one of the imports in the module? 
06:29:58 <sm> you're talking about the default built-in  error messages, right ?
06:30:02 <AndreasK> ertes Cale: Yeah it's only binary, and I essentially would the tree itself only for a easy way to get a solution out of it. I could just use backtracking with recursion I guess but using a tree seems like a decent abstraction, also useful if I ever decide i want to enumerate multiple solutions.
06:30:09 <c_wraith> grazie: it's a definition
06:30:10 <sm> I'm sure a megaparsec app can produce the same error messages
06:30:23 <Gurkenglas> sm, does it have to be a place in the script where it says "sudo" on https://get.haskellstack.org/ or are those explicit places already well-guarded about needing root when I don't have it?
06:30:27 <ertes> the main advantage of trifecta is that it can handle very complicated grammars in a modular way, and that it has very good diagnostics, including contextual information, to nail down errors
06:30:27 <c_wraith> grazie: infix operators starting with : are data constructors
06:30:34 <ertes> so it's really made for *human* languages
06:30:38 <grazie> c_wraith: that's what I thought by doing :i :. in ghci but...
06:30:39 <c_wraith> grazie: just like alphanumeric names starting with capital letters.
06:30:42 <merijn> grazie: line 36 defines it, yes
06:31:11 <merijn> grazie: : is (arbitrarily decided) the uppercase symbol character (since data constructors must start with uppercase)
06:31:25 <ertes> AndreasK: would something like LogicT work?
06:31:26 <quchen_> sm: Maybe, but it takes a considerable amount of effort to add them, every time you write a parser. Trifecta needs some effort to get into it, and then you get everything for free.
06:31:28 <grazie> it doesn't take much to define a function.. is it basically saying that `:.` is the same as `:`
06:31:43 <c_wraith> grazie: it's stronger than a function - it's a data constructor
06:31:55 <grazie> c_wraith: why not just use `:`?
06:31:59 <ertes> AndreasK: https://hackage.haskell.org/package/logict
06:32:03 <merijn> grazie: Because : already exists? :)
06:32:16 <merijn> grazie: You are not allowed to use the : constructor because it's reserved for lists
06:32:22 <sm> for me 99% of the time life is too short for puzzling out yet another undocumented libe, no matter how reputedly great it is
06:32:23 <ertes> AndreasK: read the package description as: "a monad for searches" =)
06:32:24 <grazie> merijn: but what's the need to define a new data constructor... ok, now I understand
06:32:29 <merijn> grazie: Same way you're not allowed to name a variable "case"
06:32:30 <sm> sounds like that's the case for maerwald too
06:32:37 <grazie> it's reserved to use with lists
06:32:43 <sm> and I wonder how many of us here have used both megaparsec and trifecta, I think 0
06:32:46 <merijn> sm: But I puzzled it out for you and implemented an example ;)
06:32:47 <AndreasK> ertes: I don't know logicT (yet) but since it's just for a toy project it's all about they way to get there, so will check it out
06:33:07 <merijn> sm: I haven't used megaparsec, but I used parsec and attoparsec, so I think I have a good feel for what megaparsec is like
06:33:28 <grazie> c_wraith: is that defined somewhere in a spec, or just convention? re: " infix operators starting with : are data constructors"
06:33:36 <sm> megaparsec's support for error messages is a lot more powerful than parsec's
06:33:40 <merijn> grazie: It's defined in the spec
06:33:41 <quchen_> megaparsec is a modernized Parsec, nothing more, nothing less.
06:33:43 <c_wraith> grazie: It must be in the spec somewhere. :)
06:33:52 <merijn> c_wraith: It is in the grammar :)
06:33:56 <quchen_> Megaparsec does not alias <|> for example. :-)
06:34:30 <merijn> grazie: https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-140002
06:34:42 <merijn> grazie: Section 2.4, the grammar for conid
06:34:49 <merijn> eh
06:34:51 <merijn> consym, I mean
06:35:00 <Will1> Hey, can someone give a noob some guidance on errors: if writing a command line tool, is it still considered evil to use `error` to throw an exception and halt execution?  What are the downsides?
06:35:04 <quchen_> cocreature: Speaking of aliasing, being continually annoyed by wl-pprint’s <$> and <> operators made me start rewriting it haha
06:35:09 <grazie> thank you for your help... one other quick question, might be more difficult. I loaded hakyll into ghci, the only thing it couldn't find was "Paths_hakyll" interface, but that doesn't appear to be something I can install
06:35:26 <merijn> grazie: cabal will auto generate it
06:35:39 <merijn> grazie: When you run "cabal build" or cabal install
06:35:51 <merijn> grazie: I'm assuming you're loading it into ghci without having installed it :)
06:36:00 <grazie> merijn: ok, I was able to create a test blog, so I guess that worked, but can't load it into ghci
06:36:13 <merijn> grazie: Did you install in a sandbox or something?
06:36:29 <merijn> grazie: Also are you loading the file or importing the library (the latter should use the installed version)
06:36:31 <grazie> merijn: i'll have to look again, thank you for the tip
06:36:37 <ertes> sm: i have used all of them…  if it weren't for trifecta for human languages i would most likely use megaparsec…  maerwald's reasoning as to why they won't use trifecta is understandable given the superficial consideration, but also odd in the sense that most of the API is actually in terms of the 'parsers' library, which is well documented =)
06:37:11 <ertes> and the usual base classes of course
06:37:18 <quchen_> Will1: »error« throws an IO-catchable exception out of anything, including pure code. I think it is *always* a bug in a library if »error« is called, just like every GHC panic is a bug in GHC.
06:38:06 <sm> fair enough, ertes. I'll give trifecta another look when it gets a manual and changelog :)
06:38:11 <Will1> quchen_: OK, thanks - what's the recommendation - should I use throwIO when in IO, and Either SomeException a in pure code?
06:38:18 <qmm> does the haskell runtime use a cooperative scheduling algorithm or is it built preemptively? are certain parts cooperative while others are preemptive? does that even make sense? :)
06:38:32 <grazie> merijn: oh, i know, I think I uninstalled hakyll but left the files on my system to play with in ghci
06:38:46 <merijn> sm: I recommend quickly skimming my trifecta code and see if that enlightens you
06:38:50 <grazie> merijn: so you're explanation makes sense
06:39:04 <merijn> sm: https://github.com/merijn/lambda-except/blob/master/Lexer.hs
06:39:20 <merijn> qmm: Cooperative scheduling
06:39:22 <quchen_> Will1: I usually use ExceptT e IO m. I only throw in IO for truly exceptional cases like when my network goes down, a file isn’t found and what not; every exception that I actually expect (i.e. a domain exception) goes into the »e« using ExcepT.
06:39:28 <Profpatsch>         where exc e | E.isPermissionError e = WA.ConfigWritePermissionError
06:39:29 <merijn> qmm: Well, not quite
06:39:31 <Profpatsch>                     | otherwise             = ES.throw e
06:39:35 <ertes> sm: you really insist on a manual and change log?  how many hackage libraries do you actually use?  can't be too many =P
06:39:42 <Profpatsch> That’s actually the best way to catch IOErrors, right?
06:39:46 <merijn> qmm: Basically, it doesn't use true preemption, but fakes it
06:39:53 <AndreasK> ertes: The logicT documentation seems light on details if one hasn't written a paper about it but I will see if I can figure it out :)
06:40:00 <qmm> merijn: mind blown
06:40:02 <merijn> qmm: Threads can get "preempted" whenever they allocate memory
06:40:12 <sm> if I'm choosing among complicated parsing libs, which I rely on heavily, and one of them has those things, of course I do
06:40:15 <lpaste> Cale pasted “example tree code” at http://lpaste.net/350282
06:40:16 <qmm> pretty easy to for me to have a blown mind though
06:40:17 <ertes> AndreasK: think of Logic as an alternative to []
06:40:17 <Will1> quchen_: OK, thanks - I will try that approach.
06:40:19 <merijn> qmm: So if your thread never allocates it will never get preempted (so not true preemption)
06:40:23 <lpaste> Cale pasted “example tree code” at http://lpaste.net/350283
06:40:26 <Cale> oh, weird, sorry guys
06:40:26 <lpaste> Cale pasted “example tree code” at http://lpaste.net/350284
06:40:28 <ertes> AndreasK: then think of LogicT as a transformer version of that
06:40:39 <qmm> merijn: ah
06:40:43 <Cale> lpaste didn't redirect me to the paste when I submitted
06:40:44 <merijn> qmm: But since you CAN get unscheduled when you allocate (instead of only when you yield) it's not truly cooperative either
06:40:48 <Cale> but it actually saved it :P
06:40:50 <sm> I use a lot of libraries. I need to save time
06:41:00 <merijn> qmm: In general I would treat it as preemptive as it's closest to that
06:41:25 <Cale> Anyway AndreasK, have a look there for how I might handle a binary tree type
06:41:45 <quchen_> I’ve seen some pathological examples where one thread will do a lot of work without allocating, but I don’t think this is something to worry about too much a priory.
06:42:06 <merijn> qmm: It takes some pretty unlucky/pathological cases to never allocate :)
06:42:06 <quchen_> Tail calls sometimes don’t allocate anything, for example.
06:42:10 <Cale> Every application is different, so you might want different stuff in your trees, but something along the lines of these couple functions (anaTree and cataTree) are generally really handy for defining everything else you might want
06:42:47 <qmm> merijn: i'm very curious what the interface is now for threads and ensuring they allocate
06:42:47 <old_spice> is anyone not able to open hackage page https://hackage.haskell.org/?
06:43:03 <quchen_> old_spice: Works for me
06:43:09 <merijn> qmm: There is also an explicit yield if such a case does happen
06:43:13 <qmm> old_spice: works for me
06:43:40 <Cale> AndreasK: If your tree type had more data constructors, the ana would need something fancier than Maybe
06:43:55 <old_spice> cheers.  what ip does it resolve to?
06:44:19 <AndreasK> Cale: On a first glance looks like a better version of something I would have ended up with :D I will play around with logicT first though, if nothing else then at least that should help to get more comfortable with transformers
06:44:23 <quchen_> 151.101.12.68, old_spice 
06:44:29 <old_spice> 151.101.120.68 
06:44:35 <old_spice> ?
06:44:44 <qmm> merijn: i'm comparing erlang and haskell runtimes currently and wondering how one is able to handle, say, millions of users simultaneously with low latency
06:44:53 <quchen_> No, it’s 12.
06:45:02 <quchen_> λ. ping hackage.haskell.org                                                                                                                               14:54:19  david@david-tng-laptop 
06:45:02 <quchen_> PING j.global-ssl.fastly.net (151.101.12.68) 56(84) bytes of data.
06:45:02 <quchen_> 64 bytes from 151.101.12.68: icmp_seq=1 ttl=59 time=21.0 ms
06:45:22 <old_spice> interesting. for me dig returns 151.101.120.68
06:45:27 <quchen_> ZSH is not good for copy-pasting eh
06:45:53 <old_spice> j.global-ssl.fastly.net. 17	IN	A	151.101.120.68
06:46:53 <quchen_> qmm: Aren’t both able to scale to looots of threads?
06:47:20 <merijn> qmm: Well, haskell threads are, in general, cheaper than erlang processes
06:47:34 <merijn> qmm: But the GHC runtime is not optimised for low latency
06:47:47 <byorgey> I can't connect to either of 151.101.{12,120}.68, but I can connect to hackage.haskell.org.  For me it resolves to 151.101.48.68 .
06:48:12 <merijn> qmm: The GHC GC is optimised for throughput, so it has the occasional stop-the-world pause for collection (because it has not thread specific heaps)
06:48:38 <merijn> qmm: This results into faster/more efficient GC, but causes latency spikes during GC pause
06:49:10 <merijn> qmm: (And also the GC pause starts running into scaling issues at >12-20 cores, depending on your workload when I last benchmarked)
06:49:29 <merijn> qmm: So if you care about throughput/average latency GHC should be just fine compared to Erlang
06:49:42 <merijn> qmm: If you care about worst case latency Erlang is probably better than GHC
06:49:54 <merijn> Since Erlang has no GC spikes
06:50:36 <merijn> qmm: (It's not like we're talking truly massive spikes, probably like 20ms at most and only if you have a huge heap/active set)
06:51:18 <merijn> qmm: GHC has a copying GC, so it's really fast if your working set is small and slows down as your working set grows, so that also matters.
06:52:17 <merijn> qmm: If you require a large working set AND latency spikes are unacceptable then it's not ideal. But if your working set is small OR you only care about throughput/average latency your fine
06:53:28 <merijn> qmm: But in general, millions of haskell threads should be no more of an issue than for Erlang
06:54:41 <qmm> i wonder, now, how often 20ms spikes occur 
06:55:10 <merijn> qmm: Not often and 20ms is a worst case I remember from a blog that had both huge working set and low latency requirements
06:56:02 <merijn> qmm: Basically the GC copies every live value during GC. So if you have 5 GB of live values, you need to copy 5 GB == slow. If you have only 100 MB of live data and 5GB of garbage it's really cheap
06:57:54 <sm> ponopono
06:58:20 <sm> pardon, wrong window
07:03:45 <qmm> merijn: that is as good an answer i could hope for, thank you very much. anything else i might ask wouldn't be haskell specific
07:04:07 <merijn> qmm: Good, because that's about as much as I know about RTS details ;)
07:04:26 <qmm> :)
07:05:56 <quchen_> merijn: You probably mean Pusher’s post
07:23:32 <kuribas> merijn: 20ms == 50 fps, that's reasonable :)
07:25:10 <AndreasK> Thats only the pause though?
07:25:25 <ij> Is box simply a pointer or a struct with pointer?
07:25:56 <quchen_> fps = fractional pause second
07:27:41 <kuribas> 25fps then...
07:27:53 <kuribas> but it's a spike, not an average...
07:29:43 <tsahyt> Hello! I'm implementing a graph-like static data structure, i.e. there is no need for dynamic updates. I was thinking that I could build it in a tie-the-knot kind of way. What performance characteristics would this have? I'm thinking that when all is said and done this would be like a network of pointers, so jumping around should be a constant time operation with very very little overhead. Is this assumption
07:29:45 <tsahyt> correct?
07:30:23 <lyxia> yes
07:30:37 <tsahyt> here's what my types would roughly look like http://lpaste.net/2702547757998014464
07:31:00 <tsahyt> I think the Show instance would be pretty useless though because there can be loops
07:31:45 <quchen_> If you follow pointers a lot, you’ll miss the cache a lot. But that’s a fairly low-level concern you might not need to worry about in non-critical programs.
07:32:19 <maerwald> sm: it's annoying that megaparsec doesn't backtrack by default
07:32:32 <tsahyt> quchen_: performance is rather critical here. I guess I'll try it first and then profile
07:32:54 <tsahyt> these structures can become rather large, think 10000s of nodes
07:33:18 <quchen_> tsahyt: If performance is *critical*, then a network of pointers might not be the best representation of your graph.
07:33:43 <quchen_> But before you worry about this, make sure you should.
07:34:25 <tsahyt> how would I go about profiling cache performance in haskell?
07:35:06 <tsahyt> I think cache misses would really be the main way this can get slow, right? Everything is constant time after all.
07:35:19 <quchen_> Breaking AES-256 is constant time too.
07:35:30 <quchen_> You want to be fast. Check whether your program is fast, not whether it is constant time.
07:35:55 <tsahyt> quchen_: I kinda disagree with that argumentation tbh, but I get your point
07:36:54 <hark3> welcome cur
07:37:16 <hark3> send
07:37:19 <hark3> SEND
07:37:32 --- mode: ChanServ set +o shapr
07:37:48 <shapr> hark3: are you learning Haskell?
07:37:58 <hark3> no
07:38:06 <quchen_> Would you like to? :-)
07:38:09 <shapr> hark3: oh, you already know Haskell?
07:38:20 <shapr> hark3: Are you doing the Advent of Code in Haskell? You could join the leaderboard!
07:38:40 <hark3> i am new
07:38:41 <shapr> I'm not doing as well as I was hoping on the #haskell leaderboard for Advent of Code :-(
07:38:49 <shapr> My excuse is that work is taking up all my time.
07:38:52 <shapr> hark3: oh welcome!
07:38:57 <oherrala> shapr: I have not even started yet :(
07:39:10 <shapr> oherrala: Your work takes more time than mine?
07:39:18 <hark3> k
07:39:18 <shapr> oherrala: I got lucky, my coworkers started getting excited about Advent of Code
07:39:26 <hark3> bot
07:39:28 <hark3> bot
07:39:30 <shapr> hark3: Do you know other programming languages?
07:39:32 <oherrala> shapr: I have two months old company :D
07:39:36 <hark3> yes
07:39:40 <shapr> oherrala: oh wow, that sounds busy
07:39:45 <shapr> hark3: what languages do you know?
07:39:50 <hark3> php
07:39:54 <hark3> <?php
07:40:06 <hark3> anybody on twitter
07:40:10 <AndreasK> tsahyt: If you want to reduce pointer chasing make your fields strict and unbox them
07:40:10 <hark3> i mostly active there
07:40:11 <shapr> hark3: Haskell is very different from PHP, what got you interested in learning Haskell?
07:40:14 <Clint> shapr: how do you see the #haskell leaderboard?
07:40:25 <oherrala> shapr: however, writing code has never felt so good.
07:40:26 <hark3> from reddit
07:40:30 <shapr> Clint: create an account on adventofcode.com then use the code in the topic line
07:40:31 <hark3> just random node
07:40:48 <hark3> twitter: @___0x00
07:40:51 <shapr> oherrala: I understand that, but I hear that only lasts until you have employees, then you get to be a manager
07:41:00 <tsahyt> AndreasK: that doesn't help much in my case. most of the important information is in the topology
07:41:01 <shapr> hark3: do you plan on learning Haskell?
07:41:06 <Clint> shapr: ah
07:41:08 <hark3> no bro
07:41:22 <hark3> busy right now, web application penetration
07:41:24 <shapr> hark3: this channel is for discussing Haskell, otherwise you're distracting from people who are learning Haskell
07:41:30 <paolino> why is Tree a comonad and not list ?
07:41:33 <shapr> hark3: so you gotta go elsewhere to chat
07:41:35 <oherrala> shapr: heh, probably. or then I hire managers to manage my coding
07:41:41 <hark3> do you know any good channel for hacking
07:41:46 <hark3> i'll go 
07:41:47 <shapr> hark3: not this channel
07:41:49 <hark3> :0
07:41:52 <shapr> hark3: ok, have fun! bye!
07:41:52 <hark3> thanks
07:41:55 <hark3> bye
07:41:59 <Igloo> shapr: Is the leaderboard just based on how many days you've solved, or does it take into account things like time or characters too?
07:42:33 <shapr> Igloo: leaderboard is mostly based on how many you've solved, but time from problem being released to solving ranks within that
07:42:52 <paolino> I mean isn't a list a tree with one child each node ?
07:43:10 <shapr> Specifically, the first person to solve a problem gets 100 points, the second gets 99, then down to 0. That scoring system also applies per-leaderboard
07:43:20 <shapr> Igloo: Howdy! Long time no chat, how's code?
07:43:56 <Igloo> not bad; just looking at the advent now  :-)
07:44:14 <shapr> oherrala: what's your new company? Are you writing Haskell? Tell me more!
07:44:54 <shapr> Igloo: nobody gonna beat glguy, he's ranked 16th globally
07:45:42 <shapr> I want lessons from glguy on how to quickly solve coding puzzles.
07:46:08 <geekosaur> paolino, http://stackoverflow.com/questions/12537149/theoretically-is-this-a-valid-comonad-instance-for-a-list
07:48:05 <oherrala> shapr: there's some Haskell (thousand lines or so maybe), bit of Rust, some Go and also things written in Javascript :)
07:48:06 <paolino> geekosaur, yes , tails, is what Tree has as duplicate
07:49:11 <paolino> well a Tree defined like that cannot be empty
07:49:13 <oherrala> shapr: cofounder wanted me to learn Rust in exchange for him to try Haskell :)
07:49:18 <geekosaur> point being nonempty lists appear to be perfectly good comonads. the "nonempty" part may be significant as nonempty lists only made it into base in ghc 8.0.1
07:50:45 <geekosaur> (and, at least in Haskell, you can't define a Comonad instance on lists with the constraint that the list is non-empty; you need to make non-empty lists a distinct type)
07:52:19 <paolino> geekosaur, right , NonEmpty is a comonad extract = fmap head; duplicate = tails
07:52:33 <paolino> :t tails
07:52:35 <lambdabot> [a] -> [[a]]
07:52:38 <paolino> ah
07:54:49 <paolino> > tails []
07:54:51 <lambdabot>  [[]]
08:09:01 <kuribas> I wonder if haskell style C would be slower than haskell...
08:09:24 <kuribas> or C++ since C doesn't have lambda
08:11:24 <kuribas> merijn: I am looking at the core of my transformer stack, it looks the same as if I had manually writting it...
08:12:50 <kuribas> merijn: articles describing how slow monad transformers are, are probably based on old libraries and ghc.
08:14:22 <geekosaur> wasn't mtl2's switch from standalone State etc. to StateT Identity in large part because ghc had learned to optimize them?
08:14:48 <geekosaur> (or perhaps more correctly, mtl1's standalones were because ghc of the day didn't)
08:15:50 <geekosaur> ...but that would have been ghc5! or even earlier perhaps; ghc4 manual seemed to think mtl was available as a third party library
08:18:07 <AndreasK> ertes: Turns out logicT isn't that complicated once you figure out the madness is just regular CPS types. Figuring out CPS types always blows my mind at first :D
08:18:47 <tabaqui1> how can I stop execution of program except of using "error"
08:18:49 <tabaqui1> ?
08:19:36 <int-e> :t System.Exit.exitSuccess
08:19:38 <lambdabot> IO a
08:19:56 <shapr> qmm: do you have a summary of your research on which languages/runtimes handle what numbers of kinds of threads and why that might be?
08:21:59 <tabaqui1> int-e: exactly, thanks
08:22:15 <qmm> shapr: i do not 
08:28:14 <shapr> qmm: if you write a blog post or something, I'd like to read it!
08:28:28 <ertes> AndreasK: yeah =)
08:28:52 <ertes> AndreasK: although CPS by itself isn't that bad…  it only gets mind-bending when you add church to the mix =)
08:29:23 <ertes> AndreasK: and once you understand it, you want to use it everywhere =)
08:29:30 <ertes> kind of like haskell itself
08:34:39 <infandum> Vector memory usage: Let's say I have a FULLY evaluated list with fully evaluated values. Does a where binding of Vector.fromList on that list "double" the memory or is it about the same as the elements would point to the evaluated value?
08:35:04 <infandum> I'm trying to think of the downsides of vectors versus lists
08:37:08 <ertes> infandum: do you need the list?
08:37:33 <ertes> infandum: remember: you can always go back to a list from a vector at negligible cost
08:37:46 <infandum> ertes: I guess the actual scenario is IntMap, collecting the values into a vector, and I need BOTH simultaenously
08:38:00 <tsahyt> wow. tying the knot never ceases to amaze me
08:38:15 <infandum> so IntMap -> List -> Vector, keeping IntMap and Vector
08:38:27 <ertes> infandum: is there a reason why you need *both*?
08:38:31 <infandum> they should both be strict, so the values should be available
08:38:38 <infandum> ertes: For what I'm trying to do, yes
08:39:00 <infandum> that is, if I only use the IntMap then my algorithm will be REEEEAAALL slow
08:39:16 <sm> maerwald: you saw "token-based combinators like string and string' backtrack by default" I guess
08:39:35 <ertes> infandum: well, if you construct a vector from an IntMap, it will be key-sorted, so you could binary-search the vector
08:39:42 <infandum> ertes: But would that vector take up a ton of memory or not if it points to existing values?
08:39:50 <infandum> so is it shared or duplicated?
08:39:56 <slack1256> ca you create signals on the haskell side of gtk?
08:39:59 <slack1256> *can
08:40:02 <ertes> infandum: no, compared to the IntMap a vector is typically *much* cheaper in terms of memory
08:40:14 <ertes> infandum: especially if you can use one of the unboxed variants
08:40:30 <infandum> ertes: True, but is it even LESS because the IntMap already exists?
08:40:35 <sm> Clint, Igloo, shapr: advent of code is brilliant.. I am learning a lot of new things
08:40:47 <maerwald> sm: which makes it even more inconsistent
08:40:54 <ertes> infandum: in the boxed variant the *values* are shared, but the vector itself (an array of pointers in this case) still needs memory proportional to the number of keys
08:41:04 <infandum> infandum: I'm using storable
08:41:06 <infandum> uh
08:41:11 <infandum> ertes: I'm using storable
08:41:18 <sm> on the haskell leaderboard, first solver currently gets 32 points, etc (based on the leaderboard length)
08:41:25 <ertes> infandum: with a storable vector you get no sharing at all
08:41:30 <infandum> oh yikes
08:41:42 <infandum> ertes: You said unboxed would be shared?
08:41:49 <ertes> infandum: no, boxed can be shared
08:41:56 <ertes> unboxed values need to be copied
08:41:59 <infandum> is boxed faster than the others?
08:42:05 <infandum> ah, ok
08:42:16 <infandum> their just doubles so it should be fine
08:42:36 <ertes> infandum: it depends…  boxed values are more composable, because of sharing
08:42:47 <ertes> unboxed values are faster *in principle*
08:42:57 <ertes> but they are also less flexible
08:43:03 <Amit_> New to Haskell, find it beautiful
08:43:04 <infandum> mhm
08:43:23 <infandum> ertes: Is there reading material for these different types of vectors?
08:43:27 <ertes> infandum: only Double?  go with storable or unboxed vectors – prefer the latter, if you have no particular reason to use storable
08:43:30 <infandum> with empirical speed tests and such?
08:44:03 <infandum> ertes: Yes, only double. Didn't you say unboxed would be copied values though? So it would take up twice the memory?
08:44:06 <infandum> approximately
08:44:07 <Amit_> What are unboxed vectors?
08:44:09 <ertes> infandum: it's storing a double vs. storing a pointer to a thunk that is already a Double…  in other words:  the unboxed variant will be *much* faster *and* smaller =)
08:44:36 <infandum> wait, which is which?
08:44:52 <ertes> infandum: boxed means pointers, unboxed means values
08:45:08 <ertes> (roughly)
08:45:17 <infandum> pointers take up MORE space??
08:45:36 <ertes> on a typical 64 bits architecture a Double and a pointer take the same amount of space
08:45:42 <infandum> !!
08:45:52 <infandum> boy that changes things
08:46:00 <shapr> sm: me too! I built a lazy tree shaped list! And then @sanityinc told me that he built a lazy Data.Tree and I should look at his code (but after I've solved that day).
08:46:28 <shapr> oherrala: sounds like a cool company already
08:46:31 <ertes> infandum: but remember: that pointer still points to something that is known to the garbage collector, etc.
08:46:42 <ertes> infandum: all of that extra cost disappears when you go unboxed in this case
08:46:51 <ertes> infandum: so yeah, i suggest copying
08:47:12 <Amit_> Hmm it makes sense now infandum
08:48:02 <infandum> ertes: Ah, so when it comes around to deletion it doesn't need to keep both around
08:48:34 <Amit_> @infandum, what about memory leaks? 
08:48:35 <lambdabot> Unknown command, try @list
08:49:01 <ertes> infandum: in the case of a vector the information GC has is rather coarse: "there is a vector…  that's all i know"
08:49:12 <ertes> GC isn't even aware of the individual values it stores
08:49:26 <sm> shapr: and I want lessons from glguy too
08:49:50 <sm> no spoilers, but 11 has horribly stalled me
08:50:05 <infandum> I need to look all of these cases up
08:50:16 <shapr> sm: I want to go back after the contest is over and do a write up on all the different implementations I can find in various languages.
08:50:24 <danilo2> Hello guys! Could I ask for a small help? I've got such simple GADT definition: http://lpaste.net/350289 I want to create function / typeclass which will construct `Store k as m` but without mentioning `as` in context. With GADTs its straigthforward to do the opposite - traverse structure without mentioning it, but can we construct it this way?
08:50:53 <sm> I was thinking similarly, a collection of all solutions or all haskell solutions would be very interesting
08:52:32 <maerwald> > print "\\"
08:52:34 <lambdabot>  <IO ()>
08:53:04 <maerwald> does ghci do some broken defaulting?
08:53:35 <maerwald> how do you print a string containing only of _one_ backslash
08:54:00 <geekosaur> putStrLn
08:54:03 <geekosaur> print runs through show
08:54:12 <geekosaur> > text "\\"
08:54:14 <lambdabot>  \
08:54:25 <geekosaur> (lambdabot hack)
08:54:27 <maerwald> then show is broken
08:54:31 <geekosaur> no?
08:54:43 <ertes> > read (show "\\") :: String
08:54:46 <lambdabot>  "\\"
08:54:57 <geekosaur> or have you joined the ranks of those who think show on String should not produce Haskell source but instead be literal?
08:55:07 <maerwald> I can't say megaparsec to not use show
08:55:15 <maerwald> *tell
08:56:03 <maerwald> as in: it doesn't really show what has been parsed
08:57:33 <infandum> ah, here is some good stuff: https://wiki.haskell.org/Numeric_Haskell:_A_Vector_Tutorial#Array_Types
08:58:15 <infandum> then Data.Vector is Boxed?
08:58:37 <ertes> infandum: yeah
08:58:48 <ertes> see the immediately next section there =)
08:59:49 <infandum> ooohhhh and Numeric (hmatrix) uses Storable because they pass it to C
08:59:54 <infandum> it all makes sense now!
09:00:03 <ertes> infandum: FWIW i always use the generic interface
09:00:12 <ertes> and only specialise it when creating vectors
09:00:33 <infandum> Data.Vector.Generic?
09:00:54 <infandum> Shouldn't that be Data.Vector and Data.Vector should be Data.Vector.Boxed?
09:00:55 <ertes> yeah
09:01:01 <infandum> weird naming
09:01:01 <ertes> perhaps
09:01:10 <ertes> matter of taste/history i guess
09:01:20 <infandum> probably history
09:01:37 <ertes> infandum: another very useful case for storable vectors is OpenGL
09:02:59 <kuribas> why does test2 evaluate to id for Int, but to (x + (0 * x)) for Double? http://lpaste.net/350291
09:03:14 <infandum> that would make sense
09:03:24 <ertes> infandum: especially with newer versions (i think ≥ 4.4) you can create your GL buffers on the graphics card, then map them persistently into your haskell program's address space (see glMapBufferRange), then create a mutable storable vector at that address
09:03:40 <ertes> infandum: therefore you have the full vector API for GL buffers =)
09:03:50 <kuribas> because of NaN?
09:03:57 <danilo2> Hello guys! Could I ask for a small help? I've got such simple GADT definition: http://lpaste.net/350289 I want to create function / typeclass which will construct `Store k as m` but without mentioning `as` in context. With GADTs its straigthforward to do the opposite - traverse structure without mentioning it, but can we construct it this way?
09:04:06 <kobalt_> why do I have this error with DataKinds, KindSignatures, and GADTs ? "• Type constructor ‘Type’ cannot be used here (it is defined and used in the same recursive group) • In the kind ‘Type KStar -> *’"
09:04:15 <lpaste> kobalt pasted “No title” at http://lpaste.net/350292
09:04:32 <kuribas> > 1/0 :: Double
09:04:34 <lambdabot>  Infinity
09:04:49 <kuribas> > (1/0 + (0 * (1/0))) :: Double
09:04:52 <lambdabot>  NaN
09:05:36 <kuribas> I hoped the (*0) would be optimized away :-(
09:06:55 <kobalt_> danilo2: what is your error ?
09:08:38 <danilo2> kobalt_: I've got no error. I just dont know how to do it or if it is possible, look I've just updated the example: http://lpaste.net/350289 . Function foo "fills" the Store with new values without mentioning `as` in the context. I want to do exactly this, but without providing input store
09:08:59 <mmaruseacph2> kuribas: it is optimized away if it doesn't change the semantics of the code
09:09:23 <mmaruseacph2> try running with -fast-math and see to what the Double specializates to
09:09:29 <mmaruseacph2> *specializes
09:09:29 <cocreature> kuribas: optimized away how? 1/0 is Infinity and multiplying that by 0 is NaN
09:09:53 <kuribas> cocreature: in my code it shouldn't be Infinity or NaN.
09:10:08 <mmaruseacph2> how would the compiler know?
09:10:14 <cocreature> kuribas: it can be NaN no?
09:10:41 <kuribas> yes
09:11:21 <cocreature> I guess I don’t understand what you expect
09:11:40 <ertes> kuribas: to what would you optimise (0 * (1/0) :: Double)?
09:11:59 <kuribas> ertes: 0
09:12:06 <ertes> kuribas: that's not an optimisation, but a completely different program
09:12:36 <slack1256> how do I emit custom signals in gtk from haskell?
09:12:39 <Tuplanolla> To be fair GCC has `-Ofast`, which enables `-funsafe-math-optimizations` and does just that.
09:13:02 <kuribas> ertes: I want it to eliminate my transformation matrix, which may have zero entries.
09:13:05 <Tuplanolla> There's also `fenv.h` for controlling the floating-point environment.
09:13:10 <kobalt_> isn't 0 * infinity an indeterminate form ?
09:13:33 <kobalt_> oh yes you mentionned that already, sorry
09:13:40 <cocreature> kuribas: once the function is inlined it could possibly optimize it away if it can prove that the argument is not inf
09:13:46 <ertes> kuribas: GHC might be able to do that, if your matrix is of finite and statically known dimensions and no edge cases like that occur
09:13:55 <ertes> kuribas: in other words: it's unlikely
09:14:20 <cocreature> trying -fllvm might also be worth a shot
09:14:24 <kuribas> ertes: it's just a datatype with 6 elements.
09:15:26 <kuribas> I could add a rule (forall (a :: Double) . a * 0 = 0).
09:17:27 <kuribas> https://hackage.haskell.org/package/fast-math
09:17:39 <ertes> kuribas: as a hackless compromise you could have special representations for special matrices with fewer components
09:18:24 <ertes> or a representation for sparse matrices
09:18:54 <codedmart> How do you go about debugging parsing errors for FromJSON? https://gist.github.com/codedmart/c39c8a47a2e41ad6831c128b41e1fcdc#file-address-hs-L4
09:19:08 <ertes> then you can "compile" a matrix into a transformation function and map that one
09:19:36 <kuribas> ertes: I have data Transform a = Transform a a a a a a
09:20:12 <kuribas> http://hackage.haskell.org/package/cubicbezier-0.5.0.0/docs/Geom2D.html
09:20:53 <ertes> kuribas: first of all i would make all of them strict, if you don't have a specific use case for non-strict fields…  that makes everything more memory-compact and faster, plus it enables GHC to better see the optimisation opportunities
09:21:08 <ertes> … if you can do that
09:21:17 <mmaruseacph2> kuribas: with -optc-ffast-math it seems to get the Double version to id too
09:21:24 <mmaruseacph2> unless I read it wrong
09:22:00 <kuribas> ertes: they are strict
09:23:06 <cocreature> mmaruseacph2: that seems weird, I don’t see why an option passed to the c compiler should help here
09:23:33 <kuribas> This seems to do what I want: https://hackage.haskell.org/package/fast-math-1.0.2/docs/Numeric-FastMath-NaN.html
09:24:59 <mmaruseacph2> no, it doesn't, I didn't read it properly
09:26:16 <kuribas> cocreature: the c compiler might make the optimization
09:26:34 <cocreature> kuribas: sure, but ghc does not call the C compiler when compiling Haskell programs (by default)
09:27:32 <mmaruseacph2> https://github.com/liyang/fast-math
09:27:41 <geekosaur> "at all" (unless you configured ghc unregisterised)
09:28:07 <cocreature> geekosaur: I was referring to unregistered builds :)
09:28:49 <kuribas> mmaruseacph2: yeah, that's the same one.
09:29:00 <kuribas> mmaruseacph2: I'll use that one...
09:29:42 <codedmart> Sorry I meant to link this: https://gist.github.com/codedmart/c39c8a47a2e41ad6831c128b41e1fcdc#file-shipment-hs-L3
09:29:58 <codedmart> Just not sure how to debug FromJSON parsing issues.
09:30:12 <codedmart> Anyone that can give some pointers?
09:31:08 <cocreature> codedmart: afaik the only way is to try to minimize the testcase and stare at your code really hard
09:32:38 <peddie> codedmart: could you include more information in your `fail` implementations?
09:33:44 <codedmart> peddie: It is not failing, a related data is showing `Nothing` rather then `Just ...`.
09:34:38 <lyxia> codedmart: have you tried eitherDecode
09:40:29 <codedmart> lyxia: How would I do that? There is no failure. `EPShipment {..., shpToAddress :: Maybe EPAddress, ...}`. EPShipment decodes but shpToAddress shows Nothing, but if I pull the `to_address` part out of the bs and directly encode it as EPAddress it decodess properly.
09:42:30 <lyxia> oh I see.
09:43:04 <lyxia> Maybe it's not looking for the right key
09:44:34 <peddie> codedmart: ah, I misunderstood, sorry
09:46:30 <suzu> oh is that easypost?!
09:46:34 <suzu> !
09:46:40 <tsahyt> when I do something like cycle [1,2,3] !! 1000, does it build up a 1000 element list as an intermediate step somewhere or is GHC smart enough to just step through three elements?
09:46:44 <lyxia> codedmart: unSnakeCaseJson, where is that defined
09:47:21 <codedmart> lyxia: Was just going into that as I changed shpToAddress to be Either String EPShipment. Let me get that up.
09:48:42 <lyxia> codedmart: you could try to change the field to not be optional
09:48:45 <quchen_> tsahyt: No, cycle is implemented so there will only be one "1" in memory.
09:49:02 <quchen_> It will however allocate a lot of cons-cells, because that’s what (!!) consumes.
09:49:23 <byorgey> however, with optimizations turned on probably it can get rid of the intermediate cons cells
09:49:47 <codedmart> lyxia: https://gist.github.com/codedmart/c39c8a47a2e41ad6831c128b41e1fcdc#file-utils-hs
09:49:54 <cocreature> I just looked at the core for -O2 and it doesn’t look like the cons cells are eliminated
09:50:02 <byorgey> oh, too bad
09:50:05 <byorgey> tsahyt: note even with optimizations it will still take 1000 steps, no matter how fast the steps are
09:50:27 <codedmart> lyxia: So when I changed it to shpToAddress to Either String EPAddress I get an error of `Error in $: The key \"ToAddress\" was not found`
09:50:35 <byorgey> for cycle xs !! n  in particular you should do  xs !! (n `mod` (length xs))
09:51:05 <byorgey> ...although that still has to compute the length which will take O(n)
09:51:18 <tsahyt> byorgey: Yes, it's not something I would do in real code. I'm just trying to wrap my head around this knot tying stuff
09:51:19 <byorgey> oh, that's a different n.
09:52:09 <tsahyt> byorgey, quchen_: thanks! it's good to know. so when I build up a structure from a computation lazily that references back to parts of itself, the computation will not be repeated then?
09:52:29 <byorgey> tsahyt: right
09:52:45 <tsahyt> so say I build up a structure using Maps as an intermediate structure to handle the referencing, the Map stuff will only happen once?
09:52:47 <codedmart> lyxia: But with the field modifier I thought that should work.
09:53:07 <byorgey> tsahyt: this can make for a nice memoization/dynamic programming technique, i.e. build a recursively defined lazy array or Map
09:53:35 <byorgey> tsahyt: I think the answer is yes, if I understand correctly what you are proposing
09:54:44 <tsahyt> byorgey: I can post the whole code in question if that'd help. Basically I have two types that reference each other and build up a kind of graph that way. I use a Map (IntMap actually) to build up the structure initially but would then like to not do the Map lookups again and again if I was to traverse deeper "into" the structure.
09:55:17 <tsahyt> I'm pretty sure that this should work, but since I can't deepseq it (obviously, since you can traverse it indefinitely), I started wondering again
09:55:56 <tsahyt> the cycle example is just what I think would constitute a very very simple version of that
09:56:12 <codedmart> lyxia: Actually I don't understand what is going on.
09:56:38 <codedmart> Maybe I should write my own instance.
09:57:34 <byorgey> tsahyt: you may be interested to try http://hackage.haskell.org/package/ghc-vis  to see the actual structure that is built in memory
09:57:47 <codedmart> It seems like it is trying to look for the processed key rather then the actual key in the bs.
09:58:10 <lyxia> codedmart: doesn't toTitle make Toaddress, not ToAddress?
09:58:15 <tsahyt> byorgey: this looks very interesting! I'll check it out
09:58:32 <lyxia> codedmart: The first letter of the input is converted to title case, as is every subsequent letter that immediately follows a non-letter. Every letter that immediately follows another letter is converted to lower case. https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text.html
09:58:43 <byorgey> tsahyt: I have used it successfully to view these sorts of knot-tied structures
09:59:09 <lyxia> codedmart: what you could do to better see what's happening is to insert a traceShowId in the middle of fromJson
09:59:32 <codedmart> OK
10:00:00 <lyxia> codedmart: parseJSON = genericParseJSON (...) . traceShowId . toTitleJSON . (...)
10:03:00 <codedmart> lyxia: I think you are right. I want capitalize rather then toTitle
10:05:04 <danilo2> Hello! If I've got class `class Foo (ls :: [*])` is it somehow possible to hde it form context if there are instances for `Foo '[]` and `Foo (a ': as)`? GHC oculd be sure that instance will be always there and these instances doesnt provide any additional contexts
10:05:47 <lyxia> add {-# OVERLAPPING #-} ?
10:07:40 <danilo2> lyxia: that was to me? :)
10:07:49 <lyxia> yeah
10:08:16 <danilo2> lyxia: it will nto work. I've got a context `Foo ls` - `ls` is still yet not known, so overlapping instances would not remove it form context
10:08:36 <danilo2> lyxia: moreover, overlapping doesnt matter here. '[] and (a ': as) are distinct types
10:08:37 <lyxia> oh I misunderstood.
10:08:53 <lyxia> Yeah, I thought I read "instance Foo ls"
10:09:17 <lyxia> No you can't hide the Foo ls constraint
10:09:42 <lyxia> because which instance is chosen depends on the caller.
10:10:01 <danilo2> lyxia: no, I'm talking about situation whre I've got type-level list of types and instances for empty list and any non-empty list. And GHc is guaranteed to have these isntances and that they do no tbirng anything new to the ocntext. I just want them to remove from ocntext if that wis possible. I susepct not, but I prefer to ask to check all the ways
10:10:31 <danilo2> lyxia: yes, it depends and GHC has to remember it, but it doesnt need to keep it in thecontext for the end user.
10:10:58 <danilo2> lyxia: something like GADTs do - you can traverse gadts that have tpye-level list for each of element of the lsit without mentioning it in the context
10:11:10 <danilo2> lyxia: look at this foo example: http://lpaste.net/edit/350289
10:11:46 <danilo2> lyxia: there you are evaluating a typeclass instance for each type-level list element, but you dont tell aobut it in the context, because GHC proves itself it is always met and keeps the info under the hood
10:13:25 <jasondockers> are there any online haskell compilers (interpreters?)? I can't install haskell on my current PC
10:14:28 <tsahyt> there's tryhaskell.org, but that's not meant for doing arbitrary things with it, just for first exploring the language
10:14:45 <codedmart> lyxia: Thanks that was it.
10:14:50 <codedmart> I appreciate the help.
10:15:28 <jasondockers> tsahyt, which compiler would you recommend I use? I suppose I could run a VM
10:15:35 <tsahyt> jasondockers: GHC
10:15:45 <jasondockers> tsahyt, thanks
10:16:05 <tsahyt> jasondockers: using stack makes this all extra simple though, so you might want to consider that
10:16:06 <lyxia> danilo2: the constraint here is provided by the argument though.
10:16:19 <jasondockers> tsahyt, stack? 
10:16:21 <tsahyt> jasondockers: https://docs.haskellstack.org/en/stable/README/
10:16:32 <lyxia> danilo2: so for your application it depends on whether you have a similar place to hide the constraint
10:16:44 <jasondockers> tsahyt, oh, sweet.
10:19:24 <Jello_Raptor> Is there some functions that allows me to compose lenses in parrelel? something like `Lens' s a -> Lens' s b -> Lens' s (a,b)`
10:23:17 <tsahyt> Jello_Raptor: parallel as in parallel execution?
10:23:44 <Jello_Raptor> no, just that I want to be able to work with multiple parts of a value at once 
10:23:52 <lyxia> I don't think so. The problem is it's not lawful.
10:24:13 <lyxia> feel free to build your own though
10:25:39 <Jello_Raptor>  mmm? it's not 
10:25:43 <Jello_Raptor> ?
10:26:14 <lyxia> It relies on the assumption that a and b are in independent parts of s.
10:27:10 <danilo2> lyxia: hmm, nope, the contraint is not provided by the argument. Look, the constraint is `KeyM k m`, its instance constraint is `Typeable a` and its proied by the arg, but the constraints itself is just inferred to be met by GHC
10:27:30 <Jello_Raptor> lyxia: ahh, I see 
10:27:40 <lyxia> danilo2: I thought you were talking about the Typeable constraint not appearing in the signature of the function
10:29:22 <danilo2> lyxia: I'm talking about the fact, that the constraint of `foo` does NOT mentions `as`, however, it evaluates inside typeclass intances for each particular `a` in the type-level list `as`
10:29:32 <jasondockers> does anyone here use haskell for work?
10:29:44 <danilo2> jasondockers:  yes
10:29:48 <Jello_Raptor> jasondockers: o/ I do, but I'm a grad student 
10:30:01 <jasondockers> does anyone here use haskell for work who isn't in academia* :p
10:30:18 <danilo2> jasondockers: in my company everything we write in Haskell
10:30:38 <jasondockers> danilo2, that's interesting. mind if I ask what sort of software your company develops?
10:30:38 <lyxia> danilo2: The Typeable instances are provided when you pattern match on SCons.
10:30:54 <danilo2> jasondockers: of course not, take a look at luna-lang.org
10:31:47 <jasondockers> danilo2, oh, I've seen this before. actually, I think I read an article published by one of the founders discussing his internship experiences. maybe not 
10:32:05 <tsahyt> I do use it for work, but am also a grad student
10:32:15 <tsahyt> I have used it for non-academic work for a while though
10:32:39 <jasondockers> danilo2, nice website :)
10:32:43 <Tuplanolla> I use it for academic work too, jasondockers.
10:33:43 <kuribas> Are rules automatically exported.
10:33:45 <kuribas> ?
10:33:59 <danilo2> lyxia: sure, but it doesnt matter. Sorry, maybe the example was confusing. I simplified it: http://lpaste.net/350289 . Look, `foo` doesnt mention `as` in context and its great! And here are two problems 1) If I want to just "generate" the Store, not "override" it like foo does, it is impossible without mentioning `as` ni the context
10:34:30 <jasondockers> danilo2, why did your company choose haskell? just due to prior experience?
10:35:39 <danilo2> And we see that gadts allow for some kind of "hiding" here (you cannot do something like that if instead of gadts you'll use your cutom datatype with type-level list)
10:36:12 <mmaruseacph2> danilo2: my company also uses Haskell for everything
10:36:33 <danilo2> lyxia: ^^^. So I was just asking - (it doesnt connects directly to gadts) that if I've got a type class that mentions type-level list and have instances for all possible cases, if I can magically hide it from context similar to what gadts do in my example
10:36:55 <mmaruseacph2> oh, sorry, not danilo2, jasondockers 
10:37:01 <danilo2> jasondockers: because it's the best tool you can use for this kind  of task. We need type-level security, fast binaries and functional approach
10:37:22 <danilo2> jasondockers: thanks :)
10:37:48 <mmaruseacph2> danilo2: that's really cool (project, website)
10:38:01 <danilo2> mmaruseacph2: nice to hear that! thank you :)
10:42:13 <SrPx> Is there any implementation of SHA3? The Crypto.Hash.SHA3 on hackage is actually keccak and should be removed 
10:42:19 <SrPx> or renamed
10:44:07 <shapr> SrPx: I don't see anything on google
10:44:55 <lyxia> danilo2: I think you can't in current Haskell. The example you gave manages this because the argument of foo is a runtime witness of the actual shape of the as type parameter.
10:45:03 <shapr> SrPx: oh hey, what about cryptonite? https://hackage.haskell.org/package/cryptonite
10:46:13 <shapr> SrPx: the source implies cryptonite has both sha3 and keccak: https://github.com/haskell-crypto/cryptonite/blob/master/Crypto/Hash/SHA3.hs
10:46:39 <SrPx> looking great
10:48:11 <danilo2> lyxia: yeah, I was suspecting it. I'm just trying to tell GHC that there are some complex guaranties on type-level. Thank you for the discussion! :))
10:48:34 <shapr> SrPx: are you building something interesting?
10:48:56 <SrPx> shapr: not really, why?
10:49:27 <shapr> SrPx: Lots of neat Advent of Code solutions floating by the past few weeks, I thought you might be using SHA3 in a creative solution to one of those :-)
10:49:42 <SrPx> advent of code? hmm
10:49:45 <SrPx> lmgt
10:50:18 <shapr> SrPx: don't look, it's addictive!
10:50:39 <shapr> SrPx: also, once you're addicted, you can join the #haskell private leaderboard with the code in the topic :-P
10:51:05 <xcmw> Is enabling PolyKinds supposed to cause code to error that did not error before?
10:51:09 <SrPx> I don't have time right now, but looks really cool
10:51:43 <shapr> SrPx: if you do end up joining the leaderboard you'll have links to people's github repos of solutions, there's really cool code in there.
10:53:13 <Sornaensis> @src liftM2
10:53:14 <lambdabot> liftM2 f m1 m2 = do
10:53:14 <lambdabot>     x1 <- m1
10:53:14 <lambdabot>     x2 <- m2
10:53:14 <lambdabot>     return (f x1 x2)
10:53:28 <Sornaensis> @src liftM4
10:53:29 <lambdabot> liftM4 f m1 m2 m3 m4 = do
10:53:29 <lambdabot>     x1 <- m1
10:53:29 <lambdabot>     x2 <- m2
10:53:29 <lambdabot>     x3 <- m3
10:53:29 <lambdabot>     x4 <- m4
10:53:31 <lambdabot>     return (f x1 x2 x3 x4)
10:54:13 <c_wraith> xcmw, it shouldn't usually, but there might be some cases where it breaks down. 
10:55:37 <lpaste> xcmw pasted “Error on line 19” at http://lpaste.net/350303
10:56:07 <xcmw> c_wraith: Works without Polykinds but fails with it
10:56:24 <xcmw> Should I report a bug?
10:57:22 <cocreature> xcmw: what’s the error?
10:57:50 <xcmw> cocreature: Couldn't match expected type ‘ElF (SectionedItems s i) 'Section’with actual type ‘Maybe a0’
10:58:05 <xcmw> type instance ElF (SectionedItems s i) Section = Maybe s
10:58:48 <cocreature> oh I missed that in your paste, sry
11:01:39 <cocreature> hm seems like polykinds shouldn’t break it but I might be missing something
11:05:15 <Sornaensis> @src fromJust
11:05:15 <lambdabot> fromJust Nothing  = undefined
11:05:15 <lambdabot> fromJust (Just x) = x
11:09:35 <nitrix> Sornaensis: These implementations are to take with a grain of salt and sourced from a separe file lambdabot has. It's not directly from hackage so it may be misleading.
11:11:09 <xcmw> cocreature: Ok. I'll report it as a bug.
11:11:59 <cocreature> xcmw: try to reduce it to a single-file example without external dependencies if possible
11:14:19 <xcmw> cocreature: I will
11:21:30 <xcmw> acowley: Is this the correct way to use vinyl if you need different types for the same key? http://lpaste.net/350305
11:22:53 <acowley> xcmw: which key am I looking at?
11:23:26 <xcmw> acowley: SX and XY
11:24:07 <xcmw> In d1 they are both string but in d2 they are functions of different types
11:24:52 <acowley> Oh, wow, this is quite sophisticated!
11:25:14 <ij> Can you apply the same predicate logic forall quantifier rules(and splits forall) in types?
11:25:19 <acowley> I've been mired in Core for the past 24 hours and my brain needs to ratchet back up to gear :P
11:25:47 <Eduard_Munteanu> ij, pretty much
11:27:40 <ij> Okay, I don't think you can apply those here. How (does) this work? Why wiki says I can't move «∀a» to outside? (∀a. a → a) → (∀b. b → b) to ∀b. (∀a. a → a) → (b → b). 
11:28:31 <c_wraith> you can float those binders. doesn't change anything. 
11:28:54 <c_wraith> err, that binder. 
11:29:18 <ij> So it's the same as forall a b. (a→a) → (b→b)?
11:29:41 <c_wraith> no, the forall a can't be floated. 
11:29:44 <acowley> xcmw: Is the rapply2 definition necessary? Or, put another way, can we write it more generically?
11:30:14 <ij> I think I am missing some crucial knowledge here; the security and grounding when I dick around with predicate logic.
11:30:21 <acowley> xcmw: There hasn't been much effort on type-changing updates, to be honest, so I'd like to have your efforts here guide an expansion of the library to better support it.
11:30:24 <ij> s/grounding/grounding I have/
11:31:26 <Xyliton> How do I tell stack to load files from the src folder other than Lib.hs?
11:31:37 <Xyliton> I tried to google but I didn't find anything valuable
11:31:41 <acowley> Xyliton: Add them to your .cabal file
11:31:43 <kuribas> why do my rules (bottom) not fire?  http://lpaste.net/350308
11:32:27 <Xyliton> acowley: to the "exposed-modules"?
11:33:09 <acowley> Xyliton: Yes. Although "other-modules" might be right for an executable target
11:34:27 <athan> Anyone here know if pandoc has a markdown quasiquoter?
11:36:15 <johnw> athan: good question
11:36:27 <johnw> shouldn't be hard at all to create one
11:37:14 <johnw> you want to avoid coding HTML into your source file?
11:37:16 <Xyliton> I want to create a "simple" language using Parsec. I know that it would be the best idea to make it represent everything using custom data types, although I'm not sure how to organize them. Literals are the "easy" part. But what is the difference between a statement and an expression? And how could I allow if clauses the be "full blocks", but also act as statement for let's say a while loop
11:37:46 <johnw> expressions can nest, statements cannot
11:38:59 <Xyliton> but where would such an if clause go? or do I have to add that to both?
11:39:47 <johnw> depends on your language
11:40:01 <johnw> Haskell has both if expressions, and if statements (in do syntax)
11:40:18 <johnw> it uses indentation of the "then" keyword to differentiate
11:40:27 <johnw> in C, they are only statements
11:41:39 <iphy> https://travis-ci.org/TokTok/hs-toxcore/builds/185863777#L411
11:41:39 <johnw> most languages with this distinction allow expression statements, but some also have statement expressions, where you permit syntax to use the result of a block as an expression value
11:41:42 <johnw> it's all up to you
11:42:28 <Xyliton> hm... to be honest, I wanted to create a "transpiler" which would read a custom language and "translate" it into another language (Lua, in my case). So, I could simulate a "statement if" using functions, but how should I separate them in the parser? one function which parses the "expression if" and another one for the "statement if"?
11:42:33 <Cale> johnw: er... what?
11:42:42 <johnw> Cale: which part?
11:42:50 <Cale> Haskell doesn't treat if specially inside do
11:43:16 <johnw> no?  is that just to guide the parser then?
11:43:27 <Xyliton> the term "expression statements" and "statement expressions" threw me a bit off :/ I guess I have to be a (near) native to understand that xD
11:43:28 <Cale> Though there was a change to the syntax in H2010 to allow semicolons in the middle of an if expression just so that you could indent it incorrectly inside a do-block and have it work :P
11:43:39 <iphy> Why does it need something about STM? I'm not even using STM anywhere.
11:44:07 <johnw> Xyliton: an expression statement is a statement that is simply an expression (this assumes you have side-effects in your language, typically).  In C it's called a void-statement in the grammar.
11:44:18 <johnw> EXPR;
11:44:26 <athan> thanks johnw, I swore it did... but yeah, it would be really easy to make one. Thank you!
11:44:35 <johnw> a statement expression would be like: if (x + SOME-STATEMENT-RETURN-A-VALUE) ...
11:44:49 <athan> oh, actually you might know this one - can I specify Cabal-related information in a haskell file's comment?
11:44:50 <johnw> Cale: ah, thanks
11:45:05 <athan> Specifically so I can load dependencies in an lhs literate file :x
11:45:17 <johnw> athan: only ghc options, as far as I know
11:45:18 <athan> so my `runstack somescript.hs` is all self-contained
11:45:19 <iphy> hpc: can not find stm-2.4.4.1/Control.Concurrent.STM.TMVar in ["./.hpc","./dist/hpc/mix/hstox-0.0.1","./dist/hpc/mix/testsuite"]
11:45:22 <athan> nooooo alright
11:45:36 <johnw> but I've never tired to do that, so I have no knowledge here
11:46:06 <athan> hmm... to the Nat cave!
11:47:30 <monochrom> Natman! Nat nat nat nat nat nat nat nat...
11:47:33 <Xyliton> also, how do I add tabs (and more specifically, the indent level) as part of the syntax?
11:48:23 <monochrom> Or should it be: Natman! Ba ba ba ba ba ba ba ba...
11:49:26 <iphy> athan: the semdoc project might be of interest to you if you're using literate Haskell
12:03:55 <SrPx> I've been away for quite some time... do we have dependent types already? (: 
12:07:06 <SrPx> Also, is there a {-# LANGUAGE AllNiceExtensions #-} shortcut? :)
12:07:43 <athan> monochrom: Why ba? haha
12:07:51 <athan> !! thank you iphy!
12:08:00 <monochrom> because I'm swapping n with b
12:08:09 <athan> SrPx: Define dependent:)
12:08:11 <yushyin> SrPx: http://cs.brynmawr.edu/~rae/papers/2016/thesis/eisenberg-thesis.pdf :)
12:08:13 <monochrom> "batman! na na na na..." -> "natman! ba ba ba ba..."
12:08:20 <athan> ? like the B supercombinator?
12:08:34 <monochrom> No, like a caeser cipher.
12:08:37 <SrPx> athan: can we encode Vect?
12:08:42 <athan> oh lol
12:09:00 <athan> SrPx: I think you should have been able to back in 7.8 iirc
12:09:11 <athan> given you can promote runtime nats
12:09:19 <SrPx> athan: without type class hackery? Link?
12:09:24 <athan> you have to think existentially I think, with KnownNat
12:09:32 <athan> oh there's still a lot of that
12:09:45 <athan> I needed to use KProxy one time :x
12:09:54 <SrPx> I'm quite afraid of that kind of type class hackery, it feels like stuff will break terribly if I use them so I just stay away
12:09:58 <athan> SrPx: I can't provide one, only speculation :/
12:10:06 <SrPx> okk
12:10:28 <athan> well, there's an Error type at least now :)
12:10:35 <SrPx> an Error type?
12:10:43 <athan> (for custom compiler error messages)
12:10:50 <athan> I haven't used it yet, but it seems pretty intuitive
12:10:59 <SrPx> that looks neat... I noticed the error messages changed a little, too... there are bullets now
12:11:06 <athan> rather than simply avoiding instances etc, you can reduce to Error to throw one
12:11:14 <SrPx> what are the most exiting new stuff?
12:11:28 <athan> I'm really excited to actually use TypeInType
12:12:22 <SrPx> Why is it exciting?
12:13:08 <iphy> athan: it integrates ghc and Pandoc
12:13:54 <athan> SrPx: Well, it's pretty close [tm] to sort-related reasoning about sets of things at compile time
12:14:11 <athan> but I still don't have a hang of it
12:14:23 <SrPx> uhmm
12:14:34 <athan> iirc, it means that * :: *, instead of just * :: BOX
12:15:06 <athan> but I'm probably way off
12:15:53 <athan> it would mean something like `foo :: * -> a` could make sense I think
12:17:32 <Xyliton> How do I parse indention-aware languages using Parsec? Or is there a better lib for parsing languages?
12:19:09 <athan> Xyliton: Would that make indentation it's own superexpression?
12:19:33 <athan> you might make the parser stateful in that case, tracking what the indentation "should be"
12:20:28 <SrPx> athan but what is the use for `foo :: * -> a`? 
12:20:41 <SrPx> Also is it even inhabited 
12:21:41 <Xyliton> athan: superexpression?
12:25:10 <athan> SrPx: Technically now, * inhabits * with TypeInType
12:25:36 <athan> For me, that means I can demote, but I don't think that's the correct reasoning
12:25:40 <SrPx> I mean the function `* -> a`
12:25:45 <athan> (still plumbing through it)
12:26:02 <athan> oh, that would turn a type into data
12:26:20 <athan> Xyliton: an expression that contains other expressions
12:26:54 <athan> so if your AST was something like `Exp := Foo | Bar | Supah [Exp]`, Supah would be a "superexpression"
12:27:47 <Xyliton> athan: but how can indentation contain expressions? I only want to control the flow of the code/syntax using indentation so there's no need for characters telling the compiler that a block starts/ends
12:28:31 <athan> but indentation is a character :)
12:30:14 <Xyliton> true
12:30:32 <muyfine> I'm using foldM with Maybe values and trying to figure out how to exit out of the fold on the first Just value I get: http://lpaste.net/350313
12:31:07 <muyfine> when I run that function, it hits all of the Just values
12:31:53 <muyfine> But I want it to stop after the first Just value
12:32:01 <Xyliton> let me rephrase what I wanted to say: "I want the code too look less 'cluttered' by using (usually) invisible characters, like tab and/or whitespace, to controll the 'flow of the syntax' instead of using characters like {} in java"
12:33:01 <athan> muyfine: you can imagine foldM as something that only cares about the values in the monad itself, and doesn't treat the monad as the subject matter. From what it sounds, you want to treat Just as subject matter data
12:33:04 <kuribas> why do these lifted literals not work in my code? https://github.com/liyang/fast-math/blob/master/Numeric/FastMath/NaN.hs
12:33:26 <athan> there are control-flow concepts that relate to this, muyfine, though
12:33:40 <athan> maybe something like Data.Monoid.First might help
12:34:20 <athan> Xyliton: That makes sense, but remember that indentation is a series of characters, too - which is why I suggested a stateful parser
12:34:26 <sbrg> muyfine: this question popped up the other day as well. I don't think this exists in base, but maybe it should
12:34:31 <sbrg> but you can easily write your own
12:34:35 <athan> to count how deep your indentation is, and whether or not you're in a block (or n-blocks)
12:34:57 <muyfine> athan oh? yeah, I thought fold was the right thing here, because I have a case statement where I need to leave a default of Nothing - I'm using the foldM for the things that can be called (and wrapped by Just)
12:35:02 <kuribas> > asum [Nothing, Just 1, Just 2]
12:35:04 <athan> oh also, the Alternative instance follows this concept too muyfine
12:35:04 <lambdabot>  Just 1
12:35:16 <kuribas> muyfine: like this?  ^^
12:35:36 <sbrg> > asum [return Nothing, return $ Just 1, return $ Just 2] :: IO (Maybe int)
12:35:38 <lambdabot>  error:
12:35:38 <lambdabot>      • No instance for (Num int1) arising from the literal ‘1’
12:35:38 <lambdabot>        Possible fix:
12:35:38 <muyfine> kuribas yeah, but I would like to have monadic effects with each element
12:35:46 <sbrg> > asum [return Nothing, return $ Just 1, return $ Just 2] :: IO (Maybe Int)
12:35:47 <Xyliton> athan: what is a stateful parser?
12:35:49 <lambdabot>  <IO (Maybe Int)>
12:35:52 <sbrg> eh
12:36:33 <athan> Xyliton: That is the question :)
12:36:50 <sbrg> :t asum
12:36:52 <muyfine> sbrg that returns Nothing in ghci for me
12:36:52 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
12:37:06 <sbrg> yes, it doesn't do what you want
12:37:12 <sbrg> we came to that conclusion last time as wel
12:37:13 <sbrg> l
12:37:34 <sbrg> since it's Alternative for IO 
12:37:37 <muyfine> yeah, guess I'll just write my own thing
12:37:57 <muyfine> I saw something in stack overflow about using MaybeT
12:38:12 <sbrg> yeah, you could probably do that. think that's what the user ended up with last time
12:38:25 <kuribas> muyfine: what's the type of your function?
12:38:48 <muyfine> it's `IO Int`
12:39:30 <muyfine> (for the sake of the example - it's a value that produced the thing I want to wrap in a Just)
12:39:34 <kuribas> muyfine: you want [Int] -> (Int -> IO (Maybe a)) -> a?
12:43:54 <sbrg> kuribas: I think so, but while ensuring that no more side-effects are performed than necessary to find the first Just value.
12:47:37 <muyfine> kuribas sbrg behavior like this: http://lpaste.net/350315
12:48:14 <muyfine> where I get the side effect, but stop at the first Just value
12:49:30 <kuribas> maybe foldlM with ContT?
13:02:36 <v0d1ch> guys I have a beginners question anybody in the mood to help out?
13:03:40 <cocreature> v0d1ch: just ask your question directly and if you hang around for a bit, somebody will probably take a look at it :)
13:03:52 <v0d1ch> ah ok cool :)
13:04:16 <v0d1ch> so going trough the haskell book I found this piece of code
13:04:17 <v0d1ch> gameWords :: IO WordList gameWords = do   aw <- allWords   return (filter gameLength aw)     where gameLength w =            let l = length (w :: String) in l > minWordLength && l < maxWordLength
13:04:56 <cocreature> @where lpaste
13:04:56 <lambdabot> http://lpaste.net/
13:05:06 <cocreature> ^ v0d1ch please use that to paste code
13:05:22 <cocreature> code with linebreaks is significantly easier to read :)
13:05:30 <lpaste> v0d1ch pasted “haskell from first principles” at http://lpaste.net/350316
13:05:43 <v0d1ch> sure thanks :)
13:05:44 <v0d1ch> http://lpaste.net/350316
13:05:50 <cocreature> thanks
13:06:21 <v0d1ch> so the return line specifies gameLength which is never defined 
13:06:31 <sbrg> it is
13:06:32 <sbrg>  
13:06:36 <cocreature> v0d1ch: it is defined below
13:06:37 <v0d1ch> so my guess is that filter is lazy and does not care about it?
13:06:37 <sbrg> in the `where` clause
13:07:16 <v0d1ch> yeah but there is gameLength and w
13:07:26 <cocreature> v0d1ch: haskell allows you to reference names that are defined after the current definition. this has nothing to do with lazyness, these names are all resolved at compiletime
13:07:41 <merlynfry> 'w' is the argument to the function.
13:07:50 <cocreature> v0d1ch: "gameLength w = …" means that gameLength is a function and in the definition w is the argument of that function
13:07:58 <xcmw> Will partially applied type families ever be added to haskell? Is it impossible or just very hard?
13:08:59 <merlynfry> Are you still confused?
13:10:06 <v0d1ch> ok got it so what eventually gameLength becomes after compiling ? how does the function look ?
13:10:39 <cocreature> v0d1ch: what do you mean by "look". are you interested in the assembly?
13:10:53 <v0d1ch> no I mean what does it do ? :)
13:11:07 <sbrg> it does what the definition says. it's just a function like any other
13:11:10 <cocreature> v0d1ch: are you familiar with other programming languages?
13:11:23 <sbrg> the only difference being that it's only available in the scope of gameWords' definition
13:13:05 <v0d1ch> yes but gameLength is not defined except in where clause. I see that w is used in the let statement below but I can't tell from looking at it what does gameLength do except I know it is a param to the filter function
13:13:25 <v0d1ch> yes I use JS, PHP, some Java before ..
13:14:13 <cocreature> v0d1ch: gameLength is a function that takes a String called "w". it then calculates the length of that string and returns whether that length is between minWordLength and maxWordLength
13:15:04 <v0d1ch> ah okay, I think too many equal signs got me confused
13:15:09 <v0d1ch> thanks guys
13:15:15 <cocreature> np
13:15:23 <merlynfry> Don't worry about it.
13:16:32 <v0d1ch> I am determined to go trough the book until the end and Ill give it few years to learn as much as I can and then we'll see if I can actually get a job
13:16:35 <sbrg> yeah dw. haskell is confusing right up until the point where it's the only thing that makes sense
13:16:38 <v0d1ch> writing haskell
13:16:58 <v0d1ch> no haskell jobs at all in my country
13:17:02 <v0d1ch> -_-
13:17:38 <cocreature> v0d1ch: pure haskell jobs are pretty rare, but you can often sneak in haskell to write some small tools even if your main job is not writing haskell :)
13:18:08 <v0d1ch> yes hopefully, but that really sucks
13:18:20 <delYsid> Does anyone know if there is a Haskell implementation of the box/glue/penalty algorithm of Knuths "Breaking paragraphs into lines" paper?
13:18:44 <jackhill> Hi, I'm using IHaskell installed via stack from the git repository with a jupyter notebook. How do I add a haskell package as a dependency so I can import it?
13:31:27 <sbrg> Does anyone have any articles or tips for designing an AST such that I can use Foldable and friends? I've read http://blog.ezyang.com/2013/05/the-ast-typing-problem/ and a couple of others. The "two-level types" is nearly there, but it it's a lot of wrapping and unwrapping
13:31:49 <sbrg> some of which may be possible to mitigate using pattern synonyms and ViewPatterns, maybe
13:32:11 <johnw> sbrg: I use two-level types
13:32:33 <johnw> aka fixed-points of functors
13:32:47 <sbrg> johnw: Alright. Do you happen to have any code I could look at?
13:33:28 <johnw> example: https://github.com/jwiegley/hnix/blob/master/Nix/Expr/Types.hs
13:33:44 <johnw> and then to annotate a tree: https://github.com/jwiegley/hnix/blob/master/Nix/Expr/Types/Annotated.hs
13:34:23 <johnw> there's a little boilerplate involved that can be ameliorated using pattern synonyms
13:34:36 <johnw> and it comes with some other benefits in terms of generalizing the recursion patterns
13:34:46 <johnw> but as with any design choice, there are differing camps
13:35:14 <johnw> I like it, and use it for all my AST work, and it doesn't get in my way too much
13:35:24 <sbrg> excellent, thanks! yes, I'm not afraid of some boilerplate if I get the power of Foldable and friends.
13:36:10 <johnw> sbrg: definitley check out this talk too then: https://www.youtube.com/watch?v=Zw9KeP3OzpU
13:36:41 <johnw> that was the night I started using this approach :)
13:37:00 <sbrg> thanks! that looks good. I'll have to see if I can find peace and quiet from family for 2 hours to watch it heh
13:37:08 <sbrg> holidays eh
13:37:23 <johnw> what I like about that presentation is that he uses it industrially in a lot of code
13:37:36 <johnw> so he has real experience, not just theoretical niceties
13:37:48 <sbrg> Yeah, that's definitely useful
13:38:09 <johnw> I forget why edwardk became disenchanted by this approach...
13:38:36 <johnw> but there are sometimes good reasons not to use it, which should be kept in mind.  I haven't really run into them much, so it may be more important for library authors, than application authors.
13:39:03 <sbrg> I'm writing a compiler and using it as an excuse to do very pretty Haskell things. 
13:39:06 <sbrg> so I'm not too concerned
13:39:12 <johnw> k, you'll like it then :)
13:39:25 <johnw> the best part is writing non-recusive evaluators; it's quite convenient
13:43:09 <sbrg> great, thanks! :)
13:45:36 <delYsid> Oh, Graphics.PDF.Typesetting.Breaking
13:52:49 <kuribas> > (\f -> foldr (\e b -> do f e >>= maybe b return)) --muyfine
13:52:51 <lambdabot>  error:
13:52:51 <lambdabot>      • No instance for (Typeable m0)
13:52:51 <lambdabot>          arising from a use of ‘show_M43268000795255744912403’
13:53:21 <kuribas> > (\f -> foldr (\e b -> do f e >>= maybe b return) (return 0)) --muyfine
13:53:23 <lambdabot>  error:
13:53:24 <lambdabot>      • No instance for (Typeable m0)
13:53:24 <lambdabot>          arising from a use of ‘show_M23637749553711033602433’
13:53:37 <kuribas> :t (\f -> foldr (\e b -> do f e >>= maybe b return) (return 0)) --muyfine
13:53:38 <lambdabot> (Foldable t, Num b, Monad m) => (t1 -> m (Maybe b)) -> t t1 -> m b
13:53:46 <kuribas> >  (\f -> foldr (\e b -> do f e >>= maybe b return) (return 0)) (return) [Nothing, Nothing, Just 1, Just 2]
13:53:48 <lambdabot>  error:
13:53:48 <lambdabot>      • Ambiguous type variables ‘m0’, ‘b0’ arising from a use of ‘show_M76389...
13:53:48 <lambdabot>        prevents the constraint ‘(Show (m0 b0))’ from being solved.
13:54:06 <kuribas> >  (\f -> foldr (\e b -> do f e >>= maybe b return) (return 0)) (Just) [Nothing, Nothing, Just 1, Just 2]
13:54:08 <lambdabot>  Just 1
14:06:55 <kuribas> foldr is undervalued...
14:09:38 <lyxia> :t (maybe ?b return, (<|> ?b)) 
14:09:40 <lambdabot> (Alternative f, ?b::f a, Monad f) => (Maybe a -> f a, f a -> f a)
14:11:15 <MarcelineVQ> do you know which package is the ?var syntax from?
14:11:33 <kuribas> >  (\f -> foldr (\e b -> do f e >>= (<|> b)) (return 0)) (Just) [Nothing, Nothing, Just 1, Just 2]
14:11:35 <lambdabot>  Just 1
14:11:40 <lyxia> it's the ImplicitParams extension
14:11:50 <MarcelineVQ> oh thank you
14:12:40 <kuribas> >  (\f -> foldr (\e b -> do f e >>= (<|> b)) (return 0)) (Right) [Nothing, Nothing, Just 1, Just 2]
14:12:42 <lambdabot>  error:
14:12:43 <lambdabot>      • Couldn't match expected type ‘Either a b’
14:12:43 <lambdabot>                    with actual type ‘Maybe a0’
14:13:02 <kuribas> (\f -> foldr (\e b -> do f e >>= maybe b return) (return 0)) (Right) [Nothing, Nothing, Just 1, Just 2]
14:13:16 <kuribas> > (\f -> foldr (\e b -> do f e >>= maybe b return) (return 0)) (Right) [Nothing, Nothing, Just 1, Just 2]
14:13:19 <lambdabot>  Right 1
14:13:30 <kuribas> lyxia: it's not the same...
14:14:11 <lyxia> right, it only unifies with f ~ Maybe
14:14:52 <kuribas> I wonder if there is a generic "maybe" function
14:15:54 <kuribas> @hoogle Alternative f => b -> (a -> b) -> f a -> b
14:15:57 <lambdabot> Text.Parser.Combinators chainl :: Alternative m => m a -> m (a -> a -> a) -> a -> m a
14:15:57 <lambdabot> Text.Parser.Combinators chainr :: Alternative m => m a -> m (a -> a -> a) -> a -> m a
14:15:57 <lambdabot> MonadLib.Derive derive_or :: Alternative m => Iso m n -> n a -> n a -> n a
14:19:06 <Trnsec_> Whats the best editor/ide would you say has the best support for haskell
14:19:23 <kuribas> :t \b f t -> fmap f t <|> b
14:19:25 <lambdabot> Alternative f => f a -> (a1 -> a) -> f a1 -> f a
14:19:48 <kuribas> Trnsec_: emacs?
14:19:50 <sbrg> Trnsec_: I don't think it'd be a lie to say that Emacs has very good support. but since ghc-mod, intero and similar tools are standalone, there are a few editors that support almost the same features as haskell-mode does in emacs
14:20:25 <Trnsec_> Thats good to know - I use Emacs anyway for a lot of other work
14:20:54 <sbrg> Trnsec_: well look no further then :) I personally recommend spacemacs, after having wrestled with vanilla emacs for a couple of years. spacemacs makes it *really* easy.
14:21:04 <sbrg> but getting haskell-mode working on vanilla emacs is also very simple
14:21:42 <sm> first tier: probably emacs, intellij, atom
14:22:32 <Trnsec_> Did you mean ghc-md ?
14:24:59 <Trnsec_> Do you used Spacemacs-dark or light?
14:25:11 <Trnsec_> I kinda like the feel of 'dark'
14:25:31 <sbrg> I meant ghc-mod. I use dark, but you can switch themes any time
14:26:02 <Trnsec_> I don't have ghc-mod in my package list - is it not under melpa?
14:28:47 <sbrg> oh ghc-mod is a haskell program
14:28:55 <sbrg> and it plugs in to emacs as a flycheck checker
14:28:58 <sbrg> (You really do want flycheck)
14:29:42 <sbrg> I don't use ghc-mod, btw. it's not necessary if you use haskell-mode
14:30:02 <Trnsec_> How do I get haskell-mode?
14:30:23 <sm> M-x list-packages
14:30:23 <sbrg> melpa should work I believe
14:31:05 <sm> move cursor to haskell-mode (search for it), i, x
14:31:14 <Trnsec_> Yeah I know
14:31:25 <Trnsec_> I just scrolled past it - thought it wasn't there
14:32:06 <haskell934> Hi, can someone help me, please (http://stackoverflow.com/questions/41272806/haskell-ambiguous-class-function)?
14:35:42 <kuribas> haskell934: a datatype might work better.
14:37:20 <kuribas> haskell934: haskell cannot find the right instance to use for choices.
14:37:29 <Cale> Yeah, a datatype would definitely work better.
14:38:05 <Cale> data Menu a = Menu { choices :: String, parseChoice :: String -> Maybe a }
14:39:11 <haskell934> Thanks, I'm going to give it a try.
14:39:39 <Cale> Though, it's unclear what else you would do with these apart from just presenting the user with a menu and obtaining the choice
14:39:57 <Cale> If there are no other ways of consuming this datatype, it might as well just be a function with some arguments.
14:40:21 <Cale> getMenuItem :: String -> (String -> Maybe a) -> IO a
14:43:37 <Cale> Then again, another option would be to use a class to specify how to display elements of your data type as menu item strings and better handle the construction of the String representing the choices.
14:45:45 <Cale> class MenuItem a where menuItemName :: a -> String
14:47:43 <Cale> and then perhaps have something like  displayMenu :: MenuItem a => [(String,a)] -> IO a
14:48:17 <Cale> (with the first elements of the pairs being the responses corresponding to each item)
14:48:47 <haskell934> Yes, this is much better.
14:49:47 <Cale> If you intend to have lots of small types representing the results of these menu choices, it might be worth defining something like:
14:50:12 <Cale> smallMenu :: (Enum a, Bounded a, MenuItem a) => IO a
14:50:57 <Cale> smallMenu = displayMenu [(show n, x) | (n,x) <- zip [1..] [minBound .. maxBound]]
15:30:44 <dopey_> Hey, fairly new to haskell and I've got a question related to an http proxy server. I'm dealing with WAI requests and responses and I would like my proxy to add a header to the request before sending it on to the destination. However, in reading the documentation I am only able to find methods for modifying/building the response (not the request). Given that I'm unable to find much written about the subject, I get the feeling that I'm goin
15:31:52 <MarcelineVQ> cut off at "I get the feeling that I'm goi"
15:33:09 <sbrg> dopey_: I don't have experience with WAI, but I have read a bit about it in connection with other libraries that build on top of it.. have you looked into wai middleware? 
15:33:14 <dopey_> oh, weird. is that a character limit thing? "Given that I'm unable to find much written about the subject, I get the feeling that I'm going about it incorrectly. Any advice appreciated."
15:33:27 <sbrg> I found this, googling "wai modify request" https://gist.github.com/frasertweedale/9006a2188b0c92ebb914
15:33:45 <c_wraith> dopey_, it's very poorly documented, but everything in the accessors section is actually a record accessor, and can be used to modify a request 
15:34:06 <MarcelineVQ> yes, some clients cut it off instead of sending as multiple lines, despite it being <current year> :(
15:34:11 <dopey_> ohhhh, i figured they were actually just accessors
15:34:53 <dopey_> ok, that's probably why i couldn't find much. thanks!
15:37:21 <dopey_> I did briefly look at middleware, but I still didn't understand how I would modify request from their. assuming the accessors can modify a request that should solve it
15:38:38 <moet> hi. i'd like to make a function that takes a monadic action `MonadIO m => m ()` and applies it inside of `forkIO` ... this seems not possible, since i'd need to be able to convert `Monad m => m ()` to `IO ()` somewhere along the way.. help
15:38:42 <moet> ?
15:39:03 <c_wraith> dopey_, the only hint of it in the docs (if you don't look at the source) is that a defaultRequest value is provided. that pattern only makes sense if there are some sort of record field accessors available. but you only realize that after you get some experience. 
15:39:23 <hpc> moet: do you need it for a specific m, or for all m with that constraint?
15:39:24 <monochrom> No, "forkIO your_thing" will suffice.
15:39:34 <hpc> :t forkIO
15:39:36 <lambdabot> error: Variable not in scope: forkIO
15:40:06 <hpc> monochrom: MonadIO only has liftIO :: IO a -> m a
15:40:06 <monochrom> OK I could misunderstand your question. What is the type of the function you want?
15:40:07 <Sornaensis> @src forkIO
15:40:07 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:40:23 <hpc> i read it as wanting liftIO' :: MonadIO m => m a => m a
15:41:06 <hpc> er, forkIO'
15:41:07 <moet> hpc: it's part of a library which will take somebody's action as an argument
15:41:12 <glguy> moet: No, there's no generic   MonadIO m => m x -> IO x
15:41:23 <moet> glguy: makes sense
15:41:32 <moet> so alternatively, what about https://hackage.haskell.org/package/forkable-monad-0.1.1/docs/Control-Concurrent-Forkable.html
15:41:45 <moet> this library seems very basic; is there nothing like this in stdlib?
15:42:58 <glguy> No
15:43:03 <hpc> generally if something is in a separate package, it's because someone wanted it and it isn't in base :P
15:43:38 <moet> yeah, that sounds right; still thought i'd ask
15:43:40 <hpc> what does your library do with the passed action?
15:43:46 <hpc> is there a reason it can't just be IO?
15:43:50 <c_wraith> moet, there is https://hackage.haskell.org/package/lifted-base-0.2.3.8/docs/Control-Concurrent-Lifted.html#v:fork
15:44:12 <c_wraith> moet, but no one really understands it. :) 
15:44:42 <hpc> MonadBaseControl is a hairy thing
15:44:57 <c_wraith> it works if the types you are using already have the necessary instance, but writing a MonadBaseControl instance is not easy. 
15:45:05 <hpc> it generalizes probably far more than it has any business doing
15:46:30 <moet> hpc: my library takes a user action and runs it on a different thread, using the mainthread to produce opengl contexts as necessary and pass them via MVar to the child thread(s) running actions
15:47:22 <hpc> that sounds like it should take an IO action
15:48:03 <hpc> also, http://blog.ezyang.com/2012/01/monadbasecontrol-is-unsound/
15:49:28 <monochrom> oh yikes
15:50:27 <monochrom> haha it's toned down now, s/unsound/tricky/
15:51:51 <monochrom> true, people have not given laws or other semantics
15:51:54 <hpc> i would say it's unduely toned down, though "unsound" is the wrong word
15:52:03 <monochrom> apart from wishful operational semantics
15:52:06 <hpc> i would use "unusable", or something more along those lines
15:52:49 <geekosaur> not unusable either, really. if you understand its limitations, it should still be usable
15:52:58 <geekosaur> but you'd better understand those limitations
15:53:08 <hpc> yeah, they're just really opaque limitations
15:53:32 <hpc> it's very hard to look at that first block of code and know what it does, even knowing the limitation
15:53:42 <hpc> no single line stands out as wrong
15:54:30 <hpc> hmm
15:54:47 <hpc> if the m in doubleG has multiple MonadBaseControl n m instances
15:55:08 <hpc> then if you change the type signature of doubleG from MonadBaseControl IO m => m a -> m a to MonadBaseControl SomethingElse m => m a -> m a
15:55:16 <hpc> it does something very different
15:55:20 <hpc> that's pretty funny
15:55:45 <c_wraith> shouldn't the fundep prevent that? 
15:56:11 <hpc> ... yes
15:56:32 <hpc> hmm
15:58:59 <hpc> so it looks like, at least wrt transformers, (MonadBaseControl b m) means that b is the "bottom-most" Monad in the transformer stack m?
15:59:30 <johnw> yes
15:59:33 <johnw> it's the MonadBase b
16:00:00 <hpc> ah, and it says so right in the package description
16:01:52 <moet> are there any mechanisms besides `bracket` to guarantee resource cleanup in the future?
16:02:20 <hpc> ST-style shennanigans
16:02:36 <moet> bracket locks me into compatibility with the sub-monad (if i use Control.Monad.Exception) or IO (if I just use Control.Exception)
16:02:51 <moet> hpc: can you be more specific?
16:03:43 <hpc> https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad-ST.html - ST itself
16:04:08 <hpc> and there's resources all over on how the higher-ranked type trick works to sandbox stuff
16:04:33 <hpc> you can also write your own bracket-style thing
16:04:44 <shlevy> What happens if I killThread a thread that's already exited?
16:06:39 <hpc> nothing, it seems
16:09:30 <hpc> moet: really, what you probably want to do is avoid exceptions at all cost
16:09:57 <hpc> moet: encode some kind of break-out directly into the data type you're representing computations with
16:10:08 <hpc> moet: and then write your own appropriate bracket-style function against that type
16:11:44 <hpc> that tends to work better than wondering which typeclass is going to generalize exactly the feature you want for the 50-ish things you want your library to support
16:19:27 <tmpz> Would anyone know why this Alex rule @escaped_character = @escaped_unicode_character | "\0" | "\\" | "\t" | "\n" | "\r" | "\"" | "\'" works file till \r but will fail for \" and \' ?
16:22:38 <c_wraith> tmpz, does Alex use backslash escapes for string literals? 
16:23:07 <c_wraith> tmpz, because if it does, that's the problem. 
16:23:24 <tmpz> c_wraith I have also tried "\\\""
16:23:29 <tmpz> still fails
16:24:19 <tmpz> also parsing the string \r and I mean string not character works fine as you see it
16:25:29 <tmpz> for example \r produces -> [StringLiteral "\\r"]
16:26:11 <acowley> cocreature: You around?
16:27:42 <haasn> ugh
16:27:53 <haasn> why does ‘vector’ provide mapM but not traverse
16:31:53 <Axman6> it might depend on which vector you're talking about.Data.Vector _should_ since it can hold any type, but Data.Vector.Unboxed can't because it needs to place constraints on the result type
16:36:02 <haasn> Axman6: I mean you could literally take the mapM_ code and change the Monad constraint to Applicative and it would still compile
16:36:06 <haasn> mapM*
16:36:18 <Axman6> yeah. file a vug =)
16:36:20 <Axman6> bug*
16:36:23 <Axman6> or, a PR
16:36:29 <haasn> and it would have made my life easier; but it seems somebody else has already done the work of making a traversal for Storable vectors
16:38:06 <Axman6> you can't implement Traversable for storable vectors
16:38:34 <Axman6> because Traversable doesn't allow any constraints on the result type contained in the vector
16:38:41 <Gurkenglas> If you're too lazy to do a PR feel free to go to https://github.com/aelve/haskell-issues/issues/new and rant about it, someone else might do it
16:39:04 <haasn> Axman6: traversal != Traversable
16:39:11 <haasn> (traversals can be monomorphic)
16:39:11 <Gurkenglas> Or like, I mean, I'll do it right now.
16:39:23 <Gurkenglas> (That is post to haskell-issues :P)
16:40:06 <haasn> or in this case, have an extra constraint (like with the mapM)
16:41:09 <Gurkenglas> https://github.com/aelve/haskell-issues/issues/48
16:41:13 <Axman6> right. just making sure you werten't hoping for a Traversable instance. of course a traversal should be possible. does Lens provide any?
16:41:46 <Gurkenglas> Hmm. That was mechanical enough that someone should make an IRC client plugin that does this.
16:41:49 <haasn> Lens does not, sadly
16:41:53 <Gurkenglas> Orrr a lambdabot plugin
16:42:50 <hpc> @faq can haskell rudely direct you to a project's bug tracker?
16:42:50 <lambdabot> https://wiki.haskell.org/FAQ
16:42:57 <hpc> i miss the old @faq
16:43:10 <Gurkenglas> Is it const "yes"?
16:43:22 <monochrom> It is still a const. All is not lost.
16:43:25 <dhess> Hi, anybody here a lens wizard? I have a dumb question.
16:43:39 <xcmw> Why doesn't this code error? http://lpaste.net/350320
16:43:47 <Axman6> dhess: ask away (there is also #haskell-elsn, but here is a better place to start)
16:43:50 <Axman6> uh, lens
16:43:55 <Gurkenglas> That was the dumb question, now ask the question dhess, Im pretty sure its not dumb :P
16:44:00 <haasn> Gurkenglas: “The answer is: Yes, Haskell can do that!” or something to that effect
16:44:39 <ertes> @faq Can Haskell `fix` the world?
16:44:39 <lambdabot> https://wiki.haskell.org/FAQ
16:44:43 <ertes> uhhh
16:44:52 <ertes> they `fixed` it
16:45:25 <monochrom> :)
16:45:28 <Gurkenglas> @where+ Can "Yes, it can!"
16:45:28 <lambdabot> I will never forget.
16:45:37 <Gurkenglas> @where Can Haskell `fix` the world?
16:45:37 <lambdabot> "Yes, it can!"
16:45:44 <dhess> OK, trying to figure out how to use Control.Lens.Wrapped. I have 2 simple newtypes, say A and B, which wrap Text. e.g., newtype A = A Text deriving ..., newtype B = B Text deriving ...
16:45:44 <Gurkenglas> @where+ Can Yes, it can!
16:45:44 <lambdabot> It is forever etched in my memory.
16:45:51 <Axman6> @where Can haskell fix error?
16:45:51 <lambdabot> Yes, it can!
16:45:55 <Axman6> > fix error
16:45:58 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
16:46:08 <dhess> I'm trying to use `op` to convert an A to a B, but can't figure out how
16:46:18 <Axman6> :t op
16:46:21 <lambdabot> Wrapped s => (Unwrapped s -> s) -> s -> Unwrapped s
16:46:42 <Axman6> :t op Sum
16:46:48 <lambdabot> Sum a -> a
16:46:53 <Gurkenglas> view $ B . op A
16:47:02 <Gurkenglas> Um, scratch the view.
16:47:08 <dhess> I would have thought `let a = A $ op B b` would work
16:47:22 <Gurkenglas> Nah, that turns Bs into As
16:47:46 <dhess> sorry, dyslexic. either direction is fine
16:48:27 <tmpz> c_wraith well, this works @escaped_unicode_character | "\0" | "\\" | "\t" | "\n" | "\r" | '\' $double_quote | '\'$single_quote
16:48:50 <Gurkenglas> dhess, does op B typecheck? What's it's type according to ghci?
16:49:00 <Gurkenglas> *its
16:49:11 <dhess> Gurkenglas: no, it does not.
16:49:32 <Axman6> do you have a Wrapped instance for B?
16:49:35 <dhess> I've declared a bare `instance Wrapped B` 
16:49:48 <dhess> do I need to be explicit?
16:49:55 <Gurkenglas> Does that typecheck without you using "op B"?
16:50:00 <Axman6> you can use makeWrapped
16:50:01 <dhess> yes
16:50:11 <dhess> `instance Wrapped B` checks
16:50:29 <dhess> Hmm, hadn't seen makeWrapped
16:50:33 <Axman6> I'm not sure that actually gives you what you need... I'll check
16:50:35 <dhess> is it in some TH module?
16:50:50 <dhess> ahh yes
16:50:55 <dhess> let me try it
16:50:55 <Axman6> Control.Lens expors makeWrapped
16:51:22 <Axman6> yeah it doesn't look like there's any default implementation for Wrapped using Generic or something
16:51:34 <dhess> yeah, I was just browsing the docs per-module so it doesn't show up in Control.Lens.Wrapped
16:51:41 <dhess> let me try that quickly
16:51:48 <Gurkenglas> Why not, actually?
16:52:50 <Gurkenglas> (Because then you have to derive Generic? (Or Data))
16:53:12 <dhess> Uh oh, I'm needing to do the FlexibleInstances/MultiParamTypeClasses... dance
16:53:37 <dhess> stopped there, not too bad
16:54:06 <dhess> yay! op B typechecks now
16:54:16 <dhess> let me see if the full bit works
16:54:46 <dhess> sweeet
16:55:16 <dhess> hey thanks so much!
16:55:26 <xcmw> Why doesn't this code error? http://lpaste.net/350320
16:56:04 <dhess> I'm a bit surprised that I was able to `instance Wrapped A` yet get something useless
16:56:49 <xcmw> There is no instance for Q so how does it typecheck?
16:56:52 <dhess> but all's well that ends well
16:57:44 <dhess> all's wel that lens' well?
16:57:46 <dhess> hehehehe
16:57:57 <dhess> (don't kick me for that)
16:58:10 <monochrom> all is swell
16:58:29 <geekosaur> xcmw, how are you testing this
16:58:30 <c_wraith> xcmw: instances have nothing to do with that.
16:58:58 <c_wraith> xcmw: and I'm pretty sure you'd get an error if you ever tried to *use* R
16:59:09 <c_wraith> ...  Also, that would need DataKinds to even compile..
16:59:24 <geekosaur> that. yes (that you'd get an error on use)
17:00:08 <xcmw> I have DataKinds and like 20 other extensions in my cabal file
17:00:24 <xcmw> I can use R without getting an error
17:00:37 <c_wraith> GHC does let you get away with declaring impossible (or useless) things in several different cases, and only complains on use.
17:01:40 <c_wraith> xcmw: you have some weirdness going on there, which I think explains it.
17:02:06 <c_wraith> xcmw: in particular, X is a type family that doesn't take an argument.
17:02:13 <c_wraith> xcmw: which is nearly nonsensical
17:02:24 <c_wraith> xcmw: I think that's why it's letting you get away with it.
17:03:01 <xcmw> c_wraith: I'm trying to make X a kind of G and F
17:03:27 <c_wraith> xcmw: I'd recommend not trying that until you understand Haskell's type system a bit better.
17:03:58 <xcmw> c_wraith: I'm trying to make a kind class
17:04:17 <Zemyla> So I think I've figured out how to turn the permutation parsers described here  https://hackage.haskell.org/package/parsers-0.12.4/docs/Text-Parser-Permutation.html into an actual Applicative.
17:04:26 <athan> xcmw: But why, when all constraints are deduced in a context induced by *?
17:04:48 <athan> i.e. all constraints are "used" by data
17:05:10 * athan er, e.g.? :x
17:05:28 <c_wraith> xcmw: in the end, though, the X family is meaningless.  You can't actually resolve it to anything.
17:05:34 <c_wraith> athan: i.e. was correct.
17:05:42 <athan> :D
17:05:53 <c_wraith> athan: i.e. is roughly "that is", where e.g. is roughly "for example"
17:06:11 <xcmw> c_wraith: X is a family? I though it was just a type.
17:06:33 <c_wraith> xcmw: it's an associated type of the H class, which makes it a type family.
17:07:10 <athan> ah I thought so, thanks c_wraith :)
17:09:27 <athan> o_o all the joins... is matrix.org a haskelly company?
17:09:45 <c_wraith> Just a netsplit ending
17:09:54 <xcmw> Is there a way to make the kind of X be G or F depending on context? Like how return is Right, Just, etc depending on context.
17:10:01 <athan> oh derp
17:10:31 <athan> xcmw: That's similar to saying "why can't I have heterogeneous lists?"
17:11:02 <athan> oh, but you _should_ be able to, given TypeInType?
17:11:20 <athan> actually holy derp! I think I know the use case now with DataKinds! woot
17:11:28 <haasn> (Is there anything useful you could do with a kind family that you can't do with open type families?)
17:13:06 <athan> there might be actually haasn
17:13:09 <athan> hmm
17:13:22 <athan> xcmw: Have you messed with TypeInType?
17:13:32 <xcmw> athan: No
17:13:40 <athan> my claim that constraints are induced by * might be completely false
17:14:15 <athan> but basically, * now has a kind *, so in theory, you should be able to write something nuts like `metaAbsurd :: * -> a`
17:14:59 <athan> along that same coin, could kinds be instances of typeclasses, given they reside in *?
17:16:23 <athan> > {-# LANGUAGE TypeInType #-} let metaAbsurd :: * -> a; metaAbsurd x = undefined in metaAbsurd Int
17:16:25 <lambdabot>  error:
17:16:26 <lambdabot>      Not in scope: type constructor or class ‘*’error: Operator applied to to...
17:16:26 <athan> :D
17:19:20 <xcmw> athan: Are you trying to use visble type application?
17:19:43 <xcmw> or are you trying to write a type level function?
17:20:56 <athan> I was way off actually xcmw
17:21:01 <athan> disregard what I said
17:21:15 <athan> it was more like demotion
17:23:32 <xcmw> athan: Ok. So is what I want possible? It looks like the answer is no.
17:25:47 <athan> xcmw: I don't believe so. You could probably do it with an open type family, though
17:26:35 <athan> (and data kinds :x)
17:27:32 <xcmw> athan: How? What argument would it take?
17:31:24 <halogenandtoast> I'm currently trying to improve my Haskell chops and I was wondering if anyone would be willing to do a code review. I've implemented Sokoban and put it up on Github. If anyone is willing to take a look and make suggestions please do so: https://github.com/halogenandtoast/all_the_sokobans/pull/1/files#diff-23c9c628f24b91b95a43a52b7a0b67ea
17:32:03 <athan> xcmw: With type in type :)
17:32:17 <athan> but I am probably wrong
17:32:49 <aarvar> How do these instances violate the functional dependency? http://lpaste.net/350322
17:33:24 <c_wraith> aarvar: the patterns overlap
17:34:24 <c_wraith> aarvar: What instance gets selected for Foo (Qux a) (Qux a) b
17:34:50 <c_wraith> aarvar: because the instances overlap, it could go either way.  in this case, that also means violating the fundep
17:35:00 <aarvar> though you have the Foo a b c constraint on the second one
17:35:11 <c_wraith> Constraints are ignored for instance resolution
17:35:17 <c_wraith> They're just applied as a result of it
17:35:22 <aarvar> ah
17:35:35 <aarvar> then, is there a way I could encode something like this?
17:36:04 <c_wraith> I'd consider a closed type family..  If I'm reading your intention properly.
17:43:26 <Zemyla> But yeah, the general combinator in the permutation parser library has the type Permutation m (a -> b) -> m a -> Permutation m b, and Permutation m is a functor.
17:48:28 <Zemyla> So that means it can be turned into an Applicative.
17:54:15 <slack1256> I got this problem with gtk3, I can (on events) modify my model, but I can't tell (by way of a custom event) modify the view.
17:55:29 <slack1256> I just want a way to tell a widget "you, something changed, redraw stuff" on demand. Maybe with MVars?
17:58:03 <khumba> slack1256: Haven't done a lot of GTK+ recently but...  widgetQueueDraw?
17:58:13 <halogenandtoast> If I wanted to implement a boardgame in Haskell, would using a State monad make sense, should I have a type that has both the state and a list of transformations?
17:58:29 <halogenandtoast> *StateT monad
18:00:33 <jle`> halogenandtoast: that's one way people do, yes
18:00:50 <jle`> a lot of people enhance that with lens-based State combinators to help with modularity
18:01:21 <halogenandtoast> jle`: I've been considering diving into lenses, they seem really useful, but I have yet to try them.
18:01:29 <jle`> for example, if your state consists of a bank, you could lift a 'State Bank a' to a 'State GameState a' using some of the combinators offered by the lens library
18:01:51 <jle`> the basic idea is to write 'State s a' with the minimal 's' possible, and then just "lift" it to your big fattie state type when you need to incorporate it
18:02:14 <slack1256> khumba: Can I modify that handle?
18:02:23 <jle`> it helps with modularity and helps you live with the fact that you've sunk to the level of global mutable state hehe
18:02:26 <halogenandtoast> Interesting, I kind of understand what that means and why it's important.
18:02:44 <nshepperd> athan: apparently it's actually possible to write 'foo :: * -> Int' in ghci with TypeInType, but it's useless since * is empty at the value level?
18:02:51 <halogenandtoast> Are there any good reads (or videos) on the topic that would help me get started?
18:03:01 <jle`> with State, or with lenses + State?
18:03:16 <aarvar> c_wraith: so, a closed type family won't work, since if e.g. the `Foo a a` case comes first, then `Foo a (Qux b)` won't reduce since the type system can't prove a != Qux b
18:03:39 <halogenandtoast> jle`: honestly both
18:04:14 <halogenandtoast> as in either separately, or both together. I'm still green when it comes to Haskell
18:04:56 <jle`> umm this article was how i learned State back in the day, but i'm not sure if it's the best or clearest http://brandon.si/code/the-state-monad-a-tutorial-for-the-confused/
18:05:16 <jle`> it was written 7 years ago to take it for what it is, heh
18:05:30 <khumba> slack1256: Mmm, I don't know if GTK+ has a limitation about modifying views during events though, sorry.
18:05:32 <jle`> and here's a nice article on incorporating lens with state, http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
18:05:50 <jle`> it's one of the more clear/plain ones that establishes how to use the two together, but it presupposes that you understand State, i think
18:06:27 <halogenandtoast> jle`: awesome, that second one looks right up my alley
18:06:31 <jle`> it's also a little operator-heavy ...
18:06:51 <jle`> but most of what it describes can be done without the operators and using more simple english-name combinators
18:06:54 <jle`> idk that's more of a stylistic thing
18:07:23 <halogenandtoast> I'm not too afraid of operators, thanks so much for the help.
18:07:28 <jle`> really the only thing you need is zoom, from http://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Zoom.html
18:07:57 <jle`> zoom :: Lens' s1 s2 -> State s2 a -> State s1 a
18:08:47 <jle`> the operators in that article are mostly convenient wrappers around zoom :)
18:10:39 <halogenandtoast> I'll read up and see what I can come up with. I'd really love for Haskell to replace my defacto language, but I'm very slow in it at the moment.
18:19:35 <athan> nshepperd: I tried a few things but couldn't get anything to work, but yes you're 100% correct. Unless there was... -XKindDatas! :v
18:20:40 <nshepperd> :O
18:23:23 <athan> muh strata
18:37:03 <halogenandtoast> If anyone wants to help an aspiring Haskell programmer become better, I have this Sokoban implementation I've made that I would love feedback on: https://github.com/halogenandtoast/all_the_sokobans/pull/1/files#diff-23c9c628f24b91b95a43a52b7a0b67ea
18:37:09 <halogenandtoast> Any feedback would be greatly appreciated
18:37:57 <Axman6> what's sokoban?
18:38:02 <halogenandtoast> It's around 175 lines of Haskell code and I tried my best to be idiomatic
18:38:28 <halogenandtoast> Sokoban is a little game from 1981 where you move crates around a room and try to get them to certain locations
18:38:58 <halogenandtoast> It's played in the terminal and has pretty simple rules
18:39:01 <Axman6> oh cool, sounds fun
18:39:34 <halogenandtoast> I thought it would be a perfect haskell exercise since it's a game that doesn't rely on random.
18:39:52 <Axman6> migth want to avoid using Left and Right as constructors, just becauser they're so well known from Either (but I'mnot even sure I agree with this adfvice, it's definitely quite clear at the moment)
18:40:27 <ezyang> Axman6: Nah :P 
18:41:27 <Axman6> loadLevel is just levelFromString <$> readFile filename
18:41:28 <halogenandtoast> Axman6: yeah I've wondered what I'd change if I ended up needing the Either monad.
18:41:58 <halogenandtoast> Axman6: Excellent this is exactly the type of advice I was looking for (finding out where I failed to use fmap)
18:42:56 <Axman6> is flatten not just concat?
18:43:07 <halogenandtoast> ... probably
18:43:13 <halogenandtoast> hoogling
18:43:16 <Axman6> :t concat
18:43:18 <lambdabot> Foldable t => t [a] -> [a]
18:43:19 <halogenandtoast> yes
18:43:31 <Axman6> great. nice work implementing it using foldr though
18:43:55 <Axman6> (the usual definition is foldr (++) [], and (++) xs ys is foldr (:) ys xs
18:43:59 <halogenandtoast> Yeah I'm not going to take credit for that, it was copied, then made pointfree
18:45:07 <Axman6> is render from the curses library?
18:45:11 <byorgey> halogenandtoast: the whole  case () of () | ...  thing can now be done as   if | ...   using the MultiWayIf  extension
18:45:14 <halogenandtoast> Axman6: yes
18:45:46 <halogenandtoast> byorgey: Looking it up, technically I'd like to get rid of the cond style, but I couldn't think of anything better
18:46:06 <byorgey> halogenandtoast: well, sometimes that's exactly what you need
18:46:38 <Axman6> yeah I was thinking about using some Alternative based thing, but it wouldn't be any shorter or clearer
18:47:35 <Axman6> halogenandtoast: you might find the brick library interesting btw, makes writing curses based interfaces really nice (probably overkill here, but cool to know about)
18:49:35 <halogenandtoast> Axman6: yeah, that's good to know about. technically I'm just using ncurses to get a portable clear screen.
18:50:02 <halogenandtoast> (or more portable than `system "clear"`)
18:50:16 <Axman6> heh yeah
18:50:48 <Axman6> I write a really simple twitter client using it which had a thread streaming in tweets and another updating the screen
18:51:22 <MarcelineVQ> Axman6: brick is vty based isn't it? is vty ncurses based or just curselike?
18:51:28 <Axman6> halogenandtoast: nice work, it's all really clear
18:51:37 <Axman6> btick is based on the vty library
18:51:40 <halogenandtoast> Axman6: Thanks I really appreciate it!
18:53:36 <halogenandtoast> I've implemented your feedback, happy to delete some lines.
18:54:10 <halogenandtoast> now I need to look at the MultiWayIf extension
18:55:19 <halogenandtoast> Well that was really easy
18:55:26 <Axman6> it's pretty simple, gives you suntax like if | foo == bar = baz | foo == quux = fail "blah"
18:56:01 <Axman6> can't remember if it enforces a true case or not? might fail at runtime I think
18:56:10 <Axman6> just like guards
18:56:18 <halogenandtoast> Axman6: close it uses -> instead of =
18:56:59 <athan> multi-branch if or something?
18:57:45 <halogenandtoast> athan: maybe this will make it clear: https://github.com/halogenandtoast/all_the_sokobans/pull/1/commits/e3b2cba1357a8f563db966fe5f9ffe139eda6bbc
18:58:19 <athan> it's an extension iirc, MultiWayIf I think :s
19:23:35 <athan> Does anyone here know if Oleg is authoring a next revision of HList? (They're the author, correct? :s)
19:26:34 <dfeuer> athan, HList is not a practical library. It's an experiment. The best way to use it is usually copy/paste.
19:26:47 <dfeuer> Or better, read/understand/rewrite-for-yourself.
19:27:01 <dfeuer> But that's just my opinion.
19:30:15 <athan> Ahh right on, thanks dfeuer.
20:08:56 <EvanR> > sin (2017 * 2**(1/5))
20:08:59 <lambdabot>  -1.0
20:09:03 <EvanR> haha
20:09:28 <newsham> does that mean 2017 is gonna be worse than 2016?
20:13:44 <sshine> quantitatively.
20:20:11 <geppettodivacin> Is there any way to store things of several different types, then retrieve it by using the proper type signature?
20:20:33 <geppettodivacin> Something like retrieve :: TypeMap -> Just a
20:21:03 <geppettodivacin> There would be only one thing stored of any given type.
20:21:52 <c_wraith> geppettodivacin: you could easily implement such a thing with Data.Dynamic
20:22:01 <sshine> geppettodivacin, data TypeMap = TypeMap { retrieveFoo :: Foo, retrieveBar :: Bar, ... } ?
20:24:30 <geppettodivacin> c_wraith: I've never heard of Dynamic before. Is there any resource besides the Haddocks that you'd recommend?
20:24:51 <c_wraith> Not really.  The haddocks cover it pretty completely.
20:25:02 <c_wraith> Data.Dynamic in base
20:25:34 <sshine> geppettodivacin, googling a bit: https://kseo.github.io/posts/2014-02-03-data-typeable-and-data-dynamic-in-haskell.html
20:26:10 <geppettodivacin> OK, sure. Thanks!
20:26:21 <D0TWav3> Hello is anyone active in this channel?
20:26:43 <D0TWav3> Bye.
20:26:52 <D0TWav3> Hi
20:26:58 <D0TWav3> Whats up.
20:27:28 <D0TWav3> Hey FreeBirdLjj
20:27:38 <D0TWav3> Hey is anyone here?
20:27:40 <geppettodivacin> c_wraith: Yeah, that looks like just what I was looking for. Thanks!
20:27:59 <D0TWav3> geppettodivacin What?
20:28:02 * sshine isn't sure when Data.Dynamic is ever preferrable.
20:28:59 <geppettodivacin> sshine: I'm trying to implement an Entity Component System framework, mostly for fun but I might use it for a game later on.
20:29:22 <sshine> geppettodivacin, ok!
20:29:25 <D0TWav3> Anyone active and want to talk to me. I am board
20:29:33 <D0TWav3> Whats up sshine.
20:29:47 <sshine> geppettodivacin, I don't make enough practical code like that to really know. :)
20:29:55 <Rotaerk> D0TWav3, this channel is pretty much exclusively on-topic, and the topic is haskell
20:30:09 <Rotaerk> (and some peripheral subjects)
20:30:11 <sshine> D0TWav3, we're not really here for your entertainment.
20:30:12 <geppettodivacin> I've done it before in C, and I've looked at Java implementations, and they usually have some kind of world with arrays of components, but the components can be of various types.
20:30:58 <koala_man> what's a good way to implement something like an AST where you have dozens of node types, and you want to be able to e.g. traverse the tree without writing traversal code for each node?
20:31:26 <D0TWav3> Hey Who knows Java or c++
20:31:29 <sshine> koala_man, you could write some generic traversal functions for your AST.
20:32:15 <geppettodivacin> There might be a more type-safe way, but my best guess was to store the components in one such map, then to simply use the signature for the component I needed to retrieve.
20:33:03 <koala_man> sshine: I might have data Node = Add Node Node | Negate Node | ... How do I avoid writing one piece of generic traversal code for each?
20:33:50 <c_wraith> geppettodivacin: http://lpaste.net/350333 is a start
20:33:55 <koala_man> I could do Node = Node Op [Node], data Op = Add, but then I lose argument count
20:34:21 <sshine> koala_man, it depends on what you want to achieve with these traversals, I suppose. I had access to some code like this in an optimizing compiler once I'd like to point at, but it's not available at this moment.
20:34:31 <D0TWav3> koala_man what language are you talking about? 
20:34:47 <koala_man> D0TWav3: Haskell
20:35:04 <D0TWav3> Oh my gosh I thought I was in somehting else. I am so smart....
20:35:30 <D0TWav3> Well koala_man have a good day and all of you guys where ever you are!!!!
20:37:08 <sshine> koala_man, so maybe all of your traversals involve knowing the current variables and their types in a scope, some traversals will transform expressions, some will annotate parts of the AST, etc.
20:37:47 <geppettodivacin> c_wraith: That actually looks really good. I'm working on poking around through some documentation so I can understand it all! But that's definitely helpful.
20:38:08 <c_wraith> geppettodivacin: yeah, I figure you'll want deleting and such - but it's a place to get you started
20:38:48 <koala_man> sshine: right now I want to determine types and reachability. I have existing, laboriously written code that just matches expression
20:38:49 <sshine> koala_man, so it'd be neat with a function that took into account the entire AST when traversing, but allowing for the relevant parts of handling that traversal to be overridden by some function. e.g. a fold across an AST to handle variable declarations, or whatnot.
20:39:36 <koala_man> well actually no, right now I just want to be able to e.g. replace one instance with something else everywhere
20:39:54 <koala_man> simple local transformations
20:45:04 <kevster9108> Helloworld
20:45:19 <c_wraith> heh.  I just noticed you can do let x = toDyn x to get a circular Dynamic that points to itself and can be indefinitely unwrapped into itself
20:45:19 <EvanR> geppettodivacin: theres something called a dependent map, which you can hack together in haskell
20:45:34 <EvanR> Dynamic is checked at runtime
20:45:45 <EvanR> dependent map is checked at compile time
20:46:41 <EvanR> it would be a lot nicer with dependent types ;)
20:47:03 <geppettodivacin> EvanR: That sounds better, actually.
20:50:21 <geppettodivacin> Although it looks complicated from the documentation.
20:51:51 <EvanR> this was in my head, i dont know what particular implementations there are
20:52:11 <EvanR> theres another way to do what you are saying though
20:53:00 <EvanR> instead of having a bunch of maps each with a different key->type mappings, you group all fields of a certain type into a set of maps each having one value type
20:53:12 <EvanR> possibly more than one map of a given type
20:53:22 <EvanR> then you dont need fancy type shenanigans
20:54:11 <EvanR> for instance, if you decide its possible to look at the database and get a record of type {a:A, b:B, c:C, d:D} you build that by looking at four maps containing A B C and Ds
20:56:11 <geppettodivacin> EvanR: I'm not sure how to apply what you just said to what I'm doing. I want a type -> value mapping, as opposed to a key -> type mapping.
20:57:58 <geppettodivacin> And I'm also not sure how to get a heterogeneous structure of Maps, one with A, B, C, and D, dynamically.
20:58:20 <EvanR> (Map k A, Map k B, Map k C, Map k D)
20:58:25 <EvanR> or just 4 different maps
20:58:35 <EvanR> not everything needs to be in the same structure
20:59:00 <EvanR> you also wouldnt need to pull out whole records if you only want part of something
20:59:29 <EvanR> for example, if a bunch of "heterogeneous things" all have the position property, you have
20:59:38 <EvanR> positions :: Map k Position
21:00:25 <EvanR> type -> value doesnt make much sense to me
21:00:28 <geppettodivacin> Oh, and k is polymorphic.
21:00:36 <EvanR> no k is the "object ID type"
21:01:00 <geppettodivacin> OK, right.
21:01:36 <EvanR> you can also have indexed like spatialIndex :: Map Region [ObjectID]
21:01:40 <EvanR> indexes*
21:02:11 <EvanR> well, spatial index probably has a better data structure but the functionality would be the same
21:03:22 <geppettodivacin> Sure. Thanks for your input, too, EvanR!
21:14:16 <dfeuer> edwardk?
21:17:34 <jle`> c_wraith: cute
22:25:32 <halogenandtoast> This is probably useless, but is there any way to make this point free `isPlayerOnStorage level move = isStorage level move && isPlayer level move`
22:25:44 <halogenandtoast> without using `ap`
22:28:33 <kadoban> Probably not without ap
22:29:17 <halogenandtoast> Hmm I was hoping for something clearer than `isPlayerOnStorage = ap (ap . ((&&) .) . isStorage) isPlayer` guess I'm not making this point free
22:30:47 <halogenandtoast> I was really hoping I could use `all` somehow with a list [(a->b->c)] maybe using rank n types
22:30:56 <halogenandtoast> But I have no idea what I'm actually saying
22:31:51 <kadoban> It's almost   liftA2 (&&) isStorage isPlayer , but it's not.  Do you have a lot of functions of this form, where you're passing the level and the move about as state?
22:32:08 <halogenandtoast> kadoban: yes
22:32:37 <halogenandtoast> kadoban: most of them look something like `isCrate level@Level{crates} = (`elem` crates)`
22:33:03 <kadoban> Reader could possibly be a good fit. I'm not sure if that's a good idea or not.
22:33:59 <kadoban> The idea is to save you having to pass the same envirornment around explicitly again and again though, which sounds like what you want.
22:34:29 <halogenandtoast> kadoban: this is what the code looks like: https://github.com/halogenandtoast/all_the_sokobans/blob/e3b2cba1357a8f563db966fe5f9ffe139eda6bbc/haskell/src/Main.hs
22:34:49 <halogenandtoast> You can see most of the isX functions have that format of Level -> Coord -> Bool
22:36:26 <halogenandtoast> I'll look into the Reader monad, haven't used it for anything yet
22:37:10 <kadoban> I'm not really sure just looking at it, I'd have to experiment with it both ways probably to tell. Maybe someone more experienced would have a better intuition if you should use Reader or State or something like that or not.
22:38:39 <kadoban> Sure does look like a lot of passing around the same info though, so I'd likely try it if it were my code.
22:38:41 <Rotaerk> hmm wouldn't that be:  isPlayerOnStorage = (liftA2 . liftA2) (&&) isStorage isPlayer
22:39:19 <kadoban> Hmm, does that work? Maybe
22:39:23 <halogenandtoast> checking
22:39:45 <Rotaerk> the original is a bit more readable though
22:40:29 <geekosaur> :t (liftA2 . liftA2) (&&) ?isStorage ?isPlayer
22:40:30 <lambdabot> (?isStorage::f (f1 Bool), ?isPlayer::f (f1 Bool), Applicative f1, Applicative f) => f (f1 Bool)
22:40:35 <halogenandtoast> it compiles
22:41:08 <halogenandtoast> Yes it works
22:41:24 <halogenandtoast> What is the ? there doing?
22:41:41 <halogenandtoast> oh nvm
22:43:00 <halogenandtoast> I do agree that the original is more easily read, so I'll leave it be, but it's interesting to see liftA2 at work.
22:46:48 <geekosaur> implicit parameters. here, a hack to use an undefined name and get it to spit out its inferred type as part of the result type's context
22:47:04 <geekosaur> rtaher convenient when noodling around with lambdabot
22:47:07 <geekosaur> *rather
22:51:04 <kadoban> I gotta learn me some ghc8 lambdabot tricks
22:51:08 <kadoban> I assume that's ghc8, right?
22:53:37 <geekosaur> implicit params go back at least to 6.6
22:54:18 <geekosaur> (at the time there were also linear implicit params, but nobody ever found a good use for them and they went away eventually)
22:54:36 <geekosaur> :t %foo
22:54:38 <lambdabot> error: parse error on input ‘%’
22:55:04 <geekosaur> heh. mueval in the way...
22:55:27 <geekosaur> hm, guess they don't even warn any more
22:56:17 <geekosaur> some other ancient stuff still gets you errors that the functionality went away
22:56:51 <geekosaur> but I guess here that would be camping on syntax for no good reason
23:01:28 <halogenandtoast> Is the "standard" style to have two empty lines between function definitions?
23:01:31 <halogenandtoast> Or is it 1 now
23:04:41 <clinton_> I've been trying to write a type signature for the function `g` in the code linked any help appreciated: http://ideone.com/DH9Df0
23:05:51 <EvanR> halogenandtoast: random
23:24:00 <dmwit_> clinton_: g :: (forall s. T (ST s)) -> D -- is one
23:30:28 <dmwit> not very satisfying, though
23:30:34 <dmwit> Since the type doesn't mention C. =)
23:31:26 <dmwit> I suspect you will have to add ST's phantom parameter to your type class if you want this to work.
23:42:13 <Axman6> @hoogle (a -> b) -> (b -> c) -> (a -> c)
23:42:15 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
23:42:15 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
23:42:15 <lambdabot> Data.GI.Base.ShortPrelude (.) :: (b -> c) -> (a -> b) -> a -> c
23:42:23 <dmwit> :t (>>>)
23:42:24 <lambdabot> forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
23:42:32 <Axman6> ah yes, thanks
23:47:33 <clinton_> @dmwit:yes, I want it to work for all data which is an instance of `C` that works in the `ST` monad, not just the particular example I've given here.
23:47:33 <lambdabot> Unknown command, try @list
23:47:50 <clinton_> @dmwit: but good start!
23:47:50 <lambdabot> Unknown command, try @list
23:48:01 <dmwit> skip the @
23:48:08 <clinton_> will do
23:48:20 <phanimahesh> Is there another way to write \(x,y) -> x == y ? I know there is, but can't come up with one atm.
23:48:28 <dmwit> :t uncurry (==)
23:48:30 <lambdabot> Eq a => (a, a) -> Bool
23:48:35 <dmwit> ?pl \(x,y) -> x == y
23:48:35 <lambdabot> uncurry (==)
23:48:50 <phanimahesh> Ah. yep. Thanks.
23:59:29 <phanimahesh> I'm comparing two lists with all (uncurry (==)) $ zip xs ys. I know I can do and $ zipWith (==) xs ys. Any other simple ways?
