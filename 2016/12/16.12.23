00:15:44 <jophish> how can I construct a traversal visiting the second and third elements of a three tuple?
00:18:08 <cocreature> jophish: you need a newtype that forces the last two type arguments to be equal, otherwise it has the wrong kind
00:18:59 <jophish> cocreature: 'both' manages to do this
00:19:51 <cocreature> jophish: oh you are talking about lens Traversals. for some reason I thought of instances of Traversable
00:20:36 <jophish> oh, yes. sorry, I should have said
00:20:45 <cocreature> give me a minute :)
00:22:14 <cocreature> jophish: how about lastTwo f (c,a,b) = (\a' b' -> (c,a',b')) <$> f a <*> f b
00:22:28 <jophish> well, my actual problem is a little more involved. I have a (a, [b], [b]) and need a traversal visiting all the bs. I'll try working it out from that
00:22:31 <jophish> thanks cocreature!
00:23:10 <bollu> does python have an API for ASTs?
00:23:10 <bollu> (offtopic I suppose)
00:23:19 <cocreature> jophish: "lastTwo . each" should work I think
00:24:39 <cocreature> at least it seems to work for me™
00:26:41 <jophish> cocreature: sorry, it was a little different [(a, [b], [b])]. I'm using (traverse . lastTwo . traverse)
00:27:35 <cocreature> ah ok
00:28:12 <jophish> thanks for the help :)
00:28:19 <cocreature> np
00:40:53 <bollu> is there some way to "verify" C code?
00:40:56 <bollu> I have a shell that I've written
00:41:01 <bollu> and I'd like to prove that it works
00:41:08 <bollu> but I don't want to rewrite the same thing again
00:41:11 <bollu> so, like
00:41:20 <bollu> is there some way to embed let's say pre and post conditions in C
00:41:22 <bollu> or things like that?
01:04:25 <Wizek> Hey, anyone knows what `mdo` (`{-# language RecursiveDo #-}`) desugars into? Example: https://gist.github.com/Wizek/3043e3e93eddcec00867113c4ad1d35f And/or how can I write the same with `bind`s?
01:05:20 <opqdonut> Wizek: mfix, see https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad-Fix.html
01:06:46 <Wizek> thanks opqdonut, taking a look
01:06:49 <opqdonut> so I would guess that's something like "mfix (~(x,y) -> return (2:y) >>= \x' -> return (3:x) >>= \y' -> print (take 10 x') >>= return (x',y')
01:14:14 <petercommand> Wizek: also lookup https://wiki.haskell.org/MonadFix
01:16:32 <Wizek> opqdonut, Yeah, that's getting closer. Here is the closest I got based on your example: https://gist.github.com/Wizek/3043e3e93eddcec00867113c4ad1d35f#file-2-attempts-to-desugar-hs-L28
01:17:47 <Wizek> opqdonut, And still it halts with an exception: "[2Main.hs: thread blocked indefinitely in an MVar operation"
01:19:25 <opqdonut> Wizek: hmm
01:23:12 <opqdonut> Wizek: ah I got the recursion scope wrong
01:24:29 <opqdonut> Wizek: commented on your gist
01:27:54 <Wizek> opqdonut, hmm interesting. Thanks!
01:32:01 <haskell20020> To write a function with type `K f => (f a -> f b) -> f (a -> b)`, what constraint should K be?
01:33:15 <haskell20020> Does a suitable typeclass exist or would you have to a new one?
01:33:28 <jle`> haskell20020: are you asking about a typeclass that's already commonly used?
01:34:08 <haskell20020> Well a commonly used one or a more rare one if it's got an agreed upon definition
01:34:39 <haskell20020> Also unrelated, I love your blog
01:35:05 <jle`> oh haha, thanks :)
01:35:16 <jle`> um i can't think of a nice typeclass fitting that at the moment
01:36:12 <jle`> what are you planning on using this eventually for?  just as a thought experiment?
01:36:19 <haskell20020> Just a thought experiment
01:36:38 <haskell20020> I'm sure I could invent a problem for it to solve though
01:36:38 <jle`> it's possible if f is both a Monad and a Comonad i suppose
01:36:44 <jle`> hm
01:37:50 <lyxia> then you could just get (a -> b) out of it though
01:38:09 <haskell20020> factor f = pure $ extract . f . pure
01:38:26 <haskell20020> I think that would be it, but that doesn't seem super useful
01:40:09 <lyxia> K = (~) Identity
01:40:46 <haskell20020> Also unrelated question because I have the Neural Net+Dependent Types blog post open, @jle would you recommend using dependently types in haskell/idris using c bindings to a fast library or python w/ tensorflow for someone who's creating a project with their first Neural Net
01:40:47 <haskell20020> Hah 
01:40:54 <haskell20020> That would certainly do it
01:41:37 <jle`> i'm not sure i'd recommend that as a first neural net project
01:41:41 <haskell20020> *dependent types in haskell
01:41:41 <jle`> but maybe a second or third :p
01:41:48 <haskell20020> Yeah, I figured
01:41:57 <tsahyt> Are there any ongoing efforts to change the explicit .. -> IO a things in base to MonadIO m => .. -> m a?
01:42:08 <haskell20020> Also I live with a python guru who offered to learn this with me
01:42:11 <tsahyt> I find myself using liftIO a lot lately
01:42:44 <jle`> haskell20020: also, it's good to resist the temptation to turn everything you write for a project into a 'library'/'engine', heh
01:42:56 <jle`> like the common trap of "i need to write a game.  oh first i'll write a game engine"
01:43:09 <haskell20020> @tsahyt isn't MonadIO not in base?
01:43:09 <lambdabot> Unknown command, try @list
01:43:15 <tsahyt> haskell20020: it is in base
01:43:17 <haskell20020> tsahyt: isn't MonadIO not in base?
01:43:28 <jle`> haskell20020: but a dependently typed wrapper over an ad-hoc neural network implementation is probably fine
01:43:31 <jle`> for a first project
01:43:40 <jle`> the dependent types would only really help guide your implementation/usage
01:43:41 <tsahyt> haskell20020: I don't know since when, but it's there in 4.9.0.0
01:43:44 <tsahyt> possibly earlier than that
01:43:49 <haskell20020> Oh yeah, hoogle lied to me
01:43:50 <jle`> assuming you're familiar enough that it doesn't get in the way
01:44:11 <tsahyt> apparently it got added with 4.9.0.0
01:44:26 <jle`> if you're familiar enough with working w/ dependent types in haskell, then an ad-hoc neural network implementation for your project is probably going to be better w/ dependent types on top of it
01:44:41 <tsahyt> but now that it's there, I think it'd be nice to have all the IO stuff work on MonadIO rather than just plain old IO
01:44:56 <tsahyt> possibly with a SPECIALIZE pragma
01:46:07 <jle`> haskell20020: btw a similar problem to your puzzle from before, https://github.com/quchen/articles/blob/master/loeb-moeb.md
01:46:39 <jle`> gotta love an article that leads a section with "Feeling smart? Let's change that"
01:48:23 <haskell20020> I have actually read it
01:48:36 <haskell20020> The question is have you read this paper: https://github.com/kwf/GQFC
01:48:38 <haskell20020> :)
01:49:47 <jle`> that's a fun one ;)
02:00:46 <somewone> given a Maybe [a] how do I retrieve the first element using Lenses ? 
02:03:32 <lyxia> compose lenses for Maybe and lists.
02:10:07 <dibblego> > Just [1,2,3] ^? _Just . _head
02:10:10 <lambdabot>  Just 1
02:10:15 <dibblego> > Just [] ^? _Just . _head
02:10:18 <lambdabot>  Nothing
02:10:23 <dibblego> > Nothig ^? _Just . _head
02:10:25 <dibblego> > Nothing ^? _Just . _head
02:10:27 <lambdabot>  error:
02:10:27 <lambdabot>      • Data constructor not in scope: Nothig :: Maybe a0
02:10:27 <lambdabot>      • Perhaps you meant one of these:
02:10:31 <lambdabot>  error:
02:10:31 <lambdabot>      • Could not deduce (Cons a0 a0 a1 a1)
02:10:31 <lambdabot>        from the context: Cons a a a1 a1
02:14:28 <somewone> awesome, thank you so much =) ! I was unable to figure it out myself.
02:18:00 <Wizek> > let f = (^? non [] . _head) in (f Nothing, f $ Just [], f $ Just [1])
02:18:01 <Wizek>  -- dibblego 
02:18:03 <lambdabot>  (Nothing,Nothing,Just 1)
02:22:40 <quchen> jle`: I’m not sure I should have written it in that way, doesn’t it sound a bit smug?
02:40:10 <ptek> Is here someone who has used the req library? Or maybe Mark Karpov is around? I want to download a file from a service with a self signed certificate and can't don't understand how to make it work...
02:43:59 <jaspervdj> ptek: req is supposed to be a "simple" library.  From a quick look at the API, it doesn't look like you can tweak the TLS settings unfortunately.
02:50:07 <ptek> jaspervdj, I see. I thought that there is a way to overlap the def instance for the HttpConfig (https://github.com/mrkkrp/req/blob/master/Network/HTTP/Req.hs#L472), but it looks like a hack to me and I don't know if it will even work...
02:50:40 <ptek> jaspervdj, do you maybe have a favourite library in mind for doing http(s) requests?
02:51:11 <jaspervdj> ptek: Hang on, looking at the source code it looks like it might be possible -- one sec
02:51:12 <aesquembre> stupid question: if I can use deriving when defining a data type, what are instances of type classes for?
02:51:46 <jaspervdj> aesquembre: You can only derive certain type classes.  Most typeclasses you need to write an instance for by hand.
02:52:37 <aesquembre> jaspervdj: so I can't derive my own typeclasses?
02:53:16 <jaspervdj> ptek: The interface is a bit weird.  But it looks like you can do it by adding your own monad which is an instance of 'MonadHttp'
02:54:13 <jaspervdj> aesquembre: There are a few exceptions to the rule so maybe you can derive them.
02:54:28 <ptek> jaspervdj: oh, yes. Now I seem to understand... I am writing the `instance MonadHttp IO where` anyway
02:54:39 <ptek> jaspervdj: thank you!
02:54:41 <jaspervdj> aesquembre: 1. If your datatype is a newtype you can always use GeneralizedNewtypeDeriving
02:54:57 <jaspervdj> aesquembre: 2. You can write TemplateHaskell code to derive the instance
02:55:07 <jaspervdj> aesquembre: 3. You can use GHC Generics to derive the instance
02:55:22 <jaspervdj> aesquembre: 2 and 3 require a bunch of boilerplate so it might not be worth it.
02:56:43 <jaspervdj> ptek: `instance MonadHttp IO` is a bit "dirty" because it's an orphan instance.  I would recommend using a newtype around IO instead, like `newtype MyPackageHttpM` or something like that
03:00:43 <seishun> is there any way to simplify something like `\r -> r { field = field r + 2 }`?
03:00:57 <opqdonut> lenses
03:01:08 <seishun> or `(a, b) -> (a + 2, b)`
03:01:48 <aesquembre> jaspervdj: I see, many thanks
03:02:01 <opqdonut> the lensy version of that would be "r & _field %~ (+2)" or so
03:02:21 <opqdonut> or actually "r & _field +~ 2"
03:03:29 <jophish> seishun: an alternative is to make a custom function to increment field
03:03:48 <ptek> jaspervdj: right. May I ask, what would be the difference between IO and the newtype wrapping IO in practice? I would have to manage the IO Exceptions, when "lifting" the IO computations into MyPackageHttpM right? In hakyll you seem to also use Rules as a "wrapper" around IO with other capabilities. Is this the way to think about it?
03:04:24 <jophish> it's just as complicated underneath, but the user code might be cleaner
03:06:28 <jaspervdj> ptek: I'm not sure what you mean by "manage the IO Exceptions".  It's more of a way to be a bit cautious around instances.  Some other package you depend on might also have an `instance HttpMonad IO` and then things can go wrong unexpectedly.
03:09:04 <ptek> jaspervdj: oh. I see. Would this be the main reason to try to avoid orphaned instances?
03:10:21 <jaspervdj> ptek: Yes, conflicting instances is the main reason
03:28:17 <eklavya> when simply calling stack build, is ghc using all available cores for compiling?
03:28:34 <eklavya> I see 4 threads but only using max 99% CPU
03:30:40 <quchen> 99% CPU is plenty. You also have an operating system to run along your build :-)
03:31:39 <MarcelineVQ> stack will start multiple jobs if it needs to, such as when building dependencies, which can quickly tie up cpu and ram. for a single thing though I'm not sure what kind of resource impact is typical
03:31:50 <Cale> quchen: I think the assumption is that the number would be something closer to 400%
03:32:21 <quchen> Builds for single packages are single core, I think.
03:32:49 <eklavya> Cale: yes
03:33:32 <eklavya> quchen: so you mean only 1 of those 4 threads is actually busy?
03:34:32 <quchen> Yes. Stack builds packages in parallel, and modules of a package sequentially.
03:34:49 <quchen> There’s a GHC flag you can pass to it to have parallel module builds though.
03:36:29 <quchen> Hmm, the manual says that »-jN« works only when building with »--make«.
03:38:33 <eklavya> quchen: I have never seen more than 99% usage though, have I always had linear dependencies? (no packages were availble for parallel building)
03:39:15 <quchen> That sounds strange. My builds almost always run on all cores.
03:39:42 <quchen> And then when the dependencies are almost built, single cores start to drop out, until my package is built on a single one.
03:39:44 <Profpatsch> I still don’t get rank2/ntypes.
03:39:52 <MarcelineVQ> hmm stack build --ghc-options="-j9" definitely used more cpu on my 24 modules project, dunno if it was faster
03:39:59 <quchen> But I don’t remember ever seeing full single-core builds for pretty much anything.
03:40:00 <Profpatsch> Or, wait.
03:40:21 <Profpatsch> data Foo f = forall a => Foo f a
03:40:25 <Profpatsch> Is that an existential?
03:40:51 <Profpatsch> s/ =>/./
03:40:53 <mniip> more like universal
03:42:08 <Profpatsch> As compared to data Foo f = Foo (forall a. f a)
03:42:53 <Profpatsch> Okay, the second doesn’t seem possible.
03:43:05 <Profpatsch> Only when it’s a function.
03:44:53 <dibblego> the position of forall makes a significant difference
03:44:58 <Profpatsch> I know
03:45:14 <Profpatsch> Inside the constructor it’s a RankN, outside an Existential
03:45:29 <dibblego> yes, in these cases
03:46:39 <Profpatsch> My intuition is: data Foo f = forall a. Foo f a  means: the user can put any a, but the library write cannot use it in any way.
03:47:07 <Profpatsch> But I fail to understand how that is useful in any way.
03:47:59 <Profpatsch> Hm, can this be used to state: I accept something of this type, but I will never use it internally?
03:48:11 <Profpatsch> My example is https://hackage.haskell.org/package/digestive-functors-0.8.1.0/docs/src/Text-Digestive-View.html#View
03:49:39 <jaspervdj> Profpatsch: Exactly, you can never use the `a` is a good way to informally describe it
03:50:09 <Profpatsch> jaspervdj: Do you have `digestive-functors` set to hilight in your client? :)
03:50:29 <jaspervdj> Profpatsch: You can still use functions that don't use the `a` though.  So if you had something like `forall a. Foo [a]` you can still use `length` on the list.
03:50:58 <jaspervdj> Profpatsch: Nah I was just around :-)
03:51:29 <Profpatsch> jaspervdj: So for Views you state: give me a Form of this form (heh), the View will not use the m or the a
03:52:39 <Profpatsch> Would it work without the forall?
03:52:40 <jaspervdj> Profpatsch: Pretty much.  It's a bit more complicated since we have `Monad m =>`.  This means you can still use bind and return on `m`.  But you can't go messing around with `a`
03:53:13 <Profpatsch> Except there is no guarantee of usage?
03:53:19 <Profpatsch> *non-usage
03:53:35 <jaspervdj> Profpatsch: Without the `forall`, the `a` and `m` would have to appear on the left-hand-side of the type, so `data View v m a = ...`
03:53:43 <Profpatsch> Oh, right.
03:53:57 <Profpatsch> then it would just be `digestive`
03:54:01 <jaspervdj> Which makes the types more complicated.  I think that's why I used that.  It's been a long time since I wrote that code though.
03:54:51 <Profpatsch> So, I understand that Existentials are to tell the user: that type can never use the type arguments.
03:55:00 <Profpatsch> Except for the classes explicitely given.
03:55:28 <Profpatsch> But then there’s the question how that’s different to RankNTypes
03:56:12 <Profpatsch> If I have data Bar = Bar (forall a. Show a => a
03:56:16 <Profpatsch> )
03:56:32 <Profpatsch> What does that mean for the library author?
03:57:09 <jaspervdj> Profpatsch: Existentials are somewhat related to RankNTypes
03:57:12 <Profpatsch> Oh, I have an idea.
03:57:24 <Profpatsch> I can’t seem to construct a value of Bar
03:57:35 <jaspervdj> Profpatsch: Informally: (less powerfull) Existentials < Rank2Types < RankNTypes (more powerfull)
03:57:48 <Profpatsch> Bar True throws
03:57:52 <Profpatsch>  Couldn't match expected type ‘a’ with actual type ‘Bool’
03:58:35 <Profpatsch> But then, how could I use that?
04:02:11 <nshepperd1> That's not an existential, it's a universal
04:02:57 <nshepperd1> Existential would be data Bar = forall a. Show a => Bar a
04:03:17 <Profpatsch> nshepperd1: Yes, of course.
04:03:21 <nshepperd1> Then you should be able to make Bar True
04:03:32 <Profpatsch> But I’m asking about RankNTypes specifically.
04:03:41 <Profpatsch> In order to understand the difference to Existentials.
04:04:09 <Profpatsch> Do RankNTypes make sense without functions?
04:04:31 <opqdonut> Profpatsch: no
04:04:33 <nshepperd1> Well, forall a. Show a => a would be something that can be all showable types
04:04:41 <Profpatsch> Like data Bar = Bar (forall a. Show a => a -> String)
04:04:45 <opqdonut> Profpatsch: but remember that constructors are functions
04:05:01 <Profpatsch> Bar (\x -> show x ++ "foo")
04:05:09 <opqdonut> Profpatsch: so Bar :: (forall a. Show a => a -> String) -> Bar
04:05:19 <opqdonut> which is Rank2
04:05:20 <nshepperd1> Which is impossible since Show only has functions for destructing values
04:05:42 <Profpatsch> nshepperd1: Oh, so it’s possible with e.g. Monoid?
04:06:08 <nshepperd1> Yes. Or Read or Num 
04:06:12 <Profpatsch> Oh, cool.
04:06:14 <nshepperd1> Etc
04:06:19 <Profpatsch> data Bar = Bar (forall a. Monoid a => a)
04:06:22 <Profpatsch> Bar mempty
04:06:33 <nshepperd1> Yup
04:06:53 <Profpatsch> But that’s very close to existentials again.
04:07:00 <Profpatsch> Where’s the difference to e.g.
04:07:19 <Profpatsch> data Foo = forall a. Monoid a => Foo a
04:07:46 <Profpatsch> As a user I can construct a Foo if a is a Monoid
04:08:02 <Profpatsch> And as a library I can use only Monoid functions on the a
04:08:44 <Profpatsch> Is there any other difference?
04:09:41 <Profpatsch> -other
05:29:17 <quchen> Isn’t »data Bar = Bar (forall a. Monoid a => a)« an impredicative type, rather than rank-2?
05:34:27 <werner291> Hi, is it ok to ask beginner questions here?
05:34:54 <Akii> sure, but there is also #haskell-beginners
05:35:18 <werner291> Ah, thanks. Lemme check that out
05:46:54 <Profpatsch> quchen: I do need Rank2 in ghci
05:47:26 <quchen> Oh, the function arrow makes it rank-2. I think Bar (forall a. a) would be impredicative then.
05:47:34 <quchen> merijn would know more about this, but he’s not here
05:48:47 <jaspervdj> quchen: Yes I think it's impredicative
05:50:28 <quchen> What’s a bit strange then is that an unparametrized constraint allows us to create an impredicative type using only rank-2 polymorphism, no?   Bar (forall a. Unit => a)   looks impredicative as well
05:51:01 <ertes> quchen: no, an impredicative type is when you use a quantifier within a type *argument*
05:51:10 <ertes> quchen: Maybe (forall a. …)
05:52:03 <quchen> ertes: I don’t understand why my forall. isn’t an argument (to Bar)
05:52:21 <ertes> quchen: as far as i see your Bar type doesn't take an argument
05:54:16 <jaspervdj> ertes: So this is impredicative, right? `data Bar a = Bar a`, `foo :: Bar (forall a. ...)`
05:55:11 <ertes> yeah
05:55:55 <quchen> ertes: Bar (argument to Bar here)   ← no?
05:56:24 <ertes> quchen: i didn't realise you implicitly redefined Bar =)
05:56:25 <jaspervdj> quchen: It's different when you're talking about the datatype definition
05:56:41 <ertes> your initial definition was:  Bar :: *
05:59:01 <ertes> that's why shadowing can be evil =)
06:00:53 <mekeor`> in theoretical observation of the most outer level of haskell code, could you say it just consists of three sorts of things? (1) evaluation definition. in math, you'd write "x |-> y". (2) type signatures. "value x has type T". (3) type definitions. in haskell: "data T = X1 | X2". in math maybe "T := { X1, X2 }".
06:02:44 <mekeor`> (item (1) might_be/is badly/wrongly expressed)
06:17:36 <jaspervdj> mekeor`: If you squint hard enough you can cast it as something like that yeah, but it's not very formal.  There's loads of extra stuff like typeclasses/instances which sort of mix 1 and 2.
06:18:03 <mekeor`> oh yeah, i forgot type classes
06:18:39 <seishun> how can I find the monad instance for lists?
06:19:05 <mekeor`> seishun: i think you can do maybe this:       :i []
06:19:14 <mekeor`> :i []
06:20:58 <seishun> hmm, shouldn't failed pattern match result in an empty list in list context?
06:23:37 <mekeor`> seishun: you mean, if you have a function "myFunc True = [1,2]" and then you do "myFunc False" somewhere and myFunc throws an exception? in that case you could add "myFunc _ = []" or something similar to the function definition of myFunc
06:23:58 <mekeor`> but maybe i totally got you wrong
06:24:40 <seishun> > do i <- [Just 5, Nothing]; let (Just foo) = i; return foo
06:24:42 <lambdabot>  <hint>:1:58: error:
06:24:42 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
06:26:45 <seishun> ...I hope the idea is clear because I have no idea how to fix the syntax
06:28:34 <quchen> seishun: Only pattern matching on the left of »<-« fails to the empty list.
06:28:52 <seishun> oh
06:29:10 <quchen> You could have written
06:29:25 <quchen> > do Just i <- [Just 5, Nothing]; return i
06:29:27 <lambdabot>  [5]
06:29:44 <quchen> See how the Nothing was ignored? That’s the failure mechanism you talked about.
06:29:57 <mekeor`> > do Just i <- [Nothing, Nothing]; return i
06:30:00 <lambdabot>  []
06:31:40 <seishun> it's a bit more complicated in my case, since I do a map lookup with that element
06:31:57 <kuribas> delYsid: ping
06:33:36 <seishun> it's more like `do i <- elems; let foo = i `lookup` myMap; (continue if foo is Just)`
06:34:58 <seishun> and I need both i and foo later
06:35:06 <Xnuk> interesting
06:38:38 <seishun> this works but it's ugly: `do (i, Just foo) <- zip elems $ map (`lookup` myMap) elems`
06:42:04 <siyu> hi may i ask why is there no Data.Attoparsec.ByteString.Lazy.Char8
06:43:10 <Profpatsch> Haddock is sadly oblivious to of packages.
06:43:17 <Profpatsch> -to
06:57:44 <lyxia> siyu: all functionality is provided by Data.Attoparsec.ByteString.Char8 already
07:00:30 <siyu> lyxia can u show an example of using endOfLine
07:02:50 <lyxia> siyu: line = manyTill anyChar endOfLine
07:04:11 <siyu> lyxia what is the type of this expression
07:04:17 <siyu> and what do u import
07:08:04 <lyxia> import Data.Attoparsec.ByteString.Char8 ; line :: Parser String
07:08:22 <lyxia> there are examples here BTW https://github.com/bos/attoparsec/blob/master/examples/
07:09:45 <siyu> hmm i get to make my code compiled
07:09:52 <siyu> thanks a lot
07:10:13 <siyu> but i still haven't understood the type
07:11:11 <lyxia> A value of type Parser String is a parser of string.
07:11:47 <quchen_> A parser »of string« could also mean that it processes strings as input.
07:12:02 <quchen_> I’d say it is a parser that converts something to a string.
07:22:19 <Profpatsch> #join haddock
07:22:30 <Profpatsch> whoops
07:28:00 <Profpatsch> WTF, it’s possible to create type aliases for type classes? https://hackage.haskell.org/package/ghcjs-dom-jsffi-0.7.0.1/docs/GHCJS-DOM-Types.html#t:ToDOMString
07:28:35 <quchen_> Profpatsch: Now that classes just have kind k -> Constraint it makes sense
07:28:58 <quchen_> It’s essentially the 1-tuple constraint :-)
07:29:08 <Profpatsch> What’s a type of kind Constraint?
07:29:24 <Profpatsch> This type-trickery is getting out of hand!
07:30:29 <quchen_> It’s not really trickery.
07:30:32 <quchen_> :k Int
07:30:34 <lambdabot> *
07:30:35 <quchen_> :k Monoid
07:30:37 <quchen_> :k Monad
07:30:38 <lambdabot> * -> Constraint
07:30:39 <lambdabot> (* -> *) -> Constraint
07:30:45 <quchen_> :k Monoid [Int]
07:30:46 <Profpatsch> :i Constraint
07:30:46 <lambdabot> Constraint
07:31:04 <quchen_> :k Monoid a
07:31:05 <lambdabot> error: Not in scope: type variable ‘a’
07:31:26 <quchen_> :k Monoid (Bool -> Char)
07:31:28 <lambdabot> Constraint
07:31:38 <Profpatsch> What are other types of Constraint, besides fully applied type classes
07:31:57 <quchen_> I’m pretty sure it’s only used for type classes.
07:31:58 <Profpatsch> And where can I read up on these special kinds?
07:32:12 <quchen_> -XConstraintKinds is the extension
07:32:19 <quchen_> The GHC manual probably has a section on it
07:32:24 <kuribas> :k CallStack
07:32:26 <lambdabot> error:
07:32:26 <lambdabot>     Not in scope: type constructor or class ‘CallStack’
07:32:29 <kuribas> :k Callstack
07:32:31 <lambdabot> error:
07:32:31 <lambdabot>     Not in scope: type constructor or class ‘Callstack’
07:32:34 <quchen_> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#the-constraint-kind
07:32:37 <quchen_> Profpatsch: ^
07:32:48 <kuribas> :k HasCallStack
07:32:50 <lambdabot> error:
07:32:50 <lambdabot>     Not in scope: type constructor or class ‘HasCallStack’
07:33:14 <kuribas> :k ?loc
07:33:15 <lambdabot> error:
07:33:16 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
07:33:58 <Profpatsch> :k (Show Int, Ord String)
07:34:00 <lambdabot> Constraint
07:34:03 <Profpatsch> :t (Show Int, Ord String)
07:34:06 <lambdabot> error:
07:34:06 <lambdabot>     • Data constructor not in scope: Show :: t0 -> t
07:34:06 <lambdabot>     • Perhaps you meant one of these:
07:34:12 <siyu> i don't understand why endOfLine can be used for both strict and lazy parser
07:34:28 <quchen_> Dict allows you to get a value for a type of kind Constraint, Profpatsch.
07:34:39 <quchen_> I think it’s from the »constraints« library.
07:34:51 <quchen_> :t Dict
07:34:53 <lambdabot> error: Data constructor not in scope: Dict
07:34:57 <quchen_> :-(
07:35:01 <Profpatsch> Isn’t this the point where one should switch to a Dependently typed language? :)
07:35:26 <quchen_> Using constraint kinds for shortening contstraints is quite useful.
07:35:31 <quchen_> Other than that I haven’t used it yet.
07:36:37 <quchen_> Profpatsch: Shake for example has »type ShakeValue a = (Show a, Typeable a, Eq a, Hashable a, Binary a, NFData a)«
07:37:35 <Profpatsch> Yes, that really is useful.
07:37:59 <Profpatsch> And now I understand: you can rename anything of kind Constraint.
07:38:18 <quchen_> Yup.
07:38:26 <Profpatsch> And (Show a, …) is just a normal tuple which is of kind Constraint if all members are.
07:38:52 <quchen_> Yes, you can picture (,) as having kind (Constraint, Constraint) -> Constraint.
07:38:56 <quchen_> The syntax is a bit magical, since
07:38:58 <quchen_> :k (,)
07:38:59 <lambdabot> * -> * -> *
07:39:03 <quchen_> Which doesn’t unify.
07:41:54 <quchen_> Profpatsch: Edward’s talk on monad homomorphisms is quite heavy on working with constraint kinds :-D
07:42:00 <quchen_> (ZuriHac this year)
07:42:21 <quchen_> He basically writes a lot of types, and the value for them is usually »Sub Dict«.
07:45:49 <seishun> is `(i, a) <- zip [0..] elems` the usual way to get an element plus its index?
07:46:27 <Cale> Yeah
07:47:10 <Cale> Idiomatic use of lazy evaluation :)
07:47:36 <davidmd> so I have a type called Field which contains a value and has functor and applicative like properties. The only problem is that its kind is FieldK. When I try and write instances it correctly tells me the kind is wrong. Is there any way around this?
07:48:53 <c_wraith> davidmd: It's impossible to implement fmap if the last type variable doesn't have kind *, so..  Maybe we need more information
07:48:56 <Cale> davidmd: Make a new Functor class involving FieldK somehow?
07:49:28 <Cale> (or if you don't need the polymorphism, just implement a separate fmap-like function altogether)
07:49:48 <Cale> But yeah, it's unclear what this other kind is
07:50:22 <davidmd> So the declaration of the type is
07:50:29 <c_wraith> Or could this be fixed by changing the order of the type variables?
07:50:43 <davidmd> data FieldK :: BOX;data (name :: Symbol) ::: (typ :: *) :: FieldK
07:51:13 <c_wraith> davidmd: there's no value to even fmap over there.
07:51:29 <c_wraith> davidmd: and while that doesn't make functor useless, it does make me question what you actually want.
07:51:57 <davidmd> Cale: yea that's the current solution, I'm just missing some of the niceties like <$> and <*>. newtype Field (f :: FieldK) = Field { unfield :: UnField f } is the actual field definition
07:53:04 <Cale> davidmd: So if we have f, f' :: FieldK, what are the arrows f -> f'?
07:53:14 <Cale> (since they're not functions...)
07:53:24 <c_wraith> Oh, hmm.  I see.  Since when does data allow you to declare a type with a kind other than * when it's fully saturated?
07:53:54 <davidmd> and the applicative lift function looks like liftF1 :: (a1 -> r) -> Field (na1 ::: a1) -> Field (nr ::: r)
07:53:54 <davidmd> liftF1 f (Field a1) = Field (f a1)
07:54:04 <Cale> hmm
07:54:17 <Cale> I see
07:54:52 <davidmd> sorry, I'm a tad out of my depth here, the guy who made this has since left the company
07:56:22 <Cale> davidmd: Do you have a liftF2?
07:56:37 <davidmd> yup liftF2 :: (a1 -> a2 -> r) -> Field (na1 ::: a1) -> Field (na2 ::: a2) -> Field (nr ::: r)
07:56:37 <davidmd> liftF2 f (Field a1) (Field a2) = Field (f a1 a2)
07:57:02 <Cale> So you can define  apF = liftF2 ($)
07:57:35 <Cale> To serve as a substitute for (<*>)
07:59:18 <c_wraith> Uh.  Where is BOX defined? Doesn't appear to be in base or ghc-prim
07:59:45 <davidmd> ahh, nice thanks, that'll really help clear up my code
08:00:48 <Cale> c_wraith: I believe it's primitive
08:00:51 <davidmd> c_wraith, it's the kind constructor https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/kind-polymorphism-and-promotion.html (7.8.1)
08:01:05 <c_wraith> I know what it is
08:01:16 <c_wraith> But I what do I need to do to get GHC to recognize it?
08:01:34 <c_wraith> Oh, I need to be operating at the kind level
08:01:38 <Cale> yeah
08:01:54 <c_wraith> davidmd: those definitions you provided don't even come close to compiling. :)
08:02:06 <Tuplanolla> Why is `BOX` fully capitalized?
08:02:10 <davidmd> c_wraith: and the KindSignatures language pragma
08:02:30 <c_wraith> davidmd: you're referring to a kind at the type level
08:02:44 <Cale> Tuplanolla: Probably just to reduce the chance that it'll overlap with someone else's type name.
08:02:54 <Rotaerk> it stands for Big Orange Xylophone
08:02:59 <Cale> Tuplanolla: In the paper, it was a white square
08:03:27 <Profpatsch> When should one use MonadIO m => and when IO directly?
08:03:39 <davidmd> yea, our compiler deviates from mainline GHC a little bit so there's a good chance this doesn't compile on vanilla
08:03:42 <davidmd> it's a pain in the ass
08:03:49 <c_wraith> That's more than a little bit. :)
08:03:57 <Tuplanolla> They missed a chance to be Knuth and name it `BoX`.
08:03:58 <Profpatsch> Or does it make a difference when all functions inside your function have an IO constraint directly?
08:03:59 <Rotaerk> Profpatsch, when one needs to support any monad that contains IO, rather than just IO
08:04:42 <c_wraith> davidmd: it's allowing types with kinds other than * to have values
08:04:56 <c_wraith> davidmd: that's really quite different from ghc
08:05:16 <Cale> Profpatsch: I use MonadIO when it's combined with other constraints that would be inconsistent with the monad actually being IO itself.
08:05:34 <Profpatsch> Ah, sounds reasonable
08:05:40 <Cale> If the monad could just be IO, I just use IO, since liftIO will make up the difference.
08:05:43 <Profpatsch> Then I should probably use IO directly in my case.
08:06:00 <Xnuk> What is "ghc-ncurses6-8.0.1"? Why GHC needs ncurses6?
08:06:25 <c_wraith> Xnuk: it's bindings to ncurses 6, which kind of need ncurses 6 to work.
08:06:50 <davidmd> c_wraith: yea, it makes your life wayyy easier when you're doing type level stuff. But it makes some of the kind level distinctions a bit more arbitrary
08:07:21 <davidmd> c_wraith: didn't realize GHC didn't have that yet though, I need to go outside more...
08:08:13 <Xnuk> Aha.
08:08:22 <c_wraith> Xnuk: actually, where are you even seeing that?  It's not on hackage.
08:09:11 <c_wraith> Weird.  It seems to be a stack thing that isn't actually published on hackage.
08:09:37 <Xnuk> c_wraith: Stack complains: "No compiler found, expected minor version match with ghc-8.0.1 (x86_64-ncurses6)" even if I have ghc-8.0.1.
08:09:58 <Xnuk> Using latest nightly resolver.
08:10:18 <davidmd> c_wraith: cale: thanks for the help!
08:11:48 <c_wraith> Xnuk: that's a weird error message.
08:11:54 <Xnuk> So I'm downloading it about 60KB/s
08:16:23 <eelster> I know this is probably a pretty stupid question, but can someone by chance take a look at my code and see why I'm getting an IO type mismatch? It's pretty short and I just can't figure out why it won't type check.
08:16:32 <Xnuk> I could use --system-ghc, but then Vim plugin complains me and cannot use auto-completing stuffs.
08:17:03 <Xnuk> @lpaste
08:17:03 <lambdabot> Haskell pastebin: http://lpaste.net/
08:17:30 <Cale> Yeah, paste it ^^ there and I'll have a look
08:17:57 <lpaste> eelster pasted “Operational” at http://lpaste.net/350399
08:18:26 <eelster> GHC is complaning about mismatches at 11:3 and 12:3
08:18:29 <Cale> run is plainly producing an IO action
08:18:46 <Cale> since the right hand side of the = sign is a do-block which executes getLine
08:19:04 <Cale> So its type can't be Integer -> Integer, it's got to be Integer -> IO Integer or something
08:19:20 <Cale> and then you'd have to actually run that
08:19:24 <Cale> in main
08:19:32 <Cale> rather than using it as if it were an Integer
08:19:37 <eelster> If it's type is IO Integer then should I change 12 to show $ op s $ parse $ words a
08:19:49 <c_wraith> no, it should be return
08:19:55 <Cale> Yeah return
08:20:13 <eelster> Oh yeah. show is String returning anyways
08:20:29 <Cale> Yeah, and each line of the do-block needs to be an IO action
08:20:56 <Cale> So you *could* just have it print there or something, but then that would have type IO ()
08:21:35 <Cale> Another option would be to define run in terms of the input you're getting from the two lines
08:21:52 <Cale> That is, give it some type like  run :: String -> String -> Integer
08:22:18 <Cale> and then in main, you can just execute getLine twice, and pass the strings along to run
08:23:10 <eelster> I just made op :: Integer -> (String, Integer) -> IO ()
08:23:10 <Cale> (and print the result or something)
08:23:21 <eelster> And also run :: Integer -> IO ()
08:23:39 <eelster> So it just prints the result from the "%" match in op and that works fine. 
08:23:41 <eelster> Thank you!
08:23:52 <Cale> no problem
08:24:47 <lpaste> eelster revised “Operational”: “Operational” at http://lpaste.net/350399
08:24:59 <eelster> Yeah, there's the finished code and it works great now. Thank you!
08:25:07 <Cale> eelster: The important thing to keep in mind is that the difference between a value of type IO t and a value of type t is like the difference between /bin/ls and a list of files in your home directory.
08:25:47 <eelster> So one is the command that gives you the information whereas the other is just the information itself?
08:25:51 <Cale> yeah
08:27:02 <eelster> That's actually a great way to think about it. The IO system has tripped me up some, but it's really brilliant. 
08:27:06 <Cale> and in order to run an IO action, say  x :: IO t  you write  v <- x  inside a do-block and then  v :: t  will be the result -- and the do-block as a whole will be an expression which denotes yet another IO action (of the same type as its last line)
08:27:52 <Cale> If operations don't actually need to perform I/O, try to give them types that don't involve IO, generally, because that will make them easier to test and understand.
08:28:30 <Cale> You can always use something that doesn't involve IO from an IO action, once you have all the input it needs.
08:28:42 <Cale> (and then do some output based on its result)
08:28:44 <Welkin> IO is a cool moon
08:28:47 <Welkin> Io
08:29:04 <eelster> That's probably a pretty good idea on the whole. Do thigs as simply as possible
08:41:36 <Iceland_jack> Hello #haskell
08:41:51 <Iceland_jack> It's been a while
08:44:07 <MarcelineVQ> omy
08:49:52 <Welkin> Iceland_jack: are you in iceland?
08:50:12 <Iceland_jack> I'm currently in the great state of Indiana
08:52:52 <Welkin> rofl Iceland_jack 
08:52:56 <Welkin> that is where I live right now
08:53:00 <Welkin> in indianapolis?
08:53:14 <Iceland_jack> No way
08:53:30 <Iceland_jack> Broad Ripple
08:53:43 <Welkin> I'm in avon
08:54:09 <Welkin> that's cool
08:54:15 <Welkin> I didn't know there were any haskell users nearby
08:55:32 <Iceland_jack> I won't be here for long, I will buy you a beer if you want to meet up
08:57:06 <Iceland_jack> I didn't know where Avon is but internet tells me it's less than an hour's drive
08:57:14 <Welkin> yeah
08:57:17 <Welkin> it's on the west side
08:57:25 <Iceland_jack> What a coincidence...
08:59:08 <Social-Reject> I love javascript
08:59:13 <Social-Reject> ups sorry wrong channel
08:59:14 <Social-Reject> :p
08:59:44 <Shockk> get out >:(
08:59:45 <Shockk> just joking
09:00:26 <Shockk> also that wasn't directed at you trism, someone said something right before you joined
09:05:07 * Xnuk is still downloading ghc-ncurses6-8.0.1
09:05:55 <vozz> What are the go to haskell GUI libraries nowadays?
09:09:50 <ertes> vozz: widget GUIs?  with buttons, text boxes, etc.?
09:12:34 <niklasb> can anybody tell me why "foreign import" works in this code, even though I didn't enable {-# LANGUAGE ForeignFunctionInterface #-}? http://lpaste.net/6391176331635195904
09:12:53 <MarcelineVQ> Xnuk: appearantly depending on if you have libtinfo6 and ncurses6   stack will download an alternate binary to compensate for their presence/absence
09:13:04 <mmaruseacph2> vozz: wxHaskell, gtkHs, threepenny-gui
09:13:21 <mmaruseacph2> oh, and there is one for Qt too, but I forgot it's name
09:13:29 <mmaruseacph2> (at least one for everyone above)
09:13:47 <geekosaur> niklasb, the FFI was an extension to Haskell98, it is standard as of Haskell2010
09:14:08 <niklasb> ok
09:14:23 <geekosaur> so no extension needed unless youhave forced Haskell98 compatibility (which doesn't quite work right in current ghc)
09:14:31 <niklasb> so if I compile with -XNoForeignFunctionInterface, and there is no according language pragma in the code, it should be disabled completely?
09:15:31 <geekosaur> in theory. I don't think that is well tested, since ghc diverged from the standard in other ways that are hard to reverse (Num instances, Applicative/Monad)
09:16:21 <mmaruseacph2> isn't GHC a de-facto standard?
09:17:06 <geekosaur> yes
09:17:27 <geekosaur> and h'98 back compat was broken for years and nobody noticed
09:17:27 <niklasb> geekosaur: ok it's good enough for me that it doesn't recognize the syntax. thanks
09:18:27 <mmaruseacph2> niklasb: question is, why do you want to disable the FFI? If it's for safety reasons, maybe check Safe Haskell?
09:18:43 <niklasb> mmaruseacph2: reasons are contrived, maybe I can tell you more about it next week
09:19:08 <mmaruseacph2> just wondering, no issue
09:19:21 <Xnuk> MarcelineVQ: But its download speed is too slow. Does it have any mirrors?
09:20:18 <MarcelineVQ> I don't know, I find it really odd that your system ghc's of the same version of the wasn't good enough for it :(
09:28:25 <lpaste> xcmw revised “Suggestions for improvement?”: “Suggestions for improvement?” at http://lpaste.net/350370
09:30:02 <Profpatsch>      (.>) :: MonadIO m => m (Maybe a) -> (a -> m (Maybe b)) -> m (Maybe c)
09:30:04 <Profpatsch>      a .> b = runMaybeT $ liftIO a >>= liftIO b
09:30:22 <Profpatsch> It seems like this combinator might have quite a bit of overhead.
09:30:50 <Profpatsch> And there probably is a better version in mtl already?
09:31:54 <lpaste> xcmw revised “Suggestions for improvement?”: “Suggestions for improvement?” at http://lpaste.net/350370
09:34:01 <xcmw> My attempt at making a type level case. It would have to be extended to support more than a direct mapping of one type to another type.
09:37:22 <Profpatsch> Or maybe
09:37:24 <Profpatsch>      (.>) :: MonadIO m => MaybeT m a -> a -> MaybeT m b -> MaybeT m c
09:37:26 <Profpatsch>      a .> b = liftIO a >>= liftIO b
09:39:41 <savrem> I'm writing a WAI middleware that consumes the entire request body, how can I get the body back into the request for the next Application to use?
09:51:06 <Gurkenglas> https://gyazo.com/afba43a299af2514518d2d73e455bc2c ???
09:53:40 <Gurkenglas> Can we get a command for lambdabot that takes a "MonadRandom m => m A" and shows an A?
09:54:48 <Profpatsch> savrem: Have you tried passing the original request object to the next middleware?
09:55:15 <Profpatsch> Maybe requestBody isn’t a shared pointer to a resource.
09:56:24 <Gurkenglas> (...actually I guess that's "> (`evalRand` mkStdGen 0)" if you're just testing)
09:57:40 <Profpatsch> Something like m = \app req resp -> consumeBody req >> app req resp
09:59:29 <Profpatsch> Something like m = \app req resp -> consumeBody req >>= print ("foo" ++ body) >> app req resp
10:00:42 <Profpatsch> runApp port $ m . m $ 404app
10:00:50 <savrem> I think that's what's happening in my code right now, here's a snippet of what I have right now: https://gist.github.com/anonymous/545cc5a55db99492ea70f148b254fc76
10:00:54 <Profpatsch> And then check if the body is printed once or twice
10:02:29 <Profpatsch> 404app = responseBuilder status404 [] ""
10:12:32 <Profpatsch> savrem: You are right, only the first middleware gets the request body.
10:15:08 <ertes> the only ways to get the request body from one application to another is either to run both applications concurrently and multiplex, or to load the request body into RAM
10:15:36 <ertes> (in this sense a middleware is just an application that may refer to another application)
10:16:11 <Profpatsch> The backwards-application of Applications (heh) is as nice as it is mind-boggling.
10:16:48 <Profpatsch> But yeah; savrem why exactly do you want to handle authentication with a Wai middleware?
10:17:53 <Profpatsch> You can do it in the application itself; normally frameworks do that for you.
10:18:15 <Profpatsch> Or better: Why do you need to read the body in order to do auth? that’s what headers are for, and those are values.
10:18:38 * Profpatsch is idling in the train
10:21:41 <savrem> well I'm making an API with the servant library and I just want to require authentication on the whole API, I know servant has some kind of system for authentication but it seemed to describe authentication based on the objects your trying to access. I just want to do compare HMACs on the body of every request... 
10:21:53 <savrem> maybe I'm going about this the wrong way
10:27:20 <savrem> thanks for your help Profpatsch and ertes, I'll keep at it :)
10:38:10 <Profpatsch> savrem: yeah, I’d definitely use the servant auth, or maybe enable HTTP authentication alltogether.
10:38:18 <Profpatsch> On your webserver.
10:41:34 <shlevy> What's the proper way to handle the othe end breaking the connection with Network.Socket? i.e. the equivalent of doing msg_nosignal and handling EPIPE in C?
11:07:03 <Tyg13> does anyone know why stack ghci would be using 8.0.1 even though I've run stack setup 7.10.2?
11:07:47 <athan> Tyg13: Are you using `stack ghci` within a stack project (so the stack.yaml is in your current directory)?
11:07:58 <Tyg13> it seems that it's adding ghc-8.0.1 to the bin-path even though it's not in my windows path
11:08:09 <Tyg13> it seems that it's adding ghc-8.0.1 to the bin-path even though it's not in my windows path
11:24:46 <jaspervdj> shlevy: I believe SIGPIPE is ignored by default by the Haskell RTS.
11:25:18 <jaspervdj> shlevy: You'll just get an IOException which you need to handle
11:26:02 <shlevy> Yeah, but it looks like there's no way to check the IOException for the errno without importing a GHC-internal module :(
11:27:20 <jaspervdj> shlevy: Depending on what you are doing it's not so bad to import a GHC-internal module.  Lots of code does that
11:28:06 <shlevy> Sure, but "gracefully handle the upstream server dying" doesn't strike me as especially GHC-specific :)
11:28:30 <jaspervdj> shlevy: I would also consider this more as "GHC-specific" rather than "GHC-internal"
11:29:09 <shlevy> The relevant module has "{-# OPTIONS_HADDOCK hide #-}" and "Stability   :  internal"
11:29:13 <shlevy> I'll use it, of course
11:29:22 <shlevy> But upstream is definitely trying to keep me away :D
11:31:13 <jaspervdj> shlevy: System.IO.Error from `base` allows you to look at some properties of IOException.  Not sure if it satisfies your needs
11:33:31 <yenien> hi
11:55:34 <darkmercenary> hi im using yesod, and im trying to run a db action depending on whether or not a form succeeds or not. I'm trying something right now but it's not working
11:55:40 <darkmercenary> http://pastebin.com/i7MLMLLx
11:55:53 <darkmercenary> dont think that case part is right
11:59:07 <Gurkenglas> Why not turn the two cases into one, skipping the Maybe step?
11:59:32 <Gurkenglas> In line 9, you want "Nothing -> return ()" or "_ -> return ()"
12:00:23 <Gurkenglas> (If you have a good reason for the Maybe step, you can condense it by replacing lines 7-9 with "traverse_ (runDB . insertEntity) submission"
12:00:26 <Gurkenglas> *)
12:01:44 <Gurkenglas> Also you can replace each of formWidget and formEnctype with _ because you don't use them
12:03:20 <slack1256> anywhere I could get gi-gtk api docs without compiling myself?
12:04:28 <Gurkenglas> (Using lensy stuff, lines 3 - 9 could look like "runFormPost entryForm >>= traverseOf_ (_1 . _1 . _FormSuccess) (runDB . insertEntity)"
12:04:33 <Gurkenglas> *) ._.
12:06:18 <darkmercenary> I'm trying with Nothing -> return () on line 9 i get a type error
12:06:21 <darkmercenary>  Couldn't match expected type `Entity Example' with actual type `()'     In the first argument of `return', namely `()'     In the expression: return ()
12:06:51 <darkmercenary> i tried doing something like const (return ()) (rundb...)
12:06:56 <darkmercenary> that doesnt work either
12:07:08 <Gurkenglas> runDB returns something and you ignore it? "void $" to the left of runDB, then.
12:07:40 <Gurkenglas> (Or "fmap (const ()) $ ", literally equal)
12:08:29 <Gurkenglas> (The traverse_ version should also just work)
12:09:06 <darkmercenary> ah very nice thanks yea it works
12:09:20 <darkmercenary> ill keep notes on the other things u said
12:10:35 <darkmercenary> as well
12:11:15 <johnw> fmap (const ()) ... == () <$ ...
12:11:56 <johnw> == void ..., as you said
12:34:55 <Zemyla> You know, I love that there are ways to efficiently take operations that may or may not be commutative, and force them into commutativity.
12:37:58 <KV> Hi, I'm learning Haskell and I'm rewriting binary socket protocol from Ocaml. I'm reading from a socket by using a lazy ByteString. I get a length from the socket, and then I should read records until that length is consumed. In Ocaml I check the socket position at every recursion. Is it possible to calculate the length dropped from a ByteString some how? I have both the original reference to it, and the new
12:38:00 <KV> reference after every record is read/dropped.
12:40:37 <ertes> KV: not sure i understand…  so the first information you get through the connection is the length of the next record, and then you get the record?
12:41:19 <ertes> KV: also is this a stream protocol?  (e.g. TCP)
12:41:23 <KV> ertes, no, I get a length of all the records. The I read multiple records until that length is consumed
12:41:29 <KV> Yes TCP
12:41:38 <ertes> but it's just a single number?
12:42:14 <KV> ertes, yes. It's like: 342 bytes, Then I read record after record until I've read 342 bytes
12:42:52 <ertes> KV: i'd probably do it using a stream processing abstraction like pipes
12:43:01 <ertes> KV: alternatively you can write a binary parser using e.g. attoparsec
12:43:27 <KV> ertes, thank you. Will check out that one
12:44:02 <ertes> KV: generally you should avoid lazy I/O
12:46:00 <ertes> KV: attoparsec is probably the easier option, if you're a haskell beginner
12:47:30 <amx> KV: I use io-streams for exactly that
12:48:41 <KV> ertes, okay. Will check both
12:48:54 <KV> amx, nice. Will check that as well, thanks!
13:11:05 <johnw> ertes: why "generally"?
13:19:17 <ertes> johnw: as in "by default", although lazy O is fine i suppose
13:32:55 <alex_knyshev> Hi there! I have an question about IO Monad. I have an data representing json (something like data Json =  JNumber Double | JString String | etc) and I want to genearte random Json number (JNumber). Currently I stay with this: random_prim_impl = do r <- randomIO :: IO Int; JNumber (fromIntegral r) and getting error Not in scope: data constructor `IO'
13:34:53 <geekosaur> that code looks wrong but the error doesn't match the problem...
13:35:01 <geekosaur> @paste full code example and full error message
13:35:01 <lambdabot> Haskell pastebin: http://lpaste.net/
13:35:11 <alex_knyshev> 1 sec
13:36:09 <alex_knyshev> There http://lpaste.net/350414
13:37:37 <geekosaur> right, line 10 won't work, IO is not a data constructor
13:37:44 <geekosaur> you want return instead
13:37:51 <geekosaur> and, you need parentheses (or $)
13:38:07 <geekosaur> return (JBool False)
13:38:16 <alex_knyshev> Ok, I see, thx
13:38:17 <geekosaur> likewise all the other cases need to use `return`
13:38:37 <monochrom> there is probably something about gaining experience in making peace with abstract types before tackling IO
13:45:05 <Eduard_Munteanu> Is there a generic way to turn a value into a TH Exp? I intend to run a computation at compile-time and fill the result into a definition.
13:45:42 <geekosaur> Lift typeclass, which sprouted new instances in ghc8
13:46:37 <Eduard_Munteanu> Thanks.
13:47:14 <geekosaur> (I gather they're not actually hard to write, and previously everyone just rolled their own)
14:06:46 <Lvcrft> Hello
14:07:44 <haskell932> hello
14:09:43 <jle`> hi
14:09:48 <haskell932> I have a function loop :: StateT MyMap IO () and inside I would like to call I want to call eval :: State MyMap Text -> State MyMap Text. Is there some way how to get rid of the "transformer with IO" in the call to eval?
14:11:12 <jle`> haskell932: the type signature of 'eval' is a little suspicious, but the best way is to just never work with 'State' at all, and just write polymorphially for 'StateT s m a -> State t s m a'
14:11:22 <jle`> er, StateT s m a -> StteT s m a
14:11:27 <jle`> if you have control of the implementation of 'eval'
14:11:57 <jle`> but that might not be possible in this case, depending on what 'eval' does
14:12:25 <monochrom> I wonder if "withStateT" helps you
14:12:30 <Gurkenglas> I want an example where that's not possible
14:12:38 <monochrom> err no, the other one, "mapStateT"
14:13:49 <jle`> Gurkenglas: 'eval' might expect to be able to runState
14:13:52 <Lvcrft> Can anyone please help me with this? http://lpaste.net/350416
14:14:03 <Lvcrft> Apparently I have something wrong with the guards but I can't quite figure out
14:15:03 <geekosaur> Lvcrft, you don't want the "do" at the end of line 6
14:15:04 <monochrom> Lvcrft, I wonder if you should just delete "= do"
14:15:11 <geekosaur> or the =, yeh
14:15:30 <geekosaur> name pat ... | guard = expr | guard = expr ...
14:15:43 <Gurkenglas> :t runState `asAppliedTo` (undefined :: forall m. Monad m => StateT Int m ()) -- jle`, this works. (How do I do this without specifying Int and ()?)
14:15:45 <lambdabot> State Int () -> Int -> ((), Int)
14:15:50 <geekosaur> no = before the guard, and "do" is just plain wrong there
14:16:13 <monochrom> You cannot "let me factor out 'do' from multiple guards and/or multiple cases"
14:16:27 <monochrom> "and/or the two branches of if-then-else"
14:16:31 <jle`> lambdabot: you also don't need "return"
14:16:33 <haskell932> jle`, monochrom: I will try, thank you
14:16:41 <jle`> * Lvcrft 
14:16:56 <jle`> Lvcrft: just | z == "Y" = v
14:17:31 <jle`> Gurkenglas: yes, but you can't do that and have eval expect a 'StateT s IO a', a specific m
14:17:37 <geekosaur> the do is unnecessary with or without the attempt to factor it out...
14:17:44 <monochrom> "ask :: Int -> Int -> Int" is wrong. You need "ask :: Int -> Int -> IO Int".
14:17:59 <jle`> oh, i see, yeah, in that case, you would need 'rturn v'
14:18:10 <jle`> if checker :: (Int, Int, String) -> IO Int
14:18:29 <monochrom> yeah, checker needs IO too, it's in mutual recursion with ask.
14:19:00 <monochrom> You need to read my http://www.vex.net/~trebla/haskell/IO.xhtml
14:19:25 <Tyg13> Is readMVar blocking?
14:19:35 <Tyg13> Is readMVar blocking?
14:19:37 <monochrom> It could.
14:19:42 <Tyg13> or is there some other reason putMVar wouldn't work?
14:20:10 <Gurkenglas> jle`, confusion. I'm saying that Monad m => ((State s a -> State s a) -> StateT s m a -> StateT s m a) is inhabited, and you're saying it isn't, right?
14:20:13 <jle`> readMVar usually blocks until there is something to read
14:20:13 <Tyg13> oh, I realized my problem
14:20:46 <Tyg13> just a quick check, is it idiomatic to use an MVar Bool for a lock?
14:21:08 <Tyg13> all I need is to share a bool between two threads
14:21:08 <jle`> Tyg13: why not MVar () ?
14:21:49 <Lvcrft> I deleted the do and I still get the same error
14:21:52 <jle`> you can use MVar Bool to share across two threads and controll access, yes
14:22:00 <jle`> Lvcrft: did you delete the equals sign too?
14:22:11 <monochrom> For simply a lock, you just need MVar ()
14:22:11 <jle`> Tyg13: also if you just want a semaphore (MVar ()), there's http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Concurrent-QSem.html
14:22:14 <Lvcrft> yes, well
14:22:17 <Lvcrft> on the checker function
14:22:30 <Lvcrft> i didn't on the ask function
14:22:41 <monochrom> Lvcrft, read what we've all said since last time.
14:22:44 <haskell932> monochrom: fyi mapStateT doesn't seem to have the type I need
14:22:47 <jle`> Gurkenglas: i think your example only showed the case where m ~ Identity
14:22:50 <Tyg13> that seems to be what I'm looking for thanks
14:23:00 <Tyg13> that seems to be what I'm looking for thanks
14:23:02 <jle`> Gurkenglas: but hm, i could be wrong
14:24:29 <Lvcrft> i'm not getting that mistake anymore, thanks
14:24:36 <Lvcrft> *eror
14:43:03 <Gurkenglas> :t \x f s -> do a <- f s; return $ x (const a) s -- nigh certainly completely off target. jle`, can you give me a specific (State s a -> State s a) that I cannot transform into a (forall m. Monad m => StateT s m a -> StateT s m a)?
14:43:04 <lambdabot> Monad m => ((b1 -> a) -> t -> b) -> (t -> m a) -> t -> m b
14:43:49 <Gurkenglas> *its
14:44:06 <Gurkenglas> *"*transform into its"
14:56:36 <Social-Reject> how can I log text to console in haskell
14:56:42 <Social-Reject> to ghci
14:57:02 <Social-Reject> like in javascript there is console.log
14:57:06 <Social-Reject> in haskell?
14:57:42 <sm> putStrLn
14:58:20 <Social-Reject> [x | x <- [1..100], x `mod` 2 == 0 putStrLn "fizz"]
14:58:23 <Social-Reject> why this does not work
14:59:12 <int-e> Social-Reject: what do you expect the putStrLn "fizz" to do there?
14:59:33 <Social-Reject> to print in console 'fizz'
14:59:35 <Social-Reject> :D
15:00:24 <jle`> Social-Reject: what you are writing is parsed as x `mod` 2 == (0 putStrLn "fizz")
15:00:43 <int-e> :-/
15:00:46 <Gurkenglas> When, or how often, do you want fizz to be printed?
15:00:57 <int-e> they left
15:02:03 <Social-Reject> hey could you write again
15:02:08 <Social-Reject> my connection died
15:02:13 <Social-Reject> for [x | x <- [1..100], x `mod` 2 == 0 putStrLn "fizz"]
15:02:16 <jle`> Social-Reject: what you are writing is parsed as x `mod` 2 == (0 putStrLn "fizz")
15:02:29 <jle`> as in, apply the fctuin 0 to arguments 'putStrLn' and '"fizz'
15:02:37 <jle`> you're using 0 as if it were a function, heh
15:03:33 <jle`> Gurkenglas: hm how about, \s -> if even (evalState s 10) then (modify succ >> s) else s   -- ?
15:03:44 <Social-Reject> how is correct jle`
15:04:05 <jle`> Social-Reject: well, what do you want to do?
15:04:13 <jle`> Gurkenglas: but i admit i could be wrong
15:04:31 <Social-Reject> I want [x | x <- [1..100], x `mod` 2 == 0 putStrLn "fizz"] when is x % 2 == 0 to print in console 'fizz'
15:05:04 <jle`> hm, are you familiar with what list comprehensions are supposed to do?
15:05:12 <jle`> you use them to return lists
15:05:17 <Social-Reject> return lists
15:05:18 <Social-Reject> yes
15:05:21 <Social-Reject> :-)
15:05:30 <suzu> you cant use them to /do/ stuff
15:05:37 <Social-Reject> I see
15:05:49 <jle`> how about [ if x % 2 == 0 then "fizz" else show x | x <- [1 .. 100] ] ?
15:06:00 * geekosaur has no idea why you'd expect that putStrLn to figure out it shouldn't be part of the mod expression, much less how it would do something
15:06:10 <jle`> putting x `mod` 2 on the right side of the | there would treat it like a filter
15:06:22 <jle`> but you don't want to filter things otu for `mod` 2's
15:06:35 <jle`> er, that % should be `mod`
15:07:01 <Social-Reject> cool
15:07:04 <int-e> Social-Reject: that code will produce a value of type [Integer], and Haskell has no side effects, so that type alone already prevents the expression from printing anything. jle`'s changing the type to [String], which still doesn't print anything, but you can then print each element of the resulting list in later code.
15:07:28 <Social-Reject> What do you mean by 'no side effects'
15:07:39 <sm> unlike other languages, haskell enforces separation of "calculating" (pure) and "doing" (IO) code
15:08:00 <sm> printing to the console is IO, a side effect
15:08:08 <Social-Reject> aha
15:08:25 <jle`> yeah, what i wrote would produce a list of strings
15:08:28 <jle`> um
15:08:33 <jle`> fizzOrBuz :: Int -> String
15:08:48 <sm> usually you do all the pure stuff first and add the IO code around it
15:08:50 <jle`> which outputs izz or buzz or the original int, shown as a string
15:09:03 <jle`> and then you can do [ fizzOrBuzz x | x <- [1 .. 100]]
15:09:08 <jle`> and the print out the results of that list one-by-one
15:09:20 <jle`> with, say, mapM_ print
15:09:25 <jle`> um, mapM_ putStrLn
15:09:34 <Social-Reject> so If in haskell need to contain 'else' ?
15:09:38 <Axman6> :t bool <$> const "fizz" <*> show <*> ((== 0) . flip mod 2)
15:09:40 <lambdabot> (Show b, Integral b) => b -> [Char]
15:09:50 <int-e> Social-Reject: yes
15:09:51 <Gurkenglas> :t \s -> do isiteven <- lift $ evalStateT s 10; if even isiteven then modify succ >> s else s -- jle`
15:09:54 <lambdabot> (Num s, Monad m, Integral b, Enum s) => StateT s m b -> StateT s m b
15:09:54 <jle`> Social-Reject: 'if x then y else z' in haskell is an expression
15:10:07 <jle`> it evaluates to an expression
15:10:12 <sm> Social-Reject: but if you really need to (eg for learning), you can cheat: import Debug.Trace and use traceShowId instead of putStrLn
15:10:25 <Social-Reject> I see
15:10:28 <int-e> sm: hush ;-)
15:10:28 <jle`> sm: it's kind of like the ternary operator in other languages, if you'ev ever used it
15:10:42 <sm> no no, trace is actually a really valuable learning tool :)
15:11:32 <Gurkenglas> If you use it to answer the fizzbuzz question at an interview you're in for a bad time tho
15:11:57 <Social-Reject> you mean if I use haskell?
15:12:00 <Social-Reject> why :D
15:12:04 <suzu> just use a list and a case
15:12:20 <jle`> yeah, write a fizzOrBuzz :: Int -> String function
15:12:21 <int-e> hmm,  putStr (unlines ...)  may be easier to understand than  mapM_ putrStrLn ...
15:12:27 <suzu> from my experience, using haskell in an interview has never been good for me unless that job was for haskell
15:12:35 <suzu> my interviewer never has been someone who also knows haskell
15:12:42 <suzu> so all it communicated was that we can't communicate
15:12:43 <suzu> lol
15:12:57 <suzu> i do all of my interviews in C++ unless it's for a haskell position
15:13:16 <jle`> Gurkenglas: might not be what you want, beucase it'd executes the effects of 's' twice :o
15:13:18 <int-e> @quote no.variables
15:13:18 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
15:13:18 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
15:13:38 <Social-Reject> lol there is haskell jobs? Thats hard to believe
15:13:47 <jle`> there are lots lol
15:13:52 <Axman6> my day job is writing Haskell
15:13:57 <jle`> mine too :o
15:13:58 <monochrom> They are just all out of your town.
15:14:04 <Social-Reject> out of my country
15:14:05 <Social-Reject> :D
15:14:26 <sm> so what
15:14:31 <Axman6> there's a fairly large team at Facebook writing their spam filtering system in Haskell
15:14:37 <monochrom> Murphy's law of Haskell employment: Employers find that all potential employees are out of town; employees find that all potential employers are out of town.
15:14:42 <Gurkenglas> I wonder if there's a mechanical turk-like or demand for one for Haskell.
15:14:44 <xcmw> Do they way better or worse than more common languages?
15:14:58 <jle`> it's probably more productive
15:15:05 <jle`> because it's faster to write working code in haskell
15:15:07 <jle`> than other languages
15:15:28 <jle`> and it's probably much more maintainable :)
15:15:38 <Axman6> our experience has been greatly increased reliability. once it's working it stays working, and bugs are much rarer
15:16:21 <monochrom> w00t there is a recent video in which John Hughes is impressed by Facebook Simon Marlow's spam filtering by Haskell. <Hughes> But I found no spam on Facebook. <Marlow> Exactly.
15:16:38 <Gurkenglas> Note the selection bias in talking to the people that stayed interested in Haskell
15:16:43 <grantwu> oh
15:16:56 <xcmw> I really failed at writing that question. Do haskell jobs pay more or less than jobs for other langauges?
15:16:59 <grantwu> Darn.  I see a shitton of spam on Facebook.
15:17:17 <monochrom> It's https://www.youtube.com/watch?v=LnX3B9oaKzw
15:17:28 <Axman6> grantwu: find new friends :P
15:17:31 <athan> What would be a nice way for an Async'd thread to await for data from its parent?
15:17:46 <Axman6> athan: mvar?
15:18:06 <athan> Axman6: I thought that was just like an IORef or something :s
15:18:31 <Axman6> it's a blocking variable that's either full or empty
15:18:33 * jle` realizes that he will now subconsciously blame haskell whenever he sees spam on facebook
15:18:39 <kmelva> how can I loop through ByteString and ignore the result? Something like `for_ someByteString Trace.showTraceM`? This doesn't work for me... should I use ByteString.map?
15:18:46 <athan> lol jle`
15:18:51 <Axman6> you give the forked thread an empty MVar and then later put the value in and it will be awoken
15:18:55 <grantwu> athan: It's not even that.  It's like... "Person I am acquainted with and wishes to remain friends with has liked this picture/post of someone I have never heard of before"
15:18:57 <jle`> athan: mvars are very different than iorefs, heh
15:19:17 <Axman6> kmelva: is there a mapM_?
15:19:20 <kmelva> of course I can: `for_ (ByteString.unpack someByteString) Trace.showTraceM, but is that inneficient?
15:19:20 <grantwu> er, that should be @Axman6
15:19:22 <jle`> kmelva: what does 'doesn't work' mean?
15:19:39 <jle`> is it a compiler error?
15:19:44 <kmelva> jle`: doesn't compile... I guess ByteString doesn't implement Foldable?
15:19:45 <sm> facebook did not block itself.. haskell fail!
15:19:48 <jle`> does it not do what you want?
15:20:00 <lyxia> ByteString is not Foldable
15:20:00 <jle`> kmelva: ah yeah, ByteString isn't Fodlable, it's the wrong kind
15:20:14 <grantwu> Okay, yeah, I guess that's not spam.
15:20:15 <monochrom> kmelva: I wonder if you simply need ByteString's foldr
15:20:24 <kmelva> jle`: heh, I thought I did something wrong... it was weird it's not Foldable
15:20:29 <jle`> Foldable's are only * -> *'s
15:20:33 <jle`> but ByteString is a *
15:20:41 <athan> ahh sweet, thanks Axman6
15:20:50 <jle`> Foldables can only be things expecting typeparameters
15:20:54 <kmelva> monochrom: yeah, that's basicaly what I want to know - whats the most effiecient way to iterate through ByteString without accumulating anything?
15:20:57 <jle`> type parameters
15:21:05 <monochrom> I don't know about efficient.
15:21:09 <jle`> * a single type parameter
15:21:11 <monochrom> And I will accumulate.
15:21:20 <Axman6> athan: go read Simon Marlow's (short) book on parallel and concurrent haskell
15:21:40 <athan> I have it ;-; i just get to a wall then start thinking about space stuff
15:22:09 <jle`> kmelva: mwhat you wrote should be fine, because of list fusion.  no intermediate list is ever made, it's basically a straight up constant space traversal
15:22:15 <monochrom> But it's foldr (\b m -> print b >> m) (return ())
15:22:35 <jle`> i can't imagine a more efficient way than just tracing every item
15:22:50 <kmelva> jle`: cool, didn't know that... I guess I'll benchmark a few other things, just to learn things... 
15:22:54 <kmelva> thanks guys!
15:23:37 <lyxia> if you want to treat ByteString like any other container there's the package mono-traversable
15:24:47 <dmwit> monochrom: from a discussion we had ages ago: http://hackage.haskell.org/package/ordered-containers
15:24:47 <kmelva> lyxia: cool, thanks, will look into that also... besides ByteString, what other containers don't implement Foldable? anything often used?
15:25:22 <athan> hmm, so I'm trying to make a websocket rpc system, where everything is super asynchronous. I think an `IntMap Async` structure would be a good implementation, wouldn't it? If each websocket message has some Int identifier (that the client manages, too), then each thread is directly identified by a websocket message... right?
15:26:02 <dmwit> kmelva: Text, for basically the same reason
15:26:05 <tommd> Would this value be held by a single thread or shared?
15:26:40 <kmelva> dmwit: ah, right! come to think of it... why isnt ByteString something like Vector Int8?
15:26:41 <dmwit> kmelva: IntSet, I guess probabl
15:26:44 <athan> (shoot I might just use an Array or Vector actually, for muh O(1))
15:26:58 <kmelva> dmwit: or Vector Word8, I forget which is which... that would make sense, right?
15:27:09 <dmwit> kmelva: Well, for one, I believe ByteString predates Vector.
15:27:21 <dmwit> But I think ByteString also resides in pinned memory, and is unpacked.
15:27:47 <athan> tommd: was that in reference to my question?
15:28:30 <athan> iirc, an Async is like a ThreadId
15:29:50 <Gurkenglas> jle`, I see. So the objection to haskell932 was basically "are you okay with eval executing that IO action multiple times, or even not at all?"?
15:30:09 <kmelva> dmwit: pinned memory / unpacked ... that's still bit above my level, yet more things to google for, thanks :P :)
15:30:38 <Gurkenglas> (or even other io actions that would have resulted from different starting states)
15:31:47 <dmwit> kmelva: pinned = the garbage collector won't move it; unpacked = consecutive Word8 values are in consecutive bytes in memory
15:32:48 <dmwit> I believe Vector is fine being moved around (hence requires more serialization work to use with FFI). I guess there's probably unpacked vectors, but I think Vector stores *pointers* to consecutive Word8 (thunks) consecutively in memory, but not the Word8s/thunks themselves.
15:32:56 <kmelva> dmwit: thanks :) does pinned then imply GC wont traverse it?
15:33:11 <dmwit> Well, yes.
15:33:29 <kmelva> so if it's i dunno... 10 gigs of ByteString GC wont pause the program for long?
15:33:31 <dmwit> I don't really think GC will traverse anything that's unpacked, though. (Why would it?)
15:34:05 <Axman6> the GC was never going to traverse the contents of a ByteString anyway, because there's no chance it contains a Haskell object
15:34:13 <dmwit> right
15:34:15 <ogleb> I cant seem to get stack to link my library against libHSrts, is there something I am missing?
15:34:18 <monochrom> dmwit: Oh, neat, interesting.
15:34:31 <Axman6> ogleb: we'll need more info to know
15:35:35 <dmwit> kmelva: I guess one should be careful to distinguish between lazy and strict ByteStrings. I think GC will walk the "spine" of lazy ones.
15:35:46 <Axman6> yes
15:36:10 <kmelva> dmwit: yeah, I was implicitly thinking only of strict ones... 
15:36:13 <dmwit> kmelva: `type Lazy.ByteString = [Strict.ByteString]` is a halfway-decent mental model, I think.
15:36:29 <ogleb> Axman6: well I added the path to the runtime in my stack.yaml (/usr/lib64/ghc8.0.1/rts) and added HSrts-ghc8.0.1 to extra-libraries in my cabal file but I still get "Missing C Library: HSrts.."
15:36:34 <dmwit> The list-y part probably is neither unpacked nor pinned.
15:36:51 <monochrom> lazy ByteString is a cons list of strict ByteStrings, each ByteString possibly 64KB. cons list may be [] or a homebrew thing.
15:36:55 <Axman6> ogleb: there should never be any need to do any of that afaik
15:37:54 <ogleb> hmm, well I am trying to build a shared object. And if I dont link against the runtime I cant invoke hs_(init | exit)
15:38:27 <geekosaur> just using ghc as the linker should bring in HSrts
15:38:38 <Axman6> ogleb: ah, that's probably more difficult (and beyond my experience, hopefully someone else knows)
15:39:54 <monochrom> ogleb: read my http://www.vex.net/~trebla/haskell/so.xhtml
15:40:05 <ogleb> geekosaur: I was able to get it to link using ghc, but `stack build` fails to bring it in. And I would like to avoid manually linking everything
15:40:10 <monochrom> But I don't know stack and won't comment on it. I only know cabal.
15:40:39 <dmwit> monochrom++ For documenting repeated #haskell conversations so nicely.
15:40:54 * geekosaur doesn't know stack details well enough for this use case either
15:40:57 <monochrom> err wait, when did I do that? :)
15:41:27 <athan> Is there a type-level $?
15:41:57 <slack1256> anybody using gi-gtk?
15:42:05 <athan> the war on Christmas is isomorphic to the war on parens
15:42:09 <geekosaur> athan, no. not even sure what it would do (type level id? type level apply operator?)
15:42:34 <geekosaur> oh, type level precedence hack
15:42:38 <athan> geekosaur: That's what I was thinking, just a fixity syntactic sugar
15:42:45 <athan> yep exactly
15:42:57 <dmwit> monochrom: Many of the pages listed on haskell/index.xhtml are handy references to link to in here.
15:43:09 <monochrom> Ah I see. Yeah.
15:43:18 <hamishmack> slack1256: I use gi-gtk
15:43:26 <monochrom> I lurk in #haskell for the next victim topic
15:43:56 <monochrom> But I'm also a great procrastinator. I am procrastinating and overthinking a potential "denotational semantics tutorial"
15:44:47 <dmwit> Where does "trebla" come from?
15:44:47 <monochrom> I also have an unfinished tutorial on how to invention recursive code by writing a would-be induction proof first.
15:44:55 <monochrom> reverse "albert"
15:45:06 <dmwit> =)
15:45:07 <monochrom> s/invention/invent/
15:45:36 <v0d1ch> haskell serbia new fb page, contributions welcome :) https://www.facebook.com/haskellserbia/
15:46:13 <mmaruseacph2> v0d1ch: please send a link to HCAR for that user group
15:46:16 <mmaruseacph2> in around march
15:46:30 <mmaruseacph2> mail me at hcar@haskell.org to give you details when I get home
15:46:54 <ogleb> hmmm same issues using cabal in linking in the runtime
15:46:57 <kmelva> v0d1ch: hello from Zagreb ;)
15:47:04 <mmaruseacph2> https://wiki.haskell.org/Haskell_Communities_and_Activities_Report
15:47:24 <mmaruseacph2> the newest edition should be released soon, when I get the time for the finishing touches
15:52:10 <slack1256> hamishmack: does it support glade templates?
15:52:17 <slack1256> I can't really load the documentation
15:53:03 <hamishmack> slack1256: https://github.com/haskell-gi/gi-gtk-examples/tree/master/gtkbuilder
15:54:04 <slack1256> Coooool!
15:55:04 <mmaruseacph2> I dislike glade templates, most of my gtk days where spent building interfaces with a matrix of widgets and glade was failing
15:55:20 <mmaruseacph2> so I started writing the code by hand and found out to be easier
15:58:18 <hamishmack> I prefer wrtiting code code too.  The Gtk Inspector makes it really easy to play with your UI like you would using a web browser inspector.  Which reduces the need for tools like Glade.
16:01:06 <mmaruseacph2> last time I used Glade was only to design some app when there was no paper&pen nearby (I was on a train)
16:12:14 <slack1256> Mmm what do you about documentation for gi-gtk?
16:12:38 <slack1256> stackage, hackage don't show it, plus it doesn't have a tutorial
16:13:13 <slack1256> (I was learning gtk through the gtk3 package, yet I couldn't send my own signals. I wanted to see if gi-gtk could)
16:29:38 <koala_man> hey, I find myself writing things like  register :: Key -> Value -> State SomeContext (); register k v = modify (\x -> x { myMap = insert k v mymap }); }. What are better ways of simulating multable variables for algorithms that work iteratively?
16:30:33 <koala_man> well, modify (\x -> x { myMap = insert k v (myMap x) }) 
16:32:07 <koala_man> i could use a Reader with STRefs but it's not a huge improvement syntactically
16:32:23 <JuanDaugherty> multable
16:32:44 <ertes> multable = mutable + multiple?
16:33:12 <JuanDaugherty> igess
16:33:29 <ertes> in any case lenses or a bunch of custom functions can improve the syntactic situation with…  multable variables =)
16:34:24 <koala_man> would lenses help with the state aspect or would it just replace the record syntax?
16:34:43 <ertes> koala_man: it has predefined operators for state monads, too
16:36:07 <slack1256> koala_man: even if it bothersome, modeling a vocabulary (your register func) for a problem is good practice in my book.
16:36:19 <koala_man> fresh = id <+= 1  mm, that's pretty sweet
16:38:30 <ertes> @let data Ctx = Ctx { _intVars = M.Map String Integer } deriving (Eq, Ord, Show)
16:38:31 <lambdabot>  Parse failed: Parse error: =
16:38:59 <ertes> @let data Ctx = Ctx { _intVars :: M.Map String Integer } deriving (Eq, Ord, Show)
16:39:01 <lambdabot>  Defined.
16:39:50 <koala_man> slack1256: of course, but I feel like I'm misusing State or missing something else
16:39:56 <ertes> @let intVars l = fmap Ctx . l . _intVars
16:39:59 <lambdabot>  Defined.
16:40:47 <ertes> > execState (intVars . at "blah" .= Just 5) (Ctx mempty)
16:40:51 <lambdabot>  Ctx {_intVars = fromList [("blah",5)]}
16:41:00 <ertes> koala_man: that's the lensy version
16:41:21 <ertes> > execState (do intVars . at "blah" .= Just 5; intVars . at "blah" . traverse += 5) (Ctx mempty)
16:41:24 <lambdabot>  Ctx {_intVars = fromList [("blah",10)]}
16:42:07 <koala_man> nice
16:42:10 <ertes> for state monads it gives you C-like operators, except more powerful ones
16:44:32 <koala_man> lens appears to depend on anything. is there a way to get around that? 
16:44:41 <koala_man> s/anything/everything/
16:46:03 <geekosaur> microlens?
16:46:59 <geekosaur> problem is, lens wants to provide instances for the most popular packages in the ecosystem. which means it needs to depend on the most popular packages in the ecosystem...
16:47:00 <koala_man> perfect, thanks
16:47:11 <athan> at least it's not codependence :v
16:59:09 <hpc> can cabal solve mutual dependencies?
16:59:38 <hpc> if by some miracle you're able to bootstrap it in some way?
17:01:58 <ertes> koala_man: you can't use microlens in this particular case, unless you want to write the At instance yourself
17:02:07 <ertes> koala_man: 'at' requires the At instance for Map
17:11:14 <ejr> Going to attempt Learn You A Haskell. Everyone wish me luck! :D
17:17:37 <nfd9001> Hey! Haskell newbie here; I'm trying to figure out why some code's breaking. I'm trying to solve a toy problem (zeckendorf representation), which can be solved for any n by running a greedy algorithm on the fibonacci numbers.
17:18:27 <xcmw> nfd9001: Can you post the code on lpaste.net/new/haskell
17:18:57 <xcmw> and the error
17:19:01 <nfd9001> xcmw: Sure.
17:20:03 <nfd9001>  Sec.
17:20:09 <nfd9001> hh
17:27:52 <xcmw> nfd9001: ?
17:28:37 <nfd9001>  xcmw Heh, sorry, this is a... really fresh VM install. I'm missing a couple things eg. a terminal it's possible to copy from with my keyboard.
17:30:10 <nfd9001> I've barely got more than x, haskell, xmonad, firefox, and some other dev tools installed. So I'm basically rewriting it.
17:30:53 <Gurkenglas> Has someone implemented this for Haskell? http://www.macs.hw.ac.uk/~jbw/papers/Haack+Wells:Type-Error-Slicing-in-Implicitly-Typed-Higher-Order-Languages:SCP-ta.pdf
18:18:55 <orion> https://wiki.haskell.org/GHC/Type_families#Equality_constraints <-- sumCollects :: (Collects c1, Collects c2, Elem c1 ~ Elem c2) => c1 -> c2 -> c2 -- Why can't this type signature just have "c" instead of "c1" and "c2"?
18:20:00 <athan> orion: This isn't as strict
18:20:15 <athan> Elem c1 ~ Elem c2 does not imply c1 ~ c2
18:25:20 <orion> What does it imply?
18:27:16 <geekosaur> that the containers both contain the same type of things. but one container might be Map-like and the other Hash-like
18:29:36 <orion> geekosaur: If instead of "Collects" and "Elem" the type signature said something else, would your response change
18:30:02 <geekosaur> yes. I am not sure what you are puzzled about, though, and what you apparently can't generalize
18:30:43 <geekosaur> (well, that second part is an assumption regarding the first, and may not be applicable)
18:31:15 <orion> Oh
18:31:37 <geekosaur> x c1 ~ x c2, x is a type family and the constraint says that the assigned types are the same between them. c1 and c2 need not be the same for this to be true
18:31:38 <orion> I was confused because I thought Elem was a type. It's a class.
18:31:52 <geekosaur> it's a type family
18:31:52 <orion> The whole thing is a set of class constraints.
18:32:18 <geekosaur> class Collects t where type Elem; ...
18:33:00 <orion> Alright I suppose I am still misinformed. I will read the article more carefully.
18:33:21 <geekosaur> multiple instances of Collects may specify the Elem instance as the same type, without that making both instances of Collects the same
18:33:37 <geekosaur> which is why you can't infer c1 ~ c2 from Elem c1 ~ Elem c2
18:34:53 <geekosaur> sorry that decl would have been: class Collects t where type Elem t; ...
18:36:15 <orion> I see.
18:46:22 <orion> geekosaur: It's clear now, thank you.
19:03:30 <Tyg13> Has anyone here ever successfully built gtk2hs for windows?
19:03:57 <Tyg13> I'm getting a build error when linking cairo because it's pulling the wrong version of Cabal, I think
19:04:23 <xaviergmail> Hey, I'm running Arch linux.. Is it normal for ghc to take up 1.1GB in /usr/lib?
19:04:36 <Tyg13> it says can't match Distribution.Blah.Blah with Cabal-1.24.4.0:Distribution.Blah.Blah
19:04:49 <Tyg13> that seems large
19:06:42 <xaviergmail> I have my installation on a tiny 32gb flash drive and that's rather immense lol
19:08:38 <Xnuk> What is `[(Condition v, CondTree v c a, Maybe (CondTree v c a))]`? https://hackage.haskell.org/package/Cabal-1.24.2.0/docs/Distribution-PackageDescription.html#t:CondTree
19:10:39 <Xnuk> Why `Maybe CondTree` exist?
19:51:39 <haasn> I seem to recall some sort of functional trick where you could simulate a rpn/stack style calculation by just appending a bunch of function calls “foo bar bat baz” where foo etc. are all stack operations
19:51:46 <haasn> and probably something like a ‘go’ at the beginning and an ‘E’ at the end
19:51:56 <haasn> but I remember this being possible without type classes (?)
19:52:13 <haasn> not sure if somebody remembers what I mean
19:54:26 <haasn> at any rate I'm not sure if I could construct this without a type class
19:54:42 <haasn> because wouldn't it require something like an infinite type? unless I'm misremembering
20:00:21 <haasn> http://alecb.me/blog/stack-language-ocaml hmm this may have been it
20:01:03 <Lokathor> @pl (\jd -> putStrLn $ "> " ++ (show $ SDL.joystickDeviceName jd))
20:01:03 <lambdabot> putStrLn . ("> " ++) . show . SDL.joystickDeviceName
20:04:39 <haasn> oh right
20:04:45 <haasn> I don't need an infinite type, I just need a polymorphic type
20:04:54 <haasn> because the instantiation will automatically fill in as many parameters as needed
20:06:59 <jle`> haasn: sounds similar to that printf trick
20:07:13 <haasn> printf trick?
20:07:37 <jle`> oh, the printf trick does involve a typeclass though.
20:07:42 <haasn> oh yeah
20:07:45 <jle`> from the Text.Printf module in base
20:07:55 <haasn> the trivial way to construct variadic arguments is with a type class
20:08:08 <haasn> I think for stuff like printf you have no other way, because you need constraints on the parameters
20:08:44 <haasn> but for this continuation passing style example, you can continue the chain for as long as you want because the output is completely polymorphic
20:08:53 <haasn> the output of one operation determines the input of the next
20:08:55 <haasn> basically
20:09:09 <haasn> hmm maybe that could be worked into printf somehow too
20:09:43 <haasn> by having each printf argument pass a phantom type into the next
20:09:53 * haasn should probably sleep before thinking about this
20:12:20 <haasn> Like you can basically have the ‘stop’ function do the work
20:12:37 <haasn> taking that ocaml example
20:12:58 <haasn> go ‘push3’ ‘push4’ ‘push7’ stop  is the same as printf ‘pushvar’ ‘pushvar’ ‘pushvar’ doTheWork
20:13:07 <haasn> where doTheWork is in charge of actually printing those variadic arguments
20:13:27 <haasn> pushvar etc. would all be functions PrintfState -> PrintfState, which can contain whatever you want
20:13:48 <haasn> although this wouldn't let you use e.g. strings or showable things directly
20:14:06 <haasn> you'd need to wrap everything inside a call like printf (show' a) (show' b) (str c) end
20:14:25 <haasn> probably more useful/elegant to just have a type class for that
20:18:12 <jle`> that makes sense, actually
20:18:23 <jle`> yeah, you wouldn't need to have an infinite type
20:19:22 <jle`> go, (go f), (go f g), (go f g h) could all just be stack evaluators with different starting states
20:21:01 <haasn> I mean the trick is that ‘go’ has type (Input -> t) -> t
20:21:40 <haasn> so it could be (Input -> (Input -> t) -> t) -> (Input -> t) -> t
20:21:58 <haasn> and you can keep doing that recursively
20:22:03 <haasn> replacing t by (Input -> t) -> t
20:22:17 <haasn> to get a chain of however many Input -> <polymorphic> functions you want to gather up all the arguments
20:24:41 <riaqn> Hi, what are some good rules choosing between Either e a and exceptions?
20:25:32 <haasn> My rule of thumb: Exceptions for I/O errors, hardware faults, out of memory conditions and other real world bugs; since they can only be caught from IO (which implies “real-worldedness”)
20:25:33 <riaqn> I think exceptions more of "external/impure", while Either more of "computational/pure"
20:25:43 <haasn> use ExceptT for pure exceptions because they can be caught from pure code
20:26:01 <riaqn> hashb[m]: yeah I think so too.
20:30:11 <jle`> exceptions itself only really makes sense in the context of IO
20:30:35 <jle`> well, IO exceptions and Async exceptions at least
20:31:01 <jle`> exceptions for control flow in non-IO-related/non-threaded code is kind of silly, heh
20:31:42 <jle`> since the only context they eventually make sense in is when evaluation is triggered by IO
20:31:46 <riaqn> wait, I didn't know ExcepT before. But it seems quite like EitherT?
20:31:58 <haasn> I think ExceptT is EitherT with better semantics (?)
20:32:05 <jle`> EitherT is ExceptT, but defined in an esoteric package
20:32:06 <haasn> Oh no, that was Pipe vs ListT
20:32:12 <jle`> ExceptT is actualyl defined in 'transformers', which is inclulded with ghc
20:32:30 <jle`> EitherT is defined in the 'either' package which is soon to be deprecated
20:32:46 <riaqn> jle`: OK, so your suggestion would be to use ExceptT?
20:32:53 <jle`> instead of EitherT? yes
20:33:06 <riaqn> OK, thanks!
20:33:06 <jle`> ExceptT and EitherT are the same type, just exported by different packages
20:33:31 <jle`> ExceptT is from the standard transformers package and EitherT is from the defunct either package, so there isn't really any reason to use EitherT :)
20:33:54 <riaqn> jle`: didn't know that. I have been using eitherT for a long time.
20:34:16 <jle`> most of the 'either' package's functionality has been absorbed into transformers, except for some of its neat unitility functions for Either
20:34:32 <jle`> like isLeft, isRight, rightToMaybe, etc.
20:34:38 <riaqn> oh right, what about mtl vs transformers?
20:34:40 <jle`> honestly isLeft/isRight should probably be in base
20:34:52 <jle`> since isJust/isNothing are already in base
20:35:30 <jle`> regarding mtl vs transformers: one is a monad transformer library, and the other is mtl
20:36:01 <riaqn> :-) I heard basically it's some compatibility issue.
20:36:03 <haasn> that one esoteric utility function I use the most is maybeToList / listToMaybe
20:36:17 <jle`> i think mtl and tranfsormers are pretty different libraries
20:36:27 <jle`> mtl is more about offerting typeclasses that let you program generically over effects
20:36:37 <jle`> transformers is about monad transformers (and applicative and functor transformers)
20:36:56 <jle`> so there really is no overlap in functionality, i think
20:37:00 <haasn> (usually because of list comprehension trickery, but for the most part stuff like | Just x <- [m]  works just as well as | x <- maybeToList m)
20:37:32 <jle`> they are commonly associated with each other because mtl re-exports the transformers defined in 'transformers' for some reason
20:37:49 <jle`> and also, the transformers in 'transformers' are a nice way to make instances of the typeclasses in mtl
20:37:56 <jle`> mtl has a rather unfortunate name though
20:38:07 <haasn> I just wish  that [ x | let Just x = Nothing ] had the same semantics as [ x | Just x <- [Nothing] ]
20:38:19 <riaqn> jle`: thanks!
20:38:43 <jle`> transformers = monad transformers, mtl = typeclasses for writing generic effectful programs
20:38:45 <haasn> errors translating to empty lists inside list comprehensions is the best thing ever
20:38:52 <jle`> maybe i'll start reading mtl as "monad typeclasses library"
20:38:57 <jle`> haasn: that'd be nice
20:39:11 <jle`> i use listToMaybe/maybeToList often just as a convenient natural transformation between the two
20:39:34 <jle`> if i want a list where i had a maybe, or a maybe when i had a list
20:39:48 <jle`> listToMaybe is also the awkwardly named 'safeHead' that everyone asks about
20:40:18 <haasn> ‘preview _head’ of course :p
20:42:21 <haasn> man I keep wishing for first-class prisms in haskell
20:42:39 <haasn> stuff like or-patterns or and-patterns (which other popular FP languages have) are trivial with prisms
20:42:57 <haasn> but it's annoying to have to define my own pattern synonym for the prism first
20:43:03 <haasn> instead of just somehow being able to apply magic
20:43:30 <jle`> that's a reasonable next step after redefining record syntax to generate lenses
20:43:32 <haasn> plus I can't really define a bidirectional pattern synonym because I need to use a different instance for constructing and matching
21:56:03 <juliench1rch> Probably not the right place to ask, but I'm working with Elm right now and I'm struggling to understand how to decode a JSON value into a custom union type `type Gender = Male | Female | NonBinary`. I figured there's a decent amount of cross-pollination here and I can't get a response on the Elm slack channel
21:56:38 <juliench1rch> For reference: https://github.com/elm-lang/core/blob/5.0.0/src/Json/Decode.elm
21:57:18 <Lokathor> I think you should decode it to String, and then guess based on the string
21:57:51 <juliench1rch> Lokathor: My initial thought, but then I end up with a Result String Gender
21:58:13 <juliench1rch> I'd prefer to just have the entire thing fail than carry around an Err (Left) 
21:58:24 <Lokathor> well, yes, there's no way to avoid that your decoding might fail, so you have to handle that somehow
21:58:42 <Lokathor> depending on the situation, you could just pattern match against the Right and have your program crash if the pattern match fails
21:58:45 <Lokathor> but that's like... a bad plan
21:58:51 <juliench1rch> :P
21:59:03 <Lokathor> you should perhaps come up with a default value and then provide that if there's an error
21:59:12 <Lokathor> default to NonBinary for example
21:59:38 <juliench1rch> I was playing around with that too, just defaulting to, say, PreferNotToDisclose (or something terser...)
22:00:00 <athan> juliench1rch: Yeah you should use Json.Decode.string, then match against the decoded string after an andThen
22:00:00 <juliench1rch> Mainly because unwrapping the types is exhausting and I can barely wrap my little mind around what's going on
22:00:41 <athan> string `andThen` (\s -> if s == "big potato moths" ->
22:00:44 <athan> etc
22:01:15 <Lokathor> http://68.media.tumblr.com/7892fba4c809fc7ba1201fc5738926ae/tumblr_nsmaj3Pvi31tfg29to1_1280.png better put this gender in your enum too
22:01:18 <athan> (for the source, look up "herman caine bad lip reading")
22:01:38 <juliench1rch> athan: So then I'd end up with an intermediary type because this is ultimately going into a `type Session = AnonSession | Session Member`
22:02:17 <athan> Decoder is very compositional; it shouldn't be too bad clicking them together
22:02:53 <systemfault> juliench1rch: The freenode Elm channel is a desert but their Slack is very active (Just in case you have questions in the future)
22:03:13 <athan> cowboys and anthrax!
22:03:18 <juliench1rch> systemfault: I tried on Slack, but it's a bit late :(
22:03:44 <athan> yeah the elm slack was full of questions, no answers last time I poked around
22:04:13 <juliench1rch> Lokathor: I'll add the N'Grath. Thanks for the suggestion.
22:04:17 <juliench1rch> :]
22:04:45 <systemfault> juliench1rch: Let me try something
22:04:51 <Lokathor> I think this just tells us that gender :: String is better
22:05:52 <juliench1rch> Lokathor: Yeah, I think you might be right.
22:06:35 <juliench1rch> I think I might be overthinking this.
22:08:09 <athan> codification can have its uses, but only if it is worth codifying :)
22:10:12 <Lokathor> just map toLower over it and you're done
22:10:34 <Lokathor> if someone writes "mal" instead of "male" it's really not worth troubling over I think
22:10:47 <Lokathor> maybe they wanna ba Malcom Reanolds, who knows
22:13:00 <systemfault> juliench1rch: https://runelm.io/c/zlz
22:13:12 <systemfault> juliench1rch: You can clean it up a bit but that's the idea
22:13:14 <juliench1rch> systemfault: checking
22:18:06 <juliench1rch> ur like smart n stuff rite
22:18:19 <juliench1rch> No, but seriously, thanks.
22:19:09 <systemfault> You're welcome :)
22:19:14 <systemfault> I was also on Slack...
22:19:19 <systemfault> Just saw your question too late.
22:19:37 <juliench1rch> Hah! Woops. I gave up hope and minimized it.
22:20:37 <juliench1rch> Evan, give me back my backticks, man.
22:21:12 <systemfault> Yeah... they got removed with 0.18
22:21:20 <systemfault> Along with haskell-like ranges :/
22:21:47 <juliench1rch> Yeah, jeez. I really love those.
22:22:26 <juliench1rch> I understand where he's going with things, and I've read enough of the Google groups threads to know he's incredibly thoughtful.
22:23:01 <systemfault> Oh yeah, the guy is not stupid.
22:23:09 <juliench1rch> It's just...I liked those
22:23:13 <systemfault> 0.18 made Http a lot nicer
22:23:22 <juliench1rch> Yeah it did.
22:24:20 <juliench1rch> It's actually reassuring considering how many smart people worked on it that there's still so much room for improvement.
22:25:01 <systemfault> I miss typeclasses and from what I understand, they're a controversial topic :/
22:25:37 <juliench1rch> Hah, yeah. I've seen threads where he seems to get a little heated about it.
22:25:54 <juliench1rch> I guess I would too if I had to say "no" for the 100th time, though.
22:27:07 <juliench1rch> I've felt for a long time that introducing some more advanced features but keeping the focus on simplicity wouldn't be so bad. Sometimes I read certain Haskell libs and I wonder if it's not just complex for the sake of being complex :P
22:38:47 <praveen__> I am reading wiki Typeclassospedia. I came across type ((,) e) . what is it called in haskell?
22:39:29 <suzu> tuple or pair
22:39:31 <geekosaur> partially applied 2-tuple
22:39:50 <suzu> ^ what geekosaur said is better
22:40:15 <praveen__> thanks. not I can read more about it
22:40:28 <praveen__> *now I ..
22:47:42 <codygman> Is there a better way to make  a filter based on whether a given ZonedTime is 30 days before today?
22:47:44 <codygman> http://lpaste.net/350420
23:05:02 <jchia_> I'm trying to indent my existing code properly. Looking through others' code, I'm first trying to decide whether to use an indentation size of 2 or 4 and I come across source files where an unindented line is followed sometimes by one indented with 2 spaces and sometimes by one indented with 4 spaces. Is this just inconsistency or some elaborate code style at work? For example, compare the type signature for catchIf and the MonadThrow instance of ContT r m s
23:05:27 <suzu> use hindent and call it a day
23:05:56 <jchia_> I wish I could use hindent and have consistent indentation, but I find that hindent sometimes gives weird results.
23:06:03 <suzu> oh :(
23:06:08 <suzu> its not supposed to do that
23:06:09 <Lokathor> so sdl2 was giving me an error about "unsafe reentry"
23:06:26 <Lokathor> but i did something or other and it seems to have gone away
23:06:28 <Lokathor> but i don't know why
23:12:03 <jchia_> @suzu: Does "not supposed to do that" mean you find that it's usually OK?
23:12:03 <lambdabot> Unknown command, try @list
23:12:21 <jchia_> suzu: Does "not supposed to do that" mean you find that it's usually OK?
23:12:37 <Lokathor> so does a thread that's waiting from threadDelay respond to exceptions?
23:48:33 <v0d1ch_> ?
23:48:37 <v0d1ch_> oops
23:49:54 <v0d1ch_> \
