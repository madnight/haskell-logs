00:02:44 <bolly> does anyone here use a terminal IRC client?
00:02:47 <bolly> I'm trying to pick one
00:03:11 <ongy> http://hackage.haskell.org/package/glirc
00:03:30 <ongy> ^bolly
00:04:06 <bolly> ongy: ooh, ty
00:08:03 * hackagebot itemfield 1.1.0.2 - A brick Widget for selectable summary of many elements on a terminal  https://hackage.haskell.org/package/itemfield-1.1.0.2 (KevinQuick)
00:08:04 * hackagebot itemfield 1.2.0.0 - A brick Widget for selectable summary of many elements on a terminal  https://hackage.haskell.org/package/itemfield-1.2.0.0 (KevinQuick)
00:20:02 <EvilMachine> Hey, what is the Foldable/Traversable equivalent to take? I can’t find an equivalent function in there.
00:23:05 <cocreature> EvilMachine: there is only "take n . toList". Foldable/Traversable don’t give you a take on the data structure itself
00:25:12 <EvilMachine> cocreature: Yes, but is that intentional?
00:25:26 <EvilMachine> cocreature: If yes, that must be because there’s a better way.
00:26:42 <EvilMachine> e.g. Seq has its own take
00:26:44 <ertes> EvilMachine: you can implement 'take' in terms of foldr
00:27:04 <systemfault> Can you?'
00:27:10 <EvilMachine> systemfault: of course
00:27:15 <systemfault> Perhaps an ugly.. and inefficient way
00:27:18 <systemfault> Hmm
00:27:20 <ertes> @let myTake n xs = foldr (\x more n -> if n <= 0 then [] else x : more (n - 1)) (const []) xs n
00:27:23 <cocreature> EvilMachine: Foldable is too general. being able to convert something to a list does not mean that taking a fixed number of elements leaves you with a valid data structure
00:27:23 <lambdabot>  Defined.
00:27:27 <EvilMachine> systemfault: everything that loops is a fold
00:27:30 <ertes> > take 10 [0..]
00:27:34 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
00:27:38 <ertes> > myTake 10 [0..]
00:27:40 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
00:27:49 <cocreature> I thought EvilMachine wants a take on the original structure
00:27:52 <systemfault> EvilMachine: Yes... it's just bad to iterate through every element of a list if you only need the first X.
00:27:55 <ertes> systemfault: it's just as efficient as the regular 'take'
00:28:03 <cocreature> so e.g. take :: Int -> Tree a -> Tree a
00:28:13 <systemfault> Hmm
00:28:32 <cocreature> systemfault: haskell is lazy :)
00:28:58 <EvilMachine> cocreature: I don’t need a “shorter” version of the original data stucture. I only need a data structure I can fold over as a result. A Seq, a list, whatever
00:28:59 <systemfault> Right
00:29:17 <ertes> EvilMachine: if you want an efficient splitAt that doesn't actually iterate, then Foldable can't do it
00:29:18 <cocreature> EvilMachine: then what’s wrong with take n . toList?
00:29:32 <systemfault> Thanks for showing me :)
00:29:34 <ertes> EvilMachine: so you shouldn't use Foldable to split Vector, for example
00:29:43 <EvilMachine> ertes: aah, that makes sense.
00:30:07 <ongy> ertes: how can I do splitAt without iteration on listts? Or is that for structures that support it?
00:30:36 <bollu__> offtopic: IRC is telling me that my nick is temoporarity unavaiable. any ideas why?
00:30:41 <ertes> ongy: for lists that's the only way, but for some other structures like Seq nad Vector there are much more efficient ways
00:30:53 <EvilMachine> ertes: Just to recap: Seq is a linked list (-equivalent), and Vector is a block of data with all the equally big elements lined up. Right?
00:31:18 <cocreature> bollu__: there is already a bollu_ logged in. bollu should be free
00:31:54 <bollu__> cocreature: yep, but "/nick bollu" says that "this username is temporarily unavailable". Though the username is registered 
00:31:59 <ertes> bollu__: if you don't authenticate timely, services will change your nick and suspend the nickname
00:32:06 <bollu__> ertes: oh what? o_O
00:32:07 <EvilMachine> bollu__: Somebody else uses it? Maybe you before a disconnect?
00:32:17 <bollu__> ertes: fuck, okay, so how do I re-authenticate myself?
00:32:33 <EvilMachine> bollu__: If you wait for the pre-disconnect one to time out, it will be re-usable again, i guess
00:32:36 <ertes> bollu__: /msg nickserv help release
00:32:41 <bollu__> ertes: thanks
00:33:18 <bollu> hm, I see
00:33:20 <ertes> EvilMachine: Seq is a sequence data structure based on finger trees that allows efficient splitting and appending
00:33:37 <EvilMachine> cocreature: I would like to avoid the pre-”take” toList, and just fuse it to go straight from Foldable to Seq
00:33:51 <bollu> ertes: ty
00:33:54 <ertes> EvilMachine: Vector is different things depending on which flavour of Vector you use, but's always based on a memory array (of pointers or of direct values)
00:34:46 <EvilMachine> ertes: memory array in what sense? in the sense of a block of memory that is used as a list (of pointers or values)?
00:34:55 <ertes> EvilMachine: yeah
00:35:00 <EvilMachine> ertes: okay. 
00:35:01 <EvilMachine> :)
00:35:02 <ertes> it's a sequence type
00:35:28 <ertes> with super-fast lookup at the expense of pretty much every other operation being slow =)
00:36:12 <cocreature> at least asymptotically slow
00:36:43 <cocreature> in practise copying around continuous blocks of memory can be surprisingly cheap
00:37:16 <ertes> yeah…  also linearly searching an unsorted 30-element Vector may still be faster than doing a Map lookup depending on the case
00:38:02 <EvilMachine> ertes: Yes. Vector is efficient to read and in memory but inefficient to alter. Seq is efficient to alter but inefficient to read and in memory.
00:38:07 <ertes> EvilMachine: Seq is efficient to read…  everything is logarithmic at worst
00:38:09 <cocreature> I recently tried to improve the performance in my c++ code and ended up using vectors for pretty much everything
00:38:35 <EvilMachine> ertes: Wait, no, it must be faster to insert an elemt than with Vector.
00:38:50 <EvilMachine> cocreature: Duh.
00:38:52 <ertes> it is =)
00:39:16 <ertes> EvilMachine: i recommend investing an hour to watch this video: https://www.youtube.com/watch?v=fHNmRkzxHWs
00:39:21 <ertes> cocreature: you might like it, too
00:39:23 <EvilMachine> cocreature: Especially if you got a Vector processor. (Nowadays called GPU ;)
00:39:34 <ertes> it's C++-centric, but not C++-specific
00:39:41 <cocreature> ertes: I think I have already seen that one :)
00:39:47 <ertes> everything he says applies to haskell, too
00:40:06 <cocreature> ertes: he also gave a nice talk this year on optimizing small vectors, maps, …
00:40:18 <ertes> cocreature: is it online?
00:40:24 <cocreature> yep let me search for it
00:40:39 <EvilMachine> ertes: You have no idea how much way more urgent stuff I have to invest an hour in before I get to this. ^^
00:40:45 <cocreature> ertes: should be this one https://www.youtube.com/watch?v=vElZc6zSIXM
00:40:52 <bollu> where do I understand STG? The original paper uses notation that I'm not aware of IIRC
00:41:07 <bollu> I want to grok the haskell execution moel
00:41:08 <bollu> model*
00:41:17 <cocreature> bollu: https://github.com/quchen/stgi#readme is pretty awesome for that
00:41:25 <bollu> cocreature: ohh, neat :)
00:41:33 <bollu> cocreature: oh wow, that's so cool
00:42:05 <ertes> EvilMachine: sure, that's up to you…  he breaks down the efficiency story very nicely and makes you aware of important details that asymptotics don't cover
00:42:34 <cocreature> I also learned how to use perf from a talk by chandler :)
00:42:37 <bollu> also, "STG" sounds so cool. Almost evil-scientist level cool
00:42:50 <ertes> that's also why i'm a big fan of finger tree/vector-based hybrid sequences…  they are crazy fast for almost everything =)
00:43:29 <ertes> and using them you can get away with functional data structures for many things you would otherwise use mutable vectors for
00:43:50 <EvilMachine> ertes: Yes, It’s probably great. I’ll bookmark it. I come from a low-level coding background, back in the days, where these things were kinda a must.
00:45:25 <ertes> cocreature: thanks =)
00:45:39 <EvilMachine> ertes: (”PC intern” was my favorite book as a teen. 1400, then 2500 pages of direct hardware access, assembler, interrupts and registers, etc :)
00:45:53 <bollu> WHNF?
00:46:04 <cocreature> bollu: weak head normal form
00:46:25 <cocreature> bollu: it basically means that you evaluate something until you hit the first constructor or a lambda
00:46:40 <cocreature> so a list would be evaluated to _ : _ or []
00:47:00 <cocreature> the parts marked by _ can still be unevaluated
00:47:25 <bollu> cocreature: so you "skip" constructors but try to evaluate things that they are constructing?
00:48:00 <cocreature> bollu: no, you evaluate a term to see what the first constructor is
00:48:04 <bollu> cocreature: (1 + 1) : (2 + 2) : [] --WHNF--> 2 : 4 : [] ?
00:48:08 <cocreature> s/first/outer most/
00:48:30 <cocreature> bollu: no that would just be (1 + 1) : (2 + 2) : []
00:48:40 <cocreature> the outer most constructor is : and you have already evaluated up to that point
00:49:09 <cocreature> if you have "if x < 0 then [] else 1 : []" this would be evaluated to check if the outermost constructor is [] or :
00:49:35 <bollu> cocreature: by "this" you mean the "if expression"?
00:49:48 <cocreature> yep
00:50:05 <EvilMachine> ertes: What would be examples of such hybrid structures
00:50:07 <bollu> cocreature: I see. functions will also never be evaluated, right?
00:50:17 <bollu> cocreature: since you said lambdas are unevaluated
00:50:30 <ertes> EvilMachine: as i said: finger trees of vectors
00:50:30 <bollu> cocreature: so only let, if, case, etc. can be reduced?
00:50:53 <ertes> EvilMachine: more generally an F of vectors, but finger trees really do pretty much everything i've needed so far
00:50:53 <cocreature> bollu: well if they are applied to arguments they will be evaluated, but if what you are evaluating has a function type it won’t be evaluated
00:50:59 <ertes> @package fingertree
00:50:59 <lambdabot> http://hackage.haskell.org/package/fingertree
00:51:03 <ertes> EvilMachine: ^
00:51:08 <EvilMachine> ertes: aah, I read the “/” as OR.
00:51:13 <cocreature> bollu: basically whnf means that you evaluate just enough to check which clause you have to chose in a "case" statement
00:51:26 <EvilMachine> ertes: or as AND
00:51:32 <EvilMachine> ertes: but not as OF
00:51:36 <bollu> cocreature: I see
00:51:40 <cocreature> bollu: ignoring that you can have more complex case statements in haskell where you have nested matche
00:51:58 <bollu> cocreature: so you're saying that (\x -> ...) is not evaluated, but (\x -> ..) $ 1 *will* be?
00:52:22 <EvilMachine> ertes: what do you mean with “F”? (if not “finger tree”)
00:52:34 <ertes> EvilMachine: sometimes lists of vectors make sense, too (a "lazy vector"), but for most use cases we have ready-made implementations of those:  lazy ByteString, lazy Text
00:52:42 <ertes> EvilMachine: any F
00:52:52 <cocreature> bollu: yep
00:53:49 <bollu> cocreature: I see, ty
00:53:57 <bollu> cocreature: so do you recommend that I should write STG programs?
00:54:27 <cocreature> bollu: I’ve never done so myself so I guess not :)
00:54:34 <bollu> cocreature: xD
00:54:38 <bollu> cocreature: how did you learn STG?
00:54:40 <cocreature> bollu: thinking about how your haskell programs are desugared to stg is useful
00:54:46 <bollu> cocreature: I see
00:54:53 <cocreature> and then know the execution model of stg (roughly) and you can avoid spaceleaks
00:55:10 <ertes> EvilMachine: the basic idea of having a layer of vectors is that of a *rope*: https://en.wikipedia.org/wiki/Rope_(data_structure)
00:55:29 <cocreature> bollu: not sure I think I just picked up pieces here and there. I never sat down and decided to learn stg specifically
00:55:38 <EvilMachine> ertes: I think I want a type (List o), where o is a set of properties the resulting type will be optimized for. (E.g. Reading, Inserting, MemorySaving.)
00:55:49 <bollu> cocreature: hm, I see
00:55:50 <EvilMachine> ertes: Ditto for trees and graphs.
00:55:55 <cocreature> I’m by no means an expert in stg but I feel like I know enough to have an idea how my haskell code runs
00:56:53 <cocreature> I’ll probably find out whether that’s the case when I’m looking for a haskell job :)
00:56:56 <bollu> cocreature: how hard would it be to implement an STG interpreter?
00:57:03 <bollu> cocreature: xD you don't work with haskell?
00:57:10 <cocreature> I’m a student
00:57:16 <ertes> EvilMachine: unfortunately such an abstraction will most likely give you Map, Seq or Set for pretty much everything, because it's difficult to encode details of the usage pattern
00:57:23 <cocreature> and I write mostly formal verification tools in c++ these days
00:57:26 <bollu> cocreature: oh, I see :) where, if I may ask?
00:57:31 <cocreature> bollu: germany
00:57:46 <cocreature> I write haskell but only in my free time and some small tools here and there
00:58:03 <EvilMachine> ertes: Not as difficult as learning real Haskell as a newbie. :)
00:58:33 <ertes> bollu: i came from C++ originally, too…  and if it weren't for haskell, i would probably still use C++ today =)
00:58:37 <ertes> or perhaps rust
00:58:38 <EvilMachine> ertes: Let’s create a usage pattern description mini-DSL on the type level. ;)
00:58:52 <ertes> EvilMachine: you're welcome to try =)
00:58:55 <bollu> ertes: yes, I'm from the same family :) I like Rust though, I used to use it back when it was in beta
00:58:57 <cocreature> I need LLVM so I basically have to use c++
00:59:11 <bollu> cocreature: haskell bindings for LLVM exist, right?
00:59:29 <cocreature> bollu: yep, I’m the one that updated them from 3.5 to 3.8 and then to 3.9 :)
00:59:34 <jmorris> im trying to write a function that rounds down to the nearest 1000
00:59:35 <bollu> cocreature: ah, neat :)
00:59:39 <ertes> EvilMachine: i'd wait for -XDependentTypes for that one ;)
00:59:48 <cocreature> bollu: but LLVM bindings are mostly useful for generating code not for analyzing LLVM assembly which is what I’m doing
00:59:50 <jmorris> so f(1001) = 1000 and f(1900) = 1000
00:59:59 <EvilMachine> ertes: I’m a noob. I don’t even know which is which, with foldr and folds. (Every mnemotic failed.)
01:00:11 <EvilMachine> foldr and foldl i meant
01:00:23 <ertes> EvilMachine: foldr is the list fold combinator…  you can write pretty much everything that reduces lists in terms of it
01:00:23 * EvilMachine thinks about a function called floodr.
01:00:26 <bollu> ertes: how serious are you about haskell getting that particular extension? :P
01:00:31 <ertes> EvilMachine: even foldl'
01:00:35 <bollu> cocreature: I see
01:00:45 <ertes> bollu: i think at some point it will come
01:00:49 <EvilMachine> ertes: :D
01:00:49 <tdammers> EvilMachine: a better way of going about this, I think, would be to create a SomeMap type that gives you runtime polymorphism for map-like objects
01:01:25 <tdammers> EvilMachine: then the programmer could pick one implementation or the other, and feed it to the exact same machinery
01:01:26 <EvilMachine> ertes: And foldr' is the non-lazy version of it, yes.
01:01:36 <ertes> EvilMachine: foldr' doesn't really make sense
01:01:46 <EvilMachine> ertes: or did i mean foldl'?
01:01:49 <EvilMachine> see? it’s a mess
01:01:52 <tdammers> EvilMachine: then again, you hardly ever need to do the dispatching at runtime, plain old typeclasses are often a better idea
01:01:58 <ertes> foldl' is the strict left fold combinator
01:02:17 <ertes> EvilMachine: i'm writing a fold tutorial…  that might help you =)
01:02:25 <cocreature> bollu: also the maintainer of llvm-general and I disagree on various things which makes working on it a bit frustrating
01:02:32 <ertes> EvilMachine: i can upload the current state, if you want
01:03:02 <EvilMachine> tdammers: runtime? that would mean the system chooses. not the programmer. but the programmer should at least be able to say what he wants.
01:03:23 <EvilMachine> tdammers: wait, i hadn’t read all of it yet.
01:03:28 <tdammers> EvilMachine: the programmer of the producer of the map-like object picks an implementation.
01:03:47 <EvilMachine> tdammers: yes,
01:04:09 <EvilMachine> ertes: I understand folds well. I just can’t remember which one is which.
01:04:17 <EvilMachine> ertes: I always end up with reversed lists and such.
01:04:41 * EvilMachine wants to kill cons, and prays to the gods of snoc! ;)
01:05:27 * tdammers thinks calling it "snoc" instead of "ns" is a huge missed opportunity
01:05:39 <lyxia> hahaha
01:05:51 <ertes> hehe
01:05:51 <ertes>  
01:06:04 <ertes> @let mySum xs = let f x more s = more $! s + x in foldr f id xs 0
01:06:08 <lambdabot>  Defined.
01:06:15 <ertes> > mySum [1..100000]
01:06:18 <lambdabot>  5000050000
01:06:46 <EvilMachine> tdammers: ns?
01:06:56 <ertes> EvilMachine: want some ffee?
01:07:03 <EvilMachine> ffee?
01:07:16 <EvilMachine> *yells* what are these words you all are confusing me with?? 
01:07:26 <ertes> they aren't that nfusing
01:07:28 <opqdonut> co-cons is ns
01:07:32 <opqdonut> co-coffee is ffee
01:07:36 <opqdonut> category theory jokes yay
01:07:52 <EvilMachine> sounds more like co-coaine
01:07:59 <ertes> in a dual world you are currently nfusing us =)
01:08:08 <bollu> lol, "ns" is so cute
01:08:19 <EvilMachine> I don’t get it. :((
01:08:31 <jmorris> why doesn't this work http://lpaste.net/348543
01:08:40 <tdammers> maybe that's llateral damage from nsuming too much caine
01:08:43 <ertes> EvilMachine: https://en.wikipedia.org/wiki/Dual_(category_theory)
01:09:45 <ertes> products vs. coproducts, ends vs. coends, limits vs. colimits, coffee vs. ffee
01:09:51 <EvilMachine> ertes: I understood that dual joke. ”Dual” is a confusing word for that concept though. And I’d bet money that that’s deliberate. ;)
01:09:59 <folsen> I'm having some issues trying to express something with arrow notation (in the hasql library), anyone have experience with arrows that can take a look? http://stackoverflow.com/questions/40906464/equivalent-of-a-traverse-in-arrow-notation
01:10:08 <ertes> EvilMachine: know a better word?
01:11:05 <ertes> folsen: you can't have 'traverse' for Arrow in general, unless you also have ArrowChoice
01:11:17 <EvilMachine> ertes: anything that implies that they’re opposites in some way, at least. ”dual” sounds like they’re a team of equals.
01:11:31 <opqdonut> dualism is about opposites
01:11:33 <ertes> folsen: proc xs -> case xs of …  -- case splitting requires ArrowChoice
01:11:48 <EvilMachine> ertes: I know about the Tardis monad. :D
01:12:02 <ertes> EvilMachine: they are a team of equals in a sense
01:12:26 <ertes> they aren't inverses or complementary…  they really just are "related" in that if one exists, the other exists
01:12:37 <EvilMachine> ertes: You mean like the Doctor and the Master? :D
01:12:44 <folsen> ertes: the Query type does have ArrowChoice as well
01:13:08 <ertes> EvilMachine: you have probably already used reverse state, just not in the context of a reverse state/tardis monad =)
01:13:11 <ertes> foldr does reverse state
01:13:13 <EvilMachine> ertes: Do you know an example where they aren’t on opposing sides on _any_ axis?
01:13:25 <EvilMachine> :D
01:13:35 <ertes> > foldr (\x ~(ys1, ys2) -> (x:ys2, ys2)) mempty "abcdefghij"
01:13:37 <lambdabot>  ("a","")
01:13:42 <ertes> > foldr (\x ~(ys1, ys2) -> (x:ys2, ys1)) mempty "abcdefghij"
01:13:44 <lambdabot>  ("acegi","bdfhj")
01:13:49 <ertes> this is a reverse-stateful pattern
01:14:10 <EvilMachine> ertes: What’s that ~ doing there?
01:14:24 <ertes> > foldr (\x (ys1, ys2) -> (x:ys2, ys1)) mempty [0..]
01:14:26 <lambdabot>  *Exception: stack overflow
01:14:29 <ertes> > foldr (\x ~(ys1, ys2) -> (x:ys2, ys1)) mempty [0..]
01:14:31 <lambdabot>  ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
01:14:32 <bollu> ertes: what's the ~?
01:14:38 <opqdonut> lazy pattern match
01:14:44 <EvilMachine> nice
01:14:45 <lpaste> tdammers pasted “runtime polymorphism for map-like data structures” at http://lpaste.net/348544
01:14:51 <tdammers> EvilMachine: ^
01:14:52 <bollu> oh wow, 
01:15:49 <Forlorn> How could I get all possible permutations of N arranged items? e.g for A,B to [A,B], [B,A]
01:16:18 <EvilMachine> tdammers: I don’t like the idea of runtime behavioral change though.
01:16:24 <ertes> Forlorn: have you tried implementing it?
01:16:27 <EvilMachine> tdammers: I mean beyond what I coded.
01:16:38 <tdammers> EvilMachine: then just use a typeclass and make it compile-time
01:16:45 <Forlorn> ertes, I can't wrap around my head on how to do it.
01:16:56 <EvilMachine> Btw: I noticed that monads are just fancy-looking folds. :)
01:17:07 <Forlorn> ertes, can you give me suggestions?
01:17:13 <tdammers> Forlorn: this is a textbook problem for recursive problem solving approaches
01:17:17 <ertes> Forlorn: one way would be to look up how 'permutations' works, and make it terminate early
01:17:25 <ertes> > permutations "abcd"
01:17:26 <EvilMachine> Forlorn: there’s already a tfucniton for that.
01:17:28 <lambdabot>  ["abcd","bacd","cbad","bcad","cabd","acbd","dcba","cdba","cbda","dbca","bdca...
01:17:34 <EvilMachine> Forlorn: there’s already a function for that.
01:17:54 <tdammers> for the learning experience, you could implement it yourself though
01:18:01 <tdammers> start with "permutations of the empty list"
01:18:05 <tdammers> that one is easy to solve
01:18:13 <ertes> Forlorn: another would be to think:  perm n (x:xs) = _  -- given the list of (n-1)-permutations from xs, what are the n-permutations of (x:xs)
01:18:14 <ertes> ?
01:18:20 <ertes> Forlorn: try it
01:18:21 <tdammers> "permutations of a single-element list" is also easy
01:18:22 <EvilMachine> Forlorn: Hmm… http://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.OldList.html#permutations
01:18:28 <Forlorn> ertes, n!
01:18:35 <EvilMachine> Forlorn: I would have to draw that out on a piece of paper too.
01:18:48 <Forlorn> I know how to produce n! permutations on paper
01:19:05 <tdammers> what remains is "permutations on a list with 2 or more elements"
01:19:18 <ertes> Forlorn: perm 2 "abc" = ["ab", "ac", "bc"]
01:19:25 <tdammers> now the trick is to pretend that given a list of n elements, you already know the permutations for a list of n-1 elements
01:19:29 <ertes> Forlorn: perm 3 ('x' : "abc") = ?
01:20:08 <tdammers> so given one element, and a list of permutations of a sublist, you generate all the permutations that result from inserting your extra element into each possible position in each of the given permutations
01:20:10 <Forlorn> oh
01:20:13 <Forlorn> I understand now
01:20:14 <Forlorn> thanks
01:20:25 <Forlorn> I forgot how to haskell
01:20:39 <ertes> just try it…  you will get the idea =)
01:23:01 * hackagebot yesod-core 1.4.28 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.28 (MichaelSnoyman)
01:23:03 * hackagebot yesod-test 1.5.4 - integration testing for WAI/Yesod Applications  https://hackage.haskell.org/package/yesod-test-1.5.4 (MichaelSnoyman)
01:35:51 <lpaste> bollu pasted “naive-permutations” at http://lpaste.net/348549
01:36:07 <bollu> is that the fastest way of doing the permutations question?
01:36:14 <bollu> there should be better ways, right?
01:36:17 <bollu> how do I optimise it?
01:38:16 <ertes> bollu: use splitAt
01:38:32 <ertes> bollu: but ideally you don't use splitting at all
01:39:33 <bollu> ertes: really?
01:39:35 <bollu> ertes: hm
01:41:03 <cocreature> bollu: fwiw there is a "permutations" implementation in Data.List that you could look at but it is really hard to understand. iirc there is a stackoverflow post somewhere where the author explains how it works
01:42:11 <lyxia> There http://stackoverflow.com/questions/24484348/what-does-this-list-permutations-implementation-in-haskell-exactly-do
01:42:45 <bollu> ooh, thanks
01:43:52 <cocreature> I never bothered to figure out how it works :)
01:47:06 <bollu> oh wow
01:47:07 <bollu> that is mad
02:03:01 <guillaum2> Currently stack ghci imports all the module unqualified. Is there a way to tell stack to import them qualified ?
02:34:38 <John[Lisbeth]> can you program concatenatively in haskell?
02:36:32 <ongy> what does that mean? program in files and send 'cat *.hs' into the compiller?
02:38:06 <John[Lisbeth]> ongy: are you talking to me?
02:38:09 <ongy> John[Lisbeth]: looking at the wiki article to it, I'd say with Data.Composition you can do most of it, but it doesn't always make sense
02:38:23 <ongy> the first one wasn't really a serious answer
02:39:00 <John[Lisbeth]> What I would like to do is accept arguments by popping and immutable datastructure an pass return values by pushing onto an immutable datastructure
02:39:04 <ongy> @pl 
02:39:04 <lambdabot> (line 1, column 1):
02:39:04 <lambdabot> unexpected end of input
02:39:04 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
02:41:10 <John[Lisbeth]> It looks like this. push(1); push(2); plus(); pop() => 3
02:41:32 <John[Lisbeth]> but push merely makes another refernce to an immutable linked list
02:41:44 <John[Lisbeth]> and pop simply makes a reference in the same way
02:42:26 <John[Lisbeth]> the linked list would have to be of arbitrary type
02:42:48 <ongy> that's how lists work in haskell. for this to look mice it may be possible to write a monad for it and use the do notation.
02:43:12 <John[Lisbeth]> yes, do would be essential
02:43:15 <ongy> for the list type HList may be intersting, I haven't used them, so I'm not 100% sure if it will work
02:43:29 <John[Lisbeth]> though if I used do would it sitll be purely functional?
02:44:05 <lyxia> do notation is just sugar, it's all functions underneath
02:44:24 * John[Lisbeth] wipes away forehead sweat figuratively
02:45:12 * ongy now wants to play around with a Typed Stack and Monad for push/pop on it
02:45:29 <John[Lisbeth]> he he he
02:45:59 <John[Lisbeth]> I have worked on making a concatenative javascript and a concatenative bash and both are working
02:46:17 <John[Lisbeth]> you can do "functional programming" by pushing and popping from a stack although I have not made it immutable in either of these yet
02:46:53 <jle`> ongy: you might like indexed monads
02:48:06 <ongy> John[Lisbeth]: I think it's easier to do that in haskell with Data.Composition
02:48:17 <John[Lisbeth]> Let me show you my implementations
02:48:19 <John[Lisbeth]> they are really short
02:48:20 <lyxia> A first simple implementation can just use State...
02:48:25 <John[Lisbeth]> I don't know haskell well enough to implement it
02:48:52 <John[Lisbeth]> https://github.com/johnmorrisbeck/concatenativeJavascript
02:49:18 <John[Lisbeth]> https://github.com/johnmorrisbeck/concatenativeBash
02:49:23 <John[Lisbeth]> though those are not immutable
02:50:26 <John[Lisbeth]> all you really need is a linked list of arbitrary type. Nothing more
02:50:35 <John[Lisbeth]> then you just define functions that push and pop
02:52:26 <John[Lisbeth]> I'm rusty but
02:53:43 <ddk_> hello 
02:53:47 <John[Lisbeth]> aloha
02:54:31 <ddk_> i am trying to install text-icu library from hackage on my debian but getting the error :: --> Missing C libraries: icuuc, icui18n, icudata      
02:54:44 <ddk_> can some tell me what to do next
02:55:26 <srhb> ddk_: Check the debian packaged version of text-icu to figure out what its external dependencies are and install those.
02:55:47 <ddk_> srhb : how 
02:56:30 <srhb> ddk_: Uh, I don't remember how to check dependencies with apt. 
02:57:32 <ddk_> srhb : anyguess please 
02:58:42 <srhb> ddk_: Look at this page: https://packages.debian.org/jessie/libghc-text-icu-dev
02:59:00 <srhb> ddk_: It shows two non-Haskell dependencies, libicu52 and libicu-dev
02:59:10 <srhb> ddk_: You probably only need the first one, though I'm not completely sure.
03:00:34 <ddk_> srhb : thanks a lot !!
03:00:48 <bollu_> I'm trying to implement johnson trotter in haskell
03:00:55 <bollu_> and it's horrible since it's trying to do imperative things
03:01:00 <srhb> ddk_: You're welcome.
03:01:01 <bollu_> like swap 2 elements of a list
03:01:17 <bollu_> how does one convert an imperative algorithm into a functional algorithm?
03:01:26 <bollu_> "throw the old approach away" is quite unappealing
03:01:30 <bollu_> and ST seems like overkill
03:01:34 <bollu_> (can I use ST for this?)
03:01:48 <ddk_> srhb : it worked for me thanks a lot .... sudo apt-get install libghc-text-icu-dev 
03:03:30 <bollu_> how do I convert very imperative array edits into a FP style?
03:04:22 <systemfault> bollu: There's no "direct mapping", it depends on the case.
03:04:54 <osfabibisi> "Johnson Trotter" might be the best algorithm name I've seen
03:05:37 <Guest10338> systemfault: damn :( so in this case?
03:06:34 <osfabibisi> you can swap elements with pattern matching
03:06:48 <Guest10338> osfabibisi: what? how?
03:06:53 <Guest10338> osfabibisi: at an arbitrary index?
03:07:19 <osfabibisi> Guest10338: well, for example:  let swap (a:b:rest) = b : a : rest
03:07:39 <Guest10338> osfabibisi: yes, but that is at the beginning
03:07:49 <Guest10338> osfabibisi: to edit at some index, I need to split till there, and then patterm match
03:07:50 <ahihi> you probably will want ST
03:07:52 <Guest10338> right
03:07:54 <Guest10338> ?
03:07:58 <Guest10338> I see
03:08:10 <jle`> yeah, lists aren't a good data structure for indexed access.  that's just not what they were designed for
03:08:23 <osfabibisi> can't you recurse through the list and swap at whatever position you're currently at?
03:08:25 <jle`> you might want a more suitable structure like arrays or vectors
03:08:42 <osfabibisi> I haven't grokked https://en.wikipedia.org/wiki/Steinhaus%E2%80%93Johnson%E2%80%93Trotter_algorithm but I'm seeing words like "Recursive" in the description
03:10:24 <jle`> you can implement imperative algorithms just fine in haskell
03:10:36 <jle`> haskell is probably the best imperative languages i know
03:10:47 <jle`> s/languages/language
03:14:09 <jmorris> how can i use mod or div on a new datatype
03:14:37 <osfabibisi> jle`: I've heard that said a few times, but haven't actually played with writing imperative stylee in Haskell... maybe when I have some time over Christmas ;-)
03:15:00 <osfabibisi> problem is it seems so much more fun and interesting to bend my brain with FP...
03:15:28 <jmorris> http://pastebin.com/LT3wGNVA
03:16:06 <bollu> so how do I use ST exactly?
03:16:12 <bollu> I've screwed with it before
03:16:19 <bollu> but I don't really understand the performace implications
03:18:02 <jle`> bollu: you can write a ST action on vectors w/ the Data.Vector.Mutable api
03:18:06 * hackagebot superbuffer 0.1.0.0 - Efficiently build a bytestring from smaller chunks  https://hackage.haskell.org/package/superbuffer-0.1.0.0 (AlexanderThiemann)
03:18:14 <bollu> jle`: ooh, neat
03:18:19 <bollu> jle`: lemme check it out, thanks!
03:18:22 <jle`> it's not particularly complicated, i think, esp if you're used to imperative programming
03:18:27 <jle`> in imperative languages
03:18:36 <bollu> right, right
03:18:38 <jle`> like 'read'
03:18:48 <bollu> yeah, came from c/c++ :)
03:18:51 <jle`> read :: (your reference to a mutable vector) -> (the index you want, an Int) -> m a
03:18:59 <bollu> what context of "m"?
03:19:02 <jle`> it's an action in ST that returns an 'a'
03:19:04 <jle`> it's polymorphic
03:19:09 <jle`> over all things that can do mutable stuff
03:19:11 <jle`> IO is a popular one
03:19:14 <jle`> ST is another one
03:19:38 <jle`> but the important thing is that it's a monad so you can chain it using do notation and use Control.Monad combinators etc. :)
03:19:55 <bollu> neat :)
03:19:58 <bollu> lemme give this a shot
03:20:03 <jle`> the easiest way to directly apply this to a normal vector is with 'modify'
03:20:06 <jle`> http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector.html#g:18
03:20:19 <jle`> modify :: (forall s. MVector s a -> ST s ()) -> (Vector a -> Vector a)
03:20:34 <jle`> so you give it a `MVector s a -> ST s ()` function
03:20:47 <jle`> and it applies it in-place (if possible) to the vector
03:20:53 <jle`> it just runs the action described
03:21:13 <jle`> 'MVector s a' is a reference to a mutable vector here ... kind of like an array pointer in C
03:21:49 <jle`> so an `MVector s a -> ST s ()` means a function that takes a reference to a mutable vector of a's, and an `ST s` action that mutates it and returns ()
03:22:12 <jle`> `ST s ()` is kind of like `IO ()` in that we don't care about the result of the action, just its effects
03:22:45 <jle`> so yeah, just write your algorithm as one big 'MVector s a -> ST s ()` (kind of like a void foo(int[] a)), and then "run" it with 'modify'
03:24:44 <jle`> if you are using 'ST s' specifically as your context, in the Data.Vector.Mutable module, imagine things like 'MVector (PrimState m) a -> m ()' to be 'MVector s a -> ST s ()'
03:25:05 <jle`> PrimState is just a type family to let you write the same algorithm and be able to use it in IO too i guess
03:25:29 <jle`> idk kind of needlessly polymorphic to me
03:29:34 <bollu> hmm
03:29:39 <bollu> I see
03:29:42 <bollu> lemme do this
03:40:15 <Unhammer> how should I pass -dynamic to stack build?
03:40:37 <Unhammer> when I  stack build -v --ghc-options='-dynamic', it only uses -dynamic on configure, not build
03:41:56 <osfabibisi> add it to your .cabal file under the ghc-options key
03:42:57 <Unhammer> osfabibisi,  have done that; running with -v, I get 
03:43:00 <Unhammer> …/.stack/setup-exe-cache/x86_64-linux/setup-Simple-Cabal-1.18.1.5-ghc-7.8.4 --builddir=.stack-work/dist/x86_64-linux/Cabal-1.18.1.5 build lib:mylib exe:myexe --ghc-options " -ddump-hi -ddump-to-file" 
03:43:02 <Unhammer> though
03:43:47 <Unhammer> (Does -dynamic only make sense in the cabal configure step, not the build step?)
03:47:50 <osfabibisi> not sure of details, sorry.  Does it make any difference to the filesize of the resulting executable?
03:52:08 <Unhammer> aha, yeah it's the same size, and /usr/bin/file says they're both dynamically linked, so guess the configure step is where it matters
03:57:31 <Unhammer> actually /usr/bin/file says dynamically linked no matter what, but executable size changes
03:58:08 <Unhammer> (and, what I care about, build time is a bit faster …)
04:12:29 <yushyin> Unhammer: non haskell libs (c libs) are linked dynamically by default that’s why file says both are dynamically linked.
04:22:04 <Unhammer> mm, makes sense
04:24:09 <yushyin> you can make sure with the cli tool ldd
04:25:39 <Unhammer> cool!
04:34:52 <hvr> osfabibisi: actually cabal should complain if you place -dynamic into ghc-options in .cabal
04:35:14 <hvr> osfabibisi: as that's interfering with cabal's logic setting such flags
04:35:34 <osfabibisi> hvr: interesting.  Though the original question was about stack -- where it does seem to work
04:35:40 <hvr> osfabibisi: still wrong
04:35:42 <osfabibisi> e.g. not using cabal as such, just files in *.cabal format
04:36:22 <merijn> osfabibisi: Note the distinction between cabal (the library/interface) and cabal-install (the cabal executable)
04:36:49 <merijn> stack still just uses cabal, afaik?
04:37:30 <hvr> the sanity checks are implemetned in Cabal-the-lib
04:37:35 <osfabibisi> not sure.  in any case, it does seem to work with e.g. `stack build`
04:37:49 <osfabibisi> what would be the preferred way of setting -dynamic there then?
04:37:50 <hvr> which e.g. check if place -O into ghc-options
04:38:31 <hvr> osfabibisi: -dynamic is something you tell stack or cabal flags such as     --enable-executable-dynamic      Enable Executable dynamic linking
04:38:54 <hvr> and cabal/stack then should make sure that all dependencies have been built dynamically
04:40:06 <hvr> osfabibisi: IOW, either via CLI flags, or via your project configuration (which is either stack.yaml for stack, or cabal.project for cabal)
04:40:27 <hvr> but not in .cabal files, even if it appears to work, it's still wrong
04:41:17 <hvr> if stack doesn't support this, you should file bug
04:41:22 <hvr> +a 
04:49:56 <Squarism> hslogger or logger?
05:04:12 <wagnerf> hi, i'm writing a small benchmark and because of lazyness I don't measure anything
05:04:39 <wagnerf> i found on google about band patterns but i'm not sure how to use them
05:05:25 <wagnerf> is adding a ! before the final variable enough ? it does not seem to do anything for me
05:05:36 <AndreasK> wagnerf: That only evaluates to whnf
05:05:41 <Tuplanolla> You need to depend on the contents somehow, wagnerf.
05:05:48 <AndreasK> wagnerf: Maybe deepseq works: https://hackage.haskell.org/package/deepseq
05:05:55 <Tuplanolla> If you have a list, you can use `length` for example.
05:06:18 <wagnerf> ho yes, it is a list
05:06:23 <Tuplanolla> However that may still leave the elements unevaluated.
05:06:34 <wagnerf> ok that was my next question
05:06:44 <Tuplanolla> > length [[1 ..], [2 ..], [3 ..]]
05:06:47 <lambdabot>  3
05:07:12 <wagnerf> AndreasK: what is whnf ?
05:07:21 <wagnerf> was is exactly the "!" doing ?
05:07:44 <AndreasK> wagnerf: It only evaluates until the outmost layer of the structure is knowm
05:07:48 <AndreasK> *known
05:08:43 <wagnerf> hum
05:08:59 <AndreasK> There is a great writeup somehere let me look
05:09:23 <AndreasK> wagnerf: https://en.wikibooks.org/wiki/Haskell/Laziness#Thunks_and_Weak_head_normal_form
05:09:57 <wagnerf> AndreasK: thanks 
05:10:41 <wagnerf> and effectively deepseq might do the trick
05:10:49 <wagnerf> ok thanks a lot
05:11:18 <moino> is there a shorthand for the following pattern?: { predPass :: (a -> a -> Bool) -> a -> a -> a; predPass = if f x y then x else y }
05:11:33 <hpc> wagnerf: not mentioned there is that you can use :print and :sprint to inspect partially evaluated terms
05:11:59 <moino> forgot the bindings in the function definition: f x y
05:12:31 <hpc> wagnerf: it's got some quirks, but its output for a partially evaluated (Just someExpression) would be "Just _"
05:12:35 <AndreasK> wagnerf: You could also use criterion for benchmarking if you want something more intricate. I think it includes a way to evaluate the complete structure
05:14:46 <sphinxo> How can I best translate this kind of thing into functional style? http://lpaste.net/4744706902250749952
05:14:50 <sphinxo> reduce?
05:15:54 <merijn> sphinxo: That would depend on what it does?
05:16:16 <hpc> as written the loop looks like it would directly translate to something with foldl'
05:16:34 <sphinxo> it's the g(x) part of Zitzler–Deb–Thiele's function N. 1 https://en.wikipedia.org/wiki/Test_functions_for_optimization
05:16:52 <hpc> or some combination of sum and map
05:17:08 <merijn> hpc: Possibly, but I don't understand the original code, looks like Ruby or something?
05:17:11 <hpc> sum and map would probably be closer to the intent of what you're writing
05:17:48 <sphinxo> merijn: rust but pseudo code
05:17:59 <sphinxo> ( ish )
05:18:08 <hpc> it does a wonky sum of the elements of a list named parameters
05:18:16 <hpc> and stores it in g
05:19:52 <hpc> how you would choose to translate it does depend on the intent of that snippet
05:20:41 <sphinxo> see the formula on the wikipedia page I linked to hpc 
05:21:32 <hpc> oh, cool
05:21:44 <AndreasK> moino: You could directly use "if f x y then x else y" I guess, otherwise I don't see one (but not an authority ... :D)
05:22:16 <lyxia> @pl \f x y -> if f x y then x else y
05:22:16 <lambdabot> flip flip id . (ap .) . (flip . (if' .) =<<)
05:22:21 <lyxia> nope.
05:22:36 <ertes> helo
05:22:43 <hpc> sphinxo: maybe for that i would use a fold over a Vector of some sort, maybe
05:24:02 <hpc> mostly because it looks like Vector fits the other parts of the problem reasonably well
05:24:09 <sphinxo>  1 + 9 * sum(tail xs) / (length xs  - 1)
05:24:16 <sphinxo> ehh
05:25:24 <sphinxo> is that correct?, my maths is pretty rusty
05:26:02 <sphinxo> btw (length xs) == 29
05:26:08 <sphinxo> btw (length xs) == 30
05:26:09 <sphinxo> sorry
05:33:11 * hackagebot mwc-random 0.13.5.0 - Fast, high quality pseudo random number generation  https://hackage.haskell.org/package/mwc-random-0.13.5.0 (AlexeyKhudyakov)
05:43:11 * hackagebot hsoz 0.0.0.3 - Iron, Hawk, Oz: Web auth protocols  https://hackage.haskell.org/package/hsoz-0.0.0.3 (rvl)
05:44:08 <sphinxo> what should I be using for fixed size lists?
05:44:23 <sphinxo> array right? and not vector
05:44:44 <Tuplanolla> Not enough information.
05:45:54 <sphinxo> using fixed size of arrays of len 30, will be doing guassian mutation on them
05:46:12 <ertes> sphinxo: is "fixed size" a guarantee that you want, or just a feature?
05:46:20 <Tuplanolla> How about `MVector` with `ST`?
05:46:36 <Tuplanolla> :t Data.Vector.Unboxed.create
05:46:39 <lambdabot> Data.Vector.Unboxed.Base.Unbox a => (forall s. ST s (Data.Vector.Unboxed.Base.MVector s a)) -> Data.Vector.Unboxed.Base.Vector a
05:47:13 <sphinxo> ertes: by guarantee do you mean having the array size in type sigs? ideally
05:47:41 <ertes> sphinxo: that complicates things…  if it's just a feature, then i second Tuplanolla's suggestion
05:47:50 <sphinxo> ok cool
05:48:02 <ertes> if you need the static guarantee, you will most likely have to do some engineering work
05:52:05 <muzzle> hi
05:52:35 <muzzle> what causes this error message when using stack?  Invalid package ID: "array-0.5.1.1 base-4.9.0.0 binary-0.8.3.0 bytestring-0.10.8.1" 
05:54:06 <muzzle> I just wanted to use resolver 7.10 instead of 6.22
05:54:07 <muzzle> ?
05:54:17 <muzzle> I tried to 'stack upgrade' to no effect
05:54:29 <muzzle> and I'm really running out of ideas
05:54:40 <muzzle> stack upgrade --git fixed the problem on an other machine
05:54:44 <muzzle> but no luck so far
05:55:56 <srhb> muzzle: Can you paste the stack file? It looks like it's interpreting those packages as one package.
05:56:00 <srhb> (Which obviously fails)
05:56:06 <srhb> paste it on lpaste.net or similar.
05:56:10 <muzzle> srhb you mean stack.yaml?
05:56:14 <srhb> Yes.
05:57:01 <muzzle> http://lpaste.net/348595
05:57:47 <srhb> muzzle: Is not indenting the list under packages allowed?
05:57:54 <muzzle> srhb possibly related github issue: https://github.com/commercialhaskell/intero/issues/252
05:58:31 <muzzle> srhb it works with 6.10
05:58:35 <srhb> muzzle: Looks likely, yeah.
05:59:46 <buttbutt1r> Do you guys have recommendations for a plotting in Haskell? I've seen Chart, EasyPlot, etc. Still seems...clunky. Maybe it's better to just export the data and plot with something else?
06:00:29 <hodapp> buttbutt1r: just how complex are your plotting needs?
06:00:55 <buttbutt1r> hodapp: Not super complex. Basically plotting some points, labeling them, etc.
06:01:22 <kuribas> Are there any experts on rewrite rules here?
06:02:14 <hodapp> buttbutt1r: the gnuplot bindings are decent enough
06:02:50 <buttbutt1r> Graphics.Gnuplot.Simple?
06:03:31 <hodapp> yeah
06:04:52 <buttbutt1r> Okay, I'll try that. Thanks :)
06:05:04 <hodapp> I used Graphics.Rendering.Chart.Easy too and IIRC found it a bit too simplistic
06:05:34 <hodapp> however, it's worth a look too perhaps if gnuplot is overkill
06:05:52 <buttbutt1r> I'll look at both. Thanks. :)
06:07:06 <Tuplanolla> Personally I just export data and deal with the Gnuplot suffering, buttbutt1r.
06:07:24 <hodapp> the bindings do streamline that nicely :)
06:07:37 <muzzle> srhb will using stack --resolver lts-7.10 upgrade --git solve the problem?
06:08:12 * hackagebot patat 0.4.2.0 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.4.2.0 (JasperVanDerJeugt)
06:11:41 <ertes> buttbutt1r: the diagrams library can plot, too, if you want a pure haskell solution, although you probably need to do some extra work, because all it does is diagram composition
06:11:57 <ertes> @package diagrams
06:11:57 <lambdabot> http://hackage.haskell.org/package/diagrams
06:12:19 <ertes> … or you could just time out, i guess
06:15:34 <muzzle> Can ghc-8 be reliably used with stack?
06:16:46 <kuribas> ertes: there was a new diagrams-plotting library
06:17:11 <byorgey> http://hackage.haskell.org/package/plots
06:17:30 <byorgey> I'm told it's supposed to still be in "stealth mode", i.e. may still be rough around the edges
06:17:47 <byorgey> muzzle: yes
06:33:40 <linduxed> ooooh man
06:33:42 <linduxed> it's up!
06:33:44 <linduxed> http://adventofcode.com/
06:38:14 * hackagebot hakyll 4.9.2.0 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.9.2.0 (JasperVanDerJeugt)
06:46:41 <jchia_> lens question: I have x = [(1, "a", '1'), (1, "b", '2'), (2, "c", '1')] :: [(Int, String, Char)] and f :: [String] -> [String] that fmaps an input [String] to an output [String] of the same length, and I want to apply f on the traverse . _2 of x, so that given f ["a", "b", "c"] == [sa, sb, sb], I compute from x the value [(1, sa, '1'), (1, sb, '2'), (2, sc, '1')]. How do I express this succintly with lens?
06:47:47 <jchia_> In summary, map from [(1, "a", '1'), (1, "b", '2'), (2, "c", '1')] to [(1, sa, '1'), (1, sb, '2'), (2, sc, '1')] using lens and the function f.
06:48:36 <lyxia> over (traverse . _2) f
06:48:55 <lyxia> oh no...
06:48:58 <jchia_> f takes [String], not String
06:49:06 <jchia_> I'm doing a batch lookup
06:49:18 <lyxia> you want the result of f to be zipped with it I see.
06:49:36 <jchia_> i know i can do it with zipWith, but wondering if i can express it succintly with lense
06:49:48 <jchia_> lens
06:51:08 <ertes> jchia_: you can, but you would have to write that lens on your own…  and it's a bit problematic, because it might lose data (should still be lawful though)
06:51:43 <lyxia> looks like partsOf
06:52:28 <ertes> jchia_: i've done something similar in the past (lens into the part of a lazy Text that matches a character predicate): https://github.com/esoeylemez/codebreakers/blob/master/code/Codebreakers/Text.hs#L84
06:52:47 <ertes> not sure if there is a combinator that allows you to write something like that more concisely
06:55:38 <lyxia> over (partsOf (traverse . _2)) f
07:02:38 <jchia_> lyxia: Great, i tried it on a simple case and it works. How do you figure out how to make a lens expression? Is it mostly about getting the types to match up?
07:03:15 * hackagebot math-functions 0.2.1.0 - Special functions and Chebyshev polynomials  https://hackage.haskell.org/package/math-functions-0.2.1.0 (AlexeyKhudyakov)
07:08:15 * hackagebot yeshql 1.0.0.0 - YesQL-style SQL database abstraction  https://hackage.haskell.org/package/yeshql-1.0.0.0 (TobiasDammers)
07:08:50 <ertes> jchia_: it's about understanding the basic idea
07:08:53 <ertes> of lenses
07:09:21 <lyxia> hmm... ertes++
07:09:44 <ertes> jchia_: example:  can you write a regular function that lets you change the first component of a tuple?
07:10:16 <ertes> jchia_: not separate functions to extract and reinsert that component, but more a map-like function
07:11:31 <ertes> lyxia: i wonder if i'm positive now =)
07:11:33 <ertes> @karma
07:11:33 <lambdabot> You have a karma of 0
07:11:44 <ertes> ah…  used to be -10 or something =)
07:12:07 <ggVGc> @karma
07:12:08 <lambdabot> You have a karma of 0
07:12:20 <ggVGc> ggVGc--
07:12:21 <ggVGc> @karma
07:12:21 <lambdabot> You have a karma of 0
07:12:24 <ggVGc> :(
07:12:34 <ggVGc> EvanR++
07:12:41 <lyxia> ggVGc--
07:12:43 <ggVGc> ++EvanR 
07:12:47 <ggVGc> @karma
07:12:47 <lambdabot> You have a karma of -1
07:12:53 <ggVGc> mean
07:13:10 <lyxia> ggVGc++
07:13:46 <lyxia> okay guys, go back to figuring out profunctors.
07:13:54 <ggVGc> today I was dreaming about monadic computations and if I could use Applicative of Monad to improve some stuff I have
07:14:08 <ggVGc> It didn't pan out
07:14:17 <ggVGc> and also, it was half dilerium
07:15:23 <ertes> i usually dream about topological spaces…  i watch as homeomorphisms do their thing…  at least that's my interpretation of the warped things i see
07:15:59 <ggVGc> is that one of your pickup lines? "Hey, what's up? I usually dream about topological spaces, how about you?"
07:16:45 <jchia_> ertes: This is simple enough for me to understand:
07:16:45 <jchia_> change :: (a -> c) -> (a, b) -> (c, b)
07:16:45 <jchia_> change f x = x & _1 %~ f
07:16:47 <ertes> that would be an interesting social experiment =)
07:16:49 <ggVGc> ertes: do you have a math background?
07:17:29 <ertes> jchia_: great…  now just wrap the results by a functor:  (Functor f) => (a -> f c) -> (a, b) -> f (c, b)
07:17:36 <ertes> jchia_: and voila, you have a lens =)
07:17:52 <ertes> ggVGc: nope (not formal anyway)
07:18:41 <ertes> ggVGc: i'm mostly a dilettante =)
07:18:53 <ggVGc> ertes: this summer I ended up next to the main dance floor at a trance festival, talking to a math PhD about math proofs, classification of finite simple groups(which related to her field of math), and pure functional programming, while both fairly high on Ketamine
07:19:03 <ggVGc> so, yeah, that pickup line might work some day
07:23:15 * hackagebot yeshql 1.0.0.1 - YesQL-style SQL database abstraction  https://hackage.haskell.org/package/yeshql-1.0.0.1 (TobiasDammers)
07:23:17 * hackagebot super-user-spark 0.3.1.0 - Configure your dotfile deployment with a DSL.  https://hackage.haskell.org/package/super-user-spark-0.3.1.0 (Norfair)
07:26:10 <HelgeS> Where can I paste a few lines for you to comment on?
07:27:19 <lyxia> lpaste.net
07:31:16 <HelgeS> Newbie at both QuickCheck and parametrized data types; I have problems:
07:31:18 <HelgeS> http://lpaste.net/348619
07:32:29 <HelgeS> I have a more complex property involving the type "data Turn = R Int | L Int", but first I want the simplest possible to work.
07:32:46 <lyxia> Okay, to test a property Turn -> Bool, quickCheck needs a generator of Turn
07:32:59 <lyxia> you can provide it by making Turn an instance of Arbitrary
07:34:11 <lyxia> instance Arbitrary Turn where arbitrary = oneof [R <$> arbitrary, L <$> arbitrary]
07:35:01 <HelgeS> lyxia: Excellent! it works right away. Now I have to understand also…
07:36:08 <lyxia> arbitrary :: Arbitrary a => Gen a, is a generator of values for any type a which is an instance of Arbitrary.
07:36:17 <lyxia> In particular, Int is an instance.
07:36:36 <jchia_> What can I do if I have a record type for which I want to generically make an instance of Data.CSV.FromNamedRecord (cassava) and at the same time use Control.Lens (lens) to access its fields? With makeLenses or makeClassy, the field names need to start with underscore, but I want Data.CSV to use non-underscore-prefixed column names.
07:37:23 <lyxia> HelgeS: so arbitrary :: Gen Int generates Ints.  R <$> arbitrary generates random R turns, L <$> arbitrary generates random L turns. oneof combines random generators by picking one at random.
07:38:33 <lyxia> jchia_: makeLensesFor allow you to specify your own lens names
07:47:33 <jchia_> lyxia: I have multiple records with common field names. I'm using lens partly to avoid "Ambiguous occurence 'fieldname'" errors and was actually thinking of using makeFields, not makeClassy.
07:47:50 <jchia_> "multiple record types"
07:48:08 <jchia_> In this case, what do I do?
07:48:36 <ertes> jchia_: i like to write the lenses myself, so i can document them (also TH is awkward)
07:49:07 <jchia_> ertes: Do you use lens to mitigate the "record problem"?
07:49:55 <jchia_> writing lens for all the fields of all the records for mitigating the "record problem" seems like a lot of boilerplate.
07:51:09 <ertes> jchia_: rarely
07:51:23 <ertes> i use traversals most of the time
07:51:35 <c_wraith> jchia_: I never had a record problem in haskell.
07:51:46 <ertes> jchia_: what c_wraith said
07:52:14 <lyxia> jchia_: what's the problem with makeFields though
07:52:18 <ertes> lenses can be nice for things that aren't necessarily *fields*
07:52:44 <ertes> but traversals solve a different problem, and that is an actual problem
07:54:12 <HelgeS> lyxia: I couldn't make Direction an instance of Arbitrary. hmm. http://lpaste.net/348626
07:54:45 <jchia_> lyxia: makeFields requires field names to start with '_' but if I derive FromNamedRecord generically, I'll end up with CSV column names that start with '_' also.
07:55:33 <lyxia> HelgeS: oneof [return North, return East, ...]    or    elements [North, East, ...]
07:55:38 <jchia_> c_wraith: How do you avoid the record problem? Don't you sometimes need different record types that have fields that mean the same thing?
07:55:53 <lyxia> HelgeS: look at the types, oneof :: [Gen a] -> Gen a,  elements :: [a] -> Gen a
07:55:55 <jchia_> so you naturally name the fields the same way?
07:56:06 <ertes> jchia_: -XDuplicateRecordFields
07:56:23 <ertes> or use the type name as a prefix, if you don't want to use new extensions
07:56:50 <c_wraith> Or just put the records in different modules and use qualified imports.
07:57:03 <ggVGc> so, when using makeClasst, do we get essentially a type class for each field name? Does that make it possible to get essentially structural typing?
07:57:08 <ggVGc> I am guessing not
07:57:08 <lyxia> jchia_: you can mess with the configuration of the TH lens generators
07:57:21 <ggVGc> I haven't really understood the "HasX" classes that gets generated
07:57:44 <ggVGc> makeClassy*
07:58:11 <lyxia> jchia_: note the comment that says about makeFields that it is equivalent to makeLensesWith defaultFieldRules, you can modify the rules
07:58:21 <lyxia> there are lenses for the LensRules.
07:58:36 * lyxia finds that so meta.
07:58:48 <ggVGc> Lens is pretty meta
07:59:11 <ggVGc> although, I was doing lenses to lenses a while back, and it wasn't so great
07:59:22 <jchia_> thanks, all
08:00:18 <c_wraith> jchia_: None of the ways of dealing with a desire to have multiple records with same-named fields are exactly great, but they're reasonable compromises given the constraints of working within the haskell type system.  
08:02:08 <ggVGc> one day haskell might have actual records
08:02:11 <ggVGc> that'll be a good day
08:02:54 <ggVGc> is there any way currently to get structural subtyping in haskell?
08:03:10 <lyxia> Is that the day when noone will be left to use Haskell and they will just rename OCaml to it
08:03:15 <EvanR> subtyping, uhg
08:03:33 <EvanR> we can do better than that with records
08:04:26 <ertes> in what way doesn't haskell have records?
08:04:51 <EvanR> something like row polymorphism has been implement in haskell inspired systems
08:04:57 <ggVGc> EvanR: maybe I used the wrong term. What I mean is essentially what purescript has, where I can make a record Foo{x::Int, y::Int} and another Bar{x::Int} and say printX :: {x::Int} -> String, and have it work for both Foo and Bar
08:05:03 <EvanR> implemented. 
08:05:06 <ggVGc> is this a bad thing to have in your opinion?
08:05:18 <ggVGc> is that called row polymorphism?
08:05:26 <EvanR> not as written
08:05:28 <ggVGc> I thought structural subtyping was the same thing
08:05:34 <ertes> ggVGc: you want extensible records?
08:05:54 <ertes> @package vinyl
08:05:54 <lambdabot> http://hackage.haskell.org/package/vinyl
08:05:56 <EvanR> you just want real record types
08:06:05 <ggVGc> ertes: I guess so. that's what purescript has anyway. But I think this specific thing can be had in different ways, and extensible records is just one of them
08:06:07 <EvanR> subtyping entails a lot of other insanity
08:06:37 <ertes> i don't know how it works in purescript, but you can do that without subtyping – as vinyl does
08:06:44 <ggVGc> cool
08:06:51 <EvanR> the main point is that a record type is first a collection of fields, not a name
08:07:13 <ggVGc> I've looked a bit at vinyl before, but haven't used it yet
08:07:37 <merijn> ggVGc: No, row polymorphism is rather different, from structural subtyping, but has advantages
08:07:38 <EvanR> the second point is you want to talk polymorphically about record types in different ways, and row polymorphism is one of them
08:07:51 <ggVGc> some people argue though that this kind of thing breaks type safety, since one x::Int in one type might not be the same thing as another x::Int
08:07:54 <ggVGc> and hence shouldn't type check
08:08:06 <merijn> ggVGc: Mostly in that it's easier to talk about the soundness of your type system, since subtyping generally always breaks that in difficult and obscure ways
08:08:09 <EvanR> the way you wrote it is not good i think
08:08:24 <tdammers> "jesus is not a filesystem, even though both save"
08:08:38 <ertes> i really never had a desire to have record types in that sense…  i found vinyl to be nice implementation of them, and ended up never using it
08:09:01 <ggVGc> ertes: maybe ADTs actually fill the use cases?
08:09:07 <ertes> in general when i found that i needed information in multiple record types, i just factored it out
08:09:21 <ertes> because ultimately record types are just product types, and you can multiply them
08:09:38 <EvanR> well sometimes the number of record types goes way up because you have a lot of different expectations in the program
08:09:58 <EvanR> liek earlier this week codedmarts web programming problem
08:10:00 <ertes> i don't mind having a lot of record types
08:10:09 <EvanR> me neither
08:10:32 <EvanR> but haskell doesnt make it easy because you have to come up with names and unique fields
08:10:43 <ertes> huh?  that's solved by factoring
08:10:53 <EvanR> let me get to the point
08:10:59 <ertes> ok =)
08:11:38 <EvanR> now once you have a large number of similar record types, literally factoring anything with the same name and field leads to a even huger number of single-field record types, which makes no sense!
08:11:42 <EvanR> that kind of factoring doesnt help
08:12:02 <EvanR> its obvious haskell being subpar
08:12:42 <ertes> that's right…  i would like haskell to have anonymous record types, but it doesn't, so factoring is my workaround, and so far i haven't hit one of the cases when it gets unwieldy
08:12:58 <ertes> actually in such a case i might use vinyl
08:13:31 <mmaruseacph2> if I ever hit that case I find solutions using typeclasses and functions instead of record fields, so far I always managed to refactor properly
08:14:04 <merijn> All of that doesn't diminish the fact that rowtype polymorphism would be amazeballs
08:14:44 <ertes> we have poor man's version of that now with -XDuplicateRecordFields =)
08:15:06 <merijn> ertes: No, that's not even remotely anything like rowtype polymorphism
08:15:22 <ertes> i know
08:16:09 <EvanR> one way is to encode your strategy into a template haskell and generate whole record types and boring support that way
08:16:35 <EvanR> which would work and also id call it "failed"
08:16:37 <ertes> you know what would be even more amazeballs?  linear types!  because that would actually change my way of solving problems substantially =)
08:16:50 <ertes> or even just uniqueness types
08:17:15 <ggVGc> I think I've wanted linear types sometimes, but only because I've asked about things and gotten the answer that linear types would solve it
08:17:16 <EvanR> i asked about uniqueness types in idris, and apparently they are on their way out
08:17:33 <ertes> EvanR: huh?  i thought idris already had them
08:17:34 <merijn> ertes: Linear types + rowtype polymorphism!
08:17:50 <EvanR> ertes: yes, no one likes it and its going to be removed eventually
08:17:53 <merijn> EvanR: linear types are a generalisation of uniqueness types which is far more useful
08:17:57 <ertes> ah, ok
08:18:06 <merijn> EvanR: Are they going to remove linear types entirely?
08:18:17 <ertes> merijn: i may be underedcuated on what rowtype polymorphism is
08:18:17 <EvanR> they want linear dependent types
08:18:30 <merijn> ertes: Right, you know structural subtyping?
08:18:35 <ertes> merijn: yeah
08:18:51 <merijn> ertes: And the issues with it wrt covariant and contravariant positions?
08:18:58 <ertes> merijn: yeah
08:19:24 <merijn> ertes: i.e. "{ a : int, b : char} -> { a : int, b : char }" can take something with an additional field 'c', but you lose that in the return value
08:19:41 <merijn> ertes: Rowtype polymorphism basically says "let's not do subtyping, it's a bad idea, mmmmk?"
08:20:43 <merijn> ertes: So you get "{ a : int, b : char | rho } -> { a : int | rho }" here rho is a "rowtype" which basically stands for "any set of fields disjunct from 'a' and 'b'"
08:21:04 <merijn> ertes: So, you basically make functions polymorphic in the extra fields accepted
08:21:21 <ertes> merijn: so i wasn't undereducated…  rowtype polymorphism is "what vinyl does" =)
08:21:23 <merijn> ertes: Now you don't have any subtyping any more at all, you just need to do unification on rho
08:21:23 <EvanR> and its obvious in the signature that the other fields are preserved
08:21:26 <ertes> except built into the type system?
08:21:35 <merijn> ertes: Maybe? I don't know vinyl
08:21:42 <ertes> merijn: yeah, vinyl does exactly that
08:22:08 <merijn> ertes: But potentially more efficient, since vinyl (last I checked) was effectively an HList/nested tuple
08:22:27 <ertes> but it uses type-level set arithmetic to do it…  and that, too, yes
08:22:51 <EvanR> you would need set junk if you used extensible records with scoped labels
08:22:55 <EvanR> wouldNT*
08:22:58 <ertes> merijn: so yeah…  i would love to have that, but given a choice between that and linear types, i'd honestly pick linear types
08:23:21 <merijn> ertes: Well, it depends. Independently, yes. But dependent rowtype polymorphism is amazeballs
08:23:22 <EvanR> uh... linear types comes up nearly as much as record types?
08:23:53 <merijn> Honestly, I just want both :p
08:23:54 <EvanR> the number 1 source of crashing in web programming, records where you forgot what the fields were called?
08:24:00 <ertes> merijn: i can see why =)
08:24:01 <EvanR> or contained
08:24:07 <merijn> EvanR: Look at Ur/Web? ;)
08:24:26 <merijn> EvanR: dependently typed, rowtype polymorphic language for webdev :p
08:24:45 <EvanR> it was revealed yesterday that its not really dependently typed
08:24:48 <ertes> i'd want in decreasing order of preference:  dependent types, linear types, rowtype polymorphism (a.k.a. records done right)
08:24:57 <merijn> EvanR: Build in transactional monad for database access, embedded/strongly typed DSL for html, sql and JS :)
08:25:10 <EvanR> ertes: well with full dependent types, you could implement record types 
08:25:14 <merijn> EvanR: I know, it only allows limited forms of dependent types
08:25:17 <EvanR> with more extensive polymorphism
08:25:29 <merijn> EvanR: But "a limited but useful subset of dependent types" is too long to type :p
08:25:32 <EvanR> merijn: and no real docs
08:25:40 <ertes> EvanR: sure, but it would have the same caveats as vinyl, unless you use some really clever low-level tricks
08:25:45 <merijn> EvanR: True, but the exaples are nice to play with
08:25:58 <ertes> (those tricks are probably possible in today's haskell though)
08:26:05 <EvanR> tricks ?
08:26:08 <EvanR> low level?
08:26:25 <ertes> EvanR: like: use a boxed array instead of nested tuples
08:26:40 <EvanR> that is an issue with compiled representations
08:26:44 <EvanR> not the language
08:26:58 <EvanR> agda lets you choose how to compile stuff
08:27:01 <EvanR> idris doesnt...
08:27:52 <EvanR> we dont want to care about "what it really is" just the interface! ;)
08:28:12 <ertes> if we generalise from what i'd like the type system to have to generally what i'd like to have:  my number one feature request would be agda's module system =)
08:28:18 <ertes> but that's not going to happen any time soon
08:28:24 <EvanR> records can be and have been implemented in so many ways
08:28:45 <EvanR> from fixed field arrays, to json strings, to trees etc
08:29:09 <EvanR> yeah modules
08:29:15 <Profpatsch> How do I statically link in the libraries the Haskell runtime needs?
08:29:18 <EvanR> which in agda are just records
08:29:20 <Profpatsch> e.g. GMP
08:29:24 <Profpatsch> Or libc
08:29:55 <ertes> EvanR: not quite…  every record type implicitly also defines a module, but not every module is a record
08:29:56 <Profpatsch> Because the system where I want to execute the binary is too old
08:29:58 <Profpatsch> ./stallmanbot: /lib64/libc.so.6: version `GLIBC_2.15' not found (required by ./stallmanbot)
08:30:39 <EvanR> to be able to use records as modules, or as typeclass dictionaries, that is awesome
08:30:53 <Profpatsch> Is it possible to compile in libc statically?
08:31:58 <ertes> Profpatsch: most likely (i don't know how, but the GHC docs might tell you)…  however, if you have freedom in toolchain selection you could use nix and then just extract the closure (or even install nix on the target machine)
08:32:26 <Profpatsch> ertes: Fun, I’m using nix to generate the binaries.
08:32:45 <ertes> Profpatsch: in that case see:  nix-store -qR
08:32:48 <Profpatsch> ertes: Is it possible to install nix without /nix in root already?
08:33:08 <Profpatsch> Because I’d need a chroot or something, right?
08:33:11 <ertes> Profpatsch: it is, but i recommend not to do that, because then all the paths change, and you can no longer use the binary caches
08:33:19 <Profpatsch> I know.
08:33:40 <Profpatsch> But the executable links to /nix/store
08:33:44 <ertes> Profpatsch: is the target a linux?
08:33:49 <Profpatsch> aye
08:34:04 <ertes> Profpatsch: is it young enough that it supports mount namespaces?  (i think 3.18)
08:34:31 <Profpatsch> nope, 2.6.32
08:35:56 <ertes> hmm…  and i suppose you can't have /nix because you aren't root?
08:36:06 <Profpatsch> aye
08:36:22 <ertes> would the admin mind symlinking /nix to somewhere where you have access?
08:36:46 <Profpatsch> Yeah, I can’t touch anything outside of my home.
08:37:05 <ertes> static linking it is =)
08:37:09 <Profpatsch> heh
08:37:41 <ertes> or you bite the bullet and go with a non-standard path
08:37:49 <ertes> which means you will build everything yourself
08:37:57 <maerwald> isn't there a #nixos channel?
08:38:18 * hackagebot buffer-builder 0.2.4.4 - Library for efficiently building up buffers, one piece at a time  https://hackage.haskell.org/package/buffer-builder-0.2.4.4 (chadaustin)
08:39:54 <Profpatsch> They kind of mix from time to time. :)
08:40:04 <Profpatsch> No reason to be passive-aggressive3
08:40:07 <Profpatsch> <3
08:40:33 <ertes> maerwald hates nix =)
08:40:58 <ertes> which is the reason why they didn't mind us talking about linux without asking whether there is a #linux channel =P
08:41:28 <Profpatsch> Holy moley, cabal suddenly ahs a
08:41:31 <Profpatsch> has a manpage.
08:41:46 <Profpatsch> Not sure if upstream/cabal or upstream/nixpkgs fixed that.
08:41:46 <sm> whaaat!
08:41:55 <dcoutts> it's had one for some time
08:41:56 <EvanR> how about a #stack channel
08:42:14 <geekosaur> (but does it have a .chm for windows yet?)
08:42:14 <sm> cabal++
08:42:31 <EvanR> in other channels they quickly send people to related products dedicated channel
08:42:35 <ertes> how about an .apk for android?
08:42:47 <maerwald> ertes: that's false information about what I like or hate, please don't spread it
08:43:02 <dcoutts> geekosaur: we generate the man page via pandoc iirc, so should be able to generate other formats
08:43:03 <EvanR> maerwald hates false information
08:43:12 <ertes> maerwald: sorry
08:43:12 <maerwald> EvanR: correct!
08:43:43 <maerwald> ertes: offtopic note: I make a very sharp distinction of nixpkgs and nix the PM
08:44:09 <ertes> maerwald: that's a reasonable thing to do
08:46:33 <Profpatsch> maerwald: We were talking about nix the PM
08:46:47 <maerwald> Profpatsch: I know
08:47:32 <ertes> well, to some extent also nixpkgs, because that's where the haskell stuff comes from, unless you rolled your own
08:48:10 <Profpatsch> How would I give cabal configure -optl-pthread and -optl-static so that it forwards it to ghc?
08:48:44 <ertes> dcoutts: that reminds me of a question, which you might be able to answer:  is there a way to tell cabal/Setup repl not to be component-specific?  basically: "don't hide any packages that the package depends on, regardless of component"
08:48:51 <Profpatsch> I tried "--ghc-options -optl-static", but ld complains in that case
08:49:05 <ertes> dcoutts: trying to work around a shortcoming of haskell-mode
08:49:33 <Profpatsch>  cabal configure --ghc-options "-optl-static"
08:49:44 <Profpatsch> gives me errors like /nix/store/9kxhc2f3j5lcyh00zcrifvfly33n5m4r-binutils-2.27/bin/ld: cannot find -lz
08:49:46 <Profpatsch> /nix/store/9kxhc2f3j5lcyh00zcrifvfly33n5m4r-binutils-2.27/bin/ld: cannot find -lrt
08:50:56 <ertes> Profpatsch: you should ask that on nix-dev…  someone like peti (who isn't here) might be able to answer
08:51:59 <Profpatsch> ertes: I think dcoutts should be able to answer that as well. :)
08:52:28 <Profpatsch> It’s not a nixpkgs thing, peti just gives ./Setup configure what I put into configureFlags
08:52:39 <Profpatsch> So cabal has to forward it somehow.
08:53:34 <geekosaur> looks to me like it's just failing to find the static versions of those libraries
08:53:36 <dcoutts> ertes: no it cannot not be component specific, because the environment fundamentally is component specific
08:53:54 <dcoutts> ertes: I mean one could try and hack things to avoid passing -hide-all-packages but the result will be a mess
08:54:40 <ertes> dcoutts: then i'll just do the following:  use the existing "devel" flag to add those dependencies to the library component as well
08:54:41 <geekosaur> which would be up to nixpkgs to deal with (possibly painfully as librt would be part of glibc)
08:55:21 <ertes> or just go back to my earlier non-repl-based thing until haskell-mode is fixed
08:55:26 <dcoutts> ertes: ah, you mean take the union of all the deps that any component in the package uses, even though we are doing repl for one component
08:55:31 <dcoutts> ertes: ok that's less insane
08:55:39 <ertes> dcoutts: yeah, exactly
08:55:48 <ertes> dcoutts: haskell-mode just fails to tell repl which component
08:55:52 <dcoutts> since components do at least agree on the versions of deps they use
08:56:06 <dcoutts> ertes: but this would not avoid the problem of having to know which component to ask for. 
08:56:28 <dcoutts> ertes: since everything else is still different per-component: src dirs, cpp flags, etc etc
08:57:17 <dcoutts> so there's no guarantee that having started repl for one component that you can :load a file from another component
08:57:20 <ertes> dcoutts: hmm…  so far i haven't depended on an extra-modules module in an executable component, so maybe i'll hit that roadblock, too, then
08:57:42 <ertes> dcoutts: i suppose there is no way to change the component dynamically?
08:57:57 <dcoutts> ertes: unfortunately ghci does not make that easy
08:58:10 <dcoutts> even if you don't have to change the packages that are loaded
08:58:18 <ertes> hmm…  that's unfortunate
08:58:52 <dcoutts> ertes: you might look into it, it's not completely implausible. It'd involve changing the set of dynamic flags without restarting ghci
08:58:55 <dcoutts> using :set
08:59:01 <ertes> dcoutts: i think i'll go back to my pure GHCi solution for now…  there is a nix environment around both GHCi and repl, so as long as i make sure that it builds regularly, it should be fine
08:59:07 <dcoutts> and that'd need to be wrapped up in a way that was convenient
08:59:50 <dcoutts> ertes: note that cabal new-build is going to support a ghci env that covers the whole project, without any per-component src dirs / other flags etc
09:01:26 <ertes> dcoutts: do i need cabal-install for that?
09:01:56 <dcoutts> Profpatsch: sounds like it's working
09:02:14 <ertes> cabal doesn't seem to have a new-build command for me
09:02:20 <ertes> (the library)
09:02:28 <dcoutts> ertes: this is cabal-install
09:02:41 <dcoutts> Profpatsch: in the sense that it is passing those options to ghc. As for why that then does not work, well that's probably because you really do not have the static libs installed for zlib etc
09:03:21 <ertes> hmm…
09:05:16 <ertes> dcoutts: would it make sense as a cabal feature?  (for now i'll go back to plain GHCi)
09:05:41 <dcoutts> ertes: what exactly?
09:05:47 <ertes> dcoutts: new-build
09:06:01 <dcoutts> ertes: oh no, new-build is fundamentally a feature of cabal-install
09:06:12 <dcoutts> not of the Cabal lib
09:06:51 <ertes> ok…  then i don't have access to it anyway, although what i'm doing with GHCi seems to be very similar to new-build
09:06:58 <dcoutts> ertes: what is plausible is switching components in ghci without restarting
09:07:17 <ertes> yeah, that would be nice
09:07:27 <ertes> when that happens i can come back to cabal
09:07:40 <dcoutts> ertes: it may not happen unless you make it happen :-)
09:09:25 <ertes> dcoutts: at this point all i want is a working development environment…  i don't think i want to become a GHC dev over this =)
09:20:13 <maerwald> ertes: you don't like idiomatic GHC code? =D
09:21:24 <ertes> maerwald: uh…  huh?
09:21:40 <ertes> to be honest i have no idea what the GHC code looks like =)
09:21:53 <geekosaur> spj prefers braces...
09:23:05 <ertes> oh
09:23:33 <ertes> that's…  interesting
09:23:50 <mutantmell> Nothing wrong with curly braces :)
09:25:53 <c_wraith> the simons joked that they used to look for reasons to modify code that the other had written to "fix" the {;} issue to their preferred style in code each other wrote. 
09:27:43 <cobreadmonster> Hello.
09:28:20 <Profpatsch> Hello.
09:28:36 <mutantmell> Hello!
09:28:39 <Profpatsch> dcoutts: You are right, I didn’t think about that.
09:29:11 <sm> c_wraith: heh, well anything driving fixes is good right
09:29:46 <c_wraith> sure. :) 
09:29:50 <junioraw> >
09:31:05 <sm> a simple concurrency question. I forkIO a child thread that prints output every second. When I run the program in GHCI, I see the output. When I quit the main program and return to the GHCI prompt, I expect the child thread to also be killed, but it keep printing output. What's happening here ?
09:32:18 <geekosaur> sm, when you :main something from ghci, it's ghci that owns the main thread and therefore all subthreads
09:32:42 <geekosaur> so as long as ghci itself is running, so will threads unless you actively manage them with e.g. async
09:33:28 <geekosaur> (most programs rely on the fact that killing the main thread kills all child threads, because it kills the whole process. but in ghci, the ghci process is still running afterward)
09:33:32 <cocreature> relying on threads to die automatically when the main thread dies, can also be dangerous if you expect your finalizers to run in that case
09:34:03 <sm> thanks geekosaur, cocreature, that helps
09:34:40 <sm> I'm not needing any special finalizers, I think, but for clean behaviour in GHCI I guess it's time to depend on async
09:40:44 <sm> another one. If the child thread also writes to a Chan each time, I see the output stop after one iteration. As if the second Chan write blocks.. but a Chan can hold many values, I assume
09:43:28 <c_wraith> a Chan can hold enough values to exhaust your memory if your consumers can't keep up with your writers. 
09:44:18 <c_wraith> in other words, I'm very wary of unbounded queues. :) 
09:44:39 <sm> that makes sense, but I'm only writing once a second
09:44:54 <ertes> sm: did you by any chance mix up your groupings?  forever output >> putChan …
09:45:03 <ertes> uhm, no
09:45:15 <sm> I also wonder if I should be using TChan, since Chan has scary warnings making me wonder when it is safe to use. But that's another q
09:45:16 <ertes> anyway, something like that
09:47:17 <MitchellSalad> sm: Chan is perfectly safe to use
09:47:23 <lpaste> sm pasted “thread blocking on writeChan ?” at http://lpaste.net/348673
09:47:56 <sm> just uncommenting that writeChan ^ seems to stop it looping
09:49:11 <ertes> sm: is there an actual reader?
09:49:45 <sm> ertes: yes, but it's not operational yet
09:50:25 <ertes> GHC detects dead-ends at least for MVar, and Chan is most likely implemented in terms of it…  although it shouldn't be a problem here, maybe Chan has some weird edge-case semantics
09:50:33 <sm> hmm
09:50:46 <cocreature> how is dbg0IO implemented?
09:51:13 <ertes> try this in an extra thread:  forkIO (forever (readChan eventChan))
09:51:17 <ertes> s/in/as/
09:51:38 <cocreature> but yeah ertes is probably right
09:52:05 <sm> cocreature: uh.. it's at http://hackage.haskell.org/package/hledger-lib-1.0.1/docs/src/Hledger-Utils-Debug.html#dbgIO , but it should be equivalent to a putStrLn here (if it wasn't "0", it would use unsafePerformIO)
09:54:18 <cocreature> sm: it looks like it’s calling trace from Debug.Trace instead of putStrLn
09:54:40 <sm> oh, ok
09:54:47 <sm> ertes: that didn't make a difference
09:54:52 <cocreature> sm: try putStrLn
09:54:57 <sm> ok
09:55:28 <MitchellSalad> a chan with no readers does not block writing @ertes
09:55:59 <sm> cocreature: that fixes it!
09:56:17 <cocreature> sm: the lesson is: don’t use Debug.Trace :)
09:56:23 <cocreature> especially not in IO
09:56:30 <cocreature> or rather don’t use trace
09:56:33 <cocreature> there is traceIO
09:56:51 <cocreature> GHC is free to figure out that it only needs to evaluate the trace statement once
09:56:53 <greymalkin> Anyone with snap experience: the tutorial adds `wrapSite (<|> heistServe)`, but heistServe requires an instance of HasHeist on App (in that case)
09:56:58 <ertes> or at least don't use it for anything other than debugging a pure expression that behaves weirdly =)
09:57:09 <sm> very interesting. I will meditate on this
09:57:34 <cocreature> yeah trace in IO is not really useful, you can just use any print/logging function
09:57:39 <ertes> impure I/O tends to have these weird effects
09:58:00 <ertes> (literally)
09:58:16 <cocreature> in this case it’s more about not having an effect :)
09:58:50 <ertes> interesting that the addition of writeChan made a difference in this case
09:58:55 <ertes> usually it's sharing
09:59:14 <ertes> so it was probably some super-clever GHC optimisation that caused it
10:00:01 <greymalkin> nevermind, found it.
10:02:04 <EvanR> impure I/O...
10:02:22 <EvanR> i want to categorize all the things that can be impure
10:03:15 <EvanR> impure functions, impure I/O, impure data, whats next
10:03:30 <hodapp> impure THOUGHTS
10:03:47 <koala_man> those are all impure thoughts
10:05:43 <sm> thanks, all!
10:07:13 <EvanR> haskell is a purely functional language, which generates the alternative, impure. and this word sounds pretty damning. no wonder everyone hates haskell ;)
10:07:40 <EvanR> "you just labeled every other language something bad sounding"
10:08:35 <jmnoz> how do I make stack runghc work when i do import Paths_pkgname in my module?
10:09:08 <jmnoz> anyone happen to know this?
10:12:23 <c_wraith> runghc seems like an odd fit in general with a Paths_foo package, as those tend to be created on installation. 
10:16:33 <jmnoz> so it's a caveat of using the Paths_pkgname module that you can not use runghc
10:36:34 * shapr hops quietly
10:37:06 <shapr> koala_man: do you actually look like a koala?
10:38:23 * hackagebot NetSNMP 0.3.2.5 - Bindings for net-snmp's C API for clients  https://hackage.haskell.org/package/NetSNMP-0.3.2.5 (PavloKerestey)
10:39:54 <koala_man> shapr: a bit. also, I sleep 22 hours a day
10:40:38 <shapr> koala_man: wow, do you code in your sleep?
10:40:44 <slack1256> lucky you
10:40:56 <MarcelineVQ> he's just really busy for those 6 hours
10:41:01 <MarcelineVQ> 2 hours, wow maths
10:41:33 <shapr> I feel like I get about two productive hours out of most days.
10:41:36 <MarcelineVQ> If days were strongly typed the compiler could have warned me
10:42:06 <slack1256> I wonder if someday we will have a way to slow down the perception of time.
10:42:19 <slack1256> maybe I would get more than two hours of productivity
10:43:23 * hackagebot stompl 0.4.0 - Stomp Parser and Utilities  https://hackage.haskell.org/package/stompl-0.4.0 (TobiasSchoofs)
10:45:00 <jmnoz> which is the best package?
10:45:09 <MarcelineVQ> base
10:45:26 <jmnoz> why?
10:45:43 <MarcelineVQ> Because it's got all the things you'll most commonly use across a wide range of programs
10:46:03 <MarcelineVQ> each specific program willsurely use other packages, but base's contents will be common across them
10:46:27 <MarcelineVQ> Luckily for you base comes with ghc so you've already got it
10:46:48 <shapr> Where's the hackage ranking by package?
10:47:00 <shapr> One of my fun time projects is writing examples for packages, starting with the most popular.
10:47:06 <shapr> but I keep forgetting where the ranking lives.
10:48:01 <slack1256> shapr: http://packdeps.haskellers.com/reverse ?
10:48:18 <jmnoz> here's a thing https://hackage.haskell.org/packages/top
10:48:37 <shapr> slack1256: too bad that one isn't sorted by count
10:48:41 <shapr> jmnoz: yeah, that's better
10:48:46 <slack1256> you write the examples for packages, where do you publish them?
10:49:05 <shapr> Mostly I write them for myself, but publishing them is a good idea.
10:49:05 <MarcelineVQ> surprised vector is so far down
10:49:10 <slack1256> I do the same for me, but I don't have a website nor server nor credit card to buy a domain...
10:49:15 <shapr> I figured I'd be most likely to use the most popular packages.
10:49:22 <shapr> slack1256: put 'em up on github?
10:49:27 <shapr> That's free for OSS projects
10:49:40 <MarcelineVQ> Allthough, these numbers are tiny, I wonder if these downloads are actuial site link clicks
10:49:59 <jmnoz> it's per month I suspect
10:50:20 <slack1256> yeah, but they mostly reseemble blogpost, so ideally I would work them in the haskell wiki...
10:50:29 <slack1256> how do I get a haskell wiki account?
10:50:31 <jmnoz> lens has 133005 total downloads from hackage
10:51:25 <shapr> slack1256: github-pages ?
10:51:40 <slack1256> checking out
10:52:33 <MarcelineVQ> slack1256: https://wiki.haskell.org/Special:UserLogin first paragraph there
10:52:58 <jmnoz> is Haskell usage growing much?
10:53:16 <MarcelineVQ> hard to say, there's a biannual report that's made iirc, lemme find a link
10:53:35 <MarcelineVQ> https://wiki.haskell.org/Haskell_Communities_and_Activities_Report
10:53:39 <shapr> jmnoz: it's certainly grown since I started
10:54:02 <slack1256> at least I can say we are not dying like others
10:54:54 <NemesisD> why does cabal with sandboxes sometimes refuse to reinstall packages when installed packages need version upgrades? youll see something like http-client-0.4.31.2 (conflict: bloodhound => http-client==0.4.31.1/installed-a54...)
10:54:59 <shapr> I can't think of a measurement that argues against the Haskell community growing.
10:55:30 <NemesisD> the only solution i've found so far is to blow the sandbox away which in CI means like 30+ minutes of time wasted to rebuild everything
10:55:40 <jmnoz> NemesisD: is this something that can be helped by using stack, i dunno
10:56:12 <NemesisD> jmnoz: oh certainly. i don't use cabal directly by choice anymore but this project is older and can't easily be ported to stack because reasons
10:56:41 <jmnoz> condolences
10:57:46 <NemesisD> i want to understand what's actually going on here though to see if there's a less severe (but scriptable) solution. if I don't cache .cabal-sandbox in CI, builds take forever. i'm telling it --force-reinstalls but it doesn't seem to want to listen
10:57:55 <jmnoz> shapr: speaking of stack, hopefully the vast improvement of tooling during the last few years should open the floodgates for new users - so to speak
10:58:15 <MarcelineVQ> there's a couple cabal options to get around that, --allow-newer maybe, and newer cabal versions have a different way to manage packages, `cabal new-build` maybe. that's pretty vague sorry, I've not used them myself
11:01:16 <MarcelineVQ> Additionally I'm not sure if those address your problem directly, for the same reason. You may need to change the version bounds in your project's cabal file.
11:01:19 <slack1256> github pages look really nice, plus seems to be a way of using hakyll with it!
11:02:02 <NemesisD> MarcelineVQ: the dependency graph is definitely solvable, i dump a freeze file at the end of my build, it just seems to refuse to proceed if it already has an installed dependency and it needs a different one
11:03:25 * hackagebot super-user-spark 0.3.2.0 - Configure your dotfile deployment with a DSL.  https://hackage.haskell.org/package/super-user-spark-0.3.2.0 (Norfair)
11:06:52 <NemesisD> cabal has been death by 1000 cuts on this project. i'm sure if I added up time lost it would be much less time to just figure out some way to get it on stack
11:07:59 <Faucelme> NemesidD: I think this explains the problem: http://blog.ezyang.com/2015/09/is-no-reinstall-cabal-coming-to-ghc-8/
11:10:06 <NemesisD> we just got on ghc 7.10 :/
11:10:40 <hvr> NemesisD: this works for GHCs back to at least GHC 7.4: http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
11:12:10 <hvr> and fwiw, on Stack you'll just trade one set of papercuts for another one :-)
11:12:24 <NemesisD> i've had nothing but success using stack on every other project i work on
11:12:29 <bhenchik> hello
11:12:45 <NemesisD> i'm most likely just going to detect this case in CI, blow away the sandbox and rebuild it
11:12:53 <hvr> NemesisD: keep using it then... :-)
11:13:22 <bhenchik> anybody working on smart grids?
11:13:39 <joe9_> I have to write a program in C, but, would love to translate the haskell's functional purity to the C world. Is that possible? I read about the pure keyword of gcc. It seems like a good idea. http://eprints.eemcs.utwente.nl/1077/ is a good book. Any other suggestions, please?
11:14:47 <hvr> NemesisD: fwiw, I'm not saying that pre-nix cabal is on par w/ stack
11:14:49 <bhenchik> read Denise Ritchie books for C
11:15:31 <hvr> NemesisD: the old-style sandboxes were just a workaround, compared to the nix-style builds
11:16:12 <bitemyapp> Nix is a lot harder for people to learn and get working than Stack. It's on the wrong side of the 80/20 split.
11:16:17 <bitemyapp> (for now)
11:16:36 <hvr> bitemyapp: that may be true, but you're missing the point here :-)
11:17:00 <hvr> bitemyapp: i.e. "nix-style" cabal and Nix are two totally different UIs
11:17:12 <hvr> nix-style cabal is easy to use
11:17:38 <hvr> it's more or less as easy as Stack to use, but you have more power if you need it
11:17:55 <bitemyapp> oh, sure. I don't doubt new-build is considerably easier to deal with than Nix.
11:18:33 <hvr> bitemyapp: https://github.com/xmonad/xmonad-testing#building-all-dependencies-with-a-specific-configuration-file
11:18:55 <hvr> just saying...
11:19:02 <joe9_> Is there a stack test command to run the tests just for this package instead of running the tests of included packages?
11:19:19 <NemesisD> joe9_: i think that's the default now?
11:19:22 <bitemyapp> hvr: https://twitter.com/mxavier/status/804404341276708864 just saying...
11:19:45 <kadoban> joe9_: Are the "included" packages just extra-deps, morally? You should flag them as such and then tests aren't run for them
11:19:50 <NemesisD> jesus you're fast, Chris
11:19:53 <bitemyapp> that's not me
11:19:54 * slack1256 likes nix...
11:19:59 <NemesisD> it me
11:20:06 <hvr> bitemyapp: you've convinced me... I'll start using Stack now all my Haskell needs =)
11:20:09 <bitemyapp> well I wasn't going to out you
11:20:22 <bitemyapp> hvr: I don't care about your productivity
11:20:35 <bitemyapp> hvr: use a magnetic needle and a plate if you like.
11:20:54 <hvr> bitemyapp: you mean Setup.hs directly?
11:21:00 <NemesisD> no biggie. to be fair i'll give the new cabal nix style whatever the heck a quick spike and see if it helps. just frustrated
11:21:13 <bitemyapp> hvr: I've had to purge custom Setup.hs builds and it was irritating af.
11:21:18 <bitemyapp> hvr: I think we can agree those need to go :P
11:21:31 <NemesisD> i've walked back custom Stack.hs files every time and just use shake or something instead
11:21:33 <bitemyapp> NemesisD: re: fast - you may call me Sanic
11:21:37 <hvr> bitemyapp: I'm no fan either custom-type packages
11:21:44 <joe9_> kadoban:ok, will try to set the package as extra-dep
11:21:51 <hvr> bitemyapp: they're a headache to handle in cabal
11:22:04 <kadoban> joe9_: If it's in the packages list, you leave it there and just set the flag. If that helps.
11:22:07 <bitemyapp> yeah I've seen custom builds mean certain cleanups couldn't happen
11:22:12 <bitemyapp> Distressing.
11:22:34 <joe9_> kadoban: yes, it is in the packages list. but, I cannot seem to set extra-dep flag there. let me try again.
11:23:29 <joe9_> kadoban:  Unrecognized field in PackageGitLocation: extra-dep
11:23:32 <joe9_> is the message
11:23:33 <hvr> unfortunately, doctest seems to be one reason ppl start using custom-type Setup.hs these days
11:23:42 <bitemyapp> doctest regularly causes me grief too
11:23:56 <srhb> Is there any way to leverage DuplicateRecordFields to avoid prefixing field names with makeClassy?
11:24:00 <joe9_> kadoban: https://gist.github.com/e3bff65be8cbec559a948c974d169a5b is my stack.yaml file
11:24:07 <hvr> yeah, doctest's impl is quite  hack
11:24:10 <bitemyapp> Only test-suite setup that regularly breaks for people.
11:24:22 <bitemyapp> everything else is pretty reliable (hspec, plain test stanzas, etc.)
11:24:37 <kadoban> joe9_: Unindent it a bit to match the l of location with the e of extra-dep (the first one), I believe
11:24:40 <hvr> it's trying to workaround missing features on the GHC side
11:24:43 <kadoban> (yeah, it's not intuitive)
11:24:55 <bitemyapp> hvr: sounds like a good idea for a GHC proposal :D
11:25:09 <NemesisD> lol, cabal new build \n Resolving dependencies.... \n [1]    12194 killed     cabal new-build
11:25:09 <kadoban> joe9_: I usually have it after the git: and commit: lines too, though I'm not sure that matters.
11:25:21 <hvr> NemesisD: out of mem?
11:25:24 <joe9_> kadoban: http://codepad.org/AmQqACZM . let me try after the git and commit
11:25:25 <NemesisD> yep
11:25:41 <joe9_> kadoban: THat worked.
11:25:44 <hvr> NemesisD: I assume cabal 1.24?
11:25:46 <joe9_> kadoban: Thanks.
11:25:58 <kadoban> joe9_: Cool. Yeah I wish it wasn't so damn picky. I should learn more about YAML sometime
11:26:00 <NemesisD> hvr: yeah 1.24.0.0 to be precies
11:26:00 <kadoban> 'welcome
11:26:15 <bitemyapp> OOM can be a mantra if you say it with the right intonation
11:28:34 <MarcelineVQ> kadoban, joe9_: extra-dep:​ true should be at the same indentation level as the L of location
11:29:15 <kadoban> Ya, we got it squared. It's just very exacting.
11:29:49 <MarcelineVQ> Oh I see yes you did, awesome :>
11:30:00 <c_wraith> kadoban, YAML is full of terrifying ruby-only things that no sane person would have designed. 
11:30:42 <kadoban> c_wraith: Seems like it :-/ Can't say I'd ever pick it myself, having used it more than a few times.
11:30:56 <MarcelineVQ> everything should be .ini
11:31:12 <EvanR> were all in one huge universal S expression
11:31:40 <kadoban> I'd probably do JSON, since all of this crap is for coders anyway, but maybe that'd have other downsides.
11:32:07 <c_wraith> json gets really unwieldy to edit by hand. 
11:34:01 <joe9_> good book http://eprints.eemcs.utwente.nl/1077/ just want to check if anyone has stumbled upon it.
11:35:48 <monochrom> interesting
11:42:33 <EvanR> o_O
11:43:26 * hackagebot messagepack 0.5.4 - Serialize instance for Message Pack Object  https://hackage.haskell.org/package/messagepack-0.5.4 (rodrigosetti)
11:53:27 * hackagebot sbp 2.1.1 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-2.1.1 (markfine)
11:54:02 <ggVGc> if I want to make a Monoid instance for something like `Int -> MyType`, do I have to use a newtype? To discern from the Monoid instance of (a -> b)
11:55:27 <lyxia> yes
12:01:13 <ggVGc> that's unfortunate
12:01:16 <ggVGc> and makes me unhappy
12:02:32 <EvanR> ggVGc: yes, otherwise itd be overlapping instances
12:03:15 <EvanR> what would your instance do ?
12:07:50 <jle`> ggVGc: yeah, otherwise you wouldn't be able to specify what instance to use
12:08:23 <jle`> if you tried to mappend two Int -> MyType's, there's two instances you could use, which might have different behavior/results
12:08:33 <jle`> how would you tell GHC which one you wanted?
12:10:00 <EvanR> jle`: presumably with a priority, determined by CSS-like specificity
12:10:22 <jle`> EvanR: as in...the last instance seen is the one used? >_>
12:10:31 <EvanR> its more complicated than that in css
12:10:40 <jle`> sounds complicated
12:10:42 <EvanR> but yeah thats what it ends up being in case theres a tie
12:10:50 <EvanR> and haskell doesnt really have that
12:10:53 <EvanR> "last one seen"
12:11:01 <jle`> yeah, that was my point :)
12:11:04 <EvanR> in ggVGc's case its not a tie
12:11:23 <EvanR> if its a tie, it could be ambiguous instance error
12:11:46 <jle`> so the choice would be made...automatically?
12:11:52 <jle`> by the compiler?
12:11:52 <joe9_> Which format of the date string does Haskell read parse? I get no parse with this string:  "1970-01-01 00:00:00 UTC"
12:11:55 <EvanR> its already made automatically
12:12:04 <EvanR> you control it with newtypes
12:12:25 <jle`> how would you specify if you wanted to use the general a -> b instance?
12:12:28 <EvanR> joe9_: try "1970-01-01T00:00:00"
12:12:47 <jle`> joe9_: what type are you parsing it as?
12:13:12 <EvanR> jle`: if there is a more specific instance for the particular a and b, you wouldnt be able to. like OOP overriding
12:13:17 <EvanR> once its overridden, its overriden
12:13:25 <EvanR> to go back, remove the override
12:13:49 <joe9_> EvanR: jle` got it. I was missing the type of UTCTime.
12:13:50 <jle`> doesn't sound too ideal ... and doesn't sound like that's what ggVCc wants in any case
12:14:26 <EvanR> it sounds like what ggVGc is expecting, not saying it makes sense. for example how does this specificity even work, its not clear
12:15:20 <EvanR> actually we dont have support for specifying overlaps
12:15:26 <EvanR> er... we DO
12:15:44 <jle`> they want to be able to use 'mappend' with (Int -> MyType)'s in a way that's different from general a -> b's in a specific use case, but that doesn't mean that they want ALL mappends with (Int -> MyType)'s to have that behavior
12:15:53 <jle`> globally
12:15:59 <jle`> that'd be crazy
12:16:08 <EvanR> oh?
12:16:13 <EvanR> sounds like speculation
12:16:19 <jle`> even in imported libraries that use (Int -> MyType)'s and expect the normal monoidal behavior
12:16:24 <jle`> now all of those libraries would be broken
12:16:35 <EvanR> that doesnt mean ggVGc didnt want that
12:16:47 <EvanR> just that he shouldnt want that hehe
12:16:53 <jle`> haha that's fair
12:23:45 <megaTherion> what exacly does it mean, to write (Type x) prior a function decleration?
12:23:58 <megaTherion> like (Type x) => a -> b -> c
12:24:14 <kadoban> megaTherion: Those are constraints, typeclass constraints
12:24:33 <kadoban> Type isn't really a type, it's a typeclass. It means that x is an instance of that typeclass.
12:24:34 <geekosaur> and it's not a type, it's a typeclass, these are very different things
12:25:01 <kadoban> (and x would appear somewhere on the right of =>)
12:25:06 <geekosaur> you can't have something of e.g. "type" Num or Eq. you can only constrain types to require they have instances of that typeclass
12:25:10 <megaTherion> kadoban: constaints as in, these function will only emit type's of the class x?
12:25:13 <jle`> megaTherion: for example, `sort :: Ord a => [a] -> [a]` means that 'sort' takes an [a] and returns an [a], requiring that 'a' is an instance of the Ord typeclass
12:25:22 <megaTherion> hmm
12:25:22 <megaTherion> ok
12:25:31 <jle`> so Int has an Ord instance
12:25:34 <jle`> Bool does, as well
12:25:39 <jle`> so you can use sort :: [Int] -> [Int]
12:25:51 <megaTherion> if I get an message like "No instance for (Num a) arising from the literal ‘0’" <- why does it help to add (Num a) - does it mean that a cannot be properly deduced?
12:25:54 <jle`> but you can't use something that doesn't implement Ord, like, say, (String -> Double)'s
12:26:26 <jle`> megaTherion: ah.  type signatures are contracts about what your function can take and provide
12:26:40 <megaTherion> I had to stop learning more haskell a couple of weeks ago but the type system is one of the hardest things to understand for me
12:26:44 <jle`> megaTherion: if 'sort' had the type sort :: [a] -> [a]
12:26:50 <jle`> it'd be a lie
12:26:58 <jle`> that means that it can take a list of *any* type, and sort it
12:27:05 <jle`> but, that's not true.  it can't sort things that aren't comparable
12:27:22 <megaTherion> ah ok, so that's an assumption for many functional languages - everything is generic at first sight
12:27:23 <jle`> so sort :: [a] -> [a] is too general of a type signature.  it can't take *any* a, it can only take a's that are instances of Ord
12:27:26 <EvanR> i noticed a lot of guides only go over the most basic types, monotypes and basic polymorphic functions
12:27:39 <jle`> megaTherion: yeah, that's what type variables represent in type signatures
12:27:50 <EvanR> even the full scope of standard typeclass constraints i didnt fully understand until a lot of osmosis
12:28:32 <jle`> megaTherion: so it looks liek you're trying to use Num typeclass methods on an input whose type comes from the type variable 'a'
12:28:58 <jle`> megaTherion: but, as someone who *writes* a function that's a -> a -> blah, you have to be able to handle all a's
12:29:05 <jle`> because the person calling your function might give something that's not a Num
12:29:08 <jle`> like, say, String
12:29:29 <jle`> it might as for your function where 'a' is String
12:29:58 <jle`> so `Num a => a -> a ...` means that this function can only be called for a's that are instances of Num
12:30:15 <jle`> whereas `a -> a -> ...` means that this function can be called for *any* a, Num or not, Ord or not, etc.
12:30:52 <EvanR> a function with type :: [a] -> [a] would have to work for all a. [Int] -> [Int], [Char] -> [Char], [really complicated] -> [really complicated]
12:31:11 <EvanR> so that limits what kind of stuff it can do
12:31:30 <EvanR> mainly you wont be able to look at any of the elements, it could be "anything"
12:31:40 <EvanR> you can only rearrange list nodes
12:32:22 <jle`> so if i tell you that my function is (a -> a), but in the process i do something like add 10 to my input, then my type signature is a lie.  it's not really an (a -> a), and your users can't use it as an (a -> a).  its most general possible type would be (Num a => a -> a)
12:32:57 <jle`> for something like say, `foo x = 2 * x + 10`
12:33:15 <jle`> i couldn't call foo with, say, a String
12:33:28 * hackagebot opentype 0.1.1 - Opentype loading and writing  https://hackage.haskell.org/package/opentype-0.1.1 (KristofBastiaensen)
12:33:53 <EvanR> map :: (a -> b) -> [a] -> [b] works without constraints because it is given an extra tool to work on the list elements
12:34:13 <EvanR> you can think of the constraints as another kind of extra tool, its literally going to pass in a dictionary of operations
12:34:59 <jle`> megaTherion: oh, also note that if you left the type signature off, the constraint could be inferred
12:35:14 <jle`> megaTherion: the only reason you're getting this error is because you're explicitly providing a type signature that the compiler recognizes is a lie
12:35:27 <jle`> @let foo1 x = 2 * x + 10
12:35:30 <lambdabot>  Defined.
12:35:32 <jle`> :t foo1
12:35:36 <lambdabot> Num a => a -> a
12:35:43 <jle`> @let foo2 :: a -> a; foo2 x = 2 * x + 10
12:35:45 <lambdabot>  .L.hs:174:10: error:
12:35:45 <lambdabot>      • No instance for (Num a) arising from a use of ‘+’
12:35:45 <lambdabot>        Possible fix:
12:36:09 <jle`> GHC can indeed deduce that foo1 requires a Num constraint
12:36:52 <jle`> the reason foo2 doesn't compile is because its type signature is a lie
12:48:15 <ab9rf> how dare it reject code simply because of a false type signature!
12:49:41 <megaTherion> jle`: sorry I was on the phone, I've an question to the type issue's - if I do (Num a) does this mean any a... so all argument's and the output value?
12:50:10 <EvanR> ab9rf: gradual typing agrees!
12:51:57 <EvanR> type signatures should be more of a guideline than a rule
12:53:08 <EvanR> megaTherion: Num a => puts a constraint on a type involving a, it means "any type a as long as it has a Num instance"
12:53:33 <megaTherion> so I could do (Num a, Num b)?
12:53:34 <EvanR> more constraints on the left of => means fewer types will be accepted
12:54:17 <EvanR> (Num a, Num b) => some type involving a and b, thats valid
12:54:46 <slack1256> in "iterate (+1) 0 !! 1000" will reduce a 1000 levels thunk (and memory too). Is the term "1000-level thunk" used? does it has a better name?
12:55:18 <EvanR> it will?
12:55:31 <EvanR> @src (!!)
12:55:31 <lambdabot> xs     !! n | n < 0 = undefined
12:55:32 <lambdabot> []     !! _         = undefined
12:55:32 <lambdabot> (x:_)  !! 0         = x
12:55:32 <lambdabot> (_:xs) !! n         = xs !! (n-1)
12:56:07 <EvanR> i see
12:56:39 <EvanR> slack1256: levels doesnt make sense in general, since it could be a cyclic graph
12:57:01 <EvanR> but it evaluates to a 1000-level deep expression, you could say that
12:57:24 <slack1256> Mmmmm right
12:58:17 <EvanR> its clear how bad !! really is from looking at that
12:58:30 <ab9rf> yeah, !! is almost always bad
12:58:56 <ab9rf> horrible time complexity, and nontotal to boot
12:58:56 <kadoban> Well, that's not the actual source of !! of course, so it's a bit hard to take seriously, though it can't be much better.
12:59:00 <EvanR> in real life the n-1 could be evaluated strict
12:59:40 <dolio> It is strict in n.
12:59:48 <kadoban> Wouldn't it strictify itself usually since it tests against 0 almost immediately?
13:00:10 <slack1256> yep
13:00:23 <ab9rf> and because the (n-1) forces n to be strictly evaluated
13:00:24 <EvanR> then it wont need to make a huge thunk
13:00:41 <dolio> iterate makes the thunk.
13:00:51 <dolio> (!!) just gives it to you.
13:06:23 <jchia_> :t First
13:06:26 <lambdabot> Maybe a -> First a
13:06:44 <jchia_> :i First
13:09:49 <jchia_> Is there something like foldMap that works with a non-empty list for Semigroup instead of a (possibly-empty) list of Monoid?
13:11:20 <jchia_> i.e. foldMap2 :: Semigroup s => (a -> s) -> NonEmpty a -> s
13:11:59 <EvanR> somehow Monoid is embedded in the logic of Foldable and Traversible
13:12:34 <EvanR> but your signature doesnt care about those in general
13:12:34 <jchia_> EvanR: Foldable doesn't require non-emptiness, so foldMap has to use a Monoid
13:12:50 <EvanR> yours is specific to non-empty lists
13:13:12 <jchia_> I'm just trying to see if I can make do with a Semigroup if I can make sure the list is non-empty
13:13:12 <EvanR> maybe there is a theory of "pointed" traversibles
13:13:19 <EvanR> or inhabiteed
13:13:49 <dolio> It's because Applicatives are all about monoids.
13:15:01 <jmnoz> do people actively use chrisdone's "formatting" package or is it superceded by something else?
13:15:02 <jchia_> EvanR: I don't know of a type class that expresses non-emptiness
13:15:26 <EvanR> in haskell, it kind of wouldnt make sense because "bottom is in every type"
13:15:48 <EvanR> but Default is basically that typeclass
13:16:04 <EvanR> def :: Default a => a
13:16:46 <EvanR> a better representation would be the dependent sum Sigma[a : Type] a
13:16:51 <dolio> You've got it backwards though.
13:16:52 <nshepperd1> Non emptiness is different from inhabitedness
13:17:05 <EvanR> ah yes
13:17:20 <dolio> The pure part of Applicative is what allows you to traverse empty things.
13:17:41 <dolio> And having default for a traversable kind of allows it to be empty.
13:17:58 <dolio> Because you can get one without providing an element.
13:18:11 <nshepperd1> You could certainly have a Fold1able typeclass or something that would replace monoid with semigroup
13:19:09 <dolio> Did you replace an l with a 1?
13:19:15 <dolio> That may be the worst name I've ever seen. :)
13:19:38 <EvanR> Fo1dable
13:19:43 <dolio> Oh, you just added a 1 to the middle.
13:19:58 <EvanR> Fo1dab1e would be, at least 2 elements
13:20:08 <EvanR> and thats as far as it goes
13:20:10 <nshepperd1> Heh. No it's supposed to look like the fold*1 list functions
13:20:21 <Tuplanolla> Dyslexics love Folbadle.
13:20:29 <EvanR> Foldabl3
13:20:35 <EvanR> hold on!
13:21:15 <jchia_> Here's the concrete problem I'm trying to solve:
13:21:16 <jchia_> rc = x
13:21:16 <jchia_>         ...
13:21:16 <jchia_>         & groupBy ((==) `on` fst)
13:21:16 <jchia_>         & map (bimap (fromJust . getFirst) getAddRcSym . foldMap (bimap (First . Just) AddRcSym))
13:21:46 <jchia_> after the groupBy, I have a list of (non-empty) lists, but foldMap doesn't know, so I'm still required to provide Monoids in order to use foldMap
13:22:02 <jchia_> So I even have to use fromJust. It's ugly.
13:22:45 <EvanR> i kind of gave up trying to care about non-emptiness in haskell
13:22:52 <EvanR> its like trying to use unsigned ints
13:23:11 <jchia_> EvanR: Why do people care about it so much?
13:24:19 <EvanR> it?
13:25:16 <jchia_> non-emptiness
13:25:45 <EvanR> it seems were coming to the conclusion we dont?
13:27:25 <nshepperd1> Semigroups package has a groupBy that produces NonEmpty lists. You could use that and foldr1
13:27:49 <jchia_> i think the language is not expressive enough to treat guard against non-emptiness in a practical way.
13:28:09 <jchia_> nshepperd1: Thanks
13:28:28 <ggVGc> EvanR: Fold4ble, 5oldable, Folda6le
13:28:56 <EvanR> at least 6 elements should be enough for anybody
13:29:55 <nshepperd1> Or, sconcat even. Sconcat :: Semigroup a => NonEmpty a -> a
13:34:16 <joe9_> I am receiving data in milliseconds and I want to store it as UTCTime. I can do: addUTCTime <milliseconds> unixEpoch. I cannot figure out how to convert milliseconds to NominalDiffTime so I can use it as the argument to addUTCTime
13:34:37 <joe9_> the milliseconds is the number of milliseconds from epoch.
13:35:01 <joe9_> I am not sure if there is a way to convert it directly to UTCTime instead of using addUTCTime.
13:35:09 <EvanR> to convert number of seconds (fractional) to nominal diff time, use realToFrac
13:35:56 <EvanR> POSIXTime = NominalDiffTime
13:36:03 <EvanR> posixSecondsToUTCTime :: POSIXTime -> UTCTime
13:36:15 <joe9_> EvanR: cool, Thanks.
13:37:08 <EvanR> the conversion actually does something, because NominalDiffTime is a Pico, not a Double
13:37:16 <EvanR> something to keep in mind
13:38:41 <joe9_> EvanR: yes, the Pico is bogging me down. I could not figure out what it is.
13:38:49 <EvanR> Data.Fixed
13:38:52 <joe9_> :info Pico did not turn up anything.
13:38:56 <joe9_> ok, Thanks.
13:38:58 <EvanR> its like, an Integer shifted over by 12 decimal places
13:39:50 <EvanR> the functional C book has this sentence which i couldnt decipher, when talking about functional vs imperative RNGs
13:39:54 <EvanR> The theory of random number generators tells us that it is incorrect to use alternate numbers from one random number generator to generate the values of the two dice [5]. Instead, two independent random generators must be used.
13:40:10 <EvanR> so it uses two different generators for the two dice
13:40:26 <EvanR> is it talking about bad RNGs or what
13:40:26 <Tuplanolla> That doesn't make sense.
13:41:52 <geekosaur> it makes sense..  if that book was written when LCPRNGs were the ones used most often
13:42:17 <geekosaur> (linear congruential)
13:42:57 <EvanR> yes that is what its using
13:43:06 <EvanR> seems like a weird workaround though
13:43:07 <Tuplanolla> Well, for some `m` the call `rand() % m` produces an even number every other time.
13:43:39 <Tuplanolla> Maybe the author based his conclusions on this observation.
13:43:40 <geekosaur> once you start using hashing based or Mersenne twister, etc., which only became feasible for normal use relatively recently, then you have less of a problem with consecutive generated numbers potentially being related in a way that shows up when adding them
13:44:08 <EvanR> or MWC ?
13:45:21 <EvanR> 32-bit MWC was pretty feasible back in the 32-bit days
13:45:23 <geekosaur> but they stated that like it's some fundamental thing about PRNGs in general. probably didn't really understand PRNGs...
13:53:31 * hackagebot flat-mcmc 1.4.1 - Painless general-purpose sampling.  https://hackage.haskell.org/package/flat-mcmc-1.4.1 (JaredTobin)
13:55:19 <ertes> most LCGs are truncated anyway, because a generalisation of Tuplanolla's note is that if you take an LCG modulo 2^n, you basically get a pretty terrible sub-LCG (a consequence of how modular arithmetic works)
13:55:51 <ertes> truncation doesn't eliminate this, but sets a lower bound in the cycle of such a pattern
13:56:05 <ertes> at least statistically
13:56:38 <ertes> in other words: to generate two die throws, pick the highest bits, not the lowest bits
13:58:14 <geekosaur> yep. and, well, the less said about rand(), the better. (in glibc it's been replaced with something saner; most other OSes' libc-s still use the original crappy LCG modulo 2^n)
13:59:30 <EvanR> is any operation like "give me a random number" going to be an abstraction leak? you always wonder what the RNG is doing
14:00:04 <jmnoz> so on win32, TextShow printT seems to not die as much as Data.Text.IO (putStrLn) why am I a fool?
14:01:01 <ertes> EvanR: your abstraction could guarantee a certain statistical quality or even go as far as to guarantee cryptographic strength
14:01:21 <ertes> that's what libraries like DRBG do
14:01:25 <ertes> (the latter)
14:01:39 <EvanR> i uh... is statistical quality an abstraction ?
14:02:36 <ertes> an informal one…  there are some statistical tests like DIEHARD, and you could guarantee that the generator passes them
14:02:51 <EvanR> or that it probably passes them
14:03:03 <EvanR> since you ran it and it passed, once
14:04:11 <EvanR> i dont know what pass fail is anyway, those test results are give in terms of estimate probability
14:04:47 <EvanR> after this inductive graph decomposition thing, im thinking, man where is the abstraction in RNGs
14:06:19 <ertes> EvanR: if you don't trust that, you might prefer cryptographic strength: "it's widely used in security-related areas, yet nobody has found a way to predict"
14:07:17 <EvanR> is statistical quality a prereq for cryptographic strength (where crypto straight means, can we get the RNG state by looking at the output)
14:07:25 <EvanR> cryptostrength
14:08:15 <megaTherion> is it possible to use an Word16 as list index?
14:08:37 <EvanR> if you convert it to an Int and use !! yes
14:08:46 <EvanR> if you write a different algorithm that uses Word16 yes
14:08:47 <megaTherion> EvanR: how would I convert it to an Int?
14:08:54 <EvanR> with fromIntegral
14:08:58 <megaTherion> oh
14:09:27 <geekosaur> :t genericIndex
14:09:30 <lambdabot> Integral i => [a] -> i -> a
14:09:43 <EvanR> @src genericIndex
14:09:43 <lambdabot> Source not found. :(
14:09:57 <geekosaur> it's just applying fromIntegral to the index
14:10:04 <Eduard_Munteanu> I suspect a crypto RNG could fail statistic tests if its strength is lower than the output space (yet still strong enough).
14:10:10 <EvanR> really?
14:10:31 <EvanR> if it were really generic it would be the same as @src (!!) just with a different signature
14:10:45 <geekosaur> maybe I got the wrong one, am a bit wonky today
14:11:10 <geekosaur> uh
14:11:12 <geekosaur> :t (!!)
14:11:14 <lambdabot> [a] -> Int -> a
14:11:36 <geekosaur> but @src is just a manually curated and fairly stupid text database, don't trust it
14:11:56 <shapr> chin-tastic: OH HAI!
14:12:11 --- mode: ChanServ set +o chin-tastic
14:13:25 <shapr> chin-tastic: how code? You doing Twitter stuff?
14:13:53 <chin-tastic> shapr: HAY!
14:14:18 <chin-tastic> shapr: I'll get back to it when the Harry Potter marathon is over.
14:14:19 --- mode: ChanServ set -o chin-tastic
14:14:25 <shapr> good plan
14:14:26 <megaTherion> EvanR: thanks, that did the trick - would you write t!!(fromIntegral x) or is there a better way to do?
14:14:34 <EvanR> chin-tastic: off topic!
14:14:53 <geekosaur> if I were doing it a lot, I'd probably put a binding at top level
14:15:17 <EvanR> megaTherion: well, you could also do t `genericIndex` x
14:15:41 <Eduard_Munteanu> fromIntegral might truncate things.
14:15:47 <geekosaur> (!!!) :: Integral i => [a] -> i -> a; (!!!) = genericIndex -- or something, probably also make sure it has the same fixity as (!!)
14:16:09 <Eduard_Munteanu> I think genericIndex et al. are default with newer preludes like ClassyPrelude.
14:16:30 <megaTherion> what's genericIndex?
14:16:37 <EvanR> we were just talking about it
14:16:46 <Eduard_Munteanu> Same as (!!) but for arbitrary integral types.
14:17:10 <megaTherion> a function?
14:17:15 <Eduard_Munteanu> > [3, 5, 7, 8] `genericIndex` 2
14:17:18 <lambdabot>  7
14:17:24 <EvanR> (if it truncates to 32-bit Int, thats still a insanely long list that would be broken)
14:17:58 <megaTherion> I've to load a module for it?
14:18:20 <Eduard_Munteanu> :t Data.List.genericIndex
14:18:22 <lambdabot> Integral i => [a] -> i -> a
14:18:26 <Eduard_Munteanu> Data.List.
14:18:42 <megaTherion> oh ok, sorry Im not well educated with the Haskell eco system (yet)
14:23:23 <lpaste> Tuplanolla pasted “Integer Roots” at http://lpaste.net/348787
14:23:58 <Tuplanolla> Can someone shed some light on why my intuition fails when defining `integerRtUp`?
14:24:10 <Tuplanolla> It almost works that way, but not quite.
14:25:25 <lyxia> uh, what is it supposed to do
14:25:45 <Tuplanolla> They're integer roots.
14:25:54 <Tuplanolla> The idea is to satisfy `integerRt k n == floor (n ** (1 / k))` and `integerRtUp k n == ceiling (n ** (1 / k))`.
14:25:58 <lyxia> oh
14:26:04 <danharaj> bgamari: question. why does it seem that arc can never realize which diff i'm working on when i amend and i have to tell it to update D2714?
14:26:22 <danharaj> i feel that i am misusing it somehow
14:26:32 <danharaj> whoops. wrong channel!
14:26:59 <TCZ> i dont wanna know what u are misusing...
14:27:18 <TCZ> oh
14:27:21 <TCZ> nvm
14:27:49 <Tuplanolla> I'm after for a solution where I could simply insert the correct rounding scheme (`quot` or `quotUp`) and get the correct result with the same algorithm.
14:27:57 <geekosaur> phabricator and its tools (here, arcanist) have ... interesting ... expected workflows
14:29:16 <geekosaur> although I suspect arcanist in particular was named with malice aforethought :)
14:31:38 <slack1256> what exactly is stack usage in haskell? in C the implicit stack says from where the currect function was called, such on return you pop it and go from there
14:32:59 <c_wraith> slack1256, in ghc-compiled haskell, the stack is used for evaluating expressions. 
14:34:00 <c_wraith> slack1256, where "evaluation" is the process of reducing an expression to its top-level constructor. 
14:34:57 <c_wraith> slack1256, when evaluation depends on evaluating another expression, that's when a new stack frame is created. 
14:35:47 <slack1256> on a constructor with two values, to evaluate each of the thunk it will create two stack frames for each then
14:36:07 <geekosaur> slack1256, ghc doesn't do call-return type stuff, it reduces a graph representation. that reduction involves evaluating expressions, and it is *that* that ends up on the stack (can't reduce this thing until some other thing has been reduced, stack it and go reduce that)
14:36:17 <slack1256> Mmm on C you always reduce a single path at a time, so the stack is linear. Where you need diverging stacks
14:36:38 <c_wraith> slack1256, the code ghc generates does one before the other, as well. 
14:36:44 <monochrom> Tuplanolla: if you use div instead of quot, is it better? Do you actually know that quot gives you what you want?
14:36:47 <orion> hmm... graph. Is there a way to generate a visual representation of said graph, geekosaur?
14:37:00 <slack1256> geekosaur: You are right!, the stack then reifies the dependency of the data
14:37:13 <Tuplanolla> All the numbers are positive, monochrom.
14:37:23 <geekosaur> I don't think so offhand. but you can get ghc to dump the STG and something could conceivably postprocess that
14:38:00 <monochrom> OK, next thing to watch out for is precedence. In "(n - 1) `quot` d + 1", are you sure that the computer sees what you see?
14:38:02 <c_wraith> vacuum (package) can show you the evaluated portion the graph 
14:38:02 <EvanR> there is a thing to visualize data structures in memory
14:38:27 <EvanR> ghc-viz
14:38:38 <Tuplanolla> Yes, monochrom.
14:38:40 <c_wraith> but I don't know of anything that also graphs the unevaluated portion in memory. 
14:38:49 <lyxia> is the algorithm supposed to work though
14:38:58 <c_wraith> EvanR, oh, does that include unevaluated expressions? 
14:39:05 <EvanR> http://felsin9.de/nnis/ghc-vis/
14:39:10 <Tuplanolla> The thing is, `integerRt` works fine, but `integerRtUp` doesn't.
14:39:31 <geekosaur> I don't think the unevaluated portion is easy to reconstruct from the machine code generated for it, which is why I suggested getting ghc to dump the STG level
14:40:06 <mzabani> hi everyone, I'm having trouble with Attoparsec's endOfInput failing after every other character has been consumed (when it seems to me it should do the opposite). Anyone know what is going on?
14:40:08 <geekosaur> below that level you'd have to decompile, then recognize how STG is compiled to machine code on that platform to reconstruct the graph from the bottom up
14:40:35 <c_wraith> geekosaur, I'd be happy with just "thunk holding pointers to.." info
14:40:52 <monochrom> No no, just -ddump-asm to see machine code :)
14:40:55 <slack1256> isn't that exactly what retainer profiling does?
14:40:59 <c_wraith> geekosaur, you know, enough to see space leaks in the graph 
14:41:00 <EvanR> "what we'd like to see is something like this, which is what ghc-vis outputs"
14:41:02 <geekosaur> it's far easier when ghc is actually evaluating since the parts it is evaluating are actually available as live data structures instead of as machine code to generate those data structures
14:41:03 <slack1256> for c_wraith
14:41:58 <hackrilege> :t Just $ Just $ Just Nothing
14:41:59 <lambdabot> Maybe (Maybe (Maybe (Maybe a)))
14:42:06 <buttbutter> How do I write Haskell that isn't a steaming pile of crap? I just wrote this nearest neighbor classifier, and--at least to me--it's confusing and hard to read. How can I do better? http://lpaste.net/6133010778095091712
14:42:15 <c_wraith> slack1256, sort of, but I want a library like vacuum (or ghc-vis, I suppose) that outputs graph graphviz files
14:42:24 <c_wraith> -graph
14:42:31 <EvanR> c_wraith: looks like it also lets you see the difference between interpreted and compiled 
14:42:39 <EvanR> vacuum shows the evaluated data
14:42:57 <slack1256> ghc-viz is a haskell package? doesn't show in hackage
14:43:02 <EvanR> ghc-vis
14:43:08 <slack1256> duh
14:43:10 <EvanR> http://felsin9.de/nnis/ghc-vis/ http://felsin9.de/nnis/ghc-vis/ http://felsin9.de/nnis/ghc-vis/ ;)
14:43:10 <slack1256> sorry
14:43:37 <c_wraith> slack1256, no, it's a standalone suite of programs for converting text descriptions to visual graphs. 
14:43:42 <EvanR> the arrows cross and go up sometimes! yay
14:44:22 <EvanR> "The GHCi Debugger has an integrated :print command that inspects data structures at runtime. Evaluation is not forced, so there are no side effects." whoa ;)
14:44:27 <c_wraith> slack1256, it includes things like the dot program 
14:44:59 <EvanR> :print doesnt show sharing though, where vacuum and ghc-vis do
14:45:05 <c_wraith> slack1256, http://www.graphviz.org/
14:45:22 <hackrilege> I don't understand why Fix Maybe are value level Nats and not type level ones, since the type of nested maybes seems like a representation of natural numbers....
14:45:35 <hackrilege> :t Just $ Just $ Just Nothing
14:45:37 <lambdabot> Maybe (Maybe (Maybe (Maybe a)))
14:45:48 <EvanR> how would those be type level ?
14:46:05 <c_wraith> hackrilege, that's not the type of something using Fix
14:46:23 <hackrilege> Minus the Fix constructor...
14:46:37 <c_wraith> hackrilege, but the Fix constructor is what flattens the type. 
14:46:42 <hackrilege> Ahhhh
14:46:53 <hackrilege> Ok, I understand
14:47:13 <hackrilege> Thanks
14:58:34 * hackagebot gnss-converters 0.2.0 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.2.0 (markfine)
15:19:09 <dfeuer> Ping edwardk 
15:27:35 <geppettodivacin> buttbutter: I think your code looks quite nice, actually. It might just take a while to get used to reading Haskell.
15:29:30 <buttbutter> geppettodivacin: Hm. Maybe so. I decided to actually add some extra types to increase readability of the type signatures. I think it helped: http://lpaste.net/1605554892317917184
15:29:58 <buttbutter> But I've seen some super elegant/readable Haskell. I want to be there. But I think it just takes time/experience.
15:32:11 <geppettodivacin> buttbutter: What's the pinnacle of beautiful Haskell to you?
15:35:57 <buttbutter> geppettodivacin: Really readable. 
15:36:12 <buttbutter> From what I can tell, I think it's largely dependent on having the proper abstractions.
15:39:24 <geppettodivacin> That's true. I don't know how much more you could abstract things away in your code. It could probably be done, but at the cost of a lot of added complexity elsewhere.
15:40:15 <geppettodivacin> If there is a way, I'd like to know it, too. I'm working on similar code for a Machine Learning class.
15:40:46 <geppettodivacin> Technically k-means instead of k-nearest-neighbor, but similar.
15:41:11 <buttbutter> Ah, cool. I actually think Data.Vector might've been a bad choice.
15:41:43 <buttbutter> A friend recommended that I use https://hackage.haskell.org/package/repa. Not necessarily for performance, but correctness.
15:42:02 <buttbutter> But I took a glance at it and the types seem super daunting :P
15:42:08 <MarcelineVQ> iirc repa enforces dimensions at the type level?
15:42:16 <Tuplanolla> Don't worry, buttbutter. It's fun.
15:42:53 <Tuplanolla> Shape, not dimensions, MarcelineVQ.
15:43:17 <buttbutter> What's Shape?
15:43:48 <EvanR> 1D 2D 3D
15:44:22 <Tuplanolla> How many times you can fold until the array becomes degenerate.
15:45:06 <buttbutter> Degenerate?
15:45:15 <Tuplanolla> A point basically.
15:45:19 <Tuplanolla> You can still access things out of bounds.
16:01:07 <lpaste> MarcelineVQ annotated “No title” with “buttbutter: conservation of let” at http://lpaste.net/6133010778095091712#a348799
16:04:30 <Tuplanolla> I just realized the problem in the integer root. My approach was completely backwards. It suffices to see that `integerRtUp k (n + 1) == integerRt k n + 1`.
16:06:45 <orion> Would it be accurate to consider the STG machine to be platform independent?
16:07:46 <Cale> orion: yes
16:08:24 <orion> Is it possible in theory for an STG machine to be serialized?
16:09:09 <c_wraith> I'd count the compiled program as a serialized STG machine.. 
16:13:37 * hackagebot NMap 0.12 - A transparent nested Map structure  https://hackage.haskell.org/package/NMap-0.12 (ACastello)
16:19:31 <kadoban> So here's a dumb question: is there a way to write a pure value that will *always* just run forever? No other bottoms possible, it just evaluates for eternity?
16:20:04 <Koterpillar> that's a bottom
16:20:06 <c_wraith> sure. 
16:20:22 <c_wraith> just use any undecideable problem. 
16:21:09 <c_wraith> attempt to calculate the percentage of terminating Turing machines, or something. 
16:21:32 <kadoban> Hmmm
16:21:51 <kadoban> Koterpillar: Right, no *other* bottom though, I don't want error "<<loop>>" or anything, just sitting there and doing nothing.
16:22:25 <orion> kadoban: https://wikimedia.org/api/rest_v1/media/math/render/svg/89754b8aed0f96fcf0f3096885396eed51044eb0
16:22:51 <Koterpillar> well, that depends on the compiler
16:23:04 <kadoban> c_wraith: That's a good idea. Wonder what the simplest way to write something like that is.
16:23:28 <Koterpillar> kadoban: once you write it, GHC can hypothetically learn to recognize your way of doing it
16:24:22 <kadoban> Hmm, that's true isn't it.
16:28:15 <barrucadu> kadoban: A really simple one? `last [1..]`
16:28:52 <kadoban> barrucadu: You fairly confident that no GHC version or flags will make GHC recognize that and care?
16:29:29 <kadoban> It's not that important, but it'd be amusingly useful for something dumb I'm doing.
16:29:41 <barrucadu> I'm pretty confident
16:29:51 <barrucadu> <<loop>> is for when GHC detects a value is self-referential while evaluating it
16:30:22 <kadoban> Thanks
16:30:31 <barrucadu> Out of curiosity, what's this for?
16:31:12 <kadoban> Programming contest site, haha. It'd be nice to know when I've hit an "impossible" case in my code that I specifically mark instead of just outputting an invalid answer.
16:31:40 <ertes> kadoban: runST (forever (pure ()))
16:31:51 <ertes> kadoban: filter even [1,3..]
16:31:55 <MarcelineVQ> kadoban: you can put a rewrite rule in for it
16:32:04 <glguy> last (repeat ())   seems to work pretty well
16:32:07 <ClaudiusMaximus> perhaps  last (repeat ())  would be better, to avoid using more and more memory with larger and larger Integer (it still consumes CPU, but it might end up causing issues if ghc optimizes it to a non-allocating (and thus non-yielding) loop)
16:32:15 <MarcelineVQ> kadoban: wait I should read farther hehe
16:32:34 <pacak> :t fix id
16:32:36 <lambdabot> a
16:32:38 <ertes> the problem is:  even if GHC doesn't recognise the infinite loop today, it might in version 8.2 or 12.6
16:32:51 <kadoban> Right, some of those are super cute.
16:32:53 <ertes> runST (forever (pure ()))  -- this one should always be an infinite loop though
16:33:06 <ertes> and it's also fully polymorphic
16:33:10 <kadoban> :t runST (forever (pure ())
16:33:11 <lambdabot> error:
16:33:12 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
16:33:18 <kadoban> :t runST (forever (pure ()))
16:33:20 <lambdabot> a
16:33:39 <kadoban> Nice, ya I think I like that one best.   last (repeat ()) is super cute too, though the type is a bit unfortunate.
16:33:57 <ertes> last (repeat undefined)
16:34:08 <kadoban> Oh hah, ya.
16:34:26 <kadoban> Thanks for the surprisingly helpful answer, I expected more people to yell at me xD
16:34:30 <kadoban> answer(s)
16:34:37 <orion> Would it be possible in theory to serialize and transfer unevaluated thunks to remote machines for execution?
16:34:42 <ertes> kadoban: out of curiosity: for what?
16:35:10 <kadoban> ertes: Well, I probably still have PTSD from long stretches of visiting ##C and ##C++ in the old days, and it's a fairly dumb/useless question.
16:37:57 <MarLinn> Isn't CloudHaskell pretending to do something like that?
16:38:26 <MarLinn> orion ^
16:39:04 <ertes> MarLinn: nope
16:39:32 <ertes> it marks certain IO actions with names, and then tells other processes: "execute the action with this name"
16:39:50 <ertes> ("… and these args, and give me the result")
16:40:30 <ertes> orion: values in haskell don't have memory identity, so what you're asking for is semantically…  weird
16:41:07 <ertes> you can make it work by abusing GHC's sharing, but it's even weirder than observable sharing
16:41:33 <ertes> in any case you need IO for that and you would get absolutely no guarantees as to what the behaviour is
16:43:10 <unskill> we all know that partial derivative of a type gives us a context in zipper for the type. did anybody studied the second derivative?
16:44:45 <Apocalisp> Can I use a `Traversal s t a b` to collect all the `b`s in the `s`?
16:45:51 <pacak> >  toListOf each (1,2,3)
16:45:54 <lambdabot>  [1,2,3]
16:47:45 <ertes> Apocalisp: all the 'a's rather
16:48:07 <pacak> Apocalisp: No.
16:49:59 <unskill> e.g. the second derivative of a list gives us 2*L(x)³, which makes sence. L³ is a triple of lists (xs,ys,zs) and '2' points to the first or secod comma (hole) between lists.
16:50:53 <unskill> but it seem to me that the middle list should be double-linked
16:51:08 <unskill> i.e. accessible from both ends
17:03:51 <orion> What is memory identity?
17:04:09 <orion> Is that some copy-on-write kind of thing?
17:11:08 <nshepperd> I think that means being able to ask if two objects are the same (not just equal)
17:11:13 <nshepperd> pointer equality
17:15:29 <nshepperd> to serialize a thunk, you'd basically have to unpack it and serialize all of the captured values, then send the code pointer across
17:15:36 <slack1256> what is the byte output that ghci gives with the :set +s option?
17:15:57 <nshepperd> problem is the type information of the captured values is erased at that point, so you have no idea how to serialize them
17:16:03 <slack1256> the memory used to get the expression or the one needed to store it?
17:17:36 <c_wraith> slack1256, total allocated in the process. 
17:17:42 <c_wraith> slack1256, not max resident 
17:17:43 <slack1256> got it
17:17:48 <nshepperd> so anyway you probably do want CloudHaskell or something like it, which solves this problem by not trying to send actual thunks
17:18:39 * hackagebot gnss-converters 0.2.1 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.2.1 (markfine)
17:28:15 <chachi> dibblego: I'm not here to bug you today. :)  I found the problem, it was in my instance Applicative Parser where I had (<*>) pF pA = pA `flbindParser` (\a -> pF `flbindParser` (\f -> valueParser (f a))).  Typechecks but runs backwards.  You must have asked me about it, and I must have been looking in the wrong place.  Sorry and thanks!  Just wanted to close the loop.
17:30:23 <dibblego> chachi: no worries, I knew it was a backwards Applicative/Monad somewhere :)
18:12:14 <juliench1rch> Does anyone here work for Jane Street?
18:20:10 <mnn_> I have a question from HaskellBook that should be relatively straightfoward if anyone has a moment. Ord a) allow any two values to be compared OR b) is a subclass of Eq
18:20:29 <mnn_> I think it's a subclass of Eq, but someone online who wrote up their answers said the (a)
18:20:35 <mnn_> If anything, both seem true
18:23:06 <systemfault> mnn_: The easiest way to see that by yourself is to open ghci and type:     :info Eq then press enter and scroll at the beginning of whatever appears
18:23:06 <c_wraith> mnn_: it depends on the definition of "any"
18:23:32 <c_wraith> > compare (+1) (*2)
18:23:35 <lambdabot>  error:
18:23:35 <lambdabot>      • No instance for (Ord (a0 -> a0)) arising from a use of ‘compare’
18:23:35 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
18:23:36 <mnn_> c_wraith, Yes, that was what was confusing. I assume it's the subclass, since that is clearly true (by the calss definition)
18:24:03 <mnn_> I guess they used the term any to be "too broad"
18:24:08 <mnn_> systemfault, c_wraith thanks
18:24:23 <c_wraith> mnn_: It's not too useful to think of "subclasses" in haskell.  I mean, yes, Ord is a subclass of Eq, but that doesn't have anything to do with subclasses in an OO language
18:24:43 <c_wraith> mnn_: It's more useful to think of it as any type which has an Ord instance is required to have an Eq instance
18:24:59 <c_wraith> mnn_: But instances are a property of types, not types themselves.
18:39:39 <mnn_> What would an example of a RealFrac be? Are all Fractionals not already real? (or are there complex fractionals)
18:41:16 <c_wraith> mnn_: have you looked at the class definition? https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:RealFrac
18:41:35 <mnn_> I looked at :info, looking at the full definition now
18:42:21 <riaqn> Hi, how do I express in a record type definition that , one of the field is a type satisfying a class?
18:42:33 <c_wraith> mnn_: The class definition makes it look like it's specifically for operations that only make sense on types that rest on the real number line.
18:42:42 <Koterpillar> riaqn: using forall?
18:42:53 <riaqn> say, data A = A { a :: x, b :: y}, where I require the x type satisfy class X.
18:43:04 <riaqn> Koterpillar: hmm, any link I can look into?
18:43:06 <mnn_> c_wraith, I'm a bit confused about what a RealFrac looks like. I get an error on 1.0 :: RealFrac, for example
18:43:09 <Koterpillar> riaqn: why not let the operations on this structure require the constraint?
18:43:25 <c_wraith> mnn_: that's because classes aren't types
18:43:36 <Koterpillar> data A x = A { A :: x, B :: Int }
18:43:37 <mnn_> Oh doh
18:43:39 <c_wraith> mnn_: classes are properties a type can have.
18:43:56 <Koterpillar> work_on_a :: Show x => A x -> String
18:44:00 <Koterpillar> riaqn: ^
18:44:09 <Koterpillar> riaqn: look at Data.Map.Map for an example
18:44:12 <mnn_> c_wraith, Thanks; so 1.0 :: RealFrac a => a
18:44:35 <c_wraith> riaqn: why do you want to do that?  In general, it causes more problems than it solves to try to do that.
18:44:49 <riaqn> Koterpillar: I was thinking maybe gadt can do that.
18:45:05 <riaqn> c_wraith: hmm, do you have alternative approach?
18:45:19 <c_wraith> riaqn: it depends on what you're actually trying to do.
18:45:40 <Koterpillar> riaqn: yeah, that ^
18:46:35 <riaqn> nevermind: https://wiki.haskell.org/Data_declaration_with_constraint 
18:46:39 <c_wraith> mnn_: yeah, numeric literals containing a decimal point are polymorphic over all members of the RealFrac class.
18:47:13 <Forty-Bot> Hi, I'm implementing dual numbers as an exercise (http://paste.fedoraproject.org/495314/48064662/), but I'm unable to implement NumericPrelude.Vector.C: http://paste.fedoraproject.org/495315/64671814/
18:48:25 <c_wraith> Forty-Bot: your type is named T.  numeric-prelude must be a Henning Thielmann library
18:48:32 <Forty-Bot> at this point, I'm not sure a Vector implementation makes sense logically for dual numbers
18:48:45 <Forty-Bot> c_wraith: I'm just copying the style I saw there
18:48:56 <Forty-Bot> but I'd like to figure out the error anyway
18:49:24 <c_wraith> Forty-Bot: I was just joking that he's the only one who uses that style. No worries on that remark. :)
18:49:50 <c_wraith> Forty-Bot: that message is telling you that the instance must be declared on the type T, not the type (T a)
18:50:04 <Forty-Bot> why is that?
18:50:18 <c_wraith> Forty-Bot: I have no idea.  I don't know what's in the class.  :)
18:50:40 <Forty-Bot> here's the documentation: http://hackage.haskell.org/package/numeric-prelude-0.4.2/docs/Algebra-Vector.html
18:50:55 <c_wraith> Forty-Bot: One of the main ideas in Haskell is that type constructors can be used without all of their arguments.
18:51:13 <c_wraith> Forty-Bot: that's what's often called "Higher-kinded types"
18:51:39 <Forty-Bot> right, but zero and <+> require a to be Additive, while *> requires a to be a Ring
18:52:30 <c_wraith> Forty-Bot: the definition of Algebra.Vector.C doesn't allow instances that depend on the type argument being applied.
18:53:15 <c_wraith> Forty-Bot: Other than the requirements in (<+>) and (*>), that is, since those requirements are part of the class, not an instance
18:53:27 <c_wraith> Oh, Zero has a constraint too.
18:53:44 <Forty-Bot> oh, is it because teh Additive/Ring requirements are in the type of the class?
18:54:01 <c_wraith> They're in the types of the individual members of the class, anyway
18:54:57 <c_wraith> Forty-Bot: The upshot of the way that class is written is that you can't define instance of Algebra.Vector.C (T Int) and Algebra.Vector.C (T Double) that work differently.
18:55:14 <Forty-Bot> ah, ok
18:55:24 <c_wraith> Forty-Bot: instead, you have to write one instance for just the type T
18:55:38 <Forty-Bot> I was getting confused because just T was giving an error
18:56:04 <c_wraith> Forty-Bot: are you familiar with the kind system?
18:56:10 <Forty-Bot> which appears to be because *> is defined twice, once in Algebra.Vector, and once in Algebra.Module
18:56:19 <Forty-Bot> c_wraith: ...maybe?
18:56:25 <c_wraith> Forty-Bot: Ah, yes.  Have to import more carefully.
18:56:42 <Forty-Bot> well, I was testing it out in ghci
18:56:52 <Forty-Bot> :P
18:56:54 <c_wraith> Forty-Bot: kinds are the types of types.  The type (T Int) has the kind *.  The type T has the kind * -> *
18:57:18 <Forty-Bot> ah, ok
18:57:55 <c_wraith> Forty-Bot: you can define types with crazy kinds like..  ((* -> *) -> *) -> (* -> *) -> *
18:58:07 <c_wraith> I have no idea why I'd do that, but maybe it'd come up sometime.
18:58:35 <c_wraith> Forty-Bot: well, it turns out that all values must be of types that have the kind *
18:58:53 <c_wraith> Forty-Bot: so if you use that, you can derive kinds of type variables from how they're used.
18:59:53 <c_wraith> Forty-Bot: Algebra.Vector.C, for instance, uses the type variable v in a way that means it can't have kind *.  It must be something -> *
19:00:08 <Forty-Bot> so * -> *
19:00:34 <c_wraith> Forty-Bot: the types don't actually require that, but it requires turning on a bunch of ghc extensions to make it anything else. :)
19:02:14 <c_wraith> Forty-Bot: in any case, it means (T a) can't be an instance, because it has kind *.  And that's what the error message was trying to tell you.
19:05:59 <slack1256> any good package for convex optimization?
19:07:51 <hodapp> slack1256: glpk-hs may be able to do it. hmatrix-glpk has some nasty subtle bugs.
19:08:22 <slack1256> bindings! great!
19:11:03 <hodapp> oh, man, that was a horrid project
19:11:15 <hodapp> I was to the point that I was about to implement the simplex algorithm from scratch
19:11:28 <hodapp> and luckily glpk-hs wasn't that hard to transition to
19:11:37 <c_wraith> How hard could it be?  it's got simple right in the name?
19:11:56 * hodapp throws a fountain pen at c_wraith
19:12:13 <c_wraith> Ooh, I always wanted one of these.
19:12:22 <slack1256> Mmm I wonder if they still just support Linear programming.
19:12:29 <slack1256> Some stabs at convex problems would be great
19:12:48 <hodapp> it goes past linear programming but I'm not sure how far past
19:13:09 <hodapp> the fact that I don't have a clear grasp on what convex optimization means isn't helping me
19:14:06 <peddie> slack1256: you can use the `levmar` package; you can use `ipopt-hs` which has lower-level bindings to IPOPT and NLOPT, both freely available; if you don't need constraints, hmatrix-gsl has several solvers; you can also use SNOPT, IPOPT or (I think?) NLOPT via the DYNOBUD package
19:14:24 <hodapp> yeah, hmatrix-gsl is fine, just steer clear of hmatrix-glpk
19:15:43 <peddie> slack1256: regarding your second question, GLPK can do mixed-integer linear programming as well I believe
19:15:57 <slack1256> hodapp: convex set instead of linear spaces. They follow the rule that if @a and @b belong to a convex set C, then forall @l in [0,1], the vectors @(l a + (1 - l) b) also must belongs to the convex set C
19:16:35 <hodapp> oh, hmmmm
19:17:01 <slack1256> so they guarrantee that any line between two points in the set, stays in the set.
19:20:10 <hodapp> and then optimizing some objective under the constraint of convexity?
19:20:22 <peddie> hodapp: another way to think about convex optimization is that there is only one global minimum (or connected global minimum set)
19:20:34 <slack1256> yes, but you recover a lot of niceties of linear cases
19:20:35 <peddie> er
19:20:40 <peddie> I mean you don't have other local minima
19:20:58 <slack1256> as peddie say that is one characterization. Any local minima is a global minima 
19:21:15 <peddie> slack1256: thanks, I couldn't say it quite right :)
19:21:54 <slack1256> because you can prove that if a function is convex (which implies is continous) plus differenciable at least twice, then any stationary point is a minimum because its second order differential is SDP
19:22:18 <peddie> slack1256: if your problem is really big, I encourage you to check out DYNOBUD -- it will calculate Jacobians and Hessians for you with the CASADI automatic differentiation package and interface to a variety of solvers
19:22:29 <slack1256> well not really convexity implies continuity, only if it is bounded + is defined on a open domain
19:23:12 <slack1256> then you can use an argument as in linearity function + bounded implies convexity
19:23:21 <slack1256> *continuity
19:24:30 <slack1256> the numpy community has spawned a good chunk of software, thanks for the recomendarion peddie
19:25:16 <slack1256> wait, dynobud is written in haskell!
19:25:24 <peddie> slack1256: yeah dawg, of course
19:25:44 * peddie checks the channel
19:26:00 <dmj`> profiteur is awesome for profiling
19:32:51 <mmaruseacph2> if you know what you're looking for
19:32:57 <mmaruseacph2> I also used ghc-flamegraph
19:33:39 <jmorris> how do i get String n from a list of strings
19:34:04 <jmorris> ie. ["abc", "def", "ghi"] , n = 2 -> "def"
19:34:34 <systemfault> ["Hi", "Lol"] !! 1  is "Lol"
19:34:46 <slack1256> > ["abc", "def"] !! 2
19:34:48 <hodapp> :t (!!)
19:34:49 <lambdabot>  "*Exception: Prelude.!!: index too large
19:34:50 <lambdabot> [a] -> Int -> a
19:34:53 <slack1256> heh
19:34:54 <slack1256> > ["abc", "def"] !! 1
19:34:57 <lambdabot>  "def"
19:35:21 <slack1256> I-i didn't get i-it wrong!11!, I wanted to S-show it was partial!111
19:35:29 <slack1256> *sweats*
19:35:34 <jmorris> ok thanks lol
19:36:13 <hodapp> slack1256: so would you say you were... partially right?
19:36:15 <ogkloo> Anyone know how to use the random library?
19:37:54 <slack1256> ogkloo: could you be more specific on the problem?
19:38:05 <slack1256> ie what fails, what works
19:38:41 <ogkloo> I'm mostly just lost on even getting started on it. Not sure how to get a random number generator.
19:39:48 <jmorris> ogkloo: I've used it before
19:40:02 <jmorris> ogkloo: which function are you having trouble with
19:40:45 <ogkloo> I can't find any examples on how to get started with it. Is it like Python where you have to create a generator for it first?
19:41:26 <jmorris> ogkloo, I think getStdGen needs to be used in IO
19:41:32 <jmorris> there are some examples here, http://learnyouahaskell.com/input-and-output
19:41:42 <ogkloo> thanks, I'll try that
19:42:31 <slack1256> > newStdGen >>= \seed1 -> let (val1, seed2) = next seed1 in return val1 
19:42:33 <lambdabot>  <IO Int>
19:42:44 <slack1256> lambdabot doesn't accept do notation, right?
19:44:04 <Koterpillar> :t randomRIO
19:44:05 <lambdabot> Random a => (a, a) -> IO a
19:45:07 <Koterpillar> slack1256: it did, was just afraid to execute the action, I guess?
19:45:23 <hodapp> > random $ mkStdGen 12345
19:45:30 <lambdabot>  (7342264595514404010,980569070 2103410263)
19:46:16 <slack1256> he should be, otherwise we would have to deal with letters of a bot saying on the web "launch_missiles" every 5 min
19:48:55 <martinium> anyone have a list of projects that one could do in Haskell from super noob to advanced to build skill?
19:50:54 <hodapp> write a Scheme interpreter!
19:52:31 <lordcirth> I was considering writing a Markov chain text generator as an intermediate project
19:53:45 * hackagebot turtle 1.3.0 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.3.0 (GabrielGonzalez)
19:57:05 <LordBrain> i second the markov chain, we already have a scheme written in haskell
19:57:32 <slack1256> try to write a parser with attoparsec
19:57:34 <LordBrain> if you're going to write an interpretted language in haskell just to learn, i suggest forth not scheme
19:58:24 <LordBrain> oh nvm thats done too
19:58:30 <LordBrain> https://github.com/ezag/harrorth
19:58:38 <LordBrain> well
20:20:17 <Dacto> I'm trying to: partition doesFileExist [<FilePaths>] . I ended up writing a partition to work with an (a -> IO Bool) but was wondering is there is a nicer way
20:22:16 <lpaste> BaneAliens pasted “simple hello world” at http://lpaste.net/348850
20:22:36 <BaneAliens> oh whoa didn’t know it would post in the channel
20:23:10 <BaneAliens> I’m getting a syntax error on line 3, is that not how you are suppose to do actions for one guard?
20:23:51 <glguy> BaneAliens: you'll need to line up the two statements in your do notation
20:24:31 <glguy> and the second do is unnecessary
20:25:23 <lpaste> glguy annotated “simple hello world” with “simple hello world (annotation)” at http://lpaste.net/348850#a348851
20:25:53 <BaneAliens> ohh so it has to be under the “p” in print
20:26:28 <glguy> dacto: a partition function that works with an arbitrary Monad instance sounds fine
20:26:34 <BaneAliens> thanks glguy 
20:27:22 <glguy> https://hackage.haskell.org/package/extra-1.5.1/docs/Control-Monad-Extra.html#v:partitionM
20:27:26 <glguy> for example
20:27:42 <Dacto> glguy: ah ok - i was scratching my head for a while to figure a more elegant way to make the standard partition work
20:27:50 <Dacto> oh no..one exists already!
20:28:04 <Dacto> crap - not sure why i didnt see that earlier. Doh.
20:28:18 <glguy> just showing an existing example
20:28:31 <glguy> I'm not recommending a dependency
20:28:44 <Dacto> Oh nice, mine is almost like that one :)
20:29:13 <Dacto> Thanks for the pointer though... I actually didnt know this lib existed - some cool stuff in here
20:48:47 * hackagebot itemfield 1.2.1.0 - A brick Widget for selectable summary of many elements on a terminal  https://hackage.haskell.org/package/itemfield-1.2.1.0 (KevinQuick)
20:58:32 <bollu1> join ##math
20:58:42 <monochrom> no thanks
20:58:57 <bollu1> xD morning :)
21:06:42 <kosh> Hey, please help me with gloss. I started new project with stack, then add gloss as dependece in cabal file, then "stack bulild" and I am getting "* Missing C library: GLU". I did install freeglut in arch linux
21:06:54 <kosh> but it still not building
21:07:34 <kosh> here is the error http://paste.ofcode.org/dgpf9QFrAejXgcTq8pF5ng
21:08:22 <kosh> should I indicate where the libglut.so is? (it is in /usr/lib)
21:08:48 * hackagebot itemfield 1.2.2.0 - A brick Widget for selectable summary of many elements on a terminal  https://hackage.haskell.org/package/itemfield-1.2.2.0 (KevinQuick)
21:10:03 <pacak> kosh: freeglut-dev?
21:10:57 <glguy> you might need to install libGLU then
21:11:02 <kosh> there is no such package in archlinux
21:11:22 <kosh> let me check libGLU
21:11:22 <glguy> then you'll need to figure out which package it's in
21:12:06 <kosh> em it is "glu" ...
21:12:09 <glguy> you'll have to match all the letters and case, 
21:12:10 <kosh> =D
21:12:18 <kosh> all is building
21:12:19 <glguy> so libglut won't cut it
21:38:49 * hackagebot countable-inflections 0.2.0 - Countable Text Inflections  https://hackage.haskell.org/package/countable-inflections-0.2.0 (tippenein)
21:53:25 <sssilver> why do so many programmers place so little value in the type system and everything associated with it :((((
21:53:28 <sssilver> it almost insults me
21:53:46 <sssilver> most programmers view it as some kind of a language artifact
21:54:04 <sssilver> most jobs will just give you some algorithm puzzle
21:54:37 <sssilver> yet 8 hours a day on that job you won't be solving freaking puzzles
21:55:04 <sssilver> you'll be building systems where the types will be the #1 factor of code quality
21:55:29 <sssilver> I feel desperate >.<
21:56:08 <nshepperd> many type systems are rubbish
21:56:32 <ngWalrus> and then there's javascript
21:56:43 <systemfault> Tons of people think that "Type system" == "Like Java" :/
21:59:46 <nshepperd> I can't really blame programmers for being less than enthused by them
22:03:00 <ngWalrus> It'd be easier to be more enthusiastic about type systems if they were better
22:16:38 <EvanR> when youre in the business of coming up with brand new type systems to express particular things, then theres no java to blame, and you can be however enthusiastic as you want. producer vs consumer mentality
22:19:57 <haskell009> using {-# LANGUAGE GeneralizedNewtypeDeriving #-}, I have newtype P1 = P1 (Int, Int) deriving (Bifunctor). And I have this error Cannot derive well-kinded instance of form ‘Bifunctor (P1 ...)’         Class ‘Bifunctor’ expects an argument of kind ‘* -> * -> *’     • In the newtype declaration for ‘P1’
22:20:12 <haskell009> aaaand I don't really know how to fix it
22:20:32 <haskell009> I just want to use the bifunctor instance of (,) without having to retype it
22:22:49 <mnn_>  
22:23:45 <julienchurch> I feel a little spammy asking this, but is anyone currently working with Haskell professionally/willing to entertain questions about Haskell in industry?
22:23:46 <glguy> haskell009: A Bifunctor instance doesn't make sense for P1
22:24:15 <glguy> julienchurch: It's always better to just ask your actual question
22:26:00 <haskell009> glguy, so there is no way to use it with my instance?
22:26:18 <haskskull> Hello guys, I am going through Haskell's indentation rules on wikibooks.org (https://en.wikibooks.org/wiki/Haskell/Indentation), and something that I don't quite understand is this:
22:26:21 <haskskull> if foo    then do first thing         second thing         third thing    else do something_else
22:26:33 <haskskull> uh. How do nvm. Doesn't get pasted correctly. 
22:26:43 <glguy> haskskull: You can paste to lpaste.net
22:27:07 <glguy> haskell009: No, it can't be an instance, it doesn't have the right kind, you wouldn't be able to typecheck a use of first or second with P1
22:27:15 <julienchurch> Well, I'm specifically interested in what people are doing and in interview processes.
22:27:17 <glguy> :t first
22:27:19 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
22:27:22 <lpaste> haskskull pasted “wrong indentation” at http://lpaste.net/348867
22:27:33 <haskskull> Woah this is cool. :D
22:27:34 <glguy> :t Data.Bifunctor.first
22:27:36 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
22:27:42 <haskskull> Okay, so, I don't understand how that indentation is wrong.
22:27:52 <glguy> haskell009: See how there's no place for P1 to fit into that type signature?
22:28:06 <haskell009> oh yeah
22:28:11 <haskell009> you're right
22:28:15 <glguy> haskskull: line up first and and second and third
22:28:25 <glguy> haskskull: Don't line up second with do
22:28:30 <haskskull> The wiki says that the indentation of the block occurring inside the do should be indented a bit more than the line having do.
22:28:40 <julienchurch> Let me try again. For anyone that uses Haskell/FP in their day job, where do you work, what were the qualification requirements, and what was the interview process like?
22:28:52 <haskell009> anyway thanks glguy :)
22:29:21 <haskskull> haskskull: that's what I'd do naturally, however, I don't understand why the given one is wrong.
22:29:44 <lpaste> haskskull pasted “right indentation?” at http://lpaste.net/348868
22:29:52 <haskskull> For example, this is said to be correct.
22:29:58 <glguy> haskskull: Yeah, that would work
22:30:12 <AbelianGrape> I'm sorry, but who the hell thought GHC supporting un-importable "hidden modules" was a good idea? This is an *extremely* user-unfriendly feature. It should *not* be up to a package maintainer which bits of code I can or can't use. Is there any way to override hiddenness without creating my own version of the package without the module being hidden (creating 10x the amount of work for myself)?
22:31:03 <glguy> AbelianGrape: No, there's no general way to unhide modules like that
22:31:15 <haskskull> glguy: which one would work? The second one? The wiki says it does, however, if that works, why doesn't the first one?
22:31:22 <AbelianGrape> Christ. This is actually the worst thing I've ever come across in years of using Haskell
22:31:36 <glguy> haskskull: the token *after* the do determines the indentation level of the block
22:32:34 <haskskull> glguy: Oh. So whatever should be within 'do' should be at the same indentation level as the token immediately after 'do'. Am I right?
22:32:41 <glguy> yeah
22:32:58 <haskskull> Okay. I got it. Thanks!
22:33:04 <AbelianGrape> Aaaand the package manager's website 404s, so there's no way to contact him. Awesome
22:33:08 <dmj`> AbelianGrape: to which package are you referring? It’s usually up to the package maintainer to expose the correct interface.
22:33:41 <dmj`> if you have to access a hidden module, it might not be the intended way of using the library
22:34:20 <AbelianGrape> dmj`: That would be great if A) the package manager's contact info works (it 404s) and B) if I was OK with waiting days or weeks it usually takes anything to change anything in an open-source project, and then I'd have to wait months for stack to support it in a new resolver or I'd have to manually add the hackage version. *terrible* all around
22:35:16 <AbelianGrape> Having "internal" in the name should be enough to ward people off. This is not the sort of thing that should be enforced by the compiler; it has nothing to do with correctness. This simply limits the number of productive things one can do
22:35:25 <AbelianGrape> the package is bitcoin-api
22:35:29 <dmj`> AbelianGrape: which package? afaik stack will let you refer to a fork in your stack.yaml 
22:35:50 <AbelianGrape> I want to use the "Internal" module, which has a pleasantly generic "call" function that is not exported for some reason
22:36:12 <glguy> AbelianGrape: The "issues" link for that package works, so you can file an issue there if you want to bring it up with the maintainer
22:36:38 <AbelianGrape> Last updated: a year ago
22:36:44 <AbelianGrape> I don't think this guy is around
22:37:09 <AbelianGrape> And again, I can't wait until this dude gets around to fixing it
22:37:18 <glguy> Or the package is working fine and hasn't needed work recently. Asking on the issue tracker is going to be more productive than complaining on #haskell
22:37:22 <AbelianGrape> Realistically, this is just creating several hours of inconvenience for me for no reason
22:37:44 <AbelianGrape> I'm complaining about the stupid-ass decision to allow package maintainers to disable external access to packages, not about this module
22:39:02 <AbelianGrape> The module works fine as far as I'm concerned. The thing that's broken is that GHC is intentionally crippled, which is the most rage-enducing thing someone can do to a technology
22:40:13 <chreekat> AbelianGrape: sounds frustrating, but I'm pretty sure the problem here started when you chose to depend on an unmaintained, out of date library. Allowing encapsulation is hardly a bug in GHC, that's just good engineering. All engineering tools need to be applied judiciously, of course, and maybe this old, out of date library did not do that.
22:41:17 <chreekat> but i feel your pain
22:42:14 <AbelianGrape> chreekat: "Encapsulation" is not a valid excuse for needlessly bricking correct, well-defined, and manifestly useful ways of using code
22:42:51 <AbelianGrape> There's nothing wrong with the library except that GHC doesn't give me the power to do something that is technically feasible
22:44:03 <AbelianGrape> GHC even supports "unsafePerformIO" and "unsafeCoerce", which ignore the most fundamental aspects of program safety, because it's useful for getting things done at a low level. I'm not even asking for GHC to let me do something dangerous; I'm asking for it to let me do something very straightforward and sensible that requires *less* effort than preventing me from doing it in the first place
22:44:36 <AbelianGrape> Someone spent time making GHC *less* useful, not more useful. Absolutely infuriating
22:44:37 <dmj`> AbelianGrape: it seems like it’s internal because it’s technically an unsafe function. He could have used type families here to associate the ToJSON instance and FromJSON instance in call, do you really need the entire api or just a few functions?
22:45:16 <jle`> hey, isn't Data.Map.Map a good implementation of a priority queue
22:45:32 <AbelianGrape> dmj`: The worst it could do is throw an exception. I need to support calls that don't have functions defined in this library
22:47:17 <AbelianGrape> Instead of just defining a few To/FromJSON instances and using "call", I'm probably just going to end up copy/pasting the relevant code into my own project and re-implementing a lot of stuff without the benefit of well-engineered newtype wrappers :/
22:47:40 <sleeptalics> hello
22:47:55 <sleeptalics> does anyone have the time to walk me through installing a cabal package?
22:48:13 <sleeptalics> it has a dependency error but its a clean install
22:48:24 <sleeptalics> not really sure what to do
22:49:02 <dmj`> AbelianGrape: you probably should anyways, his code is doing a putStrLn on every request
22:49:05 <glguy> sleeptalics: Best to just ask your question than to wait for someone to bite
22:49:20 <AbelianGrape> dmj`: That is true, that's not a good sign
22:49:43 <sleeptalics> i'm just trying to install "grapefruit-frp" but it has some sort of clash with "semigroups"
22:50:43 <dmj`> AbelianGrape: was probably just for debugging
22:51:57 <glguy> sleeptalics: That package hasn't been updated since 2014; it isn't compatible with the current versions of the semigroups package
22:52:06 <dmj`> jle`: psqueues might be better
22:52:32 <jle`> maybe, but under what circumstances?
22:53:07 <sleeptalics> so...
22:53:10 <sleeptalics> impossible to install?
22:53:24 <sleeptalics> it looks like there's some sort of impossible to resolve dependency cycle
22:57:38 <dmj`> jle`: hmm, well findMin/findMax call bottom if they don’t exist in Data.Map, and are O(log n), findMin in psqueues is O(1) for IntPSQ
22:57:50 <dmj`> I guess there is minView in Data.Map
22:58:34 <jle`> oh ah popping is log n for Map
22:58:42 <glguy> sleeptalics: It looks like your options are to update the package, ask the maintainer to, or try building with GHC 7.8 or possibly 7.6
22:58:43 <jle`> i guess that's it
22:58:53 <glguy> but 7.10 is too new for the set of dependencies that that package uses
22:59:51 <sleeptalics> hm
23:00:03 <sleeptalics> i'm gonna find another package
23:00:12 <sleeptalics> its having its own set of problems
23:00:18 <sleeptalics> i'll look into it tomorrow i think
23:00:24 <sleeptalics> thanks for your help glguy 
23:01:39 <dmj`> never knew while your program is profiling, you can copy the *.hp file and snapshot the heap
23:13:43 <mnn_> I'm a bit confused about how :sprint can be used with infinite structures. Are any parts of an infinite list ever held in ghci as evaluated?
23:14:25 <mnn_> For example, I can say blah = [1..10], then :sprint blah -> blah = _, but if I print blah, it's [1,2,..10]
23:14:56 <mnn_> Is it a similar case with infinite lists? As far as I can tell it didn't appear so
23:17:49 <Vyn> ##math [11:58:10] <MotivicScones> so, what's purple and commutes?      #haskell [11:59:47] <AbelianGrape> I'm sorry, but who the hell thought GHC…
23:17:54 <glguy> mnn_: it's the same, only a finite prefix of the infinite list can ever be evaluated, the rest will be a thunk awaiting later evaluation
23:19:58 <mnn_> glguy, I might need to read more still, but they why does this result: blah = [1..]; print $ take 5 blah; :sprint blah -> blah = _ (as opposed to :sprint blah -> blah = [1,2,3,4,5])?
23:21:16 <nshepperd> mnn_: did you remember to monomorphize blah?
23:21:21 <nshepperd> :: [Int] or so
23:21:27 <pikajude> is it possible to write an async/future effect for the free-vl implementation of the van laarhoven free monad?
23:21:31 <pikajude> This is escaping me at the moment
23:21:39 <glguy> mnn_: try that with blah having a non polymorphic type
23:21:46 <mnn_> nshepperd, Don't know what the means, so I assume I have to continue reading to understand
23:22:11 <mnn_> Oh wait, I know what that means
23:22:20 <mnn_> I think the type of the list right now is Num a => [a]
23:22:27 <nshepperd> yes, just so
23:22:43 <glguy> you're discovering why the monomorphism restriction is useful
23:22:55 <nshepperd> it's secretly a function (Num a -> [a]) so any evaluation of it won't be shared
23:23:14 <mnn_> Ah, this makes sense. THanks nshepperd, glguy 
23:24:44 <nshepperd> interesting, :sprint hangs on 'cycle [1]' after I evaluate it
23:28:08 <nshepperd> like, I can define xs = cycle [1] :: Int, then evaluate it with 'take 2 xs', thereafter :sprint will hang
23:28:52 <mnn_> Yep yep (tried it and same result)
23:29:59 <mnn_> Could it have anything to do with the way it's defined (with (++))?
23:30:29 <glguy> it probably just doesn't produce lazy output
23:30:53 <glguy> and since the rendered version has no end you never see anything
23:32:13 <lonokhov> warp question. If I curl something without -H "Connection: close" I get exception "Warp: Client closed connection prematurely". How do I avoid getting that bogus exception?
23:33:05 <nshepperd> glguy: ah yeah, spose that makes sense
23:53:36 <tdammers> lonokhov: don't know, first guess would be you're sending a POST or PUT request with no content-length header
23:54:47 <tdammers> lonokhov: just a guess, but this is a common issue - when you do that, the server can't tell whether it has received the full response body, but the client thinks it can and closes the connection
23:56:59 <grantwu> I have a constant that looks like mconcat $ intersperse "\n" ["foo", "bar"]
23:57:13 <grantwu> I have overloaded strings on and the type annotation set to a bytestring builder
23:57:13 <lyxia> :t intercalate
23:57:15 <lambdabot> [a] -> [[a]] -> [a]
23:57:32 <lyxia> grantwu: intersperse is a list function
23:57:46 <lyxia> so it will infer the literals to be Strings
23:58:08 <grantwu> ?
23:58:11 <lyxia> OverloadedStrings overloads string literals
23:58:24 <lyxia> not arbitrary String-typed expressions
23:58:38 <grantwu> Yes
23:58:43 <lyxia> hmm
23:58:44 <grantwu> The elements in the list are all literals
23:58:49 <grantwu> So they are inferred as Bytestring builders
23:58:55 <lyxia> oh I see -_- nvm
23:59:02 <grantwu> Anyways, the issue is that I run into ghc: panic! (the 'impossible' happened)   (GHC version 8.0.1 for x86_64-unknown-linux): 	Simplifier ticks exhausted
23:59:15 <tdammers> the OverloadedXXX extensions are all really thin layers of syntax sugar, and they all cover literals only
23:59:25 <lonokhov> tdammers: no, I send GET. Idk if curl does http 1.0 or 1.1 by default. And response is sendfile.
23:59:44 <lyxia> my comment was irrelevant sorry
