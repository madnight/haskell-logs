00:05:21 <ongy> can the haskell FFI handle flexible array sizes? I'm not quite sure how to make the storable instance of https://freedesktop.org/software/pulseaudio/doxygen/structpa__channel__map.html (or do I have to do my own alloc/peek logic?)
00:07:40 * hackagebot lol-calculus 1.20160822 - Calculus for LOL (ª… language).  https://hackage.haskell.org/package/lol-calculus-1.20160822 (julm)
00:07:40 * hackagebot lol-typing 1.20160822 - Type inferencer for LOL (ª… language)  https://hackage.haskell.org/package/lol-typing-1.20160822 (julm)
00:08:00 <glguy> ongy: you'll have to do that allocation manually,
00:08:15 <glguy> also you won't be able to make a storable instance
00:08:44 <glguy> errrr, wait that array had a fixed size
00:09:01 <glguy> so scratch what I said
00:09:33 <ongy> oh, I should learn to read...
00:13:56 <pavonia> There are peek/poke versions for static and dynamic array sizes
00:50:13 <ongy> lists are a happy type. The prepend secions show it: (entry :)
00:57:35 * hackagebot hquantlib 0.0.3.1 - HQuantLib is a port of essencial parts of QuantLib to Haskell  https://hackage.haskell.org/package/hquantlib-0.0.3.1 (PavelRyzhov)
01:00:05 <ashishnegi> hi.. i am writing Tron game :) in haskell and elm ; server needs to serve static pages and websockets support .. which library should i use in haskell ?
01:22:42 <folsen> Anyone know if there's a good way to generate the boilerplate needed for Opaleye? I want to experiment a bit with it, but my tables have 30+ columns and don't want to write all the boilerplate necessary for that right now
01:26:34 <bjorn__> folsen, i suppose it's a editor trick, vim emacs or sublime etc has tools for that
01:27:17 <sshine> ashishnegi, hi. did you go through https://wiki.haskell.org/Web/Frameworks ? I'd probably go for Scotty or MFlow. Scotty because I know it and it isn't very complex, and MFlow because it appears to be an actual web-based application server, rather than a website framework.
01:27:39 <folsen> bjorn__: would be a bit more than editor trick no? I have to pull out the correct types as well, and the way you define the tables depends on the number of columns there are etc 
01:28:12 <folsen> bjorn__: it should be possible to generate by connecting to the DB and inspecting it, so would require code to run, but I'm not sure if anyone has written that script already
01:30:10 <ashishnegi> sshine: i went sparsely through it.. i saw examples using wai-websockets with warp for websockets.. Does frameworks write wrapper over it or directly use it ? 
01:31:09 <ashishnegi> sshine: does Scotty gives support for websockets or i have to use wai-websockets only ?
01:31:35 <drdo> The capitalisation rule annoys me sometimes
01:31:37 <ongy> can I somehow get a trace or similar from a FFI segfault? Most I guess my Storable instance is wrong
01:31:49 <zomg> ashishnegi: many of the web libs are built on top of wai, so usually even if you decide to use something like Scotty, you'd be able to hook into the underlying wai interface and use a wai-based lib like wai-websockets simultaneously
01:32:49 <ashishnegi> zomg: ok.. so if i use a wai-compatible web lib for serving pages.. i can drop in wai-websockets to start using websockets also.. right ?
01:33:03 <zomg> yeah that should work :)
01:33:21 <ashishnegi> zomg: sshine thanks :)
02:10:52 <{AS}> Hi is there a nice library for testing IO in Haskell?
02:10:57 <{AS}> Like mocking or so
02:11:22 <{AS}> e.g. if I want to test whether putStrLn "Hello" is the same as putStr "Hello\n" (Yes, silly example)
02:12:32 <maerwald> IO is too unspecific to. How do you mock kernel calls?
02:12:51 <maerwald> how do you mock file writes
02:13:07 <merijn> {AS}: How about QuickCheck's "morallyDubiousIOProperty" ?
02:13:27 <{AS}> merijn: Thanks!
02:13:44 <{AS}> maerwald: I mean, I can mock my own file system
02:14:05 <{AS}> Yes, it is not going to be perfect model
02:14:05 <ongy> {AS}: have fun mocking e.g. bind syscall
02:14:07 <merijn> maerwald: Why would you want to mock those? And how is that possible related to wanting IO based tests?
02:14:32 <{AS}> ongy: Why would I want to mock a syscall?
02:14:34 <ongy> afaik not relevant for files, but for general IO testing framework
02:14:41 <maerwald> merijn: I don't understand your question. If you want to mock IO, the question is usually "what exactly do you want to mock"
02:14:45 <maerwald> you can't "mock IO"
02:14:46 <{AS}> ongy: Maybe I wrote it a bit unclear
02:14:50 <maerwald> that's too general
02:14:54 <merijn> maerwald: He didn't say "I want to mock IO"
02:15:06 <maerwald> merijn: yes he did
02:15:06 <merijn> maerwald: He said "is there a nice library for testing IO"
02:15:07 <{AS}> I meant I want to mock somethings which use IO
02:15:13 <{AS}> not mock all of IO
02:15:22 <maerwald> that's why I asked for a more specific use case
02:15:22 <merijn> maerwald: "like mocking or so" which I assume is a library in some language
02:15:24 <{AS}> As merijn said :)
02:16:44 <maerwald> you still didn't make it clear
02:17:07 <{AS}> maerwald: I want to mock a subset of IO actions
02:17:13 <minad> Hi, I just saw https://www.reddit.com/r/haskell/comments/4z28nk/tear_down_cofree/. the uncofree mentioned there, is this not just a fancy cata?
02:17:31 <minad> cata     f x = f             $ map (cata f)     $ unfix x
02:17:36 <minad> uncofree f x = f (extract x) $ map (uncofree f) $ unwrap x
02:17:53 <{AS}> maerwald Like say I have a program with putStrLn and readLn, etc. (operations I know how to mock). I am looking for a framework that allows me to do so
02:18:08 <minad> doesn't the uncofree have a proper name?
02:18:11 <merijn> Unrelatedly, I'm still looking for some good intro's to row typing/row polymorphism :)
02:18:22 <{AS}> merijn: Have you seen Elm?
02:18:27 <{AS}> I believe they support that there
02:19:01 <Ulrar> So how do I do a simple DNS lookup in haskell ? Looks like Network.DNS.Lookup ignores the /etc/hosts file
02:19:04 <merijn> {AS}: Elm has structural subtyping, I thought? But anyway, I don't mean languages that have those, I mean papers/references on how to implement them :)
02:19:14 <{AS}> merijn: Ah
02:19:20 <{AS}> I see
02:19:59 <merijn> I've found some presentations and some posts of Brian McKenna's blog, but they're pretty sparse :)
02:22:03 <{AS}> merijn maybe http://www.pllab.riec.tohoku.ac.jp/~ohori/research/toplas95.pdf ?
02:22:05 <maerwald> {AS}: that would just be hiding prelude functions and using your own
02:22:12 <maerwald> not sure why you need a framework for that
02:23:48 <{AS}> maerwald: In Java/C# etc. there are mocking frameworks
02:23:53 <maerwald> I know
02:23:55 <{AS}> I was just wondering whether there were some in Haskell
02:24:01 <maerwald> you dont need it
02:24:16 <{AS}> maerwald: I don't?
02:24:40 <{AS}> Your suggestion basically amounts to rewriting all my code to use other functions
02:24:46 <maerwald> no
02:26:56 <{AS}> maerwald: Then what do you suggest?
02:26:57 <{AS}> Maybe I misunderstood :)
02:29:20 <{AS}> merijn: I think https://link.springer.com/chapter/10.1007%2F978-3-642-41660-6_23 is newer
02:35:48 <{AS}> I guess it would have been nice if there was a MonadConsole, MonadFile, etc. 
02:36:39 <{AS}> so putStrLn :: MonadConsole m => String -> m (), and then I could implement MonadConsole for a mock instead of IO
02:37:19 <itechjunkie> merijn: Have you looked at lenses yet?
02:37:38 <maerwald> {AS}: maerwald: {AS}: that would just be hiding prelude functions and using your own
02:37:58 <merijn> itechjunkie: I'm not sure why you ask that?
02:38:14 <{AS}> maerwald: So you mean, I should redefine the functions?
02:39:03 <{AS}> to be in MonadConsole?
02:39:22 <{AS}> I see
02:39:27 <maerwald> https://wiki.haskell.org/Import
02:39:33 <maerwald> https://wiki.haskell.org/Import
02:39:36 <maerwald> import¬†Mod¬†hiding¬†(x,y)
02:40:11 <{AS}> OK, thanks
02:40:32 <{AS}> but how do I then define the IO version of MonadConsole?
02:40:58 <maerwald> I don't really understand what you are trying to do. You can hide Prelude functions.
02:41:14 <{AS}> maerwald: I want a replaceable API MonadConsole
02:41:31 <{AS}> where I can both use the IO versions (in production), and Mock versions (for testing)
02:41:46 <{AS}> So I can just use Prelude.putStrLn if I hide it?
02:41:49 <itechjunkie> merijn: You were interested in row polymorphism right? Admittedly, I'm not familiar with the in's and outs but if I understand right it allows you to mutate complex data structures...
02:42:35 <itechjunkie> Lenses are also an avenue to do that. I apologize if my understanding is off
02:42:58 <maerwald> {AS}: you hide putStrLn from Prelude and use your own
02:43:07 <maerwald> that's what I said like 4 times now
02:43:25 <merijn> itechjunkie: Yes, but I don't see how "mutating complex data structures" is at all related to implementing row polymorphism? :)
02:44:40 <lpaste> ‚Äú{AS}‚Äù pasted ‚ÄúHiding prelude‚Äù at http://lpaste.net/1201367292596715520
02:44:48 <itechjunkie> merijn: That's my fault then. I assumed the access/modify behavior is all you wanted. 
02:44:51 <{AS}> maerwald: I understood, what you meant
02:44:58 <{AS}> I was just asking a new question
02:45:17 <{AS}> How would I do the above in the paste :)
02:45:18 <itechjunkie> My only run in with row polymorphism is when I was dabbling with purescript
02:45:39 <{AS}> actually it should be IO not (IO a)
02:45:46 <merijn> itechjunkie: What I want is to figure out how to implement it in my own language ;)
02:45:50 <maerwald> I don't even understand why you want a different type signature
02:46:14 <{AS}> maerwald: Because, I want to be able to replace the IO monad with a mock object
02:46:28 <{AS}> so I can mock putStrLn during testing
02:46:36 <{AS}> but still use the IO version
02:46:38 <maerwald> why? you already mock it by importing your own version
02:47:09 <{AS}> maerwald: I don't want to rewrite the imports each time I want to test vs compiling
02:47:14 <maerwald> CPP
02:47:26 <{AS}> Anyway, thanks for the help. I think I got an idea how to proceed :)
02:48:03 <maerwald> you don't need to rewrite the imports
02:48:15 <daniel-s> module ModuleName where
02:48:26 <daniel-s> Am I exporting all or no parts of the module using the above line?
02:48:38 <Rembane> daniel-s: All the things!
02:50:59 <ashishnegi> hi .. i am switching between tcp sockets and websockets a lot in code.. so  i decided to write a wrapper over it (send,recv,accept) Please see https://github.com/ashishnegi/hchat/blob/master/src/HChat/Network.hs.. however i am getting errors http://lpaste.net/179781
02:51:26 <ashishnegi> the problem is in defining a method on class that returns value of same class..
02:51:46 <daniel-s> Rembane: ha. Thanks.
02:51:56 <Rembane> daniel-s: No worries, good luck!
02:55:25 <drdo> Is there any GHC extension that allows duplicate constructors?
02:58:00 <cocreature> drdo: no, we only have DuplicateRecordFields
02:58:12 <cocreature> drdo: you can however put them in different modules and use qualified imports
02:59:15 <drdo> Bummer :(
02:59:30 <drdo> I wonder if there are serious difficulties with such an extension
03:00:03 <cocreature> personally I don‚Äôt like the idea of such an extension. it makes it harder to read the code while giving you little benefit
03:00:22 <drdo> Why would it make it harder to read the code?
03:01:03 <cocreature> because I now need to mentally figure out which typeconstructor is actually called
03:01:16 <ashishnegi> Is it possible to have somehting like :
03:01:17 <ashishnegi> class NetworkConn sock where
03:01:17 <ashishnegi>    accept :: (NetworkConn myconn) => sock -> IO myconn
03:01:20 <drdo> If the code is well written, it should be clear from context
03:01:33 <drdo> Of course this can be misused to make it harder, like most things
03:01:35 <Rembane> drdo: Generally code isn't well written.
03:05:20 <cocreature> drdo: yeah but then I need to look at the context whereas previously the identifier was sufficient so it‚Äôs still more complex
03:05:43 <cocreature> ofc you can make the argument that the tradeoff is worth it but I don‚Äôt agree for this usecase
03:06:17 <drdo> cocreature: You do this all the time in mathematics, because otherwise things are much longer and harder to read
03:09:04 <saurabhnanda> hey, is there a good MOOC (online) course on Haskell to help a team structure their Haskell learning experience
03:09:05 <saurabhnanda> ?
03:09:07 <drdo> What I actually want in this case isn't even that. I want some form of subtyping, I want to have a new type with the old constructors plus some new ones
03:10:24 <cocreature> now that‚Äôs a usecase I could get behind :)
03:11:25 <ashishnegi> saurabhnanda: try https://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1
03:11:28 <cocreature> drdo: you can use classy prisms to get that (whether that‚Äôs worth the complexity is a separate question)
03:11:30 <drdo> I don't know if that messes something up badly
03:11:41 <drdo> (some extension like this)
03:11:55 <ashishnegi> saurabhnanda: or https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0
03:12:08 <saurabhnanda> ashishnegi: the edx course has mixed reviews
03:12:48 <ashishnegi> saurabhnanda: what are your expectations from course ? do you want it for begineers / intermediate ?
03:13:55 <mniip> @tell dfeuer most mfix instances would allow a computation of the form mfix (\x -> action >> return (1:x)), and some monads would execute 'action' multiple times. If 'action' is an index-changing operation then such monads would be unable to implement imfix
03:13:55 <lambdabot> Consider it noted.
03:14:07 <saurabhnanda> ashishnegi: (a) make people comfortable with haskell syntax, (b) build intuition for functors & monads, (c) shallow-dive into haskell type-system, (d) deep-dive into haskell type-system with a view of leveraging it to solve domain problems, (e) build a webapp as a course project.
03:15:25 <saurabhnanda> why is MSDN promoting Haskell? Shouldn't they be putting their weight behind F# ?
03:16:46 <ashishnegi> saurabhnanda: for a) b) c) would be covered in edx course.. it has exercises so team members can interact better.. i have not watched channel9 course but it has better reviews.. 
03:17:12 <saurabhnanda> ashishnegi: okay, thanks. I noticed that you have the edX certification. Did you like the course yourself?
03:18:34 <liste> saurabhnanda: Microsoft (esp. Research) has been quite involved with Haskell in general (https://www.microsoft.com/en-us/research/people/simonpj/ for example)
03:18:36 <ashishnegi> saurabhnanda: yes.. i liked it but Eric left us with the types.. which was frustrating with Monads.. as i was doing it alone.. with team it would be fun definitely..
03:19:39 <saurabhnanda> oh, SPJ is with M$
03:20:15 <saurabhnanda> ashishnegi: if all goes well, I might start hounding you on the "team" part
03:20:18 <saurabhnanda> :)
03:20:28 <ashishnegi> saurabhnanda: but yes.. eric was right to do so.. as one needs to get accustomed and learn to play with types..
03:20:51 <ashishnegi> saurabhnanda: you are doing it with team .. right ??
03:21:42 <saurabhnanda> ashishnegi: no, I mean I'm building a Haskell team to build kickass products
03:22:20 <ashishnegi> saurabhnanda: sure.. any time.. :) .. haskellers will die to get a job to write haskell :)
03:23:06 <saurabhnanda> ashishnegi: and it'll be out of Goa as well :) 
03:23:38 <ashishnegi> saurabhnanda: too good 
03:32:40 * hackagebot casr-logbook-html 0.0.1 - CASR 61.345 Pilot Personal Logbook HTML output  https://hackage.haskell.org/package/casr-logbook-html-0.0.1 (TonyMorris)
03:33:07 <ashishnegi> hi.. can somebody help me fix : http://stackoverflow.com/questions/39098222/writing-a-class-with-method-returning-same-class-object
03:42:41 * hackagebot stylish-haskell 0.6.3.0 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.6.3.0 (JasperVanDerJeugt)
04:14:39 <{AS}> ashishnegi: You should consider using type members or functional dependencies/multiparameter type classes
04:15:18 <{AS}> Basically your function signature says that you accept any user provided type 'myconn' which satifies the NetworkConn type class constraint
04:16:14 <{AS}> But WS.acceptSocket returns NS.Socket, which is not necessarily what the caller of accept provided as return type (myconn)
04:16:54 <{AS}> ashishnegi: Basically the first answer of the Stack Overflow states that
04:17:31 <ashishnegi> {AS}: WS.acceptRequest returns Connection and NS.accept returns NS.Socket
04:18:13 <ashishnegi> {AS}: i am trying to understand that .. but did not had much success till now.. let me try more and put more findings in question.. thanks :)
04:21:45 <ongy> what's the easiest way to wait for an event fired by another haskell thread?
04:22:40 <phadej> something in http://hackage.haskell.org/package/stm, TMVar or TChan or ...
04:24:43 <cocreature> if you just need a single event you can also use normal MVars
04:24:45 <puregreen> won't a semaphore work?
04:24:47 <puregreen> http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Concurrent-QSem.html
04:24:58 <zoran119> can someone explain to me how is 'Text.Parsec.Prim.ParsecT s u m Char' the same as 'Parser Char'?
04:25:21 <cocreature> zoran119: it isn‚Äôt the same
04:25:52 <cocreature> zoran119: if you fix m to identity you arrive at Parsec s u Char which is just a type synonym
04:26:15 <cocreature> zoran119: if you then fix s to String and u to () you can use the type synonym Parser Char
04:26:32 <cocreature> or fix s to Text or ByteString depending on which module you get your Parser type synonym from
04:27:10 <zoran119> ok
04:27:18 <zoran119> seemed a bit more simple to me
04:27:39 <zoran119> i have a function symbol :: Parsec Char
04:27:59 <cocreature> zoran119: the definition of the type synonyms can be found at https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#t:Parsec and https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-String.html#t:Parser
04:28:08 <zoran119> symbol = oneOf "..."
04:28:25 <puregreen> does anybody know a package providing more fancy expectations for hspec? e.g. ‚ÄúshouldBeLessThan‚Äù or ‚ÄúshouldBeInRange‚Äù or whatever
04:28:36 <zoran119> but when i do :t oneOf "..." in ghci I get Text.Parsec.Prim.ParsecT s u m Char
04:28:46 <zoran119> hence i concluded they are same
04:29:34 <cocreature> zoran119: ParsecT ‚Ä¶ is more general
04:29:43 <cocreature> zoran119: so you can specialize it to Parsec Char
04:29:47 <cocreature> but not the other way around
04:30:11 <zoran119> cocreature: what is specialising it in my symbol function?
04:30:28 <zoran119> cocreature: just the type signature?
04:31:24 <cocreature> zoran119: if you have a polymorphic type containin type variables such as s u m in your case, you can instantiate the type variables to anything you want and thereby specialize the type signature
04:31:51 <cocreature> zoran119: so in your case s = String, u = () and m = Identity
04:33:19 <zoran119> cocreature: that makes sense, i'm just struggling to see where that's specified
04:33:24 <zoran119> ghc must infer it?
04:33:50 <zoran119> String from "..."?
04:33:58 <zoran119> not sure where it get identity from...
04:34:05 <cocreature> zoran119: the Parsec type synonym tells ghc that s = String, u = () and m = Identity
04:36:13 <zoran119> cocreature: ah, i see
04:36:25 <zoran119> cocreature: thanks for that
04:36:39 <cocreature> yw
04:37:34 <jonored> zoran119: This is fairly usual, by the way - a lot of haskell libraries are written with a very general type that the library code is written for, and a type synonym for a default case that lets you not worry about the complexity if you don't need to. It just shows up in type inference output and error messages regardless :)
04:38:52 <zoran119> jonored: was just thinking that. seems like :t in ghci gives you the most general type which makes it a bit hard to read
04:40:22 <jonored> zoran119: Unfortunately for that kind of query, it's about the only thing (that I can think of, anyways) that keeping around the name of the type synonym is useful for; you /want/ the compiler to treat synonymous types exactly the same.
04:41:10 <cocreature> zoran119: it can‚Äôt really choose a simplified version because there is no unique simplification
04:42:43 * hackagebot casr-logbook-meta 0.0.1 - Meta-information about entries in a CASR 61.345 logbook (casr-logbook)  https://hackage.haskell.org/package/casr-logbook-meta-0.0.1 (TonyMorris)
04:44:38 <jonored> (Oh, yeah, and I was thinking just for things explicitly declared using the synonym; of course library stuff can't really do that sensibly.)
04:47:43 * hackagebot conduit-parse 0.1.2.0 - Parsing framework based on conduit.  https://hackage.haskell.org/package/conduit-parse-0.1.2.0 (koral)
05:20:02 <ggole> merijn: ping
05:27:45 * hackagebot cassava-conduit 0.3.3 - Conduit interface for cassava package  https://hackage.haskell.org/package/cassava-conduit-0.3.3 (domdere)
05:30:36 <merijn> ggole: pong
05:31:37 <ggole> merijn: I figured out the system f case thing
05:31:54 <ggole> You just type apply the constructors within the pattern
05:32:43 <ggole> Say, using the traditional system f notation of type application as f [t], you would have case foo of Cons [t] x xs -> Just [t] x
05:36:01 <merijn> ggole: Well, yes...but how do I recover what [t] should be from an expression of type "List a"?
05:36:35 <ggole> You don't need to do that in system F
05:36:47 <ggole> All you need to do is check type equality
05:37:43 <lpaste> merijn pasted ‚ÄúSystem F‚Äù at http://lpaste.net/179812
05:37:44 <ggole> A more complete example https://gist.github.com/31dc2ae4784124a1da9877779a1a80c6
05:37:45 * hackagebot casr-logbook-meta 0.0.2 - Meta-information about entries in a CASR 61.345 logbook (casr-logbook)  https://hackage.haskell.org/package/casr-logbook-meta-0.0.2 (TonyMorris)
05:38:05 <merijn> ggole: Let's use that example
05:38:31 <merijn> ggole: I need to check, for example, that the type of "Just t x" is equivalent to "Maybe x"
05:38:54 <merijn> ggole: To compute the type of "Just t x", I need to know the value of 't'
05:39:10 <ggole> See, the problem is that you are trying to *bind* a type variable t in the case pattern.
05:39:34 <ggole> But there's no type variable hidden in the constructor which you can get at by matching.
05:39:50 <merijn> ggole: Well, currently there is in my implementation >.>
05:40:14 <merijn> ggole: Like I said, the Henk paper is really glossing over how to properly implement ADTs, sadly :\
05:40:39 <Rudes> merijn: is it supposed to be :: after id and head? or does this notation mean something diff
05:40:59 <merijn> Rudes: This is not Haskell, so that depends on your definition of "supposed to"
05:41:10 <Rudes> oh
05:41:12 <ggole> merijn: well, up to you. But I tried out the type application idea and it works fine.
05:41:28 <Rudes> i was confused cus it looks a lot like haskell
05:41:52 <merijn> ggole: I guess I'm a bit stuck with how I should represent ADT, currently constructors are simply names + type
05:42:25 <ggole> I don't think you need anything other than an opaque tag for type checking
05:43:01 <merijn> ggole: Well, the main issue I think stems from trying to understand how to deal with compound pattern matches during typechecking
05:44:27 <merijn> ggole: Let's rollback.
05:45:10 <merijn> ggole: Presumably there's a function "Pat -> Type", yes? That computes the type a pattern corresponds to and that you compare for equality with the type of 'l', or am I already screwing up there?
05:45:42 <merijn> hmmm
05:45:47 <ggole> I didn't do it quite that way
05:45:50 <merijn> oh, maybe I understand what you mean
05:46:14 <merijn> ggole: So you're saying the pattern is applied directly to the type parameter in the function
05:46:24 <ggole> I had a function that took the discriminator's type, a pattern, and produce either an environment mapping var to type, or a type error
05:46:33 <merijn> ggole: i.e., the 't' s on line 19 should actually be 'z'
05:46:41 <ggole> merijn: yes
05:47:03 <merijn> ggole: I think I just completely misunderstood the way to write patterns in System F
05:47:17 <merijn> Hold on, lemme check the grammar
05:47:32 <ggole> So you have (say, for Nil) a constructor of type forall a. List a, and in the pattern you type apply this constructor to go to a List z
05:48:48 <merijn> ggole: no, I mean, I clearly see how to do it that way
05:49:02 <merijn> I mean, if I just take 't' to be 'z' it becomes trivial
05:49:19 <merijn> It's just that I never understood it to work anything like that from the Henk paper
05:49:44 <ggole> I admit I have not read the paper
05:49:53 <merijn> ggole: Which also seems to assume that all type arguments always come before all non-type arguments, but that does not appear to be enforced anywhere
05:50:07 <ggole> I don't think system F requires that?
05:50:13 <merijn> ggole: Right
05:50:25 <merijn> ggole: But the implementation of case described in the paper seems to imply that
05:50:34 <ggole> Hmm.
05:50:46 <merijn> ggole: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.50.7152&rep=rep1&type=pdf
05:51:08 <ggole> My (godawful) case implementation also has type arguments first
05:51:59 <merijn> ggole: No, but if I treat type variables as special applications it should work just fine in any order
05:52:39 <merijn> ggole: But it means that I should treat type variables in patterns as being APPLIED to the constructor, rather than BINDING a type from the constructor
05:52:47 <merijn> ggole: Which should be easy enough to implement
05:52:57 <ggole> Yep, that's what I suggested earlier
05:52:59 <merijn> ggole: I'm just not sure that's how I'm supposed to understand it :)
05:53:19 <ggole> It seems sensible to me. Of course I have no idea what the authors of the paper had in mind.
05:53:19 <merijn> But as you can see on page 11 the section on dealing with case is rather...sparse
05:53:33 <merijn> ping to any type theory experts :p
05:54:28 <merijn> ggole: I mean, if that's the right way to think about it, it's a matter of slightly modifying the grammar to make type application more obvious and everything else becomes obvious :)
05:54:42 <merijn> So I'd be happy if that was the case :)
05:56:11 <merijn> Man...I'm going to be so annoyed if that's the solution
05:56:17 <merijn> So much wasted time on something so trivial
05:56:52 <ggole> Mmm.
05:57:20 <ggole> Yeah, the paper isn't really clear.
05:57:46 * hackagebot HsOpenSSL-x509-system 0.1.0.3 - Use the system's native CA certificate store with HsOpenSSL  https://hackage.haskell.org/package/HsOpenSSL-x509-system-0.1.0.3 (MariosTitas)
05:59:07 <ggole> Wait, there it is: "In the example, xs is presumably a list of Int, so Cons and Nil are instantiated at Int."
05:59:08 <merijn> I'm checking if I can find an example in TaPL and else I'll wait for the theory crowd to wake up :)
05:59:28 <merijn> ggole: Yes, but it's hardly clear what that *means* :)
05:59:52 <ggole> They chuck "at { Int }" after the case, and how could it be anything except the list of type arguments at which to specialise the constructors?
05:59:59 <merijn> But I've found an example of polymorphic lists in System F in TaPL, so I hope that clarifies
06:00:25 <merijn> ggole: Sure, but given that type arguments can be in any order of the constructor arguments it seems odd to have the at the end like that
06:00:30 <ggole> TaPL might just Church encode though.
06:00:33 <merijn> ggole: So I wasn't quite sure how to make sense of it
06:00:46 <ggole> Right.
06:02:56 <ggole> Heh, tapl defines isnil, cons, and diverge and writes map in terms of them. Flaky!
06:03:01 <merijn> It's also not obvious that parts of a pattern are actually applications and others abstractions
06:03:23 <ggole> Yeah, the syntax doesn't really lead you to that conclusion.
06:03:39 <merijn> Yeah, it leaves the proper typing of case a bit confusing
06:03:58 <merijn> Anyway, I think that by modifying the syntax to indicate type application it'll be fine
06:05:24 <ggole> Hmm, this is an interesting paper.
06:05:50 <merijn> Yeah, the rest is pretty readable and fascinating
06:06:03 <merijn> It's just a shame they drop the ball a bit with the details at the very end
06:06:35 <ggole> I tried the level collapsing trick a while ago and manage to screw it up pretty badly
06:06:44 <merijn> I mean, it only took me like a few days to write a parser + interpreter for System F + ADTs, except for the typechecking of case and ADTs
06:06:59 <merijn> Which level collapsing trick?
06:07:15 <ggole> Using the same term representation for terms, types, and kinds.
06:07:46 * hackagebot unfoldable 0.8.4 - Class of data structures that can be unfolded.  https://hackage.haskell.org/package/unfoldable-0.8.4 (SjoerdVisscher)
06:07:46 <merijn> Right now I don't have the predicative stuff implemented, instead being fully impredicative
06:08:04 <merijn> But I think that only affects inference, which I don't do anyway :)
06:14:08 <merijn> Also, I'm still not entirely sure what the problem with impredicativity is, despite multiple attempts to figure it out >.>
06:22:50 * hackagebot ltiv1p1 1.0.0.2 - Partial implementation of a service provider for LTI 1.1.  https://hackage.haskell.org/package/ltiv1p1-1.0.0.2 (achirkin)
06:22:52 * hackagebot bytestring-tree-builder 0.2.7.1 - A very efficient ByteString builder implementation based on the binary tree  https://hackage.haskell.org/package/bytestring-tree-builder-0.2.7.1 (NikitaVolkov)
06:25:54 <TestingIRC> are you people proud that John Carmac said haskell is a good language ?
06:26:18 <mauke> no, I wasn't involved in the design or implementation of haskell
06:27:02 <ahihi> I have some persistent-generated types and am using them in a servant API. but I'd like to extract the API type into a separate library, and it doesn't make much sense for that to depend on persistent. what's the recommended approach here? should I just define separate types for the API, and deal with the boilerplate of converting to/from the persistent types?
06:27:26 * JuanDaugherty looks up "John Carmac"
06:27:35 <grantwu> itym John Carmack
06:28:00 <TestingIRC> is JuanDaugherty a channel's lookup bot ?
06:28:06 <hpc> i always liked that dom game that john carmac made with john romeo
06:28:07 <mauke> yes
06:28:18 <mauke> did you mean: tarmac
06:28:40 <grantwu> TestingIRC: No, he's a person
06:28:45 <TestingIRC> hpc: is that "dom" better than pokemongo ?
06:28:48 <grantwu> they're
06:29:11 <quchen> persons
06:30:38 <maerwald> did he actually ever finish is wolf 3d haskell port? I doubt it
06:30:42 <maerwald> probably lost interest after some time
06:31:30 <TestingIRC> no, the plain landed and he lost interest
06:31:36 <TestingIRC> plane
06:32:02 <TestingIRC> he better not loosing interents in rockets
06:32:50 <grantwu> TestingIRC: ?
06:33:13 <TestingIRC> grantwu: where is the question
06:33:25 <grantwu> What are you talking about...
06:33:44 <TestingIRC> pokemongo, know what it is ?
06:34:10 <grantwu> !offtopic
06:34:18 <grantwu> @offtopic
06:34:18 <lambdabot> Unknown command, try @list
06:34:24 <grantwu> argh, well
06:34:38 <TestingIRC> what is @list ?
06:34:39 <maerwald> it's not even offtopic, it's just confusion
06:34:57 <TestingIRC> what @list do ?
06:35:10 <mauke> clearly misnamed, since @list is an array, not a list
06:35:18 <grantwu> It lists commands for lambdabot.
06:35:23 <TestingIRC> @list
06:35:23 <lambdabot> What module?  Try @listmodules for some ideas.
06:35:55 <phanimahesh> lol. lambdabot be trolling
06:36:30 <TestingIRC> @listmodules
06:36:30 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
06:36:30 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
06:36:38 <TestingIRC> @slap phanimahesh 
06:36:38 * lambdabot will count to five...
06:36:49 <ongy> is there a class  that let's me build data structures? So mainly I want an insert function. Applicative a, Monoid a might work with 'mappend . pure', but I'm not sure that's a nice way to do things
06:37:21 <maerwald> "a class that let's me build data structures"?
06:37:29 <quchen> ongy: Nothing standard, no.
06:37:31 <ongy> not the structure, the instance
06:37:43 <ongy> object? Instanciation? what's the right wort here?
06:37:54 * phanimahesh waits for lambdabot to count to five. forever.
06:38:23 <ongy> > take 5 [0..]
06:38:26 <lambdabot>  [0,1,2,3,4]
06:38:53 <quchen> ongy: You can have a look at the various ‚ÄúUnfoldable‚Äù classes on Hackage.
06:39:17 <dramforever> There *is* a Control.Lens.Cons module, but I'm pretty sure you *don't* want to use it
06:40:13 <ongy> so list it is :)
06:40:22 <puregreen> if you want insert, then ‚Äòat‚Äô will work for lots of things (not lists, tho)
06:40:52 <merijn> Another type theory question: Ok, so I know that if you have, e.g. TypeInType then your type system is no longer consistent as every type is now inhabited, but does that present a problem for type checking dependent types?
06:41:10 <merijn> i.e., what is, practically speaking the consequence of TypeInType for dependent types? If anything
06:41:17 <TestingIRC> you can't catch me
06:42:09 <c_wraith> as I understand it, it doesn't make checking types any different - perhaps easier, since you don't need to prove termination anyway.
06:42:41 <merijn> c_wraith: You basically just loop indefinitely (or timeout/whatever) during time checking if your types don't terminate?
06:42:51 * hackagebot tasty 0.11.0.4 - Modern and extensible testing framework  https://hackage.haskell.org/package/tasty-0.11.0.4 (RomanCheplyaka)
06:43:51 <c_wraith> merijn: I suppose that can happen.  It's nothing new for GHC, but it is a consideration for a new type system.
06:44:46 <merijn> c_wraith: Yes, I'm back to playing with type theory again (as should be obvious from all the questions ;)), but I have no clue how hard implementing a termination checker is and if it's worth the bother if I merely want dependent types :)
06:45:22 <merijn> c_wraith: So I'm wondering if simply going "Type : Type" and calling it a day would be a simpler solution ;)
06:55:10 <parket> Hey, guys. Can not understand what am i doing wrong http://pastebin.com/qi7i9fRs. 
06:55:23 <parket>     parse error (possibly incorrect indentation or mismatched brackets)
06:55:39 <parket> Point to the end of >>= implementation
06:56:09 <merijn> parket: in is not indented more than let
06:56:54 <parket> So, in MUST be intended more then let. Ok. I'll try in sec
06:57:21 <mauke> can't reproduce
06:57:24 <mauke> parket: no, it doesn't
06:57:49 <dramforever> parket: It parses fine here
06:57:52 * hackagebot lackey 0.4.0 - Generate Ruby clients from Servant APIs.  https://hackage.haskell.org/package/lackey-0.4.0 (fozworth)
06:58:03 <dramforever> (where here = on my computer)
06:58:10 <mauke> http://stackoverflow.com/help/mcve
06:58:17 <merijn> hmmm, I always forget the details of let/in indenting
06:58:26 <merijn> It should be avoided anyway
06:58:35 <maerwald> tabs vs spaces?
06:58:42 <mauke> there's nothing special about 'in'
06:58:47 <mauke> 'let' parses layout as usual
06:59:17 <parket> merijn: Hmm. I am using ghci :script to debug it. I am new in haskell, and indentation is the hardest thing in haskell for me ^_^  
06:59:49 <parket> Deeper indentation of `in` does not help
07:00:09 <dramforever> parket: You should use a .hs file for anything more than a one-liner
07:00:37 <parket> i am using .hs file. And load it intho ghci with :script command
07:00:50 <dramforever> No, load it with :locd
07:00:52 <dramforever> :load
07:01:10 <Profpatsch> How do I wait for a thread to finish when I have a ThreadId?
07:01:40 <barrucadu> With just the ThreadId you can't
07:02:01 <merijn> Profpatsch: You don't. AMongst the reasons why is that a thread cannot die/get GCed while a ThreadId to it exists
07:02:06 <barrucadu> You could, for instance, make the thread put a value in an MVar as the last thing it does, and block on taking from that
07:02:08 <Profpatsch> barrucadu: Then the question is: How do I use the simpleBot function then? https://hackage.haskell.org/package/ircbot-0.6.5/docs/Network-IRC-Bot-Core.html
07:02:12 <merijn> Profpatsch: You have to use explicit MVar/TVar to indicate termination
07:02:23 <dramforever> Profpatsch: Try async
07:02:51 <Profpatsch> I‚Äôm not sure the ircbot library is very well designed.
07:03:19 <merijn> Profpatsch: That sounds like a not unlikely observation :)
07:03:21 <parket> dramforever: Got some progress with :load. thx ;)
07:03:30 <barrucadu> I cam to a similar conclusion when I wrote an IRC bot a couple of years ago
07:03:43 <ongy> can I use the FFI to import as FunPtr? I can import a function, and I can transform it to FunPtr (which is weird overhead)
07:03:53 <ertes> Profpatsch: use async
07:04:51 <merijn> ongy: Sure
07:05:01 <merijn> ongy: I think the FFI docs even have an example of that
07:05:38 <dramforever> ongy: http://hackage.haskell.org/package/base-4.9.0.0/docs/Foreign-Ptr.html#t:FunPtr
07:05:41 <merijn> ongy: The "weird overhead" from the wrapper stuff is because it can convert any arbitrary haskell closure into a FunPtr
07:05:47 <ertes> Profpatsch: note that even cancel and withAsync don't wait for the thread to finish‚Ä¶  you need to use 'wait'
07:05:54 <dramforever> TL;DR Like: foreign import ccall "stdlib.h &free" p_free :: FunPtr (Ptr a -> IO ())
07:08:40 <Profpatsch> ertes: How would that work?
07:08:47 <merijn> ertes: He can't do that
07:08:50 <Profpatsch> ertes: Can I convert a ThreadId to an Async?
07:08:54 <merijn> ertes: The library is returning ThreadId's
07:09:06 <merijn> Profpatsch: You don't. You can't do what he suggests with that API
07:09:28 <Profpatsch> merijn: What should I do then? :)
07:09:37 <merijn> Profpatsch: In fact, I think that with that API it's impossible to do what you ask, without at least some pretty elaborate hacks
07:09:43 <barrucadu> A ThreadId with nothing else is basically useless
07:09:52 <merijn> Profpatsch: Most likely? Not use that library.
07:10:24 <Profpatsch>  wow, who designed this?
07:10:36 <Profpatsch> But it has to work ‚Ä¶ somehow?
07:10:52 <mauke> bold assumption
07:10:57 <barrucadu> Profpatsch: My irc-client library has a couple of users other than myself, so it may do what you want. I wrote it when I was dissatisfied with the available Haskell irc libraries back in 2014.
07:11:06 <Profpatsch> I mean somebody must be using it, at least the person that designed the library?!
07:11:18 <Profpatsch> barrucadu: Ah, nice. What‚Äôs it called?
07:11:20 <merijn> Profpatsch: Maybe they don't care about waiting for threads to finish?
07:11:30 <barrucadu> Profpatsch: irc-client ;)
07:11:40 <chsn> I'm trying to study how mini stg works. I'm looking at https://github.com/bjpop/ministg/blob/master/src/Ministg/Eval.hs#L59-Lundefined -- on a high level, how does "bigStep" and "smallStep" differ ?
07:15:33 <lyxia> chsn: bigstep runs smallstep until there is nothing left to do
07:16:01 <ertes> merijn: ah, too bad
07:16:56 <ertes> Profpatsch: do you want to write an IRC bot?
07:16:58 <dramforever> Offtopic: Did you just trigger a bug of the GitHub website?
07:17:10 <dramforever> chsn: https://github.com/bjpop/ministg/blob/master/src/Ministg/Eval.hs#L70
07:19:03 <\_rand> Hello everyone! Started Haskell a week a go and it is a relevation to me, like a whole new world opening its doors 
07:19:35 <Profpatsch> ertes: Yes.
07:19:37 <Rudes> \_rand: give it a week
07:19:47 <Profpatsch> Basically just a small client that joins once a day.
07:20:23 <kadoban> \_rand: Cool, 'welcome :)
07:20:39 <Rudes> Honestly i really like this language i just can't come up with an appropriate project for it to really start learning...
07:20:44 <\_rand> thnx!
07:20:49 <Profpatsch> Let‚Äôs all improve the Aelve guide please https://guide.aelve.com/haskell
07:21:02 <\_rand> @kadoban, thnx!
07:21:02 <lambdabot> Unknown command, try @list
07:21:10 <puregreen> Profpatsch: it's missing lots of features
07:21:28 <Profpatsch> puregreen: What is?
07:21:28 <puregreen> Profpatsch: but hey, if you want you can help me with implementing them so that it would be ready for release :)
07:21:38 <puregreen> the guide
07:21:42 <Profpatsch> Ah, nice. :)
07:21:48 <Profpatsch> I think Haskell needs that.
07:22:03 <Profpatsch> But I don‚Äôt feel like I can contribute that much because I haven‚Äôt used a lot of libraries.
07:22:11 <Profpatsch> The interface is a blast, though.
07:22:53 <Profpatsch> puregreen: Do you have an IRC hilight set for ‚Äúaelve‚Äù? :)
07:23:05 <puregreen> sure
07:23:10 <puregreen> as well as lens and aeson
07:23:26 <Profpatsch> I really like how fluent the interface feels.
07:23:42 <Profpatsch> Should probably look into the code.
07:24:35 <puregreen> the code is pretty bad actually (especially since I started transitioning to Mustache but haven't finished)
07:24:38 <Profpatsch> barrucadu: How much of conduit do I need to know to be able to use your library?
07:25:09 <puregreen> if you want to help, an easy way is writing Selenium tests (which is really easy and I can help with that)
07:25:12 <Profpatsch> I haven‚Äôt learned any streaming libraries yet, so that‚Äôs kind of non-trivial for me.
07:25:29 <Profpatsch> puregreen: there‚Äôs probably a lot of JS involved?
07:25:48 <puregreen> some JS, yeah
07:26:10 <puregreen> it should work well without JS, tho (in readonly mode)
07:26:25 <puregreen> and JS there isn't complicated because when I started writing it I didn't know any JS
07:26:50 <barrucadu> Profpatsch: None.
07:27:04 <Profpatsch> barrucadu: Ah, nice.
07:28:10 <sm> glguy: thanks for the message, that might be http://hub.darcs.net/simon/rss2irc/issue/2 
07:28:14 <piyush-kurur> hi folks: any indians out there? the #haskell-india channel is mostly silent
07:28:36 <Rudes> so, does anyone know how the pandoc guys got the encoding algorithms for docx?
07:28:51 <merijn> Rudes: Painfully, presumably :)
07:29:05 <Rudes> what you think they just brute forced it?
07:29:08 <puregreen> isn't docx documented?
07:29:14 <Rudes> if you can even do that
07:29:14 <puregreen> Open XML
07:29:18 <Rudes> puregreen: where?
07:29:22 <Rudes> or how i should say
07:29:28 <JonReed> Hi, let's say I have a function `f` that has the following signature (IO a -> IO b -> IO a) and I want to write two do blocks right after it, but not use brackets. Is something like this possible? Here is an example: http://lpaste.net/179820
07:29:33 <puregreen> there's even a standard apparently
07:29:42 <puregreen> http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=61750
07:29:53 <puregreen> (see https://en.wikipedia.org/wiki/Standardization_of_Office_Open_XML)
07:30:16 <Rudes> glad i asked
07:30:23 <Rudes> otherwise i'd have been digging for hours
07:30:30 <kadoban> puregreen: It's more of a "standard". It's imfamously pretty bullshit.
07:30:36 <merijn> JonReed: No, not possible
07:30:56 <exDM69> puregreen: Rudes: there were some ugly tricks played by microsoft when there was an effort to standardize a document format
07:31:25 <Rudes> Number of Pages: 5018
07:31:26 <JonReed> merijn: Ok, thx. I liked the first version better anyway. 
07:31:35 <exDM69> puregreen: Rudes: open office xml got standardized, but microsoft also got their own "standard" format
07:32:09 <ongy> from what I have heard (I wouldn't put to much trust in it) the docx standard exists, but Microsoft violates it when they feel like it, so it's not helpful for "feature completeness" towards users
07:32:14 <exDM69> ... they did document a format supported by ms word, but it's actually impossible to implement that standard without seeing MS word sources
07:32:34 <merijn> JonReed: You could move the do blocks into a where clause
07:32:42 <liste> IIRC OOXML contains binary blobs
07:32:56 <exDM69> yeah, it's docx is standardized but then the standard has things like "formatting preset #50"... which is something left over from old MS word versions
07:32:57 <Rudes> we need fsociety to release MS's source
07:33:37 <lpaste> merijn annotated ‚ÄúLook ma, no brackets‚Äù with ‚ÄúLook ma, no brackets (annotation)‚Äù at http://lpaste.net/179820#a179823
07:33:45 <lpaste> lyxia annotated ‚ÄúLook ma, no brackets‚Äù with ‚ÄúLook JonReed, no brackets (annotation)‚Äù at http://lpaste.net/179820#a179824
07:33:47 <ongy> Rudes: we need people to use free formats :) I don't care about docx. Last time I encountered one I rewrote it in .tex
07:33:48 <merijn> JonReed: I would probably write it like that, if possible
07:34:07 <Rudes> ongy: i work for a corporation, they live on docx
07:34:31 <sm> pandoc exists, problem solved ?
07:36:09 <ongy> sm: I had the fun with japanese furigana. That fails between minor versions from time to time
07:36:14 <JonReed> merijn: That's beatiful. Will use it in the future somewhere. 
07:36:35 <Rudes> somehow microsoft will find a way to go after pandoc
07:36:38 <Rudes> beware of the overlords
07:37:12 <Profpatsch> Rudes: docx is a fist into the face of open standards activists.
07:37:17 <sm> MS likes FOSS now
07:37:18 <Profpatsch> Or rather OOXML
07:37:28 <Profpatsch> sm: Embrace Extend Extinguish, remember?
07:37:37 <sm> I think it's working the other way
07:37:45 <Rudes> well, they pretend to anyway, idk man, IBM backed Docker which was huge to me.
07:37:57 <Rudes> Profpatsch: nose knows
07:42:53 * hackagebot fay 0.23.1.15 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  https://hackage.haskell.org/package/fay-0.23.1.15 (AdamBergmark)
07:44:01 <Guest278904> How do I deconstruct a value within a do-block?
07:45:04 <xwildeyes> Hello!
07:45:16 <lyxia> Guest278904: case works within do
07:45:18 <xwildeyes> I am a newcomer to Haskell, 
07:45:29 <xwildeyes> Just started learning this week.
07:45:37 <fryguybob_> Guest278904: You can pattern match with  let  or  case  or if it is an action  <- 
07:45:42 <Rudes> xwildeyes: welcome
07:45:43 <Guest278904> xwildeyes: run while you can. lyxia thanks.
07:49:41 <Rudes> what's a solid starter project for haskell to really stretch my legs on
07:50:02 <lyxia> a haskell compiler
07:50:11 <kadoban> Rudes: What's your experience so far? What book(s) did you read, etc.?
07:50:41 <Rudes> i'm pretty new, i've worked through some of LYAH and several video series on YT.
07:50:47 <Rudes> it's not my first language though by any means
07:50:50 <merijn> Any type theory experts around for a System F question before I call it a night? :)
07:50:52 <Rudes> granted who's first language is haskell
07:52:34 <kadoban> Rudes: Maybe try the homeworks from http://www.seas.upenn.edu/~cis194/spring13/ ? http://haskellbook.com/ also has good exercises, though it depends how much you've learned from youtube I guess.
07:53:25 <Rudes> kadoban: i'll check those out, i've learned quite a bit. i just can't think of a good project that accomodates haskell well
07:54:28 <EvanR> haskell is a general purpose language, so pick a general purpose problem
07:54:43 <Rudes> EvanR: fair enough.
07:55:26 <EvanR> any program type which you see as an exercise for learning C or learning Perl should be doable in haskell
07:55:40 <EvanR> like a command line program to stream data and process it
07:55:52 <kadoban> Rudes: You could also do https://github.com/NICTA/course eventually
07:56:12 <Rudes> EvanR: up untill now i've just come up with my own exercises. just haven't been messing about on my server enough lately, haven't had any recent problems.
07:56:28 <EvanR> and doing something like this would also give you practice evaluating the performance concerns that crop up doing real haskell
07:56:39 <Rudes> i did wanna make a keyboard driver that turns my caps-lock key into a fn key so i don't have to reach for the brackets anymore but that's more a C thing i feel
07:56:59 <EvanR> drivers heh
07:57:03 <EvanR> haskell in your kernel
07:57:12 <Rudes> yeah, couldn't see it
07:57:43 <EvanR> there exists DSLs to output C code
07:57:54 <EvanR> but probably overkill for that particular project
07:58:03 <Rudes> sounds like going around your ass though
07:58:05 <kadoban> Rudes: There's usually OS-specific utilities for that kind of thing already anyway. My caps-lock is <esc>. Not that you couldn't redo it anyway, but, just saying.
07:58:09 <merijn> To be fair, there were drivers written in Haskell on NetBSD
07:58:35 <Rudes> kadoban: i mostly work over SSH, are there ssh utilities for that?
07:58:43 <Rudes> merijn: damn
07:58:57 <Rudes> kadoban: esc would be good i'm a vim coder
07:59:08 <kadoban> Not sure, I'd probably just do it on the OS level unless that interferes with something.
07:59:27 <jonored> There's also that seL4 business, although the to-run version wasn't haskell, just the runnable spec.
07:59:48 <EvanR> dont take my ESC key, i use that instead of ALT in irssi
08:00:05 <EvanR> you also use escape in telnet to ... escape
08:00:19 <Rudes> who would wanna get rid of their esc key?
08:00:29 <kadoban> I can still use esc ... I can't use capslock, 'cause who uses that anyway?
08:00:30 <EvanR> if you rebind it to something, ... its gone
08:01:02 <BMWPower> Hi all. I want to do something with Graphs. 
08:01:03 <Rudes> i just think caps lock is useless
08:01:16 <BMWPower> And persistance also
08:01:18 <EvanR> i tend to hit it accidentally which causes vim to go insane
08:01:40 <Rudes> EvanR: yep
08:02:21 <EvanR> its pretty useful if youre writing a document that needs to be viewed on roman computers
08:02:50 <Rudes> what?
08:02:52 <Rudes> OH
08:02:53 <Rudes> ha
08:02:54 * hackagebot data-category 0.6.2 - Category theory  https://hackage.haskell.org/package/data-category-0.6.2 (SjoerdVisscher)
08:02:55 <Rudes> got me
08:02:59 <EvanR> zing
08:03:22 <Rudes> EvanR: we'd be good friends, i can tell
08:03:32 <EvanR> even then they should really use css 
08:03:34 <ertes> Rudes: take an online course that is *not* related to haskell, and implement the exercise in haskell
08:03:46 <Rudes> ertes: good idea
08:04:45 <ertes> Rudes: for example a crypto or game programming course, just to give you some inspiration
08:04:51 <ertes> though crypto is probably easier
08:05:08 <EvanR> for screwing around with games, try gloss
08:05:34 <EvanR> it shortcuts you through the crap to set up a GL window, render graphics, get input
08:06:13 <Rudes> i use SDL2 in CPP
08:06:13 <ertes> i don't think taking that shortcut is a good idea, and yes, i say this with beginning haskell in mind
08:06:19 <Rudes> so rendering isn't anything new for me.
08:06:34 <EvanR> gloss gives you a simple DSL for 2d graphics
08:06:55 <ertes> Rudes: then i'd go the sdl2 route
08:07:06 <ertes> gloss hides many of the things you *should* learn in haskell
08:07:11 <EvanR> theres not much haskell to be learned from fucking with GLX ffi stuff
08:07:13 <ertes> like proper I/O, exception handling, etc.
08:07:34 <Rudes> does haskell cross-compile to windows?
08:07:49 <EvanR> GHC works on windows
08:07:54 * hackagebot irc-client 0.4.3.0 - An IRC client library.  https://hackage.haskell.org/package/irc-client-0.4.3.0 (barrucadu)
08:07:55 <Rudes> oh cool
08:08:01 <EvanR> rumor has it you can do cross compiling though
08:08:03 <Rudes> i guess it should it's only 30 years old
08:08:24 <EvanR> of course almost nothing standard (unixy) works on windows
08:08:52 <EvanR> and windows specific support tends to be "wtf why isnt this working"
08:09:20 <ertes> graphics, windows and haskell, pick two
08:09:35 <barrucadu> Every time hackagebot pings me like that I see I have a notification in this channel and immediately panic thinking "oh god, someone is asking me something!"
08:09:43 <barrucadu> EVen though I *know* I've just uploaded to hackage
08:10:24 <ertes> EvanR: BTW, the sdl2 library is very high-level
08:10:29 <sm> barrucadu: ha
08:10:38 <ertes> EvanR: no GLX FFI stuff =)
08:10:46 <puregreen> barrucadu: an opposite (or similar?) problem: I switch to the email workspace every 5‚Äì20 seconds or so even tho my email client notifies me when new mail comes
08:10:52 <sm> my hackage username is different, so I haven't noticed that
08:11:06 <EvanR> im not sure what SDL2 is really good for with askell
08:11:13 <barrucadu> sm: An advantage of the old-style hackage accounts where your username was your actual name, I suppose
08:11:39 <EvanR> there are more modern alternatives, like GLFW
08:11:40 <puregreen> that's pretty unfair
08:11:51 <puregreen> we should all ping sm several times per day to make it fair
08:12:01 <ertes> EvanR: SDL2 is modern
08:12:18 <ertes> EvanR: more importantly it does stuff that GLFW doesn't
08:12:20 <EvanR> SDL2 was replacing 1.2 in 2007
08:12:27 <ertes> EvanR: so?
08:12:54 <ertes> you think the library is out of date, because its minor version didn't increase for a long time? ;)
08:12:54 * hackagebot eventloop 0.8.2.0 - A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.  https://hackage.haskell.org/package/eventloop-0.8.2.0 (sebaslafleur)
08:13:00 <maerwald> EvanR: SDL2 is from 2013
08:13:17 <EvanR> i used 1.2 a lot, and didnt see the need to have a totally new library with the same name that is sort of living with the ghost of the past
08:13:44 <EvanR> SDL2.0 had been in development a lot when it was finally "ready" in 2007, which i was doing a lot of sdl
08:13:53 <EvanR> also known as 1.3 at the time
08:13:59 <maerwald> 1.3 was never released
08:14:18 <ertes> SDL 1.2 was good for the time it was created in, and SDL 2 is good today
08:14:28 <EvanR> GLFW is good enough
08:14:34 <maerwald> SDL2 has been released in 2013
08:14:39 <sm> barrucadu: would you say irc-client is the leading IRC lib at the moment ?
08:15:15 <sm> we were searching for an easy TLS-capable IRC lib just recently in here
08:15:46 <barrucadu> sm: I'm not sure, there are definitely a few people using it (and it does TLS).
08:16:03 <barrucadu> I think there are other people developing Haskell IRC things, but I don't really pay attention because I have my own little ecosystem which works for me
08:16:29 <sm> there are so many, we really need more package reviewers
08:16:48 <EvanR> networking, pthread-wrapping, and raw audio synth arent really things you want to be doing with SDL in haskell i think
08:17:06 <ertes> EvanR: the "good enough" argument is not a good argument‚Ä¶  SDL 2 is better than GLFW in every single way: more portable, more features, less control-hungry‚Ä¶  more importantly it's a media library you can actually use for games
08:17:29 <EvanR> you can actually use GLFW for games
08:17:34 <sm> GLFW installs on windows without pain, right ?
08:17:55 * hackagebot pi-forall 0.1.1 - Demo implementation of typechecker for dependently-typed language  https://hackage.haskell.org/package/pi-forall-0.1.1 (sweirich)
08:18:07 <maerwald> some distros don't even ship glfw anymore :D
08:18:37 <maerwald> almost no reverse dependencies anymore (at least in the opensource world)
08:21:16 <ertes> what disqualifies GLFW immediately for anything serious is callbacks
08:21:24 <sm> and by GLFW, I mean GLFW-based haskell apps. As usual, SDL-based apps come second-best in this regard (installation experience)
08:21:56 <ertes> yes, sdl2 may need a better installation experience on windows (i don't know), but that's something that can be fixed
08:22:27 <ertes> GLFW's lack of features and terrible design choices can only be fixed by redesigning the underlying library
08:22:37 <sm> I'm hoping someone will attempt packaging all SDL C files into sdl2 (you may have seen that chat ertes)
08:22:52 <ertes> sm: yeah, i was taking part in it =)
08:23:01 <sm> ah :)
08:24:03 <Schrostfutz> Hi, how would I combine parsec parsers of different types? I want to do something like this: (string "space" <|> string "newline" <|> anyChar).
08:24:29 <puregreen> add ‚Äúvoid‚Äù
08:24:41 <kadoban> Schrostfutz: Do you care about the results, or do you discard them?
08:24:48 <puregreen> void (string "space" <|> string "newline") <|> void anyChar
08:25:04 <puregreen> if you care about outputs, you can use Left <$> and Right <$>
08:25:04 <EvanR> SDL1.2's lack of features and terrible design choices could only be fixed by redesigning the underlying library, so they did. but called it the same thing and didnt go far enough. and they made commercial games with it
08:25:28 <puregreen> or just ‚Äú(:[]) <$> anyChar‚Äù if you want to get a String back
08:25:31 <EvanR> and lots of other games which were pretty awesome
08:25:42 <Schrostfutz> kadoban: This is the context: http://sprunge.us/cDVd?hs, I do save the results.
08:26:05 <ertes> EvanR: could you please name a specific shortcoming of SDL 2?
08:27:02 <kadoban> Schrostfutz: Looks like puregreen's last suggestion is what you want then.
08:27:35 <kadoban> You'll have to change line 7 too I guess.
08:27:55 * hackagebot happstack-authenticate 2.3.4.4 - Happstack Authentication Library  https://hackage.haskell.org/package/happstack-authenticate-2.3.4.4 (JeremyShaw)
08:27:57 <Schrostfutz> kadoban: Yes, I just noticed :D
08:29:08 <EvanR> ertes: too complicated
08:29:35 <Schrostfutz> A general question: I read that in a do block the statements are just concatenated using '>>' and '>>=' saving the result for the next statement. How would I write the 'x <- stmt; return $ case x of ...' without a do-block, then?
08:29:59 <phanimahesh> Not concatenated exactly.
08:30:12 <EvanR> stmt >>= \x -> case x of...
08:30:18 <EvanR> or with LambdaCase extension
08:30:20 <Gurkenglas> Schrostfutz, you could replace lines 3-7 with (Char ' ' <$ string "space" <|> Char '\n' <$ string "newline" <|> Char <$> anyChar)
08:30:53 <ertes> EvanR: it's loaded, because it actually provides non-trivial features, but if you use only basic features, you also use only a basic API
08:31:34 <Schrostfutz> EvanR, Gurkenglas: Okay, thank you
08:32:09 <EvanR> yeah if you want to use software rendering on a toaster which supports advanced window management hooks maybe
08:32:30 <EvanR> but if you want a desktop openGL video game
08:33:30 <ertes> EvanR: software rendering is more complicated than getting a GL context with SDL
08:33:40 <EvanR> i do have a gripe with GLFW that it gives you a delta counter using double, but you can also just use the clock package or your own clock code
08:33:42 <Schrostfutz> Gurkenglas: Is there a way to extract the three 'Char's from the bracket?
08:33:55 <EvanR> ertes: well it was easy in 1.2 !
08:34:14 <Gurkenglas> Schrostfutz, the bracket is unnecessary, I just put it there because I wrote long code otherwise undelimited into a line with explanation
08:34:16 <exDM69> EvanR: glfw's time counter (absolute time since app startup) is a bit crummy due to win32 timer functions being awful
08:34:19 <ertes> EvanR: it's one extra line in SDL 2
08:34:51 <Jenaf> is there some predefined stuff for binary search trees in Haskell?
08:34:52 <exDM69> EvanR: you'd need 128 bit integer division to make it work on windows with QueryPerformanceCounter / Frequency
08:34:56 <Schrostfutz> Gurkenglas: I meant to ask whether there is a version that requires me to write the Char constructor only once.
08:34:59 <sm> the http://hackage.haskell.org/package/sdl2 api looks pretty useful to me, how else would you work with all those devices ?
08:35:10 <ertes> EvanR: and the payoff is that you get hardware acceleration with 2D graphics
08:35:16 <exDM69> Jenaf: Data.Map is not really a binary search tree, but it is an ordered collection
08:35:16 <ertes> which SDL 1.2 didn't have
08:35:28 <EvanR> it did, but that gets into what you mean by hardware acceleration
08:35:34 <Jenaf> I'll check that out
08:35:46 <Gurkenglas> Schrostfutz, sure: Char <$> (' ' <$ string "space" <|> '\n' <$ string "newline" <|> anyChar). I shoulda thought of that myself.
08:35:58 <EvanR> also you cant get "opengl-style hardware acceleration" with arbitrary 2D graphics
08:36:04 <Schrostfutz> Gurkenglas: Great! Thank you very much!
08:36:04 <ertes> EvanR: you can
08:36:11 <EvanR> nah
08:36:12 <ertes> EvanR: and it is in fact OpenGL
08:36:54 <EvanR> displaying sprites is one thing but framebuffer API just cant go that fast at modern rez
08:36:57 <Gurkenglas> (Schrostfutz, also there's ($>) which is flip (<$) if you like that more)
08:37:26 <EvanR> this usually ends with someone declaring that framebuffer APIs suck anyway
08:37:28 <Gurkenglas> (Though it's unwieldy with lambdabot because it STILL doesn't have it in scope by default for some reason)
08:37:30 <EvanR> end of an era
08:37:55 <ertes> EvanR: i don't know what you're talking about‚Ä¶  SDL 2 supports both framebuffers and sprites very well
08:37:58 <EvanR> i would rather just use GL directly (through GLFW)
08:38:06 <Schrostfutz> Gurkenglas: I'll first have to dig through that solution :)
08:38:38 <Gurkenglas> Schrostfutz, you could also have "extracted from the bracket" the Char in your sprunge
08:38:45 <ertes> it's good enough for most 2D games, and if you need more speed/control or 3D, you dispense with its rendering library and use a GL context instead
08:39:18 <orion> Anyone know how to prevent stack from running tests in certain packages included in your stack.yaml file when you run `stack test`?
08:40:05 <Schrostfutz> Gurkenglas: I see that now, but the solution lacking the case seems more elegant to me.
08:40:10 <kadoban> orion: Are they in the packages list? Mark them as extra-deps
08:40:16 <orion> I.e. I pull in a library stored locally on my machine. When I run `stack test` I only want to run the tests for the project in the current working directory.
08:41:04 <ertes> EvanR: in fact SDL 2 supports framebuffers better than SDL 1.2 did, because it uses a texture, similar to gloss-raster‚Ä¶  so you don't need to switch to a 320x200 mode to draw 320x200
08:41:18 <orion> kadoban: Yes, the package is in the packages list.
08:41:34 <kadoban> orion: https://docs.haskellstack.org/en/stable/yaml_configuration/#local-dependency-packages-extra-dep
08:41:42 <EvanR> 320x240 for life
08:42:06 <sm> that should be enough pixels for anyone
08:42:30 <ertes> like 256 colours are enough colours for anyone =)
08:42:37 <EvanR> you dont need to switch... does anything made after 2005 even allow that
08:42:50 <sm> well clearly we need a haskell graphics/games lib showdown
08:43:05 <orion> kadoban: Awesome, thank you.
08:43:10 <kadoban> 'welcome
08:43:23 <ertes> EvanR: sure, but most screens don't support it =)
08:43:29 <Gurkenglas> My judgement criterium: Does stack install "just work" with it on Windows
08:43:37 <EvanR> ertes: right, so its uploading entire megabyte buffers each frame... nice
08:43:39 <sm> Gurkenglas: agreed
08:43:55 <ertes> EvanR: what is?
08:44:04 <EvanR> "framebuffer" rendering
08:44:18 <glguy> sm: Regarding IRC libraries, irc-core is what I use for low-level IRC protocol
08:44:20 <ertes> EvanR: no, it's not‚Ä¶  it's uploading 320x200
08:44:32 <ertes> or whatever size you choose
08:44:34 <glguy> sm: works at about the level of the irc package but does more
08:44:36 <vandenoever> I've a function "f :: m a", so I can call  "r <- f",  can I change the call so that I get "Maybe a" instead of "a"?
08:44:59 <sm> glguy: thanks, no TLS though
08:44:59 <EvanR> 320x240x24 is like 1 million bytes
08:45:12 <vandenoever> obviously, "r <- Just $ f" does not work
08:45:14 <glguy> sm: Right, that's the job of the tls package
08:45:17 <lyxia> vandenoever: fmap Just f
08:45:25 <Gurkenglas> vandenoever, when should you get Nothing?
08:45:47 <amf> is there a Vector cons / snoc operation that is O(1)?
08:45:49 <vandenoever> Gurkenglas: never, i just want to avoid an extra variable
08:45:54 <vandenoever> lyxia: thanks!
08:46:16 <lyxia> (Just -> r) <- f
08:46:26 <glguy> sm: and more specifically the "connection" package
08:46:54 <ertes> EvanR: if you really need that level of control, SDL 2 lets you bind the texture so that you can manually glMapBufferRange it
08:47:03 <Gurkenglas> "r <- Just <$> f" also works, if you import Control.Applicative which is in base. vandenoever, you want to have an argument to a function with a default value that is automatically used when Nothing is given?
08:47:20 <sm> glguy: so if I ever needed to do secure IRC stuff, irc-core is another good option (along with irc-client) ?
08:47:35 <vandenoever> Gurkenglas: no
08:47:40 <sm> not together I mean. alternatives
08:47:42 <saml> does haskell support emoji?
08:47:46 <saml> > "üëç"
08:47:48 <lambdabot>  "\128077"
08:47:52 <vandenoever> "r <- Just <$> f" reads nicer than fmap imo
08:48:02 <saml> looks like it does not support emoji. but that code looks like emoji
08:48:24 <ocramz> Is there a pen-and-paper way to reduce a function in order to understand whether compositions are fused?
08:48:35 <ocramz> e.g. in \f g -> filter g . map f
08:49:14 <glguy> sm: I don't think you'd be able to mix irc-client and irc-core; irc-client assumes more about the structure of your program
08:49:42 <Gurkenglas> ocramz, here's an example of the forcing of a spine: https://i.imgur.com/bxxMUp8.jpg
08:49:45 <glguy> sm: using connection for making secure connections and irc-core for speaking the IRC protocol would make for easy bot work
08:50:08 <lyxia> saml: you can write unicode strings in Haskell like you just did
08:50:11 <dolio> `show` for String prints out numbers for everything but pretty low unicode values. But I don't see what that has to do with 'supporting emoji.'
08:50:45 <EvanR> haskell supports unicode, displaying emoji on something is another story and not really a haskell thing
08:50:47 <sm> glguy: sorry, let me rephrase. I can use irc-core for secure IRC then, even though I don't see anything tls related in the deps ?
08:50:51 <vandenoever> what's used more? fmap or <$>?
08:50:54 <Gurkenglas> Oh wait I think I just confused evaluation with compilation there.
08:51:10 <kadoban> vandenoever: Both are used quite often. It depends what fits better.
08:51:13 <glguy> sm: Yeah, you'd make the connection to the IRC server with the package "connection", which supports TLS
08:51:14 <ertes> sm: irc-core is only a parser/renderer‚Ä¶  you need a separate library for actual network connection
08:51:29 <Gurkenglas> vandenoever, afaik people use <$> iff that does not result in a section
08:51:45 <sm> I see, thanks. How would I figure this out ?
08:51:48 <glguy> sm: irc-core doesn't provide the loop to read lines off the network or to write lines to the network
08:52:08 <glguy> but it's a line oriented protocol, so you can use connection's connectionPut and connectionGetLine to do that
08:52:14 <sm> ah in the readme on github
08:52:23 <vandenoever> ok, great, i'll try to see more cases where i can use either
08:52:40 <glguy> sm: My irc client uses irc-core https://hackage.haskell.org/package/glirc
08:53:17 <sm> nice, I hadn't seen glirc
08:53:33 <glguy> sm: You've seen it in that screenshot from yesterday ;-)
08:53:49 <sm> ok, you are right :)
08:54:18 <glguy> Also we have #haskell-irc if you ever have any irc-core (or IRC in general) questions that you don't want scrolled off in #haskell
08:54:32 <sm> nice
09:09:08 <rgrinberg> How can I create a value of Foreign.C.Types.CTime? I need it for testing.
09:09:51 <ertes> rgrinberg: it's just Int64 in disguise
09:10:47 <ertes> rgrinberg: you can use literals (it's a Num) and convert other number types to it (fromIntegral, round, ‚Ä¶)
09:11:02 <ertes> wait, no‚Ä¶  you can't use 'round', but you can use fromIntegral
09:11:44 <rgrinberg> ertes: ah yes. thank you!
09:14:25 <samus> ciao
09:14:30 <samus> !list
09:17:57 * hackagebot scrape-changes 0.1.0.3 - Scrape websites for changes  https://hackage.haskell.org/package/scrape-changes-0.1.0.3 (2chilled)
09:27:29 <marinheiro> Rudes: I'm also starting Haskell myself. My idea to learn it was to pick something I would normally have no problems doing in other language and then implement that using Haskell
09:27:41 <marinheiro> Since I am on a tight schedule, I am solving small problems on Hackerrank
09:28:04 <kadoban> marinheiro: Learning haskell by *only* doing projects is going to be pretty bad.
09:28:42 <ertes> kadoban: why?
09:29:10 <Welkin> marinheiro: to be warned, the skeleton code they give you for haskell on hackerrank is garbage
09:29:16 <nitrix> I'd re-iterate as, learning Haskell by trial-and-error will only lead to harmful misconceptions and is going to be a slow and painful process.
09:29:18 <marinheiro> kadoban: I studied Haskell before as well. I also have some knowledge in abstract algebra and category theory
09:29:47 <Welkin> written by someone who doesn't use haskell, obviously
09:30:19 <marinheiro> Welkin: why? (I've solved most problems by now)
09:30:21 <nitrix> I had the same thought too when I saw the snippet. No haskell dev would write it like that.
09:30:39 <Welkin> it looks like an imperative programmer wrote it
09:30:39 <kadoban> ertes: Because it's a different language than most people come in knowing. Doing that tends to just lead to a big ball of frustration.
09:32:41 <marinheiro> Sometimes "looking imperative" is not a bad thing
09:32:43 <ertes> kadoban: i don't think that's necessarily true
09:33:17 <nitrix> That makes it not necessarily wrong :]
09:33:25 <marinheiro> Specially when you are building an open source project that is not entirely related to functional programming or something like that
09:33:35 <sm> is there a link to this awful snippet ?
09:34:12 <ertes> what leads to frustration is when people try to rush it, but primarily doing an actual project is more likely to work wonders
09:34:22 <marinheiro> sm: I assume it is this one: http://pastebin.com/F6X3APzj
09:34:47 <johnw> that snippet is not evil
09:34:56 <sm> marinheiro: thanks. That's a bit of an anticlimax :)
09:34:59 <Welkin> marinheiro: it gets a lot worse later on
09:35:31 <marinheiro> Welkin: Could you elaborate on that?
09:35:46 <Welkin> marinheiro: you'll see as you get further through them
09:35:56 <nitrix> sm: It was a lot worse than that. The other exercises are funnier.
09:36:04 <marinheiro> Welkin: I've solved pretty much all the problems by now
09:36:19 <marinheiro> Welkin: I think I only have to solve the last one in the Parser category
09:37:16 <sm> in addition to "study haskell" and "write your own haskell projects" I'd like to add "read other haskell projects" for quick learning
09:37:42 <sm> if you can't get an actual mentor, which is of course the fastest
09:37:44 <Welkin> doing little exercises like those won't help you learn haskell very well
09:37:46 <nitrix> Learning = studying + writing + reading
09:37:49 <nitrix> Sounds about right.
09:37:57 <johnw> sm: also add, consume the still beating heart of one who loves Haskell
09:38:00 <Welkin> I did a lot of project euler and other exercises but it didn't help me at all
09:38:10 <sm> johnw oh well yes there's that :)
09:38:10 <Welkin> what helped was by doing a medium size project in yesod
09:38:46 <Welkin> which required reading a lot of source code
09:43:04 <ertes> finally: be sure to stay away from lenspires, unless you want to become a lenspire yourself‚Ä¶  before you know it you'll be sucking the functors and foldables out of singletons
09:46:16 <chsn> in ghc8.0, is there a flag to say "no implicit prlude; make everything strict by default" ?
09:46:44 <monochrom> there are two flags, one for each.
09:47:15 <chsn> I know about NoImplicitPrlude
09:47:18 <chsn> what is the other one?
09:47:23 <cocreature> -XStrict
09:48:24 <monochrom> or -XStrictData
09:48:26 <chsn> thanks
09:48:36 <chsn> https://ghc.haskell.org/trac/ghc/wiki/StrictPragma says Strict implies StcictData
09:48:41 <chsn> almost implying that "Strict" is stronger
09:48:53 <monochrom> yes, Strict is more than StrictData
09:49:39 <thomasd> can I be a xen haskeller without knowing the lens library?
09:49:52 <monochrom> what is xen?
09:50:02 <thomasd> you know, one with the code
09:50:13 <chsn> let xen = zen in ...
09:50:16 <monochrom> I don't know.
09:50:45 <thomasd> right, "zen"
09:51:12 <monochrom> then yes.
09:51:15 <thomasd> let xen = zen in "can I be a xen haskeller..."
09:51:38 <thomasd> ok, thanks
09:51:55 <monochrom> I don't actually know why programmers think of zen as a high achievement.
09:52:20 <Welkin> what
09:52:22 <monochrom> zen is like the anti-thesis to any achievement at all.
09:52:55 <ahihi> being a xen (half-life) haskeller sounds a lot more interesting
09:53:24 <monochrom> a zenist doesn't get anything done, in fact is against getting anything done. a zenist only asks you back questions. never solutions or products.
09:53:24 <sm> quieting unnecessary noise is quite an achievement
09:54:27 <chsn> yeah; I tend to view zen as "minimalist -- nothing extra"
09:54:41 <chsn> it's like a swordsman who kills his enemy with the minimal amount of energy / effort expended
09:54:57 <chsn> similarly, 'zen code' in the sense of 'what is the simpliest/minimalist solution to slaughter the problem before me'
09:55:22 <chsn> this, in contrast, to brute forice, i.e. beating someone to death by brute force traumar using a club or something
09:56:08 <monochrom> yes, but this is occam razor, not zen. I think Westerners are fascinated by Zenism but greatly misunderstands it.
09:56:23 <nitrix> I dream of the day where people are going to express their thoughts clearly without dubious analogies.
09:56:44 <chsn> I have not yet achieved the zen of writing yet.
09:57:12 <monochrom> In front of a question, whereas Occam Razor goes for a simple answer, Zenism doesn't even answer, it just asks back "why do you ask?"
09:57:13 <Cale> Desire is the root of suffering. You don't need a solution to the problem, only to realise that the problem is your own fascination with impermanent things.
09:57:33 <thomasd> this is why haskell irc is bomb
09:57:49 <sm> monochrom: it's a teaching technique
09:58:23 <thomasd> I think the point of chasing zen is to understand that it is a *probably* helpful state of mind to exist in for short period of time
09:58:43 <ahihi> Cale: that's what I like to tell my boss
09:59:12 <thomasd> just like programming is a great mental exercise, getting to a zen state can be as well. It doesn't mean we should pursue it permanantly
09:59:51 <thomasd> clearing the mind is often harder than achieving intense focus
10:00:26 <Welkin> it is intense focus
10:00:28 <johnw> Cale: doesn't Zen say that the root of suffering is attachment?
10:00:29 <Welkin> focus on nothing
10:00:44 <monochrom> No, that's Jediism
10:00:52 <thomasd> lmao
10:00:56 <johnw> 'Attachment is the origin, the root of suffering; hence it is the cause of suffering.'
10:01:01 <johnw> anyway
10:01:14 * monochrom is just mincing words here :)
10:01:31 <chsn> I don't get this; can you explain this in terms of GADTs, types, and monads?
10:02:01 <Welkin> chsn: no
10:02:08 <Welkin> that is what's wrong with programmers
10:02:10 <monochrom> I think I can, if I'm given research funding of $10000 per year
10:02:15 <Welkin> everything has to be a "programming analogy"
10:02:50 <chsn> monochrom: 10k? I think philosophy Phd students get paid more than that, i.e. 30K / year
10:02:58 * hackagebot hxt-css 0.1.0.3 - CSS selectors for HXT  https://hackage.haskell.org/package/hxt-css-0.1.0.3 (MariosTitas)
10:03:01 * hackagebot Frames 0.1.6 - Data frames For working with tabular data files  https://hackage.haskell.org/package/Frames-0.1.6 (AnthonyCowley)
10:03:03 <Welkin> chsn: 24k
10:03:08 <monochrom> and yet, no one pays me that.
10:03:40 <dominik> Hi, anyone knows why this implementation of permutations is so inefficient?
10:03:41 <Cale> johnw: I don't really know much about it, but I would have thought that's a way of saying basically the same thing.
10:03:45 <dominik> http://lpaste.net/179861
10:04:40 <dominik> when quickchecking it against Data.List's `permutations' I have to abort it because it is awefully slow.
10:04:46 <joshfreck>  /join emacs
10:05:18 <nitrix> I think that insert is what's slow.
10:05:41 <Welkin> dominik: look at the source for `permutations`
10:06:24 <Cale> Are you sure it's not just slow because you're comparing very long lists?
10:06:54 <dominik> Cale: hmm, I've to check :D
10:06:57 <Cale> If QuickCheck were to happen to supply a list of length 30 or something
10:07:01 <dominik> *I have to
10:07:25 <sm> stupid haskell. Did not process my billion items instantly
10:07:37 <Cale> > product [1..30]
10:07:40 <lambdabot>  265252859812191058636308480000000
10:08:25 <sm> that's why this FP thing will never catch on. Constantly with the hard to debug performance problems 
10:08:35 <cocreature> sm: the problem is that you have forced the evaluation otherwise it would be instant. so it‚Äôs just a case of removing strictness
10:12:39 <dominik> yes, my lists were to big :D
10:13:22 <dominik> but even then, I think my own perms is a little slower than permutations. I need to look at permutations' source.
10:13:29 <dominik> thanks! :-)
10:13:37 <cocreature> permutations source is really weird iirc
10:13:41 <bsmt> alright, trying again... I have a two simple data types. With one, most of the constructors take a parameter that is part of the other type. However, in the problem, some of the constructors are invalid and should type error. How do I do that?
10:13:44 <cocreature> because it tries very hard to be as lazy as possible
10:13:45 <bsmt> here's an example: http://lpaste.net/5542863004401401856
10:13:52 <cocreature> there is a stackoverflow post somewhere explaining the implementation
10:18:53 <marinheiro> sm: I don't know if you are being sarcastic, but I agree that it is hard to reason about the performance of FP code
10:19:32 <lyxia> bsmt: does your language have other constraints of a similar nature?
10:19:50 <bsmt> not sure what you mean
10:19:59 <sm> marinheiro: yes I was being silly. And yes it actually is hard sometimes
10:20:10 <lyxia> bsmt: I can come up with solutions for this particular example but I don't think they will scale to your actual problem.
10:20:19 <bsmt> oh
10:20:27 <bsmt> yeah, it does
10:21:14 <lyxia> bsmt: do you have other instructions that depend on other registers?
10:21:20 <bsmt> yeah
10:21:34 <bsmt> this is just a simplified example of the actual problem
10:22:46 <Rudes> who wants to chew me apart for how shit my code is so i can learn how to be better?
10:25:04 <jle`> Rudes: just post it, the people who do will do it
10:25:07 <jle`> asking doesn't help :)
10:25:16 <Rudes> http://cryopaste.com/61b475
10:25:17 <sm> damn it Rudes! that code is rubbish. Start over
10:25:19 <Rudes> jle`: rip
10:25:24 <nitrix> Rudes: Paste on lpaste.net if you can.
10:25:25 <Rudes> sm: i can always count on you
10:25:30 <Rudes> sure
10:25:32 <nitrix> Rudes: We have the avbility to annotate code.
10:25:56 <bsmt> ah I remember this exercise
10:26:01 <lpaste> Rudes pasted ‚Äúcredit_card_validate‚Äù at http://lpaste.net/179869
10:26:05 <sm> hey, that looks useful
10:26:21 <Rudes> pasted
10:26:25 <ertes> Rudes:
10:26:27 <ertes> :t divMod
10:26:29 <lambdabot> Integral a => a -> a -> (a, a)
10:26:31 <Rudes> nitrix: i don't even know what aht means but sounds cool
10:27:00 <lyxia> bsmt: is the set of registers fixed for your application?
10:27:09 <bsmt> yes
10:27:13 <nitrix> Rudes: Your getEveryOther wont work for any numbers beyond 2.
10:27:23 <srhb> Rudes: alighning k, r like that is extremely uncommon (and probably confusing to most)
10:27:24 <nitrix> Rudes: As the list literal does [1..2]
10:27:31 <nickpascucci> Why do you need to sort in doubleEveryOther?
10:27:45 <Rudes> nitrix: try it man, it works with any list you give it.
10:27:59 * hackagebot tal 0.1.0.0 - An implementation of Typed Assembly Language (Morrisett, Walker, Crary, Glew)  https://hackage.haskell.org/package/tal-0.1.0.0 (sweirich)
10:28:00 <nitrix> Rudes: Not any list, any `n` is what I said.
10:28:01 <Rudes> i couldn't figure out how to double every other without splitting odds and evens and pushing them back together
10:28:02 <ertes> Rudes: one style note that might sound superficial, but may have an impact on how you think about your code:  try to name your pure functions nouns rather than verbs-to-do-something-with-nouns
10:28:11 <ertes> Rudes: "getEveryOther" ‚Üí everyOther
10:28:23 <Welkin> Rudes: write a recursive function that takes two list items at once
10:29:04 <nitrix> Rudes: getEveryOther will only work for `n` that is `1` or `2`, because the cycle zipped is hardcoded to [1..2] instead of [1..n].
10:29:05 <ongy> how efficient is GHC with guard syntax and pattern matches? I guess guards are O(n)? Pattern matches the same?
10:29:17 <Rudes> nitrix: oh i see what you mean
10:29:21 <Welkin> ongy: it checks from top to bottom
10:29:48 <ongy> so a function with 50 lines will be slow-ish
10:29:49 <ertes> ongy: semantically it's checked in order, but technically constructor matching is O(1)
10:29:55 <ertes> ongy: per layer
10:30:10 <puregreen> some patterns can be turned into lookup tables (e.g. numbers, or chars, or probably constructors)
10:30:11 <ertes> ongy: nope, only if you have 50 guards, but if you have 50 constructor matches, then no
10:30:23 <Welkin> who would have that many?
10:30:26 <nickpascucci> Rudes: So you have a list that has every other element repeated, but why do you need the output to be sorted? It won't match the input order either way
10:30:34 <Welkin> most of the time it's less than 5
10:30:40 <ongy> Welkin: https://github.com/Ongy/pulseaudio/blob/master/src/Sound/Pulse/Def.hsc#L409
10:30:54 <Rudes> nickpascucci: i mean, you're right, i think it was for me.
10:31:12 <Welkin> why not use a pattern synonym?
10:31:14 <Rudes> oh, because the exercise wanted it to return in order i think
10:31:18 <nickpascucci> Ah, gotcha
10:32:10 <ongy> Welkin: how would I do that? And what's the benefit of doing it?
10:32:16 <Rudes> nickpascucci: but you're right, doesn't matter
10:32:42 <nitrix> My only complaint is the naming of functions. listToInt doesn't do what it says, it's actually dropping the head.
10:32:56 <nitrix> sumDigits isn't summing them, it's doubling every others.
10:33:01 <Welkin> I guess that wouldn't help really
10:33:02 <nitrix> etc.
10:33:07 <ertes> i don't see how pattern synonyms would help there
10:33:32 <ertes> ongy: matching ChannelPosition is O(1)
10:33:46 <Rudes> nickpascucci: oh nvm, it does matter, it changes whether validate returns correctly
10:33:49 <lpaste> lyxia annotated ‚Äúahem.hs‚Äù with ‚Äúbsmt: warning, ugly hack‚Äù at http://lpaste.net/5542863004401401856#a179872
10:33:52 <ongy> ertes: I guess, channelPositionFromInt will be O(n) though, right?
10:33:58 <nitrix> Rudes: In other words, you're too inclined to describe the representation of things in your function names than what their purpose are.
10:34:14 <ertes> ongy: yeah, that looks O(n) to me
10:34:15 <ongy> is there a better pattern to use that's something like O(log n)? Or should I stick to guards?
10:34:36 <bsmt> thanks lyxia
10:34:38 <ertes> ongy: not sure why they wrote it that way‚Ä¶  an IntMap lookup would have worked better
10:34:38 <ongy> I could make a static map with all entries and lookup... hm
10:34:53 <Welkin> ertes: ongy wrote that I thought
10:34:53 <Welkin> lol
10:34:55 <ongy> ertes: that's my code. Well, lazy autogeneration
10:35:06 <bsmt> I guess that could  work. problem is, I have like 32+ registers in the real problem, so it's going to get messy fast
10:35:16 <lyxia> ouch
10:35:17 <Rudes> nitrix: actually the tail was supposed to be removed, i was having a stack issue but i fixed it elswhere, so ignore the tail
10:35:21 <ertes> ongy: ah, then:  not sure why you wrote it that way, but i guess that's why you're asking =)
10:35:21 <bsmt> maybe it's time for template haskell
10:35:23 <ongy> so I want to do an IntMap and lookup. Sounds good
10:35:32 <ongy> ertes: exactly
10:35:42 <Rudes> nitrix: and sum does sum them, after it doubles everyother
10:35:43 <ertes> ongy: make sure the IntMap is a CAF
10:35:55 <nitrix> ongy: GHC will actually merge some pattern and guards together.
10:36:01 <ongy> ertes: how will I do that?
10:36:06 <ertes> ongy: make it a top-level definition that has no constraints
10:36:15 <ertes> ongy: myTable :: IntMap ChannelPosition
10:36:31 <ongy> ok, that's would I would have done either way
10:36:52 <nitrix> foo (0:_);  foo (1:_); foo (_:xs);  GHC knows that if it's 0, it cannot possibly be also 1, so it'll transform the two patterns into a grouped case expression.
10:36:55 <nitrix> ongy: ^
10:37:08 <lyxia> bsmt: I think you can replace the 4 parameters of Register with a single one with more possible values
10:37:10 <ertes> ongy: alternatively (probably even better) you can attach the definition to the function instead:
10:37:15 <ongy> while we are at it, how bad is https://github.com/Ongy/pulseaudio/blob/master/src/Sound/Pulse/Def.hsc#L750 ? (like I said, lazy autogeneration I wrote but I don't really know if there's something better for this)
10:37:46 <ertes> ongy: channelPositionFromInt = (\k -> Mi.lookup k xs)  where xs = ‚Ä¶
10:37:50 <lyxia> bsmt: and then AND and OR would take constraints instead of exploiting type unification like I did
10:37:56 <bsmt> lyxia: like doing data Register = Reg Integer?
10:37:57 <ongy> nitrix: I can't do that with ints, can I?
10:38:23 <ertes> ongy: note that with both approaches there is at east a one-time O(n * log n) hit
10:39:01 <ongy> :( can the compiler not do that @compile time?
10:39:08 <ongy> since it's pure with all values known
10:39:49 <nitrix> ongy: Those were ints.
10:39:50 <ertes> GHC-haskell is surprisingly terrible at precomputing stuff =)
10:39:53 <lyxia> bsmt: just a moment I'm making another paste
10:39:57 <EvanR> if it were pure, all values known, and total that would be possible
10:39:57 <bsmt> thanks
10:40:12 <EvanR> but ghc takes the halting problem seriously
10:40:26 <EvanR> except for incoherent instances
10:40:33 <ertes> ongy: i'd try to turn it into a large pattern-match first and see what GHC produces
10:40:34 <EvanR> wait, undecidable
10:40:46 <ertes> ongy: if you're lucky, it may come up with an O(1) table lookup all by itself
10:41:42 <Welkin> ertes: so all case expressions produce constant time code?
10:41:44 <ongy> I thought I can only pattern match on constructors? How would I do the match with CInt?
10:41:55 <Welkin> you can match on literals
10:42:20 <ertes> ongy: literals are valid patterns
10:42:33 <ongy> ah
10:42:35 <ertes> Welkin: no, but constructor matching does
10:42:36 <ongy> didn't know that
10:42:56 <Welkin> and if you need to split it up into a couple branches, you can add a case expression too
10:43:00 * hackagebot unagi-bloomfilter 0.1.0.0 - A fast, cache-efficient, concurrent bloom filter  https://hackage.haskell.org/package/unagi-bloomfilter-0.1.0.0 (BrandonSimmons)
10:45:30 <puregreen> I played with ghc-core and it looks like GHC does binary search (?) both for patterns and for guards (guards are actually turned into a case by the optimiser)
10:45:50 <puregreen> and https://ghc.haskell.org/trac/ghc/ticket/10137 says that in GHC 8 the binary search is replaced by a switch table
10:46:31 <ertes> puregreen: it does for guards?  has it solved the halting problem?
10:46:49 <ertes> (i wouldn't be surprised if it did)
10:46:49 <lpaste> Rudes revised ‚Äúcredit_card_validate‚Äù: ‚Äúcredit_card_validate‚Äù at http://lpaste.net/179869
10:47:04 <Rudes> how are those updates
10:47:09 <puregreen> ertes: for very simple guards (a == const1, a == const2, ...)
10:48:12 <sm> damn it Rudes, how many times...
10:48:22 <Rudes> sm: at least twice
10:48:28 <glguy> .greo
10:48:30 <sm> I like the shouting part
10:48:39 <ertes> puregreen: interesting, didn't know that
10:49:12 <glguy> heh, keyboard off-by-one error
10:49:14 <ertes> ongy: seems like with GHC your code is at worst O(log n) and O(1) with GHC 8 after all =)
10:50:13 <sm> Rudes: to quiet vim, probably add "module SomeName where" at top
10:50:41 <Rudes> sm: yeah, good idea.
10:51:21 <sm> could do validate card = cardSum == 0 where ...
10:51:30 <ongy> can I add a compile flag for a single file in cabal?
10:51:54 <ertes> ongy: {-# OPTIONS_GHC -my-flag1 -my-flag2 #-}
10:52:00 <ongy> thx
10:52:20 <sm> s/toIntList/digits/ ?
10:53:00 * hackagebot clckwrks-plugin-page 0.4.3.4 - support for CMS/Blogging in clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-page-0.4.3.4 (JeremyShaw)
10:54:23 <Rudes> sm: sure
10:56:06 <Rudes> sm: did the same thing with lintToInt to ints
10:56:09 <ongy> how do I best check if GHC really emits O(1) code? -ddump-simple?
10:56:32 <johnw> ongy: there is a "ghc-core" utility that's quite nice
10:58:14 <ertes> i'm afraid that core is not low-level enough in this case
10:58:20 <puregreen> ghc-core emits ASM too
10:58:31 <puregreen> you probably want to check Cmm instead, tho
10:58:32 <ongy> it's a case of
10:59:53 <sm> Rudes: otherwise, if it works I think it's fine. You could golf it down to a half or quarter the size, but why bother
11:00:03 <d3z> Anyone know where: '[a -> b] -> [a] -> [b]' lives or is called?  It's like zip, but the first argument is a list of functions to apply.
11:00:09 <Rudes> sm: to learn...
11:00:20 <Rudes> sm: any golf ideas are apperciated
11:00:36 <sm> must.. resist..
11:00:45 <Rudes> sm: do you mean like instead of having functions have one big function that's filled with wheres or whatever
11:01:10 <Hijiri> :t zipWith id
11:01:10 <kadoban> d3z: Sounds like the Applicative instance for ZipList
11:01:12 <lambdabot> [b -> c] -> [b] -> [c]
11:01:15 <hpc> :t (<*>)
11:01:17 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:01:22 <kadoban> Or just that, yeah.
11:01:50 <puregreen> I'd say that zipWith ($) conveys the intent better
11:01:59 <hpc> i can't wait for lambdabot to ghc8 so we can use that type application thingy
11:02:20 <ongy> type applicative thingy?
11:03:31 <hpc> the syntax is escaping me
11:03:31 <lyxia> bsmt: Unfortunately I'm getting stuck :/
11:03:41 <puregreen> :t <$> @[]
11:03:43 <lambdabot> error: parse error on input ‚Äò<$>‚Äô
11:03:45 <ertes> ongy: style note: instead of writing those two functions you may want to write an Enum instance
11:03:48 <hpc> ah yeah, that
11:04:03 <Rudes> is there a way to use ghci to look at functions that aren't in scope?
11:04:04 <hpc> (<*>) @[] means let f = []
11:04:21 <hpc> (you apply the type [] to the first type quantification)
11:04:25 <puregreen> Rudes: yep, just use the fully qualified anme
11:04:26 <puregreen> *name
11:04:30 <Rudes> like if i remember the function but not the package
11:04:30 <puregreen> :t Data.List.sort
11:04:32 <lambdabot> Ord a => [a] -> [a]
11:04:36 <ongy> ertes: I have mainly opted to those because I use the same for flags ([a] <-> CInt conversions) and cane reuse that.
11:04:46 <hpc> Rudes: check out hoogle
11:04:48 <Rudes> puregreen: yeah but i don't always remember the FQN
11:04:49 <sm> Rudes: just little stuff like writing map (*2) ... inline instead of defining doubleList which is only used once. But it's often a matter of taste, naming more things is good when you need more clarity
11:04:54 <puregreen> okay, then hoogle or hayoo
11:05:05 <puregreen> hayoo has more libraries, I think
11:05:07 <Rudes> sm: i hear ya
11:05:08 <puregreen> @where hayoo
11:05:08 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
11:05:16 <Rudes> hpc: well yeah but switching to my browser is so hard
11:05:17 <hpc> hoogle is much better now
11:05:26 <hpc> but it still has some weird search keyword stuff
11:05:30 <sm> http://hoogle.haskell.org has more libs
11:05:32 <hpc> hoogle also has a package
11:05:34 <Welkin> hpc: it covers everything hayoo does?
11:05:35 <hpc> @hoogle hoogle
11:05:38 <lambdabot> Yi.Hoogle hoogle :: YiM YiString
11:05:38 <lambdabot> package hoogle
11:05:38 <lambdabot> Hoogle hoogle :: [String] -> IO ()
11:05:39 <ongy> *can, and actually I only use the toInt
11:05:41 <hpc> which you can run as a command-line tool
11:06:13 <Rotaerk> lmhtfy
11:06:13 <Rudes> hpc do i install that with cabal?
11:06:25 <dfeuer> Still looking for help setting up a class hierarchy for sequence-like things. Anyone willing to help?
11:06:31 <d3z> puregreen: Thanks, I think the zipWith ($) matches good.
11:06:35 <Rudes> Rotaerk: don't give them any ideas
11:06:35 <hpc> Welkin: probably not since i have never been let down by hayoo, it's just better than it was
11:06:39 <Rotaerk> :P
11:06:56 <hpc> i haven't used noohoogle long enough to be able to say with any statistical significance
11:07:58 <Jenaf> the thing iwth this signature works, but its a bit ugly
11:08:06 <Jenaf> foo :: Int -> Int -> Int  -> Int -> Map.Map Int Int ->(Int,Int,Int,Int,Map.Map Int Int)
11:08:07 <hpc> Rudes: yeah - it's an executable so it'll install into ~/.cabal/bin or somewhere like that, and you can copy it out to somewhere on your path
11:08:25 <hpc> Rudes: or add that directory to your path if you don't mind it being user-specific
11:08:33 <Rudes> hpc: i'm lazy, i added .cabal/bin to my path a while ago
11:08:39 <hpc> ah well that's alright then :D
11:08:52 <Rudes> hpc: yeah, i'm the only user for now
11:08:59 <Rudes> it's a slow build
11:08:59 <hpc> you'll also need to run hoogle in a particular way to build the index
11:09:03 <hpc> and it'll tell you how
11:09:09 <Rudes> hpc: cool
11:10:56 <sm> Rudes: https://www.google.com/search?q=credit+card+validation+haskell should give you some more ideas
11:12:42 <Rudes> hpc: dammit...       network-uri-2.6.1.0 network-2.4.1.2
11:12:54 <Rudes> apparently hoogle has conflic import
11:13:52 <Rudes> sm: oh man, these are so much better
11:14:00 <hpc> or the version of hoogle you're trying to install wants to depend on something you don't have installed
11:14:12 <hpc> can you paste the whole error?
11:14:13 <hpc> @lpaste
11:14:13 <lambdabot> Haskell pastebin: http://lpaste.net/
11:14:14 <dfeuer> @ask mniip Can you give me an example of a MonadFix whose mfix would perform the action multiple times? I don't think that's supposed to happen.
11:14:14 <lambdabot> Consider it noted.
11:14:36 <Rudes> dfeuer: what did you just do?
11:14:54 <dfeuer> Rudes, I just left a message for mniip.
11:15:04 <lpaste> Rudes pasted ‚Äúhoogle error‚Äù at http://lpaste.net/179888
11:15:17 <Rudes> dfeuer: man that's cool
11:15:28 <Rudes> is lambdabot's source somewhere?
11:15:40 <Rudes> nvm
11:16:03 <dfeuer> Rudes, yes, it is.
11:16:25 <dfeuer> https://hackage.haskell.org/package/lambdabot
11:16:49 <Jenaf> would anyone care to give me some styletips?
11:17:10 <Jenaf> I just solved projectEuler Problem14 but I'd be happy about some style tips
11:17:12 <Jenaf> https://gist.github.com/anonymous/e7f2ce30526238fdfcf2c47f47c70975
11:17:21 <Jenaf> prepare for soome monsters
11:17:27 <athan> Hey everyone, is there a generalized form of how `compare` over lists is zippy? Is this something like align?
11:17:31 <athan> @check \xs ys -> fold (zipWith compare xs ys) == compare xs ys
11:17:34 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 1 shrink):
11:17:34 <lambdabot>  [(),()] []
11:17:59 <Rudes> hpc: i posted the error if you missed it
11:18:08 <hpc> i saw, reading and thinking
11:18:14 <Rudes> hpc: gotcha
11:18:37 <Jenaf> I'm aware of some uncatched errors in the functions, but the code is small enough that i skipped exceptions etc
11:18:46 <dfeuer> Cale, you got a minute for something that has nothing to do with Data.Map?
11:19:48 <puregreen> probably Data.Sequence
11:19:49 <Rudes> hpc: i tried hiding it but 
11:19:50 <puregreen> Cale, run
11:20:10 <hpc> Rudes: okay, you've bumped into something pretty interestingly annoying
11:20:22 <puregreen> (just kidding)
11:20:23 <Rudes> hpc: you're telling me
11:21:45 <hpc> Rudes: https://hackage.haskell.org/package/network-uri-2.6.1.0
11:21:46 <dmwit_> Rudes: You may like https://downloads.haskell.org/~ghc/7.0.2/docs/html/users_guide/syntax-extns.html#package-imports
11:21:49 <Cale> dfeuer: What's up?
11:21:54 <hpc> "In network-2.6 the Network.URI module was split off from the network package into this package. If you're using the Network.URI module you can automatically get it from the right package by adding this to your .cabal file:" right at the top
11:22:05 <Cale> puregreen: haha
11:22:30 <dfeuer> Cale, see PM.
11:22:51 <hpc> Rudes: you can follow that workaround, or a better solution might also be to install an older version of hoogle
11:22:55 <Rudes> dmwit: that'd be great if i was using my own package
11:23:03 <hpc> 4.2.23 might work
11:23:58 <hpc> (following that workaround involves downloading the package and editing it before installing, which is usually a bad idea)
11:25:17 <glguy> Rudes: The hoogle maintainer passed on figuring out which versions of packages it is compatible with on to you
11:25:26 <hpc> to give a very broad moral to the story, this is why good package authoring has both lower and upper bounds on package versions
11:25:29 <Rudes> glguy: i see
11:28:01 * hackagebot graphmod 1.3 - Present the module dependencies of a program as a "dot" graph.  https://hackage.haskell.org/package/graphmod-1.3 (IavorDiatchki)
11:29:01 <Rudes> hpc: maybe we should submit a bug or pull request
11:31:31 <glguy> Rudes: A package with that many unconstrained dependencies is probably maintained by someone who consiously doesn't care
11:32:02 <Rudes> glguy: fair
11:32:21 <antipsychiatry> The bastard israelites atack me every day with chemicals in the air in the home! This criminals informants used by Mossad- kiling machine!!!! I am pro-health and Antipsychiatry,anti GMO....antiVACCINE, anti-chipping people with nanochip or RFID chip! These bastards think they are a superior rase...
11:32:28 --- mode: ChanServ set +o glguy
11:32:28 --- mode: glguy set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.80.246.137.210
11:32:29 --- kick: antipsychiatry was kicked by glguy (antipsychiatry)
11:32:36 <Rudes> hpc: lol so version 4.2.23 error'd with Module `Data.Conduit' does not export `runResourceT'
11:35:21 <drewbert> Has anyone here used esqueleto?
11:35:45 <glguy> drewbert: If you have a question about esqueleto it's better to just ask it
11:35:49 <Rudes> according to the github it was fixed in .31
11:36:46 <drewbert> @glguy I mostly wanted to start a conversation about adding to it.  My application makes heavy use of "INSERT .. ON DUPLICATE KEY UPDATE ..." and I was curious if anybody had insights into that pursuit.
11:36:47 <lambdabot> Unknown command, try @list
11:36:58 <drewbert> glguy: I mostly wanted to start a conversation about adding to it.  My application makes heavy use of "INSERT .. ON DUPLICATE KEY UPDATE ..." and I was curious if anybody had insights into that pursuit.
11:37:26 --- mode: glguy set -o glguy
11:41:33 <Tehnix> drewbert: the first message got sent, just lambdabot that automatically reacts to @ commands :)
11:41:58 <Tehnix> I'd actually also be interested in `... ON DUPLICATE UPDATE`, I'll see if I can find something
11:44:54 <drewbert> Tehnix: Ahh, right.  It's been a while since I've gotten to hang out in this room.  Thanks for taking a look.  Let me know what you find.
11:50:52 <Ocisaac> Hello
11:51:25 <glguy> hi
11:51:33 <Ocisaac> I'm new here
11:51:40 <Ocisaac> both IRC and hasell
11:51:46 <Ocisaac> Haskell*
11:51:47 <hpc> have you tried turning it off and on again?
11:51:48 <jackhill> Ocisaac: welcome :)
11:51:53 <Tehnix> Welcome to! :)
11:52:52 <jackhill> Ocisaac: do you have a specific question, or are you just here to watch and listen (that's mostly what I do).
11:53:00 <Ocisaac> Can I join multiple chats in the same time?
11:53:11 <Ocisaac> I'll just watch for now
11:54:08 <chsn> what's the difference between https://github.com/bjpop/ministg and the stg that ghc outputs -- is this enough for writing a backend taht can interpret ghc's output, or do we need to handle more stg operations?
11:54:28 <Rudes> hpc: got hoogle, had to fetch and then edit the cabal file for < 2.6 and install network-uri-2.5 but dammit it's installed
11:54:38 <hpc> Rudes: nice
11:54:43 <Tehnix> Ocisaac: sure sure, on IRC they are called channles, and you can join as many as you want :)
11:54:51 <Rudes> hpc: that guy needs to fix his file
11:55:08 <hpc> Rudes: btw you've entered the weird zone of haskell that is "things lambdabot does"
11:55:32 <Rudes> lambdabot will fix my cabal files for me?
11:55:36 <hpc> i don't know why, but everything in that realm is more difficult
11:56:05 <hpc> Rudes: it's a jokey observation that packages lambdabot depends on tend to be tough to get working :P
11:56:28 <Rudes> go figure
11:58:38 <sm> Rudes: if you just want to get hoogle working, stack install hoogle. Definitely worth a bug report on hoogle too
12:02:00 <Rudes> sm: https://github.com/ndmitchell/hoogle/issues/181
12:04:14 <sm> FYI, with cabal you can add quick constraints like this: cabal install hoogle --constraint 'network < 2.6'
12:04:19 <hpc> sm: that version conflict included a 3-year-old version of one of the packages, stack is a pretty invasive solution
12:04:41 <Rudes> sm: man that would have been great to know 10 mins ago
12:05:07 <ongy> u/bu11
12:05:28 <ongy> oops
12:05:50 <Rudes> s/bull/bullshit/g cus u bullshit
12:06:58 <Tehnix> drewbert: As far as I can see it doesn't really exist yet :/ I mean, you can write a CASE that sort does the same (https://hackage.haskell.org/package/esqueleto-2.4.3/docs/Database-Esqueleto.html#v:case_) but that is quite a roundabout way of achiving that (unless you can somehow nicely generalize it)
12:07:15 <Rudes> and now i have hoolge in vim, much better than that damn browser
12:07:39 <Tehnix> drewbert: I think it's worth opening an issue about it though! :) They state that "We'd like you to be able to use esqueleto for all of your queries, no exceptions. Send a pull request or open an issue on our project page (https://github.com/prowdsponsor/esqueleto) if there's anything missing that you'd like to see"
12:09:08 <sm> Rudes: also, "cabal install hoogle" worked here without the constraint (starting from a fresh package db)
12:10:01 <hpc> sm: the error had a 3-year-old package version in it, so the install was exceptionally not-fresh and switching to stack would likely mean redoing 3 years of package installs
12:10:14 <hpc> (but also yes that is true)
12:12:04 <Rudes> sm: don't tell him that
12:14:22 <slack1256T> If I make a program that uses lets say (pipes, lens, gtk) I got the feeling that even building such package with cabal will be troublesome
12:14:41 <puregreen> pipes is easy
12:14:42 <slack1256T> what are my alternatives? stackage works for this use case? (never touched stack)
12:14:52 <puregreen> lens will likely build fine too
12:14:54 <puregreen> gtk... yeah
12:15:05 <dfeuer> puregreen, pipes is easy? I find its documentation rather hard.
12:15:15 <puregreen> easy-to-buid
12:15:16 <puregreen> *
12:15:17 <johnw> pipes is easy, it's documentation is hard
12:15:27 <slack1256T> puregreen: well then something harder to build...
12:15:52 <puregreen> if you choose something hard to build then I guess it will be indeed hard to build :P
12:15:55 <dfeuer> johnw, I never got much past the documentation.
12:16:08 <slack1256T> dfeuer: off topic, but working how cat, for and friend 'ought' to work helped me a bit
12:16:14 <johnw> dfeuer: the underlying concept is actually trivial, but the machinery on top gets complicated rather quickly
12:16:25 <slack1256T> plus bidirectionality is really cool!
12:16:39 <dfeuer> johnw, somewhat like lens?
12:16:41 <cocreature> I found the docs of pipes extremly useful
12:16:43 <Tehnix> slack1256T: seems stackage has both `gtk-0.14.2` and `gtk3-0.14.2`, so I'd definitely say go that way. (have had tons of issues with cabal there..)
12:16:44 <johnw> it's the free monad generated by a bi-directional get/put term algebra, period
12:17:12 <dfeuer> johnw, yes, I suppose someone very familiar with category would find that explanation helpful. Sadly, I'm not.
12:17:22 <slack1256T> Tehnix: is that what stackage is right? a consistent set of packages that "play" well with each other?
12:17:38 <Tehnix> slack1256T: pretty much :)
12:17:46 <slack1256T> I can't imagine how painful it must be to reach that consistent set (poor snoyberg)
12:18:31 <puregreen> Tehnix: stack doesn't handle installing non-Haskell libs. A friend was recently building something with GTK on Nix and it wasn't pleasant experience even with stack
12:18:34 <dfeuer> slack1256T, hows's that off-topic?
12:18:52 <slack1256T> dfeuer: offtopic to my main question ;-)
12:19:08 <puregreen> (glib cairo pango pkgconfig gnome3.gtk and modifying the stack.yml file by hand for some reason)
12:19:14 <johnw> off-sub-topic :)
12:19:38 <slack1256T> heh
12:21:08 <slack1256T> oh yeah, what is the common solution to non-haskell libs (C) and stack? A configure script that checks if the libraries are available (gtk)?
12:21:16 <slack1256T> on nixos I could craft the default.nix
12:21:33 <dfeuer> Poll: Henning Thielemann thinks I should name the general merge functions for Data.Map.{Lazy,Strict}.Merge merge and mergeA, rather than my draft names generalMerge and generalMergeA. Do y'all agree?
12:21:34 <kadoban> slack1256T: Mostly you just install the C libs using the OS facilities.
12:21:58 <Tehnix> puregreen: hmm, yeah I could imagine they added a lot of pain :/
12:22:19 <kadoban> dfeuer: is captainMerge an option?
12:22:25 <sm> slack1256T: currently, it's either use only system packages, or guess the system package you need to install from the haskell install errors
12:22:36 <Tehnix> honestly been a while since I played with a native GUI lib, either using Electron or going fullblown Swift or smth
12:22:42 <dfeuer> kadoban, no, it is not.
12:22:51 <kadoban> Damn.
12:23:20 <dfeuer> Sorry, kadoban. I admit that would be cool, but this is Serious Business. Silly names can only go in the source code.
12:23:29 <johnw> I wonder what it even means for a thing to be half-blown
12:23:49 <kadoban> dfeuer: Do you have a link to what these are for? Like it's "general" in what sense?
12:23:53 <ongy> johnw: or 1/4
12:24:40 <slack1256T> I guess I can set cabal/stack to say "opps, mising libgtk+XXXX headers, install those on your system" as a configure script output"
12:25:06 <dfeuer> kadoban, here's the draft documentation: http://treeowl-containers-general-merge.bitballoon.com/data-map-lazy-merge
12:25:09 <sm> slack1256T: I think you could do something like that with a custom Setup.hs script, is that what you're thinking ?
12:25:33 <slack1256T> I kind of dislike having to read a README.md to know how to install a package. The errrors and missing pieces should be shown on the instalation part
12:25:39 <slack1256T> sm: Exactly
12:25:53 <sm> it would be great to have a standard package that helps with that
12:26:01 <dmj`> dfeuer: bit balloon \o/
12:26:10 <sm> nobody does it right now
12:26:13 <slack1256T> I guess gtkhs already does something of that
12:26:29 <slack1256T> I will read them and any library with non trivial FFI
12:26:38 <dfeuer> dmj`, yep, thanks.
12:26:46 <Tehnix> dfeuer: I'd honestly go with `merge` and `mergeA` and then only mark when something is a special case
12:26:46 <ongy> I think getting cabal to check it would be nice aswell. So we can get the error befor it tries to install dependencies for an hour
12:27:13 <dfeuer> Tehnix, I'm not opposed. Just don't want to make the edit unless there's general agreement.
12:27:15 <slack1256T> OK, seems that messing with Setup.hs is what I wanted!
12:27:26 <slack1256T> thanks for hearing my ramblings :-)
12:27:28 <dfeuer> Tehnix, although I don't know what you mean about special cases.
12:27:34 <kadoban> dfeuer: I don't think I have a strong opinion on it, but merge and mergeA seem fine.
12:27:51 <slack1256T> dfeuer: merge, mergeOn ?
12:28:36 <dfeuer> slack1256T, that would not match the containers naming convention at all.
12:28:45 <Tehnix> dfeuer: I mean, if it's neccessary to mark when it's a `generalMerge` I'd assume there to be non-general merges - that said, I don't really have a strong opinion of it either
12:28:47 <slack1256T> there is a compare (`on` ) pattern as weel 
12:28:54 <slack1256T> *well
12:29:00 <slack1256T> oh right
12:29:06 <johnw> comparing, I think you mean?
12:29:07 <dfeuer> slack1256T, that is very much unrelated. This is pure vs. applicative.
12:29:31 * slack1256T should have know from the A at the end of the function
12:29:37 <jle`> asking doesn't help :)
12:29:41 <slack1256T> johnw: comparing it was
12:29:43 <jle`> oops, sorry, accidentally resent a message
12:30:00 <dfeuer> And there's pretty much no sensible way to deal with a Map using any ordering other than the one it was built with.
12:30:38 <dmj`> jle`: o/
12:30:41 <jle`>  \o
12:30:50 <phanimahesh> \o/
12:31:14 <slack1256T> '\o/'
12:31:45 <phanimahesh> \O/
12:32:22 <anubhav_> Hi, I need to install mtl-1.1.0.2 using cabal for GHC-6.12.3. This is for compiling an old project. I'm trying to run `cabal install --with-compiler=/usr/local/bin/ghc-6.12.3 mtl-1.1.0.2`. 
12:32:40 <anubhav_> The command fails with the message `ghc: unrecognised flags: -XHaskell98`
12:34:06 <anubhav_> I checked with ghc-7.6.3, the flag -XHaskell98 is a valid one. But it is unrecognised with GHC-6.12.3. Is cabal trying to use GHC-7.6.3 instead of GHC-6.12.3
12:34:18 <dfeuer> anubhav_, that's some seriously ancient technology.
12:34:53 <Tehnix> anubhav_: perhaps either mtl or something else is enabling it?
12:35:03 <anubhav_> dfeuer : I have no choice but to use an old compiler. :(
12:35:19 <dfeuer> anubhav_, may I ask why?
12:37:45 <Tehnix> anubhav_: Tried checking some of the packages, but doesn't seem I'm much help :/
12:37:54 <anubhav_> dfeuer_, Its for compiling the tool llvm-md. The authors of the tool say it has been written using template haskell that has evolved over the years and their code is not compatible with newer versions of the compiler.
12:39:26 <anubhav_> Thanks Tehnix.
12:39:29 <dfeuer> anubhav_, ouch. It might be a better use of your time to update their code than to try to cobble together a build environment like that.
12:40:40 <slack1256T> probably a bad idea, but nixos still has a ghc 6.12.3 compiler defined
12:40:48 <slack1256T> probably not with binaries
12:41:20 <dfeuer> anubhav_, especially since I'm guessing such an old tool may also be incompatible with modern LLVM.
12:43:58 <anubhav_> dfeuer, I guess so. :(
12:45:19 <anubhav_> slack1256T, I already have built GHC-6.12.3 from source. Only if I could install the mtl library with it. 
12:45:46 <dfeuer> anubhav_, have you tried installing a similarly-old version of cabal?
12:46:08 <dfeuer> Or at least a not-too-much-younger version?
12:47:45 <anubhav_> dfeuer, good idea! thanks! let me try that. 
12:48:58 <dfeuer> anubhav_, I'd guess you might want to go for Cabal-1.16.0.3, but I dont' know for sure.
12:49:45 <seanparsons> Does anyone know if there's a reason why there doesn't appear to be an instance of Generic for Text anywhere?
12:49:57 <dfeuer> seanparsons, because it's an abstract datatype.
12:50:06 <hsk3> Is it possible to create an Imports.hs module in my project, import everything I need in my whole project within Imports.hs, and then only import Imports in all other files? This would be highly convenient for me. Then I don't have to worry about imports in all of my files.
12:50:08 <dfeuer> It doesn't make much sense to give it a Generic instantce.
12:50:11 <dfeuer> instance.
12:50:26 <dfeuer> hsk3, you *can*, but that's a little gross.
12:50:37 <seanparsons> That makes perfect sense the moment you said that, thanks dfeuer.
12:51:00 <dfeuer> hsk3, module Imports (module Data.List, module Foo, ....) where import Data.List; import Foo; ...
12:51:03 <puregreen> hsk3: see e.g. http://hackage.haskell.org/package/base-prelude-1.0.1.1/docs/src/BasePrelude.html
12:51:26 * sm tries and fails to install or build ghc 6.12.3 on a modern ubuntu
12:51:28 <puregreen> (the ‚Äúmodule Exports‚Äù trick reduces duplication a bit)
12:51:54 <hsk3> Is there no way of just getting all functions within all of my files accessible from all of my other files? Files in my project that is.
12:52:09 <hsk3> then i don't have to worry about imports within my own project
12:52:15 <hsk3> and only import 3rd party stuff
12:52:29 <puregreen> you can't do that even with ordinary imports
12:52:40 <puregreen> because then you'd have circular dependencies
12:52:46 <puregreen> (well, modulo .hs-boot files)
12:52:50 <puregreen> (which are, too, gross)
12:53:08 <dfeuer> hsk3, the only sensible way is to put your whole project in one module. You'll really start to hate it once your project gets kind of large.
12:53:20 <hsk3> ok i see
12:53:22 <hsk3> thanks for the info
12:54:00 <ongy> dfeuer: I wouldn't call that sensible either way
12:54:13 <ongy> unless it's more a small script than an application
12:54:47 <dfeuer> ongy, it's the *most* sensible way, anyway. Thanks to the bloody orphan instance nightmare, a lot of projects end up with gargantuan modules anyway.
12:54:58 <sm> yesod, eg, uses an Import module for common stuff
12:58:31 <dfeuer> Take Data.Map. The lion's share of the logic is in one huge module, Data.Map.Base. Why? Because writing the instances requires fromList, toList, union, and a slew of showing and reading functions.
12:58:36 <orion> Would it be accurate to say that a skolem is a value whose type isn't exactly known, but there are a number of functions to which it can be successfully applied?
12:58:54 <dfeuer> orion, no, I think not.
12:59:51 <dfeuer> orion, I believe a skolem is a "fresh" (not equal to anything else) type used to instantiate polymorphic type variables in the process of type checking. Or something like that.
13:00:04 <dfeuer> I don't know the details.
13:01:18 <hsk3> Should   Hello/GreatModule.hs  refer to   Hello/Boom/MoreGreatness.hs   as  Hello.Boom.MoreGreatness   or   Boom.MoreGreatness   ?
13:01:29 <hsk3> when importing
13:01:41 <sm> the first
13:02:12 <hsk3> sm, ok so everything starts out at the root. that's convenient, in case i need to move files between folders
13:02:18 <sm> unless Hello/ is declared as a source path for GHC
13:02:20 <geekosaur> actually that depends on what level Hello is at. so, how does Hello/GreatModule.hs refer to itself?
13:02:29 * geekosaur is slow...
13:02:36 <johnw> dfeuer: sounds right
13:02:38 <dfeuer> hsk3, the periods in the module name don't actually mean anything in Haskell. They just have to correspond to separators in the file name.
13:03:14 <dfeuer> Thanks, johnw. I wish I understood more of the details though.
13:05:57 <johnw> skolemization turns "exists a : A, b" into b by removing the quantifier and supplying some A whose value is hidden
13:06:28 <johnw> see https://en.wikipedia.org/wiki/Skolem_normal_form
13:07:02 <johnw> in Coq one does this with "eexists"; in Haskell I don't think you ever do it manually
13:08:57 <dfeuer> johnw, are skolems also used for universal quantification, or does that use some other machine?
13:08:59 <Rudes> so i'm trying to do the fibs with zipWith and the compiler keeps saying "No instance for (Num [Int])" but only does it for this one file..
13:09:31 <Rudes> any ideas?
13:09:42 <ongy> Rudes: since it's Num [Int] I'd say you are trying to use a list somewhere where you only want 1 element
13:10:04 <Rudes>  fib = 0 : 1 : zipWith (+) fib (tail fib)
13:10:28 <johnw> dfeuer: I don't know, but I don't think so
13:10:34 <dfeuer> Hmm.
13:10:55 <Rudes> https://wiki.haskell.org/The_Fibonacci_sequence#Canonical_zipWith_implementation
13:11:19 <geekosaur> also look at use sites, since it may be inferring a different type if you used it wrong
13:12:42 <Rudes> geekosaur: thanks
13:12:45 <Rudes> that was it
13:17:31 <johnw> dfeuer: why do you ask?
13:17:49 <dfeuer> johnw, just trying to get some sort of sense/intuition about it.
13:17:57 <dfeuer> Which I don't have yet.
13:18:40 <dfeuer> Why the bleepity-bleep does Data.Map export the showTree and showTreeWith functions, which seem to be designed for debugging the library?
13:20:08 <dfeuer> That's pretty seriously screwy.
13:23:02 <athan> Does GHC support the "closures" concept detailed in distributed-process's paper?
13:25:45 <ocramz> hullo
13:26:32 <ocramz> I was wondering: can we think of types as sets?
13:27:07 <dfeuer> ocramz, to a decentish approximation. But once you start thinking of subsets, it kind of breaks down.
13:28:38 <dfeuer> ocramz, the closest things to subsets are images of functions and (at the type level, or in the upcoming Dependent Haskell) predicates on types.
13:29:12 <ocramz> dfeuer: "decentish approximation" doesn't sound flattering at all.
13:29:56 <dfeuer> ocramz, well, some stuff works out okay. But subset, union, and intersection not so much.
13:29:59 <EvanR> also sigma types
13:30:19 <dolio> It depends in part on how you think of sets.
13:30:20 <dfeuer> EvanR, how's that express a subset?
13:30:37 <dfeuer> (I'm not saying it doesn't; just trying to understand.)
13:31:34 <EvanR> if you have a type A and a "proposition about an A" P : A -> Type, then Sigma(x:A) P(x) is the type of A's that satisfy the proposition, plus the evidence to the effect
13:31:55 <EvanR> ex. isEven : Nat -> Type
13:32:34 <EvanR> so it could be all A, nothing, or anything in between depending
13:32:54 <dfeuer> EvanR, ah, yeah. That. I think it makes more sense to call that a comprehension.
13:33:06 * hackagebot mersenne-random-pure64 0.2.1.0 - Generate high quality pseudorandom numbers purely using a Mersenne Twister  https://hackage.haskell.org/package/mersenne-random-pure64-0.2.1.0 (BenGamari)
13:33:20 <EvanR> if P were A -> Prop, then its equivalent to predicates
13:34:09 <EvanR> havent heard comprehensions before
13:34:53 <dfeuer> EvanR, subset, to me, should really be more like   Subset (p : x -> Type) (q : x -> Type) = forall (y : x) . p y -> q y  I know that's not standard though.
13:35:17 <dfeuer> EvanR, I made it up. It's very much set comprehension style.
13:35:18 <EvanR> strictly speaking, subset to me is some sort of boolean algebra on a carrier
13:35:28 <EvanR> yeah set builder is a form of sigma type
13:35:38 <dfeuer> It tells you *how to form* a subset, rather than expressing *whether something is* a subset.
13:35:46 <dfeuer> Sorta.
13:35:50 <dfeuer> I dunno.
13:35:51 <EvanR> and set builder is properly done by starting with a set source of material
13:36:05 <dfeuer> I'm just an amateur dabbler.
13:36:39 <EvanR> subsets should form a poset thing
13:36:46 <EvanR> and be well typed
13:36:48 <dfeuer> But when I hear "subset", I imagine the  ‚äÜ symbol.
13:36:52 <EvanR> yeah that
13:37:05 <dfeuer> So using it to mean a set-buildery thing seems weird.
13:37:21 <dfeuer> Even if it's typical in the dependently typed land.
13:37:36 <parsnip> how did they pick (<*>) for applicative? was <$> already taken at that point? * like multiplication like composition? 
13:37:39 <EvanR> set buildery thing seems like a weird ... 
13:37:52 <johnw> parsnip: * like "points"
13:38:06 * hackagebot data-lens 2.11.1 - Used to be Haskell 98 Lenses  https://hackage.haskell.org/package/data-lens-2.11.1 (RussellOConnor)
13:38:07 <dfeuer> EvanR, it seems weird to use the name Subset for a set-buildery type.
13:38:09 <johnw> alternatively, <*> like ‚äó
13:38:16 <dolio> <*> was the closest they could get to a circled star.
13:38:20 <EvanR> you can define Fooable types as Sigma(t:Type) Fooable(t), this is strictly a "subset" of the universe of types
13:38:32 <EvanR> im not building a new set really
13:39:15 <EvanR> but if you really are doing subSETs then you should define a single type, and subsets are collections of those types, which you can union intersect and complement
13:39:26 <EvanR> and there will be a well defined < relation
13:39:43 <dfeuer> EvanR, hrmmm.... these are certainly connected.
13:39:47 <dfeuer> I dunno.
13:39:55 <EvanR> structurally, you really want new types when you are talking about a new thing
13:39:56 <dfeuer> For me it's just the name that's strange.
13:40:18 <EvanR> but subsets of a set are like an algebra over some carrier
13:40:28 <EvanR> with a ordering
13:41:02 <dfeuer> Too many fancy words.
13:41:07 <dfeuer> I'm going swimming now.
13:41:08 <EvanR> dfeuer: well i think someone asked about subsets for the purpose of doing filtering right... sigma is usually overlooked for that purpose so i mentioned it
13:41:09 <dfeuer> Later!
13:41:11 <dolio> In ETCS, a subset is just some other set with a monomorphism into your given set, I.E. a subobject in the category of sets.
13:41:21 <dfeuer> ETCS?
13:41:21 <dolio> So the sigma type certainly qualifies as that.
13:41:38 <dolio> Elementary Theory of the Category of Sets.
13:42:00 <johnw> I love how you abbreviated it like everyone knew what it was :)
13:42:01 <EvanR> heh, sets, types... screw it lets just do ETCS
13:42:04 <jdreaver> Is it possible to use associated type instances in a template Haskell declaration? For example: http://lpaste.net/179917
13:42:42 <johnw> it's elementary!  just like the S in SOAP stands for Simple.
13:44:15 <dolio> I mean, it's the name of a set theory. They're almost all abbreviated.
13:44:26 <dolio> Except maybe New Foundations.
13:44:53 <dolio> No, even that gets abbreviated, I guess.
13:48:44 <parsnip> johnw: okay, i guess it's like saying A \otimes v for matrices. 
13:49:19 <parsnip> johnw: ah, and \otimes is in this paper http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf
13:49:52 <johnw> yeah, ‚äõ
13:52:20 <jdreaver> Answered my own question: http://stackoverflow.com/questions/35992866/how-to-auto-derive-fromjson-using-template-haskell-aeson-and-type-families
14:06:32 <merijn> Any type theory folks around that can elaborate some questions I have about System F?
14:08:56 * EvanR cant wait for type theory folks to show up so i can hear the question
14:10:19 <parsnip> johnw: thanks for pointer. 
14:10:30 <merijn> EvanR: Well, my typechecker was getting stuck on checking case analysis. And after some earlier discussion we can up with a solution that's trivial to implement, but relies on interpreting the meaning of syntax differently and I'm not sure which interpretation is right
14:11:24 <merijn> EvanR: i.e., take http://lpaste.net/179812
14:12:02 <merijn> EvanR: I was interpreting the type variable 't' in the pattern match on line 19 to be a binding taking place at that point, just like the other bindings
14:12:23 <athan> What does it mean to "quote" something? Is that when you transfer from treating a term as it's computational meaning, to it's objective reference as an AST?
14:12:53 <merijn> EvanR: But ggole pointed out that it's simple to implement if you replace 't' with 'z' on both sides and tread the type variable in the pattern as being *applied* to the constructor, as opposed to being bound by
14:13:32 <merijn> athan: Usually (depending on context) quote, e.g. a computation/term returns it's representation as data, e.g. an AST for example
14:13:48 <merijn> athan: Hence why the template haskell quotes return an AST of the quoted haskell code
14:14:23 <athan> merijn: Ahh okay, yeah I've always been wary of that. Also seeing `'foo` used in elisp and stuff throws me off. Thank you!
14:14:48 <jdreaver> With the aeson deriveJSON TH function, is there a way to always encode a type as if it is a sum-of-products type, even if there is only one constructor?
14:15:36 <EvanR> athan: http://plato.stanford.edu/entries/quotation/
14:16:42 <EvanR> might help to reduce your understanding though ;)
14:20:14 <chsn> I'm reading https://github.com/Yuras/ghc/commit/6a8c5d011a93341947d631f2217f9b38da531517 . (getting ghc to dump ministg output). I'm now curious -- is tehre a 'guided tour to ghc' somewhere? to help reading the source code ?
14:20:39 <sm> http://www.stephendiehl.com/posts/ghc_01.html
14:21:10 <EvanR> merijn: whats wrong with t being a binding on 19
14:21:21 <chsn> sm: thanks
14:21:49 <merijn> EvanR: I'm not saying it's wrong
14:21:52 <dmwit> merijn: Well, I don't think System F has data at all. But if you look how you might desugar data to a Church-encoding it may be enlightening.
14:22:14 <merijn> dmwit: Ok, so System F + datatypes, whatever.
14:22:14 <EvanR> well what is "getting stuck"
14:22:42 <dmwit> merijn: Right. And I'm saying looking at how things work in the Church encoding may enlighten how to design the "+ datatypes" part.
14:22:46 <merijn> EvanR: To proof the result of head has type "Maybe z" I need to proof that 't' = 'z'
14:23:22 <merijn> EvanR: If I treat type application as application on both sides (so including inside the pattern) that's trivial
14:23:30 <merijn> EvanR: If I don't, then I don't know how to implement it
14:24:06 <EvanR> well, you can omit the t in the binding, i mean put _, then use z instead  like Just z x ;)
14:24:20 <dmwit> merijn: Consequently, I think treating `Cons t` as the constructor `Cons` for the `List t` type makes sense, i.e. `Cons t` is not a pattern that binds `t`, just like you say.
14:24:42 <merijn> EvanR: But that doesn't typecheck, because the pattern has to match the type of 'l'
14:24:49 <EvanR> but yeah i see that introducing the type again in the case binding doesnt make too much sense
14:25:18 <merijn> dmwit: I know it's easy to implement as that, but I wanted to verify that that is how you're actually supposed to do it, as the Henk paper is really lacking the relevant details on this
14:26:02 <dmwit> merijn: In fact, I'd be tempted to give the pattern `Cons x xs` and say that this matches the term `Cons t x xs`.
14:26:29 <dmwit> Although I agree that the details should be worked out carefully. e.g. what should happen for forall's that appear later in the constructor's type.
14:26:36 <dmwit> It's a fun question.
14:26:38 <merijn> dmwit: That's really hard to implement though, as opposed to type application, which is trivial :)
14:27:06 <merijn> dmwit: Well, the thing is, if you treat it as application, then forall's later in the type are really just "yet another" application and typing it is easy
14:27:27 <merijn> dmwit: But I'd like to make sure that my "easy to implement" solution is also actually right :)
14:27:38 * dmwit nods agreeably
14:29:21 <merijn> TaPL takes a shortcut of using a Church (or Scott?) encoding of datatypes when treating System F and the Henk paper spends a lot of time on the type checking of lambda's and syntax, but glosses over case and datatypes in like 4 paragraphs
14:30:29 <EvanR> shoulda church encoded!
14:30:45 <merijn> EvanR: But then *everything else* becomes a bitch >.>
14:31:43 <EvanR> have you tried to write down the rules for checking (simple) cases for some data type
14:32:22 <merijn> EvanR: The truly simple cases are just matching literal constructors :)
14:32:39 <EvanR> yeah, generalized to include ctor args
14:32:50 <EvanR> including polymorphic
14:33:08 * hackagebot bookkeeper 0.1.0.0 -   https://hackage.haskell.org/package/bookkeeper-0.1.0.0 (jkarni)
14:33:17 <EvanR> maybe theres a pattern matching calculus that you can reduce it to first bfore checking
14:33:36 <merijn> EvanR: If there is, none of that is mentioned in the Henk paper
14:34:35 <EvanR> well from the lpaste, it seems like there is enough there for some sort of rule to conclude that t = z
14:34:54 <EvanR> it just might be a complicated rule
14:35:07 <merijn> EvanR: Yes, but I've literally spend two weeks (a few months back) to somehow compute that
14:35:29 <merijn> EvanR: And have failed to come up with a non-buggy way to do it that didn't horribly break even for fairly simple cases
14:36:00 <merijn> EvanR: Whereas the "type application to constructors" view I know I can implement in like 10 minutes and having it work right trivially
14:36:23 <EvanR> sounds good then
14:36:43 <EvanR> i dont really understand that though
14:36:47 <chsn> Core looks much simpler than STG. https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType . If I'm writing a backend for Haskell; is Core -> Target or STG -> Traget better? Has all the optimization passes been used by the time we get to simplified Core ?
14:36:56 <lpaste> merijn annotated ‚ÄúSystem F‚Äù with ‚ÄúSystem F (annotation)‚Äù at http://lpaste.net/179812#a179928
14:37:19 <merijn> EvanR: Say I change the syntax a bit to say that 'f [y]' is type application
14:37:50 <EvanR> and that you can do it during a pattern
14:37:53 <merijn> EvanR: Then instead of *binding* a type variable in the pattern, I'm *applying* an existing type to the Constructor and using the result to type check the remainder of the constructor
14:38:54 <EvanR> thats sort of what i suggested except the second [ ] werent necessary and the first one was _, and if that doesnt type check thats silly
14:38:59 <merijn> EvanR: So, since 'z' is a *type* being applied (on both sides of the case) it's trivialy to compute the resulting type of the pattern *and* the result type of the specific branch (and they must trivially be 'z', because I'm using the 'z' directly in scope)
14:39:54 * EvanR tries to think up this rule you couldnt do in two weeks real fast
14:40:21 <merijn> EvanR: Ah, see but using a wildcard would ALSO correctly accept "List Bool" (for example) as type for the pattern, which is clearly nonsense, since I cannot construct a "Maybe t" from "Just t" and a Bool :)
14:40:54 <merijn> EvanR: So the pattern really has to enforce what the type variable is to be able to correctly type the binding of 'x'
14:40:55 <EvanR> how would List Bool get in there
14:41:55 <merijn> Not in this example, no, here's you can check the type of 'l' trivially since it's the input of the function
14:42:00 <EvanR> the type of the l in case l should only pull from l in the context and the types of the bodies, right
14:42:16 <merijn> EvanR: But 'l' can be an arbitrarily compelx expression and you need to make sure that case works on all cases, not just this one
14:42:42 <EvanR> i didnt think of using patterns for that
14:42:55 <EvanR> like, only check patterns, dont try to reconstruct using them
14:43:32 <EvanR> ok rule time
14:43:45 <merijn> EvanR: No, my point is that I can compute the type of the scrutinee (which is some expression), and compute the type of the pattern
14:45:30 <dmwit> chsn: Core may be simpler, but STG has an operational semantics that can be easily mapped to stock hardware.
14:45:59 <dmwit> chsn: Probably if you try to implement a Core -> Target pass, you'll end up inventing something like STG on your own.
14:47:08 <merijn> Anyway, hence why I wanted advice from more experienced/knowledgeable people ;)
14:47:48 <EvanR> i see
14:48:06 <chsn> dmwit: I'm doing Core -> JS or Stg -> JS
14:48:09 <dmwit> merijn: You could consider looking at some of the System F-like papers about Haskell's Core. The early ones may discuss data types.
14:48:41 <dmwit> merijn: So that's a possible source for alternate presentations.
14:48:45 <EvanR> maybe a paper on GADTs
14:49:00 <EvanR> which might go over "boring" datatypes first
14:50:00 <bjorn__> Data.Time.Relative, which package contains this module ?
14:50:56 <merijn> dmwit: It's difficult to find relevant papers, though. I'll have a look of the GHC wiki has any links
14:51:38 <glguy> ?google "Data.Time.Relative"
14:51:39 <lambdabot> https://github.com/chrisdone/lpaste/blob/master/src/Data/Time/Relative.hs
14:55:55 <merijn> dmwit: The wiki has some links, but not really on the System F like parts (well, there's the 2013 "System FC, as implemented in GHC", but that has so much weird notation and GHC complexity (like levity polymorphism, etc.) it's hard to understand
14:58:06 <dmwit> Does it not have references to earlier System FC papers -- from before levity polymorphism and friends?
14:58:50 <EvanR> merijn: the type application thing makes sense to me now, even without new syntax, since this is pretty much how regular instantiation works anyway
14:58:51 <merijn> dmwit: No references, I think it's just a spec of the current state in 2013
14:59:17 <merijn> EvanR: Right? It seems so simple and elegant, I just hope it's correct :p
14:59:55 <EvanR> for each component of the pattern from the left which is a type variable, instantiate a new function type for the ctor, until youre done and you have the data types type (monomorphic)
15:00:13 <Profpatsch> barrucadu: I‚Äôm trying to connect to freenode and send a message to a channel afterwards.
15:00:18 <EvanR> i mean until you start checking the regular components
15:00:24 <EvanR> by check i mean,... infer
15:00:28 <EvanR> or whatever
15:00:35 <Profpatsch> _onconnect should wait until the nick is registered, but apparently it does not.
15:01:19 <Profpatsch> barrucadu: http://lpaste.net/179931
15:02:10 <merijn> EvanR: Well, the thing is, even if your type variables are interleaved with actual bindings (which is allowed in System F, so you can have "Foo :: forall a . a -> forall b . Tuple a b" for example, then it *still* works just fine :)
15:04:32 <EvanR> i didnt know you could do that
15:04:54 <merijn> You can't in haskell, but in System F it's fine
15:05:51 <chsn> with the GHC library, I see compileToCoreSimplified -- but I don't see how to get STG. How do I get STG via the GHC API? I see there is a dump_stg flag, but I don't wnat it dumped out ot a file; I want to access it myslf to modify it
15:06:26 <athan> acid-state isn't viable for gigabytes of data, is it?
15:06:34 <barrucadu> Profpatsch: the onconnect action is executed after sending the USER message to the server, it needs to set the nick (the default does). If you want to do something after joining a channel you'll need to catch the "join" event and handle that.
15:06:56 <EvanR> acid-state network connection to the university super computer with 1000G memory, not problem
15:08:12 <barrucadu> Profpatsch: Waiting for the JOIN is necessary because IRC is asynchronous. Immediately sending a PRIVMSG is likely to be rejected as the server won't have processed the JOIN by the time it gets the PRIVMSG.
15:08:45 <athan> EvanR: ! Dang! So swapping is the solution..?
15:09:05 <athan> er mustof misread
15:09:08 <EvanR> probably not
15:09:12 <athan> so the solution is just more ram? hah
15:09:17 <EvanR> yes definitely
15:09:25 <athan> shitzkreig
15:09:50 <EvanR> its ok because no matter how much ram you add, array indexing is still O(1)
15:10:00 <Profpatsch> barrucadu: Actually I am not sure how to know which channel EJoin joined.
15:10:22 <athan> hmm. thanks EvanR 
15:10:28 <Profpatsch> I‚Äôd expect for EJoin to be :: ChannelName -> Event
15:13:00 <barrucadu> Profpatsch: If the _matchType of an EventHandler is EJoin, it means that it gets called for every JOIN received. The _eventFunc is given the actual message itself, which comes from http://hackage.haskell.org/package/irc-conduit-0.2.0.0/docs/Network-IRC-Conduit.html#t:Message
15:13:05 <barrucadu> And does include the channel name
15:13:18 <barrucadu> As a Text
15:13:21 <dfeuer> Cale, I just realized something: perhaps I should jam singleton, viewl, and viewr together into a FreeCategory class, along with a function witnessing that the category is free over the graph. It's possible to implement (very inefficient) view function using such a function and appropriate Category instances for the view types.
15:13:55 <Profpatsch> barrucadu: What do you think about EJoin "#mychanne" :: Event?
15:14:04 <Profpatsch> This way the library could do the filtering.
15:14:25 <barrucadu> Although, looking at the code, I've just remembered that you don't want to receive joins, you want to receive nuemric 332 (which is a channel topic), as you don't necessrily get your own joins. This function updates the channel list on receiving that, so might be good to look at: https://github.com/barrucadu/irc-client/blob/0aeda2349d74e707e4b1f4697c565656cc3a14ee/Network/IRC/Client/Handlers.hs#L179
15:14:53 <barrucadu> Mmm, the filtering is very coarse-grained right now. It's possible that being able to have per-channel event handlers would be more useful
15:15:02 <Profpatsch> barrucadu: Actually I don‚Äôt really need to JOIN first.
15:15:17 <Profpatsch> I can send messages without joining afaik.p
15:15:50 <barrucadu> Ah, yeah, I think that's an option you can turn on for channels on freenode
15:16:06 <okek> mode +n prevents sending messages to channel without being on it
15:16:39 <barrucadu> In any case, you can't do anything before receiving a numeric 001 ("welcome") from the server, so you should wait for that if you want to do something other than just set the nick on connect
15:17:48 <Welkin> writing an irc bot?
15:17:50 <Welkin> or client?
15:18:11 <Profpatsch> Welkin: Yes
15:19:50 <Profpatsch> barrucadu: So there is no convenient way to wait on NICK?
15:19:57 <Profpatsch> Or on channel JOIN?
15:20:34 <Profpatsch> Maybe I need yet another library.
15:21:22 <Welkin> Profpatsch: wait on nick?
15:21:24 <Welkin> what do you mean?
15:21:31 <Welkin> before you join?
15:21:55 <barrucadu> You can wait on numeric 332, which is receiving a channel's topic. If you use the default onconnect function (which sets the nick), you can wait on numeric 001 (server welcome) to do the rest of your set-up.
15:24:47 <Profpatsch> barrucadu: So the docs for _onconnect are wrong
15:24:49 <Profpatsch> Action to run after successfully connecting to the server and setting the nick.
15:25:03 <Profpatsch> Or at least ambiguous.
15:25:17 <barrucadu> Yup, I shall note that down
15:25:18 <Profpatsch> I parsed it as succussfully (connecting to server && setting nick)
15:25:36 <Profpatsch> But it is (successfully connecting && setting nick)
15:26:40 <barrucadu> It was the former originally, but then someone needed to be able to do something before setting the nick. It seems I forgot to update the comment.
15:27:00 <Welkin> barrucadu: is this a library you wrote?
15:27:18 <barrucadu> Welkin: Yes: https://hackage.haskell.org/package/irc-client
15:27:24 <Profpatsch> barrucadu: We should put the constants in.
15:27:59 <Profpatsch> Or at least document ENumeric
15:28:40 <Profpatsch> And link to https://tools.ietf.org/html/rfc2812#section-5.1
15:40:30 <Gurkenglas> Ignoring elegance, maintainability, scalability and all that jazz, are IORefs faster than StateT if done right?
15:40:43 <merijn> Gurkenglas: Yes, no, maybe.
15:41:04 <Gurkenglas> So ignoring elegance yes, ignoring maintainability no and ignoring scalability maybe?
15:41:35 <merijn> Gurkenglas: No, I mean "it depends on so many variables any of the three might be the correct answer to your question given a specific set of circumstances"
15:42:00 <Gurkenglas> Just wanted to see whether the answer to "Why would you use IORefs there" could possibly be "because this needs to be fast"
15:42:05 <merijn> Gurkenglas: In other words, the only reasonable answer to that question is "Who knows?" :)
15:42:18 <merijn> Seems unlikely
15:42:20 <Gurkenglas> (Specifically https://github.com/benl23x5/gloss/blob/c242fef27204620bf85289c42f0776d58d36714b/gloss/Graphics/Gloss/Internals/Interface/Backend/Types.hs#L21 )
15:42:29 <merijn> IORef needs to produce a memory barrier
15:42:44 <merijn> At least within the thread, but I think potentially between threads too>
15:43:11 * hackagebot bookkeeper 0.1.1.0 -   https://hackage.haskell.org/package/bookkeeper-0.1.1.0 (jkarni)
15:43:18 <merijn> Gurkenglas: Presumably you want to be able to access the same Gloss backend from multiple threads
15:44:11 <Gurkenglas> mtl is lost when it comes to threading?
15:45:20 <Gurkenglas> Specifically does this mean that converting that stuff to work with arbitrary MonadIOs destroys threading?
15:45:30 <merijn> Gurkenglas: StateT is just a newtype around passing an extra argument to a function
15:45:51 <merijn> Gurkenglas: So any StateT state is obviously not accessible to multiple threads simultaneously
15:46:11 <merijn> I'm not sure what those questions mean
15:47:06 <Gurkenglas> Can 2 threads access the same IORef at a time?
15:47:40 <merijn> Well, yes, that's the main point of IORefs :p
15:48:17 <Gurkenglas> Huh, I've always seen them as what desperate people reach for when they translate imperative algorithms.
15:48:49 <Gurkenglas> (I actually expected the answer "no duh" just now but thought I should check)
15:51:30 <Gurkenglas> I'm thinking about replacing the like of "IORef a -> Display -> IO ()" by the likes of "MonadIO m => Display -> m ()" so people can choose whether to have state and to have a single interface for play and playIO etc. Is there an alternative to StateT that allows threading? (I guess ReaderT (IORef s) works...)
15:52:57 <merijn> Right, ReaderT + IORef (or just explicitly passing in an IORef), but no, State itself can't handle multiple threads
15:53:22 <dfeuer> I very much like the way that left and right views fall out of free structures.
15:53:24 <dmwit> merijn: The 2007 paper looks relatively self-contained.
15:53:37 <merijn> dmwit: What's the title?
15:53:40 <Profpatsch> barrucadu: I think the event handling is a bit awkward to use.
15:53:42 <dfeuer> (semigroupoids and categories, here, but you would get them for lists and nonempty lists too)
15:53:50 <dmwit> merijn: System F with Type Equality Coercions
15:54:09 <Profpatsch> You can‚Äôt abstract very well, since everything is very partial.
15:54:18 <dmwit> merijn: It discusses "binding" type variables -- which in their system actually binds a coercion that can be used to convert between the declared type and the bound type.
15:54:35 <merijn> dmwit: I'll have a look, and otherwise I'll just try and bug people again tomorrow :)
15:54:42 <Profpatsch> Or the user of the library has to reimplement the handlers from Handlers.hs
15:54:43 <merijn> dmwit: Thanks
15:54:49 <dmwit> merijn: So that may be an implementation strategy if you wanted to try out the "types in patterns as binders" thing.
15:56:01 <dmwit> Gurkenglas: You probably want an MVar or TVar rather than an IORef for concurrent access.
15:56:24 <dmwit> Gurkenglas: Or else carefully design your access protocol and use the atomic* family for reading and writing the IORef.
15:56:34 <dfeuer> What's the standard name for the functions witnessing free constructions? Like for lists as free monoids, there's   foo :: Monoid u => (a -> u) -> [a] -> u. What do you call the foo function?
15:56:57 <dfeuer> I guess in this case it's foldMap?
15:57:03 <dfeuer> Huh.
15:57:10 <dfeuer> What do you call such functions generally?
15:57:32 <dmwit> foo f is the canonical homomorphism induced by f
15:57:57 <Gurkenglas> foo induces canonical homomorphisms? :D
15:58:00 <dfeuer> dmwit, so does foo itself has a name?
15:58:02 <Gurkenglas> pointfreeness.
15:58:27 <dmwit> I don't know of one.
15:59:31 <Gurkenglas> ghci should allow you to say "runMaybeT $ do" and suddenly the giant do block you're writing is in MaybeT IO 
15:59:57 <Gurkenglas> (For arbitrary monads, of course, and the important part is that monadic actions you write still print the result)
15:59:58 <dfeuer> Thanks, dmwit. It surprises me slightly that from Foldable f, Monoid (f a), and a function a -> f a, you can construct left and right views for f a.
16:00:07 <merijn> dmwit: Oh, I see, that generates equality constraints that are checked after the fact, but that was something I was hoping to avoid if possible :)
16:00:19 <merijn> Anyway, bedtime now
16:01:11 <Profpatsch> Can I combine ViewPatterns with LambdaCase?
16:01:32 <Profpatsch> e.g. fun (modifierFun) = \case
16:01:37 <Welkin> Profpatsch: I thought for a moment you were asking if you can become ViewPatterns
16:01:45 <Welkin> like some kind of matrix ascension
16:02:04 <dmwit> dfeuer: Do you even need `Monoid (f a)` and the function? Doesn't `foldMap First` and `foldMap Last` already give you a left and right view?
16:02:15 <dmwit> :t foldMap (First . Just)
16:02:17 <lambdabot> Foldable t => t a -> First a
16:02:18 <hpc> Welkin: is that how chuck became the intersect? :P
16:02:30 <dfeuer> dmwit, by views, I mean "the first element and the rest of the list"
16:02:39 <dfeuer> So yes, you need to be able to put the rest back together.
16:03:01 <dmwit> aha
16:03:39 <dmwit> No guarantee that the "shape" of the thing you get as a result matches the "shape" of the input in a meaningful way, of course.
16:03:43 <ertes> Profpatsch: why wouldn't you?
16:04:09 <ertes> Profpatsch: however, your example doesn't make much sense to me
16:05:09 <dfeuer> dmwit, you need some extra laws.
16:05:26 <dmwit> :t toList
16:05:28 <lambdabot> error:
16:05:28 <lambdabot>     Ambiguous occurrence ‚ÄòtoList‚Äô
16:05:28 <lambdabot>     It could refer to either ‚ÄòData.Foldable.toList‚Äô,
16:05:35 <dmwit> ?more
16:05:46 <dmwit> :t Data.Foldable.toList
16:05:48 <lambdabot> Foldable t => t a -> [a]
16:05:50 <dfeuer> dmwit, specifically, it actually has to *be* the free monoid, and the function involved has to actually be the canonical injection.
16:06:10 <dfeuer> And foldMap actually has to be the thing that produces the whatevers.
16:06:46 <dfeuer> The canonical homomorphisms I guess.
16:08:37 <dfeuer> dmwit, anyway, I think this relationship gives me a pretty clear picture of how I want to structure my type-aligned sequence class hierarchy.
16:10:06 * nshepperd_ suggests some kind of horrible pun based on "free" objects. Eg. "foldMap is a post-scarcity transformation"
16:10:17 <dfeuer> Ugh.
16:38:13 * hackagebot bond 0.5.0.0 - Bond schema compiler and code generator  https://hackage.haskell.org/package/bond-0.5.0.0 (chwarr)
17:00:16 <Ed___> in the definition of a haskell definition what is the "Enum a" called in "foo :: Enum a => a -> a"?
17:00:25 <Ed___> fucntion*
17:00:38 <Koterpillar> Ed___: a constraint
17:00:51 <Koterpillar> Ed___: Enum is a typeclass
17:00:55 <Ed___> what about predicate?
17:01:44 <Ed___> I used the word "predicate" when talking about it earlier. Was that bad?
17:02:00 <Koterpillar> Ed___: a predicate typically means a function returning Bool
17:02:22 <Ed___> Thanks Koterpillar
17:06:37 <nickers> hey guys, question : say I have a data type like --
17:06:53 <nickers> data stuff  = A | B | C | D | E
17:06:53 <Rotaerk> isn't that a comment
17:06:57 <hpc> :P
17:07:02 <nickers> :)
17:07:24 <nickers> is there a way for me to create a list of the constructors without doing it by hand? [A,B,C,D,E]
17:07:45 <hpc> derive Data and Typeable
17:08:07 <nickers> deriving(Data, Typeable) ??
17:08:25 <hpc> yeah
17:08:53 <hpc> you don't necessarily need both, but there's no reason not to
17:08:54 <peddie> nickers: derive Enum and Bounded and do [minBound .. maxBound] ?
17:08:57 <dedgrant_> data Stuff = A | .. | E deriving (Enum, Bounded) ; vals = [minBound :: Stuff .. maxBound] ?
17:08:58 <bergmark> Using Eq & Enum & Bounded would also work
17:09:21 <hpc> or i guess that, it depends on exactly what sort of [A, B, C, D, E] you care about having
17:09:27 <dedgrant_> ah
17:09:30 <nickers> I have not seen bounded before
17:09:45 <hpc> if it's really just a flat enum like that it's fine to just do [A .. E] with Enum, Data/Typeable are more powerful
17:10:07 <nickers> It's for a function to create a chess board by putting out a list of tuples [(A,1) .. (G,8]
17:10:07 <peddie> nickers: I wouldn't do Enum and Bounded if any of your constructors have arguments; if they do, use hpc's way
17:10:51 <nickers> ok, I'm going to go study up on data and typeable. Thanks 
17:11:57 <peddie> nickers: it sounds like for the use case you described, Enum and Bounded is fine.  you should study all 4 type classes :)
17:12:02 <EvanR> data and typeable for chess boards? o_O
17:12:48 <nickers> I could easily do the type-by-hand for this one, but I figured I'd come and ask since there *had* to be a way to do that kind of mapping for a larger or less predictable type
17:13:10 <nickers> I'll look at bounded too, I'm hitting all the books today
17:13:33 <dedgrant_> nickers: In this case maybe think about the cartesian product of ranges [A..E] and [1..8].
17:14:52 <nickers> like liftA2 Position [letters] [numbers]
17:15:29 <nickers> where position :: (col, row) or something
17:19:02 <dedgrant_> Yep.
17:20:19 <dedgrant_> > liftA2 (,) ['A'..'H'] [1..8]
17:20:22 <lambdabot>  [('A',1),('A',2),('A',3),('A',4),('A',5),('A',6),('A',7),('A',8),('B',1),('B...
17:26:11 <sm> hey joeyh/all: is it fair to say http://hackage.haskell.org/package/propellor does about what vagrant does, with real machines instead of vms ?
17:26:32 <richardS125> hello
17:27:16 <Koterpillar> sm: I thought it's closer to puppet'
17:27:18 <Koterpillar> sm: I thought it's closer to puppet
17:28:03 <sm> I'm quite confused by all these configuration management tools
17:28:11 <Koterpillar> sm: they have a lot of overlap
17:28:17 <sm> Koterpillar: how does that differ from vagrant ?
17:28:30 <sm> it does real machines rather than vms ?
17:28:39 <Koterpillar> sm: afaik vagrant just builds you something, and then you are free to mess with it
17:28:56 <Koterpillar> sm: puppet will take your machine (doesn't care if it's a VM or not) and bring it into desired state
17:29:05 <Koterpillar> sm: making only necessary changes
17:30:48 <sm> ok, like propellor. So that's one thing to look for, idempotently bringing things into desired state versus one-time build procedures
17:31:24 <sm> I feel like I could get a good enough solution with just a shell script, most package installations etc. are idempotent
17:31:27 <Profpatsch> How would I play audio files?
17:31:37 <sm> (for my current need, not in general obviously)
17:32:13 <sm> Profpatsch: sdl2, would be one way
17:33:26 <sm> more options in http://hackage.haskell.org/packages/#cat:Sound 
17:35:13 <puregreen> Profpatsch: here's a very very bad guitar synth I wrote when my fingers hurt and I thought that playing samples one after another could be a good repalcement for guitar
17:35:18 <puregreen> http://lpaste.net/179947
17:35:44 <puregreen> aka ‚Äúan example of playing wav files‚Äù :P
17:36:00 <puregreen> * replacement
17:36:18 <Profpatsch> puregreen: Is that sdl2?
17:37:21 <puregreen> Profpatsch: nope, SDL
17:37:25 <ertes> Profpatsch: that one is SDL 1
17:38:02 <puregreen> apparently sdl2 has examples bundled with it so you probably don't need mine
17:38:19 <ertes> more importantly sdl2 has a sensible audio interface =)
17:38:50 <hpc> sdl2's examples are quite good too
17:39:00 <hpc> they're not full-blown games like pong, as one might hope
17:39:10 <hpc> but they cover a little bit of nearly everything
17:39:14 <ertes> Profpatsch: the only problem is that you might have some difficulty actually *loading* audio files
17:39:30 <ertes> currently the best supported format is WAV, which is a bit of a shame
17:42:32 <Profpatsch> ertes: There is https://hackage.haskell.org/package/conduit-audio-sndfile-0.1.1/docs/Data-Conduit-Audio-Sndfile.html, which could work I guess.
17:43:20 <Profpatsch> Gives back a conduit source, sample rate, channels and frames.
17:43:50 <Profpatsch> Alternatively I could just shell out to e.g. mpv, but where would be the fun in that.
17:44:50 <alexjane>  /help
17:47:29 <ertes> Profpatsch: that might work‚Ä¶  you get at least FLAC that way
17:48:33 <Welkin> there should be lots of haskell audio solutions
17:48:35 <ertes> oh, according to the sndfile homepage, it now reads OGG/vorbis
17:48:38 <ertes> nice!
17:48:42 <Welkin> you even have euterpea
17:48:50 <Welkin> and a super collider dsl
17:49:09 <ertes> i could never get euterpea to work
17:49:16 <Welkin> I think there is a fluidsynth binding too, so you can use a midi sequencer
17:49:54 <ertes> anyway, those are for music composition, so probably not that useful for games
17:50:02 <Welkin> useful for a music game
17:50:05 <Welkin> like the one I'm making :D
17:50:11 <Welkin> well, at least the midi
17:50:17 <ertes> finally making one in haskell?
17:50:23 <Welkin> lol, not in haskell right now
17:50:32 <ertes> i thought so =)
17:57:15 <shamrock_frost> Hi!
17:57:57 <shamrock_frost> Can anyone help me with some stack/llvm stuff?
17:58:45 <shamrock_frost> The llvm-general package is outdated on hackage, but I got the version compatible with my system wide llvm package off github (as a cabal project)
17:59:09 <shamrock_frost> I'm not sure how to add it as a dependency to my local stack project, though
17:59:15 <shamrock_frost> Any ideas?
17:59:20 <Koterpillar> shamrock_frost: as an extra-dep... link coming up
17:59:31 <Koterpillar> shamrock_frost: https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#local-dependency-packages-extra-dep
17:59:44 <shamrock_frost> Thank you so much!
18:00:00 <shamrock_frost> This issue has been blocking me for a day or so
18:00:35 <Koterpillar> shamrock_frost: note that you can reference it locally or from a Git repository
18:02:18 <Axman6> it's worth reading most of that page
18:21:18 <Gurkenglas> https://wiki.haskell.org/Roll_your_own_IRC_bot is considered harmful by http://ircbrowse.net/browse/haskell?id=23236615&timestamp=1471552119#t1471552119 and so someone might want to make it point to https://github.com/glguy/irc-core/blob/v2/bot/src/Main.hs
18:23:47 <glguy> disclaimer: I made that as an example of using my library, not in judgement of any particular alternative
18:24:54 <Gurkenglas> ertes, dispense us some judgement!
18:25:25 <Gurkenglas> (As in, is that example correct in all the ways the wiki article is not?)
18:27:20 <glguy> a full bit would want to handle more errors and to use the rate limit part of the library at least
18:28:08 <chsn> what is GHC SDoc and how to I learn more about it? this is in the context of printng stuff out (StgBinding can get dumped into SDoc), but it's not clear to me what SDoc is
18:28:31 <Gurkenglas> Oh okay I assumed you weren't actively aware of anything wrong :(.
18:29:21 <glguy> there are many opportunities for making things more complicated
18:32:41 <glguy> you could add reconnect logic, detect nick being unavailable on connect
18:33:02 <glguy> the point isn't too write the most complicated example
18:34:44 <shamrock_frost> So, I added llvm as an extra dependency, which seemed to work out a little bit
18:35:18 <shamrock_frost> But now I'm getting an error about llvm-general's build tool
18:35:33 <shamrock_frost> and when I look at the .cabal, I see "build-tools: llvm-config"
18:36:00 <shamrock_frost> And stack's error is "No packages found in snapshot which provide a "llvm-config" executable..."
18:36:12 <shamrock_frost> Even though llvm-config is on my path
18:36:52 <shamrock_frost> Anyone know how to configure built-tooling for local extra-dep stack packages?
18:44:05 <ahsfhyicxv> Which is "better" IO (Maybe a), MaybeT IO a, or (MonadPlus m, MonadIO m) => m a, or something else? I am working with a library (ghcjs-dom) where nearly every function returns IO (Maybe a), IO, or Maybe.
18:46:25 <EvanR> just keep it as IO Whatever
18:48:25 <Cale> ahsfhyicxv: It depends on what you think the most likely thing your user is going to want to do is
18:48:51 <dfeuer> ahsfhyicxv, it depends. It's probably best to have the primitive IO (Maybe a) available, but also to write a wrapper interface for something fancier.
18:49:05 <Cale> If it's likely they will want to handle the failure immediately, then IO (Maybe a) or IO (Either SomeError a) is the way to go
18:49:26 <ahsfhyicxv> Cale: I am not writing a library
18:49:39 <Cale> Well, you asked which is better :)
18:49:43 <dfeuer> Since mtl doesn't offer very good MaybeT support, you might want to use ExceptT () instead.
18:50:00 <dfeuer> Although there's an efficiency cost :/
18:50:21 <dfeuer> I guess MonadPlus or MonadFail is an option....
18:50:46 <erisco> EitherT IO SomeError a
18:51:14 <Cale> Also IO exceptions are an option -- not one that most people tend to like, but an option nonetheless. They become good in the regime where the user is unlikely to want to handle the error in the common case.
18:53:22 <dfeuer> Cale, you have a PM.
18:54:28 <dfeuer> IO exceptions are an easy out when there are lots and lots of possible errors and you don't want to deal. They're easy to throw and hard to catch.
18:54:35 <ahsfhyicxv> I am not going to use IO exceptions
18:55:31 <ahsfhyicxv> Errors will occur very often.
18:55:58 <erisco> I think dfeuer meant if there are many different types of errors
18:56:14 <erisco> because when that is the case it is onerous to maintain a sum of all of them
18:56:26 <dfeuer> Exactly.
18:56:37 <erisco> one reason I have been batting around an idea of open sums
18:57:06 <dfeuer> erisco, yeah, that's your EitherT IO SomeError a, kinda sorta?
18:57:14 <ahsfhyicxv> I am using transformers not mtl
18:57:59 <Roxxik> ExceptT Error IO a
18:58:16 <erisco> dfeuer, it is either a new type system feature or perhaps can be emulated within Haskell's type system, I am not sure
18:58:30 <erisco> dfeuer, but the idea being that you can add terms to a sum ad-hoc, i.e. open rather than closed
18:58:45 <Roxxik> Union
18:59:05 <Roxxik> Used by extensible effects
18:59:51 <erisco> perhaps union types, that is an option
18:59:58 <dfeuer> erisco, oh, yeah, we don't have that.
19:00:03 <dfeuer> Not for real.
19:00:14 <Roxxik> Data.OpenUnion to be correct 
19:00:59 <erisco> but it doesn't quite fit the bill for what I am thinking
19:01:26 <erisco> it would have to be open unions‚Ä¶ i.e. union types themselves don't solve the openness
19:02:21 <erisco> it has commutativity and idempotency, so it is perhaps more on the right track than Either
19:02:49 <erisco> but if you had new type features involving |, discriminated union, I think it could work similarly
19:03:05 <erisco> you're doing a union on constructors in that case, rather than types
19:03:25 <erisco> which then fits into case analysis more naturally, with how things have already been set up
19:06:06 <EvanR> unions imply subsets, subsets implies a set from which to get material from for the subsets
19:06:12 <erisco> the key with openness is that if you have  f : U ‚Üí X,  x : U | V  then  f x : X
19:06:14 <EvanR> define that set and youre golden
19:07:17 <dfeuer> erisco, how does this language feature work elsewhere? How do you figure out which constructors you need to check for where?
19:07:43 <erisco> you do not need to check for any, that is part of the openness feature
19:08:12 <erisco> U may be the empty sum
19:08:23 <EvanR> indeed if everything in the universe is the same type, theres not much to worry about
19:08:24 <erisco> or empty union, depending on what we're using
19:09:15 <EvanR> formal topology of types
19:09:19 <erisco> well, a consequence of these rules is that all open sums/unions are equivalent
19:09:26 <EvanR> i got your openness right there
19:09:39 <dfeuer> erisco, I don't understand these open union types yet. What do they look like?
19:10:04 <EvanR> what are the rules to introduce and eliminate open union types
19:10:50 <EvanR> above that looks kind of like an eliminator
19:11:26 <dfeuer> Cale, you have a few more messages.
19:11:31 <erisco> first we have to choose whether we're going to talk about sums or unions
19:11:39 <EvanR> and the behavior implied looks kind of like an extensible record
19:11:49 <glguy> Cale: dfeuer sent you a message about sending you messages
19:12:03 <EvanR> Cale: end of stream
19:12:19 <erisco> I was more interested in sums because we already have case analysis looked after for that
19:12:27 <Cale> glguy: You sent me a message about dfeuer sending me a message about sending me messages.
19:13:06 <glguy> Confirming acknowledgement, please confirm
19:13:38 <chsn> I'm using GHC as a library; I'm trying to call showSDoc, and I get "ghc: missing -B<dir> option" -- however, I dont's ee anythign in "ghc --help"
19:13:44 <chsn> what is this "ghc -B" and why do I care about it
19:13:49 <alercah> confirming eavesdropping, please confirm outrage
19:13:51 <EvanR> erisco: based on your example, it seems like you can come up with some universal properties satisfied by sophisticated union types of any types, but intuitively it feels like it would blow up in your face
19:13:56 <Cale> glguy: Acknowledgement confirmation confirmed.
19:14:28 <EvanR> it has succeeded in other environments where "type" means "dynamic int, dynamic float, or dynamic string"
19:15:47 <Cale> The thing which makes this whole discussion extra special is that I'm meanwhile being notified by Google's mail delivery subsystem about bounced emails from failed attempts to communicate with a mail server I was working on from a couple days ago, saying that it'll keep retrying for 0 more days.
19:15:48 <dfeuer> glguy, request for acknowledgement confirmation confirmed. Acknowledgement confirmation pending.
19:16:23 <EvanR> fix acknowledge
19:16:56 <erisco> EvanR, the thing is, logically they are uninteresting, because as I said all the open sums/unions are equivalent
19:17:14 <EvanR> how are they equivalent
19:18:01 <erisco> they all have the same inhabitants
19:18:17 <erisco> let me try to drum up a short proof
19:18:18 <EvanR> A|B and B|C have the same inhabitants?
19:18:29 <erisco> yes
19:18:37 <EvanR> impressive
19:18:50 <erisco> well, it is interesting, but a necessary consequence of openness
19:19:40 <EvanR> c:C is an inhabitant of A|B ?
19:19:42 <Cale> heh, "Attempt to deliver acknowledgement confirmation failed. Will re-attempt to deliver acknowledgement confirmation for 0 more days."
19:19:47 <erisco> yes
19:19:59 <EvanR> instead of uninteresting, i would say its broken
19:20:14 <erisco> no it is the whole point in fact! :P
19:20:26 <glguy> Confirming acknowledgement, please confirm
19:20:27 <EvanR> it makes no sense
19:21:51 <glguy> Cale, do you want to be the first general, or the second general?
19:22:23 <ertes> Gurkenglas: the irc-core library doesn't make any of the mistakes the wiki article makes‚Ä¶  the only note i have is: the use of Text could be considered controversial
19:22:45 <glguy> /o\
19:23:21 <erisco> I had a quick summary of this fact the other day on -blah but have since forgotten it
19:24:00 <Cale> ertes: What about the use of Text is considered controversial?
19:24:14 <Cale> You mean just with respect to how IRC works?
19:24:24 <glguy> Presumably because I only support UTF-8 everywhere
19:24:25 <erisco> ah good, -blah has been slow so it is still in my log! checking‚Ä¶
19:24:40 <glguy> -ish, rather than per message encoding choices
19:25:48 <erisco> EvanR, this is what I posted to -blah a couple days ago or something‚Ä¶ it explains why they are all equivalent
19:26:16 <erisco> and at the bottom I realise a way to salvage the situation
19:26:59 <erisco> EvanR, dfeuer the link! http://lpaste.net/179952
19:27:11 <glguy> ertes: Perhaps doing it "right" would involve a function from Identifier -> Encoding to the parser
19:27:32 <glguy> and then Text could be used to store the Unicode representation of whatever encoding a chat message used
19:27:44 <ertes> Cale, glguy: not even that‚Ä¶  i just have trouble mentally mapping back and forth between octets (IRC) and characters (irc-core)
19:28:13 <glguy> IRC isn't a binary protocol, it's specified to use that swedish encoding
19:28:22 <erisco> so if someone could polish off and implement this idea so we can put exceptions to rest I'd be grateful :)
19:28:28 <ertes> true
19:29:05 <glguy> which is a subset of UTF-8 except for the funny casemapping of {}[]\|~`, which the library handles
19:33:28 <erisco> so, applying this, you can throw and handle exceptions, while being able to handle all exceptions and yet not losing information about the interesting ones
19:33:40 <erisco> where the interesting ones might be the likely ones, or the expected ones, or the handled ones, etc
19:34:28 <erisco> which is a boon to modularity! closed sums are not a modular approach to exceptions
19:34:28 <EvanR> oh exceptions... i bet theres a nice theory that can be dedicated to exception management
19:34:50 <glguy> ertes: What were your objections to the wiki article? A pointer or hint to some previous discussion would be an acceptable answer.
19:36:23 <ertes> glguy: mainly String and hGetLine
19:36:35 <erisco> so when you do case analysis on a particular exception, this then necessarily becomes an interesting exception, and so it is denoted by the type
19:36:54 <ertes> glguy: if nothing else, it opens you up for a DoS attack
19:37:07 <erisco> which is the natural way we do things with try/catch
19:37:23 <glguy> ertes: DoS from the IRC server?
19:38:14 <erisco> I consider it a significant hindrance to good software to have the clumsy solutions we currently do
19:38:58 <erisco> where in "good software" you expect errors/exceptions to be treated with dignity
19:39:53 <EvanR> do you have the rules for this written down
19:40:26 <erisco> I am not sure what system to write the rules in
19:40:52 <dolio> You should probably not write the types as "A|B", since that looks nothing like an infinite union of all types.
19:41:17 <erisco> I wrote it as A|B|‚Ä¶ in my -blah messages
19:41:38 <dolio> Right, and then you didn't here, which was the main thing that was confusing people, I think.
19:42:47 <erisco> the rules are based on the constructors you match, so I am not sure what system is relevant to that
19:42:59 <EvanR> instead of an infinite union of all types, can it be a single well defined structure with whatever exceptions need, like the tags that a catch will match along with a dynamic set of fields
19:42:59 <erisco> perhaps just an informal but clear description
19:43:05 <dolio> And also because finite anonymous unions also make sense.
19:43:21 * hackagebot mars 0.2.1.0 - Generates mountainous terrain using a random walk algorithm.  https://hackage.haskell.org/package/mars-0.2.1.0 (infrared)
19:43:25 <erisco> well no, because it is missing the core feature of openness dolio
19:43:30 <dolio> And are what you would handle if you don't have a catch-all case.
19:43:41 <erisco> if you just want closed unions that is fine, but that isn't what I am after
19:43:46 <EvanR> if the informal description mentions that there are types at all, then that doesnt sound like what you described
19:43:58 <erisco> yes that is right, but the catch-all case is paramount
19:44:44 <erisco> well you would write it where types go, though it encodes a property of the function
19:45:16 <dolio> Yes, but you don't need to arbitrarily rule out finite sums.
19:45:50 <erisco> I have been involved with a number of projects over a few years and this is a continual pain point
19:46:04 <EvanR> is it a special case expression where the patterns can be any types constructors at all?
19:46:16 <dolio> You can use something like row types, with the proviso that rows may be infinite. These sums are like the dual of records.
19:46:27 <EvanR> so it wouldneed runtime type information to know where to check
19:47:00 <EvanR> extensible variants
19:47:04 <dolio> So if `a : A` then `in a : A | Œ±` or something.
19:47:12 <EvanR> actually that makes way more sense
19:47:29 <dolio> And you can handle any finite number of cases, and a catch-all extends your handling to arbitrary rows.
19:47:39 <erisco> I am not sure what the implementation is yet, but perhaps there is a special notation for the catch-all
19:48:15 <dolio> Handling just a finite number of cases corresponds to a particular finite row.
19:48:22 <erisco> dolio, maybe I didn't understand what you meant by "arbitrary". The desire is not arbitrary, but I am also not saying to remove closed sums or finite unions either
19:49:05 <erisco> so if you have something finite then you might trivially open this with a catch-all, yes dolio, that should be possible
19:49:26 <erisco> i.e. the two things should be very close syntactically, just requiring the additional catch-all
19:52:20 <erisco> another application, though smaller, is that I have made state machines with a sum of states and a sum of transitions
19:52:37 <EvanR> check out extensible variants in the extensible records with scoped labels paper
19:52:56 <erisco> these are used in conjunction with a reactive scan so states update to inputs
19:53:09 <Squarism> what is the most popular IDE alternative for haskell atm? I wont persue any vim/emacs alternative.
19:53:23 <erisco> but being sums, I cannot easily modularise the states and transitions
19:53:24 <EvanR> of course, this actually has type safety so it might take more work and be safer
19:53:54 <erisco> also I interpret the states to do side effects, and I cannot modularise that easily either (the interpreters)
19:54:32 <erisco> EvanR, there is nothing that isn't safe about the idea, it isn't unsafeCoerce
19:55:03 <ertes> glguy: yeah
19:55:39 <erisco> if the constructor matches you're safe, and if no constructor matches you're safe with the catch-all
19:57:00 <erisco> Squarism, there isn't one, sadly, it is a wash when it comes to Haskell IDEs
19:57:40 <Squarism> hmm.. sad
19:57:43 <erisco> the Atom extensions for Haskell are decent, probably the best integration I have seen
19:58:06 <Squarism> i tried that but got a bunch of wierd errors
19:58:10 <erisco> out of Visual Studio and IntelliJ
19:58:22 <erisco> yeah, that happens too
19:58:24 <Squarism> cannot recall what now though
19:59:04 <Squarism> it just feels as if there could be a good ide - as the language itself seems so strict/well defined
19:59:34 <erisco> I tried Leksah and it was mediocre
20:00:23 <Squarism> im running intellij right now and it doesnt do more than a plain text editor
20:00:44 <Squarism> ...if there are no compile errors i can sometimes navigate code
20:00:57 <erisco> EvanR, do you have a link? I probably cannot understand it anyhow but worth a shot
20:01:06 <pavonia> Is there a guide or documentation of how to properly use the various RTS functions available from Rts.h?
20:01:40 <erisco> Squarism, there is an extension to add some ghc-mod features, though when I tried this a couple years ago it was horrendously laggy
20:01:54 <EvanR> ?google extensible records with scoped labels
20:02:00 <lambdabot> http://research.microsoft.com/en-us/um/people/daan/download/papers/scopedlabels.pdf
20:02:00 <lambdabot> Title: Extensible records with scoped labels
20:02:49 <erisco> thanks, I wasn't sure where the title began and ended, or if there was a title at all :P
20:05:13 <EvanR> i mention it at least 5 times a year
20:05:48 <erisco> Squarism, there is little money (seemingly) in making a Haskell IDE, and it is a significant undertaking
20:06:38 <erisco> if you could convince someone there were hundreds of businesses waiting to license it then maybe it'd happen
20:07:42 <kadoban> Haskell seems to be a fairly quickly moving target as well, which likely doesn't help.
20:09:13 <Squarism> erisco, i guess. I had hopes the community had something cooking
20:09:52 <glguy> fpcomplete attempted to make a commercially supported ide
20:10:00 <glguy> but eventually moved on
20:10:11 <erisco> Squarism, my methodology is to experiment in Haskell with Notepad++ and GHCi and then write applications in C#
20:10:55 <EvanR> before you can create an IDE you must first create a passable toolkit or binding
20:10:56 <erisco> I think they shot themselves in the foot by being inseparably a cloud service thingamabob
20:11:20 <EvanR> which is yet another huge thing in haskell, but i bet its a bigger problem to solve than the IDE
20:11:31 <erisco> the Haskell IDE is just excellent extensions to existing IDEs, we don't need more IDE programs
20:11:31 <EvanR> assuming you didnt have to create the toolkit
20:11:50 <Gurkenglas> EvanR, http://ircbrowse.net/browse/haskell?q=EvanR+scoped+labels you mean exactly five times in the ~5 months you had known it :P
20:11:59 <EvanR> example the atom editor is just chrome
20:12:08 <EvanR> so they concentrated on the IDE part
20:12:09 <Squarism> kadoban, i thought "modern" language compilers came with some IDE api for doing what needs to be done for any particular version of a language.  
20:12:15 <EvanR> and now its slow as hell
20:12:36 <EvanR> Gurkenglas: 5 months?
20:12:36 <erisco> I read it was slowest on record, hm
20:13:02 <EvanR> im not wrong tho
20:13:12 <EvanR> yet
20:13:21 <Gurkenglas> Well now you are, this was the sixth time
20:13:27 <erisco> seems like a difficult environment for doing computationally intensive analysis of programs, to respond in real time
20:13:44 <EvanR> curses
20:14:31 <Gurkenglas> wait nvm you said at least. uncurses
20:14:54 <EvanR> rses
20:22:47 <Gurkenglas> When msys2 runs ghci, pressing up moves me off the prompt line and the line I was writing gets like corrupted with \ESC characters, like so https://gyazo.com/720782c64ec82a406220a5acb99f5b6b and so https://gyazo.com/51ebcb7ac34ed6ea537756e03d82ec9c . What do?
20:28:23 * hackagebot result 0.2.3.0 - Encode success or at least one error  https://hackage.haskell.org/package/result-0.2.3.0 (srijs)
20:35:30 <geshe> GLU links and works for my executable but I get a linker error when I try to call my gui functions in ghci. Anyone got any ideas? Using stack
20:36:01 <geekosaur> are you running ghci directly, or using stack repl?
20:36:10 <geekosaur> (or stack ghci)
20:36:17 <Axman6> you probably need to explicitly load the library when calling ghci. there should be lots of info on using ghci with FFI around
20:36:59 <geshe> stack ghci.. working with a library that has some gui stuff that uses GLU
20:37:44 <geshe> ive tried adding -lGLU to the ghc options on my project .cabal
20:42:57 <jle`> what's a good name for a property of a list that all of the elements are equal?
20:43:05 <jle`> "allEqual", "allSame" ?
20:43:17 <glguy> homogenous ?
20:43:48 <jle`> ah, that's a nice one :)
20:46:31 <Squarism> gah, cant get over that there seems to be effort in creating a basic IDE/IDE-plugin. Has to be some root cause. Type/info / navigation / errors - atleast feels as it should be doable. 
20:46:45 <Squarism> to be NO effort
20:47:10 <geshe> Squarism: https://commercialhaskell.github.io/intero/
20:50:47 <geshe> geekosaur: http://lpaste.net/179961
20:51:48 <erisco> Squarism, you can found the effort you desire today!
20:52:23 <jle`> does anyone know if GHC optimizes away (dependently typed) proofs like idris does?
20:52:52 <erisco> in what fashion is GHC handling dependent types?
20:52:52 <jle`> like if an argument's only purpose is to provide a structural witness, is it possible that it is optimized away?
20:52:55 <geekosaur> that's not a linker error, that's a runtime symbol lookup by glu itself... suggesting it's somehow finding the wrong glu library (I'd expect a different error if it didn't find the library at all)
20:53:04 <jle`> like the classic Even example
20:53:43 <Squarism> geshe, "C-c C-t shows type info" ...and flips rows! =D
20:53:53 <erisco> I feel as though I should remind that compiler optimisations are unreliable
20:54:16 <jle`> eh i'll just write my code as it is now and hope that there will exist a time in the future that ghc would optimize it away
20:54:57 <jle`> exists t0. forall (t > t0). ghc version at time t will optimize my use case for me
20:55:12 <jle`> premature optimization is root of all sins etc
20:56:48 <erisco> except when it matters, like real time, or limited resources, where it is part of the requirement
20:57:23 <jle`> well premature optimization is by definition bad
20:57:43 <erisco> if you are really specific on what you mean by "premature"
20:57:52 <jle`> because appropriately timed consideration optimization wouldn't be premature
20:57:54 <glguy> Bad optimization is certainly bad
20:57:56 <jle`> it would be mature :)
20:58:22 <erisco> but it is often taken to mean, I estimate, that you run the code before you decide whether it satisfies performance requirements
20:59:20 <erisco> but this is wrongheaded. It suggests there is nothing predictable about it, so you might as well design it with your fingers crossed
20:59:51 <Squarism> ok.. so im trying Intero. Should i just open any file in my project and it will just work?
20:59:51 <geshe> geekosaur: ok thanks thats a helpful tip. Should I try giving ghci the explicit location to the library?
21:00:20 <geekosaur> you could try, yes
21:01:25 <erisco> instead of "sins" or "evils" I would say it is just a compelling way to waste time
21:04:12 <erisco> sometimes we extend our feeling of artistry to the way the program runs
21:05:16 <erisco> using the least memory and the least time is a physical elegance, a well tuned machine
21:05:49 <jle`> good insight
21:07:50 <Welkin> erisco: but that doesn't get things done
21:08:00 <Welkin> if something works, there is no reason to optimize it
21:08:09 <Welkin> optimization is a last resort, when necessary
21:08:18 <Squarism> geshe, is there something you need to do other than add that snippet to your .emacs? 
21:08:19 <Welkin> if the goal is to build something that does the job
21:08:38 <pikajude> how do I figure out what exception a SomeException is? not in code, but as a human being that wants to know which exception I'm supposed to be catching
21:08:50 <pikajude> "connect: does not exist (Connection refused)"
21:09:03 <Squarism> geshe, When doing that + opening a .hs file in a "stack project" .. then M x intero-targets isnt available in my case
21:09:37 * erisco *cough* open unions *cough*
21:09:38 <glguy> pikajude: Typeable is a superclass of Exception, typeOf :: Typeable a => a -> TypeRep
21:09:39 <geshe> Squarism: i think you might have to do a stack install intero first
21:09:52 <geshe> globally
21:09:53 <pikajude> glguy: typeOf (e :: SomeException) === SomeException
21:10:14 <glguy> pikajude: You have to pattern match on the SomeException to get the actual exception
21:10:21 <pikajude> Oh
21:10:34 <pikajude> right, my bad
21:11:03 <glguy> pikajude: Also that one is an IOError, isDoesNotExistError
21:11:40 <pikajude> thanks glguy 
21:15:44 <Squarism> anyone using intero? 1. opening .hs file (that is tree with a stack.yaml in an ancestor path. 2. Marking an expressionWhen doing C x C t .. to show types. 3. it complains some definition is "not in scope"
21:18:06 <Squarism> I can understand if emacs needs to know what "project" im working in. When doing M x intero-targets, it cannot find that "command" ?
21:19:09 <Squarism> Emacs/Vim: UX is for cowards!
21:22:31 <geshe> Squarism: I use it through spacemacs https://github.com/syl20bnr/spacemacs/tree/develop/layers/+lang/haskell#setup-path
21:24:13 <geshe> the intero support is on the develop branch
21:25:20 <joe9> Is there a haskell pattern / anti-pattern when programming with threads?
21:30:08 <pavonia> joe9: Communication via MVars and Chans is a common pattern, I think
21:32:37 <Squarism> geshe, i thought id use plain emacs, one step at a time. =D Sadly its just not working out at all
21:33:21 <geshe> is the stack install location on your path?
21:33:25 <Squarism> geshe, i think they assume things of the user. 
21:33:32 <Squarism> stack, ghc, ghci
21:33:35 <Squarism> all of them
21:33:56 <Squarism> do i need to do something for the instructions .emacs to "execute"?
21:34:16 <Squarism> when opening .hs file i have mode:Haskell 
21:34:24 <Squarism> so that seems to be something
21:34:35 <geshe> /home/user/.local/bin
21:34:51 <Squarism> what about that?
21:34:53 <Squarism> oh
21:34:59 <Squarism> on the path u mean
21:35:01 <geshe> thats where the intero bin is
21:35:19 <Squarism> yep
21:36:41 <Squarism> What ive done. 1. Added the config from https://commercialhaskell.github.io/intero/ into .emacs. 2. Started emacs in my project root (where stack.yaml resides). 3. Opened .hs file
21:36:44 <Squarism> thats it
21:37:03 <Squarism> ...and did stack install intero
21:37:26 <Squarism> also tried the : stack new intero-demo
21:37:32 <Squarism> in a clean dir
21:37:50 <Squarism> Still can find M x intero-targets
21:40:23 <joe9> Squarism: my haskell-init.el . I was tired of stuff breaking
21:40:42 <joe9> Squarism:  and simplified my init without any inferior process, less distractions.
21:40:52 <joe9> Squarism: but, keeps things simple and working.
21:41:26 <Squarism> joe9, cannot access that file
21:41:38 <joe9> pavonia:  https://hackage.haskell.org/package/async-manager-0.1.1.0/docs/Control-Concurrent-AsyncManager.html any thoughts on this, please?
21:42:01 <joe9> Squarism,  https://gist.github.com/1af198beb94b1b74340cc2d775b13bf5
21:42:20 <joe9> Squarism: this is just the haskell portion of my init.
21:42:24 <pavonia> I don't know that package
21:43:00 <joe9> pavonia: what is the recommended package to ensure that threads are running or not, etc. thread manager stuff?
21:43:34 <pavonia> I don't know, sorry
21:43:42 <Squarism> joe9, my problem seems to be i get no feedback on what is going on.. i have no "errors". Its just that intero lacks commands and cannot resolve symbols in my "project"
21:44:17 <pavonia> @where parallel and concurrent
21:44:18 <lambdabot> http://www.haskell.org/haskellwiki/Parallel
21:45:18 <pavonia> joe9: This is the recommended guide on the topic http://chimera.labs.oreilly.com/books/1230000000929/index.html
21:48:26 * hackagebot desert 0.1.0.3 - a simple build tool for OCaml projects  https://hackage.haskell.org/package/desert-0.1.0.3 (zjhsdtc)
21:48:28 * hackagebot casr-logbook-meta-html 0.0.1 - Meta-information about entries in a CASR 61.345 logbook (casr-logbook) HTML output  https://hackage.haskell.org/package/casr-logbook-meta-html-0.0.1 (TonyMorris)
21:49:10 <joe9> pavonia: Thanks.
21:53:26 * hackagebot desert 0.1.0.6 - a simple build tool for OCaml projects  https://hackage.haskell.org/package/desert-0.1.0.6 (zjhsdtc)
21:56:12 <joe9> pavonia: they are very good links. Thanks for them.
21:57:03 <pavonia> No problem
22:15:48 <joe9> pavonia: have you used the threads package? It seems to be more popular than the async package. Is it recommended over async?
22:17:38 <Axman6> I've never heard of the threads package... async is definitely highly regarded though
22:25:56 <cocreature> joe9: how are you coming to the conclusion that it‚Äôs more popular?
22:26:04 <cocreature> at least in my filter bubble async is vastly more popular
22:30:43 <cocreature> and the downloadnumbers on hackage confirm that
22:32:33 <jle`> hm, why is ConstrainedClassMethods an extension?  why shouldn't it work w/out one?
22:34:29 <glguy> jle`: The Haskell Report apparently says that it should work that way
22:34:57 <glguy> and the extension relaxes that
22:35:07 <glguy> (I don't know why the report says that though)
22:35:20 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=constrainedclassmethods#ghc-flag--XConstrainedClassMethods
22:35:28 <glguy> "The restriction is a pretty stupid one in the first place, so -XConstrainedClassMethods is implied by -XMultiParamTypeClasses."
22:37:20 <jle`> i see
22:48:09 <geekosaur> the report is *very* conservative about what is permitted, apparently in the hope if they made it simple enough it would be easier to have multiple implementations.
22:48:25 <geekosaur> needless to say, that didn't quite work out as planned
22:48:28 * hackagebot casr-logbook-reports 0.0.1 - CASR 61.345 logbook (casr-logbook) reports.  https://hackage.haskell.org/package/casr-logbook-reports-0.0.1 (TonyMorris)
22:53:28 * hackagebot idringen 0.1.0.3 - A project manage tool for Idris.  https://hackage.haskell.org/package/idringen-0.1.0.3 (zjhsdtc)
22:54:43 <dmwit_> To be fair, there were multiple implementations.
22:56:50 <geekosaur> there were, but the only one other than ghc that really lasted was hugs --- which supported most of the same extensions to typeclasses that ghc of that era did
23:09:20 <Squarism> so should i be able to mark, say a lambda in intero and be able to show its type?
23:10:15 <Squarism> ...or just any "expression"
23:13:28 * hackagebot AlanDeniseEricLauren 0.1.0.0 - Find the minimal subset/submap satisfying some property.  https://hackage.haskell.org/package/AlanDeniseEricLauren-0.1.0.0 (EchoNolan)
23:16:19 <dmwit> what an odd name for a package
23:18:07 <liste> sounds like a paper's authors
23:18:29 * hackagebot AlanDeniseEricLauren 0.1.0.1 - Find the minimal subset/submap satisfying some property.  https://hackage.haskell.org/package/AlanDeniseEricLauren-0.1.0.1 (EchoNolan)
