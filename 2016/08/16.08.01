00:02:36 --- mode: ChanServ set +o glguy
00:03:56 --- mode: glguy set +b plutoniix!*@*$##fix_your_connection
00:07:40 * hackagebot type-spec 0.1.0.0 - Type Level Specification by Example  https://hackage.haskell.org/package/type-spec-0.1.0.0 (SvenHeyll)
00:07:40 * hackagebot enummapset-th 0.6.1.1 - TH-generated EnumSet/EnumMap wrappers around IntSet/IntMap.  https://hackage.haskell.org/package/enummapset-th-0.6.1.1 (LiyangHu)
00:08:52 --- mode: glguy set +o glguy
00:08:56 --- mode: glguy set -o glguy
00:20:28 <nlambdapa> hi guys
00:21:09 <lambdapansy> can i build hard realtime systems in haskell?
00:21:59 <Koterpillar> the right question to ask is, will haskell help me build X
00:22:49 <lambdapansy> will haskell help me build systems with predictable latency, memory use, cpu use?
00:23:35 <liste> lambdapansy: yes, Haskell will: https://hackage.haskell.org/package/atom
00:24:02 <Koterpillar> I don't think there are meaningful ways you can use haskell to compile such programs. If anything like that exists, I think it would be a language to describe/compile such systems
00:24:22 <Koterpillar> ...such as the one liste linked before I finished the sentence :)
00:24:50 <freeside> that's what we call a "concurrency problem"
00:26:08 <liste> IRC should have locks
00:26:33 <Koterpillar> liste: write a XEP
00:28:06 <freeside> haha
00:30:27 <maybefbi> i want to generalizednewtypederive a monaderror instance for https://hackage.haskell.org/package/hasql-pool-0.4.1/docs/Hasql-Pool.html#t:UsageError in the servant's handler monad. i tried "newtype DBError = DBError { unDBError :: HP.UsageError } deriving (Show, MonadError DBError Handler)" but it is expecting a kind "* -> ghc-prim-0.4.0.0:GHC.Prim.Constraint" for the MonadError typeclass 
00:37:09 <lambdapansy> is there a well established mechanism for automatically generating C or C++ bindings for haskell (or somehow skipping the need for writing them in the first place)?
00:38:09 <maybefbi> lambdapansy, you will need to write a cdecl parser and then use the ast output to generate some haskell using template haskell
00:38:28 <maybefbi> then you need to feed it some header files
00:39:01 <lambdapansy> lol c gibberish <-> english hahaha
00:39:44 <solrize> @pl \a b = 1 + a + b
00:39:44 <lambdabot> (line 1, column 6):
00:39:44 <lambdabot> unexpected "="
00:39:44 <lambdabot> expecting pattern or "->"
00:39:47 <maybefbi> lambdapansy, https://github.com/USF-CS345-starterkits/parrt-cdecl/blob/master/grammars/cs345/cdecl/CDecl.g4 thats the BCNF file
00:39:50 <HallaSurvivor> quit
00:39:56 <solrize> @pl \a b -> 1 + a + b
00:39:56 <lambdabot> (+) . (1 +)
00:40:35 <liste> @hackage inline-c -- lambdapansy, maybe this is what you need?
00:40:35 <lambdabot> http://hackage.haskell.org/package/inline-c -- lambdapansy, maybe this is what you need?
00:42:28 <maybefbi> lambdapansy, https://hackage.haskell.org/package/c2hs
00:43:00 <maybefbi> lambdapansy, thats what you are looking for
00:43:03 <solrize> @pl let f a b = a : f b (a+b) in f 0 1
00:43:03 <lambdabot> fix (liftM2 (.) (:) . (. (+)) . ap) 0 1
00:44:35 <lambdapansy> and what does the overhead to calling c look like?
00:44:45 <lambdapansy> do you have to copy memory or anything?
00:45:29 <maybefbi> lambdapansy, there are different marshalling strategies: https://wiki.haskell.org/Foreign_Function_Interface
00:45:30 <augur> solrize: you can /msg lambdabot, fyi
00:45:35 <lambdapansy> not touched in a year :-/
00:45:39 <solrize> augur oh cool thanks
00:47:21 <maybefbi> lambdapansy, if you use c2hs it will help you with data structure marshalling
00:48:55 <lambdapansy> lol C--
00:49:07 <johnw> or c2hsc
00:52:53 <lambdapansy> i'm not realistically going to port mersenne twister to haskell
00:53:55 <maybefbi> lambdapansy, thats why you have to try. you need to get used to how it is done in haskell.
01:23:39 <lambdapansy> so is there a language more "modern and sophisticated" than haskell?
01:23:48 <lambdapansy> or am i foolish for asking in this channel? ;)
01:26:35 <maybefbi> lambdapansy, try agda, idris
01:27:37 * hackagebot hw-rankselect 0.1.0.0 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-rankselect-0.1.0.0 (haskellworks)
01:38:59 <toogley> is there a way how i can convenient execute the to the current buffer corresponding binary, which was produced by some compiler? i found https://www.emacswiki.org/emacs/ExecuteExternalCommand but maybe emacs has already a solution?
01:39:38 <toogley> => e.g. i'm in haskell mode, editing a .hs file. i can compile that with M-x haskell-compile . how do i execute that?
01:39:56 <toogley> aah, sry. wrong channel :D
01:57:14 <lambdapansy> can i compile haskell so that it doesn't need GC,... e.g. has ARC or something?
01:59:54 <liste> lambdapansy: not really
02:00:22 <liste> lambdapansy: http://www.ats-lang.org/ can do that, and maybe Idris someday
02:02:59 <niteria> does anyone know if Chris Done hangs out here?
02:05:05 <maybefbi> niteria, chrisdone is online on this server. use / msg to message him directly
02:05:39 <lambdapansy> programming languages suck
02:06:01 <niteria> maybefbi: thanks!
02:06:19 <lambdapansy> and there are too many of them
02:06:46 <maybefbi> lambdapansy, don't overthink it. keep calm and choose haskell
02:06:56 <lambdapansy> haha
02:07:16 <maybefbi> lambdapansy, but if you are more prone to writing loops instead of recursion, read The Little Schemer first
02:07:25 <lambdapansy> i'm debating between haskell, rust, and julia for my next language
02:07:53 <liste> lambdapansy: for hard real-time embedded programming?
02:08:06 <lambdapansy> no
02:08:08 <merijn> lambdapansy: I would say haskell or rust
02:08:25 <lambdapansy> i was just curious whether haskell had been used for realtime stuff
02:08:44 <merijn> Rust if you want bare-metal, (hard) realtime, etc. haskell for almost everything else :p
02:09:01 <raichoo> merijn +1
02:09:02 <liste> merijn++
02:09:25 <merijn> lambdapansy: There's some soft realtime stuff like games and audio/video stuff
02:09:38 <lambdapansy> audio is pretty sensitive
02:09:46 <lambdapansy> how soft?
02:09:48 <merijn> But tbh, if I was personally doing soft realtime with tight latency I'd probably not go for haskell
02:10:02 <merijn> lambdapansy: Some livecoding tools exist in haskell
02:10:04 <lambdapansy> 1 msec for audio matters
02:10:10 <merijn> I've never used them, though
02:10:23 <liste> well, if you have enough processing time slack it's not that big of a problem
02:10:35 <lambdapansy> i kinda think garbage collection is an unnecessary concept, but i can't prove it
02:11:58 <liste> lambdapansy: http://stackoverflow.com/a/89346/1283954 may be interesting
02:12:16 <liste> and the other answers to that
02:14:24 <lambdapansy> "no, there is no elegant way to have closures and no real GC" - heh
02:14:59 <lambdapansy> jesus christ though, if you are doing image processing from a camera
02:15:10 <lpaste> Ulrar pasted “No title” at http://lpaste.net/173297
02:15:26 <lambdapansy> and you have "immutable" images coming in, each of which are 5MB or something at 30 fps
02:15:32 <Ulrar> Is there a way to force it to use the latest version only ?
02:15:42 <Ulrar> I don't have that problem on my other computer with the exact same sources
02:17:27 <lambdapansy> doesn't it make sense to have some kind of fixed buffer for these images as they are processed?
02:18:00 <lambdapansy> i'd hate to think that the way to do this is to continuously allocate a stream of memory and then let that memory get GC'ed
02:18:19 <merijn> Ulrar: Presumably your dependencies rely on different version
02:18:28 <merijn> lambdapansy: Why?
02:18:34 <merijn> lambdapansy: Modern allocators are cheap
02:18:45 <lambdapansy> time?
02:19:03 <lambdapansy> cache?
02:19:17 <merijn> lambdapansy: See earlier remark about "modern allocators are cheap" and cache is hardly an issue there
02:19:36 <merijn> lambdapansy: tbh, if you wanna be fast streaming images you should be using mmap instead of manually reading data anyway
02:19:38 <Ulrar> merijn: Any way to know which ? Guess I can update everything but that might take a while
02:20:03 <merijn> Ulrar: Well, you can simply add a dependency on the new time and then cabal will yell at you that some package can't compile :p
02:20:35 <merijn> lambdapansy: Especially for something like streaming image data the allocation overhead is going to be near zero
02:20:51 <merijn> lambdapansy: Most of your time will be spent 1) loading data from disk and 2) doing processing
02:21:03 <lambdapansy> acquired images
02:21:17 <merijn> lambdapansy: Worrying about allocation overhead there is likely spending time optimising something that is <1% of your runtime
02:21:25 <merijn> lambdapansy: Golden rule: Don't optimise what you haven't profiled
02:21:48 <lambdapansy> well, yes you can accuse me of overoptimizing
02:21:57 <Ulrar> I'm trying to just use ghc --make currently, guess I should learn how to write cabal files then
02:22:07 <lambdapansy> but,... suppose i was editing a 1 GB video file loaded into memory,...
02:22:13 <lambdapansy> i change 1 frame in it
02:22:14 <merijn> lambdapansy: Out of curiosity, have you actually written high performance code before?
02:22:23 <lambdapansy> and then now i need to allocate another 1 GB video file?
02:22:29 <merijn> Ulrar: Starting point should be "cabal init" <- fill in questions
02:22:38 * hackagebot monoidal-containers 0.3.0.0 - Containers with monoidal accumulation  https://hackage.haskell.org/package/monoidal-containers-0.3.0.0 (BenGamari)
02:23:25 <merijn> lambdapansy: First off, why would you not edit in place, secondly, why do you think allocating 1 GB costs a lot of time (compared to actually doing the editing), thirdly, a 1 GB video file I'd expect to take up way more than 1 GB in memory when editing, because no one edits compressed file formats
02:23:47 <lambdapansy> merijn: sure you can accuse me of being a dummy if you like,... i've done mostly numeric computing,... moderately time sensitive
02:24:21 <lambdapansy> merijn: but "all variables in haskell are immutable"?
02:24:22 <merijn> lambdapansy: I'm not accusing you of being a dummy, but allocation outside of an inner loop is basically free.
02:24:52 <lambdapansy> merijn: yes, allocation outside of an inner loop is free, i agree
02:25:00 <liste> lambdapansy: all variables are immutable, but not all data
02:25:46 <liste> you can have references to mutable data, mutable arrays etc..
02:25:47 <merijn> lambdapansy: If I edit frame 500,000 out of 1 million you don't need to copy the last half at all, I only need to create a new first half, and actually if you're representing them with some data structure like a rope, that's probably like O(log n) operations. Not to mention you can do mutable updates in haskell just fine
02:27:50 <lambdapansy> ... and i need a package to have mutability it looks like? and there are like a dozen different packages?
02:29:24 <liste> lambdapansy: just use the correct types - STRef, IORef, STArray, IOArray etc..
02:29:42 <liste> vector is preferred to array though
02:29:55 <lambdapansy> what source were you using to determine the "correct type"?
02:32:00 <liste> lambdapansy: different sources, but this is one introduction to the topic: http://blog.jakubarnold.cz/2014/07/20/mutable-state-in-haskell.html
02:34:11 <ertes> this may be a peculiar request: i need an empty type class all types are an instance of without dragging along any actual information…  in other words i need a partially applicable version of this:  type Any a = (() :: Constraint)
02:34:42 <ertes> use case:  data X c = forall s. (c s) => X s …
02:36:39 <ertes> most applications would use this "Any" constraint, but some would benefit from specific constraints like Unbox
02:36:57 <maybefbi> lambdapansy, http://progandprog.blogspot.sg/2009/10/video-processing-on-haskell-easy.html
02:37:02 <ertes> any ideas?
02:37:16 <lambdapansy> ...adn now i'm reading a research paper. haha
02:37:40 <maybefbi> one of those papers i bet
02:37:48 <liste> lambdapansy: get used to it in this channel (:
02:38:04 <lambdapansy> maybefbi: those are bindings :(
02:38:25 <lambdapansy> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/lock-free-flops06.pdf
02:38:36 <maybefbi> lambdapansy, http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
02:39:40 <lambdapansy> haha that's good propaganda
02:41:19 <maybefbi> She ruins you for the RealWorld.
02:41:43 <lambdapansy> 'You can use lenses instead of mutable objects, to get "setter-like" behavior. Try that before messing around with mutable state, which is very ugly in Haskell'
02:41:53 * liste doesn't need to know about the RealWorld
02:42:17 <liste> I don't think mutable state is that ugly
02:42:23 <liste> it sure is less ugly than in other languages
02:42:25 <ertes> lambdapansy: any source that says that mutable state is ugly in haskell should be taken with a grain of salt, especially when it promotes lenses as a better alternative
02:42:35 <lambdapansy> haha
02:42:42 <ertes> that's like "replace mutability by mutability…  it's the better mutability"
02:42:50 <lambdapansy> haha
02:42:53 <maybefbi> state is evil sheeple. im not an anarchist.
02:43:14 <lambdapansy> so this is the "no one way" problem
02:43:19 <lambdapansy> i guess?
02:43:48 <maybefbi> it is hard to know these things from an armchair
02:44:05 <maybefbi> RealWorld is too complex to be modelled using admonisms and speculation
02:44:12 <liste> lambdapansy: certainly, there's whole programming paradigms developed to make state handling more sane
02:44:16 <maerwald> mutable state is perfectly fine, unless it's global or unless the rules who can mutate it are unclear
02:44:23 <ertes> lambdapansy: i suggest you just write code and find out for yourself…  you will hear as many different opinions to this as there are people answering
02:44:54 <maybefbi> i agree with ertes 
02:45:16 <lambdapansy> maerwald: i gave the example of changing a single frame in a huge video file loaded completely into RAM
02:45:57 <ertes> lambdapansy: that's a weird example, but yeah, we have mutable arrays
02:46:27 <maerwald> even doing simple things like quicksort require mutability
02:48:01 <dennisrt> hello. how can i get vim-syntastic to read "default-extensions" in my cabal file?
02:48:24 <liste> there's a whole world of persistent (immutable) data structures and algorithms out there - https://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
02:48:24 <Ulrar> So I noticed that I repeat forceEither $ lookupValue ... often when parsing my config file, so I thought function composition would be great there
02:48:31 <Ulrar> I did this : getConfigVal = forceEither . lookupValue
02:48:35 <ertes> dennisrt: ideally don't use default-extensions, but use LANGUAGE pragmas
02:48:53 <maerwald> liste: some algorithms _by design_ require mutable data structures
02:48:55 <Ulrar> But apparently lookupValue is being applied too few argument, did I miss something about composition ?
02:49:03 <maerwald> ertes+
02:49:16 <maerwald> default-extensions can bite you
02:50:00 <maybefbi> dennisrt, install ghc-mod and follow this: http://www.stephendiehl.com/posts/vim_haskell.html
02:50:25 <maerwald> he probably has already ghc-mod installed if he uses syntastic
02:50:31 <maerwald> that's the whole point of it
02:50:40 <ertes> even so, don't use default-extensions…  your contributors will thank you
02:50:49 <ertes> it's just such a badly supported field
02:50:57 <maerwald> yep, imagine adding OverloadedString to default-extensions :o
02:51:22 <ertes> i like the idea of having extensions in every file, but the tool support is terrible
02:51:22 <maerwald> (I did that and it was bad)
02:51:56 <dennisrt> i see, thank you. :)
02:52:12 <maerwald> I'll check if it works for me though
02:53:12 <ertes> i used to enable certain extensions project-wide like ScopedTypeVariables, because back then i used compilation in my development cycle
02:53:19 <maybefbi> dennisrt, may i suggest using atom with vim keybindings and ide-haskell plugin?
02:53:27 <ertes> but when i moved to an interactive development cycle i quickly dispensed of default-extensions everywhere
02:53:42 <maerwald> dennisrt: works here
02:53:43 <ertes> s/of/with/
02:53:58 <maerwald> dennisrt: so either ghc-mod is not properly set up or you hit a bug
02:54:14 <maerwald> or your cabal file is not entirely correct
02:56:04 <maerwald> https://github.com/DanielG/ghc-mod/issues/684
02:56:17 <maerwald> that's old and fixed
02:56:44 <lambdapansy> i'm looking at the haskell wiki entry on mutable state and it is talking about "proposals" for handling mutable state
02:56:57 <lambdapansy> i guess this means that the dust isn't settled on the question of how to do this?
02:57:25 <liste> lambdapansy: which page?
02:57:36 <lambdapansy> https://wiki.haskell.org/Top_level_mutable_state
02:57:46 <liste> lambdapansy: that's about *top level* mutable state
02:57:47 <maerwald> well, that's top-level
02:57:52 <maybefbi> lambdapansy, for image processing and general video frame manipulation, use repa.
02:57:53 <liste> it's a totally different  thing
02:58:09 <maerwald> I use the IORef hack for some of my unit tests, but that's all
02:58:19 <liste> top level mutably state is basically global mutable state — you shouldn't use it
02:58:41 <maerwald> can be useful for simple GUI programs though
02:58:46 <lambdapansy> Stability    experimental
02:58:50 <lambdapansy> hehe
02:58:54 <maerwald> where you don't care about passing configuration/state around explicitly
02:58:58 <merijn> liste: I would say "it depends"
02:58:59 <maybefbi> not even C programmers are encouraged to use global mutable state
02:59:13 <maerwald> encouraged != real world
02:59:28 <maerwald> I haven't seen a single Gtk program in C that doesn't have global mutable state
02:59:37 <maerwald> at least of some sort
03:00:07 <maybefbi> where there is a way, the will to use said way will be found.
03:00:35 <maerwald> it's about real-world programming, not about will ;)
03:00:39 <ertes> in haskell global state has bitten me every single time i tried to use it
03:00:52 <maybefbi> yeah thats why most people dont use it
03:01:07 <ertes> just use functions…  it's not really more work, and it doesn't bite you
03:01:40 <ertes> in fact functions often turned out to be *less* work
03:01:41 <maybefbi> in C it doesnt bite. it is only discouraged. hence there is a way. and the will/excuse to use the way is found 
03:02:25 <lambdapansy> sorry i wasn't clear, it says the stability of repa is "experimental"
03:02:35 <ertes> i advise against using ReaderT for the same reason
03:02:38 <dennisrt> maybefbi i'm using xmonad and usually try to avoid graphical programs. but i'll have a closer look at the vim tutorial
03:02:39 * hackagebot tpar 0.1.0.0 - simple, parallel job scheduling  https://hackage.haskell.org/package/tpar-0.1.0.0 (BenGamari)
03:02:40 <maerwald> maybefbi: ofc it bites in C
03:02:52 <maerwald> it always depends how you use it
03:03:11 <ertes> lambdapansy: you find that on many packages
03:03:35 <lambdapansy> haha great marketing?
03:03:54 <ertes> lambdapansy: "experimental" basically means: "seems to work, but don't sue me, if it crashes your business" =)
03:03:58 <lambdapansy> it should say "stability: hulk hogan rock hard"
03:04:34 <ertes> and it's often more about API stability than code quality
03:05:03 <maerwald> well, in haskell, people like to break API :P
03:05:17 <maybefbi> avoid success at all costs
03:05:36 <maybefbi> thats what simon said
03:06:10 <maerwald> well, they failed :P
03:06:46 <maybefbi> :D
03:06:57 <ertes> but we resisted for a long time
03:07:16 <maerwald> I think the "we don't care about breakage so much" mindset is still wide-spread
03:07:37 <maerwald> has pros and cons ofc
03:07:47 <lambdapansy> haha
03:07:49 <ertes> i prefer it
03:07:57 <lambdapansy> i like python because i can just find a library for whatever i'm doing
03:08:07 <lambdapansy> and it will nearly always be stable and work brilliantly
03:08:23 <maerwald> I think people should be more careful about their API design up-front and not mess with it every 2 months
03:08:29 <liste> Haskell libraries generally are good quality, there just isn't that many of them
03:08:56 <ertes> lambdapansy: the former is true for haskell as well, but the latter not so much…  python code doesn't seem to rot, except perhaps between major versions (like python 2 vs. 3), but in haskell code rots very quickly
03:09:12 <ertes> code from 2013 is far from guaranteed to work today
03:09:24 <maerwald> are you kidding? even from half a year ago xD
03:09:25 <lambdapansy> heh is that due to the language itself?
03:09:38 <maerwald> partly, ghc also breaks a lot with new versions
03:09:47 <ertes> lambdapansy: it's because we embrace breaking changes a lot more than other languages
03:09:57 <lambdapansy> yeah, that's a good thing actually
03:09:58 <liste> lambdapansy: yes, Haskell is kind of a test bed for programming language research
03:10:10 <lambdapansy> but it also means that haskell isn't usable commercially
03:10:17 <ertes> lambdapansy: we tend to fix historical mistakes at the cost of breaking some old code
03:10:18 <maerwald> I'd say facebook doesn't appreciate that
03:10:28 <maybefbi> lambdabot, here is a tip go to http://packdeps.haskellers.com/reverse and sort packages by most reverse dependencies. i do that when i have more choices.
03:10:33 <maybefbi> lambdapansy, 
03:10:46 <liste> lambdapansy: some organizations use Haskell in their core business, but they invest in it heavily
03:10:46 <maerwald> ertes: well, why don't they fix the String and FilePath mistakes then?
03:10:58 <liste> lambdapansy: like developing their own Haskell compiler etc
03:11:09 <maerwald> facebook uses GHC
03:11:24 <ertes> maerwald: good question…  bytestring and text belong into the base library IMO
03:11:32 <ertes> then it could be fixed
03:12:09 <liste> does Facebook still employ some core Haskell people?
03:12:23 <liste> any Simons?
03:12:28 <ertes> liste: simon marlow, AFAIK
03:12:32 <lambdapansy> you're referring to galois probably
03:12:42 <maerwald> https://github.com/facebook/Haxl -- that's the main thing they are using afaik
03:12:50 <lambdapansy> yeah i saw haxl,...
03:13:20 <liste> lambdapansy: Standard Chartered developed their own Mu compiler, AFAIK
03:15:14 <lambdapansy> yeah haskell does seem like a programming language research platform
03:15:26 <lambdapansy> i mean, it's good, i'm happy it exists
03:16:36 <lambdapansy> " Strings in Mu are not linked lists of characters—a major Haskell performance wart"
03:16:39 <lambdapansy> wtf seriously
03:16:49 <liste> lambdapansy: that's why we have Text
03:16:54 <maerwald> yes, it's correct
03:17:00 <lambdapansy> lol
03:18:00 <ertes> lambdapansy: base library string handling is terrible, but don't worry…  you use Text where it matters =)
03:18:48 <lambdapansy> shouldn't the compiler be able to like "understand" what the code wants to do and transcribe it to some fast C or something
03:18:55 <maerwald> or ByteString
03:19:05 <maerwald> "what the code wants" :D
03:19:18 <lambdapansy> hehe,... what the programmer wants
03:19:29 <lambdapansy> i shouldn't have to deal with a zillion string types
03:19:41 <raichoo> -XCrystalBall? :)
03:20:01 <ertes> lambdapansy: we have some of that, e.g. stream fusion
03:20:20 <maerwald> haskell isn't a declarative language, although a lot of things can feel declarative
03:20:33 <ertes> lambdapansy: you create, transform and then fold arrays, and the resulting program is a tight loop that uses no arrays at all
03:21:02 <ertes> lambdapansy: and it's not fast C, because it would be slower that way…  it's fast native code =)
03:21:13 <maerwald> lambdapansy: what you describe sounds like MDSD and it exists, but it's mostly proprietary
03:21:27 <maybefbi> lambdapansy, import Data.String.Conv
03:21:50 <maerwald> and I know in fact a company that has used haskell for writing a DSL that is used in the context of MDSD (e.g. SCADE)
03:22:07 <ertes> lambdapansy: we also have a rather formal idea of what it means for the compiler to "understand" your code:  your program has expressive types, so the compiler has extra information it can use
03:23:22 <lambdapansy> yeah this is going to sound dumb but haskell seems to be incredibly focused on types and type annotations
03:24:13 <ertes> lambdapansy: we use that in many ways:  we use it to let the compiler write the code (we call this "deriving"), we use it to optimise code, and of course we use it to encode invariants
03:24:21 <maerwald> but that's not even what makes it special imo. There are a lot of languages with strict types
03:24:44 <Jinxit> maerwald: there's definitely a difference in how types are used compared to, say, c++
03:24:45 <lambdapansy> sometimes i write code which is nothing but floats and arrays of floats
03:25:03 <lambdapansy> haskell would be very bored by it,... and type assurances would provide more or less no benefit
03:25:14 <Jinxit> unless you use opaque types
03:25:31 <flux> lambdapansy, do all floats signify same kind of values?
03:25:31 <ertes> lambdapansy: you'd be surprised by how exciting "floats and arrays of floats" can get ;)
03:25:32 <raichoo> lambdapansy: If you don't use language extensions most of the types can be inferred. However, I tend to write them down for documentation reasons.
03:25:36 <Jinxit> Area, though represented by a float, is not at all a Volume
03:26:08 <maerwald> Jinxit: java is strictly and statically typed
03:26:19 <maerwald> but it doesn't pull effects into the type system like haskell does
03:26:19 <ertes> lambdapansy: from there you quickly go to repa and functional array abstractions to comonadic patterns for multimedia processing
03:26:22 <lambdapansy> right, but boxing types with unit annotations just adds unnecessary overhead
03:26:37 <mniip> not with newtype
03:26:40 <maybefbi> real programmers don't need types, they just need a magnetized needle and a steady hand. /s
03:26:52 <mniip> newtypes are erased in core
03:27:05 <ertes> lambdapansy: the overhead is *always* optional
03:27:40 * hackagebot kawaii 0.0.1.0 - Utilities for serving static sites and blogs with Wai/Warp  https://hackage.haskell.org/package/kawaii-0.0.1.0 (etcinit)
03:27:59 <lambdapansy> ok, here is a use case i am interested in:
03:28:12 <lambdapansy> i want a database with custom types which i specify
03:28:18 <lambdapansy> that the database enforces
03:28:26 <lambdapansy> e.g. a ranged float
03:28:49 <lambdapansy> btw i think many advances in science have come from type abuses
03:29:14 <ertes> lambdapansy: that's one of those cases again: "as many different answers as people answering" =)
03:29:56 <lambdapansy> what's the "vanilla" database option in haskell
03:30:02 <maerwald> none
03:30:10 <lambdapansy> write my own db?
03:30:16 <ertes> lambdapansy: you can always just use the database binding of your choice
03:30:16 <maerwald> use a library
03:30:23 <ertes> postgresql-simple, sqlite-simple, etc.
03:30:59 <maerwald> haskell isn't like erlang, designed for a specific purpose, so there's not much "vanilla" going on anywhere in that field
03:31:20 <ertes> lambdapansy: this is a philosophical point, but i believe that it's a mistake to abstract away the database…  i would abstract the *application* instead
03:31:27 <lambdapansy> right, but i'm doing all this work implementing types in haskell
03:31:35 <lambdapansy> i might as well get mileage out of them,...
03:31:54 <MasseR> lambdapansy: There's also persistent, groundhog, haskelldb, acid-state etc
03:31:58 <ertes> lambdapansy: you'll get that with almost every solution
03:33:55 <lambdapansy> lol
03:33:59 <lambdapansy> Stability Unknown
03:34:09 <lambdapansy> it isn't even shitty stability
03:34:20 <lambdapansy> nobody has bothered running it
03:34:24 <maerwald> haha
03:34:25 <lambdapansy> so it's unknown stability
03:34:40 <ertes> i don't think i've ever paid attention to that field =)
03:35:01 <lambdapansy> Stability: Neegs Viagra
03:35:11 <alar1> фмщшв ыефишдшен фе фдд сщыеы
03:35:20 <lambdapansy> Stability: Lindsay Lohan
03:35:21 <alar1> avoid stability at all costs
03:35:51 <Jinxit> move fast break everything fuck users
03:36:01 <maerwald> Jinxit: xD
03:36:07 <lambdapansy> haha
03:36:44 <maerwald> I think you just described the philosophy of Gtk+ developers
03:37:28 <lambdapansy> wait so persistent wants me to "mirror the database table"
03:37:38 <lambdapansy> i'm already defining my types in haskell
03:37:44 <lambdapansy> i shouldn't have to mess with sql
03:37:46 <mniip> alar1, nice cyrillic layout
03:37:49 <ertes> lambdapansy: persistent wants your types to accurately represent the underlying tables
03:38:00 <lambdapansy> i want one damn place to specify the db
03:38:06 <lambdapansy> err the types
03:38:26 <lambdapansy> i'm tired of typing, my hands hurt
03:38:56 <maerwald> lambdapansy: beware of RSI
03:39:01 <ertes> lambdapansy: persistent is for you then…  it's the lowest common denominator…  not the fastest, not the most flexible, but definitely the one with the least amount of typing
03:39:14 <ertes> and groundhog, i think
03:39:29 <liste> IIRC persistent can manage migrations itself, so if you have a greenfield project, it can create the tables for you
03:40:31 <ertes> yeah, it can
03:40:44 <lambdapansy> but the backend is still postgres
03:40:47 <ertes> persistent is a do-what-i-mean library
03:41:08 <ertes> lambdapansy: it has many backends
03:41:27 <lambdapansy> haskell itself needs to implement the db i think
03:41:37 <ertes> have fun doing that =)
03:41:41 <Ford_Prefect> Hi folks
03:41:51 <Ford_Prefect> I'm looking for a library to generate C code -- any suggestions?
03:42:01 <maerwald> GHC
03:42:18 <lambdapansy> what's the name of that library for generating random C code
03:42:22 <liste> @hackage language-c -- Ford_Prefect
03:42:22 <lambdabot> http://hackage.haskell.org/package/language-c -- Ford_Prefect
03:42:33 <lambdapansy> https://embed.cs.utah.edu/csmith/
03:42:34 <Ford_Prefect> liste: the language-c API is (understandably) at the AST level, so can't generate macros, #includes, etc.
03:42:46 <lambdapansy> csmith generates excellent C code
03:42:52 <ertes> Ford_Prefect: there are some AST implementations for C, if you need that, but if all you need is a string composition library with layout, you can do what jmacro does (with JS)
03:43:26 <ertes> wl-pprint-text may get you there
03:44:17 <Ford_Prefect> Cool, thanks, I'll take a look at what csmith is doing and if all else fails, wl-pprint-text
03:45:02 <Ford_Prefect> Or maybe some horrific combination of string concatenation and constructing and pretty priting blocks using language-c
03:45:27 <lambdapansy> the csmith link was intended to be a joke, but it might be useful anyway ;)
03:45:48 <Ford_Prefect> :)
03:46:14 <Ford_Prefect> Oh, I thought csmith was in Haskell. Less useful then.
03:46:23 <lambdapansy> haha ok
03:47:11 <lambdapansy> http://www.scs.stanford.edu/14sp-cs240h/projects/puttagunta_debray_tu.pdf
03:48:54 <alar1> there is Language.C.Inline
03:50:17 <Ford_Prefect> alar1: I figured that'd do C -> whatever rather than what I'm tring (which is something -> C)
03:51:52 <lambdapansy> it looks like they failed to implement a database in haskell in their paper hehe
03:52:42 <alar1> nope, it is inlining C in haskell programs
03:55:39 <maerwald> lambdapansy: " However, we also need dynamic types, which presents difficulties given Haskell’s unusually strong type system" -- hehe
03:57:21 <haskell127> is it possible to write `foo . bar (\case x -> 1)` without parentheses?
03:57:28 <lambdapansy> https://github.com/acid-state/acid-state
03:57:41 * hackagebot gipeda 0.3.2.1 - Git Performance Dashboard  https://hackage.haskell.org/package/gipeda-0.3.2.1 (JoachimBreitner)
03:57:50 <lambdapansy> "Acid-state does not write your data types to disk every time you change it. It instead keeps a history of all the functions (along with their arguments) that have modified the state. " wtf
03:58:00 <koz_> OK, I need some advice. I have a list of monotonically non-decreasing numbers, and I wanna find the longest homogenous tail. Would it be smarter to do something like 'length . last . group', or combo of takeWhile, head and reverse?
03:58:22 <lambdapansy> "There are a few answers to this depending on the situation. One solution is to just buy more RAM. After all, you can buy machines with 1TB of RAM these days."
03:58:28 <maerwald> lambdapansy: I think the concept of having a core library written in C and building a higher-level API around it in haskell is sometimes more appealing than doing it all in haskell.
03:58:36 <lambdapansy> whoever wrote this was high
03:58:44 <merijn> lambdapansy: Why?
03:58:51 <lambdapansy> 1TB RAM??
03:58:53 <koz_> merijn: 1TB of RAM might be a clue.
03:58:56 <lambdapansy> am i made of money?
03:58:59 * merijn gets out his mantra: "Acid state is not a database"
03:59:00 <koz_> ${DEITY}-damn ninjas.
03:59:13 <SeriousBug[m]> lambdapansy: More like, whoever wrote this has a lot of money
03:59:35 <merijn> koz_: I've had colleagues work on machines with 5 TB RAM, if your problem size warrants it, it's certainly an option
03:59:50 <koz_> merijn: Yeah, but it's not exactly pedestrian.
03:59:58 <koz_> (or cheap...)
04:00:00 <merijn> More importantly, as I mentioned before: Acid state is not a database
04:00:20 <cocreature> merijn: given that the description of acid-state is “Use regular Haskell data structures as your database and get stronger ACID guarantees than most RDBMS offer.” I don’t think you’re going to have success convincing people of that (I agree with you but that doesn’t change that)
04:00:22 <koz_> Acid state = the State monad parametrized over LSD.
04:00:32 <merijn> So if you plan to store 1 TB of data in it, you're either 1) doing it wrong or 2) have a problem that warrants 1 TB ram
04:00:48 <maerwald> what is LSD? Lazy Stateful Database?
04:00:50 <ertes> haskell127: you can use lambdas without parentheses with an operator like ($):  f $ \case x -> 1
04:00:51 <merijn> cocreature: Sure, I think the common marketing of acid-state is wrong
04:01:01 <koz_> maerwald: I *so* need to make this now.
04:01:04 <ertes> haskell127: but note that your lambda-case is universal anyway:  f (const 1)
04:01:05 <lambdapansy> i found acid-state because i was looking for a database implemented in haskell :P
04:01:22 <ertes> haskell127: (if you even intended to use -XLambdaCase)
04:01:25 <koz_> That's like the most perfect punny name with the whole ACID thing databases are supposed to do.
04:01:26 <merijn> cocreature: I think acid-state is an absolutely fascinating piece of library, but I think people are wanting to use it for things where regular databases are much better
04:01:56 <merijn> I generally recommend people think of it as "persistent heap data with ACID guarantees"
04:01:58 <lambdapansy> https://imgur.com/zRMf7Bp photo of 1.5 TB RAM
04:02:09 <cocreature> merijn: I completely agree I was just making the point that arguing against marketing is hard
04:02:27 <haskell127> ertes: yes, but `foo . bar $ \case x -> 1` has different meaning `(foo . bar) \case x -> 1`
04:02:36 <merijn> So, for example, acid-state as persistent state for a daemon? Terrific idea! Storing 2 million text articles? Not so much
04:02:48 <ertes> haskell127: yeah, the latter looks like a syntax error to me
04:03:20 <lambdapansy> so there is no haskell-y database?
04:03:27 <ertes> (f . g $ \_ -> 1) = (f . g) (\_ -> 1)
04:03:34 <merijn> What does "haskell-y" database mean?
04:03:45 <lambdapansy> i can type something like :: doMy => homework
04:03:58 <mniip> is there a C-ey database
04:04:00 <lambdapansy> and then i don't have to redundantly specify types
04:04:08 <lambdapansy> if i try to modify something in the database
04:04:11 <lambdapansy> my haskell code gets called
04:04:18 <lambdapansy> and says "dont do that, dummy"
04:04:37 <ertes> lambdapansy: that has nothing to do with the database, but with the binding to the database
04:04:46 <lambdapansy> if the change to the db in a stupid way
04:04:56 <haskell127> ertes: is there any way to somehow use compose and lambda case without parens?
04:05:10 <ertes> haskell127: f . g $ \case …
04:05:45 <liste> haskell127: also, let and where
04:05:54 <lambdapansy> ertes: binding?
04:06:19 <ertes> > let f = filter even . map $ \case 0 -> 0; n -> n + 1 in f [0,1,2,3]
04:06:21 <lambdabot>  <hint>:1:29: parse error: naked lambda expression ''
04:06:35 <ertes> > let f = filter even . map $ \case { 0 -> 0; n -> n + 1 } in f [0,1,2,3]
04:06:37 <lambdabot>  <hint>:1:29: parse error: naked lambda expression ''
04:06:57 <ertes> lambdabot has no -XLambdaCase apparently, but that's how you do it
04:07:07 <haskell127> ertes: I want case as argument of g `f . (g $ \case ...)`
04:07:29 <haskell127> ertes: not as argument of (f . g)
04:08:12 <ertes> in that case use parentheses
04:08:37 <lambdapansy> google isn't filling me on this bindings business
04:08:51 <ertes> or a local definition:  let h … = … in f . g h
04:09:25 <ertes> lambdapansy: a binding to X is a library that provides an interface to X
04:10:02 <lambdapansy> ah,... yeah so if i use postgresql bindings of some kind you mean
04:10:20 <lambdapansy> but postgres doesn't necessarily know what haskell is or that my code exists at all
04:10:29 <lambdapansy> ... are there reverse bindings for databases?
04:10:49 <maerwald> what are reverse bindings?
04:11:03 <ertes> haskell-side type safety is a matter of bindings and abstractions…  at some level you will always have something that doesn't understand your code…  at some level you have "bytes"
04:11:17 <lambdapansy> so i have like HeadDiameterInches
04:11:22 <lambdapansy> as my type
04:11:36 <lambdapansy> and if somebody reports their head diameter in inches is greater than 2 feet
04:11:49 <lambdapansy> i want it to say "wtf"
04:12:15 <lambdapansy> or, a better example is
04:12:31 <lambdapansy> i've found foreign keys in sql to be shitty
04:12:38 <lambdapansy> i want to implement my own foreign key restrictions
04:13:01 <ertes> ("'inches'?  'feet'?!  wtf!")
04:17:59 <Hafydd> My foot diameter is exactly 1 foot.
04:22:31 <koz_> OK, I need some advice. I have a list of monotonically non-decreasing numbers, and I wanna find the longest homogenous tail. Would it be smarter to do something like 'length . last . group', or combo of takeWhile, head and reverse?
04:22:52 <koz_> The length of the longest homogenous tail, I mean.
04:37:42 * hackagebot type-natural 0.4.2.0 - Type-level natural and proofs of their properties.  https://hackage.haskell.org/package/type-natural-0.4.2.0 (HiromiIshii)
04:39:53 <mrCyborg> I am new to haskell and was wondering why the function `takeWhile` is in Prelude *and* in Data.List, does anyone know?
04:40:32 <liste> mrCyborg: it's probably defined in Data.List and re-exported in Prelude
04:41:23 <Hafydd> koz_: length . head . group . reverse is probably more efficient.
04:41:29 <bergmark> mrCyborg: Prelude only contains re-exports
04:42:45 <Hafydd> I suppose that using takeWhile would work equally well, but it seems less tidy.
04:43:45 <mrCyborg> liste and bergmark: tnx
04:44:52 <koz_> Hafydd: I shall try your approach and see.
04:45:04 <Hafydd> Or even better, to make it a total function: length . head . (++ []) . reverse.
04:45:20 <Hafydd> ...a total function on finite lists, that is.
04:46:13 <Hafydd> Er... length . head . (++ []) . group . reverse
04:46:38 <Hafydd> Or you might prefer to pattern-match.
04:46:46 <hpc> (++ []) = id
04:46:56 <Hafydd> Damn it. I mean (++ [[]]).
04:47:08 <hpc> ;)
04:56:03 <ertes> koz_: it would be smartest not to have a list in the first place
04:56:18 <ertes> koz_: but if you can't avoid that, go for the last-based version instead of the reverse-based one
04:56:33 <ertes> Hafydd: wrong
04:56:51 <ertes> 'reverse' is an absolute efficiency killer
04:58:27 <mniip> does reverse fuse?
04:58:59 <ertes> nope
04:59:34 <ertes> in base 4.9.0.0 it doesn't
05:03:07 <Hafydd> ertes: why?
05:08:13 <ertes> Hafydd: the last-based version is O(1) space
05:09:34 <koz_> ertes: Would you suggest doing this with vectors instead then?
05:09:52 <ertes> koz_: it depends on how the initial list is constructed
05:10:15 <koz_> ertes: It's a monadic function which makes each element from the previous one (and some starting state obviously).
05:10:26 <koz_> (in the Random monad)
05:11:06 <ertes> koz_: if you use a lazy state monad you can make this a lazy list, and then the last-based version is fine
05:11:17 <ertes> koz_: (make sure your list is never empty)
05:11:23 <koz_> ertes: Lazy state monad?
05:11:35 <ertes> koz_: Control.Monad.State or Control.Monad.Trans.State
05:12:22 * ertes is not familiar with Random
05:12:43 * hackagebot json-rpc-generic 0.2.0.2 - Generic encoder and decode for JSON-RPC  https://hackage.haskell.org/package/json-rpc-generic-0.2.0.2 (KeiHibino)
05:12:45 * hackagebot stylish-haskell 0.6.2.0 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.6.2.0 (JasperVanDerJeugt)
05:14:33 <koz_> ertes: I shall investigate - thank you!
05:17:44 * hackagebot handa-data 0.2.9.9 - This package is deprecated. It formerly contained Haskell utilities for data structures and data manipulation.  https://hackage.haskell.org/package/handa-data-0.2.9.9 (BrianBush)
05:22:12 <Hafydd> ertes: I suppose so, if there isn't a reference to the beginning of the list anywhere else.
05:23:24 <ertes> actually O(n) space, where n is the length of the last chunk
05:24:51 <ertes> hmm…  no, might be O(1) after all…  not entirely sure
05:25:21 <ertes> yeah, it's O(1)
05:27:47 <adarqui> serious question. how do you guys talk on here so much? it's impressive. I struggle with coding so much that, I can barely pay attention to this chat.. heh.
05:31:43 <maerwald> adarqui: unemployed? xD
05:35:25 <koz_> adarqui: Most of the time, it's while we wait for something else. In my case, a profiling run.
05:42:44 * hackagebot raft 0.3.2.2 - Miscellaneous Haskell utilities for data structures and data manipulation.  https://hackage.haskell.org/package/raft-0.3.2.2 (BrianBush)
05:42:46 * hackagebot haskell-tools-ast 0.1.3.0 - Haskell AST for efficient tooling  https://hackage.haskell.org/package/haskell-tools-ast-0.1.3.0 (lazac)
05:42:48 * hackagebot haskell-tools-ast-trf 0.1.3.0 - Conversions on Haskell-Tools AST to prepare for refactorings  https://hackage.haskell.org/package/haskell-tools-ast-trf-0.1.3.0 (lazac)
05:42:50 * hackagebot haskell-tools-prettyprint 0.1.3.0 - Pretty printing of Haskell-Tools AST  https://hackage.haskell.org/package/haskell-tools-prettyprint-0.1.3.0 (lazac)
05:42:52 * hackagebot haskell-tools-ast-fromghc 0.1.3.0 - Creating the Haskell-Tools AST from GHC's representations  https://hackage.haskell.org/package/haskell-tools-ast-fromghc-0.1.3.0 (lazac)
05:43:55 <adarqui> koz_: hah cool .. maerwald ya but even then, working on projects etc just take so much time (in my experience)
05:44:38 <adarqui> koz_: ya, builds / profiling sounds like good chat time
05:46:56 <koz_> OK, this is weird. Does Vector.replicateM actually feed the state through each time? I'm getting *very* different results with it from me feeding the state through manually with my own doNTimes function.
05:47:00 <merijn> Looks like Barclays is moving into Haskell too
05:47:54 * hackagebot haskell-tools-ast-gen 0.1.3.0 - Facilities for generating new parts of the Haskell-Tools AST  https://hackage.haskell.org/package/haskell-tools-ast-gen-0.1.3.0 (lazac)
05:47:56 * hackagebot haskell-tools-refactor 0.1.3.0 - Refactoring Tool for Haskell  https://hackage.haskell.org/package/haskell-tools-refactor-0.1.3.0 (lazac)
05:47:58 * hackagebot impure-containers 0.3.1 - Mutable containers in haskell  https://hackage.haskell.org/package/impure-containers-0.3.1 (andrewthad)
05:51:11 <dysfun> is there a lens that works on the head of the list?
05:53:07 <cocreature> dysfun: it can’t be a lens because there might not be a head
05:53:23 <merijn> Presumably there's a prism, though?
05:53:39 <dysfun> what if i really really promise it's not empty?
05:54:47 <dysfun> *sigh* i suppose I'd better go read about prisms
05:55:02 <Jinxit> there's a lens for that
05:55:10 <Jinxit> something with !, i think?
05:55:13 <Jinxit> it's been too long
05:55:41 <gleber> dysfun: https://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-At.html#v:ix - second one of these returns Maybe a
05:55:54 <cocreature> there is _head
05:56:04 <cocreature> which for some reason is a traversal and not a fold
05:56:21 <dysfun> perfect, i'll see how to fit these in. thanks :)
05:57:00 <cocreature> for being really sure that there is a head there are also things like ^?!
05:57:58 <cocreature> oh I think I confused folds with prisms
05:58:07 <cocreature> ah yeah you can’t make _head a prism
05:59:33 <Jinxit> ^?!, that's the one I was thinking of
05:59:37 <Jinxit> for when you really know
06:01:00 <cocreature> ^?! doesn’t turn it into a lens though, it only gives you an unsafe view function
06:02:04 <cocreature> and you can’t make it a prism because you can’t review properly
06:02:22 <cocreature> are traversals with 0 or 1 element something special?
06:05:04 <bennofs> cocreature: if you can also turn it "around" and have a function a -> s, then what you've got is a Prism
06:05:36 <bennofs> cocreature: otherwise, I think such a traversal is called affine
06:05:37 <cocreature> bennofs: yeah I know that, but I was wondering if there was something more general for things like _head
06:05:43 <cocreature> ah ok thanks
06:06:10 <cocreature> yep the docs confirm that terminology
06:07:45 * hackagebot geolite-csv 0.2 - Geolite CSV Parser  https://hackage.haskell.org/package/geolite-csv-0.2 (andrewthad)
06:19:13 <Ulrar> I'm lost in the different String types again. I've got a Data.ByteString.Lazy (returned by Data.Aeson's encode function) and I need it as a Data.Text, how can I convert ? I tried to unpack then pack but since I'm using overloaded string it complains about word
06:19:15 <Ulrar> word8*
06:19:25 <merijn> Data.Text.Encoding
06:19:47 <merijn> Ulrar: Ignore the String part of ByteString, it is a historical accident
06:19:47 <gargawel> Ulrar: use the string-conversions package and forge about it...
06:19:54 <gargawel> *forget
06:20:00 <merijn> Ulrar: ByteString is just Bytes
06:20:06 <cocreature> if it is from aeson decodeUtf8 should be what you’re looking for
06:20:12 <alercah> those conversions don't work precisely to prevent you from forgetting to specify an encoding
06:20:30 <merijn> gargawel: Now you're making me sad
06:21:17 <merijn> gargawel: That entire package is a recipe for "my app corrupted my database/files/state/website and I don't know why" bugs 1 year down the road
06:21:27 <cocreature> converting between String and Text is annoying, automatically converting between Text and ByteString is stupid
06:23:42 <Ulrar> so decodeUtf8 $ encode ?
06:23:49 <Ulrar> That seems a bit weird
06:24:01 <gargawel> Well, converting from Text to ByteString makes perfect sense, doesn't it ? I guess it's the other way around that's problematic
06:24:35 <merijn> gargawel: Oh? What's the way to convert ☃ to a ByteString?
06:25:23 <merijn> Text is unicode text, you'd have to specify how to convert unicode to binary data, i.e. what encoding to use
06:25:32 <merijn> The exact same issue with going from ByteString to Text
06:25:32 <gargawel> merijn: Correct.
06:27:36 <gargawel> merijn: I am admittedly pretty ignorant about encoding issues, sorry for saying stupid things :)
06:28:53 <merijn> gargawel: The thing is, you can't just pick one encoding that converts to ByteString, because if the machine/server/whatever on the other side expects a different one, it'll barf. So you have to know what encoding the other side uses and specify that one. If you hard code to always use the same one, you get into trouble
06:29:35 <Ulrar> Looks like it's using the wrong ByteString between the Lazy and normal ones now
06:29:44 <Ulrar> Aren't encode and decodeUtf8 supposed to use the same ?
06:30:09 <cocreature> Data.Text.Lazy.Encoding is your friend
06:32:07 <Ulrar> But that gives me a Data.Text.Internal.Lazy.Text .. I can understand the appeal of automatic conversion :)
06:32:44 <gargawel> Ulrar: that's actually the exact reason I failed for it ;)
06:33:10 <cocreature> the appeal dies as soon as you start debugging issues (performance, memory usage or encoding issues) caused by automatic conversion
06:33:43 <mauke> so you have lazy bytes and you want strict text?
06:35:04 <alercah> Ulrar: can you paste an example? it shouldn't give you an internal text
06:35:22 <merijn> alercah: Internal text is just the regular one :)
06:35:31 <cocreature> btw you can directly encode to Text instead of ByteString using aeson
06:35:32 <merijn> So it's a strict vs lazy issue
06:35:36 <mniip> it's a fully qualified identifier
06:35:47 <Ulrar> cocreature: Oh ?
06:36:09 <merijn> Ulrar: The real first question here is: 1) what do you want as input type and 2) what do you want as output
06:36:49 <Ulrar> I want Data.Text as an output, and my input is a data type containing text
06:37:53 <merijn> Ulrar: Strict Data.Text?
06:38:10 <merijn> oh, I suppose Data.Text is strict by definition :)
06:38:49 <cocreature> Ulrar: toLazyText . encodeToTextBuilder . toJSON
06:39:04 <cocreature> and prepend a toStrict if you need strict text
06:40:49 <cocreature> ah there is encodeToLazyText which does all the work for you
06:40:55 <cocreature> missed that when going through the docs
06:41:07 <cocreature> oh I think that’s not yet released
06:42:46 * hackagebot aeson-injector 1.0.3.0 - Injecting fields into aeson values  https://hackage.haskell.org/package/aeson-injector-1.0.3.0 (NCrashed)
06:44:22 <pavonia> Is there a special name for functions like bool, maybe, either etc. that apply different functions to each of their constructors?
06:45:00 <merijn> pavonia: In papers they are usually "X-eliminations"
06:45:05 <mauke> catamorphism, if they work recursively
06:45:23 <merijn> pavonia: Because you commonly work with "X-introduction" and "X-elimination" rules
06:45:41 <pavonia> What does the X stand for?
06:45:42 <merijn> pavonia: The constructors having the role of introduction
06:45:47 <merijn> pavonia: The relevant type :p
06:45:55 <pavonia> Oh okay
06:46:07 <Ulrar> cocreature: is still get a ByteString after toStrict though
06:46:08 <merijn> pavonia: So Bool-introduction and Bool-elimination, etc.
06:46:55 <pavonia> So True and False are Bool-introduction constructors?
06:47:46 * hackagebot ip 0.8.5 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-0.8.5 (andrewthad)
06:49:24 <cocreature> Ulrar: then you forgot the encodeToTextBuilder
06:50:41 <Ulrar> toStrict $ toLazyText $ encodeToTextBuilder $ toJSON (genNodeTo nodeName)
06:50:51 <Ulrar> Maybe I'm not using the correct toStrict
06:50:58 <merijn> pavonia: True and False are the Bool-introductions ("Bool-introduction constructor" is mixing terminology)
06:51:35 <pavonia> I see, thanks!
06:52:17 <merijn> pavonia: Alternatively I suppose you could call them "destructors", but that's probably confusing for both the theory people AND the OO people
06:52:38 <pavonia> :)
06:54:54 <Ulrar> That's going to end with an hardcoded string ..
06:56:07 <jle`> pavonia: bool, maybe, and either are also all functions that convert their erspective data types into their church encodings
06:56:42 <jle`> bool :: Bool -> ChurchEncodedBool, maybe :: Maybe a -> ChurchEncodedMaybe a, either :: Either e a -> ChurchEnocdedEither e a
06:56:47 <jle`> modolu some flipping of arguments
06:57:05 <srhb> jle`: I never thought of it like that.
06:57:07 <srhb> Nice.
06:57:35 <jle`> i think in this context you can also say that they convert them to their scott encodings
06:58:04 <srhb> Church-Scott normalizers, clearly.
06:58:11 <Ulrar> Ha, looks like I got it. I end up with a String instead of Text, but that convertion is easy at least
06:58:38 <mauke> I don't think you should end up with String
06:59:17 <Ulrar> I use unpack from Data.Text.Lazy on the result of toLazyText
06:59:33 <merijn> Well, yeah, duh
06:59:56 <merijn> Church and Scott encodings are simply different ways to represent all elimination rules for a datatype :)
07:00:43 <srhb> merijn: I'll work on making my realization feel as trivial as you consider it. ;-)
07:01:23 <merijn> srhb: I was referring to jle` and making the pedantic argument that he has the causality of naming reversed :)
07:02:01 <merijn> srhb: As for having that realisation, it helps to cheat by reading the Scott paper on Scott-encodings where they explicitly show how to construct them from given elimination rules ;)
07:02:01 <jle`> :)
07:02:11 <srhb> merijn: Which paper is that? :)
07:02:18 <merijn> lemme check
07:02:37 <merijn> hmmm, apparently I didn't save it...
07:03:16 <merijn> I ran across it while trying to read McBride's "A View from the Left" and his thesis
07:03:59 <merijn> srhb: Since his thesis and Epigram focussed on compiler aided program construction he spent a bunch of time discussing how eliminations of datatypes can be auto-constructed from their introduction rules
07:04:09 <srhb> merijn: Is it the Mogensen paper I wonder?
07:04:11 <srhb> Oh
07:04:15 <merijn> oh, sounds familiar
07:04:20 <c_wraith> buglebudabey: hey.  I didn't get around to answering your question on friday.  You still remember it? :)
07:05:06 <buglebudabey> c_wraith how is Compose useful at all when I can just compose functors manually :P
07:06:08 <c_wraith> buglebudabey: so, I should explain what http://lpaste.net/171865 does a bit more.
07:06:31 <c_wraith> buglebudabey: are you familiar with the lens library?
07:06:33 <jle`> buglebudabey: why is Sum useful when you can just add numbers manually? :p
07:06:54 <buglebudabey> c_wraith no i'm not
07:07:08 <buglebudabey> jle` i don't know that either ;)
07:07:16 <exio4> why is map useful if you can just do foldr ((:) . f) []?
07:07:21 <jle`> it's so that you can use Sum in monoid-polymorphic functions
07:07:42 <jle`> you can take advantage of functions that are polymorphic over all Monoids
07:07:57 <jle`> like the API of the Writer type, Foldable methods, etc.
07:08:25 <jle`> if you use Sum with your numbers, you now have whole bunches of monoid-polymorphic functions that you can now use it with
07:08:28 <buglebudabey> jle` ah alright, i actually read that in typeclassofpedia yesterday
07:08:31 <jle`> write once, use many times!
07:08:36 <c_wraith> buglebudabey: ok.  99% of the details don't matter.  The important part is that lens works with functions that look like "Functor f => (a -> f b) -> s -> f t" or "Applicative f => (a -> f b) -> s -> f t"
07:09:07 <jle`> same for Compose.  if you have Compose, you can now use it with all sorts of Functor- and Applicative-polymrophic functions that arewritten to be generically useful
07:09:09 <c_wraith> so the function in that paste is for creating functions of that type, from a pattern specified by the first couple arguments.
07:09:27 <c_wraith> buglebudabey: the important part is the type signature for traverse.
07:09:33 <c_wraith> :t traverse
07:09:34 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
07:10:15 <buglebudabey> alright, i'm following so far
07:10:28 <c_wraith> buglebudabey: traverse (and functions that can be derived from it) is the only tool I have for working with the last argument of the function I wrote.
07:11:02 <c_wraith> buglebudabey: And I can't just use it directly, because I don't know what type f is going to be
07:11:20 <c_wraith> buglebudabey: the caller of shaped gets to choose the type for f, not me as the implementor
07:11:53 <c_wraith> buglebudabey: but I want to smuggle a state-tracking operation inside the traverse, in addition to whatever they're using.
07:12:28 <c_wraith> buglebudabey: that's where Compose comes in.  I can use it to combine my state-tracking with the unknown f Functor(Applicative) that the caller gets to choose.
07:12:47 * hackagebot llvm-ffi 3.3.0 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-3.3.0 (HenningThielemann)
07:12:56 <c_wraith> buglebudabey: then I use getCompose and evalState to remove any traces of the state tracking before returning the result
07:14:33 <buglebudabey> c_wraith is your state-tracking the state itself?
07:14:40 <buglebudabey> and eval state hides it?
07:14:53 <c_wraith> buglebudabey: the state tracking is done in conditionalApply
07:15:07 <buglebudabey> modify' tail?
07:15:16 <c_wraith> buglebudabey: gets and modify' are both State operations
07:15:56 <buglebudabey> that i know but i was just wondering if your modify' was the part that specifically altered the state for you to keep track of
07:16:41 <c_wraith> yeah, modify' is the part changing it.
07:16:53 <buglebudabey> alright
07:17:17 <buglebudabey> i do have questions but i have to leave, i'm going to look over what you said again when i come back and ask later if that's okay
07:17:22 <buglebudabey> c_wraith ^
07:17:39 <c_wraith> buglebudabey: http://lpaste.net/171865#a173354 that might help a bit
07:17:47 * hackagebot llvm-tf 3.0.3.1.5 - Bindings to the LLVM compiler toolkit using type families.  https://hackage.haskell.org/package/llvm-tf-3.0.3.1.5 (HenningThielemann)
07:17:50 <c_wraith> buglebudabey: that version includes types for all the definitions in the where
07:18:11 <buglebudabey> c_wraith thanks
07:18:23 <buglebudabey> that does help
07:18:24 <buglebudabey> ttfn
07:44:25 <zlens> I have some libraries which I want to (1) make available to my other projects and (2) not publicly post to hackage. How can I setup it up so that my personal projects can pull these libraries?
07:46:05 <mniip> you can cabal install them
07:46:06 <oherrala> zlens: stack supports fetching packages for example via git
07:46:07 <mniip> locally
07:46:28 <zlens> do I need to setup a personal 'registry' of some sort for my packages?
07:47:09 <mniip> no
07:47:25 <mniip> you can use a sandbox if you wish
07:47:30 <oherrala> zlens: I have used this: https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#complex-package-locations-location
07:47:31 <mniip> the command's just cabal install path/to/package.cabal
07:48:13 <purelazy> ! 1+1
07:49:07 <purelazy> whats the repl-bot prefix?
07:49:20 <c_wraith> for evaluation, >
07:49:23 <c_wraith> > 1 + 1
07:49:25 <lambdabot>  2
07:49:28 <c_wraith> the space after is important
07:49:40 <purelazy> c_wraith: Thanks
07:49:47 <purelazy> > "Nice one!"
07:49:48 <lambdabot>  "Nice one!"
07:50:43 <zlens> oherrala: mniip : noted; thanks
08:10:27 <ryantrinkle> is there a name for (fmap head . group)?
08:10:37 <jle`> nub ?
08:10:47 <jle`> if you sort first, heh
08:11:07 <ryantrinkle> jle`: yeah, i'm thinking specifically as opposed to nub
08:11:20 <ryantrinkle> i.e. a function that only deletes *adjacent* duplicate values
08:11:48 <dfeuer> Is there any common name for the "user-friendly"  a -> a -> Bool wrapper around reallyUnsafePtrEquality# ?
08:11:58 <dfeuer> I was thinking maybe =*
08:12:04 <dfeuer> er..  =*=, or something?
08:12:28 <ryantrinkle> dfeuer: i could use the same thing!
08:12:40 <dfeuer> ryantrinkle, what do you like to call it?
08:12:46 <ryantrinkle> i just defined one last night (but didn't export it): unsafePtrEq
08:12:55 <ryantrinkle> that's about as friendly as i like it :P
08:13:17 <ryantrinkle> it's still a bit long-winded, but a whole lot better than a case statement
08:13:17 <dfeuer> ryantrinkle, I'm not exporting it either; I want it for set union/intersection/difference
08:13:25 <ryantrinkle> ah, interesting
08:14:32 <dfeuer> edwardk mentioned that Johan Tibell uses something like that for unordered-containers.
08:16:43 <dfeuer> It looks like he calls his ptrEq
08:17:09 <chelfi> ryantrinkle: unstutter ? I don't believe it is widely used but I sometimes find the opposite operation called stutter
08:17:55 <ryantrinkle> chelfi: ah, interesting
08:18:32 * mjrosenb has wanted an Eq a => ptrEq :: a -> a -> Bool ; prtEq x y = reallyUnsafePtrEquality x y || x == y; kind of replacement for the equals class.
08:18:57 <mjrosenb> since that should actually be safe, unless you did something silly like writing an eq that is not reflexive.
08:19:30 <ryantrinkle> mjrosenb: Eq Float and Eq Double are not reflexive :(
08:24:04 <mjrosenb> I don't know enough about the extensions to haskell's types, but I suspect if you made that into a typeclass, you could special-case it for instances of Real.
08:24:26 <mjrosenb> also, if your code breaks because NaN == NaN, I suspect you have made other mistakes :-p
08:24:30 <ryantrinkle> lol yeah
08:24:37 <dfeuer> ryantrinkle, Johan uses   ptrEq x y = isTrue# (reallyUnsafePtrEquality# x y ==# 1#).  Is there a reason not to use the simpler-looking  ptrEq x y = tagToEnum# (reallyUnsafePtrEquality# x y) ?
08:25:00 <ryantrinkle> dfeuer: hmm, i'm not sure
08:25:24 <ryantrinkle> in my code, i case directly on the result of reallyUnsafePtrEquality# and pattern match against 0#
08:27:02 <dfeuer> ryantrinkle, that seems like the most sensible.
08:27:06 <dfeuer> Or most reliable.
08:28:17 <dfeuer> But case on 0# or 1#?
08:29:34 <ryantrinkle> dfeuer: well, i case on 0#, basically just due to my C training that nonzero means true :P
08:29:41 <ryantrinkle> i'm not 100% sure that's right here
08:29:44 <ryantrinkle> > insert (0/0 :: Double) "b" $ insert (0/0 :: Double) "a" empty
08:29:45 <lambdabot>      Couldn't match expected type ‘r0 -> t’ with actual type ‘[Double]’
08:29:45 <lambdabot>      The first argument of ($) takes one argument,
08:29:45 <lambdabot>      but its type ‘[Double]’ has none
08:30:01 <ryantrinkle> > Data.Map.insert (0/0 :: Double) "b" $ Data.Map.insert (0/0 :: Double) "a" mempty
08:30:02 <lambdabot>  fromList [(NaN,"a"),(NaN,"b")]
08:30:08 <ryantrinkle> mjrosenb: ^ that's fun
08:30:15 <mnoonan> I think I'm doing something silly, but I don't quite see what: I have "type AExpr a = Fix (ExprF a)" and I want to write a functor instance, but "instance Functor AExpr where..." says "Type synonym 'AExpr' should have 1 argument, but has been given none"?
08:30:24 <dfeuer> ryantrinkle, well, I'm pretty sure it's right, but for some reason GHC stuff seems to tend to look for 1#. Which strikes me as odd and probably slightly less efficient, but what do I know.
08:30:27 <mnoonan> (with -XTypeSynonymInstances)
08:32:23 <ertes> mnoonan: you can only write an instance for a * -> * type synonym, if you can eta-reduce it
08:32:38 <ertes> mnoonan: type AExpr = …  -- without the type argument
08:32:48 <mnoonan> oh, I see.
08:32:49 * hackagebot luminance 0.11.0.3 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.11.0.3 (DimitriSabadie)
08:33:05 <ryantrinkle> dfeuer: ah, interesting
08:33:10 <mnoonan> And I don't suppose there is a type-level equivalent of (.:)?
08:33:16 <ryantrinkle> wel, ideally, this would be in the standard library somewhere
08:33:17 <monochrom> mnoonan: Because you wrote "type AExpr a = ..." as opposed to "type AExpr = ...", everywhere you use it you have to say "AExpr <something>", you cannot have AExpr alone. (This is why you see other people write "type X a = Either a" instead of "type X a b = Either a b".
08:33:23 <mnoonan> AExpr = Fix :. ExprF
08:34:01 <ertes> mnoonan: there is Compose, but you're probably better off just using a newtype
08:34:24 <mnoonan> ertes: I was hoping to pick up the recursion-schemes machinery for free from Fix :|
08:34:29 <jle`> mnoonan: what is (.:) ?
08:34:38 <ertes> mnoonan: if you don't use a newtype, you will write instances for Compose, and that's wrong in many ways
08:34:42 <mnoonan> (.:) = (.).(.) -- sometimes
08:34:44 <Xe> jle`: aeson
08:35:15 <ertes> mnoonan: oh, you don't even get Compose, so nevermind =)
08:35:20 <ertes> mnoonan: in any case, use a newtype
08:35:28 <ertes> you can derive most things
08:35:36 <dfeuer> ryantrinkle, I completely agree. It really belongs in GHC.Exts or something. Expecting people to deal with the Int# representation of booleans to get pointer equality seems unreasonable. OTOH, people who don't understand unboxed integers probably haven't learned enough GHC details to be messing with pointer equality :-/.
08:35:53 <mnoonan> ertes: it's just a bummer that I'll have to re-implement cata and friends, though
08:36:03 <ryantrinkle> dfeuer: well, it'd be nice to have a canonical Int# -> Bool, at least
08:36:06 <mnoonan> but I can live with it.
08:36:44 <dfeuer> ryantrinkle, that too. I'd actually like a canonical Boolish pointer equality in GHC.Exts, and to heck with trying to keep the riffraff out. :D
08:36:49 <ertes> mnoonan: not sure you have to, but if that's what it takes…  again: writing instances for existing type combinations is wrong in many ways
08:37:10 <ertes> mnoonan: it's like writing a Monoid instance for Integer
08:37:41 <mnoonan> ertes: thanks, I suppose that makes sense. I never really thought about it that way.
08:38:09 <ertes> mnoonan: there is a reason why you need an extension for type synonym instances =)
08:39:59 <mjrosenb> > Data.Map.fromList . zipWith (0/0 :: Double,) $ "Hello, World"
08:40:01 <lambdabot>      Couldn't match type ‘[b0] -> [c0]’ with ‘[(k, a)]’
08:40:01 <lambdabot>      Expected type: [Char] -> [(k, a)]
08:40:01 <lambdabot>        Actual type: [Char] -> [b0] -> [c0]
08:40:19 <mjrosenb> > Data.Map.fromList . map (0/0 :: Double,) $ "Hello, World"
08:40:21 <lambdabot>  fromList [(NaN,'H'),(NaN,'e'),(NaN,'l'),(NaN,'l'),(NaN,'o'),(NaN,','),(NaN,'...
08:40:56 <mjrosenb> ryantrinkle: and no lookup on that map will ever return anything :-(
08:41:16 <ryantrinkle> mjrosenb: yep; it's pretty bad
08:42:16 <ryantrinkle> IMO, it would be better if there were a separate typeclass, IEEE754Eq, which just provided these crazy functions
08:42:49 * hackagebot llvm-ffi 3.4.0 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-3.4.0 (HenningThielemann)
08:42:51 * hackagebot llvm-tf 3.0.3.1.6 - Bindings to the LLVM compiler toolkit using type families.  https://hackage.haskell.org/package/llvm-tf-3.0.3.1.6 (HenningThielemann)
08:46:55 <Athas> Is anyone using those LLVM bindings for something cool?
08:47:38 <dfeuer> ryantrinkle, are you saying what I've been saying? That floating point has no business in Eq, Ord, or Num?
08:48:00 <ryantrinkle> dfeuer: well, it could be in those things, but NaN == NaN should be True, in that case
08:48:16 <ryantrinkle> Num i'm not sure about
08:48:33 <ryantrinkle> i don't really know the laws of Num well enough to say whether there's a sensible instance possible
08:48:50 <dfeuer> There are no laws. But I usually expect "numbers" to be in a ring.
08:48:55 <ryantrinkle> right
08:49:09 <ryantrinkle> do floats have a sensible(ish) ring?
08:49:31 <dfeuer> Not that I know of. Rounding errors + limited range.
08:49:43 <ryantrinkle> hmm
08:49:58 <ryantrinkle> well, that's above my pay grade
08:50:06 <dfeuer> Int and Word are perfectly good rings.
08:50:14 <ryantrinkle> but it's tough for me to see why we'd want unlawful Eq or Ord instances
08:50:31 <dfeuer> Oh, that's a good point.
08:50:39 <dfeuer> The Eq and Ord instances are definitely worse.
08:50:48 <ryantrinkle> although it's a totally understandable in historical context
08:50:55 <dfeuer> You shouldn't be comparing floating point unless you know *exactly* what sort of comparison you want.
08:51:01 <ryantrinkle> like, i could definitely see myself having gone this same way
08:51:16 <ryantrinkle> it's only after getting bitten a couple of times that i started to feel this way :P
08:59:03 <mjrosenb> I can think of an instance where Eq Double makes sense.
08:59:21 <dfeuer> mjrosenb, oh?
08:59:31 <mjrosenb> buuut just one isn't a good excuse
09:00:20 <mjrosenb> yeah, DHTs + Linear hashing
09:00:29 <mjrosenb> at least I think linear hashing is the term that I want.
09:01:25 <mjrosenb> basically, you hash to a real number in the range (0,1), then distribute your values to tables based on ranges (n*(1/N), (n+1)*(1/N))
09:01:52 <mjrosenb> so that if you need to change the number of machines (N), you need to relocate relatively few elements
09:02:27 <mjrosenb> and since your key is a Double, you want to have Eq on Doulbe.
09:03:07 <dfeuer> mjrosenb, don't know enough about hashing. But do you really need Eq?
09:05:22 <ertes> dfeuer: since Ord depends on Eq, and i find myself sorting Double…
09:06:52 <dfeuer> ertes, sorting only works if there aren't any NaNs. I'll admit it sounds convenient though.
09:07:14 <ertes> dfeuer: the whole interface to Double is convenience…  it's wrong on many levels
09:07:31 <ertes> practically speaking just don't make the mistake to consider Double to be an exact representation of your numbers
09:07:38 <ertes> and check for NaNs =)
09:08:07 <ertes> also i'm not sure what happens when you compare two non-canonical numbers
09:08:18 <ertes> > isDenormalized (encodeFloat 2 2)
09:08:20 <lambdabot>  False
09:08:25 <ertes> i can't seem to produce one
09:14:46 <dolio> > head . dropWhile (not . isDenormalized) . iterate (/2) $ 1
09:14:47 <lambdabot>  1.1125369292536007e-308
09:18:03 <ertes> oh, of course
09:20:27 <zlens> I start projects with "stack new $projName haskeleton"
09:20:41 <zlens> is there a way to have it to "stack new $projName myHaSkeleton" so I can modify the tempaltes?
09:22:50 * hackagebot active 0.2.0.11 - Abstractions for animation  https://hackage.haskell.org/package/active-0.2.0.11 (BrentYorgey)
09:43:06 <SpiritGun> hii 
09:43:22 <SpiritGun> First time on here
09:43:31 <glguy> Welcome to #haskell.
09:43:41 <SpiritGun> Thanks glguy
09:43:54 <SpiritGun> I am a CS sophomore 
09:45:49 <SpiritGun> Anyone into Node.js?
09:46:44 <c_wraith> probably not here. 
09:47:00 <c_wraith> Node.js is more or less the opposite of haskell. 
09:47:44 <SpiritGun> Seems so...Thanks <c_wraith> 
09:47:47 <dmj`> SpiritGun: ghc does asynchronous non-blocking I/O.. just w/o the callback hell
09:48:33 --- mode: ChanServ set +o glguy
09:48:33 --- mode: glguy set -b $a:AzureStigma
09:48:44 --- mode: glguy set -q *!*@pool-108-35-109-85.nwrknj.fios.verizon.net
09:49:02 <c_wraith> there was that statement from the creator of node saying he'd considered haskell, but didn't want to spend the time figuring it out. 
09:50:21 <SpiritGun> <dmj`> Hmm, I must give haskell some attention (I just started using node.js to build a realtime chat for a project) 
09:50:32 <AzureStigma> is the main function in haskell an hybrid function that it has properties like languages such as java?
09:51:08 <hpc> hybrid of function and what?
09:51:09 <c_wraith> AzureStigma, no. it's something entirely new. 
09:51:33 <c_wraith> AzureStigma, it's a value that represents what the program will do when it runs. 
09:51:49 <SpiritGun> Oh
09:51:51 <zlens> I'm still confused on how to setup a local cabal repo
09:52:01 <c_wraith> AzureStigma, I don't know of other languages with that kind of value. 
09:52:02 <zlens> can I just point to a directory and say -- look for pacakges in ~/my-cabal
09:52:10 <zlens> i.e. if you need pkg foo, look for it in ~/my-cabal/foo/
09:52:21 <AzureStigma> it says it has side-effects as opposed to being a pure function or expression
09:52:37 <AzureStigma> so i was thinking of non functional elements
09:53:11 <johnw> main doesn't have side-effects
09:53:21 <johnw> it defines an action which, when evaluated by the Haskell runtime, results in side effects
09:53:45 <AzureStigma> I see thanks for the clarification sir!
09:54:01 <c_wraith> johnw, executed, not evaluated. :P
09:54:15 <johnw> right, execution
09:54:20 <c_wraith> we try to keep those bits of terminology straight. :) 
09:54:40 <johnw> I'm working in other contexts lately where we don't distinguish those terms, I forgot my #haskellese
09:54:53 <mjrosenb> c_wraith: execution frequently involves evaluation </devilsadvocate>
09:55:19 <c_wraith> certainly! but evaluation frequently does not involve execution. :) 
09:55:37 <c_wraith> (darn you, unsafeInterleaveIO
09:55:39 <johnw> c_wraith: how do you define the distunction?
09:55:58 <c_wraith> johnw, evaluation is graph reduction. 
09:56:02 <monochrom> yeah, readFile and stuff :)
09:56:25 <johnw> so execution is the ability to invoke system calls during AST traversal?
09:56:36 <c_wraith> johnw, execution is whatever the runtime does with IO
09:57:15 <monochrom> I would define the distinction by enumeration.
09:58:00 <johnw> c_wraith: "whatever the runtime does" isn't enough to help me :(
09:58:00 <SpiritGun> To be honest, I never programmed in Haskell...Googling some 'getting started with haskell tips' 
09:58:11 <monochrom> (And there are pretty few things to enumerate on the evaluation side.)
09:58:28 <c_wraith> johnw, then "everything except graph reduction" 
09:58:34 <johnw> haha, ok
09:58:47 <monochrom> For example, adding two Int's is evaluation. Pattern matching is evaluation. There are just a few more.
09:59:10 <monochrom> Yeah, after you nail evaluation, the rest is execution.
10:00:10 <c_wraith> SpiritGun, haskell is different from most languages, and that can make it tricky to learn. but it's also the most satisfying language I've learned. so go into it with patience and an open mind. :) 
10:01:06 <monochrom> I am more extreme. I say that open-mind is not enough, you have to go all the way to empty-mind.
10:01:57 <hpc> evaluation is the reduction of expressions into "more evaluated" equivalent expressions
10:02:15 <c_wraith> monochrom, does that make Mu your favorite type? 
10:02:16 <hpc> the execution model of haskell is that main is an IO action
10:02:29 <AzureStigma> <c_wraith> quick question when you said "t's a value that represents what the program will do when it runs" by that being a value you mean its an argument?  I thought main was a function 
10:02:33 <hpc> the value of that action is treated as instructions for the machine to perform
10:02:39 <erisco> SpiritGun, you've found the treasure map and your journey has begun!
10:02:44 <monochrom> Yes, I like fixed points.
10:02:46 <hpc> execution of that action periodically triggers evaluation
10:02:55 <c_wraith> AzureStigma, main isn't a function in Haskell. 
10:03:02 <hpc> for instance, main = print (some expression)
10:03:08 <c_wraith> AzureStigma, it's an IO value. 
10:03:17 <AzureStigma> so its an argument./
10:03:18 <glguy> AzureStigma: Functions in haskell have types (a -> b)
10:03:29 <erisco> if you like unofficial Haskell semantics you must like fixed points
10:03:34 --- mode: glguy set -o glguy
10:03:47 <monochrom> You can say "main is an action". Same for getLine, and generally things of type "IO <something>"
10:04:06 <AzureStigma> but anything that has values are arguments correct?
10:04:10 <hpc> it will execute that line, which triggers evaluation of print (which is a top-level definition) and ultimately also (some expression)
10:04:11 <monochrom> I liked fixed points before they were cool.
10:04:14 <hpc> and then print that result
10:04:17 <erisco> where the value of all applied functions are a fixed point
10:04:27 <monochrom> More seriously, I liked fixed points before I learned Haskell.
10:04:31 <erisco> (recursive ones)
10:04:45 <hpc> evaluating getLine yields a single unchanging representation of "read a line from standard input"
10:05:01 <hpc> executing it produces whatever your fingers want it to
10:06:23 <AzureStigma> in the book though it says the main function is the default function
10:06:32 <glguy> Which book?
10:06:35 <shapr> @quote
10:06:35 <lambdabot> DavidHilbert says: We must not believe those, who today, with philosophical bearing and deliberative tone, prophesy the fall of culture and accept the _ignorabimus_ ("We shall not know"). For us there is no _ignorabimus_, and in my opinion none whatever in natural science. In opposition to the foolish _ignorabimus_ our slogan shall be: _Wir
10:06:35 <lambdabot> müssen wissen — wir werden wissen!_ ("We must know — we will know!")
10:06:40 <AzureStigma> chris allens book
10:06:43 <shapr> yikes, wall of text
10:07:01 <hpc> main is not a function, and whatever notion in which it is "default" is ambiguous at best
10:07:02 <glguy> AzureStigma: That book misuses a number of terms, main isn't a function.
10:07:13 <erisco> though I suppose there is guarded recursion as well
10:07:14 <AzureStigma> page 152 in the ereader text it says the main function is the default function when you build an exectuable or run it in a REPL
10:07:23 <AzureStigma> I see thanks
10:07:50 <AzureStigma> so what you call it is an fixed point?
10:07:56 <hpc> ah
10:08:15 <monochrom> OK, I now declare that something bad has hit the fan and everyone is entering a pointfree debate on "what are functions? we will know --- we must know!"
10:08:22 <glguy> main is a value, more specifically it's an "action" because of its IO a type
10:08:31 <implementation> but since IO is defined newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #)),   IO () actually is function though, even if it doesn't look like one :)
10:08:35 <hpc> when you build an executable, absent any other options it will select the top-level definition main :: IO a to be the thing that is executed
10:08:47 <hpc> in a repl you can do whatever you want, it doesn't do anything unless you type it in
10:08:53 <hpc> you can write "main" and it'll do it
10:08:58 <erisco> so for unguarded recursion, you're unlikely to find any programmer who doesn't absolutely love fixed points
10:08:59 <hpc> or you can type "goober7" and it'll do that too
10:09:04 <Rotaerk> implementation, appropriate username for such a comment
10:09:32 <erisco> unless they're just trying to program a space heater
10:09:37 <hpc> implementation: it's still not
10:09:45 <hpc> State# a has no runtime representation
10:09:53 <hpc> and IO's runtime representation is specified to be a
10:10:13 <monochrom> Will implementation say: "let I# 2# + I# 2# = I# 5# in I# 2# + I# 2#"?
10:10:35 <AzureStigma> but I dont understand teh side effect part can someone please exemplify this 
10:11:20 <glguy> AzureStigma: "executing" the main action causes effects
10:11:23 <hpc> implementation: type role IO representational
10:11:25 <monochrom> erisco: I am skeptic about "absolutely"
10:11:29 <glguy> executing main is what happens when you run your Haskell program
10:11:31 <hpc> https://hackage.haskell.org/package/ghc-prim-0.5.0.0/docs/src/GHC.Types.html#IO
10:11:55 <AzureStigma> I see thanks!
10:12:14 <hpc> data State# s
10:12:16 <glguy> There's a distinction between executing an action, and evaluating one
10:12:17 <hpc> https://hackage.haskell.org/package/ghc-prim-0.5.0.0/docs/src/GHC.Prim.html#State%23
10:12:27 <hpc> "It is represented by nothing at all"
10:12:29 <AzureStigma> I know im asking trivial questions but im really trying to be a solid haskeller like you guys 
10:12:44 <erisco> monochrom, that was a throwaway word for emphasis, but what did you read into it?
10:12:45 <glguy> Executing an action "does" the action. Evaluating an action computes the primitive thing that can be executed
10:12:50 <hpc> implementation: so it turns out, GHC haskell is impure, and unsafePerformIO = unsafeCoerce
10:12:52 * hackagebot siphon 0.2 - Generic types and functions for columnar encoding and decoding  https://hackage.haskell.org/package/siphon-0.2 (andrewthad)
10:13:01 <glguy> so applying putStrLn to "hello world" might evaluate to some primitive action that prints to screen
10:13:07 <monochrom> "absolutely love" is what I read into it.
10:13:08 <glguy> but it won't print to screen unless you execute that
10:13:14 <c_wraith> AzureStigma, I disagree that these questions are trivial. I think they're really important, and food ones to be asking. 
10:13:20 <c_wraith> *good
10:13:34 <erisco> monochrom, this isn't a like a particle wave is it?
10:13:42 <glguy> AzureStigma: this is why we can write:  do let myaction = putStrLn "Hello"; myaction; myaction
10:13:42 <monochrom> no
10:13:45 <hpc> implementation: and leaning back a bit to the denotational side of things, i suspect the presence of unsafePerformIO implies that it must necessarily be an impure implementation to begin with
10:13:49 <glguy> and we see hello printed twice
10:13:56 <hpc> because it says any type 'a' admits IO
10:14:24 <Cale> implementation: That "function" is a bit of a hack. It's not really a proper function, it's just that GHC treats it like one for the purposes of hijacking its own dependency analysis to sequence the actions to be carried out.
10:14:52 <glguy> AzureStigma: defining myaction didn't actually print anything, evaluating myaction won't print either, but that whole expression together is an action that will print twice if executed
10:14:52 <hpc> and yeah, that's why it's written the way it is instead of just newtype IO a = IO# a or something
10:15:29 <hpc> implementation: you can glean a bit of this from the GHC trac commentary, and also from reading the comments in GHC.* modules
10:15:45 <hpc> it's really fascinating stuff for a compiler nerd
10:16:00 <orion> return . mix . (first toBytes) <$> enc -- Which operator has higher precedence?
10:16:05 <implementation> hpc: thanks for the explanation
10:16:08 <glguy> orion: Ask GHCi with :info
10:16:19 <glguy> orion: :info .    and    :info <$>
10:16:33 <orion> Thank you.
10:16:47 <erisco> monochrom, ah, you doubt the layman to possibly have the love you've cultured for fixed points
10:16:52 <hpc> @where commentary
10:16:52 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/Commentary
10:17:14 <monochrom> Yes. Even I don't absolutely love fixed points. I just like them.
10:17:41 <monochrom> And my like is already above average, among programmers.
10:18:03 <erisco> I am just riffing on programmers preferring their programs to do something rather than nothing
10:18:13 <glguy> and monochrom is maintaining that position by ensuring the erisco doesn't like them more
10:18:15 <SpiritGun> going offline guys
10:18:16 <SpiritGun> :P
10:18:27 <monochrom> haha
10:18:28 <glguy> which could lower his standing against the average
10:18:49 <AzureStigma> got it <glguy> just read everything you jsut said but had to isolate the statements since there were other things and i culdnt keep up with every other chat
10:20:32 <monochrom> Two things I like: fixed points and Galois connections.
10:20:45 <erisco> you and ekmett both
10:20:50 <erisco> whatever they are
10:21:09 <hpc> yes, wherever monochrom is
10:21:55 <erisco> AzureStigma, this is an enlightening article on IO https://wiki.haskell.org/IO_Semantics
10:22:34 <AzureStigma> thanks <erisco>
10:23:05 <erisco> Summarising, you do not need to think about IO executing anything. Rather, it constructs a tree of all possibilities
10:23:22 <AzureStigma> LOL WAS ABOUT TO ASK REGARDING THAT
10:23:25 <AzureStigma> THANKS
10:24:07 <erisco> the execution is then just choosing a path down the tree
10:24:15 <erisco> (from root to leaf)
10:24:33 <AzureStigma> so thats why you dont have to specify IO since it knows?
10:24:49 <erisco> I am not sure, I need more context to your question
10:25:11 <monochrom> yeah, what is "specify IO"? who is "it"?
10:25:17 <AzureStigma> When you enter functions directly into the rEPL GHCi implicily understands and implements IO without you having to specify that
10:26:02 <hpc> that's type inference
10:26:09 <erisco> the repl is a special environment that is designed to evaluate and print expressions which have a Show instance
10:26:10 <glguy> GHCi has special logic that if you provide an expression with an IO type that it should execute it
10:26:35 <glguy> and otherwise it will "show" that expression
10:27:01 <AzureStigma> so why do you need to type main:: IO ()
10:27:13 <erisco> there is no particular connection between the repl and the "IO Semantics" article I linked
10:27:14 <glguy> Your .hs files are not related to GHCi
10:27:15 <Cale> You don't need that.
10:27:16 <monochrom> I don't need to.
10:27:31 <glguy> Oh, and also the type signature is optional
10:27:49 <Cale> In fact, main can be of any IO action type, and you don't need to give it an explicit signature if you prefer not to.
10:27:49 <erisco> though perhaps the article is too advanced at this time
10:28:16 <Cale> Yeah, I don't know if that article is enough on its own. Sometimes I like to give that explanation to beginners, but it takes some time to build up to it :)
10:28:34 <Cale> (Or at least some interaction :)
10:29:15 <AzureStigma> i read everything you guys aid so much stuff now ill let my unconious mind do the thinking lol
10:32:45 <Cale> AzureStigma: If you think of IO actions as being values that represent executable programs, and remember that evaluation (turning expressions into values for the purposes of pattern matching) and execution (carrying out the steps described by IO action values) are separate, I think things should generally get clearer.
10:33:35 <Cale> AzureStigma: To paraphrase shachaf, the difference between getLine :: IO String and an actual String value is like the difference between /bin/ls and a list of files in your home directory.
10:34:01 <AzureStigma> i get that with the unix reference thanks!
10:34:40 <hawk78> Hi is it possible to write a function like fmap which can work for nested functors like [a] and http://en.wikipedia.org/wiki/Special:Search?go=Go&search=[a] e.g. f [1] = [2]      fhttp://en.wikipedia.org/wiki/Special:Search?go=Go&search=[1] = 2            i.e. f applies (+1) to all the as inside my type. I  think it is not possible because I could think of a type for s.
10:34:53 <hawk78> wooops
10:35:11 <hawk78> Hi is it possible to write a function like fmap which can work for nested functors like [a] and [[[ a ]]] e.g. f [1] = [2]      f[[[ 1 ]]] = 2            i.e. f applies (+1) to all the as inside my type. I  think it is not possible because I could think of a type for s.
10:35:12 <erisco> :t fmap.fmap -- hawk78 
10:35:13 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
10:36:27 <ertes> fmap.fmap -- lens is starting to have a negative impact on general coding style
10:36:28 <byorgey> hawk78: it is possible using generic programming techniques.
10:36:45 <erisco> ertes, what have I done? I don't know lens
10:37:23 <erisco> is it the lack of spaces that bothers you?
10:37:23 <ertes> erisco: it's conventional to leave out spaces around lens operators, and (.) happens to be one of them =)
10:37:40 <erisco> lens is not the only source of this convention
10:37:41 <glguy> Yeah, (.) belongs to lens now; back off!
10:38:04 <hawk78> erisco: I would like to write a "generic" function that does apply (+1) on vectors (lists) or matrices ([[]]) or tensors and so on 
10:39:13 <hawk78> byorgey: can you point me to the right technique?
10:39:44 <ertes> hawk78: if you follow the transformer pattern, you can use fmap itself
10:40:02 <erisco> hawk78, newtype Listlist a = Listlist [[a]]  instance Functor Listlist
10:40:24 <byorgey> hawk78: see http://hackage.haskell.org/package/syb-0.6/docs/Data-Generics-Schemes.html and http://hackage.haskell.org/package/syb-0.6/docs/Data-Generics-Aliases.html
10:40:40 <erisco> hawk78, more generally you may have   newtype C f g a = C (g (f a))    instance Functor (C [] [])
10:40:41 <byorgey> > everywhere (mkT ((+1) :: Int -> Int)) [[[3 :: Int]]]
10:40:42 <lambdabot>  Not in scope: ‘everywhere’Not in scope: ‘mkT’
10:40:57 <byorgey> > Data.Generics.Schemes.everywhere (Data.Generics.Aliases.mkT ((+1) :: Int -> Int)) [[[3 :: Int]]]
10:40:58 <lambdabot>  Not in scope: ‘Data.Generics.Schemes.everywhere’Not in scope: ‘Data.Generics...
10:41:13 <byorgey> hawk78: well, that's the idea in any case.
10:41:17 <byorgey> hawk78: why do you want to do this?
10:41:23 <erisco> even more so,  instance (Functor f, Functor g) => Functor (C f g)   I wonder
10:41:47 <int-e> mpickering: do you have any opinion on https://github.com/int-e/haskell-src-exts-simple/issues/1 ? (it's about ghc 7.8 compatibility, and there are several ways to get there)
10:42:39 <hawk78> I have nested structure, I want to apply a function "inside my structure"
10:43:12 <byorgey> hawk78: why not just make a Functor instance for your structure?  Why do you need a single version of fmap that works generically for multiple different types?
10:43:17 <agrue> erisco: Data.Functor.Compose
10:43:20 <AzureStigma> so cale its like defining the path directory vs the actual things in it
10:43:30 <erisco> yes, thank-you agrue
10:43:40 <agrue> @let import Data.Functor.Compose
10:43:41 <lambdabot>  Defined.
10:43:46 <erisco> so you can have an instance for composition of functors
10:43:53 <agrue> > fmap (+1) $ Compose [[1,2,3],[4,5,6]]
10:43:54 <lambdabot>  Compose [[2,3,4],[5,6,7]]
10:43:57 <Cale> AzureStigma: It's more like the program which reads the contents vs. the string describing those contents
10:43:58 <erisco> and because composition composes (heh) this generalises
10:43:59 <hawk78> I thought it was possible to do that using recursive typeclasses, but I failed
10:44:15 <hawk78> byorgey: ^^
10:44:16 <ertes> hawk78: note that GHC can likely derive the Functor instance
10:44:24 <AzureStigma> gotcha
10:44:24 <agrue> > fmap (+1) $ Compose . Compose $ [[[1,2,3],[4,5,6]]]
10:44:26 <lambdabot>  Compose (Compose [[[2,3,4],[5,6,7]]])
10:44:30 <agrue> etc.
10:44:39 <Cale> AzureStigma: getLine can't be a String, because which String would it be? Each time you run it, the user might type a different sequence of characters.
10:44:40 <ertes> hawk78: data MyType a = …  deriving (Functor)  -- you need the DeriveFunctor extension for that
10:44:42 <agrue> not sure this is better than fmap . fmap, but it works ;)
10:44:43 <erisco> you were schooled by a grue
10:44:52 <ertes> hawk78: in a similar way you can also derive Foldable and Traversable
10:45:02 <Cale> AzureStigma: Instead, it's a program describing what to do in order to get a String from the user.
10:45:15 <Cale> AzureStigma: i.e. it's an IO String
10:45:41 <hawk78> I'll reasong about your suggestions! Thank you all!
10:45:52 <erisco> well, it is better (necessary) if you want a type for the composed functor
10:46:11 <erisco> fmap . fmap  is the implementation (value) of this
10:47:03 <erisco> so if you're doing dict passing style then Compose is unnecessary
10:47:17 <AzureStigma> the strong would be the data?
10:47:52 <agrue> erisco: agreed
10:48:12 <maerwald> :t unsafePerformIO getLine
10:48:13 <lambdabot> Not in scope: ‘unsafePerformIO’
10:48:14 <erisco> I guess unless you're trying to fit into some * -> * kind
10:48:39 <erisco> such as, I don't know, monad transformers
10:49:48 <erisco> not to common to have type constructors take types of kind * -> *
10:51:35 <dfeuer> erisco, what's uncommon about that?
10:51:39 <maerwald> are private lambdabot conversations logged?
10:52:12 <erisco> dfeuer, what are the common types that do this?
10:53:44 <Cale> maerwald: At least back when I ran lambdabot, they weren't, but it's probably unsafe to assume that int-e can't read what you send to lambdabot ;)
10:53:45 <erisco> I guess that monad transformers are the most common example of this
10:54:27 <erisco> Fix and Compose are certainly not common
10:54:45 <dfeuer> erisco,   newtype Ap f a = Ap (f a)   (takes  (k -> *), newtype Flip f a b = Flip (f b a) (takes k1 -> k2 -> *),  data (:+:) f g a = InL (f a) | InR (g a),  data (:*:) f g a = f a :*: g a
10:55:04 <erisco> and how common are these?
10:55:07 <dfeuer> Functor sums and products are all over generics.
10:55:40 <zlens> I create my own template, pokemon.hsfiles . I put it in ~/.stack/templates/pokemon.hsfiles  . Now, I try "stack new pikachu pokemon" ... but stack can't find the pokemon template. How do I fix this?
10:55:45 <dfeuer> I've used variations on Ap and Flip for various things; I dunno how common they are.
10:56:25 <erisco> well, that was the only point, and I don't think it is of much important either
10:56:27 <dfeuer> Functor composition sucks for various reasons, but it's good to have around....
10:57:43 <AzureStigma> okay reread everything u ugys said sigh so much info but now i get it lol
10:58:09 <erisco> certainly one inhibitor is their encumbrance on the value level
10:58:32 <erisco> if it weren't for this I would guess we'd have much more compositional types in use
10:59:04 <erisco> preference to build types out of building blocks such as Compose, :+:, :*:
10:59:32 <EvanR> F `o` G
10:59:41 <dfeuer> erisco, yeah, the biggest problem is that they're only notionally associative.
11:00:17 <dfeuer> You can convert between Compose f (Compose g h) and Compose (Compose f g) h, but it's annoying.
11:00:21 <zlens> I create my own template, pokemon.hsfiles . I put it in ~/.stack/templates/pokemon.hsfiles  . Now, I try "stack new pikachu pokemon" ... but stack can't find the pokemon template. How do I fix this?
11:00:25 <sean_1> What reason could there be behind replicate causing hang + massive mem allocation with a function that normally terminates? Is something strange with laziness occuring? And I wanted to ask this before reinstalling everything with profiling support so i could profile my program...
11:00:30 <erisco> dfeuer, ah, yes this is another great point
11:00:47 <sean_1> Even with n = 2 it causes this to happen, it's really weird
11:00:55 <EvanR> its associative if = means isomorphic
11:01:15 <sean_1> I'll provide a hoogle even though it's a bit ugly
11:01:24 <cocreature> sean_1: what’s the value you’re replicatings
11:01:25 <sean_1> erm, hpaste
11:01:28 <erisco> dfeuer, to resolve that I suppose you'd need a type system such that those are the same type!
11:01:59 <AzureStigma> ZOMG pokemon go and haskell ?
11:02:16 <dfeuer> erisco, they're actually only isomorphic *functors*.
11:02:29 <AzureStigma> sorry offtopic my bad
11:02:47 <sean_1> cocreature: It's a function called on a record that runs for a bit until a certain condition (that is always met).
11:03:15 <cocreature> sean_1: hm sorry can’t help you there without seeing the actual code causing the problem
11:03:28 <sean_1> cocreature: alright, hpasting
11:03:39 <zomg> AzureStigma: amazing!
11:04:24 <mniip> dfeuer, that's where category theory comes in!
11:04:26 <AzureStigma> lol i did that again dindt mean to ping you zomg i forgot you exist
11:04:45 <zlens> I create my own template, pokemon.hsfiles . I put it in ~/.stack/templates/pokemon.hsfiles  . Now, I try "stack new pikachu pokemon" ... but stack can't find the pokemon template. How do I fix this?
11:04:51 <mniip> because you don't need (ab)c=a(bc) but rather only an isomorphism between (ab)c and a(bc) natural in a,b,c
11:05:23 <cocreature> zlens: does "stack templates" show it?
11:05:55 <mniip> consider e.g categorical monoids
11:05:58 <dfeuer> mniip, I don't know what a "natural" isomorphism is.
11:06:06 <dfeuer> I know practically no category theory :(
11:06:12 <mniip> :(
11:06:18 <dfeuer> But you can teach me!
11:06:26 <dfeuer> Yay!
11:06:30 <erisco> no category theory is practical
11:06:31 * erisco snickers
11:06:32 * Canjo 1 2 3 4 I DECLARE A THUMB WAR
11:06:36 <sean_1> cocreature: http://lpaste.net/7435092708730863616
11:07:03 <mniip> dfeuer, do you know what a category is?
11:07:27 <zlens> cocreature: no
11:07:32 <dfeuer> mniip, yes. And I have a sense of what a covariant functor is, and a contravariant functor.
11:07:41 <dfeuer> I get products and coproducts mixed up a lot.
11:07:42 <zlens> cocreature: and googling around it seems like it's currently hardcoded into stack to pull from github?
11:08:01 <dfeuer> (although I can navigate my way out of that bag)
11:09:40 <mniip> dfeuer, ok, you're aware about the basic idea of CT, that we talk about morphisms and not objects
11:09:57 <mniip> i.e we can reason about two morphisms between fixed objects being equal or not
11:10:12 <mniip> whereas objects are sometimes uncomparable and only identifiable by a pattern of morphisms around them
11:10:34 <dfeuer> mniip, um .... not really.
11:10:50 <mniip> well that's the idea!
11:10:54 <dfeuer> OK....
11:11:26 <dfeuer> Go on?
11:11:30 <cocreature> zlens: it looks like you need to run "stack new pikachu ~/.stack/templates/pokemon.hsfiles". I don’t think ~/.stack/templates is actually used
11:11:34 <mniip> when we talk about a terminal object, we determined it by a pattern of morphisms around it,
11:11:41 <dfeuer> Yes.
11:11:46 <mniip> and then we say that it is "unique up to a unique isomorphism"
11:11:55 <dfeuer> Yes.
11:12:20 <zlens> cocreature: amazing, that worked!
11:12:21 <mniip> i.e we don't know which specific object it is, but any two have a pair of morphisms in opposite directions between them such their composition is the same as id
11:12:32 <zlens> cocreature: how did you find this out? I read through the first 3 pages of google results, and none of them told me this
11:13:14 <erisco> you went to page 2? oh my
11:13:34 <glguy> mniip: Can I /msg you?
11:13:44 <zlens> erisco: have you written an non sarcastic response to a question of mine yet? /s :-)
11:13:45 <mniip> sure?
11:14:08 <cocreature> zlens: I tried figuring out where the templates are that "stack templates" shows, got to the conclusion that it fetches them each time from the git repo. then I was confused so I simply ran "stack new --help" and it told me that a path to a file is fine :)
11:14:12 <mniip> if it's freenode related you can message any of us at any time
11:14:47 <zlens> cocreature: lol; I tried "stack -v templates" (to figure out where it was pulling from) but never thought ot read the help page
11:14:53 <erisco> zlens, I guess my track record of one reply doesn't show favourably
11:14:59 <erisco> (or two)
11:17:43 <cocreature> zlens: strace confirms my suspicion that it checks the github repo :)
11:18:03 <zlens> cocreature: github PRs also say it's pulling from the git repo
11:18:14 <zlens> cocreature: there's ppl there complaining they can't stack new blah template without an internet connection
11:18:23 <cocreature> yeah it seems like a weird decision
11:18:46 <cocreature> try to update the git repo? sure! but don’t store them offline? better not
11:18:57 <zlens> cocreature: that's the sentiment on the PR request as well; I think it was an early 'get osmething working first' part of stack; I'm sure they'll fix it eventaully
11:19:55 <sean_1> cocreature: hrm. Seems that replicateM causes the same problem. I don't blame you if you don't feel like wading through this, it is my mess after all lol
11:20:04 <zlens> in stack, is there a way, in package.yaml, to say look in ~/my-repo/ for packages ? (I have a number of personal libraries, not part of lts, that I want stack to be able to use)
11:20:10 <zlens> erisco: ^^ here's a chance to change your ratio :-)
11:20:11 <cocreature> the number of things I hope “stack fixes eventually” seems to be growing a lot quicker than they are fixing issues (not that I’m blaming them for it, I could invest time in it myself after all)
11:20:40 <erisco> zlens, unfortunately I know nothing about stack D: sorry
11:20:48 <cocreature> sean_1: what do I need to call to reproduce the issue?
11:21:17 <sean_1> cocreature: Oh! I apologise, I forgot to give you Main.hs as well
11:21:48 <cocreature> sean_1: if I just need to call successProb with something in ghci that’s fine
11:21:58 <jackhill> zlens: if you don't end up solving your problem here, there is #haskell-stack dedicated to stack
11:21:59 <sean_1> cocreature: http://lpaste.net/8653811312721133568
11:22:06 <sean_1> yeah that's basically the line I use in ghci
11:22:24 <zlens> jackhill: ah, nice, thanks!
11:22:31 <sean_1> remember this causes LOTS of allocation, to the point of swapping
11:22:33 <sean_1> so be careful
11:23:15 <cocreature> I don’t have swap so it’s going to have a hard time trying to swap :)
11:23:24 <cocreature> linux killed it
11:23:30 <sean_1> lol, well it will fill your RAM, certainly. Alright, that's good
11:23:42 <sean_1> I'm running Linux myself but I use swap.
11:23:50 <maerwald> mh, linux swapping is usually the end of your running session anyway ;)
11:23:54 <sean_1> Yeah...
11:24:02 <maerwald> I have never understood why windows is better with that
11:24:07 <cocreature> I have 16gb of ram so when something needs to swap something is wrong anyway
11:24:19 <sean_1> Something is *certainly* wrong with my program :D
11:24:37 <sean_1> Running invade over and over (manually) in ghci doesn't cause nearly as much lag
11:25:04 <cocreature> does it ever return or is it just an infinite loop?
11:25:20 <cocreature> or at least could it be an infinite loop?
11:25:31 <sean_1> For n = 2 it should return VERY quickly
11:25:31 <sean_1> it's somehow looping infinitely
11:25:35 <sean_1> n = 1, it returns normally
11:25:46 <sean_1> well. uselessly, but normally.
11:26:16 <cocreature> well iterate is not a good idea here
11:26:19 <sean_1> The only part of the entire program I use anything possibly infinite is in invade with iterate
11:26:41 <sean_1> but I use "takeUntil" upon its return value
11:26:48 <sean_1> I figured it would lazily evaluate until takeUntil hit the end condition
11:27:52 <cocreature> I’m slightly confused on why it works with 1
11:28:18 <sean_1> Well. "invade" regularly always terminates.
11:28:30 <sean_1> Even with that iterate inside.
11:28:37 <sean_1> One moment while I think up a cmdline
11:29:31 <sean_1> cocreature: evalRandIO $ invade (Battlefield 100 100)
11:29:49 <cocreature> yeah I just don’t get why it terminates. it seems like sequence should force the first list to be completely evaluated before it starts calling takeUntil
11:30:59 <sean_1> Hmmm. You know, that does make sense. I assumed that sequence would work on the list gradually though rather than all at once, but perhaps I am mistaken here
11:31:10 <cocreature> imagine putting putStrLn in there
11:31:42 <cocreature> I’m sure I am missing something completely obvious here
11:31:51 <EvanR> IO is strict so sequence forces the whole list
11:32:25 <EvanR> before moving on
11:32:42 <cocreature> oh Rand is not strict
11:32:54 <cocreature> that would explain it
11:33:44 --- mode: ChanServ set +o glguy
11:33:45 --- mode: glguy set -bbbo *!*kline@*.pool-118-172.dynamic.totbb.net *!*ircap@*.Red-2-138-167.dynamicIP.rima-tde.net *!*@83.247.106.212.dynamic.jazztel.es glguy
11:34:08 <sean_1> does that explain the infinite looping? I should probably just go ahead and replace iterate with something else anyway
11:34:31 <cocreature> sean_1: let me try to walk you through it
11:34:31 <sean_1> Would likely fix the issue...who knows what it's compiling down to
11:34:43 <sean_1> cocreature: ok
11:34:47 <EvanR> you do because you can check the core output ;)
11:35:50 <cocreature> sean_1: so Rand is lazy, and return $ takeUntil … doesn’t need the rng so everything is fine. however if you then run another action it needs access to that rng. and to get to that it has to force all previous computations i.e. an infinite number
11:36:08 <cocreature> and replicateM 2 is what is causing another action to run
11:36:25 <cocreature> hm lazy monads are weird
11:38:24 <cocreature> sean_1: the easiest solution here would be to just interleave the iteration and bfCheck to make sure you never actually sequence an infinite number of actions.
11:39:00 <cocreature> sean_1: what should also work is split the random state and use a separate state for the infinite number of actions, but I probably wouldn’t use that in practise
11:39:17 <sean_1> cocreature: I see...hmm...so there is state that is being...asked for...and that causes the hang?
11:39:21 <EvanR> sequencing an infinite number of actions could be ok if you dont look at the final answer
11:39:23 <sean_1> the state of the rng, like the seed
11:39:31 <cocreature> exactly
11:39:33 <joe9> is there a better way of writing this code, please? http://dpaste.com/1CDMYPS
11:39:35 <EvanR> and only look at the side channel like Writer
11:39:54 <joe9> especially the parseResponse code.
11:40:03 <cocreature> EvanR: yep but here replicateM 2 is causing the second action to force the rng state and thereby the infinite number of actions
11:40:03 <sean_1> That really is something. Almost something I would only expect in a parallel program in some other language.
11:42:47 <nitrix> Hi, given data AnyIORef = forall a. MkAnyIORef {-# UNPACK #-} !(IORef a)
11:43:12 <nitrix> I'd like to unwrap `AnyIORef` back into an `IORef a`.
11:43:49 <monochrom> back into both IORef Int, IORef Bool, and IORef (Int -> Bool)?
11:43:57 <alercah> you can't
11:44:17 <nitrix> I'm assuming this will be pretty nasty but it kinda has to happen. Pattern matching in a let-expression exploded GHC, `case of` or `do` seems to work better but I'm getting a conflict of existantial `a1` with `a2` from the pattern and the function signature.
11:44:24 <nitrix> Scoped type variables doesn't seem to help.
11:44:36 <nitrix> alercah: That's unfortunate.
11:44:38 <alercah> They won't, because you've thrown away the information about what type a is
11:45:08 <nitrix> Do I need to introduce a type class just to do the conversion ?
11:45:26 <nitrix> And a constraint on the existantial type?
11:45:27 <cocreature> there is already Typeable
11:45:27 <alercah> what are you actually trying to do?
11:45:33 <cocreature> which might do what you want
11:45:36 <monochrom> You should consider not using the existential type first.
11:45:37 <nitrix> alercah: Exactly what I described.
11:45:43 <alercah> nitrix: for what purpose?
11:45:53 <EvanR> sean_1: laziness takes some getting used to, but at this point i find eager evaluation more confusing
11:46:03 <EvanR> and laziness is more natural
11:46:11 <EvanR> </totallysubjectivecommentary>
11:46:40 <dolio> Agree.
11:47:15 <nitrix> alercah: I'm extending the current IORef and Weak system for stable names presented in this paper [1] to allow arbitrary relations between independently allocated cells. [1] http://community.haskell.org/~simonmar/papers/weak.pdf
11:47:44 <EvanR> cocreature: ehm... are we just talking about Rand or RandT over IO or something
11:48:00 <cocreature> EvanR: Rand so RandT over identity
11:48:01 <nitrix> Giving Haskell the ability to represent relations between things in O(1) in a type-safe way.
11:48:21 <mniip> nitrix, as the problem is stated, it is impossible
11:48:27 <mniip> unless you use something like unsafeCoerce
11:48:59 <mniip> at which point you're better of with
11:49:00 <EvanR> cocreature: so action 1 is to take an infinite number of random numbers, and action 2 is to take another random number?
11:49:06 <mniip> type AnyIORef = IORef Any
11:49:40 <nitrix> mniip: Do you have a good resource on Any and Typeable ?
11:49:51 <nitrix> data ShowBox = forall a. Show a => SB a
11:50:08 <nitrix> fmap show [SB 1, SB "Hi", SB True]
11:50:16 <nitrix> Can't I just add a typeclass and a constraint?
11:50:27 <alercah> yeah that would probably work too
11:50:29 <EvanR> better: ["1", "Hi", "True"]
11:50:35 <mniip> you can but that would make a different AnyIORef type
11:50:49 <nitrix> mniip: It's not exposed outside the library.
11:50:53 <cocreature> EvanR: yep but the result of action 1 does depend only on a finite number of random numbers, so running only action 1 is just fine, but running action 1 and action 2 (and collecting both of their results) forces the evaluation of the infinite number of random numbers
11:50:55 <mniip> also yes, as EvanR said, you're basically storing comonadic Store's
11:51:05 <mniip> you're better off applying it early
11:51:31 <mniip> nitrix, if the 'a' ever goes outside of your library it will be constrained with Typeable
11:51:53 <nitrix> mniip: The problem is it almost have to stay comonadic, because higher up in the type wrappers are Weak pointers. It wont keep the same semantic.
11:51:55 <EvanR> cocreature: ok. didnt follow that argument, time for coffee
11:52:00 <nitrix> I'll just get my stuff garbage collected.
11:52:09 <sean_1> EvanR: Indeed! I fixed it! I am so happy!
11:52:29 <cocreature> EvanR: if you are just trying to help and not trying to get some knowledge out of it yourself, then all is good. it seems to be working now :)
11:52:48 <mniip> nitrix, a good resource on Any and Typeable is their haddock documentation I guess
11:52:53 <sean_1> I used a DIY sort of iteration instead. I used iterate at first because I know how good it is to leverage standard functions
11:53:02 <nitrix> I'll give it more thoughts and come back after experimenting. Thanks mniip, alercah, EvanR.
11:53:05 <mniip> @hoogle Typeable
11:53:06 <lambdabot> Data.Typeable module Data.Typeable
11:53:06 <lambdabot> Data.Typeable class Typeable a
11:53:06 <lambdabot> Data.Typeable class Typeable1 t
11:53:12 <sean_1> But I can easily see how it can mess stuff up
11:53:22 <mniip> Any is in ghc-prim I think
11:53:23 <mniip> maybe
11:53:33 <cocreature> isn’t Any called Dynamic?
11:53:49 <cocreature> I think Any is a newtype for a monoid instance
11:54:15 <cocreature> hm looks like Any also exists in GHC.Prim
11:54:18 <glguy> There are two different Any
11:55:26 <sean_1> Anyways, thank you guys!
11:57:07 <EvanR> Typeable/Dynamic attaches runtime type information so that code can inspect types at runtime
11:57:13 <c_wraith> there are two different Anys
11:57:24 <buglebudabey> I got this error message building with stack because the module was in other-modules, not in exposed modules, because my main method was trying to import the module - but I don't want to expose the module. Is there another solution? http://lpaste.net/173413
11:57:38 <EvanR> GHC Any lets you pass values around as if they were all the same type, and theres no safe way to do anything with them
11:57:55 * hackagebot ghc-mod 5.6.0.0 - Happy Haskell Programming  https://hackage.haskell.org/package/ghc-mod-5.6.0.0 (DanielG)
11:58:30 <glguy> buglebudabey: If you want a module to be available outside of the library that contains it, it goes in exposed-modules. That includes executable sections in the same .cabal file
11:59:00 <glguy> buglebudabey: If you want to make it more clear that it's an internal module there's a tradition of naming the module "Internal"
11:59:11 <glguy> e.g. Data.ByteString.Internal
11:59:29 <EvanR> Any turns haskell into a very complex version of untyped lambda calculus
11:59:45 <EvanR> which explodes in your face sometimes
12:00:07 <buglebudabey> glguy when posting my project on hackage I only want the lexer and parser i made to be available for the executable, and not the library. so should i simply put them in the app folder where my executable is sourcing from? or is what your suggesting a better approach?
12:01:26 <monochrom> Oh God, I've got a 7MB executable (10MB before strip). It uses cassava.
12:02:38 <EvanR> only 7?
12:04:01 <dolio> That's like 0.0007% of my disk space!
12:07:31 <AzureStigma> where secondGreeting = concat [hello, " ", world] why do you need the " "
12:09:17 <byorgey> > concat ["hello", "world"]
12:09:18 <lambdabot>  "helloworld"
12:09:59 <AzureStigma> i see so it adds a space
12:24:46 <osa1> does anyone else want a mtl function for updating the state, but also returning a value? like atomicModifyIORef
12:26:20 <dolio> @type state
12:26:21 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
12:26:35 <osa1> duh
12:27:18 <cocreature> :t \f -> get <* modify f
12:27:19 <lambdabot> MonadState s f => (s -> s) -> f s
12:27:21 <johnw> sometimes, the most obvious things are the hardest see
12:27:42 <cocreature> oh I missunderstood the question
12:32:59 <leshow> i'm using monad transformers for the first time, following a tutorial online about parsing options from the cli
12:33:26 <leshow> i have this Options type with several flags, and im trying to write the function to handle if a specific flag is set
12:33:40 <leshow> handleCapitalization :: AppConfig m => String -> m String
12:33:41 <leshow> handleCapitalization s = if asks oCapitalize then map C.toUpper s else s
12:34:21 <leshow> but ghc is saying couldnt match expected type Bool with actual type m0 Bool
12:34:27 <leshow> the tutorial wants that line written as
12:34:35 <leshow> handleCapitalization s = B.bool s (map C.toUpper s) <$> asks oCapitalize
12:34:44 <AzureStigma> still dont get... 	where secondGreeting = concat [hello, " ", world] why do you need the " "
12:34:51 <leshow> but that doesnt make much sense to me, so i wanted to write it as a simple if/else
12:37:44 <phanimahesh> AzureStigma: To add a space. concat just concatenates whetever you give it, witout adding anything.
12:37:56 * hackagebot hgmp 0.1.0.0 - Haskell interface to GMP  https://hackage.haskell.org/package/hgmp-0.1.0.0 (ClaudeHeilandAllen)
12:38:04 <alercah> leshow: because if/then/else is not a function, so you cant use it with <$>
12:38:25 <AzureStigma> but i thought to add a space by having an extra space by world
12:38:34 <AzureStigma> so isntead its space world
12:38:41 <fishythefish> AzureStigma: those look like variables, not strings
12:39:06 <AzureStigma> like to add the space its " world"
12:39:11 <fishythefish> so the space before it doesn't matter
12:39:13 <leshow> alercah: is there another way to write it without B.bool
12:39:25 <fishythefish> Ah, in that case, that should be fine
12:39:40 <AzureStigma> so then why is the " " in the code
12:40:39 <AzureStigma> like [hello, " ",  world] when there is already one before world
12:40:48 <chaosmasttter> leshow: you could use a lambda to create a function with an if/else expression inside
12:41:06 <chaosmasttter> or even give it a name in a where clause
12:41:37 <leshow> in the B.bool case, is the 3rd argument "<$> asks oCapitalize"
12:43:19 <fishythefish> leshow: No. Do you know what the <$> is doing?
12:43:37 <leshow> i know it's the infix version of fmap
12:44:02 <fishythefish> right, so we can rewrite as: fmap (B.bool s (map C.toUpper s)) (asks oCapitalize)
12:44:11 <leshow> But the type def of B.bool takes 3 arguments 
12:44:23 <fishythefish> Right, but we can partially apply it to 2 arguments
12:44:26 <fishythefish> Then lift it into the functor
12:44:51 <leshow> ohhhhh
12:45:07 <fishythefish> The third argument of bool is supposed to be a Bool, but what is the type of `asks oCapitalize`?
12:45:24 <leshow> m Bool
12:45:31 <fishythefish> Which is why we need to lift
12:46:03 <leshow> by lift you mean applicative map right? i thought lift was something else
12:46:29 <fishythefish> By "lift" I mean fmap
12:46:35 <leshow> yeah ok
12:46:51 <fishythefish> i.e. "lift" as used in literature, not in monad transformers
12:48:06 <phanimahesh> lift as used in literature is to move something against gravity. _runs_
12:48:54 <mniip> do you even lift bro
12:49:07 <fishythefish> (I mean, if we can have density comonads, surely we can have ones for gravity, right?)
12:52:06 <geekosaur> probably with two incompatible abstractions :)
12:53:16 <phanimahesh> Density comonads? O.o
12:53:18 <phanimahesh> Links please?
12:53:41 <phanimahesh> or ELI50
12:53:55 <shachaf> It's the dual of the codensity monad.
12:54:23 <mniip> >category theory
12:54:26 <mniip> >ELI5
12:54:34 <phanimahesh> I haven't heard of it either.
12:54:37 <shachaf> mniip: 50 hth
12:54:40 <shachaf> A left kan extension of a functor along itself.
12:55:13 * geekosaur thought the 50 was apropos for category theory. even if it's inaccurate over in this corner >.>
12:55:20 <hpc> ELIWABT
12:55:26 <hpc> explain like i wear a bowtie
12:55:57 * phanimahesh makes a mental note to steal ELIWABT for future use
12:55:59 <shachaf> In Haskell, it's something like: data Density f a = forall x. Density (f x) (f x -> a)
12:56:07 <Hafydd> ELI50 is a numeronym for "ELIELIELIELIELIELIELIELI..." (50 times), an acronym for the name of a fundamental concept in category theory.
12:56:27 <mniip> shachaf, how's that different from a Store?
12:56:51 <shachaf> mniip: data Store s a = Store s (s -> a)?
12:56:58 <fishythefish> for reference: https://hackage.haskell.org/package/category-extras-0.53.5/docs/Control-Comonad-Density.html
12:56:59 <mniip> yes
12:57:10 <shachaf> Density (Const s) = Store s
12:57:22 <shachaf> Just like Codensity (Const r) = Cont r
12:57:26 <phanimahesh> fishythefish: Thanks
12:57:40 <mniip> hm
13:01:18 <phanimahesh> Still can't make sense of it, hopefully I will, after reading more
13:01:35 <fishythefish> phanimahesh: It isn't really something you *have* to know
13:02:02 <fishythefish> It might be worth starting by reading up on the codensity monad, which is a generalization of difference lists
13:02:05 <fishythefish> http://www.janis-voigtlaender.eu/papers/AsymptoticImprovementOfComputationsOverFreeMonads.pdf
13:02:24 <fishythefish> That paper is pretty accessible IMO
13:03:24 <mniip> shachaf, is there any mnemonical sense to "left" and "right" in adjunction?
13:04:17 <fishythefish> hom(FX, Y) = hom(X, GY) means F is left adjoint, G is right adjoint
13:04:23 <shachaf> mniip: Hom(F( -- yes, that.
13:04:30 <fishythefish> :)
13:04:44 <shachaf> I'm not a big fan of that naming scheme.
13:04:47 <shachaf> But it's standard.
13:04:50 <mniip> hom or Hom?
13:05:17 <dolio> C and D.
13:05:24 <shachaf> By "hom" do you mean an internal hom functor or something?
13:05:51 <mniip> well fishythefish wrote hom and you wrote Hom
13:06:14 <mniip> tbf I can't remember which of this is internal and which leads to Set
13:06:47 <shachaf> It's the hom functor : C^op x C -> Set.
13:07:57 * hackagebot react-flux 1.2.0 - A binding to React based on the Flux application architecture for GHCJS  https://hackage.haskell.org/package/react-flux-1.2.0 (JohnLenz)
13:08:36 <fishythefish> If F: D -> C and G: C -> D, the left side is hom_C and the right is hom_D
13:08:41 <fishythefish> where these are hom functors as shachaf said
13:09:10 <osfameron> ad hominem functions?
13:09:26 <leshow> homomorphism?
13:10:26 <hpc> those who don't learn their zygohistory are doomed to prepromorphism
13:10:49 <osfameron> so true
13:10:53 <leshow> all greeek to me lol
13:11:19 <fishythefish> hpc: amen
13:11:43 <fishythefish> osfameron: well, per yoneda, hom functors single out individuals, so... yeah, ad hominem
13:12:57 * hackagebot llvm-ffi 3.5.0 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-3.5.0 (HenningThielemann)
13:13:31 <osa1> I'm having weird cabal errors. sometimes 'build' fails with linker errors, sometimes it works but I get segfaults. a 'clean' always fixes it. any ideas why this may be happening? 1.24.0.0
13:13:32 <mniip> what's a paramorphism :o
13:14:44 <fishythefish> A variant of catamorphisms which lets you do primitive recursion essentially
13:15:36 <fishythefish> In a catamorphism, you can fold using the recursively computed value for each subobject in your structure
13:15:37 <osa1> isn't it like fold except you also get to look at rest of the thing in a step?
13:15:42 <fishythefish> In a paramorphism, you also get the subobject itself
13:16:14 <fishythefish> The prototypical example is the factorial function
13:17:49 <mniip> hmm
13:17:54 <mniip> ok then
13:17:57 * hackagebot llvm-tf 3.0.3.1.7 - Bindings to the LLVM compiler toolkit using type families.  https://hackage.haskell.org/package/llvm-tf-3.0.3.1.7 (HenningThielemann)
13:18:00 <mniip> let's begin with what's an algebra
13:18:13 <leshow> what does runExceptT do? i cant find a good description on hackage
13:18:32 <mniip> :t runExceptT
13:18:33 <fishythefish> leshow: It unwraps an ExceptT
13:18:33 <lambdabot> ExceptT e m a -> m (Either e a)
13:18:44 <leshow> yeah i can see the type sig of it
13:18:48 <mniip> oh that just unwraps the constructor
13:19:08 <fishythefish> newtype ExceptT e m a = ExceptT { runExceptT :: m (Either e a) }
13:19:11 <fishythefish> does that help?
13:19:30 <mniip> all ExceptT computations are internally represented with that, and runExceptT is how you "execute" it
13:19:33 <leshow> so it's just running the Either in a monad context?
13:20:08 <mniip> there's hardly any running involved
13:20:23 <leshow> wrapping the either
13:20:35 <mniip> no?
13:20:38 <fishythefish> mniip: type Algebra f a = f a -> a
13:20:54 <fishythefish> An algebra tells you how to reduce a functor-wrapped value to a value of the underlying type
13:20:59 <mniip> fishythefish, it's a categorical term, isn't it
13:21:14 <fishythefish> Yup
13:21:22 <mniip> what's the CT definition
13:21:25 <fishythefish> https://en.wikipedia.org/wiki/F-algebra
13:21:49 <fishythefish> If F is an endofunctor, an F-algebra is an object X and a morphism F X -> X
13:22:02 <leshow> are we still talking about the same thing lol
13:22:20 <fishythefish> leshow: two different conversations
13:22:27 <leshow> phew
13:22:58 * hackagebot colonnade 0.4 - Generic types and functions for columnar encoding and decoding  https://hackage.haskell.org/package/colonnade-0.4 (andrewthad)
13:23:00 * hackagebot react-flux 1.2.1 - A binding to React based on the Flux application architecture for GHCJS  https://hackage.haskell.org/package/react-flux-1.2.1 (JohnLenz)
13:23:10 <fishythefish> leshow: runEitherT just unwraps the newtype - no running, you just get access to the wrapped representation
13:23:18 <divVerent> How would I "mostly uniformly" map all possible Word64 values to the Float range [0, 1)?
13:23:27 <divVerent> (or Double, of course)
13:23:46 <divVerent> like, is there any way where I don't need to hardcode any knowledge about Double's IEEE representation?
13:23:54 <hpc> i learned a different kind of F algebra in high school! :P
13:24:20 <fishythefish> Didn't learn it in high school, but I did hear the words "F algebra" quite a bit
13:24:40 <hpc> that's the joke
13:24:46 <fishythefish> I know ;)
13:31:51 <EvanR> divVerent: are you trying to generate a uniformly distributed random Double 
13:31:59 <divVerent> yes
13:32:03 <divVerent> from a hash value to be exact
13:32:26 <EvanR> i have seen algorithms specifically for this, with some fancy bit twiddling
13:32:55 <EvanR> which is "good enough", since you cant actually uniformly distribute doubles over that range
13:33:15 <EvanR> over the range [0,1] at least
13:33:53 <glguy> Why does (\f -> getAlt . foldMap (Alt . f)) infer a type with the constraint (Monoid (Alt f a)) given that there's an (instance Alternative f => Monoid (Alt f a)), shouldn't the inferred constraint be simply (Alternative f) ?
13:34:22 <c_wraith> glguy, are you sure you imported that instance? 
13:34:48 <glguy> I did
13:34:50 <dolio> There are a lot more IEEE floating point numbers near 0, at least.
13:35:03 <dolio> (Than near 1)
13:35:05 <glguy> c_wraith: GHC accepts the type I expected if I explicitly annotate it
13:35:26 <glguy> but inferring the type that it happens to requires FlexibleContexts and it complains
13:35:54 <divVerent> EvanR: my current approach would be encodeFloat/decodeFloat
13:36:02 <divVerent> at least that gets the bit twiddling away
13:36:44 <divVerent> too bad it's not documented whether encodeFloat 1.0 will return the maximum or minimum normalized mantissa value :P
13:37:03 <divVerent> so I'd have to pessimistically assume the worst, still getting a pretty good point density but nowhere near optimal
13:38:01 <EvanR> er, 1.0 has a unique representation doesnt it
13:38:15 <divVerent> EvanR: of course it does, in practice
13:38:29 <divVerent> however, encodeFloat doesn't return the machine representation anyway
13:38:54 <divVerent> like, I'd _expect_ that encodeFloat 1.0 returns the minimum possible mantissa, and on my PC it does
13:39:40 <EvanR> search for uniform random double in range [0,1]
13:40:01 <EvanR> for example as implemented in javascript
13:40:12 <divVerent> I only get hacky solutions
13:40:22 <divVerent> I was kinda hoping for something better and elegant
13:40:52 <EvanR> ieee floats arent exactly elegant to begin with, its like wanting an elegant solution to parsing HTML
13:41:22 <divVerent> EvanR: sure... what I was kinda hoping for is somehow forcing it to round downwards
13:41:29 <divVerent> then just divide by one plus the range of the integer
13:42:03 <EvanR> the range over the integer exceeds the range of consecutive integer doubles
13:42:04 <buglebudabey> is there a name for a project in which i can parse my language into it's AST and it will compile my language for me?
13:42:06 <divVerent> but in RealFloat there's no equivalent of fesetenv or similar C operations that would do this
13:42:10 <divVerent> EvanR: I know, that's the hard part
13:42:14 <divVerent> avoiding the 1.0
13:42:51 <EvanR> and doing a division might not get the proper resolution anyway
13:43:05 <divVerent> not unless I can set the rounding direction
13:43:15 <EvanR> you can modify the fp env
13:43:20 <hpc> buglebudabey: use ghc as a library, perhaps?
13:43:29 <hpc> it has some ASTs in it
13:44:09 <buglebudabey> hpc thanks but what i mean is there a name for the type of service that lets you parse your own language into an AST in order to compile it
13:44:26 <hpc> oh, a backend is probably the closest term you'll get
13:44:37 <hpc> as in "ghc can compile with llvm as the backend"
13:44:50 <buglebudabey> hpc alright, i reimplemented a compiler for core and want to let other basically do this
13:45:04 <buglebudabey> hpc trying to think of a good synopsis
13:46:20 <EvanR> except i cant find that module anymore
13:49:18 <AzureStigma> anyone here with the haskell book got a question if anyone can take a look?
13:49:46 <divVerent> EvanR: even if one can, I doubt it'd be in any way clean ;)
13:50:11 <EvanR> i remember there being IO actions to modify the global env
13:50:38 <hpc> as in System.Env?
13:50:55 <EvanR> no
13:50:56 <hpc> er, System.Environment
13:51:07 <EvanR> floating point env
13:52:00 <geekosaur> I think there's something on hackage for that. there's a very few flags that can be updated via base iirc
13:53:03 <divVerent> http://pastebin.com/Kcy1LZ2g is what I currently have, but it already makes some hopeful assumptions
13:53:27 <divVerent> namely, thatr the value of mantissa' always yields representable floats (essentially, for this decodeFloat 1.0 has to return the minimum normalized mantissa)
13:53:51 <divVerent> and yes, it suddenly becomes much more elegant when doing the same in integer math
13:54:42 <divVerent> (also, this clearly must use arbitrary-precision integers, not good in a tight loop)
13:54:57 <EvanR> ah elegant, and high performance
13:55:03 <divVerent> of course, doing the same in integer world required special handling of either the 0.0 or 1.0 fraction
13:55:13 <lpaste> fragamus pasted “I need a polymorphic get value function” at http://lpaste.net/173429
13:55:13 <divVerent> but seems like that's still the best...
13:55:21 <EvanR> im just going to guess you want to screw it and simply use a onliner of magic number bit manipulations
13:55:47 <divVerent> essentially I was hoping for a builtin function used by all kinds of RNG modules
13:55:50 <divVerent> that I can just use :P
13:56:01 <EvanR> if you just want a random double, that exists already
13:56:10 <divVerent> except that I need it from a hash function
13:56:42 <divVerent> essentially, I have some runtime parameters in [0,1] range, and want to divide work... e.g. one process handles [0,0.05) and the other handles [0.05,1)
13:56:49 <lpaste> fragamus revised “I need a polymorphic get value function”: “I need a polymorphic get value function” at http://lpaste.net/173429
13:57:06 <EvanR> you can compare the hash directly then
13:57:10 <EvanR> to do the splitting
13:57:14 <divVerent> right, will do that then
13:57:23 <divVerent> and instead do the inverse of the nasty work
13:57:32 <divVerent> i.e. converting the floating point parameter to a good integer to compare with
13:57:42 <divVerent> requires handling either the 0 or 1 case specially, but seems the lesser evil
13:58:00 <divVerent> (or skipping the special handling and just using Integer)
13:58:51 <fragamus> anyone know how i can wrangle a polymorphic get value function in my paste above
13:59:30 <dmwit> fragamus: You want something that can monomorph to either `alphaValue` or `betaValue`? Or do you mean something else?
13:59:39 <divVerent> EvanR: also, just looked - System.Random doesn't do anything more clever for floating point ranges either.
13:59:51 <EvanR> than what
14:00:01 <fragamus> yeah i think
14:00:14 <dmwit> fragamus: Perhaps give an instance for `Comonad` for each, then?
14:00:21 <divVerent> EvanR: than encodeFloat/decodeFloat or directly hardcoding knowledge about the IEEE representation
14:00:26 <dmwit> fragamus: Or define your own one-off class that has an `extract` analog but no `cobind`.
14:00:29 <EvanR> yes thats what i was suggesting
14:00:30 <divVerent> (it does the latter in code, and the former in a comment)
14:00:49 <EvanR> to be honest thats clever enough
14:01:16 <EvanR> if you want more elegant, then switch to real numbers
14:01:23 <EvanR> then the mapping should be pretty trivial
14:01:24 <fragamus> and then Alpha and Beta would be instances of that right
14:01:34 <dmwit> yes
14:01:50 <codedmart> Is there something like flip but just takes the first arg and moves it to the last argument?
14:02:07 <dmwit> No, because it's not generally possible to define what "last argument" means.
14:02:17 <dmwit> e.g. which argument to `id` is the last one?
14:02:32 <codedmart> dmwit: Hmm… ok
14:02:39 <hpc> :t (id, flip id)
14:02:40 <lambdabot> (a -> a, b -> (b -> c) -> c)
14:03:04 <yyyyy> codedmart: isn't `&` what you want?
14:03:20 <ReinH> codedmart: what do you mean by "last argument"?
14:03:20 <yyyyy> :t (&)
14:03:21 <lambdabot> a -> (a -> b) -> b
14:04:01 <dmwit> :t (flip id, \w x y z -> id x y z w)
14:04:02 <lambdabot> (b -> (b -> c) -> c, t3 -> (t1 -> t2 -> t3 -> t) -> t1 -> t2 -> t)
14:04:09 <ReinH> Strictly speaking, functions only take one argument.
14:04:33 <EvanR> > let n = maxBound :: Word64 in map ((/ (fromIntegral n)) . fromIntegral) ([0..maxBound]::[Word64]) :: [CReal]
14:04:34 <lambdabot>  [0.0,0.0000000000000000000542101086242752217033,0.00000000000000000010842021...
14:04:40 <EvanR> divVerent: ^ ;)
14:05:00 <codedmart> ReinH: I am using riak and would like to generalize the query methods more so connection is the last argument. `(FromJSON c, ToJSON c, Resolvable c) => Connection -> Maybe BucketType -> Bucket -> Key -> R -> IO (Maybe (c, VClock))`
14:05:08 <dmwit> EvanR: Yes... Integer arithmetic is too slow, but CReal arithmetic is just fine. =P
14:05:16 <codedmart> All the query methods take Connection first.
14:05:40 <EvanR> if you cant decide on fast, elegant, just fuckit and do elegant ;)
14:06:25 <EvanR> i would like to see some benchmarks for CReal from both packages vs ordinary numbers
14:06:53 <hpc> the fastest code is the code that doesn't get run, and the most elegant code is the code that doesn't get read
14:07:00 <hpc> clearly agda is the fastest language and php the most elegant
14:07:19 <ReinH> codedmart: ok, write your own flip
14:07:33 <EvanR> this particular problem has just fine fast solutions and not even that much code
14:07:46 <ReinH> \f a b c d e = f b c d e a or whatever
14:08:18 <codedmart> ReinH: I thought of that but not all the methods take the same amount of args.
14:08:19 <EvanR> (for got to +1 the max bound)
14:08:31 <ReinH> It's strange to want to vary the connection more than the arguments to the query method, but whatever
14:08:37 <ReinH> codedmart: then write your own flipS
14:08:50 <ReinH> There's no generic way to do it
14:09:14 <codedmart> ReinH: OK thanks!
14:09:34 <dmj`> codedmart: why not have it as the first parameter? 
14:09:34 <ReinH> you can write a module that wraps each method and presents the argument order you want
14:09:38 <ReinH> then import it instead of the original module
14:09:45 <ReinH> s/method/function
14:10:02 <ReinH> That way you only have to do the flipping once.
14:10:17 <codedmart> dmj`: No major reason. Just playing with things to learn. I was thinking of building the queries then passing them to a function that gets the connection and runs it.
14:11:29 <dmj`> codedmart: I see, I'd assume the connection would vary more than the query. Similar argument to having the Manager argument be first in HTTP clients
14:12:33 <codedmart> dmj`: Probably, I am sure I am just being dumb, but I have the connection pool in a reader. So I was thinking of having one function that asks for it rather then a number of them.
14:12:45 <hpc> codedmart: you might also send them a PR with the parameters moved around, and maybe type Query v = Connection -> IO (Maybe v) or something
14:12:55 <ReinH> dmj`: by "more", do you mean "less"?
14:12:57 <hpc> and see if it gets accepted in a major version
14:13:12 <ReinH> Generally you set up a connection and then execute queries against it, not the other way around
14:13:13 <dmj`> ReinH: yes :)
14:13:19 <ReinH> dmj`: ok phew :)
14:13:29 <codedmart> So it my thinking stupid then :)
14:13:29 <hpc> (if you feel up to it of course)
14:13:39 <ReinH> codedmart: I wouldn't say "stupid".
14:13:51 <ReinH> It's worth trying things and learning and you aren't hurting anyone
14:13:55 <hpc> codedmart: it's something every haskell programmer bumps up against eventually
14:14:13 <lpaste> fragamus revised “I need a polymorphic get value function”: “I need a polymorphic get value function” at http://lpaste.net/173429
14:14:20 <hpc> codedmart: this is one of those weird results that comes out of currying
14:14:32 <fragamus> dmwit can you check that
14:14:53 <dmwit> fragamus: `instance AlphaBeta Alpha where`, and likewise for `Beta`.
14:15:40 <dmwit> fragamus: (i.e. drop the `n` argument in the instance head)
14:15:44 <ReinH> You can do things like: do { conn <- getConnection; let getUser = DB.getUser conn; getUser someUserId } where you partially apply the connection.
14:15:54 <ReinH> Obv this is more useful in real world examples rather than this contrived one
14:16:24 <codedmart> Thanks guys I will try it and see how it feels.
14:16:29 <dmj`> codedmart: using a connection pool is a good idea too, not saying you're aren't.
14:16:37 <codedmart> Yeah I am 
14:16:49 <fragamus> thanks 
14:18:09 <divVerent> EvanR: hehe, CReal is indeed cool
14:18:25 <EvanR> the one in exact-real is also cool
14:18:39 <divVerent> I'd divide by (n+1) to exclude 1, and have the set of output values periodically extend to an evenly spaced set
14:18:43 <divVerent> but yes, cool
14:18:52 <EvanR> i would divide by n+1 to include 1
14:18:59 <EvanR> i mean, max+1
14:19:12 <EvanR> er 
14:19:16 <divVerent> to exclude, yes
14:19:49 <EvanR> yeah [0,1)
14:20:07 <EvanR> i just forgot how to make it do [0,1]
14:20:10 <EvanR> divide by max
14:20:35 <hpc> why does exact-real's implementation take a Nat as a type parameter?
14:20:42 <hpc> it doesn't seem to be used anywhere in the package
14:21:39 <divVerent> right, [0, 1] is the easy case, even with IEEE floats
14:21:55 <EvanR> hpc: thats how many digits to compute
14:22:11 <divVerent> the docs say it's also used for the Eq instance, although I can't imagine how
14:22:11 <hpc> ah
14:22:28 <EvanR> im not suprised thats you cant tell its being used, thats how typeclass abuse works
14:22:44 <hpc> so it's not quite like CReal in that you can't have ω at the type level
14:22:54 <ertes> EvanR: division by max is a bad way to go to [0,1], because you pay by excluding an element
14:22:57 <EvanR> i thought the Eq instance just frozen up
14:22:57 <hpc> oh right, type classes
14:22:59 * hackagebot core-compiler 0.1.0.0 - compile your own mini functional language with Core  https://hackage.haskell.org/package/core-compiler-0.1.0.0 (aneksteind)
14:23:07 <EvanR> ertes: how?
14:24:19 <ertes> EvanR: you don't increase the number of possible elements, even though there is one extra element
14:24:27 <ertes> so it must be that you omit an element from the original range
14:25:22 <divVerent> I mean, without having seen the source of CReal (the page always 404s), I can't imagine how CReal can even be consistent
14:25:26 <ertes> like going from [0/4, 1/4, 2/4, 3/4] to [0/4, 1/4, 3/4, 4/4]
14:25:30 <divVerent> like, there can be a == b but (2*a) /= (2*b)
14:25:42 <EvanR> ertes: no.. its the same number of elements either way
14:25:46 <EvanR> you just scale it differently
14:25:59 <ertes> wait…  is this for CReal?
14:26:01 <EvanR> its uniformly distributed eithe rway
14:26:03 <EvanR> yeah
14:26:08 <ertes> then nevermind =)
14:26:14 <EvanR> the "elegant" way
14:26:16 <ertes> with Double you'd pay
14:26:27 <EvanR> with Double youre screwed either way
14:26:40 <ertes> hmm?
14:26:57 <EvanR> you cant uniformly distribute the Double points
14:27:16 <dolio> divVerent: It's not consistent. It's just the price you pay to get 'a == b' to ever return anything but False.
14:27:27 <ertes> you can, but you must not allow *all* Doubles between 0 and 1
14:27:43 <ertes> keep the exponent fixed, choose the mantissa randomly → uniform
14:27:59 <hpc> divVerent: the workaround is to decide what your epsilon is and test for that instead
14:28:04 <EvanR> you need to change the exponent to get anything below 1/2
14:28:35 <hpc> divVerent: and ultimately you're going to end up hitting termination issues with that sort of operation anyway
14:28:40 <EvanR> and stuff very close to zero is going to be funny
14:28:40 <ertes> EvanR: that's fine…  it just goes to a canonical representation, but you can't choose something that would *require* a different exponent
14:28:44 <EvanR> maybe Word64 cant go that low
14:29:05 <EvanR> except 0 itself
14:29:27 <ertes> EvanR: you're effectively choosing x uniformly in x * 2^e for a fixed e…  that's uniform
14:29:30 <divVerent> oh, now I see what got me confused
14:29:36 <EvanR> divVerent: for exact-real you could use the parameter to decide what truncation to compare for equality
14:29:43 <divVerent> both packages use the name CReal
14:29:46 <EvanR> but i could have sworn itll just freeze on things that are equal
14:29:51 <EvanR> or "not unequal"
14:30:04 <divVerent> the really-exact one that may not terminate, and the configurably-inexact one
14:30:15 <divVerent> both are useful to know, but why do they insist on the same type name...
14:30:24 <EvanR> king of the hill
14:30:44 <divVerent> thanks, they will be useful to me
14:31:21 <dolio> I don't think there is one that will fail to terminate on equal numbers, unless there are three CReal packages.
14:31:34 <dolio> The other one I know of just doesn't let you pick the epsilon.
14:32:07 <hpc> dolio: https://hackage.haskell.org/package/numbers-3000.2.0.1/docs/Data-Number-CReal.html
14:32:17 <hpc> that one has the potential to not terminate on equal numbers
14:32:17 <ertes> is there a practical use case for CReal?
14:32:43 <hpc> ertes: astronomy?
14:32:44 <EvanR> > (4 :: CReal) == (2 + 2 + 2 - 2)
14:32:45 <lambdabot>  True
14:33:02 <ertes> hpc: how?
14:33:06 <EvanR> > (sqrt 2 :: CReal) == 1 / (1 / (sqrt 2))
14:33:07 <lambdabot>  True
14:33:25 <dolio> hpc: I don't think those docs are accurate.
14:33:26 <hpc> something where you need to very accurately compute the results of very large and very small numbers being mathed together
14:33:40 <EvanR> they do fail to terminate for converting an irrational number to a rational
14:33:48 <EvanR> like so!
14:33:55 <EvanR> > toRational (sqrt 2 :: CReal)
14:33:57 <lambdabot>  *Exception: CReal.toRational
14:34:02 <EvanR> hmm
14:34:14 <hpc> dolio: perhaps, but it fails to terminate on comparing equal numbers sometimes
14:34:21 <hpc> so it at least exists :P
14:34:47 <EvanR> astronomy is easily done with Doubles i think
14:34:47 <ertes> hpc: sounds contrived
14:34:49 <hpc> > (sqrt 2 :: CReal) == (sqrt 2 :: CReal)
14:34:51 <lambdabot>  True
14:34:56 <hpc> hmm
14:35:04 * hpc forgets how to make it happen though
14:35:15 <EvanR> use case for CReal, divVerent's elegant mapping from Word64 to [0,1]
14:35:20 <ertes> hpc: underflow is not an error…  it's basically saying: one number vanished, because it was so small in comparison that it didn't really matter
14:36:34 <hpc> ertes: it's a source of inaccuracy, and it breaks associativity for doubles
14:37:04 <EvanR> ertes: numerically thats kind of what "error" is
14:37:11 <EvanR> difference from correct
14:37:31 <hpc> well, it's different from correct ;)
14:38:00 <EvanR> apart
14:38:39 <ertes> i think if Double is not accurate enough for your calculation, CReal is probably not a good option either =)
14:38:47 <dolio> hpc: According to the source, it's just comparing like 40 digits after the decimal (I think).
14:38:50 <ertes> you probably need something with a larger range
14:38:59 <dolio> So I'm not sure how that would diverge.
14:39:01 <hpc> dolio: D:
14:39:14 <hpc> i could have sworn it did something fancier
14:39:20 <EvanR> ertes: it depends on what youre doing and how many times
14:39:41 <hpc> 10000000000000000000000000000000000000000000000000000000000000000000 - 10000000000000000000000000000000000000000000000000000000000000000001 :: Double
14:39:49 <hpc> > 10000000000000000000000000000000000000000000000000000000000000000000 - 10000000000000000000000000000000000000000000000000000000000000000001 :: Double
14:39:51 <lambdabot>  0.0
14:39:56 <hpc> hey look, they're equal
14:39:59 <ertes> EvanR: i'd expect CReal to get progressively slower, unless you "force" it from time to time, at which point you need to choose an accuracy
14:39:59 <EvanR> practically youre probably right, because doing things so much more slowly with CReal will make your supervisor question or sanity
14:40:14 <hpc> nobody will ever need numbers that big anyway
14:40:18 <hpc> > length "10000000000000000000000000000000000000000000000000000000000000000000"
14:40:20 <lambdabot>  68
14:40:27 <hpc> 67 digits is enough for anyone
14:40:49 <EvanR> ertes: yeah exact-real doesnt really do "forcing to lose accuracy"
14:40:58 <dolio> You folks should check out Abstract Stone Duality, and the Dedekind reals therein.
14:41:04 <EvanR> you just recompute the whole thing whatever you want a slightly different computation
14:41:36 <shachaf> ASD is TG
14:41:50 <hpc> (actually 53 digits is enough for anyone)
14:42:00 <dolio> TG?
14:42:08 <dolio> TorGo?
14:42:09 <EvanR> i feel cheated that the reals chapter in HoTT book did not mention abstract stone duality
14:42:16 <shachaf> too good
14:43:00 * hackagebot sbp 1.1.0 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-1.1.0 (jgross)
14:43:25 <glguy> TG is the new scow
14:43:26 <dolio> I actually wouldn't want to use ASD, I think. But it's a cool system if all you care about is first-order computation on reals and naturals (and topological spaces).
14:45:53 <eve`> Can I `-Werror` about most issues and then selectively `-Wwarn` about a select few?
14:47:36 <glguy> eve`: I don't believe so
14:47:52 <eve`> okay, thanks
14:48:46 <ertes> Num shouldn't have fromInteger and signum, because it makes it impossible to define NCReal
14:49:24 <ertes> … as a Num instance
14:50:22 <EvanR> computable functions are in a sense continuous
14:50:33 <ertes> @let data NCReal deriving (Eq, Ord, Show)
14:50:34 <lambdabot>  .L.hs:155:23:
14:50:34 <lambdabot>      Can't make a derived instance of ‘Eq NCReal’:
14:50:34 <lambdabot>        ‘NCReal’ must have at least one data constructor
14:51:10 <dmwit> Odd. That seems like an extremely easy `Eq` instance to write.
14:51:30 <hpc> what would compare be?
14:51:37 <dmwit> `compare x y = case x of`
14:52:03 <hpc> empty case is the same as error isn't it?
14:52:17 <dmwit> There's an extension that allows empty cases.
14:52:34 <hpc> yeah, and it compiles to error "empty case" or something like that?
14:52:45 <dmwit> But if you're extension-averse, `compare x y = error "nah"` would be exactly as good, semantically speaking.
14:53:00 <hpc> more of the derived-bottom-averse
14:53:14 <dmwit> You don't get a bottom out unless you put a bottom in.
14:53:21 <ertes> GHC probably considers that non-total
14:53:27 <dmwit> No, it's total.
14:53:34 <ertes> sure, but not as far as GHC is concerned
14:53:36 * fishythefish puts his bottom in, takes his bottom out, puts his bottom in, and shakes it all about
14:54:48 <hpc> dmwit: excluding seq, compare _ _ = bottom
14:55:01 <hpc> dmwit: combined with \_ -> bottom = bottom (via not having seq), compare = bottom
14:55:33 <hpc> with seq it's of course different, but i think it's more useful to assume seq is absent in this case
14:55:43 <glguy> ertes: GHC treats empty case on an empty data type differently to an empty case on a non-empty data type
14:55:47 <dmwit> ertes: There is no warning from `-fwarn-incomplete-patterns`. So it seems like GHC thinks it's total.
14:56:29 <lpaste> glguy pasted “empty cases” at http://lpaste.net/173438
14:57:49 <ertes> glguy: i'm aware of that, but i can imagine that it refuses to write Eq for an empty type for historical reasons, because e.g. in h98 it was impossible to define an empty type
14:58:58 <glguy> Yeah, historical reasons are probalby getting in the way, I was just responding to GHC treating it as non-total
15:03:57 <pshickey>  /help
15:08:01 * hackagebot wai-predicates 0.9.0 - WAI request predicates  https://hackage.haskell.org/package/wai-predicates-0.9.0 (ToralfWittner)
15:18:49 <codedmart> I am trying to write an instance of MonadBaseControl IO. I borrowed some code because I wasn’t sure how to go about it. Here is the code and error -> https://gist.github.com/codedmart/79d68d3285358f2c1bd6e5fc7b8f2a9e
15:19:04 <codedmart> I am not sure what `Wrong category of family instance` meands
15:19:11 <codedmart> means not meands
15:19:46 <dmj`> codedmart: should be expecting a type family, not a data family
15:19:57 <dmj`> it used to be implemented in terms of data families, but that changed
15:20:48 <codedmart> dmj`: Not sure I am smart enough to follow what you are saying yet :)
15:21:16 <codedmart> Oh wait maybe I see
15:22:13 <dmj`> codedmart: the form should be "type StM Stack a = StMStack a"
15:22:41 <dmj`> you're going to have to define an equivalent type to your existing stack you'd like to associate it to
15:24:24 <dmj`> @def newtype Stack a = Stack { runStack :: StateT Int IO a }
15:24:25 <lambdabot>  Defined.
15:24:38 <dmj`> @def newtype StackStm a = StackStm { runStackStm :: StM (StateT Int IO) a }, 
15:24:38 <lambdabot>  Parse failed: Parse error: ,
15:24:47 <dmj`> @def newtype StackStm a = StackStm { runStackStm :: StM (StateT Int IO) a }
15:24:48 <lambdabot>  .L.hs:157:46: Not in scope: type constructor or class ‘StM’
15:25:44 <dmj`> codedmart: well, after you define both, you need to instance MonadBaseControl IO Stack a where type StM Stack a = StackStm a; liftBaseWith ....
15:26:22 <dmj`> restoreM = Stack . restoreM . runStackStm
15:26:51 <dmj`> codedmart: snap-server has an implementation
15:27:02 <joe9> I am building a library for a streaming client. The user provides a config populated with callback functions on any changes in the state. The library invokes the callback on changes in state. How do I thread the user's state (if there is any) through the callback functions.
15:28:02 * hackagebot wai-routing 0.13.0 - Declarative routing for WAI.  https://hackage.haskell.org/package/wai-routing-0.13.0 (ToralfWittner)
15:29:29 <codedmart> dmj`: More like this -> https://gist.github.com/codedmart/79d68d3285358f2c1bd6e5fc7b8f2a9e
15:32:16 <orion> I'm using the safe-exceptions package. Given a pure function "f :: MonadThrow m => Foo -> Bar -> m Baz" with Either being an instance of MonadThrow (and MonadCatch), is it possible to write a function which evaluates to (Either FooException Baz, Either FooException Baz) by calling 'f' twice with two different inputs?
15:34:25 <codedmart> dmj`: Also I can’t seem to find MonadBaseControl in snap at all
15:35:43 <dmj`> codedmart: it's in snap snerver on github
15:37:04 <dmj`> codedmart: your code looks right to me, what extensions do you have enabled
15:37:41 <codedmart> https://gist.github.com/codedmart/79d68d3285358f2c1bd6e5fc7b8f2a9e#file-main-hs-L1-L5
15:37:44 <codedmart> dmj`: ^^
15:38:38 <dmj`> codedmart: you need to add deriving MonadBase IO 
15:40:23 <dmj`> codedmart: https://gist.github.com/dmjio/98ce9ef7634e336311ee33e0f7869c84
15:40:27 <dmj`> codedmart: what is the type of AppConfig
15:42:19 <codedmart> dmj`: https://gist.github.com/codedmart/79d68d3285358f2c1bd6e5fc7b8f2a9e#file-main-hs
15:43:42 <dmj`> codedmart: turn off DataKinds
15:44:00 <dmj`> shouldn't matter though
15:44:58 <lpaste> fragamus revised “I need a polymorphic get value function”: “I need a polymorphic get value function” at http://lpaste.net/173429
15:45:09 <codedmart> dmj`: Yeah same error
15:45:35 <fragamus> in the above paste the infinity constant causes an error when i compile
15:45:36 <codedmart> dmj`: I am on GHC 8 if that matters.
15:45:49 <codedmart> I am not sure what is going on :)
15:45:55 <dmj`> codedmart: ah
15:45:56 <sbrg> fragamus: what is the error?
15:46:56 <lpaste> fragamus revised “I need a polymorphic get value function”: “I need a polymorphic get value function” at http://lpaste.net/173429
15:47:05 <fragamus> that error^
15:47:22 <mniip> add a type for infinity
15:47:29 <mniip> it gets monomorphized
15:48:02 <codedmart> dmj`: Is it `ImpredicativeTypes`
15:50:21 <codedmart> dmj`: That was it. Thanks for your help! Is there any reason I shouldn’t use `ImpredicativeTypes`
15:51:29 <geekosaur> fragamus, without a binding and without parameters, that definition of infinity falls under the monomorphism restriction and gets defaulted to Integer. you can override that by providing a type signature for infinity
15:53:05 <dmj`> codedmart: according to the user guide there is some reason to worry :)
15:53:23 <geekosaur> ImpredicativeTypes breaks *very* regularly
15:53:26 <glguy> codedmart: Don't use it because it's broken and isn't considered supported
15:53:32 <geekosaur> (in fact it's never *not* broken)
15:53:50 <geekosaur> (just sometimes broken in ways that don't happen to interfere with how you're using it)
15:54:40 <glguy> "Note that the -XImpredicativeTypes extension, which has been known to be broken for many years, is even more broken than usual in this release (see Trac #11319, Trac #11675, and others). During pre-release testing we encountered a number of projects that broke with confusing type errors due to (often unnecessary) use of -XImpredicativeTypes. Users of -XImpredicativeTypes do so at their own risk!"
15:54:48 <dmj`> was about to paste that heh
15:55:41 <dmj`> yea, that's strange, 7.10 doesn
15:55:46 <dmj`> 't have this issue
16:04:59 <codedmart> dmj` glguy what are my options then? It compiles with ImpredictiveTypes.
16:05:34 <mniip> ImpredicativeTypes more like UnpredictiveTypes
16:05:56 <tommd> codedmart: Refactor to avoid impredicative types?
16:06:25 <codedmart> tommd: I am not sure I know how.
16:07:07 <dmj`> codedmart: you could try -XDeriveAnyClass since it now infers associated type synonyms. Although I'm unsure how it would know where to find your type... it might only work on default instances
16:11:03 <dmwit> "impredictive types", for when you find the behavior of GHC too predictable
16:11:31 <codedmart> dmj`: I will try that when I get back. Is it the AppConfig that's causing it?
16:14:32 <dmj`> codedmart: nah, something changed in the compiler
16:15:36 <dmj`> codedmart: although it appears snap-server has ImpredicativeTypes enabled too on their instance
16:16:50 <codedmart> Well if DeriveAnyClass doesn't work would I be safer going back to 7.10. Or just use ImpredictiveTypes since snap uses it?
16:19:10 <codedmart> Also if it works in 7.10 without ImpredictiveTypes is it wrong in 7.10 or 8.0.1?
16:19:30 <dolio> Where's the code?
16:20:03 <dmj`> dolio: https://gist.github.com/codedmart/79d68d3285358f2c1bd6e5fc7b8f2a9e#file-main-hs
16:29:55 <dolio> The errors are still the ones on that page?
16:31:22 <dolio> They look like errors with using (.) with higher-rank functions.
16:31:46 <dmj`> dolio: yea, under ghc8 specifically. verbatim code is fine on 7.10
16:32:11 <dolio> Oh, I can explain that, too, I think.
16:32:16 <dolio> GHC 7 was wrong.
16:32:27 <jmnoz> how do I switch to ghc 8? using stack?
16:32:41 <dolio> It didn't look inside type synonyms to see if the expansion was a polymorphic type.
16:32:51 <codedmart> dolio: should I not use (.) then?
16:33:12 <dolio> So GHC 7 didn't see `RunInBase m b -> b a` as a higher-rank function, even though it is.
16:33:28 <dolio> Er, higher rank type.
16:34:03 <dolio> codedmart: Yeah, this is the one case where 'f $ g $ ...' works and 'f . g $ ...' doesn't, because $ has special ad-hoc logic.
16:34:34 <codedmart> dolio: ok cool I will try that in a bit. Thanks!
16:34:49 <codedmart> dmj`: thanks again for your help.
16:35:56 <dmj`> dolio: wow
16:36:40 <dolio> So, GHC 7 would allow impredicative stuff to happen as long as it was disguised by a type synonym.
16:36:49 <dolio> But that got fixed in 8.
16:37:10 <leshow> quit
16:37:12 <leshow> lmao
16:37:44 <codedmart> dolio: that is great information. Appreciate it.
16:39:09 <geekosaur> jmnoz, set your resolver to "ghc-8.0" or one of the nightlies based on ghc8, and it should install ghc8 itself
16:39:28 <geekosaur> if you use the LTS resolvers, it will use ghc 7.10 because that's the compiler that is part of those resolvers
16:46:05 <jmnoz> geekosaur: thanks
16:48:08 <EmmitTillDeserve> hey
16:48:32 <sbrg> O.o
16:49:20 <EmmitTillsGhost> hi there
16:49:47 <EmmitTillsGhost> did you know that foldl is the only way to aggregate a list?
16:50:02 <sbrg> truly?
16:50:06 <EmmitTillsGhost> yup
16:50:13 <EmmitTillsGhost> foldr doesnt real
16:50:15 <sbrg> a-mei-zing
16:51:08 <EmmitTillsGhost> heck, even the signature of foldr is fake, i mean look at it: foldr::something -> something else
16:51:21 <sbrg> obviously
16:51:25 <sbrg> it's all a scam
16:51:27 <EmmitTillsGhost> I mean clearly
16:52:01 <EmmitTillsGhost> haskell::ourLives -> prosperity
16:52:32 <hydraz> wat
16:52:35 * fishythefish scratches his head
16:52:47 <sbrg> we probably shoulnd't feed the troll
16:52:54 <Cale> EmmitTillsGhost: We could do without the nonsense, thanks :)
16:52:54 <EmmitTillsGhost> haskell takes our lives and gives us prosperity
16:52:54 <sbrg> what is the correct incantation to summon the gods?
16:53:03 --- mode: ChanServ set +o Cale
16:53:04 * hackagebot json-rpc-generic 0.2.1.0 - Generic encoder and decode for JSON-RPC  https://hackage.haskell.org/package/json-rpc-generic-0.2.1.0 (KeiHibino)
16:53:12 <EmmitTillsGhost> alright, fair enough
16:53:14 <fishythefish> EmmitTillsGhost: that's a side effect - you need IO
16:53:15 <hydraz> "we probably shouldn't feed the troll", they say, while feeding the troll
16:53:19 <sbrg> i guess "what is the correct incantation to summon the gods?" is the correct incantation to summon the gods
16:53:32 <sbrg> hydraz: *after* feeding him. just a bit. sorry.
16:53:34 <fishythefish> Cale: is abstract nonsense still fair game? :)
16:53:41 <Cale> yes
16:53:44 <fishythefish> phew
16:54:08 <EmmitTillsGhost> what would abstract nonsense look like in comparison to... regular nonsense?
16:54:17 <EmmitTillsGhost> or rather, how would it differ i gues
16:54:23 <hydraz> by not being concrete.
16:54:23 <fishythefish> It's category theory
16:54:35 <fishythefish> https://en.wikipedia.org/wiki/Abstract_nonsense
16:54:54 <EmmitTillsGhost> Quick question on category theory
16:54:57 <ReinH> it would be less concrete
16:54:59 <fishythefish> Also once you prepend "abstract", the term becomes affectionate
16:56:46 <jmnoz> trying to install helm using stack and/or cabal on ubuntu 16.04 seems to lead into a dependency hell
16:56:49 <EmmitTillsGhost> so "a monad is just a monoid in the category of endofunctors" but are endofunctors a category? I always thought if anything that "functors" would be the category 
16:57:05 <EmmitTillsGhost> I don't know, just confused me a bit
16:57:09 <shachaf> Abstract nonsense is easier to catch than nonsense in the citations section, for example.
16:57:27 <hydraz> EmmitTillsGhost: the full quote is “All told, a monad in X is just a monoid in the category of endofunctors of X, with product × replaced by composition of endofunctors and unit set by the identity endofunctor.”
16:57:51 <EmmitTillsGhost> that both clears it up and obfuscates it more...
16:58:00 <Cale> EmmitTillsGhost: For any category C, the endofunctors C -> C are the objects of a category whose arrows are natural transformations
16:58:04 * hackagebot decimal-arithmetic 0.4.0.0 - An implementation of the General Decimal Arithmetic  Specification  https://hackage.haskell.org/package/decimal-arithmetic-0.4.0.0 (RobLeslie)
16:58:05 <shachaf> It's easy enough to find a detailed explanation.
16:58:08 <shachaf> @google monoid category endofunctors
16:58:09 <lambdabot> http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-issue
16:58:09 <lambdabot> Title: haskell - A monad is just a monoid in the category of endofunctors, what's th...
16:58:15 <fishythefish> EmmitTillsGhost: Also note that endofunctors are merely a special case of functors. So if you can build a functor category, then surely you can build an endofunctor category
16:58:45 <Cale> EmmitTillsGhost: moreover, this is not just a category, but a (strict) monoidal category whose tensor product is given by composition of functors, and whose identity object is the identity functor
16:58:48 <shachaf> fishythefish: Well, the monoidal structure of the endofunctor category isn't a special case.
16:59:01 <mgsloan> jmnoz: Have you tried "stack build" in the helm repo? Works for me
16:59:17 <fishythefish> shachaf: Right, but I'm addressing the comment that one would expect the category to just be functors and not endofunctors.
16:59:25 <Cale> and you need that monoidal category structure in order to talk about monoid objects
16:59:48 <EmmitTillsGhost> Yeah I guess that makes sense, I've only recently began my journy in learning category theory.  I guess i'm still a bit lost on how exactly a category differs from a set
16:59:54 <osager> what is the operator to join monad values to list? m a -> m a -> m [a]
17:00:14 <fishythefish> EmmitTillsGhost: A set doesn't come equipped with relations between the values of the set.
17:00:22 <Koterpillar> :t liftM2 (,)
17:00:24 <lambdabot> Monad m => m a -> m b -> m (a, b)
17:00:28 <Koterpillar> osager: ^
17:00:36 <jmnoz> mgsloan: thanks, will try
17:00:53 <fishythefish> :t sequence
17:00:54 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
17:00:58 <EmmitTillsGhost> So a category defines relations between it's values?
17:00:59 <fishythefish> osager: more generally ^
17:01:26 <osager> thanks
17:01:29 <fishythefish> EmmitTillsGhost: Yes, in that morphisms between objects can be used to characterize the objects
17:01:30 <Cale> EmmitTillsGhost: If you go look up the definition of a category, it should be immediately apparent how there's a lot more to it than just a set of things.
17:01:39 <mgsloan> jmnoz: Ooh, actually it did encounter a build error, but it's because of a Setup.hs script wanting an older Cabal version...
17:01:52 <mgsloan> So if you have Cabal-1.24 it won't work
17:02:35 <jmnoz> msgloan guessing "helm" isn't very actively maintained?
17:02:52 <Cale> EmmitTillsGhost: There's a collection of objects, and then for any pair of objects A and B, a collection of arrows A -> B, and then for any three objects A, B, C, there's an operation called composition which takes an arrow f: B -> C and an arrow g: A -> B and gives an arrow f . g: A -> C
17:03:10 <Cale> EmmitTillsGhost: (similarly to how function composition acts on functions between sets)
17:03:49 <osager> how do i append a value "a" to a Wrapped list of m [a]
17:03:50 <fishythefish> And each object has an identity arrow to itself and composition is associative
17:03:59 <Cale> EmmitTillsGhost: in addition to that, for each object A, there must exist an arrow 1_A: A -> A which is an identity with respect to composition
17:04:08 <EmmitTillsGhost> so are functions endofunctors on sets?
17:04:10 <mgsloan> jmnoz: Well, the error occurs when attempting to build cairo / glib
17:04:17 <fishythefish> osager: you can wrap the value with `return` and then lift the cons into m
17:04:17 <EmmitTillsGhost> i probably worded that wrong
17:04:23 <mgsloan> Perhaps newer versions of cairo / glib have fixed Setup.hs
17:04:31 <Cale> EmmitTillsGhost: Only if you regard sets as being categories in a particular way
17:04:42 <Cale> EmmitTillsGhost: Otherwise, that statement doesn't make much sense.
17:04:57 <osager> liftM2 (:) ?
17:04:59 <fishythefish> EmmitTillsGhost: The immediately applicable answer is that the endofunctors you care about are the instances of Functor
17:05:14 <Cale> EmmitTillsGhost: You can take a set, and turn it into a category with the elements of the set as objects, and with only the required identity arrows and no others.
17:05:43 <Cale> EmmitTillsGhost: and then functions between the sets will correspond to functors between those categories, but this isn't really saying a whole lot.
17:05:44 <fishythefish> > liftM2 (:) (return 0) (Just [1, 2, 3]) -- osager
17:05:46 <lambdabot>  Just [0,1,2,3]
17:05:54 <osager> great
17:06:17 <EmmitTillsGhost> The book i was reading from pretty much focuses on "the category of sets" so is that not practically a thing?
17:06:30 <EmmitTillsGhost> rather, it focuses on that for the first two chapters
17:06:52 <fishythefish> That is a thing
17:07:03 <fishythefish> The objects in the category are sets and the morphisms/arrows are total functions between them
17:07:34 <fishythefish> But saying that a category is a set is different from saying there is a category of sets
17:09:32 <EmmitTillsGhost> oh, okay
17:10:04 <Cale> and that's yet again a different thing from regarding a set as a special sort of category
17:11:52 <benzrf> "so are functions endofunctors on sets?" <- i gotta say that when i see someone writing this, it makes me suspect that they don't understand categories
17:12:46 <EmmitTillsGhost> i mean... I was asking for clarification
17:15:36 <divVerent> EvanR: as for the mapping from integertype to [0,1), what now also comes to mind is turning the inputs into a Fraction :)
17:15:44 <divVerent> but learning about CReal was cool, I'll have a lot of use for that
17:15:57 <divVerent> (that, and Interval, when needing accurate calculations)
17:16:07 <divVerent> BTW, for my specific problem, I now found another even lazier solution :P
17:16:13 <osager> i have an monad action action2 <=< action1, how can i add threaddelay to it?
17:16:30 <divVerent> first map 0..nmax to [0, 1]
17:16:39 <divVerent> and in case I hit exactly 1, I prepend something to the string and hash again
17:16:40 <osager> i have tried action2 <=< action1 >> threaddelay 10000
17:16:43 <osager> doesnt work
17:16:52 <divVerent> essentially the "roll the dice again until you don't get a 6" way to use a d6 as a d5
17:16:53 <Koterpillar> osager: just use the do notation
17:16:55 <jakeehrlich> I would like to incorporate a C or object file into my project for use with the ffi. How do I do that?
17:17:07 <jakeehrlich> Sorry that was terse. How do I do that with stack
17:17:16 <divVerent> given the chance of hitting exactly 1 is virtually 0, it's probaly the average-case fastest way anyway
17:17:19 <Koterpillar> osager: do { result1 <- action1; threadDelay 1000; action2 result1 }
17:17:36 <fishythefish> osager: You need to apply the Kleisli-composed function to something first before you can use >> (and I suspect that's backwards)
17:17:46 <fishythefish> But Koterpillar's suggestion is easiest
17:18:05 <osager> let me try the do notation
17:21:50 --- mode: Cale set -o Cale
17:23:12 <dmwit> benzrf: I guess any question, no matter how well constructed, makes me think the person asking it doesn't understand the thing they're asking about.
17:26:37 <shachaf> dmwit: Does it?
17:27:24 <dmwit> You're right. There is a category of rhetorical question that doesn't instill that belief in me.
17:27:48 <shachaf> Or maybe I don't know what I'm talking about.
17:27:49 <Koterpillar> do rhetorical questions form a category?
17:30:08 <TheNightForumer> hey there
17:45:45 <orion> Does anyone familiar with safe-exceptions know how to call this function?: https://github.com/centromere/cacophony/blob/safe-exceptions/src/Crypto/Noise.hs#L81
17:46:32 <orion> I'm slightly confused as to how it could be done purely.
18:20:58 <hodapp> can anyone point to examples of using the FFI with non-threadsafe C calls?
18:36:47 <ClaudiusMaximus> hodapp: maybe gtk bindings?  they have postGUI and postGUISync to send actions to be executed by the main loop thread - not 100% sure if it's thread safety or main loop stealing that led to their creation (i'm guessing both)
18:38:37 <ClaudiusMaximus> hodapp: or at least, they used to, can't seem to find them now
18:40:15 <ClaudiusMaximus> hodapp: ah found it, http://hackage.haskell.org/package/gtk-0.14.5/docs/Graphics-UI-Gtk-General-General.html
18:40:24 <zlens> did ghcjs make it into ghc7.8 ?
18:41:56 <glguy> ghcjs isnt in any normal release of ghc
18:43:28 <zlens> okay; someone on reddit is an idiot for claiming that ghcjs made it into ghc
18:43:45 <sbrg> what?! there are people spreading lies on the internet?!
18:43:47 <sbrg> unpossible!
18:44:43 <sbrg> maybe not lies. maybe they're misinformed.
18:45:21 <glguy> differently informed. people with alternate information
18:46:53 <sbrg> so many possibilities.
18:54:44 <ReinH> "Someone is wrong on the internet"
18:56:13 <geekosaur> or "is available for" was misinterpreted as "is included with"
19:00:50 <mgsloan> Hrrrm, anyone know why (lookupTypeName "Prelude.Maybe") yields (Just "GHC.Base.Maybe"), but (lookupTypeName "GHC.Base.Maybe") yields Nothing?
19:01:05 <mgsloan> Is it just TH being fiddly there?
19:03:12 <glguy> mgsloan: Prelude GHC.Base Language.Haskell.TH> $(stringE . show =<< lookupTypeName "Maybe")
19:03:12 <glguy> "Just GHC.Base.Maybe"
19:03:40 <glguy> mgsloan: Perhaps the difference is that you hadn't imported GHC.Base at the time?
19:05:19 <mgsloan> Could be.  Docs say it can handle qualified names
19:05:31 <mgsloan> And these names are present in TypeRep
19:05:40 <mgsloan> (writing a (TypeRep -> Q Type))
19:05:45 <glguy> I think it can handle qualified names as much as normal expressions can
19:05:51 <glguy> thing still have to be imported
19:06:15 <mgsloan> Weird, because TH can reify stuff that isn't imported
19:06:41 <glguy> Look up the given name in the (type namespace of the) current splice's scope. See Language.Haskell.TH.Syntax for more details.
19:06:55 <mgsloan> I guess it can only reify stuff that way if you already have a global Name
19:06:58 <glguy> "current splice's scope" suggests the current behavior to me
19:07:10 <glguy> yeah, reify's argument is already resolved
19:07:49 <glguy> manually constructing Names is non-portable across GHC versions
19:07:57 <glguy> but it exists...
19:08:09 <glguy> but I guess that doesn't help with your TypeRep case
19:10:06 <mgsloan> Looks like it does help!  (Name (OccName (tyConName con)) (NameG TcClsName (PkgName (tyConPackage con)) (ModName (tyConModule con)))) works
19:10:19 <mgsloan> to convert a TyCon to a Name
19:11:08 <glguy> ah, neat
19:11:22 <slack1256> is there a standard way to access the GHC-api that doesn't bind you to a specific version?
19:11:43 <glguy> slack1256: The GHC API changes each version, so probably not
19:11:49 <mgsloan> slack1256: the "hint" package is the closest I know of to that
19:12:54 <slack1256> if we could define a standard "signature" against which we could instantiate each "structure" of every ghc version ;-)
19:13:14 <slack1256> but we would need a good definition of the signature
19:27:17 <nshepperd> the problem with stable APIs is that the only way to fix the problem that the previous API was wrong is to make it right
19:41:03 <ontop> I have the IO monad going on in a do block, but I also want to use the either monad in the do block. Is this possible somehow?
19:41:16 <ontop> Maybe Monad Either Transformer or something?
19:42:22 <Clint> ontop: depending on what you're talking about, maybe ExceptT IO
19:42:30 <dmj`> ontop: you can also use let bindings for that sort of thing
19:42:44 <ontop> dmj`: Yeah, but I wanted to stop myself from having the staircase code :(
19:43:02 <dmj`> ontop: use where clauses
19:43:28 <ontop> Can you show how that solves the problem? Because you have things that depend on each other so wouldn't you have just a bunch of where clauses?
19:43:40 <ontop> Each line depends on the output from the previous line
19:43:46 <dmj`> main = do { print foo } where foo = do { m <- Just 4; pure m }
19:43:55 <ontop> o
19:43:56 <dmj`> foo :: Maybe Int
19:44:00 <ontop> Interesting...
19:44:12 <dmj`> the plot thickens, the thick plottens
19:44:40 <hodapp> ClaudiusMaximus: found what now?
19:45:56 <dmj`> ontop: let foo = do { m <- Just 4; pure m } in print foo
19:46:16 <ontop> o
19:51:06 <Cale> ontop: What are you actually trying to do?
19:51:34 <ontop> Cale: Basically I have a bunch of functions that return IO (Either Error SomethingINeedNext)
19:51:42 <ontop> And if that is a Right SomethingINeedNext, I continue
19:51:48 <ontop> If it's not, I PutStrln the error
19:51:50 <ontop> And give up.
19:52:33 <Cale> Okay, fair enough, that's ExceptT
19:52:38 <ontop> Oh.
19:53:21 <Cale> :t ExceptT
19:53:22 <lambdabot> m (Either e a) -> ExceptT e m a
19:53:41 <ontop> So I was roughly right!
19:53:50 <Cale> The data constructor will turn your IO (Either Error Result) into an ExceptT Error IO Result
19:54:06 <Cale> and then you can chain a bunch of computations of that type together
19:54:13 <Cale> :t runExceptT
19:54:14 <lambdabot> ExceptT e m a -> m (Either e a)
19:54:16 <ontop> But, Result always has to be the same type right?
19:54:20 <Cale> and then turn it back
19:54:23 <Cale> no
19:54:29 <Cale> :t (>>=)
19:54:30 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:54:36 <ontop> Ah
19:54:36 <ontop> Right
19:54:38 <ontop> Derp ^_^
19:55:04 <hodapp> https://github.com/Hodapp87/hmatrix/blob/master/packages/glpk/src/Numeric/LinearProgramming.hs#L282 - so am I understanding right that even though that's marked 'unsafe' and in IO, and never called with unsafePerformIO (as it was prior), it still may called from multiple threads?
19:56:12 <hodapp> still may *be* called, rather.
19:58:24 <ontop> When I'm using ++ "something"
19:58:34 <Cale> hodapp: Yeah, "unsafe" just means that it's not safe for that c_simplex_parse to call back into Haskell code.
19:58:34 <ontop> Why doesn't overloaded strings figure out that I want to concat that with my Data.Text?
19:58:46 <ontop> It thinks it's a [Char] still.
19:59:00 <glguy> overloaded string *literals* overloads the "" syntax
19:59:04 <Cale> hodapp: (which it probably won't even try to, given the name)
19:59:04 <glguy> It doesn't change the type of ++
19:59:08 <ontop> Ah.
19:59:35 <Cale> The solution to that is to use <> instead
19:59:39 <kadoban> All it does is change the type of string literals to   IsString a => a    like integer literals are Num a => a
19:59:59 <hodapp> Cale: Yeah, I don't think it does. I'm just trying to get a sense of how to fix this - that's from hmatrix-glpk, and it has a nasty bug by way of assuming GLPK is thread-safe when it's not.
20:00:06 <denizay> hey
20:00:18 <ontop> Cale: What lib is that in, do you know?
20:00:28 <Cale> ontop: Data.Monoid
20:00:43 <glguy> hodapp: To restrict which OS thread an FFI call will originate from you'll want to look into "bound threads"
20:01:00 <ontop> Tyvm
20:01:26 <Cale> hodapp: Where does it do that?
20:01:47 <denizay> just starting to learn haskell, im going with learnyouahaskell.com, you think it is a good place to start ? i was thinking looking to Write_Yourself_a_Scheme_in_48_Hours after that
20:02:17 <hodapp> Cale: most of what I know is by way of https://github.com/albertoruiz/hmatrix/issues/195
20:02:25 <hodapp> glguy: I'll take a look at that
20:03:33 <hodapp> Cale: hmatrix-glpk ordinarily uses unsafePerformIO on those GLPK calls, and first I tried removing the unsafePerformIO, but the bug still manifests itself.
20:04:34 <geekosaur> denizay, LYAH will teach you to read Haskell, it's kinda bad at teaching writing it. you need a supplemental set of exercises. (no, Project Euler does not count; it is about number theory, not programming)
20:32:22 <hodapp> so if I use forkOS for a bound thread, then my computation is an IO ()... so, must I find some way to capture that C function's output and store it as a side-effect?
20:32:32 <hodapp> maybe I should just take a look at what glpk-hs does.
20:35:19 <hodapp> that or just use glpk-hs instead. but, I should contribute back to hmatrix...
20:36:46 <geekosaur> I don't understand the question. if it's a pure function, use unsafeLocalState (which is almost but not quite unsafePerformIO). but if it's not thread safe, you should probably assume it's modifying thread-local state and use it in IO only
20:37:36 <hodapp> geekosaur: I'm already using it in IO (I removed the unsafePerformIO) but the bug persists
20:37:42 <geekosaur> or likewise if it needs locking (unsafePerformIO / unsafeLocalState of a computation requiring a lock will go bad places)
20:38:14 <geekosaur> then the real problem is that you need to wrap all the library's functions in a mutex
20:38:27 <hodapp> not bound threads like glguy said?
20:38:39 <papyrus3k> i'd like to write a simple socket server with an eye towards being able to handle a large number of connections concurrently
20:38:57 <hodapp> I don't know if it needs locking, I just know it's not thread-safe
20:38:59 <papyrus3k> is there a good place to start with this? specific packages or libraries?
20:38:59 <geekosaur> there's two reasons things can go wrong with this: thread local storage, which is mitigated by bound threads, and need for a mutex
20:39:29 <geekosaur> nothing will help you magically if the library requires mutexes for access from multiple threads; it's just a bad library, as albertoruiz commented
20:39:37 <hodapp> manual says non-thread-safe, and also non-reentrant, but I don't know if that changes anything
20:39:59 <geekosaur> I mean. you can add the mutexes to the haskell binding, but that just gets you extra delays that can only be removed by swapping the library for one that is thread safew
20:40:13 <geekosaur> (otoh it will get you correct results)
20:40:33 <geekosaur> that just confirms that you need to wrap all the calls to that library in a mutex
20:41:09 <geekosaur> there is no way around this. if the library is not thread safe then you need to use it single threaded or wrap every single call in a mutex to ensure that only one thread is in the library at any given time
20:41:19 <hodapp> what does, the non-reentrancy?
20:42:26 <geekosaur> "not thread safe" means you cannot call into it from two different threads. "not reentrant" means that something you pass it to call from within itself must not call back into the library again
20:43:12 * hackagebot type-spec 0.2.0.0 - Type Level Specification by Example  https://hackage.haskell.org/package/type-spec-0.2.0.0 (SvenHeyll)
20:43:14 * hackagebot file-embed-poly 0.1.0 - Use Template Haskell to embed file contents directly.  https://hackage.haskell.org/package/file-embed-poly-0.1.0 (sasinestro)
20:44:24 <geekosaur> ...the distinction is one of concurrency
20:45:22 <hodapp> yeah, mutex is what was suggested in https://github.com/albertoruiz/hmatrix/issues/32
20:46:01 <geekosaur> for most naïve non-thread-safe libraries, they are neither thread safe nor reentrant. libraries that are thread safe are usually also reentrant; libraries that are not thread safe sometimes can be reentrant, although it is rare (this appliues to callbacks and also POSIX signal handlersm although ther latter are a more complex case)
20:46:27 <geekosaur> anyway, yes, the only way forward that retains this library is a mutex
20:46:57 <geekosaur> (well, option (c) is rewrite the library to be thread safe. I suspect if that were easy, you'd not be using the library in the first place...)
20:47:24 * hodapp checks his to-do list...
20:47:32 <hodapp> Nope, "dive into the internals of GLPK" isn't on there.
20:49:32 <hodapp> ...but "dive into bed" is. I'll look at this tomorrow.
20:50:53 <orion> I need to render HTML5 templates from a XML file. Is heist too heavyweight for this?
20:53:48 <papyrus3k> no love for advice re: making a socket server?
20:54:02 <papyrus3k> e.g. preferred packages and/or approaches
20:55:42 <geekosaur> I can't help, sorry
21:06:44 <glguy> papyrus3k: You can start using the "network" package. GHC has an event manager the sockets integrate into
21:07:33 <glguy> with one runtime (not OS) thread per socket blocks for reading
21:12:34 <denizay> geekasour you still here ?
22:30:45 <jakeehrlich> if I call unsafeInterleaveIO on a value of type IO [a] to get a value of type [a] and will it lazily evaluate the list? or will it force the evaluation of the whole list as soon as I request the head?
22:33:31 <glguy> jakeehrlich: It will wait to execute the action until the value is evaluated at which point the whole action is run
22:33:59 <glguy> If you want to lazily produce the elements of that list, and producing an element of that list requires some IO, you'll need many uses of unsafeInterleaveIO
22:35:55 <jakeehrlich> glguy: Example?
22:36:52 <glguy> of which part? The key is that unsafeInterleaveIO only delays a single action, it doesn't transform a single action to run in some lazy mode
22:37:34 <glguy> getLines = unsafeInterleaveIO (do x <- getLine; xs <- getLines; return (x:xs))
22:38:00 <jakeehrlich> Say I want to produce a list [1, 2, 3] but I want "1" to be printed out when I pattern match on the head and "2" to printed when I match on the tail and "3" to be printed when I match on the tail of the tail
22:38:02 <glguy> observe that unsafeInterleaveIO is going to be used multiple times, once for each list element demanded
22:38:42 <jakeehrlich> would that be let xs = getLines?
22:38:55 <jakeehrlich> but yea I think I see now
22:38:58 <glguy> No, you'd still have: xs <- getLines
22:39:14 <glguy> but that wouldn't block. Blocking would occur upon evaluation of xs
22:39:48 <jakeehrlich> ah ok I see now!
22:40:54 <jakeehrlich> ok so just for a sanity check. I want to maintain a Ptr which was allocated with malloc and call an FFI function repeatedlly to get successive values
22:41:15 <jakeehrlich> the foreign function modifies only that pointer and is otherwise pure
22:42:00 <jakeehrlich> I don't want to make the call to the foreign function until the corrasponding element of the list is matched on
22:42:06 <glguy> If it modifies the pointer, then it's not pure
22:42:17 <jakeehrlich> thats why I said "otherwise pure"
22:43:16 <jakeehrlich> it modifies no global state is my point
22:43:33 <jakeehrlich> nor relies on any global state. it's just foreign
22:44:06 <geekosaur> if it takes the pointer and returns the modified one, it's still pure. otherwise it's not pure and that pointer is its "global" state
22:44:38 <geekosaur> or if it takes the pointer and modifies the thing pointed to, it's still not pure
22:44:44 <jakeehrlich> eh...then I'm just using the wrong words
22:45:00 <glguy> Maybe that won't matter when we know what the question is
22:45:14 <geekosaur> consider that this is not just a matter of making the compiler happy; what happens if two threads make calls using the pointer at the same time? if this is not safe, it is not pure
22:45:48 <jakeehrlich> the *only* memory that it modifies is what that pointer points to. Additionally the pointer does not leak to anywhere else in the code. It is only visiable to the function producing the list
22:46:20 <geekosaur> where "pure" here is not theoretical, but is "can I use unsafeLocalState with this?"
22:48:19 <jakeehrlich> ok so I guess my question is, assume that it is safe to use unsafeLocalState (I just learned about that now). Is it then consequently safe to sprinkle unsafeInterleaveIO where ever I want
22:50:08 <geekosaur> actually, if you can use unsafeLocalState, you should not need to care about unsafeInterleaveIO because as far as Haskell is concerned, no IO is being done
22:50:25 <glguy> At that point you can import the foreign function as being pure
22:51:20 <nshepperd> unsafeLocalState does not help here
22:52:10 <jakeehrlich> Why is that?
22:52:12 <glguy> specifically because the malloc allocated pointer isn't elligible to be used inside unsafeLocalState?
22:52:26 <jakeehrlich> it's a Storable operation
22:53:05 <geekosaur> I think you just ruled out unsafeLocalState
22:53:16 * hackagebot euphoria 0.8.0.0 - Dynamic network FRP with events and continuous values  https://hackage.haskell.org/package/euphoria-0.8.0.0 (MitsutoshiAoe)
22:53:37 <jakeehrlich> there has got to be a way to do this
22:54:32 <geekosaur> you're thrashing about, as far as I can tell. more detail is needed to determine how to do it properly, instead of trying to sprinkle magic and hoping you get something other than a core dump
22:54:56 <jakeehrlich> sure, that seems correct. let me try to explain
22:55:06 <nshepperd> do { ptr <- foo_create; let go = unsafeInterleaveIO (ffiGetNext ptr >>= \case { Just item -> (:) <$> item <*> go; Nothing -> return [] }) in go }
22:55:36 <nshepperd> ^^ is this the sort of thing you're trying to do? iterate on a foreign "list" or "iterator" of some kind?
22:55:48 <jakeehrlich> I'm trying to interface with an incremental sat solver. This sat solver is interacted with though foreign C functions that I wrote and externed in C
22:56:27 <jakeehrlich> the state I need to maintain is the solver state. the solver state is initlized with a string
22:56:36 <jakeehrlich> same input string = same solver state
22:57:03 <jakeehrlich> I then repeatedlly ask the solver for solutions (this demands modifying the solver)
22:57:31 <jakeehrlich> so there is a pure function that I would like to have that has type String -> [[Int]]
22:57:37 <senoj> modifying the solver *state* ?
22:58:00 <jakeehrlich> where each [Int] is a solution and the String is the string that initializes the solver
22:58:17 <jakeehrlich> senoj: what's the difference?
22:58:58 <jakeehrlich> furthormore sometimes I want to know all the soltutions but sometimes I'd like to just know that there is a solution
22:59:05 <jakeehrlich> and sometimes I only want a few solutions
22:59:07 <senoj> well, I didn't know if you meant modifiying the solver (code, etc..) or the state at runtime. I think you meant the state at runtime.
22:59:29 <jakeehrlich> oh yea the state
22:59:34 <jakeehrlich> sorry about that
22:59:42 <jakeehrlich> no self modifying code here
23:00:08 <jakeehrlich> so anyhow, it would be ideal that if only pattern match on the head that it only calls the solver once
23:00:21 <jakeehrlich> if I match of the first 3 items then it only calls the solver 3 times, etc...
23:01:22 <jakeehrlich> I'm not really sure how to acomplished that but IMO it should be doable because I know the function String -> [[Int]] has a well defined form. Same inputs will produce the same outputs upto inspection
23:01:49 <senoj> so your SAT solver is completely deterministic?
23:01:56 <jakeehrlich> yes
23:02:08 <jakeehrlich> I actully have to set it that way but yes
23:02:20 <glguy> unsafeInterleaveIO should be OK for this as i understand the api
23:03:38 <senoj> how do you have the FFI setup? for example you can declare FFI functions pure or not and the compiler takes you at your word
23:04:05 <jakeehrlich> so by first making a function of type String -> IO [[Int]] using unsafeInterleaveIO can I then safely call unsafeIO on it?
23:04:34 <nshepperd> you want to declare the FFI functions IO here, because the "get next" calls need to be ordered
23:04:37 <jakeehrlich> senoj: I don't have it setup yet. I'm trying to understand what I'm going to do first
23:05:25 <geekosaur> jakeehrlich, if you are using unsafeInterleaveIO then you are in IO and there is no need to unsafePerformIO / unsafeLocalState. if the function is actually pure enough to get unsafeLocalState then there is no need for unsafeInterleaveIO
23:05:27 <jakeehrlich> also they aren't pure in the haskell since I don't think because the solver state gets modified
23:06:11 <jakeehrlich> So I'll get the lazy behavior that I want by just calling unsafeLocalState? It won't force the computation?
23:06:30 <senoj> the haddock docs for unsafeInterleaveIO are pretty thin
23:06:31 <nshepperd> geekosaur: that's not true... unsafeLocalState applied to the whole operation does not provide the needed laziness
23:06:54 <jakeehrlich> haha, this is way more complicated that I thought it would be
23:07:12 <geekosaur> hm. it should be that the unsafeLocalState itself will not be forced unless something demands the result, at which point it is run
23:07:31 <jakeehrlich> I care about weather the whole list is forced when the list is matched on
23:07:53 <geekosaur> but I think in this case you can't use unsafeLocalState because updates are made through the pointer. so forget the unsafeLocalState and use unsafeInterleaveIO
23:07:55 <glguy> unsafeLocalState requires that the action is dupable
23:08:45 <senoj> that makes snese
23:08:45 <nshepperd> 'unsafeLocalState $ do { allocate sat solver; run sat solver; get results as list }' is useless because all results are forced at once
23:09:11 <geekosaur> nshepperd, I don't understand your complaint. if this is being applied to the whole operation, then no, it's not sufficient. but it also doesn't permit unsafeInterleaveIO, and it also would very likely not be pure enough for unsafeLocalState.
23:09:16 <nshepperd> unsafeLocalState at smaller granularity makes no sense since ordering is needed
23:09:52 <geekosaur> I understood that unsafeLocalState was being applied to each *step*. but with the pointer being updated, this means there is a required order, and you're back in IO
23:10:02 <geekosaur> so, again, just forget unsafeLocalState
23:10:44 <jakeehrlich> I need to be outside of the IO monad
23:11:04 <geekosaur> ... you just lost
23:11:06 <senoj> jakeehrlich: that doesn't seem like a good idea
23:11:20 <geekosaur> you have not described an operation that can work outside of IO
23:11:21 <jakeehrlich> yea it seems realy fishy
23:11:43 <jakeehrlich> but I don't know exactly what problems would occur
23:12:12 <nshepperd> lazySatSolve :: String -> IO [[Int]]
23:12:13 <jakeehrlich> *IF*, and that's a big if, things are evaluated the way I think they are then this function outside IO is pure
23:12:28 <geekosaur> making it lazy enough that it can force the third call without having done the second, so the state in the pointer is not correct for the third call
23:12:42 <jakeehrlich> I don't want that
23:12:49 <nshepperd> pureSatSolve = unsafePerformIO . lazySatSolve :: String -> [[Int]]
23:12:56 <geekosaur> itrating the list only forces the *spine*, it does not automatically evaluate the items
23:12:57 <nshepperd> ^ this is what you want
23:13:01 <jakeehrlich> yea, can I get pureSatSolve?
23:13:15 <jakeehrlich> That's what I have been assuming I was going to do
23:13:16 <senoj> you will probably regret it
23:13:23 <geekosaur> but that will happen all at once, not per item as you were asking
23:13:31 <jakeehrlich> implement lazySatSolve with interleaved IO and then make pureSatSolve
23:13:37 <nshepperd> jakeehrlich: yes
23:14:09 <jakeehrlich> ok senoj thinks I'll regret it. Why? I don't like doing things I'll likely regret. I try to avoid that ;)
23:14:16 <geekosaur> I don't think you're allowed to do that actually
23:14:31 <jakeehrlich> haha, why? What does it violate?
23:15:05 <jakeehrlich> it sure seems fishy
23:15:13 <geekosaur> in fact I seem to recall using unsafePerformIO "inside" unsafeInterleaveIO like that will cause problems with the runtime, because of the way unsafeInterleaveIO is implemented
23:15:31 <nshepperd> other way around..
23:15:41 <nshepperd> unsafeInterleaveIO is inside unsafePerformIO
23:15:42 <jakeehrlich> I want to perform unsafeInterleaveIO inside unsafePerformIO not vice versa
23:15:55 <geekosaur> um, I think that;s a *complete* nonstarter
23:15:57 <senoj> jakeehrlich: unsafePerformIO is not type safe, among other things
23:16:04 <geekosaur> but it's your core dump
23:16:24 <senoj> you are much better off restructuring the computation you want to do so that you can live an honest life in IO
23:16:45 <jakeehrlich> senoj: sure but I have to give up somthing here. that's what I'm giving up. That dosn't mean my program will crash however
23:16:46 <nshepperd> uh, why?
23:16:46 <geekosaur> (actually I don't think that 
23:17:00 <geekosaur> s a core dump waiting to happen but a runtime deadlock)
23:17:28 <senoj> just because your program does not crash does not mean it is correct
23:17:59 <jakeehrlich> I guess what I'm asking is why it wouldn't be correct
23:18:24 <senoj> if you find yourself going to great lengths to avoid being in IO, why not just accept the fact that what you're trying to do does have side effects?
23:18:48 <senoj> well, I guess it depdends on what we both mean by correct.
23:19:15 <senoj> introducing unsafePerformIO makes type checking unsound, that's proven mathematically
23:19:45 <senoj> so if your notion of correct implies type correct, then the use of said function makes your program incorrect
23:19:47 <nshepperd> there are lots of other ways to crash and break things with the ffi
23:19:51 <jakeehrlich> It's correct if the function pureSatSolve :: String -> [[Int]] maps outputs to the same output always and produces solutions to the sat problems defined by the input string
23:20:04 <nshepperd> this seems like pointless doomsaying
23:20:12 <senoj> perhaps
23:20:57 <senoj> jakeehrlich: sure, that a good definition. But how do you reason about whether it is the case or not (formally or informally) when you've subverted the type system?
23:21:22 <jakeehrlich> senoj: I don't know. That's why I'm asking ;)
23:22:03 <senoj> It was a rhetorical question :) but I think the answer is that you can't. That might not matter, practically.
23:22:21 <senoj> there are plenty of commonly used lbraries that employ unsafe operations (like ByteString)
23:22:40 <senoj> but their authors have generally thought very carefully about its use
23:23:02 <senoj> What is the real reason you can't do this in IO?
23:23:22 <geekosaur> so, my recollection is that unsafeInterleaveIO is only viable because of locking within the I/O manager. unsafePerformIO *runs without locking*
23:23:51 <EvanR> if you can do something properly without an IO type, its probably going to be nicer to use
23:23:55 <geekosaur> (in fact I am recalling code that checks for that case and throws an exception because it can't possibly work)
23:24:09 <EvanR> big if hough
23:26:02 <jakeehrlich> senoj: I want to write various algorithms using this and those algorithms are conceptually pure and shouldn't be stateful
23:26:30 <jakeehrlich> one of those algorithms is ACUI unification
23:27:00 <ReinH>  why do they require IO?
23:27:17 <ReinH> what does statefulness have to do with IO?
23:27:30 <senoj> jakeehrlich: can you evaluate lazySatSolve in an outer IO context and pass results to pure implementations of the algorithms you'd like to implement?
23:27:52 <senoj> ReinH: because the state lives in a C library
23:28:36 <jakeehrlich> ReinH: stateful was the wrong word. those algorithms benifit from an industrial strength SAT solver but should conceptully be pure. 
23:28:47 <nshepperd> λ> unsafePerformIO (unsafeInterleaveIO (return 3))
23:28:49 <nshepperd> 3
23:28:56 <jakeehrlich> that was neat
23:29:27 <senoj> nshepperd just launched the missiles
23:30:06 <jakeehrlich> senoj: I would need to pass a function of type SatProblem -> [[Int]] because I don't know what SatProblem the algorithms are going to generate
23:30:13 <geekosaur> I just looked at source in ghc 8.0.1 and do not see the warning or the check, yeh. now I am wondering what I was recalling, aside from combination of unsafe IO things being *really really* unsafe
23:30:14 <jakeehrlich> and they will generate multiple, not just 1
23:30:30 <senoj> jakeehrlich: I see
23:30:37 <nshepperd> geekosaur: maybe you're thinking of unsafeDupable*
23:30:42 <geekosaur> but as the general trend here seems to be to throw in all the unsafe we can, I guess I leave you to it
23:30:47 <geekosaur> looked at those too\
23:31:12 <jakeehrlich> btw you guys are the best for talking about this with me
23:31:55 <senoj> seems like an interesting dilema
23:32:19 <jakeehrlich> So if there was just 1 sat problem that needed to be solved then I could break the algorithms into producing the sat problem and then getting a result from the solution then composing those in an IO context
23:32:55 <jakeehrlich> if you could think of a way to do that where I have no clue a priori how many different SatProblems would need to be solved then id be all for that
23:34:40 <senoj> do the algorithms you're thinking of need to make decisions (branch?) based on the SAT results?
23:35:42 <senoj> or do they have control flow that depends on the SAT results?
23:35:56 <nshepperd> jakeehrlich: I think the unsafePerformIO (createThing >>= interleaved loop) thing will work fine
23:35:59 <jakeehrlich> eh...let me think about that. I think the answer is no
23:36:14 <nshepperd> there's no reason for this to be in IO
23:36:51 <jakeehrlich> nshepperd: I'd like that to be the case but I'm of course very cautious about such things
23:36:53 <nshepperd> (also, you probably want to use a ForeignPtr for the solver state so that it can be cleaned up when we are done with the list)
23:37:30 <jakeehrlich> oh yea that's right because if I don't match end of the list that memory won't get freed!
23:39:25 <senoj> jakeehrlich: maybe you can get away with defining the FFI just the right way,
23:40:31 <senoj> but I was going to suggest another thing which is to abstract the solver results and interpret over then, so your algorithms would produce symbolic terms at the end instead of concrete results
23:40:33 <jakeehrlich> senoj: to your question about branching. currently no these algorithms don't branch but there are optimizations I could consider where they would (namely cases where I get an unsat core back)
23:40:45 <senoj> then at that point you can do all the IO you want and evaluate the terms
23:41:36 <jakeehrlich> right, produce a structure which defines how to call the sat solver in order to in order to solve the problem
23:41:56 <senoj> yeah, something like that :)
23:42:13 <senoj> probably just using the FFI in the right way is the best thing to do here
23:42:20 <jakeehrlich> so I could do that I would just have to interpret over a preety extensive language (one that included branching)
23:42:30 <senoj> and you get your pure solver function
23:42:38 <jakeehrlich> what do you mean by using the FFI the right way?
23:42:59 <senoj> what nshepperd said
23:43:33 <jakeehrlich> you mean unsafePerformIO wraped over and interleaved computation?
23:44:01 <senoj> I was looking for an example just now.. but my google-fu failed
23:44:06 <jakeehrlich> that setup makes a lot of sense to me. I can't see why it would be wrong
23:44:25 <jakeehrlich> but is also scares me
23:44:37 <jakeehrlich> I'm like 90% confident in it
23:44:54 <senoj> I guess I meant just defining the FFI functions in IO and then doing what you just said
23:45:18 <senoj> I think the main thing to worry about is order of evaluation
23:45:34 <jakeehrlich> aight. I think I'll go with that and pray that the black magic all works out properly
23:45:47 <senoj> it's a risky business :)
23:45:48 <jakeehrlich> I'll keep a very carful eye on evaluation for sure
23:45:49 <senoj> good luck
23:45:57 <jakeehrlich> yikes...I'll need it
23:46:02 <jakeehrlich> Thanks so much guys!
23:46:09 <senoj> night!
23:46:13 <jakeehrlich> night!
