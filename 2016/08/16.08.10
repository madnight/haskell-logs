00:00:10 <ackpacket> No complaints, just thought I'd ask though.
00:03:07 <mw> I don't know if it's free, don't think so(I got the paperback), but I really "enjoyed real world haskell", still use it for referencing
00:03:19 <dysfun> it's free online
00:03:30 <mw> right!
00:03:41 <dysfun> and yes, it's a very good book
00:04:06 <dysfun> the online version is actually better than the paper (which i can see out of the corner of my eye is very tattered in my case) because it's more up to date and has comments from users
00:04:17 <ski> ackpacket : people in #haskell-beginners would probably suggest <http://bitemyapp.com/posts/2014-12-31-functional-education.html>,<https://github.com/bitemyapp/learnhaskell>,<http://haskellbook.com/>
00:04:31 <dysfun> haskellbook is most definitely not free
00:04:37 * ski nods
00:05:09 * ski recalls when YAHT was suggested
00:05:18 <kadoban> The cis194 stuff recommended in the second link is though. If you're doing lyah ... that's at least better, at the very least doing that in addition to LYAH, which has no exercises and thus you don't really learn a ton.
00:05:34 <ackpacket> kadoban: !
00:05:39 <ackpacket> kadoban: brother
00:05:52 <kadoban> :)
00:06:14 <ackpacket> did you go to upenn?
00:06:48 <kadoban> Naw, not at all. The upenn stuff just has their course material online, and it's fairly nice to learn from.
00:07:25 <dysfun> it's fantastic there's so much free education online now
00:07:44 <dysfun> i'm learning quantum physics from lenny susskind without having to move to the US
00:07:49 <ackpacket> It's silly how guarded knowledge has been historically.
00:08:35 <dysfun> apparently pythagoras led a secret cult and all we know of his maths was what was leaked. some of the leakers were killed
00:10:51 <troydm> Cale: I've just calculated and sum of all characters in all bytestring is 32208908 which is roughtly 32mb if it's using utf-8 character encoding or 64mb if it's utf-16 but since I'm using encodeUtf8 function in order to create bytestring from Text then it's probably should be somewhere 32mb+ 
00:11:05 <ski> telling people about irrational numbers was an embarrassment
00:11:23 <troydm> Cale: now the question is how something that should only occupy 32mb+ of memory actually blows into something that is over 800mb
00:11:53 * ski idly wonders whether this was after the move from Croton
00:12:33 <troydm> Cale: I've tried removing bytestring entirely and entire memory usage of application is 120mb so that means that actually those strings occupy roughtly 800-900mb since with those strings memory usage is up to 1gb 
00:14:33 <ackpacket> What I didn't like about learn you a haskell is that it went through imo way too much information that I could get as-needed.  Telling me about native datatypes, lists, tuples, and then telling me how to define a function and args, -- Great.  I can look up useful functions that are already built in later.  But it went through first, last, tail, head, repeat, etc. etc.  
00:15:15 <troydm> Cale: anyway I'm adding latest changes as commit to the code so you could see it for yourself
00:31:25 <ski> gfixler : in terms of Haskell, `(>--->) :: K -> K -> *', where `K' is an arbitrary kind of "object labels". in the above case, `data K = Star' would suffice, together with `data (>--->) :: K -> K -> * where MkMor :: Integer -> (Star >---> Star)' (well, you'd have to rename `>--->' to something that Haskell accepts)
00:31:39 <dysfun> ackpacket: yeah i found the same, but i've been using list functions for many years now, so i'm not gonna judge it too harshly given it's an introductory text
00:31:43 <ski> (that may be unintelligble, if you haven't seen GADTs before ..)
00:32:01 <dysfun> ski: i have and it still was
00:33:17 <ski> here, the data constructor `MkMor' converts an `Integer' into a morphism from `Star' to `Star'
00:33:24 <ski> you'd also define
00:34:14 <ski>   id :: obj >---> obj
00:34:20 <ski>   id = MkMor 0
00:34:52 <ski>   (.) :: (obj1 >---> obj2) -> (obj0 >---> obj1) -> (obj0 >---> obj2)
00:35:04 <ski>   MkMor m . MkMor n = MkMor (m + n)
00:36:05 <ski> (these are defined to be fully polymorphic, for all possible objects, `obj', respectively `obj0',`obj1',`obj2' .. in this case, the only possible object is `Star', though)
00:36:51 <ski> dysfun : gfixler was struggling with categories, specifically how a monoid may be viewed as a category
00:37:04 <dysfun> ah
00:37:45 <ski> (asked in ##math, but i figured i'd keep the in-terms-of-Haskell part of the answer in here)
00:38:00 <dysfun> heh
00:38:02 <dysfun> that's why i'm confused
00:53:43 <nure> t-test
01:02:41 <kamyar> Hello there
01:02:49 <kamyar> I haev a question
01:02:54 <kamyar> I have a question
01:03:06 <ongy> kamyar: then ask
01:03:18 <kamyar> stripping an executable on *x OS is easy:
01:03:21 <kamyar> strip *
01:03:38 <kamyar> but on Windows there is no default strip command/binary available
01:03:45 <kamyar> they say it depends on compiler
01:04:04 <kamyar> I need to strip some exe compiled using GHC on windows
01:04:14 <kamyar> BTW I have used both strip and upx 
01:04:20 <kamyar> and I want do the same in Windows
01:05:16 <dysfun> http://paste.lisp.org/+6WYW # freer is confusing me again, any hints?
01:10:12 <suzu> kamyar: is this related to haskell or ghc?
01:10:34 <suzu> oh sorry i did not read that properly
01:10:56 <suzu> you may be able to install strip via cygwin?
01:11:23 <dysfun> you're assuming that strip can read windows binaries
01:11:36 <suzu> oh yeah i'm dumb
01:11:42 <geekosaur> they are correct about it depending on compiler, because microsoft's compiler uses a different symbol table (and untl recently it was proprietary so cygwin/msys had to roll their own symbol table stuff)
01:11:53 <suzu> yep
01:12:23 <geekosaur> but as ghc on windows is generally msys2 based, a strip for msys2 should work. upx, I wouldn't know offhand
01:12:52 <geekosaur> or for cygwin because they're broadly compatible
01:18:11 <koz_> Is there a concise way to write 'bimap f g' in lens?
01:18:32 <koz_> (yes, officially, lens is a language)
01:31:58 <Jinxit> koz_: "over both" or something?
01:32:34 <cocreature> Jinxit: that only works if both parts are of the same type
01:32:47 <Jinxit> aha
01:33:18 * hackagebot glabrous 0.1.0.0 - A template library  https://hackage.haskell.org/package/glabrous-0.1.0.0 (MichelBoucey)
01:36:54 <kamyar_> geekosaur: Thanks. I will try
01:39:03 <Hi-Angel> Does "do" have a type? I.e. why is `do do do do do do do 42` a valid Haskell ?
01:39:50 <kadoban> 'do' is syntax, it does not have a type.
01:39:55 <dramforever> Hi-Angel: Because do x = x
01:40:12 <mfukar> :t do 42
01:40:13 <lambdabot> Num a => a
01:40:16 <dramforever> Sequencing together one action is equivalent to just that action
01:40:34 <Hi-Angel> Ah, hm, thank you
01:40:50 <dramforever> https://www.haskell.org/report/node/2010/haskellch3.html#x8-470003.14
01:41:14 <dramforever> See the "Translation" box
01:42:35 <Hi-Angel> Cool, thank you!
01:48:59 <Hi-Angel> dramforever, what does mean "do {e;stmts}" in the translation box? I thought it'd be equiualent to "do {42; print "hello"}", but in GHCi it triggers an error
01:49:54 <absence> Hi-Angel: 42 >> print "hello" doesn't type check
01:50:00 <absence> :t (>>)
01:50:01 <lambdabot> Monad m => m a -> m b -> m b
01:50:22 <Hi-Angel> Hmm
01:50:24 <absence> Hi-Angel: both sides need the same monad instance
01:50:41 <absence> print "hello" has IO, while 42 has none
01:51:05 <absence> Hi-Angel: try do { pure 42; print "hello" } instead
01:51:24 <Hi-Angel> Thank you, I see, I think I was confused because "do 42" worked, which was in the translation box as "do {e}"
01:51:26 <absence> Hi-Angel: (also, you might want putStrLn instead of print)
01:51:28 <Unhammer> This list fusion stuff, is there a simple way to see if it's being performed by ghc?
01:52:02 <Axman6> do {x} gets turned into x before it is type checked
01:52:13 <absence> Hi-Angel: yes, do x = x, but do { x; y } = x >> y, so it's the requirements from >>'s type that causes error
01:52:32 <Axman6> Unhammer: GHC can spit out info about rules which have fired
01:52:38 <Unhammer> from the manual, it seems "map (\a -> a+1) $ filter even [1..]" should turn into a single filtermap, but how do I know if it'll still work if I put in a Data.List.takeWhile there …
01:53:24 <ReinH> Unhammer: look at the core
01:54:10 <Unhammer> aha, thanks Axman6, https://downloads.haskell.org/~ghc/7.4.2/docs/html/users_guide/rewrite-rules.html looks like what I need :)
01:54:17 <ReinH> Unhammer: Also,http://conscientiousprogrammer.com/blog/2015/12/19/24-days-of-hackage-2015-day-19-ghc-core-html-list-fusion-probe-checking-ghcs-fusion-rewrite-rules-for-erasing-intermediate-data-from-existence/
01:54:24 <Unhammer> ReinH,  but then I have to learn how ot read Core first :-S
01:54:28 <ski> @undo do { pure 42; print "hello" }
01:54:28 <lambdabot> pure 42 >> print "hello"
01:54:59 <ReinH> ignore the weirdness with & and >>>
01:55:08 <Unhammer> oh, nice
01:56:10 <ReinH> @hackage list-fusion-probe
01:56:10 <lambdabot> http://hackage.haskell.org/package/list-fusion-probe
01:57:25 <ReinH> Unhammer: also the rules themselves are well documented http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#map
01:58:39 <ReinH> takeWhile has its own rules http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.List.html#takeWhile
02:00:04 <dramforever> Hi-Angel: syntactic translation and type checking are fully separate processes
02:02:15 <LordBrain> you couldnt do 42 actually, you'd need return... unless you have a num instance for your monad or something
02:02:42 <Unhammer> aha, looks like my base-4.7.0.2 takewhile has no rules https://hackage.haskell.org/package/base-4.7.0.2/docs/src/GHC-List.html#takeWhile
02:02:48 <Unhammer> guess I should upgrade :)
02:03:09 <dramforever> :t do 42 -- LordBrain: Nope
02:03:10 <lambdabot> Num a => a
02:03:40 <LordBrain> hmm
02:03:47 <LordBrain> reader monad?
02:04:20 <LordBrain> or does do not imply a monad any more?
02:04:59 <ReinH> Unhammer: at least to GHC 7.10, yeah
02:05:44 <LordBrain> shouldn't it be (Monad a, Num a)=> a
02:05:55 <LordBrain> or wait tahts not even the same kind
02:05:55 <ReinH> > do () == ()
02:06:00 <lambdabot>  mueval-core: Time limit exceeded
02:06:07 <ReinH> I don't believe you.
02:06:16 <Axman6> D:
02:06:23 <ReinH> > do () == ()
02:06:25 <lambdabot>  True
02:06:28 <ReinH> lambdabot pls
02:06:56 <ReinH> do x = x, no Monad constraint.
02:07:36 <LordBrain> is this semantics new? or have i just been overlooking something
02:07:47 <ReinH> No, it's been this way
02:08:01 <LordBrain> well, how did i get the impression monad was implied
02:08:06 <LordBrain> any clue?
02:08:33 <ReinH> other patterns desugar via monad ops, thus incur a monad constraint
02:08:43 <ReinH> e.g., do { e; exprs }
02:09:00 <ski> > let () = case () of {} in [do let {}; let in () | let]
02:09:02 <lambdabot>  [()]
02:09:06 <Axman6> :t \x -> do x
02:09:08 <lambdabot> r -> r
02:09:17 <LordBrain> so any multi line do block implies monad?
02:09:19 <Axman6> :t \x -> do {x;x}
02:09:22 <lambdabot> Monad m => m b -> m b
02:09:25 <ReinH> ski: wat
02:09:48 <ski> @type \x -> do {let {}; x}  -- LordBrain, no
02:09:50 <lambdabot> r -> r
02:10:03 <LordBrain> well...
02:10:26 <LordBrain> bindings asside
02:10:45 <LordBrain> so not counting let {} 
02:11:38 <LordBrain> the key is the bind is between lines, and you need the bind to imply the monad
02:12:19 <LordBrain> so if you only have one, there's no bind operation, no >> either, so you get no monad constraint
02:12:26 <ski> @undo do {ma; mb}
02:12:26 <lambdabot> ma >> mb
02:12:36 <ski> @undo do {a <- ma; amb a}
02:12:36 <lambdabot> ma >>= \ a -> amb a
02:12:41 <LordBrain> sorry for working my brain so publicly
02:13:11 <ski> the key is the occurence of `>>' and `>>=' in those two expansions
02:13:14 <LordBrain> yeah
02:13:27 <LordBrain> i figured it out
02:13:41 <ski> ReinH : silliness ..
02:13:49 <ReinH> ski: quite
02:18:04 <absence> will the semigroup monoid proposal eventually fix the monoid instance for Maybe so Data.Semigroup.Option isn't needed, or is that a compatibility nightmare?
02:20:50 <ashishnegi> hello.. i am generating `arbitrary` Position which are (Int, Int) but they need to be less than `some value` which i get at run-time. How can i write `arbitrary` for Position ? Any docs.
02:24:26 <Unhammer> -ddump-rule-rewrites was nice, but no line numbers makes it a bit hard to interpret :/
02:25:04 <kadoban> ashishnegi: Arbitrary is really just for QuickCheck testing, I wouldn't think you should be using it for much else. That sounds like a totally different thing?
02:25:32 <kadoban> Also I don't think you can do that, have it be based on a run-time value.
02:26:57 <dramforever> Hmm
02:27:18 <dramforever> Fancy way to get name shadowing behaviour for let's without nesting!
02:27:30 <ski> ashishnegi : what does this "some value" signify (for naming purposes) ?
02:27:35 <dramforever> Oh wait it does not. Never mind
02:28:51 <ashishnegi> ski: I have a GameConfig with `width` and `height`.. i have `arbitrary` for GameConfig and then i generate list of `Players` using arbitrary. But positions of Players should be with in `width` and `height`. How does `arbitrary` get those values ?
02:29:07 <ashishnegi> ski:  You want to see the code.. ?
02:30:10 <dramforever> ashishnegi: You can generate properties from the Gen monad and test that
02:30:17 <dramforever> http://hackage.haskell.org/package/QuickCheck-2.9.1/docs/Test-QuickCheck.html#t:Testable
02:30:24 <Axman6> you should be able to qrite quickcheck tests which make use of the Arbitrary machinery without writing Arbitrary instances
02:30:33 <dramforever> see the Testable prop => Testable (Gen prop)
02:30:57 <ashishnegi> ski: yes doing that.. i guess `Arbitrary` is for Gen .. right ? please see https://github.com/nilenso/tronkell/blob/master/test/TestEngine.hs#L30 
02:31:14 <ashishnegi> dramforever: please see above comment
02:31:55 <ski> ashishnegi : hm, i was thinking about instead generating `GameConfig -> Position' ..
02:32:14 <dramforever> You would need to skip Arbitrary if you need an extra argument
02:32:25 * ski tries to figure out whether this will run into a certain problem, or if it can be circumvented
02:32:36 * dramforever thinks that (Gen prop) is the way to go
02:32:51 <ashishnegi> dramforever: "skip" means not possible.. ?
02:33:08 <dramforever> Means you don't use it
02:33:20 * hackagebot x86-64bit 0.1.3 - Runtime code generation for x86 64 bit machine code  https://hackage.haskell.org/package/x86-64bit-0.1.3 (PeterDivianszky)
02:33:40 <ski> ashishnegi : Axman6's suggestion is probably most practical here. iow define your generation of `Position' in a local scope where `width' and `height' are available
02:33:41 <dramforever> Like you "skip" explaining English to a Chinese, when you want to talk to the Chinese, because you can speak Chinese too
02:34:41 <ski> (or, probably better, factor it out into a separate function, `arbitraryPosition :: GameConfig -> Gen Position', and call that explicitly, using `forAll')
02:35:07 <dramforever> Whoa
02:35:12 <dramforever> TIL about forAll
02:35:55 <ashishnegi> thanks ski dramforever Axman6
02:36:16 <ski> (`Gen' is a monad after all .. i suppose i was thinking more idiomatically)
02:37:06 <dramforever> ski: That must be exactly what forAll is for
02:37:06 <ski> dramforever : hm, that's also a nice idea to be aware of
02:37:24 <dramforever> I suppose the failure messages would be horrible
02:37:26 <ski> (`Testable prop => Testable (Gen prop)')
02:37:44 <acrofus> clear
02:40:33 <ski> @check \x y -> not x || y
02:40:36 <lambdabot>  *** Failed! Falsifiable (after 6 tests):
02:40:36 <lambdabot>  True False
02:40:37 <ski> @check \x -> forAll (elements [minBound .. maxBound]) $ \y -> not x || y
02:40:39 <lambdabot>  *** Failed! Falsifiable (after 2 tests):
02:40:39 <lambdabot>  True False
02:40:52 <ski> failure message looks ok
02:41:24 <ski> hmm
02:55:58 <XOCKET> test
02:58:15 <angryShiva> sup!
02:59:09 <angryShiva> what do you guys think of Haskell Programming from First principles (by Chris Allen & Juli Moronuki) ?
02:59:27 <angryShiva> a friend asked for a good book to learn haskell from
02:59:47 <peddie> angryShiva: I've basically heard only good things about it
02:59:57 <maerwald> peddie: heard?
02:59:58 <angryShiva> sweet! 
03:00:10 <maerwald> have you actually read it?
03:00:19 <peddie> maerwald: no, I haven't, that's why I said I heard good things
03:00:27 <angryShiva> i've had to bounce between textbooks way too often
03:00:33 <peddie> maerwald: or, sorry, maybe I misunderstood your question?
03:00:39 <angryShiva> heard that this book was really good.
03:00:49 <maerwald> I only recommend or don't recommend learning material I actually have read/used myself
03:00:54 <peddie> OK
03:01:26 <peddie> angryShiva: if it wasn't clear, I haven't read this book myself
03:01:47 * dysfun certainly couldn't recommend something with the price tag of that book without reading it
03:02:35 <peddie> lol, OK, well, you guys don't have to give any opinions then :P
03:02:41 <mudkip3> I only buy books that I've read and enjoyed
03:04:11 <Hi-Angel> angryShiva, why not "Learn You a Haskell for Great Good!"? I've read it, and I can say it is good.
03:04:17 <maerwald> oh please no
03:04:21 <Hi-Angel> Why?
03:04:36 <maerwald> it's one of the most terrible learning resources out there that has way too much popularity
03:05:23 <peddie> angryShiva: I read LYAH and thought it was borderline useless
03:05:43 <dysfun> it's funny how many people who know haskell think they know how to teach it better than everyone else, and yet people still struggle learning haskell
03:06:57 <maerwald> yes, because most haskellers wrongly think learning haskell is easy, because they like to forget how hard it was for them
03:07:50 <dysfun> i don't know. my issues with LYAH were that it spent way too long on stuff i already knew because of my background
03:08:00 <kadoban> angryShiva: HPfFP seems good to me. I've read ... much of it, and one of my friends is learning from it and making good progress. (I've known haskell for a while, just read parts for fun)
03:08:04 <Hi-Angel> I must say, the best way to learn would reading a bunch of not tied resources. 
03:08:35 <maerwald> I could write a whole blog post why LYAH sucks, but let's just stick to the main point: NO exercises.
03:08:47 <maerwald> without execises you don't learn anything
03:08:58 <dysfun> it encourages you to test stuff in the repl
03:09:07 <maerwald> those are not exercises really
03:09:14 <maerwald> you can learn LaTeX that way, but not haskell
03:09:19 <Hi-Angel> E.g. I've read Bartosz's posts on Category Theory, and I thought it is bad. But it isn't! I didn't find anything better, but reading his blog posts thrid time, after other books, I must say, everything much clearer
03:09:58 <kadoban> dysfun: That's not near enough, that's not an exercise at all really.
03:11:47 <dysfun> or we could accept that different people learn differently
03:12:27 <kadoban> That doesn't change the definition of an exercise, or change the fact that some learning materials are better than others.
03:12:54 <dysfun> 'better' is subjective. 'better for people who learn like i do' is more accurate
03:13:18 <kadoban> Okay then.
03:13:27 <koz_> Could someone tell me how to use runParser and co from optparse-applicative inside of IO?
03:13:32 <koz_> I'm a bit confused by all the arguments.
03:14:23 <av_> my algorithm slows down by a factor of 4 when I enable polymorphism, either by removing the monomorphism restriction with a pragma or by using AD on it -- why is this, and is there a good way of avoiding this?  It's the same in ghc 7.10.3 and 8.0.1, both with -O2.
03:15:14 <angryShiva> guys, thanks a lot for the input! Unfortunately, I have to leave
03:15:23 <angryShiva> Would someone help koz_
03:15:45 <dysfun> if someone knows the answer, i'm sure they will share
03:18:54 <Gurkenglas> koz_, what exact type signature would you like to have implemented for you?
03:19:46 <koz_> Gurkenglas: Basically, I have a Parser Foo. I wanna be able to use it inside of main to parse command-line arguments into a Foo.
03:19:53 <koz_> I'm not sure what to use to do this.
03:20:19 <Robin_Jadoul> koz_: have you looked at execParser?
03:20:20 <Gurkenglas> If this has nothing to do with IO, you can use a let statement to do pure computations in a do block
03:20:42 <koz_> Robin_Jadoul: Which part of optparse-applicative is that in?
03:20:55 <Robin_Jadoul> koz_: https://hackage.haskell.org/package/optparse-applicative-0.12.1.0/docs/Options-Applicative-Extra.html
03:21:26 <Robin_Jadoul> koz_: it should be simply imported from Options.Applicative
03:21:30 <cocreature> yeah execParser is how you typically use optparse-applicative
03:22:00 <koz_> cocreature and Robin_Jadoul: Thanks - will read!
03:22:44 <koz_> How does one get a ParserInfo from a Parser?
03:23:21 <cocreature> info
03:23:34 <cocreature> koz_: the description here https://hackage.haskell.org/package/optparse-applicative contains a minimal example
03:24:14 <koz_> OK, time to do more reading...
03:24:27 <lyxia> angryShiva: Polymorphic values with typeclass constraints prevent some optimizations. The Inline and Specialize pragmas help here.
03:26:42 <humanoyd> In order to understand comonads I was going through http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html...am I correct that the proposed rule `not (a && b && not c || (a==b))` could be rewritten as simply `not (a==b)`?
03:29:41 <lyxia> @check \a b c -> (a && b && not c || a == b) == (a == b)
03:29:43 <lambdabot>  +++ OK, passed 100 tests.
03:30:40 <ski> > all (\[a,b,c] -> not (a && b && not c || (a==b)) == not (a==b)) (replicateM 3 [False,True])
03:30:43 <lambdabot>  True
03:32:04 <lyxia> oh right, if a and b are different, then a && b is false...
03:33:34 <humanoyd> lyxia: ski thanks
03:34:21 <ski> > filter (not . \[a,b,c] -> not (a && b && not c || (a==b)) == not (a==b)) (replicateM 3 [False,True])  -- variation
03:34:23 <lambdabot>  []
03:35:53 <humanoyd> ski: I guess `replicateM` is what I was looking for
03:37:33 <Gurkenglas> Whats the difference between ghc-mod and ghc-modi?
03:39:23 <dysfun> the same as between ghc and ghci?
03:40:00 <Gurkenglas> Ah, thanks.
03:41:04 <ski> @hoogle Applicative i => Int -> i a -> i [a]
03:41:04 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
03:41:04 <lambdabot> Test.QuickCheck.Gen vectorOf :: Int -> Gen a -> Gen [a]
03:41:04 <lambdabot> Test.QuickCheck vectorOf :: Int -> Gen a -> Gen [a]
03:43:36 <Gurkenglas> Why is stack install only using one CPU?
03:44:10 <Gurkenglas> (I think so because in the task manager it never goes above 25%)
03:44:21 <Gurkenglas> (ghc, that is)
03:48:22 * hackagebot x86-64bit 0.1.4 - Runtime code generation for x86 64 bit machine code  https://hackage.haskell.org/package/x86-64bit-0.1.4 (PeterDivianszky)
03:48:26 <kamyar> geekosaur: It worked like a charm! Thanx! Just installed msys base and strip worked on my GHC compiled exe file.
03:50:04 <humanoyd> Is there a local version of lambdabot?
03:50:43 <liste> humanoyd: what features do you need?
03:53:03 <humanoyd> liste: all of them :) ... no, but @check and @hoogle would suffice for the moment
03:53:41 <liste> humanoyd: you can install hoogle
03:53:42 <kadoban> hoogle has a CLI thing. @check I dunno
03:55:55 <geekosaur> lambdabot is on hackage and "installable" but it's anything but friendly to set up
03:56:34 <geekosaur> as for @check, probably install QuickCheck and use ghci or ghc -e
04:13:19 <Gurkenglas> https://github.com/atom-haskell/haskell-ghc-mod/issues/86#issuecomment-170327712 sounds like what I need from the http://lpaste.net/8338504114115706880 atom is giving me. How do I go about removing old ghc versions? Where are they?
04:15:26 <Gurkenglas> (Actually https://github.com/atom-haskell/haskell-ghc-mod/issues/86#issuecomment-219962251 looks closer with all the lookupComponentId and lookupInstalledPackageId stuff ill try "building ghc-mod from master"
04:15:29 <Gurkenglas> *)
04:21:19 <koz_> OK, my custom positive number parser seems to not like positive numbers.
04:22:35 <cocreature> koz_: you just need to rebrand it as a parser for something else
04:22:40 <lpaste> koz_ pasted “Confused about custom ReadM instance” at http://lpaste.net/175549
04:23:23 * hackagebot credentials 0.0.1.1 - Secure Credentials Storage and Distribution  https://hackage.haskell.org/package/credentials-0.0.1.1 (BrendanHay)
04:23:25 * hackagebot credentials-cli 0.0.1.1 - Secure Credentials Administration  https://hackage.haskell.org/package/credentials-cli-0.0.1.1 (BrendanHay)
04:24:16 <cocreature> koz_: you need to parse the string from the environment of ReadM not parse a string you pass yourself
04:24:39 <absence> will the semigroup monoid proposal eventually fix the monoid instance for Maybe so Data.Semigroup.Option isn't needed, or is that a compatibility nightmare?
04:24:49 <koz_> cocreature: I don't quite follow, sorry.
04:25:01 <koz_> I wrote this based on the example from the optparse-applicative GitHub page.
04:27:51 <cocreature> koz_: the difference is that your parser has type String -> ReadM Int and you’re passing your string argument. however ReadM is already a wrapper around String -> Except a, so you end up with String -> String -> Except a. but you completely ignore the second string argument that you should be parsing.
04:28:17 <cocreature> koz_: try using eitherReader like the code in the github readme is doing
04:28:59 <Gurkenglas> Building ghc-mod from master (to fix cryptic atom errors) is not going well: it needs old-time so cabal wont do it on windows and stack says http://lpaste.net/2569182383437774848
04:31:21 <cocreature> Gurkenglas: you are building a ton of packages that you shouldn’t build.you should only add . to packages
04:31:31 <Gurkenglas> koz_, does it like negative numbers? "readMay (show s)" will first show the string, then try to read that as an integer
04:31:41 <Gurkenglas> "you should only add . to packages" i dont follow
04:31:48 <cocreature> packages is a list of directories
04:31:51 <cocreature> . is the current directory
04:32:02 <cocreature> but stack init searches for all cabal files
04:32:13 <cocreature> and there are a shitload of cabal files in there
04:32:23 <cocreature> but none of those are of interest if you want to bulid ghc-mod
04:33:03 <cocreature> don’t ask me why ghc-mod decided to add every cabal file they ever used to their repo
04:33:03 <Gurkenglas> how do i tell stack init to only use .?
04:33:18 <cocreature> you could try --ignore-subdirs
04:33:26 <cocreature> but once stack init fails I just write the yaml file myself
04:33:33 <cocreature> you only need two or three lines anyway
04:33:43 <cocreature> resolver and packages
04:33:53 <Gurkenglas> im reading "the password is only two or three lines long" :D
04:34:14 <cocreature> where did you manage to find the word “password”? :)
04:34:57 <Gurkenglas> it was an association from needing to write a config file correctly so the compiler would stop giving me walls of text
04:35:08 <cocreature>  try http://lpaste.net/175550
04:35:10 <cocreature> (untested)
04:35:56 <Gurkenglas> stack init --ignore-subdirs: http://lpaste.net/2245220460658688000
04:37:03 <cocreature> you need to add a newer haskell-src-exts to extra-deps
04:37:53 <Gurkenglas> Using that .yaml: http://lpaste.net/5982671112960475136
04:38:40 <Gurkenglas> I heard that stack solver adds needed extra-deps, but in this case it gives the same error from the previous line
04:40:07 <cocreature> Gurkenglas: try an older resolver, e.g. 2016-08-06 seems to exist and add haskell-src-exts with the appropriate version to extra-deps
04:40:45 <Gurkenglas> didnt stack init --ignore-subdirs do that binary resolver search already?
04:40:56 <koz_> Gurkenglas: It insists that both negative and positive numbers are not integers.
04:41:22 <koz_> OK, I'll change to the Either-based one.
04:41:27 <koz_> Thanks for that.
04:41:32 <cocreature> Gurkenglas: stack init failed and didn’t output anything because there is no snapshot containing a new enough haskell-src-exts
04:41:32 <Gurkenglas> > readMaybe "2" --koz_
04:41:34 <lambdabot>  Not in scope: ‘readMaybe’
04:43:29 <Gurkenglas> > (readMaybe "2" :: Maybe Int, readMaybe (show "2") :: Maybe Int, "2", show "2") -- koz_ (you post a lambdabot line without testint just once...)
04:43:31 <lambdabot>  (Just 2,Nothing,"2","\"2\"")
04:46:24 <koz_> Gurkenglas: The only reason that 'show' is there is because readMay from BasicPrelude uses Text, not String.
04:48:28 <Gurkenglas> ( stack init --ignore-subdirs --solver --force: http://lpaste.net/1698422796905873408 )
04:49:19 <koz_> Gurkenglas: If I remove show, it fails to compile...
04:49:24 <TCZ>  :/
04:49:37 <Gurkenglas> Using 2016-08-06: http://lpaste.net/9057961954248753152
04:50:30 <cocreature> gabiruh: I’m repeating myself but you need to add a newer version of haskell-src-exts to extra-deps
04:50:35 <cocreature> eh *Gurkenglas
04:50:46 <Gurkenglas> Oh right soz
04:51:10 <Gurkenglas> koz_, go to ghci and see if you can find any just expression of the form 'readMay "<something here>" :: Maybe Int'
04:51:25 <koz_> Gurkenglas: OK, shall try.
04:51:44 <Gurkenglas> umm 'readMay (show "<something here>") :: Maybe Int'. Or maybe even 'readMay <something here> :: Maybe Int'.
04:53:24 * hackagebot apiary-http-client 0.1.3.0 - A http client for Apiary.  https://hackage.haskell.org/package/apiary-http-client-0.1.3.0 (winterland)
04:53:26 <koz_> Gurkenglas: 'readMay "10" :: Maybe Int' works.
04:53:42 <Gurkenglas> with and without 1.18 extra dep: http://lpaste.net/1998569800338505728 looks like solver was right?
04:55:35 <ocharles> Can anyone make any sense from the linker error: "Types.cpp:(.text+0x0): multiple definition of `inline_c_Types_0_f269dbf42a0b9ce069a8429e00c0be08cdbb21f9'" ? I'm using the inline-c library, full paste at https://gist.github.com/ocharles/566ae662250371c1afc31042ef7c98a6
04:55:44 <Gurkenglas> koz_, wait if readMay uses Text, how can you pass it something coming from show? show produces Strings right?
04:56:00 <koz_> Gurkenglas: show :: Show a => a -> Text
04:56:04 <koz_> (as per BasicPrelude)
04:56:29 <Axman6> ocharles: Types.cpp? what's going on there?
04:56:43 <ocharles> inline-c is generating that file
04:56:48 <Axman6> ah right
04:57:01 <ocharles> If you refresh the gist, I've added that file
04:57:08 <Gurkenglas> koz_, what's (show "10") and (readMay (show "10") :: Maybe Int) in ghci?
04:57:13 <cocreature> ocharles: how are you compiling?
04:57:21 <ocharles> with cabal build, let me just add my cabal file
04:57:38 <ocharles> Updated
04:58:14 <geekosaur> somehow it's getting linked in twice
04:58:17 <koz_> Gurkenglas: show "10" :: Text and readMay (show "10") :: Maybe Int :: Maybe Int respectively.
04:58:19 <ocharles> ViewerHs.hs has plenty of inline-c which is working perfectly
04:58:28 <ocharles> It's only when I've added this extra module in things have got a bit weird
04:58:32 <Gurkenglas> koz_, not the types, the values ghci gives back :D
04:58:51 <koz_> Gurkenglas: "\"10\"" and Just 10 respectively.
04:59:21 <koz_> Are those quotes throwing readMay?
04:59:27 <ocharles> geekosaur: The end of the `ghc --make` command `cabal build` is running is: -XHaskell2010 ./ViewerHs.hs dist/build/receiving-station/receiving-station-tmp/ViewerHs.o dist/build/receiving-station/receiving-station-tmp/Types.o -o dist/build/receiving-station/receiving-station -threaded
04:59:33 <ocharles> Which looks correct to me
04:59:49 <Gurkenglas> koz_, apparently not, Just 10 works fine. I think the quotes are coming from ghci converting the text back to a string to show it to you
05:00:15 <koz_> Gurkenglas: Now I'm *really* confused...
05:00:20 <Axman6> ocharles: no idea what the solution is, but I like the C'Foo convention, did you come up with that?
05:00:21 <Gurkenglas> so am i
05:00:33 <Gurkenglas> This looks like your parser should be working
05:00:38 <ocharles> Axman6: Nah, I have seen it somewhere else, but I also like it :)
05:00:48 <Gurkenglas> put a trace in front of each of the three relevant lines koz_ 
05:01:19 <Gurkenglas> (as in import Debug.Trace, then use trace "1" etc. or perhaps traceShowId)
05:01:42 <KB5> Hello. I am new to Haskell and I started learning from the work-in-progress book called Programming Haskell. In the book's chapter 4.2, it has a following exercise: http://pastebin.com/nC763mxA Unfortunately it seems as if solution to this exercise requires something that hasn't been covered in the book yet, since I can't figure this one out.
05:01:43 <koz_> Gurkenglas: Alrighty, I'll try that, but it'll have to be tomorrow. I need sleep - early start.
05:02:42 <ocharles> Very strange. If I move 'newMat' and 'withMat' to ViewerHs.hs, it all works fine
05:03:00 <ocharles> maybe inline-c doesn't work with 'executable' targets
05:03:09 <Axman6> KB5: are you getting any errors?
05:03:19 <koz_> Gurkenglas: You may be interested to know that 'readMay (show "10") :: Maybe Int' gives 'Nothing'.
05:03:21 <Gurkenglas> koz_, also try between the return and the x and perhaps other places
05:03:29 <Kneiva> KB5: what have you tried?
05:03:30 <ski> the pasted code is erroneous
05:03:35 <zoran119> i have a function with signature f :: Int -> State [Int] Int, is it possible to rewrite this in terms of StateT?
05:03:36 <cocreature> ocharles: I’m pretty sure it does. I have a testsuite that uses it and from a linking statepoint these should be equivalent to executables
05:03:37 <Gurkenglas> koz_, what but you said otherwise above
05:03:45 <ocharles> cocreature: hm
05:03:52 <Gurkenglas> "<koz_> Gurkenglas: show "10" :: Text and readMay (show "10") :: Maybe Int :: Maybe Int respectively." "<koz_> Gurkenglas: "\"10\"" and Just 10 respectively."
05:03:59 <cocreature> ocharles: might be worth a try to run cabal with -v3 and look at the linking step
05:04:04 <koz_> Gurkenglas: I *must* be tired...
05:04:05 <zoran119> i'm under this impression that any monad signature can be expressed in terms of its transformer... not sure if that correct
05:04:45 <lpaste> koz_ pasted “My current run” at http://lpaste.net/175552
05:04:49 <Axman6> zoran119: State is implemented as type State s a = StateT s Identity a, so yes
05:04:56 <koz_> Gurkenglas: ^
05:04:58 <KB5> Kneiva: Well, I couldn't figure out what I should be trying given the signature Mood -> Mood. But I tried to if-then-else, but that changes the signature.
05:05:14 <KB5> Though if-then-else isn't covered in the book yet
05:05:29 <KB5> Neither is pattern matching or case, so...
05:05:29 <Robin_Jadoul> KB5: Did the book cover pattern matching yet?
05:05:29 <Axman6> KB5: what about pattern matching? has that been covered?
05:05:30 <zoran119> Axman6: i noticed that, but the Identity bit is confusing me
05:05:41 * ski isn't quite sure how KB5 tried `if'-`then'-`else'
05:05:44 <ski> KB5 : have you seen the definition of e.g. boolean combinators like `not' and `(&&)',`(||)' yet ? have you heard the term "pattern matching" ?
05:05:52 <ski> hm, ok
05:06:13 <Axman6> zoran119: what is confusing about it?
05:06:17 <Gurkenglas> Okay so the quotes might be throwing it? koz_ try http://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Lazy.html#v:pack instead of show
05:06:19 <cocreature> ocharles: fwiw with a dummy ViewerHS (because I don’t have the source) it compiles just fine
05:06:24 <Axman6> @unmtl State s a
05:06:24 <lambdabot> s -> (a, s)
05:06:27 <koz_> Gurkenglas: OK, shall do.
05:06:33 <Axman6> @unmtl StateT s Identity a
05:06:33 <lambdabot> s -> (a, s)
05:06:33 <ocharles> cocreature: strange. I'll have a look in more detail shortly then
05:06:36 <KB5> ski: bools and not was covered in the same chapter earlier. Just not sure how do I apply bool to this exercise.
05:06:38 <Axman6> hmm
05:06:45 <Axman6> @unmtl StateT s m a
05:06:46 <lambdabot> s -> m (a, s)
05:06:48 <ocharles> cocreature: I guess sticking 'main = return ()' is what you have in ViewerHs?
05:07:08 <ski> KB5 : were any of the combinators i mentioned defined ?
05:07:11 <cocreature> ocharles: main = putStrLn "Hello world" :)
05:07:19 <ski> KB5 : you might also want to ask bitemyapp in #haskell-beginners about the disposition of the book, or possible mistakes in it
05:07:43 <KB5> ski: I sent email to them, didn't know they're on irc
05:08:48 <ski> KB5 : i was just about to say that email is probably more reliable (and they get a more tangible record to remind them, in case something needs to be fixed), but that channel can be useful as well
05:09:04 <ski> KB5 : if you have a direct link to the chapter, that would be handy
05:09:11 <KB5> I shall try there as well, thanks
05:09:13 <koz_> Gurkenglas: That fixed it - thank you!
05:09:31 <KB5> ski: well, they ask money before you can view the book
05:09:35 <ski> ok
05:09:38 <KB5> I took a gamble with the book :/
05:10:02 <koz_> Remind me to complain to the maintainer of basic-prelude that it should really include pack and unpack.
05:10:20 <ski> KB5 : how about the combinators ?
05:10:35 <Gurkenglas> koz_, where did you get the string from in the first place
05:10:47 <koz_> Gurkenglas: What string?
05:10:53 <koz_> You mean, the one being passed in?
05:10:54 <Gurkenglas> i mean the one you put into your parser
05:10:59 <koz_> Gurkenglas: Command-line argument.
05:11:07 <koz_> (I'm using optparse-applicative)
05:11:07 <KB5> ski: only not was covered so far
05:11:28 <ski> KB5 : can you repeat how it was defined ?
05:11:46 <Gurkenglas> koz_, they might tell you to use https://hackage.haskell.org/package/basic-prelude-0.5.2/docs/CorePrelude.html#v:readArgs ?
05:11:52 <KB5> ski: how was what defined?
05:11:59 <ski> KB5 : `not'
05:12:02 <Gurkenglas> Oh wait that also gives String huh.
05:12:16 * ski is looking for something KB5 has already seen, in order to have something to connect to
05:12:17 <koz_> Gurkenglas: Yeah - and readArgs is significantly less awesome than optparse-applicative.
05:12:23 <koz_> But never mind - I learned something useful today.
05:13:02 <KB5> not :: Bool -> Bool, and not True returns False, that's it pretty much
05:13:14 <ski> do you mean
05:13:16 <Gurkenglas> > foldr (.) id (replicate 5 show) $ "asd"
05:13:18 <ski>   not True = False
05:13:19 <ski> ?
05:13:19 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"asd\\\\\\\\\\...
05:13:39 <Axman6> optparse-applicative is great
05:13:44 <koz_> Axman6: I agree.
05:13:54 <koz_> I'll definitely make use of it more now that I get how the fuck it works, kinda.
05:14:00 <ski> KB5 : yes ?
05:14:04 <Axman6> configuration-tools makes it even more useful (but really needs a DSL for defining everything, there's a lot of boilerplate)
05:14:16 <KB5> I mean hat "not True" returns "False" in GHCi, without quotations marks since then they'd be strings
05:14:37 <ski> KB5 : yes. but the question was, how was `not' *defined* ?
05:16:21 <KB5> ski: I am not quite sure what you're after. not is built-in function, so it wasn't defined?
05:16:30 <Axman6> no it's not
05:16:44 <Axman6> not is just an average everyday function in Haskell
05:16:50 <dysfun> okay, i'm not even sure what ghc is telling me any more http://paste.lisp.org/+6WZ7
05:16:55 <Axman6> it has a definition you can look up
05:17:12 <ski> KB5 : ok, so i assume they only covered it in terms of how it behaves ("what it does"), but not in terms of how it's defined
05:17:43 <KB5> I did give the definition earlier though? not :: Bool -> Bool
05:18:02 <Axman6> that's the type, not the definition
05:18:12 <ski> KB5 : that's a type signature
05:18:15 <Axman6> type signature*
05:18:29 <KB5> Okay, I give up. :D
05:18:34 <ski> it specifies that the input must be a `Bool', and that the output will then be a `Bool'
05:19:03 <ski> you must have seen simple definitions of functions and (other) constants, yes ?
05:19:20 <ski> like
05:19:25 <ski>   surname :: String
05:19:32 <ski>   surname = "Haskell"
05:20:00 <ski> and
05:20:13 <ski>   circleArea :: Double -> Double
05:20:26 <KB5> Definition of bool was given as data Bool = False | True, but no definition of not
05:20:30 <ski>   circleArea radius = pi * radius^2
05:20:34 <ski> ok
05:21:13 <ski> `data' is a keyword that starts a data type definition (in this case `Bool' is the data type that was defined)
05:21:13 <lyxia> dysfun: it's telling you you have overlapping instances and ghc doesn't know which one to pick.
05:21:29 <dysfun> lyxia: that much i understood. i don't know why it has overlapping instances though
05:22:05 <ski> KB5 : the `=' symbol signifies a definition. `surname = "Haskell"' defines the name/identifier/variable `surname' to mean / refer to the string `"Haskell"'
05:22:54 <KB5> Yeah, I get that much. The exercise had a definition for type Mood.
05:23:05 <ski> KB5 : `circleArea radius = pi * radius^2' defines the function `circleArea' (which computes the area of a circle as output, when given the radius of the circle as input)
05:23:06 <defanor> an attoparsec question: having a packet format that specifies the length of the remaining packet in its header, and using incremental parsing (`parseWith`), i'd like a parser to fail once it reads more than that length without result. a simple solution would be to read that length, and then invoke parsing (e.g., `parseOnly`) from a parser itself, but that's awkward. is there a nicer way?
05:23:08 <dysfun> lyxia: i'm not entirely clear on how freer works its magic
05:23:19 <geekosaur> dysfun, remember that contexts do not take part in instance selection
05:23:25 * hackagebot yesod-core 1.4.23 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.23 (MichaelSnoyman)
05:23:27 * hackagebot yesod-test 1.5.2 - integration testing for WAI/Yesod Applications  https://hackage.haskell.org/package/yesod-test-1.5.2 (MichaelSnoyman)
05:23:31 <lyxia> dysfun: Member t r (the first one) overlaps with Member (State [Scope v w]) r which comes from the Members constraint.
05:23:55 <geekosaur> (noting that the error references a context as a possible match. in general these overlap with every other instance)
05:24:05 <ski> KB5 : it defines the function `circlArea' in *terms* of what the output `circleArea radius' should be (equal to), given any arbitrary `radius' input (namely the output is then defined to be equal to `pi * radius^2')
05:24:13 <geekosaur> (not always. it depends on what the instance looks like. but usually it
05:24:32 <geekosaur> s intended to match based on the context, and that does not work)
05:24:55 <dysfun> actually ghc told me it couldn't figure out that this context applied
05:25:02 <ski> KB5 : in traditional math notation, the definition would look like `circleArea(radius) = pi * radius^2' (with an extra pair of round brackets), but they're not needed in Haskell
05:25:23 <dysfun> which is the error I get if i comment out the type
05:25:31 <ski> KB5 : or, if you prefer shorter names, `f(x) = pi * x^2', renaming the function to `f'
05:25:38 <ski> KB5 : does this make sense ?
05:26:55 <dysfun> http://paste.lisp.org/+6WZ7/1 # commented out type error
05:27:19 <sena_kun> I'm trying to write a yesod app without hamlet(i.e. using blaze combinators directly). Currently I'm thinking about dealing with forms. I can generate action link and enctype, but I wonder, how can I include Widget in my blaze code? Can I render Widget to Html somehow to include it in a blaze markup directly?
05:27:47 <KB5> I think so, but the problem is swapping value of Type mood, like what not does for bool.
05:28:47 <dysfun> so match on it? swap Happy = Sad ; swap Sad = Happy
05:28:50 <ski> KB5 : yes, i'm intending to attempt to build up to that, if you can follow what i'm saying
05:28:57 <KB5> ski: alright
05:30:11 <ski> (KB5 : if you think i'm going to slowly / telling you things that you already know or have guessed, please tell me to speed up. otherwise i'll try to take it more thoroughly)
05:30:23 <ski> KB5 : anyway, if you ask the interactor to compute the expression `circleArea 5' for you, then that will, by the definition, compute the expression `pi * 5^2', with the actual parameter/input replacing the formal parameter/input in the "output expression" (aka definiens) `pi * radius^2'
05:30:37 <ski> and that computes into
05:30:44 <ski> > pi * 5^2
05:30:47 <lambdabot>  78.53981633974483
05:31:18 <geekosaur> dysfun, I think you took the wrong solution to that second error. it's telling you that you have two expressions that you expect to have the same type, but it can't prove that they do
05:32:10 <ski> KB5 : we sometimes call a statement like `surname = "Haskell"' or `circleArea radius = pi * radius^2' a "defining equation" (for `surname' respectively `circleArea')
05:33:35 <ski> KB5 : note especially that when we define functions (like `circleArea') like this, we're specifying what expression to compute to get the output, given *any* possible (allowed by the types) value for the input (here given the "private" name `radius')
05:33:40 <ski> KB5 : does that make sense ?
05:34:10 <geekosaur> usually simply tossing in a type signature does *not* help; in fact it usually tells the compiler they explicitly *do not* have the same type! you may need to turn on ScopedTypeVariables so that you can specify that the type does not change (possibly for the `return`)
05:34:16 <KB5> ski: yes
05:35:22 <ski> KB5 : now, if we wanted to define a function `not', with type signature `not :: Bool -> Bool' (so our input will be a `Bool', and we should compute a `Bool' output), the obbious thing to try then would be something like
05:35:26 <ski>   not b = ..b..
05:35:39 <dysfun> geekosaur: aha!
05:35:57 <ski> KB5 : where `..b..' signifies unfinished code, a "hole", in which we're to place some expression (which probably will involve the input `b' somewhere)
05:36:01 <ski> KB5 : ok ?
05:36:10 <dysfun> geekosaur: how can i communicate this to the type system?
05:36:52 <geekosaur> (specifically you would need to make v and w top level `forall`s so that you can annotate the type of the return $ ... with them, so it knows that the type did not change even though >>= would permit it to take a different type (so it infers ppolymorphism you don't want)
05:36:55 <ski> (KB5 : if you have any question, or want more elaboration, or are wondering about something else that floats your mind, don't hesitate to interrupt)
05:37:08 <KB5> ski: sure, go ahead for now :)
05:37:13 <geekosaur> ...I think.
05:37:45 <geekosaur> at least that's the only way I can see to get that error, where it thinks that the v and w of the result are not the same v and w you gave it
05:38:24 <geekosaur> but I'm not certain and possibly someone else should check this. especially since the other error seems to be using a type level list, and, uh.
05:38:55 <ski> KB5 : perhaps you'd even be able to complete the above definition of `not' (correctly) now, if you ponder a bit (judging from what you said before) .. though possibly not in the most elegant way
05:39:22 <ski> KB5 : if you want to, you could go ahead and try that now. otherwise i'll continue
05:39:44 <KB5> please do continue
05:39:50 <ski> sure
05:40:26 <ski> KB5 : so, the basic idea is that we want, as you said, `not True' to evaluate to `False', and `not False' to evaluate to `True'
05:41:01 <ski> so, the current question would be : how to complete the "hole" `..b..' in the defining equation `not b = ..b..', so as to achieve this ?
05:41:36 <ski> we need *some* way to make distinctions, to be able to treat the two possible inputs differently
05:42:41 <dysfun> geekosaur: yeah, freer does vrazy stuff
05:43:24 <ski> (note that the definition of `circleArea' used the input `radius' *uniformly* in a sense. regardless of which actual number was passed for `radius', the same formula `pi * radius^2' was used. however, the operators `*' and `^' must ultimately be able to also make distinctions, otherwise we'd always get the same result, when using `circleArea', regardless of which number we pass as input)
05:43:38 <ski> KB5 : makes sense ?
05:44:06 <KB5> ski: think so
05:44:25 <dysfun> geekosaur: so i tried changing it to forall v w r. Arr r Text Bool and i get a no instance error
05:45:12 <quchen> Anyone else having trouble with Haskell and Atom since the last update (Atom 1.9)?
05:45:21 <eklavya> quchen: yes
05:45:25 <geekosaur> I said you also had to add a type annotation. just using the forall there doesn't do anything but tell it which type variables are to be in scope within the definition and not just the type signature. you then need to use those type variables
05:45:25 <quchen> Ah, good.
05:45:28 <ski> KB5 : now, this problem of being able to make distinctions, to be able to treat different inputs (or different *classes* of inputs) differently, by "different formulae", as it were, props up again and again, and there's a general mechanism in Haskell to handle this, called "pattern matching"
05:45:35 <quchen> eklavya: Well, bad, but it means I didn’t mess up. :-)
05:45:41 <eklavya> :)
05:45:52 <ski> KB5 : another term for the same thing might have been "case/shape distinction"
05:46:02 <KB5> ski: pattern matching isn't covered yet in the book, just FYI
05:46:09 <eklavya> I wish the vscode plugin was as useful :(
05:46:30 <quchen> eklavya: Do you know a ticket that states the problem?
05:46:35 <eklavya> but at least it always works
05:46:37 <quchen> Is it with the IDE mod, with GHC-mod ..?
05:46:55 <quchen> All I have is “doesn’t work”
05:47:02 <eklavya> quchen: no, it happened with the last update too, got fixed with plugin updates though
05:47:04 <ski> KB5 : there are simpler and more complex uses of pattern-matching. i intend here to explain the most basic usage (fyi noted)
05:47:33 <dysfun> geekosaur: er, how do i do that?
05:47:35 <eklavya> quchen: I moved over from vscode because the atom plugin is more feature complete
05:47:48 <quchen> eklavya: Arr. The nice tiling support tricked me into breaking my Haskell dev env.
05:48:43 <ski> KB5 : the simplest case is to just "list the cases" according to
05:48:46 <ski> <ski> KB5 : so, the basic idea is that we want, as you said, `not True' to evaluate to `False', and `not False' to evaluate to `True'
05:49:08 <ski> KB5 : as follows (including the type signature at the top, for completeness/neatness)
05:49:16 <ski>   not :: Bool -> Bool
05:49:21 <ski>   not False = True
05:49:25 <ski>   not True  = False
05:49:45 <geekosaur> hm, I'm no longer thinking that is correct because the top signature should have been enough. I think you need help from someone else :(
05:49:55 <dysfun> :/
05:49:59 <ski> KB5 : iow, we say that in case the input is the value `False', then the output should be the computed by the expression `True' (also a value in this case)
05:50:09 <ski> KB5 : and similarly for the `not True' case
05:50:46 <geekosaur> so eiher the type annotation needs to be somewhere else that I'm not spotting, or the instance error is actually correct and I don't know Freer to know what should be done about it
05:51:27 <ski> KB5 : note that (to a first approximation), in place of the input argument here, when using pattern-matching, we write a *value* (the two values of type `Bool' are `False' and `True', as declared by the data type definition `data Bool = False | True')
05:51:39 <ski> KB5 : ok ?
05:52:00 <KB5> ok
05:53:32 <ski> KB5 : so, in this case, we've specified what should happen for every value (of the input type `Bool') that we can pass to `not', and therefore `not' has been "completely defined" (defined for all possible inputs), so we're done
05:54:47 <ski> KB5 : you should note that this is a *single* definition of `not', which consists of two "defining equations/clauses" (handling the two different cases)
05:55:43 <ski> KB5 : if we're defining another function with signature `f :: Bool -> Integer', then we could similarly define it by two defining equations, perhaps `f False = 42' and `f True = 3^4 - 1'
05:58:01 <ski> KB5 : however, we couldn't use `f (not True) = 42' in place of `f False = 42', nor `f (False && True) = 42' (round brackets here used only for grouping) -- because we can't use an arbitrary *expression* like `not True' or `False && True' for the "case/shape distinction" when pattern matching, we have to use a "value" (or more generally, a "pattern")
05:59:16 <ski> `not True' is not evaluated as far as possible. if we evaluate/reduce it, we get the value `False', which suffices as a pattern
06:00:32 <ski> KB5 : some other points of note : (a) the defining equations for a function are tried in order, until a matching one is found, then the corresponding "output expression" (aka right-hand-side (RHS) or definiens) of the defining equation is evaluated
06:01:45 <ski> (KB5 : the RHS is also known as the body of the function clause. the stuff to the left of `=' in a defining equation is sometimes known as left-hand-side (LHS) or definiendum, or head)
06:02:47 <ski> KB5 : (b) in the case of `not' above, the order of the defining equations doesn't matter, since the different defining equations handle non-overlapping (iow disjoint) cases
06:03:26 * hackagebot ghcid 0.6.5 - GHCi based bare bones IDE  https://hackage.haskell.org/package/ghcid-0.6.5 (NeilMitchell)
06:03:31 <ski> KB5 : but it would be possible to mix the "name the input" method of defining a function with the "match on the input" method i just sketched :
06:03:38 <ski>   not :: Bool -> Bool
06:03:43 <ski>   not False = True
06:03:49 <ski>   not b     = False
06:04:28 <bblfish> Hi, I have some code with Arbitrary definition. How do I use it in ghci? https://github.com/dalaing/cofun/blob/master/code/cofun-zipper/src/Zipper/List.hs#L24
06:04:42 <depaysementKing> hi there!
06:04:45 <ski> KB5 : in this case, the ordering *does* matter, since in the last equation `not b = False', `b' would "match" with any input (including `False') (naming it `b', which in this case isn't further used in the body), given the chance
06:05:06 <simg> hi, anyone have any experience using wai-sessions and wai-websockets together? I probably have a fundamental misunderstanding about how websockets are supposed to work?
06:05:08 <simg> see this paste: http://lpaste.net/175553
06:05:16 <ski> KB5 : in this case, we're saved by the fact that defining equations are tried in order. if we tried instead
06:05:19 <ski>   not :: Bool -> Bool
06:05:21 <ski>   not b     = False
06:05:25 <ski>   not False = True
06:06:04 <lyxia> bblfish: sample (arbitrary :: ListZipper Int)
06:06:07 <ski> KB5 : then it would not work as intended, as the latter defining equation would never be used here, since the former one overlaps completely with it, "shadowing/hiding" it from use
06:07:45 <ski> KB5 : ok ?
06:11:31 <KB5> ski: I dunno. Is this lead-up to the solution, or is this THE solution? Either way, I gotta leave as I am doing overtime at work for no good reason, already 40 minutes over my work day. I'll catch up later today.
06:18:24 <dot_Sp0T> Hey there, can anybody give me sort of an overview where haskell has its strengths and weaknesses?
06:18:26 * hackagebot ratel 0.3.1 - Notify Honeybadger about exceptions.  https://hackage.haskell.org/package/ratel-0.3.1 (fozworth)
06:19:05 <ski> KB5 : ok
06:19:46 <simg> dot_Spot: I wrote a blog post about the advantages of Haskell ... http://holisticsystems.co.uk/blog/why-haskell
06:19:56 <ski> KB5 : with what i've said so far, and given the definition of the data type `Mood', you should hopefully be able to finish `changeMood'
06:20:12 <ski> KB5 : one more point, which could be helpful
06:20:13 <ski> (c) sometimes you want to accept an input, but you don't actually (at least in that particular case / defining equation) care to *use* its value. in that case you can use `_' (the "wildcard"/"anonymous" pattern) in place of the variable name for the input. it matches anything, but refrains from giving it a name. you can use it several times to ignore several different inputs in the same defining equation
06:20:48 <Athas> dot_Sp0T: strength: transformations of complicated data structure.  Weakness: high-performance transformations of simple data structures (e.g. arrays).
06:20:58 <Athas> (Not an exhaustive list.)
06:22:07 <maerwald> I don't use complicated data structures in haskell
06:22:59 <maerwald> you either have to deal with clumsy record syntax or with overcomplicated lens
06:23:26 * hackagebot strive 3.0.1 - A client for the Strava V3 API.  https://hackage.haskell.org/package/strive-3.0.1 (fozworth)
06:24:54 <dot_Sp0T> Athas: sounds pretty neat. Can I compile it to Javascript?
06:25:53 <bblfish> thanks lyxia. I was trying to get it to work in the Atom shell
06:25:54 <Athas> dot_Sp0T: yes, but I've never tried it.
06:26:47 <dot_Sp0T> Athas: just kidding, wouldn't want to do that. Haskell is compiled to machinecode by default right?
06:26:58 <bblfish> in the Atom editor it gave no response, but in ghci your code returned an error
06:27:00 <Athas> dot_Sp0T: yes.
06:27:37 <geekosaur> dot_Sp0T, js is not in stock ghc. there is ghcjs that targets javascript
06:27:59 <geekosaur> (a very complete implementation, at the expense of a fairly heavy runtime)
06:29:04 <dot_Sp0T> You folks are quite alright. Any recommended tutorial to get into the basics of it?
06:29:58 <srhb> dot_Sp0T: ghcjs is pretty awesome, you shouldn't shy away from it! :-) I do all my JS dev in Haskell nowadays.
06:30:30 <Athas> My Haskell introduction was this one: http://www.cs.nott.ac.uk/~pszgmh/book.html
06:30:35 <Athas> And then I read Real World Haskell.
06:30:48 <dot_Sp0T> I'm honest here: I did just joke about the JS thing. I wouldn't want to code anything complex in it even if I got paid..
06:31:50 <dot_Sp0T> What would be interesting though is to know if it can be compiled to jvm bytecode
06:32:18 <pavonia> When you have to pass a C struct as a parameter to a foreign import, what type do you use for that? I created a Storable instance for a new type but using it, it tells me "Unacceptable argument type in foreign declaration"
06:32:32 <humanoyd> dot_Sp0T: if you want to compile to JS, I'd recommend PureScript...very similar to Haskell
06:34:14 <pavonia> How does it know what types are acceptable an what are not? Is that built-in?
06:34:26 <srhb> dot_Sp0T: I think there's a "Summer of Code"-ish project for targeting JVM.
06:34:51 <geekosaur> pavonia, you can't pass a struct by value with the FFI. if you wanted a pointer, you want to pass a Ptr YourStructType
06:35:34 <geekosaur> structs by value are difficult and dubiously portable, especially on architectures that can pass parameters in registers (like x86_64)
06:35:55 <pavonia> geekosaur: The C function expects a struct, no pointer
06:36:08 <geekosaur> you need to write a wrapper C function that takes a struct pointer
06:36:35 <pavonia> Uh, is there a sample for that somewhere?
06:37:38 <geekosaur> hm?
06:38:22 <geekosaur> rettype_t wrap_somefunction(struct foo *a) { return somefunction(*a); }
06:38:29 <c_wraith> you write a function that calls another function with & in front of some parameters. 
06:38:37 <c_wraith> err. Yeah. *
06:38:45 <c_wraith> I was going backwards. sigh. 
06:39:15 <geekosaur> (rettype_t being replaced wiith whatever the return type is)
06:39:54 <pavonia> Okay, let's see how far I get ... I'm terribly out of practice with C :S
06:41:08 <c_wraith> now if the function returns a struct, things get uglier. 
06:41:47 * geekosaur started to say that and decided to hope it wasn't
06:42:02 <geekosaur> because it gets lots uglier :(
06:42:26 <jchia_> i have an external file with text content that i want to include as data in my haskell library, so what when it runs, the data is available as a string so that i don't need to read it from the external file. is there a way to do that?
06:42:43 <pavonia> All functions so far take a pointer for storing their results, fortunately
06:43:34 <jchia_> i'm using stack
06:44:52 <jchia_> i think i'm going to try Data.FileEmbed
06:46:39 <geekosaur> sorry, I was trying to find that. was also on a call...
06:47:32 <c_wraith> jchia_: all the template haskell/quasiquoters for doing that work pretty well.  They also share a couple common issues.  Those issues don't prevent them from working, but you should be aware of them.
06:47:59 <c_wraith> jchia_: first, they increase compile time for modules that use them quite a lot.  Especially if the file is large.  GHC doesn't do the best with huge literals.
06:48:51 <c_wraith> jchia_: second, they can make recompilation flaky.  GHC doesn't know that a change to the file requires a recompile of the module.  Be wary that if you update the file, you might have to poke GHC a bit to force it to recompile the module that includes it.
06:49:14 <simg> anyone have any idea why I would get the following error when trying to use wai-session with wai-websocket :   Cannot mapHeader of Wai.Interal.ResponseRaw when trying to add session cookie header ?
06:49:57 <c_wraith> jchia_: But those are relatively minor issues.  Just keep them in mind if they become problems.
06:50:51 <c_wraith> simg: I don't know those packages, or wai.  But I do know that after starting a websockets connection, it's too late to set cookies on that response.  That's the only thing I can suggest looking at.
06:52:43 <jchia_> c_wraith: i suppose you're talking about the template haskell use in Data.FileEmbed? I want reliable rebuild when the file changes. because the file changes a lot. is there a way that avoids the failure to recompile?
06:53:27 * hackagebot octane 0.13.4 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.13.4 (fozworth)
06:54:27 <c_wraith> jchia_: I have worked around similar issues in the past by creating a custom Setup.hs that updates the last-modified time on the hs file that includes the data file in a pre-build step.
06:54:40 <c_wraith> jchia_: ...  I don't have an example of that on hand.
06:54:49 <simg> c_wraith: thanks, that would make sense.  I'm wondering if websockets and sessions aren't supposed to be mixed?
06:55:50 <c_wraith> simg: there's probably a way to specify that certain requests shouldn't set session cookies.  That's where I'd look.
06:56:52 <simg> c_wraith: thanks. it must be something like that!
06:58:27 * hackagebot type-natural 0.7.1.1 - Type-level natural and proofs of their properties.  https://hackage.haskell.org/package/type-natural-0.7.1.1 (HiromiIshii)
06:58:57 <Gurkenglas> http://lpaste.net/8930380204124143616 ghc-mod seems to want ghc 7.10.3 but .cabal-sandbox looks like https://gyazo.com/954c20a853c9ff280a7cb84e485e0166 . How do I resolve this? I'm using stack.
07:06:35 <Gurkenglas> The stack logs for ghc-mod show I have ghc-mod-5.5.0.0. stack build ghc-mod-5.4.0.0 fails due to dependency mismatch
07:10:28 <Gurkenglas> wait why is the ghc 7.10.3 if my stack.yaml has resolver lts-5.18
07:11:56 <oddasat> If I have something along the lines of data CustomerEvent = Created String | Updated and data SalesEvent = Purchased String | Returned String, can I combine these into one? I've tried this; data CombinedEvents = SalesEvent | CustomerEvent, but that doesn't work. Thanks.
07:12:34 <Gurkenglas> data CombinedEvents = NameTheFirstConstructor SalesEvent | ChooseSomeOtherName CustomerEvent
07:13:05 <Gurkenglas> hmm without the .cabal-sandbox stack build still works so that probably has nothing to do with what I was doing
07:13:05 <oddasat> Ah, thanks :)
07:16:55 <Gurkenglas> https://github.com/DanielG/ghc-mod/issues/498#issuecomment-136230231 cabal clean changes nothing
07:28:11 <lingxiao> hey all
07:29:05 <lingxiao> does anyone know what is a sane name for this: conduit-1.2.5:Data.Conduit.Internal.Conduit.ConduitM o o (ResourceT IO) ()
07:30:57 <Gurkenglas> Well first off thats a Conduit o (ResourceT IO) o
07:31:21 <Gurkenglas> Which could be called an EndoConduit (ResourceT IO) o
07:31:31 <Gurkenglas> (Or Endoconduit, not sure)
07:31:33 <lingxiao> ok great
07:31:43 <lingxiao> Endo because it's mapping o to o?
07:31:47 <Gurkenglas> yep
07:31:58 <lingxiao> ok forget that :)
07:32:36 <lingxiao> ok now whne I do this it doesn't compile: 
07:32:37 <lingxiao> http://lpaste.net/175559
07:32:54 <lingxiao> the error says no instance for :
07:32:56 <lingxiao> MonadIO
07:32:56 <lingxiao>                        (conduit-1.2.5:Data.Conduit.Internal.Conduit.ConduitM
07:32:56 <lingxiao>                           o o (ResourceT IO)))
07:32:58 <lingxiao>       arising from a use of ‘liftIO’
07:33:05 <lingxiao> which makes sense but I don't know how to express it 
07:33:29 <Gurkenglas> You should add the error to the paste next time
07:34:00 <lingxiao> it's certaily not: MonadIO (Conduit o (ResourceT IO))) => Conduit o (ResourceT IO) o
07:34:07 <lingxiao> yeah :( sorry about that
07:34:20 <lingxiao> pressed the wrong button when the propmt came up
07:34:38 <Gurkenglas> You can edit those, theres a link on the paste you linked
07:35:54 <lingxiao> huh never noticed that button .. thanks!
07:36:32 <lingxiao> ok here it is Gurkenglas: http://lpaste.net/175559
07:36:45 <Gurkenglas> I said next time :P
07:37:45 <lingxiao> oh haha .. yeah I completely edit it so now it's not even the oirignal example anymore
07:38:47 <lingxiao> see if I do MonadIO (Conduit o (ResourceT IO) o) instead, then I get error saying MonadIO has kind * -> *,   dropping that last o give me Conduit should have three arguments
07:40:17 <Gurkenglas> Actually Im confused, Conduit o (ResourceT IO) o should be MonadIO
07:41:04 <Gurkenglas> http://hackage.haskell.org/package/resourcet-1.1.7.5/docs/Control-Monad-Trans-Resource-Internal.html#t:ResourceT has MonadIO m => MonadIO (ResourceT m) so ResourceT IO has MonadIO
07:41:35 <Gurkenglas> https://hackage.haskell.org/package/conduit-1.2.7/docs/Data-Conduit.html has MonadIO m => MonadIO (ConduitM i o m) so ConduitM i o (ResourceT IO) has MonadIO
07:42:32 <lingxiao> yeah I don't know .. 
07:42:33 <Gurkenglas> And Conduit o m o is just ConduitM o o m () so we should have a MonadIO on our hands
07:42:55 <Gurkenglas> go to ghci and say liftIO :: IO () -> Conduit o m o
07:42:58 <dot_Sp0T> well thx for your help people, see you around
07:43:29 * hackagebot websockets-snap 0.10.0.0 - Snap integration for the websockets library  https://hackage.haskell.org/package/websockets-snap-0.10.0.0 (JasperVanDerJeugt)
07:43:33 <lingxiao> I get: http://lpaste.net/175562
07:44:15 <Gurkenglas> Are we talking about the same ResourceT? I mean http://hackage.haskell.org/package/resourcet-1.1.7.5/docs/Control-Monad-Trans-Resource-Internal.html#t:ResourceT
07:44:47 <lingxiao> here are my imports: http://lpaste.net/175563
07:44:56 <lingxiao> so Control.Monad.Trans.Resource
07:45:03 <lingxiao> is that similar?
07:45:18 <s4ke> hi guys. when does it make sense to evaluate a function only to whnf in a parallel environment compared to the deeply evaluated version?
07:45:54 <Xandaros> I have a list of Either values, `[Either a b]`. Can I somehow turn this into `Either a [b]`, being Left if there are any Left values in there and Right otherwise? The resulting `a` can then either be the first Left encountered or using `a`'s Monoid instance. Is there anything ready-made for this? 
07:46:08 <Gurkenglas> yea it has the same MonadIO instance lifting at least
07:46:35 <Gurkenglas> :t sequenceA :: [Either a b] -> Either a [b]
07:46:36 <lambdabot> [Either a b] -> Either a [b]
07:46:44 <lingxiao> yeah ... all this type stuff with conduit is a bit annoying
07:47:05 <Xandaros> Gurkenglas: Thank you! :D
07:47:58 <Gurkenglas> lingxiao, tell ghci "liftIO :: IO a -> ResourceT IO a" and if that works then "liftIO :: MonadIO m => IO () -> Conduit o m o"
07:49:07 <lingxiao> unforatnately for that first statement I get: http://lpaste.net/175562
07:49:35 <Gurkenglas> What version of resourcet do you have
07:50:27 <dsub> Xandaros: I might be wrong, but be careful if the list is long. The laziness goes away with sequenceA for [Either a b] I believe, since it need to go through the whole list first in order to locate any possible Left values.
07:50:28 <Gurkenglas> Nevermind, even the first version from 2012 lifts that instance
07:51:23 <Xandaros> dsub: I need to evaluate them all eventually, anyway. But thanks for the warning :)
07:52:32 <Gurkenglas> lingxiao, tell ghci runResourceT
07:52:52 -lingxiao(~lingxiao@2607:f470:6:400d:7594:bb36:d730:7033)- Gurkenglas do you mean just type runResourceT into ghic?
07:52:59 * Clint squints.
07:53:49 <lingxiao> I get this: http://lpaste.net/175562
07:53:58 <Gurkenglas> Also try lift :: IO a -> ResourceT IO a and if that works (liftIO $ lift $ print "ping") should work
07:54:00 <lingxiao> but I have FlexibleContexts in my PRAGMA
07:54:26 <lingxiao> where is lift from?
07:54:33 <Gurkenglas> Control.Monad.Trans
07:57:09 <lingxiao> ok so  lift :: IO a -> ResourceT IO a  worked sicne I get no show instance
07:57:37 <Gurkenglas> "sicne I get no show instance"? The reply I want is not "since" :P
07:57:49 <lingxiao> but now i get: http://lpaste.net/175562
07:58:35 <Gurkenglas> okay what try putting (T.lift :: IO a -> ResourceT IO a) instead of T.lift
08:00:01 <Gurkenglas> What you can also try for your original code to work is to define an orphan instance, that is adding a MonadIO m => MonadIO (ResourceT m) instance that is defined in neither of the modules that define MonadIO/ResourceT
08:00:26 <lingxiao> what's orphan instance?
08:00:59 <Gurkenglas> an instance that is not defined in any of the modules that define the things youre connecting with an instance declaration
08:01:10 <Gurkenglas> I just said that :D
08:01:23 <Gurkenglas> Just copy the two lines at http://hackage.haskell.org/package/resourcet-1.1.7.5/docs/src/Control-Monad-Trans-Resource-Internal.html#line-253
08:03:06 <lingxiao> oh ops sorry reading so fast didnt digest what you were saying haha
08:03:13 <lingxiao> i feel like something is offf ... 
08:03:27 <lingxiao> i'm jjust trying to run thee xample here: http://stackoverflow.com/questions/38863820/how-do-you-save-a-file-using-conduit
08:03:39 <lingxiao> and I assume the example cobmpiles .. he doesnt seem to have all these issues
08:04:46 <jchia_> I have an sqlite database populated using static data. (I initialize the sqlite DB once using the static data and after that there are no more writes.) I want to make functions that return values base on read-only queries to the database but I don't want them to return IO. However, the sqlite library i'm going to use expose sqlite functionality through IO. To "un-IO" the queries, is it appropriate to use unsafePerformIO?
08:05:34 <Gurkenglas> yea i also think your code should work, it just seems to disregard that one instance. Does the (T.lift :: IO a - ResourceT IO a) or the 2 line copy work?
08:07:53 <ongy> oh wow, I found a system that has ghc-7.4
08:07:53 <lingxiao> no copy two lines get me:
08:07:55 <lingxiao> http://lpaste.net/175573
08:08:05 <lingxiao> and the (T.lift :: IO a - ResourceT IO a) doesnt work either
08:08:10 <lingxiao> I think I'll just not print
08:09:06 <Gurkenglas> I think you forgot a > in the bracket thing
08:09:15 <Gurkenglas> and that error says you should enable a pragma
08:09:25 <palat> I did not know #haskell was one of the biggest currently existing channels
08:09:56 <lingxiao> yeah the language has gotten pretty popular
08:10:01 <lingxiao> often comes up on hackernews ...
08:10:13 <lingxiao> when i started it was like really obscure to most people
08:10:48 <ongy> we had it in 3rd semester @uni as example for functional programming
08:11:11 <palat> my uni does OCaml for functional programming
08:11:19 <palat> and Haskell as grad courses
08:12:06 <ongy> here it's weird, from time to time another prof does the lecture. so if you are lucky it's haskell, but it can also be ocaml (not judging languages but imo the prof that uses haskell is also better as teacher)
08:12:25 <palat> i agree
08:12:38 <palat> well, I actually liked having OCaml as the introduction to it
08:12:54 <palat> But to use Haskell as a more sophisticated FP language
08:12:57 <palat> in latter courses
08:13:30 * hackagebot fft 0.1.8.4 - Bindings to the FFTW library.  https://hackage.haskell.org/package/fft-0.1.8.4 (HenningThielemann)
08:20:30 <hughrawlinson> ooh ffts. I love a good fft.
08:21:11 <palat> Fast Fourier transform?
08:23:30 * hackagebot carray 0.1.6.5 - A C-compatible array library.  https://hackage.haskell.org/package/carray-0.1.6.5 (HenningThielemann)
08:26:47 <exDM69> argh.... can't get any of the LLVM packages building...
08:27:11 <exDM69> llvm-general and llvm-general-pure don't work with ghc 8 (template-haskell issues)
08:27:18 <exDM69> and llvm-ffi has issues with pkg-conig
08:27:21 <exDM69> pkg-config
08:28:40 <maerwald> llvm doesn't have pkg-config files afaik
08:28:58 <exDM69> yes... but llvm-ffi wants them anyway
08:29:06 <Gurkenglas> How do I make ghc-mod use stack? (And then make Atom's ghc-mod use stack.)
08:29:08 <exDM69> there's a haskell package llvm-pkg-config
08:29:24 <exDM69> which is supposed to generate pkg-config files that work with llvm-ffi
08:29:40 <maerwald> exDM69: wow, that is really bad
08:29:45 <maerwald> tell the developer to stop doing it
08:30:02 <maerwald> pkg-config files are meant to be maintained upstream, not anywhere else
08:30:13 <maerwald> not on distro level, not on hackage level
08:31:32 <ongy> Gurkenglas: I think it's the other way around, make stack launch atom `stack exec -- atom` or similar
08:31:46 <Gurkenglas> huh, sure why not
08:32:15 <Gurkenglas> feels like a CPS transform
08:32:16 <Gurkenglas> http://lpaste.net/1004697793765310464
08:32:28 <exDM69> maerwald: yes, this is awful...
08:32:30 <maerwald> exDM69: "If we are lucky we get pkg-config support in Debian Linux." <- meaning it will only build on debian
08:32:49 <exDM69> maerwald: it could use llvm-config instead, but that would mean tinkering with cabal
08:32:58 <maerwald> it's annoying if people don't understand the meaning of pkg-config
08:33:11 <maerwald> exDM69: and cabal supports doing that
08:33:14 <maerwald> you just have to write a Setup.hs
08:33:52 <exDM69> the issue is... I'm not good enough with Cabal or template-haskell to fix these issues
08:33:56 <exDM69> and I have compiler to write!
08:33:57 <exDM69> :)
08:40:03 <argent0> Hi #haskell! Is there a name for this class?
08:40:07 <argent0> class Thing f where
08:40:08 <argent0>    thing :: (a -> b) -> f a c -> f b c
08:40:21 <argent0> looks like a functor
08:40:58 <Gurkenglas> argent0, you might be interested in https://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor.html
08:41:39 <Gurkenglas> Oh hey actually its in base https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bifunctor.html
08:45:30 <argent0> Gurkenglas: intresting, thanks!
08:52:45 <Gurkenglas> ongy, any other ideas?
08:54:20 <ongy> sadly no
08:58:02 <exDM69> https://github.com/bscarlet/llvm-general/blob/master/llvm-general/src/Control/Monad/Exceptable.hs#L153
08:58:05 <exDM69> ‘readsPrec1’ is not a (visible) method of class ‘Read1’
08:58:17 <exDM69> is anyone familiar with these type classes?
08:58:25 <ski> it ought to be
08:58:51 <glguy> It isn't any more
08:58:56 <glguy> https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Functor-Classes.html#t:Read1
08:59:59 <glguy> https://hackage.haskell.org/package/transformers-0.4.3.0/docs/Data-Functor-Classes.html
09:00:00 <exDM69> yeah, but how do I migrate this to newer version?
09:00:12 <glguy> It changed from transformers 0.4 to 0.5
09:00:15 <glguy> and then went into base
09:00:20 <exDM69> this isn't my code and I'm not familiar with this part of transformers/base
09:00:41 <nilof> For general monad comprehensions, [f x y| x <- a, y <- b] = join [[f x y | x <- a] | y <- b ] ?
09:01:47 <acowley> I migrated some code like this the other day and have forgotten what it involved, but it was explained in the haddocks
09:02:03 <glguy> exDM69: This package uses Template Haskell to derive the Read1 instances http://hackage.haskell.org/package/deriving-compat-0.3.1/docs/Text-Read-Deriving.html
09:02:14 <acowley> Hm, it was when I was doing llvm-general things, so I can look up the diff
09:02:32 <exDM69> glguy: is there a document explaining the changes from transformers to base and what changed do I need for this package
09:02:40 <linduxed> hey guys, i'm getting an error when attempting to derive an instance: https://gist.github.com/linduxed/cecfc4fd1632152f757ea568a89980c6
09:02:44 <glguy> exDM69: I don't know, you'll have to look around. I just know that it changed
09:02:54 <linduxed> i suspect it's a simple error on my part
09:03:07 <ski> exDM69,glguy : oh i see, it's replaced with `liftReadsPrec'
09:03:07 <glguy> exDM69: The new method type allows more things to have Read1 instances
09:03:10 <acowley> Here it is
09:03:10 <linduxed> i thought that lines 3-4 would make it so that i couyld derive Show
09:03:11 <acowley> https://github.com/cocreature/llvm-general/commit/49b478cb7dc0876a347197373d7d7ee9edf3cc8e
09:03:20 <linduxed> instead i'm getting the error that's listed in the comment
09:03:42 <glguy> linduxed: You can't normally show a function; Transformation is a function
09:03:54 <linduxed> glguy: i know that
09:03:54 <acowley> exDM69: That linked commit should get you going
09:03:58 <linduxed> glguy: oooh wait!
09:04:06 <glguy> linduxed: Easy solution is to import https://hackage.haskell.org/package/base-4.9.0.0/docs/Text-Show-Functions.html
09:04:07 <ski> nilof : almost. swap `x <- a' and `y <- b'
09:04:22 <linduxed> glguy: maybe i just remove the deriving! that's what i added lines 3-4 for after all!
09:04:29 <ski> nilof : .. in the right hand side of the equation, i.e.
09:04:39 <glguy> linduxed: No, remove the "instance Show" and keep the deriving
09:05:09 <glguy> linduxed: and import the module I mentioned above to get an instance of Show for functions
09:05:16 <linduxed> glguy: but i just want an Instruction to be represented with the name...
09:05:32 <exDM69> acowley: thank you very much!
09:05:32 <glguy> linduxed: That's not really what Show is for
09:05:36 <linduxed> glguy: no?
09:05:50 <glguy> linduxed: Show is for printing out mostly Haskell source representations for debugging
09:05:53 <exDM69> acowley: bscarlet seems to be a busy guy... hopefully this gets fixed soon
09:06:10 <glguy> linduxed: If you have a specific format in mind that would go in a different "render" or "pretty" function
09:06:19 <exDM69> acowley: have you sent a pull request yet?
09:06:31 <linduxed> glguy: oh, is there a typeclass for that?
09:06:37 <acowley> exDM69: No problem! I was in exactly your position that day. I had no idea what about that code and was annoyed it needed touching.
09:06:42 <glguy> linduxed: No, that class would be specific to your project
09:06:53 <acowley> exDM69: cocreature is leading the effort to sort things out
09:07:03 <glguy> and you might have more than one for your project if there are different contexts you need to render user-visible things in
09:07:15 <exDM69> acowley: haskell seems to be a moving target... or is the change from ghc 7 to 8 a bigger one than usual?
09:07:16 <glguy> if it needs to be a class at all
09:07:35 <acowley> exDM69: He has PRs open on the main repo, but I think there are some strategic questions about llvm-general maintenance that are still a bit up in the air
09:08:01 <acowley> exDM69: It wasn't big at all, that commit is almost the entirety of it!
09:08:59 <acowley> exDM69: The big question for llvm-general is how to maintain support for multiple LLVM versions. Outside contributors won't want to backport changes to 3 LLVMs and 3 GHCs, though that goal makes some sense theoretically.
09:08:59 <ski> exDM69 : i think `instance (Read e, Read1 m) => Read1 (ExceptableT e m) where liftReadsPrec readsPrec readsList = ...' is the idea, but the problem here is how to turn the `readsPrec' and `readsList' arguments for `a' into a `Read a' instance in scope ?
09:09:37 <cocreature> exDM69: use the llvm-3.8 branch, bscarlet merged my changes
09:10:22 <cocreature> personally I don’t care about any other versions so I won’t put a lot of effort into updating those
09:10:28 * acowley hits the *party popper emoji* button
09:10:38 <benzrf> is Rational actually isomorphic to Q?
09:10:56 <benzrf> (assuming you restrict its elements to the ones that are possible to construct with the publically exported stuff)
09:11:06 <benzrf> or is it broken like floats
09:11:08 <exDM69> cocreature: acowley: that patch alone doesn't fix llvm-general-pure
09:11:13 <ski> acowley : any way to do it without duplicating the logic ?
09:11:16 <exDM69> I'll check out that branch and see if it works
09:11:27 <Cale> benzrf: It's actually Q if you ignore nontermination
09:11:31 <benzrf> cool
09:11:43 <cocreature> exDM69: there are a lot of patches in the llvm-3.8 branch by now
09:11:44 <acowley> cocreature: I think it will be fine as long as support for different versions is alowed to diverge.
09:11:49 <ski> glguy : "The new method type allows more things to have Read1 instances" -- perhaps less as well ?
09:12:26 <exDM69> cocreature: should I take bscarlet/llvm-general branch llvm-3.8?
09:12:26 <acowley> exDM69: I'm using the llvm-3.8 branch with GHC-8.0.1, so I can recommend running with that
09:12:30 <exDM69> or cocreature/llvm-general?
09:12:34 <benzrf> ordered fields are always char 0, right
09:12:41 <cocreature> exDM69: bscarlet
09:13:31 <acowley> ski: for the Read1, Show1 instances? I don't know. I didn't think beyond making it work unfortunately :/
09:13:33 <benzrf> i was thinking i could extend CoC with a fake R type that's implemented with Rational
09:14:00 <benzrf> and then get away with that by leaving out any elimination rules that aren't true for r
09:14:01 <benzrf> * R
09:14:09 <exDM69> cocreature: acowley: I'm using cabal + cabal sandbox right now... should I be using stack or something else instead? (I depend on llvm, parsec and pretty only)
09:14:44 <cocreature> exDM69: I personally like stack, but cabal sandboxes are just fine if that works for you
09:14:46 <acowley> exDM69: I use stack, but I don't think that's critical
09:15:04 <ski> acowley : perhaps one could made the appropriate definition of `readsPrec' in exDM69's `instance (Read e, Read1 m) => Read1 (ExceptableT e m) where readsPrec1 = readsPrec' be (effectively) moved into this instance (redefining the other one in terms of this), instead of duplicating it ..
09:15:38 <exDM69> acowley:: cocreature: http://www.pasteall.org/73854  still doesn't build...
09:15:50 <exDM69> another template-haskell issue
09:15:55 <glguy> ski: I can't see how it would exclude instances, the first argument to liftReadsPrec is the method from the Read instance you would have had
09:15:57 <benzrf> Cale: do you know if it's possible to implement the algebraic closure of Q in a way akin to Rational?
09:16:02 <cocreature> exDM69: which llvm version do you have?
09:16:20 <exDM69> llvm-config --version = 3.8.1
09:16:24 <cocreature> weird
09:16:54 <acowley> exDM69: I've not touched that code; I don't know what's happening there
09:16:54 <glguy> ski: That's not to say that I'm going to be surprised when you point out some corner case I'm overlooking
09:17:20 <exDM69> acowley: can you tell me the git commit hash of your llvm-general version?
09:17:29 <benzrf>  
09:17:38 <cocreature> travis builds the branch just fine so there must be a difference in your setup
09:17:43 <cocreature> (and it builds fine for me as well)
09:18:00 <exDM69> cocreature: what could that difference be?
09:18:09 <acowley> exDM69: I think the branch tip builds, but I'm on 7f5719f3b24cb974e3aef0522444521ce3ac7f54
09:18:51 <Cale> benzrf: It should be possible to implement, but I'm not sure about the "in a way akin to Rational" part
09:19:52 <cocreature> exDM69: not sure, I’m looking at the code right now but I can’t find anything obvious
09:20:25 <ski> glguy : well, the `readsPrec' i was talking about was of type `forall a. Read a => Int -> ReadS (ExceptableT e m a)' (for given `e',`m' with `Read e',`Read1 m'), while the first argument to `liftReadsPrec' would have type `Int -> ReadsPrec a' (for the specific `a' with `Read a', that `liftReadsPrec' is handling, otherwise as before)
09:20:57 <acowley> I wonder if this macro problem is due to whatever C compiler is invoked
09:21:22 <acowley> Hopefully not as that's a big hairball
09:21:26 <exDM69> acowley: cocreature: something related to the NoRecurse attribute
09:21:42 <ski> glguy : i won't say that one *ought* to be able to factor/move the code as i indicated (i'm a not tired atm, and only gave the code a cursory glance). just my vague impression was that it might be possible
09:22:15 <cocreature> exDM69: iirc NoRecurse was added for 3.8 so it looks like a version missmatch but your version looks correct. also I think Setup.hs checks for the correct version
09:22:26 <exDM69> http://www.pasteall.org/73855  ghc panic
09:22:52 <exDM69> after commenting out the few lines of norecurse
09:22:52 <ski> (s/a not tired/a bit tired/)
09:23:04 <exDM69> perhaps I have some stale build files
09:23:20 <exDM69> I was trying with llvm-3.5 a moment ago
09:23:33 <cocreature> exDM69: also make sure you are using llvm-general-pure and llvm-general from the same commit
09:23:43 <Cale> benzrf: http://sci-hub.cc/http://www.sciencedirect.com/science/article/pii/S0747717188800087 might be of use
09:24:19 <benzrf> ty
09:24:23 <benzrf> i probably wont read that >.>
09:25:01 <exDM69> cocreature: that might also be an issue... I'm not at all familiar with cabal
09:25:30 <cocreature> exDM69: take a look at the LLVMCTypes.hs file that’s generated somewhere in your dist directory
09:25:45 <Cale> benzrf: meh, it's pretty vague anyway
09:28:13 <Cale> benzrf: ... perhaps better... https://perso.univ-rennes1.fr/marie-francoise.roy/bpr-ed2-posted2.html
09:28:56 <exDM69> cocreature: I think I had some stale files, I'll try rebuilding
09:29:06 <exDM69> cocreature: I'll take a look at that soon if the issue persists
09:29:22 <nmattia> let's say I have a simple .hs file that I compile with stack ghc -- ... --ddump-simpl, where would I find the core output?
09:31:18 <exDM69> cocreature: acowley: ... the issues I had later on were due to stale build files ... clean rebuild from llvm-3.8 branch worked!
09:31:26 <exDM69> cocreature: acowley: thanks a lot for your effort!
09:31:41 <exDM69> and all the help for a noob
09:31:47 <cocreature> exDM69: great, glad I could be of help
09:31:53 <acowley> exDM69: That's great! I had to stack clean several times while working on it, too, fwiw.
09:33:13 <ski> Cale : looks interesting ..
09:33:32 <x1f577> is there a way to have both a GHC compiler server executable and a GHCJS compiled webapp executable in te same .cabal file?
09:33:46 <exDM69> cocreature: acowley: now I can hopefully get back to hacking the actual compiler I was working on :)
09:34:10 <exDM69> but the issues with LLVM took so much time that I won't meet my "from zero to turing complete in 24 hours" :)
09:34:15 <cocreature> exDM69: have fun :)
09:34:32 <Cale> benzrf: Basically, it's possible to represent real algebraic numbers as polynomials, together with a mapping which assigns a sign condition (a value of type Ordering) to each of the derivatives of the polynomial, such that the only point which satisfies that sign condition (when you plug it in to all the derivatives) will be the root you're talking about.
09:34:38 <Cale> (also ski)
09:35:00 <Cale> (and then you can get the algebraic closure of Q by adjoining i)
09:35:56 <Cale> It turns out to be possible to compute nicely with this representation.
09:38:12 <ski> Cale : how about attempting to code up the "obvious"(?) completion in terms of adding a ("formal") solution for each irreducible polynomial ?
09:38:29 <ski> does that work (computationally) ?
09:41:11 <lingxiao> hey is there a library function in conduit that odes this?
09:41:24 <lingxiao> http://lpaste.net/175590
09:42:16 <exDM69> cocreature: acowley: any neat examples of getting started with llvm-general?
09:42:38 <iphy> how can I put ghc version specific flags in OPTIONS_GHC pragmas?
09:42:53 <iphy> on 8.0.1 I need a flag to compile a file, on previous versions I don't
09:42:59 <iphy> on previous versions the flag doesn't exist
09:43:04 <__Myst__> Is there any difference between foldl and foldr?
09:43:15 <__Myst__> They seem to always produce the same input
09:43:16 <linduxed> ok, why is is that i get "Not in scopeÄ data constructor 'L.Instruction'" on this line? https://github.com/linduxed/advent_of_code/blob/day_six/day-six-stack/src/InstructionParser.hs#L25
09:43:17 <__Myst__> output*
09:43:33 <cocreature> exDM69: https://github.com/sdiehl/kaleidoscope is quite nice (but not yet updated for 3.8 afaik)
09:43:36 <linduxed> it's clearly exported here: https://github.com/linduxed/advent_of_code/blob/day_six/day-six-stack/src/Lib.hs#L3
09:43:59 <linduxed> the same seems to be happening to L.Coordinate
09:44:14 <ski> __Myst__ : they differ in case the callback function is non-associative. they also allow it to have different types, in which case a comparision is meaningless
09:44:16 <glguy> linduxed: change your export to Instruction(..)
09:44:36 <glguy> linduxed: Currently you're only exporting the type constructor and not the data constructor
09:44:44 <linduxed> glguy: oooh, i see
09:45:24 <lyxia> > (foldl (-) 0 [1,2,3], foldr (-) 0 [1,2,3])
09:45:26 <lambdabot>  (-6,2)
09:45:50 <lyxia> > (foldl (-) a [b,c,d], foldr (-) a [b,c,d])
09:45:51 <ski> __Myst__ : oh, and they also assume a starting element which (in case the callback is associative) is commonly a left neutral element vs. a right neutral element. there need not exist both a left and a right neutral element for a given associative operation
09:45:53 <lambdabot>  (a - b - c - d,b - (c - (d - a)))
09:46:51 <lingxiao> it's not quite like fmap
09:47:27 <exDM69> cocreature: oh great! I'm familiar with Kaleidoscope from LLVM tutorials and implementations in other languages
09:47:35 <__Myst__> > foldr (:) [1, 2, 3, 4, 5]
09:47:37 <lambdabot>      No instance for (Typeable t0)
09:47:37 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
09:47:37 <lambdabot>        arising from a use of ‘show_M432983791586753955928063’
09:47:40 <__Myst__> > foldr1 (:) [1, 2, 3, 4, 5]
09:47:41 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ [a]
09:47:41 <lambdabot>      Expected type: [a] -> [a] -> [a]
09:47:41 <lambdabot>        Actual type: a -> [a] -> [a]
09:47:50 <__Myst__> > foldr (:) [] [1, 2, 3, 4, 5]
09:47:52 <lambdabot>  [1,2,3,4,5]
09:47:55 <__Myst__> > foldl (:) [] [1, 2, 3, 4, 5]
09:47:57 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ [a]
09:47:57 <lambdabot>      Expected type: [a] -> [a] -> [a]
09:47:57 <lambdabot>        Actual type: a -> [a] -> [a]
09:48:04 <__Myst__> makes sense
09:48:10 <ski> > foldr1 (++) [[],[0],[1,2],[3,4,5],[6,7,8,9]]
09:48:12 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
09:49:24 <ski> > foldr (\n s -> concat ["(",show n," + ",s,")"]) "0" [2,3,5,7]
09:49:25 <lambdabot>  "(2 + (3 + (5 + (7 + 0))))"
09:49:35 <ski> > foldr (\s n -> concat ["(",s," + ",show n,")"]) "0" [2,3,5,7]
09:49:36 <lambdabot>      No instance for (Num [Char]) arising from the literal ‘2’
09:49:36 <lambdabot>      In the expression: 2
09:49:36 <lambdabot>      In the third argument of ‘foldr’, namely ‘[2, 3, 5, 7]’
09:49:51 <ski> > foldl (\s n -> concat ["(",s," + ",show n,")"]) "0" [2,3,5,7]  -- oops
09:49:53 <lambdabot>  "((((0 + 2) + 3) + 5) + 7)"
09:50:30 <maerwald> ski: is any of that of public interest?
09:51:57 <exDM69> cocreature: I have to maintain naming manually, right? I can't just reuse the same name and get new ones? (like LLVM API does with add0, add1, etc.)
09:52:06 <ski> clearer demonstration to __Myst__ of cases where it doesn't make sense to try to pass the callback to both `foldr' and `foldl' (nor to ask whether it is associative)
09:53:35 <cocreature> exDM69: not sure what add0, add1, … does and I can’t find it
10:04:48 <exDM69> cocreature: I mean that the LLVM api creates new names if you ask for the same name (e.g. add) several times
10:05:12 <exDM69> cocreature: anyway, I think I can get this to work based on kaleidoscope
10:14:39 <yyyyy> #haskellstack
10:14:43 <cocreature> exDM69: if you want to do something like overwriting a variable it probably makes more sense to simply allocate stack memory for it and leave it up to llvm to move that to register ssa form
10:14:48 <yyyyy> oops
10:14:50 <cocreature> exDM69: in fact that’s exactly what clang does
10:15:24 <jophish> @tell wrengr_away Hi, Where's the best place for submitting questions/ideas for uniciation-fd?
10:15:24 <lambdabot> Consider it noted.
10:15:29 <srhb> yyyyy: I also think it's #haskell-stack
10:17:15 <exDM69> cocreature: no, I'm just trying to generate unique names here...
10:17:28 <yyyyy> srhb: you are right :)
10:17:40 <yyyyy>  what's the current best practice for putting version numbers in a cabal file? should i leave with the upper bound of the same major version i'm using?
10:17:53 <srhb> yyyyy: I think the pvp still applies
10:18:14 <srhb> Oh, on dependencies
10:18:21 * srhb has bad reading comprehension
10:18:32 <cocreature> exDM69: hm at that point you have to do it yourself afaik
10:18:47 <yyyyy> i used to leave fixed versions before stack, but it spoiled me with the curated lists, so nowadays i leave NO version on my local cabal files. i plan on uploading a few things on hackage, though, and wanted to know what's the best option.
10:19:05 <exDM69> cocreature: yep, I figured... LLVM C/C++ api does that, but need to whip up my own scheme with llvm-genera
10:19:12 <yyyyy> srhb: np :)
10:19:28 <dcoutts> yyyyy: yes, remember that other people may want to use your code in a variety of different configurations
10:19:29 <exDM69> related not: how to use ExceptT?  https://github.com/sdiehl/kaleidoscope/blob/master/src/chapter7/JIT.hs#L52
10:19:33 <cocreature> yyyyy: you can use the --pvp-bounds option on stack upload
10:19:48 <exDM69> mtl changed after this came out? that gives me type errors
10:19:54 <quchen> yyyyy: I develop using Stack, and then try to compile it with the oldest LTS I can find. I use those versions (first 3 numbers) as lower bounds.
10:20:17 <quchen> Old Stackage releases often lack important packages, so it’s more manual work the further you go back.
10:20:43 <cocreature> exDM69: could you show the type error?
10:21:06 <yyyyy> cocreature: is there a way to see the bounds before it uploads them?
10:21:22 <cocreature> yyyyy: not sure I never actually used that option. I just add bounds to my cabal file
10:21:35 <yyyyy> dcoutts: yes, that was my concern :) i want it to be useful.
10:22:09 <dcoutts> yyyyy: I'd recommend putting the bounds into the .cabal file directly and keeping that in source control, rather than relying on some tool to do it ephemerally when you upload
10:22:27 <yyyyy> quchen: that seems like a good option, though i suppose without some sort of tests i won't know if semantics changed on older versions that end up compiling since the types match.
10:22:36 <dcoutts> afterall, you sometimes need to tweak them in the light of evidence about what does and does not work
10:22:42 <quchen> dcoutts: You were very thorough: since we last met, I haven’t found a new unsafe function I did not understand! :-D
10:22:46 <quchen> Thanks again, helped me a ton
10:22:51 <dcoutts> heh
10:22:55 <dcoutts> you're welcome
10:23:28 <quchen> If you need a place to sleep at when you come to Munich, I could pay you with a nice couch ;-)
10:24:24 <dcoutts> quchen: :-)
10:24:25 <yyyyy> dcoutts: that's the plan, yes. my plan was to use `stack list-dependencies` and add the ones listed in the cabal file with the upper bounds less than next major version, but quchen's tip to move backwards seems like a good idea.
10:24:39 <exDM69> cocreature: I got confused with operator precedence and do notation here
10:25:12 <quchen> yyyyy: You’ll need to add extra deps manually for older LTS releases. It’s a bit tedious, unfortunately.
10:25:36 <quchen> And this means you need an extra stackX.yaml for older builds, like this one. https://github.com/quchen/stgi/blob/master/stack-lts3.yaml
10:25:46 <quchen> Still, better than guessing.
10:26:06 <quchen> And also better than having no version bounds, which would be *terrible* for the ecosystem.
10:26:41 <exDM69> cocreature: wohoo! first lines of LLVM IR emitted1
10:27:20 <yyyyy> is the stack-lts3.yaml used automatically by stackage in any way, or is it just so users’ have something to change into a stack.yaml if need arises?
10:27:53 <yyyyy> stgi is really cool, by the way :) kudos for it.
10:28:37 <Gurkenglas> ghc-mod can't handle CPP?
10:32:52 <yyyyy> quchen: nevermind the last question. i just read the FAQ. sorry!
10:33:07 <quchen> yyyyy: Thanks :-)
10:33:24 <quchen> I’m just using the LTS3 file for the CI build
10:33:38 <exDM69> cocreature: are you aware of anything being done to the GHCi + LLVM issue? LLVM has never worked in GHCi afaik
10:34:36 <bblfish> I can't find Control.Comonad.Trans.Cofree on Hoogle
10:35:17 <Gurkenglas> I've got atom and those ide-haskell packages set up. Now how do I get it to show me errors/warnings/linter etc as advertised on https://atom.io/packages/ide-haskell? Its just this https://gyazo.com/d3411d2ab0778e56391ce0d0e7272d1e (and for some reason I remembered Ctrl-Shift-B which does the thing at the bottom)
10:35:25 <Gurkenglas> (stack build in the project folder works)
10:36:44 <cocreature> exDM69: I think it should work if you pass -fshared-llvm to llvm-general. but that only works for projects depending on llvm-general. to load llvm-general itself into stack ghci or something like that you need some linker hackery. I know how to do it but I haven’t bothered making a patch so far because benjamin is not a stack fan and I’m too lazy to reproduce the problem with cabal.
10:37:12 <Gurkenglas> There was a thing at the bottom a few atom restarts ago with Lint, Error, Warning tabs but its gone now
10:37:58 <exDM69> cocreature: how can I pass that arg?
10:38:44 <cocreature> exDM69: cabal install -fshared-llvm llvm-general or something like that
10:39:21 <exDM69> ok, let me try
10:39:29 <Gurkenglas> Oh hey restarting didnt do anything but opening a .hs that wasnt already open showed that thing with the tabs again. ._.
10:39:36 <bblfish> mhh but I can find it using Google https://hackage.haskell.org/package/free-4.12.4/docs/Control-Comonad-Trans-Cofree.html
10:39:51 <ion> Is there a nice "aeson for XML"?
10:42:34 <quchen> Is there a way to fail with Trifecta without reporting expected things?
10:43:07 <quchen> I’ve got the problem that I want to fail with a helpful string, but Trifecta insists in also adding “expected <useless/misleading>”, which I’d like to avoid.
10:43:34 * hackagebot ghc-typelits-knownnat 0.1 - Derive KnownNat constraints from other KnownNat constraints  https://hackage.haskell.org/package/ghc-typelits-knownnat-0.1 (ChristiaanBaaij)
10:48:14 <moongazer>  Can someone be my competitive programming coach?
10:49:05 <Gurkenglas> moongazer, sounds fun, what would I do
10:49:37 <moongazer> Gurkenglas: Seriously, would you help me?
10:49:42 <srhb> CODE HARDER. CODE FASTER!
10:49:49 <Gurkenglas> seriously what would i do
10:50:08 <srhb> :-) 
10:50:47 <Gurkenglas> if you want to carry over some existing culture, dojos and senseis seem more applicable to programming x)
10:52:45 <moongazer> Gurkenglas: Please tell me in a straightforward manner
10:53:28 <Gurkenglas> I don't know what it entails, so I haven't decided yet. "Here, sign this contract, oh you want to read it, nevermind"
10:54:27 <quchen> I also don’t know what a competitive programming coach is.
10:54:33 <moongazer> Gurkenglas: I just meant someone who could help me learn some algorithms, solve some problems a little bit guidance etc
10:54:57 <quchen> Oh. In that case, this channel is a competitive programming coach. :-)
10:55:30 <Gurkenglas> Hmm. You probably also mean point you at the next algorithm to learn/program to solve?
10:55:31 <glguy> Does being a private coach pay well?
10:57:27 <Gurkenglas> By the way https://www.codingame.com/clashofcode sounds like it would be fun for you, it has the competetive part down and Haskell is one of the choices
10:58:35 <Gurkenglas> (well true pvp is over in the ai section i guess)
11:02:28 <moongazer> Ok
11:02:41 <moongazer> Thanks
11:26:35 <runeks> Is there a number type which only defines addition and subtraction, and not multiplication and division? I'm creating a custom number type for money amounts, and as far as I can see it makes no sense to multiply two money amounts.
11:27:06 <runeks> I could just make * and quotRem "undefined", but that seems uninformative
11:27:25 <glguy> There isn't a standard class for that, but you could define operations that work on money: $+ and $-
11:29:29 <glguy> There's probably a "Group" typeclass somewhere
11:29:47 <jonored> OTOH, multiplying and dividing money by other units and by dimensionless numbers /does/ make sense.
11:30:47 <runeks> Good points.
11:31:19 <runeks> I guess it would make sense to define $+ $- and $* as well, where the last one only takes an Integral as the second argument
11:31:57 <jonored> In general, money behaves pretty normally as a unit - additions and subtractions don't change the unit, but multiplications and divisions do.
11:36:08 <jonored> $/ would be pretty reasonable as returning a fractional that is /not/ money.
11:37:44 <johnw> runeks: I have code that you can use, if you like
11:38:15 <johnw> https://github.com/ledger/ledger4/blob/master/commodities/Ledger/Balance.hs
11:38:37 <johnw> a Balance is a vector that allows multiple commodities to be added/subtracted, or multiplied by a scalar (it's a vector space)
11:38:51 <johnw> if you only use one commodity, it works just as well
11:39:25 <johnw> underneath it uses Rational Integer
11:47:24 <runeks> johnw: Thank you for the suggestion. I think I will settle on creating my own type, though, as it's such an integral part of the library.
12:03:37 * hackagebot bitcoin-payment-channel 0.2.2.0 - Library for working with Bitcoin payment channels  https://hackage.haskell.org/package/bitcoin-payment-channel-0.2.2.0 (runeks)
12:06:28 <exDM69> what's the gist of the "mtl vs. tranformers" thing?
12:06:36 <exDM69> do they fulfill the same task?
12:06:47 <glguy> mtl builds on transformers with some typeclasses
12:06:47 <exDM69> if so, which one should I use for new software?
12:07:12 <glguy> mtl is more magical, transformers is more direct
12:07:14 <johnw> very, very generally: if you're making a library, use mtl; if you're writing an application, use transformers
12:07:28 <glguy> I'd have said the opposite
12:07:33 <johnw> you don't want to be too concrete in the former, nor too general in the latter
12:07:44 <exDM69> I'm looking for MonadState and State
12:07:55 <glguy> MonadState is only in mtl
12:09:09 <glguy> Unless the purpose of your library is to provide mtl utilities I wouldn't generally expose mtl constraints in a library
12:09:11 <johnw> glguy: why the opposite?
12:09:26 <johnw> have MonadState in a library allows it to be used in more contexts
12:09:53 <glguy> If your library some some library specific state it's better to make a domain specific class for that
12:10:39 <glguy> HasRandomGenerator rather than MonadState RandomGen
12:11:01 <lyxia> There's MonadRandom
12:11:12 <glguy> Yeah, for example
12:18:37 * hackagebot hjsonpointer 1.0.0.0 - JSON Pointer library  https://hackage.haskell.org/package/hjsonpointer-1.0.0.0 (seagreen)
12:26:18 <exDM69> mtl 2.2.1 depends on transformers
12:26:43 <lyxia> indeed
12:28:53 <athan> more than meets the eye
12:33:38 * hackagebot preliminaries 0.1.0.0 - A larger alternative to the Prelude.  https://hackage.haskell.org/package/preliminaries-0.1.0.0 (yghor)
12:34:02 <yyyyy> johnw: aren't the typeclasses statically dispatched on most application stacks? what do you get by being concrete?
12:34:18 <yyyyy> i generally use only the mtl classes, so i'm curious if it's a bad choice overall.
12:35:25 <yyyyy> i just uploaded that `preliminaries` package above. feedback highly welcome.
12:37:26 <lyxia> you can get a hit on performance because of polymorphic recursive functions
12:37:47 <lyxia> because of dictionary passing that doesn't get optimized away
12:38:01 <yyyyy> lyxia: can you avoid it by declaring the types on every call site?
12:39:12 <Cale> yyyyy: Not if the code which uses the dictionaries has already been compiled
12:39:19 <johnw> yyyyy: they can also be annoying to use sometimes
12:39:43 <Cale> Sometimes you can ask for things to be specialised...
12:41:02 <Cale> and yeah, I would tend to prefer designing an API which expresses something more particular about what your operations are than "get", "put" etc.
12:41:07 <yyyyy> johnw: in general i like the way it reads better. i see first the “capabilities” of the function i'm working on.
12:41:57 <yyyyy> Cale: but in this case you can wrap the mtl classes in your own stack and expose semantically-relevant operations, right?
12:42:17 <Cale> I'm not sure why you'd use the mtl classes in that case
12:43:23 <yyyyy> yeah, true. the only use case i can imagine is if you want to be able to pass arbitrary monads to build your wrapped stack.
12:43:53 <Cale> Also, I really dislike the word "stack", because if you have to think about all the intermediate monads you're producing by repeated application of various monad transformers, you've already probably gone wrong somewhere.
12:44:14 <Cale> (Except possibly once when you're applying them in the first place)
12:44:37 <Cale> You shouldn't have to think of it as a stack. You just end up with some monad, and it's the monad that you want.
12:45:14 <bizarrefish> Hi all
12:45:18 <yyyyy> you have to think when building it, at least :p
12:45:21 <Cale> and you even generally newtype it and hide the fact that you're using monad transformers at all behind a module abstraction
12:45:34 <yyyyy> yes, that's generally what i do
12:45:51 <Cale> Nobody ever refers to f (g (h x)) as a "function stack"
12:45:55 <yyyyy> with a suitable runSomeNewMonad function to do everything
12:46:26 <bizarrefish> Free monads are often talked about as ASTs, but it seems to me they are more like lazy lists. How should I think of them? What makes them AST-like?
12:46:38 <yyyyy> maybe Factor people refer to it like this O:)
12:46:44 <Cale> haha
12:47:13 <Cale> bizarrefish: Well, it helps to look at examples which aren't obtained by applying Free to some functor, but instead written directly, perhaps.
12:47:42 <Cale> bizarrefish: For example, consider if I wanted to define my own IO monad, I might start out with something like this:
12:48:18 <Cale> data MyIO a = Return a | PutChar Char (IO a) | GetChar (Char -> IO a) | ...
12:49:06 <Cale> Using the recognition that any IO action is either Return applied to an argument, or else it has to start off by doing *something*, and then following that up with another IO action.
12:49:56 <Cale> In general, if that first thing it does has a result, the corresponding constructor will take a function of that result as its argument, along with any parameters necessary
12:50:42 <Cale> So this is kind of like higher order abstract syntax for an imperative program.
12:51:57 <Cale> The next step is to just separate things out a bit, so that we get to write a general monad instance just once, and then reuse it with different bunches of operations.
12:53:11 <hsk3> Are the Haskell web frameworks (Snap, Happstack, Yesod) still being actively maintained and improved in a similar way as, say, Node.js is?
12:53:12 <hsk3> Or have these things basically plateaued and it's mostly just bug fixes nowadays?
12:53:16 <Cale> and you immediately get to the definition of Free if you do that -- it takes a functor which in my IO example above would look like  data IOOps a = PutChar Char a | GetChar (Char -> a) | ...
12:53:37 <Cale> hsk3: Snap 1.0 was just released... yesterday?
12:54:00 <Cale> no, a few days ago now :)
12:54:06 <Cale> They apparently got it out on the 7th
12:54:10 <Cale> http://snapframework.com/blog/2016/08/07/snap-1.0-released
12:54:23 <hsk3> hehe, wow.
12:54:25 <hsk3> Cale: http://snapframework.com/blog
12:54:32 <hsk3> That's a big gap though.
12:54:39 <hsk3> September 2014 to August 2016.
12:54:51 <Cale> Mostly it's a gap in announcements rather than work
12:54:56 <bizarrefish> Cale: So, the way that the free monad is constructed (bind, return) forms an AST (though not a serializable one). It seems that the resulting data structure isn't?
12:55:02 <Cale> There are people using all the frameworks actively, including in commercial projects
12:55:49 <Cale> bizarrefish: Well, Free IOOps is basically the same thing as MyIO
12:55:52 <hsk3> Sweet.
12:55:56 <hsk3> Great to know, thanks.
12:55:59 <bizarrefish> bind being the internal nodes of the tree, return and the instances of the functor being the leaf nodes.
12:56:21 <Cale> bizarrefish: Well, in this case, there's no explicit constructor for bind
12:56:31 <fr33domlover> hsk3, note that a lot of new feature development doesn't imply a good framework. A mature stable framework will have much less missing features to add
12:57:08 <johnw> fr33domlover: I get told by GitHubbers that some of my projects are "dead", just because there isn't code churn all the time; meanwhile, I continue using them daily :)
12:57:47 <quchen> not not dead does not imply dead. :-)
12:57:58 <shapr> johnw: they're finished?
12:57:58 <hsk3> fr33domlover: good point.
12:58:04 <johnw> shapr: some are, yes
12:58:06 <hsk3> But it's good to know that they're making it ever more stable.
12:58:08 <hsk3> ROCK SOLID.
12:58:15 <fr33domlover> johnw, I do think you have some hackage packages that won't mind some love but I realize they're useful and being used as they are :)
12:58:26 <johnw> yeah, some of my Hackage stuff is rotting :(
12:58:31 <johnw> guilty
12:58:34 * shapr holds eshell tightly
12:58:54 <fr33domlover> johnw, it's ok, there's a limit to how much you can focus on simultaneously
12:59:15 <fr33domlover> I have repos too that need attention but they do work and I keep using them
12:59:21 <johnw> you can blame Coq for my lack of attention to other projects; it's utterly absorbing
12:59:41 <shapr> you can even PROVE it's absorbing!
12:59:45 <johnw> lol
13:00:09 <lyxia> bizarrefish: if you define a functor corresponding to the nodes of some tree, such as arithmetic expressions: data F a = Add a a | Sub a a | Mul a a | Div a a | Neg a, then Free F is the type of these expressions, and you get certain traversals for free with that definition.
13:00:30 * geekosaur really does not understand that attitude. I should always be adding bugs to my projects?
13:01:13 <Cale> Well, of course it depends on the kind of project.
13:01:49 <Cale> Something which is basically a pure mathematical abstraction can reach a point where it's essentially done a lot more easily than something which encodes a bunch of knowledge about arbitrary web standards.
13:01:51 <bizarrefish> lyxia: So there's nothing really tree-like about the free monad itself?
13:02:00 <foxkroe> hello everybody
13:02:28 <bizarrefish> Though it can of course be used to make trees
13:02:37 <bizarrefish> foxkroe: elo
13:02:47 <the_2nd> I wrote e.g. an IP parser in attoparsec. Now I want to write another parser which waits for some keyword "NOW" and will try to run my parser on the rest of the input (with any char in between)
13:02:49 <Cale> bizarrefish: Well, the recursion through the functor will result in some kind of tree structure.
13:02:53 <hexagoxel> geekosaur: don't you get bug requests in your feature tracker?
13:03:23 <the_2nd> e.g. "somestuffNOWotherstuff   123.221.0.14 otherstuff"
13:03:25 <Cale> bizarrefish: But if you have functions involved in that functor, I suppose you have to imagine it as a perhaps-infinitely-branching tree, with one branch for each possible argument to the function.
13:03:29 <bizarrefish> Cale: Right right. Though it's not...symmetric(?). One of each of the nodes is kinda via a closure.
13:03:38 * hackagebot pinboard 0.9.8 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.9.8 (jonschoning)
13:03:40 <foxkroe> just a really stupid question, is there some kind of module in haskell for virtualization stuff?
13:03:44 <bizarrefish> I'm still grappling with the right terminology to talk about that kinda thing
13:03:44 <jophish> Does there already exist something like this, or is it a little too niche: single :: (Something f) => f a -> Either (f Void) a
13:03:49 <the_2nd> e.g. "somestuff---otherstuff   123.221.0.14 otherstuff" ---not parsing, because of missing NOW
13:04:05 <geekosaur> xmonad core doesn't get many bug reports that aren't compatibility with the latest ghc (or the behavior thereof, we've had "memory leak!" reports somwwhat regularly since8.0.1 came out and I have to point people to the release notes)
13:04:55 <mniip> :t preview
13:04:57 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
13:05:16 <geekosaur> ...mind there's some stuff that needs to change rather badly, the problem is changing them will break compatibility :/
13:06:48 <Cale> bizarrefish: Sometimes it helps to picture a function A -> B as a sort of array, with one box for each value of type A, each of which contains some value of type B.
13:06:52 <Shou> the_2nd: so "NOW" can appear at any point right? The Combinator module of Attoparsec is good for this. Specifically manyTill, assuming you can ignore the stuff preceding "NOW". Otherwise you can do something like `takeWhile (/= 'N')` and see if it's "NOW", before continuing.
13:07:28 <the_2nd> Shou, I later want to parse IPs depending on the keyword beforehand
13:07:40 <the_2nd> e.g. the NOW-IP the OTHER-P etc.
13:07:47 <CubicE> I think people might have figured this out already, but stack is frigging awesome. I can install packages with C dependencies! On windows!
13:07:54 <the_2nd> OTHER-IP
13:08:04 <Cale> bizarrefish: So when we have the constructor GetChar :: (Char -> a) -> IOOps a, that results in an infinitely branched tree node when used
13:08:05 <Cale> er, not really infinitely, sorry
13:08:11 <Cale> There are only finitely many values of type Char
13:08:11 <mniip> jophish, seems similar to 'matching' from lens
13:08:12 <Cale> heh
13:08:22 <Cale> If it were GetLine instead, it would be infinite though
13:08:28 <bizarrefish> Cale: See what you mean
13:08:30 <mniip> :t matching
13:08:31 <lambdabot> APrism s t a b -> s -> Either t a
13:08:39 <bizarrefish> Makes perfect sense
13:08:39 <mniip> :t matching _Just
13:08:41 <lambdabot> Maybe a -> Either (Maybe b) a
13:08:45 <the_2nd> Shou, I tried something like http://lpaste.net/175686   
13:08:51 <the_2nd> but no luck on my end
13:09:10 <the_2nd> within a do, ofc
13:09:22 <bizarrefish> I may have some more questions later
13:09:28 <bizarrefish> for now, thanks for your input :)
13:09:39 <jophish> mniip: hmm, that is quite similar
13:10:01 <mniip> :t matching _Right
13:10:02 <lambdabot> Either c a -> Either (Either c b) a
13:10:47 <mniip> I'm not sure there's a typeclass capturing Prism (f a) (f b) a b
13:11:05 <mniip> like Traversable for Traversal
13:11:17 <Shou> the_2nd: it would be more like `manyTill anyChar (string "NOW") >> parseIP`
13:12:10 <jophish> mniip: it's probably not as useful as I think
13:12:35 <Shou> the_2nd: Also you don't need `return` for Parsers, because they're already monads.
13:12:53 <Jello_Raptor> I'm trying to understand this article ( https://www.schoolofhaskell.com/user/edwardk/bound ) but don't know what this means `newtype Scope f a = Scope (f a)`  especially along with the use of 'Lam( Scope c)` in a data declaration
13:12:53 <the_2nd> Shou, but with another manyTill anyChar in fron of the parser, right?
13:13:10 <the_2nd> yours would only parse "wildcardNOW111.222.111.000"
13:13:45 <NemesisD> i've got a new cabal sandbox. it looks like my global packages have containers-0.5.5.1(for the ghc package). it turns out i need 0.5.7*, but when i try to install my project dependencies, it complains that it can't install 0.5.7 because it conflicts with 0.5.5.1-installed. why is my sandbox considering global packages and can I prefer a local containers
13:14:11 <Jello_Raptor> I don't understand how the newtype can have two type parameters, yet only one is applied in the data declaration. Since `Scope c` should have kind '*-> *'which I thought was illegal 
13:14:19 <Shou> the_2nd: Yeah.
13:14:27 <NemesisD> if it help, it looks like one of my dependencies depends on the `ghc`package which i think depends on the installed containers and is thus instigating the conflict
13:14:28 <mniip> there's nothing illegal about * -> * kinds
13:14:41 <the_2nd> Shou, doesnt seem to be able to stop at a parsers, only [Char]
13:14:45 <mniip> @let data Test f = Test (f Int)
13:14:47 <lambdabot>  Defined.
13:14:49 <mniip> :k Test
13:14:50 <lambdabot> (* -> *) -> *
13:14:52 <mniip> :k Test Maybe
13:14:53 <lambdabot> *
13:15:10 <Shou> the_2nd: Though manyTill returns the "many" part of it rather than the "till" part which you might want. There's a Github issue to add the latter: https://github.com/bos/attoparsec/issues/93
13:15:29 <lyxia> Jello_Raptor: The type constructor Scope has two arguments, but the data constructor Scope has just one, of type (f a).
13:15:36 <Jello_Raptor> mniip: it's closer to `newtype Foo f a = Foo (f a); data Bar a = Bar (Foo a)`
13:15:51 <mniip> not much difference
13:15:52 <Shou> the_2nd: It stops once the second argument succeeds. The Chars get accumulated until that's the case.
13:15:55 <x1f577> any run into this while compiling with ghcjs: .stack-work/dist/x86_64-linux/Cabal-1.22.8.0_ghcjs/: does not exist
13:16:04 <x1f577> what gives?
13:16:08 <mniip> oh well
13:16:14 <mniip> Bar (Foo a) is invalid
13:17:02 <lyxia> Jello_Raptor: values don't have kinds, they have types.
13:17:06 <Jello_Raptor> Shou: huh? but don't we need a type constructor there since that ends up being the same as `Lam :: Scope a -> Exp a`
13:17:14 <mniip> Jello_Raptor, so what are you having issues with exactly
13:17:50 <mniip> data Exp a = ... | Lam (Scope Exp a)
13:17:58 <mniip> Lam :: Scope Exp a -> Exp a
13:18:15 * Jello_Raptor facepalms 
13:18:37 <Jello_Raptor> I'm also looking at the corresponding slides http://www.slideshare.net/ekmett/bound-making-de-bruijn-succ-less 
13:18:48 <Jello_Raptor> and that's a typo on slide 17 :V 
13:19:15 <Jello_Raptor> it's correct in the article, but I didn't diff the two pieces of code properly 
13:20:13 <mniip> yeah
13:20:16 <mniip> looks like a typo
13:20:22 <mniip> bad edwardk
13:20:48 <hexagoxel> NemesisD: maybe try installing a 0.5.7* version manually. i think cabal will accept that once it already is there.
13:21:19 <Jello_Raptor> mniip: honestly 90% of the time something like that happens it's me misunderstanding some crazy type system shenanigan edwardk is pulling. 
13:21:46 <NemesisD> hexagoxel: globally? because i did that in the sandbox and it then complains that the sandbox 0.5.7 conflicts with the global 0.5.5.1 which is dragged in by the ghc package
13:22:06 * Jello_Raptor is actually kinda chuffed that it wasn't *him* doing something stupid this time :P 
13:23:32 <funfunfun> what is a great/the best cheap way of having access to a highly multicore machine (e.g. 8+ cores)
13:24:35 <hexagoxel> NemesisD: no, all in sandbox. sandbox vs user-global should not make any difference.
13:24:56 <hexagoxel> NemesisD: maybe install ghc manually as well, togehter with the right containers
13:25:18 <kaol> funfunfun: https://www.parallella.org/
13:25:23 <shapr> funfunfun: you can easily get 10 cores in a desktop
13:25:36 <kaol> Cheap?
13:25:44 <NemesisD> hexagoxel: ghc is not a packalge you can install. its some sort of pseudo package to your system ghc
13:25:53 <funfunfun> i found that facebook was dumping 8 core xeons with 20 mb cache for $70 each
13:26:07 <NemesisD> hexagoxel: which i think is why when you depend on it you get the exact dependencies it carries (th, containers) injected into your dependencies
13:26:59 <NemesisD> hexagoxel: also installing containers-0.5.7.1 globally doesn't work either
13:27:12 <hexagoxel> NemesisD: ah, right. is using ghc-8 an option?
13:27:15 <Jello_Raptor> also somewhat relatedly is there some abstraction that works well to encode multiple ADTs that are subsets of each other? like for compilation, you have the ADT for your AST and you want to replace constructs in it with lower level constructs (turn for loops into while loops). Ideally without creating 15 different ADTs for each version of the structure with slightly different sets of allowed constructors. (Adding tags to the type 
13:27:15 <Jello_Raptor> with GADTs might work, but i'm not sure)
13:27:50 <NemesisD> hexagoxel: nope. not yet anyways. we're on 7.8. and we're not able to move to stack yet which makes this much more hellish to work with
13:28:44 <NemesisD> i'm sure moving to 7.10 would probably incidentally upgrade containers enough to make this a non issue, but that's not so simple either
13:28:56 <hpc> jeltsch: what you describe is pretty much subtyping
13:29:13 <hpc> Jello_Raptor*
13:30:29 <Gurkenglas> Atom tells me I have a ghc 7.10.2 on my path, which conflicts with my ghc-mod 7.10.3. How do I make stack fix that?
13:30:38 <dfeuer> NemesisD, what's your containers issue?
13:30:45 <Jello_Raptor> hpc: subtyping exists in a functional context?
13:31:23 <NemesisD> dfeuer: ghc-7.8. have a sandbox. depend on the "ghc" package, which brings in containers-0.5.5.1, i need something newer like 0.5.7 in my project
13:31:29 <dfeuer> Ahhh.......
13:31:34 <hpc> not in haskell, but it gives you something to google for
13:31:39 <hpc> there's questions on SO and whatnot about this
13:31:47 <acrofus> how to install hasktags with ghc 8?
13:31:49 <quchen> Gurkenglas: I simply ignored that warning until now.
13:31:49 <dfeuer> NemesisD, you need a newer function?
13:31:53 <NemesisD> i'm attempting to build the project with 7.10 but i'm not optimistic
13:32:01 <Jello_Raptor> hpc: ahh I'm looking for haskell patterns specifically
13:32:02 <hpc> Jello_Raptor: there's some lengthy answers but it does look like GADTs or type classes is the way to go
13:32:09 <NemesisD> dfeuer: i believe its to permit a newer deepseq, which a thing i'm installing requires
13:32:09 <hpc> Jello_Raptor: depending on the operations you end up needing
13:32:14 * Jello_Raptor nods
13:32:34 <dfeuer> NemesisD, oh, that horribleness. Sorry about that.
13:32:56 <dfeuer> deepseq kind of threw a monkey wrench by changing the definition of the NFData class.
13:33:07 <NemesisD> yikes
13:33:23 <dfeuer> That was a few years ago now, wasn't it?
13:33:51 <NemesisD> probably :/
13:34:07 <Gurkenglas> quchen, I have here a single CabalFreeze.hs that is supposed to be run with "stack CabalFreeze.hs", Atom says that it could not find the modules (that are not in base) that are imported. How do I fix that?
13:34:41 <quchen> Gurkenglas: I’ve never had this issue. I now have a new issue (namely that all my Haskell stuff is broken since I upgraded to Atom 1.9), but that sounds different.
13:35:50 <Gurkenglas> You mean that your single .hs files outside of projects are compiled without complaint?
13:38:32 <dfeuer> NemesisD, actually... the NFData class *did* change, but way back in 2009, version 1.1.0.0. I don't think it's changed since. Its default definition of rnf has changed, but I doubt that would affect containers.
13:44:45 <Gurkenglas> mgsloan, can you add a command to stack that runs that version of ghc-mod on the target which fits with the ghc version used? Then atom could point to that instead of some particular ghc-mod version
13:45:51 <ggws> is there a way to do 'typed forth programming' in haskell via point-free/point-less style ?
13:49:12 <yyyyy> ggws: you might be interested in https://www.stackage.org/lts-6.11/package/concatenative-1.0.1
13:50:48 <ggws> yyyyy: I was thinking along the lines of typed heterogeous lists, but this looks fasicnating
13:50:48 <hvr> NemesisD: 'ghc' is not a pseudo-package... it's a normal package, but one for which you have no source-tarball to reinstall it
13:53:19 <yyyyy> ggws: in this case i think you can use `hlist`, but usually it's not a good idea, imho.
13:53:25 <hvr> dfeuer: the NFData class didn't change in 1.1, it was introduced with 1.1 :-)
13:53:40 <hvr> dfeuer: deepseq-1.0 and deepseq-1.1 are totally different APis
13:53:40 * hackagebot shellmate 0.3.3 - Simple interface for shell scripting in Haskell.  https://hackage.haskell.org/package/shellmate-0.3.3 (AntonEkblad)
13:53:42 * hackagebot shellmate-extras 0.3.3 - Extra functionality for shellmate.  https://hackage.haskell.org/package/shellmate-extras-0.3.3 (AntonEkblad)
13:53:52 <Jello_Raptor> ok, so next question. In that same article, I don't understand how the type in B&P Part actually stores a lambda term, I don't get how the representations of (\ x -> (\ y -> x y)) would be different from (\ y -> (\ x -> x y)). Trying to write out either gives me `Lam( Lam(App (Var (Just (Just 'x'))) (Var (Just (Just 'y')))))` but the two original functions are clearly different :/ 
13:53:56 <hvr> dfeuer: and unfortunately many package authors forget to put in a lower bound
13:54:17 <Jello_Raptor> B&P:Part 1* the article: https://www.schoolofhaskell.com/user/edwardk/bound
13:54:50 <ggws> yyyyy: yeah, hlist is interesting. Quoting SO: 'The question for any of these packages is the scope of its goals. HList is actually 5 different implementations of labels, two of type equality, two of type casting, two of Record/RecordP, and the Variant vs TIC choice. All all similar but are different trade-offs of ease of use, portability, and extensions used.'
13:56:28 <lyxia> Jello_Raptor: you're not supposed to use char to represent variables, but the nesting of Just and Nothings.
13:56:38 <sal23> hello, looking for some pointers with pandoc api...will very much appreciate help from those in the know
13:57:04 <sal23> trying to figure out how to set pandoc command line options through the api instead
13:57:12 <siwica> In ParsecT s u m a, does 'm' represent the monad or is 'm a' a monad with inner value a?
13:57:52 <Jello_Raptor> lyddonb: ahh okay, I see. so It'd be  `Lam( Lam(App (Var (Just Nothing)) (Var Nothing)))` instead? 
13:58:01 <lyxia> yeah
13:58:34 <lyxia> Jello_Raptor: Exp Void should be the type of closed expressions. Exp (Maybe Void) is the type of expressions with (at most) one free variable. etc.
13:59:07 <the_2nd> Shou, still cant make it work with another parser
13:59:16 <johnw> wouldn't Exp (Maybe Void) Just be Exp ()?
13:59:25 <lingxiao> hey all I hava  problem with stack
13:59:29 <lingxiao> I setup a project using `stack new foo`
13:59:49 <the_2nd> Shou, http://lpaste.net/3401477054615519232
14:00:01 <lingxiao> In /app/Main.hs  I am importing Lib from /src/Lib.hs
14:00:11 <lingxiao> but I am getting could not find module `Lib` error
14:00:45 <lyxia> johnw: yeah, the types are isomorphic but the technique described uses nested Maybes in a more general way.
14:01:39 <ggws> is there a way to do typed stacks with just DataKinds ?
14:01:46 <ggws> [this is reinventing the wheel, but I want to understand it from first principles]
14:01:51 <lyxia> siwica: We say that m is the monad
14:02:35 <the_2nd> Can someone help me with my parser? It should find any Hex string after some keyword (with any text inbetween)
14:03:03 <siwica> There is also a Type 'type Parsec s u = ParsecT s u Identity' so Identity must somehow take the place of 'm a'?
14:03:07 <the_2nd> http://lpaste.net/3401477054615519232     line 7 wont compile, since manyTill wants a [Char] as second argument. Is there some way to use a parser here?
14:04:09 <geekosaur> siwica, Identity is the m
14:04:27 <mgsloan> lingxiao: IS the "foo" library in the deps list of the executable stanza in the cabal file?
14:05:23 <geekosaur> in ParsecT s u m a, a is the result of a computation in ParsecT (but not necessarily involving m)
14:05:36 <lyxia> the_2nd: manyTill will throw away the result of its second argument
14:05:49 <lyxia> the_2nd: whereas it seems like that's what you want to return
14:05:59 <lingxiao> mgsloan i'm not sure which one you're referring to? but here's my .cabal file
14:06:06 <lingxiao> http://lpaste.net/
14:06:07 <siwica> Ok. But where does the 'a' go?
14:06:11 <lingxiao> http://lpaste.net/175698
14:06:12 <the_2nd> lyxia, It wont accept a parser anyway
14:06:33 <geekosaur> if the a went with the m, it'd be ParsecT s u (m a) b -- since you'd still need somewhere for the result of a ParsecT computation. but that would be wrong, since m is something that produces a result and the result type is not specified as part of the monad, or it'd be useless in practice
14:06:37 <lyxia> the_2nd: sorry?
14:06:48 <geekosaur> (put otherwise, the kind of m is m :: * -> *)
14:06:54 <the_2nd> "parseHex" cant be used in manyTill
14:07:21 <geekosaur> sometimes you do see things that need extra parameters, but this is not one of those times
14:07:54 <mgsloan> lingxiao: Hmm, yeah, "CleanText" is in the "CleanText-exe" executable stanza
14:08:17 <lyxia> the_2nd: how's parseHex defined
14:08:26 <lingxiao> mgsloan yeah for what it's worth i'm just loading Main.hs into ghci right now
14:08:38 <lingxiao> should I build the project somehow?
14:08:40 <the_2nd> Parser Hex
14:08:41 * hackagebot hgeos 0.1.8.0 - Simple Haskell bindings to GEOS C API  https://hackage.haskell.org/package/hgeos-0.1.8.0 (rcook)
14:08:48 <lyxia> the_2nd: and why do you think parseHex can't be used in manyTill
14:09:01 <lyxia> the_2nd: that's the type. What's the definition?
14:09:33 <lingxiao> ahh yeah mgsloan i didnt do stack setup and stack build
14:09:57 <the_2nd> lyxia, http://lpaste.net/3018023929206800384
14:10:57 <lyxia> the_2nd: manyTill :: Parser a -> Parser end -> Parser [a]   <--- the second argument can be ANY parser
14:11:03 <lyxia> the_2nd: parserHex is a parser
14:11:40 <lyxia> The problem is that by passing it anyChar :: Parser Char, the result must have type Parser [Char], which clashes with your type signature Parser Hex
14:12:10 <ggws> yyyyy: https://github.com/leonidas/codeblog/blob/master/2012/2012-02-17-concatenative-haskell.md is beautiful and what I'm looking for
14:12:57 <the_2nd> lyxia, so define a new parseHexString, which is Parsers [Char]?
14:13:05 <the_2nd> -s
14:14:16 <lyxia> Can you describe in more detail what you want?
14:14:35 <the_2nd> lyxia, got to go now, I'll try it tomorrow and come back 
14:14:43 <lyxia> ok
14:14:49 <the_2nd> sorry to abort here, but thanks for your time and help
14:15:06 <geekosaur> siwica, did you miss where I said that?
14:15:16 <geekosaur> [10 21:05] <geekosaur> in ParsecT s u m a, a is the result of a computation in ParsecT (but not necessarily involving m)
14:16:11 <geekosaur> the "a" tjhat goes with the "m" normally is not specified; ParsecT expects something of kind (* -> *), which is to say, something which is normally of the form (m a). you only specify the "m".
14:17:11 <geekosaur> for example, (ParsecT () () Maybe a) is valid; the a is the result of the ParsecT, and Maybe is something which normally takes an additional parameter that does not need to be specified here.
14:17:31 <geekosaur> :k Text.Parsec.ParsecT
14:17:33 <lambdabot> * -> * -> (* -> *) -> * -> *
14:18:08 <geekosaur> corresponding to s u m a and the resulting type
14:18:47 <geekosaur> the m is the (* -> *) part meaning you specify something that takes a type parameter (Maybe, IO, Identity, State MyState, ...)
14:19:24 <lingxiao> ok I'm building my project using stack
14:19:40 <lingxiao> and I'm getting error: http://lpaste.net/175700
14:20:05 <lingxiao> but as you can see: http://lpaste.net/175700
14:20:13 <lingxiao> I have conduit-extra in my build-depends
14:23:05 <siwica> geekosaur: thank you! (I was in the kitchen so didn't respond right away)
14:26:07 <siwica> So omitting the a makes 'Parsec s u' a function with parameter a?
14:26:25 <lingxiao> hey all I am getting this error in the following file:
14:27:01 <geekosaur> siwica, a type function, yes
14:27:48 <geekosaur> it's been eta reduced since in 'type Parsec s u a = ParsecT s u Identity a' the "a" is redundant. It knows from the kind of ParsecT that the "a" needs to be added back
14:27:48 <lingxiao> http://lpaste.net/175704
14:27:55 <lingxiao> no instance for resourcet
14:28:05 <lingxiao> funny thing is this problem didnt occur before i cabal installed resourcet
14:28:12 <lingxiao> and the code still compiled and ran fine
14:28:29 <geekosaur> (it will always add that back, because ghc can't as yet handle partially applied type functions)
14:29:19 <mgsloan> lingxiao: Huh, did you cabal install to the global DB?  It's possible that stack accidentally assumes a clean global DB, since that's usually how it's run
14:29:49 <siwica> geekosaur: oh, I didn't know it would add it back
14:30:36 <lingxiao> yeah I just did cabal install resourcet
14:30:42 <lingxiao> actuall mgsloan what is the workflow here?
14:30:44 <siwica> So 'type Parsec s u a = ParsecT s u Identity a' wouldn't be equally correct?
14:30:53 <geekosaur> siwica, yes
14:30:54 <lingxiao> how do I cabal install so things work out nicely with stack
14:30:57 <geekosaur> just redundant
14:31:17 <siwica> so it would or wouldn't?
14:31:24 <sm> trying to use cabal and stack in the same project is just asking for pain
14:31:30 <geekosaur> it would be equally correct, sorry
14:31:37 <mgsloan> Yeah, it isn't intended to be used that way, you should just use stack
14:31:47 <geekosaur> lingxiao, that strikes me as a bad idea. stack does a bit more with stuff you install than cabal does, cabal has no idea how to update stack's metadata
14:31:49 <siwica> geekosaur: ok, that makes sense!
14:31:52 <lingxiao> so how do I install files using stack
14:32:06 <lingxiao> ok so geekosaur so you're saying never use cabal?
14:32:08 <mgsloan> Add them as dependencies and they'll get built when you build your project
14:32:10 <lingxiao> only use stack?
14:32:27 <siwica> Don't you think it's better style to still add it for clarity although it's redundant?
14:33:05 <geekosaur> lingxiao, actually fpr the stuff I do I just use cabal, because mostly its xmonad-related and futzing with sandboxes for the thing that initiates your OS session is just asking for random stuff to land in that sandbox instead of the one you intended to use
14:33:44 <lingxiao> mgsloan so the workflow is if i need a package  just add it to my .cabal file and if i dont have it, then when i run stack build  it'll pull the package automatically?
14:34:04 <lingxiao> geekosaur , conceptually is stack creating a sandbox where packages gets installed ?
14:34:10 <dysfun> yes
14:34:12 <dysfun> to both
14:34:15 <geekosaur> if you are using stack at all in a project, use stack for everything in that project. if you are using cabal sandboxes at all, use the cabal sandbox for everuthing in that project
14:34:20 <yyyyy> ggws: hadn't seen that before. looks cool!
14:34:21 <geekosaur> otherwise you're just going to hurt a lot
14:34:25 <lingxiao> ok I'm going to use stack
14:34:47 <lingxiao> so is there an equiavlanent of stack install like cabal install?
14:34:55 <geekosaur> lingxiao, conceptually yes. practically, it keeps stuff in a "global" stash and imports compatible already-built stuff into a stack sandbox when it can
14:34:58 <lingxiao> because I put conduit-extra in my .cabal file
14:35:03 <lingxiao> and it's thorwing error saying I dont have it
14:35:06 <maerwald> isn't there a #haskell-stack channel or something?
14:35:20 <lingxiao> maerwald didnt know that  is it popular?
14:35:27 <dysfun> not nearly as popular
14:35:32 <lingxiao> ok maybe i'll stay here then
14:35:40 <dysfun> plus you don't irritate all the stack haters nearly as much by asking in there
14:35:46 <geekosaur> and stack will not check your user package db that cabal uses by default (the sandbox is in place of that database, so it can't see the original)
14:35:47 <monochrom> stay in both. ask in both. profit.
14:35:55 <yyyyy> how do you export a type operator like `type f $ x = f x`? someone pointed me to this solution, but i can't seem to satisfy GHC in letting me export it.
14:35:59 <andromeda-galaxy> Another question that has stack in it but does not actually relate to stack: I am trying to use liquid haskell with a Stack-installed local ghc 7.10.3 (my systemwide ghc is 8.0.1)
14:36:08 <geekosaur> likewise a cabal sandbox will hide your normal cabal database
14:36:57 <andromeda-galaxy> Unfortunately, running the resultant binary results in: liquid: /usr/lib/ghc-7.10.3/settings: openFile: does not exist (No such file or directory)
14:37:18 <sm> lingxiao: do you also have exes, tests suites, or benchmarks in your cabal file ? if so those may need build-depends updated also
14:37:19 <monochrom> yyyyy: I wonder if "module M(($))" works. I haven't tried.
14:37:24 <andromeda-galaxy> I think the problem is that some dependency (no idea which one) is hardcoding the GHC Libdir path given to the ghc api, possibly
14:37:31 <monochrom> But I admit that if it doesn't work, I don't know what works.
14:37:32 <geekosaur> yyyyy, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#explicit-namespaces-in-import-export
14:37:42 <yyyyy> monochrom: it worked with `type ($)` using `ExplicitNamespaces`
14:37:47 <geekosaur> you need to enable the ExplicitNamespaces extensions so that you can tell it... yes that
14:37:49 <yyyyy> geekosaur: yes! thank you :)
14:38:04 <monochrom> You know what, actually it may be true that type synonyms are always exported.
14:38:12 <lingxiao> sm yup you're right
14:38:21 <andromeda-galaxy> So my two questions are 1) why would this be happening (shouldn't GHC.Paths be able to have the correct value? I don't know if that's being used, but it seems like it should be...) and 2) is there any easy way around it?
14:38:48 <andromeda-galaxy> I have tried binary-patching the resultant binary to use the correct path, but that path is too long
14:38:53 <monochrom> I like ExplicitNamespaces. Finally.
14:39:05 <lingxiao> hey sm so II'm seeing this error:
14:39:05 <lingxiao> http://lpaste.net/175706
14:39:18 <monochrom> (oh, "finally" means "it is finally available!")
14:39:21 <lingxiao> everything in Gneric, NormDigit and Tworkenize should be exported by Lib
14:39:36 <sm> lingxiao: paste your full cabal file if you like
14:39:47 <ertes> monochrom: i like the sound of that…  what is it?
14:39:57 <lingxiao> http://lpaste.net/175708
14:40:05 <geekosaur> ertes, I pointed to it above
14:40:07 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#explicit-namespaces-in-import-export
14:40:15 <lingxiao> sm so every function that needs to be exported from library will be exported by Lib.hs
14:40:17 <yyyyy> monochrom: it looks useful and quite harmless. i wonder if it's easier to always leave it enabled.
14:40:38 <lingxiao> under this assumption do I still need to list the other modules in CleanText.Cabal as the warning message suggested?
14:40:43 <lingxiao> I'm just rying to grasp how stack works
14:40:59 <sm> this is a cabal thing. Yes you should list them as other-modules:
14:41:45 <ertes> ah
14:41:48 <lingxiao> sm sorry were you addresing me?
14:41:48 <ertes> thanks
14:41:50 <monochrom> oh wait, it only adds the "type" keyword.
14:41:52 <sm> lingxiao: yes
14:41:53 <lingxiao> what do you mean list them as other-modules
14:42:05 <ertes> i thought it's something groundbreaking that has finally become available with GHC 8, and i somehow missed it =)
14:42:19 <geekosaur> monochrom, also "pattern"
14:42:22 <andromeda-galaxy> I also thought about using binfmt_misc to use process-specific mount namespaces to fix the problem, but that didn't work because only the first 128bytes can be used to look up what kind of binary it is, so it would get detected as ELF. A custom ELF interpreter might work, but that's a little nasty...
14:42:54 <monochrom> I was looking for the utopian general picture in which you get to say: module M(kind X, type X, constructor X, family X, this X, that X...)
14:43:20 <geekosaur> request it? :)
14:43:28 <sm> lingxiao: other-modules is another field just like exposed-modules, for modules which should be compiled but should not be exported. 
14:43:35 <sm> more details at https://www.haskell.org/cabal/users-guide/developing-packages.html 
14:43:42 * hackagebot preliminaries 0.1.1.0 - A larger alternative to the Prelude.  https://hackage.haskell.org/package/preliminaries-0.1.1.0 (yghor)
14:44:03 <geekosaur> well. they're exported, theyre not *exposed*
14:44:05 <yyyyy> in other topic, how do you get documentation to show up in hackage? do i have to enable something in my cabal file? it says “pending” forever.
14:44:35 <geekosaur> yyyyy, the buildbot should be building stuff and putting the docs up as a side effect of building. if it can't build your package, it won't put up docs
14:44:36 <lingxiao> sm so like this: http://lpaste.net/175708
14:44:42 <sm> yyyyy: you may have to offer a chicken
14:44:44 <ertes> i'd actually prefer for some things if we could specify whether it's exported at its definition
14:44:51 <geekosaur> you may have to ask in #hackage if something is not building for a long time
14:44:58 <lingxiao> also sm every time I change something in .cabal file should I do [stack build] again?
14:45:01 <geekosaur> (it may be processing a backlog of packages though)
14:45:06 <lingxiao> or it suffices to reload main
14:45:43 <sm> lingxiao: do you mean :reload in GHCI ? if you change the cabal file, you'll need to :quit and restart ghci
14:45:48 <yyyyy> sm: does a macaw cut it? i live in rio.
14:46:06 <lingxiao> sm  just to clarify you mean stack ghci right?
14:46:16 <lingxiao> but now need to run [stack build] again
14:46:26 <sm> lingxiao: and if you added new dependencies to the cabal file, you'll probably need to stack build --only-dependencies 
14:46:31 <yyyyy> geekosaur: locally it fails for this package when i 'stack haddock', but this is the first i build for GHC 8.0.1. maybe it's related.
14:46:45 <lingxiao> sm ok cool but I can also do [stack build] right?
14:46:57 <lingxiao> suppose I was lazy and don't want to type out all that letters
14:47:01 <lingxiao> nothing would break correct?
14:47:03 <sm> sure, that works
14:47:04 <geekosaur> well, "pending" means it hasn't gotten to it yet. if it had failed, it would say so and have a link to the build log
14:47:10 <sm> it builds your stuff as well
14:47:18 <monochrom> to avoid typing on the keyboard, use speech recognition :)
14:47:30 <sm> which may help stack ghci load a little quicker
14:47:40 <monochrom> great Scotty demonstrated how. pick up mouse. start speaking.
14:48:09 * sm wishes stack allowed abbreviated flags like cabal
14:48:34 <geekosaur> alias sb='stack build --whatever --whatever-else ...'
14:48:37 <yyyyy> monochrom: OT: how do you handle text editing using speech recognition?
14:48:49 <yyyyy> “delete a paragraph”
14:48:59 <monochrom> I haven't thought how. But TIL "gap buffers".
14:49:27 <Gurkenglas> Perhaps Atom could start working if I nuked everything and started over? Is there a way to remove all Haskell stuff from my system?
14:49:28 <geekosaur> train speech recognition to watch for command introducers. one person I know used cussing until they started cussing about something else with the editor open >.>
14:49:40 <yyyyy> that's related to the topic of my doctorate thesis — unfinished yet.
14:49:42 <geekosaur> *listen for
14:50:19 <yyyyy> i study effort analysis for interaction, and text is one scenario.
14:50:39 <monochrom> I think you should talk to people who have done pair programming for a long time for how to edit text by speech.
14:51:09 <yyyyy> i have some literature on the subject, but was curious on some field reports :)
14:51:25 <yyyyy> haven't thought about pair programmers
14:51:52 <yyyyy> (“have” meaning “a local copy”, not published material)
14:52:30 <monochrom> now, of course, it's a bit unfair, the typer is a human, much more advanced than any known algorithm. still, they are the closest (or least furthest) to it today.
14:53:11 <mgsloan> sm: What sort of abbreviations?  Feel free to open an issue!
14:53:42 <lingxiao> sm can I ask you conceptually what goes into the /app directory vs /src directory?
14:53:54 <lingxiao> and what should be in /app/Main.hs
14:54:06 <lingxiao> or more importantly what should NOT be in Main.hs
14:54:14 <yyyyy> monochrom: using a human for it in the literature is called “wizard of oz” experiments, and it's quite accepted as a “best alternative” for comparison.
14:54:24 <monochrom> hehe
14:54:47 <sm> mgsloan: ie accept any unique prefix of a flag. Allows for some nice adhoc typing savers, like cabal install --dry --only-dep
14:55:20 <andromeda-galaxy> Sorry to repeat this so quickly, but in case it was lost in that flood of activity that showed up as I joined:
14:55:42 <andromeda-galaxy> Basically, does anyone have any ideas how to stop my binaries from complaining about /usr/lib/ghc-<vesrion>/settings
14:55:52 <andromeda-galaxy> when my ghc is installed to an unusual place?
14:56:16 <sm> lingxiao: that's just a convention of whatever project template you're using. Probably it's intended that things in src are library functions, possibly exported for other packages, things in app are executables, not exported
14:56:57 <lingxiao> sm so by executables are things that are very specific to this project right?
14:57:01 <mgsloan> sm: Interesting!  I think the idea is that CLI completion is better
14:57:04 <lingxiao> like theres no way someone else could make use of the stuff?
14:57:13 <lingxiao> since it's so project specific?
14:57:15 <mgsloan> This way we avoid confusing people by a proliferation of flag vrariants
14:57:36 <mgsloan> (not sure if that would happen)
14:58:51 <sm> I've never set up CLI flag completion, I'd have to do that on every machine etc.
14:59:29 <sm> it's just a small thing, but I enjoy it. I agree it probably shouldn't be widely used in docs etc.
14:59:55 <sm> it works with many haskell apps, so I miss it in stack
15:02:26 <sm> lingxiao: executables are command line programs. Not all haskell packages have them. Usually, they are a small front end with most of the functionality being in a reusable library
15:02:42 <lingxiao> ok got you! thanks a lot 
15:03:18 <sm> if you browse some haskell projects, you'll get a feel for it very quickly
15:05:09 <jonored> Strictly speaking, GUI executables are probably also in app :)
15:06:27 <sm> true. executables are programs an end user can run.
15:08:52 <acowley> cocreature: bscarlet's llvm-3.8 branch doesn't work for me
15:12:52 <acowley> I see it's missing the last main compatibility commit I authored
15:16:07 <acowley> cocreature: Well, your fork still works.
15:16:35 <acowley> I misunderstood in that I thought your branch had been merged
15:19:50 <implementation> @pl \a -> a []
15:19:51 <lambdabot> ($ [])
15:20:17 <implementation> that looks ugly :(
15:22:35 <monochrom> how do you like ([] &)? & is flipped $.
15:24:21 <implementation> actually that looks even more obscure and like a punctuation battle
15:24:41 <zort> neither parse in Perl, sadly
15:24:43 <pie_> yay perl
15:24:56 <pie_> aw zort was faster
15:26:33 <lingxiao> hey coudl someone familiar with conduit or pipes tell me what is the value add of such library wrt this: 
15:27:38 <yyyyy> implementation: i think `&` makes lots of things easier to read
15:27:42 <lingxiao> mainSimple f1 f2 = readFile f1 >>= \xxs -> let xxs' = (unpack . preprocess . pack $ xxs) in writeFile f2 xxs'
15:27:42 <yyyyy> behold
15:27:47 <yyyyy> > [] & head
15:27:49 <lambdabot>  *Exception: Prelude.head: empty list
15:27:51 <lingxiao> sorry lpaste is down
15:27:58 <lingxiao> ops back: http://lpaste.net/175721
15:28:20 <lingxiao> or suppose we did some lazy version of readfile
15:28:43 * hackagebot ekg-statsd 0.2.1.0 - Push metrics to statsd  https://hackage.haskell.org/package/ekg-statsd-0.2.1.0 (JohanTibell)
15:29:45 <glguy> readFile is the lazy version
15:29:48 <enthropy> lingxiao, if that's all you're doing to the data, I think lazy IO is probably going to work for you
15:30:07 <lingxiao> enthropy so what is the value add of conduit or pipes then?
15:30:23 <Welkin> lingxiao: processing huge amounts of data in constant memory
15:30:25 <lingxiao> I'll also be doing some sort of regular expression like operations on the Text, using parsec not regex
15:30:31 <lingxiao> Welkin my data is pretty huge
15:31:50 <pikajude> I remember reading an article a few weeks ago where, instead of doing HTTP or DB requests directly in your code, you pass around a record type that has a function that does each of those things
15:31:57 <lingxiao> if the data is huge why is lazyIO bad  enthropy and Welkin
15:31:59 <pikajude> does anyone know what I'm talking about and/or what that's called
15:32:23 <chrisbarrett> pikajude: are you thinking of the Free monad?
15:32:25 <Welkin> can't lazy IO build up lots of thunks?
15:32:34 <pikajude> the Free monad is way more general than what I'm thinking of
15:32:42 <johnw> pikajude: sounds very close to the van Laarhoven free monad, actually
15:32:44 <hpc> lingxiao: consider something like lazily reading the entire contents of a terabyte file
15:32:51 <pikajude> I think it was van Laarhoven
15:32:58 <johnw> pikajude: or, just encoding "objects" as records of functions
15:32:59 <hpc> lingxiao: how to you know you aren't going to kill your machine?
15:33:12 <pikajude> it was like data Eff m = Eff { runHttp :: Request -> m Response, ... } and MonadReader (Eff m) m
15:33:23 <lingxiao> hpc kill machine as in overflow it?
15:33:33 <hpc> lingxiao: you have to inspect your entire pipeline of consuming that data
15:33:42 <jonored> I think a lot of the trick is that lazy I/O, while you /can/ avoid a space leak and it should be fine, doesn't help you to avoid it.
15:33:49 <hpc> because it could end up being you read it in chunks or maybe you need the whole file
15:34:00 <Welkin> pipes is easy to use
15:34:02 <pikajude> oh right, now I remember this. I looked at free-vl but it was very confusing to me
15:34:27 <lingxiao> hpc so with conduit/pipes  even if I need the whole file, it gaurantees that I am not opening the whole file?
15:34:31 <lingxiao> so lazy IO is not always lazy?
15:34:39 <hpc> or you're keeping a reference to the original "give me all the file" variable and now your good pipeline never frees anything
15:34:45 <lingxiao> Welkin do you find it easier than conduit... since I started in conduit
15:34:47 <hpc> lingxiao: conduit is not lazy IO
15:35:01 <Welkin> lingxiao: I find pipes easier to understand and use
15:35:03 <Welkin> I like it better
15:35:08 <johnw> pikajude: I can help de-confuse, if you want
15:35:08 <lingxiao> hpc right I mean in the case where i dont use conduit or pipes
15:35:20 <hpc> ah
15:35:30 <hpc> well with conduit, you at least have control
15:35:35 <lingxiao> Welkin oh boy... I've been using conduit for a few days now and theres a lot of inertia :(
15:35:43 <lingxiao> which one is more actively used in the commnity?
15:35:44 <Welkin> either one is fine
15:35:47 <Welkin> people use both of them
15:35:48 <pikajude> johnw: I'll take you up on that
15:35:51 <lingxiao> for esxample i know Wagon use conduit 
15:35:56 <hpc> because the timing of reading that file happens outside of plain old evaluation
15:36:04 <lingxiao> ok cools thanks
15:36:12 <hpc> and what parts of the file are kept around is controlled entirely by what references you carry around
15:36:13 <lingxiao> hpac refering to lazy io or conduit?
15:36:26 <lingxiao> oh conduit you mean
15:36:34 <hpc> there's no "this is the contents of the whole file" variable for you to make a mistake with, using conduit
15:37:13 <lingxiao> hpc ahh i see
15:37:16 <lingxiao> very fascinating
15:37:31 <hpc> that's just an example, this generalizes to all forms of lazy IO
15:37:49 <lingxiao> by this you mean:  this is the contents of the whole file" variable 
15:37:54 <hpc> you don't know if a resource is freed at a given line of code, etc
15:38:33 <lingxiao> so hpc when I read something in conduit like:   source $$ pipe1 =$ pipe2 =$ sink
15:38:49 <lingxiao> what assumptions can i make about resources at each one of those functions ?
15:38:59 <yyyyy> i like the fact that conduit has resource control built-in
15:39:00 <johnw> pikajude: I have an implementation of free-vl in Coq, which makes a lot of the magic more explicit, if you can get past the syntax; Haskell is able to play more tricks, but it makes the underlying logic harder to see, in my opinion
15:39:42 <yyyyy> i don't know how pipes handles resource safety in the presence of exceptions
15:39:50 <pikajude> johnw: it just looks very verbose to me
15:40:11 <lingxiao> funny I thought coq was verbose too when i started
15:40:28 <lingxiao> after one class of basic coq i thought it was somehow more intuitive than haskell... at least in certain aspects
15:40:30 <johnw> it _is_ generally more verbose, but that can make things clearer, ironically
15:40:38 <johnw> you can clearly see what's going on
15:40:42 <lingxiao> certainyl with dependent types
15:40:55 <johnw> instead of relying on tricky typeclass lookup in Haskell
15:42:52 <pikajude> I don't mean coq, I mean using the free monad
15:43:15 <johnw> oh!
15:43:22 <johnw> it's usually only verbose if you aren't using smart constructors
15:43:27 <johnw> or pattern synonyms
15:43:30 <pikajude> oh, ok
15:43:41 <hpc> lingxiao: right away, the IO is far more visible via (=$) and you know what order pipe1 and pipe2 are going to happen in
15:44:03 <lingxiao> oh ... hmm so with lazy IO there's no gaurantee of order ?
15:44:26 <hpc> lazy IO is tied to evaluation, and evaluation as defined by the haskell report has no order
15:44:53 <hpc> there's not only no guarantee of order, but no guarantee of even HAPPENING
15:44:59 <hpc> if you just ignore the result
15:45:08 <lingxiao> wow thats amazing
15:45:20 <hpc> it's not like threads where "i'll just run this in the background"
15:45:28 <lingxiao> but if you're doing function1 :: a -> b then apply function2 :: b -> c
15:45:32 <lingxiao> doesnt the type gaurantee order?
15:45:50 <lingxiao> or are we talking about different things here
15:45:53 <hpc> not that kind of order
15:46:19 <lingxiao> could you elaborte ?
15:46:22 <hpc> imagine foo :: a -> a -> b
15:46:26 <hpc> which 'a' is first?
15:46:37 <lingxiao> oh i see it doesnt matter ... 
15:46:41 <hpc> or let's do this
15:47:15 <hpc> hasBugs = do {s <- lazyReadFile; munge s}
15:47:19 <lingxiao> but if computation on 2nd a depend on result of computation on 1st a then wouldnt 1st a get evlauted first
15:47:31 <hpc> but you can't figure out what bugs it has, so maybe you diagnostically print something
15:47:36 <hpc> hasBugs = do {s <- lazyReadFile; print s; munge s}
15:47:40 <hpc> but now the bug is different!
15:47:48 <lingxiao> why is there a bug there?
15:47:50 <hpc> because now your file is being read before whatever munge is doing
15:48:04 <hpc> or how about
15:48:44 <lingxiao> wait isnt that what you want?
15:48:49 <lingxiao> read the file and then munge it
15:48:52 <jonored> lingxiao: It reads the entire file into memory to print it, then has to keep it in memory, and starts munging that huge in-memory object, rather than effectively streaming it.
15:48:55 <Welkin> what is munge?
15:48:58 <hpc> lingxiao: the bug is that print changes the order of execution
15:49:09 <hpc> lingxiao: reading the file happens DURING munge in #1
15:49:12 <lingxiao> so print is not lazy?
15:49:13 <hpc> lingxiao: and BEFORE munge in #2
15:49:21 <hpc> print evaluates its argument
15:49:28 <hpc> and evaluating that argument leads to executing what produces it
15:49:35 <hpc> because it was produced by lazy IO
15:49:49 <hpc> do you want a world where print statements can change the order in which things happen?
15:50:04 <jonored> Even if not, you end up having to keep the data around for whenever the second thing you do with it actually happens.
15:50:06 <lingxiao> so if youre reading the file during munging, does that mean the file is read one 'bit' at a time and munge computes the output
15:50:11 <lingxiao> isnt that what you want.. lazy eval
15:50:22 <hpc> i have said nothing about what munge does
15:50:31 <mniip> lazy eval is supposed to be referentially transparent
15:50:37 <hpc> lingxiao: however, if that is indeed what you want munge to do
15:50:38 <lingxiao> oh what is a specific instance where munge could cause a bug
15:50:49 <hpc> lingxiao: then the print creates the "bug" of that IO not being interleaved
15:50:58 <hpc> lingxiao: the print makes it happen up front
15:51:17 <lingxiao> so in conduit if i do    source $$ pipe1 =$ print stuff =$ pipe2 =$ sink
15:51:32 <lingxiao> then  print stuff doesnt put everything into memory correct?
15:51:56 <jonored> You don't discard things once you've calculated them.
15:51:59 <Gurkenglas> How do I make stack update the ghc in my path to the newest?
15:52:05 <hpc> it'll do whatever its execution is defined to do
15:52:06 <jonored> (if you could need them again)
15:52:31 <Welkin> Gurkenglas: stack build --install-ghc ?
15:52:31 <lingxiao> jonored sorry were you talking to me?
15:52:38 <kadoban> Gurkenglas: stack doesn't manager the GHC in your PATH. You can add one of the directories in ~/.stack/programs/ or wherever it is to your path.
15:52:43 <kadoban> manage*
15:53:00 <jonored> Yes. With both print and munge looking at the lazy list, one of them has to leave the file around for the other.
15:53:14 <hpc> lingxiao: you're getting hung up on trying to observe specific behaviors, the important thing is that the evaluation model of haskell can do whatever it wants at any time it wants for no reason whatsoever
15:53:14 <Gurkenglas> How do I remove all ghc executables on my path that are not in that folder? Windows here.
15:53:18 <jonored> leave the file around as a list, which isn't actually what you want if you want to not run out of memory.
15:53:24 <hpc> evaluation is what decides 3 + 3 is 6
15:53:35 <hpc> execution is what decides print "blah" prints "blah"
15:53:41 <Welkin> isn't that reduction?
15:53:43 <Welkin> lol
15:53:44 * hackagebot hw-bits 0.0.0.11 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-bits-0.0.0.11 (haskellworks)
15:53:46 * hackagebot glirc 2.7 - Console IRC client  https://hackage.haskell.org/package/glirc-2.7 (EricMertens)
15:53:53 <kadoban> Gurkenglas: If it works like linux, it chooses the first one it finds. So just put the one you want to acutally be used first in the PATH.
15:54:02 <lingxiao> so evaluation is evaluating expressions
15:54:10 <lingxiao> and execution is evaluating stateful programs ?
15:54:20 <hpc> no
15:54:23 <Gurkenglas> Ooh good idea.
15:54:28 <monochrom> reduction is what decides a nucleus consists of protons and neutrons.
15:54:54 <lingxiao> execution is what decides print "blah" prints "blah"
15:54:59 <lingxiao> Im not sure what you mean here then
15:55:19 <Welkin> only `main` gets executed as one single program
15:55:20 <hpc> lingxiao: do you have ghci handy?
15:55:25 <lingxiao> yeah
15:55:38 <hpc> import Control.Exception
15:55:43 <parsnipM_> any idea why propellor keeps trying to ssh in as root? 
15:55:49 <lingxiao> ok
15:56:08 <hpc> let m1 = print "blah"
15:56:12 <hpc> let m2 = print undefined
15:56:16 <hpc> let m3 = undefined
15:56:30 <lingxiao> cools
15:56:51 <hpc> so, there's this nifty function in Control.Exception called evaluate
15:57:05 <lingxiao> a -> IO a  ok
15:57:06 <hpc> which takes a value, and produces an IO action that performs a smidgeon of evaluation on that value
15:57:14 <lingxiao> what's smidge of evaluation
15:57:15 <hpc> evaluate m1
15:57:21 <lingxiao> like reducing to whnf ?
15:57:26 <hpc> lingxiao: yeah, whnf
15:57:37 <hpc> but the nature of that isn't important for this particular example
15:57:38 <lingxiao> uh i did that and got nothing
15:57:42 <hpc> good
15:57:46 <hpc> evaluate m2 and you'll get the same
15:57:55 <lingxiao> yeah but exception fo rm3
15:57:57 <lingxiao> for m3
15:58:04 <hpc> now just type m1
15:58:05 <Guest41244> Hi all, playing with Parsec, I wonder about the signature for parsers, for example: parse :: Parser String, shouldn't that be Parser -> String?
15:58:07 <lingxiao> is it because in m2  print has been reduced
15:58:25 <hpc> lingxiao: in m2 you have evaluated it to be an action that prints something
15:58:41 <hpc> lingxiao: but you haven't said to actually print anything
15:58:43 <Gurkenglas> How do I ask stack which folder it installs "stack install" stuff to?
15:58:53 <lingxiao> yeah so i get expcetion
15:58:53 <hpc> lingxiao: when you type m1, it now prints
15:58:53 <Welkin> Gurkenglas: .stack-work
15:58:56 <Welkin> or similar
15:59:05 <hpc> you've just executed m1
15:59:07 <lingxiao> but if I just do   m1 = pirnt "ho"  and type in m1 it prints too
15:59:17 <hpc> when you execute m2, it errors
15:59:38 <lingxiao> wait but i dont see how evaluate changes things though
15:59:43 <kadoban> Gurkenglas: No. A    Parser String is a parser that yields a string. You build up 'Parser Whatever' values and when you have what you want you run it using one of the provided functions from parsec.
15:59:47 <Gurkenglas> "stack" doesnt seem to be contained in my path and yet I can use executibles installed with it
15:59:47 <kadoban> Guest41244: ^
15:59:54 <lingxiao> if i just defined m1 m2 m3 as we did and typed in m1 m2 m3  in ghci i get the same behaivor
16:00:10 <Welkin> Gurkenglas: they are in ~/.local/bin/
16:00:17 <Welkin> installed at*
16:00:51 <hpc> lingxiao: when you evaluate m2 you're basically just asking "what is this"
16:01:10 <hpc> and getting the result of "an IO action that does things"
16:01:22 <hpc> lingxiao: and then when you execute, you're saying "ok cool, do those things"
16:01:22 <implementation> Guest41244: If it was a `Parser -> String', that would mean it would be a function that takes a parser as parameter and return a string. But I don't think converting Parsers to Strings is what you want
16:02:36 <implementation> Guest41244: instead, you'll get the string when running the parser (see runParser)
16:03:15 <lingxiao> hpc sorry what was the original lesson here?
16:03:20 <lingxiao> haha getting a  little lost here
16:03:54 <lingxiao> so for what it's worth ive taken this class: http://www.seas.upenn.edu/~cis500/current/index.html
16:03:55 <hpc> heh yeah, when you have to explain things backwards it's hard to follow the chain of logic back
16:03:55 <lingxiao> and we examined the operational semantics of a simple effectful langauge (not lazy)
16:04:06 <lingxiao> also multitasking lol
16:04:15 <Guest41244> kadoban: in this case is Parser a type?
16:04:34 <hpc> lingxiao: quick summary, haskell is a pure language - this means evaluation and execution are considered separate things
16:04:38 <Gurkenglas> huh "AppData\Roaming\local\bin" isnt even on my path
16:04:42 <lingxiao> so if we just spoke directly on the mathmatical objects at play here it might be a little easier tbh
16:04:54 <lingxiao> so again .. what is the definition of evluation and exectuiion
16:05:01 <hpc> lingxiao: evaluation is an abstract notion of reducing expressions to equivalent expressions, while execution is the notion of a computer performing those actions
16:05:17 <Guest41244> implementation: Yes, that's what confuses me
16:05:25 <lingxiao> or so one is manipulation of syntax ruless
16:05:35 <lingxiao> syntax tree *
16:05:36 <hpc> lingxiao: getLine is always going to *evaluate* to an action that reads a line, but what happens when you *execute* it is that the line is whatever your fingers want it to be
16:05:43 <hpc> lingxiao: which can be different every time
16:06:11 <lingxiao> execution is when soem string of program is actually run and has an effect on the disk ?
16:06:16 <hpc> lingxiao: evaluation is defined as denotationally and minimally as possible to encourage abstract compositional reasoning
16:06:45 <hpc> lingxiao: when execution is bound to evaluation, the model of evaluation now has an effect on the meaning of the program
16:06:49 <implementation> Guest41244: `Parser String' is a type. `Parser' alone is (in most cases) invalid syntax (kind * -> *) as it requires a type parameter
16:07:06 <lingxiao> what do you mean execution is bound to evaluation
16:07:18 <hpc> lazy IO is what binds execution to evaluation
16:07:27 <hpc> it makes execution become triggered by evaluation
16:07:39 <hpc> this breaks purity and you lose almost all of that abstract reasoning
16:08:12 <hpc> what real-world effects your program has now can potentially depend on what order the arguments of (x + y) are evaluated in
16:08:25 <lingxiao> sorry what does bind exeution to evlaution mean?
16:08:32 <hpc> it makes execution become triggered by evaluation
16:08:33 <lingxiao> like you evaluate >> execute >> evaluate 
16:08:43 <lingxiao> so theyre not inter leaved or they are
16:09:43 <hpc> lingxiao: do you want to care?
16:09:53 <BlueProtoman> What's a good, small project to do in Haskell that will best demonstrate the best parts of it to someone who wants to learn it?
16:09:59 <hpc> if evaluation can't trigger execution, you don't have to care
16:09:59 <lingxiao> huh ?
16:10:10 <lingxiao> like do i want to careif they're interleaved?
16:10:19 <hpc> evaluation can happen whenever it wants to within the denotational semantics of the language
16:10:25 <hpc> and your program's meaning will stay the same
16:10:26 <lingxiao> I would think it'd be nice if  epxressions are evluated as far as possible and then executed
16:10:27 <hpc> that's purity
16:10:44 <lingxiao> ah i see thats interesting
16:10:50 <Guest41244> implementation: is it because Parser is a monad that it has this syntax, like IO ()?
16:11:24 <hpc> lingxiao: finally getting it? :D
16:11:29 <hpc> lingxiao: it can be a really hard mindset to break into
16:11:42 <lingxiao> yeah also never thought about it haha beyond the bare basics
16:12:21 <lingxiao> so you're saying we want:    eval >> execute >> eval >> execute  == execute >> execute
16:12:28 <hpc> yep
16:12:29 <lingxiao> becuase   e = eval e
16:12:36 <hpc> and both of those == eval >> eval >> execute >> execute
16:12:38 <lingxiao> which is true with non lazy or lazy
16:12:49 <lingxiao> or right that makes sene
16:12:55 <hpc> or execute >> execute >> eval >> eval
16:13:09 <lingxiao> oh wow inteeresting thats a lot to ask
16:13:09 <hpc> execution can trigger evaluation just fine, that's what it's there for
16:13:13 <pikajude> johnw: how would you go about using MonadError in conjunction with Free?
16:13:43 <implementation> Guest41244: if you're talking about the do-notation: yes this is because it's a Monad. But for the type signature this does not matter. It's just that Parser takes a type parameter.
16:13:44 <hpc> lingxiao: there's probably better resources out there to learn this from, someone else might remember their urls
16:14:16 <johnw> pikajude: you'd use MonadError m => FreeT m
16:14:31 <lingxiao> hpc or read the haskell report lol
16:14:33 <pikajude> hmm, free-vl doesn't have a monad transformer of Free
16:14:34 <johnw> which allows you to interleave MonadError effects along with your term algebra
16:14:35 <lingxiao> which I wont do at this moment
16:14:43 <hpc> lingxiao: yeah, perhaps
16:14:45 <lingxiao> but yes i learned a lot just now actually
16:14:51 <johnw> pikajude: oh, in that case just mixin the effect
16:15:02 <pikajude> oh, I should write an Error effect?
16:15:02 <lingxiao> to summarize, if we ever get to a point where    a /= eval a
16:15:05 <johnw> yes
16:15:05 <hpc> lingxiao: a large portion of the report is easy to digest, but the part on the semantics of evaluation can get a bit dense
16:15:07 <pikajude> neat
16:15:15 <implementation> Guest41244: if you don't know about type parameters, I'd recommend you to read http://learnyouahaskell.com/making-our-own-types-and-typeclasses#type-parameters
16:15:19 <lingxiao> then it's not good
16:15:21 <pikajude> so EVERYTHING is an effect
16:15:25 <johnw> yep
16:15:26 <lingxiao> and that happens with lazyIO ?
16:15:29 <johnw> except for the base effect, 'm'
16:15:36 <lingxiao> hpc yeah i can imagine
16:15:43 <hpc> lingxiao: it might still be worth a read anyway, you'll find that the grand total of specification for evaluation is saying when f bottom = bottom
16:15:52 <pikajude> which would probably be IO
16:16:00 <hpc> and when f bottom `canEqual` nonBottom
16:16:11 <pikajude> or, if I'm running tests instead, probably some kind of state monad
16:16:12 <lingxiao> whats the grand total of specification?
16:16:29 <hpc> of evaluation's specification
16:16:49 <lingxiao> what does it mean to grand total something thought?
16:16:51 <lingxiao> though*
16:17:07 <hpc> oh, it just means that's the whole thing
16:17:14 <hpc> and there's not really anything else to it
16:17:16 <lingxiao> oh ok
16:17:26 <lingxiao> hmm maybe i will look now so im less confused haha
16:17:30 <hpc> gtg though, but you have enough to do your own research :D
16:17:35 <lingxiao> yup thaanks a lot!
16:17:42 <pikajude> johnw: I don't think I can make catchError typecheck, though
16:17:42 <lingxiao> appreicate the explanations!
16:22:34 <Guest41244> implementation: thanks, I'm gonna dig into it more
16:33:45 * hackagebot io-streams-haproxy 1.0.0.1 - HAProxy protocol 1.5 support for io-streams  https://hackage.haskell.org/package/io-streams-haproxy-1.0.0.1 (DougBeardsley)
16:36:07 --- mode: ChanServ set +o glguy
16:36:07 --- mode: glguy set -bo plutoniix!*@*$##fix_your_connection glguy
16:36:36 <pikajude> yeah, I certainly can't write an effect that takes an 'm a' as an argument
16:36:39 <pikajude> it can only return an 'm a'
16:36:47 <pikajude> meaning error handling (and using MonadTiming) are impossible
16:37:38 --- mode: ChanServ set +o glguy
16:37:38 --- mode: glguy set -qo *!*@bzq-79-179-108-36.red.bezeqint.net glguy
16:37:47 <shanemikel> somebody ("OOP vs typeclasses" in the hs wiki, is it John Meacham?) mentioned an extension allowing:
16:38:05 <shanemikel> data Sized = forall a. HasSize a => Sized a deriving (HasSize)
16:40:39 <thewormkill> ExistentialQuantification?
16:40:47 <thewormkill> *ExistentialTypes
16:44:11 <glguy> ExistentialQuantification , the quantification is existential
16:45:03 <shanemikel> right, ExistentialQuantification is required, but it doesn't allow for instance deriving
16:47:20 <Symbiont> Hi, I'm new to Haskell and I'm just wondering how I would automatically reload a file on changes to it in ghci?
16:47:58 <glguy> As far as I know there's no existing extension that would allow that deriving clause as written
16:49:11 <glguy> Other than DeriveAnyClass, where it would simply derive an instance with no explicit method implementations, not the one that seems obvious from this context)
16:49:38 <glguy> Symbiont: I believe that "ghcid" is such a tool
16:49:52 <glguy> http://hackage.haskell.org/package/ghcid
16:55:10 <puregreen> I have a project called “notes” and haskell-mode creates a buffer called *notes* and it interferes with Emacs's *notes* buffer
16:55:24 <puregreen> is there anything I can do apart from changing the name of the project?
16:55:42 <Welkin> puregreen: ask in #emacs
16:56:32 <shanemikel> puregreen: they are pretty good about responding to problems.  go to github and file a bug report
16:57:12 <puregreen> shanemikel: yep, already doing that as we're writing (but I was hoping for a workaround because I want to code right now)
16:57:20 <puregreen> * as I'm writing
16:58:10 <shanemikel> none that I know of aside from source diving in haskell-mode, shouldn't be too hard (though it is a very large project)
16:58:59 <shanemikel> wait.. I don't have a *notes* buffer
16:59:05 <shanemikel> is that from some other plugin?
16:59:25 <Welkin> *scratch*
16:59:34 <Welkin> I don't have notes either lol
17:00:48 <puregreen> I thought it came with a new Emacs but I might be wrong
17:00:49 <shanemikel> it comes from org-mode
17:00:54 <monochrom> puregreen: there may be a way to change the buffer name without changing the project name
17:01:00 <shanemikel> you can kill the buffer for the moment, or rename the buffer
17:01:26 <shanemikel> but it looks like you can't use org-mode note-taking whatever while you're working on that project for the moment
17:02:19 <shanemikel> M-x kill-buffer
17:02:20 <monochrom> in fact there is probably a way haskell-emacs asks you for buffer name before it commits to that name
17:03:41 <monochrom> anyway, the normal flow is that if there is no *.cabal file, then haskell-emacs repl's buffer name is *haskell*; if there is a *.cabal file, haskell-emacs uses your project name for repl's buffer.
17:04:18 <monochrom> but supposedly either way it could prompt you for buffer name before it happens at all
17:04:22 <shanemikel> haskell-session-default-name I think sounds promising
17:04:57 <monochrom> that is probably simply the *haskell* case and does not solve the project problem
17:05:36 <shanemikel> I don't have a *haskell* buffer.. just the one for my project and *haskell-process-log*
17:06:08 <monochrom> yes, but that's because you have never worked projectlessly
17:06:55 <monochrom> whereas I almost always just do throw-away experiments in $HOME/tmp, there is no project.
17:07:58 <shanemikel> ahh.. I see.  so haskell-session-default-name is a function that looks like it's responsible for both projects, as well as your case
17:08:11 <monochrom> oh, then that's neat
17:08:54 <shanemikel> find it in haskell-session.el
17:09:30 <monochrom> maybe make it create names like **project** instead of just *project*
17:14:24 <l4m8d4> Can someone explain to me how Haskell does Integers? How they can be of "arbitrary" size? And why a lot of people still prefer using Int in spite of this obvious benefit in using Integer?
17:14:43 <Koterpillar> @src Integer
17:14:44 <lambdabot> data Integer = S# Int#
17:14:44 <lambdabot>              | J# Int# ByteArray#
17:14:49 <Welkin> Integer can take a lot of space
17:14:55 <Welkin> Int is 64 bits
17:15:12 <Koterpillar> l4m8d4: you can see that it's stored as an array of (digits? bytes? IDK), which is less efficient
17:15:57 <mniip> wat
17:16:04 <mniip> I thought @src is populated by hand?
17:16:07 <puregreen> it is
17:16:19 <mniip> who thought it's a good idea to include that :p
17:16:22 <glguy> For small Int values they should take the same space but operations could take longer two do there being two cases to consider
17:16:24 <mniip> @src IO
17:16:24 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
17:16:38 <Koterpillar> then I was just lucky?
17:16:46 <glguy> small Int/Integer values
17:17:21 <mniip> @src Int
17:17:21 <lambdabot> data Int = I# Int#
17:17:56 <Cale> mniip: It was populated by hand mostly around 2006 or something :D
17:18:11 <Welkin> by little gnomes?
17:18:25 <netheranthem> Curious, what's the performance drawback of using Integer for numbers still small enough to be an Int?
17:18:27 <Cale> dons was one of the guys doing the populating, and he was the sort to care about low-level details
17:18:42 <mniip> then where's my
17:19:05 <Cale> netheranthem: Well, there's still some size checking that needs to be done
17:19:07 <mniip> newtype IO a = IO (State# RealWorld -> (# a, State# RealWorld #))
17:19:09 <Cale> heh
17:19:18 <Cale> That one is too unrealistic :D
17:19:34 <Cale> Who would believe it?
17:19:36 <mniip> @src MutVar
17:19:36 <lambdabot> Source not found. Are you on drugs?
17:19:57 <Welkin> everyone knows you can't do IO in haskell
17:19:59 <netheranthem> I guess in that case that would be a constant time. I thought the implementation would be some wizardry, but apparently it's simple.
17:20:18 <netheranthem> (Story of my Haskell life)
17:20:24 <mniip> Welkin, actually I think that's somewhat true
17:20:35 <mniip> you construct an IO action object in haskell and then feed it to the RTS
17:20:53 <netheranthem> Or you can model a sophist philosopher.
17:21:54 <l4m8d4> Is there a space overhead on Integers when they are small?
17:22:19 <hpc> @src Integer
17:22:19 <lambdabot> data Integer = S# Int#
17:22:19 <lambdabot>              | J# Int# ByteArray#
17:22:23 <hpc> @src Int
17:22:23 <lambdabot> data Int = I# Int#
17:22:36 <hpc> l4m8d4: doesn't look like it, as far as ghc is concerned
17:23:14 <hpc> when they exceed Int# size (and maybe when they are within Int# size but come from math on jumbo ints) they go to libgmp
17:23:23 <glguy> Using Integer could get in the way of some optimizations where GHC could see that it was possible to unbox an Int argument
17:23:47 <hpc> i forget if jumbo int math gets reduced
17:23:57 <hpc> oh right, that too
17:25:37 <l4m8d4> okay, so it is mainly a performance benefit that you get from using Int, right? But also, it should be way safer, because Integers don't overflow
17:25:53 <l4m8d4> *it should be way safer to use Integer
17:26:09 <hpc> or if you're doing something where you really do want to express something as a machine-size integer
17:26:18 <hpc> FFI stuff cares about that for instance
17:26:50 <hpc> > maxBound :: Int + 1
17:26:51 <lambdabot>  Not in scope: type constructor or class ‘+’
17:26:58 <hpc> > (maxBound :: Int) + 1
17:26:59 <lambdabot>  -9223372036854775808
17:27:08 <mgsloan> Yeah, using Integer will introduce branches because it needs to check the tag
17:27:23 <hpc> and yeah, you don't get overflows (which as you can see might be unchecked)
17:27:47 <mgsloan> So, I don't think it uses more space (jams the tag into the pointer!), but does take more time
17:30:51 <dfeuer> Grrr.... Data.Bool didn't have the bool function till base 4.7!
17:31:00 <dfeuer> Ping edwardk.
17:33:10 <BlueProtoman> I'm thinking of learning Haskell.  What's a good, small project to do in Haskell that best demonstrates its best parts?
17:36:34 <frontendloader> BlueProtoman: implement quicksort
17:36:52 <Welkin> no
17:36:53 <Welkin> o.o
17:36:56 <Welkin> that is too advanced
17:37:08 <Welkin> write mergesort on lists
17:37:22 <Welkin> quicksort would require using mutable vectors/arrays
17:37:41 <mniip> by quicksort do you mean partition and concat
17:37:42 <frontendloader> no?
17:37:44 <Welkin> unless you mean treesort
17:37:47 <mniip> because that's not quite quick sort
17:38:20 <l4m8d4> BlueProtoman: You could do a binary tree and use higher order functions to implement the walks / depth / search functions
17:38:39 <netheranthem> I like the binary tree problem because it encourages you to get into the type system
17:38:58 <Welkin> > let fib a b = a : fib b (a + b) in fib 0 1 -- BlueProtoman 
17:38:59 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:39:01 <Welkin> :D
17:39:03 <mniip> I had a faithful quicksort implementation somewhere
17:39:16 <Welkin> quicksort is a bitch to write in any language
17:39:24 <Welkin> such a pain
17:39:35 <l4m8d4> You could also implement the sieve of erastothenes as short as possible (hint, it's aon-liner :D)
17:39:41 <l4m8d4> *one-liner
17:39:45 <lpaste> mniip pasted “quicksort” at http://lpaste.net/175732
17:39:48 <netheranthem> One-liner in haskell? Damn.
17:40:02 <netheranthem> Interesting brain-teaser for me then.
17:40:09 <Welkin> huh
17:40:09 <mniip> 1470875916 [03:38:36] <Welkin> > let fib a b = a : fib b (a + b) in fib 0 1 -- BlueProtoman 
17:40:18 <Welkin> my sieves were always at least a few lines
17:40:21 <mniip> > fix ((1:) . scanl (+) 1)
17:40:22 <l4m8d4> quicksort and merge sort is also like 2 lines, though, so not much longer
17:40:23 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
17:40:32 <Welkin> mniip: but yours is just golfing at this point
17:40:36 <Welkin> I like to be clear
17:41:03 <frontendloader> just about any topic seems to be able to set off a chain of 'let me show you how much smarter I am' :/
17:41:05 <Welkin> l4m8d4: impossible for quicksort
17:41:05 <mniip> it is more functional too
17:41:29 <mniip> well
17:41:50 <BlueProtoman> frontendloader, l4m8d4, Welkin, mniip: Okay, how about something a bit more practical?  E.g. something to parse text
17:41:51 <l4m8d4> Welkin: Well, we had to do it a few months ago, and maybe it was as much as 4 even, but not more lines
17:41:57 <mniip> sort (x:xs) = filter (<x) xs ++ x:filter (>x) xs
17:42:01 <mniip> is *kinda* quicksort
17:42:03 <mniip> but not quite'
17:42:12 <mniip> oops, (sort xs)
17:42:15 <Welkin> quicksort is in place
17:42:19 <Welkin> and on arrays
17:42:27 <netheranthem> Is that mergesort then?
17:42:30 <netheranthem> I'm a bit rusty
17:42:32 <Welkin> no
17:42:35 <Welkin> that is a treesort
17:42:43 <mniip> mhm
17:42:45 <mniip> so that's the name
17:43:18 <l4m8d4> Welkin: Okay, maybe we weakened on the in-place restriction a little, I don't remember
17:43:51 <Welkin> http://hackage.haskell.org/package/vector-algorithms
17:44:50 <Welkin> there are some interesting ones there
17:45:06 <Welkin> I like to write mergesort ina any language as my standard sort
17:45:19 <Welkin> it's simple to implement
17:46:13 <mniip> write inplace mergesort in haskell
17:46:48 <l4m8d4> Can ghci measure execution times?
17:48:02 <netheranthem> I think I did that once, unless you are talking about profiling
17:48:29 <netheranthem> I remember it being a simple option, not sure which one.
17:48:39 <Welkin> mniip: mergesort is not in place...
17:48:42 <l4m8d4> Not really, just running a query and have it display execiton time afterwards
17:49:29 <netheranthem> Google tells me it was ":set +s" 
17:49:37 <netheranthem> should be that
17:49:48 <hpc> yeah, that'll do it
17:49:55 <l4m8d4> netheranthem: Yep, that's it. Just found it too, on stackoverflow, thanks
17:49:56 <hpc> i think it only does wallclock seconds?
17:50:22 <hpc> ah yeah, it shows wallclock seconds and bytes of allocation
17:50:48 <hpc> or... not sure what that is
17:53:08 <shanemikel> how would I use fundeps to say that MyClass a b === MyClass b a ?
17:53:21 <mniip> Welkin, would you prefer Array# or heap modification
17:53:39 <mniip> shanemikel, you can't I think
17:55:17 <Cale> You can however add a superclass constraint... I don't think I've ever tried that
17:56:00 <mniip> I think you might need undecidablesuperclass
17:56:14 <mniip> @let class Cls b a => Cls a b
17:56:15 <lambdabot>  .L.hs:171:1:
17:56:15 <lambdabot>      Cycle in class declaration (via superclasses): Cls -> Cls
17:56:15 <lambdabot>      In the class declaration for ‘Cls’
17:59:14 <dfeuer> Cale, I have ... stuff.
17:59:48 <dfeuer> I accidentally got a bit too enthusiastic and added some stuff to the commit that belonged separate (again! fool!). But I got stuff.
18:01:18 <Gurkenglas> Hmm Data.List.sort looks less like a mergesort and more like a minheap sort
18:01:22 <codh> I'm wondering if Haskell have iterator, and if iterator can be replaced by lazy list.
18:01:41 <Koterpillar> codh: what do you want from an iterator?
18:02:26 <Gurkenglas> codh, this has already happened. Now theres just lazy list.
18:02:31 <codh> I don't want iterator. I'm wondering what's the relationship between iterator and lazy list.
18:02:46 <Welkin> an iterator is a lazy data structure, essentially
18:02:48 <codh> it seemed that since Haskell has lazy list, there is no need for iterator.
18:02:51 <Welkin> at least as far as I can tell
18:03:07 <Welkin> well, a lazy list really
18:03:18 <codh> I have that feeling too, but just not able to express it explicitly.
18:03:18 <mniip> well C++ iterators are a bit more than that
18:03:38 <Gurkenglas> :t for_ [1..10] print
18:03:39 <lambdabot> IO ()
18:03:50 <Gurkenglas> There, a lazy list used as an iterator
18:04:06 <shanemikel> mniip: thanks.. looks like I need to use ghc8 for that one?
18:04:06 <codh> let's python's yield, can it be replaced by lazy list or other lazy data structure?
18:04:13 <codh> let's say 
18:04:42 <mniip> by a nondeterminism monad, possibly
18:04:46 <mniip> such as, well, []
18:05:08 <mniip> or a writer
18:05:15 <Gurkenglas> *googles* pythons yield looks like Writer [a]
18:05:48 <mniip> > runWriter $ for_ [1..10] $ \x -> tell [x]
18:05:50 <lambdabot>  ((),[1,2,3,4,5,6,7,8,9,10])
18:05:57 <Koterpillar> to me it looks more like Source
18:06:19 <mniip> > runWriter $ for_ [1..10] $ \x -> if even x then tell [x] else return ()
18:06:21 <lambdabot>  ((),[2,4,6,8,10])
18:06:51 <mniip> yes actually a writer is a pretty good approximation
18:07:51 <Gurkenglas> Hmm this should not require [a], yielding single as at a time is probably what that Source thing is for
18:07:58 <benzrf> no, it's much more similar to Pipes
18:08:02 <Gurkenglas> *[x]
18:08:19 <benzrf> it's not that much like Writer
18:08:54 <Welkin> benzrf: hola
18:08:56 <shanemikel> how would we model that with Cont?
18:09:12 <Koterpillar> sometimes Python's yield is only expected a single time, then maybe it's more like a Cont
18:09:30 <mniip> ContT Writer?
18:10:36 <ggws> to those who use both emacs and vim: is Emacs/Intero badass, or is it pretty-meh
18:11:30 <benzrf> hi Welkin
18:12:52 <shanemikel> ehh.. I think the most common use of python's yield is to create a stateful generator.. I'm having a hell of a hard time seeing how you get writer from that
18:13:26 <shanemikel> would a ContT State make sense?
18:14:04 <mniip> can you pass arguments to .next on a generator?
18:14:16 <Koterpillar> mniip: in Python, yes
18:14:29 <mniip> and well the generator be able to accept those?
18:14:34 <Koterpillar> mniip: in Python, yes
18:14:37 <mniip> hm
18:14:50 <mniip> I wouldn't say that's the "most common use" of yield in python
18:15:02 <mniip> but it does misfit the Writer model
18:15:28 <Koterpillar> usually you don't pass anything back to the generator
18:15:35 <mniip> right
18:16:00 <mniip> perhaps ListT Reader?
18:16:41 <Welkin> and a generator is just a closure o.o, right?
18:17:06 <shanemikel> yeah, I suppose
18:20:38 <shanemikel> ggws I've tried it, and it seemed to work for at least a short period of time..  I like the idea, but I get enough isolation with stack alone
18:22:10 <takanuva> is there any way to make a function to convert an object such as [("a", Foo "b"), ("b", Foo "a")] into a recursive object kinda like let { a = Bar b; b = Bar a; } in [a, b] without using ST?
18:23:44 <mniip> sure
18:23:55 <geekosaur> https://wiki.haskell.org/Tying_the_knot
18:24:14 <geekosaur> laziness gives you some perhaps surprising options for recursive data
18:24:44 <Welkin> geekosaur: but that is not actually recursive
18:24:46 <Welkin> it's a trick!
18:25:08 <mniip> :t $>
18:25:08 <lambdabot> parse error on input ‘$>’
18:25:11 <mniip> :t ($>)
18:25:12 <lambdabot>     Not in scope: ‘$>’
18:25:12 <lambdabot>     Perhaps you meant one of these:
18:25:12 <lambdabot>       data constructor ‘Data.Sequence.:>’ (imported from Data.Sequence),
18:25:15 <mniip> :t (<$)
18:25:17 <lambdabot> Functor f => a -> f b -> f a
18:25:19 <mniip> yeha that's the one
18:25:29 <mniip> or not
18:25:42 <mniip> takanuva, consider
18:26:12 <mniip> :t \yourList -> let m = M.fromList (map (fmap (m M.!)) yourList) in map ((m M.!) . snd) yourList
18:26:13 <lambdabot> Ord a => [(a, a)] -> [b]
18:26:13 <takanuva> hmm, I'm checking the wiki
18:26:23 <mniip> hmm
18:27:29 <mniip> :t \yourList -> let m = M.fromList (map (fmap (fmap (m M.!))) yourList) in M.elems m
18:27:30 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ f b
18:27:30 <lambdabot>     Expected type: Data.Map.Map k b
18:27:30 <lambdabot>       Actual type: Data.Map.Map k (f b)
18:27:44 * mniip goes into query
18:27:47 <takanuva> I'm not sure I got it :(
18:28:03 <shanemikel> wtf is an Occurs check again?
18:30:23 <geekosaur> https://en.wikipedia.org/wiki/Occurs_check
18:31:00 <mniip> takanuva, can you specify more detail on that Foo datatype
18:31:02 <geekosaur> basically means checking to see if something occurs inside itself
18:31:13 <mniip> as in theory the code is correct
18:32:38 <mniip> @let data Foo = Foo String
18:32:39 <lambdabot>  Defined.
18:32:54 <Welkin> mniip: have more fun with it
18:33:00 <mniip> :t \yourList -> let m = M.fromList (map (fmap (\(Foo name) -> m M.! name)) yourList) in M.elems m
18:33:01 <lambdabot> [(String, Foo)] -> [a]
18:33:07 <takanuva> I got a type Example = Foo String | Bar Example, then I got an object of type [(String, Example)], like [("a", Foo "b"), ("b", Foo "a")] to let { a = Bar b; b = Bar a; } in [a, b], y'know? the tuple maps the string to its meaning
18:33:13 <Welkin> @let 草木 = 草木 String
18:33:13 <lambdabot>  Parse failed: Illegal character ''\33609''
18:33:16 <Welkin> D：
18:33:23 <mniip> @undefined
18:33:24 <lambdabot> Undefined.
18:33:30 <Welkin> @undefine
18:33:30 <lambdabot> Undefined.
18:33:37 <mniip> either works
18:33:40 <Welkin> @let _草木 = _草木 String
18:33:41 <lambdabot>  .L.hs:154:11:
18:33:41 <lambdabot>      Not in scope: data constructor ‘String’
18:33:41 <lambdabot>      Perhaps you meant one of these:
18:33:44 <mniip> @let data Example = Foo String | Bar Example deriving Show
18:33:46 <lambdabot>  Defined.
18:33:50 <takanuva> actually I believe that Foo and Bar could be of different types, it wouldn't matter, I'm just trying to use the tuple to define a grammar structure, then turn into into a grammar with cyclic objects
18:33:57 <Gurkenglas> Hmm Cont r a = (a -> r) -> r should be curry-howard be inhabited iff a or r are. But if r = Void, you couldn't construct an a given an ((a -> Void) -> Void)...
18:33:59 <Welkin> @let c草木 = c草木 String
18:34:00 <lambdabot>  .L.hs:158:11:
18:34:00 <lambdabot>      Not in scope: data constructor ‘String’
18:34:00 <lambdabot>      Perhaps you meant one of these:
18:34:03 <mniip> :t \yourList -> let m = M.fromList (map (fmap (\(Foo name) -> Bar (m M.! name))) yourList) in M.elems m
18:34:04 <lambdabot> [(String, Example)] -> [Example]
18:34:06 <Welkin> ...
18:34:29 <mniip> Welkin, forgetting the data?
18:34:38 <Welkin> @let data c草木 = c草木 String
18:34:38 <lambdabot>  Parse failed: Illegal data/newtype declaration
18:34:39 <Welkin> oops
18:34:43 <takanuva> let me check
18:34:47 <Welkin> @let data C草木 = C草木 String
18:34:48 <lambdabot>  Defined.
18:34:50 <Welkin> :
18:34:51 <Welkin> :D
18:35:07 <mniip> @undefine
18:35:07 <lambdabot> Undefined.
18:35:33 <Gurkenglas> lambdabot should have a command to let you test in a query whether a @let command would lead to Defined, without actually adding it to the @let database
18:35:35 <mniip> actually
18:35:54 <mniip> this needs a better mapping function
18:36:22 <mniip> takanuva, basically, you can write an 'Example -> Map String Example -> Example' function, you can do whatever
18:36:28 <mniip> if you*
18:36:37 <Gurkenglas> Right just import https://hackage.haskell.org/package/acme-realworld-0.1.1/docs/Acme-RealWorld.html#v:hypothetically to L.hs
18:37:13 <nshepperd> Gurkenglas: assuming totality, I think ((a -> Void) -> Void) does prove the existence of an a
18:37:42 <Gurkenglas> But you still can't construct it. So that's what constructivism and not not true isnt true mean
18:37:47 <nshepperd> Gurkenglas: but to extract it you'd need to use unsafe functions
18:37:56 <nshepperd> yeah I guess so
18:38:09 <Gurkenglas> how'd you extract it using unsafe functions?
18:38:45 <nshepperd> let foo :: ((a -> Void) -> Void) in unsafeCoerce foo id
18:38:47 <mniip> :t \v -> unsafeCoerce (v (unsafeCoerce id))
18:38:48 <lambdabot> Not in scope: ‘unsafeCoerce’
18:38:48 <lambdabot> Not in scope: ‘unsafeCoerce’
18:38:49 * hackagebot expiring-cache-map 0.0.6.1 - General purpose simple caching.  https://hackage.haskell.org/package/expiring-cache-map-0.0.6.1 (elblake)
18:39:26 <mniip> oh
18:39:29 <mniip> that works too
18:39:40 <mniip> sometimes I forget how powerful unsafeCoerce is
18:40:01 <takanuva> ohh, I got it, mniip
18:40:06 <Welkin> :t unsafeCoerce
18:40:07 <lambdabot> Not in scope: ‘unsafeCoerce’
18:40:22 <Welkin> is that like seq?
18:40:25 <mniip> :t Unsafe.Coerce.unsafeCoerce
18:40:26 <lambdabot> a -> b
18:40:31 <Welkin> oh, yeah
18:40:37 <takanuva> you're using M.! to lazily get the element, I didn't expect it to work recursively like this
18:40:37 <Welkin> I remember seeing that using in some FFI code
18:40:46 <Welkin> used
18:41:27 <takanuva> thank you very much :)
18:42:58 <slack1256T> ugh, is there a way to generate import statements?
18:43:05 <mniip> TH?
18:43:24 <puregreen> TH can't generate import statemets
18:43:25 <puregreen> *
18:43:44 <mniip> shame
18:43:49 <Gurkenglas> http://lpaste.net/1899544866858205184 why didnt that coerce correctly?
18:43:50 <puregreen> see https://ghc.haskell.org/trac/ghc/ticket/1475
18:44:42 <mniip> Gurkenglas, you want to restrict the type of that unsafeCoerce
18:45:21 <mniip> (unsafeCoerce :: ((a -> Void) -> Void) -> (a -> a) -> a)
18:45:27 <mniip> )
18:45:41 <Gurkenglas> Why not (unsafeCoerce :: ((a -> Void) -> Void) -> a)?
18:46:26 <mniip> because you're applying it to id
18:46:58 <Gurkenglas> Ohhhh I see, anything that's in ((a -> Void) -> Void) must actually be a specialization of a member of (forall b.(a -> b) -> b), so you can tell unsafeCoerce to specialize it to (a -> a) -> a instead
18:47:26 <mniip> I can tell unsafeCoerce to coerce anthing to anything
18:47:31 <nshepperd> yes. using here fact that the inhabitant of ((a -> Void) -> Void) is the same as the inhabitant of forall r. ((a -> r) -> r)
18:47:34 <Gurkenglas> yea but itll actually work
18:47:48 <mniip> many things with unsafeCoerce actually work
18:48:36 <Gurkenglas> exactly those such that a reasoning like the one I just used applies?
18:48:48 <mniip> instance Functor Proxy where fmap f = unsafeCoerce
18:49:14 <mniip> idunno
18:49:23 <mniip> I find it hard to reason about unsafeCoerce in terms of the typesystem
18:49:28 <mniip> so I just reason in terms of the RTS
18:49:29 <Welkin> mniip: is that a new apple device?
18:49:36 <Welkin> the iDunno
18:49:51 <Gurkenglas> shush you
18:50:04 <mniip> Welkin, I think that's called siri
18:52:23 <mniip> Gurkenglas, e.g how would you write addrOf :: a -> Word#
18:56:18 <Gurkenglas> *hayoos Word#* uhhh sounds uninhabited. okay i shall rephrase to "any use of unsafeCoerce that works independently of the RTS used has a reasoning 'like the one I just used'"
18:57:33 <Gurkenglas> -independently+for any
18:57:43 <mniip> actually, forget Word#, use Word
18:58:19 <mniip> Gurkenglas, well, syntactically, I guess,
18:58:21 <Gurkenglas> yep definitely no inhabitant that lives in each RTS
18:58:37 <mniip> you can always unsafeCoerce things around as long as they aren't pattern matched at the wrong type
18:59:19 <glguy> You can upset the GC coercing things without pattern matching them, can't you?
18:59:38 <mniip> no? I think the amount of pointers is stored in the closure independently of the type
19:00:19 <Welkin> is the GC a monster?
19:00:19 <mniip> oh and, well, obviously, take care when coercing the function arrow to a different kind
19:00:25 <Welkin> feed it to keep it happy
19:00:35 <mniip> A -> B and A -> Int# have different calling conventions
19:01:12 <Gurkenglas> Oh and you mean there could be a situation where you can save the compiler time proving two types are equal when you know they are, by unsafeCoerceing between them
19:01:50 <mniip> that is not the case with the Functor Proxy I pasted above however
19:01:51 <nshepperd> the logic that made me come up with 'unsafeCoerce foo id' is that foo was 'originally' (a -> r) -> r, and we're just coercing it 'back'
19:02:42 <Gurkenglas> Oh right the docs say that. "It is generally used when you want to write a program that you know is well-typed, but where Haskell's type system is not expressive enough to prove that it is well typed." Time to sleep I guess.
19:06:23 <nshepperd> mniip: I did 'data Box a = Box a' and '\x -> unsafeCoerce (Box x) :: Word'
19:07:09 <nshepperd> uh, dunno how to test that though
19:09:18 <mniip> addrOf :: a -> Word; addrOf = unsafeCoerce (\x -> W# x)
19:11:45 <nshepperd> oh, I guess my impl was wrong, it segfaulted
19:13:38 <mniip> hmm
19:13:58 <mniip> you're coercing a closure with 1 ptr and 0 bytes into one with 0 ptrs and 8 bytes
19:16:12 <nshepperd> oh
19:16:47 <nshepperd> yeah, W# has unboxed argument
19:17:39 <Gurkenglas> Puzzle: Extract an Either a b, using unsafeCoerce, from ((a -> Void) -> (b -> Void) -> Void)
19:18:27 <mniip> unsafeCoerce x Left Right
19:18:33 <mniip> assuming appropriate type cast
19:18:35 <Gurkenglas> well done ^^
19:19:18 <Gurkenglas> Makes you think you could build the entire language on unsafeCoerce
19:19:29 <Gurkenglas> who needs case statements
19:19:38 <Welkin> Gurkenglas: you can build everything using SKI
19:20:01 <mniip> SK
19:20:06 <Gurkenglas> Well I guess, you can just not do the part where you specialize to Void.
19:20:21 <mniip> actually, you can build everything using the U combinator
19:20:25 <mniip> where U = unsafeCoerce
19:21:06 <nshepperd> well, you can program haskell in untyped lambda calculus, I guess
19:21:11 <nshepperd> λ> peekElemOff (ptrOf x :: Ptr Word64) 1
19:21:14 <nshepperd> 5
19:21:18 <nshepperd> wooho
19:21:39 <nshepperd> er, read x as (5 :: Int)
19:22:50 <Axman6> data MeaningOfLife; computeMeaning :: IO MeaningOfLife; computeMeaning = unsafeCoerce Nothing
19:23:06 <mniip> Gurkenglas, here's a challenge
19:23:17 <mniip> detect if a value is WHNF or not
19:23:34 <Axman6> there are ways of doing that no?
19:23:40 <mniip> Axman6, that doesn't work
19:23:46 <Welkin> Axman6: computeMeaning = undefined
19:23:49 <mniip> that will crash
19:24:15 <Axman6> that was kind of the point =)
19:24:40 <mniip> and yes
19:24:49 <mniip> it is totally possible to detect if a value is WHNF or not
19:24:54 <mniip> I have some code for that over here
19:27:19 <Axman6> what's the library that shows you the structure of your data structures?
19:27:26 <Axman6> including their evaluation state?
19:30:05 <Welkin> Axman6: https://github.com/quchen/stgi
19:30:08 <Welkin> is that it?
19:30:28 <glguy> http://hackage.haskell.org/package/vacuum ?
19:35:32 <mniip> something along the lines of
19:36:22 <mniip> \x -> case unpackClosure# x of (# i#, _, _ #) -> let t = I# (indexInt32OffAddr# (plusAddr# i# 8#) 0#) in t >= 16 && t <= 23
19:48:59 <Axman6> Welkin: glguy vacuum was the one
20:03:00 <eitanChatav> howdy
20:19:39 <racoonsrage> hello
20:23:52 * hackagebot zabt 0.4.0.0 - Simple-minded abstract binding trees  https://hackage.haskell.org/package/zabt-0.4.0.0 (JosephAbrahamson)
20:28:52 * hackagebot pretty-types 0.1.0.0 - A small pretty printing DSL for complex types.  https://hackage.haskell.org/package/pretty-types-0.1.0.0 (SvenHeyll)
20:43:18 <x1f577> has anyone run into this error while building a project with ghcjs? .stack-work/dist/x86_64-linux/Cabal-1.22.8.0_ghcjs/: does not exist
20:43:52 * hackagebot pretty-types 0.1.0.1 - A small pretty printing DSL for complex types.  https://hackage.haskell.org/package/pretty-types-0.1.0.1 (SvenHeyll)
20:44:49 <glguy> I just discovered https://github.com/tonsky/FiraCode and it seems rather neat for getting fancy symbols in Haskell mode without needing help from the editor or compiler
20:44:58 <glguy> covers a lot of operators used in Haskell
20:47:28 <Axman6> glguy: might be even more fun when used with your irc client =)
20:48:23 <glguy> For IRC chatting I've been using Fantasque starting today, actually. Also a neat font but possibly not for programming.
20:48:50 <mniip> glguy, they have #( but not (# #)
20:49:04 <mniip> and that >>= looks awful
20:49:19 <dramforever> IMHO the #{ looks bad
20:50:20 <glguy> I don't know, I don't see #{ or #( actually working in my editor with it
20:50:30 <glguy> Maybe someone else agreed with you and removed that one from the actual font file
20:50:33 <dramforever> the <|> <$> etc. are great actually
20:51:43 <dramforever> Oh my, they have one for "www"
20:52:08 <Axman6> cd
20:52:16 <Axman6> urgh
20:52:36 <glguy> You don't have to go home, Axman6, but you can't stay here
20:52:48 <AbelianGrape> What does GHC's "-prof" option do in terms of memory layout and stuff? I discovered a very strange bug where compiling with "-prof" breaks LibUSB, and I suspect it could be due to e.g. a different stack layout than LibUSB is expecting.
21:02:19 <Axman6> glguy: I wish there was a version of Fira Code based on Anonymous :( there's Powerline versions but they don't have the ligatures from Fire
21:02:24 <Axman6> Fira*
21:04:30 * dramforever just noticed that his favourite mono font Iosevka got ligatures long ago, and is just an update away
21:05:09 <dramforever> There's even an option for "haskell mode"
21:08:03 <Axman6> hmm, the skinny characters make it look like a chinese font rendering english
21:08:13 <Axman6> at least in the screenshots
21:09:06 <dramforever> Possibly
21:09:14 <dramforever> be5invis is a Chinese guy actually
21:11:37 <dramforever> He might decided that all English-y chars should be literally half the width of Chinese characters so they render correctly. But it's getting away from Haskell so I'll stop here.
21:12:35 <hackrilege> Hi gang, anyone awake in Haskell world?
21:12:49 <Koterpillar> always
21:17:34 <hackrilege_> ok, so here is a nice little project, but i hit a bug, i hope its easy enough to read, let me know
21:17:35 <hackrilege_> http://lpaste.net/175750
21:17:48 <hackrilege_> id like some help with that type error...
21:17:52 <hackrilege_> kind error*
21:18:08 <hackrilege_> i dont know how to getround it
21:19:07 <Koterpillar> hackrilege_: you can't define an instance of [[]]
21:19:08 <hackrilege_> also surgestions for synonyms that sound less clumsy than the ones im using would be appriciated
21:19:15 <Koterpillar> hackrilege_: the first one will catch it
21:19:30 <hackrilege_> oh
21:19:46 <hackrilege_> thats annoying
21:19:56 <hackrilege_> i guess i could just define the instance over Free
21:19:57 <Koterpillar> hackrilege_: and [[]] isn't a type anyway
21:20:16 <hackrilege_> i guess thats the point i should focus on, in understanding the error
21:20:26 <dmwit> You could define an instance `(HasCollection f, HasCollection g) => HasCollection (Compose f g)`.
21:20:38 <hackrilege_> is there no (.)
21:20:39 <dmwit> Then `Compose [] []` would be just a newtype away from what you probably meant there.
21:20:58 <hackrilege_> yeah, that sounds about right
21:21:21 <mniip> hackrilege_, there's no type-abstraction
21:21:23 <Koterpillar> hackrilege_: [] has kind * -> *, so you can apply it to * (e.g. Bool: [Bool])
21:21:32 <Koterpillar> hackrilege_: but not to [] :: * -> *
21:21:54 <Koterpillar> you want a type-level (.) but I don't know if such a thing exists
21:21:54 <hackrilege_> i guess Compose is the (.) im lookingfor
21:22:12 <hackrilege_> ok awesome, that was simple.
21:22:16 <dmwit> Koterpillar: It exists and ships with GHC in Data.Functor.Compose.
21:22:23 <Koterpillar> dmwit: thanks :)
21:22:29 <hackrilege_> cool!
21:22:30 <mniip> a literal . doesn't exist
21:22:37 <hackrilege_> damn
21:22:54 <mniip> you could write:
21:22:56 <mniip> type family (f . g) x where (f . g) x = f (g x)
21:23:06 <mniip> but then you can't write 'f . g'
21:23:10 <mniip> because it's not fully applied
21:23:12 <hackrilege_> whoh
21:23:19 <hackrilege_> woah*
21:23:19 <mniip> and type families need to be fully applied
21:23:47 <hackrilege_> *mind blown*
21:24:01 <hackrilege_> so, yeah, is what im trying to with the rest of the code at all familiar?
21:24:14 <hackrilege_> im thinking something like State?
21:24:20 <hackrilege_> im new to that stuff
21:25:31 <Koterpillar> the good thing with Haskell is you can reason about things in isolation
21:25:49 <Koterpillar> but right now it means I didn't pay attention to anything else in your paste, reading again :)
21:26:42 <hackrilege_> basically, you define an instance of HasCollection by providing the accessor function, and it gives you (!!!) to use for any collection accessor type
21:27:07 <hackrilege_> its like Ix i think
21:27:31 <hackrilege_> if the accessors were Bounded
21:28:29 <dmwit> This seems like an awful lot of code to do something only marginally useful.
21:28:43 <hackrilege_> so this one is really abstract, which is what i was going for,but ikind of get the feeling its probably already in some module somewhere...
21:29:56 <dmwit> ?hackage keys
21:29:56 <lambdabot> http://hackage.haskell.org/package/keys
21:30:04 <hackrilege_> its not really useless, often i have wanted a generic accessor function. now (!!!) will work all thats needed is that its defined via a HasCollction instance (definately open to surgestednames for all these things)
21:30:32 <dmwit> You may like the keys package. Then again you may like its successor, the lens package, too.
21:30:36 <dramforever> Do you want lens?
21:31:26 <hackrilege_> i can look at it, but its hard to extract the minimal overhead from
21:31:59 <hackrilege_> undirected its easy to get lost or overwhelmed
21:32:35 <hackrilege_> i think i might be ok just with my Free Zipper. most things are isomorphic to Free []
21:32:54 <dramforever> The almighty lens library. If you want something smaller try the microlens-* packages. They are compatible actually.
21:33:53 <hackrilege_> i had a go but i was swamped with nomenclature, i was just trying to do some stuff with State.
21:34:01 <hackrilege_> oh, you should look at this nice example
21:34:04 <hackrilege_> illmake a paste
21:34:13 <hackrilege_> its got an animation and everything its super cool
21:35:10 <dramforever> That sounds amazing
21:35:43 <hackrilege_> http://lpaste.net/175752
21:36:26 <hackrilege_> ha, that wasnt really ready for publication but nvm
21:38:40 <hackrilege_> actually its a pretty great example of why this approach becomes hellishly slow as the simulation progresses
21:38:56 <hackrilege_> it has to trace up a huge list with loads of if statements
21:39:14 <hackrilege_> sorry for not describing that very well
21:39:42 <hackrilege_> to move a pixel it makes reference to where it used to be, right back to the initial conditions
21:40:18 <hackrilege_> modifying the accessor rather than the state of the object in memory
21:40:51 <hackrilege_> did anyone get that to compile?
21:41:34 <hackrilege_> id love to here how this fits in with the statemonad
21:42:00 <hackrilege_> http://lpaste.net/175752
21:45:59 <hackrilege_> its a pretty generic viewer, might be of use to some of you new to gloss, however rolled up in superfluous classes it is...
21:47:24 <dmwit> Hallway test: I am returning some solutions to a problem along with a score telling how good each solution is. Do you expect the type to be [(Solution, Score)] or [(Score, Solution)]?
21:47:36 <hackrilege_> its a slimmed down version of one that handled more kinds of Pictures, eg circles and lines not just pixels... the advantage is this framework is pretty easy to extend to contain those things by changing "Canvas" to contain functions to draw other features
21:48:03 <hackrilege_> Solution Score
21:48:09 <hackrilege_> i guess
21:48:11 <glguy> dmwit: What's a hallway test?
21:48:39 <hackrilege_> see how drunk you are can getto the other end of the hall
21:48:56 <dmwit> glguy: Step 12 of http://www.joelonsoftware.com/articles/fog0000000043.html (scroll to the end).
21:49:13 <dmwit> glguy: In short: just a quick gut check from your fellow humans.
21:49:20 <hackrilege_> im guessing no1 ran my animation...
21:51:46 <glguy> dmwit: My first impression would be to put the solutions first as they are more "important", but a possible advantage of putting them second is if you're willing to leverage the various * -> * classes then putting the important thing second and treating the first element of the tuple as the metadata could make sense
21:52:31 <hackrilege_> f :: Solution -> Score seems to define the orderto me
21:53:17 <hackrilege_> i shouldnt curry all tuples though i guess
21:55:04 <dmwit> glguy: You are a wizard, or maybe a psychic.
21:55:28 <mniip> both is good
21:55:29 <dmwit> I happen to be using fmap irresponsibly at the moment, but was scrolling through my code and the type made me blink and think, "Why isn't that in the other order?".
21:55:39 <dmwit> Which brought me here. And then you said exactly what brought me here.
21:55:53 <glguy> Sounds like you were willing :)
21:56:10 <mniip> just use edwardk's fmap on drugs :p
21:56:28 <mniip> then you don't need to care about those little details
21:56:35 <glguy> Because you're on drugs?
21:56:43 <mniip> partially
21:56:51 <hackrilege_> !?
21:57:10 <hackrilege_> acid lenses
21:57:13 <glguy> error: parse error on input â!?â
21:57:25 <dmwit> hackrilege_: I think the instructions were clear: 1. be on drugs 2. use edwardk's fmap 3. ????? 4. profit!
21:57:28 <mniip> you need t fix your unicode :P
21:57:33 <hackrilege_> lool
21:57:34 <glguy> Yeah, seriously
21:57:50 <glguy> Something broke when we started handling the Paste events
21:58:16 <mniip> actually I was referring to fmap :: Functor f => Cod f a b -> Dom f (f a) (f b)
21:58:21 <hackrilege_> if the paste doesnt complie just remove the lines that split it into 2 modules
21:58:57 * glguy heads off to report an issue with vty
22:00:41 <hackrilege_> i edited the paste, it should work out the box, now you have no excuse
22:00:52 <hackrilege_> http://lpaste.net/175752
22:01:11 <dfeuer> Ping mokus__ 
22:05:01 <hackrilege_> is there any way to use strict values to speed this up?
22:05:06 <glguy> OK, I'm ready now!
22:05:07 <glguy> error: parse error on input ‘!?’
22:05:49 <hackrilege_> !?
22:06:53 <dmwit> glguy: Did you fix your client without disconnecting and reconnecting?
22:07:21 <glguy> Well... I disconnected from ZNC
22:07:32 <dmwit> ah
22:07:36 <glguy> and as a result lost none of the scrollback or troubled the channel with a join/part
22:09:05 <hackrilege_> here all day...
22:10:45 <hackrilege_> hmm i bet you would use it if it was funny functional tetris with a cabal install, but maybe if i could get it to that point i wouldnt need help
22:11:41 <hackrilege_> so the problem in the paste is that despite working really well, it quickly runs out of memory, i was wondering if this problem was common..
22:11:54 <hackrilege_> how to solve it etc
22:12:14 <dmwit> Usually memory leaks are the result of too much laziness.
22:12:32 <hackrilege_> its not a leak..
22:13:00 <hackrilege_> i dont know what a leak is maybe it is, i thought its just that it was recalculating values it could save
22:14:47 <mniip> everybody and their mom uses a ZNC nowadays
22:15:21 <hackrilege_> as if in n+1, it recalculated n as (n-1) +1 right back to the base case each time
22:17:01 <hackrilege_> so that iterate (1+) would become progressively slower, which it wouldnt if it stored the previous value...
22:18:14 <glguy> mniip: I like to leave my phone attached to IRC, but without ZNC I just spam join/quits all day
22:18:15 <Axman6> if you run let xs = iterate (+1) 0; print (xs !! 100); the values up to and including the 100th index will be saved
22:18:24 <hackrilege_> in a tetris game it would consist of each block being instead of a record of its position, a record of the manipulations performed upon it since it was introduced
22:20:49 <hackrilege_> the paste is a working animated implementation of this for just a single falling block
22:20:55 <hackrilege_> http://lpaste.net/175752
22:22:25 <hackrilege_> i would like to understand how to operate on this list of opperations. it seems like it would help me understand lazy evaluation. i have never used strict or boxed values and thought maybe these could help
22:42:21 <hackrilege_> sigh, ill come back and talk to you abut it when you can also actually play tetris with the example
22:48:56 * hackagebot pretty-types 0.1.0.2 - A small pretty printing DSL for complex types.  https://hackage.haskell.org/package/pretty-types-0.1.0.2 (SvenHeyll)
23:02:28 <pavonia> I'm trying to link a wrapper.o file when compiling a module in GHCi. However, it complains "During interactive linking, GHCi couldn't find the following symbol: ..." which can be fixed by setting -fobject-code. Is there also a way to link the wrapper.o without generating object code for all the .hs modules?
23:05:54 <asunar> Anyone available for a beginner question?
23:06:07 <srhb> asunar: Feel free to just ask.
23:06:27 <asunar> Can someone tell me why the where syntax here is not working? http://lpaste.net/175760
23:07:14 <srhb> asunar: where bindings attach to other declarations, you have an expression
23:07:22 <dramforever> Because where is not for expressions. Only definitions can have where-clauses
23:07:41 <dramforever> You type expressions or do-notation commands into GHCi
23:08:49 <srhb> BUt you can have other definitions, like in let, as long as they form an expression
23:08:54 <srhb> > let a = b where b = 42 in a
23:08:56 <lambdabot>  42
23:09:00 <chrisbarrett> asunar: you use `let` to name things in GHCI (each line is effectively a line in do-notation)
23:09:06 <chrisbarrett> so you can write: let foo = x + 9001 where x = 10
23:09:25 <srhb> Oh yeah, that's true too.
23:09:33 <chrisbarrett> you're allowed to write `where` there because it is associated with the definition introduced by the `let` keyword
23:10:27 <chrisbarrett> you may not be far enough in haskell to know what do-notation is, but don't sweat it. just know that when you're naming things in GHCI, you have to use `let` :)
23:11:08 <mniip> not since the accident
23:12:52 <asunar> Is let still needed?On windows with ghci 8.0.1 I can do things without let.
23:13:13 <srhb> asunar: You can have it evaluate expressions, but not name values.
23:13:46 <dramforever> Wait a sec
23:13:52 <dramforever> x = 1 literally works
23:14:03 <mniip> like I said
23:14:08 <srhb> So it does.. Wat.
23:14:10 <asunar> If I define a function like this: triple x = x * 3
23:14:15 <mniip> 8.0
23:14:19 <asunar> That is not naming values.
23:14:20 <srhb> Well, that's new. :-P
23:14:24 <asunar> That is not naming values?
23:14:27 <srhb> Yeah it is
23:14:38 <dramforever> that names a function triple
23:14:50 <dramforever> but functions *are* values
23:15:10 <srhb> asunar: Then presumably you can also: triple x = x * b where b = 3
23:15:12 <dramforever> they just have this bit of syntax sugar allowing more, well, "natural" definitions
23:15:13 * mniip . o O ( and values are really functions )
23:15:20 <srhb> mniip: What.
23:15:24 <dramforever> Wat?
23:15:37 <chrisbarrett> I wouldn't go down that rabbit hole this early!
23:15:42 <mniip> I meant in STG :p
23:15:52 <srhb> That's a terrible point to make here.
23:15:58 <mniip> hence the .oO
23:16:06 <srhb> :P
23:16:24 <chrisbarrett> there's such a thing as TMI when you're still learning syntax ;)
23:16:25 <srhb> asunar: Anyway, this means that definitions you could make in a .hs file seem valid in ghci as well now. :)
23:16:30 <dramforever> asunar: I hope you are still following us with your things
23:16:40 <asunar> To chris' point, still figuring out the concepts following #haskellbook.
23:16:57 <mniip> ok, I'll try to contain myself then
23:17:00 <asunar> somewhat :)
23:18:57 * hackagebot pretty-types 0.1.0.3 - A small pretty printing DSL for complex types.  https://hackage.haskell.org/package/pretty-types-0.1.0.3 (SvenHeyll)
23:19:26 <mniip> one thing that you never stop learning is that haskell is fascinating :p
23:19:58 <asunar> http://lpaste.net/175765 If the difference between line 12 and line 14 is just syntactic sugar, why does line 12 not work?
23:20:51 <liste> asunar: where is a part of definition, there's no definition
23:20:51 <glguy> No, c where a = b is not equivalent to (\a -> c) b
23:21:13 <liste> asunar: let would work there
23:21:23 <alercah> asunar: where is not an expression
23:21:44 <alercah> it only works on function definitions
23:22:16 <dramforever> "although there are minute differences that we will not address here"
23:22:28 <dramforever> Welcome to the so-called "minute" differences
23:23:00 <glguy> if you're reading the haskellbok.com book you're going to need to stay flexible with terminology and details
23:23:22 <asunar> so if I add a definition like this foo x =  x + 9001 where x = 10
23:23:40 <asunar> it works, is that what you mean by having a definition.
23:23:56 <srhb> asunar: Well yes, if a bit useless because the x is an argument to foo already
23:23:57 * hackagebot hjsonschema 1.1.0.1 - JSON Schema library  https://hackage.haskell.org/package/hjsonschema-1.1.0.1 (seagreen)
23:24:02 <srhb> asunar: But yes, that is a definition of foo
23:24:56 <srhb> asunar: A slightly less silly example would be foo x = x + a where a = 9001 
23:25:37 <srhb> asunar: (Your example would simply evaluate to the same value regardless of the argument, since you're shadowing it with your where definition)
23:26:10 <srhb> Shadowing the x, that is.
23:26:49 <asunar> so I'm defining a function foo with an argument x but then setting x to 10, which defeats the purpose of passing an argument to the function. x will always be 10, is that why it is silly?
23:27:05 <liste> does it really say that in haskellbook? wow, I thought it would be better :(
23:27:17 <srhb> asunar: It's slightly crucial to know that you're not changing the value of the argument x. You've just "hidden" it by creating a new name x.
23:27:25 <srhb> asunar: But yes, the x in the function body is always 10
23:27:40 <srhb> liste: What does it say?
23:28:15 <asunar> http://lpaste.net/175766
23:29:00 <liste> srhb: "c where a = b" is equivalent to (\a -> c) b
23:29:20 <asunar> Basically, trying to see for myself that the last two lines are equivalent
23:29:35 <glguy> asunar: Also the let and lambda versions aren't equivalent either, they become different because let bindings can generalize their types
23:29:43 <liste> srhb: and I don't know if it says that but I kinda got the impression from this discussion
23:30:11 <dramforever> > a where a = 1
23:30:13 <lambdabot>  <hint>:1:3: parse error on input ‘where’
23:30:20 <asunar> glguy way over my head..
23:30:24 <glguy> The point of this section seems to be to introduce a few concepts, not to be particularly careful with syntax or terminology
23:30:57 <glguy> asunar: I think you're just meant to kind of glide over it and come away knowing that where and lambdas exist
23:31:09 <srhb> The version I have doesn't say that at least. But it would certainly be worth asking them to correct it if it did. :P
23:32:30 <glguy> Maybe there has been a revision that asunar needs to update to?
23:32:31 <asunar> @glguy But in the exercises I'm asked to rewrite the let expressions into declarations with where clauses
23:32:31 <lambdabot> Unknown command, try @list
23:32:31 <srhb> Oh, yes it does. The e-reader version has different numbering.
23:33:37 <glguy> asunar: (@ is for bot commands) OK, are you working in a file or GHCi?
23:34:27 <glguy> GHCi has many quirks that are convenient when you know what you're doing and confusing when you don't. A really good way to work is to have a file open that you write things in with a separate window open with GHCi
23:34:29 <quchen> liste: Why is this incorrect?  “c where a = b” is equivalent to “case b of a -> c”, no?
23:34:42 <glguy> You can use :r to reload that file in GHCi
23:34:44 <mniip> because that forces evaluation of b before c is returned
23:35:02 <glguy> and because where bindings generalize and case bindings don't
23:35:09 <asunar> ghci
23:35:10 <glguy> so "equivalent" is too strong
23:35:20 <asunar> ghci 8.0.1 that is
23:35:29 <glguy> asunar: In your file you can make declarations for your exercises like:
23:35:37 <glguy> answer = stuff where ....
23:35:57 <liste> quchen: the second one is an expression, the first one isn't
23:35:59 <glguy> You'll be declaring answer and you can write with lambdas, lets, and wheres
23:36:30 <glguy> The first one is a syntax error
23:37:06 <KB5> So... what's with Atom and Haskell plugins suddenly failing?
23:37:16 <quchen> KB5: Dunno, got the same issue though
23:37:24 <quchen> Well, they don’t fail, they just don’t do anything.
23:37:34 <glguy> asunar: In some languages writing in the repl is like writing a file one line at a time. GHCi isn't like that
23:38:00 <KB5> quchen: I am getting error message after the last Atom update
23:38:07 <KB5> *messages
23:38:08 <cryptic_Gh0st> Fizruk looks tasty
23:38:24 <glguy> cryptic_Gh0st: Did you have a Haskell question?
23:38:28 <quchen> KB5: I’m on 1.9.7 without errors
23:38:41 <KB5> I am on 1.9.8
23:38:51 <quchen> Note to self, don’t upgrade. :-)
23:39:16 <asunar> In the context of the exercise, are these let/where expressions/definitions equivalent? http://lpaste.net/175768
23:40:04 <asunar> For the same input, they are returning the same result, so they must be equivalent right?
23:40:16 <glguy> asunar: remove the x and y parameters from foo
23:40:22 <glguy> Just: foo =
23:40:54 <asunar> oh, I see
23:41:12 <asunar> that makes sense.
23:41:16 <glguy> To make them more "equivalent", you can write: foo = let x = 3; y = 1000 in x * 3 + y
23:41:24 <glguy> and then foo1 = x * 3 + y where x = 3; y = 1000
23:41:59 <pavonia> Thinking about it, it's actually strange that -fobject-code makes it work because GHCi doesn't know which object file includes the missing symbol. Does it just include all the object files in the current directory?
23:43:06 <asunar> ok, got it. The one difference is let works without a function definition, however, where needs to follow a function definition. Is that accurate? 
23:43:30 <glguy> yeah, let... in... makes an expression
23:43:57 <glguy> foo isn't a function definition, just a definition
23:44:01 <KB5> Ugh. Went back to 1.9.7 and still getting error messages.
23:44:07 <mniip> long story short
23:44:17 <mniip> 'where' relates to an equals sign
23:44:25 <asunar> great, thanks glguy. Much appreciated.
23:45:15 <mniip> which is more correct, because a definition can have multiple equations, but a where will only span one of them
23:46:18 <KB5> Same thing with 1.9.6. Looks like the plugins themselves are hosed.
