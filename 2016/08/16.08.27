00:00:03 <lispy> lay it on us
00:00:09 <gestone> i'm trying to embed StateT into ReaderT and i came up with this type declaration
00:00:14 <gestone> ReaderT Int (StateT Int IO) Int
00:00:30 <gestone> on ghci, the type of StateT is
00:00:40 <gestone> StateT s m a
00:00:45 <gestone> i mean
00:00:51 <gestone> :t StateT
00:00:52 <lambdabot> (s -> m (a, s)) -> StateT s m a
00:00:54 <gestone> there
00:01:02 <lispy> @unmtl ReaderT Int (StateT Int IO) Int
00:01:02 <lambdabot> Int -> Int -> IO (Int, Int)
00:01:20 <lispy> it might be a bit easier to understand if we did it as:
00:01:28 <lispy> @unmtl ReaderT a (StateT b IO) c
00:01:28 <lambdabot> a -> b -> IO (c, b)
00:01:32 <lispy> I don't know if that helps you or not
00:01:35 <gestone> ahh
00:02:01 <gestone> i was wondering where the var 'a' went
00:02:30 <gestone> because it's not StateT Int IO a in the declaration that i stated above
00:02:38 <gestone> it's just (StateT Int IO)
00:03:38 <gestone> but how does that work though? i get an error if i write it as
00:03:46 <gestone> ReaderT Int (StateT Int IO ()) Int
00:04:37 <lispy> Kind error, right?
00:04:45 <lispy> :k StateT
00:04:47 <lambdabot> * -> (* -> *) -> * -> *
00:04:54 <gestone> yeah it's a kind error
00:05:14 <lispy> :t ReaderT
00:05:15 <lambdabot> forall k r (m :: k -> *) (a :: k). (r -> m a) -> ReaderT r m a
00:05:20 <lispy> sorry, should be :k
00:05:23 <lispy> :k ReaderT
00:05:25 <lambdabot> * -> (k -> *) -> k -> *
00:06:03 <lispy> So if you write StateT Int IO (), the kind will be *, but ReaderT needs something of kind k -> * in that place
00:07:12 <gestone> ah
00:07:41 * hackagebot ntha 0.1.3 - A tiny statically typed functional programming language.  https://hackage.haskell.org/package/ntha-0.1.3 (zjhsdtc)
00:07:41 * hackagebot stochastic 0.1.1.0 - Monadic composition of probabilistic functions and sampling.  https://hackage.haskell.org/package/stochastic-0.1.1.0 (chokboy)
00:09:14 <gestone> so then the declaration of Reader satisifies that requirement? since Reader has Identity which has kind * -> *
00:09:22 <gestone> :k Identity
00:09:24 <lambdabot> * -> *
00:09:34 <lispy> all monads in haskell will have that kind
00:10:09 <lispy> Which is why monad transformers expect something of that kind
00:11:15 <gestone> ah because the m in the monad transformer declaration is a monad, so it expects a kind of * -> *
00:11:22 <lispy> yup
00:12:23 <lispy> StateT s m a, is looking for some type s to use as the state, some type m to use as a monad, and then the 'a' is like like the 'a' in monads like Maybe a
00:14:07 <lispy> I should head to bed. I hope you figure it out (maybe someone else who can help with stumble by)
00:14:15 <gestone> ahh okay thanks for the help
00:14:20 <lispy> yw!
00:14:23 <gestone> i think it's a lot more clear than when i started
00:16:02 <mahdi> hey, is it possible to specify a function to be run before exit? maybe listen on SIGNALs or something like that. I'd like to clean up the environment before my program is closed/killed
00:16:39 <dramforever> :t finally
00:16:41 <lambdabot> IO a -> IO b -> IO a
00:17:36 <dramforever> doSomething `finally` cleanUp
00:18:06 <mahdi> dramforever: so, something like main `finally` cleanUp would work when I do ^C?
00:18:27 <chpatrick> mahdi: ^C throws an exception that you can catch
00:18:43 <mahdi> chpatrick, dramforever: I see, thanks
00:18:50 <chpatrick> mahdi: you should be careful not to catch it anywhere else though
00:18:55 <chpatrick> see the safe-exceptions package
00:19:56 <mahdi> chpatrick: okay, thank you +
00:48:50 <jacco> how do I remove all broken packages with ghc-pkg ?
00:51:20 <black0range> There is a ghc-pkg unregister
00:52:08 <black0range> But if you do not know which packases are broken you need to sacrifice a virgin into your closest volcano :)
00:52:57 <oherrala> just remove all packages? :)
00:53:17 <Axman6> or use stack and avoid broken packages
00:54:48 <jacco> I'm doing this on purpose
00:54:55 <jacco> but there's no single command to remove all broken packages?
00:55:19 <black0range> jacco no sadly cabal isn't a package manager :/ 
00:55:38 <jacco> black0range, but I'm asking about ghc-pkg :)
00:55:57 <srhb> jacco: No, there is not.
00:55:58 <jacco> basically I'd like to remove a node from the dependency graph including all its ancestors
00:56:13 <srhb> jacco: There is no dependency graph in ghc-pkg either.
00:56:33 <jacco> it sure is able to render it for me, though
00:56:34 <chpatrick> jacco: +1 for stack :)
00:56:41 <jacco> chpatrick, why?
00:56:52 <srhb> jacco: What, is it? Then ignore what I said, I thought it was just a flat list.
00:57:10 <chpatrick> it really solves cabal hell problems
00:57:16 <chpatrick> I guess if you have a corrupted package or som
00:57:19 <jacco> I'm not in that place ;)
00:57:19 <chpatrick> ething it doesn't though
00:57:21 <jacco> yes, on purpose
00:57:32 <chpatrick> nuke and start again then? :)
00:57:44 <jacco> no, it's fine, I can do it by hand
00:58:02 <chpatrick> with stack that's easy since the version of the whole hackage is static
00:58:02 <jacco> it would be useful if ghc-pkg just had an option to remove a package and all its reverse dependencies
00:58:25 <chpatrick> so you can recreate the correct packages deterministically
00:58:27 <jacco> chpatrick, but can you control which packages are locally installed and which are not?
00:58:37 <chpatrick> with cabal it's just the sum of what you've installed so far
00:58:39 <chpatrick> whatever that is
00:58:45 <jacco> I've got no problems with having the right build plan
00:58:48 <chpatrick> jacco: what do you mean by that?
00:59:08 <jacco> chpatrick, cabal seems to be quite deterministic with the new-build command
00:59:12 <chpatrick> the nice thing with stack is that builds are fully reproducible by default
00:59:14 <hvr> chpatrick: it transforms caball hell problems into stack hell problems =)
00:59:16 <chpatrick> the version of everything is fixed
00:59:30 <chpatrick> including stuff you pull for git or wherever
00:59:36 <chpatrick> so it's very easy to nuke and rebuild
00:59:38 <hvr> chpatrick: try combining two stack.yaml files
01:00:00 <srhb> Why did Stack ever get raised here? The issue has nothing to do with Stack and Stack doesn't fix it. :P
01:00:03 <jacco> chpatrick, yes I see what you mean, but cabal new-install seems to work fine for me as well in terms of reproducability
01:00:13 <jacco> srhb, haha, yes thanks
01:00:41 <chpatrick> srhb: I'm saying that if you have these kinds of ghc-pkg problems then with stack it's super easy to just clean and start again because you know exactly what packages you need to build
01:00:43 <jacco> I'm just trying to save some precious disk spaces by pruning in a package database, but ghc-pkg doesn't make it very convenient
01:00:50 <chpatrick> with regular cabal it could be anything you've installed manually up to then
01:00:51 <hvr> jacco: 'cab' had support for that btw
01:00:59 <hvr> jacco: to recursively unregister pkgs
01:01:14 <jacco> hvr, but not anymore?
01:01:34 <hvr> jacco: it still has probably, I just don't use it anymore since we have cabal new-build
01:01:52 <hvr> jacco: http://www.mew.org/~kazu/proj/cab/en/
01:02:12 <hvr> jacco: iirc it was the -r flag to 'cabal uninstall'
01:02:12 <jacco> hvr, I see, but I find that with new-build my package database takes a lot of disk space with many packages I don't really need
01:02:19 <jacco> hvr, thanks
01:02:38 <hvr> jacco: yeah, that's because we haven't implemented pkg-db GC'ing  for new-build yet :-)
01:03:25 <hvr> jacco: I just wipe ~/.cabal/store every 1-2 months, if it gets too big
01:03:27 <jacco> hvr, ah cool.. what would be the criterium for an unreferenced package then?
01:03:54 <hvr> jacco: still haven't decided what what consitutes the root-set for package gcing
01:05:00 <hvr> could be some LRU'ing or could be reference-counting 
01:05:10 <hvr> or something else
01:05:57 <hvr> but there's higher prio things to finish up in new-build so this isn't at the top of priorities right now
01:06:55 <jacco> sure, appreciate the work :)
01:07:00 <hvr> jacco: but if you want to contribute ideas, feel free to do so on cabal's issue tracker!
01:07:21 <jacco> will do!
01:07:40 <hvr> jacco: https://github.com/haskell/cabal/issues/3333
01:08:22 <hvr> jacco: in fact, the sooner we have a plan, the sooner this gets implemented :-)
01:34:51 <edward> is there a good reference for haskell syntax that can tell me what >>= means?
01:34:54 <kamyar> Hello everyone
01:35:06 <hvr> edward: that's the Monad bind operator...
01:35:10 <kamyar> I just wanna to port some Python process to Haskell
01:35:20 <edward> hvr: thanks
01:35:25 <kamyar> I need help for writing stateful part
01:35:34 <shachaf> edward: Any introduction to Haskell should mention that operator somewhere.
01:35:44 <hvr> edward: not sure if this helps: http://learnyouahaskell.com/a-fistful-of-monads
01:35:44 <shachaf> edward: But you can also look it (and other operators) up on Hoogle.
01:35:46 <edward> thanks. i'll read https://www.haskell.org/tutorial/monads.html
01:36:04 <edward> shachaf: brilliant. i'll check out Hoogle
01:36:05 <shachaf> It's not built-in syntax, just an operator defined in a library.
01:36:27 <MarLinn> kamyar, there is no state, only Zuul.
01:36:41 <MarLinn> ask away!
01:36:46 <kamyar> I have to choose from MVar, TVar and State monad
01:37:02 <kamyar> I can not use State monad due to multi-thread nature of my process
01:37:13 <kamyar> between MVar and TVar please help me choose one
01:39:20 <MarLinn> http://stackoverflow.com/questions/15439966/when-why-use-an-mvar-over-a-tvar
01:40:50 <kamyar> There is a process here in which we accept websocket connections
01:41:00 <kamyar> and retrieve zmq messages
01:41:28 <kamyar> then dispatch the message content to some special websocket client with some conditions including the packet content
01:41:50 <kamyar> So I need some state to keep track of connected clients
01:46:38 <kamyar> No one wants to answer me please?
01:47:29 <MarLinn> The link I posted did not give you enough information?
01:47:38 * hackagebot network-uri-flag 0.1 - Pseudo-package encapsulating flag(network-uri) Cabal boilerplate  https://hackage.haskell.org/package/network-uri-flag-0.1 (HerbertValerioRiedel)
01:49:24 <MarLinn> It sounds like TVars might be better for your use case from what you wrote. But in the end only you can know
01:52:33 <kamyar> Marlinn: Sorry! I was busy and since u did not mention me here I did not notice ur link. I check now
02:42:30 <ania123> is there definition of functional programming?
02:52:49 <rightfold> Hi, is there a nice way to have Cofree T (Cofree T (Cofree T …))?
02:53:27 <lyxia> Fix (Cofree T)
03:03:14 <mpickering> rightfold: Isn't that the definition of Cofree?
03:03:44 <rightfold> no, the definition of Cofree is data Cofree f a = a <: f (Cofree f a)
03:03:57 <rightfold> I want a to be (Cofree f a) there
03:04:31 <mpickering> Why do you want that, can you not modify `f` to get the behaviour you want?
03:07:02 <black0range> Not strictly haskell related but why are Turing machines more "famous" then Lambda calculus?
03:10:02 <rightfold> thanks lyxia, that works!
03:17:51 <mniip> @pl \(a, b) (c, d) -> (xor a c, xor b d)
03:17:51 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. xor) . flip . (((.) . (,)) .) . xor)
03:18:01 <mniip> is there like an arrow combinator for this perhaps
03:19:42 <mniip> f *** g >>> uncurry (***)
04:01:10 <dinnu93> installed stack on digtal ocean ubuntu-16.04_X86_64 
04:01:26 <dinnu93> But stack ghci gives Did not find .cabal file and Right Nothing
04:01:37 <dinnu93> How to resolve this 
04:01:39 <dinnu93> ?
04:02:14 <dinnu93> I installed git also beforehand the comercialhaskell/stack repo downloaded correctly
04:04:06 <dinnu93> Did not find .cabal file for bindings-GLFW-3.1.2.1 with Git SHA of ae94749557ae68a7ad3edf192bccc110d86dbd67
04:04:07 <dinnu93> Right Nothing
04:22:44 * hackagebot tidal 0.8.1 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-0.8.1 (AlexMcLean)
04:29:16 <mkoenig> hay. is there a way to compile needed shared libraries into the executable?
04:38:05 <srhb> mkoenig: -static for ghc dependencies, optl-static for others.
04:42:18 <mkoenig> srhb: yep. ty
04:43:55 <cloudhead> dinnu93: do you have it in your extra-deps?
04:44:24 <dinnu93> cloudhead: What in extra-deps ?
04:44:47 <dinnu93> cloudhead: Ok 
04:45:39 <dinnu93> cloudhead: No, My extradeps is empty
04:46:23 <cloudhead> dinnu93: and which lts are you using?
04:46:33 <cloudhead> I mean resolver
04:46:42 <dinnu93> cloudhead: 6.13
04:46:55 <dinnu93> cloudhead: lts-6.13
04:47:32 <cloudhead> hm that is strange then
04:48:05 <dinnu93> cloudhead: Seems recently this problem is occuring a lot https://www.reddit.com/r/haskell/comments/4z6wgd/corrupted_stack_index_cache/
04:48:16 <dinnu93> cloudhead: see the link
04:48:28 <dinnu93> cloudhead: That was my output too
04:50:25 <cloudhead> dinnu93: are you still able to build though?
04:51:04 <dinnu93> cloudhead: I just installed it from scratch, No I'm not able to build, setup or even stack ghci
04:52:28 <cloudhead> dinnu93: perhaps you can try with a nightly resolver
04:52:47 <dinnu93> cloudhead: How do I do that ?
04:53:15 <dinnu93> cloudhead: Just change the stack.yaml ?
04:53:18 <cloudhead> --resolver nightly-2016-08-26
04:53:19 <cloudhead> or yeah
04:53:22 <cloudhead> either way
04:55:57 <dinnu93> cloudhead: It's just saying Killed at the end without any error log 
04:57:10 <ongy> that could be oom, are you running out of memory?
04:57:33 <dinnu93> ongy: No 
05:00:31 <dinnu93> cloudhead: It worked! after running the stack setup, Thanks :)
05:05:05 <dinnu93> cloudhead: But my project is not working, I updated the resolver in the project stack.yaml and ran stack setup, stack build 
05:05:45 <dinnu93> cloudhead: It's not working. But stack ghci works outside the project
05:07:43 <cloudhead> dinnu93: ok so it built, but it's not working?
05:08:04 <dinnu93> cloudhead: No It's not even built 
05:08:18 <cloudhead> oh, stack setup worked only
05:08:28 <dinnu93> cloudhead: Yep
05:08:41 <cloudhead> and the build is still getting killed
05:09:14 <dinnu93> cloudhead: Not killed, but failing at the linking stage 
05:09:28 <cloudhead> ah :<
05:09:32 <dinnu93> `gcc' failed in phase `Linker'.
05:09:32 <cloudhead> can you post a log?
05:09:38 <cloudhead> hm
05:09:53 <dinnu93> [1 of 1] Compiling Main             ( /tmp/stack11344/Setup.hs, /tmp/stack11344/Setup.o )
05:09:53 <dinnu93> Linking /root/.stack/setup-exe-cache/x86_64-linux/tmp-setup-Simple-Cabal-1.24.0.0-ghc-8.0.1 ...
05:09:53 <dinnu93> collect2: fatal error: ld terminated with signal 9 [Killed]
05:09:55 <dinnu93> compilation terminated.
05:09:57 <dinnu93> `gcc' failed in phase `Linker'. (Exit code: 1)
05:09:59 <dinnu93> Exit code ExitFailure 1 while running ["ghc","-clear-package-db","-global-package-db","-hide-all-packages","-package","base","-package","Cabal-1.24.0.0","/tmp/stack11344/Setup.hs","-o","/root/.stack/setup-exe-cache/x86_64-linux/tmp-setup-Simple-Cabal-1.24.0.0-ghc-8.0.1","-rtsopts"] in /tmp/stack11344/
05:10:06 <cloudhead> not here
05:10:08 <cloudhead> http://pastebin.com/
05:10:48 <cloudhead> right but it's being killed -9
05:10:55 <dinnu93> http://pastebin.com/ZuTqMLah
05:11:01 <dinnu93> cloudhead: Yeah
05:11:39 <cloudhead> it does sound like an oom issue
05:12:07 <dinnu93> cloudhead: How do I check if it is an oom issue
05:12:09 <cloudhead> don't see what else would kill the process with -9 besides the kernel
05:12:54 <cloudhead> try having `htop` running while you build
05:13:23 <mniip> yeah
05:13:29 <mniip> with 99% certainty it's OOM
05:13:34 <dinnu93> cloudhead: I'll try that 
05:13:43 <mniip> check dmesg
05:13:58 <cloudhead> oh yeah ^ might be quicker
05:14:19 <dinnu93> mniip: Yeah you're right, says it is an OOM issue
05:14:35 <dinnu93> Out of memory: Kill process 11382 (ld) score 483 or sacrifice child 
05:14:40 <cloudhead> ok
05:15:01 <mniip> dinnu93, do you have swap?
05:15:24 <cloudhead> there might be a way to increase the virtual memory size of your instance, I'd look into that
05:15:47 <dinnu93> mniip: Ok I'll see that, It's a digital ocean droplet 
05:15:53 <mniip> oh
05:15:57 <mniip> that
05:16:51 <dinnu93> cloudhead: So If I can increase the size of my VM I won't have this problem ?
05:18:30 <mniip> dinnu93, you might try incremental linking to consume less RAM
05:18:42 <dinnu93> mniip: Ok
05:18:51 <mniip> but increasing VM size - if that's possible - would be an easy solution
05:18:55 <cloudhead> dinnu93: yeah
05:19:08 <dinnu93> mniip: Ok
05:32:46 * hackagebot crypto-multihash 0.4.2.0 - Multihash library on top of cryptonite crypto library  https://hackage.haskell.org/package/crypto-multihash-0.4.2.0 (mseri)
05:57:55 <Gurkenglas> Every other time I try to build exference with Atom's ide-haskell-cabal, I get lpaste.net/5628912682766696448
05:58:39 <Gurkenglas> Or wait I think its the first time I try it after each time something changes
06:07:14 <cocreature> what can cause modifyIORef to block?
06:12:21 <mniip> cocreature, bottoms?
06:13:37 <Gurkenglas> And now it's happening sporadically <.< aw man when I first said that I was looking forward to saying it actually happens every other time in the mathematical sense
06:14:22 <cocreature> mniip: hm I’m doing "modifyIORef ref id" and it’s still blocking
06:14:48 <cocreature> I guess the ioref itself could be bottom but that would be really weird
06:16:05 <cocreature> hm that seems to be it
06:16:18 <cocreature> I’m clearly screwing up completely somewhere
06:16:52 <cocreature> ah I think I know where
06:20:06 <cocreature> turns out, dereferencing nullptrs is not such a good idea after all
06:38:08 <hawk78> Hi! I'm not able to find a way to express a function that takes an operator that can be used on both Double and Integer like ...
06:38:15 <hawk78> updateIndex :: (Num a) => Double -> Integer -> (a -> a) -> (Double, Int)     updateIndex a b op = (op a 1, op b 1)
06:39:30 <hawk78> I guess that the compiler matches a with either Double or Integer and then complains. How can I overcame this?
06:40:49 <hawk78> Can I pass a "template"  operator to a function without making it specialized?
06:41:43 <lyxia> you need the function type to be (forall a. Num a => a -> a)
06:41:50 <kadoban> hawk78: To do that directly as asked would require an extension, such as RankNTypes.
06:42:30 <hawk78> What is a workaround that uses no extensions?
06:42:41 <ggole> You really need rank-n types here.
06:43:02 <kadoban> hawk78: Take two separate arguments, one for (Double -> Double) and one for (Integer -> Integer)
06:43:08 <ggole> The op argument is used polymorphically, so there's no way around giving it a polymorphic type
06:43:19 <ggole> (Other than that. :) )
06:44:20 <hawk78> Here a "macro" would be usefull, I could pass the same operator twice to an internal function using a macro...
06:44:45 <hawk78> does it make sense? Is it possible?
06:44:45 <ggole> Is there a problem with using the extension?
06:45:30 <hawk78> ggole: It is an exercise. I cant use extensions.
06:46:48 <lyxia> What's the actual problem statement that lead you to this function?
06:48:43 <hawk78> lyxia: I'm writing a more complex function... I use that function in Map.insertWith... I have to write the function twice one for adding and one for subtracting... and map elems are (Double, Integer)
06:50:14 <mauke> you can use macros with an extension
06:51:10 <hawk78> mauke: I could also use the Double + for int values (using fromIntegral and round), this is up to now my "best solution", and I hate it!
06:51:29 <defanor> is there a way to set LD_LIBRARY_PATH for the emacs haskell-mode repl, or in a .cabal file perhaps? i'd like to run a repl from haskell-mode, but it fails to find a required C library
06:52:29 <hawk78> defanor: can't you export LD_LIBRARY_PATH before running emacs?
06:53:00 <defanor> hawk78: i can, but didn't, and don't want to restart emacs now. though another option is to figure how to do that while it runs
06:54:33 <MarLinn> hawk78 if you're performing the same operation "in parallel" that sounds like the values are closely related. That in turn suggests that there might be a better algorithm than parallel mapping
06:56:17 <atcb> hi all
06:56:20 <hawk78> MarLinn: actually I'm doing it in parallel, I'm adding vectors of 2 components, In the example above I just use (1,1) as the second vector for example sake
06:56:40 <atcb> does anyone have experience using HSpec and Pipes? I want to test my pipes code but struggling to work out how to test in/out of a pipe
06:57:30 <atcb> obviously functions need to return an "Expectation"
06:57:39 <atcb> so using this with pipes is kind of a non-starter AFAIK
06:58:07 <defanor> re my question: solved by (setenv "LD_LIBRARY_PATH" "/usr/local/lib/")
06:58:21 <lyxia> hawk78: how about implementing Num for (Double, Int), or a custom data type to avoid orphans?
06:58:32 <MarLinn> ^
06:59:30 <meoblast001> hi. does anyone know in travisci what GHC versions are actually available through ghc_find?
06:59:37 <kadoban> That sounds like it'd be more repitition and boilerplate than just specifying (+) twice.
06:59:41 <meoblast001> i've been googling but can't seem to hit a list
07:00:20 <hawk78> defanor: Great!
07:00:56 <hawk78> lyxia: that is a good idea, but a lot of more code!
07:01:41 <hawk78> Btw, I'm trying RankNTypes... What would be the coorect syntax?
07:02:03 <hawk78> s/coorect/correct/
07:02:26 <MarLinn> hawk78 if you don't need all operations from Num you could just define the operations you need under a different name. Less extra code but you still get the added clarity
07:02:48 * hackagebot HDBC-mysql 0.6.6.3 - MySQL driver for HDBC  https://hackage.haskell.org/package/HDBC-mysql-0.6.6.3 (ryantm)
07:03:18 <hawk78> this does not work     updateIndex :: Double -> Integer -> (forall a. Num a => a -> a) -> (Double, Int)
07:04:13 <hawk78> MarLinn: I agree, I think this is the best solution up to now! But still what is the correct RankNTypes solution?
07:04:48 <kadoban> hawk78: What error do you get?
07:05:13 <hawk78> kadoban: Couldn't match expected type ‘a0 -> Double’
07:05:18 <MarLinn> looks right to both me and my ghci
07:05:25 <hawk78> Couldn't match expected type ‘a1 -> Int’ with actual type ‘Integer’
07:05:33 <lyxia> updateIndex a b op = (op a 1, op b 1)  <- op takes two arguments
07:06:07 <hawk78> whoops! thanks"
07:07:38 <lyxia> If you're using that function just twice I guess kadoban's solution is the most lightweight one.
07:07:49 * hackagebot HDBC-mysql 0.6.6.4 - MySQL driver for HDBC  https://hackage.haskell.org/package/HDBC-mysql-0.6.6.4 (ryantm)
07:07:54 <hawk78> lyxia: updateIndex :: Double -> Integer -> (forall a. Num a => a -> a -> a) -> (Double, Int)    this still gives me Couldn't match expected type ‘Int’ with actual type ‘Integer’
07:08:15 <MarLinn> obviously
07:08:37 <kadoban> hawk78: Well, Int and Integer aren't the same thing?
07:09:09 <hawk78> whoops^2
07:09:14 <hawk78> (blush)
07:10:03 <atcb> Does anyone have experience using HSpec and Pipes? I want to test my pipes code but struggling to work out how to test in/out of a pipe. Obviously functions need to return an "Expectation" so "it" can't be a "pipe". Not sure how to proceed.
07:11:23 <hawk78> kadoban: MarLinn: lyxia: ggole: tnks! I'll stick with (+) (+) and (-) (-)
07:16:19 <camm> Hello everone, I've been reading the typeclassopedia, and it says that there are two perspectives for types: as containers and as contexts. What is the difference between them?
07:18:39 <camm> Maybe, [], Either e, ((->) e), etc. are containers
07:18:39 <camm> ((->) e) can be thought of as a context
07:18:45 <camm> Why?
07:21:02 <MarLinn> Both are just different view points, and both are crutches to help you get a feeling for what these types are
07:21:58 <MarLinn> From the "container" perspective these types are like boxes you can put types into
07:22:45 <MarLinn> From the "context" perspective the types are an environment in which the inner types live
07:33:24 <ryantm> Is there a way to specify the Hackage builder should use a different version of GHC from 8.0.1?
07:33:38 <ryantm> When I have the constraint that base is < 4.9 it still tries to use it.
07:46:16 <cocreature> ryantm: that’s not possible but you can upload docs that you built locally
07:46:59 <ryantm> cocreature: okay, thanks I was hoping that my package could also show that the build succeeded for that release, but I guess not.
07:47:46 <cocreature> ryantm: I don’t think the builds are really meant for anything but building docs. if you want ci use travis or something like that
07:48:24 <cocreature> tbh I think even the idea of letting hackage build docs is silly
07:56:35 <ryantm> How do you upload the docs? When I do cabal upload --doc it  says "unrecognized 'haddock' option `--for-hackage'"
07:57:57 <ryantm> Looks like I have haddock 2.16.1 installed and haddock --ghc-version is 7.10.3 which is the version i'm currently using to build my project.
07:58:57 <cocreature> I think you need haddock 2.17
07:59:22 <cocreature> lens has a script somewhere in their repo that worked before cabal upload had a --doc option
07:59:41 <cocreature> but you should be able to upgrade haddock without upgrading ghc iirc
08:00:10 <ryantm>  2.17.2 doesn't seem to have --for-hackage
08:00:32 <ryantm> also it uses ghc-version 8.0.1
08:01:16 <cocreature> wait why are you passing --for-hackage to haddock?
08:01:25 <cocreature> you need to pass that to cabal
08:01:48 <ryantm> Oh, I wasn't passing it I was just looking for it.
08:01:54 <cocreature> cabal haddock --for-hackage
08:02:11 <cocreature> and then cabal upload -d /path/to/*-docs.tar.gz
08:02:22 <cocreature> might even work for haddock 2.16
08:06:18 <ryantm> it needs 2.17
08:07:14 <ryantm> Now I need to figure out how to use 2.17 with a ghc 7.10.3. I'm using this nix-shell expression NIX_PATH=nixpkgs=/home/ryantm/p/nixpkgs nix-shell -p haskell.packages.ghc7103.ghc gcc mariadb pkgconfig zlib openssl haskellPackages.haddock
08:07:26 <cocreature> sorry not familiar with nix
08:08:03 <ryantm> I appreciate your help! Thank you.
08:08:04 <cocreature> take a look at this script https://github.com/ekmett/lens/blob/7e269b3e79ee54c0b34e4c62770fa1220068b769/scripts/hackage-docs.sh if you want to do it without upgrading haddock
08:08:05 <Welkin> that can get confusing when people refer to linux and bsd as "nix"
08:08:34 <ryantm> I've seen *nix before 
08:12:51 * hackagebot exp-extended 0.1.1.2 - floating point with extended exponent range  https://hackage.haskell.org/package/exp-extended-0.1.1.2 (ClaudeHeilandAllen)
08:16:31 <meoblast001> can anyone understand this? https://travis-ci.org/meoblast001/hakyll-sass/jobs/155582929
08:16:36 <meoblast001> i don't see any error message at the end
08:16:50 <meoblast001> sounds to me like "everything worked but i'm going to give a status code 1 anyways"
08:18:29 <johnw> yeah, that's a bit mysterious
08:18:43 <johnw> I've never used "new-build" though
08:20:06 <meoblast001> johnw: it's what multi-ghc-travis spits out
08:20:07 <cocreature> try running with -v2 or something like that
08:20:28 <meoblast001> cocreature: running with -v2 in travis?
08:20:32 <cocreature> yeah
08:21:43 <peteretep> Is there something inherently stupid about wanting: instance Functor (Report t (ResultEnv e e1)) where
08:21:47 <glguy> meoblast001: It looks like zip-archive failed
08:21:49 <peteretep> Or am I just making some other error?
08:21:54 <glguy> meoblast001: https://travis-ci.org/meoblast001/hakyll-sass/jobs/155582929#L1900
08:22:13 <glguy> Running with -v2 is probably just going to make it harder to find the problem
08:22:47 <meoblast001> couldn't find prelude? O_o
08:23:51 <ryantm> cocreature: that script from lens worked for me, thanks!
08:23:57 <cocreature> yw
08:27:10 <glguy> ryantm: yw
08:27:10 <peteretep> I have: http://lpaste.net/180799
08:27:20 <peteretep> Is it possible to use that fmap' to declare a Functor?
08:27:52 * hackagebot pulseaudio 0.0.1.1 - A low-level (incomplete) wrapper around the pulseaudio client asynchronous api  https://hackage.haskell.org/package/pulseaudio-0.0.1.1 (ongyerth)
08:28:52 <glguy> meoblast001: https://github.com/jgm/zip-archive/issues/28
08:29:34 <lyxia> peteretep: what's ResultEnv
08:29:44 <meoblast001> glguy: thanks :)
08:29:48 <peteretep> data ResultEnv e e1 = ResultEnv Result (Either e e1)
08:30:10 <peteretep> data Result = Pass | Fail String
08:30:20 <lyxia> definitely looks like a Functor
08:30:34 <peteretep> I agree, but my version of fmap' has the wrong type:
08:30:57 <lyxia> yes because you would need to also call fmap on ResultEnv
08:31:40 <lyxia> assuming you have an instance Functor (ResultEnv e)
08:33:04 <peteretep> Sure, so this works: fmap'' g (Report t f) = Report t (fmap g f)
08:33:30 <peteretep> But I want to operate on the ResultEnv itself, and not the value it's wrapping
08:33:46 <peteretep> wait, I may be being thikc
08:34:13 <lyxia> that just isn't modelled by Functor
08:48:07 <peteretep> OK. That's a shame.
08:48:23 <peteretep> I wonder what I should call this function
08:50:00 <monochrom> manipulator
08:52:23 <Welkin> name it skeletron
08:58:41 <mniip> peteretep: function1
09:00:32 <sm> study in blue, no. 37
09:02:20 <kang00> Anyone ready to discuss in pm for off topic?
09:06:31 <monochrom> you don't have to use pm. you could use #haskell-offtopic.
09:26:40 <zort> anyone have experience with using ghcmod from vim (on windows)? I got ghcmod-vim set up but it's too slow to use
09:26:57 <zort> I guess it's launching ghc each time instead of keeping a daemon? I don't know how it works
09:32:04 <hsk3> Why isn't
09:32:05 <hsk3> stack build --ghc-options="-fno-code"
09:32:06 <hsk3> any faster than
09:32:07 <hsk3> stack build
09:32:08 <hsk3> ?
09:32:12 <hsk3> That option doesn't seem to have any effect.
09:32:33 <hsk3> Would it be conflicting with my cabal file options? (ghc-options:        -Wall -O2 -fforce-recomp)
09:32:37 <hsk3> s/Would/Could
09:38:12 <ania123> is there definition of functional programming?
09:38:31 <hpc> there are many
09:38:42 <hpc> (which is another way of saying there's none)
09:38:44 <ania123> can you give me a link?
09:41:25 <Clint> to nothingness
09:42:31 * sm hands ania123 a ->
09:42:49 <ania123> sm?
09:43:09 <orion> Is that how you pronounce, "->"
09:44:10 <sm> oh fine https://en.wikipedia.org/wiki/Functional_programming
09:45:50 <sm> hsk3: one of --verbosity/--verbose/--cabal-verbose (what the.. ?) should show you what it's doing, might help you figure that out
09:46:02 <ania123> if I write: "A program written in functional programming style is composition of mathematical functions. "
09:46:08 <ania123> is it OK?
09:48:20 <sm> it's truthy
09:48:45 <sm> it's going in the right direction.. 
09:49:32 <Hi-Angel> Have anybody at hand some funny and unobtrusive blog posts about Haskell and type systems? I'd wanted to give some to a guy who dislike type systems for whatever reason. But can remember only the sarcastic "Why Haskell makes you a worse programmer", which was deleted :(
09:49:51 <sm> it's a bit over-simplified
09:50:31 <ania123> sm what?
09:51:49 <sm> ania123: I think what you said is a bit too simplified
09:52:14 <sm> was the link I gave helpful ?
09:52:23 <osfameron> Hi-Angel: "unobstrusive" is an odd way to describe a blog post :-)
09:52:54 * hackagebot stochastic 0.1.1.1 - Monadic composition of probabilistic functions and sampling.  https://hackage.haskell.org/package/stochastic-0.1.1.1 (chokboy)
09:53:48 <Hi-Angel> osfameron: I mean, without digging to much into monads and such, which might be a bit of a burden to a wholly new one
09:54:45 <Hi-Angel> Like, rather overview than a technical paper
09:55:11 <osfameron> ah, gotcha!  Yeah, sounds like a good idea (sorry, got no pointers though)
09:55:36 <sm> planet.haskell.org archives
09:56:04 <ania123> sm: is your mother language english?
09:56:49 <sm> ania123: yes.. you ?
09:57:02 <Hi-Angel> She is a russian :Ь
09:57:05 <ania123> no
09:57:27 <ania123> sm, could you please correct me following sentence
09:57:28 <ania123> Functional programming is a paradigm of declarative programming which allows to write program as a mathematical function. i.e. a program written in functional programming style is composition of mathematical functions.
09:57:55 <sm> is this homework ?
09:58:02 <ania123> no
09:58:06 <ania123> it is not
09:58:40 <ania123> Hi-Angel: I am not Russian, I am from Islamic republic 
09:59:20 <monochrom> Hi-Angel: perhaps http://perl.plover.com/classes/OOPSLA/samples/slide067.html and so on (keep clicking "next" for next slides)
09:59:47 <sm> ania123: I gave you a link, was it helpful ? or too much info ? Maybe there is a wikipedia article in your language also ?
09:59:56 <monochrom> It is a talk by the famous perler Mark Dominus
10:00:03 <sm> your sentence is good also. Got to go, good luck
10:00:33 <Gurkenglas> Hi-Angel, http://www.pixelstech.net/article/1319886824-Why-learning-Haskell-Python-makes-you-a-worse-programmer it's still mirrored
10:00:56 <Hi-Angel> Oh, indeed, thank you
10:01:10 <Gurkenglas> Doesn't smell like sarcasm to me
10:01:27 <Gurkenglas> Except that it should have said software developer in the title as in the article
10:01:28 <Hi-Angel> Was it sarcasm? :D
10:02:22 <ania123> sm: I am wondering wether it is OK wrt to Englisj, my English is poor
10:04:16 <sm> ania123: yes, it's good 
10:05:09 <ania123> sm: punctuality is ok?
10:05:23 <Gurkenglas> "Functional programming is a paradigm in which programs are written as compositions of mathematical functions." <- is shorter, grammatically an "a" was missing, "allows" doesnt sounds like the thing a paradigm does
10:05:33 <Gurkenglas> English golfing
10:05:58 <Gurkenglas> Oh, declarative, sure, you can put that back in
10:06:31 <orion> I don't understand the distinction between functional and delcarative programming.
10:07:50 <monochrom> I do. Suppose you are to solve the sorting problem.
10:08:16 <monochrom> Functional programming still has you coding up a sorting algorithm (and you have to pick one).
10:08:54 <monochrom> Declarative progrmaming just has you write down you want a permutation that is in ascending order. Ideally.
10:09:31 <ania123>  Gurkenglas: Functional programming is a paradigm of declarative programming in which programs are written as compositions of mathematical functions.
10:09:44 <ania123> like this?
10:09:54 <dmj> yea, I'd say declarative is the result of being functional. 
10:10:08 <dmj> if functional is defined as 'pertaining to functions'
10:10:28 <dmj> and the composition of higher order functions (combinators) is used, you get a declarative style
10:11:38 <dmj> add7 = (+5) . (+2)
10:11:48 <dmj> declarative is 'what', imperative is 'how'
10:14:40 * defanor tried to use sdl2-image, ended up rewriting it completely
10:14:50 <defanor> why is it so hard to get some texts and images rendered? D:
10:15:19 <jxv> defanor, do you have a repo for it?
10:15:43 <defanor> jxv: for the rewritten version? not yet, probably will fork and push soon
10:16:17 <dennisvennink> For those of you familiar with finite-state machines, how are semiautomatons used?
10:16:20 <jxv> okay
10:17:19 <monochrom> wait, what is semiautomaton?
10:17:59 <dennisvennink> A state machine with a set of states, transitions between these states and an input language I believe.
10:18:24 <monochrom> then it is already an automaton, no semi.
10:18:43 <dennisvennink> But according to the definition they don't contain a start state. So I was wondering how you kick it off then?
10:19:01 <monochrom> oh that's interesting
10:19:05 <dennisvennink> It needs to start somewhere?
10:21:11 <defanor> dennisvennink: where did you get that definition? the wikipedia one differs (<https://en.wikipedia.org/wiki/Semiautomaton>)
10:22:41 <dennisvennink> defanor: First sentence in that article. Plus this quote: "A deterministic finite automaton without accept states and without a starting state is known as a transition system or semiautomaton." from https://en.wikipedia.org/wiki/Deterministic_finite_automaton .
10:25:01 <defanor> ah, right, there's just also no accept states. maybe they are used as functors, as the third paragraph suggests?
10:25:21 <defanor> fourth*
10:27:49 <orion> monochrom: Do you know of a language which is declarative but not functional?
10:29:16 <nshepperd_> There are declarative languages that are too weak to do useful stuff
10:29:25 <nshepperd_> As in, lacking first class functions
10:29:34 <dennisvennink> defanor: Hmm. That's worth checking into. I'm new to category theory.
10:30:41 <dennisvennink> So it's basically not used on its own, but it's part of a larger whole. I guess?
10:30:45 <ania123>  Gurkenglas: A declarative program describes what computation should be performed, while an imperative program describes how it is performed.
10:30:52 <ania123> can one correct me following sentence:
10:30:53 <ania123> A declarative program describes what computation should be performed, while an imperative program describes how it is performed.
10:31:29 <Gurkenglas> Where are you getting this?
10:31:41 <ania123> what
10:31:42 <ania123> ?
10:31:53 <Gurkenglas> Where did that sentence come from? Are you translating?
10:32:06 <ania123> I am writing it...
10:32:15 <ania123> is it correct wrt english
10:32:16 <ania123> ?
10:32:51 <Gurkenglas> If you're just looking for grammatical correction, go ask somewhere else :P I think there are paid services for this?
10:33:17 <ania123> :)
10:33:21 <sm> it has been an hour.. I agree :)
10:33:36 <monochrom> orion: Prolog. But not powerful enough for the problem I stated.
10:33:38 <ania123> sm, you agree what?
10:34:01 <ania123> orion: logic programming
10:34:02 <monochrom> Still, Prolog is much closer to "state the question, don't state the answer" than Haskell.
10:34:38 <ania123> orion: rule based programming 
10:34:43 <monochrom> To the dismay of most programmers (who have the urge to state the answer) of course.
10:35:15 <ania123> orion: Answer set programming
10:35:34 <ania123> functional logic programming
10:35:37 <ania123> rewriting 
10:35:38 <ania123> etc
10:37:00 <monochrom> I no longer qualify Haskell as declarative. (I used to.) I qualify Haskell as very high level.
10:38:27 <ertes> on the other hand i can do FRP in haskell, which i can't do in prolog
10:38:31 <monochrom> HIgh level means you just write "1 : []" to allocate a cons cell and set its two fields, you don't write a lot of malloc details.
10:38:54 <ertes> haskell is not a "declarative language"…  it's a language powerful enough to express declarative frameworks in
10:39:31 <monochrom> However, if you are to solve a constraint satisfaction problem, you still have to pick one algorithm and code it up (or call up a library). You still don't state the question.
10:39:57 <mkoenig> i'm still facing problems trying to build a statically linked haskell program. i.e. /nix/store/gd28ivv40gs4mjjmkf6zlzb71ydvx3y5-binutils-2.26.1/bin/ld: cannot find -ljpeg
10:40:37 <ertes> mkoenig: with nix?
10:40:54 <mkoenig> running ld with -L flag works but cabal with extra-lib-dirs doesn't
10:41:03 <mkoenig> yup. on nixos
10:41:46 <ertes> mkoenig: the question is: are you using nix to build (using nix-build), or are you just using haskell on nixos (using cabal-install/stack)?
10:42:23 <ania123> A declarative program describes what you want to archive, while an imperative program describes how to do it. 
10:42:26 <ania123> is it OK?
10:42:41 <Rudes> looks like hoogle fixed the network-uri issue https://github.com/ndmitchell/hoogle/commit/a38927d4ef10a70fb1dd6218a42c43c86bef77a4
10:42:45 <orion> monochrom: How does "state the question" jive with "tell me what the answer looks like, not how to get it"? I've heard both in reference to Haskell.
10:42:48 <ania123> A declarative program describes what you want to archive, while an imperative program describes how to archive it.
10:42:58 <mkoenig> cabal inside nix-shell
10:43:45 <mkoenig> same issue with nix-build
10:43:53 <monochrom> It doesn't.
10:44:35 <monochrom> That's right, I am saying that "Haskell is declarative" is wrong.
10:44:43 <ertes> mkoenig: with nix-build theoretically all you need to do is to set the following attributes: { enableSharedExecutables = false; enableSharedLibraries = false; }
10:44:43 <ertes>  
10:45:15 <ania123> monochrom:
10:45:17 <ania123> A declarative program describes what you want to archive, while an imperative program describes how to archive it.
10:45:19 <ertes> mkoenig: you can either use an override of the default.nix that cabal2nix generates (preferred), or you can edit the default.nix file and just add those two attributes
10:45:22 <ania123> is it ok?
10:45:40 <orion> monochrom: Ah
10:46:43 <xcmw> Is there a package that defines the MonadZero typeclass and provides instances for transformers types?
10:47:57 <ertes> xcmw: hard to answer withing tellung us what MonadZero is, and probably how to make sense of a "zero" without a "plus"
10:48:53 <glguy> A monadzero could be an annihilating zero with >> being multiplication 
10:49:03 <xcmw> ertes: https://wiki.haskell.org/MonadPlus_reform_proposal
10:49:30 <mniip> let's split everything into one-method classes \o/
10:50:04 <mkoenig> ertes: for the moment i've edited the generated file. but it still doesn't work :(
10:50:05 <glguy> xcmw: That's just a proposal someone put on the wiki, it doesn't exist in any commonly used package that I'm aware of
10:50:09 <monochrom> The average class has 1.2193 methods.
10:50:32 <balac> @pl (\x -> [x])
10:50:33 <lambdabot> return
10:50:54 <ertes> which monad transformer from transformers would be an instance of that class, but not Alternative?
10:51:07 <xcmw> glguy: Ok
10:51:09 <mniip> Fillable -> Functor -> Pointed -> Applicative -> Monad -> MonadZero -> MonadPlus
10:51:28 <monochrom> what does Filable do?
10:51:34 <mniip> @src Functor
10:51:35 <lambdabot> class Functor f where
10:51:35 <lambdabot>     fmap :: (a -> b) -> f a -> f b
10:51:37 <monochrom> err, Fillable
10:51:48 <mniip> well nowadays that also includes <$ :: a -> f b -> f a
10:51:54 <mniip> or $> or something
10:52:12 <mkoenig> http://lpaste.net/180831
10:52:22 <monochrom> @type (<$)
10:52:24 <lambdabot> Functor f => a -> f b -> f a
10:52:37 <monochrom> Alright
10:52:38 <ertes> mkoenig: cabal2nix --shell . > shell.nix && myeditor shell.nix && nix-build shell.nix  # is that the way you do it?
10:54:12 <Hi-Angel> osfameron: decided to share: I seem to found one such article http://www.mechanical-elephant.com/thoughts/2015-08-10-the-pratical-benefits-of-haskell-typesystem/
10:56:10 <ertes> classes like Pointed never made sense to me…  semigroupoids make a lot more sense
10:56:23 <ertes> Apply: Applicative without 'pure'
10:56:37 <ertes> Alt: Alternative without 'empty'
10:57:07 <mniip> but Apply is not necessarily a Functor then
10:57:11 <mkoenig> ertes: http://lpaste.net/180832
10:57:55 <ertes> mniip: it is hierarchywise
10:58:07 <ertes> the difference is that i found semigroupoids genuinely useful
10:58:16 <ertes> Pointed?  i never found myself asking for it *in practice*
10:59:28 <ertes> mkoenig: as far as i see your nix-shell invocation doesn't even reference WX.nix
11:00:03 <ertes> it uses shell.nix (with a fallback to default.nix, i think) by default
11:01:23 <ertes> mniip: just to give you an interesting example:  ∀ k. (Map k) is the intersection semi-Applicative, and the union semi-Alternative (it is in fact a full Plus)
11:02:01 <mkoenig> i thought it would be: shell.nix -> default.nix -> WX.nix
11:02:12 <mniip> forall k. Eq k I'm assuming?
11:02:17 <mkoenig> http://nixos.org/nixpkgs/manual/#how-to-build-a-stand-alone-project
11:02:19 <ertes> mniip: Ord k
11:02:34 <mniip> er
11:02:34 <ertes> mkoenig: it doesn't look for other files than shell.nix and default.nix, as far as i know
11:02:35 <mniip> nevermind
11:02:49 <mniip> confused map with set here
11:03:11 <ertes> mniip: i suppose, if you go through the trouble of quantifying your statements, you should go all the way =)
11:09:03 <mkoenig> ok http://lpaste.net/180836
11:10:40 <mkoenig> nix-shell shell.nix --command "cabal build" or nix-build same errors
11:24:14 <ertes> mkoenig: if it's the same error, you should ask in #nixos, too
11:24:57 <osfameron> Hi-Angel: ooo, thanks!
11:25:35 <ertes> mkoenig: why static linking anyway?
11:27:23 <mkoenig> i did, but it's harder to get help there. so thank you very much.
11:30:35 <mkoenig> i have to create an executable which runs on debian centos etc. debian jessie has not all required libraries. the alternative would be to distribute the libs with the executable...
11:40:02 <ertes> mkoenig: why don't you just extract the closure?  it's currently a bit large, but it works
11:40:27 <ertes> mkoenig: du -hsc `nix-store -qR result`
11:42:16 <ertes> mkoenig: the closure is completely self-contained, so it should run everywhere, as long as it's the same architecture
11:48:36 <mkoenig> i'm sorry, but it's slightly beyond my skills. whit do i exactly have to do with them
11:56:11 <ertes> mkoenig: first build it normally, which gives you a symlink 'result'
11:56:24 <ertes> mkoenig: then you could simply tar the closure up:  tar -cf myclosure.tar.xz `nix-store -qR result`
11:56:55 <ertes> wait
11:59:04 <ertes> yeah, follow these steps: 1. cabal2nix --shell . > shell.nix && nix-build shell.nix
11:59:54 <mkoenig> done
12:00:42 <mkoenig> hm i would need to extract the tar to /
12:01:37 <ertes> 2. tar -JPpcf myclosure.tar.xz `nix-store -qR result` &
12:01:59 <ertes> that one takes a while
12:03:13 <ertes> 3. on the target host: tar -C / -xf myclosure.tar.xz
12:05:25 <ertes> mkoenig: oh, i left my "&" in the second command…  you can do an "fg", if you want to watch it output nothing for a few minutes =)
12:06:25 <kang00> Anyone ready for off topic discussion?
12:06:57 <glguy> No, #haskell is only for on-topic discussion
12:07:09 <mkoenig> i see :) what do think about this approach: http://gelisam.blogspot.co.uk/2014/12/how-to-package-up-binaries-for.html
12:07:50 <kang00> In pm?
12:08:27 <ertes> mkoenig: that's basically what those commands do, except automatically
12:09:01 <ertes> mkoenig: with one important difference: they copy *everything* from glibc up, because that's necessary for stuff built with nix
12:10:28 <ertes> mkoenig: on most other distributions most of those libraries have "standard" paths, so you usually only need minor adjustments to get binaries from one system to another
12:10:54 <maerwald> it's called FHS
12:11:03 <maerwald> nix breaks it
12:11:55 <mkoenig> ertes: you helped me alot. thank you very much. :D
12:13:55 <mkoenig> maerwald: i also tried to compile with buildFHS but it didn't work either
12:14:43 <ertes> mkoenig: my pleasure
12:15:39 <mkoenig> :)
12:16:20 <ertes> mkoenig: i'd just package up the closure…  if you think it's too big, please make some noise here: https://github.com/NixOS/nixpkgs/issues/4504 =)
12:16:50 <sleepy_nolrai> @pf \ v -> f <$> g (h v)
12:16:50 <lambdabot> Maybe you meant: pl bf
12:16:55 <sleepy_nolrai> @pl \ v -> f <$> g (h v)
12:16:56 <lambdabot> (f <$>) . g . h
12:17:06 <sleepy_nolrai> duh. >.<
12:17:33 <ertes> mkoenig: it's mostly the fault of the GHC output being monolithic, and that issue is about splitting the library portion of it out
12:18:54 <mkoenig> i will
12:22:53 <ertes> mkoenig: BTW, if you're in control of the target host, you could just install nix there and use the 'nix-copy-closure' command, which does all of this automatically and doesn't require you to be root on the target host
12:27:52 <mkoenig> if it would be my decision, i would install nixos there ;) . but i'm sure debian + nix is possible
12:31:40 <ertes> mkoenig: i tend not to install NixOS on machines i'm not fully responsible for
12:32:40 <ertes> mkoenig: installing nix is not a big deal though, because it leaves the rest of the system untouched
12:42:04 <sleepy_nolrai> Um, maybe this is a dumb question, but is the ProjectName.cabal file really the best place to put ghc options I want to always use?
12:42:30 <monochrom> It is the worst place.
12:42:43 <cocreature> sleepy_nolrai: what kind of options are we talking about here?
12:43:07 <monochrom> With a few exceptions. There are a few options you have to put there and there is no better choice. For example -threaded and -Wall.
12:43:28 <monochrom> OTOH -O2 is better not there. But there are exceptions too.
12:45:56 <monochrom> However, things like personal preferences mistaken as tenable ideologies should absolutely be not there, e.g., -v3
12:47:07 <glguy> monochrom: Who's putting -v3 for ideological reasons?
12:47:19 <monochrom> I don't know. It's a made-up example.
12:47:37 <monochrom> However, some cases of -O2 get close to being just ideological.
12:47:52 <sleepy_nolrai> Okay glad I asked.
12:48:14 <sleepy_nolrai> What about -Werror? You said -Wall has to be there?
12:48:38 <sleepy_nolrai> And where should I put say -O2?
12:48:55 <monochrom> -O2 is a gray area. bytestring and text do it, but it is probably really necessary for some of the fusion to work. But there are also many cases you shouldn't put -O2 there.
12:49:17 <monochrom> I.e., there are cases you should let the user decide.
12:49:57 <monochrom> -Wall and -Werror are OK.
12:49:58 <sleepy_nolrai> Makes sense.
12:51:06 <monochrom> -Wall and -Werror are OK because it is not like you will let the warnings and errors survive by the time your package hits hackage. I.e., -Wall and -Werror does not take away a user's choice, in reality.
12:51:16 <monochrom> Whereas often -O2 does.
12:51:41 <glguy> If you put -Werror in your cabal file for development make sure you remember to remove it when deploying to hackage
12:52:19 <sleepy_nolrai> Oh right that can cause a weird issue can't it.
12:52:35 <monochrom> Oh, I remember seeing that on haskell-cafe. I forgot why. What is the reason again?
12:52:50 <bergmark> i dunno about weird... but your package will break just because a warning was introduced
12:53:00 <glguy> Because if you have it in your package you need extremely restrictive upper bounds
12:53:05 <monochrom> Ah, is it because the meaning of -Wall changes frequently?
12:53:17 <glguy> because new versions of things can introduce new warnings, deprecation warnings, etc
12:53:28 <monochrom> Yeah OK, good.
12:54:54 <sleepy_nolrai> Is putting a -ON on the test-suite still a bad idea?
12:56:20 <mkoenig> ertes: i agree.
12:57:52 <b2coutts> is there a standard choice of linear algebra library? the wiki has 10-ish options, and I'm not really sure what to choose
12:57:55 <b2coutts> bonus points for being on stackage
13:00:57 <mkoenig> maybe i should try docker?
13:01:00 <cocreature> b2coutts: up to 4 dimensions 'linear' is a good choice once you have bigger matrices hmatrix is a good choice
13:03:38 <b2coutts> cocreature: linear looks good, thanks!
13:06:26 <cocreature> b2coutts: it’s not particularly optimized for speed (although it’s also not terribly slow) so if you care about that and have small matrices you probably want to do that stuff on your gpu
13:07:15 <ertes> note that 'linear' can handle larger vectors/matrices
13:07:44 <ertes> but you need to use the V type, which can get quite slow
13:08:14 <cocreature> also for large matrices you often want something that stores sparse matrices
13:08:25 <ertes> the other vector types and matrix types built on them are pretty much just as fast as you would expect
13:09:54 <cocreature> not really, unboxing could get you a significant speedup
13:10:51 <ertes> cocreature: they are unboxed
13:11:24 <cocreature> ertes: they are not and they can’t be because ghc can’t unbox polymorphic stuff (last time I checked at least)
13:11:38 <ertes> mkoenig: if docker is installed on the target host, then yes, it would be a reasonable option…  in fact all you need is 'buildImage' from <nixpkgs/pkgs/build-support/docker>
13:11:54 <ertes> cocreature: huh?  even if the types are statically known?
13:12:16 <cocreature> ertes: afaik yes
13:12:30 <ertes> i thought that changed somewhere around GHC 7.10, but i might be wrong
13:14:19 <ertes> 7.8 even, but i'm not sure about polymorphic types
13:16:58 <cocreature> https://ghc.haskell.org/trac/ghc/ticket/7647 is still open
13:17:25 <cocreature> but weirdly ghc doesn’t complain when adding unpack pragmas to polymorphic fields
13:17:48 <ertes> interesting…  would be worth trying out
13:18:28 <ertes> i guess i never noticed, because they usually end up in a storable Vector for me, and i guess GHC is just very good at optimizing individual vector operations
13:20:25 <dimsuz> hi! I want to read a space separated list of digits from user and convert it to [Int]. Is this a good way to do it: "map read <$> words <$> getLine"? I get a feeling I could use some Applicative tricks here. Or no?
13:21:05 <cocreature> ertes: I tried running http://lpaste.net/180858 through -ddump-simple with -O2 and it looks pretty boxed to me
13:21:13 <dimsuz> that is I currently do "xs <- map read ......"
13:22:38 <cocreature> tested with 8.0
13:22:53 <ertes> cocreature: yeah, i guess in practice those functions get inlined and GHC just eliminates most boxes
13:23:55 <cocreature> I think you’re being a bit too optimistic here but I don’t have any data to back that up so I’ll shut up now
13:24:56 <ertes> cocreature: i'll try to come up with some data later
13:25:20 <ertes> hopefully confirming my theory =)
13:25:59 <cocreature> I would love if you could prove me wrong :)
13:29:58 <cocreature> I should really read more core
13:32:38 <nshepperd> you can't unpack a polymorphic field, because (foo :: forall a. T a -> S a) (bar :: T Int) has to work, right?
13:34:14 <nshepperd> I think ghc's normal trick is to inline foo when possible, and annihilate the constructor and the case match
13:35:16 <avctr> hey
13:35:18 <avctr> anyone using ghcjs
13:35:19 <avctr> ?
13:35:36 <glguy> Yeah, people use it
13:36:15 <dmj> avctr: yea
13:37:36 <EvanR> agreed
13:39:11 <benzrf> avctr: i've been using it a bit lately, ya
13:39:12 <benzrf> hey dimsuz
13:39:21 <benzrf> if it were me, i'd do "map read . words <$> getLine" instead - functor law ;)
13:39:33 <benzrf> you may want to account for non-digit input, too - right now it'd just crash
13:41:50 <dimsuz> benzrf: I too just realized that I used a functor instance of function and already replaced it with (.) similar to your suggestion. As for errors, in this case I don't bother, because this is some training website which guarantees int input for me :)
13:42:07 <benzrf> "functor instance of function"?
13:42:08 <avctr> benzrf dmj how do you structure a project with both frontend and backend code?
13:42:24 <benzrf> when you say "backend", you mean like an http server?
13:42:29 <avctr> benzrf yes
13:42:39 <dimsuz> benzrf: eh. functor instance of (->)? I don't know how to say things right yet )
13:43:08 <benzrf> dimsuz: well, "functor instance of function" makes sense, but you're not using it here
13:43:12 <benzrf> that's functor instance for IO
13:43:36 <dmj`> avctr: there's a few ways
13:44:06 <avctr> i'm trying to do it with two stack files in the same project, but it's kind of messy
13:44:36 <dmj`> avctr: you could use 3 projects (3 cabal files), or a single project (1 cabal file), but use flags in the cabal file (i.e. impl(ghcjs)) to ensure conditional compilation
13:44:46 <liang_> dimsuz: rights $ map (readEither :: String -> Either String Int) ["1", "1b"]
13:44:47 <avctr> i end up explicitly specify .stack-work location per build
13:44:54 <dimsuz> benzrf: hm. why then "map read <$> words" is same as "map read . words". <$> and . are not the same. I played with types in ghci and somehow figured I use instance of (->)
13:45:05 <dmj`> avctr: are these the instructions you got from the stack docs?
13:45:15 <dmj`> avctr: what specifically is messy about your current setup
13:45:27 <ryandv> @hoogle
13:45:30 <lambdabot> package base
13:45:30 <lambdabot> package bytestring
13:45:30 <lambdabot> package containers
13:45:40 <avctr> dmj` afaict the stack docs assume that the project is entirely ghcjs if you use ghcjs
13:46:00 <benzrf> dimsuz: it's right-associative
13:46:02 <ryandv> @pl \x -> f (g x) (h x)
13:46:02 <lambdabot> liftM2 f g h
13:46:22 <benzrf> dimsuz: it's not "(map read <$> words) <$> getLine", it's "map read <$> (words <$> getLine)"
13:46:22 <avctr> dmj` nothing is unworkable, the ergonomics are just not great switching between two stack files and two .stack-work build dirs.
13:46:43 <avctr> it's not the biggest hurdle to be frank, just wondering if anyone had worked out a good process for doing this
13:46:46 <benzrf> dimsuz: oh, wait, i see what you mean - actually yeah, it would work in "(map read <$> words) <$> getLine" too, from the function instance
13:46:49 <benzrf> dimsuz: ok, you're right :)
13:47:04 <dmj`> avctr: this specifically, I'm referring to, https://docs.haskellstack.org/en/stable/ghcjs/#project-with-both-client-and-server
13:47:26 <benzrf> avctr: sorry, the project im doing has no backend
13:47:41 <avctr> dmj` thanks 
13:47:51 <dimsuz> benzrf: thanks for input! I always get more hints than I anticipated when asking something in this channel :)
13:48:05 <dimsuz> that's why I love asking things here
13:48:23 <dmj`> avctr: the build script should help, but you might need two editors open, one with ghcjsi and another ghc
13:48:32 <dimsuz> even though sometimes they are obvious for more experienced fellows, but I don't hesitate :)
13:48:56 <avctr> dmj` unclear where shared code goes in the two-directory stack model though
13:50:34 <Maxdamantus> :t [(<$>), (.)]
13:50:36 <lambdabot> [(a -> c) -> (a1 -> a) -> a1 -> c]
13:53:37 <ertes> nshepperd: you can in principle unpack polymorphic fields when the component type is statically known
13:53:44 <avctr> different ghcjs question - getting a bunch of warnings saying GHCS "boot package" version are different than the stackage lts versions http://lpaste.net/180862
13:55:06 <avctr> initial complaints are warnings, but it seems to have a problem if extra-deps relies on lts versions that are newer than the boot package versions.
13:55:12 <avctr> what are "boot packages" in ghcjs anyway?
14:01:55 <sleepy_nolrai> @pl \ f -> w =<< (f <$> r)
14:01:55 <lambdabot> (w =<<) . (<$> r)
14:05:07 <lyxia> (r >>=) . (w .)
14:06:05 <sleepy_nolrai> @ty (w =<<) . (<$> r)
14:06:07 <lambdabot> error:
14:06:07 <lambdabot>     • Couldn't match expected type ‘a -> m b’ with actual type ‘Expr’
14:06:07 <lambdabot>     • In the first argument of ‘(=<<)’, namely ‘w’
14:06:53 <geekosaur> all the single character names are bound by simple-reflect
14:07:04 <geekosaur> @ty (ww =<<) . (<$> rr)
14:07:06 <lambdabot> error:
14:07:06 <lambdabot>     • Variable not in scope: ww :: a -> m b
14:07:06 <lambdabot>     • Perhaps you meant ‘w’ (imported from Debug.SimpleReflect)
14:07:11 <lyxia> :t (?w =<<) . (<$> ?r)
14:07:13 <lambdabot> (?w::a -> m b, ?r::m a1, Monad m) => (a1 -> a) -> m b
14:07:16 <geekosaur> yeh
14:07:39 <lyxia> or bind the variables in a lambda
14:08:27 <danilo2> Hello guys! Is there any way in Haskell to make a type family that will just "unpack" proxy type? I want it to do for example: `Unpack (Proxy '[1,2,3])` to be `'[1,2,3]`. As a side note, the simple solution doesnt work, because of polykinds 
14:08:35 <sleepy_nolrai> @ty (?r >>=) . (?w .)
14:08:37 <lambdabot> (?w::b1 -> m b, ?r::m a, Monad m) => (a -> b1) -> m b
14:09:02 <geekosaur> avctr, they're the same thing as they are in regular ghc: packages that are used by ghc itself, such that upgrading them is sometimes risky (~always risky if using ghc-api)
14:09:35 <danilo2> so If we do `type family Unpack (p :: *) :: k where Unpack (Proxy k) = k` it doesnt work, because the kind of the result is not infered based on the argument when using the instance
14:09:40 <geekosaur> ...or template haskell
14:13:14 <avctr> geekosaur thanks but normally ghc doesn't complain if i'm using newer packages in a project than thosed used by ghc
14:14:38 <geekosaur> yes, which is actually a problem because people then get bit when they upgrade boot packages and then add a package that uses TH. ghcjs may be more sensitive in general since it's compiling to js instead of machine code
14:16:14 <avctr> geekosaur so the takeaway is that if i'm using ghcjs, i need to use an lts stackage version that corresponds to the boot package versions?
14:16:26 <geekosaur> yes
14:16:41 <avctr> ouch =/
14:16:57 <geekosaur> I'd advise that even for regular ghc, as I just said; otherwise tjings work fine until suddenly they don't and you get weird conflicts
14:17:25 <geekosaur> (weird and remarkably hard to debug until you step back and check for boot packages...)
14:17:59 <avctr> really? i've never had a problem bumping stackage lts versions without bothering to get a new build of ghc. 
14:18:11 <avctr> that doesn't sound right at all...
14:18:49 <geekosaur> there's been some discussion of having ghc use custom/renamed versions of the things it exposes in ghc-api and th (mostly containers), but that's a significant maintenance headache for them (ghc is already a maintenance headache for several reasons)
14:20:39 <avctr> this is equivalent to waiting for gcc to upgrade before i can upgrade boost, which seems nuts 
14:20:42 <geekosaur> also you won't see it as much with ghc + stackage because a resolver includes a ghc version, so a stackage release for a particular ghc version will only have boot package versions that work with that ghc
14:21:00 <geekosaur> ...again, ghcjs may well be more sensitive than ghc in this regard
14:21:38 <geekosaur> which may mean that ultimately there will be a separate set of stackage releases for ghcjs, following its rules
14:21:55 <geekosaur> (or stackage-clones, or whatever)
14:23:05 <geekosaur> (the main difference here is that with machine code, only the things that are exposed need to match (modulo cross-module inlining support exposing more than you expected), but since js is source *everything* is exposed
14:24:07 <avctr> hmm this kindof borks my plan to share code between the client and server
14:30:25 <avctr> (considers scurrying back to purescript)
14:54:09 <leshow> hey guys, i'm reading through bartosz intro to category theory for programmers, and im having some trouble figuring out exactly what an isomorphism is
14:54:21 <leshow> i roughly understand a morphism as a mapping of one object to another
14:54:36 <leshow> is an isomorphism just a mapping of an object to itself?
14:54:39 <leshow> like A -> A
14:55:08 <hpc> it's a morphism with an inverse
14:55:20 <leshow> an inverse?
14:56:00 <hpc> a morphism A -> B such that there exists an inverse B -> A
14:56:09 <leshow> oh ok
14:56:47 <dimsuz> would negation operation be an example of isomorphism?
14:56:47 <hpc> and morphism . inverse = inverse . morphism = id
14:57:44 <ReinH> Well, no
14:58:02 <ReinH> morphism . inverse :: A, inverse . morphism :: B
14:58:16 <ReinH> er, A -> A, and B -> B, respectively
14:58:42 <ReinH> morphism . inverse = id and inverse . morphism = id, but morphism . inverse != inverse . morphism, that's a type error
14:58:58 <hpc> ah right
14:59:04 <leshow> this is for isomorphism?
14:59:16 <heebo> whats the easiest way to construct a Data.Time.DiffTime
14:59:30 <johnw> fromIntegral?
14:59:41 <johnw> I think a DiffTime is just a number
14:59:44 <hpc> https://hackage.haskell.org/package/time-1.6.0.1/docs/Data-Time-Clock.html#t:DiffTime
14:59:52 <hpc> secondsToDiffTime, etc
15:00:45 <ReinH> leshow: a morphism f : X -> Y is an isomorphism if there is a morphism g : Y -> X such that gf = id_X and fg = id_Y
15:01:01 <ReinH> in Haskell we say f :: X -> Y, g :: Y -> X, f . g = id and g . f = id
15:01:02 <leshow> when you say gf you mean g . f
15:01:03 <leshow> right
15:01:07 <ReinH> since id is polymorphic
15:01:18 <ReinH> it is really f . g = id :: X -> X, g . f = id :: Y -> Y
15:01:44 <EvanR> you probably want NominalDiffTime
15:02:40 <danilo2> Hello Guys! I've got a problem with TypeInType. Here is 5-lines simple example that doesnt compile, while I think it should. Could anyone take a look? I would be very thankful for any hints here!:) http://lpaste.net/180877
15:03:01 <danilo2> (no all extensions are needed though)
15:04:51 <danilo2> I dont understand the error. It states "Expected a type, but ‘Get t a’ has kind ‘PropKind ★’", but `PropKind ★` evaluates to `★`, so it should be fine
15:05:44 <EvanR> seeing stars
15:05:59 <dolio> What's unicode star? Is that an alias for *?
15:06:41 <danilo2> dolio: yes, its official alias for *
15:06:50 <danilo2> dolio: from Data.Kind
15:07:43 <danilo2> ghc8 docs state that in the future the normal * will be removed because it causes some compiler corner cases and repalced by unicode star or type `Type`
15:07:53 <danilo2> in fact `Type === ★`
15:08:01 <EvanR> ===?
15:08:14 <danilo2> EvanR: === means is the same as :P
15:08:46 <danilo2> in fact single `=` would be good enough
15:08:55 <EvanR> yeah
15:09:26 <danilo2> but this doesnt matter so much, EvanR, dolio : do you know why the error occurs? 
15:09:56 <AzureStigma> regarding the foldable typeclass if i get it So if I m correct Typeclasses define a set of functions that can have different implementations depending on the type of data they are given.
15:09:56 <AzureStigma> So whatever that structure is u can overload and override certain subroutine pertaining to that specific structure.. So u can override the == method.
15:10:17 <dolio> No. Are you sure your PropKind instance is actually for the unicode star?
15:10:56 <danilo2> dolio: sure, If I replace everything with "Type" it works the same
15:11:02 <danilo2> dolio: (gives the same error)
15:11:16 <EvanR> AzureStigma: yes, think of type classes as a way to implicitly pass around records of operations on your types
15:11:35 <EvanR> == is from Eq, and foldMap is from Foldable
15:11:49 <dolio> danilo2: Maybe Type is not "a type", despite having type Type.
15:11:55 <danilo2> dolio: I've updated the example
15:12:12 <danilo2> dolio: Type is a type and `Type :: Type`
15:13:00 <AzureStigma> so we can override the == method right
15:13:17 <EvanR> you can implement it differently on different types
15:13:43 <EvanR> theres no direct override mechanism, but you can use a newtype wrapper to equip a type with a different Eq
15:13:50 <monochrom> In fact, you have to. It is not like someone already did it for you just so that you can say "I override it"
15:14:20 <ReinH> AzureStigma: you aren't overriding anything, you are defining something that didn't exist before.
15:14:27 <monochrom> You will find that a lot of "inheritance" and "overriding" mentality are going down the drain.
15:14:39 <monochrom> Because there is no inheritance here.
15:14:50 <ReinH> Typeclasses basically allow different functions to share the same name.
15:15:00 <dolio> danilo2: The only other thing I can think of is that it isn't reducing PropKind Type before checking something.
15:15:16 <monochrom> "overload" is right but there is no override.
15:15:32 <AzureStigma> thanks!
15:15:53 <danilo2> dolio: ok, I've been speaking on #ghc about it - it seems that this is a bug already fixed in head
15:16:20 <danilo2> dolio: thank you for your assistance! :)
15:21:31 <danilo2> dolio: confirmed, it was a bug fixed in HEAD
15:21:32 <danilo2> :)
15:34:32 <malice95> d
15:34:57 <malice95> How do I reach Jonestown from here?
15:35:24 <monochrom> I don't know. But this channel is not about the Haskell town. It is about a programming language of that name.
15:37:42 <malice95> +i Well damn sorry wrong channel,tell me if you see Jim Jones
15:37:54 <glguy> It's not o.O
15:38:00 * glguy reevaluates his life
15:38:36 <glguy> Yay, thanks to purity I evaluated to the same value
15:39:04 <malice95> Nice!
15:40:50 <dmj> :)
15:41:01 <monochrom> Who is Jim Jones?
15:41:09 <johnw> he led a suicide cult
15:41:29 <hydraz> In Jonestown.
15:42:02 <monochrom> that's dreadful
15:43:56 <malice95> What is Haskell then?
15:44:22 <monochrom> A programming language. As I said before. Did you see?
15:45:06 <malice95> Oh rightt, is it low or high level?
15:45:10 <monochrom> high
15:45:26 <hydraz> Very high
15:45:49 <hydraz> But not as high as I am! *cough* I mean, uh, what?
15:46:33 <malice95> Hey now! What are the advantages do you think of using it over a low level one like C?
15:46:59 <monochrom> To work with fewer control freaks.
15:47:10 <hydraz> Apart from being able to reason about my code better due to the expressive type system, there's the whole "don't-have-to-manage-memory" thing.
15:48:08 <monochrom> Advantage: it loses control. Disadvantage: it loses control.
15:48:08 <hydraz> There's no baggage of implicit, globally-mutable state that every function carries around, so that's one less thing to think about when coding. The ability to cheaply define your code as a composition of functions also helps building things that are structured like a pipeline, i.e. a compiler (or much of anything that deals with I/O)
15:48:44 <monochrom> But I am more inclined to let go, less inclined to micro-manage. So I like it.
15:48:53 <hydraz> Same.
15:48:57 <monochrom> But I understand that people prefer to micro-manage and over-worry.
15:49:22 <hydraz> Specially when building, say, a kernel, or something real-time.
15:49:36 <dolio> People who want to micro-manage could do it in a better language than C.
15:50:22 <malice95> I just started with C because I thought that it was a better lanuage to build from 
15:51:06 <malice95> Im only on Function templates rn, so notabley I don't know shit but I do like it
15:51:11 <monochrom> Well, here is the fun thing. People want to micro-manage, but they don't actually have enough ability to. So they go for something famed for micro-managing, rather than something really good for micro-managing.
15:51:42 <hydraz> my first language was Java. that was a bad decision
15:52:24 <malice95> Hmm okay this all interesting
15:52:28 <dolio> Well, I mean, there are practical reasons for choosing C over better languages for micro-managing, currently.
15:52:57 <malice95> When you say micro-managing can you give an example?
15:53:16 <hydraz> if you like micromanagement, go for assembly! Who *doesn't* love allocating registers by hand?
15:53:26 <dolio> Because the software industry as a whole would rather spend money fixing problems in C programs instead of investing in making better languages that would rule the problems out competitive with C.
15:53:54 <hydraz> malice95: We mean having to explicitly malloc and free, for example.
15:54:05 <monochrom> When I was in school, I had a little contest with a classmate for smaller program size and fewer clock cycles. For homework toy questions, of course.
15:54:10 <dolio> Fixing them as they're discovered by reputable security researchers, who hopefully find them before malicious people.
15:55:01 <malice95> ohh okay gotcha
15:55:04 <monochrom> I always won him by 1 byte and 1 cycle. The whole thing was about 40 bytes and 40 cycles.
15:55:20 <monochrom> Strangely, my program was also pretty elegant.
15:55:30 <hydraz> Damn, 40 executable bytes?!
15:56:03 <monochrom> But that was the old time of straightforward 68000 etc, with very predictable cycle count and similar simplicities. I can't do that to today's CPU.
15:56:27 <monochrom> Oh, sure, because the homework questions just asked us to solve trivial problems.
15:56:38 <hydraz> Definitely, x86 is pretty crap
15:56:41 <monochrom> and maybe s/bytes/instructions/
15:59:16 <malice95> Whats the format for lets says a hello world program in haskell?
15:59:58 <malice95> Sorry for the nooby questions too
16:00:06 <hydraz> main :: IO () \n main = putStrLn "Hello, World!"
16:00:38 <hydraz> where \n is a literal newline
16:01:14 <malice95> is main the main function or a variable?
16:01:15 <pavonia> Why isn't main of type [String] -> IO ()?
16:02:21 <hydraz> malice95: The latter - Though technically it's a computation in the IO monad.
16:03:04 <hydraz> pavonia: Good question. I think that'd make more sense than the getArgs kludge
16:03:57 <malice95> hmmm okay
16:04:43 <hydraz> If someone a bit more experienced than me would take over that'd be great
16:06:42 <shlevy> Hi all. Good libraries for handling de Bruijn vars?
16:07:01 <malice95> Well I'll have to seek the counsel of Jime Jones before I switch lanuages, anywhoo thank ya'll for the input.
16:07:02 <johnw> shlevy: bound is a good one
16:07:05 <johnw> there is also unbound
16:07:11 <johnw> and the one that Weirich did
16:07:53 <hydraz> Well that was super awkward
16:08:16 <shlevy> johnw: Looks like Weirich did unbound?
16:08:30 <johnw> is that the one she did?  I don't remember
16:23:03 <andromeda-galaxy> hydraz: did I just meet you on gitter through a mutual friend?
16:25:43 <justatech> Anyone knows any way to get , uid value of accounts.mozilla.com website?
16:26:43 <EvilMachine> Hi. Time libaries have way too many incompatible types.
16:26:59 <EvilMachine> All I want, is: now - 03:00h
16:27:13 <EvilMachine> how do I do that?
16:27:33 <EvilMachine> how do i subtract 3 hours from getCurrentTime
16:31:00 <c_wraith> EvilMachine: do you understand why they have different types?
16:31:00 <glguy> Prelude Data.Time> (- 3 * 60 * 60) `addUTCTime` now
16:31:01 <glguy> 2016-08-27 20:29:58.064336 UTC
16:31:51 <glguy> <3 time library
16:32:18 <glguy> Also >= 1 time library...
16:32:26 <EvilMachine> c_wraith: you’re now ignored. you know why
16:32:37 <c_wraith> EvilMachine: sweet!
16:32:47 <johnw> huh?
16:33:16 <johnw> I thought c_wraith's question was a good one
16:33:18 <EvilMachine> glguy: hey… hmm… I hoped to parse a "03:00" string to something I could substract from a UTCTime
16:33:32 <c_wraith> Apparently it's bad to point out that there are reasons for decisions.
16:34:08 --- mode: ChanServ set +q EvilMachine!*@*
16:34:17 <glguy> You're now ignored, you know why
16:34:56 <c_wraith> I don't really think that's necessary.  I suspect misunderstading more than anything.
16:35:02 <c_wraith> *misunderstanding
16:35:06 <glguy> Not the first time EvilMachine pulled that
16:35:17 <monochrom> It is not the first time and you are not the first victim, c_wraith.
16:35:26 <c_wraith> Ah
16:35:49 <monochrom> Basically a trend is emerging in which any question is considered declaring war.
16:36:03 <geekosaur> from what I've seen, they want to be given a fish and don't waste their time teaching them to fish
16:36:54 <c_wraith> That's sad.  I really like explaining why time differentials aren't the same thing as times, and why it's really important to distinguish between them.
16:37:07 <monochrom> Yes, but there is still a big difference between the respectful "sorry, I don't want to get into that now" and the hostile "you are ignored and you know why".
16:37:21 <johnw> c_wraith: or pull in some Einstenian quote about simultaneity and the meaning of time
16:37:31 <monochrom> :)
16:37:54 <monochrom> And there is also a big difference between the ops seeing it the first time and seeing it the second time.
16:37:58 <dolio> I don't think the time library takes that stuff into account. Dealing with time is bad enough without it.
16:39:02 <Adeon> can I force ghci to let me call unexported functions in a module
16:39:03 <jle`> would be interesting to see/write a library dealing with minkowski flat spacetime
16:39:10 <monochrom> the library leaves room for you to take it into account, but doesn't really force you to
16:39:25 <geekosaur> Adeon, only if you load it as source compiled to bytecode
16:39:29 <johnw> jle`: how about a library that requires me to provide a reference frame :)
16:39:52 <geekosaur> if it's compiled machine code, there's no way for ghci to know how to access an unexported name,  because the name is not present
16:40:53 <geekosaur> (and convincing linkers to put an unexported name somewhere for special use by ghci is ... tricky at best and unlikely to be portable)
16:41:52 <pavonia> That reminds me ... Is there a way to make GHCi put the object files into a separate directory if -fobject-code is set?
16:42:08 <geekosaur> does -odir work?
16:42:31 <geekosaur> (if not, I'd seriously consider filing a bug)
16:43:20 <pavonia> No, seem to be ignored
16:43:38 <hydraz> andromeda-galaxy: yup.
16:44:27 <geekosaur> then I think you want to file a ghc bug, and there's unlikely to be anything else you can do
16:44:50 <geekosaur> (except maybe hack on ghci-ng to add it, if you speak ghc-api, but ugh)
16:45:38 <andromeda-galaxy> hydraz: I (slightly) unexpectedly have to leave my machine for a bit now, but I'm looking forward to chatting some later - what time zone are you in?
16:45:56 <hydraz> I'm in UTC-3
16:46:03 <Gurkenglas> Is there something that derives the catamorphism for a data definition? For example, given Bool, Maybe and [] it would give bool, maybe and foldr.
16:46:46 <geekosaur> @hackage catamorphism
16:46:46 <lambdabot> http://hackage.haskell.org/package/catamorphism
16:46:56 <Gurkenglas> welp :D
16:47:00 <andromeda-galaxy> hmm, I'm UTC-8 so that's a bit off.  Hopefully I'll see you around here, though
16:47:31 <hydraz> Sure
16:47:38 <andromeda-galaxy> (here meaning the irc channel, since there is a good bit of overlap)
16:47:57 <andromeda-galaxy> I recommended haskellbook.com to our mutual friend by the way - it's pretty awesome
16:48:06 * hackagebot oscpacking 0.3.0.0 - Implements an osculatory packing (kissing circles) algorithm and display.  https://hackage.haskell.org/package/oscpacking-0.3.0.0 (infrared)
16:48:42 <hydraz> Aye, me too
16:49:00 <ertes> Gurkenglas: if your type is a fixed point of a type constructor, there is also:
16:49:03 <ertes> @package recursion-schemes
16:49:03 <lambdabot> http://hackage.haskell.org/package/recursion-schemes
16:49:43 <ertes> (maybe s/if/since/)
16:49:46 <pavonia> geekosaur: Oh wait, it's "-odir <actual dir name>" which does work
16:50:08 <pavonia> Thought the dir already were the dir name :p
16:50:21 <ertes> pavonia: i use -outputdir, which puts *all* files in that directory, not just outputs
16:50:39 <geekosaur> no, -o is already something so it can't do that shorthand
16:50:52 <geekosaur> (compilers and their idiosyncratic options...)
16:50:55 <pavonia> ertes: What other files do you mean?
16:50:56 <ertes> s/outputs/objects/
16:51:15 <geekosaur> .hi files mostly, but probably also -ddump-MUMBLE output etc.
16:51:16 <Gurkenglas> ertes, right but then you still have to give a case expression to cata and that's awkward when you have extra functions for each constructor that take exactly the arguments of that constructor so makeCata lets you do something like, in this case http://codereview.stackexchange.com/questions/139752/lambda-calculus-interpreter-in-haskell "eval = expr id abst app sub"
16:51:23 <ertes> pavonia: anything intermediate you request, including interface files
16:51:43 <pavonia> Yeah, that's even better
16:52:01 <Gurkenglas> Also the unwrapping of Fix whenever you need to peer further into the data structure
16:53:06 <monochrom> I have a cunning plan. Don't define ADTs. Define Böhm-Berarducci encodings. Then there is nothing to derive. :)
16:54:09 <erisco> what are packages like atom?
16:54:37 <Gurkenglas> atom is not a package, right?
16:54:47 <erisco> http://hackage.haskell.org/package/atom
16:55:01 <Gurkenglas> Gah I assumed you meant to mean the editor
16:55:36 <slack1256T> what is the default FRP package for a non-web environment? (ie no reflex)?
16:56:03 <donkey_hotei> Hello - I was wondering if there is a mechanical way to change multiparam type classes with functional dependencies into one using type families and associated types?
16:56:17 <Gurkenglas> monochrom, then he'd have trouble ==ing the exprs, but maybe it'd be good if he had to work without that
16:56:19 <donkey_hotei> Specfically, I would like to use type families here:http://pastebin.com/XNkX33W6
16:56:32 <geekosaur> I *think* reactive-banana is the main one these days?
16:56:55 <monochrom> hmm, == is probably doable by catamorphism
16:57:17 <monochrom> but I was mainly joking. It shoves the real question under the rug :)
16:57:18 <geekosaur> (along with a suitable toolkit binding, e.g. reactive-banana-sdl2 or reactive-banana-wx
16:57:21 <geekosaur> )
16:58:14 <slack1256T> I had problems with reactive-banana-wx 3 years ago and to me that meant lack of interest. Yet it seems it was a wrong conclusion
16:58:54 <geekosaur> I am not sure that;d be r-b's fault. the wx package has been dubious for a while, sadly. so I'd suggest sdl2
16:59:57 <geekosaur> wx9 support broke a lot of stuff, and was itself broken :/
17:00:24 <geekosaur> er, Wx-0.9
17:01:58 <slack1256T> !!!
17:03:02 <slack1256T> I kind of like the sdl2 library (from edk), I didn't know any graphics programming until reading the signatures of those functions. I guess that will help me with that backend
17:11:47 <donkey_hotei> great, found what I needed here: https://ghc.haskell.org/trac/ghc/wiki/TFvsFD#ConvertingfromFDtoTF
17:28:29 <ertes> slack1256T: reflex can very well be used in a non-web context
17:28:40 <ertes> slack1256T: but reactive-banana is a good library, too
17:29:23 <ertes> in fact as a framework for callback-based toolkits it may be preferable
17:31:28 <ertes> slack1256T: AFRP frameworks are also still relevant, but only in real-time applications (games, simulations)…  as an old-school stable library i recommend Yampa
17:33:50 <ertes> you can also try my own AFRP library, but it's in a very early stage yet: https://hackage.haskell.org/package/wires
17:34:04 <saolof> is [f x y| x <- a, y <- b] or equivalent to f <$> a <*> b?
17:34:28 <ertes> saolof: yes
17:35:04 <saolof> Thanks ^^
17:36:24 <slack1256T> after learning to model using Arrow I can see myself using AFRP
17:37:15 <slack1256T> I always see that claim. That AFRP are for games simulation. and FRP for GUI (and the elm guys saying that even FRP for GUI doesn't work and push/pull (a la conduit/pipes) is better)
17:40:06 <ertes> slack1256T: FRP is really for any kind of interaction modelling, but current non-arrow implementations have at best a constant overhead and are less predictable performance/GC-wise
17:40:24 <ertes> reflex is very close to closing that gap, but it's not quite there yet
17:40:57 <ertes> that's really the only reason i started writing the new library
17:45:42 <slack1256T> ertes: wasn't your AFRP bases instead of just FRP? can that escape the targe of game and simulation only?
17:49:23 <ertes> slack1256T: sorry, not sure what you mean
17:50:54 <ertes> slack1256T: AFRP is still FRP, except it doesn't have fully first-class events and behaviours…  you can use it for anything you want, but you probably shouldn't
17:51:22 <ertes> it's mostly useful in this narrow domain of real-time applications with a "main loop"
17:51:24 <slack1256T> yeah, sorry about that, I miss read a reply!
17:54:44 <MarLinn> ertes, do you have any idea why the non-arrows FRP libs might have that overhead? Intuitively I would assume that the added flexibility would allow for some enhancements
17:55:13 <MarLinn> predictability though... maybe not so much
18:02:38 <ertes> MarLinn: AFRP is a very thin abstraction around functions and state by recursion…  it's pretty much as fast as it can get
18:03:17 <slack1256T> What is the standard way to integrate a (A)FRP system with a UI toolkit. Currently thinking on having (at least) to level. The FRP model and updates concurrently some MVars and another thread that is blocked (MVar) waiting for then and updating. Plus some MVars that triggers the model
18:03:19 <ertes> first-class FRP frameworks on the other hand have to do some very clever subscription and propagation under the hood
18:03:21 <slack1256T> .... MVC
18:04:56 <ertes> slack1256T: there is no standard…  with r-b you register callbacks, while with reflex you write a main loop…  with Yampa you hand control over to it and give it polling/rendering functions, with wires you embed those into the reactive system directly
18:05:08 <ertes> slack1256T: it depends on the design of the framework
18:05:41 <slack1256T> btw, what is r-b ?
18:05:53 <slack1256T> reactive banana?
18:09:22 <MarLinn> ertes: huh, that makes sense. You must add some overhead to get the flexibility instead of the other way around. Stupid me.
18:18:08 * hackagebot raft 0.3.7.0 - Miscellaneous Haskell utilities for data structures and data manipulation.  https://hackage.haskell.org/package/raft-0.3.7.0 (BrianBush)
18:28:47 <chrisbarrett> hey peeps! very specific trifecta question. I want to render error position carets in a Rendering context. I can create one and turn it into a PP.Doc with `renderingCaret`, but the pprinted source always starts at the beginning of the input string, with the careted positioned outside the rendering window. Can anyone figure out how to advance the rendering window? I've been poking around the haddocks for a while now. :)
18:29:03 <chrisbarrett> The relevant haddocks for trifecta are here: https://hackage.haskell.org/package/trifecta-1.6/docs/Text-Trifecta-Rendering.html
18:30:04 <chrisbarrett> my rendering code is here: https://github.com/chrisbarrett/apidoc-checker/blob/rewrite-validation/src/Apidoc/Render.hs#L24
19:02:12 <Gues> How do I detect an error from an IO operation such as putStr?
19:02:41 <johnw> exceptions
19:02:47 <glguy> Gues: You can use the operations in the Control.Exception module like try and catch
19:04:14 <glguy> IO actions found in base are likely to throw IOError exceptions specifically
19:06:46 <newhoggy> Does case x of {True -> 1; False -> 0} introduce a branch instruction in GHC?
19:07:49 <newhoggy> Or is there a branchless inlined (Bool -> Int) function?
19:08:04 <johnw> you can check with the "ghc-core" utility
19:08:21 <johnw> which also shows the resulting assembly code as well as the Core
19:08:34 <hiptobecubic_> I wrote an interpreter with a big transformer stack. I now want to model memory using mutable vectors and ST. I'm confused about where this fits into the types.
19:08:45 <hiptobecubic_> I was thinking something like this > type BrainFuck s a = ExceptT BrainFuckError (StateT (World s) (WriterT Output (ST s))) a
19:08:54 <hiptobecubic_> But that doesn't make sense to me, conceptually
19:09:14 <newhoggy> This one? https://hackage.haskell.org/package/ghc-core
19:10:28 <newhoggy> I'll try it out.  Thanks!
19:11:41 <johnw> chrisbarrett: sorry, I don't know
19:13:10 * hackagebot isotope 0.1.0.0 - Isotopic masses and relative abundances.  https://hackage.haskell.org/package/isotope-0.1.0.0 (Michaelt293)
19:16:27 <Narfinger> hiho, is there a good way to browse and modify the acid state for simple one time stuff?
19:24:06 <chrisbarrett> johnw: thanks for having a ponder :) 
19:30:32 <Gues> glguy: Thanks. It seems like I should write "try putStrLn "hello"" I'm struggling to output an error though. It seems like I should be able to call show on the exception, but there are type errors.
19:30:32 <Narfinger> oh I can just use the normal functions, I see
19:32:23 <Gues> glguy: Here's my crappy test: https://bpaste.net/show/a7fa6592143c
19:35:11 <techinberg> Hello??
19:35:27 <pavonia> Gues: What's the error?
19:35:35 <techinberg> LOL
19:36:19 <glguy> Gues: you'll need to annotate what type of error you're catching
19:36:28 <techinberg> Why wont GHCI accept my my type signature? http://pastebin.com/t0sSMzTz
19:36:32 <Gues> pavonia: I don't know. I assume putStrLn can result in an error
19:36:41 <glguy> like print (e :: IOError)
19:37:18 <Gues> This is actually another issue I have. I'm not sure how to check what errors can occur from an IO function
19:37:37 <Gues> The type of the function seems to be no help
19:37:47 <pavonia> techinberg: Put your definition into a module and load that into GHCi
19:38:09 <techinberg> Thank you
19:40:16 <Gues> glguy: Okay, thanks. That worked. Where is it documented what type of exceptions can occur from an IO function?
19:40:36 <Gues> glguy: How did you know to annotate IOError specifically?
19:40:37 <pavonia> That's actually one of the things I like about Java, the compiler will tell you what exceptions are thrown by a method
19:40:55 <Welkin> anything can happen in IO
19:41:00 <pavonia> or what are uncaught, that is
19:41:05 <Gues> I'm used to C where the error is returned by the function
19:41:25 <glguy> Gues: an IO action can throw any exception. generally you'll learn what can be thrown via documentation
19:41:25 <Welkin> exceptions are for exceptional cases, of course
19:42:28 <mniip> techinberg, otherwise use semicolons instead of newlines and the definition would work fine
19:42:34 <mniip> if you're in a recent enough ghci
19:45:16 <MarLinn> We should really refactor IO some day... maybe turn it into a monad stack with explicit error type annotations or something
19:45:31 <Gues> glguy: Any way to output an error to stderr if putStrLn fails in less than 4 lines?
19:45:54 <Gues> glguy: My try/case/Left/Right thing takes 4
19:46:29 <Gues> I could put all this in a function and reuse it though
19:47:04 <MarLinn> Gues: You can put a whole case clause on one line ;) Or maybe with "either"?
19:47:07 <Gues> Something like f (putStrLn "hi") "error string"
19:47:19 <Gues> I gues
19:47:21 <Gues> s
19:48:06 <Gues> Or better would be something that more transparently outputs default error strings to stderr like in a monad or something
19:48:17 <Gues> I don't really know what I'm talking about though
19:48:48 <Welkin> Gues: Writer is often used for logging
19:49:06 <Gues> I kind of remember that
19:49:15 <Gues> Can you "log" to stderr?
19:49:46 <Welkin> not outside of IO
19:50:02 <Gues> No, definitely inside IO
19:56:52 <techinberg> This is the error message I was having. http://pastebin.com/Cakd1gWw
19:57:36 <joe9> need some advice, please? I have a chart built using d3.js (renders as .svg to a browser). It slows to a crawl a few thousand data points. I want to render atleast 100K points. I am thinking of using sdl for the next version(haskell as the programming language). Is there a haskell library that can help calculate scale's, linear/logarithmic curve, etc?
19:59:06 <geekosaur> techinberg, it's telling you what you need. if you're going to use (==) and the compiler doesn't know that the type supports it (which it can't for an arbitrary type a), you need to add a context
19:59:24 <geekosaur> isPal :: Eq a => [a] -> Bool
20:00:14 <geekosaur> you can read that as "for some type 'a' that supports Eq, this function takes a list of 'a' and produces a Bool"
20:00:31 <techinberg> Ahhh
20:01:25 <mniip> geekosaur, probably hard to figure out what 'instance', 'Eq', or 'context' are on your own :p
20:02:26 <techinberg> It's been a while since I played with Haskell
20:02:46 <techinberg> I had some down time and thought I'd give it a try again.
20:03:26 <techinberg> Eq stands for equality?
20:03:31 <mniip> yes
20:03:36 <mniip> @src Eq
20:03:37 <geekosaur> effectively
20:03:37 <lambdabot> class Eq a where
20:03:37 <lambdabot>     (==), (/=) :: a -> a -> Bool
20:03:46 <mniip> it's the class that provides == and /=
20:04:17 <geekosaur> Eq is a typeclass. the typeclass defines (==) and (/=), so if you use one of those you incur an Eq context. if you use a fixed type, it can check that immediately and doesn't require the explicit context
20:04:42 <geekosaur> but for a type variab;e. you need to promise it you will only use it in the presence of an Eq typeclass instance
20:04:46 <techinberg> So any type that can be compared which would be all primitives
20:08:41 <mniip> not all
20:09:00 <mniip> the function arrow (->) a quite important primitive but can't be ==d
20:09:53 <mniip> functions can't be ==d I mean
20:13:13 <MarLinn> On the other hand you could tell Haskell how to compare two web servers via (==), so you're not limited to primitives
20:36:49 <glguy> Anyone know how to force a full redraw in the vty package? I'd hoped that that was what refresh was for, but that doesn't seem to be the case.
20:39:32 <geekosaur> huh. that eems to be what it's documented to do (notably unlike curses, where refresh outputs batched updates)
20:45:34 <joobus> To be able to use ghcmod with stack, do I need to install ghcmod locally to every project?
20:45:54 <hiptobecubic_> I would think not
20:47:01 <hiptobecubic_> Can anyone help me figure out how to switch these types to use mutable vectors? I'd like to use runST to run my evaluator, but I keep making a mess. https://github.com/johntyree/brnfckr/blob/vectormem/src/Brnfckr/Eval.hs#L21
20:47:04 <joobus> i know i can change to lts version in stack.yml so I would think ghcmod would need to match the ghc version I'm using in stack (although I haven't changed this)
20:47:26 <hiptobecubic_> Oh if you're changing the ghc version then maybe? Not sure
20:48:15 <joobus> for the vimmers: if I install ghcmod to a project, does ghcmod-vim know to use the project local ghcmod for checking in vim?
20:48:32 <hiptobecubic_> It will just try to invoke "ghcmod" 
20:48:49 <hiptobecubic_> So if it's in your path correctly, it should "just work"
20:49:30 <joobus> should i install ghcmod to the global stack directory and then symlink ghcmod to a directory in my path then?
20:51:07 <joobus> hiptobecubic_: are you a vimmer?
20:51:31 <hiptobecubic_> I am.
20:51:44 <joobus> do you use vim or neovim?
20:52:06 <hiptobecubic_> I have both, but I typically use vim because I forget to type "nvim"
20:52:59 <hiptobecubic_> symlinking ghcmod should be fine. As long as it's in your path somewhere
20:53:03 <joobus> i switched to neovim several months ago because performance seemed better, and I aliased 'vi' to 'nvim'.  I was curious if you ran into any issues, but I guess not.
20:53:16 <hiptobecubic_> I have not, no.
20:53:35 <hiptobecubic_> Everything has worked fine for me, although I haven't gone out of my way to make use of neovim features or plugins
20:54:52 <joobus> vim 8 is adding asynchronous communication which was one of the main feature of neovim, so I wonder if neovim has as much reason to exist when vim 8 comes out in a couple weeks and plugins start getting updated.
20:55:42 <hiptobecubic_> getting off topic, but the short answer is yes
20:56:39 <hiptobecubic_> it was funny. for  *years* bram's answer was always "async is not possible, stop asking"
20:57:09 <hiptobecubic_> then neovim came along and poof, next major release has it
21:03:28 <joobus> sweet, got ghcmod setup with neovim.  thanks for the help hiptobecubic_ 
21:08:49 <fjvallarino> exit
21:28:49 <benzrf> joobus: i actually recommend hdevtools more
21:28:58 <benzrf> it runs as a daemon so it's much faster
21:29:07 <benzrf> you dont have to wait for startup
21:31:05 <Gues> How is it that most IO a are not IO (Maybe a) due to the possibility of failure?
21:31:54 <glguy> So that you can handle multiple errors at once with a single try
21:33:14 <Gues> Well, for example openFile :: FilePath -> IOMode -> IO Handle
21:33:37 <Gues> What if the file path is not valid? What will the handle bee?
21:33:39 <Gues> *be
21:33:44 <glguy> It won't
21:34:02 <glguy> execution will unwind to the nearest exception handler
21:34:04 <monochrom> No, for example putStrLn "hello" followed by putStrLn "world"
21:34:53 <Gues> glguy: So, it wont ever return a result?
21:34:59 <monochrom> By your thinking, putStrLn :: String -> IO (Maybe ()) so I have to check each time whether I get a Nothing to indicate failures such as disk full.
21:35:00 <Gues> If an exception occurs
21:35:27 <Gues> Please understand I am not trying to make an inconvenient suggestion
21:35:29 <monochrom> And if I had 10 consecutive putStrLn's I would have to do that check 10 times.
21:35:38 <Gues> Just trying to understand how things work
21:36:07 <monochrom> No, I am deducing the logical conclusion to your proposal.
21:36:26 <Gues> Okay, whatever
21:36:28 <glguy> Gues: In the case of error there will be no result.
21:36:32 <monochrom> Is it inconvenient or not? You be the judge.
21:37:40 <joe9> any recommendations for a haskell realtime charting library to sdl/opengl/gtk?
21:38:08 <monochrom> The road to hell is paved with well intention.
21:38:18 <dyreshark> Gues: if you'd like to detect errors like that, https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Exception.html#g:3 might be interesting to you :)
21:38:20 <MarLinn> Gues, do notation could make monochroms case simple. You would just have to nest two do blocks. But guess how many newbies would stumble over that...
21:38:29 <monochrom> It's why only logical conclusion matters to me.
21:41:27 <Gues> glguy: So what happens when I collect multiple IO a into IO [a]? Does the list contain only the successes?
21:42:19 <glguy> Gues: You'd have to be more specific about what operation you're considering, but my guess is that you'll construct an operation that will give back no 'a' values if there is any failure
21:43:14 * hackagebot mongoDB 2.1.1.1 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  https://hackage.haskell.org/package/mongoDB-2.1.1.1 (VictorDenisov)
21:44:10 <Gues> glguy: For example if I have [FilePath] and I collect all the IO Handle into IO [Handle], will I get either no handles or all handles, or will I get all handles for which FilePath was valid?
21:44:23 <Gues> glguy: *from openFile
21:44:48 <glguy> Gues: Write some candidate code and put it on lpaste.net and we can discuss what the concrete code does
21:45:00 <Gues> Alright
21:47:11 <MarLinn> helloWorld = runMaybeT $ do {Just name <- getLine;  runMaybeT $ do {liftIO $ putStr "hello, "; liftIO $ print name;}} -- uh yeah!
21:48:14 <mniip> runMaybeT do runMaybeT?
21:49:01 <MarLinn> I was trying to imagine what it would look like if IO actions has type IO (Maybe a)
21:49:11 <MarLinn> Probably got a lot of details wrong
21:49:26 <MarLinn> s/has/had
21:50:09 <MarLinn> bottom line: a convoluted mess
21:50:21 <grantwu> For bind :: (Float -> (Float,String)) -> ((Float,String) -> (Float,String)), why does bind f' (gx,gs) = let (fx,fs) = f' gx in (fx,gs++fs) satisfy the type signature?
21:50:49 <mniip> runMaybeT $ do { Just name <- MaybeT getLine; MaybeT (putStr "hello, "); MaybeT (print name); }
21:50:53 <mniip> not too bad
21:51:11 <grantwu> Does the implicit currying let the definition cross the parenthesization of the type signature?
21:51:18 <lpaste> joobus pasted “Data constructor not in scope error” at http://lpaste.net/180925
21:51:29 <mniip> at that point though we'd probably have getLine :: MaybeT IO String, putStr :: String -> MaybeT IO ()
21:51:44 <joobus> can someone look at the past I just posted with my import issue, please?
21:51:45 <mniip> actually
21:51:56 <mniip> runMaybeT $ do { Just name <- liftIO getLine; MaybeT (putStr "hello, "); MaybeT (print name); }
21:51:57 <dolio> `a -> (b -> c)` is the same type as `a -> b -> c`.
21:52:33 <mniip> joobus, you imported Parser the type constructor
21:52:35 <geekosaur> joobus, you imported the type without the constructor
21:52:36 <mniip> try Parser(Parser)
21:52:40 <geekosaur> or Parser(..)
21:52:43 <mniip> or Parser(..) to import all
21:53:23 <joobus> it still doesn't like it with Parser(..)
21:53:38 <joobus> the module only exports 'Parser'
21:54:10 <MarLinn> mniip: granted we could make it work. Still, I doubt we could get many newcomers to stay after seeing it
21:54:30 <joobus> and the module doesn't export Parser(Parser)
21:54:32 <geekosaur> where did you add that? we were talking about at the top on the import line. compare Value(..) on line 1
21:54:45 <joobus> Yes, in the import line
21:55:12 <monochrom> Are you even supposed to write code like "getChild jsonKey (Parser (Just a)) = ..."?
21:55:30 <joobus> monochrom: I don't know, am I?
21:55:38 <monochrom> I don't think the Parser type works that way at all. It is not meant to be a concrete type.
21:55:39 <geekosaur> I don't think so, since when I dig into it I find it's not even aeson's Parser
21:55:43 <geekosaur> it's attoparsec's
21:55:47 <joobus> here is the module source: https://hackage.haskell.org/package/aeson-0.6.1.0/docs/src/Data-Aeson-Types.html#
21:56:21 <geekosaur> and I'm pretty sure you're not supposed to be dealing with attoparsec directly
21:57:05 * monochrom shakes head.
21:57:16 <mniip> newtype Parser a = Parser { runParser :: forall f r. Failure f r -> Success a f r -> f r }
21:57:19 <mniip> it's unexported
21:57:25 <mniip> and if it were, you are using it wrong
21:57:40 <monochrom> 1. If you use library source code like that, you're already lost.
21:58:03 <joobus> I was trying to write a function that can take a Parser (Maybe a) result from (.:?) and maybe get the next child down, and keep maybe drilling down
21:58:08 <mniip> depends, it might be okay if you're writing an adjacent library
21:58:09 <monochrom> 2. Even if you use library source code like that, how does that source code tell you that you have a Just or Nothing inside?
21:58:52 <joobus> monochrom: Parser (Maybe a) is the result of (.:?)
21:59:19 <geekosaur> btu Parser is like IO
21:59:23 <mniip> joobus, p >>= (.:? jsonKey)
21:59:35 <mniip> geekosaur, not at all, there isn't an unsafeRunParser
21:59:37 <MarLinn> grantwu: Yes. Broadly speaking the types in the signature alternate between "positive" and "negative" position, which more or less says what roles they can play (argument vs. result). You can change that with paranthesis, but the system is free to ignore paranthesis if it doesn't change anything
21:59:44 <geekosaur> you donlt take an IO apart to get the thing inside it, you use >>= (or <- in do)
21:59:53 <glguy> joobus: It might be more productive to paste some code that shows what you're trying to do and we could pick up from there
22:00:03 <mniip> glguy, he did
22:00:31 <glguy> I meant like at a higher level than the implementation of getChild in http://lpaste.net/180925
22:00:35 <joobus> ((v .:? "preview") >>= getChild "images" >>= nth 0 >>= getChild "source" >>= getChild "url")
22:00:41 <joobus> something like that
22:01:54 <monochrom> RIght, I don't even understand the motivation behind "String -> Parser (Maybe a) -> Parser (Maybe b)".
22:01:54 <joobus> If Parser is already a monad, then >>= will only give back the Maybe monad, but I needed the Value inside the Maybe to apply (.:?) again
22:02:10 <mniip> :t (>>=)
22:02:12 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:02:21 <mniip> it does give you a pure a to apply to .:?
22:02:47 <mniip> ah well
22:03:08 <joobus> but in the case of Parser (Maybe Value), wouldn't >>= just give back a Maybe?
22:03:12 <glguy> joobus: and you want this to  be optional?
22:03:14 <mniip> right
22:03:22 <glguy> If the path isn't available it returns Nothing?
22:03:34 <monochrom> you can use pattern matching on Just vs Nothing, you know that?
22:03:44 <joobus> yes
22:04:02 <mniip> you're looking for 'fmap (>>= (.:? jsonKey))' then
22:04:25 <glguy> It's going to be more like: optional (   (v .: "preview") >>= (.: "images") >>= nth 0 >>= (.: "source") >>= (.: "url") )
22:05:43 <glguy> joobus: What's nth from? are you using lens-aeson?
22:05:53 <glguy> or is that just an example
22:06:11 <joobus> glguy: yes, data.aeson.lens
22:07:34 <joobus> glguy: where is 'optional' defined?
22:07:40 <glguy> Control.Applicative
22:07:54 <glguy> preview (key "preview" . key "images" . nth 0 . key "source" . key "url") :: Value -> Maybe Value
22:08:00 <glguy> That's how you'd do it with lens-aeson
22:10:34 <joobus> thanks geekosaur mniip glguy monochrom 
22:11:52 <joobus> glguy: where does 'preview' come from?
22:12:03 <glguy> Control.Lens
22:12:09 <joobus> thanks
22:20:00 <Gues> glguy: Alright, so what happens in this program is if a single invalid file path is passed in, nothing is printed: https://bpaste.net/show/133ba8e3e48e
22:21:15 <Gues> glguy: That's not technically true. What is printed is an error regarding the first invalid file path
22:22:54 <Gues> glguy: So, what I would like the program to do is output the number of valid file paths passed in
22:26:47 <MarLinn> Gues: how about something along the lines of getFileStatusMaybe = try getFileStatus >>= either (const Nothing) Just 
22:27:08 <MarLinn> (with added type sig, of course)
22:27:44 <glguy> You could do: results <- mapM (try . getFileStatus) files
22:28:11 <glguy> by having one try per file tested you'll be able to recover from failure without interfering with the next file
22:28:21 <glguy> MarLinn: You'd want to do fmap rather than >>= for that
22:29:10 <MarLinn> Of course. And why re-wrap if you've got an Either anyway
22:38:11 <joe9> What is FRP?
22:38:48 <Hi-Angel> Functional Reactive Programming, I guess
22:38:51 <Gues> joe9: Functional Reactive Programming
22:39:01 <Gues> joe9: Trying to model functions of time
22:40:20 <joe9> I want to build a realtime chart app from haskell (backend, most probably opengl). using dynamic-graph. Can FRP help me? Reactive banana seems to be the most popular
22:40:31 <Jackoe> If you have the time, http://www.haskellcast.com/episode/009-conal-elliott-on-frp-and-denotational-design/ <-- this episode might introduce you
22:40:44 <Jackoe> and reactive bananna is the most popular
22:40:47 <orion> joe9: You want to render the image data in Haskell?
22:41:09 <Gues> Last time I tried FRP it was still very experimental
22:41:15 <joe9> orion: I used to use d3.js and it starts choking with a few thousand values.
22:41:21 <Gues> Ran into lots of problems
22:41:47 <joe9> orion: I want to render close to 100k values. canvas seems ok to a few 10,000 values.
22:41:56 <Gues> One problem is accumulating information from the past that you no longer need and wasting RAM
22:42:01 <joe9> orion, I think my best bet is to check out something like dynamic-graph.
22:42:15 <MarLinn> I'm not sure about opengl, but there are sdl2 bindings for reactive banana
22:43:26 <joe9> https://hackage.haskell.org/package/dynamic-graph seems to be my best bet for an existing library.
22:46:05 <MarLinn> so.. no FRP necessary, I suppose
22:47:01 <joe9> MarLinn, When I am searching for haskell libraries rendering using SDL or OpenGL, I am coming across the term FRP. Not sure if that is recommended or not.
22:49:05 <glguy> Other than inspecting the output of show or diving into GHC.IO.Exception, is there a way to determine that an IOError was a ResourceVanished type?
22:50:13 <Gues> glguy: I'm not sure how to annotate try in your example. I have Exception type ambiguity again
22:51:27 <MarLinn> joe9: FRP seems to be what most consider to be "the right way" for GUIs. What I meant was thatBut the package you linked seems to have a lot of stuff already built in, so maybe you don't even need something extra
22:51:32 <Gues> By the way, are there more specific try functions that remove this ambiguity?
22:51:33 <MarLinn> *-But
22:51:43 <Gues> tryIOError for example
22:52:04 <glguy> Gues: No, but you can write one
22:52:37 <glguy> tryIOError :: IO a -> IO (Either IOError a); tryIOError = try
22:52:51 <Gues> glguy: Cool. Thank you
22:54:20 <joe9> MarLinn, Thanks.
22:54:25 <MarLinn> joe9: But GUIs are not Haskell's strength currently. It could even be easier to have the graph rendered as an image and to serve that as a website
22:54:58 <joe9> MarLinn: It is a realtime data feed.
22:57:07 <MarLinn> I'm just gonna say "good luck". You're definitely choosing the path less travelled by
23:15:32 <gestone> hey all, i'm trying to use ReaderT for the first time in some actual code and i'm running into some issues
23:15:45 <gestone> http://lpaste.net/180937 is currently what i have
23:18:23 <gestone> i ran into the issue that ReaderT b m Int could not be matched with the actual type String -> ReaderT r0 m0 a0. i was under the impression that each of these functions would utilize the Reader's environment where i pass it in the url
23:19:56 <MarLinn> gestone: Looks like one of your functions has the wrong type. Hard to say without their types, though
23:20:08 <gestone> i'll post the full impl
23:20:48 <gestone> http://lpaste.net/180940
23:21:08 <MarLinn> gestone: btw, that almost looks like you could use the Applicative instance instead of do notation
23:21:32 <gestone> oh really? like Song <$> func <*> func2 <*>...?
23:21:50 <mauke> what are all those ReaderT's doing there?
23:22:14 <gestone> ah i thought the types inside of the do notation had to be ReaderT's
23:22:45 <mauke> they do
23:23:30 <gestone> so... wrapping the do blocks in ReaderT's was the right thing to do?
23:23:35 <mauke> ... no?
23:23:45 <mauke> do you write 'main = IO $ do ...' for IO code?
23:23:55 <gestone> ah very true
23:24:46 <mauke> it looks like you started with functions of type String -> IO something
23:24:51 <mauke> foo u = do ...
23:25:05 <gestone> yep
23:25:21 <mauke> you can turn that into ReaderT String IO something: foo = do u <- ask; liftIO (do ...)
23:26:42 <mauke> hmm. foo = ReaderT $ \u -> do ... could also work
23:26:52 <MarLinn> gestone: I would also suggest factoring out some of these sub-function. If nothing else it helps you narrow down where error messages come from
23:27:09 <gestone> would it just make more sense to condense these down into one function?
23:27:29 <MarLinn> And eg. getDuration looks almost pure
23:27:51 <gestone> yeah, each of the functions have IO surrounding it
23:28:50 <MarLinn> Well, it's always a trade-off. Do-notation and factoring out gives you more names and thus more hints. Applicative notation and condensing gives you less code
23:29:08 <MarLinn> But if it's hard to track down an error that usually means the code is too condensed already
23:32:59 <gestone> MarLinn: ah, figured out the issue, i just needed to ask for the url and call it as mauke suggested
23:33:17 * hackagebot ghc-prof 1.0.0 - Library for parsing GHC time and allocation profiling reports  https://hackage.haskell.org/package/ghc-prof-1.0.0 (MitsutoshiAoe)
23:33:19 <gestone> meh my code looks uglier now with all the lifts
23:33:53 <gestone> i'm probably better off without ReaderT, i still haven't found a great use case for this transformer
23:34:34 <mauke> agreed. ReaderT is basically different syntax for a function argument
23:35:41 <gestone> yeah i was about to say, what's the point of adding more complexity by wrapping it in ReaderT when i'm just going to call ask to get the function argument?
23:36:21 <gestone> i guess... it's could be more useful when composing monad transformers?
23:39:33 <gestone> is anyone aware if there's a liftAx function anywhere? i only see upto liftA3 in Control.Applicative
23:39:43 <athan> gestone: <*> :)
23:40:03 <athan> liftA4 f x y z q = f <$> x <*> y <*> x <*> q
23:40:10 <athan> er whatever >.>
23:40:22 <gestone> :P yeah i could write my own
23:40:44 <athan> gestone: MonadReader is really useful when you consider your monad stack as a monolith
23:41:04 <athan> where you expect to have some kind of runtime-varying arguments, where static in your effect stack, you'd still like to peek into them
23:42:19 <gestone> sorry you have me a little lost, could you provide an example?
23:42:22 <athan> I usually have some kind of `ReaderT Env ...` type, where Env has info like the `cwd`, and flags supplied to the executable
23:42:54 <athan> So Main fills in the Env data, then you conveniently have access to it in your effects stack
23:43:20 <gestone> ahh i see. so you don't have to keep on passing it around to different functions
23:43:43 <gestone> you can just convinently call ask to get your global environment
23:44:13 <MarLinn> gestone, about ReaderT: you could factor out a youtube-getter as a ReaderT. Then it would make some sense to use the wrapper. I mean it sounds like a good idea to factor it out anyway
23:44:24 <athan> gestone: Exactly :)
23:44:24 <athan> this is assuming your effect stack is static throughout your app though
23:44:51 <athan> if you have subcomponents of your app using a subset or superset of those effects, you'd need to do some monad morphism stuff to shuffle the data around
23:46:02 <gestone> MarLinn: how would i begin to factor it out? each of the functions have different flags
23:46:12 <athan> MarLinn, gestone: Yeah right now in my app I have a `Env { database :: AcidState Database ... }` component, where if my app is run in "development" mode, it's an in-memory mock database, vs. in "production" it actually stores to disc
23:47:11 <gestone> athan: oh that's interesting
23:48:08 <athan> gestone: You can do the same for functions too :)
23:48:28 <MarLinn> gestone: the query could be a function argument
23:48:43 <athan> I'm doing it with a session cache - development is just in-memory, while production connects to memcached. They both have a type `SessionId -> IO UserId`, so I'm good to go
23:48:44 <MarLinn> s/query/flag
23:49:31 <gestone> athan, MarLinn: oh that makes sense, so i could have readProcessWithExitCode "youtube-dl" be in the ReaderT env
23:51:02 <gestone> athan: out of curiosity, how long have you been using haskell for?
23:56:42 <athan> gestone: A few years now
23:57:23 <MarLinn> It feels like there should be a nicer way to get coeffects into our apps, but I guess right now MonadReader is the only reasonable large scale option. Implicit variables or OverloadedLabels can't quite cut it yet.
23:58:13 <gestone> athan: oh cool, this is my second month (attempting) to use haskell
23:59:12 <gestone> i must say, this is language has quite the following and a friendly community
23:59:42 <MarLinn> gestone: I'd say you're doing great for that short amount of time.
