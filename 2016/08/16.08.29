00:07:39 * hackagebot pretty-types 0.2.1.0 - A small pretty printing DSL for complex types.  https://hackage.haskell.org/package/pretty-types-0.2.1.0 (SvenHeyll)
00:07:39 * hackagebot hasktags 0.69.2 - Produces ctags "tags" and etags "TAGS" files for Haskell programs  https://hackage.haskell.org/package/hasktags-0.69.2 (jhenahan)
00:11:25 <MarLinn> saurabhnanda, I don't have time to test right now, but it sounds like there might be a problem with the encoding
00:11:56 <saurabhnanda> MarLinn: all docs say that HTML is escaped by default and everything is UTF8 in Yesod.
00:12:06 <saurabhnanda> MarLinn: I'm moving on to the next benchmark. See if you can help me out with this.
00:12:55 <MarLinn> Maybe postgresql is missconfigured somehow?
00:13:17 <hiptobecubic_> I would test that first
00:13:25 <hiptobecubic_> run one of the other benchmarks against the same db
00:16:40 <saurabhnanda> MarLinn: does the PG connections string have any setting for encoding?
00:16:58 <saurabhnanda> hiptobecubic_: does the PG connections string have any setting for encoding?
00:17:13 <hiptobecubic_> I wouldn't know, unfortunately.
00:17:27 <MarLinn> saurabhnanda: the persistent TH says that fortunes are Text. Text is UTF16 I think. I would expect both persistent and yesod to handle that, but might be worth a check?
00:17:54 <saurabhnanda> hmm even UTF16 <=> UTF8 is a problem?
00:19:28 <MarLinn> could be...
00:24:49 * Ford_Prefect waves to saurabhnanda
00:25:16 <saurabhnanda> Ford_Prefect: I've heard that username somewhere... in a galaxy far far away... who could it be now?
00:25:39 <Ford_Prefect> off to PM to avoid spamming the channel
00:30:14 <MarLinn> It seems you can only set the default encoding in postgresql and at least scaffolded Yesod doesn't change it
00:31:00 <MarLinn> What's more scaffolded Yesod seems to use Text in the DB. Don't know how well it might have been tested, though
00:32:34 * hackagebot yesod-core 1.4.24 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.24 (MichaelSnoyman)
00:32:35 <MarLinn> I don't know what sql=... does, though, so no idea if it changes anything
00:37:34 * hackagebot mysql-haskell 0.4.1.0 - pure haskell MySQL driver  https://hackage.haskell.org/package/mysql-haskell-0.4.1.0 (winterland)
00:39:53 <saurabhnanda> MarLinn: my console is giving me locale warnings -- could that have any impact?
00:42:13 <MarLinn> saurabhnanda: If Yesod takes your locale into account then I would classify that as a serious bug.
00:43:07 <MarLinn> saurabhnanda: But Snoyman is from Israel (I think) so he should not have fallen into the common "America is the world" trap.
00:43:41 <MarLinn> I've also run Yesod servers from machines with different locales without incident, but then maybe my samples where too clean
00:45:14 <saurabhnanda> MarLinn: from a PG standpoint. Is the shell local affecting PG?
00:45:19 <saurabhnanda> *locale
00:45:32 <saurabhnanda> trying the DB update benchmark now... let's see if this verifies
00:45:35 <MarLinn> Not according to what I found
00:45:52 <MarLinn> But just to make sure: how did you enter the test data into the DB? Could they have been changed there?
00:46:53 <saurabhnanda> From the logs -- Content encoding found in "application/json; charset=utf-8" where "application/json" is acceptable.
00:47:09 <saurabhnanda> everything is UTF8 -- Yesod is even putting it in the response headers
00:47:22 <MarLinn> Huh...
00:47:32 <saurabhnanda> MarLinn: their harness. The MySQL test is passing. The Postgres test is failing.
00:47:42 <saurabhnanda> could it be that their PG harness is buggy?
00:48:03 <MarLinn> Wouldn't they have caught that by now?
00:48:56 <saurabhnanda> hmm
00:49:12 <MarLinn> Can you see what happens to the data when it's returned?
00:49:18 <saurabhnanda> Have mailed on yesod@  -- hope Snoyman replies amidst all the political mess
00:49:29 <saurabhnanda> does he hang around on IRC, btw?
00:50:32 <MarLinn> The only place I see in the code that has something to do with encoding is the connection string. I'm not sure if C8 is correct, but it must be working, and shouldn't have anything to do with the type of the stored data
00:50:55 <saurabhnanda> Btw, here's what I have till now -- https://gist.github.com/saurabhnanda/6f3e7afd5c7153e72b0f5ab599346090
00:51:22 <saurabhnanda> surprised with the multiple query benchmarks... the requests seem to be decreasing as concurrency increases. Not the case with single query benchmark
00:52:15 <saurabhnanda> and it seems to be happening with every framework out there
00:52:18 <saurabhnanda> https://www.techempower.com/benchmarks/previews/round13/#section=data-r13&hw=azu&test=query
00:52:20 <Rudes> has anyone gotten the cabal test with library coverage working? i keep getting errors in cabal test even though it's passing
00:58:54 <tdammers> probably late to the party, but: Text is internally UTF-16, but that doesn't really matter, because just like String, it's conceptually an encoding-agnostic unicode type
00:59:34 <tdammers> which of course means that when you send Texts to a database API that also takes Texts, any encoding issues are the database API implementor's fault
01:01:18 <Rudes> nvm to my issue, got it
01:03:45 <MarLinn> The documentation is horrible again. According to what I found, Text is converted to UTF-8 varchar in MySQL. Or Text, maybe. Which is equivalent to a varchar in postgresql, maybe
01:04:11 <MarLinn> word size might have something to do it, or not
01:05:16 <merijn> MarLinn: Assuming C8 stands for "Char8", the answer is "no, it's not correct. In fact it's so wrong it makes me sad"
01:05:45 <merijn> I wish we could retroactively prevent that module from ever being written >.>
01:06:24 <saurabhnanda> merijn: which module?
01:06:31 <MarLinn> merijn, that's what I thought. Must be a wonder the database connection gets even established, then...
01:06:35 <merijn> saurabhnanda: Data.ByteString.Char8
01:06:40 <saurabhnanda> I can give access to my EC2 cluster if anyone wants to take a closer look
01:06:44 <merijn> MarLinn: Basically, it silently drops anything non-ASCII
01:06:50 <merijn> MarLinn: Corrupting everything
01:06:57 <saurabhnanda> merijn: is that PG or MySQL?
01:07:09 <merijn> saurabhnanda: ?
01:07:23 <saurabhnanda> merijn: who drops anything non-ASCII?
01:07:45 <merijn> saurabhnanda: Data.ByteString.Char8
01:08:06 <saurabhnanda> ah koay
01:08:13 <saurabhnanda> but that's just the connectionString right?
01:08:21 <saurabhnanda> what about the data exchange between Pg and Haskell?
01:08:44 <merijn> I don't have a clue, I don't use Pg
01:08:47 <MarLinn> saurabhnanda: Yes
01:10:36 <merijn> MarLinn: I don't know how the types match up
01:10:54 <sooheon> hello, I'm trying to follow a somewhat outdated tutorial online, it looks like whatever version of haskell I've installed by default through stack doesn't include the Text.Regex module by default. It prompts me to replace this with Text.Read, but it doesn't look like it does the same thing--how can I install Text.Regex in my .cabal file?
01:11:02 <merijn> MarLinn: But, assuming your database expect data in a specific encoding you want Data.Text.Encoding
01:11:27 <cocreature> sooheon: do you have a cabal project or are you just running "stack ghc" on a .hs file
01:11:44 <sooheon> I've just made an empty project with "stack new proj simple"
01:11:47 <saurabhnanda> okay my test suite is complete
01:11:49 <sooheon> so i do have a .cabal file
01:11:53 <saurabhnanda> EXCEPT this stupid encoding issue.
01:12:05 <MarLinn> merijn: no one seems to know. The documentation is thin and mixes all possible databases into one -_-
01:12:17 <Cale> sooheon: I believe that's in the regex-compat package?
01:12:26 <sooheon> I'll try that, thanks
01:12:41 <cocreature> sooheon: and you need to add that package to the build-depends in your cabal file
01:12:50 <cocreature> then "stack build" will install it
01:13:08 <sooheon> Yeah looks like stack build is going through with it. Any idea why regex was taken out of the base install? just not core enough?
01:13:24 <merijn> sooheon: It's never been in there
01:13:25 <cocreature> I’m not sure if it ever was in the base install
01:13:31 <sooheon> I've had to also install System.Random
01:13:49 <merijn> I guess maybe both of those were in the Haskell Platform?
01:13:52 <sooheon> Ah ok, so this tutorial I'm following is just assuming a larger install
01:14:20 * Cale shudders at the thought of that package getting merged into base
01:14:20 <MarLinn> saurabhnanda: Can you check what the DB itself says about the column encoding by logging into it yourself?
01:14:35 <saurabhnanda> MarLinn: let me try
01:15:07 <MarLinn> saurabhnanda: Maybe also read the data so we can check where it gets changed
01:15:07 <sooheon> Cale: Haha thanks. where do I search centrally for these available packages, names, versions etc? Googling is pretty difficult for this.
01:15:20 <cocreature> where did Text.Regex come from originally?
01:15:32 <Cale> http://hackage.haskell.org/
01:15:56 <cocreature> sooheon: http://hoogle.haskell.org/ is pretty good if you know a modulename or function name and are trying to figure out the package where it came from
01:17:16 <sooheon> Searching for "System.Random" gives nothing there, I guess I have to search "radom", and figure out what's the appropriate one. There doesn't seem to be any kind of ranking.
01:17:46 <Cale> Yeah, usually I just google the module name and then "hackage"
01:17:51 <sooheon> ah it's ranked correctly with "random", but differently with "Random". Weird
01:18:10 <sooheon> Thanks guys
01:18:11 <Cale> https://www.google.ca/?ion=1&espv=2#q=System.Random+hackage
01:18:27 <sooheon> ah yeah that's even better
01:18:29 <ion> ion=1
01:18:38 <Cale> sometimes that will link to an older version of the package documentation though, so watch out for that :)
01:18:45 <cocreature> sooheon: hm the first hit for System.Random is the random package for me
01:19:18 <cocreature> you can also be more precise using is:module http://hoogle.haskell.org/?hoogle=System.Random%20is%3Amodule
01:19:22 <sooheon> cocreature: I see generators, randfile, mersenne-random-pure64, normaldistribution
01:19:33 <Cale> https://chrome.google.com/webstore/detail/hackage-fu/dnpldbohleinhdgfnhlkofpgkdcfcfmf?utm_source=chrome-app-launcher-info-dialog -- this google chrome extension will add links to the documentation on hackage which will warn you when you're looking at an old version and link the latest
01:19:56 <sooheon> cool
01:20:08 <MarLinn> http://hackage.haskell.org/packages/tag/randomization -- seems a little... sparse
01:20:59 <Cale> Yeah, unfortunately the search on Hackage doesn't include module names, just the package name and description
01:21:04 <sooheon> cocreature: I just realized I'm searching Hackage directly and you referred me to Hoogle--you're correct that has better results
01:21:20 <Cale> Yeah, Hoogle will do a better job there
01:23:08 <cocreature> I only use the hackage search if I am searching a specific package
01:23:10 <saurabhnanda> request for code review -- https://github.com/TechEmpower/FrameworkBenchmarks/pull/2247
01:23:17 <cocreature> and even then it is extremely good at not showing me what I’m looking for
01:23:24 <sooheon> haha yeah
01:23:30 <saurabhnanda> MarLinn: Cale: glguy: merijn: request for code review -- https://github.com/TechEmpower/FrameworkBenchmarks/pull/2247
01:25:26 <suppi> if i have a list of packages or a cabal sandbox, how can i download the .tar.gz for each package?
01:26:04 <sooheon> a quick emacs question: is there a way to inspect the source of functions from module? I know there's :t, but I can't understand everything just from that. And no functions seem to have docstrings...
01:26:22 <suppi> cabal fetch maybe?
01:27:24 <suppi> sooheon: there goto source option, not sure regarding the docstring
01:27:38 <cocreature> sooheon: intero has a "goto definition" function but that only works if the definition is in the same package. I don’t think there is a general way to do this
01:27:39 <Cale> sooheon: Usually (if it was generated correctly), the documentation has source links on the right
01:27:40 <Reshi> sooheon: Haskell mode? jump-to-def-or-tag, which is bound to `M-.` usually I think.
01:27:55 <Cale> Oh, but you're asking about emacs, so I dunno
01:28:28 <sooheon> I'm using intero-mode, and the M-. binding does nothing. I guess this is a config problem? Though M-x jump-to-def-or-tag isn't working for me either..
01:28:56 <sooheon> cocreature: ah it only works if it's defined in the same package. As in if I'm writing something, it only finds definitions I've written?
01:29:32 <cocreature> sooheon: (sadly) yes
01:29:49 <Cale> What I do is from say, http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Map-Lazy.html#v:difference  I'll click the source link on the far right and it'll take me to  http://hackage.haskell.org/package/containers-0.5.7.1/docs/src/Data.Map.Base.html#difference  which in this case, is nicely hyperlinked source
01:29:57 <sooheon> so all of you haskellers really just figure everything out by the type singnature?!
01:30:15 <cocreature> no I type function names in hoogle and then follow what Cale explained
01:30:16 <Cale> But yeah, the type signature is often enough to know how to go forward
01:30:50 <cocreature> also there are packages that have documentation :)
01:30:58 <cocreature> so the times I look at the source are relatively limited
01:31:07 <sooheon> what's the :t equivalent for docstrings?
01:31:13 <cocreature> there is none
01:31:21 <cocreature> you have to look at the haddock pages
01:31:32 <Cale> In this case, from  "difference :: Ord k => Map k a -> Map k b -> Map k a"  I could totally guess what the thing is computing, and I *know* that it's left-biased from its type.
01:31:48 <sooheon> haddock meaning what Cale linked to above?
01:31:55 <cocreature> yeah
01:32:18 <cocreature> if you type the function name in hoogle http://hoogle.haskell.org/?hoogle=map and then click on one of the links it takes you to the corresponding haddocks
01:32:19 <Cale> The documentation might not be installed on your system. It would be nice if ghci could interact with it when it is.
01:32:36 <cocreature> yeah integrating docs in ghci would be great
01:32:36 <sooheon> Ok cool. I'm sure theres an emacs package that integrates that...(probably)
01:33:41 <cocreature> if you find one tell me about it :)
01:34:29 <suppi> it's being worked on in intero at least
01:34:41 <Cale> When *I* was learning Haskell, the documentation looked like this: https://downloads.haskell.org/~ghc/5.02.3/docs/set/finitemap.html
01:34:56 <Cale> https://downloads.haskell.org/~ghc/5.02.3/docs/set/set.html
01:35:04 <cocreature> ouch
01:35:18 <cocreature> I’m glad I’m too young to have experienced that
01:35:48 <Cale> But really, I'm sure you could guess correctly what all of these functions do :)
01:36:02 <cocreature> addlisttofm_c is completely obvious
01:36:15 <sooheon> no syntax highlighting? how did you survive grandpa?!
01:36:57 <Cale> "Guess what? The implementation uses balanced trees."
01:37:21 <Cale> haha
01:37:47 <merijn> Cale: Stop waving your stick about, grandpa ;)
01:39:16 <Hi-Angel> How to force `stack setup` to install later version of `cabal-install`? It for some reason doesn't resolve it automatically from the `./glib.cabal` file :/
01:39:35 <MarLinn> When I was learning Haskell with Hugs I spend hours in the sources that were installed with it. I learned a lot just looking at the code. Discovered ($), and "unlines", and "intercalate", and a crazy thing called "Traversable"... good times...
01:40:06 <michbad> is there a way to map a sequence of pure functions over a monadic value, so that i write the value first, and the function in the order of application?
01:42:01 <Cale> MarLinn: I'm actually kind of surprised that you would have found Traversable -- it came along pretty late to be in Hugs, but I suppose it did make it into the 2006 release
01:42:54 <lyxia> michbad: x <&> (f1 >>> f2 ... >>> fn) ?
01:43:00 <saurabhnanda> MarLinn: DB is UTF8 -- https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/config/create-postgres-database.sql#L4
01:43:14 <merijn> lyxia: Why >>> instead of (.)?
01:43:23 <Hi-Angel> MarLinn, agree, having a project to work on allows to advance in the language much more, than just reading occasional tutorials. E.g. I'm tackling with Yi, and getting more experience just from seeing things already implemented; in particular extensions.
01:43:25 <Cale> michbad: fmap?
01:43:34 <Cale> oh, the value first
01:43:59 <Cale> merijn: to be consistently backward
01:44:27 <michbad> lyxia: where is that from? i remembered threre was something with the three arrows, but i can't find a list of all operators like that, and it gets confusing
01:44:39 <MarLinn> Cale: I stayed with hugs for quite some time until I finally worked up the courage to try this strange thing I found that seemed to be like hugs but looked like a primitive console...
01:44:39 <Cale> That's from Control.Arrow
01:45:24 <michbad> is there a reference that would list all operators like >=>, >>, >>> and so on?
01:45:36 <Cale> Hoogle will find them
01:45:46 <Cale> https://www.haskell.org/hoogle/?hoogle=%3E%3E%3E
01:45:50 <merijn> Cale: >>> is also in Control.Category, no?
01:45:56 <Cale> Apparently so
01:45:58 <merijn> Seems that one might be more sensible
01:46:11 <cocreature> michbad: *all* operators is not possible since each package can define new operators
01:46:31 <Cale> Infix operators are just functions whose names are made of symbol characters
01:47:38 <michbad> I don't know what exists, so I can't look for them on Hoogle - I'm getting comfortable with monads, but haven't learned about Arrows yet
01:47:39 <lyxia> Control.Arrow reexports >>> from Control.Category
01:48:04 <Cale> michbad: Well, you can't hope to care about every infix operator that anyone's ever defined somewhere :)
01:48:37 <sooheon> A little tangent, but why, when the language supports incremental partial application, are infix operators a thing?
01:48:44 <cocreature> michbad: don’t worry about arrows too much. apart from some frp packages they are barely used (apart from manipulating tuples maybe)
01:48:50 <Cale> sooheon: why not?
01:49:02 <lyxia> <&> can be found in lens and a couple of other packages, making it more unlikely to be used. It's a one-liner to define though.
01:49:10 <sooheon> Like I'm really enjoying how every a -> a -> b in the function means each step returns a partial function
01:49:14 <sooheon> but I can't do that with >
01:49:15 <Cale> sooheon: You can even partially apply the infix operators
01:49:16 <cocreature> sooheon: because non lispers think that 1 + 2 reads nicer than (+ 1 2)
01:49:22 <Cale> Sure you can
01:49:27 <Cale> :t (>) 5
01:49:29 <lambdabot> (Ord a, Num a) => a -> Bool
01:49:33 <Cale> :t (5 >)
01:49:34 <lambdabot> (Ord a, Num a) => a -> Bool
01:49:35 <sooheon> I'd like to do say `(>) 1 2 3 4 5`
01:49:57 <Cale> Well, (>) 1 2 :: Bool
01:49:58 <sooheon> Like in clojure you could do (> 1 2 3 4 5) to return a bool
01:50:05 <Cale> and so you can't apply it to another argument
01:50:26 <Cale> What type would (>) 1 2  have then?
01:50:27 <sooheon> and I'm asking the reason (>) is defined that way is for it to make sense as an infix operator
01:50:46 <michbad> lyxia: sorry, and what is <&>?
01:50:51 <Cale> Well, the reason it's defined that way is because it's a binary relation in mathematics :)
01:50:52 <cocreature> imho it’s non obvious what (> 1 2 3 4 5) does
01:50:59 <lyxia> michbad: flip fmap
01:51:04 <suppi> you want to operate on lists rather than arguments
01:51:27 <michbad> okay, thank you! i will look more into that
01:51:55 <sooheon> Hm actually I do get that about > being binary; it seems clojure was essentially making syntax sugar for that
01:52:03 <Cale> > all (1 >) [2,3,4,5]
01:52:06 <lambdabot>  False
01:52:09 <Cale> > any (1 >) [2,3,4,5]
01:52:11 <lambdabot>  False
01:52:25 <Cale> (poor examples...)
01:52:27 <sooheon> any (1 <) [2..5]
01:52:34 <sooheon> > any (1 <) [2..5]
01:52:36 <lambdabot>  True
01:52:43 <sooheon> > all (1 <) [2..5]
01:52:45 <lambdabot>  True
01:53:31 <Cale> > and . zipWith (<) <*> tail $ [1..5]
01:53:33 <lambdabot>  error:
01:53:33 <lambdabot>      • Couldn't match type ‘Bool’ with ‘[t0] -> t’
01:53:33 <lambdabot>        Expected type: [t0] -> [t0] -> t
01:53:39 <Cale> heh, precedence
01:53:44 <Cale> > and . (zipWith (<) <*> tail) $ [1..5]
01:53:46 <lambdabot>  True
01:53:52 <black0range> technicly all arguements  in lisp are lists :)
01:53:58 <suppi> is there an equivalent of cabal get that doesn't unpack the package?
01:54:06 <Cale> > and . (zipWith (<) <*> tail) $ [1,2,3,2,5]
01:54:09 <lambdabot>  False
01:54:12 <black0range> so the lisp type of (>) would be [a] -> Bool 
01:54:20 <suppi> black0range: 1 is not a list :)
01:54:27 <lyxia> michbad: (<&>) = flip (<$>) parallels (&) = flip ($)
01:54:31 <cocreature> black0range: Ord a => [a] -> Bool :)
01:54:48 <black0range> supp: i mean how the arguments are passed to the functions :)
01:55:17 <Cale> Which lisp?
01:55:50 <michbad> lyxia: thanks!
01:55:56 <black0range> thinking specificly of scheme :)
01:59:22 <nmdanny> is there a way of having HSpec tests with shared state inbetween?
02:00:17 <black0range> (define + (lambda args (if (null args) 0 (internal-plus (car args) (apply +  (cdr args)))))) would be a definintion of plus 
02:00:30 <lyxia> michbad: x <&> f1 <&> f2 <&> ... <&> fn  also works and looks flatter!
02:00:37 <cocreature> nmdanny: what kind of state are we talking about here? in general tests should be independent and you should only share immutable stuff between them
02:01:02 <cocreature> nmdanny: you can put multiple assertions in one test which might come closer to what you’re looking for
02:02:31 <nmdanny> let's say I want to test several functions: 1. create user 2. save user to state 3. persist state to disk
02:03:00 <michbad> lyxia: yeah, that's cool! do you know if there's a way to rewrite it to get rid of parentheses here? getLine >> (getLine <&> words <&> map read)
02:03:28 <nmdanny> so for example, creating and saving users to state would both be part o the state test as well as the persist to disk state
02:03:50 <cocreature> nmdanny: in that case (assuming it is not trivial to just start a test with an existing user) I would make a single test with three assertions (obviously you can pull that apart in three definitions
02:04:05 <nmdanny> so a single "it" block?
02:04:19 <cocreature> yep
02:04:32 <nmdanny> and what  if I want each part to be considered a different test?
02:04:54 <nmdanny> aka can I share state between 'it' blocks in the same 'describe' monad?
02:07:11 <cocreature> you could probably write your state in an IORef and share it between the tests
02:07:18 <cocreature> but imho tests should be isolated
02:08:38 <saurabhnanda> MarLinn: replicated the benchmark on my local machine. Seems to be working fine. Must be an issue with the EC2 cluster setup.
02:10:00 <MarLinn> saurabhnanda: That seems really weird...
02:11:00 <MarLinn> saurabhnanda: Is that the system they're testing on? Maybe there's a conflict with another system or something
02:11:47 <saurabhnanda> MarLinn: god knows. Running these benchmarks is such a pain...
02:12:08 <lyxia> michbad: oh the fixity clash is indeed unfortunate here.
02:12:14 <saurabhnanda> finer stuff is pretty ill-defined. Fetch rows based on a random number, what happens if random number doesn't exist in the DB?
02:12:32 <MarLinn> saurabhnanda: Btw the code looks fine to me. Only that C8 really bugs me, especially as OverloadedStrings should be able to handle that anyway
02:12:37 * hackagebot yi-rope 0.7.0.2 - A rope data structure used by Yi  https://hackage.haskell.org/package/yi-rope-0.7.0.2 (DmitryIvanov)
02:12:39 <lyxia> michbad: or is it...? what do you get if you just remove the brackets?
02:12:54 <saurabhnanda> MarLinn: nope -- it doesn't work if I remove that pack/unpack/whatever-nonsense
02:13:37 <MarLinn> saurabhnanda: and normal bytestring doesn't work either?
02:13:56 <saurabhnanda> MarLinn: any idea about https://github.com/TechEmpower/FrameworkBenchmarks/pull/2247/files#diff-56ca321c6284377d819955ff9e22bb0cR81 (fakeInternalState) -- what is it used for? I just copied it over from the MySQL test.
02:14:23 <saurabhnanda> MarLinn: nope -- needed that exact incantation to satisfy the String overlords.
02:14:48 <michbad> lyxia: ... you're right, it works - nevermind :)
02:16:27 <MarLinn> saurabhnanda: craziness all around... I guess for the finer details you must ask The Master
02:16:51 <saurabhnanda> MarLinn: Who is The Master?
02:18:57 <MarLinn> saurabhnanda: The Master of Yesod and persistent. The Man. The Snoy! The Snoyman!
02:21:09 <saurabhnanda> MarLinn: heh... the man of the hour.
02:22:46 <MarLinn> saurabhnanda: I hope not! Think what an hour more would to to the benchmark...
02:24:12 <piyush-kurur>  saurabhnanda: You can reduce some packs by enabling the OverloadedStrings pragma. You know that right
02:26:36 <MarLinn> piyush-kurur: there's only one pack left if I see correctly, and C8 seems to be an exception
02:26:51 <saurabhnanda> piyush-kurur: didn't work in this case.
02:27:14 <saurabhnanda> so, basically, MySQL drivers are the suxxx in Haskell
02:27:44 <saurabhnanda> 1000%+ speedup in a few benchmarks by just switching to PG
02:28:55 <saurabhnanda> is travis CI really slow? https://travis-ci.org/TechEmpower/FrameworkBenchmarks/builds/155873833
02:35:58 <piyush-kurur> saurabhnanda: Of course I have no clue why the postgre thing is not working. Just to clean up code using things like Text, String, ByteString you can enable Overloaded strings (for byte strings in some versions of base you would need to import D.B.Char8)
02:36:25 <piyush-kurur> Although in general it is less (type safe) to use overloaded strings
02:36:45 <piyush-kurur> particularly for types that are instances of IsString but not all strings are valid elements
02:37:08 <tdammers> overloaded strings aren't less typesafe, they just turn make string literals polymorphic
02:37:44 <tdammers> "not all string literals are valid elements" means that the particular IsString instance is partial, but the type system doesn't do totality checks anyway
02:38:38 <piyush-kurur> okey the point is that errors will appear in run time instead of compile time
02:38:39 <tdammers> if you write a Monad instance where >>= is partial, you'd have the same problem, really, but it wouldn't make do notation any less type-safe
02:38:56 <tdammers> overloaded string doesn't move errors to runtime either
02:38:57 <ggole> Dynamic languages aren't less typesafe, either
02:39:08 <merijn> Unsafe IsString instance make overloadedstrings less typesafe
02:39:23 <merijn> i.e. Char8 heresey
02:39:34 <tdammers> indeed
02:39:39 <piyush-kurur> in fact Char8 is quite bad
02:39:40 <tdammers> instance IsString ByteString is a lie
02:39:51 <merijn> When I become dictator of the world I will take over hackage, delete Char8 and have anyone who tries to readd it executed >.<
02:40:00 <piyush-kurur> it just silengthy truncates Chars to Word8
02:40:16 <tdammers> if it used UTF8 instead, it'd still be wrong
02:40:35 <merijn> I have a completely unrelated question
02:40:37 <tdammers> but it's wrong the same way`head is wrong
02:40:46 <tdammers> and then some
02:41:30 <piyush-kurur> use bytestring if it is Octects (i.e. pure simple binary) and Text if it is any kind of Characters
02:41:35 <piyush-kurur> that is what I follow
02:43:54 <merijn> Incidentally, if you would like a safe way to have Char8 literals, I hacked togehter a prototype here: https://github.com/merijn/validated-literals
02:44:16 <merijn> Or any form of "safe" polymorphic literals in the presence of partial conversion functions
02:44:40 <tdammers> the "string" part in "bytestring" is a lie
02:44:51 <tdammers> it's not a string, it's a byte array
02:45:09 <piyush-kurur> may be octects might have been a better word
02:45:52 <merijn> There was a campaign to introduce "type Bytes = ByteString" and change the signature of all the functions to use that (keeping ByteString for backwards compatibility)
02:45:59 <ertes> well, it's a "string", just not a text string =)
02:48:07 <piyush-kurur> merijn: you use template haskell. This is where we miss dependent types
02:48:31 <piyush-kurur> maybe one can use type families to make it work
02:50:27 <piyush-kurur> merijn: I should have said this is one of the places where we miss dependent types
02:50:44 <piyush-kurur> there are more places of course
02:50:46 <merijn> piyush-kurur: Oh, sure, dependent types are nicer
02:51:11 <merijn> piyush-kurur: Actually, this is more efficient, though. Because for types with a quasiquoter the conversion is done at compile time
02:51:47 <ertes> what are Char8 literals?  Word8, but using Char syntax?
02:51:47 <piyush-kurur> I think in the dependent type case also the stuff is done at compile time
02:52:41 <merijn> piyush-kurur: The validity check, sure. But not the conversion
02:52:59 <merijn> ertes: "ByteString literals using overloadedstrings", then
02:54:35 <MarLinn> merijn: Wouldn't it be better to have type ByteString = Bytes? Then the automatic removal of synonyms in ghci would return the "better" name
02:55:06 <merijn> MarLinn: Maybe, not sure which is more robust
02:55:18 <piyush-kurur> merijn: I am not sure of that either but it depends on the compiler of course
02:55:39 <piyush-kurur> particularly for languages that are total
02:56:23 <dominik> due to lazyness, does Haskell also memoize function calls so that repeatedly calling a function with the same arguments delivers the result faster?
02:56:29 <ertes> merijn: i see, so IsString, but rejecting nonsense at compile-time
02:56:45 <dominik> (i.e., in constant time, after the first computation of the function on these arguments)
02:56:48 <ertes> dominik: no
02:56:49 <merijn> ertes: Yeah
02:57:22 <merijn> dominik: In general, no. But GHC ensures that named bindings are evaluated only once (well, mostly, there's some caveats, etc.)
02:57:25 <ertes> dominik: it only reuses values that have a name:  let y = f x in y + y
02:57:43 <merijn> dominik: So "let x = {- costly expression -} in x + x" will only evaluate costly expression once
02:58:10 <ertes> dominik: (that's called sharing, not to be confused with memoisation)
02:58:12 <dominik> ohh, ok. So basically constants get reused, but function calls with the same arguments don't?
02:58:19 <dominik> *aren't
02:58:27 <merijn> (the caveats being that multithreaded GHC marks some computations as "cheap" and decides that computing it more than once is cheaper than sharing
02:58:35 <MarLinn> Damn, I did it again... Anyone know how to I can make Stack-started ghc(i) ignore global non-Stack-packages without having to remove those global packages?
02:58:45 <ertes> dominik: correct…  GHC has some optimisations, but if you want to make sure, name your reused values
02:59:06 <merijn> dominik: In *theory* there's an optimisation that can change "f (g 1) (g 1)" to only evaluate "g 1" once, but I would not rely on them
02:59:21 <dominik> ertes, merijn: ok, thank you.
03:00:03 <dominik> I'm asking because I feel that reusing the computed answers to certain function calls would make the formulation of Dynamic Programming problems trivial.
03:00:28 <ertes> dominik: there are libraries that can transform a normal function into a memoised one
03:00:33 <ertes> like MemoTrie
03:00:34 <dominik> (i.e., you could just formulate the recurrence without the need of auxiliary data structures like arrays or some such)
03:01:02 <dominik> ertes: oh, nice. Good to know :-)
03:01:14 <ertes> dominik: the reason it's not done automatically is that the compiler has no way to know whether the memoised version is going to be faster/smaller
03:01:21 <Cale> dominik: It would also make garbage collection trivial -- you just wouldn't do it ;)
03:01:29 <dominik> haha :D
03:02:33 <dominik> so to devise DP algorithms are you defining the recurrence as a function and memoizing it via (e.g., MemoTries) then?
03:03:16 <dominik> or do you hand-craft your own data structure to store the reoccuring subproblems?
03:03:39 <dominik> e.g. by relying on Data.Array ?
03:03:50 <ertes> dominik: there are many ways to do DP in haskell, and sometimes you would simply use laziness/sharing
03:04:32 <ertes> probably most of the time
03:05:43 <ertes> (the vector library should work on its SafeHaskell)
03:08:37 <dominik> ok, then I should probably state my question more concretely. I've just implemented the string edit distance in Haskell: the snippet is here: http://lpaste.net/181275
03:09:05 <dominik> if you don't mind looking at it, I would like to know if I implemented `editDist` idiomatically... :-)
03:09:55 <dominik> don't worry about `editDistance` which takes exponential time since (as I know now) repeated function calls aren't memoized.
03:10:19 <dominik> while the second version `editDist` works (by relying on an array), I still think that the first version is much more readable
03:10:35 <dominik> (I mean `editDistance` is more readable than `editDist`)
03:12:22 <dominik> so, I'm wondering how to best devise a DP algorithm (as in `editDist`) while preserving readability (as in `editDistance`).
03:16:53 <ertes> dominik: https://github.com/esoeylemez/snippets/blob/master/DynProg.hs#L15
03:17:18 <ertes> i'll leave applying the technique to edit distance to you =)
03:18:37 <ertes> dominik: note also the difference between 'f x = (\y -> …) where …' and 'f x y = … where …'
03:19:06 <ertes> in the former case, if the function (f x) is shared, so are the values in the 'where' block
03:19:24 <ertes> in the latter case the values in the 'where' block are recomputed for every application
03:19:54 <adnauseam> g`day
03:20:01 <Hi-Angel> Comments stated the question, and instead of an answer there's "I now know it doesn't get memoized :-)" D: oh, please, tell me the plot is going to evolve
03:20:01 <dominik> ertes: thanks! :-)
03:20:10 <adnauseam> is sleep() possible in haskell ? 
03:20:34 <deank> @hoogle threadDelay
03:20:36 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
03:20:36 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
03:20:36 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
03:20:38 <adnauseam> i'd like to create a timer of sorts that plays a sound every x seconds 
03:20:48 <adnauseam> rgr ill check that out 
03:21:28 <ertes> adnauseam: do you need that to be consistent over long periods of time?  because (replicateM_ 86400 (threadDelay 1000000)) is likely to wait noticably longer than a day =)
03:21:32 <deank> what made you think it may not be possible? :)
03:21:42 <adnauseam> what about playing a simple mp3 or wav file, is there something straight forward? many of the examples i found involved pretty complex code that probe for sound drivers and such 
03:22:00 <dominik> Hi-Angel: Basically, because it's hard to decide if a function call should be shared or computed from scratch again.
03:22:05 <adnauseam> i want to create a timer for studying, so it plays a sound every 30 minutes 
03:22:15 <cocreature> adnauseam: if you know that a specific mediaplayer is installed on your system you could just shell out and call vlc or something like that
03:22:20 <EvanR> sounds like a job for cron
03:22:23 <EvanR> or cronlike lib
03:22:38 <adnauseam> ~trying to do it in haskell for educational purposes 
03:22:45 <adnauseam> i know cron or js or python would be easier 
03:22:48 <dominik> Hi-Angel: e.g., if you always share, you'll never garbage collect and you'll quickly run out of memory. 
03:22:57 <Hi-Angel> Ah.
03:23:10 <Hi-Angel> That's interesting, never thought about it. Thank you.
03:24:39 <cocreature> Hi-Angel: also there are different caching schemes with different performance characteristics (e.g. a hashmap, a “normal” map, a vector, …)
03:25:02 <maerwald> adnauseam: https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Concurrent.html#v:threadDelay
03:26:36 <ertes> adnauseam: if you are a haskell beginner, note that properly calling out to a media player, waiting for it to finish (perhaps kill it after a while) and then go back into the waiting loop is not quite as straightforward as it sounds =)
03:26:45 <ertes> adnauseam: so there is some learning value in doing that
03:27:22 <maerwald> should be easy with forkFinally
03:27:27 <maerwald> or somesuch
03:28:15 <ertes> adnauseam: but if you really want to do it yourself, the first thing i recommend is that you convert the sound file to OGG or WAV, use hsndfile to load it and then sdl2 to play it
03:28:53 <maerwald> using bindings to C libs doesn't really have much educational value imo
03:29:10 <maerwald> it's just the annoying part of haskell
03:29:21 <ertes> (alternatively you can work with your platform library, e.g. ALSA, but it's the same amount of work)
03:29:32 <EvanR> sdl2 to play a sound?
03:29:47 <maerwald> EvanR: one can always find ways to overdo :P
03:29:50 <EvanR> thats pretty roundabout
03:29:59 <ertes> EvanR: know a better option that doesn't call out to a media player?
03:30:25 <EvanR> exactly why dont we want to do that
03:30:52 <ertes> i didn't make that assumption: "but if you really want to do it yourself"
03:30:53 <EvanR> aplay, etc
03:31:40 <maerwald> too easy, use gstreamer
03:31:53 <ertes> in fact i'd suggest doing both =)
03:32:29 <ertes> they are both engineering challenges, not particularly difficult, but also not completely straightforward, and they have very different learning values
03:33:00 <tsahyt> :t comparing
03:33:02 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
03:33:14 <EvanR> i have seen sdl bindings actually do streaming sound before, but i suspect it will suck for higher loads due to gc dropout
03:34:53 <tsahyt> I've been looking at the lrucaching package and the API requires both a Hashable and an Ord instance. My keys are (newtype wrappers around) HashSets, so I don't have an Ord instance. I can define one based on ordering the hashes. Will an Ord instance like this do?
03:35:09 <ertes> EvanR: it's not that bad…  i've even generated sound from GHCi without dropouts
03:35:27 <saurabhnanda> ===> Yes! All tests passed. Now to pester them to merge ==> https://github.com/TechEmpower/FrameworkBenchmarks/pull/2247
03:35:33 <EvanR> yeah ive seen it done, with nothing going on but dumping already computed samples
03:35:38 <jaspervdj> tsahyt: That's weird, `lrucaching` is built on `psqueues` which only requires Eq and Hashable afaik
03:35:41 <tsahyt> as far as I can see the instance is required because psqueues is used underneath, which has the same constraints. So the question can probably asked for psqueues' HashPSQ as well
03:36:02 <ertes> EvanR: the trouble starts when you have generation 2 values in your sound code in the final stage (the part that gets evaluated within the callback)
03:36:14 <ertes> in other words: make sure that the sound code doesn't GC
03:36:15 <EvanR> that would be really bad
03:36:18 <tsahyt> jaspervdj: psqueues does require keys to be an instance of Ord
03:36:29 <cocreature> jaspervdj: no member requires Ord
03:36:33 <EvanR> but im talking about synthesizing and or mixing not the callback, you still might get gc in the callback
03:36:34 <cocreature> and lookup
03:36:38 <cocreature> and insert
03:36:41 <cocreature> so basically everything
03:36:42 <jaspervdj> tsahyt: oh right. we fallback to using Ord on hash collisions
03:37:08 <tsahyt> oh, so building an Ord instance on top of Hashable is probably a bad idea then
03:37:11 <ertes> EvanR: that's what i meant, though i haven't tried anything heavy (like FFT) yet
03:37:17 <cocreature> I guess the real question is why do HashSets not have an ord instance?
03:37:34 <jaspervdj> tsahyt: It's only used for searching so as long as the Ord instance is consistent it should be fine
03:37:36 <MarLinn> saurabhnanda: Well done, you may have saved the honour of Haskell web development ;)
03:37:42 <EvanR> i thought you were referring to accidentally sending a lazy mixed buffer to the callback which accidentally evaluates in there
03:38:01 <ertes> EvanR: that would be quite terrible =)
03:38:03 <tsahyt> jaspervdj: well I could toList the HashSet and build Ord on that too
03:38:13 <ertes> EvanR: though not necessarily
03:38:20 <tsahyt> not sure how that would affect performance though
03:38:38 <EvanR> sound sucks, everything should execute in perfect silence
03:38:49 <ertes> EvanR: indeed
03:38:53 <EvanR> purity ftw
03:39:32 <ertes> but then i love noisy games =)
03:45:07 <jgt> I'm trying to get a UUID as a Text value
03:45:24 <jgt> If I do `fmap toText $ liftIO nextRandom`, I get a `f0 Text`
03:45:36 <jgt> how do I get the Text value out?
03:45:54 <jgt> I somewhat suspect someone will say “you must *run* the IO monad”
03:45:54 <tsahyt> jgt: using >>= in one way or another
03:46:16 <ertes> jgt: if you're in a do-block, you just name the result of that
03:46:21 <jgt> tsahyt: yeah, I suspected that too. Haven't quite figured out bind yet, but I guess I'll have to dig there
03:46:26 <tsahyt> jgt: the way you're doing it, you need to be in IO. but there are other ways to get random numbers
03:46:31 <tsahyt> look at monadrandom
03:46:33 <jgt> I'm not in a do-block
03:46:36 <ertes> jgt: do r <- fmap toText (liftIO nextRandom)
03:46:55 <jgt> I'm doing this straight in a record
03:46:58 <jaspervdj> tsahyt: perhaps you could precompute the hash and some sorting key in a smart constructor
03:47:01 <ertes> jgt: you can also use (>>=) directly as tsahyt said
03:47:22 <ertes> jgt: fmap toText (liftIO nextRandom) >>= \r -> …
03:47:32 <EvanR> theres got to be a UUID package which does all of this
03:47:54 <tsahyt> jaspervdj: I think I'll stick with compare = comparing (toList . coerce) for now and if that becomes a performance problem I'll look back into it
03:48:14 <tsahyt> (with coerce actually being the unwrapping function, I'm still wary of using coere)
03:48:15 <tsahyt> coerce*
03:48:22 <EvanR> jgt: make a function which takes the UUID and puts it in the record, rather than trying to put the whole program inside the record ctor
03:48:40 <jgt> EvanR: that's probably the easiest way of doing it
03:48:50 <jgt> thanks for your help everyone :)
03:49:23 <Hi-Angel> jgt: if you need "pseudo-randomness", I remmeber there was a pure function computing a random number from a key. Can't remember the name though.
03:49:45 <ertes> this is usually the point when i note that GHC can derive Traversable instances, but i'll refrain from it this time =)
03:49:59 <EvanR> f x = x + 4, 4 chosen completely "pseudorandomly"
03:50:25 <ertes> sequence (MyRec { field1 = action1, field2 = action2 })
03:50:36 <tsahyt> EvanR: why not by fair diceroll?
03:50:45 <jgt> Hi-Angel: I want to stick to using UUIDV4 values in the context of my web app
03:50:49 <EvanR> cant be trusted and is too slow
03:50:54 <ertes> (and yeah, hlint can go to hell, i'll never write this without the parentheses)
03:51:15 <jgt> tsahyt: if I could charge for this over the phone, I'd quit my job
03:51:29 <EvanR> and i'd eat my hat
03:51:31 <tr|ck> Hi. I'd like to simplify the look of an ugly instance of a new data type. Is there a way to stream the elements of a list out of it as a succession of values?
03:52:14 <jaspervdj> tr|ck: depends on what you mean by "stream".  which instance are you trying to write?
03:52:25 <Hi-Angel> EvanR, yeah, it was almost the point, and it does have an application. I was tackling with ANNs as part of my studen paper, and I was needed to initalize matrices with more or less disctinct values, which could repeat every time I relaunch the app perfectly fine.
03:52:34 <tr|ck> jaspervdj: I created a new data type (DNSrecord) 
03:52:40 <lpaste> “tr|ck” revised “djbParsec.hs”: “djbParsec.hs” at http://lpaste.net/6784107058296782848
03:53:38 <EvanR> if you want it to be repeatable then how about saving the data to a file and reloading it, then having a separate thing to generate the file in the first place
03:54:32 <Hi-Angel> EvanR, no, I didn't need to be repeatable, It's rather that I didn't care if initial values would repeat every relaunch.
03:54:54 <EvanR> so a non requirement
03:55:00 <EvanR> those are easy
03:55:28 <EvanR> non requirements are satisfied by doing nothing
03:55:50 <tr|ck> jaspervdj: the code works correctly, I'd like to be able to construct the varius DNS type without using that clumsy repetitive notation.
03:56:34 <tr|ck> jaspervdj: the style is kind of raw because I'm an absoulute beginner.
03:57:02 <Hi-Angel> EvanR, But I had to initialize starting values to be disctinct, I.e. I couldn't set them all to the same value. And here comes the pseudo-randomness: you give the same key on every launch, and get every time disctinct values for matrices (even though repeatable)
03:57:28 <EvanR> yes generate the data from a seed
03:57:38 <tr|ck> jaspervdj: “djbParsec.hs” at http://lpaste.net/6784107058296782848
03:57:53 <EvanR> but if you just need it to be distinct rather than have random properties, that is even easier
03:58:01 <EvanR> > [1..]
03:58:03 <ongy> Hi-Angel: if they really have to be distinct, pulling them from PRNG isn't enough though
03:58:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
03:58:30 <ertes> tr|ck: note that you can use record constructors like regular constructors: DEBUG "blah"
03:58:31 <tr|ck> jaspervdj: if you need it I can paste the Parsec parser that I wrote to fetch djb DNS data records.
03:58:57 <Hi-Angel> > [0.01..0.06]
03:59:00 <lambdabot>  [1.0e-2]
03:59:04 <ertes> tr|ck: if that doesn't suffice, you can write smart constructors, which are just functions that construct values of your type of a certain shape
03:59:32 <tr|ck> jaspervdj: ah, ok. It's this an haskell extension?
03:59:33 <ongy> > [0.01,0.011..0.06]
03:59:35 <lambdabot>  [1.0e-2,1.1e-2,1.1999999999999999e-2,1.2999999999999998e-2,1.399999999999999...
03:59:42 <EvanR> that is so gross
04:00:43 <ongy> why does it look that broken? Float precision?
04:00:48 <ertes> tr|ck: as i said, smart constructors are just regular functions:  myMx x y = MX { … }
04:00:59 <EvanR> a confluence of float phenomena
04:01:08 <tr|ck> jaspervdj: that's what I already used
04:01:21 <EvanR> for one thing 0.01 isnt a real float
04:01:31 <ertes> a real float =)
04:01:38 <Hi-Angel> :D
04:01:52 <tr|ck> ertes: data DNSrecord = NS    { djbTag :: String, tld :: String
04:01:52 <tr|ck>                        , ip :: String, alias :: String, ttl :: String
04:01:52 <tr|ck>                        , sndTtl :: String, thrdTtl :: String }
04:02:24 <EvanR> > [0.01, 0.011..0.06] :: [Pico]
04:02:26 <lambdabot>  [0.010000000000,0.011000000000,0.012000000000,0.013000000000,0.014000000000,...
04:02:49 <Rarrikins> What is Pico?
04:02:58 <tr|ck> ertes: well, actually you're giving multiparameters to the funtion.
04:02:59 <EvanR> Data.Fixed fixed point
04:03:12 <Rarrikins> Ahh, thanks.
04:03:34 <implementation_> > [0.01,0.011..0.06] :: [Ratio Int]
04:03:36 <lambdabot>  [1 % 100,11 % 1000,3 % 250,13 % 1000,7 % 500,3 % 200,2 % 125,17 % 1000,9 % 5...
04:04:00 <implementation_> okay, that's ugly too
04:04:09 <EvanR> Pico is the secret sauce behind NominalDiffTime
04:04:14 <ongy> 2 % 125, looks nice and readable to me
04:04:32 <Rarrikins> > [0.01,0.011..0.06] :: [CReal]
04:04:34 <ertes> tr|ck: the idea is to identify usage patterns and code them up as little functions…  haskell lets you abstract over many things, not just the fields
04:04:34 <lambdabot>  [0.01,0.011,0.012,0.013,0.014,0.015,0.016,0.017,0.018,0.019,0.02,0.021,0.022...
04:04:53 <ertes> implementation_: also Ratio Int is a really terrible idea =)
04:04:56 <ramadoka> exit
04:05:01 <EvanR> Rational plz
04:05:10 <merijn> ongy: Ratio and Fixed are both much nicer alternatives to Float/Double for many uses
04:05:12 <EvanR> also whats with that increment being only 0.001
04:05:14 <tr|ck> ertes: the problem that I'm facing is that, say the NS data constructor, needs a bunch of parameters and I have to take them out the list before passing it to the NS constructor.
04:05:21 <implementation_> ertes: just wanted to see what it looks like
04:05:45 <ongy> merijn: how fast are they? :) When I don't need the precision, I think floats are ok
04:05:53 <tr|ck> ertes: so I should be able to do this not changing the actuale data DNSrecord constructors, shouldn't I?
04:06:00 <merijn> ongy: Fixed is pretty fast. Ratio I dunno
04:06:08 <EvanR> when i dont need precision and a dont even need non not-a-numbers i use floats
04:06:08 <tr|ck> s/uale/ual/
04:06:29 <merijn> EvanR: What would it be if not 0.001?
04:06:40 <EvanR> oh i see
04:06:56 <EvanR> it subtracts to get the increment
04:07:17 <merijn> Anyway, let's all just agree that Enum instance of Float is super-haram
04:07:20 <ongy> what else would it do?
04:07:33 <tr|ck> ertes: thanks a lot. I'll go through this -> https://wiki.haskell.org/Smart_constructors
04:07:48 <EvanR> > [0.1 .. 0.9] :: [Pico]
04:07:50 <lambdabot>  [0.100000000000,0.100000000001,0.100000000002,0.100000000003,0.100000000004,...
04:07:54 <ertes> > (1/2)^70 :: Ratio Int
04:07:57 <lambdabot>  *Exception: Ratio has zero denominator
04:08:02 <EvanR> rofl
04:08:44 <ertes> > product (map recip [1..130]) :: Ratio Int
04:08:46 <lambdabot>  *Exception: Ratio has zero denominator
04:09:04 <ongy>  (1/2)^70 :: Ratio Float
04:09:08 <ongy> > (1/2)^70 :: Ratio Float
04:09:11 <lambdabot>  error:
04:09:11 <lambdabot>      • No instance for (Integral Float) arising from a use of ‘^’
04:09:11 <lambdabot>      • In the expression: (1 / 2) ^ 70 :: Ratio Float
04:09:20 <ongy> ok, I would have been surprised
04:09:26 <Rarrikins> Typecheckmate!
04:09:48 <implementation_> > 0.01 :: Ratio Fd
04:09:50 <lambdabot>  error:
04:09:50 <lambdabot>      Not in scope: type constructor or class ‘Fd’
04:09:55 <ertes> tr|ck: don't think too much about it…  smart constructors aren't a special language feature…  they are literally just functions
04:10:01 <implementation_> @import System.Posix.Types
04:10:02 <lambdabot> Unknown command, try @list
04:10:35 <implementation_> i think using file descriptors for ratios are a good idea :^)
04:10:53 <EvanR> for frightening small children
04:11:25 <ongy> does ghc use select?
04:11:29 <implementation_> PortNumber is an Integral too
04:11:29 <ertes> > product (map recip [1..130]) :: Ratio Fd
04:11:32 <lambdabot>  error:
04:11:32 <lambdabot>      Not in scope: type constructor or class ‘Fd’
04:11:44 <merijn> ongy: GHC uses epoll/kqueue internally, afaik
04:11:46 <ertes> @let import System.Posix.Types
04:11:48 <lambdabot>  Defined.
04:11:50 <ertes> > product (map recip [1..130]) :: Ratio System.Posix.Types.Fd
04:11:53 <lambdabot>  *Exception: Ratio has zero denominator
04:12:10 <implementation_> @let import Network.Socket
04:12:12 <lambdabot>  .L.hs:133:1: error:
04:12:12 <lambdabot>      Network.Socket: Can't be safely imported!
04:12:12 <lambdabot>      The module itself isn't safe.
04:12:15 <merijn> ongy: Which scales better than select, see also the Mio paper on the post-7.6 IO manager
04:12:57 <ertes> the funny thing about using Ratio Int is…
04:13:07 <ertes> > (1/3)^10000000 :: Ratio Int
04:13:10 <lambdabot>  1 % 385609709189952001
04:13:12 <ongy> strace shows a lot of select (compiled with ghc-8)
04:13:16 <jgt> I found an easier way of getting a UUIDV4 value that might make some of you sad. `toText $ unsafePerformIO nextRandom`
04:13:54 <implementation_> with PortNumber the result is 1 % 29185
04:13:56 <ertes> jgt: it's more likely to make *you* sad at some point =)
04:14:13 <tinco> > (1/3)^10 :: Ratio Int
04:14:15 <lambdabot>  1 % 59049
04:14:24 <jgt> ertes: I couldn't work out how to use bind. I kept getting an IO Text out
04:14:31 <EvanR> jgt: that... is a pretty bad usage of unsafePerformIO
04:14:32 <implementation_> > (1/3)^10000000 :: Ratio Fd
04:14:33 <Rarrikins> Why do port numbers need arithmetic?
04:14:34 <lambdabot>  1 % (-902467071)
04:14:43 <ertes> jgt: that's the correct thing
04:14:47 <EvanR> you dont use unsafePerformIO when you cant figure out how to use bind
04:14:49 <tinco> Fd.. is that a filedescriptor? :P
04:14:54 <implementation_> yes it is
04:14:56 <merijn> ongy: Which OS? Also, threaded or single threaded runtime?
04:15:04 <ertes> jgt: you *should* get an IO Text
04:15:15 <jgt> ertes: but… I want a Text :P 
04:15:22 <ongy> merijn: linux x86_64 and non-threaded (why would it make a difference?)
04:15:24 <Rarrikins> Why do file descriptors need arithmetic?
04:15:36 <ertes> jgt: https://www.vex.net/~trebla/haskell/IO.xhtml
04:15:50 <merijn> ongy: The threaded and non-threaded codebases are largely separate. I think the non-threaded one might use select instead
04:15:59 <tr|ck> ertes: got it, thanks a lot for your time!
04:16:01 <ongy> that's just...
04:16:08 <EvanR> jgt: create this piece of data in IO, since its using IO, then pass it into your pure code
04:16:17 <ongy> well, time to create 1025 fds and file a bug against GHC :)
04:16:52 <merijn> ongy: Looks like it uses select o check for blocking or something?
04:16:55 <merijn> "485:    In non-threaded mode we call select() before attempting to read,"
04:17:04 <merijn> Which is from libraries/base/GHC/IO/FD.hs
04:17:21 <ongy>  rmember reading something like that
04:17:36 <merijn> ongy: oh
04:17:39 <suppi> can i tell cabal to fetch tarballs for packages and use certain constraints for resolution?
04:17:50 <merijn> ongy: It's apparently because O_NONBLOCK is stupid broken
04:18:41 <merijn> See comments in aforementioned file
04:18:54 <ertes> jgt: the most important thing you will ever learn about haskell:  you do not get out of IO to get into pure land, pure land is embedded in IO
04:19:36 <ertes> that's why you do not need or want unsafePerformIO…  what you want is to learn IO
04:19:51 <maerwald> adnauseam: http://lpaste.net/181278 here's an example, but don't look at it if you haven't done it yourself already
04:19:58 <EvanR> one proper use of unsafePerformIO is if youre executing pure code, since youre action causes side effects, thats not that
04:20:15 <merijn> @quote Lemmih not.a.bug
04:20:15 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
04:21:24 <ertes> and of course…
04:21:28 <ertes> @quote /bin/ls
04:21:28 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
04:21:30 <EvanR> but messing with the global RNG from different threads, whether its caused by upio or not, seems like a contract people implicitly signed by using it
04:22:13 <EvanR> the global rng is like the "i just dont care, dont want to think about it" rng
04:22:15 <maerwald> that quote is funny though, since lots of people parse the output of `ls` :P
04:22:40 * hackagebot mysql-haskell 0.5.0.0 - pure haskell MySQL driver  https://hackage.haskell.org/package/mysql-haskell-0.5.0.0 (winterland)
04:22:42 <ertes> as long as it's the output and not /bin/ls itself ;)
04:22:53 <maerwald> it's still wrong
04:23:07 <ongy> merijn: so if I have an FD <1023 in the non-threaded RTS I will fail?
04:23:32 <ertes> it's not wrong, it's unix ("wrong" bent to such an extent that it becomes "right")
04:23:50 <maerwald> it's not proper shell programming
04:23:59 <EvanR> the one point compactification of the right wrong spectrum
04:24:00 <merijn> ongy: I dunno? Test it and/or read the source?
04:24:03 <ertes> "proper shell programming" =)
04:24:07 <maerwald> yes
04:24:34 <merijn> ongy: Why would it fail with an FD < 1024?
04:24:44 <maerwald> ertes: you can use `find` to do stuff on files, which has a guaranteed API and doesn't depend on random characters that may or may not be printed
04:24:46 <ongy> merijn: see BUGS in 'man select'
04:24:52 <ongy> and fd > 1024
04:24:58 <ongy> oh I mistyped earlier
04:25:02 <maerwald> so using `ls` in shell scripts is almost always wrong
04:25:10 <merijn> ongy: It depends on your OS settings
04:25:11 <ertes> maerwald: yeah, and don't forget to use -print0 =)
04:25:20 <maerwald> why? use -exec
04:25:34 <ongy> merijn: which isn't nice either
04:25:42 <merijn> ongy: Sure, but what can you do?
04:26:01 <merijn> ongy: The runtime fails if you set ulimits too low too
04:26:46 <merijn> ongy: If you have that many FDs you should probably use the threaded runtime anyway
04:27:01 <merijn> ongy: And I would argue that you should probably just use the threaded runtime regardless
04:27:10 <ertes> regardless of how you put it and how many standards/conventions you follow…  shell programming is the epidem^W epitome of stringly typed programming
04:27:31 <maerwald> doesn't mean everything is ok
04:27:37 <ongy> merijn: ulimits aren't set low by default though. And also fail in a different way
04:27:54 <ongy> but haveing >1023 Fds isn't really a common usecase, I agree with that
04:28:31 <merijn> ongy: Alternatively, fix the RTS? :)
04:29:44 <merijn> ongy: It probably has plenty of annoying edge cases like this to solve for people with some C expertise and obscure standards knowledge :)
04:30:12 <ongy> oh, Fd 1024 is an invalid argument to 'dupTo', good to know
04:34:23 <Hi-Angel> Have anybody an idea what gone wrong here https://github.com/gtk2hs/gtk2hs/issues/179#issuecomment-243070398
04:35:53 <maerwald> Hi-Angel: yes, missing comma
04:35:56 <merijn> ongy: I mean, that's how we end up with patches like: https://github.com/ghc/ghc/blob/24e05f48f3a3a1130ecd5a46e3089b76ee5a2304/rts/posix/Select.c#L298-L313 :p
04:36:06 <Hi-Angel> maerwald, awww
04:36:14 * maerwald slaps Hi-Angel
04:37:13 <Hi-Angel> Thx :D
04:37:37 <merijn> ongy: Incidentally if you use "ghc -debug" it will use a version of the RTS that has debug symbols so you can use gdb
04:38:34 <cocreature> ^ that is one of the best and most underappreciated features of recent ghcs
04:38:42 <merijn> cocreature: That's not recent...
04:38:52 <merijn> cocreature: That's been there since before 7.2
04:39:07 <cocreature> merijn: eh sorry I thought you were talking about -g
04:39:19 <cocreature> missread
04:39:37 <merijn> cocreature: -g is nice, but an entirely different feature :)
04:39:51 <cocreature> yeah I realized that :)
04:41:07 <merijn> I'm mostly just trying to encourage people to actually produce fixes for annoying bugs/edge conditions they think off :)
04:41:20 <merijn> The runtime isn't actually magic, and pretty forward to trace/debug if you know C
04:47:02 <ongy> tracing it isn't that nice because of the signal rapid firing, but the code I have seen is rather clean
04:47:28 <merijn> ongy: step by step tracing, no. but just breakpointing is ok
04:47:41 * hackagebot hjsmin 0.1.5.4 - Haskell implementation of a javascript minifier  https://hackage.haskell.org/package/hjsmin-0.1.5.4 (ErikDeCastroLopo)
04:50:26 <Phyx-> merijn: or to report them! they can't be fixed if they're not reported!
05:12:13 <black0range> Without type  families, is it possible to say (Applicative f) => f Char -> f Char? 
05:13:34 <lyxia> I don't see how that requires type families
05:14:38 <black0range> Sorry, asked that question wrongly
05:30:29 <haskell137> What is the best way to write if length list == 1 then unsafeHead list else 1 without unsafe?
05:30:50 <merijn> haskell137: Eh, pattern match?
05:31:08 <merijn> "case list of [x] -> x; _ -> 1"
05:31:15 <mauke> case list of [x] -> x; _ -> 1
05:31:17 <mauke> nice
05:31:25 <merijn> Glorious stereo, etc.
05:32:03 <haskell137> thanks
05:37:42 * hackagebot json-stream 0.4.1.2 - Incremental applicative JSON parser  https://hackage.haskell.org/package/json-stream-0.4.1.2 (ondrap)
05:54:49 <hackrilege> :t (\z zs -> (return a zs -> (return a) <|> as)
05:54:50 <lambdabot> error:
05:54:51 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
05:55:33 <hackrilege> :t (\z zs -> (return a zs -> (return a) <|> zs)
05:55:34 <lambdabot> error:
05:55:34 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
05:55:49 <hackrilege> (hackrilege) :t (\z zs -> (return a zs -> (return a) <|> zs))
05:56:11 <hackrilege> :t (\z zs -> (return a zs -> (return a) <|> zs))
05:56:12 <lambdabot> error:
05:56:13 <lambdabot>     Pattern syntax in expression context:
05:56:13 <lambdabot>         return a zs -> (return a) <|> zs
05:56:49 <hackrilege> Mobile keyboard so as, v sry
05:57:51 <hackrilege> :t (\z zs -> (return z) <|> zs)
05:57:53 <lambdabot> (Alternative f, Monad f) => a -> f a -> f a
05:57:59 <hackrilege> Whew
05:58:24 <hackrilege> :t foldl (\z zs -> (return z) <|> zs) empty
05:58:26 <lambdabot> error:
05:58:26 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ f a
05:58:26 <lambdabot>       Expected type: f a
05:58:32 <hackrilege> Help
05:58:45 <hackrilege> That's my error with the infinite type
05:58:47 <blueonyx> :t foldl
05:58:48 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
05:58:55 <blueonyx> :t foldl (\z zs -> (return z) <|> zs) empty
05:58:57 <lambdabot> error:
05:58:57 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ f a
05:58:57 <lambdabot>       Expected type: f a
05:58:59 <blueonyx> :t foldr (\z zs -> (return z) <|> zs) empty
05:59:01 <lambdabot> (Alternative f, Foldable t, Monad f) => t a -> f a
05:59:04 <absence> sounds like you need rechursion-schemes
05:59:06 <hackrilege> Woot
05:59:26 <blueonyx> :t foldl (flip (\z zs -> (return z) <|> zs)) empty
05:59:27 <absence> or not :)
05:59:28 <lambdabot> (Alternative f, Foldable t, Monad f) => t a -> f a
05:59:43 <blueonyx> first param of foldl is different from foldr
05:59:58 <hackrilege> Such a dumb mistake thanks
06:00:06 <hackrilege> I like that function
06:00:12 <blueonyx> happy to help
06:00:44 <Guest45400> ello why does (+1).(z 4) not work? z is defined as "let z a = z" 
06:01:02 <hackrilege> Lol
06:01:07 <Rarrikins> Guest45400: What is the type of z?
06:01:32 <ertes> off-topic call for advice: i need a practical theorem prover that is easier to use than agda (easier equality, easier universes)…  any suggestions?
06:01:35 <Guest45400> t -> t 
06:01:51 <Guest45400> it returns anything, but im giving it an Int 
06:01:55 <ggole__> > let z a = z
06:01:56 <Rarrikins> Guest45400: You need let z a = a
06:01:58 <lambdabot>  <no location info>: error: not an expression: ‘let z a = z’
06:02:02 <merijn> ertes: I don't have any experiences, but the only serious once I can think off are like Coq and Isabella
06:02:34 <ggole__> Guest45400: well, that should have given a type error complaining about an infinite type
06:02:42 <Guest45400> oh sorry, z is defined as "let z a = a" 
06:02:45 <Guest45400> the abiove was an error
06:03:14 <Guest45400> the error im getting is also this one No instance for (Show (a0 -> a0)) arising from a use of ‘print’
06:03:28 <Rarrikins> Guest45400: Then you need (+1) . z $ 4
06:03:38 <Guest45400> doh
06:03:49 <ertes> merijn: thanks…  i think i'll give coq a try after all those years i've avoided it for no particular reason
06:04:32 <hackrilege> :t foldl (<$>).return
06:04:34 <lambdabot> Foldable t => b -> t (a -> a) -> a -> b
06:04:51 <hackrilege> (hackrilege) :t foldl (<|>).return
06:05:05 <hackrilege> :t foldl (<|>).return
06:05:06 <lambdabot> (Alternative f, Foldable t, Monad f) => a -> t (f a) -> f a
06:06:27 <ertes> i suppose there aren't any practical implementations of HoTT yet
06:06:40 <Guest45400> thanks guys now i undertand whats happening! thank you 
06:09:05 <berndl> ertes: https://github.com/UniMath/UniMath
06:10:43 <hackrilege> :t foldl (<|>).pure
06:10:45 <lambdabot> (Alternative f, Foldable t) => a -> t (f a) -> f a
06:12:01 <hackrilege> What is the equivalent using traversable?
06:12:28 <ertes> berndl: thanks!  learning coq now
06:12:51 <berndl> ertes: How do you plan on learning it?
06:20:33 <hackrilege> Ok so since Foldable is a superclass constraint on Traversable that doesn't really make sense. I guess if like to know how to use that module
06:20:59 <blueonyx> hackrilege: http://learnyouahaskell.com/functors-applicative-functors-and-monoids
06:21:43 <blueonyx> ah not really about Traversable
06:21:48 <c_wraith> hackrilege: Foldable and Functor are superclasses of Traversable because Traversable is strictly stronger than each.  You can derive Foldable and Functor implementations from only what's given in Traversable
06:22:17 <ertes> berndl: what do you mean?
06:22:53 <hackrilege> How do you define foldl using functions from Traversable?
06:23:43 <hackrilege> And can any other cool functions be used with (<|>).pure?
06:24:02 <hackrilege> Using traversable..
06:24:08 <berndl> ertes: Are you going to read a book to learn it? Or are you going to Google for tutorials?
06:25:09 <c_wraith> hackrilege: There are a bunch of possible ways.  You can use State to pass an accumulator around, or you can use the foldl-as-foldr encoding
06:25:36 <c_wraith> hackrilege: none will be as efficient as a direct implementation, though
06:25:56 <ertes> berndl: actually i've youtube-searched for tutorials to get a first impression =)
06:26:14 <hackrilege> What's the later encoding thing? I get the state accumulator idea
06:26:38 <cocreature> ertes: I highly recommend reading “software foundations” if you want to learn coq (freely available
06:26:39 <cocreature> )
06:26:46 <hackrilege> Though I probably couldn't implemented it immediately
06:26:59 <hackrilege> Can't*
06:27:00 <jgt> How do I convert from a Data.ByteString.Lazy.Internal.ByteString to a Text? I'm struggling to find this with Hoogle
06:27:08 <merijn> jgt: Data.Text.Encoding
06:27:13 <mauke> that would involve decoding
06:27:24 <merijn> jgt: And/or Data.Text.Encoding.Lazy, I suppose
06:27:40 <cocreature> isn’t it Data.Text.Lazy.Encoding?
06:27:44 * hackagebot hindent 5.1.1 - Extensible Haskell pretty printer  https://hackage.haskell.org/package/hindent-5.1.1 (ChrisDone)
06:29:22 <merijn> cocreature: Maybe
06:29:28 <merijn> I dunno, I'm typing from memory :p
06:29:44 <c_wraith> :t \f z xs -> foldr (\x k y -> k (f x y)) id xs z -- hackrilege 
06:29:46 <lambdabot> Foldable t => (t2 -> t1 -> t1) -> t1 -> t t2 -> t1
06:29:49 <c_wraith> :t foldl
06:29:51 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
06:30:08 <c_wraith> ok, I got the args backwards.  :)
06:30:20 <c_wraith> :t \f z xs -> foldr (\x k y -> k (f y x)) id xs z -- hackrilege 
06:30:22 <lambdabot> Foldable t => (t1 -> t2 -> t1) -> t1 -> t t2 -> t1
06:30:29 <ertes> cocreature: noted, thanks!  i'm also considering to switch to idris, because i like the way it does universes…  i have no experience at all with coq's calculus, but it looks very similar to type theory
06:30:36 <jgt> weird that Data.Text.Lazy.Encoding.decodeUtf8 gives me a Data.Text.Internal.Lazy.Text instead of a Text
06:30:39 <c_wraith> hackrilege: there.  foldl from foldr
06:31:07 <tdammers> jgt: Data.Text.Lazy.Text and Data.Text.Internal.Lazy.Text are the same type
06:31:08 <hackrilege> But then I just have to define foldr instead
06:31:14 <tdammers> Data.Text.Lazy just re-exports it
06:31:25 <jgt> darn
06:31:42 <jgt> I'm using Aeson, and I'm using `encode` on a record
06:32:00 <hackrilege> I thought someone said there was a trivial definition in terms of traverse
06:32:01 <jgt> `encode` gives me a `Value`, and I want to stick this in a database
06:32:17 <jgt> the database field is of type `Text`
06:32:27 <jgt> is there an easy way to do this that I'm not seeing?
06:32:47 <ertes> honestly i'll gladly switch to anything that doesn't make me write types like this:  data MyTheorem {l1} {l2} {l3} … {l800} : Set (l1 lub l2 lub l3 lub gocrazy lub …  it's the number one thing that annoys me about agda
06:33:02 <hackrilege> Though that trick is neat
06:33:35 <c_wraith> hackrilege: Nah, foldr is relatively trivial from traverse.  foldl has to go through an inversion like that
06:33:36 <cocreature> jgt: encodeToLazyText from Data.Aeson.Text
06:34:00 <cocreature> jgt: and it already calls encode internally so you don’t need to do that
06:34:01 <ania123> I want to install haskell on windows machine
06:34:03 <bergmark> jgt: Data.Aesonn.encode gives you a Lazy ByteString... but do what cocreature says
06:34:06 <ania123> can one help me?
06:34:17 <ertes> s/Theorem/Property/
06:34:18 <hackrilege> Haskell platform
06:34:25 <ania123> https://www.haskell.org/downloads
06:34:25 <hackrilege> Ania
06:34:29 <bergmark> ania123: https://haskell-lang.org/get-started
06:35:02 <ania123> https://www.haskell.org/downloads
06:35:11 <ania123> I am trying to download this compiler
06:35:22 <ania123> does one use it?
06:35:48 <bergmark> that page points to minghc for windows, which is deprecated
06:38:47 <jgt> looks like I'll have to update my version of Aeson to get access to Data.Aeson.Text
06:40:10 <ania123> bergmark: I have downloaded and installed exe file from the link u pointed me
06:40:16 <ania123> do u have windows OS
06:40:16 <ania123> ?
06:41:05 <ski> @where SF
06:41:06 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages",
06:41:06 <lambdabot> "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof assistant."
06:45:51 <gurki> http://pastebin.com/SqmYKaV2
06:46:55 <gurki> i dont quite understand what haskell dislikes about the definition ...
06:47:16 <gurki> i intended to define a function which takes two lists and returns a list which is a concat of the input lists
06:47:37 <ski> gurki : the type signature says `conv', but the definition says `const'. change one or both ?
06:47:45 <gurki> oh "§%"§$
06:48:27 <gurki> i should get a coffee or sth :/
06:48:35 <gurki> thank you!
06:48:38 <ski> np
06:57:44 * hackagebot mersenne-random-pure64 0.2.2.0 - Generate high quality pseudorandom numbers purely using a Mersenne Twister  https://hackage.haskell.org/package/mersenne-random-pure64-0.2.2.0 (BenGamari)
06:59:10 <drostie> This is kicking my butt a bit... I have `newtype Sometimes m x = Plain x | Monadic (m x)` and I am trying to derive `Monad m => Monad (Sometimes m)` with the more-obvious `return = Plain`, but monad laws seem very hard to prove since it's not obvious how to handle the inner monad...
07:00:09 <opqdonut> what part of the laws?
07:00:54 <hpc> drostie: if it's (>>=) that's giving you trouble, try working out the laws in terms of join
07:01:16 <opqdonut> ah right
07:01:23 <opqdonut> "m >>= return === m" is hard
07:01:26 <hpc> drostie: think of a reasonable definition of join, see if the equalities work out, revise
07:01:26 <ski> you'd have to consider it as a quotient type
07:01:45 <opqdonut> because you would need to escape the inner monad
07:01:54 <drostie> In this case m >>= return is easy, it's really associativity.
07:02:18 <drostie> And yes, I'm mostly dealing with the join-form. ^_^
07:02:24 <opqdonut> drostie: is it? so how would "getChar >>= return" work?
07:02:36 <opqdonut> sorry, "Monadic getChar >>= return"
07:02:38 <ski> (and so make it an abstract data type, not exporting the data constructors, and not export any operation through which you'd be able to tell the difference betewen `Plain x' and `Monadic (return x)' .. possibly apart from ones which lives in `IO')
07:03:07 <hpc> opqdonut: join (Plain (Monadic getChar))
07:03:33 <opqdonut> hpc: yeah but he did say "return = Plain"
07:03:36 <drostie> opqdonut: because return has the form \x -> Plain x producing a Plain (Monadic x) but join (Plain (Monadic x)) = Monadic x quite trivially.
07:03:54 <hpc> opqdonut: so define a (>>=) that puts them together appropriately
07:03:57 <opqdonut> hmm right I was confused
07:05:00 <hpc> opqdonut: actually i had it just a little bit backwards
07:05:00 <drostie> It's really just associativity and a lingering suspicion because I've got two forms of "return", or so it seems... Monadic . return and Plain.
07:05:23 <hpc> it'd be join (Monadic (fmap Plain getChar))
07:06:03 <hpc> which you still have to think about the definition of join, but it's still pretty clear how it works out
07:06:11 <drostie> So, like, the obvious definition for the monadic-monadic case is join (Monadic m) = Monadic $ m >>= \x -> case x of Plain q -> return q; Monadic r -> r
07:06:52 <opqdonut> right
07:07:33 <drostie> But then it's not obvious to me how I'm going to prove that this is associative when everything that is not Plain (Plain mx)) is complicated to deal with...
07:13:13 <dicioccio> drostie: i believe you'll need to leverage the fact that laws for m hold
07:14:53 <sm> morning all. hSetEcho stdin False or hSetEcho stdout False ? I have the feeling either one is working for me
07:15:38 <sm> (https://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#g:15)
07:16:23 <geekosaur> the first is pedantically correct, the second will work as long as output has not been redirected to a pipe/file
07:16:56 <sm> hmm, ok thank you. The first it is then
07:17:12 <dicioccio> drostie: basically, take your bind instance, you probably use right/left identities of the underlying monad when doing something like Plain x >>= Monadic t = Monadic (return x >>= t)
07:17:15 <Clint> f/win 23
07:17:19 <sm> and no reason to do both I guess
07:17:45 <sm> I'm cautious because I just realized I needed to set NoBuffering on stdin as well as stdout
07:18:58 <geekosaur> yes, buffering is part of the haskell runtime and must be done on each filehandle, echo is an aspect of the terminal driver and applies to all handles associated with that terminal
07:19:44 <geekosaur> if you're running something from a terminal and haven't redirected anything, stdin, stdout, and stderr will all refer to the same terminal, but they will have separate buffers
07:20:17 <geekosaur> (although ghc seems to conflate buffering and terminal line/character mode, which confuses things a bit)
07:20:43 <sm> I'm just not quite getting the meaning of echo mode on stdin vs on stdout
07:21:19 <sm> I know what stty -echo does at the shell
07:21:43 <sm> I think I can just forget about echo mode on stdout
07:21:56 <geekosaur> yes, you don't care about it.
07:22:30 <geekosaur> at the terminal driver level, echo is applied to an input source to tell it to copy any characters read from the terminal from the input queue to the output queue
07:22:45 * hackagebot vector-fftw 0.1.3.7 - A binding to the fftw library for one-dimensional vectors.  https://hackage.haskell.org/package/vector-fftw-0.1.3.7 (BenGamari)
07:23:03 <drostie> dicioccio: I don't know if it's just that I'm not seeing stuff or what, but I may just try to write this as some sort of interpreter on top of some sort of free monad so that I get these laws for free.
07:23:40 <sm> geekosaur: great, thank you
07:23:49 <sm> May I ask you one more ? Do you know the best way to ensure terminal state is restored at program exit ?
07:24:32 <Rarrikins> sm: Does it not happen automatically?
07:24:51 <sm> no.. eg if I disable echo in main and then ctrl-c, it stays disabled
07:25:05 <geekosaur> the ghc runtime should be ensuring it, since it is changing things "behind your program's back" (at least when ghci/runhaskell are in play)
07:25:51 <Rarrikins> sm: I think that's a bug.
07:26:10 <sm> I think echo is restored in GHCI actually. But not when compiled
07:26:19 <geekosaur> that would make sense, yes
07:26:27 <sm> and hiding the cursor is not restored in GHCI, it seems
07:26:38 <Rarrikins> Maybe it's supposed to be that way, so that you can write evil Haskell programs.
07:27:11 <Rarrikins> Does turning echo off and then exiting normally leave echo off?
07:27:59 <sm> Rarrikins: no
07:28:23 <Rarrikins> Yeah, it's probably a bug then.
07:28:35 <geekosaur> so you need a signal handler for sigINT, and https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/unix-2.7.2.0/System-Posix-Terminal.html#v:terminalMode
07:29:08 <sm> and in this latest build I can't reproduce it. The head-scratching continues..
07:29:24 <geekosaur> s for the cursor, that's not state that lives in either your program or the terminal driver, so it can't be automatically saved/restored (at least, not without hardcoding the terminal type which might not be the best of ideas)
07:31:02 <sm> now it looks like: echo is restored on ctrl-c, but no on normal exit. cursor visibility is not restored in either case
07:32:45 <sm> https://gist.github.com/simonmichael/5b97f3ab67fc0aeade7c022b7900ae9b if anyone would like to sanity check me
07:32:52 <geekosaur> in some sense the right way to do this is to use something like hscurses or vty that knows how to manage terminal state and save/restore it properly
07:34:12 <geekosaur> to do it yourself, you'll need to save the initial terminal state, then set a signal handler on sigINT that restores terminal state and exits, then set the desired terminal state
07:34:37 <sm> makes sense, thanks
07:34:54 <sm> I made a cli version of the game Simon, which I thought would be trivial, but there are lots of these interesting little challenges. This version is supposed to avoid deps like vty
07:36:59 <geekosaur> you can get away with that only by assuming that every terminal is xterm compatible (cursor hide/restore is not part of ANSI X3.64)
07:37:37 <dicioccio> drostie: one way to look at it is that your data type discards information when joining: you have a single Plain or Monadic constructor, a free monad would have one per "recursive layer"
07:37:57 <geekosaur> (20 years ago you couldn't safely assume ANSI X3.64 as a baseline, but these days you *probably* can. might need to beware of e.g. emacs terminal mode though)
07:42:28 <sm> geekosaur: yes indeed, this mode requires ansi. I think checking hSupportsANSI would be sufficient to make it robust
07:42:57 <sm> https://github.com/simonmichael/symon/blob/master/src/Main.hs <- latest
08:02:46 * hackagebot hasql-class 0.0.0.1 - Encodable and Decodable classes for hasql  https://hackage.haskell.org/package/hasql-class-0.0.0.1 (jkarni)
08:05:02 <Aleksejs> Hi, probably my question is for beginners, but can you explain me this? http://vpaste.net/gYljg
08:06:01 <ongy> :t print
08:06:02 <lambdabot> Show a => a -> IO ()
08:07:03 <ongy> Aleksejs: The argument in first line is of Type (Foo a b), while the second line is of type (b -> Foo a b)
08:07:31 <ongy> ah sorry
08:07:33 <ongy> I fail at reading
08:07:36 <ongy> my mistake
08:08:42 <pavonia> Aleksejs: What error do you get?
08:08:53 <Aleksejs> it shows an error No instance for (Show b0) arising from a use of `print'
08:09:17 <hydraz> G'morning.
08:09:40 <Aleksejs> it seems that it requires Bar to have 2 parameters in constructor, but if so, then how Nothing works?
08:10:22 <pavonia> Try adding and explicit type annotation, like (Bar 1 :: Foo Int Int)
08:10:35 <Insanity_> Good morning @hydraz
08:10:48 <pavonia> Aleksejs: It doesn't know what the type of the second parameter is supposed to be
08:12:07 <Aleksejs> pavonia: but why it even requires 2nd parameter?
08:12:29 <pavonia> Because you gave the type two parameters
08:13:58 <ahihi> you'll notice that trying to print Nothing (with no type annotation) will fail similarly
08:14:15 <Aleksejs> I see
08:15:04 <hguant> dumb yesod question - within the yesod scaffold, is there a dedicated place to define your data types, or can those just go in the handler files?
08:15:32 <hguant> I'm not using persistent or anything that would require Models
08:15:49 <ski> Aleksejs : the derived instance is `(Show a,Show b) => Show (Foo a b)'. it needs a `Show' instance for both `a' and `b', in order to produce one for `Foo a b', since the latter requires being able to show any value in `Foo a b'. the fact that you used the `Bar 1' form in the second `print' command doesn't change this
08:16:52 <ski> Aleksejs : also, because that data constructor (`Bar') didn't mention the `b' parameter, `Bar 1' itself was ambiguous, iow the `b' wasn't inferred, but still `Show b' was needed -- hence the error
08:28:55 <tr|ck> ertes: Peano numbers are the solution to my problem and you're right it's a just another function. Thanks again (:
08:32:13 <jle`> Aleksejs: remember that 'Foo a b' is actually just a family of types -- you can have values of type Foo Int Bool, Foo String Double, etc.; 'show' only takes specific, monomorphic, concrete types
08:32:45 <jle`> so you don't pass a 'Foo a b' to show, you pass values of specific types, like Foo Int String
08:32:47 * hackagebot bindings-libzip 1.0.1 - Low level bindings to libzip.  https://hackage.haskell.org/package/bindings-libzip-1.0.1 (SergeyAstanin)
08:32:49 * hackagebot LibZip 1.0.1 - Bindings to libzip, a library for manipulating zip archives.  https://hackage.haskell.org/package/LibZip-1.0.1 (SergeyAstanin)
08:33:26 <jle`> haskell can't figure out what you are trying to pass print.  a Foo Int Bool?  a Foo Int String?  a Foo Int Double ?
08:37:47 * hackagebot HUnit 1.3.1.2 - A unit testing framework for Haskell  https://hackage.haskell.org/package/HUnit-1.3.1.2 (AdamBergmark)
09:02:48 * hackagebot simple-effects 0.1.0.1 - Simple project template from stack  https://hackage.haskell.org/package/simple-effects-0.1.0.1 (darwin226)
09:12:49 * hackagebot servant-subscriber 0.4.0.0 - When REST is not enough ...  https://hackage.haskell.org/package/servant-subscriber-0.4.0.0 (eskimo)
09:16:29 --- mode: ChanServ set -q EvilMachine!*@*
09:38:27 <mahdi> Hey, I'm writing an HTTPS proxy using Yesod (I know, it's more of an experiment), and I'm encountering a problem where it seems after sending 200 OK to client in CONNECT, I can't read the client's request anymore. readRequestBody returns null while I get a packet in Wireshark (SSL Hello)
09:39:40 <mahdi> source: https://github.com/mdibaiee/yesod-proxy
09:42:39 <suzu> mahdi: sendResponse / sendWaiResponse i believe short-circuits the handler
09:42:49 * hackagebot servant-purescript 0.3.0.0 - Generate PureScript accessor functions for you servant API  https://hackage.haskell.org/package/servant-purescript-0.3.0.0 (eskimo)
09:43:07 <suzu> remaining handler code is bypassed and ignored
09:43:59 <mahdi> suzu: AFAIK my connection is not closed until responseStream - which is waiting on the threads - returns, isn't that right?
09:47:38 * mahdi will be back in 30 minutes
09:54:01 <ctesiphon> guys - has any of you tried running `packunused` from inside a stack project? I'm having some trouble with cabal
09:59:40 <alpx> hello
09:59:59 <srhb> alpx: Hello. :)
10:00:04 <dmj`> alpx: Hello. :)
10:03:32 <saurabhnanda> jkarni: how long does it take for a PR to get merged into the techempower benchmarks?
10:06:16 <srhb> saurabhnanda: If you look at the closed PRs, you can see for yourself. :)
10:13:09 <saurabhnanda> srhb: got a reply on my PR. Asking me to raise it against Round 14, which are probably another 3 months away...
10:14:38 <sm> drat
10:15:27 <xuxu> what are kinds used for besides promotion? does the compiler check kinds and why if so?
10:15:54 <mauke> > () :: Int Int
10:15:57 <lambdabot>  error:
10:15:57 <lambdabot>      • Expecting one fewer argument to ‘Int’
10:15:57 <lambdabot>        Expected kind ‘* -> *’, but ‘Int’ has kind ‘*’
10:16:00 <johnw> xuxu: kinds determine how you apply types.  It makes "Maybe Maybe" illegal
10:16:08 <mauke> > () :: Maybe
10:16:10 <lambdabot>  error:
10:16:10 <lambdabot>      • Expecting one more argument to ‘Maybe’
10:16:10 <lambdabot>        Expected a type, but ‘Maybe’ has kind ‘* -> *’
10:16:55 <xuxu> are there just two kinds?
10:16:58 <xuxu> * and * -> *
10:17:22 <dmwit> No. * is a kind, and for every pair of kinds k1 and k2, k1 -> k2 is a kind.
10:17:25 <dmwit> :k StateT
10:17:27 <lambdabot> * -> (* -> *) -> * -> *
10:18:00 <dmwit> With PolyKinds, you should add kind variables to the list of base cases of that recursive definition.
10:18:36 <dmwit> With ConstraintKinds, you should add Constraint to the list of base cases.
10:18:44 <ski> @kind Const
10:18:45 <lambdabot> * -> k -> *
10:18:46 <xuxu> i don't know what those are
10:18:49 <ski> @kind Eq
10:18:50 <lambdabot> * -> Constraint
10:18:52 <xuxu> think i need a tutorial
10:18:54 <ski> @kind Monad
10:18:55 <lambdabot> (* -> *) -> Constraint
10:19:09 <ski> `PolyKinds' and `ConstraintKinds' are language extensions
10:19:19 <saurabhnanda> are there dead simple articles/tutorials about DataKinds, TypeFamilies, and HKTs? Along with their practical uses (NOT Nat/Zero/Succ examples!)
10:19:49 <dmwit> The documentation is good, and the papers that introduced them start with motivating examples.
10:21:35 <nitrix> Is anyone aware of a method to partition a 2D grid of (alive/dead) cells, to group them into contiguous (touching top/left/right/left) regions? I looked into graph cut-edge / articulation points, but it's O(|V|+|E|) and my instinct tells me there exist a simplification for a 2D grid.
10:22:08 <nitrix> (e.g. it's not directional, maybe could be simplied to a tree or something)
10:23:25 <dmwit> Since O(|E|) = O(|V|) for 2D grids, it's hard to imagine doing better than O(|V|+|E|) = O(|V|).
10:23:33 <dmwit> Surely you have to at least look at every point on the grid, right?
10:24:59 <nitrix> Isn't there a way to keep additional information on each grid cell?
10:25:28 <nitrix> Maybe amortize the cost during insertions and deletions to avoid a full traversal O(|V|) everytime something's removed?
10:25:41 <dmwit> You want an online method to recompute the partition as the grid changes or something?
10:25:53 <dmwit> I don't know what insertion and deletion means.
10:26:20 <nitrix> I tried all kinds of strategies. Incremental numbers, boolean to tell me that this cell was part of a cycle, etc, all fail somewhere :(
10:26:39 <dmwit> I think you need to describe your problem more carefully.
10:26:46 <nitrix> dmwit: Oh, sorry, marking active/dead in this case. I need to keep up to model I presented, sorry.
10:27:03 <dmwit> I'm making educated guesses about what you mean in several places, but my estimate of the robustness of my interpretation is falling quickly.
10:27:12 <mnoonan> if you're doing some kind of CA, you can at least restrict to recomputing connectivity on stuff touching the area where you applied a rule
10:27:22 <napping> nitrix: "Dynamic Connectivity", right?
10:27:34 <LordBrain> Certificate Authority?
10:27:41 <dmwit> cellular automaton
10:27:46 <LordBrain> ah
10:28:33 <nitrix> napping: dmwit mnoonan The full story is a game in space wjere if I remove a block, I have to detect a region became isolated and turn it into its own ship entity (regroupment of blocks).
10:28:34 <napping> nitrix: I'm afraid I don't know of anything special for the 2d case
10:29:11 <LordBrain> so like 'fill' in paint?
10:29:36 <LordBrain> just walked in, sorry if i sound like a space cadet
10:29:55 <nitrix> LordBrain: Like graph cut-edges / articulation points.
10:30:11 <LordBrain> ah
10:30:23 <napping> nitrix: Is it probably small enough you don't care too much about asymptotic complexity?
10:30:26 <nitrix> napping: Yeah, I think it falls into dynamic connectivity (on the very little I know about it)
10:30:27 <dmwit> nitrix: You may like to search for "union-find with deletion".
10:30:36 <LordBrain> i would think google would turn up some decent algorithms
10:30:49 <nitrix> napping: The O(n) seriously scare me. I can't believe there isn't anything better for finding cut edges.
10:30:55 <dmwit> nitrix: Top result looks relevant: a union-find data structure with constant-time makeset, union, and delete, and the usual O(a(n)) find.
10:30:56 <mnoonan> what if you mark non-filled points that are exterior (can reach infinity)?
10:30:58 <ertes> nitrix: can you keep it strictly hierarchial?
10:31:04 <nitrix> napping: These ships are huge, thousands of blocks :/
10:31:07 <napping> nitrix: I was suggesting that as a possible formal description of your problem, not assuming anyone was familiar with it
10:31:35 <mnoonan> then if I'm understanding you right, removing a bridge will only split a group if it connects some points-reaching-infinity to some not-reaching-infinity points
10:31:45 <mnoonan> I guess I'm assuming your shapes are simply connected :|
10:31:49 <nitrix> ertes: I can but that'd be part of the solution I'm looking for. Because a 2d grid naturally connects with top/left/right/bottom.
10:32:12 <dmwit> Or perhaps not.
10:32:16 <mnoonan> wait, I'm talking nonsense
10:32:19 <dmwit> Perhaps deletion doesn't have the semantics I'm thinking of.
10:32:46 <nitrix> ertes: If I start keeping it hierarchical like a tree, then I'd have to recompute some of the neibhours on removals to see if they still connect to other things and rebuild part of that tree.
10:33:06 <ertes> nitrix: yeah, i don't think you can really improve beyond linear
10:33:18 <nitrix> The grid is always a grid. I can insert or remove stuff in those cells, that is all.
10:33:45 <nitrix> So the grid topology doesn't simplify anything huh :/ ?
10:34:12 <LordBrain> what would be a non-grid?
10:34:13 <ertes> nitrix: or can you…  connecting is easy enough; it's disconnecting that's difficult
10:34:40 <napping> I have no idea if it helps. https://en.wikipedia.org/wiki/Dynamic_connectivity#Fully_dynamic_connectivity quotes amortized (lg n)^2 for some of the tricky algorithms
10:34:41 <nitrix> ertes: Yes. I've actually already implemented insertions. I got stuck on deletions.
10:34:52 <LordBrain> non-grid = using floats?
10:34:53 <ertes> nitrix: one way to think of it is:  you're dynamically constructing an equivalence relation
10:35:55 <ertes> nitrix: whenever you add a fact, you can immediately make a lot of new conclusions based on it
10:36:10 <ertes> nitrix: but when you remove a fact, you have to "garbage-collect"
10:36:43 <nitrix> I'm assuming that's an `unsolved` problem?
10:36:44 <ertes> the connected cells are the equivalence classes of that relation
10:36:51 <LordBrain> i am sorry i'm ignorant of the problem at hand, but maybe you could get away with not doing it... i mean, how are the edges created, if you can update them as they change... just track them rather than detect
10:37:07 <ertes> nitrix: i'd say it's a problem with linear complexity =)
10:37:16 <ertes> considering all of this linear is actually pretty good
10:37:51 <LordBrain> i guess you would have already exhausted that possibility before coming to us
10:38:18 <nitrix> ertes: I can't help but think, if I have this cross-shaped structure, cutting any of the arms or the middle, obviously sections the structure in two structures.
10:38:43 <napping> nitrix: the "General graphs" suggestion on the wikipedia page doesn't sound too bad
10:38:52 <nitrix> ertes: Shouldn't the cell be able to just know without looking at the whole thing? Surely it can stop at some major points that could pass this information.
10:38:53 <LordBrain> i think i need a picture
10:38:56 <ertes> nitrix: with your bird's eye view, sure, but the computer has a local view
10:39:01 <nitrix> e.h. "there's a loop behind this path".
10:39:04 <LordBrain> a screen shot perhaps?
10:39:50 <LordBrain> what are the limitations on the shapes here, is what i am missing
10:40:25 <napping> nitrix: keeping some spanning forest, and figuring out how to reconnect things if it breaks
10:40:47 <ertes> LordBrain: think battleship, but ships that touch connect, and if you attack a ship by removing a square, it may turn into two smaller ships
10:41:29 <napping> "thousands" isn't really that big
10:41:31 <xuxu> 11:19 < dmwit> The documentation is good, and the papers that introduced them start with motivating examples.
10:41:33 <nitrix> napping: I think that's where I'm headed next. I've got that proposition a few times and kind of see how it'd work.
10:41:40 <xuxu> dmwit: which documentation? i've been looking for it 
10:41:48 <xuxu> and which papers? :)
10:42:08 <ertes> nitrix: you're facing the flood-fill problem…  maybe you can find a flood-fill algorithm that can use a data structure, as long as you maintain it
10:42:46 <napping> nitrix: There ought to be better information somewhere, but the general theme that the excessively complicated algorithms later try to optimize finding an edge to reconnect thing seems also like a decent direction to go
10:42:56 <ertes> nitrix: but if your "ships" don't grow larger than a few hundred or thousand cells, i wouldn't bother
10:42:58 <napping> and a place where you might get some benefit from the 2d structure
10:43:11 <mnoonan> nitrix: what if you track the outer boundary of each region?
10:43:39 <napping> First obvious idea is to use something like A* instead of an undirected Dijkstra search
10:44:06 <nitrix> A lot of people proposed DFS for the O(n) solution.
10:44:17 <LordBrain> yeah, the boundary, you can use loops to cut.. i did something like that in a 3d printer program
10:44:23 <napping> thats O(n) worst case
10:44:30 <Antares> https://vk.com/rexant
10:44:40 <napping> if you're searching from one side of the break to the other, it's probably much faster
10:44:48 <napping> especially if you can use geometry to direct the search
10:44:52 <nitrix> mnoonan: How would I do this boundary tracking? What are the interest points?
10:45:14 <nitrix> Also I can move the discussion to #haskell-game if this is too noisy.
10:45:18 <napping> You might be able to track articulation points. I think the tricky bit is when deleting one thing makes new articulation points
10:45:44 <nitrix> napping: Yes, it's particuliarly that tricky bit I'm trying to solve :P
10:45:53 <napping> But on a 2d graph it's maybe not so hard
10:46:04 <ertes> nitrix: how many cells?
10:46:16 <nitrix> napping: Exactly. I can't help but think I can avoid O(n) because it's 2D :/
10:46:19 <napping> Perhaps deleting a grid cell can only make immediate neighbors into articulation points, if that cell wasn't already an articulation point?
10:46:31 <LordBrain> i made the edges directed, and used an even odd rule... 
10:46:33 <nitrix> ertes: https://farm8.staticflickr.com/7403/14070032424_4dbee3b254_o.png
10:46:35 <mnoonan> nitrix: if zero or two of vertices on the removed square are not on the boundary, then no change needed (but you might need to add to the boundary)
10:46:43 <nitrix> ertes: This is a rather small ship. They end up pretty huge normally.
10:47:08 <ertes> nitrix: i'm not going to count the cells =)
10:47:13 <nitrix> ertes: Actually correction, that's two ships. There's a second on the bottom right.
10:47:18 <mnoonan> if all four are, you might be able to say something about components getting removed by looking at the order that the four vertices are visited when walking the boundary
10:47:23 <mnoonan> but I haven't tried to work out details :)
10:47:40 <napping> nitrix: I suspect some of the fancier algorithms have unacceptable constant factors
10:47:50 <nitrix> LordBrain: even / odd ?
10:48:13 <ertes> nitrix: from a quick estimation i'd say that's about 2000 cells
10:48:16 <LordBrain> nitrix, https://sites.psu.edu/fa13math497c/tag/even-odd-rule/
10:48:58 <nitrix> ertes: Yeah and no, it finds if the cell is "solid" (able to hold the structure of the ship) by iterating all tiles on that given cell.
10:49:15 <nitrix> ertes: Some of those cells have like 5 things piled up. Lockers, wires, whatnot.
10:49:22 <ertes> nitrix: one thing you can probably do is to keep track of regular shapes within a region in order to do the flood-fill faster…  if you keep track of squares, you cut the complexity of flood-filling to its outline
10:49:40 <nitrix> Maybe O(n) is okay, but I kinda feel bad doing this everytime something to the structure changes.
10:49:44 <LordBrain> that was just one of the links, if you google, winding number and even odd you might find more detailed explanation
10:49:59 <nitrix> LordBrain: Thanks, kept that tab, I'll let your know.
10:50:01 <nitrix> *you
10:50:37 <ertes> nitrix: you can maintain that optimisation for as long as the shape stays intact…  when it is destroyed, it normally splits into a bunch of new shapes
10:50:50 <ertes> nitrix: i think you can make it pretty fast this way, but it will still be O(n)
10:51:22 * nitrix scratches head.
10:51:51 <napping> I think taking a few microseconds when a ship actually breaks wouldn't be too bad?
10:51:59 <nitrix> I'm almost sure if I can group them somehow, give them a pointer to data to represent that group, and change information on the group occasionally, I can avoid looking at all of the tiles individually.
10:52:04 <napping> as long as you quickly handle more minor damage
10:52:19 <ertes> nitrix: yeah, that's what i'm suggesting
10:53:01 <ertes> nitrix: you can use a k-d-tree to keep track of these, let's call them, super-squares in order to get a fast "in which super-square is this cell?" test
10:53:53 <nitrix> ertes: Oh I see the idea.
10:54:08 <nitrix> ertes: Then you have a bigger grid made of the k-d-tree cells.
10:54:20 <nitrix> And how those connect together.
10:54:39 <napping> xuxu: The GHC User's Guide references papers in most of the sections on extensions: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#type-families https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#datatype-promotion
10:55:12 <ertes> nitrix: that's the idea…  i haven't thought it through completely, but at least you can do the flood-fill skipping
10:55:21 <nitrix> ertes: Mhm.
10:55:22 <ertes> whether you can give up on individual cells completely i'm not entirely sure
10:55:35 <ertes> i think that returns you to the original problem
10:55:44 <ertes> so consider this just an optimisation for now =)
10:55:47 <ertes> still O(n)
10:55:53 <napping> ertes, nitrix: I'm not sure big cells work right if you have something like a long winding path wandering back and forth through cells
10:55:57 <nitrix> Alright, grabbing lunch, will try to work it out and maybe find limitations or new possible solutions.
10:56:44 <mahdi> suzu: back, could you find any clue?
10:57:32 <ertes> napping: yeah, there are definitely pathological cases…  i'd go for a minimum size and try to make them as large as possible
10:58:03 <nitrix> napping: You'd get the connectivity A <-> B <-> C <-> D <-> E  where A,B,C,D,E are bigger cells. The point is just to group all the, erhm, cell edges collections that happens at a smaller zoom level to regroup them at a bigger zoom level.
10:58:23 <nitrix> napping: This way I can reduce to flood fill a little and keep flood fill information in those big cells I think.
10:58:39 <ertes> even if you don't get those groups, you can at least skip the flood-fill for the super-square cells
10:58:40 <compact-subset> I have a function fix (x, y) = (x, f y). I feel there must be some nice Lens thing that would let me write this succinctly in terms of id and f. Any pointers?
10:58:53 <nitrix> Brb later. Thanks for the nice contributions.
10:58:58 <napping> nitrix: I suspect you might be able to keep track of biconnected components, and use the 2d connectivity to update it faster on deletions
10:59:43 <glguy> compact-subset: succinctly? fmap
10:59:47 <lyxia> compact-subset: fmap f
10:59:48 <glguy> fmap f, rather
11:00:29 <compact-subset> fmap doesn't help; there are different types and functions for each component of the pair.
11:01:05 <cocreature> compact-subset: fmap helps for the second element in the pair
11:01:11 <napping> It does for the function you wrote, which only operates on the second. Specifically using lens is I think (_1 .~ f)
11:01:22 <napping> oops, (_2 .~ f)
11:01:26 <cocreature> compact-subset: there is “second” and “first” in Bifunctor if you want to have it generally
11:01:30 <glguy> napping: You'd want %~
11:01:45 <cocreature> or lens, but it really doesn’t buy you anything over first and second if that’s all you want
11:01:48 <napping> maybe that's it
11:02:13 <napping> cocreature: doesn't a lens compose better with lenses?
11:02:44 <cocreature> napping: sure, that’s why I added “if that’s all you want”. if you want to compose it with other stuff then lenses start to make sense
11:02:51 <cocreature> if you just want that function it doesn’t help
11:03:19 <napping> if you just want to map the second element, you don't need bifunctor either
11:04:41 <napping> compact-subset: your fix = _2 %~ f
11:06:55 <compact-subset> Sorry; I don't see how these help. I'm looking for a foo that behaves like foo f g (x, y) = (f x, g y)
11:07:10 <ertes> compact-subset: bimap
11:07:12 <ertes> :t bimap
11:07:14 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
11:07:26 <compact-subset> Aha. :)
11:07:32 <napping> Ah, that's more than "fix (x, y) = (x, f y)". Yeah, bimap is exactly that
11:07:59 <compact-subset> (Yes, in my initial post I mentioned "id" obliquely implying that; not clear.)
11:08:17 <napping> In general lens isn't especially great if you want to update multiple locations
11:08:35 <napping> (_1 %~ f . _2 %~ g) will do, but that's just two updates
11:09:06 <napping> there's no sharing of parts of the traversal or anything nice like that
11:09:07 <ertes> > (_2 %~ (_1 %~ (+ 1))) (10, (20, 30))  -- this is a social experiment
11:09:10 <lambdabot>  (10,(21,30))
11:10:07 <glguy> > (10,(21,30)) -- optimized, experiment success
11:10:10 <lambdabot>  (10,(21,30))
11:10:37 <napping> ertes: why did you write it like that?
11:10:59 <glguy> napping: To generate a response
11:10:59 <ertes> napping: good question
11:11:09 <ertes> napping: fix it…  i know you want to!
11:13:21 <the_2nd> when I newtype e.g. newtype Ints = Ints [Int]
11:13:30 <the_2nd> and I call functions via
11:13:35 <the_2nd> f :: Ints -> a
11:13:58 <the_2nd> f (Ints is) = something is   --- I can unwrap them easily
11:14:12 <the_2nd> but when I want to write a function pipe
11:14:38 <the_2nd> f . g . h . (foo :: Ints)
11:14:49 <the_2nd> how can I unwrap the value e.g. for function g?
11:14:57 <the_2nd> since g only accepts [Int]
11:15:20 <glguy> newtype Ints = Ints { toIntList :: [Int] }
11:15:41 <glguy> (f . g . toIntList . h) foo
11:17:21 <newbie24> Hello! I need some help
11:17:49 <napping> Hello
11:18:53 <joehillen> http://doodle.com/poll/82xf854t9mmuv22h
11:19:11 <napping> which help do you need?
11:19:18 <geekosaur> newbie24, you'll get help faster if you actually ask your question
11:19:22 <newbie24> The below program shows me error - parse error on input `putStrLn`
11:19:22 <the_2nd> glguy, looking good, thanks
11:19:40 <newbie24> https://thepb.in/p/r0hwRKZZpBQfK
11:20:01 <napping> are you mixing tabs and spaces?
11:20:07 <newbie24> no
11:20:16 <newbie24> I used only spaces.
11:20:23 <napping> I see two vertical grey bars in the whitespace on line 7, and not on line 8
11:20:34 <napping> er, on line 6
11:20:40 <glguy> newbie24: You used spaces
11:20:46 <geekosaur> same, which makes me think it expanded tabs
11:20:55 <glguy> newbie24: To use spaces with Haskell you'll need to set your tabstop to 8 characters
11:20:57 <napping> In the raw view they don't like up
11:21:00 <glguy> errrrr, you used tab
11:21:08 <napping> *don't line up
11:22:25 <geekosaur> haskell is whitespace-sensitive, like python; it's safest to use only spaces
11:22:54 <napping> The args <- line seems to start with a tab
11:24:12 <newbie24> Problem is fixed. Thanks! I was using sublime text and apparently it inserted a tab without my knowledge. Thanks again!
11:24:36 <napping> glguy: Don't you mean to use tabs with Haskell?
11:24:57 <glguy> napping: certainly
11:25:17 <compact-subset> Perfect! Thanks. :)
11:25:55 <napping> newbie24: great. There's also another syntax with braces, if you don't want to use indentation somewhere
11:27:11 <newbie24> Okay, how does that work? Like using braces in C/C++?
11:27:40 <napping> Hardly anybody writes their code that way, but it's nice for checking your grouping or writing on one line for the interpreter
11:27:48 <napping> Put a { } around the block, and ; between the lines
11:28:18 <napping> Then it goes by that instead of looking at indentation at all, for that level of syntax. If you write a do or something inside of that block, it looks for indentation as uses inside it
11:29:06 <napping> main = do { args <- getArgs; putStrLn (" Hello , " ++ args !! 0) } is just like your code
11:36:08 <MichaelK> Hi, how can I get something like Test.QuickCheck.All.quickCheckAll to see all *imported* functions?
11:39:32 <napping> MichaelK: that's not trivial. If you want something that works automatically, I guess look at the source of forAllProperties and read the Template Haskell docs to see how much you can learn about the imports
11:40:45 <napping> can you use quickCheckAll in each module to get IO Bool tests, and then group them together more explicitly?
11:41:30 <MichaelK> napping: that's probably the best solution. looking through Language.Haskell.TH, it doesn't look like there's a good way to get imported Names, at all
11:41:56 <napping> I have no idea what it supports myself.
12:27:13 <owoce> hey everyone i need some help with numeric typeclasses
12:27:36 <owoce> trying to calculate (log 2) of maxBound::Int
12:28:00 <owoce> i tried fromIntegral, didnt work
12:29:43 <pjrt> log 2 of maxBound::Int ?
12:29:46 <dmj`> > logBase 2 (fromIntegral (maxBound :: Int) :: Double)
12:29:50 <lambdabot>  63.0
12:29:51 <pjrt> Do you mean logBase 2?
12:30:10 <{AS}> Oh shouldn't it be 64?
12:30:17 <{AS}> Ah nevermind, it is signed
12:30:20 <geekosaur> sign bit
12:30:36 * geekosaur is slow
12:30:44 <{AS}> geekosaur: Thanks anyway :)
12:35:07 <dmwit> xuxu: I was responding to saurabhnanda with that comment.
12:35:31 <pjrt> log 2 of maxBound::Word
12:35:58 <pjrt> Idk how this bot works :\ 
12:36:19 <mauke> I'm not a bot
12:36:49 <pjrt> I meant Lambdabot
12:36:54 <pjrt> I'm new here
12:36:56 <xuxu> oh, okay
12:36:56 <tsani> > "hello"
12:36:58 <lambdabot>  "hello"
12:37:11 <tsani> Prefix your expression with an arrow >
12:37:14 <pjrt> > log 2 of maxBound::Word
12:37:16 <lambdabot>  <hint>:1:7: error: parse error on input ‘of’
12:37:24 <pjrt> But it got it before
12:37:29 <tsani> > logBase 2 (maxBound :: Word)
12:37:31 <pjrt> Is it the question mark?
12:37:31 <lambdabot>  error:
12:37:31 <lambdabot>      • No instance for (Floating Word) arising from a use of ‘logBase’
12:37:31 <lambdabot>      • In the expression: logBase 2 (maxBound :: Word)
12:37:38 <dmwit> xuxu: Nevertheless, in case you have similar interests to saurabhnanda... documentation: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/, see especially sections 9.4 (Extensions to data types and type synonyms) and 9.9 (Type families)
12:37:40 <mauke> pjrt: ?
12:37:46 <mauke> this is #haskell
12:37:56 <mauke> lambdabot runs haskell code
12:38:07 <dmwit> xuxu: papers: "Giving Haskell a Promotion" was the one I had in mind
12:38:23 <tsani> pjrt: dmj` wrote "> logBase 2 (fromIntegral (maxBound :: Int) :: Double)" write after you wrote "log 2 of maxBound::Int ?"
12:38:31 <pjrt> ohhh
12:38:38 <pjrt> Happy coincidence :D 
12:38:47 <pjrt> Thanks
12:39:33 <xuxu> :t flip
12:39:35 <lambdabot> (a -> b -> c) -> b -> a -> c
12:39:53 <xuxu> is there a function which has the type sig a -> b -> c?
12:39:56 <dmwit> xuxu: The documentation for type families also links to several other papers that are relevant.
12:40:03 <xuxu> i hoogled and didn't see anything like that
12:40:15 <xuxu> dmwit: i wasn't able to find the documentation for type families
12:40:18 <hydraz> xuxu: Any function of arity two has type a -> b -> c
12:40:20 <hydraz> :t map
12:40:21 <xuxu> i looked in the haskell 2010 report
12:40:21 <dmwit> xuxu: Only `undefined` and variants thereof (like `const undefined`, etc.)
12:40:22 <lambdabot> (a -> b) -> [a] -> [b]
12:40:27 <dmwit> xuxu: Section 9.9 of the user's guide.
12:40:37 <dmwit> xuxu: Which I linked you to above. =)
12:40:42 <hydraz> (a -> b) ≈ a, [a] ≈ b, [b] ≈ c
12:40:45 <dmwit> xuxu: It's an extension, so not part of the Report.
12:41:39 <xuxu> dmwit: i see tha tyou linked, sorry i missed it! guess i need to tweak this color scheme further
12:42:14 <owoce> dmj: wow, thanks. just spent 20 minutes reading about haskell numeric classes because i didn't notice `log` only takes one parameter....
12:42:35 <owoce> dmj: thought it was a number conversion problem
12:42:36 <arianvp> :t log
12:42:38 <lambdabot> Floating a => a -> a
12:42:44 <dmwit> There is only one true base for logarithms. ;-)
12:42:44 <owoce> i know i know
12:42:45 <arianvp> :t logBase
12:42:45 <mauke> > log (fromIntegral (maxBound :: Int)) / log 2
12:42:50 <lambdabot> Floating a => a -> a -> a
12:42:50 <lambdabot>  63.0
12:42:56 <arianvp> =)
12:45:55 <dmwit> xuxu: Also: as hydraz points out, the correct answer to your question about what terms have type `a -> b -> c` depends on exactly what "have" means.
12:46:18 <dmwit> Many terms have types that unify with `a -> b -> c`; but only a few marginally useful terms have types alpha-equivalent to it.
12:46:47 <hpc> dmwit: are there even any useful ones?
12:47:02 <dmwit> hpc: I dunno. People keep telling me infinite loops are useful sometimes.
12:47:27 <dmwit> Perhaps statically-known-infinite loops are less useful. =)
12:47:57 * hackagebot http-link-header 1.0.2 - A parser and writer for the HTTP Link header as specified in RFC 5988 "Web Linking".  https://hackage.haskell.org/package/http-link-header-1.0.2 (myfreeweb)
12:48:03 <hpc> yeah, i take a more constructive view as well
12:48:15 <hpc> if you're getting something useful out of the loop it's a -> b -> IO c
12:48:25 <hpc> or it's impure and thus the darkest of evils
12:48:34 <LordBrain> even with all the tools we have, i still think writing parsers should be even easier
12:48:52 <dmwit> hpc: http://perl.plover.com/classes/typing/samples/slide030.html
12:48:53 <LordBrain> i liked the idea of bnfc for example
12:49:17 <dmwit> hpc: Perhaps better to start at slide 27, actually: http://perl.plover.com/classes/typing/samples/slide027.html
12:49:31 <LordBrain> last i checked tho, it didnt give you enough control over the lexing tho
12:49:43 <LordBrain> in an easy way anyway
12:51:22 <napping> Doesn't it allow regular expressions for the lexing?
12:52:50 <LordBrain> yes, which is good, but it doesnt let you specify the order of matching those 
12:52:50 <LordBrain> it may seem less elegant, but it would actually be easier to just have a a list of regular expressions in order
12:52:56 <LordBrain> so you dont have to worry as much about overlap etc
12:52:57 * hackagebot tasty-silver 3.1.9 - A fancy test runner, including support for golden tests.  https://hackage.haskell.org/package/tasty-silver-3.1.9 (PhilippHausmann)
12:53:27 <LordBrain> also, its not clear that the default lexing is adding a lot... 
12:53:42 <Tomek_> Hi, can someone help me with function composition ?
12:53:51 <dmwit> ?where justask
12:53:51 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
12:53:51 <LordBrain> so maybe a tool like bnfc, but with no default lexing, and an ordered list of token expresssions
12:54:15 <xuxu> why is "brain d foy" considered a scalar?
12:54:28 <mauke> because it's a single value
12:54:35 <dmwit> What is a scalar, and why do you think "brain d foy" is considered one?
12:55:02 <LordBrain> should it be brian d foy?
12:55:13 <hpc> i like that the last slide links to a "next" 404
12:55:50 <hpc> xuxu: from those slides? it's written for perl users
12:56:20 <gosu94> lets  say we have a function h x y = f x (g y) . Can somebody explain to me step by step why h = flip ((.) . f) g  ?
12:56:35 <xuxu> hpc: yeah, from the slides. i've heard of scalars before, but not in this context 
12:57:19 <napping> flip ((.) . f) g x y => ((.) . f) x g y => (.) (f x) g y == (f x . g) y = f x (g y)
12:57:37 <dmwit> gosu94: h = \x y -> f x (g y) = \x y -> (f x . g) y = \x -> f x . g = \x -> (.) (f x) g = \x -> flip (.) g (f x) = \x -> (flip (.) g . f) x = flip (.) g . f
12:57:46 <hpc> gosu94: are you asking out of curiosity or do you genuinely want to know? ;)
12:57:53 <hpc> pointfree manipulations can be veeeeery tedious
12:57:55 <LordBrain> haha
12:58:12 <lambdaislove> So say in my project I need to create a bunch of new monad transformers. This is going to mean everytime I hadd a monad transformer I'm going to have to make a typeclass and redundantly implement it with lift for each typeclass of each new monad transformer
12:58:12 <gosu94> hpc: I'm studying :D
12:58:29 <lambdaislove> How does one avoid that boilerplate and implement those typeclasses directly?
12:58:49 <dmwit> ?pl h x y = f x (g y)
12:58:49 <lambdabot> h = (. g) . f
12:59:05 <napping> You can't really, if you are writing new transformers from scratch with the standard type classes
12:59:10 <dmwit> Okay, I explained the wrong expression. Bummer.
12:59:26 <lambdaislove> napping: are there alternatives to monad transformers then?
12:59:33 <lambdaislove> or the standard typeclasses?
13:00:01 <dmwit> lambdaislove: Do you actually have a large collection of genuinely new monad transformers? That seems relatively uncommon to me.
13:00:02 <napping> There may be alternate type classes. Why are you implementing a bunch of monad transformers?
13:00:30 <napping> If you're just wrapping up some useful compositions of existing monad transformers you can take advantage of the instances
13:00:53 <lambdaislove> dmwit: It's like only 4 or 5 and they do specific things not generic things. But the intent is to allow more such transformers
13:01:00 <johnw> lambdaislove: this is perhaps one of the essential problems with transformers, which forces one to ask whether they are really the right solution.  Algebraic effects may give you the flexibility you need, so long as you understand the performance implications.
13:01:24 <LordBrain> i like hte concept of the effect-monad package, but i'll caveat that i have not used it anything sizeable or practical
13:01:35 <lambdaislove> basically if I have N transformers I have to implement N^2 typeclasses and each instance is just lifting
13:01:45 <johnw> I've been meaning to use free-vl in anger at some point, it looks quite promising
13:01:49 <dmwit> lambdaislove: Probably you don't need new type classes. That's very rare. Are you sure you have new effects not covered by the existing classes, let alone five whole collections of new effects?
13:01:56 <hydraz> TemplateHaskell when?
13:02:37 <dmwit> lambdaislove: (Let's make sure there's actually a problem before we go hunting for complicated solutions!)
13:03:16 <lambdaislove> dmwit: yes. I'm separating language features out but during parsing you need certian recursive things like "expression" or "definition" etc... each of these makes a monad transformer and people could add new language features that required new transformers
13:03:37 <lambdaislove> so these aren't generic things like "MaybeT" they're specific things like "ParseExprT"
13:04:06 <LordBrain> hmm
13:04:38 <michaelt> lambdaislove What does this have to do with type classes though? 
13:04:43 <LordBrain> but you dont need type classes for them do you? that's only if you want to write code for alternatives with similar interfaces
13:04:44 <dmwit> What effects are available for a `ParseExprT` that aren't available from, say, `MonadError ParseError` and perhaps `MonadState StreamContents`?
13:05:30 <lambdaislove> the reason I want to use monad transformers is because a) ParseExprT might have multiple implementations *and* you have to dynamically build up what counts as an expression in my case so ParseExprT is a state monad where the state is actully a parser that changes a) depending on language features and b) as system parses the input 
13:05:30 <LordBrain> so if you have ParseExprT1 and ParseExprT2 where these are interchangeable implementations, with the same interface, then you make a type class
13:06:01 <napping> lambdaislove: how are you requring that that transformer be somewhere in the final monad?
13:06:41 <lambdaislove> napping: I want one monad that provides several of many monad transformer like typeclasses implemented by yet more monad transformers
13:06:43 <LordBrain> you could avoid type classes by having a record state which actually contains methods, then your initializer sets the 'implementation'
13:07:10 <lambdaislove> LordBrain: that's not extensable. if someone wants to add modules they have to redefine that record
13:07:18 <LordBrain> the advantage of threading the methods in the state that way would be you could switch implementations on the fly
13:07:25 <lambdaislove> I'd rather have a ModuleT alogn with a MonadModule typeclass
13:07:30 <LordBrain> okay
13:07:40 <napping> So you're making new classes for monads that have your operations, and transformers that add them, and classes that show how they relate? That will be N^2 following the transformers design
13:07:55 <napping> wasn't there a transformer library that used type-level lists or something?
13:08:14 <lambdaislove> man that'd be sweet if there was
13:08:27 <dmj`> napping: ether uses type level literals
13:08:31 <dmj`> @package ether
13:08:31 <lambdabot> http://hackage.haskell.org/package/ether
13:11:29 <napping> a lower-tech approach is to write some generic lifting functions with types like genericFooMethod :: (MonadTrans t, MonadFoo m) => ... (t m) ....
13:11:46 <napping> and even give them as the default implementation for your typeclasses
13:11:58 * shapr hugs napping for being awesome
13:12:03 <lambdaislove> that demands overlapping instances though dosn't it?
13:12:13 <napping> Nope, just default methods
13:12:19 <napping> Trying to make that an *instance* would overlap
13:12:49 <lambdaislove> OH! so default methods can be overridden!
13:12:50 <napping> if you explicitly write instance (MonadFoo m) => MonadFoo (ParseEnvT m) where method = genericFooMethod, that's obviously not overlapping at all
13:13:00 <lambdaislove> but you still have to make the thing an instance right?
13:13:03 <napping> yweah
13:13:21 <lambdaislove> so it's still n^2 but we're talking lines not whole instances
13:13:21 <napping> but if you have default methods you just need to write the instance line
13:13:24 <napping> yep
13:13:47 <lambdaislove> yea that's much better than what I had so far. I'm reading about algebraic effects and extensiable effects now
13:13:55 <napping> type-level lists and fancieness are fun too, but hopefully overkill for a modular interpreter
13:14:01 <lambdaislove> likely one of those will be my solution I think
13:14:34 <lambdaislove> I tried solving this by making a type level list of constraints but didn't get anywhere with it
13:15:53 <dmwit> With `DeriveAnyClass` you don't even need to write a whole instance line, of course.
13:16:30 <Ed___> is there a version of "map" that creates a new list instead of modifying the old one?
13:16:37 <lambdaislove> where can I read about DeriveAnyClass?
13:16:43 <dmwit> Ed___: That is the default behavior.
13:16:50 <lambdaislove> I can't seem to find anything about DeriveAnyClass
13:16:52 <dmwit> Ed___: In Haskell, there is no modification.
13:17:03 <Ed___> oh ok. i was thinking that might be the case. thanks
13:17:27 <jle`> > let x = [1,2,3] in (map (*2) x, x)
13:17:28 <dmwit> lambdaislove: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-any-other-class
13:17:29 <napping> lambdaislove: extensions are usually in the GHC user's guide
13:17:30 <lambdabot>  ([2,4,6],[1,2,3])
13:17:31 <jle`> ^ Ed___ 
13:17:36 <LordBrain> well technically you could use Mutable VEctors
13:17:40 <hydraz> *insert mniip breaking the ghc with magic here*
13:17:47 <Ed___> awesome. great example. thanks
13:17:47 <LordBrain> and they do have something like that i think
13:18:05 <LordBrain> if you really want it, its there in the vector package
13:18:31 <LordBrain> its not as pleasant to work with
13:18:41 <lambdaislove> ah so no with DeriveAnyClass I'm still at n^2 but it's single words not lines now
13:18:52 <lambdaislove> I like how you guys keep widdeling this down lol
13:19:02 <dmwit> s/widdeling/whittling/
13:19:10 <lambdaislove> yea that
13:19:22 <napping> I'm not sure DeriveAnyClass will make instances like you want
13:19:26 <napping> but it's worth a try
13:19:28 <dmwit> Personally, I am still skeptical that additional classes are needed at all.
13:20:06 <napping> You do need "Default Method Signatures", if you want to write a default with an extra constraint
13:21:09 <lambdaislove> dmwit: I'm quite open to new ideas. I can PM you the design parts that I *really* want and perhaps you could lead me in a better direction on this monad thing
13:21:35 <dmwit> I prefer interacting in public fora like this one. Perhaps a paste would be more appropriate.
13:21:38 <dmwit> ?lpaste
13:21:38 <lambdabot> Haskell pastebin: http://lpaste.net/
13:21:39 <napping> Just using constraints like MonadState MyInterpreterState might get pretty far
13:21:43 <lambdaislove> ah yea paste
13:22:02 <napping> but when you have several state components it gets messier
13:23:49 <dmwit> I have heard good things about using lens to deal with multiple state components.
13:24:19 <dmwit> I haven't done it myself, but the interfaces have fun names with things like "Zoom" and stuff in them, so how bad could it be?
13:24:20 <napping> yeah, that's an option too
13:24:48 <Ed___> > print $ findIndex (==3) [1..10]
13:24:50 <lambdabot>  <IO ()>
13:25:23 <dmwit> > findIndex (==3) [1..10]
13:25:26 <lambdabot>  Just 2
13:25:29 <napping> dmwit: even just the operators like .= go pretty far
13:25:39 <Ed___>  But I want it to print 2, not "Just 2"
13:25:53 <dmwit> Ed___: What should it print when it does not find an index?
13:25:57 <napping> lambdaislove: How much are you doing this as a learning exercise?
13:26:10 <Ed___> It will find an index...
13:26:26 <dmwit> > fromJust (findIndex (3==) [1..10])
13:26:28 <lambdaislove> napping: um, I guess purely.
13:26:28 <lambdabot>  2
13:26:33 <Ed___> Thanks
13:26:36 <napping> lambdaislove: writing a modular monadic interpreter with your own specialized classes and transformers does sound fairly instructive
13:26:38 <dmwit> Ed___: But it is your responsibility to prove your assertion that it will find an index.
13:26:45 <Ed___> absolutely
13:26:55 <dmwit> Ed___: If you have not written down this proof, then I encourage you to think again about how to handle the situation where it does not find an index.
13:27:14 <dmwit> Ed___: Usually it is not that difficult to handle.
13:27:19 <lambdaislove> napping: I'm mainly interested in how to at the type level seperate features independent of each other
13:27:42 <napping> You might want to look into the more explicitly type-level stuff too
13:27:51 <dmwit> ?google data types a la carte
13:27:53 <lambdabot> http://journals.cambridge.org/article_S0956796808006758
13:28:00 <dmwit> lambdaislove: ^^
13:28:05 <lambdaislove> napping: wait until you see what I already have in this paste. It's preety hype
13:28:18 <napping> like ones where you have a single monad that takes as a type-level argument a list of layers you need for your current interpreter
13:28:46 <napping> I haven't found modular interpreters especially practical
13:28:56 <lambdaislove> Yea I'm quite intersted in that kind of design I'm already using polykinds and stuff
13:29:01 <dmwit> napping: agreed on practicality
13:29:03 <napping> compared to just building up your transformer stack and getting the right instances on the final monad
13:29:53 <napping> I suspect if you did want something like runtime configuration of what features to allow, you might need something like fancy type-level lists anyways, just to dynamically assemble the right types for dynamically assembled transformer stacks
13:30:29 <senoj> dmwit: that link doesn't work
13:31:07 <dmwit> senoj: No, it doesn't. =(
13:31:10 <senoj> there is a fulltext here: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.101.4131
13:31:18 <dmwit> senoj: But the next link on Google does. =)
13:32:03 <napping> Building up a monad for your interpreter using transformers works nicely
13:33:31 <dmwit> > traverse_ print (findIndex (3==) [1..10])
13:33:34 <lambdabot>  <IO ()>
13:38:23 <LordBrain> what are you parsing anyway?
13:38:35 <LordBrain> are you making a compiler?
13:44:42 <lambdaislove> dmwit: napping: http://lpaste.net/181400
13:45:08 <lambdaislove> took me a while to write it up and my writing isn't very good. feel free to ask questions
13:45:31 <lambdaislove> I think you'll like my language representation and I hope you figure out a better way to do parsing
13:47:03 <lambdaislove> LordBrain: just an interpreter for now. I'm parsing the language I'm interpreting
13:47:30 <LordBrain> general purpose language?
13:48:21 <lambdaislove> unspecified, I want it to be modular by features
13:49:24 <lambdaislove> the only thing preventing you from combining C with the lambda calculus is that the phantom types you would use in C wouldn't match up with lambda calculus and thus it'd be more of a 'C *or* lambda calculus but not both' interpreter
13:50:42 <lambdaislove> more practically I'm looking adding features to small functional languages to play around with language design
13:51:10 <lambdaislove> but in theory there's nothing stopping you from also making a Lua interpreter with it
13:54:14 <Ed___> how to map findIndex over a list. for example. map (findIndex x) [1..10]
13:54:21 <Ed___> but x changes
13:54:39 <Ed___> list comprehension?
13:54:49 <monochrom> perhaps it's a zipWith not a map.
13:54:57 <Ed___> right
13:57:34 <Ed___> zipWith doesn't work because it uses elements from the same position in the list
13:58:32 <Welkin> not sure what you mean by "x changes"
13:58:40 <Cale> Yeah, I'm not either.
13:59:12 <Cale> Perhaps you want some fold, or a mapAccumL/R ?
13:59:13 <monochrom> Clearly it can only mean: for each position in [1..10], I know what x should be in that position. Therefore it is a zipWith.
13:59:53 <pjrt> Not sure I'm getting what "map (findIndex x)" means...find the index `x` for each elem?
14:00:06 <Ed___> So I have a list: say [0,6] and a list of lists say [[1,0,3], [3,4,5,6]] and I want to map findIndex. E.g. findIndex (==0) [1,0,3] then findIndex (==6) [3,4,5,6]
14:00:27 <Cale> Yeah, that's zipWith
14:00:52 <Cale> > zipWith (\x -> findIndex (== x)) [0,6] [[1,0,3], [3,4,5,6]]
14:00:54 <Welkin> > zipWith (\a b -> show b ++ a) ['a'..'z'] [1..]
14:00:55 <lambdabot>  [Just 1,Just 3]
14:00:57 <lambdabot>  error:
14:00:57 <lambdabot>      • Couldn't match expected type ‘[Char]’ with actual type ‘Char’
14:00:57 <lambdabot>      • In the expression: 'a'
14:01:17 <Welkin> > zipWith (\a b -> show b : [a]) ['a'..'z'] [1..]
14:01:20 <lambdabot>  error:
14:01:20 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
14:01:20 <lambdabot>        Expected type: String
14:01:25 <hydraz> No, that's not how you cons
14:01:27 <Ed___> Thanks Cale!
14:01:29 <Welkin> lol
14:01:38 <Welkin> > zipWith (\a b -> show b ++ [a]) ['a'..'z'] [1..]
14:01:39 <Welkin> oops
14:01:40 <lambdabot>  ["1a","2b","3c","4d","5e","6f","7g","8h","9i","10j","11k","12l","13m","14n",...
14:03:16 <gosu94> Could somebody explain to me (step by step) this equation --> map (uncurry g) . warbler zip = map (warbler g) ? Where warbler f x = f x x
14:05:58 <napping> apply it to an argument and see how it would go
14:06:02 <mauke> take a sample list like [a, b, c, ...]
14:06:21 <mauke> what would warbler zip [a, b, c, ...] be?
14:06:25 <Welkin> gosu94: look at the type for each part
14:07:12 <gosu94> mauke: warbler zip [a,b,c,..] [a,b,c,...] ?
14:07:24 <Welkin> yes
14:07:25 <gosu94> zip [a,b,c,..] [a,b,c,...]
14:07:32 <mauke> gosu94: go on
14:08:16 <Welkin> gosu94: and now that `zip` has no more parameters, you can reduce it again
14:08:23 <Welkin> what is the output of `zip`?
14:08:44 <gosu94> [(a,a),(b,b)..] ? 
14:08:48 <Welkin> yes
14:09:36 <mauke> this part doubles up every element in the list
14:09:52 <gosu94> now the problem is with uncurry g. What does it do ?
14:09:53 <napping> this one doesn't entirely go through by simple unfolding
14:09:55 <Welkin> uncurry :: (a -> b -> c) -> (a, b) -> c
14:10:01 <hydraz> :t uncurry
14:10:03 <lambdabot> (a -> b -> c) -> (a, b) -> c
14:10:05 <mauke> @src uncurry
14:10:05 <lambdabot> uncurry f p = f (fst p) (snd p)
14:10:16 <napping> you need something like a fancier argument that warbler zip = map (warbler (,))
14:10:21 <Welkin> it changes a function to allow it to accept a tuple
14:10:31 <hydraz> ... why not uncurry f (a, b) = f a b? couldn't come up with good variable names?
14:10:31 <mniip> changes? tsk
14:10:38 <Welkin> mniip: lol
14:10:40 <Welkin> okay mniip 
14:10:45 <mniip> hydraz, laziness
14:10:46 <mauke> hydraz: laziness
14:10:47 <Welkin> it produces a new function that wraps the older one
14:10:52 <mniip> > uncurry (const ()) undefined
14:10:54 <lambdabot>  error:
14:10:55 <lambdabot>      • Couldn't match type ‘()’ with ‘b0 -> c’
14:10:55 <lambdabot>        Expected type: b1 -> b0 -> c
14:11:07 <mniip> > uncurry (const $ const ()) undefined
14:11:09 <lambdabot>  ()
14:11:25 <napping> what about a lazy pattern? uncurry f ~(a,b) = f a b
14:11:34 <shachaf> The next question is: Why not uncurry f ~(a,b) = f a b?
14:11:35 <mniip> that's just equivalent
14:11:36 <gosu94> wait, so we at the map (uncurry g) [(1,1),(2,2)..]
14:11:50 <Welkin> gosu94: you understand `map` right?
14:11:57 <gosu94> yes
14:12:00 <Welkin> okay
14:12:11 <Welkin> so you are mapping this new version of `g` over the list
14:12:13 <hydraz> An irrefutable patt- Oh, I'm 2 minutes late, blimey.
14:12:13 <gosu94> apply every function to every element in list
14:12:24 <mauke> there's only one function
14:12:41 <gosu94> applay function*
14:13:02 <gosu94> Ok
14:13:20 <mauke> [uncurry g (a,a), uncurry g (b,b), uncurry g (c,c), ...]
14:13:57 <hydraz> Did you just make it 3 elements because you want to talk about g c c, mauke? :P
14:14:34 <gosu94> so at this point it doesn't really matter what g does ?
14:14:45 <mauke> it works for all functions g
14:15:27 <Welkin> as long as g :: a -> b -> c
14:15:42 <Welkin> so the types match
14:15:43 <Ed___> Can you define a "where" inside a "main = do" block?
14:15:55 <hydraz> sure, just watch out for laying it out properly
14:16:10 <jle`> Ed___: the syntax is foo = ...; where ...
14:16:18 <Welkin> Ed___: no, they can only be used at the end of a function definition
14:16:20 <jle`> 'where' isn't a part of do block syntax
14:16:24 <jle`> it's a part of declaration syntax
14:16:30 <mauke> Welkin: that's not right
14:16:30 <jle`> not just functions, but bindigns in general :)
14:16:43 <Welkin> really?
14:16:47 <jle`> > let x = y where y = 10 in x
14:16:49 <lambdabot>  10
14:16:52 <jle`> x is not a function :o
14:17:07 <jle`> "where" is a part of declaration syntax
14:17:12 <Welkin> oh, okay
14:17:13 <jle`> not do block syntax
14:18:03 <Ed___> so I just put a semicolon at the end of the main = do block then on the next line have there "where..."?
14:18:18 <jle`> oh no, don't use a semicolon, that was my bad idea to represent a new line on IRC
14:18:23 <jle`> main = do
14:18:25 <jle`>     ...
14:18:27 <jle`>   where
14:18:30 <Ed___> thanks
14:18:31 <jle`>     blah = blah
14:18:35 <mauke> there's no newline involved
14:18:40 <hydraz> Doesn't the where have to be alined with the dow
14:18:47 <mauke> hydraz: no
14:18:48 <monochrom> No.
14:18:59 <jle`> the where has to be les sindented than the lines of the do block
14:19:00 <monochrom> Guess what, it can be to the right, too
14:19:01 <jle`> i think...
14:19:07 <jle`> oh, it doesn't?
14:19:12 <Welkin> I've used nested where before
14:19:14 <hydraz> s/.$/?/, darned alt key
14:19:15 <monochrom> let me double-check
14:19:17 <Ed___> the blah = blah has to be on new line?
14:19:24 <mniip> no
14:19:25 <mauke> Ed___: no
14:19:27 <jle`> i don't think it does
14:19:39 <mniip> layout sucks :(
14:19:41 * mniip sticks to tabs
14:19:51 <hydraz> BLASPHEMY!
14:19:54 <jle`> i think for the most part people just learn their own layouting convention that works and stick to it, heh
14:20:02 <monochrom> Yes, confirmed to be legal to be to the right
14:20:03 <Ed___> "the where has to be less indented than the liens of the do block" my indentation of the do block is 2 spaces.s..
14:20:06 <Welkin> I recently worked with someone else's program that had tabs everywhere
14:20:13 <Welkin> it was horrible
14:20:26 <senoj> mniip: check out the description of the "off sides rule" on the wiki
14:20:28 <jle`> Ed___: i'm not sure if that's necessarily true, but it's good to be able to visually see where the do block ends and where the "where" begins
14:20:40 <jle`> that's why i indent my do blocks four spaces now
14:20:44 <Welkin> just use haskell-mode and don't worry about indentation
14:21:00 <hydraz> > emacs
14:21:03 <lambdabot>  error: Variable not in scope: emacs
14:21:11 <hydraz> .. right, I wasn't sure what I was expecting
14:21:14 <mniip> senoj, where?
14:21:31 <hydraz> Why doesn't lambdabot know when I'm being sarcastic and when I'm evaluating Haskell? :P
14:21:38 <Ed___> lol
14:21:40 <Welkin> hydraz: because you are a bastard
14:21:50 <hydraz> Welkin: says the emacs user!
14:21:56 <mauke> >implying
14:22:28 <monochrom> Surely lambdabot knows. When you use "> ", you are not being sarcastic. Clearly.
14:22:42 <jle`> >_>
14:22:45 <mauke> > so sincere right now
14:22:45 <jle`> > _>
14:22:46 <hydraz> <_<
14:22:46 <monochrom> This is totally computable.
14:22:47 <lambdabot>  <hint>:1:3: error:
14:22:47 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
14:23:24 <pjrt> > sarcasm 
14:23:27 <lambdabot>  error: Variable not in scope: sarcasm
14:23:29 <senoj> mniip: sorry, thought I saw this on the wiki, but it's actually in RWH: http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#deftypes.offside
14:23:31 <pjrt> There u have it
14:23:37 <mniip> 03>greentext
14:23:40 <Ed___> lol
14:23:40 <mniip> 03>not green
14:23:47 <hydraz> I still can't do colours in weechat
14:24:05 <jle`> 05w04h07a08t 03a09r10e 11c02o12l06o13r05s
14:24:06 <pjrt> They are both green for me :\
14:24:26 <hydraz> >03green
14:24:27 <hydraz> there we go
14:24:30 <mauke> > super green
14:24:34 <mniip> senoj, what about it
14:25:01 <hydraz> fuck everything
14:25:12 <jle`> :(
14:25:12 <monochrom> are you done?
14:25:18 <mniip> "Any indentation that uses tabs is going to look broken under someone's configuration."
14:25:27 <hydraz> monochrom: Yes.
14:25:31 <mniip> I digress
14:25:42 <senoj> mniip: the section describes the layout rules in a straightforward way
14:25:49 <mniip> so?
14:26:21 <mniip> I mean, what point are you trying to make by linking me this
14:26:48 <senoj> mniip: I thought you seemed confused above about layout rules
14:26:54 <mniip> no?
14:26:59 <senoj> my bad
14:27:02 <lpaste> Ed_ pasted “Not in scope "input” at http://lpaste.net/6252508940207128576
14:27:25 <monochrom> perhaps it was meant for me. erroneous nick completion and all.
14:27:36 <senoj> sorry, yeah
14:28:00 <Ed___> getting a not in scope "input" in my "do" block after using "where ..."
14:28:10 <ReinH> monochrom: yeah you should spend some time learning the layotu rules
14:28:31 <ReinH> Ed___: That's because input will not be in scope
14:28:32 <monochrom> I need to learn monads, too.
14:28:38 <ReinH> input is only in scope within the do block
14:28:43 <ReinH> the where clause is not within the do block
14:29:01 <ReinH> (specifically, only in the do block after it is bound, ofc)
14:29:14 <jle`> Ed___: you probably want a let declaration in the do block, or to add a parameter to  lines
14:29:15 <hydraz> monochrom: Something something a monoid in the category of endofunctors in X.
14:29:35 <pjrt> Ed___: Yeah, statements in `where` are functions of their own.
14:29:41 <shapr> hydraz: right on, writing any cool Haskell code?
14:30:34 <Ed___> How to do a let declaration in the do block? not sure on the correct syntax..
14:30:49 <ReinH> let on its own line, no 'in'
14:30:59 <ReinH> let input = ...
14:31:50 <pjrt> Same indent as the rest of the body, btw
14:32:31 <lpaste> Ed_ pasted “Parse Error on input 'let'” at http://lpaste.net/181404
14:33:36 <pjrt> Well that's odd
14:36:01 <mauke> Ed___: your 'let' line uses spaces; the others tabs
14:36:04 <mauke> don't use tabs
14:36:17 <BusFactor1> Has anybody ever worked with Hylogen/Hylide (a DSL for writing GLSL shaders in Haskell)?
14:36:36 <pjrt> Don't use tabs, mmmkay?
14:36:40 <Welkin> why not just write shaders in glsl?
14:36:44 <pjrt> Tabs are bad
14:36:47 <monochrom> I doubt if that's the cuase.
14:36:57 <Ed___> I never use tabs. dunno how they got there. mustve copied/pasted from a online text editor that auto-converted them... looking at you, "lpaste".
14:36:59 <BusFactor1> Welkin: Hylide seems like a more powerful language, but it's tricky to get into
14:37:20 <Ed___> that was the cause. but now i have like 3 more errors. 
14:37:21 <monochrom> No, lpaste auto-converts nothing. It is verbatim.
14:37:26 <BusFactor1> Hylogen i mean
14:40:05 <lpaste> Ed_ revised “Parse Error on input 'let'”: “Parse Error on input 'let'” at http://lpaste.net/181404
14:40:25 <Ed___> Couldn't match expected type ‘String -> [String]’                 with actual type ‘[[Integer]]’     In the expression:       (map . map) (read :: String -> Integer) $ map words $ lines input
14:41:06 <Ed___> I've used that same exact function multiple times before. now when I put it inside of a let declaration it complains...
14:41:14 <mauke> Ed___: let lines = ... lines ...
14:41:17 <mauke> recursive definition
14:41:27 <Ed___> LOL
14:41:30 <Ed___> omg..
14:41:35 <Ed___> <- ashamed
14:43:14 <lpaste> Ed_ revised “Parse Error on input 'let'”: “It works now Thanks!” at http://lpaste.net/181404
14:44:08 <Ed___> lpaste gives me some suggestions to only use map once at multiple spots... Can anybody comment on that?
14:44:48 <Ed___> im assuming its because i do map on a list, then map again. is there some way to combine that?
14:45:15 <senoj> Ed___: you can form the composition of the two functions you're mapping and map once with that
14:45:40 <mauke> Ed___: click on the suggestions
14:45:54 <kadoban> Ed___: map f . map g = map (f . g), meaning if you're mapping multiple times, you can just combine them using (.) or some other combinator, depending.
14:45:58 <senoj> > map (+1) (map (*2) [1..3])
14:46:00 <lambdabot>  [3,5,7]
14:46:16 <senoj> > map ((+1).(*2)) [1..3]
14:46:19 <lambdabot>  [3,5,7]
14:46:30 <Ed___> Awesome! Thank you very much.
14:48:34 <spaceghost> Open your pm clint.
15:29:43 <dmwit> ?tell Ed___ In the future, you can click on lpaste's suggestions to see more details; in particular, it includes the code to replace and the replacement code to make it ultra clear what the suggestion is.
15:29:43 <lambdabot> Consider it noted.
15:30:16 <dmwit> Oh, mauke suggested that and I missed his suggestion.
15:30:34 <dmwit> oh well, can't undo it now
15:31:13 <monochrom> Sometimes they need to be told twice anyway.
15:48:16 <xcmw_> Why isn't castTo gTypeInt :: Int in http://lpaste.net/181410
15:48:49 <f-a> I am installing ghc 8, should remove ghc 7?
15:48:52 <f-a> (not that I know how)
15:49:34 <jle`> f-a: nah, ghc's can co-exist fine
15:49:48 <jle`> if you're planning on directly calling the command line tools, you might have to replace the symlinks
15:49:58 <jle`> but having ghc 7.x installed while using ghc 8 mainly is no problem
15:50:39 <f-a> jle`: what do you mean calling command line tools. like invoking ghci?
15:51:14 <jle`> yeah, usually "ghci"/"ghi"/etc. (and some internal tools) are symlinks to ghci-8.0 or something like that
15:51:33 <jle`> er, to the version-specific ghc or ghci
15:51:39 <f-a> so you mean that now when I'll invoke ghci it'll end up being ghci-8? that'd be fine
15:51:52 <monochrom> yes
15:52:12 <f-a> excellent, thanks
15:52:16 <monochrom> Take a look at your /usr/local/bin or something. You will see.
15:52:19 <jle`> oh i meant, your system might have been configured so that ghc is a symlink to ghc-7.8, and if that's the case, you would have to update the symlink (it might do it for you during the isntall process, not sure) or add the ghc-8 bins to your PATH
15:52:42 <MarLinn> f-a: Just don't dare to use Stack when you have anything else Haskell-related installed. Stack is a diva.
15:52:50 <sm> such (re)symlinking should be happening automatically, however you install
15:53:09 <f-a> MarLinn: not a stack user
15:53:12 <f-a> hi sm
15:53:19 <sm> hi f-a
15:53:44 <sm> MarLinn: I have stack and non-stack ghc and cabal installed and move between them freely
15:55:22 <MarLinn> sm: Ok, stack + ghc can work. But update cabal: stack breaks. Install a package outside a sandbox: stack breaks
15:55:38 <sm> I don't think that's right
15:55:53 <sm> generally, anyway. 
15:56:30 <f-a> I always wonder what's the correct thing to do, move immediately to $LATEST_GHC? if I upgrade my boundaries and one of my users cannot compile anymore?
15:56:51 <MarLinn> sm: That's just what I experienced. Maybe I just don't know enough about stack to work around it's ideosyncracies...
15:57:04 <f-a> is there an established etiquette? (support at least k ghc versions)
15:57:12 <sm> supporting the latest 3 GHC versions is a nice, common approach
15:57:35 <sm> as far back as necessary to get into debian stable, is another
15:57:44 <f-a> thanks
15:58:32 <sm> I'm thinking it's a good idea to use GHC 8 yourself asap, for the improved error messages (but it might build slower, don't know)
15:59:14 <sm> MarLinn: if you have an easy recipe to reproduce, I'd be interested to see
15:59:33 <f-a> so when I will finish installing ghc8, how to tell cabal "pop up all the constraints and let me fix breakage"?
15:59:55 <sm> cabal install --allow-newer ...
16:00:00 <ClaudiusMaximus> xcmw_: you can use a newtype to get that behaviour, not sure why type doesn't work (possibly gets rewritten to String really early, and  GType a = GType b  even when a and b aren't the same)
16:00:21 <f-a> sm: but will that automagically modify my .cabal file?
16:00:38 <sm> no, it's just while troubleshooting
16:00:45 <f-a> ok
16:01:45 <MarLinn> sm: Recipe 1: Install a package in stack. Install a different version of the same package with plain cabal. Make sure a module in the stack environment uses both through separate import chains. Result: conflict. That usually happens in practice because stack packages are a bit older
16:01:49 <sm> perhaps you want to comment out most constraints in the cabal file until you get an install plan working, then start to replace them
16:02:27 <sm> MarLinn: which package db are both stack and cabal sharing here ?
16:02:53 <sm> normally they are separate worlds
16:03:08 <xcmw_> ClaudiusMaximus: newtype gives me an error: The constructor of a newtype must have exactly one field but ‘String’ has none. In the definition of data constructor ‘String. In the newtype declaration for ‘GType’
16:04:14 <lpaste> ClaudiusMaximus annotated “Type Experiment” with “Type Experiment (annotation)” at http://lpaste.net/181410#a181412
16:05:19 <MarLinn> sm: stack itself seems to only manage its own db, but if you start ghc(i) from stack it will also look in the (user-)global db 
16:05:27 <xcmw_> ClaudiusMaximus: I get it now. Thanks.
16:06:43 <sm> MarLinn: is this only when running stack outside a project, or also in a project ?
16:08:27 <f-a> sm: once I know it builds with all the new things, how to list the version it is actually using?
16:08:53 <sm> here are the package db paths used by non-project stack and cabal on my system: https://gist.github.com/simonmichael/0040fb0acbb9e19079a393e5ac557fd5 . The GHC pkg db is common (because I let stack use my system GHC) but nobody should be modifying that one
16:09:24 <sm> f-a: IIRC, cd myproject; cabal exec -- ghc-pkg list
16:09:31 <f-a> thanks
16:10:00 <MarLinn> sm: I didn't know you could use stack outside of projects.
16:10:32 <sm> sure, it's useful for installing random tools to be always available 
16:11:29 <MarLinn> sm: I have always used cabal for that
16:12:17 <sm> I used to as well
16:12:59 <test> test
16:13:01 <test> hello
16:13:25 <Guest94213> i failed to identify in time
16:13:45 <f-a> Guest94213: type
16:13:51 <f-a> /nick some_nick_of_your_choice
16:14:13 <the_nick_of_my_c> are there really this many people in #haskell
16:14:23 <EvanR> no one here but us people
16:14:25 <f-a> now pick an appropriate nick of your choice :P
16:14:26 <the_nick_of_my_c> why is this room so popular
16:14:34 <MarLinn> sm: Which brings me to Recipe 2: Start a stack project with a resolver, including a local cabal. Update the global cabal to something newer than the one from the resolver. Result: the project can't be built anymore.
16:14:43 <the_nick_of_my_c> i see on the right there is like 200+ people
16:15:15 <f-a> 1438 to be precise the_nick_of_my_c 
16:15:27 <the_nick_of_my_c> is haskell really that popular
16:15:30 <sm> MarLinn: I haven't understood Recipe 1 yet.. were you modifying GHC's global pkg db ?
16:16:44 <MarLinn> sm: Does installing new global packages with system cabal count? Then yes.
16:17:23 <sm> if you did cabal install --global ..., that was the problem (easy mistake to make, really shouldn't be allowed)
16:18:28 <sm> it sounds like that's the issue in recipe 2 also ?
16:21:29 <MarLinn> sm: The funny thing is that --global works everywhere if you're a bit careful. Stack is the exception I found for some reason.
16:22:35 <sm> it is really not recommended, unless you like adventure :) but, I think if you told stack not to use your system GHC, you could keep doing it and they'd both be happy
16:24:38 <sm> good to know. I wondered why you were seeing such fragility
16:25:57 <MarLinn> sm: I got into the habit when I had little hard drive space and a slow connection. Sandboxing and 15 installations of everything tended to be a bit more pain than being careful about your db
16:26:55 <MarLinn> that's maybe the main drawback of stack, with the fragility only resulting from people like me trying to work around it
16:27:44 <MarLinn> Price of simplicity I guess...
16:27:48 <sm> how is it a stack drawback ?
16:28:47 <sm> if you were to report the issue, what would you say ?
16:29:28 <sm> I don't mean to argue, I'm interested in moving our tools forward
16:29:40 <ReinH> So Stack's main drawback is literally the thing Stack is designed to do?
16:29:49 <ReinH> I mean, if you don't like what Stack does, don't use it?
16:30:01 <maerwald> are you allowed to not use it these days? 
16:30:05 <maerwald> jk
16:30:26 <ReinH> If you want to put everything in your user db and deal with cabal hell, just do that?
16:30:39 <maerwald> or just use sandboxes, nix, docker containers, ....
16:30:52 <sm> eh.. getting derailed here :)
16:31:10 <maerwald> sm: hey
16:31:31 <sm> hey maerwald 
16:31:37 <MarLinn> ReinH: I tried, but Snoyman invented stack partly because he couldn't solve his Yesod built troubles in other ways (I think), so it's becoming progressively harder to built Yesod without Stack. Which is why I use Stack for Yesod, and nothing else
16:32:07 <maerwald> oh, do they not maintain the version bounds in their .cabal files?
16:32:18 <maerwald> that's basically the only thing causing the so-called "cabal hell"
16:32:29 <ReinH> maerwald: I mean no, it isn't.
16:32:31 <maerwald> then the version bounds are "out of sync", "outdated" or just wrong
16:32:32 <Cale> maerwald: It's a bit more than that.
16:32:40 <maerwald> s/then/when/
16:32:41 <ReinH> What causes cabal hell is *conflicting* bounds across multiple packages
16:33:00 <Cale> maerwald: The thing which causes cabal hell is when you have two *different* compiled instances of the same package-version combination.
16:33:25 <Cale> i.e. it's the same package and the same version, but compiled against different versioned dependencies
16:33:29 <maerwald> how do you manage to do that in sandboxes?
16:33:31 <Cale> and so it has a different hash
16:34:32 <ReinH> Package A depends on package C.1, package B depends on package C.2, you want to use both A and B together.
16:35:05 <Cale> Yeah, it's the diamond dependency problem.
16:35:15 <ReinH> That's the entire purpose of stackage: to make sure A and B don't have conflicting dependencies.
16:35:17 <MarLinn> sm: About your question: I wouldn't report it as an issue. Stacks approach is to throw resources at a problem, and that's what it's good at. Instead I'm still hoping that maybe, one day, we may find another solution. Like, say, a full package manager
16:35:44 <maerwald> ReinH: yeah, it's a depgraph problem and what I consider "out of sync" as explained above
16:35:51 <ReinH> It's not "out of sync"
16:36:00 <maerwald> yes thats what I call it
16:36:04 <ReinH> A and B are developed by different people, who have no reason to sync with each other
16:36:54 <ReinH> Admission into the stackage is what gives maintainers of A and B a reason to sync with each other.
16:36:58 <ReinH> s/the stackage/stackage
16:37:03 <sm> MarLinn: ok. But hopefully you no longer think "Just don't dare to use Stack when you have anything else Haskell-related installed. Stack is a diva." You were mucking around with its GHC
16:37:16 <maerwald> ReinH: I tend to fix those problems regardless, so I disagree
16:37:30 <ReinH> maerwald: That problem is, in general, unfixable
16:37:39 <ReinH> because there's also D which depends on C.3
16:37:45 <Cale> maerwald: Well, if you're willing to take responsibility for all your dependencies, that's one way to fix version hell.
16:37:49 <ReinH> now there's no version of A which works iwth both B and D
16:38:13 <maerwald> ReinH: I've been a distro dev for 4 years, so I know the dependency graph problems, yeah
16:38:28 <ReinH> So how do you "fix those problems"?
16:38:38 <Cale> But the real important thing is being able to reproduce a working situation on another computer.
16:38:41 <ReinH> Since those problems are unfixable unless something like Stackage exists to fix them.
16:39:07 <maerwald> ReinH: you can consider hackage a "rolling release distro" and stackage one with releases
16:39:09 <MarLinn> sm: I still think so for my system because stack is the exception to all rules there. ;) But thanks to you I now have a better understanding where that comes from
16:39:14 <ReinH> i.e., something that provides a central source of truth for version compatibility
16:39:15 <Cale> So that once you solve the issues *somehow*, they stay solved
16:39:23 <maerwald> ReinH: the one that "rolls" naturally has more breakage, including depgraph breakage
16:39:47 <ReinH> maerwald: You said "I tend to fix those problems", but the problem in question is impossible to fix.
16:39:59 <ReinH> as a maintainer of a package in the hackage ecosystem
16:40:04 <sm> ok. Just alias stack="stack --no-system-ghc" or something :)
16:40:26 <Cale> I've been using nix at work for a while now, and while I can't stand its configuration language, I really like the fact that it gives very reproducible builds by hashing everything.
16:41:16 <EvanR> it hashes all outputs of the build? or the build tools too
16:41:17 <nshepperd> when you're building everything fresh in a sandbox the usual problem is that the maintainer of some package didn't update their version bounds
16:41:22 <Cale> EvanR: The tools too.
16:41:23 <maerwald> ReinH: you're probably misinterpreting what I said. I fix depgraph breakage as I go "e.g. wrong base upper bounds" and other stuff
16:41:41 <maerwald> I never said that you can make sure latest hackage state is fully consistent
16:41:42 <MarLinn> sm: there's no way to use the system ghc without its db?
16:41:56 <nshepperd> package B *says *it depends on package C.2 but actually it works with everything from C.1 through 4
16:42:35 <chsn> so I'm writing a langauge taht is strict -- and then i realize -- damn -- lazy evaluation makes if then else so easy to implement
16:42:39 <sm> MarLinn: oh there probably is, with magic flags, but really life is too short
16:42:51 <f-a> is anyone here using library-profiling-detail?
16:42:54 * nshepperd would love some kind of buildbot that automatically updates version bounds to the maximal set with no type errors
16:43:01 <ReinH> nshepperd: Yes, but those *can* be fixed. The general problem can't be fixed without the ability to modify A, B, *and* D's dependency bounds.
16:43:02 <sm> you'll be in your own unique little world of breakage that noone else sees
16:43:09 <geekosaur> MarLinn, you need base at least, and it is hardwired into the system db
16:43:18 <f-a> and if so, should I turn it on by default (I do it w/ library-profiling)
16:43:41 <EvanR> how are you guys surmising to detect if an updated package is somehow not compatible with something
16:43:50 <geekosaur> (and hardwired into the compiler, along with some related packages like [iirc] ghc-prim and template-haskell)
16:44:18 <EvanR> not building is one thing, but surely things can build and still be broken
16:44:26 <MarLinn> sm, geekosaur: Ok, I'll choose a different small little world of breakages then ;)
16:44:32 <ReinH> EvanR: run your tests?
16:44:49 <EvanR> anticlimactic
16:44:50 <jle`> chsn: there are a lot of things we use everyday that surprisingly only work due to laziness
16:44:58 <jle`> in fact, almost all things, heh.  but some in surprising ways
16:45:22 <chsn> jle`: what is there besides if-then-else + patern matching + infinite lists ?
16:45:48 <jle`> translating BNF into parsers naively requires recursively infinite parsers
16:45:59 <jle`> infinitely recursive?
16:46:13 <jle`> when translating simple parsers in haskell to ocaml, you run into trouble
16:47:04 <jle`> also 'forever' creates an IO action with infinitely nested structure, and wouldn't make sense if the action was fully evaluated
16:47:19 <EvanR> chsn: many algorithms that are switched to eager evaluation suddenly get really inefficient, ones that you need an accumulating parameter for in something like javascript. but you still need these sometimes even in lazy, but not as often
16:47:44 <ReinH> laziness also makes dynamic programming almost trivial in many cases
16:47:52 <Cale> chsn: Even large finite lists :)
16:47:55 <ReinH> the most famous example is probably fibonacci
16:47:56 <jle`> and of course there's the fact that (.) and other higher order functions completely break their semantics without laziness
16:48:18 <MarLinn> Would it help resolve dependency hell if we had function-declaration-level version annotations? The idea is that some more bounds might be inferred that way.
16:48:36 <EvanR> jle`: you mean if you consider _|_?
16:48:46 <EvanR> you can get out of that if you just dont consider _|_ ;)
16:48:52 <ReinH> dynamic programming becomes lazily generating the entire value space and then evaluating the points you are interested in at need
16:49:00 <jle`> EvanR: i mean that composing simple functions become awfully unperformant
16:49:24 <ReinH> Look at something like take 5 . filter p . map f
16:49:40 <ReinH> even ignoring deforestation, the strict version of that has to evaluate the entire list twice from start to finish
16:49:48 <ReinH> the lazy version evaluates 5 elements once
16:50:03 <EvanR> oh... "performance semantics"
16:50:04 <jle`> (well, in that exmaple, potentially more than 5 ;))
16:50:08 <jle`> but i get your point
16:50:10 <EvanR> i wish we had those
16:50:17 <jle`> EvanR: well, map and take have semantics too
16:50:18 <ReinH> jle`: good point
16:50:33 <jle`> "as little as 5"
16:50:38 <ReinH> yep
16:50:58 <ReinH> also we get map f . map g = map (f . g) for free
16:51:19 <jle`> ah yes that's pretty nifty
16:51:31 <EvanR> a lot of list processing becomes more efficient for free
16:51:32 <ReinH> in strict languages you're unrolling that sort of thing everywhere and you totally lose modularity
16:51:57 <EvanR> than if written that way in say ruby
16:52:09 <ReinH> you're rewriting filter p . map f into a single for loop manually everywhere
16:52:11 <ReinH> it's awful
16:52:18 <jle`> preserving semantics in higher-order functions is really the main reason i am pro-laziness in the face of all of its potential complexities
16:52:19 <EvanR> you can also get the efficiency back by doing that
16:52:24 <EvanR> and being awful
16:52:31 <jle`> composability is a lie if you aren't lazy
16:52:34 <ReinH> EvanR: (ruby has lazy enumerables btw)
16:53:01 <EvanR> uh
16:53:10 <ReinH> not by default
16:53:10 <EvanR> it has something called Enumerable
16:53:15 <ReinH> Yes.
16:53:18 <EvanR> thats about it
16:53:26 <ReinH> Nope.
16:53:27 <ReinH> http://ruby-doc.org/core-2.0.0/Enumerator/Lazy.html
16:54:01 <EvanR> so that lets you do what
16:54:21 <EvanR> chunk map and filter
16:54:24 <ReinH> lazy_enum.map(&:f).filter(&:p) lazily
16:54:32 <ReinH> at need
16:54:33 <EvanR> no grouping
16:54:58 <EvanR> whatever it needs needs to be implemented inside the type, through monkey patching or something
16:55:23 <f-a> I do place upper bounds on dependencies, should I do the same on cabal-version: ? (and which lower bound should I put? the one I am building with?)
16:55:25 <EvanR> anyway yeah you can reimplement generators with lambdas in an eager language but its not nearly as nice
16:55:25 <ReinH> there's even a flat_map :D
16:56:15 <jle`> did they ever get flatmap for Option in java approved
16:56:27 <jle`> i remember the debate basically went, "flatmap would make Option a monad, and we don't want it to be a monad."
16:56:36 <sm> f-a: cabal-version >= 1.16 is common I think, and I've never seen an upper version on that
16:57:19 <sm> or >= 1.10 maybe. Try that I guess, it should warn if you use some newer syntax
16:57:29 <sm> maybe cabal check warns
16:57:32 <hpc> jle`: it's a monad if they want it to be or not though :(
16:57:40 <hpc> the java people can't even math
16:58:11 <f-a> I had 1.10 sm, I guess I'll flip a coin to decide whether to bump it to 1.16
16:58:21 <jle`> they just want to force people who want to use it as a monad to go through a lot of extra work
16:58:47 <jle`> its mapping function doesn't follow functor laws anyway, so it's probably already unsalvageable
17:00:59 <chsn> okay; i'm now convinced that strict evaluation makes no sense at all
17:01:14 <jle`> heh, you give things up/gain things either way
17:01:27 <chsn> what do you give up with laziness?
17:01:28 <jle`> both have their purpose :)
17:01:49 <jle`> reasoning with space complexity is significantly more complicated
17:01:52 <hpc> chsn: it's much easier to predict memory consumption under strict evaluation
17:01:59 <jle`> but also, some algorithms are just naturally strict algorithms
17:02:10 <jle`> and it wouldn't make any sense to implement them as lazy algorithms
17:02:24 <jle`> so it's really about picking the right evaluation semantics for different situations
17:02:44 <ReinH> (Many strict algorithms have lazy alternatives though)
17:03:25 <jle`> also some cases you don't get any gain from making things non-strict
17:03:40 <jle`> like the classic problem of the lazy sum on types like Int
17:04:01 <MarLinn> The one time I tried to use javas "functions" I almost immediately ran into stack overflows because of recursion. This has little to with strictness, but it shows once again that you can't just throw in new semantics without thinking about it.
17:05:08 <MarLinn> therefore I would be very suspicious of any glued-on laziness constructs
17:05:33 <jle`> are you as suspicious of glued-on strictness constructs? :)
17:06:27 <jle`> the argument in haskell usually isn't whether lazy is better than strict or not, but on what should be the default and what should be required to be specially annotated
17:08:23 <MarLinn> As far as I've read that's been a debate from before day zero.
17:08:36 <MarLinn>  So I'm quite certain that the strictness in Haskell is not glued on and that some people have actually thought about it
17:09:55 <MarLinn> Otherwise... Yeah, I would be suspicious. But then I've never seen a purely lazy language
17:23:05 * hackagebot linode-v4 0.1.0.2 - Haskell wrapper for the Linode v4 API  https://hackage.haskell.org/package/linode-v4-0.1.0.2 (eatonphil)
17:23:16 <hpc> currently the reasoning behind non-strict by default is that strictness is contagious
17:24:09 <hpc> so cases of forgetting to non-strict are more damaging than cases of forgetting to strict
17:24:16 <riaqn> Hi, anyone has idea why this program is printing all TCP traffic? https://github.com/riaqn/copy2gmail/blob/master/src/Main.hs
17:24:25 <hpc> in terms of how much code ends up behaving the wrong way
17:25:02 <riaqn> I've checked the constructor of connection and made sure there's no configuration I can do.
17:26:01 <hpc> riaqn: can you show a sample of what's printed?
17:26:03 <hpc> @lplaste
17:26:03 <lambdabot> Haskell pastebin: http://lpaste.net/
17:26:21 <hpc> my typing gets worse and worse...
17:28:24 <hpc> also what's your program's exit status?
17:28:46 <Welkin> hpc: what's your relationship status?
17:29:17 <hpc> heh
17:29:24 <hpc> in bash it's $?
17:36:36 <ReinH> riaqn: (as an aside, use OverloadedStrings so you don't have to call T.pack on every string literal)
17:38:51 <maerwald> ReinH: is ReinH_ a ghost? I just spammed him in -offtopic
17:39:07 <ReinH> maerwald: I'm in the middle of switching from weechat to irccloud atm
17:39:33 <maerwald> so you are not reading -offtopic right now?
17:39:43 <ReinH> Yep
17:39:46 <ReinH> I am reading it now
17:39:59 <ReinH> So nope. I am not not reading it.
17:46:10 <tr|ck> quit
17:50:19 <riaqn> ReinH: thanks for the tip.
17:54:22 <riaqn> hpc: http://lpaste.net/181422 
17:54:53 <riaqn> I suspect it's the imap library printing; since I don't see the traffic of authenticating with IMAP server.
18:33:07 * hackagebot linode-v4 0.1.0.3 - Haskell wrapper for the Linode v4 API  https://hackage.haskell.org/package/linode-v4-0.1.0.3 (eatonphil)
18:39:47 <chsn> where is the cheatsheet for https://commercialhaskell.github.io/intero/ ?
19:00:43 <Gues> Why are there so many ghc* directories in my /tmp directory? Are they from runhaskell?
19:01:15 <chsn> is there a way to implement typed sql tables in haskell?
19:01:23 <chsn> Is there a way to implement typed sql tables in Haskell?
19:01:30 <lambdaislove> yes!
19:01:33 <chsn> I need to be able to handle project
19:01:35 <chsn> lambdaislove: how so?
19:01:42 <chsn> it seems like projection 'creates new types'
19:01:49 <lambdaislove> https://wiki.haskell.org/Phantom_type
19:02:21 <lambdaislove> https://hackage.haskell.org/package/relational-query-0.5.0.1/docs/Database-Relational-Query-Expr.html
19:02:48 <pavonia> Gues: GHCi or cabal-install produces them too
19:02:51 <chsn> how is that typed ?
19:03:14 <lambdaislove> chsn: maybe I'm misunderstanding what you want. Could you clarify?
19:04:04 <lambdaislove> I assumed you meant that you wanted a system that allowed Haskell's type checker to type check sequal quries so you know they are somewhat valid
19:04:29 <lambdaislove> not multiplying a string by number kind of thing etc...
19:05:19 <lambdaislove> this whole library does what I assumed you to be asking about: https://hackage.haskell.org/package/relational-query-0.5.0.1
19:07:27 <Cale> chsn: It always takes a bunch of type hackery, plus either letting the Haskell library construct and maintain the table structure in your database, or vice versa, generating a bunch of Haskell code statically from what's in your DB.
19:07:38 <chsn> suppse I hve one table (hourlySalary :: Int, hoursWorked :: Int) .. and I wanted to creat ea new table (hourlyWage :: Int, hoursWorked :: Int, ttlEarned :: Int)
19:07:54 <chsn> Cale: is 'row types' planned any time soon for Haskell ?
19:08:03 <chsn> I'm surprised given our all type extensions we don't have row types.
19:08:08 <Cale> There's a bunch of shenanigans on the way
19:08:15 <Cale> which isn't really row types
19:08:39 <chsn> Cale: is 'row types' un haskell, or is it just no one has come along and implmeented it?
19:08:43 <lambdaislove> tuples are basically rows no?
19:09:27 <Cale> lambdaislove: *kinda*, and with enough typeclass hackery, you can implement a lot of the operations you might want on structures consisting of effectively nested pairs
19:10:06 <Cale> I really like the idea for row types used in Ermine
19:10:43 <chsn> https://github.com/ermine-language/ermine ?
19:10:49 <Cale> yes
19:11:12 <chsn> is there an 'ermine language tour' somehwere? I've heard the name quite a few times, but never got to see real programs in it
19:11:27 <Cale> https://www.youtube.com/watch?v=o3m2NkusI9k -- there's a talk here
19:11:28 <chsn> https://www.youtube.com/watch?v=o3m2NkusI9k <-- 'functional reporitng' also isn't particularly inspiring
19:11:32 <chsn> lol, same link
19:11:48 <Cale> Well, that's what they developed it for
19:12:05 <Cale> But the type system ideas are more interesting than the application imo :P
19:12:21 <chsn> http://nocandysw.com/ermine-user-guide/ermine-user-guide-usltr.pdf <-- is this the best thing to read ?
19:12:53 <Cale> It has constraints (in the style of type class constraints) of the form  a <- (b,c)  which means that the row a can be partitioned into b and c
19:13:03 <Cale> Probably, yeah
19:13:48 <Cale> So, for example, you can give the type of a database join like this:
19:14:13 <Cale> join :: (d <- (a,b), e <- (b,c), f <- (a,b,c)) => [..d] -> [..e] -> [..f]
19:15:47 <chsn> Cale: https://www.youtube.com/watch?v=QCvXlOCBe5A is also a horrible recording
19:15:48 <Cale> i.e. it takes a table whose columns can be partitioned into some disjoint parts a and b, and some table whose columns can be partitioned into disjoint parts b and c
19:15:52 <chsn> these ermine guys need to get a PR person
19:16:04 <Cale> and produces a table whose columns can be partitioned into disjoint parts a, b, c
19:16:11 <S11001001> chsn: the project isn't nearly big enough for that
19:16:38 <Cale> iirc, it's like approximately 1.5 people worked on it for a while
19:17:06 <chsn> yeah, but edwardk counts as 100 people
19:17:12 <Cale> lol
19:17:29 <Cale> But he was probably doing 99 other projects at the same time
19:18:09 <Cale> But the point is, it's a whole lot more elegant than lacks constraints
19:18:47 <chsn> every time I get to this point, I want to just go full dependent types
19:18:50 <Cale> and doesn't have the arbitrary choices made by e.g. the system Daan Leijen came up with and suggested for Haskell a long time ago
19:19:17 <Cale> Dependent types only help you so much -- you still need to write the library using them
19:19:33 <Cale> and decide what that library's conventions are going to be
19:20:47 <Cale> Also, I'm not sure how it works out in general -- certainly if you need to provide explicit witnesses to partitions and stuff and you can't get the language implementation to just auto-infer some things, it's going to be annoying.
19:21:19 <Cale> But there's probably a way to do it.
19:21:24 <alercah> Cale: is a partition necessarily an isomorphism?
19:23:47 <Cale> alercah: I'm not sure exactly what it would be an isomorphism between, but given a single row which can be partitioned, there's an isomorphism between the original row type and the product of rows of the row types it was partitioned into
19:41:27 <thoughtpolice> Cale: For Ur/Web, the compiler sort of does some magic heuristic inference for these cases, but really I think that's only because it can know/control both the schema of the tables and has language-integrated query, so it 'knows' when certain queries may give rise to a witness naturally. I think. It can automatically prove disjointness constraints, for
19:41:27 <thoughtpolice> example.
19:41:52 <zoran119> can a compiled haskell binary run natively on a linux machine, or does the machine need some kind of a haskell runtime installed?
19:42:12 <dmj`> zoran119: the runtime is linked into the binary
19:42:41 <Jenaf> hi! I have some noob question about creating datatypes
19:43:15 <zoran119> dmj`: cool, thanks
19:43:42 <Jenaf> I plan to write me a little program to make me pretty pictures; for that I need to represent lines and points;
19:43:46 <thoughtpolice> Cale: But it comes with a trade off - the types get incredibly verbose, but the value level language is fairly clean and doesn't need very many type annotations. It's a fairly different beast than Ermine all together but has some similar core ideas, so I feel automated construction of witnesses is *probably* pretty feasible in practice, especially if you
19:43:46 <thoughtpolice> restrict your domain just a tad.
19:44:25 <Cale> cool
19:44:46 <dmj`> Jenaf: sure, feel free to ask anything
19:44:48 <Jenaf> so without making my own types my code would propably look like foo::((Float,Float),(Float,Float))->((Float,Float),(Float,Float))  But it would be way better if I could use foo:: Line-> Line
19:44:50 <thoughtpolice> Really it's all sort of compounded by the fact the same mechanisms in the type language are used for metaprogramming, so you're rarely 'just' generating witnesses for constraints, but like, entire fragments of a program that can be abstracted over all sorts of stuff, like tables.
19:44:52 <Cale> Probably in a dependently typed language someone's eventually going to want some sort of crazy dependent telescope row types
19:45:07 <Cale> and then all hope is lost :D
19:45:11 <Jenaf> but I'm not sure how to write constructors and functions for types
19:45:30 <Jenaf> like floatPoint :: (float,float)
19:45:36 <thoughtpolice> But you can do stuff like, "I would like to take any set of tables WHICH DO NOT CONTAIN THE COLUMNS [User, Password, IsAdmin]" which is the disjointness constraint. You specify that as the signature of an ML functor.
19:45:43 <zoran119> Jenaf: type Point = (Int, Int)
19:45:52 <zoran119> Jenaf: type Line = (Point, Point)
19:46:02 <Cale> But man, it would be *so* cool to have a database whose rows were dependent records
19:46:17 <Jenaf> and then there is autamatically a constructor Line:: int -> int ->Point?
19:46:23 <Cale> So the types of later columns can depend on the values of previous ones
19:46:25 <thoughtpolice> Then you can pass in any SQL table, and it automatically checks the constraint and can construct the needed witnesses. I used this to add secure password management over any arbitrary 'user' sql table, using scrypt.
19:46:28 <Jenaf> ah brainfarted there
19:46:34 <thoughtpolice> Cale: Oh, that would be very interesting.
19:46:53 <zoran119> Jenaf: let p = (2,5)
19:47:15 <zoran119> addPoints :: Point -> Point -> Point
19:47:20 <Jenaf> yeah ofc it will be (Int,Int)->Point
19:47:29 <thoughtpolice> Cale: What does the 'telescopic' imply? This has a fairly specific DT meaning, doesn't it?
19:47:44 <Jenaf> can i make different constructors? Like with overloading in Java?
19:47:47 <zoran119> addPoints (x1,y1) (x2,y2) = (x1+x2,y1+y2)
19:48:14 <zoran119> Jenaf: sure, but it will be just a function which returns a Point
19:48:32 <zoran119> fromString :: String -> Point
19:48:51 <Jenaf> I'm thinking about likes
19:48:54 <Jenaf> *Lines
19:48:59 <zoran119> then you just call it like fromString "2,5" - but you have to implement that
19:49:07 <Jenaf> so i can either make a line from 2 points or from 4 coordinates
19:49:15 <zoran119> sure
19:49:23 <Cale> thoughtpolice: As far as I've seen, "telescope" is the term people use for the thing I described, where you have basically a nested dependent sum type, with types of later components depending on values of earlier ones
19:49:25 <zoran119> lineFromString :: String -> Line
19:49:38 <zoran119> as long as you can implement it
19:50:23 <Jenaf> ah I'll just play around with ghci a bit and ask more questions later when something is unclear
19:50:27 <Jenaf> thanks for the help so far!
19:50:42 <zoran119> Jenaf: np
20:01:47 <thoughtpolice> Cale: Ah, yes. de Bruijn defined it himself. Or IOWs, something like 'pi n :: Nat -> (pi xs :: Vec n t -> ...)' (handwavy syntax) and so on and so forth. Either way, some kind of dependent calculus like this for databases would be quite interesting.
20:03:05 <Cale> thoughtpolice: Though, in the mean time, I'll settle for something that has a good story for sum types :P
20:04:16 <Cale> The other thing I've really wanted lately is a database where my application can register a collection of queries, and any transaction which commits, it will efficiently determine how it affects the results of each of those queries and give me a diff.
20:05:18 <Cale> On top of that, we could build a lovely FRP layer :)
20:05:37 <Cale> Where you have a Dynamic query, and get back a Dynamic Map of results.
20:08:24 <radoye> hello! what's the preferred way to wrap IntMap to work with newtype Int. preferably without a lot of repetition and no runtime overhead?
20:08:24 <thoughtpolice> Cale: So, sort of almost like some kind of continuous materialized view, in a sense?
20:09:12 <Cale> thoughtpolice: yeah
20:10:32 <MarLinn> Cale: sounds to me like some kind of "darcs for databases"
20:10:58 <Cale> MarLinn: heh, that's a fun way to think about it
20:12:21 <Eduard_Munteanu> radoye, what newtype? Like newtype MyInt = MyInt Int ?
20:12:23 <Cale> radoye: I don't know of an approach which wouldn't involve just locally redefining the relevant parts of IntMap's interface.
20:12:56 <Cale> (or just exposing the newtype's data constructor)
20:13:24 <radoye> Eduard_Munteanu : yes, like `newtype NodeId = N Int` `newtype EdgeId = E Int` ... 
20:13:33 <radoye> i have a bunch of those to remind me what's what
20:13:50 <radoye> but need to keep them in maps with associated data ...
20:14:38 <radoye> Cale : I see ... that is annoying.
20:14:47 <MarLinn> radoye: Would it hurt a lot to turn the newtypes into types?
20:15:12 <Cale> radoye: Personally, I would usually just use Map
20:15:44 <radoye> MarLinn : TBD ... but i am trying to put ~10M elements in ... :) (or more, memory allowing)
20:15:58 <radoye> Cale : ok, so I guess I should profile both then ... 
20:16:39 <Cale> 10M elements sounds like about the point where maybe you're going to start caring about the difference
20:16:59 <Cale> But yeah, give it a try
20:17:06 <ania123> how can i create .hs file on windows machine?
20:17:06 <Cale> Map really isn't so bad
20:17:28 <Jenaf> interesting; with type Point = (Int,Int);type Vector = (Int,Int);foo::Point->Point->Point; a=(0,0)::Point;b=(0,0)::Vector; i get not error when doing foo a b
20:17:39 <Cale> ania123: Well, .hs files are just text files, named appropriately, and containing Haskell source.
20:17:44 <Jenaf> I had expected some type mismatch there
20:17:54 <Cale> ania123: So you typically get yourself a good programmer's text editor
20:17:55 <Jenaf> actually I hoped for it
20:18:08 <geekosaur> `type` is an alias, not a different type
20:18:13 <Cale> and you write your code, and just "Save as" foo.hs  or whatever.
20:18:18 <Jenaf> ahh
20:18:26 <geekosaur> `newtype` is what you want. newtype Point = Point Int Int
20:18:32 <Jenaf> kthy
20:18:32 <ania123> I have winedit, but it does not support to save in  .hs  format
20:19:36 <Cale> ania123: A text editor doesn't need to do anything special to "save in .hs format", you just need to name the file that way.
20:19:40 <Jenaf> do I get any noticable overhead when using type Point = (Int,Int) and fst/snd instead of making a new type with two fields?
20:19:41 <MarLinn> radoye: "wrapping the relevant parts"... maybe a few methods along the line updateIntMapWith :: (IntMap v -> IntMap v) -> WrappedIntMap v -> WrappedIntMap v could be enough?
20:21:13 <Cale> ania123: Well, it helps if it has an option to automatically convert tab characters to spaces for you
20:21:47 <radoye> MarLinn: I was thinking about that, and hoping that Data.Coerce would do most of the work
20:21:48 <Cale> ania123: Since you generally don't want actual tab characters in Haskell source code. Pretty much any decent text editor will have that feature though.
20:21:51 <MarLinn> Jenaf: Tuples are a type, too. So there should be no difference at all
20:22:16 <Jenaf> yeah I assumed that also, but I wasn't sure
20:22:25 <ania123> C:\Users\user\new-project>stack HelloWorld.hs ghc-7.10.3:   59.73 MiB / 128.40 MiB ( 46.52%) downloaded...
20:22:54 <MarLinn> Jenaf: If anything tuples are built-in so they might be faster, but I highly doubt that
20:22:55 <ania123> Cale: it is downloading smt?
20:23:01 <ania123> should I wait it?
20:23:10 <Jenaf> yeah ^.^
20:23:45 <Cale> ania123: Yeah, that looks like stack is downloading the Haskell compiler for you
20:23:59 <Cale> which it will do the first time you ask it to build something if it needs a version that you don't have
20:24:08 <ania123> https://haskell-lang.org/get-started/windows
20:24:16 <ania123> I have installed this alreay
20:24:28 <ania123> why it is downloading again?
20:25:02 <Cale> To be honest, I'm not sure, I haven't had the chance to use stack myself.
20:25:27 <ania123> how do you run haskell program then?
20:25:43 <ania123> are you windows user?
20:25:49 <Cale> I'm not a windows user
20:25:54 <ania123> ok
20:26:02 <Cale> But independently of platform, there are a few other tools for building Haskell projects
20:26:17 <ania123> what tools?
20:26:21 <Cale> In particular, there's a tool called cabal-install which is a bit of a competitor to stack
20:26:30 <ania123> could you recomend me easy one?
20:26:40 <Cale> and if you don't have a larger project, you can just install GHC directly and run it
20:26:55 <ania123> i have small projects
20:27:00 <ania123> i have installed 
20:27:20 <ania123> 1 Download Haskell Stack
20:27:20 <Cale> Some people recommend stack to beginners just because even though it's geared at coherent projects, it has these nice mechanisms to download and install the things you'll need for you.
20:27:37 <Cale> But it might do some repetitive downloading in some cases, I don't know.
20:28:01 <ania123> stack is kind of editor for haskell?
20:28:18 <MarLinn> ania123: stack is a kind of manager
20:28:41 <MarLinn> It manages a lot of the tools and libraries you might need for programming in Haskell
20:28:50 <Cale> Stack is a tool for compiling and installing the projects built with Haskell, and managing the library dependencies (getting them from remote servers, and installing them in a sandboxed environment so you have consistent versions of things)
20:28:50 <pavonia> ania123: You can run a Haskell program with "runghc Foo.hs"
20:29:04 <ania123> it works now
20:29:06 <ania123> stack HelloWorld.hs Hello World
20:29:18 <ania123> thanks...
20:45:01 <Jenaf> fLineRec :: fLine->[fLine]
20:45:02 <Jenaf> -- some recursion to define a fractal
20:45:04 <Jenaf> recurser:: Int -> [fLine]
20:45:06 <Jenaf> recurser 0     = fLineRec startLine
20:45:07 <Jenaf> recurser iters = nub $ concat $ map fLineRec $ recurser (iters-1)
20:45:09 <Jenaf> -- dat runtime ^.^ (in this case I guess that nub is gonna actually making it faster most of the time)
20:46:32 <solrize> http://lpaste.net/181449  any idea why this program is so slow?  it takes a couple seconds to run and the c++ version is like 100x faster.  i originally used regular list concatenation but thought that might make a quadratic factor, so i used that dlist-like trick but it didn't help
20:46:47 <solrize> it's the hofstadter figure sequence
20:47:42 <Jenaf> I'm a noob, too but why do you define your function in a do block?
20:47:55 <Jenaf> and without a signature? signatures are awesome
20:48:06 <c_wraith> solrize: looks like the issue is likely to be thunks
20:48:27 <c_wraith> solrize: I bet if you create a heap profile for that, it's triangular
20:48:41 <solrize> well there should be a thunk tree with (yy++) at the top, and then it pulls elements off the left
20:48:54 <solrize> hmm ok i should try the heap profiler, i've forgotten about stuff like that
20:48:56 <c_wraith> nothing ever forces the arithmetic until the printing
20:49:04 <c_wraith> so all the arithmetic expressions are unevaluated
20:49:49 <solrize> but that's ok, there should be only 10k of them, and the part that needs to be forced is next to the top of the tree in the left branch
20:49:57 <dmwit> Um, you are not using a dlist there.
20:49:58 <solrize> or at least thats what i thought the idea was
20:50:32 <dmwit> I don't think you can usefully use a dlist here, though, so it's not your fault.
20:50:33 <solrize> dmwit should there not be a tree with (yy ++ otherstuff) at the top?
20:50:35 <solrize> hmm
20:50:45 <dmwit> solrize: No, because you immediately apply it to `[]`.
20:50:54 <dmwit> dlists only win if you can realize them infrequently.
20:50:54 <solrize> hmm
20:51:10 <dmwit> Once per recursive call is ... not what I would call infrequent.
20:51:28 <ania123> Cale: factorial n = if n == 0 then 1 else n * factorial (n - 1)
20:51:36 <ania123> this program should compute factorial
20:51:41 <solrize> hmm i gotta think of some other way then... maybe the deque made with two lists where you reverse one of them when the other becomes empty
20:51:42 <dmwit> solrize: Consider using the poor man's functional queue, or a real queue implementation.
20:51:44 <ania123> and it is written in haskellis not
20:51:45 <ania123> ?
20:51:52 <dmwit> solrize: jinx =)
20:52:00 <solrize> heh :)  i guess that's the poor man's queue
20:52:19 <solrize> a lot of stuff is pushed onto this queue but only a few items are pulled off
20:53:37 <solrize> anyway i'll give that a try.... i didn't realize that issue about dlists  thanks
20:53:47 <MarLinn> ania123: Yes, that's Haskell
20:54:17 <ania123> MarLinn: I am getting following error message when I am compiling it
20:54:27 <ania123> fac.hs:1:53:     Not in scope: `main'     Perhaps you meant `min' (imported from Prelude)
20:55:02 <mauke> ania123: it's not a complete program; it's just a single function definition
20:55:18 <dmwit> ania123: Paste your entire file, and the command you run.
20:55:18 <Jenaf> escapes in Strings are like In C in haskell, right? or are there any pitfalls?
20:55:19 <dmwit> ?lpaste
20:55:19 <lambdabot> Haskell pastebin: http://lpaste.net/
20:55:20 <mauke> a program needs to define 'main'
20:55:37 <mauke> Jenaf: \123 is decimal, not octal
20:55:51 <Jenaf> thy
20:55:55 <ania123> http://pastebin.com/n9r2vSjw
20:56:02 <ania123> this is a programm
20:56:08 <mauke> Jenaf: there are string gaps but not \<newline>
20:56:22 <mauke> ania123: no, it's not
20:56:23 <ania123> >stack fac.hs
20:56:28 <mauke> ania123: a program needs to define 'main'
20:56:36 <ania123> mauke: aha
20:56:45 <ania123> could you point me a link
20:56:49 <mauke> ania123: for example, main = print (factorial 5)
20:56:50 <ania123> to see how programs are built
20:57:01 <boj> ania123: perhaps you want to try this in ghci? try "stack ghci" and enter your program there
20:57:22 <ania123> I what ghci means?
20:57:29 <glguy> I'd recommend not entering your program into ghci directly, but rather to save the program into a file and open that with ghci
20:57:33 <glguy> especially while learning
20:57:50 <mauke> ghci is an interactive interpreter
20:57:50 <boj> glguy: good point
20:57:52 <dmwit> ania123: I think this program is much too simple for stack to be more useful than confusing.
20:57:54 <mauke> a.k.a. REPL
20:58:04 <dmwit> ania123: I propose running `ghci fac.hs` instead of `stack fac.hs`.
20:58:29 <MarcelineVQ> ah, well, it's a stack script which is why you'd use stack fac.hs
20:58:36 <MarcelineVQ> that's what the `#!/usr/bin/env stack` is about
20:58:41 <dmwit> ania123: ghci is an interactive interpreter for Haskell
20:58:43 <ania123> >ghci fac.hs 'ghci' is not recognized as an internal or external command, operable program or batch file.
20:59:02 <geekosaur> they apparently have ghc etc. via stack
20:59:11 <ania123> dmwit: I am getting this error message
20:59:18 <boj> ania123: stack ghci fac.hs
20:59:31 <dmwit> ania123: Understood. In that case, you may like... yes, what boj said. =)
20:59:31 <glguy> ania123: You're going to be making your experience harder by using GHC via stack, you'll need to learn stack along the way of learning ghc
20:59:51 <ania123> stack ghci fac.hs Error parsing targets: Directory not found: fac.hs
21:00:07 <boj> note to self, don't suggest commands you don't use
21:00:17 <dmwit> It might be `stack exec ghci fac.hs`. I'm not sure -- I haven't used stack much.
21:00:33 <glguy> Most of us have actual full ghc installs
21:00:43 <geekosaur> 'stack ghci' works to get a repl, but probably doesn't transparently pass parameters
21:00:51 <geekosaur> you'd need stack exec ghci for that
21:00:59 <geekosaur> and probably need to say: stack exec -- ghci ...
21:01:10 <ania123> http://pastebin.com/0EPNvfpA
21:01:15 <geekosaur> (if anything in the ... starts with -)
21:01:36 <kadoban> ania123: glguy's opinion is not universal by any means. Using stack to get and use GHC is fine.
21:01:42 <ReinH> You might also read the stack manual
21:01:52 <dmwit> ania123: Your latest pastebin link doesn't work for me.
21:01:55 <ania123> glguy: I am a beginner
21:01:57 <geekosaur> pastebin now thinks you are a bit :/
21:01:59 <geekosaur> bot
21:02:04 <glguy> ania123: Yeah, that's the problem
21:02:09 <geekosaur> use something sane like lpaste
21:02:11 <geekosaur> @paste
21:02:11 <lambdabot> Haskell pastebin: http://lpaste.net/
21:02:13 <ania123> http://pastebin.com/0EPNvfpA
21:02:14 <dmwit> ania123: (It asks me if I am a bot, and when I assert that I am not one, it agrees but does nothing further interesting.)
21:02:58 <ania123> glguy: I am a beginner, so I need to rund some simple projects and hence I need to use an intepreter as easy as possible
21:03:03 <ania123> what do you recomend?
21:03:09 <mauke> pastebin.com is just terrible
21:03:11 <glguy> ania123: Right, that's why it would be better if you could run ghci directly
21:03:38 <dmwit> ania123: You can download and install the latest GHC from its website. Then `ghci yourfile.hs` will work for the easy stuff.
21:03:57 <ania123> glguy: could you please give me a link where is a discribed how to use ghci directly?
21:04:12 <ania123> dmwit:
21:04:15 <ania123> dmwit: thx
21:04:25 <kadoban> ania123: You can just do 'stack ghci' and then :load yourfile.hs  . When you make changes to it, you can reload it.
21:04:26 <dmwit> ania123: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html I guess
21:05:08 <ania123> I have downloaded https://haskell-lang.org/get-started/windows
21:05:18 <ania123> should I uninstall it
21:05:19 <ania123> ?
21:05:23 <kadoban> ania123: Using stack doesn't particularly make really basic GHCi usage easier, but it'll be nicer once you're using dependencies and such.
21:05:34 <dmwit> There is no need to uninstall stack.
21:05:40 <glguy> ania123: You can start with the minimal installer, it will give you a GHC install, and comes with stack, so you won't be left out if you need it later https://www.haskell.org/platform/windows.html
21:06:25 <dmwit> Okay. I am definitely one chef too many. I will bow out.
21:06:45 <ania123> glguy: would not be it better to install full? because in a future maybe i will need more advance?
21:07:09 <glguy> ania123: No, if you need more libraries later they can be installed, no need to worry about that
21:07:19 <ania123> ok
21:08:23 <ania123> glguy: I am downloading... it is 200 mb
21:08:45 <glguy> Well... minimal is relative to the Haskell ecosystem :)
21:08:54 <ania123> ok :)
21:09:43 <ania123> glguy: is there an editor to avoid using shell to run haskell programs
21:09:44 <ania123> ?
21:10:46 <dmwit> I think the Windows build of GHC comes with a second variant of ghci tuned to the Windows GUI.
21:11:04 <dmwit> But you will probably want to get comfortable with the shell.
21:11:07 <glguy> I don't know what the state of Haskell editor integration is on Windows. A common workflow is to have your file loaded in GHCi in one window and edit it in another using the :r reload command after you save
21:11:50 <glguy> There are some fancier tools but I believe that they take some amount of effort to get set up. Maybe someone else can speak up if they have a favorite Windows editor/ haskell integration story
21:14:50 <ania123> during instalation of ghci it asks me whether I want to be stack included. Since I have stack already installed, I think I should not select it to be included. is not?
21:15:27 <glguy> Yeah, you already have it
21:15:31 <pavonia> What glguy just described is basically what I usually do, editing files in Notepad++, testing them in GHCi, and building the whole package using cabal-install in another shell
21:16:10 <pavonia> Pretty simple workflow but works great for me
21:17:59 <glguy> My Haskell programming setup is my irc window, shell for building/repl, editor :)
21:19:13 <MarLinn> Jenaf: Sorry, I had a bit of fun... recurser n = foldl (.) id (replicate n $ nub . concatMap fLineRec) startLine -- not tested, esp. for off-by-one errors
21:19:49 <Jenaf> oh 
21:20:04 <glguy> http://imgur.com/a/LCDtk
21:20:37 <Jenaf> what does id do?
21:21:03 <glguy> returns the value it's applied to
21:21:09 <ReinH> id x = x
21:21:26 <Jenaf> ah
21:21:45 <Jenaf> I haven't fully grapsed that line yet, but foldl1?
21:21:53 <MarLinn> Jenaf: It should be not too different, performance-wise. It's just that whenever I see explicit recursion I get an urge to get it away ;)
21:22:19 <Jenaf> does it make much difference?
21:22:52 <Jenaf> btw: mine is end recurive because the recursion call is typed right in the end! ;)
21:24:00 <ania123> glguy: may I pm you?
21:24:15 <nitrix> Jenaf: It's mostly limitations. You can't represent all recursion schemes with Foldable. It's great by itself for simplistic "accumulator"-based work, but for anything more complex (look-ahead and whatnot), you do need explicit recursion.
21:24:52 <nitrix> Jenaf: That's how we end up with crazy general recursion schemes like zygohistomorphic prepromorphism.
21:24:55 <glguy> If it's a question for me, sure. If it's a question about Haskell it would be better to chat about it here
21:25:23 <ania123> it is question about haskell, how to use a compiler u recomended me...
21:25:25 <Jenaf> zygohistomorphic prepromorphism. <- is this two real words?
21:25:26 <MarLinn> I guess it's mostly a way to train my brain to think about different forms of recursion. foldr vs scanr vs mapAccumR etc
21:25:51 <nitrix> Jenaf: They are; but they're also mainly a joke.
21:25:57 <Jenaf> ah
21:26:03 <ania123> http://pastebin.com/f0U6Qx9N
21:26:09 <ania123> glguy: http://pastebin.com/f0U6Qx9N
21:26:21 <nitrix> Jenaf: Zygo, histo, prepro refer to real concepts, but it's not very practical as a whole.
21:26:24 <glguy> yay, it opened
21:26:36 <glguy> ania123: You can load your Haskell file with :load FILENAME
21:26:39 <shergill-web> Cale: ping
21:26:47 <Jenaf> well... I'm actually a fan of readability; I am biased but I assume mone is more readble; (but eh.. everyone thinks that of their own code)
21:26:53 <Jenaf> *mine
21:27:15 <ania123> glguy: do i need to point whole path of program?
21:27:16 <glguy> ania123: Or by specifying the filename when opening ghci: ghci FILE.hs
21:27:45 <Jenaf> MarLinn: I still don't get why you need the identity function in there
21:27:51 <glguy> ania123: Also check your context menu, it's possible that Windows might support opening a haskell file with GHCi (worth checking)
21:29:11 <ania123> glguy: http://pastebin.com/AuAqHP2E
21:29:14 <MarLinn> Jenaf: Yeah, yours is indeed more readable. And yes, foldl1 would work, but fails on n==0
21:29:44 <Jenaf> ahh
21:29:45 <glguy> ania123: great! so now you can do things like check the types of things:  :t factorial
21:29:54 <glguy> ania123: try evaluating things:   factorial 10
21:30:03 <MarLinn> Jenaf: Also I have composition = foldl (<<<) id somewhere in my library, which makes it a bit more readable again ;)
21:30:07 <glguy> If you change the file you can reload with :r
21:30:17 <ania123> glguy: :t factorial
21:30:21 <ania123> what this does?
21:30:22 <Jenaf> ah
21:30:58 <glguy> ania123: If you have factorial defined in your fac.hs, it will print the type of your factorial
21:31:00 <Jenaf> MarLinn you just made my head click again about an important concept of functional programming
21:31:24 <MarLinn> nitrix: I *think* I used an apomorphism once in a "real" program ;)
21:32:07 <MarLinn> Jenaf: Oh? Which one? The less readable the code, the more street-cred? XD
21:32:24 <ania123> glguy: great! thank you for your help
21:32:25 <Jenaf> nope; lists of functions; 
21:32:32 <MarLinn> Ah ^^
21:32:34 <Jenaf> aka functions are data ... 
21:32:50 <Jenaf> thats kinda the very basic of functional programming
21:32:51 <joe9> need some architecture advice, please? I get streaming market data. There are some markets I like (mostly around 2-3). Each market can have 2 participants. I have a gtk app to show the chart for each participant. The streaming market data can get a message every 100 ms at busy times. This is all in haskell. I am not sure if I should mix the gtk part with the streaming code. If I have them as 2 separate applications, I am not sure what
21:32:51 <joe9> would be the way of communication between these 2 processes (sockets?). If I have them both together, then I can use a TChan for communication. but, as the gtk windows can be created or destroyed independent of each other, it does not seem like a good idea. Any suggestions , please?
21:33:31 <glguy> ania123: Now that you're able to open GHCi, it might be worth looking at something like http://learnyouahaskell.com/starting-out to see what kinds of things you can do if you don't already have a tutorial that you're following
21:34:09 <Jenaf> MarLinn: how would an obtimizing compiler handle both codes?
21:34:20 <ania123> many thanks
21:34:30 <ania123> I will start today....
21:35:03 <Jenaf> would there be any difference in detecting potential possibilities for tail-recursion to save stack space?
21:35:25 <Jenaf> <- has no clue about how much obtimization haskell compilers really do
21:35:57 <peddie> joe9: you could use a messaging system like zeromq to make the streaming data available to UI clients
21:36:02 <MarLinn> that's a good question...
21:36:06 <mauke> Jenaf: haskell doesn't use a call stack
21:36:09 <Jenaf> but also on the other hand: recursion overhead is nothing to worry about in that case ...
21:36:09 <geekosaur> the stack doesn't work the same way in ghc
21:37:03 <Jenaf> mauke: but it should use something wich represents simillar functionality
21:37:08 <mauke> Jenaf: no
21:37:22 <geekosaur> there is a pattern matching stack that is used when a pattern match has to force another computation. but functions aren't "called", they get jumped to. (beyond that, read the STG paper to find out what really happens. it's graph reduction, not call/return)
21:38:10 <Jenaf> but if you jump to a function, you need to remember where to jump back
21:38:34 <Jenaf> and in tail-recursion you can save the effort of storing al back-jumps because you need only one.
21:38:40 <geekosaur> no, only if you are doing procedural execution do you need that
21:38:50 <mauke> no
21:38:56 <geekosaur> if you are building a graph, you are not following control flow at all excet in the structure of the graph
21:39:09 <geekosaur> you are not *executing* according to the control flow
21:39:36 <Jenaf> link to the STG paper?
21:39:42 <geekosaur> @where stg
21:39:42 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
21:39:53 <ReinH> @google eval apply stg
21:39:54 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode
21:39:59 <ReinH> Eh
21:40:20 <ReinH> Not bad Google, not bad
21:40:44 <geekosaur> this does take some getting used to; it's completely different from what people expect
21:41:04 <ReinH> conal: o/
21:41:38 <conal> ReinH: \o
21:41:53 <glguy> oh man, you just broke a 21 day silence streak
21:42:01 <geekosaur> (also it makes debugging remarkably difficult sometimes; ghc8 added a "call stack" which is more or less a traceback of how you got a particular piece of data, not an actual call_ stack
21:42:14 <joe9> peddie: are there any other alternatives to zeromq? shared memory?
21:42:15 <Jenaf> weeeee that paper has black holes
21:42:18 <geekosaur> because there's no call stack to actually show
21:42:19 <shachaf> glguy: Does your IRC client give you these fun facts?
21:42:22 <glguy> Oh, no. I subtracted the month from the day...
21:42:30 <glguy> shachaf: No, if it did I might have been right
21:42:54 <glguy> It was actually ~14 :)
21:43:13 * hackagebot namespace 0.1.2.1 - A Generic Haskell library for managing namespaces  https://hackage.haskell.org/package/namespace-0.1.2.1 (xuhao)
21:43:27 * glguy goes off to write a fun facts command
21:44:18 <peddie> joe9: you could use shared memory instead, but . . . why?  you specified it's all in haskell, and there is already a nice zmq library on hackage :)
21:48:22 <MarLinn> Let's say a compiler had graphical output. Which structure would it present to the user instead of a call stack? A graph of partly evaluated thunks?
21:49:06 <MarLinn> s/call stack/"call stack"
21:49:12 <ReinH> Runtime, not compiler
21:49:28 <MarLinn> Ok. Yeah.
21:49:45 <geekosaur> HasCallstack in ghc8 is essentially a trace of the nodes in the graph from the root to the node where the error occurred. if you had graphical output, it might dump the graph with the visited nodes and followed edges highlighted
21:50:03 <geekosaur> and possibly show where reduction had already occurred
21:50:12 <chsn> is there any screencast showing how to use emacs with intero ?
21:52:16 <geekosaur> that said, with graphical output you might get something well-nigh unreadable; I've seen some highly unfortunate generated representations of trees with many branches...
21:54:24 <MarLinn> geekosaur: Yeah, graph- (or even tree-) layout can be really hard to adapt to a use case...
21:55:19 <MarLinn> And I assume even if one found a way, adding that to ghc might not be the best idea with all the dependencies one would need
21:55:58 <Jenaf> foldl1(.)  [(foo.bar),(foo.bar)]==(foo.bar).(foo.bar) right?
21:56:35 <MarLinn> yes
21:56:38 <Jenaf> kthy
21:59:09 <geekosaur> in theory it could dump a machine readable version of the graph and a postprocessor could produce the human viewable version. compare hp2ps to decipher heap profiling output
22:01:01 <geekosaur> the biggest problem might be that the current implementation of HasCallstack is designed to minimize the number of nodes that remember their origin, for performance reasons. for a full graph, you'd have to throw that out and always annotate every node
22:02:00 <ReinH> Jenaf: no need to use foldl1, that's why id was used.
22:02:17 <ReinH> So your function doesn't cause a runtime error with the empty list
22:04:09 <dmwit> Also, why foldl instead of foldr?
22:04:29 <MarLinn> geekosaur: I suppose there would be nothing else that needs to remember that much? E.g. Profiling will do it's best to stay out of everyone's way, too...
22:05:08 <geekosaur> profiling does its best but still incurs a fairly high cost. which is why HasCallstack tries to minimize that cost
22:05:43 <jle`> foldr is a bit more natural for composing functions
22:06:10 <geekosaur> (before HasCallstack, you could indeed get something similar by building with profiling and running with +RTS -xc. but the performance penalty was very noticeable)
22:09:25 <MarLinn> So if one were to add such a feature it would only be useful in the most desperate of situations. Or for learning about the execution, maybe
22:13:14 * hackagebot namespace 0.1.2.2 - A Generic Haskell library for managing namespaces  https://hackage.haskell.org/package/namespace-0.1.2.2 (xuhao)
22:18:46 <Jenaf> is there any difference between foo.bar var and foo $ bar var ?
22:18:54 <ReinH> Yes.
22:19:17 <Jenaf> any difference in "execution"?
22:19:21 <ReinH> The former is foo . (bar var)
22:19:36 <ReinH> The latter is foo (bar var)
22:19:46 <ReinH> They are entirely different
22:20:01 <Jenaf> oh 
22:20:02 <glguy> Jenaf: GHC isn't persuaded by your putting foo and bar so close to the . :)
22:20:08 <ReinH> Function application binds more tightly than anything else.
22:20:30 <Jenaf> (foo.bar) val and foo $ bar var is what I ment
22:20:42 <ReinH> Then Jo.
22:20:45 <ReinH> No.
22:20:52 <Jenaf> kthy
22:21:07 <glguy> Jenaf: Both (.) and ($) will inline and those two will become the same: foo (bar var)
22:21:19 <ReinH> Or foo . bar $ var
22:21:41 <gestone> hello all, i was wondering if you guys knew a way to map elements and then insert them into a hashmap
22:22:06 <ReinH> Map then fold?
22:22:21 <gestone> so like map id [1..5] would result in a hashmap looking like {1 : 1, 2 : 2, 3 : 3, 4 : 4, 5 : 5}
22:22:22 <Jenaf> what is the more common style: foo $ bar $ baz var or foo.bar.baz $ var?
22:22:42 <ReinH> Many people prefer the latter
22:22:55 <Jenaf> kthy
22:22:56 <glguy> Jenaf: don't discount the simple: foo (bar baz)
22:23:10 <gestone> yeah i was thinking about map and then fold, but if i map, i'll lose the key
22:23:24 <Jenaf> foo (bar (baz var)))
22:23:31 <Jenaf> parens, yay
22:23:42 <glguy> Yeah, but only with as many ) as (
22:23:43 <gestone> or i could map one list, zip them up and then fold...
22:23:52 <gestone> but that seems a little messy
22:23:56 <Jenaf> (((foo (bar (baz var)))))
22:23:58 <Jenaf> better?
22:24:04 <MarLinn> gestone: maybe something like foldMap (singleton . f)
22:24:04 <jle`> Jenaf: (foo.bar.baz) var is nicer because it's like, (foo.bar.baz) is a thing
22:24:10 <glguy> Yup, you fixed it
22:24:11 <jle`> that you can pull out and name, or reason with
22:24:24 <ReinH> gestone: use fanout f g x = (f x, g x) and fanout id yourFunc
22:24:30 <jle`> like you're applying (foo . bar . baz), the function, to var
22:24:41 <ReinH> Fanout exists in arrow as (&&&) iirc
22:24:54 <ReinH> It's a common combinator for such things
22:25:14 <Jenaf> yeah, but shouldn't a compiler be able to handle that anyway?
22:25:22 <gestone> ReinH: oh, are there examples of usage anywhere on this?
22:25:22 <jle`> Jenaf: it's mostly for readability
22:25:26 <jle`> and reasoning with your code
22:25:29 <pkmx> > Data.HashMap.Strict.fromList [ (i, i * 2) | i <- [0..5] ]
22:25:32 <ReinH> Jenaf: it's for humans
22:25:34 <lambdabot>  error:
22:25:34 <lambdabot>      Not in scope: ‘Data.HashMap.Strict.fromList’
22:25:34 <lambdabot>      No module named ‘Data.HashMap.Strict’ is imported.
22:25:39 <Jenaf> <- holds firm believes in magic haskell compilers
22:25:54 <jle`> it all compiles to the same thing, of course
22:25:55 <ReinH> We write code for other humans too
22:26:06 <gestone> pkmx: oh interesting, i hadn't thought of using a list comprehension
22:26:08 <jle`> but one is nicer to work with and reason with, refactor, understand, read, etc.
22:26:12 <jle`> as a human being :)
22:26:13 <ReinH> And for our future selves
22:26:16 <gestone> MarLinn: how would that work?
22:26:18 <Jenaf> ReinH thats why I asked the question in the beginning ^.^
22:26:55 <Jenaf> I could start writing code my own style, but adaption to the common conventions is a good thing I guess
22:26:56 <ReinH> fromList . fanout id f
22:27:15 <pkmx> gestone: yeah, list comprehension is infinitely more readable than zip or (&&&) id
22:27:43 <MarLinn> gestone: the idea is to create one hashmap per value and then combine them through their monoid instance
22:28:05 <ReinH> Jenaf: I recommend reading good Haskell code. Jekor (Chris Forno) has a series on YouTube where he walks through code of popular Haskell libs.
22:28:26 <ReinH> pkmx: disagree
22:29:21 <ReinH> I prefer fanout to (&&&), but fanout and zip are easy to read.
22:29:35 <ReinH> And very idiomatic
22:29:43 <gestone> why isn't (&&&) just called fanout?
22:30:13 <ReinH> Because in the Arrow universe it's used as an operator and has some other similar operators
22:30:26 <piyush-kurur>  pkmx: list comprehension is like loops where as one can build "pipelines" of functions which are more readable using zips, folds and maps.
22:30:46 <ReinH> You'll see Richard Bird use fanout frequently, for example
22:30:50 <piyush-kurur> with experience the latter starts becomming more readable
22:31:04 <Jenaf> concat.map==concatMap?
22:31:10 <ReinH> Yes
22:31:13 <Jenaf> thy
22:31:22 <jle`> not exactly but close enough :)
22:31:30 <jle`> concatMap f = concat . map f
22:31:33 <gestone> ReinH: so i would do something along the lines of (fromList . (id &&& [1..5])?
22:31:34 <ReinH> You can also look these things up on Google and view their source
22:31:57 <gestone> MarLinn: would that be expensive to create a new hashmap for each k,v pair?
22:32:07 <ongy> :t fanout
22:32:08 <glguy> pkmx: I agree with you, at least that the list comprehsion solution is the most direct and readable in this case
22:32:08 <lambdabot> error: Variable not in scope: fanout
22:32:16 <systemfault> What is "fanout"?
22:32:24 <systemfault> It's not on hoogle
22:32:27 <gestone> :t (&&&)
22:32:29 <MarLinn> gestone: probably, sadly.
22:32:29 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
22:32:39 <gestone> ^ is fanout
22:32:40 <jle`> fanout f g x = (f x, g x)
22:32:56 <jle`> :t \f g x -> (f x, g x)
22:32:58 <lambdabot> (t2 -> t) -> (t2 -> t1) -> t2 -> (t, t1)
22:33:03 <ReinH> gestone: mappify = fromList . fanout id id; mappify [1..5]
22:33:08 <systemfault> Hmm, is there an applicative that does similar?
22:33:26 <jle`> you can implement it using Applicative combinators yes
22:33:42 <jle`> :t \f g -> liftA2 (,) f g
22:33:44 <lambdabot> Applicative f => f a -> f b -> f (a, b)
22:34:04 <jle`> um wait
22:34:08 <jle`> yea
22:34:19 <ReinH> With the function instance
22:35:07 <MarLinn> You could even argue that liftA2 (,) is the "more natural" version of <*> from a mathematical standpoint
22:35:53 <MarLinn> And Applicatives and Arrows seem to be closely related, somehow, but I have found no one how knew any details
22:36:06 <mauke> :t liftA2 ask
22:36:08 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
22:36:44 <systemfault> ask being id, right?
22:36:58 * systemfault is slowly getting it
22:39:37 <Eduard_Munteanu> :t ask
22:39:38 <lambdabot> MonadReader r m => m r
22:41:07 <mauke> :t [id, ($), ask, asks, fmap fix return]
22:41:08 <lambdabot> [(a -> a1) -> a -> a1]
22:47:24 <gestone> so does anyone have any great gems of haskell code that i could learn from?
22:47:40 <gestone> i stumbled upon xmonad, but understanding the source is a little dense
22:48:28 <glguy> gestone: You might be interested in poking around my IRC client, depending on what kinds of programs you're interested in
22:48:43 <glguy> you can change it and see what happens without having to restart your window manager :)
22:48:48 <zugz_> Anything problematic/evil with using System.Environment (getEnv,setEnv) to do https://wiki.haskell.org/Top_level_mutable_state ? Seems less hacky to me than unsafePerformIO, and at least in the common case of a global configuration (e.g. set on the command line, to be used deep in the code) not to be a hack at all
22:49:09 <gestone> glguy: ohh interesting, is the source on github?
22:49:38 <glguy> gestone: Yeah https://hackage.haskell.org/package/glirc https://github.com/glguy/irc-core
22:49:47 <solrize> dmwit, i'm thinking the poor man's functional queue isn't the right thing because it has to force the whole list when it reverses it.. the list is mostly concatenated ranges (enumFromTo a b) which can be quite long so it's better if they stay lazy.  i guess i can represent them explicitly as pairs of bounds but at some point the code is uglier than the c++ version
22:50:21 <gestone> glguy: ohhh that's awesome! i'll take a look at it
22:51:14 <mahdi> hey, I want to do some computation inside a thread (forkIO) which returns a Monad that's not IO, I'm wondering how can I make it an IO? (btw it's a ConduitM)
22:52:28 <Jenaf> If I got a float, how can I get a string with its "normal" representation (like 123.4567) ?
22:52:56 <liste> mahdi: what's the base monad for that ConduitM ? or is it left abstract
22:53:03 <johnw> mahdi: do you mean, you are in ConduitM, and you want to use forkIO to fork another ConduitM action?
22:53:08 <glguy> > Numeric.showFFloat Nothing 123.4567 ""
22:53:10 <lambdabot>  "123.4567"
22:54:21 <Jenaf> what do I need to import to use showFFloat?
22:54:23 <lpaste> mahdi pasted “conduitM, IO” at http://lpaste.net/181474
22:54:33 <mauke> @index showFFloat
22:54:34 <lambdabot> Numeric
22:54:46 <glguy> gestone: you can build documentation for the client with : cabal haddock --executables
22:54:56 <Jenaf> ah
22:54:58 <glguy> which should help navigate things
22:55:05 <mahdi> liste: pasted the error above ^ and here is Flush: http://hackage.haskell.org/package/conduit-1.2.7/docs/Data-Conduit.html#v:Flush
22:55:22 <gestone> glguy: oh excellent
22:55:25 <glguy> I've tried to include a lot of comments
22:55:41 <Jenaf> what does the maybe Int in showFFloat do?
22:55:58 <Jenaf> number of digits after the decimal point?
22:56:11 <gestone> glguy: ah i see there's some C in here as well
22:56:18 <mahdi> johnw: um, not exactly. I'm in a HandlerT, and I want to do a `liftIO $ forkIO` which works if everything is an IO inside my fork
22:56:39 <johnw> mahdi: you could try "liftBaseDiscard forkIO $ do ..." from monad-control
22:57:02 <johnw> not sure if HandlerT has a MonadBaseControl instance, but it might
22:57:27 <glguy> gestone: yeah, it has aC extension API that I use a provide Lua scripting
22:57:31 <mahdi> johnw: oh, let me test it, thanks btw
23:07:00 <ReinH> zugz_: if you can use those you can just use an IORef
23:07:38 <ReinH> Instead of wanting top level immutable state, try not wanting it instead
23:08:30 <lpaste> mahdi pasted “MonadBaseControl” at http://lpaste.net/4303773503670190080
23:08:40 <zugz_> ReinH: an IORef with the unsafePerformIO hack, you mean? The problem with that is it's a hack ;)
23:08:52 <johnw> right, ConduitM for certain doesn't have a MonadBaseControl instance, nor can it
23:08:55 <johnw> so that won't work
23:08:57 <mahdi> johnw: johnw: it seems it's not an instance of MonadBaseControl 
23:09:36 <mahdi> johnw: here is the code, might give you a better idea of what's going on: https://github.com/mdibaiee/yesod-proxy/blob/master/app/Main.hs#L93
23:11:50 <ReinH> zugz_: your suggestion is no different
23:12:14 <ReinH> Still requires unsafePerformIO, plus you lose all type safety
23:12:28 <ReinH> Just don't want top level immutable state.
23:12:59 <ReinH> And you won't need ugly, unsafe hacks to achieve it
23:13:40 <zugz_> ReinH: why would it need unsafePerformIO? I mean to have conf :: IO () which uses setEnv, then somewhere else guaranteed to run later getConf :: IO a using getEnv
23:14:12 <zugz_> I'm not saying it's nice... I was just surprised not to see it listed as a possibility at https://wiki.haskell.org/Top_level_mutable_state
23:14:41 <Jenaf> I really get confused with indentation rules in haskell
23:14:44 <zugz_> but for the special case of setting conf on the commandline, it seems quite acceptable - using environment variables to set configuration is a venerable tradition, after all
23:14:51 <Jenaf> so I want to put together a long string
23:14:53 <Jenaf> https://gist.github.com/anonymous/4033b8bb6c230b6152a09494ece96f50
23:15:06 <Jenaf> how to correctly do this without one crazy long line?
23:15:19 <ReinH> You still don't need unsafePerformIO
23:15:40 <Jenaf> and yes i forgot to close the strings in the end *facepalmÜ
23:15:52 <srhb> Jenaf: I would just de-indent a lot and leave nothing on the first line
23:17:04 <srhb> Jenaf: It also looks like you would benefit from a helper function a la foo s = "\"" ++ s ++ "\""
23:17:38 <srhb> (Call it escaped, say...)
23:17:47 <Jenaf> hm...
23:18:01 <Jenaf> https://gist.github.com/anonymous/c6cab56214b48ee67278500b4f32a138
23:18:06 <Jenaf> wold the third thingy work?
23:18:13 <srhb> Jenaf: Sure.
23:18:22 <Jenaf> kthy
23:18:29 <srhb> Jenaf: There's a short wikibooks article on indentation rules.
23:18:59 <Jenaf> https://en.wikibooks.org/wiki/Haskell/Indentation this one?
23:19:04 <srhb> Yep.
23:19:13 <Jenaf> that did not completely help me
23:19:21 <saurabhnanda> ===> w00t! merged into round 13 -- https://github.com/TechEmpower/FrameworkBenchmarks/pull/2247
23:21:13 <Jenaf> now i only hope i got the svg right XD
23:21:35 <srhb> Jenaf: Well, might reread and practice a bit. Making Haskell pretty is very nice because of those rules :-)
23:22:06 <Jenaf> yeah 
23:22:18 <Jenaf> no doubt about that ^.^
23:22:48 <srhb> Jenaf: Here's a simple idea: http://lpaste.net/2413960414229430272
23:24:06 <Jenaf> huh? i thought that the different indentation between ines 2 and 3 would mess things up?
23:24:12 <Jenaf> *Lines
23:24:23 <srhb> Jenaf: Why did you think that?
23:24:37 <srhb> There's no layout herald.
23:25:11 <Jenaf> srhb: bacause https://en.wikibooks.org/wiki/Haskell/Indentation
23:25:17 <Jenaf> *because
23:25:22 <Jenaf> need cofee brb
23:26:04 <geekosaur> line 2 does not introduce new layout; only line 1 does
23:26:15 <geekosaur> so the only relevant rule is that everything be further indented than line 1 is
23:28:10 <MarLinn> Man... Now my brain interprets "cofee" as a typo of "cofree" before considering "coffee"...
23:28:12 <geekosaur> it's only when you have something that introduces layout (mostly: let, case, do, or a new binding at top level or inside let or do, or [I think] a new pattern in case) that you need to be stricter about what follows --- specifically that what follows must be more indented to remain part of it
23:28:37 * geekosaur was wondering how a cofee relates to a fee :p
23:28:47 <srhb> MarLinn: A common affliction. :-)
23:29:19 <MarLinn> Even after pure-ing oneself some?
23:29:23 <srhb> :D
23:29:29 <srhb> I'm afraid so!
23:30:18 <mauke> https://www.youtube.com/watch?v=jRZ_PonbNJE
23:30:21 <MarLinn> But I haven't even fully understood cofree!
23:31:24 <MarLinn> geekosaur: a fee grants wishes, so maybe a cofee lives in a world of wishful thinking?
23:32:09 <Jenaf> so you could make a valid but very confusing indentation by just moving left?
23:33:28 <geekosaur> you could use any indentation  on lines 2-7 as long as they're more indented than line 1. make a zigzag if you want. :) (and yes, that could well be confusing...)
23:34:03 <chsn> I have a stack project, opened up in emacs; how do I fire up a stack repl taht eamcs connects to?
23:34:08 <zugz_> geekosaur: ffee is what a comathematician turns cotheorems into
23:34:15 <zugz_> geekosaur: (traditonal joke)
23:34:33 <geekosaur> yes, but the typo was "cofee"
23:35:06 <zugz_> geekosaur: then you need a new joke
23:35:14 <oolongCat> Is http://learnyouahaskell.com/ a good source for someone new to haskell but has previously programmed in other languages? 
23:35:43 <srhb> oolongCat: It has no exercises, teaches slightly poorly, but is very motivating.
23:35:49 <srhb> oolongCat: If that works for you. :-)
23:36:00 <Jenaf> for exercises I used project euler
23:36:30 <Welkin> @where learnahaskell -- oolongCat
23:36:30 <lambdabot> I know nothing about learnahaskell.
23:36:34 <Welkin> @where learnhaskell -- oolongCat
23:36:34 <lambdabot> https://github.com/bitemyapp/learnhaskell
23:36:35 <Jenaf> but now I'm beginning to takle the Things i wanted to do with haskell -> pretty pictures
23:36:39 <oolongCat> So the content in there is not old or annything I have to worry about right ? 
23:36:40 <srhb> I think project euler is fairly terrible for exercises, unless you only intend to do trivial math stuff.
23:36:45 <Welkin> project eulrer isn't any good for programming either
23:36:49 <srhb> oolongCat: No, not old.
23:36:54 <Welkin> start with the UPenn course
23:37:02 <Welkin> and then do your own project
23:37:04 <srhb> And yeah, cis194 is great.
23:37:09 <Jenaf> but I had much fun solving priject euler problems
23:37:10 <oolongCat> awesome, thanks, for exercises I think ill come bother guy people again :P 
23:37:11 <Welkin> something like Write Yourself a Scheme, or build a web app
23:37:21 <oolongCat> cis194, got it. 
23:37:23 <srhb> oolongCat: Consider cis194 instead, it's really good. :-)
23:37:34 <Welkin> haskell is extremely good for web dev
23:37:45 <Welkin> lots of great libraries and tools to choose from
23:37:48 <oolongCat> Really appreciate the help everyone. 
23:37:49 <Jenaf> Welkin: I do not want to do "practical" things
23:38:04 <geekosaur> euler problems are fine as long as you remember they exist to test your understanding of number theory, not programming
23:38:16 <Jenaf> yeah
23:38:35 <Jenaf> I don't like the fact that they are so into digits and euler phi function
23:39:19 <srhb> It does what it does quite great. It's just not very good for general purpose programming exercises. Because it doesn't try to be that. :-P
23:39:45 <Jenaf> yeah 
23:39:48 <MarLinn> Jenaf: if your goal is to get pretty pictures, you might want to take a look at diagrams.
23:40:13 <Jenaf> actually I want to do pretty pictures from maths stuffs
23:40:25 <srhb> STill diagrams :-)
23:40:44 <srhb> Jenaf: http://projects.haskell.org/diagrams/gallery.html
23:40:54 <Jenaf> so sometimes i sat there for a couple of hours mathing out a description for something pretty, but without knowing how to make a computer draw it
23:40:54 <MarLinn> *and* it can export to svg
23:43:23 <MarLinn> mh... I wonder how close to the pipeline the Haskell OpenGL libs are. There's a lot of mathy stuff going on on that level
23:44:39 <Jenaf> anyway I should be finished with my current pretty-picture generator thingy soon
23:46:29 <Jenaf> actually I'm done... now laod it into ghci and see if I'm really done XD
23:50:35 <Jenaf> do imports need to be at the beginning of the .hs file?
23:50:49 <Welkin> try it out
23:50:58 <Welkin> I've never tried anywhere but the top
23:52:22 <Jenaf> hm ghci sas parse error
23:52:38 <srhb> Jenaf: Yes, they do.
23:52:57 <srhb> Jenaf: after the (possibly implicit) module definition
23:53:04 <mahdi> How can I use non-IO monads inside `forkIO`? is it possible at all?
23:53:08 <Jenaf> I had it a bit lower because at the top I kinda have stuff that would technically belong into a config file
23:53:16 <srhb> :t return -- mahdi
23:53:17 <lambdabot> Monad m => a -> m a
23:53:18 <jle`> mahdi: what do you mean?
23:53:24 <srhb> mahdi: Your question is probably misguided though :)
23:53:32 <jle`> not sure how what you're asking can make sense, heh
23:53:38 * piyush-kurur applauds saurabhnanda for fixing the yesod benchmarks
23:53:49 <jle`> you can use values like normal
23:55:04 <mahdi> srhb: jile: look here: I have a forkIO and I want to use a function which returns another Monad (ConduitM) inside it, that's where I get an error) https://github.com/mdibaiee/yesod-proxy/blob/master/app/Main.hs#L94
23:56:32 <mahdi> forkIO expects an (IO a), but my Monad is (ConduitM a), how can I convert my ConduitM to IO? does that make sense?
23:56:38 <saurabhnanda> piyush-kurur: not so fast... let them beat Ruby by a wide margin first. On my scrappy test-bench I was getting mixed results.
23:57:26 <piyush-kurur> saurabhnanda: i thought sayd 800% improvement or some such ghastly speedu
23:59:01 <saurabhnanda> piyush-kurur: that was over Yesod+MySQL. When I benchmarked against Sinatra I got mixed results.
23:59:20 <saurabhnanda> but my test-bench was just a 2-core thingie... might not be good for benchmarking in the first place.
23:59:34 <saurabhnanda> Also, virtualbox+vagrant on top of EC2
