00:00:17 <intothemountains> Is there anyting similar to until where, instead of checking for a condition, I just define how many times to apply the function?
00:00:48 <ramadoka> are you looking for replicateM ?
00:01:08 <ramadoka> intothemountains: are you looking for replicateM ?
00:01:09 <athan> When GHC says "warning, using Double for ...." etc, wouldn't that mean it's _deciding_ on what type to use for an ambiguous one?!
00:01:14 <athan> if so, how does I use this?
00:01:33 <cocreature> :t \f n x -> iterate f x !! n
00:01:34 <lambdabot> (a -> a) -> Int -> a -> a
00:01:38 <cocreature> ^ ramadoka
00:01:40 <athan> like a default instance or something? :3
00:02:16 <intothemountains> More looking for what cocreature wrote ;)
00:02:17 <jle`> athan: hm, what do you mean?
00:02:19 <intothemountains> Thanks!
00:02:34 <jle`> athan: it's saying that it isn't sure what to use, so it's assuming you want Double
00:02:37 <jle`> but that might not be the case
00:02:43 <ongy> :t iterate
00:02:45 <lambdabot> (a -> a) -> a -> [a]
00:02:48 <jle`> you can specify by adding a type annotation
00:02:59 <athan> jle`: I understand that, but it's still not throwing an ambiguous type variable error
00:03:11 <athan> which is the curious part for me
00:03:30 <athan> how could I say (for a typeclass for instance) that type Foo is the default one?
00:03:36 <cocreature> athan: it’s called “default rules”, I can only find http://www.alexeyshmalko.com/2014/haskell-defaulting-rules/ documenting it right now
00:03:42 <athan> I'm guessing Double and Integer are defaults because they're the most lossless
00:03:51 <athan> !! thank you cocreature!
00:04:05 <cocreature> I always forget how to use it
00:04:16 <athan> I've seen it before in some of chrisdone's code
00:04:25 <cocreature> there is also -XExtendedDefaultRules
00:04:30 <cocreature> which is enabled by default in ghci
00:05:25 <ramadoka> ah, i c, i've used iterate before, but didn't realize that it create infinite list that could be` take`-n
00:05:33 <cocreature> athan: you can only use it for Num afaik
00:06:27 <ramadoka> wait, what is the expected complexity of iterate?
00:06:59 <ramadoka> take n $ iterate (+2) 3
00:07:26 <cocreature> that depends on the complexity and the functional behavior of your function
00:07:38 * hackagebot containers 0.5.8.1 - Assorted concrete container types  https://hackage.haskell.org/package/containers-0.5.8.1 (dfeuer)
00:07:38 * hackagebot cipher-aes128 0.7.0.3 - AES and common modes using AES-NI when available.  https://hackage.haskell.org/package/cipher-aes128-0.7.0.3 (ThomasDuBuisson)
00:07:44 <cocreature> ramadoka: in that case it will be O(n)
00:08:12 <ramadoka> how does it work though, isn`t it using (++) instead of (:) ?
00:08:24 <cocreature> ramadoka: no take a look at the definition https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.List.html#iterate
00:08:30 <cocreature> it’s quite simple :)
00:09:30 <ersran9> is it possible to have data Foo = Foo Type by just importing GHC.Types without -XTypeInType?
00:10:06 <athan> dang, yeah I though it was too much to genuinely work properly
00:10:20 <ramadoka> hoo, non-tco approach, i c.
00:10:40 <cocreature> ramadoka: tco is not useful if you are producing infinite data structures
00:10:59 <cocreature> ramadoka: tco is useful if you are producing something like an Int
00:12:01 <cocreature> ramadoka: in fact you would destroy lazyness if you try to tco optimize that
00:12:06 <cocreature> eh -optimize
00:13:10 <ramadoka> i c, i c... if i tco-it, i'll need to calculate until the end instead of cutting it in the middle.
00:13:22 <cocreature> exactly
00:13:28 <cocreature> and even if you do that it won’t be faster
00:13:51 <ersran9> ah that works
00:14:22 <cocreature> ramadoka: if your accumulator can not be saved in constant space, tco doesn’t make your program run in constant space
00:14:30 <cocreature> and that’s the case for things like lists
00:17:27 <srhb> cocreature: Don't you mean tail call instead of tco?
00:17:41 <srhb> afaik there is no tco, ever.
00:18:15 <cocreature> srhb: I was using tco as a “manual form of optimization where you rewrite things into tail calls” (I really shouldn’t do that)
00:18:23 <srhb> Ah :)
00:18:55 <srhb> I was just wondering if I'd missed something interesting :P
00:19:21 <ramadoka> my terminoly was wrong then, i thought, tco was compiler`s job to optimize tc-able function.
00:19:31 <ramadoka> s/terminoly/terminology/g
00:19:57 <cocreature> that’s the correct definition of tco (or at least the one most commonly used)
00:27:32 * hackagebot ogmarkup 2.2 - A lightweight markup language for story writers  https://hackage.haskell.org/package/ogmarkup-2.2 (lethom)
00:31:46 <k_89> woah
00:31:56 <k_89> #haskell has more users than #node.js
00:32:07 <k_89> is industry usage of haskell catching up?
00:32:53 <maerwald> k_89: compared to node.js? no. in general? a bit, but mostly in larger companies
00:33:08 <maerwald> facebook does some haskell too (see haxl)
00:33:53 <maerwald> it's just that haskell has turned out to be the frontier of language experimentation (that's why MS research is sorta funding it and using results for F# etc)
00:34:07 <k_89> interesting
00:34:32 <k_89> maerwald, can you tell in a few sentences what does language experimentation constitute?
00:36:24 <maerwald> k_89: some say GHC is a type laboratory. You'll also see a lot of category theory stuff being used in haskell
00:37:44 <maerwald> I'm not sure if "Monads" were first used in haskell the way they are popular today, but it sure has brought their use to another level.
00:38:28 <maerwald> and that's sort of a "community property" that's hard to replicate... being fine with experimentation
00:39:24 <maerwald> the downside of that is: APIs break rather quickly :P
00:39:54 <k_89> hehe
00:41:12 <maerwald> But it's not "just" an experimentation language anymore. Those days are gone. So it's sort of a hybrid today.
00:43:30 <maerwald> you bet facebook doesn't use an esoteric experimental academic-only language for their backend ;)
00:46:16 <Athas> Is there a way to make 'stack build'/'stack install' build my (single) package in parallel?  With cabal-install, I just edited the 'jobs' field of ~/.cabal/config.  Is there a similar thing for stack?  I can just pass --ghc-options -jN, but that seems a little crude.
00:47:33 * hackagebot hspec-golden-aeson 0.2.0.0 - Use tests to monitor changes in Aeson serialization  https://hackage.haskell.org/package/hspec-golden-aeson-0.2.0.0 (mchaver)
00:51:41 <balac> @pl (\(x,y) -> ( S.member x primes ) && (S.member y primes ) )
00:51:41 <lambdabot> uncurry ((. flip S.member primes) . (&&) . flip S.member primes)
00:54:36 <Axman6> :t on
00:54:38 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
00:55:13 <Axman6> :t uncurry (on (&&) (flip S.member primes))
00:55:15 <lambdabot> error:
00:55:15 <lambdabot>     Variable not in scope: primes :: Data.Set.Set a
00:55:31 <Axman6> :t uncurry (on (&&) (flip S.member (undefined :: S.Set Integer)))
00:55:33 <lambdabot> (Integer, Integer) -> Bool
00:55:59 <Axman6> IIRC pl doesn't look for common subexpressions
01:01:42 <Jinxit> what's an idiomatic way to build up a list based on a set of conditions? (add x if y, add z if w, etc)
01:03:13 <Axman6> catMaybes can be useful for that
01:03:28 <shachaf> [x | y] ++ [z | w] ++ etc
01:03:41 <Axman6> that's also pretty good
01:03:47 <shachaf> Or concat [[x | y], [z | w], etc]
01:03:51 <shachaf> Or something like that.
01:04:24 <ramadoka> meanwhile, i'm using case y of -> True ... / False -> .. lol
01:05:16 <Jinxit> shachaf: clever
01:05:27 <Jinxit> thanks
01:09:18 <ramadoka> is (|) a special syntax?
01:09:32 <ramadoka> :t (|) raise an error
01:09:36 <lambdabot> error: parse error on input ‘|’
01:10:02 <maerwald> list comprehension
01:10:06 <kadoban> ramadoka: It's part of list comprehension syntax
01:10:13 <Axman6> it's a guard in list comprehensions
01:10:26 <Axman6> it's the same as calling guard IIRC
01:10:28 <Axman6> :t guard
01:10:33 <lambdabot> Alternative f => Bool -> f ()
01:10:35 <MarLinn> But something like (|-) is still legal
01:11:36 <ramadoka> thx
01:11:49 <Axman6> > [(x,y,z) | x <-[1..10], y<-[x..10], z<-[y..10], x*x+y*y==z*z]
01:11:51 <lambdabot>  [(3,4,5),(6,8,10)]
01:12:07 <Axman6> tat's quivalent to...
01:12:41 <Axman6> > do x <-[1..10]; y<-[x..10]; z<-[y..10]; guard (x*x+y*y==z*z); return (x,y,z)
01:12:43 <lambdabot>  [(3,4,5),(6,8,10)]
01:13:41 <shachaf> It's true that that's what it means if you turn on MonadComprehensions.
01:21:01 <Algebr``> Did haykll have some kind of breaking change? 
01:21:16 <Axman6> like what?
01:21:18 <Algebr``> I am frustrated by how haskell code constantly breaks, has no backwards compatibilyt
01:21:50 <Algebr``> the binary produced used to give a watch option
01:22:28 <Axman6> I'm pretty sure the watch option is a fairly new thing, maybe you installed a version that was too old?
01:22:34 * hackagebot XMLParser 0.1.0.1 - A library to parse xml  https://hackage.haskell.org/package/XMLParser-0.1.0.1 (AlanHawkins)
01:22:36 * hackagebot incremental-sat-solver 0.1.8 - Simple, Incremental SAT Solving as a Library  https://hackage.haskell.org/package/incremental-sat-solver-0.1.8 (SebastianFischer)
01:22:56 <Algebr``> I was using watch perfectly fine for months, then installed a newer version of hakyll and it broke
01:24:37 <Algebr``> okay smediel helped me on twitter, apparently the cache format changed
01:25:06 <Algebr``> but the error message was quite ominious: hblog: Data.Binary.Get.runGet at position 17: not enough bytes CallStack (from HasCallStack): error, called at libraries/binary/src/Data/Binary/Get.hs:342:5 in binary-0.8.3.0:Data.Binary.Get
01:25:36 <ertesx> edwardk: i'm currently working on a refactoring of the containers package as discussed with dfeuer…  according to the changelog you requested internal modules to be exposed…  does that include the Data.Utils.* modules?
01:25:57 <Axman6> that error just says "Data.Binary couldn't parse some binary data"
01:26:01 <kadoban> Algebr``: You should usually clean when you upgrade hakyll, I don't think it's uncommon for the cache format to change.
01:27:01 <Algebr``> yes, I didn't realize that. I want that watch server again, The preview server is not enabled in the version of Hakyll. To Creating provider... enable it, set the flag to True and recompile Hakyll. But it doesn't tell you how or where to add the flag
01:27:25 <Algebr``> I built it with:  cabal install hakyll --enable-shared and  	ghc --make -threaded hblog.hs
01:28:57 <maerwald> Algebr``: watch server is enabled by default
01:29:42 <Algebr``> I just showed the error message I got from a fresh install
01:30:12 <ertesx> edwardk: for now i'll operate under the assumption that it doesn't, as those are mostly just very generic helper functions…  if i'm wrong, please let me know
01:30:24 <maerwald> cabal install --flags="watchServer" -- should enable watchServer explicitly
01:32:26 <Algebr``> okay, things are compiling....this might take some time
01:33:30 <kadoban> I don't really understand what's going on with that, someone else asked earlier about the watch server not being enabled. Is there some quirk of cabal that default flags don't mean what it seems like they'd mean?
01:33:58 * maerwald senses a stack argument incoming
01:34:03 <Algebr``> I don't understand it either, previously it worked just fine, now this. 
01:34:11 <Algebr``> It makes me never want to upgrade haskell code
01:34:26 <Algebr``> I only use it for this blog
01:37:31 <maerwald> Algebr``: for deploying a blog I'd probably use a hakyll docker container, which allows easy rollback if something gets messed up
01:37:34 * hackagebot language-puppet 1.3.1 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.3.1 (SimonMarechal)
01:38:08 <Algebr``> its just for github pages, so not like I have something to deploy to
01:38:14 <merijn> Why does hakyll even need a docker container? >.>
01:38:29 <merijn> I mean, the entire point of Hakyll is that it's just some static files you copy over
01:38:31 <maerwald> merijn: that's not really what I said
01:38:46 <kadoban> Algebr``: I'd kind of question why you upgrade in the first place. Something like hakyll ... I mean it doesn't interact with anything, so unless you need an actual change?
01:39:15 <kadoban> I mean it's not a server where you'd worry about missing security upgrades or anything. So the whole point of getting new version is *for* things to change. But if you're happy where it was ...
01:39:17 <Algebr``> kadoban: because I like having the latest version of stuff? Maybe some bugs were fixed? 
01:39:28 <Algebr``> kadoban: are you recommending to not upgrade code? 
01:39:49 <merijn> Algebr``: For something like Hakyll? Yes, I would recommend not upgrading unless you encounter a problem/need a new feature
01:39:51 <kadoban> Algebr``: I wouldn't in this case.
01:40:13 <merijn> Algebr``: "maybe a bug was fixed" <- unless it's a bug actually affecting the HTML generated, why care?
01:40:28 <maerwald> merijn: look at rancher to get an idea what docker containers can be used for (not just running a web server)
01:40:29 <Algebr``> I am surprised that ya'll are recommending to not upgrade code. 
01:40:33 <merijn> Algebr``: tbh, I don't recommend upgrading to the latest version of GHC either :p
01:40:47 <Algebr``> but lesson learned, don't upgrade haskell code heh. 
01:40:50 <merijn> Algebr``: I work on "latest GHC -1" unless I need a new feature
01:41:31 <kadoban> Algebr``: That's a pretty bad summary of what anyone said, but *shrug*.
01:41:38 <merijn> Algebr``: I'm not saying "don't upgrade code", if you're running, e.g. a server you should upgrade stuff to avoid bugs/holes that are undiscovered. But executables that are not attack vectors? Why upgrade what's not broken?
01:41:56 <exDM69> Algebr``: if hakyll uses stack, you should try building with stack instead... it should make builds reproducible and also build with a specific compiler version
01:42:09 <maerwald> that's orthogonal
01:42:33 <exDM69> Algebr``: haskell dependency management has been an issue for years... and now that GHC is making breaking changes, it's even worse
01:42:46 <exDM69> Algebr``: stack should help with that, but not everyone likes it (like maerwald here)
01:42:50 <kadoban> It's buildable with stack, though I don't know that it'd really have any effect in this case. Not clear what's up with the flags in the first place.
01:42:51 <maerwald> it was not a dependency issue, so how is this relevant?
01:43:01 <maerwald> exDM69: don't misquote me plz
01:43:06 <exDM69> was it a compiler version issue?
01:43:11 <kadoban> No
01:44:03 <Algebr``> kadoban: I was being facetious. Because I don't care to learn something new, stack, when cabal was fine and was introduced to me as the way for haskell and apparently is still used. I get that dependency mangagement is hard
01:44:47 <Algebr``> in any case, I won't upgrade haykll anymore
01:44:48 <ertes> Algebr``: i don't see any particular issue with never updating hakyll
01:45:11 <maerwald> Algebr``: so, does it work now?
01:45:22 <Algebr``> compiling
01:45:41 <maerwald> please don't go the "never update" route, instead start nagging maintainers so they fix their packages
01:45:58 <ertes> Algebr``: the code is only used locally, and there are solutions for keeping compiler and libraries at certain versions for that particular project, while letting the rest of the system update
01:46:05 <Algebr``> maerwald: :( still no watch server
01:46:07 <Algebr``> damnit
01:46:28 <Algebr``> I really liked the watch server. If this community itself is not giving a consistent answer on upgrading or not...not sure what a casual observer ought to do?
01:46:44 <Algebr``> okay whatever, as long as build work
01:47:17 <kadoban> Algebr``: Listen to what people said, understand, make a decision for yourself. Possibly hakyll just had a bad update, you could consider filing a bug on the issue tracker if you like.
01:47:56 <maerwald> Algebr``: I can at least verify that the WATCH_SERVER get def'ed and the related code-paths are compiled
01:48:15 <Algebr``> ertes: yea, I know solutions, nixpkgs, etc, I have a few nixpkgs accepted, but I don't feel like dealing with all that just for a blog. 
01:48:30 <Algebr``> maerwald: I don't get it...whatever, at least I can write a new post. 
01:48:44 <Algebr``> hopefully deploy still works
01:51:12 <mniip> is there a thing like
01:51:25 <mniip> (a -> b -> c) -> (a -> c) -> (b -> c) -> [a] -> [b] -> [c]
01:51:52 <mniip> like zipWith that deals with leftovers
01:52:11 <merijn> mniip: There's some packages with something like that
01:52:35 <merijn> But I dunno if I'd bother picking up a dependency for it
01:52:37 <ertes> Algebr``: hakyll has a history of breaking changes, and it's for the most part not considered a bug, but a feature…  it's representative of the mindset of the haskell community: continued maintenance over legacy
01:53:01 <ertes> mniip: see the 'these' package
01:53:08 <mniip> oh, thesed
01:53:10 <mniip> these
01:53:17 <merijn> Especially considering you can just stick to the old Hakyll version
01:53:41 <Algebr``> well now I get it. 
01:54:02 <Algebr``> I am not used to that in my other coding 
01:54:05 <mceier> @djinn (a -> b -> c) -> (a -> c) -> (b -> c) -> [a] -> [b] -> [c]
01:54:05 <lambdabot> Error: Undefined type []
01:54:33 <Axman6> djinn doesn't know about recursive types like list
01:54:36 <Insanity_> I'm going to ask a noob question again, I can find some answers online but I'm not sure which is the correct approach. I am generating the fibonacci sequence, but (because I'm using sqrt I think) the resulting list is a bunch of floats. How could I convert them to integers when they are added to the resulting list?
01:54:36 <Insanity_>  
01:54:51 <Insanity_> The function I am using is: [(((1+sqrt 5)^n) - ((1-sqrt 5)^n)) / (2^n*sqrt 5) | n <- [1..10]]
01:55:16 <mniip> hmm, these is not in lambdabot :(
01:55:16 <Insanity_> Not the most straightforward way of generating fib, but since I'm new to FP, I assumed otherwise I would need to use recursion which I haven't seen in Haskell yet :P
01:55:19 <Axman6> you can use round, ceil or floor depending on wha behaviourt you want
01:55:20 <bartavelle> Insanity_, there are "truncate" and "round" functions
01:55:23 <ertes> Insanity_: if you're happy with precision loss for larger integers, you can just apply 'round'
01:55:36 <mniip> > fix ((1:) . scanl (+) 1)
01:55:39 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
01:55:42 <merijn> :t (^)
01:55:44 <lambdabot> (Num a, Integral b) => a -> b -> a
01:55:49 <Insanity_> oh round, that did it, thanks :-)
01:56:02 <Axman6> Insanity_: that's impressive, the fibonacci sequence is the canonical example used to demonstrate laziness in haskell
01:56:10 <ertes> Insanity_: i have code to use a number field with sqrt 5 in order to use the formula without precision loss, but i'm not sure if showing it to you right now is a good idea =)
01:56:11 <Insanity_> The function is supposed to generate fibonacci - minor mistakes in terms of precision should still be near the actual number 
01:56:31 <merijn> Insanity_: Note: round uses banker's rounding (as it should according to IEEE754), but lots of people expect rounding to work like grade school
01:56:32 <kadoban> Insanity_: Just so you know, that is going to give you some pretty bad answers for not very big numbers. Not that it probably matters, just saying.
01:56:35 <Axman6> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
01:56:37 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
01:56:39 <Insanity_> @ertes I'm just learning Haskell for the second day now, so it might be:D
01:56:39 <lambdabot> Unknown command, try @list
01:57:10 <mniip> > fix ((0:) . scanl (+) 1)
01:57:12 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
01:57:28 <mniip> > fix (([0,1]++) . zipWith (+) <*> tail)
01:57:30 <lambdabot>  error:
01:57:30 <lambdabot>      • Couldn't match type ‘[Integer]’ with ‘[c] -> [c]’
01:57:30 <lambdabot>        Expected type: [c] -> [c] -> [c]
01:57:32 <Insanity_> Ah thanks for the heads-up merijn 
01:57:40 <mniip> > fix (([0,1]++) . (zipWith (+) <*> tail))
01:57:43 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
01:58:26 <merijn> Insanity_: Which deals with how 0.5 gets rounded. In grade school they usually teach you to round 0.5 up, banker's rounding rounds to even. So 5.5 -> 6 but 6.5 -> also 6
01:58:44 <mniip> > map round [5.5, 6.5
01:58:46 <mniip> > map round [5.5, 6.5]
01:58:46 <lambdabot>  <hint>:1:20: error:
01:58:46 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
01:58:48 <lambdabot>  [6,6]
01:58:54 <Insanity_> Indeed, good to know :-) 
01:58:55 <mniip> TIL
01:59:03 <merijn> mniip: The reason is to avoid bias
01:59:19 <ertes> if anyone else is interested: https://github.com/esoeylemez/snippets/blob/master/FibNF.hs
01:59:28 <ertes> exact fibonacci formula =)
01:59:37 <shachaf> Banker's rounding is not as good as baker's rounding, which rounds 12 up to 13.
01:59:44 <merijn> mniip: .If you round 1, .2, .3, and .4 down and .5, .6, .7, .8 and .9 up then you round up more numbers than you round down
01:59:51 <merijn> mniip: Introducing a slight bias :)
02:00:03 <mniip> ertes, is that Z[sqrt(5)]
02:00:10 <merijn> mniip: So be rounding half of all .5 up and half down, you keep the distribution fair
02:00:22 <Axman6> shachaf: go home dad
02:00:24 <Insanity_> That's interesting :o
02:00:33 <ertes> mniip: ℚ[sqrt 5]
02:00:35 <merijn> mniip: The choice to round to even, rather than odd is completely arbitrary
02:00:54 <mniip> cool stuff
02:01:00 <merijn> Rounding to odd would work equally well, but IEEE754 uses "round to even", so that's the sanest default
02:01:23 <Insanity_> Just checked in the language I usually work with, 6.5 -> 7 
02:01:24 <Axman6> people are ok having a bias against oddness though
02:01:28 <Insanity_> Quite nifty
02:01:49 <mniip> > map (floor . (+.5)) [5.5, 6.5]
02:01:51 <lambdabot>  error:
02:01:51 <lambdabot>      • Variable not in scope: (+.) :: Double -> Integer -> Double
02:01:51 <lambdabot>      • Perhaps you meant one of these:
02:01:55 <mniip> > map (floor . (+ .5)) [5.5, 6.5]
02:01:57 <lambdabot>  <hint>:1:17: error: parse error on input ‘.’
02:02:01 <merijn> mniip: 0.5 :)
02:02:02 <mniip> > map (floor . (+0.5)) [5.5, 6.5]
02:02:06 <mniip> right, this isn't python
02:02:06 <lambdabot>  [6,7]
02:02:19 <bjs> mniip: not much is python
02:02:25 <bjs> mniip: except for maybe python
02:02:52 <mniip> I think that exhaustively lists all things that are python
02:03:01 <jle`> what about python
02:03:04 <jle`> oh wait already got that
02:03:23 <Axman6> does someone have a list of things which are not python?
02:03:24 <ertes> i wonder if there are cases when (+ x) is slower than (x +) for base numberic types
02:03:46 <jle`> i remember a post on the reddit talking about an odd case due to a ghc-ism for Integer
02:03:59 <jle`> or maybe it was about different results, not different performance
02:04:10 <ertes> that would be terrible
02:04:41 <jle`> it might have had to do with an optimization for 0 + x or x + 0
02:05:11 <ertes> > 0 * undefined :: Integer
02:05:13 <lambdabot>  *Exception: Prelude.undefined
02:05:19 <ertes> > undefined * 0 :: Integer
02:05:21 <lambdabot>  *Exception: Prelude.undefined
02:05:43 <ertes> i think there used to be an odd case for multiplication by 0
02:07:35 * hackagebot inline-c 0.5.5.7 - Write Haskell source files including C code inline. No FFI required.  https://hackage.haskell.org/package/inline-c-0.5.5.7 (FrancescoMazzoli)
02:07:54 <maerwald> Algebr``: the watch thing is supposed to be daemonized or run in the foreground or what?
02:08:30 <merijn> ertes: I expect special casing multiplication by 0 actually makes performance worse by messing with the strictness analyser or something
02:09:22 <Algebr``> maerwald: no, just runs and whenever there's a change in the markdown it rebuilds the site
02:09:26 <Algebr``> foreground
02:11:21 <ertes> merijn: yeah, probably…  GMP has a special case for 0 anyway
02:11:29 <mniip> GMP is strict anyway
02:12:00 <merijn> mniip: The strictness analyzer actually deals with unboxing
02:13:02 <merijn> mniip: As in, if you have a long bunch of strict math (because the strictness analyzer sees you doing a bunch of boxing/unboxing for Int) it can turn all the code into working directly on unboxed versions, making it faster. I imagine special casing 0 makes it harder for the analyzer to peer through and see everything can be unboxed
02:13:14 <mniip> right
02:13:18 <mniip> ah
02:17:04 <maerwald> Algebr``: aha, I might have figured it out
02:17:13 <maerwald> Algebr``: do: cabal run -- watch --no-server
02:17:27 <maerwald> otherwise it requires the previewServer which seems to be disabled because of broken dependencies
02:18:06 <maerwald> default for previewServer is enabled, but cabal will disable it if it cannot satisfy the deps it seems
02:19:04 <maerwald> and without --no-server the watcher just doesn't run
02:19:13 <Algebr``> maerwald: but I did it on a fresh install...how could I not satify deps??
02:19:40 <maerwald> I don't understand that question
02:19:44 <Algebr``> and cabal run won't work cause I don't have a cabal file
02:19:55 <maerwald> how do you invoke the watcher?
02:19:55 <Algebr``> oh the package itself has broken dependencies
02:20:00 <Algebr``> ./hblog watch
02:20:07 <Algebr``> aka ./the_binary watch
02:20:14 <maerwald> ./hblog watch --no-server ?
02:21:04 <Algebr``> yesss
02:21:08 <Algebr``> maerwald: that works!
02:21:26 <Algebr``> maerwald: thank you so much!!!!
02:22:36 * hackagebot yaml 0.8.18.2 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.18.2 (MichaelSnoyman)
02:29:28 <MarLinn> As dependency purgatory came up again in this context: Is there a resource out there that discusses possible solutions to the underlying challenges that I could read? Somehow I can't believe that stack's way is the only one.
02:30:58 <ertes> MarLinn: it's not a problem of tools…  cabal sandboxes would already solve it, if it were
02:31:07 <maerwald> MarLinn: I don't know of any particular resource. You can check however on source-based rolling release distros, which basically solve those problems every day. It requires better platform/communication tools though than hackage is.
02:31:10 <Axman6> perhaps read up on the cabal new-build stuff from ezyang
02:31:46 <ertes> MarLinn: the problem is that two versions of a pacakge are inherently incompatible, even if they export exactly the same type
02:31:55 <ertes> MarLinn: in most languages this problem is just hand-waved away
02:32:22 <Algebr``> I don't encounter these kinds of problems in OCaml, different build pains, but not cabal pain.
02:32:31 <Axman6> "Lol, sopmeone will probably come along and change all the methods at runtime anyway, so who cares?" - Ruby/JS devs
02:32:39 <MarLinn> maerwald, Axman6: thanks, I'll see what I can find
02:32:53 <maerwald> MarLinn: one possibility e.g. would that when you upload a package to hackage it gets into a "pending" state first, then a dependency tree checker is run on reverse deps to check if the dependency broke. Then it shows and mails you the result
02:33:26 <ertes> MarLinn: now imagine that library B depends on A-1 and C depends on A-2…  you depend on B and C as well as A
02:33:29 <ertes> which A do you depend on?
02:33:39 <maerwald> that doesn't fix building problems per se though, it just makes sure the dependency tree is not borked. And that's easily possible.
02:33:53 <ertes> to be honest i've *never* had this problem in a practical setting, so i have a feeling that it's exaggerated
02:34:17 <maerwald> ertes: doesn't happen too often with up2date packages
02:34:38 <maerwald> sometimes happens with flags no one uses anymore (e.g. the yi-editor flag in leksah afair)
02:34:50 <ertes> i see
02:35:14 <maerwald> and flags are a plague, actually
02:35:31 <MarLinn> maerwald: sounds like in the end it might come down to manual labour in any way, just with different amounts of feedback
02:37:21 <maerwald> MarLinn: well, it's the old discussion: freezed releases or rolling-release. As a package developer, I want to be exposed to the "latest" hackage state, so I can fix dependencies accordingly.
02:37:36 <maerwald> rolling release needs more coordination and hackage doesn't really offer that as a platform
02:38:22 <maerwald> if you want a release based channel, you can either use a distro that provides that or use stack
02:41:36 <MarLinn> Could definition-level versions be part of a solution? E.g. if a type doesn't change between versions, the solver could ignore a difference between package versions in some (many?) cases.
02:42:14 <merijn> MarLinn: But now you need code to ensure that actually does that, even then it's not good enough.
02:42:30 <merijn> MarLinn: Imagine, for example, "HashMap a"
02:42:50 <merijn> MarLinn: Now, in a new version of the library the data type is unchanged, BUT! I use a different method of hashing
02:43:18 <merijn> MarLinn: Now HashMap's from version 1.0 and 1.1 can't be interchanged (despite the datatype being the same!) because the way said datatype was constructed has changed
02:43:31 <merijn> MarLinn: There's an infinite tar pit of problems in that direction
02:43:54 <merijn> The sanest solution is simply saying "No."
02:44:35 <MarLinn> Hm... yeah, I was just thinking about internal consistency, not consistency between produced data. And that obviously not wide enough
02:44:49 <MarLinn> +'s
02:45:15 <merijn> MarLinn: So, despite people liking to handwave "It's so easy!", it's really just a honest to god really hard problem
02:46:04 <merijn> MarLinn: The only reason people don't have this in, say, Python/JavaScript is that, since every object is just a dictionary, it doesn't really matter if the object is old. You just try to access the member/method and if it's there it works. If not, you crash at runtime
02:46:33 <Algebr``> merijn: I don't understand why OCaml doesn't have this massive pain.
02:46:41 <merijn> MarLinn: As for the "what if your datastructure is now constructed differently?" problem. They stick their fingers in their ears and go "lalala, I can't hear you"
02:46:48 <merijn> Algebr``: I don't know enough ocaml to say
02:47:06 <merijn> Algebr``: Maybe it does, but has a smaller ecosystem?
02:47:28 <Algebr``> maybe, or maybe opam is smarter than cabal. opam has an actual sat solver. 
02:47:31 <merijn> Algebr``: Also, the way Ocaml functors work makes it easy to provide code that is abstracted over internals, so I imagine that helps
02:47:43 <merijn> Algebr``: You can plug a sat solver into cabal
02:47:52 <merijn> Algebr``: And I think it has a simple one builtin
02:48:08 <ertes> Algebr``: "cabal hell" is not related to the resolver, which usually does the right thing
02:48:17 <ertes> it's the dependencies themselves that are the problem
02:48:25 <merijn> Obligatory: "Cabal hell no longer exists"
02:49:01 <merijn> Cabal hell existed. It doesn't exist any longer. Everyone currently using the term "cabal hell" really just means "my dependencies are broken!"
02:49:58 <maerwald> there are 3 things that make dependency resolution overly complex: 1. a package can have more than one version, 2. a package can have "flags" and other packages can depend on package configuration, 3. || dependencies
02:49:58 <maerwald> classic release distros usually don't have any of those 3 and dependency resolution works pretty well
02:50:59 <maerwald> I know only one distro that allows all 3 and the PM is utterly broken
02:51:48 <merijn> maerwald: Having flags affect the interface of the package is expressly not allowed on hackage, so that shouldn't be an issue
02:52:01 <MarLinn> Not to mention that inlining can happen across package boundaries, if I recall correctly. Hilarity ensues
02:52:16 <maerwald> merijn: theoretically, in practice that's already done (e.g. in snap, you get a runtime error then telling you are missing flags)
02:52:51 <maerwald> I think that was about tls support there
02:53:16 <kuribas> Whats the best datatype to describe raw binary data?
02:53:17 <merijn> maerwald: Then Snap should be fixed
02:53:22 <merijn> MarLinn: Correct
02:53:27 <kuribas> Bytestring?
02:53:29 <merijn> kuribas: ByteString?
02:53:34 <kuribas> ok
02:53:46 <merijn> kuribas: Ignore the string part of ByteString, historical mistake. Pretend it's called "Bytes"
02:53:54 <kuribas> ah ok :)-
02:53:57 <kuribas> :-)
02:54:08 <maerwald> MarLinn: yes, that happens quite often with QuickCheck actually... you build package A which depends on QuickCheck and on Foo. Foo also depends on QuickCheck, but was built against an older version than you are trying to build A against.
02:56:12 <maerwald> merijn: how would you fix that? enable tls unconditionally?
02:56:35 <heebo> I have a comment parser that looks like ```CommentConstructor <$> (some $ notChar '\n')``` 
02:56:56 <merijn> maerwald: Yes, or architect it to be parameterised over protocol and have a snap-tls that you can pass as parameter to snap
02:57:20 <MarLinn> But QuickCheck stuff should not be re-exported. Or exported for tests, but not used by dependencies. So the solver actually stumbles because he doesn't get enough information about transitivity?
02:57:21 <Algebr``> maerwald: whew, deploy still worked. Yay, thank you very much again
02:58:02 <heebo> how can I create a parser that reads any string up to the begininng of a comment? somethig like ``` (some $ anyChar) *> commentParser`
02:58:15 <maerwald> Algebr``: pretty odd problem though. I tried again with adding the git repo via cabal sandbox add-source and the dependency problem went away. Maybe the hackage thing is skewed or something
02:59:27 <MarLinn> Man... so many edge cases and pitfalls...
03:00:32 <maerwald> MarLinn: https://people.debian.org/~dburrows/model.pdf
03:02:06 <Algebr``> maerwald: no idea, also did cabal update beforehand
03:02:08 <MarLinn> maerwald: Thanks :)
03:02:30 <ongy> merijn: but there's also nothing preventing me to change interface with a flag, and I don't know how it would be better to export a file, that doesn't make sense without the dependency (well, I could putt an error pragma, which may be more descriptive)
03:08:30 <Algebr``> maerwald: fwiw here's the post, http://hyegar.com/2016/08/31/grabbing-function-location/
03:08:51 <maerwald> what post
03:09:12 <Algebr``> maerwald: that I was trying to do with haykll
03:09:25 <Algebr``> its a hakyll powered blog
03:28:29 <kuribas> What would be the best way to represent the truetype font tables?
03:29:29 <kuribas> a map "String -> Table", or "TrueTypeTables (Maybe CvtTable) (Maybe FpgmTable) ..."
03:31:12 <kuribas> What I like about the second is that it doesn't allow for wrong associations.
03:31:13 <berndl> kuribas: I think that depends on what you plan on doing.
03:31:31 <kuribas> berndl: reading a truetype font in a haskell datatype.
03:31:42 <kuribas> and writing
03:32:58 <Axman6> I don't understand what the second option is supposed to represent
03:33:15 <merijn> Axman6: Tables may or may not be present and there's multiple types of tables
03:33:42 <kuribas> But each table appears only once I think...
03:33:52 <merijn> kuribas: I think the latter is nicer (maybe use record syntax for the datatype)
03:36:45 <kuribas> merijn:  yeah
03:37:29 <kuribas> merijn: It was probably done to save space and make it easy to extend the file format, but for the library a single datatype may be nicer.
03:37:57 <merijn> kuribas: Yes
03:38:23 <merijn> I actually kinda like the truetype file format, what I remember from trying to parse it in the past is that it's fairly sane
03:42:04 <kuribas> I can leave out the Maybe for required tables anyway...
03:49:40 <chpatrick> do you guys know a package for operating on GADTs like this? data Some f where Some :: KnowNat nat => f nat -> Some f
03:50:17 <chpatrick> like mapSome :: (forall nat. f nat -> g nat) -> Some f -> Some g
03:50:37 <chpatrick> I can write it myself but I was wondering if there's anything comprehensive already
04:01:04 <Insanity_> Hey guys, I have a bunch of tuples (a,b). for example: (3,4) (3,6), (5,10), (6,11). If I wanted to create lists out of these containing all elements where 'a' is the same. Would there already be a function of that?
04:01:35 <Insanity_> so I'd get lists like [(3,4),(3,6)][(5,10)][(6,11)]
04:01:47 <Insanity_> essentially a 'groupBy a'
04:02:17 <puregreen> Insanity_: groupWith fst
04:02:25 <puregreen> where groupWith comes from GHC.Exts
04:02:37 <Jinxit> is find linear in memory usage?
04:02:58 <Insanity_> thanks puregreen, by that do you mean that groupWith is not by default part of haskell? 
04:03:24 <puregreen> yeah, it's just a useful function that hasn't found its way into Data.List yet (I think)
04:03:45 <Insanity_> I haven't worked with external functions yet, so I'll look into that, thanks :-)
04:05:38 <ertes> Insanity_: you would need to sort first
04:05:52 <puregreen> ertes: groupWith sorts automatically
04:06:10 <ertes> ah, i'm not familiar with groupWith
04:06:34 <ertes> Insanity_: you could just create a Map/IntMap
04:07:22 <sup_> hello
04:07:30 <ertes> :t M.fromListWith (++) . map (fmap pure)
04:07:32 <lambdabot> Ord k => [(k, a)] -> Data.Map.Map k [a]
04:07:55 <Insanity_> They are sorted :-)
04:07:59 <ertes> > (M.fromListWith (++) . map (fmap pure)) [(3,4), (5,10), (3,6), (6,11)]
04:08:01 <lambdabot>  fromList [(3,[6,4]),(5,[10]),(6,[11])]
04:08:02 <sup_> I am using postgresql-simple and i want to do an insert of multiple rows to a table with a name in a variable
04:08:07 <ertes> Insanity_: ^
04:08:16 <sup_> but i'm not sure how to construct a query that will typecheck
04:08:48 <Insanity_> Oh that looks neat ertes, cheers
04:08:56 <sup_> for example: "insert into ? (name, age) values (?,?)"
04:08:58 <ertes> Insanity_: use this if appropriate:
04:09:06 <ertes> :t M.fromListWith (<>) . map (fmap S.singleton)
04:09:08 <lambdabot> (Ord a, Ord k) => [(k, a)] -> Data.Map.Map k (Data.Set.Set a)
04:09:28 <ertes> or even:
04:09:32 <ertes> :t IM.fromListWith (<>) . map (fmap IS.singleton)
04:09:34 <lambdabot> [(Data.IntSet.Key, Data.IntSet.Key)] -> Data.IntMap.IntMap Data.IntSet.IntSet
04:09:48 <sup_> so i have `tableName` and `[("a", 12), ("b", 21)]`
04:09:49 <Insanity_> And another noob question of course, where does 'M' come from? :P
04:10:02 <ertes> Insanity_: import qualified Data.Map.Strict as M
04:10:05 <ertes> S = Data.Set
04:10:11 <ertes> IM = Data.IntMap.Strict
04:10:14 <ertes> you get the idea
04:10:17 <Insanity_> Ah I see, can you do those things inside ghci?
04:10:21 <ertes> yeah
04:10:22 <Insanity_> Yup, get the idea, thanks :)
04:10:50 <sup_> so, how do i prepare a query so it will fill the first `?` and then i can use `executeMany` for the values list?
04:10:55 <sup_> anyone has an idea?
04:12:30 <lwm> sup_: postgresql-simple just gives you normal sql strings. So you'd need to know your query and then just use `field=?`
04:12:57 <lwm> an example being: https://github.com/lwm/es-api/blob/master/src/DB/Query/QueryStrings.hs#L17-L23
04:14:04 <sup_> lwm is there no way to put the table name and then the values?
04:14:36 <ertes> int-e: i'm assuming that you're importing many modules twice in lambdabot, once with the full name (Data.Set), once abbreviated (Data.Set as S)
04:15:10 <ertes> int-e: if you import the short variant first, it is used for :t, which makes types a lot more readable…  would you mind doing that?
04:15:14 <lwm> sup_: table name should come through the connection information
04:15:21 <sup_> i can use `executeMany conn (Query $ "insert into " <> BS.pack tableName <> " (name, age) values (?,?)") [("a", 12), ("b", 21)]`
04:15:24 <sup_> but that's not very nice
04:15:36 <lwm> oh, I get what you mean
04:15:51 <Aruro> why haskell-mode does not color two declarations in one line separated by ; ?
04:16:27 <sup_> Aruro, if you don't get an answer, best to ask at #haskell-emacs i think
04:16:34 <Aruro> ty
04:16:38 <sup_> np
04:16:44 <ertes> Aruro: haskell-mode doesn't use a full haskell parser, so it's basically a bunch of regexes that don't cover that case
04:18:44 <sup_> anyone knows of a way to solve that problem in postgresql-simple?
04:19:49 <Aruro> ertes: ok thanks, maybe i will try to add one for this case
04:20:02 <ramadoka> :q
04:21:44 <ertes> Aruro: to be honest i wouldn't bother
04:22:29 <Aruro> why i like ; operator
04:22:39 <Aruro> and have wide monitor
04:22:39 * hackagebot fixfile 0.4.0.0 - File-backed recursive data structures.  https://hackage.haskell.org/package/fixfile-0.4.0.0 (rev_null)
04:23:13 <ertes> Aruro: sure, use it, if you like it, but i imagine that fixing the syntax highlighting for it could be quite difficult
04:23:47 <Aruro> yeah its not my first priority just wanted to ask , maybe someone from haskell mode will implement
04:32:40 * hackagebot lentil 0.2.0.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-0.2.0.0 (fffaaa)
04:40:08 <orion> hmm... Amazon has a service called "Lambda" which executes small snippets of code in response to various events. They support Python and Node.js. Is there a similar service offering Haskell-based code instead?
04:40:15 <orion> If not, that might be a cool service to offer.
04:46:15 <bollu> the yoneda lemma basically says that you can know an object X if you know Hom(_, X) right?
04:48:43 <Cale> bollu: quite vaguely, yes
04:51:07 <bollu> Cale: what's the exact formal statement?
04:51:14 <Axman6> orion: it's possible to use any language on Lambda be calling it from node/python (or java but that egts expensive fast because you pay the JVM startup time every time your lambda function is called)
04:51:16 <bollu> wikipedia just throws a commutative diagram in my face :P
04:52:52 <Axman6> orion: https://github.com/abailly/aws-lambda-haskell
04:54:26 <Axman6> orion: you could easily use the amazong amazonka packages(s) to interact with other AWS services too
04:56:37 <zedik> Hi all. How can I apply putStrLn to the value of type IO [Float}? I read the vector from a file (let v = readvector "./data.txt"), the v has a type IO [Float]. I am trying to putStrLn $ show $ v!!0, but it gives an error 'Couldn't match expected type ‘[a0]’ with actual type ‘IO [Float]’'. How to fix it?
04:56:41 <bollu> what's the right statement of the yoneda lemma?
04:56:43 <Cale> It says that if y: C -> Set^(C^op) is the Hom functor Hom(-,X), then there's a bijection between Hom(yX, F) and FX
04:56:49 <Cale> which is natural in both F and X
04:57:27 <bollu> Cale: C -> Set ^ (C^op)? isn't that just C -> (C^op -> Set)? (or am I missing something?)
04:57:46 <bollu> and what does it mean to say that it "is the Hom functor"?
04:57:51 <Axman6> zedik: you haven't actually read the data from a file, you've created a value of type IO [Float] which when executed will produce a [Float]
04:57:57 <ertes> zedik: what's the type of readvector?
04:57:59 <Axman6> and you've called it z*
04:58:24 <Axman6> you will probably need to replace the let line with z <- readvector "foo.txt"
04:58:28 <liste> zedik: use v <- readvector "./data.txt" instead of let v = readvector "./data.txt", if you're inside a do block
04:58:30 <Cale> oh, woops, it helps not to reuse X
04:58:31 <zedik> ertes: readVec :: String -> IO [Float]
04:58:32 <Cale> like that
04:59:06 <ertes> zedik: (show :: [Float] -> String), but (readvector "./data.txt" :: IO [Float])
04:59:11 <orion> Axman6: Oh, I didn't know you could upload code/libraries to Lambda.
04:59:14 <Cale> Er, sorry, I just woke up
04:59:22 <ertes> zedik: would you consider the latter to be a valid argument to the former?
04:59:31 <Cale> yX is the functor Hom(-,X)
04:59:37 <bollu> Cale: haha, np. I'm just trying to grok Yoneda for what feels like the Nth time :)
04:59:43 <Axman6> orion: it's a bit of a hack, but IIRC somewhat officially supported
04:59:49 <zedik> ertes: No
05:00:15 <ertes> zedik: that's correct
05:00:18 <ertes> zedik: https://www.vex.net/~trebla/haskell/IO.xhtml
05:00:20 <zedik> ertes: Is it possible to extract [Float] from IO [Float]?
05:00:24 <bollu> so, wait given C -> presheaf(C) ...
05:00:25 <bollu> ?
05:00:30 <orion> Axman6: It would be nice if someone created a service like Lambda that supported Haskell as a first class citizen.
05:00:41 <Cale> bollu: Here, let me point you at Awodey's book, it's so much more coherent than I can be right now -- I have to get ready for the day
05:00:41 <ertes> zedik: it's possible to do what you want to do, but it doesn't involve "extraction" in that sense
05:01:08 <Insanity_> How would I go about getting a Key from a Data.Map when I have the value?
05:01:15 <Axman6> orion: yeah I agree - would be tricky though (if anyone could do it'd be Facebook and their hot code loading stuff used in Sigma)
05:01:15 <zedik> Axman6: doesn't work
05:01:28 <Axman6> zedik: "doesn't work"?
05:01:35 <orion> Axman6: Why would it be tricky?
05:01:35 <bollu> Cale: I wish there was category theory for functional programmers
05:01:38 <lpaste> Insanity pasted “Data.Map get key by elem” at http://lpaste.net/181871
05:01:38 <ertes> zedik: IO is not a container or wrapper…  something of type (IO [Float]) is a program that produces a [Float] on execution…  the article i linked explains how to compose programs
05:01:41 <merijn> Insanity_: Turn it into a list and do a linear lookup?
05:01:53 <merijn> bollu: Did you see Bartosz' blog posts?
05:02:05 <zedik> Axman6: parse error on input ‘=’
05:02:20 <Axman6> zedik: there wasn't an = in the code I wrote =)
05:02:26 <zedik> ertes: OK! Thanks for the link, I will read it
05:02:38 <Axman6> replace let z = readvec... with z <- readvec...
05:02:40 <bollu> merijn: some of them yes
05:02:45 <bollu> merijn: they're disconnected IIRC
05:03:23 <zedik> Axman6: Works! Black magic
05:05:38 <Cale> bollu: anyway, to some extent, what y does, and the Yoneda lemma itself, is a bit of an implementation detail. The usually important consequence is that you have an embedding C -> Set^(C^op) which is faithful (doesn't send to arrows to the same place) and full (every arrow in Set^(C^op) between images of objects in C comes is the image of an arrow in C.
05:05:59 <Cale> bollu: and even the fact that Set^(C^op) itself is a bit of an implementation detail
05:06:32 <bollu> Cale: so you care about the fact that you can embed C into its' presheaf?
05:06:33 <Cale> The more important thing is that Set^(C^op) inherits lots of nice properties from Set -- in particular, being complete and cocomplete, having all exponentials, etc.
05:07:04 <Cale> Into the category of set-valued presheaves on C, if you like
05:07:41 * hackagebot conffmt 0.2.3.0 - A .conf file formatter  https://hackage.haskell.org/package/conffmt-0.2.3.0 (yamadapc)
05:07:49 <Insanity_> Thanks merijn, turning it to a list did it
05:07:53 <Cale> The objects of Set^(C^op) happen to be functors C^op -> Set, and the arrows between them are natural transformations
05:08:41 <bollu> Cale: wait, isn't Set^(C^op) ~= C^op -> Set? they're different?
05:09:02 <Cale> Set^(C^op) is a category
05:09:09 <bollu> I see >_<
05:09:25 <bollu> Cale: it's an exponential category?
05:09:26 <Cale> If you like to write C^op -> Set to mean a particular category of functors
05:09:38 <Cale> then they're not just isomorphic, but equal
05:09:42 <rcschm> aren't they isomophic?
05:09:56 <rcschm> oh ok
05:10:03 <merijn> rcschm: Equal is more specific than isomorphic
05:10:09 <rcschm> yeap.
05:10:12 <MarLinn> Explanations of the basics of IO interwoven with a discussion of the yoneda lemma... only on #haskell.
05:11:14 <bollu> Cale: what are the elements of Set^(C^op)? are the the functors themselves? or something else that is ismoporhic to the functors?
05:11:27 <bollu> in the sense of, a linear map of V -> W can be though of as living in a V* \tensor W
05:11:31 <bollu> but they're not the "same"
05:12:08 <Cale> Well, it's a category whose objects are functors C^op -> Set, and whose arrows are all the natural transformations between them
05:12:22 <bollu> I see
05:12:26 <bollu> interesting
05:12:27 <bollu> hm
05:12:30 <rcschm> can you talk more about tensor, bollu?  being tensorial ~= Monoidal right?
05:12:51 <bollu> rcschm: my notion of "tensor" is from multilinear algebra :)
05:13:08 <bollu> rcschm: but the short idea  is that, rather than thinking of f: V -> W as a linear map
05:13:34 <rcschm> i try to understand that but i still have no grasp of it.
05:13:45 <ertes> MarLinn: i remember Cale complaining that i started a short graphics demo with "main = lowerCodensity $ …" at least once, though it was probably more a note than a complaint =)
05:13:59 <Cale> bollu: and you can leverage a bunch of theorems of the form that D^C has some nice property whenever D has that nice property in order to conclude that Set^(C^op) is going to have a whole bunch of nice properties even if C is garbage
05:14:23 <bollu> ertes: I still think Codensity is magic :P it's crazy that it gives you a functor for any choice of the other type
05:14:26 <Cale> I wasn't complaining, I was pointing out that it was hilarious.
05:14:33 <Cale> There's a difference :)
05:14:38 <bollu> Cale: why's it hilarious? :) too abstract?
05:14:39 <ertes> hehe yeah
05:14:57 <ertes> bollu: i used it as poor man's ResourceT =)
05:15:01 <bollu> Cale: I see. hm, I want to understand 1. Yoneda 2. Kan extensions 3. Applicative
05:15:17 <bollu> Cale: Applicative from the cat. theory point of view :P
05:15:38 <bollu> ertes: TIL about resourceT
05:15:39 <Cale> bollu: The details of 3 are easier than the details of the first two things
05:15:52 <ertes> "TIL"?
05:15:52 <Cale> Well, depends on your perspective
05:15:54 <bollu> Cale: interesting. I assumed 3 would be hardest for some reason
05:15:58 <bollu> ertes: "Today I learnt" :)
05:15:59 <merijn> ertes: Today I Learned :)
05:16:01 <ertes> ah
05:16:01 <boj> bollu: these terms are way over my head. what does one gain by learning those in particular?
05:16:04 <ertes> thanks
05:16:10 <merijn> ertes: TYL ;)
05:16:12 <rcschm> Kan extension deals with ends and coends, doesn't it?
05:16:17 <ertes> indeed =)
05:16:22 <bollu> boj: which ones? the terms I just listed? they're part of category theory
05:16:23 <Cale> boj: Basically, if you only care about Haskell, not much
05:16:31 <bollu> I understand limits, but not ends
05:16:36 <boj> ah ok, thanks :)
05:16:45 <bollu> limits make sense - they let you "reflect" a copy of some structure in another
05:16:52 <ertes> (\acquire release -> Codensity . bracket acquire release) :: IO a -> (a -> IO b) -> Codensity IO a
05:17:05 <ertes> my favourite resource manager =)
05:17:13 <rcschm> from what i understand, end is the limit but we need to talk about the dual.
05:17:18 <rcschm> so we have coend.
05:17:25 <rcschm> colimit.
05:17:36 <Cale> boj: We've gotten a lot of mileage out of stealing ideas from category theory, and you can understand the things which have been stolen without understanding any CT.
05:17:37 <lpaste> Insanity pasted “FindMultiple” at http://lpaste.net/181876
05:18:01 <Insanity_> I have some code to mess around with Haskell, to find the first number that is evenly divisible by the number 1->10 
05:18:11 * ertes .o(what category talk must sound like, if you listen to it out of context)
05:18:20 <Cale> boj: But if you want to either do more stealing yourself, or you care about other mathematical disciplines or applications of category theory to other areas of computer science, then it might be worth learning category theory proper.
05:18:28 <Insanity_> It's in that paste, but I have some questions if you don't mind. First of all, this is probably not the best way to do this in Haskell, right? 
05:18:45 <Insanity_> And second of all.. I can't do that with an infinite list, so how would I have done this assuming I did not know the answer was  < 3000?
05:18:56 <bollu> Cale: software foundations book was bugged in chapter 4
05:19:00 <bollu> Cale: I think they updated it
05:19:03 <boj> Cale: that makes sense, thanks. i have no math background, i think haskell has taught me more than i ever learned in uni about it
05:19:39 <boj> which isn't saying much as a liberal arts student :)
05:20:37 <boj> this stuff is infinitely fascinating though. my goal is to understand at least half the terms people say here
05:20:38 <ertes> Insanity_: first understand the problem: try to reword it such that you talk about multiples instead of divisibility
05:20:57 <ertes> "visible by 2" → "a multiple of 2"
05:21:02 <ertes> "divisible by 2" → "a multiple of 2"
05:21:47 <lyxia> [w | w <- [(x,y) | x <- [10..3000], y <- [2..10]], mod (fst w) (snd w) == 0 ]          [(x,y) | x <- [10 .. 3000], y <- [2 .. 100], x `mod` y == 0]
05:22:42 <Insanity_> Mhm okay ertes, the first number that is a multiple of all of them
05:22:51 <Cale> The first part of this lecture (as it happens by the author of my favourite intro book on the subject) does a good job in describing what it's generally about https://www.youtube.com/watch?v=ZKmodCApZwk
05:22:58 <ertes> Insanity_: now find another word for "first"
05:23:00 <bollu> Cale: which book?
05:23:12 <Cale> Awodey's book called "Category Theory"
05:23:46 <Cale> Those lectures he gave are introductory, but move quite fast
05:23:50 <merijn> He gave a set of (freely available) lectures at OPLSS too
05:23:55 <bollu> merijn: OPLSS?
05:23:56 <M2tias> check the first comment on that youtube page :D
05:23:58 <Cale> Yeah, that's what I linked
05:24:05 <merijn> bollu: Oregon Programming Languages Summer School
05:24:09 <bollu> oh, so, we have a prof here who apparently works on the Langlands program (Rajat Tandon)
05:24:23 <bollu> I want to have a rough idea on what it's about before I go talk to him about it
05:24:35 <bollu> he teaches number theory and is really good at it, but.. he's seems legit "crazy"
05:24:52 <bollu> can anyone ELIundergrad langlands program?
05:25:10 <Insanity_> @ertes I don't immediatly get what you are hinting at mh
05:25:10 <lambdabot> Unknown command, try @list
05:25:20 <Cale> M2tias: Yeah, that guy in the first comment has a valid criticism of the talk, but I think they would be more understanding if they understood better the audience which was in that room
05:25:24 <Insanity_> I need to stop writing that before names
05:25:29 <ertes> Insanity_: the "first" number is the "least" number
05:25:51 <Cale> (which consisted mostly of computer scientists -- the point of the lectures was just to provide a motivational starting point)
05:26:10 <ertes> Insanity_: the least number that is a multiple of all of them…  if you think back, you probably had this exact problem in school at some point =)
05:26:22 <ertes> Insanity_: does that ring a bell?
05:26:58 <ertes> Insanity_: if not, allow me to give you a little math quiz:  1/12 + 1/15 = ?
05:28:20 <bollu> also, what companies other than Galois and Jane Street offer Haskell internships for summer?
05:28:30 <bollu> I applied to these two, but I was wondering about others
05:29:19 <merijn> bollu: I doubt Jane Street offers haskell internships?
05:29:25 <bollu> merijn: OCaml
05:29:30 <bollu> merijn: decently close :)
05:29:37 <Insanity_> so we are looking for the common multiples mh
05:29:59 <MarLinn> Insanity_: There's a fun(ction) for that!
05:30:02 <ertes> Insanity_: the least common multiple, yeah…  and that one happens to be built-in
05:30:10 <ertes> > lcm 12 15
05:30:11 <Insanity_> oh really.. nice :P
05:30:13 <lambdabot>  60
05:30:31 <ertes> Insanity_: now see how to apply it to a list, as opposed to only two arguments
05:30:44 <Insanity_> Thanks ertes :D
05:30:49 <mniip> needs more extended euclidean algorithm
05:31:11 <MarcelineVQ> I didn't know about lcm, that's neat ertes
05:31:15 <Jenaf> I have a question:
05:31:17 <Jenaf> https://gist.github.com/anonymous/c66603119cdd4abb141643bc4849387b
05:31:19 <MarLinn> @quote clsmith Prelude
05:31:19 <lambdabot> clsmith says: i find programming in haskell is mostly about reinventing things and then discovering them in Prelude
05:31:30 <Jenaf> line2 is wrong, what would be the right code for it?
05:31:57 <ertes> well, it's pretty easy to go from gcd to lcm, so i guess they figured they could just add it to the Prelude =)
05:32:17 <ertes> > let myLcm x y = x*y `div` gcd x y in myLcm 12 15
05:32:19 <lambdabot>  60
05:32:24 <Jenaf> (Float -> Float -> FPoint) is a signature here for what I use for relative coordinates 
05:32:30 <mniip> @let egcd :: Int -> Int -> Int; egcd a b = go a b 1 0 where go pr 0 ps s = ps; go pr r ps s = let q = pr `quot` r in go r (pr - q * r) s (ps - q * s)
05:32:33 <lambdabot>  Defined.
05:34:01 <Hi-Angel> How is that possible that the code "import Yi.Completion (completeInList')" does actually imports more functions? E.g. "prefixMatch, infixMatch", from the same module. Shouldn't they be hidden? o.o
05:34:12 <ertes> :t quotRem
05:34:13 <lambdabot> Integral a => a -> a -> (a, a)
05:34:14 <ertes> mniip: ^
05:34:33 <mniip> ertes, how does that help
05:34:50 <merijn> mniip: Saves some operations
05:35:01 <mniip> I think it's cleaner with explicit subtraction
05:35:08 <ertes> let (q, y) = quotRem pr r in go r (pr - y)
05:35:22 <mniip> ertes, what about ps - q * s
05:35:25 <ertes> mniip: the subtraction doesn't go away, just the multiplication
05:35:44 <ertes> you still need that one
05:35:48 <mniip> er
05:35:52 <mniip> itym 'go r y'
05:35:58 <jekor> Is this sort of "rollback" behavior expected when combining MonadCatch and StateT? https://gist.github.com/jekor/73624523cdc156173d0048c83496b0fc
05:36:05 <ertes> oh, of course =)
05:36:08 <ertes> my bad, sorry
05:36:47 <mniip> > egcd 3 7
05:36:49 <lambdabot>  -2
05:37:05 <Jenaf> If I have foo:: t1->t2 and bar :: t3 -> t2 ->t2; how can I make a function to apply the partial application of bar to the output of foo?
05:37:28 <Cale> M2tias: except, I should add, the part where he goes completely off the rails and basically defines a category to be an equivalence relation.
05:37:29 <Cale> lol
05:37:33 <bollu> Cale: how do we find the correct "yoneda function" for a given category C?
05:37:37 <mniip> Jenaf, \x -> bar x . foo
05:37:41 <bollu> functor*
05:37:58 <Cale> bollu: It's always yZ = C(-,Z)
05:38:01 <mniip> in theory you can write (. foo) . bar
05:38:03 <mniip> but you don't want to
05:38:10 <bollu> Cale: yZ is?
05:38:11 <Jenaf> https://gist.github.com/anonymous/c66603119cdd4abb141643bc4849387b
05:38:17 <Jenaf> mniip: that did not work
05:38:22 <MarLinn> or ((.).(.)) foo bar ...
05:38:28 <Cale> y is the functor you're asking about
05:38:43 <bollu> Z is in C?
05:38:49 <Cale> yeah, an *object* in C
05:38:56 <ertes> Jenaf: \x -> bar x . foo
05:39:04 <bollu> I'm supposed to find y: C -> Set^(C^op) right?
05:39:08 <mniip> MarLinn, wrong
05:39:17 <Cale> and C(-,Z) is the functor C^op -> Set which sends an object X in C to the set C(X,Z) of arrows X -> Z
05:39:25 <MarLinn> Whoops
05:39:30 <mniip> flip(.)
05:40:03 <Cale> and which sends an arrow a: X -> Y in C, which is an arrow Y -> X in C^op to the function C(a,Z): C(Y,Z) -> C(X,Z) 
05:40:10 <Jenaf> ertes: isn't that the same as in my gist snipplet? 
05:40:29 <Jenaf> did I get the signature wrong?
05:40:35 <ertes> hlint has all those controversial warnings that make you avoid parentheses and other readability aids at all costs
05:40:46 <ertes> but it doesn't care about ((.) . (.))
05:40:48 <bollu> Cale: C(-, Z)(X) = Hom(X, Z)?
05:41:22 <Cale> Yeah, I'm using the convention where we use the name of the category rather than "Hom", just because there's a lot of different "Hom"s in this discussion
05:41:43 <bollu> Cale: I see
05:41:54 <ertes> Jenaf: coord is a function of three arguments
05:41:54 <bollu> Hom_C(X, Z) to be most precise right?
05:41:56 <Cale> There's the Hom for C, the Hom for Set, the Hom for C^op, the Hom for Set^(C^op)...
05:42:04 <bollu> right
05:42:09 <Cale> Well, C(X,Z) is exactly as precise as that
05:42:18 <Cale> But yeah, sometimes people will subscript too :)
05:42:36 <bollu> :) cool. I hadn't seen the notation where C(X, Z) means the hom-set in C of X and Z
05:42:44 <bollu> thanks a ton! I'll take some time to digest this and get back
05:42:50 <Jenaf> ertes: huh? coord:: Float->Float->Fpoint
05:43:01 <Jenaf> as far is I understood the signature I wrote
05:43:01 <Cale> bollu: So think about what that function C(a,Z) is doing
05:43:11 <Cale> bollu: and think about how this is a functor
05:43:21 <ertes> Jenaf: yes, so it takes three arguments
05:43:32 <bollu> Cale: very well :)
05:43:38 <Jenaf> it mapes two floats to a point
05:43:52 <Jenaf> thats two arguments in my world
05:43:54 <Cale> bollu: So in particular, we should have that C(a,Z) . C(b, Z) = C(a . b, Z) and that C(id_X, Z) = id_(C(X,Z))
05:44:03 <Cale> So make sure to check those facts :)
05:44:05 <Jenaf> <- confused
05:44:22 <merijn> Jenaf: What's "Fpoint"?
05:44:36 <merijn> Jenaf: If "Fpoint" is an alias for a function, then it takes 3 arguments
05:44:38 <Cale> bollu: Oh, but be careful with what I just wrote :)
05:44:46 <ertes> Jenaf: imagine that you live in a parallel universe where i'm not too tired to type "two" when i mean "two" =)
05:44:47 <Jenaf> type Fpoint = (Float,Float)
05:44:51 <ertes> Jenaf: sorry
05:44:52 <Cale> bollu: the composition a . b is a composition in the opposite category, remember
05:44:57 <bollu> right, damn
05:45:01 <bollu> C^op -> Set
05:45:11 <Cale> bollu: So that's b . a if you're thinking about the arrows in C
05:45:22 <ertes> Jenaf: but yeah, that's the problem:  it takes two arguments (not three)
05:45:23 <Cale> and you will see why as soon as you unfold the definitions a bit :)
05:45:50 <Jenaf> fCoordRescale :: Float -> (Float -> Float -> FPoint) -> (Float -> Float -> FPoint)
05:46:02 <Jenaf> fCoordRescale s coord =(fPscale s).coord--something is wrong here
05:46:11 <Jenaf> -- fPslale :: Float -> FPoint -> Fpoint
05:46:25 <ertes> Jenaf: this would work:  fCoordRescale s coord = fPscale s . coord 0
05:46:51 <merijn> Jenaf: oh, right
05:47:01 <merijn> Jenaf: Note that . composes only one argument
05:47:03 <ertes> but what you really need is:  fCoordRescale s coord x y = fPscale s (coord x y)
05:47:21 <Jenaf> yeah
05:47:22 <Cale> Well, I say "unfold the definitions", but really I mean "invent the definitions", since that's the exercise :)
05:47:33 <ertes> Jenaf: you could get rid of the 'y' using (.), but in this particular case i suggest you don't
05:47:38 <Cale> There's only one thing which naturally fits here though, so it's a fair exercise
05:47:52 <ertes> fCoordRescale s coord x = fPscale s . coord x
05:49:18 <Jenaf> well I though if you had a function :: smonething -> t0 and another function t1 -> t0 -> t0 ; chaining them together would be quite a standard problem In HOP so i hoped for en operator wich does that for me
05:49:46 <Jenaf> because fPscale s :: FPoint->FPoint
05:49:59 <ertes> Jenaf: the number of possible patterns scales up very quickly
05:50:05 <merijn> Jenaf: .: is a common version of that, but personally I'd avoid that
05:50:08 <Cale> bollu: So first of all, what is this function C(a,Z): C(Y,Z) -> C(X,Z) doing?
05:50:18 <Cale> oh, oops
05:50:22 <Jenaf> anyway I gotta be afk short
05:50:24 <Jenaf> brb
05:52:12 <Ashy> ive got an issue with yesod where "stack exec yesod devel" is reporting the error "ERROR: Yesod has been compiled with a different GHC version, please reinstall yesod-bin"
05:52:30 <Jenaf> re
05:52:42 * hackagebot symon 0.1 - Minimal implementation(s) of the classic electronic memory game.  https://hackage.haskell.org/package/symon-0.1 (SimonMichael)
05:52:46 <Ashy> but "stack exec which yesod" shows that it's from lts-6.4 which is the same as my project
05:53:02 <Jenaf> it's basically just making a new function wich puts the output of the first through the second function
05:53:48 <merijn> Jenaf: Except that's not something you can sensibly describe in haskell
05:54:03 <merijn> Jenaf: How does the compiler know whether the function is supposed to return a function or not
05:54:13 <Jenaf> the signature ...
05:54:31 <Jenaf> fCoordRescale :: Float -> (Float -> Float -> FPoint) -> (Float -> Float -> FPoint)
05:54:54 <Jenaf> at least thats what I hoped for
05:55:24 <merijn> Jenaf: No, I mean, how does composition know whether "Float -> Float -> FPoint" is supposed to have "Float -> FPoint" or "FPoint" as result?
05:55:28 <Jenaf> and I thought that it does not need to be clear if a thunk is a function or data?
05:55:55 <merijn> Thunks are completely unrelated to any of this :)
05:56:16 <MarLinn> Jenaf: Just take the case of one two-argument and one three-argument function like in your case. Then shuffle all the types around in all possible ways. Now find the minimal set of unique combinators you need...
05:56:16 <Jenaf> merijn: isnt Float->Float->FPoint short for Float->(Float -> FPoint)
05:56:16 <merijn> Jenaf: You seem to be asking "why does (.) only consume one argument of the right hand function?"
05:56:27 <merijn> :t (.)
05:56:29 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:56:57 <ertes> no, i think Jenaf would just prefer to have this particular composition pattern predefined
05:56:58 <Jenaf> okay that makes things clearer
05:57:23 <Insanity_> ertes, once again thank you btw. I went with : foldl (lcm) 1 [1..10] 
05:57:30 <merijn> Jenaf: So the only thing you can sensibly do is "consume one argument" and use that as input to the next
05:57:47 <ertes> Insanity_: great =)
05:57:50 <Jenaf> (b->b)->(x->b)->(x-b) is basically what I need 
05:57:53 <ertes> glad to help
05:58:03 <merijn> Jenaf: So if 'b = Float -> FPoint' (like here), it goes wrong when the function you compose with expects "FPoint" instead of "Float -> FPoint" :)
05:58:05 <Jenaf> (b->b)->(x->b)->(x->b) is basically what I need 
05:58:27 <jgzh6> Someone here might remember I asked how to fix my function so that it can work with Text or ByteString
05:58:33 <ertes> Jenaf: you could of course work around the issue entirely and use the vector types from the 'linear' library =)
05:59:38 <Jenaf> ertes: but then I had to throw away 60% of all the code I wrote ( vector operations)... (wich would be the reasonable thing to do... but eh... now i encountered this problem i want to learn how to solve it)
05:59:39 <jgzh6> Everyone said String Text conversion is nothing to do with Unicode encoding. 
05:59:46 <jgzh6> That's true.
06:00:04 <Jenaf> <- is only writing this code for recreational purposes ^.^
06:00:05 <jgzh6> I tested it on Ubuntu and it works without any problem.
06:00:07 <Jenaf> at the moment
06:00:39 <jgzh6> It was Windows that could not deal with such conversions.
06:00:40 <ertes> Jenaf: on the other hand you learn how many linear algebra patterns are covered by classes like Applicative and Foldable =)
06:00:41 <merijn> Jenaf: If you know in advance how many arguments you want to compose, like 2 in this case, nothing stops you from writing a custom composition operator that does work
06:00:59 <Jenaf> so yeah using an existing libary should in most cases be prefered to personal solutions
06:01:20 <ertes> @let dotProduct xs ys = foldl' (+) 0 (liftA2 (*) xs ys)
06:01:22 <lambdabot>  Defined.
06:01:26 <merijn> :t let f ☃ g x y = f (g x y) in (☃)
06:01:28 <lambdabot> error: Parse error in pattern: g
06:01:31 <merijn> hmm
06:01:33 <merijn> oh, right
06:01:46 <merijn> :t let (☃) f g x y = f (g x y) in (☃)
06:01:47 <lambdabot> (t -> t1) -> (t2 -> t3 -> t) -> t2 -> t3 -> t1
06:02:03 <sm> cabal install can't see the recently uploaded https://hackage.haskell.org/package/symon-0.1, any idea why ?
06:02:04 <MarLinn> :let result = (.)
06:02:13 <ertes> sm: cabal update
06:02:20 <sm> after cabal update, I mean
06:02:26 <Xnuk> @let result = (.)
06:02:27 <lambdabot>  Defined.
06:02:35 <ertes> sm: wait two minutes, update again
06:02:42 <MarLinn> Ah, yes
06:02:43 <sm> hmm, ok
06:02:46 <merijn> :t let (☃) f g x y = f (g x y) in fst ☃ (,) 
06:02:47 <lambdabot> t -> b -> t
06:03:02 <MarLinn> :t \f g -> result f . g
06:03:04 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
06:03:07 <dcoutts> sm: CDN caching
06:03:09 <ertes> sm: i think hackage has quite a noticable delay before it updates the index
06:03:22 <sm> ahh CDN. Yes it used not to do this
06:04:13 <sm> does hackage need a CDN to be running full time ?
06:04:22 <ertes> :t dotProduct
06:04:24 <lambdabot> (Foldable t, Applicative t, Num b) => t b -> t b -> b
06:04:32 <ertes> Jenaf: ^
06:05:20 <Xnuk> > [1,2,3] `dotProduct` [4,5,6,7]
06:05:22 <lambdabot>  132
06:05:30 <sm> something for #hackage I guess
06:05:41 <ertes> @let data V2 a = V2 !a !a  deriving (Eq, Foldable, Functor, Generic, Ord, Show, Traversable)
06:05:43 <lambdabot>  .L.hs:160:44: error:
06:05:43 <lambdabot>      Not in scope: type constructor or class ‘Generic’
06:05:48 <MarLinn> "result" is from Conal Elliots "editor combinators" and a nice way to think when making custom combinators
06:05:53 <ertes> @let import GHC.Generics
06:05:55 <lambdabot>  Defined.
06:05:58 <ertes> @let data V2 a = V2 !a !a  deriving (Eq, Foldable, Functor, Generic, Ord, Show, Traversable)
06:06:01 <lambdabot>  Defined.
06:06:21 <dcoutts> sm: hackage specifies max-age=300 for the index tarball
06:06:30 <ertes> d'oh…  lens again
06:08:09 <arkaros> Hi awesome people. I have been given the oportunity to rewrite some python services in another language. I have done some hobby projects in haskell and thought it might be fun to try it out. I have a pretty clear idea of how to do it but the main thing i feel like i'm missing is a way of handling database migrations in a nice way. I really dislike ORMs in general and would much rather write my own sql queries in sql or in some sort of
06:08:09 <arkaros> DSL for sql. If someone have any recommendations for libraries to handle this i would be very happy :)
06:09:21 <dcoutts> sm: the CDN particularly helps with tarballs, docs etc, and keeps the load on the primary server pretty low
06:09:25 <Cale> arkaros: sigh, there's nothing I'm 100% happy with in this space yet, but what we've been doing is using groundhog almost just for its automated migrations, and then using psql-simple to write queries.
06:09:44 <Cale> Sorry, postgresql-simple
06:09:56 <dcoutts> sm: I'm afraid the latency is going to go up a bit though, e.g. ~15min once we fully deploy the mirrors
06:10:31 <Cale> arkaros: The trouble with writing your own queries in SQL though is that bugs in your SQL are runtime errors.
06:10:53 <dcoutts> sm: still better latency than one gets with stack though ;-)
06:11:19 <Cale> arkaros: usually just doing a few tests will root the worst of them out, but still...
06:11:36 <Cale> It sucks when a *syntax* error makes it through to runtime
06:11:47 <tero-> arkaros: Database.Esqueleto is good
06:12:11 <arkaros> Cale: Yeah. But in my experience ORMs end up hurting you more than helping you because as soon as i try to run anything remotely advances it compiles into multiple queries in the background. Maybe it's just me using it wrong.
06:12:13 <Cale> However, in my experience, you typically do end up wanting to write the queries directly in SQL
06:12:26 <arkaros> Cale: But groundhog looks promising. I will check it out.
06:12:28 <Cale> because e.g. groundhog doesn't even support joins
06:12:41 <Cale> yes, that is very much the problem
06:13:02 <Cale> It won't lie to you in this case, it just won't let you express the joins in the first place
06:13:36 <Cale> So you'll be totally aware of the cases where you ought to be doing something better -- sometimes it's nice to write the simple queries using groundhog directly.
06:13:38 <arkaros> Haha i guess that's better though.
06:13:39 <sm> dcoutts: ack.. thanks
06:15:36 <arkaros> Thank you all for your awesome help :)
06:16:08 <Cale> arkaros: and the sad part is that I can't even say I'm particularly in love with the way that groundhog handles migrations, in that you tend to describe your schema in this awkward and not-very-well-described yaml format -- it's not *so* bad, but groundhog doesn't do a great job of checking that everything it finds there makes sense, so you can write something which it doesn't understand and it'll just ignore it
06:16:43 <Cale> But hey, it's nice when you can fire up your program and have it look at the tables and compute a migration for you.
06:17:01 <Cale> (and carry out that migration automatically in cases where it's safe to do so)
06:17:11 <tero-> bbbbI've been happy with ffffffffDatabase.Persist migrations 
06:18:14 <tdammers> my preferred way of doing migrations is writing them by hand, in up/down pairs, and then have some tooling in place to manage those
06:18:19 <Cale> tero-: Yeah, persistent and groundhog are practically the same thing, they're forks of the same codebase
06:18:22 <joe9> I am drawing a chart using gtk2hs. Just want to check if there is a haskell library to help with scale? something like https://github.com/d3/d3-scale/blob/master/src/linear.js
06:18:29 <tero-> Cale: ah, ok
06:18:29 <tdammers> *maybe* some support in writing the migrations, in the form of a DSL or something
06:18:49 <tdammers> but I certainly don't want to have a tool try and derive possible migration paths based on incomplete information
06:19:26 <MarLinn> persistent also has a nice way to define schemas with TH
06:19:41 <dcoutts> joe9: I'm not aware of anything, but there may be code from ThreadScope you can steal
06:20:30 <Cale> tdammers: Well, that's probably the more sound way to operate in production, but it would be a real hassle in development when your schema is changing on a daily or weekly basis
06:20:42 <Cale> (in early development)
06:21:01 <joe9> dcoutts: Thanks.
06:22:46 <tdammers> Cale: true, but then, that phase is short and you don't need to do proper migrations during exploratory coding, you can afford to just throw the entire DB away and start from scratch
06:23:16 <tdammers> and if experience has taught me anything, it is that getting these things out of the way early is something you never regret
06:23:37 <Cale> tdammers: It's kind of just good at solving the stupid problem where one developer on the team is adding some feature and they need some new columns or a new table, and it's going to mean that all the other devs on the team need to screw around with or just delete their db to get the thing to run.
06:24:31 <MarLinn> Cale, tdammers: Do you have an opinion on opaleye? It seemed to stand out in some discussions, but I'd rather trust someone who actually has to use stuff
06:24:33 <tdammers> Cale: yeah, ofc... my situation was never such that I did a multi-person explorative coding thing though; on every project I worked on, the moment we grew to more than one programmer was after the exploratory phase
06:24:39 <Cale> But yeah -- throwing the DB away is a fair option, but it does mean you need to have a mechanism in place earlier on to throw lots of test data in
06:24:54 <tdammers> yes
06:24:57 <ltcmelo> does anyone know whether I can get a haskell grammar for an LL(k) parser, with a well defined k?
06:25:16 <Cale> (which is arguably a good thing to put in early anyway)
06:25:18 <tdammers> oh, also, in such an early phase, the manual way (send your fellow dev an e-mail with the update script in it if you have to) isn't too lousy either
06:25:21 <arkaros> tdammers: We actually do this now. We use a node module called grunt-db-migrate and handle the database using up and down migrations like that. It works perfectly fine
06:25:33 <tdammers> and yes, throwing in test data instrumentation early is also good
06:25:54 <tdammers> arkaros: indeed. Extra kudos if the state of migrations is stored in the database itself
06:26:06 <tdammers> arkaros: ...but the *desired* state is stored in source control
06:26:22 <tdammers> arkaros: and versioning is more sophisticated than just sequentially numbering your migrations
06:26:33 <ltcmelo> by a quick inspect in haskell report, an LL(1) parser doesn’t seem feasible, I wonder if there’s some LL(n) known grammar
06:27:16 <tdammers> MarLinn: haven't used opaleye myself; my opinion of the approach is twofold - one part of me says, type-safe SQL queries, woot; the other part says, let SQL be SQL, it's a very good DSL for expressing relational database interactions
06:27:36 <tdammers> (relevant: https://bitbucket.org/tdammers/yeshql)
06:28:47 <ertes> people will probably rip me apart for this, but:  i've done migrations simply by attempting to add all columns and ignore the potential "already exists" error =)
06:29:23 <Cale> MarLinn: I don't really have experience with it. Ryan Trinkle (who I usually trust with respect to the practicality of things) seemed to have a negative opinion, but I can't recall exactly why that was.
06:30:53 <MarLinn> Ok, so I will be cautious when trying it out. Got it. Thanks!
06:31:31 <Cale> MarLinn: I think it was that it forced you into this style where your records on the Haskell side of things could only consist of a bunch of distinct variable fields
06:32:05 <Cale> MarLinn: and then the column types would all appear everywhere
06:33:36 <Cale> Like, you can't just have  data Item = Item { style :: PGText, colour :: PGText, location :: PGText, quantity :: PGInt4, radius :: PGFloat8 }
06:33:41 <Cale> You need to write
06:34:00 <Cale> data Item a b c d e = Item { style :: a, colour :: b, location :: c, quantity :: d, radius :: e }
06:34:30 <Cale> and then you end up using types like Table (Item (Column PGText) (Column PGText) (Column PGText) (Column PGInt4) (Column PGFloat8))
06:34:49 <Cale> and re-explaining throughout your code what the types of those columns are
06:35:41 <MarLinn> ...and then that might get exponentially more ridiculous with something like opaleye-sot which adds even more paranoia on top
06:36:00 <tdammers> ertes: if all you ever do is add columns, then that's fine, but as soon as you need to delete columns, rename columns, change constraints, etc., things get hairy
06:37:11 <ertes> tdammers: i tend not to make adjustments that require destructive/non-idempotent operations
06:37:21 <MarLinn> I do begin to see the potential benefits of something like YeshQL
06:37:38 <ertes> tdammers: and if i do, i'll gladly do those manually and very carefully
06:38:06 <tdammers> well, but "manually" is actually bad, because you can't automate the tests for those operations
06:38:35 <tdammers> with automatic migrations, you can: 1) dump a production database, 2) load it into the test server, 3) run the migrations, 4) run your battery of automated tests
06:38:57 <arkaros> And good luck convincing the DevOps to manually run migrations on deploys
06:39:13 <Jenaf> okay, workaround; instead of Float->Float->FPoint its FPoint->FPoint (FPoint::(Float,Float)) now
06:39:15 <tdammers> but if step 3 is manual, such a test is weak, because there is nothing to stop you from fat-fingering on the production system
06:39:20 <Jenaf> but I end up with lines like this:
06:39:21 <tdammers> or, worse, fat-fingering during testing
06:39:22 <Jenaf> ((coord (  0 ,   0 )),(coord(  0 , (-1))))
06:41:47 <saolof> Is an instance of monad plus automatically an instance of Alternative? I.e. can I write <|> for monadplus?
06:42:05 <saolof> * for mplus
06:42:10 <tdammers> :info Alternative
06:43:07 <ertes> tdammers: yeah, that's true
06:43:20 <ertes> but then i'm not aware of a pure migration solution in haskell
06:43:29 <ertes> ("pure" in the sense of "only")
06:43:32 <ReinH> saolof: you can check by reading the docs on hackage
06:43:53 <tdammers> ertes: I whipped up something based on YeshQL myself in the past, works like a charm
06:44:16 <tdammers> downside of YeshQL is of course that type-safety of your queries is the programmer's responsibility (just like with FFI)
06:44:34 <tdammers> and that it doesn't abstract over the query AST at all, i.e., you write your queries as raw SQL strings
06:44:37 <ertes> as long as i can write secure SQL with it, i'm happy
06:44:44 <MarLinn> Jenaf: No instance for (Read problem) arising from the use of "tryingToUnderstand" in the first argument of "tryingToUnderstand problem MarLinn"
06:44:46 <tdammers> define "secure"
06:44:55 <ertes> tdammers: placeholders
06:45:00 <tdammers> oh, yeah, sure
06:45:18 <ertes> that's fine with me, i prefer writing SQL
06:45:21 <tdammers> it works on top of HDBC, and extends the parametrized query API to also support *named* parameters
06:45:22 <lyxia> saolof: ghci> :i MonadPlus      says     class (Alternative m, Monad m) => MonadPlus (m :: * -> *)    so, yes.
06:45:26 <Jenaf> dang I thought my MarLinn instance had the discussion from a few minutes ago still in memory
06:45:44 <Jenaf> I keep forgeting that those temp files vanish If i don't keep them up
06:45:50 <Jenaf> :-P
06:46:12 <MarLinn> Jenaf: I do, but I still don't get what's wrong. Sorry.
06:46:50 <tdammers> so you can write "SELECT username FROM users WHERE user_id = :userID AND access_level >= :accessLevel", tag it with type information, and it'll generate a function something like Integer -> AccessLevel -> Connection -> IO [Text]
06:47:02 <Jenaf> now it works ^.^ also the representation is now closer to the problem it tries to tackle
06:47:04 <MarLinn> I'm just a dumb provider of browser histories...
06:47:18 <Jenaf> but 4 close-parens in a row is not beautifull code
06:47:27 <MarLinn> Jenaf: It works? I see your problem! ;p
06:47:33 <Jenaf> XD
06:49:46 <MarLinn> So the problem is that it looks bad when you print? So... it's either a custom show function or wrapping in a newtype for a nice "normal" show
06:50:03 <ph88> hi guys
06:50:29 <ph88> how can i find out which thing failed in a monad ?
06:51:18 <Jenaf> that issue whan you need to multipy something by one half.. and tye a mix of 0.5 and 1/2 == 1/5; and the wonder why your code gives qierd output
06:51:56 <ski> MarLinn : not sure what you're up to, but in case you want a custom pretty-printing thing, then you should not use `Show' for that
06:53:00 <Cale> ph88: There are too many different monads which are too wildly different for that question to have an answer.
06:53:00 <MarLinn> ski: You mean because of the lie that read and write should be somewhat coherent?
06:53:06 <ski> (`Show' is for debugging purposes, and ought to generate a string representing a valid Haskell expression (in the appropriate environment) evaluating to the given value)
06:53:14 <ReinH> ph88: in general? You can't. There isn't even a coherent notion of failure in general.
06:53:45 <Cale> (despite the occurrence of the fail method in the class -- you can regard that as a mistake in the definition of the class)
06:53:54 <ski> MarLinn : well, `read (show x) = x' ought to hold for finite `x', yes
06:53:57 <Cale> (most monads don't sanely implement fail)
06:54:19 <ph88> i use megaparsec and i want to know "how much" of a parser succeeds. So for example when you parse foo, bar and then baz  the first 2 can succeed and the 3rd can fail so it would be a 66% success rate. How can i get this percentage ?
06:54:26 * ski . o O ( `MonadFail' )
06:54:38 <Cale> ph88: That's a better question :)
06:55:29 <Cale> ph88: I suppose you can use <|> at each stage to provide another option to the parser there, which will just be  return (Left something)
06:55:48 <MarLinn> > show (2 / 10 :: Rational)  -- ski
06:55:52 <lambdabot>  "1 % 5"
06:56:28 <MarLinn> almost, but not quite. But yes, I know there's a special intention
06:56:31 <ski> > 2 / 10 :: Rational
06:56:34 <lambdabot>  1 % 5
06:56:37 <ski> MarLinn : so, it's equal
06:56:46 <MarLinn> > 1 % 5
06:56:47 <ph88> Cale, then this other options would be all over the parser code and there is now no separation of concerns
06:56:48 <lambdabot>  1 % 5
06:57:12 <MarLinn> Ok, you must fudge the import
06:57:13 <ski> > (-1) % 5 + 2 % 5
06:57:16 <lambdabot>  1 % 5
06:57:29 <ski> (obviously there will be many ways to write an expression that evaluates to this value)
06:57:55 <MarLinn> I thought % wasn't an operator
06:58:01 <ski> > (reads :: ReadS Rational) "1 % 5"
06:58:03 <lambdabot>  [(1 % 5,"")]
06:58:10 <ski> it is
06:58:28 <ph88> Cale, also i would have to put case everywhere and check the results to see if the parser was a 100% success or otherwise
06:58:30 <ski> @type (%)
06:58:32 <lambdabot> Integral a => a -> a -> Ratio a
06:59:32 <ReinH> Cale: perhaps using a state monad? I don't see how you can get percentages though.
06:59:34 <Cale> ph88: Well, the parser doesn't have any intrinsic notion of how complete it is
07:00:06 <ReinH> That breaks composability
07:00:21 <MarLinn> ski: Now the question is: why? I get the debugging idea. But an exact representation? What if I have an ID that should have Show but not Read? Why should I be forced to think about poor man's serialisation?
07:00:38 <Cale> It either succeeds in consuming some initial segment of the input, or it completely fails.
07:00:40 <ph88> Cale, yes exactly, so i would like something else to "inspect" the parser and find out for how many % it did matched
07:00:55 <jakub_> i am getting an ambiguity error when compiling lens-4.14 with ghc-7.10 in Control.Lens.Traversal:823-824 take (Data.Map vs Prelude) and I do not get why (why isnt Data.Map imported with the keyword qualified?)
07:00:56 <ski> MarLinn : i don't understand the question
07:01:01 <Cale> You'll need a different kind of parser.
07:01:21 <ph88> can i generate the different kind of parser from the original parser ?
07:01:39 <cocreature> is there something like ForeignPtr but for “native” Haskell types, i.e., a way to associate a finalizer with some data that is executed when the data is garbage collected?
07:02:11 <MarLinn> ski: Why should I follow read (show x) == x ? 
07:02:24 <Cale> ph88: You might be able to use trifecta
07:02:37 <ph88> to do what ?
07:02:47 <Cale> Trifecta is another parser combinator library
07:02:51 <ph88> i know
07:03:06 <ReinH> I'm not sure how you would do it with trifecta either
07:03:14 <Cale> When it fails, it gives you a list of Deltas
07:03:21 <ph88> what would that give me that i don't have right now with megaparsec ?
07:03:28 <ph88> oh Deltas
07:03:30 <ph88> what are those ?
07:03:41 <ski> MarLinn : if you don't have a `Read' instance, then it doesn't apply. but i'd still argue that `show x' ought to give a string representing a Haskell expression that evaluates to (a value equal to) `x'
07:03:56 <ReinH> You still don't know how many parsers there are left
07:04:05 <Cale> Well, yeah
07:04:13 <Cale> But you can see how much of the input was eaten, perhaps
07:04:22 <TobyGoodwin> anyone know of a package that can validate a v4/v6 ip address? Network.Socket.inet_addr only appears to support v4
07:04:35 <Cale> Maybe I'm not understanding what we're going for
07:04:48 <ph88> Cale, the success of the parser does not depend on the input but on the amount of successful sub-parsers
07:04:49 <ski> MarLinn : because this is what `Show' is for. if you want some kind of custom display format, then define your own function, perhaps `displayFoo :: Foo -> String'. if you have many types where you want this, perhaps make a new type class for this. just don't use `Show'
07:05:17 <Cale> ph88: Ah, which means there has to be some well-defined notion of how many sub-parsers there are
07:05:29 <Cale> ph88: So you're giving up on being able to define parsers recursively?
07:05:49 <ReinH> I think you would need a fundamentally different type of parsers, but I don't know what that would look like
07:06:05 <ReinH> And I think you would lose compositionality
07:06:17 <ph88> Cale, when the sub-parser fails i don't have to count it's child parsers anymore, i can keep recursion
07:06:25 <Cale> Maybe it's sufficient just to build something like sequence
07:06:41 <ski> MarLinn : e.g. sometimes people want to display expressions in a nicely indented way, depending on a (customizable) line width. or sometimes they want to use some notation that's conventional in the domain area, e.g. `{2,3,5,7}' for (sub)sets ..
07:06:43 <Cale> but which succeeds even if one of the parsers fails, except that it reports which one
07:06:52 <Cale> (or how many were successful, which is the same0
07:06:54 <Cale> )
07:07:24 <ph88> suppose i do that, can i generate that sequence from a "normal" parser ?
07:07:38 <ph88> this feature is only suppose to kick in when an error was encountered
07:07:39 <Cale> i.e.  sequenceMaybe :: [Parser a] -> Parser (Either Int [a])
07:07:47 <ph88> to find the best possible match and give suggestion about the error
07:08:06 <ReinH> What are you actually doing?
07:08:50 <ph88> if a parser fails, but there are a few choices which should have been matched i want to find out which choice is closest to the orignal input
07:08:50 <MarLinn> ski: I get that Show is for debugging. So I shouldn't use random brackets or custom whitespace, but something that "plays well" with other expressions. Sure. But something that's readable as a Haskell expression... doesn't that go a bit far?
07:09:11 <ph88> therefor i need to know how much of each choice parser was valid
07:09:33 <ph88> and also i would like to inspect the parser strings and check lehvenstein distance to check for typo's
07:09:35 <ski> MarLinn : custom whitespace would strictly speaking be ok (though perhaps weird), as long as the result is a valid Haskell expression
07:10:02 <Tor_> I have read Learn You a Haskell for Great Good and want to do a small project where I interact with a postgre database and expose a http service with json resources. Very standard but I want to do something like that to get a real world feel for Haskell. Do you guys have any library recommendations?
07:11:03 <nitrix> For json, Aeson is popular. If you know very little Haskell, then Scotty is probably a good place to start for web development.
07:11:14 <ph88> Consider these 3 tokens "funtion", "foo", "{" which should be the start of a function declaration. And parser (in regex): "function" "\w+", "{". "funtion" fails because there is a typo (levhenstein distance is 1), second two tokens match, so this parser is a very good candidate.
07:11:24 <nitrix> Tor_: Both are going to be fairly painful if you don't at least understand a couple basic concepts like monads though.
07:11:50 <cloudhead> Tor_: you could start with postgresql-simple
07:12:04 <Cale> @let sequenceMaybe ps = sequenceMaybe' (zip [0 :: Integer ..] ps); sequenceMaybe' [] = return (Right []); sequenceMaybe' ((n,p):ps) = do v <- (Right <$> p) <|> return (Left n); vs <- sequenceMaybe' ps; return (liftA2 (:) v vs)
07:12:06 <lambdabot>  Defined.
07:12:10 <Cale> :t sequenceMaybe
07:12:11 <lambdabot> (Alternative m, Monad m) => [m t] -> m (Either Integer [t])
07:12:23 <Cale> ph88: ^^ perhaps this will serve?
07:12:32 <ph88> im gonna look at it
07:12:41 <Tor_> nitrix: I understand monads - have to read those chapters like three times, but I feel confident I got it now.
07:12:43 <ski> MarLinn : `Show' instances are built to "play along" with each other. for any `a', if `Show a', then automatically also `Show (Maybe a)' (and so on). so `show (Just x)' (with `x :: a') should make sense. if `show x' doesn't produce a Haskell expression, then `show (Just x)' will produce a weird mix of Haskell and non-Haskell
07:12:49 <nitrix> Tor_: Additional thought, there is in my opinion better than the LYAH book. Haskellbook.com (Which is a really good book) actually covers writing a web app too.
07:13:00 <Cale> ph88: So it takes a list of parsers, and turns it into a parser which gives you Either an Integer saying which one failed, or a list of all the results
07:13:18 <ski> MarLinn : this is also why you should normally define `showsPrec' in `Show', and not `shows' or `show'
07:14:31 <ski> (the exception to "normally" is in case your values are so simple so that you don't ever need to wrap them in brackets. this is the case for `Bool', but not for `Maybe', e.g.)
07:15:16 <ski> @let data Foo = MkFoo Int String
07:15:18 <lambdabot>  Defined.
07:15:39 <ph88> Cale, i would have to change the original parser no ?
07:16:00 <ski> @let instance Show Foo where show (MkFoo n s) = "MkFoo " ++ show n ++ " " ++ show s  -- this is an example of how to *not* make a `Show' instance
07:16:02 <lambdabot>  Defined.
07:16:03 <tsahyt> Hello! I was wondering whether there were any plans of making Semigroup a superclass of Monoid, now that it is part of base?
07:16:13 <Tor_> thanks nitrix and cloudhead. Will look into postgresql-simple, aeson and scotty.
07:16:40 <ski> > show (Just (MkFoo (-12) "hello"))  -- this now generates a broken string representation of a Haskell expression
07:16:43 <lambdabot>  "Just MkFoo -12 \"hello\""
07:16:56 <ski> > Just MkFoo -12 "hello"  -- doesn't work
07:16:59 <lambdabot>  error:
07:16:59 <lambdabot>      • No instance for (Num (Maybe (Int -> String -> Foo)))
07:16:59 <lambdabot>          arising from a use of ‘-’
07:17:09 <ski> @undefine
07:17:09 <lambdabot> Undefined.
07:17:12 <ski> @let data Foo = MkFoo Int String
07:17:14 <lambdabot>  Defined.
07:17:20 <nitrix> tsahyt: Yes, there has been many proposals with influential names, like Edward Kmett.
07:17:30 <nitrix> tsahyt: It's complicated, but the story has got a lot better in GHC 8.
07:17:48 <ramadoka> how does take and iterate works?
07:17:55 <hpc> @src take
07:17:56 <lambdabot> take n _      | n <= 0 = []
07:17:56 <lambdabot> take _ []              = []
07:17:56 <lambdabot> take n (x:xs)          = x : take (n-1) xs
07:17:59 <ski> @let instance Show Foo where showsPrec p = showParen (p > 10) $ showString "MkFoo " . showsPrec 11 n . showChar ' ' . showsPrec 11 s  -- the right way to do it
07:18:01 <lambdabot>  .L.hs:160:13: error:
07:18:01 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘String -> String’
07:18:01 <lambdabot>        Expected type: Foo -> ShowS
07:18:10 <ski> sorry, forgot the pattern
07:18:13 <tsahyt> nitrix: I suppose the problem is the same as with AMP, i.e. lots of code needs to change?
07:18:13 <hpc> ramadoka: taking nothing from any list is the empty list
07:18:16 <ramadoka> like take 3 $ iterate (+2) 3
07:18:17 <ski> @let instance Show Foo where showsPrec p (MkFoo n s) = showParen (p > 10) $ showString "MkFoo " . showsPrec 11 n . showChar ' ' . showsPrec 11 s  -- the right way to do it
07:18:19 <lambdabot>  Defined.
07:18:22 <hpc> ramadoka: taking something from an empty list is the empty list
07:18:41 <ski> > show (Just (MkFoo (-12) "hello"))  -- now both the number and the whole expression inside `Just' will be properly bracketed
07:18:42 <ramadoka> isn't it like (3:5:7:(unevaluated expression))
07:18:43 <lambdabot>  "Just (MkFoo (-12) \"hello\")"
07:18:43 <hpc> ramadoka: taking something from a non-empty list is taking the first element, then taking the next (something - 1) elements from the rest of the list
07:18:48 <ski> MarLinn ^
07:18:54 <ramadoka> how did the unevaluated expresionn become []
07:19:13 <lyxia> tsahyt: https://ghc.haskell.org/trac/ghc/wiki/BenGamari/ProposalMilestoneExample
07:19:36 <hpc> ramadoka: so you start with take 3 $ iterate (+2) 3
07:20:03 <lyxia> oh wait it's just an example of proposal *facepalm*
07:20:06 <ski> in this particular case, `showsPrec 11 s' could be simplified to just `shows s', since a string `s' will never need to be bracketed
07:20:33 <hpc> ramadoka: stepping through take once, we go down the patterns of take in order
07:20:41 <hpc> 3 is not <= 0 so the first case doesn't match
07:20:43 <tsahyt> lyxia: Interesting, a proposal proposal. I suppose it'll happen eventually.
07:20:50 <ReinH> ph88: you can't do this with your existing parser. It doesn't contain enough information to reconstruct the things you are asking for.
07:20:58 <ski> MarLinn : anyway, `Maybe' is just one simple example of what i mean by "play along"
07:21:05 <lyxia> tsahyt: https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid
07:21:05 <hpc> now we need to evaluate iterate's result enough to match against []
07:21:22 <ramadoka> oh, k, now I understand
07:21:24 <hpc> ramadoka: it evaluates to 3 : (iterate (+2) 5)
07:21:25 <ramadoka> damn
07:21:43 <hpc> ramadoka: which isn't [], we step into the next pattern and have 3 : (take 2 (iterate (+2) 5))
07:21:44 <MarLinn> ski: That's all well and good, but show'ing a vector (V 3 2) as "<3,2>" would not break show-consistency - provided I manage the bracketing correctly, of course. Show-Read-consistency... probably not
07:21:54 <nitrix> tsahyt: Yeah. Phase 1 for GHC 8 is done. Phase 2a is moving Semigroup to Prelude. Phase 2b is making Semigroup a superclass of Monoid. Phase 3 is deprecating mappend by removing all the instance implementations. Phase 4 is either removing mappend ocmpletely or making it a top-level binding.
07:21:58 <hpc> ramadoka: repeat until we're doing take 0, which ignores the rest of the list and produces []
07:22:02 <ramadoka> (y)
07:22:19 <hpc> ;)
07:22:20 <ski> MarLinn : `<3,2>' is not (and can't be) a valid Haskell expression
07:22:24 <ramadoka> i didn't realize it was that simple
07:23:02 <ph88> ReinH, which information do you think is missing ?
07:23:06 <ejbs> I'm writing a fn to get the average length of words in a sentence. This is easy to write recursively, but is there some kind of HoF that would help me do that in Haskell? It's kinda like a fold, except I need to carry with me the current word's length as I fold
07:23:10 <ski> MarLinn : otoh, you could probably manage to make a corresponding `Read' instance with `read (show v)' for any total `v :: V 3 2'
07:23:14 <tsahyt> about Phase 1, having Data.List.NonEmpty in base is a very nice thing in my opinion. At least now I don't shy away from denoting non-empty lists just because I don't want to pull in another dependency just for that.
07:23:22 <ski> er, with `read (show v) = v'
07:23:32 <hpc> ramadoka: it takes time to build up a good intuition about evaluation, but you'll get there :D
07:23:32 <nitrix> tsahyt: Some people don't like it. Only time will tell :)
07:23:36 <Cale> MarLinn: typically you want the Show instance to produce valid Haskell source code though.
07:23:49 <Cale> MarLinn: and leave other styles of printing to some other function
07:23:58 <tsahyt> nitrix: I don't see what's not to like about it. What's the problem?
07:24:22 <TobyGoodwin> anyone know of a package that can validate a v4/v6 ip address? Network.Socket.inet_addr only appears to support v4
07:24:33 <Cale> It's not always the case, but whenever possible, that's a good idea, because it helps that you can show something and immediately copy/paste it to use it for further testing.
07:24:56 <ramadoka> yeah, I was thinking something along the line, is it reversed first, and then reversed again or something wut.
07:25:54 <MarLinn> So basically, when I'm not automatically deriving Show I'm doing something wrong.
07:26:01 <TobyGoodwin> d'oh! /me finds Data.IP (i was browsing under Network...)
07:26:23 <lyxia> ejbs: isn't that just \words -> sum (fmap length' words) / length' words  with length' = fromIntegral . length
07:26:30 <tdammers> MarLinn: there are a few rare exceptions... Text, for example, has a good custom Show instance
07:26:59 <hpc> MarLinn: in general if your program's logic depends on the result of show you're probably doing something wrong ;)
07:27:05 <hpc> (probably)
07:27:11 <ejbs> lyxia: Maybe :)
07:27:29 <ramadoka> @src iterate
07:27:29 <lambdabot> iterate f x = x : iterate f (f x)
07:28:05 <ski> MarLinn : to a first approximation, yes. however, there are some exceptions. (a) sometimes (using more advanced type stuff, iow extensions) the deriving machinery doesn't manage to generate an instance; and (b) sometimes you don't want to expose the data constructors, but instead show your values in terms of abstract operations
07:28:17 <ramadoka> is there @src-like function in ghci?
07:28:23 <ski> MarLinn : show `Show' instance for `Array' (and also for `Rational') is an example of (b)
07:28:53 <MarLinn> It just sounded like I should always be able to rely on the result of show
07:28:57 <hpc> ramadoka: sort of but not really
07:29:00 <ski> @src Ratio
07:29:00 <lambdabot> data (Integral a) => Ratio a = !a :% !a
07:29:02 <ReinH> how many parsers there are, how many parsers were tried, what strings were expected from string parsers. Basically all of it.
07:29:15 <tdammers> MarLinn: more like you should never rely on the result of show
07:29:19 <hpc> you can use :info to get definitions of type classes and data types, but not value-level things
07:29:20 <ski> > listArray (0,3) [2,3,5,7]
07:29:23 <lambdabot>  array (0,3) [(0,2),(1,3),(2,5),(3,7)]
07:29:41 <ski> > 12 % 21
07:29:43 <lambdabot>  4 % 7
07:29:44 <ReinH> ph88: ^
07:29:46 <hpc> it's worth mentioning that @src in ghci is a bit of a lie, it just has a dedicated separate "source" file that it looks up into
07:29:52 <hpc> and not every definition is what's actually used
07:29:55 <hpc> @src sortBy
07:29:55 <lambdabot> -- The actual definition used by GHC is an optimised mergesort.
07:29:55 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
07:30:02 <ski> note that neither `array' nor `(%)' are data constructors
07:30:12 <ramadoka> hoou
07:30:26 <hpc> (ghc's sortBy is an impressive piece of code btw)
07:30:34 <MarLinn> So basically I want to be able to deflect blame if someone relies on my Show instances
07:30:53 <ramadoka> @src insertBy
07:30:53 <lambdabot> insertBy _   x [] = [x]
07:30:53 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
07:30:53 <lambdabot>                                  GT -> y : insertBy cmp x ys'
07:30:53 <lambdabot>                                  _  -> x : ys
07:32:16 <ramadoka> btw, do people actually consider using myVar and myVar' is recommended practice in haskell?
07:32:20 <maerwald> hpc: since when does ghci have @src?
07:32:27 <ph88> ReinH, i just mean that the information should be available in the source code .. i mean i, as human being, can answer those question given an input string and the parser source code.
07:32:38 <nitrix> maerwald: This is lambdabot bot, not ghci.
07:32:48 <maerwald> nitrix: he was speaking of ghci.
07:32:53 <ReinH> ph88: that's true, but how is it relevant?
07:33:04 <ongy> ramadoka: I use name' for similar things, e.g. defaulting an argument. But not for separate things or local variables
07:33:26 <nitrix> maerwald: A mistake probably. Lambdabot uses its own local database; I think thats what he meant.
07:33:30 <ongy> which is what I stumbled on in other libraries
07:33:32 <hpc> maerwald: :info can give you source-like output of certain things
07:33:39 <ph88> ReinH, because maybe my question boils down to: how can i make haskell reason about ordinary parser code ? i would expect some kind of abstraction/inspection/whatever is possible
07:33:42 <hpc> oh wait yes, typo
07:33:48 <hpc> meant to write "lambdabot" there lol
07:33:52 <ejbs> lyxia: I need to get the words too :P, but anyway, I'll do it myself siince it turns out that it's more complicated than I first thought
07:33:55 * maerwald is disappointed now
07:33:59 <hpc> heh
07:34:32 <byorgey> dmwit: no worries, thanks for the nudge.  I'm about to merge in some big refactorings and make a major new release of MonadRandom, so maybe we can do this at the same time
07:34:45 <ReinH> ph88: you can't, in the same way that you can't extract "hello" from \x -> x == "hello"
07:34:50 <lyxia> ejbs: there's the "words" function for that!
07:35:11 <ReinH> Literally the same way, since parsers are functions.
07:35:18 <ph88> ReinH, in the least i would expect to be able to inspect the original parser code and from there generate new code (i guess that would be template haskell) .. but perhaps there are more elegant solutions? I only want to use this advanced feature if the regular parser fails and i need to make suggestions to the user what could have been the right thing instead ..
07:35:32 <zomg> ph88: lisp :D
07:35:36 <ph88> :D
07:35:58 <ph88> hurray, finally found a use-case for lisp :D
07:36:09 <ski> ("if the regular parser fails" implies run-time. TH runs at compile-time)
07:36:13 <hpc> ph88: you should insert your suggestions into the parser's failure messages
07:36:27 <hpc> which you can already do in all parser combinator libraries
07:36:46 <ph88> ski, i generate the special suggestion-parser from the regular one at compile time (so i have 2 parsers). Then at runtime if the ordinary one fails i switch to the other one
07:36:54 <ReinH> ph88: you simply can't do what you want with the sort of parser you're using.
07:37:19 <ReinH> You might be able to add some machinery on top, like Cale suggested
07:37:22 <ph88> hpc, i can get better suggestions if can have an idea which of the possible choices is the best match
07:37:29 <ph88> ok ok
07:38:23 <ph88> i thought monad's were so magical they could inspect their own code or something
07:38:31 <ReinH> Not at all.
07:38:38 <ph88> bummer
07:38:57 <ski> perhaps you want an applicative (or arrow) parser or something
07:38:58 <ReinH> They are entirely non magical
07:39:01 <maerwald> xxD
07:39:02 <hpc> why would they be magic?
07:39:08 <ski> though you'd need to also handle the recursion
07:39:12 <maerwald> that's gonne become a quote
07:39:41 <hpc> in fact, that's probably a useful enough quote to keep around
07:39:49 <hpc> @remember hpc why would Monad be magic?
07:39:50 <lambdabot> I will remember.
07:40:48 <byorgey> ph88: in fact, monads are so magical that they *cannot* inspect their own code
07:40:58 <byorgey> hard to see through all the magic
07:41:09 <hpc> they are sufficiently advanced magic that one could even deign to call them "technology"
07:41:11 <byorgey> (where magic = functions)
07:41:24 <ski> @quote magic
07:41:24 <lambdabot> Axman6 says: foldr chosen for its magical evil terminating powers
07:41:36 <Axman6> hey I said that
07:41:55 <hpc> no, you're thinking of Bynbo7
07:42:01 <nitrix> "For my next magic trick, I'll open up this burrito".
07:42:19 <ph88> zomg, you were serious though? lisp can do it ?
07:42:30 <hpc> no matter what ingredients originally went into a burrito, when you open it up after it all looks like sour cream
07:43:39 <hpc> or guac if you can afford to spend $2 ruining your lunch ;)
07:44:51 <Axman6> hpc: that guy's a jerk, I wouldn't listen to him
07:46:32 <s4ke> hi.
07:46:40 <Axman6> 'lo
07:47:38 <s4ke> i am trying to do a intance for a interface and i want one version of the implementation of it only to be used if an additional contract is available. i know this isn't haskell-y, but i am somewhat forced to to this. something along the lines of: parEvalN (fs :: (NFData b, Trans b) => [(a -> b)]) (as :: [a]) = spawn (map process fs) as
07:47:58 <s4ke> this however does not work. any ideas?
07:49:22 <ph88> i'm a bit disappointed about haskell now :(
07:49:41 <Axman6> why?
07:50:16 <Axman6> s4ke: can you givw more context? what's process and spawn? what error are you having?
07:50:46 <ph88> well i can't use the string literals in several context while keeping the same parser code
07:51:04 <ph88> in the same way that you can't extract "hello" from \x -> x == "hello"
07:52:14 <SandyH> Hi I'm currently learning haskell and have a quick question. If I have a list of (x, y) coordinates defined as tuples (Integer, Integer) and I want to apply them to a function taking x and y as arguments. How would I go about to do that? Kinda like map but with two arguments
07:52:18 <s4ke> Axman6: i want to do a implementation of an interface for Eden GHC. for all other things i only need (NFData b), but Eden needs also needs (Trans b)
07:52:20 <zomg> ph88: well since lisp code is just lists and lisp can process lists, if you wanted to figure things out off it or change it on the fly, it might be easier to do than in haskell... but tbh I don't have a huge amount of experience in using lisp-like langs :)
07:52:27 <s4ke> Eden needs (NFData b, Trans b)
07:52:40 <SandyH> So my structure looks kinda like data = [ (1, 2), (3, 4), (5, 6) ]
07:52:42 <hpc> :t curry
07:52:43 <s4ke> but, Trans requires NFData
07:52:44 <lambdabot> ((a, b) -> c) -> a -> b -> c
07:52:51 <hpc> :t uncurry -- er
07:52:53 <lambdabot> (a -> b -> c) -> (a, b) -> c
07:52:59 <hpc> > uncurry (+) (5, 10)
07:53:01 <lambdabot>  15
07:53:13 <hpc> SandyH: ^
07:53:18 <Axman6> what's Eden?
07:53:49 <hpc> :t uncurry (+)
07:53:50 <s4ke> Axman6:  a custom GHC compiler that aims to do parallel computation on multiple machines that look like they are on the same machine from the programmers point of view
07:53:50 <lambdabot> Num c => (c, c) -> c
07:54:15 <hpc> SandyH: and then for applying (uncurry f) to the list you'd maybe use map, or whatever other function is appropriate
07:54:20 <hpc> :t map (uncurry (+))
07:54:22 <lambdabot> Num b => [(b, b)] -> [b]
07:54:42 <Axman6> s4ke: so, is the problem that under GHC proper, you need NFData b only, but under Eden you need (NFData b, Trans b)?
07:54:51 <haskell793> Hi, I have imported Data.Semigroup and Data.List.NonEmpty. When I enter the command :i NonEmpty, I do not get semigroup instance of NonEmpty
07:55:11 <s4ke> Axman6: yes. i want to give the compiler a hint that the function i am implementing also needs a special additional dependency
07:55:13 <s4ke> is this possible?
07:55:14 <Axman6> if so, there's a few ways you could do that with CPP pretty easily
07:55:19 <ski> @where+ Eden "Eden: Parallel Functional Programming with Haskell" <http://www.mathematik.uni-marburg.de/~eden/>
07:55:19 <lambdabot> Good to know.
07:55:41 <Axman6> ski++
07:55:44 <s4ke> ski++
07:55:58 * ski blinks
07:56:05 <SandyH> hpc: So if my function is named validCoord x y then I could do " map data (uncurry validCoord) "
07:56:05 <haskell793> I have imported Data.Semigroup and Data.List.NonEmpty. When I enter the command :i NonEmpty, I do not get semigroup instance of NonEmpty
07:56:07 <SandyH> ?
07:56:14 <hpc> ski = &ski OH GOD WHAT HAVE I DONE
07:56:15 <s4ke> Axman6: with the CPP extension?
07:56:47 <hpc> SandyH: flip the arguments to map, but yeah
07:56:54 <Axman6> s4ke: yes. not the world's more pleasant way. can be made nicer if Eden is up to date with GHC and has ConstraintKinds
07:56:59 <hpc> map function list
07:56:59 <SandyH> hpc But other order "map (uncurl validCoord) data"
07:57:00 <SandyH> yeah
07:57:16 <s4ke> Axman6: Eden has GHC 7.4...
07:58:50 <Axman6> #ifdef EDEN_GHC #define NFDat(b) NFData b, Trans b #else #define NFDat(b) NFData b #endif
07:58:52 <SandyH> hpc: Thanks a ton
07:59:13 <haskell793> Can someone please help me with Ghci 8: I have imported Data.Semigroup and Data.List.NonEmpty. When I enter the command :i NonEmpty, I do not get semigroup instance of NonEmpty
07:59:17 <Axman6> or something (with appropriate new lines). then you just use (NFDat(b)) => ...
07:59:38 <s4ke> Axman6: ah ok :). well seems like this will do the job (or something like it :))
08:00:01 <haskell793> I have imported Data.Semigroup and Data.List.NonEmpty. When I enter the command :i NonEmpty, I do not get semigroup instance of NonEmpty
08:00:27 <ski> @type fromIntegral :: (((Num b),(Integral a))) => a -> b
08:00:30 <lambdabot> (Num b, Integral a) => a -> b
08:00:45 <ongy> ski: ?
08:01:01 <dysfun> is there such a ghc extension that you can define a load of types without implementations and get correctness checks but not errors about lack of definitions?
08:01:16 <ongy> dysfun: EmptyDataDecls?
08:01:16 * ski would just define `NFDat(b)' as `(NFData b,Trans b)'
08:01:36 <ski> (otherwise it'll give an error if you write just `foo :: NFDat(b) => ..b..')
08:01:43 <ongy> at least that can be used for (Ptr SomeType) to mirror opaque types in FFI bindings
08:01:51 <dysfun> ongy: sorry, i mean like i could declare Foo :: A -> B, Bar :: Foo -> C etc.
08:01:56 <s4ke> ski: but then people that dont want to use Eden need to implement Trans.
08:01:59 <Axman6> > 1 :: ((Num a, Integral a),Show a) => a
08:02:01 <lambdabot>  1
08:02:11 <ski> s4ke : including the alternative case, obviously
08:02:16 <Axman6> if that works, then I would too =)
08:02:18 <sm> ph88: I agree with what was said, the easiest way to get that is build some support for it into the parsing lib. (Or do it ad hoc in your parsers by saving state as they go)
08:02:19 <s4ke> ski: ok :)
08:02:20 <dysfun> ongy: including functions i haven't yet written
08:02:26 <ski> Axman6 : yeah, just check that as well
08:02:32 <ongy> dysfun: and what would those functions do, if you have no implementation for the type?
08:02:38 <ski> s/just/i just/
08:02:52 <Axman6> I wasn't convinced you had checked the thing I was trying to avoid :P
08:03:00 * ski nods
08:03:13 <dysfun> ongy: sorry, i've totally messed up my wording here. I want GHC to typecheck my unwritten functions
08:03:14 <ski> (it occured to me just after i had stated the suggestion)
08:03:19 <Axman6> > 1 :: (((Num a,Read a), Integral a),Show a) => a
08:03:21 <lambdabot>  1
08:03:33 <dysfun> ongy: such that it can tell me if they are consistent, were they written
08:03:34 <Axman6> I never knew the syntax allowed you to do that
08:03:51 * Axman6 -> bed
08:03:57 <ongy> dysfun: you can just put "undefined" as definition of the function, but you would need your type to exist
08:04:09 * ski idly wonders when we'll get `foo :: (forall a. Show a => Show (f a)) => ..f..'
08:04:23 <int-e> @undef
08:04:24 <lambdabot> Undefined.
08:04:38 <Cale> ski: you can sort of fake that right now with the features we have, but it would be pretty nice to have it for real
08:04:39 <dysfun> ongy: thanks
08:04:55 <int-e> :t M.fromListWith (<>) . map (fmap S.singleton)
08:04:56 <ski> Cale : yeah, with extra versions of the class ..
08:04:57 <lambdabot> (Ord a, Ord k) => [(k, a)] -> Data.Map.Map k (Data.Set.Set a)
08:05:17 <Cale> ski: I mean http://hackage.haskell.org/package/constraints-0.8/docs/Data-Constraint-Forall.html
08:05:34 * ski should check out the new version of `Show1',&c. better
08:06:04 <Zemyla> Cale: That doesn't work, because it doesn't allow constraints on the forall'd type.
08:06:16 <ski> Cale : hm, right. i remember seeing that, but i haven't played with it enough to be able to tell how far it goes
08:09:46 <int-e> ertes: regarding qualified imports, actually it appears to work in the opposite way: if *in a module*, one imports the same module qualified in two different ways then ghci prefers the second import... let me check that theory.
08:09:55 <Cale> Zemyla: I guess the thing we need for ski's example isn't there, but we could probably do something similar, taking an extra * -> Constraint parameter.
08:10:08 <Cale> To allow for constraining the quantified variable
08:10:23 <nitrix> int-e: ping
08:10:28 * ski . o O ( `k -> Constraint' )
08:10:34 <Cale> yeah
08:10:37 <Zemyla> But then the skolem construction isn't valid, I am pretty sure.
08:11:08 <ertes> int-e: not sure about hint/mueval, but GHCi prefers the first one…  in any case, it would be nice, if the short one is preferred =)
08:11:14 <int-e> @undef
08:11:14 <lambdabot> Undefined.
08:11:16 <int-e> :t M.fromListWith (<>) . map (fmap S.singleton)
08:11:18 <lambdabot> (Ord a, Ord k) => [(k, a)] -> M.Map k (S.Set a)
08:11:19 <Zemyla> Like, imagine the constraint you're passing in is Typeable.
08:11:25 <Cale> Well, at the very least, it's possible to explictly take an argument of type (forall a. Show a :- Show (f a))
08:11:27 <ertes> int-e: much better!
08:11:39 <int-e> ertes: the behavior is different between importing from the ghci prompt and importing inside a module
08:11:45 <nitrix> int-e: Hey, I'm working on individual @undefine of given function names for lambdabot.
08:11:48 <ski> int-e : nice ! :)
08:11:52 <int-e> ertes: (that is then loaded from ghci)
08:12:39 <ertes> i see
08:12:53 <int-e> nitrix: I've seen a report float by about that... real life is very distracting right now though!
08:12:57 <Zemyla> nitrix: Will we also be able to import an lpaste?
08:13:09 <nitrix> Zemyla: That you can already do :P
08:13:09 <int-e> nitrix: but it definitely sounds useful
08:13:16 <ertes> you know what would be really cool?  per-user imports =)
08:13:20 <Zemyla> Oh?
08:13:25 <ertes> or rather per-user definitions
08:13:25 <nitrix> Oh my! That'd be awesome.
08:13:48 <nitrix> int-e: https://github.com/lambdabot/lambdabot/pull/147
08:14:08 <nitrix> int-e: Do you think this one would be easily doable easily mergeable?
08:14:20 <ski> @help letlpaste
08:14:20 <lambdabot> letlpaste <paste_id>. Import the contents of an lpaste.
08:14:39 <hpc> bwaaaaaaaah?
08:14:45 <int-e> nitrix: it's easy to merge but it doesn't directly affect the Freenode instance of lambdabot
08:14:54 * ski thought everyone knew about that, by now
08:15:01 <nitrix> int-e: Pretty please :3 ?
08:15:22 <dfeuer> Wow... cabal-install takes an awfully long time to build.
08:15:36 <sm> ha.. you ain't seen nuthin yet
08:15:37 <nitrix> I'll figure out an implementation for per-user definitions in exchange :P
08:15:46 <int-e> does TypeApplications cause any conflict with existing syntax?
08:15:49 <sm> dfeuer: well.. how long ?
08:16:03 <nitrix> int-e: No, it uses an @ at sign in from of type names.
08:16:06 <int-e> (that's the question I wanted to answer before doing anything about it)
08:16:18 <nitrix> :t map @Int
08:16:19 <lambdabot> error:
08:16:20 <lambdabot>     Pattern syntax in expression context: map@Int
08:16:20 <lambdabot>     Did you mean to enable TypeApplications?
08:16:25 <ski> ertes,nitrix,int-e : rudybot in #scheme has this `give' command by which you can give a value to another user, which they can then use in their sandbox (using the expression `(grab)', in this case)
08:16:26 <int-e> > let foo@bar = 42 in bar
08:16:30 <lambdabot>  42
08:16:45 <nitrix> int-e: bar isn't a type though.
08:17:00 <ski> `bar' could be a type variable
08:17:16 <int-e> nitrix: I know, I'm just demonstrating why I would even ask such a question.
08:18:05 <nitrix> ski: You cannot do type applications of type variables afaik.
08:18:20 <ongy> is there a reason 'IO a' is used pretty much always over 'MonadIO m => m a'? Would it have a performance hit if I a lot of IO in my function?
08:18:23 <nitrix> Or can you?
08:18:34 * ski doesn't know
08:18:49 <dfeuer> sm, I'm not sure. Several minutes anyway.
08:18:50 <ski> if we can't, should we leave the possibility open for the future ?
08:18:51 <int-e> nitrix: but at a glance, the type application lives only on the expression level, and cannot collide with the as-pattern.
08:19:23 <ertes> ski: something similar would be quite useful for exercises…  i give you an expression/definition with named holes, you fill in the holes
08:19:23 <nitrix> It may unly conflict with ScopedTypeVariables I think.
08:19:24 <sm> dfeuer: not swapping due to lack of ram I hope
08:19:25 <int-e> hmm, or not
08:19:43 <nitrix> int-e: But then you need to purposefully be doing @a while `a` is in scope.
08:19:55 <ertes> then people could work on the exercise in /query lambdabot
08:20:11 * ski feels somewhat uneasy about type applications meaning that `forall's doesn't commute with each other and with `(... ->)'
08:20:56 <sm> dfeuer: and thank you for the new containers by the way
08:21:08 <ski> int-e : .. and i don't really like having a phrase which can be both interpreted as a pattern and as an expression, but meaning different things
08:21:14 <dfeuer> sm, I hope not? I'm not sure. And you're welcome.
08:21:30 <int-e> "Turning on this extension will make the ‘@’ symbol whitespace-sensitive in the front: whitespace before an ‘@’ will parse as a type-application, while no whitespace in front of the ‘@’ will parse as an as-pattern." -- but why?
08:21:43 <sm> watching [h]top should give some idea
08:21:49 <int-e> > let x @ y = 42 in y -- this code doesn't work with TypeApplications
08:21:51 <lambdabot>  42
08:22:46 <ertes> TypeApplications is a thing?
08:22:48 * ski has also played with the idea of giving `@' in expressions a meaning corresponding to the one for patterns
08:23:03 <ertes> :t id @ Int
08:23:05 <lambdabot> error:
08:23:05 <lambdabot>     Pattern syntax in expression context: id@Int
08:23:05 <lambdabot>     Did you mean to enable TypeApplications?
08:23:19 <nitrix> ertes: Not yet, I'm trying to convince int-e but ski is working in the opposite direction.
08:23:37 * ski smiles
08:23:40 <ertes> it is indeed
08:23:51 <ertes> how did i miss that?
08:24:12 <ertes> probably not going to use it much though =)
08:24:31 <nitrix> I always have to move to GHCi, copy-paste the results in the chat to show how certain functions specializes to beginners.
08:26:27 <ski> @type fmap `asTypeIn` \fmap -> fmap reverse (words "monadic reflection")
08:26:29 <lambdabot> ([Char] -> [Char]) -> [[Char]] -> [[Char]]
08:26:37 <ertes> hmm…  the extension is a bit suspicious, if only for making the type order on 'forall' significant
08:27:11 <ertes> const @ Int :: Int -> b Int?  const @ Int :: a -> Int -> a?
08:27:32 <ski> (.. however, if it was `f @{a = Int}', then i would feel uneasy because then `forall a. ..a..' isn't equal to `forall b. ..b..')
08:29:01 <nitrix> Can we give it a try? There's not really any real commitment.
08:29:18 <ReinH> Cancel at any time!
08:29:40 <nitrix> If it bugs people they cannot define an @ operator, we remove it :/
08:29:55 <sm> Satisfaction guaranteed!
08:30:30 <ski> (we already can't define an `@' operator)
08:30:55 <nitrix> Or pattern rather.
08:31:21 <ski> (i suppose one solution, though not really concise, would be something like (an expression) `const :: a -> b -> a where b = Int' ?)
08:31:25 <int-e> regarding @ in patterns, looking at https://ghc.haskell.org/trac/ghc/wiki/ExplicitTypeApplication there was a plan to allow things like  f (Just @Int x)  but currently that doesn't work.
08:31:40 <Prutheus> Hi. I am using Network.Curl. How can I get the first element of a InfoValue? it looks like a [String] but it is type InfoValue
08:32:07 <ertes> i would love to have local types
08:32:11 * ski too
08:32:57 <sm> Prutheus: typically you would use a case expression, pattern matching each InfoValue constructor
08:33:00 <byorgey> Prutheus: the definition of InfoValue is here: http://hackage.haskell.org/package/curl-1.3.8/docs/Network-Curl-Info.html#t:InfoValue  it looks like you should pattern-match on it.
08:33:13 <ski> (by which i thought you meant local `data',`newtype',`type', and possibly `class' and `instane' declarations, inside expressions. but perhaps you meant local inside types)
08:33:19 <Cale> ertes: It's also too bad that type synonyms in Haskell don't interact in a more interesting way with the module system
08:33:20 <int-e> So right now I'm not thrilled about having TypeApplications in lambdabot.
08:33:43 * ski supposes Cale is thinking of abstractly exported synonyms
08:33:49 <Cale> ertes: It would be really nice to be able to define a type synonym local to a module, and then not export the type equality that it gives you
08:34:14 <ski> Cale : especially coupled with local modules
08:34:15 <Cale> (though, this means that you *must* give type signatures for all the exported things involving the synonym)
08:35:16 <Cale> Another old thought that came back to me today was that it would be nice if newtype let you have multiple fields.
08:35:24 * ski . o O ( "Restricted type synonyms" <https://www.haskell.org/hugs/pages/hugsman/exts.html#sect7.3.5> )
08:35:27 <Cale> and then we'd have proper categorical product
08:36:06 * ski doesn't follow
08:36:07 <Cale> i.e. the semantics would be that matching on a newtype constructor would always succeed without doing evaluation
08:36:13 <Cale> Just as it does now
08:36:22 <Cale> (the operational semantics, that is)
08:36:38 <Cale> and denotationally, it would be an unlifted product then
08:37:29 <ski> m, yes. we have talked some about that in the past, though perhaps not in terms of extending `newtype' to do this
08:37:39 <nitrix> ski: give/grab seems really cool. Can anyone arbitrarily give/grab from each others or it's some kind of approval system.
08:37:49 <nitrix> ski: give, grab to accept?
08:38:27 <ski> nitrix : the owner has to do the rudybot command `give other_nick foo', then other_nick can use `(grab)'
08:38:43 <nitrix> Gotcha.
08:39:14 <ski> it's a bit crude, but allows rudimentary communication between the sandboxes
08:39:21 <nitrix> ski: And your current namespace includes your own definitions, possibly shadowing the global ones?
08:39:33 <dfeuer> I tried uploading replacement documentation for containers. It claimed to succeed. But it didn't actually change anything on Hackage. Is this a caching thing?
08:39:57 <ski> for lambdabot, i'd suggest that possibly one should be able to switch between accessing a public global sandbox, and a private (per-user) one
08:40:16 <ski> nitrix, yes
08:40:46 <ski> nitrix : they can even use custom lexical syntax, with `#lang' in Racket ..
08:41:33 <nitrix> ski: Would you introduce a new operation > vs >> to distinguish global vs. local?
08:41:55 <ski> for lambdabot, one'd probably also want to be able to share type definitions (and classes, instances) with other people .. perhaps the simplest solution is to simply grant another user access to your sandbox
08:42:31 <ski> nitrix : hm, maybe. i was just thinking of a command (or two) to switch the context of the user
08:42:32 <nitrix> ski: That could be fairly easy, if you give the sandboxes actual modules, you could import qualified by username?
08:42:46 <exio4> nitrix: that was my first thought
08:42:47 * hackagebot diagrams-contrib 1.3.0.12 - Collection of user contributions to diagrams EDSL  https://hackage.haskell.org/package/diagrams-contrib-1.3.0.12 (BrentYorgey)
08:44:01 <nitrix> ski: That's a little noisy though people switching between modes.
08:44:40 <ski> yes (though they could do it in private) (but then people watching in the channel will miss the context switches, and may become confused)
08:45:42 <ski> (i guess the question then is how often people would switch context several times within minutes)
08:46:27 <xuxu> data Tree a = Leaf a | Branch (Tree a) (Tree a)
08:46:33 <nitrix> I think I'd rather have everyone in their sandbox and import the global shared stuff, with the ability to "exchange" (give/grab) definitions from others, as well as import their entire namespace qualified.
08:46:36 <xuxu> size :: Tree a -> Int
08:46:52 <nitrix> How does that sounds?
08:47:20 <xuxu> The number of type variables for a data type doesn't need to correspond to the number of possible values?
08:47:25 <sm> dfeuer: there is a CDN delaying some things on hackage by at least a few minutes
08:47:39 <dfeuer> Thanks, sm.
08:47:46 <xuxu> Branch will have two args ( I think they are called args)
08:47:48 <ski> nitrix : could work, if one could manage local shadowing of global stuff properly
08:47:49 <sm> dcoutts would know if it affects docs
08:48:57 <ski> xuxu : the number of type parameters of the data type doesn't have to correspond to the number of arguments of the data constructors, correct
08:50:16 <ski> (nitrix : btw, in rudybot, `grab' is a (state-depending) procedure, but for lambdabot, something similar probably ought to be a command)
08:51:20 <dcoutts> sm, dfeuer: yes, docs are cached rather aggressively, the server tells http caches it can keep them for 24 hours without revalidating
08:51:35 <dfeuer> dcoutts, ouch.
08:51:42 <dcoutts> see curl --head
08:51:56 <sm> would that also keep newly uploaded docs from being linked on the package page ?
08:52:04 <dcoutts> no
08:52:05 <xuxu> thank you ski
08:52:13 <dcoutts> sm: not if it's going from 404 to 200
08:52:17 <xuxu> #haskell has been very nice to me. thank you all
08:52:24 <dcoutts> sm: so this only affects replacing docs
08:52:27 <sm> good
08:52:31 <ski> yw, xuxu
08:52:47 * hackagebot http-client 0.5.3 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.5.3 (MichaelSnoyman)
08:53:50 <dfeuer> dcoutts, that seems a bit extreme. Why such a long lifetime? 
08:54:27 <dcoutts> dfeuer: docs don't change much
08:55:00 <dcoutts> and it reduces the number of requests that have to go back to the origin server, improving responsiveness for most people
08:55:20 <dcoutts> including all the way through to local browser caches
08:57:05 <Prutheus> I have a html source as string. how can i find a special number of tag element via haskell?
08:57:07 <dcoutts> dfeuer: generally one wants to cache as long a time as one can get away with as that improves things for the end user, not the minimum time one can get away with
08:58:16 <dcoutts> Prutheus: there's a bunch of libraries on hackage for that
08:58:31 <dcoutts> https://hackage.haskell.org/packages/search?terms=tag+html
08:58:48 <dfeuer> dcoutts, sure. But when a package version is first uploaded, it's relatively more likely to have documentation wibbles. Would it be possible to set the cache time for recently built/uploaded documentation to something short, and then go back and change it as it ages?
08:58:54 <Prutheus> dcoutts: ty
08:59:05 <dcoutts> dfeuer: in principle, yes
08:59:09 <dcoutts> dfeuer: PR welcome
09:00:03 <dfeuer> dcoutts, it would need some sort of cron-like thingum to evict things from the recently-changed status, I guess. I'm no system programmer!
09:00:39 <Tor_> I try running "stack new foo" and suddenly get a long list of things like Did not find .cabal file for zot-0.0.3 with Git SHA of f9092bae03d0044d2b4e3f33609c9544e8c46b19
09:00:39 <Tor_> Left C:\stack_root\indices\Hackage\git-update\all-cabal-hashes\.git\objects\pack: getDirectoryContents: does not exist (The system cannot find the path specified.)
09:01:02 <ertes> ski, Cale: i specifically meant 'data', 'newtype' and 'type' in 'where' and 'let'…  about local classes defined this way: not sure about the semantics in that case
09:01:24 <ertes> especially with local instances for top-level classes
09:01:39 <dcoutts> dfeuer: it'd be simpler than that, want to join #hackage ?
09:08:36 <Tor_> is my stack install broken?
09:08:56 <Cale> ertes: Yeah, local instances don't really make sense.
09:08:57 <Tor_> trying to make a new project I get a huge list of "dost not exists"
09:09:12 <Cale> ertes: They break everything that's nice about using type classes, unfortunately.
09:09:27 <sm> Tor_: what's stack --version ? And #haskell-stack may know more
09:09:57 <Tor_> Version 1.1.2, Git revision c6dac65e3174dea79df54ce6d56f3e98bc060ecc (3647 commits) x86_64 hpack-0.14.0
09:17:55 <ejbs> http://lpaste.net/181946 I've got this, I just want to return it as an integer and just adding toInteger doesn't work. How do I deal with it?
09:18:57 <lifter> I often find myself diving Ints via "(/) `on` fromIntegral" and then "round"ing the results. Would it be better in this case to use "div" or "quot" instead?
09:19:43 <glguy> lifter: If div or quot do what you want, you should prefer them to (/) and fromIntegral and rounding
09:25:58 <lifter> glguy: Well I'm not sure that either of them do what I want. I would like "3 `f` 2" to return 2 where f = either div or quot - that is, I would like the result of 1.5 to be rounded to 2 (but say, a result of 1.4 to be rounded down to 1). div and quot both round down in this case.
09:27:33 <Prutheus> at curlPost function (https://hackage.haskell.org/package/curl-1.3.8/docs/src/Network-Curl.html#curlPost) this function outputs data directly, how to make it silent so it wont write anything to console?
09:27:44 <lifter> let divide = (/) `on` fromIntegral in round $ 3 `divide` 2 -- returns 2
09:33:05 <Prutheus> how to stop this function from doing output into console?
09:34:19 <nitrix> lifter: You can't.
09:34:40 <lifter> nitrix: ok, I'll stick to my "divide" w/ "round" then. Thanks.
09:34:43 <sm> Prutheus: it looks like you can't, you'll have to copy and change it
09:34:43 <nitrix> lifter: `div` works on Integral and yields Integrals. Your variant works on Integrals and yield Fractionals.
09:35:00 <sm> because it sets CurlVerbose True
09:35:04 <lifter> nitrix: Yeah, that makes sense.
09:35:24 <hpc> Prutheus: or use another library, curl is one of those things that there's a hundred other alternatives that do the same thing
09:37:20 <Prutheus> sm: yeah i wanna copy and change it. what must i change?
09:37:53 <bezirg> hello, I think I found a bug in GHCi . The normal behaviour is that if an entered expression has type (Show a => a or Show a => IO a) , it will be evaluated an the result printed right?
09:38:10 <sm> Prutheus: there are 8 lines of code.. one of them should look suspicious to you
09:39:28 <sm> hint: I mentioned it. :) I'd try commenting it out
09:39:33 <hpc> bezirg: correct, with the exception of IO ()
09:39:54 <nitrix> bezirg: Your "bug" might just be a usage issue. Can you paste the problem in question to lpaste.net ?
09:40:19 <lyxia> > let (/) x y = (x + y `div` 2) `div` y in [3 / 2, 14 / 10] :: [Int]
09:40:21 <lambdabot>  [2,1]
09:40:27 <lyxia> lifter: ^
09:40:29 <hpc> (and in the IO a case, executed and the result printed)
09:42:23 <lifter> lyxia: I'm not sure what you are trying to tell me.
09:43:44 <Prutheus> i already removed the return
09:43:46 <Prutheus> ^^
09:44:21 <lpaste> bezirg pasted “ghci does not print result” at http://lpaste.net/181957
09:44:45 <bezirg> hpc, nitrix i put it in lpaste
09:45:15 <bezirg> hpc,nitrix: can u try in your ghci?
09:47:18 <ejbs> fib :: (Floating a, RealFrac a) => a -> Integer How do I make a into Integer from that?
09:47:38 <nitrix> bezirg: The type of `f <$> return 3 <*> return 5` is `f (IO Int)`.
09:47:43 <ejbs> Actually that doesnt make any sense
09:47:49 <nitrix> @let f x y = return (x-y) :: IO Int
09:47:51 <lambdabot>  Defined.
09:47:59 <nitrix> :t f <$> return 3 <*> return 5
09:48:01 <lambdabot> error:
09:48:01 <Prutheus> sm: so what do you mean then?
09:48:02 <lambdabot>     Ambiguous occurrence ‘f’
09:48:04 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.f’,
09:48:07 <nitrix> :t L.f <$> return 3 <*> return 5
09:48:09 <lambdabot> Monad f => f (IO Int)
09:48:23 <nitrix> bezirg: Does that help?
09:48:29 <lyxia> lifter: that's a function that does what you described without any intermediate floating point value
09:48:32 <bezirg> nitrix: u r right. this Identity monad always bites me
09:48:53 <bezirg> nitrix: thank you I totally missed it
09:48:58 <nitrix> bezirg: The default monad is supposed to be Identity, thus nothing displayed.
09:49:41 <mniip> the default monad is IO
09:49:43 <Prutheus> sm: I already added a getInfo function to my curlPost function, but this new one also do a return, so maybe there is the fault?
09:49:45 <mniip> in ghci
09:49:54 <lifter> lyxia: Oh I see, I'm not terribly good at math. :) Hmm, I wonder if that would be better than my "divide"? Perhaps more efficient?
09:50:06 <mniip> it first tries to interpret your code as an IO action
09:50:09 <sm> Prutheus: verbose means more output.. so I would comment out the first line of the function, that sets CurlVerbose to true
09:50:21 <Prutheus> ahh okay. sry that is new to me
09:50:37 <Prutheus> sm: worked. ty
09:50:39 <sm> no problem
09:50:52 <bezirg> mniip: ok so I end up with an IO (IO Int)
09:50:58 <bezirg> mniip: so that is why it is not printed
09:50:59 <mniip> yes
09:51:08 <bezirg> mniip: and when I call `it`
09:51:17 <mniip> exactly
09:51:17 <nitrix> bezirg: Oh sorry.
09:51:18 <bezirg> it :: IO Int
09:51:25 <bezirg> so it is subsequently printed
09:51:31 <nitrix> It's actually IO (IO Int) that shows nothing.
09:51:33 <bezirg> ok thank you both, I understand now
09:51:59 <nitrix> I don't know why I said Identity, maybe because you said Identity :P
09:52:45 <bezirg> nitrix: y :)
09:52:59 <nitrix> > L.f <$> return 3 <*> return 5
09:53:01 <lambdabot>  error:
09:53:01 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M436467658913...
09:53:01 <lambdabot>        prevents the constraint ‘(Show (f0 (IO Int)))’ from being solved.
09:53:14 <nitrix> Fancy.
09:53:33 <nitrix> > (L.f <$> return 3 <*> return 5) :: IO (IO Int)
09:53:35 <lambdabot>  <IO (IO Int)>
09:53:52 <nitrix> Ah, at least lambdabot is a little more verbose.
09:53:54 <ongy> > (L.f <$> return 3 <*> return (5 :: Int))
09:53:56 <lambdabot>  error:
09:53:56 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M478926748636...
09:53:56 <lambdabot>        prevents the constraint ‘(Show (f0 (IO Int)))’ from being solved.
09:54:10 <ongy> ah, it doesn't know about the monad to use
09:54:16 <nitrix> ongy: It's the Monad f0 => f0 ... that's ambigious
09:54:30 <ongy> yeah, just noticed that
09:54:35 <nitrix> GHCi seems to default to IO, lambdabot doesn't.
09:54:40 <ongy> > (L.f <$> return 3 <*> return 5 :: IO Int)
09:54:42 <lambdabot>  error:
09:54:42 <lambdabot>      • Couldn't match type ‘IO Int’ with ‘Int’
09:54:42 <lambdabot>        Expected type: IO Int
09:54:46 <nitrix> But, it does have a show instance for IO, which GHCi doesn't have apparently.
09:55:09 <nitrix> (err, has but empty)
09:55:51 <ongy> :t L.f
09:55:53 <lambdabot> Int -> Int -> IO Int
09:57:49 * hackagebot pointfree 1.1.1.2 - Tool for refactoring expressions into pointfree form  https://hackage.haskell.org/package/pointfree-1.1.1.2 (BenMillwood)
10:03:28 -tenniscp25(~tenniscp2@49.228.99.209)- Let's say I have a record:  data MyData = MyData { _a :: A, _b :: B, _c :: C }
10:03:45 <mniip> errr don't do that
10:03:52 <tenniscp25> Can I use lens to get (A, B, C) from the said record?
10:04:19 <glguy> tenniscp25: If you use makePrisms ''MyData you'll get a prism _MyData
10:04:30 <glguy> you can use view _MyData to get a function MyData -> (A,B,C)
10:04:52 <glguy> actually you'll get an Iso, but the rest of what I said it true :)
10:05:52 <tenniscp25> glguy: Thanks. I'll check that.
10:06:36 <hsk3> Am I allowed to put my own modules (in the project's src folder) into the "Control" and "Data" subfolders? For instance, src/Control/GreatModule.hs and src/Data/BoomModule.hs
10:06:37 <hsk3> And then import them in my own code as  Control.GreatModule and Data.BoomModule
10:06:49 <hsk3> Just wondering if "Data" and "Control" would conflict with the built-in "folders"
10:07:22 <ongy> hsk3: you can
10:07:46 <ongy> and afaik if you actually have conflicting modules the local ones are used (e.g. you define your own Data.Map)
10:08:02 <hsk3> ongy: ah ok. i hope haskell would warn about it thou
10:08:04 <hsk3> gh
10:08:11 <hsk3> with -Wall
10:09:45 <tenniscp25> glguy: What if I want just (A, C)? Can prism and/or iso do that?
10:11:05 <glguy> tenniscp25: If you want a more complicated thing you'll have to define the lens yourself
10:11:12 <glguy> :t lens
10:11:14 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
10:11:51 <glguy> (you have to provide the first two arguments)
10:12:22 <tenniscp25> glguy: thanks
10:14:46 <chsn> is there any rigorous explaination of filter/map vs list comprehension style?
10:15:09 <shapr> chsn: ooh, I'd like to see that
10:15:15 <shapr> does GHC just rewrite it?
10:15:25 <shapr> is it entirely equivalent? I'd guess it must be.
10:17:49 * hackagebot yaml 0.8.18.3 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.18.3 (MichaelSnoyman)
10:23:47 <chsn> in haskell, is there a way to say: this is a tuple, where EACH field of the tuple has a different ype?
10:23:57 <chsn> i.e. (Int, Int) is not allowed, but (Int, Double) and (String, Text) are fine ?
10:24:10 <shapr> Those are different types, you could make a typeclass
10:24:26 <chsn> shapr: ?
10:24:27 <ggVGc> a type class?
10:24:32 <chsn> window 8
10:24:32 <ggVGc> sounds like the job of an ADT to me
10:24:50 <shapr> ggVGc: even better!
10:25:03 <ggVGc> type Foo = Tuple1 :: (Int,Double) | Tuple2 :: (String, Text)
10:25:18 <chsn> well, I don't know it before hand
10:25:34 <ggVGc> you don't know which types are valid at compile time?
10:25:35 <chsn> I also want (Cat, Dog), (Student, Car, Bottle)
10:25:49 <chsn> ggVGc: I'm looking at a way to fake row types
10:25:51 <ggVGc> chsn: then add ADT constructors for each of those
10:25:58 <chsn> declaring al lthe valid types ahead of time defeats the purpose
10:26:05 <ggVGc> mkay
10:26:09 <ggVGc> then I misunderstood
10:26:17 <ongy> chsn: why would you force non-equal types?
10:26:58 <MarcelineVQ> someone in here last night, I think, showed an example of using datakinds to restrict types statically
10:27:17 <chsn> ongy: then I can select it bsed on the type
10:27:21 <lpaste> whittle pasted “Cale warned me about this” at http://lpaste.net/181977
10:27:24 <chsn> ongy: for example, if I had (FirstName, LastName, Age, Gender)
10:27:45 <chsn> then I can have firrstName, lastName, age, gender selectors -- which, through type magic, should beable to tselect the right field of the tuple
10:27:47 <ggVGc> chsn: maybe you want https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Dynamic.html
10:27:50 <ggVGc> ?
10:28:03 <whittle> First, I’d like to note that Cale told me something like this would happen. But I still don’t understand quite why. 
10:28:45 <chsn> window 7
10:29:09 <shapr> chsn: no
10:29:16 <haldean>  chsn: I think you might mean /window 7
10:29:19 <haldean> ;)
10:29:25 <MarcelineVQ> whittle: not sure if it matters but just in case be careful about sharing things with auth tokens in them
10:31:06 <whittle> MarcelineVQ: Thank you for the reminder. That auth token is useless, but it would still be better to put in something obviously untrue. 
10:32:18 <whittle> Ha! Figured it out. Sorry for the noise. 
10:33:45 <ongy> whittle: do you know what went wrong, or did you just get it to work?
10:35:57 <whittle> ongy: I realized that because I was sticking in an undefined for the stripeReq, that the call to withStripeExpecting was expecting its second argument to match the unrestricted type of its first argument. Once I annotated stripeReq with a concrete type, the compiler stopped complaining. 
10:36:52 <dfeuer> Cale, give me a pretty mathematical function saying how long Hackage should set the cache  time for documentation based on when that documentation was last modified. It should start at ten minutes and max out, within a few days, at one day.
10:37:09 <MarcelineVQ> tragedy / time
10:37:14 <dfeuer> (Or anyone else who can come up with a pretty function)
10:38:28 <whittle> dfeuer: I feel like a log function works here. Will that be too expensive? 
10:39:06 <dfeuer> whittle, the units analysis doesn't seem to work out on that, does it? What's the logarithm of time?
10:39:21 <Cale> Well, just pick any sigmoid you like
10:39:21 <dfeuer> I don't think it's too expensive, no.
10:39:30 <dfeuer> Cale, what's a sigmoid?
10:39:55 <Cale> https://en.wikipedia.org/wiki/Sigmoid_function#/media/File:Error_Function.svg -- a function which looks something like this
10:40:04 <dfeuer> Ah.
10:40:29 <dfeuer> Are there any that make sense for quantities with units?
10:40:54 <dfeuer> Or should I just say to heck with that and use something that looks pretty?
10:41:23 <Cale> some https://en.wikipedia.org/wiki/Logistic_function is probably what you want
10:42:06 <Cale> But really, this is an arbitrary thing...
10:42:41 <dfeuer> Yeahhh.
10:43:55 <Cale> Without some additional constraint or some function we want to maximise, it's hard to be anything but totally arbitrary
10:43:56 <whittle> dfeuer: I’m not sure I understand what you mean. I think of transcendental functions as being unitless transforms. 
10:44:42 <dfeuer> whittle, if you change the unit of an exponent, you change the order of growth. :-/
10:45:00 <dfeuer> But I guess logarithms aren't so ill-behaved as that.
10:45:36 <Cale> The log function doesn't tend to max out at any particular value...
10:46:24 <Cale> Though in practical terms, that would never be terribly relevant
10:47:25 <jonored> The usual way this works is that you /make/ the input to the odd function be unitless.
10:48:01 <jonored> Which happens if you divide the input by some particular characteristic amount of time.
10:48:26 <jonored> (and then multiply your dimensionless result by a time to get the new time, and unit analysis is satisfied.)
10:49:45 <dfeuer> jonored, yeeeeah.
10:49:47 <dfeuer> That makes senes.
10:49:48 <dfeuer> sense.
10:56:10 <jonored> dfeuer: And of course, if you're just fitting a function to a "what you need", that reference quantity can be 1 second on both sides and the curve can be arbitrary, and that's still actually correct, even though it feels like cheating on types somehow.
10:57:33 <dfeuer> jonored, totally.
10:59:23 <monochrom> Dear dfeuer, thank you for all the work on containers.
11:02:01 <jonored> (Also, although getting offtopic so cutting off there, all the dimensionless numbers in physics & fluid mechanics have strangely specific numbers that mean things in them.)
11:02:50 * hackagebot lentil 0.2.0.1 - frugal issue tracker  https://hackage.haskell.org/package/lentil-0.2.0.1 (fffaaa)
11:04:50 <dfeuer> monochrom, glad you appreciate it. I'm not the only one who worked on it, but I certainly did work a lot!
11:08:46 <Ikkyo> Hi! I am new to haskell and I'm trying to find a way to strip a set of letters matching a specific pattern from a string
11:08:57 <Ikkyo> Can anyone point me in the right direction?
11:09:28 <kadoban> Ikkyo: Just based on what letters they are, or is this kind of a parsing question?
11:09:37 <kadoban> For just plain filtering you can use 'filter' on Strings
11:09:40 <kadoban> :t filter
11:09:41 <lambdabot> (a -> Bool) -> [a] -> [a]
11:09:47 <shapr> @src filter
11:09:47 <lambdabot> filter _ []     = []
11:09:47 <lambdabot> filter p (x:xs)
11:09:47 <lambdabot>     | p x       = x : filter p xs
11:09:47 <lambdabot>     | otherwise = filter p xs
11:10:18 <kadoban> You may also be interested in some functions from https://www.stackage.org/haddock/lts-6.14/base-4.8.2.0/Data-Char.html
11:10:51 <cocreature> is there any way to get the full name of a cost centre in a heap profile?
11:11:50 <cocreature> nvm found it -L100 gives me 100 chars
11:14:32 <puregreen> Ikkyo: do you just want to remove a substring, or is the pattern more complicated? (e.g “foo???bar”)
11:15:13 <Athas> Has anyone here managed to run git HEAD of accelerate-examples on CUDA recently?
11:16:10 <Ikkyo> puregreen: The pattern is slightly more complicated, it involves removing a certain sequence of chars, so if you have a number, and the two previous chars are equal, then all three should go
11:16:35 <puregreen> recursion with pattern-matching could work in this case
11:17:03 <puregreen> f (x:y:z:xs) | x == y && isDigit z = f xs | otherwise = x : f (y:z:xs) 
11:17:40 <Ikkyo> Thanks! I'll give it a go
11:23:46 <xuxu> the @src feature of lambdabot is handy. has equivalent functionality been built into ghci?  
11:24:21 <puregreen> nope
11:24:30 <xuxu> puregreen: thanks
11:24:32 <puregreen> you can add hoogle to ghci
11:24:35 <puregreen> and there's also :i
11:24:40 <puregreen> but they are poor substitutes
11:24:43 <xuxu> i use both
11:24:48 <kadoban> xuxu: It's full of lies and missing a lot though, just to warn you.
11:24:56 <kadoban> (@src, not the others)
11:25:45 <prototrout> There's :list for showing an identifier's source code (if it's your own)
11:26:18 <puregreen> nice, I didn't know that
11:26:21 <puregreen> prototrout++
11:35:13 <joe9> I am trying to use diagrams and am having trouble understanding the types used. Is there some material that can help me understand it?
11:38:25 <joe9> http://bpaste.net/show/7ba043e01a14 How do I decipher this? I know that there is a mkWidth.
11:38:28 <lyxia> joe9: the diagrams tutorial is pretty nice to get some things done
11:40:08 <joe9> lyxia: thanks, the tutorial seems to concentrate on drawing and not on the types, etc. let me check if there are other tutorials.
11:40:33 <orzo> I've diagnosed (somewhat) why my builds are so slow
11:41:26 <orzo> cabal is repeatedly invoking ghc --make when nothing has changed, each time it does this, ghc --make takes 3 seconds to do whatever it's doing
11:41:44 <dcoutts> orzo: cabal new-build is much better at this
11:41:53 <orzo> oh it is?
11:42:02 <dcoutts> it tracks what files have changed and only invokes ghc if anything did change
11:42:12 <orzo> aha
11:42:35 <orzo> of course, ghc --make should be tracking/caching stuff probably
11:42:44 <orzo> i mean it is claiming to --make
11:42:58 <dcoutts> but note that new-build and related commands are a tech preview, usable but some rough edges
11:43:21 <orzo> well if it speeds u p my build, i'll deal with it
11:43:26 <orzo> thanks a lot for the tip
11:43:31 <dcoutts> orzo: actually I disagree, I think that kind of caching belongs in an external build tool
11:43:51 <dcoutts> imho, cabal should stop using ghc --make at all and use single-shot mode and do the graph stuff itself
11:44:15 <orzo> i agree with that
11:44:46 <orzo> but as long as ghc does the --make option, it ought to do it right
11:44:58 <Cale> joe9: http://projects.haskell.org/diagrams/haddock/Diagrams-Size.html#t:SizeSpec
11:45:23 <orzo> i'm going to try new-build, i'll let you know if it works out
11:45:29 <dcoutts> orzo: well... it means ghc has to have too much policy on files, layout etc
11:45:41 <Jenaf> my program has really bad svg code as output, does anyone know where i can find a simple tool for svg obtimization?
11:45:47 <dcoutts> orzo: http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/
11:46:04 <joe9> Cale, Thanks.
11:46:11 <Jenaf> or at least where i can search? googling only gives me plugins for other programs
11:46:20 <orzo> unrecognized option '--disable-library-profiling' that was unexpected
11:46:24 <Cale> joe9: mkSizeSpec tells the story for what SizeSpec values are
11:47:05 <Cale> joe9: Basically, they're like vectors, but whose components are Maybe values (which doesn't work abstractly with vector spaces, but the idea is that we may or may not have information about the size of something in each basis direction)
11:47:34 <orzo> dcoutts, do you happwn to know how i can tell new-configure/new-build to build only the non-profliing versions?
11:47:48 <dcoutts> orzo: that's the default
11:48:02 <dcoutts> orzo: though you may have overridden that default in your ~/.cabal/config
11:48:46 <orzo> dcouts, yes i did override, but it actually takes the option, i'm sorry, stupid mistake.  I wasn't invoking cabal when i thought i was.
11:49:18 <Jenaf> great #svg exists but seems dead
11:50:38 <orzo> Jenaf, what are you looking for?  I've written some svg code
11:51:08 <Jenaf> well the output is just a list of lines, but it's rather big
11:51:36 <orzo> i have code that turns svg files into android library calls
11:51:38 <Jenaf> and i guess its not really good
11:52:13 <Jenaf> I basically wrote the minimum xml without compression or anything smart
11:52:21 <orzo> dcouts: !!! 0m0.275s when nothing changed :))
11:52:45 <Jenaf> <svg height="1000" width="1000">
11:52:46 <Jenaf> <line x1="500.0" y1="586.8" x2="500.0" y2="587.9" style="stroke:black;stroke-width:1" />
11:52:48 <Jenaf> <line x1="500.0" y1="587.9" x2="500.0" y2="589.0" style="stroke:black;stroke-width:1" />
11:52:49 <Jenaf> -- snip...
11:52:51 <Jenaf> </svg>
11:52:52 <Jenaf> like this
11:55:32 <joe9> Jenaf: is the svg rendered slow?
11:55:55 <Jenaf> well... I addmit i know nothing about graphics
11:56:09 <Jenaf> so I just opened about:blank and pasted the plaintext into the html editor
11:56:20 <chsn> I'm writing a stack library. Is it possible to package a number of static assets (*.html, *.js files) as part of the library, in a place taht the *.hs files from the library can reference?
11:57:25 <Jenaf> okay, atm I try another online obtimization tool.. but eh.. there seems to be something really bad about my output
11:58:19 <glguy> chsn: https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
11:58:36 <Jenaf> (about 5mb filesize atm and I don't really want to have less iterations
11:59:11 <chsn> glguy: thanks
11:59:22 <lpaste> mnoonan pasted “Slow function?” at http://lpaste.net/182021
11:59:42 <mnoonan> Can anybody help me figure out why this ^^ is running so slowly?
12:00:17 <mnoonan> there is almost nothing to these functions, but they are taking the vast majority of the time in my executable
12:00:25 <mnoonan> hopefully I'm just overlooking something dumb
12:02:12 <orzo> Jenaf: a series of lines should probably using the <path> element
12:02:28 <dolio> mnoonan: What do your node names look like?
12:02:37 <Jenaf> they arent connected...
12:02:39 <sm> mnoonan: how many items in the map ?
12:02:59 <Jenaf> I'm playing around with https://en.wikipedia.org/wiki/Iterated_function_system
12:03:02 <mnoonan> dolio: strings around ~10 characters in length, with about 20% sharing a common 4-letter prefix
12:03:17 <Jenaf> but i only use transformations on lines
12:03:24 <orzo> Jenaf: path doesn't require the lines be connected, you can use the M code to move the cursor to a point
12:03:41 <mnoonan> sm: about 250 elements in the map, fewer in the sets
12:03:58 <sm> I wonder why it's calling compare 100 million times
12:04:07 <Jenaf> then I'd have to rework my Haskell code ^.^
12:04:14 <dcoutts> mnoonan: notice that `compare` is big in the profile. That's probably the comparison operator used in the map lookup, which is on Edge, which contains two Strings
12:04:24 <mnoonan> sm: ! my eyes glazed over that number I think!
12:04:30 <dolio> mnoonan: So, you're aware that Sets are search trees, and so storing strings in them does lexicographic comparison, which will be comparing those common prefixes many times to look things up, right?
12:04:39 <Jenaf> orzo: does it change much?
12:05:06 <mnoonan> dolio: yes, but still..
12:05:16 <orzo> well i'm not sure what your issue is.  I figure it would help the renderer avoid parsing a bunch of stuff
12:05:39 <orzo> your issue was it's working too hard to render your svg files?
12:05:47 <monochrom> even linear search over 250 strings incurs only 1000 Char comparisons
12:05:56 <dcoutts> mnoonan: so it'd probably be quicker if you used Text or ByteString (or ShortByteString) instead of String. And it's plausible an unordered set/map would be faster than the normal Set/Map, if it's really the set and map operations that is dominant in this code
12:06:42 <mnoonan> I can actually make those just unboxed Ints or something, I just need to do a little extra work. But I didn't think that could explain enough of the slowness.
12:07:07 <sm> or why edgeProb is called 18 million times, even. I'd validate/fix those large numbers before messing with data types
12:07:11 <Jenaf> orzo: I guess so , but also my svg is propably very very bad so i hoped for a magic tool
12:07:33 <Jenaf> I had one recursion step more, but firefox blew up on it
12:07:58 <Jenaf> (aka I killed the firefox process when it was using almost all my RAM)
12:08:18 <joe9> Jenaf: I used svg and just handwrote them using lucid.svg
12:08:25 <mnoonan> sm: yeah, that's disturbing.. looking further up the call chain..
12:08:40 <orzo> Jenaf: i use a tool called "scour" that tidies up svg files.  I don't know if it will do anything you have in mind
12:08:40 <joe9> Jenaf: I found the generated versions had too much stuff and I had no clue what each component was doing.
12:09:15 <Jenaf> joe9: you have a link? I basically just dumped the xml into a textfile and renamed it to be an svg
12:09:29 <joe9> Jenaf: another thing you might want to think about is if you want to use svg or go native with cairo (or, diagrams).
12:09:40 <joe9> Jenaf: google haskell lucid svg
12:09:49 <orzo> Jenaf: http://codedread.com/scour/
12:09:53 <Jenaf> I may do that ^.^
12:10:44 <Jenaf> okay, I will try that one
12:25:41 <the_2nd> how can I flatten an "Either String (Maybe a)" in such a way that Nothing gives me a Left of STRING and a Just returns a Right ? I would use a case of, but maybe there's a cleaner way
12:27:19 <Phyx-> :t ord
12:27:20 <lambdabot> Char -> Int
12:27:43 <mnoonan> the_2nd: either?
12:27:45 <mnoonan> :t either
12:27:47 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
12:28:01 <EvanR> theres a pckage out there for converigng between a variety of combinations of either and maybe
12:28:25 <EvanR> but other than that, you just need to write your own flattener
12:28:56 <joe9> extra pakage has some either-extra functions too
12:30:00 <meditans> I have a question on hackage candidates: is the haddock automatically generated or should I upload it manually?
12:30:28 <EvanR> :t fmap (fromMaybe "string")
12:30:30 <lambdabot> Functor f => f (Maybe [Char]) -> f [Char]
12:30:46 <EvanR> hm nope
12:31:04 <EvanR> :t fmap (maybe "string" id)
12:31:05 <lambdabot> Functor f => f (Maybe [Char]) -> f [Char]
12:31:15 <EvanR> :t fmap (maybe "string" Right)
12:31:17 <lambdabot> error:
12:31:17 <lambdabot>     • Couldn't match type ‘Either a0 b’ with ‘[Char]’
12:31:17 <lambdabot>       Expected type: b -> [Char]
12:31:27 <EvanR> /quits
12:33:45 <dogweather> Meta: I just discovered that #haskell is the 8th largest IRC channel by number of members, unless I'm reading my Channel List wrong
12:34:13 <dogweather> And #python is the only larger prog. language channel
12:34:43 <johnw> dogweather: you are reading it right, we are large
12:59:59 <TCZ> hehehe heskell geniuses xd
13:01:58 <shapr> TCZ: are you becoming a Haskell genius? Writing some cool code?
13:03:24 <TCZ> geniuses dont use haskell its stupid....
13:03:26 <TCZ> :x
13:03:40 <TCZ> only good for genius wanabes xd
13:03:46 --- mode: ChanServ set +o shapr
13:03:54 <shapr> TCZ: have you tried any of the tutorials?
13:04:06 <TCZ>  :O
13:04:11 <TCZ> nevermind -.-
13:04:49 <orzo> dcoutts: using --enable-shared --enable-executable-dynamic still causes executables to be new-built when only white space changed in a library module.  Is that a necessary evil for some reason?
13:05:10 <shapr> TCZ: I'm enjoying the Haskell book from @argumatronic and @bitemyapp, it's really fun.
13:05:54 <APic> lopl
13:05:56 <APic> -p
13:06:14 <TCZ> noooo
13:06:26 <TCZ> sorry i came here only to
13:06:28 <TCZ> u know...
13:06:36 <mnoonan> learn haskell?
13:06:37 <shapr> TCZ: Learn you a Haskell (for great good) is free online, you should try it!
13:06:41 <shapr> mnoonan: right!
13:06:43 <TCZ> noooooo
13:06:51 <TCZ> i was reading learn you a haskell
13:07:02 <shapr> TCZ: and you enjoyed the humor and learned awesome stuff?
13:07:20 <TCZ> no
13:07:22 <TCZ>  : |
13:07:32 <shapr> TCZ: oh, so you have questions you want to ask here?
13:07:38 <shapr> TCZ: how far did you get?
13:07:45 <TCZ> goodbye
13:07:47 <TCZ>  : /
13:07:50 <TCZ> geniuses xd
13:07:51 <senoj> TCZ only came here so say "no" and "noooooo" and its variants
13:08:12 <schell> shapr: classy handling
13:08:43 * schell gives thumbs up
13:08:46 <shapr> :-)
13:09:43 <dmwit> shapr++
13:09:46 <shapr> :-)
13:10:03 <shapr> Trolls will be educated. Resistance is futile.
13:10:45 <dmwit> > traverse (maybe (throwError "ack!") return) (Left "foo") :: Either String Int
13:10:48 <lambdabot>  error:
13:10:48 <lambdabot>      • Couldn't match type ‘Either [Char] b0’ with ‘Int’
13:10:48 <lambdabot>        Expected type: Either String Int
13:11:05 <EvanR> dat unicode bullet
13:11:14 <dmwit> oh
13:11:19 --- mode: shapr set -o shapr
13:11:27 <dmwit> > Left "foo" >>= maybe (throwError "ack!") return :: Either String Int
13:11:29 <lambdabot>  Left "foo"
13:11:34 <dmwit> > Right Nothing >>= maybe (throwError "ack!") return :: Either String Int
13:11:36 <lambdabot>  Left "ack!"
13:11:38 <EvanR> fortune said the other say: "keep your goals away from the trolls"
13:11:40 <dmwit> > Right (Just 3) >>= maybe (throwError "ack!") return :: Either String Int
13:11:42 <lambdabot>  Right 3
13:12:01 <EvanR> :t throwError
13:12:02 <lambdabot> MonadError e m => e -> m a
13:12:19 <dmwit> Too bad the_2nd is already gone.
13:13:03 <EvanR> if typeclasses were pokemon there would be an "error type"
13:13:28 <slack1256T> class MissingNo a where (...)
13:16:07 <prsteele> how un-idiomatic is using Either for what amounts to an anonymous Sum type?
13:16:24 <APic> Ether ♥
13:19:08 <senoj> prsteele: I would say that's exactly what Either is meant to be (even though it's used very commonly for the return type of a function that may fail along with a value)
13:20:15 <prsteele> senoj: thanks!
13:20:27 <heebo> hello, i think my quickcheck is throwing an exception how can i get it to print out the arbitrary instances that made the test fail?
13:21:29 <stringer> can someone explain to me how is (f.) . g x y  diffrent than (.) f (.g) x y ??
13:22:06 <TCZ> i cant
13:22:49 --- mode: ChanServ set +q *!*@62.244.139.175
13:22:52 <geekosaur> :t (?f .) . ?g ?x ?y
13:22:53 <lambdabot> (?y::t1, ?x::t, ?g::t -> t1 -> a -> a1 -> b, ?f::b -> c) => a -> a1 -> c
13:23:06 <geekosaur> :t (.) ?f (. ?g) ?x ?y
13:23:07 <lambdabot> (?y::t, ?x::b -> c, ?g::a -> b, ?f::(a -> c) -> t -> t1) => t1
13:26:42 <stringer> wow this is hard to read, so (f.) . g x y transit like this (f.)(g x) y -> f(g x y) . But I'm having problem with the (.) f (.g) x y , meaning I dont see a diffrence
13:30:28 <dmwit> > (f.) . g x y $ z :: Expr
13:30:30 <lambdabot>  error:
13:30:30 <lambdabot>      Ambiguous occurrence ‘f’
13:30:30 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
13:30:34 <dmwit> ?undefine
13:30:34 <lambdabot> Undefined.
13:30:36 <dmwit> > (f.) . g x y $ z :: Expr
13:30:38 <lambdabot>  error:
13:30:38 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘() -> c0’
13:30:38 <lambdabot>      • In the expression: (f .) . g x y $ z :: Expr
13:31:00 <dmwit> > ((f.) . g x y) w z :: Expr
13:31:02 <lambdabot>  error:
13:31:02 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘f’
13:31:02 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
13:31:54 * prsteele looks forward to ApplicativeDo
13:34:10 <mnoonan> sm: thanks for the tip, it looks like that function was getting called a large number of times, due to using maximumBy on a largish list.
13:34:33 <sm> great
13:34:34 <mnoonan> I had been looking for the largest value in a map; I changed it to track the transpose of the map as well
13:34:52 <mnoonan> now I have other functions getting called a lot, but they are cheaper :)
13:35:57 <sm> large entry counts on a profile are the first thing I look for, they're usually good news
13:39:22 <dmwit> stringer: Do you actually mean `(f.) . g x y`, or do you mean `((f.) . g) x y`?
13:39:54 <dmwit> (The former could also be written as `(f.) . (g x y)`.
13:40:42 <dmwit> ((f.) . g) x y = (f.) (g x) y = (f . g x) y = f (g x y)
13:41:15 <ReinH> stringer: You'd be better off just not using the (f .) . g construct in the first place
13:41:37 <stringer> Ok i know for a fact that (.) f (.g) doesnt equals f (g x y)
13:42:01 <ReinH> That is correct.
13:42:02 <dmwit> (.) f (.g) x y = f ((.g) x) y = f (x . g) y
13:42:13 <stringer> oh Ok
13:42:16 <stringer> thanks
13:44:05 <prsteele> So I'm trying to write a FromJSON instance for Aeson, but this is really a general question. If I want my parser to conditionally branch based on a value, I need a *monadic* parser rather than an *applicative* parser, right?
13:44:30 <stringer> wait how f ((.g) x) y is f (x . g) y ?
13:44:40 <dmwit> prsteele: Assuming that value came from parsing a previous chunk, then yes, right.
13:45:19 <prsteele> dmwit: thanks!
13:45:28 <dmwit> stringer: What would you expect it to be instead?
13:46:21 <geekosaur> (.g) is \x -> x . g
13:46:32 <geekosaur> like (f.) is \x -> f . x
13:46:45 <stringer> ohhhh, that's explain a lot
13:46:49 <stringer> thank you guys
13:49:50 * prsteele really looks forward to ApplicativeDo because the compiler knows best
13:53:26 * slack1256T doesn't care as long they don't reuse the word `do'
13:55:15 <puregreen> it's already in GHC 8 and they reused the word “do”
13:56:08 <puregreen> https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/glasgow_exts.html#applicative-do
13:56:42 <kadoban> It'd be kind of weird for it to be a different keyword. It's not really different at all, just the type is more general.
13:57:17 <prsteele> I know it's in GHC 8, I'm just waiting for it to come through apt
14:11:31 <slack1256T> even so, the motivation for haxl was that the applicative interface was parallel and the monadic for sequential
14:11:49 <slack1256T> using the same syntax for writing in both is curbersome, as you distribute the work differently in each case
14:12:49 <slack1256T> So I like to be clear upfront and say "if I use do notation, there is monad composition on this", so I don't half way mislead people
14:13:38 <slack1256T> if the instances of applicative and monad are the same then there is no problem, but also there is no point also in the generalization
14:18:41 <rpunkfu> sb_window_inact_bg = "%N";
14:18:49 <rpunkfu> oops, sorry
14:21:04 <aarvar> slack1256T: there is a point; you might have an applicative instance but no monad instance
14:22:01 <aarvar> or the applicative version might be more efficient
14:22:34 <kadoban> Is the Applicative really ever worse?
14:22:55 <monochrom> I think slack1256T means that a different keyword could be used instead of "do", which is still consistent with wanting a notation for Applicative expressions.
14:23:52 <kadoban> Ah. I guess in that case you would just give a type annotation maybe?
14:26:21 <monochrom> On the next April 1st, the keyword for ApplicativeDo will be changed to "ado". :)
14:26:55 <MarcelineVQ> oh μ
14:27:03 <geekosaur> much ado about...
14:27:59 <slack1256T> basically what monochrom says
14:28:26 <slack1256T> I would even define "further = id" to make cringy jokes without "further ado "
14:28:41 <monochrom> \∩/
14:29:11 <Alxandr> Hi. I'm having some trouble with designing types in my system, and was wondering if I might get some help here. Or maybe just some inspiration. To get around the brain-block I'm currently stuck at :-/.
14:29:22 <aarvar> slack1256T: you mean further $ ado
14:29:23 <Alxandr> I'm building a monadic library for combinding Web APIs
14:29:33 <Alxandr> (server implementation)
14:29:55 <Alxandr> So you can do stuff like `POST >=> path "/foo" >=> handleFoo`
14:29:57 <monochrom> withArray $ \p -> further $ ado ...
14:31:13 <aarvar> much $ ado about Nothing
14:31:20 <Alxandr> Then I wanted to add support for automatically generating swagger documentation, which is hard when dealing with these kind of dynamic models, so I diviced a new type `data Api a = Api (WebPart a) (Spec -> Spec)`
14:31:47 <Alxandr> Which I could then combine to produce APIs with documentation
14:31:56 <Alxandr> The problem is I'm pretty sure my new type can't be monadic
14:32:08 <Alxandr> Cause I can't figure out how to write the bind operator
14:32:26 <monochrom> perhaps it suffices to be an Applicative
14:32:35 <Alxandr> Which I'm interpreting as I'm probably doing something wrong
14:32:52 <aarvar> or do you want a writer monad with Endo Spec
14:35:35 <Alxandr> @aarvar was that for me?
14:35:35 <lambdabot> Unknown command, try @list
14:35:51 <Alxandr> -.-. I use IRC so little, I forget how to even mention people
14:36:04 <aarvar> Alxandr: colon
14:36:08 <geekosaur> just start with their name, no introducer needed
14:36:22 <aarvar> or nothing
14:36:22 <Alxandr> Yeah, thanks :)
14:36:51 <Alxandr> But again, was the "writer monad with endo spec" comment for me?
14:36:58 <aarvar> yes
14:37:16 <Alxandr> http://debasishg.blogspot.no/2013/06/endo-is-new-fluent-api.html <- is this the endo thingy you're talking about?
14:37:23 <aarvar> probably not
14:37:35 <Alxandr> Thanks. I'll look into it
14:37:35 <aarvar> newtype Endo a = Endo { appEndo :: a -> a }
14:37:48 <aarvar> its a monoid where append is composition
14:37:57 <Alxandr> I see
14:38:01 <Alxandr> Sounds simple enough
14:38:46 <Alxandr> I'm contemplating wether I need it to be a monad, or just go with applicative
14:38:51 <aarvar> endo being short for endomorphism, if you like mathy words
14:38:54 <Alxandr> Which I think was also suggested
14:38:58 <benzrf> ooh, writer with endo is an interesting concept
14:39:19 <benzrf> kinda like state minus `get'
14:39:24 <Alxandr> Never used the Writer monad either, so that'll be fun -.-
14:41:52 <aarvar> Alxandr: well, what would your applicative instance do
14:42:26 <Alxandr> Well, combining two instances of ApiPart is actually pretty easy
14:42:36 <Alxandr> WebPart is a monad, so that's covered
14:42:49 <Alxandr> And the Spec -> Spec I can just use functional composition on most of the time
14:43:04 <Alxandr> That's what I had before I figured I wanted to structure thing a bit better
14:43:11 <aarvar> so that's WriterT (Endo Spec) WebPart then
14:43:18 <Alxandr> And rewrote it to be cleaner, and hopefully more monadic/similar
14:43:18 <aarvar> if you're composing the Spec -> Spec functions
14:43:32 <aarvar> though you might not want to use WriterT, for performance reasons
14:43:49 <Alxandr> Well, TBH I'm not using Haskell at all, so no worries there :P
14:44:00 <aarvar> blasphemy
14:44:16 <Alxandr> It's just you guys tends to have answers about how to solve these kinds of things functionally and pure
14:44:21 <Alxandr> Cause that's what you do
14:44:40 <Alxandr> Also the perf is likely not an issue, because the spec is being generate once, during application startup
14:44:51 <Alxandr> Only the WebPart composition has to be performant
14:46:11 <Alxandr> But yeah, I just had such good help here last time, with my confusion of foldl vs foldr in haskell, so I figured you guys might be able to help me again :)
14:46:15 <Alxandr> Really appreciate it
14:46:25 <Alxandr> Sorry for taking you time with my blasphemy :P
14:46:28 <aarvar> Alxandr: did you watch dibblego's talk on that?
14:46:45 <Alxandr> No, dunno who that is, or what talk we're talking about
14:46:47 <aarvar> dibblego = Tony Morris
14:46:59 <Alxandr> On endos?
14:47:04 <aarvar> no, folds
14:47:07 <Alxandr> Oh
14:47:10 <aarvar> on foldl vs foldr
14:47:16 <Alxandr> No, but I got it now though
14:47:23 <aarvar> k
14:47:35 <Alxandr> Basically, I'd written a monadic parser (like parsec)
14:48:02 <Alxandr> And was checking that foldl and foldr did the same thing with it
14:48:13 <Alxandr> But I thought foldr was basically reverse >> foldl
14:48:16 <Alxandr> Which is not true
14:49:11 <aarvar> yep, foldr can't be implemented in terms of foldl
14:49:17 <Alxandr> Lol, when I search for "endo monad" on youtube I get dubstep :P
14:49:30 <aarvar> it's not a monad
14:49:34 <Alxandr> Right
14:49:37 <Welkin> endofunctor
14:49:40 <Welkin> Left
14:50:09 <Alxandr> https://www.youtube.com/watch?v=Qcs_f8FwnhY
14:50:16 <geekosaur> it's a mon*oi*d
14:50:19 <Alxandr> This is what I got
14:50:22 <Alxandr> Yeah, sorry
14:50:33 <aarvar> Alxandr: yeah, pronounce it exactly like that
14:50:59 <Alxandr> :P
14:51:11 <Alxandr> Well. I have some blog posts to read
14:51:16 <Alxandr> Hopefully they'll enlighten me :)
14:51:19 <aarvar> Endo is not short for endofunctor though
14:51:33 <Alxandr> No, I tried endomorphism
14:51:55 <Alxandr> Which gave me math talks
14:52:01 <Alxandr> Which I don't really need atm
14:52:27 <monochrom> endomorphism just means "X -> X"
14:52:35 <aarvar> but it sounds cooler
14:52:43 <Adeon> maybe it's endomorphine
14:52:57 * hackagebot glirc 2.12 - Console IRC client  https://hackage.haskell.org/package/glirc-2.12 (EricMertens)
14:54:22 <Alxandr> So any function from x -> x is an endo?
14:55:31 <aarvar> yes, but a -> a has a different monoid instance
14:56:05 <Alxandr> Ah
14:56:12 <Alxandr> So composition works differently?
14:56:41 <aarvar> appending works differently
14:57:20 <ReinH> The monoid instance on functions is Monoid m => Monoid (a -> m)
14:57:36 <Alxandr> Wow, this article might be explaining my problem exactly: https://ocharles.org.uk/blog/posts/2013-02-12-quick-dsls-with-endo-writers.html
14:57:52 <Alxandr> I also have grudgingly defined an "empty" spec state
14:57:56 <Alxandr> Which is not technically valid
14:58:10 <ReinH> Endo is a newtype wrapper for a -> a that lets us choose the (.) id monoid.
14:58:15 <aarvar> > ((++"foo") <> (++ "bar")) "baz"
14:58:17 <lambdabot>  "bazfoobazbar"
14:58:51 <aarvar> > appEndo (Endo (++"foo") <> Endo (++ "bar")) "baz"
14:58:56 <lambdabot>  "bazbarfoo"
14:59:46 <Alxandr> right
15:00:11 <Alxandr> What's <> again?
15:00:16 <monochrom> mappand
15:00:21 <monochrom> err, mappend
15:00:22 <aarvar> :t (<>)
15:00:25 <lambdabot> Monoid m => m -> m -> m
15:00:50 <Alxandr> Thanks
15:06:02 <Squarism> so do you recommend package "mysql-simple" package?
15:12:06 <ali_> A bit of a metaphysical question guys. In a functional language like Haskell. Why doesn't -O3 make ghc compile the program, run it get the output and then make a new program that just prints it?!
15:12:29 <maerwald> ??
15:12:32 <aarvar> lol
15:13:01 <oherrala> ali_: there has been such project back in days
15:13:02 <aarvar> ali_: what if the program reads a file?
15:13:03 <et09> is there a Prelude equivalent to Ruby #sort_by 
15:13:04 <kadoban> ali_: Because haskell programs very very often depend on their input. If they didn't ... haskell wouldn't be a very useful language.
15:13:26 <hpc> :t sortBy
15:13:27 <ali_> aarvar: then this particular compiler optimization isn't applied :D
15:13:27 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
15:13:46 <et09> wow.  dumb q i see
15:13:54 <hpc> et09: ;)
15:13:56 <oherrala> ali_: I think it was called Supero or something
15:14:06 <ali_> oherrala: that is hilarious
15:14:17 <hpc> et09: if you can imagine what you want the type of it to be, usually hoogle will find it
15:14:20 <hpc> @hoogle
15:14:24 <lambdabot> package base
15:14:24 <lambdabot> package bytestring
15:14:24 <lambdabot> package containers
15:14:31 <hpc> @where hoogle
15:14:31 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
15:14:39 <et09> that is cool
15:14:41 <hpc> i could have sworn blank @hoogle printed that link
15:14:51 <ali_> kadoban: if you don't have side effects then your program is "useless".
15:15:17 <aarvar> ali_: what do you mean by side effect
15:15:27 <Alxandr> What's ~@~?
15:15:40 <kadoban> ali_: If your program can't respond to the input it gets, it's not very often a useful thing.
15:16:07 <ali_> aarvar: So if it doesn't alter a state.
15:16:26 <aarvar> ali_: what does that mean
15:16:47 <et09> typeclasses are sooo cool
15:17:01 <et09> it's correct to call those polymorphism right
15:17:09 <johnw> it's one kind of polymorphism, yes
15:17:15 <ali_> aarvar: I guess I mean nothing is maintains between function calls, 
15:17:36 <et09> btw does 'polymorphism' break down to 'many morphism' as in category theory morphism/arrow
15:17:56 <ali_> so no matter how many times you call a function you get the same resilt, which means it can't be altered by input since that means calling main will have variable results
15:18:16 <ali_> kadoban: http://codepad.org/g6wZqqIG this code is useful and takes no input
15:18:43 <aarvar> except evaluating main and running the resulting executable of a haskell program aren't the same thing
15:19:22 <aarvar> main returns a value representing what the executable does
15:19:25 <ali_> aarvar: compiled Haskell code still has a "main" routine that takes arguments and returns them.
15:19:32 <geekosaur> Alxandr, I don't think that can be anything /per se/. What's the context?
15:19:36 <aarvar> actually, main is a value, not a function
15:19:51 <aarvar> so it takes no arguments
15:19:56 <ali_> aarvar: and no matter how many times you ran that program other than "print" those values would never change? print might... get ruined?
15:20:06 <Alxandr> I'm looking at Endo sources
15:20:12 <aarvar> ali_: not sure what you mean
15:20:16 <Alxandr> Found the source here though: http://hackage.haskell.org/package/between-0.11.0.0/docs/src/Data-Function-Between-Lazy.html
15:20:38 <kadoban> Alxandr: I didn't say "always", which was deliberate.
15:20:42 <Alxandr> Definitely one of the more crazy operators I've seen :P
15:20:46 <kadoban> ali_: ^
15:20:58 <ali_> aarvar: aren't command line arguments passed on the stack to main like they would be in C?
15:21:17 <ali_> and main does it's business and returns a value?
15:21:24 <aarvar> :t getArgs
15:21:25 <lambdabot> error: Variable not in scope: getArgs
15:21:32 <aarvar> er..
15:21:34 <hpc> ali_: the only specification for command-line arguments is that getArgs produces them
15:21:43 <hpc> ali_: and main always has type IO a, for some a
15:21:47 <ali_> mhmm looking at some codes I actually can't see a pop in my "main"
15:21:47 <aarvar> :t System.Environment.getArgs
15:21:49 <lambdabot> IO [String]
15:22:08 <hpc> the only values in haskell that are functions are those that have (->) at the root of their type
15:22:10 <et09> does anyone in here know HL7 
15:22:42 <ali_> So, still. whenever you run that program it's garanteed to return the same results right? Even if main doesn't the bit before print $ does.
15:22:53 <Alxandr> Lol, this looks so much worse in F#: ((<<) f) << ((>>) g)
15:23:02 <ali_> Since you have that garantee shouldn't the compiler optimize it away?
15:23:12 <hpc> ali_: you're definitely confusing execution and evaluation
15:23:22 <geekosaur> oh. huh. those chaarcters are special in patterns, but I guess tey can get away with that if defining them in prefix form
15:23:22 <aarvar> main always returns the same thing, no matter how many times you evalaute it. But executing a haskell program doesn't just evaluate main
15:23:30 <hpc> ali_: when you evaluate main, it's the same program every time
15:23:30 <kadoban> ali_: How would it know what command-line arguments you'll get, or what file contents you'll read, or a thousand other possible inputs?
15:23:52 <aarvar> you can think of main as returning the program to be run
15:23:58 <hpc> ali_: executing main is executing that program
15:23:58 <aarvar> it always returns the same program
15:24:00 <ali_> kadoban: because this one program does none of those things. It just outputs an answer of stdout.
15:24:09 <chsn> database constraints are fundamentally dynamic in nature: this set of columsn is unique.... taht over there is a foreign key for this .... is there a nice way to have a DSL for expressing constraints ?
15:24:15 <geekosaur> anyway they're defined further in; (~@~) is the infix form of "between" and (~@@~) is infix "flip between"
15:24:20 <ali_> hpc: I'm sure I'm confusing something
15:24:30 <kadoban> ali_: Ah, yes a program that does no input could theoretically be optimized down to just a print, or whatever output it does. GHC doesn't do that though.
15:25:07 <ali_> kadoban: I was asking. on a metaphysical level why not? I mean we have those garantees in Haskell?
15:25:20 <aarvar> you might not want it to
15:25:21 <kadoban> If you actually wanted this to happen, you could just write your code in TH, have it happen at compile time and really just end up with a print. You'd have to do that though.
15:25:22 <ali_> It was more tongue in cheek than anything
15:25:35 <ali_> kadoban: TH?
15:25:38 <kadoban> ali_: There's no metaphysical, it's for practical reasons ... it doesn't come up enough that anyone has cared.
15:25:43 <aarvar> template haskell
15:25:44 <kadoban> Template Haskell
15:25:59 <monochrom> metaphysical level is when you don't run a program, you just prove it correct.
15:26:07 <ali_> haha monochrom 
15:26:15 <kadoban> There's likely also practical reasons it'd be harder than it seems to do, but I dunno.
15:26:17 <hydraz> So Coq?
15:26:49 <kadoban> I've been learning coq recently, it's fun.
15:27:08 <monochrom> No, not so Coq. So Dijkstra.
15:28:15 <andromeda-galaxy> ali_: looking at my logs, if I have not misunderstood what you are talking about, this is basically partial evaluation.  In the special case where $I_\mathrm{static}$ is empty, then the program can be optimized down to just outputting the result
15:28:41 <aarvar> Something chessboard something something dominos
15:28:43 <andromeda-galaxy> I don't know of any reasonable systems that try to apply partial evaluation without users marking what to partial-evaluate, though
15:28:47 <ertes> ali_: can you explain the difference between Integer and IO Integer in your own words?  how are (x :: Integer) and (getX :: IO Integer) different?
15:28:51 <andromeda-galaxy> aarvar: what?
15:29:05 <aarvar> andromeda-galaxy: dijkstra
15:29:15 <hydraz> Something something random LaTeX
15:29:39 <andromeda-galaxy> aarvar: ah, right
15:30:07 <andromeda-galaxy> hydraz: oops, sometimes I forget that not everyone stares at latex half the day every day and can render it in their heads...
15:30:39 <andromeda-galaxy> practically speaking, I would love if irc clients that rendered \LaTeX became something lots of people used, though. 
15:30:48 <ali_> ertes: no, not at all.
15:31:08 <hydraz> Well, I can render _some_ LaTeX, but you can't expect me to remember \everything
15:31:17 <ertes> ali_: just try it
15:31:31 <ali_> ertes: I'm really new to Haskell and was working my way through Project Euler when I realised Haskell should know this program never does anything different
15:31:38 <andromeda-galaxy> I just used roman fonts and subscripts!
15:31:56 <hydraz> Oh, so that's what mathrm does
15:32:08 <aarvar> ali_: though it doesn't know it terminates
15:32:13 <monochrom> pidgin has a plugin that renders latex
15:32:21 <aarvar> monochrom: what is it?
15:32:24 <Alxandr> Anyways. Thanks again for the help. I'll experiment a bit on my own. Might be back if I shoot myself in the foot too many times though :P
15:32:37 <ali_> aarvar: what does that mean?
15:32:39 <ertes> ali_: this is probably the most important thing you will ever learn about haskell, so give it a shot, and we'll (or at least i'll) help you correct misunderstandings
15:32:45 <monochrom> pidgin does irc and icq and jabber and so on.
15:32:48 <aarvar> ali_: the program might loop forever
15:32:53 <andromeda-galaxy> monochrom: neat!
15:33:00 <andromeda-galaxy> aarvar: well, something something we all want a termination checker
15:33:18 <aarvar> andromeda-galaxy: something something but we don't have one
15:33:38 <hydraz> something something #idris is that way
15:33:47 <aarvar> something something idris sucks
15:33:57 <ali_> aarvar: As in during the first run it doesn't know it may terminate? Like a halting problem issue? Well just timeit out
15:34:02 <andromeda-galaxy> in theory, there is no difference between theory and practice. hydraz: yeah I've been spending too much time on idriz
15:34:23 <andromeda-galaxy> aarvar: sorry to carry on two discussions here, but I'm really curious - why do you say that?
15:34:27 <aarvar> no typeclasses and weaker type inference, no thanks
15:34:29 <hydraz> something something fair point, aarvar
15:34:55 <aarvar> and no irrelevance, meaning less parametricity
15:34:57 <monochrom> I am my termination checker.
15:35:04 <andromeda-galaxy> interfaces seem to handle everything that I use typeclasses for
15:35:16 <ali_> ertes: I genuinely don't know, maybe IO Integer isn't garanteed to be an Integer?!
15:35:20 <hydraz> umm
15:35:27 <aarvar> andromeda-galaxy: try using them with dependent types
15:35:29 <hydraz> http://docs.idris-lang.org/en/v0.9.20/tutorial/classes.html
15:35:31 <andromeda-galaxy> the type inference is a valid point though.  If you use existentials et al in haskell it's quite a mess too
15:35:32 <aarvar> you'll run into problems
15:35:40 <aarvar> hydraz: they aren't the same as type classes
15:35:46 <ali_> ertes: I haven't really looked into IO yet all I do is try and get my stuff printed and or read in!
15:36:02 <ertes> ali_: x is an integer, a number, a value
15:36:10 <andromeda-galaxy> aarvar: really, is that a fundamental limitation or part of the inference problem(s)?
15:36:13 <aarvar> if you have B and C instances in scope, and B and C each imply A, there's no guarantee that the two A instances are the same
15:36:33 <ali_> ertes: I agree so far
15:36:43 <ali_> ertes: What is an IO Integer?
15:36:44 <aarvar> so if B and C both contain proofs about their respective A instances, you still don't have two proofs about a single A instance
15:36:53 <ertes> ali_: getX is a program to produce an Integer
15:36:53 <aarvar> so the classes don't compose
15:37:12 <aarvar> not to mention, your program's behavior depends on which instance the compiler chooses
15:37:21 <ertes> ali_: it's another value, but a completely different type of value:  it's *not* an integer, but more like a recipe/action/program to come up with one
15:37:46 <hydraz> Makes me ask: -XDependentTypes when?
15:38:07 <andromeda-galaxy> aarvar: hmm, that makes sense... admittedly I can't imagine that type classes in HS that carry proof witnesses wouldn't have the same problem
15:38:18 <ertes> ali_: getX is indeed the same program, no matter how often you refer to it or how often you give it different names:  let y = getX  -- y is still a *program*, the same program as getX
15:38:19 <aarvar> andromeda-galaxy: they dont
15:38:21 <ali_> ertes: Ah, mhmm, I don't htink I appreciate the difference. I'd want to be able to use a function which returns type A as though it were a object of type A
15:38:27 <andromeda-galaxy> aarvar: hmm, why?
15:38:46 <ali_> ertes: And I'd want the language to do all the foot work to let me do that!
15:38:59 <aarvar> in haskell, there can only be one instance per type (though you can violate this rule, but you shouldnt)
15:39:03 <andromeda-galaxy> is it because of idris's named instances, which allow more than one instance?
15:39:04 <ali_> If it's garanteed to return a type A that is
15:39:13 <ertes> ali_: don't worry, it will, but it's important to understand what it does and how
15:39:19 <aarvar> though the restriction of only one instance per type is too restrictive really, and also bad
15:39:21 <aarvar> but less bad
15:39:49 <ertes> ali_: you're familiar with (getLine :: IO String) and (putStrLn :: String -> IO ())?
15:40:14 <ali_> ertes: But still, I'm not sure I'm getting accross what I am saying. I feel like the programmer can reason about this program (http://codepad.org/g6wZqqIG) and realise if you have the result once, you have the result forever.
15:40:19 <ali_> ertes: Yeah
15:40:28 <andromeda-galaxy> yeah, it seems like there should be a magic middle ground there that no one can find....
15:40:32 <aarvar> andromeda-galaxy: aside from being inconvenient, it leads to ugliness like nominal type roles
15:40:43 <ali_> and I feel like Haskell too should know that.
15:40:45 <aarvar> andromeda-galaxy: there probably is
15:40:50 <andromeda-galaxy> indeed
15:41:18 <ali_> Kind of like let x = 3**3. I would be shocked if ghc didn't just use 27
15:41:26 <aarvar> I think one could have "local coherence", where there's guaranteed only one instance for a type in any given scope
15:41:38 <ertes> ali_: then you will be shocked
15:42:09 <ertes> ali_: purity is not an optimisation…  it can be used as one in some cases, but only manually
15:42:33 <aarvar> then you lose the ability to guarantee that two `Set a`s use the same Ord instance, but if you have dependent types you should really do Set : (a : Type) -> Ord a -> Type anyway instead
15:42:34 <ertes> > let x = 3^10 in x + x  -- ali_: here i've used sharing
15:42:37 <lambdabot>  118098
15:42:38 <roboguy`> idStar :: * -> *; idStar = id        -- GHC 8 accepts this... is it possible to actually apply it or use it somehow?
15:42:48 <andromeda-galaxy> aarvar: doesn't that still lead to nominal roles?
15:42:53 <aarvar> andromeda-galaxy: no
15:43:11 <monochrom> ali_: Suppose I implement the Ackermann function, then write the program "main = print (ackermann 100 200)". When, do you propose, should the time be spent?
15:43:22 <ertes> ali_: purity is a semantic guarantee, not an efficiency guarantee, just like laziness
15:43:29 <ali_> ertes: I thought purity was there so we could reason and if we can reason haskell should be able to make something "pure" or "impure". If an entire function is pure and recives no arguments then just optimise it away?
15:44:11 <aarvar> andromeda-galaxy: how would it?
15:44:12 <hydraz> If a function is pure and takes no arguments it's useless
15:44:15 <ertes> ali_: haskell does not evaluated stuff at compile time, except for some trivial things it's programmed to evaluate
15:44:17 <roboguy`> ali_: a function with no arguments isn't really a function
15:44:21 <orzo> ali_: the issue is the halting problem.  In general, haskell expressions don't terminate, so for the compiler to do this optimisation, it'd need firs tto prove the expression terminates
15:44:39 <ali_> orzo: run it once see what happens? if it terminates once it always will
15:44:39 <andromeda-galaxy> ali_: that is a transform that would be valid, but for operational reasons it is generally considered that that is not a transformation that is particularly useful to be done in general. hydraz: this is about writing programs that are meant to compute one specific answer, the parameters are all in the source and so part of $I_\mathrm{static}$
15:44:49 <ertes> ali_: the reason is that the compiler cannot calculate how long the evaluation will take
15:44:52 <aarvar> orzo: you could argue that it'd be better to find non-termination at compile time :)
15:45:10 <ali_> ertes: it can compile it niavely once and time it once...
15:45:11 <hydraz> ah
15:45:19 <andromeda-galaxy> ali_: can't tell the difference when running it once between nontermination and taking a long time. orzo: sometimes termination checkers are a good tradeoff
15:45:20 <aarvar> but then you can still have codata (infinite lists) that you dont want to fully evaluate
15:45:22 <orzo> well there's things the compiler could do, but the genral problem of deciding termination is hard
15:45:26 <ertes> ali_: i'm glad it doesn't do that for every value that comes up =)
15:45:43 <ali_> ertes: which is why I asked about a metaphorical -O3
15:45:54 <ali_> ertes: although ghc does use accept -O3!
15:46:07 <roboguy`> ali_: it cannot tell if an arbitrary Haskell expression will terminate, so compilation might not terminate
15:46:09 <ertes> ali_: that -O3 would be a metaphor for unlimited patience
15:46:10 <ali_> I was thinking of gcc only accepting -O2
15:46:16 <monochrom> I think ali_ would be the happiest with an interpreter. In which there is no line between compile time and run time.
15:46:19 <roboguy`> also, evaluations can depend on the results of IO actions
15:46:42 <hydraz> Just imagine GHC compile times if it tried to solve the halting problem for evely function
15:46:45 <ali_> ertes: yes. but sometimes it's worth waiting for once if it'll save time for everyone.
15:46:53 <orzo> i'd like ghc to distinguish -O1 and -O2, -O1 would be only very cheap in compile-time optimisations
15:47:06 <aarvar> ali_: then you can already do that with TH
15:47:09 <aarvar> if you really want to
15:47:10 <ertes> ali_: in those rare cases you can instruct the compiler to evaluate at compile time using TH
15:47:24 <ali_> ertes: Imagine if you could take a day to compile some spam filter for facebook that lead to a 0.01% improvement thats stillworth while considering how much data that churns through.
15:47:30 <monochrom> Given my program, the interpreter would first prove that ackermann 100 200 is a huge number, and would do it ASAP.
15:47:44 <roboguy`> ali_: this kind of optimization, by the way, is called partial evaluation. It isn't really practical to do in all cases though
15:47:55 <ali_> I think once I'm better aquanted with Haskell I'll checkout TH
15:47:57 <roboguy`> (that's the "partial" part of "partial evaluation")
15:47:58 * hackagebot keysafe 0.20160831 - back up a secret key securely to the cloud  https://hackage.haskell.org/package/keysafe-0.20160831 (JoeyHess)
15:48:33 <aarvar> ali_: what if I have an infinite list? how does the compiler know not to evaluate that?
15:49:03 <aarvar> or even a very large list where I'm only going to use part of it
15:49:09 <ali_> aarvar: this would only apply if the compiler program terminated in some finite time which you chose. I don't know what that would need to be to be worth while
15:49:36 <ali_> but if your code will run *alot* why not accept x10 compile times for your "release"
15:49:44 <mmaruseacph2> ali_: you're thinking of ghc --supercompile --finish-in=5min ?
15:49:53 <ali_> mmaruseacph2: I guess so!
15:49:58 <andromeda-galaxy> roboguy`: it is impossible to generally and *perfectly* decide if a given program and given input will terminate.  It is possible to do it reasonably well, especially with hints given by the programmer - like the use of well-founded recursion
15:49:58 <roboguy`> some GHC optimizations already behave in that way, on a smaller scale
15:50:16 <orzo> aarvar, ali_, there should be some keyword to hint to the compiler to fully evaluate at compile time (instead of using template haskell)
15:50:20 <mmaruseacph2> but then the compilation results will be greatly influenced by what you were running at the time
15:50:27 <roboguy`> andromeda-galaxy: yeah. That's my point
15:50:38 <JonReed> ali_: Imagine this: `let expr = [1..]; forM_ expr (print)`. A valid usecase migth be termining a program via Ctrl+C at runtime until you get enough output. If you evaluate this at compile time, you will never compile it.
15:50:39 <ali_> roboguy`: yeah I basically mean partial evaluation on a wider scale now that we have some benefits of being able to segregate "pure" code
15:50:45 <mmaruseacph2> imagine compiling the same code while no other thing is running on your machine or when you already have 90% of RAM filled
15:50:46 <ertes> ali_: where does that strategy end?  you can always squeeze out 0.01% by making the compiler smarter, but the cost of making the compiler smarter gets progressively higher
15:50:54 <andromeda-galaxy> roboguy`: oops, sorry, got you confused with orzo
15:51:03 <mmaruseacph2> the first time it might finish evaluating a big thunk in that time and get a supercompiled binary
15:51:06 <ali_> JonReed: this would be the final step in some "super" compile step
15:51:14 <mmaruseacph2> while the second time it won't, so you'd get the non-optimized code
15:51:25 <aarvar> JonReed: or taking a number, n, as input and printing out n elements of that infinite list
15:51:30 <mmaruseacph2> also, what JonReed says
15:51:37 <ali_> ertes: I agree, but when 0.01% of facebooks anti-spam budget puts that ceiling of diminishing returns very friggin high no?
15:51:43 <andromeda-galaxy> aarvar: also ^
15:51:46 <kadoban> ali_: A lot of this would be possible, for some programs. It just hasn't been added, probably because nobody has wanted it badly enough. I suspect the cases where it'd actually matter don't come up very much. It's hard for something that could be done at compilation time to be the bottleneck in what a real program is doing. It's pretty much *only* project euler type stuff.
15:51:49 <roboguy`> ali_: well, as I said, we already do that to a degree. It is also impossible to do in all cases even with a time limit
15:52:08 <roboguy`> because things may depend on IO action results
15:52:33 <andromeda-galaxy> orzo: Idris is trying to do something like that, although it only goes as far as specializing functions.  It'd definitely be nice not to have to manually encode it all in TH.
15:52:36 <monochrom> Yeah, "want it bad enough" is key. Time to ask: How much money will you pay for this?
15:52:48 <ali_> Yeah, I was just excited by the prospect of programmers putting pure code in segregated parts of the program and Haskell potentially being aware of that!
15:52:50 <kadoban> ali_: A lot more common than 0.01% would be, a constant 2 seconds maybe. And then you wonder wtf you're acutally doing. If you were facebook, it'd instead make more sense to profile, see that "oh this evalutation is happening a lot and it could be done at compile time, let's just throw in some TH".
15:53:25 <ertes> ali_: not necessarily…  the problem is that the return of investment is very difficult to calculate: it's almost impossible to estimate how much extra time the compiler will need to even make a difference, and how much that difference will be…  most likely it will be very small at a very high cost
15:53:27 <roboguy`> ali_: to be fair, some of GHCs optimizations definitely rely on that fact. That is part of why unsafePerformIO can be so unsafe!
15:53:27 <andromeda-galaxy> more precise effects systems would also be quite useful here, in theory, since you could isolate exactly the bits that require getting *dynamic* data
15:53:33 <kadoban> You're certainly right that sometimes it would be theoretically possible for a compiler to do. I suspect you're overestimating how often it'd help (and possibly how cheap it'd be to do).
15:53:40 <ertes> ali_: so a more predictable strategy is to just improve the code itself
15:54:20 <andromeda-galaxy> but yeah, there are not that many cases where enough static information is available for something like this to be a really useful optimization
15:55:08 <roboguy`> ali_: you might be interested in the paper "Secrets of the GHC Inliner," which talks a bit about some of GHC's inlining-type optimizations
15:55:12 <ali_> ertes: I think I might be asking too much "creativity" of the compiler but I just thought if the compiler knows function X takes no arguments and is pure it could optmize it away in the time it would take to run the naive function once
15:55:48 <aarvar> ali_: (it's not a function then, btw)
15:55:53 <ali_> roboguy`: looks good, microsoft reasearch and over 100 cites!
15:56:08 <ertes> ali_: you're asking to precompute values (no functions involved)
15:56:22 <ertes> ali_: and we're trying to explain how that problem is a lot less trivial than you think =)
15:56:25 <ali_> aarvar: what would you call it? Is it not a function because it wouldn't make sense in the sentence " it's a function of X"?
15:56:44 <roboguy`> ali_: yep. It's written by Simon Peyton Jones, one of the creators and maintainers of GHC
15:56:46 <ertes> ali_: it's not a function, because it has no (->)
15:56:49 <aarvar> all functions take one argument
15:56:57 <aarvar> 1 != 0
15:57:10 <ali_> ertes: What I don't understand is. The code I linked above runs in about 3 seconds and compilers in about 5 on my computer. 
15:57:15 <aarvar> therefore if it takes 0 arguments it's not a function
15:57:17 <aarvar> qed
15:57:38 <ali_> ertes: Any programmer at least will realise it is pure. Run that code once and you will get the same anser on the one billionth run.
15:57:46 <andromeda-galaxy> ali_: I guess that what you are looking for in this case as actually more constant folding than partial evaluation?
15:57:53 <ali_> So why don't a compiler just print that out?!
15:58:13 <ertes> ali_: because you're writing a program to compute it…  you're not hard-coding the result
15:58:27 <ali_> ertes: if it's pure the result today will be the result tomorrow
15:58:39 <ali_> and if that takes 3 seconds then why not optimise to that. 
15:58:44 <aarvar> ali_: then run it once and write down the result
15:58:49 <ertes> ali_: yes you did not write the result, you wrote an algorithm
15:58:58 <andromeda-galaxy> ali_: this is indeed something that could be done
15:59:05 <andromeda-galaxy> ali_: however it is not something that is actually useful very often
15:59:07 <ertes> s/yes/yet/
15:59:18 <andromeda-galaxy> ali_: most things depend on a lot of dynamic data that is not known until runtime
15:59:18 <kadoban> ali_: Same reasons as above. GHC isn't checking for that because nobody wrote that code because it doesn't come up as much as you probably think it does (because you're doing project euler, which are *very* strange programs in this sense, in general).
15:59:22 <ali_> aarvar: in this case. but sometimes there is a function lets say I take input x and print "X:{}", result of pure bit
15:59:42 <ertes> ali_: if you want to write the result, write the result…  the GHC will gladly just compile it to a value =)
15:59:42 <andromeda-galaxy> ali_: it is not useful often enough that anyone has wanted to make ghc do it
15:59:47 <ali_> I agree with the argument it's not particularly useful
15:59:51 <roboguy`> ali_: if you want to use the same result later in the program, you can bind it to a name. Once that happens, the computation associated with that name will only be computed once
16:00:09 <roboguy`> (at most)
16:00:10 <andromeda-galaxy> ali_: that is the basic reason that ghc does not do it
16:01:22 <aarvar> andromeda-galaxy: if its not useful that sounds like a great reason to implement it
16:01:27 <aarvar> avoid success at all costs!
16:01:50 <ertes> ali_: if you really want to encode the result instead of the algorith, you want to compute a program
16:01:54 <ali_> I suppose the bigger issue is. If it were useful then your programmers need to start thinking about the code they wrote
16:01:59 <andromeda-galaxy> aarvar: unfortunately the people giving out the 3-year research grants don't agree
16:02:02 <ertes> ali_: the language to compute programs is template haskell
16:02:22 <aarvar> andromeda-galaxy: just tell them it's useful
16:02:35 <ertes> ali_: but it's rarely worth the effort
16:02:46 <andromeda-galaxy> ali_: relevant: https://www.reddit.com/r/haskell/comments/1kpu1h/can_haskell_programs_be_compiled_such_that_the/. 
16:03:21 <ali_> andromeda-galaxy: That is *exactly* what I had in mind
16:03:21 <JonReed> ali_: I imagine you could do something like `[compileEval|expr]` where expression creates a list and then computes its length at runtime. 
16:03:39 <ertes> ali_: i have used TH once for this purpose, and it was more a hack to get GHC to properly inline a statically known value
16:03:54 <ali_> It just seems like the "next step" in compilers in pure functional languages (to newbies at least)
16:04:00 <andromeda-galaxy> aarvar: there apparently are some research projects on it, actually. just none of them have gotten too far because it's a little annoying to do, and noone cares enough about it
16:04:02 <JonReed> at complite time*
16:04:03 <ertes> that's once in ~9 years of haskell =)
16:04:36 <ertes> ali_: you're really overvaluing that feature, mostly because you're not considering the cost of actually implementing it
16:04:48 <andromeda-galaxy> apparently niel mitchell has been doing something like that, but  more general: https://github.com/ndmitchell/supero
16:04:50 <ertes> ali_: feel free to grab the GHC source code and give it a shot to get a feeling for the latter
16:04:56 <aarvar> ertes: but if we assume haskell will be around for another 90 years, that's an average of 10 more times you might use it
16:05:18 <aarvar> if you live that long
16:05:38 <aarvar> maybe reduce the assumption to 45 years
16:05:48 <ertes> aarvar: in machine learning terms your model is most likely overfitting with the single sample you have =)
16:06:02 <andromeda-galaxy> ali_: I think that basically it is that there is another problem right next door which is *much* more tantalizing which is partial evaluation/supercompilation/etc which is more about doing the absolute most that you can with static data, includes unfolding optimizations, stuff like that.
16:06:08 <aarvar> ertes: details details
16:06:10 <andromeda-galaxy> that is useful much more in practice, and what stuff like supero tries to do
16:06:34 <ali_> andromeda-galaxy: I couldn't find supero, all I could find is spanish nursing guidance haha
16:06:35 <andromeda-galaxy> ali_: unfortunately it is also much harder, so all the people working on it aren't done yte
16:06:40 <ertes> aarvar: also it was a matter of putting TH brackets around my code…  not a particularly expensive optimisation
16:06:58 <andromeda-galaxy> ali_: https://github.com/ndmitchell/supero
16:06:59 <aarvar> ertes: but what if your bracket key was broken
16:07:02 <chsn> why is https://github.com/agentm/project-m36 not more popular? this sessme like one of the most projects in haskell 
16:07:42 <ertes> aarvar: i'll gladly buy a new keyboard in that case =)
16:07:59 <ali_> andromeda-galaxy: thanks, it's awesome that this exists.
16:08:33 <ali_> andromeda-galaxy: less so that it's had less than 1000 commits in 10 years!
16:08:51 <andromeda-galaxy> ali_: yeah, progress has been sporadic
16:09:49 <JonReed> Hm, would trying to compile more complex datastructures like $([1..10]) work. I imagine that some of them will be represented as pointers... or not?
16:10:00 <andromeda-galaxy> ali_: there are some SPJ papers that look relevant, too, I gues
16:11:47 <ali_> andromeda-galaxy: SPJ
16:11:51 <ali_> ah simon peyton jones?
16:16:26 <andromeda-galaxy> ali_: yes
16:24:19 <andromeda-galaxy> this may not be the right channel for this, but does anyone know if anyone's done much complexity analysis of pure LC functions (e.g. assuming that the reduction operations of LC are supported in hardware)?
16:24:44 <andromeda-galaxy> (also does anyone know of a more appropriate channel?)
16:27:07 <andromeda-galaxy> e.g. I am curious about fun things like: is there a purely functional multiplication algorithm that has the asymptotics of Karatsuba or better (Schönhage–Strassen)?
16:28:50 <c_wraith> nothing about Karatsuba requires mutation, for its asymptotics 
16:29:30 <Squarism> I understand "myfkn :: Eq a => a -> Bool. But i get a bit confused on this declaration " app :: MonadWidget t m => m () ". How should i interpret m here ?
16:30:05 <aarvar> Squarism: which part of it are you confused by
16:30:24 <Squarism> that m should satisfy the type bounds MonadWidget's  second type parameter?
16:30:30 <Squarism> of ..
16:30:40 <aarvar> so, the multiparam typeclass is confusing?
16:31:21 <Squarism> in the first function i understand a should derive equals
16:31:44 <Squarism> in the second i dont know what to say of m
16:32:02 <andromeda-galaxy> c_wraith: sure, but it does it on church encodings?
16:32:03 <aarvar> it means that there needs to be a MonadWidget instance for the pair of types t and m
16:32:17 <Squarism> ah ok
16:32:18 <aarvar> though in this case there's a functional dependency saying m needs to imply t
16:32:35 <aarvar> so you can interpret it as MonadWidget m, where there's some type t determined by m
16:32:53 <c_wraith> andromeda-galaxy, church encoding might lose efficiency. but why would you church encode a large matrix anyway? 
16:33:10 <andromeda-galaxy> c_wraith: because my hardware doesn't support numbers it just supports pure LC terms
16:33:16 <andromeda-galaxy> lamba terms and applications, thats it
16:33:39 <aarvar> that's some interesting hardware
16:33:41 <andromeda-galaxy> then my number have to be encoded somehow, church, scott, perigot, something like that
16:33:41 <c_wraith> ah. missed that detail. church encodings tend to lose sharing. that might be a problem. 
16:33:58 <andromeda-galaxy> and then the asymptotics questions become "how many reduction steps does this take"
16:34:24 <andromeda-galaxy> aarvar: indeed, it doesn't yet exist. but I'm curious about trying to convince my comp arch friends to make it
16:35:26 <andromeda-galaxy> c_wraith: so I was saying for example, is there a complexity analysis that you know of for the asymptotics of multiplication on various encoded numerals, or on finding lower bounds in terms of reduction steps for problems? I have not yet been able to find any
16:40:06 <c_wraith> I don't know if anything. 
16:40:11 <c_wraith> *of
16:47:29 <chsn> is laziness the reason we can't have somehting like http://bloomberg.github.io/bucklescript/slides/Haskell_meetup.html#4 (readable js output)
16:50:04 <ReinH> chsn: have what?
16:50:15 <chsn> a haskell -> js compiler with readalbe output
16:50:37 <Cale> Readable compiler output is a lot of effort for not much value
16:50:54 <Cale> You wouldn't expect your compiler to produce particularly readable x86 output either
16:51:01 <chsn> there's also small output size + fast compilation
16:51:19 <Cale> Small output size is something that's being worked on
16:51:22 <chsn> ghcjs feels like this slow blackbox with complicated machinery ... and if anything bekas, I can't can't figure out why
16:51:44 <chsn> I can't even build ghcjs without (1) using nix of (2) downloadinga prebuilt binary
16:51:53 <chsn> bucklescript just seems small and clean
16:51:57 <puregreen> Cale: cool, is there anywhere I can read more about it?
16:52:07 <Cale> puregreen: Read more about what?
16:52:14 <ReinH> chsn: anything can look small and clean if you know next to nothing about it
16:52:19 <Cale> puregreen: Code size optimisation in GHCJS?
16:52:21 <puregreen> yep
16:52:27 <Cale> puregreen: You'd have to ask Luite
16:52:48 <Cale> But he's been doing a bunch of stuff for us in that direction.
16:53:32 <Cale> There's some new Javascript level deduplication stuff iirc
16:56:10 <umbrjel> can someone point me to an text about folds? Im having a hard time understanding folds that arent basic +, * funcs
16:56:44 <Cale> umbrjel: Well, foldr is particularly nice to explain
16:56:54 <Cale> Are you familiar with how lists are built up from [] and (:)?
16:57:03 <umbrjel> yes
16:57:26 <Cale> So, what foldr f z does is to replace each occurrence of (:) in the construction of the list with f, and the [] at the end (if any) with z
16:57:41 <Cale> So foldr (:) [] is the identity function
16:58:00 * hackagebot semver-range 0.2.2 - An implementation of semver and semantic version ranges.  https://hackage.haskell.org/package/semver-range-0.2.2 (thinkpad20)
16:58:53 <Cale> > foldr (\x xs -> if x < 10 then (10*x):xs else xs) [] [1,2,15,3,4,87,5]
16:58:55 <lambdabot>  [10,20,30,40,50]
16:59:41 <Cale> > foldr (\x n -> 10*n + x) 0 [1,2,3,4,5]
16:59:43 <lambdabot>  54321
17:00:28 <umbrjel> the folds that reduce i understand well, im having trouble with the ones that construct things, like the first that you wrote
17:00:35 <Cale> okay
17:00:52 <umbrjel> i think that recusrion is my main problem hehehe
17:01:02 <Cale> So, remember to think of that first function as our replacement for (:)
17:01:19 <Cale> So imagine we're building the same list, instead of every time there's a (:), we instead apply that function
17:01:49 <Cale> So if the element x is less than 10, we multiply it by 10 and add the result to the beginning of the list
17:02:01 <Cale> otherwise, we skip it altogether
17:02:24 <umbrjel> i think i got it heheh
17:02:31 <Cale> So that's kind of a combination of a filter and a map
17:02:52 <Cale> > foldr (:) [4,5,6] [1,2,3]
17:02:54 <lambdabot>  [1,2,3,4,5,6]
17:03:55 <umbrjel> one more thing, whats a "spine"
17:03:58 <Cale> In this example, we replace the [] at the end of 1 : (2 : (3 : [])) with [4,5,6]
17:04:23 <Cale> The spine of a list refers to the (:) nodes, thinking of the data structure as a tree
17:04:37 <Cale> http://cale.yi.org/share/Folds.svg
17:04:43 <Cale> This diagram might help
17:04:57 <Cale> have a look at the one for foldr in the upper left
17:05:22 <Cale> The spine is the part that's made up of :'s
17:05:33 <Cale> (and perhaps including the [] at the end...)
17:05:57 <umbrjel> well, this just clarified A LOT
17:06:12 <c_wraith> the [] is a vestigial tail. :) 
17:06:24 <Cale> haha
17:06:53 <umbrjel> thank you very much Cale =)
17:07:02 <umbrjel> sorry for my bad english hehe
17:07:14 <Cale> > foldr (\x xs -> concat ["(f ", show x, " ", xs, ")"]) "z" [1,2,3,4,5]
17:07:16 <lambdabot>  "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
17:07:41 <umbrjel> im reading Programming Haskell From First Principles, and some things are still not that clear to me hehe
17:07:45 <Cale> > foldl (\xs x -> concat ["(f ", xs, " ", show x, ")"]) "z" [1,2,3,4,5]
17:07:47 <lambdabot>  "(f (f (f (f (f z 1) 2) 3) 4) 5)"
17:08:01 * hackagebot language-thrift 0.8.0.2 - Parser and pretty printer for the Thrift IDL format.  https://hackage.haskell.org/package/language-thrift-0.8.0.2 (abhinav)
17:08:51 <umbrjel> im trying to understand well folds, to not suffer that much with scans hehe
17:09:18 <c_wraith> umbrjel, your English is excellent. no worries on that matter. 
17:09:43 <Cale> > scanl (+) 0 [1,20,300,4000,50000]
17:09:45 <lambdabot>  [0,1,21,321,4321,54321]
17:10:34 <Cale> > scanr (+) 0 [1,20,300,4000,50000]
17:10:36 <lambdabot>  [54321,54320,54300,54000,50000,0]
17:11:04 <Cale> ^^ compare these results with the diagrams :)
17:11:37 <Cale> The stretched out version of scanl is perhaps better than the coiled up version
17:12:57 <umbrjel> Cale, the diagrams are AWESOME!! =)
17:15:20 <prsteele> so I can write "f <$> (twiddle <$> x) <*> y" or "f <$> (fmap twiddle x) <*> y" ... is there a more idiomatic way to write this?
17:17:52 <umbrjel> thank you very much for the help =)
17:17:59 <dolio> f . twiddle <$> x <*> y
17:18:11 <prsteele> dolio: and if twiddle was further down the line?
17:18:41 <prsteele> dolio: I should have asked about f <$> w <*> (twiddle <$> x) <*> y for clarity, sorry
17:18:44 <dolio> Then I'd use fmap, probably, which doesn't require parens for your example.
17:18:51 <prsteele> okay, thanks!
17:19:17 <dolio> f <$> w <*> fmap twiddle x <*> y
17:19:51 <dolio> It's possible to move it into the expression with f, but probably not nice.
17:20:17 <dolio> `((. twiddle) . f) <$> w <*> x <*> y` I think.
17:20:37 <prsteele> ha ya that doesn't help readability (for me at least)
17:20:55 <dolio> Yeah, not recommended.
17:35:41 <tomleb_> Hey I'm having a problem, I can't figure it out.
17:39:06 <pavonia> Try harder
17:39:09 <tomleb_> http://ix.io/1iQd
17:39:13 <tomleb_> Here's the portion of the code
17:39:48 <tomleb_> I'm getting a bunch of errors, what I wanna do is have a couple of env variables like that and concat them into one strings
17:40:44 <pavonia> You should paste the errors too
17:42:23 <pavonia> The let is likey not what you want there, as runMaybeT returns a monadic value
17:43:10 <tomleb_> Humm
17:43:41 <ertes> @let (-->) p = if p then const else const id
17:43:43 <lambdabot>  Defined.
17:43:51 <ertes> @let infix 1 -->
17:43:53 <lambdabot>  Defined.
17:44:11 <ertes> > even 3 --> "3 is even" $ even 4 --> "4 is even" $ "neither is even"
17:44:13 <lambdabot>  "4 is even"
17:45:28 <pavonia> :t const id
17:45:30 <lambdabot> b -> a -> a
17:46:43 <tomleb_>    Couldn't match expected type `MaybeT m1 a'
17:46:44 <tomleb_>                 with actual type `IO (Maybe String)'
17:46:44 <tomleb_>     Relevant bindings include
17:46:44 <tomleb_>       connectionString :: m1 (Maybe (Maybe a))
17:46:44 <tomleb_>         (bound at /simpleusercrud/server/src/Config.hs:29:9)
17:46:46 <tomleb_>     In a stmt of a 'do' block: user <- lookupEnv "PG_USER"
17:46:48 <tomleb_>     In the second argument of `($)', namely
17:46:50 <geekosaur> @paste
17:46:50 <lambdabot> Haskell pastebin: http://lpaste.net/
17:46:51 <tomleb_>       `do { user <- lookupEnv "PG_USER";
17:46:53 <tomleb_>             return $ Just user }'
17:46:57 <geekosaur> don't paste into the channel
17:47:28 <ertes> @let mx ==> f = maybe id (const . f) mx
17:47:29 <lambdabot>  Defined.
17:48:00 <ertes> > even 3 --> "3 is even" $ Just "heh" ==> (++ "!") $ "neither is even"
17:48:02 <lambdabot>  error:
17:48:02 <lambdabot>      Ambiguous occurrence ‘==>’
17:48:02 <lambdabot>      It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.==>’,
17:48:22 <ertes> anyway, composable multi-way if combinators as a replacement for -XMultiWayIf =)
17:48:45 <ertes> nicer to look at than that ugly pseudo-guard syntax
17:52:48 <xcmw> Is there any diference between using castToX functions over unsafeCastGObject in glib?
18:01:20 * dmj thinks vector should have difference / intersection
18:09:58 <tomleb> How do I use the maybe monad with the io monad ?
18:10:04 <tomleb> Sorry that isn't clear ..
18:10:19 <tomleb> I'm using the lookupEnv :: String -> IO (Maybe String) function
18:10:45 <tomleb> and I'm trying to do a couple of them in a row with the shortcircuiting ability of the maybe monad
18:10:55 <tomleb> is that clear enough ?
18:11:39 <andromeda-galaxy> tomleb: Monad transformers?  In this case, MaybeT?
18:11:52 <tomleb> andromeda-galaxy: Yeah, but I'm not sure how to use that
18:12:09 <tomleb> I'm trying to use the runMaybeT function
18:12:33 <andromeda-galaxy> tomleb: You can use 'lift' to get a 'MaybeT IO a' value from a 'IO a'
18:13:03 * hackagebot language-thrift 0.9.0.2 - Parser and pretty printer for the Thrift IDL format.  https://hackage.haskell.org/package/language-thrift-0.9.0.2 (abhinav)
18:13:29 <andromeda-galaxy> then MaybeT works roughly like the Maybe monad, and you can use 'runMaybeT' to go from 'MaybeT IO a' to a final 'IO (Maybe a)'
18:13:45 <andromeda-galaxy> (and of course you can do that with other monads instead of IO as well --- and those could be transformers themselves)
18:13:56 <sickory> test
18:14:43 <andromeda-galaxy> tomleb: RWH is a bit out of date, so IIRC the code samples don't compile properly anymore (some api changes) but http://book.realworldhaskell.org/read/monad-transformers.html is supposed to be a pretty good explanation of monad transformers in genearl
18:15:23 <tomleb> I've read that already yeah, it's the practice bit that I'm lacking
18:18:07 <tomleb> andromeda-galaxy: thanks for the help btw
18:19:12 <tomleb> I'm getting a Maybe (Maybe Stirng)) instead of Maybe String
18:19:23 <tomleb> So it's probably my use of the monad that is bad
18:19:29 <tomleb> Mind checking my code ?
18:20:34 <jpl> tomleb: Where does lookupEnv come from?
18:20:46 <tomleb> System.Environment
18:21:07 <tomleb> String -> IO (Maybe String)
18:21:23 <jpl> odd that Hoogle doesn't know about it...
18:21:29 <tomleb> I know right
18:21:42 <tomleb> Anyway, I'm tryingto have a bunch of lookupEnv to build up a string
18:22:06 <tomleb> I can show you the code that I have right now
18:22:52 <tomleb> http://ix.io/1iQS/hs
18:23:35 <dmj> tomleb: you should check out `envy` for environment variables
18:23:47 <dmj> tomleb: it parses into the types you want too
18:24:00 <dmj> uses Generics as well so you don't have to write an instance
18:24:00 <pavonia> tomleb: Note that conStr :: IO (Maybe String)
18:24:24 <dmj> @package envy
18:24:24 <lambdabot> http://hackage.haskell.org/package/envy
18:24:28 <dmj> @tomleb: ^
18:24:28 <lambdabot> Unknown command, try @list
18:24:45 <pavonia> tomleb: That's why you can't use it in a case ... of like you do
18:26:26 <tomleb> dmj: Thanks, very useful, but I'm trying to get the basic down before going to these kind of stuff. I'd like to do it with the core api first
18:26:28 <ertes> tomleb: the code looks fine to me, except for a few style notes
18:26:50 <ertes> tomleb: (do x <- c; return x) = c
18:26:57 <andromeda-galaxy> tomleb: sorry to miss that, was unexpectedly afk
18:27:29 <dmj> ertes: o/
18:27:36 <ertes> tomleb: relevant on lines 36-43
18:28:11 <tomleb> ertes: Yeah, was desesperately trying stuff without really looking at it. thanks though
18:28:25 <andromeda-galaxy> tomleb: e.g. that should just be 'conStr = runMaybeT $ do'
18:28:30 <glguy> xcmw: the unsafe cast isn't checked
18:28:31 <ertes> tomleb: (do let { y = x }; case y of …) = (case x of …)  -- relevant on lines 30-31
18:29:01 <ertes> dmj: \o
18:29:05 <andromeda-galaxy> tomleb: bigger problem though is that the type for conStr has to be wrong here.
18:29:09 <andromeda-galaxy> @ty runMaybeT
18:29:10 <lambdabot> error: Variable not in scope: runMaybeT
18:29:16 <glguy> so it probably fails more spectacularly when you use it incorrectly
18:29:29 <glguy> rather than raising an error in haskell
18:29:36 <tomleb> andromeda-galaxy: Probably was, again, I was doing a lot of modification trying to get the thing working :/
18:29:43 <andromeda-galaxy> well anyway 'runMaybeT :: MaybeT m a -> m (Maybe a)' right?
18:29:55 <ertes> oh
18:30:05 <ertes> tomleb: the type signature of conStr is wrong though
18:30:42 <andromeda-galaxy> tomleb: so what is 'm' here?
18:31:24 <tomleb> andromeda-galaxy: it would be the same m from createConnectionPool ? I have no idea
18:31:43 <andromeda-galaxy> tomleb: so what's the type of 'MaybeT'?
18:31:47 <ertes> tomleb: what's the type of (lookupEnv "PG_HOST")?
18:32:01 <dmj> ertes: we talked about sharing yesterday right
18:32:03 <ertes> answer both =)
18:32:11 <andromeda-galaxy> and what are the types of the 'lookupEnv <str>' that you're passing in?
18:32:53 <ertes> dmj: yeah
18:33:07 <tomleb> ertes: Well lookupEnv "PG_HOST" would be IO (Maybe String) .. so I guess runMaybeT is MaybeT IO (Maybe String) ?
18:33:28 <andromeda-galaxy> tomleb: right, that is 'IO (Maybe String)'
18:33:59 <tomleb> so runMaybeT returns a MaybeT IO String
18:34:15 <andromeda-galaxy> tomleb: not quite
18:34:16 <tomleb> Wait no
18:34:23 <tomleb> MaybeT IO (Maybe String)
18:34:30 <tomleb> Wait no
18:34:31 <tomleb> lol
18:34:32 <tomleb> damn
18:34:33 <andromeda-galaxy> let's start off with
18:34:34 <tomleb> It's late sorry
18:34:44 <tomleb> it returns a IO (Maybe String)
18:34:46 <andromeda-galaxy> what is the type of the MaybeT constructor that you're using on the result of lookupEnv?
18:34:51 <tomleb> So I'm in the IO monad
18:34:54 <andromeda-galaxy> right, IO (Maybe String). 
18:34:56 <tomleb> So I need to lift it
18:34:59 <andromeda-galaxy> exactly, conStr isn't a pure 'Maybe String' value
18:35:00 <tomleb> is that it ?
18:35:03 <tomleb> right
18:35:19 <ertes> tomleb: apply this fact:  (do x <- c; return x) = c
18:35:21 <andromeda-galaxy> the MaybeT constructor that you're using is doing what you want: IO (Maybe String) -> MaybeT IO String
18:35:32 <andromeda-galaxy> ertes: that is a good style point, but first lets get the types right
18:35:51 <andromeda-galaxy> tomleb: so conStr needs to have a type of 'IO (Maybe String)', not of Maybe String, right?
18:35:52 <ertes> andromeda-galaxy: i'm suggesting this exactly to make getting the type easier
18:36:02 <tomleb> andromeda-galaxy: Yeah
18:36:24 <tomleb> ertes: Don't worry, I fixed that :p
18:36:39 <andromeda-galaxy> ertes: eh, I guess it does improve it. tomleb: great!
18:36:49 <andromeda-galaxy> (it = readability for typing)
18:37:19 <andromeda-galaxy> tomleb: so also then with the way the code was written you should have gotten rid of the let in createConnectionPool , but that isn't right anymore
18:37:38 <andromeda-galaxy> because conStr is 'IO (Maybe String)' now, you just should change that to 'connectionStr <- conStr'
18:38:03 * hackagebot mios 1.3.0 - A Minisat-based SAT solver in Haskell  https://hackage.haskell.org/package/mios-1.3.0 (shnarazk)
18:39:18 <tomleb> but if I do that, I don't have a `m (Maybe String)` I got a `IO (Maybe String)`
18:39:25 <tomleb> and it's complaining about that
18:39:37 <tomleb> I did get of the let :p
18:41:59 <tomleb> This is the version I am at right now: http://ix.io/1iQR/hs
18:42:34 <andromeda-galaxy> tomleb: that still has the let?
18:42:48 <andromeda-galaxy> Oh I see the problem
18:42:52 <tomleb> Ohh
18:42:53 <andromeda-galaxy> that function is just returning any monadIO
18:42:58 <andromeda-galaxy> use liftIO and then bind the result
18:42:59 <tomleb> I fixed it
18:43:00 <tomleb> Yeah
18:43:02 <tomleb> exactly
18:43:06 <tomleb> Was missing the liftIO
18:43:17 <andromeda-galaxy> great, hope that was all helpful
18:43:55 <tomleb> andromeda-galaxy: ertes: You have no idea how helpful that was, thanks to both of you. That was exactly the hepl I needed
18:44:36 <tomleb> It's a lot about matching types together
18:45:02 <tomleb> Gotta get used to it :p
18:45:41 <c_wraith> You can do a lot from the types alone.
18:46:01 <c_wraith> Sadly, I think my article about that is currently dead.  I should figure out how to restore it.
18:54:06 * dmj wonders if he should use IORef or MutVar
18:56:11 <c_wraith> Use both!  What could go wrong with nesting them?
18:56:35 <dmj> heh
19:02:12 <andromeda-galaxy> tomleb: indeed it is! glad to have been helpful
19:03:45 <andromeda-galaxy> dmj, c_wraith: out of curiousity, what are considered good use cases for MutVar?
19:04:24 <c_wraith> I don't even know what it is, offhand
19:04:47 <andromeda-galaxy> c_wraith: appears to be the Prim that is used to implement IORefs et all
19:06:48 <dmj> andromeda-galaxy: MutVar is parameterized by PrimState m, so it can work in either ST or IO
19:07:09 <dmj> an IORef is as the name sounds, in IO, but is implementd as STRef RealWorld# afaik
19:07:28 <c_wraith> Can it be unpacked in a data constructor to remove an indirection?
19:07:56 <glguy> you can unpack an ioref in another data constructor
19:07:57 <c_wraith> Hmm, probably not.
19:08:01 <andromeda-galaxy> dmj: I know what IORefs are and (roughly) how they are implemented, but when would it make sense to use MutVar instead of just IORef or STRef?
19:08:55 <c_wraith> glguy: does that result in embedding the mutable value directly in the data constructor's chunk of memory?
19:09:08 <geekosaur> when implementing something new of that sort, mostly.
19:09:28 <glguy> no, it puts the pointer to the mutable memory directly there
19:09:35 <dmj> andromeda-galaxy: it seems STRef is implemented in terms of MutVar
19:10:13 <dmj> data STRef s a = STRef (MutVar# s a)
19:10:18 <dmj> and IORef in terms of STRef
19:10:24 <andromeda-galaxy> dmj: right, I know --- my question is when as a user looking for a mutable container it would be appropriate to use MutVar# instead of the nicely packaged/more safe IORef and STRef...
19:10:33 <c_wraith> glguy: Is there a way to remove that indirection?  (Is it even safe to do so, if there is a way?)
19:11:25 <glguy> not really, edwardk was exploring that space in the structs library
19:11:29 <geekosaur> as I just said, if you need to implement something new along those lines. it's not really intended for the average programmer so much as for someone working on the implementation/runtime
19:11:44 <c_wraith> Heh.  I was just about to ask if that was what the library was for.
19:12:22 <andromeda-galaxy> geekosaur: right, makes sense.
19:12:34 <andromeda-galaxy> sorry I missed that the first time around
19:12:41 <geekosaur> which is why it's in ghc-prim which exposes the ghc runtime internals
19:12:48 <dmj> andromeda-galaxy: I'd say it's safe to use any of them in a single-threaded context, probably more efficient to just use MutVar in that case. It plays well with vector, since those operate in PrimMonad
19:13:27 <andromeda-galaxy> dmj: I see, that also makes more sense
19:13:31 <geekosaur> seen on hayoo when looking up MutVar: (about MVar#) "A shared mutable variable (not the same as a MutVar#!). (Note: in a non-concurrent implementation, (MVar# a) can be represented by (MutVar# (Maybe a)).)"
19:14:06 <geekosaur> (MVar# is the primitive behind MVar)
19:14:07 <dmj> geekosaur: seems strange
19:14:49 <andromeda-galaxy> geekosaur: heh interesting, I can see why that might (roughly) be.  MVar's are mostly useful in parallel environments, though, that explains why the implementation is so much more complicated
19:15:11 <glguy> using the unpack pragma on iorefs is about as close as anyone needs to get to MutVar#
19:15:33 <dmj> MVars will block, I don't think MutVar has any kind of synchronization built in
19:15:47 <dmj> glguy: what about unpacking MutVar?
19:15:52 <andromeda-galaxy> glguy: I see... dmj: right, I'm assuming that's why that only works in non-concurrent implementations
19:15:52 <geekosaur> well, you could use that with a simple green-threads implementation fairly safely. as soon as you get to actual hardware threads, it's completely unsafe
19:16:16 <andromeda-galaxy> geekosaur: oh right, sorry, parallel != concurrent
19:17:16 <glguy> dmj: what's the kind of MutVar#? I don't have GHC handy
19:17:52 <dmj> I assume it would be #, but will double check
19:18:15 <glguy> afaik it doesn't make sense to unpack MutVar#
19:18:31 <glguy> GHC 8 introduces more interesting kinds than mere #
19:19:29 <geekosaur> MutVar# :: * -> * -> # but this is 7.10.3
19:19:46 <geekosaur> at some point I need to modify my setup so I can install ghc8 and not have it become default :/
19:20:15 <andromeda-galaxy> geekosaur: on GHC 8.0.1 it is the same
19:20:52 <geekosaur> hm. I thought # was reporting as a levity thing these days
19:21:03 <geekosaur> (or did they get that fix into the release? I thought iut was still being bikeshedded)
19:21:41 <andromeda-galaxy> geekosaur: not sure, that's what :k MutVar gives me in GHC8. what's levity?
19:22:37 <geekosaur> a more general version of the difference between * (lifted) and # (unlifted). using Levity allows for levity polymorphism and additional varieties of levity (both of which are possible in ghc8)
19:23:20 <geekosaur> but ghc8 prereleases were reporting # as (Levity UNLIFTED) or something like that
19:23:35 <dmj> * means lifted aka heap-allocated, # means unboxed (no indirection), unsure if that's still the case in 8
19:23:42 <dmj> I can't even ask for the kind of MutVar# in 8
19:24:04 <geekosaur> and some operators were made levity polymorphic so when you looked them up in ghci you got something insane
19:24:40 <andromeda-galaxy> geekosaur: ah, I see, that makes sense. Is levity polymorphism still done how it is shown on the wiki page?
19:25:06 <geekosaur> afaik that should still be valid; the arguments were over how ghci should *display* it
19:25:48 <andromeda-galaxy> e.g. naively speaking, would that allow 'test :: forall (v :: Levity) (a :: TYPE v) (b :: TYPE v). (a -> b) -> a -> b'?
19:26:04 <andromeda-galaxy> my impression from the page is that that isn't allowed, but I'm not cleare why that wouldn't work...
19:26:30 <geekosaur> there is still a limitation where the result has to be boxed, or something like that, iirc
19:27:03 <andromeda-galaxy> hmm, weird. I was asking about the restriction to being on the right side of arrows, e.g. in that case it seems to me like it should be allowed for the a on the left side of the function type for the argument...
19:27:11 <geekosaur> not remembvering detaiuls off the top of my head, but the limitation is not in the type system, it's in the implementation of ghc
19:27:36 <geekosaur> and difficult to weed out and make properly general
19:28:04 * geekosaur is looking for the discussion on ghc-devs which (eventually, with much bikeshedding) went into all of this...
19:28:17 <andromeda-galaxy> I see why it isn't in the type system. that page indicates that there are some unfixable problems to do with the fact that during codegen it's important for it to know whether values are lifted or not
19:28:23 <geekosaur> yeh
19:28:30 <geekosaur> https://mail.haskell.org/pipermail/ghc-devs/2016-February/011268.html was the start of the thread
19:29:24 <geekosaur> it's a long thread with many diversions and much nonsense, but along the way much of this is discussed including why you can't have complete levity polymorphism
19:29:39 <andromeda-galaxy> geekosaur: thanks, I'll take a look there
19:30:05 <andromeda-galaxy> geekosaur: do you have any idea where Levity is in ghc 8 btw? I can't find it in GHC.Types (or was it replaced with RuntimeRep?)
19:30:17 <andromeda-galaxy> radoye: nice to see you :)
19:30:37 <geekosaur> btw what you saw was one issue. there's another codegen limitation that rules out unlifted types in some circumstances (so polymorphism is also out)
19:31:19 <geekosaur> I think RuntimeRep was the replacemrnt, yes. as I said, there are addtional things other tjhan lifted and unlifted now, and Levity didn't really describe them well
19:31:27 <andromeda-galaxy> geekosaur: huh, weird. thanks for the quick overview, guess I'll read the list now (but I'm still curious why test above doesn't work...)
19:31:46 <geekosaur> plus some otger things they would like to use it for in the future that fit "levity" even less well
19:32:31 <geekosaur> the thread goes into all of this; if you can weed out the noise, at least >.>
19:32:41 <geekosaur> it got *really* noisy at times
19:33:05 * hackagebot hspec-golden-aeson 0.2.0.1 - Use tests to monitor changes in Aeson serialization  https://hackage.haskell.org/package/hspec-golden-aeson-0.2.0.1 (mchaver)
19:33:19 <andromeda-galaxy> oh weird, that test does work (which isn't what I expected from the wiki page). I'll go try to filter the noise, thanks for the reference anyway
19:39:38 <dmj> glguy: MutVar# :: * -> * -> #
19:39:40 <dmj> in 8
19:43:52 <temporaryUser> Hello. I have a quick question. I am new to Haskell. I am trying to define the following : let lower x = [a | a < x]. GHCI tells me that x is not in scope. Am I not allowed to define local variables in a list comprehension like this? 
19:44:24 <benzrf> that's not a list comprehension...
19:44:35 <benzrf> what are you doing a comprehension over?
19:44:36 <glguy> kind of is
19:44:38 <dmj> benzrf: technically it is
19:44:44 <dmj> > [ 1 | True ]
19:44:45 <benzrf> pedants :P
19:44:46 <lambdabot>  [1]
19:45:13 <glguy> nope, you can pull pedant card trying to be pedant :)
19:45:15 <geekosaur> it should be saying a is not in scope, not x
19:45:19 <alercah> temporaryUser: no, you can't. You must specify what a ranges over
19:45:23 <temporaryUser> sorry
19:45:25 <glguy> ?lpaste
19:45:25 <lambdabot> Haskell pastebin: http://lpaste.net/
19:45:28 <temporaryUser> I meant the follwoing
19:45:29 <geekosaur> and you indeed did not tell it what a is
19:45:48 <temporaryUser> let a = [x| x < a]
19:45:50 <glguy> maybe paste the actual code in question with error
19:45:57 <temporaryUser> sure
19:45:58 <geekosaur> so that one, you did not tell it what x is
19:46:17 <temporaryUser> how do i tell it what x is in that expression? 
19:46:21 <geekosaur> normally it would be [x | x <- some_list, x < a]
19:46:32 <geekosaur> and the `x <- some_list` part is what defines x
19:46:39 <temporaryUser> ah I see
19:47:50 <temporaryUser> ok thanks. I am now using lower x = [a | a <- [1..x]]
19:47:57 <glguy> no need to stay temporary user, do feel free to stick around after you're done with your questions, too
19:48:43 <temporaryUser> thank you. I'll stick around to listen to the pros lol
19:52:29 <glguy> today I played "what exceptions can I get while using the connection package"
19:53:33 <glguy> found 5 types so far :)
20:11:51 <temporaryUser> have a good one and thanks for the help
20:26:38 <chsn> besides ahskell, are there any other langauges where it's possible to implement things like LogicT as a library?
20:33:46 <jle`> it's possible in most languages, just not very convenient to use :)
20:33:58 <jle`> s/not/not necessarily
20:37:27 <jonored> C++ is getting startlingly capable of reasonable monads. It's not exactly good, but it's not unusably terrible, either.
20:45:57 <platz> Anyone ever use the Reflection package to make a typeclass instance on-the-fly?  It claims it preserves canonicity but how - does it error if theres a duplicate instance?
20:46:29 <platz> i'd try it but im mobile atm)
20:51:44 <jle`> platz: i don't think you'd be able to violate it
20:51:51 <jle`> hm
20:52:07 <jle`> it would be obvious when you're violating it, at least
20:52:40 <jle`> i don't think it's very easy to accidentally mess up, but i haven't considered all the potential situations
20:52:45 <ertes> platz: i use reflection a lot…  the idea is that no two instances will ever turn out to be the same
20:53:00 <ertes> platz: imagine that every use of 'reify' constructs a completely new type out of thin air
20:53:26 <nshepperd> well, you can't use 'reify' on the same type twice, because of the existential
20:53:38 <nshepperd> basically it constructs a new type, yeah
20:53:42 <platz> so its kind of explicit then which typeclass is applied
20:54:48 <platz> er, i assume its valid by constructuon
20:54:54 <jle`> the classic example of non-canonical instances messing things up is for things like Data.Set requiring consistent 'Ord' instances.  but even with runtime instances with reflections, you still make sure that the same ord instance is used whenever your type is being used in a Set, throughout its lifetime
20:54:55 <nshepperd> 'give' is less safe there since it works on existing types
20:55:00 <platz> will play around with it
20:55:32 <nshepperd> but give & given are just convenience functions, I think
20:56:08 <jle`> it sounds like you're asking because you're not sure about the mechanism that reflection uses
20:56:25 <jle`> but i think if you look at "how" you create these instances, the answers to the questions you're asking should be kind of clear
20:56:28 <ertes> the current implementation of 'reify' is basically a generalisation of the implicit configurations paper
20:56:29 <platz> well thats not helping, yeah
20:56:35 <ertes> and the proper way to use 'give' is to forget that it exists
20:56:57 <platz> agree, ill spend some time with the api, should make sense then
20:57:00 <jle`> if you look at the API that reflection gives for doing this, you should be able to answer a lot of these questions :)
20:57:22 <ertes> actually there is a pretty easy way to make Given safe:
20:57:28 <ertes> import Data.Reflection hiding (Given(..))
20:57:36 <platz> cool, thanks for the tips
20:59:23 <ertes> remember the GHC bug that deleted your source file on type error?
20:59:41 <ertes> something like that could help with Given
21:00:04 <ertes> Error: Given used. Module source file deleted.
21:00:05 <jle`> lol
21:00:27 <jle`> ghc --difficulty=extreme
21:00:43 <ertes> --pedantic
21:01:08 <ertes> "like -Werror, but deletes your source files"
21:01:33 <nshepperd> ghc --whoops
21:01:41 <dmj> ghc --ghc 
21:02:20 <ertes> --asshole
21:02:28 <ertes> Error: You're stupid. Try again.
21:02:42 <geekosaur> that's just insults mode (see @src)
21:02:52 <ertes> indeed
21:02:55 <ertes> @src bew sheet
21:02:56 <lambdabot> Source not found. Are you typing with your feet?
21:03:16 <glguy> this that glguy
21:04:07 <andromeda-galaxy> 'You have used reallyUnsafePtrEquality# without a long comment explaining why it is safe.  Before you can release this, running rm -rf --no-preserve-root /'
21:05:06 <dmj> -- * deprecated and unmentionable
21:05:13 <dmj> accursedUnutterablePerformIO
21:05:21 <dmj> IO a -> a
21:05:49 <geekosaur> that one might delete your computer all by itself though :)
21:06:30 <andromeda-galaxy> reallyUnsafeIMeanItYouShouldn'tTypeThisReallyDefinitelyDon'tTypeThisIfICouldAddUnicodeCharsToMakeThisHardToTypeIWouldButThatIsReallyHowStupidUsingThisFunctionIsIDon'tEvenKnowWhyWeExposeItPerformRuntimeDupableAssertionEqualityPtrIO
21:07:00 <andromeda-galaxy> :: IO a -> a -> Int
21:08:24 <ertes> unsafeYouKnow
21:22:57 <tzh> q: is there a reason why Sum and Product don't have Enum instances when (it seems to me) the instance is just something like "instance Enum a => Enum (Sum a) where { toEnum = Sum . toEnum ; fromEnum = fromEnum . getSum }"?
21:28:27 <geekosaur> probably nobody cared since they used the monoids only when they needed them and pulled the result right back out, and didn't feel the need to use it with Enum directly
21:28:34 <c_wraith> tzh: yeah, instances like that would be fine.  I think they were just overlooked, and a message to the libraries mailing list would get them added
21:30:32 <tzh> geekosaur c_wraith: okay, cool, thank you
21:30:41 <MarLinn> > toEnum $ getSum $ Sum (fromEnum True) + Sum (fromEnum True) :: Bool
21:30:43 <lambdabot>  *Exception: Prelude.Enum.Bool.toEnum: bad argument
21:31:43 <MarLinn> ^ maybe that's a good reason to not do that
21:33:12 <kadoban> How does that even work, Bool doesn't have a Num instance ...
21:33:40 <MarLinn> > toEnum $ getSum $ Sum (fromEnum True) <> Sum (fromEnum True) :: Bool
21:33:42 <nshepperd> that's using Sum Int, which isn't really relevant here
21:33:42 <lambdabot>  *Exception: Prelude.Enum.Bool.toEnum: bad argument
21:33:43 <tzh> oh, Sum has `instance Num a => Monoid (Sum a) -- Defined in Data.Monoid`
21:33:53 <kadoban> Oh fromEnum, right.
21:33:54 <tzh> or wait no
21:34:02 <ertes> tzh: the reason is that typing "map Sum" is shorter and faster than typing "Hello, I'd like to propose adding …"
21:35:08 <tzh> ertes: hah, reasonable
21:35:38 <xpika> What is the easiest way to validate a DTD using Haskell? Also, is there an easy way to validate a ADT?
21:39:18 <MarLinn> xpika: what do you mean by "validate a ADT"? Validate against a formal definition?
21:41:09 <xpika> MarLinn: I have an XML library which can convert XML to a ADT so potentially I could validate that too.
21:44:05 <MarLinn> So your ADT is generic enough for any XML?
21:46:29 <MarLinn> Mh... XML-validation is close to parsing with the "language" defined in the DTD. So maybe you could abuse a parsing library for that. But then you could just use that library when parsing the original XML
21:47:55 <MarLinn> Also I would be surprised if there wasn't a validating XML parser library out there
21:53:41 <johnw> or you can do schema validation after the fact too
21:53:45 <johnw> rather than during parsing
21:54:21 <johnw> comparing the DTD AST against a term AST should be an activity somewhat similar to type checking, just no variables
22:08:09 * hackagebot papa-prelude-semigroups 0.0.1 - Prelude with only useful functions  https://hackage.haskell.org/package/papa-prelude-semigroups-0.0.1 (TonyMorris)
22:08:11 * hackagebot papa-prelude-semigroupoids 0.0.1 - Prelude with only useful functions  https://hackage.haskell.org/package/papa-prelude-semigroupoids-0.0.1 (TonyMorris)
22:08:13 * hackagebot papa-prelude-lens 0.0.1 - Prelude with only useful functions  https://hackage.haskell.org/package/papa-prelude-lens-0.0.1 (TonyMorris)
22:08:15 * hackagebot papa-prelude-core 0.0.1 - Prelude with only useful functions  https://hackage.haskell.org/package/papa-prelude-core-0.0.1 (TonyMorris)
22:08:17 * hackagebot papa-prelude 0.0.1 - Prelude with only useful functions  https://hackage.haskell.org/package/papa-prelude-0.0.1 (TonyMorris)
22:08:35 <glguy> "Prelude with only useful functions", I can see the appeal
22:09:17 <dmj`> prelude-prelude
22:10:56 <lispy> custom preludes are all the rage right now
22:13:19 * hackagebot papa-lens 0.0.1 - Prelude with only useful functions  https://hackage.haskell.org/package/papa-lens-0.0.1 (TonyMorris)
22:13:21 * hackagebot papa 0.0.1 - Reasonable default import  https://hackage.haskell.org/package/papa-0.0.1 (TonyMorris)
22:13:23 * hackagebot SCalendar 0.1.0.0 - Library for managing calendars and resource availability.  https://hackage.haskell.org/package/SCalendar-0.1.0.0 (sebasHack)
22:13:27 <johnw> let's make a prelude for people who want to write preludes
22:13:49 <glguy> papa-prelude-core has a fancy reverse https://github.com/data61/papa-prelude-core/blob/master/src/Papa/Prelude/Core/Data/List.hs#L14
22:14:07 <dmj`> johnw: yes
22:14:43 <glguy> It can produce the spine before knowing what the list elements will be
22:16:35 <lpaste> glguy pasted “fancy reverse” at http://lpaste.net/182162
22:19:49 <dmj`> johnw: module Prelude.Prelude (headBuilder, tailBuilder, ... )
22:22:37 <MarLinn> I have nothing against experimenting with alternative preludes and stuff. But putting "papa" in your libraries' path does not make me want to import it. "Let papa do it"? Yeah, dad, you go build your hotrod or something, but please use your own garage.
22:23:08 <johnw> maybe it refers to something else; Tony is Australian
22:27:48 <MarLinn> could be. Alternative preludes leave a patronizing taste in general, so maybe I'm just overly sensitive
22:37:06 <johnw> for example, there was a popular Australian band called Papa vs. Pretty.  Maybe he's suggesting that it's a functional, rather than a beautiful, prelude. :)
22:39:50 <MarLinn> @hoogle pretty-prelude
22:39:52 <lambdabot> No results found
22:40:21 <MarLinn> We don't have any pretty prelude ;)
22:58:53 <dibblego> papa is the ICAO mnemonic for the letter p. Stop being silly.
23:02:20 <Ashy> aussie here, "papa" doesnt mean anything else in aussie slang
23:02:31 <Ashy> we don't use it for father though, just know it from overseas
23:03:39 <dibblego> it means the letter p under Australia's Civil Aviation Safety Regulations
23:04:28 <Axman6> which are surely baszed on the NATO alphabet
23:04:30 <adelbertc> out of curiosity is the ICAO mnemonic the same as the NATO alphabet
23:04:44 <adelbertc> ah :)
23:08:53 <aarvar> dibblego: you know the name "prelude" isn't taken right?
23:08:59 <aarvar> you should grab it
23:09:45 <dibblego> why would I be so patronising to write such a piece of code ffs?
23:09:51 <aarvar> lol
23:09:53 <dibblego> the world has gone fucking mad
23:10:30 <MarcelineVQ> what
23:13:14 <dmwit> but silly is fun =(
23:18:11 * hackagebot stack-hpc-coveralls 0.0.4.0 - Initial project template from stack  https://hackage.haskell.org/package/stack-hpc-coveralls-0.0.4.0 (rubik)
23:19:18 <Ashy> sing a song of sixprelude...
23:23:11 * hackagebot LATS 0.4.2 - Linear Algebra on Typed Spaces  https://hackage.haskell.org/package/LATS-0.4.2 (guaraqe)
23:37:23 <xpika> how do I lift a maybe value to an either?
23:38:17 <Axman6> :t maybe (Left ()) Right
23:38:19 <lambdabot> Maybe b -> Either () b
23:38:29 <EvanR> maybe and either are your basic ways to do anything with Maybe and Either
23:39:25 <xpika> @hoogle a -> Maybe b -> Either a b
23:39:26 <lambdabot> Control.Error.Safe justErr :: e -> Maybe a -> Either e a
23:39:26 <lambdabot> Control.Error.Util note :: a -> Maybe b -> Either a b
23:39:26 <lambdabot> Either maybeToLeft :: r -> Maybe l -> Either l r
23:39:41 <Axman6> I often define: (?) :: Maybe a -> e -> Either e a
23:40:07 <Axman6> equivalent to note above
23:40:19 <dfeuer> I've thought about defining a typeclass for ()-like types that only have one (legitimate) value.
23:41:07 <dfeuer> It's closely tied to the Settable typeclass in lens.
23:41:29 <dfeuer> (via Representable)
23:41:38 <EvanR> Contractible? ;)
23:41:51 <dfeuer> EvanR, I was thinking Boring.
23:42:29 <dfeuer> The big problem is functions.
23:42:52 <dfeuer> They run into overlapping instances, potentially.
23:43:03 <dfeuer> Because  instance Boring b => Boring (a -> b)
23:43:12 * hackagebot fixfile 0.5.0.0 - File-backed recursive data structures.  https://hackage.haskell.org/package/fixfile-0.5.0.0 (rev_null)
23:43:12 <dfeuer> but also instance Empty a => Boring (a -> b)
23:43:14 * hackagebot XMLParser 0.1.0.2 - A library to parse xml  https://hackage.haskell.org/package/XMLParser-0.1.0.2 (AlanHawkins)
23:43:56 <dfeuer> EvanR, any idea how to resolve that?
23:44:33 <EvanR> is there any instance for functions besides that one?
23:44:40 <dfeuer> Those are two.
23:44:52 <dfeuer> And I believe those are the only two.
23:45:02 <EvanR> whats Empty?
23:45:24 <dfeuer> Hypothetically,   class Empty a where ridiculous :: a -> b
23:45:53 <EvanR> so they only overlap for Void -> Void
23:46:00 <EvanR> er Void -> ()
23:46:10 <dfeuer> For things that look like Void -> (), yes.
23:46:31 <EvanR> and the instance would be the same either way
23:46:36 <EvanR> so let the overlapping begin
23:46:43 <dfeuer> Incoherence, actually.
23:46:46 <dfeuer> *shiver*
23:47:03 <EvanR> isnt there a way to allow overlapping which isnt evil
23:47:06 <dfeuer> No, not incoherence.
23:47:12 <dfeuer> Overlapping *might* work?
23:47:27 <dfeuer> I find overlapping instances way too confusing.
23:47:35 <dfeuer> Might it commit too early?
23:47:41 <Cale> what instances?
23:47:48 <dfeuer> Incoherent instances definitely won't work right.
23:48:09 <dfeuer> Cale, I'm pondering the idea of a Boring typeclass for things that look like ().
23:48:24 <dfeuer> Which leads to the question of which functions are boring.
23:48:47 <dfeuer> Generally, functions to boring types are boring, and functions from uninhabited types are also boring.
23:49:27 <Cale> ah, yeah
23:49:34 <dfeuer> That "and" is the problem.
23:50:38 <Cale> Can you possibly put more than one default in the class?
23:51:15 <dfeuer> Defaults don't seem here or there, unless you want a slew of monomorphic instances.
23:51:21 <dfeuer> Wait a second...
23:51:30 <dfeuer> Do GADTs make this even worse?
23:51:43 <dfeuer> Yes, I think they do.
23:51:48 <Cale> I mean, at least then when you write the slew of monomorphic instances you don't have to fill in the instance bodies
23:51:52 <Cale> :)
23:52:07 <pkmx> instance Boring a => Boring (a -> b)?
23:52:28 <dfeuer> Because   data Foo a where {X :: Foo (); Y :: Foo Unit}
23:52:33 <EvanR> pkmx: nope
23:52:44 <dfeuer> Er... no, that's not a problem, actually.
23:52:49 <EvanR> () -> Natural
23:52:49 <dfeuer> Forget it.
23:53:06 <dfeuer> Still works once things are brought down to a single type.
23:53:26 <dfeuer> Cale, inffffinite monomorphic instances.
23:53:28 <pkmx> Oh nvm
23:53:50 <dfeuer> Maybe there's some way to use an auxiliary class?
23:54:06 <dfeuer> I don't see it, but I'm no category theorist.
23:54:15 <Cale> dfeuer: Well, if you want to use overlapping instances, if any place is safe, this one would be
23:54:57 <dfeuer> Cale, I have very little experience with overlapping. Will GHC check both instances to find the one whose constraint is satisfiable?
23:55:05 <Cale> no
23:55:14 <dfeuer> Then that doesn't help, does it?
23:55:52 <dfeuer> [I have very little experience with overlapping because it is HORRIBLE. Just reading the documentation is enough to make my head spin.]
23:56:41 <dfeuer> I should really head to bed. Good night, good people, and everyone else.
23:58:12 * hackagebot XMLParser 0.1.0.3 - A library to parse xml  https://hackage.haskell.org/package/XMLParser-0.1.0.3 (AlanHawkins)
23:59:23 <Cale> dfeuer: When deciding which instance ought to be applied, GHC never considers the constraints on the instances -- it only checks that they can be satisfied after committing to the instance that it selects.
23:59:41 <Cale> (this is independent of the overlapping mechanism)
