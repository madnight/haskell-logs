00:00:49 <MarLinn> But you managed to write down the syntax rules in pretty much the most concise way possible and close to the one you would find in a paper. And then... you "fixed" it into shape. Holy crap.
00:01:58 <dramforever> hence the name
00:02:01 <dramforever> *paste name
00:02:10 <dramforever> ok, *paste title
00:04:12 <MarLinn> I think when the Haskell prime team writes their next report they should use your notation. The first executable language report.
00:07:37 * hackagebot stochastic 0.1.0.0 - Monadic composition of probabilistic functions and sampling.  https://hackage.haskell.org/package/stochastic-0.1.0.0 (chokboy)
00:07:37 * hackagebot tasty-golden 2.3.1.1 - Golden tests support for tasty  https://hackage.haskell.org/package/tasty-golden-2.3.1.1 (RomanCheplyaka)
00:08:44 <nomotif> Dumb question -- what is the current state of the Haskell scientific computing libraries?
00:10:02 <Axman6> not amazing, there's some nice libraries, but nothing as extensive as you'd fine in say Python or R. carter would be able to tell you more, he's been working on some new libraries for a while now, not sure of the progress though
00:11:01 <Axman6> the things to look at are Vector, Repa, HMatrix, Accelerate (for GPU accelerated computation)
00:11:12 <Axman6> there's probably several more depending on what you want to do
00:11:17 <johnw> I guess also we should ask what kind of science nomotif intends to be doing
00:11:54 <johnw> what I hear "scientific computing" I either hear "really fast, tons of data", or "safe management of units"
00:11:55 <srhb> nomotif: In my experience, crunching big numbers is quite comfortable, while explorative data science is quite meh.
00:12:09 <nomotif> johnw: I'm particularly interested in the Data Science front, but last time I checked none of the infrastructure was in place for any of the !FUN! stuff.
00:12:22 <srhb> nomotif: !FUN! :-)
00:12:33 <johnw> there has been some exploration of fun data science with groups and monoids in the last few years
00:12:44 <johnw> there's a few blog articles laying around...
00:13:02 <nomotif> johnw: The stuff I looked at looked like it hadn't hit critical mass yet.
00:13:15 <johnw> that was a physics joke, wasn't it
00:13:31 <nomotif> Thanks Axman6, tahts exactly what I was interested in.
00:14:04 <nomotif> johnw: Sure, I'll pretend I have momentum and see where that gets me.
00:14:39 <Axman6> we just don't have a concerted effort to make good libraries like the python guys do in the scipy work
00:14:52 <nomotif> Axman6:  Yeah.  They're fanatical.
00:15:08 <Axman6> lots of people doing their own thing, but not much group concensus (a pretty familliar story in the Haskell world)
00:16:06 <srhb> There was a loose gathering of peoples at one point trying to do stuff. I wish I could remember who...
00:16:44 <srhb> Also the whole (I don't remember what it's called) previously known as IPython should probably help
00:17:08 <nomotif> Oh, I didn't realize the Jupyter group did scientifc computing stuff
00:17:27 <srhb> A lot of people that I know in hard sciences use it at least. I think that helps in itself.
00:18:29 <Axman6> the IHaskell stuff is really nice, not sure if it's maintained though
00:18:41 <nomotif> srhb: Jupyter/IPython Notebooks definitely help on the reproduceability front.
00:19:10 <srhb> Axman6: There was a summer of haskell project for Jupyter/ghcjs, so that's a bit exciting, if tangential.
00:19:36 <Axman6> hmm, interesting, though not quite as useful as plain ghc I'd guess
00:21:50 <nomotif> I'm kind of surprised the Facebook Haskellers never kicked back any of the good stuff along these lines.
00:22:31 <Axman6> well, Haxl is open source
00:22:44 <nomotif> True.
00:23:07 <Axman6> which afaict is the major thing FB are doing with Haskell (their job ad seems to imply as much)
00:23:43 <nomotif> I'd suspect there is a degree of AI, though apparently it's all human intelligence.
00:23:59 <Axman6> yeah
00:27:17 <Guest72983> Can anybody see what the problem here is? http://lpaste.net/180223
00:27:59 <geekosaur> Guest72983, you are using a do block in a function String -> [String]
00:28:10 <geekosaur> the monad is not IO, it is []
00:28:37 <Guest72983> geekosaur: why isn't that allowed?
00:28:52 <geekosaur> because you can only do IO in IO, not in arbitrary places
00:29:23 <geekosaur> "do" is not "lemme do IO here", it is "let me use a convenient shorthand for monadic binds". you still need to be in IO if you are doing IO things
00:29:35 <Axman6> you probably want String -> IO [String] and to use return imps and return []
00:32:10 <Guest72983> geekosaur: that at least solves that problem. Now I'm having a truckload of other errors... I'll look into it. Thanks so far...
00:32:50 <geekosaur> yes, I'd imagine you need to either plumb IO through to there or refactor so the IO isn't all over everything (the preferred route for most Haskell code)
00:33:53 <Guest72983> geekosaur: that's basically what I'm trying to do. I've been here yesterday already and discussed the implications of having IO at some point and several friendly folks pointed out that I'll have to drag IO through all methods. Which made me pretty unhappy.
00:34:33 <cocreature> Guest72983: that good thing about being annoyed about having to drag IO through all your methods is that you‚Äôll try really hard to isolate it :)
00:36:19 <Guest72983> cocreature: from a conceptual pov that surely is enforcing good coding style. But from a implementation point (having called my functions "methods" was probably a giveaway that I'm more of a procedural programmer...) it is rather frustrating to me.
00:36:43 <merijn> Guest72983: One solution is to move the "openFile" and "hGetContents" out to the top level or main and then have "String -> [String]" simply take the file's contents as input argument
00:37:50 <Guest72983> merijn: sadly, I can't do that. The whole idea is "parse file x. Should you encounter an 'import'-statement, open that file as well and parse it". So the IO is nested pretty deep inside the logic.
00:39:02 <cocreature> Guest72983: I can definitely emphasize with being frustrated when starting with haskell. but I‚Äôm also really happy I stayed with it until the initial frustration passed
00:39:03 <Guest72983> merijn: well, I'm kind of doing what you suggest already. I'm preprocessing the whole file, extracting all the imports, parsing each file separately and then combining their contents. But there I have IO again. Bleh.
00:39:17 <Axman6> depending on the parser library, you may actually be able to perform IO inside its parser monad transformer... but this is possibly an advanced topic depending on where you're up to in your haskell learning
00:39:48 <cocreature> Guest72983: what you might be able to do is rather than reading the file when you encounter an import, you could return a value indicating that you encountered that import and then the function calling the parser takes care of reading that file
00:40:24 <Guest72983> cocreature: seeing how happy everyone at my workplace is with haskell I definitely think that it's a good thing. Plus the community has been very helpful and encouraging so far. But spending two days on a thing I'd do in 5 mins in python makes me want to break things from time to time. :)
00:40:38 <glguy> or the parse logic can return a suspended parse with request to load a file and the io can stay on the outside where those things are interpreted
00:40:48 <peteretep> >=> is missing from the pronunciation guide. Does it have a name?
00:43:13 <Axman6> "fish"
00:43:19 <Axman6> there's probably other names
00:43:29 <MasseR> Isn't that kleisli arrow? Or was it <=<
00:44:15 <peteretep> I'm going to go with `kcompose` I think
00:44:26 <dramforever> :t ((<=<), (>=>))
00:44:27 <lambdabot> (Monad m1, Monad m) => ((b -> m c) -> (a -> m b) -> a -> m c, (a1 -> m1 b1) -> (b1 -> m1 c1) -> a1 -> m1 c1)
00:44:43 <peteretep> :r:r
00:44:45 <peteretep> ooops, sorry
00:44:47 <demize> MasseR: >=> is left-to-right and <=< is right-to-left kleisli composition
00:44:55 <MasseR> right
00:45:00 <dramforever> kcompose and kpipe?
00:46:44 <merijn> peteretep: The formal name would be Kleisli composition. The usual haskell name is "fish operator", since it looks like a fish :p
00:53:08 <lpaste> dramforever annotated ‚Äú'My best idea ever'‚Äù with ‚Äúcata basically works, haven't tested polymorphic ones yet‚Äù at http://lpaste.net/180217#a180229
01:03:57 <ongy> can I tell haddock to not warn me about undocumented types/functions from a single file? The values are (mostly) reexported by other modules, where haddock complains again, can I document them in those modules?
01:07:18 <lyxia> yes you can
01:07:33 * hackagebot cabal2nix 2.0.1 - Convert Cabal files into Nix build instructions.  https://hackage.haskell.org/package/cabal2nix-2.0.1 (PeterSimons)
01:07:38 <ongy> lyxia: thanks
01:10:44 <newcomer25> The whole Law is fulfilled in one statement: ‚ÄòYou‚Äôll love your neighbour as much as yourself‚Äô - Galatians 5:14
01:10:44 <newcomer25> God bless you all and have fun chatting!
01:14:52 <ongy> lyxia: mind telling me how?
01:15:39 <sshine> newcomer25, does this law have a transitive property?
01:16:36 <lyxia> ongy: ah after re-reading your question I realize I misunderstood. You want to document your functions not from the modules where they are defined but from where they are re-exported.
01:17:24 <ongy> I only reexport the data constructors, but I don't think that makes a difference. Yes
01:17:25 <sshine> newcomer25, also, since this law says nothing about how much to love yourself, should I love my neighbours very little if I love myself very little?
01:18:21 <sshine> newcomer25, it seems reasonable that if I should seek to destroy mankind, that I should also seek to destroy myself. this law seems quite mankind-centric, so I'm not sure it extends to cyborgs?
01:18:46 <Squarism> When using "Intero" for emacs when doing C-c C-t (Show type) i get "Cannot open load file:ghc". Anyone got a qualified quess on possible fix?
01:20:47 <lyxia> ongy: sorry I don't know how to do that then.
01:24:40 <Guest72983> Is there a shorthand for "<-"? E.g. instead of doing "y <- x; z ++ y" just "z ++ ?x?"?
01:24:59 <lyxia> x >>= (z ++)
01:25:03 <Guest72983> thanks
01:25:17 <lyxia> <- is in fact syntactic sugar for bind
01:26:08 <Guest72983> How would that look? I can only find bind in the context of sockets.
01:26:51 <lyxia> bind is the English name of >>=
01:27:03 <Guest72983> lyxia: ah, I see! :)
01:27:27 <Guest72983> that's one point that strikes me with haskell. It's sometimes pretty hard to google the operators.
01:28:07 <tdammers> that's why we have hoogle and hayoo
01:28:09 <cocreature> Guest72983: operators that are not syntax (so it won‚Äôt work for <-) can be found pretty easily on hoogle http://hoogle.haskell.org/
01:28:17 <tdammers> @where hoogle
01:28:17 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle ‚Äì See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
01:28:19 <tdammers> @where hayoo
01:28:20 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
01:28:31 <Guest72983> cocreature: ah, good point
01:29:03 <tdammers> fortunately, there is only a handful of operator-like tokens that are syntax sugar rather than actual operators
01:29:11 <cocreature> yep
01:29:53 <tdammers> tuples, do notation, record syntax, pattern matching, guards is all I can think of right now
01:29:58 <tdammers> oh, and TH and QQ
01:30:13 <cocreature> tdammers: arrow notation (i.e., proc)
01:30:19 <tdammers> right
01:30:39 <dramforever> ::
01:30:46 <Xnuk> :::
01:30:47 <Xnuk> ::::
01:31:27 <tdammers> oh crap, also lists, comprehensions, almost everything type-level, lambdas, ...
01:31:43 <cocreature> well lists don‚Äôt look a lot like operators
01:32:03 <tdammers> granted
01:32:16 <cocreature> I think I‚Äôve only really seen people confused by <- because it can most easily been mistaken for a binary operator
01:32:40 <tdammers> hmhm
01:32:46 <tdammers> same goes for = really
01:33:02 <tdammers> probably worse even, because = can appear in top-level bindings
01:33:02 <cocreature> yeah but people are used to = being syntax
01:33:37 <tdammers> people are used to foo = bar being syntax for an assignment statement
01:33:57 <dramforever> But then . $ look like syntax (Let's talk about Haskell2010)
01:34:20 <tdammers> they do
01:34:42 <tdammers> but I think it's less harmful to accidentally consider regular operators syntax than the other way around
01:35:05 <tdammers> being able to pass ($) around as a function is surprising, but it's a good surprise
01:35:15 <tdammers> (e.g. zipWith ($) -- mind blown!)
01:35:36 <tdammers> OTOH, = not being an operator is kind of a disappointment
01:36:01 <tdammers> (e.g. you can't write zipWith (=) to generate a bunch of top-level bindings from a list of pairs)
01:56:24 <ongy> tdammers: zipWith (=) sounds more like a job for TH
02:00:05 <ongy> can I somehow check, sine which GHC version (<*>) is in prelude?
02:01:42 <Guest72983> Still not getting any closer... http://lpaste.net/180236 I already extracted all paths to imported files. So that's a step forward. But now foldr goes all honkeydonk on me. Any suggestions?
02:01:54 <tdammers> ongy: yes, but it doesn't work in TH either
02:05:24 <ongy> Guest72983: since you are folding over IO [Kernel] you want the start value to be (return []). Also I think you have the argument order in the lambda wrong
02:05:41 <ongy> not folding over, but the accumulator is IO [Kerne]
02:06:00 <Guest72983> isn't the first argument the accumulator?
02:06:06 <ongy> :t foldr
02:06:08 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
02:06:30 <ongy> so the first argument is the element from your list, the second the accumulator
02:07:38 <Guest72983> hmm... doesn't foldr switch the arguments around then? Since when calling foldr the second argument was the accumulator and the third one the list?
02:08:27 <Guest72983> well rhetorical question. Guess I'll roll with it.
02:08:36 <Rarrikins> :t foldl
02:08:37 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
02:09:34 <cow_2001> i raise
02:09:42 <cow_2001> > raise
02:09:45 <lambdabot>  error: Variable not in scope: raise
02:10:14 <cow_2001> this isn't the poker channel? what are you folding for, then?
02:16:36 <Guest72983> switched the arguments around. Replaced [] with (return []). Still errors... http://lpaste.net/180239
02:17:12 <lyxia> ins is not a list
02:17:26 <lyxia> but you pass it to ++ which expects a list
02:18:03 <Guest72983> it was a list before and then I had the errors as in http://lpaste.net/180236
02:18:07 <cow_2001> hit and miss, yuval. hit and miss. -.-
02:19:39 <lyxia> Guest72983: do you want to parse the files whose names are in import and concatenate the results?
02:19:51 <Guest72983> alright, maybe I'm just doing the completely wrong thing. I have parseFile :: String -> IO [Kernel] and a list of Strings I want to pass to parseFile consecutively and concat their results.
02:19:57 <Guest72983> lyxia: exactly
02:21:00 <anohigisavay> hi. stupid question: how to do imperative return in IO? nested when and unless drive me crazy
02:21:20 <lyxia> Guest72983: fmap concat . mapM parseFile $ imports
02:22:16 <lyxia> Guest72983: that's more straightforward than foldr IMO.
02:23:46 <Guest72983> lyxia: ah, great! Guess that would have taken me a while to get there. Thanks a bunch!
02:24:24 <ashishne_> anohigisavay: what do you mean by `imperative return` ? do you mean return that line as result of function ?? 
02:24:52 <hexagoxel> anohigisavay: MaybeT/EitherT
02:25:31 <lyxia> Guest72983: foldr (\file parseRest -> parseFile file >>= \kFile -> parseRest >>= \kRest -> return (kFile ++ kRest)) (return []) imports
02:26:09 <lyxia> Guest72983: 2 binds and one return can be refactored: \file parseRest -> liftA2 (++) (parseFile file) parseRest
02:26:13 <anohigisavay> ashishnegi: yes
02:26:25 <Guest72983> lyxia: umm... yes fmap definitely looks more straightforward
02:27:22 <ashishnegi> anohigisavay: so last logical line is the only "imerative return" in haskell.. so you have to make it last logical line.. easiest is `if .. then return 1 else .. more ..`
02:27:32 <lyxia> Guest72983: eta-reduce, \file -> liftA2 (++) (parseFile file), rewrite a bit and eta-reduce once more, liftA2 (++) . parseFile
02:27:49 <ashishnegi> anohigisavay: each branch of `if else` has last logical line
02:28:21 <lyxia> Guest72983: then it looks neat but admittedly the logic is not quite obvious
02:28:58 <Guest72983> lyxia: IO confuses the hell out of me anyway.
02:29:32 <hexagoxel> anohigisavay: in that case: EitherT :)
02:29:49 <anohigisavay> hexagoxel: thanks that did the trick :)
02:30:12 <ashishnegi> anohigisavay: may be you can show some code.. because as hexagoxel said.. if you are using `Maybe` or `Either` then you can remove the repetitive stuff.
02:32:09 <anohigisavay> ashishnegi: http://lpaste.net/180242
02:32:11 <tsahyt> Hello! I've been digging through base a bit and found a MD5 implementation in C. Where is MD5 being used in base and why is it implemented in C rather than Haskell?
02:32:34 <lyxia> Why are there both EitherT and ExceptT?
02:32:44 <anohigisavay> ashishnegi: well this actually works but i want to get rid of perform
02:33:35 <anohigisavay> yea it would be best if not involving Maybe or Either
02:34:37 <cocreature> tsahyt: could you point me to the implementations
02:34:45 <cocreature> s/implementations/implementation?/
02:34:49 <tsahyt> cocreature: https://github.com/ghc/ghc/blob/master/libraries/base/cbits/md5.c
02:35:03 <lyxia> I answered my own question https://github.com/ekmett/either/issues/7
02:35:46 <ashishnegi> anohigisavay: what do you mean by getting rid of perform ? this code looks ok to me.. usually if you had been doing simple `return ()` in `Nothing` then you could have used some abstractions..
02:36:24 <tsahyt> cocreature: I kinda see the use of the other C files in that directory, them being mostly compatibility things for different OSs, but MD5 stands out a bit
02:36:40 <cocreature> tsahyt: it‚Äôs used in GHC.Fingerprint and only there as far as I can see.
02:36:57 <cocreature> as to why it is implemented in C, I can only come up with performance reasons but that seems like a poor excuse
02:37:17 <cocreature> tsahyt: you might want to ask in #ghc
02:37:23 <tsahyt> cocreature: Thanks, I'll do that!
02:37:41 <cocreature> I didn‚Äôt even know GHC.Fingerprint exists until two minutes ago
02:38:49 <cocreature> ah it‚Äôs used in typeable
02:38:49 <tdammers> not reimplementing any wheels might also be a reason
02:39:06 <anohigisavay> ashishnegi: thanks that sounds fair
02:39:13 <tdammers> i.e., maybe someone had a working C implementation already, and writing one in Haskell wasn't a priority
02:39:28 <tdammers> (also the "don't write your own crypto" rule)
02:39:44 <tdammers> (not that md5 is considered valid crypto these days)
02:39:47 <cocreature> yeah if I understand the comments correctly the code is just copied from somewhere else
02:39:50 <tsahyt> tdammers: MD5 hardly counts as crypto :P
02:39:58 <tdammers> tsahyt: I know
02:46:41 <ongy> can https://travis-ci.org/Ongy/pulseaudio/jobs/154995451#L334 be cause by an older hsc2hs version? It works for the 8.0 container (and my dev-machine, which has ghc-8.0)
02:56:50 <k0ral> Hello
02:57:13 <k0ral> is there a way to turn a "Sink i m o" into a "Conduit i m o" ?
02:59:34 <lyxia> k0ral: toConsumer?
02:59:50 <cocreature> ongy: yes #alignment is new in 8.0 (or rather the corresponding hsc2hs version). the user guide describes how to do it on older versions https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/8.0.1-notes.html#hsc2hs
03:00:21 <lyxia> k0ral: though the types aren't quite what you wrote
03:02:02 <lyxia> k0ral: (>>= yield) . toConsumer
03:03:48 <k0ral> lyxia: right, it seems to work; what about "looping" the sink forever now ? :)
03:04:09 <k0ral> and yielding each result
03:04:53 <k0ral> forever . (>>= yield) . toConsumer ?
03:05:12 <lyxia> yeah
03:06:48 <k0ral> great, thanks, didn't know about the "toConsumer" trick
03:26:19 <lingxiao> heyall
03:31:51 <lingxiao> I'd like to describe an attoparsec parser that looks ahead as many nonAlphaNumerical symbols as possible and make sure the symbol following that is either a space or EndOfInput
03:32:03 <lingxiao> but I'm having trouble describing this lookAheadMany operation
03:35:13 <lingxiao>  many1 (lookAhead notAlphaNum)   does not terminate on input "--hello"
03:36:06 <lyxia> lookahead (many nonAlphanumerical *> (space <|> endOfInput))
03:36:38 <lyxia> many1 lookAhead tries many times to consume nothing
03:36:57 <lyxia> which it can do infinitely often
03:37:14 <puregreen> takeWhile isAlphaNum <* (space <|> eof)
03:37:33 <puregreen> and wrap that into lookAhead,
03:37:52 <puregreen> (or have I misunderstood?)
03:38:33 <puregreen> darn, * takeWhile (not . isAlphaNum)
03:39:06 <lyxia> isn't space nonalphanumeric too though?
03:39:18 <puregreen> good catch
03:40:00 <lingxiao> Thak you lyxia and puregreen 
03:46:03 <lingxiao> lyxia hey sorry I think notAlphaNum is too persmissive?
03:46:15 <lingxiao> or too restricitve i should say, it should not consume a space
03:46:29 <lingxiao> right now   parse (lookahead (many nonAlphanumerical *> (space <|> endOfInput)))  "... hello" is failing
03:47:04 <lyxia> right you need to add something to nonAlphanumerical to exclude spaces
03:48:03 <lingxiao> ahh gotcha thanks that makese sense
03:50:04 <lyxia> I think takeWhile as suggested by puregreen is more fitting, so: takeWhile (liftA2 (||) (not . isAlphaNum) isSpace) <* (space <|> endOfInput)
03:52:29 <lingxiao> ok I'll try that!
03:52:30 <lingxiao> thanks!
03:52:47 <saurabhnanda> anyone using Vagrant+Virtualbox? What's the recommended RAM & CPUs?
03:57:42 * hackagebot json-stream 0.4.1.1 - Incremental applicative JSON parser  https://hackage.haskell.org/package/json-stream-0.4.1.1 (ondrap)
04:04:35 <k0ral> care to help in naming a function "f :: Parser input result -> Conduit input result m" that yields only successfully parsed elements from input ?
04:04:52 <k0ral> while ignoring all others
04:05:18 <mauke> creamOfTheStream
04:05:33 <k0ral> s/Conduit input result m/Conduit input m result/
04:06:38 <k0ral> I was considering "parsed" but that seems quite unspecific
04:07:04 <k0ral> also it does not convey the idea of discarding unparsed input
04:08:15 <peteretep> I need a very simple tree data structure, which I can build up by essentially saying "create branch" "insert leaf at current branch" and "close branch"
04:08:29 <peteretep> I can implement it myself (perhaps) but I'd much rather use something already written
04:08:39 <peteretep> Triple plus points if it's in the standard ghc distro
04:08:56 <peteretep> I guess it's a tree with a pointer to the current depth
04:10:20 <lyxia> k0ral: I'd say it is a kind of filter
04:11:11 <lyxia> peteretep: a tree with a pointer sounds like a zipper
04:11:39 <lyxia> I can't quite visualize the operations you need though.
04:12:43 <k0ral> lyxia: definitely, but there's already a `filter :: Monad m => (a -> Bool) -> Conduit a m a` in conduit
04:15:02 <lyxia> parsingFilter?
04:27:09 <EvilMachine> Is there any kind of algorithm, that can‚Äôt be presented as a data structure?
04:27:19 <EvilMachine> *REpresented
04:27:52 <Taneb> What do you mean by that?
04:34:55 <k0ral> lyxia: parsingFilter is good, thanks
04:36:13 <infinity0> does anyone know of a doc that explains why ((,) a) is a functor but (a (,)) is not
04:36:43 <lyxia> what's (a (,))?
04:36:48 <infinity0> i sort of get why only one of them can be, but why the right and not the left
04:37:28 <{AS}> infinity0: so (,) is a type level operator
04:37:55 <{AS}> basically ((,) a) means the type of pairs applied to argument a
04:38:22 <{AS}> We could write it a bit like (a, ?) in pseudocode
04:38:51 <{AS}> and in category theory (?, a) is also a functor
04:39:02 <infinity0> i see, it's just because partial application goes from ltr and we can't do that "in the middle" as it were
04:39:10 <{AS}> Yeah
04:39:23 <peteretep> lyxia: Basically I have a stream of hierarchial results. Perhaps like I was building up an XML document, one tag at a time. Some tags are open, some are closed, some just are
04:39:24 <{AS}> You could probably define a type level swap
04:40:07 <peteretep> So in fact, any data structure capable of holding an XML tree, with a function that allows me to say "open", "closed" "single"
04:40:13 <{AS}> newtype Flip f b a = Flip { unFlip :: f a b }
04:40:17 * peteretep googles zipper
04:40:35 <{AS}> and then declare Flip (,) a as a Functor
04:40:40 <{AS}> with some extensions
04:40:45 <{AS}> but it isn't as nice to use
04:40:51 <peteretep> That looks like a good start, although it's not a binary tree
04:40:58 * zipper googles peteretep
04:40:58 <peteretep> or rather, my data structure isn't
04:41:04 <peteretep> lol
04:41:32 <{AS}> because you have to wrap your maps inside Flip and unFlip
04:41:42 <infinity0> understood
04:41:48 <{AS}> so if you want to map over the first argument you have to do unFlip . map . Flip :)
04:41:50 <zipper> My nick gets mentioned so many times because I do FP. So funny that me picking this nick was so long ago I had no idea FP existed.
04:41:52 <{AS}> great :)
04:42:10 <peteretep> I want like: e -> addElement Open|Close|Child a -> e
04:42:31 <peteretep>  e -> addElement Open|Close|(Child a) -> e
04:42:45 <{AS}> Can anyone refer me to some litterature on writing good custom QuickCheck generators?
04:43:26 <infinity0> thanks for the explanation!
04:45:31 <maerwald> {AS}: you mean Arbitrary instances?
04:46:06 <{AS}> maerwald: Yeah
04:46:24 <maerwald> haven't seen anything like that. I'd say the problem is too specific
04:46:41 <maerwald> e.g. if you want to generate random polygons with specific properties
04:46:54 <{AS}> maerwald: for example, yes
04:47:09 <maerwald> I'd just not use QuickCheck for that if it's too hard.
04:48:42 <{AS}> What would you recommend instead?
04:48:56 <maerwald> unit tests with hspec
04:49:48 <{AS}> OK :)
04:49:55 <tdammers> hmm, I think I saw a package flash by a while ago that was designed specifically for making Arbitrary instances for tree-shaped data types
04:50:02 <maerwald> property testing only makes sense if the Arbitrary instance is properly defined. If you are not sure, then it'll just cause trouble
04:50:02 <tdammers> or recursive data types in general
04:50:55 <{AS}> tdammers: It would be nice if you could remember what it was called :)
04:51:34 <tdammers> {AS}: well, that's the trouble :x
04:52:09 <tdammers> I could actually use that myself right now, considering I'm writing an AST optimizer
04:52:50 <tdammers> and one of the property tests I want is "generate an AST, optimize it, and verify that the original and optimized ones produce the same program output for the same inputs"
04:53:57 <{AS}> tdammers: So there is LazySmallCheck
04:56:07 <lyxia> peteretep: zipper can be generalized to ote
04:56:10 <lyxia> other trees
04:56:14 <peteretep> OK, thanks
04:56:43 <peteretep> ::r
04:58:43 <lyxia> @hackage generic-random {AS} 
04:58:43 <lambdabot> http://hackage.haskell.org/package/generic-random {AS}
04:59:03 <{AS}> lyxia: Thanks
05:00:10 <Squarism> i discovered that fmap f [1,2,3] workes for bot (*2) and (2*).. say i have a function f a b , can decide what argument im passing in a partial application? 
05:00:52 <lyxia> > let f a b = a - b in (`f` 1) 2
05:01:01 <lambdabot>  mueval-core: Time limit exceeded
05:01:01 <lambdabot>  mueval: ExitFailure 1
05:01:11 <lyxia> > let f a b = a - b in (`f` 1) 2
05:01:20 <lyxia> hmm
05:01:23 <lambdabot>  mueval-core: Time limit exceeded
05:03:02 <merijn> that's...odd
05:03:11 <merijn> I wonder if it's overloaded again
05:03:23 <merijn> @undefine -- maybe this helps
05:03:24 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
05:03:31 <merijn> @undefine
05:03:32 <lambdabot> Undefined.
05:03:43 <merijn> > let f a b = a - b in (`f` 1) 2
05:03:45 <lambdabot>  1
05:04:04 <Squarism> merjin: was that for me?
05:04:30 <lyxia> Squarism: sections are a special case for binary operators. In general if you want to pass an argument that appears farther than the first two you can use a lambda.
05:05:09 <Squarism> oh ok.. id hoped for some shortcut
05:06:04 <{AS}> Squarism: You could use pl to check
05:06:21 <Squarism> ?
05:06:25 <merijn> I wonder if there's some channel for people hacking on languages...so far I just hang around here, in #ghc and #idris, etc. but I'm not sure if there's a channel dedicated for that
05:06:49 <{AS}> @pl map (\x y z -> f y z x)
05:06:49 <lambdabot> map (flip (flip . f))
05:06:58 <{AS}> Squarism ^ 
05:07:40 <Squarism> okok
05:07:40 <{AS}> This applies to if you want to avoid lambdas for functions more than 2 arguments
05:07:53 <Squarism> i wanted something conceise
05:08:19 <Squarism> f _ 2 :: a -> a
05:08:23 <Squarism> or somehting =D
05:09:20 <lyxia> that's (`f` 2)
05:09:37 <Saizan> Squarism: also lambdas: fmap (\ x -> f x b) vs. fmap (\ x -> f a x)
05:10:13 <Squarism> i guess thats ok
05:22:46 * hackagebot StringUtils 0.1.0.0 - String manipulation utilities  https://hackage.haskell.org/package/StringUtils-0.1.0.0 (CIX_68)
05:32:46 * hackagebot fortran-src 0.1.0.3 - Parser and anlyses for Fortran standards 66, 77, 90.  https://hackage.haskell.org/package/fortran-src-0.1.0.3 (madgen)
05:36:13 <ardu> in page 15 of the haskell 2010 language report it says infixexp --> -infixexp. i'm confused about that, wouldn't that imply that - - 7 is a valid expression?
05:37:40 <merijn> ardu: Lemme see
05:37:54 <merijn> ardu: Section?
05:38:11 <ardu> merijn: thanks - right in the beginning of chapter 3
05:39:18 <merijn> eh, yes, you're right that that means "- - 7" would be correct, with the caveat that - is subject to parser hacks
05:39:22 <merijn> ardu: Which makes sense
05:39:34 <merijn> ardu: It's just applying the unary negation operator twice
05:40:01 <ardu> merijn: when i input that into ghci i get parse error on '-'. what do you mean about parser hacks?
05:40:38 <merijn> ardu: Well, let me give you a tricky example: 'f - 7'
05:41:07 <merijn> ardu: Is that: 1) the function 'f' applied to '- 7' (i.e. unary negation of 7) or 2) 7 subtracted from 'f'
05:42:20 <merijn> ardu: So in practice the parser only accepts - is unary negation when surounded by parens
05:42:25 <merijn> i.e. 'f (-7)'
05:43:09 <ardu> merijn: hmm, i see. do you have any idea where in the spec this is mentioned?
05:43:35 <merijn> I'm guessing section 3.4?
05:43:48 <ardu> let me see
05:44:07 <merijn> "Prefix negation has the same precedence as the infix operator - defined in the Prelude (see Table 4.1). Because e1-e2 parses as an infix application of the binary operator -, one must write e1(-e2) for the alternative parsing. "
05:44:35 <merijn> And - is also explicitly exempt from operator sectioning for this reason
05:44:58 <ardu> just a side node - wouldn't it be wiser to make prefix negation (-) to be consistent with the rest of the language?
05:45:28 <merijn> ardu: But what would prefix subtraction be, then?
05:45:35 <ardu> right.
05:45:55 <merijn> ardu: Alternative would've been to use, e.g. ~ for negation instead of -, but that's also kinda ugly
05:46:08 <ardu> hmm that's not too bad actually
05:46:17 <merijn> ardu: hindsight 20/20 :)
05:46:21 <ardu> :)
05:46:25 <merijn> Hard too fix now
05:46:30 <ardu> of course
05:46:45 <merijn> It's usually not that big a deal, imo
05:47:18 <thomasd> good morning :)
05:47:47 * hackagebot snap-cors 1.2.10 - Add CORS headers to Snap applications  https://hackage.haskell.org/package/snap-cors-1.2.10 (OliverCharles)
05:48:04 <ardu> yes i guess in practice it's not a problem at all. just getting me confused while reading the spec. merijn: thanks a lot. i'm going to go and read the relevant pages again because i recall i saw another weird thing there that i believe did not have something to do with prefix unary negation
05:49:03 <merijn> ardu: Yeah, it's a bit annoying that it makes the grammer slightly more complex than written. But writing the "real" grammar would make it harder to read
05:49:08 <merijn> ardu: Trade-offs :)
05:51:21 <ardu> merijn: oh i guess it's the same thing actually - it says infixexp --> lexp qop infixexp which would imply that 7 + -7 is a valid expression
05:52:48 <merijn> ardu: Yes, the only questionable case is "- -7"
05:54:09 <ardu> merijn: i'm not following - the part of the spec you pasted above doesn't seem to apply to 7 + -7 because it can't confuse it for infix negation now?
05:55:23 <merijn> ardu: If we parse "7 + ??" we know that "??" is infixexp
05:55:33 <merijn> ardu: And if it was a binary operator we'd have to see a lexp first
05:55:55 <merijn> But we see a qop ('-') so it HAS to be the "- infixexp" branch of infixexp
05:57:21 <ardu> merijn: i guess i'm missing something trivial.. so why doesn't it parse "7 + -7" as 7+?? where ?? -7 is the infixexp i.e. is -infixexp i.e. negate(7) ?
05:57:31 <ardu> where ?? is -7 i meant
05:57:42 <merijn> ardu: Because when parsing ?? we see that the first thing is -
05:58:04 <merijn> ardu: We know that 1) ?? is an infixexp and 2) it starts with '-'
05:58:19 <merijn> ardu: There's three branches of infixexp
05:58:29 <merijn> ardu: There is only one of those that can start with '-'
05:58:40 <ardu> merijn: right, i'm saying what's wrong with that branch? parse it as - 7
05:59:01 <ardu> -7 parses as infixexp --> -infixexp  where the right infiexp is the aexp 7
05:59:02 <merijn> ardu: Nothing
05:59:18 <merijn> ardu: I was confirming that "which would imply that 7 + -7 is a  valid expression" is correct
05:59:23 <ardu> ohh
05:59:50 <ardu> oh indeed now i see in ghci 7 + -7 does not give a syntax error but a "precedence parsing error"?
06:00:20 <merijn> oh, I suppose that comes from + and - having the same precedence >.>
06:00:32 <ardu> + and unary - ?
06:00:52 <merijn> binary + and binary - have the same precedence
06:01:01 <ardu> but the - must be unary
06:01:57 <merijn> ardu: The problem is that we have to parse operators without knowing their precedence
06:02:30 <merijn> ardu: Because the precedence of a user-defined operator can be defined later in the file from where the operator is used
06:02:55 <ardu> hmm, can the precedence of binary + and unary - be changed?
06:03:08 <merijn> ardu: So you basically parse one long list of binary operators, left associatively at the same precedence and then later, after parsing the precedence you restructure the list to be correct
06:03:24 <merijn> ardu: Can it be changed? No. Can you define a NEW + and - with different precedence? Yes.
06:03:39 <merijn> > let x + y = x * y in 3 + 3
06:03:41 <lambdabot>  9
06:04:14 <ardu> > let -x = x+3 in -7
06:04:14 <merijn> ardu: Since operators are just functions, you can shadow them like any other function
06:04:17 <lambdabot>  <hint>:1:5: error: Parse error in pattern: - x
06:04:18 <ongy> > let (-x) = 5 in -3
06:04:22 <lambdabot>  <hint>:1:6: error: Parse error in pattern: - x
06:04:32 <mniip> unary - is special
06:04:32 <merijn> ardu: Unfortunately the report earlier says that "-x" always translates to negate :)
06:04:39 <ardu> oh.
06:04:48 <mniip> > let negate = show in -5
06:04:51 <lambdabot>  -5
06:04:58 <merijn> ardu: From section 3.4 also: "The binary - operator does not necessarily refer to the definition of - in the Prelude; it may be rebound by the module system. However, unary - will always refer to the negate function defined in the Prelude. There is no link between the local meaning of the - operator and unary negation"
06:05:18 <mniip> merijn, sounds like it translates into Prelude.negate and is not rebindable?
06:05:27 <merijn> mniip: Yes
06:05:35 <merijn> Well
06:05:39 <ongy> mniip: why why does it print -5? if (-x) is 'negate x'?
06:05:41 <merijn> Unless you enable RebindableSyntax :)
06:05:57 <merijn> ongy: Because "-x" is not "negate x" :)
06:05:58 <ongy> oh
06:06:05 <merijn> ongy: "-x" is "Prelude.negate x"
06:06:09 <ardu> merijn: i'm still confused as to what precedence has to do with any of this. seems to me that 7 + - 7 can only be parsed as 7+(-7) ?
06:06:11 <mniip> ongy, a lot of things, when they desugar, use qualified identifiers
06:06:14 <mniip> so you can't override them
06:06:22 <mniip> there's an extension for that though: RebindableSyntax
06:06:27 <merijn> ongy: For obvious sanity reasons :)
06:06:40 <mniip> consider e.g
06:06:49 <ongy> maybe I want to do the insane things :)
06:06:51 <mniip> @undo do { x <- f; g x }
06:06:51 <lambdabot> f >>= \ x -> g x
06:07:01 <mniip> in reality it's more like Prelude.>>=
06:07:10 <merijn> ongy: Then you can enable RebindableSyntax extension :)
06:07:32 <mniip> > let (>>=) = const in [1,2,3] >>= show
06:07:34 <lambdabot>  [1,2,3]
06:07:51 <ongy> [1,2,3] >>= show
06:07:55 <ongy> > [1,2,3] >>= show
06:07:58 <lambdabot>  "123"
06:08:04 <mniip> okay I am proper confused now
06:08:20 <merijn> mniip: >>= can be shadowed
06:08:25 <mniip> oh
06:08:25 <mniip> duh
06:08:38 <mniip> > let (>>=) = const in do x <-[1,2,3]; show x
06:08:40 <lambdabot>  "123"
06:08:47 <mniip> I didn't wake up today :)
06:08:50 <ongy> > let (>>=) = const in do { x <- [1,2,3]; show x }
06:08:52 <lambdabot>  "123"
06:09:09 <ongy> does it desugar to (>>=) or (=<<)?
06:09:13 <merijn> ongy: >>=
06:09:21 <mniip> >>=
06:09:29 <mniip> sometimes also fmap, <*>, and join
06:09:30 <merijn> ongy: Although it doesn't matter, there's only one way it could typecheck :p
06:09:37 <merijn> mniip: Only with ApplicativeDo
06:09:41 <mniip> exactly
06:10:03 <ongy> what? the example above?
06:10:27 <merijn> ongy: Ignore mniip's remark, it's technically correct, but not very useful as beginner :)
06:10:41 <ongy> merijn: I wouldn't count myself beginner anymore :)
06:11:22 <merijn> ongy: Ok, maybe wrong phrasing: "Not very useful unless you're using a specific extension only available in the latest version of GHC that isn't very well tested yet" :p
06:12:22 <ongy> I haven't used list with do yet, but it looks like normal monad usage to me.
06:12:23 <ongy> :t show
06:12:25 <lambdabot> Show a => a -> String
06:12:48 <merijn> ongy: Yes, but the fmap, etc. remark was not related to that example
06:13:34 <ongy> ah. I have to look into ApplicativeDo at one point. But I don't want to break support for "old" compilers either
06:14:04 <merijn> ongy: The idea is that, in some case the Applicative implementation of operations is faster than equivalent monadic implementation
06:14:28 <ardu> merijn: could you try and explain to me again why would 7 + -7 result in precedence error? the way it's in my head now is that by the rules of parsing we talked about above, the - must be the unary -, and therefore there does not seem to be a reason why there'd be any precedence problems
06:14:42 <merijn> ongy: Consider the Async applicative that can do all IO in parallel, whereas it's monad would have to sequentialise everything. However sometimes the monadic code is more readable, so we want "best of both worlds"
06:14:43 <ongy> is there a desugar command with lambdabot?
06:14:52 <merijn> ongy: Readable code + Applicative execution
06:15:06 <merijn> ardu: I'm not 100%, tbh :)
06:15:25 <ardu> merijn: oh okay
06:15:49 <mniip> ongy, afraid not in lambdabot
06:15:54 <mniip> but in ghc you can -ddump-ds
06:16:00 <merijn> Well, there's undo
06:16:11 <ongy> @undo do x <- f; return x
06:16:11 <lambdabot> f >>= \ x -> return x
06:16:17 <ongy> @undo do x <- f; return (g x)
06:16:17 <lambdabot> f >>= \ x -> return (g x)
06:17:20 <ongy> so this could be rewritten to 'fmap g $ f' with ApplicativeDo?
06:17:38 <ardu> some more nitpicking from the spec.. in page 8 (section 2.2) an octit is defined as ascii 0..7 while hexit and digit also allow unicode. is this deliberate or a mistake in the spec?
06:17:45 <mniip> ah well
06:17:48 * hackagebot fixfile 0.3.0.0 - File-backed recursive data structures.  https://hackage.haskell.org/package/fixfile-0.3.0.0 (rev_null)
06:17:52 <mniip> -ddump-ds output is core
06:18:10 <mniip> which might be problematic to read for a novice
06:19:32 <ongy> I can deciver it, at least when I know what I'm looking at
06:22:21 <ardu> and another thing about unicode that seems like a mistake - again in page 8 (section 2.2) `any` is defined as `graphic` plus space/tab i.e. `ANY` minus newlines, vertical tabs and uniWhite. but i would assume uniWhite is to be allowed as `any`?
06:23:47 <ardu> (or at least any uniWhite which is not line breaking)
06:24:48 <merijn> ardu: That's a judgement call
06:25:02 <merijn> ardu: Looks like they decided not too to keep one-line comments unsurprising
06:25:18 <merijn> ardu: I mean, do you really need any unicode whitespace in one line comments?
06:25:38 <merijn> Because single line comments is the only grammar section allowing 'any'
06:26:06 <ardu> merijn: i'd actually expect for single line comments to allow anything other than line breaks, so yes, that would be least surprising to me
06:26:49 <merijn> ardu: I don't know the reasoning behind it
06:27:22 <ardu> merijn: i could be wrong but i get the feeling this wasn't a deliberate decision but an oversight. the reason i think this is that the octit definition seems to be lacking when it comes to unicode too, and there's it's even harder to justify the omission
06:27:53 <merijn> ardu: What should octit include that's not in it?
06:28:12 <Guest72983> why o why must you torture me so, IO? http://lpaste.net/180277
06:28:20 <ardu> merijn: hex digits and decimal digits allow not only ascii digits but also unicode digits. but octit only allows ascii 0-7
06:28:34 <Gurkenglas> I think to make https://hackage.haskell.org/package/indexed-0.1/docs/Control-Monad-Indexed-Trans.html make sense we need ekmetts lenses into nested monad transformers. Composing two indexed monad transformers obviously takes the product of the indices, right?
06:29:42 <srhb> Guest72983: An IO (Either e a) doesn't _contain_ values like Left x or Right y
06:30:19 <Guest72983> srhb: is there any way to obtain them then?
06:30:33 <mniip> Guest72983, No.
06:30:35 <mniip> (yes)
06:30:39 <Gurkenglas> Guest72983, you'll be wanting to define configLibraryPath in your main
06:31:03 <srhb> Guest72983: What resource are you going by? This is a topic that deserves some attention from a text book or the like rather than a few short remarks :-)
06:31:46 <Gurkenglas> main = do config <- readIniFile "config.ini"; configLibraryPath = case config of ...; Ö
06:31:54 <Guest72983> srhb: umm... no real resource whatsoever. I just needed a config file and looked for a library that would supply me with some access methods.
06:32:47 <Guest72983> Gurkenglas: that seems horrible wrt encapsulation. I might need to call this a few times from different places.
06:32:47 <Gurkenglas> (and maybe you want lambdacase to not have to name config: 'main = readIniFile "config.ini" >>= \case ...; Ö)
06:32:50 <srhb> Guest72983: Well, the problem you're bumping into is completely generic (and will happen whenever you use IO) and not specific to the config library thingy. 
06:32:58 <srhb> Guest72983: So whatever Haskell resource, I meant. :)
06:33:08 <Gurkenglas> Guest72983, what if the "config.ini" changes in the meantime?
06:33:45 <mniip> there is a cheat that you can use if your IO is referentially transparent
06:33:53 <mniip> bu 90% of the time you should be using something else
06:34:33 <merijn> hmm, I wish StateT had a function included for "read + update state and return old value"
06:34:40 <Guest72983> srhb: I see. I've read some of Christopher Allens "Haskell Programming". Gurkenglas: that won't happen
06:35:47 <Guest72983> mniip: that's great and all and I'm not too keen on using IO but in the current situation I just need to read from file
06:35:51 <Gurkenglas> merijn, "id <<%="
06:36:08 <mniip> well
06:36:43 <Gurkenglas> Tell him the terrible invocation of power
06:36:53 <mniip> if you can promise the haskell runtime that your IO can be executed at any time, or even multiple times, and it will always return the same value
06:36:59 <merijn> Gurkenglas: That requires lens, I think I'll just use "get <* modify' (+1)"
06:37:04 <mniip> in return you can hope that unsafePerformIO will not crash your program
06:37:11 <mniip> :t System.IO.Unsafe.unsafePerformIO
06:37:12 <lambdabot> IO a -> a
06:37:37 <merijn> Maybe we should call it abandonHopeAllYeWhoEnterHereIO
06:37:58 <mniip> I like accursedUnutterablePeformIO
06:38:02 <srhb> Guest72983: This is not an approach you should be using if you're just starting out, and you probably WILL be doing other IO as well (unless you intend for your program to just warm your room)
06:38:36 <hpc> mysql_real_perform_io
06:38:41 <srhb> By which I mean: It's hard to get it right :-)
06:38:46 <Gurkenglas> Relative to that, it might even be a better idea to just make the whole program fit in your main's do block and use lets for all the definitions
06:39:04 <mniip> merijn, thisFunctionWillBreakYourProgramLikeSeriouslyYouHaveNoIdeaWhatKindOfPowerYou'reMessingWithWhenYouNeedToPerformIO
06:39:04 <Guest72983> I'm pretty sure that there's good reason behind this all but frankly. I'm just trying to read a string from file to have some indicator on where my program should be looking for files and the language goes all wololo on me.
06:39:11 <Gurkenglas> Then you can say "<-" instead of "= unsafePerformIO $" and all else will stay the same
06:39:54 <srhb> Guest72983: There's a very good reason. :)
06:40:02 <merijn> 20 bucks says you'll regret this somewhere in the next 1 or 2 weeks
06:40:17 <Guest72983> srhb: it's not a learning project but a real tool I'm extending. And it just needs to be modifyable via a config file. I'm sadly not too free in deciding this.
06:40:20 <srhb> Guest72983: It can be instructional to just unsafePerformIO it and revisit :-P
06:40:21 <agocorna> Gurkenglas: only that the operation will be executed when needed and not in sequence. That may be useful in some cases
06:40:29 <merijn> oh
06:40:34 <srhb> Guest72983: Ouch, that's rough.
06:40:43 <merijn> If it's an actual tool I'm going to say 50 bucks
06:41:03 <mniip> ah well
06:41:06 <ahihi> I am disappointed that the haskell type system does not capture the "warming the room" effect
06:41:15 <Guest72983> ¬Ø\_(„ÉÑ)_/¬Ø well what should I do instead.
06:41:16 <mniip> if it's a real tool
06:41:24 <ahihi> what if the room contains a temperature-controlled missile launch trigger?!
06:41:25 <mniip> basically what merijn said
06:41:53 <merijn> Guest72983: Invest the time to understand why things are the way they are
06:42:01 <agocorna> lazyExec= return . unsafePerformIO
06:42:15 <srhb> Or get someone who knows Haskell to do it, really. Either way. :-P
06:42:18 <hpc> lazyExec = unsafeInterleaveIO
06:42:26 <merijn> @quote Lemmih not.a.bug
06:42:26 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
06:42:42 <Guest72983> Alright. *chants* almighty haskell God, why do I have to perform a voodoo ritual and sacrifice 32 virigins each time I want to have side effects at some very isolated point of my program.
06:43:18 <cocreature> Guest72983: because it means that everything that relies on that isolated part is now no longer referentially transparent
06:44:04 <cocreature> Guest72983: but don‚Äôt feel too bad about starting by spamming IO all over your program and then later refactoring it. you don‚Äôt need to get everything right the first time :)
06:44:08 <hpc> or to continue the metaphor, because you're about to commit an unspeakable evil
06:44:47 <Gurkenglas> Guest72983, your encapsulation feeling might be soothed if you do it like "main = do config <- readIniFile "config.ini"; let ?config = config in do ..."
06:45:13 <hpc> also writing haskell with IO touching everything isn't even that bad
06:45:22 <Gurkenglas> Then all the functions that need access to the config will have an extra (?config :: Config) => in their type signature
06:45:48 <merijn> hpc: Word.
06:46:09 <Guest72983> Does ? have semantics or is it just an visual indicator for "there be side effects"?
06:46:12 <hpc> unless you're about to claim that it's impossible to write good code in a language without separation of IO
06:46:52 <hpc> Guest72983: it's implicit parameters, which are the greatest unspeakable evil in all of ghc
06:46:56 <Gurkenglas> ? has semantics: It adds "implicit parameters" that don't need to be passed explicitly, and go in the constraints rather than the function arguments of type signatures
06:47:00 <merijn> hpc: They're really not
06:47:01 <srhb> Guest72983: It's called implicit parameters, and it would probably work here, but it's not really clear to anyone who will read it later :P
06:47:03 <hpc> (except for all the other unspeakable evils we don't talk about)
06:47:06 <Gurkenglas> Huh, they're unspeakable too?
06:47:07 <merijn> hpc: ImplicitParameters are pretty sane
06:47:16 <merijn> hpc: Not particularly useful in most scenarios
06:47:24 <merijn> hpc: But I'd hardly call them evil
06:47:25 <hpc> they make sense, but the code you can write with them is pretty heinous
06:47:30 <hpc> i consider it organizationally evil
06:47:41 <hpc> it's no IncoherentInstances though, for sure
06:47:43 <Guest72983> There seems to be a lot of unspeakable evils in the great book of haskell
06:48:02 <srhb> Guest72983: There is everywhere, but we dare name them thusly!
06:48:08 <hpc> Guest72983: some evils are eviler than others, and some evils aren't even evil
06:48:13 <hpc> it's a whole thing
06:48:14 <Gurkenglas> And then there's the Reader monad.
06:48:14 <srhb> Also everyone should talk like this about programming all the time.
06:48:15 <maerwald> you can do the same with the reify package
06:48:28 <Gurkenglas> Which is pretty much exactly passing function parameters :P
06:48:34 <hpc> Guest72983: basically programming is terrible and sarcasm is how we cope :D
06:48:52 <Guest72983> looks like I pretty much fit in then.
06:49:09 <Gurkenglas> Maybe you want your config to instead be compilation flags?
06:49:31 <Guest72983> there's some good amount of sarcasm seeping through me already. I have a hard time not screaming at my monitor and breaking stuff.
06:50:02 <srhb> Guest72983: You really should take the half-hour to read up on it. It will be less frustrating than trying to make sense of our half-answers
06:50:11 <srhb> Or you can probably coax someone here into giving you the Full Lecture
06:50:31 <Guest72983> Gurkenglas: no. The config should contain a path to some directory that is different on every user's machine. The user shouldn't have to pass that path each time he runs the tool. But it must be configurable.
06:50:59 <mniip> full lecture on what?
06:51:08 <mniip> a nebulous topic that not everyone totally agrees on?
06:51:37 <srhb> mniip: Point taken, but you're not helping :-P
06:51:46 <srhb> How to basic IO
06:51:50 <srhb> (I would so watch that video)
06:52:13 <agocorna> Guest72983: pass it in the command line
06:52:20 <Gurkenglas> Guest72983, if he passed that path each time he runs the tool, you'd still have this problem :P
06:52:34 <Gurkenglas> (except the unsafePerformIO way wouldnt even work)
06:52:58 <Guest72983> Gurkenglas: so it would be even worse :P agocorona: I wouldn't want to have the user specify it each time he runs the tool
06:53:44 <Guest72983> I guess my problem with learning haskell is that whenever I google some topic it starts off with something like "as we've learned in the chapter of covariant Monad astrophysics..." and then I have to go into recursion. :P
06:54:22 <srhb> Guest72983: It's not hard, it's just... Different, and you need different basics.
06:54:34 <maerwald> it is hard
06:55:03 <hpc> "hard"
06:55:11 <srhb> Sigh
06:55:12 <hpc> there's just a lot of things to learn and in the right order
06:55:21 <agocorona> Guest72983: construct the file name from the machine hostname
06:55:36 <srhb> Guest72983: They still need to read the file. The issue is "why is IO hard"
06:55:49 <srhb> oops
06:55:53 <srhb> agocorona: ^
06:55:55 <hpc> if something is hard to learn, it's because there's something else you should learn first
06:56:01 <Guest72983> I'm probably facing the same problem almost every procedural programmer is running into. Doing basics all over again in a different concept when you've done that stuff for years requires... much self motivation.
06:56:10 <srhb> Guest72983: yes, that is true :)
06:56:30 <agocorona> hi srhb
06:56:41 <maerwald> no, haskell uses concepts that require a fair amount of abstract understanding and not only that, it's also pretty difficult to develop intuition in some areas. More than in other languages imo.
06:56:46 <Guest72983> agocorona: I sense some trolling.
06:56:53 <Gurkenglas> Guest72983, why do you want configLibraryPath to not be an IO action anyway? Isn't the path you're apparently extracting from the config also going to be used for an IO action?
06:57:03 <merijn> maerwald: More so than ocaml?
06:57:30 <maerwald> it's just that most haskellers either forget about it or don't want to admit how hard it was, because it's a bad seller. imo
06:57:56 <maerwald> merijn: I dont know ocaml
06:58:09 <merijn> maerwald: It's basically haskell, but not lazy and no IO
06:58:15 <Gurkenglas> We could look at people's early ircbrowse logs in here to see whether it was hard for them
06:58:25 <maerwald> I know what the language is, but I don't *know* the language
06:58:39 <Guest72983> Gurkenglas: because I've spent the last day to isolate the IO actions in that called function to have it be a clean interface that works without IO :D
06:59:07 <hpc> maerwald: the only "hard" learning is the kind that involves logical leaps
06:59:09 <Gurkenglas> May we see that code?
06:59:16 <hpc> which is the very definition of bad learning
06:59:37 <agocorona> Guest72983: I don¬¥t know why
07:00:32 <ardu> merijn: i just tested it, it seems ghci does allow unicode space in single line comments
07:01:34 <maerwald> hpc: I disagree
07:01:43 <Guest72983> Gurkenglas: my head is too clouded now to gather all the required functions to paste a proper working sample.
07:02:14 <Gurkenglas> Doesn't need to work I think.
07:02:22 <srhb> Guest72983: If you write a program that a: gets a line from the user (with getLine) and b: prints it -- the solution is the very same that you need to employ here.
07:02:29 <Guest72983> okay, let's start again with a more basic question. Referential transparency means "I can call this function again and again and it won't behave differently", right?
07:02:47 <srhb> Guest72983: Given the same arguments, it will always produce the same value, yes.
07:02:58 <Gurkenglas> (And also "the compiler knows this and can use that fact for optimizing")
07:03:11 <srhb> Like, not recomputing it, because why would it.
07:03:27 <mniip> or
07:03:31 <mniip> which is an important point
07:03:43 <mniip> accidentally computing it twice in a concurrent data race
07:03:48 <mniip> because no one cares if that happens
07:03:52 <hpc> Guest72983: (referential transparency is actually more powerful than that, it's really that calling a function and getting a result is always equal to having that result in the first place)
07:03:59 <Guest72983> so whenever I'm dealing with anything but constants - output from databases, user input, parameters, network traffic - all functions that are being fed that input are no longer referential transparent?
07:04:16 <maerwald> hpc: white lie though... it's only the result of evaluation, not execution
07:04:38 <nclarke> @pl \x -> (x,) <$> f x
07:04:38 <lambdabot> (line 1, column 9):
07:04:38 <lambdabot> unexpected ","
07:04:38 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
07:04:54 <hpc> maerwald: calling a function doesn't execute anything ;)
07:05:03 <maerwald> ?
07:05:26 <hpc> ?
07:05:31 <mniip> nclarke, (,) <*> (flip fmap . f)
07:05:32 <srhb> Guest72983: That's difficult to answer, because we have a model to make it referentially transparent again, which is exactly what you're struggling with.
07:05:44 <Gurkenglas> @pl \x -> ((,)x) <$> f x
07:05:44 <lambdabot> liftM2 (<$>) (,) f
07:05:49 <mniip> ooo
07:05:52 <maerwald> hpc: the RTS calls *functions*
07:05:53 <mniip> that's nicer
07:06:18 <Guest72983> srhb: alright, what is that model called then?
07:06:18 <mniip> mniip 0 pl 1
07:06:27 <srhb> Guest72983: IO. :-P
07:06:30 <Guest72983> goddamnit.
07:06:53 <hpc> maerwald: functions as in things with (->) at the root of their type
07:07:02 <hpc> maerwald: the RTS executes closures
07:07:20 <hpc> which are implemented as blocks of assembly
07:07:22 <maerwald> so it doesn't call libc functions?
07:07:24 <hpc> and assembly has no notion of functions
07:07:29 <mniip> hpc, the rts executes functions too
07:07:52 <mniip> when you apply a function there's a block of code that interprets the arguments and tells the rts which closure is the result
07:08:21 <hpc> when did this conversation go from "this is how haskell works" to "this is how the RTS executes machine code"?
07:08:31 <srhb> Pedant central engaged, somehow.
07:09:00 <hpc> if you want to argue that pure functions count as execution than whoop-de-doo, basil
07:09:02 <merijn> hpc: People like to confuse and mix operational and denotational meanings
07:09:03 <maerwald> hpc: when you started a distinction that's not useful
07:09:24 <hpc> executing the RTS blob of code that says "apply a pure function to an argument" warms your CPU
07:09:27 <hpc> good job
07:09:30 <jonored> Guest72983: Basically, referential transparency is preserved even when you're accessing the DB because one of the arguments, and the return value, of all of the "not referentially transparent" functions is effectively guaranteed to be unique. (the actual implemetation isn't exactly that, but that's sorta the the key idea)
07:09:35 <hpc> you've cracked the code of referential transparency and language semantics
07:09:36 <glguy> Guest72983: applying functions isn't causing the IO, the functions are creating actions that when they executed have effects
07:09:42 <hpc> haskell is impure because entropy exists
07:09:44 <hpc> math is a lie
07:09:46 <hpc> we can all go home
07:10:27 <Gurkenglas> If entropy didnt exist we wouldnt need all this referential transparency stuff anyway, just compute everything as often as needed because its free
07:10:36 <glguy> Guest72983: so if you have do let x = print 42; x
07:10:36 <mniip> referential transparency cannot exist because function application loses information
07:10:40 <mniip> and thus yields energy
07:10:43 <glguy> that prints 42 once
07:11:05 <glguy> do let x = print 42; x ; x
07:11:07 <hpc> maerwald: the distinction is that what was said before my clarification is idempotence, which is a totally different thing
07:11:07 <glguy> twice
07:11:28 <glguy> and do let x = print 42; return ()
07:11:33 <glguy> doesn't print
07:12:02 <glguy> and those things only print if your main action executes them by including then in itself
07:12:35 <glguy> print is a function that makes actions, it's not a function that prints
07:12:50 * hackagebot camfort 0.900 - CamFort - Cambridge Fortran infrastructure  https://hackage.haskell.org/package/camfort-0.900 (madgen)
07:12:58 <mniip> is it recipe analogy time?
07:14:40 <mniip> Guest72983, an 'IO a' value can be thought of as a recipe explaining the execution system what things to do to obtain a value of type 'a'
07:14:52 <mniip> recipes themselves are pure and referentially transparent
07:15:32 <mniip> and your program defines an "entry point", the "main" recipe that the execution system picks up and starts executing
07:16:30 <maerwald> hpc: I just showcased another reason why haskell is not easy to learn
07:16:32 <Guest72983> isn't any non-void function a recipe that describes exactly that?
07:16:39 <mniip> no
07:16:43 <mniip> functions cannot do IO
07:16:53 <mniip> recipes describe IO-doing operations
07:16:53 <maerwald> hpc: you read about referential transparency, but then you see IO and you get confused, so you have to learn yet another detail
07:17:01 <Guest72983> but they describe how to acquire a value
07:17:04 <hpc> maerwald: no, you just deliberately obfuscated
07:17:09 <maerwald> no
07:17:14 <maerwald> the distinction is highly important
07:17:45 <mniip> Guest72983, referential transparency is why we choose to have this distinction in haskell
07:18:07 <Guest72983> what is a function then?
07:18:32 <mniip> a mapping from arguments to results
07:18:36 <mniip> just like in math
07:19:02 <Guest72983> so... a set of instructions how to acquire the result? Then I don't see how IO is different from that.
07:19:30 <mniip> 'getLine' is not a mapping from arguments to results
07:19:36 <mniip> the result is different each time
07:19:41 <mniip> and what is even the argument here?
07:20:47 <Guest72983> is "f -> Integer; f = 42" not referential transparent then?
07:20:47 <mniip> 'instructions' is vague
07:20:49 <agocorona> Alternatively you can program haskell like any other language as long as things type check and don¬¥t care about the details.
07:21:04 <mniip> that's not a function
07:21:07 <mniip> that's a constant
07:21:18 <mniip> it is referentially transparent by definition
07:22:14 <mniip> if you look at f :: () -> Integer
07:22:26 <hpc> Guest72983: the key distinction is fuctions are in terms of "is equal to" and IO is in terms of "do this, then that"
07:22:30 <mniip> the mathematicity of the function lets you reason that 'f ()' will always be the same value
07:22:42 <mniip> that's kinda what referential transparency is
07:22:51 * hackagebot hindent 5.1.0 - Extensible Haskell pretty printer  https://hackage.haskell.org/package/hindent-5.1.0 (ChrisDone)
07:23:23 <hpc> Guest72983: to give a specific example:
07:23:27 <hpc> :t putStrLn
07:23:28 <lambdabot> String -> IO ()
07:23:34 <Guest72983> The point I'm trying to understand is the following: I see that having input could change the result of a function everytime it is called. And that's okay when reading the file. But the result of my configLibraryPath can yield one of exactly two results. So if I'd cover them both individually that should be referentially transparent, no?
07:24:04 <mniip> no?
07:24:05 <glguy> readLine "stuff" never changes
07:24:15 <glguy> it's always the same action
07:24:29 <glguy> err readFile
07:24:40 <hpc> Guest72983: putStrLn is a function, which you can see by it having (->) as the "root" of its type
07:24:50 <jonored> Guest72983: You can sort of view the way a haskell program works as "main is a function from one state of reality to another state of reality. Functions from reality state to reality state are composable, and can chain back into more functions to decide what to compose on the end next."
07:24:59 <Guest72983> is it referentially transparent then, glguy?
07:24:59 <mniip> jonored, oh no :(
07:25:06 <hpc> Guest72983: (putStrLn "banana") *is equal to* an action that will print "banana" if you tell it to
07:25:13 <mniip> Guest72983, how do you "cover them both individually"
07:25:30 <jonored> mniip: ...meep?
07:25:37 <hpc> Guest72983: and then when that action is executed, *do stuff that will* print it to the screen
07:25:38 <agocorona> In the future I don't think that  haskell programmers will care so much about low level details of the language. 
07:25:50 <mniip> Guest72983, define a function that always return True, and a function that always return False, and then what?
07:26:44 <Guest72983> Oh man. My head spins. Alright everyone. Thanks to everyone who made an attempt to clear things up for me but maybe I should do only so much haskell in one day. I guess I'll go and prettyprint some documents with C or something and cry in a corner. So long.
07:27:30 <mniip> :(
07:27:40 <maerwald> that's why haskell is hard...
07:27:55 <mniip> this is what happens when one person tries to reason about recipes and the other is explaining State RealWorld
07:28:16 <Cale> Guest72983: The function from Bool to whatever the rest of your program does based on the result of the configuration should be referentially transparent
07:28:27 <mniip> and then in background someone argues whether the RTS treats State# as a thread identifier token or just as a cause of evaluation
07:28:31 <hpc> Guest72983: don't get demotivated, you'll eventually build up enough understanding of related concepts that parts of the explanation will make more sense
07:28:45 <hpc> Guest72983: and repeat until the whole idea becomes clear
07:28:49 <puregreen> Guest72983: it might be better if you got a mentor here (https://github.com/haskell-learning-group/haskell-learning-group), having one person explain things to you patiently is better than having 4 people explain things and correct each other at the same time
07:29:01 <Cale> Ignore the "function of reality" nonsense, it doesn't really work.
07:29:14 <merijn> Cale: s/doesn't really/really doesn't
07:29:22 <Cale> merijn: haha
07:29:28 <Ashy> there's also a couple excellent free books on haskell too
07:29:28 <agocorona> I think that this way of explaining IO as a state of the world to another state of the world is bad pedagogy sorry.
07:29:41 <agocorona> and it is not true by the way
07:29:50 <merijn> agocorona: Almost everyone thinks it's bad
07:29:58 <agocorona> and detract people from learning haskell
07:30:07 * jonored will avoid mentioning that, then.
07:30:13 <maerwald> mniip: no, it started when someone came up with referential transparency while this was about IO actions. In order to not be confused here one must understand the difference of evaluation vs execution in haskell. A python programmer doesn't care about that.
07:30:30 <Guest72983> Don't worry guys, you haven't seen the last of me and I will pick up my haskell book again to go back to basics - as soon as I have some time. But this is really getting messy here and I wouldn't want to get cocky out of frustration while you're trying to help.
07:30:31 <hpc> Guest72983: there's a lot of inter-related concepts to learn and for some parts of it you just need to chip around the edges first
07:30:45 <hpc> :)
07:30:48 <agocorona> I'm for the formula: first teach how to use it, without care about the details. after if he ask how, explain it
07:31:32 <mniip> agocorona, in some areas I wouldn't like to be taught that way
07:32:00 <Gurkenglas> Why does http://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Operators.html#v:-37--61- say "(%=) :: MonadState s m => ASetter s s a b -> (a -> b) -> m ()" but http://hayoo.fh-wedel.de/?query=%25%3D says "(Profunctor p, MonadState s m) => Setting p s s a b -> p a b -> m ()"?
07:32:22 <hpc> Gurkenglas: what's the type of (%=) in other versionf of lens?
07:32:56 <agocorona> explaining the IO monad without using it first is like teaching music staring with the theory, without an instrument or teaching a language by grammar without conversation
07:33:05 * Gurkenglas goes binary searching through the lens docs
07:34:26 <maerwald> agocorona: the problem is that you cannot talk about referential transparency without people being confused about how that works with IO
07:34:43 <maerwald> so you have 3 choices: 1. don't mention it, 2. use a white lie, 3. explain it
07:35:00 <hpc> or 4, learn something else first that builds into it
07:35:04 <maerwald> leaving people confused however is not useful
07:35:05 <implementation_> agocorona: it is very common to teach Latin grammar without latin conversation
07:35:11 <agocorona> mniip: most of the people want to get things done . help him first on that. Then he will get confidence and would enter in details
07:35:12 <hpc> you don't have to jump into a concept head-first
07:35:14 <dmj> is anyone aware of a monadic interface for mutable vector construction?
07:35:36 <agocorona> implementation_:  that is because latin is a dead language. Would you like haskell too?
07:35:41 <hpc> dmj`: i think you can use ST and some freezing shennanigans
07:36:42 <implementation_> agocorona: it's a dead language, but the approach works. it's not that people cannot learn it that way.
07:36:45 <mniip> just integrate the state tags in MutableArray# into the ST flow
07:37:03 <mniip> then a mutable array cannot escape ST
07:37:07 <mniip> but a frozen array can
07:37:16 <maerwald> hpc: you started with referential transparency :P
07:37:31 <agocorona> implementation_:  I don't agree. it does not work. nobody uses it. not even the church nowadays
07:37:38 <hpc> i only entered the discussion about it that was already happening
07:37:45 <Gurkenglas> Yep, 4.13 changed that. Not obvious from the changelog :I. Is it really more general if p a b is replaced by (a -> b)?
07:38:11 <hpc> dmj`: i found https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Mutable.html#t:MVector but it doesn't have a freeze operation
07:38:41 <hpc> dmj`: oh, it uses MutableArray which does have a freeze: https://hackage.haskell.org/package/primitive-0.6/docs/Data-Primitive-Array.html#t:MutableArray
07:38:45 <hpc> and it also carries the s
07:39:02 <dmj`> hpc: yea, I'm seeing similar things in Data.Vector.Generic.New, still think even with ST we need to know how many elements we're making ahead of time. Wanting like a non-deterministic way to yield n elements into a mutable vector
07:39:58 <hpc> dmj`: you can use MutableArray with IO as well, it uses PrimMonad
07:39:59 <dmj`> hpc: trying to avoid cons cells that fromList would have to deal with. I see we can cons with Stream, convert that to a bundle, than to an MVector
07:40:02 <hpc> https://hackage.haskell.org/package/primitive-0.6/docs/Control-Monad-Primitive.html#t:PrimMonad
07:40:23 <hpc> or something
07:40:39 <agocorona> maerwald:  i learnt the deep meaning of referential transparency after some experience using haskell. Before that it was impossible I may pass an exam on it but I did'nt know what it was until I used haskell and read about RT after
07:40:55 <dmj`> hpc: yes, this would be for a library where a user would have a lucid/blaze like interface for constructing vectors
07:40:56 <implementation_> agocorona: the reason why latin is not spoken nowadays is that there are no native speakers. this has nothing to do with the learning method.
07:41:01 <maerwald> agocorona: yep, that's why haskell is hard
07:41:32 <hpc> maerwald: "it should be learned after something else" doesn't automatically make it hard
07:41:46 <jonored> hm... perhaps the trick is that the explanation didn't quite get to "the only things that the program /does/ are the IO actions that are included in main".
07:41:50 <agocorona> maerwald:  I don¬¥t think so. The Java Runtime is very very hard to understand. And this is not a problem for Java programmers
07:42:38 <maerwald> because they dont understand it
07:42:44 <dmj`> I'm also curious as to why Stream doesn't have a Monoid instance using Stream.empty and Stream.(++)
07:43:00 <merijn> You don't need to understand the haskell runtime either
07:43:02 <agocorona> And the way the OS interleave asynchronous requests to perform a readFile is really complex. But that helps me. It does not make programming more hard. on the contrary
07:43:02 <hpc> maerwald: so is java hard?
07:43:06 <maerwald> no
07:44:48 <hpc> you must have a really contradictory definition of "hard"
07:44:59 <maerwald> no
07:46:02 <dmj`> wonder why there isn't an Eq for Stream as well...
07:46:43 <hpc> maerwald: i accept your unexplained claim at face value and hereby vow to change my entire worldview based on your "no"
07:46:45 <dmj`> oh there is, but it requires a Monad constraint :/
07:47:23 <maerwald> hpc: aha, so you want me to argue against your unexplained assumption?
07:47:37 <maerwald> not getting into that kind of gamew :)
07:47:59 <maerwald> and by now it's -offtopic
07:54:56 <ania123>  I need to choose a title from follwoing three alternatives, can one tell me which one is correct? Designing and Analyzing encryption protocols using formal method techniques or Designation and Analyze encryption protocols using formal method techniques or Design and Analyzing encryption protocols using formal method techniques
07:55:42 <byorgey> ania123: the first one sounds best to me
07:56:15 <byorgey> also, you can probably just say 'formal methods'.  'formal method techniques' sounds redundant.
07:56:40 <hpc> "Designing and analyzing encryption protocols using formal methods"
07:56:42 <hpc> :D
07:57:38 <ania123> Design and Analysis of encryption protocols using formal method techniques
07:57:43 <ania123> is it better then first one?
08:00:23 <hpc> i would still go with the first one
08:01:15 <pavonia> ania123: There's also ##english for questions related to the English language
08:01:42 <hpc> ania123: are those formal methods interesting to haskellers? ;)
08:12:03 <ardu> what is (,) for? i realize "(,) 3 5" gives me (3,5) but in what cases would i want to use that form?
08:12:28 <hyPiRion> ardu: if you want to pass it to a higher order function, for example.
08:12:30 <chelfi> for partial application I guess
08:12:52 * hackagebot imperative-edsl 0.7 - Deep embedding of imperative programs with code generation  https://hackage.haskell.org/package/imperative-edsl-0.7 (EmilAxelsson)
08:12:59 <hyPiRion> > zipWith (,) [1..3] [4..6]
08:13:01 <lambdabot>  [(1,4),(2,5),(3,6)]
08:13:20 <ardu> oh i see, great
08:13:35 <ardu> what would i do if i wanted to use zipWith to create [[1,4],[2,5],[3,6]] from [1..3] and [4..6] ?
08:13:59 <thomasd> zipWith (
08:14:26 <thomasd> zipWith (\x y -> [x,y]) [1..3] [4..6]
08:14:35 <c_wraith> ardu: transpose is better for that, though
08:14:45 <c_wraith> > transpose [[1..3],[4..6]]
08:14:47 <lambdabot>  [[1,4],[2,5],[3,6]]
08:15:20 <ardu> i see, so for tuples i could've just done:
08:15:29 <ardu> > zipWith (\x y -> (x,y)) [1..3] [4..6]
08:15:31 <lambdabot>  [(1,4),(2,5),(3,6)]
08:15:32 <c_wraith> ardu: best to unlearn python (for example) and not think tuples and lists have *anything* in common in Haskell
08:15:34 <thomasd> yes
08:15:38 <thomasd> ardu: yes
08:15:47 <thomasd> or you could just use "zip"
08:15:51 <thomasd> because that's how zip is defined
08:16:12 <thomasd> zip [1..3] [4..6] === zipWith (,) [1..3] [4..6]
08:16:30 <ardu> any particular reason why haskell defines (,) to save me from typing (\x y -> (x,y)) ?
08:16:42 <thomasd> zip [1..3] [4..6] === zipWith (,) [1..3] [4..6] === zipWith (\x y -> (x,y)) [1..3] [4..6]
08:16:51 <thomasd> (,) is an operator, bascially
08:16:52 <c_wraith> ardu: because it's consistent with every other infix operator?
08:17:18 <thomasd> just like (+) == (\x y -> x + y)
08:17:19 <hpc> ardu: the reason it's awkward for the list version is that lists are defined differently
08:17:21 <c_wraith> ardu: programmers do what's easy.  Why introduce friction in the cases that you want to encourage?
08:17:34 <hpc> [1, 4] is 1 : 4 : []
08:17:44 <hpc> @pl \x y -> (x : y : [])
08:17:44 <lambdabot> (. return) . (:)
08:17:48 <c_wraith> ardu: When you want to make passing functions easy, make the syntax for doing so as simple as possible.
08:17:53 * hackagebot pulseaudio 0.0.1.0 - A low-level (incomplete) wrapper around the pulseaudio client asynchronous api  https://hackage.haskell.org/package/pulseaudio-0.0.1.0 (ongyerth)
08:18:01 <thomasd> well, really (+) == (\x -> (\y -> x + y))
08:18:01 <hpc> @pl \x y -> x : y
08:18:01 <lambdabot> (:)
08:18:12 <ardu> hpc: what's @pl ?
08:18:29 <ardu> c_wraith: i understand, that makes sense. i guess my reason question is why there's no [,]
08:18:35 <ardu> my real question*
08:18:40 <c_wraith> ardu: because lists are nothing at all like tuples
08:19:02 <c_wraith> ardu: The only way in which they are similar at all is that they're data types
08:19:09 <hpc> ardu: it shows pointfree expressions that are equal to the provided expression
08:19:24 <ardu> hpc: oh nice
08:19:32 <c_wraith> ardu: They are defined differently.  They do different things.
08:19:46 <hpc> "pl" refers to a common joke that pointfree expressions are pointless
08:20:10 <ardu> c_wraith: okay, but why specifically would it not make sense for something like [,] to exist?
08:20:28 <c_wraith> ardu: basically, lists are a recursive data type.  The constructor for lists (that aren't empty) is (:)
08:20:31 <c_wraith> :t (:)
08:20:33 <lambdabot> a -> [a] -> [a]
08:20:46 <c_wraith> ardu: notice how it's recursive?  Its second argument has to be a list.
08:20:53 <ardu> yes
08:20:54 <c_wraith> ardu: there's nothing special about 2-element lists
08:21:21 <ardu> okay, i think i'm satisfied.
08:21:30 <merijn> hpc: That's not just a joke, pointless is an alternative, equally correct, name for pointfree
08:21:30 <c_wraith> ardu: unlike two-element pairs.  There is something special about them.  They're complete.  :)
08:21:30 <ardu> thanks a bunch everyone
08:22:13 <hpc> merijn: ah neat
08:22:13 <ardu> c_wraith: complete meaning?
08:22:46 <ongy> well, there's a somewhat working pulseaudio wrapper on hackage now. And I have to say, I really don't like their api
08:22:50 <c_wraith> ardu: I used it in a non-technical sense, meaning something like "The value is done.  You know there's nothing more"
08:23:04 <merijn> hpc: Which just makes jokes that much easier ;)
08:23:12 <saurabhnanda> does anyone here have the techempower benchmarking code installed on their machine?
08:23:25 <ardu> c_wraith: sorry, i'm not following what you mean
08:24:34 <hpc> ardu: you can just ignore it ;)
08:25:55 <ardu> well one thing that does annoy me (keep in mind i started learning haskell a few days ago) is that functions on lists and on tuples have diff syntax, e.g. i do "lst !! 0" but "fst tpl". so if there's a much deeper reason for this i'd like to know
08:26:47 <hpc> it comes down to types
08:26:49 <hpc> :t (!!)
08:26:50 <lambdabot> [a] -> Int -> a
08:26:51 <hpc> :t fst
08:26:53 <lambdabot> (a, b) -> a
08:27:18 <hpc> notice the types are completely different
08:27:23 <jonored> ardu: There is a deeper reason, yes: to have a !! on tuples, you'd need to have different return types depending on the /value/ of the index, which isn't even known when we're typechecking.
08:27:29 <ardu> but wouldn't it be possible for list and tuples to both be "subtypes" (i don't yet know what's the correct terminology in haskell for what i'm saying) of some broader type that defines !! ?
08:27:47 <merijn> ardu: Not really in any sensible way in Haskell
08:27:55 <ardu> jonored: oh, that makes sense. because tuples are not homogenous
08:27:59 <hpc> ardu: imagine you have a tuple (False, "True")
08:28:15 <hpc> ardu: imagine the type of (False, "True") !! 0, and now imagine the type of (False, "True") !! 1
08:28:27 <merijn> ardu: There's type systems that would allow such a thing, but those are substantially more complex than Haskell's
08:28:29 <hpc> ardu: what's the type of (!!)?
08:28:40 <ardu> hpc: yes i see now
08:28:45 <hpc> (!!) :: (a, b) -> Int -> mystery
08:29:11 <exio4> hpc: ‚àÄa,b.‚àÉr. (a,b) -> Int -> r :p
08:29:22 <ardu> merijn: like what?
08:29:36 <hpc> exio4: well if you're going to go that far, have it return a dependent product :P
08:29:47 <hpc> er, dependent sum
08:29:54 <merijn> ardu: Pretty sure you could write a function similar to that in a dependently typed language, such as, Agda, Coq, or Idris
08:29:54 <hpc> one of those two, it's been a while
08:30:00 <exio4> hpc: that would be actually useful!
08:30:08 <jonored> ardu: there's some template-ish stuff kicking around that'll let you actually write a number to index into a tuple, but it's likely not worth it (and if the tuple is getting that big, it might be time to define it as a record..)
08:30:37 <hpc> ardu: it's an easy thing to not notice coming from other languages, especially java
08:30:50 <hpc> ardu: where a tuple might be expressed as Object[2]
08:31:03 <hpc> and then you just never know which type is which
08:31:28 <ertes> exio4: that doesn't sound true though
08:31:48 <exio4> ertes: you mean ‚àÄa,b.‚àÉr. (a,b) -> Int -> r ?
08:31:51 <ardu> alright, i think i'm satisfied enough with the whole tuples vs lists thing (for now). let me get back to learning. thanks guys :)
08:31:57 <ertes> exio4: yeah
08:32:28 <merijn> ardu: Is the Report the first/only thing you're reading on Haskell?
08:32:56 <exio4> ertes: data Exists = forall r. Exists r ; (!!) (a,b) n = if n == 0 then Exists a else Exists b
08:33:23 <ertes> exio4: look at it as a logical statement
08:33:51 <ertes> exio4: "not true" in this sense means: you can't write that function
08:34:12 <exio4> ertes: indeed, I am thinking of it that way :)
08:34:54 <ertes> oh my, there is an ‚àÉ
08:35:15 <exio4> ertes: what about ‚àÄa,b,r. (a,b) -> Int -> (‚àÄe. -> e -> r) -> r ?
08:35:17 <ertes> ok, it's true, but also useless =)
08:35:29 <exio4> ‚àÄa,b,r. (a,b) -> Int -> (‚àÄe. e -> r) -> r ?
08:35:32 <exio4> ertes: on purpose, too! 
08:36:06 <ertes> exio4: i mistook the ‚àÉ for an ‚àÄ, sorry
08:36:17 <exio4> ah, heh
08:36:19 <merijn> ertes: o.O
08:36:26 <merijn> ertes: Sounds like you need a bigger/better font :p
08:36:59 <ardu> merijn: i read a few chapters of some popular online books, but then went on to the spec (somewhat strange i guess, but i like learning like that)
08:37:11 <ertes> merijn: or i should adjust my expectations‚Ä¶  i don't usually expect to see ‚àÉ around here =)
08:37:16 <hpc> they need to come up with an extended system of logic that has quantifiers for a 180-degree rotated I and O
08:37:33 <hpc> and U
08:37:35 <hpc> and sometimes Y
08:37:39 <ertes> merijn: (my font is already huge)
08:37:53 * hackagebot reroute 0.4.0.0 - abstract implementation of typed and untyped web routing  https://hackage.haskell.org/package/reroute-0.4.0.0 (AlexanderThiemann)
08:37:55 * hackagebot Spock-core 0.11.0.0 - Another Haskell web framework for rapid development  https://hackage.haskell.org/package/Spock-core-0.11.0.0 (AlexanderThiemann)
08:38:35 <merijn> ardu: tbh, you could do a lot worse than the spec :p It's one of the more readable ones, unlike the C or C++ ones :)
08:39:07 <ardu> merijn: yes i do like how some dificult points are explained in plain english even though they have already been specified unambiguously by the syntax
08:39:08 <merijn> ardu: I'm just curious what you're experience will be approaching it this way.
08:39:22 <dmj`> Stream should be Foldable
08:39:54 <ardu> merijn: i'm actually liking it so far. i think this channel is going to be a tremendous help for making up the gaps
08:40:05 <merijn> ardu: There's also the "Gentle Introduction"
08:40:24 <merijn> Which is...not so gentle :p (It was written for people who already know typed functional programming, like ML)
08:40:31 <hpc> does the gentle introduction still use a particularly sadistic... lol
08:40:41 <merijn> @quote Brend gentle
08:40:41 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
08:41:03 <ardu> merijn: mmhmm i've read a couple of chapters of that
08:41:16 <exio4> haha, I didn't know that quote!
08:41:18 <hpc> it seems like at the moment most of the community suggests starting with the CIS194 course materials
08:41:39 * hpc still hasn't given it a good read though
08:42:05 <dmj`> typeclassopedia is still best imo
08:42:07 <merijn> hpc: Or the Haskell Book, which 50% says is amazing and the other 50% says is trash
08:42:18 <merijn> I'm so conflicted! I don't know whether to recommend it now >.<
08:42:23 <exio4> I don't even know how I learnt the basics of Haskell :(
08:42:33 <merijn> exio4: Osmosis from here, like me ;)
08:42:54 * hackagebot Spock 0.11.0.0 - Another Haskell web framework for rapid development  https://hackage.haskell.org/package/Spock-0.11.0.0 (AlexanderThiemann)
08:42:56 * hackagebot Spock-api 0.11.0.0 - Another Haskell web framework for rapid development  https://hackage.haskell.org/package/Spock-api-0.11.0.0 (AlexanderThiemann)
08:42:58 * hackagebot Spock-api-server 0.11.0.0 - Another Haskell web framework for rapid development  https://hackage.haskell.org/package/Spock-api-server-0.11.0.0 (AlexanderThiemann)
08:43:00 * hackagebot Spock-api-ghcjs 0.11.0.0 - Another Haskell web framework for rapid development  https://hackage.haskell.org/package/Spock-api-ghcjs-0.11.0.0 (AlexanderThiemann)
08:43:01 <exio4> indeed, that's about 60% of it, I am wondering about the other 40% :P 
08:43:04 <hpc> merijn: yeah, my recommendations tend to float around "i like this one, but shop around until one of them works for you"
08:43:21 <hpc> almost all of them cover something that's not in the others
08:43:54 <hpc> or they do things in a different order, which might be a gentler progression of concepts for different people
08:50:26 <Gurkenglas> Perhaps an ML algorithm could produce an optimal sequence of lines said in #haskell to osmosis off of... nah.
08:50:53 <c_wraith> I learned a ton of haskell just watching this channel for a couple years.
08:50:57 <hpc> if "confluence" `isInfixOf` line then Optimal else Ignore
08:51:10 <c_wraith> Not even interacting, most of the time.  Just absorbing
09:11:29 <jgzh6> Exception Prelude.read No parse error http://lpaste.net/180301
09:12:11 <jgzh6> where should I put more {length list `seq`}..?
09:18:23 <cocreature> jgzh6: you won‚Äôt solve a "no parse error" with more seq
09:18:41 <cocreature> jgzh6: you can‚Äôt read functions
09:18:49 <jgzh6> hm..
09:18:59 <cocreature> oh sorry you‚Äôre not trying to do that
09:19:17 <cocreature> hard to tell why this fails without seeing the input
09:19:41 <cocreature> read is not really meant for parsing files
09:19:51 <cocreature> if you use one of the parser combinator libraries you‚Äôll get far better error messages
09:20:34 <jgzh6> parser combinator is a bit difficult for me
09:20:46 <cocreature> if you paste your input files on lpaste I can take a look
09:22:55 * hackagebot Spock-digestive 0.3.0.0 - Digestive functors support for Spock  https://hackage.haskell.org/package/Spock-digestive-0.3.0.0 (AlexanderThiemann)
09:22:58 <cocreature> jgzh6: also why are you calling length _ `seq` in the first place?
09:24:11 <jgzh6> my txt files http://lpaste.net/180305
09:25:31 <jgzh6> I just looked at some questions on Stackoverflow and just tried to put (length _ `seq`) everywhere without actually understanding anything
09:25:47 <cocreature> why are you dropping the first three chars of qs?
09:26:15 <cocreature> and where is lookupAll coming from?
09:26:27 <chokboy> hullo! last night (PST) i released my first hackage package (stochastic), and I was wondering if anyone would be kind enough (and interested enough) to give some honest feedback.
09:26:42 <jgzh6> This is my original file http://lpaste.net/180306
09:26:49 <jgzh6> source code
09:27:04 <cocreature> jgzh6: alright so why are you dropping the first three chars of these files?
09:27:19 <phadej> chokboy: I'd make StochProcess a `newtype`
09:27:43 <jgzh6> because the txt files are in UTF8 so it contains 3 unnecessary chars
09:27:51 <jgzh6> at the beginning
09:27:55 * hackagebot Spock-worker 0.3.1.0 - Background workers for Spock  https://hackage.haskell.org/package/Spock-worker-0.3.1.0 (AlexanderThiemann)
09:27:57 * hackagebot HDBC-mysql 0.6.6.2 - MySQL driver for HDBC  https://hackage.haskell.org/package/HDBC-mysql-0.6.6.2 (ryantm)
09:28:17 <phadej> jgzh6: bom? why you don't match it explicitly
09:28:26 <phadej> bom might be, or might be not there.
09:28:31 <phadej> more than often it's not there
09:28:48 <jgzh6> what is bom..?
09:28:58 <cocreature> byte order mark
09:28:58 <hpc> byte order mark
09:28:59 <jgzh6> I'm a complete noob..
09:29:04 <jgzh6> aha
09:29:08 <hpc> it's a unicode thing, you should look it up
09:29:25 <chokboy> phadej: right, gotcha.
09:29:30 <hpc> it's pretty hacky ;)
09:31:25 <cocreature> jgzh6: so one error is that the elements in the resultlist of lookupAll can be " " and you are trying to parse that as a double
09:31:45 <jgzh6> right...
09:32:56 <jgzh6> It's convenient to have " " than a Nothing as I'm copying and pasting the results to a spreadsheet.
09:35:04 <cocreature> well regardless of that it‚Äôs not a valid double so that will fail :)
09:35:22 <cocreature> apart from that and the fact that just dropping 3 characters in all cases is pretty hacky I don‚Äôt see anything obvious
09:35:37 <cocreature> but I really recommend to look into parser combinators
09:35:42 <cocreature> they are quite easy to use
09:35:45 <jgzh6> hm..
09:36:17 <jgzh6> I'm actually reading a parser combinator chapter in a book but got stuck
09:36:27 <cocreature> which book are you reading?
09:36:34 <jgzh6> haskellbook
09:37:13 <jgzh6> Haven't done any exercises though. Just reading the explanation part
09:37:32 <jgzh6> as I feel pressurised for time
09:37:58 <cocreature> how so?
09:38:40 <jgzh6> um.. the book is pretty thick and I want to make progress quickly
09:38:49 <jgzh6> so I am skipping all the exercises
09:39:03 <cocreature> skipping exercises is not exactly a good way to learn
09:39:06 <monochrom> you get what you spend time for.
09:39:36 <jgzh6> but it will take ages if I go through all the exercises.
09:39:51 <jgzh6> Instead, I'm just trying to build some stuff that's useful for my work
09:40:14 <monochrom> Learning objective: At the end of just reading quickly and skipping exercises, you will be able to: Write great essays that would earn impressive A+'s from essay teachers; Completely screw up on actual code.
09:40:28 <monochrom> (In other words, you will be full of it.)
09:41:48 <jgzh6> The book doesn't contain any answers or solutions. So I'll have to struggle even more if I got stuck on a exercise
09:41:55 <monochrom> Do you know why? It is because without going through the painful failures in the exercises, you won't know that you got all the wrong messages, you will think you're so right. Cf Dunning-Kruger effect.
09:42:36 <jgzh6> hm..
09:43:26 <monochrom> And I say that, not hypothetically, but actually empirically I have seen people who behave exactly as that.
09:43:36 <cocreature> you don‚Äôt have to do all the exercises but if you feel like you are struggling then just skipping them doesn‚Äôt help you learn anything
09:44:11 <monochrom> They write very wrong code, and then they write a great essay to explain why their code should make sense. The code doesn't even type-check.
09:46:01 <chokboy> phadej: made it a newtype. I'll upload a changed version to hackage. Anything else?
09:46:15 <jgzh6> I noticed I even forget/don't understand some codes I myself wrote a while ago. So, even if I go through some of the exercises in the book, I'll probably forget how to solve them by the time I finish the book.
09:46:22 <chokboy> I'll upload a changed version to hackage tonight, after some more changes actually
09:46:43 <monochrom> Yes, but you will knock off more wrong concepts.
09:46:47 <ertes> jgzh6: there is a simple solution to that: work on a project
09:47:23 <ertes> jgzh6: personally i don't object to the idea of *not* following a linear learning path, but picking up information as you need it
09:47:57 <monochrom> You wrote, and tested, much C code when you were 10, and today you don't even recognize that code. Sure.
09:48:43 <monochrom> But because of that past experience, you have retained one message: "int a[10]" and "int *a" are still different.
09:48:48 <monochrom> For example.
09:49:22 <jgzh6> I guess I'm trying to make an excuse to avoid pain
09:49:46 <earldouglas> Koterpillar: (continued from yesterday) You were right, it was Eff (Freer).
09:50:13 <monochrom> Oh, then what you need is one of those religious or philosophical advice that says: change perspective, it does not have to be interpreted as pain... :)
09:50:44 <ertes> jgzh6: do you really view failure as pain?  remember that failure is a temporary state, usually followed by success, a permanent state
09:50:51 <monochrom> (Actually, when I failed an exercise, I didn't feel pain, I felt the Vulcan kind of "fascinating".)
09:51:10 <ertes> jgzh6: more importantly failure is *important* for learning‚Ä¶  the best way to learn is to fail
09:51:23 <johnw> well, to fail and reflect
09:51:48 <johnw> I'd say "failure provides some of the best opportunities to advance learning"
09:52:37 <monochrom> In fact I have the scientist inclination. I actively seek failure. I.e., when I think up a hypothesis, I try very hard to invent an experiment that refutes it.
09:53:37 <jgzh6> I found doing exercises in haskell is actually quite fun compared with other languages  
09:53:48 <jgzh6> But still I shouldn't be lazy..
09:53:59 <maerwald> well, failure is rather neutral, the problem is when learning causes frustration, which is a negative feeling and can cause irrational association, where people move away from learning itself, because they are afraid to experience frustration again
09:54:27 <monochrom> I think the frustration is tied to expectation.
09:54:34 <ertes> jgzh6: i found the best weapon against laziness is doing *interesting* stuff‚Ä¶  that's why i suggest working on a project you're interested in
09:54:41 <maerwald> I think it is tied to wrong teaching/learning methods
09:54:48 <monochrom> If you give yourself a deadline, for example, you will feel pain.
09:54:58 <jgzh6> right..
09:55:17 <jgzh6> need to cope with frustration..
09:55:20 <maerwald> but yeah, if you experience frustration, don't try harder, question your methods
09:55:33 <monochrom> I know because I faced all kinds of deadlines when I taught a course and had to prepare for lectures and create homework questions etc.
09:56:29 <monochrom> And there was also once when I had to do similar things but the deadlines didn't really matter, and that was much more fun.
09:57:05 <monochrom> As a scientist I conclude that deadlines and expectations and pressure, not the process, is the cause of pain frustration etc.
09:57:17 <ertes> jgzh6: there is also an important question i feel you should ask yourself repeatedly
09:57:19 <monochrom> You remove the deadline, suddenly the pain disappears.
09:57:25 <ertes> "why am i going on?"
09:57:29 <jgzh6> I want to build a scraper and use cassava, persistence, etc.
09:57:30 <maerwald> it can be more than that, it's methods in general
09:57:36 <ertes> in other words: why are you learning haskell?  what do you want to do with it?
09:58:23 <ertes> jgzh6: now that sounds like a specific project you're interested in‚Ä¶  note that the project is "scraper", not "scraper using cassava, persistent, etc."
09:58:25 <jgzh6> but to understand and use those libraries, I must build the foundation first
09:58:57 <ertes> jgzh6: learn to parse a CSV file with cassava now
09:59:04 <ertes> then learn to write a CSV file
09:59:28 <ertes> it's part of an *interesting project*
10:01:05 <jgzh6> That means I have to choose between making a progress with the book or build a project.
10:01:49 <ertes> jgzh6: not really‚Ä¶  you can always pick up the book where you left it
10:02:19 <MarLinn> Warning: I must say I used cassava and was disappointed by its fragility and lack of useful feedback. But I heard the conduit version of a csv library might not be too bad, so I'm going to try that next time.
10:02:21 <ertes> the choice is in your head‚Ä¶  the book doesn't get upset and run away =)
10:02:40 <ertes> neither does your project
10:02:40 <jgzh6> haha
10:02:48 <jgzh6> right
10:03:10 <monochrom> I don't find cassava fragile.
10:03:23 <ertes> MarLinn: me neither‚Ä¶  i've used it a few times successfully
10:04:01 <MarLinn> I mean "fragile" in the sense that it fails without any indication why
10:04:05 <jgzh6> I feel it's necessary to understand at least Monad transformer and parser combinator to build a useful project.
10:04:18 <ertes> jgzh6: you're wrong
10:04:22 <jgzh6> really..?
10:04:26 <monochrom> OK yes its error messages seem poor.
10:04:26 <ertes> jgzh6: yes
10:04:33 <monochrom> s/poor/unspecific/
10:04:53 <Gurkenglas> Atom needs the ghc-mod version that is built with the same ghc version that my project uses. If I put ghc-mod into my .cabal file, then that works, but that .cabal modification would be added to any PRs I submit from that fork. Is there another way, or a way to tell it to ignore that modification to the .cabal?
10:05:40 <jgzh6> Because I sort of understand almost everything before those two part in the book
10:05:41 <Sonolin> not sure about cabal/Atom, but to ignore a file in git try:
10:05:44 <Sonolin> git update-index --assume-unchanged FILENAME
10:05:51 <monochrom> My use case is probably very different from yours. My case doesn't need good error messages. My input files are all cool. They come from unerroneous sources.
10:05:55 <jgzh6> But still can't build a useful code
10:06:45 <MarLinn> jgzh6: if you use a library like cassava, you don't need to understand parsers. And you can always replace monad transformers by manually stacked monads.
10:07:13 <ertes> jgzh6: i'm not familiar with the book's chapter layout, but i'm pretty sure you can put it aside now and write code
10:07:32 <et09> http://hl7-definition.caristix.com:9010/HL7%20v2.3.1/segment/Default.aspx?version=HL7+v2.3.1&segment=PR1 so, see this page?  notice that in every column where GROUP = Y, it indents an extra 12 pixels in the style attr for the "NAME" column.  i'm able to parse this in ruby basically iterating through and marking the indentation via a separate function that pulls it out, but how would you model that in 
10:07:38 <et09> haskell ?
10:07:39 <jgzh6> I still have some difficulty especially in recursion
10:07:59 <monochrom> To use cassava you need Functor and Applicative. Possibly Monad but depends on how you use it, likely you don't need Monad.
10:08:03 <et09> it's a stateful mechanism i'm using to solve that and can't imagine an FP solution
10:08:36 <jgzh6> Recursion and folds are very difficult for me
10:08:41 <monochrom> You also need type classes and instances.
10:08:44 <et09> well, at least not without costly "reverse lookups"
10:09:47 <ertes> jgzh6: that's probably because you skipped the exercises thinking that you understood, but maybe you misjudge your true level of understanding
10:10:15 <Gurkenglas> et09, you meant to paste that page? https://gyazo.com/839dad4b6921c6396776a8a8c95ffe6e
10:10:41 <jgzh6> True. I'll have to do some exercises in those areas.
10:10:59 <jgzh6> Time to go home. Thank you all for very nice advice
10:11:00 <ertes> jgzh6: you know the number one way we teach people how state monads work?  we let them implement them on their own
10:11:38 <Cale> et09: uh, I don't see what it is that you're referring to, but based on the description alone, that sounds like something you ought to be able to do with a pure function.
10:11:39 <ertes> write code, fail, understand why you failed, reiterate, do that a few times, succeed
10:11:50 <whittle> GHC is telling me that something "is a type function, and may not be injective". Where should I start my research into how to fix this type error? 
10:12:03 <monochrom> no. write code, fail, understand why, recurse.
10:12:03 <Cale> et09: But maybe I'm misunderstanding what it is that's going on, since I don't see the picture.
10:12:04 <jgzh6> ok. I think the book uses the similar method
10:12:56 <Cale> et09: If all else fails, you can always transcribe an effect-free imperative computation into a functional one which turns each point of control in the imperative algorithm into a function, and the values of mutable variables in scope into function parameters
10:12:56 <jgzh6> without an instructor or a mentor, it's pretty hard I think..
10:13:19 <Cale> et09: You then have each function apply the next one in turn to the new values of any mutable variables (according to whatever got updated)
10:13:44 <jgzh6> anyway, I'll reconnect when I get back home. Thanks again for reviving my motivation.
10:13:46 <whittle> Cale: That sounds exactly the first couple chapters of SICP. 
10:13:51 <Cale> This initially will result in a messy program, but it's a messy program consisting of *equations*, which you can immediately begin to simplify.
10:14:20 <Cale> whittle: hah, yes
10:14:48 <ertes> speaking of recursion‚Ä¶
10:15:14 <Cale> Anyway, usually there's a more direct way to get to an answer for how to write your program, but if you know an imperative solution and you're stuck, it's always something you can do.
10:16:28 <chsn> anyone here editing haskell in Yi ?
10:17:45 <Cale> et09: Having clicked around on the dropdowns a bit, I found picking NMD_N02 from the first dropdown contains an example of what you're talking about
10:18:04 <Cale> Gurkenglas might like to know that as well ^^
10:18:47 <Cale> One thing I've used in cases like this in the past is a slight abuse of groupBy
10:22:39 <Cale> > groupBy (\u v -> fst u == "Y" && fst v /= "Y") [("Y", 1), ("", 1.1), ("Y", 2), ("", 2.1), ("", 2.2), ("Y", 3)]
10:22:42 <lambdabot>  [[("Y",1.0),("",1.1)],[("Y",2.0),("",2.1),("",2.2)],[("Y",3.0)]]
10:23:56 <lpaste> whittle pasted ‚ÄúType error‚Äù at http://lpaste.net/180312
10:23:59 <Cale> However, it appears that in this case, there can be multiple levels, and I'm not sure how to distinguish them from the data here.
10:25:14 <Cale> whittle: It's very unlikely that you want that forall in your data declaration
10:25:42 <Cale> Well, hmm...
10:25:59 <Cale> oh!
10:26:07 <whittle> Cale: I don‚Äôt want the App type parameterized on a. 
10:26:26 <whittle> I just want a function shaped like that available throughout the app. 
10:26:29 <Cale> I see, you really are putting in what ought to be a polymorphic argument as well
10:28:06 <Cale> oh
10:28:12 <Cale> I see
10:28:18 <Cale> Yes, this type error is correct
10:28:44 <Cale> You're trying to return the result that's passed in
10:28:54 <Cale> But that's not necessarily the same 'a'
10:29:05 <Cale> The user of withStripeExpecting might choose a = Integer
10:29:24 <Cale> and pass in a StripeRequest Integer, and an Either StripeError (StripeReturn Integer)
10:29:42 <Cale> but then mock still needs to be a polymorphic function
10:30:08 <Cale> So it can't produce the  Either StripeError (StripeReturn Integer)  that the user passed in
10:31:05 <Cale> It's got to be possible to pass it some  StripeRequest String  and obtain an  IO (Either StripeError (StripeReturn String))  still.
10:31:14 <Cale> Right?
10:31:50 <Cale> So even though your type signature for mock says that it's polymorphic, the implementation is not really, because it's using something whose type was determined in an outer scope.
10:32:03 <whittle> Cale: Given actualReq and expectedReq, I was hoping there was some sort of coersion mechanism that I could use on res. 
10:33:00 <whittle> Since withStripeExpecting is part of the test suite, I‚Äôm totally fine with a run-time error if the two type variables turn out not to match. 
10:34:13 <Cale> whittle: hm... you could unsafeCoerce, maybe.
10:34:24 <whittle> Cale: Also, I want to say that it‚Äôs remarkable how fast you got there. I got to the same place, but it took hours. 
10:34:28 <Cale> But that seems really dangerous in the presence of a type function.
10:35:17 <Cale> Well, I've been programming in Haskell for about 15 years now, I've seen things like this before :)
10:36:35 <Cale> So is it guaranteed that this thing is only going to use the appStripe function at the single type that you're trying to implement it at?
10:37:34 <Cale> It's really unclear to me that it's certain not to attempt to use appStripe at some other type in some intermediate way.
10:38:40 <Cale> Maybe we could make this a little safer with Typeable constraints, so we'd at least have runtime type information to compare
10:39:10 <whittle> Cale: Sadly, no, there is no such guarantee. 
10:39:25 <whittle> Also, the compiler is quite right that StripeReturn is not injective. 
10:40:07 <dmj`> whittle: hm, you're trying to mock stripe requests here?
10:40:16 <whittle> dmj`: Yes. 
10:40:49 <Cale> Well, you *do* know that there's a FromJSON instance
10:41:17 <Cale> So one thing you could do is just produce fromJSON of something, and if it's not the type you wanted, then you'll get a parse error.
10:41:24 <whittle> Cale: What I was thinking was to create a run-time check that the two StripeRequests were in agreement, then use that fact to justify returning a StripeReturn that matched. 
10:41:48 <whittle> Cale: Ah! Excellent point! 
10:41:49 <Cale> Yeah, in order to do that check, you'll need something like Typeable a
10:42:28 <Cale> (Or else StripeRequest will need to be a GADT or something, which it's not)
10:42:33 * geekosaur tries to remember if closed type families can be injective yet
10:43:07 <Cale> geekosaur: That's kind of the point of their existence isn't it? One would hope...
10:44:13 <geekosaur> yes but iirc they were only partially implemented as such initially or something
10:44:22 <whittle> Cale: My understanding is that the type variable in StripeRequest is a phantom type used to guarantee that the StripeReturn is appropriate for the StripeRequest. 
10:44:24 <geekosaur> that is there were some cases where it'd complain stull
10:44:28 <dapplefuz> i woud like to assert at compile time that `Map ((:+$$) 1) '[1,2,3]` is equal to `'[2,3,4]` .. since these have kind [GHC.TypeLits.Nat], I cannot "proxy" them and pass them into a function `a -> a -> ()` to assert equality.. is there a type family or typeclass way to do this?
10:44:30 <Cale> whittle: Yeah
10:44:41 <geekosaur> meh, I need to wake up fully before thinking about this stuff :/
10:45:44 <dolio> More comprehensive injectivity stuff is implemented in 8.0.
10:45:46 <Cale> whittle: If StripeRequest were a much more complicated type, a GADT, with data constructors for all the possible requests, then its type parameter could depend on the data constructor in a way that would let you recover the type index when you pattern matched one of the constructors.
10:46:31 <dapplefuz> so far, i've been poking at `Data.Type.Equality.(:~:)`, but haven't learned how to use it.
10:47:25 <Cale> dapplefuz: The idea with that is that something can take an argument of type (a :~: b) and by pattern matching on Refl, you "learn" that a and b are the same type after all.
10:49:12 <MarLinn> Please excuse my naiive question, but why does a simple ~ not do the job?
10:49:47 <Cale> MarLinn: It often would...
10:50:31 <Cale> Are you familiar with the Dict type?  a :~: b  is similar to  Dict (a ~ b)
10:50:44 <whittle> MarLinn: I have seen this ~ of which you speak before. Does it have a name by which I could Google it and discover more? 
10:50:52 <Cale> Type equality
10:51:01 <Cale> Or look for "Type equality constraint"
10:51:26 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#equality-constraints
10:51:52 <whittle> Cale: Thank you. 
10:52:18 <Cale> whittle: if you have a GADT like...
10:52:24 <Cale> data Expr a where
10:52:32 <Cale>   Lit :: Integer -> Lit Integer
10:52:44 <Cale> oops
10:52:48 <Cale>   Lit :: Integer -> Expr Integer
10:53:02 <Cale>   IsZero :: Expr Integer -> Expr Bool
10:53:19 <Cale>   IfThenElse :: Expr Bool -> Expr a -> Expr a -> Expr a
10:54:15 <Cale> This can be rewritten a bit in terms of type equality constraints
10:54:33 <Cale> So, for example,  Lit :: (a ~ Integer) => Integer -> Lit a
10:55:32 <Cale> ugh, keep making that error :)
10:56:08 <Cale> Anyway, you get the idea, it's possible to pull out the type constants into equality constraints, and get the type back into a form where the constructors produce something of type Expr a
10:56:41 <Cale> IsZero :: (t ~ Integer, a ~ Bool) => Expr t -> Expr a
10:56:48 <whittle> Cale: I see. That makes sense. 
10:57:04 <MarLinn> Cale: And then you can make the underlying dictionary more explicit with the Dict wrapper so you can "manipulate" it if I understand correctly?
10:57:07 <Cale> yeah
10:57:22 <dapplefuz> Cale: ok, i think you've explained how to use it adequately .. thanks!
10:57:26 <dapplefuz> i've gotten this far: http://lpaste.net/180326
10:57:27 <Cale> It turns it into a value that you can pass around explicitly
10:57:35 <dapplefuz> which is farther than anything else i've been able to get
10:58:17 <Cale> Rather than having to resort to funny "continuation passing" operations like ((a ~ b) => r) -> r
10:59:17 <whittle> dapplefuz: Whoo! That‚Äôs some heady stuff. 
10:59:55 <dapplefuz> whittle: i've been in out of this channel all week trying to get to this point. i think i can take a break now! hah.
10:59:59 <dapplefuz> thanks Cale 
11:00:10 <Cale> No problem, glad that I somehow managed to help :)
11:00:18 <dapplefuz> next step is to implement maps..
11:01:10 <dapplefuz> i'll dip back into https://hackage.haskell.org/package/type-level-sets but i think its `Map` type isn't properly promoted, and can't do pure type-level maps (despite what it says on the tin)
11:01:30 <MarLinn> That sounds great. I have stumbled upon Dicts in the past but it never really "clicked". Maybe I can understand some more of some of the libraries now. Yay!
11:01:57 <et09> oh, sorry - the URLs on that site don't always update when you switch page
11:02:48 <MarLinn> dapplefuz: I _think_ - but don't quote me on that - that the maps from there can be fully on the type level, but you can always get both levels at the same time
11:02:59 * hackagebot bookkeeper 0.2.2.0 - Anonymous records and overloaded labels  https://hackage.haskell.org/package/bookkeeper-0.2.2.0 (jkarni)
11:03:28 <et09> Cale: you mean you basically run through it recursively and modify the (tail recursive?) call whenever the indentation changes?
11:03:47 <Cale> et09: Yeah, that's an option
11:04:14 <et09> i guess you can probably also use state monad or something right (although that prob defeats the purpose)
11:04:37 <dapplefuz> MarLinn: i'll take another stab at it, then.. i need to put type lit symbols into the value part of `:->`, but i think it's not polykinded, so it hasn't worked for me so far
11:04:41 <Cale> et09: There's probably something nicer than that... which I'd explain how to do, except that I don't really understand the layout of your data well enough to distinguish between the case where a Y just starts a new level, and the case where it also closes the previous indentation block
11:05:09 <MarLinn> dapplefuz:  I tried using that thing but my problem was that many basic operators are missing so you have to manipulate the underlying list manually anyway
11:05:26 <Cale> et09: Oh, is that what the * in the RPT/# is doing?
11:05:28 <et09> there's nothing that indicates the closing of an indentation block besides an indentation receding.  i actually did my ruby code so that it'll compare the levels of indentation (it goes 6, 18, 30, 42...)
11:05:50 <et09> uh, maybe, but the GROUP = Y is the for-sure one
11:06:00 <et09> i think RPT is for field repetitions, which is different
11:06:12 <Cale> et09: I mean, in the case of NMD_N02, it seems like there are three separate indentation levels
11:06:45 <Cale> and I'm sure you couldn't tell that just looking at the group column alone
11:06:50 <et09> yeah, in segments (as opposed to other types of data shown here), RPT is different than GROUP
11:07:03 <et09> RPT just means anything is repeatable.  i think a group is almost always repeatable, but not always
11:07:46 <Cale> et09: Like, how do we know that the line with "-- CLOCK" is not on the same level as the line before it?
11:08:03 <et09> it has td style="padding-left:18px;"
11:08:08 <Cale> et09: are groups not allowed to be nonempty?
11:08:17 <et09> groups have to have something in them 
11:08:18 <whittle> Is there any way to derive orphan instances of Typeable? I‚Äôd like to equip the phantom types in the Stripe library with Typeable instances without forking the library. 
11:08:25 <Cale> er, sorry
11:08:29 <Cale> Yeah
11:08:37 <MarLinn> et09: for more general stuff you could try the scanl family of functions. That would give you the option to transport a "state"
11:08:47 <dmj`> whittle: StandaloneDeriving
11:08:52 <Cale> et09: and that's the only way we know that things are nested more deeply then, okay
11:09:18 <whittle> dmj`: Thank you. 
11:09:19 <dapplefuz> MarLinn: ah, i take it back.. `:->` is in a module with datakinds an polykinds, so i should be able to put type lits into it.. it looks like the module also has `Lookup`, `Member`, and `Ext` (insert) .. should be sufficient for my purposes!
11:09:55 <dapplefuz> MarLinn: thanks for the cautious encouragement. :) i'll report back when i've gotten somewhere (or nowhere!)
11:10:29 <MarLinn> dapplefuz: Good luck! ;)
11:12:45 <Cale> et09: So we need to distinguish the case when we find that the first thing a group contains is another group, because that's the only way we ever get deeper grouping, right?
11:13:07 <Cale> et09: Or is there some other indication?
11:15:01 <athan> Would you ever want a strict Maybe?
11:15:42 <athan> I realize you can't have it UNPACKED and stuff, because of the type variable, but do people often make their own MaybeFoo types to dodge this?
11:15:44 <Cale> athan: It doesn't tend to be so important. Sometimes you want to force the thing you're applying Just to, but you can just... do that.
11:15:47 <monochrom> sometimes I do, but I can easily cope without. I just have to add my "seq" elsewhere.
11:15:56 <et09> the actual data output is basically: groups: {"uuid1": {indent: n, name: (the group name minus -- ) }, "uuid2": [...] }     and then also   values: {"1": {optional: true, repeat: false, groups: [], name: "MSH - Message Header Segment", segment: "MSH"} ... }
11:16:10 <jgzh6> how can I substitute (drop 3) when reading a utf8 txt file content to get rid of boms?
11:16:29 <athan> right on, thanks Cale & monochrom!
11:16:33 <et09> it files the group info into a second column , not recording them as "values" 
11:16:41 <et09> a second json structure i should say
11:17:14 <monochrom> you just have to say "drop 3 xxx" don't you?
11:17:26 <ertes> jgzh6: read as Text‚Ä¶  if the BOM thing is actually there, it should be just a character that you can remove
11:17:31 <Cale> et09: Oh, maybe I'm misunderstanding something -- are you considering the fact that the indentation is already there, and forming a tree structure using it, or do you have flat data and you want to determine the indentation, or is it something else entirely? :)
11:17:37 <Gurkenglas> If this project is written using an old ghc version, and the ghc on my path is new, can I build ghc-mod using the new version and everything will work? ie is ghc-mod backwards compatible?
11:17:59 <ertes> jgzh6: if that's not the case, check your user's locale settings
11:18:21 <athan> Does anyone know of a collection of benchmarks for competing container implementations, like Data.Set vs. Data.HashSet for different varying sizes of data?
11:18:23 <jgzh6> right. thanks.
11:18:35 <Gurkenglas> *is ghc backwards compatible is what i wanted to say
11:18:48 <monochrom> ertes: I have a program that uses cassava (so, bytestring input) and faces the BOM in input, so I actually have to drop 3 bytes rather than one Char :)
11:19:25 <ertes> monochrom: i'd probably use utf8-string in that case, just to be safe =)
11:19:37 <Gurkenglas> Alternatively, how do I make atom's ide-haskell's "haskell-ghc-mod" use the ghc that stack uses to build my project, rather than the one on my path?
11:19:38 <ertes> i have a bad feeling about drop-3-ing a single character
11:19:57 <Cale> jgzh6: Perhaps write a function which looks for '\xffef' at the start of the Text and deletes it if there.
11:20:19 <monochrom> Don't worry, I check those 3 bytes first.
11:20:26 <jgzh6> sounds good
11:20:41 <et09> it's flat data + indentation, and also trying to preserve the metadata about the groups the indentation notates
11:20:44 <glguy> jgzh6: Be careful unconditionally dropping the BOM since most UTF-8 content won't have one
11:20:47 <et09> denots * 
11:20:52 <et09> denotes ****
11:21:13 <jgzh6> ok thanks
11:21:50 <hiptobecubic> I think I've only ever seen the BOM in data coming from Microsoft's api
11:22:12 <MarLinn> Isn't a BOM in utf8 discouraged? I mean, sure, be liberal in what you accept, but still... 
11:22:24 <monochrom> yes
11:22:34 <monochrom> Only Microsoft people do it.
11:23:22 <et09> on the first day, god said, let there be light.  and then microsoft said, actually, let's modify that spec 
11:24:11 <hpc> on the third day, god said "developers developers developers developers"
11:24:17 <Cale> It might actually be useful to produce a function which reads the BOM and decodes Text according to what it finds (and chooses UTF8 if none is found)
11:25:18 <dominik> Hi there, I've recently playing with implementing Dynamic Programming problems in Haskell.
11:25:27 <dominik> Most recently, implementing Bitonic Tours.
11:25:56 <dominik> my current approach is here: http://lpaste.net/180330
11:26:59 <Gurkenglas> One project complains if ghc 8.0.1 isnt the one on the path and the other complains if ghc 7.10.3 isnt the one on the path :(
11:27:02 <ertes> on the second day bill gates said: (LPCSTR) "letÔøΩs be as incompatible to everybody else as we can!"
11:27:06 <whittle> dmj`: By any chance are you David Johnson, the principle author of https://github.com/dmjio/stripe? 
11:27:15 <dmj`> whittle: yea
11:27:27 <whittle> dmj`: Thank you so much. It‚Äôs a terrific library. 
11:27:52 <dominik> however, somehow running `bitonicPath tour1` results in a StackOverflow and I cannot figure out why
11:27:53 <whittle> I‚Äôm patterning a client lib I‚Äôm writing after it, as it‚Äôs such an excellent example. 
11:28:00 * hackagebot language-lua 0.10.0 - Lua parser and pretty-printer  https://hackage.haskell.org/package/language-lua-0.10.0 (EricMertens)
11:28:10 <dominik> if anyone sees the problem, I would very much like to hear it :-)
11:28:20 <glguy> ertes: What's going on with your apostrophe?
11:28:22 <dmj`> whittle: glad you like it, stepcut played a large role in its creation as well :)
11:28:42 <ertes> glguy: that's an intentional UFFFD
11:28:46 <Gurkenglas> dominik, `bitonicTour tour1`, right?
11:28:51 <ertes> glguy: part of the joke =)
11:28:51 <dominik> Gurkenglas: yes
11:29:02 <glguy> OK, i get it now :)
11:29:17 <dominik> Gurkenglas: I've tried to debug it with Debug.Trace
11:29:23 <dominik> and it halts immediately
11:29:39 <dominik> after going just 4 steps into the recursion inside `bitonicPath`
11:29:45 <Cale> dominik: What's the last trace?
11:29:59 <Cale> Is it step case #2?
11:30:09 <dominik> Cale: no its the base case
11:30:13 <whittle> dmj`: I‚Äôll be sure to thank stepcut too, the next time I see him here. 
11:30:37 <whittle> dmj`: I don‚Äôt suppose you have any wisdom to impart on the subject of mocking Stripe calls? 
11:30:55 <Gurkenglas> Hmm. Is there a law that <= be antisymmetric?
11:31:29 <dominik> and well, I'm wondering why after just so few steps into the recursion it already blows up my memory
11:31:46 <Cale> dominik: I asked that because foldr1 selectMin looks like something which could cause a stack overflow on its own, given that selectMin is strict and the list which you're applying it to might be long.
11:31:50 <cocreature> Gurkenglas: Ord doesn‚Äôt have any laws so no
11:31:57 <dmj`> whittle: if we port stripe to servant, we could instantiate a web server from it, and use Arbitrary intances for the types. Then servant-mock could deliver dummy data and act like an actual stripe server
11:32:46 <whittle> dmj`: If you were writing the library today, is that how you would do it? 
11:33:20 <dmj`> whittle: servant-client and ghc8 since the record field names could be shared. Types.hs takes like 8 seconds to compile
11:33:23 <dominik> Cale: interestingly, I'm getting a Stack Overflow even for lists with just 4 input points
11:33:37 <Cale> dominik: Oh, then possibly there's an infinite loop :)
11:33:40 <dominik> (e.g. `tour1` from the snippet -- you might want to refresh the screen
11:33:55 <dominik> yea, might be :D
11:34:21 <Gurkenglas> dominik, ever tried the ghci debugger? (Load your code in ghci, do :set -fbreak-on-exception, then :trace bitonicTour tour1, then :back, then :list
11:34:26 <dmj`> whittle: this would let people share types w/ ghcjs too, w/o separate packages being required. servant-client supports BasicAuth too now
11:36:40 <dmj`> whittle: oh and Generic json instances :) 
11:37:07 <whittle> dmj`: Interesting. Thank you for the insight. 
11:37:42 <dmj`> whittle: PRs always welcome ;)
11:38:54 <whittle> dmj`: Once I feel competent to contribue, I may send some. 
11:39:04 <whittle> s/contribue/contribute/
11:41:06 <dominik> Gurkenglas: Thanks! I'm running it currently. But it takes much longer to get to the stack overflow...
11:48:01 * hackagebot ginger 0.3.2.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.3.2.0 (TobiasDammers)
11:48:45 <hc> hi, can someone help me fixing this error:
11:48:47 <hc>     Couldn't match type ‚Äòa‚Äô with ‚ÄòDynamic‚Äô
11:48:49 <hc>       ‚Äòa‚Äô is a rigid type variable bound by
11:49:57 <Cale> dominik: hm, so every one of the recursive calls to bitonicPath turns out to be okay, it's the *first* one which is being problematic
11:50:01 <hc> the function definition is like this: doSomething :: (Get a -> IO a) [...] doSomething getter = getter[...]
11:50:26 <jle`> hc: you are probably using Dynamic where GHC is expecting something polymorphic
11:50:27 <geekosaur> @paste
11:50:27 <lambdabot> Haskell pastebin: http://lpaste.net/
11:50:35 <Cale> dominik: Oh, and of course, look at what happens...
11:50:38 <c_wraith> hc, your type signature promised you'd return a value of any type the caller wants. but you're returning a Dynamic, regardless of what the caller requests 
11:50:41 <jle`> :t let foo :: a -> a; foo True = False
11:50:42 <lambdabot> <no location info>: error:
11:50:43 <lambdabot>     not an expression: ‚Äòlet foo :: a -> a; foo True = False‚Äô
11:50:52 <jle`> :t let foo :: a -> a; foo True = False in foo
11:50:54 <lambdabot> error:
11:50:54 <lambdabot>     ‚Ä¢ Couldn't match expected type ‚Äòa1‚Äô with actual type ‚ÄòBool‚Äô
11:50:54 <lambdabot>       ‚Äòa1‚Äô is a rigid type variable bound by
11:50:56 <Cale> dominik: no wait, hmm...
11:51:04 <geekosaur> but usually that means you've assumed somewhere that if you have a type signature mentioning a type variable, you get to choose the type. but in fact the caller chooses the type; you must live with it
11:53:59 <Cale> oh!
11:54:03 <Cale> It's pathCosts
11:54:32 <lpaste> hc pasted ‚Äútype_problem_excerpt.hs‚Äù at http://lpaste.net/180340
11:54:46 <hc> here's the relevant code excerpt ^^^
11:54:49 <Cale> dominik: pathCosts $ BitonicPath {graph = Graph {vertices = Set.fromList [Point {pX = 1, pY = 0},Point {pX = 2, pY = -1},Point {pX = 3, pY = 1},Point {pX = 4, pY = 0}], edges = Map.fromList [(Point {pX = 1, pY = 0},Point {pX = 2, pY = -1}),(Point {pX = 2, pY = -1},Point {pX = 1, pY = 0}),(Point {pX = 3, pY = 1},Point {pX = 2, pY = -1}),(Point {pX = 4, pY = 0},Point {pX = 1, pY = 0})]}, from = Point {pX = 3, pY = 1}, 
11:54:50 <Cale> to = Point {pX = 4, pY = 0}}
11:54:59 <Cale> dominik: infinite loop :)
11:57:48 <Cale> dominik: (3,1) -> (2,-1) -> (1,0) -> (2,-1)
11:57:57 <Cale> -> ... nontermination
11:58:14 <hc> basically inchannel is any means of supplying data from the world... maybe i need to instead define a typeclass for the inchannel>
12:00:12 <jle`> trying to remember why i have a data type called SnapMap
12:00:54 <jle`> hc: perhaps did you mean (forall a. Get a -> IO a) ?
12:01:05 <jle`> the forall there is the same as putting the forall at the top of the signature
12:01:10 <jle`> as you have it now
12:02:25 <hc> Yup, thanks a lot, that did it :)
12:02:29 <jle`> putting the forall in the parentheses would resolve the error, and there are a bunch of `(forall a. Get a -> IO a)` in the binary package
12:03:34 <jle`> hc: yeah, remember that a -> (forall b. b -> c) is the same as forall b. a -> (b -> c)
12:03:45 <jle`> or a -> forall b. b -> c is forall b. a -> b -> c, as you wrote it there
12:03:59 <jle`> they're both rank-1 types
12:05:47 <hc> thanks
12:08:02 * hackagebot dynamic-loader 0.0.1 - lightweight loader of GHC-based modules or packages  https://hackage.haskell.org/package/dynamic-loader-0.0.1 (GaborGreif)
12:33:04 <dfeuer> Ping mokus
12:40:00 <Ed___> Hello. What was that shorter way of writing map (\x ->  read x :: Int) ["1", "2"]? 
12:40:20 <Welkin> map . read (String -> Int)
12:40:29 <Welkin> map . (read :: String -> Int)
12:40:35 <Ed___> Thanks
12:40:36 <Welkin> er
12:40:39 <Welkin> map (read :: String -> Int)
12:40:40 <Welkin> yeah
12:40:42 <Welkin> no compose
12:40:46 <thomasd> *clapz*
12:40:50 <Ed___> lolz
12:41:05 <Ed___> tyty
12:41:26 <jonored> map read ["1", "2"] :: [Int] should also work, I think.
12:41:53 <MarLinn> Or [1,2] :: [Int] O:-)
12:42:14 <Welkin> MarLinn: is that a potato on your head?
12:43:04 <MarLinn> Yes. Or a halo. It depends on the input value, really.
12:45:19 <geekosaur> space potato maybe?
12:45:44 <bala> @pl (\x f -> f x )
12:45:44 <lambdabot> flip id
12:46:40 <Welkin> :t flip ($)
12:46:41 <lambdabot> a -> (a -> c) -> c
12:48:13 <MarLinn> :t (Data.Function.&)
12:48:15 <lambdabot> a -> (a -> b) -> b
12:48:51 <bala> @pl( \list val -> (flip map) list ( flip ($) val )
12:48:51 <lambdabot> (. flip id) . flip map
12:50:45 <MarLinn> @let swing = flip.(.flip id)
12:50:46 <lambdabot>  Defined.
12:50:51 <MarLinn> :t swing map
12:50:52 <lambdabot> [b1 -> b] -> b1 -> [b]
12:51:48 <MarLinn> :t swing foldr
12:51:50 <lambdabot> Foldable t => b -> b1 -> t (b1 -> b -> b) -> b
12:52:16 <MarLinn> I love swing
12:53:29 <Cale> :D
12:53:46 <Cale> swing is a very old invention of mine
12:54:05 <Cale> :t swing partition
12:54:07 <lambdabot> [b1 -> Bool] -> b1 -> ([b1 -> Bool], [b1 -> Bool])
12:54:44 <erisco> :t swing
12:54:45 <dominik> Cale: ahhh, thanks!!! 
12:54:46 <lambdabot> (((b1 -> c1) -> c1) -> b -> c) -> b -> b1 -> c
12:54:57 <Cale> :t swing filter
12:54:58 <lambdabot> [b1 -> Bool] -> b1 -> [b1 -> Bool]
12:55:12 <dominik> Cale: damn, I should have noticed this in the first place :-)
12:55:19 <dominik> Cale: thanks a lot for debugging!
12:55:25 <Cale> dominik: no problem
12:55:58 <Cale> dominik: btw, a trick you should know about...
12:56:12 <Cale> bitonicPath ps i j | trace (unwords ["bitonicPath", "(" ++ show ps ++ ")", show i, show j]) False = undefined
12:56:32 <erisco> where might be use swing? it seems peculiar
12:56:41 <Cale> dominik: Just a nice way to handle tracing
12:56:53 <Cale> The guard will fail, but not before the arguments get printed :)
12:57:28 <Cale> erisco: Well, look at the examples of usage MarLinn and I have been providing :)
12:57:32 <dominik> Cale: cool, I didn't know this. Thanks!
12:58:34 <Cale> erisco: So, it turns filter into a function which takes a list of predicates, and a single element, and picks out the predicates which are satisfied by that element :)
12:59:00 <Cale> Or map into a function which takes a list of functions and a single element and applies all the functions to the element (a.k.a. sequence)
12:59:30 <Cale> and it almost unreasonably has lots of these sorts of consequences
13:00:10 <erisco> I asked the wrong question‚Ä¶ I meant to ask what general sense swing has
13:00:24 <MarLinn> erisco, in my mind it's like Data.Function.on. One of the nice functions that lurk in the back of your head. You can do for years without it, but it's incredibly satisfying to use them once you get a chance
13:00:56 <erisco> I might concoct any function and then find arguments which fit, but I am guessing you had something less arbitrary in mind when devising it
13:01:32 <MarLinn> :t \f c a = f ($ a) c -- pointy swing 
13:01:34 <lambdabot> error:
13:01:34 <lambdabot>     parse error on input ‚Äò=‚Äô
13:01:34 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
13:01:40 <MarLinn> :t \f c a -> f ($ a) c -- pointy swing 
13:01:41 <MarLinn> Oups
13:01:42 <lambdabot> (((a -> b) -> b) -> t -> t1) -> t -> a -> t1
13:01:42 <Cale> yeah, the pointed version is the one I came up with
13:02:02 <Cale> I looked at what it was that I was doing to map in order to apply a list of functions to a single value
13:02:09 <Cale> and then realised I could abstract that out
13:02:28 <Cale> and it was kind of funny that it worked much more generally
13:02:46 <Cale> (though not all that funny, when you look at the implementation)
13:03:12 <erisco> MarLinn, I don't know, I drove the pointless route to such an absurdity it doesn't seem interesting anymore‚Ä¶ but certainly functions which fit a design grander than themselves are still interesting
13:03:50 <erisco> MarLinn, Applicative-style being a pervasive example, or even more banally, function composition
13:03:58 <erisco> I am having a tough time seeing the idea of swing
13:04:01 <Cale> I've never really gotten much use out of it, but it's a curious thing anyway. One of the more useful third order combinators I've seen.
13:04:29 <Cale> (Even if giving it a name isn't usually so practical)
13:05:13 <Cale> I guess it's actually order 4?
13:05:45 <Cale> But regardless, the idea is to apply it to second order functions
13:06:04 <Cale> :t swing
13:06:06 <lambdabot> (((b1 -> c1) -> c1) -> b -> c) -> b -> b1 -> c
13:06:10 <Cale> yeah
13:06:58 <Cale> they have to be polymorphic if they're second order ;)
13:07:04 <erisco> :t swing sortBy
13:07:06 <lambdabot> error:
13:07:06 <lambdabot>     ‚Ä¢ Occurs check: cannot construct the infinite type:
13:07:06 <lambdabot>         a ~ b1 -> a -> Ordering
13:07:14 * erisco *shrugs*
13:07:31 <Cale> :t swing swing
13:07:32 <lambdabot> b -> (b1 -> b -> c) -> b1 -> c
13:07:43 <Cale> :t swing zipWith
13:07:44 <lambdabot> [b1 -> b -> c] -> b1 -> [b] -> [c]
13:08:35 <MarLinn> :t swing mapMaybe
13:08:37 <lambdabot> [b1 -> Maybe b] -> b1 -> [b]
13:08:37 <hiptobecubic> Things like ((a -> b) -> b) just never make any sense to me.
13:09:22 <Cale> Well, (a -> b) -> b is roughly similar to a
13:10:12 <erisco> not not a
13:10:16 <Cale> yeah
13:10:22 <hiptobecubic> Yeah i don't see that at all
13:10:33 <Cale> Well, what's a function f :: (a -> b) -> b?
13:10:46 <erisco> I say this with the most thin of understandings
13:10:50 <Cale> It's a function to which we can pose b-valued questions about a value of type a
13:10:54 <Cale> and it will answer them
13:11:09 <Cale> e.g. if b = Bool, these would be yes or no questions
13:11:23 <Cale> Now, it might be lying.
13:11:42 <hiptobecubic> What is a "b valued question"
13:11:46 <Cale> But at the very least, the simplest thing it could be doing is answering honestly about a value of type a
13:11:51 <hiptobecubic> a question whose answer is of type b?
13:11:53 <Cale> Well, a function of type (a -> b)
13:11:56 <Cale> yeah
13:12:14 <Cale> Consider (a -> Bool) -> Bool
13:12:26 <Cale> So a function (a -> Bool) is like a yes-or-no question about values of type a
13:12:32 <hiptobecubic> yes, sure
13:12:43 <hiptobecubic> But (a -> Bool) and (a -> b) are not the same type
13:12:47 <Cale> and a function (a -> Bool) -> Bool is then a box which answers yes-or-no questions about values of type a
13:12:54 <Cale> sure
13:13:02 <Cale> (a -> Bool) is more specialised
13:13:32 <hiptobecubic> But that matters, because you can pull Bools out of nowhere if you like
13:13:35 <erisco> "a box" and "answers questions" ‚Ä¶ what are these more precisely?
13:13:36 <hiptobecubic> But not "b's"
13:13:53 <hiptobecubic> :t const True
13:13:55 <lambdabot> b -> Bool
13:13:56 <erisco> we know this function cannot be implemented as anything other than bottom, if we're talking Haskell
13:14:00 <Cale> hiptobecubic: sure -- but you can certainly do the simple thing which is to give the box which answers honestly
13:14:08 <erisco> so I presume we're talking about some correlation with the types
13:14:36 <Cale> erisco: Well, by that I mean
13:14:58 <Cale> @let honest x f = f x
13:14:59 <dolio> It depends which things are supposed to be meta-variables, and which are internally quantified.
13:15:00 <lambdabot>  Defined.
13:15:08 <Cale> :t honest (5 :: Integer)
13:15:10 <lambdabot> (Integer -> t1) -> t1
13:15:19 <erisco> dolio, such a confusing thing for ASCII!
13:15:31 <Cale> honest is return for the Cont monad
13:15:42 <Cale> (unpackaged)
13:15:55 <dolio> It doesn't have to be confusing.
13:16:18 <dolio> You just have to pick more precise syntax.
13:16:45 <erisco> dolio, confusing or clumsy
13:16:57 <dolio> And maybe Cale already has, but didn't tell anyone.
13:17:59 <Cale> dolio: I'm being slightly imprecise and hoping, which is perhaps not the best plan :D
13:18:20 <HenrySwill> Is this Eddie's channel?
13:18:27 <Cale> Eddie?
13:18:33 <Welkin> this is the public haskell channel
13:18:36 <erisco> Cale, gotcha
13:18:40 <HenrySwill> you know, Eddie Haskell
13:18:49 <HenrySwill> from Leave it to Beaver
13:18:54 <erisco> except I imagine this has some important logical correlation I am unfamiliar with, the "not not a" part
13:18:55 <Cale> No, Haskell Curry
13:19:17 <Ed___> haha
13:19:20 <HenrySwill> oh so this is not a fan channel?
13:19:27 <xuxu> i find this pretty difficult to reason about: https://hackage.haskell.org/package/Spock-0.10.0.1/docs/src/Web-Spock-Safe.html#SpockM
13:19:35 <Cale> Nope, it's about the functional programming language
13:19:47 <Cale> named in honour of Haskell B. Curry, the mathematical logician
13:19:54 <HenrySwill> l?
13:20:07 <HenrySwill> "Functional programming"? Should not all programs be functional and work?
13:20:28 <HenrySwill> Who wants something that is not functional? That sounds like something in need of repairs.
13:20:39 <Cale> "Functional" refers to a particular facility for working with functions as first class values.
13:20:49 <Welkin> furniture that you can only look at, but not sit on
13:20:54 <erisco> did Reddit send you here? where do the lols pools collect nowadays?
13:21:11 <HenrySwill> Welkin. Exactly! That's not functional at all
13:21:17 <Cale> and the fact that the language is designed to make manipulating functions a natural way of doing things
13:21:27 <hiptobecubic> HenrySwill, it's function is not to be sat upon. It's to look good and cost little.
13:21:30 <hiptobecubic> its* rather
13:21:43 --- mode: ChanServ set +o shapr
13:21:54 <Cale> HenrySwill: Of course, we would tend to argue that languages which aren't functional in this sense are probably not so functional in the other ;)
13:22:00 * hiptobecubic plays theme from jaws softly
13:22:32 <xuxu> e.g. how does SpockCtxT relate to main <- runSpock 3000 $ spockT id $ do get ("echo" <//> var) $ \s -> text $ T.concat ["Echo: ", s]
13:22:42 <HenrySwill> no function should be manipulated. every function should be immutable along with every bit of data. It should be the programs that are mutable ... i.e., write again a bad version of a function. 
13:23:01 <hiptobecubic> HenrySwill, will that's what all programming already is
13:23:04 <hiptobecubic> well*
13:23:09 <Cale> HenrySwill: Well, as an example of what I mean, consider the operation of composing two functions to obtain a third
13:23:32 <Cale> In Haskell, we have the operation (f . g) x = f (g x)
13:23:45 <erisco> Cale, my new favourite idea is functionally produce data, then non-functionally interpret it (to do side effects)
13:24:11 <erisco> in other words, highly specialised languages and interpreters
13:24:11 <Cale> The infix operator (.) takes two functions, say f and g as arguments, and produces a function which when applied to an argument x gives the result f (g x)
13:24:32 <HenrySwill> a toilet bowl flushes turds down into the sewer. can you imagine if mid crap, your toilet bowl could be mutated into something else, say a harden bucket of concrete? What would your backside look like but a splattered mess. 
13:24:33 <HenrySwill> Functions cannot be mutable, ever. 
13:24:47 <Cale> This doesn't involve mutating functions at all
13:24:50 <xuxu> anyone here use haskell for web programming?
13:25:00 <Cale> xuxu: I do it for a living.
13:25:10 <ReinH> This is a troll.
13:25:18 <xuxu> Cale: do you use a framework and which one if so?
13:25:23 <Cale> ReinH: after the last messages, I would tend to agree
13:25:24 <HenrySwill> Rein, you are?
13:25:27 <MarLinn> HenrySwill: But you can compose a toilet with a sewer to form a crap-offloading system
13:25:29 --- mode: ChanServ set +o Cale
13:25:33 --- mode: Cale set +b *!*@71.119.182.33
13:25:33 --- kick: HenrySwill was kicked by Cale (HenrySwill)
13:25:39 <erisco> Cale, also acknowledging that I am applying this in non-functional languages, where you have to work with non-functional libraries, and so this is a method to oust the side effects to the fringes
13:25:40 --- mode: Cale set -oo Cale shapr
13:25:41 * hiptobecubic turns up jaws theme volume
13:25:44 <drdo> HenrySwill: 1 + 2 = 3
13:25:47 <MarLinn> crap-offloading system: worked
13:25:52 <Ed___> 1 + 1 = 3
13:25:54 <drdo> Oh no, we just mutated 1 into 3!
13:26:04 <shapr> Cale: thanks!
13:26:07 <Ed___> <- BANNED
13:26:28 <erisco> no no, numbers are primitive types, you cannot mutate those, only object types
13:26:40 <ReinH> > let 1 + 1 = 3 in 1 + 1
13:26:44 <lambdabot>  3
13:26:47 <ReinH> If you insist
13:26:53 <Cale> dang, just as I was typing that very same thing
13:26:58 <Cale> haha
13:27:19 <ReinH> Cale: :p
13:27:29 <erisco> what is this? does lambdabot understand ad-hoc constructors?
13:27:46 <ReinH> It's defining (+), which is not a constructor.
13:27:58 <erisco> ah, obvious now
13:28:04 * hackagebot hocilib 0.1.0 - FFI binding to OCILIB  https://hackage.haskell.org/package/hocilib-0.1.0 (Thierry)
13:28:32 <erisco> the syntactic similarities can be confusing
13:28:41 <MarLinn> It's ad-hoc mutating the meaning of a function! Oh noes!
13:28:45 <erisco> "=" gets used for different things in Haskell
13:29:15 <xuxu> i think i have a firm grasp theoretically of haskell and how to use it, but i'm struggling to actually use it in building a simple api endpoint
13:30:26 <xuxu> erisco: isn't "=" having different meanings called "ad hoc polymorphism"
13:30:32 <xuxu>  / operator overloading
13:30:50 <hiptobecubic> Well = isn't a function
13:30:52 <erisco> it isn't polymorphic, or an operator, it is just syntax
13:30:59 <ReinH> Cale: Henry pmed me and called us a bad name.
13:31:05 <dkasak> xuxu, no, because = is a metasymbol.
13:31:05 <hiptobecubic> Right, it's just a way to communicate a truth to the compiler
13:31:40 <erisco> if there is a construct on the left then it is a pattern match, and if there is a function name on the left it is a function definition
13:31:50 <ReinH> And also "probably millenials", which I rather enjoyed.
13:31:52 <xuxu> thanks. if Applicative refers to <* and MyClass refers t <* though, that is operator overloading / ad hoc polymorphism, right?
13:32:00 <hiptobecubic> xuxu, regarding your web question, is the problem that you can't get it stood up and responding to requests, or that the theoretical underpinnings of the types in Haskell's web frameworks / libraries are bananas?
13:32:07 <xuxu> by refers, i mean defines
13:32:17 <ertes> > let 0 = 5 in 0 + 0
13:32:19 <lambdabot>  10
13:32:40 <erisco> if there is "type" on the left it is a type alias ‚Ä¶ and I am sure some other uses as well
13:32:42 <ReinH> ertes: you sit on a throne of lies
13:32:57 <Ed___> is there a symbol for `mod` in haskell>?
13:33:02 <ertes> =)
13:33:12 <Ed___> =) doesn't work;
13:33:23 <ertes> Ed___: none is predefined, but you can define one, if you want
13:33:28 <Ed___> ty
13:33:30 <xuxu> hiptobecubic: i can get the example from spock's readme running, but there's more than echoing. i want to query a database (success!) and return that result to the user in json format (so far: failure)
13:33:33 <ertes> > let (%) = mod in 17 % 5
13:33:34 <sm> why is a literal allowed to be reassigned ?
13:33:35 <lambdabot>  2
13:33:40 <ertes> Ed___: ^
13:33:45 <Cale> ReinH: Yeah yeah
13:33:53 <erisco> > let "foo" = "bar" in "foo"
13:33:55 <lambdabot>  "foo"
13:34:02 <ReinH> Cale: eh?
13:34:23 <ertes> Ed___: but i encourage you to use `mod` instead, so everybody understands your code, including yourself in six months
13:34:31 <erisco> it isn't literals sm, it is just shadowing of identifiers
13:34:36 <Ed___> yea. i was just wondering. thanks!
13:34:38 <erisco> as my previous example shows
13:34:47 <hiptobecubic> I don't know, I'm pretty accustomed to seeing (%) by now.
13:34:58 <Ed___> is the symbol % used for anything?
13:35:00 <ertes> sm: as ReinH noted, i'm sitting on a throne of lies =)
13:35:06 <sm> erisco: 0 is a numeric literal, and not a valid identifier surely
13:35:07 <erisco> "foo" = "bar"  is a pattern match, equivalent to ['f','o','o'] = "bar"
13:35:10 <ertes> sm: no actual reassignment is going on there
13:35:17 <sm> s/reassignment/binding/
13:35:17 <geekosaur> Data.Ratio
13:35:37 <geekosaur> :t 2 % 1
13:35:37 <ertes> sm: what is going on is me secretly redefining (+) in lambdabot's /query =)
13:35:39 <lambdabot> Integral a => Ratio a
13:35:49 <geekosaur> ^ Ed___
13:36:08 <Ed___> that's gotta be in some package, cause it's not in my prelude...
13:36:13 <sm> this is going from bad to worse :)
13:36:28 <hiptobecubic> > 0 + 0
13:36:28 <erisco> so 0 = 5 is a pattern match as well
13:36:29 <geekosaur> as I said earlier, Data.Ratio
13:36:29 <Ed___> > 2 % 1
13:36:31 <lambdabot>  0
13:36:32 <lambdabot>  2 % 1
13:36:44 <Ed___> oh ok. thanks bud
13:36:52 <ertes> sm: 0 = 5 is a failed pattern match, but because 'let' patterns are irrefutable by default, it's basically just ignored
13:36:57 <ertes> > let !0 = 5 in ()
13:36:59 <lambdabot>  *Exception: <interactive>:3:5-10: Irrefutable pattern failed for pattern !0
13:37:22 <erisco> ertes, it has no need to evaluate, irrefutability is beside the point
13:37:28 <Cale> ReinH: He did the same to me. Pretty sad.
13:38:05 * hackagebot postgresql-libpq 0.9.2.0 - low-level binding to libpq  https://hackage.haskell.org/package/postgresql-libpq-0.9.2.0 (LeonSmith)
13:38:23 <Cale> xuxu: I wouldn't call it ad-hoc polymorphism. Haskell doesn't really have ad-hoc polymorphism, it has type class polymorphism, which is a different thing.
13:38:30 <xuxu> thank you for responding :)
13:39:02 <geekosaur> well, the purists often call typeclass polymorphism ad-hoc :)
13:39:16 <minad> Cale: but there is this paper: making ad-hoc less ad-hoc ;)
13:39:29 <Cale> minad: Yeah, that pun is the cause of a lot of confusion
13:39:31 <erisco> the pursuit of nothingness
13:39:51 <minad> Cale: still, I consider it kind of ad-hoc polymorphism + laws
13:40:01 <erisco> the laws are a lie, a terrible lie
13:40:08 <Cale> The distinction is that with ad-hoc polymorphism, you don't get more ad-hoc polymorphic things just by using ad-hoc polymorphic things
13:40:15 <minad> ersico: why?
13:40:18 <ertes> > case 1 of 0 -> ()
13:40:21 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
13:40:23 <ertes> > case 1 of ~0 -> ()
13:40:26 <lambdabot>  ()
13:40:32 <erisco> actually they are laws in the proscriptive sense rather than the descriptive one!
13:40:42 <Cale> For example, with type class polymorphism, just by using the order comparison operations like compare and (<=) to write a sorting function, say, we can obtain a polymorphic sorting function.
13:40:42 <ertes> erisco: the irrefutability is what makes the joke "work"
13:40:42 <minad> erisco: well use agda then
13:41:00 <Cale> The choice of type at which to use the definition can be *deferred*
13:41:04 <ertes> erisco: it's the reason it doesn't just blow up
13:41:14 <Cale> That's very different from plain ad-hoc polymorphism
13:41:21 <ertes> and the second reason it works is that i secretly redefined (+) for a short time
13:41:32 <xuxu> i really want ML langs to be common place in 50 years and everyone using at least a simply typed lambda calculus
13:41:33 <Cale> :t sort
13:41:35 <lambdabot> Ord a => [a] -> [a]
13:41:42 <Cale> sort is not a method of the Ord type class
13:42:00 <ertes> xuxu: i hope we have better languages in 50 years
13:42:01 <dolio> 50 years? Geeze.
13:42:27 <ertes> if we're still praising haskell in 50 years, something is seriously wrong with computers
13:42:51 <geekosaur> does that include as a progenitor?
13:42:55 <erisco> ertes, I attribute it to laziness, but perhaps we're saying the same thing
13:43:20 <ertes> xuxu: of course i just realised that your statement is completely unrelated to mine =)
13:43:22 <xuxu> i'm not talking about praising, just common place and expected
13:43:42 <geekosaur> (I suspect that, long term, haskell won't be remembered for itself, so much as for introducing laziness and purity that will have been incorporated into more popular languages. So it goes.)
13:44:19 <erisco> minad, using agda does not change the lies of Haskell TC laws
13:44:35 <minad> what is the lie exactly?
13:44:36 <Cale> By the time Haskell gets to be commonplace, I expect to be using some dependently typed language with univalence and built-in higher inductive types.
13:45:08 <Cale> (and hopefully a lazy-by-default evaluator too!)
13:45:27 <xuxu> which language introduced type classes and algebraic data types? haskell has been my first experience with them
13:45:44 <minad> Cale: what do you expect from hit in a programming language?
13:45:49 <erisco> geekosaur, if it is lucky! I wager people will assume the flashy new language with a web 2.0 website made the innovation
13:45:52 <Cale> (Though maybe univalence and type classes won't play together so nicely, I dunno.)
13:45:55 <raskolnikvosmoth> xuxu, dolio: in 50 years code is generated from high level interfaces, or maybe an AI is coding for us so it wont matter :)
13:45:55 <ertes> i think ML had ADTs
13:46:07 <dolio> It's already been 45 years since ML was invented. If it takes another 50 years to get mainstream, that's 95 years.
13:46:08 <ertes> type classes may be a haskell invention though
13:46:10 <minad> SML has ADTs
13:46:49 <geekosaur> erisco, well, most people yes. but people do that anyway; I'm discounting it because it's inevitable
13:47:07 <erisco> minad, easy example: Float is a Num
13:47:16 <minad> erisco: when I started to use haskell, I just thought of typeclasses as some weird overloading mechanism but if you pair it with laws...
13:47:18 <Cale> minad: Well, I'm not 100% sure of all the things higher inductive types will be useful for, but I think if we find ways to make computing with them easy enough, they'd be a really nice way to define domain specific languages together with laws that interpreters must satisfy
13:47:19 <minad> erisco: bad example
13:47:25 <minad> float is pragmatic
13:47:38 <erisco> oh, so you get to break the laws when it is pragmatic
13:47:44 <minad> but of course you are right about this one
13:47:44 <erisco> well hold on, what are the laws saying again?
13:47:48 <geekosaur> the problem with considering laws as part of typeclasses is we have Num :)
13:47:58 <geekosaur> and the Enum/Bounded mess, etc.
13:48:00 <ertes> in reality type classes are just a convenient way of passing implicit arguments to functions
13:48:22 <erisco> bingo was his name-o ertes :)
13:48:23 <minad> erisco: if we would do it right, we would not declare float as num etc. and we wouldn't use ord but partialord and so on
13:48:24 <Cale> A convenient and consistent way
13:48:55 <Cale> Such that you don't have to worry about the providence of any particular implicitly supplied argument
13:49:13 <erisco> minad, to be done right they have to be descriptive rather than proscriptive laws
13:49:54 <minad> Cale: I am not convinced about HIT in programming languages, but I don't understand enough. To start I guess extensionality would be more useful
13:49:55 <MarLinn> minad: There are at least two alternative/additional preludes that try to introduce better numerical hierarchies
13:50:04 <ertes> yeah, consistency is very important‚Ä¶  you know‚Ä¶  like‚Ä¶
13:50:13 <ertes> > ([1,2,3], ['a','b','c'])
13:50:16 <minad> ersico: so then you need dependent types
13:50:16 <lambdabot>  ([1,2,3],"abc")
13:50:40 <erisco> I think what co-effects is demonstrating is a way forward on implicit arguments http://tomasp.net/coeffects/
13:50:45 <Cale> minad: Our minds are also a bit clouded I think by the fact that we don't usually have such good access to groups and groupoids as HITs would provide
13:51:01 <erisco> minad, I disagree that you *need* them, but that is an option
13:51:01 <xuxu> is HIT referring to dependent types and other types?
13:51:15 <Cale> HIT stands for higher inductive type
13:51:18 <erisco> minad, and regardless, it still stands that the laws are a lie (descriptively), which is all I am saying
13:51:33 <minad> MarLinn: yes and that's pretty cool. However I think it is ok to sometimes violate the laws (for something like float) if it makes things easier to learn maybe? but we could also use .+ .* etc for float
13:51:49 <minad> like SML i think, they have .+ for float right?
13:52:21 <erisco> I think coeffects is so compelling that we need it yesterday
13:52:38 <Cale> It's a particular sort of data type on which in addition to the usual value constructors, you are able to provide "equality" constructors, i.e. you can say that you want a specified reason why such and such term of your type is equal to such and such other term.
13:53:15 <xuxu> so HIT doesn't necessarily imply dependent types?
13:53:33 <Cale> Well, the fact that you're working with identity types does, pretty much
13:53:48 <Cale> But yeah, the types you're defining needn't depend on values themselves
13:53:49 <ertes> Cale: like a built-in equivalence relation for types?
13:53:52 <minad> erisco: this lie thing - I dont get it ;) It is like Liskov substitution principle or pure functions in SML or all things not covered by the type system. all lies ;)
13:53:58 <MarLinn> minad, I don't think we need separate operators necessarily. The underlying ideas are the same anyway.
13:54:11 <Cale> ertes: yeah, though, there's something a bit more to it than just what "equivalence relation" gets across
13:54:19 <ertes> Cale: does that make equivalent values indistinguishable?
13:54:42 <minad> MarLinn: I would like to have the operators follow laws, like associativity etc. But I am also fine with the pragmatic way.
13:55:03 <Cale> ertes: It's better to think of those higher constructors as providing 1-dimensional paths between the 0-dimensional values of your type (and then you can keep going and provide 2-dimensional paths between various composites of the 1-dimensional ones, and so on)
13:55:24 <ertes> sounds like something that might come out of HoTT =)
13:55:27 <minad> Cale: you mentioned univalence before. this doesn't play well together with axiom K
13:55:31 <Cale> ertes: They're not indistinguishable in one sense, but any function out of the type has to say where the path constructors get sent
13:55:39 <minad> this doesn't play well together with pattern matching
13:55:40 <Cale> minad: right.
13:55:45 <minad> I think agda had such problems
13:55:59 <Cale> Well, you can turn off axiom K in Agda
13:56:01 <Cale> (now)
13:56:32 <Cale> However, computing with univalence will require even more research
13:56:44 <minad> yeah but it is not clear if it is really off, it just disables some ways to trigger it if I remember correclty
13:56:53 <Gurkenglas> lpaste.net/2619919897257312256 that didnt appear to overwrite the existine exference.exe. How do I make it do that?
13:57:05 <MarLinn> minad, one of my favourite idea is that type systems could be optional so you could switch them on the fly. After all, it's only a tool for you. So why not switch out the system for a scope if you need a more pragmatic solution for floats.
13:57:06 <minad> Cale: but I agree that more expressive equality would be very nice
13:57:14 <erisco> minad, if you use my instance of Functor, for my type Outlaw, do you know if it satisfies Functor laws?
13:57:16 <Cale> There are some early implementations of "cubical" type theories which allow one to prove univalence as a theorem and thus compute with it
13:57:31 <ertes> Cale: what's the current state on HoTT computing?  still basically undefined?
13:57:38 <minad> erisco: no, but the name sounds suspicious ;)
13:57:48 <Cale> ertes: well, what I just mentioned is the current state of things :)
13:58:05 <erisco> minad, if the laws were descriptive you would, because it must be so, but because they are proscriptive you cannot know, no more than you can be certain that a law against theft will prevent all robberies
13:58:14 <Cale> ertes: People are working on new axiom-free type theories which are able to prove univalence as a theorem
13:58:40 <minad> Cale: about these hott realizations, is type checking decidable there?
13:58:42 <erisco> minad, and so when it comes to determining the correctness of your software these are not laws you can rely upon
13:58:44 <Cale> and there are a handful of things, but I don't know whether the formal results have actually been obtained yet
13:59:06 <erisco> minad, if you assume the laws hold then this is the potential lie you expose yourself to
13:59:08 <minad> erisco: in a language with dependent types you can enforce the laws. not yet so in haskell
13:59:31 <erisco> I am aware of the state of Haskell. I am the one who is saying you cannot enforce them. Is that not what I have been saying this whole time?
13:59:51 <Cale> minad: I believe so.
14:00:11 <Cale> My concrete understanding of cubical type theories is a little shaky.
14:00:22 <minad> erisco: yes, but if you would formally verify your software, the first thing you would do is to ensure that the laws are obeyed
14:01:00 <erisco> I agree, and this is a different point
14:01:21 <minad> erisco: yes, in the end we agree I guess
14:01:34 <Cale> But there are at least a couple machine implementations of cubical type theory which seem to work in a practical sense at the very least.
14:02:06 <hpc> cubical as in lambda cube?
14:02:14 <Cale> No, different cubes
14:03:24 <Cale> hpc: The idea is that elements of identity types are thought of as 1-dimensional paths
14:03:39 <minad> Cale: this is a topological thing? like triangulation?
14:03:42 <Cale> yeah
14:03:58 <Cale> "cubical" as opposed to "simplicial"
14:04:10 <Cale> as opposed to "globular"
14:04:47 <hpc> sounds too mathy for me today
14:05:04 <hpc> i just found out in another channel that i got /real/ dumb over the course of this afternoon, but something for me to google later ;)
14:05:19 <Cale> The idea is to put in explicit rules implementing the Kan filling condition, that whenever you have an (n-dimensional) box with all the sides but one made up from identity terms, then the "top" of the box exists and the "inside" does too.
14:05:49 <dglkhadglkadj> Anyone know how to use stack to build docker images? I can build containers with `stack --docker --docker-persist build`, but not images.
14:06:04 <Cale> It would be easier to explain if I could draw some simple diagrams
14:06:11 <minad> Cale: would it also work with other polyhedra?
14:06:27 <hpc> Cale: is this a good thing to read? http://dlicata.web.wesleyan.edu/pubs/lb14cubical/lb14cubes-oxford.pdf
14:06:31 <erisco> I prefer Tubular Types
14:06:46 <Cale> Higher category theorists think about that kind of thing, and yeah, there are other approaches which operate on different shapes.
14:06:58 <hpc> erisco: for me it's a tie between mondo types and gnarly types ;)
14:07:13 <Cale> hpc: Find the talk corresponding to that
14:07:42 <Cale> https://www.youtube.com/watch?v=lt8JgGRw7gg -- maybe this?
14:08:11 <Cale> But I don't know if there's a really easy to understand one yet -- people are still figuring out what this stuff *is* let alone how to explain it to others :)
14:08:18 <hpc> ooh neat
14:08:45 <hpc> it's cool to be on the cutting edge of math for once
14:08:53 <minad> a few days ago this rosetta stone paper by baez was showing up again on reddit
14:09:10 <minad> I would really like to have an updated rosetta stone paper which includes the hott stuff
14:09:10 <Cale> hpc: I remember that talk being kind of technical...
14:09:39 <erisco> all my thinking is on "Predicate Types", and maybe someone can point me to some work on this
14:09:46 <Cale> hpc: Also, if you haven't already read about HoTT, probably best to start with a more basic approach before jumping straight to cubical type theory
14:10:08 <Cale> (though I know that benzrf started with cubical TT somehow)
14:10:53 <minad> I guess the book is a good start?
14:10:55 <Cale> yeah
14:11:07 <Cale> and if the introduction gets confusing, just skip it
14:11:16 <erisco> well, it should be the same as just stripping the characteristic functions out of sets
14:11:20 <erisco> and there are your types
14:11:29 <hpc> Cale: ill keep that in mind
14:12:06 <Cale> Chapter 1 starts off with an introduction to dependent type theory
14:12:09 <minad> do you have some recommendations on "classical" type theory?
14:12:12 <Cale> which ought to be comprehensible
14:12:20 <minad> ah ok, so the book covers that too
14:12:35 <erisco> though I came to realise it is more awkward than I thought if you need quantifiers
14:12:41 <erisco> and I haven't figured out how not to need those
14:12:41 <hpc> Cale: any tips on intros to hott?
14:12:48 <Cale> (though it's tinted in a particular way)
14:13:01 <Cale> https://homotopytypetheory.org/book/ is freely available
14:13:05 <hpc> oh neat
14:13:57 <Cale> It's the intro of that book which I warned about ;)
14:14:03 <Cale> In case that was unclear
14:14:25 <hpc> ah k
14:14:33 <Cale> oh, except
14:14:59 <Cale> minad: I just noticed that the intro to the HoTT book contains (at least part of) the rosetta stone you were looking for
14:15:10 <minad> :)
14:15:28 <Cale> It's Table 1 :)
14:15:54 <minad> that cute
14:17:07 <erisco> the thought with predicate types is you already have the tools at hand‚Ä¶ so for example, the type of even numbers is just the predicate isEven
14:17:35 <minad> erisco: is this the theory behind liquid haskell?
14:17:49 <erisco> but then it becomes awkward introducing quantifiers to say, for example, that = is of the type of reflexive, transitive, symmetric relations
14:18:18 <erisco> minad, I have no idea. All I know is the name "refinement types" and maybe those are related *shrug*
14:18:31 <minad> ah, right. refinement, didn't remember the name
14:18:36 <erisco> in their demo they showed something which looks like what I am saying here but really not due to its restrictiveness
14:19:33 <minad> did you try it already? I wonder how painful that is
14:19:40 <erisco> and their bent on inference with SMT solvers is not what I'd be trying
14:20:00 <erisco> eh, when inference times are several minutes it isn't something I'd want to be attached to :P
14:20:28 <Cale> I think they've really done quite a good job with the HoTT book considering how absurd the audience for it is
14:20:44 <minad> I like the idea of smt solvers, this is very powerful. I played a bit with sbv
14:20:54 <Cale> Not often that you want to write a book aimed at algebraic topologists and computer scientists at the same time.
14:21:06 <minad> Cale: probably more often in the future
14:21:16 <erisco> first you need a fully deliberated way to prove type membership manually
14:21:22 <minad> and also for physicists etc
14:21:27 <erisco> then you let the programmer develop automation for this process
14:21:47 <Cale> Yeah, it's remarkable how all these ideas are unifying.
14:21:51 <erisco> the problem with the SMT solver approach is you're restricted to an arbitrarily slow black box of magic
14:22:45 <Cale> Perhaps it's that we're always reinventing systems which are exactly as general as human brains are capable, and so they all turn out to be equivalent :D
14:23:05 <erisco> or as general as generality can be
14:23:17 <minad> erisco: that's true. but if you start with something and it looks like such a smt problem, why not throw it at it at first?
14:24:12 <minad> Cale: sounds like church and turing ;)
14:24:24 <erisco> use an SMT solver in your toolbox ‚Ä¶ you need the other pieces I stated first. I know little about it, but I think this is what get called "tactics" in proof assistants
14:25:31 <minad> erisco: yes but I meant it could happen that you have to solve some quick and dirty integer problem for some application. no necessarily type inference
14:25:46 <minad> I agree that for type inference it is probably not the best thing
14:25:47 <Gurkenglas> In http://lpaste.net/8799161557297659904 , why does stack install early on (ctrl-f copying) copy the bin, but not at the end?
14:26:01 <erisco> inferring the type of the integer problem and solving the integer problem are the same thing, that is the point
14:26:18 <erisco> the types *are* the problems
14:26:51 <minad> if you formulate it in that way, but you don't have to
14:27:23 <erisco> if you don't then it is something different
14:29:03 <erisco> well, inferring a type is different than checking a type, and I particularly mean checking a type
14:29:22 <minad> erisco: yes
14:29:30 <erisco> inferring a type is about assigning a satisfactory type to an unannotated term, so you're worried about uniqueness for example
14:30:08 <minad> but many typesystems don't have this principal type property?
14:30:18 <erisco> you mean type inference?
14:30:32 <minad> yes
14:30:49 <erisco> it isn't that the type systems don't have it ‚Ä¶ type systems may be incompatible with the notion, but the languages we're probably referring to don't have this problem
14:31:05 <erisco> the reason you write  Foo x = new Foo(); in Java is not because of an incompatibility with their type system
14:31:25 <erisco> they just haven't had the incentive to add "var" like in C#
14:31:57 <erisco> also these companies seem to have extra concerns when it comes to their compilers, particularly with resource use
14:32:04 <Welkin> erisco: it's because java is stoopid
14:32:10 <minad> yes, the java people are a bit slow ;)
14:32:17 <erisco> they may not want a worse-case exponential inference algorithm
14:32:26 <erisco> because of security issues and quality assurance issues and so forth
14:32:28 <minad> or undecidable even ;)
14:32:31 <minad> most of them are undecidable
14:32:44 <minad> (for higher rank stuff I mean)
14:33:14 <erisco> in C# there are legitimate incompatibilities, for example  var f = x => x;  is invalid
14:33:29 <minad> but I don't buy this argument about high complexity type checking and inference. I would rather have a diverging type checker than a diverging program
14:33:50 <erisco> x => x  has multiple possible types, and so due to lack of uniqueness they forbid this program
14:33:53 <Welkin> why does anyone even care about java or dotnet (besides being forced to use them at some dumb company)?
14:33:59 <Welkin> I like to pretend they never existed
14:34:35 <erisco> Welkin, you've eradicated the bulk of it with your aside
14:34:38 <minad> Welkin: I think the VMs are not that bad. At least clr works also for FP
14:35:03 <erisco> then you have people who just like the languages, they're familiar with them, nothing wrong with it
14:35:25 <erisco> but if it weren't for the commercial success then these languages wouldn't have any foothold
14:35:46 <maerwald> Welkin: that doesn't sound like a serious question. Check the tiobe index maybe.
14:36:09 <lpaste> Ed_ pasted ‚ÄúUniqify‚Äù at http://lpaste.net/180368
14:36:14 <Ed___> So I'm trying to filter a list by keeping only elements that appear once.
14:36:32 <erisco> are you interested in a Prelude function which does this Ed___ ?
14:36:39 <Ed___> sure.
14:36:49 <erisco> :t nub
14:36:50 <lambdabot> Eq a => [a] -> [a]
14:36:53 <Welkin> maerwald: that index is meaningless
14:36:55 <minad> nubOrd!
14:36:59 <maerwald> Welkin: no, it's not
14:37:01 <Ed___> But i'm also interested in the one I am writing right now. if anybody can comment on it
14:37:06 <Welkin> because someone is forced to use something doesn't mean they like it
14:37:18 <maerwald> Java is one of the most widely used language in the industry. So there you have your reason.
14:37:31 <maerwald> your initial question wasn't really about emotions
14:37:39 <Ed___> oh shit. its gotten hostile in here
14:38:28 <Ed___> nub doesn't really do what i want it to because it keep elements that occur more than once, i dont keep those.
14:38:43 <erisco> > nub [1,2,1,3,2]
14:38:43 <Welkin> Ed___: us Set.fromList
14:38:45 <lambdabot>  [1,2,3]
14:38:48 <Welkin> use*
14:38:49 <maerwald> sounds like someone had a bad awakening realizing that most job descriptions involve java and not haskell ;)
14:38:55 <erisco> what elements did it keep that occur more than once?
14:38:57 <Welkin> it is O(n)
14:39:06 <Ed___> uniqify [1,2,1,3,2] should equate to [3]
14:39:15 <Ed___> becase it is the only element that appears once
14:39:16 <erisco> it is nlogn Welkin
14:39:17 <Welkin> uniqify? lol
14:39:22 <Ed___> =D
14:39:23 <Welkin> erisco: okay, fine
14:39:38 <erisco> Ed___, I have misunderstood your problem description entirely then
14:39:56 <Ed___> sorry about that. but thanks for that nub function tho
14:40:08 <erisco> so, there is a wonderful way to do this
14:40:25 <Ed___> list comprehension?
14:40:32 <Ed___> thats what first came to my mind..
14:40:45 <Ed___> but it didnt quite pan out
14:41:11 <Ed___> so I tried this http://lpaste.net/180368 and its not working. And im interested in getting that to work the most
14:41:15 <Welkin> Ed___: of course, you could solve it using a Map
14:41:19 <Welkin> you can solve almost anything using a Map
14:41:35 <Welkin> Ed___: get the count of each element and then only take the ones that have a count of 1
14:41:40 <Welkin> simple enough
14:41:41 <erisco> Ed___, you will have to afford me the time to derive it
14:42:10 <Ed___> I just think that my function should work perfectly fine. yet its getting an error.
14:42:42 <lpaste> Ed_ revised ‚ÄúUniqify‚Äù: ‚ÄúUniqify‚Äù at http://lpaste.net/180368
14:43:05 <Ed___> oops. i had a silly mistake in there
14:44:33 <erisco> :t M.fromList
14:44:37 <lambdabot> Ord k => [(k, a)] -> Data.Map.Map k a
14:45:04 <erisco> > (M.keys . M.filter (==1) . M.fromListWith (+) . flip zip (repeat 1)) [1,2,1,3,2]
14:45:10 <lambdabot>  [3]
14:45:22 <erisco> that is for you to dissect Ed___
14:45:36 <Ed___> lol. thanks man. i doubt i will use it though.
14:46:34 <Ed___> Plus, i don't think Code Eval will allow for that import....
14:46:34 <erisco> 1) why? 2) what is Code Eval?
14:46:40 <Ed___> codeeval is like hacker rank. 
14:46:51 <erisco> another thing I am unfamiliar with
14:46:52 <MarLinn> :t \xs -> [ x | n <- [0..(length xs - 1)], let (pre,(x:post)) = splitAt n xs, x `notElem` pre, x `notElem` post]
14:46:55 <lambdabot> Eq t => [t] -> [t]
14:47:15 <Ed___> i mean they didnt allow for the import of some libraries... like Data.List i think
14:47:22 <Ed___> or Data.Char
14:47:25 <Ed___> one of those
14:47:55 <erisco> flip zip (repeat 1)  is  fmap (,1)   with TupleSections
14:48:42 <erisco> hm, so you're running a three-legged race then?
14:50:11 <erisco> Ed___, ohhhh ‚Ä¶ do they stipulate there is only one number which occurs once?
14:50:17 <Ed___> no
14:50:32 <erisco> okay ‚Ä¶ that is one of those interview questions
14:51:01 <Ed___> yea... 
14:51:05 <Ed___> i gess
14:51:09 <erisco> a test of whether you're inclined to recall the properties of xor off the top of your head
14:51:23 <minad> lol
14:51:57 <erisco> interestingly there is an operation on sets which satisfy the same properties and give you a more general answer (works for more than 1 number)
14:52:10 <Ed___> > [x | x<-[1,2,3,2], notElem x (tail [1,2,3,2])]
14:52:12 <lambdabot>  [1]
14:52:50 <Ed___> > [x | x<-[1,2,3,2,4,5,5], notElem x (tail [1,2,3,2,4,5,5])]
14:52:52 <lambdabot>  [1]
14:53:04 <Ed___> booo
14:54:16 <Ed___> can you ":set +m" here?
14:54:24 <lyxia> nope
14:55:41 <linman> how would one put a list of zeros inbetween (and out) the list here, such that the max length is x: http://en.wikipedia.org/wiki/Special:Search?go=Go&search=1,1],[1
14:55:58 <linman> sorry, ignore that link...
14:57:07 <linman> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=1],[1,1 -> [[0], [1], [0], [1,1], []]
14:57:12 <lpaste> Ed_ revised ‚ÄúUniqify‚Äù: ‚ÄúUniqify‚Äù at http://lpaste.net/180368
14:57:17 <linman> idk wht it keeps putting that link up..
14:57:45 <Ed___> so I revised the lpaste to include the error if anybody can take a look and explain plz
14:58:22 <Ed___> Also, is there a way to turn off messages of someone joining/leaving the channel?
14:59:27 <MarLinn> x ++ uniqify xs ~~> what are the types of the components ~~> solution ;)
15:00:06 <Ed___> omg
15:00:07 <Ed___> thanks
15:00:59 <MarLinn> I must say that my ghci gave me a much better error message though... strange.
15:01:32 <Ed___> Ok. But im getting a non exhaustive pattern. This was my problem in not being able to write recursion on lists. im having trouble with establishing a proper base case.
15:01:42 <lpaste> Ed_ revised ‚ÄúUniqify‚Äù: ‚ÄúUniqify‚Äù at http://lpaste.net/180368
15:02:10 <erisco> linman, not sure what the URL is about in your question. What determines the length? why is one of the lists empty?
15:02:43 <Welkin> Ed___: the empty list, meaning none are uniqie
15:02:46 <Welkin> unique*
15:03:02 <Ed___> uniqify [] = []
15:03:05 <Ed___> i have that though
15:03:47 <MarLinn> Ed___ could you include the new error message as well, then?
15:04:01 <Ed___> *** Exception: <interactive>:110:5-21: Non-exhaustive patterns in function uniqify
15:04:14 <Ed___> do I have to include a base case for a list with 1 element?
15:04:23 <erisco> that is x:xs
15:04:52 <erisco> how are you entering this into GHCi? you have to give it all at once, not line by line
15:04:57 <erisco> otherwise you are just overwriting it
15:05:01 <Ed___> oh...
15:05:12 <Welkin> Ed___: put it in a file and :load it
15:05:14 <Welkin> yeah
15:05:19 <erisco> or use semicolons
15:05:24 <Welkin> don't bother messing around directly with inputting it into ghci
15:05:35 <Ed___> Ok. Thanks for the advice. I wont..
15:05:37 <Welkin> it's always easier to put it in a file and :load and :reload it
15:05:40 <erisco> but this is a lengthy function and so I would load it from file
15:05:41 <Ed___> Il just :l it in now
15:05:50 <Ed___> Thanks guys
15:05:53 <Ed___> and gals maybe
15:06:12 <erisco> wouldn't want to leave Welkin out
15:06:28 <Ed___> lolololol
15:06:30 <MarLinn> Btw, the paste thingy has two nice style tips
15:06:58 <Welkin> `[x] ++ rest` is just `x : rest`
15:07:02 <Ed___> i get the 2nd one. but 1st one doesnt make sense
15:07:13 <Welkin> ah yes the first one is nice too
15:07:25 <Ed___> thats debateable no?
15:07:28 <Welkin> x `elem` xs means "x is an element of xs"
15:07:39 <Welkin> it reads like englis
15:07:41 <Welkin> english*
15:07:49 <Ed___> elem x xs means element is x of xs
15:07:55 <erisco> it is debatable
15:07:56 <Welkin> same with x `isPrefixOf` xs
15:08:08 <erisco> so is the usage of $
15:08:16 <erisco> lpaste is opinionated ;)
15:08:20 <Welkin> it is personal preference
15:08:23 <Welkin> you can do it any way you like
15:08:28 <Ed___> if everything is pretty much written in prefix, then why include one function using infix...
15:08:38 <datesnstuff> What's an easy way to write a date literal using the time library?
15:08:39 <erisco> infix all the things
15:08:41 <Ed___> omg $ is amamzing
15:08:43 <Welkin> Ed___: there are lots of infix functions (all combinators)
15:08:49 <Welkin> sometimes it is cleaner to write them infix
15:08:50 <Ed___> right.
15:09:00 <erisco> I used $ and then I stopped, and maybe one day I'll use it again
15:09:02 <Welkin> and you can make any function infix by wrapping it in ` and `
15:09:08 <erisco> like some days I like braces on newlines and other days not *shrug*
15:09:20 <Welkin> I tend to use $ with compositions: x . y . z $ a
15:09:26 <Ed___> whyd you stop using $? thing is a lifesaver. saves minutes not having to count parantheses
15:09:33 <erisco> (x.y.z) a
15:09:40 <Welkin> erisco: no spaces? ew!!
15:09:47 <erisco> yeah I know, I'm awful
15:09:51 <minad> erisco: and with do?
15:09:59 <dmwit> datesnstuff: `parseTime`?
15:10:31 <MarLinn> ((. x (. y z)) a)
15:10:35 <erisco> Ed___, it doesn't as clearly reflect the AST
15:11:23 <erisco> and when the AST is obscured this sometimes obscures other insights
15:11:31 <Ed___> umm. how to correctly map print over a list of numbers?
15:11:38 <dmwit> :t mapM_ print
15:11:40 <lambdabot> (Foldable t, Show a) => t a -> IO ()
15:11:41 <Welkin> Ed___: mapM_
15:11:41 <datesnstuff> dmwit: I was looking for fromGregorianValid
15:11:44 <Welkin> well wait!
15:11:45 <Ed___> thanks
15:11:48 <Welkin> traverse_
15:11:50 <Welkin> :P
15:11:55 <Welkin> :t traverse_
15:11:56 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
15:11:58 <Welkin> :t mapM_
15:12:00 <lambdabot> (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
15:12:09 <datesnstuff> Can you add a month to a date in Haskell? I only see the Day type which doesn't have a Num instance it seems.
15:12:11 <Welkin> different names for the same thing
15:13:10 <dmwit> datesnstuff: addGregorianMonths{Clip,RollOver}
15:13:41 <Ed___> the more I use Haskell the more I'm starting to love it! So much easier to do these challenges in haskell than in c++. Lot's of one line answers where c++ would take much more work.
15:13:55 <Welkin> Ed___: yes, it will ruin you forever
15:14:00 <erisco> first you want to make a header file
15:14:02 <Welkin> you will hate programming in pretty much anything else
15:14:39 <minad> you could use transpilers ;)
15:14:40 <erisco> make sure to check with compiler pragmas that the header was not already loaded
15:14:44 <Ed___> You're right. Because I don't want to do any of these challenges in C++ anymore... I started doing Haskell because I'm Teaching a lab on haskell this semester.. 
15:15:02 <Ed___> kind of re-teaching myself in the process.
15:15:08 <Sonolin> yea that's the only bad part of haskell.. my love for all other non-fp languages have diminished quite a bit
15:15:22 <Sonolin> but it does make you a much better programmer (FP in general at least)
15:15:38 <Welkin> Sonolin: it teachs you to think about side effects
15:15:50 <Welkin> whereas you probably never think about side effects at all in other languages
15:16:21 <Welkin> because the design of most languages encourages you to do stupid things (designed to be abused)
15:16:50 <erisco> well you start with mathematical principles, conventions, and then you come to realise these computer languages are doing something else, and one of those things gets called "side effects"
15:16:55 <EvanR> side effects, state, numeric data issues, many things
15:17:07 <EvanR> haskell is a sobering experience
15:17:24 <EvanR> string encodings
15:17:34 <EvanR> concurrency
15:17:36 <minad> but I wouldn't praise haskell for strings
15:17:51 <EvanR> the Text type is really "string" in haskell
15:17:57 <erisco> that would be a mundane thing to praise any language for
15:17:59 <Rembane> Haskell and Python 3 is about as nasty when it comes to strings.
15:18:02 <erisco> "we have great strings"
15:18:04 <Welkin> minad: haskell String is amazingly fun and useful
15:18:10 <Ed___> how take min of a list? I think theres difinetely something better than foldl1 (min) [1..10]
15:18:16 <Rembane> Ed___: minimum
15:18:21 <Rembane> Ed___: Or min
15:18:24 <Welkin> minimum
15:18:27 <monochrom> tcl is praised for strings :)
15:18:33 <minad> hehe
15:18:35 <minad> i love that
15:18:39 <MarLinn> I'm gonna be a heretic now: I actually miss some of the flexibility and mathematical cleanliness of Lisp in Haskell. Not that I would switch any time soon, but it feels like Haskell is a truckload of stuff on top of the same great ideas.
15:18:39 <EvanR> stringly typed languages
15:18:50 <Ed___> but foldl min 0 [] does what i want and returns a 0 for an empty list
15:18:54 <Ed___> which I LOVE!
15:18:55 <Rembane> Awk and Perl are great for string manipulation!
15:19:03 <EvanR> mathematical cleanliness of lisp?
15:19:12 <monochrom> lisp does not have mathematical cleanliness
15:19:27 <dmwit> minimum :: [a] -> PosInf a
15:19:27 <minad> mathematical cleaniness? not in lisp?
15:19:30 <dmwit> http://hackage.haskell.org/package/monoid-extras-0.4.2/docs/Data-Monoid-Inf.html#v:minimum
15:19:35 <monochrom> it has flexibility. which is not a blessing either.
15:19:43 <dmwit> Oops, forgot the `Ord a` constraint, of course. ;-)
15:19:56 <hpc> the lisp programming style is to write code that generates more code
15:20:04 <hpc> liberal use of gensym is very common
15:20:05 <erisco> Ed___, meet the addition monoid
15:20:05 <monochrom> translate Haskell's or SML's "map f xs" to Lisp.
15:20:20 <hpc> gensym is literally hitler :P
15:20:34 <minad> I think the only point of lisp is that it is much easier to write a lisp
15:20:44 <Welkin> lol
15:20:50 <Welkin> because lisp is an AST
15:20:55 <minad> havent't you written one?
15:21:07 <monochrom> (Hint: It won't translate cleanly. You have to add some mumble jumble to say "I want to use f's function binding, not f's value binding".)
15:21:24 <monochrom> Overall most of Lisp's higher-order functions are a mess.
15:21:28 <Welkin> lol monochrom you mean common lisp?
15:21:29 <hpc> monochrom: what if f is a macro?
15:21:36 <erisco> :t getSum . foldr mappend mempty
15:21:38 <lambdabot> (Foldable t, Num c) => t (Sum c) -> c
15:21:38 <Welkin> because functions are only first class in scheme
15:21:45 <erisco> count the things in any listable
15:21:57 <monochrom> I don't know, hpc. And this is more mess than I am depicting.
15:22:18 <Gurkenglas> :t getSum . foldMap Sum
15:22:20 <lambdabot> (Foldable t, Num c) => t c -> c
15:22:25 <minad> did someone use this shen or how is it called? some typed lisp
15:22:29 <monochrom> Yes I am so glad I don't know. Keeps my brain unburdened. I am also glad I still haven't learned yacc and php.
15:22:31 <erisco> I was just going to put that Gurkenglas :D
15:22:37 <EvanR> minad: ive used shen
15:22:42 <hpc> monochrom: when f is a macro there's no first-class way to refer to it outside of other macros
15:22:55 <Gurkenglas> :t ala Sum foldMap -- Just another way to write the same thing, and with a lens dependency too x)
15:22:58 <EvanR> its kind of abandonware like its predecessor
15:22:58 <lambdabot> (Foldable t, Num b) => t b -> b
15:22:58 <minad> EvanR: is it statically typed? and how powerful is the type system?
15:23:19 <hpc> monochrom: so each higher and higher order of computation involves more and more code generation at runtime
15:23:22 <erisco> :t ala
15:23:24 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
15:23:25 <minad> EvanR: I won't use it. I cannot read lisp. I am just interested in general
15:23:41 <erisco> what fiendish thing is that
15:23:43 <EvanR> minad: no. but you can activate the typ checker which will attempt to derive the type of expressions using the built in deriving language, which is turing complete
15:23:43 <epictetus_> This question has been stumping me: "only one version will typecheck" co :: (b -> c) -> (a -> b) -> (a -> c)"
15:24:14 <erisco> someone has type classed newtypes?
15:24:16 <EvanR> minad: a given expression can have any number of types, the default is either "symbol" or function
15:24:21 <epictetus_> I tried co a b c = c, wouldn't that be returning a function that is (a -> c)?
15:24:37 <MarLinn> Well of course you need to add types and macros and syntax etc on top of lisp to get to Haskell. ;) But what I was getting at was that while what we have is more robust and usable, we also lost things like simplicity and macros
15:24:39 <minad> EvanR: uuh. maybe everything is function ;)
15:24:40 <EvanR> you can define more ways to derive the type of stuff using basically lisp code
15:24:50 <erisco> what is ala from?
15:24:57 <hpc> epictetus_: with that definition, co :: (type of a) -> (type of b) -> (type of c) -> (type of c)
15:25:06 <agocorona_> lisp  metaprogramming is unbeatable
15:25:17 <EvanR> MarLinn: that kind of wont make it a statically typed language
15:25:18 <hpc> epictetus_: which is a' -> b' -> c -> c
15:25:28 <minad> Well a while ago I thought that bootstrapping in a language is a good idea, but I don't think so anymore
15:25:41 <hpc> epictetus_: let a' = b -> c, b' = a -> b to make it look closer to what you want it to be
15:25:42 <monochrom> Lisp is not simple.
15:25:58 <minad> start from a lisp and add more and more high level features, add a type system add this and that
15:26:09 <minad> rather I prefer a clean core language. that's the way to go
15:26:10 <monochrom> (Same reason as why Lisp is not mathematically clean. See what I said above.)
15:26:10 <Welkin> minad: you mean start from scheme
15:26:21 <EvanR> i was very confused learning lisp, because anything can be anythinged, most people i talked to couldnt even explain what stuff was
15:26:24 <EvanR> unambiguously
15:26:35 <epictetus_> :hpc thanks, I'll take another look
15:26:40 <monochrom> Scheme is simple. I can agree to that.
15:26:47 <erisco> oh, lens, could have guessed
15:27:00 <hpc> i will agree with sceme being simple*r*
15:27:01 <EvanR> minad: start with a typed core language and then piss it away with a S expression type ;)
15:27:01 <minad> Welkin: yes, I didn't distinguish between lisp and scheme here. I meant scheme
15:27:04 <EvanR> better
15:27:10 <erisco> is lens just a bag for whatever now? lol
15:27:24 <EvanR> you can t go in vreverse
15:27:25 <Gurkenglas> erisco, I said so in the line where I used ala :c
15:27:31 <minad> EvanR: you can always embed the unityped lambda calculus ;)
15:27:42 <EvanR> in a typed language syes
15:27:49 <glguy> erisco: No, ala is quite in line with the rest of the library and foldMap and Sum aren't from lens
15:27:53 <EvanR> but you cant go the toher way, from lisp to a statically typed language
15:28:07 <Welkin> minad: because there is a huge difference between scheme (lisp-1) and common lisp (lisp-2)
15:28:13 <minad> yes I know
15:28:19 <monochrom> Lisp started with the idea "everything can be encoded as graphs of cons cells" which seemed simple on surface. But it got messy because they went crazy on that.
15:28:20 <erisco> glguy, I was just referring to ala. Maybe there is more breadth to the library than I realise. I never came to understand it
15:28:26 <Gurkenglas> http://lpaste.net/5015056341706735616 why doesn't this copy the exference.exe to my path?
15:28:42 <minad> Welkin: and also emacs lisp :D
15:29:21 <hpc> Gurkenglas: i don't see it building an executable
15:29:25 <hpc> just the library
15:29:40 <MarLinn> Ok, we don't have to go all the way down. But for example we have so much extra syntax that could be turned into (statically typed?) macros so new compilers would be easier to make. 
15:29:56 <monochrom> And no, it didn't even start on ideas of functional programming. Instead, I got wind of those ideas and added some of them.
15:29:57 <MarLinn> Or language extensions
15:30:03 <monochrom> s/I got/It got/
15:30:03 <erisco> the point of lens, as from what I could see, was this fstab thing, and to that extent I never quite got it
15:30:11 <minad> EvanR: you can also go the other way round by writing an interpreter type checker compiler etc. it is just much harder
15:30:26 <monochrom> But so does C# and even C++.
15:30:36 <Gurkenglas> ohhh right yea hexa_goxel without the _ even changed that on the parent repository. And stack init probably didnt add the executable-building because the .cabal is done wrong
15:30:37 <minad> I like lens :)
15:30:44 <EvanR> you can create a whole tool chain in lisp yes, but thats really hard
15:30:59 <minad> this is what I meant before. embedding one way is easy the other way not
15:31:01 <EvanR> you can create a lisp with one screen of haskell code
15:31:07 <Gurkenglas> https://github.com/Gurkenglas/exference/blob/master/exference.cabal <- what in this .cabal causes stack init --solver not to add executable-building?
15:31:31 <minad> EvanR: and that's the point of lisp. It is such a good thing for learning
15:31:51 <EvanR> learning something at least
15:31:56 <hpc> Gurkenglas: good question, it looks like that should be building it
15:31:59 <minad> I mean teach some people in a few days how to write an interpreter. how could you do that otherwise?
15:32:04 <sm> Gurkenglas: cabal can flip that flag off any time to make its life easier, unless you set Manual: true on it
15:32:12 <EvanR> there are nicer toy languages to create with a screen of code
15:32:24 <erisco> there are lots of languages with a small number of instructions and easy syntax
15:32:43 <erisco> but a common exercise is a calculator
15:32:44 <minad> hmm, but syntax = ast makes it easier. I like it for that at least.
15:32:50 <EvanR> no it doesnt
15:32:53 <hpc> sm: bwaaaaaaah?
15:33:17 <hpc> sm: that is some perl-level weird
15:33:18 <minad> EvanR: you could also write a metacircular interpreter
15:33:23 <erisco> every time someone says the syntax and AST I lose them ‚Ä¶ these are not the same thing
15:33:32 <sm> I know, it's a stupid feature :) (but well known)
15:33:42 <erisco> says the syntax is the AST and vice versa
15:33:44 <minad> in lisp they are
15:33:48 <sm> cabal can toggle flags at will to satisfy deps, unless you opt out of that
15:33:54 <hvr> sm: well, manual flags and automatic flags are not a stupid feature ;)
15:33:54 <merijn> minad: They're really not
15:33:59 <EvanR> that makes the difference harder
15:34:00 <hpc> erisco: my professor said that lisp had no syntax, and then said that read macros are programmable syntax
15:34:01 <minad> ok, please explain
15:34:03 <EvanR> to understand
15:34:13 <erisco> yes, then it goes on to wild claims like these hpc :P
15:34:16 <EvanR> syntax=AST is confusing 
15:34:23 <EvanR> its also not even correct to say that thats what it is in lisp
15:34:27 <EvanR> which is really confusing
15:34:38 <erisco> Lisp is a magical entity in its manifestation
15:34:49 <EvanR> also "meta circular interpreter" ...
15:34:52 <minad> you mean AST as the in-memory representation?
15:34:55 <erisco> not a mere line of characters, no, it is much more
15:35:01 <EvanR> wtf is that supposed to imply
15:35:29 <EvanR> AST as in a object of some formal language
15:35:46 <EvanR> as opposed to concrete syntax
15:35:50 <minad> I agree that one can say that
15:35:53 <EvanR> lisp doesnt seem to think theres a difference
15:36:40 <EvanR> the difference is very useful to avoiding dwelling on minutia of language design
15:36:54 <minad> but to keep it simple. if you have a compiler like for haskell
15:37:11 <minad> the *.hs file contains syntax and the parser output is an AST?
15:37:21 <minad> is this ok to say in your opinion?
15:38:10 <EvanR> sure, and we dont want to program directly in the AST
15:38:11 <erisco> minad, and to be fair you could explain how Lisp syntax is the same as the AST. I have yet to hear a coherent answer on this
15:38:17 <Gurkenglas> sm, so if I add "  Manual: true" between lines 57 and 58 stack init --solver into stack install will do the right thing?
15:38:30 <EvanR> and you dont want to process the ascii text with TH
15:38:48 <sm> Gurkenglas: best to try it
15:38:49 <minad> EvanR: ok
15:38:57 <sm> I would think so
15:38:59 <monochrom> yes,  a compiler is most likely to have its internal AST representation.
15:39:32 <minad> erisco: If I say it more precisely. the lisp syntax is a very simple serialization format of the lisp ast
15:39:47 <monochrom> I agree with minad.
15:39:52 <erisco> no argument there
15:39:53 <EvanR> thats true
15:39:56 <minad> but = is not right in the precise sense
15:39:57 <hpc> or perhaps yet more precisely, the lisp syntax is a mapping from text to AST?
15:40:13 <erisco> could have chosen RPN though
15:40:15 <Gurkenglas> (asking because then I have to delete the stack.yaml to see whether it actually works and there might be something else that Ill need to do with the stack.yaml that I knew last time but forgot by now, and those caveats just keep accumulating, so I try to try as little as possible with the terminal stuff)
15:40:19 <hpc> unless you're going to say with seriousness that the lisp AST admits unbalanced parens
15:40:25 <sm> cabal flags are really best avoided, except when absolutely necessary. They complicate your life
15:40:47 <EvanR> however real lisp code is more complex than just S expressions
15:40:47 <hvr> sm: that I agree with
15:40:54 <EvanR> on paper
15:41:26 <EvanR> they have all grown legs in one way or anoher because just S expressions is horrible
15:41:58 <erisco> clearly Lispers believe in some manner of pragmatism, because they don't use RPN
15:42:13 <minad> erisco: maybe one could also say that, the AST = syntax in lisp, because if I read in the syntax and dump it again it looks like before ;)
15:42:33 <erisco> minad, and what language can't you say that for?
15:42:52 <EvanR> minad: what, no you lose original formatting
15:42:55 <minad> well if I use show for the GHC AST it doesn't look at all as haskell
15:42:56 <hpc> "read in the syntax"?
15:43:07 <minad> I mean it looks like the datastructure haskell
15:43:07 <EvanR> as in read-macros
15:43:08 <hpc> if you read in a program and dump it again, you've lost whitespace and comments
15:43:30 <hpc> oh yeah you do lose read macros too
15:43:35 <minad> hpc: true, let's say modulo comments
15:43:39 <MarLinn> EvanR, Lisp was never intended to stay at S-Expressions. They were originally only meant to be the Lisp-equivalent of GHC-Core. It's more or less an accident of history that they became "the language"
15:43:45 <minad> hpc uuh now it gets complicated
15:44:01 <minad> MarLinn: I think they wanted M-expressions?
15:44:03 <minad> whatever that is
15:44:08 <EvanR> hpc: in MOO the comments are preserved in the assembly, when it decompiles for editing you have your comments back ;)
15:44:10 <erisco> omega expressions
15:44:18 <sm> crazy lispers, they should get on and finish their language
15:44:22 <EvanR> because by convention you write comments in floating string literals
15:44:23 <merijn> MarLinn: Hell, McCarthy didn't think lisp was implementable until one of his grad students did it over the weekend iirc
15:44:27 <minad> hehe
15:45:01 <erisco> just like you write comments in Haskell as  const (+1) "adds one to a number"
15:45:16 <minad> I have yet to see that in code
15:45:38 <MarLinn> merijn: Steve Russell, if I remember correctly. Gonna name my reduced Haskell "Steve" I guess, when I finally manage to "show you all" XD
15:45:52 <EvanR> another way to say asyntax=AST in lisp is that lisp doesnt have syntax
15:45:58 <minad> yes
15:46:11 <EvanR> which really pisses people off if you say that ;)
15:46:16 <erisco> by defining "Lisp" out of the linear text representation?
15:46:23 <minad> but it is so easy to write parsers these days that there is no need for no syntax
15:46:23 <MarLinn> minad, I've read on the wiki that some Lispers consider Haskell to be basically the M expressions they were searching for...
15:46:26 <erisco> oh that text file containing parentheses and stuff isn't really Lisp
15:46:34 <minad> MarLinn: great!!!
15:46:46 <monochrom> this is a good time to say: what have I done?!
15:46:56 <hpc> is lisp the x86 of core languages?
15:47:09 <merijn> monochrom: No take backsies!
15:47:55 <erisco> well, I'll tell you, Haskell doesn't have syntax either, only the semantic denotation that floats in the academic mind can be called Haskell
15:48:20 <monochrom> What is Haskell?  <duck>
15:48:30 <ReinH> Haskell is an idea, man.
15:48:52 <merijn> monochrom: A first name
15:49:36 <hpc> didn't he hate his name?
15:49:41 <hpc> or am i misremembering
15:49:42 <minad> :D
15:49:48 <hpc> it's a pretty weird name
15:50:06 <merijn> hpc: He was not particularly fond of it
15:51:03 <merijn> hpc: At least, at IFL a few years ago there was a "History of Haskell" talk, and I remember them saying they asked Curry's wife for permission to use his name and she said "sure", but pointed out he was never really happy with it. Not sure if that qualifies as hating it
15:51:40 <hpc> well i am happy with it :D
15:51:55 <hpc> he continues a long and proud tradition of mathematicians having names that you can tell from a mile away belong to mathematicians
15:53:22 <minad> so if you want your child to become a mathematican...
15:54:12 <EvanR> in curry's time they hadnt invented the /nick command yet  
15:54:59 * EvanR looks around at all the weirdo's choice of names , this is what youd get if people could choose
15:55:51 <monochrom> I don't think letting parents choose is all that better.
15:56:16 <MarLinn> I must say I can imagine some of the nicks here as programming language names
15:57:49 <monochrom> IRC nickname choice is quite different from real-life name choice. In IRC you have more worry about name clashes. You are inclined to be deliberately weird.
15:58:06 <Welkin> people change their names all the time
15:58:17 <shachaf> Why would you not worry about name clashes outside IRC?
15:58:17 <monochrom> Because for example "monochrom" is so much more unique than "albert"
15:58:24 <drdo> Or you're just unoriginal like me and go for the real life name initials
15:58:47 <monochrom> I don't know. But it's true.
15:59:14 <Welkin> drdo seems like a reference to the arcade game https://en.wikipedia.org/wiki/Mr._Do!
15:59:40 <drdo> Welkin: I didn't even know that existed!
15:59:55 <drdo> But yes, it has the cool property that it can be pronounced "Dr. Do"
16:01:44 <geppettodivacin> Which version of ghc added ApplicativeDo? I'm trying to build with 7.10.3 and it claims Unsupported extension.
16:01:52 <minad> 8?
16:02:13 <kadoban> 8, yeah.
16:02:41 <geppettodivacin> Looks like I've got a good reason to finally upgrade! :)
16:02:42 <minad> are you using PatternSynonyms btw?
16:02:53 <minad> I always have problems with the exhaustiveness checker
16:03:30 <minad> is this completely not implemented?
16:06:01 <minad> what's the point of applicativedo? why not use applicative operators?
16:06:27 <hiptobecubic> It makes many things easier to read, same with monads
16:06:53 <hiptobecubic> And it also means you don't have to go back and rewrite a bunch of code to take advantage of AMP
16:06:59 <hiptobecubic> or whatever it was called
16:07:01 <minad> yes ok
16:07:02 <merijn> minad: Wanting best of both worlds. i.e. monadic formulation being more readable, but wanting as much of applicative's speed as possible
16:07:08 <minad> I would like idiom brackets
16:07:20 <minad> if I would wish for a special applicative syntax
16:08:06 <hiptobecubic> I had no trouble thinking about applicatives when looking at do notation, for whatever reason. I think it works well.
16:08:37 <Sonolin> can anybody explain why I could be getting this error when implementing MonadError instance?
16:08:40 <Sonolin> Only one type can be given in an instance head.
16:09:08 <Sonolin> I tried something simple like "instance MonadError Int MyMonad where { ... }" and I get that error
16:09:50 <hpc> can you paste your code?
16:09:52 <hpc> @laste
16:09:53 <lambdabot> Haskell pastebin: http://lpaste.net/
16:10:05 <hpc> <3 levenstein distance
16:10:33 <Sonolin> http://lpaste.net/3487442122125082624
16:11:03 <hpc> Sonolin: and the error you get?
16:11:21 <Sonolin> http://lpaste.net/6145970996529594368
16:11:51 <hpc> Sonolin: ah cool, try {-# LANGUAGE MultiParamTypeClasses #-} at the top of your file
16:12:09 <Sonolin> oh... I don't recall that being necessary for my previous State requirements
16:12:11 <hpc> it tells you what to do in the error message, though not in so many words
16:12:24 <Sonolin> is that always necessary with typeclasses like that?
16:13:40 <hpc> see if it works first, but i believe so
16:15:12 <Sonolin> hmm that worked... needed a couple more extensions though for my types
16:15:33 <Sonolin> just weird because I've done quite a bit of work with MonadState and don't ever recall that being necessary
16:16:00 <hpc> now that you have it working, try reducing down the extensions you're using to a minimal set
16:16:24 <hpc> it's been a while since i looked at the type class-y extensions but maybe you just need FlexibleInstances?
16:16:31 <Sonolin> yea FlexibleInstances
16:16:36 <hpc> if you needed more than just MPTC
16:16:40 <Sonolin> and also wanted TypeSynonyms (since my real failure type is String)
16:16:45 <hpc> oh cool
16:17:32 <ardu> can someone help me understand sections? i don't understand this:
16:17:42 <ardu> > let (^^) x y z = [x,y,z] in (^^ 7) 9 12
16:17:44 <lambdabot>  [9,7,12]
16:18:00 <ardu> why 7 in the middle? i'd expect it to be either rightmost or leftmost, but definitely not middle
16:18:29 <hpc> ardu: to the right, the (x *) section translates to (*) x
16:18:37 <Sonolin> ah yea MonadState does require MultiParamTypeClasses... thanks hpc all makes sense now :)
16:18:42 <hpc> ardu: to the left, the (* x) section translates to \y -> (*) y x
16:19:36 <hpc> so it's doing ((\y -> (^^) y 7) 9) 12
16:19:47 <ardu> hpc: if (x *) translates to (*) x then above would have to be [7, 9, 12]?
16:20:01 <Welkin> ^^ is the "happy anime eyes" operator
16:20:12 <ardu> ^^
16:20:14 <hpc> ardu: yes, if you wrote that section the other way around :D
16:20:29 <Welkin> ^+^ is the bat of doom
16:21:02 <hpc> ardu: in general haskell doesn't have a concept of the number of arguments a function takes
16:21:03 <ardu> oh i confused the directions of what you meant by to the right / to the left
16:21:17 <hpc> ardu: (which is what you need to determine the "last" argument a function takes)
16:21:24 <hpc> for instance, id obviously takes one argument
16:21:26 <hpc> @src id
16:21:26 <lambdabot> id x = x
16:21:35 <hpc> > id (*) 5 10 -- but here it takes 3
16:21:37 <lambdabot>  50
16:22:13 <hpc> but anyway, now you know the exact translation that sections receive
16:22:17 <hpc> more or less
16:22:20 <ardu> wait, you just really confused me
16:22:21 <EvanR> clearly haskell is variadic!
16:22:31 <hpc> ardu: consider it a teaser for future learning :D
16:22:43 <ardu> id (*) 5 10 - isn't id taking the single argument "(*) 5 10" ?
16:22:58 <Forlorn> Hi, what books are recommended for learning Haskell?
16:23:13 <hpc> ardu: id takes (*)
16:23:29 <ertes> @let (-.-) = flip logBase
16:23:30 <lambdabot>  Defined.
16:23:40 <hpc> ardu: and then (id (*)) takes 5, and that takes 10
16:24:00 <EvanR> f x y z = (((f x) y) z
16:24:17 <hpc> ardu: id (*) 5 10 is actually (((id (*)) 5) 10)
16:24:19 <EvanR> oops
16:24:27 <hpc> ardu: so here's the neat part
16:24:32 <hpc> ardu: id (*) = (*)
16:24:42 <hpc> (*) 5 10 = 5 * 10 = 50
16:24:53 <ardu> yes i see that now
16:24:59 <hpc> :D
16:25:02 <ardu> but is it correct to say that 'id takes 3 arguments' in this case?
16:25:11 <Welkin> no
16:25:17 <ardu> isn't it that id takes a single argument (*) which gives us a function which takes 2 arguments?
16:25:18 <Welkin> all haskell functions have one parameter
16:25:31 <hpc> in some sense you can say it's given 3 arguments
16:25:32 <ertes> Forlorn: http://www.cs.nott.ac.uk/~pszgmh/pih.html
16:25:38 <hpc> but in a more useful sense, what Welkin just said
16:26:01 <hpc> you can get a lot of mileage out of functions always taking exactly one parameter
16:26:15 <hpc> in terms of reasoning about what's possible and what's not
16:26:27 <Forlorn> what about http://haskellbook.com/index.html ?
16:26:52 <shachaf> I don't recommend that book.
16:26:54 <ardu> so let me know if i get this straight. what's really happening is: id takes (*) which gives back (*). then (*) takes 5 which gives back (* 5). then that takes 10 which gives 50
16:26:58 <shachaf> Based on the excerpts I've seen of it, at least.
16:27:04 <EvanR> in a -> b -> c -> d , theres an equivalent function that does take 3 arguments, (a,b,c) -> d
16:27:05 <hpc> ardu: yep, almost
16:27:15 <hpc> (5 *) though that's basically the same
16:27:25 <hpc> it becomes very important if you're using something like (/) though ;)
16:27:30 <EvanR> though in that case its still one tuple argument, but this is how it is in most other languages
16:27:41 <ardu> oh i confused directions again
16:27:54 <epictetus_> I get "error: parse error on input ‚Äò10‚Äô" with numFromThenTo '0' '10' '100', is this a bug in ghci?
16:27:58 <ardu> hpc: thanks :)
16:27:58 <hpc> you'll get used to it
16:28:15 <hpc> Forlorn: the current community choice is the CIS194 course materials
16:28:22 <epictetus_> enumFromThenTo
16:28:27 <ertes> there is a community choice?
16:28:27 <Welkin> epictetus_: show your code
16:28:39 <Welkin> > enumFromThenTo 0 10 100
16:28:40 <epictetus_> enumFromThenTo '0' '10' '100'
16:28:41 <lambdabot>  [0,10,20,30,40,50,60,70,80,90,100]
16:28:42 <glguy> ertes: Didn't you get your ballot?
16:28:45 <hpc> Forlorn: my advice is to go with that first, get as far as you can, and then start going through multiple other materials
16:29:02 <Welkin> epictetus_: those are not numbers
16:29:07 <ertes> i must have sleepwalked filling out that survey =)
16:29:10 <hpc> not everything covers the same concepts, some cover them better, some cover them in different orders
16:29:26 <Welkin> :t enumFromThenTo '0' '10' '100'
16:29:28 <lambdabot> error: parse error on input ‚Äò10‚Äô
16:29:34 <Welkin> :t enumFromThenTo
16:29:36 <lambdabot> Enum a => a -> a -> a -> [a]
16:29:44 <Welkin> '0' is not anything
16:29:51 <hpc> i liked LYAH, but it has some flaws wrt exercises and some people get annoyed by the very casual tone
16:29:56 <Welkin> well, it is the character 0
16:30:05 <Welkin> '10' doesn't make sense
16:30:07 <minad> Forlorn: I recommend Stephen Diehl's what I wish if you like it dense
16:30:10 <Welkin> :t '10'
16:30:12 <lambdabot> error: parse error on input ‚Äò10‚Äô
16:30:21 <hpc> RWH is decent, i didn't really like it that much and nowadays it's rather out of date as far as libraries it uses
16:30:29 <hpc> but a lot of other people like it
16:30:39 <hpc> the wikibook is good for some select topics
16:30:52 <epictetus_> oh, duh
16:31:00 <hpc> bitemyapp's github has some other good information on how to learn haskell too
16:31:02 <epictetus_> '10' can't be Char
16:31:31 <Welkin> epictetus_: if you want to count from 0 to 100 with a step of 10 and output the result as strings, just map show over it
16:31:45 <Welkin> > map show $ enumFromThenTo 0 10 100
16:31:47 <lambdabot>  ["0","10","20","30","40","50","60","70","80","90","100"]
16:33:44 <Forlorn> minad, link?
16:34:01 <Forlorn> hpc, thanks
16:34:42 <hpc> Forlorn: the key thing is having those multiple resources so you aren't getting stuck
16:34:50 <hpc> and if you get /really/ stuck, asking here :D
16:35:22 <minad> Forlorn: dev.stephendiehl.com/hask
16:36:56 <minad> Forlorn: but this is more like a reference to look up some things. I think it is pretty complete
16:36:58 <ardu> why does the language spec say "Sections are a convenient syntax for partial application of binary operators" when we can apply them to operators of more than 2 arguments?
16:37:25 <minad> after you understood most of the basics you should be fine just with the reference, haddock and example codes
16:37:32 <shachaf> An operator of more than two arguments is still an operator of two arguments.
16:37:54 <hpc> ardu: basically a bit of plain english
16:38:26 <glguy> operators require two arguments when used in infix form without special extensions. The result of applying an operator to two arguments can be a function
16:38:27 <hpc> the spec is a combination of technical language, plain english explanations, and "you already know what we're talking about" english language
16:39:17 <MarLinn> :t (,2,,"what?",)
16:39:19 <lambdabot> Num t1 => t -> t2 -> t3 -> (t, t1, t2, [Char], t3)
16:39:27 <EvanR> noice
16:39:28 <hpc> oh god lambdabot has tuple sections
16:39:44 <glguy> MarLinn: That's an extension, not Haskell
16:40:01 <EvanR> -XNotHaskell
16:40:19 <MarLinn> Haskell is whatever you want it to be
16:40:34 <hpc> can haskell be php?
16:40:44 <MarLinn> you don't want that, so no
16:40:46 <glguy> No, in the context of understandning the Haskell Report Haskell is what's described in the report
16:41:03 <hpc> MarLinn: too late, i already wrote it :D
16:43:19 <ertes> @package acme-php
16:43:19 <lambdabot> http://hackage.haskell.org/package/acme-php
16:44:21 <ardu> well, since you guys told me above that actually functions only take 1 argument - so let me see if i get this right - a binary operator is a function which takes an argument and returns a function which takes an argument and which returns something that could possibly be another function. ?
16:45:41 <MarLinn> Yes
16:45:42 <glguy> ardu: Yeah, the fact that operators used in infix form need to be applied to two arguments is syntactic.
16:45:50 <kadoban> ardu: When you use infix syntax with an operator, you must supply two arguments. There's no choice. If you don't want to do that, you can use sections or use prefix syntax.
16:46:04 <ardu> great, thanks
16:46:09 <glguy> > let (+++) = 1 in (+++) + 2
16:46:11 <lambdabot>  3
16:46:16 <MarLinn> > let (?) p t f = if p then t else f in True ? "Look, ma, " $ " interfix operators!"
16:46:19 <lambdabot>  "Look, ma, "
16:46:28 <kadoban> glguy: xD
16:46:55 <glguy> The two argument requirement is just when you use it in the infix position in the syntax, it doesn't restrict the actual type
16:47:17 <kadoban> Yes, other than defaulting to infix syntax, operators work just like functions in every way I know of.
16:47:32 <EvanR> :t let (+) = fmap in (+) + (+)
16:47:33 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
16:47:57 <ardu> glguy: what did you do there? now (+++) is not an operator/function as it's just a constant..but it looks like an operator?
16:48:00 <glguy> If you use a non-operator in infix position, it needs to be applied to two arguments, also
16:48:25 <glguy> ardu:  (+++) is a name
16:48:27 <jonored> > (const 5) `id` 3
16:48:29 <lambdabot>  5
16:48:36 <glguy> x +++ y   is (+++) being used in an infix application
16:48:50 <glguy> stuff is a name,  x `stuff` y is stuff being used in an infix application
16:52:13 <glguy> ardu: +++ is an "operator" because it's made out of symbols, not because of its type
16:53:08 <ardu> MarLinn: in your example above with (?) p t f, what exactly is going on? "True ? 1 $ 2" gets translated to ? True 1 $ 2, but then how does that get translated to sending ? the 3 arguments True, 1 and 2?
16:53:26 <ardu> glguy: aha i see. it's just a different type of name?
16:53:33 <hpc> ($) is an operator with lower precedence
16:53:37 <glguy> True ? 1 $ 2 is translated to:   ($) (True ? 1) 2 
16:53:42 <hpc> so it's parsed as (true ? 1) $ 2
16:53:47 <glguy> which is: ($) ((?) True 1) 2
16:54:03 <glguy> ardu: Yeah
16:54:11 <hpc> it's also terrible code which you should never do ever in your life
16:55:25 <ardu> where is $ defined? is it Prelude?
16:55:47 <geshe> in ghci, is there a way to call a function from a module that wasn't exported
16:57:14 <glguy> ardu: It's exported from Prelude, it's technically defined somewhere else
16:59:17 <MarLinn> geshe: yes, if you load that module via :load. Yes, if it's exported from anywhere. No in all other cases
16:59:47 <geshe> MarLinn: thanks!
17:00:42 <ardu> glguy: what do i have to do if i want to see its definition?
17:01:31 <glguy> ardu: Go to the haddock documentation for Prelude and click the source link
17:01:37 <glguy> ?hackage base
17:01:37 <lambdabot> http://hackage.haskell.org/package/base
17:03:01 <ardu> mmm where am i going to find it in there?
17:03:48 <ardu> oh nm i think i found it
17:03:54 <glguy> ardu: In the Prelude module link on that page
17:04:15 <glguy> There's also an index page that is easier to search through when looking for a specific name
17:04:37 <ardu> but where is the source? http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#v:-36-
17:04:45 <MarLinn> ardu, I suppose it might get a bit more confusing if you find the definition. I really only needed it for the lower precedence because kadoban was right: functions in the infix position take exactly two arguments
17:05:09 <glguy> ardu: Click "Source"
17:05:24 <ardu> d'oh. thanks!
17:05:28 <glguy> If you have a big monitor, turn your head to the right :)
17:06:01 <ardu> so $ f x is just f x.
17:06:25 <MarLinn> yup
17:07:09 <jle`> ardu: ($) f x = f x
17:07:21 <jle`> ardu: typically the definition people use is f $ x = f x :)
17:07:34 <ardu> i think i get it. doing a b $ c is the same as doing a (b c) ?
17:07:43 <glguy> no
17:07:51 <jle`> ardu: not quite, function application has higher precedence than $
17:07:57 <jle`> so "apply a to b" binds tightest
17:08:00 <kadoban> $ is *very* low precedence, and function application is much much higher.
17:08:01 <jle`> it's (a b) $ c
17:08:49 <jle`> yeah, you usually consider $ to have the lowest precedence in anything you use it with, so it loses out over almost literally everything else
17:09:13 <jle`> for example, f $ x + y is (f) $ (x + y), because + binds tighter than $
17:09:54 <ardu> i'm gonna save what you guys said in some file and look at it tomorrow, apparantly too much haskell for one day. :)
17:10:21 <ardu> thanks guys for being so helpful.
17:11:03 <kadoban> ardu: Breaks are indeed important. See you tomorrow :)
17:12:34 <ardu> yes it's weeknd so i'll definitely get to it tomorrow. during the week i'm swamped with PHP, this is a hobby to keep sane
17:13:26 <kadoban> Nice
17:13:52 <asdfkaba> glkn
17:16:19 <ahsfhyicxv> Is there an implementation of MonadZero for the transformers library?
17:34:59 <jle`> ahsfhyicxv: what do you mean exactly?
17:35:12 <jle`> a separate package that defines the MonadZero typeclass and provides instances for transformers types?
17:35:32 <ahsfhyicxv> jle`: yes
18:13:15 * hackagebot courier 0.1.1.4 - A message-passing library for simplifying network applications  https://hackage.haskell.org/package/courier-0.1.1.4 (PhilHargett)
18:15:19 <EvanR> "Most number-theoretic functions definable using recursion on a single variable are primitive recursive" from wikipedia
18:16:06 <EvanR> is "most" use here to mean in the set theoretic sense, exagerating, or just wrong?
18:16:52 <Cale> EvanR: Just in the practical sense
18:17:04 <Cale> Most of the number theoretical functions that people care about
18:17:11 <EvanR> ok
18:17:48 <EvanR> ackermann?
18:18:40 <EvanR> isnt primitive recursive. so i wonder whats so uninteresting about most non primitive recursive functions
18:23:08 <EvanR> is primitive recursive the same as inductively definable
18:43:35 <sgronblo> Hello, could someone help me figure out this: addHeaders ‚à∑ HTTP.ResponseHeaders ‚Üí WAI.Middleware
18:43:38 <sgronblo> addHeaders hdrs app req respond = 
18:44:14 <sgronblo> The function takes a "HTTP.ResponseHeaders" in the type signature, but the actual defintion takes four values?
18:47:33 <sgronblo> Is it some sort of unexpected destructing pattern I don't understand?
18:48:55 <geekosaur> type Middleware = Application -> Application
18:49:02 <glguy> sgronblo: WAI.Middleware must  be a type synonym for a function
18:49:48 <geekosaur> type Application = Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived
18:51:49 <MarLinn> in other words addHeaders ‚à∑ ResponseHeaders -> (Application -> (Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived))
18:51:51 <sgronblo> Ah its the middleware function thats kind of "destructured"
18:52:22 <sgronblo> Thanks
19:04:10 <nitrix> glguy: It's not my habit of asking people directly but I have a feeling your answer is going to resonate with me instantly.
19:04:13 <nitrix> :k Functor
19:04:14 <lambdabot> (* -> *) -> Constraint
19:04:16 <nitrix> :k Applicative
19:04:18 <lambdabot> (* -> *) -> Constraint
19:04:32 <hseg> Hi. In response to http://mail.haskell.org/pipermail/beginners/2016-July/017005.html, I've been trying to figure out how to define setjmp/longjmp in Cont. Is it as impossible as it seems to me?
19:04:36 <nitrix> I was expecting the kind of (,) to be :: Constraint -> Constraint -> Constraint.
19:04:46 <nitrix> Instead, it's * -> * -> *.
19:04:48 <nitrix> In fact:
19:04:50 <nitrix> :k Constraint
19:04:52 <lambdabot> *
19:04:52 <jle`> (,) is hopelessly overloaded at the type level
19:04:53 <glguy> nitrix: (,) is magic
19:05:04 <nitrix> glguy: What's going on here, I thought Constraint was a kind, not a type.
19:05:21 <jle`> :k *
19:05:23 <lambdabot> error:
19:05:23 <lambdabot>     Not in scope: type constructor or class ‚Äò*‚Äô
19:05:23 <lambdabot> error: Operator applied to too few arguments: *
19:05:28 <glguy> nitrix: :k Constraint is part of the TypeInType story
19:05:33 <nitrix> Oh!
19:05:43 <glguy> type Type = * so that you can talk about * with letters
19:06:13 <jle`> nitrix: * -> * -> * is the "obvious" kind of (,) in that it's the kind of (,) in its most common usage
19:06:26 <jle`> as the tuple type constructor
19:06:36 <nitrix> But lambdabot is still using the older GHC no? Why is the kind of Constraint :: * ?
19:06:38 <jle`> :k (,) Int Bool
19:06:40 <lambdabot> *
19:06:41 <glguy> Similarly () is the unit type and also the empty constraint
19:06:44 <hseg> Specifically, the problem I see is that in order for setjmp/longjmp to make sense, setjmp needs to be sort of like callCC, except that it passes its continuation through bind instead of regular application. I don't see how to recover a continuation that way.
19:06:54 <glguy> nitrix: Lambdabot is GHC 8 now
19:06:59 <nitrix> o: !
19:07:11 <hseg> Nice
19:07:12 <jle`> @tell o !
19:07:12 <lambdabot> Consider it noted.
19:07:26 <nitrix> :t map @Int
19:07:28 <lambdabot> error:
19:07:28 <lambdabot>     Pattern syntax in expression context: map@Int
19:07:28 <lambdabot>     Did you mean to enable TypeApplications?
19:07:40 <nitrix> glguy: That's very neat. That answers everything then.
19:07:47 <glguy> Yay!
19:08:06 <nitrix> int-e: Is it possible to have TypeApplications enabled for lambdabot?
19:08:06 <jle`> :k (,) (Monoid Int)
19:08:08 <lambdabot> error:
19:08:08 <lambdabot>     ‚Ä¢ Expected a type, but ‚ÄòMonoid Int‚Äô has kind ‚ÄòConstraint‚Äô
19:08:08 <lambdabot>     ‚Ä¢ In the first argument of ‚Äò(,)‚Äô, namely ‚ÄòMonoid Int‚Äô
19:08:20 <jle`> i guess (,) for constraints is syntax magic
19:08:33 <jle`> interestingly enough  (,) also can be interpreted to have kind a -> b -> (a, b)
19:08:37 <hseg> Like the typing of ($)?
19:08:39 <jle`> :k '(,)
19:08:41 <lambdabot> a -> b -> (a, b)
19:11:50 <MarLinn> I know nothing about the topic but I have a feeling that what seems like heavy overloading for now is just a figment of the inability of the current tools to express the deeper connection between the actual structures
19:12:08 <glguy> Prelude GHC.Types> type Tuple (a :: Constraint) b = (a,b) === Prelude GHC.Types> :i Tuple === type Tuple (a :: Constraint) (b :: Constraint) = (a, b) :: Constraint
19:13:58 <jle`> MarLinn: the (,) vs. '(,) thing is sort of the same as Identity and 'Identity, so it's consistent with the rest of haskell
19:14:23 <ertes> :k (':)
19:14:24 <lambdabot> error: Operator applied to too few arguments: :
19:14:28 <ertes> :k '(:)
19:14:29 <glguy> '(,) relates nicely to the normal (,) via DataKinds
19:14:30 <lambdabot> a -> [a] -> [a]
19:14:41 <jle`> :k Identity
19:14:43 <lambdabot> * -> *
19:14:43 <glguy> magic constraint (,) comes from ConstraintKinds and is the hack
19:14:45 <jle`> :k 'Identity
19:14:47 <lambdabot> a -> Identity a
19:14:50 <ertes> that feels like a weird syntax choice
19:15:21 <jle`> the (,) in constraints is indeed the hack, but you might be able to think about it as a method of some sort of kind-class
19:15:47 <jle`> so it's both * -> * -> * and Constraint -> Constraint -> Constraint
19:16:06 <nitrix> Mhm. Thanks glguy, glguy.
19:16:23 <jle`> and the '(,) is from normal DataKinds stuff like other constructors, it's mostly unfortunate because the type constructor has the same name as the value constructor
19:16:43 <jle`> amateur mistake
19:17:05 <ertes> -XLessSpecialComma
19:17:21 <glguy> -XYouKnowWhatIMeant
19:17:37 <jle`> people always say to not name your data constructors the same as your type constructors because it causes confusion, but nobody actually takes the advice
19:18:03 <ertes> jle`: it's too late for that advice
19:18:33 <MarLinn> kind family (KindStuff a, KindStuff b) => (,) a b :: (,) a b  -- ;)
19:18:57 <dolio> I take that advice.
19:19:17 <jle`> half of the types defined in 'base' laugh at that advice
19:19:30 <ertes> class Comma a b c | a b -> c where (,) :: a -> b -> c
19:19:41 <jle`> i think it can be simpler than that
19:20:11 <jle`> class Comma a where type (,) (x :: a) (y :: a) :: a
19:20:13 <dolio> More than half the types in base were written before anyone thought GHC would be approximating dependent types.
19:20:25 <jle`> the advice came before dependent types
19:20:37 <jle`> well, dependent types in haskell
19:20:56 <ertes> we'll more likely learn to embrace the apostrophe
19:20:57 <jle`> mostly newbies getting confused by type constructors and data constructors having the same name
19:22:15 <dolio> Yeah, it was still good advice back then, but now we're in an extra bad situation.
19:22:38 <ertes> after all, if you actually follow the advice and rename your MyType newtype's constructor, what are you going to rename it to?  probably M or MyTypeC or something
19:22:49 <ertes> at least the apostrophe would be a common ground
19:22:55 <ertes> s/would be/is/
19:23:20 <jle`> it's just too impractical to think of two different names when defining a newtype or single-constructor type
19:23:27 <lpaste> glguy pasted ‚Äúmagic ,‚Äù at http://lpaste.net/180399
19:23:35 <jle`> data Sum a = MkSum { getSum :: a } ?
19:23:46 <jle`> then there's the burden of the user having to remember the name of the constructor
19:24:12 <niffyjiffy> hey how are you all doing
19:24:12 <nitrix> int-e: Created https://github.com/lambdabot/lambdabot/pull/147. (Also Iceland_jack is probably going to be interested in this :P)
19:24:28 <jle`> usually as soon as people are comfortable enough to realize that the type-level and value-level namespaces are different, they abandoned the advice.  but now with DataKinds, type-level and value-level namespaces overlap
19:24:34 <MarLinn> and the discussion if "unX", "getX" or "runX"
19:25:00 <jle`> s/abandoned/abandon
19:25:02 <ertes> fromX
19:25:33 <MarLinn> ^or that
19:25:58 <glguy> MarLinn: That paste is baslically the kind family you hinted at, I think
19:26:34 <jle`> i say we just use lists for constraints instead of commas
19:27:11 <jle`> type family All (as :: [Constraint]) :: Constraint where All '[] = (); All (c ': cs) = (c, All cs)
19:27:25 <MarLinn> glguy, nice!
19:27:26 <jle`> All [Monad m, Traversable m] => ...
19:27:49 <ertes> jle`: i wouldn't mind it at all‚Ä¶  maybe then (=>) could finally have an actual type
19:27:52 <ertes> sorry, kind ;)
19:28:05 <ertes> (=>) :: [Constraint] -> * -> *
19:28:34 <ertes> although that feels a bit suspicious
19:29:10 <hseg> ertes: That makes no sense. You probably want something along the lines of (=>) :: [Constraint] -> k -> Constraint
19:29:37 <MarLinn> That would need a tiny bit of sugar on the value level to distinguish it from "real" lists, but sugar is cheap
19:29:52 <jle`> hseg: it'd make sense, [Monoid a, Monad m] => a -> m b
19:30:01 <ertes> hseg: forall a. [Num a] => a -> a  -- kind error with your variant
19:30:02 <jle`> as long as it binds loser than ->
19:30:30 <ertes> hseg: note that (=>) is (->) in disguise, so it makes sense for them to have similar types
19:30:37 <hseg> Oh, you meant in function type signature context. I was thinking typeclass instance definition context.
19:31:55 <hseg> Yeah, now I see how your signature makes sense. What makes you suspicious about it?
19:33:14 <jle`> @let type family (cs :: [Constraint]) ==> (a :: *) :: * where (==>) '[] a = a; (==>) (c ': cs) a = c => (cs ==> a)
19:33:16 <lambdabot>  .L.hs:165:9: error:
19:33:16 <lambdabot>      ‚Ä¢ Illegal qualified type: c => cs ==> a
19:33:16 <lambdabot>      ‚Ä¢ In the equations for closed type family ‚Äò==>‚Äô
19:33:17 <ertes> hseg: the fact that i don't know how it maps to logic (not that it doesn't, i just don't know how)
19:34:23 <ertes> of the magic "=>" i always thought: "it's not logic, just do the plumbing in your head"
19:34:35 <ertes> but as soon as it has a type, i feel it should be logical
19:34:51 <hseg> Oh... You'll probably need a multi-sorted logic (to separate kinds), but I'm not sure of the other details.
19:35:52 <MarLinn> To me ertes definiton looks a bit too general for that context. It feels more comfortable to restrict it (at first), eg to  (=>) :: [Constraint] -> Declaration -> Definition
19:36:18 <ertes> MarLinn: what are those?
19:36:37 <hseg> MarLinn: How would those compose?
19:36:48 <MarLinn> I don't know. Types for compiler primitives?
19:36:55 <ertes> MarLinn: and how is Int :: Declaration, if Declaration is not the same as *?
19:38:21 <MarLinn> for now I'm assuming there's another type family for (=>) and I'm speaking only about the typeclass instance case
19:38:32 <MarLinn> Ok, declaration could probably be *
19:39:01 <MarLinn> But I'm not sure if Declaration can be anything other than a "primitive" like Constraint
19:39:32 <ertes> MarLinn: it's easier to think of the (=>) in class heads as something else
19:39:46 <ertes> the (=>) i'm talking about is the one you see in type signatures
19:41:25 <MarLinn> Ok... just don't listen to my ramblings. I'm just a normal guy trying to follow what the experts are coming up with XD
19:42:56 <ertes> MarLinn: don't let me stop you‚Ä¶  random rambling can lead to great ideas‚Ä¶  i'm just telling you why that particular one may be problematic =)
19:43:28 <MarLinn> heh. thanks for the encouragement
19:48:02 <EvanR> http://lpaste.net/18040http://lpaste.net/1804000
19:49:21 <hseg> EvanR: ?
19:49:49 <EvanR> stupid internet
19:49:52 <EvanR> http://lpaste.net/180400
19:50:05 <jgzh6> http://lpaste.net/180401
19:51:14 <jgzh6> Is there any way in which I can store the {forM_ .. threadDelay 1000000} part to a {let variable} so that I don't have to use appendFile as well as not go through {converted <- Prelude.readFile ... ; let ..} ?
19:51:41 <jgzh6> http://lpaste.net/180401
19:54:14 <EvanR> you can totally store IO actions in a let variable
19:54:59 <EvanR> usually people discover this by accident, doing let x = readFile for example in a do block doesnt actually read the file
19:56:01 <jgzh6> How could I substitute appendFile with a let variable..?
19:56:03 <pavonia> jgzh6: Why don't you return the value instead of writing it into the file in the forM, and use the result list later?
19:56:25 <sgronblo> yay, was able to create a simple WAI middleware! it seems that the streaming of responses is the trickiest part of the WAI Application
19:57:18 <jgzh6> pavonia : Because when I used a let variable, ghc gave me an error
19:58:12 <jgzh6> I would like to know how I can get rid of appendFile and use a let variable to store the whole forM_ part
19:58:13 <pavonia> jgzh6: You don't need a let: http://lpaste.net/180402
19:58:30 <pavonia> let defined immutable variables, so that won't help you
19:58:37 <pavonia> *defines
19:58:55 <EvanR> let x = the_whole_forM__part
20:02:58 <MarLinn> random idea: why not just generalize to (=>) :: [precondition] -> k -> postcondition, with conditions filled by a family.
20:03:26 <EvanR> you could create your own type former like that, call it :=>
20:06:38 <MarLinn> ... and then I could try to force (=>) and (->) into it and drop all the boring default type signatures? Heh.
20:09:08 <jgzh6> http://lpaste.net/180403
20:09:16 <jgzh6> can't match the type..
20:10:30 <pavonia> let storing puts the whole forM computation in the variable, but what you want is to store the _result_ of that computation once it has been executed
20:10:54 <pavonia> so use "storing <- forM ..." for that
20:12:13 <pavonia> Also you have to use "return" in the loop to return the individual results
20:15:10 <jgzh6> Oh, I saw this now http://lpaste.net/180402
20:15:21 <jgzh6> Thanks, let me try
20:19:47 <jgzh6> http://lpaste.net/180404
20:19:55 <jgzh6> Still can't work out..
20:21:13 <MarLinn> O.o I just read that Core is dynamically typed. Wat. I've been living a lie.
20:21:20 <pavonia> jgzh6: You need formM, not forM_
20:21:26 <pavonia> *forM
20:22:08 <pavonia> And converted already is a list, so no need for "lines"
20:23:14 <lpaste> lambdafan pasted ‚Äúwhat is the point-free version of cons?‚Äù at http://lpaste.net/180405
20:24:07 <EvanR> MarLinn: the type system can be considered a tool to filter out programs which would go bad when fed into the underlying runtime system, and that system is necessarily more primitive and dangerous
20:24:18 <EvanR> or more lax in what it allows to happen
20:24:26 <jgzh6> pavonia : Working! 
20:24:35 <jgzh6> Thank you so much
20:24:37 <EvanR> think C code vs machine code
20:24:46 <pavonia> No problem
20:25:14 <jgzh6> one headache gone :)
20:25:51 <pavonia> lambdafan: You have to pattern match on Hughes, so you will always have at least one varibale, no?
20:26:49 <lambdafan> pavonia : that's right, so point-free is impossible? That's why I can't think of it
20:28:04 <pavonia> Unless you have an accessor, I'd say yes
20:28:10 <MarLinn> EvanR, sure, it's just a tool. But why would one not carry that information through the layers and use it to make sure the correct primitives are used?
20:28:57 <glguy> MarLinn: Do you know about "core lint"?
20:29:01 <lambdafan> pavonia: this is a codewars challenge, I cannot change Hughes. hmmm.
20:29:19 <MarLinn> glguy not yet
20:29:23 <lambdafan> The problem is, I must write snoc, and the hint is "consider point-free version of cons"
20:29:41 <lambdafan> and I can't consider that if it can't be written
20:29:47 <lambdafan> so I am without hint
20:31:28 <lifter> Does anybody know what the difference is between "extensions", "default-extensions", and "other-extensions" fields in a cabal file?
20:31:36 <MarLinn> glguy, so core itself and its checks are both present, but separated into two parts?
20:32:15 <MarLinn> That sounds like it should make optional/externalised type systems easier!
20:32:31 <glguy> MarLinn: Yeah. The checks it has to do can be more expensive than they want to run all the time, but they are available
20:34:36 <MarLinn> Makes sense. Who wants to listen to users' complaints about how their tool is so slow all the time
20:34:57 <ertes> lifter: 'extensions' is legacy, 'default-extensions' is a bad idea and 'other-extensions' is almost useless
20:35:35 <kadoban> Nice
20:35:52 <ertes> lifter: use LANGUAGE pragmas, and if you want to be completely correct, list all extensions you used in other-extensions
20:36:19 <lifter> ertes: Yeah I don't know what 'other-extensions' could be used for or why it might be needed. Why is 'default-extensions' a bad idea?
20:36:59 <ertes> lifter: because it interferes with tools‚Ä¶  many haskell tools don't parse the .cabal file for required extensions
20:37:08 <ertes> mostly because it's actually quite hard to do
20:37:58 <lifter> I'm temped to do "default-extensions:  OverloadedStrings" because ALL my modules need it.
20:38:33 <ertes> lifter: your editor probably has a templating framework that can write it for you
20:39:03 <ertes> saves you from having to write the module header and haddock module description, too
20:39:53 <lifter> ok, thanks
20:43:21 * hackagebot rdf 0.1.0.1 - Representation and Incremental Processing of RDF Data  https://hackage.haskell.org/package/rdf-0.1.0.1 (TravisWhitaker)
20:45:09 <MarLinn> lambdafan: does the snoc part of the question state that snoc must be point free?
20:56:26 <pkmx> We don't have data ... deriving (Monoid) yet, right?
20:58:29 <shachaf> What would that mean?
21:01:24 <MarLinn> pkmx, just try it!
21:02:15 <MarLinn> We have, but then we also have not...
21:02:17 <pkmx> well, it says no explicit implmentation for mempty and mappend, so I guess no?
21:02:21 <jle`> pkmx: we can do a limited "lifting" of Monoid instances with GeneralizedNewtypeDeriving
21:03:12 <jle`> newtype Ints = Ints [a] deriving Monoid, and mempty/mappend are considered mempty/mappend for lists
21:03:26 <jle`> but other than that i really don't know what you are expecting
21:05:19 <pkmx> I was thinking something along the lines of: data A a b = A a b; instance (Monoid a, Monoid b) => Monoid (A a b) where mempty = A mempty mempty; A a b `mappend` A a' b' = A (a `mappend` a') (b `mappend` b')
21:09:59 <pavonia> pkmx: What if you had "data A a b = A a | B b", what would "A a <> B b" be?
21:11:51 <pkmx> pavonia: yeah I guess it would not work with sum types
21:12:21 <pkmx> would probably still be useful to have it generate single constructor cases though
21:18:01 <AndChat54704> Hello
21:18:26 <MarLinn> next step of my loud thoughts about (=>): Maybe the hole is in Constraint. How about (=>) :: Constraint k -> k -> Constraint Scope, where scope is more or less an ordered dictionary...
21:18:53 <ybit> http://kevinmahoney.co.uk/articles/tests-vs-types/
21:19:32 <AndChat54704> Where I can find the Hisyory of Haskell please?
21:20:07 <glguy> AndChat54704: Search Google for "History of Haskell"
21:21:03 <ybit> if haskell + sig + tests don't necessarily guarantee: the returned index is always a valid index, the returned index always referes to a matching alue, a missing element always returns None or Nothing, no exceptions, no errors, no infinite loops. what are some strategies for dealing with these errors?
21:21:40 <ybit> ping shapr :)
21:22:02 <AndChat54704> OK
21:22:21 <ybit> (probably resting)
21:23:32 <AndChat54704> The Wiki and community wiki have nothing, not any of the online documentation, downdloads or learning resources,  I think a lo g and detailed histoey is needed
21:24:21 <AndChat54704> To know the foundamental intention, comncept and conception of Haskell
21:25:12 <AndChat54704> A suggestion
21:25:33 <AndChat54704> Bye
21:27:01 <kadoban> ybit: You write test cases that check for any particularly difficult or boundary cases, and property tests that throw some arbitrary values at it, and achieve the level of confidence you're comfortable with.
21:28:23 * hackagebot pipes-random 1.0.0.1 - Producers for handling randomness.  https://hackage.haskell.org/package/pipes-random-1.0.0.1 (fosskers)
21:28:33 <orion> Hi. If within a WAI Application I use a pure function such as (+) to calculate (2+2), will the result be calculated once after the first HTTP request and then never again?
21:29:02 <orion> Assuming that I literally wrote (2+2) in the Application.
21:31:24 <MarLinn> orion, if it's so simple I would almost assume that ghc calculates the result on compilation, at least with -O2
21:32:04 <orion> Ok, sure. Let's assume it's not simple.
21:32:23 <ybit> kadoban: thank you for that. i guess i was talking about testing strategies, but i suppose that's one of those things that's hard to address without a specific example
21:33:19 <kadoban> Yeah it's a bit hard to say much interesting about in the abstract, for me.
21:34:02 <MarLinn> orion, I'm not a ghc programmer but as far as I've read that depends. A monomorphic value would be computed only once, but a polymorphic one might be recomputed
21:35:16 <MarLinn> But take that with a shovel of salt. When in doubt: profile!
21:41:02 <ReinH> well, that may be true of top-level definitions
21:41:32 <ReinH> as it stands, we don't have enough information to give an accurate answer
21:41:44 <ReinH> unless you consider "it depends" to be an accurate answer
21:43:26 <MarLinn> yeah, my answer had both salt and currying I guess...
21:43:28 <EvanR> if depends if "it depends" is an accurate answer
21:43:34 <ReinH> orion: My guess would be "probably not". GHC doesn't do memoization.
21:44:50 <orion> I see.
21:45:35 <ReinH> GHC will *evaluate* a given expression at most once per "context" (surrounding lambda-expression, or the global top-level context)
21:45:53 <EvanR> per thread
21:45:55 <EvanR> ;)
21:46:10 <ReinH> But it seems extremely unlikely to me that multiple HTTP requests would share the same context
21:46:26 <ReinH> as in, I have no idea how could make that so
21:46:42 <ReinH> EvanR: well, no.
21:46:57 <ReinH> or yes, depending on how you read that
21:46:59 <EvanR> two threads could race to evaluate the same top level thing
21:47:15 <ReinH> something something blackholing
21:47:39 <EvanR> yeah but there is still a window
21:48:23 <ReinH> Sure.
21:48:42 <orion> Ah
21:48:57 <EvanR> thought i would bring that up since were talking about how many times something gets computed
21:48:59 <ReinH> orion: iow, within a given evaluation of the surrounding expression, x + y will be evaluated at most once
21:49:34 <ReinH> on multiple evaluations (e.g., when a function is evaluated each time an HTTP request is received) x + y will need to be reevaluated
21:49:47 <ReinH> I mean, this should be obvious, given that x and y can be different
21:50:06 <ReinH> but what GHC definitely does not do is memoize the results of x + y for different values of x and y
21:50:14 <orion> ReinH: I see.
21:50:27 <ReinH> This is undesirable, since there is no globally optimal memoization strategy
21:51:08 <ReinH> If you want to do that yourself, there are various libraries that provide memoization
21:51:46 <orion> Given a [(ByteString, Application)] and the value of the "Accept" HTTP header, my function will `lookup` the corresponding Application and hand the Request off to it.
21:52:10 <ReinH> The fine points of whether GHC recomputes CAFs that are monomorphic vs. polymorphic are almost certainly irrelevant here
21:52:33 <orion> The [(ByteString, Application)] never changes at runtime. Based on what you've said, I should expect that the List is calculated once per HTTP Request.
21:52:44 <orion> But, it likely doesn't matter because bottlenecks will be elsewhere.
21:52:51 <parsnip> i can't seem to find Cale 's other fold images. like mapAccumL, etc. 
21:53:06 <ReinH> If you put that list as a top-level definition, it will be computed at most once.
21:53:17 <ReinH> The *list* will be. The lookups will not be.
21:53:22 <orion> Sure, that makes sense.
21:53:34 <parsnip> ah, luckily i have an old one saved with all of them in one image. 
21:53:39 <ReinH> You'd probably be better off just using a Data.Map
21:53:43 <orion> But, I doubt THAT calculation will be the bottleneck.
21:54:06 <orion> Under what circumstances would one choose Data.Map over a simple tuple?
21:54:29 <ReinH> The comparison would be between Data.Map and a list of tuples.
21:54:55 <ReinH> And whenever access in log n beats access in n
21:55:20 <ReinH> lookup in a list of tuples has linear access time
21:55:28 <ReinH> lookup in a map has logarithmic time
21:56:01 <ReinH> Generally you want to use Data.Map. If your list is sufficiently small, it might be fast
21:56:06 <ReinH> ... faster to use a list
21:56:23 <orion> That makes sense. My list has < 10 entries.
21:56:34 <orion> And that's known at compile-time.
21:56:45 <orion> (To me)
21:56:58 <ReinH> Well, either would probably be fine then
21:57:13 <kadoban> It's pretty likely faster as a list then, I'd think, but unless there's some reason it can *never* get bigger than that, I'd almost say use the Map anyway. Kind of depends what it is.
21:57:17 <ReinH> and lookup is pretty much guaranteed to not be your bottleneck
21:57:51 <MarLinn> if you use a map, I'd suggest using a Data.Map.Strict in this case
22:00:13 <MarLinn> mhh... TH-generated custom pattern-matching-trie? Overengineering!
22:01:57 <orion> I find overly engineered systems attractive.
22:02:01 <ReinH> lol just use the list and stop worrying
22:02:15 <orion> lewl, ok
22:02:16 <ReinH> orion: you and everyone else
22:06:06 <jgzh6> http://lpaste.net/new/haskell
22:06:20 <jgzh6> -- Is there any way I can use getLine to receive an input -- and use it to change the result type of the function convertFrom? -- For example, if rType gets USD, then the type of convertFrom becomes :: Converter -> String -> Double -> USD
22:06:45 <jgzh6> http://lpaste.net/180406
22:10:24 <MarLinn> type level information is erased on compilation, so it can not depend on runtime information
22:10:59 <jgzh6> hm..
22:16:10 <jgzh6> ok, then.. http://lpaste.net/180406
22:16:44 <jgzh6> Is there a way to select a function to operate depending on a user input?
22:18:12 <pavonia> You already did that with case
22:19:17 <Spynxic> Everyone familiar with what a monad and dyad is?
22:19:24 <pavonia> jgzh6: What you could do is to move the show into convertFrom, then you always return values of type String
22:21:19 <jgzh6> hm..
22:23:16 <MarLinn> One could pass the result type via a Proxy to unify both function. But the extra case for the result type would still be necessary
22:27:56 <jgzh6> http://lpaste.net/180409
22:28:05 <jgzh6> not sure..
22:28:31 <jgzh6> I moved the show function into convertFrom
22:32:35 <MarLinn> lol?
22:33:17 <MarLinn> pavonia didn't mean convertFrom
22:33:50 <MarLinn> it should go into convertEUR and convertUSD
22:34:10 <pavonia> Err sorry, yes
22:34:35 <MarLinn> so confusing with all those converters
22:35:31 <jgzh6> I think this is a bit too confusing to me.
22:37:09 <dramforever> jgzh6: In what way are values of different types used?
22:37:43 <dramforever> Sorry, badly described. Nevermind
22:38:07 <MarLinn> jgzh6, I think you might be trying too many things at once here
22:39:09 <jgzh6> I guess so
22:39:20 <dramforever> jgzh6: Is this right: Ultimately you are getting from a 'command' to a 'result'. The 'result' is a string representation of the amount
22:40:02 <jgzh6> Yes, that seems to be correct
22:41:09 <jgzh6> My original working example code is http://lpaste.net/180410
22:41:49 <jgzh6> But since it only results in one type of currency (EUR), it's not that useful 
22:42:13 <jgzh6> I would like to change it so that it can return results for other currencies
22:42:20 <dramforever> Ok. What about a function convertPrice :: Converter -> String -> Price -> String, which calls different convertion functions, but 'show' them so that they are all string
22:42:38 <dramforever> Now you are confusing different types, but I wouldn't quite mind, because that does seem like your goal
22:43:31 <jgzh6> that sounds alright
22:43:58 <jgzh6> though I have to see if I can code that right
22:44:31 <dramforever> So... it wouldn't quite make sense to actually read back that String after that
22:44:50 <dramforever> *Unless* you got it from a file, perhaps. Files have no idea of Haskell stuffs
22:45:51 <glguy> jgzh6: You can either make a type that can contain all of the currencies: data Money = MoneyUSD USD | MoneyEUR EUR | ...
22:46:04 <glguy> or you can just have a single Money type that the difference currencies share
22:46:18 * dramforever looks up Data.Currency.Convert
22:46:52 <jgzh6> hm..
22:47:19 <Spynxic> Anyone know what the dyadic case for the word 'like' is?
22:47:39 * dramforever finds all sorts of con*currency* :(
22:48:03 <glguy> Spynxic: #haskell is for questions about the Haskell programming language
22:48:15 <Spynxic> haskell has dyads, yes?
22:48:25 <ertes> pkmx: https://hackage.haskell.org/package/generic-deriving
22:48:26 <adelbertc> hey all - i'm looking into bidirectional parsing/printing libs in the context of JSON - i've found JsonGrammar2 and roundtrip-aeson. roundtrip-aeson looks a bit simpler, but JsonGrammar2 a bit more fully fledged albeit more complicated
22:48:38 <adelbertc> does anyone have experinece using either of these? or have advice about them
22:48:41 <Spynxic> glguy: I must share this..
22:48:58 <ertes> pkmx: you can use -XDeriveGeneric together with that package to avoid having to write product monoid instances
22:49:09 <dramforever> Spynxic: monad dyads? Like in APL/J/...?
22:49:23 <Spynxic> dramforever: exactly like apl/j/..
22:49:25 <dramforever> No Haskell doesn't have Monads in that sense
22:49:32 <Spynxic> oh
22:49:35 <dramforever> That's a different thing
22:49:44 <Spynxic> it's a simple thing
22:49:51 <Spynxic> I imagine haskell's thing is much more complex
22:50:07 <Spynxic> thing being it's monad
22:50:48 <Spynxic> or concept thereof.. anywho, sticking with the J/APL concept.. the dyadic case for "like" is a comparison between two things
22:51:31 <Spynxic> and I consider the monadic case to be pretty profound
22:53:35 <Spynxic> It gives the input in question substance
22:56:26 <xuxu> https://wiki.haskell.org/Combinator
22:56:51 <xuxu> should "\a -> \b -> a" be " \a -> \b -> b a"?
22:57:21 <xuxu> oh, nevermind, that is const 
22:57:24 <glguy> xuxu: No, those are just 3 examples
22:57:44 <jgzh6> Many websites seems to be using ip or robot detection. wreq requests get blocked.
23:00:19 <dysfun> there's not much we can do about that
23:01:00 <Spynxic> xuxu: the problem I see with that is the arguments cannot be changed..
23:23:37 <hc> hi everyone, i've got a question about the type system again
23:23:42 <lpaste> hc pasted ‚Äútype_question_2.hs‚Äù at http://lpaste.net/180411
23:24:04 <hc> ^^^ I'm getting the error:     Couldn't match type ‚Äòforall a Get‚Äô with ‚ÄòGet‚Äô
23:24:08 <merijn> hc: Not sure if it's an accident, but that has a syntax error :)
23:24:13 <merijn> hc: Right :)
23:24:23 <merijn> hc: "forall a . Get a"
23:24:28 <merijn> hc: You're missing a dot :)
23:24:55 <hc> oh dear. yes, it's too early here, sorry
23:25:10 <merijn> Also, that type does not quite make a lot of sense to me?
23:25:19 <Axman6> hc: also, when you're getting errors, it's a good idea to paste the full error from GHc into the paste too
23:25:23 <merijn> hc: What are you *intending* to describe
23:25:29 <hc> Yes I just forgot to activate RankNTypes in some modules
23:25:45 <hc> I didn't fully read the error message and assumed the dot was not required in that situation...
23:26:00 <Axman6> the dot is always required afaik
23:26:02 <hc> again, sorry! seems to be compiling fine now :)
23:26:24 <hc> and thanks for the quick help
23:27:03 <hc> hmm. why did the compiler not quit with a syntax error but accepte "forall a Get" (without the dot) as a type
23:28:39 <Guest67829> Alright. I'm back and ready to strangle IO. :P I started to do the suggested "just slap IO on everything that comes in touch with your IO functions" thing. And I can't since I call readFile -> FilePath and FilePath is String but my Strings are now IO. Can I fix this?
23:30:06 <merijn> hc: Well, did you say you didn't have RankNType enabled?
23:30:50 <merijn> Guest67829: So you have "IO String" and want to apply "readFile" to that string?
23:30:55 <hc> merijn: No, but your insisting I was missing a dot got me to think again why the dot wasn't accepted ;-)
23:31:16 <Guest67829> merijn: yes.
23:31:31 <merijn> :t (>>=) `asAppliedTo` (undefined :: IO String)
23:31:33 <lambdabot> IO String -> (String -> IO b) -> IO b
23:31:46 <merijn> Or
23:32:08 <merijn> Oh, I forgot lambdabot doesn't have readFile, so can't show that example :)
23:32:18 <Guest67829> alright, that helps already, thank you :)
23:32:31 <merijn> hc: Ah, I asked because 'forall' is not syntax without RankN, it's just another typevariable
23:32:50 <merijn> But if you have rankn enabled I dunno why it wouldn't report that as error
23:43:05 <ongy> :t asAppliedTo
23:43:07 <lambdabot> (a -> b) -> a -> a -> b
23:43:28 * hackagebot hakyll-filestore 0.1.3 - FileStore utilities for Hakyll  https://hackage.haskell.org/package/hakyll-filestore-0.1.3 (aergus)
23:44:59 <merijn> ongy: It's basically const with a spiffy type signature for that sorta thing :)
23:45:31 <ongy> flip const, if I see it correctly
23:45:48 <merijn> :t const
23:45:50 <lambdabot> a -> b -> a
23:46:00 <ongy> oh
23:46:06 <merijn> ongy: with 'a' = 'a -> b' and 'b' = 'a' :)
23:46:30 <ongy> I think I get it
23:49:17 <merijn> ongy: Basically, the ignored argument of const still aids inferences of it's input type due to the signature
23:50:04 <orion> Given a function f :: Foo -> Bar -> ... -> MyApp () where MyApp = ReaderT MyAppEnv IO, is it possible to construct a function that transforms f to IO (), when you don't know the number of arguments f takes?
23:51:22 <merijn> orion: Not in general
23:51:27 <orion> I defined a function "runToIO" thusly: (flip (runReaderT . runMyApp)) env -- and has the type: MyApp a -> IO a
23:51:44 <orion> s/and has/which has
23:52:33 <merijn> orion: To convert it to IO () you'd need to apply it to actual arguments, and how can you pull values of unknown types like Foo/Bar out of thin air?
23:53:05 <orion> I want the arguments to "pass through". Foo and Bar were just examples.
23:54:01 <orion> My goal is to is to write a function that can take any foo :: ... -> ... -> MyApp a and convert it to ... -> ... -> IO a
23:54:06 <merijn> Right, so you want "(Foo -> Bar -> ... -> MyApp ()) -> Foo -> Bar ... -> IO ()"
23:54:11 <orion> Indeed.
23:54:25 <merijn> orion: Is it possible? Yes. A bit messy/complex? Also yes :)
23:54:29 <orion> heh
23:54:40 <orion> Does it involve currying?
23:54:48 <merijn> orion: I think I might have a related piece of code somewhere
23:55:31 <merijn> orion: No, can't curry unknown number of arguments. Requires polymorphic recursion and type families
23:56:49 <orion> oh wow, that is complicated.
23:57:32 <merijn> orion: An approach similar to https://github.com/merijn/SNet2.0/blob/master/SNet/Task.hs#L73-L79
