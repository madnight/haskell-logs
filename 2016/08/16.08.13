00:07:41 * hackagebot servant-auth-token 0.2.0.1 - Servant based API and server for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-0.2.0.1 (NCrashed)
00:07:41 * hackagebot autoproc 0.2.1 - EDSL for Procmail scripts  https://hackage.haskell.org/package/autoproc-0.2.1 (JasonDagit)
00:16:15 <lpaste> Diego pasted “Submask Queries” at http://lpaste.net/2973778718016667648
00:16:54 <lpaste> Diego revised “Submask Queries”: “Submask Queries” at http://lpaste.net/2973778718016667648
00:21:23 <LadY_aSaL> hello
00:24:18 <glguy> hi
01:11:48 <orion> Anyone know why this error keeps happening?: ghc: unable to decommit memory: Invalid argument
01:16:55 <geekosaur> orion, what platform and what ghc version?
01:17:25 <orion> 8.0.1, just the compiler
01:17:31 <orion> I did not install a platform.
01:17:40 <orion> I also have cabal-install 1.244.0.0 installed.
01:17:52 <geekosaur> not haskell platform. os/distro
01:18:15 <orion> Ubuntu Xenial
01:18:25 <orion> Sorry, my mistake.
01:18:46 <orion> I cross compiled it on Ubuntu Xenial targeting Alpine Linux x86_64.
01:18:58 <orion> (musl libc)
01:19:59 <geekosaur> ok, the problem is that musl doesn't support the new memory manager (the one that makes every haskell program look like it's using 1TB in top). it's playing mmap/madvise games and musl apparently doesn't support them fully
01:21:15 <geekosaur> for more detail you'd probably have to ask in #ghc. also ask if there's a way to build it without that new memory manager for platforms that don't support it properly
01:21:33 <geekosaur> (hopefully it's a configure flag)
01:21:57 <cocreature> I think it’s only used on linux, so I would guess that you can somehow disable it
01:22:54 <geekosaur> (at least, given what I've seen of it, I assume "decommit" maps to some form of madvise(MADV_DONTNEED) or similar...)
01:30:27 * geekosaur scans manual for any relevant RTS options, chuckles at the new commentary for -B
01:31:49 <geekosaur> sadly, don't see anything about controlling the new memory manager
01:31:53 <cocreature> “Certain people can even tell what stage [the program] is in by the beep pattern.” lol
01:33:06 <geekosaur> I can well believe that (I did similar things... uh, ~30 years ago)
02:19:21 <jchia_> anyone using the atom editor with the ide-haskell-cabal plugin? how do i make ide-haskell-cabal build with stack instead of cabal?
02:23:32 <jchia_> i found the answer. the builder can be selected in the haskell ide pane
02:26:48 <Darwin226> Hey guys. Say I have a class MonadSomething a m that doesn't have a fundep (m ->  a). Is there a way to write a function fn :: MonadSomething a m => m Int defined as fn = return 5 without ambiguity errors?
02:27:15 <Darwin226> I mean, it obviously doesn't care about the a parameter since it does nothing with it, but it's still forcing me to put proxies everywhere
02:28:12 <cocreature> Darwin226: well how should GHC know which instance it should choose?
02:28:46 <Darwin226> cocreature: Hmm, that's right I guess. Though in my case the instance also doesn't matter
02:29:01 <cocreature> if the instance doesn’t matter, why do you parametrize it my the instance?
02:29:12 <cocreature> if fn = return 5 is really your implementation just give it a Monad m constraint
02:29:23 <cocreature> s/my/by
02:30:14 <Darwin226> Yeah it's kind of a simplified example. In my case I have this state that has type parameters. My function does actually modify the state but it does so uniformly
02:30:35 <Darwin226> (and for unrelated reasons I'm not using MonadState which does have a fundep)
02:32:37 <cocreature> Darwin226: sry I need to see an example of what you are actually trying to do to be able to try to help you :)
02:34:20 <Darwin226> Imagine you have a MonadState class without the fundep. This let's you have multiple states simultaneously at the expense of inference. Now the problem is that I have a function like fn :: MonadState (SomeState s) m => m ()
02:34:51 <Darwin226> and I'm getting ambiguity errors on the s, but even though the fn function does actually modify the state, it does so independently of s
02:35:36 <Darwin226> The "what's the right instance" question is valid, but the instance here is basically "instance MonadState (SomeState s) m"
02:36:13 <Darwin226> *the m is actually some specific monad in this case, but the s is unspecified
02:36:42 <Darwin226> I don't know if this makes sense
02:36:45 <lyxia> can't you restructure your typeclasses so that the functionality used by fn comes from a typeclass that does not involve s?
02:37:38 <lyxia> If you don't care which instance it picks, doesn't that mean you have duplicated functionality among these instances?
02:38:08 <Darwin226> lyxia: Say the implementation is fn = modify (take 5)
02:38:31 <Darwin226> and my state is a list of `a`s
02:38:40 <Darwin226> it works for any `a`, right?
02:38:52 <Darwin226> but it does actually use the modify function from the MonadState class
02:38:56 <lyxia> ah I see
02:39:05 <Darwin226> Do you see a way to restructure that better?
02:40:26 <lyxia> Does your m type have multiple different list states?
02:41:24 <Darwin226> You're thinking of making the state parameter higher kinded?
02:42:21 <lyxia> I mean, given m and the fact that the state is a list type [a] for some a, perhaps that determines a uniquely and you can exploit this in the corresponding instance declaration?
02:42:22 <Darwin226> Either way, no, there should only be one instance per type constructor
02:42:40 * hackagebot foundation 0.0.1 - Alternative prelude with batteries and no dependencies  https://hackage.haskell.org/package/foundation-0.0.1 (VincentHanquez)
02:43:43 <Darwin226> I don't see a way of doing that unless I make the paramtere higher kinded and then have a MonadState [] m => function
02:44:03 <Darwin226> but then I lose the ability to have monomorphic states and stuff
02:44:19 <Darwin226> I guess that would be recoverable with Const
02:44:23 <Darwin226> but it still seems hacky
02:44:50 <lyxia> Can you show me what m is in your case
02:45:38 <lyxia> You said there is one instance per type constructor, but does m also determine the type parameters of the state?
02:45:59 <Darwin226> I actually have to go right now, but I'll be back in probably 45 minutes so we can continue then if you'll be available
02:46:00 <Darwin226> sorry
02:46:11 <lyxia> ok sure
02:46:14 <Darwin226> In any case, thanks!
02:47:40 * hackagebot foundation-edge 0.0.1 - foundation's edge with the conventional set of packages  https://hackage.haskell.org/package/foundation-edge-0.0.1 (VincentHanquez)
03:07:41 * hackagebot language-dockerfile 0.3.3.0 - Dockerfile linter, parser, pretty-printer and embedded DSL  https://hackage.haskell.org/package/language-dockerfile-0.3.3.0 (yamadapc)
04:00:53 <laserpants> In my terminal, I can write ghc -e $(echo "map(+1)[1,2,3]")
04:01:22 <laserpants> but if I write ghc -e $(echo "map (+1) [1,2,3]")
04:01:26 <laserpants> with spaces
04:01:47 <laserpants> I get an error "target '[1,2,3]' is not a module name or a source file.
04:01:52 <laserpants> Does anyone know why?
04:02:44 <chrisbarrett> I guess your shell is expanding those separate tokens out to separate arguments in the call to ghc
04:02:49 <mauke> because that ends up running ghc -e map (+1) [1,2,3]
04:03:03 <mauke> also, I get -bash: no match: [1,2,3]
04:03:07 <laserpants> oh
04:03:22 <chrisbarrett> use double-quotes around your subshell invocation and quote the snot out of everything to avoid those issues :)
04:03:44 <mauke> or just ghc -e 'map (+1) [1,2,3]'
04:04:41 <laserpants> What I really wanted to achieve, before running into this
04:04:51 <laserpants> was to pipe the output from some arbitrary command
04:05:33 <mauke> echo 'main = print 42' | runghc
04:06:00 <laserpants> yes, something like that
04:06:18 <laserpants> thanks
04:18:16 <jchia_> I'm using stack to build my project, where one of the source files uses Data.FileEmbed.embedFile to get some data to use with template Haskell. I found that when I update this file, stack build seems to understand the dependency. How does it figure that out given that I don't mention this file in stack.yaml or the project .cabal file. Does it manage to figure this out by understanding the embedding in the source code or observing the file read access during t
04:20:33 <cocreature> jchia_: template haskell support declaring dependencies on files via https://hackage.haskell.org/package/template-haskell-2.11.0.0/docs/Language-Haskell-TH-Syntax.html#v:qAddDependentFile
04:21:05 <jchia_> ah, mystery solved
04:31:53 <rightfold> Hi, where can I find what the colours of the version numbers mean on Hackage? Some of the hspec versions are in green, some in grey, and some in orange.
04:33:21 <cocreature> rightfold: klicking on info explains it although it seems to be updated
04:33:25 <pacak> rightfold: view source. Green - unpreferred, gray - deprecated.
04:33:36 <cocreature> s/updated/outdated/
04:33:43 <cocreature> replace blue by orange and the description is accurate
04:34:34 <rightfold> cocreature ah! the info button! I never knew what that was for. :-)
04:35:11 <rightfold> thank you!
04:35:32 <cocreature> rightfold: I’m sure the hackage guys would like a PR replacing blue by orange if you have time :)
04:36:02 <rightfold> yeah I guess it's a leftover from the times where the theme was still blue, like you still see in some Haddock Google search results
04:36:07 <cocreature> the code is here https://github.com/haskell/hackage-server/blob/f4c0f44d4e995e11e57c730d551dd3ba058446b2/Distribution/Server/Features/Html.hs#L1311
04:36:41 <hpc> perhaps a tooltip on those links would help?
04:36:49 <cocreature> yeah
04:37:00 <cocreature> also not using green for deprecated would probably be a good idea
04:37:22 <hpc> i think grey for unpreferred and red for deprecated maybe
04:38:12 <hpc> but that's secondary to knowing which is which in the first place
04:39:28 <rightfold> Some cultures associate red with preference/good :P
04:41:37 <maerwald> rightfold: do those cultures use haskell?
05:29:24 <zort> I'm trying to build this package from github with stack but it's saying this: http://slexy.org/view/s21DyuoPmy But in System.Posix.Types from base 4.8.2.0 (corresponding to ghc-7.10.3) all those symbols are there, so what's going on?
05:34:00 <zort> er I mean I'm trying to build my project while having store as a dependency 
05:37:45 * hackagebot config-manager 0.3.0.1 - Configuration management  https://hackage.haskell.org/package/config-manager-0.3.0.1 (guyonvarch)
05:41:43 <haskell202> Is (return . pureFunction) the idiomatic way to put pure function inside Kleisli compositions? foo >=> (return . pureFunction) >=> bar
05:45:43 <hpc> :t (return .)
05:45:44 <lambdabot> Monad m => (a -> a1) -> a -> m a1
05:46:35 <hpc> haskell202: there's also (^>>) and (>>^)
05:47:23 <haskell202> hpc: could you show an example?
05:47:39 <pavonia> :t (^>>)
05:47:40 <lambdabot> Arrow a => (b -> c) -> a c d -> a b d
05:47:48 <hpc> the types are rather straightforward
05:48:02 <hpc> for your purposes, a = Kleisli
05:48:03 <hpc> https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Arrow.html#t:Kleisli
05:48:25 <hpc> oh right, there's also arr
05:48:26 <hpc> :t arr
05:48:27 <lambdabot> Arrow a => (b -> c) -> a b c
05:48:39 <hpc> arr :: (b -> c) -> Kleisli b c
05:49:09 <jchia_> I need to choose a command-line parsing package. I want to make Unix-style command-line options and I want to have informative usage information when -h or --help is given or when the given command-line is wrong. What are some packages that support what I need?
05:49:29 <cocreature> jchia_: optparse-applicative
05:49:30 <hpc> haskell202: (return .) probably won't work and you'll need Kleisli (return . pureFunction)
05:49:41 <hpc> or something like that
05:50:33 <mniip> :t (>=>)
05:50:34 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
05:50:52 <hpc> oh wait derp, it is Monad
05:50:56 <mniip> you need the newtype for Control.Category.id
05:50:59 <mniip> er
05:50:59 <hpc> i got thrown by the mention of "Kleisli"
05:51:06 <jchia_> OK
05:51:08 <mniip> well, that, and Control.Category..
05:51:38 <mniip> and (return . f) is simpler than (runKleisli (arr f)) imo
05:52:11 <haskell202> hpc: What do you mean (return .) won't work? It works
05:52:22 <hpc> haskell202: ignore that, i was confusing (>=>) and (>>>)
05:53:17 <haskell202> So is there something better than (return .)?
05:54:22 <hpc> it's probably fine as is, yeah
05:55:17 <haskell202> hpc: ok, thanks
05:55:24 <vaibhavsagar> fmap?
05:55:49 <vaibhavsagar> what about (fmap pureFunction)?
05:56:20 <hpc> vaibhavsagar: (return .) is (fmap return)
05:58:10 <vaibhavsagar> :t (fmap return)
05:58:11 <lambdabot> (Monad m, Functor f) => f a -> f (m a)
05:58:14 <vaibhavsagar> :t (return .)
05:58:15 <lambdabot> Monad m => (a -> a1) -> a -> m a1
05:58:33 <vaibhavsagar> I don't see it
05:58:41 <hpc> (.) `asTypeOf` fmap
05:58:47 <hpc> > (.) `asTypeOf` fmap
05:58:49 <lambdabot>      No instance for (Typeable b0)
05:58:49 <lambdabot>        arising from a use of ‘show_M408154946060305311325473’
05:58:50 <lambdabot>      In the expression:
05:58:54 <hpc> :t (.) `asTypeOf` fmap
05:58:56 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:59:17 <hpc> (return .) = (.) return, (.) = fmap, so (.) return = fmap return
05:59:36 <hpc> https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#line-638
05:59:38 <lyxia> replace m with (t ->)
05:59:44 <vaibhavsagar> interesting, I didn't know that about fmap
06:00:20 <vaibhavsagar> is this equivalent to the reader monad?
06:00:24 <lyxia> replace f with (a ->) in (b -> c) -> f b -> f c
06:00:39 <vaibhavsagar> yup, that makes sense
06:00:49 <vaibhavsagar> thank you hpc and lyxia
06:00:55 <hpc> vaibhavsagar: it is the same as Reader, yeah
06:01:25 <vaibhavsagar> cool :)
06:22:47 * hackagebot acme-iot 0.1.0.0 - IO monad transformer  https://hackage.haskell.org/package/acme-iot-0.1.0.0 (mniip)
06:25:05 <quchen> mniip: Excellent package!
06:25:12 <mniip> :)
06:25:14 <quchen> Solves a long-standing problem with Haskell
06:25:34 <maerwald> seems like a lot of SO answers need a downvote now
06:25:50 <quchen> If State is a transformer, why should IO not be!
06:26:02 <maerwald> well, ppl have been claiming it's not possible :P
06:26:12 <quchen> People also said the world is flat!
06:26:21 <mniip> I will admit I've ripped liftCallCC and liftPass out of StateT
06:26:35 <quchen> You can rip most things out of StateT for IO.
06:26:40 <quchen> Well, State.
06:27:08 <mniip> now just need to build the docs
06:27:20 <mniip> how long does that take nowadays?
06:29:11 <hexagoxel> finally i can use IOT (IOT IO) and affect three different real worlds!
06:30:32 <mniip> lmao
06:31:13 <mniip> woohoo docs
06:31:26 <mniip> https://hackage.haskell.org/package/acme-iot-0.1.0.0/docs/Control-Monad-Trans-IO.html#t:IOT
06:31:33 <heisenbug> IOT is at the base of the Internet of Things!
06:31:40 <maerwald> lazy IO... uh
06:31:57 <mniip> hmm it lost the function docs
06:32:14 <mniip> maerwald, it's hard to do it otherwise
06:32:18 <nitrix> You know it's a great library when you see MagicHash.
06:32:25 <maerwald> mniip: no, you missed '|' in your function docs
06:32:27 <mniip> but I might come up with something for Control.Monad.Trans.IO.Strict
06:32:29 <maerwald> so it's not a haddock comment
06:32:29 <mniip> ohh
06:32:58 <maerwald> lazy IO for me is a no-go. Too unpredictable
06:33:39 <mniip> maerwald, I'll keep that in mind :p
06:35:28 <mniip> note how I didn't use realWorld# a single time so there's no unsafePerformIO so the code must be safe :p
06:37:32 <maerwald> mniip: fun fact: with freer that's even easier :P
06:37:43 <maerwald> (adding IO as the last effect, that is)
06:37:47 * hackagebot acme-iot 0.1.0.1 - IO monad transformer  https://hackage.haskell.org/package/acme-iot-0.1.0.1 (mniip)
07:05:34 <UberLambda> Hello everyone! Is there any standard function that is the opposite of any?
07:05:48 <UberLambda> e.g. [(Bool -> a)] -> a -> Bool
07:06:05 <UberLambda> no wait [(a -> Bool)] -> a -> Bool
07:06:22 <mniip> any ($x)
07:06:30 <mniip> :t any . flip id
07:06:31 <lambdabot> Foldable t => b -> t (b -> Bool) -> Bool
07:07:08 <UberLambda> hm... gotta learn some more Haskell it seems
07:07:10 <UberLambda> mniip: thanks
07:07:15 <mniip> well
07:07:28 <mniip> really you just want 'any ($ value) list_of_predicates'
07:09:12 <UberLambda> I have no idea why, but I guess it works :P
07:09:38 <lyxia> "is any predicate true when applied to value"
07:09:39 <mniip> well it's simple
07:09:51 <mniip> ($ value) is a predicate on predicates
07:10:02 <mniip> that checks whether the predicate returns true on 'value'
07:10:43 <mniip> :t ($ ?value)
07:10:44 <lambdabot> (?value::a) => (a -> b) -> b
07:11:06 <UberLambda> :t any
07:11:07 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
07:11:18 <UberLambda> oh
07:11:41 <Welkin2> :t flip id 
07:11:42 <lambdabot> b -> (b -> c) -> c
07:13:03 <mniip> aw, Data.OldList is a hidden module
07:14:59 <UberLambda> :t any ($ a) [a -> Bool]
07:15:00 <lambdabot> Pattern syntax in expression context: a -> Bool
07:15:02 <UberLambda> hm
07:15:32 <UberLambda> :t (?val :: a) => any ($ ?val) [a -> Bool]
07:15:33 <lambdabot> parse error on input ‘=>’
07:15:45 <mniip> > any ($ 5) [even, (> 10), (< 6)]
07:15:47 <lambdabot>  True
07:16:17 <mniip> > any ($ ?val) `asAppliedTo` []
07:16:19 <lambdabot>  mueval-core: internal error: PAP object entered!
07:16:19 <lambdabot>      (GHC version 7.10.2 for x86_64_unknown_linux)
07:16:19 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
07:16:22 <mniip> oops
07:16:25 <mniip> :t any ($ ?val) `asAppliedTo` []
07:16:26 <lambdabot> (?val::a) => [a -> Bool] -> Bool
07:16:48 <mniip> int-e, is that supposed to happen?
07:16:51 <UberLambda> well... I guess I'm going too fast
07:16:54 <qqzero> is it possible to write high performance numericla code in haskell? (things like deep learning, opencv, etc ...)
07:17:19 <mniip> qqzero, yes but like in any other language it's not going to be very pretty
07:17:26 <UberLambda> I'm trying to use SLJP + Lester's book to learn a bit of Haskell but I guess it's not a great idea
07:17:35 <qqzero> mniip: that's fine
07:17:41 <qqzero> mniip: what's a good document on how to do it?
07:17:53 <mniip> hmm, I don't know of one document
07:18:18 <mniip> but figuring out the evaluational model of ghc is a good start, and then you could read about mutable arrays and unboxed vectors
07:19:13 <Welkin2> qqzero: numeric-haskell
07:19:38 <UberLambda> :t $
07:19:39 <lambdabot>     parse error on input ‘$’
07:19:39 <lambdabot>     Perhaps you intended to use TemplateHaskell
07:19:43 <UberLambda> oh come on
07:19:46 <UberLambda> :t ($)
07:19:47 <lambdabot> (a -> b) -> a -> b
07:19:48 <mniip> Welkin2, is that supposed to be a package?
07:20:01 <mniip> it's not
07:20:01 <Welkin2> yes
07:21:21 <Welkin2> https://github.com/wellposed/numerical
07:21:59 <carter> Welkin2: is that a question? I'm planning on finishing an alpha this fall
07:22:31 <carter> It does have some cool locality tech , but not quite usable yet
07:22:41 <Welkin2> lol hi carter
07:23:12 <carter> Granted ... Most folks don't understand locality engineering for performance
07:23:26 <carter> Welkin2: I have highlight on key words ;)
07:23:35 <Welkin2> game programmers do haha
07:23:45 <carter> Welkin2: which ones?
07:24:04 <carter> Game engine devs ?
07:24:09 <Welkin2> yeah
07:24:18 <mniip> sometimes I feel like game programmers don't have a grasp of basic optimization
07:25:02 <carter> I guess that raises a different question: for basic stuff , is there really a diff between OpenGL 4.1 vs 4.5?
07:25:15 <Welkin2> people ask about machine learning and similar things in haskell pretty often in here
07:25:18 <carter> Or is all the difference in fancy stuff
07:25:32 <Welkin2> I wonder if it's just because of the fad
07:25:38 <carter> Welkin2: was busy doing some distributed systems stuff this summer.
07:25:51 <carter> Welkin2: it's been a fad for 4-5 years now
07:25:56 <carter> So ... Yes
07:26:21 <carter> Otoh, folks aren't asking about how to model. More often looking for a batteries included thing
07:26:39 <carter> Welkin2: I'll take some time today to do a new release of hblas
07:26:45 <Welkin2> then I would point them to torch.ch
07:26:48 <UberLambda> carter: compute shaders
07:26:59 <UberLambda> carter: not that you can't emulate them in fragment shaders
07:27:03 <carter> I think that's a more concrete thing than numerical atm
07:27:25 <carter> UberLambda: is there any good Exposition of the difference ?
07:27:43 <UberLambda> carter: well the wikipedia article seems pretty accurate
07:27:45 <carter> Like, is it just more flexible / easy to use or ? I
07:27:58 <UberLambda> carter: there's the full changelong between each version
07:28:22 <carter> I looked and I didn't understand the change log yesterday
07:28:31 <carter> Because I don't understand the stuff yet
07:28:56 <UberLambda> carter: to me it looks like nothing really changed
07:28:57 <carter> I last used OpenGL in 2002 when it had the fixed function setup
07:29:11 <UberLambda> carter: yeah, from modern OpenGL I mean
07:29:14 <lpaste> felko pasted “struggling with -XDataKinds and -XKindSignatures” at http://lpaste.net/176686
07:29:34 <felko> How can I use -XDataKinds and -XKindSignatures ? I want to declare a datatype like in the paste
07:30:06 <felko> sorry I interrupted you i forgot that lpaste automatically post on the channel
07:30:43 <carter> UberLambda: so looks like compute shaders are for power devs doing crazy stuff :)
07:30:59 <UberLambda> carter: pretty much nothing that couldn't be done in OpenCL
07:31:12 <UberLambda> carter: and also pretty easy to emulate by rendering data into textures
07:31:17 <carter> So basic bits will be the same even if apparently newer resources don't work with 4.1
07:31:31 <UberLambda> yup
07:31:52 <UberLambda> the big change was the deprecation of the fixed function pipeline back in, I think, OpenGL 3.something?
07:31:54 <hexagoxel> felko: 'FileType probably; needs tick.
07:32:26 <UberLambda> I target OpenGL 3.3 and so far I don't have any problems
07:32:39 <xeviox> hi guys, I'm a total noob and just wanted to ask if stack or cabal supports something like vendoring the dependencies in a separate folder..
07:33:09 <felko> hexagoxel: thats what I tried too but i got the following parse error: "parse error on input '"
07:33:19 <carter> Cabal new build does it with the prjects files
07:34:14 <UberLambda> :t ($ Char) [isAlpha, isDigit]
07:34:15 <lambdabot>     Not in scope: data constructor ‘Char’
07:34:15 <lambdabot>     Perhaps you meant one of these:
07:34:15 <lambdabot>       ‘Chr’ (imported from Text.PrettyPrint.HughesPJ),
07:34:31 <UberLambda> :t import Data.Char; ($ Char) [isAlpha, isDigit]
07:34:31 <lambdabot> parse error on input ‘import’
07:34:59 <UberLambda> lambdabot /help
07:35:06 <UberLambda> no uh?
07:35:13 <Welkin2> lol 
07:35:36 <UberLambda> How do I import stuff?
07:35:51 <UberLambda> if I can atleast
07:35:56 <carter> Welkin2: for folks looking for basic matrix stuff hblas is not shabby and more honest than torch or numpy, though I need to do a new release of master soon. Plus add some solver lapack hooks
07:36:01 <pkmx[m]> felko: well you need to finish the ... part?
07:36:13 <ongy> :t (\x -> ($ x) [isAlpha, isDigit])
07:36:14 <lambdabot>     Couldn't match expected type ‘a -> r’
07:36:14 <lambdabot>                 with actual type ‘[Char -> Bool]’
07:36:14 <lambdabot>     Relevant bindings include x :: a (bound at <interactive>:1:3)
07:36:23 <carter> UberLambda: what's a sane resource on modern ish / sane bits of open gl?
07:36:33 <UberLambda> carter: I liked open.gl
07:36:38 <UberLambda> https://open.gl
07:36:56 <ongy> UberLambda: what did you want to do with lambdabot?
07:37:00 <ongy> :t (\x -> map ($ x) [isAlpha, isDigit])
07:37:01 <lambdabot> Char -> [Bool]
07:37:05 <felko> pkmx[m]: no thats not a problem, do you know how to fix the type error I get when i dont put a tick ?
07:37:17 <felko> pkmx[m]: or the parse error I get when i put a tick ?
07:37:33 <Welkin2> felko paste the errors
07:37:37 <ongy> @pl (\x -> map ($ x) [isAlpha, isDigit])
07:37:37 <lambdabot> flip map [isAlpha, isDigit] . flip id
07:37:57 <ongy> :t id
07:37:58 <lambdabot> a -> a
07:37:59 <Welkin2> pointfree strikes again
07:38:00 <ongy> :t flip id
07:38:01 <lambdabot> b -> (b -> c) -> c
07:38:08 <UberLambda> ongy: trying to decipher mniip's answer from before
07:38:32 <UberLambda> it still looks like black magic to me, I've been expanding types on paper for a good 5 minutes now
07:38:40 <ongy> :t flip
07:38:41 <lambdabot> (a -> b -> c) -> b -> a -> c
07:38:48 <Welkin2> flip id is a nice exercise in types, but makes your code hard to tead
07:38:51 <Welkin2> read
07:39:31 <Welkin2> UberLambda: a ~ b -> c 
07:39:38 <Welkin2> replace accordingly
07:40:03 <UberLambda> hm
07:40:19 <UberLambda> ok I think I actually need to read some docs first
07:40:31 <felko> oops nevermind it works now, I don't know why. I think GHCi hadn't set the GHC Extensions automatically
07:40:43 <UberLambda> I assumed I could just try to learn from other people's code but it seems like I am deadly wrong
07:41:10 <Welkin2> a -> a unifies with a -> (b -> c) where a ~ (b -> c)
07:41:35 <ongy> ahh flip id is really hard to get, but actually makes sense
07:41:46 <Welkin2> yeah
07:42:09 <UberLambda> :t c :: Char -> ($ c)
07:42:10 <lambdabot> parse error on input ‘c’
07:42:16 <Welkin2> which is why it is not useful in real code unless tou want to golf
07:42:16 <UberLambda> :t (c :: Char) => ($ c)
07:42:17 <lambdabot> parse error on input ‘=>’
07:42:29 <UberLambda> :t (?c :: Char) => ($ ?c)
07:42:31 <lambdabot> parse error on input ‘=>’
07:42:41 <ongy> :t (\(c :: Char) -> ($ c))
07:42:41 <lambdabot> Char -> (Char -> b) -> b
07:42:49 * hackagebot pixelated-avatar-generator 0.1.3 - A library and application for generating pixelated avatars.  https://hackage.haskell.org/package/pixelated-avatar-generator-0.1.3 (ExcaliburZero)
07:43:00 <ongy> UberLambda: you want to make it a lambda, so it parses nicely in lambdabot (maybe there's other ways)
07:43:01 <UberLambda> oh... you need explicit lambdas?
07:43:17 <UberLambda> ongy: nice
07:43:19 <mniip> UberLambda, what are you trying to understand
07:43:38 <Welkin2> $ is just apply
07:43:52 <mniip> also yes, you either bind names with \ or with ?
07:43:54 <hpc> :t ($)
07:43:55 <lambdabot> (a -> b) -> a -> b
07:44:13 <mniip> :t \x -> show x
07:44:14 <lambdabot> Show a => a -> String
07:44:17 <mniip> :t show ?x
07:44:19 <lambdabot> (Show a, ?x::a) => String
07:44:40 <UberLambda> but if you ($ Char) you should get a ((Char -> a) -> a) back, right?
07:44:46 <mniip> no
07:44:50 <mniip> Char is not a value
07:44:57 <mniip> it's a type
07:45:01 <Welkin2> I thought ? was for implicit parameters 
07:45:03 <UberLambda> well yeah actually a c instance of Cgar
07:45:07 <UberLambda> *Char
07:45:11 <mniip> Welkin2, exactly
07:45:18 <mniip> sure
07:45:20 <UberLambda> as in any ($ c) [isAlpha, isDigit]
07:45:24 <mniip> :t ($ 'a')
07:45:26 <lambdabot> (Char -> b) -> b
07:45:54 <UberLambda> so I apply any to a (Char -> b) ->b and then to a [(Char -> Bool)]
07:46:15 <UberLambda> but any is (a -> bool) -> [a] -> Bool and this is where I get lost
07:46:20 <exio4> c being an instance of Char sounds like wrong terminology
07:46:35 <exio4> c has type Char, maybe?
07:46:40 <UberLambda> yeah, that
07:46:48 <ongy> :t any
07:46:49 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
07:47:13 <mniip> UberLambda, any :: (a -> Bool) -> [a] -> Bool
07:47:23 <mniip> ($ c) :: (Char -> b) -> b
07:47:27 <ongy> :t [isAlpha, isDigit]
07:47:28 <lambdabot> [Char -> Bool]
07:47:48 <mniip> application of 'any' to ($ c) implies that (Char -> b) -> b and a -> Bool are the same type
07:48:11 <mniip> both are arrow types, therefore, (Char -> b) and a are the same type, and b and Bool are the same type
07:48:38 <mniip> so the result is [a] -> Bool which is same as [Char -> b] -> Bool which is [Char -> Bool] -> Bool
07:49:29 <UberLambda> woah
07:49:30 <mniip> in haskell we usually done "is the same type" with ~
07:49:52 <mniip> so (a -> b) ~ (c -> d) ==> (a ~ c) and (b ~ d)
07:49:59 <mniip> -done + denote
07:51:31 <UberLambda> ...any time estimate about when does this become natural when reading code?
07:51:47 <mniip> 3-4 carrots
07:51:49 <UberLambda> nice
07:51:57 <UberLambda> 2 with rice?
07:52:27 <UberLambda> oh well, thank you all for the help
07:52:43 <Welkin2> well, you shouldn't need to work out types on paper unless the code you are reading was golfed 
07:52:43 <mniip> UberLambda, see if you can figure out what 'flip id' is
07:52:59 <UberLambda> :t flip
07:53:00 <lambdabot> (a -> b -> c) -> b -> a -> c
07:53:02 <mniip> or what type '\f g -> (f .) . g' has
07:53:07 <UberLambda> :t id
07:53:08 <lambdabot> a -> a
07:53:20 <hpc> UberLambda: a lot of it is just a change in mindset, so it's hard to really say when it'll start to make sense
07:53:52 <UberLambda> yeah... completely different from C(++)
07:54:05 <exio4> UberLambda: it is hard to estimate but it is doing equations mentally - which might be easy or extremely hard based on your previous knowledge etc :P
07:54:31 <UberLambda> but I'm bad at standard math :(
07:55:07 <hpc> what's "standard math" for you?
07:55:47 <UberLambda> equations etc.
07:56:00 <UberLambda> I mean algebra on-the-fly mentally
07:56:02 <mniip> where's that article about pattern matching
07:56:14 <mniip> was it monochrome's?
07:56:51 <mniip> or maybe it was him who linked it
08:00:49 <mniip> can't find it
08:01:19 <mniip> UberLambda, anyway, haskell is all about abstract algebra
08:01:35 <ongy> is there an easy way to get all Classes some type is an instance of?
08:01:36 <mniip> haskell programs are literally a bunch of substitution rules
08:02:40 <UberLambda> + a bunch of creative operators it seems
08:02:52 <mniip> operators are functions too
08:03:05 <mniip> and functions is what I was referring to as substitution rules
08:03:21 <UberLambda> yes but why $ and not apply?
08:03:26 <UberLambda> or something like that
08:03:30 <mniip> because usually you use $ in infix form
08:03:33 <mniip> we're not lisp
08:03:46 <UberLambda> alright
08:03:48 <mniip> $ has a prefix "synonym" called id
08:03:58 <mniip> (not really, the type is more general, but it works)
08:04:14 <mniip> actually
08:04:27 <mniip> any infix operator can be written in prefix form
08:04:30 <mniip> > (+) 1 2
08:04:32 <lambdabot>  3
08:04:45 <mniip> and vice versa
08:04:52 <mniip> > negate `map` [1,2,3]
08:04:53 <lambdabot>  [-1,-2,-3]
08:05:21 <estonoboo> mniip: so $ = \x -> x?
08:05:28 <UberLambda> flip id is evil
08:05:53 <mniip> @src $
08:05:53 <lambdabot> f $ x = f x
08:06:46 <ongy> @src id
08:06:46 <lambdabot> id x = x
08:07:24 <mniip> note how id x y = x y = x $ y
08:07:51 <Welkin2> UberLambda: you can write everything in terms of <*> and const
08:08:03 <ongy> > f $ g y
08:08:05 <lambdabot>      Could not deduce (Show r0) arising from a use of ‘f’
08:08:05 <lambdabot>      from the context (FromExpr t)
08:08:05 <lambdabot>        bound by the inferred type of it :: FromExpr t => t
08:08:06 <mniip> Welkin2, what's False in SKI?
08:08:16 <ongy> > f $ g a
08:08:17 <UberLambda> Welkin2: now if I actually knew what any of these were :P
08:08:18 <lambdabot>      Could not deduce (Show r0) arising from a use of ‘f’
08:08:18 <lambdabot>      from the context (FromExpr t)
08:08:18 <lambdabot>        bound by the inferred type of it :: FromExpr t => t
08:08:33 * UberLambda will probabily start reading Learn You A Haskell
08:08:42 <Welkin2> mniip: forgot. what is it?
08:08:55 <mniip> it isn't
08:09:16 <mniip> SKI only covers lambda calculus
08:09:23 * ongy needs to use <*> more, it makes code look clever
08:09:24 <mniip> you can encode datatypes in LC
08:09:41 <mniip> but '\x y -> y' is not the same as False
08:09:42 <UberLambda> BTW... is SLJP+Lester's book good?
08:09:51 <Welkin2> lol 
08:09:51 <UberLambda> no more like offtopic
08:10:00 <Welkin2> it is const id 
08:10:10 <mniip> yes
08:10:21 <mniip> or is that True
08:10:48 <mniip> ah no
08:10:50 <mniip> I was correct
08:10:54 <Welkin2> const is true
08:11:31 <ongy> :t const
08:11:32 <lambdabot> a -> b -> a
08:11:35 <ongy> :t (<*>)
08:11:36 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:12:02 <mniip> :t (<*>) `asAppliedTo` (const undefined)
08:12:03 <lambdabot> (b1 -> a -> b) -> (b1 -> a) -> b1 -> b
08:12:12 <mniip> that's the type you're probably after
08:12:53 <Welkin2> ongy: the point is not to look clever. clear is better than clever
08:13:45 <ongy> Welkin2: I know that :) though I think <$> <*> combination is better than 3 line do block with return $ at the end
08:13:51 <mniip> Welkin2, tell that to edwardk
08:13:55 <ongy> but harder to read for beginners
08:13:56 <Welkin2> lol 
08:14:03 <Gurkenglas> If I have two libraries, one defines a typeclass, and the other a thing that happens to be definable as an instance of that typeclass, but each library should be usable without importing the other, what can I do? Can I tell it to define the instance only when both are imported?
08:14:40 <mniip> orphan instance module :(
08:19:45 <Gurkenglas> mniip, in a third library?
08:22:32 <int-e> mniip: it's probably not supposed to happen...
08:24:24 <int-e> > const 1 ?a
08:24:25 <lambdabot>  mueval-core: internal error: PAP object entered!
08:24:26 <lambdabot>      (GHC version 7.10.2 for x86_64_unknown_linux)
08:24:26 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
08:30:11 <nitrix> Who's accountable for lambdabot?
08:30:25 <nitrix> Can we have hopes of it being updated to GHC 8 ?
08:32:43 <int-e> there's hope... see https://github.com/gwern/mueval/issues/14
08:36:14 <int-e> nitrix: oh and that would be me
08:42:13 <nitrix> int-e: So waiting for mueval's release on stackage?
08:43:41 <int-e> well, hackage
09:05:11 <codedmart> How can I filter certain things out with `Network.Wai.Middleware.RequestLogger`? For instance if I don't want to show passwords as plain text but rather as ****
09:05:15 <pkmx[m]> Is it possible to make it work so that if you have a type family TF ::  ->  and a class F a where f :: a -> TF a, and then giving a constraint (r ~ TF a) automatically give rise to the (F a) constraint and allow you to use f :: a -> r?
09:06:09 <Welkin> codedmart: check the endpoint?
09:06:25 <codedmart> Welkin: What do you mean check the endpoint?
09:06:35 <Welkin> codedmart: of the request
09:08:02 <codedmart> Welkin: Don't think I follow. How would the endpoint help?
09:09:53 <Welkin> codedmart: is it really showing your password as plaintext in your logs?
09:09:58 <Welkin> using http basic auth?
09:10:09 <Welkin> it should be encrypted already anyway
09:10:39 <codedmart> Welkin: No not using Basic Auth. I have a route that posts "json". It is the users signup creds.
09:10:58 <codedmart> My logger shows the post body.
09:11:02 <codedmart> And I see the password.
09:13:08 <Welkin> codedmart: it looks like you can use customMiddleware to hook into it manually
09:13:20 <Welkin> then just ignore requests that get sent to your endpoint
09:13:32 <Welkin> don't log them I mean, and let them pass through to the app
09:13:45 <Welkin> or you can modify it before logging
09:14:28 <mniip> pkmx[m], no, sounds like you want functional dependencies
09:14:49 <mniip> or injective type families with associated type synonyms
09:14:53 <codedmart> Welkin: OK thanks!
09:14:59 <Welkin> codedmart: looks like it isn't exported from the module though
09:15:02 <Welkin> but I see it in the source
09:19:17 <pkmx[m]> mniip: yes I'm currently writing it using functional dependencies, but it's ugly and I also want to use the fundep as a type-level function
09:32:53 * hackagebot cabal-lenses 0.4.8 - Lenses and traversals for the Cabal library.  https://hackage.haskell.org/package/cabal-lenses-0.4.8 (DanielTrstenjak)
09:39:45 <Gurkenglas> http://lpaste.net/176700 why can't it deduce that fundep? if f -> g, then StateT s f -> StateT s g, right?
09:40:34 <Gurkenglas> This works, says lambdabot: lpaste.net/150858
09:40:37 <Gurkenglas> @letlpaste 150858
09:40:39 <lambdabot>  Defined.
09:42:30 <mniip> Gurkenglas, like it says, you need UndecidableInstances
09:42:32 <orion> .j #ghc
09:42:53 * hackagebot cabal-bounds 1.0.3 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  https://hackage.haskell.org/package/cabal-bounds-1.0.3 (DanielTrstenjak)
09:42:54 <rexim> Gurkenglas: hi! :D
09:43:11 <Gurkenglas> mniip, that gives this: http://lpaste.net/8033001612882477056
09:43:55 <mniip> sounds like you're using Coercible instances that you shouldn't be using
09:44:52 <mniip> can you write it without coerce?
09:45:23 <Gurkenglas> Oh hey that worked I already tried UndeicidableInstances and removing the coerce use before asking but I guess I must have missed one of the 2x2 possibilities
09:45:40 <Gurkenglas> Thanks.
09:50:39 <lingxiao> hey all
09:51:00 <lingxiao> i have a type error i cant resolve
09:51:40 <ongy> lingxiao: best bet is to paste it somewhere
09:51:43 <ongy> @lpaste
09:51:43 <lambdabot> Haskell pastebin: http://lpaste.net/
09:51:51 <lingxiao> yeah sorry editing the paste right now
09:52:14 <lingxiao> here it is: http://lpaste.net/176703
09:52:21 <lingxiao> sourceFileE function
09:55:37 <lingxiao> if i annotate error with SomeException, a new error occurs: http://lpaste.net/176705
09:57:54 * hackagebot cabal-bounds 1.0.4 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  https://hackage.haskell.org/package/cabal-bounds-1.0.4 (DanielTrstenjak)
09:58:21 <lingxiao> putting  AllowAmbiguousTypes pragma doesnt help
10:02:29 <Welkin> lingxiao: where is the `e` used in your type delcaration?
10:02:56 <lingxiao> sorry ?
10:03:04 <Welkin> I'm not familiar with Exception
10:04:38 <lingxiao> yeah me neither
10:04:40 <lingxiao> (
10:04:41 <lingxiao> :(
10:07:54 * hackagebot cabal-cargs 0.7.10 - A command line program for extracting compiler arguments from a cabal file.  https://hackage.haskell.org/package/cabal-cargs-0.7.10 (DanielTrstenjak)
10:12:25 <lyxia> lingxiao: where is yield from
10:12:33 <lingxiao> conduit
10:12:39 <lingxiao> http://hackage.haskell.org/package/conduit-1.2.7/docs/Data-Conduit.html#g:6
10:14:00 <lingxiao> ok fiexed it
10:17:55 * hackagebot hsimport 0.8.0 - A command line program for extending the import list of a Haskell source file.  https://hackage.haskell.org/package/hsimport-0.8.0 (DanielTrstenjak)
10:22:09 <Welkin> lieven: what was the fix?
10:22:24 <Welkin> lingxiao ^
10:22:27 <Welkin> they left, oh well
10:24:15 <maerwald> love it when people do that...
10:27:18 <ongy> the joys of irc
10:27:55 * hackagebot confsolve 0.5.5 - A command line tool for resolving conflicts of file synchronizers.  https://hackage.haskell.org/package/confsolve-0.5.5 (DanielTrstenjak)
10:41:08 <daniel_w> Anyone know why GHC has a problem with this: http://lpaste.net/176711
10:45:58 <Welkin> daniel_w: what's the error?
10:47:16 <daniel_w> Welkin, it was complaining that Zipped wasn't necessarily injective. I fixed it with judicious use of Proxies
10:47:41 <daniel_w> That error has caught be out so many times.
10:49:42 <daniel_w> I forget that, not only does GHC have to devise a way to produce a value, it also has to know that it can ascertain the types at the callsite
10:51:35 <daniel_w> I think I prefer the idris approach, where, the responsibily to provide the types is with the caller.
11:00:33 <michaelt> daniel_w: why does it work with 'AllowAmbiguousTypes'? 
11:01:58 <Gurkenglas> Travis says my library doesnt compile with ghc 7.6.3 because it didnt add a Functor restriction to a Monad restriction. Should I comply or remove 7.6.3 support?
11:02:28 <daniel_w> michaelt, because in that case GHC will ignore the fact that it doesn't know that the function is injective and just pick any matching types
11:02:59 <daniel_w> and since one form reduces to the other, they are equivalent
11:05:13 <ongy> Gurkenglas: I woulod comply, mostly because of https://packages.debian.org/jessie/ghc
11:07:07 <lingxiao> hey are there any one here comfortable with excpetions?
11:07:39 <c_wraith> depends on what "comfortable" means.  And also what kind of exceptions you're asking about
11:07:48 <lingxiao> I'm getting this eror: http://lpaste.net/176717
11:07:59 <lingxiao> the function is err2, it's giving me a lot of trouble
11:08:18 <c_wraith> lingxiao: https://haskell-lang.org/tutorial/exception-safety is a good first step, though I haven't checked to see if anything it says is relevant to your problem
11:08:54 <lingxiao> I just want to catch an exception and output some other stuff
11:08:58 <c_wraith> lingxiao: ok, that just looks like a normal compile error
11:09:03 <lingxiao> my problem is mostly with type stuff
11:09:13 <lingxiao> yeah not sure how to work twith Exception type
11:09:27 <c_wraith> lingxiao: ... the type of sourceFileE is kind of nonsense
11:09:28 <lingxiao> the doc is mostly about when to use what exception
11:09:32 <c_wraith> lingxiao: e is never used
11:09:43 <lingxiao> yeah I had to put it there 
11:09:46 <Welkin> c_wraith: that is what I asked haha
11:10:04 <c_wraith> lingxiao: well, no.  You didn't.  It never actually is used;
11:10:19 <c_wraith> lingxiao: so it obviously can't work
11:10:38 <lingxiao> this is the signature for catchC:  catchC :: (MonadBaseControl IO m, Exception e) => ConduitM i o m r -> (e -> ConduitM i o m r) -> ConduitM i o m r
11:10:53 <lingxiao> yeah I never used it, I just threw it away, but why wont it work?
11:11:08 <lingxiao> what's the kosher way of doing it?
11:11:11 <c_wraith> lingxiao: it doesn't work because it can't work.  There's no way to specify what type it is.
11:11:15 <c_wraith> lingxiao: just remove it from the context
11:11:17 <Welkin> lingxiao: you put a constraint on a type variable that doesn't exist
11:11:17 <Welkin> lol
11:11:18 <lingxiao> the use case is that if I cant find a file, i just out put emtpy bytestring
11:11:26 <lingxiao> if i do then i get a type error
11:11:33 <c_wraith> lingxiao: then fix that type error
11:11:46 <michaelt> daniel_w: yes I see that much. I see it works if I separate the cases, sameNil ::  Dict (Zipped '[] (x ': r) l ~ Zipped (l ': '[]) r x ) and sameCons ...
11:11:48 <lingxiao> how do i fix it?
11:12:05 <lingxiao> http://lpaste.net/176723
11:12:07 <lingxiao> thisis the error
11:12:08 <c_wraith> lingxiao: that'd depend on what it is. :)
11:12:15 <lingxiao> sent the link
11:12:27 <c_wraith> Why did you take out the SomeException ascription?
11:12:46 <c_wraith> That was correct.  The problem was the context.
11:12:49 <lingxiao> oh ok i put it back 
11:12:51 <lingxiao> ok now it works
11:12:56 <c_wraith> :)
11:13:31 <lingxiao> thanks! ... but :\ in this function: err2 = runConduit $ sourceFileE "" =$= logData =$= cap 
11:13:53 <lingxiao> im getting this error again: http://lpaste.net/176724
11:13:59 <michaelt> lingxiao: I think `(SomeException _) -> return mempty` works in these cases.
11:14:29 <daniel_w> lingxiao: the problem is the compiler doesn't know what kind of exceptions to catch.
11:14:36 <lingxiao> ok update th link: http://lpaste.net/176724
11:14:44 <lingxiao> yeah and im not sure where to annotate that information
11:14:45 <Velizar> Theoretical question: Using the (+) function, we can get all of the (+1), (+2) etc functions by currying with the appropriate arguments; using a more general function, we can get (+), (*) and more functions. My question is, is there an established concept for a function from which you can get all functions? In order to be useful, the arguments must be done in a useful way - otherwise I can just say that eval is that, but this doesn't give any useful 
11:14:46 <Velizar> structure which relates different functions. 
11:15:04 <michaelt> lingxiao: I mean `\(SomeException _) -> return mempty` 
11:15:31 <lingxiao> that would be in sourceFileE' or err2?
11:15:37 <lingxiao> my sourceFileE' compiles as it is:
11:15:53 <lingxiao> catchC (sourceFile f)  (\(e :: SomeException) -> yield mempty)
11:15:57 <Welkin> Velizar: not sure what you are asking
11:16:00 <aweinstock> Velizar: Ackermann's function is the general function that gets you the entire arithmetic hierarchy (+, *, ^, etc)
11:16:05 <lingxiao> but it's my err2 function that is giving me rror:
11:16:15 <lingxiao> err2 = runConduit $ sourceFileE "" =$= logData =$= cap
11:16:20 <michaelt> lingxiao: Oh sorry, I haven't seen that one yet.
11:16:24 <lingxiao> yup np
11:16:28 <lingxiao> lots of conversation going on
11:16:52 <aweinstock> Velizar: maybe{ universal turing machines/lambda evaluators/eval} more generally, but those aren't suitable for currying
11:17:27 <Velizar> Welkin: Sorry, I don't think I can explain any better. Possibly my fault. 
11:19:49 <Velizar> btw, my practical motivation is modelling abstractions, and it seems like an abstraction is just one less parameter applied to that universal function
11:21:16 <michaelt> lingxiao: It's simpler than it seems, the extra "Exception e" constraint was not needed
11:21:27 <AzureStigma> this may be off-topic so if so please ignore it. Im starting college in fall and need java as a requirment and if i have been studying haskell all summer when i take java 2 in the fall is it going to be easy to understand the synatax also can functional aspects of what I am learning be incorporated? If it were upto be I wouldnt even learn java but this is a requirments
11:21:43 <michaelt> lingxiao: so when you write err2, the compiler cant figure out what to do with the constraint
11:22:04 <michaelt> lingxiao: it's like writing mysum :: Functor f => [Int] -> Int ...
11:23:03 <lingxiao> yeah so it makees sense in that respect .. but how do i fix it?
11:23:55 <michaelt> lingxiao: just delete the Exception constraint  ... `sourceFileE :: (FileOpS m s)  => FilePath -> Source m ByteString ...`
11:24:21 <aweinstock> AzureStigma: once you've learned a few languages, syntax is pretty straightforward. Semantics might be a bit trickier, but if you can teach yourself haskell, java isn't that much more complicated
11:24:38 <Gurkenglas> For TraversableT, should I use Control.Monad.Trans.Traversable or Control.Monad.Traversable?
11:24:40 <lingxiao> michaelt sorry what do you mean?
11:25:14 <Welkin> AzureStigma: java has nothing in common with haskell other than it is a programming language
11:26:18 <michaelt> lingxiao: use the signature I gave above for `sourceFileE` http://sprunge.us/AUML
11:26:23 <AzureStigma> well my friend knows java and when i showed him haskell code he was able to understand it 
11:27:33 <lingxiao> ohhh hahha
11:28:00 <lingxiao> I removed the Exception e in sourceFileE' not sourceFileE, and my err2 was using sourceFileE
11:28:02 <lingxiao> oh my
11:28:05 <lingxiao> thank you!
11:28:21 <michaelt> lingxiao: I find that happens to me quite a bit when refactoring, a constraint on a no-longer-used-type is left hanging
11:29:27 <lingxiao> yeah ... epseically after staring at the screen for so long
11:35:09 <lingxiao> hey all
11:35:25 <lingxiao> suppose I traverse all files in some directory using sourceDirectory
11:35:59 <lingxiao> what's the kosher way to "fold" over this list of filespaths, open each file and do some funtion on it, and then combine the output
11:36:55 <lingxiao> the computation would look like:     [path1 .... pathn]  ---> [file1 ..... filen] ---> [f (file1), .... f (filen)] ---> f (file1) <> .... <> f (filen)
11:37:07 <lingxiao> but hopefully ... the list of files doesnt actually exist in memory
11:37:13 <lingxiao> otherwise I could just use foldM
11:37:21 <lingxiao> i'm doing all of this in the conduit library btw
11:37:39 <Cale> There's a directory-tree package which might be of some use
11:38:09 <Cale> Oh, there are so many files that you wouldn't want to keep all their names in memory?
11:39:48 <geshe> why would GLU link properly for my executable but not in ghci
11:39:51 <michaelt> lingxiao: there are several packages for this sort of thing, here's one https://hackage.haskell.org/package/posix-paths-0.2.1.0/docs/System-Posix-Directory-Traversals.html#v:traverseDirectory
11:40:05 <geshe> is there a way to force linking in ghci
11:40:11 <lingxiao> Cale yeah the biggest thing is memory manageent
11:40:22 <lingxiao> the naive solution had a space lak
11:40:24 <lingxiao> leak*
11:40:37 <lingxiao> so one use case is fold over the directory, open all files and concactenate them
11:40:42 <lingxiao> the final file is ~20GB
11:41:10 <Cale> How many files are we talking about? Storing all the file *contents* in memory is a whole lot more likely to create problems than just the tree of paths
11:41:20 <lingxiao> a more common usecase is open each file, count the occurences of some thing, then add all the occurences up
11:41:33 <lingxiao> oh im saying Dont store all contents in memory
11:41:39 <Gurkenglas> http://lpaste.net/7067810968415240192 is there a way to write this that satisfies ghc and doesnt have me dealing with newtype wrappers?
11:41:52 <lingxiao> Cale 100+ files
11:43:36 <lingxiao> michaelt so im not really doing any deep traversals
11:44:02 <lingxiao> its just one directory of .gz files, i just need to unzip them and do some funtion on each unzip file
11:44:20 <Cale> So yeah, it won't be a problem just to obtain the list or tree of all the file paths. The tricky part is just making sure that you evaluate whatever function it is and don't retain the file contents in memory. foldM or something over the list of files could indeed work.
11:45:06 <lingxiao> yeah I did something funky so that i did encounter overflow
11:45:17 <lingxiao> right now im doing everything in the conduit library anyways
11:45:26 <lingxiao> Im just wondering if there's a way using conduit's stuff to do that
11:45:39 <lingxiao> its good for managing memrory right? conduit and pipes?
11:45:55 <michaelt> http://hackage.haskell.org/package/pipes-files fwiw The gzip part of this I'm not following
11:46:23 <Cale> I'm less experienced when it comes to figuring out the performance of conduit stuff, but yeah, conduit and pipes are considered good solutions when you want to do streaming I/O but need to keep careful track of resources.
11:46:29 <Cale> (and exceptions)
11:47:16 <lingxiao> ok i'll look into that link
11:47:34 <lingxiao> the zip part is a distraction .. the main thing is folding over a list of files and doing functonn on each
11:47:57 <lingxiao> like foldr f mempty $ openFile <$> [filePath1, filePath2, ... filePathn]
11:49:05 <Cale> You almost certainly don't want to open all the files at once like that
11:49:23 <Cale> You want to open one file at a time, compute some summary of it, and close it.
11:49:58 <Cale> Most operating systems have somewhat draconian limitations on the number of open filehandles.
11:51:32 <Cale> I would start by writing a function which takes a FilePath and produces an IO action for computing whatever thing it is you're interested in -- being careful that you're not just returning an as-yet-unevaluted expression in terms of the entire file contents.
11:53:02 <Cale> Control.Exception.evaluate might be of some use there, to make sure that you're evaluating the function of the file contents that you're computing (with the usual caveat that it only evaluates to WHNF, so you might need to do more to evaluate the components of the data structure if you're producing something more complicated)
11:53:23 <lingxiao> wow ok that's actually really helpful
11:53:34 <lingxiao> so you're saying conduit is not a necessary solution?
11:53:56 <Cale> Conduit and pipes solve a problem which is somewhat orthogonal
11:54:24 <Cale> If the file is so big that its contents don't fit into memory, you might need to consume it in chunks
11:54:28 <Cale> they help you do that
11:55:06 <Cale> They're kind of more principled solutions to the problem that lazy I/O is a solution to.
11:55:58 <lingxiao> I see .. so it's not really the case that if I use conduit, then magically memory problems will disappear
11:56:04 <Cale> right
11:57:57 <lingxiao> oh boy .. 2 days wasted :(
11:58:01 <Cale> They still might be a good way to organise the computation of this summary of the concatenation of the file contents
11:58:35 <lingxiao> yeah .. i guess i like the compositionality of it from a syntax perspective more than anything
11:58:40 <Cale> yeah
12:00:06 <lingxiao> Cale ok I need to do more research then .. meanwhile I also asked a SO question just to get more eyeballs: http://stackoverflow.com/questions/38935950/how-would-you-traverse-a-directory-and-do-some-function-on-all-files-and-combine
12:01:37 <michaelt> lingxiao: I am confident the memory problem will disappear if you use pipes or conduit or whatever. Once you have the sequence of filenames, or data dependent on these, the usual fold is a strict left fold
12:02:24 <lingxiao> michaelt ok that gives me a silver lining that i didnt completely waste my time haha ...
12:02:41 <lingxiao> so once I grab all fileNames I can yield it downstream
12:02:47 <lingxiao> but what would i do with it then?
12:03:05 <lingxiao> like Im not sure how to express it with conduit's primitives
12:06:07 <michaelt> lingxiao: oh i didn't retain its in the standard utility package for conduit http://hackage.haskell.org/package/conduit-combinators-1.0.4/docs/Data-Conduit-Combinators.html#v:sourceDirectory
12:06:13 <Cale> It's still possible to use conduit/pipes to build up a giant unevaluated expression in memory
12:06:35 <Cale> But so long as you're careful to make the evaluation happen, it shouldn't be a huge problem
12:07:22 <lingxiao> michaelt oh are you Michael Snoyman? amazing
12:07:36 <lingxiao> so you're saying i should use sourceDirectoryDeep?
12:07:37 <michaelt> oh Michael S wrote a little tutorial http://www.yesodweb.com/blog/2014/03/efficient-directory-traversals
12:08:21 <michaelt> Cale: there are many ways of messing up memory wise with these libraries. It just gets harder to do.
12:08:26 <Cale> Right.
12:08:26 <lingxiao> wait that doesn do what i want though?
12:08:37 <Gurkenglas> Can I have two modules with different dependencies, so people using one don't have to install the dependencies of the other?
12:08:50 <lingxiao> so suppose I do   (sourceDirectory dirPath =$= ...)
12:08:54 <lingxiao> what should come after =$=?
12:09:10 <lingxiao> so call this foo :: conduit i m o 
12:09:33 <lingxiao> in foo i need to open all the files and and do something on each .. then fold with some function f 
12:09:37 <lingxiao> how would i express it?
12:10:20 <lingxiao> i guess ive reduced problem to I'm not familiar with the api
12:10:24 <michaelt> lingxiao: right, that's what I understood. Then you need to make a conduit consumer that corresponds to your fold. See Conduit.foldMC for example
12:10:50 <michaelt> foldMC :: Monad m => (a -> b -> m a) -> a -> ConduitM b o m a
12:10:55 <lingxiao> that's in conduit-combinators right?
12:11:18 <michaelt> yes, import Conduit  -- conduit-combinators
12:12:46 <lingxiao> so say I just want to concat each file ...
12:12:50 <lingxiao> then i do:
12:13:18 <lingxiao> and suppose i already have     sourceDirectory path
12:13:56 <michaelt> lingxiao: you want to stream all the contents of all the files?
12:14:36 <lingxiao> yeah ... so on each step of the function i have :    f (file_i) <> someComputationStreamingTheNextFile
12:14:59 <lingxiao> in the most egregious case, im actually concactenating all the files together
12:15:18 <lingxiao> but more commonly I'm actually just counting items in each file
12:15:23 <michaelt> right, if that means represent it all in single bytestring, it's a bad idea of course.
12:15:27 <Gurkenglas> TraversableT Maybe is isomorphic to MaybeT, using iso coerce coerce. Should I define that isomorphism and turn my mtl-only dependency into a profunctor+mtl dependency?
12:15:41 <Gurkenglas> (And the other ones for EitherT and IdentityT and ListT.)
12:16:09 <lingxiao> michaelt yeah makes sense .. so say i just want to count the length of each file ..
12:16:12 <lingxiao> then I write:
12:16:17 <michaelt> lingxiao: but if you can write an io function :: FilePath -> IO Int, then you can stream these numbers sourceDirectory =$= mapMC function 
12:16:40 <lingxiao> sorry that doesnt type check?
12:16:53 <michaelt> sourceDirectory "."
12:16:57 <lingxiao> foo = sourceDirectory path =$= mapMC fun 0   for example?
12:17:07 <lingxiao> oh .. wait hold on could we write it in non-point free please?
12:17:15 <michaelt> mapMC :: Monad m => (a -> m b) -> Conduit a m b
12:17:23 <lingxiao> :t (mapMC . =$=)
12:17:25 <lambdabot> parse error on input ‘=$=’
12:17:34 <lingxiao> :t (mapMC . (=$=))
12:17:35 <lambdabot>     Not in scope: ‘mapMC’
12:17:35 <lambdabot>     Perhaps you meant one of these:
12:17:35 <lambdabot>       ‘mapM_’ (imported from Data.Foldable),
12:17:35 <mniip> Gurkenglas, there was some package offering stuff for newtypes
12:17:39 <mniip> :t ala
12:17:40 <lambdabot> (Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
12:17:46 <michaelt> Oh, I was using "." for the current directory!
12:17:59 * hackagebot lol 0.5.0.0 - A library for lattice cryptography.  https://hackage.haskell.org/package/lol-0.5.0.0 (crockeea)
12:18:19 <lingxiao> oh haha ..
12:18:24 <mniip> oh
12:18:26 <mniip> that's lens
12:18:27 <lingxiao> hahahaha
12:18:55 <mniip> ah there it is
12:18:59 <mniip> @hackage newtype
12:18:59 <lambdabot> http://hackage.haskell.org/package/newtype
12:20:11 <Cale> "lol" has to be the most confidence-inspiring name for a crypto library :D
12:20:36 <sm> :)
12:21:59 <michaelt> lingxiao: theres a simple IO 'getFileSize" somewhere , but this typechecks sourceDirectory "." =$= mapMC (\path -> liftIO $ fmap B.length $ B.readFile path)
12:22:55 <lingxiao> btw there's no mapMC?
12:22:59 * hackagebot libnotify 0.2 - Bindings to libnotify library  https://hackage.haskell.org/package/libnotify-0.2 (MatveyAksenov)
12:23:00 <lingxiao> did you mean mapM_C?
12:23:17 <lingxiao> :t mapMC
12:23:19 <lambdabot>     Not in scope: ‘mapMC’
12:23:19 <lambdabot>     Perhaps you meant one of these:
12:23:19 <lambdabot>       ‘mapM_’ (imported from Data.Foldable),
12:23:22 <lingxiao> import Conduit
12:23:26 <lingxiao> :t mapMC
12:23:27 <lambdabot>     Not in scope: ‘mapMC’
12:23:27 <lambdabot>     Perhaps you meant one of these:
12:23:27 <lambdabot>       ‘mapM_’ (imported from Data.Foldable),
12:23:32 <lingxiao> :t mapM_C
12:23:34 <lambdabot>     Not in scope: ‘mapM_C’
12:23:34 <lambdabot>     Perhaps you meant one of these:
12:23:34 <lambdabot>       ‘mapM_’ (imported from Data.Foldable),
12:27:51 <lingxiao> ok nvm got it!
12:27:59 * hackagebot Gamgine 0.5.1 - Some kind of game library or set of utilities.  https://hackage.haskell.org/package/Gamgine-0.5.1 (DanielTrstenjak)
12:28:01 * hackagebot layers-game 0.5.1 - A prototypical 2d platform game.  https://hackage.haskell.org/package/layers-game-0.5.1 (DanielTrstenjak)
12:29:36 <michaelt> lingxiao: this is barbaric but this is working with what I have imported in ghci :  runResourceT $  sourceDirectory "." $$ filterC (\path -> takeExtension path == ".txt") =$= mapMC (\path -> liftIO $ fmap B.length $ B.readFile path) =$= foldlC (+) 0
12:30:10 <michaelt> there are 'getFileSize' functions around that don't require reading the file of course.
12:30:15 <lingxiao> michaelt so the thing is that it's reading a file using B.readFile right?
12:30:28 <michaelt> lingxiao: in this case yes
12:30:39 <lingxiao> yeah in my case I'm actaully traversing the file and examining each item .. :(
12:30:57 <michaelt> lingxiao: right, that's why I didn't worry about reading the whole file to get its length ...
12:31:03 <lingxiao> so i wrote this funciton: sourceFileE f = catchC (sourceFile f) (\(e :: SomeException) -> yield mempty)
12:31:15 <lingxiao> and there'd be no way to use that in place of readFile right?
12:31:40 <lingxiao> and what's this B in B.readFile?
12:31:47 <michaelt> lingxiao: oh yeah, just write the function you want. 
12:32:08 <michaelt> lingxiao: import qualified Data.ByteString as B -- i just used that arbitrarily.
12:32:59 * hackagebot layers-game 0.5.2 - A prototypical 2d platform game.  https://hackage.haskell.org/package/layers-game-0.5.2 (DanielTrstenjak)
12:33:00 <lingxiao> hmm.. itd be kind of awkward though to use a conduit inside of a conduit?
12:33:01 * hackagebot rlwe-challenges 0.0.0.1 - Ring-LWE/LWR challenges using Lol.  https://hackage.haskell.org/package/rlwe-challenges-0.0.0.1 (crockeea)
12:33:08 <lingxiao> i mean using my sourceFileE function 
12:33:23 <raskell> so I have been struggling with this for a couple days... is there a way to dynamically add predicates to a list comprehension?
12:33:43 <mniip> raskell, guard
12:33:55 <mniip> also well
12:34:24 <mniip> [x <- xs, all ($ x) $ generatePredicatesFrom x]
12:34:27 <mniip> that works too
12:34:55 <mniip> what specifically are you trying to do
12:35:31 <michaelt> lingxiao: hah, i totally forgot about sourceFileE 
12:35:45 <lingxiao> yeah it's really not neccsary
12:35:47 <raskell> mniip, ahh thanks. so basically the problem I am working on
12:35:51 <lingxiao> if the other stuff works i'll go witht hat
12:36:19 <raskell> mniip, ahh thanks. the problem I am working on is almost that I need to count up solutions to a linear equation
12:36:48 <mniip> there's 0, 1, or infinity, isn't there
12:36:56 <mniip> depending on the rank
12:37:11 <lingxiao> ok michaelt im off for a bit
12:37:12 <lingxiao> thank you!
12:37:13 <raskell> so something like this
12:37:19 <michaelt> lingxiao: ok be good!
12:38:47 <ahsfhyicxv1> I am trying to understand monad transformers. Am I doing it correctly? http://lpaste.net/176754
12:40:04 <mniip> uhhhh
12:40:41 <c_wraith> ahsfhyicxv1: that looks weird.  It's really hard to say what's going on there.  It's a snippet without context or a type provided.
12:40:47 <mniip> to answer your other question, prelude doesn't use MonadIO because MonadIO is in transformers and not base
12:41:06 <mniip> c_wraith, I can see what's going on there but it's uhh
12:41:08 <mniip> uhh
12:43:31 <ahsfhyicxv1> c_wraith: what context are you looking for? I included everything but the imports.
12:43:57 <c_wraith> ahsfhyicxv1: as it stands, it's a syntax error.
12:44:24 <c_wraith> ahsfhyicxv1: if it's not even syntactically valid, it's missing a lot of context.
12:45:24 <ahsfhyicxv1> c_wraith: It works for me in a haskell jupyter notebook
12:45:43 <mniip> so it's an expression
12:46:31 <c_wraith> ahsfhyicxv1: it's best to make things syntactically valid if put in a .hs file
12:46:53 <Gurkenglas> Hmm. ListT doesn't even give an Alternative instance that is useful in the same way the MaybeT one is, because both monadic actions have to be executed regardless of the first result.
12:47:05 <geekosaur> for your other question, MonadPlus and Maybe aren't quite the same thing; in fact the closer correspondence is MonadPlus to Monoid --- but Maybe has different instances for each of them (one picks the first, the other picks the last)
12:49:54 <cloudhead> what would be the general way of treating all traversables as lists? I see there's an IsList class, but it's in GHC.Exts, so not sure if I should use that?
12:50:40 <c_wraith> cloudhead: well, toList is part of Foldable, which is a superclass of Traversable.  So you can always convert a Traversable to a list
12:51:03 <cloudhead> oh, so I can import it from there?
12:51:10 <c_wraith> ahsfhyicxv1: the bigger issue is..  Why are you using maybeT at all?
12:51:27 <c_wraith> ahsfhyicxv1: You aren't ever binding together operations that can fail.
12:51:50 <c_wraith> cloudhead: yeah, if you import Data.Foldable, it will give you toList
12:51:52 <dkasak> cloudhead, it's in Data.Foldable
12:52:09 <cloudhead> c_wraith: dkasak: thanks, that's perfect
12:52:22 <dkasak> :t Data.Foldable.toList
12:52:24 <lambdabot> Foldable t => t a -> [a]
12:52:24 <ahsfhyicxv1> c_wraith: I am going to bind together operations that can fail. I was just doing something easy first.
12:52:25 <cloudhead> was thrown off as I expected Data.Foldable to be part of base in ghc 8
12:52:51 <c_wraith> cloudhead: it's always been part of base.  Well, at least for many years
12:53:03 <cloudhead> sorry I meant exported from the prelude!
12:53:08 <dkasak> Yeah, it just isn't in the ...
12:53:10 <dkasak> Prelude :D
12:53:12 <c_wraith> cloudhead: Being part of Prelude is recent.  But not all of it is exported from Prelude now
12:53:15 <dkasak> Too slow.
12:55:29 <cloudhead> I wish the Prelude had stuff like Control.Monad in there
12:55:56 <cloudhead> I almost always have to import that 
12:57:37 <Welkin> cloudhead: you'll abandon the prelude soon 
12:58:00 * hackagebot servant-auth-cookie 0.3.0.3 - Authentication via encrypted cookies  https://hackage.haskell.org/package/servant-auth-cookie-0.3.0.3 (zohl)
12:58:48 <lpaste> c_wraith annotated “Monad transformer attempt” with “Monad transformer attempt (annotation)” at http://lpaste.net/176754#a176782
12:59:24 <c_wraith> ahsfhyicxv1: http://lpaste.net/176754#a176782 is how I would write that particular code.
13:00:49 <EvanR> warning monad transformer do not atempt
13:01:35 <EvanR> funky you can compose a functor with a natural transformation
13:02:52 <cloudhead> Welkin: you're probably right.
13:03:16 <cloudhead> although I haven't found an alternative prelude that is conservative enough to my liking
13:03:34 <cloudhead> Protolude looks really nice, but I think the stance on String is extreme
13:04:28 <cloudhead> classy-prelude has too many new type classes
13:13:00 * hackagebot licensor 0.1.0 - A license compatibility helper  https://hackage.haskell.org/package/licensor-0.1.0 (jpvillaisaza)
13:43:01 * hackagebot lol 0.5.0.1 - A library for lattice cryptography.  https://hackage.haskell.org/package/lol-0.5.0.1 (crockeea)
13:52:00 <Gurkenglas> geekosaur, Monoid Maybe doesnt pick the last o.o
13:52:29 <geekosaur> I was trying to avoid asserting which did which, because I can never remember (and yes, I hate this setup)
13:52:41 <geekosaur> the Monoid stuff at least has newtypes to pick the one you want
13:52:48 <Gurkenglas> Nothing picks the last, why would anything ever pick the last
13:53:52 <Gurkenglas> -Nothing+nothing :D
13:54:28 <Gurkenglas> (I guess Last picks the last but thats explicit)
13:58:02 * hackagebot envy 1.2.0.0 - An environmentally friendly way to deal with environment variables  https://hackage.haskell.org/package/envy-1.2.0.0 (DavidJohnson)
14:03:30 <hsk3> A general question. On his web browser, a visitor hits the route /december-22-2015-vacation (a blog post about a vacation for december 22, 2015) on a Haskell web app (such as Snap).
14:03:31 <hsk3> Should the web app make a new database connection (such as MongoDB connection) on every such hit?
14:03:32 <hsk3> Or should it somehow store database connections in memory?
14:03:38 <hsk3> How are these things usually done?
14:04:03 <hsk3> (the purpose of the database connection is to read the blog post, of course)
14:04:08 <dmj> hsk3: the latter
14:04:55 <hsk3> dmj`: so there should be a one app-wide database connection that will be used by all the web app's visitors?
14:05:11 <dmj`> hsk3: right, but this is usually handled in some sort of connection pool
14:05:22 <dmj`> @package pool
14:05:22 <lambdabot> http://hackage.haskell.org/package/pool
14:05:46 <dmj`> @package resource-pool
14:05:47 <lambdabot> http://hackage.haskell.org/package/resource-pool
14:05:47 <dmj`> rather
14:07:26 <hsk3> hmm ok
14:07:34 <hsk3> why pools?
14:08:23 <hsk3> interesting.
14:09:07 <Maxdamantus> Maybe because the database protocol doesn't do request tagging and the server isn't designed for it.
14:09:33 <Maxdamantus> in which case you'd probably be best just wasting more resources to avoid some latency.
14:10:40 <hsk3> I'm not following.
14:10:41 <hsk3> What dmj` was saying, it sounds like, is that I should first create a single app-wide MongoDB connection. After that, thousands of visitors can trigger database operations using that one connection.
14:10:58 <hsk3> operations such as insert, update, and find.
14:11:03 <hsk3> (mostly find in my case)
14:11:09 <hsk3> (since they're just viewing the blog)
14:12:09 <Maxdamantus> Looking at the resource-pool library, it looks like the intention would be to have potentially more than 1 connection.
14:12:20 <Maxdamantus> but probably still fewer connections than you have clients.
14:13:05 <Welkin> hsk3: you shouldn't be using something like mongo for anything really
14:13:12 <Welkin> it's only (maybe) useful as a cache
14:13:16 <Welkin> not for storing data
14:13:35 <hsk3> why, you prefer sql?
14:13:56 <Welkin> it is not ACID
14:14:02 <Welkin> so your data is not safe from corruption
14:14:05 <Welkin> and it is not relational
14:14:11 <Welkin> and most data you will be storing is relational
14:14:20 <EvanR> its awkward to use mongo for database stuff since you have to go back and reimplement a large chunk of guarantees and structure yourself
14:14:25 <Welkin> unless it is just some mass data (like analytics) that you don't really care about
14:14:32 <EvanR> and sometimes what you need is impossible
14:15:07 <shirt> you can create a new database connection for each http request if you are using an external database pool utility, such as pgbouncer. but resource-pool is really easy to use and recommended. i assume things are similar for mongodb, but i've never used it
14:21:01 <hsk3> But since everything is in a monad
14:21:02 <hsk3> https://hackage.haskell.org/package/mongoDB-2.1.0.2/docs/Database-MongoDB.html
14:21:02 <hsk3> i'm not sure how i'd share a connection across multiple visits
14:21:26 <systemfault> Must be a rotten burrito.
14:21:27 <hsk3> the connect function gives me a pipe, but it's an IO action that has to be performed first
14:33:03 * hackagebot envy 1.2.0.1 - An environmentally friendly way to deal with environment variables  https://hackage.haskell.org/package/envy-1.2.0.1 (DavidJohnson)
14:38:55 <EvanR> if F and G are functors, eta and epsilon are natural transformations what is going on on the left side of the law (epsilon . F) (F . eta) = 1_F, some sort of composition of natural transformations?
14:39:09 <EvanR> i dont get it
14:40:04 <EvanR> how do you compose two natural transformations
15:02:51 <mniip> EvanR, in the category of functors natural transformations are morphisms
15:03:00 <mniip> and composition of them is very, uh, natural
15:07:52 <EvanR> uh
15:08:04 * hackagebot persistent 2.6 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.6 (GregWeber)
15:08:22 <EvanR> so it sends objects in A to arrows in C and the naturality law is just way more complex?
15:09:41 <alercah> EvanR: what is "it" here?
15:09:48 <gfixler> EvanR: where is that eta/epsilon example?
15:10:13 <EvanR> the hott book on page 315
15:10:15 <alercah> EvanR: oh I missed the example before
15:10:27 <alercah> you can totally compose natural transformations
15:10:34 <EvanR> here is another instance on page 314: (δG)(Hγ) = (Kγ)(δF).
15:10:36 <mniip> well, consider all functors from category C to category D
15:10:37 <alercah> why wouldn't you be able to?
15:10:42 <gfixler> page numbers probably depend on which version you have
15:10:45 <mniip> denote each with an object
15:10:53 <EvanR> https://hott.github.io/book/nightly/hott-online-1029-gcbb9cd5.pdf
15:11:12 <gfixler> 404
15:11:14 <EvanR> alercah: im sure you can i just dont understand how
15:11:18 <EvanR> nice
15:11:20 <mniip> morphisms are natural transformations between functors
15:11:48 <mniip> if you have a functor F you can create an "identity" natural transformation, where eta_X = id_FX
15:12:02 <EvanR> ok
15:12:26 <EvanR> yes i know they are morphisms in a functor category, or 2-categories
15:12:45 <mniip> well
15:12:51 <mniip> then what is your question?
15:13:00 <EvanR> how does composition work
15:13:13 <mniip> ok
15:13:31 <mniip> say you have eta1 : F >--> G, eta2 : G >--> H
15:13:56 <mniip> for every X in C, you have eta1_X : FX -> GX, eta2_X : GX -> HX
15:14:02 <mniip> both morphisms in D
15:14:10 <EvanR> F : C -> D ?
15:14:15 <mniip> yes
15:14:19 <EvanR> H : D -> E ?
15:14:22 <mniip> no
15:14:24 <EvanR> er
15:14:32 <mniip> F,G,H : C ===> D
15:14:34 <EvanR> ok
15:14:59 <mniip> eta_X = eta2_X . eta1_X : FX -> HX
15:15:15 <mniip> and that demonstrates a natural transformation eta : F >--> H
15:15:22 <EvanR> oh
15:15:33 <EvanR> that takes care of the types
15:15:38 <mniip> you can prove the naturality laws
15:15:40 <mniip> if you wan
15:15:41 <mniip> t
15:16:32 <EvanR> so composition is defined using composition of the arrows in D
15:18:01 <mniip> yes
15:18:20 <mniip> family of compositions of families of arrows in D
15:20:52 <EvanR> i see
15:21:11 <EvanR> that sort of explains the commutative monoid thing i think
15:21:37 <gfixler> EvanR: how long has it taken you to get 315 pages into that?
15:22:03 <EvanR> i finished the book and went backwards and now im randomly skipping to topics
15:22:39 <gfixler> that's even more hardcore
15:22:43 <EvanR> i got the pdf, order the dead tree book, its been about a month and a half i guess
15:22:52 <gfixler> seems fast
15:23:13 <gfixler> have you done anything else, like Harper's book?
15:23:21 <EvanR> not yet
15:23:26 * EvanR looks up harpers book
15:23:35 <gfixler> guess I'm really asking about prereqs to HOTT
15:24:10 <EvanR> dependent types, though that is covered pretty well in chapter 1
15:24:26 <EvanR> but it took me a few years to get comfortable with those
15:24:32 <gfixler> all this stuff makes my head spin
15:24:59 <gfixler> years, yikes
15:25:00 <EvanR> it assumes you know what a fibration is
15:25:26 <gfixler> it assumes wrong
15:25:29 <EvanR> heh
15:25:40 <exio4> is there any average function in the standard library?
15:25:55 <Welkin> exio4: there is a statistics library I think
15:30:30 <EvanR> gfixler: do you know GADTs
15:30:57 <gfixler> I have sort of understood them a few times
15:31:03 <gfixler> then they've leaked back out of my head
15:31:21 <Welkin> gfixler: it's just a more detailed way of defining datatypes
15:31:22 <EvanR> you define gadt data types by listing the constructors and their types
15:31:23 <gfixler> I'd love a collection of exercises for those, in order of increasing difficulty
15:32:47 <EvanR> like Z :: Nat; S :: Nat -> Nat, "these are how all Nats are constructed"
15:33:30 <EvanR> with higher inductive types in the hott book, you can also define genuinely new ways that two values of the type (points in the space) are equal
15:34:03 <Welkin> I haven't advanced much in haskell for a long time now
15:34:14 <Welkin> I want to learn more about type families and actually use things like datakinds
15:34:20 <Welkin> but I have no idea where I would actually use them
15:34:24 <Welkin> and never see a need
15:35:02 <gfixler> you have to create a new, arcane branch of mathematics that's best served by them
15:35:12 <EvanR> so MkInt :: Nat -> Nat -> Int; Cong :: MkInt x y = MkInt (S x) (S y) "these are all the ways integers are constructed and which points are considered equal"
15:35:35 <gfixler> Cong?
15:35:52 <Welkin> 从？
15:36:01 <EvanR> so you can think of this as defining a space consisting of an infinite grid of points and diagonal lines through them equating them into a space equivalent to the integers
15:36:33 <EvanR> congruent
15:36:46 <gfixler> was just thinking about such a thing last night, but for transformations
15:36:59 <EvanR> 0 is encoded as (0,0), 1 is (0,1) -1 is (1,0), but (1,1) is the same as (0,0), 0
15:37:11 <gfixler> not exactly such a thing - I pulled godel numbers into it
15:37:54 <gfixler> EvanR: boustrophedon diagonals?
15:38:04 * hackagebot persistent-mysql 2.6 - Backend for the persistent library using MySQL database server.  https://hackage.haskell.org/package/persistent-mysql-2.6 (GregWeber)
15:38:07 * hackagebot persistent-sqlite 2.6 - Backend for the persistent library using sqlite3.  https://hackage.haskell.org/package/persistent-sqlite-2.6 (GregWeber)
15:38:09 * hackagebot persistent-postgresql 2.6 - Backend for the persistent library using postgresql.  https://hackage.haskell.org/package/persistent-postgresql-2.6 (GregWeber)
15:40:09 <EvanR> when you define a function from one type to another, you also have to say where the paths go, which paths they map to in the other space. also each point has a trivial path to itself "Refl".
15:40:32 <EvanR> and each path can be inverted and concatenated to form a bigger path, so types have groupoid structure 
15:43:33 <EvanR> you can use HITs to define geometric shapes, like the Circle is base :: Circle; loop :: base = base
15:43:44 <EvanR> you can prove that loop != Refl_base
15:44:14 <gfixler> is refl a standard thing in dep types? I've seen it in coq examples
15:45:56 <EvanR> normally Refl :: x = x is the only way to construct equality
15:46:36 <gfixler> I see
15:46:37 <EvanR> but in hott you can get two different equalities which are not the same
15:46:59 <EvanR> for example a path going around the circle once has no homotopy to the path going around twice
15:47:02 <gfixler> what a twist
15:47:09 <EvanR> ^ literally ;)
15:47:21 <gfixler> :)
15:47:44 <EvanR> homotopy is a path between two paths
15:49:29 <gfixler> yeah, I have a sense of them
15:49:46 <gfixler> in Maya we call that a loft
15:49:59 <EvanR> nice
15:51:12 <EvanR> you can add these higher paths directly as part of your type, so here is a torus: b :: T; p :: b = b; q :: b = b; surf :: p <> q = q <> p
15:51:38 <gfixler> no wonder it took a year
15:52:08 <EvanR> one point, two loops, and a homotopy between the loops (carefully)
15:52:26 <Welkin> EvanR: what is with your types?
15:52:30 <Welkin> p :: b = b ?
15:52:44 <gfixler> forall b
15:52:49 <EvanR> no
15:53:00 <EvanR> b is a constructor
15:53:22 <EvanR> pretend GADTs let you use lowercase letters for the ctors
15:53:52 <Welkin> what's with the =?
15:54:00 <EvanR> in the case of b = b, (=) is a type ctor like T -> T -> Id(T)
15:54:15 <EvanR> =_T is the type of equalities between values of T
15:54:27 <EvanR> a family of types, indexed by two values
15:54:58 <EvanR> the one in surf is different, Id(Id(T))
16:06:13 <biglambda> Has anyone ever successfully stored at Data.Vector to a foreign pointer?
16:06:31 <biglambda> Having a lot of trouble making it work :(
16:06:31 <EvanR> theres something called foreign store
16:06:48 <EvanR> which will let you store a Data.Vector without having to serialize it
16:07:04 <EvanR> but you can also use Storable Vector
16:07:07 <biglambda> I see which library is it in?
16:07:21 <biglambda> I’ve been trying to use storable Vector
16:07:22 <EvanR> foreign-store
16:07:42 <biglambda> but I’m not sure how to malloc the right pointer
16:07:44 <EvanR> Storable Vector is probably what you want
16:07:58 <biglambda> My goal is to send to an OpenCL kernel
16:08:05 * hackagebot snaplet-scoped-session 0.1.1 - Modularised session state for Snaplets, in a Snaplet  https://hackage.haskell.org/package/snaplet-scoped-session-0.1.1 (justus)
16:08:17 <biglambda> I’ve been successful with Repa.Array
16:08:41 <EvanR> try allocaArray ?
16:09:49 <biglambda> Here’s the function I’ve been trying to write http://lpaste.net/176796
16:10:45 <EvanR> and what happens
16:10:51 <biglambda> This is the Repa one that works http://lpaste.net/176797
16:10:57 <biglambda> It doesn’t compile yet
16:11:36 <biglambda> Currently saying Could not deduce (Storable (V.MVector ghc-prim-0.4.0.0:GHC.Prim.RealWorld a))
16:12:12 <EvanR> seems like youre not using the right vector
16:12:49 <EvanR> Storable types can be poked into memory through a pointer, but Storable Vector is a special module of the vector package
16:13:57 <biglambda> Yes I’m importing Data.Vector.Storable as V
16:15:53 <biglambda> Sorry I was jimmying with my code, here is the version that just uses Data.Vector.Vector http://lpaste.net/176800
16:15:58 <EvanR> yeah ok, so those vectors consist of foreign ptrs to storable values
16:16:25 <EvanR> you should be able to poke them using the foreign marshal stuff somehow
16:16:46 <Welkin> alloca I think
16:16:47 <EvanR> or just transfer the pointer directly
16:16:53 <EvanR> they should be pinned
16:17:01 <Welkin> http://hackage.haskell.org/package/base-4.9.0.0/docs/Foreign-Marshal-Alloc.html#v:alloca
16:17:59 <biglambda> I see
16:18:04 <biglambda> Let me give that a shot
16:23:30 <biglambda> I tried this: http://lpaste.net/176803 but I still get: Could not deduce (Storable (V.Vector a)) arising from a use of ‘poke’
16:23:41 <biglambda> where V is Data.Vector.Storable
16:25:05 <Welkin> why allocaBytes instead of alloca?
16:25:14 <Welkin> allocaBytes has no Storable constraint
16:25:39 <biglambda> I see, how would alloc know the size of my vector though
16:25:49 <biglambda> It’s not part of the type
16:27:15 <Welkin> http://hackage.haskell.org/package/base-4.9.0.0/docs/Foreign-Marshal-Array.html
16:27:18 <biglambda> In any case I get the same error if I try to use Alloca
16:27:19 <Welkin> forgot about that
16:27:56 <Welkin> pokeArray
16:28:14 <Welkin> oh, that takes a list
16:28:37 <biglambda> Let me try Vector.toList there
16:29:10 <Welkin> there should be a way to do it straight from a vector
16:29:39 <biglambda> I agree, and actually I get: Could not deduce (Storable [a])
16:30:04 <biglambda> Which makes me think I’m missing something typewise or importing something wrong.
16:30:32 <Welkin> http://hackage.haskell.org/package/base-4.7.0.1/docs/Foreign-ForeignPtr-Safe.html#t:ForeignPtr
16:31:10 <Welkin> http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Storable.html#g:36
16:31:18 <Welkin> maybe those will help
16:31:25 <Welkin> foreign pointer functions for vector
16:34:22 <biglambda> That works
16:34:31 <biglambda> But it seems so unsafe :)
16:35:38 <biglambda> Here’s the compiling function: http://lpaste.net/176803
16:35:51 <biglambda> I’ll let you know if I get an segFaults
16:35:58 <biglambda> *any
16:36:51 <biglambda> I think openCL just copies it over to the GPU so there isn’t much risk of modifying it
17:03:07 * hackagebot persistent-mongoDB 2.5.0.1 - Backend for the persistent library using mongoDB.  https://hackage.haskell.org/package/persistent-mongoDB-2.5.0.1 (GregWeber)
17:07:14 <williamyager> What is the relationship between F-algebras (and Fix, which constructs the initial algebra for a functor) and Free Monads? It seems like they are very closely related
17:07:37 <williamyager> The recursive constructor of Free is essentially identical to the Fix constructor
17:08:56 <williamyager> I guess in F-algebras, you rely on the functor itself having a non-recursive case, whereas with the Free Monad the functor can have no non-recursive cases?
17:08:57 <joe9> I have a bunch of record fields  that I am updating. The update may have a value for the field or Nothing. http://bpaste.net/show/a1c589a974b0 . Just want to check if there is a smart way to thread the record through the maybe functions.
17:10:05 <Rotaerk> :t liftIO . liftIO
17:10:06 <lambdabot> MonadIO m => IO a -> m a
17:18:39 <Gurkenglas> joe9, "maybe record" is at each step going to reset the record back to the original state if a fieldValue is Nothing
17:19:10 <Gurkenglas> Rotaerk, the left liftIO takes an IO a, so the right liftIO is forced to specialize to id
17:19:14 <joe9> Is there a function to change the order of arguments of a function from : f :: a -> b -> c -> a to  f :: b -> c -> a -> a ?
17:19:40 <williamyager> :t \f a b c -> f b c a
17:19:41 <lambdabot> (r1 -> r2 -> r3 -> r) -> r3 -> r1 -> r2 -> r
17:19:55 <Welkin> joe9: unless you want to get fancy with `flip`
17:20:05 <Gurkenglas> joe9, if you're defining f yourself, consider changing its argument order
17:20:18 <mniip> :t (flip .) . flip
17:20:19 <lambdabot> (a1 -> a -> b -> c) -> a -> b -> a1 -> c
17:20:26 <Welkin> it's easier to write it using a lambda wrapper
17:21:00 <mniip> :t flip . (flip .)
17:21:01 <ozev> Though if you really wanted such a combinator: https://www.stackage.org/lts-6.11/hoogle?q=(a+-%3E+b+-%3E+c+-%3E+a)+-%3E+b+-%3E+c+-%3E+a+-%3E+a
17:21:01 <lambdabot> (a -> a1 -> b -> c) -> b -> a -> a1 -> c
17:21:05 <mniip> there, simple enough
17:21:35 <Rotaerk> Gurkenglas, yea I figured; just wanted to confirm it was idempotent
17:22:06 <Welkin> mniip: always golfing
17:22:08 <Gurkenglas> When you're not trying to show lambdabot's output to other people, use /query
17:22:57 <Gurkenglas> maybe id (\t r -> r{field1 = t}) (field1Value :: Maybe Field1) -- joe, lines like this should at least work correctly
17:25:27 <Gurkenglas> If you use State and lens, you can rewrite those lines into lines like "traverse_ (assign field1) field1Value" in a do block
17:26:17 <Gurkenglas> I've heard it said that taking Maybe arguments is the wrong approach in the first place - just export the record and let the user use record update syntax
17:27:02 <joe9> mniip: Gurkenglas Wekin, Thanks.
17:31:09 <vctr> hello
17:32:21 <Welkin> vctr: y lst ll yr vwls
17:33:00 <vctr>  knw rt?
17:33:41 <vctr> workin on anything fun?
17:34:19 <Welkin> does playing nethack count?
17:36:44 <vctr> probably not but i'll accept it :-)
17:47:12 <ahsfhyicxv2> Is there a function with the type signature: (MonadPlus m, IOMonad m) => IO (Maybe t) -> m t?
17:47:34 <ahsfhyicxv2> I meant MonadIO not IOMonad
17:48:41 <ahsfhyicxv2> I searched hayoo and nothing came up
17:48:42 <Welkin> asm89: you can't escape IO unless you use unsafePerformIO
17:49:07 <Welkin> oh, m is still IO
17:50:05 <Welkin> @hoogle (MonadPlus m, MonadIO m) => IO (Maybe a) -> m a
17:50:07 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
17:50:07 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
17:50:07 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
17:51:03 <ahsfhyicxv2> Welkin: I already searched
17:52:05 <ahsfhyicxv2> I assume I have to write it myself using mfromMaybe and liftIO but I can't figure out how
17:52:41 <dustmote> i'm watching phillip wadler's talk https://www.infoq.com/presentations/category-theory-propositions-principle
17:53:23 <dustmote> i'm having a bit of trouble understanding product, because the only example is a tuple, which seems contrived... 
17:53:56 <dustmote> it's also confusing because I don't understand what 'c' is, at the top of mr. wadler's diagram
17:54:38 <dustmote> whereas for sum (Either a b) makes total sense to me because of the type of `either :: (a -> c) -> (b -> c) -> Either a b -> c`
17:55:04 <dustmote> can anyone recommend some better examples for product? google seems useless (or i don't know the right specifying keywords)
17:55:35 <Welkin> dustmote: what do you mean by product?
17:55:36 <mauke> :t \x -> do y <- liftIO x; case y of Nothing -> mzero; Just z -> return z
17:55:37 <lambdabot> (MonadPlus m, MonadIO m) => IO (Maybe b) -> m b
17:56:15 <dustmote> Welkin: at 11:14 in the presentation, he has a diagram: https://cdn.infoq.com/statics_s1_20160809-0249u1/resource/presentations/category-theory-propositions-principle/en/slides/sl3.jpg
17:56:22 <ahsfhyicxv2> mauke: Thanks
17:56:50 <Welkin> dustmote: oh, you mean sum and product types
17:57:33 <dustmote> yes, but explained the way he has, they seem to be general concepts which could be inhabited by satisfactory types
17:57:47 <dustmote> so i'm thinking of them as typeclasses?
18:06:26 <dustmote> these are what he's talking about .. they're alright https://en.wikipedia.org/wiki/Product_(category_theory) sum: https://en.wikipedia.org/wiki/Coproduct
18:24:51 <ozev> Is it a fair gloss to say that `Data` is `Generic` with names?
18:28:09 * hackagebot inchworm 1.0.0.1 - Inchworm Lexer Framework  https://hackage.haskell.org/package/inchworm-1.0.0.1 (BenLippmeier)
18:42:15 <mmhelloworld> Hi all, In a stack project, is it possible to use environment variables in the cabal file or in some way parameterize the build so that it can take options from the user?
18:43:16 <Axman6> Cabal files allow you to specify binary flags
18:43:50 <mmhelloworld> yes, that's what I found too from googling but I need non-binary values
18:43:58 <Axman6> https://www.haskell.org/cabal/users-guide/developing-packages.html#configurations
18:44:05 <Axman6> that's a little harder then
18:44:35 <Axman6> you can use CPP and set flags to use imnside Haskell files
18:47:48 <mmhelloworld> ok otherwise I am thinking of running some kind of script or a haskell file to preprocess and substitute values in cabal file
19:08:12 * hackagebot jupyter 0.9.0 - A library for creating and using Jupyter kernels.  https://hackage.haskell.org/package/jupyter-0.9.0 (gibiansky)
19:18:12 * hackagebot lol 0.5.0.2 - A library for lattice cryptography.  https://hackage.haskell.org/package/lol-0.5.0.2 (crockeea)
19:47:11 <ReinH> mmhelloworld: what's your use case?
19:50:03 <mmhelloworld> ReinH: I am interfacing with JVM so the build needs libjvm.so and some header files from JVM so I thought of having the user provide JAVA_HOME and in cabal file, I can have the paths for those under include-dirs, extra-lib-dirs relative to JAVA_HOME
19:51:53 <lingxiao> hey all
19:52:01 <lingxiao> i have a problem with using conduit's combinators
19:52:47 <lingxiao> I want to say:
19:53:21 <lingxiao> pipe = sourceDirectory path =$= mapAll openFile =$= mapAll fileLength =$= fold (+) 0
19:53:40 <lingxiao> basically open all files and count the length of each file, then sum the length
19:54:14 <lingxiao> the problem is mapM_C has signature   (a -> m ()) -> Consumer a m ()
19:54:20 <lingxiao> so i cant attach anything downstream
19:54:41 <Axman6> you probably don't want to actually open the filed if you're just wanting the length, there should be a way to stat them (probably doesn't solve your problem but will stop the program being killed for having too many files open)
19:54:59 <Axman6> files*
19:55:29 <lingxiao> yeah im using conduit
19:55:49 <lingxiao> witht he hope that the files will be open one at a time, their length computed, then file handle closed while the next file opens
19:56:01 <lingxiao> i'm actually opening hundreds of files and each one is pretty big
19:56:15 <lingxiao> all together the directory is 10s of GB
19:57:04 <michaelt> what is mapAll
19:58:51 <lingxiao> there is no mapall
19:59:00 <lingxiao> sorry its like pseudocode
19:59:21 <lingxiao> yeah actuall michaelt im glad youre around since the code we spoke about earlier had things thats not inthe conduit library
19:59:37 <lingxiao> this is what we discuessed: 
19:59:38 <lingxiao> http://lpaste.net/176827
19:59:49 <lingxiao> it pointed me in the right direction, but htere is no mapMC ?
20:00:15 <lingxiao> only mapM_C, which when I used I got an error since mapMC is (a -> m ()) -> Consumer a m ()
20:00:27 <lingxiao> so it no longer outputs anything for downstream conduits ?
20:00:31 <Axman6> https://www.stackage.org/haddock/lts-6.11/conduit-1.2.7/Data-Conduit-List.html#v:mapM
20:01:08 <lingxiao> oh boy .. ive ben looking at the wrong docs
20:01:14 <lingxiao> this is what im looking at
20:01:15 <lingxiao> http://hackage.haskell.org/package/conduit-1.2.7/docs/Data-Conduit.html#g:6
20:01:22 <michaelt> I was using conduit-combinators 'import Conduit'
20:01:33 <michaelt> and I was using 'import System.FilePath'
20:01:58 <lingxiao> yeah that's what i did too?
20:02:25 <michaelt> http://sprunge.us/cFXH
20:03:00 <lingxiao> sorry michaelt could you put a type signature on that?
20:03:23 <lingxiao> there is no mapMC in this: https://www.stackage.org/haddock/lts-6.11/conduit-1.2.7/Data-Conduit-List.html#v:mapM
20:04:25 <lingxiao> and it's weird .. Axman6 when I imoprt conduit I dont get all the functions in stackage's verison?
20:04:36 <lingxiao> I'm using stack to init my project and heres my .cabal file
20:04:41 <Axman6> you might also want to look at https://hackage.haskell.org/package/unix-2.7.2.0/docs/System-Posix-Files.html#g:5
20:04:51 <lingxiao> http://lpaste.net/176828
20:04:53 <michaelt> http://sprunge.us/IUjH lingxiao 
20:05:31 <Axman6> did you import Data.Conduit.List?
20:05:47 <Axman6> importing Foo.Bar does not mean you get everything in Foo.Bar.Baz
20:06:47 <lingxiao> huh super weird .. now it works michaelt .. i do have mapMC
20:06:53 <lingxiao> yeah Axman6 i did not
20:06:55 <lingxiao> thanks
20:07:22 <michaelt> I think 'import Conduit' covers 'Data.Conduit.List' though the names have C at the end
20:09:00 <Axman6> I can't even see any fooC functions in the stackage docs
20:09:02 <michaelt> lingxiao: also, when main is of the form : main = runResourceT $ do ... , the inferred type is likely to be more general than `IO x`, so you should annotate main
20:09:18 <lingxiao> ok i'll keep that in mind thanks for that tip
20:09:33 <michaelt> Axman6: I was using conduit-combinators, the omnibus module
20:09:42 <Axman6> ah
20:10:04 <lingxiao> by the way i have a question about waht the right *choice* is
20:10:26 <lingxiao> Im making a bunch of conduit combinators specific for my domain .. a little language if you will
20:10:40 <lingxiao> and some of them have MonadIO constraints, others MonadIO and MonadResource
20:11:01 <lingxiao> one has MonadBaseControl IO m,  and I also plan on keeping a counter so one of them mgiht have MonadSatte
20:11:23 <lingxiao> does it make sense to make on constraint like this:   type FileOpS m s = (MonadState s m , MonadIO m, MonadResource m, MonadBaseControl IO m) 
20:11:42 <lingxiao> and say all of them have this constraint : ...  so   foo :: FileOpS m s => Conduit i m o
20:11:43 <michaelt> its crazy how much you get from the one 'import Conduit', sinkVector mapMC sourceRandom 
20:12:18 <synergistics> What package should I be using for Hashtables? The one in base or in the hashtables package?
20:12:54 <Axman6> synergistics: unordered-containers
20:15:25 <synergistics> Axman6: Oh ok. Has the performance of HashMaps gotten any better?
20:15:43 <Axman6> they've always been very good, not sure what you're referring to
20:17:32 <michaelt> synergistics: you are thinking of a mutable hashtable, maybe
20:17:54 * geekosaur was wondering if they had heard of the old Data.Hashtable...
20:18:08 <haxx0r> dont worry
20:18:13 <synergistics> michaelt: Oh, yea that's what I had heard complaints about
20:18:17 <haxx0r> krya krya
20:18:36 <Axman6> unordered-containers has had a lot effort put into making it fast
20:18:39 <geekosaur> that one was removed from the ecosystem years ago. unordered-containers is the much faster relacement
20:19:11 <haxx0r> i delete unix sorry
20:19:15 <synergistics> First thing I saw was from a 7 year old reddit post and then trying to find the package for hash*tables* led only to obscurity. Guess that's why
20:19:17 <haxx0r> becase bnc off
20:19:29 <haxx0r> now vidalia
20:19:31 --- mode: ChanServ set +o geekosaur
20:19:36 --- mode: geekosaur set +b *!*6dfc4822@*.109.252.72.34
20:19:36 --- kick: haxx0r was kicked by geekosaur (haxx0r)
20:19:46 <Axman6> what weird spam
20:19:47 <geekosaur> ban's probably pointless
20:20:11 <michaelt> the hash table that was kicked out of base was a regular mutable hash table implementation https://hackage.haskell.org/package/base-4.2.0.2/docs/Data-HashTable.html
20:20:23 <Axman6> ew :(
20:20:27 <synergistics> right, that's what I had been looking at
20:20:33 <synergistics> Good to know
20:20:49 <synergistics> plus I didn't want to have to deal with all that IO
20:20:52 <geekosaur> yeh, it was straight up removed although it then showed up on hackage for backward compatibility for the few packages that used it
20:21:30 <synergistics> Ah
20:21:32 <michaelt> synergistics: the hashtables library has mutable hashtables but it just isnt faster 
20:21:51 --- mode: geekosaur set -o geekosaur
20:23:37 <michaelt> synergistics: It must be much faster than the old 'Data.Hashtable' though. 
20:25:04 <synergistics> HashMap is what I really need it seems
20:25:11 <michaelt> synergistics: but unordered-containers is the way to go
20:25:56 <synergistics> Alright thanks
20:27:20 <carter> Unless it's a bad hash function :)
20:29:42 <synergistics> I might even be able to get away with two vectors since the hash function I would use would really just be the next value in a counter
21:28:16 * hackagebot irc-core 2.1.0.0 - IRC core library for glirc  https://hackage.haskell.org/package/irc-core-2.1.0.0 (EricMertens)
21:28:18 * hackagebot mongoDB 2.1.1 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  https://hackage.haskell.org/package/mongoDB-2.1.1 (VictorDenisov)
21:34:35 <ReinH> synergistics: why do you want a HashMap instead of a plain old Data.Map?
21:35:12 <ReinH> what sort of asymptotics do you want?
21:35:57 <ReinH> oh that's from a while ago, never mind
21:46:02 <angerman> can I have an instance derived, while providing my own implementation for one or two special cases? (data X = X | Y | Z deriving (Show, Ord, Eq); instance Eq X where Z == Z = False)?
21:47:17 <geekosaur> no, or not currently at least
21:47:49 <geekosaur> there's some talk of redesigning the derivation stuff in a way that would allow something like that to be added in the future (but it's not part of the main proposal)
21:50:22 <Axman6> it'd be good to be able to write deriving instance Eq X where Z == Z = False and have everything else filled in automatically... but I think extra annotation would be needed, in case you actually might want a partial imeplementation
21:51:08 <angerman> geekosaur hmm too bad for me. But I think that would be a nice option to have. (E.g. derive everything I didn't specify. Even thought hat could get a little complicated at the edges I assume.)
21:51:43 <geekosaur> more than a little, plus simply not possible as things currently stand; it's all or nothing and there's no way to hook into the current implementation to change it
21:52:13 <geekosaur> (and it would not take much for such a hook to lead to it generating illegal instances; there
21:52:40 <geekosaur> ;ve already been a number of bugs where obscure deriving corner cases led to it deriving unsafeCoerce)
21:54:03 <c_wraith> you didn't even need obscure cases with GADTs and GND
21:56:06 <ReinH> As a last resort, you can have GHC print out the derived code
21:56:07 <ReinH> and edit it
21:56:17 <angerman> Hm. The other option is to break your data up into stuff that can be derived and stuff you want to hand derive, and have that wrapped. Somewhat ugly though :(
21:58:07 <angerman> E.g. data X1 = X | Y deriving Eq, data X2 = Z, instance Eq X2 where Z == Z = False, data X = X1 X1 | X2 X2 deriving Eq. Now I would just need to hide that sum somehow.
21:58:15 <angerman> ReinH: true.
21:58:18 <angerman> Maybe I should have done that.
21:58:33 <geekosaur> with a bit of work that could even be somewhat automated
22:01:17 <angerman> not sure how easily that would break though.
23:11:33 <Narfinger> hiho, I am looking for a function (a -> b) -> [Maybe a] -> [b], I know that maybe can be seen as a monad but I hoogle doesn't help finding something (a->b) -> [m a] -> [b] for me
23:13:37 <kadoban> :t \f -> catMaybes . map (fmap f)
23:13:38 <lambdabot> (a1 -> a) -> [Maybe a1] -> [a]
23:13:52 <glguy> mapMaybe ^
23:14:11 <epicallanl> exit
23:14:53 <Narfinger> thanks
23:14:59 <kadoban> Narfinger: It doesn't really make sense as a generic Monad function, unless I'm missing something. It has to be specific to Maybe.
23:15:15 <Narfinger> mhhh ok I thought I saw something like that but perhaps I am mistaken
23:16:01 <glguy> The only function of that type that would work for arbitrary Monad instances rather than Maybe would be \_ _ -> []
23:16:25 <glguy> modulo various bottoms
23:17:43 <baordog> Will I be offtopic for asking xmonad questions in here? xmonad room seems a little dead right now.
23:19:09 <dmwit> :t \f -> map f . catMaybes
23:19:10 <lambdabot> (a -> b) -> [Maybe a] -> [b]
23:19:38 <baordog> Can't tell if that was unrelated or you making a joke :P
23:19:55 <dmwit> It is related to Narfinger's question from before you joined.
23:20:22 <baordog> ah ok. I think I may have inadvertantly hurt xmonad by installing something with cabal. A script that compiled before no longer does 
23:20:37 <glguy> :t mapMaybe . fmap
23:20:39 <lambdabot> (a -> b) -> [Maybe a] -> [b]
23:20:43 <Narfinger> yeah well the cat and then map is the obvious thing
23:20:57 <dmwit> I'm all in favor of doing the obvious thing.
23:21:02 <dmwit> Less surprises is better.
23:21:06 <dmwit> (Fewer?)
23:21:13 <dmwit> Fewer surprises are better.
23:21:21 <glguy> smaller?
23:22:31 <dmwit> No, I don't think fewer surprises are smaller. ;-)
23:23:03 <glguy> that's surprising
23:23:29 <dmwit> law of conservation of surprise mass
