00:01:07 <ertes> FRP and stuff like rendering or even graphics are completely orthogonal
00:01:57 <ertes> FRP is about interaction design, and whenever you have a program of interacting things, FRP can help, if even in the most trivial manner
00:02:13 <ertes> whenever you write "main loops" or "callbacks", consider using FRP instead
00:02:44 <ertes> and in fact which one of those two you use even helps you decide which library
00:02:58 <ertes> main loops?  use reflex…  callbacks?  use reactive-banana
00:03:11 <gestone> MarLinn: thanks, i don't think i would have gotten this far without this irc though. someone here suggested me to buy haskellbook (which was a fantastic investment) and i read through most of it
00:03:23 <ertes> joe9: ^
00:04:15 <gestone> anyways, i'll be off now, i'll probably be back to ask questions
00:09:02 <cocreature> is it safe to pass a Ptr via the FFI to a function accepting a C reference?
00:10:05 <lispy> What is a C reference?
00:10:44 <cocreature> lispy: "int f (int& x)" x is a reference
00:11:28 <lispy> okay, that's not C though
00:11:37 <cocreature> eh right
00:11:40 <cocreature> I always forget that
00:12:14 <lispy> I can only speculate, but I would imagine that as long as the Ptr is non null you'll be okay
00:12:42 <cocreature> I need to wrap the c++ api anyway, so it’s less important :)
00:12:47 <cocreature> I’ll just accept pointers
01:15:07 <athan> combinator combinators
01:33:05 <Xnuk> I have many `StateT s IO [Text]` and each `s` are different. And I think I should combine the `StateT`s into one `StateT` like: if case x, run `y :: StateT s IO [Text]` with previous state.
01:33:17 <Xnuk> How do I manipulate the states?
01:40:00 <lyxia> Xnuk: can you give an example?
01:40:15 <lyxia> or an excerpt of your code
01:41:59 <lyxia> How do you want to "run with previous state" if the states of your actions have different types?
01:43:00 <Xnuk> um I mean, `y`'s previous state
01:46:40 <lyxia> Xnuk: maybe you can make a big record state containing substates used by the functions you mentionned.
01:47:53 <lyxia> You can then use zoom from lens to do the conversion.
01:49:48 <Marcel_> Hey I'm making a simple programming language to try and learn some Haskell. I have it working for a single type Int, but I want to try and generalise it to include Bool as well. How do I go about defining a data object that can be more than a one type. I have tried data Val = Int Int | Bool Bool
01:50:44 <Prutheus> hello. I wanna grab the site via a curl request. I am using Network.Curl ... wanna use curlGetString, but i need to set parameters, mainly headers. how to specify them for this call?
01:51:51 <Prutheus> you know what i mean or should i explain more detailed/in a better way?
01:53:50 <srhb> Marcel_: That looks like a valid type to me (without calling it an object, at least)
01:54:35 <srhb> Prutheus: Look at how CurlOption is defined. It has a CurlHttpHeaders constructor.
01:56:46 <Prutheus> oh yeah i watched at this list already, didnt find it, but now i found it. sry and ty anyway ^^
02:02:31 <Prutheus> srhb: I hvent used haskell since a long time, i wasnt an expert so i forgot how to set the variables in []. can you tell me please how to set a CurlCookie for example in []. was it [CurlCookie="string"] ?
02:03:21 * hackagebot flaccuraterip 0.3.6 - Verify FLAC files ripped form CD using AccurateRip"  https://hackage.haskell.org/package/flaccuraterip-0.3.6 (NicolaSquartini)
02:05:31 <Prutheus> no it was [CurlHttpHeaders [str,str,str], nextstuff] right?
02:06:01 <srhb> Prutheus: Yes, it's just a list of CurlOption, and CurlHttpHeaders [...] is one such value
02:06:20 <Prutheus> yeah. man, half a year not using haskell really fucks your brain haha
02:08:13 <Prutheus> srhb, but how to set something what requires a bool?
02:08:21 <Prutheus> is it with = or how is the syntax? ^^
02:08:34 <srhb> Prutheus: You're not "setting" anything, you're just passing values.
02:09:10 <Prutheus> but i need to do it like: SomeVar bool equals in code then: [SomeVar True] ?
02:09:48 <srhb> Prutheus: If you're asking how to create a CurlOption value using say, the CurlVerbose Bool constructor, then it would simply be CurlVerbose True (or CurlVerbose False)
02:10:22 <Prutheus> okay. man, i forgot the syntax of haskell #shit
02:10:58 <srhb> Prutheus: I think you may be mixing up record syntax with list syntax.
02:11:02 <srhb> A list just looks like...
02:11:06 <srhb> > [1,2,3]
02:11:08 <lambdabot>  [1,2,3]
02:11:12 <Prutheus> yeah
02:11:19 <Prutheus> i am mixing up, right ^^
02:52:58 <Prutheus> Hello! It is me again
02:53:35 <Prutheus> just one simple question: for my curl request i need a cookie. this cookie is killed after 10 minutes. so I need to login first via curl to get the cookie to get the other information then.
02:54:07 <Prutheus> my question: Is it posssible to make a post "login" with curl and get the responded data, e.g. the cookie, then? if so, how? (in haskkel ofc)
02:59:27 <srhb> Prutheus: I think you would gain more by just using something with actual session support rather than the curl wrapper
03:01:03 <piyush-kurur> looks like ghc has slowed down a lot since 7.6. The travis builds of raaz seems to suggest a big (3x) slowdown from 7.6 to 7.10
03:11:08 <Prutheus> srhb: and what would this be for example?
03:12:52 <srhb> Prutheus: http-client for instance.
03:15:33 <int-e> piyush-kurur: yes, and memory usage has gone up significantly too
03:21:59 <piyush-kurur> int-e: and raaz does not use any template haskell. wonder how the yesod guys are managing
03:38:18 <Prutheus> srhb: i tryed with curl, works fine. curlPost returns the cookie which i can use then. but how to put the returned data into a variable to operate with it, because its returntype is IO ?
03:39:04 <blueonyx> there is no escape from IO, resistance is futile
03:40:06 <Prutheus> what do you mean in easy words? ^^
03:40:18 <blueonyx> try something like "variable <- getCookieFromYour $ curlPost"
03:40:43 <blueonyx> easy and mean words are read up on monads :>
03:41:10 <blueonyx> can you paste something how you get the cookie from curl?
03:41:46 <Prutheus> wait a moment pls... and yeah, i bought a haskell book, but when it got close to monads i stopped reading .. maybe i should continue
03:43:45 <blueonyx> as far as i can see with the curlPost function you can't get the resulting cookie
03:45:22 <blueonyx> Prutheus: you are using this lib i presume? http://hackage.haskell.org/package/curl-1.3.8
03:45:40 <Prutheus> blueonyx: i can, because i use curlPost :: URLString -> [String] -> IO ()   >  so and when i write this with all necessary values in ghci, it outputs me the website code incl. header where the cookie is in
03:46:04 <srhb> But curlPost prints the output directly, you have no way to get at it.
03:47:00 <Prutheus> srhb: and that is the problem? can i bypass this *shit* somehow?
03:48:13 <blueonyx> Prutheus: use a function which returns the response somehow, with type ending in IO SomeData instead of IO ()
03:49:50 <srhb> There is no such function in the library, you'd have to duplicate curlPost and alter it to actually give you the response body.
03:49:57 <srhb> (Or you could use a library more suited to the task)
03:50:24 <Prutheus> srhb: nono i like curl ^^ so i need to partly rewrite this function or what?
03:50:30 <srhb> Prutheus: Yep.
03:50:45 <Prutheus> okay then i do this haha
03:51:07 <blueonyx> why use a haskell binding for libcurl when there are better suited native haskell libraries
03:51:31 <srhb> Prutheus: If you look at its source code you'll se that it has return () at the end. Instead you'll need to fetch the actual response body and make that the return value instead.
03:51:56 <Prutheus> i understand, yes
03:52:18 <Prutheus> whatever, im doing lunch now, cu later
03:54:09 <blueonyx> oh the source looks surprisingly easy
03:56:57 <blueonyx> Prutheus: getInfo h CookieList instead of return () should do the trick
04:03:24 * hackagebot verbosity 0.2.3.0 - Simple enum that encodes application verbosity.  https://hackage.haskell.org/package/verbosity-0.2.3.0 (PeterTrsko)
04:31:08 <Prutheus> i am back
04:31:23 <Prutheus> blueonyx: but how to get IO InfoValue to a string?
04:32:13 <blueonyx> show
04:32:21 <Prutheus> wait
04:32:33 <blueonyx> but i tried it myself, you will have to parse this string then and split on \t chars :/
04:32:40 <Prutheus> oh ok
04:32:55 <Prutheus> hm
04:33:05 <Prutheus> but what type signature does the new function have then?
04:33:31 <blueonyx> myCurlPost :: URLString -> [String] -> IO InfoValue
04:34:02 <blueonyx> infoVal <- myCurlPost ...
04:34:06 <Prutheus> oh sry i had it already but had a syntax error that is why i got errors xD
04:34:55 <Prutheus> and how to do from InfoValue to String?
04:35:09 <Prutheus> ahh
04:35:12 <Prutheus> it can use show
04:35:12 <Prutheus> nice
04:37:17 <alanz> Any Turtle experts here? I have a silly problem with rmtree. See http://lpaste.net/6760081049897664512
04:46:35 <Prutheus> haha blueonyx 
04:47:15 <Prutheus> when i do putStrLn $ show loginRes i can read the cookie
04:47:24 <Prutheus> but I can't just filter this line out
04:47:53 <blueonyx> :t show loginRes
04:47:54 <lambdabot> error: Variable not in scope: loginRes :: ()
04:48:14 <blueonyx> this gives you a list of cookie strings
04:48:34 <blueonyx> there you have to find the right string and then filter this string for the part of the infos you need :/
04:49:03 <blueonyx> Prutheus: you know about :t?
04:57:00 <Prutheus> ahh okay.
05:02:48 <lingxiao> i need to lift a list in to an io monad so that in some IO () i can do     foo <- foos
05:03:00 <lingxiao> lift doesn't seem to work ..
05:03:06 <srhb> alanz: Does ./test exist?
05:03:26 * hackagebot yesod-core 1.4.23.1 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.23.1 (MichaelSnoyman)
05:03:27 <alanz> yes, constructed as per the comment in the paste
05:03:28 * hackagebot conduit-combinators 1.0.5 - Commonly used conduit functions, for both chunked and unchunked data  https://hackage.haskell.org/package/conduit-combinators-1.0.5 (MichaelSnoyman)
05:03:35 <Prutheus> got it, ty
05:03:57 <alanz> And at the end of it the .stack-work dir is gone, but the exception shows up
05:05:37 <alanz> srhb, I am beginning to think rmdir may be the culprit
05:05:52 <srhb> alanz: Like, the ordering of rmtree messing it up?
05:06:08 <alanz> I have a trace of the rm/rmdir calls made
05:07:14 <alanz> srhb, I just updated the paste
05:07:49 <alanz> where I renamed rm/rmdir to print their args first
05:08:26 * hackagebot http-client 0.5.2 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.5.2 (MichaelSnoyman)
05:08:28 * hackagebot http-conduit 2.2.0.1 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.2.0.1 (MichaelSnoyman)
05:09:48 <cocreature> alanz: I think "find" is the problem
05:10:11 <alanz> But it lists the dirs I expect?
05:10:31 <alanz> i.e there should be only one. Unless I need a trailing "/"?
05:10:41 <cocreature> alanz: it yielsd the directory, then you delete it but then it tries to recursively search inside of that directory even though it is now gone
05:11:12 <cocreature> *yields
05:11:16 <alanz> it yields a single FilePath, which a pass to rmtree?
05:11:56 <alanz> ok, gotcha, an interleaved execution. I need to kill the pipeline, do the one fully then the other
05:12:01 <cocreature> exactly
05:12:07 <cocreature> at least that seems very likely
05:12:34 <alanz> It makes sense. A lot of effort has gone into making it work in a fully pipelined way
05:12:52 <alanz> Which breaks it for me.
05:13:04 <cocreature> you sort of want a find that allows you to return a DontRecurse option in your action
05:13:08 <alanz> So I must loop out to return the dirs, then delete those
05:13:20 <lingxiao> hey guys any idea how i can lift a list into IO   so that in some foo :: IO () i can do
05:13:22 <lingxiao> x <- xs
05:13:39 <alanz> no, it must recurse, but I need to do something like view at the end to get just a list of paths, which I then forM_ over
05:13:41 <lingxiao> or do i have to use listT
05:14:09 <blueonyx> lingxiao: what about 'return foo' ?
05:14:14 <cocreature> alanz: it can’t recurse inside a directory that’s deleted
05:14:30 <lingxiao> oh i was hoping to draw elements out of the list
05:14:38 <blueonyx> yea im dumb
05:14:52 <lingxiao> haha it's ok i tried it too
05:15:22 <alanz> cocreature, exactly. So I first do the find, and view its result to yield [FilePath]
05:15:27 <alanz> Then I delete those
05:15:43 <alanz> They are not nested, I know that
05:15:51 <cocreature> ah yeah if you know that then that’s fine
05:15:56 <alanz> from the application
05:16:46 <cocreature> you can just use "fold Fold.list" iirc to get what you want
05:17:13 <alanz> ok, will give it a go. My first attempt at using Turtle in anger.
05:17:23 <blueonyx> lingxiao: in your IO you can do let bar = do foo <- foos... or not?
05:17:27 <alanz> The Shell type threw me, until I actually read the tutorial
05:17:45 <lingxiao> blueonyx no
05:17:55 <lingxiao> for example in ghci if you do    x <- [1..4]
05:18:06 <lingxiao> you get couldnt match expected type IO t with actual type [Integer]
05:18:27 <blueonyx> yea but ghci is weird
05:18:51 <cocreature> lingxiao: note that if you want ListT you probably don’t want the one from transformers/mtl (forgot where it is) as it does not lazily yield results
05:18:59 <blueonyx> lingxiao: but what i meant works in ghci: let foos = do x <- [1..4]; return x
05:19:51 <lingxiao> yeah :t foos   (enumb, num b) => [b]
05:19:59 <lingxiao> i think im looking for listT IO _
05:20:13 <lingxiao> cocreature you mean *not* this: https://hackage.haskell.org/package/transformers-0.5.2.0/docs/Control-Monad-Trans-List.html
05:20:13 <lingxiao> ?
05:20:36 <MarLinn> lingxiao: or you're simply looking for "let list = [1,2,3]"...
05:20:39 <lingxiao> my list is short ... 10 - 50 item range 
05:20:54 <cocreature> lingxiao: exactly
05:21:05 <lingxiao> so where from then?
05:21:39 <cocreature> lingxiao: pipes is quite nice for that https://hackage.haskell.org/package/pipes-4.2.0/docs/Pipes-Tutorial.html#g:6 but it requires a bit of reading to figure out how to use it (but learning pipes is totally worth it)
05:23:26 <lingxiao> uh im using conduits as is actually
05:23:32 <lingxiao> but yeah i guess i can do the same thing in conduits
05:23:46 <cocreature> yeah I’m sure you can (never really used conduit)
05:24:01 <lingxiao> the thing is im already streaming a list of files though
05:24:09 <lingxiao> so im not sure hwo this woudl work ... would i need two sources ?
05:25:27 <et09_> is my understanding of FRP correct, you basically model application state as a recursive function?
05:25:37 <et09_> responding to IO?
05:28:03 <srhb> et09_: I don't see how that relates to FRP at all.
05:28:13 <et09_> i don't understand FRP so that's my question
05:28:23 <MarLinn> et09_: FRP basically means you model behaviour as a function from time to values
05:29:53 <et09_> it's no longer "FRP" when you're talking about including user inputs and stuff?
05:30:03 <MarLinn> et09_: you can interpret the values as state, but you can also interpret them as past or future state, or state of an alternate universe if you wand
05:31:00 <et09_> i'm really trying to figure out like, how you would structure an opengl game in haskell (or an elm web app for that matter)
05:31:09 <MarLinn> "User input and stuff" can be values that are handled by an FRP framework
05:31:46 <et09_> so my understanding was that you're basically declaring iterations of state as sequentially modified by whatever
05:32:04 <MarLinn> An alternative point of view is that FRP is a data flow language embedded into the base language
05:33:08 <MarLinn> You can do that, for example by modelling "event streams" as a list of updates
05:33:49 <MarLinn> But the more elegant way is to actually use functions that you can later sample with an actual time value
05:34:20 <et09_> you mean to say, 3 seconds have elapsed, dx and dy are 5 and 20 ?
05:34:56 <et09_> (whoa, someone wrapped Bullet for haskell, i just noticed)
05:36:20 <MarLinn> well... that's not enough context to answer with yes or no
05:36:44 <MarLinn> So you have a point on a plane that might move
05:37:31 <et09_> just hypothetically
05:38:41 <MarLinn> Option 1: you have continuous behaviour. You sample the stream, say every 1/60 seconds, and check the point positions. In that sense a result like yours might come up
05:40:08 <MarLinn> Option 2: You model behaviour as a stream of events. After 3 seconds the backend pushes a new event into the stream because the point has moved. Time and values all fall out of the stream at the same time.
05:41:12 <et09_> i see 
05:41:47 <et09_> certainly a different mode of thinking than OOP game structure
05:41:59 <MarLinn> Where the values come from and what happens to them is an implementation choice of the backend
05:42:36 <MarLinn> Absolutely. As I said, it might be better to think of them as a network of data flows
05:42:47 <et09_> i think it just clicked
05:43:17 <et09_> that's really stunning that it's just state handling described mathematically 
05:43:42 <et09_> so to speak
05:44:01 <MarLinn> Stunning is Haskells middle name. Haskell Stunning Curry.
05:52:06 <mmaruseacph2> @remember MarLinn Stunning is Haskells middle name. Haskell Stunning Curry.
05:52:06 <lambdabot> It is forever etched in my memory.
05:53:03 <MarLinn> mmaruseacph2, I'm flattered XD
05:57:30 <alanz> cocreature, FYI this is what I ended up with. At the end: https://github.com/alanz/HaRe/commit/8a484f5c8ffd538ab9775256f1036afe7a14cd4a
05:59:21 <cocreature> alanz: yeah that’s what I was suggesting
05:59:40 <alanz> I followed your suggestion, thanks
05:59:44 <cocreature> np
07:08:22 <suppi> is it possible to get a text list of stackage lts-6.14's packages and versions?
07:09:03 <suppi> i mean, does it exists somewhere
07:12:26 <chris2> https://www.stackage.org/lts-6.14/cabal.config
07:12:40 <chris2> used to be linked...
07:14:50 <suppi> chris2: bless you :)
07:21:44 <meinteil> If you release a game with only singleplayer as v1.0.0 and then add multiplayer but the game is still backwards compatible, would you call the version v1.1.0 or v2.0.0?
07:22:40 <saurabhnanda> hey, whenever I start a new project with stack (using the same LTS as a previous project), stack seems to start all over again. Can't stack re-use stuff that has already been downloaded and built for another project?
07:29:07 <cspin> > fmap (+1) (*3) $ 8
07:29:09 <lambdabot>  25
07:29:18 <cspin> cool
07:37:23 <{AS}> meinteil: It depends, like Chrome releases new versions all the time 
07:37:32 <{AS}> Version numbering is marketing too :)
07:39:05 <blueonyx> meinteil: semver.org suggest to still use 1. since you are not making incompatible api changes
08:17:06 <sm> meinteil: working on something for ludum dare ?
08:17:17 <defanor> i have a tree with different types of nodes, and would like to attach some state to the nodes, but just addding it into the structure makes it cumbersome to work with it when the additional state is not needed. something like traversable would be nice if there only was one node type, but there's more. so, currently using a second structure that resembles the first one (but is parametrized by state, which is always of the same type btw),
08:17:17 <defanor> but it also feels rather wrong. what are the less cumbersome ways to achieve it?
08:20:10 <defanor> though maybe i'm on a wrong path altogether. are there any standard and nice approaches to keeping track of elements of a rendered document (their resulting coordinates, for instance), while keeping it pure?
08:57:03 <chsn> is there any haskell -> go backend? (even if experimental?)
08:59:52 <thomasjoy> I have a question about persistent-postgresql, I can use `userId <- insert $ User name` to insert a new line, while how to insert with primary key already known?
09:04:53 <ramadoka> hey, if I have things like "data Node = A | B | C | D"
09:05:14 <ramadoka> what is the easiest way to convert A -> 0, B -> 1, C -> 2 etc ?
09:06:37 <defanor> ramadoka: the Enum class, it can be derived
09:07:10 <ramadoka> nice, thanks.
09:08:19 <lingxiao> hey all
09:08:25 <lingxiao> is there a way to do targeted exports?
09:08:35 <lingxiao> like I have foo.hs and I want to export all functions to fooTest.hs
09:08:38 <lingxiao> but not to bar.hs
09:08:42 <lingxiao> for examle
09:09:10 <glguy> Module have a single export list that is used by all importers of that module
09:11:44 <mniip> haha
09:11:51 <mniip> I was thinking of dataToTag#
09:12:01 <mniip> Enum sounds much simpler indeed
09:12:28 <ramadoka> as a beginner, I definitely never heard about dataToTag haha
09:13:09 <mniip> :t GHC.Prim.dataToTag# -- you don't really want to
09:13:11 <lambdabot> a -> GHC.Prim.Int#
09:13:35 <lingxiao> glguy i figured :(
09:15:12 <defanor> "#" means that magic is involved. things happen when you use those
09:16:54 <hydraz> It is, after all, the MagicHash
09:17:47 <ramadoka> weird, I got parse error instead o.O
09:17:48 <ramadoka> http://www.ramadoka.com/ss1.png
09:18:16 <hydraz> :set -XMagicHash in GHCi, {-# LANGUAGE MagicHash #-}, or -XMagicHash for the ghc
09:19:16 <hydraz> http://hydraz.vehk.de/img/131800-20160828.png there's also tagToEnum#, which I guess is toEnum but magic.
09:21:00 <ramadoka> eww, I'll reconsider it later after I deal with monad.
09:21:24 <hydraz> Just derive enum.
09:21:33 <ramadoka> yep, I did thanks.
09:22:14 <hydraz> y/e/E/
09:22:28 <ramadoka> oh, btw, is this webchat.freenode.net, the same as "irssi -c chat.freenode.net" ?
09:22:41 <glguy> Yes
09:22:43 <hydraz> Basically.
09:22:55 <ramadoka> because, I haven't been able to connect via irssi for a while.
09:28:33 * hackagebot glirc 2.11 - Console IRC client  https://hackage.haskell.org/package/glirc-2.11 (EricMertens)
09:28:35 * hackagebot irc-core 2.1.1.1 - IRC core library for glirc  https://hackage.haskell.org/package/irc-core-2.1.1.1 (EricMertens)
09:28:52 <tr|ck> hi
09:28:56 <glguy> Hello.
09:29:00 <hydraz> Aloha.
09:29:33 <black0range> Hej!
09:29:42 <hydraz> Olá.
09:30:45 <tr|ck> I've been into haskell for the last couple of months. I wrote a parser for djbdns data files and I'm trying to simplify data construction through the use of unidirectional pattern synonyms.
09:31:37 <tr|ck> the data constructor for a SOA record looks like this:                | SOA   { djbTag :: String, tld :: String, nsName :: String
09:31:39 <tr|ck>                        , adminName :: String, serial :: String, ttl :: String
09:31:42 <tr|ck>                        , nsTtl :: String, refrTtl :: String, authTime :: String, negResTtl :: String, other3 :: String }
09:32:02 <tr|ck> well, correctly indented, not actually like this. (:
09:32:28 <tr|ck> I put all string types for initial simplification
09:32:48 <ramadoka> uhum test
09:33:01 <glguy> tr|ck: If you have code to share you can put it on http://lpaste.net
09:33:14 <tr|ck> glguy: thanks
09:33:28 <hydraz> ramadoka: o/
09:33:38 <hydraz> If you're testing irssi, it's definitely working
09:34:11 <ggole> tr|ck: I don't think this is the answer to your question, but you can save typing with x, y :: String instead of x :: String, y :: String
09:34:13 <glguy> Next you could test glirc as linked above ;-)
09:36:42 <hydraz> The version of glirc in nixpkgs is still 2.2 D:
09:37:03 <xuxu> :t forM_
09:37:05 <lambdabot> (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
09:37:05 <glguy> hydraz: I'd recommend 2.11 over 2.2
09:37:21 <hydraz> Now it's .10.
09:37:24 <lpaste> xuxu pasted “code related to question” at http://lpaste.net/181081
09:37:35 <glguy> hydraz: Well, I only just uploaded .11, so that's understandable :)
09:37:40 <xuxu> i came across this code when searching for examples of how to use forM
09:37:43 <hydraz> glguy: Yeah
09:38:00 <hydraz> xuxu: forM is flipped mapM
09:38:10 <xuxu> i would have never thought to use $ and a lambda function
09:38:24 <xuxu> hydraz: yeah people say that as if I know what that is :)
09:38:29 <xuxu> i haven't used mapM yet
09:38:56 <lpaste> “tr|ck” pasted “djbParsec.hs” at http://lpaste.net/181083
09:38:59 <xuxu> i was thinking you'd use forM like: forM [1..10] namedFunction
09:39:06 <xuxu> :t ($)
09:39:07 <lambdabot> (a -> b) -> a -> b
09:39:09 <hydraz> That works too
09:39:39 <xuxu> that doesn't seem to fit (a -> m b)
09:39:48 <glguy> hydraz: Current view of the channel if you're interested: http://imgur.com/a/zoBMW
09:40:02 <lpaste> “tr|ck” revised “djbParsec.hs”: “djbParsec.hs” at http://lpaste.net/181083
09:40:10 <hydraz> glguy: Oh, I will run it
09:40:19 <xuxu> :t do
09:40:21 <lambdabot> error: Empty 'do' block
09:40:24 <hydraz> it's just that there's a bunch of updates in the queue
09:40:43 <glguy> xuxu: do isn't a value, it's part of the syntax of Haskell
09:40:52 <xuxu> a keyword
09:40:57 <hydraz> Yeah.
09:41:49 <xuxu> i can see how do returns a monad
09:42:08 <cloudhead> :t (>>=)
09:42:09 <xuxu> though for some reason i'm a little shocked there isn't some way to get type information 
09:42:09 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:42:12 <xuxu> ah, right
09:42:20 <hydraz> do doesn't return anything - it's syntactic sugar for chains of (>>=)
09:42:23 <tr|ck> ggole: thanks, I'm exploring lpaste.net. brb asa I have the code organized to re-ask the question (:
09:43:15 <cloudhead> xuxu: it would be like getting type information of `let`
09:43:49 <xuxu> cloudhead: is let syntactic sugar as well?
09:43:58 <cloudhead> it's part of the core syntax
09:44:07 <hydraz> I think let is an actual construct rather then sugar, but it could be sugar for lambdas
09:44:22 <hydraz> i.e. let x = e in x becomes (\x. x) e
09:44:37 <mauke> that doesn't work because of recursion and polymorphism
09:44:38 <xuxu> is there a path on figuring out that i could use $ and do syntatx together?
09:44:48 <glguy> It's not sugar, it's just syntax
09:44:55 <hydraz> mauke: then it couldn't be sugar for lambdas :P
09:45:08 <xuxu> how does do and $ translate to the type signature of forM
09:45:12 <hydraz> But I know some lisps do it like that
09:45:55 <mauke> > let xs = 0 : xs in xs
09:45:58 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:46:28 <cloudhead> xuxu: forget about $ for a second: forM [1..10) (\x -> return x)
09:46:38 <reqq456> can someone tell me how I could print this or can convert this to a basic datatype?
09:46:41 <reqq456> http://sprunge.us/eIKK
09:46:44 <hydraz> I know about let recursion >.<
09:46:52 <cloudhead> > forM [1..10] (\x -> return x)
09:46:54 <lambdabot>  error:
09:46:54 <lambdabot>      • Ambiguous type variables ‘m0’, ‘b0’ arising from a use of ‘show_M46861...
09:46:54 <lambdabot>        prevents the constraint ‘(Show (m0 [b0]))’ from being solved.
09:47:05 <cloudhead> meh
09:47:11 <hydraz> > forM [1..10] (\x -> return x) :: Identity [Int]
09:47:14 <lambdabot>  Identity [1,2,3,4,5,6,7,8,9,10]
09:47:18 <cloudhead> ty
09:47:22 <hydraz> np
09:47:26 <glguy> reqq456: someFunc = do exists <- todoListDirectoryExists; print exists
09:47:34 <xuxu> cloudhead: that was actually the only thing i was able to generate myself
09:47:42 <xuxu> i looked up the type signature of forM
09:47:44 <xuxu> and found return
09:47:51 <xuxu> > forM [1..10] return
09:47:54 <lambdabot>  error:
09:47:54 <lambdabot>      • Ambiguous type variables ‘m0’, ‘b0’ arising from a use of ‘show_M49818...
09:47:54 <lambdabot>        prevents the constraint ‘(Show (m0 [b0]))’ from being solved.
09:47:54 <reqq456> thx glguy 
09:47:55 <black0range> reqq456: or todoListDirectory >>= print 
09:48:08 <hydraz> > forM [1..10] return :: Identity [Int]
09:48:10 <lambdabot>  Identity [1,2,3,4,5,6,7,8,9,10]
09:48:43 <xuxu> nevermind, i used that with mapM (because i came across that saying forM is just mapM with its args reversed and tinkered with it)
09:48:57 <xuxu> > mapM return [1,2,3]
09:48:59 <lambdabot>  error:
09:48:59 <lambdabot>      • Ambiguous type variables ‘m0’, ‘b0’ arising from a use of ‘show_M54014...
09:48:59 <lambdabot>        prevents the constraint ‘(Show (m0 [b0]))’ from being solved.
09:49:00 <cloudhead> xuxu: $ is just function application, but it has its own precedence, so it allows you to omit the () in the example above
09:49:10 <hydraz> > mapM return [1,2,3] :: Identity Int
09:49:12 <lambdabot>  error:
09:49:12 <lambdabot>      • Couldn't match type ‘[Integer]’ with ‘Int’
09:49:12 <lambdabot>        Expected type: Identity Int
09:49:18 <hydraz> damn it
09:49:21 <xuxu> anyway, none of what i just said is remotely important, i'll look at what you all have to say and try to learn
09:49:37 <hydraz> forgot my brackets
09:50:26 <cloudhead> xuxu: forM [] (\x -> return x)    ==    forM [] $ \x -> return x     == forM [] return
09:50:33 <cloudhead> they are equivalent
09:50:33 <lpaste> “tr|ck” revised “djbParsec.hs”: “djbParsec.hs” at http://lpaste.net/181083
09:51:19 <hydraz> Transforming `\x -> f x` to just `f` is η-reduction, right?
09:51:39 <black0range> yup
09:51:53 <johnw> points for the Unicode even :)
09:52:03 <cloudhead> eta-conversion, yeah
09:52:13 <cloudhead> um reduction
09:52:18 <glguy> geekosaur: Regarding my question last night and your reply: https://github.com/coreyoconnor/vty/issues/104 (tl;dr it's fixed)
09:52:42 <lpaste> “tr|ck” revised “djbParsec.hs”: “djbParsec.hs” at http://lpaste.net/181083
09:53:01 <cloudhead> xuxu: and likewise,    forM [] (\x -> do { return x })   is also the same as the above
09:53:33 <int-index> Why doesn't this typecheck? http://lpaste.net/181094
09:53:34 * hackagebot vty 5.8.1 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.8.1 (JonathanDaugherty)
09:53:56 <int-index> I'm getting an error that says "Illegal type synonym family application"
09:54:03 <lpaste> “tr|ck” revised “djbParsec.hs”: “djbParsec.hs” at http://lpaste.net/181083
09:54:29 <xuxu> cloudhead: that makes sense, i could see how that's an a -> m a
09:55:07 <xuxu> oh, it needs to be (a -> m b), but i could see how you can get there with that. i didn't know you could put do statements inside of a lambda 
09:55:42 <hydraz> I'm pretty sure you can put a do-expression anywhere an expression is valid.
09:56:14 <hydraz> Though you'll have to use (do { ... }) or faff around with things to make the layout happy
09:57:30 <saurabhnanda> can anyone help me with String -> Bytestring nonsense. Which ByteString does https://www.stackage.org/haddock/lts-6.3/persistent-postgresql-2.2.2/Database-Persist-Postgresql.html#t:ConnectionString need and how to I convert String to it?
09:57:57 <xuxu> cloudhead: how does the ($) in forM [] $ \x -> return x fit with the forM type sig?
09:57:58 <lpaste> “tr|ck” revised “djbParsec.hs”: “djbParsec.hs” at http://lpaste.net/181083
09:58:00 <black0range> saurabhnanda: There is a "pack" function in Data.ByteString
09:58:10 <hydraz> xuxu: f $ x = f x
09:58:11 <saurabhnanda> black0range: not working
09:58:16 <black0range> wut
09:58:26 <hydraz> saurabhnanda: Lazy vs Strict bytestring?
09:58:46 <black0range> saurabhnanda: oh you need Data.ByteString.Char8 
09:58:46 <srhb> saurabhnanda: What's the actual error and code?
09:58:58 <monochrom> Of all people in the whole world, programmers are the ones supposed to know best that "not working" is uninformative.
09:58:59 <glguy> int-index: Perhaps GADT's lifted via Data Kinds aren't yet compatible with type families? (Just looking at this simplified case type family Bt (i :: Fin ('S a)) :: * where Bt FZ = () )
09:59:01 <saurabhnanda>    289  64 error           Couldn't match type ‘Char’ with ‘GHC.Word.Word8’ // Expected type: [GHC.Word.Word8] // Actual type: [Char]
09:59:03 <srhb> saurabhnanda: Also, it might be simpler to simply acquire the connection string as a bytestring to start with. :)
09:59:08 <black0range> saurabhnanda: the pack in the default Data.ByteString is [Word8] -> ByteString
09:59:09 <xuxu> hydraz: that's useful, thanks
09:59:24 <saurabhnanda> why is this needlessly complicated
09:59:29 <lpaste> “tr|ck” revised “djbParsec.hs”: “djbParsec.hs” at http://lpaste.net/181083
09:59:37 <srhb> saurabhnanda: Type safety, mostly.
09:59:41 <saurabhnanda> this sheer stupidness should be the FIRST priority for the powers that be.
09:59:44 <hydraz> The difference between $ and regular function application is just precedence and associativity
09:59:55 <cloudhead> xuxu: since `a` can be `m a`
09:59:59 <cloudhead> :t id
10:00:00 <lambdabot> a -> a
10:00:05 <cloudhead> :t return
10:00:06 <black0range> saurabhnanda: Chars are represented isn't Word8 and ByteStrings are arrays of Word8 :)
10:00:07 <lambdabot> Monad m => a -> m a
10:00:09 <saurabhnanda> black0range: srhb: hydraz: which function should I be using? Data.ByteString.pack is not typechecking
10:00:19 <srhb> saurabhnanda: black0range already told you
10:00:19 <cloudhead> :t id (return ())
10:00:21 <lambdabot> Monad m => m ()
10:00:21 <black0range> saurabhnanda: Import Data.ByteString.Char8
10:00:46 <int-index> glguy, your simplified case compiles
10:01:03 <saurabhnanda> black0range: and?
10:01:13 <black0range> saurabhnanda: It has  a pack function too :)
10:01:16 <glguy> int-index: So it does... I must have misattributed the error when I loaded that
10:01:24 <srhb> saurabhnanda: There's also a tool called Hoogle that you might like for this purpose:
10:01:28 <srhb> @hoogle String -> ByteString
10:01:29 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
10:01:29 <lambdabot> Data.ByteString.Lazy.UTF8 fromString :: String -> ByteString
10:01:29 <lambdabot> Data.ByteString.UTF8 fromString :: String -> ByteString
10:01:36 <cloudhead> as long as `id` doesn't look at what `a` is, it could be an `m ()`
10:01:42 <xuxu> thanks cloudhead for that last one, i was staring at the type sig for forM_ and trying to understand how it arrives at m ()
10:02:15 <saurabhnanda> beats me why people aren't crying bloody murder about this.
10:02:24 <saurabhnanda> most. stupid. thing. EVER.
10:02:24 <lpaste> “tr|ck” revised “djbParsec.hs”: “djbParsec.hs” at http://lpaste.net/181083
10:02:34 <cloudhead> xuxu: `a` is more general than `m x` basically
10:02:45 <monochrom> I am not murderous.
10:02:47 <saurabhnanda> thanks. it compiles. And deep breathing helped :)
10:02:56 <glguy> int-index: OK, so it seems like it requires that that Fin is indexed by a type family application : type family Bt x xs (i :: Fin (Len (x ': xs))) :: * where Bt x xs FZ = ()
10:02:58 <hydraz> saurabhnanda: What, [Char] vs. Strict Text vs. Lazy text vs. ByteString vs. ByteString vs. Char8 Bytestring?
10:03:04 <hydraz> [Char] strings are stupid
10:03:08 <saurabhnanda> hydraz: the entire string situation.
10:03:23 <hydraz> Yes, dealing with strings is mildly annoying
10:03:25 <srhb> Text and ByteString are both completely reasonable (for different things)
10:03:27 <saurabhnanda> hydraz: why does the connectionstring have to be a bytestring in the first place?
10:03:33 <srhb> So the problem really isn't worsened that much by String.
10:03:35 <hydraz> ¯\_(ツ)_/¯
10:03:40 <srhb> saurabhnanda: That's what libpq uses.
10:03:44 <saurabhnanda> hydraz: what particular performance can one drive out of a DB connection string.
10:03:45 <hydraz> Probably performance?
10:03:48 <srhb> saurabhnanda: As in, the C interface.
10:03:52 <hydraz> Well, good point :P
10:04:09 <saurabhnanda> srhb: what's the point of higher level bindings if they can't give a more programmer friendly interface?
10:04:18 <cloudhead> xuxu: forM [] (\x -> x)     -- this works, even though it seems like 'x' can't be an `m a`
10:04:29 <int-index> glguy, looking at -ddump-tc-trace, GHC tries to check that 'At' is a valid TyCon, which doesn't make sense to me (yet)
10:04:34 <srhb> saurabhnanda: There's nothing particularly programmer unfriendly about having to either produce a connection string as a ByteString or using one simple function to convert another Stringly thing to it. :)
10:04:39 <srhb> saurabhnanda: At least, I don't think so.
10:04:47 <black0range> saurabhnanda: Because ByteStrings aren't strings of characters :P 
10:04:54 <cloudhead> xuxu: but of course, it can: forM [return ()] (\x -> x)
10:04:55 <glguy> saurabhnanda: There's a difference between text and encodings of that text. You have to be quite careful using Data.ByteString.Char8.pack because it presumes a latin1 encoding, which only covers a small subset of what fits in Strings
10:04:59 <hydraz> Aren't ByteStrings just really thin wrappers around char *?
10:05:09 <srhb> hydraz: Not quite.
10:05:18 <glguy> saurabhnanda: A safer way to go from text to bytes is UTF-8 encoding these days
10:05:53 <monochrom> Not wrapper and not very thin. What you should go for is "analogous concept".
10:06:15 <xuxu> cloudhead: i could see that working since it returns an empty list and lists are supposedly monads
10:06:16 <saurabhnanda> glguy: it's a DB connection string! what can possibly go wrong?
10:06:18 <monochrom> Except that char* doesn't know its length and ByteString knows. All comparisons are doomed.
10:06:33 <black0range> Speaking about text does anyone know if theres any posibility that the default string type is changed to Text?
10:06:34 <glguy> saurabhnanda: What could go wrong? You could produce an invalid connection string and not connect
10:06:47 <black0range> saurabhnanda: Text encodings are a thing :)
10:06:50 <srhb> Or segfault, or...
10:06:53 <saurabhnanda> glguy: and C8 vs Text will solve htat? 
10:06:56 <xuxu> though that seems that lambda would have a type sig of (m a -> m a)
10:07:18 <glguy> saurabhnanda: It depends on what encoding the database library expects. You should figure that out and produce whatever it is
10:07:18 <monochrom> glguy is precisely saying that C8 is wrong.
10:07:31 <hydraz> saurabhnanda: If your string is a literal, I'm pretty sure ByteString has IsString instances.
10:07:36 <monochrom> And you may cry bloody murder now.
10:07:53 <glguy> The IsString instance for ByteStrings presumes latin1 encoding
10:07:59 <hydraz> Damn it
10:08:13 <cloudhead> xuxu: yeah, the main thing to keep in mind though, is that 'a' can be /anything/, it can even be (m (m (m a)))
10:08:34 <lpaste> “tr|ck” revised “djbParsec.hs”: “djbParsec.hs” at http://lpaste.net/181083
10:08:36 <srhb> I think internally the pgconninfo string is in fact at least split up into * char
10:08:37 <monochrom> C8 assumes latin1. Which is becoming a falser and falser assumption by the second.
10:08:49 <monochrom> Twitter uses UTF-8.
10:08:56 <monochrom> Whatsapp uses UTF-8.
10:09:11 <monochrom> The list goes on and on. latin1 is an endangered species.
10:09:25 <hydraz> Thankfully, latin1 is kinda stupid
10:09:26 <black0range> Could someone tell microsoft that?
10:10:01 <monochrom> oh Microsoft is more complicated than that. (mainly because it is a large organization, not one single personality)
10:10:16 <monochrom> the kernel group swears by UTF-16 IIUC
10:10:16 <glguy> It's a split personality??
10:10:27 <lpaste> “tr|ck” revised “djbParsec.hs”: “djbParsec.hs” at http://lpaste.net/181083
10:10:57 <monochrom> the command.com group swears by those windows-125x code pages, which are "one byte per character" but not latin1
10:11:01 <hydraz> Dear Microsoft; Anything non-UTF-8 is stupid. Please adopt UTF-8; Thanks in advance, #haskell.
10:11:20 <srhb> hydraz: utf-16 is not that stupid...
10:11:39 <xuxu> cloudhead: it's still a little baffling for me. but i have a little more familiarity then i did when i started. 
10:11:46 <monochrom> hydraz, Data.Text uses UTF-16 too
10:11:52 <hydraz> GOD DAMN IT!
10:11:55 <saurabhnanda> okay, I don't know all this encoding business. but there's not reason that Yesod's API should expect a C8. 
10:12:07 <monochrom> don't cry bloody murder. just cry bloody holy war.
10:12:08 <xuxu> > forM [1,2,3] $ (\x -> do { return x }) :: Identity [Int]
10:12:10 <lambdabot>  Identity [1,2,3]
10:12:24 <alercah> UTF-8 is a better transfer encoding, but UTF-16 makes sense as a storage encoding sometimes
10:12:46 <black0range> saurabhnanda: When sending things through a network you're sending bytes not characters :)
10:13:22 <cloudhead> xuxu: good, it'll get easier :)
10:13:23 <monochrom> performance benchmarks on the "8 vs 16" debate are still partisan and biased.
10:13:25 <saurabhnanda> black0range: yes, and let Yesod.Persistent bother with that. Not me.
10:13:51 <monochrom> because you can easily pick one real-world corpus to make 8 look good. and you can do a similar thing to 16.
10:13:52 <xuxu> cloudhead: thanks for the encouragement :)
10:14:03 <int-index> glguy, so I've found what causes the error, GHC has a specific check that a type pattern has no type family applications
10:14:23 <int-index> and here the kind of `FZ` mentions a type family
10:15:02 <glguy> int-index: and that's an error and not a design choice?
10:15:23 <int-index> glguy, I believe it was a sensible check before TypeInType
10:15:33 <monochrom> You know what, I think my http://www.cs.utoronto.ca/~trebla/CSCB63-2016-Summer/lecture-10.pdf are pretty good slides on this.
10:15:56 <glguy> int-index: Good find, then :)
10:16:45 <koomi> cabal: out of memory (requested 1048576 bytes)
10:17:04 <koomi> so, cabal-install is unusable on systems with <= 1G of memory?
10:18:25 <black0range> koomi: Set some swap up 
10:18:28 <sm> koomi: certain packages (or combinations of packages) are unbuildable on systems with < 1G of memory. Telling cabal to limit heap size can help
10:18:57 <lpaste> “tr|ck” revised “djbParsec.hs”: “djbParsec.hs” at http://lpaste.net/181083
10:19:05 <koomi> sm: that's "cabal update" failing, I don't even get to building stuff
10:19:15 <koomi> and it wasn't linked with -rtsopts
10:19:19 <sm> how much memory do you have ?
10:19:23 <koomi> 1 gig
10:19:26 <lpaste> “tr|ck” revised “djbParsec.hs”: “djbParsec.hs” at http://lpaste.net/181083
10:19:26 <sm> (available)
10:19:54 <sm> anyway, ouch. It sounds abnormal
10:20:23 <JonReed> All Haskell's functors are really endofunctors. But from a theoretic point of view, in simple terms, is my understanding right that "Maybe a -> IO a" is a functor. "Maybe a -> Maybe a" is an endofunctor, "Maybe a -> a" is just a morphism, but not a functor. 
10:20:49 <koomi> 67M are used
10:20:55 <lpaste> “tr|ck” revised “djbParsec.hs”: “djbParsec.hs” at http://lpaste.net/181083
10:20:56 <koomi> oh my, let's try swap then
10:21:14 <koomi> in the hope it won't turn my box into a brick
10:21:21 <sm> I would also ask on #hackage 
10:21:32 <sm> or is it #cabal...
10:23:17 <lpaste> “tr|ck” revised “djbParsec.hs”: “djbParsec.hs” at http://lpaste.net/181083
10:23:37 <monochrom> JonReed: "Maybe" is a functor, "IO is a functor", "Maybe a -> IO a" is a natural transformation.
10:23:37 <dolio> Those are natural transformations.
10:24:34 <JonReed> Oh fuck. Just when I thought that I understood it now I'm back to zero.
10:24:37 <srhb> tr|ck: Are you aware that you're making the lpaste bot ping the channel with each revision of that lpaste? :-)
10:24:51 <lpaste> “tr|ck” revised “djbParsec.hs”: “djbParsec.hs” at http://lpaste.net/181083
10:24:55 <dolio> Maybe is an endofunctor because its kind is * -> *.
10:25:11 <JonReed> I thought that morphism is the actual arrow like (->)
10:25:29 <tr|ck> srhb: no I really wasn't thanks 
10:25:45 <srhb> tr|ck: Just untick the #haskell channel in the channel dropdown :)
10:25:55 <srhb> Or set it to nothing, rather.
10:26:02 <tr|ck> srhb: thanks again (:
10:26:42 <JonReed> It morphs something into something. Then, I thought that functor is a morphism that morps something of the same structure (* -> *), like `Maybe a -> IO a`
10:27:02 <tr|ck> srhb: now I got it. First time I'm using it. Thanks. Very cool tool
10:27:06 <JonReed> morphs something while presenving its structer*
10:27:33 <monochrom> "Maybe a -> IO a" is a morphism if you say "a is just one particular type", for example "Maybe Int -> IO Int"
10:27:58 <monochrom> but if you say "a is a type variable", equivalently "forall a. Maybe a -> IO a", you have a natural transformation.
10:28:11 <monochrom> These two facts are consistent with each other.
10:28:33 <srhb> tr|ck: :-)
10:28:39 <monochrom> In fact, they need each other.
10:29:55 <xcmw> Am I doing this correctly? http://lpaste.net/181116
10:31:09 <wedify> i need help with a dailyprogrammer challenge. i have most of it implemented but i can't figure out the last part. anyone willing to help?
10:31:13 <lpaste> wedify pasted “help with findNonIntersectingPaths3” at http://lpaste.net/181118
10:31:21 <hiptobecubic_> I have a data type "data Mem s = Mem !Int (U.MVector s Word)" that stores a cursor position in an array. I do a lot of operations to move the cursor around and I'm trying to avoid allocating so much. Do I need the int and vector in their own STRefs or something? Otherwise changes to the int force allocation of a new Mem, right?
10:31:32 <liste> xcmw: for a bit simplified concept of "duration"
10:31:55 <tr|ck> glguy, srhb: thanks again. brb
10:37:02 <xcmw> liste: I will add decimals and weeks
10:38:35 * hackagebot hoogle 5.0.3 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0.3 (NeilMitchell)
10:38:37 * hackagebot vty 5.9 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.9 (JonathanDaugherty)
10:45:10 <significance> Hey all! I'm reading through LYAH, which states that "applicative functors don't allow for the applicative values to interact with each other very much" - what do they mean by that?
10:45:49 <mauke> good question
10:46:26 <significance> mauke: after that, they say "They can, at best, be used as parameter to a function by using the applicative style" - but can't you chain applicative calls?
10:46:43 <hydraz> Yes.
10:47:08 <significance> Should I just ignore that paragraph?
10:47:19 <srhb> significance: Probably. :P
10:47:22 <hydraz> Pretty much.
10:47:40 <significance> I get that monads are awesome for preserving context in chains of function calls
10:47:56 <srhb> They're alluding to a difference between monads and applicatives for sure.
10:47:56 <significance> thanks!
10:47:58 <dolio> Presumably it means that you can't use the value yielded by an applicative action to determine what other actions are run.
10:48:11 <dolio> But it's an awkward way of saying it.
10:48:41 <significance> dolio: I'm not quite following - what do you mean by "what other actions are run"?
10:48:44 <significance> Like previously?
10:49:08 <dolio> Like in (>>=) :: m a -> (a -> m b) -> m b
10:49:38 <mauke> significance: no, afterwards
10:49:42 <dolio> I get to use the value of type a to determine what the `m b` is.
10:50:20 <mauke> significance: e.g. with IO (or rather the >>= operator) I can say, get a line from the user; if it's empty, get another line, otherwise print "hello"
10:50:43 <mauke> here the value I've read determines the action that follows
10:51:07 <mauke> you can't do that with applicative; the sequence of effects is "static"
10:51:54 <Xnuk> @hoogle (<%=)
10:51:54 <lambdabot> Control.Lens.Lens (<%=) :: MonadState s m => LensLike ((,) b) s s a b -> (a -> b) -> m b
10:51:54 <lambdabot> Control.Lens.Operators (<%=) :: MonadState s m => LensLike ((,) b) s s a b -> (a -> b) -> m b
10:51:55 <lambdabot> Lens.Micro.Mtl (<%=) :: MonadState s m => LensLike ((,) b) s s a b -> (a -> b) -> m b
10:52:23 <hydraz> Lens type signatures scare me.
10:52:23 <significance> mauke: weird! so applicatives are just like lifting a function, but monads are like chaining along context?
10:53:30 <mauke> I don't know what that means ¯\_(ツ)_/¯
10:53:40 <black0range> Applicatives are a "superclass" of Monads :) 
10:53:40 <significance> I'll figure things out - thanks!
11:01:59 <wedify> what's a good place on reddit to ask my question?
11:02:50 <wedify> i have a partial solution now but i don't understand why the result is missing stuff
11:02:55 <hydraz> /r/haskell? 
11:03:19 <mauke> stackoverflow?
11:03:25 <wedify> would it be welcome there? i thought it was more academic
11:03:26 <mauke> irc?
11:03:34 <hydraz> ... here?
11:03:37 <wedify> well i've asked here :)
11:05:13 <wedify> alright i will try /r/haskell. hopefully i don't die from the flames
11:05:49 <cocreature> as long as you don’t mention stack or cabal you’ll be fine
11:06:11 <black0range> Oooh you could spice things up and ask /r/programming.... I'll grab my popcorns
11:06:56 <ongy> there's still /g/ if you want unusable answers :)
11:08:42 <sm> wedify: asking little coding questions like that on reddit is a waste IMHO, here or #haskell-beginners is better
11:09:06 <sm> to get more responses, make your question more specific/easier to answer
11:09:40 <markus1199> joachifm: clever: About the ~/bin scripts I wanted to convert to nix yesterday evening, this is what I've come up with: https://gist.github.com/markus1189/78e30c4487fb37587172d4fcb94e83e7, pretty happy so far.  Any comments?
11:10:18 <wedify> sm: in other words just bash my head against till i get it :)
11:10:40 <sm> not at all
11:10:51 <wedify> my question can't really be made simpler
11:11:31 <sm> I think it can be made more enticing
11:11:37 <sm> but I'm not going to do it
11:11:46 <sm> good luck :)
11:12:24 <wedify> sm: thanks
11:13:07 <sm> alright, I admit I missed part of your question on first reading in the scrollback. Sometimes it takes a few tries to get help here
11:15:18 <sm> and, I mistook xcmw's question for yours. Sorry..
11:17:36 <sm> I'll come in again. wedify, so far you've pasted a 160-line program and the question is "i have a partial solution now but i don't understand why the result is missing stuff", right ?
11:18:24 <lingxiao> anyone know how to traverse multiple directories in conduit?
11:18:28 <sm> you can make this more enticing, eg, by being more concrete and specific
11:18:46 <undreren> Hi all. I have a question about Snaplets and postgres. Does anyone here know anything about that? Because I'm following a tutorial, and I can't make the example program work :(
11:25:32 <wedify> sm: i have a function that finds non-intersecting paths of two sets of paths. i want to generalize that to finding non-intersecting paths of a bunch of sets of paths
11:26:14 <wedify> is that better? 
11:26:49 <sm> yep
11:27:11 <sm> keep going :)
11:28:00 <sm> no offense intended, I'm genuinely trying to be helpful
11:28:13 <wedify> i'm trying to not be annoying :)
11:29:49 <sm> if nothing else, this will help you refine your eventual reddit question :)
11:30:11 <lingxiao> hey all
11:30:30 <lingxiao> is anyone here familar with conduits and know how i can travrse a list of directories?
11:30:53 <lingxiao> that is instead of sourceDirectory f  we have sourceDirectories [f1...fn]
11:31:22 <sm> wedify: so far you've asked us to spend time understanding a non-trivial program, and show you how to do a non-trivial enhancement. That's quite a lot to ask, hence few replies. How could you boil it down further ?
11:33:58 <wedify> sm: i see your point but i'm not sure how to make it simpler. i will spend time thinking about it
11:36:11 <lyxia> lingxiao: mapM sourceDirectory fs ?
11:36:36 <sm> in your shoes, if I don't see a better way, I would start at the top of the program and change the first place that limits to two sets, figure out what's needed to make it compile. That will lead to the next place, and so on, and start generating ideas
11:36:45 <sm> good luck
11:37:10 <lingxiao> lyxia uh i get     Couldn't match type ‘[()]’ with ‘()’ 
11:37:43 <mauke> mapM_
11:38:05 <lingxiao> uh i got it
11:43:14 <peteretep> So I actually used applicative to do something
11:43:20 <peteretep> I had no idea it was anything other than a gimmick
11:43:21 <peteretep> :P
11:43:37 * hackagebot vty 5.9.1 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.9.1 (JonathanDaugherty)
11:51:44 <wedify> sm: there isn't a haskell solution for the challenge. other languages are winning! surely that's enough incentive ;)
11:52:08 <sm> wedify: that can help, especially if you paste a link
11:52:39 <sm> where do we see this travesty of justice
11:52:56 <wedify> https://www.reddit.com/r/dailyprogrammer/comments/4zog32/20160826_challenge_280_hard_free_flow_solver/
11:53:35 <sm> I'm working on my own challenge now (2h ludum dare entry), so I will leave you
11:54:55 <wedify> no problem. i don't expect more than what people want to give
11:58:20 <saurabhnanda> well, the latest outrage (https://www.reddit.com/r/haskell/comments/4zzmoa/haskellorg_and_the_evil_cabal/) proves my point. Haskell needs a dictator.
11:59:01 <saurabhnanda> everything is spread too thin. Too many choices. Too many opinions. Just kill some of them already. And focus on taking the eco-system forward.
11:59:33 <EvanR> the problem is people, nothing wrong with haskell
12:00:10 <lyxia> Isn't the outrage directed precisely at the committee acting like a dictator though
12:01:12 <saurabhnanda> dictator == sensible dictator
12:01:23 <saurabhnanda> someone who brings order and tries to take people along
12:01:25 <EvanR> 1 == sensible
12:01:36 <saurabhnanda> not bad dictator, good dictator
12:01:36 <srhb> What we need is #haskell-politics or something to clear up this channel again.
12:01:41 <cocreature> EvanR: so because 2 == sensible is obviously also true, 1 == 2!
12:01:42 <saurabhnanda> dictator = someone who takes the final decision
12:02:10 <lispy> srhb: or #haskell-we-need-to-talk
12:02:11 <EvanR> probably a quotation mismatch or something
12:02:19 <srhb> lispy: Anything but this. :-P
12:02:34 <lyxia> oops. srhb++
12:02:48 <EvanR> saurabhnanda: someone who brings total order or partial order
12:03:26 <saurabhnanda> anyways, I would vote with my money for whoever comes up with a batteries included Haskell platform, which fixes the stupid strings/text issue, someone who fixes the errors issue, and someone who comes up with an IDE that just-works.
12:03:38 * hackagebot propellor 3.1.2 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-3.1.2 (JoeyHess)
12:03:55 <EvanR> youre bank rolling a redesign of haskell?
12:04:08 <saurabhnanda> EvanR: I will contribute to whoever wants to do that.
12:04:29 <saurabhnanda> EvanR: take a monthly subscription to make sure it keeps getting better.
12:04:49 <saurabhnanda> some of the problems need at least a library redesign -- strings & errors come to mind.
12:04:50 <EvanR> commercial free software, stallman's dream 
12:05:07 <saurabhnanda> some can do with a bit of core-language tweaking -- eg. records
12:05:28 <EvanR> why is it that nothing seems really wrong until i click on a reddit link
12:05:30 <saurabhnanda> it needs to be done.
12:05:55 <saurabhnanda> and if it's committee driven -- only 2 types of people should be allowed to vote. People who contribute -- in terms of money or code.
12:06:00 <saurabhnanda> or documentation also.
12:06:07 <srhb> O_o
12:06:46 <ggole> What could possibly go wrong.
12:07:41 <saurabhnanda> ggole: wrt?
12:07:51 <EvanR> languages and ecosystems orders of magnitude worse than haskell current survive and produce real life products
12:07:57 <EvanR> on real life timescales
12:08:08 <lispy> I hate to be that guy, but maybe we should move these discussions elsewhere
12:09:08 <wedify> to #cabal-flame
12:09:20 <EvanR> #haskell-blah (secretly knowing that enroute most people will get clotheslined by the ssl thing)
12:10:14 <saurabhnanda> okay, I'll stop
12:10:39 <wedify> i think open-source is meant to be filled with forks. it's how things are kept honest
12:27:55 <lingxiao> does anyone know how to convert from integer to fractional? 
12:28:07 <lingxiao> hey all does anyone know how to convert from integer to fractional?
12:28:55 <glguy> fromInteger :: Fractional a => Integer -> a
12:29:50 <EvanR> > fromInteger (3 :: Integer) :: Pico
12:29:52 <lambdabot>  3.000000000000
12:30:23 <Clint> lingxiao: yes
12:35:03 <pyrtsa> On the Ord instance of Maybe; is there a deeper wisdom behind the choice of which way `Nothing` compares to `Just _`, or is it just a historic incidence that Nothing happened to be first in the ADT definition?
12:36:12 <EvanR> lingxiao: to rogue's gallery of number conversion functions are: fromIntegral, realToFrac, floor/ceiling/round/truncate. the first two are implemented with fromInteger/toInteger and fromRational/toRational (unless there are some ghc behind the scenes rewrite rules for certain types)
12:36:20 <EvanR> lingxiao: the*
12:36:26 <lingxiao> ah that's awesome ... ok will keep in mind thanks@1
12:36:35 <b2coutts> pyrtsa: I think it's just intuitive that "nothing is less than something"
12:39:00 <pyrtsa> b2coutts: E.g. PostgreSQL chose its sorting of NULLs the other way around. And I've found it useful at times (with natural numbers or thereof) that adding one more unit to the type union lets me augment the open-ended class of values with a supremum value.
12:39:34 <EvanR> i think theres a newtype which changes how Maybe's Ord works
12:39:40 <EvanR> :t Last
12:39:42 <lambdabot> Maybe a -> Last a
12:39:42 <pyrtsa> Cool.
12:40:13 <EvanR> > sort [Last Nothing, Last (Just 3)]
12:40:17 <pyrtsa> It seems to me Idris and Agda chose to omit the Ord instance of `Maybe a` altogether, FWIW.
12:40:18 <lambdabot>  [Last {getLast = Nothing},Last {getLast = Just 3}]
12:41:50 <EvanR> nevermind that changes the Monoid instance
12:42:15 <pyrtsa> Yeah, just figured the same.
12:42:19 <lyxia> Down (Maybe (Down a))
12:42:53 <EvanR> where is Down
12:43:02 <fr33domlover> EvanR, Data.Ord
12:43:08 <fr33domlover> iirc
12:44:33 <EvanR> > sort [Down Nothing, Down (Just (Down 3)), Down (Just (Down 4))]
12:44:36 <lambdabot>  [Down (Just (Down 3)),Down (Just (Down 4)),Down Nothing]
12:44:55 <EvanR> :t getDown
12:44:57 <lambdabot> error: Variable not in scope: getDown
12:45:00 <EvanR> aw
12:45:19 <lyxia> also this https://hackage.haskell.org/package/monoid-extras-0.4.2/docs/Data-Monoid-Inf.html
12:45:33 <mniip> aw
12:45:36 <mniip> there's no 'up'
12:46:20 <pyrtsa> Oh, in my original message: s/thereof/lexicographically sorting sequences thereof/
12:46:38 <EvanR> Inf looks more convenient
12:47:52 <pyrtsa> Yeah, Inf looks useful.
12:48:13 <pyrtsa> (For the narrow set of use cases I had in mind.)
12:56:31 <saurabhnanda> okay, last try with the yesod+postgres benchmarks before going to sleep... hope they knock the ball out of the park!
12:56:51 <sm> saurabhnanda: what kind of changes have you made ?
12:56:59 <saurabhnanda> switched to PG
12:57:08 <saurabhnanda> sm: switched from MySQL to PG
12:57:11 <sm> nice. Thanks for working on it
12:57:30 <Welkin> saurabhnanda: you mean persistent
12:57:58 <saurabhnanda> Welkin: techempower benchmarks. so it's Warp + Wai + Yesod + Persistent. The entire stack.
12:58:54 <saurabhnanda> and wrote them in a typical yesod fashion
12:58:58 <saurabhnanda> basically straight out of the yesod book
12:59:18 <sm> saurabhnanda: what kind of machine are you running on ?
12:59:38 <saurabhnanda> sm: right now, it's 3 scrappy machine on EC2. t2.medium, I believe.
12:59:39 <Welkin> an amiga
12:59:40 <Welkin> lol
13:00:03 <Welkin> could you run a web server on an amiga?
13:00:16 <EvanR> amigas didnt have internet
13:00:28 <Welkin> so!?
13:00:29 <saurabhnanda> yup t2.medium
13:00:37 <Welkin> add it
13:00:45 <EvanR> uh huh
13:00:48 <Welkin> I think people run servers on raspberry pi
13:00:51 <saurabhnanda> not about the raw performance, but comparitive performance with yesod-mysql and ruby
13:01:15 <EvanR> by all reasonable standards rpi are modern PC computers
13:02:02 <Welkin> run it on a gameboy
13:02:03 <Welkin> :O
13:02:42 <Welkin> what were gameboy cpus? zilog?
13:02:50 <EvanR> web and web servers are just so bloaty its sad to see it wasting 40 thousands times the capacity of something like a gameboy
13:02:54 <EvanR> z80
13:02:57 <Welkin> Sharp
13:02:58 <Welkin> yeah
13:03:19 <Welkin> and the ps1, ps2, and psp were mips
13:03:32 <Welkin> does haskell run on any of those?
13:03:59 <EvanR> oh right, the haskell channel. no it doesnt
13:08:29 <saurabhnanda> hmm strange results
13:09:01 <sm> the usual :)
13:09:25 <sm> let me guess.. no change ?
13:17:47 <saurabhnanda> sm: 200% speed-up https://gist.github.com/saurabhnanda/6f3e7afd5c7153e72b0f5ab599346090
13:18:36 <sm> woot! good progress!
13:19:32 <saurabhnanda> sm: trying with higher concurrency levels now
13:19:39 <saurabhnanda> sm: should be at least 20x ruby
13:21:36 <wedify> HOLY SHIT I HAVE DONE IT!
13:21:44 <wedify> well almost
13:22:19 <lpaste> wedify pasted “free-flow solution” at http://lpaste.net/181172
13:22:28 <Welkin> saurabhnanda: well, anything is faster than ruby o.o
13:23:40 * hackagebot yesod-auth-account 1.4.3 - An account authentication plugin for Yesod  https://hackage.haskell.org/package/yesod-auth-account-1.4.3 (JohnLenz)
13:23:59 <saurabhnanda> Welkin: no, not if you're looking at round-13 of techempower benchmarks. Haskell is slower.
13:24:01 <sm> Welkin: ha ha, you say that but ruby is kicking our functional butts all over those benchmarks :)
13:33:33 <wedify> alright guys go to https://www.reddit.com/r/dailyprogrammer/comments/4zog32/20160826_challenge_280_hard_free_flow_solver/ and upvote my solution so i get lots of imaginary points
13:33:42 <wedify> :P
13:33:52 <saurabhnanda> @hackagebot Text -> Int
13:33:52 <lambdabot> Unknown command, try @list
13:34:08 <saurabhnanda> what's the easiest+safest way to convert Text -> Int ?
13:34:16 <glguy> const 0
13:34:41 <saurabhnanda> :t (const 0)
13:34:43 <lambdabot> Num a => b -> a
13:34:56 <saurabhnanda> first time I've heard of this!
13:34:57 <magbo> Greetings, everyone. In servant, obviously, :<|> combines APIs, not parts of those. I wonder if there exists, however, a way to write this[1] down more elegantly:
13:34:57 <hydraz> saurabhnanda: unpack x _ = x
13:35:00 <magbo> [1]: https://gist.github.com/manpages/f3cc3f5d5e1f138528dc7cbbf63a5129
13:35:05 <hydraz> er, const*
13:35:17 <hydraz> unpack is what I was supposed to be writing in my editor buffer :P
13:36:33 <saurabhnanda> no why would I want const
13:36:46 <saurabhnanda> I want to conver "34234" -> 34234
13:37:01 <hydraz> saurabhnanda: would read @Int . unpack work?
13:37:20 <hydraz> :t (read :: String -> Int) . Data.Text.Lazy.unpack
13:37:22 <lambdabot> Data.Text.Internal.Lazy.Text -> Int
13:38:00 <saurabhnanda> hydraz: might work
13:38:08 <saurabhnanda> there's nothing that works on Text and gives back a Maybe Int?
13:38:18 <hydraz> I don't think so
13:39:17 <mauke> Text.Read readMaybe :: Read a => String -> Maybe a -- well, that's fun
13:39:18 <jaspervdj> Text.Read.readMaybe . unpack
13:39:58 <saurabhnanda> what about http://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Read.html
13:40:57 <monochrom> yes, I would use that
13:41:06 <seagreen> Is there an actively maintain library that provides a base32 encoding function?
13:41:27 <monochrom> And I was looking through Data.Text for something more direct before I felt safe to recommend Data.Text.Read
13:43:44 <jaspervdj> huh.  I wasn't aware of Data.Text.Read.  Looks like it's been there since text-0.9, wow.
13:45:32 <Welkin> when parsing a file, does it make more sense to read it all in at once and then parse the string? Or parse it as it is read in with a file handle?
13:45:54 <jaspervdj> Welkin: depends on the file size
13:46:00 <Welkin> pretty small
13:46:10 <Welkin> under 1 mb
13:46:25 <jaspervdj> then I wouldn't bother for now, keep it simple at first
13:47:11 <Welkin> jaspervdj: I don't think I've been you chat in here before :D
13:47:14 <Welkin> seen*
13:47:21 <Welkin> thanks for hakyll
13:47:55 <jaspervdj> yeah I haven't been on irc too much lately.  appreciate it
13:54:04 <saurabhnanda> sm: hardware seems to be maxing out after 32 concurrency -- https://gist.github.com/saurabhnanda/6f3e7afd5c7153e72b0f5ab599346090
13:55:51 <sm> jaspervdj++ !
14:01:53 <jle`> saurabhnanda: you can use aeson too for that
14:02:01 <jle`> er wait no
14:02:06 <jle`> i'm thinking about bytestring
14:03:56 <jaspervdj> sm: :-)
14:23:25 <saurabhnanda> okay, multiple DB query test now
14:23:28 <saurabhnanda> let's see how this fares
14:23:42 * hackagebot stylish-haskell 0.6.4.0 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.6.4.0 (JasperVanDerJeugt)
14:25:52 <hiptobecubic_> Is there a way to drop from the right of a sequence? I only see for the left and it looks like reverse is O(n)
14:26:14 <hiptobecubic_> Well really I need splitAtR I guess
14:26:47 <hiptobecubic_> I suppose I could call length and do the arithmetic myself, but the asymmetry in the library is strange
14:27:05 <xansx> @pl \xs n -> take n xs ==> flip take
14:27:05 <lambdabot> flip flip (flip take) . ((==>) .) . flip take
14:27:46 <xansx> @unpl (. f)
14:27:46 <lambdabot> (\ a0 x -> a0 (f x))
14:28:08 <xansx> @unpl (f .)
14:28:08 <lambdabot> (\ g x -> f (g x))
14:29:07 <xansx> @undo do { x <- getLine; print x } ==> getLine >>= \ x -> print x
14:29:07 <lambdabot> getLine >>= \ x -> print x ==> getLine >>= \ x -> print x
14:29:31 <hydraz> what's (===>)?
14:29:36 <hydraz> er, (==>)
14:30:16 <xansx> @undo do { x <- getLine; print x }
14:30:16 <lambdabot> getLine >>= \ x -> print x
14:30:35 <LordBrain> looks like it is 'evaluates to' or 'reduces to'
14:30:46 <LordBrain> not real code
14:30:49 <Zemyla> xansx: Use -- instead, to comment it out.
14:31:12 <hydraz> oh, I see
14:36:10 <xansx> @unpl (.f).g.f
14:36:10 <lambdabot> (\ x x0 -> g (f x) (f x0))
14:38:31 <mauke> :t ?g `on` ?f
14:38:33 <lambdabot> (?g::b -> b -> c, ?f::a -> b) => a -> a -> c
14:40:00 <black0range> Whats the 'cleanest' way to select n unique random elements from a list? 
14:40:16 <mauke> shuffle, take n
14:40:57 <jle`> is there any common idiom i'm missing for \f -> fmap f . sequence ?
14:43:21 <Rarrikins> @pl \f -> fmap f . sequence
14:43:21 <lambdabot> (. sequence) . fmap
14:43:37 <mauke> :t fmap ?f . sequence
14:43:39 <lambdabot> (?f::t a -> b, Traversable t, Monad f) => t (f a) -> f b
14:45:32 <mniip> :t \f -> fmap f . sequence
14:45:33 <lambdabot> (Traversable t, Monad f) => (t a -> b) -> t (f a) -> f b
14:48:02 <mniip> hmm
14:48:28 <mniip> if you can fold a pure structure you can fold a monadic structure too
14:50:29 <mniip> 1472420289 [00:38:09] <mauke> :t ?g `on` ?f
14:50:45 <mniip> might have bad effects if f is used at two types in the original expr
14:53:43 * hackagebot hspec-webdriver 1.2.0 - Write end2end web application tests using webdriver and hspec  https://hackage.haskell.org/package/hspec-webdriver-1.2.0 (JohnLenz)
14:58:43 * hackagebot webdriver-angular 0.1.11 - Webdriver actions to assist with testing a webpage which uses Angular.Js  https://hackage.haskell.org/package/webdriver-angular-0.1.11 (JohnLenz)
14:58:45 * hackagebot papillon 0.1.0.3 - packrat parser  https://hackage.haskell.org/package/papillon-0.1.0.3 (YoshikuniJujo)
15:08:43 * hackagebot react-flux 1.2.2 - A binding to React based on the Flux application architecture for GHCJS  https://hackage.haskell.org/package/react-flux-1.2.2 (JohnLenz)
15:13:43 * hackagebot sexp-grammar 1.2.2 - Invertible parsers for S-expressions  https://hackage.haskell.org/package/sexp-grammar-1.2.2 (EugeneSmolanka)
15:28:44 * hackagebot servant-quickcheck 0.0.1.0 - QuickCheck entire APIs  https://hackage.haskell.org/package/servant-quickcheck-0.0.1.0 (jkarni)
15:28:46 * hackagebot cipher-aes128 0.7.0.2 - AES and common modes using AES-NI when available.  https://hackage.haskell.org/package/cipher-aes128-0.7.0.2 (ThomasDuBuisson)
16:08:45 * hackagebot hackage-security 0.5.2.2 - Hackage security library  https://hackage.haskell.org/package/hackage-security-0.5.2.2 (DuncanCoutts)
16:22:38 <Gues> For System.Console.GetOpt, I don't understand why the types are parameterized or what type I should choose. I tried just () for the type value in NoOpt (); that didn't work.
16:24:17 <glguy> Gues: The types are parameterized so that you can return information about what flag matched
16:25:31 <glguy> Prelude System.Console.GetOpt> getOpt RequireOrder [Option ['x'] [] (NoArg "Got an x") "documentation for -x"] ["-x","example"]
16:25:32 <glguy> (["Got an x"],["example"],[])
16:26:16 <Gues> glguy: Okay, my code looks like that but I had () in placd of "Got an x" and I got type errors.
16:26:52 <Rarrikins> How do you turn on an extension in ghci?
16:27:00 <glguy> Rarrikins: :set -XTheExtension
16:27:06 <Rarrikins> Thanks
16:27:16 <lingxiao> hey all i have a design question
16:27:26 <lingxiao> suppose I have an attoparsec parser   p = string "hello"
16:27:49 <lingxiao> I'd like to give this parser a name ... w/o using <?> from attosparsec combinatros
16:28:03 <lingxiao> am I left with the only option of wrapping the Parser type around antoher type?
16:28:21 <lingxiao> ie ...     data MyParser = P { name :: String, run :: Parser Text }
16:29:35 <lingxiao> at the current moment I'm not sure i can even do someting like p = "hello" <?> (string . pack $ "hello")
16:31:52 <Gues> glguy: Thanks. It's compiling now. I think the problem before is that I declared 'a' but () is a value of type (). Not sure. I just went with a String for now like in your code.
16:32:46 <glguy> Gues: Better than a String would be a data type specific to your flags: data GuesFlag = FastFlag | QuietFlag | InputFileFlag FilePath
16:32:58 <glguy> Gues: A common pattern is to return a function
16:33:01 <reinh1> lingxiao: write a combinator
16:33:10 <lingxiao> sorry what might it do?
16:33:32 <glguy> Gues: here's an example using functions https://github.com/glguy/irc-core/blob/v2/src/Client/Commands/Exec.hs#L41
16:33:35 <lingxiao> it certainly can't take a parser (string . pack $ "hello") and "get out" the "hello"
16:33:59 <reinh1> namedString s = string s <?> s?
16:35:10 <reinh1> er, with the appropriate conversion of s to bytestring or text or w/e
16:35:28 <reinh1> e.g., namedString s = string (pack s) <?> s
16:35:39 <Gues> glguy: Alright, thank you very much.
16:35:55 <lingxiao> ok if namedString fails it doesn't output the name of the parser though
16:36:16 <reinh1> What are you parsing?
16:36:38 <monochrom> lingxiao: Suppose I have x,y :: Parser Int, x's name is monochrom, y's name is albert. Then what will be the name of liftA2 (+) x y?
16:36:49 <Gues> By the way, does GHC compile for ARM easily now?
16:37:11 <lingxiao> should's monochrom albert
16:37:24 <lingxiao> reinh1 ok nvm got it to fail witha a message
16:40:02 <owoce> hi everyone. i have a style question
16:40:21 <wedify> i love undefined
16:41:51 <owoce> i noticed people using a 'go' function inside function definitions to do stuff you'd use a loop for in an imperative lang
16:42:15 <owoce> you know, foo x = go x where go x = ...
16:42:22 <wedify> yep
16:42:23 <owoce> is that considered good style?
16:42:27 <wedify> yep
16:42:28 <mniip> yes
16:42:30 <glguy> Yeah, that's pretty normal
16:42:36 <hpc> it's occasionally the best way to write things
16:42:47 <mniip> unless you can convey the meaning in a more clean way using a combinator
16:42:51 <hpc> foo = something simple where a whole bunch of stuff
16:43:00 <mniip> e.g, map, foldr, 
16:43:15 <mniip> fix perhaps
16:44:57 <wedify> i've been learning joy. i like how you can't define functions but must use a recursion combinator
16:45:10 <wedify> eg, primrec, binrec
16:45:17 <ahihi> if the definition really is just foo x = go x where …, you don't need the helper function
16:45:32 <owoce> i guess normal recursion gets  verbose/ not that readable when your function takes say 3 parameters
16:45:45 <fr33domlover> Q: How do I choose between associated data and associated type synonym? assuming the user probably defines a dedicated type anyway
16:46:01 <owoce> so if its like foo a b c = go a where ...
16:46:13 <owoce> then it makes sense maybe? idk
16:46:42 <mniip> owoce, not really
16:47:17 <mniip> fac = fix $ \fac n -> if n == 0 then 1 else n * fac (n - 1)
16:48:12 <owoce> havent really understood how fix works yet, sorry 
16:48:46 * hackagebot pretty-types 0.2.0.0 - A small pretty printing DSL for complex types.  https://hackage.haskell.org/package/pretty-types-0.2.0.0 (SvenHeyll)
16:49:30 <owoce> (i know it does something with passing the function to itself, but it hasn't clicked yet)
16:49:51 <jonored> owoce: More usual I think would be foo a = go a [] [] where go a b c =...
16:54:56 <glguy> Steve Holt!
16:55:39 <fr33domlover> anyone has advice?
16:55:50 <fr33domlover> on associated data vs type synonym?
16:58:46 * hackagebot servant-quickcheck 0.0.1.1 - QuickCheck entire APIs  https://hackage.haskell.org/package/servant-quickcheck-0.0.1.1 (jkarni)
16:58:48 * hackagebot react-flux-servant 0.1.0 - Allow react-flux stores to send requests to a servant server  https://hackage.haskell.org/package/react-flux-servant-0.1.0 (JohnLenz)
17:03:43 <slack1256T> fr33domlover: I don't think they even solve the same needs
17:04:25 <MarLinn> fr33domlover: The very few times I've used families in my own stuff I got no benefit from data families. With type families I can re-use an existing type. But then maybe I used them wrong
17:05:14 <xuxu> > putStrLn 2
17:05:17 <lambdabot>  error:
17:05:17 <lambdabot>      • No instance for (Num String) arising from the literal ‘2’
17:05:17 <lambdabot>      • In the first argument of ‘putStrLn’, namely ‘2’
17:05:22 <slack1256T> plus I don't think data families that useful
17:05:23 <hydraz> > print 2
17:05:25 <xuxu> how can i get around this?
17:05:25 <lambdabot>  <IO ()>
17:05:30 <slack1256T> > putStrLn "2"
17:05:32 <lambdabot>  <IO ()>
17:05:34 <hydraz> :t print
17:05:36 <lambdabot> Show a => a -> IO ()
17:05:44 <slack1256T> :t putStrLn
17:05:45 <lambdabot> String -> IO ()
17:06:05 * slack1256T got a partner in crime now
17:06:13 <hydraz> haha
17:07:30 <pavonia> fr33domlover: Associated data types are injective, type families aren't. You sometimes need the former when dealing with fundeps-like constructs
17:08:56 <slack1256T> pavonia: do you have an example package that use data families?
17:09:43 <pavonia> Hhm, I don't know which package uses them
17:10:06 <fr33domlover> slack1256T, persistent
17:11:07 <slack1256T> nice
17:11:22 <fr33domlover> pavonia, basically I'm letting persistent backends define some extra data, which is likely not to be shared between backends (because it contains raw query text etc.)
17:11:39 <fr33domlover> i just wonder about best practice
17:14:35 <fr33domlover> i suppose it's much easier to move from associated data to associated synonym, than the other direction. i'm taking assocated data for now
17:15:28 <lingxiao> does anyone know if there's a way to force an attoparsec parser to fail
17:15:44 <lingxiao> as opposed to pass in some input like ""
17:15:50 <lingxiao> which maybe wont fail for some parsers
17:15:59 <hpc> does fail work?
17:16:01 <hpc> :t fail
17:16:02 <lambdabot> Monad m => String -> m a
17:16:35 <jle`> empty also fails
17:16:38 <jle`> or mzero
17:16:40 <jle`> take your pick :)
17:16:56 <fr33domlover> but 'fail' is now from MonadFail iirc?
17:17:12 <fr33domlover> not sure which GHC version starts this change
17:17:28 <hpc> 8.something
17:17:30 <jle`> you just need whatever works for the attoparsec parser type
17:17:35 <hpc> lambdabot's still on 7.10.x
17:17:39 <hydraz> 8.0.1, I guess.
17:17:44 <lingxiao> sorry how does mzero wwork  jle` ?
17:17:47 <hpc> :t mzero
17:17:49 <lambdabot> MonadPlus m => m a
17:17:53 <hpc> :t empty
17:17:54 <jle`> :t \x -> (mzero >> x)
17:17:54 <lambdabot> Alternative f => f a
17:17:55 <lambdabot> MonadPlus m => m b -> m b
17:18:08 <jle`> (mzero *>) takes a parser and returns one that just fails right off the bat
17:18:08 <lingxiao> ah nvm got empty to work :)
17:18:13 <lingxiao> ahh i see
17:18:14 <Gues> glguy: I want Bools for my no-argument options and Strings for my argument options. How should I do this when everything must be parameterized over the same type? Do I just use Either?
17:18:20 <hydraz> mzero is to MonadPlus what mempty is to Monoid (right?)
17:18:40 <lpaste> xuxu pasted “warning” at http://lpaste.net/181207
17:18:42 <jle`> yeah, it's the identity of mplus, but it has other laws associated with it too
17:18:47 * hackagebot hasql-class 0.0.0.0 - Encodable and Decodable classes for hasql  https://hackage.haskell.org/package/hasql-class-0.0.0.0 (jkarni)
17:18:56 <xuxu> i'm trying to get rid of the warning that is pasted above
17:19:03 <jle`> but yeah, mzero is now as redundant as return, you should probably be using 'empty' instead
17:19:41 <hydraz> base could use a lot of cleaning up after the AMP. what's the point of having return *and* pure, other than backwards compat?
17:20:30 <hpc> hydraz: it takes a few versions to go through the cycle of deprecation and updating packages
17:20:36 <jle`> i guess there's one use, which is that you can write only a Monad instnace, and then have an Applicative instance written without extra work
17:20:37 <hpc> there's no way that's not already being planned by someone
17:20:44 <geekosaur> xuxu, (2 :: Integer), or {-# OPTIONS_GHC -fno-warn-type-defaults
17:20:49 <geekosaur> er
17:20:58 <geekosaur> {-# OPTIONS_GHC -fno-warn-type-defaults #-}
17:21:21 <geekosaur> (which can be -wtype-defaults with ghc8.0.1)
17:23:10 <hydraz> How long are the GHC release cycles, in general?
17:24:38 <Gues> glguy: I think I get it. I made like data Option = A | B String and used Option as the type argument
17:24:45 <MarLinn> I'm not sure if Alternative and MonadPlus always agree, so in general I would be cautious about mzero and empty
17:25:06 <glguy> Gues: sounds like a good plan
17:25:22 <jle`> MarLinn: isn't mzero = empty, mplus = (<|>) a MonadPlus law?
17:25:43 <jle`> oh hm, it's not
17:25:45 <jle`> that's unfortunate
17:25:52 <jle`> how did this (not) happen
17:26:03 <Gues> glguy: But seems inefficient to have to run through the list of returned values
17:26:43 <jle`> i'd argue that it's a de-facto law is the general expectation of everyone to the extent that a contradictory MonadPlus would be the dangerous thing
17:28:01 <glguy> it's fine
17:28:52 <MarLinn> jle`: I wouldn't expect that in general, because "addition" and "choice" have different connotations to me.
17:29:31 <jle`> then there's no reason why Alternative would be a superclass of MonadPlus
17:29:41 <slack1256T> yeah, but addition and choice and mental models of their meaning. The real meaning ought to be captured by algebraic laws
17:29:58 <MarLinn> jle`, ok that's a fair point
17:30:43 <glguy> gues: the alternative is the function version i showed you earlier
17:30:51 <xuxu> geekosaur: what exactly is that though?
17:30:56 <xuxu> why is it complaining
17:31:03 <xuxu> geekosaur: thank you for responding btw!
17:31:44 <geekosaur> because numeric literals are polymorphic. haskell has always used defaulting to figure out which one you mean, but in recent ghc versions there is a warning whenever defaulting is used
17:31:49 <geekosaur> :t 2
17:31:51 <lambdabot> Num t => t
17:31:54 <geekosaur> ^
17:31:54 <Gues> glguy: I looked at your example, but it was confusing. Also, you didn't seem to use NoArg
17:32:34 <geekosaur> so, one solution is to always specify the type at which a numeric literal is used, and the other is to turn off the warning about defaulting
17:32:37 <glguy> Gues: it works the same way with NoArg
17:32:58 <hydraz> I assume that defaulting to Integer was used because using other instances of Num requires calling `fromInteger`, which is potentially expensive?
17:33:14 <Gues> glguy: It doesn't seem like there is any getting around the fact that getOpt returns a list of results
17:33:38 <glguy> right
17:33:47 <geekosaur> it defaults to Integer because `default (Integer, Double)` is the "default default"
17:34:17 <Gues> glguy: It seems like if I want to know if "-a" was used, I have to run through the list looking for an A-value of my Option type
17:34:44 <glguy> once
17:34:53 <geekosaur> you can specify by making your own `default` declaration, but doing so may cause surprises if you were implicitly relying on defaulting elsewhere (which is very common; how many people always write 2.0 when they mean a Double?)
17:35:04 <Gues> glguy: What I really want is a single value from getOpt with record functions like isA : Bool, getB : String
17:35:08 <glguy> you can have a configuration data type you build using those flags once
17:35:18 <glguy> yeah, that's the idea
17:35:34 <geekosaur> and even then you'd get defaulting anyway
17:35:37 <geekosaur> :t 2.0
17:35:38 <lambdabot> Fractional t => t
17:35:47 <Gues> glguy: But how can I have just one value if getOpt makes you create one for every option?
17:35:47 <glguy> and that's what the example code i showed you did
17:36:07 <glguy> Gues: by processing the list of results
17:36:17 <Gues> glguy: But how can I have just one value if getOpt makes you create one for every option?
17:36:27 <glguy> Gues: by processing the list of results
17:36:31 <Gues> glguy: Oops. And combining the values in the list?
17:36:37 <Gues> glguy: lol
17:36:51 * geekosaur is of the opinion that defaulting warnings should not have been turned on by default
17:37:20 <geekosaur> since so much code implicitly makes use of numeric defaulting and people expect it to just work without throwing warnings at them
17:37:55 <Gues> glguy: Like if I had a bunch of Option Bool Bool String values in the list, I would combine them into one Option value?
17:38:06 <geekosaur> this is especially "fun" with operators that don't give you much of an option to infer the type...
17:38:09 <geekosaur> :t (^)
17:38:11 <lambdabot> (Num a, Integral b) => a -> b -> a
17:38:13 <glguy> Gues: make a record
17:38:36 <geekosaur> about the only way to avoid a defaulting warnings is to always annotate the `b` with a type :/
17:38:44 <jle`> i find myself defining a special (^) that only works for Integer's and using that instead
17:38:47 <jle`> or Int's
17:38:53 <jle`> s/find/often find
17:40:05 <Gues> glguy: I think I'm not understanding. If I make a big type T with all the values, does each option have to return a T -> T that I have to apply to some default T?
17:40:43 <glguy> Gues: yes, if you're returning functions from getOpt, that's what you'd need
17:41:01 <Gues> glguy: Ohhh
17:41:41 <Gues> Then I do like map (.) results $ init
17:41:59 <glguy> not quite a map, you want to combine them
17:42:02 <Gues> Or there is also some folding function I guess
17:42:07 <glguy> yeah
17:53:41 <xuxu> geekosaur: wow, very useful. thank yu
17:54:03 <xuxu> now if only i can figure out how to turn off the warnings in the atom text editor
17:55:01 <geekosaur> mm. I removed atom because it's big and slow :/ presumably somewhere you can specify default ghc options for its checking (via ghc-mod?) and add -fno-warn-type-defaults to that
17:56:12 <Gues> So for a record type T, Haskell creates T -> F, T -> G, for T's fields F and G. Is there a way to also get F -> T -> T and G -> T -> T, kind of like setters?
17:56:51 <Gues> I mean get without having to manually define them
17:57:00 <jle`> you don't get those functions exactly, but you can use record update syntax
17:57:13 <jle`> there are libraries that provide template haskell to define them too
17:57:35 <jle`> it's a bit unsatisfactory, but i think there is some work on GHC to make things a bit nicer on this end
17:58:37 <jle`> updateG t g = t { G = g }
17:58:43 <Gues> Yeah, would be cool if you could do like data R = R { getF, setF :: T, ...
17:59:07 <Gues> jle`: Oh, I remember that! That's what I wanted
17:59:16 <Gues> I meant to type F instead of T btw
17:59:39 <jle`> some of the proposals are for lens to be created instead of straight getters
17:59:57 <jle`> and with the lens, you get the getters and setters for free
18:00:06 <Gues> jle`: Oh yeah, I remember lens
18:00:12 <Gues> That's better
18:00:48 <jle`> view :: Lens' a b -> (a -> b)     -- the getter
18:01:07 <jle`> set :: Lens' a b -> (b -> a -> a)      -- the setter
18:01:19 <jle`> would be nice some day
18:01:20 <Gues> So, otherwise I still need to write (\x -> x { a = b }) right?
18:01:24 <jle`> yeah
18:01:44 <xuxu> is there much of a difference in immutability and static typing?
18:01:53 <jle`> hm, i don't think the two are related
18:02:18 <Gues> Well maybe he means like type mutability?
18:02:19 <xuxu> in the case for x = [1,2,3]
18:02:20 <jle`> java is a statically typed language, but people wouldn't consider it an "immutable language"
18:02:20 <Gues> I dunno
18:02:30 <xuxu> we can't reassign x
18:02:40 <jle`> most java programs are imperative and rely on mutation
18:02:41 <xuxu> (static typing)
18:03:01 <xuxu> the data x points to will never change, immutability
18:03:04 <xuxu> that's how i understand it
18:03:11 <jle`> you can have static typing and mutability, and you can have dynamic typing and immutability
18:03:21 <jle`> so i don't think the two are related very deeply
18:03:40 <xuxu> is there an example which demonstrates the difference between the two?
18:04:16 <suzu> static typing vs dynamic typing?
18:04:22 <suzu> or immutability vs mutability
18:04:28 <Gues> static typing means the type of a variable can't change at runtime and mutability means the value of a variable can change, right?
18:04:35 <xuxu> static typing vs immutability
18:04:37 <geekosaur> yes
18:04:38 <jle`> static typing means that your types are known at compile-time, and immutability means that your values don't mutate as side-effects ... they describe completely different things
18:04:56 <jle`> that's like asking for the difference between democracy and parakeets
18:05:00 <suzu> static/dynamic typing is not related to [imm]mutability
18:05:15 <suzu> those are both two different choice
18:05:18 <suzu> s
18:05:27 <dmwit> xuxu: Arguably, C is statically typed and mutable. e.g. `int main() { int x = 3; x = 4; }` is fine, but `int main() { int x = 3; x = &4; }` is a type error.
18:05:31 <suzu> two sets of choices *
18:05:37 <jle`> xuxu: you can have a statically typed language with mutability, and you can have a dynmically typed language with immutability
18:05:55 <jle`> the two don't care about each other
18:05:59 <suzu> ^
18:06:10 <xuxu> jle`: that's an interesting definition of immutability. i would have thought it would b "...that you values don't mutate", the side-effects bit seems to overlap with a part of purity
18:06:15 <Gues> It doesn't make sense to say a language is mutable, does it? In C or Java, variables can be mutable or immutable
18:06:30 <dmwit> xuxu: I don't know enough languages to highlight one that's dynamically typed and immutable by default. Perhaps lisp or so?
18:06:38 <suzu> what you mean to say is that the language has* mutability
18:06:42 <dmwit> Gues: That would probably be more precise.
18:06:45 <suzu> that is, the language lets you mutate things
18:06:59 <jle`> sure :)
18:07:06 <Gues> That would be every language, right?
18:07:11 <Gues> I'm confused
18:07:35 <suzu> Gues: you mean, every language has mutability?
18:07:46 <jle`> mutability only really makes sense in the context of imperative algorithms anyway, so you can write imperative algorithms in haskell that take advantage of the idea of mutation
18:07:58 <jle`> it's more a question about the style that the language encourages and common idioms
18:07:58 <dmwit> Gues: You can write a lot of programs in Haskell without touching the mutable stuff (i.e. IORef, MVar, and friends)
18:08:56 <dmwit> For the sake of argument, I could imagine defining a subset of Haskell with no mutability that would still be Turing complete and even pleasant to use.
18:08:59 <MarLinn> dmwit: I thought about mentioning Lisp too. But then they went and added mutability because monads had not been invented back then
18:09:09 <jle`> foldl is arguably an interpreter for imperative mutation-based algorithms
18:11:06 <MarLinn> You could argue that Prolog is dynamically typed with no mutable state...
18:11:18 <cspin> Clojure is dynamic and immutable too, but again it's a Lisp, and also there are exceptions
18:11:24 <suzu> strictly speaking, haskell does not have mutability
18:11:33 <dmwit> I don't think it's worth trying to find an exceptionless answer.
18:11:33 <suzu> it is not in the language
18:11:52 <MarLinn> unlambda has only one type, which is more or less the same as dynamic typing
18:12:31 <jle`> an implementation of an untyped lambda calculus reducer would probably qualify as non-statically-typed and immutable
18:12:53 <jle`> under the 
18:13:05 <jle`> same condituions in which haskell would be considered immutable
18:13:48 * hackagebot ncurses 0.2.16 - Modernised bindings to GNU ncurses  https://hackage.haskell.org/package/ncurses-0.2.16 (JohnMillikin)
18:13:58 <MarLinn> jle`, now that you mention it, GHC Core should qualify I guess
18:14:46 <suzu> core is dynamically typed?
18:16:15 <dmwit> no
18:19:00 <MarLinn> Well the type checker is deactivated by default for performance if I understood correctly
18:21:49 <ramadoka> window level ALL
18:21:52 <ramadoka> window level ALL
18:21:56 <ramadoka> sorry
18:22:14 <xuxu> str = "test"
18:22:16 <xuxu> main = do
18:22:25 <xuxu> oh, lpaste
18:22:48 <lpaste> xuxu pasted “No title” at http://lpaste.net/181211
18:23:01 <xuxu> this fails
18:23:19 <dmwit> Name the result of your computation.
18:23:34 <xuxu> i'm not trying to extend greeting
18:23:41 <dmwit> e.g. `main = do { let {newGreeting = greeting ++ " and hello"}; print newGreeting }`
18:23:44 <xuxu> i want greeting ++ " and hello" to just be computed
18:23:57 <dmwit> Okay, then look into `seq` and `deepseq`.
18:23:57 <xuxu> i don't want a new greeting
18:24:16 <dmwit> ```main = (greeting ++ " and hello") `deepseq` print greeting```
18:24:32 <dmwit> However, I am suspicious.
18:24:41 <xuxu> of what exactly?
18:24:57 <dmwit> "I want it to be computed" is counter to the usual way of doing Haskell.
18:25:03 <dmwit> *Why* do you want it to be computed?
18:25:16 <xuxu> to prove a point 
18:25:50 <xuxu> immutable data structures
18:26:10 <dmwit> I'm struggling to figure out what point you could prove with this program.
18:26:15 <xuxu> this is an example of not being to extend the data structure as you might expect coming from a language where you primarily use mutable data structures
18:26:37 <dmwit> This would show only that `(++)` doesn't change the data, not that it's impossible.
18:26:38 <xuxu> i'm open to better examples, but it's the only one i could think of
18:27:36 <xuxu> trying to teach haskell lets me know that 1. i don't really know haskell that well 2. learn the stuff i thought i handle on and 3. embarrass myself here often
18:27:41 <geekosaur> only way I can see that example being relevant is by comparison to C's strcat, and that's because C strings are dumb
18:28:26 <dmwit> Imagine opening a Python REPL, typing `x = [1,3,2]; sorted(x); print x`. You observe `[1,3,2]` from the last print. But it would be wrong to conclude that `x` is immutable.
18:28:49 * hackagebot pretty-types 0.2.1.0 - A small pretty printing DSL for complex types.  https://hackage.haskell.org/package/pretty-types-0.2.1.0 (SvenHeyll)
18:29:40 <xuxu> dmwit: that's a good point
18:30:02 <xuxu> is there a better example?
18:30:35 <dmwit> I doubt it.
18:30:59 <dmwit> You could try to show it by shadowing an old variable and showing that the shadowed version still has the same value.
18:31:11 <dmwit> But I think that would be more confusing than enlightening for new Haskell programmers.
18:31:56 <MarLinn> It's the black swan problem. How do you prove the non-existence of black swans? Just because you haven't seen one that doesn't  mean none exist
18:32:00 <ramadoka> about immutability, i think you should show that haskell raise an error, to prevent you from changing an old variable?
18:32:27 <dmwit> There is no error. There just isn't a way to change the contents of an existing value.
18:34:06 <dmwit> Oh, perhaps you are thinking of the error you get from something like `main = print x where { x = 3; y = 4; x = 5 }`.
18:34:18 <ramadoka> yeah, that's what i mean
18:34:30 <dmwit> sure
18:35:50 <dmwit> s/y = 4; //
18:36:17 <ramadoka> or, if you want to show about haskell data structure, maybe you can use the list
18:36:42 <ramadoka> like myNewList = (myValue:myOldList)
18:36:53 <ramadoka> tail myNewList == myOldList
18:38:00 <ramadoka> it'd be better if we can show that myNewList and myOldList refer to the same pointer, haha.
18:40:43 <lpaste> mniip pasted “oh but mutation is easy” at http://lpaste.net/181213
18:41:23 <MarLinn> maybe something like let { x = 3 } in let { y = x + 1; x = y `div` 2 } in print x but in a version where x actually is a fixed point at the end?
18:41:49 <glguy> "immutable? ha, watch me smash my computer with a hammer"
18:42:06 <b2coutts> clearly the answer is to show them unsafePerformIO
18:42:15 <b2coutts> this will enlighten everything
18:43:09 <xuxu> data Vehicle = Vehicle { color :: String }
18:43:17 <mniip>  > let foo = Just "foo"; > mutate foo 0 "bar"; Just "bar"; > foo; "foo"
18:43:31 <mniip>  > foo; Just "<interactive>: internal error: PAP object entered!
18:43:37 <mniip> see, all working as expected
18:44:00 <xuxu> i think there's a way to create a Porsche data type and allow it to inherit from Vehicle
18:44:05 <xuxu> i should reread about data types
18:44:07 <xuxu> i forget how to do this
18:44:17 <mniip> inherit?
18:44:51 <mniip> we don't have datatype inheritance in haskell
18:45:00 <xuxu> yeah, it's not really inheritance, it's just how i think about it
18:45:22 <Welkin> xuxu: how you think about it is wrong though
18:45:36 <Welkin> that is (p)oop
18:46:14 <xuxu> :)
18:48:20 <xuxu> maybe i'm thinking about type classes
18:49:04 <xuxu> class extension
18:49:20 <xuxu> for some reason i thought something along these lines applied to ADTs
18:53:23 <charly_> plop
18:53:50 <ReinH> I recommend trying as hard as possible to NOT think of Haskell in terms you might be familiar with from OO languages.
18:53:54 <fr33domlover> How do I export an associated data type from a module that defines a class instance? ymy data uses record syntax
18:54:08 <fr33domlover> do I have to export indivisual fields?
18:54:23 <geekosaur> X(..) ?
18:54:27 <fr33domlover> *my
18:55:43 <MarLinn> What does it mean for a field to be divisible?
18:57:55 * geekosaur took that as typo for "individual"
18:58:17 <fr33domlover> geekosaur, what is X though
18:58:32 <fr33domlover> it's an associated data type,i don't have a name for X
18:58:50 * hackagebot hasktags 0.69.2 - Produces ctags "tags" and etags "TAGS" files for Haskell programs  https://hackage.haskell.org/package/hasktags-0.69.2 (jhenahan)
18:59:19 <JonReed> Is it possible to to mtl to have an effect system with effects doing IO? For example,`(MonadSTDIO m, MonadWriteFile m) => m ()`, where MonadSTDIO has `putStrLn' :: String -> IO ()`  and MonadWriteFile has `writeFile :: String -> String > IO ()`.
18:59:58 <MarLinn> fr33domlover but you have both a class name and a type name, right?
19:00:03 <galileopy> if I have to check if a Maybe is a nothing, doesn't it defeat the whole purpose of using a Maybe?
19:00:11 <JonReed> Is it possible for mtl to have *
19:00:26 <geekosaur> oh, right. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#import-and-export
19:00:31 <geekosaur> fr33domlover, ^
19:00:34 <fr33domlover> MarLinn, geekosaur thabks it seems to work :P
19:00:40 <fr33domlover> *thanks
19:00:49 <fr33domlover> connection suddenly slow, sorry for typos
19:00:53 <geekosaur> so I was still right according to that
19:09:29 <hydraz> xuxu: You're trying to *teach* haskell?
19:10:55 <xuxu> hydraz: :)
19:11:07 <xuxu> i'm trying to work up to the point of teaching
19:11:27 <hydraz> oh that makes more sese
19:11:28 <xuxu> hydraz: just hope i never do 
19:11:44 <hydraz> sense too, stupid mobile keyboard
19:12:00 <Groot> Any of you guys know C++
19:12:00 <xuxu> i'm learning a lot coming up with what i think beginners should focus on
19:12:50 <Welkin> Groot: probably most
19:12:57 <Welkin> but this is a haskell channel
19:12:58 <hydraz> I kind of do Groot, why?
19:14:04 <Groot> Welkin: Oh i see
19:14:16 <Groot> How can i learn on this channel?
19:15:10 <Welkin> Groot: ask questions
19:15:15 <hydraz> Read whatever book people recommend nowadays, ask away any questions that come up
19:15:24 <Welkin> @where learnhaskell -- Groot 
19:15:24 <lambdabot> https://github.com/bitemyapp/learnhaskell
19:15:26 <geekosaur> why do you want to learn c++ here?
19:15:53 <Groot> I heard this was a good place to ask questions..
19:15:55 <Groot> haha
19:17:18 <Welkin> haskell questions though
19:17:43 <pavonia> Clearly Haskell programmers can teach you better C++ than C++ programmers :p
19:18:00 <Groot> Lol
19:18:10 <Groot> Gotta learn from the best
19:18:11 <alercah> Groot: ##c++ is a very good channel
19:18:24 <Groot> Okay
19:19:07 <Groot> ty
19:22:18 <suzu> i see a lot of people come here to ask cpp questions
19:22:20 <suzu> i don't get it
19:22:22 <suzu> this is #haskell 
19:22:30 <suzu> ???
19:22:42 <lispy> It's one of the biggest channels on freenode
19:22:50 <lispy> I think that has an impact
19:22:51 <suzu> oh is it?
19:22:54 <glguy> C preprocessor questions? those make sense here given how much of it ends up in .hs files
19:22:58 <suzu> i didnt know that
19:23:10 <suzu> glguy: no just like straight up cpp
19:23:26 <glguy> I don't know anyone writing just straight up c preprocessor
19:23:28 <suzu> someone was asking about abstract base classes a few days ago i think
19:23:40 <suzu> and pure virtual functions
19:23:42 <suzu> lol
19:25:08 <MarLinn> I recently discovered an old post by Conal Elliot about cpp being a functional programming language that compiles to c as its internal representation
19:25:29 <wedify> i'm doing the dailyprogrammer anagram challenge. the word file they supply has some very weird words in it
19:25:40 <wedify> like 'rees' for example
19:28:04 <wedify> oh it's the name of a bird
19:39:59 <wedify> well that challenge turned out to be a lot easier than i though it would be
19:54:17 <dmwit> C++ isn't really on-topic here, though discussions of other languages are inevitable on any programming channel, I think.
19:54:37 <dmwit> It would be obnoxious to come here specifically to ask a C++ question.
20:10:32 <galileopy> any goos starting points besides  learnyouahaskell?
20:10:44 <galileopy> s/goos/goods
20:11:00 <Cale> http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
20:11:39 <ramadoka> galileopy that's a nice method to replace what you mean haha.
20:13:43 <ramadoka> any1 know how  /set window_check_level_first ON
20:13:48 <ramadoka>  /set window_check_level_first ON
20:13:51 <ramadoka> sorry
20:20:19 <suzu> hehe
20:23:54 <Rarrikins> Are there any Haskell-like low-level languages out there? It looks like Habit hasn't gone anywhere.
20:24:48 <joe9> Which GUI library is recommended for drawing lines, curves and circles? Graphics.UI.GLUT or Cairo-gtk?
20:27:58 <c_wraith> joe9: if animation isn't necessary, I'd go with diagrams
20:28:56 <joe9> c_wraith: i render figures realtime and I also want the rendered window to be responsive to mouse events.
20:30:40 <Gues> glguy: For ReqArg, what js the second parameter? Is it a default string?
20:30:40 <joe9> c_wraith:  not sure if this is still relevant http://www.renci.org/wp-content/pub/tutorials/BeautifulCode.pdf
20:30:57 <glguy> Gues: It's documentation for the flag's argument
20:30:59 <c_wraith> Yeah, I have little idea for dealing with interactive stuff
20:31:30 <Gues> glguy: Ohh
20:35:52 <gestone> hi all, i'm currently trying to work with the persistent library and i've run into this error
20:35:55 <gestone> The type variable ‘backend0’ is ambiguous
20:36:16 <gestone> i'll post my code in a sec
20:38:12 <gestone> http://lpaste.net/181230
20:38:40 <MarLinn> joe9: Yeah, diagrams is really nice and there's an "obvious" way to extend it for interactivity via FRP. It's just not something anyone has integrated into it yet.
20:39:28 <MarLinn>  There's some half-baked animation+interactivity stuff now, but I don't think it's really suitable for anything major
20:40:10 <gestone> lines 46 and 48 are throwing the error, why is it complaining about a type variable being ambiguous?
20:40:16 <gestone> oops
20:40:29 <gestone> lines 20 and 22
20:42:19 <pavonia> gestone: You probably need to give a type annotation on what backend type should be used
20:43:23 <gestone> to which variable?
20:43:48 <joe9> MarLinn: it appears that OpenGL is the best for sizeable data (around 85k points) and Cairo is the next best. diagrams seems to have issues with scalability.
20:44:04 <joe9> MarLinn: This is just from reading up about them.
20:44:23 <joe9> MarLinn: This article seems to reiterate that too http://www.renci.org/wp-content/pub/tutorials/BeautifulCode.pdf
20:44:28 <pavonia> gestone: e.g. pool
20:44:58 <gestone> pavonia: yeah, that's what i've been trying to do
20:46:18 <MarLinn> gestone: There might be several points where the type must be added.
20:46:51 <MarLinn> gestone: from the errors it reads as if all that the functions need is information what type of queries you want to run
20:48:30 <MarLinn> gestone: I *think* Yesod solves some of this by creating ReaderT wrappers before putting the execution into IO
20:48:31 <gestone> MarLinn: yeah, i'm trying to add the SqlReadBackend type annotations everywhere
20:53:22 <MarLinn> gestone: Now that I look at it longer I think "getBy" is probably the best guess.
20:53:45 <gestone> MarLinn: should i not be using getBy?
20:53:56 <gestone> i do want to fetch an entry with a unique constraint
21:00:13 <MarLinn> gestone: I don't think getBy is wrong. It's where I would first look if I was trying to add a type signature.
21:00:40 <RiverDance> Hey, simple question: say L1 and L2 are lists. How do I properly write: zip tail L1 tail L2 ? Thanks!
21:00:54 <Gues> How do I get this to work: https://bpaste.net/show/e0e306ce930d
21:01:45 <Rarrikins> RiverDance: zip (tail l1) (tail l2) is a clear way.
21:01:47 <gestone> Gues: i think you're missing an else branch
21:02:01 <Gues> gestone: That's required?
21:02:07 <Rarrikins> RiverDance: Also, tail (zip l1 l2) is fine.
21:02:08 <gestone> Gues: yep
21:02:15 <gestone> if expr then expr else expr
21:03:10 <RiverDance> Rarrikins: feck me, thanks so much. I was messing about with '$', and it was not helping.
21:03:39 <Gues> Also, now I think return () will not exit the program
21:04:03 <gestone> MarLinn: you're right, it's not getBy. i tried using selectList instead with constraints and it returned me the same error
21:04:36 <gestone> Gues: you shouldn't need return ()
21:05:10 <Gues> I want exit :: IO () or something
21:05:21 <geekosaur> @index exitSuccess
21:05:21 <lambdabot> System.Exit
21:05:48 <gestone> :t putStrLn
21:05:49 <lambdabot> String -> IO ()
21:06:04 <gestone> putStrLn takes in a string and returns an IO ()
21:06:09 <Gues> @index exitFailure
21:06:10 <lambdabot> System.Exit
21:06:11 <gestone> main has to be type IO ()
21:06:19 <Gues> Yeah I get it
21:06:20 <geekosaur> however you can rewrite that to use if-then-else and not need an exit
21:06:28 <Gues> I thought return would exit the program
21:06:32 <geekosaur> at least, as it is right now...
21:06:45 <Gues> Now I realize I need putStrLen "bla" >> exitFailure
21:06:49 <geekosaur> return just brings a value into the monad. it doesn't do flow control
21:06:55 <gestone> ^
21:07:07 <gestone> it's not like return in other languages
21:07:15 <Gues> I get it already
21:08:10 <c_wraith> @quote stereo
21:08:10 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
21:08:21 <gestone> ah i see, you want the program to abort if there aren't two args
21:08:40 <geekosaur> @quote in.*stereo
21:08:40 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
21:08:46 <geekosaur> meh
21:09:08 <gestone> :t exitFailure
21:09:09 <lambdabot> error: Variable not in scope: exitFailure
21:10:17 <Gues> gestone: Actually 1, but I only just realized getArgs doesn't return the program name
21:10:54 <gestone> Gues: ah got it
21:11:11 <Gues> Is there a more concise way to do this? https://bpaste.net/show/9e6b7d10b51b
21:11:44 <Gues> Maybe like exitWhen :: Bool -> IO ()
21:11:56 <Gues> exitFailureWhen :: Bool -> IO ()
21:12:08 <MarLinn> gestone: songQuery :: ReaderT SqlReadBackend IO (Just Song); getSong = getBy $ UniqueSongHash "hi" ... ?
21:13:02 <MarLinn> :t when
21:13:04 <lambdabot> Applicative f => Bool -> f () -> f ()
21:13:18 <MarLinn> :t guard
21:13:20 <lambdabot> Alternative f => Bool -> f ()
21:13:34 <gestone> MarLinn: i believe that's the type sig
21:13:34 <MarLinn> Gues: ^
21:14:04 <geekosaur> when (null args) (putStrLn "no args" >> exitFailure)
21:15:26 <Gues> geekosaur: Oh, just what I wanted. Thank you.
21:15:44 <gestone> MarLinn: wait, how do i assert the type of the backend i'm using? putting the type annotation on the binding, 'pool' it throws even more errors
21:15:44 <Gues> Didn't really like the superfluous else
21:16:08 <MarLinn> Gues: or getArgs >>= \case [theArg] -> launchRocketsAt theArg; _ -> putStrLn "Usage..." >> exitFailure
21:16:30 <MarLinn> That gives you more options and clearer paths
21:17:00 <Gues> MarLinn: But then I have to make function or indent everything in main
21:17:05 * geekosaur would also use hPutStrLn stdout, but that's POSIX pedantry
21:17:08 <Gues> *make another
21:17:33 <Gues> This was just for testing, but also stderr should be used
21:17:44 <Gues> Maybe that's what you mean
21:17:46 <Gues> t
21:17:48 <geekosaur> er I meant stderr
21:17:57 <Gues> Yeah for sure
21:18:08 * geekosaur would be in bed now if his body didn't have other ideas, sigh
21:18:09 <Gues> Not really pedantry IMO
21:18:26 <Gues> I just didn't know how to do it yet
21:18:54 <Gues> So hPutStrLn is like fputs
21:19:01 <Gues> Or hPutStr
21:21:08 <Gues> So how do I get args with the program name?
21:21:20 <Gues> @index getArgs'
21:21:21 <lambdabot> bzzt
21:22:26 <lambdaislove> so deepseq on the surface seems to claim that it needs ghc-prim 0.2 but in fact that is only the case if the ghc version is low enough. problem is stack still seems to think that deep-seq needs ghc-prim
21:22:56 <lambdaislove> megaparsec on the other needs deepseq and I need to use Constraint
21:23:17 <Gues> @index hPutStrLn
21:23:17 <lambdabot> System.IO, Data.ByteString.Lazy.Char8, Data.ByteString.Char8, Data.ByteString
21:23:21 <lambdaislove> How do I get stack to play nice and allow me to use megaparsec and Constraint?
21:23:50 <MarLinn> lambdaislove: you could just use plain cabal...
21:24:03 <lambdaislove> but I like stack...a lot
21:24:15 <lambdaislove> and it's supposed to replace cabal
21:24:54 <MarLinn> no, it's not. It's supposed do either enhance or replace Haskell Platform, depending on who you ask
21:25:25 <lambdaislove> so can I use cabal *with* stack?
21:25:37 <osfameron> stack does kinda replace cabal too
21:25:46 <lambdaislove> I use stack to replace cabal lol
21:26:12 <osfameron> e.g. I raised a github issue because the stack docs are so *bad* at explaining what it's actually for... https://github.com/commercialhaskell/stack/issues/1816
21:26:54 <MarLinn> Well... stack is a layer on top of cabal. But it adds so many opinions that it can be hard to use both together
21:28:21 <pchiusano> Data.Set advertises O(n+m) for intersection... shouldn't it be closer to O(size (a `intersection` b))?
21:29:16 <osfameron> MarLinn: it uses the cabal file format, but I'm not sure if it uses the cabal *code* itself does it?
21:29:40 <osfameron> but certainly I think if you're using `stack`, they expect you to just use that
21:30:23 <pchiusano> like I would expect if I have Set.fromList [1] `intersection` Set.fromList [90..100000], it would be able to notice that the minimum element of the right side is greater than the maximum element of the left side, so the result is empty
21:30:44 <pchiusano> and likewise recursively if there is overlap
21:31:56 <MarLinn> osfameron, I'm not really sure. I just use it for Yesod because Snoyman kinda enforces that
21:32:18 <lambdaislove> so is there anyway to get stack to ignore this issue with ghc-prim
21:32:30 <lambdaislove> and just use the ghc-prim that I want it to?
21:32:43 <MarLinn> osfameron, but seeing how stack chokes if the installed version of cabal is too new, it must rely on the code somehow
21:33:51 <geekosaur> lambdaislove, you can't use a different ghc-prim
21:34:10 <geekosaur> it's accessing runtime internals. it *must* be the exact one that comes with the ghc runtime
21:34:21 <geekosaur> you replace it by installing and using a different ghc version
21:34:22 <lambdaislove> geekosaur: it isn't though
21:34:35 <osfameron> MarLinn: ah ok, fair enough
21:34:38 <lambdaislove> it only even imports ghc-prim if the ghc version is less than 7.6
21:34:43 <lambdaislove> I'm using 7.10
21:37:51 <geekosaur> does that include any dependencies that might use it? because if the version constraints are specified correctly and ghc-prim is not needed with ghc-7.10 at all then you should not be having a problem
21:38:13 <MarLinn> lambdaislove: Are you sure stack doesn't force the "package local" version of ghc to something different?
21:39:12 <gestone> wow, persistent should update their docs to have their examples comply to their changes they put out in their newest version x_x. that would have saved me a lot of time
21:39:16 <lambdaislove> geekosaur: no because deepseq appears to be *really* outdated on hackage. I can't go back far enough to make sure it works
21:39:42 <geekosaur> uh
21:39:47 <geekosaur> lose the deepseq dependency
21:39:48 <lambdaislove> sorry I was reading stuff wrong
21:39:53 <geekosaur> it's in base
21:40:06 <lambdaislove> deepseq only imports ghc-prim if ghc version is less than 7.6
21:40:06 <geekosaur> which is why the one on hackage is old; it's only needed with very old ghc
21:40:32 <lambdaislove> I somehow got base and array verion numbers confused so disregard that statement. sorry.
21:41:27 <lambdaislove> yea deepseq only uses ghc-prim in a very specific case that dosn't apply to me
21:41:50 <geekosaur> um
21:42:15 <lambdaislove> GHC.Generics used to be in ghc-prim apprently
21:42:28 <geekosaur> so I just looked and, while megaparsec does depend on deepseq, the deepseq on hackage is 1.4.2.0 from April of this year
21:42:30 <lambdaislove> so ghc-prim is a conditional dependency to account for that
21:42:51 <lambdaislove> yea I was wrong about deepseq being out of date
21:43:19 <lambdaislove> I got version numbers confused and though it depended on base 0.6 not array 0.6
21:43:36 <geekosaur> possibly capture the whole dependency output and lpaste it
21:43:38 <geekosaur> @lpaste
21:43:38 <lambdabot> Haskell pastebin: http://lpaste.net/
21:44:06 <lambdaislove> https://hackage.haskell.org/package/deepseq-1.4.2.0/dependencies
21:44:09 <lambdaislove> that's it
21:44:38 <geekosaur> no, I mean for your project that is getting the dependency conflict
21:45:17 <lambdaislove> oh my bad
21:46:30 <lambdaislove> http://lpaste.net/181239
21:46:57 <geekosaur> and I meant stack's solver output
21:47:14 <lambdaislove> sure sorry
21:47:59 <lambdaislove> it will take a bit, it's building I guess
21:48:27 <geekosaur> hm. does that mean the problem is now fixed?
21:48:30 <lambdaislove> no
21:48:34 <lambdaislove> just got the error
21:48:41 <lambdaislove> I was just telling you why it was taking so long
21:48:42 <saurabhnanda> well then, 800% speed-up in yesod benchmarks -- https://gist.github.com/saurabhnanda/6f3e7afd5c7153e72b0f5ab599346090
21:50:54 <lambdaislove> http://lpaste.net/181239
21:51:08 <gestone> MarLinn: i finally resolved the issue, i couldn't add a type annotation to 'pool', but the query itself like you mentioned
21:51:25 <lambdaislove> eh wait now the error seems to be about array
21:51:38 <geekosaur> o.O
21:51:46 <gestone> MarLinn: i had to specify the type annotation as: checkSong :: String -> String -> ReaderT SqlReadBackend (NoLoggingT (ResourceT IO)) (Maybe (String, String))
21:51:49 <gestone> what a mess
21:52:14 <geekosaur> this looks like exactluy the kind of conflict stack was supposed to *prevent*
21:52:14 <gestone> i had to import two packages to get access to NoLoggingT and ResourceT
21:52:41 <lambdaislove> yea let me look at this one
21:52:43 <MarLinn> gestone: Yeah, that looks just as intuitive as I remember from that package
21:52:44 <geekosaur> oh, hm. so you have a broken array package registered somewhere
21:52:46 <lambdaislove> this might just be valid
21:52:53 <geekosaur> stack exec ghc-pkg check
21:53:13 <gestone> *sigh* haskell is great and all, but i really wish the docs were more up to date
21:53:19 <lambdaislove> I get a crap ton of warnings when I run that
21:54:00 <geekosaur> it will probably spit a bunch of warnings about missing documentation, but there will be something more in there. lpaste it...
21:54:19 <MarLinn> gestone: persistent looks great when you see the TH side, but when it gets to coding... ehh... it's why I'm trying out opaleye instead
21:54:41 <Rudes> i'm using cabal and i gave cabal the hs-source-dir flag but it doesn't cascade into the folders it should be like src/Test/Test.hs but it just stops at src
21:54:44 <lambdaislove> http://lpaste.net/181241
21:55:25 <geekosaur> Rudes, if hs-source-dir is src then src/Test/Test.hs is for a module Test.Test
21:55:40 <gestone> MarLinn: lol i switched from opaleye to persistent because i couldn't understand the opaleye docs
21:55:47 <Rudes> geekosaur: yes and i gave it the exposed-modules flag for Test.Test
21:56:10 <Rudes> geekosaur: it actually says "can't find source for Test/Test"
21:56:34 <MarLinn> gestone: Lol. For persistent documentation you can also look into the Yesod docs.
21:57:15 <geekosaur> lambdaislove, interesting, it's not showing array in there at all. so why is it finding an array package that is broken...
21:57:42 <lambdaislove> I don't know what this black magic is. Let me do a clean restart real quick
21:57:56 <lambdaislove> well let me clean and then make a new stack project
21:57:57 <geekosaur> in any case you seem to vbe getting into deeper areas of stack than I can help with; I'd have expected it to not have this problem in the first place
21:58:11 <geekosaur> Rudes, lpaste your cabal file?
21:58:13 <geekosaur> @paste
21:58:13 <lambdabot> Haskell pastebin: http://lpaste.net/
21:58:46 <geekosaur> oh, hm, array is in there, but presumably not the broken one (sadly it does not show the abi hash)
21:59:03 <MarLinn> gestone: The packages from that direction (persistent, yesod, stack) seem all to be documented *somewhere*. Wikis, books, stackage, github repos, stack overflow... but good luck finding out *where* in all the mess
21:59:06 <geekosaur> but of it were the "missing or broken package" then it should have said what was missing
22:00:02 <Rudes> geekosaur: yeah, it'll take a min my copy/paste is broken, lol
22:00:42 <geekosaur> also I think the first complaint there is that you have two installed versions (same version number, differnet abi hash) of deepseq; pretty wants one of them, tagged wants the other
22:00:48 <gestone> MarLinn: yeah, i honestly would love to do work on improving these docs and the haskell ecosystem overall
22:01:17 <geekosaur> which, again, is something stack was supposed to *prevent* (by, if necessary, rebuilding pretty with the same deepseq that tagged is using)
22:01:28 <geekosaur> so you may have a stack bug report in the making here
22:01:44 <gestone> i would write a blog post after finishing my project, but i think there are too many blog posts highlighting people's experiences with haskell :P
22:02:22 <lpaste> Rudes pasted “cabal_source_dirs” at http://lpaste.net/181244
22:02:34 <Rudes> geekosaur: ^
22:02:56 <gestone> alas, i also feel too inexperienced with this language to make a big impact yet
22:03:04 <lambdaislove> geekosaur: I'll try recreating the error and if make it happen again I'll report it
22:03:09 <Rudes> gestone: same
22:03:31 <MarLinn> gestone: on the one hand it would be nice to have one central resource. Say eg. hackage could have a comments/rating/user-supplied docs section for each package
22:03:50 <geekosaur> is that Network.HTCPCP.Pot the Test/Test you were talking about?
22:04:00 <Rudes> geekosaur: yeah
22:04:08 <geekosaur> if so, then you wanted hs-source-dirs: .
22:04:13 <gestone> MarLinn: ah that'd be awesome
22:04:17 <geekosaur> or the module name should be HTCPCP.Pot
22:04:20 <Rudes> and the file structure is Network/HTCPCP/Pot.hs
22:04:31 <geekosaur> or it should be Network/Network/HTCPCP/Pot.hs
22:04:38 <Rudes> OH
22:04:44 <Rudes> i see how it reads now, thanks
22:05:32 <MarLinn> gestone: On the other hand that could lead to more politics and fighting. One of our strengths is distribution. Many channels, many small libraries, many individuals vs. few companies.
22:06:11 <MarLinn> gestone: I feel that the bigger our community gets the more some people want to get control over central parts
22:06:31 <gestone> MarLinn: has our community been expanding in recent years?
22:06:51 <MarLinn> gestone: I have no numbers, but it feels like it
22:07:12 <geekosaur> hackage has a ratings system of sorts, not that anyone uses it much (see "Votes")
22:07:13 <MarLinn> gestone: or maybe we just get more professional people using it
22:07:37 <gestone> MarLinn: how do the more popular languages handle this issue?
22:08:18 <MarLinn> geekosaur: I suppose there might be a UI problem then...
22:08:27 <geekosaur> the Haskell community breaks in three different directions: open source, open commercial (fpcomplete, well-typed, galois), closed commercial (facebook until recently, several large financial firms)
22:08:33 <lambdaislove> geekosaur: fresh stackage project with those dependencies gives the same error, where do I report this?
22:09:06 <geekosaur> https://github.com/commercialhaskell/stack/issues
22:09:39 <geekosaur> they'll likely want that stack exec ghc-pkg output from earlier, and maybe a plain ghc-pkg check (without the stack exec)
22:10:40 <hiptobecubic_> Today, suddenly, I cannot build anything at all with stack. Linker errors all over the place. 
22:10:44 <MarLinn> gestone: I don't know, I'm not nearly as involved in them as here. They're not Haskell, after all ;)
22:11:26 <hiptobecubic_> e.g.: /usr/bin/ld: /usr/lib/ghc-7.10.3/base_HQfYBxpPvuw8OunzQu6JGM/libHSbase-4.8.2.0-HQfYBxpPvuw8OunzQu6JGM.a(PrelIOUtils.o): relocation R_X86_64_PC32 against symbol `__errno_location@@GLIBC_2.2.5' can not be used when making a shared object; recompile with -fPIC
22:11:31 <gestone> MarLinn: hah indeed. what got you interested in haskell?
22:12:18 <geekosaur> mrr. been hearing about that error of late, don't know cause or fix offhand
22:13:57 <MarLinn> gestone: We used it as our "first" language in uni, together with Java. Caught a bug, I guess...
22:15:12 <gestone> MarLinn: ah yeah we used in uni as well for a basic PL class. we built a lisp interpreter and i've been hooked on haskell ever since
22:17:40 <MarLinn> Ah, the classic project XD
22:20:32 <lambdaislove> geekosaur: if your interested I posted it here https://github.com/commercialhaskell/stack/issues/2539
22:24:57 <gestone> does haskell have any nice string intrpolation libs?
22:25:29 <gestone> i'm a little tired of having to do ++ or <> to concat my strings
22:25:42 <johnw> gestone: there are actually many
22:26:10 <gestone> johnw: is there one in particular you recommend?
22:26:21 <johnw> they range from really fancy (say, shakespeare) to quite simple (here)
22:27:09 <johnw> I think each of the big web frameworks has its own related library that it prefers
22:28:26 <gestone> ah i see that yesod uses shakespeare
22:30:06 <osfameron> there's a Mustache library which looks promising
22:30:12 <gestone> completely unrelated, but are classes in haskell like interfaces in java?
22:30:26 <Cale> gestone: More or less
22:30:34 <atoll> Hello, something I'm not sure about learnyouahaskell: data Frank a b  = Frank {frankField :: b a} deriving (Show)  It says we assume a has kind *. Can someone explain to me why that ?
22:30:47 <MarLinn> gestone: shakespeare also has a "plain text" part
22:30:49 <atoll> I mean it could be anything right ?
22:31:13 <gestone> MarLinn: oh? not just for html/css/etc templating
22:31:14 <Cale> atoll: Yeah, but Haskell 98 doesn't have kind polymorphism, so any ambiguous kind variables get defaulted to *
22:31:26 <gestone> osfameron: ah i'll check it out
22:31:41 <atoll> Cale: is there something more recent than haskell 98 ?
22:31:45 <atoll> (also thanks)
22:31:49 <gestone> haskell 2010
22:32:03 <dmwit> I would bet Haskell 2010 also defaults to *.
22:32:04 <Cale> atoll: Well, there's Haskell 2010, but it's practically the same thing, to the extent that I don't even bother distinguishing it
22:32:13 <dmwit> But GHC has an extension to turn it off. KindPolymorphism, I think.
22:32:28 <atoll> so in haskell 2010, what would be the kind of a and by extension b ?
22:32:38 <MarLinn> gestone: yeah, including TH. But your guess is as good as mine where I found the documentation for that... Maybe the yesod book again
22:32:41 <Cale> Haskell 2010 is the same as 98 in this regard.
22:32:45 <dmwit> a :: *, b :: * -> *
22:33:02 <atoll> What if it had kind polymorphism ?
22:33:12 <dmwit> a :: k, b :: k -> *
22:33:19 <gestone> MarLinn: *sigh* i feel like compiling a list of resources just so others don't have to go through this same pain x_x
22:33:31 <dmwit> (because fields must have types of kind *)
22:33:39 <Cale> @let data Frank a b  = Frank {frankField :: b a} deriving (Show)
22:33:41 <lambdabot>  Defined.
22:33:45 <Cale> :k Frank
22:33:45 <mniip> dmwit, PolyKinds
22:33:46 <atoll> Is k a power of * -> * ?
22:33:46 <lambdabot> k -> (k -> *) -> *
22:34:00 <dmwit> mniip: I'm aware, thanks. Please read the rest of the conversation.
22:34:01 <Cale> k is any kind at all
22:34:10 <atoll> Oh ok
22:34:13 <dmwit> mniip: ...oh, wait
22:34:16 <Cale> The user of the type gets to decide what kind they want k to be
22:34:16 <dmwit> mniip: I apologize.
22:34:18 <atoll> thanks a lot!
22:34:20 <dmwit> mniip: I misunderstood you.
22:34:35 <atoll> damn haskell is pretty
22:34:38 <atoll> coming from scala
22:34:41 <mniip> was a correction to "KindPolymorphism" which is not an extension
22:34:46 <gestone> atoll: lol that's what i said
22:34:56 <dmwit> Right. I'm sorry for misinterpreting you and getting pissy about it. =(
22:35:00 <dmwit> I think I will go to bed.
22:35:02 <atoll> where ?
22:35:03 <Cale> {-# LANGUAGE ExtensionSynonyms #-}
22:35:05 <Cale> ;)
22:35:07 <MarLinn> gestone: Let's make a (yesod based?) website where one can search through a crowd-sourced database of documentation links ;)
22:35:46 <Cale> atoll: Where what?
22:36:01 <gestone> MarLinn: hah. i would be up for the challenge
22:36:20 <atoll> "22:34:21   gestone | atoll: lol that's what i said"
22:38:00 <gestone> MarLinn: it'd be cool if people could also just paste in their errors and it would point them to the right docs
22:38:23 <gestone> MarLinn: stackoverflow + google isn't cutting it for me
22:38:30 <gestone> MarLinn: for the common ones at least
22:38:36 <mniip> Cale, {-# LANGUAGE PragmaKinds #-}
22:39:56 <Cale> :p LANGUAGE
22:40:03 <Cale> Sequence Extension -> Pragma
22:40:55 <MarLinn> gestone: matching language extensions against ghc versions might be nice, too, so you can adopt to your expected user base
22:43:14 <gestone> MarLinn: ohh yeah that would be really nice. yeah, i'd actually want to work on this project, but i don't know if i have enough experience or knowledge of the overall haskell ecosystem where i could actually make something useful for the community
22:43:49 <MarLinn> newtype Pragma Extension = Pragma String (Preprocessor Extension)
22:43:59 <MarLinn> data Pragma Extension = Pragma String (Preprocessor Extension)
22:46:45 <MarLinn> gestone: Well, I have some other Haskell web projects right now. If I can manage to finish those I should have the basic knowledge for something like that. I'll get back to you then?
22:47:27 <gestone> MarLinn: yeah, of course i'd be up for collaborating on the project
22:47:55 <MarLinn> gestone: We're gonna save the world! Or something. XD
22:48:38 <gestone> MarLinn: :D and hopefully getting more people on board with haskell
23:20:03 <saurabhnanda> I'm trying to add Yesod-postgres benchmarks to Techempower. Stuck with the fortune benchmark. Problem explained at https://gist.github.com/saurabhnanda/48a65b6eb38162e8b792f04320ee37e0 -- can anyone help?
23:32:14 <saurabhnanda> anyone with some free time to look into the benchmarks problem?
