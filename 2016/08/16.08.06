00:08:21 * hackagebot PPrinter 0.0.3 - A generic derivable Haskell pretty printer  https://hackage.haskell.org/package/PPrinter-0.0.3 (iamzhenyi)
00:38:23 * hackagebot PPrinter 0.0.4 - A generic derivable Haskell pretty printer  https://hackage.haskell.org/package/PPrinter-0.0.4 (iamzhenyi)
00:41:00 <edwardk> Note to self: Don't try to organize anything in Cuba ever again.
00:44:29 <bydo> story!
00:49:25 <edwardk> bydo: got invited to give a talk in cuba, invited a bunch of folks to give talks with the help of local organizers, had conference cancelled 3 days out from the start of the conference with no indication it was going to be a problem, long after a dozen folks have already bought tickets and booked hotels in a non-refundable fashion
00:49:57 <edwardk> so now you have a bunch of people who aren't sure if they can even legally fly into cuba, and even if they can, the conference is cancelled
00:50:12 <edwardk> so its a hell of a lot of uncertainty for 3 days before a conference
00:50:42 <edwardk> unless i hear more i'm just going to cut my losses
00:51:17 <bydo> yeah, legality of that is probably even more fun if the event you said you were going to isn't real anymore
00:51:40 <edwardk> this made an appreciable dent in my slush fund for travel for the year, and i get nothing to show for it.
00:51:50 <edwardk> not to mention all the folks i talked into going
00:52:11 <edwardk> i just don't see the sense in it
00:54:11 <edwardk> i'm getting radio silence from the organization on the ground there, so i'm thinking it was some random government official who decided to pull the plug
00:55:22 <edwardk> but if so, all it does is slit the throat of the cuban FP community, because after this, I don't know how many folks would be willing to just randomly travel down on their own dime to give talks if this kind of crap will get pulled
00:56:25 <edwardk> we have folks flying in from Europe, all over
00:56:29 <bydo> I'd expect that to generalize to other programming confs, but yeah esp FP 
00:57:19 <edwardk> it just took something that was going to be a fun net positive experience for all involved with zero downside to something that has no upside
01:03:47 <ggole> That sure sounds fun. I suppose there's no time to redirect to another location.
01:04:00 <rabbi1> what type of file is 'routes' in yesod ?
01:05:15 <edwardk> ggole: not with everyone having long since booked tickets into cuba
01:05:30 <edwardk> and with entry requiring a local visa with a reason for going
01:06:17 <edwardk> i don't know if it is a 'cuban government said no' situation or something silly like they lost the venue, since nobody is talking to me.
01:06:26 <ggole> I was thinking somewhere in the southern US, but that would come with its own issues
01:06:36 <edwardk> if its the latter, then we might be able to get folks to show up and just do something less formal
01:06:53 <edwardk> if its the former, then things are even messier
01:07:23 <edwardk> ggole: well, for instance both bartosz and i are flying into cuba from mexico
01:07:51 <edwardk> so adding some random venue in the south of the us just adds more expense, another hotel stay, more flights, etc.
01:07:57 <edwardk> it might as well be an entirely different event
01:08:07 <edwardk> and on 3 days notice, the flights would be ridiculous
01:09:27 <ggole> Yeah :(
01:10:34 <edwardk> mostly just annoyed that i decided to do this rather than nara
01:11:17 <edwardk> oh well
01:11:44 <edwardk> going to go get some sleep and head back to hac boston
01:17:21 <wagle> how do you convert a String to a Data.ByteString.Lazy.Internal.ByteString?
01:20:55 <pavonia> via Data.Text.Encoding
01:21:19 <edwardk> or via the Data.ByteString.Lazy.Char8 combinators
01:21:34 <edwardk> depending on how fancy of a locale you want to support
01:27:43 <wagle> reading json off the web, trying to aeson'ize it
01:28:09 <hongminhee> What should I do if I want to build my package with -static link option using stack build command?
01:28:54 <dramforever> hongminhee: change/set ghc-options in the relevant executable section in your whatever.cabal
01:29:14 <dramforever> You *might* want to have -optl-static too, depending on your use case
01:33:24 <hongminhee> dreamseeker: thanks!
01:37:34 <vaibhavsagar> wagle: Data.ByteString.UTF8 has `fromString` and Data.ByteString.Lazy has `fromStrict`
01:37:53 <vaibhavsagar> so you could do fromStrict . fromString
01:38:16 <wagle>     • Couldn't match expected type ‘Data.ByteString.Lazy.Internal.ByteString’
01:38:16 <wagle>                   with actual type ‘Data.ByteString.Internal.ByteString’
01:38:16 <wagle> is my current error, but you might have answered it
01:38:38 <vaibhavsagar> actually, there is also Data.ByteString.Lazy.UTF8
01:38:50 <vaibhavsagar> http://hackage.haskell.org/package/utf8-string-1.0.1.1/docs/Data-ByteString-Lazy-UTF8.html
01:42:02 <wagle> coolio! now I can sleep (it works)
01:42:57 <wagle> thanks vaibhavsagar
01:43:09 <vaibhavsagar> glad I could help
01:46:07 <wagle> thanks to pavonia and edwardk too, it just took me a while to connect the dots
01:53:10 <aloiscochard> tnks: how does that differ than a multi-project cabal? or you mean even different cabal file? there is the concept of "workspace", which mean that it will take tags from "sibbling" folder
01:53:27 * hackagebot htestu 0.1.0.0 - A library for testing correctness of pseudo random number generators in Haskell.  https://hackage.haskell.org/package/htestu-0.1.0.0 (DominicSteinitz)
02:18:22 <vaibhavsagar> what does (flip -) do?
02:18:29 <vaibhavsagar> :t (flip -)
02:18:30 <lambdabot> Num ((a -> b -> c) -> b -> a -> c) => ((a -> b -> c) -> b -> a -> c) -> (a -> b -> c) -> b -> a -> c
02:18:51 <alercah> you might be confusing it with (flip (-))
02:19:08 <alercah> (flip -) is a section: it applies (-) to flip
02:19:16 <vaibhavsagar> no, I was explaining the difference over at #haskell-beginners
02:19:21 <alercah> ohh
02:19:25 <vaibhavsagar> I see
02:19:36 <alercah> note the constraint in the type
02:19:51 <alercah> since
02:19:54 <alercah> :t (-)
02:19:55 <lambdabot> Num a => a -> a -> a
02:20:12 <alercah> it doesn't immediately lead to a unification failure, but it does require that unusual Num instance to exist to work
02:20:48 <vaibhavsagar> that's really interesting
02:20:51 <vaibhavsagar> thanks alercah
02:21:12 <mauke> :t (-) flip
02:21:13 <lambdabot> Num ((a -> b -> c) -> b -> a -> c) => ((a -> b -> c) -> b -> a -> c) -> (a -> b -> c) -> b -> a -> c
02:22:04 <vaibhavsagar> trippy
02:24:45 <vaibhavsagar> how can a function be a Num?
02:25:01 <alercah> if someone write an instance for it
02:25:21 <alercah> for instance, someone's written an instance of Num that lets you operate numerically on numeric functions, like you see in math
02:25:30 <alercah> I don't know if lambdabot has it loaded right now
02:25:37 <alercah> > (sin + cos) 4
02:25:39 <lambdabot>      No instance for (Show a0)
02:25:39 <lambdabot>        arising from a use of ‘show_M727457897212589458432022’
02:25:39 <lambdabot>      The type variable ‘a0’ is ambiguous
02:25:53 <alercah> > (sin + cos) 4 :: Float
02:25:54 <lambdabot>      No instance for (Num (Float -> Float))
02:25:55 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
02:25:55 <lambdabot>        arising from a use of ‘+’
02:25:58 <vaibhavsagar> right, like that automatic differentiation library?
02:26:15 <alercah> possibly? I don't know
02:26:19 <alercah> I've only seen it used in here
02:26:40 <vaibhavsagar> https://hackage.haskell.org/package/ad
02:26:49 <vaibhavsagar> of course it's written by edwardk
02:27:06 <alercah> https://wiki.haskell.org/Num_instance_for_functions
02:33:21 <mauke> for all applicatives F, there's an instance (Num a) => Num (F a)
02:33:33 <mauke> ((->) e) is Applicative
02:39:37 <meditans> hi all, I have a question: does ghc use the standard cpp or the cpphs clone in his internal processing?
03:31:54 <liste> meditans: it uses standard cpp by default
03:33:24 <meditans> thanks liste!
03:43:46 <sphinxo> Say I have an data structures like this http://lpaste.net/6236822422562013184
03:44:14 <sphinxo> How can I best calculate  the total value of the Black and White sides
03:45:08 <sphinxo> I was thinking concat to flatten the list of lists and then fold, accumulating the scores as you go
03:45:50 <thewormkill> that's certainly one possibility, but you could also concat and partition by color and then simply use sum . map value
03:46:03 <sphinxo> ooh
03:46:44 <mheinzel> Reminds me of the haskell bot I wrote for university once.
03:47:27 <mheinzel> The types looked pretty much the same, except for using an Array Position Square instead of [[Square]]
03:47:47 <DzyubSpirit> f
03:49:01 <mheinzel> It had some pretty ugly parts (e.g. move generation, where the pawns are kind of annoying), but was a lot of fun.
03:49:39 <mheinzel> Especially the min-max/negamax algorithm.
03:50:02 <mheinzel> You can play against it here: http://ec2-52-59-255-84.eu-central-1.compute.amazonaws.com/
03:50:46 <mheinzel> (it does not consider castling and en passant)
03:50:52 <sphinxo> oh that's really cool
03:51:19 <mheinzel> I should maybe tidy up the code a bit and put it on github.
03:52:11 <mheinzel> I will probably be ashamed by some parts of it, though. Looking at code you wrote a while ago is a strange feeling.
03:54:55 <sphinxo> I've always felt that being ashamed of old code is actually a good thing - it shows you're improving
03:55:03 <mheinzel> Yes, definitely.
03:55:56 <thewormkill> also has the interesting property of extending NIH to code you've written yourself
03:56:10 <mheinzel> NIG?
03:56:13 <mheinzel> *NIH
03:56:33 <thewormkill> not invented here
03:57:19 <thewormkill> https://en.wikipedia.org/wiki/Not_invented_here
03:58:28 <mheinzel> Oh yeah. Working in your own codebase or some else's is very different.
03:58:34 * hackagebot desert 0.1.0.0 - a simple build tool for OCaml projects  https://hackage.haskell.org/package/desert-0.1.0.0 (zjhsdtc)
04:01:33 <mheinzel> My personal project want-to-do list is dominated by Haskell at the moment.
04:02:52 <mheinzel> I'm so glad about the upcoming semester break.
04:16:06 <sphinxo> Hows this? http://lpaste.net/1771952671373131776
04:18:36 <sphinxo> oh forgot the sum, should be join (***) (sum . map (value . piece)) . partition team . catMaybes . concat
04:20:06 <maerwald> it's not particularly readable to me, especially join (***) asks for obfuscation contest
04:20:39 <sphinxo> oh ok
04:21:10 <mheinzel> team (Piece _ colour) = colour == White ?
04:21:32 <sphinxo> otherwise perhaps?
04:21:48 <sphinxo> oh wait yeah
04:21:50 <sphinxo> no guards
04:22:02 <sphinxo> how better should I map over a tuple?
04:23:26 <mheinzel> You can always spell it out explicitly. Might be a bit more verbose, but does not require the reader to knw ***
04:24:07 <maerwald> yeah, don't try to be too smart
04:24:32 <mheinzel> let values = map (value . piece)
04:24:48 <mheinzel> \(ws, bs) -> (values sw, values bs)
04:25:47 <sphinxo> ok yeah that's much cleaner
04:27:07 <mheinzel> What are your plans for this project? Writing a simple chess engine?
04:27:13 <sphinxo> mheinzel: yup
04:28:27 <mheinzel> I thought about writing a very simple one (based on my knowledge from last time) over the course of a few blog posts.
04:28:57 <sphinxo> I think a lot of people might be interested in that
04:29:14 <mheinzel> And then, you can write about a lot of topics as a follow-up
04:29:42 <mheinzel> Optimisation by unboxing and strictness, Parallelization, ...
04:29:52 <sphinxo> you'd be covering a lot of ground
04:30:20 <mheinzel> Yes. It's a non-trivial but still kind of simple program.
04:31:09 <mheinzel> Well, but first I'd need to set up my website. Probably using Hakyll and Servant.
04:33:53 <mheinzel> Servant is really nice for creating server-side APIs. You can just have some APIs like the chess bot and serve anything else statically from your file system. It was very easy to set up.
04:37:35 <connor__> hello hello
04:38:04 <mheinzel> hi
04:39:05 <connor__> oh hey, someone replied! :)
04:41:24 <cocreature> don’t be offended if people don’t reply. if 1410 people start greeting every person who joins this channel it would get way too noisy
04:42:33 <connor__> thats true. Its just I haven't found a server with people who have responded before, until now.
04:43:48 <connor__> I've been frantically researching about irc since I saw it used in a Mr. Robot episode.
04:44:00 <Iceland_jack> Welcome connor__!
04:45:15 <connor__> Hello Iceland_jack! :)
04:45:58 <maerwald> connor__: most IRC channels have a topic. Smalltalk can be a lot of noise in crowded channels, which is why there exist offtopic channels for that.
04:50:21 <avi__> hey
04:50:30 <avi__> shambhavi Mishra
04:50:34 <avi__> this will be
04:50:35 <avi__> fun
04:50:42 <avi__> its really "Dope"
04:51:20 <connor__> maerwald: I see, well that's understandable. Thanks for the info :)
04:57:25 <avi__> Mr Robot s02 e05. Thats how I got interested in IRC.
04:58:01 <connor__> REALLY?? Thats exactly how I got interested in IRC!!
04:58:22 <avi__> Yeah. 
04:58:30 <avi__> FTP in 1hour
04:58:35 <connor__> Thats awesome! :)
04:58:38 <magneticduck1> connor__: sometimes the topics don't give the whole story -- for example, #programming is in fact a channel devoted to anime, Australian politics and wind turbine maintenance
04:58:38 <avi__> fk yes. youre the best.
04:58:41 <avi__> lol
04:58:56 <connor__> magneticduck1: I see, thanks :)
04:59:09 <connor__> avi__: omg i love you
04:59:18 <magneticduck1> programming discussions are usually directed to ##anime
04:59:40 <connor__> magneticduck1: thats anime for ya xD
04:59:54 <connor__> www.whoismrrobot.com
05:00:24 <magneticduck1> there are 110 users in #mrrobot, you should probably head there
05:00:47 <connor__> magneticduck1: thats a good point
05:01:02 <connor__> how many users are in #haskell though?
05:01:54 <magneticduck1> you should find that part of your client's interface; currently there are 1412
05:02:52 <connor__> I am using irssi
05:02:58 <maerwald> connor__: do you have questions about the haskell programming language?
05:03:05 <avi__> me too
05:03:10 <avi__> irssi
05:03:15 <magneticduck1> (we should move this somewhere else)
05:03:15 <avi__> on kali
05:03:18 <maerwald> this channel is not about irssi or general IRC questions
05:03:47 <connor__> maerwald: not exactly
05:03:51 <zort> I'm trying to parse a large binary format. I don't really know what I'm doing. This is what I've got: http://slexy.org/view/s21xHozEfF It works, but I was hoping I could use generics like this guy did so I don't have to write getInt32le <*> getInt32le <*> getInt32le <*> ...: https://github.com/gitfoxi/Stdf/blob/WIP/Data/Stdf/Types.hs The difference in my case is that I have bytestring fields (longest one 4*1622207 bytes). Can I
05:03:51 <zort>  somehow encode that huge length statically in the type?
05:04:21 <connor__> avi__: you know who else uses Kali Linux?
05:05:09 <magneticduck1> connor__: please, let's find another channel
05:05:34 <magneticduck1> (the one I mentioned should do fine, type /join #mrrobot)
05:05:57 <Nycatelos> connor__: try /join #da7Q_9RnPjm
05:06:01 <lyxia> zort: your code snippet does not exist anymore
05:06:13 <connor__> magneticduck1: will do
05:06:26 <avi__> I want to discuss A certain malware im trying to build in python
05:06:36 <avi__> recommend a channel?
05:06:55 <magneticduck1> rofl, mr robot fans are not putting on a good show
05:07:10 <zort> http://slexy.org/view/s2PMR1d92l
05:09:27 <magneticduck1> zort: have you looked into, say, serialization libraries that might auto-derive serialization from a type definition?
05:09:43 <zort> yeah I don't really understand them
05:09:55 <lyxia> binary already has such support AFAICT
05:11:14 <zort> magneticduck1: also I need a type definition of 1622207 bytes
05:11:37 <zort> looks like in fixed-vector that would be 
05:11:53 <zort> Vector (S (S (S ... Z)...) Int8
05:12:03 <zort> S written 1622207 times
05:12:15 <magneticduck1> heh, don't use peanos for those sorts of numbers ^^
05:12:21 <magneticduck1> Haskell does have type-level literals
05:12:40 * magneticduck1 looks for API
05:13:07 <zort> s/bytes/words/
05:13:20 <lyxia> I don't know what would be appropriate for fixed length bytestring. :/
05:13:56 <magneticduck1> the things I'm finding are more related to low-level FFIs and high performance arrays
05:14:23 <magneticduck1> besides some type unsafety, is there any downside to just reading that number of words into a bytestring for your case? 
05:14:39 <zort> yeah then I presume I can't auto-derive serialization
05:15:26 <magneticduck1> you could make a wrapper type holding a bytestring along with a type-level literal, and define serialization for it manually
05:15:39 <magneticduck1> I .. believe that should work without too much headache
05:16:44 <zort> ok let me see
05:17:37 <haskell-question> I am using encode from aeson to create JSON. But Javascript receives quotes as '&quot;
05:18:23 <magneticduck1> haskell-question: inside string literals, presumably?
05:18:47 <magneticduck1> that doesn't make sense either way though
05:19:07 <iphy> how would you test for approximate Double equality in hspec?
05:19:57 <haskell-question> magneticduck1:   {'key': value}  becomes {&quot;name&quot;:value}
05:20:18 <haskell-question> *{&quot;key&quot;:value}
05:20:53 <Eduard_Munteanu> haskell-question, well, did you name the field "'key'"?
05:21:11 <Eduard_Munteanu> If so, it looks like the right outcome.
05:22:09 <haskell-question> I'm generating JSON from a data declaration
05:22:32 <Eduard_Munteanu> haskell-question, how did you define the ToJSON instances?
05:23:17 <haskell-question> I just used the DeriveGeneric extension
05:23:30 <Eduard_Munteanu> haskell-question, and what's the field's name in Haskell?
05:25:05 <haskell-question> Eduard_Munteanu: It's called key
05:26:44 <Eduard_Munteanu> haskell-question, are you checking in a browser? I'm thinking perhaps your server does something odd to the encoding.
05:27:54 <haskell-question> Yup, I console logged the json I receive. Any ideas on how to debug this?
05:28:39 <Eduard_Munteanu> haskell-question, look at the MIME type of your request/response, perhaps it's mistakenly sending JSON as HTML.
05:29:22 <Eduard_Munteanu> If you're using Yesod, you simply need your handlers to return an aeson Value, no encode needed.
05:30:08 <haskell-question> I'm using happstack. I'll check the MIME type then
05:32:12 <haskell-question> Eduard_Munteanu: bingo! It was sending in HTML
06:00:04 <mheinzel> I have an ConT _ (StateT _ _) _
06:00:28 <mheinzel> Is there an elegant way to obtain a continuation using callCC and store it in the state?
06:01:27 <mheinzel> I can use callCC and update the state with the continuation, but is it possible to somehow put it into the initial state (used in runReaderT)?
06:02:11 <mheinzel> Otherwise I have to put a dummy value into the state first, just to replace inside the monad.
06:03:28 <mheinzel> https://github.com/mheinzel/hython/blob/errorhandling/src/Hython/Interpreter.hs#L148
06:07:56 <mniip> ooh
06:08:00 <mniip> cult of the bound variable
06:08:02 <mniip> I remember that one
06:26:31 <troydm> if I use readFile from Data.ByteString.Lazy.Char8 package will it open the file in lazy mode or will it read entire file?
06:27:18 <troydm> because I have some 500mb file I would like to parse using aeson and I'm wondering what approach should I use to have minimal memory footprint
06:27:35 <troydm> file is json data
06:37:22 <nitrix> troydm: Lazy.
06:42:02 <troydm> nitrix: well it seems I'm having hard time parsing that lazy thing as it eat ups all memory
06:42:15 <troydm> nitrix: file contains [{}.....] json objects
06:42:23 <troydm> of 500mb
06:43:02 <troydm> I'm doing decode b :: Maybe [Value] in order to decode them
06:43:21 <troydm> I've tried both decode and decode' and they both eat up all memory :(
06:43:59 <pie_> you guys ever read any of these www.aosbook.org/en/index.html ? 
06:44:10 <pie_> well i guess what i really want to ask is are they good/do you recommend them?
06:45:34 <nitrix> troydm: Yeah that's a different problem entirely of Aeson.
06:47:23 <nitrix> troydm: https://hackage.haskell.org/package/json-stream
06:48:35 <nitrix> You want to do "stream parsing".This library apparently plays nice with Aeson but I cannot make any real recommendations other than search keywords.
06:50:07 <troydm> nitrix: ic, thx
07:03:13 <troydm> is head and tail effecient way to process a bytestring?
07:03:31 <troydm> I need to process it like a some list
07:03:56 <wagle> fmap?
07:06:15 <hpc> troydm: look at the existing functions for traversing bytestrings
07:06:31 <wagle> hmm..  how do i keep aeson from truncated bigints to float?
07:06:40 <wagle> hmm..  how do i keep aeson from truncating bigints to float?
07:07:25 <wagle> #semirhetorical
07:11:40 <glguy> wagle decode them differently
07:12:04 <glguy> wagle, aeson parses json numbers losslessly
07:12:35 <glguy> it uses the Scientific type for numbers
07:12:38 <wagle> yeah, looking for that knob
07:12:48 <wagle> oh rrrright
07:13:21 <wagle> man, they show want you to shave yaks
07:13:29 <wagle> man, they sure want you to shave yaks
07:16:09 <Profpatsch> Hm, what’s the recommended way to name accessor fields now?
07:16:25 <Profpatsch> data Foo = Foo { fBar :: Int, fBaz :: Text }
07:16:36 <Profpatsch> data Foo = Foo { bar :: Int, baz :: Text }
07:17:22 <Profpatsch> with DuplicateRecord fields?
07:17:53 <nitrix> fooBar, fooBaz, unless you have another reason to do differently.
07:18:17 <nitrix> Just like it's nice to have consistent naming for functions of a module, I think you can apply the same reasoning to record members.
07:19:09 <DocFox> Hello gentlemen, I get a type mismatch error with this code B.unpack $ Base64.decodeLenient $ B.pack (map convert string)
07:19:18 <DocFox> Couldn't match type ‘GHC.Word.Word8’ with ‘Char’
07:19:28 <DocFox> & Couldn't match type ‘Char’ with ‘GHC.Word.Word8’
07:19:48 <Profpatsch> nitrix: So you think DuplicateRecordFields should not be used?
07:20:01 <nitrix> You're using Data.ByteString.Char8 and one of the function seems to expect Data.ByteString.
07:20:04 <nitrix> DocFox: ^
07:21:08 <nitrix> Profpatsch: It's not that it shouldn't be used, I just feel like you're unecessarily complicating things when you start throwing in more and more extensions.
07:21:38 <nitrix> It's solving the problem of duplicates, but you can still avoid having duplicates. Approach the problem at the source.
07:22:01 <DocFox> fixed it nitrix, thanks. Btw, is there a better way to decode base64 without going trough the hassle of converting to ByteString?
07:22:36 <wagle> glguy: is this my opportunity to finally learn some template haskell, or is there an easier way (ie, a keyword to google for)
07:22:58 <Profpatsch> It looks like a lot of changes came with GHC 8.0 that interact with each other and complicate the language considerabley.
07:22:59 <Profpatsch> *y
07:23:00 <nitrix> DocFox: Depends on the type of the functions provided by that library. base64-bytestring seems to only support ByteString.
07:23:42 <glguy> wagle: I don't know where Template Haskell comes in
07:24:00 <wagle> to generate a type to parse to
07:24:23 <wagle> <quote> Data.Aeson.TH provides Template Haskell functions which will derive an instance at compile time. The generated instance is optimized for your type so will probably be more efficient than the following two options:
07:24:58 <wagle> i guess you'd say no then...  8)
07:25:50 <DocFox> nitrix, it seems to be the reference library when working with base64, so I guess i'm gonna stick with it. Last question: is "unpack . decode . pack" okay style wise?
07:26:41 <nitrix> DocFox: Other than unfortunate, it reads easily to me.
07:27:05 <DocFox> I see, thank you for your time
07:27:35 <Shou> Is there a way to override project specific Stack configuration settings outside its stack.yaml?
07:28:24 <sm> command-line flags
07:28:24 <nitrix> DocFox: Ideally you'd want to work mostly with ByteString or String throughout your application then do one conversion at the beginning/end. Juggling between the two will incur a cost everytime.
07:29:01 <glguy> Shou: What setting?
07:29:28 <Shou> I need `system-ghc: true` but I don't want to enforce this on the project.
07:29:44 <glguy> the stack.yaml *are* your local settings
07:29:47 <Shou> When I eventually `git push` it.
07:30:14 <glguy> Often stack.yaml isn't even committed in the repository
07:30:27 <Shou> In my case it is, for convenience.
07:30:41 <sm> hmm, not committing it would seem odd
07:31:09 <sm> since otherwise everyone would have to stack init
07:31:15 <sm> maybe stack should do that automatically
07:31:20 <glguy> If you're making a library, the .cabal file has the library's constraints that everyone uses, the stack.yaml has is local to a particular project
07:31:28 <glguy> stack init builds the stack yaml automatically
07:31:59 <sm> but stack build/install doesn't, maybe those should too
07:32:00 <DocFox> nitrix, String is used almost everywhere, except where decode is needed, so I guess it's okay
07:32:13 <DocFox> I don't juggle too much between String & ByteString
07:32:24 <nitrix> Cool.
07:32:34 <nitrix> :)
07:32:48 <glguy> someone else using the package as a dependency isn't going to be using whatever stack.yaml comes with a library, so it's impotant that the stack.yaml not have important settings in it that can't be derived by stack.yaml for the library to work
07:33:00 <glguy> can't be derived by stack init*
07:34:05 <sm> that makes sense. I'm still a bit confused about when a stack.yaml should/must be used/committed
07:34:38 <nitrix> It think it's reasonable for executables to commit stack.yaml. My game has a lot of local dependencies that are handled automatically. It's nice.
07:34:39 <glguy> if someone else is working on your project having the stack.yaml committed means you're conflicting with their local settings when working on that library
07:35:01 <nitrix> With cabal, you'd have to manually add them to the sandbox, maybe setup git submodules and whatnot.
07:35:09 <glguy> nitrix: Yeah, if you're committing a sort of "workspace" to git that can make sense
07:35:21 <glguy> but not if you're making a library
07:35:58 <glguy> but then it requires everyone to agree on what that workspace is
07:36:19 <glguy> sometimes everyone is one person and that doesn't matter
07:37:09 <glguy> stack.yaml has local information like extra library include paths
07:37:21 <glguy> so it's not necessarily possible for it to be completely shared
07:37:37 <sm> if you want a reliable setup process that will work for contributors, I think a stack.yaml is often needed
07:37:55 <sm> s/work/always work/
07:37:56 <glguy> stack init is good for that
07:38:17 <sm> stack init seems less deterministic, no ?
07:38:46 <glguy> It's pretty good at picking a resolver once you've specified your dependencies
07:39:30 <nitrix> It's supposed to magically know. Maybe there's a way to add special annotations that should be part of the final stack.yaml generated.
07:39:31 <sm> pretty good/works most times is not enough 
07:39:38 <nitrix> I guess that's another decent workflow as well.
07:39:51 <glguy> sm: If it doesn't work then you aren't done and need to specify your dependencies
07:40:30 <glguy> People should be able to pick different resolvers as long as the packages in the resolver satisfy your constraints
07:41:28 <sm> well, anyone can change the resolver in the stack.yaml, or submit a patch to update it
07:41:39 <glguy> It shouldn't be something everyone has to agree on
07:42:21 <sm> so having a common setup is useful, reducing sources of problem, but changing it is still pretty easy
07:42:58 <glguy> If the project's tricky to set up, having a stack.yaml.default in the repository can help
07:43:08 <glguy> to help someone get started setting up theirs
07:43:29 <glguy> but I've only seen that needed about once
07:43:52 <sm> also if your project has multiple packages, isn't that a good reason to have a stack.yaml ?
07:44:16 <glguy> that might be a good reason to have a default provided
07:44:58 <sm> remember, there a thousand ways for installers/contributors to have trouble and lose interest.. I'm going to do anything that simplifies the process
07:45:45 <glguy> OK, do whatever you want
07:46:48 <sm> thanks :) In truth I'm a bit confused, as I said. Going to ponder what you said as I work with it more
07:47:20 <sm> maybe stack's design could be improved somehow
07:48:32 <Shou> I think it'd be nice with one stack.yaml for project defaults and then allow the user to override it with a project local.yaml or something.
07:49:54 <sm> user can cp stack.yaml local.yaml; stack --stack-yaml local.yaml ...
07:50:53 <sm> you're suggesting it should do that by default, I guess
07:51:04 <Shou> Yeah.
08:00:45 <pkmx[m]> Is there a `Void` of kind `* -> *` defined somewhere I can use?
08:01:02 <lingxiao> hey all
08:01:04 <lingxiao> I have a few questions about regrex
08:01:06 <lingxiao> regex*
08:01:15 <lyxia> just ask
08:01:54 <glguy> pkmx[m]: You can make one with Const Void
08:02:13 <lingxiao> specifically here:
08:02:14 <lingxiao> https://hackage.haskell.org/package/text-icu-0.7.0.1/docs/Data-Text-ICU-Regex.html
08:02:29 <lingxiao> why does the function `regex` return IO regex?
08:02:39 <lingxiao> like why does regular expresssion need IO
08:03:37 <phadej> it's IO because it uses foreign-stuff
08:03:47 <glguy> Because it allocates and compiles and possibly on failure throws an error
08:03:56 <glguy> so it's good to know exactly when that process is happening
08:04:10 <pkmx[m]> @kind Const Void
08:04:11 <lambdabot> Not in scope: type constructor or class ‘Void’
08:04:28 <phadej> also, seems it has "haystack" bundled into
08:04:42 <phadej> so it's stateful object
08:04:42 <glguy> pkmx[m]: * -> *
08:05:12 <glguy> phadej: It has the regex built in (kind of the needle)
08:05:56 <pkmx[m]> glguy: Yeah, I just checked in ghci and it works nicely, thanks for the tip ;)
08:05:57 <phadej> glguy: https://hackage.haskell.org/package/text-icu-0.7.0.1/docs/src/Data-Text-ICU-Regex-Internal.html#Regex shows it has also the "haystack"
08:06:22 <phadej> e.g. "find" doesn't take the haystack anymore
08:06:24 <lingxiao> glguy thanks a lot!
08:06:40 <lingxiao> also I need to write a regex that find all occurances of digits and replace them by zeros... ie
08:06:52 <lingxiao> '1232 322.433'  becomes '0000 000.000'
08:06:53 <glguy> phadej: It takes the haystack as its second parameter I16"
08:07:11 <glguy> findNext uses that haystack then
08:07:17 <lingxiao> and unfortunoately I'm not very familiar with regex in general
08:07:20 <Gurkenglas> @let import Data.Void
08:07:21 <lingxiao> could someone chime in here?
08:07:21 <lambdabot>  Defined.
08:07:24 <phadej> glguy: yes, but that's only an offset
08:07:29 <Gurkenglas> :k Const Void
08:07:29 <lambdabot> * -> *
08:07:37 <sm> lingxiao: very few haskell regex libs provide replace, IIRC
08:07:37 <glguy> It's easier to use the ICU regex interface in the top-level interface
08:07:42 <glguy> this API is quite low level
08:08:19 <lingxiao> glguy thanks for the poitner!
08:08:31 <lingxiao> I'm using it with the conduit library for what it's worth
08:08:46 <glguy> lingxiao: https://hackage.haskell.org/package/text-icu-0.7.0.1/docs/Data-Text-ICU.html#v:regex
08:09:41 <lingxiao> glguy ok I'll look at that!
08:09:52 <sm> http://hackage.haskell.org/package/regexpr is one that does, though this lib is not perfectly robust
08:10:11 <sm> and http://hackage.haskell.org/package/hledger-lib-0.27.1/docs/Hledger-Utils-Regex.html#v:regexReplace is one that uses regex-tdfa
08:12:02 <sigrlami> Quick question about stack, I configured stack to build ghcjs with lts version and after I build specific version it's name doesn't change, for example `compiler: ghcjs-0.2.0_ghc-7.10.3` for `lts-6.6` or `lts-6.10` and with `stack setup` I want to recompile ghcjs, but from stack side nothing changed. How do I force it to recompiler? Maybe some option?
08:13:14 <lingxiao> glguy aahh tried installing text-icu but getting: * Missing C libraries: icuuc, icui18n, icudata 
08:13:42 <sm> sigrlami: stack clean ?
08:13:50 <lingxiao> but I see a SO post on it so
08:14:50 <glguy> lingxiao: You'll have to install the icu C library
08:14:57 <lingxiao> yup doing it now thanks!
08:15:03 <glguy> lingxiao: Linux? OS X?
08:15:09 <lingxiao> os X
08:15:14 <glguy> Homebrew?
08:15:16 <Gurkenglas> Is there something like "preuse' :: (MonadState s m, Alternative m) => Getting (First a) s a -> m a"?
08:15:44 <lingxiao> yes but accidently did sudo port install icu instead
08:15:53 <lingxiao> it's installing now
08:16:01 <Gurkenglas> (Perhaps [a] instead of First a would be more fitting)
08:16:17 <glguy> lingxiao: OK, you might need to specify an extra-lib-dirs and extra-include-dirs for Homebrew, at least.
08:16:49 <lingxiao> yeah you mean after ie brew install icu i need to specify directory when i do cabal install text-icu correct/
08:16:50 <lingxiao> ?*
08:16:50 <lambdabot> Maybe you meant: v @ ? .
08:17:01 <glguy> Yeah
08:17:02 <Gurkenglas> *"*?"
08:17:06 <geekosaur> that's macports. you will need extra-include-dirs /opt/local/include extra-lib-dirs /opt/local/lib
08:17:11 <glguy> icu4c is "keg-only" in Homebrew
08:17:24 <glguy> so it doesn't go into a globally discoverable path
08:17:36 <glguy> like /usr/local/Cellar/icu4c/57.1/
08:18:13 <lingxiao> why is it bad if it goes into a globally discoverable path?
08:18:32 <glguy> OS X comes with some version of ICU already
08:18:38 <lingxiao> oh i see
08:20:54 <sigrlami> no, doesn't help, stack clean remove binaries of my app, ghcjs resided in other place
08:21:12 <lingxiao> ok glguy I hate to ask you this kind of question, but could I ask you what is the regular expression to find all digits and period delimited digits?
08:21:17 <lingxiao> ie 3222 and 4322.4322 
08:21:57 <lingxiao> also is there a haskell version of this library: https://github.com/myleott/ark-twokenize-py
08:21:59 <lingxiao> twokenize
08:22:45 <sm> if you wand to be fully robust, handling all valid decimal numbers, that's actually a bit complicated and you might want to use a parsing library that does it
08:23:01 <glguy> To match about exactly what you said you can use \d+(\.\d+)?
08:23:23 <lingxiao> sm what library do you suggest?
08:23:24 <glguy> > lex "12.34 and more"
08:23:25 <lambdabot>  [("12.34"," and more")]
08:23:31 <lingxiao> :t lex
08:23:32 <lambdabot> ReadS String
08:23:39 <glguy> If you want to define a lexer you can use Alex
08:23:59 <glguy> If you want to hijack a simplified Haskell lexer you can use Prelude.lex
08:24:33 <lingxiao> yeah I hate to say it but quick and dirty is what I am after right now
08:25:07 <sm> https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#v:lex , right ?
08:25:11 <sm> otherwise maybe http://hackage.haskell.org/package/megaparsec-5.0.1/docs/Text-Megaparsec-Lexer.html#g:4 
08:25:53 <Gurkenglas> http://haskanything.com/content/how-do-i/simple/read-a-file-from-disk.html why not just readFile?
08:27:11 <lingxiao> ok sm thanks looking at them now
08:27:38 <geekosaur> that code has a hidden gotcha because hGetContents is lazy. readFile is safer
08:27:58 <lingxiao> oh sm all my process is done in unicode
08:28:38 <geekosaur> (so you return a not-fully-evaluated string, the file is closed when withFile scope is exited, lazy string is truncated)
08:29:26 <sm> lingxiao: test them, then. If it's really a quick one off thing, you could also write a simple non-regex replace function
08:29:39 <lingxiao> ok cool thanks
08:29:49 <lingxiao> is anyone here familiar with twokenize?
08:31:04 <sm> map (\c -> if isDigit c then '0' else c)
08:38:48 <glguy> geekosaur: It's worse than that now
08:39:06 <glguy> geekosaur: people campaigned for the truncation behavior to go away and to get an error
08:39:13 <glguy> Prelude System.IO> withFile "README.md" ReadMode hGetContents
08:39:13 <glguy> "*** Exception: README.md: hGetContents: illegal operation (delayed read on closed handle)
08:39:28 <glguy> withFile + hGetContents = mistake
08:39:56 <geekosaur> yes, and actually I approve of that behavior. but that web page is just Wrong
08:40:26 <geekosaur> or at least does not state that it's only valid if the entire string is evaluated within the withFile
08:51:27 <tnks> aloiscochard: oh, sorry, yeah, I mean multi-project stack.  Cabal files can still only have one library, right?
08:52:16 <jchia_> is there any reason why Data.ByteString.ByteString does not have a Foldable instance? Is it because of legacy reasons?
08:53:04 <cocreature> jchia_: it has the wrong kind
08:53:10 <jchia_> truo
08:53:11 <jchia_> true
08:53:29 <jchia_> didn't think of that
08:53:45 <cocreature> there might be a monofoldable instance somewhere
08:54:47 <lingxiao> hey so Im trying to use the regex :: [MatchOption] -> Text -> Regex function
08:55:00 <lingxiao> and when I do "\d+(\.\d+)" in ghci I'm getting    lexical error in string/character literal at character 'd' 
08:55:12 <sm> use \\
08:55:17 <geekosaur> double the \  
08:57:13 <lingxiao> ah thanks
08:57:13 <lingxiao> !
08:57:43 <ongy> jay escaping :)
08:58:11 <lingxiao> could someone explain to me what this means: \\d+(\\.\\d+)
08:58:17 <lingxiao> what does each symbol here mean
08:58:18 <geekosaur> there may be a "raw string" quasiquoter on hackage
08:58:54 <glguy> lingxiao: You dropped the '?'
08:58:58 <monochrom> it will have yet its own escaping convention because ] ends a quasiquote.
08:59:05 <geekosaur> yeh
08:59:11 <ongy> lingxiao: the problem with "\d" is that ghc(i) want's to interpret \d in some way, so it's something else when it reaches the regex stuff
08:59:25 <lingxiao> sorry dropped it where?
08:59:40 <geekosaur> haskell string syntax *also* uses \ so you need to say \\ to get one \ into the result
08:59:58 <geekosaur> > text "\65"
08:59:58 <ongy> > "\d+(\.\d+)"
09:00:00 <lambdabot>  <hint>:1:3:
09:00:00 <lambdabot>      lexical error in string/character literal at character 'd'
09:00:00 <lambdabot>  A
09:00:24 <lingxiao> oh i see thanks
09:00:36 <lingxiao> glguy where did i drop the ?
09:00:40 <lingxiao> the '?' ?
09:00:42 <geekosaur> after the closing paren
09:00:54 <geekosaur> because you want the decimal part to be optional, not required
09:00:55 <lingxiao> ah right got it
09:01:38 <lingxiao> hm its funny there doesnt seem to be a function in data-text-icu so that replaces a string with another one using some regular expression
09:01:47 <lingxiao> i guess i have to roll my own?
09:01:49 <geekosaur> so, \d+(\.\d+)?     one or more digits, optionally followed by (period followed by one or more digits)
09:02:14 <geekosaur> and replace functions are not common because the C level ones usually mutate
09:03:18 <lingxiao> hmm i see
09:03:51 <lingxiao> so if im mapping over a string using conduit library and I want to find each occurance of digits and replace by something else ... 
09:03:59 <lingxiao> should I just do the natrual thing here? 
09:04:09 <lingxiao> or are there some caveats i should be aware of
09:04:17 <sm> lingxiao: I wrote about that above
09:04:24 <geekosaur> regex quantifiers follow the thing being quantified, but in English you put the quantifier first, so the trailing + is in English prefix "one or more". trailing * is "zero or more". trailing ? is "zero or one", otherwise said "optional"
09:04:37 <lingxiao> sm did you mean ehre: test them, then. If it's really a quick one off thing, you could also write a simple non-regex replace function
09:05:01 <sm> that (and the silly map function that followed), but also the replace situation (see links)
09:05:45 <sm> getting started doing basic regexp stuff is really quite a hassle in haskell. You may want to just try regexpr
09:05:57 <sm> http://hackage.haskell.org/package/regexpr
09:06:44 <sm> I mean, this would be a 1 minute task in ruby, right
09:07:04 <geekosaur> regexes are not really the preferred way to do things in haskell, so there's little interest in making them easy
09:07:33 <hpc> or to be a bit more accurate, they were made easier and more powerful by coming up with things that are not regexes
09:07:48 <hpc> like parser combinators
09:07:55 <geekosaur> the very fact that people have to ask what "\d+(\.\d+)?" means is an indication of why regexes are not preferred. parsers are easier to write and easier to read
09:08:09 <geekosaur> but everyone wants the regexes even when they can't understand what a regex means
09:09:50 <sm> lingxiao: did you see that ? it even provides examples (gasp)
09:10:08 <lingxiao> sm you mean in the links you prvodied?
09:10:15 <sm> yes, regexpr in particular
09:10:24 <sm> and as a general regexp reference I recommend http://www.regular-expressions.info
09:10:31 <lingxiao> sorry could you send it again?
09:10:35 <lingxiao> Im seeing these two links:
09:10:37 <lingxiao> https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#v:lex
09:10:41 <lingxiao> http://hackage.haskell.org/package/megaparsec-5.0.1/docs/Text-Megaparsec-Lexer.html#g:4
09:10:54 <geekosaur> [06 16:05] <sm> http://hackage.haskell.org/package/regexpr
09:11:15 <lingxiao> ahh i see thanks
09:11:19 <lingxiao> so in data-text-icu
09:11:25 <lingxiao> how does the Match datatype work?
09:11:29 <lingxiao> matchRe is not exported
09:11:47 <lingxiao> so If I'm given (Just (Match [...]))
09:11:52 <lingxiao> I can't acess the underlying list
09:12:07 <lingxiao> I dont' want to map over Match because I want to return a T.Text type
09:12:18 <lysgaard> I am building a toy compiler based on WYAH, but now I am stuck with a particular bug in the type inferrence algorithm: https://github.com/sdiehl/write-you-a-haskell/issues/82 Anyone have experience with type-inference for polymorphic lambda calculus and why the WYAH implementation fails?
09:15:54 <lingxiao> ok nevermind got it
09:27:18 <joobus> Question:  I recently wrote a simple program to parse a nested key out of a json file.  I did this just using the Data.Aeson and the Parser monad.  Then I converted it to use lens to fetch the nested item.  What I don't understand is how lens actually works.  Using (^?) only requires a bytestring, and returns a value.  How did the program ever know the bytestring was json?
09:27:54 <joobus> doc for (^?): https://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Fold.html#v:-94--63-
09:28:32 <joobus> the line to parse I ended up using was:  a ^? key "first" . key "second" . _Array
09:28:40 <glguy> ^? is generic, has nothing to do with JSON
09:28:45 <glguy> or bytestrings
09:28:46 <joobus> i know
09:28:56 <glguy> key is responsible for the JSON behavior
09:29:15 <jle`> joobus: check :t key "first" . key "second" . _Array
09:29:51 <jle`> or just :t _Array or :t key "first"
09:30:10 <jle`> although, this might not be a good idea because of type synonym expansion >_>
09:32:35 <lingxiao> in data-icu what's the operation to combine regular expressions by or?
09:32:46 <lingxiao> that is re1 | re2 | ... | re
09:32:47 <lingxiao> n
09:33:35 <joobus> key produces a `Traversal' t Value` and Value is the sum type from Data.Aeson, so key is doing to parsing of the bytestring as json, I assume
09:33:54 <joobus> *the parsing
09:38:53 * hackagebot type-natural 0.7.0.0 - Type-level natural and proofs of their properties.  https://hackage.haskell.org/package/type-natural-0.7.0.0 (HiromiIshii)
09:45:05 <jle`> joobus: yeah, a Traversal "contains" a function to turn a 't' into a list of Value's, and that function for key involves the parsing
09:45:51 <jle`> sort of like how a Lens' s a can be thought of as a packaged-up function to get an 'a' out of the 's', and to replace it
09:46:28 <gottharsys> @pl f x = x + 1
09:46:28 <lambdabot> f = (1 +)
09:47:04 <ongy> @pl f x = 1 + x
09:47:04 <lambdabot> f = (1 +)
09:47:27 <joobus> jle`: thanks.  This is my first foray into lenses.
09:49:15 <jle`> np!
09:56:21 <sphinxo> Should I represent the board in a game of tic tac toe as a [], (,), or [[]] ?
09:56:34 <Athas> sphinxo: Array!
10:00:17 <jle`> sphinxo: V3 (V3 Bool) :D
10:00:30 <jle`> from the linear package
10:00:43 <jle`> or your own custom V3 or 3x3 matrix type
10:00:53 <sphinxo> haha jle :) , array seems pretty reasonable
10:01:01 <jle`> with a Foldable and Traversable instance, you can treat it like a list
10:01:05 <jle`> or a nested list
10:01:09 <sphinxo> oooh
10:01:14 <sphinxo> that's pretty neat :)
10:01:18 <sphinxo> actually
10:01:20 <jle`> array might not be too great becuase of unsafe indexing
10:01:36 <Athas> sphinxo: the only problem with Haskell Arrays is that they are not nice in the multidimensional case, but I don't think you will need that.
10:01:38 <jle`> because your board is statically known ahead of time
10:01:46 <jle`> there's no reason why you have to deal with unsafe indexing
10:02:14 <jle`> V3 (V3 (Maybe Player)) gives you type safe ways of working with your board :)
10:02:32 <jle`> unsafe indexing, why not just write your program in C
10:03:54 * hackagebot glirc 2.4 - Console IRC client  https://hackage.haskell.org/package/glirc-2.4 (EricMertens)
10:04:50 <Athas> jle`: it's often a tradeoff, where the correct-by-construction code is awkward or heavyweight in terms of boilerplate (or slow).  And sometimes the potential errors being avoided are pretty easy to avoid anyway.
10:05:35 <jle`> i can't imagine there being much boilerplate with V3
10:05:45 <jle`> and, the less things you have to worry about as a programmer, the better
10:06:15 <jle`> V3 . V3 is also arguably a nicer itnerface because you get 2d indexing with lenses
10:06:31 <Athas> You need to convert user-provided integers into whatever structured index representation you use.  I agree it's minor in this specific case.
10:08:40 <jle`> yeah, with three indexes i can't imagine it being too bad.  but i guess you were referring to the general case when things get overly complicated?
10:09:00 <sphinxo> http://lpaste.net/404221581502447616 So something like this?
10:09:09 <sphinxo> (for the v3 route)
10:09:21 <Athas> Right.  I had a design in my nontrivial Haskell program where I used GADTs and type-level integers and whatnot to preserve some invariants.
10:09:48 <jle`> sphinxo: yup although i'd automatically derive functor/foldable, partially just to enjoy how painfree this all is
10:09:50 <Athas> But in the end, the invariants I were preseving were pretty trivial compared to the effort it took to write and maintain that type-heavy code.
10:10:11 <jle`> sphinxo: but one of the advantages of using the 'linear' library is it comess with convenient lenses for nested access and modification
10:11:29 <jle`> also it wouldn't hurt too much to leave Grid paremterized too for the instances, but maybe the newtype might even be unecessary
10:11:32 <jle`> unnecessar
10:12:05 <jle`> Athas: yes, that can happen ;_;
10:12:20 <Athas> jle`: if only I was using Idris instead!
10:12:48 <Athas> Specifically, I spent a lot of time proving trivial arithmetic identities (like 'x+(y-z)=(x+y)-z') in the type system.
10:13:06 <Athas> And I still needed dynamic checks when interfacing this structurally-correct module to the nest of my not-structurally-correct compiler...
10:16:30 <sphinxo> so now that i've implemented traversable can I treat Grid as a list?
10:17:10 <Athas> sphinxo: well, you can traverse it.
10:18:30 <monochrom> You can use Traversable's methods on Grid. I wouldn't say "treat as a list".
10:19:34 <sphinxo> ahh ok
10:20:34 <ertes> i wish linear came with *functions* to access coordinates
10:22:46 <ertes> sphinxo: using V3 from the 'linear' package you can write a type like this:  newtype Board a = Board { fromBoard :: M33 a }  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
10:23:48 <ertes> the advantage is that (M33 a), which is just (V3 (V3 a)), is not Traversable in the sense one might expect…  it traverses over *rows* (or columns) rather than elements, so you always need two layers of traversal
10:23:54 <sphinxo> Thats cool
10:23:59 <sphinxo> I'll use that
10:25:37 <ertes> > pure 0 :: V3 Int
10:25:38 <lambdabot>      Not in scope: type constructor or class ‘V3’
10:25:38 <lambdabot>      Perhaps you meant ‘E3’ (imported from Data.Fixed)
10:25:53 <ertes> @let import Linear
10:25:54 <lambdabot>  .L.hs:134:1:
10:25:54 <lambdabot>      Failed to load interface for ‘Linear’
10:25:54 <lambdabot>      Perhaps you meant Linker (needs flag -package-key ghc-7.10.2)
10:25:56 <ertes> too bad
10:26:11 <Athas> I take it linear is not meant for working with large-ish structures?
10:26:31 <ertes> Athas: it's mostly for up to 4D vectors and matrices
10:27:04 <ertes> but it does support higher dimensions, either by your own vector types, or by the dimensionality-parametric V type
10:27:14 <ertes> V 5 Double  -- a 5D vector
10:27:23 <ertes> … type
10:27:57 <ertes> Athas: but writing a linear-compatible vector type is really easy, because most of its operations are in terms of base classes like Applicative and Traversable
10:28:09 <sphinxo> woah linear sure has some deps which are quite intensive to build
10:28:24 <tommd> ertes: Ping
10:28:39 <ertes> tommd: pong
10:28:49 <Athas> sphinxo: I think that library is overkill for a tic-tac-toe program, unless the point is to try out this kind of type-heavy programming.
10:28:52 <jle`> Athas: yes, that can happen ;_;
10:29:00 <tommd> ertes: I've been thinking (and otherwise busy) about your and many other peoples desires wrt entropy.
10:29:03 <wagle> I don't understand how to generate arbitrary json datastructures with exact Integers with aeson..  all the examples seem to concentrate on extracting one datatype
10:29:08 <jle`> sorry, mis-typed
10:29:13 <gottharsys> @pl f x = g x ""
10:29:13 <lambdabot> f = flip g []
10:29:48 <tommd> ertes: My thoughts are that we as a community should have/do need an actual "System.Entropy" 
10:29:49 <sphinxo> Athas: I think I might just try using it to experiment with type heavy programming
10:29:55 <gottharsys> @pl f x = g 3 x ""
10:29:56 <lambdabot> f = flip (g 3) []
10:29:59 <jle`> sphinxo: the deps are mostly from lens, heh
10:30:01 <tommd> ertes: And in general access to the sources unmolested.
10:30:27 <ertes> tommd: ah, hello!  yeah, i agree
10:30:30 <tommd> ertes: But at the same time, I am of the mindset that users would benefit from a mixing of sources (without overengineering)
10:30:35 <Athas> sphinxo: a good idea!  Remember to write it in a straightforward way also, so you can judge the pros and cons.
10:30:58 <jle`> i wouldn't realy say linear is very type-heavy
10:31:02 <tommd> ertes: SO here's the plan - and it's an ernest proposal despite me not having time to act *right now*.
10:31:04 <sphinxo> That's actually a very good idea - thanks
10:31:05 <jle`> except for maybe the Linear.V module
10:31:19 <gottharsys> @pl f x = showIntAtBase 2 intToDigit x ""
10:31:19 <lambdabot> f = flip (showIntAtBase 2 intToDigit) []
10:31:22 <jle`> V3 is literally just the same Vec3 you wrote
10:31:30 <jle`> linear just has some nice utlity functions :)
10:31:43 <jle`> gottharsys: did you know that you can use lambdabot in private message? :)
10:32:05 <tommd> ertes: System.Entropy exposes urandom or crypt-api or (on Xen) RDRAND as well as some yet-to-be-named hwRandom :: Int -> IO (Maybe ByteString) with softer promises.
10:32:10 <jle`> :(
10:32:14 <sphinxo> these utility function dependencies are making my computer warm
10:32:50 <jle`> yeah that's lens ;_;
10:33:13 <tommd> ertes: These building blocks can be used to make something more particular by higher level packages if desired (fortuna) or otherwise directly used by consumers.
10:33:50 <jle`> sphinxo: well, the only thing really useful would probably be the lenses that are pre-defined, but writing them on your own isn't that bad at all
10:33:54 <jle`> and using them wouldn't be that bad either
10:34:08 <jle`> so it might be fine just to skip linear completely and implement the subset that you need from scratch
10:34:17 <tommd> ertes: I welcome your input, and thanks for continued interest / engagement vs any sort of "screw you, fork fast" mentality.
10:34:50 <sphinxo> +1 I think i'll do that
10:34:59 <jle`> xLens f (V3 x y z) = (\x' -> V3 x' y z) <$> f x
10:35:11 <jle`> yLens f (V3 x y z) = (\y' -> V3 x y' z) <$> f y, etc.
10:35:25 <jle`> and now all of a sudden you have nestable/composable accessors and getters to your grid :)
10:35:35 <ertes> tommd: from my (user) perspective really all i need is a way to get bytes from urandom…  currently i literally just open /dev/urandom and read from it, sometimes together with DRBG if needed
10:36:11 <tommd> ertes: And that's what entropy would provide under this proposal... except it would also work with Windows and with Xen.
10:36:49 <zort> I'm trying to define a Binary instance for a fixed length list 'Sext n a' (n=length, a=element type) that uses GHC type literals in the type. The deserialization function needs to know n. Is it possible to get n from inside the function? http://slexy.org/view/s21WbTVEMs
10:37:17 <jle`> zort: yes, with ScopedTypeVariables
10:37:21 <ertes> tommd: sounds fine to me…  really any way to access OS entropy seems fine to me, as long as it's not RDRAND-exclusive
10:37:22 * tommd Goes to write unrelated/paid code.  Will look back on this channel later.
10:37:23 <zort> I tried that
10:37:33 <tommd> ertes: OK!
10:37:38 <zort> it still says  Not in scope: `n'
10:38:34 <jle`> how are you using it?
10:39:02 <zort> get = fmap (Sext.create >>> fromJust) $ replicateM n get
10:39:03 <jle`> hm, but also i don't think you need to explicitly use it
10:39:07 <jle`> oh
10:39:09 <jle`> n there is not a type
10:39:12 <jle`> it's a value
10:39:19 <jle`> there is no value named 'n'
10:39:49 <jle`> replicateM takes an Int, so you need to give it an Int
10:40:08 <zort> you're restating the problem, right?
10:40:31 <jle`> yeah, i originally read your problem as you needed access to the type n
10:40:36 <glguy> To get a value representation of that type-nat, you'll need http://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-TypeLits.html#t:KnownNat
10:40:38 <jle`> but you want access to the Int that the type represents
10:40:44 <jle`> you can use natVal there
10:40:58 <jle`> natVal (Proxy @n) :: Integer
10:41:10 <jle`> natVal (Proxy @n) gives you the Integer that the type n represents
10:41:14 <ertes> tommd: thanks!  glad to have a common ground on this
10:41:39 <jle`> natVal :: KnownNat n => p n -> Integer or something I think
10:41:59 <zort> um, parse error on input `@'
10:42:08 <jle`> you might need to enable TypeApplications
10:42:15 <jle`> or you can do it the old school way, natVal (Proxy :: Proxy n)
10:44:00 <sphinxo> jle`: so an example of composing the lens fns bottomLeft f = zLens (zLens f)
10:44:03 <sphinxo> is that correct?
10:44:24 <jle`> sphinxo: yeah, or bottomLeft = zLens . zLens
10:44:55 <jle`> (which won't type check with monomorphism restriction like you'd want, but you probably don't need to define it anyway)
10:45:29 <jle`> so `over (zLens . zLens) f` wouild map f over the bottom left square
10:45:41 <jle`> `view (zLens . zLens)` would be your indexer
10:46:40 <jle`> if you don't have lens as a dep, you'd have to write over and view on your own, but that might be a fun exercise :)
10:46:43 <benjica> I would to apply a function across a list where a value matches a predicate.
10:47:18 <jle`> or maybe there's a leightweight package somewhere that provides simply definitions of over/view/etc. and nothing else
10:47:31 <benjica> Is there a function I can use to use id where the value fails the predicate and the function f if it satasfies it?
10:48:00 <ertes> sphinxo: note that the linear library predefines those lenses for you
10:48:18 <jle`> benjica: i'm not sure if there is any built-in, but it should be simple enough to write
10:48:39 <ertes> myBoard ^. _x . _y  -- first row, second column
10:48:41 <benjica> I wasn't sure if an arrow was applicable here.
10:48:44 <zort> it's telling me Couldn't match kind `GHC.TypeLits.Nat' with `*' http://slexy.org/view/s2uPmtU57O
10:48:49 <zort> pretty scary stuff
10:49:04 <jle`> zort: hm, maybe enable PolyKinds ?
10:49:19 <jle`> what version GHC are you using?
10:49:32 <zort> 7.10.3
10:49:59 <jle`> it's kind of weird to me that Proxy isn't polykinded by default but that seems to be the issue the error is talking about
10:50:01 <zort> that's what the yesod quickstart thing chose
10:50:07 <jle`> it thinks that Proxy :: * -> *, and not Proxy :: k -> *
10:50:50 <ertes> benjica: lenses make this rather easy
10:51:01 <tommd> [5~
10:51:02 <tommd> oops
10:51:03 <jle`> :k Proxy
10:51:04 <lambdabot> k -> *
10:51:24 <ertes> > (traverse . filtered even %~ 10) [1..5]
10:51:25 <lambdabot>      No instance for (Show b0)
10:51:25 <lambdabot>        arising from a use of ‘show_M34111127833140488237172’
10:51:25 <lambdabot>      The type variable ‘b0’ is ambiguous
10:51:31 <c_wraith> jle`: the first version of ghc that bundled Proxy didn't compile it polykinded
10:51:36 <ertes> uhm
10:51:38 <ertes> > (traverse . filtered even +~ 10) [1..5]
10:51:40 <lambdabot>  [1,12,3,14,5]
10:51:47 <ertes> benjica: ^
10:51:56 <c_wraith> jle`: I remember this because I filed the enhancement request in the libraries mailing list
10:51:58 <jle`> c_wraith: yeah, they're on 7.10 though
10:52:21 <glguy> Proxy that comes with GHC 7.10.3 works fine with Nat
10:52:23 <jle`> i thought if it was defined to be polykinded, then any module that imported it would get the polykinded version
10:52:34 <jle`> but the Proxy that zort is using seems to be rejecting Nat
10:52:42 <jle`> do you need PolyKinds for that to work?
10:53:09 <glguy> Perhaps Sext isn't parameterized by a Nat, but a *
10:53:11 <monochrom> No. I just used it the other day.
10:53:16 <zort> adding PolyKinds seems to have fixed it, on a different error now that's probably my fault
10:53:17 <benjica> ertes: Perfect! Thanks.
10:53:32 <monochrom> I only had DataKinds and KindSignatures (and ScopedTypeVariables)
10:53:33 <glguy> Or a different Proxy than Data.Proxy is in use
10:54:28 <jle`> mysteries
10:54:54 <monochrom> Need a reproducible experiment.
10:55:55 <monochrom> Or http://www.vex.net/~trebla/humour/tautologies.html #4 if you just want to laugh.
10:55:59 <jle`> i'm still freaking out that zort's pastebin site links to haddock documentation to identifiers in the source code
10:56:14 <zort> woah
10:56:26 <zort> didn't notice that
10:57:14 <monochrom> Happily it's all 404 so there is nothing to look, can move on.
10:58:45 <jle`> aw
11:06:30 <zort> does it make sense to write 'instance (Binary a, Sextable [a], KnownNat n) => Binary (Sext n [a])' with the double type constructor 'Sextable [a]' on the left?
11:07:01 <zort> or are you only allowed single type constructors in the constraint?
11:07:11 <jle`> it should be allowed with FlexibleConstraints
11:07:27 <jle`> but you're going to have a bad time if you ahve both that instance and also the Sextable a instance
11:07:47 <zort> cool
11:07:51 <zort> no only Sextable [a]
11:08:05 <zort> unsupported extension :(
11:08:15 <jle`> oh sorry
11:08:17 <jle`> FlexibleContexts
11:08:37 <jle`> i usually just FlexibleCon<tab>, heh
11:09:19 <sphinxo> jle`: so how would I go about implementing view and over?
11:09:20 <ertes> Fl<tab>C<tab>
11:10:09 <jle`> sphinxo: for over, you want to turn a (a -> f a) -> (b -> f b) into an (a -> a) -> (b -> b)
11:10:20 <jle`> or more generally an (a -> f b) -> (s -> f t) into an (a -> b) -> (s -> t)
11:10:28 <jle`> so you basically want to make the f "disappear"
11:10:37 <jle`> or, have it be ignored/act as an identity
11:10:51 <ertes> or rather pick an F such that F x ≃ x
11:10:54 <glguy> zort: We can write a more general instance that wouldn't require FlexibleContexts or Instances
11:11:07 <sphinxo> hmm
11:11:08 <jle`> similar to how you'd implement fmap using traverse
11:11:22 <jle`> oh yeah, i didn't mention that you get to pick your 'f'
11:11:38 <zort> glguy: how?
11:11:51 <jle`> writing view/over/set boils down to picking the 'f' that gives you the behavior you want, and being creative
11:12:45 <jle`> (quoted from a reductionist)
11:13:27 <ertes> sphinxo: (i recommend implementing 'over' first)
11:14:19 <ertes> 'view' may need some brain adjustment…  at least it did for me =)
11:16:49 <sphinxo> wait  for over don't you want ((a -> b) -> s -> t)
11:17:15 <lpaste> glguy pasted “for zort” at http://lpaste.net/174706
11:17:21 <ertes> sphinxo: what's the type of 'over'?
11:17:30 <glguy> zort: You'll need to fill out the BinaryWithLength instances, but they're all possible
11:17:32 <zort> coincidentally I just got mine working
11:17:37 <zort> or compiling at least
11:17:38 <glguy> this requires no extensions
11:17:51 <glguy> and will more easily support the other sextables
11:18:20 <glguy> Oh, and I shouldn't have used get for the length in the get implementation, oops, fixing
11:18:49 <sphinxo> oh wait
11:19:06 <ertes> sphinxo: i'm not saying you're wrong!  i'm asking you a question
11:19:32 <ertes> sphinxo: answering it will help you answer your own question
11:19:41 <sphinxo> How it appears in lens?
11:20:00 <ertes> sphinxo: you're reimplementing lenses, aren't you?
11:20:03 <sphinxo> yes
11:20:03 <lpaste> glguy revised “for zort”: “for zort” at http://lpaste.net/174706
11:20:07 <zort> that makes sense glguy
11:20:10 <ertes> sphinxo: then use only the definitions you have written so far
11:20:42 <ongy> glguy: reading out of contest, do I want to look up sextables? :)
11:20:42 <sphinxo> I haven't written any apart from  what jle` posted earlier above
11:20:47 <zort> this seems like something someone should have done before though
11:21:11 <zort> unfortunately in slang "sextable" is read as sex + table instead of sext + able
11:21:23 <ertes> sphinxo: well, first decide whether you want to learn how lenses work on this level (it pays off, but technically it's optional)
11:21:23 <zort> oh well
11:22:22 <sphinxo> i'll think i'll skip how it works on this level, because i've kind of gone down a rabbit hole
11:22:29 <ertes> sphinxo: if yes, then you should write some actual definitions now…  create a little lens module in your project…  don't worry, your lenses will be compatible with the lens library
11:22:36 <sphinxo> but i'm sure in the future i'll return
11:22:57 <zort> thanks for the help jle` glguy, no way I could have done this on my own
11:23:02 <ertes> sphinxo: if you don't want to go down there, really just use the lenses that the 'linear' library defines for you
11:23:10 <sphinxo> ahh ok
11:23:15 <ertes> sphinxo: myBoard ^. _x . _y
11:23:32 <ertes> sphinxo: that's the second column of the first row
11:24:27 <sphinxo> ok
11:25:18 <ertes> sphinxo: you can use (^.) to access individual elements and (%~) to modify elements
11:25:31 <ertes> there are also many convenience wrappers around (%~)
11:38:02 <wagle> I'm trying to chnage aeson's "Value" to use Int instead of "Scientific"..  google isnt helping..  anyone alreaady know howto do this?
11:41:37 <Shou> wagle: https://hackage.haskell.org/package/scientific-0.3.4.9/docs/Data-Scientific.html#v:toBoundedInteger
11:41:45 <Shou> This might be what you're looking for
11:42:02 <wagle> already lost precision
11:42:32 <wagle> but I'm looking
11:43:40 <wagle> the json has 64 bit timestamps.. 
11:43:47 <wagle> the json has 64 bit int timestamps.. 
11:46:18 * wagle is maybe confused
11:53:41 <monochrom> Scientific doesn't lose digits. Int does.
11:54:45 <wagle> yeah, thats my latest hypothesis
11:55:13 <wagle> testing it now
12:09:01 * hackagebot hgeos 0.1.7.2 - Simple Haskell bindings to GEOS C API  https://hackage.haskell.org/package/hgeos-0.1.7.2 (rcook)
12:14:01 * hackagebot pointful 1.0.9 - Pointful refactoring tool  https://hackage.haskell.org/package/pointful-1.0.9 (MikhailGlushenkov)
12:16:42 <sphinxo> http://lpaste.net/6560996980581990400 is that the right type annotation for the accessors?
12:18:56 <ertes> sphinxo: looks right to me, but why are you defining everything yourself?
12:19:59 <sphinxo> So that when I do use other peoples implementations I know what's going on
12:20:05 <sphinxo> also learning etc
12:20:28 <ertes> so you're learning lenses after all =)
12:20:47 <sphinxo> ¯\_(ツ)_/¯
12:22:49 <ertes> i appreciate haskell for being exceptionally consistent compared to other mainstream languages, but it's inconsistent in the weirdest places
12:23:19 <ertes> x {}  -- x being of a record type, not allowed because empty record update
12:26:41 <Rotaerk> why would you want that?
12:27:39 <wagle> ok, whats the modern way to extract something from (say) a parser monad and print it in the top level io monad?
12:28:52 <Rotaerk> also how is that an inconsistency
12:29:45 <ertes> Rotaerk: during prototyping i tend to write code in small steps
12:29:55 <monochrom> wagle, that depends on which parser monad. but most existing ones have a function Parser a -> Either <some kind of parse error type> a
12:30:23 <Rotaerk> I see
12:30:26 <ertes> Rotaerk: let winCfg = Sdl.defaultWindow {} in Sdl.createWindow "Test" winCfg  -- then type-check, then fill in the actual fields
12:30:41 <wagle> monochrom: Maybe (Parser a)
12:31:00 <Rotaerk> I mean you can just wait to add the {} when you actually have an update to perform
12:31:06 <Rotaerk> it's just two characters to omit
12:31:12 <OutlawStar> hi all, question: I'm using data kinds and I am trying to use the type of a function to determine which instance of a type class to invoke, in seems to work in most cases, but in this particular scenario it does not. Line 27 here: http://lpaste.net/4666644724889681920, any ideas. I need KeyFlag to resolve.
12:31:17 <monochrom> Rotaerk: Consider how "let {} in case Just 4 of Just{} -> True" is legal
12:31:36 <Rotaerk> it is? not sure what that even does
12:31:42 <OutlawStar> compiler sees dup instances :(
12:32:28 <Rotaerk> oh, is that an empty list of let-bindings
12:32:42 <monochrom> wagle, so you don't even always have a parser!
12:32:43 <ertes> Rotaerk: sure, but i expand the layout, just to find that i have to remove it again
12:33:07 <ertes> Rotaerk: note that i'm not typing this on a single line, and i'm an exceptionally lazy typist
12:33:13 <Rotaerk> k-
12:33:19 <Rotaerk> k *
12:33:58 <ertes> it's just a minor annoyance, but haskell has quite a few of them, and sometimes they add up =)
12:34:02 <monochrom> Also, I forgot that a parser needs input. Parser a -> <some input type> -> Either <some parser error type> a
12:34:58 <monochrom> Parser monads are where "it's a recipe, there is nothing to extract" is accurate, even without I/O.
12:35:06 <joe9> glguy: you around? Now. I understand why using RWST was such a bad idea.
12:35:25 <wagle> Just (Object (fromList [("ok",Bool True), ...
12:35:47 <monochrom> That's an Object not a Parser a.
12:36:25 <monochrom> It is also a hashed dictionary.
12:36:26 <wagle> type error says its aeson-0.11.2.0:Data.Aeson.Types.Internal.Parser
12:36:53 * wagle KNOWS for a fact that he's confused
12:37:12 <monochrom> OK, what is the complete picture?
12:37:46 <wagle> trying to parse json off the web using aeson
12:37:51 <monochrom> I'm pretty sure "Just (Object ...)" is a Maybe Value, not a Maybe (Parser a)
12:38:05 <Profpatsch> cabal wants that I copy all dependencies from my lib to the executable definition.
12:38:22 <Profpatsch> Even though the executable module only calls one exposed thing from the lib.
12:38:27 <Profpatsch> Is that normal?
12:38:41 <monochrom> You're probably misreading the error message.
12:38:56 <wagle> monochrom: thats what I thought..  yeah, lemme explore that for 5 minutes
12:41:13 <sphinxo> how's "((a -> Identity b) -> (s -> Identity t)) -> (a -> b) -> s -> t" as the type of over ertes 
12:42:35 <ertes> sphinxo: looks right to me
12:43:12 <monochrom> will you generalize from Identity to arbitrary Functors? :)
12:43:38 * wagle has aha moment
12:43:59 <sphinxo> monochrom: sorry I don't understand what you mean?
12:44:28 <monochrom> forall f. Functor f => ((a -> f b) -> (s -> f t)) -> (a -> b) -> s -> t
12:45:17 <ertes> monochrom: for 'over'?  i wouldn't do that
12:45:23 <monochrom> maybe not
12:46:00 <ertes> sphinxo: the idea is: polymorphic lenses (_x), monomorphic users (over)
12:46:53 <ertes> sphinxo: in other words your type signature is fine
12:47:09 <sphinxo> Ok great
12:47:44 <hpc> monochrom: can you even write that one with Functor?
12:47:57 <monochrom> no
12:48:15 <ertes> you could, if it were rank 2
12:48:21 <ertes> but not like that
12:49:03 <hpc> because if it was rank 2 you could pick f = Identity and get back to the first one
12:49:25 <monochrom> Yeah, but I wasn't thinking of the rank-2 version
12:50:08 <ertes> even then i wouldn't do that, because that rules out non-lens traversals
12:51:28 <sphinxo> what would the type sig of get look like?
12:52:01 <sphinxo> wait working it out
12:55:13 <cynode> Am I in the right place for help with compiling a simple introductory haskell program?
12:55:15 <hexagoxel> Profpatsch: your executable is by all likelyhood directly using library modules instead of using the dependency.
12:55:26 <Eduard_Munteanu> cynode, yes
12:55:28 <abrooks> cynode: Of course!
12:55:28 <glguy> cynode: Sure. You can use http://lpaste.net for code 
12:55:57 <OutlawStar> fyi: figure my issue out, needed ScopedTypeVariables ext
12:56:14 <sphinxo> ok get type sig is something like: get :: s -> ((a -> Const a s) -> s -> Const a b) -> a
12:56:18 <sphinxo> is that correct?
12:56:25 <ertes> sphinxo: yeah
12:56:37 <hexagoxel> Profpatsch: i.e. you are not using separate hs-src-dirs and cabal prefers "local" imports
12:56:38 <ertes> sphinxo: personally i would flip it, but yeah
12:56:46 <sphinxo> flip it how?
12:56:57 <ertes> sphinxo: take the subject value as the second argument
12:57:16 <sphinxo> oh ok
12:57:38 <ertes> sphinxo: just for consistency i would rename 'b' to 't', too
12:57:50 <Eduard_Munteanu> Is there an extension which provides qualified exports? e.g. simply import X and use X.Y.foo if X exports Y qualified.
12:58:22 <Eduard_Munteanu> Or is someone working on it?
12:58:47 <lpaste> cynode pasted “Linking Error?” at http://lpaste.net/2702251044477337600
12:58:49 <ertes> sphinxo: guessing by the way you named your variables your type may be correct by accident:  get :: ((a -> Const a b) -> s -> Const a t) -> s -> a
12:59:13 <ertes> sphinxo: i.e. just replace F by (Const a)
12:59:25 <cynode> Ok, it posts it automatically. That's neat. I'm trying to work though Chapter 5 in Real World Haskell. I'm fairly certain the code itself is ok, but I seem to be getting a linking error...
12:59:46 <Profpatsch> hexagoxel: I have ./Main.hs as executable and ./MyModule as module namespace.
13:00:15 <Profpatsch> Should I move MyModule into src/mymodule?
13:00:28 <CubicE> Hi, is there a function like mapM with index (a la (Int -> a -> m b) -> Vector a -> m [b]) in the vector library? Because if there is I can't seem to find it?
13:00:29 <glguy> cynode: use  ghc -o simple Main.hs SimpleJSON.hs
13:00:35 <sphinxo> F? ertes 
13:00:40 <ertes> sphinxo: the functor
13:00:44 <sphinxo> ahh ok
13:00:57 <newsham> what can haskell learn from golang?
13:00:59 <ertes> CubicE: apply 'indexed' before folding
13:01:07 <ertes> newsham: marketing
13:01:33 <newsham> i mean, not as an inflamatory question..  haskell obviously has a lot more powerful features and mechanisms.
13:01:36 <glguy> cynode: Or even better:  ghc -o simple Main
13:01:43 <newsham> but.. there is some elegance, particularly in some of the library design
13:02:15 <sphinxo> and set can just be ((a -> Identity b) -> (s -> Identity t)) -> b -> s -> t
13:02:16 <CubicE> Oh yeah, I forgot to mention, this is for Storable vector, which doesn't seem to have indexed
13:02:21 <glguy> cynode: GHC already knows how to search for modules. When you import SimpleJSON in Main GHC knows to look for SimpleJSON.hs
13:02:40 <Profpatsch> hexagoxel: Hm, now the linker completely fails.
13:02:43 <newsham> if you were going to write a new haskell-like language today, and you knew golang well, would you do it differently than if you hadnt been exposed to golang?
13:02:46 <Profpatsch> What’s with this package manager.
13:02:49 <ertes> CubicE: oh yeah, there is no Storable instance for tuples unfortunately…  go through a list in that case
13:02:52 <cynode> glguy: Oh, that's simple enough. And it works! Have the parameters changed since Real World Haskell?
13:03:11 <ertes> CubicE: oh, it's mapM, not mapM_
13:03:29 <CubicE> ertes: I was more thinking along the lines of just iterating over the vector recursively, because that's what I'm getting as an argument
13:03:55 <joe9>  glguy: you around? Now. I understand why using RWST was such a bad idea. Thanks for the suggestion.
13:03:56 <glguy> cynode: Probably; many things have changed since Real World Haskell was originally published. I think that at the time of publishing the "smart" behavior was enabled by a --make flag. Current GHC uses the smart behavior by default
13:04:02 <glguy> joe9: Oh, cool.
13:04:04 <ertes> CubicE: well, you could use StateT to get a counter
13:04:23 <ertes> CubicE: evalStateT (mapM f xs) 0
13:05:13 <ertes> sphinxo: write 'set' in terms of 'over'
13:05:16 <CubicE> I don't know, sounds like overengineering for me. I'm just trying to write poke for a fixed size vector lol
13:05:52 <ertes> CubicE: i don't think it's overengineering…  it's actually one of the few use cases of StateT that i'd consider valid =)
13:06:19 <ertes> CubicE: if you write a loop, you will do explicit indexing, which is going to be much uglier and blinder
13:06:51 <cynode> glguy: Ok, thanks for the help! One more question if you have a minute: What's the difference between "Public" and "Private" on lpaste?
13:07:09 <glguy> Public is listed in the index, you can find them behind the "browse" link
13:07:31 <hexagoxel> Profpatsch: do you expose the module from the library? what does the .cabal look like/is the project on github or smth?
13:08:09 <joe9> glguy:  would you recommend a prelude better than the current one?
13:08:14 <glguy> No
13:08:28 <suzu> i want an update to rwh :(
13:09:04 <Profpatsch> hexagoxel: Even if I use the library as dependency, I still have to expose all modules, even if the executable only needs one?
13:09:35 <Profpatsch> Yes, now the linking works as well.
13:10:18 <CubicE> ertes: This is the explicit loop version. Doesn't look THAT bad to me https://gist.github.com/anonymous/56a53664b9685162b0b446451b5454a6
13:10:19 <Profpatsch> I always wonder why such a high-level language has a package manager behaving in such … simpla ways.
13:11:13 <hexagoxel> Profpatsch: https://www.haskell.org/cabal/users-guide/developing-packages.html#modules-included-in-the-package
13:11:15 <glguy> Profpatsch: No, you don't have to expose *all* modules to use *one* module in an executable (perhaps I'm missing something from the chat history)
13:11:46 <glguy> Profpatsch: You do need to list unexported modules in "other-modules"
13:12:04 <ertes> CubicE: because that's not a loop =)
13:12:06 <CubicE> You don't have to _expose_ all modules, but you need to _list_ all modules that are actually a part of the library
13:12:10 <sphinxo>  so http://lpaste.net/3419016472691736576 ertes 
13:12:27 <CubicE> ertes: Right you are. I'm a moron
13:13:03 <CubicE> although it only lacks 7 characters
13:13:03 <Profpatsch> glguy: I wonder why I have to list them at all.
13:13:17 <glguy> Profpatsch: So that cabal knows how to form the correct linker commands
13:13:21 <hexagoxel> Profpatsch: you did read the guide, did you not? :D (to be fair, the guide is a mess. this is the real problem, not cabal's behaviour.)
13:13:38 <ertes> sphinxo: looks correct to me, but at this point you should try it out
13:13:52 <CubicE> Profpatsch, because cabal doesn't assume any particular directory structure and isn't going to guess what's part of the public or private interface of your module, and what's for example test files or stuff you only need for code generation
13:14:11 <Profpatsch> But cabal already knows how to build the modules correctly.
13:14:18 <ertes> sphinxo: write a few simple lenses like the identity lens (from a value to itself), the fst lens (from a tuple to its left component), etc.
13:14:25 <Profpatsch> And then fails at the linker, if I don’t exactly tell it how to behave.
13:15:06 <ertes> CubicE: it's not bad in terms of code size, but it's bad in terms of structure (in my opinion)…  the StateT variant is cleaner, even though it may actually be slightly longer
13:15:10 <CubicE> That does indeed sound odd. If I forget to list a package in cabal I tend to get compile errors, not link errors
13:15:22 <ertes> CubicE: simply having the mapM there is a *major* advantage over the explicit loop
13:16:31 <monochrom> The other day someone entrenched in C was asking "in C I always add a guard against running my loop for too many iterations. can you do that easily in Haskell too?"
13:16:47 <CubicE> oh right I forgot... what's the hip thing to use nowadays? mtl or transformers?
13:17:12 <Eduard_Munteanu> mtl2
13:17:13 <ertes> CubicE: mtl is a library of effect classes on top of transformers
13:17:15 <monochrom> And my answer is "we don't write as many recursions by hand as you write loops by hand". it's because you just use mapM and foldl' etc all the time.
13:17:25 <ertes> CubicE: you can use transformers directly in this case
13:17:27 <sphinxo> ertes: thanks very much for your help
13:17:50 <ertes> sphinxo: you're welcome…  now have a very close look at the type of 'traverse'
13:18:03 <ertes> sphinxo: and see if it fits any of the types you defined =)
13:19:57 <hexagoxel> Profpatsch: ghc --make is sufficiently clever to build dependent modules for any module exposed by your lib. but that set needs not be equivalent to the set of modules you want to expose.
13:20:27 <hexagoxel> Profpatsch: if you have independent modules A and B and expose/other only one of them, cabal build will only build that one.
13:23:59 <hexagoxel> (and ghc --make is (currently) used behind `build`)
13:25:34 <sphinxo> ertes: ya gonna have to give me a hint
13:27:23 <ertes> sphinxo: compare:
13:27:49 <ertes> someLens :: (Functor f) => (A -> f B) -> S -> f T
13:28:10 <sphinxo> ah
13:28:19 <ertes> traverse :: (Applicative f) => (A -> f B) -> [A] -> f [B]
13:28:26 <ertes> (specialised to lists)
13:28:51 <ertes> sphinxo: unlike someLens, traverse is not a lens…  it needs the functor to be Applicative, not just Functor
13:28:57 <ertes> so you can't use it with 'get'
13:29:04 <ertes> but you can use it with 'over'
13:29:40 <ertes> > over traverse (^2) [1,2,3,4]
13:29:42 <lambdabot>  [1,4,9,16]
13:30:38 <ertes> type-level reason why you can use it with 'over':  Identity happens to be Applicative
13:31:23 <ertes> 'traverse' is what in lens slang is called a traversal…  unlike a lens it can focus on *many* things, in this case all list items
13:33:16 <sphinxo> hmm
13:34:59 <ertes> sphinxo: this is your last chance…  after this there is no turning back
13:35:30 <sphinxo> so  over traverse (\x -> x) initialGrid applies to every item in the top level vec3 
13:35:56 <sphinxo> wait can I also fold?
13:36:15 <ertes> if (initialGrid :: Vec3 (Vec3 a)), then you apply the function over each row (or column)
13:36:30 <ertes> yeah, you can fold
13:36:34 <sphinxo> oh boy
13:36:58 <ertes> note that "optics" compose
13:37:11 <ertes> over traverse f  -- apply f to each row
13:37:19 <ertes> over (traverse . traverse) f  -- apply f to each element
13:37:30 <sphinxo> that was what I was looking for
13:37:31 <ertes> over (traverse . _x) f  -- apply f to the first element of each row
13:37:38 <sphinxo> my god
13:38:10 <sphinxo> mind a bit blown
13:38:29 <ertes> i told you:  after this there is no turning back…  welcome to the lens rabbit hole =)
13:38:33 <sphinxo> just an everyday occurance in haskellville
13:41:08 <ertes> sphinxo: check out under what circumstances (Const a) is an Applicative
13:41:26 <ertes> then you know when you can use traversals with 'get'
13:43:41 <sphinxo> could you give me an example with get? ertes 
13:44:10 <ertes> sphinxo: first do you see an Applicative instance for (Const a)?
13:44:47 <sphinxo> monoid
13:47:34 <sphinxo> ertes: so I need to implement monoid for my cell type?
13:49:07 * hackagebot palette 0.1.0.4 - Utilities for choosing and creating color schemes.  https://hackage.haskell.org/package/palette-0.1.0.4 (BrentYorgey)
13:49:25 <wagle> ok..  in aeson, I've "decode"d a json string.  the value vv show's (prints) as "Just (Object (fromList [("ok",Bool True), ..."  now how do I print vv at the index "ok"?
13:49:57 <wagle> "its type errors all the way down"
13:50:16 <dmj`> wagle: sounds like you want to use a FromJSON instance
13:50:19 <ertes> sphinxo: no, that's not where i was going
13:50:32 <ertes> sphinxo: in some cases you can fold using traversals
13:50:44 <ertes> > view traverse ["abc", "def"]
13:50:45 <lambdabot>  "abcdef"
13:50:59 <sphinxo> is my get the same as view?
13:51:07 <wagle> dmj`: 
13:51:08 <wagle>   let ss = decode (B.fromStrict (E.encodeUtf8 (T.pack ans))) :: Maybe Value
13:51:08 <wagle>   Prelude.putStrLn (show (myselect ss))
13:51:12 <ertes> sphinxo: the same as: flip view
13:51:44 <sphinxo> oh ok done
13:51:48 <wagle> if myselect is the identity function, it typechecks and prints
13:53:05 <dmj`> wagle: what is the type of myselect?
13:53:14 <sphinxo> oh
13:53:22 <sphinxo> I think I understand
13:53:34 <wagle> trying this:
13:53:35 <wagle> myselect :: Maybe Value -> Value
13:53:35 <wagle> myselect' (Object x) = fromJust (lookup "ok" (HM.toList x))
13:53:35 <wagle> myselect' x = x
13:54:10 <ertes> sphinxo: you can't 'get' traversals in general, because they can focus on arbitrarily many things (including zero)
13:54:12 <wagle> oops, 
13:54:33 <wagle> thats an intermediate, but thats the type I tried
13:54:42 <ertes> sphinxo: but if what they focus on happens to be a monoid, then you can…  in that case 'get' simply mconcats everything
13:55:15 <sphinxo> Cool
13:55:26 <ertes> sphinxo: note how you never programmed that feature…  you just get it for free =)
13:55:37 <Gurkenglas> Can ghc, given a whole project, tell me what functions im not using anywhere?
13:55:46 <sphinxo> +1 and I can implement it if I want
13:55:49 <Gurkenglas> *what functions defined in the project
13:56:56 <monochrom> wagle, you should not be doing HM.toList there. You should be using HM.lookup directly.
13:57:31 <wagle> was trying to mimic this:
13:57:32 <wagle> revStrings (Object x) = let revPair (k, v) = (T.reverse k, revStrings v)
13:57:32 <wagle>                         in  Object . fromList . map revPair . HM.toList $ x
13:57:45 <wagle> just to get something to work
13:58:29 <monochrom> mimicking is a good learning method. but mimick simple comprehensible things. don't mimick complex ambitious things.
13:58:54 <wagle> yeah, i do well, though, when I get it to work, then refine
13:59:23 <wagle> but that was a failure I hadnt thrown out yet
14:00:26 <sphinxo> ertes: is that mconcat the closest I can get to folding?
14:00:59 <ertes> sphinxo: if you want to fold, i suggest you just use Foldable
14:01:16 <ertes> sphinxo: sum (fmap sum xs)  -- sum of all elements
14:02:39 <sphinxo> so implement Foldable for Vec3? ertes 
14:02:47 <sphinxo> oh wait
14:02:50 <wagle> this works, but I got inside of Object and did invasive things: 
14:02:51 <wagle> myselect x = myselect' (fromJust x)
14:02:51 <wagle> myselect' (Object x) = HM.lookup "ok" x
14:02:56 <sphinxo> it's done with magically
14:03:21 <monochrom> That means x is Maybe Value
14:03:51 <monochrom> and HM.lookup "ok" x is also Maybe Value
14:03:58 <alx741> guys, cabal allows to search hackage packages with the `list` command. Is possible to achieve something similar with stack?
14:04:05 <wagle> yeah, I coulda done that in one line
14:04:28 <monochrom> you could use the patterns Just (Object dictionary) and Nothing
14:04:30 <wagle> except I was getting odd type errors when I tried to one-line it earlier
14:05:37 <ertes> sphinxo: you can derive Foldable, Functor and Traversable
14:05:50 <monochrom> is there anywhere one can read a coherent, intact piece of code that one can reproduce what you observed?
14:05:57 <ertes> sphinxo: by virtue of that you get 'traverse' for free for your type
14:06:18 <wagle> before needlessly reducing it to one line, I was wondering if there was a better way to lookup inside an aeson Object
14:06:42 <monochrom> No.
14:06:43 <wagle> not really, the password is hardcoded and required
14:06:57 <wagle> ok, thanks!
14:07:18 <wagle> it work now
14:07:23 <wagle> it works now
14:07:34 <monochrom> Yes if you're writing FromJSON instances.
14:08:15 <monochrom> in which you write like parseJSON (Object dictionary) = dictionary .: "ok" IIRC
14:09:01 <wagle> none of the fromJSON examples did that
14:09:10 <wagle> but it sounds plausible
14:09:11 <monochrom> But it is not really going to be just dictionary .: "ok", in reality this is part of a larger thing, which depends on what FromJSON instance you're writing for
14:09:34 <monochrom> Eh? The aeson doc itself has that kind of example right at the beginning.
14:10:10 <monochrom> In fact it's the only thing I ever learned, and the doc is the only thing I ever read.
14:10:25 <monochrom> I am too proud to read someone else's "blog tutorial", you know.
14:10:52 <monochrom> And in the end it actually pays off because I don't get confused by someone else's inaccurate perspective.
14:10:59 <wagle> its written in standard haskell documentese, which I havent wrapped my brain around, for some reason
14:11:47 <wagle> i can see it makes more sense to me now though
14:11:50 <monochrom> I don't know what that means.
14:12:07 <monochrom> "parseJSON (Object v) = Person <$> v .: "name" <*> ..."
14:12:22 <monochrom> That is actual code.
14:12:39 <monochrom> Does actual code count as documentese that you don't understand?
14:12:51 <sphinxo> ertes: earlier you gave the example 
14:12:52 <sphinxo> instance Foldable V3 where
14:12:56 <sphinxo> oops
14:13:08 <sphinxo>  sum (fmap sum xs)
14:13:14 <sphinxo> How would I actually use that?
14:13:21 <wagle> sure, when it includes Person, which is a structure that I dont need an morphism of
14:13:48 <wagle> but I'm very weird, sorry
14:15:07 <monochrom> Have you finished learning that basic dumb Person example first, before you go on to tackle something more ambitious that involves morphisms and natural transformations and left Kan extensions and so on?
14:15:27 <CubicE> ertes, I've tried writing my earlier poke in terms of forM_ and runStateT, I'm not sure if this is what you were talking about earlier: https://gist.github.com/anonymous/8a0f3df6ddb88257eb1ae7f7a2d14246
14:15:37 <CubicE> It's been too long since I've written any haskell -_-
14:16:06 <ertes> sphinxo: if you have a 3x3 matrix of numbers, you can use that code to calculate its element sum
14:16:10 <wagle> i'm just trying to shave this yak..  once I can read the freaking json, then I can get real work done
14:16:19 <sphinxo> oh ok
14:16:32 <wagle> wasn't expecting it to be this involved
14:16:56 <sphinxo> I see
14:16:59 <sphinxo> Thanks again ertes 
14:16:59 <ertes> CubicE: pretty much, except that i'd use a combined 'state' rather than 'get' and 'put'
14:17:28 <ertes> :t state
14:17:29 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
14:17:40 <ertes> CubicE: i <- state (\i -> (i, i + 1))
14:18:06 <monochrom> OK, it is possible to just use decode and stick to Value and not care about FromJSON.
14:19:09 <wagle> yeah, i got the decode only to print, so I slid down that slope
14:19:31 <wagle> its all good now
14:19:55 <ertes> CubicE: note also that you can construct storable vectors from pointers in a rather straightforward way:  unsafeFromForeignPtr0
14:20:01 <joe9> How come there is no (++) in Data.Text?
14:20:06 <ertes> CubicE: then you can just use the copying mechanisms of the vector library
14:20:14 <hexagoxel> joe9: <>
14:20:15 <ertes> joe9: use (<>)
14:20:18 <dmj`> joe9: use (<>)
14:20:35 <joe9> Thanks.
14:20:36 <monochrom> (Well, you have to care enough to know that Value is a pre-made FromJSON instance so that you know decode can give you Maybe Value.)
14:20:49 <dmj`> joe9: it's a monoid
14:20:49 <dmj`>  
14:20:52 <suzu> :t WriterT
14:20:53 <lambdabot> m (a, w) -> WriterT w m a
14:20:55 <CubicE> oh
14:20:59 <CubicE> hm
14:21:12 <CubicE> you mean force?
14:21:49 <CubicE> I'm not that familiar with vector
14:21:51 <wagle> yeah, i tried that first, didnt work because I ws confused..  then I got decode to work, so I tried to extend that solution
14:21:53 <ertes> CubicE: construct a mutable vector from the destination pointer, then use Data.Vector.Storable.copy
14:22:59 <ertes> CubicE: the first step is to go from Ptr to ForeignPtr (Foreign.ForeignPtr.newForeignPtr_)  -- it's a rather trivial step
14:23:28 <ertes> CubicE: the second step is to go from ForeignPtr to a mutable storable vector (Data.Vector.Storable.Mutable.unsafeFromForeignPtr0)
14:23:39 <ertes> CubicE: the final step is Data.Vector.Storable.copy
14:23:52 <CubicE> I didn't actually know there was a difference between Ptr and ForeignPtr before o_O
14:24:22 <ertes> CubicE: a Ptr is just a raw pointer, while a ForeignPtr can have finalizers associated with it, but you don't need that here
14:24:49 <monochrom> wait a second, does Data.Vector.Storable.copy really insist in ForeignPtr?
14:25:02 <ertes> monochrom: no, but MVector does =)
14:25:13 <monochrom> yikes
14:25:29 <monochrom> Oh well, perhaps it is trivial to promote Ptr to ForeignPtr
14:25:41 <ertes> it is:  newForeignPtr_
14:25:45 <CubicE> It's a ForeignPtr in Storable even for the immutable version apparently
14:30:06 <CubicE> I must say I'm rather proud of myself to be no longer scared of functions just because they have unsafe in their name. I choose to interpret this as myself having grown in confidence rather than recklessness
14:33:43 <joe9> When trying out CorePrelude, it does not have a visible Show typeclass. Any thoughts on how I can export this ? or, If there is a coreprelude alternative?
14:33:44 <CubicE> Should I read up on what a PrismMonad is or can I ignore that for now?
14:34:14 <monochrom> Does CorePrelude even mean to provide something like Show?
14:34:45 <monochrom> Because it sounds like CorePrelude means to be minimal, and to avoid thorny questions that Show raises.
14:34:53 <joe9> monochrom: yes, that is what I am getting to. How do I use Show when using CorePrelude?
14:35:06 <joe9> monochrom: GHC.Show?
14:35:33 <joe9> monochrom: Where is the Show typeclass defined?
14:37:14 <suzu> ?src foldl'
14:37:14 <lambdabot> foldl' f a []     = a
14:37:14 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
14:37:20 <suzu> ?src foldl
14:37:20 <lambdabot> foldl f z []     = z
14:37:20 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:37:23 <CubicE> ertes, I guess I should implement peek similarly in terms of freeze then?
14:38:30 <ertes> CubicE: personally i would just avoid pointers altogether and go through the vector API
14:38:54 <ertes> CubicE: except when there is literally just a single value…  then just using 'peek' and 'poke' may be more sensible
14:39:13 <monochrom> :)
14:39:14 <CubicE> So yes?
14:39:21 <dmj`> joe9: maybe GHC.Show
14:40:51 <suzu> :i SemiGroup
14:41:01 <monochrom> lambdabot does not have :info
14:41:04 <suzu> oh
14:41:19 <suzu> ?src SemiGroup
14:41:20 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:41:21 <suzu> lol
14:41:24 <suzu> ok w/e
14:42:01 <ertes> CubicE: yes, if it's an actual array
14:42:04 <monochrom>  @src is a handwritten file, not automatically synced with current source code in use.
14:42:54 <monochrom> therefore it arbitrarily has some things and lack some other things, and for the things it has, it arbitrarily gives you real code in use or illustrative code not in use.
14:43:17 <suzu> a non-strict monad means that it is not strict in it's contained data?
14:43:29 <monochrom> for example @src sort (or is it @src sortBy) is totally not the version GHC actually uses
14:43:34 <suzu> return undefined >> a = a?
14:43:48 <suzu> ah i see monochrom 
14:43:54 <monochrom> no, there is no general "non-strict monad".
14:44:05 <suzu> Identity is claimed to be non-strict
14:44:20 <suzu> does that mean (Identity undefined) >> x = x
14:44:27 <monochrom> OK, then what you said is true for Identity
14:44:31 <suzu> ah kk
14:44:45 <suzu> > Identity undefined >> return
14:44:46 <lambdabot>      Couldn't match expected type ‘Identity b’
14:44:47 <lambdabot>                  with actual type ‘a0 -> m0 a0’
14:44:47 <lambdabot>      Probable cause: ‘return’ is applied to too few arguments
14:44:51 <suzu> > Identity undefined >> return 5
14:44:52 <lambdabot>  Identity 5
14:44:55 <suzu> yup
14:45:01 <monochrom> But this does not extrapolate to Control.Monad.State. It has a different idea of strictness.
14:45:05 <suzu> > Identity undefined >>= return
14:45:07 <lambdabot>  Identity *Exception: Prelude.undefined
14:45:08 <suzu> kk
14:45:50 <suzu> > runIdentity $ Identity undefined
14:45:51 <lambdabot>  *Exception: Prelude.undefined
14:46:28 <monochrom> the act of trying to print an answer at all increases strictness.
14:46:34 <suzu> right
14:46:55 <suzu> you would need to eval it to whnf to print it?
14:47:03 <suzu> at least whnf *
14:47:10 <monochrom> yeah
14:47:20 <hpc> whnf is the minimum non-zero amount of evaluation you can put on an expression
14:47:21 <suzu> printing a list would require you to eval each and every elem
14:47:37 <monochrom> there are exceptions like:
14:47:42 <monochrom> > undefined :: IO ()
14:47:43 <lambdabot>  <IO ()>
14:47:44 <hpc> which you can do with (`seq` ()) or something
14:47:53 <hpc> print evaluates the show result to normal form
14:47:59 <hpc> which is almost always more than whnf
14:48:07 <hpc> but as like with IO, it might be less
14:48:14 <suzu> i read somewhere that
14:48:15 <monochrom> in which the Show instance says "show _ = ..." and totally doesn't care.
14:48:24 <suzu> avg x = sum x / length x causes a space leak
14:48:27 <suzu> where is the space leak and why?
14:49:10 * hackagebot text-icu-normalized 0.1.6 - Dealing with Strict Text in NFC normalization.  https://hackage.haskell.org/package/text-icu-normalized-0.1.6 (misandrist)
14:49:12 * hackagebot xlsx 0.2.4 - Simple and incomplete Excel file parser/writer  https://hackage.haskell.org/package/xlsx-0.2.4 (KirillZaborsky)
14:49:26 <monochrom> I hate the term "space leak"
14:49:27 <hpc> what kind of "leak" are they talking about?
14:49:46 <hpc> perhaps they mean sub-optimal space complexity?
14:49:47 <monochrom> but it leaks or not leaks depending on context.
14:50:14 <hpc> it's likely O(n) space for how it uses x
14:50:20 <monochrom> which, scientifically speaking, implies that it does not leak, ever. Some contexts leak.
14:50:22 <hpc> but if you're carrying x around anyway that's not even an issue
14:50:46 <hpc> if you expect x to be normal form, avg is effectively O(1) because it doesn't consume additional space you weren't anticipating anyway
14:50:49 <suzu> what's a better term for "space leak" monochrom ?
14:51:01 <monochrom> memory inefficient
14:51:02 <joe9> dmj`: Thanks.
14:51:12 <suzu> ah okay
14:51:19 <suzu> so, avg x is memory inefficient .. why?
14:51:26 <monochrom> No one has ever said "time leak".
14:51:36 <suzu> if i already have x in normal form then it won't incur a crazy cost
14:51:39 <suzu> as hpc says
14:51:43 <monochrom> Correct.
14:51:58 <suzu> what if i don't?
14:52:07 <suzu> then it just evaluates all of x and that may or may not be what i want?
14:52:21 <monochrom> avg [1 .. n] is where you see Theta(n) space but you know of another algorithm that uses Theta(1) space.
14:52:43 <suzu> ?
14:52:46 <hpc> suzu: if you plan on throwing away x after averaging it, then the other part of what i said
14:53:16 <suzu> avg will use O(n) space on top of the cost of holding all of x in memory?
14:53:24 <monochrom> OK, first you need to figure out that avg [1..n] uses Theta(n) space.
14:53:27 <implementation> a memory leak (or space leak) is not simply memory inefficience, but reserved memory that does not get freed. it is not possible that time isn't freed. that's why there is no such term as a "time leak"
14:53:56 <suzu> i don't know why it will use O(n) space
14:53:57 <hpc> or in another sense, time is already leaking at one second per second
14:54:04 <suzu> on top of holding x
14:54:55 * wagle , on the other hand, leaks at least 2 seconds per second
14:55:06 <monochrom> "reserved memory is not freed" is a tautology.
14:57:04 <implementation> no, it's not. the memory may at one time t be reserved, but at some other time t' freed. this is possible.
14:58:02 <monochrom> That is just moving goal posts.
14:58:38 <monochrom> Let x refer to the expression [1..n]. At the beginning, it is unevaluated yet, and it takes little space.
14:59:26 <monochrom> You evaluate sum x. That requires evaluating all of the details of x. And then here is the thorny part:
14:59:41 <CubicE> ertes, I did away with all the manual peeking and poking. I _think_ this might be better now. It certainly gives off this dangerous "Don't touch this, you'll break things" vibe though: https://gist.github.com/anonymous/8ec32d5353add3208bb918d9126e297d
14:59:45 <CubicE> Thanks for all the help
14:59:49 <monochrom> You also have a "length x" to evaluate later. Therefore, all the details of x has to be retained until then.
15:00:10 <monochrom> So this takes Theta(n) space.
15:01:19 <implementation> monochrom: if the memory is freed after `length x`, this is not a leak. if it remains reserved even if it is not required any more (this should not happen with garbage collectors), it is a leak.
15:01:37 <koz_> What's the GHC extension magic that allows me to have two records with 'foo' as a member again?
15:02:27 <dmj`> koz_: DuplicateRecordFields ?
15:02:36 <koz_> dmj`: That'd be it - thank you!
15:03:50 <monochrom> Actually, read my http://www.vex.net/~trebla/haskell/lazy.xhtml , it discusses sum x / length x at the end.
15:04:19 <suzu> ahhhh
15:05:16 <suzu> > const 5 undefined
15:05:17 <lambdabot>  5
15:05:36 <monochrom> implementation: I agree with you. But do you know that the world outside actually says that "sum x / length x leaks"? It's why I hate about the term, at least their use of the term.
15:06:20 <monochrom> Basically if they don't understand something they call it a space leak.
15:06:43 <monochrom> Rather than the Netscape kind.
15:07:17 <implementation> yes, that's really a bad and incorrect use
15:07:45 <suzu> > 3 + undefined
15:07:46 <lambdabot>  *Exception: Prelude.undefined
15:10:11 <implementation> but I don't understand why this happens. most people who learn haskell do know some imperative languages before. and (I think) in most imperative languages the difference between a leak and inefficience is really obvious... there is no reason why this would be different in Haskell
15:10:43 <bbielsa> ░█▀▄░█░█░█▀█░░█▀▀░▀█▀░█▀▀░█▀█░
15:10:46 <bbielsa> ░█░█░█░█░█▀▀█░▀▀█░░█░░█▀▀░█▀▀░
15:10:51 <bbielsa> ░▀▀░░▀▀▀░▀▀▀▀░▀▀▀░░▀░░▀▀▀░▀░░░
15:10:53 --- mode: ChanServ set +o glguy
15:10:54 --- kick: bb010g[m] was kicked by glguy (bb010g[m])
15:10:56 --- kick: bbielsa was kicked by glguy (bbielsa)
15:11:07 <glguy> sorry, bb010g[m]
15:12:58 <suzu> how can you efficiently write average?
15:13:53 <implementation> probably with a custom fold
15:14:11 <suzu> makes sense
15:14:23 <bbielsa> sorry for the dubstep
15:14:24 <implementation> the point is that you should only traverse the list one time, not two times
15:14:47 <suzu> so just do it in a single strict fold
15:15:01 <suzu> so it can 'forget' the list as it evaluates
15:15:07 <suzu> and won't consume O(n) memory
15:15:41 <implementation> exactly
15:15:43 <monochrom> Yeah. But you have to be superstrict in the accumulator. If not, you're still use Theta(n) memory, this time for the unevaluated build-up of "1+2+3+...+n"
15:15:58 <suzu> so use foldl'?
15:16:20 <monochrom> foldl' is necessary but not sufficient.
15:16:40 <suzu> is foldl' not strict in the accumulator?
15:16:47 <monochrom> Imagine you use (<the sum so far>, <the length so far>) as your accumulator.
15:16:56 <suzu> ?src foldl'
15:16:56 <lambdabot> foldl' f a []     = a
15:16:56 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:16:59 <suzu> ok
15:17:22 <monochrom> the thing is:
15:17:31 <monochrom> > seq (undefined, undefined) "hello"
15:17:32 <lambdabot>  "hello"
15:17:34 <suzu> ahhh if the accumulator is a tuple
15:17:39 <suzu> the whnf of that is (_,_)
15:17:43 <suzu> and that's not good enough
15:17:55 <suzu> you can still have massive thunks hiding in there
15:18:13 <monochrom> So you need to write your own "data Whee = W !Int !Int" and then you'll be OK.
15:18:26 <suzu> could we alternatively write
15:18:39 <implementation> > \(!a,!b) -> a+b
15:18:40 <suzu> a' `seq` fst a' `seq` snd a' ..
15:18:40 <lambdabot>  <(Integer,Integer) -> Integer>
15:18:42 <monochrom> Actually there is a way without your own Whee type.
15:18:49 <implementation> shouldn't this be strict?
15:19:37 <monochrom> Write the whole foldl' expression, then I will be able to see more clearly.
15:20:22 <suzu> foldl' f a (x:xs) = let a' = f a x in a' `seq` fst a' `seq` snd a' `seq` fold' f a' xs
15:21:39 <monochrom> I think foldl' (\(!a, !b) c -> (a+c, b+1)) works
15:21:50 <suzu> oh just make f strict in it's args?
15:22:05 <ertes> CubicE: note that you're basically reinventing V from the 'linear' library
15:22:07 <suzu> and strict in the contained data in the tuple
15:22:22 <suzu> your soln is 999x cleaner lol
15:22:29 <monochrom> also foldl' (\(a,b) c -> a `seq` b `seq` (a+c, b+1))
15:22:45 <suzu> right, rewriting the ! into `seq`
15:22:46 <monochrom> ! in patterns requires the BangPatterns extension
15:22:54 <zort> are there any libraries for statically-lengthed data structures that use GHC type literals other than Sext? ( http://hackage.haskell.org/package/sext-0.1.0.2/docs/Data-Sext.html )
15:23:02 <suzu> does seq have a definition or is it ghc magic
15:23:29 <monochrom> it is magic. but not just GHC. every Haskell compiler is required by Haskell 2010 to have this magic.
15:23:32 <ertes> CubicE: V has interesting semantics: it's a regular boxed vector, unless you use it in a Storable context, at which point it collapses into an unboxed array in memory
15:24:01 <ertes> CubicE: the advantage is that it comes with all the usual instances:  Applicative, Foldable, Functor, Traversable, …
15:24:12 * hackagebot directory 1.2.7.0 - Platform-agnostic library for filesystem operations  https://hackage.haskell.org/package/directory-1.2.7.0 (Rufflewind)
15:24:32 <monochrom> But if you know whnf then you know at least what this magic accomplishes, even though not always how it is implemented.
15:24:42 <implementation> suzu: but almost every magic thing also has a definition (see IO). just don't assume that the definition handles every single aspect of the magic
15:25:00 <suzu> IO has a definition? beyond some RealWorld# state thing?
15:25:06 <monochrom> at which point it is an abstraction, not a magic
15:25:24 <zort> ertes: what's V?
15:25:49 <monochrom> (And if the abstraction leaks, then it is not magic, it's a goof up :) )
15:25:50 <ertes> zort: a vector type indexed by dimensionality
15:25:56 <zort> link?
15:26:05 <ertes> zort: V 11 Double  -- an 11-d vector of Double
15:26:12 <glguy> monochrom: your first "foldl' (\(!a, !b) c -> (a+c, b+1))" basically works but is slightly too lazy in the sum
15:26:15 --- mode: glguy set -o glguy
15:26:17 <zort> sounds like what I need
15:26:31 <ertes> zort: https://hackage.haskell.org/package/linear-1.20.5/docs/Linear-V.html
15:26:36 <suzu> the sums must also be strict?
15:26:36 <CubicE> ertes, I get the impression that literally everything I do when using haskell is reinventing something someone else has already written
15:26:38 <zort> ah yes that thing
15:26:40 <bb010g[m]> glguy (IRC): What? I feel like there's context I'm missing.
15:26:51 <glguy> bb010g[m]: tab completion misktake
15:26:52 <glguy> strictPair :: a -> b -> (a,b)
15:26:53 <glguy> average xs = foldl' (\(a, b) c -> strictPair (a+c) (b+1)) (0,0) xs
15:27:11 <bb010g[m]> Oh. No problem. :)
15:27:11 <ertes> CubicE: yeah, i know the feeling =)
15:27:15 <wagle> how do you hoogle again?
15:27:16 <glguy> allows GHC to unbox both sums
15:27:30 <implementation> suzu: that realworld state thing is a definition. but it varies from compiler to compiler (compare ghc IO and uhc IO for example) and it doesn't really cover the magic aspect of IO (as said) :)
15:27:40 <suzu> uhc
15:27:42 <suzu> what
15:29:06 <implementation> suzu: the Utrecht Haskell Compiler
15:29:12 * hackagebot hgeos 0.1.7.3 - Simple Haskell bindings to GEOS C API  https://hackage.haskell.org/package/hgeos-0.1.7.3 (rcook)
15:29:13 <monochrom> you know what, import Control.DeepSeq (force) and use foldl' (\(a,b) c -> force (a+c, b+1))
15:29:29 <suzu> oh
15:29:37 <implementation> suzu: https://github.com/uhc/uhc/blob/master/EHC/ehclib/uhcbase/UHC/Base.chs#L2119
15:31:36 <implementation> fun fact:       x `seq` y = let !x' = x in y
15:33:02 <zort> ertes: so just to be clear, the dimension is known at compile-time, but not the size, right?
15:33:53 <ertes> zort: uhm…
15:34:13 <monochrom> bang patterns are actually a bit subtle. the average use cases are obvious, but there are subtle corner cases.
15:34:26 <zort> size is number of elements it contains
15:34:36 <zort> volume
15:34:39 <ertes> zort: so is the dimensionality
15:35:01 <ertes> a (V n a) has exactly 'n' elements of type 'a'
15:35:21 <zort> how do you express a 100d vector?
15:35:32 <zort> what's the type of a 100-d vector I mean?
15:35:57 <ertes> V 100 A
15:36:03 <zort> oh
15:36:28 <monochrom> 100 volts and 0.5 amperes
15:37:06 <zort> by dimensionality I thought you meant
15:37:19 <zort> matrices have dimensionality 2
15:37:49 <zort> do you know any examples of usage of this library?
15:38:20 <ertes> zort: ah, no…  i'd call that the 'order'
15:38:32 <ertes> from tensor terminology
15:38:56 <ertes> pretty much all functions that work with the fixed-size vector types should work with V as well
15:39:43 <zort> what fixed-size vector types?
15:40:40 <ertes> V1, V2, V3, V4
15:42:13 <zort> alright thank you
15:43:03 <zort> I passed over this library earlier probably because I didn't know it statically encoded the size
15:48:43 <zort> Storable, Serial, AND Serialize instances
15:49:59 <zort> also Binary
15:51:04 <whiteline> we are two dudes who worked on some code here and we are wondering why << isn't in the standard monad code like =<< is?
15:51:22 <whiteline> it makes writing do-free code so much nicer?
15:51:35 <_wraith0> hello
15:51:37 <whiteline> (can implement it as liftM2 const a b or whatever)
15:52:06 <glguy> whiteline: <* and *> are available
15:52:08 <hpc> it's not clear what order the effects should be in
15:52:22 <hpc> and yes, you should be using the applicative versions
15:53:38 <whiteline> hpc: implicitly, right to left
15:53:44 <whiteline> and thank you yes those work
15:54:08 <glguy> whiteline: If you use liftM2 const, you're ordering them left to right
15:54:49 <whiteline> glguy: certainly, but i defined it as b << a = ... though
15:55:22 <glguy> whiteline: In that case the wrong result would have been returned
15:56:35 <whiteline> *a << b
15:56:43 <whiteline> thought wrong, wrote right
15:56:51 <whiteline> nvm, the code works
16:03:20 <zort> does anyone study Haskell like they study math? because many tutorials come with exercises, and I'm like, "No, I don't care whether I can solve your exercise, as long as I can figure out how to write this program it doesn't matter."
16:03:50 <glguy> The exercises are there to give you a chance to actually learn the thing you just read about
16:04:07 <zort> but why would I read about it if I didn't have something I wanted to apply it to
16:04:35 <zort> or do people read about haskell without immediately having something to apply it to?
16:05:50 <glguy> It's probably both that they're just interested in learning about a particular topic, or the actual problem is complicated enough that exploring a simpler one first helps. It's probably going to be hard to have this discussion in the abstract though. Is there a particular tutorial you're referring to?
16:07:45 <zort> glguy: https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell like this one
16:09:20 <jakeehrlich> Does GHCJS support unsafeIO and unsafeInterleaveIO?
16:13:09 <implementation> glguy: in many situation you don't really know that concept X applies/is relevant, unless you studied concept X before. this is why waiting for the right moment often misses the point. in the right moment, you won't know it's the right moment.
16:13:33 <zort> I see
16:14:03 <implementation> sorry glguy, i wanted to highlight zort
16:14:28 <zort> though you don't really need to understand something deeply
16:14:30 <zort> to know it exists
16:15:09 <implementation> the knowledge that something exists often does not help you
16:15:15 <wagle> inquiring minds need to know what the heck "do let foo <- baz" means?
16:15:28 <wagle> it apparently parses
16:15:34 <hydraz> is that even valid syntax?
16:15:41 <geekosaur> that is invalid syntax
16:16:02 <wagle> yeah, I figred out what I did
16:16:36 <implementation> a simple example: if you just know that monads exist, you won't notice your new type is one of them. or an applicative. or an arrow. or a comonad. you need to know exactly what that is to recognize them.
16:16:49 <hydraz> Gives me an error here, wagle
16:16:51 <mauke> > do let {}; [()]
16:16:52 <lambdabot>  [()]
16:17:29 <wagle> I cut and pasted wrong, sorry for the interruption
16:23:55 <wagle> yak half done!
16:44:27 <koz_> How do you get optparse-applicative to allow both short *and* long opts? Just make two parsers?
16:47:21 <kadoban> koz_: (long "verbose" <> short 'v' <> help "Whatever") -- is that what you mean?
16:49:19 <kilimanjaro> I just installed haskell platform and then tried to install a cabal package, which warns me that packages are likely to be broken: http://pastebin.com/raw/bRXZDWgi
16:49:39 <kilimanjaro> They look like older versions, but I'm not sure what I should do in this situation
16:49:57 <kilimanjaro> (I haven't used cabal or haskell much)
16:50:20 <kadoban> kilimanjaro: This is kind of why Haskell Platform sucks. I'd recommend you use haskell "stack" instead, which is a program that can build projects for you, and automatically install GHC as it needs, and etc.
16:50:49 <kadoban> kilimanjaro: https://docs.haskellstack.org/en/stable/README/#how-to-install
16:51:01 <geekosaur> they;re newer versions. haskell devs don't believe in stability
16:52:06 <hpc> kilimanjaro: if you're on windows stack is absolutely the way to go; it looks like you're using OSX though so perhaps just go with a straight install of ghc and cabal
16:52:17 <kilimanjaro> yes, osx
16:52:18 <hpc> then you can install whatever versions you want of the supplementary packages
16:52:30 <kilimanjaro> i'll check out stack, thanks
16:52:32 <hpc> and you can do a sandboxed install of gloss so it's not interfering with anything else you have either
16:52:58 <hpc> stack has some tradeoffs as far as what you can and can't do
16:53:09 <hpc> largely it comes down to it being hard to do things once you're off of stack's "rails"
16:53:26 <hpc> or it just being tedious to do things like add dependencies to a project after the fact
16:53:52 <hpc> sometimes it's worth it for the reproducable builds aspect, or you just won't hit those sorts of issues
16:53:55 <hpc> just things to be aware of
16:53:58 <kadoban> ? It's not tedious at all to add dependencies to a project in stack.
16:54:13 <hpc> kadoban: you have to add them twice, once in the stack.yaml and again in the .cabal file
16:55:02 <kadoban> hpc: In the vast majority of cases, you only need to add them to the .cabal file. In the other cases, it tells you exactly what to do in the vast majority of cases. I wouldn't call adding a line to 1 file, possibly 2 "tedious"
16:55:19 <hpc> it's multiple steps is the point
16:55:29 <hpc> and it annoys me :P
16:55:49 <kadoban> Yet installing cabal-install and ghc manually and dealing with sandboxes manually doesn't? Whatever floats your boat.
16:56:11 <hpc> you do it once and you have a whole environment for whatever projects you're doing
16:56:17 <hpc> and you can apt-get install ghc cabal
16:56:24 <hpc> or whatever
16:57:04 <hpc> i haven't had much trouble with sandboxes, even before it was integrated into cabal proper
16:57:54 <kadoban> hpc: OS packages of GHC and cabal-install are usually terribly old, or just terrible. So the only good way I ever found to do it was actually manually ... which I got good at because you end up having to do it again every few weeks when installing libraries magically breaks, even if using sandboxes.
16:58:09 <hpc> ah, that changes things then
16:58:11 <hpc> i don't use OSX
16:58:29 <kilimanjaro> i'll try stack
16:58:33 <kadoban> I don't either, apt-get isn't OSX though, is it? That was what I was referring to.
16:59:12 <hpc> "apt-get" was a placeholder for brew, yum, pacman, etc
17:00:30 <hpc> karshan: apt-get is debian/ubuntu's version of brew, just a package manager
17:00:47 <hpc> they're all more or less the same
17:01:00 <hpc> except for pacman which has baffling shorthand options that everyone uses in documentation for some reason
17:01:46 <hpc> that's just UI though
17:01:59 <koz_> OK, I don't quite understand the example for custom readers given here: https://github.com/pcapriotti/optparse-applicative
17:02:31 <koz_> Shouldn't parseFluxCapacitor have type 'String -> ReadM FluxCapacitor'?
17:04:37 <hpc> koz_: it'll still work and when parseFluxCapacitor is used it'll decide m = ReadM
17:04:42 <hpc> koz_: but it's a bit weird to show it that way
17:04:51 <hpc> so i can see the confusion
17:05:18 <koz_> hpc: So what should I use?
17:05:31 <koz_> And how would I indicate a 'bad' value with a fully-general Monad?
17:05:58 <hpc> what i mean is
17:06:00 <hpc> option :: ReadM a -> Mod OptionFields a -> Parser a 
17:06:17 <hpc> and (ReadM a) unifies with (Monad m => m a)
17:06:36 <hpc> so in practice you should just give it a ReadM parser thingy
17:07:00 <hpc> and then you just use whatever ReadM provides
17:07:25 <hpc> which is probably readerAbort or readerError
17:07:30 <hpc> https://hackage.haskell.org/package/optparse-applicative-0.12.1.0/docs/Options-Applicative-Builder.html#t:ReadM
17:07:34 <koz_> hpc: I get *that*.
17:07:52 <koz_> I meant 'suppose I followed the advice here and wrote against Monad instead - how to indicate failure?'.
17:07:56 <hpc> with a fully general one, you'd probably use fail and hope ReadM's instance defines it nicely
17:07:59 <hpc> :t fail
17:08:00 <lambdabot> Monad m => String -> m a
17:10:09 <koz_> hpc: Ah, OK. I forgot fail was a thing.
17:10:21 <koz_> Why would you wanna code something like that against Monad though?
17:10:48 <Clint> fail has its own package now
17:11:36 <hpc> koz_: you wouldn't
17:11:40 <koz_> Clint: Is the module you import also called 'fail'?
17:11:44 <hpc> and yeah, it's easy to forget fail is a thing
17:11:48 <koz_> hpc: Should I report this as an issue then?
17:11:50 <hpc> because it's a terrible thing that should be forgotten
17:12:10 <Clint> koz_: https://hackage.haskell.org/package/fail-4.9.0.0/docs/Control-Monad-Fail.html
17:12:45 <koz_> Clint: Ah, OK.
17:12:48 <hpc> koz_: maybe - it's just a documentation issue but it's also about a 10-byte fix so there's not really much harm in suggesting it
17:12:56 <koz_> hpc: OK, I'll suggest it.
17:14:18 * hackagebot pinchot 0.20.0.0 - Write grammars, not parsers  https://hackage.haskell.org/package/pinchot-0.20.0.0 (OmariNorman)
17:17:04 <ahsfhyicxv> Can anyone here answer this stackoverflow question?
17:17:06 <ahsfhyicxv> https://stackoverflow.com/questions/38808804/map-of-gtype-to-function-transforming-a-type-to-an-io-string
17:17:53 <dmj`> ahsfhyicxv: where is gType from ?
17:18:04 <ahsfhyicxv> ghcjs-dom
17:19:31 <dmj`> ahsfhyicxv: not sure you need to be working directly with those types
17:20:40 <dmj`> ahsfhyicxv: what would the string representation of an element look like that has a dom reference?
17:21:36 <dmj`> ahsfhyicxv: it seems like you're trying to create a json object out of a Node
17:22:06 <ahsfhyicxv> dmj': Img, video, … would be the src prop, meta would be content prop, time would be datetime prop
17:22:40 <ahsfhyicxv> innerText would be the fallback
17:23:03 <dmj`> ahsfhyicxv: what would 'parent' be? :)
17:23:38 <dmj`> ahsfhyicxv: I think what you want is to make a FromJSVal instance
17:24:01 <moon__> just a minor question: why does Haskell permit recursive variables? Thats just a good way to crash and nothing else
17:24:13 <soulisson> I would like to learn about functional programming is haskell a good choice?
17:24:15 <moon__> like it lets foo = foo
17:24:20 <moon__> It is soulisson 
17:24:35 <glguy> moon__: for all the cases where it's not a mistake
17:24:46 <moon__> And where would it have use?
17:24:53 <soulisson> in what context functional programming is better than the other programming paradigms?
17:24:56 <dmj`> ahsfhyicxv: I'd check out the Object API in ghcjs-base
17:25:10 <glguy> recursive functions, cyclic data structures
17:25:22 <moon__> Ah
17:25:58 <soulisson> I don't see functional programming use that often but I'm still interested in learning it
17:26:03 <dmj`> soulisson: haskell is a great choice
17:26:17 <jesus_uncle> hello
17:26:26 <samsepi01> jesus_uncle: hi!
17:26:27 <dmj`> soulisson: facebook uses ghc haskell to process 1M req/s, all instagram / fb spam fighting touches haskell code
17:26:36 <dmj`> it's used heavy
17:26:42 <samsepi01> oh wow
17:27:09 <soulisson> dmj`, ok, good to know
17:27:31 <jesus_uncle> is there anything "anonymous datatypes" in haskell? like c# anonymous classes
17:27:43 <jesus_uncle> anything like *
17:28:03 <dmj`> jesus_uncle: a tuple might be the closest thing
17:28:19 <dmj`> but there are no anonymous records
17:30:10 <ahsfhyicxv> dmj`: Here is js code very similar to what I am trying to achieve https://github.com/hubgit/jquery-microdata/blob/gh-pages/jquery.microdata.js#L133
17:32:51 <dmj`> ahsfhyicxv: are you trying to reimplement this library, ffi into it, or just showing me this code as an example of how attributes can be retrieved on dom nodes
17:33:45 <ahsfhyicxv> dmj`: I am trying to implement a library similar to it
17:36:47 <dmj`> ahsfhyicxv: ok, I'd use GHCJS.DOM.Node.nodeName then pattern match in haskell on that
17:37:13 <ahsfhyicxv> dmj`: Ok that was plan B
17:37:25 <ahsfhyicxv> thanks for your help
17:37:44 <dmj`> ahsfhyicxv: yea, I'd stay in haskell as much as you can
17:42:38 <samsepi01> testing testing (ignore me)
17:49:20 * hackagebot language-dockerfile 0.1.2.0 - Dockerfile linter, parser, pretty-printer and embedded DSL  https://hackage.haskell.org/package/language-dockerfile-0.1.2.0 (yamadapc)
17:53:22 <wagle> is there something like printf, but for formating strings without printing them out?
17:53:46 <glguy> printf
17:53:48 <wagle> Text-Printf-Safe that is
17:54:24 <glguy> Text.Printf does that, too
17:54:42 <dmj`> printf is like printf
17:55:31 <wagle> dont want it to be printed
17:55:42 <glguy> OK, use printf then
17:56:00 * wagle blinks
17:56:13 <dmj`> :t printf
17:56:14 <lambdabot> PrintfType r => String -> r
17:56:46 <wagle> yeah, it cleverer than I thought
17:57:04 <ontop> Any help with ExceptT. I just can't seem to figure it out myself. http://lpaste.net/2463161906009997312 I'm trying to make it easy to deal with errors like it would be if I only had the Either monad going on. But IO.. that jerk, it messed up everything!
17:57:16 <ontop> Face deep in the ExceptT - and getting nowhere fast now :(
17:58:06 <dmj`> ontop: do you have a type error message?
17:58:16 <ontop> It's just a string currently.
17:58:25 <ontop> All of the helper methods return some string to indicate what happened.
17:58:30 <ontop> Text - is the type
17:59:00 <dmj`> ontop: ok one thing, line 83, you're inside ExceptT, so since it's a transformer, if you want to call IO functions, you'll have to use liftIO
17:59:17 <dmj`> liftIO getArguments, etc
17:59:24 <ontop> Right. Okay, I was trying it
17:59:38 <ontop> But I put it at the wrong level - let me try that
18:00:03 <ontop> Okay, now I think I see another problem.
18:00:20 <ontop> All my little functions return a different type for success.
18:01:45 <ontop> dmj`: You were correct. liftIO in front of each of the functions got me further, thanks for that. I had previously tried: liftIO $ do
18:01:52 <ontop> And that didn't have great results lol.
18:02:38 <dmj`> ontop: so, if you want to use ExcepT, then change all your IO (Either e a) actions to ExceptT e IO a
18:03:12 <ontop> That's kinda what I thought I'd have to do. But that won't work because they have different return types, right? (a would be different)
18:03:19 <dmj`> ontop: right now you have 3 IO functions and one ExceptT that just performs liftIO on these three, but you're really not using throwE 
18:03:40 <dmj`> ontop: 'a' being different is fine
18:03:49 <ontop> Because monads and >>=?
18:03:52 <dmj`> ontop: e has to be the same though
18:03:58 <ontop> Right, I can do that much.
18:03:58 <ontop> Let me try.
18:04:18 <dmj`> IO (Either Text [Repository]) -> ExceptT Text IO [Repository]
18:04:30 <ontop> Yea
18:04:31 <dmj`>  IO (Either Text Auth.Auth) -> ExceptT Text IO Auth.Auth
18:04:34 <ontop> Doing that right now
18:04:34 <ontop> :)
18:05:11 <ontop> Okay. Now I'm gonna need a whole pile of liftIO I think.
18:05:54 <dmj`> liftIO getArgs >>= \args -> case null args of True -> throwError "Must provide at least one argument"; False -> pure $ pack (head args)
18:06:50 <ontop> I got the first function free of errors now.
18:06:54 <ontop> Had to remove all my Either stuff
18:06:58 <ontop> In favor of throwE/return
18:07:05 <ontop> Moving on to next fn
18:08:44 <ontop> "Adds exceptions to other monads", m is the inner Monad. So IO is my "inner" type
18:08:54 <dmj`> ontop: right, just know that ExceptT isn't performing any exception handling here
18:09:30 <ontop>   args <- liftIO System.Environment.getArgs
18:09:33 <ontop> This line confuses me some.
18:09:42 <ontop> Why do I have to liftIO if it's an IO wrapped function?
18:09:45 <ontop> Is it because I'm binding it?
18:10:23 * ontop has to study lift one more time
18:10:27 <dmj`> ontop: the monad you're in is ExceptT, so you have to lift that operation into the base monad, which is IO
18:10:35 <dmj`> hence, liftIO
18:10:54 <ontop> Seems counter-intuitive to call it lift. In my head it's like a drop. Since IO is the "inner" monad.
18:10:59 <ontop> From what the docs say.
18:11:25 <ontop> Depends which way you draw the diagram I guess ^_^
18:11:49 <dmj`> ontop: sure, inner does seem to suggest 'bottom'
18:12:16 <wagle> howcome this hides Prelude.++?
18:12:18 <ontop> Alright. I'm rockin'. All my methods are ExceptT Text IO X now.
18:12:18 <wagle> import Data.Vector hiding (++)
18:12:18 <wagle> \
18:13:19 <wagle> nevermind, hallucinaing again
18:14:18 <ontop> dmj`: Should I use runExceptT?
18:14:40 <dmj`> ontop: yea, you'll have to
18:15:00 <dmj`> ExceptT is a constructor, you'll need to unwrap it to get IO, which main needs to run your code
18:15:51 <ontop> Which is what runExceptT does for me, right?
18:17:39 <dmj`> runExceptT :: ExceptT e m a -> m (Either e a)
18:17:45 <dmj`> ontop: right
18:19:32 <dmj`> ontop: the mtl docs have an example that you might find pertinent, https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html
18:19:38 <dmj`> bottom of page
18:34:46 <wagle> whats the idiom for checking to see if a file exists before getFileStatus'ing it? (which produces a fatal error)?
18:35:09 <wagle> I'm not seeing how to do this with do notation
18:35:25 <glguy> catch the error and handle it if it says that it doesn't exist
18:36:18 <glguy> you can use try from Control. Exception
18:36:32 <wagle> eeee  exception handling in haskell!  might as well, using every other feature for the first time
18:39:03 <nitrix> glguy: As I understand it, is the main motivation for IO exceptions to lighten types a little bit?
18:39:39 <nitrix> As opposed to the various IO functions to return Eithers or Maybes.
18:42:11 <glguy> I suppose the errors are expected to be uncommon and to be things you'd want to handle in bulk rather than typically uniquely per call site, another possible reason is that offers a faster (performance) fast path
18:44:23 * hackagebot hgeos 0.1.7.4 - Simple Haskell bindings to GEOS C API  https://hackage.haskell.org/package/hgeos-0.1.7.4 (rcook)
18:46:00 <glguy> wagle: regarding the particular "idiom" around checking if a file exists before operating on it, you can't check ahead of time because the file might disappear between the time you check and the time you access it
18:46:27 <wagle> yeah, i decided to punt on races like that
18:46:34 <glguy> so when it comes to querying, accessing, or manipulating files you'll have to try to do the operation and then handle failure
18:47:25 <wagle> right now, I'm trying to check the last modification tiime before re-downloading
18:47:44 <wagle> already a race there
19:06:01 <davean> wagle: can't you use a conditional header?
19:06:18 <davean> Why not just If-Modified-Since?
19:06:19 <wagle> davean: whazzat?
19:06:36 <davean> no race condition then, its one operation
19:07:44 <wagle> my haskell is very rusty, and haskell has moved on twice
19:08:00 <suzu> moved on twice?
19:08:23 <wagle> two major releases since I last used haskell
19:08:51 <davean> thta has nothing to do with haskell
19:09:09 <wagle> just explaining why I dont know current things
19:10:24 <davean> but it has nothing to do with haskell
19:10:42 <suzu> haskell on the whole has not changed much from haskell98
19:11:17 <suzu> typeclasses are still defined and work the same way
19:11:19 <suzu> same with fn defns
19:11:21 <suzu> etc etc
19:11:39 <suzu> the only really new stuff i think is just the plethora of ghc extensions
19:12:05 <suzu> and some changes with Traversal / Foldable / Applicative etc
19:12:58 <wagle> i was not complaining
19:13:47 <mDuff> If building a library against ghc 8.0.1, is it ever expected for a *.conf file to be created in /opt/local/lib/ghc-7.8.3/package.conf.d/? If not, where would I look to understand/fix this?
19:15:48 * mDuff inspects his system's ghc-pkg entrypoint, and observes that it's hardcoding /opt/local/lib/ghc-8.0.1, as one would expect.
19:17:18 <geekosaur> conceivably your PATH has the wrong ghc-pkg on it somewhere
19:17:43 <geekosaur> linux/os x: type ghc-pkg
19:17:48 <geekosaur> windows: where ghc-pkg
19:18:42 <geekosaur> (and beware of things other than "type" on unix-likes, as they can report what the next shell you start will see instead of what your current shell sees)
19:18:53 <mobilemobile> true
19:19:04 * mobilemobile looks for avi__
19:20:14 <geekosaur> ...although in this case it's being run by cabal or stack (or Setup.hs conceivably) so that might even be more correct, since it won't have your current shell's path cache
19:47:13 <ontop> Aw dmj` is gone. I wanted to thank him for helping me out with ExceptT and allowing me to defeat my staircase of case statements.
20:00:15 <ontop> Alright. Github StarCounter is done. Now what do I make in Haskell?
20:00:30 <ontop> Monad Transformers nearly killed me. But I did it.
20:01:01 <suzu> make a program to play pokemon go for you
20:01:11 <ontop> :|
20:01:24 <suzu> i'm not kidding
20:01:50 <ontop> I think I'll try to fix my text table-layout library.
20:01:57 <ontop> That thing got into a horrifying state.
20:04:38 <joe9> Are Show and Read the only choices for text serializing? I want to be able to write out a data structure to file and then read it back in later.
20:06:23 <geekosaur> the only ones present in a basic Haskell installation --- although text serializing is usually less than ideal anyway
20:06:43 <geekosaur> there are packages to serialize via JSON or YAML, etc.
20:06:54 <suzu> joe9: you can use Data.Binary
20:06:55 <geekosaur> also binary serialization (binary or cereal)
20:06:58 <suzu> or cereal
20:07:00 <suzu> yeah
20:07:22 <joe9> geekosaur:  Thanks, that is a good idea. Can check out JSON or YAML.
20:07:40 <tnks> I'm pretty sure that a call to Stack finds the closest stack.yaml and uses that; is it at all possible to have it overlay stack.yamls that it finds in parent directories?
20:07:40 <geekosaur> aeson is the most widely used package for JSON, fwiw
20:07:45 <sm> also TOML
20:07:53 <ontop> TOML rocks :D
20:07:53 <joe9> suzu, I cannot do Data.Binary. I would like to be able to read the file
20:08:07 <joe9> what is TOML?
20:08:37 <ontop> joe9: It's great for config files, that's about it. Like an upgraded .ini that has maps etc.
20:08:43 <ontop> It's not a good idea for data interchange
20:08:48 <sm> http://hackage.haskell.org/package/toml says "Whiskey-driven YAML replacement" :)
20:09:00 <sm> I think I'd pick htoml
20:09:02 <ontop> For that stick to json/msgpack/protobufs.
20:09:13 <ontop> sm: I used htoml for two projects recently. It's not bad ^_^
20:09:38 <sm> sounds great
20:10:00 <joe9> If I can use JSON, I can use Protolude.
20:10:39 <joe9> I am debating Protolude vs BasicPrelude. BasicPrelude has show and read. whereas , Protolude does not.
20:14:57 <ontop> Question: Is it possible to nest many Monad transformers?
20:15:22 <alercah> yes
20:16:27 <suzu> yeah you can go to the moon with them
20:17:06 <ontop> Are typical programs usually a mess of nested ones?
20:17:09 <ontop> It seems like they'd boil down to be
20:17:20 <ontop> StateT, ExceptT, IO, a mishmash of such.
20:17:54 <wagle> ETOOMUCHGENERIC
20:18:36 * wagle is busy scrubbing his malfunctioning program clean of generics to see if that makes it work
20:20:09 <wagle> (Text vsString mostly, I think, plus encodings)
20:25:37 <joobus> Question:  I've been writing a simple json parsing program, and I've been using lens so far.  I'm now to the point where I've gotten a nested list of things from the json, and now I want to map those into an Entry data type.  I've been trying to write a FromJson instance for this part so far, but if I want to keep using the lens library, should I just write a regular function which produces Entry's 
20:25:43 <joobus> instead?
20:27:34 <lpaste> joobus pasted “Using lens to parse a json” at http://lpaste.net/174766
20:28:12 <joobus> that's what I've got so far, but it currently doesn't compile.  The commented out code was my attempt with lens in FromJson
20:30:42 <mDuff> Is the dependency tree of platform packages self-contained?
20:31:02 <mDuff> I see cabal-install depending on tar, for instance, but tar isn't listed in the platform-baseline dependency set.
20:31:36 <geekosaur> cabal-install can't rely on the platform since the platform needs cabal-install. normally it's bootstrapped
20:35:14 <Maxdamantus> bootstrapped? I'm sure I remember being able to install cabal-install's dependencies with just GHC.
20:39:30 * hackagebot roundRobin 0.1.2.0 - A simple round-robin data type  https://hackage.haskell.org/package/roundRobin-0.1.2.0 (winterland)
20:39:41 <phadej> cabal-install depends on tar only starting with 1.24
20:39:55 <phadej> so probably platform didn't had time to catch up
20:41:19 <Maxdamantus> Mm, when I last built everything from scratch I think it also depended on mtl and some http library and some other things.
20:41:50 <wagle> is there some way to keep character encoding straight?
20:42:23 <wagle> I'm trying to pull stuff off the web, and my chars seem all screwed up
20:42:32 <Maxdamantus> wagle: "straight"?
20:42:38 <wagle> display onmy terminal fine though
20:42:53 <wagle> UTF-8 vs whatever
20:43:33 <Maxdamantus> If you're trying to deal with them using Strings, those are not UTF-8.
20:44:53 <wagle> i have String, Text, UTF-8, something, something, and it DOES NOT MIX
20:45:12 <wagle> except on my terminal emulator, where cutting and pasting work fine
20:45:25 <glguy> It'll probably be hard to guess what you're doing wrong
20:45:36 <wagle> so...  I want to keep which is which spearate
20:46:03 <wagle> I'm looking for something that manages it for me or something
20:46:10 <Maxdamantus> You don't fix encoding issues by throwing lots of different things at the problem.
20:46:18 <wagle> rather than just blindly interconverting
20:46:31 <wagle> stop insulting me, please
20:46:31 <glguy> The difference between String, Text, and UTF-8 encoded bytestrings are the types
20:47:01 <glguy> If you have some example code that doesn't work that would be worth pasting to http://lpaste.net
20:47:18 <wagle> glguy: it requires a password to run
20:47:35 <wagle> else I would have done that
20:48:23 <wagle> its sorta a homework problem, so I'm looking for help more of the "hint" variety
20:48:43 <wagle> hence my unfortunate need for vagueness
20:48:54 <glguy> The vagueness is going to prevent you from getting meaningful help though
20:49:16 <wagle> yeah
20:50:20 <wagle> what I'm looking for here is a way for the type system to keep me from doing stupid things..  printf is too magical, for example, I thing I'll have to get rid of it
20:50:29 <wagle> think
20:50:39 <glguy> Yeah, it's uncommon to use printf
20:51:06 <Maxdamantus> Most things seem to get string encoding wrong, including Haskell.
20:52:16 <Maxdamantus> and a type system isn't going to be able to handle everything. When you're reading stuff from the internet it can be in any encoding, and the type of data you have is just bytes.
20:52:44 <glguy> When you have a bytestring it's just bytes, that's on you to decode based on the context
20:52:52 <glguy> Once you have a String or Text it should be normalized into Unicode
20:54:01 <wagle> i threw aeson into the mess, and libCurl
20:55:09 <wagle> lemme see if getting rid of printf works
20:55:41 <synergistics> What is the purpose of the Text.ParserCombinators.Parsec modules when there's Text.Parsec? 
20:55:50 <glguy> synergistics: legacy code
20:55:51 <sleblanc> synergistics, alias
20:56:02 <glguy> wagle: It's unlikely that printf is introduce an encoding error
20:56:12 <synergistics> glguy: Ok, so I'd be fine with just using Text.Parsec modules?
20:56:38 <wagle> it might be letting me get away with mixing
20:56:39 <glguy> That's preferred, actually
20:56:50 <glguy> synergistics: ^
20:56:55 <synergistics> Ok
20:57:27 <synergistics> glguy: So I tried to add Parser String in a type signature, but I guess that synonym only exists in ParserCombinators?
20:58:02 <glguy> synergistics: There are a number of modules that provide Parser in the Text.Parsec namespace
20:58:11 <glguy> for example Text.Parsec.String. It depends on what you're parsing
20:58:22 <wagle> glguy wins!  removing printf (to string) didnt help
20:58:31 <nitrix> synergistics: Parsec String is a type error I think?
20:58:38 <mDuff> hrm.
20:58:47 <nitrix> *Parser String
20:59:07 <synergistics> glguy: Oh I see
20:59:26 <glguy> nitrix: No, Parser :: * -> *
20:59:38 <synergistics> Is there anywhere where I could get a tree of the parsec modules?
20:59:47 <glguy> ?hackage parsec
20:59:47 <lambdabot> http://hackage.haskell.org/package/parsec
20:59:58 <mDuff> cabal-install depends on hackage-security; hackage-security depends on ed25519; ed25519 0.0.5.0 is failing to build with a dependency on "ghc-prim >=0.1 && <0.5"
20:59:58 <nitrix> glguy: Isn't Parsec :: * -> * ? checking.
21:00:01 <mDuff> ...that can't be right.
21:00:08 <synergistics> glguy: Oh, duh. Thanks
21:00:10 <glguy> nitrix: We're not talking about "Parsec", we're talking about "Parser"
21:00:20 <nitrix> Oh, no, it's ParsecT which is has  s u m a
21:00:21 <mDuff> ...particularly as https://hackage.haskell.org/package/ed25519-0.0.5.0/dependencies says it should be <0.6
21:00:35 <nitrix> glguy: I don't like how you can eta-reduce type aliases :(
21:01:07 <glguy> nitrix: How do you mean?
21:01:39 <glguy> Parsec String () is a type, Parser is an alias for that type
21:03:03 <mDuff> hmm. ed25519.cabal in https://hackage.haskell.org/package/ed25519-0.0.5.0/ed25519-0.0.5.0.tar.gz does indeed specify ghc-prim <0.5
21:04:07 <nitrix> glguy: type Parser = Parsec String ()  would be more informative as   type Parser a = Parsec String () a
21:04:31 * hackagebot sized 0.2.0.0 - Sized sequence data-types  https://hackage.haskell.org/package/sized-0.2.0.0 (HiromiIshii)
21:04:44 <glguy> type aliases must be saturated, so it's important to leave off unnecessary arguments
21:05:33 <nitrix> Is it normal that it bugs me or there's probably a misunderstanding that causes this?
21:06:14 <glguy> I don't think it's "normal" but I wouldn't scold you over it
21:06:27 <nitrix> Can't GHC just figure it out?
21:06:41 <nitrix> Seems like a simple enough reduction that'd benefit clarity :/
21:06:55 <glguy> There's the LiberalTypeSynonyms extension to let GHC try and figure things out more in this space
21:07:08 <nshepperd> what if you could give Parser a kind signature
21:07:09 <glguy> but I don't think it's obviously a question of clarity
21:07:27 <glguy> adding the extra argument doesn't tell you what kind the extra argument has, either
21:08:09 <nitrix> glguy: Parser to Parsec to ParsecT isn't too bad, but if you look at other libraries (I think lens?), things get crazy quickly.
21:12:12 <nitrix> Thanks for the extension.
21:12:34 <geekosaur> nitrix, the problem is that partial type functions play havoc with type inference and I think some other parts of the typechecker. it's kinda the type equivalent of that "infinite type a ~ [a]" error
21:12:43 <geekosaur> (not literally, but conceptually)
21:13:27 <geekosaur> ghc could potentially figure some of them out, but also could get lost in the weeds fairly quickly
21:14:17 <geekosaur> (put otherwise: it can't always tell if you're being stupid, or being clever >.> )
21:15:04 <nitrix> geekosaur: A 'lil bit column A, lil' bit column B.
21:19:23 <geshe> anyone familiar with error (unknown GLU entry gluOrtho2D) latest ghc, glut, opengl
21:20:03 <geshe> with freeglut installed
21:23:48 <pavonia> geshe: Have you seen http://stackoverflow.com/questions/7805534/unknown-glu-entry-gluortho2d-using-opengl-in-haskell ?
21:26:14 <moongazer> Hello! Can someone help me with the Graph data structure? The question is in C and I need the answer now, and there are very few people on C now
21:26:44 <dmj`> moongazer: is it for homework?
21:26:59 <glguy> moongazer: Questions about C are off-topic on #haskell
21:27:06 <moongazer> dmj`: Nope, I am self learning, I am not a CS grad
21:29:24 <suzu> does it involve C itself
21:29:52 <geshe> pavonia: was looking at that but didnt notice that last comment.. I guess I'm trying to call something that is deprecated
21:36:44 <moongazer> suzu: Yessss
21:37:59 <samsepi01> Ne0nD3lta: run program now
21:38:03 <Ne0nD3lta> samsepi01: rgr
21:38:22 <glguy> samsepi01: This isn't the place to test bots
21:39:57 <oldmanmike> Is it possible to get stack to gen its haddock docs in a custom directory, rather than nested far into .stack-work?
21:40:53 <suzu> moongazer: if it has to do with C itself then this isn't the right place
21:41:17 <moongazer> suzu: ok
21:55:00 <wagle> has anyone used libcurl and aeson together?  I'm getting an impedance mismatch between String (libcurl) and ByteString (aeson)
21:55:19 <mDuff> Hmm, this is a new one.
21:55:21 <mDuff> Setup: failed to parse output of 'ghc-pkg dump'
21:56:05 <mDuff> ...okay, not so new. Yay for wiki docs.
21:58:00 <solrize> ghc is pretty good at unboxing ints in a strict calculation but it never seems to want to unbox floats, so numeric calculations go very slow unless i unbox the floats by hand, which seems very painful because none of the regular stuff works.  is there a better way?
21:58:25 <pavonia> wagle: You can just encode the String to a ByteString via Data.Text.Encoding
22:04:51 <wagle> pavonia: I seem to have tried that, but it just silently didnt work, proably due to charset mismatches or something
22:06:13 <pavonia> Is the encoding fixed for the data you download?
22:08:37 <wagle> libCurl comes out as String.  aeson uses ByteStrings.  somewhere something gets confused and I cant build more libcurl queries that work from the haskell program..  (but the haskell program CAN print strings to the Terminal app that work when cut and pasted)
22:09:37 <wagle> earlier I converted from String to Text to Lazy ByteStrings, maybe to Strict ByteStrings
22:09:57 <wagle> then I tried to convert back to String for libcurl
22:10:22 <wagle> what the type system let me get away with was suspicious
22:11:13 <wagle> can't give you a functioning program, since a password is required (hardcoded in the code)
22:11:58 <pavonia> I had similar problems with calling external programs from Haskell which yield a String that actually was a sequence of UTF-8 bytes, so you may need to do some extra decoding of the libcurl data
22:12:32 <pavonia> But that gets tricky if the encoding of the data varies
22:14:07 <wagle> yeah..  
22:14:48 <pavonia> So I'd start with inspect the data from libcurl to see if it's actually a Unicode string or raw bytes
22:15:09 <wagle> how..  it claims to be string
22:15:13 <suzu> print it
22:15:30 <suzu> print part of it and look at it manually
22:15:31 <wagle> prints fine..  can cut and paste to terminal, and that DOES work
22:16:31 <suzu> wtf is an impedence mismatch
22:16:46 <suzu> does it give you any more detail than just HALP IMPEDENCE MISMATCH
22:17:15 <pavonia> wagle: Also print the show'ed version of the string to see if non-ASCII characters appear in it
22:18:13 <wagle> interesting..  (thought my terminal supports all sorts of chars, but will try it anyway
22:18:15 <suzu> strip the string out and see if it's equal to the original
22:18:17 <suzu> ?
22:18:22 <suzu> strip = filter (\x -> ord x > 32 && ord x < 126)
22:18:26 <suzu> or something
22:18:31 <wagle> neat
22:19:01 <wagle> lemme get it to typecheck again first, sorry
22:23:07 <wagle> braindead.  no longer getting anywhere, going to sleep now..  thanks guys!
22:34:36 * hackagebot hw-rankselect 0.2.0.0 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-rankselect-0.2.0.0 (haskellworks)
22:36:56 <geshe> pavonia: i've got gluOrtho2D in /usr/include/GL/glu.h, is it a linking problem? I tried these ghc flags for the OpenGL package: -lGL -lGLU -lglut
22:38:22 <pavonia> Yeah, this is what I suspect, or incompatible versions
22:41:12 <pavonia> geshe: Have you tried if patching of GLURaw works, as shown in the earlier link?
22:46:38 <geshe> pavonia: I was confused cause I didnt realize what that package was. Can I just stack unpack that to patch it in my project
22:47:30 <pavonia> I don't know about stack, sorry
22:47:57 <geshe> no problem thanks for pointing me in the right direction
22:48:47 <kadoban> geshe: You can indeed use a local package instead of one from hackage or whatever as a dependency.
22:53:20 <athan> geshe, pavonia: Yeah you can just throw in directories in the `packages` pragma in your stack.yaml
22:53:47 <athan> so something like `packages:\n  - '.'\n  - '~/dev/myPackage'` should work fine
22:54:00 <geshe> awesome
22:54:11 * athan need's glguy's sweet irc skillz
22:55:02 <glguy> ?
23:04:26 <geshe> athan: do I need to do anything special to ensure a local version of a dependency is used in lieu of the lts version
23:04:38 * hackagebot ruin 0.1.0.0 - Pliable records  https://hackage.haskell.org/package/ruin-0.1.0.0 (NicolasFrisby)
23:06:25 <dabron_mobile> test test (ignoreme)
23:09:16 <kadoban> geshe: Naw, just what they said above.
23:14:39 * hackagebot ruin 0.1.0.1 - Pliable records  https://hackage.haskell.org/package/ruin-0.1.0.1 (NicolasFrisby)
23:49:06 <srhb> Have there been any proposals to have a feature to unwrap a namespace locally? Like if I'd imported something qualified as N, I'd like to be able to do: with N: { foo; ... } where foo is understood as foo OR N.foo, whichever is in scope in the "unwrapped" scope (or conflict)
23:49:50 <srhb> Does this kind of thing have a more formal name I can google?
23:50:27 <magneticduck> srhb: you can get the same result with 'import N; import qualified N as N'
23:51:01 <srhb> magneticduck: I don't want to pollute the default namespace, I just want to be able to join it locally in places.
23:51:48 <magneticduck> okay, at least I confirmed we're talking about the same thing ^^
23:51:54 <srhb> Yes. :)
23:52:40 <srhb> It's a little tedious to have to prepend, say, SDL. to everything in a massive do-block when you could just say "hey, I want to unwrap the SDL qualifier locally in this block"
23:52:55 <srhb> I think that would be gorgeous.
23:54:43 <magneticduck> such a thing could be achieved with TH at some cost to sanity
23:54:50 <srhb> Indeed.
23:54:55 <magneticduck> one could also just use more modules
23:54:57 <srhb> I'm not willing to pay _that_ much sanity. ;-)
23:55:18 <srhb> Yeah, I'm considering that, but I'm thinking it would still be frowned upon (understandably) to have these things unqualified even in internalish modules
23:55:19 <srhb> Maybe not.
23:55:20 <magneticduck> out of curiosity, what does SDL export that clashes?
23:55:32 <daniel_w> It might be difficult in TH, since, last time I checked I couldn't enumerate decls of a named module
23:55:56 <srhb> magneticduck: It's not a question of clashing as such, at least not yet, but just keeping things sane by making it locally visible where a name is from.
23:56:25 <daniel_w> What I'd do is import everything. Write code, then ddump-minimal-imports
23:56:29 <srhb> I think having _every_ name be qualified is a bit noisy, but blocky namespaces sounds nice.
23:56:38 <srhb> daniel_w: ... That's a thing? TIL.
23:56:58 <suzu> somehow i got haskeline to segfault.
23:57:07 <suzu> when printing a lot of data
23:57:09 <suzu> from a socket
23:57:53 <daniel_w> srhb, yeh, it's pretty handy for preventing random future breakage
23:58:05 <srhb> daniel_w: Wow, that's really useful. Thanks for the heads up. :-)
23:59:46 <daniel_w> Is there a modern version of syb-with-class?
