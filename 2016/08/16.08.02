00:37:39 <andrewbrowne> I am trying to write a small DSL using free. One thing in my DSL is the ability to create a queue. I am having trouble working out how to have typed commands that take the type of items in the queue as a parameter. Is it possible to have a DSL using free that is type safe when the commands are polymorphic?
00:39:20 <andrewbrowne> In normal haskell code I can do something like: (a :: Queue Char) <- newQueue; putQueue a 'c'. And the it is type safe. Is that possible within a dsl using free?
01:02:47 <lambda-cypher> hey guys
01:03:04 <lambda-cypher> would you recommend "write yourself a scheme in 48 hours"?
01:03:20 * hackagebot servant-auth-token-api 0.1.0.0 - Servant based API for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-api-0.1.0.0 (NCrashed)
01:03:24 <Pupeno> I haven't used Haskell in ages. Do comments starting with -- | have a special significance?
01:03:35 <shachaf> lambda-cypher: It's quite old.
01:03:42 <shachaf> Pupeno: They can be Haddock comments.
01:03:42 <liste> Pupeno: they're for Haddock
01:04:29 <lambda-cypher> Is there any good alternative? I want to do exactly what it seems made for.
01:04:31 <Pupeno> Thanks.
01:08:20 * hackagebot servant-auth-token-api 0.1.0.1 - Servant based API for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-api-0.1.0.1 (NCrashed)
01:13:20 * hackagebot json-rpc-generic 0.2.1.1 - Generic encoder and decode for JSON-RPC  https://hackage.haskell.org/package/json-rpc-generic-0.2.1.1 (KeiHibino)
01:29:42 <eklavya> my god, I haven't done anything as complicated as trying to write a code fragment in template haskell
01:29:49 <eklavya> it's soooo hard :(
01:48:27 <orion> eklavya: Ever write a Free Monad?
01:48:35 <orion> That's pretty gnarly too.
01:49:49 <eklavya> couldn't be as hard as TH the only thing harder I can imagine is giving birth
01:53:21 * hackagebot th-utilities 0.2.0.0 - Collection of useful functions for use with Template Haskell  https://hackage.haskell.org/package/th-utilities-0.2.0.0 (MichaelSloan)
01:58:28 <fr33domlover> eklavya, remember you can use [| ... |]
01:59:07 <eklavya> yeah but not sure where
01:59:10 <fr33domlover> if your TH is mostly "static" it will make it much more readable
01:59:49 <fr33domlover> eklavya, what does your TH do
02:00:14 <eklavya> I need to write instances of a class for user records
02:01:04 <fr33domlover> eklavya, you mean have the instances automatically generated using TH?
02:01:11 <eklavya> yes
02:02:18 <fr33domlover> eklavya, take a look at the source of the persistent-template package on Hackage
02:02:29 <fr33domlover> See how the TH is written there
02:02:35 <eklavya> ok
02:02:53 <eklavya> I have read the examples of writing Show for stuff
02:02:55 <fr33domlover> also maybe how makeAcidic works, in acid-state package
02:03:30 <eklavya> and I am trying to write something similar, it would be a lot less hard if I could see what I has written so far easily
02:03:42 <eklavya> had*
02:03:55 <eklavya> so I could experiment and increment 
02:06:14 <ongy> eklavya: there is a flag that lets ghc output the generated code
02:06:36 <fr33domlover> eklavya, you can also write an example of what the genrated code should look like
02:06:42 <fr33domlover> and use it to help you nagivate the TH
02:07:03 <fr33domlover> it's also good for documentation to have such an example
02:07:14 <eklavya> yeah, let me look that up
02:07:31 <eklavya> persistent-template is like black belt level TH
02:11:25 <fr33domlover> eklavya, you can see how it uses [|...|] everywhere and $() inside it, to insert variables
02:11:47 <fr33domlover> it's still hard to read, but still much easier than using just plain TH functions 
02:11:47 <eklavya> yes
02:11:58 <eklavya> I looked up the printing part
02:12:08 <eklavya> I can print the AST for desired code
02:12:23 <eklavya> I need to see what my $(myFunc a) is producing
02:12:32 <eklavya> let me see if there is anything for that
02:14:05 <eklavya> the problem is that I think Q [Exp]  is printable but I have Q [Dec]
02:14:38 <cocreature> $(stringE . show =<< decs) might do the trick
02:16:13 <ongy> eklavya: does -ddump-splices compiler flag help you?
02:18:03 <eklavya> cocreature: yes it does :D
02:18:22 * hackagebot haskell-src-exts-simple 1.18.0.1 - A simplified view on the haskell-src-exts AST  https://hackage.haskell.org/package/haskell-src-exts-simple-1.18.0.1 (BertramFelgenhauer)
02:18:33 <eklavya> ongy: I think that will be used when I use the template in code?
02:19:19 <ongy> eklavya: It will output what ghc generated, so if you use the splice somewhere, the code that's inserted will be printed (if I understand it correctly).
02:19:35 <eklavya> ok
02:19:42 <eklavya> let me add that flag
02:20:34 <cocreature> I typically use -ddump-splices when I have reasonably large code and use the stringE . show stuff for playing around in ghci
02:27:46 <eklavya> even if I am not able to write the code I want in the end, I am just really grateful for your help and support fr33domlover cocreature ongy :)
02:28:22 * hackagebot mystem 0.1.0.0 - Bindings for Mystem morphological analyzer executabe  https://hackage.haskell.org/package/mystem-0.1.0.0 (wapxmas)
02:29:15 <fr33domlover> eklavya, (1) you will be able to write it! (2) glad to help :P
02:33:23 * hackagebot murmur3 1.0.3 - Pure Haskell implementation of the MurmurHash3 x86_32 algorithm.  https://hackage.haskell.org/package/murmur3-1.0.3 (PhilippeLaprade)
02:35:08 <av_> hi guys, I'd love to solve some differential equation systems numerically, is there a library I could use for that, preferably one allowing an infinite list of results (end condition not pre-defined)?  I know hmatrix-gsl, but that would require some work on my part
02:38:08 <int-e> how do people deal with the discrepancies between hackage's treatment of package descriptions and haddock's markup? (cf. https://github.com/int-e/haskell-src-exts-simple/issues/3 for a concrete instance)
02:38:24 <lyxia> av_: ad might be useful
02:42:37 <cocreature> int-e: use a README.md and link to it in the description :)
02:43:23 * hackagebot pstemmer 0.1.0.0 - A Haskell Implementation of the Porter Stemmer  https://hackage.haskell.org/package/pstemmer-0.1.0.0 (wapxmas)
02:47:18 <av_> lyxia: what's ad?
02:48:02 <av_> lyxia: ah, you mean the package named ad -- yes, it looks good
02:48:32 <av_> lyxia: sorry, not used to such short and non-informative names :)
02:49:09 <lyxia> av_: haha yeah that was confusing
02:49:18 <int-e> cocreature: hmm, that may be the best way.
02:49:30 <ertes> int-e: i just make sure to use the lowest common denominator and use a README.md
02:49:36 <cocreature> int-e: hackage does render READMes so it’s quite a reasonable thing to do
02:50:15 <ertes> int-e: be sure to include README.md in extra-source-files
02:50:49 <cocreature> although it’s kind of annoying that it puts readmes at the bottom while descriptions are at the top
02:51:46 <ertes> cocreature: i think that's reasonable, especially if you use that page as a documentation hub with keyboard navigation
02:51:58 <ertes> you want the module links to be above the README.md
02:52:12 <ertes> (in fact i'd like them to be above everything)
02:52:34 <cocreature> ertes: I’d be fine with everything being above. what I don’t like is that description and readmes are not treated equally
02:53:39 <ertes> not sure if they should be…  there is a single-line synopsis, a short description and longer in-depth documentation…  i think it's reasonable
02:53:40 <int-e> ertes: is there a list of common features that work anywhere? (I guess plain text, > quoted text,  and itemized lists should work; is there anything else?)
02:54:03 <merijn> int-e: No, because markdown is an awful format :\
02:54:15 <int-e> oh and I guess autolinks for http[s]:// urls.
02:56:21 <ongy> merijn: and haddock is so great?
02:56:23 <ertes> int-e: even the common features are interpreted differently in certain cases
02:56:30 <merijn> ongy: I didn't say that
02:56:51 <merijn> ongy: But rST is a better format than markdown, not sure why everyone settled on markdown
02:57:20 <ertes> int-e: IMO you simply shouldn't assume that there is a common subset, and the easiest way not to make that mistake is to treat the description and README.md as different things
02:57:45 <ertes> int-e: the former is a short prose description…  sometimes it's abused as a full introduction, but it shouldn't be
02:57:48 <int-e> ongy: haddock has some severe limitations, but compared to markdown it's quite well-defined... perhaps by virtue of having a single implementation.
02:58:23 * hackagebot parsec-pratt 0.1.1 - Pratt Parser combinator for Parsec  https://hackage.haskell.org/package/parsec-pratt-0.1.1 (jh3141)
02:58:26 * hackagebot shakespeare 2.0.11 - A toolkit for making compile-time interpolated templates  https://hackage.haskell.org/package/shakespeare-2.0.11 (MichaelSnoyman)
02:58:27 * hackagebot wai-app-static 3.1.6 - WAI application for static serving  https://hackage.haskell.org/package/wai-app-static-3.1.6 (MichaelSnoyman)
03:00:04 <ertes> int-e: from a user perspective the best description fields i have seen contain 2-3 paragraphs and give me a good idea what the package is about, what i can do with it and where i need to look for a first impression/tutorial
03:00:30 <ertes> without blathering
03:08:24 * hackagebot th-utilities 0.2.0.1 - Collection of useful functions for use with Template Haskell  https://hackage.haskell.org/package/th-utilities-0.2.0.1 (MichaelSloan)
03:15:51 <oish_> is there a way to sort the characters in a Data.Text ideally without converting to ByteString or writing my own Ord instance?
03:20:27 <liste> oish_: you mean (pack "adceb") -> (pack "abcde") ?
03:27:51 <oish_> liste: exactly
03:28:24 * hackagebot ghc-typelits-presburger 0.1.1.0 - Presburger Arithmetic Solver for GHC Type-level natural numbers.  https://hackage.haskell.org/package/ghc-typelits-presburger-0.1.1.0 (HiromiIshii)
03:33:59 <merijn> oish_: Why would you have to convert to bytestring?
03:34:08 <merijn> oish_: "T.pack . sort . T.unpack"?
03:34:14 <merijn> :t T.unpack
03:34:15 <lambdabot>     Not in scope: ‘T.unpack’
03:34:15 <lambdabot>     Perhaps you meant ‘BS.unpack’ (imported from Data.ByteString)
03:34:18 <merijn> eh
03:34:23 <merijn> :t Data.Text.unpack
03:34:24 <lambdabot> Data.Text.Internal.Text -> String
03:34:29 <merijn> :t Data.Text.pack
03:34:31 <lambdabot> String -> Data.Text.Internal.Text
03:35:02 <merijn> > Data.Text.pack . sort . Data.Text.unpack $ text "efabhol"
03:35:03 <lambdabot>  Not in scope: ‘Data.Text.pack’Not in scope: ‘Data.Text.unpack’
03:36:11 <ongy> sorting on bytestring would be terrible either way, since unicode characters will be multiple bytes
03:36:20 <merijn> Exactly
03:38:25 * hackagebot wai-websockets 3.0.1 - Provide a bridge between WAI and the websockets package.  https://hackage.haskell.org/package/wai-websockets-3.0.1 (MichaelSnoyman)
03:38:25 <oish_> merijn: does that not create a (less performant than Data.Text) String?
03:38:53 <maerwald> Data.Text does not have an Ord instance?
03:40:01 <liste> (pack "a") > (pack "b") prints False for me
03:40:25 <ongy> it's about sorting in the string, not sorting strings (I think)
03:40:53 <oish_> ongy: Yep
03:41:08 <oish_> for a big list of anagrams
03:42:51 <fr33domlover> oish_, convert to String, sort, convert back to Text? Note that Text is meant for... text, and text rarely needs to have its letters sorted
03:43:01 <fr33domlover> Just make sure you're using the right tool etc.
03:43:08 <merijn> oish_: Sure, but you can't sort in place anyway?
03:43:28 <merijn> oish_: You can't modify the initial text
03:43:52 <merijn> oish_: So whether you build one via a list or not doesn't seem very relevant?
03:45:35 <oish_> merijn: well, want to construct a Map with the sorted letters of a word as key and list of words as element
03:46:09 <oish_> merijn: so I can detect words that are anagrams of each other from a wordlist
03:46:55 <oish_> merijn: given that each word will want sorting to decide which bucket it goes in, I'm looking for a quick way to sort the letters
03:47:42 <oish_> merijn: hopefully minimizing the number of conversions between types...
03:48:13 <sbrg> oish_: are you sure you aren't just prematurely optimizing? it'll probably perform just fine even with the explicit conversions back and forth
03:49:13 <fr33domlover> oish_, you could also turn each word into a Set Char and compare these for equality to detect anagrams
03:49:30 <fr33domlover> Start naive and optimize after you get it to work :P
03:49:51 <oish_> sbrg: Yep, will see if Data.Text.pack . sort . Data.Text.unpack works...
03:50:01 <maerwald> converting back and forth is a hack I would try to avoid
03:50:32 <oish_> fr33domlover: Set Char would detect beet and bet as anagrams though?
03:50:33 <fr33domlover> perhaps work with String directly, especially since each string there is a single word
03:51:02 <fr33domlover> oish_, hmm good point, must also count number of occurences of each letter...
03:51:15 <fr33domlover> (or use a multiset, dunno if a package for that exists)
03:51:22 <oish_> fr33domlover: handy, will check it out.
03:51:25 <oish_> Thanks folks.
03:51:59 <fr33domlover> (it's still probably easier to compare sorted String, my Set idea isn't necessarily a good one, just a random thought)
03:57:43 <merijn> If the number of words is very big than String is kinda bad, though
03:59:04 <osager> my stack lts has and old aeson version which has a bug, how can i make stack use a new version of the aeson library ?
03:59:22 <oish_> merijn: ~300k words...
03:59:52 <sbrg> osager: you need to use a new snapshot
04:00:09 <merijn> oish_: Average length?
04:00:13 <osager> sbrg, great, can i choose a new snapshot?
04:00:16 <sbrg> oish_: 300k doesn't sound too bad really. depends on if you actually have performance requirements
04:00:23 <osager> i thought it's automatic
04:00:45 <sbrg> osager: what does your stack.yaml for your project say for the "resolver:" line?
04:01:09 <osager> resolver: lts-4.1
04:01:20 <merijn> oish_: At 10 chars per word String comes down to about 68 MB of data
04:01:23 <sbrg> ẙeah, that's pretty old. you can change that one to, for example, the newest one on the stack homepage
04:01:27 <osager> i didnt write any version requirement in my cabal file
04:01:42 <osager> on all the libraries
04:01:58 <sbrg> osager: Then I'd think that just changing the resolver to a newer one and rebuilding should basically take care of everything automatically for you
04:02:11 <sbrg> I haven't done this for a while, however, so it may be nastier
04:02:12 <ertes> oish_: any sorting algorithm on Text is going to have similar performance to sorting [Char]…  if you want to use any of the fast in-place sort algorithms, don't create a Text in the first place, but instead create a Vector Char and use the vector-algorithms library
04:02:17 <osager> let me try, sbrg ,thanks
04:02:32 <sbrg> unboxed vector of ints!
04:03:04 <sbrg> going that way is probably insane unless you really need that kind of performance. but since you're just playing with anagrams I'm guessing this is a programming challenge of some sorts :b I think I did something very similar, just using String, and it worked fine. 
04:03:11 <sbrg> FSVO fine
04:03:31 <ertes> using a Vector Char is not much different from using a Text
04:03:33 <osager> sbrg, so people update the resolver version from time to time ?
04:04:27 <ertes> the APIs are very similar, but Vector Char allows O(1) indexing and vector-algorithms
04:04:35 <sbrg> osager: Sure, if they need to
04:29:31 <zedik> Hi all. How to read the string (path to file) as a command line argument? Top Google's results are about how to do parsing using various libraries but I need just to read path to the file.
04:30:01 <Maxdamantus> @hoogle getArgs
04:30:04 <lambdabot> System.Environment getArgs :: IO [String]
04:30:04 <lambdabot> System.Posix.Env.ByteString getArgs :: IO [ByteString]
04:30:04 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: MonadIO m => m (String, [String])
04:30:16 <Maxdamantus> That first one.
05:19:15 <cocreature> does throwTo only ensure that the exception was raised when it returns or does it make sure that it was also handled. e.g. when the thread that the exception is thrown to has a bracket, can I be sure that the cleanup action has been run?
05:19:41 <cocreature> if not is there a better way to ensure that it is run than throwing in an mvar or something like that?
05:20:35 <barrucadu> throwTo blocks until the exception is delivered, but not until it is handled
05:20:52 <cocreature> barrucadu: thanks I guess that is my problem then
05:23:00 <ertes> a strict *type* for HashMap, IntMap and Map would be really handy
05:23:23 <ertes> i just had a major memory leak involving IntMap that turned out to be due to its lazy Traversable instance
05:23:29 <merijn> Blocking until the exception is handled is kinda nonsensical
05:23:40 <merijn> What if the receiving thread doesn't ever catch exceptions?
05:24:55 <ertes> how do i even write a strict 'traverse' for IntMap?
05:24:58 <cocreature> merijn: my problem is that I want to ensure that the finalizer of that thread is run (it does actual io not just in memory cleanup). however if the main thread exits in the mean time I’ve lost
05:25:01 <ertes> without traversing twice that is
05:26:06 <cocreature> at least that’s what I think is causing my finalizer to fail without an exception somewhere in the middle
05:28:20 <merijn> cocreature: Have a global TVar with the number of active threads, block main thread until it is zero, have threads decrement it in their finalizer
05:29:39 <cocreature> merijn: the main thread is run by hspec so this is not that easy
05:30:36 <hellofunk> when a haskell app is compiled, does it require a runtime environment already installed on the system, or is everything it needs included in the compiled binary?
05:31:03 <sbrg> hellofunk: It doesn't require a runtime system, but it may require libraries for dynamic linking
05:31:17 <sbrg> but you can remedy that by doing a static build which includes everything
05:31:19 <bennofs> things like GMP may be required
05:32:00 <hellofunk> i had read various reports of people compiling haskell for iOS, but there would be nothing on the iOS system for it to link to, so was wondering how that was done.
05:32:13 <hellofunk> that's a nice option
05:32:29 <sbrg> I haven't really looked into it, but it wouldn't surprise me if they used static builds.
05:33:13 <sbrg> The executable will be larger, though. 
05:33:56 <ongy> I have looked into it for android at one point, the general idea was compiling to C (with jhc I think) and then going through the intended compile-chain for C libraries
05:34:24 <bennofs> hellofunk: compiling haskell to iOS is not very smooth yet, and might prove to be quite hard to get set up
05:34:31 <bennofs> hellofunk: some people have done it I think though
05:36:53 <merijn> bennofs: Some people have done it for sure
05:37:08 <merijn> bennofs: The game Cale was working on ran on iOS, afaik
05:37:24 <bennofs> but i remember that setup for such a thing is quite some work
05:38:32 <hellofunk> i usually think of garbage collection as being an environment outside the executable, like a VM, but it's interesting that the GC is baked right into the executable.
05:39:09 <merijn> There's no specific reason a VM has to be an external program
05:39:20 <hellofunk> right, i'm not used to that.
05:40:23 <sbrg> I can't think of any programming language where the gc is "external" as such. Haskell executables have a runtime system compiled in, which handles all that, and I think most languages that have GC do something similar, though it depends on the type of GC and so on. 
05:40:30 <merijn> hellofunk: Basically, the compiler just generates code with calls to (something like) malloc and when things are no longer live it produces an automatic call to something like "free" (gross oversimplification/flat out wrong), the runtime is then just a library that happens to expose those functions :)
05:40:53 <merijn> tbh, even C has a runtime system compiled in, it's just significantly smaller and simpler than others
05:41:29 <hellofunk> what about GC in .NET or Java or Erlang?
05:42:39 <sbrg> Well, that depends on how you view it, I guess? In those cases, the programs are compiled to bytecode and executed by the vm, which handles that, yes, but I'm not sure I would call it "external"
05:42:51 <sbrg> since the programs themselves can't run on their own
05:43:05 <hellofunk> that makes sense
05:43:37 <sbrg> (NB: I don't know anything about erlang)
05:44:24 <ongy> afaik recent vms do some jit, so they more or less have to compile it into the application aswell
05:48:06 <ggole> <sbrg> I can't think of any programming language where the gc is "external"
05:48:09 <phanimahesh> I know a bit of erlang, I contribute ocassionally to github.com/emqtt/emqttd
05:48:29 <ggole> Early Lisps used to work by writing the heap out, restarting and reading it back in
05:48:46 <ggole> Which sort of delegated the actual reclamation to the kernel
05:48:52 <sbrg> really? wow
05:48:53 <phanimahesh> Erlang runs on a VM that interprets bytecode, very much like python. The default interpreter is BEAM, though alternates are available
05:49:15 <ggole> This was in the very early days shortly after the invention of GC, so they didn't really know what they were doing.
05:49:19 <sbrg> ggole: that sounds like an incredibly convoluted way to do that
05:49:21 <sbrg> ah
05:49:23 <sbrg> fair enough
05:50:17 <phanimahesh> And GC in erlang is managed by the runtime. Erlang uses immutable data everywhere and copes data between its lightweight processes with no sharing, so the GC is really simple.
05:50:24 <phanimahesh> s/copes/copies
05:51:01 <phanimahesh> I find Rust interesting. It has no GC afaik.
05:51:38 <phanimahesh> By statically analysing the code, the compiler can insert appropriate malloc and free where resources are needed.
05:51:46 <ggole> I like Erlang's solution to the stop-the-world problem - instead of a complicated pauseless algorithm, instead there is simply no world to stop.
05:52:19 <ongy> phanimahesh: I'm pretty sure the same thing *is possible TM* with C++
05:52:22 <ggole> It seems typical of Armstrong's work
05:52:24 <phanimahesh> Yep. That's what makes erlang a great choice for soft realtime systems with massive concurrency
05:52:31 <ongy> but rust is interesting (though I don't think really usable at this point)
05:52:33 <sbrg> ggole: hm? can you explain?
05:52:56 <ggole> GC in erlang is (afaiui) done per lightweight thread
05:53:02 <sbrg> I don't know too much about gc, but what do you mean about there not being a "world"? "Stopping the world" means "stopping everything that's running" so that you can cleanup the heap, right?
05:53:09 <phanimahesh> ongy: I haven't seen it done well with C++, but then again I haven't read as much C++ as I did erlang/elixir
05:53:09 <sbrg> aah
05:53:27 <ggole> And they are all independent, with no cross-pointers. This means that GC can be run in small, manageable slices without stopping any other process.
05:53:40 <phanimahesh> Yep. Since processes share nothing, the gc can be run at a per process level.
05:53:43 <sbrg> I see. so per-thread heaps. doesn't that come with any overhead?
05:54:01 <phanimahesh> It comes with some overhead, all data is copied between processes.
05:54:05 <ongy> phanimahesh: possible, not easy, not even sure if it's done. And rusts type system is better at telling you if you make mistakes
05:54:15 <phanimahesh> These processes are lightweight, not os processes.
05:54:36 <phanimahesh> a typical machine can handle hundreds of thousands of erlang processes.
05:54:39 <merijn> sbrg: Yes, any communication between threads has to be by value instead of by reference
05:54:40 <ggole> It's probably not a suitable model for something like Haskell.
05:54:53 <sbrg> is this something haskell could possibly benefit from? I remember (semi-)recent discussions about there being no way around "long" gc pauses if you keep a lot of stuff in memory
05:55:00 <sbrg> oh
05:55:10 <merijn> phanimahesh: You do realise haskell threads are actually more lightweight than erlang processes? :)
05:55:24 <phanimahesh> No, I didn't know that. Is that the case?
05:55:25 <ggole> For Haskell I suppose you'd use something like a pauseless algorithm.
05:55:36 <merijn> phanimahesh: Yes, threads consume less memory than erlang processes
05:55:37 <ggole> Although those are reportedly hard to engineer.
05:55:49 <phanimahesh> I'm a fairly experienced erlanger but pretty much a haskell newbie. Interesting!
05:56:00 <merijn> sbrg: You could certainly do the same for haskell as for erlang, at the cost of making communication more expensive
05:56:27 <phanimahesh> (I encountered haskell before I did erlang. The difference was because I got to use erlang at my previous job, never used haskell professionally)
05:56:29 <merijn> sbrg: I've actually been wanting to experiment with typing by-value and by-reference semantics for communication between threads to play with this
05:57:11 <merijn> sbrg: I don't think it'd be easy to retro-fit into haskell, but designing something haskell like with that would be cool
05:57:36 <merijn> sbrg: It's on my list of ideas for the ideal concurrent programming language I want. But that's on hold until someone is willing to pay me to work on it :p
05:57:37 <zedik> Hi all. I am trying to read the file path from the command line argument. Why doesn't this work?: main = do sigile <- getArgs ; fpath = sigfile !! 0
05:57:39 <phanimahesh> The best part of erlang is the philosophy - "let it crash", and supervision trees, that allow managing failures really well
05:57:42 <ggole> Transparently copying Haskell values seems like it might be hard, or make some inconvenient requirements of the runtime
05:57:43 <sbrg> merijn: I see. We could probably come up with some smart schemes to reduce the communication overhead. copy-on-write, for example
05:57:59 <sbrg> or some such
05:58:04 <merijn> ggole: It's easy, it just makes communication far slower
05:58:05 <sbrg> i don't know much about the internals
05:58:21 <merijn> ggole: Doing one or the other is both easy
05:58:21 <ggole> Are cycles hard to find efficiently?
05:58:28 <merijn> ggole: Mixing is the problem
05:58:42 <merijn> ggole: Also, consider the effect on laziness
05:58:47 <ggole> Also, what about suspensions? They get run multiple times?
05:58:52 <ggole> Right.
05:59:11 <merijn> ggole: You can't effectively copy a lazy list by value, unless you want to either 1) force evaluation or 2) evaluate multiple times
05:59:25 <merijn> These things are probably the main reason why haskell uses global GC
05:59:34 <ggole> Mmm, that's what I thought.
05:59:42 <phanimahesh> It _is_ possible, but requires some work.
05:59:43 <merijn> Note that GHC already has per-thread nurseries that get GCed independently
05:59:58 <merijn> So if you have short term garbage it doesn't require global GC
05:59:59 <phanimahesh> oh wait, you said by value. scratch that
06:00:41 <merijn> phanimahesh: Haskell's threads don't have a lot of the erlang tools builtin, but I think you can implement like 80-90% of the functionality in a library if you'd like
06:01:04 <phanimahesh> erlang uses reference counting for large binaries. Maybe haskell can do similar thing with lazily evaluated values
06:01:45 <ongy> zedik: file path? the equivalent to Cs argv[0]?
06:02:21 <mauke> zedik: because that's a syntax error or two
06:02:25 <ggole> I dunno. Haskell's heap objects are pretty fine grained, often only a couple of words. 
06:02:29 <mauke> zedik: and you called the variable sigile, not sigfile
06:03:17 <ongy> is there a way to find out how much physical memory a value takes?
06:03:38 <merijn> ongy: Programmatically or by hand?
06:03:59 <ongy> merijn: either or, mainly I want to play around with it and inspect things
06:29:23 <merijn> 1 word per un-unpacked argument and 1 word for the constructor
06:29:23 <phanimahesh> BTW I bought the haskell book yesterday, reading through it.
06:29:23 <zedik> mauke:   Sorry, it was a typo when I was wrinting code here, it is:  sigfile <- getArgs   (next line)   fpath = sigfile !! 0
06:29:23 <ongy> where word=width of architecture?
06:29:23 <mauke> zedik: 'fpath =' is still a syntax error
06:29:23 <phanimahesh> it should be `let fpath = `, right?
06:29:23 <zedik> mauke:  fpath <- also doesn't work
06:29:23 <ongy> zedik: that works if you are in a do block
06:29:23 <mauke> zedik: indeed, that's a type error
06:29:23 <ongy> oh sorry
06:29:23 <ongy> I misread
06:29:23 <mauke> phanimahesh: yes, but the easiest way is just fpath : _ <- getArgs
06:29:23 <phanimahesh> Yep, that works, too.
06:29:30 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
06:29:30 --- topic: set by Cale!~Cale@2607:fea8:9840:324:58c2:98f3:e7ff:280e on [Thu Jun 23 02:10:43 2016]
07:13:13 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
07:13:13 --- topic: set by Cale!~Cale@2607:fea8:9840:324:58c2:98f3:e7ff:280e on [Thu Jun 23 02:10:43 2016]
07:13:47 <mjp__> Am I crazy, or does Ubuntu not have a haskell-platform version with GHC 8.0.1 yet?
07:17:08 <dexterph> mjp__: doesn't surprise me, Ubuntu has never been known to offer current versions of pretty much anything
07:19:20 <Gurkenglas> https://hackage.haskell.org/package/acme-realworld should be extended to implement Control.Monad.IO.Trans
07:23:52 <aweinstock> :t do { x <- get; y <- lift $ newSTRef x; lift $ readSTRef y } :: StateT Int (ST s) Int -- zenek
07:23:53 <lambdabot> StateT Int (ST s) Int
07:27:06 <aweinstock> > let action = do { x <- get; y <- lift $ newSTRef x; lift $ readSTRef y } :: StateT Int (ST s) Int in runST (runStateT action 0)
07:27:08 <lambdabot>  (0,0)
07:27:39 <aweinstock> zenek: ^ that's how to run a (StateT a (ST s) b)
07:28:31 * hackagebot type-natural 0.5.0.0 - Type-level natural and proofs of their properties.  https://hackage.haskell.org/package/type-natural-0.5.0.0 (HiromiIshii)
07:30:43 <aweinstock> :t \(body :: forall p. StateT s (ST p) a)  initState -> runST (runStateT body initState)
07:30:44 <lambdabot> (forall p. StateT s (ST p) a) -> s -> (a, s)
07:31:50 <aweinstock> zenek: ^ making a generic runner for (StateT a (ST p) b) gets kind of complicated due to the phantom type, I think it requires rank-2 types to quantify ST's type
07:32:50 <aweinstock> zenek: does this answer your question?
07:34:33 <s4ke> hi guys. i am having trouble building threadscope on my windows machine. is there a download link to a binary release of it on the internet?
07:45:05 <zenek> aweinstock: yes, it does - I've just added rank-2 forall s. to my type and it works :) thank you :)
07:49:46 <nitrix> What's the difference between Typeable and Dynamic?
07:50:12 <nitrix> Seems to me both are achieving the same goal, with Dynamic maybe completing Typeable a little bit / more convenient.
07:50:41 <merijn> nitrix: Dynamic is something you implement on top off Typeable
07:50:58 <merijn> nitrix: I'm not quite sure how they are remotely the same?
07:51:05 <geekosaur> Typeable is a mechanism. Dynamic is one but not the only thing implemented atop Typeable
07:51:42 <nitrix> merijn: So Data.Typeable gives you type representations and Data.Dynamic is using that to allow Dynamic typing with back and forth conversions?
07:51:55 <merijn> nitrix: Right
07:51:56 <nitrix> merijn: So there could be other uses of Typeable other than dynamic typing?
07:52:12 <merijn> nitrix: Yes
07:52:19 <nitrix> Do you have an example?
07:52:33 <merijn> nitrix: Dispatch based on type
07:52:51 <aweinstock> does Generic do something similar to Typeable?
07:53:05 <merijn> aweinstock: No, generic allows you to construct values
07:53:16 <merijn> aweinstock: Typeable only allows you to know their type
07:53:25 <nitrix> I think Generic is less about the type, more about the representation?
07:53:47 <merijn> aweinstock: You can't create a value of a Typeable instance out of thin air, you can for Generic
07:54:25 <aweinstock> Typeable gives abstract equality tokens, Generic gives ways to generically poke the guts of a type?
07:54:32 <merijn> aweinstock: Right
07:54:52 <nitrix> And Dynamic gives dynamic typing on top of Typeable.
07:55:03 <nitrix> I think we have a good summary. Thanks merijn, aweinstock.
07:56:14 <nitrix> Is it common to use Dynamic with/instead of existantial types?
07:57:07 <merijn> @define eqAny :: (Typeable a, Typeable b, Eq a) => a -> b -> Bool; eqAny x y = Just x == cast y
07:57:09 <lambdabot>  Defined.
07:57:16 <merijn> > eqAny 1 True
07:57:17 <lambdabot>  False
07:57:24 <merijn> > eqAny 'c' 'c'
07:57:25 <lambdabot>  True
07:57:28 <merijn> > eqAny 'c' 'a'
07:57:29 <lambdabot>  False
07:57:34 <nitrix> Very cool.
07:57:44 <nitrix> So I'm guessing the answer is Yes ?
07:57:58 <merijn> nitrix: I'm not sure use of Typeable is common in general :p
07:58:39 <merijn> nitrix: imo, Typeable, much like existential quantification is almost never relevant. But when it is, there's generally no other way to tackle said problem
07:59:38 <nitrix> There's where I'm at. It's for my relational `Big Library (TM)` that everyone seem suspicious about :P
07:59:50 <nitrix> I'm making progress though.
08:01:16 <Cale> nitrix: Typeable is way more common than Dynamic though. Dynamic is a trivial application of Typeable which is usually less precise than the thing you actually want.
08:02:03 <fr33domlover> I read a bit about fundeps vs type families - is there a reason these days to use fundeps in new code?
08:02:21 <fr33domlover> I mean does it have use cases where type families don't apply or where fundeps are better?
08:02:32 <mnjot> I thought of bringing this to -blah, but can't join there because of ssl something. 
08:02:40 <mnjot> data (Show n) => PTree =  Node n | Branch PTree PTree   -- what's wrong there?
08:03:14 <dolio> Fundeps look nicer in quite a few situations, if you don't need the semantics of type families.
08:03:48 <merijn> mnjot: Typeclass constraint in front of the PTree type is illegal
08:04:01 <kadoban> mnjot: data PTree = Node n | Branch PTree PTree deriving (Show)
08:04:09 <dolio> Technically there are certain things they can do that families can't, I think. But that's because they're kind of weaker in other areas.
08:04:14 <merijn> fr33domlover: Supposedly FunDeps have better inference
08:04:15 <mnjot> yes, but I have a custom Show function for that type. 
08:04:34 <merijn> fr33domlover: At least, that's what edwardk has told me, so I'm just parrotting it :)
08:04:35 <kadoban> mnjot: Then without the deriving
08:04:36 <mnjot> it works if I say "Node Int" and pretend other kinds of show-able nodes never come up.
08:05:03 <fr33domlover> dolio, I have a class (Graph vertex edge) and multiple graphs have their edges stored in the same place, so I want to add the type of an argument used to pick a specific graph. Intuitively I went for Graph a b i | a b -> i
08:05:16 <fr33domlover> Just curious if type families would make it any better :P
08:05:29 <kadoban> mnjot: In your instance declaration you have to do something like   instance (Show a) => Show (PTree a)
08:05:30 <dolio> Does i need to be in the class anyway?
08:05:43 <kadoban> Also I left the 'n' out of the left side of the = sign in my data thing above, woops.
08:06:43 <fr33domlover> dolio, the class has a method in similar fashion to selectEdges :: i -> Proxy (a, b) -> IO (g a b i)
08:06:59 <fr33domlover> the 'i' is used in the method type sig, that's why it's in the class
08:07:09 <dolio> Actually, I guess I know it doesn't, because there's only that one fundep.
08:07:21 <Cale> mnjot: Well, it's a question about Haskell, so it belongs here, but also, there is #haskell-offtopic which is a new and somewhat more official offtopic channel for #haskell (it has the same operators), and doesn't require TLS/SSL
08:07:31 <nitrix> mnjot: You want #haskell-offtopic instead of #haskell-blah.
08:07:46 <dolio> fr33domlover: I mean, you could write it as 'class Graph a b where { type I a b ; ... }'
08:08:00 <dolio> An associated type.
08:08:08 <fr33domlover> dolio, indeed. The question is whether it would be an advantage
08:08:16 <fr33domlover> I mean, which should I prefer?
08:08:20 <fr33domlover> How do I choose
08:08:56 <dolio> If you ever are in a situation where you need to know 'Graph a b i, Graph a b j ==> i ~ j' then you need families.
08:09:27 <mnjot> Cale:  yeah, but it's so basic. And then I interrupt a discussion about type-level programming or whatever fundeps are.
08:09:49 <Cale> mnjot: Don't worry about that -- beginner questions are as welcome here as anything else :)
08:10:02 <Cale> mnjot: The problem is that n isn't in scope -- perhaps you wanted  data PTree n = Node n | Branch (PTree n) (PTree n)
08:10:18 <fr33domlover> dolio, hmm can you give an example of a situation where I'd need that?
08:10:23 <Cale> The Show constraint usually will go on functions that act on the data structure
08:10:35 <dolio> fr33domlover: No. But sometimes it happens.
08:10:57 <Cale> It is possible to put a Show constraint there, but it doesn't accomplish much (it just restricts the types of the data constructors)
08:11:10 <mnjot> http://pastebin.com/XcCiKuZ6
08:11:22 <mnjot> Cale: yes, I fixed that.
08:11:28 <mnjot> but still. 
08:11:34 <mnjot> I forgot to paste the error message.
08:11:46 <dolio> fr33domlover: I suppose it could involves something like 'data EGraph a b = forall i. Graph a b i => EG ...'
08:11:50 <Cale> Also, maybe try lpaste.net, it's a bit better at Haskell code
08:12:04 <mnjot> okay.
08:12:10 <dolio> If you unpacked two of those, and knew they had the same a and b, with fundeps you wouldn't know that they were in fact the same i.
08:12:24 <dolio> So they wouldn't be compatible.
08:12:33 <dolio> But with families, they would be.
08:13:41 <fr33domlover> dolio, I don't plan to have anything like that :P regardless, a tiny advantage of using an associated type is shorter constraints: "Graph a b =>" instead of "Graph a b i"
08:13:56 <fr33domlover> (i is rarely used, in most cases I care only about a and b)
08:14:01 <mnjot> with error message: http://lpaste.net/173589
08:14:12 <dolio> fr33domlover: Yes, but all the 'i' equivalents are longer, so it's usually not a good trade off on that front.
08:15:00 <glguy> mnjot: You'll need to add a Show constraint to n
08:15:10 <glguy> instance Show n => Show (PTree n) where
08:15:10 <dolio> Anyhow, if it doesn't bug you, I'd probably go with families. I think their semantics is better.
08:15:48 <mnjot> ah yes.
08:15:52 <mnjot> glguy: that does it.
08:15:54 <glguy> mnjot: That's what the error message means:       add (Show n) to the context of the instance declaration
08:16:25 <mnjot> so wait. class constraints are applied to functions, not data type definitions?
08:16:38 <Cale> mnjot: Typically, yeah.
08:16:46 <mnjot> because then I could have functions on PTrees that were not Show-able?
08:16:51 <mnjot> (say, have PTrees of functions)
08:16:53 <Cale> Yeah
08:17:00 <mnjot> thatś confusing, but sounds powerful.
08:17:30 <merijn> mnjot: Is it really so confusing when you think about it? :) A list of printable things is printable, a list of not printable things is not :)
08:18:09 <Cale> Also, it is usually best for Show to produce Haskell code for reconstructing the value, rather than being some arbitrary prettyprinter
08:18:31 <Cale> It's really convenient when debugging if you can copy the printed values and put them into GHCi and use them to test further things
08:18:48 <glguy> Additionally the rest of the Show instances assume that you've done this
08:18:50 <fr33domlover> dolio, an associated type is more like detail about the class, while in a fundep, that i is just another typeclass param. In my case the graph is stored in SQL and the 3 params basically say: (1) in which table vertices are stored; (2) in which table edges are stored; (3) type of index value used to pick a single graph's vertices from the table (which has nodes of potentially many unrelated graphs)
08:19:02 <fr33domlover> So in that sense, fundeps feel more right in this case
08:19:06 <mnjot>  I could have the pretty printer not be called "show". 
08:19:11 <glguy> so when you show a Maybe a, the show instance is going to assume that it makes sense to wrap a Just around that
08:19:12 <fr33domlover> (assuming that's what you mean by semantics)
08:19:23 <Cale> mnjot: Right :)
08:20:43 <fr33domlover> (also I'm more used to using fundeps than associated type so I may be biased, although I do see lots of use of associated types in persistent, which I use a lot)
08:20:45 <dolio> fr33domlover: No, I just mean the way they work.
08:24:26 <dolio> You can encode fundeps using associated types, too. 'data (i ~ I a b) => Graph a b i where { type I a b ; ... }'. I mean, really, they're saying that there's a function from a and b to i, which is what fundeps are also saying.
08:24:48 <dolio> Anyhow, if you're more comfortable with fundeps, they're probably fine to use, too.
08:26:38 <fr33domlover> This suggests to default to associated types: http://stackoverflow.com/questions/12956063/functional-dependencies-vs-type-families
08:29:15 <fr33domlover> hmm this is a good chance to learn type families, I never used them before
08:29:48 <fr33domlover> dolio, thanks for all the info :)
08:29:52 <zlens> I want a minimal haskell webserver with (1) websockets + (2) serve a bunch of static files -- I don't need templates, auth, routing, whatever else is popular these days. What should I use?
08:31:32 <kadoban> zlens: Why use haskell at all if all you want is a webserver that serves static files? What would haskell be doing for you in this case?
08:31:53 <zlens> kadoban: it's handling the websockets part
08:31:55 <Cale> kadoban: Presumably all the stuff that happens over the websocket
08:32:00 <zlens> I'm using the browesr as a GUI
08:32:05 <Cale> It sounds a lot like our setup actually
08:32:06 <zlens> ahskell sends cmds to the browser, which the js then evals
08:32:20 <Cale> We use Snap, but just ignore the 90% of it that we don't use
08:32:23 <Cale> and https://hackage.haskell.org/package/websockets
08:32:32 <zlens> the browser is literally (load index.html, load a js file, which (1) connects to haskell ws, and (2) evals wahtever ahskel sends back)
08:32:38 <Cale> which... isn't perfect, but it works
08:32:40 <zlens> Cale: I'm using that lib -- I got the ws part up.
08:32:44 <zlens> Cale: however, how do I serve static files?
08:32:53 <zlens> due to XSS issues, don't I ened static file and ws to be on the same port ?
08:33:11 <zlens> and the example they have creates a WS chat setup ... but doesn't show you how ot serve index.html and index.js
08:33:30 <glguy> zlens: http://hackage.haskell.org/package/snap-core-0.9.8.0/docs/Snap-Util-FileServe.html
08:33:38 <Cale> zlens: We're using it from inside a Snap handler
08:34:11 <zlens> Cale: lol, you guys loaded up all of snap just to serve static files? :-)
08:34:18 <zlens> alright, I'll use snap
08:35:09 <Cale> zlens: Well, we do a few more things with it
08:35:18 <Cale> zlens: File uploads are separate
08:35:34 <Cale> There's a bit of compression stuff which is also involved
08:36:24 <Cale> https://hackage.haskell.org/package/websockets-snap-0.9.2.0/docs/Network-WebSockets-Snap.html
08:38:12 <Cale> zlens: Our frontends are written using reflex-dom
08:40:05 <Cale> So mostly it's just static files and websocket communication, but there's the occasional need to handle some additional case, and it doesn't hurt to have the rest of Snap lying around for when that happens.
08:48:30 * hackagebot transient-universe 0.3.2.2 - Remote execution and map-reduce: distributed computing for Transient  https://hackage.haskell.org/package/transient-universe-0.3.2.2 (AlbertoCorona)
08:54:10 <mnjot> what should be the data constructor like for root in data RTree n = {root :: n, tree:: PTree n}
08:54:37 <glguy> mnjot: RTree would be an OK choice
08:55:14 <mnjot> I think I'm missing more basic concepts.
08:55:42 <glguy> data TypeConstructor type variables = DataConstructor { recordFieldName :: RecordFieldType }
08:56:19 <mnjot> if terminology more or less follows mathematics, "data Color = Red | Yellow | Blue | Green | Violet | Fuchsia" is a sum type. and "data Color n = (Red n) (Green n) (Blue n)" is a product type.
08:56:25 <mnjot> but I don think I know how to specify product types.
08:56:41 <glguy> mnjot: Your RTree is a "product type"
08:56:44 <mnjot> (that's possibly the wrong terminology)
08:56:50 <mnjot> yes.
08:57:07 <glguy> You're just missing the "DataConstructor" bit from what I wrote above
08:57:37 <mnjot> ok. in ordinary, non-record syntax how do I specify that type?
08:57:52 <mnjot> (forgetting the automatic destructors. I used to know this stuff 10 years ago.)
08:58:27 <glguy> data RTree n = MkRTree n (PTree n)
08:58:36 <mnjot> that type or, say,RGB color.
08:58:52 <mnjot> is data Color n = (Red n) (Blue n) (Green n) ok?
08:58:59 <glguy> no
08:59:04 <implementation> data Color n = RGB (Red n) (Green n) (Blue n)
08:59:36 <mnjot> ah ok. it needs a product type constructor before the dimensions are given.
08:59:39 <implementation> you need the constructor name, be it "RGB" or "Color" or "MkColor" or whatever you like
09:00:11 <mnjot> so data EuclideanPoint p = RCubed (X p) (Y p) (Z p) 
09:00:22 <implementation> righ
09:00:25 <implementation> +t
09:00:29 <glguy> probably just: data EuclideanPoint p = RCubed p p p
09:00:35 <mnjot> ok. sorry for the string of beginner questions.
09:00:40 <glguy> It's unlikely that you'd have separate X Y Z coordinate types
09:00:56 <mnjot> glguy: not in euclidan space, no. 
09:01:23 <mnjot> actually, not in metric spaces. possibly in the case of product measures.
09:01:29 <aweinstock> data Vec3 p = Vec3 { x :: p, y :: p, z :: p } -- if you want to give the coordinates names
09:02:20 <aweinstock> and then you can do (Vec3 1 2 3 :: Vec3 Int), which is equivalent to (Vec3 { x=1, y=2, z=3 } :: Vec3 Int)
09:03:14 <aweinstock> with (data Vec3 p = Vec3 p p p), only the first is valid
09:04:26 <aweinstock> mnjot: record syntax is just syntactic sugar for product types + automatically creating getters like (x :: Vec3 p -> p; x (Vec3 a b c) = a)
09:04:39 <mnjot> yes.
09:05:00 <mnjot> what I was missing is that product types need a master constructor. sum types don't. 
09:05:32 <glguy> data types are sums of products, so a "product type" is a trivial sum of one product type
09:05:33 <mnjot> which only makes sense if you're going to have a mixture of product and sum types like data PTree n = Node n | Branch (PTree n) (PTree n).
09:05:40 <glguy> it's not so much that it's a master
09:06:59 <ggole> glguy: that's because data types are nominally typed: "anonymous" sum and product types don't have that
09:07:39 <eklavya> I am almost there in my template haskell instance construction
09:07:41 <eklavya> http://lpaste.net/173604
09:07:53 <eklavya> I need to create the record as the last step in 36
09:08:09 <eklavya> can anyone please help?
09:09:59 <glguy> eklavya: What about:    return ( $(conE cName) a)
09:10:12 <eklavya> yeah I tried that
09:10:18 <eklavya> it needs a constructor there
09:10:52 <eklavya> for record data T = T { a :: Int } 
09:10:59 <eklavya> it gives Type constructor ‘T’ used where a value identifier was expected
09:11:52 <eklavya> it generates:
09:11:58 <eklavya> instance CR T3 where
09:11:58 <eklavya>       fromCR m_as9O
09:11:59 <eklavya>         = do { a_as9P <- ((runGet (get :: Get Int))
09:12:00 <eklavya>                           <$> (DMS.lookup "a" m_as9O));
09:12:02 <eklavya>                return T3 a_as9P }
09:14:16 <glguy> eklavya: You need to get the data constructor name out of "constructors" on line 29
09:14:35 <glguy> Oh, you're almost there on line 31
09:14:54 <glguy> it's the first field that you've got _'d
09:15:49 <eklavya> oh yeah
09:15:57 <eklavya> glguy: you are a wizard man
09:16:02 <eklavya> everytime, everytime
09:16:04 <eklavya> :D
09:16:51 <eklavya> I can't believe I was just using the wrong name all this time !!
09:18:41 <eklavya> glguy: any suggestions on how I could insert the (a <- onOfRecordField) statements based on the args in that do block?
09:18:52 <eklavya> I am doing it for a single arg right now
09:19:04 <eklavya> I need a way to map on args and then insert it into the do
09:19:39 <glguy> You're going to quickly find yourself going beyond the power of the [d| |] quotation
09:19:43 <glguy> But that's OK
09:20:01 <eklavya> yeah I think I need to create the AST in this case
09:20:09 <eklavya> to be able to insert inside a do block
09:20:15 <glguy> You'll need to generate newName-s for all the results, name the process of decoding a value
09:20:38 <glguy> You can build up some do-notation with doE
09:21:00 <eklavya> that would be super cumbersome and really hard to read :(
09:21:02 <eklavya> no other way?
09:21:05 <glguy> and then at the end you'll have something like:    appsE (conE cName : map varE namesOffields)
09:21:25 <eklavya> oh
09:21:48 <glguy> You can still use the declaration quoter to make your instance
09:22:09 <glguy> but you'll be loading the do-block expression with a splice
09:22:31 <eklavya> if only I could give a list [a] like the a now
09:22:50 <glguy> lines 34/35 will be something like: $(doE ( thingsThatBuildUpNames ++ [ thingThatReturnsResult ] ) )
09:23:17 <eklavya> let me try it out
09:23:28 <eklavya> I will get back with the results, thanks :)
09:24:19 <ertes> strict function fields are pointless, right?  example:  data T = T !(A -> B)
09:24:38 <glguy> Not any more than any other strict field
09:24:42 <Cale> ertes: No, they do stuff.
09:25:11 <glguy> ertes:  myFunction | expensiveBool = impl1 | otherwise = impl2
09:25:50 <ertes> i ask because i was told that forcing functions doesn't do anything
09:26:09 <Cale> ertes: An expression is in weak head normal form if it's a constructor applied to some arguments, or if it's a lambda. There are lots of expressions of function type which are nevertheless still applications or something else.
09:26:17 <glguy> It does do stuff
09:26:30 <Cale> Forcing the evaluation of a function may then do arbitrary amounts of work.
09:26:41 <ertes> yeah, makes sense
09:26:53 <ertes> > (undefined :: Int -> Int) `seq` ()
09:26:55 <lambdabot>  *Exception: Prelude.undefined
09:27:06 <hpc> forcing the valuation of a memoized function might trigger setting up the memo table, for instance
09:27:08 <ertes> ok, thanks
09:27:26 <hpc> or if the function is bottom, that's distinct from const bottom and you get a crash
09:28:15 <hpc> *evaluation
09:29:20 <ertes> yeah, actually i already made use of that, so i should have known
09:29:48 <ertes> let { f x = \y -> … where !z = … } in map f
09:30:18 <ertes> uhm
09:30:20 <ertes> let { f x = \y -> … where !z = … } in map f x
09:30:26 <ertes> UHM
09:31:03 <glguy> uh oh, ertes locked up
09:31:28 * glguy tries turning him off and on again
09:31:42 <ertes> phew…  thanks!
09:31:45 <ertes> let { f x = \y -> … where !z = … } in map (f x)
09:31:47 <ertes> there we go
09:33:31 * hackagebot transient-universe 0.3.2.3 - Remote execution and map-reduce: distributed computing for Transient  https://hackage.haskell.org/package/transient-universe-0.3.2.3 (AlbertoCorona)
09:49:31 <anohigisavay> hi
09:49:57 <anohigisavay> i'm using hpc to get coverage reports
09:50:08 <hpc> don't tell me what to do :D
09:50:17 <anohigisavay> _(:з」∠)_
09:50:44 <anohigisavay> ╮(￣▽￣)╭
09:50:55 <hpc> (anyway, continue)
09:51:05 <anohigisavay> your coverage reports marks `deriving Show` as uncovered
09:51:26 <anohigisavay> yes it is but it's irrelavent to my logic and i want these lines excluded 
09:52:12 <hpc> i actually don't know much about hpc
09:52:23 <hpc> if it's possible for you to not derive Show there, maybe do that?
09:52:46 <hpc> or if some other class instance depends on Show, then you're probably using it without realizing and need to be covering it
09:52:49 <anohigisavay> hpc: sadly no. hpc kinda depends on this to show error messages when tests fail
09:53:03 <hpc> haha
09:53:14 <hpc> that's pretty ironic
09:53:56 <anohigisavay> need to fail some tests to get a prettier coverage report ●﹏●
09:53:57 <hpc> if nothing else, maybe you can just make some basic always-passes test with a comment of "this is just here to make the coverage report happy"?
09:54:34 <anohigisavay> hpc: that'll work
09:55:09 <anohigisavay> i see someone on stackoverflow that does `showList ... `seq` ... `seq`... all the way
09:55:47 <hpc> that sounds about right
09:56:35 <anohigisavay> k i'll go with that
09:56:45 <anohigisavay> hpc: add this to your issue list xD
09:59:33 <nitrix> @let meaningfulInput input f = do { oldS <- get; let newS = f input oldS; put newS; return input }
09:59:34 <lambdabot>  Parse failed: Parse error: ;
09:59:42 <nitrix> How to write this in lambdabot without getting the parse error?
10:00:05 <eklavya> glguy: it's proving to be just as hard as I feared :(
10:00:32 <glguy> eklavya: perfect, no surprises!
10:00:40 <eklavya> :D
10:01:08 <hpc> @let meaningfulInput input f = do { oldS <- get; let {newS = f input oldS}; put newS; return input }
10:01:09 <lambdabot>  Defined.
10:01:14 <eklavya> without [||] it's hopeless
10:01:21 <nitrix> hpc: braces for the let?
10:01:27 <nitrix> thanks
10:01:55 <hpc> nitrix: yeah, the parsing rule for a lump of definitions is kind of odd
10:02:31 <hpc> where doesn't have any problems because it's at the end of a definition, let-in has "in" to delimit it, but do-let tries to take subsequent lines as definitions
10:07:50 <hpc> :t modify
10:07:51 <lambdabot> MonadState s m => (s -> s) -> m ()
10:08:14 <codedmart> What is the haskell equivalent of getTime in Javascript `A number representing the milliseconds elapsed between 1 January 1970 00:00:00 UTC and the given date`
10:08:29 <sbrg> There's getCurrentTime
10:08:36 <sbrg> > :t getCurrentTime
10:08:37 <lambdabot>  <hint>:1:1: parse error on input ‘:’
10:08:42 <hpc> :t getCurrentTime
10:08:44 <lambdabot> Not in scope: ‘getCurrentTime’
10:08:48 <hpc> @hoogle getCurrentTime
10:08:50 <sbrg> I thought that was its name.
10:08:51 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
10:08:51 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
10:08:59 <sbrg> but I'm not sure that's milliseconds
10:09:26 <hpc> it is
10:09:34 <hpc> UTCTime = (Day, DiffTime)
10:09:42 <sbrg> ah
10:09:42 <hpc> and DiffTime has a resolution of 10**-12
10:09:43 <mauke> codedmart: getPOSIXTime
10:10:31 <codedmart> mauke: Ah right I missed that. Thanks!
10:10:38 <merijn> hpc: 10**-12 what?
10:10:43 <hpc> seconds
10:11:26 <merijn> hpc: That's what I guessed after some thinking, I'm just being pedantic :)
10:11:36 <merijn> It's not necessarily obvious :p
10:11:45 <hpc> heh, fair enough
10:12:02 <hpc> i was partially quoting the documentation
10:12:37 <hpc> codedmart: usually you want to use UTCTime anyway
10:12:52 <codedmart> hpc: Really how come?
10:12:59 <codedmart> Just wondering
10:13:08 <sbrg> @hoogle getPOSIXTime
10:13:09 <lambdabot> Data.Time.Clock.POSIX getPOSIXTime :: IO POSIXTime
10:13:29 <hpc> it's a more abstract representation of time, and specifically represents an exact UTC time
10:13:38 <sbrg> what is POSIXTime? some wrapper around a C struct?
10:13:40 <Cale> and it has all the useful operations
10:13:52 <hpc> type POSIXTime = NominalDiffTime, which technically is only a length of time
10:14:07 <sbrg> date/time is so complicated
10:14:09 <hpc> and you have to arbitrarily decide on a zero yourself, which is normally PSIX's zero
10:14:21 <hpc> UTCTime also has all the useful functions as Cale mentions
10:14:31 <hpc> most notably it has FormatTime and ParseTime instances
10:15:12 <hpc> meaning whenever you are reading a date from a string, you're automatically going to find UTCTime the path of least resistance
10:15:47 <hpc> https://hackage.haskell.org/package/time-1.6.0.1/docs/Data-Time-Clock.html#t:NominalDiffTime
10:16:05 <codedmart> OK so is `utctDayTime` unique always or is it the combo of `utctDay` and `utctDayTime` that is unique?
10:16:20 <hpc> see also the operations at the bottom of the page, which solidify NominalDiffTime's position as an unanchored length and not a single point on the timeline
10:16:44 <hpc> codedmart: i am hesitant to name any properties at all about UTCTime as far as how it's implemented
10:16:54 <hpc> codedmart: to put it lightly, time is weird as shit
10:17:19 <codedmart> OK maybe I should go about this different.
10:17:38 <codedmart> Is uuid’s representative of time at all?
10:18:18 <sbrg> I read recently that for some types of UUIDs, the first N bytes are timestamp info, if that's what you mean
10:18:22 <sbrg> where N is some constant I don't remember.
10:18:31 <codedmart> I will dig some more. Thanks guys!
10:18:34 <codedmart> sbrg: OK cool
10:18:36 <Zekka> (Sorry for leaving and rejoining a lot! My client was misbehaving and it kept asking me to restart it.)
10:18:41 <sbrg> s:bytes:bits:, maybe
10:18:55 <hpc> codedmart: ah, do you need some monotonically increasing identifier that's bound to the current time?
10:19:07 <codedmart> hpc: That was my idea.
10:19:07 <hpc> codedmart: because fun fact, time is not monotonically increasing
10:19:54 <merijn> Which OS?
10:19:56 <hpc> i recommend using something that increments by 1 each time, if you can
10:20:11 <hpc> or if it doesn't need to be always monotonic but just close enough, take a look at https://hackage.haskell.org/package/time-1.6.0.1/docs/Data-Time-Format.html#t:FormatTime
10:20:11 <merijn> linux has a monotonic clock
10:20:19 <merijn> Not sure if it's portable
10:20:20 <Zekka> merijn: which os re who?
10:20:41 <codedmart> hpc: Thanks!
10:20:56 <hpc> merijn: i think that's what getPOSIXTime reads from
10:21:35 <theduke> Hey there. Can anyone recommend some medium-depth articels on GHCs sparks/microthread model?
10:21:52 <hpc> theduke: have you read the commentary?
10:21:54 <hpc> @where commentary
10:21:54 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/Commentary
10:22:08 <hpc> iirc it has some stuff on that, don't remember how deep it goes
10:22:19 <merijn> hpc: I doubt it, clock monotonic is different from gettimeofday which returns posix time
10:22:34 <hpc> ah, maybe not then
10:22:46 <theduke> hpc: thanks, I'll check it out
10:22:52 <hpc> that clock isn't totally monotonic either if it's going too fast and ntp updates it, either
10:23:33 <hpc> anyway it depends on what level of "increasing unique identifier" codedmart needs
10:25:34 <hpc> codedmart: feel free to ignore some of this advice too, if you don't actually need to be totally monotonically increasing, or unique
10:25:53 <codedmart> hpc: :) fair enough.
10:26:14 <hpc> sometimes a 64-bit seconds-since-1970 is really good enough, but since you said "uuid" i went into "it has to be exactly perfect" mode :D
10:26:36 <hpc> and time is so bad for "exactly perfect" that you might as well not bother
10:26:56 <hpc> nobody in the world knows what time it will be exactly 12 months from now, for instance
10:27:11 <hpc> just 31536000 seconds away
10:27:38 <hpc> adjustments to UTC happen with 6 months notice and are totally unpredictable
10:28:24 <hpc> there's entire weeks of time that don't exist because of calendar changes, hours that happen twice, seconds that take longer than others, days that only exist sometimes, it's nuts
10:28:31 * hackagebot type-natural 0.6.0.0 - Type-level natural and proofs of their properties.  https://hackage.haskell.org/package/type-natural-0.6.0.0 (HiromiIshii)
10:30:03 <hpc> and if you go about 60 miles straight up to where the ISS is, time dilation makes you lose a measurable amount of time
10:30:07 <hpc> so it's location-dependent too
10:30:35 <dysfun> hpc: handily you can just subscribe to bulletin C and use UTC
10:31:30 <EvanR> the key is that peoples expectations of time dont care about physics or even politics most of the time, they are nice abstract spaces which are not that bad
10:31:51 <dysfun> until you consider things like daylight savings, you mean? ;)
10:32:11 <EvanR> library desginers dont know this and so programmers are flabbergasted
10:32:14 <hpc> yeah, time doesn't even make sense at the level that humans deal with
10:32:17 <kadoban> EvanR: I don't think that's actually true. People just assume they're nice and abstract, until something happens that they didn't expect and then it's all your fault.
10:32:20 <EvanR> dysfun: nope
10:32:28 <EvanR> im not assuming
10:33:24 <EvanR> and "its so hard" lore makes it seem even worse
10:33:39 <dysfun> well it's hard doing it with most libraries
10:33:40 <EvanR> we need trade prigress
10:33:47 <EvanR> progress
10:33:57 <Shou> Is "structural associativity" a good description of the property of a binary operator whose constructors are equal no matter the precedence?
10:34:19 <hpc> EvanR: it's not that "it's so hard", it's just knowing what operations make sense and which don't when you look at time from which perspectives
10:34:21 * dysfun was once tasked to stop the tests failing during BST
10:34:33 <dysfun> (jobs were run between midnight and 1am)
10:34:57 <Cale> It actually kind of confuses me why people seem to like throwing timestamps into UUIDs thereby reducing their entropy
10:35:03 <hpc> dysfun: so it was running twice then?
10:35:25 <dysfun> hpc: no, it was hitting a database in the wrong timezone
10:35:32 <hpc> ah, even more fun
10:35:33 <Cale> I guess if you care about the order in which they were constructed, then it gives you something to sort by.
10:36:10 <dysfun> mongodb heavily abuses that feature for it's not-quite-uuid
10:36:51 <hpc> some mail servers do that for message IDs and queue IDs, though not for sorting
10:37:07 <hpc> it's so an admin can more easily find the message in question when there's a problem
10:37:29 <hpc> mail logs can be gigs per day, so just knowing which day it was narrows it down a lot
10:38:10 <hpc> and they're just the date prepended on another unique identifier anyway
10:38:58 <Cale> Yeah, I would tend to prefer just including things like the date separately if that's needed.
10:40:22 <caw> What's the best way one would convert a hex string to a Word32?
10:40:48 <Cale> :t readHex
10:40:49 <mjrosenb> caw: prepend "0x", and read?
10:40:49 <lambdabot> (Eq a, Num a) => ReadS a
10:40:55 <mjrosenb> or readHex.
10:41:18 <glguy> \x -> case readHex x of [(n,"")] -> Just n; _ -> Nothing
10:41:32 <caw> Is there a preferred or best practice way though? (This seems trivial, I know...)
10:41:54 <Cale> Whatever works. readHex is in the base library
10:42:25 <glguy> definitely don't accept anything less than the best practices
10:43:04 <caw> @glguy ;)
10:43:04 <lambdabot> Unknown command, try @list
10:43:20 <glguy> Using @ for addressing people is not best practice
10:43:34 <caw> Aren't you pleasant
10:43:37 <glguy> :)
10:43:50 <caw> Anywho, thanks for the help
10:44:50 <mtesseract> Hi
10:45:05 <glguy> I'm a bit surprised that there's not a pre-packaged runReads :: ReadS a -> String -> Maybe a
10:45:46 <shapr> submit a PR?
10:48:48 <glguy> I guess the questions to resolve would be 1) require unique parse vs take first parse, 2) allow trailing whitespace or not
10:49:19 <glguy> actually, just doing whatever readMaybe does is probably the right way
10:49:25 <glguy> read already allows trailing whitespace
10:50:07 <glguy> and doesn't tolerate ambiguity
10:50:13 <mtesseract> Say I want to make a typeclass PartialOrdering, which implements an <= operator for partially(!) ordered sets (Data.Ord's <= is for totally ordered sets). In particular I am thinking of providing an instance decleration for Sets based on the is-subset-of-notion. Say I would like to also provide instance declerations for some other types. My idea was to write something like "instance Real a => PartialOrdering
10:50:15 <mtesseract> a" implementing my <= in terms of the traditional <= relation for real numbers. But this triggers several typechecking problems, because instance contexts are not respected during typeclass matching. I guess I am overlooking something... how would I formulate in Haskell "use this instance decleration for a type T that implements the Real typeclass interface"?
10:50:48 <Cale> mtesseract: You wouldn't.
10:50:58 <mtesseract> Cale: What would I do instead?
10:51:05 <Cale> Each instance should match on at least one type constructor.
10:51:18 <dfeuer> Grr... This is complicated. I'm trying to figure out how to make <* fast for Data.Sequence. It seems considerably trickier than *>.
10:51:35 <glguy> mtesseract: If there's an implementation of a class method that makes sense generically, you can define that and then use it in each instance where it's appropriate
10:52:01 <glguy> instance PartialOrder SomeType where (<=?) = defaultOrderingForReals
10:52:07 <dfeuer> It should be possible to get a bunch of sharing within subtrees, but I don't know how to structure the whole mess.
10:52:42 <Cale> You can also provide default implementations of the class methods inside the class declaration, and there is an extension to give them a more specific type to the default methods, whereby they will only be used in cases where that type unifies with the type needed for the instance
10:52:57 <mtesseract> glguy: I'm not sure what the last line is supposed to mean. (<=?) <- ?
10:53:19 <dfeuer> I was able to make *> good by just stripping complications out of <*> and stealing some replication code to fill in a gap, but this side is harder.
10:53:22 <glguy> mtesseract: Replace that operator with whichever operator you happen to be using in the definition of your class
10:53:24 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#default-method-signatures
10:53:31 * hackagebot uni-htk 2.2.1.3 - Graphical User Interface for Haskell Programs  https://hackage.haskell.org/package/uni-htk-2.2.1.3 (ChristianMaeder)
10:53:38 <Cale> mtesseract: That's the method name
10:53:40 * dfeuer hates the design of DefaultMethodSignatures.
10:54:12 <Cale> mtesseract: He's assuming you don't actually want to shadow the definition of (<=) in the Prelude, because that would be obnoxious.
10:54:41 <mtesseract> Actually I think it's bad that <= implies a total order.
10:55:05 <dfeuer> Not too obnoxious if it's working in a very different realm....
10:56:36 <dfeuer> mtesseract, I agree; <=, <, >=, and > should be in a partial ordering class. Then there are pre-orders to think about....
10:56:46 <Cale> mtesseract: In my experience, >90% of the time you need an Ord t constraint, it's because you want to form a Set of values of type t or Map keyed by values of type t. That requires a total ordering.
10:57:12 <mtesseract> Cale I am not saying that there should be no Ord typeclass.
10:57:19 <dfeuer> Cale, do you have any thoughs on how to write this <*?
10:57:40 <Cale> dfeuer: hm?
10:57:51 <dfeuer> I'm trying to optimize <* for Data.Sequence.
10:58:30 <Cale> Oh, no idea. It's been a long while since I last looked at how Data.Sequence worked internally.
10:58:32 <dfeuer> Cale, <$, <$>, *>, and <*> are about as good as they can be, but <* uses the default definition, which doesn't share as much as it can.
10:59:03 <mtesseract> glguy: To be honest, I am not sure what you are suggesting for my problem. Are you saying I should drop the idea of implementing PartialOrd "for a typeclass [like Real]" and instead use concrete types, like Int, Integer, Float, etc.?
10:59:06 <dfeuer> I'd like to fix that, of course.
10:59:40 <dfeuer> Doesn't share anything, actually.
10:59:46 <dfeuer> It's silly.
10:59:53 <glguy> mtesseract: No, just that you're going to have one instance per type and that you can share the implementation between each of them for the case of the ones that would have been covered by your original bit of code for Reals
11:00:33 <Cale> dfeuer: Oh, another Map operation which is conspicuously missing: splitAt
11:00:41 <Cale> There are a bunch of index-related operations, but not that one
11:01:18 <Cale> and given that size is O(1), you'd expect it to be relatively doable
11:01:52 <dfeuer> Cale, good point! That goes for sets as well.
11:01:58 <Cale> yes
11:02:09 <dmwit> dfeuer: If you're the guy in charge, maybe you know why IntMap doesn't have the indexing operations.
11:02:33 <mtesseract> glguy: One instance per type ... meaning, one instance declaration for each type covered by Real but relying on some default implementation? Then the default implementations would need the Ord context. But for this there is the default-method-signatures extension. I think I understand.
11:02:41 <dmwit> (Just oversight, or is the implementation different enough that it's not efficient?)
11:03:15 <Cale> mtesseract: An important thing to understand is that the algorithm which selects which instance applies to any given type is *not* allowed to look at the class constraints on the instances.
11:03:28 <mtesseract> Cale: I got that.
11:03:28 <Cale> mtesseract: If you write  instance (Foo a) => Bar a
11:03:47 <Cale> it looks to the instance selection mechanism as if you wrote  instance Bar a
11:03:50 <dfeuer> dmwit, I do indeed! IntMap is based on big-endian PATRICIA trees. The key operations don't require size annotations, so to save space/time there aren't any. But that means index-based operations (and size calculations) are expensive.
11:04:29 <dfeuer> (Very expensive. Nothing better than O(n) seems at all likely to be available)
11:04:50 <Cale> The reason for that is that future modules might always expand which instances are available, and so it can't skip over an instance and commit to another one on the basis that the constraints aren't currently met.
11:05:21 <Cale> (because when that future module comes into scope, it might then make the decision about which instance to use differently, which would result in a confusing mess)
11:05:50 <mtesseract> Thanks for the explanation.
11:06:21 <dmwit> dfeuer: Bummer! I guess one could potentially make a variant that does have size annotations. But ballooning the containers library in that way probably doesn't make sense.
11:06:40 <dmwit> Especially considering how rare it is to need the indexing operations at all.
11:06:44 <dfeuer> dmwit, I really wish there were easy ways to write code that would just work with/without values (Set/Map) and with/without size annotations (IntSet/IntMap with/without indexing).
11:07:38 <dmwit> whoa
11:07:41 <dmwit> That is an ambitious wish.
11:08:05 <dfeuer> ;-). I think it would probably be feasible, but making it *efficient* is another story.
11:08:18 <Cale> ;__; we already have a complete replica of the Data.Map API just to have a different Monoid instance by default
11:08:19 <dmwit> right
11:08:27 <dfeuer> (unless you use Template Haskell or similar, in which case the code turns into horrors)
11:08:44 <dmwit> Cale: Ugh, yes, the Data.Map Monoid instance is just wrong.
11:08:59 <dfeuer> Yes, I know.
11:09:21 <dmwit> Maybe next major version number bump it can be fixed. ;-)
11:09:28 <Cale> I guess the really right one needs Semigroup to be in.
11:09:31 <dfeuer> Ain't nothing I can do about it, unless I add modules exposing newtypes  with better APIs.
11:09:50 <Cale> I wonder how much pain and suffering would really be caused by a switch
11:09:59 <dfeuer> Too much.
11:10:00 <Cale> Probably a lot :P
11:10:29 <dfeuer> I don't know how much code would need to be changed, but a *#@%-ton would need to be audited.
11:10:54 <Cale> Right, it would silently break a lot of things
11:11:13 <osfameron> is there any documentation for Data.Time ?
11:11:38 <Cale> Maybe someday we can move Data.Map to just be Map and fix the Monoid instance at the same time ;)
11:12:10 <Cale> I've honestly always been unhappy with the Data.* and Control.* module prefixes
11:12:32 <dfeuer> Cale, I think adding another module with a different interface to the same underlying implementation would be much less pain. If the community *really* wants to change the current one, I think the right way to do it would probably be to *remove* the Monoid instances for a couple major versions, then put them back the way they should be.
11:12:46 <ReinH> Cale: I guess we were pretty excited to have scoped modules.
11:13:00 <dmj`> osfameron: https://two-wrongs.com/haskell-time-library-tutorial
11:13:04 <Cale> ReinH: Yeah, people lost their minds
11:13:39 <Cale> ReinH: and the change was literally to make '.' a valid character in module names
11:13:47 <osfameron> dmj`: phew, thanks.  I found nothing much useful from google search result for haskell+datetime ;-)
11:14:04 <osfameron> ah, though that link is in fact on the first page, but just below the fold
11:15:01 <dolio> Data.Map isn't that bad. There could stand to be a lot more top level names, though.
11:15:24 <dmj`> osfameron: good info is out there, just well hidden at times =)
11:15:28 <dfeuer> Cale, I warn you, however: if I'm in charge of a major restructuring of Map, there will be some major changes to how lazy/strict stuff is handled. The current approach is confusing to users and horribly fragile to maintain.
11:17:38 <dfeuer> Hey, anyone want to help me optimize Data.Map.Base.unionWith for the singleton cases? I find insertWith and insertWithKey more confusing than I should.
11:17:40 <Cale> dfeuer: heh, I can see how some people would want Maps which were always strict in the values, rather than just lazy maps with strict operations.
11:17:56 <osfameron> dmj`: indeed!  is just a shame it's not linked to, or subsumed by the Data.Time module's own documentation, for example
11:17:59 <Cale> dfeuer: However, it's important to still have strict operations on lazy maps anyway
11:18:29 <dfeuer> Cale, oh, I completely agree.
11:18:40 <dfeuer> For some operations, anyway.
11:18:45 <Cale> yeah
11:19:13 <dfeuer> Anything vaguely map-like.
11:19:24 <dfeuer> That's why I just added adjust' to Data.Sequence.
11:19:28 <mtesseract> Nice, XDefaultSignatures does the trick.
11:19:30 <mtesseract> Thanks
11:19:42 <dfeuer> Because who really wants adjust? Basically ever?
11:20:16 <EvanR> ive used adjust
11:20:27 <dfeuer> EvanR, did you want its laziness?
11:20:34 <EvanR> no
11:20:37 <dfeuer> Well then.
11:22:50 <dfeuer> I've changed adjust so it builds up its thunks in chains on the affected elements (instead of clogging up the whole tree), but it still isn't usually what you want. update (no longer implemented using adjust) and adjust' are much better.
11:23:31 * hackagebot dot 0.2.1 - Data types and encoding for graphviz dot files  https://hackage.haskell.org/package/dot-0.2.1 (andrewthad)
11:31:57 <eklavya> glguy: I think I did it :D
11:32:05 <eklavya> phew
11:32:22 <eklavya> I can make instances for simple records now
11:46:30 <shapr> freeside: are you a member of the freeside makerspace?
11:50:31 <lightly> This is only a half-formed question, but why should fmap preserve composition? isn't the type (a -> b) -> (f a -> f b) enough?
11:51:03 <shachaf> Enough for what?
11:51:03 <shapr> @hoogle (a -> b) -> (f a -> f b)
11:51:04 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
11:51:05 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
11:51:05 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
11:51:23 <EvanR> the expectation is that fmap doesn't change the structure of the data, only the values
11:51:35 <EvanR> it wont truncate your list in the process 
11:52:10 <johnw> lightly: you need that type, and the first law
11:52:11 <EvanR> and everything based on Functor relies on that expectation 
11:53:02 <lightly> are there not any useful things that are like fmap but don't preserve composition?
11:53:34 <mniip> lightly, with the identity law?
11:53:36 <fishythefish> lightly: it's actually a theorem that the type of fmap and the fact that fmap id == id gives you fmap (f . g) = fmap f . fmap g
11:53:45 <mniip> yeah, the composition law can be proven from the identity law and parametricity
11:53:46 <johnw> lightly: also keep in mind that when you implement fmap, you choose f; it's not hard to implement a lawless functor for Maybe, for example, so the general type of fmap doesn't guarantee anything about its instances
11:53:55 <lightly> mniip: without I think
11:54:00 <shachaf> It's a theorem assuming that the type is a functor.
11:54:02 <mniip> well
11:54:22 <mniip> \f x -> []
11:55:24 <mniip> well, among more interesting things you have
11:55:29 <lightly> fishythefish: why is that?
11:55:34 <shachaf> That is, if there's a version of fmap that satisfies both laws, and you have a function foo with the same type that satisfies the identity law, then they must be equal.
11:55:43 <mniip> \f -> zipWith id (iterate (f .) id)
11:55:53 <fishythefish> lightly: it's a general concept known as free theorems
11:56:12 <fishythefish> lightly: https://www.mpi-sws.org/~dreyer/tor/papers/wadler.pdf if you're interested in reading the paper
11:56:20 <shachaf> But I think people aren't answering the question that was asked.
11:56:37 <shachaf> The question looks like, why are the functor laws what they are in the first place?
11:58:15 <fishythefish> lightly: Are you asking in particular why fmap must satisfy those laws, or whether a weaker version of fmap would be useful?
11:58:26 <lightly> um
11:58:53 <lightly> if a weaker version of fmap were useful then we would call that fmap I think
11:59:07 <lightly> I think I'm asking if a weaker version of fmap would be useful
11:59:55 <EvanR> lightly: we should really call fmap `map'
12:00:08 <EvanR> if there is something that acts differently may we should pick an entirely new name
12:01:53 <EvanR> Data.Text.map does the same thing, and is called map
12:02:01 <EvanR> its just specialized to Char
12:02:57 <dmj`> weird question, In aeson, is there a way to omitNothingFields deeply? Like data Foo = Foo { k :: K } deriving (Show, Generic), newtype K = K (Maybe Int), can encode (Foo (K Nothing)) become "{}" somehow? 
12:04:19 <mniip> EvanR, Text is not an endofunctor on Hask
12:04:26 <mniip> so no map/fmap
12:04:45 <EvanR> nonetheless it has an operation called map and it does the same thing
12:04:59 <mniip> does it
12:05:06 <mniip> can it lift an arbitrary morphism?
12:05:07 <dmwit> Text is an endofunctor from the one-object category containing Char and all its endofunctions to Hask.
12:05:10 <EvanR> you can think of Text as an optimized implementation of Vector Char
12:05:10 <mniip> of type a->b
12:05:13 <dmwit> s/endofunctor/functor/
12:05:21 <mniip> well
12:05:51 <mniip> dmwit, it is, but that doesn't make it a Prelude.Functor, does it
12:05:56 <EvanR> (Char -> Char) -> Vector Char -> Vector Char
12:06:02 <mniip> why why should it have a Prelude.fmap
12:06:16 <EvanR> what?
12:06:16 <dmwit> I don't think anybody is claiming it's a Functor.
12:06:51 <dmj`> nvm, will just put Maybe on the outside
12:30:46 <Serpent> what's up yall
12:31:10 <dmj`> Serpent: hi
12:31:10 <Serpent> who's here
12:31:45 <suzu> hi
12:31:50 <Serpent> sup
12:31:53 <suzu> nm
12:31:55 <suzu> haskell
12:31:57 <suzu> etc
12:31:59 <Serpent> truu
12:35:10 <shapr> I do love me some Haskell, mmm functors.
12:35:23 <suzu> i am doing some haskell RIGHT NOW even
12:35:26 <suzu> fancy that
12:35:28 <shapr> suzu: whoa cool! whatcha writing?
12:35:40 <suzu> do you happen to play pokemon go?
12:35:46 <Serpent> im new here lmao 
12:36:11 <suzu> it's.. a bot.. that will play pokemon go for me..
12:36:13 <suzu> <_<
12:36:16 <suzu> >_>
12:36:39 <rhovland> suzu: hope it's good at force closing and restarting
12:36:54 <suzu> i wrote one in python and it works but it's getting unwieldy and i wince when i try to refactor it
12:36:59 <suzu> hahaha rhovland 
12:37:20 <ongy> speaking of nintendo-stuff, has anyone written a haskell compiler for the 3DS yet?
12:37:23 <shapr> Serpent: have you written any Haskell code?
12:37:41 <suzu> hiding joins/quits was the best thing i've ever done
12:37:48 <suzu> this channel is so clean now
12:38:04 <sbrg> yeah. waaaay too much noise on large channels on freenode to go without it
12:39:00 <suzu> yeah for sure
12:39:49 <shapr> Serpent: if you're new to Haskell, I like "Learn you a Haskell for Great Good" or "haskel programming from first principles" at http://haskellbook.com/
12:40:25 <senoj> +1
12:40:45 <kadoban> The latter, yep. The former ... bleh.
12:43:31 * hackagebot data-files-gen 0.0.0.1 - Generate data-files Cabal file field from existing files  https://hackage.haskell.org/package/data-files-gen-0.0.0.1 (JeanPhilippeMoresmau)
12:43:33 * hackagebot reload 0.0.0.1 - A web based Haskell IDE  https://hackage.haskell.org/package/reload-0.0.0.1 (JeanPhilippeMoresmau)
12:48:38 <suzu> omg an ide
12:48:41 <suzu> yess
12:48:46 <suzu> web based though
12:48:49 <suzu> ehh
12:49:31 <senoj> so whose computer does ghc run on with that?
12:49:52 <mniip> does ghc compile with ghcjs
12:50:17 <hpc> it's the cloud
12:50:20 <hpc> no computers involved
12:50:20 <mjrosenb> that sounds like a good way to make your browser very very sad.
12:50:58 <senoj> that's the C in GHC, Glasgow Haskell Cloud
12:51:29 <hpc> the G is "GNU" and the H is "HA! this letter is also GNU"
12:51:44 <ongy> hpc: https://fsfe.org/contribute/promopics/thereisnocloud-v2-preview.png
12:53:01 <mjrosenb> "the cloud is when I can't do work because a computer I've never seen is having issues that I can't fix"
12:53:43 <suzu> mniip: what?
12:53:50 <suzu> do you mean, can you compile ghc to js with ghcjs?
12:54:27 <hpc> suzu: ghcjs compiles haskell to javascript
12:54:34 <suzu> yes, i now
12:54:36 <suzu> know *
12:54:54 <hpc> oh, what mniip said was unclear, nvm
12:55:05 <suzu> i was asking mniip if he wanted to compile the compiler to js
12:56:10 <mniip> we were talking about a web-based ide and someone asked what compiles the haskell
12:56:30 <mniip> naturally I asked whether a haskell compiler can be turned into javascript
12:56:51 <mjrosenb> clearly you need to recompile ghc with ghcjs-in-js to get a consistent build.
12:57:01 <suzu> ghc8 error messages are the bomb
12:57:04 <senoj> it would be amazing if you could build ghc with ghcjs
12:57:23 <suzu> js is going to become the new assembly
12:57:49 <mjrosenb> it already is, if you listen to bendan eich.
13:05:41 <glguy> suzu: I got tired of join/part scrolling, so I use this view: http://imgur.com/a/82CRn
13:05:57 <suzu> oh thats nice
13:06:03 <suzu> i just have it completely off
13:06:07 <suzu> which is even nicer imo
13:06:17 <sbrg> i just told my client to ignore joint and parts for everyone except people that were active recently
13:06:24 <suzu> weechat?
13:06:31 <suzu> smart filter?
13:06:34 <sbrg> up until yesterday, yes.
13:06:36 <sbrg> now i'm using circe
13:06:37 <suzu> :D
13:06:39 <sbrg> it does that as well
13:06:43 <sbrg> if you enable it
13:13:31 * hackagebot impure-containers 0.4.0 - Mutable containers in haskell  https://hackage.haskell.org/package/impure-containers-0.4.0 (andrewthad)
13:27:40 <mpickering> Why does the semigroups package have so many dependencies? Should the packages not define their own instances of semigroup?
13:28:37 <Clint> mpickering: once it goes into base that should be easier
13:28:50 <suzu> constants cant start with capital letters
13:28:52 <suzu> ??
13:28:56 <suzu> has this always been like that
13:29:06 <byorgey> suzu: what do you mean by "constants"?
13:29:13 <mpickering> I guess this is more of a general point. Surely it should just be a package which supplies the class definition 
13:29:23 <suzu> MY_VAR = 5
13:29:26 <suzu> in a .hs file
13:29:26 <mpickering> suzu: You can use a pattern synonym if you like, pattern MyConstant = 5
13:29:36 <suzu> pattern synonym?
13:29:46 <byorgey> suzu: Haskell doesn't have constants, just variable names, and variable names must start with a lowercase letter
13:29:54 <suzu> err yes
13:29:57 <suzu> that's what i mean
13:29:58 <mpickering> The problem seems to be that these packages don't want to depend on semigroups because.. it has so many dependencies
13:32:03 <dolio> Several of those packages are GHC boot libraries, so you can't invert the dependency without making semigroups one, too.
13:35:55 <dmwit> Alternately: Haskell doesn't have variables, only constants, and constant names must start with a lowercase letter.
13:36:27 <shachaf> Why can't constant names start with a capital letter?
13:36:43 <suzu> just seems to be The Law
13:36:46 <suzu> thats how the spec is
13:37:14 <dmwit> To make them syntactically distinguishable from constructors. But I suspect shachaf already knew that, so I wonder what he was really asking.
13:37:34 <shachaf> I mean, I'm not sure why you wouldn't call constructors constants.
13:37:34 <dolio> Constructors are constants, though.
13:38:01 <dmwit> Ah, yes, well, in this tongue-in-cheek categorization, constructors are not constants. ;-)
13:38:09 <dmwit> Just a joke. I understand your point well.
13:41:12 <dolio> Even the variables are constants. :)
13:42:45 * osfameron fails to find any documentation about Data.Time on how to construct a time.  (e.g. the equivalent of fromGregorianDate, but for h:m:s instead of y/m/d)
13:43:22 <osfameron> it may be telling that all the tutorials skip this and use getCurrentTime instead
13:45:15 * osfameron raises eyebrows at: UTCTime (fromGregorian 2011 12 16) (fromIntegral $ 12 * 3600)
13:45:57 <glguy> http://hackage.haskell.org/package/time-1.6.0.1/docs/Data-Time-LocalTime.html#v:makeTimeOfDayValid
13:47:50 <glguy> there are other useful functions in that module too
13:48:19 <osfameron> glguy: thanks
13:48:30 <osfameron> I don't understand why the module has no documentation :-(
13:48:56 * dfeuer is very annoyed when he finds important properties missing from the QuickCheck test suite >:-(
13:48:57 <osfameron> is Pico used like a float?
13:51:05 <osfameron> ah, Fixed
13:52:14 <shapr> dfeuer: submit a PR for more QC props?
13:52:38 <shapr> dfeuer: are you still fixing Data.Map ?
13:52:54 <glguy> this shapr account seems like it might be a bot
13:53:10 <glguy> PR bot
13:53:37 <dfeuer> shapr, yeah, still working on that. I'm adding QC properties as I notice I need them. I figured I should check whether the unionWith properties checked for left bias in the appropriate fashion; they did not.
13:55:16 <shapr> glguy: On this channel, I've been accused of being a bot many many times.
13:55:24 <glguy> That's what a bot would say
13:55:30 * shapr fails his Turing Test
13:58:55 <shachaf> @bot-shapr
13:58:55 <lambdabot> shapr!!
14:00:14 <geekosaur> shapr's been bottled?
14:02:55 <johnw> I hope to one day be shapr complete
14:03:26 <shapr> :-P
14:05:55 <Gurkenglas> http://ircbrowse.net/browse/haskell?q=shapr+is+a+bot
14:07:56 <johnw> lol
14:23:31 * hackagebot hmpfr 0.4.1 - Haskell binding to the MPFR library  https://hackage.haskell.org/package/hmpfr-0.4.1 (MichalKonecny)
14:24:39 <danilo2> Hello guys! If I'm using State monad with list of Ints as its state and list access functions (!!) in a chunk of code known at compile time (pretty simple - some recursive typeclasses based on some defined Nat value), can I assume it will be optimized during -O2 compilation? If not, how can I guarantee it? 
14:24:40 <danilo2> I know I can check the assembler to see it, but I dont want to do it every time I define a function
14:32:13 <volhovm> Hi!
14:32:23 <volhovm> Is there any magic trick to make acid-state lazy?
14:32:27 <volhovm> Or something.
14:32:42 <volhovm> My local databaze is 5g already and it can't be loaded in 4gb of memory.
14:32:45 <AzureStigma> is javascript functional?
14:33:18 <danilo2> AzureStigma: is assembler Object Oriented?
14:33:30 <danilo2> AzureStigma: I mean, you can treat it like it was
14:33:43 <danilo2> so if you use it correctly, using some rules, then yes 
14:34:01 <maerwald> paradigms are usually not very well defined anyway
14:34:07 <shachaf> JavaScript is off-topic in here.
14:34:08 <kadoban> AzureStigma: A little ... compared to haskell, not really at all.
14:34:09 <danilo2> but assemblers mentality is not OO, the same way goes JS with funcitonal
14:34:24 <shachaf> And so are arguments about the meaning of the word "functional", for that matter.
14:34:45 <AzureStigma> i apologize
14:35:58 <maerwald> shachaf: how is talking about the meaning of the word "functional" off-topic? It's directly related to haskell. We have been talking about the word "purity" here too to great extent.
14:36:02 <danilo2> Hello guys! If I'm using State monad with list of Ints as its state and list access functions (!!) in a chunk of code known at compile time (pretty simple - some recursive typeclasses based on some defined Nat value), can I assume it will be optimized during -O2 compilation? If not, how can I guarantee it?
14:37:10 <glguy> You can be assured that the optimizer will be applied to your code if you have used -O2. Did you have a particular optimization in mind?
14:39:44 <danilo2> glguy: just imagine that I have a set of types {A1,A2,A3,...} and I want to treat them like constructors in custom case' function like : case' a $ do { of' \(A1 a) -> ... ; ...}. of' adds just a function to a list of functions in a State but it adds it to a certain position (for A5 it is 4th element, A7 - 6th , etc). case' just runs this State and selects (using (!!)) the proper one to apply
14:40:00 <danilo2> glguy: I want be sure that it just gets optimized when using -O2
14:40:42 <glguy> It's going to get the full optimization treatment. !! is likely to survive that treatment if that's what you're asking
14:41:38 <danilo2> glguy: why its going to survive when the compiler would know the list and the int (index) ?
14:41:44 <suzu> you might want to consider not using list if you're gonna !! a lot
14:42:07 <danilo2> suzu: sure, but it is guaranted that the indexes after (!!) will be known at compile time
14:42:16 <Clint> volhovm: no, you need to use something that's not acid-state instead
14:42:23 <danilo2> suzu, glguy: so why GHC could not optimize them?
14:42:33 <suzu> i don't know anything about ghc optimization
14:42:34 <c_wraith> danilo2, that doesn't actually allow any optimizations. 
14:42:44 <suzu> but i do know that list is implemented as a linked-list so !! is slow af
14:42:53 <volhovm> Clint: well that sucks. How then can I profile the amount of memory objects in acid-state take?
14:43:07 <volhovm> I supposed they're much much slower.
14:43:15 <volhovm> How can i measure it?
14:43:21 <suzu> go for a vector type if you can
14:43:29 <danilo2> c_wraith: oh, ok. So what can I do If I want to build a "vector" or a "list" at compsile time and be sure it will be build? I want to build it like described above - just insert some elements into defined positions
14:43:31 <suzu> then you wouldnt need to be relying on ghc optimizing this for you
14:43:41 <glguy> It dosn't matter if the indexes to !! are known at compile time
14:43:49 <suzu> ^
14:43:51 <shachaf> GHC doesn't even optimize "reverse []" to "[]"
14:44:04 <glguy> For example: demo x y z = [x,y,z] !! 2
14:44:09 <glguy> That !! isn't going anywhere
14:44:21 <danilo2> suzu: it doesnt affect my scenario here. I'm asking bout optimizations during compilation time, not about execution speed. Sometimes such pure, simple algebraic datas could be optimized better than magically implmented vectors
14:44:30 <suzu> you are correct
14:44:34 <suzu> somtimes it could be optimized better
14:44:41 <danilo2> glguy: why? :(
14:44:43 <suzu> but lists suck and ghc cant reason about them very well
14:45:11 <suzu> even if ghc knew every single index you want
14:45:16 <glguy> danilo2: !! is a recursive function, it would have to do a lot of exploration to find out that inlining that was a good idea
14:45:17 <danilo2> ok, but why GHC cannot do such simsple things like [x,y,z] !! 2 or reverse [] ? 
14:45:19 <suzu> it will have to traverse from the beginning
14:45:30 <c_wraith> danilo2, think of [] as the type of reified loops, not as a data structure for storing data long term. 
14:45:32 <danilo2> glguy: interesting
14:46:00 <danilo2> c_wraith, glguy : ok, If I use MVector instead in ST Monad - is it possible it will be optimized away?
14:46:08 <suzu> no
14:46:12 <suzu> oh
14:46:14 <suzu> MVector
14:46:19 <danilo2> if not - is there ANY data structure - vector like - taht could be optimized away?
14:46:29 <suzu> a vector will optimize to an O(1) access time
14:46:36 <Zekka> If you're terribly concerned aobut the performance of your code, are you sure you should be using Haskell?
14:46:55 <Zekka> It's possible to write fast Haskell but as far as I can tell you rely heavily on the optimizer restructuring your code to something fast
14:47:00 <c_wraith> I don't even know what you think you are optimizing away. 
14:47:13 <danilo2> suzu: I'm not asking about access time and its not an optimization -its a characteristics. I'm asking about compile tim e optimization while building it when the elements and positions would be known at compile time 
14:47:26 <c_wraith> if the data isn't compile time constant, it will need to be looked up at runtime 
14:47:29 <suzu> what do you mean by compile time optimization
14:47:36 <suzu> what are you trying to optimize, if not the access time of the data?
14:47:48 <danilo2> c_wraith: I know the elements and their positions durign compile time. I want just compiler to optimize it out, because it will be used in a very critical code fragments
14:48:07 <c_wraith> danilo2, why not just name the values? 
14:48:08 <danilo2> suzu: I'm trying to optimize building of the initial list / vector / ... 
14:48:11 <lpaste> tippenein pasted “insertBy persistent” at http://lpaste.net/173686
14:48:26 <danilo2> c_wraith: I'll paste the example from above:
14:48:29 <suzu> you want to optimize inserting data into the structure?
14:48:46 <danilo2> c_wraith: just imagine that I have a set of types {A1,A2,A3,...} and I want to treat them like constructors in custom case' function like : case' a $ do { of' \(A1 a) -> ... ; ...}. of' adds just a function to a list of functions in a State but it adds it to a certain position (for A5 it is 4th element, A7 - 6th , etc). case' just runs this State and selects (using (!!)) the proper one to apply
14:49:03 <danilo2> c_wraith: do you see the use case here?
14:49:34 <suzu> so you have a data type
14:49:43 <suzu> and you wish to append things quickly?
14:50:07 <suzu> and also select the right function back out quickly and apply it?
14:50:15 <danilo2> suzu: no. I want to build an "index arrray" in O(0) because it wuill be known at compile time
14:50:32 <danilo2> suzu: selecting back would be in O(1) using a Vector
14:50:34 <suzu> oh i think i understand
14:50:37 <danilo2> or somethin simmilar
14:51:04 <suzu> so you don't even want to construct this thing
14:51:12 <suzu> you want this data baked into your program
14:51:38 <suzu> by the compiler
14:51:49 <danilo2> suzu, c_wraith : here is an example with nicer formatting: http://lpaste.net/173687
14:51:56 <danilo2> suzu: yes
14:52:07 <suzu> hmmmm
14:52:43 <maerwald> I wonder if that's something you can achieve with TH
14:52:56 <suzu> i don't know how to do this.
14:53:05 <suzu> TH might work
14:53:07 <danilo2> suzu: it is a custom - case / of implementation. And I want to optimize it this way, that if durign compilation I know all the possible cases, I can enumerate them, create an index and when performing in runtime the case function, I can just O(1) select the right method
14:53:31 <maerwald> so instead of using !!, you would use some TH-equivalent that actually turns the thing into the element at the index
14:53:36 <danilo2> suzu: I was asking another question - why no jsut leave it to GHC to optimize these things away?
14:53:49 <suzu> GHC isn't magic
14:53:58 <suzu> it doesn't know what in your list tbh nor does it care
14:54:02 <danilo2> maerwald: so I understand that even If I switch from lists to vectors or mutalbe vectors it will not be optimized ?
14:54:14 <suzu> it won't be baked into the program as you like
14:54:17 <Zekka> if your strategy to get good performance is "let the optimizer deal with it" you probably won't get good performance
14:54:32 <suzu> you can get it to dynamically lookup in the vector and etc etc during runtime
14:54:33 <danilo2> suzu: optimizations like [x,y,z] !! 1   ----> y    is not a magic
14:54:43 <Zekka> especially since haskell programs don't automatically include a lot of the information an optimizer is likely to want to take advantage of
14:54:50 <suzu> and that'd be a strict overhead cost
14:54:55 <fishythefish> danilo2: Sure it is. (!!) isn't baked into the language, it's just a function
14:54:56 <osager> how to turn [[a]] -> [a]
14:55:01 <fishythefish> :t concat
14:55:02 <lambdabot> Foldable t => t [a] -> [a]
14:55:08 <suzu> which, even the compiler were almighty and all-knowing, would still need to do a lookup during runtime to pattern match your data
14:55:11 <lyxia> :t join
14:55:13 <Zekka> FWIW Haskell absolutely has lots of hardcoded rewriting rules for cases like this
14:55:13 <lambdabot> Monad m => m (m a) -> m a
14:55:19 <suzu> so you likely could not get it any faster
14:55:22 <danilo2> Zekka: this is not my strategy. My strategy is to use Haskell in a convinient way and know that it will be optimized and not use Haskell like C, because then I'd prefer to use just C
14:55:43 <fishythefish> danilo2: But you can't expect it to be optimized like C.
14:55:54 <Zekka> for instance, it has a hardcoded rule to turn map f . map g into map (f . g)
14:56:09 <suzu> functor laws ftw
14:56:20 <Zekka> danilo2: Your best option is going to be to profile heavily and try to figure out what magic buttons you can press to make the optimizer generate fast code
14:56:56 <Zekka> but the nature of HAskell is that it doesn't include information like "it would be beneficial to copy this so you can change values in place later," while that information is going to appear in your C code automatically
14:57:07 <danilo2> Ok, thank you guys :) I know I cannot just leave it to GHC. Ill profile it :)
14:57:25 <Zekka> In this case a Haskell implementation could conceivably do well, but I'm pretty sure that your results in general with Haskell are going to be "hopefully the compiler does the right thing, I have no way to be sure of that"
15:02:15 <connoted> Hey guys, can someone tell me why the following 3 term fibonacci doesn't work? Prelude> seqq = 1 : 2 : 3 : [a + b + c | a <- seqq, b <- tail seqq, c <- tail (tail seqq) ] Prelude> take 10 seqq [1,2,3,6,9,12,15,18,21,24]
15:02:26 <Cale> Well, you do have a way to be sure -- you can look at the core which is generated, which is a lot closer to describing the operational behaviour of the code -- or of course, you can go a step further and look at the cmm code from there.
15:03:21 <Cale> connoted: Well, first of all, the ghci prompt doesn't want declarations
15:03:58 <Cale> It's looking for expressions. You can prefix the declaration of seqq with 'let' though if you want
15:04:27 <Cale> secondly, that second line looks like a type error, unless the [1,2,3,6...] was meant to be the result...
15:05:13 <Cale> third, that list comprehension probably doesn't mean what you want it to mean
15:05:28 <connoted> hmm, for some reason my ghci doesn't seem to need let...
15:05:58 <Cale> oh, hm, maybe that got recently changed
15:06:31 <connoted> and [1, 2, ...] was the result I obtained from 'take 10 seqq'
15:06:38 <kadoban> Did they change that in 8? That'd actually be kind of neat ... ghci is already magic anyway, right?
15:06:40 <geekosaur> I know they were talking about changing it but I don't know if it made ghc8.0.1
15:06:57 <Cale> It seems to have made it into 8.0.1
15:07:21 <kadoban> Nice, I'm surprisingly happy about that I think. That confused the crap out of my in ghci when I was new.
15:07:50 <Cale> connoted: So yeah, that looks correct. Note that a will always be 1 and b will always be 2 because the list is infinite, so it never makes it through all the possible values for c
15:09:04 <connoted> @Cale hmm it seems to work for normal fibonacci when you zip them
15:09:04 <lambdabot> Unknown command, try @list
15:09:12 <Cale> You probably wanted something like (a,(b,c)) <- zip seqq (zip (tail seqq) (tail (tail seqq)))
15:09:20 <dfeuer> I am looking forward to playing with the new Typeable. Is it still on track for 8.2?
15:09:21 <Cale> You didn't zip them
15:09:33 <connoted> oh, does zip mean you will reuse the stored ones because of laziness?
15:09:33 <int-e> > let seqq = 1 : 2 : 3 : [a + b + c | a : b : c : _ <- tails seqq] in seqq
15:09:35 <lambdabot>  [1,2,3,6,11,20,37,68,125,230,423,778,1431,2632,4841,8904,16377,30122,55403,1...
15:09:47 <Gurkenglas> Can we change do notation to also not need let?
15:09:53 <Cale> > [(x,y) | x <- [1,2,3], y <- [4,5,6]]
15:09:55 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
15:10:08 <Cale> Gurkenglas: my head...
15:10:44 <int-e> > let seqq = 1 : 2 : 3 : [a + b + c | a <- seqq | b <- tail seqq | c <- tail (tail seqq)] in seqq -- is this enabled?
15:10:44 <Gurkenglas> It already has no in, and the syntax would fit as an alternative to <-, and less indentation
15:10:45 <lambdabot>  [1,2,3,6,11,20,37,68,125,230,423,778,1431,2632,4841,8904,16377,30122,55403,1...
15:10:57 <Cale> Gurkenglas: Does it automatically collect up all the adjacent declarations into a single let block?
15:11:01 <suzu> if module a gives me a type thats in module b, and i want to work with that type, is it proper to be including module b too?
15:11:06 <Gurkenglas> Does that make a difference?
15:11:09 <int-e> (parallel list comprehension is a ghc extension)
15:11:24 <Cale> Gurkenglas: yes... it can mean the difference between mutual recursion and not...
15:11:27 <amf> with the RWST monad, how do i weave the stat from runRWST back into itself? aka i want to use do `forever $ do (a, s, w) <- runRWST ... ; runRWST s` while still getting access to a and w
15:11:59 <suzu> concretely, i'm working with an Object in aeson. Objects are strict hashmaps, and i want to do a lookup, but to get lookup i need to import Data.HashMap.Strict + add unordered-containers to .cabal. is this right?
15:12:00 <Gurkenglas> Ooh what effects does that have? Is that something basic enough I should google it instead?
15:12:11 <connoted> hmm thanks all, I'll try to absorb this haha.
15:12:50 <amf> i think i want the x in x calling, but impossible to google
15:13:02 <Cale> connoted: I'm sure if you study the behaviour of [(x,y) | x <- [1,2,3], y <- [4,5,6]], you'll see what's going on :)
15:13:04 <int-e> :t zip3
15:13:06 <lambdabot> [a] -> [b] -> [c] -> [(a, b, c)]
15:13:32 <Cale> amf: Are you sure you want to be using runRWST there at all?
15:13:53 <Gurkenglas> Oh, you just mean that if you have the let blocks one after the other, the definitions in the latter are out of scope of the former?
15:14:12 <Cale> Gurkenglas: yeah
15:14:12 <amf> Cale: i know i want one of those functions that lets me access to the final state so i can reuse it in the next iteration
15:14:45 <amf> execRWST works as well (need the MonadWriter value too)
15:15:01 <Cale> Which monad are you transforming?
15:15:36 <Gurkenglas> Well I guess it would be most permissive to desugar it into as large let blocks as possible, is your concern that then you need linear brain swapspace to read a long let block that could have been split into multiples?
15:17:10 <amf> Cale: its a threaded queue handler that forks from IO, i guess there is no transformer portion... might be able to use runRWS as a function to get the first state value
15:17:41 <mniip> 1470175862 [01:11:02] <int-e> (parallel list comprehension is a ghc extension)
15:17:48 <mniip> you mean the one with zipWith id?
15:18:24 <Gurkenglas> Just use MonadComprehensions with ZipList
15:18:37 <Gurkenglas> and ApplicativeDo
15:18:41 <mniip> but ZipList isn't...
15:19:31 <Cale> amf: I guess you could use MonadFix, but whether it makes sense to do that depends on what it is that you're doing.
15:20:19 <amf> oh right... that might be a solution, thanks ill look at that
15:21:02 <mabs> hi all
15:21:12 <mniip> hello
15:21:15 <Cale> amf: You really want the final state of running the thing to be the input state?
15:21:32 <Cale> amf: Or you mean you want the final state from one iteration to be the input state of the next?
15:21:47 <Cale> amf: Maybe just write a recursive function in that case?
15:22:02 <amf> i believe i want your seconds question
15:22:32 <mabs> Is anyone aware of any paper or report addressing tupling issues?
15:23:00 <Cale> mabs: What does that mean?
15:23:47 <Cale> amf: foo s = do (... s') <- runRWST blah ... s...; foo s'
15:24:16 <mabs> Cale: (filter p xs, filter (not . p) xs) is faster than partition p xs
15:24:35 <mabs> because tupling is more expensive than traversing the list twice
15:24:38 <Gurkenglas> amf, https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:iterateM_
15:25:31 <hydraz> GHCi 8 doesn't need `let`s? Well, that's news.
15:25:54 <Cale> mabs: I'm not sure I understand -- the former is a valid implementation of the latter.
15:26:25 <Cale> So if it's better, we can just implement partition that way.
15:26:39 <newhoggy> Does anyone know if GeneralizedNewTypeDeriving inlines?
15:26:44 <Cale> However, I'm a little bit suspicious of this.
15:26:55 <mabs> Cale: partition is not implemented this way
15:27:03 <hydraz> mabs: Your statements are kinda contraditory. You say that using a tuple is faster, but also that it's more expensive
15:27:10 <mniip> hydraz, the semantics are differrnt though
15:27:32 <mabs> hydraz: I never said using a tuple is faster
15:27:46 <mniip> x=y creates a temporary module that is added into the environment
15:27:56 <mabs> I just said that the consensus seems to be that one traversal is better than two
15:27:58 <mniip> let x=y is ancient voodoo
15:28:17 <hydraz> mabs: "(filter p xs, filter (not . p) xs) is faster than partition p xs"
15:28:21 <Gurkenglas> I believe mabs is refering to this
15:28:23 <Gurkenglas> http://stackoverflow.com/questions/38671397/benchmarking-filter-and-partition
15:28:23 <mniip> that compiles a string that unsafecoerces rhs variables to HValues and whatever
15:28:26 <amf> Cale: bingo, duh. so easy. thanks :)
15:28:31 * hackagebot free-vector-spaces 0.1.0.0 - Instantiate the classes from the vector-space package with types from linear  https://hackage.haskell.org/package/free-vector-spaces-0.1.0.0 (leftaroundabout)
15:28:34 <hydraz> mniip: ah, I see
15:28:34 <Cale> amf: no problem
15:28:46 <mabs> Gurkenglas: yes
15:29:08 <Cale> mniip: wha?
15:29:21 <dfeuer> mabs, sometimes.
15:29:35 <mniip> Cale, try -ddump-parsed
15:29:48 <dfeuer> It depends on the predicate, the list length, the consumption pattern.....
15:29:53 <mniip> I've had a glance at the actual code behind it too and it's not pretty
15:30:07 <mabs> dfeuer: absolutely; we are doing a lot of experiments on this.
15:30:22 <lpsmith> Hmm, isn't there a way to supply a default method implementation that has a type constraint that doesn't exist on the method type?
15:30:27 <mabs> in the case of vectors this issue does not seem to occur
15:30:41 <lpsmith> I.e. that constraint would have to be otherwise be satisfied in order to use the default method
15:30:54 <lpsmith> if not,  then you would have to supply the method yourself.
15:31:12 <mabs> dfeuer: it's still a bit surprising because this issue seems to date back to the papers on optimisations via tupling 
15:31:18 <mabs> and it has not been solved yet
15:31:55 <lpsmith> ahh found it
15:32:12 <newhoggy> new
15:32:17 <mabs> do you know of any "detailed" report that elaborates on the cost of tupling?
15:32:48 <Cale> mabs: Well, the space performance is just obviously different. I don't think it's reasonable for the compiler to work out what would be better most of the time.
15:33:05 <Cale> This really isn't specific to tuples at all
15:33:19 <mniip> have you tried unboxing the tuples
15:33:23 <dfeuer> mabs, no, I don't. As Lennart Augustsson mentioned, there are ways around it (given sufficient primitives) but I'm not convinced they'll remain valid and fast in a parallel or concurrent context.
15:33:24 <Cale> If you're talking about the stackoverflow thing
15:33:30 <mabs> mniip: doesn't work
15:33:37 <mniip> oh?
15:33:49 <dfeuer> mniip, utterly prohibited and wrong.
15:34:10 <mniip> ?
15:34:46 <Cale> This doesn't have anything to do with the cost of forming pairs
15:34:50 <mabs> Cale: isn't specific to tuples at all?
15:34:57 <mabs> so it has to do with what?
15:34:57 <dfeuer> mniip, well, you can't even write it, I don't think. GHC will buzz at you. The trouble is that you need to tie thunks to each other.
15:35:01 <dfeuer> Er... sort of.
15:35:19 <Cale> It's all about the cost of retaining the list being computed
15:35:20 <mniip> can't write it?
15:35:26 <Profpatsch> hm, can I export the fields of a type but not the constructor itself?
15:35:27 <Cale> Er, the list being acted upon
15:35:56 <mabs> i could buy that, but still the runtime performance shouldn't vary so much
15:36:01 <mabs> even if you keep all the lists
15:36:08 <Cale> You have to balance the cost of managing memory vs. the cost of recomputing the predicate
15:36:48 <Cale> We can make the compiler pretty smart, but I'd be quite surprised if the compiler is ever going to be smart enough to make a decision like that the right way every time.
15:37:05 <mabs> sure but it's seems to be wrong every time
15:37:11 <dfeuer> Quick question: how dangerous is   foo :: a -> b -> Int#; foo = unsafeCoerce reallyUnsafePtrEquality#  ?
15:37:12 <Cale> It's not wrong every time
15:37:19 <Cale> Make the predicate much more expensive to compute
15:37:24 <mabs> sure it is, for the predicates that people use
15:37:30 <dfeuer> ....
15:37:33 <Cale> ...
15:37:37 <glguy> ....
15:37:53 <mabs> ... ? what? we collected all of them
15:38:02 <Cale> "all"?
15:38:05 <mabs> in the entire hackage yes
15:38:06 <Cale> Huh?
15:38:07 <dfeuer> mabs, it also depends on the list length, the consumption pattern, the sizes of the list elements, etc....
15:38:09 <mabs> it's most of the time wrong
15:38:23 <mabs> it's better to traverse twice
15:38:28 <mniip> dfeuer, sometimes it will return false for equal objects
15:38:35 <mniip> sometimes it will return true for different objects
15:38:36 <dfeuer> mabs, when libraries use the wrong function, they should be fixed.
15:38:47 <mabs> point aside
15:38:52 <dfeuer> mniip, how will it return true for different objects?
15:39:19 <mniip> if a garbage collection happens midway
15:39:28 <Cale> It's obviously less necessary to have a library definition for the version of partition which is implemented by doing filter twice though.
15:39:41 <dfeuer> mniip, I'm pretty sure that's guaranteed not to happen.
15:39:43 <Cale> If that's better, the code which uses partition can just use filter twice :P
15:40:03 <mniip> eh
15:40:17 <Cale> But if the single traversal partition is better, it's awkward to have to write it in place.
15:40:43 <mabs> Cale: if this is related to retaining why doesn't this phenomenon occur with Vector?
15:41:02 <Cale> Vector can't be partially garbage collected
15:41:15 <dfeuer> mniip, it's a primop roughly equivalent to   rUPE x y = unsafeCoerce# x ==# unsafeCoerce# y, I believe.
15:41:34 <dfeuer> There's no "in between" time.
15:41:37 <Cale> Any given Vector is either entirely resident, or entirely garbage
15:42:35 <mabs> Cale: so you believe this is solely because of GC or there might be a cost because of the tuples?
15:42:45 <mniip> 1470177291 [01:34:51] <dfeuer> mniip, well, you can't even write it, I don't think. GHC will buzz at you. The trouble is that you need to tie thunks to each other.
15:42:49 <mniip> so I just wrote it
15:42:55 <mniip> what was the supposed problem
15:43:23 <Cale> mabs: Consider this one:
15:43:52 <Cale> subsequences [] = [[]]; subsequences (x:xs) = subsequences xs ++ map (x:) (subsequences xs)
15:43:58 <glguy> mniip: Does it work on infinite lists? (I think that might be the concern)
15:44:23 <Cale> mabs: You might think it's wasteful that we're computing subsequences xs twice on the right hand side in the recursive case
15:44:44 <Cale> However, if we change it to share the work:
15:44:54 <mniip> ah well
15:45:05 <Cale> subsequences [] = [[]]; subsequences (x:xs) = ys ++ map (x:) ys where ys = subsequences xs
15:45:23 <Cale> Now it'll eat all your memory, and take way longer because of that.
15:46:17 <dfeuer> mniip, sorry, yeah, I got the wrong problem :P
15:47:23 <Cale> This is because in the span of time from the beginning of the list up to reaching the middle of the 2^n elements, no part of the list ys is garbage, and so more and more memory needs to be allocated to store it all
15:48:12 <Cale> Whereas in the first version, yes, we recompute subsequences xs twice, but the elements of that list become garbage as they're consumed by whatever uses the result
15:49:43 <Cale> and so the space usage is much lower, there's much less memory pressure, it won't have to allocate large blocks of memory to hold the result, assuming that you're consuming it nicely
15:50:07 <mabs> Cale: not clear to me that the same is happening in the case of partition vs 2 filters
15:50:26 <Cale> @src partition
15:50:26 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
15:50:26 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
15:50:26 <lambdabot>                               | otherwise = (ts, x:fs)
15:50:51 <Cale> I don't know whether or not that's the GHC implementation, one sec while I have a look.
15:51:21 <Cale> yeah, looks like it
15:52:17 <Cale> So, anyway, assuming that you're going to use up the whole left portion of the result before you begin to look at the right portion...
15:53:11 <Cale> what's going to happen here is that the whole input list xs won't begin to become garbage until you begin to consume the right portion of the result as well
15:54:00 <Profpatsch> Design problem:
15:54:17 <Cale> Well... perhaps if the first few elements of the list are in the left portion of the result, those can be collected
15:54:32 <Profpatsch> I want to create a Table type which can be created from any type by the user.
15:55:02 <Cale> But anyway -- it's got to hang on to at least the suffix of the input which has the first element of the second part, until you begin to consume that
15:55:43 <Profpatsch> The table should be a list of as, together with a description for the header for each field of a.
15:55:54 <Gurkenglas> Sounds like the optimal place for partition is somewhere between those extremes
15:56:36 <mabs> Cale: hang on? what do you mean by that precisely? foldr is lazy. also i don't see why that wouldn't happen in the case of tupling 2 filters
15:56:37 <Profpatsch> So that if I have a Table, I can render it, with headers and rows.
15:56:38 <Gurkenglas> Perhaps every 100 elements of xs, there should be a beacon that tells ghc to force both lists until they'd evaluate xs past that beacon
15:57:51 <Profpatsch> My idea is to export the constructor, and provide a function table :: ? -> Table where the user can create a table.
15:58:01 <Profpatsch> *not export the constructor
15:58:21 <Cale> mabs: Oh, sorry, I should be clear: it's not really the input which is being retained, but the result of the foldr on the tail of the list.
15:58:54 <Profpatsch> But I have no idea what the function’s type should be to ensure every rendered field of the user type has a header description.
16:00:09 <mabs> what is the precise semantics of the ~ in ~(ts,fs)?
16:01:12 <Cale> It defers the pattern match until either ts or fs gets used. The computation of the argument is still done exactly once and shared between the occurrences of ts and fs
16:01:59 <Cale> It's basically like pattern matching against us, and then having let ts = fst us; fs = snd us in ...
16:02:37 <mabs> got it, thanks.
16:02:41 <Denommus> hi
16:02:46 <Cale> and so it's this us which is retained
16:02:53 <Cale> You might consume all of ts
16:03:09 <Cale> but the fs will be sitting there retaining us
16:03:33 <Cale> and thereby retaining the whole result of doing the foldr over the tail of the list
16:04:14 <Cale> (as it gets computed while you walk down ts)
16:04:34 <mabs> what if i force the head of fs in select? would that help?
16:05:19 <Cale> fs will actually be pretty much evaluated by the time it becomes a problem
16:05:46 <Cale> It's not something you can solve by being stricter, you need to be lazier, in a way.
16:06:19 <Cale> Well, that's ambiguous
16:07:26 <Cale> What I mean is, the solution to not keeping the whole result in memory is to instead refer to an unevaluated expression which won't get evaluated while you traverse the first half of the result
16:07:39 <Cale> That's what you've done by implementing partition as two filters
16:08:16 <Cale> What might be even better in many cases will even be to carry this back yet another step
16:08:27 <Cale> and repeat the evaluation of the input to partition as a whole
16:08:51 <Cale> However, it's obviously a tradeoff, and sometimes you can't just do that
16:09:18 <Cale> If the input to partition was user input, you obviously have no choice but to retain it, you can't recompute it from scratch :P
16:09:50 <Cale> But if it was some relatively cheap thing like [1..10000000]
16:10:27 <Cale> then probably writing (filter p [1..10000000], filter (not . p) [1..10000000]) is going to be better still
16:10:53 <Cale> because then you don't retain this derpy list of numbers in memory
16:11:32 <Cale> If on the other hand, the computation of the input to partition is something repeatable, but relatively expensive, it's a tough call
16:12:23 <Cale> Also, if the evaluation of the predicate is expensive
16:12:42 <Cale> then the library partition will clearly be better, because it evaluates the predicate once per list element
16:12:58 <mabs> the question there is how expensive does it have to be?
16:13:22 <Cale> That probably boils down to some hardware question eventually
16:13:43 <hexagoxel> is there a `transpose` that behaves more like a "zipN", i.e. ignores restelements once at least one of the input lists is null?
16:13:56 <Cale> Like, the relative performance of memory accesses vs. what the CPU can compute
16:14:30 <shachaf> > transposeOf traverse ["abc","de","fghi","jk"]
16:14:31 <lambdabot>  ["adfj","begk"]
16:14:49 <Cale> hah
16:15:26 <shachaf> transposeOf traverse = getZipList . traverse ZipList
16:15:42 <Cale> Oh, "rest elements"
16:16:18 <hexagoxel> shachaf: thanks!
16:16:47 <Cale> I was parsing it as re-stele-ments and trying to figure out if it was some rare word or an attempt at a cognate from a foreign language :D
16:18:02 <mabs> Cale: your initial assumption was that the left portion is evaluated before the right portion, but it can certainly be the case that you consume an element of each after partition
16:18:15 <mabs> even in that case, the entire "us" would still be retained?
16:18:26 <mabs> this is somewhat puzzling to me
16:28:32 <Cale> mabs: In that case, things would behave better, I think.
16:28:42 <Cale> mabs: try it :)
16:32:10 <Shou> So the Monoid/Semigroup instance for Maybe is `Monoid a => Monoid (Maybe a)` but I'm doing a combinatory logic library which depends on Maybe being a different, other valid instance internally as a dependency for another typeclass because it's basically perfect for the cause (mempty, associative binary operator). How do I go about that, idiomatically?
16:32:57 <Clint> newtype wrapper?
16:32:59 <fishythefish> Shou: newtype wrapper? I might be misunderstanding
16:37:09 <Cale> Shou: Yeah, it's kind of unfortunate that it's not the Semigroup a => Monoid (Maybe a) one
16:38:24 <Cale> But yeah, if it's yet another thing that you mean, then either a newtype or just a completely separate data type would be the way to go.
16:39:38 <Shou> I couldn't just override it locally without affecting the ecosystem?
16:39:40 <mabs> Cale: no luck :(
16:39:59 <Cale> mabs: hmm
16:41:38 <glguy> Shou: No, A type may not be declared as an instance of a particular class more than once in a program
16:42:37 <ludat> isn't there an extension to do that?
16:43:05 <Cale> nope, it's just counter to what type classes are for
16:43:16 <ludat> oh without affecting anything else nope
16:53:31 * hackagebot execs 0.1.0.0 - Tool to run stack exec prj-exe more easy  https://hackage.haskell.org/package/execs-0.1.0.0 (wapxmas)
17:12:42 <Gurkenglas_> https://hackage.haskell.org/package/Chart-1.1/docs/Control-Lens-Reified.html#t:ReifiedTraversal why can't you store traversals in a container otherwise?
17:13:23 <Gurkenglas_> (and why doesnt that newtype run into that same problem)
17:15:46 <shachaf> Because it would be impredicative.
17:21:51 <Gurkenglas_> *reads https://wiki.haskell.org/Impredicative_types * can someone give an inhabitant of the union, but not the intersection, of forall a. Int -> a -> [a] and (forall a. [a] -> Int) -> Int?
17:22:35 <shachaf> What? Those types are completely different.
17:23:41 <Gurkenglas_> Wait I mean "forall a. ([a] -> Int) -> Int" for the first one, ctrl-c
17:23:46 <Gurkenglas_> 'd the wrong thing
17:24:47 <edwardk> The optimal solution to my problem would want an hscpp2hs
17:25:28 <c_wraith> sounds like something you could write. 
17:26:18 <c_wraith> though it'd be way more painful than a straight port. 
17:26:23 <edwardk> i have a header that i need something out of that is c in all capacities except they put the thing in a damn namespace
17:27:49 <Koterpillar> edwardk: lots of #define?
17:28:01 <edwardk> its an enum underneath a namespace
17:28:15 <edwardk> but morally, yes
17:28:39 <Koterpillar> I mean, #define namespace to something else
17:28:57 <Koterpillar> and include it like that
17:29:15 <edwardk> hrmm
17:29:19 <edwardk> #define namespace
17:29:20 <edwardk> #define vr
17:29:22 <edwardk> might work
17:29:35 <Koterpillar> you'll still have { }
17:31:12 <edwardk> i've got an idea
17:31:19 <edwardk> (peculiar to this situation)
17:31:53 <Koterpillar> #define namespace // ?
17:33:45 <edwardk> heh would almost work for this
17:34:12 <edwardk> nah, messier. i can hack on the header in question as its generated by python from a real header to get it into a form i can call from mingw
17:36:03 <edwardk> ugh, that is going to be way more invasive than i want
17:36:44 <edwardk> i can write a custom setup step that builds and runs a c++ program that spits out the haskell i want i guess
17:36:54 <edwardk> which is effectively writing a one-off hscpp2hs ;)
17:38:08 <edwardk> putting this down for the day
17:40:22 <Gurkenglas_> Ah I see ($ [2,3]) is in (forall a. [a] -> Int) -> Int but not forall a. ([a] -> Int) -> Int, because the implementation of the left one can specialize its argument arbitrarilly, and then type inference is hard because anything might take more general arguments but is just specialized right now.
17:42:51 <Gurkenglas_> And then it gets completely intractable once ImpredicativeTypes allows the foralls to be in positions that are neither covariant nor contravariant?
17:44:28 <Gurkenglas_> In that case perhaps you could have ImpredicativeTypes- where you can only put the foralls in covariant positions and that'd still allow Traversals in records right?
17:49:16 <dioxylin> Howdy.  I couldn't find anything on the ticket tracker.  Is there a known issue where `ghci -XRebindableSyntax` will crash in 8.0.1 because (>>) and return are not in scope?
18:03:32 * hackagebot ip 0.8.6 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-0.8.6 (andrewthad)
18:14:40 <fragamus> i need a fold that can abort and return Nothing if a certain condition occurs - anyone know??
18:16:19 <Koterpillar> fragamus: foldM?
18:16:28 <fragamus> yeah
18:16:37 <fragamus> i just found that
19:24:22 <mrtrump> :)
19:24:26 <mrtrump> hows happstack?
19:24:40 <Koterpillar> nice
19:26:42 --- mode: ChanServ set +o glguy
19:26:43 --- mode: glguy set +b $a:glguy
19:27:03 <mrtrump> its seems the answer to my preayers
19:27:10 <mrtrump> and Im polytheistic
19:27:18 <mrtrump> why have the favor of just 1 god?
19:27:35 <mrtrump> peopel still use mac?
19:27:37 <mrtrump> how boring
19:27:41 <mrtrump> freebsd desktop here
19:27:42 <mrtrump> icewm
19:27:46 <mrtrump> fierfox n adblock
19:27:48 <glguy> The topic of #haskell is Haskell, please stick to the topic
19:27:50 <mrtrump> free software yum
19:27:57 <mrtrump> happstack is topic yes
19:28:03 <mrtrump> www.happstack.com
19:29:07 --- mode: glguy set -p
19:30:22 --- mode: glguy set +p
19:30:58 --- mode: glguy set -bo $a:glguy glguy
19:31:48 * Clint stares at glguy
19:33:31 <glguy> Nothing to see here; talk amongst yourself!
19:37:27 <lpaste> lambdafan pasted “possible properties of boxAxisDistance” at http://lpaste.net/173721
19:37:41 <lambdafan> there you go, some haskell
19:37:55 <lambdafan> looking to explore properties of this function, if any
19:39:07 <Koterpillar> distance is non-negative
19:39:21 <lambdafan> ah that is good one
19:39:47 <Koterpillar> distance(a, b) + distance(b, c) <= distance(a, c)
19:40:19 <Koterpillar> http://www.citr.auckland.ac.nz/~rklette/Books/MK2004/pdf-LectureNotes/07slides.pdf
19:40:24 <lambdafan> Koterpillar: thanks :)
19:40:47 <Koterpillar> if you can transform/translate your shapes, add that
19:41:15 <glguy> Koterpillar: Is that inequality reversed?
19:41:35 <Koterpillar> yes, sorry
19:42:02 <lambdafan> ah supposed to be >=
19:42:06 <lambdafan> good catch
19:43:32 * hackagebot isobmff-builder 0.10.5.0 - A (bytestring-) builder for the ISO-14496-12 base media file format  https://hackage.haskell.org/package/isobmff-builder-0.10.5.0 (SvenHeyll)
19:44:47 <lambdafan> Koterpillar: dude that pdf you gave me is great!
20:07:34 <pyon> I have “foo :: Foo (a -> b -> c)”, “bar :: Bar a” and “qux :: Qux b”, where “Foo”, “Bar” and “Qux” are Applicatives. I want to get a “Foo (Bar (Qux c)))” in the obvious way. Is there some way to do that, without manually injecting all of them into “Compose Foo (Compose Bar Qux)” and then unwrapping that?
20:08:37 <pyon> Given how nicely Applicatives compose in theory, it'd be a shame if in practice it required so much boilerplate. :-|
20:36:12 <lolcode> can someone explain what the Data.Ix library is used for?
20:37:13 <geekosaur> "The Ix class is used to map a contiguous subrange of values in type onto integers. It is used primarily for array indexing (see the array package). Ix uses row-major order." https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/base-4.9.0.0/Data-Ix.html
20:37:28 <alercah> lolcode: read (a, a) in all the functions as (low, high)
20:37:34 <alercah> representing a range
20:38:06 <geekosaur> basically, the types using the Data.Array interface aren't indexed directly but go via Ix, letting you use arrays indexed from something other than 0... which don't even have to be numbers
20:38:32 * hackagebot tagsoup-megaparsec 0.2.0.0 - A Tag token parser and Tag specific parsing combinators  https://hackage.haskell.org/package/tagsoup-megaparsec-0.2.0.0 (kseo)
20:38:52 <geekosaur> as long as you can construct an Ix instance that can be used to generate internal index values
20:39:42 <lolcode> Ah, okay. It's similar to enum in C then?
20:40:16 <geekosaur> not really, since C's enum doesn't let you map array indices onto, say, (-5. 5)
20:41:17 <geekosaur> ordinary data declarations are closer to C's enum (data Foo = Bar | Baz | Quux, with either a derived Enum instance that counts from 0 or a manual one to map constructors to values)
20:42:29 <lolcode> cool; thanks geekosaur :)
20:48:18 <codedmart> Any erlang folks in here know if there is a Haskell equivalent of this https://github.com/basho/riak_core/blob/e86aaa62c80a3774ff7c3f74e71e54fa50c93663/src/riak_core_util.erl#L215
21:02:43 <nitrix> pyon: What about using ((->) r) as an Applicative? (<*>) f g x = f x (g x)
21:02:50 --- mode: ChanServ set +o mauke
21:02:50 --- mode: mauke set +b $a:MrrTrump
21:03:25 <nitrix> pyon: Small issue with the outcome of f x (g x) instead of f (g x) though. Are you sure you're not looking for Functor instead?
21:03:44 <nitrix> pyon: ((->) r) functor's instance would be composition.
21:04:12 <pyon> nitrix: I'm pretty sure what I have only works for applicatives.
21:04:50 --- mode: mauke set -o mauke
21:05:28 <glguy> pyon: Your particular question could be solved with fmap, but maybe you planned to combine more stuff together
21:08:00 <nitrix> pyon: On top of my head, (<*>) :: Applicative f => f (a -> b) -> f a -> f b, if you specialize f, f ~ Foo, then you can't really use `Bar a` or `Qux b` after.
21:08:05 <pyon> nitrix: glguy: In general, what I actually have is a gigantic expression “e” that isn't quite well-typed. All the ill-typed subterms are expected to have type “a”, but have type “Foo a” for some applicative “Foo”. (Possibly different “Foo”s for different subterms.)
21:08:07 <nitrix> Unless I'm confused.
21:08:50 <pyon> To make the expression well-typed, I have to manually inject everything into a gigantic combined Applicative context. :-|
21:09:06 <nitrix> Correct.
21:09:19 <nitrix> Why use applicatives then :P ?
21:10:27 <nitrix> Yet I think it's still possible, one sec.
21:12:30 <joehh> I'm looking to run servant within distributed-process, but am unsure of how to communicate between things in the
21:12:44 <joehh> Process () monad and things in the IO monad (ie within servant)
21:12:54 <joehh> does anyone have any tips?
21:14:10 <pyon> nitrix: glguy: Mathematically, Applicatives are the right abstraction. The only problem is to express it using more pleasant syntax. For instance, let's say “foo (this bar) (that qux)” is ill typed because of “bar” and “qux”. I'd have to do something like “pure pure foo <*> fmap this (pure bar) <*> pure (fmap this qux)”. Actually, this example isn't too unpleasant, but for bigger expressions, it can quickly become unwieldy. :-|
21:15:25 <pyon> What I want is something like super-powered idiom brackets that will inject everything into whatever Applicatives it can find in the expression.
21:15:55 <dmwit_> pyon: You may like the paper "Lightweight Monadic Programming in ML".
21:15:57 <pyon> Rather than just into one Applicative.
21:16:02 <dmwit_> pyon: It describes how to implement what you ask for.
21:16:06 <pyon> dmwit_: Will check out. Thanks!
21:16:24 <dmwit_> pyon: Unfortunately it is not easy to port to Haskell, because it makes some assumptions about the type language that are true in ML but not Haskell.
21:16:31 <pyon> Mmm.
21:17:46 <nitrix> pyon: With total lack of knowledge on the subject, can't you steal a little bit of the mechanism used by monad transformers classes that automatically do the proper lifting?
21:17:48 <dmwit> In any case, it shows how to infer all the necessary `lift`s, `>>=`s, and `return`s for monadic expressions.
21:17:50 <dfeuer> dmwit, is it as surprising to you as to me that Data.Map.Strict.insertWithKey is not always strict in the given value?
21:18:28 <dmwit> dfeuer: I guess my priors are too flat to be surprised by much. I haven't played with strict Maps much.
21:18:33 <dfeuer> I mean, I guess it makes *sense*....
21:18:39 <glguy> I would expect it to be strict in the result of the final value stored in the map
21:18:43 <dfeuer> But it can't be great for strictness analysis.
21:19:00 <pyon> nitrix: I might not even have Monad instances to begin with. :-|
21:19:02 <dfeuer> glguy, yeah, that's what it is. There's sense there, like I said....
21:19:39 <glguy> it's easy to make an insert function strict in the value before inserting it
21:19:49 <glguy> it's the result I want help with :(
21:19:51 <glguy> :)*
21:20:08 <dmwit> glguy: oh dear
21:20:08 <nitrix> pyon: Remember that monads simply have a `join` operation extra ;) It should be, at least theorically, possible to transpose the concept to applicatives.
21:20:12 <dmwit> glguy: you have a spider on your chin!
21:20:23 <glguy> In my font that can't be a spider!
21:20:29 <glguy> 6 legs
21:20:37 <glguy> or it's an injured spider I guess
21:20:43 <dmwit> glguy: You mean you cut off two of its legs! That's like, animal cruelty
21:20:44 <glguy> OK, spider it is
21:21:42 <dfeuer> Not as surprising as the fact that Data.Set.intersection is lazy in its second argument.
21:22:04 <dfeuer> And difference too.
21:22:10 <dfeuer> That's much more surprising.
21:22:26 <dfeuer> empty `intersection` undefined = empty
21:25:50 <jle`> that's cute
21:26:33 <dfeuer> I don't like that much.
21:26:42 <dfeuer> I don't think that makes good sense.
21:26:56 <Cale> Sure it does
21:27:12 <Koterpillar> empty `intersection` _ = empty
21:27:15 <dfeuer> Cale, from a design standpoint.
21:27:32 <Cale> I don't see a problem with it, it's just a sign that the thing is as lazy as it ought to be
21:27:32 <dfeuer> Koterpillar, yes, but then you'd expect also  _ `intersection` empty = empty, which ain't true.
21:27:40 <Cale> You would not expect that
21:27:50 <Cale> It has to pattern match on one of its arguments or the other first
21:28:00 <dfeuer> Yes, it does.
21:28:15 <Cale> > Nothing <*> undefined
21:28:20 <lambdabot>  Nothing
21:28:22 <dfeuer> undefined is not a set.
21:28:56 <Cale> > undefined <*> Nothing
21:28:58 <lambdabot>  *Exception: Prelude.undefined
21:29:02 <Cale> Same deal
21:29:13 <Cale> There are countless other examples..
21:29:22 <Cale> > False && undefined
21:29:24 <lambdabot>  False
21:29:29 <Cale> > undefined && False
21:29:31 <lambdabot>  *Exception: Prelude.undefined
21:29:40 <dfeuer> Cale, I worry more about strictness analysis than I do about this sort of weird convenience. If someone is trying to intersect together a bunch of sets, I want GHC to Do The Right Thing even if the programmer is a bit sloppy.
21:29:58 <Cale> That is what helps GHC do the right thing
21:30:08 <dfeuer> Not in this case.
21:30:24 <Cale> It means that if you're doing a foldr Set.intersection it can terminate early
21:30:29 <Cale> If it hits an empty set
21:30:40 <dfeuer> && and || short-circuit because that's what programmers rely on. Not because it's good for the compiler analysis.
21:31:18 <dfeuer> I really tried (and failed) to convince people that  .&. and .|. and such should be strict in both arguments for the Bits Bool instance.
21:31:44 <Cale> I'm not sure I understand what benefit there would be in examining the second argument if you know that the first is empty.
21:32:12 <dfeuer> Cale, that sort of thing is what often lets GHC transform foldl into foldl'.
21:33:09 <Cale> The computation of the second set might be very expensive
21:33:34 <Cale> Not computing it unnecessarily can avoid an almost arbitrary amount of work
21:33:38 <dfeuer> I don't think you're right about foldr either. At all.
21:34:15 <dmwit> dfeuer: Do you have a specific example that GHC would handle better if the strictness of `intersection` were different?
21:34:27 <dmwit> dfeuer: If not, it might be worth the effort to cook one up before sweating too much.
21:34:28 <Cale> > foldr S.intersection undefined (repeat S.empty)
21:34:29 <lambdabot>  fromList []
21:34:29 <dfeuer> You can't short-circuit. All you can do is turn the tail of a `foldl'` into a series of cheap operations.
21:34:40 <glguy> If someone's relying on a function to be strict unnecessarily in its arguments, it would be good to seq those arguments at the use-site
21:35:15 <dfeuer> > foldr S.intersection undefined (S.singleton 3 : repeat S.empty)
21:35:16 <lambdabot>  fromList []
21:35:19 <glguy> and put a comment that while unnecessary that this is a  good idea in this case
21:35:30 <dfeuer> Ok, I'm clearly getting confused. Must be tired.
21:36:00 <dfeuer> dmwit, you have a point. It's probably going to be a foldl, but I'll have to cook it.
21:36:20 <glguy> I think that the possible improvement would be to document the fact that intersection is actually lazy in that second argument so that someone could rely on that behavior
21:36:23 <Cale> You'll probably have to make it flip foldl
21:36:26 <glguy> It could just as well be the other way around
21:36:27 <dfeuer> Ah, I understand the short-circuiting now, Cale. I'm too tird, clearly.
21:36:41 <Cale> er, sorry, foldl with the arguments to the second function flipped
21:36:42 <dfeuer> glguy, I wasn't going to change the behavior.
21:36:57 <sa_> hey
21:36:59 <dfeuer> And you're right, it definitely needs to be documented.
21:37:04 <glguy> I was more focused on the possible improvement of adding these things to the documentation than the change 
21:37:20 <dfeuer> Yes, I will add them to the documentation.
21:37:25 <dfeuer> Definitely important.
21:37:51 <sa_> i got a really simple question this is my first day
21:37:55 <sa_> boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]   
21:38:08 <dfeuer> In fact, we need comprehensive strictness documentation, especially for Data.Map.Strict. At present, you really need to read the source code to know what it's doing.
21:38:11 <sa_> can anyone explain this to me, where does x come from
21:38:31 <dmwit> sa_: It's a bit like a loop that traverses the input list (`xs`).
21:38:41 <dmwit> sa_: `x` takes on the values in `xs` one at a time.
21:38:45 <glguy> We call that a "list comprehension"
21:39:01 <eklavya> how to hide TH dependency and let the user write "instance Some A" instead of "$(deriveSome ''A)"?
21:39:20 <Cale> sa_: x is bound by the generator x <- xs
21:39:24 <glguy> eklavya: No :(
21:39:33 <Cale> sa_: which means "where x is selected from the list xs"
21:39:34 <sa_> idk how to whisper but thanks dmwit i got it now
21:39:47 <glguy> eklavya: But the $( and ) are unneeded
21:39:47 <sa_> also cale, thanks
21:40:12 <Cale> > [(x,y) | x <- [1,2,3], y <- [4,5]]
21:40:13 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
21:40:16 <eklavya> so just  --deriveSome ''A-- ?
21:40:18 <dfeuer> boomBangs = map (bool "BANG!" "BOOM!" . (<10)) . filter odd, if I'm not mistaken
21:40:25 <Cale> > [(x,y) | x <- [1,2,3], y <- [4,5], even (x + y)]
21:40:26 <lambdabot>  [(1,5),(2,4),(3,5)]
21:40:29 <glguy> eklavya: Yes, but without all that -- stuff :)
21:40:34 <eklavya> :D
21:40:45 <eklavya> of course
21:41:14 <eklavya> how does aeson manage it, they also use TH but all I have to write is instance FromJSON A
21:41:27 <dmwit> eklavya: They use Generics for that, not TH.
21:41:32 <Cale> dfeuer: That's not the literal desugaring though
21:41:37 <dmwit> eklavya: If you want the TH-based instance, you have to write a TH splice.
21:41:48 <Cale> @undo [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
21:41:48 <lambdabot> concatMap (\ x -> if odd x then [if x < 10 then "BOOM!" else "BANG!"] else []) xs
21:41:48 <eklavya> oh
21:42:02 <eklavya> I think it's not so bad
21:45:03 <dfeuer> cale, no, it's not.
21:47:14 <dfeuer> Sorry for my silliness about intersection earlier. I spewed nonsense. :-[
21:52:33 <dfeuer> I hope the next Haskell Report supports type operators whose names start with colens.
21:52:34 <dfeuer> colons.
21:53:18 <dfeuer> I dunno what I think about the ones that don't.
21:54:22 <Johnathan> So this question isn't specifically haskell related, moreso type related 
21:54:42 <Johnathan> Could you make a pair of functions, f, and g, for which f g and g f is well typed? 
21:54:59 <Koterpillar> Johnathan: f = g = id
21:56:03 <dfeuer> :t flip (flip flip)
21:56:05 <lambdabot> (a -> b -> c) -> b -> a -> c
21:56:10 <dfeuer> :t (flip flip) flip
21:56:11 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
21:56:16 <Johnathan> Oh... 
21:56:22 <Koterpillar> :t (const const)
21:56:23 <lambdabot> b -> a -> b1 -> a
21:56:24 <dfeuer> :t fmap (fmap fmap)
21:56:25 <lambdabot> (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
21:56:31 <dfeuer> :t (fmap fmap) fmap
21:56:32 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:56:48 <dfeuer> :t traverse (traverse traverse)
21:56:50 <lambdabot> (Applicative f, Traversable t, Traversable t1, Traversable t2) => t (t1 (a -> f b)) -> t2 a -> t (t1 (f (t2 b)))
21:56:54 <dfeuer> :t (traverse traverse) traverse
21:56:55 <lambdabot> (Applicative f, Traversable t, Traversable t1, Traversable ((->) (a -> f b))) => t (t1 a) -> (a -> f b) -> f (t (t1 b))
21:57:20 <Johnathan> I didn't actually think that `id id` would work. 
21:57:20 <dfeuer> That last looks shady. Forget it.
21:59:31 <nak> whoa dfeuer i just crossed paths with your recently on stackoverflow
21:59:36 <nak> i'm trying to remember which question
21:59:52 <dfeuer> nak, what's your username there?
21:59:57 <nak> naomik
22:00:40 <nak> oh! you edited my question here: http://stackoverflow.com/questions/38682768/how-to-derive-a-procedures-hm-type-based-on-its-implementation
22:01:35 <dfeuer> Oh, yes. That had a few too many tags :p
22:01:42 <nak> ha yeah
22:01:59 <nak> in all fairness, i was open to accepting answers in haskell
22:02:08 <nak> i should've been more explicit why i was tagging haskell
22:02:21 <nak> but i got the info i needed nonetheless
22:02:23 <nak> ^_^
22:02:49 <dfeuer> nak, in the future, you might be better off *writing* such questions in languages like Haskell or Ocaml, so you can legitimately use tags that will attract the people who are likely to know the answers.
22:03:13 <dfeuer> Relatively few Javascript people are interested in/knowledgeable about type inference.
22:03:27 <nak> well the code examples were trivial, the important parts were the types, yeah
22:04:35 <nak> anyway, i see that you're basically a wizard
22:04:38 <dfeuer> No.
22:04:41 <nak> i'm sorry if i um, misused the tag lol
22:04:43 <dfeuer> Cale is a wizard.
22:04:51 <dfeuer> dmwit is a wizard.
22:05:12 <nak> hm yes those people have answered me from time to time in here
22:05:25 <dfeuer> I'm just someone with a lot of patience (sometimes), and some flashes of insight (on rare occasions)
22:07:25 * nak nods
22:07:34 <nkaretnikov`> is there a function fromList :: [a] -> HList a that allows converting an ordinary list to an hlist?
22:09:22 <dfeuer> nkaretnikov`, that type doesn't make too much sense to me.
22:09:43 <dfeuer> And yes, you can convert an ordinary list to an HList, but not like that.
22:09:46 <nkaretnikov`> dfeuer: well, ignore the type
22:09:53 <nkaretnikov`> dfeuer: then how?
22:10:03 <nkaretnikov`> dfeuer: most libs provide such a function
22:10:23 <dfeuer> nkaretnikov`, you can, but I don't think it's necessarily going to be very *nice*.
22:10:59 <c_wraith> it's really hard to provide a type for. 
22:11:02 <dfeuer> type family Replicate n a where Replicate 'Z a = '[]; Replicate ('S n) a = a ': Replicate n a
22:12:15 <dfeuer> data FromListResult a where FromListResult :: HList (Replicate n a) -> FromListResult a
22:12:25 <dfeuer> fromList :: [a] -> FromListResult a
22:12:31 <dfeuer> I *think* you could do it with that.
22:12:45 <dfeuer> Maybe.
22:12:54 <dfeuer> It's gonna be nasty.
22:13:39 <exio4> it'd be less-nasty with a Vect n a 
22:14:01 <dfeuer> Much.
22:15:29 <exio4> you could then have (∀a. [a] -> ∃n. Vect n a) and (∀a,n. Vect n a -> [a])
22:17:43 <nkaretnikov`> dfeuer: how do people use hlist usually, then, construct explictily like records?
22:18:14 <dfeuer> nkaretnikov`, you could. There are also some fancy (sort of printf-like, if you've seen that) functions for doing it.
22:18:46 <nkaretnikov`> dfeuer: i don't recall, could you point me to an example?
22:21:43 <lpaste> dfeuer pasted “HList fromList” at http://lpaste.net/173761
22:21:51 * nkaretnikov` looks
22:22:11 <dfeuer> nkaretnikov`, the HList package has one somewhere, with all the rest of its experimental goo.
22:22:26 <dfeuer> (the fancy thing I mean. I dunno about fromList)
22:22:35 <nkaretnikov`> dfeuer: haha, right, i've already looked but it's just  a mess :)
22:23:17 <nkaretnikov`> anyway, gonna try something else, then. thanks for your help!
22:23:28 <dfeuer> BOOM.
22:38:01 <pyon> Is there a type class similar to Alternative, but where empty and (<|>) require the wrapped type be a Monoid?
22:38:45 <johnw> why not then just use Monoid (m a)?
22:39:02 <pyon> Mmm. Good point.
22:39:08 <pyon> Yeah, I'll use just that.
22:39:13 <suzu> :D
22:43:08 <lpaste> dfeuer revised “HList fromList”: “HList fromList” at http://lpaste.net/173761
22:47:41 <lpaste> fragamus pasted “what is that   #.” at http://lpaste.net/173772
22:48:47 <glguy> fragamus:  http://hackage.haskell.org/package/profunctors-5.2/docs/Data-Profunctor-Unsafe.html#v:-35-.
22:49:08 <fragamus> thanks
23:25:49 <piyush-kurur>  folks: for haskell packages is version 0.1.0 and version 0.1 different?
23:29:14 <srhb> piyush-kurur: Up to the author. I don't think it's usual to make such a distinction.
23:31:24 <c_wraith> cabal does treat them as different versions, though
23:31:36 <c_wraith> with 0.1.0 the higher number
23:34:17 <piyush-kurur> c_wraith: Thanks. That is what I wanted to know. So if I start with 0.1 then I can make a minor release with a 0.1.0 I hope. Pushing this idea can I start with version 0? I hope yes.
23:34:56 <piyush-kurur> I like version 0 shows howmuch the author trusts the code
23:35:01 <c_wraith> you can, though it might confuse people who want to specify the lower bound with 3 components
23:35:15 <c_wraith> They might not realize they're disallowing a version
23:35:20 <kadoban> piyush-kurur: I would ... not do that. It's confusing.
23:35:38 <kadoban> Pick a number of components in your versions, and stick with it.
23:36:06 <piyush-kurur> kadoban: makes sense
23:37:07 <Cale> 0, 0.0, 0.0.0, 0.0.0.0, 0.0.0.0.0
23:37:39 <kadoban> unary version numbers? Fun xD
23:37:47 <piyush-kurur> Cale: not possible if you want to stick to PVP
23:38:32 <phanimahesh> PVP?
23:38:52 <piyush-kurur> but I still like the version 0.0.0 (say and then increment stuff as it changes)
23:39:08 <piyush-kurur> may be should try it on the next package
23:39:45 <piyush-kurur> phanimahesh: PVP = Package versioning policy https://wiki.haskell.org/Package_versioning_policy
23:42:45 <YellowOnion> Is there no lens for Char's?
23:42:56 <piyush-kurur> Cale: PVP : The protector of packages from evils of Unary versioning :-)
