00:00:12 <Rarrikins> gestone: Ahh, you're right.
00:00:27 <gestone> wait is tail not the same as drop 1?
00:00:39 <Rarrikins> gestone: No, try both on empty lists.
00:00:53 <gestone> ah tail is a partial function
00:02:45 <dk_> hello
00:03:46 <gestone> hi hi
00:05:43 <dk_> I wan't job in haskell where could i find ...is it possible to get for a fresher like me who has coded a lot in haskell but not professionally yet
00:06:28 <gestone> man i'm dying for a haskell job too
00:06:30 <zomg> check functionaljobs or stack overflow, those are probably the easiest to find ones.. other than that you'd probably have to know someone 
00:07:38 * hackagebot kawaii 0.0.1.1 - Utilities for serving static sites and blogs with Wai/Warp  https://hackage.haskell.org/package/kawaii-0.0.1.1 (etcinit)
00:07:38 * hackagebot bioinformatics-toolkit 0.2.2 - A collection of bioinformatics tools  https://hackage.haskell.org/package/bioinformatics-toolkit-0.2.2 (kaizhang)
00:08:28 <dk_> I am from India and couldn't find any company using haskell .... also i don't know personally anyone abroad working with Haskell do i ..should left my zeal to work with FP
00:10:52 <zomg> maybe see if there are any meetups in your local area, if not FP related, just programming / tech stuff
00:11:17 <zomg> could be useful for finding out about any companies out there
00:11:53 <dmwit> You could look at haskellers.com, though I'm not sure whether employers still post there.
00:12:15 <gestone> i know that /r/haskell has job opening occasionally
00:12:17 <gestone> on reddit
00:17:14 <dk_> ohk but wherever i see they require professionals ..... 
00:17:52 <dk_> and also i don't come to know whether there occurs ant meet for FP
00:27:56 <saurabh__> is dk_ around?
00:39:07 <kamyar> Hello everyone
00:39:22 <kamyar> I have a general question
00:39:39 <kamyar> Any Haskell experienced developer may help
00:39:56 <kamyar> I am studying and writing Haskell for 2 months
00:40:06 <kamyar> I have a limited free time
00:40:11 <kamyar> about 2-3 hours a day
00:40:28 <kamyar> I study documents and tutorials and try to port my Python codes into Haskel too learn better
00:40:41 <kamyar> Now I have a good intuition about Monads 
00:40:58 <kamyar> I have a good knowledge of functional programming, purity and laziness
00:41:23 <kamyar> I know Monad transformers to some extent
00:41:42 <kamyar> Now I want to know what should be the rest of my roadmap
00:41:51 <gestone> build things!
00:41:57 <kamyar> I have tons of concepts and packages to learn
00:42:08 <kamyar> MVar/TVar
00:42:12 <kamyar> Conduit/Pipes
00:42:19 <kamyar> Arrows
00:43:09 <kamyar> Coroutines
00:45:22 <kamyar> gestone: I am currently trying to build things, actually I have built 2
00:45:55 <kamyar> But for writing each of them I had to learn so many things
00:46:12 <kamyar> I learned lens and aeson for calling REST using Wreq
00:46:12 <gestone> yeah, i feel you. i'm in the same boat
00:46:27 <gestone> oh dear
00:48:25 <kamyar> and learned HDBC for postgRESQL query
00:48:41 <kamyar> monad transformers for Redis and many others
00:49:01 <kamyar> Now I wanna port a WebSocket dispatching service to Haskell
00:49:01 <gestone> if you mind me asking
00:49:03 <gestone> what did you build?
00:49:36 <kamyar> So I may need many things: At least stateful multithread programming 
00:50:03 <kamyar> gestone: I built a simple utility for checking availability of our account managers
00:50:31 <kamyar> gestone: First I wrote one using Redis+PostgreSQL and Ansi Console
00:50:54 <kamyar> gestone: Then I wrote another using our backend RESTful services
00:51:06 <kamyar> gestone: With same functionality
00:51:25 <kamyar> gestone: I learned many things, and using this IRC I made the code much better yet
00:51:32 <gestone> ahh i see
00:52:18 <kamyar> gestone: Where r u from? If not mind
00:52:18 <gestone> all i've made is a script to send text files to an SMTP server and upload MP3 files to an AWS bucket
00:52:35 <gestone> yeah i'm in the US
00:52:38 <gestone> i'm in WA
00:52:51 <gestone> you?
00:52:54 <kamyar> gestone: And I am Persian
00:53:07 <gestone> ahh
00:53:36 <kamyar> gestone: How old r u?
00:53:49 <gestone> 25, you?
00:54:01 <kamyar> gestone: Am somewhat old!   I am 37
00:54:13 <gestone> ah i see
00:54:16 <kamyar> getsone: about 20 years of programming
00:54:25 <gestone> what made you want to use haskell?
00:54:37 <gestone> hah i've been programming since around 18
00:54:50 <kamyar> gestone: Digging in programming languages have been my hobby for long
00:55:25 <gestone> yeah, it quickly became my hobby as well
00:55:35 <kamyar> gestone: I researched for a fast language for building high available, concurrent, scalable small programs
00:55:46 <gestone> and you stumbled across haskell?
00:56:41 <kamyar> gestone: yea, Rust is also great, but Haskell is more mature, and I had little experience before, So I chose it
00:57:10 <gestone> ahh yes
00:57:12 <gestone> do you use haskell at your job
00:57:55 <kamyar> gestone: Not yet, but soon it may be!
00:58:20 <kamyar> gestone: I have a plan for rewriting some parts of our backend using Haskell
00:58:25 <gestone> ohh interesting
00:58:30 <gestone> what is it written in atm?
00:58:56 <kamyar> gestone: We have a dispatching service which gets data from ZMQ and dispatches to some selected websocket clients
00:59:15 <kamyar> gestone: I guess it is a good candidate
00:59:57 <gestone> ahh
01:00:16 <kamyar> getsone: They are all written in Python
01:00:42 <gestone> agh
01:01:15 <gestone> sorry, after writing things in haskell with global type inference, i can't put myself to write python with all those run time errors X_x
01:01:29 <Rarrikins> gestone: Here's my ugly attempt at the earlier problem: http://lpaste.net/179213
01:01:31 <kamyar> gestone: The intersting part is that I have used most possible functional potential of python: even partial function calling
01:02:03 <gestone> Rarrikins: aghh
01:02:17 <gestone> kamyar: even partial function calling?
01:02:22 <kamyar> gestone: BTW the whole code is async using coroutines
01:02:33 <kamyar> gestone: yes, using functools.partial
01:03:01 <kamyar> gestone: In fact it is Advanced Python: Python 3.5 + full type annotation
01:03:26 <gestone> kamyar: so are these like curried functions?
01:03:36 <kamyar> getsone: Even parts of code are working lazy! 
01:03:53 <kamyar> getsone: yes they are like curried 
01:04:20 <gestone> Rarrikins: just wondering, what's the '@' symbol signifying when you pattern match on your second case of execute?
01:04:35 <kamyar> getsone: In fact Python 3+ gives much more functional programming tools than 2 branch
01:04:46 <Rarrikins> gestone: a@b means the whole thing is a, and b is what it's expanded into.
01:05:00 <Rarrikins> gestone: Like wholeList@(head:tail) 
01:05:09 <gestone> Rarrikins: ah got it
01:05:26 <gestone> kamyar: just another reason to switch from 2.7 to 3+
01:05:52 <kamyar> gestone: sure! And for me, it made another reason to switch to a pure functional language like Haskell!
01:06:03 <intothemountains> How can I construct some Group {positions = …, player = p} if p is Just … and Nothing if p is Nothing?
01:06:19 <kamyar> gestone: I felt I am getting too functional! So I like it!
01:07:48 <Rarrikins> intothemountains: fmap (\p -> Group { positions = ..., player = p }) theThing
01:07:49 <gestone> kamyar: indeed, this language always makes me feel dumb one way or another, but i always come back to it
01:08:55 <kamyar> getsone: Me too! When I first started to learn French language, soon I was able to read any text, even not understanding the meaning.
01:09:31 <kamyar> getsone: But Haskell is the opposite: After 2 months of Haskelling I still do not understand some code! Feel absolutely dymb!
01:09:52 <intothemountains> Rarrikins: no shortcut for it?
01:10:24 <gestone> yeah, i ended up reading all of haskellbook, and i still have to refer back to it because even though it's easy to understand, there's a lot to learn coming from imperative langs
01:11:31 <intothemountains> Also, is pattern matching the only way to deconstruct constructors?
01:11:31 <Rarrikins> intothemountains: Nope. With Maybe, fmap will return Nothing if you start with that, or it'll apply the function you give if you have a Just value.
01:11:35 <kamyar> getsone: Apparently no one replied me here! I have to go on my way
01:11:42 <intothemountains> Rarrikins: ok, cheers!
01:11:55 <gestone> :(
01:12:30 <kamyar> getsone: I have studied Arrows from different sources, with no chance of understaing!
01:12:38 <kamyar> getsone: Do u understand Arrows?
01:12:56 <gestone> kamyar: nope =/
01:13:02 <gestone> haven't dug into Arrows yet
01:13:11 <gestone> i've only really used parsec
01:13:30 <kamyar> gestone: Arrows are very useful when using XHT
01:13:42 <gestone> XHT?
01:14:14 <kamyar> getsone: sorry! HXT
01:14:51 <gestone> xml processing?
01:15:20 <kamyar> getsone: We have a likely big crawler project working here! It is written in Python! I have not wrote it and so it is not well coded! I want to port it to Haskel ass my second pace!
01:15:26 <intothemountains> Like, how could I extract Just Snorkel from Just Piece, where Piece = Snorkel Snorkel | Stone, and Snorkel = Green | Purple?
01:16:28 <gestone> kamyar: ahh
01:16:38 <gestone> alright all i'm headed off to bed it was nice chatting with you all
01:16:46 <kamyar> getsone: Sorry for my mistakes: "I have not written it!"
01:17:14 <kamyar> getsone: same here! Good night! Sweet dream!
01:18:30 <hamid> folks i want to know how you can implement this function with such inputs 1."Hello world!" 2.[(1,3),(4,2),(0,2)] as in (index, length) which will result in such output "(H()ell()o )world!".
01:19:52 <hamid> sorry this: "(H(e)ll)(o )world!"
01:20:55 <Rarrikins> intothemountains: With basic Haskell, something like http://lpaste.net/179216
01:21:27 <Rarrikins> intothemountains: (>>=) will return Nothing if you start with that or whatever the function on the right returns otherwise.
01:23:21 <oddasat> Hi, working my way through the Opaleye manipulation tutorial currently. The update statements generated from the example differs slightly from what the tutorial says it should, it adds SET "id" = DEFAULT. Is there a way around this?
01:23:33 <Rarrikins> hamid: Break it down. Make a function that takes the current String and only one (index, length) value and gives the output.
01:24:33 <Maxdamantus> Rarrikins: that's going to be difficult to use since the indices change each time you apply the subtransformation.
01:25:27 <oddasat> the tutorial says it should have generated : ... UPDATE tableName SET x = .., y = .., not id = DEFAULT, x = .., y = ..
01:25:38 <Maxdamantus> hamid: go through the input adding a '(' and appending the length + index to the state when there is a pair with the current index.
01:25:59 <Rarrikins> Maxdamantus: Ahh, missed the nex example output.
01:26:20 <Maxdamantus> hamid: and adding a ')' when there is an index in the state.
01:27:54 <hamid> Maxdamantus, would you write it? if you are free.
01:28:05 <Maxdamantus> hamid: what's it for?
01:29:11 <hamid> Maxdamantus, fun... i was thinking how this might affect the state since i was writing it in ruby.
01:29:49 <hamid> Maxdamantus, i exactly did what you told me to in ruby but when it comes to haskell it's a little bit weird
01:37:08 <Maxdamantus> actually, don't even need state.
01:37:35 * hackagebot clash-prelude 0.10.14 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-0.10.14 (ChristiaanBaaij)
01:41:11 <Maxdamantus> @let f bs st = concat [['(' | (s, l) <- bs, s == n] ++ toList c ++ [')' | (s, l) <- bs, s + l == n] | (n, c) <- zip [0..] $ map Just st ++ [Nothing]]
01:41:13 <lambdabot>  .L.hs:161:10:
01:41:13 <lambdabot>      Ambiguous occurrence ‘toList’
01:41:13 <lambdabot>      It could refer to either ‘Data.Foldable.toList’,
01:41:39 <Maxdamantus> @let f bs st = Prelude.concat [['(' | (s, l) <- bs, s == n] ++ Data.Foldable.toList c ++ [')' | (s, l) <- bs, s + l == n] | (n, c) <- zip [0..] $ map Just st ++ [Nothing]]
01:41:40 <lambdabot>  Defined.
01:42:03 <Maxdamantus> > f [(1,3),(4,2),(0,2)] "Hello world!"
01:42:05 <lambdabot>      Ambiguous occurrence ‘f’
01:42:05 <lambdabot>      It could refer to either ‘L.f’,
01:42:05 <lambdabot>                               defined at /tmp/mueval11015139291801979802.hs:1...
01:42:09 <Maxdamantus> Bleh.
01:42:27 <Maxdamantus> @let f bs st = Prelude.concat [['(' | (s, l) <- bs, s == n] ++ Data.Foldable.toList c ++ [')' | (s, l) <- bs, s + l == n] | (n, c) <- zip [0..] $ map Just st ++ [Nothing]] in f [(1,3),(4,2),(0,2)] "Hello world!"
01:42:27 <lambdabot>  Parse failed: Parse error: in
01:42:57 <Maxdamantus> > let f bs st = Prelude.concat [['(' | (s, l) <- bs, s == n] ++ Data.Foldable.toList c ++ [')' | (s, l) <- bs, s + l == n] | (n, c) <- zip [0..] $ map Just st ++ [Nothing]] in f [(1,3),(4,2),(0,2)] "Hello world!"
01:42:59 <lambdabot>  "(H(el)l(o) w)orld!"
01:43:06 <Maxdamantus> Should probably have tried it in private before spamming.
01:44:17 <Maxdamantus> Seems incorrect anyway.
01:46:21 <hamid> Maxdamantus, haha but i exactly wanted how you go step by step. So generating and concating.
01:48:06 <kamyar> An unrelated question:
01:48:34 <kamyar> Since Haskell is a complicated language in compare with imperative trivial languages
01:48:43 <kamyar> I usually wonder if there are 'girls
01:48:54 <kamyar> If they are 'girls' writing Haskell?
01:49:36 <Cale> Of course there are, why wouldn't there be?
01:49:49 <kamyar> Now we are 1405 people here, are there any girls?
01:50:09 <Cale> Actually, that discussion is almost certainly inappropriate here.
01:50:37 <MarLinn> probability says yes. WOAAAAAAA!!!!eleven!!
01:50:39 <MarLinn> omg
01:50:47 <kamyar> Cale: Hello again! Sorry for inconvenience! I did not meant any insulting! I just wondered!
01:50:48 <MarLinn> -_-
01:51:50 <kamyar> Cale; Actually I wanna convince one of my lady coworkers to start Haskell!
01:52:08 <kamyar> Cale: that is why I wondered!
01:52:22 <hamid> haha and that's the way to go.
01:52:51 <kamyar> Cale: usually this is a good way to convince a girl! Showing another girl on the same boat!
01:52:56 <zomg> I showed both javascript and haskell to my gf who has never done any programming, she thought haskell made more sense :)
01:53:05 <piyush-kurur> kamyar: You can tell her that the first programmer was a girl https://en.wikipedia.org/wiki/Ada_Lovelace
01:53:15 <zomg> although I don't think the gender in this instance has nothing to do with it, but rather it was interesting to hear from someone who had never done any programming
01:54:21 <piyush-kurur> and she was definitely well ahead of her times
01:54:39 <piyush-kurur> much ahead than many men infact
01:54:49 <zomg> there was a woman at nasa who was one of the key people behind the code that sent man on the moon
01:55:01 <zomg> forget her name though, saw the picture with her and stacks of code printouts on twitter a few times
01:55:49 <kamyar> Hey fellows! I give up! I just wanted to make some motivation for her! Sorry!
01:56:25 <Maxdamantus> I think if she's already doing programming gender won't have much to do with it.
01:56:40 <zomg> yeah, honestly some people might find it a bit insulting
01:56:45 <zomg> "look, there's another woman there!"
01:57:20 <kamyar> zomg: She does not find it insulting, but a motivation for self-confidence!
01:57:24 <zomg> anyway, if you want to teach her haskell just tell her why you think it's a good language
01:57:36 <Maxdamantus> I suspect the main discrepencies between genders in different areas have to do with social upbringing, not really with capability.
01:57:38 <zomg> the fact that a woman is using it is hardly a good excuse to learn a programming language :P
01:58:07 <kamyar> zomg: Previously I trained her C#, and then Python. Now she is wondering why she may want to learn Haskell!
01:58:46 <zomg> well considering you know those two languages and also haskell from the sound of it, I would just explain why you think it would be useful and/or interesting :)
01:59:59 <kamyar> zomg: thanks! Motivation just depends on someone's morals and life perceptions! That is why I guess it may be a good reason for her! Cuz I simply know her!
02:00:13 <MarLinn> Well you could argue that maybe our culture selects for a particular type of women to come into or stay in our community. So you might want to use different things to lure male or female people into it.
02:00:26 <hamid> Now I'm curious! Is there any research on why a man is more likely to go for such activity(being a programmer) than a woman?
02:00:51 <Cale> It would be weird for anything gender related to have any impact on the reasons to learn or not learn a programming language. The reasons one would give ought to be the same as those you would give to anyone else, in any case.
02:00:51 <kamyar> hamid: Where r u from? If u not mind
02:01:21 <piyush-kurur> hamid: I think the reasons are kind of obvious is it not?
02:02:20 <hamid> piyush-kurur, it might be but science is not about "it's the obvious so let it go".
02:03:20 <kamyar> Anyway! It could be a good research subject: modeling Haskellers by Age, Gender, Location....
02:03:21 <MarLinn> Cale, I agree in general. I'm just saying there could be some (unfortunate) pre-selection. Also maybe we drive out some "types" more easily.
02:03:40 <piyush-kurur> for example, I was hunting for a toy to present to kid and the shopkeeper suddenly asks whether the kid is a boy or girl and when I said girl he starts bringing the "girly" stuff like dolls, kitchen set instead of the "boyish" stuff like remote control cars etc
02:05:43 <zomg> boys are generally encouraged to study math, sciences, etc. more than girls
02:06:14 <Maxdamantus> They're also encouraged to relate differently to friends.
02:06:39 <zomg> there was also some stuff on how engineering related toys and such tend to be marketed more towards boys I think
02:06:43 <kamyar> Zomg: I think it is not that alone! Psychological researches show girls' mind is different than boys'
02:06:49 <zomg> kamyar: that's just false
02:07:04 <piyush-kurur> there is no doubt that there is pre-selection in the society where I live in (India) which to a large extent is a resonably liberal society.
02:07:20 <Cale> For sure, there are cultural external factors which might predict that more or fewer women are participating in programming in general. But when you're talking about someone who is already a programmer and coming to the selection of an individual programming language... it seems strange to me that those cultural factors would still have much influence.
02:07:45 <hamid> kamyar, what "psychological" researchs exactly?
02:07:53 <kamyar> Zomg: for instance, 3D imagination in a general masculine brain is much better than a feminine brain and it is approved
02:08:28 <zomg> Yeah I recall hearing something about that, but it was more about how the brain perceives things differently
02:08:35 <kamyar> Zomg: In stead, there are some skills females are better , e.g. speaking
02:08:42 <vin-ivar> <piyush-kurur> there is no doubt that there is pre-selection in the society where I live in (India) which to a large extent is a resonably liberal society.
02:08:44 <vin-ivar> wat
02:08:57 <piyush-kurur> kamyar: the difference in men and women brains could itself be due to the kind of training given to them kids
02:09:03 <zomg> iirc female brain uses different cues for 3D recognition than male, but this was not something that was true for every individual
02:09:04 <vin-ivar> kamyar, nature/nurture
02:09:17 <vin-ivar> you don't know that these differences are inherent
02:09:21 <vin-ivar> and not because of upbringing
02:09:22 <ongy> Cale: I have seen behaviour like that. But mostly in teens
02:09:34 <kamyar> Zomg: Actually I guess in the future, researches may show some programming languages may match better with men brain, while some others match female brain
02:09:44 <zomg> there was actually an interesting research on VR related nausea, and how it is sometimes more common in women because of the type of rendering used
02:09:53 <zomg> which doesn't account for the difference in some women's perception of 3D
02:10:07 <zomg> but as usual I saw it on twitter and didn't keep a link :P
02:10:22 <Cale> I wonder how often any of those studies has been repeated
02:10:44 <zomg> someone from Oculus mentioned they recommend using the two technologies mentioned (one was preferrable for men, other for women)
02:10:50 <ongy> and how big the test groups are
02:10:52 <zomg> so it seems it had at least some truth to it
02:10:54 <intothemountains> I'm searching for some function (a -> Bool) -> (Maybe a) -> Bool that will return False if the second argument is Nothing
02:11:15 <MarLinn> const isNothing
02:11:19 <Cale> Finally a proper Haskell question.
02:11:20 <zomg> oh maybe it was @tom_forsyth
02:11:33 <MarLinn> oups. const isJust
02:11:43 <kamyar> Zomg: I barely guess the result maybe absolutely different than what we expect! I mean, for example, in spite us, weoman may learn pure functional programming much better! 
02:12:17 <Cale> intothemountains: Did you want to do something with the supplied function?
02:12:32 <Cale> :t maybe False f
02:12:32 <intothemountains> MarLinn: cheers
02:12:34 <lambdabot>     Ambiguous occurrence ‘f’
02:12:34 <lambdabot>     It could refer to either ‘L.f’,
02:12:34 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:158:1
02:12:36 <Cale> :t \f -> maybe False f
02:12:37 <lambdabot> (a -> Bool) -> Maybe a -> Bool
02:12:46 <kamyar> Zomg: The girl I mentioned above, she is master in SQL, when learned C#/Python she was still in lov ewith SQL! SQL is declarative! I guess her brain is match with declarative paradigm more than imperative!
02:12:46 <intothemountains> oh, thanks Cale too!
02:13:22 <zomg> kamyar: familiarity with something is often a big factor rather than the brain :)
02:13:47 <KB5> https://www.techempower.com/benchmarks/previews/round13/#section=data-r13&hw=azu&test=fortune
02:13:57 <KB5> Sneak peek into the next round of web framework benchmarks. Starting to look like Go dominating the lot.
02:13:58 <zomg> but since some people are better in for example math than others, it's plausible there could be a difference between men and women as well... but upbrining is definitely a huge factor
02:14:33 <kamyar> zomg: sure! u r right! But I have some blind guess in my mind that girls learn Haskell much easier than us! I think their mind is much more functional! But our's is imperative
02:15:05 <zomg> who knows :)
02:15:29 <Cale> In any case, the variation from individual to individual seems much larger than the variation between the sexes, and even then, the largest predictor of ability is going to be the amount of time spent working on improving.
02:15:34 <kamyar> Zomg: concurrency is clearly better implemented in girl's mind! they can do work while speaking!
02:16:29 <kamyar> Zomg: They can even cook while struggling! I think they are more functional!
02:16:44 <piyush-kurur> kamyar: I think those are just popular stereo types. 
02:17:47 <piyush-kurur> I can give you many such incidents which makes me think that the difference between sexes are just nonsense
02:18:09 <piyush-kurur> this men are from mars and women are are from venus type on nonsense
02:19:07 <ongy> piyush-kurur: saying they are exactly the same, is at least the same amount of wrong, though
02:20:22 <Cale> https://www.sciencedaily.com/releases/2007/10/071024145626.htm -- here's some more research of dubious quality to go in the other direction
02:20:53 <piyush-kurur> except for the obvious differences in their genitals I do not see much difference in their ability to think, reason.
02:21:25 <puregreen> piyush-kurur: what about things they are interested in?
02:21:36 <ongy> puregreen: may as well be mostly learned
02:21:48 <zomg> Cale: I was just thinking that both my mom and gf are terrible at reading maps and finding places... but then I realized that so is my brother =)
02:22:26 <piyush-kurur> zomg: my wife thought she was bad at reading maps till she tried.
02:22:49 <piyush-kurur> so there goes one another stereo type
02:23:16 <zomg> heh
02:23:46 <puregreen> ongy: sure, but e.g. rhesus monkeys gendered toy experiments suggest it might not all be learned
02:24:25 <piyush-kurur> and do you thing the rhesus monkeys do not have societal pressures.
02:24:43 <joncol> I can't remember, what's the name of the sort of partial application where you do things like (/=4)?
02:24:50 <piyush-kurur> apes and to a large extent other herd animals have a lot of societal structure
02:24:52 <puregreen> societal pressures to play with toy trucks? probably not
02:24:53 <Rarrikins> joncol: Sections?
02:24:54 <ongy> joncol: a section
02:25:01 <joncol> Ahh, thanks
02:25:14 <lambdamu> there are differences which amount to statistical significance, that doesn't make them a law or suggests that for two individuals the situation can't be completely reversed
02:26:55 <lambdamu> e.g. women dislike open personal confrontation many men do to, but statistically more women do than men
02:27:53 <piyush-kurur> lambdamu: there is no question that there are differences, that there are less women in science, engineering is a fact. No one is questioning that
02:28:06 <piyush-kurur> what people are questioning is the reason
02:28:34 <piyush-kurur> my experience is that it is nurture and not nature
02:28:55 <lambdamu> as with most things it's probably both
02:29:20 <piyush-kurur> I think the nature part, even if it is true is highly overrated
02:29:36 <lambdamu> I think that, too
02:30:17 <lambdamu> most of the difference can be probably attributed to society expecations and stereo types
02:30:25 <ongy> I'd say, that nature makes a huge part of nurture here. If people are at least a bit interested, they will take topics up. If they don't like it at all, they wont. So the nature part may be small to begine with, but makes a big difference
02:31:51 <piyush-kurur> ongy: I think even there the interest comes from societal expectation
02:32:13 <piyush-kurur> for example take the case of students enrolling into various streams in our University
02:32:33 <piyush-kurur> there is a huge demand form Computer science. Why is that the case?
02:32:58 <piyush-kurur> clearly because, to a lot of Indians, computer science means great software jobs
02:33:02 <piyush-kurur> and hence interest.
02:34:02 <piyush-kurur> An equally challenging field is Maths or any of the Sciences
02:34:27 <piyush-kurur> why computer science trumps them all
02:36:17 <Cale> Also note that we ask people to make these decisions about what subject areas to specialise in at a time when the struggle to fit in with one's peers is at perhaps the highest point in their lives.
02:37:06 <piyush-kurur> Cale: yes peer pressure is also an important point
02:38:27 <zomg> I had no idea what to do after elementary school
02:38:37 <zomg> and our school's guidance counselor was useless
02:38:54 <zomg> so I can certainly see that point being quite true :P
02:39:21 <piyush-kurur> zomg: that is true for all, or at least vast majority of the people.
02:39:25 <ongy> Cale: that somewhat depends on the country though
02:39:30 <Cale> ongy: yeah
02:40:03 <Cale> Though not by too much -- there are few countries I can think of when it's significantly later.
02:40:34 <ongy> our school system here is weird either way. But we have a bias at ~14 years, but the first real decision is ~18
02:40:58 <Cale> It's about the same here
02:41:00 <ongy> given that one takes the most straight forward path to uni
02:41:17 <zomg> here the choices are generally around 15 when elementary school ends, and then 17-18 when secondary education ends and you choose if you want to study further (ie. to university or polytechnic)
02:41:35 <akfp`> how can I avoid `A._String` which is part of Aeson.Lens being treated as a "hole" by ghc?
02:41:54 <Cale> akfp`: Make sure it's in scope.
02:42:05 <Cale> Are you sure it's exported?
02:42:46 <lambdamu> at my university there was much talk about how to close the gender gap, truth be told I think by the time people enroll to university the path is already set, interest in technical things has to cultivated at a much earlier stage
02:43:09 <Cale> ah, it seems to be...
02:43:16 <piyush-kurur> lambdamu: I think you are right
02:43:24 <Cale> Maybe make sure that you have the version of that package that you expect...
02:44:10 <piyush-kurur> but we should make every effort to keep the few brave souls who manage to keep the interest feel welcome
02:45:29 <lambdamu> certainly, but I knew quite a few female computer science students and I didn't have the feeling there were any problems they related to their gender
02:45:52 <lambdamu> they had all the same problems as the male students
02:46:23 <lambdamu> some dropped out but not at a higher rate than the males
02:46:25 <zomg> lambdamu: I studied for a business IT degree, before uni level.. we had three women in our class, one dropped out almost immediately, the second a bit later and I think the third just stopped showing up the second year :P
02:46:42 <akfp`> Cale: Seems like there's been a change so it isn't exported.  Thanks.
02:46:46 <zomg> out of about 15-20 men, a few dropped as well
02:47:49 <lambdamu> zomg: hm yeah I guess our experiences are rather anecdotally
02:48:16 <ongy> the main thing I noticed that's gender based is unwanted attention. But that's hard to fix, a pink lamb in between a bunch of black and white lambs will get attention, even if they just want to fit in
02:50:27 <zomg> interestingly enough, at our company we have about same amount as men as we do women
02:51:14 <piyush-kurur> zomg: I think that is a very good situation
02:51:27 <zomg> yeah
02:51:42 <zomg> out of devs, we do have 1 woman only vs 3 men, but then our design team is entirely women
02:52:01 <int-e> Sigh, we're into the third hour of this topic now.
02:52:15 <piyush-kurur> but there is a problem in Science/Engineering
02:52:22 <zomg> int-e: it was a much better discussion than has been had on this topic on a variety of other channels I think ;)
02:52:57 <piyush-kurur> there is no point in just closing our eyes to the problem and pretending it is not there
02:53:16 <zomg> yeah though I guess this should go on -blah or whatever it was =)
02:54:05 <piyush-kurur> I think the question of diversity be it gender or race is a very important meta question that every community should address
02:54:05 <ongy> it's rather off-topic yes
02:54:50 <piyush-kurur> after all diversity is the best insurance against tyranny.
02:55:04 <zomg> obligatory comment about Hitler
02:56:35 <MarLinn> you can never be diverse enough from that one
02:59:42 <akfp`> Cale:  lens-aeson was switched with aeson-lens.  Great that they both export the same modules!
04:09:29 <hsk3> I have this in my foo.cabal:
04:09:33 <hsk3> executable foo
04:09:39 <hsk3>     ghc-options:        -Wall -O2 -fforce-recomp
04:09:49 <hsk3> But running "stack build" doesn't seem to use those options...
04:09:56 <hsk3> I don't get all the warnings I expected to get.
04:09:58 <hsk3> Why not?
04:18:58 <hsk3> Actually, it's the -fforce-recomp that's not working
04:46:58 <mpickering> Probably because stack doesn't use that field in the cabal file? 
04:47:29 <cocreature> stack uses these options
04:47:34 <cocreature> the problem is that it hides the output
04:47:38 <Jenaf> Hi!
04:47:43 <cocreature> hsk3: if you run stack build foo it should show them
04:47:50 <Jenaf> I have some beginners question about the behavior of recursion in haskell
04:47:59 <cocreature> the reason why it hides them is that the output gets messed up if multiple packages are built in parallel
04:48:09 <cocreature> Jenaf: just ask them :)
04:48:16 <Jenaf> I've read that Ghc is quite smart at doing it, but I'm nto sure whether i can get my sieve to run a bit faster
04:48:22 <Jenaf> I'll post a ghist
04:49:16 <Jenaf> https://gist.github.com/anonymous/feaab5b7b689c111980eb5b5a4676bbe
04:50:04 <Jenaf> that should be the Sieve of Eratosthenes 
04:50:17 <Jenaf> (without beautifull indentation, sorry)
04:52:29 <Jenaf> I just started Haskell yesterday so i'm not really used to the indentation stuff
04:53:07 <lyxia> appending stuff at the end of a list like in fst p ++ [head (snd p)] is quite slow
04:53:42 <Jenaf> so It could be better to use : and put it in front?
04:53:57 <lyxia> right
04:54:13 <Jenaf> so head(snd p):(fst p)
04:55:09 <Jenaf> when I tried that code from the gist with a number arround 700k ghc blew up to 3gigs of ram, so i was suspecting that ghc did not really obtimize the recursion perfectly
04:55:10 <lyxia> though perhaps the complexity is dominated by the second part of the algorithm...
04:55:38 <hsk3> cocreature: nah, still not seeing the warnings
04:55:39 <Jenaf> well Sieve of Eratosthenes  isn't the best way of finding primes, but its simple to program
04:55:48 <hsk3> even if i do stack build foo
04:56:24 <Jenaf> still its wierd for that piece of code to blow up that much in memory usage
05:03:30 <Jenaf> would it make a difference to use [x|x<-(tail (snd p)), (mod  x (head (snd p)))/=0] instead of the filter ? (I doubt that)  
05:03:47 <parsnip0> https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
05:04:44 <Jenaf> that looks interesting thank you!
05:04:49 <lyxia> Jenaf: I also don't think so.
05:05:05 <lyxia> Jenaf: you use a lot of superfluous parentheses
05:05:38 <Jenaf> as I said b4 I just started haskell yesterday and superflous parantheses should not make a difference after compilation
05:05:57 <Jenaf> anyway i'll be reading that paper now
05:10:26 <parsnip0> Jenaf: i think i get a parse error input on the comma. 
05:10:58 <Jenaf> the comma is for the pair that the sieve passes arround
05:11:25 <Jenaf> perhaps forcing haskell to stricly apply the filter would speed it up?
05:12:29 <Jenaf> because the filter reduces the size of the list, and maybe the lazyness causes the programm not to reduce the length of the lsit?
05:12:29 <parsnip0> oh yeah, i had a partially edited version
05:13:01 <parsnip0> Jenaf: i'm going to try to trim out the parens, then i'll regist. then, i'll try to see if i can spot the problem. 
05:13:12 <Jenaf> yeah that would be nice
05:13:28 <Jenaf> also I did not use indentation because i kept getting indentation errors
05:13:49 <Jenaf> so i got frstrated, put parans everywhere and wrote it into a single line. (aka ugly code)
05:14:17 <cocreature> hsk3: try cleaning or forcing a rebuild
05:17:44 <parsnip0> Jenaf: https://gist.github.com/bradyt/7db45a92f31b088111be1bcc610545f5
05:18:38 <Jenaf> the $ sign is for strictness?
05:19:00 <Jenaf> and i really have no feeling for operation precedence in haskell yet
05:19:04 <parsnip0> a little cleaner: https://gist.github.com/bradyt/0d75ce0e28ef7e374ab55e61788dafdb
05:19:41 <parsnip0> > (*2) $ 3 + 4
05:19:42 <lambdabot>  14
05:20:07 <Jenaf> (*2)3+4
05:20:11 <parsnip0> Jenaf: the use of dollar here basically says, evaluate all the stuff to the right first. 
05:20:15 <parsnip0> as opposed to: 
05:20:19 <Jenaf> >(*2)3+4
05:20:25 <parsnip0> > (*2) (3 + 4)
05:20:27 <lambdabot>  14
05:20:37 <Jenaf> lambdabot does not seem to like me
05:20:51 <parsnip0> need the space after >
05:21:03 <lyxia> $ is just function application, but with a convenient precedence for nested applications
05:21:13 <parsnip0> see how $ helped me remove parens? 
05:21:14 <lyxia> f $ stuff morestuff is like f (stuff morestuff)
05:21:59 <parsnip0> yeah, $ has lower precedence than "usual". 
05:22:02 <hexagoxel> ($) is not in any way about order of evaluation.
05:22:20 <Jenaf> (head $ snd p):fst p should be a little bit faster?
05:22:22 <hexagoxel> /strictness
05:22:37 <Jenaf> (the order of the primes in the final list would be reversed, but thats not an issue for me
05:22:42 <parsnip0> Jenaf: it doesn't speed it up, it just makes it easier to read imo. 
05:22:44 <piyush-kurur> ping saurabnanda
05:22:52 <Jenaf> ah ok
05:23:03 <parsnip0> once it's easier to read, then we might be able to talk about what is slowing it down. 
05:23:23 <Jenaf> I'm suspecting that the stack is growing unnesecarily
05:24:18 <cocreature> Jenaf: one problem is that you are appending to a list
05:24:24 <cocreature> that’s an O(n) operation if the list has n elements
05:25:28 <Jenaf> cocreature: also when i ran it with a list up to 700k it memory usage got up to 3gigs, so there must be something wrong with the recursion obtimization
05:25:35 <cocreature> oh sorry someone already said that
05:26:05 <Jenaf> I replcaed the ++ with : already:
05:26:07 <Jenaf> ((head (snd p)):(fst p))
05:26:21 <Jenaf> but thats not the main issue
05:26:45 <parsnip0> Jenaf: the paper talks about how for each prime, you are checking every number, rather then just noting what is a multiple of it. 
05:27:06 <Jenaf> yeah;
05:27:20 <parsnip0> in other words, you are running that filter against all that is left, and checking if the mod is not zero. 
05:27:29 <Jenaf> yeah
05:28:52 <Jenaf> still: why does ghc grow to 3gig ram usage when i call it for with bigger lists?
05:29:08 <parsnip0> Jenaf: have you seen this: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Pseudocode
05:29:35 <parsnip0> Jenaf: with bigger lists? 
05:29:40 <Jenaf> yeah
05:30:08 <Jenaf> If I did sieven 700000 it would run too long so I terminated it
05:30:18 <Jenaf> also when I checked my task manager ghc was at 3gigs of ram
05:30:27 <parsnip0> well, as you go to each candidate, let's say you have about 1,000 of them, aren't you checking approximately 1,000 numbers? 
05:30:39 <parsnip0> is that 1,000^2? 
05:30:50 <Jenaf> yeah it's not perfect ^.^
05:31:02 <parsnip0> or is that 1,000^1,000? i always get this mixed up. 
05:31:17 <sm> g'day all
05:31:27 <Jenaf> it should be somewhere O(n*sqrt(n)) or so
05:31:30 <sm> https://github.com/TechEmpower/FrameworkBenchmarks/tree/master/frameworks/Haskell could use more activity
05:31:48 <parsnip0> Jenaf: why sqrt(n)? 
05:32:02 <Jenaf> that was a rough guess
05:32:03 <cocreature> Jenaf: just from a style perspective http://lpaste.net/179253 would be how I would write it (if I would go for the tail recursive version) now looking at memory usage
05:32:23 <Jenaf> propably more like O(n^2) instead of O(n log log n) for a "good" sieve
05:32:44 <Jenaf> still does not really explain why that piece of code needs so much memory
05:33:21 <sm> haskell results: https://www.techempower.com/benchmarks/previews/round13/#section=data-r13&hw=azu&l=8vn073
05:33:28 <parsnip0> Jenaf: ah, and you were saying something about strictness, maybe relates to the wikipedia psuedocode i linked. 
05:33:58 <parsnip0> in that pseudocode, for each prime, they cross out multiples in the fixed-size array. 
05:34:28 <Jenaf> cocreature: you use a lot of syntactical suger I was not aware about
05:34:46 <Jenaf> *sugar
05:34:52 <cocreature> Jenaf: anything that you don’t understand and that I should try to explain?
05:35:05 <Jenaf> I think I got it
05:35:38 <Jenaf> I did not know you could do things like line 3
05:35:42 <parsnip0> Jenaf: (prime:toTest) is pattern matching, so like (x:xs) pattern matches for head and tail. 
05:35:46 <Jenaf> it really makes the code way more readable
05:36:06 <Jenaf> yeah the more I lear about haskell the more I like it XD
05:36:17 <parsnip0> line 2 is pattern matching also. 
05:36:32 <Jenaf> yeah line 2 is basically the abort condition
05:36:45 <cocreature> Jenaf: hm so for 100000 it finishes in less than 20s and needs less than 6mb of memory
05:37:19 <parsnip0> so getting rid of append solved a lot of the problem? 
05:37:21 <Jenaf> so there must have been some obscure mistake in my original code
05:37:36 <Jenaf> only getting rid of append does nto change much in the runtime
05:37:55 <cocreature> Jenaf: could you post the exact program (including a main method) that you are using atm to test memory usage?
05:39:10 <Jenaf> I'm loading the definitins into ghci and then let it show stuff there, so maybee ghci is the problem?
05:39:56 <Jenaf> https://gist.github.com/anonymous/7d1d98cbf19d795d5d7bf6a2e2ad068a
05:40:10 <Jenaf> and then i type list20k into ghci to let it run
05:40:53 <Jenaf> already takes a noticable ammount of time for 20k
05:43:36 <cocreature> hm that’s weird for list20k your version is twice as slow as mine
05:45:13 <Jenaf> perhaps your more beatifull code helps the compiler doing its work?
05:46:40 <cocreature> hm without -O1 or something like that that seems unlikely
05:47:07 <Jenaf> -O1?
05:47:16 <cocreature> that enables optimizations
05:47:27 <Jenaf> isn't that enabled by default?
05:47:37 <cocreature> pretty sure it’s not
05:47:43 <cocreature> especially not in ghci
05:47:44 * hackagebot pinchot 0.22.0.0 - Write grammars, not parsers  https://hackage.haskell.org/package/pinchot-0.22.0.0 (OmariNorman)
05:48:19 <Jenaf> yeah not in ghci, but if I load a file into ghci can I let it run obtimizations in the loading process?
05:48:29 <Jenaf> like :load 003.s -O1
05:49:12 <hexagoxel> optimizations are on by default. ghci does interpret though, no optimizations at all.
05:49:17 <Jenaf> *003.hs
05:49:47 <Jenaf> even if i load files? I was expecting loaded files to be compiled and obtimized and only typed expressions to be interpreted
05:49:49 <hexagoxel> that code shows no bad residency when compiled with optimizations.
05:49:51 <Jenaf> maybe i got that wrong
05:50:53 <hexagoxel> it just seems to do a lot of filtering, with the corresponding mildly high amount of short-term garbage.
05:52:35 <Jenaf> thats to be expected
05:52:52 <Jenaf> but that short-term garbage should not add up to 3gigs or should it?
05:53:10 <daenorks> Hi
05:53:17 <cocreature> Jenaf: how are you measuring memory usage?
05:53:26 <Jenaf> no real measurement
05:53:38 <cocreature> so looking at htop?
05:53:47 <Jenaf> I just ran that code with a list up to ~700k and it did not terminate
05:53:58 <cocreature> well where did you get the 3gig from
05:54:02 <Jenaf> and when i checked my task manager ghc process was at 3gigs ram usage
05:54:04 <parsnip0> oh, 700k, i thought we were doing 20k
05:54:32 <Jenaf> actually the size i wanted to sieve is in the comments at the top
05:54:47 <Jenaf> so in the end I would like primes=sieven limit
05:55:07 <Jenaf> I just commented that part out because i did not think it was important for the main issue
05:55:52 <parsnip0> oh, 600851475143 ?
05:56:09 <parsnip0> oops, sqrt apparently
05:56:27 <Jenaf> the first Int above the sqrt actually
05:57:02 <Jenaf> actually i# trying to solve some projectEuler things as exercise to learn haskell
05:57:11 <parsnip0> ah, you're trying to factor it ;)
05:57:30 <Jenaf> I only need the bigest prime factor
05:57:38 <Jenaf> https://projecteuler.net/problem=3
05:57:50 <Jenaf> so actually the reversed list of primes is quite good in this case
05:58:51 <parsnip0> even if i use the edited versions of your sieve above, i think those numbers will be quite large. 
05:59:39 <Jenaf> yeah that could be the case
05:59:45 <Jenaf> then i would have to rethink my approach
05:59:50 <parsnip0> Jenaf: the ideas from that pdf will teah you about the Data.Map module, which will help with other project euler problems. 
05:59:59 <parsnip0> *teach
06:00:40 <parsnip0> Jenaf: the approach to the pseudocode in the wikipedia link above doesn't quite work with haskell. 
06:00:40 <Jenaf> even with a non-working approach like this one I learn stuff so it's okay to try some things ^.^
06:01:10 <parsnip0> in the pseudocode, for each prime, the remove elements from a fixed-size array. 
06:01:26 <parsnip0> *they remove
06:01:56 <Jenaf> well then I would have a fixed size boolean array and set values to false
06:02:12 <Jenaf> but I have no clue if this really wokrs nicely with haskell
06:02:32 <Jenaf> and then I'd need to walk through that bool list to get the primes
06:02:51 <parsnip0> Jenaf: yeah, problem is, haskell is mostly about immutability. 
06:03:20 <Jenaf> yeah
06:03:41 <parsnip0> so instead of jumping back and forth on the list, they head straight down the list, with a sort of auxiliary list in a handbasket, carrying with them which numbers next to remove. 
06:03:43 <Jenaf> so for each itteration step there would be a new bool list
06:04:17 <parsnip0> the hand basket is the Data.Map, that carries a dictionary of which number to remove next, and which primes it is associated with. 
06:04:39 <parsnip0> so like, when you get to 2, you say, next i will cross out 4, so they add (4, [2]) to the dictionary. 
06:05:28 <parsnip0> when they get to 3, they add (6, [3]) to the hand-basket. (they actually add (9, [3]), but that's another optimization. 
06:05:35 <Jenaf> well I learned quite a bit just now
06:05:47 <parsnip0> sorry, i'm rambling. 
06:05:51 <Jenaf> I'll take a break and rethink my approach later, but thank you a LOT for the help ^.^
06:05:57 <parsnip0> :)
06:06:36 <Jenaf> as I said b4 I just started haskell yesterday, so there is still a LOT to learn
06:07:15 <parsnip0> Jenaf: project euler is an interesting first exercise, do you have prior experience with math or programming/ 
06:07:24 <Jenaf> yes
06:08:15 <Jenaf> studiing computerscience and maths, but I got some depression so I'm not reallymove forward at the moment
06:08:55 <Jenaf> I browsed through the problems a bit and there are soem where i don't even know how to approach them ^.^
06:09:19 <Jenaf> and that is a sign that i can learn a lot by trying
06:09:19 <parsnip0> to get familiar with the syntax of haskell, i found it fun to work through the first few sets at "99 haskell problems". 
06:10:02 <Jenaf> I gotta google that later
06:15:58 <daenorks> Bwa
06:20:16 <sm> Jenaf: to save yourself some time, skim through the haskell language report and Prelude library api
06:20:37 <Jenaf> okay thy
06:22:51 <Jenaf> I could also just download the b file of the OEIS prime number list, but that would feel like cheating ^.^
06:25:21 <parsnip0> there is a way to cheat using haskell ;) but i was forced to read that pdf when i got to other problems that weren't necessarily dealing with primes, but similar issues. 
06:26:12 <parsnip0> Jenaf: are you using stack? cabal-install? haskell-platform? 
06:26:35 <Jenaf> actually i jsut downloaded the thing from the haskell website
06:26:43 <Jenaf> i think it was the platform
06:26:56 <Jenaf> for writing the code I jsut use notpad++, not an ide
06:28:16 <parsnip0> editor sounds good, but i've heard haskell-platform is not recommended. but maybe it's fine for now. 
06:29:05 <lush> hey there! I'd like to play a little bit with implementing a really simple parser combinator. Has anyone got some article/paper that gives an introduction into such a parser?
06:29:35 <Jenaf> It should be fine for now; i'm not doing real projects just excercises
06:31:51 <pavonia> lush: You want to build parsers with a given library, or implement your own parser combinator library?
06:32:01 <lush> my own little library
06:32:02 <buglebudabey> lush http://www.cs.nott.ac.uk/%7Epszgmh/monparsing.pdf
06:32:11 <lush> to get a better understanding on how they work etc
06:32:41 <lush> ty buglebudabey, I'll look into that :)
06:32:45 <buglebudabey> any time
06:33:04 <saurabhnanda> piyush-kurur: there
06:34:01 <piyush-kurur> saurabhnanda: did you get the forms working
06:34:29 <piyush-kurur> I thought yesod did it quite nicely I am not sure why you are having a lot of trouble with it
06:34:44 <saurabhnanda> piyush-kurur: actually I'm not writing any code right now till I get the architecture straight in my head first. I've wasted a lot of time writing and rewriting random code over the past few months.
06:35:11 <saurabhnanda> piyush-kurur: actually in the current exercise I've moved on from Yesod. Trying to build something with Servant now.
06:35:22 <saurabhnanda> piyush-kurur: the trouble with Yesod was Persistent and Hamlet.
06:35:31 <saurabhnanda> piyush-kurur: didn't even get to forms with Yesod.
06:35:35 <piyush-kurur> saurabhnanda: I think you need to get the applicative functor thing straightened out whether you want to use yesod or any other stuff
06:36:02 <piyush-kurur> it is quite basic (despite the name from category theory)
06:36:12 <saurabhnanda> piyush-kurur: I thought it was digestive-functor
06:36:45 <piyush-kurur> digestive-functor is the name of a package to deal with forms and may be other things (I am not sure)
06:37:00 <piyush-kurur> but the idiom is applicative functors.
06:37:17 <piyush-kurur> captured by the type class Applicative in Haskell
06:37:31 <saurabhnanda> piyush-kurur: applicative-functor is the same as applicatives, right?
06:37:40 <piyush-kurur> yes that is correct
06:37:53 <piyush-kurur> we can go step by step on this if you want
06:38:03 <saurabhnanda> piyush-kurur: if yes, then I understand it. It's a generalization of fmap to functions with multiple arguments (more than one)
06:38:11 <piyush-kurur> Exactly
06:39:02 <saurabhnanda> piyush-kurur: actually, that was not my initial (2 months ago) problem with Yesod Forms, when I first read them.
06:39:23 <saurabhnanda> piyush-kurur: it was the statement in the book -- that we have three kinds of forms. Applicative, Monadic, and Input.
06:39:37 <saurabhnanda> And I was like, what? How can **forms** be applicative and/or monadic?
06:39:50 <saurabhnanda> now that I'm reading it more carefully, I realize that an important term is probably missing.
06:40:05 <saurabhnanda> The DATA STRUCTURE representing the form is an applicative or a monad. Right?
06:40:35 <piyush-kurur> You are mostly correct.
06:40:48 <zomg> iirc those different types mostly affects how heavily you can customize the form :)
06:40:56 <zomg> though might be wrong since it's been a while since I touched yesod
06:40:58 <piyush-kurur> correct again
06:41:22 <piyush-kurur> but you can use applicatives with your other pet problem (handling Maybe's)
06:41:25 <saurabhnanda> piyush-kurur: why mostly correct?
06:42:01 <saurabhnanda> piyush-kurur: have you tried yesod's forms for nested data structures?
06:42:31 <saurabhnanda> piyush-kurur: something very simple. User profile that can have multiple contact (phone, email, address)
06:42:39 <saurabhnanda> piyush-kurur: does it handle the nesting easily?
06:42:47 <piyush-kurur> Mostly because there is some magic inside it that I do not fully understand. 
06:43:06 <saurabhnanda> piyush-kurur: how is the nesting represented in terms of HTML input names?
06:43:17 <piyush-kurur> I do not see a problem with using applicative forms with nested types
06:43:43 <piyush-kurur> My advise would be to build it as have a look
06:44:24 <saurabhnanda> piyush-kurur: I'm going to try with digestive-functors now, which seems to have the same approach as Yesod. (please correct me if I'm wrong)
06:44:43 <saurabhnanda> also, this exercise about validations uncovered a HUGE difference in this approach and Rails approach
06:44:58 <piyush-kurur> I am less familiar with digestive-forms but I think yes it is mostly the same apporach
06:45:35 <piyush-kurur> infact I think cronologicaly digestive-functors came first
06:45:53 <piyush-kurur> and was an inspiration for yesod
06:46:08 <saurabhnanda> in Rails, the incoming request is deserialised to a Ruby hash. An ActiveRecord model is instantiated taking the Ruby Hash as the data source. This can result in a in-memory Object which is actually invalid. The actual validation is done when you try saving it to the DB (usually). And the errors are added to the object itself.
06:46:30 <piyush-kurur> saurabhnanda: Just hang on before you jump into digestive-functors there is one another thing that I wanted to say
06:46:50 <saurabhnanda> so, Rails allows you to create an in-memory domain record/object which is actually incorrect.
06:47:03 <saurabhnanda> In Haskell, that is actively discouraged.
06:47:19 <piyush-kurur> and that is a good thing dont you think
06:47:43 <saurabhnanda> The validation is done at the parsing level itself (via libraries such as digestive functors). ONLY IF the validations pass is the domain model created. Else is results in a related data-type (not the core domain type) which marries the user-input along with the validation errors.
06:47:49 <saurabhnanda> Took some time to wrap my head around this difference.
06:48:13 <piyush-kurur> Not all validation needs to be at the parsing level
06:48:19 <sm> these are called domain model and view model in OO, no ?
06:48:46 <saurabhnanda> sm: yes -- but view-model typical in JS libraries. Not so much in Rails.
06:48:55 <saurabhnanda> piyush-kurur: examples?
06:48:56 <piyush-kurur> see the example of `checkBool (>18) "you need to be an adult" intField
06:49:23 <piyush-kurur> Here the parsing is done by the intField and then the checkBool does additional validation
06:50:33 <saurabhnanda> piyush-kurur: referring to https://www.reddit.com/r/haskell/comments/4yr1a2/call_for_help_trying_to_make_building_webapps/d6qinde
06:50:33 <saurabhnanda> ?
06:50:34 <piyush-kurur> well I am not sure about the view-model idea as all validation is done on the serverside 
06:51:45 <saurabhnanda> piyush-kurur: can you elaborate your previous comment?
06:51:51 <mniip> can I bring an instance out of scope in ghci?
06:52:01 <saurabhnanda> piyush-kurur: not all validation needs to be done at parsing level? Isn't that the design-pattern actively encouraged in Haskell
06:52:15 <saurabhnanda> basically DO NOT instantiate invalid/incorrect domain models.
06:52:21 <piyush-kurur> Well  I am not sure what you mean by parsing
06:52:33 <saurabhnanda> or, make incorrect states irrepressentable in code
06:52:47 * hackagebot hpc-coveralls 1.0.5 - Coveralls.io support for Haskell.  https://hackage.haskell.org/package/hpc-coveralls-1.0.5 (killy971)
06:53:01 <piyush-kurur> for me parsing here means detecting whether the input is of the right type or not
06:53:01 <saurabhnanda> piyush-kurur: parsing a POST key/value pair to a nested record, for example. That's parsing. Requires quite some logic if you think about it.
06:53:23 <saurabhnanda> piyush-kurur: okay. You are correct, technically/pedantically.
06:53:30 <saurabhnanda> piyush-kurur: I'll rephrase.
06:53:56 <saurabhnanda> piyush-kurur: All validations should be done BEFORE a domain-model is instantiated.
06:53:56 <piyush-kurur> saurabhnanda: you can add your nested form as a field if you want
06:54:02 <piyush-kurur> does it not work
06:54:28 <saurabhnanda> piyush-kurur: I'll find out in a day or two, as soon as I complete the design/spec phase and start writing the code.
06:54:40 <piyush-kurur> saurabhnanda: I am not really into webframeworks so I do not understand what a domain-model is
06:54:54 <piyush-kurur> although I have written some RoR and a bit of Yesod
06:55:09 <saurabhnanda> so, have I understood the core difference wrt validations in Haskell and Rails?
06:55:58 <saurabhnanda> In Haskell, any large-scale web-app will have some interim data-types to represent user-input and form validations. ONLY IF the user-input is valid, is this interim data-type converted to a domain model.
06:56:00 <piyush-kurur> saurabhnanda: I do not understand whether you understood ;-)
06:56:17 <saurabhnanda> ^ just typed out my understanding :)
06:56:37 <piyush-kurur> My suggestion is not to really worry about the internals yet (they are hairy)
06:56:48 <piyush-kurur> Think of it at the abstract level
06:57:29 <piyush-kurur> let me try to motivate using IO instead of forms
06:57:53 <piyush-kurur> start by defining a basic propt function
06:59:00 <saurabhnanda> propt
06:59:02 <saurabhnanda> ?
06:59:07 <piyush-kurur> > ask prompt = do putStr prompt; read <$> getLine
06:59:08 <lambdabot>  <hint>:1:12: parse error on input ‘=’
06:59:48 <piyush-kurur> I meant an ask function which prints a prompt and reads an input
07:00:04 <sm> "Haskell" doesn't mandate any of this. It's common practice to favour using different types to represent different things, but there's no reason a haskell web framework can't do it like rails does
07:00:06 <saurabhnanda> piyush-kurur: okay, then?
07:00:22 <piyush-kurur> let me try with lambdabot again
07:00:38 <piyush-kurur> > let ask prompt = do putStr prompt; read <$> getLine
07:00:40 <lambdabot>  <no location info>:
07:00:40 <lambdabot>      not an expression: ‘let ask prompt = do putStr prompt; read <$> getLine’
07:00:52 <piyush-kurur> sorry does not work
07:00:59 <saurabhnanda> sm: I want to learn the Haskell way. The way that will let me harness its type-safety. I do NOT want to replicate Rails in Haskell.
07:01:03 <piyush-kurur> but try it in your ghci
07:01:13 <sm> ok
07:01:14 <riaqn> Hi, I 'm using nix with stack; but when I "stack build", the dependencies is still built by stack, instead of downloaded by nix. Is it how it supposed to be?
07:01:20 <dinnu93> Did anybody use bloodhound ?
07:01:44 <piyush-kurur> saurabhnanda: private message  or do you want to continue on #haskell
07:01:49 <piyush-kurur> ?
07:02:01 <daenorks> Can someone explain to me this : fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
07:02:05 <saurabhnanda> I'm fine on #haskell unless others are getting disturbed.
07:02:23 <riaqn> daenorks: first of all, haskell is lazy.
07:02:34 <daenorks> I know
07:02:50 <riaqn> daenorks: then, the first two elements is that list is 0 and 1
07:03:02 <daenorks> Ok
07:03:04 <saurabhnanda> daenorks: does this help ==> fibs = 0 : 1 : zipWith (\x y -> x + y) fibs (tail fibs) 
07:03:16 <saurabhnanda> daenorks: and do you understand how zipWith works?
07:03:31 <daenorks> Nop
07:03:31 <saurabhnanda> > zipWith (\x y -> x + y) [1, 2, 3] [4, 5, 6]
07:03:32 <lambdabot>  [5,7,9]
07:03:48 <daenorks> Hein
07:03:51 <saurabhnanda> see if you can understand what I just did there.
07:04:05 <daenorks> But tail is all the element except the first one?
07:04:13 <riaqn> daenorks: yes, exactly.
07:04:32 <riaqn> so you will get a list where the first element is fib[0]+fib[1], the second is fib[1]+fib[2]
07:04:36 <riaqn> and so on.
07:04:49 <riaqn> append this list after 0:1, you get the fib.
07:05:16 <riaqn> (although I don't think 0 belongs to fib, but that's details)
07:05:19 <saurabhnanda> daenorks: pick up a pen & paper and try working it offline. That's one way to grasp it.
07:06:10 <daenorks> Humm but tail send all except the first one so after it will do 1+1+2+4
07:06:14 <daenorks> No?
07:06:48 <daenorks> I understand everything except that tail give only two numbers
07:07:36 <saurabhnanda> daenorks: rephrase your last statement please
07:07:54 <dinnu93> In The first example of bloodhound docs it says => let testServer = Server "http://localhost:9200"
07:08:08 <dinnu93> But If I run it, it's saying that it expects the argument of Server to be of type Text
07:08:23 <dinnu93> Can somebody please explain to me what's wrong with the documentation of bloodhound ?
07:09:00 <daenorks> Tail send all except the first element so it add all the element except the first one not just the two last??
07:09:28 <Rarrikins> daenorks: It only adds one item from each list at a time.
07:10:08 <daenorks> Heinnn
07:10:19 <daenorks> I understand I think
07:11:12 <daenorks> Thx
07:14:04 <saurabhnanda> daenorks: you'll understand only if you understand zipWith first.
07:31:30 <Schrostfutz> Hi, I want to write a function using the bind operator instead of do. However, I get error messages about missmatching types. This is my attempt: http://sprunge.us/IKiX?hs
07:32:25 <mpickering> That's nearly right
07:32:39 <Rembane> Schrostfutz: Add more brackets! :D
07:33:08 <mpickering> Or you just need to change 1 character
07:34:57 <Schrostfutz> I tried some changes but none of them worked. Where would I add brackets/which character needs to be changed?
07:35:09 <Rarrikins> Schrostfutz: In general, you shouldn't have a $ (b . c) d. You should use a . b . c $ d.
07:35:37 <Rarrikins> Schrostfutz: You have all the functions you're applying separated by dots, then a dollar sign, then the value you're applying the functions to.
07:36:34 <Schrostfutz> Rarrikins: Ah, I see. I still think of return as some kind of special keyword but it's just a function...
07:36:34 <mauke> Schrostfutz: many1 digit >>= \digs -> return (Number (read digs))
07:36:51 <mauke> Schrostfutz: many1 digit >>= return . Number . read
07:37:00 <Schrostfutz> My version is now: many1 digit >>= return . Number . read
07:37:06 <mpickering> perfect
07:37:08 <mauke> Schrostfutz: (Number . read) <$> many1 digit
07:37:41 <Schrostfutz> What does the <$> operator do?
07:38:01 <ahsfhyicxv> <$> = flip fmap
07:38:41 <Schrostfutz> So it maps the value on the right using the functor on the left?
07:39:24 <mpickering> It's just an infix version of fmap
07:39:31 <mpickering> f <$> a = fmap f a
07:39:39 <ahsfhyicxv> I'm sorry <$> = fmap
07:40:07 <Schrostfutz> Alright, thank you all
07:47:49 * hackagebot hscaffold 0.3.0.0 - Very simple file/directory structure scaffolding writer monad EDSL  https://hackage.haskell.org/package/hscaffold-0.3.0.0 (yamadapc)
07:59:13 <Ford_Prefect> Hello. Is there a way for me to use a "local" version of a package while doing a stack build? There's a package (c-dsl) which has stale deps in its .cabal file, and I'd like to be able to use it locally while (hopefully) someone upstream reviews my PR to update it.
08:00:22 <lyxia> Ford_Prefect: yes you can add the path to your local version to extra-deps.
08:00:37 <Ford_Prefect> lyxia: Oh, sweet. Just specify the full path?
08:00:45 <Ford_Prefect> (also upsteram merged the PR already, yay)
08:00:46 <lyxia> oh no, it's in packages
08:01:00 <ongy> what's the lambdabot syntx for do notation?
08:01:08 <ongy> do { x; y; z; }?
08:02:11 <lyxia> Ford_Prefect: relative paths also work, though I'm not sure what they should be relative to
08:02:34 <Ford_Prefect> lyxia: sweet, at least absolute path worked. Thank you!
08:02:49 <lyxia> great, you're welcome
08:03:16 <Ford_Prefect> (relative to top level dir also worked too, jfyi)
08:08:18 <mauke> ongy: lambdabot just runs haskell
08:08:24 <mauke> it has no special syntax
08:29:32 <parket> @undo
08:29:32 <lambdabot> Error: expected a Haskell expression or declaration
08:29:47 <parket> @undo do 1; 2
08:29:47 <lambdabot> 1 >> 2
08:29:50 <parket> @undo do 1; 2; 3
08:29:50 <lambdabot> 1 >> 2 >> 3
08:51:52 <Welkin> what!
08:52:03 <Welkin> cpan lets you download epub or mobi files of the docs!
08:52:16 <Welkin> why don't we have that?
08:52:37 <mauke> oh, so that's what those links are for
08:53:19 <hpc> what if haddock used pandoc to output documentation?
08:53:44 <Welkin> you could just feed the html into pandoc and get epub
08:54:21 <Welkin> I often read docs on my phone when trying to figure out how to use something
08:54:49 <monochrom> Why don't we have that? I'll tell you an Aesop tale to explain why.
08:56:21 <monochrom> A group of mice were getting cracked down by a cat real hard. The group discussed countermeasures. Eventually, one mouse said, if we tie a bell on the cat's neck, then we'll get early warning. And everyone was like, great idea, why don't we already have that?!
08:58:10 <hpc> what a great aesop, why hasn't it already been told here?
08:58:47 <monochrom> :)
08:59:27 <riaqn> .stack-work/dist/x86_64-linux-nix/Cabal-1.22.5.0/build/Language/Haskell/Exts/Annotated/Syntax.dyn_hi: hPutBuf: resource exhausted (No space left on device)
08:59:35 <mauke> we should just use cpan instead of hackage
08:59:37 <riaqn> anyone know what it means?
08:59:45 <hpc> riaqn: i think your device needs more space ;)
08:59:50 <glguy> It means:  (No space left on device) 
08:59:59 <monochrom> "No space left on device" do you know it means disk full?
09:00:03 <hpc> riaqn: what's 'df -h' say?
09:00:20 <riaqn> I have 10Gb free disk space.
09:00:30 <riaqn> I'm not that stupid, haha.
09:00:32 <mauke> df -i?
09:00:34 <monochrom> This is why my theory is that humans have mental blocks on error messages.
09:00:56 <riaqn> inode is abundant too.
09:00:59 <hpc> mauke: inodes
09:01:04 <int-e> sometimes it's not the hard disk drive but some tmpfs
09:01:08 <hpc> inodes are aaaaaaaaalmost never the problem
09:01:08 <monochrom> Yeah, 10Gb is great, but how much do you have left?
09:01:27 <int-e> monochrom: come on, they said "free".
09:01:38 <monochrom> oh oops, I misread, sorry.
09:01:40 <parket> @undo do a <- val 1; a += b
09:01:40 <lambdabot> val 1 >>= \ a -> a += b
09:01:44 <mauke> hpc: has happened twice to me before
09:01:58 <parket> @undo do a <- val 1; b <- val 2
09:01:58 <lambdabot> <unknown>.hs: 1: 26:Parse error: Last statement in a do-block must be an expression
09:02:09 <riaqn> int-e: which tmpfs do you suspect?
09:02:09 <parket> @undo do a <- val 1; b <- val 2;
09:02:09 <lambdabot> <unknown>.hs: 1: 27:Parse error: Last statement in a do-block must be an expression
09:02:16 <parket> @undo do a <- val 1; b <- val 2; a+b
09:02:16 <lambdabot> val 1 >>= \ a -> val 2 >>= \ b -> a + b
09:02:41 <riaqn> int-e: /tmp is only 300M, which may be the problem. But I don't know if "stack build" use /tmp?
09:02:46 <int-e> riaqn: /tmp if it is a tmpfs.
09:02:51 * hackagebot polar-shader 0.2.0.0 - High-level shader compiler for Polar Game Engine  https://hackage.haskell.org/package/polar-shader-0.2.0.0 (Shockk)
09:03:05 <monochrom> stack and cabal-install and ghc use /tmp all the time.
09:03:16 <hpc> riaqn: in general, assume literally everything on a linux box uses /tmp
09:03:27 <int-e> I believe they respect TMPDIR though.
09:03:30 <monochrom> or whatever your $TMP environment variable says, but the default is /tmp
09:03:36 <mniip> hey int-e
09:03:38 <hpc> the list of things that don't consists of the bare simplest of utilities and some very rare larger exceptions
09:03:45 <riaqn> monochrom: hpc: thanks, I will try to enlarge the /tmp
09:03:47 <Ford_Prefect> Probably a silly question. I'm using c-dsl which uses OverloadeadStrings. I'm seeing some odd behaviour w.r.t. code in my file vs. a repl
09:03:51 <Ford_Prefect> http://hastebin.com/ezojukopaj.hs
09:04:26 <parket> @undo do a <- val 1; b <- val 2; a+=b
09:04:26 <lambdabot> val 1 >>= \ a -> val 2 >>= \ b -> a += b
09:04:43 <parket> @undo do a <- val 1; b <- val 2; a+=b; a += a
09:04:43 <lambdabot> val 1 >>= \ a -> val 2 >>= \ b -> a += b >> a += a
09:05:39 <monochrom> on ubuntu, /tmp is on a physical disk by default, but /run is tmpfs
09:05:54 <implementation_> Ford_Prefect: in the file i don't see any usage of OverloadedStrings
09:06:12 <hpc> monochrom: weird, does it at least have a "delete old things" job?
09:06:22 <Ford_Prefect> implementation_: c-dsl provides a fromString to create a CDeclr
09:06:41 <monochrom> yes, IIRC at boot
09:06:47 <Ford_Prefect> implementation_: so in my case, name is a String, but should be converted to a CDeclr in line 13
09:06:49 <hpc> that's terrible
09:07:05 <hpc> i can't think of a reason to have /tmp be disk-backed when it's already backed by swap
09:07:06 <implementation_> Ford_Prefect: OverloadedStrings is only about literals. I don't see any literals there
09:07:38 <Ford_Prefect> implementation_: ah, I see. It worked in the repl because the underlying thing was a literal.
09:07:39 <monochrom> I can. ghc.
09:07:57 <Ford_Prefect> implementation_: I guess I need to figure out how to do that conversion explicitly in code
09:08:12 <implementation_> Ford_Prefect: it's as simple as calling "fromString" explicitely
09:09:08 <implementation_> replace "name" with "fromString name" and it works
09:10:20 <Ford_Prefect> implementation_: works, thanks :)
09:15:41 <Welkin> does anyone run ALSA on macos?
09:16:01 <riaqn> after enlarging the /tmp, the error still.
09:16:25 <riaqn> and I found /tmp is not used at all during 'stack build'.
09:16:38 <riaqn> .stack-work/dist/x86_64-linux-nix/Cabal-1.22.5.0/build/Language/Haskell/Exts/Annotated/Syntax.dyn_hi: hPutBuf: resource exhausted (No space left on device)
09:16:42 <riaqn> still the error.
09:18:54 <monochrom> then I don't know
09:19:19 <riaqn> nevermind, I use TMPDIR and now it's using /tmp. I hope it will work.
09:20:25 <riaqn> but still curious which directory it uses by default.
09:20:54 <monochrom> maybe -v3 tells
09:23:19 <riaqn> monochrom: hmm, buildir=.stack-work/...
09:23:48 <riaqn> which is relative to the stack project path, which is on disk.
09:23:50 <riaqn> then it's wierd
09:24:14 <Rembane> riaqn: Is /tmp a ramdisk?
09:24:38 <Rembane> riaqn: Or something like that, => it uses RAM space instead of HDD space?
09:24:51 <riaqn> Rembane: yes, /tmp is tmpfs.
09:25:07 <riaqn> monochrom: nevermind, builddir is not related.
09:27:19 <int-e> riaqn: how did you check whether /tmp was being used?
09:27:46 <int-e> for me, ghc creates some /tmp/ghcNNNN subdirectories while working, and cleans them up when done.
09:27:53 * hackagebot irc-dcc 2.0.0 - A DCC message parsing and helper library for IRC clients  https://hackage.haskell.org/package/irc-dcc-2.0.0 (JanGerlinger)
09:28:19 <riaqn> int-e: yes, there is stack123 and ghc123 
09:28:51 <riaqn> int-e: because I'm set TMPDIR=/tmp now. otherwise I can't find where it's being built.
09:31:32 <mniip> instance LiftClass Show [] where liftClass = sub Dict
09:31:38 <mniip> I remember seeing this somewhere :p
09:32:05 <glguy> http://hackage.haskell.org/package/constraints-0.8/docs/src/Data-Constraint-Lifting.html#line-67
09:32:10 <mniip> yup
09:32:28 <mniip> except I basically just implemented my own
09:32:33 <mniip> using instance dictionaries
09:33:14 <lpaste> mniip pasted “fancy stuff” at http://lpaste.net/179315
09:34:18 <mniip>  > given (BoundedDict 'a' 'z') minBound :: Char
09:34:18 <mniip> 'a'
09:34:20 <mniip> :D
09:37:51 <mniip> aha
09:38:31 <mniip> nope, still crashes without -fobject-code
09:42:50 <Hi-Angel> Have anybody profiled haskell code? I'm wondering, why ".prof" file shows "inherited time" for a column "87.5%" in sum. How do they count? D:
09:43:19 * Hi-Angel searches in pockets the lost 12.5%
09:45:51 <Rotaerk> hmm I need a Map-like data structure that can be modified by multiple threads; suggestions?
09:46:32 <AleXoundOS_> Hi-Angel, maybe try to look for answers here: https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/profiling.html http://book.realworldhaskell.org/read/profiling-and-optimization.html http://stackoverflow.com/a/3276557/1663197
09:47:03 <Rotaerk> I mean of course I could IORef (Map k v) but that would essentially lock the entire map while one thread is modifying it, whereas if multiple threads are modifying different parts of it, they should be able to do so in parallel
09:47:25 <Hi-Angel> AleXoundOS_: unless you could point the exact line, I don't know what to look there. I have at least two of the links opened in the browser.
09:47:52 <ertesx> Rotaerk: i've used this in the past:  TVar (Map k (TVar v))
09:48:22 <ertesx> Rotaerk: once you get the inner TVar, you can modify the value without locking the entire map
09:48:33 <Rotaerk> hmm in this case I think the primary modification will be adding/removing, not modifying existing elements
09:48:37 <Hi-Angel> Rotaerk: actually, all the links opened :Ь
09:48:40 <ertesx> structural changes still lock the map, though
09:48:49 <AleXoundOS_> Hi-Angel, ok, sorry then, I'm not confident in this question neither, someone more experienced will answer here
09:48:53 <Hi-Angel> Opps 
09:48:54 <Hi-Angel> Sorry
09:48:57 <Hi-Angel> wrong name
09:49:18 <ertesx> Rotaerk: if you can somehow split your map into "locking zones", use one map for each
09:49:54 <Rotaerk> hmm
09:51:03 <Rotaerk> this will basically just be a Map ID Window
09:51:06 <ertesx> Rotaerk: also evaluate whether it's worth the hassle…  most Map updates are O(log n)
09:51:16 <Rotaerk> every time a window is created it needs to register itself into the map
09:51:27 <Rotaerk> yea I guess I'll just use IORef (Map k v)
09:52:52 <ertesx> Rotaerk: random question: do you need the Map at all?
09:54:42 <Rotaerk> I'm making a proof-of-concept where one thread is running a GUI, and another thread is reading standard input.  I can enter commands like create (to create a window and display its ID through stdout), or send <id> <text> to set the text of a label on the window with the specified ID
09:54:56 <Rotaerk> so I'd need a mapping from ID to the window that should be updated
09:55:21 <mynigga> ji
09:55:23 <mynigga> hi
09:55:55 <ertesx> Rotaerk: sounds like you need a Map, but so far nothing indicates that you need it from multiple threads
09:56:17 <Rotaerk> hmm true, I guess it's just one thread writing and the other reading
09:56:20 <Welkin> a distributed, cloud-based Map
09:56:41 <Welkin> sharded over servers in every timezone for reduced latency
09:56:49 <ertesx> Rotaerk: maybe your Map is just local state of one thread…  in that case i'd use recursion or StateT
09:57:00 <cocreature> Rotaerk: there is an stm-containers package on hackage that contains maps that minimze locking
09:57:15 <ocramz> hullo
09:57:35 <ocramz> why do missing instances result in runtime errors and not compile-time errors?
09:57:47 <mniip> do they?
09:57:58 <Welkin> has anyone worked with jack/alsa?
09:58:01 <ertesx> ocramz: do you have deferred type errors enabled?
09:58:08 <Rotaerk> thanks
09:58:08 <ocramz> missing methods in instances, I should say
09:58:20 <mniip> they can be made such
09:58:21 <Welkin> are there any good guides to learn how they are used and why?
09:58:22 <mniip> iirc
09:58:29 <mniip> {-# MINIMAL #-} pragma
09:58:30 <Rotaerk> can't think of how I'd represent it as a StateT here
09:58:53 <ertesx> Rotaerk: you probably have a REPL loop of some sort in the stdio thread
09:59:36 <ertesx> you can either use a recursive function with the state as an argument, or you can use StateT, which is basically the same thing
09:59:40 <Rotaerk> the stdio thread needs to fire an event on the GUI thread, so it needs access to the window itself, I think
09:59:46 <Rotaerk> hmm
09:59:51 <ertesx> it has that access
09:59:56 <Jenaf> cocreature: I realized that my non-perfect sieve would terminate in a reasonable time for 120k and then I just wrote a imple factorisation function and that actually got my the solution i needed without the need for further optimization tricks
10:00:05 <Rotaerk> oh right, the dictionary COULD exist solely on the stdio thread...
10:00:12 <ertesx> Rotaerk: the point is that the stdio thread is the only thread that actually needs the overall map
10:00:13 <Jenaf> yay
10:00:16 <ocramz> mniip : {-# MINIMAL #-} is used when one defines a class; I'm just writing Num instances and the like, and it barfs on a missing fromInteger
10:00:17 <ertesx> Rotaerk: exactly
10:00:21 <ongy> is there a way to wait for POLL-style HUP signal in haskell? like read/write have the threadWait*
10:00:24 <cocreature> Jenaf: nice :)
10:00:34 <Jenaf> hehe
10:00:40 <ocramz> I was surprised
10:00:46 <mniip> ocramz, it should be a compile-time warning
10:01:04 <cocreature> it is with -Wall at least, not sure if it is in the default warning set
10:01:18 <ocramz> mniip: I'm on ghc 8.0.1 . What flags do I need?
10:01:24 <mniip> none
10:01:44 <mniip> well, perhaps -Wmissing-methods but that is the default here
10:01:55 <ocramz> uhm. Then I'm really puzzled
10:02:52 <Jenaf> cocreature: https://gist.github.com/anonymous/9334679ad93df833b2d7bc5af8d1271d
10:02:54 <ertesx> ocramz: which class is it?  the compiler can get confused about what constitutes a minimal complete definition, so it doesn't necessarily warn you that you're missing members
10:03:00 <mniip> Prelude> instance Num ()
10:03:00 <mniip> <interactive>:1:10: warning: [-Wmissing-methods] • No explicit implementation for ‘+’, ‘*’, ‘abs’, ‘signum’, ‘fromInteger’, and (either ‘negate’ or ‘-’) • In the instance declaration for ‘Num ()’
10:03:09 <Jenaf> here is my solution; I just tried it and it actually factorized the number
10:03:16 <ertesx> ocramz: the problem is that it indeed doesn't *know* that you're missing members…  in that case it's a bug in the type class
10:03:33 <cocreature> Jenaf: you typically don’t use tuples as function arguments but instead use currying and multiple arguments
10:03:38 <Jenaf> also a little bit more pretty code than this morning
10:03:53 <cocreature> so simplePrimeChecker :: Int -> [Int] -> [Int] -> (Int,[Int],[Int])
10:04:12 <Jenaf> cocreature: i guess, but the signatures are easier to write with tuples lol
10:04:24 <cocreature> you’ll get used to it :)
10:04:27 <Jenaf> does it make a huge difference in runtime or mem usage?
10:04:53 <mniip> a lot of tiny things can make ram usage explode
10:04:56 <cocreature> the main reason why we do this is that you can partially apply your functions
10:04:58 <mniip> such is haskell
10:05:27 <Jenaf> well it worked so I'm happy for now
10:05:46 <Jenaf> also list120k cointains the solution to ProjectEuler #7 XD
10:10:20 <mniip> @tell edwardk have you considered class Lifting c d f | c f -> d where lifting :: d a :- c (f a); instance Lifting (Lifting (Lifting Show Show) (Lifting Show Show)) Show WriterT
10:10:20 <lambdabot> Consider it noted.
10:11:09 <niluje> in a do block, what's the correct syntax for a case? http://pastebin.com/AS0wuLWj
10:11:24 <niluje> here, "putStrLn name return []" gives three arguments to putStrLn
10:11:43 <mniip> otherwise -> do
10:11:55 <mniip> also usually you use _, not otherwise
10:11:57 <niluje> here, "putStrLn name return []" gives three arguments to putStrLn
10:11:59 <niluje> oops
10:12:02 <Welkin> niluje: case f a of D b -> b ...
10:12:03 <niluje> nice
10:12:05 <niluje> ok
10:12:09 <niluje> hm
10:12:41 <niluje> when doing otherwise -> do, is it the same "monad" (the concept is still blurry to me) than the one I'm working on outside the case block?
10:12:47 <mniip> yes
10:12:53 <Welkin> `otherwise` is a synonym for `true`
10:12:57 <Welkin> only used in guards, not case
10:13:13 <mniip> yeah when used in a case it is bound to a different value
10:13:18 <mniip> which might end up confusing later
10:13:18 <Welkin> okay
10:13:35 <niluje> what
10:13:37 <niluje> :D
10:13:40 <c_wraith> niluje: there's nothing special about do blocks.  They just infer their type from context.
10:13:46 <c_wraith> > do ()
10:13:47 <lambdabot>  ()
10:13:55 <Welkin> niluje: do is just syntax sugar
10:14:00 <c_wraith> niluje: they don't even need to infer a monadic type
10:14:04 <Welkin> niluje: learn how to write without using do-blocks to udnerstand them
10:14:11 <Welkin> understand*
10:14:43 <max3> in `data Tree a = Tip | Node a (Tree a) (Tree a)` is it correct to say that the type constructor is parametrically polymorphic or that the type is parametrically polymorphic 
10:14:47 <niluje> I think I understand them
10:14:53 <Welkin> `a <- ma; print a` is the same as `ma >>= print`
10:15:01 <niluje> but when thinking about it, the _ -> do ... makes totally sense
10:15:40 <niluje> I guess the value of _ is a "list" of actions to run in the monad (not sure to use the correct vocabulary)
10:15:41 <Welkin> er
10:16:09 <Welkin> `a <- ma; print a` is the same as `ma >>= \a -> print a`
10:16:51 <Welkin> although that should be the same anyway
10:17:06 <Welkin> :t Just 3 >>= \a -> print a
10:17:07 <lambdabot>     Couldn't match type ‘IO’ with ‘Maybe’
10:17:07 <lambdabot>     Expected type: Maybe ()
10:17:08 <lambdabot>       Actual type: IO ()
10:17:18 <Welkin> :t Just 3 >>= \a -> return . print $ a
10:17:19 <lambdabot> Maybe (IO ())
10:17:24 <Welkin> lol
10:17:34 <mniip> Welkin, what's the most complex-kinded but still practical datatype can you come up with
10:17:55 * hackagebot xdcc 1.1.0 - A wget-like utility for retrieving files from XDCC bots on  IRC  https://hackage.haskell.org/package/xdcc-1.1.0 (JanGerlinger)
10:18:00 <Welkin> mniip: no idea
10:18:35 <Welkin> :t (3 :: IO Int) >>= \a -> print $ a
10:18:36 <lambdabot>     No instance for (Num (IO Int)) arising from the literal ‘3’
10:18:36 <lambdabot>     In the first argument of ‘(>>=)’, namely ‘(3 :: IO Int)’
10:18:36 <lambdabot>     In the expression: (3 :: IO Int) >>= \ a -> print $ a
10:19:31 <Welkin> :t Just 3 >>= \a -> return $ 3 + a
10:19:32 <lambdabot> Num r => Maybe r
10:19:41 <Welkin> > Just 3 >>= \a -> return $ 3 + a
10:19:42 <lambdabot>  Just 6
10:19:43 <Welkin> let's go with that
10:19:52 <Welkin> damn IO
10:20:16 <Welkin> > Just 3 >>= return . (+3)
10:20:18 <lambdabot>  Just 6
10:22:11 <Welkin> mniip: I don't do crazy type stuff like some of you do
10:22:13 <Welkin> why so you ask?
10:22:18 <Welkin> do*
10:33:12 <xuxu> is there a websockets library similar to channels in elixir's phoenix framework? with channels you get 1. client connection recovery 2. routing traffic (topics + events) 3. multiplexiingserver processes on a single concrete connection (channels) 4. client crash notification/recover when a process on the server crashes 5. possible support for more than one WS transport, such as a long polling fallback 6. pubsub integration on the server 7. origin checking 8. pr
10:36:28 <bibiion> Hi all
10:38:05 <max3> :info (->)
10:38:14 <max3> :t (->)
10:38:16 <lambdabot> parse error on input ‘->’
10:38:24 <Welkin> -> doesn't have a type
10:38:35 <Welkin> er...
10:38:38 <max3> that's not true
10:38:50 <mniip> (->) is not a value
10:38:51 <Welkin> (-> r) is the "function functor/monad"
10:39:08 <exio4> (->) :: * -> * -> * 
10:39:11 <mniip> it might have a kind but not a type
10:39:16 <max3> data (->) t1 t2 	-- Defined in ‘GHC.Prim’
10:39:30 <exio4> mniip: aren't kinds.. types now? :) 
10:39:38 <mniip> exio4, only with -XKitchenSink
10:39:45 <mniip> max3, right, -> is a type constructor
10:39:48 <mniip> still not a value
10:39:51 <max3> yes
10:40:03 <mniip> also that declaration is a lie, see docs of that module
10:41:52 <mniip> Welkin, trying to see if the typeclass mess is too convoluted
10:41:53 <max3> mniip, i don't know where to look. lots of arrows on that doc page
10:41:55 <lpaste> mniip pasted “Show WriterT” at http://lpaste.net/179330
10:42:41 <mniip> {- This is a generated file (generated by genprimopcode). It is not code to actually be used. Its only purpose is to be consumed by haddock. -}
10:42:43 <mniip> max3, ^
10:44:06 <johnw> I wonder if there's a shorthand for (x <$ act <|> pure y)
10:44:47 <johnw> I find myself using it often to turned a parser into a decided value
10:45:51 <mniip> glguy, looks like someone might need a ##fyc
10:46:15 <glguy> k
10:47:11 --- mode: ChanServ set +o glguy
10:47:12 --- mode: glguy set +b ghostlight!*@*$##fix_your_connection
10:51:03 --- mode: glguy set -o glguy
10:56:54 <haskel857> op
11:02:26 <Jenaf> I have the feeling I'm writing very ugly code
11:02:56 * hackagebot morte 1.6.2 - A bare-bones calculus of constructions  https://hackage.haskell.org/package/morte-1.6.2 (GabrielGonzalez)
11:05:37 <maerwald> Jenaf: code is not written to look pretty :o
11:05:50 <Jenaf> that is a lie ^.^
11:05:56 <maerwald> no
11:06:07 <maerwald> easily understandable
11:06:14 <maerwald> pretty? I dont care
11:06:15 <Jenaf> I want my code to look like flowers.
11:13:04 <max3> is (Num a => a) strictly speaking a type?
11:13:22 <mniip> depends on how strictly
11:14:06 <max3> well i'm confused because formally if that were a type signature i would be able to write a function like
11:14:26 <max3> (Num => a) -> (Num => a) -> (Num => a)
11:15:07 <mniip> you can if you quantify properly
11:15:21 <glguy> With RankNTypes you can write
11:15:21 <glguy> Prelude> :kind forall a. (Num a => a) -> (Num a => a) -> (Num a => a)
11:15:22 <glguy> forall a. (Num a => a) -> (Num a => a) -> (Num a => a) :: *
11:15:56 <mniip> @let foo :: (Num a => a) -> (Num a => a) -> (Num a => a); foo x y = x + y
11:15:58 <lambdabot>  Defined.
11:16:00 <mniip> :t foo
11:16:01 <lambdabot> Num a => (Num a => a) -> (Num a => a) -> a
11:16:25 <max3> interesting
11:16:25 <mniip> it is hardly a useful function though
11:16:43 <glguy> Actually, -XExplicitForAll was enough
11:16:46 <mniip> @let bar :: (forall a. Num a => a) -> (forall a. Num a => a) -> (forall a. Num a => a); foo x y = x + y
11:16:48 <lambdabot>  .L.hs:158:1:
11:16:48 <lambdabot>      The type signature for ‘bar’ lacks an accompanying binding
11:16:53 <mniip> @let bar :: (forall a. Num a => a) -> (forall a. Num a => a) -> (forall a. Num a => a); bar x y = x + y
11:16:54 <lambdabot>  Defined.
11:16:59 <mniip> this however is more interesting
11:17:23 <max3> i have no idea what quantification here means but okay
11:17:34 <mniip> it's like a + but requires both arguments to be fully polymorphic
11:17:56 * hackagebot optparse-generic 1.1.2 - Auto-generate a command-line parser for your datatype  https://hackage.haskell.org/package/optparse-generic-1.1.2 (GabrielGonzalez)
11:17:57 <Welkin> but they are still restricted to Num
11:18:04 <mniip> max3, whenever you write a type with type variables
11:18:11 <mniip> implicitly there's a forall for every type variable
11:18:21 <max3> that makes sense
11:18:26 <max3> then why the explicit universal
11:18:34 <mniip> the forall goes on the toplevel
11:19:08 <mniip> types 'a -> forall x. b' and 'forall x. a -> b' are equivalent
11:19:11 <mniip> (assuming a is free of x)
11:19:22 <max3> yes
11:19:30 <mniip> however '(forall x. b) -> a' is different from 'forall x. b -> a'
11:19:51 <mniip> because in the latter, the user of the function is free to choose x, and the function has to accomodate
11:19:58 <mniip> in the former, the function is the one choosing x
11:20:03 <mniip> and the user has to accomodate
11:20:26 <max3> the semantics of the former aren't clear to me
11:20:57 <max3> one b for all x?
11:21:56 <max3> it's funny. haskell might not be the most abstract language but it's certainly the most formal (at least that i've encountered)
11:22:04 <max3> which is nice
11:22:23 <max3> i guess it's no coq though
11:22:36 <mniip> max3, consider foo :: (forall a. a -> a) -> Int
11:22:38 <johnw> it means, given any choice of x, there is a b
11:23:42 <mniip> foo = \x -> ... x has type 'forall a. a -> a' here, i.e  you're able to apply it to value of any type and get that same type back ...
11:24:29 <mniip> when using foo, however, you do the opposite, you should give a function that is able to accomodate to being applied to a value of any type
11:25:36 <mniip> you can't say 'foo not' because even though a -> a fits into Bool -> Bool, the opposite does not happen
11:25:51 <max3> trying to parse
11:26:30 <max3> what is "the opposite"?
11:26:50 <mniip> well, there's two counterparts
11:27:29 <max3> mniip, i appreciate the discussion but just this moment i think this is too far afield for me
11:27:37 <max3> mniip, i wouldn't want to waste your time
11:27:42 <max3> thank you
11:27:45 <mniip> oh dun I have plenty of that
11:28:02 <mniip> whenever you have a typevariable, someone has to decide what it is (instantiate it), and someone has to accomodate for such decision
11:28:16 <mniip> likewise there are two sides: the producer of the value, and the consumer
11:28:41 <mniip> in Rank1 types which you've probably worked with so far, the roles coincide: consumer chooses, producer accomodates
11:28:56 <max3> makes sense
11:29:15 <mniip> sometimes Rank1 is not enough
11:29:25 <mniip> consider, say, hmm, a bit more contrived example
11:29:29 <mniip> @undefine
11:29:29 <lambdabot> Undefined.
11:30:15 <mniip> @let foo :: (forall a. a -> [a]) -> String; foo f = f 'a' ++ show (f 3)
11:30:16 <lambdabot>  Defined.
11:30:47 <mniip> you wouldn't be able to write this with rank1: you can't apply the same f to both Char and Int
11:30:59 <Welkin> :t repeat
11:31:00 <lambdabot> a -> [a]
11:31:02 <mniip> yet the function makes perfect sense if 'f' itself is polymorphic
11:31:03 <Welkin> > foo repeat
11:31:05 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
11:31:05 <Welkin> :D
11:31:08 <mniip> nah I wouldn't use that
11:31:11 <Welkin> lol
11:31:13 <mniip> > foo (replicate 2)
11:31:15 <lambdabot>  "aa[3,3]"
11:31:18 <mniip> > foo (replicate 5)
11:31:20 <lambdabot>  "aaaaa[3,3,3,3,3]"
11:31:29 <mniip> > foo (const [])
11:31:31 <lambdabot>  "[]"
11:31:39 <max3> interesting 
11:32:14 <Welkin> > foo (replicate 5 :: Int -> [Int])
11:32:15 <lambdabot>      Couldn't match type ‘a’ with ‘Int’
11:32:15 <lambdabot>        ‘a’ is a rigid type variable bound by
11:32:15 <lambdabot>            a type expected by the context: a -> [a] at <interactive>:1:1
11:32:39 <mniip> yeah, the argument *has* to be polymorphic
11:34:27 <mniip> one more interesting to note is that type variables should never escape their scope (as dictated lexically by forall)
11:35:38 <max3> i feel like that goes without saying
11:35:57 <mniip> @undefine
11:35:57 <lambdabot> Undefined.
11:35:59 <mniip> @let foo :: (forall a. a -> b) -> (b, b); foo f = (f 'a', f 3)
11:36:01 <lambdabot>  Defined.
11:36:10 <mniip> you might wonder what's "foo id"
11:36:18 <mniip> would it be ('a', 3) ?
11:36:36 <mniip> nope that's a type error
11:36:40 <mniip> > foo id
11:36:41 <lambdabot>      Couldn't match type ‘b’ with ‘a’
11:36:41 <lambdabot>        because type variable ‘a’ would escape its scope
11:36:41 <lambdabot>      This (rigid, skolem) type variable is bound by
11:36:52 <max3> yea i was thinking i'm surprised that compiled
11:37:00 <max3> actually nm
11:37:09 <max3> my surprise was for spurious reasons
11:37:21 <max3> but i guess the b
11:37:32 <max3> that should've stayed within the scope of the for al
11:37:33 <max3> l
11:37:47 <max3> why did it compile?
11:37:52 <mniip> it didn't
11:37:57 * hackagebot xdcc 1.1.1 - A wget-like utility for retrieving files from XDCC bots on  IRC  https://hackage.haskell.org/package/xdcc-1.1.1 (JanGerlinger)
11:38:04 <mniip> 'foo id' is a type error
11:38:11 <max3> what does "Defined" mean?
11:38:16 <mniip> the definition of foo itself though is valid
11:38:27 <max3> what's a valid bar then?
11:38:34 <mniip> bar?
11:38:39 <max3> foo bar such that it compiles
11:38:46 <ggole_> foo undefined
11:38:48 <mniip> > foo (\x -> (x, "moo"))
11:38:50 <lambdabot>      Couldn't match expected type ‘b’ with actual type ‘(a, [Char])’
11:38:50 <lambdabot>        because type variable ‘a’ would escape its scope
11:38:50 <lambdabot>      This (rigid, skolem) type variable is bound by
11:38:53 <mniip> err
11:38:56 <mniip> > foo (\x -> "moo")
11:38:58 <lambdabot>  ("moo","moo")
11:39:32 <ggole_> Or yeah, foo (const <anything>)
11:39:44 * ggole_ coughs
11:39:55 <mniip> can't say 'foo show' because even though foo is only using Int and Char, it is said that 'a' can be anything, not only instances of Show
11:40:27 <mniip> unless you leave the world of referential transparency I don
11:40:27 <max3> i don't understand how you got ("moo","moo") from  foo f = (f 'a', f 3)
11:40:33 <max3> oh const
11:40:37 <mniip> 't think you can ever get a tuple with two different elements from foo
11:40:47 <max3> const applied to 'a', for example, just returns the const?
11:40:56 <mniip> @src const
11:40:56 <lambdabot> const x _ = x
11:41:00 <max3> yes
11:41:40 <max3> anyway thanks
11:41:42 <max3> i'll be back
11:45:28 <mniip> max3, the skolem trick is used in the implementation of the ST monad
11:46:09 <mniip> newSTRef :: a -> ST s (STRef s a)
11:46:11 <mniip> runST :: (forall s. ST s a) -> a
11:46:43 <mniip> this ensures that an stref can never escape the runST 'do' block
11:47:15 <mniip> and if you try to use an stref in an *inner* nested block, you will monomorphize the s to the surrounding block's skolem
11:47:27 <mniip> and the type will be insufficiently polymorphic for runST
11:49:30 <max3> i have no idea what almost any of that means but it's fine
11:50:19 <Jenaf> woot my code for finding the bigest plindrome number wich is a product of 2 n-digit numbers runs in about a minute for 7 digits
11:50:35 <Jenaf> and the exercise I made it for only asked for 3 digit numbers
11:50:39 <Jenaf> hehe
11:50:51 <ertes> Jenaf: that's actually quite terrible =)
11:51:02 <ertes> encouraging you to improve it =)
11:51:06 <Jenaf> XD
11:51:15 <Jenaf> yeah the code is still ugly, want to see a gist?
11:51:29 <ertes> feel free to post it
11:51:46 <Jenaf> be prepared for some ugly code, i only started haskell yesterday
11:53:51 <Jenaf> https://gist.github.com/anonymous/aa99b446059aa5c82eaded5c7bf09e2d
11:53:54 <Jenaf> here you go
11:54:20 <lush> I tried to implement a simple parser: http://pastebin.com/Hz1kzjEp ; I first implemented string using my Monad instance of Parser, but then found a solution that only needs Applicative. However: it doesn't work properly and I don't get why. any thought? (it's been some time since I last used haskell...)
11:54:36 <Jenaf> and uh, please excuse the very wierd palindrom check function
11:54:50 <ertes> Jenaf: i can certainly give you some style suggestions, but on a first glance it's not that bad…  i see way worse code in production =)
11:55:01 <Jenaf> oh lol
11:55:25 <Jenaf> yeah style suggestions is somethign i'd really appreciate
11:55:42 <oherrala> Jenaf: isn't palindrome something like isPalindrome str = str == reverse str ?
11:55:44 <ertes> your code is readable and has type signatures on all top-level functions…  that makes it a joy to read
11:56:30 <Jenaf> Oherrala: check out the monstrosity i wrote
11:56:39 <ertes> Jenaf: first suggestion is to pay attention to precedence and eliminate parentheses that only add noise and no extra readability
11:56:54 <oherrala> Jenaf: I'm looking at it
11:57:13 <Jenaf> yeah I have really no clue about precedence yet so I just throw parans everywhere
11:57:49 <Welkin> left to right
11:57:58 <oherrala> Jenaf: lines 7 and 8 could be cleaned a bit with "where"
11:57:59 <ertes> Jenaf: most importantly function application has the highest precedence:  f x + g y;  fst p == snd p
11:58:50 <Jenaf> and there is also some $ thingy for changes in precedence or so?
11:58:59 <ertes> Jenaf: regarding your actual algorithm i can see that you were trying to be clever about how much comparison you actually do, but it won't make much of a difference to a straightforward comparison of the string to its reverse
11:59:22 <Jenaf> oh yeah lol
11:59:38 <ertes> ($) is just an operator, and while there is overusing parentheses, there is also underusing them (equivalently overusing ($))
11:59:40 <oherrala> Jenaf: $ is parameter application. f x is same as f $ x
11:59:43 <Jenaf> I kinda overlooked the obvious solution there *facepalm*
12:00:19 <lush> hehe
12:00:37 <ertes> Jenaf: your solution should be twice as fast in principle, but the bad performance of in-memory lists drowns your optimisation
12:01:05 <ertes> i doubt that it makes any noticable difference =)
12:01:14 <Jenaf> also it makes the code very ugly to read
12:01:19 <oherrala> ertes: I'm not sure, but shouldn't the list comparison terminate as soon as something doesn't match?
12:01:39 <Jenaf> and in this case readability should be more important than minor "obtimizations"
12:01:44 <ertes> oherrala: 'reverse' is O(n) anyway
12:01:47 <oherrala> ertes: so the only issue with str == reverse str is the reversing itself taking space
12:01:47 <Robot56> hi guys
12:02:30 <Jenaf> the other solution I had in my mind would have been in O(n^2), but i overlooked the other obvious O(n) solution
12:02:31 <ertes> Jenaf: now would be a good time to get into using libraries to solve your problem =)
12:03:00 <Jenaf> but I want to learn Haskell; I may get into libaries later
12:03:11 <Jenaf> first i want to have a good grasp of the basics
12:03:14 <ertes> Jenaf: that's an important part of learning haskell
12:03:29 <Jenaf> I know, but ... I kinda don't wanna :-P
12:03:36 <Robot56> guys how enter to darknet?
12:04:02 <glguy> Robot56: Wrong channel
12:04:08 <oherrala> Robot56: stack install darknet and then import the module and off you go
12:04:10 <Robot56> i'm joking
12:04:13 <Jenaf> change your browser settings so that the backroudn is black and the writing is green
12:04:18 <Jenaf> then your in the darknet
12:04:39 <Jenaf> also wear a guy fawkes mask
12:04:44 <Robot56> hahahahah
12:04:53 <Robot56> guys i'm joke
12:05:01 <ertes> Jenaf: if you find yourself wanting to do it, use Data.Sequence from the most likely preinstalled library 'containers' =)
12:05:04 <Robot56> i don't enter in the darknet
12:05:23 <glguy> Robot56: Did you have a Haskell question?
12:05:33 <ertes> Jenaf: the difference to lists is that you can read from both ends in O(1)
12:05:50 <Jenaf> Sequence sounds tempting as I tend to like to play around with integer sequences
12:05:52 <Robot56> I already know how the pc...
12:06:02 <johnw> Robot56: hi, this channel is for discussion of the Haskell language and related compilers
12:06:09 --- mode: ChanServ set +o glguy
12:06:09 --- mode: glguy set +q *!*@gateway/web/freenode/ip.93.71.161.9
12:07:54 <Jenaf> also: how much runtime things does it cost to use show int and check the string?
12:08:07 <Jenaf> one could also do some maths mumbo-jumbo
12:08:27 <ertes> Jenaf: not that much, but all you really need is a sequence of integers modulo 10
12:09:13 <Jenaf> it would be the more natural representation, but gettign that could need some costly maths stuffs...
12:09:17 <ertes> > iterate (`div` 10) 12345  -- Jenaf: you can get that by iterating an integer division by 10
12:09:19 <lambdabot>  [12345,1234,123,12,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
12:09:39 <ertes> > takeWhile (> 0) . iterate (`div` 10) 12345  -- Jenaf: then stopping when zero is reached
12:09:40 <lambdabot>      Couldn't match expected type ‘a -> [a1]’
12:09:40 <lambdabot>                  with actual type ‘[Integer]’
12:09:40 <lambdabot>      Possible cause: ‘iterate’ is applied to too many arguments
12:09:54 <ertes> > (takeWhile (> 0) . iterate (`div` 10)) 12345  -- Jenaf: then stopping when zero is reached
12:09:56 <lambdabot>  [12345,1234,123,12,1]
12:10:04 <Jenaf> anyway the runtime of the whole thing isnt determined by the O(n) of the palindrome check anyway
12:10:11 <ertes> > (map (`mod` 10) . takeWhile (> 0) . iterate (`div` 10)) 12345  -- Jenaf: and finally taking everything modulo 10
12:10:12 <lambdabot>  [5,4,3,2,1]
12:10:28 <ertes> it gives you the digits in least-significant-first order
12:10:44 <ertes> that's basically what 'show' does, but it does a lot more
12:10:59 <lush> I tried to implement a simple parser: http://pastebin.com/Hz1kzjEp ; I first implemented string using my Monad instance of Parser, but then found a solution that only needs Applicative. However: it doesn't work properly and I don't get why. any thoughts? (it's been some time since I last used haskell...)
12:11:06 <Welkin> :t iterate
12:11:08 <lambdabot> (a -> a) -> a -> [a]
12:11:12 <puregreen> has anybody used webkitgtk to write GUI? I'm trying to do it now and I absolutely hate Webkit's API (for getting input values, outputting text, etc). I want something like typesafe bindings for jQuery to go with Webkit, I guess. Has anybody already solved this problem (for their personal project, maybe?)
12:11:12 <Welkin> where is that from?
12:11:17 <ertes> Welkin: Prelude
12:11:26 <Welkin> oh
12:11:29 --- mode: glguy set -qo *!*@gateway/web/freenode/ip.93.71.161.9 glguy
12:25:23 <lush> is really nobody able to help? I'm pretty sure it's quite an easy error.. maybe something like false implementation of <*> or sth like that
12:26:30 <hiptobecubic_> lush, help with what?
12:26:35 <hiptobecubic_> oh
12:26:42 <glguy> lush: You can implement use (<*>) = ap to avoid any errors in the implementation of (<*>)
12:26:51 <lyxia> lush: (Parser ff) <*> (Parser xx) = Parser $ \inp -> case xx inp of    the order is right to left?
12:27:17 <lush> eehm
12:27:20 <lyxia> that conflicts with your >>= definition
12:27:24 <lush> that may be a good point :')
12:27:31 <lush> give me a second please! :)
12:30:48 <lush> aaaah now it is working 
12:30:49 <lush> ty!
12:32:08 <lush> I got confused with the order, don't know why ^
12:32:29 <lyxia> :)
12:33:50 <lush> is there anything else that you'd write another way in haskell?
12:34:03 <lush> All those case of patterns seem quite repetitive :')
12:37:42 <lyxia> I would have chosen String -> Either Error (String, a) as my representation. It doesn't seem like you do anything with the remaining string in case of error.
12:39:03 <lyxia> the string function looks like a traversal
12:40:49 <lush> traversal... I remember the word but I've got to lookup what it means ^^
12:41:30 <lyxia> :t traverse
12:41:31 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
12:41:48 <lyxia> I think string = traverse char
12:41:54 <glguy> lush: I'd have left the default many and some definitions, rather than reimplementing them
12:42:02 <glguy> and I'd have implemented (<*>) as ap instead of reimplementing that
12:42:15 <lush> I get ap through monad
12:42:15 <lush> ?
12:42:26 <int-e> oh, ghci -XSafe  doesn't work with ghc 8.0.1
12:42:27 <glguy> Yeah, and I'd have implemented fmap = liftM
12:42:44 <lush> glguy: does the default many the same as my implementation?
12:43:05 <lush> mhm then I should change that although it was a good exercise to think about those things :D
12:43:12 <int-e> (but setting -XSafe after starting ghci works... odd?)
12:43:37 <glguy> lush, seems so
12:44:05 <lyxia> lush: I don't see anything too out of place overall.
12:44:05 <glguy> lush: Oh, no, your versions were wrong
12:44:24 <glguy> lush: You're using the wrong outgoing string here:           (Left err', str') -> (Right [x], str')
12:45:05 <glguy> lush: same problem in <|>, some, and many
12:45:13 <glguy> you're consuming the input string on failure
12:46:06 <lush> yeah I thought that'd be how <|> should work
12:46:36 <lush> like:  parse (char 'c' <|> char 'b') "bdasdasd" should work
12:47:07 <lush> but maybe I don't really understand what's the task of <|>, I thought of it as: try the first, if it fails try the next and so one
12:48:08 <glguy> No, your problem is that (  char 'a' <|> char 'b' *> 'c' ) will consume the 'b' out of "bx"
12:48:31 <lush> what's *>?
12:48:32 <glguy> char 'b' *> char 'c' *
12:48:41 <glguy> It's the applicative >>
12:48:48 <lush> ah ok
12:48:49 <glguy> for this example you can just replace it with >>
12:49:09 <glguy> except that *> has the right precedence ot be used with <|>
12:49:39 <lush> but if I use my consumed input string won't it work like: (char 'a' <|> char 'b') "cb" will pass?
12:49:57 <glguy> no
12:50:02 <lush> huh
12:50:49 <mniip> in common parser implementations <|> actually unwinds the input
12:51:39 <mniip> which reminds me
12:51:48 <lush> I'm a little bit confused... should (char 'a' <|> char 'A') "Abbbb" work or not?
12:51:56 <glguy> Yeah, that hsould
12:51:58 <glguy> should*
12:52:02 <lush> ok then I got it right
12:52:06 <mniip> int-e: can we get FreeT in lambdabot
12:52:09 <lush> at least the idea
12:52:09 <glguy> You got it half right
12:52:22 <lush> yeah I mean the idea behind <|>
12:52:22 <chsn> if I want a haskell like -> JS, what choices do I have besides ghcjs, haste, ocamljs, f#, purescript, fay, elm?
12:52:23 <jarlg> Is there a way to activate vi-like keybindings in ghci? Like `set -o vi` for bash?
12:52:59 * hackagebot hocilib 0.0.0 - FFI binding to OCILIB  https://hackage.haskell.org/package/hocilib-0.0.0 (Thierry)
12:53:19 <lush> glguy: so you say I should write it like this: (Left err, str)   -> case yy str of       (Right y, str')   -> (Right y, str')
12:53:26 <lush> instead of yy inp
12:53:49 <glguy> No
12:53:56 <glguy> This line:       (Left err', str') -> (Left err', inp)
12:53:57 <lush> good because that doesn't work :DD
12:54:38 <lush> aaaah now I know
12:54:42 <lush> ty
12:54:47 <glguy> and your satisfy is similarly wrong
12:54:51 <lush> I thought you were talking about another part
12:55:32 <Schrostfutz> Hi, I have a problem again: I want to parse Lisp-Integers but I fail to get the Number from the readOct/-Hex functions which return ReadS a. This is my attempt: http://sprunge.us/RDFa?hs
12:55:48 <glguy> lush: Actually, the type should probably be changed
12:56:00 <glguy> newtype Parser a = Parser { parse :: String -> ParseRes (a, String) }
12:56:05 <glguy> which would have avoided these errors
12:56:41 <glguy> I suppose with the current type you can show what the input was that didn't match
12:56:43 <mniip> :t (undefined :: ReadS a) . id
12:56:44 <lambdabot> String -> [(a, String)]
12:56:49 <glguy> so it's a valid choice either way
12:57:22 <lush> so it gets a little bit more tedious but I could add more features? (I won't just in theory)
12:57:27 <lush> or more features with more ease
12:57:50 <lush> about satisfy: you mean: if I can't parse it I should return the whole input string
12:57:51 <lush> ?
12:59:23 <Schrostfutz> mniip: I forgot a call to listToMaybe in my example but even with that it does not work: http://sprunge.us/PEfb?hs
13:01:18 <int-e> mniip: this is a bad time... I'm trying to figure out the precise dependencies of lens for ghc 8.0.1 atm, and I had forgotten how lacking tool support for SafeHaskell is.
13:09:40 <mniip> int-e, fwiw free-4.11 (iirc?) doesn't have a dependency on exceptions
13:10:42 <Jenaf> I'm trying to use the where keyword the first time, btu it does not work
13:10:43 <Jenaf> https://gist.github.com/anonymous/489c80d0a07d4337c9c3644d155d0c75
13:10:57 <Jenaf> can someone please tell me what I'm doing wrong?
13:11:03 <glguy> Jenaf: "where" need to be indented
13:11:20 <chsn> is ghc's current STG based on the 1992 eval/apply or the 2004 push/enter ?
13:12:00 <merijn> chsn: Pretty sure it's based on push/enter, but even that paper is rather out of date, most likely
13:12:01 <Jenaf> thy glguy (bot?)
13:12:17 <chsn> merijn: is there any more up to date paper; or is this just "read the friendly code" ?
13:12:55 <merijn> chsn: Well, there's the GHC commentary on the wiki, which should be more up to date and comprehensive, but even that isn't always 100% accurate
13:13:13 <merijn> chsn: Other resource #ghc (don't expect any quick replies) or ghc-devs mailing list
13:13:23 <mniip> and incomplete
13:13:51 <mniip> I'm afraid the only complete documentation of ghc's behavior is its source
13:14:13 <merijn> mniip: Well, it depends on the exact level of detail you want :)
13:14:37 <merijn> chsn: To be fair, GHCs source is (in my experience so far) pretty readable
13:14:50 <chsn> I need enough detail to write a toy STG -> Javascript compiler
13:14:53 <merijn> Once you get over SPJ's horrific eccentric programming style :p
13:15:10 <merijn> chsn: afaik there's no real way to have GHC output STG
13:15:21 <chsn> there are modules for accessing that
13:15:22 <mniip> merijn, tbqh gcc is better
13:15:31 <chsn> merijn: for example: https://hackage.haskell.org/package/ghc-simple
13:16:15 <ertes> gcc better be better…  it's a C compiler written in C
13:16:28 <chsn> gcc better not be better
13:16:30 <merijn> chsn: Sure, but realise that's a very undocumented and non-standardised format :)
13:16:51 <chsn> it was written to be as unreadalbe as possible ot prevent others from writing propeitary gcc modules
13:17:08 <chsn> merijn: yeah, which is why I was hoping the papers would provide insight on how it worked
13:17:08 <merijn> mniip: Really? Last time I talked to colleagues that had hacked on gcc there was an avalanche of profanity with relation to gcc's codebase
13:17:24 <chsn> merijn: but I guess as long as it's still spineless, tagless, and graph-reducing, it can't be too different
13:17:29 <merijn> chsn: The papers are more about the techniques than documenting an actualy format :)
13:17:33 <mniip> implying that obscures the code in any way
13:17:34 * geekosaur considers the last time he looked at the gcc codebase... and swore off of it
13:18:01 <merijn> chsn: Is this STG -> JS compilation thing just for educational/"because I can" goals, or...?
13:18:04 <chsn> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode , short of the code base, is the best I can hope for?
13:18:27 <chsn> merijn: I have this crazy idea -- of a langauge which is native (i.e. numbers are js numbers, which are doubles) -- but uses ghc's type checker
13:18:45 <merijn> chsn: Probably the best you can expect, etc.
13:18:47 <chsn> merijn: so it has all of js's warts with numbers, strings, etc .... but it outputs very small js; and it gets to use all of haskell's type checking / gadt powers
13:19:12 <merijn> chsn: tbh, writing a type checker yourself is probably far less work than writing an STG -> JS compiler :)
13:19:26 <merijn> And you don't depend on an unstable format either
13:19:27 <chsn> merijn: I tried reading the rank n type checking paper
13:19:30 <mniip> merijn, I disagree
13:19:31 <chsn> merijn: and didn't understand it
13:19:50 <chsn> also, if typeclasses are easy to implement; why haven't the Fay-Language people done it?
13:19:55 <merijn> chsn: If it's the sorta thing that interest you, the recommended starting point is TaPL
13:19:58 <Gurkenglas> :t \f g -> contramap f . g . f -- Why does Getter a b have a Functor constraint?
13:19:58 <merijn> @where tapl
13:19:59 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
13:19:59 <lambdabot> Contravariant f => (a -> b) -> (b -> f b) -> a -> f a
13:20:08 <mniip> rank n, constraint kinds, polykinds, type families, coercions
13:20:09 <geekosaur> writing a H-M typechecker is probably easier. writing ghc's typechecker.... <hollow laugh>
13:20:18 <geekosaur> or, that
13:20:21 <merijn> mniip: Sure, if you wanna implement all of GHC
13:20:36 <chsn> yeah; I want all of GHC
13:20:38 <mniip> merijn, they wanted gadts
13:20:41 <c_wraith> chsn: because fay uses ghc as a compiler frontend.  It operates on GHC core.  at the point GHC core is created, all type classes have been erased
13:20:51 <mniip> they would be woefully incomplete without the rest
13:21:04 <chsn> c_wraith: yeah; wouldn't that give fay thypeclasses ?
13:21:13 <chsn> c_wraith: if all the typeclass info have been resolved / taken care of at the GHC core level?
13:21:23 <chsn> c_wraith: also, I thought that Fay used hs-source-exts, not ghc
13:21:49 <merijn> mniip: tbh, every time I think about implementing a type checker with advanced features I realise that just implementing a full dependent type checker is probably simpler AND more featurefull than GHC's mess :p
13:22:01 <merijn> Speaking of which...
13:22:18 <chsn> merijn: yeah; but reading idirs source code is also ahrd
13:22:28 <chsn> merijn: I tried implementing a dependent type checker; did not get very far
13:22:32 <merijn> I tried to read the "Gentle Art of Levitation" paper again...does anyone know a more in-depth explanation that isn't so dense
13:22:56 <chsn> merijn: http://math.andrej.com/2012/11/08/how-to-implement-dependent-type-theory-i/ is as far as I got; but this doesnt'e ven give things like "data Animal = Dog String | Cat Int"
13:23:00 * hackagebot treemap 1.20160814 - A tree of Data.Map.  https://hackage.haskell.org/package/treemap-1.20160814 (julm)
13:23:05 <merijn> chsn: Like I said, TaPL, that should get you most (all? I forget) of the way to implementing dependent types
13:23:21 <c_wraith> Yeah, implementing dependent types is somewhat easier than GHC's mess.  But GHC's mess gives you better inference than what simple dependent types do
13:23:53 <merijn> chsn: There's also the LambdaPi stuff (but that assumes some knowledge about type theory, so I'd do that after TaPL)
13:24:10 <chsn> c_wraith: isn't that the point of 'tactics' / ltac ?
13:24:18 <merijn> c_wraith: The local type inference stuff helps with that, no?
13:24:56 <c_wraith> chsn: tactics are *far* more complicated than simple dependent types
13:25:07 <kadoban> Is the stuff in tapl useful for just a usual programmer, or mostly if you're going to be implementing a compiler for a high level language? Just out of curiosity.
13:25:21 <merijn> To be honest, in daily life I'd gladly sacrifice quite a bit of inference for better types
13:25:33 <chsn> merijn: use Coq
13:25:37 <mniip> eh
13:25:43 <chsn> or Agda
13:25:45 <chsn> or Idris :-)
13:26:00 <merijn> kadoban: I wouldn't restrict the usefulness to implementing "high level languages", but just languages in general :p
13:26:01 <dolio> Tactics also aren't going to get you inference like GHC has.
13:26:20 <merijn> kadoban: But yes, the main usefulness is 1) implementing type checkers and 2) learning type theory
13:26:21 <kadoban> merijn: Heh. If you're not going to be implementing languages at all, think it's still useful to know?
13:26:35 <chsn> dolio: why not? I get the (perhaps incorrect) impression that with tactics, you can specify inference rules in USER land in stead of COMPILER land
13:27:05 <merijn> kadoban: I think a thorough understanding of basic type theory is fairly helpful in general, is it worth working through TaPL for? Probably not?
13:27:53 <kadoban> merijn: Is there something better for just basic type theory? I have a feeling I'll read tapl eventually anyway, just because ... I dunno, it sounds kind of interesting, but wondering if I should wait until I run out of other stuff to read.
13:28:00 * hackagebot interval 1.20160821 - Intervals with adherences.  https://hackage.haskell.org/package/interval-1.20160821 (julm)
13:28:07 <merijn> kadoban: If you're not going to implement languages I'd say your probably better off investing time in Software Foundations then TaPL :)
13:28:24 <kadoban> Ah yeah? That's also on my list, maybe I'll read that then.
13:28:30 <chsn> SF gets really boring really fast when tactics get too slow to run
13:28:37 <chsn> and impossible to debug without using proof general in emacs
13:28:44 <merijn> kadoban: Well, since TaPL was written as an (under)grad textbook, no, I don't think there's a better thing :)
13:28:52 <kadoban> I find myself almost completely uninterested in making my own language, or implementation of an existing language for some reason, heh.
13:29:06 <kadoban> Thanks for the answers.
13:29:30 <merijn> kadoban: Software Foundations is more about reasoning about programs and proving properties, so more generally applicable, imo
13:30:22 <kadoban> merijn: This one, right? http://www.cis.upenn.edu/~bcpierce/sf/current/toc.html
13:30:58 <dolio> chsn: Because tactics are for automatically constructing terms, and have nothing to do with the system automatically inferring types for plain terms.
13:31:12 <dolio> At least in all the places I've seen them.
13:31:45 <merijn> kadoban: Yes. Note that the book is a literate source file and if you use ProofGeneral (emacs) or Coquille (vim), you can interactively step through all the examples :)
13:32:07 <kadoban> Nice. Thanks, yeah I'll put that at the top of my reading list then and save tapl for later.
13:32:10 <merijn> I suppose the CoqIDE also works, but it sucks donkey balls, so I wouldn't bother
13:32:16 <kadoban> Haha
13:32:24 <kadoban> I'll see how the vimy thing works
13:32:33 <chsn> kadoban: just use emacs
13:32:51 <chsn> kadoban: I use vim for everything else; but for COq, I use emacs, because I need proof geneeral
13:33:03 <merijn> I was quite happy with Coquille
13:33:09 <chsn> kadoban: as it turns out, Coq has a special debug mode (which one needs for debugging ltacs) which ONLY speaks emacs
13:33:21 <kadoban> Hmm
13:33:26 <chsn> so unless Coquille has a layer to speak emacs, it's not going to have the ltac debugging tools you'll need
13:33:41 <merijn> kadoban: Here's some common bindings I made: https://github.com/merijn/dotfiles/blob/master/dotfiles/vim/ftplugin/coq.vim
13:33:44 * geekosaur used to make new languages. it was a phase. it passed. :)
13:33:52 <kadoban> Well, I guess I'll try it both ways. I've been vaguely meaning to try evil mode in emacs or spacemacs or some nonsense, but I'll probably try vim first and see
13:34:00 <merijn> geekosaur: I still plan to make the perfect language!
13:34:39 <geekosaur> ob https://xkcd.com/927/
13:34:49 <merijn> geekosaur: It'll have proper types! And modules! And be strictness polymorphic! And having linear, row polymorphic types with a borrow checker!
13:35:03 <chsn> geekosaur: unlike standards, PLs actually improve things
13:35:13 <merijn> geekosaur: How hard could it be?! :p
13:35:32 <chsn> merijn: what's a borrow checker?
13:36:09 <chsn> I thikn http://www-ps.informatik.uni-kiel.de/kics2/ is pretty cool. I wish I understood what 'narrowing' meant
13:36:21 <chsn> and that I could youtube for "curry" and get things about programing languages instead of some basketball player
13:36:26 <dolio> I also think implementing 'dependent types' is not significantly easier than implementing what GHC has, unless you have stripped out so much stuff that you are open to the same objections as implementing some simpler system similar to Haskell.
13:37:10 <chsn> dolio: well, dependent types = O(1) complexity; GHC = O(# extensions) complexity; so at some point, complexity(GHC) > complexity(dependent types)
13:37:23 <merijn> chsn: The stuff Rust has to check ownership
13:37:53 <dolio> Like, it's about as easy to implement dependent types as System F. But if you add in inductive types, and inductive families, and have good inference, and have nice pattern matching based definitions instead of eliminators, and so on, it is not easy at all.
13:38:39 <chsn> dolio: agreed; I translated http://math.andrej.com/2012/11/08/how-to-implement-dependent-type-theory-i/   from ocaml to haskell -- but then I wanted inductive types -- and I couldn't find any infoanywhere on how to implement it
13:38:41 <merijn> dolio: Right, so you're saying the hard bit is the machinery of dealing with user types
13:39:12 <chsn> dolio: but I think Coq's type system is more powerful than Haskell's type system -- and Coq's type sstem is fixed cost, whereas ghc is O(# extensions)
13:40:09 <Cale> chsn: What do you mean by "cost" there?
13:40:43 <nshepperd> all I want is a language with a magical gc that collects everything instantaneously and with no overhead
13:40:44 <chsn> Cale: how complicated it is to implement something: i.e. Coq's cost is "fixed" (as it's mostly stable); but GHC"s type system has cost O(# extensions), since with every extension, it's more complicated
13:40:52 <dolio> merijn: I'm saying the hard bit is being something someone would actually use, instead of the simplest type checker example that someone could bang out in an afternoon.
13:41:29 <Cale> chsn: If you're talking about Coq's kernel, that's relatively fixed, but then so is GHC Core
13:42:02 <chsn> Cale: unless I'm unaware, Coq doesn't have extensions; everything is built up from the core
13:42:04 <merijn> Incidentally, now that the "more knowledgeable than me" crowd has arrived, I repeat my earlier question: I was (trying to) read the "Gentle Art of Levitation" by pigworker, and I'm so, so lost any pointers?
13:42:16 <chsn> Cale: with GHC, I don't think I can do anything serious without 5-10 extensions
13:42:30 <Cale> chsn: It doesn't have extensions you can turn on and off, but it does get new language features on a regular basis.
13:42:52 <dolio> Coq does let you toggle impredicative Set, at least.
13:42:58 <Cale> Well, yeah :)
13:43:02 <dolio> Unless they removed that.
13:43:15 <chsn> Cale: are these 'new features' just things that one could do in ltac (but slower) ?
13:43:24 <Cale> Not always.
13:45:00 <Cale> Also, they put in a new tactic engine kind of recently too.
13:45:10 <Cale> With stuff like dependent subgoals
13:45:36 <dolio> merijn: Might depend which part you're stuck on. I think the descriptions type is relatively understandabale. The part where all data types are supposed to actually be defined by the descriptions, including the descriptions, I'm not sure if anyone but the authors really understand that part (and I remember the paper being a bit hand wavey about that part).
13:45:37 <Cale> https://coq.inria.fr/distrib/V8.5pl2/CHANGES
13:46:21 <chsn> Cale: I would argue this isn't 'extending the typesystem' or making it more complicated -- but is optimizations for making tactics faster
13:47:11 <Cale> chsn: In 8.5 there's universe polymorphism now
13:47:17 <Cale> That's a change to the type system
13:47:28 <chsn> I acutally don't know what "universe polymorphism" means
13:47:33 <chsn> so I'm going to admit I lose the argument. :-)
13:47:43 <merijn> dolio: Well, there's not a single point where I get lost as much as it so dense that I get lost by a hundred tiny things being glossed over, being mixed by me, difficult notation, etc.
13:48:03 <dolio> It's definitely dense.
13:48:34 <merijn> I'm not really with all the references to "universe", so I have to read something on that, but I'm not sure what :)
13:48:39 <dolio> Have you read other similar papers, maybe? Like stuff about generic programming by defining a universe of strictly positive types?
13:50:01 <merijn> dolio: I've read about 80% of TaPL, about 50% of McBride's thesis and a bunch of papers related to Epigram, ECC, and the View from the Left/eliminator stuff
13:50:14 <Cale> chsn: You're familiar with how types belong to a type called Type?
13:50:25 <merijn> And a bunch of other misc papers, but most older and not so much dependently typed
13:50:42 <Cale> chsn: Well, it's not just one type, but an infinite sequence of them, indexed by natural numbers.
13:50:45 <chsn> Cale: I'm familiar with how these are levels of types, where the TYPE of a type in Universe K has type K+1
13:50:49 <Cale> yeah
13:50:55 <merijn> Also
13:51:00 <merijn> Another thing I've been wondering
13:51:08 <chsn> Cale: I believe Coq has always had that.
13:51:13 <Cale> Yes.
13:51:30 <Cale> So, previously, Coq would simply infer which universe level anything had, and you didn't get to say which, or write definitions which would work with respect to an arbitrary universe level.
13:51:35 <merijn> What's the type/kind/whatever it is of TYPE? i.e. "TYPE :: Levity -> ?"
13:52:06 <chsn> Cale: right, iirc, Coq never showed that to the user
13:52:30 <shanemikel> is http://ezyang.com/jfp-ghc-rts-draft.pdf still the most recent version of this paper?
13:52:38 <dolio> merijn: I think ? is *, whatever that translates into in terms of TYPE.
13:52:48 <Cale> Now you can have explicit level variables and write stuff like Type@{i} for the ith universe.
13:53:16 <Cale> and you can make definitions which are explicitly polymorphic in universe level
13:53:17 <merijn> dolio: * is "TYPE Unlifted", afaik
13:53:47 <jonored> ...and lots of errors on liftIO being ambiguous between GhcMonad and ControlMonad.IO.Class when trying to do stack setup for a ghcjs project.
13:53:50 <Cale> (like in Agda)
13:54:01 <merijn> eh
13:54:05 <merijn> TYPE Lifted, I guess
13:54:47 <dolio> merijn: Yeah, sounds right.
13:54:48 <merijn> dolio: Well, hence my confusion, it can't be *, because that'd be a nonsensical recursive definition
13:55:09 <dolio> Why? How is it worse than * :: *?
13:55:19 <merijn> Oh, wait, I guess that's just type in type
13:55:44 <chsn> Cale: I don't see why I would ever want to use this, but yes, I agree, this does sound like "an extension to the type system"
13:55:50 <merijn> But still, then we have "TYPE Lifted :: TYPE Lifted", but "TYPE Unlifted :: TYPE Lifted"?
13:56:35 <Cale> chsn: If you search the release notes for the heading "Logic" you'll find some others. It's not a whole lot, but they do actually make changes to the type system itself.
13:57:07 <dolio> merijn: Something like 'Generic Programming for Dependent Types: Constructing Strictly Positive Families' might be a little more comprehensible than the levitation thing, if you haven't read it. It has a lot of epigram syntax, though.
13:57:37 <Cale> hah "- The VM now supports inductive types with up to 8388851 non-constant constructors and up to 8388607 constant ones."
13:57:51 <Cale> That's... very specific
13:57:56 <merijn> dolio: ok, I'll try that :)
13:58:08 <Rembane> Cale: And they are not even a 2^n.
13:58:30 <merijn> Cale: More so than supporting 62-ary tuples because "it crashes with bigger ones"? :p
13:58:36 <dolio> merijn: At least, it has two (I think) examples of defining a 'universe of types' that are both simpler than the levitation one.
13:59:02 <merijn> dolio: Well, the levitation one also has a universe of enums, but they seem to take lots of shortcuts defining it
14:00:05 <Cale> I guess 8388608 is a power of two...
14:00:26 <dolio> merijn: If you don't know about "universes" at all, you should probably read up about the universe in Martin-löf type theory, and then induction-recursion, which lets you define such things in general.
14:00:59 <merijn> dolio: Yeah, I've had the feeling I'm missing some basics from Martin-Löf type theory that TaPL didn't cover
14:01:02 <Cale> 8388851 = 100000000000000011110011_2
14:02:06 <Cale> So, they get a few additional non-constant constructors somehow.
14:02:25 <dolio> merijn: Generally, a universe is a type U whose values represent types, and a decoding T : U -> Type that takes those codes to the types they represent.
14:03:18 <dolio> That's what the Martin-löf one looks like, at least. Induction-recursion lets you define much fancier things.
14:04:10 <merijn> dolio: Right, and the Levitation thing is getting rid of having to maintain a separate value representation and decoding, no?
14:04:42 <Cale> There's at least two major styles of universes -- there's the kind where the universes are types whose inhabitants are directly types (Universes a la Russell), and the kind where universes are types whose inhabitants are codes for types (Universes a la Tarski)
14:05:21 <Cale> I'm more familiar with the former, it's what the HoTT book and Coq do.
14:06:33 <Cale> (Agda too)
14:06:56 <dolio> merijn: No, not really. The big point of the levitation paper is to not think of 'data type declarations' as rules for augmenting the theory. Instead, you have types that represent the declarations, and a way of decoding the declarations into the types they mean.
14:07:24 <dolio> So having that universe is like having a theory that already has all possible data declarations.
14:08:24 <Jenaf> Does Haskell have a Type for rational numbers?
14:08:33 <merijn> I should have known that, that was actually discussed in the part I still understood
14:08:36 <merijn> Jenaf: Ratio
14:08:45 <merijn> > 2 % 3
14:08:46 <Jenaf> kthy
14:08:48 <lambdabot>  2 % 3
14:08:50 <Cale> shanemikel: Sometimes ezyang comes online here... perhaps add him to your IRC client's watch list :)
14:08:52 <merijn> :t 2 % 3
14:08:54 <lambdabot> Integral a => Ratio a
14:09:09 <Cale> There's also Rational which is a synonym for Ratio Integer
14:10:33 <Cale> shanemikel: Oh, he's in #ghc right now :)
14:10:57 <dolio> merijn: There are other ways of presenting the Martin-löf universe, too, that don't involved 'codes' and 'decoding.' The one defined that way is called 'a-la-Tarski'. But there's also 'a-la-Russell', where you say that a universe is a type U such that if a : U then a is a type.
14:11:25 <Gurkenglas> :t \f g -> contramap f . g . f -- Why does Getter a b have a Functor constraint?
14:11:26 <lambdabot> Contravariant f => (a -> b) -> (b -> f b) -> a -> f a
14:11:58 <dolio> The Tarski version is more like induction-recursion, though.
14:12:34 <Cale> shanemikel: <ezyang> Cale: Yes, unfortunately ^^
14:13:20 <shanemikel> Oh, thanks
14:23:10 <xuxu> let companies = run h $ table "companies" -- [{"name":"tesla","id":"d25f0978-8cce-48e4-a58f-8b66b1d8ffa8"}]
14:23:32 <xuxu> spock requires a Text type
14:24:04 <xuxu> :t companies -- companies :: Result r => IO r
14:24:05 <lambdabot> Not in scope: ‘companies’
14:24:18 <xuxu> this is a rethinkdb query
14:24:43 <xuxu> i'm trying to convert the IO r result to something can be used by T.concat
14:25:05 <geekosaur> you don't want let, you want <-
14:25:44 <Cale> xuxu: let companies = run h $ ...  defines companies to be the same action as run h $ ...
14:26:14 <Cale> Whereas, like geekosaur says, you probably want to execute the action, and obtain its result
14:26:31 <hexagoxel> is writing to an element of a mutable vector (Data.Vector.Storable.Mutable) an atomic operation?
14:27:14 <lpaste> xuxu pasted “No title” at http://lpaste.net/179389
14:27:44 <geekosaur> right, if you are in ghci you need to provide more information
14:27:53 <geekosaur> in a program it will usually figure it out itself
14:28:11 <xuxu> what kind of information?
14:28:29 <Cale> Information about what type the variable 'companies' is meant to have
14:28:38 <Cale> Apparently it's ambiguous here...
14:28:58 <geekosaur> see, in a program it will figure out from how you use it what the type will be
14:29:22 <geekosaur> ghci has to do something and give you a prompt back without knowing what you'll type at the prompt next, so you need to give it a hint
14:29:35 <Cale> try  (companies :: Value) <- run h $ table "companies"
14:29:39 <xuxu> companies <- run h $ table "companies" :: IO [Datum]
14:29:51 <xuxu> -- :t companies -- companies :: [Datum]
14:29:51 <chsn> based on https://docs.haskellstack.org/en/stable/ghcjs/ , I tried putingg "compiler: ghcjs" into stack.yaml -- and I got an error about failiged ot parse field 'compiler' -- what should I put there instead?
14:29:52 <Cale> or something like that
14:29:59 <Cale> yeah
14:30:11 <begriffs> Any tips to build small docker containers for haskell binaries?
14:30:35 <kadoban> chsn: It gives you several example configs
14:30:38 <lpaste> xuxu pasted “investigating the Datum data type” at http://lpaste.net/179391
14:30:45 <Cale> chsn: It looks like you're meant to put in the full version number
14:31:46 <chsn> kadoban: Cale : yeah, I should read a bit further down
14:32:13 <xuxu> it looks like Datum defines  | String Text
14:32:42 <chsn> kadoban: why does it pull from aws instead of github?
14:32:45 <xuxu> it looks like my result is | Object Database.RethinkDB.Datum.Object though
14:32:50 <chsn> kadoban: slightly nervous about pulling a apckage from a random aws url
14:33:36 <kadoban> chsn: It can't use directly just the github stuff, IIUC, it has to be partially built or something? Yeah I find that part sketchy as well, the aws link.
14:33:51 <Cale> chsn: Because it's presumably getting a binary for the compiler.
14:33:58 <Cale> Does it compile ghcjs itself?
14:34:00 <xuxu> companies <- run h $ table "companies" ! "name" :: IO [Datum]
14:34:07 <Cale> I would expect that it wouldn't.
14:34:16 <xuxu> now it's a String Text type
14:34:22 <kadoban> Cale: It does a lot of stuff, and takes kinda forever. I don't really understand ghcjs though, so I dunno what it's doing.
14:34:32 <Cale> ah, hm
14:34:45 <Cale> I just use reflex-platform which is quick ;)
14:35:16 <kadoban> Cale: Can reflex-platform just give my ghcjs, out of curiosity? Like can I point my PATH somewhere and just magically have ghcjs?
14:35:26 <xuxu> this isn't accurate, but it's the only way i know how to explain, companies is it's a [Datum] type with a value of Datum a => String Text a
14:35:41 <chsn> kadoban: reflex-platform gives you a nix environment
14:35:42 <xuxu> how it's shown in ghci is ["tesla"]
14:35:43 <Cale> kadoban: Well, it'll be sitting in your nix store somewhere... so perhaps.
14:35:55 <chsn> kadoban: if you like nix; it's awesome; personally, I don't get nix
14:35:59 <Cale> I'm assuming you mean without running a nix shell
14:36:02 <kadoban> I like using stack, but last time I tried to get ghcjs through stack I had ... huge problems, though nobody else ever seemed to come across those issues, heh.
14:36:05 <kadoban> Cale: Right
14:36:22 <xuxu> i'm trying to figure out how to convert this into a text of some sort
14:36:30 <chsn> I want to start a kickstarter to fund "ghcjs into ghc"
14:36:33 <kadoban> Maybe I'll try it next time and see what happens. I guess I'm not totally against nix, I just never seem to have the urge to figure it out.
14:36:35 <chsn> who's willing to donate :-)
14:37:25 <chsn> okay, so maybe this is why ghcjs never got into ghc 8.0
14:37:39 <kadoban> Was it ever planned for ghc8?
14:38:05 <Cale> chsn: I don't really care much for nix either, except that it's quite good at the thing that it does, which is making builds reproducible.
14:38:20 <chsn> there wa ssomethign on mailing list, irc, or github, but I can't find it at the moment <- kadoban
14:38:39 <kadoban> I really should learn nix ... I think nix and stack can even play together well. Probably should just force myself to try it.
14:38:56 <Cale> The nix language is the new m4
14:39:01 <chsn> I've tried reading the nix manual like 10 times
14:39:02 <merijn> FYI, luite is usually pretty helpful troubleshooting ghcjs
14:39:04 <chsn> I stil don't get it
14:39:07 <merijn> Cale: Now you made me sad
14:39:16 <kadoban> Yeah, luite is great.
14:39:38 <Cale> I really wish we had a Haskell implementation of nix which you could configure with Haskell programs instead of nix programs whenever you liked.
14:40:10 <hexagoxel> do MVar operations act as memory barriers? the docs seem to only address ordering between MVar operations, but what if i poke some Ptr in between?
14:40:18 <chsn> Cale: in theory, isnt' this just "we need Cale to write a *.nix -> *.hs compiler" ?
14:40:20 <Cale> (It should still support nix language files, since nobody's going to want to make all those packages)
14:41:21 <Cale> there's already http://hackage.haskell.org/package/hnix
14:41:26 <merijn> hexagoxel: I don't think they have to
14:42:14 <Cale> Maybe a Haskell -> Nix compiler would do it. ;)
14:42:15 <merijn> hexagoxel: This seems relevant: http://blog.ezyang.com/2014/01/so-you-want-to-add-a-new-concurrency-primitive-to-ghc/
14:43:03 <chsn> I think this is the third time I've seen blog.ezyang.com referenced today.
14:43:32 <merijn> chsn: That's because edward 1) contributes to ghc quite a bit and 2) blogs about it too :p
14:46:04 <hexagoxel> merijn: thanks.
14:50:37 <hexagoxel> i guess i can use some C primitives to get across-FFI synchronization. Kinda ironic.
14:57:42 <hexagoxel> merijn: wait, what did you mean by "they don't have to"? that the standard does not require implementations to have the property?
15:03:03 * hackagebot morte 1.6.3 - A bare-bones calculus of constructions  https://hackage.haskell.org/package/morte-1.6.3 (GabrielGonzalez)
15:05:57 <Jenaf> okay, wtf
15:06:17 <Jenaf> I just compiled my code and now I'm not allowed to delete the resulting .exe?
15:06:53 <Welkin> Jenaf: you are on windows? o.o
15:07:03 <Jenaf> yeah
15:07:05 <Welkin> no idea
15:07:08 <Welkin> probably a windows problem
15:09:09 <Jenaf> okay, I'm letting a not-really-good sieve of erathostenes run on the first two million numbers
15:09:17 <Jenaf> dou you think It will terminate overnight?
15:11:04 <hexagoxel> Jenaf: first try some rtsopts. on your earlier example, 
15:11:19 <Jenaf> rtsopts?
15:11:32 <Welkin> profile the code
15:11:33 <hexagoxel> `+RTS -A4M` reduced gc overheads significantly
15:11:51 <hexagoxel> (and consequently, halved execution time)
15:11:54 <Welkin> Jenaf: project euler?
15:12:02 <Jenaf> yeah
15:12:10 <Welkin> you know you can solve most (or all) of those just using math
15:12:15 <Welkin> no need for brute force
15:12:18 <Welkin> brute force often fails
15:12:23 <Jenaf> I know XD
15:12:30 <athan> what constitutes as "data", without including function spaces?
15:12:38 <Jenaf> but I'm about to go to bed anyway, so why not try lettign it run overnight?
15:12:57 <athan> i.e. `forall a. a \\ (forall b c. b -> c)` or something?
15:13:09 <athan> er sorry, is there a word for this?
15:13:17 <Welkin> is your sieve O(n^2)?
15:13:19 <Jenaf> thats the code i just complied using ghc -O2
15:13:23 <Jenaf> https://gist.github.com/anonymous/84f8743636b44c7a546cdf35b72c153e
15:13:34 <Jenaf> @Welkin: i think it is O(n^2)
15:13:34 <lambdabot> Unknown command, try @list
15:13:46 <athan> er... hm. Terms vs. expressions? maybe..?
15:13:48 <Welkin> so many parens...
15:13:53 <Jenaf> but for 200k it terminated within minutes
15:13:57 <Welkin> all unnecessary
15:14:04 <Welkin> and that do-block is extraneous too
15:14:09 <Jenaf> i just started haskell yesterday
15:14:16 <Welkin> main :: IO ()
15:14:22 <Jenaf> and this is the first time ever I compiled haskel code
15:14:28 <athan> Jenaf: Welcome :)
15:14:28 <Welkin> main = print . sum . sieven $ 2000000
15:14:30 <Jenaf> b4 I was just loading things into ghci
15:14:47 <Welkin> actually
15:14:51 <Jenaf> so I don't really have much of a clue of what I'm doing
15:15:01 <Welkin> that's fine
15:15:52 <Welkin> lol
15:15:54 <athan> cryptomorphism
15:15:56 <Welkin> everything is on one line
15:16:10 <Welkin> Jenaf: learn about `let` and `where` yet?
15:16:28 <Jenaf> yeah; I got confused by the indentation errors so I just put everything into one line and bombarded it with parans
15:16:40 <Welkin> also, you don't need tuples
15:16:52 <Jenaf> also the sieve itself is copy and pasted from euler 3, and I'm at euler9now
15:16:58 <Welkin> you can have multiple parameters to a function
15:17:03 <Jenaf> so i learned quite a bit since i wrote that sieve
15:17:21 <Welkin> Jenaf: install haskell-mode for your editor
15:17:28 <Jenaf> btu I was too lazy to rewrite it, having faith in ghc obtimisation
15:17:39 <Jenaf> I use notepad++ 
15:17:53 <Welkin> install something better than that...
15:17:57 <Welkin> like emacs
15:18:00 <Jenaf> nah
15:18:27 <Jenaf> I'll just let this version run overnight. If it terminates: fine; if not I'll write a better sieve
15:18:31 <Welkin> so you don't have any syntax highlighting or formatting?
15:19:05 <Jenaf> some, because it knows Haskell, but I wonder why :: and -> don't get highlighted
15:19:16 <Welkin> because it doesn't have haskell-moe
15:19:20 <Welkin> haskell-mode
15:19:28 <Welkin> haha, haskell-moe :D
15:19:48 <Jenaf> does he serve haskell-beer to haskel-homer?
15:20:33 <Welkin> oh, I was thinking https://en.wikipedia.org/wiki/Moe_(slang)
15:21:04 <Jenaf> oh lol
15:26:58 <Jenaf> rough estimation: it should terminate in ~16 hours
15:27:15 <Jenaf> brute force, yay
15:46:55 <athan> In Network.Socket, what is a ServiceName?
15:47:22 <glguy> Either a number or an entry from /etc/services
15:47:42 <chsn> https://hackage.haskell.org/package/regex-compat-0.95.1/docs/Text-Regex.html <-- is this state of the art for regex in haskell ?
15:48:03 <chsn> I don't need the full power of parsec. I just need to split some giant strings on regular expressions
15:48:26 <athan> glguy: Ahh! sorry, still a newb ._.
15:48:40 <athan> chsn: There's also regex-applicative!
15:49:30 <Welkin> I thought you were some kind of bird
15:50:14 <athan> Welkin: :v
15:50:36 <chsn> https://hackage.haskell.org/package/regex-type <-- wtf is this
15:50:38 <chsn> regex on types?
15:54:03 <athan> chsn: holy shirt
15:54:17 <shirt> athan: eh?
15:55:06 <enthropy> Uploaded 	Fri Apr 1 18:57:03 UTC 2016
15:55:11 <imPure> Meme - Why not Context Free parsing on types?
15:55:34 <athan> shirt: Sorry :)
15:56:59 <chsn> athan: is this Nethack where you pour Holy+8 water on a Hawwian shirt before battling demons?
16:00:49 <berra_> I'm seeking library/usage recommendations for JSON - with aeson, or another library, what's the syntactically lightest way to express arbitrary json, without having an ADT representation? is manually constructing a hashmap with Aeson the easiest way?
16:02:45 <chsn> berra_: I may have possibly misunderstood your question -- why not use Aeson and just have it auto derive tojson/fromjson instances?
16:03:05 * hackagebot pipes-http 1.0.4 - HTTP client with pipes interface  https://hackage.haskell.org/package/pipes-http-1.0.4 (GabrielGonzalez)
16:03:46 <puregreen> berra_: if you want to construct JSON, then Aeson's ‘object’ is going to be pretty lightweight
16:04:40 <berra_> I'm wondering if there's a slightly quieter way than having to make type aliases for all the value constructors in aeson's object/value -- 
16:05:06 <puregreen> object ["foo" .= 3, "bar" .= object [ ... ] ]
16:05:26 <puregreen> ‘.=’ will do-what-you-mean in most cases
16:05:32 <berra_> https://github.com/nlohmann/json this is actually one of my favorite json libraries despite being c++ 
16:06:58 <berra_> puregreen: thanks, I should have given that operator a try (I assumed from the docs that (.=) is only intended for manually writing ToJSON/FromJSON instances)
16:08:45 <berra_> (aeson is another favorite library of course, but was looking for a less rigid, prototype-friendly way to produce json for the moment)
16:08:59 <puregreen> writing a ToJSON instance means merely taking something and constructing JSON from it, so it's just “constructing JSON” in both cases
16:10:35 <berra_> puregreen: thanks, I had overcomplicated it in my mind
16:10:51 <puregreen> there's also https://github.com/sol/aeson-qq#readme
16:11:13 <puregreen> you might like it more
16:13:18 <berra_> puregreen: awesome, aeson-qq was what I had imagined, thanks! but (.=) may get me far enough
16:39:02 <aarvar> is there Applicative but for functors of kind (* -> *) -> *?
16:49:56 <hydraz> why aren't the Prelude's `id` and `(.)` re-exports of the ones from Control.Category?
16:50:43 <johnw> hydraz: because for many people, they are used for one category, and so the genericity of the errors would just be annoying to the majority
16:50:58 <johnw> you're free to import them yourself
16:52:04 <tamago_> :q
16:52:15 <tamago_> oops
16:52:17 <hydraz> johnw: But then I have to import Prelude hiding (id, (.)), no?
16:52:24 <johnw> hydraz: correct
16:55:37 <athan> aarvar: Like a polykinds functor?
16:55:49 <athan> s.t. PolyFunctor :: k -> *
16:56:03 <athan> aarvar: Actually hold that thought, fmap is impossible lol
16:56:10 <athan> because values are strictly of kind *
16:56:46 <aarvar> athan: you can have a polykinded functor
16:57:16 <aarvar> you have to generalize (->) to arrows of some category
16:57:50 <athan> aarvar: But... fmap
16:57:57 <aarvar> what about it?
16:58:07 <aarvar> https://hackage.haskell.org/package/categories-1.0.7/docs/Control-Categorical-Functor.html
16:59:03 <athan> aarvar: you're still mapping values
16:59:11 <athan> `f` still expects to see a value, doesn't it?
16:59:17 <athan> because categories expect values
16:59:30 <aarvar> not sure what you mean
16:59:36 <athan> you couldn't have a category `c Maybe Either`
16:59:43 <athan> maybe a natural trans. ?
17:00:00 <athan> by value, I mean specifically elements of types with kind *
17:00:30 <ertes> athan: functors don't need to be endofunctors
17:00:32 <athan> aarvar: I think you should keep going with this though :)
17:00:41 <aarvar> keep going with what
17:00:49 <athan> attempting lol
17:00:53 <aarvar> attempting what
17:01:10 <athan> life lol
17:01:23 <athan> ertes: where was I endoing?
17:01:47 <ertes> nevermind
17:02:12 <athan> aarvar: (that comment wasn't meant to be depraving, sorry)
17:02:44 <aarvar> athan: how dare you
17:04:12 <ertes> aarvar: fmap1 :: (forall a. f a -> g a) -> F f -> F g  -- like this?
17:05:23 <aarvar> ertes: yes
17:06:38 <ertes> aarvar: if you make this a special case of higher-rank endofunctors, then you can use MFunctor from the 'mmorph' library
17:06:49 <ertes> F needs to be (* -> *) -> (* -> *)
17:06:55 <aarvar> wrong kind
17:07:00 <aarvar> and im looking for applicative, not functor
17:08:08 <ertes> what would the type of the apply combinator be?
17:08:41 <ertes> you need some rank-2 representation of functions
17:17:35 <aarvar> oh, damn, that library isnt polykinded
17:18:45 <immersion> How do you create lists of 3 elements using pipes-group? P.toList $ concats $ maps _ $ view (chunksOf 3) (each "hi there") -- should return ["hi ", "the", "re"]
17:31:09 <johnw> what does "maps _" do?
17:31:53 <immersion> maps is defined here https://hackage.haskell.org/package/pipes-group-1.0.5/docs/Pipes-Group.html
17:32:01 <immersion> The _ just means that I don't know what should go there
17:33:08 * hackagebot hspec-setup 0.2.0.0 - Add an hspec test-suite in one command  https://hackage.haskell.org/package/hspec-setup-0.2.0.0 (yamadapc)
17:33:43 <johnw> why does your example require mapping anything?
17:34:30 <pavonia> :t view (chunksOf 3) (each "hi there")
17:34:31 <lambdabot>     Couldn't match type ‘a -> Const a a’ with ‘[e0]’
17:34:31 <lambdabot>     Expected type: Getting a (s0 -> f0 t0) a
17:34:31 <lambdabot>       Actual type: [e0] -> [[e0]]
17:34:37 <johnw> btw, as far as I know (I don't have code running), concats . view (chunksOf 3) should cancel each other out, no?
17:35:58 <immersion> Maybe it doesn't require mapping - that was just my attempt at a solution
17:36:15 <Gurkenglas> pavonia, Pipes.Group defines it's own chunksOf, and lambdabot doesn't know Pipes.Group
17:36:33 <johnw>  what you want is to go from Producer String m () to Producer [String] m ()?
17:36:45 <Gurkenglas> (Trying to find some (a -> b) -> Producer a m r -> Producer b m r right now)
17:37:15 <immersion> johnw: yes
17:38:19 <johnw> ok, one sec
17:39:26 <Gurkenglas> Huh, lambdabot doesnt even know Pipes.
17:40:03 <Gurkenglas> Try "flip for yield . (:[])" in place of _?
17:40:38 <Gurkenglas> "flip for (yield . (:[]))" that is, dammit no typechecker
17:41:50 <immersion> That produces ["h","i"," ","t","h","e","r","e"]
17:42:40 <johnw> meh, it will take too long for me to build an environment to test my answer, and I have to go now
17:45:44 <immersion> let chunksOf n = replicateM n await >>= yield >> chunksOf n in P.toList $ (each "hi there") >-> chunksOf 3 -- returns ["hi ","the"]
17:46:05 <immersion> It just doesn't deal with leftovers (the "re" at the end)
17:51:05 <Gurkenglas> (stack unpack pipes-group, cd pipes-group, stack init --solver, stack build, stack ghci, time for some tdd)
17:52:51 <Gurkenglas> (When I press up in ghci in msys2 the cursor actually goes above the command prompt and the line I was currently writing gets contaminated with \ESC characters or something...)
17:53:16 <grantwu> Yeah... terminals suck...
18:11:01 <chsn>  /join #go-nuts
18:17:27 <Gurkenglas> Eureka! immersion, *Pipes.Group.Tutorial Pipes.Group Pipes.Group.Tutorial L Pipes.Prelude Control.Foldl> toList $ purely folds list $ L.view (chunksOf 3) (each "hi there")'
18:17:54 <Gurkenglas> *"'" before "*Pipes", *worked at the end. Damn enter key
18:21:01 <Gurkenglas> And if you want no Foldl dependency, "toList $ folds (\x a -> x . (a:)) id ($ []) $ L.view (chunksOf 3) (each "hi there")" also works
18:35:26 <systemfault> I don't get foldMap. Why does foldMap (*5) [1] :: Sum Int "works" foldMap (*5) [1] :: Maybe Int doesn't?
18:35:44 <ertes> > 1 :: Maybe Int
18:35:46 <lambdabot>      No instance for (Num (Maybe Int)) arising from the literal ‘1’
18:35:46 <lambdabot>      In the expression: 1 :: Maybe Int
18:35:52 <ertes> systemfault: that's why
18:36:29 <systemfault> Ah, it's just that
18:36:42 <ertes> systemfault: even then it requires a monoid
18:37:04 <ertes> foldMap f xs = fold (map f xs)  -- f's result type must be a Monoid
18:37:53 <pavonia> When I use an MVar function in a handler that is registered by a foreign function, the program exits with "schedule: re-entered unsafely. Perhaps a 'foreign import unsafe' should be 'safe'?" as soon as the handler is called. However, I don't use any safe or unsafe declarations for my foreign imports because I'm not sure about what the implications of these are. What is the proper way to...
18:37:54 <pavonia> ...handle this problem? Can't I use MVars in foreign handlers?
18:37:58 <systemfault> ertes: Thanks :)
18:40:24 <mauke> what is the foreign function you called that ended up running your handler?
18:41:17 <pavonia> "SetConsoleCtrlHandler" from the Windows API
18:41:40 <mauke> that doesn't sound like it would run a handler
18:42:17 <pavonia> Well, the handler is called when Ctrl+C is received
18:42:21 <geekosaur> pavonia, you can't do that
18:42:48 <pavonia> Using MVars here?
18:42:50 <mauke> oh, async fun
18:42:59 <geekosaur> using Haskell callbacks here
18:43:04 <geekosaur> not from a signal handler
18:43:17 <mauke> (windows doesn't have signals)
18:43:38 <pavonia> What is a Haskell callback?
18:43:46 <geekosaur> (there are slight differences between this an a posix signal, but the main issue is still present: there is no way to ensure the runtime can handle a call at the time it is invoked)
18:44:23 <geekosaur> anything that calls a Haskell function from C, essentially
18:44:31 <mauke> a callback written in haskell
18:45:02 <ertes> would FunPtr wrapping work?
18:45:19 <geekosaur> (again, not exactly, but that covers 90% of cases. you probably do not care about ones where C is primary and Haskell secondary, which has slughtly different rules)
18:45:42 <pavonia> Then how do I use this function to signal events to the Haskell program?
18:46:46 <geekosaur> I would use the same trick I'd use for async operations in C: the callback is in C and writes down a pipe, the read end is in the synchronous part (in your case in Haskell) and reads from the other end
18:47:06 <pavonia> Btw, it worked with just using some debug output, but fails with MVars
18:48:29 <geekosaur> pretty sure it "got lucky" and just can't detect that there's a potential problem. in most cases (not just involving haskell) something like this manifests as nondeterministic core dumps 
18:48:57 <mauke> did you foreign import SetConsoleCtrlHandler manually?
18:49:17 <pavonia> mauke: Yes
18:51:25 <mauke> can you check in ghci if your GHC.ConsoleHandler module exports anything?
18:51:25 <pavonia> haskeline uses the same function and does a "throwTo tid Interrupt" in its handler
18:52:12 <pavonia> Yeah, it has an installHandler function
18:55:03 <mauke> that might work better but the lack of documentation worries me
18:56:37 <mauke> oh, it's ifdef'd out on other OSes
18:57:08 <mauke> anyway, try installHandler (Catch yourFn)
18:58:42 <pavonia> What is the result handler of this function?
18:59:43 <jchia> Data.Fixed uses Integer internally, is there something similar that uses Int?
18:59:49 <mauke> the previous handler
19:01:16 <pavonia> Thanks, let me try ...
19:04:22 <pavonia> That seems to work
19:05:19 <pavonia> It's a bit disappointing, though, that you can't write Haskell handlers for foreign functions that easily
19:08:03 <geekosaur> you can in the case where you call into the FFI and that call calls back into Haskell
19:08:48 <geekosaur> otherwise... well, it's not much different from POSIX signal handlers only guaranteeing safety for a very small number of functions (because reentrancy is Hard)
19:11:24 <dfeuer> edwardk, I'm puzzled by the type of imfix in indexed-Control.Monad.Indexed.Functor. Why m i i a and not m i j a?
19:13:58 <pavonia> geekosaur: In the case of an FFI call, is it different because the RTS is kind of "prepared" for calls back into Haskell, while in the case of an asynchronous callbacks it's not?
19:14:09 <geekosaur> essentially
19:14:23 <geekosaur> if you make a "safe" FFI call, the runtime specifically prepares to handle callbacks
19:14:58 <Zemyla> geekosaur: Is there a way to set an MVar on receiving a signal?
19:15:08 <geekosaur> if you make an "unsafe" call, it's almost like using an asynchronous callback (e.g. POSIX signals or Windows ctrl-c handler), there's no guarantee the runtime is able to do anything
19:15:20 <geekosaur> (consider for example if something happens during a garbage collection)
19:15:38 <mauke> "unsafe" promises you won't re-enter haskell during the call, so the RTS can skip some bookkeeping
19:16:02 <mauke> Zemyla: yes, if you use the normal signal handling interface
19:16:17 <geekosaur> Zemyla, unless the POSIX signal stuff specifically handles it (it might, I have not reviewed the code, but signal handling is exposed in System.Posix.Signals so I'd hope so) you'd need to use something like the loopback pipe trick I described earlier
19:16:23 <mauke> no if you foreign import sigaction manually
19:16:52 <mauke> geekosaur: AFAIK the standard modules run haskell signal handlers in a new thread
19:16:58 <Zemyla> Or some kind of atomic compare-and-swap.
19:17:06 <mauke> i.e. the RTS has already done all the hard work
19:22:53 <dfeuer> Type-aligned sequences can offer a function of type tmap :: (forall i j . c i j -> d i j) -> t c x y -> t d x y. What should a type class offering such an operation be called?
19:24:19 <dfeuer> I'm trying t put together a tiny package offering Atkey-style indexed functors, applicatives, and monads, plus things mappable in the described manner, and foldable and traversable in related manners.
19:24:23 <dfeuer> But names are really hard.
19:24:36 <dfeuer> Any categorical name for a thing like that?
19:25:59 <dfeuer> It seems to be some sort of transformation of a natural transformation between hom-functors or something, but I don't know category theory.
19:26:23 <dfeuer> Anyone know?
19:26:24 <mniip> dfeuer, imagine a function that changes the index from i to j
19:26:46 <dfeuer> mniip, how's that relate?
19:26:52 <mniip> 1471831862 [05:11:02] <dfeuer> edwardk, I'm puzzled by the type of imfix in indexed-Control.Monad.Indexed.Functor. Why m i i a and not m i j a?
19:26:57 <dfeuer> Oh, that.
19:27:05 <mniip> the point is
19:27:15 <mniip> if you have different indices, you can't possibly apply your function twice
19:27:45 <dfeuer> mniip, why do you need to?
19:28:17 <Zemyla> dfeuer: You can't feed it back through.
19:29:02 <mniip> trying to come up with an example
19:29:39 <dfeuer> It's value recursion; the action only happens once.
19:31:55 <mniip> hmm, does IxFree exist
19:32:27 * mniip <- hasn't used free monads in their original purpose a single time
19:32:29 <dfeuer> mniip, no idea, but free monads aren't MonadFix anyway.
19:32:42 <dfeuer> What's their original purpose?
19:33:00 <mniip> constructing a monad from a set of operations
19:33:22 <dfeuer> So what have you used them for?
19:33:28 <mniip> er
19:33:33 <mniip> @hackage yoctoparsec
19:33:33 <lambdabot> http://hackage.haskell.org/package/yoctoparsec
19:34:15 <dfeuer> mniip, what makes that different from their original purpose?
19:34:35 <dfeuer> Also, have you thought about an appropriate name for the class/method I described? That's going to make me crazy.
19:34:48 <mniip> (Reader t) isn't exactly that kind of functor
19:35:08 <dfeuer> *shrug*. It's a functor.
19:35:28 <mniip> riiiight
19:35:53 <mniip> also can you describe your thing in more detail
19:36:13 <mniip> type aligned sequences? and I'm not sure that type signature tells me much
19:37:08 <biglambda> Why would my instance of typeclass Storable cause an infinite loop: http://lpaste.net/179428
19:37:16 <dfeuer> mniip, the simplest example of a type-aligned sequence is   data TList c x y where TNil :: c x x; TCons :: c x y -> TList c y z -> TList c x z
19:37:42 <mniip> TNil :: TList c x x, right?
19:38:11 <dfeuer> They're used for reflection without remorse and such. They support a foldMap analogue mapping to a Category.
19:38:20 <dfeuer> Yes, that's what I meant.
19:38:24 <dfeuer> Sorry.
19:38:30 <mniip> hmm
19:39:10 <immersion> Gurkenglas: Thank you! Now I'm going to study the foldl library =)
19:39:21 <mniip> dfeuer, reminds me of hoist
19:40:12 <mniip> you lift a natural transformation  c -> d into t c -> t d
19:40:23 <mniip> c,d,t c,t d are functors from Hask to End(Hask)
19:40:32 <ertes> biglambda: the default peekByteOff is defined in terms of peek
19:40:37 <nitrix> Why isn't `a -> (b -> b) -> a` something like `forall a. a -> (forall a. b -> b) -> a` by default?
19:40:44 <dfeuer> mniip, yeah, that's the right idea. But I want two indices because dealing with '(i, j) stuff is very painful.
19:40:48 <ertes> biglambda: and you defined peek in terms of peekByteOff
19:40:51 <biglambda> I see
19:41:07 <biglambda> That would make sense :)
19:41:09 <mniip> dfeuer, I would use some word for "lift" for it
19:41:28 <ertes> biglambda: you probably meant to use the peek/peekByteOff of another type, not the one you're writing an instance for
19:41:36 <biglambda> I see
19:41:43 <mniip> hmm, we have lift, hoist, 
19:41:49 <mniip> I guess the next option is skycrane
19:41:52 <nitrix> In other words, why to choose that `(b -> b)` is monomorphic(?) and not rank-2 by default?
19:41:55 <biglambda> So I should just constrain the type.
19:42:06 <ertes> biglambda: also note that on some platforms alignment is not just for efficiency, but actually mandatory
19:42:14 <mniip> nitrix, type of (.)
19:42:23 <dfeuer> Hahaha. elevate? 
19:42:34 <biglambda> ertes: How should I define alignment exactly?
19:42:46 <nitrix> mniip: I'm trying to think, what role does (.) play in this?
19:42:51 <geekosaur> forall a. doesn't help there. did you mean forall b.? and if so, doesn't that need ImpredicativeTypes which is always broken?
19:43:04 <mniip> :t (.)
19:43:06 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:43:08 <ertes> biglambda: depends on the memory layout and the primitive type you're going to read
19:43:12 * hackagebot tcp-streams 0.4.0.0 - One stop solution for tcp client and server with tls support.  https://hackage.haskell.org/package/tcp-streams-0.4.0.0 (winterland)
19:43:25 <ertes> biglambda: question: why are you writing it?
19:43:36 <mniip> all haskell98 functions live in unsuspecting rank 1 world
19:43:44 <ertes> biglambda: to use Data.Vector.Storable?
19:43:54 <mauke> that alignment looks OK if overly conservative
19:43:56 <mniip> would be pretty destructive to require explicit quantification of a large portion of them
19:44:05 <biglambda> Honestly, I’m using my own Coord type because the one in my main program has some type constraints that are helpful
19:44:29 <biglambda> So I thought it would be simple enough just to write my own instance
19:44:49 <nitrix> mniip: Would a better math/C.S. background help me see more clearly why or is that something specific to Haskell?
19:44:51 <ertes> biglambda: hint: the 'linear' library comes with V2, which is isomorphic to your Coord type, but has Storable and Unbox instances
19:45:23 <biglambda> ertes: My actual coord type distinguishes between X and Y dimensional values
19:45:32 <biglambda> using newTypes
19:45:40 <biglambda> that’s the only reason
19:46:00 <mauke> I'd fall back to the base definition: alignment (DSpace d) = alignment d; ... alignment (Coord x _) = alignment x
19:46:00 <mniip> nitrix, do you know what rank 1 is
19:46:23 <biglambda> ertes: I removed it from the example I pasted though
19:46:52 <ertes> biglambda: do you really want/need that?  seems like you'd give up a lot of free functionality that way
19:47:01 <biglambda> Yeah
19:47:10 <biglambda> It’s old code.
19:47:33 <biglambda> I’m just porting some of it to run in an OpenCL kernel
19:47:55 <ertes> i see…  so that's why you're using storable vectors
19:48:00 <biglambda> I can go back and remove a lot of cruft at some point
19:48:06 <biglambda> Yes that’s why
19:48:27 <biglambda> Allows me to move a list of data into foreign memory easily
19:48:38 <biglambda> And take it out again.
19:48:50 <ertes> are you actually dealing with 2D spatial points?
19:48:57 <biglambda> Yes
19:49:04 <biglambda> 2D floats
19:49:12 <biglambda> On the GPU
19:49:21 <biglambda> It’s a rasterizer
19:49:45 <biglambda> I first implemented with Repa and then coded OpenCL based on that.
19:49:59 <nitrix> mniip: I'd guess it's function that can only take another function as an argument (not a polymorphic one, but monomorphic).
19:50:08 <biglambda> Working fairly well but I’m trying now to optimize
19:50:30 <ertes> IMO the best option is to refactor the code to use V2 from 'linear'…  if that's not possible, use the alignment code mauke wrote above and be sure to write 'peek' in terms of 'peek'/'peekElemOff' of the underlying type
19:50:43 <nitrix> mniip: e.g. foo :: (a -> a) -> Int  would be rank-1, while bar :: (forall a. a -> a) -> Int would be rank-2 ?
19:50:51 <mniip> nitrix, no, it's one that can be transformed into 'forall tv1 tv2 tv3. monomorphic type'
19:51:01 <ertes> biglambda: same for poke
19:51:06 <nitrix> mniip: It is monomprhic.
19:51:23 <mniip> your examples are correct but the idea is not
19:52:07 <biglambda> Ok thanks, I’ll give that a shot and let you know how it goes.
19:52:25 <nitrix> mniip: I'm speaking of the `foo` as having an implicit quantification though, the type variables are monomorphic in that sense, for the lack of knowing better terminology.  What am I missing?
19:53:08 <mniip> err I'm bending terminology a bit there
19:53:25 <mniip> usually a monomorphic type is one without type variables
19:53:41 <nitrix> mniip: Don't be afraid to be pedantic if it helps. I'd rather see things as they are.
19:54:01 <mniip> I'm speaking about 'forall tv1 tv2 tv3. some type without foralls'
19:54:05 <nitrix> mniip: I thought monomorphic meant the type variable got pinned by the calling function to a concrete type.
19:54:22 <mniip> monomorphic is the antonym of polymorphic
19:54:46 <dfeuer> Sometimes.
19:55:01 <mniip> (common sense tells me it's related to monomorphisms but apparently not?)
19:55:07 <nitrix> mniip: Really? I doubt it. What about monomorphism restriction?
19:55:13 <dfeuer> Other times it's dual to epic. Terminology sucks.
19:55:16 <mniip> yes
19:55:35 <mniip> in monomorphism restriction we're actually talking about antipolymorphism
19:56:08 <nitrix> Interesting. Up until now, I thought those were in the same basket.
19:56:18 <mniip> nitrix, the monomorphism restriction states that all toplevel declarations are assumed to be monomorphic
19:56:25 <geekosaur> nitrix, that's related but it's more complex than that. still, consider that the MR is about forcing something with a type variable to act as if it didn't have one but had a specific type
19:56:30 <mniip> unless declared polymorphic with a quantified type signature
19:56:36 <geekosaur> when otherwise that would not be forced
19:56:52 <nitrix> mniip: Well, almost. Only if there's no type signatures and the left-hand side has no arguments.
19:57:14 <nitrix> But back to the question, ehm...
19:57:19 <mniip> not sure about the details
19:57:23 <mniip> I try to avoid it
19:57:45 <mniip> can't remember when was the last time I've written a decl without a tysig outside of ghci
19:58:36 <mniip> nitrix, so
19:58:42 <mniip> in haskell98 all types are rank 1
19:59:12 <nitrix> mniip: I was told to look at polymorphism as, the author of a given function, and a user of the same function. Even if the function has polymorphic type variables, from the user's perspective, this function is polymorphic, he gets to choose which types he wants to use it on (specialize the function), but from the author's perspective, inside his function, since the user get to choose the type, from his
19:59:15 <nitrix> perspective, the type variables are monomorphic, aka, pinned to a given type.
19:59:16 <dfeuer> hrmm
19:59:18 <nitrix> mniip: That was my understanding until now.
19:59:38 <mniip> "monomorphic"
19:59:44 <mniip> I'd use the term "rigid" there
19:59:46 <nshepperd> that seems like an abuse of language
19:59:49 <nitrix> mniip: I didn't think monomorphic and polymophic were antonyms :/
19:59:52 <mniip> as that's what ghc uses
20:00:02 <nshepperd> type variables can't be monomorphic
20:00:15 <nitrix> mniip: Oh... so that's what it is.
20:00:32 <mniip> @let foo :: a -> a; f x = not x
20:00:34 <lambdabot>  .L.hs:157:1:
20:00:34 <lambdabot>      Duplicate type signatures for ‘foo’
20:00:34 <lambdabot>      at .L.hs:155:1-3
20:00:38 <mniip> @undefine
20:00:38 <lambdabot> Undefined.
20:00:39 <mniip> @let foo :: a -> a; f x = not x
20:00:40 <lambdabot>  .L.hs:155:1:
20:00:40 <lambdabot>      The type signature for ‘foo’ lacks an accompanying binding
20:00:44 <mniip> blah
20:00:46 <mniip> @undefine
20:00:46 <lambdabot> Undefined.
20:00:49 <mniip> @let foo :: a -> a; foo x = not x
20:00:51 <lambdabot>  .L.hs:159:9:
20:00:51 <lambdabot>      Couldn't match expected type ‘a’ with actual type ‘Bool’
20:00:51 <lambdabot>        ‘a’ is a rigid type variable bound by
20:01:02 <nitrix> Gotcha.
20:01:13 <nitrix> That clarifies some terminology a little.
20:01:47 <mniip> when typechecking an application, we can substitute the type variables in the applicants any way we want
20:01:49 <nitrix> mniip: So rank-1 being monomorphic... then that means you'd have  :: forall a. Int -> Int -> MoreConcreteTypes ?
20:02:09 <nitrix> Sorry, no foralls, meant to erase that.
20:02:15 <mniip> when typechecking an abstraction however, the bound argument contains "rigid" type variables, that cannot be substituted
20:02:27 <mniip> rank-1 != monomorphic
20:02:32 <mniip> id is rank-1
20:02:36 <nshepperd> nitrix: rank-1 is 'forall a b c. some type without foralls'
20:02:36 <mniip> (.) is rank-1
20:03:00 <nitrix> nshepperd: I'm aware. The question is how they're called.
20:03:03 <nshepperd> length [a,b,c,...] >= 0
20:03:27 <nitrix> nshepperd: Become someone thrown explanation about monomorphic things and my world crumbled.
20:04:19 <nitrix> nshepperd: AFAIK, `forall a. a -> (b -> b) -> a`  is rank-1, and `forall a. a -> (forall b. b -> b) -> a` is rank-2.
20:04:31 <nitrix> mniip: I don't get the monomprhic part here. What's monomorphic?
20:04:48 <mniip> :t not
20:04:50 <lambdabot> Bool -> Bool
20:05:02 <mniip> :t ["three"]
20:05:04 <lambdabot> [[Char]]
20:05:08 <mniip> all these things are monomorphic
20:05:14 <nitrix> Yes but how is it related?
20:05:15 <mniip> they contain no type variables
20:05:24 <mniip> their types are inhabitants of Hask
20:05:41 <biglambda> ertes, mauke: Here’s the working version http://lpaste.net/179428 THANKS
20:05:48 * mniip . o O ( are quantified types inhabitants of Hask? )
20:06:03 <nitrix> 22:51:02           mniip | nitrix, no, it's one that can be transformed into 'forall tv1 tv2 tv3. monomorphic type'
20:06:11 <mniip> I later corrected myself
20:06:22 <mniip> 1471834366 [05:52:46] 20<mniip>30 err I'm bending terminology a bit there
20:06:22 <mniip> 1471834382 [05:53:02] 20<mniip>30 usually a monomorphic type is one without type variables
20:06:23 <mniip> 1471834419 [05:53:39] <mniip> I'm speaking about 'forall tv1 tv2 tv3. some type without foralls'
20:06:29 <nitrix> Okay.
20:08:05 <nitrix> We're on the same page then, other than I didn't know pinned polymorphic type variables were referred to as rigid.
20:08:38 <nitrix> And what would break if we were to make more of our rank-1 functions as rank-2 ?
20:09:00 <mniip> well, let's begin with
20:09:01 <mniip> :t ($)
20:09:02 <lambdabot> (a -> b) -> a -> b
20:09:38 <mniip> this type makes no sense in the implicit quantification strategy that you're proposing
20:10:03 <mniip> not that I'm entirely sure what it is,
20:10:26 <mniip> :t Data.IORef.modifyIORef
20:10:27 <lambdabot> GHC.IORef.IORef a -> (a -> a) -> IO ()
20:10:47 <mniip> :t (.)
20:10:48 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:10:58 <mniip> :t runContT
20:11:00 <lambdabot> ContT r m a -> (a -> m r) -> m r
20:11:06 <nitrix> Mhhh...
20:11:07 <nshepperd> I think the theory was something like 'put the forall at the innermost scope containing all references to the variables'
20:12:09 <mniip> :t curry (.)
20:12:10 <lambdabot>     Couldn't match type ‘(a, b)’ with ‘b1 -> c’
20:12:10 <lambdabot>     Expected type: (a, b) -> (a1 -> b1) -> a1 -> c
20:12:10 <lambdabot>       Actual type: (b1 -> c) -> (a1 -> b1) -> a1 -> c
20:12:22 <mniip> :t uncurry (.)
20:12:23 <nitrix> Let's see... forall a b. (forall c d. c -> d) -> a -> b ... that's definitely not as "safe/clear" as ($), but wouldn't it work?
20:12:23 <lambdabot> (b -> c, a -> b) -> a -> c
20:12:38 <nshepperd> I can think of three problems: type inference is worse with RankN, impredicative types don't work at all, and rank1 functions are usually more useful anyway
20:13:21 <mniip> nitrix, you'd ever be able to apply it to either some form of undefined, or some form of unsafeCoerce
20:13:40 <nitrix> Actually you're right, d and b don't match.
20:13:55 * nitrix scratches head.
20:14:08 <mniip> forall a b. (forall c d. (a ~ c, b ~ d) => c -> d) -> a -> b  that's just equal to the original type sig
20:14:18 <nitrix> Weird, I could swear when I had that idea this morning, somehow it didn't seem that impossible.
20:14:29 <nshepperd> :t runST
20:14:30 <lambdabot> (forall s. ST s a) -> a
20:15:15 <mniip> nshepperd's idea seems more likely
20:15:18 <mniip> but see uncurry (.)
20:15:27 <nshepperd> 'runST (return "foo")' works
20:15:32 <nitrix> I see. That was a little naive from me to think rank-2 could be the default then.
20:15:45 <nshepperd> 'runST $ return "foo"' requires special magic
20:15:53 <mniip> yeah
20:16:00 <mniip> > runST `id` return "foo"
20:16:02 <lambdabot>      Couldn't match expected type ‘forall s. ST s a’
20:16:02 <lambdabot>                  with actual type ‘m0 [Char]’
20:16:02 <lambdabot>      In the second argument of ‘id’, namely ‘return "foo"’
20:16:26 <mniip> the typechecker can't handle rank-2 types here without a type annotation
20:16:44 <mniip> runST $ do is a common enough thing to have a special case in the typechecker
20:16:45 <nshepperd> because the type required (return "foo") :: forall s. ST s String doesn't unify with the 'a' in :t ($)
20:17:07 <mniip> that erases application to GHC.Base.$
20:17:14 <nitrix> Oh wait what.
20:17:26 <nitrix> Isn't that nasty o.<
20:17:35 <mniip> kinda
20:17:49 <mniip> rank-2 typechecking is so complicated that not even GHC has it
20:17:54 <mniip> rank-3 typechecking is undecidable
20:18:14 * hackagebot inchworm 1.0.1.1 - Inchworm Lexer Framework  https://hackage.haskell.org/package/inchworm-1.0.1.1 (BenLippmeier)
20:18:36 <mniip> ^ one more reason why haskell98 decided to stick with rank-1
20:18:53 <mniip> was rank-2 inference even proven at the time?
20:19:01 <nitrix> Are there situations that cannot be solved without rank-2, or is it convenience?
20:19:39 <nitrix> mniip: GHC can infer rank-2 but not type-check everything correctly is what I understand?
20:19:51 <mniip> no
20:19:57 <mniip> it can typecheck but not infer
20:20:10 <nitrix> Gotcha.
20:20:21 <mniip> if you use a :: typecast every time you use an identifier it's going to be okay
20:20:42 <nitrix> And rank-3 is not checkable?
20:20:49 <nitrix> How does Rank-N works?
20:21:15 <mauke> pretty sure it's checkable but not inferable
20:21:41 <mniip> 1471835975 [06:19:35] <mniip> it can typecheck but not infer
20:21:49 <nitrix> So similar problem, except the inferring complexifies.
20:22:25 <mniip> hmm
20:22:34 <mniip> I don't think you can type-annotate that even
20:22:56 <mniip> can you introduce a tyvar shared between values?
20:23:43 <nitrix> mniip: mauke nshepperd Thank you guys for answering the wave of questions.
20:24:29 <nitrix> It's always ideal when it happens right before bed, then the brain gets to sleep on it ;)
20:24:51 <mniip> :t let z :: forall a. a; z = z; x :: a; x = undefined; y :: a; y = undefined in (x, y)
20:24:53 <lambdabot> (t, t1)
20:25:00 <mniip> :t let z :: forall a. a; z = z in let x :: a; x = undefined; y :: a; y = undefined in (x, y)
20:25:01 <lambdabot> (t, t1)
20:25:04 <mniip> hmm
20:25:11 <mniip> maybe you can't even express all the things then
20:26:53 <mniip> :t id runST
20:26:54 <lambdabot>     Couldn't match expected type ‘a’
20:26:54 <lambdabot>                 with actual type ‘(forall s. ST s a0) -> a0’
20:26:54 <lambdabot>       ‘a’ is a rigid type variable bound by
20:28:43 <mniip> :t (id :: ((forall s. ST s a) -> a) -> ((forall r. ST r a) -> a)) runST
20:28:44 <lambdabot>     Cannot instantiate unification variable ‘a0’
20:28:45 <lambdabot>     with a type involving foralls: (forall r. ST r a1) -> a1
20:28:45 <lambdabot>       Perhaps you want ImpredicativeTypes
20:28:47 <mniip> can you even write this
20:30:33 <mauke> I think that's exactly what impredicative types are for
20:31:14 <mniip> oh but they're so broken
20:31:17 <geekosaur> ...when they work, wich, ...
20:31:26 <geekosaur> *which
20:32:09 <mniip> :t Unsafe.Coerce.unsafeCoerce id runST
20:32:10 <lambdabot> t
20:32:12 <mniip> good enough for me
20:33:14 * hackagebot morte 1.6.4 - A bare-bones calculus of constructions  https://hackage.haskell.org/package/morte-1.6.4 (GabrielGonzalez)
20:39:36 <mniip> why does ghci try to recompile already compiled modules?
20:44:14 <fresheyeball> hey out there
20:44:21 <fresheyeball> quick question
20:44:30 <fresheyeball> let x = Left 3
20:44:34 <fresheyeball> let y = Left 4
20:44:41 <fresheyeball> x <*> y = x
20:44:44 <fresheyeball> why?
20:44:57 <mauke> it isn't
20:45:38 <mniip> it is, well, operationally
20:45:50 <mauke> but the types don't work
20:45:52 <mniip> but the xes are of different types there
20:45:56 <fresheyeball> bogus
20:45:57 <fresheyeball> I just checked again
20:45:59 <fresheyeball> it works
20:46:20 <fresheyeball> @lambdabot
20:46:21 <lambdabot> Unknown command, try @list
20:46:23 <mauke> > let x = Left 3; y = Left 4 in length [x <*> y, x]
20:46:25 <lambdabot>  2
20:46:28 <mauke> oh, indeed
20:46:37 <mniip> :t let x = Left 3 in (x <*> Left 4, x)
20:46:38 <mauke> polymorphism?
20:46:39 <lambdabot> (Num a, Num a1) => (Either a b, Either a1 b1)
20:46:45 <fresheyeball> Either is Applicative 
20:46:54 <mniip> I think it's a polymorphic binding on x
20:47:09 <mauke> I have insufficiently generalized my type variables, lord
20:47:14 <mniip> :t let x = 3 in (x, x, x)
20:47:15 <lambdabot> (Num t, Num t1, Num t2) => (t, t1, t2)
20:47:26 <fresheyeball> haha
20:47:47 <mauke> fresheyeball: which part exactly are you asking about?
20:47:49 <mniip> :t (\x -> (x, x, x)) 3
20:47:51 <lambdabot> Num t => (t, t, t)
20:48:05 <mniip> :t (\x -> (x <*> Left 4, x)) (Left 3)
20:48:06 <lambdabot> Num a1 => (Either a1 b, Either a1 (a -> b))
20:48:08 <fresheyeball> x <*> y = x
20:48:09 <fresheyeball> why?
20:48:17 <fresheyeball> why not `x <*> y = y`
20:48:28 <mniip> well, first thing is that neither of those equations can work
20:48:29 <fresheyeball> they are both `Left` so why the one on the left
20:48:36 <mauke> because <*> runs the effects of the first argument first
20:48:43 <fresheyeball> right
20:48:45 <fresheyeball> but why?
20:48:51 <mauke> sanity?
20:48:54 <mniip> because it comes first syntactically
20:49:13 <mniip> would you expect 'do f; g; h' to execute backwards?
20:49:42 <fresheyeball> would it still obey the Applicative laws if the implementation of Applicative for Either picked the second Left instead?
20:49:44 <mniip> you can: 'forward $ do backward f; backward g; backward h'
20:49:49 <mniip> (assuming ApplicativeDo)
20:50:11 <mniip> fresheyeball, yes, that's Backward (Either a)
20:50:30 <mniip> https://hackage.haskell.org/package/transformers-0.5.2.0/docs/Control-Applicative-Backwards.html
20:52:45 <fresheyeball> I'm not sure thats true
20:53:01 <mniip> :t Bacwards
20:53:02 <lambdabot>     Not in scope: data constructor ‘Bacwards’
20:53:02 <lambdabot>     Perhaps you meant variable ‘backwards’ (imported from Control.Lens)
20:53:11 <mniip> @let import Control.Applicative.Backwards
20:53:12 <lambdabot>  Defined.
20:53:26 <mniip> > (Backwards $ Left 3) <*> (Backwards $ Left 4)
20:53:27 <lambdabot>  Backwards (Left 4)
20:53:49 <mniip> what's with me and spelling "Backwards" today
20:54:30 <fresheyeball> yeah, but thats just a dodge 
20:54:38 <mniip> ?
20:54:50 <fresheyeball> Backwards reverse the direction 
20:54:51 <fresheyeball> sec
20:55:15 <mniip> that's correct
20:55:51 <mniip> for every nontrivial applicative instance, there's one that is backwards
20:56:19 <NeverDie> Anyone know of any open jobs in Haskell?
20:56:21 <mniip> in Identity, the forward and the backward instances coincide, and so they do in Maybe
20:56:42 <mniip> in Either a, however, the two are distinct
20:57:06 <fresheyeball> ok I get ti
20:57:09 <fresheyeball> ok I get it
20:57:35 <fresheyeball> Applicative goes left to right to avoid spoiling expectations that come from monads and do notation 
20:57:37 <fresheyeball> but both are valid 
20:57:42 <mniip> yes
21:06:07 <fresheyeball> mniip: so is there a name for when a thing has 2 Applicative instances?
21:06:36 <mniip> no
21:06:42 <mniip> some things have more instances though
21:06:46 <mniip> e.g []/ZipList
21:06:55 <fresheyeball> its like an `Applicative Ring` or some shit
21:15:07 <geekosaur> terms like "ring" are only applicable when there's a mathematical relationship between them, though
21:21:42 <nitrix> > ZipList [(+1),(+3),(+7)] <*> ZipList [1,2,3]
21:21:44 <lambdabot>  ZipList {getZipList = [2,5,10]}
21:21:56 <nitrix> > [(+1),(+3),(+7)] <*> [1,2,3]
21:21:57 <lambdabot>  [2,3,4,4,5,6,8,9,10]
21:22:00 <mniip> can type synonyms be kind-polymorphic?
21:23:00 <nitrix> mniip: I think you can with ConstraintKinds ?
21:24:31 <mniip>     • Expected a type, but found something with kind ‘*’
21:24:33 <mniip> well good job
21:26:16 <mniip> type Compose2 r (t :: TYPE (rt :: RuntimeRep)) (a :: TYPE (ra :: RuntimeRep)) (b :: TYPE (rb :: RuntimeRep)) = (t -> (# a, b #)) -> t -> (a -> b -> r) -> r
21:26:19 <mniip> where did I go wrong
21:26:40 <nitrix> Kind checking happens before expanding synonyms, right?
21:28:16 * hackagebot glirc 2.10 - Console IRC client  https://hackage.haskell.org/package/glirc-2.10 (EricMertens)
21:28:25 <mniip> I half expected this to be impossible
21:28:30 <mniip> but that message just sucks
21:29:51 <lpaste> glguy pasted “for mniip” at http://lpaste.net/179440
21:29:57 <glguy> mniip: That loads, at least
21:30:04 <mniip> does it?
21:30:10 <glguy> does it?
21:30:14 <mniip> ah
21:30:35 <mniip> hmm, I'm not sure I want to sacrifice backwards compatibility for this
21:30:48 <mniip> (TypeInType)
21:30:55 <mniip> but I'll keep that in mind
21:40:30 <NeverDie> Does Haskell have a GUI library?
21:42:33 <pavonia> Several even: Gtk, wx, several browser-based, ...
21:48:07 <gfixler> several ncurses libs, too
21:51:15 <mniip> <interactive>: internal error: MUT_ARR_PTRS_CLEAN object entered! (GHC version 8.0.1 for x86_64_unknown_linux) Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
21:51:17 <mniip> me is sad
21:51:56 <mniip> I was sorta expecting "id' :: forall (a :: TYPE PtrRepUnlifted). a -> a; id' x = x" to actually work
21:52:08 <mniip> because that's what runtime reps are for, aren't they?
22:00:04 <haoyang> can i ask question here
22:00:16 <jle`> haoyang: yup!
22:00:45 <haoyang> I am wondering this chat we can ask haskell question all the time right?
22:01:04 <mauke> sure
22:01:35 <mauke> you may not get an answer (at least not immediately) if everyone's asleep, though
22:02:15 <haoyang> got it!
22:02:21 <mauke> it's just random people who happen to be online and paying attention
22:02:48 <systemfault> Trying to do some exercises in the Haskell book: Would you write 'elem' using Foldables like this?:  elem x = getAny . foldMap (Any . (==x))
22:03:02 <systemfault> Or there's a nicer way that I just cannot find since I'm a noob
22:04:07 <zomg> at least syntaxwise it looks reasonable but must admit I'm not hugely familiar with foldables :)
22:04:32 <systemfault> Reasonable is encouraging to me :P
22:04:57 <jle`> any popular library offering a "free category" similar to how list is the "free monoid" ?
22:05:03 <gfixler> it looks okay to me
22:05:06 <jle`> i wrote a one-off one but was wondering if there was something i could re-use
22:06:50 <gfixler> systemfault: elem' x = foldr ((||) . (==x)) False
22:06:55 <gfixler> I think that might work, too
22:07:06 <gfixler> no need for the monoid stuff
22:07:14 <systemfault> Right
22:07:38 <ongy> also, isn't '\x -> any (==x)' enough?
22:08:20 <c_wraith> :t any . (==)
22:08:21 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
22:09:20 <gfixler> ongy: or even (any . (==))
22:09:38 <gfixler> > (any . (==)) 'c' "this is cool"
22:09:40 <lambdabot>  True
22:10:04 <gfixler> but that's skipping using foldable things
22:10:12 <gfixler> which I think is part of the exercise in the book
22:10:19 <systemfault> Yeah :)
22:14:03 <c_wraith> Technically...
22:14:05 <c_wraith> :t any
22:14:06 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
22:14:09 <c_wraith> That's a Foldable thing
22:17:36 <c_wraith> :t \x -> getAny . foldMap (Any . (== x))
22:17:37 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
22:20:47 <gfixler> I suppose, though it's a pre-made foldable thing
22:24:46 <c_wraith> That's why I said "technically"
22:31:38 <ongy> @src any
22:31:38 <lambdabot> any p = or . map p
22:35:45 <systemfault> I'm missing something that must be really obvious for Foldable.
22:37:07 <systemfault> Ah, nvm
22:47:30 <mniip> in other news
22:47:45 <mniip> I came up with a package that lets you manipulate unboxed tuples in GHCi
22:47:49 <mniip> without -fobject-code
23:03:19 * hackagebot mysql-haskell 0.3.0.0 - pure haskell MySQL driver  https://hackage.haskell.org/package/mysql-haskell-0.3.0.0 (winterland)
23:11:59 <pavonia> Is there already a class somewhere for converting from and to Char?
23:12:59 <parsnip0> > ord 'A'
23:13:01 <lambdabot>  65
23:13:14 <Koterpillar> > ord '아'
23:13:16 <lambdabot>  50500
23:13:34 <parsnip0> > chr 50501
23:13:37 <lambdabot>  '\50501'
23:14:03 <geekosaur> also note that Char has an Enum instance
23:14:13 <pavonia> I mean functions you can overload, like the IsString class but for characters
23:18:07 <geekosaur> no, and it's not clear how useful such a thing would be
23:18:08 <Koterpillar> pavonia: what instances do you want[ to make]?
23:18:08 <geekosaur> (in particular it wouldn't be useful for Text and if you're doing that with ByteString use the .Char8 one and be aware that it is lossy)
23:18:36 <pavonia> Koterpillar: CChar and CWchar
23:19:26 <Koterpillar> pavonia: and what is a CChar for '아'?
23:19:54 <pavonia> undefined
23:20:03 <Koterpillar> ah, well, there will be a CWchar
23:20:28 <geekosaur> until you exit the BMP at least
23:21:17 <geekosaur> (also that instance would inherently be windows-only, because wchar_t is so pathetically underspecified that it must be treated as platform and potentially even C compiler specific)
23:21:18 <pavonia> Err, I guess I need a custom class anyway because of code pages :S
23:23:19 * hackagebot hailgun 0.4.1.0 - Mailgun REST api interface for Haskell.  https://hackage.haskell.org/package/hailgun-0.4.1.0 (RobertMassaioli)
23:31:31 <ocramz> morning !
23:31:48 <mniip> ok here comes the most boring package ever
23:33:19 * hackagebot box-tuples 0.1.0.0 - A hack to use GHC.Prim primitives in GHCi  https://hackage.haskell.org/package/box-tuples-0.1.0.0 (mniip)
23:38:20 * hackagebot postgresql-simple-migration 0.1.6.0 - PostgreSQL Schema Migrations  https://hackage.haskell.org/package/postgresql-simple-migration-0.1.6.0 (ameingast)
23:53:20 * hackagebot emailaddress 0.1.3.0 - Wrapper around email-validate library adding instances for common type classes.  https://hackage.haskell.org/package/emailaddress-0.1.3.0 (cdepillabout)
23:53:22 * hackagebot emailaddress 0.1.4.0 - Wrapper around email-validate library adding instances for common type classes.  https://hackage.haskell.org/package/emailaddress-0.1.4.0 (cdepillabout)
23:53:24 * hackagebot emailaddress 0.1.5.0 - Wrapper around email-validate library adding instances for common type classes.  https://hackage.haskell.org/package/emailaddress-0.1.5.0 (cdepillabout)
