00:02:16 <cocreature> srhb: there has been a proposal for local imports by ocharles iirc
00:03:12 <srhb> https://mail.haskell.org/pipermail/haskell-cafe/2015-August/120681.html -- for reference, this is somewhere in that thread. Thanks cocreature
00:03:26 <cocreature> ah yeah just found it as well
00:03:52 <suzu> holy shit haskell is segfaulting!
00:04:11 <cocreature> suzu: using the FFI?
00:04:18 <suzu> um... no
00:04:24 <suzu> i am using Haskeline
00:04:34 <suzu> i think i know what's wrong here
00:04:37 <suzu> haskeline is not thread-safe.
00:04:41 * hackagebot idringen 0.1.0.1 - A project manage tool for Idris.  https://hackage.haskell.org/package/idringen-0.1.0.1 (zjhsdtc)
00:04:48 <suzu> i've got one thread printing out stuff
00:04:52 <suzu> and then another thread asking for user input
00:04:58 <cocreature> well haskeline does ffi calls
00:05:01 <suzu> and i'm pretty sure something bad is going on in here
00:05:10 <suzu> because it without fail segfaults
00:05:12 <suzu> ah yeah
00:05:14 <suzu> you are right
00:05:31 <suzu> it looks like it binds to ncurses with the ffi
00:06:17 <srhb> ocharles: Did anyone ever make the proposal about "Syntax extension - adding import support tolet/where bindings" in a more formal setting than Haskell Cafe, or did it strand there?
00:06:41 <suzu> i suppose i could rewrite my app to only use haskeline in the one thread
00:06:47 <cocreature> there wasn’t really a more formal way to make a proposal at that point
00:07:26 <wagle> wireshark++
00:07:35 <wagle> i couldnt sleep
00:07:37 <srhb> cocreature: How come?
00:07:44 <cocreature> srhb: might be worth trying to revive it using the ghc-proposal repo. but then I don’t remember while it failed originally so the reasons might still apply
00:07:47 <srhb> cocreature: The trac seems to be where most of these live.
00:08:01 <srhb> cocreature: Rather, the ghc wiki.
00:08:28 <cocreature> srhb: the trac is for documenting proposals, but the discussion on whether to accept it or not is usually still done on mailing lists
00:08:32 * hackagebot ruin 0.1.0.1 - Pliable records  https://hackage.haskell.org/package/ruin-0.1.0.1 (NicolasFrisby)
00:08:32 * hackagebot idringen 0.1.0.1 - A project manage tool for Idris.  https://hackage.haskell.org/package/idringen-0.1.0.1 (zjhsdtc)
00:08:40 <srhb> cocreature: Ah, I see. Okay. :)
00:08:49 <srhb> I might see if I can revive it sometime later this week.
00:08:59 <cocreature> I would definitely like to see it
00:09:05 <srhb> Yeah, it would be quite awesome.
00:23:57 <Gurkenglas> Why isn't there a combinator to fold Cofrees?
00:25:27 <cocreature> Gurkenglas: is the Foldable instance not what you’re looking for?
00:25:53 <Gurkenglas> Sorry, I mean to cata Cofrees
00:26:24 <Gurkenglas> The thing https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Free.html#v:foldFree does
00:27:45 <Gurkenglas> (Well, monadic effects not really necessary. More the opposite of https://hackage.haskell.org/package/free-4.12.4/docs/Control-Comonad-Cofree.html#v:unfold )
00:28:17 <Gurkenglas> "ununfold :: Functor f => ((a, f b) -> b) -> Cofree f a -> b"
00:34:01 <cocreature> Gurkenglas: where do you get the initial f b from to apply the passed function?
00:34:19 <Gurkenglas> I pull it out of infinity
00:35:01 <cocreature> ah yeah I guess you can do that
00:42:34 <chemouna> Hello, i'm trying to understand more the paper on finger trees by Paterson & Hinze (Finger trees:  a simple general-purpose data structure) , but everytime i get close to finish it i realize i didn't understand it , any resources or advice (i've read all the resource pointed to here http://www.staff.city.ac.uk/~ross/papers/FingerTree.html) 
00:43:10 <chemouna> or any practical advice on reading papers (related to haskell) and understanding them better
00:43:19 <chemouna> would be great
00:44:08 <pavonia> What is unclear?
00:47:53 <chemouna> pavonia: the code of the implementation (for example the deque operations and the use of view f sequences)
00:51:55 <daniel_w> chemouna: I found this helpful: http://apfelmus.nfshost.com/articles/monoid-fingertree.html
00:54:18 <chemouna> thanks daniel_w
01:00:47 <ashishnegi> hi.. i include Data.Text in .hs file and started getting error :   Data.Text not available.. do you mean Data.Set
01:01:07 <ashishnegi> so i added `text` in my .cabal file and stack fetched / build the package
01:01:30 <ashishnegi> `text` was a guess.. how do i know the aliases for the packages.. ?
01:01:56 <hvr> ashishnegi: if you know the exact module name, you can infer the package name 
01:02:24 <hvr> via .e.g https://www.haskell.org/hoogle/
01:02:31 <cocreature> use the new hoogle http://hoogle.haskell.org/ :)
01:02:41 <hvr> right...
01:03:05 <hvr> there you can enter 'module:Data.TExt'
01:03:12 <ashishnegi> hvr:  infer.. like just convert to shortform.. ?
01:03:39 <hvr> ashishnegi: I rather mean, that there's a mapping of package name -> {module names}
01:03:47 <ashishnegi> http://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text.html does not give / can not find any info that `text` is the alias to put in .cabal
01:04:04 <hvr> and tools like  http://hoogle.haskell.org/ allow you to figure out (for popular packages) how to reverse that mapping
01:04:35 <hvr> ashishnegi: 'text' is not really an alias, it's the package's name that contains the 'Data.Text' module (& others)
01:05:19 <hvr> package's are collections of modules, and the unit of packaging we use in Haskell
01:05:22 <hvr> -'
01:05:37 <ashishnegi> i see.. it is at the top.. blue bar left side .. having other buttons `source` `contents` `index`
01:05:56 <daniel_w> ashishnegi, it's in the url
01:06:00 <daniel_w> as well
01:06:06 <hvr> ashishnegi: http://hackage.haskell.org/package/text-1.2.2.1 <- there you can see what other stuff is provided by thge 'text' package
01:06:06 <ashishnegi> duh.. true
01:06:15 <ashishnegi> thanks
01:14:18 <synergistics> How would a parser work that has a stream type of a list of strings?
01:14:44 <daniel_w> synergistics: which library?
01:14:49 <synergistics> I want to parse over a string over splitting it into lines while maintaining state over the whole list
01:14:52 <synergistics> Parsec
01:15:05 <synergistics> string after* splitting
01:16:28 <daniel_w> so you want something like: overLines :: Parser a -> Parser [a]
01:16:45 <daniel_w> ?
01:17:08 <synergistics> Right
01:17:18 <synergistics> But I'm not sure of where or how to split the initial string
01:17:44 <synergistics> Well I know what function to use, so I guess more when than how
01:18:55 <daniel_w> generally parsec combinators build parsers with limited lookahead.
01:19:44 <daniel_w> In this case, if you could ensure that your parser per line wouldn't consume a newline character, it would be easier to fix into parsec
01:19:57 <daniel_w> *per line parser
01:21:15 <synergistics> Oh, so instead of running lines, just delimit the parser at newlines?
01:24:18 <daniel_w> See, http://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Combinator.html#v:sepBy
01:25:00 <synergistics> Yea I was thinking of how to fit that in, I think I've figured it out
01:33:48 <johnw> btw, pipes-parse has a way of expressing this
01:33:59 <johnw> by chunking the input into semantic groups
01:43:31 * hackagebot desert 0.1.0.1 - a simple build tool for OCaml projects  https://hackage.haskell.org/package/desert-0.1.0.1 (zjhsdtc)
01:54:35 <nathyong_> is there anything other than lenses out there for functional getter/setter interfaces that's worth looking at?
02:13:03 <troydm> is there a function in haskell that takes bytestring and index of substring with index until or length and gives a substring of that bytestring?
02:13:33 * hackagebot x86-64bit 0.1 - Runtime code generation for x86 64 bit machine code  https://hackage.haskell.org/package/x86-64bit-0.1 (PeterDivianszky)
02:14:01 <srhb> troydm: I can't parse: "index of substring with index until or length"
02:14:25 <troydm> srhb: like Java's substring method for String class
02:14:38 <srhb> troydm: I don't speak Java, sorry.
02:15:08 <troydm> substring(int beginIndex, int endIndex)
02:15:09 <troydm> Returns a new string that is a substring of this string.
02:15:20 <troydm> simple
02:15:48 <srhb> troydm: There's drop and take
02:16:12 <troydm> srhb: so you are suggesting combination of those two I guess
02:16:17 <srhb> troydm: Yes. :)
02:16:31 <troydm> srhb: okey I got it, thx
02:17:02 <troydm> also is IO monadic bind tco safe?
02:17:35 <[delta]> test test test (ignore me)
02:17:49 <troydm> like I want to continiously apply some IO function over a recursive function but without getting my stack exploded
02:18:11 <srhb> troydm: tco?
02:18:18 <daniel_w> tail call optimization
02:18:20 <troydm> srhb: tail call optimization
02:18:21 <daniel_w> I presum
02:18:23 <srhb> troydm: Tail calls are irrelevant in Haskell, really.
02:18:31 <srhb> (There is no TCO)
02:18:35 <troydm> srhb: honestly they are relevant
02:18:40 <troydm> anywhere 
02:18:47 <daniel_w> Not in a lazy language
02:18:47 <troydm> so
02:18:53 <srhb> troydm: You need a call stack for them to have any meaning.
02:18:57 <srhb> We don't have a call stack.
02:19:04 <troydm> okey
02:19:08 <troydm> as I said
02:19:14 <troydm> I have some recursive function
02:19:29 <daniel_w> troydm, GHC will do the right thing
02:19:40 <troydm> and I want to continiously apply some IO fun over some data I get in process of applying that recursive function
02:19:50 <troydm> what's the most efficient way to do that?
02:20:01 <srhb> forever, until and company.
02:20:37 <troydm> hmm
02:21:52 <daniel_w> troydm, from your description I think you want foldM
02:22:55 <troydm> daniel_w: probably, will look into it
02:25:32 <root> hello there
02:25:38 <root> lol
02:25:57 <bollu> hey guys
02:26:07 <bollu> what exactly is a "day convolution"?
02:27:27 <kv_> bollu: I had the exact same question :)
02:27:33 <srhb> bollu: Have you seen: https://ncatlab.org/nlab/show/Day+convolution#definition ?
02:28:13 <bollu> srhb: just taking a look at it, but I find nLab to be way more category theoretic that what is accessible to me
02:28:42 <bollu> "closed symmetric monoidal category " <- I'm lost :/ I know closed, monoidal(?) but not symmetric
02:28:47 <bollu> closed in the sense of CCC
02:28:50 <srhb> bollu: THen the "exactly" part may be a little hard to fulfill. There are some Haskell specific resources on left Kan extensions though
02:29:07 <srhb> Afair, at least.
02:29:28 <johnw> bollu: in what context are you asking?
02:29:48 <bollu> johnw: the blog post related to building UIs using comonads - there's a definition using a Day convolution
02:29:48 <johnw> their utility in Haskell in one thing; their theoretical origins is another
02:29:50 <mbuf> What is the recommended setup to use HTTPS with scotty?
02:29:53 <bollu> I want to understand what they are
02:30:19 <bollu> I also think kmett told me something about writing Applicative category-theoretically using Day?
02:30:44 <bollu> like, you get monads if you "complete" the endofunctor structure in one way, and Applicative in another way or something of the sort?
02:30:50 <johnw> Applicative is a monoid object in the category of endofunctors, where Day is the "mappend"
02:30:51 <bollu> I didn't really understand it very well
02:31:17 <bollu> johnw: then where do we get the extra Monad strength? isn't Monad also the monoid of endofunctors?
02:31:19 <johnw> http://stackoverflow.com/questions/35013293/what-is-applicative-functor-definition-from-the-category-theory-pov
02:31:39 <johnw> Monad is a monoid object in the category of endofunctors, where functor composition is the "mappend"
02:32:06 <johnw> Alternative is yet another monoid object in the same category
02:32:26 <bollu> johnw: oh, different notions of (<>) gives different objects? I see.
02:32:29 <johnw> yes
02:32:44 <bollu> johnw: so that would be similar to how (Z, +) and (Z, *) can both be monoids on the same underlying structure Z, right?
02:32:54 <johnw> there's a paper on this very subject, btw, that talks a lot about Day
02:33:00 <bollu> johnw: link, please?
02:33:11 <johnw> looking
02:33:31 <johnw> www.fceia.unr.edu.ar/~mauro/pubs/Notions_of_Computation_as_Monoids.pdf
02:33:34 <bollu> "a monoidal category is a category equipped with a tensor product and a unit object" - Why is it called "tensor product"?
02:33:39 <johnw> this is a wonderful paper
02:33:56 <johnw> it's a tensor product because of the laws it comes with
02:34:00 <bollu> tensor product in lin. alg. is something that lets you get a new space of dim(V tensor W) = dim V * dim W
02:34:10 <johnw> they aren't exactly the same as the monoid laws, because they rely on isomorphism, not equality
02:34:13 <bollu> johnw: you get multi-linearity or something?
02:34:20 <bollu> johnw: oh
02:34:44 <johnw> I'm not sure why the choice of the word "tensor" in this context
02:34:55 <johnw> but probably it arises by analogy to something from linear algebra
02:35:05 <bollu> johnw: I see, so it's just a regular product?
02:35:15 <johnw> not quite
02:35:23 <johnw> although regular product are a reasonable choice for the tensor product
02:35:37 <johnw> think of it as a chosen operation within the category that relates to objects
02:35:58 <johnw> when you pick the choice of <> for the category, you're picking the tensor product
02:36:11 <johnw> and product (as in, tuples) is just one possibility
02:36:15 <bollu> johnw: so the tensor product in a category is just a monoid over the category?
02:36:27 <johnw> essentially, but with slightly different laws
02:36:39 <johnw> they look the same, just using ≅ instead of =
02:36:47 <bollu> johnw: what are the different laws? we just replace equality with isomorphism?
02:37:06 <bollu> so, like (a <> b) <> c ~= a <> (b <> c), a <> e ~= e <> a ~= a?
02:37:21 <johnw> it would be written:
02:37:30 <johnw> a ⊗ id ≅ a
02:37:45 <bollu> johnw: both left and right identity exist right?
02:37:52 <johnw> the tensor product of morphism a with the identity morphism is isomorphic to a
02:38:04 <johnw> yes, left, right and associative
02:38:17 <bollu> johnw: wait, this product structure is on the arrows of the category and not the objects? 
02:39:02 <johnw> oh, wait, I may have misspoken there
02:39:14 <johnw> let me check
02:39:27 <bollu> johnw: sure
02:40:47 <johnw> the products are applied to the objects, of course, you are right
02:40:54 <johnw> I was thinking of the definition of the monoidal object
02:41:15 <johnw> anyway, check out that paper I linked you, it goes into all of this is great detail
02:41:43 <bollu> johnw: cool, thanks :)
02:41:55 <bollu> johnw: so it is "lax" because we weaken it as "up to isomorphism"?
02:41:57 <johnw> and link it to the Cayley representation of a Monoid in a rather beautiful way, explaining along the way how difference lists arise, and by direct analog the Codensity transformation
02:42:09 <johnw> where did you see "lax"?
02:42:22 <bollu> "Such an up-to-isomorphism structure is called lax, so cartesian product forms a lax monoidal structure in Hask."
02:42:27 <bollu> stackOverflow question
02:42:31 <johnw> ah, I see
02:42:45 <johnw> not qualified to say, but that sounds right
02:43:04 <bollu> johnw: and "strength"?
02:44:03 <johnw> what about strength?
02:44:31 <bollu> johnw: what is it, exactly?
02:44:38 <bollu> johnw: is it a measure or something? on a category?
02:45:12 <troydm> so here is my problem: I have some 500mb file id load it into lazy bytestring using readFile and I then use index function to read each character from that file and it takes a very long time. what is wrong?
02:45:13 <johnw> it usually means the ability to transport products into some structure
02:45:23 <johnw> like: (m a, b) -> m (a, b)
02:45:49 <johnw> a monad can do that is call strong (which all Haskell monads are)
02:46:26 <johnw> troydm: have you profiled your application?  there are a few things that could cause that
02:46:54 <troydm> johnw: I profiled my application and found out that 70% time takes calling index function 
02:46:55 <bollu> johnw: oh, so you should be able to "commute" the product structure?
02:47:00 <johnw> bollu: for more on strength, see arxiv.org/pdf/1309.5132
02:47:09 <troydm> johnw: from Data.Bytestring.Lazy.Char8 module
02:47:22 <johnw> bollu: not entirely sure I know what you mean well enough to answer that questio
02:47:40 <johnw> troydm: what about your allocation stats?
02:48:08 <bollu> johnw: I meant that if you think of product as some kind of p :: * -> * -> *, then you want p (m a) b -> m (p a b) right?
02:48:12 <johnw> often when there's strange slowness, you could be churning (allocating and deallocating a ton), or producing lots of thunks that you then later collapse
02:48:37 <johnw> bollu: oh, I see, yes, commute, distribute, etc.
02:48:45 <troydm> johnw: only 12% is for bytestring
02:49:04 <johnw> what's the total allocation during the run of the application?
02:49:33 <troydm> total alloc = 1,547,484,448 bytes  (excludes profiling overheads)
02:49:49 <johnw> oh, that's only 3x larger than your data file
02:50:02 <johnw> although, it's high if you only intended to read in little bits at a time
02:50:22 <troydm> johnw: I'm indeed trying to do that
02:50:30 <johnw> a typical application like you described should have a total alloc of, say, 10 megabytes, not 1.5 gigabytes
02:50:33 <troydm> johnw: I'm not sure, maybe I should switch to strict?
02:50:37 <johnw> so something is needlessly allocating
02:50:44 <johnw> switching to strict is not always the answer in these cases
02:50:50 <johnw> it could also be that you're not lazy enough
02:50:52 <troydm> I can dump you a .prof log
02:50:52 <johnw> can you show the code?
02:51:09 <johnw> yeah, and the .prof log would be good
02:51:14 <johnw> then I have to go to bed ;)
02:51:27 <troydm> johnw: okey just a sec
02:54:48 <troydm> I had to cut it short as there is limit to refheap paste size
02:54:53 <troydm> but all relevant info is there
02:54:57 <troydm> https://www.refheap.com/4a659e354b55985efa7174619
02:54:59 <johnw> thx
02:56:00 <troydm> sure, thank you for your time
02:56:10 <[connor]> testing testing testing (ignore me)
02:56:32 <johnw> sorry, it doesn't jump out at me from the report
02:56:47 <johnw> i can't say whether the total alloc is due to excessive residency, or churn
02:57:11 <johnw> however, there is a technique you could use
02:57:22 <johnw> see http://neilmitchell.blogspot.com/2015/09/detecting-space-leaks.html
02:58:22 <troydm> johnw: thx, will look into it, also will try switching to strict bytestring
02:58:41 <troydm> johnw: 500mb is memory footprint I'm willing to take as good afterall if it'll work
02:59:10 <troydm> johnw: as the method I need it for is only to import data which only runs once during setup of application
03:00:21 <[condab]> testing testing testing (please ignore me)
03:00:41 <lyxia> why don't you go test in an isolated channel
03:00:42 <johnw> hard to ignore you if you keep changing names!
03:01:19 <[condab]> roger, sorry guys
03:03:43 <troydm> johnw: okey this is strange but I've switched to strict bytestring and everything worked in few secs
03:04:16 <troydm> johnw: it was probably excessive I/O allocations that lazy bytestring does when trying to iterate over it using index function
03:07:07 <daniel_w> troydm: lazy bytestring are essentially lists of strict bytestrings, so indexing them can be slow
03:07:28 <troydm> daniel_w: figured it out the hard way
03:08:24 <daniel_w> Everything in haskell is a narrow tree unless otherwise stated
03:09:58 <troydm> I'm starting to appreciate OCaml more and more especially when I hit these kind of issues when working with Haskell
03:10:09 <troydm> I know it's my lack of knowledge + experience
03:10:11 <troydm> but still 
03:10:30 <daniel_w> It takes a bit of getting used to
03:11:03 <daniel_w> Eventually, you'll build up a good mental model
03:11:14 <daniel_w> and you'll be able to predict the performance of things
03:19:04 <nure> h-hi
03:22:34 <srhb> nure: Hi there.
03:28:37 * hackagebot htestu 0.1.1.0 - A library for testing correctness of pseudo random number generators in Haskell.  https://hackage.haskell.org/package/htestu-0.1.1.0 (DominicSteinitz)
03:35:23 <Shou> Is there a way to define a type-level operator (&) that would allow a user to chain Constraints for a variable, e.g. `(Num & Eq & Generic) a => ...`?
03:48:38 <ongy> Shou: how would that be differen from (Num a, Eq a, Generic a) => ?
03:49:25 <Shou> It's just a fun shorthand form.
03:50:19 <Shou> Like how the value-level ($) often allows you to omit parens.
04:01:04 <implementation> Shou: you could try to do that with -XConstraintKinds, a "type" alias and explicit kind annotations, but I'm not sure that works. 
04:02:28 <Shou> I tries implementing a type synonym family for it but I think we need type-level lambdas for this, unless I'm just not creative enough to think of a way around it.
04:05:02 <Gurkenglas> A function is in WHNF when it's a lambda expression, right?
04:05:09 <Gurkenglas> -when+iff
04:09:26 <implementation> Shou:  type (:&) (a :: * -> Constraint) (b :: * -> Constraint) (t :: *) = (a t, b t)   -- works when Data.Constraint from the package "constraints" is imported, with -XKindSignatures, -TypeOperators and -XConstraintKinds
04:11:07 <Drezil> can GHC diverge when you have isomorphic instances between 2 classes and use rewrite-rules for stream-fusion? because it takes fairly long to compile 100loc.. (about 15 mins now..)..
04:11:24 <implementation> alternatively one could take GHC.Prim.Constraint instead of the one from "constraints"
04:11:46 <Shou> implementation: Yeah but it only takes two constraints sadly.
04:14:41 <Shou> implementation: I think we'd need something like this https://u.teknik.io/Ys9ew.png
04:28:41 * hackagebot hedis 0.9.2 - Client library for the Redis datastore: supports full command set,  pipelining.  https://hackage.haskell.org/package/hedis-0.9.2 (k_bx)
04:54:18 <pkug> is it a poor practice to count elements in the list like this: let elemCount xs x = foldl (\a b -> if b == x then a + 1 else a) 0 xs -- ??
04:56:02 <Axman6> pkug: why not length . filter (== b)?
04:56:19 <Axman6> (so yes, many would consider that bad style)
04:58:03 <pkug> Axman6: there you go, thanks :)
05:06:32 <Gurkenglas> Write fmap, nobody bats an eye, write (.), everyone loses their minds
05:08:43 * hackagebot hedis 0.9.3 - Client library for the Redis datastore: supports full command set,  pipelining.  https://hackage.haskell.org/package/hedis-0.9.3 (k_bx)
05:10:21 <ongy> Gurkenglas: what about <$>?
05:10:52 <Gurkenglas> fmap is more useful when you're using it like a lens
05:11:24 <Gurkenglas> Compare "(fmap . fmap) modifyT . fmap EitherT" to "((.) . (.)) modifyT . (.) EitherT"
05:23:44 * hackagebot aeson 0.11.2.1 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-0.11.2.1 (AdamBergmark)
05:43:45 * hackagebot aeson 1.0.0.0 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-1.0.0.0 (AdamBergmark)
05:46:29 <greenrd> http://stackoverflow.com/questions/38814153/update-intero-flycheck-after-changing-cabal-file
05:46:39 <Axman6> ooo, how exciting, Aeson 1.0
05:48:08 <dramforever> greenrd: Have you tried M-x intero-restart ?
05:48:29 <puregreen> Axman6: yeah, now with 50% more overengineering :( I understands that there were valid reasons for all the changes they did, but I'm also wishing a simpler library was available
05:49:15 <puregreen> okay, fine, 20% more overengineering, not 50%
05:49:20 <dramforever> (Assuming that you are the one asking. I don't have an account on SO)
05:57:10 <Profpatsch> instance ToMarkup Site where
05:57:11 <Profpatsch>   toMarkup Site{..} =
05:57:41 <Profpatsch> That’s pretty straightforward, but I want to add i18n
05:58:32 <Profpatsch> I thought maybe something like toMarkup (t, Site{..}) where t is a function TranslationItem -> Html
05:59:22 <Profpatsch> But that doesn’t look that elegant to me.
06:00:58 <Eduard_Munteanu> Profpatsch, well, yeah, the HTTP request should indicate the desired language
06:02:23 <Profpatsch> Eduard_Munteanu: Of course. I‘ve got a class RenderMessage that can translate a type to a Markup abstraction
06:02:49 <Profpatsch> It’s basically the class from https://hackage.haskell.org/package/shakespeare-2.0.11/docs/Text-Shakespeare-I18N.html modified a bit.
06:03:03 <Eduard_Munteanu> Profpatsch, what framework are you using?
06:03:13 <Profpatsch> Eduard_Munteanu: None.
06:03:18 <Eduard_Munteanu> Oh, ok.
06:03:52 <Profpatsch> It’s more about to best inject the translation into my ToMarkup class.
06:04:05 <Profpatsch> A tuple is probably pragmatic.
06:05:23 <greenrd> @dramforever Thanks. Since you don't have an account, I posted your answer.
06:05:23 <lambdabot> Unknown command, try @list
06:05:45 <implementation> maybe you shouldn't instantiate ToMarkup for Site, but for something like a LocalSite (which would be a Site + extra information)
06:06:26 <Profpatsch> implementation: Yes, Site is already a combination type of the site data.
06:06:56 <Profpatsch> But I split it a bit, so there is a separate ToMarkup instance for TaskList
06:07:52 <Profpatsch> Hm, I think type Translated a = (Markup -> Html, a) is nice.
06:08:07 <Profpatsch> Then my routes are Get '[HTML] (Translated Site)
06:12:28 <edwardk> johnw, bollu: Day isn't 'mappend' in that scenario, it is (,). Identity is ().
06:32:07 <sphinxo> given the following data structures and accessors http://lpaste.net/2477578238616928256
06:32:56 <sphinxo> How should I determine if a team has one? ( in the context of tic tac toe )
06:33:47 <sphinxo> now I know I can apply functions like  fmap (fmap (\x -> x /= Nothing)) <grid>
06:34:17 <sphinxo> and things like  over (_x . traverse) (\x -> Just O) <grid>
06:34:29 <sphinxo> or  over (traverse . traverse) (\x -> Just O) <grid>
06:34:53 <sphinxo> or  over (_x . _x) (\x -> Just O) <grid>
06:37:25 <sphinxo> fmap (\(Vec3 a b c) -> a == b && b == c && a == c && a /= Nothing) initialGrid 
06:37:44 <sphinxo> I can do that for horizontal checking
06:38:10 <sphinxo> but how should I do vertical without lots of deconstructing?
06:39:05 <sphinxo> and diagonal?
07:00:56 <osfameron> sphinxo: you could transpose the array 
07:01:42 <osfameron> e.g. and then just run the exact same check, but on the transposed structure
07:02:50 <sphinxo> that's a pretty neat approach
07:03:20 <bollu> what's a Day convolution? I still don't get how it's a different monoid structure on the Hask category
07:04:43 <osfameron> sphinxo: yeah it's quite cute.  bit more complex to do for the diagonal (but if you only have a 3x3 grid as per traditional then you can easily transform info a grid of [sw-ne diagonal, nw-se diagonal])
07:14:23 <athan> Does anyone here know of a Map-like structure that's optimal for multiple queries at one time?
07:14:32 <athan> (ideally hashmaps! :c)
07:15:03 <athan> So something like `lookupMany :: HashSet k -> HashMap k a -> [a]` or something
07:15:14 <athan> :\
07:15:23 <Athas> What is the best way to efficiently resize an STUArray?
07:17:29 <athan> Athas: I _think_ pruning, but I shouldn't talk because I've never used it
07:20:11 <mpickering> How can I get stack to do a heap profile? (-p -hc) 
07:20:15 <cheater> hi
07:20:17 <cheater> hello
07:20:18 <cheater> hi
07:23:31 <athan> Athas: I think you're best bet is to build a new one out of bounds :\
07:23:39 <athan> from the looks of it, arrays are intended to have static size
07:23:47 <athan> maybe you need something like a vector?
07:24:11 <athan> Athas: https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Storable-Mutable.html
07:24:45 <Athas> athan: hm, interesting.
07:25:07 <Athas> I've made something that performs... decently... using getElems/newListArray, but I really end up longing for C here.
07:35:51 <Athas> athan: actually, that looks quite like what I want.  Thanks!  It's still striking how poor Haskell is at array programming.
07:37:31 <Athas> Actually, can someone see a space leak in this program?  https://gist.github.com/Athas/d4e77e187328853fb56529d55dec8bd8  It just reads a newline-separated array of Ints from standard input, but consumes huge amounts of memory for e.g. a hundred million lines.
07:39:50 <athan> Athas: Same here haha
07:41:05 <athan> Athas: I'd bet it's from resizeArrayTo
07:41:19 <Athas> athan: yeah, definitely.  The list of the old elements is sticking around, maybe.
07:41:19 <athan> that's just asking for tons of rebuilds of your array
07:41:42 <Athas> Sure, but only the old and the new array should be in memory concurrently.  The older ones should be garbage-collected.
07:41:57 <Athas> And the object graph for this program should be tiny, since the arrays are atomic to the garbage collector (I hope).
07:42:33 <athan> iirc, ST is hard to garbage collect
07:42:43 <athan> but this is out of my leage so I'm just spitballing :\
07:42:45 <Athas> Ugh... that could be it, then.
07:43:03 <Athas> (Although that would make STArrays kind of dangerous.)
07:43:06 <athan> ahh here's a thought
07:43:11 <athan> line 39
07:43:23 <athan> you're creating new references... _sometimes_
07:43:43 <athan> not if you only use component-wise maps, I think!
07:44:27 <athan> (btw is there a zip-esque componentwise join? Like `merge :: (a -> b -> c) -> Array a -> Array b -> Array c`?
07:44:52 <Athas> Hm, how do I turn an MVector into a Vector (or an Array)?
07:44:58 <athan> s.t. it just folds them in parallel? The sucky-thing is arrays aren't sized at the type level so you can't avoid that zipping thing
07:45:09 <athan> freeze, I think
07:45:24 <Athas> I can't find a freeze function.
07:45:39 <Athas> Oh, it's generic.
07:45:59 <athan> :s
07:46:16 <Athas> Wait, no, it's only for non-mutable vectors.
07:46:17 <Athas> So... ugh.
07:46:29 <lyxia> http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector.html#v:freeze
07:47:14 <Athas> There we go!  Thanks!
07:50:55 <lyxia> Athas: I think your program consumes lots of memory because it stores the whole input before doing anything with it.
07:51:29 <Athas> lyxia: no, that's not it.  The whole input is only a few hundred megabytes for cases where I see the program consuming gigabytes upon gigabytes.
07:51:44 <lyxia> oh ok.
07:53:15 <safran64> hi from a newbie
07:54:31 <lyxia> hi
07:55:10 <athan> Athas: You might dig repa too btw, if you're doing numeric stuff: http://hackage.haskell.org/package/repa-3.4.1.1/docs/Data-Array-Repa.html
07:55:27 <Athas> athan: actually, I'm just trying to parse large arrays.
07:55:44 <Athas> I don't intend to do any real computation on these things - I just need them represented!
07:56:13 <athan> oh hm
07:56:22 <athan> do you want a constant-space streaming parser?
07:56:50 <Athas> No, I want the entire array stored in memory afterwards.
07:57:04 <Athas> I just need it to efficiently handle not-all-that-large arrays (my largest datafile is 80MiB).
08:04:16 <Athas> This works well: https://gist.github.com/Athas/bb38562801e8417ff0a1c5b4ad614a01
08:04:24 <athan> Athas: In this code it looks like you're building your own state monad on top of ST or something
08:04:29 <Athas> Unboxed mutable vectors rock.  Thank you, athan!
08:04:29 <athan> er old code
08:04:36 <athan> np :)
08:07:27 <lyxia> I'm not sure what went wrong when you were using arrays. :/
08:08:12 <athan> lyxia: I think the issue was when they kept rebuilding new ones. Isn't that a no-no?
08:08:24 <Athas> I rebuild new vectors now.
08:08:37 <Athas> These vectors just have a much better implementation of growing.
08:08:51 <lyxia> no, because the arrays grow exponentially in size
08:09:17 <lyxia> https://en.wikipedia.org/wiki/Dynamic_array
08:20:32 <Profpatsch> Hm, can’t I use lambda case to do more sparce function pattern matching?
08:20:40 <Profpatsch> foo :: A -> B
08:20:44 <Profpatsch> foo = \case
08:20:52 <Profpatsch>   A1 -> …
08:21:00 <Profpatsch> gives me a parse error.
08:21:24 <Profpatsch> *sparse
08:21:26 <lyxia> paste the full code
08:21:33 <Profpatsch> lyxia: Should it be possible?
08:22:20 <Profpatsch> Ugh, my bad.
08:22:33 <lyxia> it should
08:22:35 <Profpatsch> I had {-# LambdaCase #-}
08:22:54 <Profpatsch> Forgot the LANGUAGE. Should enable wall probably
08:23:39 <srhb> Profpatsch: -Wunrecognized-pragmas is good too :-)
08:23:57 <Profpatsch> I thought there was something like that. :)
08:32:41 <Profpatsch> What’s the ~ do? a <| ~(b :| bs) = a :| b : bs
08:34:01 <lyxia> it's a lazy/irrefutable pattern
08:34:57 <lyxia> it delays pattern matching to when b or bs is evaluated
08:36:31 <Profpatsch> Interesting
08:37:24 <c_wraith> It also causes an error if the pattern doesn't match - later, when the value is used.
08:37:37 <c_wraith> It's the same thing as pattern-matching in a let binding
08:37:44 <c_wraith> Which has those same properties
08:42:05 <troydm> what's the most easiest and correct way to convert bytestring into Int?
08:42:37 <troydm> I'm using fromInteger . read . C.unpack but it seems too long
08:43:58 <glguy> if you're treating the bytes as ASCII, there's a readInt in there somewhere
08:44:13 <glguy> check the index
08:44:34 <ongy> Data.Bytestring.Char8
08:52:09 <ongy> btw. is there a reason, readInt is for Int and not 'Num a' (or something similar if it's better fitting)
08:53:17 <nitrix> There's a readInteger too.
08:55:31 <joe9> Is there a : whenRightM :: Applicative m => Either a b -> (b -> m a) -> m a ? somewhere
08:55:49 <joe9> I find the Data.Either to be very limited when working with monads? Is there a reason for that?
08:58:47 <athan> joe9: You could catch!
08:58:53 <athan> @type catch
08:58:54 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
08:59:12 <athan> @type catchError
08:59:13 <lambdabot> MonadError e m => m a -> (e -> m a) -> m a
08:59:16 <athan> :)
08:59:31 <ongy> nitrix: so the intended way for Word would be 'fmap (\(a, b) -> (fromIntegral a, b) . readInt'?
08:59:42 <joe9> athan: catch is for exceptions raised, correct? I have an either value coming through.
08:59:45 <glguy> joe9: case expressions work well for these sorts of random need
09:00:10 <joe9> glguy: what do you think of EitherT? good idea?
09:00:13 <athan> joe9: `Either e` is an instance of `MonadError e m` :)
09:00:24 <athan> plus, that's the behavior of Either
09:00:27 <athan> Left is consumptive
09:00:51 <athan> er wait sorry
09:01:02 <athan> glguy knows better
09:01:13 <athan> you're not using Either as a monad, you're using it as a value :x sorry
09:01:17 <ongy> readInteger of course, since readInt has a lower bound
09:01:24 <glguy> joe9: if you need one of those ExceptT from transformers is probably the place to start
09:02:20 <joe9> my library provides an Either e a value for any call. I am figuring out the best way to thread all these Either values in the IO monad.
09:02:35 <joe9> I could just split out the pure either code to a separate function.
09:02:41 <joe9> glguy: ^^
09:14:14 <ongy> joe9: maybe ExceptT
09:14:26 <ongy> oh, I should read one more line up -.-
09:35:22 <joe9> Which is recommended? Control.Exception.Lifted or Control.Exception.Safe?
09:37:36 <athan> Control.Monad.Catch! :D
09:37:46 <athan> that's the one I use anyway
09:45:31 <athan> is an `fmap` over a list considered "pointwise" or "componentwise"?
09:45:40 <athan> I mean, I might not be thinking clearly here
09:46:00 <athan> I feel like the default effect instance of lists is "pointwise" / cartesian, while ZipList captures "componentwise"
09:46:13 <athan> but I have got this inkeling that fmap is pointwise for some reason
09:53:46 <ocramz> hey there
09:54:33 <ocramz> why does `toRational x/y` reduce the fraction, if y is an integral multiple of x?
09:55:03 <ocramz> > toRational 2/4
09:55:04 <lambdabot>  1 % 2
09:56:45 <pavonia> ocramz: 2/4 and 1/2 are mathematically the same, Rational relfects that
09:57:50 <hpc> :t toRational
09:57:51 <lambdabot> Real a => a -> Rational
09:58:16 <hpc> ocramz: what types can differentiate between (2/4) and (1/2) to begin with?
09:58:19 <dmwit_> athan: `fmap` has the same implementation in both instances.
09:58:25 <geekosaur> more practically, because rationals become harder to work with the larger the denominator gets, so the denominator gets minimalized whenever possible
09:58:27 <hpc> it defaults to Double, so you're always passing 0.5f to it
09:58:52 <dmwit> hpc: ...no
09:59:01 <dmwit> > (2/4) :: Expr
09:59:03 <lambdabot>  2 / 4
09:59:20 <hpc> oh blargh, it's (toRational 2) / 4
09:59:37 <hpc> that kind of crap is why you put spaces around infix operators 100% of the time
09:59:42 <ocramz> dmwit: what's Expr?
10:00:09 <dmwit> ocramz: A really stupid type that just records all the operations you do and prints them instead of "performing" the operations.
10:00:12 <dmwit> ?where simple-reflcet
10:00:12 <lambdabot> I know nothing about simple-reflcet.
10:00:17 <dmwit> ?hackage simple-reflect
10:00:17 <lambdabot> http://hackage.haskell.org/package/simple-reflect
10:00:33 <dmwit> Well. I mean stupid in the most endearing way possible.
10:00:39 <ocramz> dmwit :)
10:01:28 <hpc> Expr is effectively a newtype around String
10:02:03 <dmwit> What Expr should be: an AST for the type classes it implements, + a Show instance that traverses the AST.
10:02:35 <dmwit> Unfortunately, for some reason it has been prematurely optimized. They used the standard deforestation technique and assumed that Show would be the only consumer.
10:03:24 <dmwit> I mean, I can sort of understand: the deforested version doesn't need special AST nodes added for each new instance. But it does reduce the usefulness of the package by a bit.
10:06:06 <hpc> fun fact: deforestation optimization was invented by deforest kelly
10:07:54 <c_wraith> note: fun does not imply true
10:08:26 <hpc> indeed :D
10:10:52 <uwap> is there a good library for accessing sql databases that is not just low level bindings?
10:11:11 <oroa> does anyone play runescape
10:12:26 <c_wraith> uwap: you mean like esquilito or persistent?
10:13:05 <c_wraith> *esqueleto
10:14:01 * hackagebot haskell-src-exts-prisms 1.18.2.0 - Prisms with newtype wrappers for haskell-src-exts  https://hackage.haskell.org/package/haskell-src-exts-prisms-1.18.2.0 (DanielWaterworth)
10:14:26 <uwap> c_wraith, yes. like those. Is there something like this without quasi quotations? ^-^
10:15:33 <jle`> does esqueleto use quasiquotes?
10:15:52 <uwap> jle`: the docs like it does
10:15:54 <uwap> *look like
10:15:59 <c_wraith> well, it does for the schema, since it uses persistent for that.
10:16:04 <c_wraith> I think, anyway
10:16:20 <jle`> ah yeah that
10:16:46 <c_wraith> there's also groundhog, maybe?
10:17:15 <mitchty> anyone used inline-c with stack perchance? doesn't seem to be invoking CC to produce the c file and its complaining it doesn't exist
10:17:40 <c_wraith> Nope, groundhog also uses quasiquotes.
10:17:42 <uwap> c_wraith: which also uses persistent for database schemes
10:27:40 <mitchty> hrm, got it further to the linker complaining, progress i guess
10:28:07 <jle`> congrats on the aeson team for their 1.x release
10:28:13 <jle`> *congrats to
10:29:02 * hackagebot io-streams-haproxy 1.0.0.0 - HAProxy protocol 1.5 support for io-streams  https://hackage.haskell.org/package/io-streams-haproxy-1.0.0.0 (DougBeardsley)
10:42:01 <mitchty> doh, stupid mistake, was testing stuff from math.h and didn't have libm installed, lazy sunday for me >.<
10:49:03 * hackagebot polar-configfile 0.5.0.0 - Fork of ConfigFile for Polar Game Engine  https://hackage.haskell.org/package/polar-configfile-0.5.0.0 (Shockk)
10:49:32 <Shockk> I was just about to ask about hackage not updating, and to ask how long it might take, but I guess hackagebot answered my question
10:49:33 <Shockk> thanks
10:50:43 <Gurkenglas> "haskell-src-exts-1.17.1 depends on old-time-1.1.0.3 which failed to install." but https://hackage.haskell.org/package/haskell-src-exts-1.17.1 doesn't list old-time :(
10:53:28 <osfameron> any recommendations for Vim colourschemes with Haskell?  not sure if it's just me, but I can't get any of them to work consistently (and usefully) except Solarized
10:53:45 <osfameron> (but I find solarized a bit low-contrast for my liking)
10:53:58 <mitchty> osfameron: i use emacs but i just use solarized out of sheer laziness
10:54:03 * hackagebot mandrill 0.5.2.3 - Library for interfacing with the Mandrill JSON API  https://hackage.haskell.org/package/mandrill-0.5.2.3 (AlfredoDiNapoli)
10:54:05 <ashutosh> railscasrs is good for me
10:54:13 <ashutosh> railscasts
10:55:08 <joe9> osfameron:zenburn?
10:56:02 <osfameron> ashutosh: it looks quite nice in gvim (no dice in my console) but doesn't seem to highlight as many things - punctuation etc.
10:56:23 <osfameron> joe9: looks *very* subtle?
10:57:41 <ashutosh> yes. I agree it is lacking in syntax highlighting. But as an absulute beginner, I dont seem to miss much
10:58:13 * osfameron should get a mac with iTerm rather than hopelessly trying to get Win10 + ConEmu + Console Vim to do anything useful with colorschemes...
10:58:33 <osfameron> ashutosh: oh fair enough!  it's a personal pref I suppose, just wasn't sure if I was doing something wrong tbh
10:58:37 <ashutosh> Haha. 
10:59:17 <ashutosh> I had enough trouble setting up vim on widows. :P 
10:59:24 <mitchty> osfameron: maybe try the linux subsystem and unicode rxvt?
10:59:27 <ashutosh> *Windows
11:00:12 <Eduard_Munteanu> There was someone in here working on a structural editor. Any clues?
11:00:24 <osfameron> mitchty: I tried that a while back and can't remember why I didn't like it.  It turned out that ConEmu + Git Bash + Vagrant is almost Good Enough as a dev environment (but not if you want colourschemes to work ;-)
11:01:06 <mitchty> osfameron: ah fair enough, i haven't done much with windows 10 besides install it into a vm and then archive it off for some snowy winter day
11:01:09 <Shockk> hello, I'm having an issue with type inference, from what I can gather, in the following code:
11:01:12 <lpaste> Shockk pasted “ForceRetrieve.hs” at http://lpaste.net/174891
11:01:41 <lpaste> Shockk revised “ForceRetrieve.hs”: “ForceRetrieve.hs” at http://lpaste.net/174891
11:03:25 <Shockk> as far as I know, if I'm passing (As :: As GL.VertexArrayObject) like this, the first instance should be selected, and since `a` would be GL.VertexArrayObject, the result should be `m GL.VertexArrayObject`
11:03:52 <Shockk> this isn't the case though, I'm getting an ambiguous type variable error
11:04:19 <Shockk> and I have to explicitly type that whole forceRetrieve expression as `:: Core GL.VertexArrayObject`
11:04:31 <Shockk> am I misunderstanding something or doing something wrong here?
11:07:59 <Eduard_Munteanu> Shockk, well, that forceRetrieve is going to give you a String -> Core GL.VertexArrayObject, AFAICT
11:08:10 <Eduard_Munteanu> Sorry.
11:08:13 <Eduard_Munteanu> Window overlap.
11:08:59 <Shockk> the type of forceRetrieve on line 17 should be the following:
11:09:04 * hackagebot these 0.7.2 - An either-or-both data type & a generalized 'zip with padding' typeclass  https://hackage.haskell.org/package/these-0.7.2 (phadej)
11:09:12 <Shockk> forceRetrieve :: As a -> String -> m a
11:09:35 <Shockk> because it doesn't match the other instance which is just String -> m a
11:10:06 <Shockk> so in this case, if I'm passing an (As GL.VertexArrayObject) into it, the type variable `a` should be GL.VertexArrayObject
11:10:10 <mitchty> ok hopefully quick and easy question, if i define a flag in my cabal file, does that show up as something I can detect via CPP
11:10:24 <Eduard_Munteanu> Shockk, what is the exact error?
11:10:46 <Shockk> I'll copy and paste it
11:11:09 <lpaste> Shockk pasted “forceRetrieve error” at http://lpaste.net/174895
11:11:56 <Shockk> bear in mind that (Control.Monad.Trans.RWS.Lazy.RWST CoreEnv CoreOutput CoreState IO) is just "Core"
11:12:00 <Shockk> in case it's hard to read
11:12:41 <Eduard_Munteanu> Shockk, are you using TypeSynonymInstances?
11:12:57 <Shockk> hmm, yes
11:13:21 <Shockk> would that cause issues?
11:14:02 <Shockk> actually, I don't think I'm using any in that file, so I can disable them, but it has the same error still
11:14:14 <hexagoxel> mitchty: https://github.com/ekmett/lens/blob/master/lens.cabal#L303
11:14:35 <Eduard_Munteanu> Shockk, write the instance without the synonym
11:14:45 <mitchty> hexagoxel: ah, ok so bit hacky but no big deal, danke schön!
11:16:10 <Shockk> Eduard_Munteanu: I mean, there are no type synonym instances there, I removed {-# LANGUAGE TypeSynonymInstances #-} and I get the same error in that paste
11:17:03 <Eduard_Munteanu> Oh, doh, my bad.
11:17:15 <Shockk> that's okay
11:17:30 <Shockk> I'm very confused at this
11:17:34 <bizarrefish> Hi all
11:18:16 <Eduard_Munteanu> Shockk, what else is there in the do block? Unless some constraints arise from it, the type variables may be distinct.
11:18:20 <bizarrefish> I'm having a rough time getting my head around what you can do with an applicative that you can't do with a functor. I can see examples and accept them, but I have no intuition of it.
11:18:44 <Shockk> the other stuff in the do block doesn't make use of `vao` at all, but I can paste it if you like
11:18:44 <bizarrefish> I've been reading about this all day; perhaps I should stop...Hammocktime.
11:19:05 <Eduard_Munteanu> Shockk, don't paste. That's the problem.
11:21:40 <Shockk> hmm, well, the do block is typed `Core ()` and the other lines in it are all calls to liftIO, to do GLFW or OpenGL stuff, and each of those is typed `IO ()` (plus the liftIO to lift it into `Core`)
11:22:18 <Shockk> I don't know if that's the question you were asking
11:22:26 <Shockk> I don't really know how else to answer it though
11:23:33 <Eduard_Munteanu> Shockk, I'd suggest doing away with all that As stuff and using something like   (vao :: GL....) <- forceRetrieve "vao"
11:24:39 <Eduard_Munteanu> (you need ScopedTypeVariables for that type annotation)
11:24:58 <Shockk> hmm
11:25:03 <Shockk> I mean, that's a solution
11:25:14 <Shockk> I'm interested to know why this doesn't work though
11:25:53 <Eduard_Munteanu> Shockk, because instance selection happens after types have been inferred.
11:26:28 <Eduard_Munteanu> And inference gives a more general type, using two type variables, so it doesn't fit any of the instances.
11:26:29 <Gurkenglas> I want to make a VM to compile a package that won't compile under Windows. What sort of image should I use? I have Windows 10, and VirtualBox installed.
11:27:30 <Shockk> hmmm okay
11:28:58 <kadoban> Gurkenglas: Maybe the xfce version of linux mint? Probably doesn't matter overmuch really.
11:29:03 <ongy> Gurkenglas: do you just want to check if it compiles, or why do you want it in a VM?
11:29:14 <Gurkenglas> check if it compiles
11:29:43 <Gurkenglas> can you do that on windows ignoring all the packages that didnt build? :D
11:31:20 <Eduard_Munteanu> No, not really.
11:33:21 <Gurkenglas> (i guess it might be useful to be able to run the tests, but ehh ill take compiling)
11:34:05 * hackagebot slug 0.1.5 - Type-safe slugs for Yesod ecosystem  https://hackage.haskell.org/package/slug-0.1.5 (mrkkrp)
11:34:08 <ongy> unless you have weird-ish tests, you will be able to run them
11:35:56 <ggole> Type safe slugs. What a time to be alive.
11:36:07 <ggole> No longer will we be plagued by dynamic mollusc failure.
11:38:53 <mitchty> ok inline-c is easily the most fun i've had interacting with c in any language to date
11:39:30 <mitchty> wrapping stuff into monads to handle stuff like free() calls etc.. is rather nice
11:39:45 <mitchty> could use a lot more examples however
11:41:28 <ongy> mitchty: monad for memory managment? sounds fancy. Is your code public?
11:41:52 <mitchty> ongy: nope, just farting around avoiding sunburn sunday
11:42:38 <mitchty> not really sure what i'm doing, just throwing spaghetti at the wall
11:43:40 <mitchty> and figuring out how i can use this for a c library i have to use that has a crazy amount of mutation
11:43:51 <ongy> :t (>>=)
11:43:52 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:44:03 <mitchty> figured i'd end up in a state monad eventually so i'm just playing around
11:45:00 <Eduard_Munteanu> I've recently seen bracket used with codensity to make things like that nicer.
11:51:33 <mitchty> Eduard_Munteanu: i'm not familiar with bracket, any links?
11:51:42 <Eduard_Munteanu> :t bracket
11:51:44 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:52:32 <Eduard_Munteanu> mitchty, you use it like    bracket (malloc size) free $ \buf -> ...
11:53:21 <mitchty> ah, that would be simpler, more stuff to read up on then thanks Eduard_Munteanu
11:53:34 <Eduard_Munteanu> https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Exception.html#g:15
11:54:14 <mitchty> so i still feel like i'm a barely competent beginner in haskell, too much stuff to learn
11:59:07 * hackagebot stache 0.1.5 - Mustache templates for Haskell  https://hackage.haskell.org/package/stache-0.1.5 (mrkkrp)
12:00:13 <__Myst__> Is there any reason to *not* use LANGUAGE pragmas?
12:01:19 <wagle> is it a bug that haskell createSymbolicLink "dir1/file1" "dir2/file2" work, but doesnt create a viable link, whereas createSymbolicLink "dir1/file1" "../dir2/file2" in disallowed?
12:02:56 <Eduard_Munteanu> __Myst__, portability among compilers or simply because an extension is a bad idea.
12:03:06 <Eduard_Munteanu> (one in particular)
12:04:06 <__Myst__> Eduard_Munteanu: Which one, and are there even any compilers apart from GHC?
12:04:10 <geekosaur> wagle, it's doing what the system call does. people always want the system call to work differently from how it works, which is consistent with rename() and link() etc.
12:04:18 <Shou> Are there any extensions that conflict? Also I think some extensions introduce inconsistencies to the type system when used incorrectly but I can't say which one right now.
12:04:45 <Eduard_Munteanu> __Myst__, yes, there are. And one possibly bad idea is OverlappingInstances.
12:04:53 <Eduard_Munteanu> But I gotta go eat something.
12:05:59 <ongy> What's so bad about OverlappingInstances?
12:06:31 <wagle> geekosaur: seems you are right  but I coulda sworn it worked 10 years ago
12:06:35 <hpc> it allows you to write instances such that a particular use can resolve to multiple instances
12:06:56 <Eduard_Munteanu> ongy, you can change program behavior by simply adding instances.
12:07:02 <hpc> instance Show a => Show [a] where ...
12:07:06 <hpc> instance Show String where ...
12:07:25 <hpc> do you show "abc" as "abc" or as ['a', 'b', 'c']?
12:07:26 <ongy> I know, I have used it (or the I think newer version with {-# OVERLAPPABLE #-} to define "better" Show instances if possible
12:07:33 <wagle> really dont want to chdir() around..  sigh
12:08:18 <hpc> wagle: honestly, if the solution is symlinks i would go find a different problem
12:08:21 <hpc> ;)
12:08:57 <wagle> tell that to the firefox config.. 
12:10:28 <wagle> oo!  withCurrentDirectory
12:28:56 <GreySunshine> Hello all, I am Vasanth
12:29:14 <buttbutter> Hi
12:29:50 <hpc> and they lived happily ever after
12:30:00 <buttbutter> :3
12:30:50 <buttbutter> Why are vim's movement keys mapped to hjkl and not jkl;?
12:31:17 <hpc> ask in -blah
12:31:56 <GreySunshine> Does ghc have a builtin Hash table, I am aware of Data.Map but that is a balanced binary tree, but a hash table with O(1) lookup is what I am looking for
12:33:06 <hpc> GreySunshine: https://hackage.haskell.org/package/hashmap
12:33:15 <dmj`> @package hashtables
12:33:15 <lambdabot> http://hackage.haskell.org/package/hashtables
12:35:36 <mheinzel> buttbutter: Yes, that is just strange.
12:36:15 <mheinzel> I remapped them.
12:36:39 <buttbutter> mheinzel: We're discussing in -blah :)
12:36:51 <mheinzel> Okay.
12:39:28 <Forlorn> Hi, I would be really grateful if someone could help me. I want to multiply "* (2.0^(n-1)) * 3.0" in my function
12:39:50 <Forlorn> if I append that above code to my function I get NaN but if I do it manually it works
12:39:55 <Forlorn> in GHCI
12:40:08 <Forlorn> http://sprunge.us/NYUC
12:40:23 <Forlorn> it is only 4 lines of code
12:40:36 <Forlorn> 5*
12:40:58 <Forlorn> what am I doing incorrectly?
12:41:21 <lyxia> Have you tried using Double instead of Float
12:41:25 <liste> Forlorn: what's `n' ?
12:41:28 <liste> in your invocation
12:41:37 <dmwit> Forlorn: `arch 1` works for me; what should I type to get `NaN`?
12:41:40 <Forlorn> n is an integer
12:41:47 <Forlorn> `arch 2`
12:42:27 <Forlorn> or n > 1 gives NaN for me
12:42:51 <lyxia> what did you do manually that works, exactly?
12:43:00 <dmwit> Forlorn: What are you expecting `sqrt (1-3^2)` to give...?
12:43:09 <Forlorn> arch n = (arch' n)
12:43:18 <Forlorn> if I just have the function like that
12:43:44 <dmwit> Forlorn: `arch' 2` calls `sqrt (1 - (arch 1)^2)`, and `arch 1` is `3`.
12:43:48 <dmwit> Forlorn: (To explain my question above.)
12:43:49 <Forlorn> and then in ghci write: (arch 2) * (2.0^(1)) * 3.0
12:45:30 <Forlorn> ooh, thank you
12:45:36 <lyxia> that's not at all equivalent to what you pasted. arch multiplies the result of every call to arch' by (2^(n-1) * 3) whereas your handwritten thing only multiplies the last one.
12:45:37 <Forlorn> I forgot to add the prime to the name
12:46:14 <Forlorn> yay, I am now calculating an approximate value of pi with archimedes method :D
12:46:45 <dmwit> ?where pi
12:46:45 <lambdabot> I know nothing about pi.
12:46:49 <dmwit> oh?
12:47:00 <dmwit> Have we lost the golfing results from ages ago? =(
12:47:09 <implementation> @hoogle pi
12:47:11 <lambdabot> Prelude pi :: Floating a => a
12:47:11 <lambdabot> package pi-calculus
12:47:11 <lambdabot> package pia-forward
12:47:28 <dmwit> shachaf: fixitfixitfixitfixit
12:47:52 <Forlorn> are there types that can hold more decimal places than floats?
12:48:01 <hpc> ?where pi_17
12:48:01 <lambdabot> I know nothing about pi_17.
12:48:09 <Forlorn> I want to preview as many digits as possible
12:48:12 <dmwit> Forlorn: `Double` has double the digits; `CReal` can hold arbitrarily many digits.
12:48:24 <dmwit> ?hackage numbers
12:48:24 <lambdabot> http://hackage.haskell.org/package/numbers
12:48:36 <dmwit> > pi :: CReal
12:48:37 <lambdabot>  3.1415926535897932384626433832795028841972
12:49:23 <dmwit> > drop 100 (showCReal 200 pi)
12:49:25 <lambdabot>  "798214808651328230664709384460955058223172535940812848111745028410270193852...
12:49:48 <Forlorn> thanks
13:12:37 <wagle> does the ! operator have a name that you can google for?
13:13:08 <hpc> @hoogle (!)
13:13:10 <lambdabot> Data.IntMap.Strict (!) :: IntMap a -> Key -> a
13:13:10 <lambdabot> Data.IntMap.Lazy (!) :: IntMap a -> Key -> a
13:13:10 <lambdabot> Data.Array.IArray (!) :: (IArray a e, Ix i) => a i e -> i -> e
13:13:16 <hpc> http://hoogle.haskell.org/
13:13:51 <wagle> wondering how to index the last element of a vector
13:14:53 <glguy> is there a "last" function?
13:15:42 <wagle> yess!  glguy wins!
13:17:22 <hpc> a brand new cdr!
13:39:14 <Shockk> hello, I've been trying to get some code working for a while and I wanted to ask about it;
13:40:08 <Shockk> if I have a data structure with a Lens into one of its records called `dyns`, and that record is typed as a Data.Array,
13:40:35 <Shockk> well, such as this: :: A.Array StorageIndex Dynamic
13:41:01 <Shockk> is there an easy way to do a lookup into that array using a lens?
13:41:25 <puregreen> Shockk: `ix` should work
13:41:43 <Shockk> puregreen: hmm I tried ix but I don't think it worked, let me try again
13:42:03 <puregreen> you'd need ^?! or ^? to do the lookup, not ^.
13:42:28 <Shockk> this is the line I've got currently:
13:42:29 <Shockk> retrieveDyn rep idx = use (storage . at rep . dyns . ix idx)
13:42:48 <Shockk> where rep :: TypeRep and idx :: Integer
13:42:49 <puregreen> then preuse instead of use and you'll need to handle the Nothing case
13:43:04 <Shockk> hmm preuse, let me look that up
13:43:38 <puregreen> ix can fail, therefore it's a traversal, therefore it needs functions that can account for the case when there are no values to return
13:43:46 <puregreen> (like preuse/preview/^?)
13:43:49 <Shockk> oh right right
13:44:14 <puregreen> (well, okay, view can work with traversals too but most of the time it wouldn't work for what people want it for)
13:44:34 <puregreen> (it combines results with mappend and thus requires a Monoid instance)
13:44:46 <Shockk> so before I was using a HashMap instead of an Array so I was using `at idx`; that works similarly in that in can fail to lookup, and returns Nothing in that case, right?
13:45:03 <puregreen> no, `at` is somewhat different
13:45:11 <Shockk> ah
13:45:31 <puregreen> `at` is a lens that views a `Maybe a` value, `ix` is a traversal that views an `a` value
13:45:48 <puregreen> the thing about `at` is that you can use it to insert values (by writing Just something thru it)
13:45:56 <puregreen> that's why `at` doesn't work with arrays or lists
13:46:03 <Shockk> ahh right
13:46:08 <johnw> edwardk: thanks for clarifying
13:46:38 <Shockk> hmm I tried the following:   retrieveDyn rep idx = preuse (storage . at rep . dyns . ix idx)
13:46:53 <Shockk> this is still giving me errors though
13:47:05 <puregreen> `at rep` is going to view a Maybe value
13:47:09 <puregreen> that might not be what you want
13:47:13 <puregreen> what's the type of dyns?
13:47:39 <puregreen> also, `preuse` will return a Maybe and if you don't want retrieveDyn to return a Maybe you'll have to unwrap it by yourself
13:47:42 <Shockk> dyns is Array Integer Dynamic
13:47:53 <Shockk> ah, I do want it to return the Maybe yes
13:48:07 <Shockk> I'm not sure how to deal with `at rep` giving a Maybe though
13:48:18 <puregreen> you mean, dyns is a lens that views an Array Integer Dynamic?
13:48:32 <Shockk> oh right, yes
13:48:35 <puregreen> you can write “storage . ix rep . dyns . ix idx”
13:48:43 <Shockk> it's just a generated one using makeFields
13:49:03 <puregreen> unless you need to handle the case when `rep` isn't found differently from the case when `idx` isn't found
13:49:05 <Shockk> puregreen: ahhh I see
13:49:13 <Shockk> oh wait
13:49:51 <puregreen> a) you can make retrieveDyn return Nothing when the lookup fails at either stage
13:49:55 <Shockk> if I used something like non' _Empty, would that work as I'd maybe expect it to work?
13:50:16 <Shockk> i.e. create if not exist
13:51:28 <puregreen> can you write what are the types of storage, rep, dyns, and idx; what result do you want when “ix rep” fails; and what result do you want when “ix idx” fails?
13:51:43 <Shockk> ah, one sec
13:51:51 <puregreen> because currently it's unclear (at least for me) what you want to create when what doesn't exist
13:51:52 <lpaste> Shockk pasted “Storage.hs” at http://lpaste.net/174935
13:52:04 <Shockk> I can understand that yep, sorry
13:52:08 <puregreen> uh, sorry, gotta run
13:52:15 <Shockk> oh 
13:52:19 <puregreen> hopefully someone else would chime in :)
13:52:27 <Shockk> :( thanks for the help though
13:56:20 <Shockk> I'm thinking I could write an instance of AsEmpty for my InnerStorage type 
13:56:27 <Shockk> and then use non' _Empty
14:29:15 * hackagebot heist 1.0.0.0 - An Haskell template system supporting both HTML5 and XML.  https://hackage.haskell.org/package/heist-1.0.0.0 (DougBeardsley)
14:29:51 <troydm> so I'm having yet another problem with Haskell
14:30:06 <troydm> I have some recursive function with accumulator
14:30:14 <troydm> accumulator is just HashMap
14:30:17 <troydm> strict one
14:30:45 <troydm> so in my recursive function I build that HashMap by continiously calling HashMap's insert function
14:30:55 <troydm> but it seems something goes lazingly wrong
14:32:42 <troydm> the HashMap I'm building has list as it's value 
14:33:30 <troydm> so I'm thinking maybe it somehow doesn't forces that list creation so it all executes and turns into some big thunk tree instead of accumulating values in HashMap
14:33:37 <cocreature> strict hashmaps only evaluate their args to whnf which won’t evaluate lists fully
14:33:43 <cocreature> only the constructor
14:34:15 * hackagebot werewolf 1.5.0.0 - A game engine for playing werewolf within an arbitrary chat client  https://hackage.haskell.org/package/werewolf-1.5.0.0 (hjwylde)
14:40:21 <geshe> I cant get GLURaw to link my GLU. GCC will do it with -lGLU. Is there a cabal setting that can help me force the linking?
14:41:07 <troydm> cocreature: how do I fully evaluate the list
14:41:09 <troydm> ?
14:41:28 <cocreature> troydm: you can use deepseq
14:41:39 <cocreature> sorry have to go
14:44:16 * hackagebot werewolf-slack 1.0.1.5 - A chat interface for playing werewolf in Slack  https://hackage.haskell.org/package/werewolf-slack-1.0.1.5 (hjwylde)
14:46:35 <troydm> cocreature: thx
15:01:48 <verement> Is there a way to make GeneralizedNewtypeDeriving apply to Show and Read?
15:10:30 <byorgey> verement: no, that would defeat the purpose of Show and Read
15:11:06 <verement> OK, thanks
15:13:00 <byorgey> verement: you may be interested in http://hackage.haskell.org/package/pretty , or just make your own ad-hoc pretty-printing class
15:13:27 <mniip> why won't +RTS -N8 eat 800% of the CPU :(
15:14:45 <byorgey> mniip: there are a myriad possible reasons.
15:15:34 <mniip> I'm aware
15:15:44 <mniip> the most likely reason is that my code sucks
15:17:00 <Gurkenglas> http://lpaste.net/5960257121751662592 halp
15:17:25 <Gurkenglas> *setting up ghc-7.8.4 fails on this vm
15:18:24 <Gurkenglas> 8.0.1 too http://lpaste.net/9217819073637777408
15:19:14 <Gurkenglas> the stack installer did say my distribution is unsupported. should i switch away from mint mate?
15:25:32 <c_wraith> mint should be fine.  It's basically ubuntu with different UI library choices.
15:25:45 <c_wraith> (ie, not the crazy stuff canonical has done)
15:26:59 <troydm> I have a [ByteString] is there some convenient function that can break it into [[ByteString]] where each sublist is no more than 10000 elements?
15:27:36 <mniip> wtf
15:28:05 <mniip> I refactored "last . sortBy (compare `on` ...)" into "head . sortBy (flip compare `on` ...)" and the runtime exploded
15:28:39 <troydm> nvm my question, will probably figure out something 
15:29:17 <Eduard_Munteanu> Wow, what a surprise... There's a way to authenticate Linux Mint ISOs now.
15:32:03 <puregreen> troydm: like “chunksOf” from split?
15:32:35 <troydm> puregreen: yeah well something like, but I figured I'll take another approach at problem at hand
15:32:40 <puregreen> okay
15:33:27 <tinco> I remember reading a list of parser combinator libraries in haskell with their advantages/disadvantages
15:34:07 <tinco> anyone know which one is easiest to work with and has nice parser error messages?
15:35:44 <tinco> https://www.reddit.com/r/haskell/comments/46u45o/what_is_the_current_state_of_parser_libraries_in/
15:35:47 <tinco> must've been that one
15:37:47 <Eduard_Munteanu> tinco, I'd say attoparsec is the easiest, but error messages are kinda lacking.
15:38:08 <puregreen> tinco: here's an incomplete list I made (I believe it lists all libraries that are actually worth using, but it doesn't list pros/cons for some of them): https://guide.aelve.com/haskell/parsing-lnwybqv9
15:39:01 <tinco> oh nice thanks
15:39:49 <tinco> ok now comes the crazy followup
15:40:08 <tinco> I'd like to have my haskell run in a browser, any chance a parser like this would run in a js haskell?
15:40:44 <tinco> I guess it would be ghcjs?
15:41:05 <kadoban> tinco: ghcjs will run most code, by far. It definitely can do parsec, and I'd think all of them in the same general family.
15:42:39 <puregreen> I think GHCJS can run anything as long as it doesn't use C (and some things that use C if a shim is provided)
15:42:54 <kadoban> Sounds right
15:44:13 <tinco> hmm, so haste might also right?
15:44:35 <tinco> how do they compare? I thought haste was a smaller implementation, but it claims to be a full haskell implementation
15:45:07 <tinco> maybe the downside is that it doesn't support cabal dependencies or something?
15:45:32 <puregreen> https://github.com/valderman/haste-compiler/blob/master/README.md says that Template Haskell is broken
15:45:55 <tinco> do the parser libraries depend on template haskell?
15:47:22 <tinco> oh wow, haste does the mixed client/server thing
15:47:39 <tinco> I don't like that, I don't get why people are so attracted to it
16:05:53 <toothbrush0> Hello all!  Dumb question maybe, but how do i portably reference my homedir in cabal's config file (e.g., for the remote-repo-cache setting)?  Putting "~" or "$HOME" creates directories under my home literally called "~" and "$HOME" :/
16:06:22 <toothbrush0> I ask because i use OS X and Linux, and have my dotfiles in VCS, but they use /Users and /home respectively...
16:08:05 <Shockk> hello, I was wondering if there's a function similar to `catMaybes` but which works on any Traversable?
16:08:10 <Shockk> :t catMaybes
16:08:12 <lambdabot> [Maybe a] -> [a]
16:08:30 <puregreen> :t foldMap maybeToList
16:08:31 <lambdabot> Foldable t => t (Maybe a) -> [a]
16:08:35 <Shockk> or is it Foldable, I forgot
16:08:38 <Shockk> ahhh
16:09:05 <Shockk> hmm, is it possible to go something like Foldable t => t (Maybe a) -> t a?
16:09:08 <hexagoxel> Shockk: http://hackage.haskell.org/package/witherable-0.1.3.3/docs/Data-Witherable.html
16:09:52 <erisco> exponentially quicker is it
16:10:02 <erisco> pretty sure nub is O(n^2)
16:10:21 <kadoban> toothbrush0: https://www.stackage.org/package/directory is what I use, specifically the stuff like getAppUserDataDirectory
16:10:35 <kadoban> (there's a few for various purposes)
16:10:53 <c_wraith> nub's timing is more subtle than that.  If there are lots of duplicates, it gets faster.
16:11:04 <erisco> it is worst case
16:11:04 <c_wraith> nub's worst case is a list that already contains no duplicates
16:11:04 <glguy> Big O is upper bound
16:11:26 <erisco> I am commenting on the docs for ordNub
16:11:36 <kadoban> big-O isn't upper bound ... it's whatever you say it is. It's a way of characterizing mathematical functions, specifically O(f) is a set of functions.
16:11:40 <glguy> erisco: Maybe it's exponentially faster than quadratic, which perhaps means that it runs in sub-constant time as the number of elements increases... o.O
16:11:43 <geekosaur> kadoban, I don;t think that helps for creating a crossplatform ~/.cabal/config
16:11:52 <c_wraith> glguy: yes, it's *an* upper bound.  You still get to talk about the bounds in various cases.
16:12:14 <toothbrush0> kadoban: thanks, will check that out!
16:12:15 <kadoban> geekosaur: Oh, I misread. Sorry toothbrush0
16:12:16 <c_wraith> kadoban: well, the definition specifically does make it an upper bound.  There's a < symbol in it. :)
16:12:21 <glguy> c_wraith: We're specifically talking about this other function being *exponentially* faster than nub
16:12:35 <toothbrush0> haha oops it almost looked relevant though ^^
16:12:37 <c_wraith> glguy: err.  asymptotically? :P
16:12:48 <kadoban> c_wraith: They apparently meant "upper bound" in the sense that it's characterizing the worst-case running time of the function ... which isn't inherent in big-O
16:13:16 <glguy> c_wraith: No telling http://hackage.haskell.org/package/witherable-0.1.3.3/docs/Data-Witherable.html#v:ordNub
16:14:47 <c_wraith> I don't even know what "exponentially faster" means. :)
16:15:19 <c_wraith> Much like that youtube fad a while back.  I also have no idea what "800% slower" means, unless it means played backwards at 7x speed.
16:15:20 <erisco> it means you decrease the exponent, apparently, from n^2 to n
16:16:15 <Shockk> great I got it working, thanks for the help
16:16:49 <erisco> though sorting will give you nlogn but who's counting
16:17:27 <glguy> toothbrush0: I think that your home directory question might not have a solution
16:17:37 <glguy> I think I'd looked into that at one point and came away disappointed
16:18:01 <Koterpillar> write a dotfiles templater
16:23:14 <toothbrush0> glguy: yeah i'm afraid so  :( it's a pity because i have package flag constraints in there that i want to share over my machines :( oh well.
16:25:37 <wagle> I cant get {-# LANGUAGE DWIM #-} to work
16:42:26 <pavonia> wagle: What is this extension supposed to do?
16:42:35 <codebje> what he means
16:42:37 <wagle> want i mean
16:42:46 <wagle> what i mean, rather
16:43:58 <pavonia> Oh, got it :S
16:44:22 * hackagebot damnpacket 1.0.0 - Parsing dAmn messages  https://hackage.haskell.org/package/damnpacket-1.0.0 (JudeTaylor)
16:44:34 <hydraz> Ohh
16:44:38 <hydraz> wagle: I see what you did there
16:45:23 <nshepperd> don't worry, I'm sure -XDWIM will arrive in the next ghc release
16:45:25 * wagle cant even get his jokes to work right
16:45:53 <geekosaur> ghc has reached the point where Poe's Law applies to it >.>
16:46:14 <solrize> ha
16:46:25 <solrize> yeah i remember thinking that sql-style lisp comprehensions were an april fools joke
16:46:28 <solrize> list comprehensions
16:46:31 <solrize> freudian slip :)
16:46:50 <hydraz> when is Greenspun's tenth rule going to apply?
16:47:00 <implementation> lisp comprehensions would be an interesting feature too
16:47:02 <solrize> template haskell?
16:47:28 <solrize> https://github.com/haskell-lisp/liskell
16:47:39 <wagle> well crud, now it works, and I dont understand how or why
16:47:45 <nshepperd> I wouldn't be surprised to see an extension called MagicalTypeSynonyms in a near release
16:48:09 <glguy> We already have a MagicHash, so that doesn't seem too far-fetched
16:48:50 <nshepperd> IncomprehensibleInstances - probably already exists in a patch somewhere
16:49:21 <glguy> How about an UnnecessaryInstances ?
16:49:33 <solrize> list incomprehensions
16:49:47 <hydraz> half of the list comprehensions I see are incomprehensible already
16:50:04 <hydraz> wether that speaks to list incomprehensibility or my ability to read them requires further experimentation to decide
16:51:10 <nshepperd> RealWorldComprehensions, QuantumTypeFamilies
16:51:37 <hydraz> RealWorld#Comprehensions you mean :P
16:51:53 <implementation> DeriveWorldFormula
16:52:04 <hydraz> DeriveFormulaOne
16:59:02 <solrize> enterprise monads
17:00:24 <solrize> "
17:00:24 <solrize> DRMacIver: I dread to think what category theory would look like after the software engineering world had got their grubby paws on it. Enterprise variant functors. Commutative UML diagrams."  (hwn)
17:03:21 <wagle> solrize: https://ro-che.info/ccc/
17:03:39 <solrize> haha
17:09:24 * hackagebot zabt 0.1.0.0 - Simpleminded abstract binding trees  https://hackage.haskell.org/package/zabt-0.1.0.0 (JosephAbrahamson)
17:19:24 * hackagebot zabt 0.1.0.1 - Simple-minded abstract binding trees  https://hackage.haskell.org/package/zabt-0.1.0.1 (JosephAbrahamson)
17:38:35 <hydraz> I love how clicking ">>>" ro-che.info says: *** Exception: Prelude.undefined
17:54:26 * hackagebot json-rpc-server 0.2.5.0 - JSON-RPC 2.0 on the server side.  https://hackage.haskell.org/package/json-rpc-server-0.2.5.0 (KristenKozak)
17:57:25 <joe9> any haskell-mode users here? (with emacs). It hangs when I am middle of typing something and it is annoying.  I disabled haskell-process and haskell-interactive-mode and the issue still persists.
17:57:39 <joe9> Is there a simple haskell-mode configuration with just syntax support?
17:58:51 <joe9> all i care about is syntax highlighting and company completions to work.
18:03:44 <orion> Which version of LLVM do I need for GHC 8.0.1?
18:36:53 <srhb> orion: The manual just says llvm 2.8 or later. Does that not work?
18:37:41 <srhb> joe9: There's also #haskell-emcas if you don't get any help here. It sounds like it might be a flycheck thing, or ghc mod, I guess?
18:38:03 <srhb> joe9: #haskell-emacs of course
18:38:07 <suzu> i get the same sort of freeze in vim with ghc-mod
18:38:17 <suzu> usually on completing module names
18:38:26 <suzu> import Data.<hang>
18:39:21 <benzrf> suzu: try using hdevtools instead
18:40:40 <suzu> er yeah thats what i am using
18:40:43 <suzu> i think
18:41:09 <suzu> nope
18:41:20 <suzu> i have neco-ghc, ghc-mod, and syntastic running hdevtools and hlint
18:54:30 * hackagebot snap-core 1.0.0.0 - Snap: A Haskell Web Framework (core interfaces and types)  https://hackage.haskell.org/package/snap-core-1.0.0.0 (DougBeardsley)
19:14:31 * hackagebot snap-server 1.0.0.0 - A web server for the Snap Framework  https://hackage.haskell.org/package/snap-server-1.0.0.0 (DougBeardsley)
19:15:03 <Koterpillar> wow, 1.0
19:16:19 <alercah> :O
19:19:31 * hackagebot snap 1.0.0.0 - Top-level package for the Snap Web Framework  https://hackage.haskell.org/package/snap-1.0.0.0 (DougBeardsley)
19:20:31 <suzu> aeson hit 1.0.0.0 today too!
19:24:31 * hackagebot snap-templates 1.0.0.0 - Scaffolding CLI for the Snap Framework  https://hackage.haskell.org/package/snap-templates-1.0.0.0 (DougBeardsley)
20:19:53 <AdituV> hey there.  anyone know of an IRC library that supports IRCv3 tags and capabilities?
20:20:11 <alercah> IRCv3?
20:20:59 <joe9> srhb: Thanks.
20:21:01 <AdituV> it's a backwards-compatible extension to IRC
20:21:11 <glguy> AdituV: Like @time=stuff COMMMAND arguments ?
20:21:17 <AdituV> yep, that's the sort of thing
20:21:17 <glguy> (regarding the tags part)
20:21:28 <AdituV> and also CAP REQ my.site/capability 
20:21:31 <glguy> yeah, my IRC library supports both of those
20:21:37 <AdituV> ahh, fantastic
20:22:11 <glguy> The library does a lot, which might be more than you're looking for, though. You're invited to look of course http://hackage.haskell.org/package/irc-core
20:22:26 <AdituV> thank you :)  
20:22:40 <glguy> the library exists to support my client, which I've since been working on a new version of, so that library hasn't been moving
20:22:41 <AdituV> (side-note: I seem to remember a karma thing on this server?)
20:22:47 <glguy> https://hackage.haskell.org/package/glirc
20:23:42 <glguy> That's the client in action fwiw https://imgur.com/a/YadOM
20:24:20 <AdituV> oh, that looks nice!  I might have to check it out when I'm doing more client stuff
20:24:22 <glguy> AdituV: and if you're doing much with IRC and Haskell, #haskell-irc exists, though it doesn't have #haskell's 1400 users :)
20:24:48 <AdituV> will join that too :p  thanks again
20:41:01 <ahsfhyicxv> Why does "import GHCJS.DOM.*" error? Is there any way to import all submodules of a module?
20:44:30 <pavonia> No
20:46:16 <ahsfhyicxv> Is there anyway to avoid importing the same modules at the top of every file?
20:46:54 <Koterpillar> ahsfhyicxv: well, you can reexport them from your own module
20:46:58 <dmwit_> Create a module that re-exports all the modules you care about, then import it.
20:47:19 <dmwit> module Ahsfhyicxv (module Foo, module Bar) where import Foo; import Bar
20:47:37 <ahsfhyicxv> Ok thanks
21:00:38 <asivitz> orion: I think ghc 8.0.1 is llvm 3.7, and HEAD is 3.8
21:03:26 <vctr> hello
21:03:30 <vctr> anyone using servant?
21:03:34 <Koterpillar> yes
21:03:40 <Koterpillar> but ask your question :)
21:04:03 <vctr> i'm trying to figure out
21:04:30 <vctr> how to generate a templated page at runtime instead of compile time
21:04:46 <Koterpillar> what do you mean by a templated page?
21:05:08 <vctr> a page that's takes some input and generates a blaze-html template
21:05:31 <vctr> that's easy enough to do if the page has no data and is just static html
21:05:45 <vctr> with an instance of ToMarkup
21:06:18 <vctr> but it's less clear if I want to generate markup using a function that takes some input dat
21:06:21 <vctr> a
21:06:29 <vctr> since the toMarkup instance is defined at compile time
21:06:39 <vctr> and i may wnat to toss around some data that's not defined until runtie
21:06:42 <vctr> urntime
21:07:03 <Koterpillar> well, you're always in your app monad
21:07:21 <Koterpillar> which should have access to all the data you need
21:07:42 <Koterpillar> so instead of YourPage, the function will have the type AppM YourPage
21:08:01 <Koterpillar> and you can use the environment, or whatever you please, to make an instance of YourPage
21:08:43 <vctr> hm
21:08:46 <Koterpillar> i.e. data YourPage = YourPage { message :: String }; and in the handler: message <- getMessageFromSomewhere; return (YourPage message)
21:08:51 <Koterpillar> is this what you're asking?
21:09:46 <vctr> yes i think so
21:09:57 <vctr> so the convention is to pass data through the constructor
21:10:06 <vctr> of the instance of 
21:10:10 <vctr> ToMarkup?
21:10:46 <Koterpillar> well, yes, Servant is just presenting your data, so it _must_ be already there
21:15:42 <codygman> I refactored my code to use a Monad transformer stack and it all typechecks. I just don't know how to make my initial "App" state to do something. Here are the 45 lines of code: http://lpaste.net/175037
21:17:19 <Koterpillar> codygman: you've defined runApp, isn't that what you want?
21:18:11 <codygman> Koterpillar: Yes, but I err.. don't know how to use my consulUrl function with runApp
21:18:42 <codygman> I can create AppEnv, but I don't know how to satisfy "App" in the runApp definition
21:18:49 <Koterpillar> codygman: runApp defaultConsul consulUrl
21:19:13 <Koterpillar> codygman: shouldn't consulUrl be App URI?
21:19:43 <Koterpillar> so at line 44, return (u :: URI)
21:20:25 <codygman> Koterpillar: maybe, I'm just now refactoring to use monad transformers. I might also make that change later.
21:20:45 <Koterpillar> codygman: App URI already includes the possibility of failure
21:21:13 <codygman> Koterpillar: runApp defaultConsul consulUrl does not work
21:21:20 <codygman> "Couldn't match expected type ‘AppEnv’ with actual type ‘ConsulInfo’"
21:21:21 <Koterpillar> codygman: define doesn't work
21:21:26 <Koterpillar> oh, right
21:21:42 <Koterpillar> runApp (AppEnv defaultConsul) consulUrl
21:22:22 <codygman> Koterpillar: Thanks! That is it. Now i'm trying to understand what you mean about line 44
21:22:40 <codygman> You mean that parseURI returns a maybe so it will be handled implicitly in case of failure?
21:22:45 <Koterpillar> no
21:22:51 <Koterpillar> right now, consulUrl can throw an error via ExceptT in App
21:23:03 <Koterpillar> but it can also return a Left error
21:23:32 <Koterpillar> so its type is currently: "A computation that reads AppEnv, can throw an AppError, and returns... either an AppError or URI"
21:23:38 <Koterpillar> observe double AppError
21:24:18 <Koterpillar> you can let the type be, App URI
21:24:27 <codygman> Oh, I think I see.
21:25:38 <codygman> Koterpillar: Yes, I get it and it just compiled as type App URI after my changes
21:25:55 <Koterpillar> without Right in L44?
21:26:02 <codygman> yes
21:26:04 <codygman> :)
21:26:21 <codygman> Later on I want to make those functions return "KeyErrors" maybe, in that case I think I would want the either for more granular error handling
21:26:33 <codygman> not sure if that is a good idea
21:26:37 <codygman> or just overcomplicates
21:26:41 <Koterpillar> well, you have a choice
21:26:52 <Koterpillar> either always throw the AppError through your monad
21:27:03 <Koterpillar> or handle individual errors of different types
21:28:34 <Koterpillar> or returning Maybe URI, implying that the only thing that could happen is the key error (a la Data.Map.lookup)
21:28:57 <codygman> Koterpillar: Alright. Thanks for all your help! Feel free to say more if you wanted and I'll read it after work tomorrow. Goodnight for now though
21:29:32 <Koterpillar> codygman: write more stuff! Then you'll see which of the options is easiest
21:50:04 <Xnuk> @hoogle >->
21:50:05 <lambdabot> No results found
21:50:08 <Xnuk> @hoogle <-<
21:50:09 <lambdabot> No results found
21:50:15 <Xnuk> @<-<
21:50:15 <lambdabot> Unknown command, try @list
21:50:28 <ongy> @hoogle (<-<)
21:50:29 <lambdabot> No results found
21:50:56 <Koterpillar> http://hayoo.fh-wedel.de/?query=%3C-%3C ?
21:51:13 <Koterpillar> http://symbolhound.com/?q=%3C-%3C ?
21:51:45 <joe9> anyone knows how to use stack to build xmonad/xmonad-contrib/xmobar?
21:52:57 <Koterpillar> <--
21:53:58 <Koterpillar> https://github.com/koterpillar/desktop/blob/master/dotfiles/xmonad/xmonad.hs#L195
21:54:01 <Koterpillar> https://github.com/koterpillar/desktop/blob/master/bin/xmonad
21:55:08 <Koterpillar> not very interested in xmobar, other than to make it adopt the dbus protocol
22:02:37 <joe9> Koterpillar: Thanks
22:04:01 <Koterpillar> maybe xmonad needs a patch to support stack transparently
22:06:00 <joe9> Koterpillar: How do you build it initially? stack install xmonad?
22:06:11 <joe9> and, then use xmonad --recompile?
22:06:32 <Koterpillar> yes to both
22:06:50 <joe9> Koterpillar: Thanks.
22:12:44 <tnks> the number of packages in Haskell for error management is hard to summit.
22:13:09 <tnks> just when I started using "exceptions" I was pointed to "safe-exceptions"
22:13:35 <tnks> safe-exceptions kind of looks like a dropin replacement with more sensitivity to async versus sync exceptions.
22:13:53 <tnks> is it safe (pardone pun) to regard it as such?
22:14:04 <tnks> or is there a case where the exceptions package is handy?
22:14:31 <tnks> or is the exceptions package actually just as safe as safe-exceptions claims to be -- there's just a misunderstanding?
22:14:52 <Koterpillar> tnks: safe-exceptions was developed to address the deficiencies in exceptions
22:15:10 <tnks> Koterpillar: okay, that's in line with what I'm reading.
22:15:41 <tnks> but I'm still going through Snoyman's writeups -- haven't yet gotten to comparing the source code.
22:15:49 <tnks> Koterpillar: thanks for the confirmation.
22:16:12 <Koterpillar> tnks: I was only going through their blog
22:23:32 <Job316> Hi there - I'm trying to define a class interface for a ranking system. I'd like to specify that the collection ca must have a monadic update interface. How do I do that? http://lpaste.net/175045
22:24:41 * hackagebot damnpacket 1.0.1 - Parsing dAmn messages  https://hackage.haskell.org/package/damnpacket-1.0.1 (JudeTaylor)
22:25:02 <glguy> Job316: Are you sure you need a class at all?
22:25:35 <glguy> and what is a monadic update interface?
22:26:06 <Koterpillar> ^ wondering that too
22:26:23 <Koterpillar> Job316: it would help if you show an example of something that implements that class
22:26:52 <Job316> oh just a way to send collectionOfMatches->Match->collectionOfMatches
22:27:31 <Job316> let me build the implementation first
22:27:36 <Job316> then i'll hack together the interface
22:44:30 <RoboClamp> This is quite bizarre. After compiling my program with "-rtsopts -prof -fprof-auto", the behavior is entirely different. Instead of doing what it normally does, it crashes with "Main: An unexpected failure occurred". I think this is happening in hLibBladeRF. Does compiling with -prof break foreign pointers or something?
22:48:59 <glguy> It doesn't generally break them, no. It is possible that it can affect the result of compilation causing a different observed behavior if you're relying on faulty assumptions. Of course there's always a small chance that the runtime system has a bug
22:59:43 * hackagebot algebra 4.3 - Constructive abstract algebra  https://hackage.haskell.org/package/algebra-4.3 (HiromiIshii)
23:18:01 <joe9> Koterpillar: github.com:joe9/xmonad-task.git is a package I use with xmonad. when I use stack init in it's folder, I get  http://bpaste.net/show/e6d8357866b8 . Any suggestions on how I can fix it, please?
23:18:59 <Koterpillar> joe9: you can manually specify a resolver
23:19:28 <joe9> Koterpillar: I installed xmonad-contrib http://bpaste.net/show/83080168bf94 earlier
23:19:46 <joe9> I am not sure why stack says that it cannot find xmonad-contrib in the 6.10 resolver.
23:20:07 <Koterpillar> that's not how Stack works, you can install things but you can't _depend_ on them
23:20:45 <joe9> so, when I install a library and I have another project using that library
23:21:02 <joe9> how would that work with Stack?
23:21:06 <Koterpillar> you want something like this: https://github.com/koterpillar/desktop/blob/master/dotfiles/stack/global-project/stack.yaml#L9
23:21:37 <Koterpillar> _all_ your dependencies have to be in stack.yaml, whatever you did messing around doesn't count
23:21:46 <kadoban> joe9: Simply put, you don't install libraries. All 'stack install' does is build the thing and then copy any executables in it into ~/.local/bin/    If you want to depend on a package from another package, that's a different question. Usually you just specify it in your .cabal file for the package.
23:22:32 <kadoban> Rarely (if it's not in your resolver), you have to specify it in stack.yaml as well, since stack wants to know *exactly* what version you want, for repeatability.
23:23:11 <Koterpillar> and flags
23:26:57 <joe9> kadoban: Koterpillar, so, I can add the packages installed as extra-deps to the global-project/stack.yaml, correct?
23:27:06 <Koterpillar> joe9: correct
23:30:19 <joe9> Koterpillar: I read in the manual about ./stack/config.yaml and global-project/stack.yaml. these extra-deps belong in global-project/stack.yaml, correct?
23:30:47 <Koterpillar> joe9: I'm going with global-project because that's how I want to install xmonad
23:33:42 <GGuy> Hi, I'm currently playing around with the Cont monad. The following works: { let strapp a b = return $ b ++ a; evalCont $ return "1" >>= strapp "2" >>= strapp "3"; }
23:33:52 <GGuy> But this doesn't work: evalCont $ foldM (>>=) (return "1") [strapp "2", strapp "3"]
23:33:55 <GGuy> any ideas?
23:35:51 <kadoban> joe9: Yes, they go in there. Note that those will only be used/useful when you're outside of the context of a project, IOW there's no other associated stack.yaml
23:36:20 <lyxia> :t foldM
23:36:22 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
23:37:56 <joe9> kadoban: Koterpillar, sorry for bothering you about this. my ~/.stack/global-project/stack.yaml file, but still "stack init" says this: http://bpaste.net/show/1075688a6a5b
23:38:24 <Koterpillar> joe9: what do you want to achieve with stack init?
23:38:39 <lyxia> GGuy: you should use foldl. foldM does something different from what you wrote.
23:39:00 <joe9> Koterpillar: I have this package that I use with my xmonad configuration.
23:39:07 <Koterpillar> joe9: is it on Hackage?
23:39:24 <GGuy> lyxia: oh gosh, knew it would be something silly... THANKS!
23:39:31 <joe9> Koterpillar: no, just on github github.com:joe9/xmonad-task.git
23:40:16 <Koterpillar> joe9: you can copy that into the global stack.yaml
23:40:45 <Koterpillar> joe9: like this: https://github.com/koterpillar/uv-alert-server/blob/master/stack.yaml#L4
23:41:31 <joe9> Koterpillar: Thanks a lot.
23:41:34 <kadoban> joe9: You seem to be attempting to do things in the global-project and then having them take effect in another project you're doing (that's what 'stack init' is for). Which I don't think makes sense. Maybe I'm missing something.
23:41:37 <Koterpillar> joe9: if you're using stack to build X, you need to list _all_ of the X's dependencies in stack.yaml
23:41:50 <Koterpillar> joe9: whether it's a global project or not, they have to be in one stack.yaml
23:42:19 <Koterpillar> joe9: so, assuming you want to build your own xmonad.hs configuration, you need a stack.yaml with xmonad-contrib and xmonad-task in it
23:42:24 <joe9> Koterpillar: got it. Thanks. kadoban
23:42:30 <Koterpillar> joe9: you don't need to add stack.yaml to xmonad-task
23:42:45 <joe9> Koterpillar:  makes sense. Thanks.
23:43:06 <joe9> Koterpillar: So, stack install xmonad-contrib is not required.
23:43:26 <joe9> Koterpillar: stack takes care of that when building xmonad.
23:44:46 * hackagebot htestu 0.1.1.1 - A library for testing correctness of pseudo random number generators in Haskell.  https://hackage.haskell.org/package/htestu-0.1.1.1 (DominicSteinitz)
23:46:46 <pavonia> I'm following http://stackoverflow.com/questions/12546757/how-do-i-use-cabals-min-version-and-other-macros-with-ghci to include said .h file when loading modules with GHCi. But when loading a module using {-# LANGUAGE CPP #-}, I get an error "dist\build\autogen\cabal_macros.h: No such file or directory". Any ideas what I could be missing?
23:47:21 <systemfault> Reading the part about WHNF in the haskellbook, basically... an expression is WHNF if it's a lambda or a type constructor?
23:47:33 <systemfault> Or it's way more complicated than that?
23:47:52 <pavonia> It makes no difference if I set these options at command-line, in GHCi directly or via the .ghci
23:51:47 <pavonia> Hhm, setting the absolute path works, but I'd rather avoid this
23:58:33 <kadoban> systemfault: If it's evaluated up to the outermost data constructor or lambda, yeah.
23:59:14 <systemfault> Great! It wasn't that clear to me from what I was reading, thank you :)
