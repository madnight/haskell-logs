00:00:09 <saurabhnanda> piyush-kurur: I want to see Haskell we frameworks in the top 20% percentile of that benchmark. Else the claims of a performant platform are bogus.
00:00:13 <saurabhnanda> *web frameworks
00:00:39 <jle`> mahdi: not sure what you want to do exactly, but you can "run" a ConduitM as an IO action
00:00:50 <jle`> if you are ok with streaming its effects
00:01:00 <jle`> you might have to give it a sink and a source
00:01:50 <mahdi> jile` sendFlush is a ConduitM Flush (not a source/sink), can I "run" that, too?
00:03:18 * hackagebot slim 0.0.1 - Functional reactive user interface programming  https://hackage.haskell.org/package/slim-0.0.1 (jvdp)
00:04:30 <mahdi> jile` I tried runConduit $ sendFlush but I got an error as `runConduit` requires `ConduitM () Void m r` while sendChunkBS and sendFlush don't have that `Void` part
00:05:19 <Jenaf> okay now I'm confused
00:06:08 <Jenaf> oh
00:06:12 <Jenaf> cool
00:06:16 <johnw> where is merijn when you really need him
00:09:07 <piyush-kurur> saurabhnanda: agree with you but often in tasks like webframeworks the Db driver is the
00:09:11 <piyush-kurur> bottleneck
00:09:47 <piyush-kurur> if the DB driver is badly written one is doomed
00:11:53 <piyush-kurur> So I would assume that ruby and haskell will not be too different when it comes to DB heavy benchmarks
00:12:47 <piyush-kurur> obviously haskell should not be doing worse (that is what I understood from your post on MySQL)
00:13:59 * piyush-kurur wonders why people still use MySQL after Oracle has virtually killed it
00:14:59 <saurabhnanda> Haskell needs more people building DB-based webapps for the situation to get better. MySQL had the exact same problem with Ruby circa 2007 or so. I had run into it.
00:15:14 <saurabhnanda> But enough people were invested in the Ruby platform to solve the problem.
00:15:28 <ReinH> Haskell certainly should be doing better than Ruby in pretty much any benchmark.
00:16:18 <ReinH> The quality of the individual code samples tends to heavily skew these benchmark shootouts, as does the suitability of the chosen algorithm to a language's execution model
00:16:23 <johnw> ReinH: oh, so many are the jokes, so many
00:16:39 <piyush-kurur> saurabhnanda: If you are serious about database I think you should ditch MySQL. Yesod started with postgre (and sqlite of course) and that is what should be the better alternatives.
00:16:54 <saurabhnanda> piyush-kurur: I'm not using MySQL. Postgres all the way.
00:17:03 * piyush-kurur has an axe to grind against MySQL
00:17:47 <johnw> @tell merijn Found the non-fold/non-recursive formalize I was looking for: https://github.com/jwiegley/notes/blob/master/PipesFiat.v#L125  See the proofs that follow about for/yield
00:17:47 <lambdabot> Consider it noted.
00:17:53 <saurabhnanda> If yesod+postgres moves up in the benchmark, I have a couple of more ideas to squeeze performance for the benchmark's specific workload
00:17:53 <ReinH> johnw: which ones? which jokes in particular?
00:18:18 * hackagebot quack 0.0.0.3 - Convenience parser combinators for URI query strings  https://hackage.haskell.org/package/quack-0.0.0.3 (athanclark)
00:19:25 <MarLinn> saurabhnanda: hardcoding the db content and only fake-accessing the db? ;)
00:19:32 <piyush-kurur> saurabhnanda: be careful about the types for example of strings. it can really kill the performance
00:20:19 <MarLinn> yeah, maybe switching from text to bytestring might help a bit
00:21:01 <piyush-kurur> Specifically look out if you are doing to much conversion between the string types
00:21:38 <ReinH> As a general rule, don't use String.
00:22:05 <ReinH> You can get away with it for very small things that you don't compute with, like naming things
00:24:39 <saurabhnanda> MarLinn: :) Not really. Using the Async library to parallelize DB access.
00:25:24 <piyush-kurur> saurabhnanda: I thought such things should be done by yesod internally what is the point of DB pools etc
00:26:06 <saurabhnanda> piyush-kurur: generally DB pools are used as 1 connection per request/response cycle
00:27:45 <ReinH> (see also https://hackage.haskell.org/package/resource-pool-0.2.3.2)
00:28:09 <ReinH> if you for some reason want to manage your own
00:28:10 <piyush-kurur> saurabhnanda: to continue on strings. If you are pulling out a lot of strings from DB and not really processing it. ByteString can be faster than even text I guess. (assuming that the strings are stored in utf8)
00:29:11 <piyush-kurur> other wise you encounter to costs (db -> text) followed by eventual text ->  JSON/HTML (via utf8) conversion
00:29:24 <saurabhnanda> piyush-kurur: would Yesod allow me to treat them as ByteStrings in the record?
00:29:25 <piyush-kurur> but these are the kind of hacks that I do not like
00:29:41 <saurabhnanda> and is it a good idea by any stretch?
00:29:44 <piyush-kurur> in real world one should not do such stuff
00:30:24 <piyush-kurur> saurabhnanda: I do not understand your question
00:31:00 <saurabhnanda> piyush-kurur: Yesod maps everything to a record-type. Is it a good idea to use ByteString as a field type?
00:31:20 <piyush-kurur> saurabhnanda: depends
00:31:39 <piyush-kurur> I would go by asking the following question
00:31:55 <piyush-kurur> is the field a textual data (example name) or binary data (password hash)
00:32:11 <ReinH> Remember that bytestrings are sequences of bytes, *not* sequences of characters.
00:32:21 <piyush-kurur> if it is the former then the former makes sense otherwise the latter
00:33:08 <geekosaur> even that might not be the right question. if for example you are working with an API that is defined to use UTF8, you may wish to use UTF8-encoded ByteString everywhere
00:33:10 <piyush-kurur> now for benchmarks you can cheat and just use bytestring for name as well but that is hitting below the belt allowed only in love, war and benchmarks
00:33:16 <geekosaur> rather than convert between that and Text
00:34:04 <geekosaur> ...provided you are not computing based on those strings
00:34:06 <ReinH> If you need to interpret them as characters in some encoding, you are best off using Text directly or encoding/decoding the Bytestring to/from Text at need, depending.
00:34:08 <MarLinn> The biggest problem I see is not how they might be stored in the DB but how Yesod will treat them when you insert them into html
00:34:19 <piyush-kurur> geekosaur: I disagree with you. In actual apps one should use Text if the field is textual
00:34:28 <ReinH> Don't try to insert a ByteString into HTML
00:34:37 <ReinH> Since, again, bytestrings are not composed of characters
00:34:45 <ReinH> it doesn't even make sense to do so
00:35:23 <MarLinn> Well the html will be converted into a bytestring anyway, right?
00:35:30 <piyush-kurur> to develope on ReinH's point. When you see ByteString think binar
00:35:36 <piyush-kurur> s/binar/binary
00:35:42 <ReinH> Unless, as geekosaur says, you are treating the whole thing as binary data already
00:35:44 <piyush-kurur> like exe files etc
00:36:57 <piyush-kurur> ByteString = Binary data, Text = Textual data. 
00:37:41 <piyush-kurur> although I have seen yesod's auth plugin use text for password hash (a very wrong thing IMO) May be they have fixed it now
00:38:21 <saurabhnanda> Strings & Floats.
00:38:28 <saurabhnanda> Seem simple, but are a can of worms.
00:38:39 <MarLinn> yesod's auth setup is not really great anyway imho
00:39:36 <piyush-kurur> saurabhnanda: yes avoid strings use text and avoid floats use Double
00:39:52 <geekosaur> dogma can lead you wrong just as readily as not thinking about it at all, you just feel better about going wrong. (indeed, dogma is just another way to not think about it. not thinking about it is what causes messes)
00:40:19 <Jenaf> it works ^.^
00:40:20 <Jenaf> https://gist.github.com/anonymous/bf8327fd0c1059d06d16ca9f220e6118
00:40:31 <saurabhnanda> geekosaur: don't force me to think about the lowest level of abstraction. I want to spend more time thinking about the domain problem.
00:40:59 <MarLinn> piyush-kurur: double just moves problems, it doesn't solve them
00:41:47 <piyush-kurur> MarLinn: agree but there is no place where Float is better than Double. Infact in modern processor the former can actually be slower than latter
00:42:12 <piyush-kurur> although that cannot be said about String vs Text
00:42:34 <piyush-kurur> there are some places where strings might still be better (due to list fusion)
00:42:49 <MarLinn> saurabhnanda: Your domain involves a finite amount of machines and memory. Ergo bits are part of your domain...
00:43:11 <piyush-kurur> MarLinn: joking right?
00:43:21 <Ke> floats use twice as much cache and memory
00:43:28 <Ke> doubles...
00:43:44 <tdammers> MarLinn: by that logic, a stewardess needs in-depth knowledge of aircraft design and kerosene production
00:44:21 <saurabhnanda> okay, parallel question. Is there an approachable article/post/video about advanced type-level hackery **and how to use all those tricks to solve domain-level problems**? Please no, Peano numbers, and Zero/Succ/Nat mumbo-jumbo.
00:44:27 <Jenaf> a pilot needs to know how his rudders work
00:45:00 <tdammers> Jenaf: yes. the point is that there are limits to how deep your knowledge has to extend into the abstraction stack
00:45:01 <saurabhnanda> stuff like DataKinds, TypeFamilies, HKTs, etc?
00:45:04 <piyush-kurur> saurabhnanda: just for fun or for money?
00:45:21 <saurabhnanda> piyush-kurur: 1. Learn. 2. Have fun. 3. Profit
00:45:30 <Jenaf> tdammers: far enough to avoid obvious pitfalls
00:45:41 <tdammers> fsvo "obvious"
00:46:05 <Jenaf> that part on the other hand is relative to the problem you wanna tackle
00:46:09 <saurabhnanda> piyush-kurur: if there's a paid course, I'm willing to sign-up for it. But it needs to use all these types as practical tools, not as theoretical constructs for category theory wankery.
00:46:34 <Jenaf> so if you can drive a car you still need to leanr new things when you want to fly a plane.
00:47:04 <piyush-kurur> saurabhnanda: I started finding DataKinds, TypeFamilies etc more natural after I started looking at Dependently type languages like agda and Gallina (coq)
00:47:19 <geekosaur> often you can get away without dealing with the lowest levels. but you may still need to deal with them occasionally; judging by human history, we only manage to get away from that around the time what we're doing becomes obsolete >.>
00:47:43 <saurabhnanda> piyush-kurur: problem is, I'm running out of time. Need to figure out how to deploy Haskell effectively.
00:48:19 <piyush-kurur> saurabhnanda: I understand.
00:48:27 <piyush-kurur> okey let us take type family. What is it
00:48:40 <piyush-kurur> it is just function at the type level.
00:49:47 <piyush-kurur> In some sense even one parameter types like [a] can be seen as type families.
00:50:16 <piyush-kurur> But since Haskell like lang keeps types and values isolated one needs to come up with the typefamily stuff
00:50:32 <piyush-kurur> Example Let us say there are different kinds of DB
00:50:42 <piyush-kurur> say SQL or no SQL. 
00:50:54 <saurabhnanda> piyush-kurur: a better pedagogy would be to show how type families can solve a domain problem, and then demonstrate how the solution has been constructed.
00:51:04 <piyush-kurur> Each use different keys types
00:51:13 <saurabhnanda> piyush-kurur: go on...
00:51:14 <piyush-kurur> saurabhnanda: I am getting to that
00:51:45 <piyush-kurur> say the primary key in SQL would be say Integer (I think) where as in MongoDB it would be Object ID
00:52:18 <tdammers> Jenaf: yes, but those things aren't aircraft engine maintenance or petrochemistry
00:52:27 <piyush-kurur> Suppose one wants to capture these Key type  you can use a type family
00:52:39 <piyush-kurur> type family Key db
00:52:41 <MarLinn> In a way, there's also a "lower level" in the type system, like e.g. peano arithmetic. Again: If you wanna drive, drive. You will get there but someone might fly over your head. If you wanna fly, learn how the rudders work...
00:52:41 <Jenaf> tdammers: your wrong and thats it
00:52:49 <piyush-kurur> which depends on the db
00:53:01 <tdammers> Jenaf: "you're", "that's"
00:53:20 <piyush-kurur> that is the classic example of a type family I guess.
00:53:27 * Jenaf stops feedig the troll
00:53:42 <tdammers> Jenaf: I'm not even trying to "be right" here, just mentioning that learning the entire stack isn't always necessary if you can afford to stay at a certain abstraction level
00:54:55 <piyush-kurur> Now you can define functions like lookup :: db -> Key db -> IO value etc
00:55:18 <piyush-kurur> this says that lookup expects a db and the associated key type and returns a value
00:55:30 <saurabhnanda> piyush-kurur: brb, someone for a meeting. Need to understand the practical difference between this and phantom types.
00:55:59 <saurabhnanda> piyush-kurur: and actually simple parameterized types as well. Can this not be done without type families?
00:56:03 <saurabhnanda> piyush-kurur: brb
00:56:08 <demize> (My partner being a former US army aircraft engineer, pilots are idiots that know essentially nothing about the aircraft themselves.  It's a bit surprising that they don't fuck up more often, honestly.)
00:57:35 <tdammers> demize: depends a bit on the pilot, I guess, but in practice, I believe it's more pragmatic to teach the pilot a bunch of drills for responding to all sorts of situation, than to teach them all the theory and expect them to solve complex equations in a matter of seconds while the plane is on fire
00:58:40 <piyush-kurur> saurabhnanda: I have to go for lunch will be back in an hour I guess
00:58:43 <Insanity_> Depends at which level you are talking about Demize. Many people who are driving a car today don't know how the engine works
00:58:49 <demize> tdammers: There's a difference between knowing the complex theory and being able to fix simple things that a 5 year old would be able to do with a little instruction, especially when they often break said thing.
00:59:11 <demize> tdammers: And then they complain to the mechanics about the things being broken, when they've been told how to avoid breaking it multiple times.
00:59:48 <tdammers> demize: same happens in software dev ;)
01:00:47 <demize> Indeed.  But at least most software devs that do it aren't paid rather well for doing it, in my experience.
01:00:59 <tdammers> you'd think so, would you?
01:01:39 <MarLinn> But according to some here we're just the steward(esse)s, so we mustn't know any better than our users or the engineers that serve us. Wait... something's wrong in that metaphor...
01:01:41 <tdammers> but then how do you explain wordpress, drupal, the dutch government's unemployment benefits website, and a million other similar f-ups?
01:02:47 <tdammers> MarLinn: some of us are stewardesses, some are pilots, some are air traffic controllers, some are aircraft mechanics, and some are rogue pilots operating a tiny airline in a remote bushland area all by themselves
01:03:47 <tdammers> does a web designer need to know programming? it certainly helps, but it's not required.
01:04:01 <tdammers> does a programmer need to know CPU design? most don't, and that's fine
01:04:41 <suppi> i'm trying to cabal install deepseq-generics-0.1.1.2 in a cabal sandbox but it fails saying base needs ghc-prim-0.4 but the package's contraints is 0.2=> and 0.4<
01:04:43 <tdammers> it depends on your particular area of programming, and also how you approach problems and in what kind of situation you have to work, how deep you have to dive into the abstraction stack
01:05:04 <tdammers> (and also how far up you have to reach0
01:05:26 <suppi> but that's not true! deepseq-generics-0.1.1.2 needs <0.5 and not 0.4!
01:05:45 <suppi> anyone have an idea to what might be going on?
01:06:50 <MarLinn> To me "web designer" has a bad connotation. Not because they are bad, but because in the past, so many didn't care enough about the details. And that's connected to php and all the horrible crap that was built with it
01:07:58 <MarLinn> tdammers, I don't completely disagree with you. But I'd rather be a bit too cautious than end up fudging up because I ignored my environment
01:09:04 <MarLinn> suppi: Is stack involved?
01:09:34 <suppi> MarLinn: no. only cabal
01:10:26 <MarLinn> mh... any global packages?
01:10:57 <suppi> a few basic one like ghc-prim-0.4
01:11:12 <tdammers> MarLinn: agree. If in doubt, I'd prefer a programmer who does know bit fiddling and manual memory management over one who doesn't.
01:12:28 <MarLinn> suppi, that might be a problem, I suppose. As far as I understand it sandboxes keep stuff in, but they do not keep stuff out.
01:13:10 <sup_> MarLinn: I'm suppi, just from a web client. what might be a problem with ghc-prim installed globally?
01:13:47 <oolongCat> I just tried defining a long list of numbers, the resulting .hs file is only 600kb. But when I load the .hs file on ghci it causes ghci process to use like 2GB of ram. Any idea why it's using so much memory ?  
01:15:45 <MarLinn> sup_, I'm not a cabal wiz in any shape or form, sorry. That was just a stab in the dark. I think that the message about base you're getting might actually come from the global base, which conflicts with the one the package wants locally or something
01:17:09 <sup_> MarLinn: the problem is that there are no conflicts, the cabal solver is giving false constraints
01:17:52 <sup_> http://lpaste.net/798053121719795712
01:18:20 * hackagebot repl-toolkit 1.1.0.0 - Toolkit for quickly whipping up config files and command-line interfaces.  https://hackage.haskell.org/package/repl-toolkit-1.1.0.0 (jtapolczai)
01:19:06 <saurabhnanda> piyush-kurur: I'm back
01:19:54 <saurabhnanda> okay, parallel question. Is there an approachable article/post/video about advanced type-level hackery **and how to use all those tricks to solve domain-level problems**? Please, no Peano numbers,  Zero/Succ/Nat, or category theory mumbo-jumbo.
01:20:06 <quchen> sup_: Can’t you overwrite the solver’s calculated constraint with your own via a flag?
01:20:19 <quchen> Not that it’s pretty, but...
01:20:58 <suppi> quchen: how can i do that?
01:21:05 <quchen> saurabhnanda: Check out Lennart’s talk at the Haskell Exchange 2015. He talks about abstracting over database schemata at the type level.
01:21:41 <saurabhnanda> quchen: thanks, checking it out. Anything else?
01:22:58 <quchen> saurabhnanda: Just the one came to mind. Not that there aren’t any others though, it’s just what came to mind immediately
01:23:17 <quchen> suppi: Hmmmm, I forgot, let me see
01:23:33 <saurabhnanda> quchen: how's "Using Haskell as a Thinking Tool " by Andraz Bajt?
01:23:57 <quchen> saurabhnanda: Nice little talk, not about type-level programming though
01:24:04 <saurabhnanda> okay
01:24:21 <suppi> thanks. quchen. got a blackout at sup_ :(
01:24:37 <quchen> Hm?
01:24:44 <quchen> suppi = sup_?
01:24:53 <saurabhnanda> This one? “In this talk, Lennart will show how to design a strongly typed interface to an external library. The external library has some rather complex, dynamically checked, types. Making a strongly typed, easy-to-use version of the API uses several Haskell type system extensions, e.g., type level strings, closed type families, kind definitions. It even uses some extensions that are not quite in ghc yet.”
01:25:05 <suppi> quchen: yeah. i'm on my phone here
01:25:35 <quchen> saurabhnanda: Sounds like it, yes. Lennart only gave one talk at that conference, so it’ll be hard to mix up the talk with another :-)
01:25:44 <saurabhnanda> quchen: heh :)
01:28:47 <quchen> suppi: Check out the --constraint flag in ‘cabal configure --help’
01:29:09 <quchen> Might be a lead, at least
01:29:23 <suppi> quchen: thanks a lot! i will check that
01:29:46 <saurabhnanda> all the talks sound really interesting
01:29:53 <quchen> saurabhnanda: Yes!
01:30:17 <quchen> saurabhnanda: Neil Mitchell’s was also outstanding if you’re looking for talks to watch
01:30:32 <quchen> It got me excited to write a build system. Can you imagine?
01:32:10 <quchen> saurabhnanda: What Haskell can learn from Scala ← highly entertaining
01:33:46 <quchen> And Tibbe’s talk about high performance Haskell is also quite good
01:35:02 <Insanity_> As a beginner with Haskell, would you  consider these talks to be worth watching anyway?
01:35:27 <Insanity_> In fact, new to any style of functional programming. (Years of imperative though) 
01:35:54 <Hi-Angel> saurabhnanda, I'm not sure how advanced you want, but perhaps this might be interesting http://ren.zone/articles/opaleye-sot
01:36:20 <saurabhnanda> Hi-Angel: halfway through that :) but need something more basic first.
01:41:46 <MarLinn> Insanity_: If you're looking for something that introduces you to functional programming I recommend http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/. It's quite old, it's with lisp, and it's a whole course, but it's really good at conveying the functional way of thinking
01:42:05 <Insanity_> Thanks @MarLinn :-)
01:42:14 <Insanity_> I'm reading "Learn yourself a haskell for great good" at the moment
01:42:26 <Insanity_> learn you*
01:43:33 <MarLinn> If you get all that then I suppose the course I linked is more of a tool to deepen the understanding of some of the underlying principles
01:44:00 <MarLinn> There's nothing about modern programming in Haskell there, naturally
01:44:58 <saurabhnanda> MarLinn: I've written fairly large systems in Common Lisp as well. I'm trying to find practical uses of Haskell's type system (and extensions)
01:45:00 <Insanity_> Thanks, I have bookmarked them :)
01:46:58 <MarLinn> saurabhnanda: Yeah, the link was mostly for Insanity_. I think I gathered my own knowledge from dozens of sources, but saved few links that I could pull out for you, sorry.
01:47:34 <Hi-Angel> Insanity_, I'd also recommend to pick a ready Hackell project to hack in. From my experence: learning basic Haskell syntax is easy, but somewhere around typeclasses you might stuck without a practice. Changing a code in a ready project and looking how something is done there could help.
01:49:04 <Insanity_> Thanks Hi-Angel, I'm assuming you're on about github projects written in Haskell. Or is there another source that people use more for Haskell?
01:49:56 <Hi-Angel> Hmm, I can't say actually. I might say that I picked up for that purpose (though for a need too) Yi editor, which is being hosted on github.
01:50:50 <Insanity_> Checking that out now, thanks :)
01:53:51 <Hi-Angel> Insanity_, rule of thumb for hacking into Haskell project as a newbie: if you see something weird, like a syntax you don't know, or function having "Text" as its type, but accepting instead a quoted string, which could seem as a [Char] — check the header of the file for enabled extension.
01:53:58 <Hi-Angel> *extensions.
01:56:44 <Hi-Angel> E.g. "quoted string" being a Text instead of String is the OverloadedStrings
01:57:26 <Insanity_> Oh, thanks for the heads-up :)
02:13:22 <Jenaf> are there a built-in constant for Pi in haskell?
02:13:35 <shachaf> pi
02:14:50 <Jenaf> cool
02:14:50 <Ke> builtin is evil
02:14:50 <Jenaf> it's okay I don't need high precision
02:15:23 <Jenaf> I'd have used 3.1415926 instead (wich are all digits of pi I remember without having to look it up)
02:20:00 <ahihi> > pi :: CReal
02:20:02 <lambdabot>  3.1415926535897932384626433832795028841972
02:22:08 <cocreature> Jenaf: if you round that correctly you need a 7 at the end :)
02:22:29 <Jenaf> rigth
02:22:45 <Jenaf> but then i would have to memorize 2 more digits to know how to correctly round it
02:23:05 <Jenaf> but whats a common mistake wich makes a way bigger difference: is using 3.1415 for pi
02:25:00 <merijn> Does it really? I thought that at like 5 significant digits the difference is already marginal to the point of imperceptibility
02:25:22 <ongy> :t pi
02:25:23 <lambdabot> Floating a => a
02:25:45 <ongy> ?instances Floating
02:25:50 <lambdabot> Complex a, Const a b, Double, Float, Identity a, Sym a
02:26:30 <merijn> Jenaf: I mean, honestly 3.14 gives 0.5% error from the true result, 3.15159 gives a whopping 0.000084% error from truth (ignoring Floating point rounding)
02:26:49 <merijn> eh
02:26:55 <merijn> 3.14159, obviously :)
02:27:46 <MarLinn> e^(i*pi) = -1 => (i*pi) = ln(-1) => pi = ln(-1)/sqrt(-1); ln and sqrt are built-ins => built-in pi!
02:28:18 <ReinH> merijn: 5 digits is enough to measure the circumference of a stadium to the inch
02:29:24 <ReinH> 12 digits is enough to measure the earth to the width of a human hair
02:29:51 <ReinH> 64 digits is enough to measure the entire universe to within a Planck length.
02:29:53 <Jenaf> i guess 3,1415926 is more accurate than the floating point errors that will be accumulated
02:29:59 <Jenaf> so eh its OK
02:30:53 <ReinH> "but then i would have to memorize 2 more digits to know how to correctly round it" No, you need to store one extra bit.
02:30:57 <merijn> People give the bible shit for saying pi = 3, but tbh. Given the measurement accuracy at the time, that's not a terrible approximation. (Yeah, I know the greeks computed more accurate values)
02:32:59 <ReinH> merijn: fun fact: the correct value of pi is published by a committee named CODATA
02:33:10 <agocorona> > pi / pi
02:33:12 <lambdabot>  1.0
02:33:20 <ReinH> http://physics.nist.gov/cuu/Constants/codata.pdf
02:33:44 <ReinH> (their suggested approximation, I guess I should say)
02:33:46 <agocorona> > pi* pi / pi == pi
02:33:48 <lambdabot>  True
02:34:31 <ongy> > pi* pi / pi == (pi :: Float)
02:34:33 <lambdabot>  True
02:34:38 <MarLinn> > pi * 0.1 / 10 == pi
02:34:40 <lambdabot>  False
02:35:01 <MarLinn> > pi * 0.1 * 10 == pi -- More cofree in my life, please
02:35:03 <lambdabot>  True
02:35:32 <agocorona> Haskell compute infinite precision numbers great!
02:36:24 <MarLinn> damn you, optimizer! Y u no break!
02:36:27 <merijn> Rationals are the best numbers, infinite precision!
02:36:35 <ReinH> also you do need more sigfigs when dealing with argument reduction http://www.csee.umbc.edu/~phatak/645/supl/Ng-ArgReduction.pdf
02:36:50 <agocorona> I mena irrationals lile pi ;)
02:36:55 <agocorona> like
02:37:02 <agocorona> means
02:39:16 <agocorona> in lisp is possible to optimize operations with irrationals with infinite precision
02:40:16 <MarLinn> There's at least one Haskell lib with "infinite precision" pi as well, for all your size-of-universe calculating needs
02:41:46 <agocorona> I suppos that comparing the s-expression that generate each number it is possible to eliminate and factorize s-expressions
02:46:15 <balac> @pl (\x y -> compare ( fst x ) ( fst y ) )
02:46:15 <lambdabot> (. fst) . compare . fst
02:46:48 <lyxia> compare `on` fst
02:47:22 <MarLinn> comparing fst
02:47:25 <balac> lyxia: thanks!
02:48:10 <lyxia> oh right I always forget comparing exists
02:48:47 <MarLinn> "on" looks nicer anyway ;)
02:53:23 * hackagebot BiGUL 1.0.1 - The Bidirectional Generic Update Language  https://hackage.haskell.org/package/BiGUL-1.0.1 (joshko)
03:13:24 * hackagebot hindent 5.2.0 - Extensible Haskell pretty printer  https://hackage.haskell.org/package/hindent-5.2.0 (ChrisDone)
03:15:18 <f-a> http://paste.debian.net/plain/795056 <-- I am pretty sure I need to apt-get install something, but what specifically?
03:33:48 <woffs> f-a, build-essential?
03:35:38 <f-a> woffs: build-essential is already the newest version. Mhhhhh
03:36:19 <f-a> I'll pester the folks at #darcs, maybe it's a bug
03:36:46 <srhb> If the check is on -liconv, it might be libiconv? I'd consider that error a bug regardless...
03:37:10 <srhb> Not exactly a clear error message. :-P
03:38:14 <f-a> srhb: thanks. thought an apt-cache search isn't immediately helpful http://paste.debian.net/795071/
03:38:20 <f-a> (tried installing libiconv-hook-dev, no dice)
03:38:25 * hackagebot unused 0.6.1.1 - A command line tool to identify unused code.  https://hackage.haskell.org/package/unused-0.6.1.1 (joshuaclayton)
03:43:57 <MarLinn> Yeah, hackagebot. "unused code" was what I was thinking darcs was these days as well.
03:49:23 <intothemountains> https://paste.debian.net/795074/ Has anyone an idea of why nothing gets printed to stdout?
03:50:09 <intothemountains> it loops forever (as it should until I introduce the exiting condition) but nothing gets printed
03:50:27 <hungryhugo> f-a: there is also a libghc-iconv-dev, have you tried that?
03:51:08 <intothemountains> applying `playGame` to a game does print to stdout
03:51:17 <hungryhugo> f-a: if you have ghc installed via apt-get, that is
03:51:23 <f-a> hungryhugo: I downloaded ghc + cabal, maybe I should install iconv from hackage. I'll try it, hungryhugo 
03:52:50 <hungryhugo> f-a: ah ok, i think apt-getting libghc-iconv-dev would want to install ghc again
03:53:22 <f-a> no dice, hungryhugo 
03:53:33 <f-a> http://darcs-devel.darcs.narkive.com/qXymID9X/issue2498-ghc-8-breakage-and-workaround still, I found this
03:53:35 <lyxia> intothemountains: could there be an infinite loop in display? Is that your actual code or did you simplify it
03:53:56 <intothemountains> lyxia: that is the actual code
03:54:20 <intothemountains> I don't think there's an infinite loop in display though, because applying `playGame` works just fine
03:55:23 <lyxia> intothemountains: Oh I see what's wrong. until is not monadic.
03:55:58 <Adeon> yo
03:56:17 <Adeon> is 'parsec' still the parser library to use if you want good error messages and stuff?
03:56:24 <lyxia> intothemountains: so it keeps applying (>>= playTurn), and a result is never reached
03:56:28 <Adeon> or have some people written more modern parser libraries
03:56:53 <intothemountains> lyxia: but isn't (>>= playTurn) monadic in itself though?
03:57:36 <ent> Adeon: I think it's megaparsec now
03:57:40 <MarcelineVQ> Adeon: trifecta and uu-parser are pretty modern, but so is megaparsec which is what I'd use if you wanted something like parsec
03:57:53 <MarcelineVQ> *uu-parsinglib
03:57:55 <Adeon> yeah I also found 'parser' library which is apparently just combinators typeclassed on parsec or attoparsec
03:58:25 <Adeon> yeah what I'm parsing are pretty short source files and if the library can make it easier to give out nice error messages that's a big plus
03:58:54 <MarcelineVQ> I really really like megaparsec's indent-aware parsing combinators
03:59:05 <lyxia> intothemountains: until p f x = if p x then x else until p f (f x). Since p = const False, this reduces to until p f x = until p (f x), this function never produces a result.
03:59:29 <Adeon> I'm going to try megaparsec for this one
03:59:46 <intothemountains> lyxia: oh, so it would produce a result if the condition actually used the game
03:59:48 <intothemountains> right
03:59:52 <intothemountains> thank you!
04:00:15 <lyxia> intothemountains: you need to actually run the x action, and that is not done by the until function.
04:00:34 <intothemountains> is there any monadic alternative to until?
04:00:42 <MarcelineVQ> Adeon: https://mrkkrp.github.io/megaparsec/tutorials.html
04:01:04 <lyxia> intothemountains: there's untilM from monad-loops
04:01:14 <intothemountains> thanks!
04:01:30 <lyxia> intothemountains: uhm, actually iterateUntilM is closer
04:01:38 <Adeon> MarcelineVQ: thanks!
04:01:50 <Adeon> this is for a company internal DSL which isn't very complicated
04:02:01 <MarcelineVQ> Adeon: chances are you'll be using the stuff from the Lexer module the most
04:02:01 <Adeon> but the existing python parser gives out absolutely terrible syntax errors
04:03:26 * hackagebot x86-64bit 0.2 - Runtime code generation for x86 64 bit machine code  https://hackage.haskell.org/package/x86-64bit-0.2 (PeterDivianszky)
04:06:21 <ocramz> hullo!
04:11:18 <ongy> hello
04:11:28 <hydraz> hi
04:11:41 <Hi-Angel> hey
04:12:14 <woffs> > ['h','i']
04:12:16 <lambdabot>  "hi"
04:12:37 <SShrike> Hei
04:13:48 <ahihi> > take 2 . drop 7 $ ['a'..]
04:13:50 <lambdabot>  "hi"
04:15:21 <hydraz> > ([1..] >>= flip replicateM ['a'..'z']) !! 216
04:15:24 <lambdabot>  "hi"
04:16:17 <woffs> hydraz, you won
04:17:16 <SShrike> yeah...
04:17:25 <SShrike> Someone get that guy his trophy
04:24:15 <ocramz> is there a class of Sets ? I'm looking for a generalized filtering function
04:25:33 <maybefbi> is Data.Default as bad an idea as Java's null?
04:25:37 <ocramz> I came up with this question when writing a generalized `partition`: partitionG f q ss = (f q ss, f (not . q) ss)
04:26:13 <woffs> > ([1..] >>= flip replicateM ['a'..'z']) !! 246127776
04:26:15 <lyxia> ocramz: witherable?
04:26:21 <lambdabot>  mueval: ExitFailure 1
04:26:39 <ocramz> lyxia : beg your pardon?
04:27:05 <lyxia> ocramz: there's a package called witherable defining a class that generalizes filter
04:27:46 <woffs> > ([6..] >>= flip replicateM ['h'..'y']) !! 23768009
04:27:54 <lambdabot>  mueval-core: Time limit exceeded
04:27:56 <ocramz> lyxia: wow, thanks. Spot on
04:28:09 <ocramz> strange name though
04:28:41 <lyxia> yeah it definitely doesn't help discoverability
04:30:31 <puregreen> ocramz, lyxia: witherable doesn't have generalised partition, however
04:53:53 <saurabhnanda> is all of this types > kinds > sorts machinery required? Why can't something like Lisp work here?
04:54:18 <saurabhnanda> similar machinery is available at compile-time. and similar machinery is available at run-time.
04:54:34 <opqdonut> if you want to step in that direction
04:54:37 <opqdonut> it's called dependent typing
04:54:49 <opqdonut> many things become much more complex, but you do get more power
04:55:02 <opqdonut> have a look at languages like agda and idris for instance
04:55:26 <opqdonut> in haskell you can know which stuff your compiler checks, and which stuff is checked at runtime
04:55:37 <opqdonut> in a lisp or dependently-typed language that's not so easy to know
04:55:45 <opqdonut> so that's one reason for the structure of haskell
04:55:52 <opqdonut> another reason is that it keeps the type inference simpler
04:56:47 <saurabhnanda> I'm not so sure if type-inference is a big goal to always keep optimizing for.
04:57:05 <saurabhnanda> All functions should have top-level type signatures
04:57:12 <saurabhnanda> do we really need global type-inference
04:57:17 <saurabhnanda> I think Rust has taken a good call here
04:58:21 <Adeon> I just noticed that with recent stack snapshot I get stack traces by default if there's an uncaught exceptions that kills my program
04:58:27 <Adeon> maybe it's the most recent
04:58:30 <Adeon> but it's amazing
04:58:31 <hydraz> Isn't there work going on to remove the kind system?
04:58:46 <hydraz> And related work to bake some form of dependent types into the GHC
05:00:05 <saurabhnanda> I need to wrap my head around this dependent type nonsense. To me Lisp is beautiful. Similar machinery at all levels. Like a fractal. Understand it once, and you're done.
05:01:39 <ahihi> it may be beautiful, but it usually doesn't come with much of a type system
05:04:05 <f-a> I like them both saurabhnanda , they are two different beasts
05:05:08 <saurabhnanda> question is, does one need such complexities to do some computations at the type-level during compile-time? Just give a turing-complete language that programmers can access at compile-time and be done with it.
05:05:29 <ahihi> that makes your code difficult to reason about
05:06:16 <ahihi> but if that's not a priority for you, sure
05:06:31 <f-a> saurabhnanda: what if the compile-time end doesn't end
05:06:56 <f-a> hello dddddd 
05:06:58 <ahihi> ^ one part of the difficulty ;)
05:07:06 <saurabhnanda> f-a: so be it. We can implement a "wack the programmer" feature
05:07:26 <saurabhnanda> f-a: or a "here there be dragons" warning 
05:07:43 <dddddd> Hi f-a!
05:08:09 <f-a> eh, I am sure you understand some might find the "it might not be turing complete, but I am sure it will end" enticing
05:10:02 <saurabhnanda> f-a: so don't make it turing complete. But make it powerful enough to be able to do computations that one would do at compile-time at the type-level
05:10:13 <saurabhnanda> f-a: but a haskell available during compile-time
05:10:20 <saurabhnanda> that's the zen of lisp
05:10:23 <saurabhnanda> ah the beauty
05:10:26 * saurabhnanda shudders
05:10:33 <maybefbi> saurabhnanda, if the compile time program doesn't halt, are you planning to Ctrl-C out of the compilation?
05:10:38 <f-a> ^
05:10:45 <saurabhnanda> maybefbi: yup, why not?
05:10:58 <ahihi> I will second the suggestion to look at idris, agda & friends
05:11:03 <saurabhnanda> i can write runtime programs that don't halt. what's the point?
05:11:23 <saurabhnanda> haskell's type system can't prevent me from writing stuff that doesn't terminate during runtime
05:11:46 <saurabhnanda> and the proposed type-of-type system cannot prevent me from writing stuff that won't terminate during compile-time
05:11:55 <maybefbi> just because there is a rat in the house doesnt mean we have to burn the whole house down
05:11:55 <saurabhnanda> what's the problem?
05:11:59 <f-a> then that's a different beast saurabhnanda 
05:12:23 <maybefbi> just because halting problem prevails at runtime doesnt mean we should welcome it to compile time
05:13:39 <ahihi> in fact dependently typed languages are more strict about runtime non-termination too
05:15:29 <merijn> ahihi: *can* be more strict
05:15:33 <merijn> ahihi: It's not required
05:15:55 <ahihi> well, sure
05:16:07 <ahihi> but it is one of the things that make them interesting :)
05:16:54 <saurabhnanda> pragmatically, given Haskell's functional and immutable nature, how many times would you have ended-up writing a non-terminating program **in real life**?
05:17:57 <maybefbi> if there is a way to do something, the will to use it will be found
05:18:06 <maybefbi> it will be justified using deadlines or something
05:18:37 <ahihi> not sure I understand the question
05:18:52 <jonored> I mean, if you really want lisp style macros and don't want the sort of limited computation that types get you, there's template haskell.
05:19:01 <eklavya> saurabhnanda: let me be the anecdotal evidence, I wrote a non terminating program in Idris many many times :P
05:19:10 <ahihi> I write a non-terminating program when the task calls for it
05:20:27 <jonored> One of the big draws for haskell for me coming from common lisp was that type-based programming and non-strict evaluation covered a good 80% of what I want macros for while giving much better support for my thought process from the compiler.
05:20:40 <saurabhnanda> jonored: right. TH is on my to-learn list, right after I wrap my head around DataKinds, Type Families, and HKTs. But on cursory glance, it looked like hell.
05:20:53 <jonored> and for the other 20% the lisp macros are there.
05:21:05 <saurabhnanda> jonored: TH, you mean?
05:21:51 <jonored> Yep. And from the look of yesod's template stuff, it's reasonable for the same sorts of stuff. I haven't had to delve into it much.
05:21:52 <f-a> jonored: as much as I like haskell, TH pales in comparison to lisp macros
05:23:28 <tdammers> TH is a last resort
05:23:41 <tdammers> or maybe second-to-last, before you go CPP or full-on code generators
05:23:51 <f-a> *m4 :P
05:24:04 <maybefbi> if there is a possibility for type inference to not terminate, i can easily imagine autocomplete taking forever, trying to infer the type of an infinitely long tuple lazily defined in the type level program
05:24:17 <tdammers> but there's this common sentiment that whenever you grab TH, it is a sign of either the language or your understanding of it being subpar
05:24:48 <jonored> hm... I may have missed a lack somewhere when I was looking at TH.
05:25:18 <Insanity_> Noob question: TH?
05:25:22 <tdammers> Template Haskell
05:25:23 <hydraz> TemplateHaskell.
05:25:32 <Insanity_> Cheers
05:25:49 <f-a> Tested Hammock
05:25:56 <tdammers> the idea is that you write Haskell code that emits Haskell AST; the TH code runs at compile time, and the emitted AST gets injected into the real program
05:26:01 <ahihi> I'll admit I haven't written that much TH, but it seems a lot more pleasant than e.g. scala macros
05:26:15 <Insanity_> Sounds quite interesting
05:26:57 <tdammers> it's a lot harder to write than Lisp macros, because TH, just like any other Haskell, insists on being typesafe (at least to the degree that you cannot output malformed Haskell AST with it)
05:27:14 <tdammers> and the types of that AST can be somewhat unweildy at times
05:27:57 <tdammers> there are, however, perfectly valid uses for it IMO
05:28:19 <ahihi> is there any indication of that being TH-specific, rather than a general property of type-safe macro languages?
05:28:30 <jonored> Ah, okay. So it is still arbitrary AST manipulation, the AST is just haskelly.
05:28:36 <tdammers> yes
05:32:46 <jonored> ...Barring the types being absurd, that sounds nicer to work with than defmacro to me, really.
05:33:20 <tdammers> the types aren't absurd, it's just that a type API that models a typed language like Haskell comes with some intrinsic complexity
05:33:43 <tdammers> lisp kind of cuts things short by simplifying it down to untyped s-expressions
05:36:43 <merijn> jonored: We have Typed Template Haskell too, which only allows well typed AST manipulation
05:37:10 <merijn> jonored: But yes, even the not typesafe TH will produce a compile time error, rather than runtime
05:37:39 <quchen> Haskell’s type system is also not guaranteed to terminate in my lifetime. I don’t see how its guarantee to terminate eventually is relevant to programming Haskell.
05:37:45 <merijn> It's basically, "What if the language we wrote our macro's in was Haskell too!"
05:38:17 <saurabhnanda> merijn: and simple haskell. That I can understand :) 
05:39:55 <maybefbi> if type inference doesnt terminate you will wait forever wondering if the type inference is just taking longer than it should or just taking forever. imagine what that will do to auto-complete or build times. even in template haskell, type inference of TH code terminates.
05:42:15 <quchen> When my typechecker does not terminate after a minute, I kill the process. I don’t wonder whether whether it takes forever or just very long.
05:43:06 <quchen> Luckily, Haskell’s type-level capabilities don’t allow lifting computations to the type level easily, so long compile time are always very suspicious.
05:43:21 <saurabhnanda> :t (:::)
05:43:23 <lambdabot> error: Data constructor not in scope: :::
05:43:27 <saurabhnanda> :k (:::)
05:43:29 <lambdabot> error:
05:43:29 <lambdabot>     Not in scope: type constructor or class ‘:::’
05:43:29 <lambdabot>     Perhaps you meant ‘:~:’ (imported from Data.Typeable)
05:43:38 <saurabhnanda> :i (:::)
05:43:54 <saurabhnanda> where is ::: mentioned in Lennart's talk defined? quchen
05:44:13 <quchen> I don’t know
05:44:26 <quchen> Doesn’t he mention it?
05:44:41 <saurabhnanda> quchen: he's moving very fast. 
05:45:12 <jonored> merijn: Am I reading this right that I could, for instance, use Typed Template Haskell and a typeclass with instances on (TExp a) for various a to do transformations that vary on the type of an expression that's passed in?
05:45:29 <merijn> jonored: Yes!
05:45:38 <kanister> would you recommend haskell for relatively computation heavy programs such as a software renderer?
05:45:52 <merijn> jonored: See this proof of concept on how you could use that: https://github.com/merijn/validated-literals
05:46:19 <jonored> Cool. I don't think I want to find myself wanting to, but that was the thing that /I/ was feeling was missing when I was looking at TH :)
05:46:58 <merijn> jonored: That library is using it to do compile time type safe partial conversions of polymorphic literals
05:47:19 <jonored> Useful.
05:47:27 <simon> merijn, what's a polymorphic literal?
05:47:34 <quchen> :t 1
05:47:36 <lambdabot> Num t => t
05:47:40 <merijn> That
05:47:43 <simon> ah, those.
05:47:47 <merijn> Also, OverloadedStrings and OverloadedLists
05:48:00 <merijn> simon: So you can have "newtype Even = Even Int"
05:48:03 <ongy> is the OverloadedStrings conversion done during compile time?
05:48:11 <merijn> and write:
05:48:11 <merijn> x :: Even
05:48:12 <merijn> x = $$(valid 38)
05:48:14 <simon> ongy, yes.
05:48:14 <merijn> ongy: No
05:48:16 <simon> what?
05:48:18 <ongy> :)
05:48:37 <merijn> simon: OverloadedStrings just turns every string into "fromString <literal here>"
05:48:54 <merijn> simon: If your fromString function is partial (i.e. crashes on some inputs), you *will* crash at runtime
05:48:56 <tdammers> compile-time optimizations may iron out the overhead though
05:49:12 <merijn> simon: Which is exactly what the thing I linked earlier is trying to prevent :)
05:49:40 <merijn> "x = $$(valid 37)" would give a runtime error for my "Even" example
05:49:45 <ongy> is there a particular reason it's done that way?
05:49:57 <merijn> ongy: What is?
05:50:37 <ongy> that the OverloadedStrings conversion is not done at compile time
05:51:05 <merijn> ongy: OverloadedStrings works with any arbitrary user type, using any possible code in its IsString instance
05:51:08 <ahihi> kanister: for real-time programs I personally prefer something with more easily predictable performance characteristics, such as Rust. but it can certainly be done in haskell too
05:51:22 <merijn> ongy: The only way to do it at compiletime would be to run arbitrary haskell code at compiletime
05:51:25 <ahihi> if it's offline, this is less of an issue
05:51:32 <merijn> ongy: Which you can't do, unless you use, e.g. Template Haskell
05:51:54 <merijn> ongy: Imagine this:
05:52:26 <merijn> foo :: IsString a => (a -> Bool) -> Bool; foo f = f "Yay!"
05:52:39 <merijn> ongy: How would you convert that at runtime?
05:52:44 <merijn> ongy: Eh, compile time
05:52:46 <jonored> I mean, it /would/ be nice to be able to guarantee constant folding happens on that expression.
05:53:13 <jonored> which really is a different sort of "haskell code running at compile time".
05:53:24 <merijn> ongy: You don't even know what to convert to at compile time
05:54:02 <kanister> ahihi, i thought of writing it as an offline renderer, yes. I would maybe want to create some sort of scene builder as well though (probably in opengl), which doesn't need to be 60fps realtime, but still run decently.
05:55:18 <ongy> merijn: which doesn't prevent doing it when we have a constant
05:55:32 <ongy> be it by constant propagation or a literal
05:55:33 <merijn> ongy: You have a constant there
05:55:42 <merijn> ongy: You just don't know what to convert it too
05:55:46 <ongy> but not a constant type
05:57:25 <ongy> also the extension could force compile time possibility and leave the usecase you proposed explicit. Which I would even prefer (but that's quite subjective)
05:58:39 <ahihi> kanister: for opengl, check out https://github.com/phaazon/luminance :)
05:58:50 <jonored> ongy: I would argue that just making sure that constant folding can apply and is applied when appropriate to fromString "foo" would be better than making a path to force it.
05:58:53 <et09> can someone give me a one-sentence overview of a good structure of an average GTK style app in haskell 
05:59:40 <merijn> ongy: Anyway, the neat thing is that you can implement what you want as a library, so no real need to bake it into GHC :)
05:59:56 <et09> also i'm wondering if "duplicating" immutable state and modifying it is a sound approach for a very large (how large?) state 
06:00:05 <et09> like in a recursive system
06:00:10 <ongy> merijn: which would require TH at this position, which has more annoying syntax
06:00:29 <kanister> ahihi, thanks! abstractions over opengl are always welcome
06:00:34 <merijn> ongy: Does it really? Have you looked at the examples? You just need "$$(valid <expression here>)"
06:01:23 <jonored> merijn: I mean, that /is/ more noise than <valid expression here>...
06:01:39 <merijn> jonored: Sure, but not so much to be a huge problem
06:02:19 <phaazon> ahihi: kanister I wouldn’t dig luminance any deeper if I were you
06:02:30 <phaazon> because I’ve migrated it into Rust :/
06:02:40 <phaazon> I’m still maintaining stackage support though
06:02:47 <ahihi> well, I did recommend Rust ;)
06:02:53 <ahihi> though I'm using glium there myself
06:03:48 <ahihi> phaazon: do you know of any similar projects for haskell that are actively developed?
06:04:45 <phaazon> gpipe, lambdacube
06:04:46 <ongy> merijn: which is more than <epxresion here>. Also iirc it requires the extension to be activated for the file, which is not 100% compatible to old code
06:05:44 <ongy> but I don't think this discussion makes to much sense
06:05:53 <hydraz> Is there any way to encode Σ-types (dependent pairs, in case your unicode/greek is lacking) using Haskell's current type system (or with TypeInType and friends)?
06:05:56 <ongy> if even it should be in #ghc
06:07:23 <kanister> phaazon, what made you change the library to rust, if I may ask? the performance difference?
06:07:53 <phaazon> kanister: the runtime overhead, yeah
06:08:05 <phaazon> Haskell doesn’t fit the graphics runtime requirements, IMHO
06:08:12 <phaazon> you can of course write games in Haskell
06:08:22 <merijn> hydraz: Basically, no
06:08:27 <hydraz> Damn it
06:08:28 <phaazon> but it’s not what Haskell was designed for
06:08:45 <merijn> hydraz: Idris?
06:09:21 <hydraz> merijn: Oh, no, I don't really need them; Just wanted to know if it was possible
06:10:37 <kanister> phaazon, alright! how do you like rust compared to haskell? I've tried it just a bitbut it seems like a pretty cool language
06:11:05 <kktjejed> How do I use Data.Binary for constructing strict ByteStrings?
06:12:15 <merijn> kktjejed: Construct lazy bytestring, call toStrict? :)
06:14:20 <saurabhnanda> why did no one every point me to Implicit Parameters -- https://ocharles.org.uk/blog/posts/2014-12-11-implicit-params.html -- I had to spend so long understanding the ReaderT monstrosity
06:17:05 <saurabhnanda> "One solution might be to move the LogFunction to a reader monad, but this still carries a cost and the program will need to be transformed. A less invasive technique is to use an implicit parameter."
06:17:11 <saurabhnanda> wow! solves one of my pain points.
06:17:13 <tdammers> saurabhnanda: holy cow, that looks awesome... and terrible at the same time!
06:17:35 <tdammers> it's basically lisp's dynamic variables
06:17:44 <saurabhnanda> tdammers: YES! EXACTLY!
06:17:48 <kktjejed> merijn: Thanks, guess I didn't googled good enough
06:17:53 <saurabhnanda> Lisp FTW!
06:17:55 <tdammers> I have a love-hate relationship with those myself
06:18:01 <merijn> tdammers: They are dynamic variables. Hence why people usually avoid them like the plague
06:18:06 <saurabhnanda> tdammers: what's the downside?
06:18:15 <tdammers> saurabhnanda: action-at-a-distance
06:18:30 <saurabhnanda> tdammers: is it? it's right there in the type-sig
06:18:43 <saurabhnanda> tdammers: and I'm assuming the type-checker will complain if it's not in scope
06:18:47 <tdammers> it's in they type sig at the definition site, but it's not obvious at the call site
06:19:10 <tdammers> it has to be in scope, but it may not always be obvious why it is in scope, or which one is
06:19:43 <tdammers> and of course, the behavior of the function now depends on what is in scope at the call site, which is quite clearly a side effect, no matter how you look at it
06:19:55 <tdammers> a type-checked side effect, but a side effect nonetheless
06:21:58 <saurabhnanda> tdammers: I think it works beautifully for logging functions and global config variables, no?
06:22:03 <saurabhnanda> what about passing a DB pool?
06:22:21 <tdammers> I much prefer wrapping these things into an application state object and passing that around explicitly
06:22:49 <tdammers> the pain of doing that is small and manageable, but the pain of having to figure out, under pressure, which exact thing is in scope and why, is a lot nastier IMO
06:25:31 <saurabhnanda> hmm... back to figuring out what the hell to use 'Proxy' for
06:26:29 <saurabhnanda> so if implicit parameters are so hated, who managed to get them merged into GHC in the first place?
06:28:28 <saurabhnanda> btw, GADT is no longer an extension?
06:34:05 <merijn> saurabhnanda: Why would GADT no longer be an extension?
06:34:06 <ahihi> are there any use cases for Proxy left with the introduction of TypeApplications?
06:34:23 <merijn> ahihi: Proxy is more robust
06:34:48 <saurabhnanda> can't find it at https://ocharles.org.uk/blog/pages/2014-12-01-24-days-of-ghc-extensions.html -- assumed it to be a complete list.
06:34:49 <merijn> ahihi: If the forall order of arguments changes you can get mess up the types
06:34:59 <ahihi> right, good point
06:35:01 <merijn> saurabhnanda: The complete list is in the GHC manual
06:35:16 <merijn> saurabhnanda: That list isn't close to complete
06:35:41 * saurabhnanda has an exploded mind.
06:35:55 * saurabhnanda is trying to figure out how to compose grammatically correct sentences.
06:38:31 * hackagebot monad-logger-prefix 0.1.5 - Add prefixes to your monad-logger output  https://hackage.haskell.org/package/monad-logger-prefix-0.1.5 (parsonsmatt)
06:42:46 <haskell154> @pl \xs n -> take n xs ==> flip take
06:42:46 <lambdabot> flip flip (flip take) . ((==>) .) . flip take
06:43:08 <saurabhnanda> is there any practical use-case of using type-families without typeclasses?
06:43:33 <EvanR> ive used type families without type classes... now im trying to remember a time when i used them with type classes
06:43:55 <haskell154> @pl \i -> toHistogramColumn i (fromMaybe 0 (Map.lookup i m))
06:43:55 <lambdabot> ap toHistogramColumn (fromMaybe 0 . flip Map.lookup m)
06:44:24 <merijn> I think I've only once used type families with typeclasses
06:44:36 <EvanR> recently someone wanted to encode physics units into their numeric arithmetic, you can use type families to get the output unit type to depend on the input unit types
06:44:49 <merijn> Things like: https://gist.github.com/merijn/6130082
06:45:43 <merijn> Or my example HList doesn't use typeclasses either: https://gist.github.com/merijn/dc00bc7cebd6df012c5e
06:46:02 <merijn> apply on line 33 is a good example
06:46:27 <merijn> Perfectly sensible type that's unwritable without type families
06:51:39 <saurabhnanda> checking...
06:52:13 <saurabhnanda> merijn: what does https://gist.github.com/merijn/6130082 do?
06:52:49 <saurabhnanda> merijn: i can't understand both your examples, unfortunately
06:53:24 <saurabhnanda> EvanR: regarding your example, isn't that doable via regular data constructors wrapping over Doubles, or something?
06:53:46 <merijn> saurabhnanda: Well, try loading it in ghci and calling "foo" on () :)
06:54:00 <saurabhnanda> merijn: which one?
06:54:21 <merijn> The Restrict one
06:54:30 <merijn> saurabhnanda: The HList one actually has examples at the bottom
06:55:32 <EvanR> saurabhnanda: that wouldnt be type safe
06:56:29 <EvanR> if it was smart constructs then every operation you did would check units at runtime, and if you messed up crash you give you an annoying Nothing to handle (and have nothing good to do with)
06:56:43 <EvanR> crash or give you Nothing
06:56:58 <EvanR> you want it to be checked at compile time
06:57:58 <saurabhnanda> merijn: tried it on GHCi. I get that it's doing something at compile-time, but what is it *doing*?
06:58:55 <saurabhnanda> merijn: like, what's the practical use-case for the Restrict example?
06:59:33 <merijn> saurabhnanda: It's the id function, except that it statically rejects some types
07:00:07 <MarcelineVQ> that's really cool
07:00:40 <ocramz> why the Functor instance of a 2-tuple only fmaps over the second member of the tuple?
07:00:45 <ocramz> *does the
07:01:05 <EvanR> because mapping over both would amount to a Bifunctor, not a regular functor
07:01:22 <EvanR> another way to say it is, what would the type of fmapping over both components be
07:02:10 <EvanR> remember Functor types have one type variable, i.e. have kind * -> *
07:02:56 <ggole> Functor for (a, a) (and (a, a, a), etc) would make sense
07:03:20 <glguy> no
07:03:44 <EvanR> Functor for data Two a = Two a a deriving (Functor) makes sense
07:04:10 <ocramz> EvanR : understood, thank you. And in fact, Bifunctor :: (* -> * -> *) -> Constraint 
07:04:12 <ocramz> makes sense
07:04:41 <saurabhnanda> merijn: can it be written without DataKinds? I'm absolutely confused about DataKinds right now.
07:07:05 <Athas> Whenever I save my buffer in haskell-mode in Emacs, it automatically runs some program that "prettifies" my code (and also moves the view around).  How can I disable that?
07:07:40 <balac> @pl \( _, label ) -> label == FREE 
07:07:40 <lambdabot> (FREE ==) . snd
07:07:52 <puregreen> Athas: probably M-x customize-variable RET haskell-stylish-on-save
07:08:10 <Athas> puregreen: thanks.
07:13:02 <saurabhnanda> Athas: if you get stuck again, please install spacemacs+intero
07:13:50 <Athas> saurabhnanda: I find Spacemacs much too invasive.
07:14:01 <Athas> I have 13 years of muscle memory in my current Emacs customisation.
07:14:26 <saurabhnanda> Athas: okay. I think intero can be installed on top of plain ol' emacs as well.
07:14:49 <Athas> Is intero much better than haskell-mode?
07:15:01 <saurabhnanda> Athas: my experience is that it "just works"
07:15:09 <Athas> Hmm.  I might just give that a try.
07:15:31 <Athas> Can you use it without loading your entire project into ghci?  I've had that problem with some of the more sophisticated features in haskell-mode.
07:15:38 <Athas> My project is too big and ghci chokes on it.
07:16:14 <saurabhnanda> Athas: I spent a lot of time twiddling with haskell-mode, but never got it to work properly.
07:16:58 <Athas> That's how Emacs works.
07:20:57 <barrucadu> I just use haskell-mode for indentation and syntax highlighting, what other things am I missing out on?
07:21:29 <Athas> barrucadu: meta-dot aka. 'find definition'.
07:21:32 <Athas> Type hinting.
07:26:57 <Cooler> why is the state monad s->(s,a) instead of a->(s,b)?
07:28:42 <barrucadu> Because the Monad class doesn't let you vary two type parameters like that.
07:29:52 <barrucadu> I assume you want a bind like :: State s1 s2 a -> (a -> State s2 s3 b) -> State s1 s3 c
07:30:01 <phaazon>  ,15:13 < kanister> phaazon, alright! how do you like rust compared to haskell? I've tried it just a bitbut it seems like a pretty cool language
07:30:07 <jgzh6> I can't make this work http://lpaste.net/181575
07:30:12 <phaazon> ah damn they left
07:30:23 <jgzh6> It works fine if I only use String type
07:30:53 <jgzh6> But I have to use Data.Text or ByteString because of Csv conversion
07:31:09 <barrucadu> :t read
07:31:11 <lambdabot> Read a => String -> a
07:31:18 <barrucadu> ^ you're trying to give it a Text as the first paraneter
07:31:27 <barrucadu> *parameter
07:32:16 <barrucadu> Similarly, you're trying to use ++ with Text, but ++ only works for lists
07:32:22 <EvanR> Cooler: huh, you didnt pass in the current state
07:32:41 <EvanR> it cant be very stateful that way
07:32:49 <saurabhnanda> discovered another shocker today. NullaryTypeClasses -- https://ocharles.org.uk/blog/posts/2014-12-10-nullary-type-classes.html
07:33:51 <jgzh6> I can't fix the functions
07:34:10 <jgzh6> I tried to use Data.Text.Read but
07:34:36 <jgzh6> Either Result is not what I want
07:35:34 <bergmark> jgzh6: you can use Data.Text.pack/unpack to convert String<->Text and use <> instead of ++ to append Texts
07:36:21 <jgzh6> But if I unpack and repact the Text, it breaks the Utf8 encodings
07:36:40 <jgzh6> So I have to commute only between Text and ByteString
07:36:42 <EvanR> huh packing and unpacking Text has nothing to do with Utf8
07:36:57 <c_wraith> jgzh6: Text isn't utf8 anyway
07:37:25 <EvanR> it does break straggling utf16 surrogates
07:37:41 <saurabhnanda> :t read
07:37:42 <lambdabot> Read a => String -> a
07:37:52 <tdammers> huh, I always assumed that Text <-> String and Text <-> UTF8 would be lossless
07:37:58 <saurabhnanda> jgzh6: that's your problem I think. You're using the standard 'read' which is defined on String.
07:38:03 <c_wraith> aren't straggling surrogates malformed unicode anyway?
07:38:06 <saurabhnanda> :t Data.Text.Read
07:38:07 <lambdabot> error:
07:38:07 <lambdabot>     Not in scope: data constructor ‘Data.Text.Read’
07:38:08 <lambdabot>     Perhaps you meant variable ‘Data.List.head’ (imported from Data.List)
07:38:11 <EvanR> sure why not
07:38:13 <saurabhnanda> :t Data.Text.read
07:38:15 <lambdabot> error:
07:38:15 <lambdabot>     Not in scope: ‘Data.Text.read’
07:38:15 <lambdabot>     Perhaps you meant ‘Data.List.head’ (imported from Data.List)
07:38:23 <tdammers> :t Data.Text.Read.read
07:38:25 <lambdabot> error:
07:38:25 <lambdabot>     Not in scope: ‘Data.Text.Read.read’
07:38:25 <lambdabot>     No module named ‘Data.Text.Read’ is imported.
07:38:34 <saurabhnanda> jgzh6: there's some variant of 'read' in Data.Text as well -- please search and use that.
07:39:14 <chpatrick> how can I use GHC.Generics.Constructor?
07:39:17 <chpatrick> SingI isn't exposed
07:39:19 <EvanR> String can have these straggling surrogates so technically these operations dont round trip, but morally those characters are ILLEGAL YALL
07:39:37 <jgzh6> If unpack does not break the encoding, I can fix the function to make it work
07:39:51 <EvanR> unpack and pack dont deal with encodings
07:39:56 <saurabhnanda> jgzh6: did you try changing your read function?
07:40:00 <EvanR> String and Text are "morally unencoded"
07:40:15 <c_wraith> jgzh6: Text represents unicode.  Encodings are irrelevant implementation details.
07:40:17 * saurabhnanda HATES the String/Text/ByteString/Word8 situation in Haskell
07:40:17 <jgzh6> Yes, I changed the read function in one of my fixes
07:40:22 <tdammers> indeed - conceptually, they're both encoding-agnostic unicode strings
07:40:28 <saurabhnanda> jgzh6: and still not working?
07:40:45 <jgzh6> It worked but the Text became unreadable
07:40:49 <tdammers> saurabhnanda: it's a pain point, but really only the Text vs. String part is a true wart
07:40:49 <jgzh6> by the compliler
07:40:52 <c_wraith> saurabhnanda: do you also hate the Float, Double, Int situation?
07:40:54 <EvanR> saurabhnanda: its better than most other languages at least, which give you either ByteString and call it String or give you a messed up ByteString+EncodingTag
07:41:08 <tdammers> saurabhnanda: Text vs. ByteString is something *all* programming languages are struggling with, one way or another
07:41:10 <c_wraith> saurabhnanda: do you want One True Number to go along with your One True String?
07:41:40 <tdammers> the real problem is that String is the default string type, while from a real-world programming point of view, it should have been Text
07:41:40 <c_wraith> The fact is, there are different things that get called "string" which have different rules and different semantics.  They *should* be different types.
07:41:54 <c_wraith> There is no One True String type just like there is no One True Number type
07:42:02 <Fernando-Basso> λ> :type length
07:42:04 <Fernando-Basso> length :: Foldable t => t a -> Int
07:42:14 <tdammers> there's also the unfortunate situation that ByteString has the word "String" in its name, suggesting that it's somehow related to strings
07:42:19 <Fernando-Basso> Foldable is a typeclass, right? What about that t and t a?
07:42:19 <saurabhnanda> c_wraith: no, my idealistic scenario would be for the compiler to figure out what the internal representation should be based on type-inference.  I should simple define the input/output at the boundaries. 
07:42:39 <saurabhnanda> writing a network protocol? all code paths start working with bytestring.
07:42:40 <c_wraith> saurabhnanda: Doesn't work, given that they have different *semantics*
07:42:41 <EvanR> we can rename Text to String, and String to Chars, so we get better string type and still have [Char] party tricks. and all of haskell would be broken
07:42:57 <saurabhnanda> writing a webapp? all code paths start working with Text+UTF8
07:43:08 <EvanR> ByteString is a fine name, its a string of bytes
07:43:16 <saurabhnanda> ByteList?
07:43:20 <EvanR> woe be to whoever things "strings" imply text!
07:43:22 <jonored> Fernando-Basso: t is the type that is Foldable, and a is the contents.
07:43:26 <c_wraith> saurabhnanda: if you try to smash them all together, you end up with an unusable mess
07:43:42 <saurabhnanda> and Haskell naming. Don't get me started. digestive-functors for form processing. Who. Woulda. Thunk.
07:43:45 <tdammers> ByteArray would be fine by me
07:44:18 <owoce> Fernando-Basso: `Foldable t => t a -> Int` means that `t` is Foldable, a is whatever
07:44:19 <c_wraith> ByteArray# is a type! :)
07:44:57 <EvanR> haskell has been pretty fortunate with naming, relatively speaking
07:45:01 <EvanR> so im satisfied
07:45:04 <owoce> Fernando-Basso: it's called a Type Constraint
07:45:07 <tdammers> anyway, the ByteString name is misleading, even if it's technically correct, and it's not even Haskell's fault
07:45:12 <Fernando-Basso> jonored, owoce: Okay, thank you both.
07:45:24 <owoce> why not call it 'Bytes'
07:45:29 <owoce> like python does
07:45:37 <EvanR> unordered bag of byte?
07:45:42 <EvanR> sounds interesting
07:46:30 <cloudhead> it is ordered though
07:46:39 <c_wraith> speaking of not enough string types, type FilePath = String is a huge error.
07:46:42 <tdammers> python 3 does
07:46:56 <cloudhead> I think 'String' is what's misleading, ByteString is perfect in terms of naming
07:46:57 <EvanR> FilePathStringTypeWindows
07:46:58 <tdammers> c_wraith: file paths is something you cannot possibly get right
07:47:00 <EvanR> FilePathStringTypeLinux
07:47:05 <EvanR> lets do it
07:47:18 <tdammers> FilePathStringTypeExtLinux
07:47:30 <tdammers> FilePathStringTypeCIFSMountedOnExtLinux
07:47:44 <tdammers> or actually
07:47:50 <tdammers> FilePathStringTypeCIFSMountedOnExtLinux_en_EN_UTF8
07:47:56 <tdammers> FilePathStringTypeCIFSMountedOnExtLinux_en_US_UTF8
07:47:59 <tdammers> I mean
07:48:14 <EvanR> sounds good
07:48:18 <tdammers> sure
07:48:30 <tdammers> but then you still need to somehow figure out which type to use, at runtime
07:48:43 <tdammers> it's not like there's a universal standard that tells you which encoding a filesystem uses
07:48:51 <EvanR> encodings arent advertised by filesystems anyway so that simplifies that
07:48:51 <chpatrick> :r
07:48:53 <tdammers> even the OS itself just guesses
07:49:13 <tdammers> basically you set a global locale, and then you hope that your filesystems all match it
07:49:51 <tdammers> fortunately, almost all modern boxes use UTF8 for unix-like filesystems and to a bit of translation for other filesystems
07:50:01 <EvanR> the best locale is US_UTF8_SOMETIMES_SHIFT_JIS
07:50:39 <tdammers> en_US.EDUCATED_GUESS_PROBABLY_SOMETHING_UNICODE_BUT_WHO_KNOWS
07:50:42 <c_wraith> How does SHIFT_JIS work again?  It's not even unicode, right?
07:50:50 <EvanR> not even
07:50:51 <tdammers> no, it's not
07:51:03 <c_wraith> yay windows!
07:51:07 <tdammers> neither are the 8-bit codepages
07:51:12 <tdammers> so-called "ANSI"
07:51:20 <tdammers> (which, incidentally, are not ANSI standards)(
07:52:19 <owoce> i have a naming question. in code like this: `data Record = MkRecord { ... }` what's the 'Mk' for? why do people use that
07:52:21 <merijn> saurabhnanda: I'm not sure whether Restrict *has* a practical usecase. I was just fooling around with type families and someone told me "you couldn't write a function like that!" in haskell, so I decided to prove them wrong, just because I could
07:52:27 <merijn> owoce: Mk = Make
07:52:52 <jgzh6> To give some more context for what I'm trying to achieve, please see http://lpaste.net/181577
07:53:05 <merijn> owoce: Because it's a constructor. I usually do it when teaching beginners to make clear that the two Foo's in "data Foo = Foo Int" are different
07:53:54 <jgzh6> If I can fix the function combNum, combTxt so that they compile in the last line, my headache will be cone..
07:53:56 <jgzh6> gone.
07:54:26 <owoce> merijn: ok, got it. do you use it in actual code?
07:55:00 <merijn> owoce: I might, not entirely sure
07:56:54 <saurabhnanda> Which extension is being referred to? ===> "The problem we’re encountering is that multi-parameter type classes don’t add any information to the type inference engine - because knowing one type doesn’t let you know anything about the other types. However, we needn’t abandon hope here - this problem can be solved, it just needs another extension (oh, of course!). "
07:57:47 <saurabhnanda> fun-deps. Got it.
07:59:31 <saurabhnanda> is it possible to write a strongly-typed Haskell program that converts all relevant PDF academic papers into blog posts that lesser mortals can understand?
08:00:20 <jgzh6> Why aren't Text and ByteString traversable? If they were, it would've been much easier
08:00:35 <EvanR> traversables have one type parameter
08:00:36 <kadoban> saurabhnanda: Probably, but it's likely beyond current techniques. Sounds like you'd need movie AI for that.
08:01:07 <EvanR> i think i would have a hard time understanding those papers if converted to simple english
08:01:15 <saurabhnanda> kadoban: I'm sure some type-level hackery can solve that problem. 
08:01:28 <owoce> youd probably need unsafeCoerce though
08:01:53 <c_wraith> jgzh6: if you want things like Traversable but for types that are more constrained, it's time to look into lens
08:02:31 <kadoban> Isn't mono-traversable a thing?
08:02:48 <jgzh6> I'm still a complete noob. Lens looks quite complicated.
08:02:53 <c_wraith> mono-traversable is a thing, but I see it as strictly worse than lenses
08:03:00 <EvanR> you can use traversable with String ! ;)
08:03:10 <kadoban> Ah. I've never used either much.
08:05:23 <jgzh6> String is a list of Chars so naturally traversable too 
08:05:37 <jgzh6> But Text and ByteString are not the case..
08:06:02 <saurabhnanda> jgzh6: learn lenses. It will go a long way.
08:06:52 <jgzh6> I briefly looked at lenses when trying to learn to use wreq
08:07:13 <jgzh6> But beyond a casual use, it looked quite complicated
08:07:46 <EvanR> you could have invented lenses, start with implementing your own functions of the form (A -> A) -> B -> B
08:07:55 <saurabhnanda> jgzh6: I agree. First I used just enough to write workable code.
08:08:10 <EvanR> then when you go to the lens library, they have generalized to (a -> b) -> f c -> f d
08:08:13 <saurabhnanda> jgzh6: after writing some working code, I cam back to the problem when dealing with nested records.
08:08:29 <puregreen> * (a -> f b) -> c -> f d
08:08:34 <EvanR> oops
08:08:49 <EvanR> yes
08:09:07 <jgzh6> hm..
08:10:01 <jgzh6> So, lens can solve this problem..? Turning a ByteString to [t]..?
08:10:55 <EvanR> and back again
08:10:55 <kadoban> jgzh6: I believe it solves the problem of "caring that ByteString isn't [t]"
08:11:21 <jgzh6> sounds nice..
08:11:38 <EvanR> its kind of a huge advancement in functional programming
08:11:50 <maerwald> just pray you never get a type error
08:12:35 <saurabhnanda> what's the best blog/article/video for GADTs for super-dummies?
08:12:40 <jgzh6> any comprehensive lens tutorial recommendation for a beginner who hasn't fully grasped Monad Transformers..?
08:13:11 <jgzh6> or do I need to master MT first...?
08:13:16 <EvanR> what lens tutorial talks about monad transformers O_O
08:13:22 <maerwald> none?
08:13:36 <saurabhnanda> EvanR: most beginners don't know how these things are connected.
08:13:37 <puregreen> @hackage lens-tutorial
08:13:37 <lambdabot> http://hackage.haskell.org/package/lens-tutorial
08:13:44 <jle`> is there a nice name for a (a -> (b, c)) -> (a -> c, b -> c) ?
08:13:59 <jle`> s/for a/for
08:14:01 <EvanR> saurabhnanda: GADTs for super-dummies sounds like a great... or terrible title for this
08:14:10 <c_wraith> Just ignore all the MonadState stuff
08:14:12 <c_wraith> It's not necessary
08:14:14 <puregreen> jgzh6: try this one, then try using lenses in your code, and go here with any questions you have
08:14:27 <jgzh6> Great. Thanks.
08:14:49 <jle`> MonadState isn't even related super related to monad transformers, anyway :)
08:14:52 <puregreen> alternatively, try reading the lens wikibook if you find the previous one too basic
08:14:53 <puregreen> https://en.wikibooks.org/wiki/Haskell/Lenses_and_functional_references
08:15:14 <saurabhnanda> jle`: unTuplifyFunctor?
08:15:26 <jle`> saurabhnanda: what is the functor?
08:15:42 <saurabhnanda> jle`: what's in a name :)
08:15:51 <saurabhnanda> jle`: I'm messing around. ignore.
08:16:18 <jle`> ok :)
08:17:59 <jgzh6> FP seems to have so many vocabularies to memorise. There might be a natural language which has fewer vocabularies..
08:18:14 <olibert> hi everyone! i'm a total newbie trying to install haskell-platform on linux mint 17 via apt-get. however, that would result in removing of a lot of packages: http://pastebin.com/9xVhtRA1 hints anyone?
08:18:58 <jle`> olibert: hm, how about installing stack instead?  would that give you less problems with aptitude?
08:19:27 <kadoban> olibert: Just install 'haskell stack' https://docs.haskellstack.org/en/stable/README/#how-to-install
08:19:47 <olibert> thanks, i'll try that
08:22:05 <Rudes> any idea how i might cover the red areas with hspec https://coveralls.io/builds/7669552/source?filename=.%2FNetwork%2FHTCPCP%2FPot.hs ???
08:22:17 <exDM69> olibert: the recommended way to use haskell is to use stack... download the stack binary, put it in $PATH and it will take care of the rest
08:22:21 <mnoonan> jle`: You could call it "unzip"
08:22:31 <exDM69> olibert: it'll install the compiler, all the libs you need, etc. in your home directory
08:22:32 <maerwald> exDM69: since when is that the recommended way?
08:22:44 <Rudes> exDM69: is there a direct benefit to stack over cabal?
08:23:06 <exDM69> Rudes: stack also installs the compiler, etc... it uses (parts of) cabal in the background
08:23:16 <AzureStigma> whats the general definition of polymorphic in haskell
08:23:21 <exDM69> maerwald: I guess "recommended" was a bad choice of words...
08:23:29 <kadoban> Rudes: Ease of use and repeatability mostly.
08:23:30 <Rudes> exDM69: that's true it does install GHC, outside of that though i don't see any real benefits.
08:23:34 * hackagebot codeworld-api 0.2.0.0 - Graphics library for CodeWorld  https://hackage.haskell.org/package/codeworld-api-0.2.0.0 (ChrisSmith)
08:23:36 * hackagebot inline-c 0.5.5.6 - Write Haskell source files including C code inline. No FFI required.  https://hackage.haskell.org/package/inline-c-0.5.5.6 (FrancescoMazzoli)
08:23:38 * hackagebot haskell-names 0.8.0 - Name resolution library for Haskell  https://hackage.haskell.org/package/haskell-names-0.8.0 (PhilippSchuster)
08:24:01 <exDM69> Rudes: yeah, cabal sandboxes work ok too
08:24:18 <exDM69> Rudes: but now that GHC 8 is going to have some breaking changes, stack can solve those issues
08:24:32 <exDM69> you can easily switch between ghc 7 and 8 with stack
08:24:32 <Rudes> exDM69: now that's a good argument
08:24:37 <maerwald> start with cabal sandboxes, if that gets messy, you can try stack. No reason to start with a more complicated system
08:24:47 <glguy> You can easily switch between GHC versions with or without stack
08:24:51 <exDM69> sure
08:24:51 <kadoban> stack is not more complicated to use, doing things manually is.
08:25:04 <glguy> GHC is designed to allow you to install multiple versions side-by-side on its own
08:25:09 <maerwald> kadoban: depends what you do
08:25:22 <exDM69> I just found stack to be about 2000x more simple than trying to get ghc and cabal and cabal-install on your system
08:25:23 <Rudes> any idea how i might cover the red areas with hspec https://coveralls.io/builds/7669552/source?filename=.%2FNetwork%2FHTCPCP%2FPot.hs ?
08:25:51 <exDM69> download one executable, put it in $PATH and you're done
08:25:54 <maerwald> those are personal experiences depending on use case, proficiency etc
08:26:15 <exDM69> yeah, my personal experiences installing haskell several times in the past decade have always been painful
08:26:20 <saurabhnanda> olibert: haskell platform vs stack is the vi vs emacs in the Haskell world. Beware.
08:26:26 <Rudes> i reinstalled cabal and ghc like four times yesterday trying things out, so i can see how stack might be better
08:26:35 <Rudes> saurabhnanda: lol
08:26:38 <exDM69> stack is the first time that it was painless... although I had to learn a new tool and be confused for a while
08:26:38 <kadoban> maerwald: And yours is objective truth *eyeroll*
08:26:42 <maerwald> no
08:26:46 <maerwald> did I say that?
08:26:51 <c_wraith> saurabhnanda: I literally know of no one who would suggest the platform as opposed to just installing ghc and cabal manually.
08:26:58 <kadoban> You implied it, by disagreeing with "that's just your opinion, man"
08:27:01 <jgzh6> Why do people also use Nix when Stack alone can suffice?
08:27:09 <glguy> c_wraith: I think the minimal platform on Windows is better than a manual install
08:27:22 <berndl> jgzh6: because nix is useful for more than just Haskell.
08:27:27 <Rudes> oh geez, here comes the aids
08:27:34 <c_wraith> glguy: oh, did they create a version without opengl?
08:28:00 <nitrix> Rudes: No need to add to the noise with those remarks.
08:28:11 <jgzh6> hm..
08:28:16 <glguy> c_wraith: Yeah https://www.haskell.org/platform/contents.html compare minimal to full
08:28:30 <c_wraith> Once WSFL adds support for the timer_create call, I'd say that it's the correct way to install ghc on windows. :)
08:28:48 <glguy> It turns out that stack is useful for some workflows and not for others. It's OK
08:30:29 <AzureStigma> (Num a, Num b) => a -> b -> b what is the term level and type level of this 
08:31:10 <kadoban> That's all type level.
08:31:22 <AzureStigma> thought so 
08:31:24 <berndl> AzureStigma: a -> b -> b is a kind I think
08:31:44 <berndl> err wait.
08:32:08 <berndl> The "kind" of a -> b -> b is * -> * -> *.
08:32:24 <AzureStigma> o wait the -> is the term level?
08:35:04 <berndl> AzureStigma: -> lives in the type level
08:37:21 <EvanR> -> sends a * and a * to *
08:37:28 <nitrix> AzureStigma: (->) is a type operator in this case. It's all at the type level.
08:37:31 <EvanR> just like Data.Map.Map does
08:38:06 <ppfs> hi
08:38:11 <nitrix> berndl: Seems confusing to needlesly bring kinds in the picture here.
08:38:21 <jgzh6> Is there any advantage or reason for naming a variable with a prefixed underscore like _x :: Double ?
08:38:46 <EvanR> because lens TH will automatically make non-underscores lenses for you with that name
08:38:48 <nitrix> jgzh6: Some libraries like lens uses Template Haskell to generate the lenses automatically for record fields begining with an underscore.
08:39:05 <jgzh6> aha..
08:39:07 <jgzh6> Thanks.
08:39:27 <nitrix> jgzh6: You can actually use makeLensesFor if you want more control.
08:39:34 <glguy> jgzh6: Outside of record naming, the _ prefix disables the warning about about not using a name
08:39:53 <jgzh6> right..
08:41:17 <glguy> The IRCv3.2 Message Tag specification defines "<key>           ::= [ <vendor> '/' ] <sequence of letters, digits, hyphens (`-`)>", is the empty string a valid key? http://ircv3.net/specs/core/message-tags-3.2.html
08:42:11 <nitrix> glguy: I think not. Otherwise you'd have [<>] and not <>, right ?
08:42:21 <maerwald> kadoban: no, I was only implying that it's not general consensus
08:42:22 <glguy> I was trying to write some negative tests and I tried parsing @ on its own and the parser came back with "" key, "" value :)
08:42:44 <glguy> In other contexts in RFC 1459 they'll specify that something is "<middle>   ::= <Any *non-empty* sequence of octets .."
08:43:16 <glguy> (emphasis not added)
08:46:29 <cocreature> glguy: they also use *empty* explicitely in other contexts
08:46:35 <glguy> good point
08:46:47 <nitrix> glguy:   5)    The last parameter may be an empty string.
08:47:19 <nitrix> glguy: Make sure you're not missing a NOTE from the RFC, the <params> one has this.
08:49:30 <cocreature> glguy: empty doesn’t seem to make a lot of sense in that context so I would assume it should be nonempty
08:49:54 <nitrix> I'm going with non-empty as well.
08:50:02 <EvanR> survey says
08:50:18 <glguy> Yeah, I can't imagine they intended to actually support "@" as a valid tags list
08:50:26 <glguy> it just seemed like the specification have accidentally :)
08:50:33 <glguy> might have*
08:51:03 <cocreature> open an issue :)
08:51:12 <EvanR> "conforms to the spirit of the spec"
08:51:40 <cocreature> “conforms to what I assume the spec is supposed to say”
08:51:44 <glguy> In my context I'm parsing it as a client, so I want to be as liberal as possible
08:52:00 <glguy> If you try to parse IRC as specified in the IRC RFC you couldn't connect to freenode
08:55:10 <ongy> who needs freenode anyways
08:55:32 <glguy> Last time I counted it was *at least* 5 people
08:57:00 <nitrix> I actually found a solution to my problem of bi-component / articulation point / cut vertex to make it near O(1). The proof seems to hold fine for 2D grid-world where you always have four edges.
08:58:51 <jgzh6> As a beginner, I haven't yet found any serious disadvantage in learning Haskell on Windows environment.
08:59:32 <jgzh6> Eventually I must move to Unix of course. 
08:59:46 <nitrix> The inspiration? Rubber bands! :P The cost is four markers per tile and a fairly complex book-keeping technique :]
09:01:43 <ongy> nitrix: what's near O(1)? O(n) with a nice constant factor?
09:02:01 <maerwald> ongy: O(2) lol
09:02:26 <mnoonan> O(alpha(n)) is pretty damn close..
09:02:28 <nitrix> ongy: Deletions in a 2D grid and being able if the deletions created more components you started with.
09:02:54 <nitrix> ongy: Where a component is defined as any shape made by tiles touching on their 4 sides.
09:03:00 <nitrix> *to tell
09:04:58 <eitanChatav> good morning
09:05:20 <nitrix> ongy: I'm using a clever variant of spanning trees. I'm only tracing perimeters and allowing tiles to share spanning trees.
09:05:41 <ongy> maerwald: afaik O(1) would be considered equal to O(2), and if equal is the closest you can get, or something special, I'm not quite sure about
09:06:21 <maerwald> ongy: yes, that was the joke
09:07:01 <nitrix> ongy: near O(1) as in, you might have to look at most two tiles next to your deletion, but that's simple in a 2D grid.
09:07:44 <nitrix> ongy: I still consider it O(1), compared to the O(|V|+|E|) complexity that was brought up yesterday.
09:08:29 <orion> What does O(alpha(n)) mean?
09:09:00 <ongy> nitrix: sounds like there is a constant upper limit, so why "near"?
09:09:37 <mnoonan> alpha is the inverse of the Ackermann function; it shows up in the complexity for union-find
09:09:53 <nitrix> ongy: There's one case where you have to do O(1)*2 and another where you have O(1)*4
09:10:09 <ongy> which is O(1), unless I'm quite mistaken
09:10:13 <nitrix> ongy: So I'm not sure how it can be expressed nicely. Theorically, you're still at O(1).
09:10:20 <nitrix> Yeah, that's what I thought.
09:11:12 <ongy> I would call something like linux realloc implementation "near O(1)" (if I understood them correctly)
09:11:20 <glguy> For discussing concrete runtimes seconds are a better unit :)
09:11:33 <ongy> glguy: instructions!
09:11:37 <nitrix> There's a strange initial cost of O(perimeterOf(n)), then from then on, you can maintaing contant time with bookkeeping.
09:21:36 <sm> jgzh6: good! haskell is not supposed to be platform-specific
09:23:44 <jonored> nitrix: I'm trying to guess how you're getting down to O(1) for an update and I'm not quite seeing a way...
09:24:45 <balac> @pl ( \x -> x > 0 && x <= bSize )
09:24:45 <lambdabot> liftM2 (&&) (> 0) (<= bSize)
09:26:17 <nitrix> jonored: I'm putting everything together with drawings :)
09:26:57 <jonored> Connectivity is nonlocal even in a grid, and I don't know of any way you can propagate the "which perimeter is this" that's needed to handle holes without using a data structure that'll at least hit you for O(ln(n)) on one side or the other. I may be missing something, though.
09:27:56 <nitrix> Yes, you're correct, the holes also have this perimeter system and they're identified uniquely.
09:29:15 <jonored> or is this just O(1) for the query of "is this a cutpoint" and not for "cut this and give me the new grid"?
09:31:43 <nitrix> jonored: O(1) for the "tell me if I can cut this, cut this, update the bookkeeping stuff, then give me the new grid".
09:32:30 <nitrix> jonored: Actually traversing the new piece `m` to get a list of the tiles is O(m) though.
09:33:32 <nitrix> But I'm able to cut things arbitrairily and handle the pieces at will.
09:35:37 <nitrix> I'll post images c:
09:36:07 <nitrix> jonored: To implement it in Haskell though, I'll need IORef.
09:36:36 <ejbs> Hey guys! Haskell noob here. I wrote a naive fib function and it's really slow. I wrote a memoized one in Lisp and it's a lot faster. I thought Haskell memoizes by default?
09:36:56 <pikajude> it doesn't
09:37:35 <ejbs> pikajude: Do I need to write the memoization mechanism or is there like a compiler flag or something?
09:38:38 <ejbs> Sorry, I should've googled
09:39:32 <sm> there's a few libraries, http://hackage.haskell.org/packages/search?terms=memo
09:40:32 <ejbs> sm: This is for school so I think std libs only :)
09:40:50 <sm> GHC memoizes some things, but not as much as you're expecting
09:42:38 <laserpants> There is an example, specifically of the fib function here: http://programmers.stackexchange.com/questions/220746/can-someone-explain-the-concept-behind-haskells-memoization
09:44:32 <pikajude> but there is a package for it
09:44:32 <pikajude> give me one second
09:44:32 <pikajude> i'm on cafe internet
09:44:33 <pikajude> http://hackage.haskell.org/package/memoize-0.7/docs/Data-Function-Memoize.html
09:48:21 <ejbs> laserpants: Thanks, I found the wiki page but I didn't get the top line. So is (map fib [1..] !!) a pointfree expression for a fn waiting for an index to lookup?
09:50:05 <jonored> ejbs: It's worth noting that "memoized function" and "data structure holding lazily-evaluated members" are more similar than you might expect. They aren't /identical/, but..
09:50:27 <Welkin> jonored: it's more likely than you think!
09:51:49 <ejbs> jonored: Yeah, it's a bit mind bending atm since I'm so used to strict eval haha. I kinda get it though
09:53:34 <navaati_> hi
09:54:34 <navaati_> i'm stumbling on something somewhat stupid : i've got a value of type "Maybe (m (Maybe a)) -> m (Maybe a)" and i just can't figure a way to get a m (Maybe a)
09:54:44 <navaati_> i hoogled it but it gives nothing good
09:54:48 <navaati_> any idea ?
09:55:46 <ongy> navaati_: Does m have a constraint?
09:56:52 <jmct> navaati_: Let's break it down: If the argument is a `Nothing` there isn't much choice in how to get a `m (Maybe a)`
09:57:22 <navaati_> ongy, yeah it's a monad, sorry
09:57:59 <ongy> navaati_: so if you have a 'val :: Maybe a' you can get 'm (Maybe a)' with 'return val'
09:58:19 <ongy> :t return
09:58:21 <lambdabot> Monad m => a -> m a
09:58:50 <navaati_> (just so nobody wastes time, i know monads well)
09:59:06 <pkmx> :t maybe (pure Nothing) id
09:59:08 <lambdabot> Applicative f => Maybe (f (Maybe a)) -> f (Maybe a)
09:59:26 <navaati_> pkmx, oh
09:59:53 <navaati_> i see
10:00:04 <ongy> > return . return . return $ "var" :: Monad m => Maybe (m (Maybe String))
10:00:07 <lambdabot>  error:
10:00:08 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M295730168589...
10:00:08 <lambdabot>        prevents the constraint ‘(Show
10:00:32 <navaati_> actually i thought there would be some function to do that, like join but better
10:00:33 <ongy> ah, right that won't work
10:00:41 <navaati_> but yours is quite nice
10:01:42 <ejbs> What's literal syntax for a Char?
10:01:51 <ongy> :t 'a'
10:01:53 <lambdabot> Char
10:02:07 <ongy> ejbs: Single quotes
10:02:41 <ejbs> ongy: Thanks, I'll try out the bot next time
10:02:50 <ongy> is it considered good style to use 'pure' over 'return' when possible
10:03:04 <ongy> ejbs: That's not something the bot can tell you easily. I just used it to demonstrate
10:04:21 <MarcelineVQ> :t fmap join . sequence
10:04:23 <lambdabot> (Traversable m, Monad m, Monad f) => m (f (m a)) -> f (m a)
10:04:31 <monochrom> ongy: It is one of two good styles.
10:06:41 <MarcelineVQ> navaati_: Is that appropriate for you, type-wise?
10:11:08 <PaulePanter> Hi. On http://lambda.haskell.org/platform/download/ why is current still at 2013.2?
10:11:29 <PaulePanter> … because http://lambda.haskell.org/platform/download/2014.2.0.0/ only contains release candidates?
10:12:17 <monochrom> I think lambda.haskell.org is out of use entirely
10:12:46 <Squarism> Im having some trouble understanding the greatness of Arrow? When and with what can it help? /Noob
10:13:08 <monochrom> For example if you start at https://www.haskell.org/platform/ you don't actually get linked to any lambda.haskell.org URLs
10:13:45 <PaulePanter> monochrom: https://github.com/haskell/haskell-platform/releases seems to be the new URL.
10:13:48 <PaulePanter> monochrom: Thank you.
10:13:50 <monochrom> For example if you choose "Generic" there, you get links like https://haskell.org/platform/download/8.0.1/haskell-platform-8.0.1-unknown-posix--minimal-x86_64.tar.gz
10:14:27 <PaulePanter> Indeed.
10:14:48 <monochrom> the github one can't be the latest. it lacks the 8.0.1 version.
10:14:48 <PaulePanter> What a mess, when you start with an outdated URL in some script. ;-)
10:14:56 <PaulePanter> monochrom: I figured.
10:15:02 <PaulePanter> Sorry for the noise and thank you.
10:16:22 <monochrom> There was a change of lead maintainer between 7.10.3 and 8.0.1. That may also change administrative things like "do we still use github?"
10:17:15 <monochrom> Or maybe they still use github but forgot to tag a release.
10:17:49 <monochrom> Take everything on the web with a grain of salt.
10:18:27 <xuxu> data T = forall a. MkT a (a -> Int)
10:18:30 <xuxu> f :: T -> Int
10:18:36 <xuxu> f (MkT x g) = g x
10:18:49 <xuxu> this doesn't look like haskell
10:19:04 <monochrom> Why do you say that?
10:19:04 <Welkin> why not?
10:19:16 <Welkin> it is pattern matching on the MkT constructor
10:19:23 <xuxu> that looks like type classes and ADT combined into one
10:20:02 <monochrom> Even then, both type classes and ADT look like Haskell.
10:20:08 <xuxu> but data tells me its an ADT?
10:20:22 <c_wraith> what looks like a type class? 
10:20:41 <xuxu> i didn't know you could use forall in the definition of a data type
10:20:46 <monochrom> At any rate, it is Haskell after turning on {-# LANGUAGE ExistentialQuantification #-}
10:21:01 <xuxu> c_wraith: it looks like you are defining a generic function called f
10:21:13 <monochrom> Yeah, there are a lot more things I didn't know.
10:21:21 <c_wraith> there's no polymorphism at all in the type of f
10:21:31 <xuxu> monochrom: hm?
10:21:34 <c_wraith> classes require polymorphism 
10:21:35 <PaulePanter> monochrom: It looks like it. The README from 8.0.1 still contains the GitHub URL.
10:21:36 <ejbs> Guys I have a function that's gonna generate a VERY long string and I want to time it, can I skip the string printing to stdout in ghci somehow?
10:21:53 <xuxu> thanks for mentioning ExistentialQuantification, i thought that was just in the dependent languages
10:21:59 <monochrom> Do not be surprised if you or I run into things we didn't know. It happens all the time. Just accept new facts.
10:22:14 <xuxu> ah
10:22:16 <hpc> ejbs: time the length of the string?
10:22:47 <hpc> or if that's not enough, you can use rnf: https://hackage.haskell.org/package/deepseq-1.4.2.0/docs/Control-DeepSeq.html#v:rnf
10:22:51 <Ed___> is there a beeter way to sum up every even number from 100 to 200? sum [ x | x <- [100..200], mod x 2 == 0]
10:22:51 <ejbs> hpc: Nah, as in just see how long it takes (I'm the stopwatch, I just wanna skip the printing)
10:22:56 <ongy> also if it's a really long string, maybe use text or similar to reduce string processing overhead (unless you want to measure that aswell)
10:22:59 <xuxu> i'll look into existential quantification 
10:23:34 <hpc> ejbs: i mean, instead of timing a computation that produces the string (which prints it), instead time a computation that produces the length of the string (which prints one number and still computes the string)
10:23:34 <ongy> ejbs: if you print the lenght instead of the string you will force evaluation, but skip printing the actual length
10:23:36 <pkmx> > sum $ filter even [100..200]
10:23:39 <lambdabot>  7650
10:24:06 <ejbs> ongy: hpc: Oh duh, I accidently dcd from the channel and thought I was missing something
10:24:15 <ejbs> I'll do that!
10:27:46 <Will_is_here> Don't die on me. 
10:28:05 <EvanR> where theres a will, will is there
10:28:31 <Ed___> how to generate a list of every nth number. for example: every 3rd number? 
10:28:57 <EvanR> > [0,3..]
10:28:59 <lambdabot>  [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,7...
10:29:00 <Ed___> I'm a lab assistant for a class right now and thats one of the things they have to do. I could solve it with mod, but is there any better way?
10:29:03 <monochrom> No. Where there is a will, there is a signature. :)
10:29:03 <Ed___> oh ok.
10:29:09 <Ed___> so it auto-generates it
10:29:25 <EvanR> its syntax sugar for 
10:29:42 <EvanR> :t enumFromThen
10:29:43 <lambdabot> Enum a => a -> a -> [a]
10:30:16 <Ed___> is there a way to limit the list generated up to a certain value without using a takeWhile, etc...?
10:30:27 <hydraz> > [0,3..27]
10:30:30 <lambdabot>  [0,3,6,9,12,15,18,21,24,27]
10:30:34 <Will_is_here> I'm really bad at math. 
10:30:40 <hydraz> which is enumFromThenTo? I guess
10:30:50 <EvanR> :t enumFromThenTo
10:30:52 <lambdabot> Enum a => a -> a -> a -> [a]
10:31:00 <hydraz> the enum typeclass has the stupidest names
10:31:12 <EvanR> names are stupid
10:31:22 <EvanR> we should all be using a canonical set of debruijn indices
10:31:26 <AzureStigma> Enum a => a -> a -> a -> [a] has 3 arugments right
10:31:44 <EvanR> 4 if you count the Enum a instance
10:31:53 <EvanR> which you normally don
10:31:57 <AzureStigma> cool
10:32:09 <Welkin> hydraz: the names make sense
10:32:13 <AzureStigma> im stuck on this currying section of chapter 5
10:32:22 <AzureStigma> i dont get it lol
10:32:31 <dolio> > 50 * 51 + 2 * 51 * 50
10:32:33 <lambdabot>  7650
10:32:41 <EvanR> a -> a -> a -> [a] is parsed as a -> (a -> (a -> [a]))
10:32:50 <Welkin> AzureStigma: currying is taking a function that takes 2 parameters into a function that take 1 parameter and returns another function of one parameter
10:32:52 <EvanR> which is isomorphic to (a,a,a) -> [a]
10:33:06 <Welkin> :t curry
10:33:08 <lambdabot> ((a, b) -> c) -> a -> b -> c
10:33:19 <AzureStigma> now it makes sense thanks welkin
10:33:28 <AzureStigma> perhaps i shuld go back to the chapter
10:33:28 <hydraz> ((a,b) -> c) -> (a -> b -> c)
10:33:55 <Welkin> currying is what allows us to do partial application
10:33:55 <Will_is_here> I'm out of here! I hate math! 
10:34:19 <AzureStigma> i dont get the partial application example he gave in hte book
10:34:28 <Welkin> what book?
10:34:28 <AzureStigma> was lost
10:34:33 <AzureStigma> the haskell book
10:34:44 <Welkin> an easy one is this: (+) 3
10:34:48 <Welkin> :t (+)
10:34:51 <lambdabot> Num a => a -> a -> a
10:34:54 <Welkin> :t (+) 3
10:34:57 <lambdabot> Num a => a -> a
10:34:59 <Welkin> :t (+) 3 4
10:35:01 <lambdabot> Num a => a
10:35:07 <EvanR> how about one without constrains and variables
10:35:11 <Welkin> lol
10:35:15 <AzureStigma> no thats too complicated 
10:35:19 <AzureStigma> i give up
10:35:20 <AzureStigma> lol
10:35:49 <EvanR> dont we have any functions lying around which are polymorphic as hell
10:35:54 <EvanR> arent
10:36:05 <Welkin> yeah
10:36:10 <Welkin> :t (++)
10:36:12 <lambdabot> [a] -> [a] -> [a]
10:36:27 <monochrom> wait, (+) isn't polymorphic enough?
10:36:33 * PaulePanter wants to cry.
10:36:34 <pkmx> EvanR: hmm it is surprsingly hard to think of one when you need it
10:36:35 <PaulePanter> checking version of ghc... 7.6.3
10:36:35 <PaulePanter> configure: error: GHC version 7.8 or later is required to compile GHC.
10:36:42 <Welkin> :t (++) "a"
10:36:43 <lambdabot> [Char] -> [Char]
10:36:55 <AzureStigma> when will i actaully start programming for realz in the haskell book i feel like im just learning about haskell but not programming
10:37:00 <EvanR> Char stuff isnt polymorphic as hell but nothing is multi-argument
10:37:05 <Welkin> :t (++) "a"Azuno idea, I haven't read that book
10:37:07 <lambdabot> error: parse error on input ‘,’
10:37:08 <cocreature> :t const
10:37:09 <lambdabot> a -> b -> a
10:37:17 <Welkin> AzureStigma: no idea, I haven't read that book
10:37:33 <AzureStigma> what have you read?
10:37:40 <Welkin> AzureStigma: if you want to start programming right away, check out the UPenn course
10:37:45 <Welkin> @where learnhaskell -- AzureStigma 
10:37:45 <lambdabot> https://github.com/bitemyapp/learnhaskell
10:37:53 <EvanR> thats not the upenn course
10:38:06 <AzureStigma> ive seen the upenn course
10:38:15 <Welkin> AzureStigma: LYAH, some RWH, lots of papers and blog posts, and discussions in this channel
10:38:15 <AzureStigma> website that is good notes
10:38:23 <Welkin> and I did the upenn course and a little nicta
10:38:45 <AzureStigma> u did it in upenn or the syllabus
10:38:50 <Welkin> no
10:38:59 <Welkin> I went through the course material online
10:39:05 <AzureStigma> o ya i see
10:40:27 <frontendloader> wish the react/react native community was even half as active as this
10:41:04 <Ed___> I got this question im having trouble with. How many numbers from the list [150, 151, 152, ...] must be added before the sum becomes larger than 100,000?
10:41:45 <Ed___> so im thinking ofcourse of generating a list and then taking the length of it. but how do i limit the generation of the list to have a sum of under a certain number/?
10:42:19 <EvanR> generate the sequence of partial sums
10:42:24 <EvanR> then takeWhile
10:42:34 <Ed___> ok
10:42:41 <EvanR> since you dont care about the actual numbers, just the length
10:42:42 <Welkin> Ed___: because lazy evaluation
10:42:49 <Ed___> right
10:43:19 <pkmx> > length $ takeWhile (<= 100000) $ scanl (+) 0 [150..]
10:43:23 <lambdabot>  323
10:43:35 <pkmx> > sum [150..323]
10:43:37 <lambdabot>  41151
10:43:40 <EvanR> homework complete
10:44:01 <pkmx> > sum [150..(150+322)]
10:44:03 <lambdabot>  100453
10:44:27 <EvanR> maybe not
10:45:39 <Ed___> not my homework. others' hw lol
10:49:36 <AzureStigma> i apologize if i went of topic i cant rem if i did today lol sorry if i did though
10:52:37 <ania123> what is a different between those programs: 
10:52:53 <ania123> fac 0 = 1 fac n = n * fac (n-1)
10:52:55 <ania123> and
10:53:10 <ania123> factorial n = if n == 0 then 1 else n * factorial (n - 1)
10:54:05 <kadoban> ania123: Style, largely. I believe they should operate very similarly, if not exactly the same.
10:54:12 <EvanR> http://www.willamette.edu/~fruehr/haskell/evolution.html?
10:54:17 <EvanR> ^ uh oh... the original seems to be 404ing
10:54:22 <AzureStigma> isnt one the second is an arugment for factorial
10:54:26 <EvanR> well not resolving
10:55:12 <pkmx> it resolves for me
10:55:42 <pkmx> nvm, i see the original now
10:56:06 <ania123> using "if" in the program does not give feeling to be language functional
10:56:07 <ania123> bo?
10:56:24 <EvanR> agreed
10:56:53 <hydraz> fac n | n < 2 = 1 | otherwise = n * fac (n - 1)
10:57:24 <EvanR> prematurely optimizing haskell programmer
10:58:31 <johnw> why would "if" be non-functional?  case analysis is a fundamental building block of functional programs built in the presence of algebraic data types, for which "if" is just sugar.  I guess then "let" is also not very functional?
10:59:02 <nitrix> ongy: jonored http://imgur.com/a/IjCOW
10:59:37 <johnw> I've always thought of functional as "my functions are mathematical functions: always same output for same input, and only the output stated by the type"
10:59:37 <EvanR> and you can consider pattern matching as sugar for a huge nests of if combine with =='s
10:59:51 <ggole_> There's lots of languages in which if is not a function
10:59:52 <johnw> EvanR: == requires an Eq instance
11:00:10 <EvanR> if all constructor tags were exposed as numbers
11:00:20 <EvanR> which you could inspect
11:00:26 <johnw> how would you access the arguments?
11:00:42 <EvanR> x[0] x[1] x[2] ;)
11:02:23 <jonored> nitrix: I don't dispute that what you've shown here is local and works, I question that you can do an update to the new configuration in constant time and keep the data structure for accessing a band constant time.
11:03:12 <johnw> EvanR: I guess what I mean is that you can case analysis a Reader to access the function it contains, but you can't test if it's == to another Reader because you can't compare functions that way
11:03:29 <chsn> where can I find a study on the inefficiency icrease due to laziness vs strict evaluation (i.e. the cost of creating thunks, the indirection involved in executin them, and lastly, the cost of overwriting the old pointer with the actual value) ?
11:03:40 <jonored> if there's some ln(n) hiding in one of the data structures I also have no hesitation as to whether it works :)
11:04:23 <nitrix> jonored: Yes. The concept of knowing which "band" does the "wire" belongs to is via a pointer. It allows to dereference it to check for equality nd also easily merging two bands into one (without having to update each tile independently).
11:05:27 <nitrix> jonored: The only thing that is left is adjusting the neighbours with the new wiring when something changes, but that's as easy as following the perimeter from before and after the gap created.
11:06:05 <jonored> nitrix: Following the perimeter from the cut point isn't doable in constant time.
11:06:14 <EvanR> in haskellandia if then else is a special case of pattern matchin, which is fundamental. but in every other language if then else is fundamental so thats why it feels unclean
11:06:20 <nitrix> jonored: They're already wired though.
11:06:41 <nitrix> jonored: Deletion is just reconnecting the wire you broke locally.
11:06:43 <Jenaf> my code works, yay
11:07:04 <johnw> EvanR: ah
11:07:04 <Jenaf> question: is there a less ugly way to solve the issue in lines 21 and 22 ?
11:07:06 <Jenaf> https://gist.github.com/anonymous/a162e2f0f69bea33930fb48af36853da
11:07:06 <EvanR> non-functional is probably a bad characterization in many ways
11:07:49 <Jenaf> using f1=1::float in a where block kinda feels ugly
11:08:03 <dfeuer> Hello, persons! Has anyone seen mokus around? I've sent him a couple pull requests for dependent-map and dependent-sum but I've gotten no response.
11:08:21 <nitrix> mokus: ^
11:09:01 <jonored> nitrix: it /looks/ like your wire is local, "the boundary between these tiles" and band is "this perimeter loop, all of it"?
11:09:02 <EvanR> Jenaf: you shouldnt need that because fPscale takes a Float argument
11:09:04 <dfeuer> nitrix, yeah, I've seen his computer logged in, but I haven't actually seen any activity therefrom. :-/
11:09:32 <EvanR> in fact you should be able to put 1/3
11:09:41 <EvanR> instead of f1/3
11:09:47 <Jenaf> I'll try again, but iirc i kept getting type missmatches
11:10:02 <nitrix> jonored: Yes. The wire are what crosses a given tile. The band is always the perimeter of the shape, it's a cycle on purpose.
11:10:03 <mokus> dfeuer: yea, i'm still around, just very very swamped
11:10:13 <mokus> dfeuer: got a 11-mo old baby that doesn't sleep :)
11:10:32 <Jenaf> okay, now it works...
11:10:37 <Jenaf> yay ^.^
11:10:46 <nitrix> jonored: (B) shows three wires crossing one cell, on the right, you see a cell arrangement, such that the full band is visible.
11:10:56 <dfeuer> mokus, that's a good reason. If you don't think you'll get to them soon, do you think maybe you could give me commit access to the repos?
11:11:08 <nitrix> jonored: It's possible the wire a cell sees is the same band looping back on itself or something. The cell has four anchor points.
11:11:28 <Jenaf> with that program there is a HUGE difference between loading it in ghci or compiling it (runtimewise)
11:11:34 <jonored> nitrix: Yep. Are the wires just stored in an array so you can do constant-time lookups or something?
11:12:03 <EvanR> compiling will do optimizations, especially with -O2, but im not sure what ghci does
11:12:05 <mpickering> I'm not sure how to represent this. I have a fixed-size circular data structure which I need to support random access and also "next" and "prev" to find the adjacent item.
11:12:11 <mpickering> Maybe just a vector is the best representation?
11:12:13 <mokus> dfeuer: i'll make a point to get to them, and commit access also isn't out of the question
11:12:30 <dfeuer> Thanks, mokus, on both counts. I'll try to be patient.
11:12:38 <EvanR> mpickering: yeah, thats a classic ringbuffer
11:12:44 * dfeuer is very bad at being patient.
11:13:17 <Jenaf> EvanR yeah ^.^ and i guess the highly recursive nature of the prolem makes that difference even bigger
11:13:21 <mokus> dfeuer: things should be easing up a bit here... we've had a rough few months with the kids bringing home a new illness every week it seems... that can't last forever, I keep telling myself :) 
11:13:30 <nitrix> jonored: It's stored in the cell itself. It's a grid and the grid lookup is constant.
11:14:07 <jonored> nitrix: Okay. And did you say that the band is a pointer from the wire?
11:14:26 <mpickering> EvanR: So you think I should use a vector? Perhaps there is an implementation of this already on hackage
11:15:08 <dfeuer> mpickering, is access single-threaded (so you can use ST or IO stuff)+
11:15:08 <dfeuer> ?
11:15:12 <nitrix> jonored: Each cell has 4 connectors for a wire, the wire is a pointer to a given band (that's how you can translate to local to global). Bands can be merged together by changing the pointed value without through all the tiles at once.
11:15:26 <mpickering> dfeuer: yes
11:16:18 <dfeuer> mpickering, sounds good then. Depending on context, you may need to "null out" the invalid entries to free up memory.
11:16:28 <mpickering> it really seems like a fixed size vector is what I need, because I don't need insertion at all
11:16:32 <jonored> nitrix: Okay. How do you make it so that after a merge, updating the pointed-to value in one of them updates all of them?
11:16:41 <mpickering> I'll look on hackage to see if someone else has already packaged this up
11:16:45 <dfeuer> Oh, so they're all always valid!
11:16:46 <jonored> (so you can merge again)
11:16:48 <dfeuer> Super-that.
11:17:37 <dfeuer> mpickering, if your buffer isn't huge, you should probably be sure to use a SmallMutableArray#-based implementation, to avoid the card-marking stuff. If it's large, then be sure not to.
11:18:23 <jonored> (or is it you're updating the pointers, which would cost O(|E|)?)
11:30:57 <nitrix> jonored: A neat IORef(IORef()) trick presumably :P
11:31:09 <EvanR> Fix IORef
11:31:20 <shapr> : IORef
11:31:24 <shapr> :t IORef
11:31:25 <lambdabot> error: Data constructor not in scope: IORef
11:31:31 <nitrix> jonored: https://github.com/nitrix/lspace/blob/master/src/Link.hs#L42
11:31:34 <nitrix> jonored: I've done nastier.
11:32:19 <EvanR> :k Fix
11:32:20 <lambdabot> error:
11:32:20 <lambdabot>     Not in scope: type constructor or class ‘Fix’
11:32:36 <nitrix> Where did Fix go o: ?
11:32:54 <jophish> There are so many 'Fix's in Hackage
11:33:14 <jonored> nitrix: that smells like actually a bit of a tree, which gets you to a (small-constant, but still) ln(n)
11:33:23 <nitrix> jophish: At least we don't have Broken things :P
11:33:32 <hydraz> :D
11:33:37 <EvanR> Broken IORef
11:36:35 <nitrix> jonored: I doubt it, but it'll depend how awkward Haskell makes it. The theory works though and seems better than the original O(|V|+|E|)
11:37:46 <nitrix> I think what helped is delegating some of the responsabilities. Made assumptions were made like O(1) lookup in the grid, etc.
11:37:55 <nitrix> *But
11:38:13 <nitrix> It might bite me in the end, but I can still see the light for now :P
11:43:22 <jonored> nitrix: It's not really a thing that haskell changes, it's a "how is adding more indirection letting you maintain equality when you're iterating while avoiding a number of updates dependent on the size of the input" thing.
11:51:02 <nitrix> The beauty is that you can duplicate IORefs. You share the same IORef for all the tiles belonging to a given "band". When that band needs to be merged with another, you can update them all at once by changing that pointer. But, as you may notice, that only work for subgroups, so you need an IORef(IORef()) and make sure the inner IORef is the one that all cells have in commons and you use the outer one to
11:51:03 <nitrix> achieve that.
11:52:33 <nitrix> Or phrased differently, the other IORef lets you modify an entire group of tiles related to a band at once, and what's changed is the inner IORef which lets you ensure the even bigger groups you're going to create will all have the same pointer in common.
11:53:41 * hackagebot mustache 2.1 - A mustache template parser library.  https://hackage.haskell.org/package/mustache-2.1 (justus)
11:53:48 <nitrix> That's the part that I'm not too sure.
11:54:25 <nitrix> jonored: Well, even if it ends up a lookup table, it'll still be O(log n) as you said.
11:59:11 <jonored> nitrix: Yeah, not saying that O(log n) is bad at all, that's still a useful chunk of algorithm (although if you want all the cutpoints at a stage O(|V|+|E|) is better than iterating it), I just don't think that pointers trivially get you the datastructure you need to represent a band with all the operations you'd need to be O(1) to hit O(1) overall.
11:59:54 <nitrix> I'll scratch my head real hard.
12:00:47 <jonored> (and do make it easy to get updating that kind of "these are the same" "these are not the same" wrong.)
12:01:16 <nitrix> I know. It's easy to fool oneself thinking it works and then notice bugs in the implementation.
12:01:41 <nitrix> jonored: It works in drawings, I just need to be really clever in the implementation to get O(1) instead of O(log n).
12:02:31 <jonored> nitrix: I have no objection at all to it involving a constant number of the primitives the drawings rely on :)
12:03:36 <nitrix> I like to think my lack of knowledge on the subject helps not to not be too restrained mentally :P
12:03:47 <nitrix> Of course that's a double edged sword.
12:17:02 <f-a> I have got a simple haskell script. After upgrading to ghc 8 it fails with: shuffle.hs: <command line>: can't load .so/.DLL for: /home/f/.cabal/lib/i386-linux-ghc-8.0.1/mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM/libHSmtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM-ghc8.0.1.so (/home/f/.cabal/lib/i386-linux-ghc-8.0.1/mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM/libHSmtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM-ghc8.0.1.so: cannot enable executable stack as s
12:17:08 <f-a> hared object requires: Operation not permitted)
12:17:26 <f-a> I am puzzled at the error, maybe my ~/.cabal got corrupted?
12:17:38 <f-a> (I can fpaste the script if you want) 
12:19:11 <sm> are you on some securified distro ? why is it dealing with the stack executable ?
12:19:44 <f-a> sm: debian stable, I don't know why it is pulling this
12:19:46 <geekosaur> got nothing to do with fpcomplete's stack, but executable stack segment
12:20:13 <sm> ohh
12:20:45 <geekosaur> http://linux.die.net/man/8/execstack
12:21:01 <sm> wild guess, file permissions ? maybe you did something as root ?
12:21:41 <geekosaur> this is generally associated with newer linux kernels,  but possibly ghc8 needs to be modified to enable executable stack *or* to mark shared objects as not needing it
12:22:11 <f-a> geekosaur: so you are saying I should report it to ghc as a bug? 
12:22:12 <geekosaur> "ELF binaries and shared libraries now can be marked as requiring executable stack or not requiring it. This marking is done through the p_flags field in the PT_GNU_STACK program header entry. If the marking is missing, kernel or dynamic linker need to assume it might need executable stack"
12:22:33 <f-a> or just ask in #ghc?
12:22:42 <grantwu> In this: https://bpaste.net/show/5b616776ac44 , why does bind work but test does not work?
12:23:04 <grantwu> I'm not understanding how parenthesization and type signatures works...
12:23:08 <geekosaur> probably the latter. not clear it's a bug unless you consider "not religiously rewriting the world every time the linux kernel devs decide to change key functionality underneath you" a bug
12:23:46 <f-a> thanks geekosaur, sm. I'll pester #ghc
12:23:58 <Cale> grantwu: Given test's type signature, both x and f should have type Integer, and the right hand side of the equation (well, both sides) should have type Integer -> Integer
12:24:20 <Cale> grantwu: But you're applying f to x as if it were a function.
12:24:35 <Cale> grantwu: -> associates to the right
12:24:51 <Cale> That is,  A -> B -> C -> D  means  A -> (B -> (C -> D))
12:24:53 <grantwu> Cale: Okay, I guess that makes sense
12:25:01 <grantwu> I don't understand the top function though
12:25:03 <Cale> and function application associates to the left, so when you write
12:25:04 <geekosaur> bind takes one parameter, a function; it produces one result, a function
12:25:09 <Cale> f x y z
12:25:16 <Cale> it means ((f x) y) z
12:25:21 <geekosaur> the first function takes a Float and produces a tuple (Float,String)
12:25:31 <grantwu> geekosaur: Okay, but the definition has two parameters
12:25:44 <geekosaur> the second (result) function takes a tple (Float,String) and produces a tuple (Float,String)
12:25:47 <Cale> grantwu: A function of two parameters is the same thing as a function which produces another function as its result
12:25:53 <geekosaur> no, it has one parameter and one result
12:26:13 <Cale> All functions in Haskell really only have one parameter, and one result. Sometimes that result is another function.
12:27:05 <maerwald> we still lazily use the expression "this function has 3 parameters"
12:27:05 <Cale> So in this case, bind is a function which when applied to a function f' of type Float -> (Float, String)
12:27:16 <Cale> is going to produce a function of type (Float, String) -> (Float, String)
12:27:40 <Cale> So in the equation defining it, we apply that resulting function to a pair (gx,gs)
12:27:44 <grantwu> hrm, ok
12:27:51 <Cale> and say what the result of *that* will be
12:28:02 <Cale> which is some value of type (Float, String)
12:28:08 <geekosaur> however: the first parameter is a function, whose result type is a tuple. now, remember that functions can be substituted into an expression, expanding it out; this enables you to refer to the tuple
12:28:52 <Cale> If it makes you more comfortable, you can move the binding of the tuple to the other side of the equation, using a lambda, which is basically the same
12:29:10 <Cale> bind f' = \(gx,gs) -> let (fx,fs) = ... in ...
12:29:29 <geekosaur> this is one of the things you get from purity, you can always replace a function by its definition, and this lets you "unhide" things that would otherwise be hidden inside eg. a parameter
12:29:31 <ReinH> maerwald: yes, when the fact that this is technically incorrect doesn't cause problems, it can be a useful shorthand.
12:29:33 <Cale> We could go yet another step as well and move the f' to the other side
12:29:54 <Cale> bind = \f' -> \(gx,gs) -> let (fx,fs) = ... in ...
12:30:31 <Cale> (you can't always do this because of the way that failed pattern matches continue to the next equation, but it works in this case because the patterns can't fail to match)
12:32:10 <Cale> grantwu: So, in case it's not obvious, the type signature you probably wanted for test is  test :: Integer -> (Integer -> Integer) -> Integer
12:32:29 <maerwald> ReinH: imagine ppl saying "this function, given an Int, produces a function that, given an Int, produces a function ..." :P
12:32:53 <ReinH> Yes, that's what I mean.
12:34:33 <Cale> ReinH: Well, it's not even technically incorrect -- a function which takes an Integer and a String and produces a Bool is the very same thing by definition as a function which takes an Integer and produces a function which takes a String and produces a Bool
12:37:41 <jle`> anyone know if a nice name for the hof (a -> (b, c)) -> (a -> b, a -> c) ?  it's a bit like distributing exponents, (b*c)^a = b^a * c^a
12:38:09 <Jenaf> distribute
12:38:39 <Jenaf> https://en.wikipedia.org/wiki/Distributive_property
12:38:51 <Cale> (fst .) &&& (snd .)
12:38:59 <Jenaf> or that :-P
12:39:20 <Jenaf> thats like map on a pair instead of a list
12:39:57 <grantwu> Cale: I guess I'm just being tripped up by differences between Haskell and SML
12:40:02 <jle`> hm, in what way is it a map on a pair
12:40:09 <jle`> it doesn't take any pairs as inputs
12:40:36 <grantwu> wait, nvm
12:42:15 <Cale> grantwu: Well, in SML, they just, by convention, usually tuple their arguments rather than currying functions.
12:43:12 <grantwu> In Haskell, this works fine:
12:43:14 <grantwu> let test :: (Integer -> Integer) -> (Integer -> Integer)
12:43:17 <grantwu>     test f x = f x
12:43:33 <Cale> I'm not sure this is in any way fundamental, but I'm not familiar enough with the details of SML to tell you if its function arrow associates to the right, and function application associates to the left.
12:43:38 <grantwu> In SML, this does something different:
12:43:39 <grantwu> fun test (f : int -> int) (x : int -> int) = f x
12:43:42 <grantwu> Cale: Pretty sure it does
12:44:08 <grantwu> (well, that doesn't typecheck at all)
12:44:13 <Cale> oh?
12:44:22 <Cale> oh, no, that's not right
12:44:25 <grantwu> er
12:44:27 <Cale> x should have type int
12:44:35 <grantwu> if you move the type signature out
12:44:37 <Cale> if you want to make things the same as in Haskell
12:44:44 <grantwu> fun test f x : (int -> int) -> (int -> int) = f x
12:44:48 <grantwu> this does something very wrong too
12:44:54 <Cale> no, test f x : int
12:45:08 <grantwu> I want to give a signature for the whole function
12:45:13 <Cale> (test : (int -> int) -> int -> int) f x = f x
12:45:16 <Cale> does that work?
12:45:58 <grantwu> Er, I don't think you can give type signatures that way in SML
12:46:25 <grantwu> There's something subtly different though between SML and Haskell and I can't pin down precisely what it is >_<
12:47:03 <Cale> There are lots of differences, but I don't think this is one of them, apart from what conventions people use for cultural reasons
12:47:31 <dmwit> solrize: Yes, but the point is that reversals happen quite rarely -- each element is visited at most one extra time by reversals.
12:48:28 <Lgm> Hello, I am working through Learn You A Haskell on Windows and it is currently telling me to compile a helloworld program using Cygwin, but this doesn't seem to work anymore. Is there another way to compile progams on Windows?
12:48:53 <Cale> - fun test (f : int -> int) (x : int) = f x;
12:48:53 <Cale> val test = fn : (int -> int) -> int -> int
12:48:57 <alercah> https://www.haskell.org/platform/windows.html
12:49:00 <Cale> ^^ from the smlnj interpreter
12:49:24 <dmwit> byorgey: `getSplit :: MonadSplit g m => m g` seems quite unnatural, since none of the `MonadRandom` operations deal with generators explicitly. I propose replacing this method with `forkRand :: MonadSplit m => m a -> m a` (by analogy to `forkIO`).
12:49:32 <grantwu> Cale: Okay, but that's kind of parenthesized differently
12:50:11 <Cale> - (test : (int -> int) -> (int -> int));
12:50:11 <Cale> val it = fn : (int -> int) -> int -> int
12:50:21 <Cale> -> associates to the right, so it doesn't matter
12:50:31 <Cale> It's just removing the extraneous parens
12:50:38 <geekosaur> Lgm, I don't think cygwin has ever really been recommended for ghc. msys2 is what it currently expects
12:51:11 <Cale> (A -> B) -> (C -> D) and (A -> B) -> C -> D mean precisely the same thing
12:51:30 <Lgm> ok thank you geekosaur, I'll try that
12:52:24 <dmwit> byorgey: With the existing interface, one might implement `forkRand` specialized to `RandT` as something like `forkRand m = do { g <- getSplit; liftRandT (\g' -> do { (v, _) <- runRandT m g'; return (v, g) }) }` (which... I hope demonstrates the awkwardness of having `getSplit` as the primitive).
12:52:42 <Cale> - (test : (int -> int) -> (int -> int)) (fn x => x+1) 5;
12:52:42 <Cale> val it = 6 : int
12:52:47 <geekosaur> (experts can make it work with cygwin. but cygwin is, or ought to be labeled as, kinda experts-only anyway... it's not so much a development environment as it is a unix emulator)
12:52:49 <Cale> seems to work just fine :)
12:53:09 <dmwit> Cale: You may enjoy my last two comments as well.
12:53:41 <Cale> dmwit: I agree
12:53:56 <alercah> Lgm: Alternatively, use the Linux subsystem
12:56:38 <dmwit> byorgey: Oh, it seems I'm not the only one to think of this; there's already an issue on the tracker. Sorry for the noise. =P
12:57:31 <jle`> it doesn't take any pairs as inputs
12:57:43 <jle`> ah, sorry
12:58:34 <Lgm> thank you alercah, but as far as I can tell Linux subsytem is only for Windows 10 and I have 8.
12:59:59 <alercah> Lgm: yeah, so just grab the platform
13:01:08 <solrize> dmwit, yeah, i was concerned about the memory usage of storing those elements... the length of the queue is O(n**2) after generating n outputs.  but i guess the number of reversals will be small so the larger enumFroms will never get expanded
13:01:22 <solrize> i should be able to calculate some bounds... thanks
13:02:54 <Ed___> "let ans = [x | x <-[150..], sum[150..x] <= 1000000]" goes on infinitely. can I have a break somehow in place so it doesn't?
13:03:18 <erisco> take n  of them
13:05:03 <grantwu> Cale: Okay, I think I had some misconceptions about how SML worked
13:07:18 <jle`> Ed___: well, what are you looking for?
13:07:21 <jle`> the first one hundred values?
13:07:27 <jle`> you can `take 100 ans`
13:07:51 <jle`> oh i see, you have a predicate
13:07:53 <jle`> you can use takeWhile
13:08:04 <Ed___> im looking for it to finish once the "sum[150..x] < 1000000" does not hold anymore
13:08:14 <jle`> > takeWhile (\x -> sum [150..x] <= 1000000) [150..]
13:08:16 <lambdabot>  [150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168...
13:08:38 <jle`> > takeWhile (\x -> sum [150..x] <= 400) [150..]
13:08:41 <lambdabot>  [150,151]
13:09:22 <Ed___> oh ok
13:09:43 <Ed___> any way to do it without the lambda function inside the takeWhile?
13:09:47 <Ed___> and without scanl
13:09:50 <jle`> the reason it originally went on forever was because it doesn't know that it won't eventually find an x with a sum <= 1000000 again
13:09:51 <zv> this question isn't *technically* haskell related but so far nobody has been able to answer this question: phillip wadler (here: 
13:09:55 <zv> err, sorry
13:10:20 <Welkin> imposter!
13:10:21 <jle`> it thinks that maybe if it looks at just one more x, it might find one where the sum is less than a million
13:10:25 <Welkin> you are not philip wadler!
13:10:38 <jle`> the lambda is probably the cleanest way, but you couild also
13:10:49 <jle`> @pl \x -> sum [150..x] <= 1000000
13:10:49 <lambdabot> (<= 1000000) . sum . enumFromTo 150
13:10:59 <ejbs> I've got a function which appends strings, a lot of them (with ++). Because of that it's slow, how can I make it fast?
13:11:12 <ReinH> ejbs: use a difference list
13:11:22 <ReinH> @hackage dlist
13:11:22 <lambdabot> http://hackage.haskell.org/package/dlist
13:11:37 <ReinH> This one neat trick for making appends O(1), computer scientists hate him.
13:11:38 <jle`> ejbs: are you appending from the right or the left?
13:11:40 <Welkin> there is also a Builder which is just a wrapper for difference lists
13:11:40 <zv> i meant here: https://www.youtube.com/watch?v=IOiZatlZtGU says you can get a
13:11:42 <zv> 'proof' builder out of a normal 'modens ponens' deductive system. sicp
13:11:44 <zv> asks you to build one of these and I was wondering if anyone knew how I would
13:11:46 <zv> go about keeping track of the rules applied *AND* their unification the the 
13:11:48 <zv> EXACT order in which they are needed?
13:11:52 <zv> ugh, sorry again, my irc is being wild
13:12:12 <ReinH> ejbs: If you should be using Text instead (which is likely), you can use the text builder stuff.
13:12:32 <ejbs> jle`: The right
13:12:36 <Welkin> oh, Builder is just ByteString
13:12:46 <Welkin> or is it for Text too?
13:13:04 <Welkin> oh yeah
13:13:05 <Welkin> http://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Lazy-Builder.html#t:Builder
13:13:06 <ejbs> ReinH: I'll use Text
13:15:25 <ejbs> Hm. I need to Cabal install Text builder it seems.
13:15:55 <ejbs> Thanks guys, I'll have to ask my lecturer tomorrow about this, it all seems a bit unreasonable.
13:17:37 <jle`> any way i can lift an arbitrary-arity function over storable vectors?
13:18:05 <jle`> it seems like Data.Vector.Storable gives zipWith, zipWith3, zipWith4 ... zipWith6, so i think that's implying that you can't
13:18:36 <Welkin> ejbs: oh, this is for a class?
13:18:36 <jle`> might just be impossible without copying to non-storable and then copying back?
13:18:51 <Welkin> then you might want to use difference lists with String instead, for learning
13:19:25 <Welkin> ejbs: you can make your own difference lists
13:19:29 <Welkin> you don't need to use a package
13:19:48 <Welkin> it's just a partially applied append wrapped in a lambda
13:26:28 <athan> How are package imports used? Isn't it something like `import foo@Thingy`?
13:28:03 <puregreen> import "foo" Control.Foo
13:28:45 <athan> Thanks puregreen!
13:34:17 <EvanR> so if i want to combine a Reader and a List monad... is it just ReaderT r [] Foo ?
13:34:32 <EvanR> whats this i hear about "ListT done right"
13:34:51 <johnw> ListT don't right addresses the fact that ListT m a = m [a] is a horrible list monad transformer
13:34:55 <johnw> s/don't/done
13:35:33 <EvanR> i basically want a list monad with a context
13:35:39 <EvanR> read only
13:35:42 <johnw> better notions of ListT use some notion of "a stream of values with an accompanying 'effect' at each value"
13:35:57 <johnw> so you just want r -> [a]
13:36:01 <EvanR> yeah
13:36:04 <johnw> I'd use Reader r [a]
13:36:10 <EvanR> oh..
13:36:43 <EvanR> then to do concatMap i uh...
13:36:47 <johnw> unless you want the non-determinism-like effect of the list monad in addition
13:36:52 <EvanR> right
13:36:53 <johnw> @unmtl ReaderT r [] a
13:36:53 <lambdabot> r -> [] a
13:36:59 <johnw> so yeah, you were right before
13:37:32 <EvanR> ok so ListT done right is something entirely else
13:37:37 <johnw> yes
13:37:44 <johnw> ListT done right improves upon r -> m [a] :)
13:37:52 <johnw> relative to this discussion
13:41:19 <EvanR> i just tried it and i can ask, or lift lists to do branching
13:41:29 <jle`> luckily, ReaderT from transformers is already "ReaderT done right"
13:41:39 <EvanR> can i reverse them so i can just use lists and lift ask
13:42:31 <jle`> you'd need ListT for that
13:42:43 <EvanR> maybe this is why ReaderT is usually on the top
13:42:58 <jle`> i think ListT (ReaderT r) is a proper monad though
13:43:15 <jle`> um, ListT (Reader r)
13:43:24 <EvanR> with that ListT... im guessing you cant just write [1,2,3] as an action
13:43:32 <jle`> i think Reader r is a monad for which transformer's ListT does not break
13:43:57 <jle`> one of the rare ones
13:44:24 <jle`> EvanR: yeah, you'd have to manually hoist it
13:44:24 <EvanR> [return 1, return 2, return 3]
13:44:33 <jle`> traverse return [1,2,3], i think
13:44:39 <EvanR> oh geez
13:44:44 <jle`> which is equilvane to return [1,2,3], so that's nto too bad
13:45:04 <EvanR> guess ill stick with lift [1,2,3]
13:46:43 <jle`> *equivalent
13:51:11 <Lgm> Thank you geekosaur, alercah, my helloworld now compiles thanks to your efforts :)
13:51:13 <jle`> *equivalent
14:00:03 <camm> Why the unicode character *let c = '\xE007'* is printed like this *'\57344'* in ghci? What does that number mean?
14:00:30 <kadoban> camm: Probably the same thing in decimal
14:00:33 <glguy> Hex E007 is decimal 57344 (presumably)
14:00:41 <glguy> > 0xe007
14:00:43 <lambdabot>  57351
14:00:54 <kadoban> Hmm
14:01:22 <glguy> > text "\xe007"
14:01:24 <lambdabot>  
14:04:51 <camm> Oh, yeah. I feel like a fool :/
14:05:24 <geekosaur> ghci uses show, show on String converts anything outside 0x20..0x7e to an escape sequence
14:05:35 <geekosaur> :t text
14:05:37 <lambdabot> String -> Doc
14:05:41 <Phyx-> wait, Learn You A Haskell tells you to use Cygwin for a simple Hello World?
14:05:55 <Phyx-> what the actual..
14:06:07 <EvanR> LYAH, a cygwin tutorial
14:06:11 <geekosaur> `text` in lambdabot uses a prettyprinting library to force the string (its Show instance is id)
14:09:03 <camm> Thanks for the information :)
14:19:26 <silverCloud7> How do I install this module:  Could not find module `Data.Aeson.Text'   I'm using stack
14:19:42 <puregreen_> you need a newer aeson
14:20:22 <puregreen_> it looks like aeson-1.0 isn't on Stackage yet
14:21:08 <puregreen_> I'm not experienced with stack enough to answer your question, sorry
14:21:14 <EvanR> ah nice, having a List in your "monad stack" lets you cancel early like exceptions
14:21:25 <cocreature> silverCloud7: put aeson-1.0.0.0 in extra-deps
14:21:52 <kadoban> silverCloud7: Or just use whichever aeson you already have, if you're not set on aeson-1.0.0.0, there's docs out there for the version you have.
14:22:16 <cocreature> there are docs but I think the Text stuff in aeson is relatively new
14:22:26 <cocreature> so if you need that you need a recent version
14:29:16 <Ed___> is there a better way to generate a 256x256 board of zero's? "take 256 $ repeat $ take 256 $ repeat 0"?
14:30:03 <puregreen_> replicate 256 $ replicate 256 0
14:30:12 <Ed___> Thanks. thats much nicer
14:38:06 <silverCloud7> cocreature:  extra-deps.  Thanks!
14:41:45 <chsn> is https://github.com/knupfer/haskell-emacs for real ?
14:42:16 <Ed___> is there a way to do nested cases using the guards?
14:44:04 <puregreen> like multiway if?
14:44:36 <puregreen> | a == b = if | cond -> ...; | another cond -> ...;
14:44:41 <puregreen> | a /= b = ...
14:45:23 <Ed___> yea. something like that. thanks!
14:49:05 <dmwit> chsn: Is there a reason to believe it is a joke?
14:49:50 <chsn> dmwit: no, I just expected it'd be talked about here 
14:49:56 <chsn> given how awesome this would be
15:01:23 <lpaste> whittle pasted “Scoped type variables?” at http://lpaste.net/181694
15:03:15 <whittle> Why does the compiler introduce a new type variable b0 I’m using ScopedTypeVariables to make sure the type variables are the same? 
15:03:25 <geekosaur> remember that you need to forall the type variables you want to remain in scope
15:03:41 <whittle> geekosaur: Gah! 
15:03:45 <whittle> Thank you! 
15:22:30 <grantwu> I'm trying to understand http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html and I don't get the random number part at the end
15:22:40 <grantwu> Er, the Appendix
15:23:07 <grantwu> For example, bind shift needs two more arguments to be fully applied, but it is composed with AddDigit
15:23:23 <grantwu> AddDigit returns a tuple though
15:23:42 <grantwu> wait, hrm.
15:24:28 <hpc> grantwu: replace the function compositions with function application
15:24:34 <hpc> start with 
15:24:35 <hpc> er
15:25:05 <hpc> start with test x = (bind addDigit . bind shift . addDigit) x, and reduce per the definition of (.)
15:25:09 <hpc> @src (.)
15:25:09 <lambdabot> (f . g) x = f (g x)
15:25:55 <grantwu> oh, I need to compose bind addDigit and bind shift first, I think
15:29:47 <grantwu> hpc: Do you know if there's a way to find out the type of a parameter in a function definition?
15:30:03 <hydraz> Uh?
15:30:34 * glguy restarts hydraz
15:31:15 <JonReed> Hi, let's say `f1 :: (a -> m ())` and `f2 :: (a -> m c)`. Wasn't there some way to compose them using Applicative? My goal is to figure out a readable pointfree version of (liftIO $ print a) >> (liftIO $ print a).  
15:31:53 <glguy> join (>>) . liftIO . print 
15:32:30 <glguy> Also if you're OK with ()s, just write:   liftIO (print a) >> liftIO (print)
15:32:43 <glguy> No points for using up all the $s
15:34:21 <JonReed> Hm. What if `f1 :: a -> m b` and `f2 :: a -> b -> m ()`?
15:34:41 <spoonm> I joined expecting I'd have some questions answered by just lurking
15:34:44 <spoonm> now I have many more questions
15:34:49 <spoonm> and this still looks alien to me
15:35:00 <hydraz> did anyone use fmap fmap fmap near you, spoonm?
15:35:08 <spoonm> hydraz: they didn't need to ;-;
15:36:31 <glguy> spoonm: Well, glad to hear you're getting something out of it, then :)
15:37:01 <spoonm> glguy: really confusing, but I'm doing my best to understand this
15:37:53 <hydraz> If fmap fmap fmap is (a -> b) -> (f₁ (f a)) -> (f₁ (f b)), how many fmaps do I need for (a -> b) -> (f₂ (f₁ (f a))) -> (f₂ (f₁ (f b)))?
15:38:05 <spoonm> sadly what brought me to join was a need of mutable variables, which I looked up and got bunchs of pages stating it's either absent or advised against in haskell
15:38:27 <glguy> spoonm: Do youknow about IORef ?
15:38:33 <spoonm> nope
15:38:43 <spoonm> I don't really know haskell
15:38:53 <spoonm> I started learning yesterday, reading learn you a haskell  :v
15:39:22 <hydraz> Also STRef, if you don't need to perform I/O.
15:39:58 <spoonm> would you look at a file and try to explain me how things are being stored? :/
15:40:12 <spoonm> <things> in this case refers to windows in XMonad
15:40:19 <glguy> http://lpaste.net is a good place to put code you want to show
15:40:27 <spoonm> it's online already: http://xmonad.org/xmonad-docs/xmonad-contrib/src/XMonad-Layout-Minimize.html#minimize
15:40:47 <spoonm> I see "modify" and "windowset", also "W.stack"
15:41:08 <spoonm> just wanted to know how it's storing windows so I can change it from a stack to queue to fit my needs
15:41:41 <geekosaur> http://hackage.haskell.org/package/xmonad-0.12/docs/XMonad-StackSet.html
15:42:15 <hydraz> see also https://github.com/xmonad/xmonad/blob/master/src/XMonad/Core.hs
15:42:55 <geekosaur> http://hackage.haskell.org/package/xmonad-0.12/docs/XMonad-Core.html#t:XState the X monad is a stack of XState (mutable state such as the windowset), XConf (read-only state, mostly the user config but also things like root window that can't change without restarting X and losing all clients including xmonad), on top of IO
15:43:47 <pkmx> @JonReed: like liftA2 (>>=)?
15:43:47 <lambdabot> Unknown command, try @list
15:44:08 <geekosaur> mutable state in Haskell is often simulated by using the state monad, which is really just sugar for passing the "state" around as part of a tuple
15:44:11 <spoonm> so this module itself isn't storing anything?
15:44:36 <pkmx> :t liftA2 (>>=)
15:44:37 <lambdabot> (Applicative f, Monad m) => f (m a) -> f (a -> m b) -> f (m b)
15:44:43 <geekosaur> so it's not really a global variable, just a set of values that get implicitly passed to, and returned from, pretty much every function
15:44:53 <pkmx> with f = (->) c
15:45:09 <spoonm> geekosaur: so pretty much it "returns it around"?
15:45:39 <hydraz> spoonm: State is isomorphic(?) to s -> (a, s). You give it an initial state, and it returns a value (in the case of minimize window, nothing important: The unit value, ()) and the new state
15:46:31 <geekosaur> @unmtl ReaderT XConf (StateT XState IO) a
15:46:31 <lambdabot> XConf -> XState -> IO (a, XState)
15:46:47 <hydraz> That's incredibly handy
15:47:29 <spoonm> I understood less than half of that
15:47:51 <spoonm> I'll just continue reading that book and hope I'll learn something :(
15:48:01 <spoonm> something other than "man, C is comfortable"
15:48:04 <geekosaur> well, jumoing straight in ike that will probably be confusing, yes
15:48:15 <spoonm> geekosaur: yeah, it was a terrible choice
15:48:48 <spoonm> I've been using xmonad as my wm for a bit, but really didn't take the time to learn haskell, only used the extensions in xmonad-contrib and what little I could figure out in the config file
15:49:01 <geekosaur> it worked for me, but (a) I already knew some SML and (b) I understood X11, which actually counts for a bit more than knowing Haskell when it comes to understanding the guts of xmonad
15:49:03 <spoonm> changing an existing module is still way ahead of me
15:49:15 <grantwu> Is . left associative or right associative?
15:49:39 <glguy> grantwu: Type:   :i .    in GHCi
15:49:43 <hydraz> Is there a lambdabot equivalent to :i?
15:49:45 <grantwu> Hrm, right associative
15:50:46 <geekosaur> (and even so, it took me a year or so to feel at all comfortable about actually writing code as opposed to auditing sjanssen's understanding of how X11 worked :)
15:51:40 <jonored> spoonm: There's definitely some things that are very different from C, but there's also a /lot/ of concise power kicking around in Haskell. just plain old ghci is one of my indispensible "I need to futz with data" tools at this point.
15:52:24 <glguy> I occasionally use GHCi for futzing around with C using foreign imports defined in GHCi to mess with C libraries :)
15:53:12 * jonored feels like he should perhaps warn that C may stop being so comfortable with sufficient haskell exposure, though :)
15:53:28 * dmj futzes
15:53:46 <spoonm> jonored: ; - ;
15:53:52 <spoonm> don't say that, man
15:53:54 <spoonm> C is for Cute
15:54:04 <spoonm> pretty and proper
15:54:26 <hydraz> I find that using GHCi is easier (and more powerful) than grep/sed/awk, but maybe that's because I don't know regex all that well
15:54:33 <jonored> spoonm: Okay, honestly and properly, I mostly mean C++ and not C :)
15:56:45 <JonReed> pkmx: Yes this is it. Almost did not notice it. 
15:56:54 <JonReed> pkmx: Thanks
15:57:15 <geekosaur> any language with strcpy and strcat in its standard library is neither pretty nor proper :/
15:57:26 <geekosaur> (...nor secure)
15:57:31 <jonored> hydraz: I'm pretty good with regex and I still go for ghci. Type-checked repl with libraries over piped streams of bytes (almost) any day.
15:57:48 <hydraz> Yeah.
15:58:58 <drw_> I'w working through the GLUT tutorial here: https://wiki.haskell.org/OpenGLTutorial2
15:59:04 <hydraz> I find it easier to think in terms of list comprehensions than pipes, even though they're basically equivalent
15:59:09 <drw_> I've got spinning multi-colored cubes (no depth yet, about to start step 4). It seems as if everything is working fine unless and until I give the app some input. I can resize and move the window--no problem, but if I click the window, or pres a key I get a crash with this error:
15:59:18 <drw_> newBoundTask: RTS is not initialised; call hs_init() first
15:59:19 <hydraz> (in terms of structure, that is; not power)
15:59:28 <drw_> Do you know what this error means, and/or how to fix it?
16:01:37 <ReinH> It means that the GHC runtime is not running, but I don't know why that would be the case.
16:02:48 <drw_> ReinH: running it with stack...is that helpful?
16:02:58 <ReinH> It shouldn't matter
16:03:01 <geekosaur> the GLUT library is setting up its callbacks incorrectly somehow
16:03:25 <ReinH> Somehow GLUT either is calling hs_exit when it shouldn't, or failing to call hs_init when it should.
16:04:54 <ReinH> Which platform?
16:05:26 <drw_> ok, so maybe something is wrong with my OpenGL library...I'm using freeglut-MinGW-3.0.0-1  does that ring any bells for the more experienced?
16:05:42 <drw_> I'm running on Windows 8.1 64-bit
16:07:07 <geekosaur> this wouldn't involve the OS glut library, but the haskell bindings. freeglut doesnt know ghc's runtime from a hole in the ground >.>
16:07:09 <whittle> If I have a `type family X a :: * where type X A = RetA; type X B = RetB; ...` and a function `f :: Typeable (X a) => Foo -> Bar (X a)` can I satisfy this by deriving Typeable instances for RetA, etc.? 
16:08:19 <drw_> the readme includes instructions to put freeglut in my path--which I've done, and to include the dll when distributing it (not an issue at the moment)
16:08:46 <drw_> but it also mentions this:  Given a source file “test.c”, which you want to compile to an application “test.exe” dynamically linking to the DLL, you can compile and link it with the following commands (replacing the include and lib paths with the ones you created above if necessary):    gcc -c -o test.o test.c -I"C:\Program Files\Common Files\MinGW\freeglut\include"   gcc -o test.exe test.o -L"C:\Program Files\Common Files\MinGW\
16:08:57 <drw_> it all seemed out of scope to me, but now I'm not sure
16:09:12 <drw_> also, I wouldn't know how that fits into my "stack build" workflow 
16:09:23 <geekosaur> that's not the issue either
16:09:43 <Cale> whittle: Your function is going to be impossible to use, because it won't be possible to determine the type variable a, only knowing X a
16:09:47 <geekosaur> if that were the problem you would have gotten an ugly error message about not being able to find the GLUT library or symbols
16:10:20 <geekosaur> instead of it working up until you press a key and it tries to invoke the keyboardAndMouseCallback
16:10:27 <drw_> geekosaur: yeah, sort of my thinking...it worked "so far" but then mouse clicks send it over the edge.
16:11:16 <drw_> geekosaur: might I have written the handler in such a way that it 1) compiles and runs, but 2) crashes when executed?
16:11:48 <geekosaur> unlikely. this sounds like something the GLUT haskell binding itself has done wrong
16:11:57 <whittle> Cale: Is that why the compiler keeps going on about the type function not being injective? 
16:12:12 <geekosaur> your handler never even gets run, because the attempt to call it is what's raising the hs_init error
16:12:31 <Cale> Yeah, you might have X A = X B for distinct types A and B
16:12:33 <geekosaur> which is weird, because the runtime needs to be running to get that far
16:13:20 <Cale> whittle: and it needs to be able to infer which type a to use, even if you only refer to X a (though if you're really only referring to X a, perhaps you can just replace the whole thing with a type variable)
16:13:27 <hydraz> drw_: You could also try #ghc
16:14:09 <geekosaur> you may have to contact the maintainer of Graphics.UI.GLUT, which appears to be via https://github.com/haskell-opengl/GLUT/issues
16:14:11 <drw_> geekosaur: I'm not sure about that.  the handler defines that a "right arrow button" should move the position of the cubes in the tutorial...which I can see it do just before it crashes.
16:14:51 <geekosaur> ok, but anything written *in* haskell cannot be shutting the haskell runtime down
16:14:53 <whittle> Cale: Is this something to do with Typeable, or is this more generally true? 
16:15:10 <geekosaur> whittle, it is generally true that type families are not injective
16:15:21 <Cale> Generally
16:16:22 <Cale> Even if the existing instances of the type family are injective, the compiler can't know that it'll always be that way when it compiles your module either, because future modules might define further instances
16:17:06 <geekosaur> drw_, so this hgas to hbe happening at the point where Graphics.UI.GLUT is either calling into or returning from the C-level GLUT library. or possibly when it is returning from a Haskell callback given to a C GLUT function
16:17:16 <geekosaur> *has to be happening
16:20:56 <geekosaur> so I'd report this at the GLUT bug tracker. include that information about seeing the action happen before the crash --- that helps nail down somewhat where the problem is (the first place I would look, based on that, is at whatever is wrapping the Haskell callback passed to GLUT to ensure it's doing the right thing when the Haskell callback returns control to it)
16:33:50 * hackagebot octane 0.15.0 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.15.0 (fozworth)
16:57:44 <xcmw__> Will unsafeCastGObject throw an exception at runtime if cast to the wrong type? If not, is there any reason to use castToX functions over unsafeCastGObject?
16:58:19 <xcmw__> unsafeCastGObject is from glib
17:38:52 <alphonse23_> does anybody here subscribe to any haskell mailing lists.
17:39:05 <alphonse23_> what would you say is the best haskell related mailing list?
17:40:07 <Axman6> I guess haskell-cafe is the canonical community mailing list, but I personally don't subscribe to it because it's too high traffic - Reddit suits my needs much better
17:40:39 <alphonse23_> that's funny because I have a subscription to haskell cafe, and I notice the volume is really low
17:40:52 <alphonse23_> so I though there's another mailing list out there that's more worth while
17:41:11 <Axman6> oh, well it used to be very high.
17:41:15 <alphonse23_> maybe the community more invested into reddit, which is interesting, since most programming lang communities have a mailing list.
17:41:41 <Axman6> I find mailing lists so painful to interract with that I don't bother
18:11:47 <camm> Is a context the same as a container?
18:12:14 <JonReed> Is there a way to compose monads in this way `(print .>> print .>> print) "val"` where `.>>` is some magic that will glue together prints in a point free style. 
18:13:24 <shergill-web> Cale: are you by any chance in canada?
18:13:57 <chsn> how do I fire up a 'stack repl' inside of emacs ?
18:13:58 <kadoban> JonReed: I don't understand the goal.
18:14:10 <geekosaur> camm, a context has nothing to do with containers
18:14:26 <geekosaur> a context has to do with constraints on type variables
18:15:00 <kadoban> :t (>=>) -- this, JonReed?
18:15:02 <geekosaur> e.g. a context (Show a) means the type variable a must represent a type with a Show instance
18:15:02 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
18:15:03 <Axman6> > runWriter $  (tell >> tell >> tell) "test"
18:15:05 <lambdabot>  error:
18:15:05 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘tell’
18:15:05 <lambdabot>        prevents the constraint ‘(MonadWriter
18:15:17 <Axman6> :t runWriter
18:15:20 <lambdabot> Writer w a -> (a, w)
18:15:26 <Axman6> :t tell
18:15:30 <lambdabot> MonadWriter w m => w -> m ()
18:16:19 <geekosaur> I have no clue what that was supposed to be, since print wants a parameter but there's only one parameter there. and it doesn't produce anything worth printing itself
18:16:46 <Axman6> I'm sure there's a way of using reader
18:18:44 <JonReed> kadoban: Thanks (>=>) fits perfectly (I was just curious about composing monads in general, don't have yet have particular scenario in mind).
18:19:42 <pkmx> wouldn't >=> just print () for all but the first one?
18:20:12 <JonReed> pkmx: Oh.
18:20:17 <Axman6> yeah
18:20:38 <MarLinn> :t sequence_ . replicateM 3 print -- JonReed
18:20:39 <lambdabot> Show a => a -> IO ()
18:20:55 <Axman6> > runWriter . runReader "test" $  (tell >> tell >> tell)
18:20:57 <lambdabot>  error:
18:20:57 <lambdabot>      • Couldn't match type ‘[Char]’
18:20:57 <lambdabot>                       with ‘ReaderT (w0 -> m2 ()) Identity (Writer w a)’
18:21:13 <kadoban> JonReed: Cool
18:22:18 <camm> geekosaur: Thanks for the explanation! :)
18:23:15 <JonReed> MarLinn: I used `print` just an example. It can be (f1 a >> f2 a >> f3 a), where you want to compose (`f1 `magic` f2 `magic` f3 `magic`) a`
18:23:53 <JonReed> (`f1 `magic` f2 `magic` f3) a` *
18:24:24 <MarLinn> JonReed: how about swing mapM_ [print, print, print]
18:24:33 <MarLinn> (with Cales swing)
18:25:17 <MarLinn> the actions must have the same return type though
18:25:29 <pkmx> the `magic` you are looking for is liftA2 (>>)
18:26:34 <pkmx> > let (>>.) = liftA2 (>>) in execWriter $ tell >>. tell >>. tell $ "foo"
18:26:36 <lambdabot>  "foofoofoo"
18:27:07 <Axman6> MarLinn: swing?
18:28:04 <MarLinn> Axman6: swing f c a = f ($ a) c
18:29:13 <zell> Wow I just got slain. I refuse to handle errors and use (!!)
18:29:40 <zell> Never know when it's gonna get ya
18:30:14 <zell> This time it was most crucial and it broke
18:30:23 <zell> :(
18:30:25 <Axman6> @hoogle Int -> [a] -> Maybe a
18:30:34 <lambdabot> Safe atMay :: [a] -> Int -> Maybe a
18:30:34 <lambdabot> Agda.Utils.List (!!!) :: [a] -> Int -> Maybe a
18:30:34 <lambdabot> CLaSH.Util indexMaybe :: [a] -> Int -> Maybe a
18:30:58 <zell> Maybe!?
18:31:07 <Axman6> (would be (^? ix n) in the lens world)
18:31:13 <Axman6> yes?
18:31:23 <zell> Isn't that going to propagate like crazy!? I can't handle that refactoring
18:31:35 <Axman6> it's a computation that may fail, and may fail in basically only one way
18:31:43 <Axman6> or you intentionally trolling?
18:32:32 <orzo> I'm currently using --disable-library-profiling --disable-optimization.  Are there other things i can do to obtain the fastest possible build time?  I notice linking and preprocessing executables takes quite a bit of time too.
18:32:51 <zell> Well I don't really have a problem, I can't tackle that kind of bug easily so I guess I give up defeated. Just thought it'd say how much it got me bad this time
18:33:18 <peddie> zell: it doesn't have to propagate if you can handle the case where that element isn't present in the list right where you do the indexing
18:33:25 <peddie> i.e. if you have a default value
18:33:37 <peddie> woops, I meant e.g.
18:33:56 <jpl> If you pretend that things can't fail, you'll eventually be proven wrong
18:34:47 <zell> Id rather throw the error I guess i could write a safe assessor which did that and then it would be an easy renaming job
18:34:51 <JonReed> :t swing
18:34:53 <lambdabot> error: Variable not in scope: swing
18:35:39 <JonReed> > let swing f c a = f ($ a) c
18:35:42 <lambdabot>  <no location info>: error:
18:35:42 <lambdabot>      not an expression: ‘let swing f c a = f ($ a) c’
18:37:04 <Cale> shergill-web: Yes.
18:37:26 <orzo> what does the preprocessing executable step do anyway?  Not understanding the need for that phase makes the wait even more obnoxious
18:37:26 <dfeuer> UGHC.
18:37:29 <shergill-web> a wild (fellow) canadian appears!
18:37:43 <shergill-web> Cale: toronto here; yourself?
18:37:48 <Cale> Brantford
18:38:09 <zell> I like how gadts give me datatype contexts. I thought they were depreciated and had been removed from the language
18:38:23 <Cale> zell: what? :D
18:39:22 <Gues> Is there some sort of concatMapM?
18:39:50 <shergill-web> Cale: oh that's not too far at all :) any upcoming visits to toronto planned?
18:39:58 <zell> data DTC a where DTC ::  Constraint a => a -> dtc a
18:39:59 <Cale> shergill-web: I really need to try harder to make it to one of the Toronto Haskell meetups. Every time thus far that I've tried to plan it, the transportation has been a bit awkward.
18:40:17 <peddie> :t \f -> fmap concat . mapM f
18:40:19 <lambdabot> (Traversable t, Monad f) => (a1 -> f [a]) -> t a1 -> f [a]
18:40:32 <orzo> In addition to the two configuration flags, I've been trying to factor my code into smaller modules so rebuild is less painful.  But cabal/ghc takes considerable time just to decide there's nothing to be done anyway.
18:40:45 <shergill-web> Cale: tbh, i've been somewhat slack the last few months. but dann, ben and the others usually make for really interesting discussions
18:41:08 <Gues> Sorry, nvm. I don't need it.
18:41:29 <zell> Use traverse?
18:42:26 <zell> :t (>>=)
18:42:27 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:42:40 <dfeuer> No polykinded proxies in the olden days.
18:42:53 <dfeuer> Horrifying.
18:42:53 <orzo> time cabal build --- no changes, nothign to be done --> 11 seconds.
18:43:37 <orzo> clearly the build system is just not caching enough computations
18:44:01 <zell> :t join
18:44:02 <lambdabot> Monad m => m (m a) -> m a
18:44:28 <zell> :t fold
18:44:30 <lambdabot> (Monoid m, Foldable t) => t m -> m
18:45:05 <zell> :t concat
18:45:06 <lambdabot> Foldable t => t [a] -> [a]
18:45:12 <dfeuer> Cale, I think I fixed it: https://github.com/haskell/containers/pull/321/files
18:45:50 <MarLinn> orzo: I wouldn't call ghc a (full) build system. Maybe adding one on top (e.g. shake) could help? Not with basic build times, but with re-build caching
18:46:10 <Gues> If a let expression defines a variable that is only used in some cases of a following case expresion, is the variable only defined/evaluated in those cases?
18:46:13 <orzo> cabal is a build system, no?
18:46:50 <zell> (peddie) :t \f -> fmap join . mapM f
18:46:58 <orzo> how would i use shake to speed up my rebuild?
18:47:03 <zell> :t \f -> fmap join . mapM f
18:47:04 <lambdabot> (Traversable m, Monad m, Monad f) => (a1 -> f (m a)) -> m a1 -> f (m a)
18:47:07 <MarLinn> heh... good question... what *is* cabal, really.
18:47:24 <zell> Hmm
18:47:38 <peddie> zell: it's the same, concat is join for the list monad
18:48:01 <dfeuer> Cale, I realized today that I need to implement the new merge functions for Data.IntMap too. *barf*. That data structure is considerably harder to understand than Data.Map. How bad would it look to make a second major release to add that one, instead of trudging through it right now?
18:48:30 <peddie> zell: traverse is the same as mapM but with an Applicative constraint instead of a Monad one
18:48:31 <MarLinn> orzo: I just thought that shake might identify if intermediate files or the whole project didn't change
18:48:47 * dfeuer is a little tired of merge functions, even though he recognizes there's still room for various improvements.
18:49:03 <MarLinn> orzo: How that would integrate with ghc I don't know, it was just an idea
18:49:07 <orzo> does shake know more about haskell/ghc than me or would i somehow have to program this in shake?
18:49:21 <zell> Id rather Alternative came without the Applicative constraint
18:49:51 <dfeuer> orzo, you might want to start using stack. It seems to manage the building stuff pretty well, relatively speaking.
18:50:04 <dfeuer> (It's built on cabal, but works some magics)
18:50:15 <orzo> dfeuer: will it be faster?  I thought it just uses cabal anyway
18:50:17 <zell> Id like the concat without the wire funky fmap <$> business...
18:50:19 <peddie> zell, what would "a monoid on applicative functors" be without Applicative?  a monoid?
18:50:48 <zell> Yeah a monoid
18:50:55 <peddie> you're in luck
18:51:05 <peddie> there is a class called Monoid
18:51:19 <peddie> @hoogle Monoid
18:51:22 <lambdabot> Prelude class Monoid a
18:51:22 <lambdabot> module Data.Monoid
18:51:22 <lambdabot> Data.Monoid class Monoid a
18:51:54 <zort> ghc keeps saying "Not in scope: data constructor `Poke'" even though I have the line "import Data.Store.Internal (StaticSize, Poke)" in my imports and I'm quite sure Data.Store.Internal exports Poke
18:52:02 <zell> instance Overlapping f => Monoid (f a)?
18:52:18 <fizruk> zort: you import type
18:52:28 <zort> so I should do Poke(Poke)?
18:52:29 <fizruk> zort: try importing Poke(..)
18:52:35 <peddie> zell, I don't see that at https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html
18:53:13 <zort> oh yeah thanks
18:53:55 * hackagebot http-api-data 0.3 - Converting to/from HTTP API data like URL pieces, headers and query parameters.  https://hackage.haskell.org/package/http-api-data-0.3 (NickolayKudasov)
18:54:16 <zell> Oops that overlapping should be Alternative
18:55:03 <zell> Without the Applicative
18:55:36 <zell> instance Alternative f => Monoid (f a)?
18:55:51 <zell> That would work right?
18:55:53 <peddie> zell: there is a newtype for it called Alt
18:56:18 <zell> Sweet thanks
18:56:30 <peddie> Alternative f => Monoid (Alt * f a)   https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#g:5
18:57:03 <zell> I'm dealing with free alternatives, they don't compose easily
18:57:11 <peddie> zell: but wait, applicative is still a superclass of alternative, so your f there will have to be applicative still
18:57:23 <zell> No this is not good
18:57:59 <peddie> I'm not sure how it could be an alternative without f being applicative, maybe someone with more understanding can help you better
18:58:38 <zell> And how do I call an Alt of Monoids?
18:59:07 <zell> It has two composition functions
18:59:07 <spider_> Hello 
18:59:29 <peddie> an Alt of Monoids?
19:00:15 <ReinH> I'm not convinced that anyone knows what zell is trying to do
19:00:22 <zell> (Alt a, Monoid m) => a m
19:00:34 <peddie> zell, Alt is a newtype, not a type class
19:00:53 <spider_> Can someone kindly tell me whacking od channel this is
19:01:02 <zell> (Alternative a, Monoid m) => a m
19:01:15 <ReinH> spider_: what?
19:01:31 <peddie> spider_: it's a channel about the programming language haskell
19:01:48 <ReinH> zell: Is that supposed to be a question?
19:02:30 <spider_> Ow. I'm new here. I'm sorry to interrupt, i just saw this channel somewhere, doesn't really know anything about irc in general
19:02:33 <zell> Damn, see they are immutable
19:02:53 <ReinH> zell: ?
19:03:06 <zell> I'm trying to extend it to n
19:03:08 <peddie> spider_: would you like to learn to write programs using Haskell?
19:03:16 <ReinH> What is "is"? What is "n"?
19:03:20 <zell> That's a base case and an inductive step right there
19:03:32 <ReinH> what is?
19:03:38 <zell> Monoid Alternative boom
19:03:38 <EvanR> what is is, is that like what is the type of :
19:03:42 <ReinH> What?
19:03:50 <ReinH> EvanR: I meant "what is 'it'?"
19:03:52 <EvanR> i mean, ::
19:04:00 <peddie> hey zell, I think it'd be easier for people to help you if you could post some code and show what you're trying to get working
19:04:24 <ReinH> So far I know that the problem involves "it", "n", "that", and also somehow Alternative.
19:04:36 <zell> Yeah I think that would help but it makes little sense one sec
19:04:40 <ReinH> But I don't know what "it" or "that" refer to.
19:04:43 <peddie> @where paste -- zell
19:04:43 <lambdabot> Haskell pastebin: http://lpaste.net/
19:04:45 <zell> No but wait I should use my words
19:04:54 <ReinH> Yes, you should.
19:05:12 <zell> If I can one line it it, but struggling
19:05:42 <peddie> ReinH: I think maybe this person wants a container that, if it contains something that's an instance of Monoid, is also an instance of Monoid?
19:05:57 <ReinH> I don't know, and I don't want to guess.
19:06:13 <zell> It's just (Monoid a, Monod (f a), Monoid (f (f a)))
19:06:23 <ReinH> What is?
19:06:31 <peddie> welp, you were right not to guess :)
19:06:48 <zell> The thing on the lhs of =>
19:07:04 <ReinH> Which =>?
19:07:06 <zell> The constraint, context or whatever
19:07:14 <ReinH> You keep referring to things you haven't actually stated
19:07:19 <ReinH> so we don't know what they are
19:07:31 <zell> Monoid is a constraint right?
19:07:33 <monochrom> OK, you can write the type (Monoid a, Monoid (f a), Monoid (f (f a))) => ...
19:07:52 <zell> It's Free?
19:07:54 <monochrom> No, but "Monoid a" is, and "Monoid (f a)" is, etc.
19:08:03 <ReinH> Is what?
19:08:19 <ReinH> You keep pronouns with ambiguous or unknown antecedents
19:08:25 <zell> This infinite nested Monoid constraint
19:08:26 <ReinH> We don't know what "it" is until you tell us what it is
19:08:27 <monochrom> I wouldn't get "Free" involved until I know why.
19:08:31 <monochrom> No.
19:08:41 <ReinH> What infinite nested Monoid constraint?
19:08:54 <ReinH> I am not trying to be difficult, I genuinely don't know what you're talking about.
19:09:05 <zell> Free for recursion Free for infinity
19:09:20 <ReinH> ...
19:09:31 <ReinH> Is that an answer to my question?
19:09:33 <Gues> How do I get ghci to show the interface for types such as Ord?
19:09:34 <monochrom> "Free" is not about recursion over constraints.
19:09:43 <zell> (monochrom) OK, you can write the type (Monoid a, Monoid (f a), Monoid (f (f a))) => ...
19:09:45 <zell> That
19:09:45 <Gues> type classes I mean
19:10:03 <peddie> Gues: :i Ord
19:10:18 <zell> But with the ... Inside the parenthesis
19:10:36 <Gues> peddie: I tried that, but I got a bunch of noise
19:10:40 <monochrom> No, my "..." means things like "a -> f (f a)"
19:10:44 <peddie> Gues: scroll up
19:11:01 <monochrom> For example (Monoid a, Monoid (f a), Monoid (f (f a))) => a -> f (f a)
19:11:09 <monochrom> You can write a type like that.
19:11:39 <Gues> peddie: Okay, I see it. So I guess that's the most concise output possible?
19:11:42 <monochrom> I wonder if some extension is needed, but it can be easily done.
19:11:49 <zell> Something =  (Monoid a, Monoid (f a), Monoid (f (f a)), ...) =>
19:11:51 <peddie> Gues: as far as I know, sorry . . .
19:12:03 <monochrom> OK, you cannot write an infinite list of constraints.
19:12:21 <peddie> zell: are you asking how to define instances of a type class recursively?
19:12:27 <monochrom> And I default to opining that you don't need it, until I am strongly convinced otherwise.
19:12:28 <zell> It's a constraint I'm sure
19:13:05 <monochrom> In fact, there may be a proof that you don't need it.
19:13:13 <zell> Yes that, and the way I thought of it which was defining constraints recursively
19:13:32 <monochrom> Or maybe not, I always underestimate the consequences of polymorphic recursion.
19:14:24 <zell> Otherwise I just right (Alternative a, Monoid m) => Free a m
19:14:29 <monochrom> Anyway, you know what? Until I see actual code (function bodies) that requires what you're asking, I rightfully assume that you're thinking XY problems ad infinitum.
19:14:51 <ReinH> ...
19:14:59 <ReinH> In what way is that free?
19:15:34 <monochrom> In other words, you're asking "how do I write such a type", without demonstrating that you can write a term that needs that type.
19:15:42 <zell> It has Free written right in it
19:15:50 <ReinH> ...
19:15:53 <peddie> lolol
19:16:02 <ReinH> Calling something free does not make it free.
19:16:26 <zell> But I get a nested type with the correct constraint
19:16:30 <monochrom> I could put it more bluntly and frankly if you want.
19:16:40 <zell> Nah
19:17:13 <ReinH> I don't know what it is, but there is no reason to believe it is a free object
19:17:34 <zell> How do I write a class of infinite parameters all treated the same way, ie demanding instances of functions defined on each of them
19:17:49 <zell> The same functions*
19:17:54 <ReinH> Is this a new question? 
19:17:57 <zell> No
19:18:07 <zell> It would use the missing object
19:18:12 <ReinH> What missing object?
19:18:16 <peddie> zell, you cannot define a type class with an infinite number of parameters
19:18:17 <monochrom> "instance of functions" is a wrong concept. there is only "instance of a class"
19:18:17 <zell> Free constraints
19:18:27 <ReinH> What are "free constraints"?
19:18:35 <Cale> dfeuer: Being selfish, I actually only care about Data.Map and not IntMap, I think it's fine to do a second release :)
19:18:36 <monochrom> there is no "class of infinite parameters" in Haskell. or I suspect any language at all.
19:18:51 <monochrom> I will put it bluntly and frankly. You are full of it.
19:18:57 <ReinH> I wonder if you're ever going to define any of your terms
19:19:03 <monochrom> You don't even have a term that needs the type you're asking for.
19:19:13 <zell> So that eg a, f a, f (f a) ... Are all Monoids (constrained to be)
19:19:26 <monochrom> Unscientific people would call you a dreamer and think you're their hero. They are wrong. Scientific people would call you bluff.
19:19:33 <dfeuer> Cale, hehe. Yeah. I'm going to ask Wren if she's okay with doing a release now. There's plenty of good stuff to justify it.
19:19:35 <monochrom> Show me a term that has your type.
19:20:22 <zell> (Alternative a, Monoid m) => Free a m
19:20:28 <ReinH> That is not a term
19:20:32 <zell> ...
19:20:40 <monochrom> Yeah, do you even know what is "term"?
19:20:55 <monochrom> "term" means expressions like 1+1 and (\x -> x * 2)
19:20:56 <zell> Datatype context synonym
19:20:58 <ReinH> Without any additional context, that is not even a valid haskell fragment.
19:21:10 <ReinH> Are you saying that a term is a "datatype context synonym"?
19:21:21 <monochrom> "term" means actual code.
19:21:24 <zell> Yes
19:21:46 <ReinH> Well, you are wrong. I don't know what a "datatype context synonym" is, but I am confident that a term is not it.
19:21:47 <monochrom> You are wrong.
19:22:04 <monochrom> But show me actual code anyway.
19:22:22 <ReinH> If you're going to make up your own meanings for words, you have to share them with us if you want us to understand you
19:22:53 <zell> data DCS a m where DCS :: (Alternative a, Monoid m) => a -> m -> Free a m
19:23:40 <monochrom> That is a syntax error. Even after {-# LANGUAGE GADTs #-}
19:23:55 <monochrom> You probably need to brush up on GADTs syntax.
19:23:57 <ReinH> And indeed not a term.
19:24:27 <monochrom> well, I would be happy to see a data constructor there and take it as a term.
19:24:33 <dfeuer> Cale, oh, there's one more thing ... I think I need to add take, drop, splitAt, takeWhileAntitone, dropWhileAntitone, and spanAntitone to Data.Set.
19:24:35 <monochrom> But it has to compile first.
19:25:00 <monochrom> At present it is not even a type error. It's a bloody syntax error. The code doesn't even pass that test.
19:25:16 <zell> (zell) data DCS a m where DCS :: (Alternative a, Monoid m, Free a m) => a -> m -> DCS a m
19:25:24 <zell> Lol sorry that's a joke
19:25:41 <monochrom> But "Free" is not a class.
19:25:52 <zell> You get it! Funny huh
19:26:23 <ReinH> ...
19:26:27 <zell> It's hard
19:26:33 <ReinH> At this point I am going to need convincing that you are not a troll.
19:27:08 <zell> I just want infinitely many constraints, they are defined in an easy way. What's up language?
19:27:26 <zell> I know I'm trying to do it wrong and that's why it doesn't work
19:27:27 <ania123> hi all
19:27:29 <dfeuer> How can I tell Travis to please never bother with CI when I change the changelog?
19:27:39 <zell> I was wondering if there it's a way to do it
19:27:41 <ReinH> You couldn't use infinitely many constraints even if you had them.
19:27:47 <zell> Lol
19:27:51 <dfeuer> (when I change *only* the changelog, that is)
19:28:02 <zell> Challenge accepted
19:28:02 <ania123> can one help me?
19:28:03 <ania123> http://pastebin.com/jVWh41VA
19:28:13 <ania123> I can not compile a tex document
19:28:14 <ReinH> zell: It's easy to prove me wrong: write a term that requires them.
19:28:42 <dfeuer> You should be able to make infinite constraints using a list-like existential thingy....
19:28:42 <monochrom> ReinH, I wonder if polymorphic recursion could use infinitely many constraints. But otherwise I also believe that no term can use infinitely many constraints.
19:29:04 <dfeuer> It can't *use* them all. But maybe it could use an unbounded number?
19:29:13 <ReinH> I'm not certain that it's impossible, but I'm certain that it won't happen in this case.
19:29:31 <monochrom> yeah
19:29:48 <zell> Hi ania, you need latex
19:29:56 <monochrom> basically "a term has finite length" and pretty much done
19:30:50 <zell> I would if i could use free
19:30:57 <zell> Oh yeah I can do this easily
19:31:00 <zell> Sorry
19:31:21 <zell> Inductive
19:31:41 <zell> The contents of free is a Monoid so free can be a Monoid
19:32:02 <zell> Because the contents of free is free
19:32:16 <ReinH> You keep using that word.
19:32:23 <ReinH> I do not think it means what you think it means.
19:32:35 <zell> Relying on the basecase monoid at Pure
19:33:19 <zell> Gosh
19:33:46 <MarLinn> Maybe infinitely nested constraints could be a feature of a turing complete type checker, so you would never have to decent onto the value level at all. Now all you need are side effects on the type level... I'm sure there are *loads* of RL applications! Possibly even one!
19:34:32 <ReinH> The GHC type-checker is already Turing complete.
19:34:33 <EvanR> turing complete type checkers is that way
19:35:00 <ReinH> (with proper extensions enabled)
19:35:00 <EvanR> ghc is turing complete, just not conveniently 
19:35:06 <zell> Certainly Free Monoids make everything badass
19:35:42 <zell> Sorry, Free Alternatives of Monoids
19:35:44 <monochrom> What does "side effect on the type level" mean?
19:35:45 <EvanR> -XTypeLevelLisp
19:36:05 <zell> In human syntax
19:36:21 <monochrom> This is what's wrong with the Internet. People feel so free to speculate, but spend no effort to substantiate.
19:36:28 <EvanR> human syntax sounds like a hipster band
19:36:40 <monochrom> This is why people are so full of junk.
19:36:57 <zell> (Alternative a, Monoid m) => Free a m
19:37:13 <zell> Best datatype ever
19:37:35 <zell> *datatype context synonym
19:37:58 <EvanR> Alternative Indie Gypsie Punk
19:38:06 <zell> (zell) data DCS a m where DCS :: (Alternative a, Monoid m) => a -> m -> Free a m
19:38:13 <zell> So close
19:38:33 <MarLinn> monochrom: Right now I'd classify the creation of dictionaries as a "side effect". My (sarcastic) idea was more about things like writing to a file when a type variable is unified
19:39:12 <EvanR> cant all dictionaries all created a priori since theres only so many
19:39:34 <zell> In human syntax it's a datatype context synonym of a free alternative Monoid
19:39:35 <jle`> you can create dictionary values at runtime though so there's that
19:39:38 <zell> One line!
19:40:07 <EvanR> thats enough 
19:40:10 <jle`> EvanR: as in, you can create typeclass instances at runtime
19:40:23 * EvanR hmms
19:40:25 <zell> :/
19:40:40 <jle`> so you can't really compile every typeclass dictionary statically, i don't think
19:41:11 <zell> Human compilers buggy
19:41:44 <EvanR> really, you can just do that?
19:42:05 <jle`> yeah, but i think it requires some extensions
19:42:27 <monochrom> it probably involves polymorphic recursion again
19:43:09 <EvanR> polyrecusive morphism
19:43:27 <EvanR> recursomorphic polythiesm
19:44:03 <jle`> i don't think it requires polymorphic polymorphism, but it at least requires a judicious unsafeCoerce i think
19:44:28 <EvanR> that sounds like hax
19:44:46 <monochrom> please don't use unsafeCoerce. it makes things too easy :)
19:44:52 <jle`> it's hax to implement, but when wrapped up in a nice library, it behaves well
19:45:04 <jle`> @hackage reflection
19:45:04 <lambdabot> http://hackage.haskell.org/package/reflection
19:45:06 <monochrom> OK that's probably not so bad
19:45:21 <jle`> the package behaves pretty well but the entire implementation is basically unsafeCoerce
19:45:25 <EvanR> i looked into it, but didnt think it was literally creating brand new custom instances
19:45:36 <monochrom> ah, like that.
19:45:48 <jle`> 'reflection' can be used to create instances at runtime, that's actually one of the neat usecases people always talk about it with
19:46:16 <jle`> but i suppose in that case, you might be able to precompile at least *something* relating to typeclass dictionaries.
19:47:01 <zell> Everyone needs recursive datatypes all the time
19:47:31 <zell> Get a Fix
19:47:54 <zell> He was on Astérix
19:48:03 <zell> He knew
19:50:14 <MarLinn> Ok, I got from that that my naive understanding of type level evaluations and dictionaries was wrong in yet more ways than I thought. Yay!
19:57:06 <zell> Oh so you know what else is good about free is something like data Free2 f g a = Pure a | Free1 (f(Free2 f g a)) | Free2 (g(Free2 f g a))
19:57:56 <shachaf> That's just Free (f :+: g)
19:58:00 <zell> Then you can alternate types nested inside each other arbitrarily
19:58:25 <Rudes> jfc, you guys are too smart for me
19:58:51 <zell> What is this strange looking (:+:) thing? Looks like off starwars
19:59:05 <Rudes> :t (:+:)
19:59:06 <lambdabot> error:
19:59:06 <lambdabot>     • Data constructor not in scope: :+:
19:59:06 <lambdabot>     • Perhaps you meant ‘:+’ (imported from Data.Complex)
19:59:13 <Rudes> bummer
19:59:21 <shachaf> A long time ago, in a category far far away...
19:59:39 <shachaf> data (f :+: g) a = L (f a) | R (g a)
19:59:58 <Rudes> GHC.Generics data (:+:) f g (p :: *)
20:00:35 <zell> It's Either for Kind *->* things by the looks of it
20:00:59 <zell> Or maybe, that is not makes sense
20:01:33 <zell> Does that make sense?
20:01:56 <zell> Is that what it is?
20:02:43 <Rudes> the evidence of abscence is not the abscence of evidence
20:02:43 <zell> Or is there a better way to call it?
20:03:37 <zell> Yeah I'm no white on white contemporary artist, say what you mean Rudes
20:04:34 <Cale> zell: Yes, that's pretty much what it is
20:04:54 <zell> Anyway that side you linked with generics just got ddos, so what are they?
20:05:44 <zell> I guess some of the trolls are grumpy, not me! I'm happy, I can almost speak Haskell
20:06:03 <Cale> Which site?
20:06:22 <zell> Nvm
20:06:45 <zell> I like it here because the hackers stand out
20:07:04 <zell> Until they learn Haskell, but it's hard, so...
20:08:23 <Rudes> zell: haskell is so cool but i'm new and it's HARD
20:08:54 <Cale> any questions?
20:08:58 <zell> Just don't come on here unless you have a Haskell problem and you will be fine
20:09:31 <zell> But please don't make us teach to chatbots
20:09:59 <Rudes> zell: oh i leave it open and ghost tons because i don't even know the questions to ask yet
20:10:44 <Rudes> Cale: kinda. can you help me figure out how to write tests for the bit in red? https://coveralls.io/builds/7669552/source?filename=.%2FNetwork%2FHTCPCP%2FPot.hs
20:10:50 <zell> It's too steep a learning curve, hit the web material, introductory Haskell stuff is abundant and written with love
20:11:06 <Rudes> zell: it really is, i'm not THAT new but i'm pretty new
20:11:34 <Cale> Rudes: What kind of tests?
20:12:10 <Rudes> hspec for a data type
20:12:17 <Cale> The functions being defined there are written by the compiler, so testing that they work would be more a test of GHC than your own code (and it would be a pretty needless test, GHC is pretty good at record selectors)
20:12:35 <Rudes> these are my tests https://coveralls.io/builds/7669552/source?filename=test%2FNetwork%2FHTCPCP%2FPotSpec.hs
20:13:44 <Cale> Those show tests are... of questionable value :)
20:13:47 <Rudes> i know it's pointless but i wanna get coverage, lol
20:13:47 <kap> I teach highschool CS, should I be recommending haskell as a language to pursue?
20:14:02 <zell> What are you trying to cook!?
20:14:47 <Rarrikins> kap: Recommend to whom?
20:14:49 <zell> yes recommend Haskell, learn and teach Haskell
20:15:14 <zell> Not recommended for hackers, to hard
20:15:29 <zell> High school students much smarter
20:16:53 <Cale> kap: I would generally recommend it to people who are interested in learning to program, so long as they're not pressed for time in getting a job (there exist Haskell jobs, but the competition for them is generally pretty solid)
20:17:16 <zell> Must be smarter than the average bear (that's a joke because the hackers constantly short crypto markets with stolen virtual currencies)
20:17:31 <Cale> I... I don't understand these comments about hackers
20:17:50 <zell> Have fun teaching them
20:17:55 <kap> I run a TSA chapter for tech competitions, any recommended self guided learning systems?
20:18:34 <Rarrikins> Cale: I think zell is a troll: < zell> I guess some of the trolls are grumpy, not me! I'm happy, I can almost speak Haskell
20:18:37 <Cale> kap: It's not perfect, but there are some pretty decent course materials here http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
20:18:57 * hackagebot language-c-quote 0.11.6.3 - C/CUDA/OpenCL/Objective-C quasiquoting library.  https://hackage.haskell.org/package/language-c-quote-0.11.6.3 (GeoffreyMainland)
20:19:12 <Welkin> programming isn't about languages
20:19:28 <Welkin> any competent programmer can use any language
20:19:30 <zell> Rarrikins, I'm referring to some troll hackers.
20:19:34 <Rarrikins> zell: Ahh.
20:19:49 <zell> So quick, type some Haskell
20:20:00 <kap> Thanks for the links! My higher level students really suck this stuff up... GUI dev possible with haskell?
20:20:03 <Cale> Welkin: I'm not sure I agree
20:20:15 <Welkin> kap: yes, but it's not great
20:20:30 <Cale> I think it's pretty great -- well, depends on what kind of GUI dev you're talking about
20:20:35 <Welkin> kap: web development is a strong point for haskell, as well as compilers and DSLs
20:20:37 <ReinH> kap: web front-ends are currently more popular than GUIs, especially with ghcjs.
20:20:55 <Cale> If you use reflex-dom to develop your web front-ends you get desktop guis for free :)
20:21:01 <ReinH> Yep
20:21:04 <Cale> (well, typically)
20:21:18 <ReinH> I mean, for the price of using reflex-dom to develop a web front-end.
20:21:36 <zell> > mapM_ putStrLn ["not","a","hacker","troll"]
20:21:38 <lambdabot>  <IO ()>
20:21:39 <Cale> I would seriously consider using reflex-dom to provide the GUI for a desktop application as well.
20:21:59 <ReinH> Cale: Electron or other things can probably make that easy
20:22:07 <kap> welkin: I always reiterate that programming principles should be expected from every language
20:22:08 <glguy> is reflex-dom approachable to new learners of Haskell (I don't actually know the answer)
20:22:10 <ReinH> iirc someone was using haste or ghcjs with electron
20:22:15 <ReinH> glguy: No.
20:22:23 <Welkin> glguy: seems too much at this point
20:22:30 <Cale> ReinH: You don't need electron, you just compile the same program with ghc rather than ghcjs
20:22:31 <ReinH> I mean maybe, but it wasn't very approachable to me, and I am a less new learner of Haskell.
20:22:38 <Welkin> I would reccomend Elm over ghcjs/reflex-dom
20:22:39 <Cale> and you get a desktop application rather than a web page
20:22:40 <Welkin> for the simplicity
20:22:46 <ReinH> Cale: oh right
20:23:12 <Welkin> what's with electron though?
20:23:15 <Cale> ReinH: Not only that, but the contents of the DOM are controlled by native code
20:23:17 <Welkin> seems like a huge waste
20:23:24 <Cale> There's no interpretation of HTML or anything going on
20:23:30 <ReinH> Cale: huh
20:23:33 <Welkin> run an entire web browser just to render your gui?
20:24:13 <ReinH> Leverage your team's knowledge of html, css, and js to build desktop applications.
20:24:16 <Cale> (reflex-dom just interacts with a gtk-webkit browser widget directly
20:24:17 <Cale> )
20:24:19 <geekosaur> these days? everyone's running a browser anyway
20:24:24 <systemfault> Portable.. works well...
20:24:25 <kap> anyone know of a hexchat equiv for console/terminal?
20:24:34 <Rarrikins> kap: irssi
20:24:35 <systemfault> kap: weechat?
20:24:38 <Welkin> kap: bitchx :)
20:24:39 <Welkin> lol
20:24:46 <systemfault> Welkin: Welcome to the 90s
20:24:47 <Welkin> kap: irssi works
20:25:02 <Welkin> erc (emacs) too
20:25:16 <kap> i am using irssi but lists for servers is lame
20:25:24 <systemfault> Running a complete OS (emacs) to run a IRC client is a bit too much :P
20:25:36 <Welkin> systemfault: emacs isn't an os
20:25:45 <systemfault> Liar! :)
20:25:53 <kap> love the sort ability in hex
20:26:05 <Rarrikins> kap: What does the sort ability do?
20:26:16 <Welkin> you can extend irssi however you want
20:26:22 <kap> welkin: bichx? is it good?
20:26:26 <Welkin> same with erc and weechat (I believe)
20:26:32 <Welkin> lol,bitchx is old
20:26:33 <Welkin> not sure
20:26:37 <Welkin> I never used it
20:26:38 <glguy> glirc
20:27:13 <kap> Rarrikins: the ability to sort count of users
20:27:24 <systemfault> kap: bitchx is more a joke than anything else these days
20:27:38 <glguy> ?hackage glirc
20:27:39 <lambdabot> http://hackage.haskell.org/package/glirc
20:27:45 <systemfault> kap: The only two clients worth considering (IMHO) are irssi and weechat
20:27:55 <Welkin> http://bitchx.sourceforge.net/
20:27:56 <Welkin> lol
20:28:07 <kap> is haskell considered "interpreted" language?
20:28:10 <Welkin> systemfault: erc too
20:28:14 <systemfault> It's on sourceforge 'nuf said :)
20:28:14 <boj> wow, i think the last time i used bitchx was over a decade ago
20:28:15 <Welkin> ERC is very good
20:28:21 <Rudes> i'm on irssi, i've been using it for a couple years, always happy
20:28:31 * Welkin is on irssi right now
20:28:35 <Rudes> i throw it on my server with tmux and i can leave and join as needed
20:28:43 <systemfault> Welkin: erc is a awesome alternative if you use emacs... if not, it's meh
20:29:06 <Welkin> kap: haskell has type inference through it's advanced type system
20:29:14 <systemfault> I was using bitchx on slackware  20 years ago :/
20:29:17 <glguy> glirc is actually a rather complete client and offers features missing in irssi or weechat ( and similarly is missing some things they can do)
20:29:21 <Welkin> but it is statically typed (types decided at compile time)
20:29:44 <EvanR> kap: compiled vs interpreted is kind of a red herring talking point, like "strong typing" and "weak typing"
20:30:03 <EvanR> theres not that much to gain from establishing "the fact" one way or another
20:30:11 <kap> EvanR: got it!
20:30:17 <Cale> kap: The standard Haskell compiler comes with an interpreter as well.
20:30:21 <ReinH> Haskell is usually compiled, but it can also be interpreted.
20:30:26 <Rarrikins> kap: It can be either. GHC compiles to fairly fast code. `runghc` interprets. `ghci` is a REPL.
20:30:59 <Welkin> an interpreter and a compiler are almost the same thing
20:30:59 <EvanR> either everything is interpreted, or everything can be either
20:31:07 <zell> Emacs is on the play store, do you think it could handle Haskell, i don't know how it does cabal...
20:31:14 <Cale> kap: and GHCJS compiles Haskell to Javascript which will then be interpreted (and JIT compiled) by your web browser
20:31:51 <ReinH> Lots of people develop haskell using emacs.
20:31:54 <kap> Cale: really? that is fantastic!
20:32:19 <kap> How about abstract classes?
20:32:23 <zell> But on on os!?
20:32:24 <ReinH> No classes at lal.
20:32:25 <ReinH> all.
20:32:32 <kap> ok
20:32:36 <ReinH> It is not an object oriented language.
20:32:48 <kap> all functions
20:32:53 <zell> It depends on the existence of a compiler on the parent os?
20:32:55 <Cale> kap: Haskell has something called classes, but they are not the same thing as OO classes (though they bear some resemblance to Java's interfaces)
20:33:26 <Cale> However, I think you can *do* OOP in Haskell just fine.
20:33:27 <Rudes> Cale: are classes the things like deriving (Show,Eq)
20:33:37 <Rudes> as in is Show a class
20:33:37 <Cale> Show and Eq are examples of classes, yes
20:33:40 <Rudes> cool
20:34:05 <Rudes> Cale: idk if you can really call it OOP in a stateless language
20:34:12 <Cale> and the deriving thing is just a feature provided for certain classes that lets the compiler write the instance for you
20:34:25 <Cale> You can do stateful stuff in Haskell
20:34:45 <zell> How would it know the device architecture? I presume if it's on the play store emacs runs on arm but I can't find a stable Haskell compiler for arm
20:34:46 <Rudes> Cale: yeah, i've written straight instances before, i like that you can control it but also infer it.
20:35:02 <Rarrikins> zell: I don't think GHC is on Android. Your best bet is probably SSHing to a machine with emacs and GHC installed.
20:35:28 <zell> It would be great if i could write apps for the play store
20:35:43 <zell> In Haskell
20:36:24 <zell> I can cross compile to arm and run an emulator of Linux on arm
20:36:29 <Cale> zell: I think our approach to that is just going to be packaging up GHCJS compiled code in some container for Android.
20:37:08 <systemfault> Perhaps Frege would work for Android? (No clue)
20:37:13 <zell> I have run ghci on a Linux kernel obtained from the play store which uses proot
20:37:24 <Rarrikins> zell: Be careful with that, since some Androids are x86, I think.
20:37:36 <zell> On arm on my phone on Android without rooting my phone
20:37:48 <Rarrikins> zell: Oh, and MIPS.
20:38:01 <zell> What's that stand for?
20:38:15 <Rarrikins> zell: Processor architecture.
20:38:19 <Welkin> MIPS was developed at stanford
20:38:24 <zell> Ok
20:38:28 <Cale> But yeah, I seem to recall people getting some basic GHC-compiled things running on Android phones using cross compilation.
20:38:37 <Welkin> the ps1, ps2, psp, and other game consoles used it
20:38:45 <Welkin> it is very popular in china right now
20:38:52 <Cale> I would expect that to require some heroic effort at the moment
20:38:53 <zell> So cool
20:39:06 <zell> Hmm
20:39:12 <Rarrikins> There's some scripts or something on https://github.com/neurocyte/ghc-android
20:39:12 <Cale> and we did iOS stuff in the past
20:39:18 <zell> I can compile Haskell to java libraries
20:39:35 <zell> And include those in apps
20:39:45 <Clint> there's some git-annex android stuff
20:39:49 <Welkin> what...?
20:39:59 <Cale> There was someone who recently told me they were going to work on a Java backend for GHC... who was that...
20:40:00 <zell> But what I can't do it's compile to whatever it is Android apps are
20:40:11 <MarLinn> Android can run c and ghc can compile to c, afaik. All you need is a small Java wrapper
20:40:11 <zell> And then sell them on the play store
20:40:15 <Welkin> Cale: were they high?
20:40:26 <systemfault> Frege is the closest thing to a Haskell -> Java compiler...
20:40:27 <Welkin> or just feeling suicidal?
20:40:33 <boj> Cale: isn't that what frege is?
20:40:47 <systemfault> But I have no clue if Frege works for Android..
20:40:47 <peddie> https://github.com/rahulmutt/ghcvm
20:40:57 <systemfault> peddie: Ah cool
20:41:29 <Cale> boj: Frege is its own programming language
20:41:41 <Cale> It's merely Haskell-like
20:41:49 <boj> ah, ok. i've only heard of it in passing
20:42:01 <Welkin> like purescript?
20:42:09 <zell> If you could run OpenGL which has all the right drivers you could make a nice fullscreen activity
20:42:29 * dfeuer should probably learn purescript at some point.
20:42:38 <Welkin> dfranke: why?
20:42:39 <Welkin> er
20:42:44 <Welkin> dfeuer: ^
20:42:59 <Welkin> you already have Elm and ghcjs
20:43:49 <dfeuer> Welkin, just to expand my knowledge and such. It apparently has some cool type stuff to help deal with the JS world without going crazy. Elm doesn't seem so interesting; ghcjs is amazing, but it's just Haskell.
20:44:05 <dfeuer> (i.e., I already know what it's about, pretty much)
20:44:05 <MarLinn> I tried to try purescript once. Then nodejs failed to install. I think I got lucky...
20:44:15 <zell> So I see the task as calling opengl in a Haskell program compiled as a java or c library and then compiled to Android. Cabal needs to somehow run to install the Haskell OpenGL bindings, which seems hard
20:44:23 <Cale> ghcjs is amazing, *because* it's just Haskell :)
20:44:58 <dfeuer> Cale, oh, absolutely! But if I learned purescript, I'd be learning a new and different language...
20:45:07 <Cale> yeah
20:45:23 <Cale> zell: I would tend to assume that if you were targeting Android or iOS, you would not be running the compiler on the actual phone or whatever.
20:45:24 <Welkin> purescript is too similar to haskell, but then different in weird ways that make it annoying
20:45:46 <Cale> zell: Maybe you *could* get away with that today, phones are getting pretty insane. But still, you probably wouldn't want to.
20:45:57 <dfeuer> Cale, I've sent Wren a message; I hope she gets back to me soon. If so, the release could come within a couple days.
20:46:03 <Cale> Nice!
20:46:08 <schell> is there any way to tie a monadic dealloc function to a value, so that when the value is garbage collected the dealloc is run?  
20:46:13 <zell> If I could release on the play store a program which compiled Haskell to apps I would have succeeded
20:46:14 <dfeuer> You should check over the changelog to be sure I haven't missed anything important to y,ou.
20:46:30 <Welkin> schell: lol, you mean like the __gc meta-method in lua? :P
20:46:36 <Cale> https://github.com/rahulmutt/ghcvm
20:46:43 <Welkin> that's a good question actually
20:46:50 <Welkin> I wonder if the ffi supports anything like that
20:46:59 <schell> Welkin: i’m not sure, though i thought i had read something about that in the FFI
20:47:03 <dfeuer> schell, well, there are weak references, but they're kind of *weird*.
20:47:22 <Cale> ^^ re: JVM backend support for GHC
20:47:32 <dfeuer> Oh...
20:47:33 <Welkin> dfeuer: who is Wren?
20:47:46 <dfeuer> Welkin, Wren Romano, the other co-maintainer of containers.
20:47:50 <zell> Woah awesome stuff Cale, I wish i knew what it meant to target the java virtual machine
20:48:34 <dfeuer> o.O
20:48:35 <Welkin> zell: bytecode that gets interpreted by the vm
20:48:47 <schell> dfeuer, Welkin: maybe there’s another way i’m not thinking of - my problem is that i have a function like “allocThing :: IO Thing” and i’d like to use Thing for a bit and then call “deallocThing :: Thing -> IO ()” and then be sure i’m not able to use the Thing again later
20:49:06 <zell> Yeah bit where is it? I guess that's what targeting it means
20:49:13 <dfeuer> schell, is this in normal Haskell or some GHCJS thing?
20:49:14 <zell> But*
20:49:24 <schell> dfeuer: normal haskell :)
20:49:42 <Cale> zell: It means that the Haskell compiler is producing bytecode which the Java virtual machine can understand and execute.
20:50:13 <zell> So then I need a program which ruins a jvm to receive and execute code
20:50:15 <dfeuer> schell, well ...... you definitely *can* do that sort of thing with the FFI, but it's kind of horrifying.
20:50:29 <dfeuer> Why do you want to/
20:50:29 <dfeuer> ?
20:51:02 <Welkin> dfeuer: he mentioned above that he wants the garbage collector to dealloc for him
20:51:03 <MarLinn> zell, please don't ruin the jvm... Java does that already.
20:51:09 <Rarrikins> Are there any systems-level programming languages with type systems similar to Haskell? Habit seems to have dropped off the face of the Earth?
20:51:09 <zell> Can I produce a jvm using Haskell?
20:51:09 <dfeuer> I mean, you'd be trading a possible memory leak for an unpredictable crash.
20:51:42 <MarLinn> zell: Yes. Haskell is a great language to write other languages, including java
20:51:51 <boj> Rarrikins: idris possibly
20:51:53 <Cale> zell: You could, but I don't really know what the point would be
20:51:59 <schell> dfeuer: i’ve got some GPU resources for rendering bundled up with some other state and i’m afraid that i’ll alloc a Thing, pass it around, call dealloc and then other references will try to render with it 
20:52:00 <dfeuer> Haaaahahahahaahaha.
20:52:02 <dfeuer> Idris no.
20:52:09 <dfeuer> I mean, maybe next decade.
20:52:13 <Welkin> use Coq
20:52:13 <zell> To then receive and execute Haskell code
20:52:29 <Cale> Idris is a systems-level programming language in the same respect that Haskell is.
20:52:31 <dfeuer> you'd have better luck in Coq than in Idris, today, I imagine.
20:52:35 <boj> dfeuer: right, is there a better answer to that question?
20:52:45 <boj> coq, ok
20:52:46 <dfeuer> boj, I dunno.
20:52:47 <Welkin> lol
20:52:53 <Welkin> it was a joke
20:52:54 <zell> Seems like basic stuff
20:52:56 <dfeuer> Yup.
20:53:01 <Cale> Rarrikins: Use Haskell, but stick to lower-level features? :)
20:53:01 <Welkin> there are not really any systems-level languages like haskell
20:53:14 <Welkin> you can use a haskell DSL to write emmbedded C though
20:53:15 <Welkin> for example
20:53:20 <Rarrikins> Cale: That may be my only choice :)
20:53:21 <Cale> Rarrikins: The FFI stuff can give you explicit control of memory and such
20:53:31 <Welkin> I have heard people using/liking rust
20:53:39 <dfeuer> C is also a lousy system programming language.
20:53:54 <peddie> Rarrikins: OCaml?
20:54:06 <Welkin> peddie: no...
20:54:34 <peddie> Welkin: feel free to elaborate
20:54:49 <Welkin> peddie: ocaml is at the same level as haskell
20:54:52 <Welkin> but a worse language
20:54:53 <Welkin> lol
20:55:10 <Rarrikins> Cale: Thanks, I'll check that out.
20:55:13 <Cale> There's also as Welkin points out, the approach of generating code in another language. Some people have taken that approach to programming embedded systems: write a Haskell program which serves as a one-shot compiler and emits a program in C or assembly
20:55:15 <peddie> Welkin: maybe we disagree on what "systems-level" means
20:55:32 <zell> The worst thing about (!!) bugs is that you can normally fix them without needing to safely handle the exception, so I never bother getting in the habit of doing so
20:56:13 <Welkin> peddie: macro assembly
20:56:22 <peddie> Welkin: also this person said that using haskell but using lower-level features was an option
20:56:23 <dfeuer> zell, why are you using (!!)?
20:56:25 <Cale> zell: You should never attempt to handle an exception thrown by expression evaluation (rather than execution of an IO action)
20:56:36 <Gues> I like C because I never run into roadblocks where I would have to write library bindings or contribute to compiler development.
20:56:54 <Cale> Well, when I say "never", I mean it should be a last resort.
20:57:53 <Cale> Gues: You just run into roadblocks in every other aspect of everything ;)
20:58:03 <dfeuer> Throwing exceptions from pure code is a bad habit. You may convince yourself that the exception will really happen when you think it will, but often you will be wrong.
20:58:20 <Gues> Cale: Like what?
20:58:23 <zell> Haskell on Android. It's funky linux right? Why all this jvm?
20:58:51 <zell> Oh because the compiler to Android apps likes java
20:58:51 <systemfault> Because Android's language is Java
20:58:55 <Rarrikins> zell: It's the Linux kernel, but not really Linux.
20:58:56 <Gues> Also, abstraction is premature optimization most of the time IMO.
20:58:57 <zell> Boom
20:59:34 <zell> It's not on hackage yet
20:59:43 <boj> Gues: so Haskell programmers are the worst premature optimizers? :)
20:59:44 <dfeuer> Basically, if you're throwing exceptions from pure code and trying to catch them, you're programming a graph reduction machine rather than writing normal Haskell.
21:00:20 <schell> dfeuer, Welkin: maybe i’ll try something like http://www.haskellforall.com/2013/06/the-resource-applicative.html - it’s not the feeling i want but it may work well enough
21:00:21 <Cale> Gues: Buffer overflow, indecomposability of problems into parts that can be solved by existing libraries because of mismatch between memory or mutation conventions, lack of much help from the compiler finding your bugs, ...
21:00:21 <nshepperd> schell: if you have a C object and a C deallocation function, you can use Foreign.ForeignPtr which lets you wrap the Ptr into a ForeignPtr with finalizer attached
21:00:30 <Gues> boj: Maybe? In my experience, I spent a lot of time in Haskell trying to do things the Right Way.
21:00:51 <nshepperd> schell: when the ForeignPtr is garbage collected the deallocation function will be called
21:00:52 <zell> Polymorphism is awesome
21:00:57 <Gues> It can be a time sink trying to write beautiful code.
21:01:09 <zell> Everything is map and fold
21:01:16 <dfeuer> ?
21:01:17 <zell> And free zippers
21:01:17 <Cale> Gues: Lack of polymorphism, resulting in being unable to reuse code effectively.
21:01:26 <dfeuer> zell, you drunk or something?
21:01:52 <zell> Re Gues's conversation
21:02:00 <Welkin> zell is drunk on science
21:02:06 <Welkin> and shrooms
21:02:09 <schell> nshepperd: that’s a thought - though i’m working with GPU resources, not strictly FFI
21:02:10 <Gues> Writime generic code for hypothetical reuse is also premature optimization IMO
21:02:28 <Gues> In Haskell it's pretty low-effort though
21:02:32 <Cale> Gues: Well, sure, but spotting a pattern and being unable to abstract over it is unacceptable.
21:02:34 <Gues> I don't do it in C though!
21:02:38 <Welkin> boj: no, that is java programmers and their shitty inheritance heirarchies and UML diagrams (da fuck?)
21:02:40 <ReinH> Writing unnecessarily specific code is premature optimization
21:03:05 <Gues> Ahhhhhhhhh
21:03:12 <ReinH> There are concrete advantages to writing more generic code.
21:03:15 <Gues> My IRC client sucks
21:03:18 <Cale> You can write perfectly down to earth code in Haskell, and I would recommend it even. You don't have to start off every project by defining a dozen type classes :)
21:03:36 <Welkin> nshepperd: that is good to know
21:03:48 <ReinH> The more generic the code is, the more likely it is to be correct.
21:03:52 <boj> Welkin: but my FactoryFactoryBuilderFactory is brilliant!
21:04:07 <Cale> But once you understand the structure of what you're trying to do better, and you find that you want to make it reusable so that you can transplant it into similar but distinct situations, having stuff like parametric polymorphism and type classes is really important.
21:04:51 <Cale> My general razor for whether I consider a language to not be a waste of my time (to program in directly) is whether it can handle typechecking "map"
21:05:19 <Welkin> I was wondering the same thing after using the lua c api
21:05:20 <zell> Prelude exports this dozen type classes
21:05:20 <zell> But you just need Monoid it turns out
21:05:20 <dfeuer> If you're using Data.Constraint.Forall, you'll probably have to define some classes.
21:05:20 <Gues> Does GHC compile to ARM easily yet?
21:05:20 <glguy> I use GHC 8 on my Raspberry PI
21:05:20 <zell> Since 5 mins ago?
21:05:29 <zell> It works for sure, just run Linux on it
21:05:41 <zell> The problem is with the play store
21:05:43 <Cale> If you can't write a function which will apply some other arbitrary function to a list of values and collect the list of results, then the language will probably waste your time in so many ways that it won't be worth programming in.
21:06:01 <Welkin> Cale: so basically, first class functions
21:06:02 <ReinH> And by this test, golang is immediately excluded.
21:06:08 <Cale> Welkin: and polymorphism!
21:06:18 <ReinH> which is fine with me
21:06:24 <zell> And you can actually get Linux which runs Haskell on the play store
21:06:28 <dfeuer> Higher-rank polymorphism and GADTs.
21:06:33 <zell> But it might have broke
21:06:52 <zell> Yeah it broke. GnuRootDebian
21:07:01 <Welkin> Cale: and TCO
21:07:02 <Welkin> !!
21:07:11 <zell> On play store, ran Haskell on arm on my phone
21:07:11 <dfeuer> If a language doesn't offer higher-rank polymorphism, then it will eventually bite.
21:07:23 <Cale> Welkin: Haskell doesn't have TCO ;)
21:07:25 <dfeuer> Ah, but more importantly!
21:07:32 <dfeuer> Polymorphic recursion.
21:07:37 <zell> Before it broke
21:07:47 <Welkin> Cale: how is that?
21:07:55 <dfeuer> Welkin, doesn't need it.
21:07:59 <Cale> Welkin: Because it doesn't have a call stakc
21:08:01 <Cale> stack*
21:08:05 <Gues> Are there debuggers for Haskell?
21:08:07 <boj> Welkin: haskell has laziness
21:08:10 <Welkin> yes, of course, but that is a technicality
21:08:11 <dfeuer> Well, it sort of has a call stack...
21:08:34 <Welkin> Gues: yes
21:08:37 <Cale> At least, a sensible implementation of Haskell won't have a call stack -- there's a stack which GHC uses, but it's weird to think of it as a call stack
21:08:38 <Welkin> you can use gdb as well
21:08:44 <Welkin> ghci has a debugger built in
21:08:52 <Gues> Oh?
21:08:55 <dfeuer> Cale, why is it weird to think of it as a call stack?
21:08:55 <Cale> It's more like a stack of pattern matches waiting to happen
21:08:56 <nshepperd> you can also attach haskell (IO ()) finalizers to MVars, but I found those were unreliable..
21:09:12 <Cale> It's an evaluation stack
21:09:18 <dfeuer> Sure.
21:09:33 <kadoban> The important part of TCO is to be able to do something like ... describe an iterative process using a recursive definition, which haskell has, so it's all good.
21:09:48 <kadoban> You want recursive functions to ... not be totally useless when used for anything complicated.
21:09:51 <Cale> Because evaluation is outermost first, you don't need to record where you're going next after you apply a function.
21:09:54 <Welkin> https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/ghci-debugger.html
21:10:01 <Gues> Does Haskell have something like POSIX select?
21:10:05 <zell> The trick seems to be writing a java app to emulate an os which runs Haskell. I was wondering if androids emacs which I can see on the play store can handle opengl and so compile and execute full screen activity
21:10:25 <Cale> Gues: The GHC runtime system will use select, epoll, or kqueue as necessary
21:10:27 <dfeuer> Gues, well, you *can* just use POSIX select, but usually you just use threads.
21:10:34 <Cale> (and as availability dictates)
21:10:34 <Gues> How do you block on multiple handlers?
21:10:36 <geekosaur> Gues, Haskell does it the way a number of other languages do; the select is in the runtime, you spawn lightweight threads
21:10:40 <geekosaur> and they are lightweight
21:10:43 <Cale> Typically you just use concurrency
21:10:49 <Cale> Threads are super cheap
21:10:52 <Gues> Oh, you are forced to use concurrency
21:10:54 <Cale> Just a handful of bytes
21:10:54 <Gues> Okay
21:11:00 <ReinH> lightweight threads are lightweight
21:11:01 <Cale> and concurrency is nice in Haskell
21:11:06 <zell> But I don't use emacs I was wondering if it seems reasonable. Does emacs have cabal?
21:11:20 <ReinH> emacs is not an operating system
21:11:20 <Welkin> zell: what does that mean?
21:11:30 <Welkin> haha
21:11:35 <Welkin> emacs is a text editor
21:11:35 <boj> is zell a bot and we've been fooled this whole time?
21:11:35 <Cale> You can build whatever abstractions around that you want -- there's an async library which you can use to spawn asynchronous computations and then later wait for their results to be available
21:11:48 <dfeuer> ReinH, emacs definitely is an operating system.
21:11:53 <zell> Whoever said emacs was an os earlier just killed my life
21:12:09 <Welkin> zell: it's a common joke to call emacs an OS
21:12:11 <ReinH> dfeuer: I know the joke, but if someone is expecting emacs to compile haskell for them then perhaps the joke isn't really appropriate.
21:12:23 <zell> Not funny
21:12:26 <Welkin> because it has a web browser, irc client, email client, and even games
21:12:26 <Gues> I was thinking of doing some prototyping in Haskell, but I'l probably still port to C for performance
21:12:38 <MarLinn> I don't think zell's a bot. Just a very very clueless kid
21:13:25 <Cale> MarLinn: manners :)
21:14:32 <Cale> Gues: But yeah, GHC makes it look as if most IO operations are blocking, but they're implemented internally with non-blocking OS-level stuff
21:16:03 <Cale> (in order to let the thread manager handle things)
21:17:22 <boj> hmm, indeed
21:17:22 <boj> i was kind of hoping he was, then praise the author :D
21:17:22 <kadoban> Gues: You can always do the standard and use the FFI to do any parts you need to in C, and the main logic in haskell if that works out for you.
21:17:22 <zell> Bots arise!
21:17:22 <Gues> Nah
21:17:22 <Cale> Gues: http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf -- the new(ish) thread manager gets some pretty good numbers :)
21:17:23 <zell> They refuse to arise
21:17:23 <MarLinn> @yow
21:17:23 <ReinH> Bots are le tired.
21:17:23 <dfeuer> I've never had much luck translating code from Haskell to C. It's just too frustrating and verbose.
21:17:23 <EvanR> emacs is currently a puzzble for me
21:17:23 <ReinH> dfeuer: yeah writing your own GHC RTS is a bit of a pain
21:17:23 <EvanR> puzzle
21:17:23 <ReinH> EvanR: no it's a text editor
21:17:23 <Welkin> it has puzzles
21:17:23 <EvanR> hidden inside a puzzle
21:17:23 <zell> Emacs is a useless operating system
21:17:23 <Welkin> like tetris
21:17:23 <Gues> Also, not as many people know/can read Haskell
21:17:23 <ReinH> EvanR: wrapped in an enigma?
21:17:23 <Welkin> you can run emacs inside of emacs
21:17:23 <Gues> It's like writing a book in Swedish vs. English
21:17:23 <Welkin> I did it before
21:17:23 <Gues> C is like English
21:17:23 <lambdabot> JAPAN is a WONDERFUL planet -- I wonder if we'll ever reach their level
21:17:23 <lambdabot> of COMPARATIVE SHOPPING ...
21:17:23 <EvanR> haskell is also like english
21:17:23 <Welkin> programming languages are nothing like human languages
21:17:23 <Gues> Not in the sense that a lot of people speak it
21:17:23 <zell> Unless you write your function names in polish
21:17:23 <Gues> Way less people know Haskell than C
21:17:23 <EvanR> Kvikkalkul is like swedish
21:17:23 <balac> @pl ( \x -> x > 0 && x <= bSize )
21:17:23 <Welkin> popularity means nothing
21:17:23 <Welkin> it is often a negative sign when it does mean something
21:17:24 <Gues> It means more people can read and modify your code, right?
21:17:24 <Welkin> donald trump is popular
21:17:27 <lambdabot> liftM2 (&&) (> 0) (<= bSize)
21:17:28 <Cale> whoa such lag
21:17:46 <ReinH> what
21:17:51 <zell> If you use free you can pass errors through the type checker
21:17:59 <Welkin> lambdabot is a weeaboo
21:18:07 <ReinH> This like a weird free association game.
21:18:13 <Cale> Gues: I think that has as much to do with familiarity as anything else
21:18:27 <Cale> Gues: The people who I started out on Haskell didn't seem to have so many troubles
21:18:33 <boj> i didn't realize i was on a different planet, wow
21:18:33 <EvanR> freely generated game
21:18:51 <lpaste> xuxu pasted “declaration vs expression style” at http://lpaste.net/181733
21:19:10 <ReinH> I've given up on trying to understand these utterances, bot or troll or neither.
21:19:19 <Gues> I would fully embrace Haskell if GHC consistently produced faster programs than C compilers, every major library had bindings, and it compiled effortlessly for Android, iOS, Linux, Windows, and Mac OS.
21:19:33 <Cale> Gues: It's just that if you're an imperative programmer, you get really used to being able to pick up another imperative programming language quickly, and Haskell is fundamentally different in some ways (though it does actually do a pretty good job of imperative programming when you really want that, it's not the usual convention)
21:19:42 <Welkin> Gues: no language has that...
21:19:51 <Gues> Yeah, C
21:19:54 <Welkin> no
21:19:59 <EvanR> C is not consistently faster than C
21:20:05 <Cale> Not every major library has C bindings
21:20:08 <Gues> Wow, you got me
21:20:13 <ReinH> Down with unrealistic language standards.
21:20:26 <EvanR> or unphysical
21:20:33 <Gues> The libraries I have wanted to use are written in C
21:20:35 <dfeuer> Cale, unless you want mutable variables. Then the optimizer spits on you.
21:20:41 <Gues> curl, openssl, ffmpeg...
21:20:43 <ReinH> Great, go write C.
21:20:46 <Cale> In fact, nearly all of my favourite libraries do not have C bindings
21:20:49 <Welkin> can it wash your cat and wax your lawn?
21:21:10 <EvanR> json in C is a fun time
21:21:10 <kadoban> Gues: Even a lot of that doesn't fit C. You don't write general Android programs in C, for instance. The NDK is only for some thing. I would strongly assume it's similar on iOS.
21:21:19 <dfeuer> @remember Welkin can it wash your cat and wax your lawn?
21:21:19 <lambdabot> Done.
21:21:45 <dmj> Gues: but green threads tho
21:21:56 <zell> ReinH it's nice to have tech savvy friends working to keep the world safe and everything but they kind of bomb around ircs spamming academics they hack journals off
21:21:57 <EvanR> iOS = objC which is kind of like C
21:22:06 <EvanR> rather than java
21:22:10 <kadoban> EvanR: Isn't it almost nothing like C?
21:22:11 <Gues> You can write a pure C program for iOS
21:22:16 <ReinH> zell: I still have no idea what you are talking about.
21:22:19 <EvanR> you can write C directly in it
21:22:19 <Gues> I saw a SO post of it
21:22:28 <boj> ReinH: you are not alone
21:22:29 <EvanR> thats when the obj doesnt really work out
21:22:33 <xuxu> re: http://lpaste.net/181733 i'm having a difficult time determining why the let is used in an expression style and the where is used in a declaration style. anyone willing to help? :)
21:22:33 <Gues> You have to kind of know the Objective C runtime though
21:22:43 <Cale> Gues: Personally, I really like the fact that I can be employed as a full stack web developer and not have to write any javascript ever.
21:22:47 <Gues> Realistically you would just use a small bit of Objective C
21:22:52 <xuxu> i don't understand why one is declarative and the other expression
21:22:55 <Welkin> objc is c where strings wear silly hats
21:22:55 <zell> I have yet to see Gues or boj write Haskell
21:23:01 <xuxu> i don't understand why one is declarative and the other is a declarative expression
21:23:04 <Cale> (or HTML, for that matter)
21:23:08 <EvanR> and you can freely use char[] if you wish
21:23:14 <xuxu> i don't understand why one is expression and the other is a declarative expression. 
21:23:18 <xuxu> i can't type, i should stop now :)
21:23:22 <dfeuer> This channel is really weird tonight.
21:23:31 <ReinH> xuxu: There are exactly two ways you can use let: in do blocks and not in do blocks.
21:23:32 <Cale> dfeuer: You're right, it is weird :)
21:23:32 <boj> zell: hmm, true. i write quite a bit of haskell in the form of a multiplayer game server
21:23:37 <ReinH> dfeuer: agreed
21:23:43 <Gues> Well you can pretty much write in whatever language you want as a web developer if you don't intend for your uses to self-host your software
21:23:49 <Gues> *users
21:24:00 <zell> let's see
21:24:11 <Cale> Gues: I mean, I get to write all my *frontend* code in Haskell.
21:24:25 <xuxu> ReinH: how is the statement there considered an expression style?
21:24:37 <EvanR> self hosting software sounds like something else
21:24:39 <boj> zell: the code is private and the server unreleased, but check out http://armoredbits.com/
21:24:40 <xuxu> why is it not declarative?
21:24:47 <Cale> Gues: (Also the backend code, but that's less interesting, of course I can do that)
21:24:49 <kadoban> Gues: Anyway, I just thought your criteria are weird. Whatever language floats your boat.
21:24:56 <Gues> Yeah, sure. I'm interested in writing applications
21:25:11 <Gues> I don't want to use web UI crap either
21:25:26 <ReinH> xuxu: I don't understand what you mean by "declaration style" and "expression style" so I don't know how to answer that question.
21:25:31 <xuxu> dfeuer: why is it weird in here to you?
21:25:33 <Gues> Like a desktop app that is really just a web browser renderer
21:25:39 <dfeuer> Attention: I'm hoping to release containers in a day or a few. Do you use it? If so, please review the changelog for 0.5.8.1 at https://github.com/haskell/containers/blob/master/changelog.md and let me know if there's anything you think needs to change before release.
21:25:45 <zell> boj is officially not a hacker
21:26:12 <Cale> Gues: Personally, I don't see much difference between that and anything else, if you have native code controlling the contents of the DOM directly.
21:26:16 <xuxu> ReinH: page 13 http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf
21:26:33 <zell> As long as is actually a developer of that game server and it actually uses Haskell
21:26:35 <Welkin> dfeuer: I think everyone uses containers
21:26:37 <Cale> Gues: It becomes pretty much like any other GUI widget interface
21:26:37 <EvanR> Cale: well theres the resources required for a standard browser vs regular desktop app
21:26:55 <Welkin> if they don't then what do they use when they need a basic data structure?
21:26:59 <zell> Can't you just write something for lambdabot to evaluate?
21:26:59 <Cale> EvanR: I mean, just running a webkit-gtk widget
21:27:07 <boj> zell: i don't really understand you
21:27:12 <dfeuer> Welkin, well then, you should probably review the changelog and documentation and tell me what you think needs fixing....
21:27:31 <EvanR> isnt that... the vast majority of where the resources are going
21:27:49 <zell> Sorry I'm just kidding, I'm sure there are at least one troll lurking from the crypto markets though
21:27:49 <EvanR> wouldnt think its my cookie jar
21:28:00 <Gues> Cale: Well, if we compare to some Haskell DSL that compiles to JS and gives you pixel precision over your UI elements, the only difference is that writing your UI in C or C++ is going to be way faster
21:28:26 <ReinH> xuxu: Ok, so which expression where?
21:28:36 <Gues> Because JS is slow and compiling some DSL to JS is probabily going to add another layer of inefficiency
21:28:43 <EvanR> development at the speed of C
21:28:50 <kadoban> dfeuer: The ones I understand sound nice :)
21:28:50 <EvanR> prepare
21:29:08 <Cale> Gues: You only compile to Javascript if you want to run it on the web
21:29:21 <Cale> Gues: You can take that same program and compile it with GHC to native code.
21:29:28 <Gues> Cale: Yeah, that's true
21:29:32 <Cale> and the contents of the DOM will be controlled by native code
21:29:33 <ReinH> Gues: You...  you can't run C or C++ in a browser.
21:29:56 <ReinH> So writing your UI in C or C++ will not be faster, since it isn't possible at all.
21:29:57 <Gues> Web UI's are worse anyway
21:29:58 <xuxu> section 4.4 
21:30:01 <xuxu> ReinH ^
21:30:02 <Cale> So there's no JS in that case, just a browser toolkit mostly written in C :P
21:30:18 <EvanR> C to javascript compiler
21:30:22 <Cale> That we're binding to in Haskell, with a very high level nice interface over top of everything
21:30:25 <boj> Gues: just curious, but do you actually have any interest in Haskell?
21:30:31 <ReinH> xuxu: Where in section 4.4?
21:30:35 <xuxu> i don't understand how one is an expression style and the other is a declaration style, seems this may not be necessarily common knowledge :)
21:30:43 <zell> Can't we write a browser in Haskell which compiles web pages written in Haskell?
21:30:47 <ReinH> xuxu: They define those terms
21:30:53 <xuxu> ReinH: http://lpaste.net/181733 
21:30:53 <dmj> zell: who would use it?
21:30:54 <Gues> Web UIs are slow, bad at fullscreen, and usually lack keybindings. Also, you can't access hardware easily
21:31:05 <ReinH> So they are according to their definitions.
21:31:13 <zell> djm, at least all of humanity ever
21:31:15 <EvanR> Gues: of course you can, at least the printer
21:31:16 <peddie> zell: go for it
21:31:24 <Gues> LOL
21:31:35 <systemfault> EvanR: Even the graphic card
21:31:37 <ReinH> dfeuer: Definitely weird tonight.
21:31:58 <Gues> I've never played a god game written in WebGL
21:32:01 <Gues> *good
21:32:26 <zell> You would if Haskell compiled to it
21:32:44 <zell> From other languages
21:32:50 <Welkin> I am not optimistic about the future of the web as an application platform
21:32:58 <Welkin> it's okay for online services
21:33:01 <EvanR> 2008 called
21:33:03 <ReinH> If Haskell compiled to... WebGL? You know what, never mind.
21:33:09 <Gues> Yeah, same
21:33:11 <Welkin> but for something that could easily be a desktop application, but runs in the browser
21:33:19 <Welkin> yeah, it sucks unless it's just  crud app
21:33:23 <EvanR> ReinH: i was sort of working on that...
21:33:31 <Gues> I mean, web services like YouTube and Amazon make sense
21:33:46 <Gues> But most stuff I'd rather not be a service at al
21:34:03 <Gues> And I'd rather have an application
21:34:17 <xuxu> ReinH: i might should instead sleep. 
21:34:20 <Welkin> games, for example
21:34:26 <Welkin> they don't have access to anything really
21:34:47 <xuxu> ReinH: thanks for at least addressing me
21:34:56 <EvanR> except your video, harddrive, internet connection
21:35:07 <Welkin> EvanR: not your harddrive
21:35:18 <Welkin> it's in a sandbox
21:35:28 <EvanR> i guess all your saves are at blizzard now so 
21:35:30 <Gues> Uh, games write config files, models, etc.
21:35:41 <EvanR> who needs a harddrive
21:35:42 <boj> i think Welkin is talking about browser games
21:35:43 <zell> Virtual machine written in Haskell running os written in Haskell running ghc to compile Haskell programs for this vm which is running on Android
21:36:00 <dfeuer> kadoban, you can browse the latest containers documentation at http://treeowl-containers-general-merge.bitballoon.com/ which should explain the parts you don't understand in the changelog. If you still don't understand them after you read the docs, that's the sort of thing I need to know about.
21:36:09 <EvanR> my atari ST didnt need a harddrive either
21:36:35 <Welkin> dfeuer: I read the changelog and it looks fine to me. I don't know about some of those functions because I never used them
21:37:18 <Welkin> and I assume `merge` and `mergeA` are something like Elm's dictionary merge (left-biased, right-biased, or use all and some combining function)
21:37:20 <zell> Is there an os written in Haskell that can compile Haskell programs that run on it?
21:37:43 <dfeuer> Welkin, I know nothing about Elm. Take a look at http://treeowl-containers-general-merge.bitballoon.com/data-map-lazy-merge
21:38:10 <dmj> Welkin: that was before elm dropped Signals I believe
21:38:25 <dmj> @google Haskell operating system
21:38:26 <Welkin> dmj: no, it's still there
21:38:27 <lambdabot> http://stackoverflow.com/questions/6638080/is-there-os-written-in-haskell
21:38:27 <lambdabot> Title: operating system - Is there OS written in Haskell? - Stack Overflow
21:38:36 <dmj> zell: ^
21:38:38 <zell> It's a small extension to ghc
21:38:38 <Welkin> dfeuer: yeah, that is the same idea
21:38:52 <dmj> Welkin: I wonder what for
21:39:02 <ReinH> zell: what is?
21:39:15 <Welkin> dmj: what o.o
21:39:57 <dmj> Welkin: what is merging if Signals were removed
21:40:21 <zell> These all suck. Just have to write minimal Linux
21:40:25 <kadoban> dfeuer: One thing I notice is that the ASCII-diagram-ish thing showing the lining up of keys on http://treeowl-containers-general-merge.bitballoon.com/data-map-lazy-merge doesn't line up very well (the 1s and the 4s especially)
21:40:39 <ReinH> zell: what is a small extension to ghc?
21:40:48 <Welkin> dmj: a Map (called a Dict in Elm)
21:40:54 <dmj> Welkin: ah
21:40:57 <zell> Os capable of running Haskell code
21:41:07 <ReinH> zell: No it isn't?
21:41:14 <zell> Why not?
21:41:24 <zell> Basically already ruins in ghci
21:41:26 <Welkin> zell: you mean Minix?
21:41:27 <Welkin> :D
21:41:38 <dfeuer> kadoban, I just noticed that too. Do you know if it's possible to fix that in Haddock? It looks fine in fixed-width.....
21:41:44 <ReinH> Turning GHC in an operating system would not be a "small extension".
21:41:53 <kadoban> dfeuer: Also is that "@since 0.5.8" supposed to be displayed like that? It looks almost like a directive or something that didn't get parsed, or maybe I just haven't seen that too.
21:41:56 <Cale> zell: Would Xen be light enough for you?
21:41:59 <ReinH> This is absurd.
21:42:11 <EvanR> operating systems are pretty off topic
21:42:12 <kadoban> dfeuer: Yeah, that's kind weird. It is actually using a fixed width font, at least in my browser ... hmm.
21:42:12 <Cale> zell: https://github.com/GaloisInc/HaLVM
21:42:21 <ReinH> I feel like you don't know what an operating system is.
21:42:23 <dfeuer> kadoban, I *think* that's just not supported properly by the version of Haddock I have lying around.
21:42:28 <kadoban> Ahh
21:42:55 <dfeuer> kadoban, yeah, it also looks fixed-width in my browser, but I *know* that vim is showing me actual for-real fixed-width.
21:42:56 <zell> Xen is neither written in Haskell nor what I'm after for any other reason
21:43:24 <ReinH> On the other hand, it does have the important quality of actually existing.
21:43:26 <EvanR> haskell isnt an OS, its not suited for writing OSes, it doesnt run on very many OSes, its basically a non haskell topic
21:43:32 <kadoban> dfeuer: Pretty strange, but really minor stuff, I certainly picked up what it meant there anyway, without knowing anything about this coming in, the rest seems pretty clear too (so far)
21:43:42 <Cale> zell: I mean, HaLVM lets you run your Haskell programs directly on the Xen hypervisor, without an OS in the way.
21:43:45 <dfeuer> Yay!
21:43:53 <Welkin> I once wrote a very basic OS for a 16-bit microcontroller in motorola assmebly
21:43:58 <ertesx> zell: to answer your question: there is no operating system written in haskell that runs on bare metal
21:43:59 <zell> But I need an os to emulate
21:44:02 <Welkin> that was pretty easy
21:44:23 <zell> It can ruin on jvm which is good I guess
21:44:24 <Cale> ertesx: That might be true right now, but it was not always true
21:44:31 <Cale> There was House
21:44:35 <boj> are there any stories of companies outside of galois using halvm?
21:44:45 <dfeuer> kadoban, did you check out Data.Map.Lazy.alterF?
21:45:06 <ReinH> Even if an operating system written in Haskell did exist, you could not use it to compile Haskell programs using emacs on android phones.
21:45:09 <ertesx> Cale: i'd not show people house as an "operating system" =)
21:45:12 <fizbin> Okay, this may be haskell profiling 101, but: I have a process that is demonstrably CPU-bound. The profiling run I just did concludes "Productivity  26.3% of total user, 25.9% of total elapsed", and that 202.767s of my program's total 372.722s runtime was GC. (97.897s was MUT, but I don't know what that means)
21:45:14 <zell> It would have to have opengl
21:45:16 <kadoban> Nope, just looked in merge so far.
21:45:16 <ReinH> This entire discussion is absurd.
21:45:17 <ertesx> it's a little proof of concept
21:45:18 <dmj> boj: yes, companies use applications that are compiled with HalVM, and run them on Xen
21:45:21 <dfeuer> Oh, okay.
21:45:33 <fizbin> So, where do I begin looking for where the garbage is and how to reduce that?
21:45:47 <Welkin> fizbin: compile with profiling
21:46:00 <Cale> ertesx: I would say it technically qualifies, even if it never really got enough drivers or applications to be useful for much.
21:46:00 <fizbin> Yeah, and?
21:46:02 <Welkin> and run with +RTS <options>
21:46:21 <fizbin> What do I do with these .prof and .hp files?
21:46:24 <zell> When your working with phones you don't want bare metal because you shouldn't root your phone
21:46:28 <Welkin> fizbin: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
21:46:35 <dmj> fizbin: use hp2ps
21:46:48 <boj> it just dawned on me that i could build my game server on halvm and just spin up instances that way 
21:47:10 <Welkin> what does halvm have to do with anything?
21:47:13 <fizbin> Okay, so here's the problem: hp2ps makes pretty pictures, but I have no idea what those pictures are telling me?
21:47:17 <fizbin> me.
21:47:18 <zell> I had an emulated Linux kernel. But I don't want to have to make the whole of Linux just to run ghci
21:47:20 <ertesx> zell: while you say that you're asking for an operating system, i'm not sure what you're *really* asking for, i.e. what problem you're trying to solve
21:48:36 <boj> Welkin: what do you mean?
21:49:03 <Welkin> boj: why do you need halvm?
21:49:34 <Cale> Welkin: I brought up HaLVM because zell was asking about running Haskell on bare metal, rather than having to run Linux underneath.
21:49:35 <zell> I want an os to run ghci. I will have to write this in Haskell, compile to java and then to Android, release it on the play store and then develop programs targeting Android in this way on Android using this minimal emulated os
21:49:52 <zell> I definitely don't want bare metal
21:50:12 <zell> It had to be emulated by a java program
21:50:13 <boj> Welkin: i have spent the last year writing a game server in Haskell, the goal of which is launching a game service. using halvm to run it would be a lot more lightweight and easier to manage/spin up than running the binary inside an OS
21:50:25 <Cale> HaLVM isn't quite bare metal, but it's closer to it than many other options.
21:50:28 <kadoban> dfeuer: Oh huh, that looks cool. Seems like it makes sense. I don't know that I've ever come across a situation that would call for it, but maybe I will now that it exists, heh.
21:50:53 <ReinH> zell: If you can't run Haskell programs on android, how will writing an OS in Haskell help you run Haskell programs on android?
21:51:01 <ReinH> You would have to run the OS
21:51:07 <ReinH> which, being a Haskell program, you cannot.
21:51:11 <dfeuer> kadoban, sweet. I just found a major formatting bug in the documentation for the new Data.Sequence.intersperse.
21:51:21 <zell> That's why that's the problem I need to solve
21:51:32 <kadoban> dfeuer: One dumb thing (sorry): I initially found the difference in the two equations distracting between alter and alterF:  "lookup k (alter f k m) = f (lookup k m)" vs. "lookup k $ alterF f k m = f (lookup k m)"  (parens vs. $)
21:51:34 <ReinH> What
21:51:35 <zell> In order to do what I just described i wanted to
21:51:45 <ertesx> there has been some success compiling haskell to android native code
21:51:51 <ReinH> zell: I am explaining why you can't do what you want to do
21:52:03 <zell> That's what I'm trying to solve
21:52:07 <peddie> zell: maybe you should write a working haskell program before you worry about all this
21:52:08 <ReinH> You can't solve it
21:52:12 <ReinH> since it's something that you can't do
21:52:15 <dfeuer> kadoban, that looks *wrong*. The $ should be <$>. 
21:52:27 <kadoban> Oh, hah, yes it should.
21:52:27 <ertesx> zell: there is a VM ready-made for you that you can use to target from haskell: javascript
21:52:32 <zell> > [1..]
21:52:34 <ertesx> zell: see apache cordova and GHCJS
21:52:34 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
21:52:43 <dfeuer> kadoban, thanks for catching that.
21:52:52 <kadoban> Accidentally xD but I'll take it.
21:53:05 <ReinH> if you could run Haskell OS on your phone, you wouldn't need to run a Haskell OS on your phone because you can already run Haskell programs on your phone.
21:53:06 <ertesx> zell: bonus: you won't spend the next two years engineering
21:53:20 <ReinH> Since the Haskell OS is, by definition, a Haskell program.
21:53:21 <zell> Wait so what I can compile Haskell with javascript?
21:53:25 <dmj> ertesx: at least, heh
21:53:33 <ReinH> No, you can't compile Haskell with javascript.
21:53:39 <ReinH> you can compile Haskell *into* javascript.
21:54:02 <dmj> you could try to compile ghc with ghcjs ;)
21:54:15 <ReinH> At least, no one to my knowledge has written a Haskell compiler in javascript or, yes, done that.
21:54:22 <ertesx> zell: GHCJS compiles haskell *to* javascript, and cordova runs apps written in HTML/JS like a browser app, but with access to some of the phones features
21:54:22 <lispy> zell: you can import js libs into ghcjs compiled haskell
21:54:34 <ertesx> phone's
21:54:48 <zell> But if I can't use it to compile Haskell code from my phone for my phone I rely don't see how it helps
21:55:24 <dmj> zell: your phone doesn't care at that point, since it only needs to understand javascript
21:55:35 <zell> Yes compiling Haskell to java is done, we can write apps that use Haskell code.
21:55:44 <ReinH> Compiling Haskell to java is not done.
21:55:53 <ReinH> You keep saying that, but saying it doesn't make it so.
21:55:57 <ertesx> not officially or in any known open source project at least
21:56:01 <ReinH> Unless you mean javascript.
21:56:05 <zell> lispy, do you know if I can use bindings like to openGL?
21:56:08 <ReinH> And are perhaps unaware that java and javascript are different things
21:56:20 <lispy> zell: you mean webgl?
21:56:31 <ReinH> You can't use OpenGL bindings in a broswer
21:56:36 <lispy> ReinH: I mean, there is a summer of haskell project to compile to jvm
21:56:40 <Welkin> I think he means to say it is "dumb"
21:56:52 <orion> It would be cool to have a Haskell shell that's an amalgamation of ghci and bash.
21:57:02 <ReinH> orion: hell
21:57:04 <Welkin> orion: Hell
21:57:08 <dmj> @package hell
21:57:08 <lambdabot> http://hackage.haskell.org/package/hell
21:57:10 <zell> Cordova is apache not Haskell
21:57:17 <ReinH> No one claimed Cordova was Haskell
21:57:19 <Welkin> http://hackage.haskell.org/package/hell
21:57:27 <dmj> zell: are you doing this on purpose
21:57:38 <zell> Yeh I'm making a new statement about fussiness
21:57:41 * Welkin throws dmj
21:57:49 * Welkin aims at zell
21:58:01 <glguy> Welkin: I'd advise doing that in the other order
21:58:19 <ReinH> Depending on whether you want to hit or not, I suppose
21:58:33 * dmj hides behind glguy
21:58:58 <ertesx> glguy: not necessary in haskell:  do rec throwTo t dmj; t <- aimAt zell
21:59:13 <saurabhnanda> Please share your feedback on https://www.reddit.com/r/haskell/comments/50fibt/resources_for_learning_how_to_practically_use/
21:59:32 <glguy> ertesx: That's a good way to put the world into a blackhole
21:59:57 <zell> The situation is post appocalyptic, all you have is opengl Haskell bindings, ghci and an Android phone which you can somehow publish apps too and use to compile and publish apps if only the world hadn't been destroyed along with #haskell
22:00:08 <ertesx> don't worry, haskell black holes vanish immediately
22:00:26 <ReinH> This is the very definition of absurd.
22:00:31 <ertesx> the worst they can do i<<loop>>
22:00:37 <orion> What modules should I look at if I want to have an end-user load and unload pre-compiled shared objects at runtime?
22:00:59 <orion> (Similar to how Linux has loadable modules)
22:00:59 <glguy> orion: My IRC client supports runtime loading / unloading of a shared object (extension api)
22:01:11 <glguy> if you're looking for an example
22:01:33 <dmj> zell: appocalyptic... I see what you did there
22:01:44 <monochrom> glguy: do you use the GHC API directly for that?
22:01:47 <zell> Does there exist a genuine lack of available tools for me to develop Haskell on Android or is this channel just too pedantic?
22:02:02 <glguy> monochrom: No, it's a C library shared object, so dlopen and friends
22:02:12 <ertesx> orion: i'd launch processes
22:02:26 <monochrom> I think I see.
22:02:33 <glguy> https://github.com/glguy/irc-core/blob/v2/src/Client/CApi.hs
22:02:46 <glguy> https://github.com/glguy/irc-core/blob/v2/src/Client/CApi/Exports.hs
22:03:18 <ertesx> zell: there exists a genuine lack of tools…  as i said, there has been some success compiling haskell to android native code, and you can compile haskell to JS to use together with something like cordova, but that's it
22:03:36 <zell> If you don't think the state of the internet and these new fangled devices interplay with your mother tounge is a nightmare scenario I don't know what would
22:04:12 <ertesx> i'd go with GHCJS+cordova
22:04:24 <cocreature> orion: I have a minimal example of how to load haskell objects https://purelyfunctional.org/posts/2016-05-20-dynamic-loading-haskell-module.html but you probably want to use the “plugins” package which hides all that ugly machinery instead
22:04:29 <zell> So I can at least run Haskell programs in the browser
22:04:30 <Welkin> I thought you could run anything that you could compile to machine code on ios/android
22:04:35 <kadoban> dfeuer: I'm a tiny bit confused by the asymptotic bounds on for example intersection in http://treeowl-containers-general-merge.bitballoon.com/data-map-strict , both just is that the correct bound? I only ask because it's a bit uncommon looking of a bound, and because the changelog says they're asymptotically optimal, but the old bounds in like https://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Map-Lazy.html are better, unless I'm 
22:04:36 <kadoban> flubbing my big-O
22:05:20 <Welkin> kadoban: Roger Smith?
22:05:26 <dfeuer> kadoban, I think you're flubbing your big-O, although the bounds are definitely not the most understandable.
22:05:42 <ReinH> kadoban: there's a paper that talks about the bounds, referenced in the docs
22:05:46 <zell> Can I then compile ghci to js and have it run on the browser to compile to js to run on the browser?
22:05:51 <ReinH> If you want to know about the bounds, you might try reading the paper about the bounds.
22:06:00 <kadoban> ReinH: Ah, I should likely read that.
22:06:07 <kadoban> dfeuer: Fair enough then
22:06:30 <zell> Because that sounds awesome, I almost want to change the goal to that because Android sucks
22:06:42 <dfeuer> kadoban, a point that would be good to make in the documentation is that if you take a bunch of singleton sets, you can union them together in any order and only take O(n log n) time to do so.
22:06:47 <zell> By that i mean a browser solution would be cross platform
22:07:04 <glguy> orion: If that code is relevant and you have more questions you're welcome to ask more in #haskell-irc
22:07:07 <ertesx> zell: unlikely, but you're welcome to try
22:07:43 <dfeuer> kadoban, the new bounds are better than the old ones, but it's definitely less than obvious. See what happens when you plug in m=n. Then see what happens if m or n is just 1.
22:07:51 <zell> Might be easier to bundle Linux with ghci on into an app
22:08:47 <lispy> saurabhnanda: I threw in my $0.02
22:08:51 <ertesx> "wow, i've downloaded your app, it was quite huge!  right now i'm waiting for it to start…  what does it do?" – "displays 'hello world'"
22:08:55 <saurabhnanda> lispy: thanks :)
22:08:57 <kadoban> dfeuer: Oh I see, huh that's quite interesting
22:09:20 <zell> And then rather than targeting the phone by also running an Android compiler on the Linux kernel, you would have to deploy a server to run the webpage. Is that right?
22:09:27 <Welkin> zell: you might find this interesting http://daurnimator.github.io/lua.vm.js/lua.vm.js.html
22:09:35 <Welkin> the entire lua vm in the browser
22:09:42 <dmj> ok I actually have a haskell question
22:09:44 <Welkin> it works really well
22:09:47 <ReinH> dmj: thank god
22:09:52 <dmj> ReinH: :)
22:10:12 <ReinH> I think I was going slowly insane.
22:10:34 <dmj> if I have two types, 'a' and 'b', where 'b' is created from 'a', is there a way to track all the sub parts of 'a' that were used to generate 'b', so later, if 'a' was modified, I could reuse parts of the old 'b' to construct the new 'b' (patching it basically), to reduce allocations. Similar to gdiff maybe, but this is tracking changes across different types, not the same type, if that makes sense.
22:11:14 <ReinH> What does "'b' is created fro 'a'" mean?
22:11:15 <dmj> I'm referring to the values, when I talk about creation
22:11:24 <ReinH> *from
22:11:26 <zell> Can lua run linux?
22:11:50 <ReinH> Do you know what linux is?
22:12:10 <zell> Because if not I know no other os to use to compile Haskell that I can get the source of and compile to Haskell
22:12:43 <zell> If lua claims to be a virtual machine and I can't install Linux on it then it's no good
22:12:55 <glguy> zell: Try to stick to Haskell questions
22:12:57 <lispy> dmj: Doesn't bidirectional programming have to deal with that problem?
22:13:09 <ReinH> You know what, whether a programming language that is not Haskell can "run" a kernel is off topic.
22:13:12 <Welkin> http://kripken.github.io/emscripten-site/
22:13:14 <dmj> ReinH: "b is created from a" just looks like: a -> b
22:13:23 <ReinH> dmj: Ok right
22:13:26 <boj> dmj: you mean like downgrade a type, but save the information that was lost?
22:13:31 <Welkin> you could very likely use emscripten to run anything in the browser
22:13:35 <ReinH> dmj: So this is about sharing?
22:13:39 <zell> I wasn't asking about anything to do with not Haskell
22:13:39 <ertesx> dmj: sounds like something "free"
22:13:53 <ReinH> zell: your question had nothing to do with Haskell
22:13:53 <ertesx> dmj: a list, a free monad, …
22:13:54 <zell> Everything needs to be written in Haskell, that's the point
22:14:08 <zell> I want to compile Haskell on my phone
22:14:14 <zell> Using Haskell programs
22:14:18 <boj> this zell character is kind of tiring
22:14:28 <dmj> ReinH: yes
22:14:32 <kadoban> dfeuer: Does haddock not know how to show pattern synonyms, is that why Empty, :<| and :|> aren't in the docs there? Just making sure it wasn't supposed to be mentioned there (I forget how/if they usually show up in docs and can't find an example to compare at the moment)
22:14:42 <zell> Yeah I'm getting pissed at being put on the defensive
22:14:53 <zell> Just make it happen ok?
22:14:58 <ertesx> dmj: free things tend to expose their composition structure
22:15:05 <ReinH> Ok, can we just call zell a troll now please?
22:15:06 <dfeuer> kadoban, I *think* that's a problem with the version of Haddock I'm using, but I don't really know how to verify that :-/
22:15:10 <ReinH> This has gone on long enough.
22:15:11 <dfeuer> Yes.
22:15:22 <dmj> it seems like GHC is good at sharing when it comes to modify values of the same type (i.e. modifying large HashMaps), but much is lost in translation across types
22:15:25 <dfeuer> Temporary troll, at least.
22:15:28 <dmj> s/modify/modifying
22:16:05 <kadoban> dfeuer: I think that's all I potentially see then, all-in-all looks really good, the parts I looked at.
22:16:11 <tzh> zell: the short answer is "no, you cannot do the thing you want"; the long answer is something like http://stackoverflow.com/questions/5151858/running-a-haskell-program-on-the-android-os#5152910 at least insofar as your question is "can i compile haskell code to run on android?"
22:16:15 <dmj> ertesx: I see, so the free thing would be rules of construction for 'a', reusing an older 'a' if possible
22:16:47 <zell> Iv been trying for a good few years and have got every working attempt running while they were stable
22:16:52 <zell> None are now
22:17:01 --- mode: ChanServ set +q *!*@188.29.165.62.threembb.co.uk
22:17:08 <dmj> ertesx: the goal would be to minimize allocations, including free monad constructors :/
22:17:43 <ertesx> dmj: you could use the church-encoded variant
22:17:59 <ertesx> but it restricts you to full traversals
22:18:12 <johnw> dmj: the 'free' library has a church-encoded variant in it
22:18:37 <ertesx> dmj: if you don't want that restriction, then you indeed want that overhead, because you actually need that information at run-time =)
22:18:54 <ertesx> so it makes sense to have the constructors
22:18:58 <johnw> you could also use the Scott-encoded free monad
22:19:11 <ReinH> Rub some coyoneda on it
22:19:22 <ReinH> or whatever it is
22:19:33 <dfeuer> Thanks, kadoban.
22:19:34 <johnw> newtype Scott  a = Scott  { runScott  :: forall r. (a -> Scott a -> r) -> r -> r }
22:19:59 <johnw> this lets you control how deep evaluation goes
22:20:05 <ertesx> the scott-encoded variant would have the advantage that you can have instances with smaller contexts, but it doesn't get rid of the constructor overhead the way church does
22:20:37 <johnw> i guess you pay for the feature
22:21:52 <glguy> Hi, gestone. Did you end up looking at that code yesterday?
22:22:46 <gestone> glguy: oh hey, i did a little bit on github, i'm cloning atm
22:25:01 <gestone> glguy: do i use stack to build this project?
22:25:22 <glguy> gestone: You can. I don't
22:25:29 <glguy> I can try if you want
22:25:35 <gestone> i tried running stack build
22:25:42 <gestone> it didn't seem to work
22:26:22 <glguy> You can just cabal build it
22:26:38 <gestone> just a simple cabal build?
22:26:51 <dmj> ertesx: makes sense, in this case I still feel like I'm trading allocations of 'a' for allocations of F and patches of 'a'. Ideally what I want is to have a function a -> b, and an older 'b' that gets read from (shared when needed) during the construction the new 'b', in a -> b.
22:27:13 <glguy> gestone: a simple cabal install will do it. To get all the dependencies first if you want you can run: cabal install --dep
22:27:16 <ertesx> dmj: so an (a -> b -> b)?
22:28:10 <gestone> hm? cabal couldn't resolve dependencies?
22:28:13 <glguy> gestone: For using stack you can use: stack init --resolver=ghc-8.0
22:28:19 <ertesx> dmj: you need a way to expose the structure you want to observe…  you can always just encode it manually using an encoding specific for your particular 'a' and 'b'
22:28:33 <glguy> gestone: Maybe you need to update
22:28:34 <glguy> cabal update
22:28:36 <ertesx> dmj: free structures just make it easier by giving you some common and well understood patterns
22:29:23 <gestone> glguy: i'll give it a shot
22:30:08 <glguy> gestone: If you want to join #haskell-irc we can chat about it with less scrolling
22:30:13 <glguy> (or here is fine, too)
22:30:27 <gestone> sure
22:31:57 <dmj> ertesx: this (a -> b) would be defined by the library consumer, but the benefit of efficient 'b' construction should be gained, and would be the responsibility of the library implementor (me), and I would have access to the old 'b' for sharing
22:35:54 <dmj> ertesx: a -> b would get run in a tight loop, in IO. Old b would be saved for next iteration. So in this loop the full encoding would still be generated each time, if we used Free
22:36:17 <dmj> s/Free/F
22:36:34 <ertesx> dmj: so basically you want your user to construct a new B in each frame, but then you want the frame controller to quickly find opportunities for sharing?
22:36:59 <dmj> ertesx: basically, yes
22:37:31 <ertesx> dmj: why don't you just allow your user to do the sharing by giving them access to the old B?
22:38:03 <dmj> ideally based on pre-existing data (no new constructors) as well
22:38:46 <ertesx> alternatively just make sure your user can use haskell sharing…  if they construct a portion of B and then reuse it, regular sharing should simply kick in
22:39:13 <ertesx> i'd go as far as to say that if you need to concern yourself with this in the controller, you'll end up sad
22:39:16 <ertesx> really sad
22:39:32 <dmj> ertesx: we could put the old B as an arg into the function the user defines, but I'd consider the old B internal, and implementation details. Ideally, we can do it for the user
22:39:49 <ertesx> dmj: no need to do that, if B can use sharing
22:39:52 <Cale> Quick reflex-dom demo: http://cale.yi.org/ParseHaskell.jsexe/ (source: http://cale.yi.org/ParseHaskell.jsexe/ParseHaskell.hs)
22:41:08 <ertesx> dmj: example: data T = A | B T T | C Int  -- the user can 'let x = B A (B (C 5) A)', then whenever they refer to 'x' it's simply shared, even when embedded in a larger T
22:44:01 * hackagebot containers 0.5.8.1 - Assorted concrete container types  https://hackage.haskell.org/package/containers-0.5.8.1 (dfeuer)
22:47:06 <dmj> ertesx: I see, so IO occurs between each b creation (FRP loop), so I'm pretty sure sharing would get killed. But maybe we can demonstrate using your example what it would look like.
22:47:45 <ertesx> dmj: why would IO kill sharing?
22:48:00 <dmj> well, the let binding wouldn't be referenceable anymore
22:48:08 <ertesx> dmj: why not?
22:49:02 <ertesx> let s = … in control (\x -> …)  -- here is one way to do it, which is constant across all frames
22:49:16 <ertesx> the other way, since it's FRP, is to have an "event scan"
22:49:19 <dmj> because at that point 'b' is a fully evaluated object, it's not being constructed anymore, it's parts can't be referenced
22:49:50 <ertesx> dmj: https://github.com/esoeylemez/wires/blob/master/Control/Wire/Core.hs#L138
22:51:15 <ertesx> dmj: here is an example of how to use it: https://github.com/esoeylemez/wires/blob/master/examples/Utils.hs#L19
22:51:34 <ertesx> it shares the Seq it constructs across occurrences (and thus frames)
22:54:07 <dmj> ertesx: I see
22:54:36 <jle`> it's still kind of weird that * is now a type of kind *, that you could theoretically have values of if there were any constructors
22:56:34 <ertesx> dmj: ignore the fact that the implementation of 'average' is so terrible algorithmically that it doesn't matter in this case =)
22:56:50 <dmj> ertesx: :)
22:56:52 <ertesx> it's just part of a small example, not the actual library
22:57:54 <dmj> ertesx: I see, so using your previous example, if we had f :: Int -> T; f n = B A (C n), and we called (f 4) first, then (f 5), we'd have to unfold (f 4) to know how to share the A in (f 5), is that what I'm seeing
22:58:19 <dmj> how can we keep a new 'A' from being created I suppose
22:58:33 <dmj> across (f 4) -> (f 5)
22:58:41 <ertesx> dmj: yeah, you can only share the 'A' there
22:59:03 <ertesx> if you want to share dynamically constructed values, you need a scan
22:59:29 <ertesx> basically what you have right now is a 'map', but you need a 'scan'
23:00:20 <ertesx> for example imagine you were constructing this sequence: A, B (C 0) A, B (C 1) (B (C 0) A), etc.
23:00:42 <ertesx> the only (reasonable) way to use sharing here is to give the user access to the old value
23:04:02 * hackagebot cipher-aes128 0.7.0.3 - AES and common modes using AES-NI when available.  https://hackage.haskell.org/package/cipher-aes128-0.7.0.3 (ThomasDuBuisson)
23:05:55 <dmj> ertesx: very interesting
23:07:15 <glguy> hi jharjanto . 
23:07:20 <jharjanto> oh hello
23:07:23 <jharjanto> ohhh
23:07:54 <dfeuer> kadoban, the @since annotations worked. http://hackage.haskell.org/package/containers-0.5.8.1
23:09:28 <dmj> ertesx: in my case the function looks like a -> Tree b
23:09:51 <kadoban> dfeuer: Nice
23:10:48 <GGuy> hi, what are the pros/cons of using empty types and writing the implementations as class instances? I've been watching some of Conal Elliott's videos on denominational design and I always tend to end up wanting to implement everything a class instances. Maybe that's the intent?
23:11:02 <antipsychiatry> Hi. Read :               http://www.naturalnews.com/049755_Bride_of_Frankenfood_Hillary_Clinton_Monsanto.html
23:11:02 <dfeuer> kadoban, the unnice parts: the hidden modules still show up in the big list, which is ugly and terrifying. Also, I don't know how some people make super-hyperlinked source.
23:11:04 <dmj> ertesx: so you're saying if I used scanr I'd need (a -> Tree b -> Tree b) -> Tree b -> [a] -> [Tree b]. The issue is now the user has to traverse the old tree while constructing the new. So I see how it's shared, but it's explicit and onus is on the user to perform it
23:11:14 --- mode: ChanServ set +o geekosaur
23:11:31 --- mode: geekosaur set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.185.32.179.90
23:11:31 --- kick: antipsychiatry was kicked by geekosaur (antipsychiatry)
23:11:43 --- mode: geekosaur set -o geekosaur
23:11:47 <GGuy> "denotational design"*
23:12:11 <dmj> ertesx: seems we could do the same with foldr
23:12:16 <dfeuer> GGuy, empty types? What do those have to do with denotational design?
23:12:17 <ertesx> GGuy: not necessarily a class…  conal's design principle is that you should always have a formal semantics and an implementation of it
23:12:37 <ertesx> GGuy: so that your programs have mathematical meaning, and implementations can be compared to it
23:12:54 <ertesx> GGuy: if your semantics is a type, then an implementation is a value
23:12:56 <kadoban> dfeuer: Yeah, that is unfortunate, all of the hidden modules ... I wish I knew how haddock worked better.
23:13:30 <dfeuer> kadoban, I suspect that's more a Hackage thing that I can't do anthing about. The hyperlinked source is probably something I could do something about, but I dunno how.
23:13:53 <ertesx> dmj: the hallmark of a scan is that you have a (next :: A -> S -> S) and an (s0 :: S)
23:14:38 <ertesx> dmj: then you have a source for those As, like an event of A, and what you construct is a similar object, like another event, but of S
23:15:01 <ertesx> dmj: i'd not call it a fold, because you're not reducing to a result value…  and it's left, not right
23:15:17 <ertesx> :t scanl -- this is the idea as applied to lists
23:15:19 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
23:15:24 <cocreature> dfeuer: is there a reason why only the internal module for strict maps is exposed? that seems inconsistent
23:15:50 <GGuy> ertesx: Yes. When I try to apply my rough understanding of dd my mind turns to empty types to implement it. If only because those empty types are are used at the mathematical meaning and the class instances are the implementation. 
23:16:16 <cocreature> dfeuer: you can steel the commands from https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh to get hyperlinked source links
23:16:16 <dfeuer> cocreature, the lazy stuff is all in Data.Map.Base. I didn't really want to expose this mess in such a state, but edward wanted the access.
23:16:23 <cocreature> ah ok
23:16:26 <ertesx> GGuy: sounds like you're using a class when you should use a type
23:17:05 <dfeuer> cocreature, I really wish I could tell Hackage to hide the internal modules from the table of contents. Is there any way?
23:17:30 <ertesx> GGuy: DD maps to classes and instances nicely, but it also maps to types and values nicely, which is actually not that surprising, because instances are to classes what values are to types
23:17:47 <cocreature> dfeuer: afaik no but personally I also don’t think this is a good idea. they are already called internal so it should be reasonably clear that no guarantees are made about their stability
23:17:54 <GGuy> ertesx: yes true
23:17:58 <dmj> ertesx: right, I see what you're saying. I'm just not sure library users will want to worry about handling the sharing themselves, but it seems there's no way around it...
23:17:59 <cocreature> and I really hate packages that don’t expose their internals in some module
23:18:47 <ertesx> dmj: if i'd be a user of your library, i'd want you to give me control over the sharing =)
23:19:08 <ertesx> dmj: in fact library users are more likely to "just do it" rather than "worry about it"
23:19:56 <ertesx> > scanl (\dx x -> x + 2*dx) 0 [1,3..]
23:19:58 <lambdabot>  [0,1,5,15,37,83,177,367,749,1515,3049,6119,12261,24547,49121,98271,196573,39...
23:20:15 <ertesx> dmj: i didn't particularly "worry" about sharing there…  i just used it by the fact that i referred to 'x'
23:21:08 <dmj> ertesx: the a -> b function is actually for html templating (where b is an HTML tree), so imagine having the previous html around, that you had to pattern match on, if you just wanted to perform simple templating. Not sure that's aesthetically appealing, but it would be more efficient definitely.
23:22:01 <ertesx> dmj: start with an unfold
23:22:08 <ertesx> a scan is a special case of that
23:22:46 <dfeuer> cocreature, you don't think what is a good idea?
23:22:59 <ertesx> dmj: the unfold is expressive enough that you don't necessarily pass the old *document* to the function, but an arbitrary state type, which may be a much simpler object
23:23:26 <dfeuer> The internals were previously completely internal. Now almost all of them are exposed through Cabal (but not Haddock).
23:23:39 <cocreature> dfeuer: hiding some modules from the hackage page. that’s the place I look at if I’m trying to figure out how to do something and if I realize the public API is not exposed and there are no internal modules listed I give up
23:24:01 <cocreature> s/not exposed/sufficient/
23:24:10 <cocreature> s/sufficient/not sufficient/
23:24:13 <cocreature> it’s way too early to talk
23:24:22 <dfeuer> cocreature, are you saying you want to be able to click on the internal modules on Hackage?
23:24:36 <dmj> ertesx: would have though unfold could operate on Foldable
23:24:36 <cocreature> dfeuer: yes
23:24:39 <gestone> glguy: this client is amazing
23:24:43 <ertesx> dfeuer: seconded
23:24:44 <dmj> s/though/thought
23:24:46 <dfeuer> I already fear for the beginner who sees the page *as it is now*.
23:25:04 <dmj> ertesx: being the dual of foldr and all
23:25:20 <cocreature> dfeuer: it’s not like internal modules are something containers come up with. .Internal modules are quite common so I don’t think there will be much confusion
23:25:27 <ertesx> dfeuer: maybe ".Base" is just not a very good name
23:25:37 <cocreature> yeah .Base is problematic
23:26:37 <dfeuer> ertesx, cocreature, yes, it's not optimal. I need to spend a bunch of time rearranging the internals. There was demand for internals, and there was not time to make them (even slightly) pretty first.
23:26:54 <ertesx> dfeuer: even as a beginner i prefer when people warn me instead of patronising me
23:27:28 <dfeuer> ertesx, when faced with a giant page full of modules, *most* of which are irrelevant internals, how do you see which ones you need to care about?
23:27:44 <cocreature> dfeuer: top down
23:27:52 <dfeuer> cocreature, eh?
23:28:00 <cocreature> start with the top level module in the module hierarchy and then work your way to the more specific stuff
23:28:07 <ertesx> dfeuer: normally though conventions like ".Internal" and the overall structure (deeper in the hierarchy = more "internal")
23:28:27 <dfeuer> cocreature, ertesx, I eagerly await your pull requests.
23:28:39 <cocreature> I’ll see if I can find some time :)
23:29:01 <cocreature> I have never looked at the containers source so I’ll probably learn a bunch of stuff which is good
23:29:01 <ertesx> dfeuer: changing what?  the module names?  or adding warnings?
23:29:14 <ertesx> dfeuer: i'm happy to do it later today =)
23:29:57 <dfeuer> ertesx, changing module names, and rearranging the internal modules so they make more sense. Caution: no orphan instances allowed.
23:30:46 <ertesx> dfeuer: are all base and utils modules considered internal in the sense that renaming them is not considered a breaking change?
23:31:13 <dfeuer> ertesx, they are considered internal in the sens that renaming them, deleting them, etc., are not considered breaking changes.
23:31:18 <dfeuer> *sense
23:32:02 <dfeuer> The *only* internal functions I've committed to keeping available *somewhere* are Data.Map.Base.drawTree and Data.Map.Base.drawTreeWith (just now deprecated from the public API).
23:33:08 <dfeuer> ertesx, I'd prefer if drawTree, drawTreeWith, valid, and everything else having to do with Data.Map debugging were stripped out of Data.Map.Base and put in Data.Map.Internal.Debug (or whatever).
23:35:22 <ertesx> cocreature: anything particular you'd like to do?  to prevent conflicts
23:35:37 <cocreature> dfeuer: btw, thanks for the work you’re doing on containers
23:36:02 <dfeuer> You're welcome, cocreature.
23:36:14 <dmj> ertesx: don't think unfold will work for rose trees... but there is an unfoldForest
23:36:37 <ertesx> dmj: note that you're not unfolding the tree, you're unfolding frames
23:37:15 <ertesx> dmj: so your unfold most likely looks more like a list unfold
23:37:42 <cocreature> ertesx: probably not in the next two days (busy with exams). I’ll just look at what you have already done when I get to it
23:39:49 <ertesx> dfeuer: from which branch should i work?
23:39:59 <dfeuer> ertesx, work off master.
23:40:07 <dfeuer> For now.
23:40:19 <dmj> ertesx: we'll have to pick this up later, late here. Thanks for recommendations, will ponder
23:46:11 <dfeuer> ertesx, cocreature, there are a number of internal functions in Data.Sequence.Base that I did not expose, because I didn't want to take the time and energy to try to see how doing so would affect the inliner. If y'all want to investigate that and figure out if some of the key FingerTree operations can be exported, that'd be great.
23:56:51 <cocreature> dfeuer: tbh I think exposing internal functions is not that important. it’s more about importing constructors. if a function I need is not exposed I can just copy it in my own source but if the constructors are not exposed you can actually get stuck and be unable to write some function without first upstreaming changes.
23:56:55 <cocreature> but I’ll take a look
