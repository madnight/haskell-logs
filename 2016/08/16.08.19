00:02:30 <anohigisavay> HallaSurvivor: if you are comfortable with MonadComprehensions then [x|p] :: (Maybe TypeofX)
00:03:00 <Axman6> heh, nice
00:04:11 <HallaSurvivor> anohigisavay, any particularly good links for learning about this black magic?
00:04:28 <HallaSurvivor> purely for curiosity sake
00:05:44 <MarLinn> HallaSurvivor you can learn a lot by reading about language extensions in the ghc docs
00:05:46 <anohigisavay> HallaSurvivor: sorry i don't. but if you know how to work with lists as monads then it's just obvious
00:06:29 <liste> :t guard
00:06:30 <lambdabot> Alternative f => Bool -> f ()
00:06:52 <anohigisavay> it's just list comprehension for any monad
00:07:40 * hackagebot glirc 2.9 - Console IRC client  https://hackage.haskell.org/package/glirc-2.9 (EricMertens)
00:07:40 * hackagebot servant-auth-cookie 0.3.1 - Authentication via encrypted cookies  https://hackage.haskell.org/package/servant-auth-cookie-0.3.1 (zohl)
00:09:20 <fProgrammer> quick question: I am trying to write instance to serialize a value of type SVM, but this type SVM is a binding to C library (i.e. libsvm for support vector machine, machine learning), link to bindings: https://github.com/tanimoto/bindings-svm/blob/master/src/Bindings/SVM.hsc  .  How do I proceed? 
00:09:57 <HallaSurvivor> anohigisavay, I'll google it! Thanks for bringing it up, though :D
00:10:03 <rajesh_> Could somebody point me to concurrent data structures implementations in haskell. I'm looking for already existing implementations.
00:10:10 <anohigisavay> HallaSurvivor: you're welcome :)
00:11:29 <fProgrammer> anyone?
00:12:10 <cocreature> rajesh_: there is https://hackage.haskell.org/package/stm-containers-0.2.14
00:12:34 * hackagebot mysql-haskell 0.2.0.0 - pure haskell MySQL driver  https://hackage.haskell.org/package/mysql-haskell-0.2.0.0 (winterland)
00:15:56 <Axman6> fProgrammer: it doesn't look like that library gives you the ability to retrieve a haskell value of the C svm objects, so it might not be easily possible
00:17:12 <fProgrammer> Axman6: yes I noticed, I am afraid I will have to look for something else, thanks anyway
00:18:42 <pavonia> I'll reask my question from yesterday: Why does withCAString use this weird loop internally instead of using withArray0 the same way withCWString does? Is there a subtle difference I cannot spot? https://hackage.haskell.org/package/base-4.9.0.0/docs/src/Foreign.C.String.html#withCAString
00:22:13 <cocreature> pavonia: I don’t think so. withArray0 calls pokeArray0 which then uses basically the same loop. I would assume that it’s for performance reasons (not sure why it is then not used in withCWString) or it is simply an oversight/grew that way for historic reasons
00:23:16 <pavonia> Yeah, maybe the latter
00:24:11 <cocreature> then again if you care about performance maybe you shouldn’t be using string in the first place :)
00:25:36 <freyr> Hi. I have a list of strings and a function of type ``string -> IO int''. How can i map over this list to obtain string of ints? Thanx
00:25:58 <pavonia> cocreature: What would you suggest instead if you have to call a function that takes Ptr CChar/Ptr CWchar?
00:26:06 <Koterpillar> :t mapM -- freyr
00:26:07 <Axman6> freyr: mapM
00:26:07 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
00:26:24 <cocreature> pavonia: I just use Text for everything that’s actually text and ByteString for bytes
00:27:23 <pavonia> But that wouldn't be a performance improvement if you do have to do the conversion anyway, would it?
00:28:02 <Axman6> the conversion from Text to Ptr CChar or Ptr WCChar is likely to be more effiecient than from String
00:28:09 <cocreature> pavonia: well walking through a Text can be a lot faster than walking over a string since you don’t need to do pointer chasing
00:32:20 <pavonia> ByteString already hase some functions working on Ptr, maybe converting the Text to ByteString and using the pointer functions then is indeed more efficient
00:33:04 <cocreature> pavonia: withCStringLen from Data.Text.Foreign does exactly that. it firstf calls encodeUtf8 and then uses one of the bytestring pointer functions
00:33:14 <pavonia> Alignment for CWchar could be a problem, though
00:33:17 <saurabhnanda> ReinH, ReinH_ around?
00:33:18 <Axman6> well, with Text you can use things like text-icu to convert directly from the UTF16 encoded Text to the ASCII or whatever (IIRC anyway)
00:33:22 <ongy> can I tell cabal to only build a binary, when a flag is given?
00:33:57 <saurabhnanda> ReinH, ReinH_: Here's a longer version of my rant about isomorphism, and why it's not always a good thing -- https://www.reddit.com/r/haskell/comments/4ye5yy/if_classyprelude_is_a_good_idea_should_one_be/d6nseon
00:33:59 <Axman6> ongy: yes, see the cabal buildable option and the section on flags
00:34:10 <Guest789233> I have a Megaparsec parser which tries to parse strings like "[a,b,c]" into a list of expressions (listElements = bracks $ expression `sepBy` pcomma). This works all fine but now I'd like to allow trailing commas, like "[a,b,]". Preceeding "expression" with "optional" won't do the trick as I'll end up with maybe. Is there a way to tell Megaparsec "try to parse it, if it doesn't work just stop it alltogether"?
00:35:46 <saurabhnanda> btw, does anyone know *why* JSON coding/decoding has been exposed to application authors as a Monad in Aeson?
00:36:25 <Axman6> you mean the parsers?
00:36:38 <pavonia> cocreature: Ah, I didn't know about that module, thanks!
00:37:05 <Axman6> pavonia: you might want to check out https://hackage.haskell.org/package/text-icu-0.7.0.1/docs/Data-Text-ICU-Convert.html too
00:38:12 <pavonia> Yup, thanks
00:46:27 <saurabhnanda> newbie question. How do I declare a NonEmpty list?
00:46:40 <saurabhnanda> this is not working -- let x = [1] :: NonEmpty Int
00:46:56 <liste> saurabhnanda: it's a different type
00:47:02 <cocreature> either enable -XOverloadedLists or use 1 :| []
00:47:18 <cocreature> NonEmpty is basically a tuple of a single element and a normal list
00:47:34 <saurabhnanda> how is one supposed to read/grok it's constructor ==> data NonEmpty a = a :| [a]
00:47:55 <cocreature> saurabhnanda: :| is just a data constructor
00:48:04 <cocreature> data NonEmpty a = Cons a [a] if that’s easier for you to read
00:48:22 <cocreature> now replace Cons by :| and make it infix and you have the definition in Data.NonEmpty
00:48:50 <saurabhnanda> if I need to prepend an element to a NonEmpty, can I use x :| y ?
00:49:05 <saurabhnanda> and what's the equivalent of [x] ++ [y] with NonEmpty?
00:50:31 <saurabhnanda> prepend is <|
00:50:41 <cocreature> use the semigroup instance
00:50:45 <cocreature> for ++
00:52:14 <saurabhnanda> :t (++)
00:52:15 <lambdabot> [a] -> [a] -> [a]
00:52:38 <saurabhnanda> :t (<>)
00:52:39 <lambdabot> Monoid m => m -> m -> m
00:52:46 <cocreature> that’s the wrong <>
00:52:51 <cocreature> you need Semigroup m => m -> m -> m
00:53:02 <cocreature> you can’t make NonEmpty a monoid
00:53:57 <saurabhnanda> cocreature: right, that's the core different between a Monoid and a Semigroup. Absence of an empty state.
00:54:05 <saurabhnanda> :t (Data.Semigroup.<>)
00:54:07 <lambdabot> Data.Semigroup.Semigroup a => a -> a -> a
00:54:37 <saurabhnanda> wow, using NonEmpty is going to be really painful. It's a **completely** different type, with it's own world.
00:55:02 <srhb> saurabhnanda: If your problem requires nonempty, things should be a lot _less_ painful :-P
00:55:10 <srhb> Otherwise you'd have to encode the invariant everywhere
00:55:31 <saurabhnanda> how many different API surfaces will one have to learn
00:55:53 <cocreature> a lot :)
00:55:55 <saurabhnanda> why can't it just work (tm) with (:) for prepending and (++) for mappending
00:56:05 <liste> saurabhnanda: Monoid, Semigroup etc. are good ways to work with both lists and NELs
00:56:19 <cocreature> Monoid isn’t :)
00:56:40 <liste> yeah, NEL's not a monoid. many other types ore though
00:56:53 <saurabhnanda> If some parts of my code require nullable lists, and some require non-nullable lists, which data-type/container would you recommend?
00:57:14 <saurabhnanda> is there anything which can use the same bunch of functions for core operations?
00:57:17 <srhb> saurabhnanda: Using both and converting when needed, making sure invariants stick.
00:57:20 <saurabhnanda> and can work with Traversable, etc as well?
00:58:19 <saurabhnanda> so a Semigroup seems to be a foldable and a traversable. which is good.
00:59:01 <cocreature> no?
00:59:07 <cocreature> a nonempty list is foldable and traversable
00:59:10 <cocreature> semigroups aren’t
00:59:15 <cocreature> at least not in general
01:01:10 <saurabhnanda> and brilliant. Control.Lens also defines <|
01:02:00 <saurabhnanda> yet more namespacing.
01:02:16 <saurabhnanda> because Haskell can't figure out which <| I mean given the surrounding context.
01:02:19 <srhb> saurabhnanda: Isn't it the same <| ?
01:02:30 <saurabhnanda> :t Control.Lens.<|
01:02:32 <lambdabot> parse error on input ‘Control.Lens.<|’
01:02:39 <saurabhnanda> :t (Control.Lens.<|)
01:02:41 <lambdabot> Cons s s a a => a -> s -> s
01:02:43 <srhb> Or I imagine the Lens one is at least general enough to work
01:03:01 <saurabhnanda> let me hide and try.
01:03:08 <cocreature> srhb: no iirc lens removed support for NonEmpty because there were some weird problems but I forgot what they were
01:03:12 <srhb> Ah
01:03:29 <saurabhnanda> not working -- import Data.List.NonEmpty hiding (<|) 
01:03:35 <saurabhnanda> how do I hide an infix operator?
01:03:40 <srhb> saurabhnanda: More parens
01:03:42 <Axman6> ((<|))
01:04:17 <saurabhnanda> need a PhD to read this type error now.
01:04:20 <saurabhnanda> retreat.
01:04:21 <saurabhnanda> Plan B.
01:04:56 <srhb> saurabhnanda: I think you're panicking a bit now :-P
01:06:32 <saurabhnanda> brilliant -- cons is also taken by THREE different libraries. Aargh!
01:06:46 <saurabhnanda> Plan C
01:07:14 <nshepperd> hide all of the (<|)s and make your own
01:09:25 <srhb> cocreature: FOund it: https://github.com/ekmett/lens/issues/636
01:09:26 <saurabhnanda> refuses to compile -- http://lpaste.net/edit/178425
01:10:10 <srhb> saurabhnanda: Your nonempty is a list of list now
01:10:17 <srhb> saurabhnanda: Is that your intention?
01:10:37 <saurabhnanda> nope
01:10:41 <saurabhnanda> just caught that. thanks
01:11:50 <saurabhnanda> okay my types itself were wrong -- list of list
01:15:02 <saurabhnanda> this **needs** to be easier to use
01:18:58 <saurabhnanda> sorry. dog sat on the laptop.
01:19:20 <ongy> when I use Debug.Trace.trace in something like: 'let y = (\x -> trace (show x) x) $ z' and the trace is printed multiple times, does that imply that y is evaluated multiple times? And does this imply something about the evaluation of z?
01:20:54 <saurabhnanda> right, so all this stuff **needs** to be easier to use. So much power, but so tough to use. Does it have to be tough? Or is because no one is thinking about programmer happiness?
01:23:23 <opqdonut> ongy: yes, y is evaluated multiple times. z might not though
01:24:12 <opqdonut> ongy: for instance, if "f z = let y = (\x -> trace (show x) x) $ z in ..." and we call f repeatedly on the same value z, z will get evaluated only once
01:24:17 <opqdonut> (or rather, at most once)
01:27:09 <saurabhnanda> hmm, got NonEmpty to work, but don't have a good feeling about this.
01:28:15 <saurabhnanda> time to test the haskell promise. If it compiles, it will run correctly. Let's see...
01:29:01 <merijn> So, with Levity polymorphism in GHC8, what is the kind (or is it type?) of TYPE?
01:29:17 <merijn> "TYPE :: Levity -> ???"
01:30:12 <saurabhnanda> anyone here contributing to the Haskell2020 project?
01:30:19 <saurabhnanda> is compiler speed a goal?
01:31:00 <merijn> saurabhnanda: What does compiler speed have to do with Haskell Prime?
01:31:09 <merijn> Compiler speed is a matter of implementation, not specification
01:31:46 <saurabhnanda> so, then not Haskell Prime. Is there something similar for GHC?
01:31:55 <saurabhnanda> where compiler speed is an appropriate concern?
01:32:36 <saurabhnanda> compiler speed, more helpful type messages (eg. Rust & Elm)
01:33:09 <saurabhnanda> IDE support. Refactoring support (and one needs to do a *lot* of refactoring in Haskell)
01:33:35 <merijn> Compiler speed is being looked into, but in general there's only a small number of people hacking on GHC and work is prioritised by what's important to them
01:33:50 <saurabhnanda> just wondering -- is it possible to pledge monetary support to some of these causes, and request the right people with the right knowledge to solve them?
01:34:12 <merijn> The 2 main ways you could get work like this done is: 1) hire someone to work on it or 2) start hacking yourself
01:34:36 <saurabhnanda> is there some sort of consortium or foundation for Haskell
01:34:37 <merijn> saurabhnanda: The point is that almost everyone who is actually getting paid while hacking on GHC is already more than overburdened
01:34:42 <saurabhnanda> that one could support?
01:34:50 <saurabhnanda> and vote with money, and not just rants.
01:35:13 <saurabhnanda> Mozilla Foundation equivalent
01:35:15 <merijn> saurabhnanda: I don't think there's a real consortium, the main issue is lack of manpower
01:35:31 <mpickering> ^ most people work on GHC in their spare time
01:36:19 <saurabhnanda> what is it in the Ocaml world? INRIA is the de-facto consortium?
01:36:37 <mpickering> In the ocaml world the main development is driven by ocaml labs in cambridge
01:36:56 <merijn> mpickering: and Jane Street, I'm guessing
01:37:07 <mpickering> But only about 10 people have commit access to the main compiler code base and progress is generally very slow
01:37:18 <mpickering> yes, they work together
01:37:41 <mpickering> otoh, the compiler is also much simpler 
01:37:48 <mpickering> because it doesn't have as many features
01:38:04 <merijn> FP Complete is occasionally contributing to GHC for clients, afaik
01:38:12 <merijn> And of course they're hacking on cabal
01:38:17 <saurabhnanda> so is Haskell Prime trying to somehow solve the manpower problem as well?
01:38:25 <merijn> saurabhnanda: No
01:38:28 <mpickering> I don't remember fp complete contributing anything major to ghc
01:38:36 <merijn> saurabhnanda: Haskell Prime tackles one issue, specification of the Haskell language
01:38:55 <saurabhnanda> hmm, is that the largest issue with Haskell right now? 
01:39:15 <merijn> saurabhnanda: Well, everyone complains about needing X extensions to write "real code"
01:39:28 <merijn> And lack of specification makes it hard for alternative implementations to implement extensions
01:39:29 <saurabhnanda> Isn't tooling, library standardization, compiler speed, etc. the bigger problems?
01:39:44 <mpickering> surely the largest issue is the community fragmentation 
01:39:47 <merijn> saurabhnanda: The people who consider those things issues are not contributing.
01:40:03 <merijn> saurabhnanda: What gets contributed gets pushed forward
01:40:10 <saurabhnanda> brb, call.
01:40:42 <merijn> saurabhnanda: The people who care about standardisation/specification are actively pushing those things. Unless people who care about tooling start actively pushing tooling as much it won't happen
01:40:54 <merijn> (see, for example, stack/haskell-ide being pushed)
01:41:06 <merijn> mpickering: Is it really? How so?
01:41:30 <mpickering> that's how it seems to me anyway
01:42:43 <merijn> mpickering: People want different things, and that will increase as long as the userbase goes up
01:43:01 <merijn> mpickering: The only way to have an undivided userbase is to have one so small it's dying
01:43:17 <merijn> mpickering: Hell, look at C, python, or JS ecosystems
01:44:41 <merijn> @remember NickLockwood The hardest problem in computer science is fighting the urge to solve a different, more interesting problem than the one at hand.
01:44:41 <lambdabot> I will remember.
01:45:37 <mpickering> It's possible to want different things in a way which doesn't cause huge rifts , the way which is has been gone about is needlessly aggressive 
01:46:17 <EvilMachine> Hi. How come I can’t write an instance of Monoid for (IO MyType) ?
01:46:45 <merijn> EvilMachine: Probably because you're getting the syntax wrong, because that's definitely possible :)
01:46:59 <merijn> EvilMachine: lpaste your code?
01:47:12 <EvilMachine> merijn: instance Monoid (IO MyType) where …
01:47:24 <EvilMachine> merijn: That’s where GHC complains.
01:48:28 <merijn> EvilMachine: It would be helpful to show GHC's actual error :)
01:48:35 <EvilMachine> merijn: one second
01:49:20 <lpaste> EvilMachine pasted “GHC error” at http://lpaste.net/178435
01:50:09 <EvilMachine> merijn: ↑
01:50:26 <merijn> Oh, right :)
01:50:40 <merijn> EvilMachine: The report is overly conservative in what it allows for instance declarations
01:51:09 <EvilMachine> merijn: So… FlexibleInstances? I thought that causes ambiguities…
01:51:12 <merijn> So you're only allowed to have a single type constructor followed by variables. You have two options: 1) "instance Monoid a => Monoid (IO a) where"
01:51:17 <merijn> 2) FlexibleInstances
01:51:24 <merijn> What? No, FlexibleInstances is fine
01:51:43 <merijn> OverlappingInstances causes ambiguities
01:52:35 <merijn> I strongly suspect FlexibleInstances and FlexibleContexts to go into Haskell Prime
01:52:37 * hackagebot ghc-typelits-extra 0.2 - Additional type-level operations on GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-extra-0.2 (ChristiaanBaaij)
01:52:37 <EvilMachine> merijn: (Monoid a => Monoid (IO a)) doesn’t look sensible to me. And it would not do what I wanted anyway. :)
01:52:47 <EvilMachine> merijn: :)
01:52:50 <merijn> EvilMachine: Why not? It's a perfectly fine monoid
01:53:09 <merijn> "mempty = return mempty; mappend = liftA2 mempty"
01:53:33 <EvilMachine> merijn: Yes, since <> is just >> or something like that… you’re right.
01:53:39 <merijn> If that doesn't do what you want, I'm curious what your monoid instance looks like
01:53:43 <Athas> Is it still associative in the presence of exceptions?
01:54:05 <merijn> Athas: All bottoms are identical in denotational semantics, so yes
01:54:29 <Athas> Is an exception bottom in IO?  You can handle them.
01:54:34 <jle`> even if not, it should still be associative
01:54:41 <merijn> Athas: Exceptions have the denotational semantics of bottom
01:54:46 <Athas> Yeah, I think so.  Maybe you can play tricks with threading?
01:55:00 <Athas> merijn: has someone actually written a denotational semantics for IO?
01:55:05 <EvilMachine> merijn: It’s not what I want to do here though. (The MyTypes are maps of trees that need to be deep-united into one map of trees. Probably something with functors, now that I think of it.) 
01:55:15 <merijn> Athas: No, which is why the ability to handle them is irrelevant :)
01:55:26 <jle`> i'm not even sure what it would even make sense for (x >> y) >> z to not be x >> (y >> z) for IO
01:55:28 <jle`> hm
01:55:41 <jle`> still thinking
01:55:54 <jle`> they both should just be evaluated to the same program
01:55:58 <jle`> and program tree
01:56:19 <jle`> exceptions shouldn't make any difference
01:56:29 <merijn> Athas: After talking to Conal I'm not convinced a denotational semantics of IO could possible exist
01:56:31 <Athas> I think you are correct.
01:57:01 <jle`> IO actions that throw exceptions are something that happens in the context of executions, not in building the program
01:57:22 <jle`> esp since (>>) is like (*>) so the structure of its results can't depend on any IO results
01:57:24 <EvilMachine> merijn: And the RealWorld should be deterministic too… :D
01:57:25 <merijn> jle`: Well, you can throw exceptions outside of IO actions
01:57:35 <merijn> jle`: Trivially, even
01:57:43 <jle`> yeah, i guess we are discouting that x, y, and z are themselves bottom
01:57:45 <merijn> jle`: So your IO could evaluate to exception
01:57:46 <jle`> *discounting
01:57:58 <jle`> but most Monoid instances in Haskell are broken if the arguments are bottom anyway
01:58:07 <merijn> But that case is solved by the fact that exceptions are bottom :)
01:58:08 <jle`> and Monad instances
01:58:20 <Athas> Right, but IO is special in that you often use IO for its ability to work with bottom values.
01:58:44 <merijn> jle`: Fast and Loose Reasoning is Morally Correct!
01:58:54 <jle`> maybe, but that's different than having IO actions that are themselves bottom
01:59:47 <jle`> we usually talk about exceptions etc. in the context of executing IO actions, not in evaluating them
02:09:13 <Squarism> so there is no mappend for Set?
02:09:22 <Squarism> its not a monoid? 
02:10:07 <merijn> Squarism: huh? There is a monoid for set
02:10:20 <merijn> "Ord a => Monoid (Set a)"
02:10:34 <dramforever> > Data.Set.fromList [1,2,3] <> Data.Set.fromList [2,5,6] -- Like this
02:10:36 <lambdabot>  fromList [1,2,3,5,6]
02:10:46 <Squarism> oh .. it is then
02:11:06 <Squarism> but no (++) atleast
02:11:13 <merijn> ++ is lists only
02:11:16 <merijn> :t (++)
02:11:17 <lambdabot> [a] -> [a] -> [a]
02:11:21 <dramforever> ...What's so bad about <> ?
02:11:24 <merijn> The operator for mappend is <>
02:11:27 <merijn> :t (<>)
02:11:28 <lambdabot> Monoid m => m -> m -> m
02:11:42 <merijn> > getSum $ 5 <> 10
02:11:44 <lambdabot>  15
02:12:17 <Squarism> what do i need to import to use (<>) for Set?
02:12:37 <liste> @index Monoid
02:12:37 <lambdabot> Data.Monoid, Prelude, System.Console.Terminfo.Base, System.Console.Terminfo
02:12:46 <liste> Squarism: what GHC version?
02:12:51 <Squarism> 7.10
02:13:14 <liste> Squarism: Data.Monoid
02:13:18 <Squarism> worked fine
02:13:30 <liste> I guess only `mappend` is in Prelude
02:13:40 <liste> <> is an alias for that
02:14:47 <Squarism> do poeple avoid Set? everywhere you look its just list list list
02:15:05 <liste> Squarism: depends on the use case
02:15:10 <liste> list is good for iteration
02:15:50 <saurabhnanda> back from the call.
02:16:52 <liste> is collecting a list + nub slower than using a Set?
02:17:01 <merijn> liste: nub is quadratic
02:17:08 <liste> merijn: oh, ofc (:
02:17:15 <merijn> Which is pretty terribad
02:17:56 <jle`> list and set are very different
02:18:21 <jle`> i can't imagine too many overlapping use cases
02:19:14 <jle`> (but then again my imagination has been known to be selectively bad when it helps make a point)
02:19:17 <saurabhnanda> so, no one's really looking at the tooling problem? Except probably chrisdone and intero?
02:20:09 <merijn> saurabhnanda: Lots of people are working on tooling in the best way they see fit
02:20:39 <haskell645> Hi.  I'm trying to get Haskell working on my Fedora 23 system, and cabal is balking at the first step: http://lpaste.net/178442
02:21:03 <haskell645> What am I doing wrong here?
02:21:12 <Squarism> haskell645, get stack 
02:21:16 <saurabhnanda> is there no haskell dictator?
02:21:25 <merijn> haskell645: Rerun with -v3
02:21:28 <saurabhnanda> benevolent dictator?
02:21:59 <srhb> saurabhnanda: Nope.
02:22:00 <merijn> saurabhnanda: No, the original report was drafted by a committee, as is the new Prime report. There have been multiple implementations
02:22:21 <merijn> So before the current GHC hegemony there wasn't even a "standard" compiler/implementation
02:22:21 <liste> saurabhnanda: cabal-install is getting more and more awesome with the new nix-like system
02:22:33 <maerwald> haskell is non-enforced, slowly decaying democracy
02:22:45 <merijn> maerwald: Why decaying?
02:23:00 <saurabhnanda> isn't SPJ the default dictator?
02:23:03 <maerwald> merijn: because of haskell report vs crapload of GHC extensions
02:23:12 <merijn> saurabhnanda: oh god no, he really wouldn't want to be
02:23:22 <haskell645> merijn, I got a little bit further: http://lpaste.net/178443
02:23:27 <merijn> maerwald: I fail to see how that relates to democracy?
02:23:43 <maerwald> merijn: well, the committee doesn't decide on GHC extensions, does it?
02:24:05 <srhb> What committee? Prime?
02:24:05 <maerwald> basically anything can get into GHC as an extensions even if it broken (and we have those)
02:24:19 <merijn> haskell645: Oh, you don't have Cabal the library installed
02:24:37 <saurabhnanda> so, who's the most ambitious haskell hacker who knows his stuff around the codebase?
02:24:47 <haskell645> merijn, I have simply run `dnf install cabal-install` -- is there more that needs to be done?
02:24:48 <merijn> maerwald: So? Why do GHC extensions need to be democratically decided?
02:24:57 <dramforever> merijn: I thought the command was cabal install Cabal
02:24:59 <saurabhnanda> no one ever wanted to fork haskell and enforce his/her opinions on it and bless things as the Right Way (tm)
02:24:59 <srhb> saurabhnanda: Which codebase?
02:25:03 <merijn> haskell645: cabal-install is the the cabal *program*, not the library
02:25:09 <srhb> saurabhnanda: GHC?
02:25:12 <merijn> haskell645: Cabal is the library
02:25:15 <maerwald> merijn: it doesn't need to be, but if it isn't... then it isn't democratic either as I said
02:25:18 <merijn> haskell645: So "cabal install Cabal"
02:25:23 <saurabhnanda> GHC + standard libraries 
02:25:26 <saurabhnanda> GHC with batteries
02:25:27 <haskell645> Sorry, I'm cluless here, am not at all familiar with this system.
02:25:34 <srhb> saurabhnanda: There's a core libraries committee
02:25:35 <merijn> maerwald: You said Haskell is not democratic
02:25:44 <merijn> maerwald: Whereas now your complaint is that GHC is not democratic
02:25:51 <haskell645> merijn, that was my first command: http://lpaste.net/178442
02:25:51 <srhb> saurabhnanda: https://wiki.haskell.org/Core_Libraries_Committee
02:26:03 <merijn> haskell645: oh, hmmm
02:26:08 <merijn> haskell645: Which version of GHC?
02:26:13 <srhb> saurabhnanda: GHC is just the regular contributors you can find in the commits :)
02:26:23 <haskell645> 7.8.4
02:26:27 <saurabhnanda> no committe... everything seems like a "design by committee" to me right now. 5 different ways to do the same thing. each having subtle differences, not large enough in practice.
02:26:35 <merijn> Does 1.24 work with 7.8?
02:26:38 <merijn> I'm not sure
02:26:39 <srhb> saurabhnanda: In base?
02:26:50 <saurabhnanda> everywhere!
02:26:55 <saurabhnanda> String handling
02:26:56 <haskell645> I've just installed ghc and cabal from the Fedora package manager
02:26:58 <merijn> saurabhnanda: tbh, the haskell2010 report was designed by committee and it's pretty good
02:26:59 <srhb> saurabhnanda: Well, everywhere is made by everyone! :-P
02:27:03 <saurabhnanda> Exceptions, Errors, Either
02:27:14 <merijn> The Scheme report was designed by a committee, also pretty good
02:27:16 <saurabhnanda> Monad Transformers vs Free monads vs Effects (?)
02:27:28 <maerwald> merijn: uhm yes. If the de-facto standard compiler that's used by 99% of the whole ecosystem decides what to do, it technically affects the perceived "haskell language". That's the point. The haskell report isn't the only thing anymore that defines haskell. Even if you claim that's technically the case.
02:27:32 <maerwald> In practice, it isn't.
02:27:47 <saurabhnanda> Records
02:27:49 <srhb> saurabhnanda: Choice isn't bad, and there's no uniform opinion on the superior solution. One of the strengths of Haskell is that you can just grab another library since so much is _just that_ - a library.
02:27:54 <saurabhnanda> Lenses -- how many implementations do we have?
02:27:54 <srhb> saurabhnanda: Records are bad, yes.
02:28:03 <merijn> Anyway, I'm not even convinced a democratic language is necessarily a good thing
02:28:20 <haskell645> Ok ... what is the "official" way to successfully run GHC and its tools (for a beginner) on Fedora?  I was hoping using the Fedora packages would work, but the signs are not promising...
02:28:20 <srhb> saurabhnanda: One meaningful, really. That was a relevant question some time ago.
02:28:37 <ongy> srhb: why are Records bad?
02:28:41 <maerwald> or we could put it this way: GHC is the dictator ;)
02:28:44 <ongy> outside of all their limitations
02:29:01 <merijn> haskell645: On linux I personally just grab the binary distribution of GHC and install it. But whether that works depends on how comfortable you are with that sorta stuff :)
02:29:05 <saurabhnanda> srhb: good thing then. But how does a newbie not get confused when he searches on google and gets hold of some other lens library? (happened with me).
02:29:52 <saurabhnanda> my latest gripe -- NonNull vs NotEmpty
02:29:53 <maerwald> srhb: except it isn't that easy :P
02:30:04 <haskell645> merijn, any idea how well the Fedora packages are curated?  It seems a bit of a disaster if nothing actually works out of the box, which is where I seem to be...
02:30:30 <maerwald> libraries are used throughout the ecosystem. Even if you don't want to use, say... mtl, and go for freer or extensible-effects, you will still be widely exposed to mtl.
02:30:30 <saurabhnanda> name clashes between libraries that you would use end-up using together. And have to resort to highly irritating namespacing and hiding.
02:30:59 <merijn> saurabhnanda: tbh, I think ClassyPrelude is a bad idea, so Yesod forcing it on newbies is a bad approach by Yesod.
02:31:01 <dramforever> haskell645: Consider stack ( haskellstack.org ), which is the one everyone seems to be using now
02:31:11 <maerwald> same with lens or th: even if you don't like it, you will be exposed to it
02:31:21 <merijn> maerwald: So?
02:31:22 <dramforever> kinda like the rvm (ruby), nvm (nodejs) situation
02:31:26 <maerwald> merijn: ?
02:31:27 <srhb> saurabhnanda: Yes, deciding which solution you like can be difficult. :)
02:31:42 <srhb> saurabhnanda: Especially as a beginner.
02:31:49 <saurabhnanda> and I was under the impression that Snoyberg was the one taking things forward and making sense of using the Haskell ecosystem (with the number of libraries and frameworks that he has written).
02:31:59 <merijn> maerwald: "You'll be exposed to it", well, yes. What else did you expect? Should people implement everything exponentially many times to work with your pet library/approach?
02:32:01 <maerwald> merijn: I was replying to srhb that the "just make your library choice" isn't all of the story
02:32:11 <srhb> saurabhnanda: Some people that work purely in the Yesod ecosystem may see it that way.
02:32:14 <dramforever> haskell645: Says the home page of stack, "It is intended to be easy to use for newcomers, while providing the customizability and power experienced developers need."
02:32:15 <haskell645> dramforever, I know absolutely zero about stack.  Will it actually just work?
02:32:19 <maerwald> merijn: no, that's not what I said
02:32:44 <saurabhnanda> ah -- Cabal vs Stack... the **very** first thing that I ran into. 
02:32:53 <saurabhnanda> Now I have to throw Nix into the mix because of reflex-frp
02:32:55 <maerwald> it's cabal-install vs stack, if any
02:32:59 <maerwald> stack uses cabal
02:33:11 <merijn> maerwald: I'm not saying that's what you said. But clearly you think being exposed to that is a bad thing. So what possible solution exists, besides exponentially reimplementing?
02:33:15 <srhb> saurabhnanda: And people prefer different solutions there, too. What can you do? Censor one or more of them? :-P
02:33:27 <maerwald> merijn: none
02:33:43 <maerwald> it's ecosystem "democracy"
02:33:58 <dramforever> haskell645: I could have said yes, but I can't guarantee anything
02:34:04 <maerwald> people like type FilePath = String, so we are stuck with it, because it's all over base
02:34:04 <saurabhnanda> not censor. But have a consistently designed primary programmer experience.
02:34:05 <saurabhnanda> Bless it.
02:34:09 <saurabhnanda> Make it the default.
02:34:19 <srhb> saurabhnanda: Yuck. :(
02:34:46 <srhb> saurabhnanda: Now you get to choose which one of those everyone prefers.
02:34:49 <merijn> saurabhnanda: See, I don't use any of the things you've mentioned and I'd be really annoyed if, e.g., stack and ClassyPrelude get pushed on me
02:34:58 <saurabhnanda> srhb: no, it's not yuck. It's the ONLY thing that cane make sense of this bazaar. It needs some sort of "standardization"
02:35:30 <srhb> saurabhnanda: I disagree. And I think it's a fundamental disagreement, so I will leave it at that. :)
02:35:34 <zomg> saurabhnanda: it seems all of your problems with haskell are actually problems with pretty much every language out there :)
02:35:47 <saurabhnanda> zomg: why do you say that?
02:35:51 <merijn> saurabhnanda: Says you, yet all of the things, e.g. Snoyberg would want to standardise on is exactly the same stuff that annoys me
02:35:57 <ongy> saurabhnanda: you are bringin gup an argument that has existed for the longest time int the context of linux. Most open source communities (especially with people working on it kind of as hobby) like to have choice
02:35:57 <maerwald> merijn: but one has to realize that "choice" in haskell in terms of libraries may be harder than you think, because you have more indirect dependencies than in a lot of other languages 
02:36:20 <zomg> saurabhnanda: well, at least most of them seem to revolve around the fact that there's a lot of different choices and opinions, there is no specific standard on certain things
02:36:23 <haskell645> I see you guys talking about standardisation ... one thing Haskell really seems to need, speaking as a dabbler, is it needs for the distribution packages to JUST WORK.
02:36:31 <zomg> which is basically how things are in most programming languages that are at least somewhat popular
02:36:43 <maerwald> so if you really want to do something different, you _will_ end up with a lot of wrapper code and even fork libraries and reimplement functionality
02:37:09 <saurabhnanda> okay screw the standard. But in most other languages communities have clearly identified opinion about which approach is better. Most tutorials, most libraries work with that opinion. 
02:37:10 <dramforever> haskell645: I thought they (at least Fedora) have GHC in there package system because they have xmonad pandoc etc.
02:37:39 <zomg> saurabhnanda: there are those about haskell as well, for example stack is being mostly preferred over cabal now as far as I can tell
02:37:40 <saurabhnanda> haskell645: just use stack. I learnt it the hard way.
02:37:46 <srhb> saurabhnanda: In my experience, there are sub-communities that prefer certain things (because they exist because they prefer certain things)
02:37:47 <ongy> haskell645: but that's mostly on the side of distributions (especiall redhat/debian) that want to be stable
02:38:02 <srhb> saurabhnanda: But #haskell is definitely a melting pot. :)
02:38:04 <zomg> saurabhnanda: but haskell is growing and there's a lot of new stuff (stack being one) coming around, which is probably why you might find conflicting info 
02:38:44 <saurabhnanda> i just feel like asking, "Who's the president of Haskell -- I'd like to have a conversation with him/her"
02:38:47 <srhb> A few years ago people were discussing which streaming IO library was The Right One
02:38:53 <haskell645> Huh.  Guess it's time to ensure that stack is in Fedora proper, not a radom repo on the side!  Also Haskell seems to keep breaking stuff, but maybe that's just cabal?
02:39:07 <zomg> saurabhnanda: python is the only language I can think of where there's some kind of one person who says how things are done :)
02:39:15 <saurabhnanda> Go Lang
02:39:33 <ongy> haskell645: it's ghc/cabal-install with hackage, there is breaking going on. afaik stack with the lts resolvers fixes that, but may not have the latest package
02:39:38 <maerwald> srhb: yeah, but I feel there's no real community workflow wrt such decisions. It's more like open discussion and then "see who does stuff first".
02:39:59 <srhb> I think it's more "which solution ends up being preferred" but yes.
02:40:00 <maerwald> not saying you have that in other languages
02:40:41 <dramforever> Well somebody would need to get nodejs >= v4 into Fedora too
02:40:56 <dramforever> (Experience less than a minute ago)
02:41:21 <haskell645> Who verifies this key fingerprint: C570 5533 DA4F 78D8 664B 5DC0 5751 5968 9BEF B442 ?
02:41:44 <saurabhnanda> when is the next haskell meetup?
02:41:57 <saurabhnanda> HaskConf
02:42:01 <saurabhnanda> HaskellConf?
02:42:07 <saurabhnanda> LambdaConf?
02:42:11 <saurabhnanda> actually, what is it called?
02:42:23 <srhb> saurabhnanda: YOu'll love this: There isn't one blessed conference or a name of such.
02:42:25 <srhb> :-)
02:42:44 <zomg> Considering most languages don't have one either... :x
02:42:53 <maerwald> srhb: I actually don't agree. It's more like "which solution ends up being the most widely used" which _can_ mean that it's preferred, but not necessarily.
02:42:54 <saurabhnanda> who owns the trademark - Haskell?
02:42:56 <srhb> zomg: I know, I thought I was being funny :-P
02:43:02 <zomg> yeah =)
02:43:13 <srhb> saurabhnanda: Is it trademarked?
02:43:26 <saurabhnanda> it should be, if it isn't
02:43:29 <saurabhnanda> I'll trademark it
02:43:36 <saurabhnanda> and bless my own haskell ecosystem
02:43:45 <zomg> Go for it I guess :D
02:43:46 <barrucadu> Good luck trademarking a term that's been in use for decades.
02:43:46 <saurabhnanda> except that I'll need a PhD in category theory to get anything done.
02:44:02 <saurabhnanda> http://lanyrd.com/topics/haskell/
02:44:05 <zomg> I didn't even go to university and I can use Haskell just fine ¯\_(ツ)_/¯
02:44:13 <zomg> ie. I'm dumb
02:44:15 <ongy> barrucadu: good luck arguing with logic in law. especially with things like trademark that you want internationally but are wrt to local laws
02:44:55 <ongy> zomg: I don't thinkg going to uni proves anything different
02:44:58 <maerwald> zomg: s/dumb/not academic/
02:45:14 <intothemountains> Is there a way to access data type attributes with namespaced accessors?
02:45:16 <saurabhnanda> there must be some "seat of power" in haskell
02:45:17 <zomg> maerwald: don't patronize me!
02:45:18 <zomg> lol
02:45:19 <saurabhnanda> who pays for the servers?
02:45:21 <maerwald> :D
02:45:31 <saurabhnanda> who paid for the initial committe to work on the project/
02:45:37 <intothemountains> For some data type Group with a player member, Group.player instead of just player
02:45:48 <intothemountains> Or something similar
02:45:58 <maerwald> zomg: I've been to university and it has mostly been a waste of time with a few exceptions.
02:45:59 <ongy> intothemountains: if you have imported it, you can do qualified imports
02:46:03 <srhb> saurabhnanda: Why is it so hard to accept? :-P
02:46:16 <intothemountains> ongy: What if it is in the same module?
02:46:34 <ongy> then I don't know of any way. Why do you want to do that? coliding names?
02:46:39 <intothemountains> player is too good of a variable name to be a function name :(
02:46:42 <zomg> maerwald: yeah I think I'm far too hands-on oriented with things to really care for it anyway =)
02:47:02 <maerwald> zomg: learning stuff yourself is usually more effective imo (especially when it comes to haskell). The only downside is that you don't see the bigger picture of topics that relate to each other and can get lost in the road of knowledge.
02:47:22 <ongy> intothemountains: you can generally prefix your constructors with something, so make Group.player grPlayer (or even groupPlayer)
02:47:24 <saurabhnanda> srhb: I can't believe no one hold any real power in deciding the fate of haskell.
02:47:35 <intothemountains> ongy: fair enough
02:47:39 * hackagebot ghc-typelits-knownnat 0.2.1 - Derive KnownNat constraints from other KnownNat constraints  https://hackage.haskell.org/package/ghc-typelits-knownnat-0.2.1 (ChristiaanBaaij)
02:47:45 <merijn> saurabhnanda: Power is determined by amount of contributions
02:48:11 <ongy> maerwald: I think uni is quite nice to get you into the right topics and a base to work on. I don't think I would have gotten into haskell if I didn't get it introduced in a course
02:48:39 <zomg> saurabhnanda: most languages evolve on their own from people contributing, or based on groups of people agreeing on some direction on it, where said direction is often based on what people are doing with the language
02:48:50 <maerwald> ongy: Well, I got introduced by someone telling me about it. By the time it came up in uni, I was already doing it for 1+ year.
02:49:05 <ongy> saurabhnanda: at least no strong power, as far as I can tell there's people that can put out a library which finds big adoption because they are known to do good work
02:49:15 <saurabhnanda> so, SPJ? Chrisdone? Snoyberg, etc?
02:49:38 <maerwald> uhm
02:49:40 <merijn> saurabhnanda: Simon Marlow, Austin, etc.
02:49:48 <ongy> maerwald: that also helps. But I'm not sure, if I would have gotten annoyed with it before I got something done (as I did with rust)
02:49:52 <merijn> Chrisdone and Snoyberg don't really contribute to GHC, afaik
02:50:04 <maerwald> and not everyone is a fan of their libraries :P
02:50:11 <saurabhnanda> for me Intero at least got me started with Haskell. 
02:50:28 <srhb> saurabhnanda: Intero doesn't work with Nix :-(
02:50:40 <haskell645> How do I use stack to build an existing tool?  All the instructions seem to be about using stack to build my own projects.
02:50:49 <saurabhnanda> srhb: **you proved my point**
02:50:52 <saurabhnanda> srhb: just use stack. 
02:50:59 <srhb> saurabhnanda: I don't want to use Stack.
02:51:04 <maerwald> yeah, they force tooling on you... 
02:51:04 <saurabhnanda> anyone knows what to do with http://lpaste.net/178451
02:51:12 <saurabhnanda> please force tooling
02:51:16 <saurabhnanda> force one set of tooling
02:51:20 <maerwald> please don't
02:51:20 <saurabhnanda> write all tutorials around that
02:51:23 <maerwald> force APIs
02:51:26 <ongy> no, please don't
02:51:28 <saurabhnanda> explain your design decisions
02:51:35 <ongy> that would be a good point to make
02:51:39 <saurabhnanda> talk about pros & cons
02:51:42 <saurabhnanda> talk about what to use when
02:51:53 <zomg> I'm pretty sure people are already doing that :P
02:52:10 <haskell645> Hmm.  `stack install ...` seems to work?
02:52:11 <saurabhnanda> not everyone can make design decisions like someone who has written core Haskell libraries. What is right is not obvious when you're writing your first project in Haskell.
02:52:12 <ongy> that's done quite often, but often that's in ~1h long talks that only exist as video
02:52:33 <ongy> that's a problem not specific to haskell
02:52:48 <maerwald> cabal is an API and I hope we will never get a second one. What tools you build around that (stack, cabal-install, cabal2nix) is a different thing and should improve user choice
02:52:56 <saurabhnanda> Constraint is no smaller than the instance head -- what does that mean? -- http://lpaste.net/178451
02:52:56 <lyxia> saurabhnanda: if any type implementing ToJSON also implements ToTypedContent, why make a typeclass instead of a simple function toTypedContent :: ToJson a => ...
02:53:43 <haskell645> Oh for FS.  Stack now insists on downloading ghc 7.10.3.  So my distribution install is worthless, just a bootstrap
02:54:26 <saurabhnanda> haskell645: I had to do that THRICE for GHCJS. Welcome to my world of pain. 
02:54:39 <saurabhnanda> haskell645: if you're starting just get through this step, install spacemacs & Intero.
02:54:44 <lyxia> saurabhnanda: For example, Monoid a => Monoid (Maybe a). Instance head is Maybe a, which "contains" a, and we say that a is smaller than Maybe a.
02:54:55 <srhb> saurabhnanda: Just use Nix ;-)
02:55:38 <saurabhnanda> lyxia: okay, I got that. So, my constraint is not narrowing anything down. 
02:55:48 <saurabhnanda> lyxia: but that does not solve my original problem.
02:56:15 <saurabhnanda> How do I write that? // getDownloadR :: Handler J.DownloadResponse 
02:56:32 <saurabhnanda> No instance for (ToTypedContent JsonTypes.DownloadResponse)
02:57:10 <lyxia> saurabhnanda: I think the problem is ill-posed and we should look at what you are trying to do at a higher level.
02:58:43 <saurabhnanda> lyxia: okay, let me explain
02:59:47 <haskell645> saurabhnanda, vim here :(
03:00:05 <saurabhnanda> I'm trying to write a Yesod handler for a JSON endpoint (getDownloadR :: Handler MyTypeWhichImplementsToJson). In the handler I simply "return (x :: MyTypeWhichImplementsToJson)". However, the compiler complains that it can't find an instance for ToTypedContent for MyTypeWhichImplementsToJson.
03:01:52 <saurabhnanda> lyxia: there?
03:02:12 <lyxia> Sorry I gotta go afk right now, I hope someone else can take over.
03:02:37 <saurabhnanda> lyxia: no issues. thanks :)
03:03:34 <Jinxit> in bencoding, 'l' starts a list, and 'e' ends it. "le" == [], "llee" == [[]], and so on. is it possible to write a tail recursive parser for this?
03:04:29 <ongy> saurabhnanda: do you have multiple types that can be passed to your handler, about which you only know that they are an instance of toJson?
03:04:52 <ski> Jinxit : CPS-transform it ?
03:04:58 <saurabhnanda> ongy: please rephrase.
03:05:55 <Jinxit> ski: I haven't really grok'd CPS, got a good reference?
03:06:19 <dramforever> Jinxit: Yes it is possible, because you can use a stack
03:06:59 <dramforever> b: push an empty list onto the stack. e: pop the top of the stack and append to the end of the next-to-top
03:07:15 <ongy> saurabhnanda: I'm wondering if you are putting to much of a constraint on your problem. At the point where you are using it, is the only thing you know about your type, that it implements ToJSON, or do you have a number of types, which each implement ToJSON, but can be infered when you use getDownloadR
03:07:17 <dramforever> Um.. I meant "l" not "b"
03:07:24 <Jinxit> dramforever: but then you can probably overlow it with "lllllll..."
03:07:36 <dramforever> You can always overflow it
03:08:15 <saurabhnanda> ongy: I want to make sure that getDownloadR **always** returns a DownloadResponse. Yesod tutorials always have this signature -- endpointR :: Handler Value -- which loses some amount of type safety.
03:08:24 <Jinxit> hm
03:08:33 <saurabhnanda> ongy: I want my handler to be -- getDownloadsR :: Handler DownloadResponse
03:08:50 <ski> Jinxit : "tail recursive" doesn't mean "runs in constant space"
03:09:01 <Jinxit> yeah you're right
03:09:05 <Jinxit> I wasn't thinking
03:09:12 <dramforever> Perhaps you are worried about too-deep recursion?
03:09:26 <ski> Jinxit : i'm not sure whether just looking for a tail recursive version (which is always possible) is that useful ..
03:09:54 <Jinxit> well, it's not in haskell but another FP language (erlang) where stack overflow could happen and tail recursion is encouraged
03:09:55 <ski> Jinxit : for CPS, you could try "Abstracting Control" and "Representing Control" by Filinski (and Danvy ?)
03:10:03 <Jinxit> but I figured it was interesting enough as a general problem :)
03:10:11 <Jinxit> I'll take al ook
03:10:30 <dramforever> Jinxit: So what's your goal?
03:10:56 <dramforever> Avoid too-deep recursion? Or *just* tail-recursive for the sake of being tail-recursive?
03:11:04 <Jinxit> avoid too-deep recursion
03:12:51 <dramforever> Just build a stack of your own perhaps?
03:13:24 <ongy> saurabhnanda: is getDownloadsR provided by yesod? I can't find it
03:13:40 <Jinxit> yeah I've considered that, just fishing for ideas before I go off implementing something
03:13:48 <saurabhnanda> ongy: it's a handler. my own name.
03:14:09 <Jinxit> I've also considered passing along the progress so far along with a "you are here" pointer/lens
03:14:31 <dramforever> Jinxit: I wonder if my "l/e interpreter idea" works
03:14:40 <dramforever> This: l: push an empty list onto the stack. e: pop the top of the stack and append to the end of the next-to-top
03:15:31 <Jinxit> I mean that's essentially the "build your own stack" idea, no?
03:16:05 <dramforever> It is
03:16:52 <dramforever> Anyway I think you already know how to it, so I'll go back and stop littering with random stuffs
03:16:53 <ski> Jinxit : as is CPS, more or less
03:17:14 <ski> (CPS also allows interesting control transfer patterns)
03:17:31 <Jinxit> aha, so it's like a more powerful form of the same thing?
03:18:06 <ski> CPS is Continuation-Passing Style
03:18:13 <Jinxit> yeah
03:18:24 <dramforever> "Abstracting Control" and "Representing Control"
03:18:35 <Jinxit> yeah reading the first one atm
03:18:53 <ski> instead of returning directly to whoever called you, you take a function (a continuation) as argument, which represents "what to do next", and you "return" by (tail)calling it with your answer
03:18:56 <ongy> saurabhnanda: I am a bit lost, since I neither know yesod, nor your codebase. But I guess you need an instance 'ToTypedContent DownloadResponse'. I don't see why you are trying to derive one from ToJSON
03:19:40 <saurabhnanda> ongy: to avoid doing it for every single JSON type in my codebase.
03:19:49 <ski> doing this then allows swapping in a different continuations at times, to e.g. implement generators, coroutines, cooperative concurrency, backtracking, ...
03:21:04 <Jinxit> this feels like it would cause typing issues in languages less polymorphic than haskell
03:21:21 <Jinxit> unless I misunderstand
03:23:47 <Jinxit> ski: "foo :: a -> (a -> b) -> b" would be a CPS-style function then?
03:23:53 <ski> yes
03:24:08 <Jinxit> alright
03:25:04 <ski> Jinxit : in C, something like `void foo(a_t a,void (*cont)(a_t));' might be used
03:25:41 <ongy> saurabhnanda: you can wrap it into a type (Endpoint a) and do 'instance ToJson a => ToTypedContent (Endpoint a) where ...'. But there may be something nicer that I don't know about
03:26:05 <ski> Jinxit : polymorphism isn't required for CPS
03:26:52 <Jinxit> but you would need something like templates to do it with return values
03:27:18 <Jinxit> (which is compile-time polymorphism anyways)
03:28:52 <ski> Jinxit : i don't see why. .. do *what* with return values ?
03:29:18 <Jinxit> b_t foo(a_t a, b_t(*cont)(a_t));
03:29:31 <freyr> Stupid question: how to rewrite previous line while printing in haskell? VT100 escape codes does not work for me with Text.Prinf.
03:30:00 <ski> unless you want to do nqCPS (which isn't quite CPS), then just pick a single fixed "answer" return type, possibly `void' in C, C++, Java, C#
03:30:29 <ski> Jinxit : that is using specific types `b_t',`a_t'. doesn't require templates or something similar
03:30:42 <ongy> freyr: if you want to use the codes raw you cand try to build a ByteString and use Data.ByteString.putStr
03:30:48 <Jinxit> but I meant that it would require a different foo overload for each b_t
03:31:14 <ski> Jinxit : why would you need to use more than one `b_t' ?
03:31:30 <Jinxit> that seemed to me where it would be the most powerful
03:31:45 <Jinxit> you can write foo once and go into different contexts
03:31:47 <ski> (also, overloading is technically distinct from templates and generics (polymorphism))
03:31:54 <ongy> Jinxit: why would you ever want to return? b_t would just be 'void'
03:32:01 <Jinxit> (yes, overloading OR use templates)
03:32:22 <ski> Jinxit : the point of CPS is that every call is a tail call, and so every return type can be the same
03:32:22 <Jinxit> don't you want a return value in CPS? maybe I misunderstand how to use it
03:32:40 * hackagebot strict-data 0.1.1.0 - Verious useful strict data structures  https://hackage.haskell.org/package/strict-data-0.1.1.0 (AlexanderThiemann)
03:32:48 <ongy> Jinxit: instead of returning a value, the rest of the function would be the continuation that then get's the value as argument
03:33:04 <Jinxit> yes, but for the final call?
03:33:09 <ski> (or, every call except some select few which you aren't CPS-transforming, and which you're treating as primitive)
03:33:20 <ongy> exit? that never returns :)
03:33:21 <ski> Jinxit : every call is the final call
03:33:59 <Jinxit> even if I want to use CPS only in a part of my entire program?
03:34:03 <saurabhnanda> WHAT THE BLOODY...
03:34:25 <saurabhnanda> The order of 'on' clauses in Esqueleto is significant
03:34:49 <saurabhnanda> any order will compile, but only one true order will work! rest will throw a runtime error
03:34:52 <Jinxit> something like "int result = foo(5, bar(baz(10)));"
03:35:01 <ski> Jinxit : instead of having a non-CPS `b_t frob(a_t a);', you'd write a CPS `void frob_cps(a_t a,void (*cont)(b_t));'
03:35:02 <saurabhnanda> so much for type-safe SQL joins.
03:35:06 <merijn> Jinxit: Then you pass in "id" as continuation :)
03:35:10 <saurabhnanda> screw this, I'm going home.
03:35:40 <ski> Jinxit : instead of returning a `b_t' with `return b;', you'd just call `cont', with `(*cont)(b);'
03:36:01 <Jinxit> yes I think I understand how it works inside the CPS function
03:36:06 <Jinxit> it's more the outside I don't get
03:36:32 <ski> if you CPS-transform, then commonly all or most of your programm would be in CPS
03:36:38 <Jinxit> how do I get out the value when I want to stop being in CPS?
03:36:39 <ongy> Jinxit: what you want to do can be done with a mutable value (int *, or for java some mutable Int wrapper) and have the last continuation just write into that. 
03:36:49 <Jinxit> fair
03:36:56 <Jinxit> but then that needs to be polymorphic or overloaded
03:37:07 <ski> depending on what you want, you can do it manually, and more localized
03:37:12 <ski> (e.g. for a parser)
03:37:46 <ski> "how do I get out the value when I want to stop being in CPS?" -- if you have mutation, then you can use that
03:38:09 <ski> (and if you can send messages to other processes as in Erlang, then you can do that)
03:38:17 <saurabhnanda> has some gibberish about it in the docs -- https://hackage.haskell.org/package/esqueleto-2.4.3/docs/Database-Esqueleto.html#v:on
03:38:19 <Jinxit> (yep)
03:38:30 <ski> if you can do neither, then you need to incorporate the final answer in the answer type you use
03:38:48 <ski> either by picking a fixed answer type, or by some kind of polymorphism
03:38:59 <Jinxit> but yeah then it works like I thought it did
03:39:02 <Jinxit> pretty neat style
03:39:06 <Jinxit> where does it excel?
03:39:21 <ski> non-trivial control transfers
03:39:49 <ski> and simulating tail calls on an architecture that doesn't have then, i suppose
03:40:19 <ggole> Translation into CPS also makes order of evaluation explicit
03:40:26 <Jinxit> and I guess non-trivial control transfers turn up in parsers
03:40:47 <ski> yes, CPS can be useful inside a compiler
03:41:16 <ski> (but i was thinking of uses of it, as a programmer, apart from implementing a compiler or similar)
03:41:39 <ski> Jinxit : yes, if you have some form of backtracking
03:42:05 <Jinxit> yeah that seems like a nice solution
03:42:32 <ski> Jinxit : one can also use it to remove "interpretative overhead"
03:42:45 <ongy> ski: simulating tail calls sounds broken. If the compiler insersts some kind of stack for a call, that sounds bad
03:43:14 <ski> ongy : you can do trampoline tricks
03:43:17 <ggole> Various non-blocking programming patterns also involve (usually partial) CPS conversion of some kind
03:43:57 <ggole> eg, you reify the rest of what you want to do as a continuation and put it somewhere to be resumed when the thing you want has arrived
03:44:38 <Jinxit> ongy: C# has no tail-call optimization for example
03:45:06 <Jinxit> also, this feels a bit like callback hell from JS :)
03:45:07 <ski> Jinxit : the naive way to run `(>>=)' for `Maybe' or `Either e' will percolate a failure/exception through all the left arguments of `(>>=)' calls, until it reaches a handler
03:46:03 <ski> Jinxit : using `CoYoneda Maybe'/`CoYoneda (Either e)', which is CPS, you will instead "jump directly" to the handler
03:46:31 <Jinxit> so it won't jump out when using Maybe normally?
03:46:36 <ski> .NET has support for tail calls, though
03:47:15 <ski> i'm not sure whether GHC currently does optimizations which (often ?) give the same effect anyway
03:47:43 <ski> (istr seeing some paper that was relevant, but i'm not sure if it's currently implemented)
03:48:13 <Jinxit> ski: afaik it's the C# compiler that can't insert tail calls for some reason, even though the CLR has them
03:48:28 <ski> ok
03:49:06 <ggole> Might be the debugging thing.
03:50:14 <quicksilver> @src forever
03:50:14 <lambdabot> forever a = let a' = a >> a' in a'
03:50:36 <quicksilver> I recall getting really confused in the past by the fact that 'forever' (and similar hand written constructs) aren't actually tail calls
03:50:46 <quicksilver> because of the >>
03:50:58 <quicksilver> and nonetheless they work fine
03:53:00 <ski> i think one could view it as similar to an accumulating loop looping over the result of e.g. `map' (which isn't tail-recursive, though incremental)
03:54:34 <quicksilver> IIRC it is something you need to consider when writing a custom monad
03:54:58 <quicksilver> it is possible to accidentally write ones which have poor performance with >>-nesting like this
04:02:42 <nilof> If I want to manipulate trees (chopping them up, putting chopped subparts together in a different way, and getting or storing information at nodes), is there any Haskell concept that is useful for doing this?
04:04:10 <ski> maybe zippers and contexts
04:04:24 <ski> perhaps tying-the-knot, depending on what you're doing
04:04:53 <ski> otherwise, just normal recursion and tree shuffling/manipulation ?
04:05:20 <nilof> Right, the context is physics and I have a Hamiltonian ( a matrix) where the matrix elements are defined by sime combinatorial rules with trees
04:05:34 <ski> perhaps state and nondeterminism could be useful, in some cases
04:06:49 <nilof> The basis vectors are just all different labeled trees I can write down, and matrix elements a_ij are nonzero if I can transform the tree i into the tree j with a sequence of simple moves
04:09:33 <ski> mhm
04:10:38 <nilof> Is the lens library useful for problems of this kind?
04:11:15 <nilof> ah, all trees are binary
04:13:01 <ski> i'm not sure whether lenses would be that helpful, unless you want to do stuff to all elements of a tree
04:17:12 <nilof> Well, I need to compare matching elements of slightly different trees basically, and do stuff to them if they are different
04:20:27 <hexagoxel> nilof: if you want to apply some list of transformation rules on your tree, there is `uniplate` (or other *plate stuff/syb)
04:20:38 <nilof> I can also rewrite the problem in terms of dyck words with several different kinds of parentheses (like []{} or [{}] ) which makes my moves local, but then I get some other nonlocal information to keep track of (matching parentheses must be of the same type)
04:21:05 <nilof> and another part of the problem becomes harder
04:22:48 <nilof> thanks, I'll look at uniplate
04:38:55 <lyxia> lens has "Plated" as an alternative to uniplate
04:46:18 <merijn> So, with Levity polymorphism in GHC8, what is the kind (or is it type?) of TYPE?
04:54:00 <pavonia> If you use -fobject-code in GHCi, can you only use function in the interpreter that are listed in the export list of the currently loaded module?
04:59:48 <merijn> pavonia: Not sure, but my intuition says yes
05:02:43 <pavonia> I got "Can't find interface-file declaration for variable ..." errors from time to time when testing functions from the current module, but it worked when importing them from another module
05:03:20 <pavonia> And just adding them to the export list seems to solve the problem
05:10:56 <zoran119_> i'm playing with scotty and would like to store some data in memory while my program is running
05:11:08 <zoran119_> what's a good library to use for this?
05:11:30 <zoran119_> or should i just use an IORef? (noob here)
05:11:48 <merijn> zoran119_: Do you plan to persist said data between runs?
05:12:25 <zoran119_> merijn: let's say not
05:12:39 <zoran119_> i bet you are thining of acid state?
05:13:10 <merijn> If yes, acid-state, if no, IORef or MVar seems reasonable
05:14:25 <zoran119_> merijn: how does one go about migrating an acid-state store in case of changes to types?
05:14:45 <zoran119_> i couldn't find much info on the net, apart from saying it is possible
05:15:25 <merijn> zoran119_: I've not really used acid-state :)
05:16:25 <cocreature> merijn just appears magically everytime someone mentions acid-state and database in the same sentence :)
05:16:32 <zoran119_> merijn: it sounds so attractive, sql in haskell feels messy (not that i have tried yet)
05:16:55 <merijn> cocreature: :)
05:17:09 <zoran119_> cocreature: seems to appear any time i ask a question :)
05:17:20 <zoran119_> very helpful
05:17:26 <zomg> zoran119_: it's questions like that that put me off from using acid-state, it seems there's all these things that are possible but it's just not documented anywhere except in someone's head
05:17:42 <merijn> zomg: Figure it out and write it up for the rest of the internet!
05:17:46 <zomg> Persistent might be something to look at for dealing with SQL DB's
05:18:05 <zomg> merijn: yeah if I had the time I might :D
05:18:43 <cocreature> zoran119_: also sql is really not that bad in haskell. we don’t have a good story regarding orms as some people like to use in other languages but if you’re fine writing more or less raw sql with some serialization from and two haskell types it’s quite easy to do
05:19:03 <zoran119_> zomg: i have read a bit about persistent but it's dsl just doesn't seem as neat as much of haskell does
05:19:37 <merijn> Obligatory remark referred to by cocreature: I would not consider SQL or acid-state for the same sorts of problems
05:19:56 <cocreature> toldyouso™
05:20:15 <zomg> in an ideal world you should be able to use acid-state for everything :p
05:20:32 <zomg> but yeah especially for very large and/or complex data sets I get the feeling it probably isn't going to work so well
05:20:58 <zoran119_> cocreature: i'm kinda on the fence as far as sql in haskell goes. i'd like all the type checking, but it makes the api not pretty, or just write sql as strings but i expect more from haskell
05:21:00 <merijn> zomg: To quote myself, I would describe acid-state as "persistent heap data with ACID guarantees", rather than a database :)
05:21:12 <jonored> Actually... it might be pretty neat to have a DSL of pretty straight-up relational algebra with a n SQL ba ckeckend around.
05:23:10 <jonored> *an SQL backend around. mosh prediction stuff isn't perfect and my link is slow.
05:24:14 <jonored> Ah, which appears to be relational-query.
05:24:24 <zomg> jonored: I've learned to be very careful when typing over slow connections, to the point where a laggy SSH connection I can accurately detect my own typos and fix them before even seeing any changes :p
05:24:39 <zomg> well, at least some of the time anyway
05:26:31 <jonored> I have a suspicion that some backspaces might be getting lost by being split over packets that come in across a timeout, actually. It doesn't seem like it's quite consistent.
05:34:13 <lwm> mpickering: could you elaborate on community fragmentation a little? Interesting ...
05:34:39 <mpickering> I would prefer not to, you can read the comment threads on reddit
05:35:29 <lwm> Fair enough
05:37:45 * hackagebot angle 0.8.1.0 - A small, general-purpose programming language.  https://hackage.haskell.org/package/angle-0.8.1.0 (GuiltyDolphin)
05:42:42 <jchia_> I have many records of the same type in a file that I'm trying to deserialize using cereal (Data.Serialize.Get) into [MyRecord]. cereal uses strict ByteString. If I use Data.ByteString.Lazy.toStrict to get a strict ByteString and use it to runGet, I will end up reading the whole file before I can even process the first record, correct?
05:43:36 <jchia_> (I'm using toStrict because i'm decompressing a bz2 file using Codec.Compression.BZip, which uses lazy ByteStrings.)
05:44:26 <jchia_> I suspect this because I see 1GB resident memory and not even one record got printed.
05:44:31 <merijn> jchia_: Why not use binary then? That works with lazy ByteString
05:44:56 <ertes> cereal works with lazy bytestring, too
05:45:02 <ertes> decodeLazy
05:45:21 <merijn> jchia_: Alternatively, use either Pipes or Conduit to do streaming decoding of strict read operations
05:45:24 <ertes> however, neither of the two support streaming, so you end up using lazy I/O
05:45:42 <merijn> Which for large data sets would be the most reliable approach
05:46:46 <jchia_> merijin: I actually don't know how people choose one over the other and their pros and cons. What do you think about them?
05:47:04 <ertes> jchia_: if you store all of them in the same file, make sure that you can iterate over them using some other abstraction like pipes, so you only deserialise individual records, not a whole list of records
05:47:14 <ertes> jchia_: alternatively use multiple files
05:47:15 <jchia_> ertes: If I want to use decodeLazy, I have to make my record an instance of Serialize, right?
05:47:22 <merijn> jchia_: I use pipes because I think it's design is elegant and I used it before. No strong opinion on conduit
05:47:44 <merijn> jchia_: FYI, Serialise/Binary instances are not good for decoding a fixed format
05:47:45 <jchia_> ertes: What does it mean by streaming?
05:47:50 <ertes> jchia_: you can use runGetLazy, too
05:48:06 <merijn> At least binary introduces custom noise inside the class
05:48:09 <cocreature> ertes: I don’t think that’s true. binary has an incremental interface which you could plug into pipes or something like that
05:48:33 <ertes> apparently cereal has an incremental interface, too
05:48:38 <ertes> that might be useful
05:48:39 <jchia_> merijn: By fixed format, do you mean repeated fixed-sized records?
05:48:46 <saurabhnanda> ditching yesod + persistent. Moving to Servant + Opaleye (I hope SQLITE works).
05:48:48 <ertes> see runGetPartial
05:48:57 <cocreature> in fact pipes-cereal and pipes-binary both exist already
05:49:17 <merijn> jchia_: I mean if your implementing a parser for an existing binary format, you want explicit Get/Put instead of the typeclasses
05:49:45 <jchia_> there's actually runGetLazy. I don't know why I didn't see it earlier
05:50:52 <ertes> jchia_: use runGetPartial instead
05:52:20 <ertes> there is also the runPutLazy counterpart to stream-write the file
05:53:01 <ertes> jchia_: about choosing between binary/cereal, here is how to choose: flip a coin
05:53:02 <ertes> =)
05:53:37 <jchia_> ertes: what's the advantage of runGetPartial over runGetLazy?
05:53:49 <ongy> pain FFI Storable for the win :)
05:53:58 <ongy> *plain, but pain is good enough
05:53:59 <ertes> jchia_: runGetLazy needs lazy I/O, while runGetPartial allows you to read chunks in a loop
05:54:29 <jchia_> is lazy I/O worse than reading chunks in a loop?
05:55:46 <ertes> it's harder to predict/control in some cases, but more importantly it's "weird" semantically
05:55:51 <ertes> like unsafePerformIO is weird
05:56:08 <jonored> jchia_: lazy IO is much easier to shoot yourself in the foot with than the other options, at least.
05:56:33 <jchia_> in terms of holding on to lots of resources?
05:56:37 <jonored> (and said foot-shooting happens somewhat non-locally in your code.)
05:56:57 <jonored> in terms of "oops, I looked at the value in the wrong place, now I'm out of memory", yes.
05:57:04 <maerwald> lazy IO is hard because it's hidden
05:57:15 <maerwald> types don't tell you what's going on
05:58:18 <jchia_> is there a small example of how to shoot one's foot using lazy IO?
05:58:20 * jonored suggests that it's also hard because resource usage doesn't compose cleanly with lazy I/O.
05:58:38 <jchia_> i want to understand how exactly it's bad
05:58:56 <mniip> you can break referential transparency
05:59:18 <ertes> jchia_: when you use lazy I/O you have in your hands a lazy ByteString
05:59:40 <ertes> jchia_: but whenever you ask what part of its value is, you might cause I/O
06:00:08 <jchia_> i c. you could do actual I/O in weird places.
06:00:12 <ertes> that's not necessarily bad in itself…  the impurity begins when that I/O fails
06:00:30 <ertes> and you never know *how much* I/O you're doing
06:00:39 <mniip> jchia_, would you agree that "x `seq` y `seq` (x, y)" and "y `seq` x `seq` (x, y)" should always be the same
06:01:07 <ertes> or even *when* it happens
06:01:17 <maerwald> jchia_: there's a library that constructs trees of your files/folders lazily. So you walk up down etc, but folders are only read when you actually visit a node in your internal structure. That means that the tree in your internal memory can be in a state that's completely disconnected from the actual filesystem. The idea is nice... have a lazy tree of the _whole_ filesystem (that's not a good idea in strict semantics)
06:01:21 <maerwald> but in practice, it's just bad
06:01:47 <jchia_> mniip: yes
06:02:06 <mniip> well lazy IO lets you construct such x and y such that evaluation of one affects the result of the other
06:02:09 <mniip> i.e breaking the above law
06:02:30 <jchia_> OK
06:02:51 <ertes> mniip: uhm…  how would that happen?
06:03:23 <ertes> even lazy I/O uses (and has to use) sharing
06:03:35 <merijn> maerwald: Isn't the laziness a red-herring there? Since a strict version would have the exact same issues?
06:03:36 <mniip> do ix <- newIORef False; iy <- newIORef False; x <- unsafeInterleaveIO (writeIORef iy True >> readIORef ix); y <- unsafeInterleaveIO (writeIORef ix True >> readIORef iy)
06:03:45 <merijn> maerwald: Or am I misunderstanding what you're saying?
06:04:14 <jchia_> Codec.Compression.BZip uses lazy BS. If I use it with a lazy BS I get from readFile, I'm necessarily doing lazy IO, correct? Does that mean I should use toChunks to convert the lazy BS to chunks of strict BS before processing the bytes?
06:04:32 <ertes> mniip: that doesn't break it in a way that lazy I/O itself doesn't already break it:  you don't know the value at the beginning
06:04:45 <ertes> the file might change even during a lazy read
06:05:00 <mniip> merijn, with strict IO you can reason about when you saw something happen
06:05:03 <maerwald> merijn: no, it's not the same. 
06:05:26 <mniip> with lazy IO it's random unspecified moments
06:05:44 <maerwald> merijn: in the strict version you _couldn't_ do the same. So you have to choose a different approach anyway. This is an example where lazy IO is tempting as a concept, but leads to a lot of problems.
06:05:51 <ertes> ByteString has a terrible acronym…  i always read that other word
06:05:56 <mniip> ertes, but that breaks the law I stated, doesn
06:05:58 <mniip> 't it
06:06:10 <maerwald> if you read the whole filesystem strictly, you'll likely just blow up your program
06:06:59 <ertes> mniip: surprisingly enough it doesn't…  which tuple you get depends on which one you evaluate first…  however, if you do both and compare, you will find that both tuples are equal regardless
06:07:24 <c_wraith> ertes: You can do the same with unsafeInterleaveST.  Which is "fun"
06:07:24 <jonored> jchia_: To some extent, I wouldn't worry about there being some lazy I/O in the course of an operation that will happen at a fixed time, and if the lazy IO datastructures can't leak out of that context.
06:08:02 <c_wraith> ertes: you can easily construct cases where that's not true
06:08:16 <ertes> i'd be interested in seeing one
06:08:17 <mniip> ertes, er what?
06:08:52 <c_wraith> ertes: like http://lpaste.net/110207
06:09:07 <ertes> mniip: try this:  (x `seq` y `seq` (x, y)) == (y `seq` x `seq` (x, y))
06:09:33 <ertes> mniip: this only fails, if you don't give the result of unsafeInterleaveIO a name *immediately*, i.e. before evaluation
06:09:48 <mniip> that's the same x and y
06:10:07 <mniip> hm
06:10:19 <ertes> c_wraith: i don't see how that one would fail either
06:10:21 <mniip> yeah this is not what RT is about
06:11:41 <ertes> oh, wait
06:12:02 <jonored> (also, small example of the memory issue would be that something like do { file <- readFile "foo"; return $ last $ unlines file } can happen lazily in constant space, do { file <- readFile "foo"; return $ head $ unlines file } similarly, and do { file <- readFile "foo"; return $ (head $ unlines file, last $ unlines file) } probably holds the /entire/ file in memory while it's running, and won't work if yo
06:12:08 <jonored> u run out.)
06:12:13 <ertes> let (l1, t1) = fun 0; (l2, t2) = fun 0
06:12:20 <ertes> l1 and l2 *should* be equal
06:12:36 <ertes> but you can find them to be non-equal
06:12:42 <c_wraith> exactly
06:12:57 <ertes> c_wraith: bottom line: don't use unsafeInterleaveST =)
06:13:10 <ertes> at least unsafeInterleaveIO has that IO in there =)
06:13:19 <c_wraith> There are legit use cases for it.  But yeah, it's incredibly unsafe.
06:13:29 <c_wraith> Well, there's *one* legit use case for it.
06:13:38 <ertes> i've used it myself for random numbers
06:13:46 <c_wraith> Creating a *single* infinite stream of values from a state-based computation
06:13:51 <c_wraith> yep.  that case. :)
06:14:09 <ertes> but i prefer to just use IO today
06:14:25 <ertes> (or PrimMonad, if you will)
06:14:26 <c_wraith> Even when something really is morally pure?
06:14:37 <ertes> c_wraith: yeah
06:14:58 <c_wraith> I mean, a PRNG will always produce the same output stream from a given seed.  It's pure, really!
06:15:21 <jchia_> jonored: do you mean lines instead of unlines?
06:15:46 <jonored> jchia_: Yes, sorry. I actually was poking at ghci with words...
06:16:09 <ertes> c_wraith: the problem is that i almost never know what will consume random values when, so a list of randoms rarely does it for me
06:16:21 <ertes> c_wraith: most of the time i find it easier to just pass the Gen around (mwc-random)
06:17:02 <ertes> i also found myself passing generation actions around:  (Monad m) => m Int -> m Blah
06:17:07 <mniip> ertes, can we reason about breaking RT in IO actions?
06:17:25 <ertes> that one is still pure, except for that one effect
06:17:34 <mniip> hmm, probably nothing is broken there
06:17:34 <jonored> jchia_: although it's not really even required; you could look at the first and last character, or sum them, or something like that.
06:18:01 <ski> mniip : with `forkIO' you can get a similar type of behaviour as with `unsafeInterleaveIO'
06:18:38 <mniip> hardly
06:20:09 <jchia_> jonored: what characters?
06:21:12 <ski> hm, to emulate it closely, i think you'd also need something like futures or I-vars
06:21:28 <ski> (which will block when forced)
06:21:42 <mniip> yes, you need to unsafeinterleavedly read them
06:21:45 <pavonia> Is there no way to catch a null pointer dereferencing?
06:21:47 <jonored> jchia_: lines is not actually required there.
06:21:51 <mniip> pavonia, in?
06:22:06 <pavonia> In what?
06:22:14 <mniip> yes in what?
06:22:21 <pavonia> In Haskell :)
06:22:28 <mniip> what kind of null pointer
06:22:32 <mniip> and what is dereferencing it
06:22:45 <pavonia> As in "peek nullPtr"
06:22:46 * hackagebot servant-matrix-param 0.2 - Matrix parameter combinator for servant  https://hackage.haskell.org/package/servant-matrix-param-0.2 (SoenkeHahn)
06:23:13 <pavonia> Or when it happens in a foreign function call
06:23:17 <mniip> so a Ptr
06:23:18 <jchia_> jonored: ok, you meant in that code you wrote, getting the first and last characters would be enough, so no need to use lines
06:23:32 <mniip> well
06:23:35 <ski> (anyway, `unsafeInterleaveST' is dangerous in a way that i'd argue `unsafeInterleaveIO' isn't. you could always blame getting different results from the program as due to the I/O part of `unsafeInterleaveIO'. nothing would prevent an implementation to do speculative execution of `unsafeInterleaveIO'd actions in a separate thread)
06:23:46 <Guest789233> I have a Megaparsec parser which tries to parse strings like "[a,b,c]" into a list of expressions (listElements = bracks $ expression `sepBy` pcomma). This works all fine but now I'd like to allow trailing commas, like "[a,b,]". Preceeding "expression" with "optional" won't do the trick as I'll end up with maybe. Is there a way to tell Megaparsec "try to parse it, if it doesn't work just stop it alltogether"?
06:23:52 <mniip> safePeek p = if p == nullPtr then error"boo" else peek p
06:24:21 <pavonia> mniip: No, I mean when I don't have control over the checking
06:24:40 <mniip> then hardly
06:25:47 <mniip> e.g on Linux NULL can be made a valid address
06:25:57 <jonored> jchia_: I expect so. You still have a reference to the start of the list and walk down it.
06:26:00 <paolino> @pl \x  -> (<>) <$> f x <*> g x
06:26:00 <lambdabot> ((<>) <$>) . liftM2 (<*>) f g
06:26:18 <paolino> :t  \x  -> (<>) <$> f x <*> g x
06:26:20 <lambdabot> (Show t, Applicative f, Monoid b, FromExpr (f b)) => t -> f b
06:26:34 <paolino> :t  \f g x  -> (<>) <$> f x <*> g x
06:26:35 <lambdabot> (Applicative f, Monoid b) => (r -> f b) -> (r -> f b) -> r -> f b
06:26:36 <c_wraith> ski: I don't think anyone would argue that unsafeInterleaveST isn't the more dangerous of the two
06:27:08 <mniip> @pl liftA2 (<>) (f x) (g x)
06:27:08 <lambdabot> liftA2 (<>) (f x) (g x)
06:27:13 <mniip> @pl \x -> liftA2 (<>) (f x) (g x)
06:27:13 <lambdabot> ap (liftA2 (<>) . f) g
06:27:16 <jchia_> jonored: OK, thanks for the example
06:27:29 <pavonia> mniip: I'm on Windows, porting parts of the API, and sometimes while testing GHCi just crashes with "Segmentation fault/access violation in generated code" which is a bit annoying
06:27:41 <paolino> :t \f g -> ((<>) <$>) . liftM2 (<*>) f g
06:27:42 <lambdabot> (Applicative f, Monoid m) => (a -> f (a1 -> m)) -> (a -> f a1) -> a -> f (m -> m)
06:27:45 <mniip> :t \f g -> liftA2 (<>) <$> f <*> g
06:27:46 <lambdabot> (Applicative f, Applicative f1, Monoid c) => f (f1 c) -> f (f1 c) -> f (f1 c)
06:28:00 <mniip> :t liftA2 (liftA2 (<>))
06:28:02 <lambdabot> (Applicative f, Applicative f1, Monoid c) => f (f1 c) -> f (f1 c) -> f (f1 c)
06:28:05 <mniip> there
06:28:15 <mniip> might wanna use mappend, too
06:28:25 <paolino> uh, pl is ...
06:28:52 <paolino> :t liftA2
06:28:53 <mniip> paolino, liftA2 (liftA2 mappend) is the same function
06:28:54 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
06:29:05 <paolino> :t (<*>)
06:29:06 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:29:58 <paolino> mniip, seems pl got it wrong
06:30:04 <mniip> no
06:30:55 <mniip> :t \x -> (<>) <$> ?f x <*> ?g x
06:30:59 <lambdabot> (Applicative f, ?f::t -> f b, ?g::t -> f b, Monoid b) => t -> f b
06:31:07 <mniip> :t ((<>) <$>) . liftM2 (<*>) ?f ?g
06:31:13 <lambdabot> (Applicative f, ?f::a -> f (a1 -> m), ?g::a -> f a1, Monoid m) => a -> f (m -> m)
06:31:19 <mniip> hrm
06:32:02 <mniip> oooh
06:32:09 <mniip> I think it parsed <*> at the wrong precedence
06:32:17 <mniip> @pl \x  -> ((<>) <$> f x) <*> g x
06:32:17 <lambdabot> ap ((<*>) . ((<>) <$>) . f) g
06:32:43 <Philonous> I'm trying to find the ghc documentation describing the default keyword, but I'm drawing a blank. Can someone point me in the right direction? 
06:33:40 <paolino> :t ap ((<*>) . ((<>) <$>) . ?f) ?g 
06:33:42 <lambdabot> (Applicative f, ?f::a -> f b, ?g::a -> f b, Monoid b) => a -> f b
06:34:20 <lyxia> :t \x -> (<>) <$> (?f x <*> ?g x)
06:34:21 <lambdabot> (Applicative f, ?f::t -> f (a -> m), ?g::t -> f a, Monoid m) => t -> f (m -> m)
06:34:44 <paolino> :t (mappend <*>) <*>)
06:34:45 <lambdabot> parse error on input ‘)’
06:34:50 <prohobo> woah what happened here
06:34:55 <paolino> :t ((mappend <*>) <*>)
06:34:56 <lambdabot> Monoid a => ((a -> a) -> a) -> (a -> a) -> a
06:35:47 <lyxia> Philonous: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#default-method-signatures
06:36:29 <Philonous> lyxia, thanks
06:36:53 <mniip> oh
06:37:04 <mniip> I thought you were talking about monomorphism defaulting
06:37:46 <Philonous> lyxia, Oh, wait, that must be another one. I meant the default keywoard you use to specify type defaulting rules. For example you can put «default (Text)» at the top of your file to avoid OverloadedStrings ambiguities
06:38:28 <lyxia> oh, you can do that?
06:38:44 <mniip> ah
06:38:48 <mniip> that's what I was talking about
06:38:54 <mniip> Philonous, it's a feature of haskell, not ghc
06:38:55 <mniip> https://www.haskell.org/onlinereport/decls.html#sect4.3.4
06:39:45 <Philonous> mniip, Wait, there's a useful feature that is not a GHC extension? Amazing! :P 
06:39:48 <Philonous> mniip, Thanks!
06:42:43 <paolino> :t liftA2 ?f x y
06:42:45 <lambdabot>     Couldn't match expected type ‘f a0’ with actual type ‘Expr’
06:42:45 <lambdabot>     In the second argument of ‘liftA2’, namely ‘x’
06:42:45 <lambdabot>     In the expression: liftA2 ?f x y
06:42:57 <paolino> :t \x y -> liftA2 ?f x y
06:42:58 <lambdabot> (Applicative f, ?f::a -> b -> c) => f a -> f b -> f c
06:44:58 <mniip> hmm, on a related note
06:45:21 <paolino_> :t \x y ->  ?f <$> x <*> y
06:45:22 <lambdabot> (Applicative f, ?f::a1 -> a -> b) => f a1 -> f a -> f b
06:45:23 <jonored> jchia_: (to be fair, that's more of a "lazy I/O puts you in the situation of working with huge lists you need to gc as you go a lot" issue - the same would happen with any large lazy list - but still.)
06:47:54 <lingxiao> hey all
06:48:01 <lingxiao> the behavior of foldlC in http://hackage.haskell.org/package/conduit-combinators-1.0.4/docs/Conduit.html is really confusing me
06:49:00 <saurabhnanda> anyone using servant around here?
06:49:13 <lingxiao> i have this setting    foo =$= filterC pred :: Source m [Text]
06:49:34 <lingxiao> I want to do    foo =$= filterC pred =$= foldlC (++) []
06:50:05 <Philonous> saurabhnanda, You're better off just asking your question than trying to get someone to commit to answering it before you asked
06:50:08 <mniip> when we say that (Hask^Hask, Day, Identity) is a monoidal category
06:50:15 <saurabhnanda> Philonous: :)
06:50:23 <mniip> we have to be able to reason about equality of morphisms in Hask^Hask
06:50:42 <saurabhnanda> anyone using servant around here? What's the recommended (least painful) HTML templating library to use along with servant?
06:50:58 <mniip> e.g to be able to say that assoc . (id *** rightCounit) = (leftCounit *** id)
06:51:17 <mniip> how do we do that
06:51:25 <Philonous> saurabhnanda, Personally I use hamlet for most of my HTML templating independent of framework 
06:51:57 <Philonous> saurabhnanda, It's part of the shakespeare package: http://hackage.haskell.org/package/shakespeare
06:52:13 <saurabhnanda> Philonous: nooooooo... I'm not touching hamlet again... https://medium.com/@saurabhnanda/why-building-web-apps-in-haskell-is-harder-than-it-ought-to-be-c9b13de0be4f#.ouydugy7k
06:53:16 <saurabhnanda> Philonous: "Why are templates so hard"
06:53:20 <lingxiao> i think it's because foldC is a Consumer b m a
06:53:35 <lingxiao> while I really want a conduit that folds over the stream and yield the result 
06:55:01 <Philonous> saurabhnanda, I agree that those are problems. I don't do a lot of frontend web programming, so it hasn't hit me as hard as it might have. 
06:55:38 <zomg> saurabhnanda: interesting article.. I also come from the dynamic langs and web dev world :)
06:56:35 <zomg> the "templates are hard" point is actually good.. I didn't run into it much myself tbh, but good point still
06:56:53 <zomg> have you looked at blaze-html? Allows you to write "templates" of sorts directly in Haskell
06:58:52 <saurabhnanda> zomg: trying to figure out which is better right now. Lucid vs Blaze.
06:59:01 <saurabhnanda> that's what the servant world seems to be using.
06:59:46 <zomg> interesting, lucid looks fairly similar to blaze-html
06:59:57 <saurabhnanda> reading https://www.schoolofhaskell.com/user/AthanClark/overloaded-monadic-deployment right now
07:00:07 <mniip> ski, hey
07:04:48 <saurabhnanda> any opinions on lucid vs blaze?
07:05:49 <zomg> Seems chrisdone isn't on irc so much these days
07:05:57 <zomg> I'm sure he'd have one :D
07:06:06 <zomg> oh, actually, he is on irc but just not here :P
07:07:00 <ahihi> he's already written about it http://chrisdone.com/posts/lucid
07:07:04 <suppi> http://chrisdone.com/posts/lucid <- his opinion here
07:08:07 <saurabhnanda> thanks for the link
07:09:39 <zomg> yeah that's a good overview, pretty much answers all the questions I had about it
07:09:53 <zomg> ...and it seems lucid also answers pretty much all annoyances I had with blaze-html :P
07:11:05 <zomg> I wonder if Chris had his hands on that CSS DSL
07:11:20 <zomg> since he seems to be one of those people who end up having their hands on a lot of webdev things =)
07:16:45 <joncol> Too long since I did Haskell, so I cannot remember the command to automatically insert an empty function definition after having written a function's type. In Emacs...?
07:18:13 <ertes> saurabhnanda: lucid is mostly just a smoother experience…  no qualified imports and less operator spaghetti
07:18:27 <ertes> saurabhnanda: for actual templating, i'd just use functions
07:18:41 <ertes> consider "template" and "function" to be the same thing
07:18:45 <saurabhnanda> remmeber having read some 3000x improvement in heist (I believe). What's the heist vs lucid story?
07:19:25 <ertes> saurabhnanda: you use heist, if you want to write actual HTML, and to some degree if you want *templates* (not content) to change during run-time
07:19:55 <ertes> reasons you may want to do that include having a frontend colleague who doesn't know haskell
07:20:12 <saurabhnanda> got it. The Erb vs HAML debate.
07:21:04 <ertes> joncol: i write the type signature, go to the next line and press tab twice to get the function name inserted for me
07:21:19 <ertes> but it only works with the old indent-mode, not the newer indentation-mode
07:22:11 <ertes> (to be honest it's the only reason i still use indent-mode)
07:22:48 * hackagebot octane 0.14.0 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.14.0 (fozworth)
07:25:21 <saurabhnanda> wow -- 3 year old issue. http://stackoverflow.com/questions/18084265/cabal-expose-all-modules-while-building-library 
07:25:24 <saurabhnanda> any solutions?
07:26:20 <joncol> ertes> OK, thx. Didn't work in my config, though.
07:27:48 * hackagebot unbound 0.5.0 - Generic support for programming with names and binders  https://hackage.haskell.org/package/unbound-0.5.0 (sweirich)
07:31:30 <saurabhnanda> trying to stackify my project. But it can't seem to find it's own modules -- http://lpaste.net/178525
07:32:31 <saurabhnanda> do I **need** to define a library target first?
07:43:57 <glguy> You only need a library target if you're making a library
07:48:52 <warbo> hello, I'm hitting deadlocks using System.Process stdio handles with ByteStrings, and was wondering if there's a de facto wrapper or something I could use instead? Google's pointing me to stuff like conduits, but that would mean learning a bunch of abstraction/jargon when all I really want is 'CreateProcess -> ByteString -> IO (ByteString, ExitCode)'
07:49:40 <glguy> warbo: One way to get stdio stuck is to have stderr fill up
07:50:12 <warbo> glguy: I'm inheriting stderr, so I assume that wouldn't be an issue
07:51:39 <glguy> Oh, then you'll still have to figure out how it's getting stuck, streaming libraries probably aren't related to a Handle that stops returning results when read from
07:52:34 <warbo> I was passing Strings via stdio handles, since System.Process didn't have a helper for my particular combo of input/output options
07:53:14 <warbo> that deadlocked until I switched around hPutContents and waitForProcess
07:53:48 <glguy> You also have to worry about Handle buffering
07:53:57 <glguy> either with hFlush or hSetBuffering
07:54:19 <warbo> I tried adapting https://passingcuriosity.com/2015/haskell-reading-process-safe-deadlock
07:54:33 <warbo> I'll try sprinkling some flushes around
07:54:35 <warbo> thanks
07:55:30 <paolino_> is there a simpler solution to http://lpaste.net/178535 (if it's correct)
07:57:07 <paolino_> I want to default to different ordering on EQ
07:59:17 <geekosaur>  all I really want is 'CreateProcess -> ByteString -> IO (ByteString, ExitCode)
07:59:29 * geekosaur smells the open3 problem
07:59:54 <geekosaur> no library will help in that case, you *must* split the input and output over different threads
08:00:42 <lingxiao> hey all
08:00:58 <lingxiao> does anyone know what the analogue of `noneOf`  in parsec is in attoparsec?
08:01:05 <lingxiao> looking thru the docs, i cant seem to find anything
08:01:54 <glguy> lingxiao: You'll build it with satisfy
08:02:51 <warbo> geekosaur: why can't a library help? System.Process uses threads, but it produces Strings rather than ByteStrings (e.g. https://hackage.haskell.org/package/process-1.4.2.0/docs/src/System.Process.html#readCreateProcess )
08:03:13 <geekosaur> String vs. ByteString does not cause deadlocks
08:03:49 <geekosaur> what causes deadlocks is writing more than _PIPE_BUF of data to a subprocess and expecting to linearly (instead of concurrently) read the result back, when the result is also more than _PIPE_BUF
08:04:47 <geekosaur> because the child's write will block on a full pipe, and then te parent blocks because the child is blocked instead of reading. but the pipe the child is blocked on will never empty because you don't read until after you've completed the write, which will never complete because the child blocked
08:06:13 <warbo> yes, I assume that's what the threaded code in that link is for, based on the comments like '-- fork off a thread to start consuming the output'
08:07:49 * hackagebot servant-aeson-specs 0.4.1 - generic tests for aeson serialization in servant  https://hackage.haskell.org/package/servant-aeson-specs-0.4.1 (SoenkeHahn)
08:07:55 <lingxiao> ahh makesense
08:23:41 <navaati> hi
08:24:16 <shapr> salut navaati, how's code?
08:24:46 <navaati> shapr, growing ! but with hiccups
08:25:06 <navaati> i'm using persistent and i'd like a newtype wrapper around Int for a field, using the same backend representation as Int
08:25:26 <shapr> I haven't used persistent :-( but it sounds like a cool thing to have!
08:25:46 <Snaek> hello m8
08:26:06 <navaati> however i can't use GeneralizedNewtypeDeriving (or something like that) because the PersistFieldSql is not public in the package
08:26:14 <navaati> is this supposed to be possible ?
08:26:48 <shapr> howdy Snaek, how's code?
08:27:22 <Snaek> ayy lmao
08:27:33 <shapr> navaati: random google result? http://stackoverflow.com/questions/28135414/store-existing-data-type-with-yesods-persistent
08:28:14 <navaati> shapr, tried it, but as it's intender for enums it turn my field into a VARCHAR in the base
08:28:35 <nitrix> Is safecopy the current recommendation for versioned serialization?
08:29:05 <shapr> navaati: aw, if you figure it out, write a blog post or put it on twitter?
08:30:27 <intothemountains> Given I have a type State that can be either Piece or Empty where Piece can be either Black or White, oh can I check some l is a Piece?
08:31:09 <intothemountains> s/ oh / how /
08:31:30 <warbo> intothemountains: which of those are types and which are constructors?
08:31:42 <intothemountains> data State = Piece | Empty
08:31:48 <intothemountains> data Piece = Black | White
08:32:03 <warbo> ah, you've defined *two* things called "Piece"
08:32:09 <intothemountains> Yep
08:32:27 <lyxia> data State = Piece Piece | Empty perhaps?
08:32:34 <shapr> intothemountains: wouldn't it be , yeah what lyxia said
08:32:54 <intothemountains> Oh, yes
08:32:56 <intothemountains> My bad
08:32:57 <warbo> your "State" is effectively a custom version of "Bool"
08:32:58 <intothemountains> That's how it is
08:33:15 <intothemountains> Yes
08:33:21 <kadoban> Why not use  Maybe Piece  instead of State?
08:33:33 <intothemountains> Because I have Maybe State
08:33:35 <intothemountains> :D
08:33:42 <intothemountains> The names are just examples
08:33:43 <Zemyla> You really want to have, like, State = PBlack | PWhite | Empty, because pattern matching is faster.
08:33:43 <warbo> in that case, "case l of { Piece Black -> .....; Piece White -> ....; Empty -> ..... }"
08:33:46 <intothemountains> Not the real thing
08:34:10 <intothemountains> Zemyla: But conceptually PBlack and PWhite belong to a same type
08:34:27 <warbo> (or use newlines and indentation instead of "{}" and ";")
08:34:48 <intothemountains> Could I do "l == (State Piece)" or something along the lines?
08:35:34 <warbo> you could do "l == Piece Black || l == Piece White"
08:35:46 <warbo> but pattern matching would be nicer
08:36:10 <intothemountains> A isPiece function it is then!
08:37:12 <warbo> intothemountains: be careful which things are types and which are constructors; they're both uppercase
08:37:33 <warbo> you can usually tell the difference based on which side of the "=" they're on when defined
08:37:49 <warbo> "data SomeType = Constructor 1 | Constructor2 | ..."
08:37:55 <ziman> hello, how do I pipe a chain of commands in Shake? Do I just need to bind and name every intermediate result as a lazy bytestring? Will these commands run in parallel, blocking appropriately to avoid filling up the memory with the intermediate data?
08:38:25 <warbo> isPiece Empty = False; isPiece (Piece _) = True
08:39:34 <intothemountains> warbo: exactly what i did :D
08:39:41 <ziman> surprisingly enough, I can't google anything relevant and the documentation does not seem to say anything explicitly
08:39:49 <lingxiao> hey all
08:40:00 <lingxiao> using conduit library, im folding over the stream and accumulating some value
08:40:31 <lingxiao> but the problem is that afterwards Id like to do something with the value
08:40:41 <lingxiao> however i cant await it since foldlC is a Consumer
08:42:12 <nitrix> _Piece = prism' Piece (\m -> case m of Piece x -> Just x; _ -> Nothing)
08:42:21 <nitrix> isn't _Piece
08:42:29 <nitrix> Prisms are nice :)
08:42:55 <navaati> shapr, no blog nor twitter, but if anyone wants to know, the PersistFieldSql class is actually public, it's just that ghc told me it was in a hidden module Database.Persist.Sql.Class whereas it was available in Database.Persist.Sql.
08:43:00 <navaati> Ah, misleading error messages…
08:44:26 <warbo> geekosaur glguy looks like process-extras is doing the job
08:45:50 <warbo> although like System.Process, I can't get stdout and exitcode without also getting stderr, but I'd rather pass on stderr manually than mess with threads manually
08:49:41 <Welkin> lol, OnkelTem 
08:49:55 <OnkelTem> Welkin: wut?
08:49:55 <Welkin> reminds me of the person who used the name UnkelTom or something
08:50:01 <Welkin> and didn't understand what it meant
08:50:58 <OnkelTem> Welkin: you're damn right! That's an overlay of Onkel Tom (Angelripper) - one of my favourite singers
08:51:17 <Welkin> lol what o.o
08:51:23 <OnkelTem> And my name is "Artiom" or "Tema" in short
08:51:38 <Welkin> I meant Uncle Tom's Cabin https://en.wikipedia.org/wiki/Uncle_Tom
08:51:39 <OnkelTem> Welkin: shame on you :)
08:52:10 <OnkelTem> Welkin: https://www.youtube.com/watch?v=og68bobzDo0
08:52:50 * hackagebot RepLib 0.5.4 - Generic programming library with representation types  https://hackage.haskell.org/package/RepLib-0.5.4 (sweirich)
08:53:12 <OnkelTem> Welkin: that Uncle Tom is a famous person, yeah. I've read the book in my youth
08:54:10 <maerwald> great, casual talk fits well in #haskell-offtopic btw
08:54:54 * OnkelTem has minded that this is #Haskell channel only now
08:55:43 <OnkelTem> (sings) so many different channels, so many different chats
08:57:09 <rcschm> hi i am trying to build some kind of models using records and i am still not sure how do i  have Eq instance for the following.
08:57:14 <rcschm> data Id      b     = Id { id :: b } deriving (Eq, Functor)
08:57:15 <rcschm> data Content a     = forall a b. Eq b => Content { contentId :: Id b, contentValue :: a }
08:57:32 <rcschm> thanks for any help or suggestion.
08:57:49 <lyxia> rcschm: how do you want to compare two Content a ?
08:58:03 <rcschm> just the id field.
08:58:33 <rcschm> the id is poly because it can encrypted, etc.
08:58:37 <rcschm> be
08:58:37 <lyxia> you can't guarantee that two Content a values have the same type of b value
08:59:20 <rcschm> then it would be false, that is what i think.
08:59:29 <lyxia> What's wrong with Content b a = Content (Id b) a
09:00:04 <rcschm> i thought of just exposing a and not b.
09:00:39 <rcschm> it would be more record wrapping the content as well.
09:01:17 <lyxia> But if you don't expose b you can't ever do anything with it.
09:01:20 <rcschm> it would be nice if we can just exposed what is relevant to each type of record and not exposing everything.
09:01:53 <rcschm> yes, i come to realize.
09:02:03 <rcschm> free theorem of sort.
09:04:58 <ryantrinkle> if i have a class C a b | a -> b
09:05:10 <ryantrinkle> is there any way to write a type family that expresses the functional dependency
09:05:21 <ryantrinkle> such that i can write T a ~ b?
09:05:55 <mpickering> You can use an associated type family and an equality constraint in the class context to express the same thing
09:06:02 <mpickering> If you don't want to use a fundep
09:06:40 <ryantrinkle> mpickering: well, i do want to use the fundep, but i'd like to have subclasses that don't also include all of the fundep's types in their own heads
09:06:54 <ryantrinkle> (those ones would expose it *only* as a type family)
09:07:01 <orion> If I parameterize a type, can I restrict the type variable to be those types which instantiate ToJSON?
09:07:34 <orion> Is that a poor design choice? If not, would I achieve this through GADTs?
09:07:51 <mpickering> I can't understand without a more complete example sorry
09:08:46 <orion> Or are type families what I actually want?
09:09:00 <ryantrinkle> mpickering: here's the situation i'm trying to arrive at: http://lpaste.net/3616893716326776832
09:09:29 <ryantrinkle> basically, Prerendered describes a monad that may or may not have JS support
09:10:09 <lyxia> orion: you can have this with GADTS: data T a where C :: ToJSON a => T a
09:10:21 <ryantrinkle> if it does, there's a phantom type that indicates the specific JS context (since different JS contexts' values can't mix)
09:10:45 <lyxia> orion: this requires you to pattern match to unwrap the ToJSON constraint though
09:11:13 <orion> lyxia: Could you show me an example of pattern matching to unwrap the constraint?
09:11:24 <ryantrinkle> but what i was hoping is that i could not expose the 'x' parameter on Prerendered
09:11:33 <ryantrinkle> of course, i could make its head Prerendered x m
09:11:58 <lyxia> orion: However I think the more common alternative is how containers does it, make the constraint appear on every function using your type.
09:12:20 <ryantrinkle> but it would be cleaner if i could avoid that
09:12:33 <orion> lyxia: Really all I'm doing is creating a data structure whose sole purpose is to be JSONified.
09:12:41 <pchiusano> anyone know where cabal by default looks for shared C libraries?
09:12:57 <ryantrinkle> pchiusano: on linux, i believe it uses pkgconfig
09:12:59 <mpickering> ryantrinkle: What is the precise problem using fundep, what fails to happen?
09:13:02 <pchiusano> am trying to install leveldb
09:13:13 <ryantrinkle> mpickering: it's just a usability thing for end-users of the library
09:13:24 <orion> pchiusano: You have the headers installed, right?
09:13:28 <pchiusano> am on osx
09:13:32 <ryantrinkle> there are some classes where it's convenient to use the fundep, and some where it's convenient not to
09:13:43 <ryantrinkle> from my perspective as an implementer, it doesn't really make a difference
09:13:49 <pchiusano> orion: ummm, I did `brew install leveldb`
09:14:03 <pchiusano> which resulted in some shared libs being placed in /usr/local/lib
09:14:12 <pchiusano> is there something else I need to do?
09:14:31 <orion> pchiusano: Are there headers installed in /usr/local/include?
09:15:08 <pchiusano> orion: yes
09:15:13 <lyxia> orion: f :: T a -> a -> Stuff ; f C a = {- here you can call toJSON on a -} ; f c a = {- here you can't -}
09:15:17 <mpickering> ryantrinkle: Sorry if I missed this but what currently doesn't work with the implementation? What is the error? It's not clear to me where you are stuck
09:15:40 <pchiusano> there's a /usr/local/include/leveldb directory with a bunch of headers
09:16:43 <mpickering> ryantrinkle: I simplified your example. does that show your problem still? http://lpaste.net/3616893716326776832
09:16:49 <sm> pchiusano: might need to add that dir with --extra-include-dir then
09:17:03 <pchiusano> sm: where does it look by default?
09:17:04 <ryantrinkle> mpickering: i'll put together a simpler example
09:17:42 <pchiusano> (also, aside, why the hell doesn't it TELL ME where it looks by default, rather than uselessly reporting "could not find leveldb C library")
09:17:44 <sm> the default search path does include /usr/local/include I'm pretty sure
09:17:53 <lyxia> orion: maybe   data SomeJSON where SomeJSON :: ToJSON a => a -> SomeJSON   is closer to what you want... though at that point I wonder why you're not simply storing the Value's directly.
09:17:58 <lingxiao> hey all
09:18:06 <lingxiao> i setup a project using stack
09:18:26 <pchiusano> sm: apparently it doesn't...
09:18:39 <pchiusano> or it would find the headers, right?
09:18:57 <sm> and if includes look like <leveldb/X.h>, it should. If they're like <X.h>, then not
09:19:35 <sm> adding -v3 may give more clues about where it's looking
09:19:52 <lingxiao> but why can't i import /src/Lib from /app/Main ?
09:20:08 <lingxiao> heres my cabal file: http://lpaste.net/178564
09:21:18 <athan> To implement a parser combinator monad over lists of characters [Char], how would you implement backtracking?
09:21:39 <athan> Right now, my `Parser = StateT ParserState (ExceptT ParserError Identity)`
09:22:07 <sm> lingxiao: I think Lib doesn't automatically reexport the imported modules, you have to write "module Core" in an explicit exports list
09:22:22 <athan> and `ParserState = ([Char],[Char])`, where the first side of the tuple is how many characters were parsed "so far", while the snd is "left to parse", if that makes sense
09:22:36 <lingxiao> how might the syntax look like sm?
09:22:44 <sm> I forget, check the docs
09:22:48 <athan> my question is, do I even need this left component of the tuple to implement backtracking-based parser combinators, like attoparsec?
09:22:54 <athan> backtracking-on-failure*
09:25:17 <orion> lyxia: What's the difference between data T a where C :: ToJSON a => T a -- and -- data SomeJSON where SomeJSON :: ToJSON a => a -> SomeJSON ?
09:25:45 <orion> Is the kind different?
09:25:58 <lyxia> orion: C is nullary, SomeJSON is unary
09:26:22 <orion> On the type level?
09:27:08 <dfeuer> Ping Cale
09:27:10 <lyxia> they are value-level constructors
09:27:51 * hackagebot huckleberry 0.9.1.0 - Haskell IOT on Intel Edison and other Linux computers.  https://hackage.haskell.org/package/huckleberry-0.9.1.0 (tkmsm)
09:28:28 <max3> can someone tell me why i'm getting "conflicting definitions" for b and c here http://pastebin.com/M6SrZhJf
09:29:33 <lyxia> max3: you can't have the same variable appear twice in a pattern.
09:29:49 <orion> lyxia: Ah, so I was correct in saying that those two types have different kinds.
09:29:59 <orion> The former being * -> *, the latter being *.
09:29:59 <max3> lyxia, so then how do i write down the data constructor for Pair in the (==) equation?
09:30:05 <lyxia> orion: what types?
09:30:13 <dfeuer> max3, you probably meant     Pair a b == Pair c d = a == c && b == d
09:30:17 <lyxia> orion: ah nvm
09:30:21 <lyxia> orion: yes
09:30:41 <orion> And, inherently the latter throws away information?
09:30:52 <lyxia> orion: I totally misunderstood your previous question.
09:30:55 <max3> dfeuer, how come it's legal in the type definition then?
09:30:55 <lyxia> yes
09:31:14 <max3> dfeuer, no not that btw, not tuple
09:31:33 <dfeuer> max3, because it means something very different in the type language? What do you mean "not tuple"?
09:31:54 <max3> dfeuer, the exercise in the book has data Pair a = Pair a a
09:32:02 <dfeuer> Yes, that's perfectly fine.
09:32:05 <max3> and data Tuple a b = Tuple a b
09:32:13 <dfeuer> Yes.
09:32:25 <dfeuer> max3, you seem to be confusing types with terms.
09:32:29 <max3> not exactly
09:32:37 <dfeuer> I don't really know how to fix that.
09:32:46 <dfeuer> I mean your understanding.
09:33:09 <dfeuer> The type    data Pair a = Pair a a   means that the Pair constructor must take two values of the same type.
09:33:14 <dfeuer> They don't need to have the same value.
09:33:22 <max3> right
09:33:23 <dfeuer> Pair 3 4   is fine.
09:33:27 <dfeuer> Pair 'a' 4  is not.
09:33:29 <max3> ah
09:33:43 <Profpatsch> Is it okay to abuse IsString like that?
09:33:56 <Profpatsch> data Foo { name :: Text, bar :: Bar, … }
09:33:58 <dfeuer> When you define ==, you need to check parallel values, just like you would for a tuple.
09:34:04 <max3> okay you're correct, while that was not my confusion, that does resolve my confusion
09:34:04 <dfeuer> Even though it's not a tuple.
09:34:11 <max3> since that was an implicit misunderstanding on my part
09:34:16 <max3> yes
09:34:18 <max3> thank you
09:34:24 <dfeuer> Cool.
09:34:48 <Profpatsch> instance IsString Foo where fromString "bla" = Foo { name = "bla", bar = … }?
09:35:34 <pyon> [] isn't a free monad, but “Free (Const a) k” is isomorphic to “[a]” for any “k”, right? What other non-free monads can be obtained from Free using this kind of clever hack?
09:35:45 <dfeuer> I *think* I can give my crazy WhenMissing type a Category instance and an Applicative instance.... Not sure they're useful. Pretty sure they're correct.
09:36:26 <dfeuer> Can I give it a Monad instance?
09:36:53 <dfeuer> Hrmmmm.
09:36:56 <pyon> dfeuer: Where's WhenMissing defined? :-O
09:37:15 <dfeuer> pyon, http://treeowl-containers-general-merge.bitballoon.com/data-map-lazy-merge
09:37:32 <pyon> Checking, thanks.
09:37:33 <dfeuer> pyon, would you like to see my instances?
09:37:39 <pyon> dfeuer: Yeah.
09:37:52 * hackagebot huckleberry 0.9.1.1 - Haskell IOT on Intel Edison and other Linux computers.  https://hackage.haskell.org/package/huckleberry-0.9.1.1 (tkmsm)
09:37:54 <pyon> Err, above, when I said “for any k”, I really meant “k ~ ()”.
09:38:04 <pyon> dfeuer: Checkcing.
09:38:16 <lpaste> dfeuer pasted “WhenMissing Category and Applicative” at http://lpaste.net/3520609650586157056
09:38:23 <pyon> Oh, that link was hackagebot, my bad.
09:38:25 <pyon> Now really checking
09:38:44 <geekosaur> Profpatsch, it's not really abuse if the ... is something sensible. if it's undefined then it's arguably abuse
09:39:31 <dfeuer> pyon, I believe the Category instance is very close to a Kleisli category for MaybeT or something.
09:40:18 <dfeuer> The Applicative instance is, I think, pretty Maybeish.
09:40:29 <dfeuer> Or MaybeTish. Whatever.
09:40:57 <Thra11> Can anyone recommend a package/function for parsing dates formatted according to RFC 822? Searching hackage suggests time-http should do this, but it requires older versions of various dependencies, at least one of which is marked as deprecated.
09:42:18 <dfeuer> pyon, any sense of it yet?
09:43:28 <pyon> Mmm... Not yet. :-|
09:43:33 <pchiusano> hmm how do I pass flags to packages being built as dependencies in stack?
09:43:33 <dfeuer> pyon, also ... hmmm ... I wonder if this Applicative instance can be optimized furth.er....
09:43:41 <dfeuer> Yeah, it probably can....
09:43:49 <pchiusano> as in, I am depending on leveldb-haskell
09:43:49 <orion> lyxia: What can I do with data FooType a where FooCons :: ToJSON a => FooType a -- that I can not do with -- data BarType where BarCons :: ToJSON a => a -> BarType ? In other words, what are the possible negative repercussions of throwing away information, as I do in BarType?
09:43:53 <dfeuer> Hrmmmmm....
09:44:08 <pchiusano> and need specify extra-lib-dirs when building it
09:44:24 <dfeuer> Or ... maybe not.
09:44:33 <dfeuer> But probably.
09:44:41 <dfeuer> Yes, almost surely.
09:45:04 <dfeuer> I only need to perform actions for the second map corresponding to keys in the first one....
09:45:25 <dfeuer> And that's actually the only way to make these pieces correspond correctly.
09:45:59 <dfeuer> Or ... hmmm.
09:46:13 <dfeuer> This is a bit complicated.
09:51:12 <pchiusano> okay, here is another question - in cabal, when specifying build-depends, can one specify flags that should be passed to the libraries being depended on?
09:53:42 <unit73e> is this the style guide everyone uses? https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
09:53:55 <unit73e> roughly
09:54:35 <lyxia> orion: if you don't know what the type of something is, as is the case when you deconstruct BarCons, there's not much you can do with it.
09:55:22 <Welkin> unit73e: yes
09:55:28 <orion> lyxia: Surely I can call toJSON on it though?
09:55:34 <kadoban> unit73e: Looks pretty much like what I do. I use 2-space indents though generally.
09:55:58 <orion> (Assuming an instance of ToJSON BarType)
09:55:58 <glguy> unit73e: it's pretty close, but there isn't a universe style that everyone uses
09:56:02 <lyxia> orion: right
09:56:24 <orion> lyxia: What is an example of something I can do with FooType that I can't do with BarType?
09:57:06 <lyxia> orion: FooType can contain a number, to which you can add 1.
09:57:18 <CubicE> So, apparently hspec is really badly behaved on windows console -_-
09:57:21 <lpaste> dfeuer revised “WhenMissing Category and Applicative”: “WhenMissing Category and Applicative” at http://lpaste.net/3520609650586157056
09:57:27 <dfeuer> pyon, I've edited it.
09:57:51 <CubicE> it just sets background color to black and foreground color to white after running, which is just a tad annoying if those weren't your original colors
09:58:11 <kadoban> Wow, why does it do that.
09:58:24 <unit73e> thanks guys
09:59:01 <pyon> dfeuer: Checking.
09:59:02 <CubicE> I assume they just didn't know that people ran conhost with themes other than the black&white you normally get with cmd?
09:59:39 <CubicE> that, or the method they use to get the previous colors is faulty
09:59:44 <orion> lyxia: What aspect of the addition operation allows that in FooType but not BarType?
09:59:47 <geekosaur> probably because there's no mechanism to set the original fg/bg? (amd neither windows nor unix terminal has a way to query the default or current fg/bg)
10:00:24 <dfeuer> Anyone else have a moment to check whether my Applicative instance makes sense?
10:00:49 <geekosaur> orion, the only thing you know about the value in BarType is it can toJSON; there's no way to know it can Num
10:00:59 <CubicE> geekosaur, but git manages to do colored output just fine without breaking anything
10:01:33 <CubicE> ...
10:02:02 <CubicE> Apparently the changes hspec made persist through closing and reopening the console too
10:02:25 <CubicE> that's actually kind of impressive
10:02:52 * hackagebot hscaffold 0.1.1.0 - Very simple file/directory structure scaffolding writer monad EDSL  https://hackage.haskell.org/package/hscaffold-0.1.1.0 (yamadapc)
10:02:53 <orion> geekosaur: Ah, so in other words the type variable 'a' in 'FooType a' can be inspected for other instances besides ToJSON?
10:03:09 <geekosaur> it's visible to users, so it can be known
10:03:19 <orion> I see.
10:03:24 <geekosaur> the one in BarType is hidden and the only thing visible about it is ToJSON
10:04:12 <orion> Right, so that would make it impossible to add, say, a NFData instance to BarType.
10:04:17 <geekosaur> more to the point: you have to specify the type for FooType, so you can specify anything you want including Num a => FooType a which is sufficient to allow (+)
10:04:32 <geekosaur> or FooType Int, or whatever
10:05:04 <geekosaur> BarType, once you "put something in", the only thing that can be known about it is ToJSON
10:05:17 <orion> Makes sense.
10:05:49 <nitrix> Instead of mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
10:05:52 <nitrix> Is there as:
10:06:01 <nitrix> mapM' :: (Traversable t, Monad m) => (a -> m b) -> m (t a) -> m (t b)
10:06:14 <nitrix> Where the traversable is wrapped in the monadic context too?
10:06:44 <nitrix> Otherwise I end up with two <- bindings, or >>= in my binding. 
10:06:45 <c_wraith> that's just adding in fmap and join. 
10:06:56 <nitrix> c_wraith: which is >>=
10:07:43 <c_wraith> join $ fmap (traverse foo) bar
10:08:12 <nitrix> natives <- mapM gameReadLink =<< engineObjectsAtLocation (coordinateMove direction location)
10:08:16 <nitrix> It just looks a little off.
10:08:34 <c_wraith> looks fine to me.. 
10:10:16 <nitrix> Alright then. Moving on :P
10:16:52 <CubicE> well thank god for powershell. Still submitting a bug report to hspec
10:18:21 <max3> so this http://pastebin.com/zpQq3Vq0 doesn't work i'm assuming because a and b aren't necessarily comparable types. is there somewhere i can specify that they should be?
10:19:18 <Cale> max3: That case should just be False
10:19:36 <max3> Cale, the first one?
10:19:50 <Cale> max3: Yeah, Hello and Goodbye don't match
10:20:10 <max3> Cale, i want that case to be true, like saying "Hello bob" "Goodbye bob"
10:20:34 <Cale> Maybe you want (Eq a) => Eq (EitherOr a a)
10:20:51 <the_2nd> I have issues with my IO action not happening, I guess I nested IO actions, but can't get it to compile otherwise : http://lpaste.net/8423724430001176576
10:21:01 <Cale> You'll need FlexibleInstances to write that
10:21:08 <maerwald> anyone else unable to install th-lift-instances? causes ghc panic here http://lpaste.net/178589
10:21:30 <max3> Cale, you might be right but is there no way to specify that the two parameters to a polymorphic type should be comparable ?
10:21:38 <kadoban> the_2nd: Remove the 'return $' ?
10:21:39 <the_2nd> but I need the outer-most return or it wont compile
10:21:49 <glguy> the_2nd: you're right, you're never executing the interesting action
10:22:02 <glguy> the outermost return is wrong
10:22:03 <the_2nd> kadoban, Couldn't match type ‘Either String’ with ‘IO’
10:22:34 <geekosaur> max3, if they are comparable then they are the same type
10:22:56 <the_2nd> glguy, removing it leaves me with : Couldn't match type ‘Either String’ with ‘IO’
10:22:58 <geekosaur> the_2nd, I don't see why (parsed :: Either String [Item]) is being used with >>=
10:23:09 <max3> geekosaur, is that true in some technical sense that I don't understand yet? Int and Integer are comparable but not the same type right?
10:23:10 <geekosaur> because that makes the monad Either String
10:23:19 <kadoban> Yeah, that doesn't really fit
10:23:19 <Cale> the_2nd: For any value x, the action return x is one which doesn't have any effect, but produces x as its result when executed.
10:23:37 <glguy> the_2nd: OK, then that's the actual bug to fix
10:23:51 <geekosaur> max3, Eq requires them to be the same type. there is no comparison function that will work across Int and Integer
10:23:57 <max3> interesting
10:24:06 <max3> okay
10:24:35 <geekosaur> ...you could of course try to define a typeclass Comparable and use it, but it's not going to be trivial
10:24:51 <Cale> max3: Types are all checked at compile time and don't exist at runtime. If you were comparing values of different types, you would statically know they're not the same, so you might as well have written False.
10:24:58 <the_2nd> geekosaur, how would you do it then?
10:25:06 <max3> strong typing will take a while to get used to
10:25:10 <Cale> the_2nd: What do you want this program to do?
10:25:36 <the_2nd> to "storeItems" when parsed was Right
10:25:46 <max3> thank you
10:26:02 <Cale> the_2nd: case parsed of Left e -> ... ; Right xs -> storeItems xs
10:26:12 <geekosaur> the_2nd, I'm not sure what the >>= is even trying to do there. as written, if parsed is monadic then the monad must be Either String
10:26:31 <Cale> the_2nd: Where "..." is some action of type IO ()
10:26:32 <geekosaur> if it's not supposed to be monadic then you may have wanted (.)
10:27:03 <maerwald> how can I show all package versions installed in a sandbox? like ghc-pkg list
10:27:29 <Cale> Perhaps something like  case parsed of Left e -> putStrLn e; Right xs -> storeItems xs
10:28:00 <Cale> maerwald: cabal sandbox hc-pkg list
10:28:43 <the_2nd> geekosaur, Cale, glguy this works : http://lpaste.net/7054116478076846080   is there a "shorter / nicer" way to write that?
10:29:41 <Cale> That's roughly how I would write it, except I might make it  storeItems . addItem newItem $ x
10:31:11 <Cale> You could use the 'either' function, but I usually find that when returning to code which makes use of that, I usually end up turning it back into a case expression anyway.
10:31:17 <geekosaur> either (return . const ()) (storeItems . addItem newItem) -- shorter, but I would not say nicer
10:31:38 <Welkin> jasper says the same thing
10:31:47 <Cale> I think that should be  const (return ())
10:31:51 <Cale> in the first argument
10:31:52 <Welkin> he always prefers using explicit case over either since it is easier to read
10:32:41 <Cale> either can be good in cases where you're not going to have to extend either of the branches
10:33:11 <Cale> Basically, if the thing you're doing is the mathematically correct thing, and there's practically no option about what code goes there.
10:34:00 <Cale> (which is not our situation here, which is why I'd prefer an explicit case expression)
10:40:10 <dfeuer> Hi Cale!
10:40:17 <dfeuer> Did you get my email?
10:40:34 * shapr gets jealous, also sends email to Cale
10:40:35 <maerwald> business opportunity?
10:40:45 <shapr> Would you like to mortgage your copy of GHC?
10:43:48 <Cale> dfeuer: Yeah, I haven't had time to attempt to prove that the Applicative instance is correct, but I think it makes sense that such instances would exist.
10:47:51 <dfeuer> Cale, one other question is whether the Functor instance is laziness-compatible with the Applicative one. If not, should I strengthen the Functor instance constraint to Monad f?
10:49:43 <dfeuer> And/or should I make the Applicative instance stricter and *then* do so.
10:49:44 <dfeuer> ?
10:50:26 <dfeuer> These things are very MaybeT-like, I think.
11:03:32 <lingxiao> hey all
11:03:35 <lingxiao> im trying to install stack on a remote server
11:03:41 <lingxiao> installing it manually
11:04:22 <lingxiao> ive gitcloned the folder to remote server
11:04:44 <lingxiao> now im not sure how to install it though
11:04:52 <cocreature> lingxiao: build it with cabal
11:05:01 <lingxiao> how so?
11:05:06 <lingxiao> what's the command?
11:05:51 <cocreature> you probably want a sandbox, so cabal sandbox init then cabal install --only-dependencies and then cabal install which will build and copy the binary to ~/.cabal/bin
11:07:09 <cocreature> "so" must really like being highlighted if she chose such a nick
11:14:49 <joe9> What should the type of throwExceptions be? It just throws the exceptions. I understand what the ghci is saying about the throwExceptions type not matching the expected IO a. but, I cannot figure out how to get a dummy a value.  error  http://bpaste.net/show/2bc5c6b98eab . code:  http://dpaste.com/1F3MRPE
11:16:42 <indicator> Is there a way to "discover" HUnitPlus tests, rather than listing them individually to build a TestSuite?
11:17:31 <jle`> joe9: are you sure you want fmap and not bind ?
11:17:42 <jle`> :t fmap putStrLn getLine
11:17:44 <lambdabot> IO (IO ())
11:17:45 <joe9> jle`: good point. let me check that.
11:18:12 <jle`> you can also use typed holes to see what type they're expecting
11:18:15 <jle`> error _ pure
11:18:17 <jle`> * either _ pure
11:18:38 <indicator> I tried hoogling to answer my own question but didn't get any hits.  I'm not sure if that's just because I'm not hoogling correctly
11:19:00 <joe9> jle`: or, I can change my function to http://bpaste.net/show/113abda822d7
11:19:25 <jle`> mhm
11:21:22 <joe9> jle`:  no that did not work   error http://bpaste.net/show/e462314eb0c9 http://dpaste.com/0W4XKX0 code
11:22:09 <jle`> try playing around with typed holes and either until you find a combination that works
11:22:26 <jle`> i think you're just returning 'IO a's and 'a's at the same time
11:22:32 <jle`> or IO (IO a)'s
11:22:42 <jle`> try using do notation, it usually simplifies things like this
11:23:01 <joe9> I want to make IO () -> IO a
11:23:08 <joe9> > pure
11:23:10 <lambdabot>      No instance for (Typeable f0)
11:23:10 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
11:23:10 <lambdabot>        arising from a use of ‘show_M529052653040729187429043’
11:24:01 <Ed_> Hello. How to print a list of strings seperate by white space without a new line character at the end?
11:24:29 <jle`> joe9: try using do notation and pattern matching instead of fmap and either
11:24:37 <lyxia> :t intercalate
11:24:38 <lambdabot> [a] -> [[a]] -> [a]
11:24:40 <jle`> remember that throwM returns something inside a monad
11:25:03 <lyxia> :t intersperse
11:25:05 <lambdabot> a -> [a] -> [a]
11:25:41 <joe9> jle`: I could use throwIO but, that will not solve my problem. let me try with do
11:26:20 <lyxia> > intercalate " " ["one", "two", "three"] -- Ed_ 
11:26:22 <lambdabot>  "one two three"
11:26:30 <Ed_> tyvm
11:27:41 <Welkin> > intersperse ' ' "pancake"
11:27:42 <lambdabot>  "p a n c a k e"
11:28:11 <glguy> > unwords ["one", "two", "three"]
11:28:13 <lambdabot>  "one two three"
11:28:26 <lyxia> oh right I forgot that one
11:28:29 <Welkin> lol
11:28:36 <Welkin> unwords = intercalate " "
11:28:44 <lyxia> indeed
11:29:11 <Welkin> because String is a list, it is a lot of fun to play with in haskell
11:29:37 <joe9> jle`: got it. bind helped.
11:30:06 <Ed_> intercalate "," ["one", "two", "three"] --
11:30:15 <Ed_> intercalate "," ["one", "two", "three"]
11:30:22 <Welkin> Ed_: forgot the > 
11:30:23 <joe9> jle`: now I understand what you were saying about IO (IO ())
11:30:29 <Ed_> > intercalate "," ["one", "two", "three"]
11:30:31 <lambdabot>  "one,two,three"
11:30:37 <Ed_> tyty
11:30:47 <Welkin> joe9: IO (IO ())?
11:30:52 <Welkin> how does that work?
11:31:56 <joe9> Welkin:  It did not. and that was what jle` was telling me about.
11:42:55 * hackagebot snap-server 1.0.1.0 - A web server for the Snap Framework  https://hackage.haskell.org/package/snap-server-1.0.1.0 (GregoryCollins)
11:44:48 <joe9> Is using MonadIO a better practice than using IO a?
11:46:55 <Clint> joe9: probably not
11:47:56 <jonored> I mean, what you get is accepting anything that has a "lift all the way to IO", but it's added complexity.
11:49:51 <implementation> joe9: on the one hand it enables people on IO-based monad transformer stacks to use your function without thinking about the lifts, but on the other hand, large monad transformer stacks might be considered an antipattern in many cases and you're encouraging that
11:51:07 <jle`> note that MonadIO doesn't necessarily have to do with transformer stacks
11:51:28 <jle`> most of my useful (non-IO) MonadIO instances I use aren't made from monad transformers
11:53:14 <ryantrinkle> mpickering: here's the simplest example i could come up with:
11:53:14 <ryantrinkle> http://lpaste.net/178637
11:53:31 <ryantrinkle> i have C, and i would really like to write D, or as a slightly worse alternative, D'
11:54:27 <ryantrinkle> however, in both cases, b is out of scope
11:54:50 <mniip> ryantrinkle, there's currently no way to upgrade a fundep to a tyfam
11:54:57 <ryantrinkle> mniip: ah, ok
11:55:03 <ryantrinkle> good to have a solid answer on that :)
11:55:04 <ryantrinkle> thanks
11:55:08 <mniip> there's a discussion on ghc trac about this
11:55:40 <mniip> https://ghc.haskell.org/trac/ghc/ticket/11534
11:55:48 <ryantrinkle> mniip: ok, cool; it's not so urgent - i'll just push extra type parameters everywhere for now :)
11:57:43 <mniip> well edwardk claims he tried doing that and the "extra type parameters" grew to about 8 unnecessary parameters on a typeclass
11:58:10 <ryantrinkle> mniip: one small corrollary issue is that it's difficult to do a deprecation cycle on this kind of stuff becuase replacing a class with a constraint synonym usually requires its *users* to add (GADTs or TypeFamilies) and FlexibleContexts to their code
11:58:30 <mniip> right
11:58:33 <ryantrinkle> i know that was a thoughtfully considered decision, and i don't necessarily disagree with the logic that was used, but it has burned me on occasion
12:00:18 <mniip> ryantrinkle, actually
12:01:51 <mniip> you can acctually replace 'class FunDep a b | a -> b' with 'class (Assoc a, b ~ Fam a) => FunDep a b | a -> b; instance (Assoc a, b ~ Fam a) => FunDep a b; class Assoc a where type Fam a;
12:01:52 <mniip> '
12:02:07 <mniip> without introducing backwards incompatibility
12:02:34 <zeapo> supRboyz: il y a moyen de la récupérer http://www.thewindowsclub.com/find-windows-product-key
12:02:43 <zeapo> oups, sorry wrong chat :/
12:08:08 <orion> In a type family, what's the proper way to require that all instances of the family instantiate NFData?
12:12:34 <mniip> associate it with a class?
12:13:37 <lpaste> Ed_ pasted “Quicksort” at http://lpaste.net/178646
12:13:53 <Ed_> It doesn't seem to work for negative numbers...
12:13:56 <mniip> that's not quicksort but ok
12:13:59 <Ed_> sorts negatives in opposite order
12:14:18 <jle`> Ed_: what do you mean opposite order?
12:14:19 <mniip> @letlpaste
12:14:20 <lambdabot>  I couldn't find any paste under that ID.
12:14:21 <mniip> @letlpaste 178646
12:14:24 <lambdabot>  Defined.
12:14:43 <mniip> > (quicksort [1,2,3,4], quicksort[-1,-2,-3,-4])
12:14:45 <lambdabot>  ([1,2,3,4],[-4,-3,-2,-1])
12:14:49 <mniip> looks good to me
12:14:50 <Ed_> quicksort ["-37.507","-3.263","40.079","27.999","65.213","-55.552"]
12:15:00 <Welkin> what...
12:15:00 <Ed_> > quicksort ["-37.507","-3.263","40.079","27.999","65.213","-55.552"]
12:15:02 <lambdabot>  ["-3.263","-37.507","-55.552","27.999","40.079","65.213"]
12:15:04 <Welkin> those are strings
12:15:06 <mniip> um
12:15:09 <mniip> yes those are strings
12:15:15 <mniip> you are comparing strings
12:15:19 <jle`> > sort ["hello","world","-10"]
12:15:21 <lambdabot>  ["-10","hello","world"]
12:15:21 <Ed_> haskell cant compare strings correctly?
12:15:27 <Welkin> it does
12:15:28 <mniip> it compares strings correctly
12:15:30 <mniip> i.e like strings
12:15:32 <jle`> haskell compares strings in a pretty sensible way
12:15:33 <geekosaur> strings are compared lexically, as strings are
12:15:34 <mniip> alphabetically
12:15:36 <Welkin> > ord '3'
12:15:38 <lambdabot>  51
12:15:39 <Welkin> > ord '4'
12:15:39 <mniip> errr
12:15:40 <jle`> like you'd find them in a dictionary
12:15:41 <lambdabot>  52
12:15:41 <mniip> lexicographically
12:15:46 <Welkin> it uses ord
12:15:51 <geekosaur> not assuming a string that contains a number is really a number; tis is not perl
12:16:07 <Ed_> also, how is that not quicksort?
12:16:09 <mniip> perl has strict distinction between those too
12:16:12 <mniip> < vs lt
12:16:22 <Welkin> Ed_: it's not inplace or on an array
12:16:40 <mniip> no the algorithm itself is wrong
12:16:41 <Ed_> link to proper implementation of quicksort in haskell?
12:16:43 <jle`> it's a bit of a technicality, but that implementation doesn't implement the actual quicksort algorithm
12:16:50 <joe9> Is there a "whenM" function to : (a -> m Bool) -> (a -> IO a) -> a -> IO a
12:16:58 <mniip> Ed_, one sec
12:17:01 <Ed_> ty
12:17:32 <Welkin> Ed_: write mergesort, it's fun and easy to write
12:17:50 <mniip> http://lpaste.net/175732
12:17:51 <Welkin> Data.List.sort is mergesort
12:17:55 <mniip> almost as ugly as in C
12:18:08 <dolio> How come mergesort is allowed to be on lists, and not copy things between mutable arrays?
12:18:10 <Ed_> But I wan't to understand why this implementation of semi-"quicksort" isn't fully correct? i.e. places negatives in the opposite order as they should be
12:18:28 <Welkin> Ed_: it is correct
12:18:34 <Welkin> you were just using it on strings instead of numbers
12:18:45 <jle`> > quicksort [-10,3,-7,2]
12:18:47 <lambdabot>  [-10,-7,2,3]
12:19:02 <jle`> > quicksort ["george", "mary", "susan", "jonathan"]
12:19:04 <lambdabot>  ["george","jonathan","mary","susan"]
12:19:06 <jle`> it works properly on strings :)
12:19:10 <Ed_> > "-1" < "-10"
12:19:12 <jle`> sorts them alphabetically as expected
12:19:12 <lambdabot>  True
12:19:15 <orion> mniip: This is what I'm trying to accomplish: http://lpaste.net/2769328705539932160
12:19:21 <Ed_> ah
12:19:22 <Ed_> i see
12:19:32 <mniip> > quicksort "hello, world!@#$%^&*()"
12:19:34 <lambdabot>  " !#$%&()*,@^dehllloorw"
12:19:36 <Welkin> Ed_: what made you think it would sort strings of number like numbers?
12:19:38 <Ed_> any quickfix to this or would I have to convert the strings to integers?
12:19:39 <jle`> Ed_: yes, because the string hyphen-one char is alphabetically before hyphen-one char-0 char
12:19:52 <Welkin> Ed_: no... why would you do that?
12:20:36 <Ed_> @Welkin so there's a way to do this without converting the strings to integers?
12:20:37 <lambdabot> Unknown command, try @list
12:20:37 <mniip> orion, is RPCMethod the family in question?
12:20:48 <jle`> Welkin: what are you trying to do?
12:20:49 <Welkin> Ed_: why would you convert strings to integers
12:20:52 <jle`> * Ed_
12:20:59 <orion> mniip: Yes.
12:21:00 <jle`> Ed_: are you trying to sort strings as the integers they represent?
12:21:05 <Ed_> yes
12:21:08 <jle`> then yes, it would make more sense to sort the actual integers
12:21:10 <mniip> orion, add NFData as a superclass to API
12:21:12 <jle`> instead of the strings
12:21:17 <Welkin> if you wanted to read in valus from the command line, you do that in another functions, then fed this function the Int or Integer values only
12:21:20 <jle`> like, why even
12:21:23 <mniip> Ed_, then you need sortWith
12:21:28 <mniip> or sortBy
12:21:37 <jle`> Ed_: that's like asking how to add strings as the integers they represented
12:21:46 <jle`> it's kind of a hint that you're using the wrong data type :)
12:21:49 <orion> mniip: Will that work in ToJSON as well?
12:21:57 <mniip> orion, er?
12:21:59 <orion> mniip: My instance for ToJSON isn't valid.
12:22:13 <jle`> Ed_: strings are definitely the wrong data type for this job
12:22:24 <jle`> not all types are useful for all situations :)
12:22:27 <mniip> jle`, I could see a valid use for using strings here
12:22:27 <Ed_> that is the input that I have to deal with.
12:22:31 <jonored> If you really need the string-encoded-integer behavior for some reason, you could newtype up an "integer represented as string", but that's really a stretch.
12:22:42 <mniip> jle`, imagine implementing sort -n
12:22:43 <Ed_> I am going through a text file. and was hoping to do this without the need to convert. but i learned my lesson
12:22:47 <mniip> can't really coerce 1.0 into 1
12:22:58 <mniip> :t sortOn
12:22:59 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
12:23:16 <jonored> ...right, or that.
12:23:23 <mniip> > sortOn (read :: String -> Double) ["-1", "-10", "-10.0"]
12:23:24 <lambdabot>  ["-10","-10.0","-1"]
12:23:27 <Welkin> read the strings as Integers, sort them, then `show` them
12:23:33 <jle`> usually you'd get the text file into the right type for the job, then do your operations on that type, and then convert that type to whatever output you'd want
12:24:35 <implementation> Ed_: you asked for a link to a proper quicksort implementation https://github.com/ghc/ghc/blob/5d98b8bf249fab9bb0be6c5d4e8ddd4578994abb/libraries/base/Data/OldList.hs#L939
12:24:54 <mniip> if you want to sort cases like ["1.2", "1.20"] deterministically, might want to use ((read :: String -> Double) &&& id) as a key instead
12:25:09 <implementation> Ed_: (if you scroll up, you can also see a merge sort and benchmark results)
12:25:17 <Ed_> Thank you implementation.
12:25:25 <jle`> or maybe you'd create a data type that has a meaningful comparison defined on it
12:25:32 <Ed_> Can I map "read x :: Int" over a list?
12:25:45 <jle`> Ed_: what happens when you try?
12:25:45 <Welkin> yes
12:25:45 <mniip> map (read :: String -> Int)
12:25:55 <mniip> map read [...] :: [Int]
12:26:12 <jle`> took away a potentially rewarding learning experience! :o
12:26:19 <EvilMachine> Hi. What’s the shortest way to achieve (x -> (y, x))? Like tuple sections ((y,) $ x) but without using them, since I found them to make the program very slow.
12:26:34 <Ed_> he did. he did..
12:26:38 <mniip> EvilMachine, (,)y
12:27:19 <Welkin> or just use `\y x -> (y, x)`
12:27:23 <Welkin> what's wrong with that?
12:27:24 <EvilMachine> mniip: lol, I *knew* it was something so simple I missed it… :) thank you mniip! :)
12:27:27 <lyxia> EvilMachine: \x -> (y, x) is faster than (y,) ?
12:27:29 <jle`> i feel like (y,) would desugar to (,) y anyways
12:27:30 <EvilMachine> Welkin: too long and ugly
12:27:31 <EvilMachine> :)
12:27:38 <EvilMachine> jle`: yes, it should
12:27:38 <jle`> or \x -> (y, x)
12:27:42 <jle`> have you tried benchmarking?
12:27:50 <implementation> @pl \y x -> (y,x)
12:27:51 <lambdabot> (,)
12:28:03 <implementation> @pl \x -> (y,x)
12:28:04 <lambdabot> (,) y
12:28:04 <EvilMachine> jle`: but when I removed a tuple section part from one of my programs, it got insanely much faster.
12:28:34 <mniip> do partially applied constructors have their own closure type?
12:28:38 <implementation> are you sure there were no other changes?
12:28:39 <mniip> that could explain the slowdown
12:28:41 <jle`> EvilMachine: what do you replace it with?
12:28:44 <mpickering> ryantrinkle: Glad you got your answer, sorry not to be of much use !
12:28:47 <Ed_> my first inclination to map "read x :: Int" over a list would be to do map (\x -> (read x :: Int)) ["1","2"]
12:28:59 <mniip> Ed_, that would work
12:29:00 <Welkin> aren't tuples strict?
12:29:02 <jle`> Ed_: that also works
12:29:12 <Ed_> any version better than the other?
12:29:14 <mniip> Welkin, no?
12:29:20 <jle`> Ed_: but also, a good first inclination would be to just not provide a type annotation at all unless ghc complains
12:29:25 <Welkin> nyazdani: is that a question?
12:29:27 <Welkin> er
12:29:29 <ryantrinkle> mpickering: yeah, it's good to know
12:29:30 <Welkin> mniip: ^
12:29:30 <mniip> Ed_, they are the same once they pass the typechecker
12:29:30 <jle`> in 90% of cases, the type can be inferred
12:29:39 <mniip> Welkin, no it's an answer?
12:29:41 <ryantrinkle> luckily the stuff i'm working on is fine either way
12:29:41 <mpickering> ryantrinkle: Is there a reason you don't want to write it using a type family in the first place?
12:29:42 <EvilMachine> jle`: I don’t know anymore. Nothing special though. I just found another way. Probably your suggestion, since I had forgotten about tuple constructors…
12:29:48 <Welkin> mniip: then why is there a question mark?
12:29:53 <mniip> because?
12:29:57 <ryantrinkle> mpickering: that just forces a slightly-gross deprecation cycle
12:30:08 <ryantrinkle> also, it's often much less convenient for the end user
12:30:09 <ryantrinkle> e.g.
12:30:15 <ryantrinkle> in reflex, we have MonadHold t m
12:30:19 <mpickering> I see
12:30:19 <Ed_> jle` what do you mean?
12:30:27 <Welkin> oh, that's right
12:30:30 <mniip> ryantrinkle, did you see my comment about replacing fundeps with tyfams in a backward compatible way?
12:30:31 <jle`> > read "True" || False
12:30:33 <lambdabot>  True
12:30:37 <jle`> no annotation needed :)
12:30:46 <Welkin> tuples are not strict, so in some cases you want to use !$ to force them
12:30:58 <ryantrinkle> the reason that's an MPTC instead of a type family is that writing MonadHold m => m (Behavior (Timeline m) a) is more verbose than MonadHold t m => m (Behavior t a)
12:31:13 <jle`> the magic of type inference
12:31:30 <jonored> Ed_: If you're just dumping that into GHCi, then there's not enough information for it to figure out the types, and you need to help; in a real program, how you're using the list of numbers and how you're getting the strings is probably enough to constrain what read has to do.
12:31:37 <EvilMachine> jle`: Although if you have a lot of code, zero type annotations have a tendency to make errors point to the wrong part of the code. I usually first add some types to check my assumptions. The important ones then stay.
12:31:42 <mpickering> mniip: Does that actually work and not break anything?
12:31:57 <mniip> edwardk is using it
12:32:04 <mniip> probably is
12:32:16 <mniip> probably does*
12:32:19 <jle`> EvilMachine: in general, yeah, but usually for something like 'read' it's not too bad
12:32:23 <Welkin> $!
12:32:28 <ryantrinkle> mniip: ah, nice
12:32:35 <EvilMachine> jle`: Yes.
12:32:36 <jle`> this actually might be one of the rare cases where read needs to be annotated
12:32:37 <ryantrinkle> i had missed it; thanks for pointing it out
12:32:41 <mpickering> Seems like a nice trick. 
12:32:45 <ryantrinkle> yeah
12:32:47 <mpickering> Good perspective ryantrinkle thanks
12:32:53 <EvilMachine> ok, gotta go again.
12:32:56 * hackagebot quack 0.0.0.1 - Convenience parser combinators for URI query strings  https://hackage.haskell.org/package/quack-0.0.0.1 (athanclark)
12:33:09 <mpickering> I might write a quick post about it as I haven't seen it before thanks mniip 
12:33:11 <ryantrinkle> i've used the class-with-one-instance trick, but i basically stopped using it once constraint kinds came out
12:33:19 <ryantrinkle> mpickering: np :)
12:35:50 <mniip> mpickering, I wouldn't claim credit over it as it's fairly trivial to come up with imo
12:36:07 <mpickering> Writing things down is always useful
12:37:32 <mniip> we just need a GHC hacker to implement https://ghc.haskell.org/trac/ghc/ticket/11534 :)
12:37:57 * hackagebot pandoc-crossref 0.2.3.0 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.2.3.0 (lierdakil)
12:39:33 <mpickering> mniip: Looks like it needs some much clearer specification first!
12:40:07 <mpickering> Another example, this trick http://chrisdone.com/posts/haskell-constraint-trick wasn't written down anywhere for ages
12:40:44 <mniip> well that's obvious
12:40:54 <mniip> "and thought, “Shenanigans! Why not just have this?”"
12:41:01 <mniip> I mean I can instantly see the difference
12:42:44 <mpickering> You are an expert though.. :)
12:42:48 <hsk3> Is there a convention in Haskell about which integer type to use? For instance, even if I know I'll only need non-negative integers in a value, should I still use Int as the type?
12:43:08 <mniip> oh am I
12:43:28 <mpickering> I would say so
12:43:41 <mniip> I was tricked by monomorphism restriction the other day :)
12:44:49 <hpc> that trick does resolve around (a ~ b) => f a not always being the same as f b
12:45:04 <hpc> which is counter-intuitive when you're in the mindset of equality being equality
12:45:14 <mniip> not really
12:45:24 <mniip> it's about instance picking
12:45:27 <mpickering> If you think you have nothing left to learn then you're probably not an expert 
12:45:51 <mpickering> hsk3: It depends, most people would just use Int, if they wanted more safety they might use a type which encoded that information
12:45:57 <mniip> instance (a ~ X) => Cls a tells you that X is an instance of Cls, and also that it is the only instance there will ever be
12:45:58 <hpc> mniip: behind the instance picking is that inequality though
12:46:41 <athan> mniip: Wooooah, singleton class instances through superclass constraints? Nice!
12:46:45 <mniip> it's pretty logical that first the instance is picked based on the structure, and then the instance constraints are applied
12:46:55 <athan> that's like a closed type family sorta!
12:47:00 <athan> (not at all)
12:47:11 <mpickering> It is when you know that is the precise specification 
12:47:18 <mniip> not really
12:47:23 <hpc> it really is
12:47:31 <mniip> I could see how that behavior comes from all the various things you can try to do with classes
12:47:34 <mpickering> I've never seen anyone convince someone else that something is obvious lol
12:47:36 <mniip> that would be computationally impossible
12:47:47 <Ed_> So I tried converting [ [ "1" ] , [ [ "2" ] , [ "3" ] ] ] into [ [ 1 ] , [ [ 2 ] , [ 3 ] ] ] with map (read :: [String] ->  [Int]) ... with no luck. What the correct way of converting nested lists of strings into integers? 
12:47:58 <mniip> Ed_, another map
12:48:07 <hpc> mniip: it's not about how obvious or logical it is, it's about programmers having the expectation of not having to care
12:48:09 <mpickering> Ed_: Think about the types!
12:48:10 <ryantrinkle> mpickering: isn't anyone trying to do that convincing wrong by definition?
12:48:16 <Ed_> i was thinking that also
12:48:17 <hpc> which is what equalities and laws give you
12:48:30 <hpc> who cares if it's (a >> b) >> c or a >> (b >> c), they're equal
12:48:40 <mpickering> ryantrinkle: exactly my point..
12:48:44 <ryantrinkle> :)
12:48:51 <hpc> but what you'd normally expect of type equality is NOT true here, and it makes you have to care
12:49:03 <hpc> which is surprising if you aren't already looking for it
12:49:11 <mniip> wellllll
12:49:24 <mniip> all constraints in haskell are simultaneously checks and inference drives
12:49:37 <mniip> one of the basic principles
12:50:07 <mniip> although that's probably more obvious to me than other people because I've spent a good chunk of code fighting with type inference
12:50:51 <hpc> you might also be considering ghc and not just what haskell specifies
12:51:01 <mniip> also
12:51:09 <mniip> 1471635936 [22:45:36] <hpc> mniip: behind the instance picking is that inequality though
12:51:22 <mniip> it's very logical if you read the instance out loud like
12:51:43 <mniip> anything is an instance of Cls, if it is X
12:51:57 <mniip> anything is an instance of Cls, if it is equal to X, orsmth
12:52:29 <mniip> the typechecker then can go and instantly match any use of Cls on that "anything" clause and place a constraint on the argument
12:52:34 <hpc> that's a terrible way to read it, it sounds like "you can get a model T in any color as long as it's black"
12:52:56 <hpc> :t (Just ()) :: (a ~ ()) => Maybe a
12:52:58 <lambdabot> Maybe ()
12:53:08 <mniip> that's a stronger sentence than "you can get model T in black"
12:53:09 <hpc> you can't explain that
12:53:28 <mniip> um
12:53:32 <mniip> I don't see the problem
12:53:33 <ryantrinkle> :t (Just undefined) :: (a ~ ()) => Maybe a
12:53:34 <lambdabot> Maybe ()
12:53:53 <hpc> mniip: that type equality doesn't reduce?
12:54:02 <hpc> that's not even a little weird to you?
12:54:30 <mniip> not in the context of instance picking mechanism
12:54:56 <jpl> :i fmap
12:55:04 <jpl> :t fmap
12:55:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:55:12 <hpc> mniip: and you can't imagine it being weird to anyone else either?
12:55:14 <mniip> hpc, I mean even your example with black makes perfect sense
12:55:22 <mniip> your statement is a much stronger one than mine
12:56:07 <Ed_> am I on the right track here to use two maps to convert nested list of strings into intgers?  map (\x -> read (map (\y -> read y :: Int) x) :: [Int]) [["1"],["2","3"]]
12:56:12 <Ed_> >  map (\x -> read (map (\y -> read y :: Int) x) :: [Int]) [["1"],["2","3"]]
12:56:12 <mniip> well, I might agree with the instance picking mechanism being not obvious
12:56:14 <mniip> but not ~
12:56:15 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘Int’
12:56:15 <lambdabot>      In the expression: read y :: Int
12:56:15 <lambdabot>      In the first argument of ‘map’, namely ‘(\ y -> read y :: Int)’
12:56:30 <mniip> Ed_, think about the types
12:57:17 <Ed_> I think the type we want is [[String]] -> [[Int]]
12:57:31 <mniip> Ed_, what is the type of (\x -> read x :: Int)
12:57:56 <Ed_> String -> Int
12:58:17 <mniip> what is the type of map (\x -> read x :: Int)
12:58:40 <Ed_> [String] -> [Int]
12:58:53 <mniip> I hope you're not querying that from ghci
12:59:01 <mniip> do you see the pattern now?
12:59:08 <Ed_> yea. i need another map. 
12:59:24 <mniip> well try to reason about it
12:59:31 <mniip> what did addition of map do to the type
12:59:36 <mniip> and where did you add the map
13:00:54 <Ed_> Got it. Thanks. just add an extra map on the outside..
13:01:08 <Ed_> > map (map (\x -> read x :: Int)) [["1"],["2","3"]] [[1],[2,3]]
13:01:10 <lambdabot>      Couldn't match expected type ‘[[Integer]] -> t’
13:01:10 <lambdabot>                  with actual type ‘[[Int]]’
13:01:10 <lambdabot>      The function ‘map’ is applied to three arguments,
13:01:21 <Ed_> oops. map (map (\x -> read x :: Int)) [["1"],["2","3"]]
13:01:33 <Ed_> > map (map (\x -> read x :: Int)) [["1"],["2","3"]]
13:01:35 <lambdabot>  [[1],[2,3]]
13:01:56 <orion> I've added instances for ToJSON and NFData for my associated data type, and the code compiled. However, I am not sure if what I've done is the best way to go about it: http://lpaste.net/8915958880765214720 -- can this code be improved? Namely, can I get rid of methodToText and methodToNF?
13:02:02 <Welkin> Ed_: you can also use (read :: String -> Int)
13:02:21 <Ed_> i guess that looks nicer?
13:02:27 <Welkin> Ed_: and map . map
13:02:48 <Ed_> whats the difference between map . map and map $ map
13:03:06 <mniip> one is composition and the other one is not valid
13:03:08 <Welkin> one is a compose function
13:03:09 <hpc> :t map . map
13:03:11 <lambdabot> (a -> b) -> [[a]] -> [[b]]
13:03:13 <hpc> :t map $ map
13:03:15 <lambdabot> [a -> b] -> [[a] -> [b]]
13:03:15 <mniip> the difference is
13:03:17 <Welkin> $ is just apply
13:03:22 <mniip> (map . map) x = map $ (map x)
13:03:24 <Welkin> so map $ map is map map
13:03:41 <Ed_> ah. i see
13:03:45 <mniip> I almost spelled the definition of . out there
13:03:50 <mniip> @src .
13:03:50 <lambdabot> (f . g) x = f (g x)
13:04:05 <mniip> although I'm sure the actual definition says \x -> instead
13:05:44 <Ed_> $ is usually the one used to remove parantheses?
13:05:49 <Welkin> yes
13:05:49 <Elision> yup
13:06:08 <Welkin> or to apply something to a value
13:06:11 <Welkin> like this
13:06:12 <Elision> it's funny seeing people ask about the difference between . and $, because now i can't really imagine how one would confuse them... but i can still remember being exactly that confused about how they were different
13:06:30 <Welkin> > map ($ 4) [(+1), (*2)]
13:06:32 <lambdabot>  [5,8]
13:06:40 <ryantrinkle> Elision: well you can sometimes substitute them freely :)
13:06:49 <ryantrinkle> f . g $ x == f $ g $ x
13:06:54 <Elision> ; )
13:07:02 <Elision> Welkin: that's.... bizarre
13:07:45 <Ed_> I like these definition the most: "(f . g) x = f (g x)", " map $ map = map map" and this one to bring them both together "(map . map) x = map $ (map x)"
13:07:58 * hackagebot llvm-pkg-config 0.0.0.2 - Generate Pkg-Config configuration file for LLVM  https://hackage.haskell.org/package/llvm-pkg-config-0.0.0.2 (HenningThielemann)
13:09:56 <mniip> Ed_, well
13:09:59 <mniip> @src $
13:09:59 <lambdabot> f $ x = f x
13:10:33 <Elision> that's a good definition :)
13:12:07 <ReinH> The $ doesn't really add anything
13:12:38 <johnw> yeah, it's the same operator as space, just different precedence
13:12:43 <ReinH> map (map x) = (map . map) x by definition of (.) directly, no extra step required
13:14:21 <Ed_> how to convert "1.23" into 1.23?
13:14:34 <mniip> I thought you already knew that?
13:14:55 <johnw> > read "1.23" :: Float
13:14:57 <lambdabot>  1.23
13:14:59 <Ed_> omg
13:14:59 <Ed_> yes
13:15:01 <Ed_> Float
13:15:04 <mniip> ew don't give him bad ideas
13:15:08 <mniip> use Double
13:15:15 <Welkin> ewe
13:15:21 <Ed_> lol
13:15:23 <Ed_> why
13:15:37 <Elision> there's no reason not to use doubles these days
13:15:53 <jonored> Well, almost entirely.
13:15:55 <ReinH> There are very specific niche reasons to not use doubles these days.
13:16:01 <ReinH> But by default, yes, use double.
13:16:04 <Welkin> when programming games, you want floats
13:16:14 <Welkin> unboxed :D
13:16:24 <ReinH> no one programs games in haskell
13:16:27 <ReinH> to a first approximation
13:16:30 <jonored> I'll bet you want to use a lot of floats with accelerate :)
13:16:41 <Elision> okay yes
13:17:58 * hackagebot llvm-pkg-config 0.0.1 - Generate Pkg-Config configuration file for LLVM  https://hackage.haskell.org/package/llvm-pkg-config-0.0.1 (HenningThielemann)
13:18:01 <mniip> Floats are relatively unoptimized in ghc
13:18:10 <mniip> as everything is aimed at doubles
13:18:57 * jonored proposes "only use floats if you know you really do definitely want floats".
13:21:46 <smilingbuddha> ?src ($)
13:21:46 <lambdabot> f $ x = f x
13:21:50 <ongy> FLoat being 32bit and Double 64 in GHC?
13:21:56 <Ed_> Just want to say thanks to everybody who answered my questions today. I definetely learned some things and I'm grateful to all of you. I hope you guys have a great weekend. 
13:22:25 <smilingbuddha> ?src (<*)
13:22:25 <lambdabot> (<*) = liftA2 const
13:26:10 <smilingbuddha> <(src) mappend
13:26:17 <smilingbuddha> <?(src) mappend
13:26:34 <smilingbuddha> ?src mappend
13:26:34 <lambdabot> Source not found. That's something I cannot allow to happen.
13:26:38 <edwardk> ReinH: we're fiddling with it off and on
13:26:57 <smilingbuddha> ?src length
13:26:58 <lambdabot> Source not found. Just try something else.
13:27:04 <ReinH> smilingbuddha: if you want to test things with lambdabot, you can query it via pm to avoid spamming the channel.
13:27:09 <smilingbuddha> ?src map
13:27:09 <lambdabot> map _ []     = []
13:27:09 <lambdabot> map f (x:xs) = f x : map f xs
13:27:12 <ReinH> edwardk: fiddling with what?
13:27:17 <edwardk> though i guess i can't say much, my latest experiments on that front are in c++ =/
13:27:24 <edwardk> games in haskell
13:27:24 <mniip> class Monoid m where mappend :: m -> m -> m
13:27:25 <ReinH> sorry, I lost the thread
13:27:32 <ReinH> ah right
13:27:38 <ReinH> heh
13:27:52 <mniip> length = go 0 where go n [] = n; go n (_:xs) = n $! go (n + 1) xs
13:27:58 * hackagebot llvm-ffi-tools 0.0 - Tools for maintaining the llvm-ffi package  https://hackage.haskell.org/package/llvm-ffi-tools-0.0 (HenningThielemann)
13:28:01 <edwardk> switched to c++ to do spike solutions to figure out what portions of things i needed to bind
13:28:04 <ReinH> edwardk: Lots of "look at this shiny new game deveopment framework" projects that have been abandoned or proved to be vaporware, is what I've seen :/
13:28:10 <edwardk> yep
13:28:40 <mniip> err
13:28:44 <mniip> n `seq`
13:28:48 <mniip> not $!
13:29:16 <gaurish_> ?src map
13:29:16 <lambdabot> map _ []     = []
13:29:16 <lambdabot> map f (x:xs) = f x : map f xs
13:29:27 <ReinH> gaurish_: please pm lambdabot to test things
13:30:32 <gaurish_> ok sorry...new to freenode :-) feeling my way around
13:30:47 <CubicE> ReinH, I think the problem is that most of these projects were born out of some cool idea for a framework rather than out of any needs that arose out of trying to actually make a game
13:31:08 <CubicE> ReinH, at least the fact that these things tend to have toy examples at best seems to indicate that to me
13:31:39 <ReinH> yep
13:31:59 <mniip> let's try to make a haskell game!
13:32:07 <mniip> on a second thought I'll use C++ instead
13:32:10 <orion> mniip: Hey, did you see my previous message?
13:32:15 <alercah> mniip: story of my life
13:32:17 <alercah> (not actually)
13:32:23 <Welkin> well the only problem is the lack of libraries besides sdl and opengl
13:32:29 <CubicE> mniip, theres some games that are made in or mostly in haskell
13:32:29 <Welkin> other languages have much better support
13:32:56 <CubicE> the hedge wars backend is written in haskell IIRC
13:32:57 <Welkin> it's just too much work to build something quickly in haskell
13:33:04 <mniip> well
13:33:28 <mniip> in haskell it's common to avoid boilerplate due to simply the modular nature of the language
13:33:45 <mniip> and I guess gamedev includes tons of boilerplate
13:33:54 <CubicE> it's just not terribly popular _because_ it's not terribly popular. Newtons first law of motion and all that
13:34:05 <mniip> and trying to modularize that away the haskell way tends to result in frameworks that suck
13:34:32 <mniip> e.g gloss
13:34:48 <mniip> fairly cool and easy to bootstrap if a toy example of a simple visualization is what you're after
13:35:37 <CubicE> I really don't think that's the problem. Ruby works mostly the same as other languages, and it's a fairly popular language and it's easy to make C bindings still very few people use ruby for game dev
13:35:55 <CubicE> performance is part of the reason of course, but that doesn't explain everything away
13:36:02 <CubicE> it's mostly just the lack of momentum
13:36:32 <mniip> well, idunno
13:37:07 <CubicE> There's lots of people doing game development in C++ or C#, and those also have frameworks that don't really work and that aren't used by anyone
13:37:07 <Welkin> CubicE: ruby sucks the worst of almost any language for games
13:37:12 <Welkin> the support is worse than in haskell
13:37:15 <Welkin> it has zero support
13:37:26 <CubicE> Welkin, how so?
13:37:31 <mniip> I have this little voice in me that goes "why would you write a webserver in bash, why would you write a CGI script in C++, why would you write a game in haskell"
13:37:55 <CubicE> There are a couple of high and low level bindings for game development in ruby
13:37:56 <Welkin> I'll eventually make something again in haskell
13:37:58 * hackagebot gasp 1.0.0.0 - A framework of algebraic classes  https://hackage.haskell.org/package/gasp-1.0.0.0 (JeanPhilippeBernardy)
13:38:00 * hackagebot gasp 1.0.1.0 - A framework of algebraic classes  https://hackage.haskell.org/package/gasp-1.0.1.0 (JeanPhilippeBernardy)
13:38:08 <Welkin> using lua and love2d for now though
13:38:17 <jle`> mniip: correctness, performance, refactorability, etc. ? :p
13:38:19 <Welkin> maybe I can write a portion of it in haskell?
13:38:30 <Zemyla> mniip: Why do people climb mountains?
13:38:32 <CubicE> and there is the fairly prominent example of RPG Maker, which uses Ruby as its main scripting language
13:38:53 <mniip> Zemyla, is climbing mountains useful to other people
13:39:10 <Zemyla> Is writing games? :P
13:39:21 <mniip> source of entertainment
13:39:32 <CubicE> mniip, 1) because you hate yourself, 2) because you hate php, 3) because you want to break the meta
13:40:02 <maerwald> mniip: it might be, it can be inspirational
13:40:15 <CubicE> well, commercial games are mostly for other people. But I'd venture to say it isn't inaccurate to say that most hobbyists are doing it because making games is fun
13:41:03 <Welkin> ludum dare is next weekend!
13:41:06 <Welkin> get ready
13:41:37 <mniip> maerwald, I'm yet to see thousands of people climbing mountains because that one person did it
13:41:50 <maerwald> that's not even unlikely imo
13:41:51 <CubicE> mniip, mount everest
13:42:01 <CubicE> is literally that
13:42:04 <maerwald> but we are going OT hard :P
13:42:19 <CubicE> nobody gave a damn for centuries, then someone climbed it and now everyone's doing it
13:42:22 <mniip> are we
13:42:35 <mniip> maerwald, we're just 2 cuils away from haskell
13:42:37 <Welkin> go climb Olympus Mons
13:42:39 <Welkin> on Mars
13:42:46 <Welkin> the tallest mountain in the solar system
13:43:54 <CubicE> ludum dare always makes me a bit depressed. All these people coming up with cool ideas
13:44:26 <mniip> *a small library in phoenix ceases to exist*
13:44:31 <mniip> ok that was 3 cuils
13:44:35 <CubicE> but at least they give good advice for prep "Make some art, import it, and draw it on screen. Make some sounds, import them, and play them on cue. If you’re using a new development tool, figure out the development cycle. Learn how to make a release too!" 
13:44:36 <CubicE> lol
13:44:53 <Welkin> yeah, you can't make anything if you don'
13:45:01 <Welkin> yeah, you can't make anything if you don't even have the tools for it or know how to use them
13:45:12 <Welkin> which is why doing LD in haskell seems kind of dumb at this point
13:45:23 <CubicE> that _sounds_ really obvious, but there's a surprising number of people that don't get that
13:45:33 <Welkin> someone make a good library
13:45:44 <CubicE> Welkin, well, unless you're one of those few people that actually has been making games with haskell
13:45:52 <mniip> I have some good libraries :)
13:45:57 <Welkin> CubicE: I made pong o.o
13:45:58 <CubicE> I bet someone has a really good internal library somewhere and just didn't think about sharing them
13:46:07 <CubicE> good enough
13:46:12 <CubicE> Go win LD
13:46:38 <mniip> LD = ?
13:46:50 <CubicE> Ludum Dare
13:46:56 <CubicE> the 48 hour make a game contest
13:47:32 <mniip> I guess
13:47:34 <Welkin> 48 hour?
13:47:38 <mniip> I can't really imagine making a functional game
13:47:39 <Welkin> it lastes 4 days
13:47:48 <CubicE> it does?
13:47:52 <mniip> only imperative concepts come to mind
13:48:01 <CubicE> I thought it was 48 hours
13:48:04 <CubicE> oh well then
13:48:09 <Welkin> mniip: I used FRP (netwire) in my pong experiment
13:48:14 <Welkin> ran into some problems o.o
13:48:51 <CubicE> Welkin, the problem I have with netwire is that dynamic sets of things seem to be really difficult with it
13:49:09 <mniip> when I think about game development in haskell the first thing I wonder about is whether I'll be using IORef, State, or MutableByteArray#
13:49:44 <CubicE> mniip, for uploading textures and for low level algorithms probably. Not for any of the high level game logic.
13:50:18 <mniip> depends on what kind of game we're talking
13:51:20 <CubicE> well, if it's the kind of game where performance is so critical that you need to get caching right all the time, doing it in haskell is probably not such a good idea
13:52:10 <Welkin> CubicE: eXtreme TetRis
13:52:40 <Ed_> Hello again folks. How do I get show 1.32 to give me 1.320
13:52:48 <Ed_> > show 1.320
13:52:50 <lambdabot>  "1.32"
13:53:05 <CubicE> Ed_, not at all. Show isn't meant for pretty printing
13:53:05 <Welkin> there is something for string formatting
13:53:12 <Ed_> ok
13:53:18 <glguy> > Numeric.showFFloat (Just 3) 1.32 ""
13:53:18 <CubicE> you need a proper string formatting function
13:53:19 <lambdabot>  "1.320"
13:53:25 <Welkin> ah
13:53:31 <Welkin> I think I remember using something like that
13:53:32 <Welkin> yeah
13:54:02 <glguy> > printf "%.3f" 1.32 :: String
13:54:05 <lambdabot>  "1.320"
13:54:15 <Ed_> WHAT?
13:54:23 <Ed_> how did you do that
13:54:30 <CubicE> do what
13:54:30 <Ed_> blasphemy
13:54:49 <Ed_> he used printf in ghci?
13:54:55 <glguy> If you don't know how to print 1.320 yet, you're not ready to declare what is or isn't blasphemy :)
13:54:59 <Welkin> Ed_: there is a library that provides printf
13:54:59 <CubicE> what's wrong with that?
13:55:09 <maerwald> printf is unsafe!
13:55:20 <maerwald> we need dependent types to make this properly (lol)
13:56:28 <CubicE> maerwald, (/) :: Fractional a => a -> a -> Maybe a
13:56:46 <Ed_> Or, how about when I convert the string to a double, can I have it include the required number of decimal places. I.e. in "map (\x -> read x :: Double) ["1.20", "1.300"]"
13:56:59 <maerwald> CubicE: erm, what?
13:57:24 <c_wraith> we could actually get type safe printf with one tiny addition to the current machinery - just need to be able to process symbols as type level lists of characters 
13:57:40 <CubicE> maerwald, just poking at the people that insist that all functions need to be total
13:59:06 <CubicE> c_wraith, or you could just use some TH like [|printf| %d times Hello %s!"]
13:59:57 <Ed_> to get to use Numberic.showFFloat do I "import Data.Numeric"?
14:00:26 <geekosaur> annoyingly, it's "import Numeric"
14:00:35 <geekosaur> hgets its own slot at the top for historical reasons
14:01:16 <CubicE> Ed_, you might want to take a look at haskell.org/hoogle if you haven't already
14:01:43 <mniip> maerwald, not unsafe
14:01:46 <mniip> rather error-ey
14:02:12 <Ed_> I have taken a look at it. There's a lot of info on there.
14:02:19 <CubicE> well, he means typesafe
14:02:23 <CubicE> probably
14:02:32 <mniip> you mean type-inferenceable
14:02:38 <CubicE> probably
14:02:44 <CubicE> my terminology game isn't the greatest
14:06:37 <Ed_> how would I map Numeric.showFFloat over a list if it's 3rd argument is ""
14:07:05 <Welkin> ?
14:07:16 <Ed_> > map (Numeric.showFFloat (Just 3)) [1.0, 1.23, 1.12] ""
14:07:18 <lambdabot>      Couldn't match expected type ‘[Char] -> t’
14:07:18 <lambdabot>                  with actual type ‘[ShowS]’
14:07:18 <lambdabot>      The function ‘map’ is applied to three arguments,
14:07:19 <Welkin> type String = [Char]
14:08:09 <Ed_> nvm. got it
14:08:21 <Ed_> map (\x ->  showFFloat (Just 3) x "") [1.32, 01]
14:23:00 * hackagebot wolf 0.2.8 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.2.8 (markfine)
14:23:14 <Welkin> o.o
14:23:27 <Welkin> what's with these names
14:23:42 <Welkin> name your package "table" and "dog" and "pencil" next why don't you
14:24:06 <ReinH> @hackage tables
14:24:06 <lambdabot> http://hackage.haskell.org/package/tables
14:27:10 <sm> I built three new haskell game engines yesterday (as in, ran "stack build" and ran them)
14:27:24 <sm> this one has a pretty demo: https://github.com/nitrix/lspace
14:27:35 <sm> things are slooowly improving
14:27:48 <linduxed> stack is really nice
14:28:53 <Gurkenglas> https://hackage.haskell.org/package/pointedalternative-0.1.0.0/candidate/docs/Control-Alternative-Pointed.html why don't some of the links work?
14:29:05 <Gurkenglas> (The ones in the class definition's documentation)
14:31:35 <Gurkenglas> (Any other combinators that coerceToNonempty can safely produce, but aren't covered by manyLazy and desperately?)
14:31:50 <geekosaur> links seem to work for me
14:32:10 <Gurkenglas> (and the other exported defs I suppose)
14:32:14 <geekosaur> oh, you mean the @ markup?
14:32:40 <Gurkenglas> Yes, and the link to coerceToNonempty, etc. Can I give documentation for a name without exporting it?
14:33:00 * hackagebot hscaffold 0.2.0.0 - Very simple file/directory structure scaffolding writer monad EDSL  https://hackage.haskell.org/package/hscaffold-0.2.0.0 (yamadapc)
14:33:17 <geekosaur> I don't think so. the @ markup looks like a bug (but possibly a difficult one to fix...)
14:33:34 <Sinestro> Is there an interface to COM in Haskell that actually works?
14:33:46 <sm> how do I see a unix-style timestamp (seconds since epoch) again ?
14:34:03 <Sinestro> I don't want to, but sometimes one is forced to do things one would rather not.
14:34:13 <Gurkenglas> Oh hey I guess the characteristic equations of manyLazy and someLazy don't work with these new types.
14:35:03 <mniip> that package seems broken
14:35:17 <mniip> you can't define an instance if the names aren't exported can you
14:35:45 <hexagoxel> Gurkenglas: syntax is @code here@ i think. you miss the "closing tag".
14:35:50 <sm> use the unix-time package I guess
14:36:08 <linduxed> sm: does one need to have an SDL package installed to make lspace build?
14:36:22 <linduxed> sm: or should stack build be able to complete without any extra packages?
14:36:41 <Welkin> linduxed: yes, it requires sdl2
14:36:43 <geekosaur> hmmm. Gurkenglas it occurs to me that @ might be a delimiter
14:36:46 <sm> linduxed: yes, you'll need to install sdl c libs yourself
14:36:47 <Welkin> which uses the sdl2 c library
14:36:58 <geekosaur> especially since in some places it is used as @x y z@ and others as @x
14:37:03 <geekosaur> which is ... difficult to parse
14:37:14 * sm . o O ( sooner or later someone's going to bolt this on to stack or cabal )
14:37:20 <Welkin> http://libsdl.org/download-2.0.php
14:37:49 <geekosaur> oh, right, and hexagoxel already noted that
14:38:11 <geekosaur> neither cabal nor stack knows how to install non-haskell libs (unless they are embedded in the haskell package that needs them)
14:38:44 <sm> geekosaur: good point that.. I wonder how hard it would be to embed sdl in the haskell package
14:39:02 <dbeacham> what are the best examples of using c2hs / ffi? mostly looking at foreign pointers / finalizers atm
14:39:12 <geekosaur> this is not really a solvable problem. should it know how to run apt-get, yum, pacman, etc. on linux and figure out which one your system uses? should it know how to run chocolatey on windows and fall back to finding windows dlls on some random site, or maybe build the C source itself?
14:40:20 <geekosaur> hm, chocolatey wouldnt help here given ms vs. gnu symbol tables. so it has to know whether you're msys2/pacman or cygwin's package foo or ... and still have to fall back to build from source
14:40:30 <geekosaur> "ick"
14:40:44 <Gurkenglas> It should do one or multiple of those things, because if it doesnt then the user has to do it and surely hell do worse
14:41:05 <Gurkenglas> Or at least hell be littering channels asking for help :P
14:41:31 <geekosaur> right, let me get right on the strong AI part needed for that...
14:41:47 <sm> Gurkenglas: that's right, we get this question multiple times daily now
14:41:49 <Welkin> damn... I had 2.66 GB free
14:41:59 <jonored> Gurkenglas: Well, for all but the windows users they'll do something like "apt-get install sdl-dev" :p
14:42:00 <Welkin> had to delete my VM that was 12 GB
14:42:35 <jonored> (and the "something like" part is a thing they've already been doing...)
14:43:00 * hackagebot ginger 0.2.8.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.2.8.0 (TobiasDammers)
14:44:12 <sm> until more capable tools arrive, haskell package authors can learn to communicate their C requirements better
14:44:38 <sm> eg how about something in Setup.hs to give better errors
14:45:18 <Gurkenglas> Even expert systems would do better than the user!
14:45:36 <linduxed> sm: i noticed that i've got the system packages "sdl" and "sdl2" installed, and the thing still doesn't build
14:45:49 <linduxed> sm: i probably need to somehow communicate the location of the packages
14:45:56 <Gurkenglas> And by expert systems I mean hardcoded scripts :P
14:45:56 * linduxed is on Arch, by the way
14:45:57 <Welkin> linduxed: which OS?
14:45:58 <geekosaur> if you are on fedora you need sdl2-devel
14:45:59 <Welkin> oh
14:46:00 <geekosaur> oh
14:46:05 <Welkin> I know that I need to specify the library
14:46:12 <Welkin> in the compile command
14:46:29 <Welkin> it is different depending on your OS
14:46:32 <sm> "this package needs sdl, which we can't install yet. Go to http://.. for instructions for your system"
14:46:35 <geekosaur> anyway if it let you install both of those (they are not compatible) then it installed them in different prefixes and you'll need to point to the sdl2 installation
14:46:38 <Welkin> er, the name of the library is even different
14:46:47 <geekosaur> and preferably remove sdl
14:46:55 <geekosaur> headers conflict
14:47:25 <geekosaur> libs differ so the sdl1 and sdl2 runtimes can coexist. dev stuff can't
14:48:01 * hackagebot type-operators 0.1.0.2 - Various type-level operators  https://hackage.haskell.org/package/type-operators-0.1.0.2 (Shou)
14:48:51 <Welkin> there is some flag to specifiy which extra libraries you want to compile with
14:49:14 <geekosaur> (and, having to know where the package installed in situations like this is why your magic script is not going to do the right thing...)
14:49:44 <jle`> Iceland_jack: what have you unleashed
14:49:57 <Welkin> I got this error when trying to install lspace Invalid package ID: "array-0.5.1.1 base-4.9.0.0 binary-0.8.3.0 bytestring-0.10.8.1"
14:50:05 <Welkin> sm: nitrix: ^
14:50:08 <geekosaur> guh
14:50:15 <Welkin> what does that even mean
14:50:26 <sm> tried stack clean; stack build ?
14:50:38 <geekosaur> someone quoted something they shouldn't have
14:51:04 <Welkin> yeah
14:51:06 <Welkin> no difference
14:51:15 <Squarism> I cannot find a uncons/head in Data.Set. Set having an Ord - my limited insight says they could be there? 
14:51:17 <sm> paste full transcript ?
14:51:21 <Welkin> that's it
14:51:34 <Welkin> there is nothing else
14:51:53 <Welkin> I used --install-ghc because it requires ghc 8.0.1, but other than that, nothing
14:51:55 <sm> by transcript I mean command and output
14:52:01 <sm> it saves time
14:52:01 <jle`> Squarism: could be defined, but probably does not make too much sense as an operation
14:52:13 <jle`> Squarism: (head . toList) would probably be more meaningful
14:52:13 <Welkin> "stack build" gives me that error
14:52:15 <Welkin> nothing else shows up
14:52:29 <hexagoxel> Squarism: deleteFindMin
14:52:32 <jle`> sm: actually, there's findMin
14:52:37 <jle`> nvm v.v
14:52:47 <jle`> Squarism: uncons is "minView"
14:52:52 <Welkin> jle`: you always have the most triangular eyelids
14:52:53 <jle`> > minView (S.fromList [1..10])
14:52:54 <lambdabot>      Not in scope: ‘minView’
14:52:54 <lambdabot>      Perhaps you meant one of these:
14:52:54 <lambdabot>        ‘Data.IntMap.minView’ (imported from Data.IntMap),
14:53:01 <jle`> > S.minView (S.fromList [1..10])
14:53:02 <Squarism> jle`, hexagoxel : thanks
14:53:03 <lambdabot>  Just (1,fromList [2,3,4,5,6,7,8,9,10])
14:53:13 <jle`> Welkin: i try
14:53:18 <Welkin> lol
14:53:22 <Squarism> hexagoxel, couldnt help but lol on that name.
14:53:28 <Welkin> Set.findMin is used as a minheap
14:53:29 <Welkin> haha
14:53:40 <Welkin> er
14:53:42 <Welkin> minView
14:54:06 <Squarism> Welkin, ah.. can live with that
14:55:03 <Welkin> so anyone know anything about this weird error?
14:55:17 <geekosaur> fwiw I don't see that string anywhere in the package. I'm tempted to say stack issue of some kind
14:55:24 <Squarism> Hmm.. sometimes you just want "a list with a unique constraint" - The price of Set is a completely different api
14:55:27 <Squarism> =/
14:55:59 <Welkin> should I update stack?
14:56:56 <Welkin> wtf o.o
14:56:58 <geekosaur> probably, yes. ghc8 changed how package ids work
14:57:01 <Welkin> I typed `stack upgrade`
14:57:01 <geekosaur> iirc
14:57:07 <Welkin> and now it is installing another copy of ghc
14:57:12 <geekosaur> o.O
14:57:18 <Welkin> even though I already have many installed, including the version it is installing
14:57:21 <Welkin> 7.10.3
14:57:26 <geekosaur> /o\
14:57:28 <maerwald> welcome to stack, the new user friendliness
14:59:06 <Cale> I wish so much that parallel ghc was deterministic
14:59:30 <Welkin> why is it doing this
14:59:39 <Welkin> reinstalling ghc 7.10.3 and all of base
14:59:48 <jle`> Cale: do you mean parallel compilation or parallel runtime
14:59:56 <Cale> parallel compilation
14:59:59 <Welkin> I just want to upgrade the stack binary...
15:00:15 <jle`> Welkin: it might be compiling stack
15:00:16 <Cale> We can't use GHC's -j flag because it results in nondeterministic hashes of the result
15:00:40 <Welkin> screw that
15:00:48 <Welkin> I'll just download the 10 mb binary that already exists
15:00:50 <hexagoxel> (cabal-install would not do such things. mainly because there is no "cabal upgrade"..)
15:01:11 <jle`> cabal install cabal-install would do it :p
15:01:20 <jle`> that's how i used to upgrade cabal at least >_>
15:01:28 <jle`> (that's how cabal suggests you upgrade itself)
15:02:31 <geekosaur> yes, but it doesn't install a new ghc first
15:02:37 <Welkin> I'm using stack 0.1.5
15:02:37 <Welkin> lol
15:02:45 <Welkin> the newest is 1.1.2
15:02:48 <geekosaur> that sounds ... self-inflicted
15:03:03 <geekosaur> I think I'd do that upgrade by downloading a new one
15:03:21 <geekosaur> (except instead I have the repo in /etc/apt/sources.list.d :p )
15:03:35 <sm> installing the official binary will be much faster than building it
15:04:18 <jle`> but also less satisfying
15:04:22 <Welkin> I always get the symlink parameters backward too
15:04:29 <Welkin> lol jle` 
15:04:35 <Welkin> more satisfying
15:04:40 <sm> also I guess binaries aren't a thing on Arch
15:04:45 <Welkin> because I don't have to wait 45-60 minutes to compile
15:04:49 * geekosaur never has that problem... but then dates from when cp, ln, and mv were hard links to the same command
15:04:59 <geekosaur> so it was not surprising they all worked the same way
15:05:17 <sm> Welkin: if you would be stack building new haskell toys daily like a good haskeller, this would be much quicker
15:06:11 <Welkin> I haven't compiled anything in haskell in ages
15:06:15 <sm> and I thought Arch users loved waiting for compiles
15:06:42 <Welkin> I am using macos o.o
15:06:48 <Welkin> and xubuntu
15:07:06 <sm> Welkin: oh! sorry. I misread a comment from linduxed
15:07:41 <Welkin> Did not find .cabal file for exceptions-0.8.2.1 with Git SHA of c7c51e5f975407adb24b9c7ed0ad3cf55ef1bb7f
15:07:44 <Welkin> Right Nothing
15:07:45 <Welkin> lol what is this
15:07:53 <Welkin> `Right Nothing`
15:08:15 <hexagoxel> Either (Maybe a) ?
15:08:27 <hexagoxel> (scnr)
15:08:29 <Welkin> no, that printed out to the console while installing packages
15:08:33 <sm> Welkin: that's a stack bug, ignore it
15:08:51 <Welkin> it's not a bug! it's a feature!
15:10:21 <sm> brew install sdl2, brew install haskell-stack, git clone lspace, stack build, stack exec lspace
15:10:38 <Welkin> I only use brew for non-haskell things
15:10:49 <Welkin> I just grab the .dmg for sdl2 too
15:11:31 <Welkin> actually, most of brew is outdated
15:11:45 <Welkin> it's fine for utilities though
15:15:35 <Welkin> sm: got another error
15:15:44 <Welkin> it requires more than sdl2, also sdl2-ttf
15:16:12 <Welkin> also sdl2-image
15:16:22 <sm> yes, I would install all of them
15:16:35 <sm> that's "sdl2" IMHO
15:18:14 <CubicE> sm, I wouldn't necessarily say so. The other libraries are kind of like "sdl-contrib" if you will
15:19:28 <sm> I think that's a useful distinction for a developer, not so much for someone trying to install haskell games
15:20:16 <CubicE> I use JuicyPixels instead of sdl image right now because I couldn't find an sdl image binding that was actively maintained
15:20:51 * sm updates the recipe: brew install sdl2 sdl2_gfx sdl2_image sdl2_mixer sdl2_net sdl2_ttf haskell-stack && git clone https://github.com/nitrix/lspace && cd lspace && stack build && stack exec lspace
15:21:08 <izohask> fmap f . p
15:21:12 <izohask> how do you read this ? 
15:21:56 <CubicE> the pointful reading is \x -> fmap f (p x)
15:22:00 * hexagoxel is tempted to reply "with my eyes"
15:22:31 <pikajude> hexagoxel: good thing you didn't
15:23:05 <izohask> CubicE: this seems much easier to understand
15:23:05 <Welkin> well
15:23:10 <Welkin> I'm not bulding this game it seems
15:23:23 <Welkin> it still cannot find sdl2_image or sdl2_ttf even though I installed them
15:23:37 <CubicE> Welkin, what does pkgconfig say?
15:23:39 <izohask> how did you convert (fmap f .) p to \x -> fmap f (p x)  ? 
15:23:41 <CubicE> pkg-config
15:23:56 <Welkin> setup-Simple-Cabal-1.24.0.0-ghc-8.0.1: The pkg-config package 'SDL2_image' version >=2.0.0 is required but it could not be found.
15:24:31 <CubicE> izohask, f . g = \x -> f (g x)
15:25:05 <CubicE> that's just how . is defined (or specified rather, not sure what it looks like in code, although probably not too different)
15:25:20 <sm> have you got a /usr/local/include/SDL2/SDL_image.h ?
15:25:31 <hexagoxel> izohask: fmap f . p === (fmap f) . p === (.) (fmap f) (p)
15:25:53 <Welkin> no, on osx it goes in /Library/Frameworks/
15:25:54 <hexagoxel> (if parsing is the issue, sorry if my guess is wrong)
15:26:10 <sm> Welkin: ah, because you're messing with unreliable dmgs :)
15:26:34 <sm> brew installs things in a place stack/cabal see by default
15:26:59 <hexagoxel> pikajude: better? :)
15:27:12 <pikajude> 👍
15:28:17 <CubicE> Welkin, what does pkg-config --libs SDL2_image say?
15:28:20 <Welkin> sm: brew is outdated though
15:28:28 <izohask> uh got it... thnank you all 
15:28:29 <sm> in what sense ?
15:28:59 <Welkin> CubicE: not found
15:29:11 <Welkin> sm: it is behind the releases
15:29:34 <CubicE> Welkin, in that case probably a screwy install. You can try manually adding a pkg-config config https://people.freedesktop.org/~dbn/pkg-config-guide.html
15:29:35 <Welkin> but this is how I used sdl2 before just fine
15:29:49 <Welkin> it should find it in /Library/Frameworks, right?
15:30:06 <sm> Welkin: what releases ? It seems to have the latest stable sdl2
15:30:13 <CubicE> Welkin, if pkg config can't find it then the sdl packages can't either
15:30:13 <sm> 2.0.4
15:31:17 <Welkin> oh, I thoguht it said 2.0.3
15:31:29 <Welkin> it looks like I did install sdl2 2.0.3 through brew
15:31:39 <sm> that is going to be perfectly fine for haskell sdl2 libs
15:31:45 <Welkin> but also have the .Framework package in /Library/Frameworks
15:32:32 <Welkin> oh well, brew it is then
15:35:48 <Welkin> how do you play this game o.o
15:35:54 <Welkin> it's a little astronaut with a box
15:36:27 <CubicE> Welkin, what game
15:36:32 <Welkin> lspace
15:36:36 <Welkin> https://github.com/nitrix/lspace
15:36:37 <sm> wasd moves the guy, cursor keys pan the view. Note the parallax when you do that
15:36:40 <Welkin> the thing I was trying to build
15:36:45 <sm> and, congrats :)
15:36:53 <sm> here's another: git clone https://github.com/schell/odin && cd odin && stack build && stack exec entity
15:37:20 <sm> Welkin: with lspace, also note how it's persistent when you quit and restart
15:37:30 <sm> it's an interesting lib
15:37:44 <Welkin> what else does it do?
15:38:08 <CubicE> sm, is that configurable? Because I imagine auto persistence could get annoying easily if that's not actually what you want
15:38:10 <Welkin> yeah I know about schell's odin
15:38:25 <sm> Welkin: nitrix will tell you all about it
15:38:40 <sm> or see #haskell-game log from yesterday
15:40:07 <sm> CubicE: I'm sure. Also, it persists to json which you can edit
15:40:23 <Welkin> I can't move the player and the camera at the same time
15:42:50 <sm> your keyboard probably doesn't support it
15:43:09 <Welkin> what...
15:43:20 <Welkin> I can't move in multiple directions at once either
15:43:26 <Welkin> must be the way he wrote the input
15:43:38 <Welkin> up-right for example
15:43:51 <CubicE> oh, I thought this lspace thing was supposed to be an engine, but it's a full game?
15:44:14 <sm> Welkin: true
15:44:25 <Welkin> should use smooth scrolling
15:44:30 <Welkin> it scrolls by tile now
15:44:39 <sm> CubicE: it's mostly engine with a little game prototype
15:45:13 <CubicE> huh, the description says it's a game though. Is the author lying to me? lul
15:45:20 <Welkin> yeah
15:45:25 <Welkin> nitrix is a troll
15:45:26 <sm> I think that's the best way to develop haskell games/engines right now - one or more example games plus engine in one package
15:46:06 <Welkin> how do I exit the game?
15:46:08 <Welkin> o.o
15:46:12 <sm> e
15:47:54 <CubicE> well yes, but it doesn't actually contain a library or anything. It's just an executable that... apparently consumes the json files in the demo folder?
15:48:52 <EvilMachine> Is there something to limit the total number of open files at any given time? (Preferably with an interface as nice as rateLimitInvocation.)
15:49:43 <CubicE> EvilMachine, do you mean ulimit? I doubt the RTS exposes that functionality directly though. What are you trying to write, a sandbox?
15:49:57 <EvilMachine> I have a lot of parallel file reads and writes, and I want an IO function that can delay any read/write call until <x files are open.
15:50:52 <CubicE> EvilMachine, I can't help but think you're probably approaching this the wrong way
15:50:56 <EvilMachine> CubicE: No, the opposite. ulimit keeps me from opening crazy many files. I don’t want to open that many files at the same time. I want to wait with opening another file, until the other files are closed (asychronously).
15:51:24 <CubicE> what problem are you actually trying to solve here?
15:51:40 <EvilMachine> CubicE: please go away
15:51:58 * EvilMachine sighs.
15:52:59 <EvilMachine> I love people who misunderstand the opposite of what you mean, and then when you correct them, they stick with it anyway. Waste of time.
15:53:25 <hexagoxel> woah, i don't think CubicE has any bad intentions.
15:53:31 <Welkin> he quit
15:53:32 <Welkin> kik
15:53:34 <Welkin> lol
15:53:40 <CubicE> well, someone has gotten off the wrong foot today
15:53:44 <Welkin> people do that sometimes
15:54:03 <Welkin> I tried to help someone recently (a couple months ago) who was angry at me for trying to help
15:54:28 <hexagoxel> (i also think that EvilMachine's issue seemed valid, without need to X/Y..)
15:55:33 <hexagoxel> (if you want to stop trying to open files before running into ulimit-IO-Exceptions or something.)
15:56:32 <CubicE> I _guess_ that that was what he was trying to do, but I wanted some clarification. Apparently asking for details is offensive
16:00:05 <pavonia> Are the functions allocating temporary space from the Foreign modules all safe in the sense that they release the memory if an exception occurs within the passed action?
16:00:24 <monochrom> yes.
16:00:33 <CubicE> pavonia, like unsafeWith? Those are safe afaik
16:00:51 <monochrom> wait, there is unsafeWith?!
16:00:57 <CubicE> no wait
16:01:00 <CubicE> that was vector
16:01:09 <monochrom> OK good
16:01:19 <CubicE> I forget the name of the function I was talking about
16:01:27 <CubicE> but we're probably talking about the same thing
16:01:34 <monochrom> alloca is an example.
16:01:48 <pavonia> I mean allocaArray and such
16:02:12 <monochrom> yes. they do what you said.
16:02:54 <pavonia> That's good
16:08:49 <Kaidelong> hey, I am dabbling with a DSL for representing cost-benefit analysis problems and allowing them to be solved. Is there a computer-algebra-system for Haskell that I could use as it's "runtime"?
16:09:24 <CubicE> what do you need it to be able to do?
16:09:55 <Kaidelong> discounting, error terms, opportunity cost (comparing alternatives) would be the three big things
16:10:08 <Kaidelong> just getting calculus might be good enough, in which case I could use ad or a similar library
16:10:42 <Kaidelong> I also might like to support monte-carlo simulations with it
16:10:50 <joncol> Hello, I'm having some problems with a parser (using Parsec) that I'm working on. I've created a gist: https://gist.github.com/joncol/8066ea2b7a42d5fa518b6d1dea2f0dfc. Basically, the problem is that with the "trailing text" (see the example input data) at the end of the file, the parser complains that it expects a leading "**" (my custom error message) instead of EOF. I'm don't understand why the 
16:10:56 <joncol> recursive step on line 30 doesn't work here. When removing the "trailing text" line, everything works fine.
16:10:58 <Kaidelong> I could just tie random-fu in for that, though
16:11:29 <Squarism> is there a way to get the number of compile errors printed? 
16:11:42 <Squarism> when doing "stack build"
16:13:42 <joncol> ...Is this too much code to post in a gist, or would anyone care to take a look?
16:18:03 <ReinH> joncol: can you pare it down to a minimal test case?
16:18:35 <joncol> ReinH: I can try
16:23:03 * hackagebot hjsmin 0.2.0.2 - Haskell implementation of a javascript minifier  https://hackage.haskell.org/package/hjsmin-0.2.0.2 (ErikDeCastroLopo)
16:23:28 <Gurkenglas> joncol, your recursive thingy that anything followed by one also counts as a one. But that trailing dummy text doesnt have a one after it, so that doesnt help.
16:23:35 <Gurkenglas> *thingy says that
16:24:39 <Squarism> noone? Possible to get some nice report from stack when building? 
16:26:34 <Gurkenglas> Oh, you expected to fail, but in another way. Nevermind me then.
16:26:46 <sm> Squarism: you mean for dependencies ? how about -v
16:27:52 <Squarism> no for compile errors.. just replaced some List's with Set's -> 83 compile errors in my testsuite
16:27:57 <Squarism> Fun night
16:30:30 <joncol> I simplified the gist radically, and I think I still have the problem isolated: https://gist.github.com/joncol/8066ea2b7a42d5fa518b6d1dea2f0dfc
16:31:04 <joncol> When trying to parse "1234" it works, but when parsing "1234\n" it fails.
16:31:29 <sm> Squarism: "stack test" shows me compile errors
16:31:31 <hexagoxel> joncol: see what Gurkenglas said above.
16:31:41 <joncol> Gurkenglas: Yes, that seems reasonable. But how to fix it :)?
16:32:28 <Squarism> sm, sure. For me too. But when you have 83 errors it can be nice with a summary saying how many you have left
16:33:21 <Squarism> ...and not having to do : stack test 2>&1 | grep "Tests.hs" | wc -l
16:33:38 <sm> ghcid shows just a screenful, if you can figure out how to invoke it
16:33:53 <sm> ghcid -c 'stack ghci :TESTSUITENAME' might work
16:35:22 <sm> does GHC even support that (counting all errors ?) I don't think so
16:35:36 <Squarism> ok
16:35:39 <sm> sometimes it'll report more than one at once, but not always
16:37:11 <hexagoxel> joncol: maybe something along "parseExam = (eof $> []) <|> (liftM2 (:) parseMultiChoiceQuestion parseExam) <|> (P.anyChar *> parseExam)"
16:39:26 <joncol> hexagoxel: what's ($>)?
16:39:28 <sm> Squarism: it would be a nice feature though. But I suspect it's not practical
16:39:40 <hexagoxel> @hoogle ($>)
16:39:42 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
16:39:42 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
16:39:42 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
16:40:13 <hexagoxel> joncol: http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Functor.html#v:-36--62-
16:40:15 <joncol> I'm not sure I've seen the "half" version.
16:41:23 <hexagoxel> ($> x) is like (*> return x)
16:41:38 <joncol> Cool, thx
16:41:39 <Gurkenglas> :t ($>)
16:41:41 <lambdabot> Functor f => f a -> b -> f b
16:42:21 <mniip> shachaf: prod
16:42:38 <shachaf> mniip: test
16:42:43 <mniip> test failed
16:43:02 <shachaf> Good, that's why we have tests. At least prod is still OK.
16:43:04 * hackagebot ombra 0.1.0.0 - Render engine.  https://hackage.haskell.org/package/ombra-0.1.0.0 (ZioCrocifisso)
16:43:10 <mniip> shachaf, I have a question regarding Day convolution
16:43:46 <mniip> when we say that (Hask^Hask, Day, Identity) is a monoidal category
16:44:12 <mniip> how do we reason about morphism equalities in Hask^Hask to prove the monoidal laws
16:44:27 <shachaf> What do you mean?
16:44:44 <mniip> can we reason about equality of two Day f g a values?
16:44:55 <shachaf> Why not?
16:45:24 <mniip> they have existential variables inside
16:45:56 <shachaf> Is the question about equality of values of existential types?
16:46:11 <shachaf> Equality is generally only about what you can observe.
16:46:44 <shachaf> For the type (exists a. (a, a -> String)), the values (1, show) and ("1", id) are equal.
16:47:01 <shachaf> Is that the sort of thing you mean?
16:47:06 <mniip> hmm
16:47:11 <mniip> yeah kinda
16:47:23 <shachaf> (exists a. a) has only one inhabitant.
16:48:04 * hackagebot keysafe 0.20160819 - back up a secret key securely to the cloud  https://hackage.haskell.org/package/keysafe-0.20160819 (JoeyHess)
16:48:36 <joncol> hexagoxel: Nice solution, seems to work fine. Thank you!
16:48:37 <mniip> do forall/exists have some type-algebraic meaning?
16:49:08 <CubicE> err... has anyone here dabbled with sdl2's rendering api?
16:49:11 <shachaf> Well, they're like products and sums.
16:49:24 <shachaf> Well, in the usual definition of Day convolution of functors, it's defined as a coend.
16:49:34 <sm> Squarism: I wonder if setting -fdefer-type-errors in ghc-options helps
16:49:45 <mniip> shachaf, what's a coend
16:50:10 <shachaf> dual of an end hth
16:50:23 <mniip> you know what's my next question going to be
16:50:52 <shachaf> dual of a coend hth
16:51:34 <shachaf> https://ncatlab.org/nlab/show/end or https://en.wikipedia.org/wiki/End_(category_theory)
16:53:53 <Squarism> theres no [a,b,...] "like" notation for list? You need to do : S.fromList [a,b...] ?
16:54:10 <monochrom> > [3, 10 .. ]
16:54:12 <lambdabot>  [3,10,17,24,31,38,45,52,59,66,73,80,87,94,101,108,115,122,129,136,143,150,15...
16:54:51 <Squarism> oh i mean for SET
16:54:52 <pikajude> > [3, 10 .. ] :: Set Integer
16:54:54 <lambdabot>      Not in scope: type constructor or class ‘Set’
16:54:54 <lambdabot>      Perhaps you meant one of these:
16:54:54 <lambdabot>        ‘Data.Set.Set’ (imported from Data.Set),
16:55:04 <pikajude> Squarism: I think you can use OverloadedLists for that
16:55:24 <ReinH> If you're trying to work with an infinite set you're going to have a bad time.
16:55:43 <Squarism> oh.. the infinite part was not the issue here
16:55:59 <geekosaur> I don't think OverloadedLists works with range syntax though, because it turns into methods on Enum that produce lists
16:56:05 <geekosaur> not list literals
16:56:51 <Squarism> its just that the list creation mechanism is very compact.. [1,2,3]... now that i switch to lists i need to convert all those to (S.fromList [1,2,3])... which is disturbingly verbose
16:57:03 <monochrom> I see. Yes, you need to use S.fromList.
16:57:07 <Squarism> now that i switch to SET
16:57:32 <monochrom> There is no notation for Data.Set sets. It's a library, not a syntax extension.
16:57:39 <geekosaur> oh, looks like OverloadedLists does handle ranges
16:57:48 <geekosaur> as long as they;re literals
16:58:23 <mniip> shachaf, I'm lost
17:02:08 <shachaf> mniip: I think there's a Catsters video about ends, maybe.
17:02:30 <mniip> shachaf, what do you mean when you say that a transformation is natural in some variables
17:02:52 <mniip> I know the definition of NT but I don't see the generalization
17:03:06 <shachaf> Did I say that?
17:04:15 <mniip> not you specifically
17:04:42 <mniip> however the ncat article on extranatural transformations does and I feel like this is an important concept
17:05:04 <shachaf> Looks like that article explains what it means too.
17:05:36 <shachaf> "said to be natural in a ... if ... \eta(-,b,c) is a natural transformation (in the usual sense)."
17:05:44 <lpaste> jdt pasted “Migration-related warnings” at http://lpaste.net/178695
17:06:41 <jdt> I'm wondering if there's some way to avoid those warnings. I'm using the data structures referenced in groundhog database migrations, so they're definitely being used (I can't remove them without breaking things).
17:06:47 <jdt> but GHC complains nonetheless.
17:07:06 <shachaf> Oh, I was looking at the Wikipedia article, not the nlab artile.
17:07:33 <jdt> here's the source file: https://github.com/justindthomas/blog/blob/master/src/Site.hs
17:08:27 <shachaf> But anyway if you fix all the other variables, you get a natural transformation.
17:09:10 <mniip> from what to what
17:11:01 <c_wraith> jdt: if you export them, you won't get that warning.
17:11:06 <shachaf> What's the thing that you're saying is natural in something?
17:11:33 <jdt> c_wraith: okay, thanks. I'll follow that lead.
17:12:22 <c_wraith> jdt: (It might not be what you want to do in the end, but it's an option)
17:13:40 <Squarism> geekosaur, pikajude. I filtered your comment on OverloadedLists as i thought you interpreted me as wanting to do some infinite thing. Turns out it also serves allows using [...] as constructor for Set's if the type can be infered!
17:13:42 <jdt> cool, thanks. my setup there is really weird (I want to define the creation of one table, but use a different view that's created outside of Haskell for the actual queries - that makes things really ugly).
17:14:15 <jdt> I expect I'll find a nicer way to do that at some point.
17:16:07 <mniip> shachaf, I'm not sure
17:16:57 <mniip> The identity transformation 1:hom→hom has components of the form 1_{x, y}: x^y \to x^y and this of course is natural in each of the separate arguments x,y
17:17:04 <mniip> I don't understand this sentence at all
17:18:05 * hackagebot buildbox 2.1.9.2 - Rehackable components for writing buildbots and test harnesses.  https://hackage.haskell.org/package/buildbox-2.1.9.2 (BenLippmeier)
17:20:18 <sm> jdt: or, you can begin their names with _
17:20:31 <jdt> I tried that and it didn't work for me.
17:21:02 <jdt> the names are part of data constructors - maybe that's the reason?
17:21:05 <sm> or you can probably suppress those warnings in the project or module
17:21:09 <sm> with a GHC flag
17:21:21 <jdt> okay, I'll look into that too. thx.
17:22:30 <ertes> ncatlab looks like an interesting wiki
17:23:32 <mniip> hmm, I can see how if we have a functor CxD->E, a choice of an object in C leaves us with a functor D->E and a choice of a moprhism in C leaves us with an NT between two aforementioned functors
17:24:01 <mniip> I can also see how 1 is an NT
17:24:21 <mniip> however the components are indexed by pairs, objects of CxD
17:24:34 <mniip> or in our case V^op x V
17:25:49 <sm> jdt: like https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using.html#source-file-options , -Wno-unused-binds perhaps
17:25:54 <jdt> sweet. exporting them all fixed it. thanks for the advice.
17:25:59 <jdt> I'll look at that too sm - thanks again.
17:26:21 <sm> the new GHC docs are working well!
17:35:16 <monochrom> Hmm new Haskell MOOC eminent: https://www.futurelearn.com/courses/functional-programming-haskell (I saw it from haskell-cafe). Maybe it'll be better than Erik Meijer's.
17:37:32 <Phyx-> what's a MOOC?
17:37:45 <monochrom> massive online open course
17:37:59 <monochrom> or maybe "open online"
17:39:56 <ggVGc> is massive needed?
17:40:16 <ggVGc> monochrom: your nick is one of my favourite techno EPs
17:41:06 <mmaruseacph2> online open
17:41:27 <mmaruseacph2> *open online
17:41:49 <Phyx-> aha
17:42:26 <monochrom> some online open courses do expect a lot of online students (say, 10x more than local students), so they are indeed massive.
17:43:27 <monochrom> and I think the rest just still say "MOOC" because it is such a common acronym, if you don't include the "M" (or if you leave out an O) people don't know what you mean.
17:49:21 <Hafydd> MMOC: Massively Multiplayer Online Course.
17:50:52 <mniip> MMORPC
17:51:19 <Welkin> VRMMORPG
17:51:28 <Hafydd> VRRROOOOOOOMMM!
17:51:40 <Welkin> that's a real thing
17:51:54 <Welkin> Virtual Reality Massively Multiplayer Online Role Playing Game
17:52:06 <Welkin> at least in manga/anime it is a huge fad right now
17:52:15 <mniip> ew
17:52:27 <Welkin> and in chinese light novels
17:54:42 <ertes> MMOZQ
18:02:16 <benzrf> chinese light novels
18:03:50 <mniip> shachaf: prod?
18:13:06 * hackagebot mars 0.1.0.1 - Generates mountainous terrain using a random walk algorithm.  https://hackage.haskell.org/package/mars-0.1.0.1 (infrared)
18:19:22 <Squarism> can multiple patterns be handle by one case in a case-of expression?
18:19:38 <Squarism> seems like a common situation
18:21:59 <Welkin> what do you mean?
18:22:08 <MarLinn> Squarism: You mean like a switch fall-through?
18:22:25 <Squarism> exactly
18:22:48 <Rembane> _ -> handle
18:23:45 <pavonia> "case { Foo or Bar or Baz -> ...; _ -> ... }" <-- Something like this would be nice
18:24:50 <Squarism> seems like there is no way
18:24:50 <Squarism> https://wiki.haskell.org/MultiCase
18:25:04 <Welkin> Squarism: there is
18:25:11 <glguy> ërichsdfsdfsdfsdfsdfsdfsdfadfsdfsfsasdfasdf
18:25:11 <Squarism> oh?
18:25:12 <Welkin> just define your body in a where clause
18:25:57 <Welkin> case ... of A x y -> g x y; B x y -> g x y; where g x y = ...
18:27:46 <Squarism> Well ok.. that works, but for readability it would be clear if there were a nice grouping mechanism.
18:28:24 <systemfault> I see fallthrough as being a flaw.
18:28:36 <systemfault> Glad Haskell doesn't have that.
18:28:39 <Welkin> yeah
18:28:49 <Welkin> having to manually type `break;` is a problem
18:29:03 <MarLinn> I'd say a data structure with more than 5-7 constructors is an antipattern. And once you have several levels you have a higher chance of unifying some in a variable/wildcard
18:29:11 <Welkin> clear and explicit is better than clever and implicit
18:31:25 <Squarism> ok.. fallthrough has its problems... and luckely there is no rampant instruction pointer in haskell
18:31:29 <MarcelineVQ> guards have fallthrough to the next pattern
18:31:48 <MarcelineVQ> Unless I'm misunderstanding the word
18:32:08 <Squarism> does it execute all guards that evaluates to True?
18:32:14 <geekosaur> no, only the first
18:32:15 <Squarism> just first right?
18:37:13 <Gurkenglas> "<glguy> ërichsdfsdfsdfsdfsdfsdfsdfadfsdfsfsasdfasdf" stroke or cat?
18:37:35 <Welkin> he's just german
18:45:38 <ertes> when using -fobject-code, GHCi only recompiles modules that need recompilation…  it also creates interface files…  however, in its default mode (-fbyte-code) it doesn't do that and recompiles *everything* on *every* reload…  is there a way to avoid that?
18:45:49 <ertes> without -fobject-code that is
18:47:15 * glguy changes his easy password
18:47:44 <monochrom> haha
18:48:00 <monochrom> do they even allow non-ascii in passwords?
18:48:16 <glguy> The imaginary service I'm talking about? I hope so!
18:48:26 <glguy> Otherwise I'm not going to be able to log in
18:48:26 <ertes> do they even allow ASCII in passwords?
18:48:42 <monochrom> ertes, -fbyte-code does not recompile everything on every reload.
18:49:25 <ertes> monochrom: it seems to do it for me…  do you have an idea what could cause this?  -fforce-recomp is not in effect
18:49:32 <monochrom> but it may be true that in some cases -fobject-code recompiles less
18:49:57 <monochrom> actually let me carefully check my claim
18:53:15 <monochrom> I am able to get :reload to just recompile a child module, it doesn't recompile a parent module. (I have module M, then module K import M, then I only modify K and :reload)
18:55:06 <monochrom> hrm, if the user guid is right, it is the same recompilation check for both ghci and batch mode. -fobject-code should not be recompiling less.
18:55:11 <geekosaur> here's one for you: what happens if the module is already compiled as object code, but you are requesting byte codE?
18:56:28 <geekosaur> (there... have actually been issues with that in the past, iirc)
18:58:08 * hackagebot diagrams-rasterific 1.3.1.9 - Rasterific backend for diagrams.  https://hackage.haskell.org/package/diagrams-rasterific-1.3.1.9 (BrentYorgey)
18:58:32 <mitchty> ok i have a hopefully fun c ffi question for y'all 
18:59:21 <mitchty> say I want to build a dict say or maybe a better data type of byte strings of these error messages, but do it at compile time instead of hitting the ffi each time I'd need to get one, any pointers?
18:59:23 <mitchty> https://github.com/dun/munge/blob/1d124054e8be1e0ae1a14f9ffd648a6a120dfe29/src/libmunge/strerror.c#L37
19:00:03 <mitchty> its a regular c function though, i suppose i could hide it behind some sort of memoizing function and suffer the ffi hit once
19:00:57 <mitchty> and yes this isn't a big deal but it is annoying me a little
19:01:42 <geekosaur> I'm not sure what you mean by "at compile time" but the answer to that is usually quasiquotes or TH, not FFI /per se/
19:02:19 <geekosaur> suppose you could use a quasiquoter that did the FFI at compile time
19:02:21 <mitchty> well i wrapped it with an ffi function to get at the char*
19:02:23 <geekosaur> maybe
19:02:54 <mitchty> but that basically means i hit the ffi each time there is an error, which isn't a big deal but this is basically a pure function
19:04:03 <mitchty> its more i'd like to get at these char * values at compile time, maybe i could abuse macros, hrm, eh i'll look at quasi quotes, too much to learn
19:08:09 <mitchty> although i wonder if i can abuse this https://hackage.haskell.org/package/language-c-0.5.0/docs/Language-C-Parser.html
19:08:42 <monochrom> yes, I would copy the strings by hand or use a C parser to do it for me.
19:09:08 <monochrom> in fact, I would copy the strings by hand, too lazy to learn and use a C parser
19:09:49 * geekosaur would probably sed it... but should be possible to ffi at compile time
19:11:07 <mitchty> yeah that would be the lazy way, i'm just code golfing for fun
19:11:13 <monochrom> ertes: so far I can only think of some background process behind your back that changes your files' timestamps.
19:11:56 <monochrom> and possibly along that tangent, being on a networked file system that suffers from inconsistent clocks.
19:15:44 <monochrom> you know what? if GHC and GHCi don't have a bug about this, then even clocks should not be a reason.
19:16:45 <monochrom> the thing is you're seeing -fobject-code and -fbyte-code having different degrees of recompilation. but they are supposed to use the same decider. every issue should either cause both of them to recompile or cause both of them to skip.
19:19:51 <geekosaur> awk -f '/^munge_strerror/ {go=1} go && /case EMUNGE_[A-Z_]+:/ {split($2, f, /:/); printf "munge_strerror %s = ", f[1])} go && /return (/ {split($2, f, /[()"]/); printf "\"%s\"\n", f[3])} /default:/ {go=0} END {print "munge_strerror _ = \"Unknown error\""' # roughly, assumes you extracted EMUNGE as a data
19:20:28 <geekosaur> actually iirc awk is index-0 so f[0] and f[2] respectively
19:20:34 * monochrom 's jaw drops
19:20:37 <geekosaur> :p
19:21:15 <geekosaur> I used ot have to do this somewhat regularly. but it's been some years since I last awk-ed, so had to swap those bits back in...
19:24:06 <geekosaur> also gawk can do things "cleaner" than the weird split()s... in versions where those cleaner versions don't dump core, and quite often the expressions end up longer
19:25:14 <mitchty> heh, i suppose that would work, i'd just use perl that is... insane
19:25:38 <geekosaur> didn't have perl on the machines I needed to do this one
19:25:40 <geekosaur> *on
19:26:03 <mitchty> no perl? what degenerate unix was this? even sunos 2.5.1 had perl
19:26:15 <geekosaur> some early pc unix
19:26:34 <geekosaur> (another reason why I stuck to v7 awk instead of posix or gnu or mawk etc.)
19:27:36 <geekosaur> perl (3.x!) was a thing but vendors hadn't picked it up yet
19:27:54 <mitchty> you're way more persistent than me, i get really angry when awk is my only choice
19:28:22 <monochrom> "some early pc unix" is really early and arcane, like Xenix.
19:28:38 <geekosaur> you have seen nothing. I've done this stuff in sed too, when awk wasn't available (e.g. early SunOS boot before /usr was mounted)
19:29:03 <geekosaur> most people have no idea what sed can do in a punch
19:29:07 <geekosaur> *pinch
19:29:28 <monochrom> the whole notion of "pc unix" disappeared after linux.
19:29:43 <geekosaur> ...otoh that's for the best; "sed can do" and "you should use sed to do" are very much two different things
19:30:09 <mitchty> best i can offer up is having to use ed without any feedback to fix a broken solaris system that wasn't booting and had a firmware update problem
19:30:12 <geekosaur> as a general rule if someone starts using sed's hold space, run away
19:31:17 <mitchty> i have never seen that in use thankfully
19:31:24 * mitchty goes to look at this part of sed
19:32:04 <mitchty> and i'm going to forget i saw that
19:32:14 <geekosaur> :)
19:32:50 <geekosaur> really, if you see someone doing that, give them a perl or python book. preferably by dropping it on their head
19:32:51 <mitchty> actually, i may have used that in a one-liner once
19:33:48 <Welkin> I saw an implementation of chess in sed
19:35:01 <monochrom> you know what, perl is designed to take in your insane sed scripts and awk scripts almost verbatim. so you give them a perl book either, it won't change a thing.
19:35:16 <mitchty> i found this fun one in my dotifle history awk '!a[$0]++'
19:35:18 <monochrom> s/so you give/so don't give/
19:35:36 <geekosaur> no, perl comes with scripts that will convert them to (almost idiomatic, for awk; not so much for sed) perl
19:35:39 <mitchty> i don't remember what that does, i think sorts input and removes duplicates
19:35:54 <geekosaur> yes
19:36:52 <geekosaur> ...wastefully since it's going to hold the first copy of each line in memory. sort -u is better unless it's a small file
19:37:07 <geekosaur> well, no, not sorted actually
19:37:15 <mitchty> well first hit wins
19:37:34 <monochrom> is it exactly Haskell's nub?
19:37:39 <geekosaur> right. but it will only be sorted if the input was, and in that case use uniq instead of awk
19:37:52 <mitchty> i (ab)used it to do evil things to $PATH's
19:38:18 <geekosaur> it's not exactly haskell's nub because associative arrays are hash tables :)
19:38:51 <geekosaur> (insert the usual rant about nubOrd, except here it's nubHashable)
19:43:09 * hackagebot mars 0.1.0.2 - Generates mountainous terrain using a random walk algorithm.  https://hackage.haskell.org/package/mars-0.1.0.2 (infrared)
19:49:34 <buglebudabey> out of curiosity, i've heard ghc is a pain on windows, is this true and if so why?
19:50:16 <Gurkenglas> Libraries assume you have dlls available that linux and osx can get via package manager on demand
19:50:41 <Welkin> buglebudabey: because windows is a pain
19:50:48 <Gurkenglas> Welkin, shush
19:51:02 <Welkin> Gurkenglas is just a masochist
19:53:41 <exio4> buglebudabey: the issue is mostly "needs extra work that it's often automated/simplified on linux"
19:53:49 <buglebudabey> gotcha
19:54:19 <buglebudabey> another thing out of curiosity does anyone go to UCF?
19:54:24 <exio4> buglebudabey: not just library-wise but things like paths, you only have a single /usr/lib and the OS normally deals with that stuff on Linux, on Windows you'll probably need to tell cabal where things are
19:55:15 <buglebudabey> exio4 im glad i have nix based then
20:02:52 <ertes> geekosaur: if i compile with -fobject-code and then switch to -fbyte-code, then no recompilation happens, which is related to:
20:03:06 <ertes> monochrom: i noticed that when i use -fbyte-code, no .hi files are generated
20:05:00 <geekosaur> yes, the bytecode backend does no file i/o. you do not want it to write .hi files that don't match any existing .o files
20:05:27 <geekosaur> (and, because internal names can leak into .hi files, they can fail to match exactly even if nothing changed)
20:11:14 <Squarism> how big parts of your freetime do you spend coding?
20:11:54 <Squarism> ...at max, when you focus on some personal project?
20:12:13 <Squarism> .../joint ops
20:12:27 <Welkin> I have done it for 2 weeks straight
20:12:33 <Squarism> haha
20:12:37 <Squarism> good to hear
20:12:37 <Welkin> but then I go for months without doing anything
20:12:52 <Welkin> that was fun though
20:13:03 <Welkin> wake up, program, go to sleep, repeat for 14 days
20:13:19 <Squarism> yeah.. mind loves it, body not so much
20:16:56 <Squarism> well, evaluating other hobbies/freetime activities it feels very rewarding in comparrision. But in perspective of it is also my day to day job - it does feel a half sane.
20:17:14 <Squarism> a bit half..
20:32:16 <grantwu> Is there any special meaning when :t gives a type with Dec in it?
20:35:14 <ertes> geekosaur: yeah, makes sense…  so -fobject-code seems to be my only option (other than creating a separate package)
20:35:44 <buglebudabey> is there a reference for lambda bot commands
20:39:07 <ertes> grantwu: no…  you can find out where your Dec comes from using :i
20:39:16 <ertes> :i Dec
20:39:27 <grantwu> ertes: So, it says it's not in scope
20:39:37 <grantwu> Er, sorry, this wasn't :t
20:39:39 <grantwu> This was a type hole
20:40:09 <grantwu> The hole looks like this:         _ :: ParsecT Dec T.Text Data.Functor.Identity.Identity ()
20:40:29 <ertes> if that's exactly what :i gives, then Dec should be in scope
20:40:41 <ertes> s/:i/:t/
20:41:24 <grantwu> I'ts not :t, it's from the error given by the type hole
20:41:26 <geekosaur> not if it's expanding a type synonym (Parsec, Parser)
20:41:30 <grantwu> Here, let me give a more complete trace
20:42:00 <geekosaur> and I conclude this is megaparsec, and you can query hayoo for it
20:42:12 <grantwu> https://bpaste.net/show/11faf06089ed
20:42:21 <grantwu> Hayoo doesn't seem to index megaparsec
20:42:31 <grantwu> At least, http://hayoo.fh-wedel.de/?query=megaparsec gives nothing
20:42:37 <geekosaur> er, hayoo indexes all of hackage
20:42:48 <geekosaur> no, you want to look for Dec
20:42:51 <Gurkenglas> doesDirectoryExist actually uses exceptions in normal operation? :(
20:43:04 <geekosaur> "megaparsec" is not a Haskell function so is not found :)
20:43:11 <Gurkenglas> Now ghci's :set fbreak-on-exception trips over that
20:44:14 <grantwu> Dec doesn't seem to find anything from Megaparsec on Hayoo...
20:44:16 <geekosaur> it's likely trying to do stat() and catching the exception, yes. because too much of the standard library uses exceptions like that :(
20:45:01 <grantwu> Also, does Hayoo only let me search for functions?  Should MonadParsec turn up anything (It's a typeclass)
20:45:16 <Gurkenglas> Can I make ghci stop only at Ctrl-C?
20:46:27 <geekosaur> http://hackage.haskell.org/package/megaparsec-5.0.1/docs/Text-Megaparsec-Error.html#t:Dec
20:46:51 <grantwu> geekosaur: Oh, thanks.  How'd you find that?
20:46:54 <geekosaur> no idea why hayoo's not finding it, but indeed "Dec package:megaparsec" returns nothing :(
20:47:03 <geekosaur> looked up megaparsec docs on hackage
20:47:22 <Gurkenglas> Can I pause the execution after it's probably in whatever infinite loop it apparently runs into and only then enable fbreak-on-exception?
20:47:28 <geekosaur> because I know that its Parser (eventually) expands as ParsecT Dec () Identity
20:55:51 <ices> @djinn (a, b) -> c -> (b, c)
20:55:52 <lambdabot> f (_, a) b = (a, b)
20:56:05 <ices> @djinn f -> [a] -> b
20:56:05 <lambdabot> Error: Undefined type []
20:56:57 <geekosaur> :exf "f -> [a] -> b"
20:57:06 <geekosaur> not expecting much
20:57:27 <exferenceBot> could not find expression
20:58:11 <geekosaur> djinn doesn't handle recursively defined types (such as lists), but with nothing relating your f, a, and b, I don't expect anything would do much with that type
20:58:40 <ices> yea it was from a shitpost by someone anyway
21:02:57 <Welkin> what is exferenceBot?
21:03:15 <Welkin> :exf "a -> a"
21:03:16 <exferenceBot> id
21:03:28 <Welkin> @djinn a -> a
21:03:28 <lambdabot> f a = a
21:03:34 <Welkin> @djinn forall a. a -> a
21:03:34 <lambdabot> f a = a
21:07:00 <geekosaur> https://github.com/lspitzner/exference
21:08:19 <mikeplus64> are there any memoisation libraries with memory or size limits? using e.g. a lru-cache
21:09:40 <geekosaur> @where+ exference Djinn on steroids: recursive types, typeclasses, etc. https://github.com/lspitzner/exference
21:09:40 <lambdabot> Good to know.
21:10:51 <geekosaur> @where+ exference Djinn on steroids: recursive types, typeclasses, etc. https://github.com/lspitzner/exference or in #haskell: :exf "Monad m => m (m a) -> m a"
21:10:51 <lambdabot> Done.
21:11:36 <Welkin> why does it take a string?
21:11:59 <Welkin> get rid of the quotes
21:12:16 <geekosaur> it will somtimes throw errors without them
21:12:26 <geekosaur> I think it supports the same options it does on command line?
21:12:27 <Welkin> why is that?
21:12:40 <Welkin> seems like a UI problem
21:12:59 <geekosaur> yes, there's a bunch of options it can take along with the expression
21:13:39 <geekosaur> from the bot help: [20 04:12] <exferenceBot> ask hexagoxel for details
21:13:46 <Welkin> lol
21:13:59 <geekosaur> I just know it and use it, I don;t run it or make decisions about how it works
21:33:12 * hackagebot ghc-time-alloc-prof 0.1.0 - Library for parsing GHC time and allocation profiling reports  https://hackage.haskell.org/package/ghc-time-alloc-prof-0.1.0 (MitsutoshiAoe)
22:08:14 * hackagebot mars 0.1.0.3 - Generates mountainous terrain using a random walk algorithm.  https://hackage.haskell.org/package/mars-0.1.0.3 (infrared)
22:20:36 <joe9> Is there a withTChan ?
22:21:46 <Welkin> ?hayoo withTChan
22:21:46 <lambdabot> Unknown command, try @list
22:21:51 <Welkin> @hayoo withTChan
22:21:51 <lambdabot> Unknown command, try @list
22:30:49 <glguy> What would such an operation do?
22:41:49 <joe9> glguy, something that can free up the TChan resources on exception
22:42:08 <dysfun> is anyone else relying on ghc8 behaviour already?
22:43:56 <glguy> very likely
22:45:01 <shachaf> mniip: hi
22:45:51 <shachaf> mniip: I was away for a while. Did you figure it out?
22:56:42 <nshepperd> joe9: TChans are just garbage collected normally when you're done with them
22:58:14 <nshepperd> i don't think there's anything to free up
23:06:56 <CookieMonster_> hello all
23:06:59 <joe9> nshepperd:  Thank.
23:07:05 <joe9> nshepperd:  Thanks.
23:07:18 <CookieMonster_> I have a question if anyone is here
23:07:20 <joe9> Is there a Text.Groom that works with Text instead of String?
23:07:42 <CookieMonster_> So there is a library that can be install on ubuntu via apt-get. 
23:07:49 <CookieMonster_> I'd like to write a haskell binding for it.
23:07:57 <CookieMonster_> What are my initial steps in going about this?
23:08:08 <dysfun> a c library?
23:08:11 <CookieMonster_> yep
23:08:24 <dysfun> welcome to haskell FFI
23:08:26 <CookieMonster_> c/c++ library
23:08:28 <dysfun> i recommend using cffi
23:09:21 <CookieMonster_> yeah I figured. When built, it'll be necessary to apt-get the specific package in order to use the library
23:09:22 <dysfun> to use cffi you will need to write a file for cffi to consume describing the c functions
23:09:52 <dysfun> it will then generate the haskell during build to bind it
23:10:25 <CookieMonster_> Wouldn't I need a script to say "hey its in usr/share/_ /"
23:10:54 <CookieMonster_> when building the haskell library
23:10:57 <dysfun> no. you declare a dependency on a library in your cabal file
23:11:09 <dysfun> let me find the option
23:11:16 <CookieMonster_> right right.
23:12:26 <dysfun> pkgconfig-depends: libvirt -- i require libvirt on this
23:14:19 <CookieMonster_> inside .cabal?
23:14:46 <dysfun> yes. specifically inside the relevant build target (probably a library)
23:21:45 <joe9> Is there a pretty print library such as Text.Groom that can output to Text?
23:22:29 <dysfun> use text-conversions ?
23:23:08 <joe9> dysfun: Thanks, will check it out.
23:23:19 <dysfun> text-conversions is the 'safe' one
23:23:24 <CookieMonster_> dysfun I think I sent you a message.
23:23:32 <dysfun> CookieMonster_: you did, i responded
23:24:10 <CookieMonster_> don't see it
23:24:14 <joe9> It is not just about conversion from String to Text. It would be nice if the library uses Text to pretty print using the derived Show instances. Groom does that, but, uses String.
23:24:16 <dysfun> (yes, like that, but strip the comment and change the library to the one you want rather than libvirt)
23:24:25 <joe9> dysfun: ^^
23:24:46 <dysfun> :t show
23:24:48 <lambdabot> Show a => a -> String
23:24:54 <dysfun> and therein lies your problem
23:25:33 <dysfun> the penalty has to be paid somewhere. choosing to use string means you are conscious that you are paying it
23:25:43 <dysfun> rather than it just doing it behind the scenes
23:28:07 <joe9> dysfun: BasicPrelude uses Text
23:28:42 <dysfun> *shrug* i'm not the author, i'm just explaining plausible reasons
23:29:41 <dysfun> pretty printing isn't something you do very often in production, so i'd just use text-conversions in this case and go on to something more fun :)
23:39:09 <ongy> joe9: there is also https://hackage.haskell.org/package/text-show but I don't know about performance (and it's not the derivable show instance)
23:46:12 <joe9> ongy, Thanks. Will check it out.
23:50:36 <joe9> ongy, Thanks. it is a good idea.
23:58:49 <joe9> ongy, text-show does not have pretty output. It is just a replacement for Show and not Pretty Show.
23:59:10 <ongy> joe9: oh, there is pretty show? Sorry my mistake
23:59:57 <joe9> ongy:  Something like Text.Groom
