00:05:11 <merijn> orion: Something like this should work: http://lpaste.net/180417
00:10:30 <orion> merijn: Interesting, thanks!
00:11:54 <merijn> uh
00:12:09 <merijn> Actually, that has a bug and I'm not sure why it didn't yell at me >.>
00:12:57 <merijn> Last line should be something like: "unwrap f = \x -> runMyApp (f x)"
00:13:10 <ReinH> orion: instead of wanting to do that, I would recommend not wanting to do that.
00:13:26 <Guest67829> How do I patternmatch on IO(Either t0 t1)?
00:13:50 <ReinH> You can't directly. IO doesn't expose any constructors. In a 
00:14:05 <ReinH> ... in a do block, you can use result <- theIOAction; case result of
00:14:32 <ReinH> or you can use theIOAction >>= \result -> case result of ...
00:14:43 <ReinH> both can be simplified a bit with the LambdaCase extension
00:14:48 <Guest67829> ah, ofc! Thanks
00:16:27 <merijn> I feel like Habit's "case<-" is more generally useful than lambdacase, I wish they'd gone with that
00:17:38 <merijn> orion: I do concur with ReinH that you should probably not want that
00:22:44 <Guest67829> http://lpaste.net/180420 why does y do be any type at all? I didn't specify anything there.
00:22:55 <Guest67829> *expect to be
00:24:05 <MarLinn> How would LambdaCase look in the sugared case (result <- theIOAction)? I've never seen that. And what would Habit's case have looked like?
00:25:04 <MarLinn> The only version I know is theIOAction >>= \case ->
00:25:11 <johnw> I'm guessing: case <- theIOAction of ...
00:26:23 <ahihi> Guest67829: configLibraryPath has type String, so you're working in the list monad rather than IO
00:26:47 <MarLinn> johnw, that would make sense. But it does look a bit confusing
00:27:43 <ReinH> You can use theAction >>= \case in a do block. I don't use it sugared.
00:27:51 <ReinH> I don't know if you can.
00:28:30 * hackagebot hakyll-filestore 0.1.4 - FileStore utilities for Hakyll  https://hackage.haskell.org/package/hakyll-filestore-0.1.4 (aergus)
00:29:03 <MarLinn> ReinH, ok then I misunderstood you
00:29:26 <Guest67829> All I'm trying to do is "readIniFile. If it is Right, return this result, if Left return a default". Is this not the right way to do it?
00:29:44 <lpaste> ahihi annotated “No title” with “No title (annotation)” at http://lpaste.net/180420#a180421
00:29:50 <ahihi> ^ something like this should work
00:30:25 <Axman6> Guest67829: you can easily use `either` for that:
00:30:36 <Axman6> :t either (const True) id
00:30:38 <lambdabot> Either b Bool -> Bool
00:31:34 <ahihi> Axman6, I think IO is the issue here, not Either
00:32:03 <Guest67829> thanks, ahihi 
00:32:20 <Axman6> :t either (const True) id <$> (undefined :: IO (Either String Bool)
00:32:22 <lambdabot> error:
00:32:22 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
00:32:26 <Axman6> :t either (const True) id <$> (undefined :: IO (Either String Bool))
00:32:28 <lambdabot> IO Bool
00:32:57 <Axman6> replace True with your default config, and the undefined with the readIniFile call
00:42:00 <MarLinn> case <- theIOAction of ... does not seem to work. And maybe it's better that way
00:43:43 <lyxia> Indeed it doesn't.
00:46:25 <merijn> MarLinn: Yeah, like johnw said in Habit they added "case<- e of" to mean "x <- e; case x of"
00:46:56 <merijn> MarLinn: Yeah, that's not in Haskell :)
00:47:18 <merijn> MarLinn: I was saying that I found that syntax slightly nicer than LambdaCases "e >>= \case"
00:52:39 <MarLinn> merijn, I think for me it feels a bit wrong because it's so unexpected to have something "meaningful" on the left side of a "<-" all of a sudden. ;)
00:53:10 <merijn> MarLinn: There's other possible syntax things you could invent
00:53:55 <ahihi> IMHO there's nothing wrong with e >>= \case
00:53:57 <johnw> MarLinn: ViewPatterns are allowed to the left of <- too, I think
00:54:11 <merijn> ahihi: It's a bit messy if you have longer expressions
00:54:19 <merijn> ahihi: The \case tends to march to the right quickly
00:55:12 <johnw> > (do (length -> x) <- return [1,2,3]; return x) :: Identity Int
00:55:14 <lambdabot>  Identity 3
00:55:28 <MarLinn> Mhh.... \case <- theIOAction of...; case \<- theIOAction of ...; case \ of <- theIOAction ...
00:55:31 <merijn> I don't suppose anyone has turned Bartosz' category theory for programmers into a pdf?
00:55:47 <johnw> merijn: I was waiting till he was done
00:56:20 <merijn> johnw: Yeah, but I have a 7 hour train trip, without wifi for the majority, so I figured I could (re)read it then, but the webpage version is a bit annoying for that :)
00:56:35 <johnw> use httrack to grab the site
00:57:11 <merijn> I think it'd be quicker to just open a bunch of tabs, but then it won't work on my kindle :)
00:57:21 <johnw> ah
00:57:23 <johnw> one sec
01:03:29 <johnw> merijn: https://dl.dropboxusercontent.com/u/137615/Category%20Theory%20for%20Programmers.pdf
01:03:31 <johnw> see if that helps
01:03:42 <johnw> that's just what Acrobat Pro does if you point it at the website
01:04:29 <johnw> hmm.. maybe it's just the preface and the comments :(
01:05:48 <merijn> johnw: That's ok, plenty of other stuff done already. The other thing on my list was just diving into LambdaPi again :)
01:06:22 <johnw> you can help me figure out what pipes look like as a mathematical relation
01:06:30 <johnw> i've been stuck on this for a few hours now
01:06:57 <merijn> johnw: pipes? as in unix or as in Tekmo? :p
01:07:02 <johnw> Tekmo
01:07:16 <johnw> like, we can specify a stream of type A as the function relation (nat, A)
01:07:32 <johnw> so, what is the specification of a pipe?
01:08:09 <johnw> so far I have a function relation (((a',a,nat),(b,b',nat)),r)
01:08:11 <phadej> didn't tekmo formalise pipes?
01:08:23 <johnw> tekmo formalized them on paper, I did it in Coq
01:08:32 <johnw> now I'm trying to do it mathematically, apart from the pipes implementation altogether
01:08:34 <phadej> johnw: ah cool
01:08:48 <johnw> the problem with my relation is that it's not possible to write the "for" combinator
01:09:00 <merijn> johnw: Where does it get stuck?
01:09:13 <johnw> i'll show you
01:09:20 <johnw> https://gist.github.com/db18815b7e7bac3477de0a9f6ba60547
01:09:24 <johnw> see the "??" at the very bottom
01:09:44 <johnw> that index needs to relate to how many c's appear downstream
01:09:57 <johnw> however, the counter gets reset for each new 'b' that comes from the function passed to for
01:10:13 <johnw> since this isn't a fold, or a recursion, I don't retain knowledge of how many c's I've output so far
01:10:25 <johnw> so something else is needed in the relation...
01:11:07 <merijn> Gimme, like, 3 hours to figure out what's going on :p
01:12:00 <johnw> it's forcing me to ask "what are pipes?", and I think because I haven't fully answered that in mathematical terms yet, that's why I'm not able to encode it
01:12:54 <merijn> What's Comp?
01:13:09 <johnw> Comp A is just a set, which is just A -> Prop
01:13:18 <johnw> so A -> Comp B is A -> B -> Prop which is the relation A * B
01:14:35 <johnw> but we can talk about it in terms of sets and I can translate as needed
01:14:50 <johnw> if all you had were math sets, how would you characterize what a pipe is?
01:15:45 <merijn> Well, I'm guessing math sets and natural numbers and a way to index in some order ;)
01:15:53 <johnw> oh, gee thanks
01:15:58 <johnw> ;)
01:15:58 <merijn> johnw: I think it's like a nested fold?
01:16:37 <johnw> the computational version is most definitely a nested fold
01:16:46 <johnw> but we should be able to specify this without recursion
01:17:01 <johnw> the framework I'm using for specification lets me refine to a computational version later
01:17:04 <merijn> johnw: Ok, let me think about push pipes first
01:18:35 <merijn> I consume a number of 'A', producing 0 or more 'B' as output and ending with an 'R'
01:19:01 <johnw> I think that's half right
01:19:07 <merijn> Why half?
01:19:09 <johnw> to external consumers, all you do is end with an 'R'
01:19:21 <johnw> only the other segments of the pipeline are aware of consuming and producing A and B
01:19:48 <johnw> what makes this useful in Haskell is the presence of effects within the pipeline
01:20:20 <johnw> but if you remove effects, all that a pipeline can be is a fancily computed value
01:20:26 <merijn> Sure
01:20:38 <johnw> so maybe my specification is complicated by the fact that I'm mixing these two
01:20:42 <johnw> perhaps there are two specifications
01:20:47 <merijn> Actually
01:21:05 <merijn> It's not a nested fold, that's just one component
01:22:08 <merijn> I mean, one component is folding an unfold, so the question becomes, how do you represent composing "folded unfolds"
01:22:35 <johnw> right; my main goal for this work is apply fusion during refinement, so that executing pipelines can have zero overhead
01:23:30 <merijn> johnw: I still struggle with the operational bits of pipes occasionally, so I'm not sure I'm the right person to help formalise them ;)
01:23:55 <johnw> ok, the external spec then is trivial, it's just a value.  The internal spec should relate pipeline segments...
01:24:43 <merijn> johnw: yeah
01:25:01 <johnw> other ways of looking at the core type: https://github.com/jwiegley/notes/blob/master/PipesSimple.hs
01:25:17 <johnw> that's where I got the idea from that I'm using in the Coq code, but I think it's too operationally biased to work
01:28:45 <jchia> Is using Word16, Word32, etc instead of Int16, Int32, Int, etc, a good way to express that a number cannot be negative? I don't want to have to check that an input is non-negative -- I want to make negative input impossible in the first place. For example, an input could be an index into a sequence of things where the first index is zero.
01:29:07 <johnw> jchia: sure, that's how I'd read the use of Word16
01:29:44 <Cale> jchia: assuming that the size restriction is appropriate, it's probably the best you'll do
01:30:00 <jchia> thanks
01:30:02 <merijn> johnw: Well, don't you "simply" need to reorder the pipeline? As in, f >-> g becomes "g.f" where 'f' and 'g' are folding unfold over their input
01:30:20 <Axman6> the only problem is the minor inconvenience when converting to something like Int when working with other libraries, but it's not a big issue (unless you're using Word64 which can have issues when converted to Int(64))
01:30:54 <jchia> Axman6: Do you mean having to call fromIntegral all over the place?
01:31:00 <merijn> johnw: list/stream goes into 'f', producing another list, which goes into 'g'. I suppose the tricky bit is short-circuiting? Because each fold computes it's own 'r' and you need to figure out which to return?
01:31:01 <Axman6> yeah
01:31:20 <johnw> merijn: ok, but can we do away with the notion of folding
01:31:25 <merijn> johnw: In the push/pull scenario that's actually simple
01:31:36 <johnw> merijn: my streams are just position/value relations now, not actual foldable things
01:31:53 <merijn> johnw: Because the only thing they yield upstream are (), so we can pretend those don't exist
01:32:34 <merijn> johnw: So then we can pretend a pipe returns "Either [a] r" (either it produces a result, in which case any computation in the others is irrelevant)
01:32:51 <merijn> johnw: Or it produces a list, in which case we need to see if the next part terminates
01:33:29 <merijn> johnw: Sure, but figuring out how to express a fold based on position/value seems more tractable at least
01:33:32 * hackagebot gitHUD 1.3.5 - More efficient replacement to the great git-radar  https://hackage.haskell.org/package/gitHUD-1.3.5 (gbataille)
01:34:07 <johnw> merijn: I can only fold if the stream is finite though
01:34:23 <merijn> johnw: Why?
01:34:39 <merijn> johnw: foldr works fine on infinite streams?
01:34:46 <johnw> it does in haskell, yeah
01:35:05 <merijn> I don't see why you couldn't formalise foldr in math on position value mappings
01:35:31 <johnw> let's try
01:41:37 <johnw> ok, I understand if this makes little sense, but: https://gist.github.com/0f7cbc5ae0c42a29f83804bdc53dbecb
01:41:46 <johnw> that will only be refineable, however, for finite streams
01:42:42 <johnw> i'm not really familiar yet with using greatest fixed points
01:43:15 <johnw> which should allow for a refinement based on corecursion
01:43:58 <johnw> now, the way I've specified foldr_spec, the answer it gives you depends on telling it how far into Stream B you're going to go; otherwise, I have no way to "start the induction"
01:44:25 <merijn> johnw: Well, one thing I can think off that it'd be horrifically slow in reality, but ok in match
01:44:35 <johnw> yes, this code is not what executes
01:44:44 <merijn> johnw: So, we have f >-> g, right?
01:44:52 <johnw> in fact, the whole point of the exercise is that it doesn't even need to have a computational meaning
01:44:57 <johnw> ok, f >-> g
01:45:34 <merijn> johnw: Feed one element into 'f', compute one step of fold. The function we're folding returns either 'r' or a new stream, right?
01:46:04 <merijn> feed first element of that stream into 'g', do the same thing, until we're all through the pipeline
01:46:32 <merijn> Let's assume f >-> g >-> h, actually
01:46:43 <merijn> So, one element into 'f'. If it produces 'r', we're done
01:46:52 <merijn> If it produces a stream, feed first element of stream into 'g'
01:47:12 <merijn> if 'g' produces 'r', done. If 'g' produces a stream, feed first element into 'h', etc.
01:47:25 <merijn> If 'h' does not terminate, feed next element from 'g' output stream
01:47:38 <merijn> Until either 'h' produces a result OR 'g' is exhausted
01:47:58 <merijn> if 'g' is exhausted, feed next element of 'f' stream until return or exhausted
01:48:03 <merijn> Then feed next element into 'f'
01:48:48 <merijn> johnw: As you can see, if every component is a fold resulting in "Either [a] r" this is fine
01:49:27 <merijn> johnw: Because, afaik if, say, 'g' produces an infinite stream in it's fold, I don't think we ever need to consider the parts before 'g' to obtain a result?
01:49:54 <merijn> johnw: So we only ever need to look at finite chunks to find termination of any individual fold?
01:50:17 <johnw> these terms like "find termination" are too procedural for what I'm trying to do
01:51:12 <johnw> I'm not looking for an algorithm that computes a pipeline; I want a mathematical description of what such a computation means
01:51:25 <johnw> the former I have already, as a fold, etc.
01:51:42 <merijn> johnw: What I'm trying to say, that starting from the last most component of the pipeline the fold will either 1) terminate prematurely (not consume the entire infinite input) or 2) termination happens in a component later in the pipeline
01:52:11 <johnw> pipes don't technically ever need to terminate
01:52:25 <merijn> johnw: Sure, but then they don't produce an 'r' either :)
01:52:36 <johnw> you could do something like for (generate ()) \_ -> print "Hello"
01:52:49 <merijn> johnw: And as we covered earlier, we were considering pipes are merely "a fancy way to compute 'r'"
01:52:59 <merijn> johnw: So really only terminating pipes are meaningful
01:53:22 <johnw> yes, based on what I said that's true
01:53:55 <merijn> johnw: So your fold formalisation that only works for either finite inputs is fine assuming it works when you can succesfully return in finite steps from infinite input
01:56:23 <johnw> thanks for taking the time, merijn; I have to head to bed now
01:58:22 <merijn> johnw: Good night! I have to leave for keynote anyway :p
02:08:29 <balac> hi, could someone help me with reading the function (. flip id), please?
02:09:24 <balac> it was a component of the "swing" function, i believe.
02:10:59 <ahihi> @unpl (. flip id)
02:10:59 <lambdabot> (\ a0 x -> a0 (\ y -> y x))
02:18:41 <jle`> balac: you can manually expand the definitions of flip and (.) and id, if that helps
02:53:35 <quchen> :t (. flip id)
02:53:36 <lambdabot> (((b -> c1) -> c1) -> c) -> b -> c
02:53:54 <quchen> Whoever wrote this should not be programming.
03:00:36 <balac> jle`: thank you.
03:01:02 <balac> quchen: well, it was part of this: https://wiki.haskell.org/Pointfree#Swing :)
03:01:39 <quchen> Good, you can look up the name in the history and write an angry email to the author.
03:04:28 <cocreature> looks like Cale is to blame for it
03:06:02 <Gurkenglas> "zoom providedScopes . state . addScope :: MonadState SearchNode m => ScopeId -> m ScopeId" isn't gonna work because that type is too general, right?
03:06:22 <cocreature> Gurkenglas: yeah zoom and monadstate don’t play well together
03:06:42 <Gurkenglas> What type signature should I use? Or should I perhaps not worry about it and just inline that code?
03:08:08 <cocreature> Gurkenglas: I think at some point I stole the code from this stackoverflow answer https://stackoverflow.com/questions/30827838/how-do-i-use-zoom-with-a-monadstate-constraint-of-a-newtype
03:08:33 <cocreature> but you run into ambiguities really quickly iirc
03:14:13 <AndChat54704> I found a detailed history of Haskell if you're interested 
03:14:19 <AndChat54704> https://www.google.com.bo/url?sa=t&source=web&rct=j&url=http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf&ved=0ahUKEwjR26DZpd7OAhVKFJAKHRMJBbIQFgghMAE&usg=AFQjCNE-Gw-iGvQxbrkWCGnXl5b5MmrnHg&sig2=wK4hjZWuxuzdVqE6fmvDiw
03:18:36 * hackagebot raw-feldspar 0.1 - Resource-Aware Feldspar  https://hackage.haskell.org/package/raw-feldspar-0.1 (EmilAxelsson)
03:20:59 <Gurkenglas> And now the two call sites have to replace their "MonadState SearchNode m" by "(Zoom n m Scopes SearchNode, Functor (Zoomed n ScopeId))" - uh oh
03:42:56 <jchia> conduit question. I have the following conduit setup where I read records (getRec) from a bz2 file and pass them to a sink (recSink):
03:42:56 <jchia> let conduit = CB.sourceFile inputFile $$ bunzip2 =$= conduitGet2 getRec =$= recSink refData:: ResourceT (StateT SymTimeMap IO) ()
03:43:04 <jchia> However, the refData should be read from the beginning of the file first (Also using a Get) before I can give it to recSink. refData is reference data used to interpret the records. How can I express this?
03:46:32 <jchia> To clarify, the reference data comes first in the file, followed by the records read using getRec
03:47:57 <jchia> so, maybe I need two kinds of sink, one for reading the refData, once, and one for reading using getRec, and sequence them in a way that they are used to read from the same file, and the refData from the first sink is given to recSink
03:48:19 <jchia> which conduit functions allow me to join two sinks like that?
03:50:59 <jchia> should i be looking at resumable source/conduit?
03:58:37 * hackagebot reroute 0.4.0.1 - abstract implementation of typed and untyped web routing  https://hackage.haskell.org/package/reroute-0.4.0.1 (AlexanderThiemann)
04:48:39 * hackagebot pipes-io 0.1 - Stateful IO streams based on pipes  https://hackage.haskell.org/package/pipes-io-0.1 (yinguanhao)
04:53:39 * hackagebot huckleberry 0.10.0.0 - Haskell IOT on Intel Edison and other Linux computers.  https://hackage.haskell.org/package/huckleberry-0.10.0.0 (tkmsm)
05:04:56 <Taneb> Is there a way to do "instance Foo a" without extensions?
05:05:09 <Taneb> That needs flexible instances :(
05:10:21 <fr33domlover> Taneb, which instance exactly do you want to define?
05:10:42 <Taneb> I want a class with the same instance for all types
05:10:55 <Taneb> So, exactly the one I wrote
05:11:26 <fr33domlover> Taneb, why would you need such a thing? just curious, sounds strange
05:11:45 <fr33domlover> you can simply use a regular function, no need for a class at all
05:11:51 <Taneb> For a joke library
05:11:59 <Taneb> I'm being silly
05:12:45 <fr33domlover> joke :: IO () -- ^ Prints a random joke to stdout
05:12:47 <fr33domlover> :-)
05:13:39 <Taneb> I mean a library that is a joke :P
05:14:18 <hpc> can you write nullary type classes?
05:14:37 <fr33domlover> Taneb, i know, just kidding :)
05:32:17 <lpaste> lambdafan pasted “What's wrong with append for my difference list” at http://lpaste.net/180483
05:34:08 <Taneb> mkHughes is where the error is
05:34:26 <lambdafan> it's works with appendDumb
05:34:42 <lambdafan> ahhh!
05:34:43 <Taneb> Doesn't mean it's necessarily right
05:34:50 <lambdafan> I see
05:34:54 <lambdafan> thanks!
05:41:36 <lambdafan> what is the complexity of [1,2] <> [3,4]?
05:42:10 <lambdafan> is that not O(n)?
05:42:14 <bjs> Taneb doing terrible things again
05:42:51 <hpc> big O is asymptotic complexity
05:42:56 <hpc> there's no n to even express there
05:43:02 <Taneb> lambdafan, it's O(n) where n is the length of the first list
05:43:06 <rom1504> lambdafan: worst case complexity of list difference is O(n) yes
05:43:21 <rom1504> well difference as in <>
05:43:29 <hpc> rom1504: (<>) = mappend = (++)
05:43:44 <rom1504> oh well nevermind
05:43:53 <hpc> yeah, it's a bit weird
05:43:54 * lambdafan already neverminded
05:44:02 <hpc> as we all know, it should really be (<>) = getLine
05:44:14 <lambdafan> lols
05:46:27 <lambdafan> is there a more efficient way to merge two sorted lists?
05:46:40 <lambdafan> other than (<>)
05:46:55 <hpc> lambdafan: do you want [1,3] ++ [2,4] to be [1,2,3,4]?
05:47:05 <lambdafan> hpc : yes
05:47:15 <lambdafan> but the lists are already sorted
05:47:36 <lambdafan> hpc : so [1,2] ++ [3,4] == [1,2,3,4]
05:47:59 <lambdafan> hpc: I can't see anything better than (++)
05:48:11 <hpc> oh sorted as in you already know head (second list) > last (first list)
05:48:21 <hpc> (++) is the fastest then yes
05:48:23 <lambdafan> hpc: this is a codewars challenge, and it seems too easy so I htink I am missing something
05:48:34 <lambdafan> hpc, huh
05:48:38 <lambdafan> okay then
05:48:43 <hpc> if you want it to be faster, switch data structures
05:50:49 <lambdafan> ah I see what the trick is
05:57:45 <Gurkenglas> Why is http://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.OldList.html#genericLength slower than http://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.Foldable.html#length ?
05:58:05 <Gurkenglas> (Oh wait because it's lazy isn't it nvm shoulda seen that)
06:09:22 <cocreature> Gurkenglas: it will first build up 1+(1+(1+…)) before it can start evaluating anything
06:10:07 <cocreature> so strictness wouldn’t even help here
06:10:33 <cocreature> I wonder why it is that way
06:10:39 <cocreature> seems a bit silly
06:11:36 <cocreature> I guess if the rules figher it’s not actually a problem
06:11:54 <cocreature> and if you had lazy naturals it might actually be useful but nobody uses lazy naturals
06:12:09 <hiro`> I'm using emacs with haskell-mode and ghc-mod. What's a good workflow for working with projects? For example, I want to work through this: https://earldouglas.com/notes/lambdaconf-2015-web.html I'm in the ex1 directory. When I open src/Main.hs, emacs underlines the Spock import because it can't find it. The project also fails to compile when I open the repl because it can't find the import.
06:17:43 <hiro`> I can cabal run from a shell and everything works okay, so it seems that the issue is with the way I've set up or am using emacs.
06:19:19 <snoba> hi! I'm doing some CG stuff and I wanted to try doing it in haskell. which library should I use for performant matrices and vectors? i looked at linear and hmatrix, but not sure what performance characteristics I can expect from them. or should I roll my own library, as I only need 3d vectors and 4x4 matrices (at least for now)?
06:21:55 <tsahyt> Hello. I'm trying to cache results of functions again, but this time I want the cache to be of limited size, because the domain of the function I'm caching is rather large, and in the worst case I'm gonna use very large parts of it. So I suppose that building a lazy map wouldn't work this time. Is there anything on hackage that provides a cache like this?
06:27:06 <cloudhead> tsahyt: maybe lrucache with a maxSize?
06:28:01 <tsahyt> cloudhead: I'd prefer something based on unordered-containers for performance
06:28:10 <tsahyt> The cache package might actually fit the bill but it seems to be very new
06:29:48 <cocreature> I recently published an lrucaching package which should be reasonably fast
06:31:23 <cloudhead> hmm
06:31:49 <cocreature> but the cache package looks fine if you are ok with living in IO/STM
06:31:50 <tsahyt> cocreature: I'm looking at it right now. When using this I still need to reinsert elements back into the cache after they have been purged, right?
06:32:26 <cocreature> tsahyt: yeah, how else do you expect it to work?
06:32:38 <tsahyt> with the other caching structures that I've been using (i.e. lazy HashMap), I could just create the whole map beforehand and elements would be filled in when needed due to laziness
06:32:47 <tsahyt> I guess that's not possible when you need to free things up again
06:33:03 <cocreature> yeah if you want to free them you really need to throw them away
06:33:09 <cocreature> which means that they need to be reinserted
06:33:24 <tsahyt> I was hoping for something completely transparent
06:34:01 <cocreature> does the function you are trying to execute perform IO or is it just an expensive pure computation?
06:34:10 <tsahyt> it's pure
06:37:04 <cocreature> hm I guess I could try adding an API such as https://hackage.haskell.org/package/lrucaching-0.3.0/docs/Data-LruCache-IO.html#v:cached for non IO stuff. not sure if you don’t shoot yourself in the foot when ghc decides to share stuff or something like that
06:37:52 <cocreature> also it would obviously need to return a new cache
06:38:12 <tsahyt> yes, I realized that already. It adds some state one way or the other
06:39:09 <tsahyt> While the computation is pure, the caller is in a monad stack with IO as its base. I guess I could use this API, there's nothing keeping me from wrapping the result in IO after all
06:39:28 <jchia_> I'm trying to write a function getRecs :: Get ([Rec], Maybe String), basically for deserializing Recs from a bytestring using cereal. I want to return a list of all the  Recs I can get. The Maybe String is the first error I get, if any, from deserializing a Rec. That means if there's an error, there can still be a non-empty list in the result consisting of the Recs deserialized before the error. How can I do this? The main problem is I don't know how to 'catc
06:40:49 <jchia_> Also, I already have a Get Rec available.
06:41:00 <bergmark> jchia_: you cut off after "I don't know how to 'catc"
06:41:23 <jchia_> ... I don't know how to 'catch' a fail in the do block of my Get, and I think catching a fail is not something that can be done. I'm trying to do lazy IO, so that if only the head of the list is needed, I won't try to process the whole bytestring, but if the Maybe String is needed, then I'll try to process the whole bytestring.
06:42:28 <cocreature> jchia_: there are also various packages specifically for memoizing function results, e.g. data-memocombinators but I don’t know of one offering lru semantics
06:42:59 <jchia_> cocreature: I'm trying to do lazy deserialization of the records. How does that relate to memoization?
06:43:09 <cocreature> oh sorry I meant tsahyt
06:43:11 <cocreature> I got confused
06:44:45 <orion> Has the cabal.config file for Stackage been deprecated?
06:45:05 <hvr> orion: I hope not
06:45:39 <orion> hvr: I know it's at https://www.stackage.org/{resolver}/cabal.config, but I can't find a direct link on the website.
06:48:20 <tsahyt> cocreature: Having a finite size for the cache is crucial in my case, as I can have something on the order of 2^100 possible inputs to my function on a medium-sized problem
06:49:04 <tsahyt> seeing as Maps and HashMaps are strict in their keys I can't even begin to construct this thing. I suppose that being explicit about what I cache will be absolutely necessary
06:50:18 <cocreature> do you call the function with more or less random inputs or are they somehow ordered? an lru cache with 100 elements won’t save you if you have 2^100 possible inputs and they are random
06:50:42 <tsahyt> they are ordered
06:50:59 <tsahyt> and it's highly likely that I'll visit the same few inputs multiple times
06:51:08 <cocreature> so you only need a cache size of 1?
06:51:21 <tsahyt> no, about 100 elements would do
06:52:11 <tsahyt> it happens as part of a tree-search like algorithm. not exactly the same but close enough. reaching search depths of 100 will take long enough on its own that no cache can save me anyhow. but it's nice to know that calculation of the heuristic function on backjumping isn't gonna be the bottleneck
06:52:40 <tsahyt> unfortunately I have to recompute (or cache) because my code isn't what's doing the actual search. I only respond to queries for heuristic values from an external solver
06:53:19 <tsahyt> I've got one version replicating the search, but that locks the solver too tightly into one way of searching and doesn't play well with using other heuristics alternatingly etc
06:53:24 <tsahyt> so caching it is
07:07:03 <hpc> Cale: that cubical type theory talk is so far making a lot more sense than i expected it to
07:07:22 <hpc> Cale: it's pretty neat
07:07:33 <Jenaf> is there a way to "import" another .hs source file?
07:08:09 <tsahyt> Jenaf: what's wrong with just using import?
07:08:24 <Jenaf> it gives my a parse error
07:08:47 <tsahyt> can you post an example in a pastebin?
07:08:51 <tsahyt> lpaste.net for example
07:09:26 <Jenaf> I have the file foo.hs in wich the function bar :: Int -> [Int] is defined
07:09:40 <Jenaf> and in the other file i just typed import foo.hs (bar)
07:09:50 <tsahyt> you need to define it as a module, and use the module name with the import statement
07:09:51 <Jenaf> and ghci says parse error on foo
07:10:03 <tsahyt> the parse error is because module names start with upper case letters
07:10:15 <Jenaf> and how do i define a module?
07:10:21 <tsahyt> e.g. module Foo where ..., and then use import Foo in the other file
07:10:39 <tsahyt> see here for some more detail http://learnyouahaskell.com/modules
07:13:46 <Jenaf> okay thy it seems to work now; i just added "module Foo (bar) where " to the beginning of the foo.hs file
07:14:25 <Jenaf> (technically it's an O(n sqrt n) prime sieve i wrote myself; not obtimal but handmade ^.^
07:15:11 <bsmt> hand crafted? artisinal bits?
07:16:22 <Jenaf> I'm learning haskell and doing projekt euer problems to do so
07:16:50 <Guest5434> Hi
07:17:02 <Jenaf> and the first sieve i wrote was in O(n^2) ; and for one problem it at least terminated overnight; but my second version finished within seconds, yay
07:17:24 <Jenaf> still not the perfect runtime for sieve of erathostenes, but at least not too complicated
07:28:20 <haskell993> Is there anything wrong if Bool would supports + and * operators same as Numbers. It looks like they have same laws.
07:28:48 <tsahyt> but + and * are part of the Num class and don't exist on their own
07:29:00 <hpc> there's an instance that obeys the laws you would normally expect from numbers
07:29:10 <tsahyt> i.e. you'd need to implement the other parts of Num too and not all of these make sense for Bool I think
07:29:30 <hpc> fromInteger = odd, (*) = (&&), (+) = xor (iirc), etc
07:29:44 <hpc> writing it will get you odd looks though ;)
07:29:53 <tsahyt> hpc: what's abs False?
07:30:05 <hpc> abs = id
07:30:09 <tsahyt> ok
07:30:24 <dramforever> hpc: just fromInteger looks
07:30:26 <tsahyt> how is (-) defined?
07:30:52 <hpc> also xor, i think
07:31:05 <tsahyt> so a + b == a - b. that' looks a bit weird indeed
07:31:07 <hpc> i try not to put much effort into remembering exactly what the right instance is ;)
07:31:18 <maerwald> putting Bool in Num class will do no good. We already have a too fuzzy type distinction in C in that regard and it's the root of a lot of confusion.
07:31:55 <tsahyt> what exactly are the laws of Num anyhow?
07:32:05 <tsahyt> is there some equivalent algebraic structure?
07:32:39 <Elision> it's pretty much a ring... plus a mapping to and from integers
07:32:41 <Elision> iirc
07:33:04 <hpc> plus (-) which is a bit of funny business, and abs/signum
07:33:31 <hpc> any laws you could give for Num you can make a reasonable case for breaking
07:33:33 <Elision> - should be fine in any ring
07:33:37 <hpc> with Float and such
07:33:41 <hpc> Elision: what about Nat?
07:33:44 * hackagebot memorypool 0.1.0.0 - basic memory pool outside of haskell heap/GC  https://hackage.haskell.org/package/memorypool-0.1.0.0 (lspitzner)
07:33:48 <Elision> nat isn't a ring, it's a semiring
07:33:53 <Elision> rings need to be a group under addition
07:33:58 <hpc> sure, but do you want Nat to not be an instance of Num?
07:34:09 <tsahyt> hpc: I'd want a different numerical hierarchy
07:34:21 <hpc> tsahyt: ding ding ding!
07:34:21 <Elision> are they now? what's 4 - 10?
07:34:29 <barrucadu> 0
07:34:40 <Elision> well that's just silly
07:34:41 <tsahyt> a runtime error
07:34:44 <hpc> 0 or bottom are the only things you can argue for
07:35:08 <Elision> indeed
07:35:20 <Elision> well, you could argue for 6, but not very convincingly I expect
07:35:35 <tsahyt> well right now it's an arithmetic underflow exception
07:35:57 <hpc> well if Nat is anything like Bool (which is obviously the simplest Num instance), 4 - 10 would be 14
07:36:04 <Elision> exceptions are bad
07:36:06 <Elision> hpc: heh
07:36:30 <Jenaf> i get an error in patter matching on 
07:36:34 <Elision> (-) = (+) makes sense in bool, that's kind of how boolean algebras work
07:36:44 <tsahyt> so, historical reasons aside, why don't we have a "proper" numerical class hierarchy?
07:36:54 <Elision> pretty sure it's just hysterical raisins
07:37:00 <Jenaf> foo :: int -> [Int] -> t ; foo a b:c = ...
07:37:07 <Elision> I can't imagine any other reason to require fromInteger and signum
07:37:11 <Jenaf> did I make an obvious mistake?
07:37:20 <hpc> tsahyt: the sheer amount of code that would need to change, updating resources for teaching the numeric hierarchy
07:37:31 <hpc> tsahyt: the absence of a proposal convincing enough to actually go through the effort
07:37:34 <implementation_> Elision: fromInteger is probably for literals
07:37:49 <dramforever> Jenaf: foo a (b:c) if that's what you meant
07:37:54 <tsahyt> hpc: why not just reuse the hierarchy of algebraic structures? I mean we already have semigroups and monoids.
07:37:58 <Jenaf> oh yeha thy
07:38:03 <tsahyt> why not just add groups, rings, and fields
07:38:04 <Jenaf> I keep forgeting the parens there
07:38:16 <maerwald> tsahyt: and break how much code?
07:38:22 <Elision> there are libraries that build this up from scratch, for sure
07:38:29 <tsahyt> maerwald: well that's part of "historical reasons" I think
07:38:36 <maerwald> yes
07:38:53 <maerwald> historical mistakes, there've been a lot, but it's hard to just revert them
07:38:55 <Elision> implementation_: I feel like you should be able to separate that from everything else
07:39:14 <hpc> tsahyt: someone has to do the work and say "this is what it's going to be defined as, these are the instances, consumers of numeric code need to change under these conditions, this is how we will transition"
07:39:18 <Elision> maerwald: revert? nonsense, let's just go over here and found Haskell 3000
07:39:42 <maerwald> even String is now considered a historical mistake often, but it's spread all over base and other libs and codebases
07:39:43 <tsahyt> I suppose there is a library implementing such a hierarchy though, right?
07:40:16 <hpc> tsahyt: and then it gets reviewed, checked for problems, it possibly gets into GHC first as a proof of concept, and then slowly gets into the language spec
07:40:23 <tsahyt> maerwald: string is mostly just misused imo. It describes perfectly what it is, it's just that people thought it was a good idea to use lists of characters for text processing..
07:41:00 <hpc> if lists are loops waiting to happen, String is a consumer of text waiting to happen
07:41:15 <barrucadu> If it was undesirable for String to be used for text processing, the alias shouldn't exist.
07:41:18 <dramforever> subhask does it. But it might be over-doing it with all those algebra stuffs
07:41:20 <maerwald> tsahyt: I disagree, it would have been better if there was [Char] and String being something different
07:41:28 <maerwald> barrucadu: exactly
07:41:46 <tsahyt> Maybe I've just got a different idea of what a string is
07:42:04 <maerwald> similarly, [Word8] is not ByteString
07:42:27 <dramforever> So the situation: standard stuffs suck
07:42:49 <dramforever> with so tiny but so important parts
07:43:13 <tsahyt> so I just looked at subhask and the first thing I find is the Logic type family. That might indeed be overdoing it a bit.
07:43:35 <Theophane> hello there!
07:43:46 <dramforever> Um, I mean the standard stuffs are pretty good, but they suck at so, you know, tiny but by so fundamental stuffs
07:44:10 <Elision> I think subhask is pretty niche
07:44:37 <Theophane> I'm writing a TCP client library for a server that I wrote, and I need to reuse the socket I open for the library's network operations
07:44:49 <haskell993> So if there is new class Ring with four members add, mul, zero, one could Bool have its instance?
07:44:51 <dramforever> Looks like some "introduction to abstract algebra"
07:45:10 <Elision> yes
07:45:21 <implementation_> add = xor, mul = &&, zero = False, one = True
07:45:22 <Elision> add, mul, zero, one, and neg, to be precise
07:45:24 <tsahyt> Acutally the algebra package looks a bit more useful in that regard, but still rather involved
07:45:26 <Elision> neg = id
07:45:51 <Theophane> I'm coming from an Elixir/Erlang background, so storing a socket reference in a process is the way I'd do it
07:45:58 <Theophane> but in the context of haskell I'm quite lost
07:46:01 <Elision> your class would be Semiring and Nat could have an instance there : )
07:46:14 <Theophane> I've read a bit about the green threads but I never used them
07:46:44 <dramforever> Theophane: you can totally have a Socket value
07:46:55 <ph88> hey guys i wrote a parser script in php and it's fking slow .. it captures offset of strings found because otherwise it cant figure out the meaning. Can i do this with attoparsec ?
07:47:14 <tsahyt> haskell993: as always, edward kmett has done it already. here's a semiring class with Bool as an instance http://hackage.haskell.org/package/algebra-4.2/docs/Numeric-Algebra-Class.html#t:Semiring 
07:47:26 <implementation_> ph88: of course you can
07:47:32 <Theophane> dramforever: where? :D
07:47:47 <Theophane> in the main thread? in a green thread?
07:47:54 <Theophane> how would I store the reference?
07:47:55 <dramforever> Are you using this? http://hackage.haskell.org/package/network-2.6.3.1/docs/Network-Socket.html
07:47:56 <ph88> it needs like 2 hours and 2GB to parse a 30mb file -___-
07:48:16 <Theophane> ph88: oh dear that's awful :(
07:48:20 <ph88> and the worst thing is i have to run this script every time i make a modification in my code and want to check the results
07:48:26 <dramforever> Hmm...in a process?
07:48:51 <Theophane> yes I'm using Network.Socket :)
07:48:52 <tsahyt> I think I shall start using the algebra package just to get a proper numerical typeclass hierarchy. and to annoy people who didn't study abstract algebra.
07:49:27 <Theophane> dramforever: I'm quite formatted for the Open Telecom Platform so I'm going to have to wrap my mind around this 
07:49:38 <ph88> but how do i capture with attoparsec where in the line a string was found ?
07:49:41 <dramforever> So which part of 'create a socket, use the socket, reuse the socket' are you having problems with?
07:49:53 <Cale> tsahyt: The main reason we don't reuse the numerical hierarchy from math is that most of the things we want to talk about aren't actually rings.
07:50:07 <haskell993> Is anyone know why purescript has separate class for Bool and don't use Ring https://github.com/purescript/purescript-prelude/blob/master/src/Data/HeytingAlgebra.purs ?
07:50:08 <tsahyt> Cale: I.e. floating point numbers?
07:50:14 <Cale> yeah, and anything based on them
07:50:49 <tsahyt> Cale: I think it's a bit of an exaggeration to say that's "most" things though. I find myself using ints much more, but I suppose it depends on the domain of your problem
07:51:02 <jonored> I think ints also don't pass that test?
07:51:11 <tsahyt> but even then, treating floating point numbers as "kinda sorta ring-like" is a decent enough assumption imo
07:51:15 <jonored> or do they pass it weirdly?
07:51:18 <Cale> Int kind of does pass it
07:51:20 <Theophane> dramforever: well since I'm new to the language it's mostly a matter of program design
07:51:34 <Cale> But Int wouldn't be a valid ordered ring.
07:51:41 <tsahyt> true, because of its finite nature
07:51:46 <ph88> implementation_, i don't think it's possible with attoparsec !
07:51:54 <hpc> jonored: the problem is you now have a bunch of "this works on all rings" operations that do weird things with floating point numbers
07:51:59 <tsahyt> Cale: but there's still Integer
07:52:01 <hpc> jonored: and you just have to know "these are broken"
07:52:15 <tsahyt> and yes I know, those are technically bounded too
07:52:27 <Cale> tsahyt: The main remaining problem with Num is really just that abs and signum probably deserve to be in their own class.
07:52:36 <jonored> hpc: Yep. floting point numbers basically just /don't/ satisfy any laws.
07:52:48 <dolio> That's also not true.
07:53:02 <Cale> They satisfy commutativity laws :)
07:53:14 <tsahyt> hpc: well they kinda sorta behave the same (within some epsilon)
07:53:24 <hpc> they have their own laws as well that are not theoretically interesting
07:53:29 <tsahyt> but yes, they're not associative as such for example
07:53:30 <Cale> It's just distributivity and associativity laws that fail
07:53:33 <hpc> so they aren't formulated in any context outside IEEE floats
07:53:56 <dramforever> Theophane: =( I don't know anything about erlang
07:53:58 <Theophane> dramforever: I think I'm trying to mimic the behaviour of http://elixir-lang.org/docs/master/elixir/Agent.html
07:54:12 <tsahyt> Still, the cases where I had to pay attention to the lack of associativity of floating point numbers have been few and far between in the past
07:54:21 <implementation_> ph88: why do you think so?
07:54:40 <tsahyt> assuming that they do behave like proper real numbers has been good enough in the vast majority of cases in my experience
07:55:13 <dolio> Yeah, if you're doing something where that matters, you probably need to be an IEEE expert, because there's a bunch of other things that matter.
07:55:45 <Cale> But yeah, my first impression too was that we ought to have classes like "Ring" and "Field", but over time I've come to appreciate the fact that they didn't go with those names, given that they'd often be lies anyway.
07:55:48 <jonored> Now, calling them all approximations of the mathematical concepts is probably appropriate.
07:55:50 <tsahyt> dolio: dealing with lack of precision in floating point calculations can be an absolute nightmare
07:56:07 <tsahyt> I've spent about 2 months last summer doing nothing but fixing bugs related to this. epilons everywhere..
07:56:12 <tsahyt> epsilons*
07:56:28 <jonored> it /would/ be nice to have the operations grouped along ring/field/etc lines.
07:56:36 <Cale> They kind of are
07:57:59 <Cale> abs and signum aren't usually part of the structure of a ring, but the other operations in Num are. Fractional is roughly like Field then.
08:00:14 <Cale> I'm just glad that we don't still have spurious Eq and Show superclasses on Num :)
08:01:00 <Cale> Integral roughly corresponds to "Euclidean domain"
08:01:23 <Cale> I don't believe mathematics has a proper name for what Floating is.
08:02:48 <Cale> (It probably doesn't quite deserve to be called Floating, since it doesn't really have anything to do with floating point...)
08:04:03 <ph88> implementation_, because i google for attoparsec + identation parsing i don't really find anything
08:04:12 <carter>  Even if you have exact numbers there's all sorts of fun conditioning / stability issues that would still happen
08:05:34 <hpc> Cale: if Integral is euclidean, Floating perhaps expresses stretching and contracting of the domain?
08:05:56 <dramforever> Transcendental?
08:06:15 <implementation_> ph88: am i understanding that right? the fact that noone wrote an article about your exact application makes you believe it's not possible?
08:06:33 <dramforever> then again what do those functions have in common...
08:07:03 <jonored> Fair. And I suppose there's not really a way to support the "and a with this operator is a monoid, and a with that operator is an abelian group" comfortably.
08:07:55 <tsahyt> jonored: the problem is the "with this operator" part. the best you can do is really wrap things into newtypes
08:09:15 <jonored> tsahyt: Yeah, that's what I was just getting to. There's just not a comfortable way to do that with typeclasses.
08:09:29 <danza> hi all, i would like to have some general indications about using Haskell for system automation. I did an experiment with Turtle, but the result was quite disappointing. What is your Haskell tool of choice for these kind of tasks? Shake?
08:09:34 <dramforever> Calling them 'IEEE' sounds like a parody /s
08:10:01 <tsahyt> jonored: to be fair the abelian part is also a bit of a problem since you can't encode the proof for being abelian. but that's a general problem with typeclass laws in Haskell
08:10:12 <danza> system automation is maybe the wrong term ... i basically want to replace Bash with some Haskell
08:10:19 <shapr> turtle?
08:10:36 <danza> Turtle was disappointing, since i get a lot of runtime errors
08:10:42 <shapr> aw :-(
08:10:50 <danza> and not very informative
08:12:12 <Jenaf> I'm not sure if my approach to get all proper divisors of a number is the best... maping product over the set of subsets of the prime factorisation ...
08:12:29 <jonored> tsahyt: Well, yeah, but I'm not terribly upset by "this is an unchecked but declared law that is part of the meaning of this typeclass". It at least keeps track.
08:12:33 <shapr> danza: have you found better options?
08:12:59 <tsahyt> jonored: Neither am I, although I'd like to have some tooling to check typeclass laws. Quickcheck only gets you so far.
08:13:06 <danza> shapr, no i am asking just now ... maybe i can try Shake ... or maybe i should just use plain Haskell
08:13:14 <tsahyt> I guess there's always the option to translate it to Agda and do the proof there
08:13:29 <tsahyt> jonored: basically just some kind of guarantee other than "trust me, I did some equational reasoning"
08:14:09 <tsahyt> jonored: I mean there are some cases where typeclass laws are being violated and it's okay. iirc there are a few monads that aren't actual monads for example.
08:20:31 <jonored> There's definitely some balancing between "convenient to use" and "is technically correct". And a "less than a monad but still satisfies enough for /these/ operations to be useful" is likely awkward, and is /definitely/ awkward with where we are.
08:21:31 <ph88> implementation_, google search also on hackage
08:24:18 <implementation_> ph88: What exactly are you looking for? If I search "attoparsec" on hackage, i find the Haddocks. If I search "attoparsec" on google I even get some tutorials on how to use it.
08:25:28 <ph88> to know the position of the string on the line
08:26:03 <ph88> i think i will use this parser instead https://mrkkrp.github.io/megaparsec/tutorials/indentation-sensitive-parsing.html
08:28:24 <implementation_> ph88: megaparsec is a fine package, but all of the stuff from the article is just for convenience. you can do the same things with attoparsec, it just might not be as beautiful.
08:30:37 <maerwald> attoparsec is not a monad transformer
08:35:56 <k0ral> Hello
08:35:59 <ph88^> hi
08:36:01 <glguy> How long does it take these days for stack to be able to see packages released on Hackage?
08:38:43 <k0ral> I'm hitting an obstacle when working with ZipConduit (from conduit package obviously); I'm observing, and the documentation seems to confirm, that leftovers from each component aren't propagated to the "global" conduit
08:38:54 <cocreature> glguy: for stack or for stackage?
08:39:15 <glguy> stack
08:40:06 <geekosaur> the job that updates their mirror-plus-added-metadata runs daily
08:40:19 <k0ral> so now I'm having this `let g = getZipConduit $ f <$> ZipConduit conduit1 <*> ZipConduit conduit2`, and I wish no element were consumed by g if both conduit1 and conduit2 "rejected" input by pushing it back as a leftover
08:40:33 <glguy> and is there a way to not using that mirror to avoid the delay when testing releases?
08:41:11 <k0ral> any idea how to achieve that ?
08:41:40 <cocreature> glguy: you can point it at a tarball iirc
08:41:48 <glguy> a tarball of hackage?
08:41:53 <geekosaur> or at a hackage release directly
08:42:00 <cocreature> - location: https://example.com/foo/bar/baz-0.0.2.tar.gz
08:42:07 <cocreature> put that in packages
08:42:13 <glguy> Oh, no I know how to manually install things
08:42:29 <glguy> but if that's as good as it gets
08:42:37 <geekosaur> the "plus metadata" part makes avoiding the mirror difficult
08:43:02 <cocreature> the repo claims that it is updated every 30 minutes but I think it took quite a bit longer the laste time I checked something
08:43:03 * geekosaur thinks it ought not claim to be a mirror when it's a mirror plus stuff that is required to actually use it
08:43:24 <glguy> Yeah, it used to be 30 minutes, but that doesn't appear to be the case any more
08:44:08 <racketschemer> Hi!
08:44:31 <ph88^> hi
08:44:32 <cocreature> seems to be updated irregularly
08:44:37 <cocreature> at least once a day but sometimes more
08:44:44 <geekosaur> from when I tracked this down yesterday: 2016 Aug 24 17:22:09 <geekosaur>	G*rkenglas, because "Uploaded	Wed Aug 24 16:34:37 UTC 2016" but "Commercial Haskell all-cabal-hashes Travis job Update from Hackage at 2016-08-23T20:48:01+0000"
08:44:52 <cocreature> geekosaur: what kind of metadata are they actually adding?
08:45:11 <geekosaur> that I do not know
08:45:49 <cocreature> ah the readme mentions it
08:46:41 <cocreature> byte count of the tarball, different hashes of the tarball & download urls
08:49:15 <glguy> Trying to list the tarball gets me stack: Cannot decode byte '\xf1': Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream
08:49:23 <cocreature> ouch
08:49:39 <glguy> I guess that goes to the point of the recent discussion on libraries@ about decodeUtf8 :)
08:50:14 <glguy> Oh well, I'll just continue testing with cabal and assume everything is fine on the stack side
08:53:35 <sm> glguy: worth filing a bug about slow mirroring
08:53:47 * hackagebot yesod-auth-oauth2 0.2.2 - OAuth 2.0 authentication plugins  https://hackage.haskell.org/package/yesod-auth-oauth2-0.2.2 (jferris)
08:53:56 <glguy> sm: I wouldn't expect so
08:54:21 <sm> I'm sure it's not supposed to be that slow
08:56:34 <berndl> Random question: Does Haskell have something similar to reflection that allows me to e.g. get the type of a value?
08:58:03 <pavonia> Yes, see Data.Typeable
08:59:32 <berndl> pavonia: Nice.
08:59:38 <geekosaur> note that you have to derive it and require a Typeable constraint where it is used; you can't just ask for the type of a random value somewhere
08:59:52 <glguy> Typeable doesn't need to be derived any more, at least
09:01:06 <berndl> geekosaur: OK.
09:01:30 <geekosaur> I think you still need to go through the motions?
09:01:54 <geekosaur> otherwise it is still deriving it internal to the compiler but not exposing it, or something
09:02:06 <geekosaur> (backward compatibility, I think)
09:03:39 <glguy> It doesn't do anything in 7.10 and beyond
09:03:42 <glguy> but you'd need it in 7.8
09:15:09 <andromeda-galaxy> In TH, is there a way to, having constructed, say, a Dec, ask GHC to attempt to typecheck it, and then do something based on whether or not it typechecks?
09:18:48 * hackagebot cassava-conduit 0.3.4 - Conduit interface for cassava package  https://hackage.haskell.org/package/cassava-conduit-0.3.4 (domdere)
09:28:42 <berndl> Another question: Is it possible to define a type as the image of a given type under some function?
09:28:48 * hackagebot list-transformer 1.0.1 - List monad transformer  https://hackage.haskell.org/package/list-transformer-1.0.1 (GabrielGonzalez)
09:31:49 <pavonia> berndl: You can have type-level functions (mapping one type to another) with data families
09:34:27 <dkasak> Or type families, if you want the image to be an existing type rather than a new type.
09:37:30 <pavonia> Type families is what I actually meant :S
09:37:38 <berndl> Hmm...but I want a new type. For example, f :: Int -> Int defined by f(x) = 2*x. I want f(Int) to be a new type, the type of even ints.
09:38:08 <EvanR> you can do it with smart constructors
09:38:18 <berndl> Yes, I was thinking that.
09:38:24 <EvanR> mkeven :: Int -> EvenInt which does *2
09:38:31 <EvanR> hide EvenInts ctors
09:38:53 <Clint> then you can't have a Num instance
09:38:57 <EvanR> whatever things make sense only for even ints, are support functions in the EvenInt module
09:39:25 <EvanR> EvenInts do constitute a subgroup
09:39:49 <EvanR> Num is weird anyway
09:40:25 <Gurkenglas> Is there "Fold s a -> (a -> Fold s a) -> Fold s a"?
09:40:59 <Gurkenglas> Actually "Fold s a -> (a -> Fold s b) -> Fold s b". Huhhh monads.
09:41:39 <EvanR> monads. damn
10:00:54 <joe9> I want to run a task in the background and move on. With async, I would have to call "wait" to ensure that the task finished. Should I just use forkIO?
10:01:32 <joe9> The task is just writing to a file. So, there is a big possibility that it will just run fine.
10:01:50 <maerwald> there are 5000 ways a file write can fail :o
10:02:07 <joe9> or, I can start async, and store the Async values in a list and waitAny on it in the next iteration.
10:02:12 <joe9> maerwald: yes, agreed.
10:02:21 <Sonolin> so there's no way to implement bind using just Applicative right? 
10:02:42 <ReinH> Sonolin: No, that's what Monad can do that Applicative can't.
10:02:50 <Sonolin> ok, makes sense
10:03:23 <Sonolin> I'm starting implementing instances from Functor -> Applicative -> Monad and naively thought something like "\m k -> fmap k m >>= id" would work
10:03:28 <Sonolin> but obviously that's endless recursion
10:04:15 <joe9> maerwald: so, map poll on [Async a] -> in the next iteration?
10:05:05 <joe9> maerwald: or, waitAny
10:05:52 <maerwald> joe9: maybe something like forkFinally?
10:06:08 <joe9> maerwald: ok, Thanks. will check it out.
10:06:19 <Cale> joe9: I would usually use forkIO unless I cared about the result of a computation. The question is what should be done about it if/when the thing fails
10:06:58 <Cale> async is specifically geared toward forking off computations which are going to produce a result we're going to need at some point in the future
10:07:23 <Cale> Though I have seen people use it just for the added exception handling mechanics
10:07:31 <joe9> maerwald: forkFinally masks asynchronous exceptions. I do not think it is a great idea.
10:08:03 <joe9> Cale, Thanks. I think forkIO is what I need.
10:08:42 <joe9> I do not care about the result of the computation. But, if there is an exception, I want it to be raised. and I want the thread to  be responsive if the user presses Ctrl-C, etc.
10:09:05 <Cale> You want it to be re-raised in the main thread?
10:09:18 <Cale> (asynchronously?)
10:11:56 <joe9> Cale, no, not asynchronously. just the "throw" mechanism that is used generally.
10:12:31 <joe9> Cale, but, if the main thread is dying or died, then I would want the forked thread to also die. (it will be receiving an asynchronous exception of ThreadKilled.)
10:12:56 <Cale> If the main thread ends, the whole program ends, along with all its threads.
10:13:27 <Cale> and the child threads don't get any chance to do anything about it -- you have to be careful about killing the main thread
10:15:29 <joe9> Cale, ok. Thanks. so, forkIO for me. Do you use the MVar signalling mechanism in the main thread described in Control.Concurrent documentation?
10:15:47 <joe9> Cale "Terminating the program" section
10:15:51 <Cale> That's a reasonable thing to do, sure.
10:16:00 <codedmart> I have a bunch of files in my repo/folder like ccBsOAxW, ccD03t1X, etc. Looking at them they seem related to stack/haskell. Do I have something configured wrong? I never remember seeing these in my other projects.
10:16:21 <joe9> codedmart: tmpdir setting?
10:16:40 <Cale> codedmart: I've never seen anything quite like that, but I haven't really used stack much at all.
10:18:50 <maerwald> joe9: with forkFinally you know when a child terminates, which is probably useful for file operations
10:19:29 <codedmart> joe9: Is that something I am suppose to set or change?
10:20:01 <codedmart> I haven't set that on my other projects
10:21:12 <geekosaur> it's something to check for ($TMPDIR). although I don't know why it would be set, unless you're on OS X (in which case it would not be current directory) or you had explicitly set it for some reason
10:21:26 <joe9> maerwald: the IO thread is opening and closing the file. the file operation I am using is "atomicWriteFile", so I am not worried about the file opening/closing.  I just want the IO thread to run something in the background and finish it's task or raise an exception if something bad happens. I do not want the main thread to keep checking on it.
10:21:40 <codedmart> geekosaur: Actually this project is run in a docker container.
10:21:45 <codedmart> Maybe that is related somehow.
10:22:01 <codedmart> Because my other projects aren't and I don't see this same issue.
10:22:04 <cocreature> try looking at the value of TMPDIR in the docer contianer
10:22:28 <joe9> codedmart: try running a simple program returning the value of tmpdir
10:22:30 <sm> joe9: how will it raise an exception in the main thread, except asynchronously or by the main thread waiting on or polling it
10:22:38 <maerwald> joe9: you are basically providing a callback with forkFinally, the main thread does not "keep checking on it"
10:24:28 <codedmart> geekosaur cocreature joe9 `echo $TMPDIR` is blank in the docker container. I must need to set that.
10:24:44 <geekosaur> no
10:25:09 <geekosaur> the question was whether something *had* set it to the build directory so that temporary files were being created there instead of elsewhere
10:25:31 <codedmart> Oh no not to my knowledge.
10:26:33 <joe9> sm, maerwald, the difference between forkFinally vs forkIO (from what I understand) is that with forkFinally, I would be using the throwTo on Left value. whereas with forkIO, that is done automatically on exception.
10:26:51 <joe9> s/throwTo/throw/
10:30:29 <balac> @pl (\f x -> f x )
10:30:30 <lambdabot> id
10:31:21 <balac> @unpl (. flip id) . flip map 
10:31:21 <lambdabot> (\ x x0 -> map (\ y -> y x0) x)
10:32:03 <maerwald> joe9: how do you perform cleanup?
10:33:27 <joe9> maerwald: there is nothing to cleanup
10:33:31 <cocreature> joe9: the difference between forkFinally and forkIO is that forkFinally executes the passed callback when the thread is about to die
10:33:54 <cocreature> and by thread I’m referring to the newly created thread
10:34:07 <maerwald> joe9: that's rather rare with file operations, but I don't know what file operations you actually do
10:35:36 <joe9> maerwald: http://dpaste.com/0XBDH8D is my code.  line 67 is the forkIO call.
10:35:42 <maerwald> e.g. portable file copy (across devices): start copying, target device is full... you now have a broken file on the target device
10:35:51 <joe9> maerwald: line 146 is the file write.
10:36:12 <joe9> maerwald: those situations are raised by the called thread as exceptions, correct?
10:37:01 <maerwald> https://hackage.haskell.org/package/atomic-write-0.2.0.5/docs/src/System-AtomicWrite-Writer-ByteString.html#atomicWriteFile
10:37:07 <maerwald> uhm
10:37:32 <maerwald> so it writes to a temp directory first?
10:37:44 <maerwald> that one can already raise an exception
10:37:57 <maerwald> closeAndRename can also raise one
10:38:41 <joe9> maerwald: I am sure something can always fail. I am not disputing that. When a failure happens, the thread raises an exception, correct? the exception gets propogated to the parent thread (or, main thread) automatically, correct?
10:38:42 <maerwald> now the question is whether tempFileFor already does cleanup
10:39:42 <joe9> maerwald: propogated to the parent try/catch exception handler (that could be the parent, grand parent, etc.)
10:41:16 <joe9> maerwald: does that make sense?
10:41:50 <cocreature> joe9: “the exception gets propogated to the parent thread” no they don’t
10:41:53 <EvanR> normally no, when a thread crashes the exception goes to a uncaught handler separate from the main thread, it prints the error to stderr, and stuff continues
10:41:57 <sm> joe9: there's no automatic propagation of exceptions to the parent thread, you have to explicitly throwTo it (asynchronous exception) or use eg the parent child linkage features in async  request that
10:42:02 <cocreature> joe9: that’s one of the reasons why you want to use async
10:42:05 <EvanR> unless its the main thread that crashed
10:42:12 <EvanR> ^
10:43:58 <joe9> oh, really.
10:44:08 <joe9> that makes forkIO very dangerous to use.
10:44:25 <joe9> unless you have an exception handler when you forkIO
10:44:30 <joe9> in the forked thread.
10:44:31 <EvanR> see forkFinally
10:44:41 <EvanR> or use the library async
10:45:04 <EvanR> or sometimes forkIO is fine because you just dont care about errors
10:46:30 <joe9> EvanR: ok, Thanks. In my situation, I do not care for the return value. when using async, I would have to maintain a list of [Async a] values and check the values with waitAny. it is probably a good idea to use forkFinally and then in finally use (_ <- either throw pure) function, correct?
10:47:18 <joe9> maerwald:  Thanks for sticking with the discussion. That was a very wrong assumption in my part. Thanks for clearing it up.
10:48:34 <joe9> sm, cocreature, ^^
10:48:51 * hackagebot rawr 0.0.0.0 - Anonymous extensible records and variant types  https://hackage.haskell.org/package/rawr-0.0.0.0 (pkmx)
10:49:03 <joe9> EvanR: I agree, link is a good idea for this situation.
10:49:30 <EvanR> i dont get _ <- either throw pure
10:51:24 <joe9> maerwald, sm, EvanR:      _ <- withAsync (processResponse umkts mcm) link
10:51:45 <maerwald> joe9: also, in forkFinally if you try to rethrow an exception, it doesn't get rethrown to the parent ofc
10:52:10 <joe9> maerwald: it gets thrown in the main thread?
10:53:16 <EvanR> try it yourself
10:53:22 <joe9> updated code: http://dpaste.com/07JG0MV line 67 replaced the forkIO with withAsync and link
10:54:21 <EvanR> exceptions being thrown in a different thread (asynchronous exceptions) is a thing pretty much unique to haskell, and does not happen unless you explicitly want it to, because its kind of nuts
10:55:48 <EvanR> normally crashing threads or throwing threads which dont catch them have their exceptions handled by the global default handler, which either just prints out the message and possible ends the entire program (main thread crashed)
10:56:04 <maerwald> joe9: as EvanR said it just prints to stderr, so you rethrow the exception in the forked thread
10:56:09 <maerwald> which doesn't do much
10:56:26 <maerwald> the code is also pretty obvious https://hackage.haskell.org/package/base-4.9.0.0/docs/src/Control.Concurrent.html#forkFinally
10:58:06 <maerwald> unfortunately, you have a SomeException constraint there
10:58:15 <maerwald> instead of Exception class
10:58:45 <joe9> maerwald: link seems to do what I want. I am fine with an exception propogated to the next higher up asynchronous exception handler or crashing the program when not handled.
10:58:46 <maerwald> so I'm not sure how useful that is for actual cleanups
10:59:06 <joe9> maerwald: what worries me is if an exception is not handled or raised. (silently failing)
10:59:07 <EvanR> withAsync will already propogate the exception
10:59:19 <monochrom> SomeException is exactly right for "finally" stuff and cleanups
10:59:22 <EvanR> so will await
10:59:38 <maerwald> monochrom: why would that be
10:59:54 <joe9> EvanR: where is await?
11:00:12 <EvanR> i mean, wait
11:00:33 <joe9> EvanR: ok, Thanks. I think link is perfect for this purpose.
11:00:52 <EvanR> but... 
11:01:25 <EvanR> i didnt sound like link is necessary for your purpose
11:03:21 <joe9> EvanR: Why do you not recommend link? link rethrows the child exception in the current thread . and , that is what a throw from a forkFinally would do, correct?
11:03:58 <EvanR> async already does that
11:04:09 <EvanR> if you wait or use withAsync
11:04:28 <EvanR> and no thats not what a throw from forkFinally would do
11:06:39 <monochrom> You probably misunderstand what could or could not happen to a handler of type like "Exception e => IO a -> (Either e a -> IO ()) -> IO ThreadId"
11:07:10 <joe9> EvanR: 1. with using wait, I do not want to keep the list of [Async a] and check them with wait. 2. putting the current action into the withAsync block, would mean I would have a list of completed Async threads waiting for my current action to end (which might take a long time.)
11:07:22 <monochrom> Here is what could not happen: No matter what exception type is thrown, Your "Either e a -> IO ()" handler is called.
11:07:36 <maerwald> that's what I want
11:07:59 <maerwald> and that's also the reason MonadThrow is problematic, because it forces SomeException on you
11:08:43 <joe9> what is wrong with this, please? _ <- withAsync (someIOaction) (link)
11:08:49 <maerwald> also, the handler is called always anyway for forkFinally
11:08:57 <monochrom> OK, I am not clear what you mean by "that". Do you mean: you prefer no cleanup for some exceptions?
11:09:01 <EvanR> do you just want the forkFinally and on error use System.Exit ?
11:09:26 <EvanR> throwing an async exception in the main thread which has continued on doesnt make too much sense
11:10:05 <maerwald> monochrom: ofc, it makes a difference which exception type is thrown
11:10:17 <joe9> EvanR: I think I get it, doing that changes the Synchronous exception to an asynchronous exception, correct?
11:10:43 <joe9> s/that/_ <- withAsync (someIOAction) link/
11:10:43 <maerwald> monochrom: but one could argue that is abusing "forkFinally"
11:10:48 <EvanR> i just dont understand the entire point of the various parts of your statement
11:10:52 <maerwald> since "finally" means "finally"
11:11:26 <ertes> does anyone use the 'ad' library in production?  i'd like to know what its performance characteristics are compared to hand-coding derivatives
11:11:29 <monochrom> OK, I don't understand you at all.
11:11:30 <maerwald> so you would rather have the catch already in your IO action
11:12:38 <EvanR> joe9: you probably do want to keep all these handles around 
11:13:12 <EvanR> for example if you want the main thread to continue processing stuff while these actions are going, and periodically check them to see if they are done or did crash
11:13:21 <maerwald> monochrom: there are different types of cleanup. Those that depend on the type of exception and those that don't.
11:13:40 <sm> as I said, I think rightly, there are exactly three ways the main thread can notice exceptions in a forked child: it can wait for it synchronously, poll it periodically, or the child can throw an asynchronous exception to it
11:13:52 * hackagebot helium-overture 1.0.0 - A backwards-compatible, modern replacement for the Prelude.  https://hackage.haskell.org/package/helium-overture-1.0.0 (patrick_thomson)
11:13:55 <sm> I wonder which of those you want joe9 
11:14:22 <joe9> EvanR: oh, ok, What would I do on an exception? either throw _ ?
11:14:31 <EvanR> you tell me
11:14:39 <EvanR> i dont understand either throw _
11:17:14 <monochrom> If you are given SomeException, you can use the fromException method to test on the original type and branch based on it.
11:18:26 <monochrom> Suppose I have 4 different cleanup plans, one of AsyncException, one for IOException, one for ArithException, and one for no exception.
11:18:37 <monochrom> Then I will really want to start with SomeException.
11:19:19 <monochrom> Also one of my "4 cleanup plans" could be "do nothing". That's covered.
11:20:10 <joe9> sm, 1. wait for it synchronously: using wait? When I do that I do not gain anything by forking the thread. I could have done the job in the main thread. 2. poll it periodically: using poll? I get a Maybe (Either e a) value. Should I just do "throw e" when the return value is (Just (Left e))? , 3. with the child throwing an asynchronous exception: Is there something wrong with this? If there is no asynchronous exception handler in any of
11:20:10 <joe9> the parent or grand parents, the whole program crashes, correct?
11:20:43 <EvanR> you do gain something with async, because you can wait for multiple threads to all finish, or for the first one to finish
11:21:10 <EvanR> and you dont have to wait right now, you can defer the waiting or crash detection
11:22:05 <EvanR> having the child finally throw an async exception to the main thread is just a complicated way to just use System.Exit
11:23:37 <joe9> EvanR: that option makes the most sense. I would have [Async a] and then "run map poll (as :: [Async a])" periodically. What do I do when there is a (Just (Left e)) return value? Should I just do : "case returnValue of (Just (Left e)) -> throw e"?
11:23:38 <sm> EvanR: how's that ? 
11:24:05 <sm> it's equivalent to System.Exit, because.. ?
11:24:23 <EvanR> it will interrupt the current task main is on and crash the program
11:24:54 <joe9> EvanR, or it propagates to the parent or grand parent asynchronous handler, ?
11:25:02 <sm> and if you called System.Exit in the child thread, much the same would happen ?
11:25:06 <EvanR> theres no parent of main
11:25:21 <EvanR> yes
11:26:05 <sm> but if joe9 wanted to do some pre-exit cleanup, is throwing the async exception and catching it better ?
11:26:19 <EvanR> how do you catch an async exception in main
11:26:19 <joe9> EvanR: only main thread gets asynchronous exceptions? not the parent or grand parent, even there is a throwTo <parent thread id>
11:26:45 <sm> joe9: only the specific thread you throwTo gets it. Unless you use the features in async
11:27:36 <sm> "bubbling up" of exceptions is not the default in haskell, at all (perhaps it should be)
11:28:09 <EvanR> i like the way async is, as a library, where you control the bubbling behavior
11:28:13 <EvanR> thats also how it is in clojure
11:28:23 <joe9> sm, then, _ <- withAsync (someIOAction) (link) -- the link has a throwTo <the parent threadId>
11:28:46 <EvanR> s/parent/this thread/
11:30:01 <EvanR> you can also do x <- async someAction; link x; ...
11:30:26 <EvanR> just to break up the monotony of stating _ <- withAsync (someIOAction) (link) over and over
11:31:01 <monochrom> bubbling up is also the wrong behaviour 50% of the time.
11:31:05 <joe9> EvanR:  I understand your argument of using synchronous exceptions. It makes sense to know why/where an exception occured. But, I do not know if this is what I should do with the return value: "case returnValue of (Just (Left e)) -> throw e"?
11:31:26 <EvanR> if you are just going to rethrow, then why even catch
11:31:45 <EvanR> dont use Either, just let it get rethrown
11:32:22 <EvanR> "what are you actually trying to do" "what do you want"
11:32:30 <joe9> EvanR, so, something like _ <- map poll [as :: [Async a]] ?
11:33:37 <EvanR> theres too much wrong / missing from this question
11:33:45 <joe9> EvanR , I just want an IO operation to go on in the background. On any exception, crash the program (for now). If the crashing is happening too often, I can put a try/catch/handler block on the IO action.
11:33:51 <monochrom> That 50% of the time is when a "parent" thread, even if it cares that a child thread dies horribly, wants to know it from a message queue (say) rather than getting thrown an exception.
11:34:24 <monochrom> I mean, Haskell exception is not Unix signal. Unix signal is resumable, Haskell exception is not.
11:34:57 <monochrom> With Unix signal, bubbling up can be made to always make sense.
11:34:59 <EvanR> joe9: then execute it in an async, a <- async myAction
11:35:31 <sm> joe9: some experimentation may help. What's the simplest thing that could possibly work ? In your shoes I would try either exitFailure or throwTo MAINTHREAD when the child has a problem
11:36:06 <joe9> EvanR, what do I do with 'a'? Why not just "_ <- async myAction"?
11:36:17 <monochrom> But I still feel that "upon signal, add stuff to the message queue, resume" is a pandora box.
11:36:24 <EvanR> because _ <- foo is the same as foo
11:36:42 <EvanR> its useless. not necessarily the question you were asking but its annoying me
11:37:10 <EvanR> async myAction without holding on to the handle is just forkIO
11:37:17 <sm> EvanR: just running with async won't terminate the parent on child exception, you have to wait for that no ?
11:37:18 <joe9> EvanR: I am sorry to annoy you. I am trying to understand if you want me to do anything on the 'a' value now?
11:37:24 <EvanR> right
11:37:33 <EvanR> joe9: save it
11:37:45 <EvanR> and do your background stuff
11:37:48 <EvanR> or foreground
11:38:31 <EvanR> later you can do a for loop and poll for Lefts and do a System.Exit
11:38:39 <EvanR> or rethrow the exception
11:40:24 <joe9> EvanR: ok, Thanks.
11:40:25 <EvanR> heres something that might be even easier, in your main thread, run various asyncs some of which are your "foreground" tasks, then wait on all of them normally
11:40:36 <sm> joe9 said they don't want to wait or poll, just die if there's a problem
11:40:45 <monochrom> EvanR, IIRC there is a GHC warning that people love to turn on, and which requires you to write like "_ <- foo" explicitly.
11:40:55 <EvanR> thats annoying
11:41:08 <monochrom> And why do people love to turn it on? Because it's -Wall IIRC
11:41:19 <EvanR> -Wannoying
11:42:27 <sm> EvanR: also "When called from another thread, exitWith will throw an ExitException as normal, but the exception will not cause the process itself to exit."
11:43:04 <sm> so I think the behaviour joe9 has asked for is given by having the child throwTo MAINTHREAD
11:43:17 <monochrom> You know, I am very lax on personal preferences (especially personal preferences packaged up as holy-than-thou ideologies, for example "every project must insist on -Wall -Werror"), so I would be fine with whatever, except: ...
11:43:17 <balac> @pl (ord c - 96)
11:43:17 <lambdabot> ord c - 96
11:43:44 <joe9>  EvanR  "or rethrow the exception" this is what link does, correct? why bother with storing the a, and looping with wait?
11:43:50 <monochrom> The warning does not require you to write "_ <- return ()", because of the () type.
11:44:05 <sm> but no.. you're right, ExitException will do the same
11:44:11 <monochrom> But if you do such much as "data P = P", then "_ < return P" is required.
11:44:31 <balac> @pl ord c - 96
11:44:31 <lambdabot> ord c - 96
11:44:35 <monochrom> So here we have a cognitive dissonance. Suddenly my own "data P = P" is second-class.
11:44:51 <geekosaur> @pl \c -> ord c - 96
11:44:51 <lambdabot> subtract 96 . ord
11:44:59 <EvanR> they should have implemented that warning with type equivalence to () support
11:45:08 <balac> geekosaur: thanks :)
11:45:10 <monochrom> I am not annoyed by funny ideologies. I am annoyed by self-consistency.
11:45:24 <monochrom> err, self-inconsistency.
11:45:38 <monochrom> People are so hypocritic and they don't know it.
11:46:44 * sm wishes joe9 luck and goes for a lie-down
11:51:43 <maerwald> monochrom: weird, I somehow was thinking you lose information with SomeException. In that case I could also argue the other way around and say "you can use toException to get SomeException" :P
11:52:06 <maerwald> then it's just a matter of taste
11:52:38 <maerwald> (except the 'Maybe e' result of fromException being slightly annoying)
11:55:21 <monochrom> No, bringing up toException is not a good reason. toException and fromException are not exactly symmetric.
11:55:51 <maerwald> how so
11:56:02 <monochrom> But what is symmetric and a good reason is this: Suppose you propose "ff :: Exception e => IO a -> (Either e a -> IO a) -> IO ThreadId".
11:56:34 <monochrom> Then you get to say, for my use case, I can instantiate e = SomeException, there is no loss of generality.
11:58:15 <Cale> hm
11:58:19 <monochrom> So now the only real question is: "Exception e => IO a -> (Either e a -> IO a) -> IO ThreadId" vs "IO a -> (Either SomeException a -> IO a) -> IO ThreadId", which one people actually need more often?
11:58:57 <Cale> The one involving the class constraint is likely to be more convenient in the case where you're not likely to want to catch *all* exceptions
11:59:16 <monochrom> And I think (without taking a poll) that the SomeException is used a bit more often. Simply because most cleanup plans are independent of actual exceptions.
11:59:19 <maerwald> Cale: and you still can catch all if you want very conveniently
11:59:33 <monochrom> Cale, yes for catch, no for "finally" stuff.
11:59:47 <maerwald> right, that's why I was thinking maybe I'm abusing "finally"
11:59:47 <monochrom> "ff" is a variant of forkFinally
11:59:50 <Cale> But monochrom might be right that people just end up using SomeException anyway
12:00:53 <monochrom> "try" and "catch" do have the "Exception e =>" part as you say and I agree.
12:08:54 * hackagebot craze 0.1.3.0 - HTTP Racing Library  https://hackage.haskell.org/package/craze-0.1.3.0 (etcinit)
12:18:30 <joe9> EvanR : http://bpaste.net/show/3f31e6461c88 is my checkAsyncs function.  source : http://dpaste.com/0SY7BQB
12:19:25 <joe9> maerwald: I presume you checked out Control.Exception.Safe
12:20:01 <ertes> i'm intrigued by automatic differentiation, but according to my benchmark the auto-derived logistic function is four times slower than the hand-written one =/
12:20:09 <ertes> (using the 'ad' library)
12:20:40 <ertes> s/auto-derived/automatic derivative of/
12:21:26 <ReinH> ertes: TANSTAAFL?
12:21:54 <maerwald> joe9: no
12:22:01 <ertes> ReinH: i'm not going to look that up =)
12:22:18 <ReinH> No free lunch
12:22:47 <ertes> are there other libraries or methods for automatic differentiation?
12:23:02 <ReinH> Not sure. You could try poking edwardk.
12:23:40 <ertes> it's not that important really…  i'm mostly diffing the logistic function, which has an easy derivative
12:27:43 <lpaste> ertes pasted “Library benchmark: ad” at http://lpaste.net/180563
12:28:08 <ertes> FWIW, this the benchmark i used ^
12:38:23 <athan> Why doesn't Data.Tree.Tree have an Ord instance?
12:38:38 <athan> In the argument of amiguity, couldn't something similar be stated for lists?
12:39:27 <athan> in fact, all you would need is the Node instance, and the rest is derived from lists
12:50:28 <joe9> I am trying to convert a Sequence to a List using Data.Foldable.toList and it is taking forever. Are there better ways of going about it?
12:51:25 <athan> joe9: Sometimes the module implementation is faster, but I doubt it with Seq. Are you sure it's not an infinite sequence?
12:51:26 <ertes> joe9: it shouldn't take forever…  could you paste the code?
12:52:23 <ertes> joe9: the most likely cause is that constructing the Seq is what takes forever
12:52:39 <ertes> athan: that's *very* unlikely
12:53:00 <joe9> ertes: athan : code: http://dpaste.com/1NGCWJK  after line 84, there is no response.
12:53:28 <joe9> athan: ertes: I suspect that it is the (toList ps) that is causing it.
12:54:13 <ertes> joe9: the 'foldl' is very suspicious
12:54:57 <ertes> joe9: switch to the strict foldl' and make sure that the tuple your buildLatestMarket function produces is strict in its components
12:55:23 <joe9> ertes: is there a way to just switch to the strict stuff generally?
12:55:35 <cocreature> -XStrict
12:55:36 <ertes> the easiest way to do that is with -XBangPatterns: let !x = …; !y = …; !z = … in (x, y z)
12:55:52 <ertes> joe9: there is, but i suggest you don't do that
12:56:17 <ertes> joe9: have you tried your code with small parameters to see if it terminates at all?
12:57:28 <joe9> ertes: if you do not mind me asking , why do you suggest not using the strict stuff generally?
12:59:27 <ertes> joe9: because it makes *everything* in your module strict
12:59:36 <ertes> all functions, all constructor fields
13:00:18 <ertes> sometimes it may be appropriate (i've never encountered such a case myself), but i suggest you learn how to write the buildLatestMarket function properly
13:01:08 <ertes> BTW, don't misunderstand -XStrict…  it only makes the definitions in your module strict
13:01:18 <ertes> foldl will still be inappropriately lazy
13:02:26 <joe9> ertes: Thanks. "learn how to write the buildLatestMarket function properly". How do I go about it? just test with a smaller subset of data?
13:03:04 <joe9> ertes, another annoyance,  when using stack repl, i do not have access to the functions of a module unless they are exported.
13:03:45 <joe9> ertes, is there a way to make all functions in the module visible. wHile testing functions, it gets annoying to explicitly export everything and then remove stuff.
13:04:16 <ertes> joe9: first understand the problem:  foldl' is written in such a way that each step is evaluated immediately, but only to the outermost constructor
13:04:20 <geekosaur> maake sure it's compiling to bytecode. this is not always feasible
13:05:17 <ertes> joe9: foldl' (+) (0 :: Integer)  -- this one is fine, because the outermost "constructor" (the number) of an Integer is already the normal form
13:06:07 <ertes> joe9: foldl' (\(s, n) x -> (s + x, n + 1)) (0, 0)  -- the purpose of this function is to compute both a sum and the number of elements in one traversal (e.g. to compute an average)
13:06:26 <ertes> it's similar in structure to your function
13:06:27 <ertes> and it will blow up at run-time, if you feed it a large list
13:06:45 <ertes> the reason is that foldl' only evaluates to the outermost constructor, namely the (,)
13:07:10 <joe9> ertes: oh, ok. makes sense. remove the foldl and write a recursive function?
13:07:23 <ertes> in order to make this work, you need that one to depend on the components, so that evaluating the constructor entails evaluating the components as well
13:08:10 <ertes> foldl' (\(s', n') x -> let !s = s' + x; !n = n' + 1 in (s, n)) 0  -- this one works
13:08:23 <ertes> joe9: no, use foldl' (note the apostrophe)
13:08:37 <ertes> but also make sure that your function is sufficiently strict like i just showed you
13:09:30 <solrize> should    foldl' \(!s, !n) ....   work?
13:09:42 <ertes> joe9: there is an off-by-one version that works, too, and is much nicer to read
13:09:59 <ertes> joe9: what solrize wrote
13:10:36 <athan> What's a "pun" in -XNamedFieldPuns?
13:10:52 <ertes> foldl' (\(!s, !n) x -> (s + x, n + 1)) (0, 0)  -- this leaves one evaluation open…  most likely not a big deal
13:11:23 <Gurkenglas> Can I write "do case x of A -> Just 1; B -> Just 2; _ -> Nothing" without writing Just or Nothing or _, perhaps by using how fail is implemented for Maybe?
13:11:28 <Xe> athan: basically it lets you have multiple records share the same accessors
13:11:41 <glguy> No, that one's different
13:12:35 <glguy> Named field puns like you write record syntax omitting the = part of a field
13:12:39 <glguy> Constructor { field }
13:12:45 <glguy> to mean: Constructor { field = field }
13:14:02 <athan> glguy: I got that far, just wondering what the heck a pun actually is
13:14:09 <glguy> same word multiple meanings
13:14:11 * athan is in target position
13:14:17 <athan> oh huh
13:14:36 <athan> thanks glguy 
13:18:11 <geekosaur> Gurkenglas, yes, for Maybe return = Just and fail _ = Nothing
13:18:33 <geekosaur> but using fail is kinda icky
13:18:33 <joe9> ertes: tried using the patterns http://dpaste.com/2729C48 still no response. line 140, 141 added !
13:18:49 <Gurkenglas> geekosaur, what would the variation of my do block look like that doesnt say Just, Nothing or _?
13:20:06 <glguy> Gurkenglas: No, you can't hijack do-notation pattern failure to do that
13:20:14 <joe9> ertes: is it recommended to use foldl or foldl' with only one summing variable?
13:20:52 <geekosaur> you can't hijack pattern failure but you can use the components of it as they work for Maybe. the question is why?
13:21:03 <ertes> joe9: in general always use foldl'
13:21:15 <geekosaur> there aren't many good reasons to do it
13:21:26 <ertes> joe9: i think of foldl as a historical accident
13:21:29 <Twey> Is ‘machines’ still the latest and greatest when it comes to stream transducers?
13:21:48 <joe9> ertes, ok, let me switch to foldl' everywhere and thry.
13:22:09 <ertes> joe9: and again: have you tried with smaller parameters?  first make sure your program terminates in the first place by trying small and trivial parameters
13:22:35 <joe9> ertes: did you mean foldl1 is better than foldl?
13:22:40 <ertes> joe9: "my program is slow" and "my program never stops running" are two vastly different kinds of bugs
13:22:50 <joe9> ertes, ok, will try that.
13:23:01 <ertes> joe9: foldl1 is a completely different function
13:23:05 <ertes> i mean foldl'
13:24:09 <ertes> (foldl1 is again one of those historical accidents in my opinion…  they should have added a non-empty list type, but instead they wrote foldl1)
13:25:24 <ertes> (do you write "non-empty" or "nonempty" in english?)
13:26:37 <glguy> afaik both are OK and nonempty is standard, but ianal
13:27:05 <Twey> ertes: In my experience mathematicians often write ‘nonempty’, while laymen would usually prefer ‘non-empty’
13:29:53 <joe9> with stack repl, is there a way to expose all functions of the module? or, atleast load a module instead of the executable?
13:30:55 <kadoban> joe9: You can specify what context you're in somehow. I think by default it just asks you (and I think that message also tells you the syntax to choose?)
13:31:19 <kadoban> This is assuming you have a library defined in your .cabal file and such.
13:33:56 <ertes> (thanks…  if anyone cares: i've done some research, and some sources suggest that in BrE the hyphen is conventional, while in AmE no hyphen is)
13:36:07 <athan> joe9: You can always use :browse too
13:37:35 <black0range> Whats the status on dependant types in haskell? :)
13:38:02 <monochrom> almost getting there, but not going to be natural
13:38:44 <monochrom> i.e., even after getting there, it will be more like obfuscated encoding than direct expression.
13:39:33 <jackhill> black0range: in addition to monochrom's analysis https://typesandkinds.wordpress.com/2016/07/24/dependent-types-in-haskell-progress-report/
13:40:06 <jackhill> more of a nuts and bolts report
13:40:29 <black0range> Thanks :)... I want them so badly :D 
13:44:14 <earthy> now to get that stuff to percolate all the way down to java and C# :P
13:46:12 <black0range> Don't worry, java and C# won't exist by then and everything is written in Python / Javascript
13:46:15 <joe9> ertes: your suspicion is correct, it did not complete even for 10
13:46:32 <ertes> earthy: yeah, try proposing proper polymorphism for those languages first
13:47:21 <MarLinn> earthy, give them 30-40 years. Or have one of the languages use it that threatens the backing companies' monopolies
13:49:32 <ertes> i can imagine their response to a issue titled "C# needs a proper kind system": "oh, one of those haskell hipsters again!"…  ten years later, after they finally understood why it's a good idea: C# gets a kind system
13:50:18 <ertes> by then we probably already have -XDependentTypes
13:53:23 <solrize> ertes -- they should have added a non-empty list type, but instead they wrote foldl1) --- or they should have written a fold that uses a monoid instance to start up
13:54:36 <codedmart> I am back trying to figure out my stack temp files. I am running my development inside of a docker container and I mount/bind my dir to the docker container. Everytime I compile from a change I get new temp files in my project directory. Any ideas how I can avoid that of change where the temp files are.
13:55:19 <ertes> solrize: the point of foldl1 is that it has no common initialiser, so if anything you'd need fold1 with a Semigroup
13:56:08 <MarLinn> ertes, solrize, now that I think about it, neither fold nor foldMap from Foldable have strict versions. Interesting choice.
13:56:15 <solrize> yeah you're right
13:56:29 <solrize> foldl1 with a monoid is called msum
13:57:34 <glguy> mconcat*
13:58:31 <solrize> oh right sorry
13:58:43 <ertes> you're mistaking foldl1 for something it's not…  it's related to foldl the same way f is related to fold, where f :: (Semigroup a) => NonEmpty a -> a
13:59:15 <ertes> i'd call 'f' fold1
13:59:47 <solrize> well typically the function you're folding isn't the same thing as addition on the semigroup
13:59:57 <solrize> it's just some arbitrary a->a->a
14:00:01 <ertes> in Data.Semigroup it's called sconcat
14:00:09 <solrize> or a->b->a rather
14:00:18 <solrize> i didn't know we had data.semigroup
14:00:19 <ertes> solrize: a -> a -> a
14:00:36 <solrize> @t foldl
14:00:36 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
14:00:41 <solrize> :type foldl
14:00:44 <solrize> @type foldl
14:00:47 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
14:01:00 <ertes> :t foldl1
14:01:02 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
14:01:18 <ertes> foldl1 is partial for types that can be empty
14:01:28 <solrize> yeah for foldl1, for folds in general it's a->b->a
14:01:32 <solrize> yeah
14:01:58 <ertes> i think we're talking about different things now =)
14:02:01 <solrize> np
14:02:21 <solrize> i was just getting that semigroup/monoid aren't really relevant to folds
14:02:33 <solrize> because the folding operation is often different
14:02:45 <solrize> so foldable is a different class
14:03:45 <ertes> and my point was that historically foldl1 shouldn't have been written for []…  instead they should have added non-empty lists much earlier
14:03:55 <ertes> now we have non-empty lists, but foldl1 is still broken
14:04:15 <solrize> we have non-empty lists now?  that seems hard to typecheck in general.  
14:04:36 <ertes> see Data.List.NonEmpty
14:04:38 <ertes> it's in base now
14:04:51 <solrize> wow
14:04:53 <solrize> sec
14:05:00 <monochrom> I love foldl1. It saves me a few keystrokes.
14:05:38 <solrize> ertes wow nice, i'll have to look at that more.  thanks
14:05:49 <monochrom> On IRC I can quickly enter "foldl1 (+) [1..n]" will use Θ(n) memory, too"
14:06:06 <solrize> why don't we have sum'  ?  
14:06:07 <monochrom> with foldl I would have to enter more: foldl (+) 0 [1..n]
14:06:20 <solrize> yeah that's the way i've usually used foldl1
14:06:23 <ertes> monochrom: sum[1..n]
14:06:52 <monochrom> well yeah but whenever I write that, I am writing in the context of someone asking or claiming things about foldl
14:09:52 <nitrix> Given an ordered list [10,7,5,4,3,2,1] how do I find the pivot point where each side (left and right) are as balanced as possible?
14:09:53 <joe9> ertes: the function works fine from ghci though.
14:10:40 <ertes> joe9: does :main from GHCi work?
14:10:51 <ertes> joe9: (in the Main module)
14:11:08 <MarLinn> nitrix: feed the list into a self-balancing binary tree, then look at the root?
14:11:34 <ertes> nitrix: in value sum or in number of elements?
14:11:58 <nitrix> ertes: number of elements.
14:12:21 <ertes> nitrix: is the number of elements known?
14:12:27 <nitrix> ertes: Yes.
14:12:29 <joe9> ertes: ok, will try. I am trying the function piecemeal from the gh
14:12:34 <ertes> nitrix: divide that number by 2
14:14:00 <MarLinn> ertes: booring ;)
14:14:05 <ertes> nitrix: if you actually need two lists, note that the actual splitting may be anywhere between O(1) and O(n) depending on what you want to do and how you split
14:14:31 <nitrix> I guess I exposed the problem wrong.
14:14:41 <ertes> probably =)
14:14:43 <nitrix> It's not even Haskell related so I'll proceed on my own :)
14:15:34 <joe9> ertes: yes, the :main from ghci does not work either. when I run just that function with all 3500 messages, it works fine.
14:16:04 <jle`> didn't realize NonEmpty was in base now
14:16:05 <ertes> @let binarySplit (x1:x2:xs) = let (ys1, ys2) = binarySplit xs in (x1:ys1, x2:ys2); binarySplit xs = (xs, [])
14:16:07 <lambdabot>  Defined.
14:16:24 <ertes> > binarySplit [10,7,5,4,3,2,1]
14:16:26 <lambdabot>  ([10,5,3,1],[7,4,2])
14:16:32 <jle`> will never use groupBy from Data.List again
14:16:42 <joe9> ertes: should I just get rid of the foldl' and use a recursive function? Would that help?
14:17:01 <ertes> joe9: no, if it fits the foldl' pattern, you should use foldl'
14:17:27 <ertes> joe9: foldl' is not your problem…  replacing it by recursion will not make your problem go away
14:17:57 <ertes> joe9: you need to check your code piece by piece now and narrow down *where* it diverges
14:18:23 <joe9> ertes, ok, Thanks.
14:18:23 <ertes> joe9: test every function individually
14:20:55 <nitrix> ertes: I should phrase as "How do I split a list such that each sides sum are as balanced as possible?"
14:21:20 <nitrix> Is this a recursive problem or one that can eb solved arithmetically?
14:22:00 <ertes> nitrix: i'm not entirely sure, but it may be a variant of the subset sum problem
14:23:08 <MarLinn> nitrix: You said the list is sorted. Is every number between min and max included?
14:23:09 <ertes> nitrix: my first impulse would be to split the list in half, then repeatedly move elements between the lists
14:23:29 <ertes> nitrix: in fact i would split it with the binarySplit function i wrote above =)
14:23:37 <ertes> > binarySplit [1..10]
14:23:40 <lambdabot>  ([1,3,5,7,9],[2,4,6,8,10])
14:23:59 <nitrix> MarLinn: The list is sorted descending. I'm not worried in performance, I just want the actual number to put in a report :P
14:24:45 <ali_> Hey guys I'm very new to Haskell code someone give me some input on some code (12 lines only! wont take too long!) https://gist.github.com/wolfmankurd/e329a81d2de079cd94f4f069ff558dcd it takes some letters and finds some perfect anigrams.
14:24:54 <jonored> nitrix: Well... presumedly you want a number within a lifetime, which suggests that you probably want an approximate answer.
14:25:03 <nitrix> ertes: What I wonder is, do I have to try all elements as pivot points, or as soon as the left and right give bigger differences than my "best case", I can stop there?
14:25:33 <ertes> nitrix: you can't stop there, because an earlier choice may influence your later options
14:25:48 <athan> Does an ixset perform better with data that's been UNPACKED across it's index fields, or one which leaves the pointers intact?
14:25:58 <nitrix> Oh, sorry I might have forgetten something.
14:26:09 <ertes> nitrix: binarySplit will give you a good first approximation…  one easy way to close in on the global optimum is to use something like simulated annealing
14:26:13 <nitrix> The ordering must be preserved. It's just cutting the list.
14:26:31 <nitrix> There's no re-organising elements, I just want to know where to cut it optimally to get two balanced segments.
14:26:31 <jonored> Oh, yeah, that's a totally different, and much easier, problem than it sounded like you wanted.
14:26:42 <ertes> nitrix: oh
14:26:47 <ertes> nitrix: in that case just use binary search
14:26:49 <jonored> Or rather,  a ++ b == original
14:26:51 <black0range> ali_: You probably want to separate IO from pure functions as much as possible :)
14:27:06 <Welkin> IO is technically pure though
14:27:13 <nitrix> jonored: correct
14:27:17 <black0range> (You know what i mean)
14:27:20 <Welkin> lol
14:27:28 <black0range> :P
14:28:24 <ali_> black0range: thanks, I'll try, I've seen that said a few times, as in each individual function should be either pure and the IO stuff should be concentrated in main say?
14:28:29 <jonored> it's just that difference between exponential and logarithmic, no big deal...
14:29:11 <ertes> nitrix: start at 1/2, figure out whether 1/4 or 3/4 is better, etc.
14:29:34 <Welkin> ali_: pretty much the only function that should be IO is main
14:29:52 <Welkin> if possible
14:29:57 <ertes> nitrix: implementationwise a tree structure (a binary tree or finger tree) will help you to keep track of sublist sums in logarithmic time
14:30:25 <MarLinn> ali_: I think wordFile has a slightly misleading name
14:30:40 <ali_> Welkin: so ideally I'd have the main function, a function which searches a [[Char]] and returns a [[Char]] and a function which takes a [[Char]] and returns a [(Char, Char)]?
14:31:21 <Welkin> ali_: I'm not sure what your program looks like, but that sounds like it works
14:31:25 <ali_> MarLinn: I usually point it at /usr/share/dict/american-english so just a \n seperated list of words
14:31:29 <Welkin> construct a pipeline of simple functions and ocmpose them together
14:31:45 <Welkin> compose*
14:32:20 <ertes> nitrix: https://en.wikipedia.org/wiki/Rope_(data_structure)
14:33:00 <ertes> nitrix: instead of string lengths you would use the item values with (+)
14:33:01 <nitrix> ertes: Oh you're right!
14:33:03 <nitrix> It IS a rope.
14:33:07 <ali_> Thanks guys I'll get crackin'!
14:33:12 <MarLinn> ali_ I mean that wordFile contains all the arguments, but the name implies that it contains only one. Not a big issue, just a nitpick
14:33:29 <ertes> nitrix: if you do this in haskell, the fingertree package comes with pretty much everything you need
14:34:19 <lyxia> nitrix: http://lpaste.net/180593
14:36:02 <ali_> MarLinn: Ah I see good point.
14:40:48 <monochrom> I use: words <$> readFile "/usr/share/dict/words"
14:43:00 <ali_> monochrom: I'm still learning I'm somewhat limited with the language features I know
14:43:11 <ali_> It seems there is alot more to Haskell than I know so far!
14:44:07 <black0range> ali_: You have a wonderfull journey ahead of you :)
14:47:01 <nitrix> ertes: lyxia. 25. Solved it :)
14:47:05 <nitrix> Thanks :)
14:48:15 <nitrix> 50407 on one side, 49593 on the other. The shortest difference of them all, by 814 :P
14:48:37 <nitrix> Damn, Haskell is awesome sometimes for recursive problems ;-;
14:51:01 <joe9> Findin the last element of a sequence: index (pred (length <sequence>)) <sequence>
14:51:01 <ertes> nitrix: with FingerTree the solution looks like this: split (< measure xs / 2) xs
14:51:07 <joe9> is there a better way than that?
14:51:41 <ertes> nitrix: and it's O(log n) overall, while lyxia's solution is at best O(n) =)
14:52:09 <lyxia> you still need O(n) time to build the structure anyway :P
14:52:44 <kadoban> joe9: What's pred? What's a sequence? I have a feeling I'm missing something.
14:53:02 <joe9> kadoban: Data.Sequence finding the last element in it.
14:53:21 <ertes> lyxia: that overhead is extra in both cases
14:54:10 <kadoban> joe9: You can use 'viewr' on the sequence, and then pattern match on (:>), if nothing else.
14:55:08 <MarLinn> joe9: works best with -XViewPatterns
15:04:12 <jle`> hi all
15:04:37 <Welkin> jle`: hola, como estas
15:04:57 <jle`> not bad how are you
15:05:12 <jle`> i was going to ask a question but typing it out, i realized i have to rethink it
15:05:18 <jle`> do go on with your days
15:06:21 <jle`> actually i'll ask it even though i think it's not possible
15:06:48 <jle`> i have a type data Length :: [k] -> * where LZ :: Length '[]; LS :: Length as -> Length (a ': as)
15:07:02 <jle`> was wondering if there was any way to access the 'a' and 'as' when pattern matching on LS s
15:07:07 <jle`> *LS l
15:07:09 <jle`> but i don't think there is
15:11:37 <jle`> alas
15:11:57 <MarLinn> I'm still new to much of this type level stuff, but maybe something like foo :: (LS x ~ Length (a ': as)) => ...  ?
15:13:15 <jle`> hm, i don't think that is a valid thing, LS is at the value level here
15:13:26 <mniip> jle`, depends on what you want to do with a/as
15:13:43 <jle`> mniip: i want to make a `Proxy :: a`
15:13:47 <jle`> er, Proxy :: Proxy a
15:14:12 <mniip> (LS x _) -> mkProxy x
15:14:19 <jle`> LS has only one argument
15:14:20 <mniip> where mkProxy :: p a -> Proxy a; mkProxy _ = Proxy
15:14:28 <mniip> ah
15:14:31 <jle`> there is no witness inside it
15:14:44 <mniip> yes there is
15:14:53 <jle`> i suppose i could mkProxy :: Length (a ': as) -> Proxy a
15:15:03 <mniip> l@(LS _) -> mkProxy x
15:15:06 <mniip> er
15:15:11 <mniip> yeah basically what you wrote yes
15:15:22 <mniip> LS contains a witness for an equality
15:15:45 <mniip> LS :: (aw ~ a ': as) => Length as -> Length aw
15:16:39 <jle`> oh hey it works :O
15:17:05 <black0range> Where can i read up on that type level stuff?
15:18:18 <jle`> i guess you could say it's like data Length as = LZ ('[] :~: as) | LS ((b ': bs) :~: as) (Length bs)
15:18:28 <jle`>  ... is that accurate?
15:18:28 <nitrix> Given an arbitrary graph, is there a way to know if you'
15:18:39 <nitrix> you're segmenting the graph by removing an element?
15:18:53 <xelxebar> Do we have a lot of *nix people in here?
15:21:06 <jle`> oh there needs to be quantifiers over b and bs
15:21:13 <monochrom> nitrix: look for "cut edge" and "articulation point"
15:21:23 <Welkin> bs!
15:21:50 <Welkin> nitrix: disjoin sets?
15:21:56 <Welkin> disjoint*
15:22:13 <joe9> What is the function to filter out all non-ascii characters from a Text ? isAlphaNum?
15:22:44 <Welkin> > filter isAlphaNum "你好吗hello24"
15:22:46 <lambdabot>  "\20320\22909\21527hello24"
15:22:52 <Welkin> nope
15:22:55 <glguy> Non-ascii? not . isAscii
15:23:23 <xelxebar> An obvious thing dawned on me. Standard posix/gnu tools are geared toward using line-based files (including stdin/stdout), and along with `cat` and unix pipes, we basically have a monad over lists and a suite of associated tools.
15:23:33 <kadoban> joe9: You could just use an encoder at the end that does that, there's ones with different rules for what to do with non-ascii, if you're encoding to ascii.
15:24:01 * hackagebot rawr 0.0.0.1 - Anonymous extensible records  https://hackage.haskell.org/package/rawr-0.0.0.1 (pkmx)
15:24:50 <xelxebar> But, when working with tree data and stuff (e.g. json, xml, etc), unix tools are infamously unsuited to simple processing tasks
15:24:56 <Welkin> > filter isAscii "你好吗hello24"
15:24:58 <lambdabot>  "hello24"
15:25:14 <joe9> kadoban: I am trying to do this : https://rosettacode.org/wiki/Strip_control_codes_and_extended_characters_from_a_string#Haskell , but, for a text
15:25:28 <MarLinn> xelxebar, maybe *nixe should switch to conduits ;)
15:25:29 <joe9> I do not want to convert the Text to a String and then check each chaaracter.
15:25:45 <Welkin> > Data.Text.filter isAscii ("你好吗hello24" :: Text)
15:25:45 <joe9> just thought that there might be a way to do that directly on the Text itself.
15:25:48 <lambdabot>  error:
15:25:48 <lambdabot>      Not in scope: ‘Data.Text.filter’
15:25:48 <lambdabot>      Perhaps you meant one of these:
15:26:05 <joe9> Welkin: isAscii takes the first 128 characters.
15:26:20 <glguy> That's what ASCII is
15:26:21 <joe9> I think there are some control characters in that
15:26:32 <glguy> you'll have to do two tests to remove ASCII's control codes
15:26:44 <joe9> strip = filter (\x -> ord x > 32 && ord x < 126) -- this for Text
15:26:53 <joe9> glguy: isAscii and isControl?
15:26:58 <xelxebar> MarLinn: Exactly! My idea would be to generalize pipes and such to general monadic operations. Tools like `file` already sort of let us determine the "type" of a file, so it's perhaps reasonable.
15:27:12 <joe9> or isAscii and isAlphaNum
15:27:25 <xelxebar> But this is such an obvious idea, I have a hard time believing someone hasn't thought of this before...
15:27:47 <xelxebar> Would appreciate if someone could point me in the right direction to see whas has been done before
15:28:09 <xelxebar> My simple searches of "monad shell" and the like don't turn up a lot
15:28:11 <joe9>  > Data.Text.filter( isAlphaNum ( Data.Text.filter isAscii ("你好吗hello24" :: Text)))
15:28:34 <glguy> joe9: isAlphaNum would strip more than control characters. You can play with this in GHCi finding the perfect filter
15:28:39 <xelxebar> Though it seems like one guy made a similar observation in 2001: http://okmij.org/ftp/Computation/monadic-shell.html
15:28:43 <glguy> You can browse the haddocks for Data.Char to find all the predicates
15:28:56 <MarLinn> xelxebar: All projects that I've seen that tried to implement a "functional OS" have stalled after the first couple steps.
15:28:58 <monochrom> nitrix: Actually I might have answered the reversed question. If you already have a given vertex and are asking "if I remove this vertex, does this split the graph?", then it's simpler: Before removing, do a BFS to check that the graph is one piece (all vertices reached), unless you already know "yes"; after removing, do a BFS to find out whether the graph is in one piece (all vertices reachable).
15:29:30 <nitrix> monochrom: I know before hand that it's already one big piece.
15:29:35 <MarLinn> xelxebar but I think I had found something about functional shells... let me check...
15:30:00 <nitrix> monochrom: Is there a way to mark bridges and such during insertions, to avoid this cost at every deletions?
15:30:30 <MarLinn> xelxebar In the meantime, here's something to ponder: Why use files at all? Information is a graph, right?
15:30:42 <nitrix> monochrom: Something that'd inflate the complexity by O(1) to later save a full traversal?
15:30:48 <xelxebar> MarLinn: Well, my idea isn't as glorious as a functional os. I'd just like to work with trees and other monadic data as easily as I can with the standard unix tools on flat text data
15:30:51 <nitrix> monochrom: I'm still googling mind you.
15:31:13 <Welkin> xelxebar: templeos?
15:31:14 <Welkin> lol
15:31:36 <monochrom> I don't know.
15:31:38 <xelxebar> templeos. lol. how about ponyos?
15:33:33 <monochrom> In that case, look for "online algorithms that updates your knowledge of bi-connected components, bridges, and articulation points, as you add vertices and edges"
15:33:44 <geekosaur> there's a number of reasons for files, many of them practical (for example, hard to pick up a graph and give it to someone else without serializing it first, and people don't generally want to have to specifically export their data every time they want to do that)
15:33:51 <ali_> Hey guys, just to check I'm moving in the right direction https://gist.github.com/wolfmankurd/e329a81d2de079cd94f4f069ff558dcd I've tried to seperate the functions out a bit. Is this what you mean by seperate pure and IO functions?
15:34:14 <nitrix> monochrom: Doing exactly that. Thanks for the earlier keywords :)
15:34:19 <xelxebar> MarLinn: graph? I'm not sure. Maybe if you allow muliply-connected, directed graphs? But then that's essentially a category
15:34:20 <geekosaur> there's a whole host of tradeoffs that have to be made along the way --- and those tradeoffs are often quite different for different kinds of data, or for different *uses* of that data
15:34:24 <MarLinn> xelxebar: https://wiki.haskell.org/Applications_and_libraries/Operating_system has some links to shell-related projects. Most of them are probably dead, but maybe one could revive the code
15:34:58 <black0range> a,
15:35:35 <black0range> ali_: It is in the right direction :)
15:35:47 <ali_> black0range: Thanks :D
15:36:15 <geekosaur> not to mention that you may not even know what kind of graph(s) are represented by raw data such as observations
15:36:26 <black0range> ali_: by the way there is a "lines" function that takes a string and separates it into a list of lines
15:36:36 <monochrom> You can always redefine the word "file" to mean whatever way your OS stores stuff on disk.
15:36:47 <Rembane> Or a socket.
15:36:47 <monochrom> Then logically it is always "files".
15:37:00 <MarLinn> geekosaur, sure. And our systems have been optimized for file-like things with paging and whatnot. Unless you use a database-filesystem, maybe
15:37:39 <geekosaur> I'm not even talking on that level, really, except at the point where I talked about serializing to give the data to someone else
15:38:03 <xelxebar> MarLinn: https://github.com/cpennington/h4sh this looks interesting... last commit 6 years ago though
15:39:13 <MarLinn> geekosaur, it's the relation between the OS abstraction and the user interface metaphor must not necessarily be as close as it is
15:39:25 <geekosaur> I'm talking about a more fundamental issue: if you have a bunch of data representing scientific observations, or financial transactions, or weather reports, or ..., your first problem is figuring out how to convert them into relationships so you can construct a data structure other than a flat table or a text file
15:40:02 <MarLinn> But once I have a relation both I and the computer can profit from that
15:40:22 <geekosaur> "once I have a relation" is exactly the problem
15:40:53 <geekosaur> often you don't, and your task is to *determine* the relation. or relations. or combine it with other data and try to find new relations.
15:41:20 <hiptobecubic> are you trying to "data science" each other?
15:41:57 <MarLinn> Then that means I have a bunch of "stuff" floating in space, not "files".
15:42:01 <monochrom> No. One is data sciencing the other, and the other is operating systeming on the one.
15:43:20 <monochrom> "stuff" = "files". Plus, the disk platters are floating in space, too.
15:43:36 <monochrom> Unless you believe in SSD
15:43:54 <monochrom> But then in SSD the electrons float in space. All is well.
15:43:57 <MarLinn> Nope. "Containment in a file" is only one of the known input-relations, nothing more. Why limit myself to that?
15:44:24 <monochrom> That is not even an input relation.
15:44:38 <MarLinn> So files are useless after all?
15:44:41 <geekosaur> (also note that I'm a sysadmin. I know the OS side of it quite well, thank you; much of the time, my job is helping people twist the OS into doing what they need, or at least not actively obstructing what they need to do)
15:44:56 <monochrom> Files are a useful stepping stone.
15:44:58 <ali_> black0range: awesome, I'm running low on descriptive terms so it's handy to find some built-ins
15:45:31 <monochrom> And the word "files" is useful as a more encouraging word than "stuff", even though they are the same thing.
15:46:03 <monochrom> Just like how "managed memory" is a better wording than "garbage collection" but there is no difference apart from propaganda.
15:47:27 <monochrom> Like I said, whatever you will do to your OS, I will call them "files". The word is so undefined that it will fit perfectly.
15:47:57 <tzaeru> uh, ok
15:48:01 <MarLinn> One of the drawbacks of the "file" name is what other stuff is related to that metaphor. If I see an E-Mail as a "file" as in "a piece of paper I can file", then in makes more sense to print it out.
15:48:02 <tzaeru> you fellas are some real hipsters
15:48:42 <monochrom> Yes. I print out my new emails on my LCD screen every day.
15:48:48 <tzaeru> ...
15:48:52 <tzaeru> jesus christ
15:49:06 <ali_> monochrom: buy a thermal printer print all emails = instant hipster king
15:49:44 <monochrom> I have a thermal printer actually. It is for use with the Casio FX-702P calculator a long long time ago.
15:50:04 <monochrom> I was hipster king before hipster was cool.
15:50:07 <ali_> monochrom: you had a thermal printer *before* they were cool you say?
15:50:10 <ali_> haha
15:51:01 <monochrom> In fact, a bit later, my father also bought me the Sharp PC-1500 calculator (more powerful) and its companion four-colour plotter. Yes, plotter, bloody vector graphics.
15:51:13 <MarLinn> Ok... you keep using files, I'll go write an OS that stretches the metaphor so far that it snaps. After I reinvent the world of programming, and save humanity that is... XD
15:52:25 <geekosaur> metaphors are usually more flexible than reality
15:52:44 <geekosaur> language stretches to fill the need
15:52:52 <monochrom> "dashboard" is the most butchered metaphor I have ever seen.
15:53:09 <monochrom> Because it got butchered twice, not just once.
15:53:40 <monochrom> At this rate there is no butchering you can't do to natural language.
15:54:02 * hackagebot posix-error-codes 0.1.0.0 - POSIX error codes  https://hackage.haskell.org/package/posix-error-codes-0.1.0.0 (yghor)
15:54:04 * hackagebot preliminaries 0.1.5.0 - A larger alternative to the Prelude.  https://hackage.haskell.org/package/preliminaries-0.1.5.0 (yghor)
15:54:08 <monochrom> or rather s/butchered/metaphorized/
15:55:47 <monochrom> "dashboard" began as a board in front of your car seat to block dust. its first metaphorization was when it became just a display panel of your car.
15:56:47 <monochrom> then it got metaphorized the second time when it became a display panel of your OS GUI.
15:57:56 <MarLinn> if only it would protect us from the mud the OS throws at us
15:58:10 <athan> Is it a common pattern to want to name your uncurried patterns, like a record? Is this similar in thought to free monads maybe..?
15:58:11 <monochrom> This is like The Ship of Theseus done to metaphors.
15:58:38 <athan> sorry, not similar in thought. I just mean how some people use data constructors as a new DSL
15:58:40 <ali_> monochrom: how about the word metaphor itself
15:58:43 <monochrom> what does an uncurried pattern look like?
15:59:10 <monochrom> yes, free monad is an example of using an ADT for a DSL.
15:59:14 <athan> hm, actually nevermind
15:59:41 <ali_> metaphor comes from the greek to "carry over", metaphor is a metaphor :)
15:59:50 <monochrom> nice
16:00:00 <athan> so -XDuplicateRecordFields only really enables the ability to _create_ multiple terms with the same name, right?
16:01:06 <athan> isn't there an extension in-development that will make records act more polymorphic or something?
16:01:14 <athan> or related to ad-hoc polymorphism?
16:02:05 <Welkin> athan: I think that is already out in ghc 8
16:02:21 <geekosaur> OverloadedRecordFields is still in the future, yes. DuplicateRecordFields is a prerequisite, and made ghc8.0
16:02:23 <athan> Welkin: I don't think there's something like row polymorphism baked in haskell though
16:02:25 <Welkin> so record accessors can have the same name for different types
16:02:28 <athan> oh okay
16:02:52 <athan> so I can't say something like `forall a. { a | foo :: Int }` or something
16:03:09 <dmwit> athan: https://turingjump.com/blog/bookkeeper/
16:03:18 <Welkin> lol athan is that Elm?
16:06:01 <athan> Welkin: yeah :x
16:06:11 <athan> I mean the weird thing with elm is that there's no union
16:06:22 <athan> er, no way to "merge" objects or whatever (I'm pretty sure)
16:06:22 <ali_> I feel like moving the code out to seperate functions looks and feels messier, did I do it wrong? https://gist.github.com/wolfmankurd/e329a81d2de079cd94f4f069ff558dcd
16:06:55 <athan> you always have to recreate the terms `foo x = { foo = x.bar, bar = x.baz }`
16:07:10 <dolio> Union is one of the things that starts making type checking really difficult in practice.
16:09:19 <athan> dmwit: That's really cool haha
16:09:54 <athan> dolio: Hmm, I think that makes sense
16:10:29 <athan> that's really interesting though, thank you
16:11:04 <jle`> anyone have a full proof of reverse (xs ++ ys) = reverse xs ++ reverse ys or reverse (reverse xs) in idris/coq/agda i could look at ?
16:11:54 <dolio> No one has a proof of your first equation. :)
16:11:58 <alercah> ^
16:12:00 <shachaf> There is no proof of -- yes.
16:12:00 <dolio> Except in falso.
16:12:12 <alercah> Falso?
16:12:17 <shachaf> It's also true for reverse :: [()] -> [()]
16:14:06 <jle`> dolio: heh, i meant reverse (xs ++ ys) = reverse ys ++ reverse xs :)
16:14:41 <jle`> this post claims to walk through the proof but actually omits it https://www.stackbuilders.com/news/reverse-reverse-theorem-proving-with-idris
16:14:54 <jle`> literally the most deceptive thing
16:15:12 <jle`> it just shows the syntax of it, more or less v.v
16:15:46 <Welkin> U.U <-- jle` late at night
16:15:57 <jle`> |_| . |_|
16:16:50 <jle`> well the post basically uses unsafeCoerce in the middle of the proof
16:16:57 <jle`> which is sort of the opposite of what you'd want in a proof
16:17:13 <athan> how do you solve the problem of having a large number of parameters to a function?
16:17:34 <jle`> one-off records?
16:17:35 <MarLinn> ali_: no, I wouldn't call it wrong. On the one hand you may have spread the content too thin. That makes it harder how stuff relates. On the other hand you could theoretically prune main even more.
16:17:38 <athan> You could make a record with intuitively named fields, and use the record for the in-between
16:17:54 <jle`> one-off records are nice too because they're a convenient way to provide default values
16:17:55 <athan> jle`: But can you evade the cost?
16:17:59 <jle`> what is the cost?
16:18:07 <jle`> s/default values/default arguments
16:18:09 <MarLinn> ali_: E.g. I like to factor out a "queryUser :: String -> IO String" function just for clarity
16:18:12 <athan> The data constructor and the extra pointers
16:18:16 <pavonia> jle`: What are one-off records?
16:18:18 <athan> I mean... ah shoot idk
16:18:45 <jle`> athan: try benchmarking, i don't think it'd be very big, especially if you use strict fields
16:18:46 <athan> It's reasonable, my brain is just saying to me "but that's data now!"
16:19:01 <Welkin> athan: or benchwarming
16:19:02 <athan> idk maybe a `FooParams` convention might help
16:19:12 <jle`> pavonia: records you make just for one purpose, like using as arguments for a function
16:19:24 <athan> good point. Thanks jle`
16:19:26 <jle`> pavonia: instead of foo :: Int -> Int -> Bool -> Int -> String -> String -> a
16:19:58 <jle`> you can use data FooParams = Foo { count :: Int, size :: Int, isFast :: Bool, number :: Int, name :: String, cousin :: String }, and have foo :: FooParams -> a
16:20:10 <jle`> some people say this is a nice way to provide default arguments, too
16:20:14 <ali_> MarLinn: what would queryUser do? Just get the user input?
16:20:16 <athan> I just have a feeling a macro could do it here or something, like syntactic sugar
16:20:30 <jle`> because you could have defaultParams, and call foo using foo defaultParams{ isFast = False }
16:20:34 <athan> but that's probably like diving into a snake pit
16:20:48 <jle`> or some people leverage Data.Default there, and you can overload it as foo def{ isFast = False }
16:21:00 <Welkin> jle`: it's a common way to apply functions in lua too, just push all the parameters in a table
16:21:27 <jle`> basically superUncurry
16:21:37 <athan> yeah these are all really good points
16:22:11 <athan> I think it would be cool to partially apply records too at least
16:22:17 <athan> to do just that - curry their application
16:22:19 <MarLinn> ali_: Yes. It would print the question, flush the buffer, and get the input
16:22:26 <athan> so it's like you can care about their order, but not at the same time :)
16:22:39 <athan> actually, can you do that?
16:23:07 <jle`> it's all a bit smoother if you had anonymous records
16:23:11 <athan> Just something like `data Foo = Foo {x:Int, y:Int}` and `map (Foo{x=0}) ys`
16:23:23 <jle`> you can't do that
16:23:23 <athan> that would imply...
16:23:53 <MarLinn> ali_: But I feel the more important thing is that you had not really reduced your functions before you spread them out
16:23:57 <geekosaur> record updates are not first class. neither are field labels. this is about 90% of why lenses came to be
16:24:04 <athan> `map ((\a -> a{x=0}) Foo) ys` too, huh
16:24:17 <athan> yeah good point jle` 
16:24:24 <athan> do you know if there's any hope for that?
16:25:02 <athan> ahhh good point, thanks geekosaur 
16:25:18 <alercah> jle`: I'd do the reverse commutativity proof using some nastiness involving the tail and init of a list
16:25:43 <alercah> err not tail, last
16:25:51 <alercah> tail $ reverse xs = head xs
16:25:55 <jle`> i've been trying that
16:26:10 <jle`> but i'm not getting very far
16:26:13 <jle`> :'(
16:26:16 <alercah> ok
16:26:18 <jle`> maybe i'll just unsafeCoerce Refl
16:26:22 <jle`> nobody would judge me
16:28:02 <ali_> MarLinn: How do you mean? reduce as in each one is simple? Or reduce as in there are few of them?
16:30:52 <ali_> I'm am very impressed with Haskell I have to say, I've been programming in C for nearly a decade and something like this would take me longer in C than it took me to learn enough haskell to do it in haskell
16:31:19 <alercah> jle`: in Idris, you use believe_me for that
16:31:34 <ali_> it's about 50% slower than my binary tree in C. Which is really impressive considering how abstract this version is.
16:31:36 <MarLinn> ali_: For example you're combining maps, filters, and list comprehension. That's not wrong, but list comprehensions can be written as basically a combination of map and filter and vice versa. That means you can remove a bit of duplication
16:31:51 <alercah> jle`: you'd have to ask in #idris about whether there's a good way to make a proof involing that irritating auxiliary function though
16:32:04 <Welkin> ali_: there are many ways to speed it up
16:32:22 <Welkin> ali_: and it depends on how you are testing it
16:33:19 <ali_> Welkin: I'm sure there is. But 50% slower than probably great C for totally naive Haskell is really good.
16:33:46 <ali_> Probably great as in profiled repeatedly and worked on for weeks.
16:34:03 * hackagebot probable 0.1.2 - Easy and reasonably efficient probabilistic programming and random generation  https://hackage.haskell.org/package/probable-0.1.2 (AlpMestanogullari)
16:34:48 <MarLinn> ali_: You also have some functions that might iterate the same list several times (depending on fusion)
16:35:34 <ali_> I did try a few times to re-write findWordInList using maps and filters but each time I felt like it was exploding in complexity compared to the filter.
16:36:14 <ali_> to the comprehension*
16:39:49 <MarLinn> ali_: ok, I guess I was talking about your earlier approach. That comprehension is fine. 
16:40:27 <MarLinn> ali_: Although you could write it as [word | (k, word) <- list, k == key]
16:40:42 <ali_> Ah that is much nicer thanks
16:42:03 <MarLinn> ali_: Although now that I look at it a bit closer, I'm reminded of the predefined "lookup"
16:43:17 <MarLinn> well... not exactly...
16:45:22 <chpatrick> #hi
16:45:33 <chpatrick> I'm having some trouble with opencl in transparent mode
16:45:53 <chpatrick> clinfo and sample code work fine, clGetPlatformIDs returns my NVIDIA GPU as expected
16:46:07 <chpatrick> however in ocl.cpp it returns num_devices = 0 and so opencl is diabl
16:46:10 <chpatrick> *disabled
16:46:10 <ali_> I'll check it out, my mcguyvered hashtable is probably slower than a builtin one
16:46:28 <chpatrick> I don't see why opencv behaves differently than clinfo and it's driving me nuts
16:46:31 <chpatrick> any ideas?
16:46:48 <chpatrick> oh crap meant to be in #opencv :)
16:49:06 <MarLinn> ali_: Data.HashMap
16:49:36 <Welkin> only if you need your keys to be hashable
16:49:51 <Welkin> you can just use Data.Map, which required the keys to have an ordering
16:51:16 <ali_> MarLinn: I'm just making a version now to benchmark
16:52:58 <ali_> Welkin: I guess I'll try both, strings are Ord and I assume Hashable too.
16:53:25 <ali_> I assume HashMap is slower to make the bintree and faster to look up and viceversa
16:54:54 <Welkin> ali_: generally, you can just use Map
16:56:33 <MarLinn> I'm certain there are several different trie libraries out there that could be used for the purpose. Eh. Map is a good start and you can normally just switch later.
16:58:17 <ali_> Ah wait. I want hash collisions don't I?
16:58:37 <ali_> That's where all the magic happens.
17:00:17 <MarLinn> Do you guys have any recommendations regarding extensible types? Basically what are the advantages of data types  la carte versus type level sets?
17:00:49 <chpatrick> MarLinn: for what use case?
17:01:37 <MarLinn> basically, nodes in an AST
17:02:04 <MarLinn> or rather ast-node type markers
17:02:10 <chpatrick> yes I understand
17:02:56 <chpatrick> are there going to be so many variations that it's not easier to just have a record?
17:04:07 <chpatrick> if you like lens you could use "classy lens" to overload the fields
17:04:20 <chpatrick> HasSourceLocation, HasType etc
17:05:37 <MarLinn> chpatrick: The main goal is extensibility. Let's say you have an AST representing Hask. Now someone comes along and wants to add do notation. He might need to add custom node types for an extra stage between parsing and the "normal" evaluation
17:06:13 <MarLinn> So I might not know everything in advance
17:06:54 <chpatrick> MarLinn: right but for his stage he cou
17:07:01 <Gurkenglas> MarLinn, have you considered http://hackage.haskell.org/package/bookkeeper
17:07:04 <chpatrick> ld make a NodeWithCustomStuff no?
17:07:36 <Gurkenglas> Umm this is probably the better link https://github.com/turingjump/bookkeeper#readme
17:07:50 <ReinH> then there's always vinyl
17:08:07 <ReinH> although you pay a pretty heavy cost in compile time for using hlist-y features
17:08:13 <ReinH> and it's often over-engineering
17:08:55 <chpatrick> typeCheck  :: Fix ExprNode -> Fix ExprWithType
17:09:02 <MarLinn> I have looked at Bookkeeper. I more or less did something similar manually before I heard of it. But then I heard about data types  la carte and it looked promising, too
17:09:09 <chpatrick> customStep: Fix ExprWithType -> Fix ExprWithCustomStuff
17:10:27 <MarLinn> chpatrick: that looks a bit like  la carte with the fixpoint thing
17:11:31 <chpatrick> I think simpler is better
17:11:49 <MarLinn> I guess all approaches basically come down to either fixpoints or hlist...
17:11:59 <chpatrick> any reasonably complicated type level stuff is a pain in the ass in haskell
17:12:12 <chpatrick> not to mention slow usually
17:12:51 <chpatrick> this is just: data ExprWithType a = ExprWithType (Expr a) Type
17:13:27 <MarLinn> chpatrick: but only slow to compile, not slow to run I would think, right?
17:14:42 <MarLinn> ok, that IS simple
17:14:58 <MarLinn> maybe I am really thinking too complicated
17:22:03 <chpatrick> MarLinn: well all hlist stuff is a linked list
17:29:54 <ali_> nn guys
17:32:06 <MarLinn> yeah. linked lists, recursion through fixed points, and mostly pre-order notation. I guess I know where the "informally-specified, bug-ridden, slow implementation of half of Common Lisp" is in Haskell ;)
17:37:13 <MarLinn> Anyway, thanks for the thoughts and tips!
17:53:24 <joe9> EvanR: just wanted to let you know that I had another async that I had not handled earlier and there was no exception. took me half a day to figure out why the process seemed hung.
18:17:42 <parsnip> yikes, M-x rgrep for "pass" in my config directory
18:30:44 <parsnip> oops, wrong channel
18:33:24 <ardu_> if otherwise=True then what's going on here?
18:33:29 <ardu_> > let f x = case x of {1->"One";otherwise->"Not one"} in f 3
18:33:31 <lambdabot>  "Not one"
18:33:56 <enolan> otherwise is a pattern variable there
18:34:04 <enolan> you're shadowing the one that = True
18:35:29 <ardu_> oh
18:35:29 <pavonia> > let f x = case x of {1->"One"; otherwise->show otherwise} in f 3
18:35:33 <lambdabot>  "3"
18:37:26 <jle`> ardu_: it's the same as any other variable name
18:37:47 <ardu_> ohhhhhh
18:37:48 <jle`> > let f x = case x of { 1 -> "One"; y -> show y } in f 3
18:37:51 <lambdabot>  "3"
18:37:54 <ardu_> now i get it lol
18:37:56 <ardu_> thanks! :)
18:38:01 <jle`> > let f x = case x of { 1 -> "One"; yotherwise -> show yotherwise } in f 3
18:38:03 <lambdabot>  "3"
18:38:17 <jle`> > let f x = case x of { 1 -> "One"; (+) -> show (+) } in f 3
18:38:20 <lambdabot>  "3"
18:38:46 <jle`> otherwise isn't a syntax keyword, it's just parsed as any other normal identifier :)
18:38:55 <jle`> it's not a reserved word like let, in, etc.
18:39:54 <ardu_> funny about the (+) one. useful to know. thanks!
18:40:46 <jle`> yup, (+) is just a normal identifier too, not reserved syntax!
18:42:07 <jle`> i used to try to use 'undefined' as a type when i started out with haskell
18:42:17 <jle`> to fill in things where i couldn't figure out what to put there
18:42:34 <jle`> foo :: a -> undefined -> b -> c
18:42:41 <jle`> i was really confused about why it worked
18:42:46 <jle`> then one day it clicked
18:43:54 <MarLinn> data True = Bool | False | Maybe Int | Just Char ...
18:44:37 <MarLinn> ^ works
18:44:53 <MarLinn> *shudder*
18:45:41 <jle`> data True = True True
18:46:27 <ardu_> jle`: i don't get it - why would a type with undefined work? i just tried something like f :: Int -> undefined -> Int, f x y = x+y, and it won't compile
18:46:58 <jle`> ardu_: it works in some surprising cases that make you shrug and move on haha
18:47:01 <glguy> ardu_: You understand that that's the same as f :: Int -> a -> Int , right?
18:47:08 <jle`> but it's actually interpreted as a normal type variable, like 'a'
18:47:26 <ardu_> glguy: yes i realize that word has no special meaning in haskell
18:47:29 <jle`> so f :: Int -> a -> Int; f x y = x + y wouldn't work, because y has to be an Int, but you've declared f to work for all types
18:47:44 <ardu_> ah
18:47:52 <jle`> if you have a function f :: a -> Int, then you could pass it a Bool, a Char, a String, a Float, etc.
18:48:18 <jle`> but your function requires that y is an Int ... not just anything
18:48:39 <ardu_> so like f :: Int -> undefined -> Int, f x y = 7
18:48:57 <jle`> yeah that'd be okay, f is defined in a way that doesn't require y to be anything in particular
18:49:03 <ReinH> Cale: ping
18:49:18 <jle`> the fancy vocabulary is that f is universally quantified
18:49:23 <ReinH> jle`: o/
18:49:25 <jle`>  \o
18:49:47 <jle`> um, is that right to say
18:49:53 <jle`> f is universally quantified over a
18:50:02 * jle` is missing some sleep
18:50:06 <ardu_> yes i was going to say just over one of the variables
18:55:58 <ardu_> > let isComposite n = let smaller = [2..n-1] in any (\x -> n `mod` x == 0) smaller in isComposite 7
18:56:00 <lambdabot>  False
18:56:11 <ardu_> is there a nicer way to write the \x -> n `mod` x == 0 part?
18:56:36 <glguy> That's pretty nice
18:57:42 <ardu_> not too bad i guess :)
18:58:25 <Clint> what would make it nicer for you?
18:58:58 <ardu_> nothing in particular, i just had a feeling there might be a syntax for such things that i'm missing
18:59:12 <MarLinn> you could give it a nice name...
19:00:49 <ardu_> i guess i was thinking there might be a way to make it 'point free' (is that the right name?)
19:01:35 <Clint> @pl \x -> n `mod` x == 0
19:01:35 <lambdabot> (0 ==) . (n `mod`)
19:01:39 <Clint> ardu_: ^
19:01:49 <MarLinn> so the only reason would be code golf
19:01:51 <glguy> Now instead of nicer you have it point free
19:02:08 <ardu_> haha yeah i'm definitely not sure that's nicer. cute though
19:02:30 <MarLinn> @pl \x n -> n `mod` x == 0
19:02:30 <lambdabot> flip flip 0 . ((==) .) . flip mod
19:02:59 <MarLinn> @pl \n x -> n `mod` x == 0
19:03:00 <lambdabot> flip flip 0 . ((==) .) . mod
19:03:17 <ardu_> now it's getting creepy
19:04:08 <MarLinn> "flip 0"... nice one
19:08:05 <ardu_> i cannot parse that
19:10:51 <verement> :t flip flip
19:10:53 <lambdabot> b -> (a -> b -> c) -> a -> c
19:11:11 <ardu_> oh. that helps. for some reason i thought flip flip would do nothing
19:11:17 <ardu_> let me try parsing again
19:11:29 <MarLinn> "flip 0" was a red herring :p
19:13:12 <ardu_> i still don't get it. so flip flip expects 3 arguments - 0 is its first i'm guessing - but then isn't . function composition? what is it doing there after the 0?
19:15:23 <MarLinn> so mod takes the first argument and returns a unary function
19:25:50 <MarLinn> My guess (ignoring constraints): mod is a->a->a. ((==) .) is  (a->b)->a->b->Bool. So substituting mod for (a->b), we get one value in return, so ((==).).mod is a->a->a->Bool. That's what flip flip 0 gets.
19:27:57 <ardu_> MarLinn: i don't get ((==) .)
19:29:01 <MarLinn> It's a section, so you can see it as (.) (==)
19:32:03 <ReinH> @. pl t flip flip
19:32:03 <lambdabot> Plugin `compose' failed with: user error (Unknown command: "t")
19:32:11 <ReinH> @. pl type flip flip
19:32:13 <lambdabot> (line 1, column 5):
19:32:13 <lambdabot> unexpected '>'
19:32:13 <lambdabot> expecting operator
19:32:16 <ReinH> ugh
19:32:21 <ReinH> oh wrong thing sorry
19:32:27 <MarLinn> (==) is (a->a->Bool) or (a->(a->Bool)), (.) is ((b->c)->(a'->b)->a'->c). Remove (b->c), substitute b with a, c with (a->Bool). You get ((a'->a)->a'->(a->Bool)) or ((a'->a)->a'->a->Bool)
19:32:34 <ReinH> @. djinn type flip flip
19:32:36 <lambdabot> f a b c = b c a
19:32:39 <ReinH> That is what flip flip does
19:32:53 <ReinH> it cannot do anything else except fail to terminate.
19:33:28 <ReinH> renaming things a bit: flipflip a f b = f b a
19:33:41 <ReinH> ardu_: ^
19:33:44 <ardu_> MarLinn: i'm starting to get it, so ((==) .) takes an unary function f and two values a, b and returns True if f(a)=b
19:34:07 <ardu_> ReinH: thanks - that much i figured already, now stuck on the rest of the expression
19:36:30 <Cale> ((==) .) f x y --> ((==) . f) x y --> (==) (f x) y --> f x == y
19:37:04 <ardu_> right
19:38:41 <ardu_> oh i think i've parsed it successfully at last
19:38:45 <MarLinn> Or on the type level: mod::(a->(a->a)). ((==).)::((a'->b)->a'->b->Bool); drop (a'->b), replace a' with a, b with (a->a) ~> (a->(a->a)->Bool) 
19:39:06 <ReinH> For fun, compare with ((==) <*>)
19:39:44 <ReinH> > ((==) .) reverse "radar" "radar"
19:39:47 <lambdabot>  True
19:39:57 <ReinH> > ((==) <*>) reverse "radar"
19:39:59 <lambdabot>  True
19:40:27 <ardu_> er, what's <*> ?
19:41:16 <Welkin> <*> is ap
19:41:25 <Welkin> :t ap
19:41:27 <lambdabot> Monad m => m (a -> b) -> m a -> m b
19:41:28 <Welkin> :t <*>
19:41:30 <lambdabot> error: parse error on input ‘<*>’
19:41:33 <Welkin> :t (<*>)
19:41:34 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:41:38 <MarLinn> <*> is fmap
19:41:48 <Welkin> MarLinn: <$> is fmap
19:42:01 <MarLinn> oh. Yeah
19:42:05 <MarLinn> Sorry
19:42:55 <ardu_> oh monads. i haven't got to that yet so i'm going to ignore that for now
19:43:31 <Welkin> ardu_: not monad, applicative functors
19:43:34 <Welkin> and fmap is just functors
19:44:26 <ardu_> i'm still having trouble with flip flip 0 . ((==) .) . mod
19:44:31 <ardu_> say i define ff = flip flip 0
19:44:42 <ardu_> so :t ff is (a->b->c) -> a -> c
19:45:14 * slack1256 now has trouble with flip flip
19:47:19 <ardu_> oh i get it now
19:47:33 <ardu_> gg = ff . ((==) .) . mod
19:48:45 <Welkin> but that is ugly and hard to read
19:48:59 <Welkin> @unpl ff . ((==) .) . mod
19:48:59 <lambdabot> (\ x -> ff (\ x0 -> (==) (mod x x0)))
19:49:02 <athan> > (+) 1 2 -- ardu_
19:49:04 <lambdabot>  3
19:49:17 <athan> > (+) <$> [1,2,3] <*> [4,5,6] -- ardu_
19:49:19 <lambdabot>  [5,6,7,6,7,8,7,8,9]
19:50:43 <ardu_> is there a way to do @pl / @unpl in ghci?
19:51:44 <glguy> ardu_: The easiest way is going to be to use /msg lambdabot
19:51:50 <glguy> It's not built into GHCi
19:51:54 <slack1256> > fmap (+1) (*3) $ 8
19:51:56 <lambdabot>  25
19:52:24 <ardu_> glguy: i see, thanks
19:52:58 <geekosaur> think it's available as a command line utility though
19:53:06 <geekosaur> @hackage pointfree
19:53:06 <lambdabot> http://hackage.haskell.org/package/pointfree
19:53:33 <ardu_> nice
19:53:34 <geekosaur> the readme says how to hook it into ghci
19:53:47 <ardu_> is it guaranteed to always work? like can anything be made pointfree?
19:54:54 <geekosaur> some things can't be point free, notably case and let (and if, but it cheats and outputs a reference to a function if'; this possibly should be updated to use bool)
19:55:24 <ardu_> oh
19:56:09 <MarLinn> And it can have problems with precedence, but that's just a practical issue
19:56:19 <slack1256> not that pointfree is always the better option
19:56:34 <ardu_> ok thanks a lot guys for all your help! lots of food for thought as usual.. going to dream of operators - i'm haveing dreams with haskell in them for a few days now :)
19:56:41 <slack1256> it is nice to be clever, but is it better being able to read your code in 2 weeks also
19:56:42 <geekosaur> yeh. usually when it outputs multiple flip-s, I give up on pointfree :)
19:57:30 <shachaf> Even a single flip is too much.
19:57:40 <geekosaur> oh, sometimes it will tell you it gave up on optimization and output something horrid
19:57:54 <drostie> a single flip sometimes looks OK with backticks. ^_^
19:58:35 <MarLinn> I practically never go pointfree beyond the first variable unless I can just remove all variables without changing anything in the structure
19:58:57 <Welkin> pointfree is like freeballing
19:59:24 <drostie> but yeah when you start trying to mess with foldr to what it should "morally" be, \a b c -> foldr c b a, then you get some nasty mess of flips and dots...
20:00:49 <slack1256> sometimes is standard practice. Like with (flip runState 0 $ do (...))
20:01:35 <drostie> there we go, one of the ways is flip (flip . flip foldr). ay yai yai.
20:02:15 <Welkin> :t flip id
20:02:16 <lambdabot> b -> (b -> c) -> c
20:02:19 <Welkin> lol
20:02:40 <slack1256> wat
20:02:41 <Welkin> :t (&)
20:02:42 <lambdabot> a -> (a -> b) -> b
20:02:45 <slack1256> oh
20:03:07 <MarLinn> @pl \f -> flip (flip . flip f)
20:03:07 <lambdabot> flip . (flip .) . flip
20:03:31 <MarLinn> there you go, drostie. I just created "juggle" for you.
20:03:32 <Welkin> ludum dare has begun
20:03:36 <Welkin> who is participating?
20:04:27 <geekosaur> @pl (\a b c d e f g h i j k l m n o p q r s t u v w x y z -> s u c h g o l f)
20:04:30 <drostie> fair enough, flip . (flip .) flip $ foldr definitely works. :D
20:04:33 <geekosaur> (I blame Cale)
20:04:43 <geekosaur> sadly my logs back then didn't include years :/
20:04:53 <lambdabot> const (const (const . const . ((((const . const . const . ((const . const . ((const . const . const . ((const . ((const . const . const . const . const) .)) .)) .)) .)) .) .) .) . flip . ((flip . ((
20:04:54 <lambdabot> flip . ((flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .) . flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .) . flip . (flip .) . flip flip))
20:05:26 <drostie> Very surprised that there's not a 10 sec comp time limit for lambdabot, seems like a denial of service possibility...
20:05:39 <geekosaur> this is the point where you reconsider if you really wanted to be programming >.>
20:05:40 <MarLinn> that's the well known "hackysack" function, right?
20:06:29 <geekosaur> I think it's actually like 3 seconds, but that does not include the overhead for mueval and ghc8 (which may not be playing well with the vps)
20:06:34 <drostie> Oh! I forgot why I signed on. Has anyone ever seen a sort of "MaybeMonadT"  transformer where MMT m is sometimes m and sometimes Identity?
20:07:00 <Welkin> @hoogle MaybeT
20:07:04 <lambdabot> Control.Monad.Trans.Maybe newtype MaybeT m a
20:07:04 <lambdabot> Control.Monad.Trans.Maybe MaybeT :: m (Maybe a) -> MaybeT m a
20:07:04 <lambdabot> package MaybeT
20:07:24 <drostie> Like, not MaybeT where the (Nothing | Just x) is happening on the value x in m x, but something happening on the monad m.
20:08:06 <geekosaur> at one point someone thinko-d and the timeout was .03s (the usual, forgot threadDelay was in µsec)
20:08:40 <slack1256> drostie: Maybe (IO a) is something I use alot when I want that behaviour
20:08:50 <slack1256> is not really popular though
20:09:04 <Welkin> slack1256: are you mad?
20:09:11 * hackagebot monzo 0.4.0.0 - Haskell bindings for the Monzo API  https://hackage.haskell.org/package/monzo-0.4.0.0 (mbg)
20:09:17 <drostie> It has to do with a problem that I'm solving at work which is basically like having a (properly done) ListT Promise in JavaScript, but it sucks because a filesystem will often kick up these huge deferred chunks of undeferred code.
20:09:34 <slack1256> Welkin: I-i d-don't know!
20:10:12 <drostie> So you have a sort of ListT Promise [x] thing which is blazing fast, like 10s, then you go to profile just the ListT Promise x and it's... like, several minutes.
20:10:21 <slack1256> but really, is useful. Instead of nested ifs/guards I can check the conditions of a piece of data in a pure context and just at the end return the IO action (that will be ran by the caller)
20:10:53 <Welkin> :t Just 3 >>= return . print
20:10:54 <lambdabot> Maybe (IO ())
20:10:56 <Welkin> :D
20:11:06 <Welkin> blasphemy
20:11:10 <slack1256> and (ab)use the shortciuting and alternative instances of Maybe. The value is de-structured witht he `maybe` function
20:12:10 <MarLinn> In a way isn't the type of a module Maybe (IO ()) ? If there's a main, it's Just (IO ()), otherwise it's Nothing...
20:12:25 <drostie> slack1256: Hm. Yeah, I guess I'm sorta asking if there's a monad for newtype ALittleTainted m x = ALittleTainted (Either x (m x))
20:12:39 <slack1256> drostie: it is implicitly defined
20:12:55 <slack1256> for all a, Maybe a composes
20:13:02 <slack1256> specially if a = IO b
20:13:56 <lpaste> slack1256 pasted “Maybe (IO () ) is midly crazy” at http://lpaste.net/180632
20:13:58 <drostie> Right but when you're storing the x on the Left hand side of the Either I'm not sure you get all the axioms. Maybe you do.
20:14:44 <slack1256> nah, you do if you are really parametric on the (Either e a)
20:16:06 <drostie> well that's what I'm saying, is that the monad instance for Either is all about ignoring Left and propagating it out...
20:16:45 <slack1256> I thought that is what you wanted right?
20:17:04 <slack1256> You can also use Either (IO e) (IO a) 
20:17:09 * slack1256 feels heretic
20:17:36 <Welkin> you got your IO in my Either
20:18:52 <drostie> no, it's a type which either has no side-effects and stores a direct value of type x, or which has side-effects that produce a value of type x, so it's an Either x (m x) and I'm suddenly confused for example whether you can join an Either (Either x (m x)) (m (Either x (m x))) into an Either x (m x) because of what's happening on the left-hand side.
20:19:18 <drostie> But now that I write it out it sounds like you just take Left (Right monadic) -> Right monadic.
20:19:38 <drostie> I'll need to see if I can recover the monad laws from that though
20:20:46 <slack1256> this "construction" only buys you _one_ layer of a monad. As only you are interested on that effect.
20:21:30 <slack1256> You would have to `newtype` to get stuff like `join` implemented
20:21:53 <drostie> Yes, that's the point.
20:25:12 <drostie> I think we may be talking past each other then. My problem is that I have this JS code where I am modeling it as a ListT m x, and there is a too-costly reduction of ListT m [x] to ListT m (ListT m x) because the returns create all sorts of nasty allocations and extra layers of indirection and stuff.
20:26:16 <drostie> But I want this because I want to join to ListT m x because that makes user code really simple.
20:27:09 <drostie> So I'm trying to see if there is a data SometimesMonadicT m x = Plain x | Monadic (m x)
20:27:51 <drostie> because if that's a monad then I can return into Plain and save some of the allocations, and actually in JS the typing is loose enough that I might be able to save all of them.
20:33:20 <slack1256> Wasn't ListT really unlawful if the monad m wasn't commutative
20:33:21 <slack1256> ?
20:37:16 <linman> hi, i am running simple executable that i built and it is not print stuff to io until i give inputs
20:37:27 <linman> how can i fix that?
20:37:44 <Welkin> @lpaste
20:37:44 <lambdabot> Haskell pastebin: http://lpaste.net/
20:38:08 <glguy> linman: I'd guess it's a buffering issue, paste the code to the link Welkin provided and we can find otu
20:38:37 <linman> http://lpaste.net/180636
20:38:56 <glguy> linman: That's a buffering issue, stdout is in LineBuffering mode by default
20:39:12 * hackagebot atmos 0.4.0.0 - 1976 US Standard Atmosphere Model  https://hackage.haskell.org/package/atmos-0.4.0.0 (GregHorn)
20:39:16 <glguy> linman: You can import System.IO, and add hFlush stdout after you putStr
20:40:04 <glguy> Alternatively you can change the buffering mode: hSetBuffering stdout NoBuffering
20:40:19 <glguy> While that's technically less efficient, for simple code like this it won't matter.
20:40:59 <Welkin> that is written strange
20:41:02 <Welkin> hard to read actually
20:41:32 <linman> Welkin: the list comprehension?
20:41:37 <linman> thanks glguy
20:41:51 <Welkin> I meant the prompt
20:42:41 <jle`> can anyone help me write a type family for reversing type-level lists with the new injective type family thing?
20:42:56 <linman> Welkin: well, it has to be on one line
20:43:07 <jle`> type family Rev as = bs | bs -> as where Rev '[] = '[]; Rev (a ': as) = ??
20:43:12 <jle`> i'm not sure if it's possible
20:43:50 <jle`> i can't use any other type families in the definition, according to GHC
20:44:12 <jle`> also maybe it's probably not possible for GHC to verify its injectivity if i define it in the usual way, admittedly
20:45:33 <drostie> slack1256: so newtype ListT m x = ListT {runListT :: m [x] } requires commutativity because essentially you have to decide on a length up-front.
20:48:30 <drostie> slack1256: but newtype ListT m x = ListT (m (Maybe  (x, ListT m x))) or some such thing doesn't require that because at each step the effects can decide whether the list ends or not.
20:48:56 <MarLinn> drostie, I /think/ your transformer follows all the laws as long as it has the intuitive behaviour: pure wraps without monad and every combinator wraps if one of the arguments does.
20:54:37 <drostie> MarLinn: the one in particular I'm worried about is the associativity of join... I'm working on it but it just "feels" dangerous to have two options for what I can do for `return`.
20:56:36 <pavonia> Are there functions to "cast" signed to unsigned numeric types, e.g. Int8 to Word8, and vice versa?
20:56:44 <glguy> fromIntegral
20:57:56 <pavonia> Thanks
21:00:54 <MarLinn> drostie, I was looking at the alternative formulation via (>=>). return must be its left and right identity and it must be associative.
21:01:27 <MarLinn>  Associativity: If any application "escalates", then the whole structure does, regardless of order, so no problem
21:02:00 <ReinH> (These are the monoid laws, just like for (.))
21:02:15 <ReinH> And, you know, other monoids.
21:03:53 <MarLinn> ReinH, does that mean they are not applicable to monads, or is that just the observation that (>=>) is composition in the "monadic monoid"?
21:04:15 <drostie> I am not sure enough what "escalates" means to 100% believe you but I think I'm almost through a proof.
21:04:17 <pavonia> glguy: Do you know if GHC can optimize that to a no-op somehow? I see the implementation uses an intermediate Integer
21:04:41 <glguy> Yeah, it'll be fine
21:04:44 <pavolzetor> why does zeromq haskell binding block on send?
21:04:54 <pavolzetor> I get 100% cpu usage
21:05:02 <Welkin> pavolzetor: ask the author
21:05:09 <pavolzetor> I implemented same program in C and it just works
21:05:10 <pavolzetor> no blocking
21:05:33 <ReinH> Maybe it's a bug. You could report it to the author.
21:05:53 <ReinH> If it isn't a bug then you must be doing something wrong, and they might be able to help with that too.
21:06:27 <pavolzetor> ok, going to report
21:06:34 <ReinH> Well, I suppose it could be a "feature", but that seems unlikely.
21:06:38 <MarLinn> drostie, by "escalate" I mean that the combinators must be cautious and wrap everything in a monad as soon as they encounter one
21:06:48 <pavonia> pavolzetor: Did you compile your program with -threaded? I think I had that problem once with another program where that flag was missing
21:07:02 <pavolzetor> yes, it even uses 800% CPU
21:07:06 <pavolzetor> but does nothing
21:07:53 <ReinH> Well, it provides some warmth to the surrounding area.
21:08:11 <pavolzetor> and noise
21:08:14 <ReinH> See that's how we know Haskell is impure.
21:08:36 <Welkin> I used to let me pentium 4 idle to heat up my room in the winter
21:08:39 <Welkin> my*
21:10:44 <MarLinn> drostie, if return >=> g and g is simple, then the result must be simple. (>=>) is not allowed to escalate. In other words return must wrap "unmonadic", and everything should work out
21:11:12 <ReinH> I really don't understand what "escalate" means.
21:11:29 <MarLinn> wrap in the monad instead of returning a pure value
21:11:35 <ReinH> I suspect this is an imprecise use of terminology when the types themselves would be more appropriate
21:11:36 <slack1256> I guess stacking. m (m a)
21:11:39 <Welkin> like those moving stairs at the mall
21:12:19 <slack1256> moving stairs? witchcraft
21:13:05 <ReinH> fwiw, associativity of join and associativity of (>=>) are not necessarily the same thing
21:13:45 <ReinH> one might be the associativity at the type level, of the composition of functors
21:14:19 <shachaf> No, they're both associativity at the value level.
21:14:27 <shachaf> Well, maybe at different value levels.
21:15:09 <ReinH> shachaf: associativity of join might be in the category of endofunctors, while associativity of (>=>) is in the category of Kleisli arrows.
21:15:39 <ReinH> depending on what "associativity of join" means
21:15:54 <shachaf> Right. But neither is at the type level.
21:16:29 <ReinH> No? m (m (m a))) is type-level.
21:16:32 <pavolzetor> so I thought about it, and I think it has to block as for the context to terminate and clean up
21:16:52 <shachaf> (a -> m b) is also type-level.
21:16:54 <ReinH> pavolzetor: Ok, but it shouldn't busy wait.
21:17:19 <MarLinn> So... if (>=>) forms a monoid, do the objects of its category form a monad, or should I be following the "usual" laws instead?
21:17:28 <ReinH> shachaf: That's true, but m . (m . m) is type level, while k >=> (l >=> m) is value level
21:17:45 <shachaf> Yes, but the associativity of join isn't the fact that m . (m . m) = (m . m) . m
21:17:57 <ReinH> No?
21:18:03 <ReinH> I guess that's what I'm asking for clarification on.
21:18:04 <shachaf> There's no join in that statement.
21:18:35 <shachaf> That's just associativity of (type-level) (.).
21:19:12 <pavolzetor> that's true, and with async it still does some weird stuff
21:19:53 <MarLinn> Ok, I'll try to prove the equivalence myself I guess...
21:22:41 <ReinH> shachaf: Ok, I shouldn't mix terminology. I mean the natural transformation join : T . T -> T
21:23:01 <shachaf> Yes, that's what I mean too.
21:23:16 <shachaf> That thing exists on the value level. It's a natural transformation (in Haskell, a polymorphic function).
21:31:16 <grantwu> Where is (,) defined?
21:31:39 <shachaf> You can ask ghci with :i
21:31:42 <shachaf> But it's built-in.
21:31:59 <MarLinn> (sadly)
21:36:27 <Welkin> @src (,)
21:36:27 <lambdabot> Source not found. stty: unknown mode: doofus
21:37:23 <geekosaur> not that @src tells you the truth, necessarily
21:38:44 <MarLinn> or ghci, for that matter
21:43:56 <grantwu> How do I fix cabal install hoogle not working
21:44:16 <slack1256> shachaf: not that it had just special parsing rules? (same as [Int]). But it was declared as data as every other ADT right?
21:44:45 <shachaf> It behaves as if it's declared as data (a,b) = (a,b)
21:44:52 <jle`> why is it caled "gcastWith"
21:44:55 <jle`> what does the g stand for?
21:45:05 <jle`> oh, "generalized"
21:45:18 <grantwu> This is the log of cabal install not workinghttps://bpaste.net/show/a3700002d0f3
21:45:54 <shachaf> :t gcastWith
21:45:56 <lambdabot> error: Variable not in scope: gcastWith
21:46:09 <shachaf> gcast is generalized cast, yes.
21:46:11 <glguy> grantwu: The Hoogle maintainer doesn't bother documenting the versions of the libraries that it requires
21:46:54 <glguy> grantwu: As it happens the network package split into network and network-uri when network became version 2.6
21:47:52 <grantwu> So... sorry, Haskell noob, what exactly do I do here?
21:48:45 <glguy> grantwu: What happens if you use: cabal install --dry hoogle --constraint="network>=2.6"
21:49:17 <MarLinn> slack1256, try this in ghci: :set -XNoImplicitPrelude \n :m \n :t ((),()). Works for numbers and lists, too. So it can't just be parsing rules.
21:51:17 <athan> Has anyone here done anything like a redundant acid-state replication service thing with cloud haskell?
21:51:17 <grantwu> glguy: Hrm... I'm going to try with stack install hoogle...
21:51:34 <Clint> apt-get install hoogle
21:51:50 <athan> I'm sure it would be pretty easy to put together, not much novel code involved
21:52:54 <glguy> grantwu: sorry to hear it
22:01:09 <Axman6> athan: I've thought about it, building on rust, but acid-state doesn't seem to have exposed enough to make it easy to reuse a lot of the parts
22:01:55 <Axman6> uh, building on raft*
22:14:08 <significance> Hey all! I know that `pure 'a' :: Maybe Char` wraps 'a' into a Maybe - how would I do the same thing for (->) Char as a functor?
22:14:42 <glguy> pure 'a' :: r -> Char
22:14:43 <shachaf> First, forget the word "wrap".
22:14:49 <significance> glguy: thanks!
22:15:06 <glguy> Maybe is the one functor, (->) r  is the other
22:15:13 <shachaf> But then pure 'a' has the type glguy said. To be more explicit about what you wanted you can write: pure 'a' :: (->) Char Char
22:16:38 <significance> shachaf: gotcha - thanks!
22:18:34 <significance> dumb question, but why does `(pure 'a' :: (->) Char Char) 'a'` work but `pure 'a' :: (->) Char Char $ 'a'` not?
22:19:11 <shachaf> Becuase $ , which is an operator, is stickier than :: , which is syntax.
22:19:18 <significance> ahh, gotcha - thanks!
22:19:20 <sclv> glguy , grantwu -- running "cabal unpack hoogle" then cding into the directory and running cabal new-build seems to work just dandy
22:19:24 <sclv> fyi
22:19:34 <significance> is there any way to apply a function of type r -> Char?
22:19:54 <significance> i.e. if I did `pure 'a' :: (->) r Char`, could I apply that?
22:20:09 <glguy> Yeah, you could apply it to any value
22:20:20 <significance> glguy: sweet - thanks!
22:20:34 * Clint squints.
22:22:05 * glguy helps Clint find his glasses
22:22:53 <glguy> ( ∙_∙)>⌐■-■
22:24:00 <MarLinn> glasses = bifunctors on lenses?
22:24:10 <cocreature> what would we do without glguy? not only does he help with haskell questions, he also helps people find glasses!
22:24:49 <shachaf> Maybe we would drink less.
22:25:54 <cocreature> shachaf: hm is that a good or a bad thing?
22:26:23 <MarLinn> maybe we would just drink out of bottles without the glasses
22:27:47 <Axman6> shachaf: even without the glasses, we'd still drink straight from the bottle
22:27:57 <Axman6> damn, beaten to it :(
22:28:48 <lpaste> Mahdi pasted “No title” at http://lpaste.net/180647
22:30:06 <MarLinn> Axman6: cheers!
22:30:09 <glguy> mahdi: Looks like you have a capitalization problem with chart
22:30:20 <mahdi> hey, so I just wanted to install the `Chart` and `Chart-diagram` packages using stack, but then I get this output from `stack build`. I had no trouble installing other dependencies and I can't really understand what it means by `must match -any`. http://lpaste.net/180647
22:31:02 <mahdi> glguy: no, the package actually is capitalized, I get `package not found` when I use lowercase C
22:31:16 <glguy> mahdi: Yeah, so you'll need to make sure that it's capitalized in deep-reinforcement-learning-g2048
22:31:51 <glguy> Is that the top-level package that you're trying to build?
22:32:00 <mahdi> glguy: Oh! that's right :D thanks
22:32:15 <glguy> mahdi: and the -any part is because you forgot to specify the version constraints in your .cabal file
22:32:56 <mahdi> glguy: I see, so cabal can't find `chart` (which is interpreted as `chart-any`) in stack and it's complaining.
22:33:57 <mahdi> glguy: thanks, been banging my head on the keyboard o nthis since last night :D
23:21:14 <potbelly> \q
23:23:08 <jle`> wow finally removed all the unsafeCoerces from my hacky afternoon
23:23:24 <jle`> not sure if it was worth it
23:23:37 <dmwit> s/unsafeCoerce/coerce/g
23:24:09 <dmwit> hum
23:24:17 * hackagebot ntha 0.1.3 - A tiny statically typed functional programming language.  https://hackage.haskell.org/package/ntha-0.1.3 (zjhsdtc)
23:24:20 <dmwit> Can you use unsafeCoerce to invent a typeclass dictionary out of nowhere?
23:24:39 <lispy> at which phase?
23:24:39 <dmwit> ...I suppose the answer is both "yes" and "that would be unsafe". =P
23:26:09 <dmwit> lispy: `data NumLol = forall a. Num a => NumLol a` and then `unsafeCoerce :: Char -> NumLol`
23:26:52 <lispy> I guess I was wondering more about where the wheels fall off
23:27:08 <lispy> At type checking time it's probably mostly all good
23:27:17 <ertes> dmwit: that's what the reflection library is doing
23:27:20 <lispy> but when you go to use that dictionary...
23:27:22 <dmwit> I think at runtime it will try to access the memory in the `Char` and treat it as a `Num` dictionary.
23:27:43 <ertes> dmwit: which means: if you need that, use the reflection library =)
23:27:44 <dmwit> Which will probably knock your wheels off.
23:28:03 <lispy> dmwit: it certainly wouldn't be comfortable Num
23:28:14 <lispy> comfortably*
23:28:33 <dmwit> groanget
23:29:17 * hackagebot stochastic 0.1.1.0 - Monadic composition of probabilistic functions and sampling.  https://hackage.haskell.org/package/stochastic-0.1.1.0 (chokboy)
23:29:27 <lispy> This makes me realize that I don't know how dictionaries are laid out in STG
23:30:02 <ertes> dmwit: https://github.com/ekmett/reflection/blob/master/fast/Data/Reflection.hs#L166
23:30:20 <dmwit> Why do you keep trying to sell me reflection? I'm not buying!
23:30:43 <ertes> dmwit: i'm not…  i'm showing you that it literally does what you just wrote
23:31:48 <ertes> sorry for trying to help…  i'll shut up
23:33:17 <dmwit> =(
23:33:23 <dmwit> Thank you for pointing it out.
23:59:34 <gestone> hi all
23:59:43 <lispy> gestone: hello
23:59:45 <gestone> i had a question about composing monad transformers
