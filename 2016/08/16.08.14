00:16:47 <wz1000> given fibs :: [Int] = 1 : 1 : zipWith (+) fibs (tail fibs), can ghc garbage collect the front of the list when calculating fibs !! n for a large index?
00:20:40 <Maxdamantus> wz1000: depends where it's defined.
00:21:26 <wz1000> Maxdamantus: in a let binding in the definition of another variable
00:22:33 <Maxdamantus> wz1000: if it's not inside a function then it's pretty much not allowed to be GCed.
00:23:10 <wz1000> Maxdamantus: My definition is fib = fibs !! <large number> where fibs = ...
00:23:37 <Maxdamantus> eg, if you do `(fibs !! x, fibs !! y)`, it's not allowed to evaluate anything under `fibs` twice.
00:24:25 <wz1000> Maxdamantus: I only use fibs once
00:25:27 <wz1000> Maxdamantus: How should I define it to make it garbage collect the front?
00:26:36 <Maxdamantus> wz1000: possibly something like `fibs () = let fibs = .. in fibs`
00:26:51 <Maxdamantus> though you'd probably still need to check that it does get GCed.
00:27:40 <Maxdamantus> Since afaik, GHC will usually identify such definitions as closed and raise them up.
00:32:07 <edwardk> wz1000: if you are in compiled code, yes. if you're in the repl, it'll still be reachable from the repl of course
00:32:29 <edwardk> there is code in ghc for detecting 'unreachable cafs' and letting them be collected
00:33:14 <edwardk> wz1000: you know you can make a much faster fib that runs in log time, right?
00:33:19 <edwardk> (just for reference)
00:34:44 <wz1000> edwardk: Yeah, but I'm just trying to play around with GHC
00:34:55 <wz1000> edwardk: Here is my code http://lpaste.net/176858
00:35:08 <edwardk> wz1000: fair nuff https://www.schoolofhaskell.com/user/edwardk/fibonacci/search has a fancy fib ;)
00:35:15 <wz1000> It still allocates some 2.5gb worth of ram
00:35:54 <wz1000> I want to see if GHC can optimise it to constant memory use
00:36:10 <edwardk> it produces the garbage but is that just because it hasn't triggered a gc?
00:36:22 <kadoban> wz1000: How big of a number is the 30000000th fib number?
00:36:32 <edwardk> hah or that
00:36:46 <edwardk> try it with Int ;)
00:36:54 <wz1000> edwardk: It is an Int
00:36:59 <kadoban> Oh it is Int, nevermind.
00:37:08 <edwardk> shucks
00:37:42 <Maxdamantus> I'm guessing GHC will still compile that inner fibs definition to a single thunk which it will consider to be always reachable.
00:37:46 <edwardk> regardless even for the naive top level def ghc should be able to be smart about it
00:38:02 <edwardk> what optimization level are you running at?
00:38:45 <wz1000> edwardk: I've tried -O{1-3}
00:40:17 <srhb> wz1000: O3 is still a no-op, isn't it?
00:40:23 <edwardk> yeah
00:41:21 <wz1000> srhb: Ah, I'm mixing up gcc and ghc
00:42:09 <wz1000> BTW what happened to unboxed types in ghc 8?
00:42:26 <wz1000> It thinks # is a type function
00:44:42 <srhb> wz1000: I don't think MagicHash changed
00:59:49 <wz1000> edwardk: Ok, so indexing fibs = 1 : fibs runs in constant memory. However even something like fibs = 1 : map (+1) fibs runs in linear memory
01:00:30 <wz1000> Maxdamantus: ^
01:01:28 <Maxdamantus> Well, when you write `fibs = 1 : fibs` you only have a finite number of thunks.
01:05:18 <Maxdamantus> It's just creating a cyclic graph. You follow the list to itself.
01:05:58 <Maxdamantus> When you do `fibs = 1 : map (+1) fibs` you're creating an infinite graph that can hopefully be GCed as it's traversed.
01:06:58 <Maxdamantus> and actually that last definition is probably going to be worse than the zipWith code you had at first.
01:07:15 <Maxdamantus> actually, nvm, it will be just as bad.
02:03:24 * hackagebot mustache 2.0 - A mustache template parser library.  https://hackage.haskell.org/package/mustache-2.0 (justus)
02:03:47 <tomjaguarpaw> Does Core's 'case x of z -> ...' force x?  (It doesn't in the surface syntax)
02:03:52 <tomjaguarpaw> (and it does in STG)
02:07:26 <srhb> tomjaguarpaw: Surface syntax? As in Haskell? Isn't that exactly how you force, pattern matching?
02:08:08 <tomjaguarpaw> srhb: case with a single branch does not force
02:08:18 <srhb> Oh.
02:08:48 <tomjaguarpaw> Which is actually a bad inconsistency, IMHO.  But I'm not sure whether this is the case in Core.
02:09:29 <srhb> Hmm, isn't the single branch just a side effect of the pattern actually matching anything?
02:09:31 <srhb> I mean
02:10:23 <srhb> > let x = undefined in case x of [] -> "This evaluates x"
02:10:26 <lambdabot>  "*Exception: Prelude.undefined
02:10:56 <tomjaguarpaw> Right, I guess I meant "single default branch"
02:11:13 <srhb> Ah.
02:11:23 <tomjaguarpaw> > case undefined of z -> "This evaluates x"
02:11:23 <tomjaguarpaw> "This evaluates x"
02:11:25 <lambdabot>  "This evaluates x"
02:11:42 <geekosaur> "A case expression is always strict, even if there is only one alternative, and it is DEFAULT. (This differs from Haskell!)"
02:11:54 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType#Caseexpressions
02:12:52 <tomjaguarpaw> geekosaur: Ah, thanks!
02:41:52 <quchen> tomjaguarpaw: Yes, case is strict in both Core and STG.
02:42:21 <quchen> tomjaguarpaw: There is a special translation rule for Haskell's case into Core that deals with the case where the first pattern is a wildcard.
02:42:53 <quchen> It’s rule (f) in the formal semantics of pattern matching in the Report.
02:43:24 <quchen> case value of { _ -> e; _ -> e' }   ---->  e
02:47:47 <gingitsune> Is it possible to define function types in ghci?
02:48:00 <gingitsune> like factorial :: Integer -> Integer
02:48:46 <LordBrain> you can make a type synonym
02:48:55 <lyxia> let factorial :: Integer -> Integer ; factorial n = n
02:49:09 <LordBrain> type Int2Int = Integer -> Integer
02:49:21 <LordBrain> factorial :: Int2Int
02:49:23 <Gurkenglas> Is "plus !x !y = x + y :: Int" exactly as strict as "(+) :: Int -> Int -> Int"?
02:49:52 <quchen> (+) is strict in both arguments for Int as far as I know.
02:50:01 <gingitsune> LordBrain: thanks
02:50:02 <quchen> (“yes”)
02:51:59 <Shockk> hello, I'm looking into writing an instance of AsEmpty (part of lens) for one of my data structures, and the issue I'm facing is that, although there's a default implementation of _Empty, it requires instances of Monoid and particularly Eq which isn't possible as I'm using a Vector of Dynamic values; so I'm looking into the source of Control.Lens.Empty to try and manually implement _Empty, because I know
02:51:59 <Shockk> that both Vector and HashMap have instances of AsEmpty without the Eq constraint
02:52:21 <Shockk> I'm just having trouble doing this though and wondered if anyone has experience and would be able to help
02:53:55 <Gurkenglas> > seq (undefined + 2 :: Int) () -- quchen, given that both of these are undefined, can you give a more forceful statement on whether plus and (+) are exactly identical on Int?
02:53:57 <lambdabot>  *Exception: Prelude.undefined
02:54:05 <Gurkenglas> > seq (2 + undefined :: Int) ()
02:54:06 <lambdabot>  *Exception: Prelude.undefined
02:54:36 <Gurkenglas> (Is there a way to ask lambdabot "are both of these terms undefined" in one line? @@ is cheating x) )
02:55:56 <LordBrain> well, you could catch the exception
02:56:23 <Gurkenglas> @@ (@show @run seq (undefined + 2 :: Int) ()) (@show @run seq (2 + undefined :: Int) ()) -- ehh i guess @@ is better than catching exceptions.
02:56:26 <lambdabot>  " *Exception: Prelude.undefined\n" " *Exception: Prelude.undefined\n" -- ehh i guess  is better than catching exceptions.
02:58:44 <quchen> Gurkenglas: A more forceful statement, no.
02:58:47 <Gurkenglas> Shockk, an easy way should be to look up how ekmett does it in http://hackage.haskell.org/package/lens-4.14/docs/src/Control.Lens.Empty.html#AsEmpty
02:59:26 <Gurkenglas> Ah, because I didnt exclude syntactic identity or because of inlining that might not happen?
02:59:47 <Shockk> Gurkenglas: I'm on the page right now, I figured the easiest instance to try and replicate the style of would be but it seems kind of confusing at first and second glance
03:00:26 <Shockk> but actually right now I'm just implementing an equivalent empty and null for my structure, and I can probably just do a `nearly` instance like is done for things like Map and Vector
03:00:54 <Gurkenglas> yea was about to suggest that cant be that bad if hes doing it and it doesnt need eq either
03:01:17 <Shockk> yep
03:02:42 <Shockk> oh okay that worked :D
03:02:44 <Shockk> thanks
03:50:04 <xeviox> hi guys, does stack support some kind of vendoring (for dependencies?
03:50:25 <yurrriq> xeviox: short answer, yes.
03:50:59 <yurrriq> check the manual. I've gotta run but thought I'd say "yes." ;)
03:51:01 <xeviox> yurrriq: thanks, could not find suitable answer in the docs
03:51:17 <xeviox> yurrriq: I see that it supports local dependencies 
03:51:31 <yurrriq> xeviox: what are you trying to do, specifically, then?
03:52:02 <xeviox> but there is no info to a command like "stack vendor" that pulls dependencies and puts them into a local folder that can be checked into the vcs
03:52:28 <yurrriq> are your packages on hackage?
03:52:41 <yurrriq> or are they github repos?
03:52:55 <xeviox> currently I don't have a concrete project but say yes, they are on hackage
03:53:00 <yurrriq> in either case, there's some way of adding those in stack.yml
03:53:25 <xeviox> yes, but then they get pulled from the source on another pc
03:53:37 <yurrriq> for example, I needed a more recent version of idris that wasn't in stack yet, so I said "- idris-x.y.z" somewhere
03:53:54 <yurrriq> I guess I don't follow what the trouble is.
03:54:14 <yurrriq> you can specify non-stack hackage stuff, or github repos, or point to somehwere on your local filesystem
03:54:19 <yurrriq> I think there are even a couple more options.
03:54:43 <xeviox> yes it covers all needed options
03:54:50 <yurrriq> ah ok :)
03:54:52 <xeviox> but does not help to pull dependencies local
03:55:01 <Shockk> hello, I have a quick question about HashMap from the unordered-maps package; if I wanted to have a HashMap from keys of arbitrary types, to values
03:55:02 <yurrriq> it does though
03:55:05 <xeviox> so I could setup things manually and everything will work
03:55:11 <yurrriq> at least for hackage and github
03:55:18 <yurrriq> not just github, any git repo, I think
03:55:19 <Shockk> would something such as the following (or similar) be appropriate to model that? :
03:55:32 <xeviox> ok, let me try to explain what I mean
03:55:38 <Shockk> HashMap (TheIntegerHash, TypeRep) Value
03:55:46 <xeviox> lets say I add 8 deps from hackage
03:55:51 <xeviox> compile and everything is fine
03:56:43 <Shockk> for example if I wanted to map "hello" to value1, it'd be a mapping from (hash "hello", typeRep "hello") => value1
03:56:46 <xeviox> what I then want to do is something like "stack vendor" which moves the deps to a local folder and rewrites the config to point to the local folder. Then I can "git add" this folder and on another pc I don't need an active internet connection for pulling the dependencies
03:57:53 <yurrriq> xeviox: Ah, I see. In that case, I don't think it'll do that out of the box.
03:58:28 <yurrriq> should be too hard to script though
03:58:36 <yurrriq> And I very well might be wrong.
03:58:54 <xeviox> yurrriq: ok thanks :). Think it shouldn't be that hard, also ;)
03:59:19 <yurrriq> What I've done for that is keep a local clone of the other repo and then just manual change the reference in my project when "other repo" is good to go and pushed
03:59:22 <Shockk> hmm actually scrap my question, I figured out a better method of doing what I want to do
03:59:24 <Shockk> thanks thoguh
03:59:27 <Shockk> though*
03:59:38 <yurrriq> 'stack vendor' sounds great though.
03:59:52 <yurrriq> Also, be warned it might already exact. I just haven't heard of it :)
04:00:05 <yurrriq> Oops, already said that.
04:00:15 <yurrriq> Shockk: nice one
04:01:45 <xeviox> yurrriq: couldn't find something like that in the docs.. Does it support some kind of plugins? (that's how a similar solution is currently supported in rusts tool cargo)
04:03:07 <haskellhq2> Hey guys, feel free to tackle this one: https://stackoverflow.com/questions/38937264/haskell-database-connections
04:12:55 <mpickering> haskellhq2: Isn't the typical solution to use a connection pool?
04:15:47 <haskellhq2> mpickering: maybe, i have no idea..
04:15:51 <troydm> so I need to write some haskell HUnit test and I have some big json file that needs to be read for that test
04:16:19 <mpickering> I think that's the general technique but I have never done it myself
04:16:21 <troydm> how can I do that?
04:16:57 <LordBrain> depending on what you use for the database, you may not want millions of simultaneous connections
04:17:02 <mpickering> What is the problem troydm?
04:17:26 <mpickering> type Assertion = IO (), so you can read the file inside an assertion
04:17:33 <troydm> mpickering: I have no idea how can i include that data file into cabal and get it for test
04:18:12 <mpickering> You need to add the json file to data-files section in the cabal file
04:18:15 <mpickering> so that they get included in the sdist
04:18:22 <mpickering> Is that the question/
04:20:19 <troydm> mpickering: hmm, I've tried specifying it in test-suite section but it says it's invalid
04:20:27 <mpickering> what's the error message
04:22:37 <troydm> mpickering: well it says data-files section is not valid
04:23:07 <mpickering> You put it in the first section, not in the test-suite section
04:23:17 <mpickering> in the bit with description, sypnosis etc
04:23:55 <troydm> mpickering: oic
04:24:04 <troydm> mpickering: and then just use full path as a name?
04:24:19 <mpickering> relative to the directory the cabal file is in
04:24:45 <mpickering> see here for example
04:24:45 <mpickering> https://github.com/jgm/pandoc/blob/master/pandoc.cabal
04:26:29 <osager> in aeson, the following code give me a list of results, each result contains a list of json structure,how can i access that?
04:26:30 <osager> results <- r .: "results" :: Parser [Object]
04:27:14 <osager> i have tried   tags <- results .: "tags" :: Parser [Object]
04:27:29 <osager> i suppose that i should use withArray
04:27:43 <osager> but can't figure out how to use it
04:30:27 <mpickering> What is the structure of your JSON?
04:31:52 <mpickering> and what exactly do you want to do? Convert each item in the list into a haskell value?
04:32:04 <osager> {response : {"results":["fields":{}, tags[]]}}
04:32:46 <osager> never mind, thanks anyway, i found a nested array discussion on stackoverflow
04:36:59 <troydm> mpickering: thanks figured it out
04:45:51 <osager> http://lpaste.net/176902
04:45:55 <helmut> hi. I get "virtual memory exhausted: Cannot allocate memory" while building ShellCheck for mips or mipsel. What ghc options should I look at for trying to reduce the virtual memory required for compiling (even at the expense of build time or other aspects)?
04:46:00 <osager> sorry i couldnt parse this json
04:46:25 <osager> how can i get the first name and last name in the tags
04:46:26 <osager> ?
04:51:27 <mpickering> So Object is a type you have defined yourself?
04:53:17 <mpickering> The general way is to parse the whole json value into a haskell datatype and then manipulate it as usual
05:00:38 <osager> Thanks
05:43:32 * hackagebot yesod-persistent 1.4.0.6 - Some helpers for using Persistent from Yesod.  https://hackage.haskell.org/package/yesod-persistent-1.4.0.6 (MichaelSnoyman)
05:48:32 * hackagebot yesod-auth 1.4.13.4 - Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-1.4.13.4 (MichaelSnoyman)
05:56:07 <hc> hi
05:56:32 <hc> I'm wondering if the performance of the protobuf (ghc generics) or protocol-buffers (hprotoc) on hackage is better
05:56:52 <hc> Has anyone got any experience with both packages?
06:07:20 <Mateon1> Hi, I have a question: Is it possible to use run time profiling info within a program? I'm making a game, and I want to know what's eating the most CPU in pure update code in certain situations/states; displayed within a debug screen inside the game. I would have to redesign the update code from scratch to add built in profiling, and I would lose purity.
06:08:27 <bergmark> Mateon1: can you do that with ekg?
06:08:38 <avctrh> anyone use aeson-schema?
06:09:34 <mpickering> avctrh: Ask your question and someone will help if they can
06:09:45 <avctrh> I'm running into a corner ghci/ghc incompatability corner case with the example 
06:09:48 <avctrh> on https://www.stackage.org/haddock/lts-3.6/aeson-schema-0.3.0.7/Data-Aeson-Schema.html
06:10:00 <avctrh> it works in ghci
06:11:08 <Mateon1> bergmark: From what I first see after a google, and after reading the package docs, no. I can't do that with pure code
06:11:18 <avctrh> but when i try to read it from a program, I get a type ambiguity error
06:11:30 <Mateon1> bergmark: And it's only for increasing counters, not tracking timing information
06:12:41 <mpickering> Guessing, it is probably because GHCi does type defauling
06:12:45 <mpickering> you can fix it by adding a type signature
06:14:47 <avctrh> here's the code: http://lpaste.net/176919
06:15:16 <avctrh> mpickering ah
06:15:20 <bergmark> Mateon1: re. losing purity, if you write an interface you can have one runner in IO and a pure one, the pure one would ignore certain actions like logging. You still have to rewrite some stuff to do that though
06:16:00 <avctrh> is there a trick to peek at what ghci is type defaulting arguments too?
06:16:13 <mpickering> I actually don't think that's the problem here
06:16:46 <mpickering> the type of 'validate' is not IO
06:16:53 <mpickering> it is a pure function which returns a list
06:17:08 <mpickering> so you can't just put it in a do block
06:18:14 <avctrh> mpickering i deleted a let that was there earlier. if i bind it to a variable
06:19:14 <avctrh> or take out the IO type signature, still get an error
06:19:20 <geekosaur> you need the let
06:19:44 <geekosaur> you cannot use <- because that requires an IO type
06:20:04 <geekosaur> and [ValidationError] is not IO something, it is [] something
06:21:44 <avctrh> I don't think that's the problem, I updated it here http://lpaste.net/176919
06:21:48 <avctrh> still the same type error
06:22:00 <avctrh> oh wait
06:22:22 <mpickering> Are you running the right file?
06:22:32 <mpickering> The errors don't match what is in the paste
06:22:34 <avctrh> sorry reverted to an error type ambiguity error. 
06:22:54 <mpickering> ok good, now you just need to add a type signature for foo
06:22:55 <avctrh> yeah didn't copy paste the error to the paste
06:23:09 <mpickering> Ghci defaults ambiguous type variables to ()
06:23:20 <mpickering> So that things like "print Nothing" work without errors
06:23:59 <geekosaur> tjay
06:24:00 <geekosaur> er
06:24:44 <geekosaur> I think that's not the only possible ambiguity; it can decide the monad is ambiguous, but ghci will always resolve it as IO
06:25:16 <geekosaur> (because ghci will try something as an IO action if it's not pure)
06:26:50 <avctrh> I don't think assigning a signature for foo is sufficient
06:27:07 <avctrh> the ambiguity seems to be in the arguments to validate
06:28:14 <geekosaur> can you provide the full actual error?
06:28:33 * hackagebot snaplet-postgresql-simple 1.0 - postgresql-simple snaplet for the Snap Framework  https://hackage.haskell.org/package/snaplet-postgresql-simple-1.0 (DougBeardsley)
06:28:41 <avctrh> No instance for (Ord ref0) arising from a use of ‘validate’
06:28:48 <avctrh> The type variable ‘ref0’ is ambiguous
06:28:52 <geekosaur> (note that there is an edit link on lpaste so you can replace the error in your prev paste)
06:30:21 <avctrh> updated http://lpaste.net/176919
06:31:00 <geekosaur> the second error is actually the one I just mentioned about IO
06:31:23 <geekosaur> only it says Applicative instead of Monad because you used pure instead of return
06:31:50 <geekosaur> (although if ApplicativeDo isn't enabled, it probably shouldn't do that...)
06:32:38 <ertes> geekosaur: it should, because this do-block is not monadic
06:32:59 <ertes> pure/return aren't handled specially by do-notation
06:33:25 <ertes> :t do let { x = 5 }; pure x
06:33:27 <lambdabot> (Num a, Applicative f) => f a
06:33:41 <liste> :t do {let x = 5 }; x
06:33:42 <lambdabot> parse error on input ‘;’
06:33:49 <ertes> :t do let { x = 5 }; x
06:33:50 <lambdabot> Num a => a
06:34:56 <ertes> in fact ApplicativeDo does treat them specially, while standard do-notation does not
06:38:02 <geekosaur> ok, I see what it is complaining about but I am not sure how you fix it...
06:38:44 <avctrh> ack gotta run
06:40:48 <geekosaur> possibly just by giving positiveNumbers a type signature specifying some dummy type (e.g. let positiveNumbers :: Schema (); positiveNumbers = ...)
06:41:08 <Welkin2> does anyone know of any other good AI resources besides this course? http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-034-artificial-intelligence-fall-2010/index.htm
06:41:26 <Welkin2> it already focuses too much on machine learning
06:41:30 <mpickering> It is not complaining about M.empty
06:41:34 <geekosaur> () being what ghci will be inferring
06:42:51 <ertes> Welkin2: what would you like to learn, if not ML?
06:43:06 <Welkin2> game entity AI
06:43:27 <Welkin2> minimax and A* are a good start, but what else?
06:43:50 <geekosaur> mpickering, I focused on that because that's where the (Ord ref) comes from
06:43:56 <Welkin2> besides writing a big state machine 
06:44:09 <ertes> Welkin2: there isn't much really…  most of them are a set of elaborate decision trees…  if you have enough such sets, you may get what is known as "emergent behaviors"
06:45:29 <ertes> Welkin2: and the big state machine is part of the deal, if you don't want to actually *learn* the AI
06:45:30 <avctrh> geekosaur that fixes it, thanks! 
06:46:48 <avctrh> not familiar with aeson schema tbh, wasn't grokking what ref is supposed to be modeling
06:48:04 <geekosaur> I didn't catch that either, I see Schema needs a type there but didn't spot what it did with it
06:48:29 <geekosaur> aside from possibly just being the type of keys in the Map (but yours is empty, so not relevant)
07:18:35 * hackagebot network-ip 0.3 - Internet Protocol data structures  https://hackage.haskell.org/package/network-ip-0.3 (MikhailVorozhtsov)
07:25:55 <AzureStigma> how does this particular reduce in lambda if True then "Truthin'" else "falsin'" 
07:30:55 <JordiGH> What's the name of that newer package manager?
07:31:16 <Welkin> there is no package manager
07:31:38 <JordiGH> what's the thing that isn't cabal and made people fork off?
07:31:46 <Welkin> stack?
07:31:46 <JordiGH> stack
07:31:48 <JordiGH> Right, thanks.
07:31:50 <Welkin> that's not what it is though
07:31:53 <Welkin> it's not a fork
07:31:54 <JordiGH> I kept confusing it with cargo.
07:31:57 <Welkin> it uses cabal
07:32:33 <JordiGH> Yeah, I mean, the thing that's making people fork off the Haskell website, IRC channels and website.
07:32:44 <Welkin> oh, the "for beginners" thing
07:32:47 <cocreature> it uses Cabal the library, but not cabal-install (which calls its executable cabal)
07:32:48 <JordiGH> I just couldn't remember the name.
07:32:49 <Welkin> that whole thing is stupid
07:37:26 <dcoutts_> cocreature: and just to make things more complicated: it does actually call cabal (the exe) for the solver
07:38:28 <cocreature> dcoutts_: well the default mode, i.e. using stackage snapshots, doesn’t use the solver, does it?
07:38:36 <dcoutts_> cocreature: right
07:39:19 <cocreature> I don’t think I’ve ever used it myself. at the point where I want a solver I just use cabal new-build
07:40:57 <ania123> can one correct me following sentence: Functional programming is a paradigm of declarative languages which involves writing of program in terms of functions and  describe what to do  rather than how to do, i.e. supports functional approach of problem solving.
07:41:28 <Welkin> ania123: there is no definition of functional programming
07:41:42 <Welkin> it's a vague idea
07:41:52 <hvr> dcoutts_: and we're slowly factoring out the solver into a separate package anyway, then they won't even have to call cabal-install at all :-)
07:42:09 <ania123> Welkin: could you please correct what i wrote?
07:42:20 <ania123> I am not going to define FP
07:42:38 <Welkin> ania123: but you just did
07:42:45 <Welkin> if that is your definitiona, that's fine
07:42:47 <ania123> I need to write Purposes of the course
07:43:08 <ania123> Welkin: is ur mother language english?
07:43:11 <Welkin> yes
07:43:27 <glguy> hvr: What package is that?
07:43:31 <ania123> is the sentence correct in terms of english
07:43:31 <ania123> ?
07:43:47 <dcoutts_> ania123: have a look around, there's various reasonable definitions around, e.g. in book intros
07:43:52 <lingxiao> hey all
07:44:04 <lingxiao> what's the difference between the bytestring from   data.bytstring.lazy
07:44:07 <lingxiao> and data.bytestring?
07:44:12 <hvr> glguy: right now it's still a ticket in the issue tracker :-) https://github.com/haskell/cabal/pull/3222
07:44:13 <lingxiao> aside from the "lazy", but what does it mean?
07:44:27 <lingxiao> and the one from Data.ByteString.Char8 
07:44:35 <lingxiao> there's so many ByteString versions my head is spinning
07:44:35 <ania123> Welkin: is the sentence correct in terms of english
07:44:39 <glguy> lingxiao: see http://hackage.haskell.org/package/bytestring
07:45:01 <ania123> dcoutts_: in particular?
07:45:11 <Welkin> ania123: it's close
07:45:28 <dcoutts_> lingxiao: did you have a look at the package description and intro sections for the module docs?
07:45:37 <lingxiao> glguy ok so i see int the case where i open a zip file and decoding it, the `decompress` function takes in  lazy bytestring
07:45:44 <dcoutts_> lingxiao: if that still leaves Qs then I'd be quite happy to explain
07:45:46 <lingxiao> its' because the assumption is that the zip file is large?
07:46:08 <cocreature> lingxiao: Char8 is not a separate bytestring type, it only exports some combinators that treat strict bytestrings as ascii strings
07:46:12 <lingxiao> dcoutts_ no i didnt :(  but I am now thanks to glguy and it does explain a lot
07:46:31 <Welkin> ania123: the first sentence here is close to what you have written https://en.wikipedia.org/wiki/Functional_programming
07:46:44 <dcoutts_> lingxiao: the key difference is the ability to do processing incrementally, like with lazy lists vs strict arrays
07:47:16 <lingxiao> by strict array you mean the whole array is in memory right?
07:48:49 <alercah> lingxiao: as opposed to storing thunks, yes
07:52:25 <Freezer25> http://ilredentore.dynv6.net/ updated server :)
07:54:19 <lingxiao> gotcha thanks
07:56:03 <ania123> I need to correct one sentence, can one help me with this matter?
08:08:53 <nitrix> Is there such thing as   none f = all (not . f) ?
08:11:32 <geekosaur> hayoo says there's one in Control.Lens.Indexed (but its type seems too simple to be a lens :p )
08:12:21 <geekosaur> but I suspect that `all . not` is not seen as being worth using a name up
08:12:32 <int-e> ITYM all . (not .)
08:12:49 <geekosaur> probably...
08:12:58 <int-e> or, perhaps,  not . any
08:15:11 <lingxiao> hey all
08:15:23 <lingxiao> is there a way to writeFile a Lazy bytestring
08:15:29 <lingxiao> as opposed to converting it to string first then writing it?
08:15:42 <lingxiao> or is there something on that precludes it from happeneing
08:15:57 <lingxiao> wait nvm
08:16:01 <lingxiao> it's in the docs 
08:16:03 <lingxiao> :( sorry!
08:21:31 <mniip> 1471187311 [18:08:31] <nitrix> Is there such thing as   none f = all (not . f) ?
08:21:49 <mniip> ah yes, int-e already mentioned (not .) . any
08:22:54 <int-e> Yes, of course I had to mess up the type too.
08:26:44 <int-e> It's interesting that  (not .) . all  doesn't have a corresponding english word.
08:27:28 <Welkin> :t (not .) . all
08:27:29 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
08:27:52 <Welkin> :t all
08:27:53 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
08:28:15 <nitrix> :t not .: all
08:28:16 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
08:28:49 <Welkin> :t (fmap not) . all
08:28:50 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
08:29:07 <Welkin> the levels of composition still confuse me
08:29:24 <nitrix> The parenthese are optional there, I think.
08:29:29 <int-e> :t fmap (fmap not) all
08:29:30 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
08:29:48 <nitrix> int-e: How... how does that work ._.
08:30:02 <nitrix> Because functor's <$> = (.) ?
08:30:05 <int-e> nitrix: (.) is a special case of fmap.
08:30:08 <nitrix> Gotcha.
08:30:21 <int-e> (the functor associated with the reader monad)
08:31:24 <nitrix> I'd prefer to say, the functor instance of partially applied functions :]  Functor ((->) r)
08:31:33 <nitrix> Functor of reader monad sounds odd.
08:31:49 <Welkin> Reader Functor :D
08:31:55 <nitrix> :>
08:34:04 <int-e> "The reader functor (for the lack of a better term)" ... okay, it is google-ble.
08:35:06 <int-e> nitrix: in any case, I learned about the reader monad before I had internalized the notion that monads are functors, so to me it's not strange at all.
08:38:24 <ertes> nitrix: except it's not the functor of partially applied functions
08:38:39 <nitrix> On a side note, `not $ all objSolid natives` seems to behave differently than `all (not . objSolid) natives`.
08:38:51 <ertes> it's the functor of functions, of dependencies, of environments, …
08:39:32 <jonored> nitrix: Of course. You've moved a not across a quantifier.
08:39:42 <kaol> :t (,) <$> id <*> Just
08:39:43 <lambdabot> a -> (a, Maybe a)
08:39:57 <ertes> or as most of us call them:  reader functors
08:40:01 <alercah> nitrix: not (all oranges are orange) -> some oranges are not orange
08:40:27 <nitrix> This oddly resembles existentials and universals :P
08:40:33 <alercah> nitrix: all (oranges are not orange) -> no orange is orange
08:40:48 <alercah> nitrix: that's because it is exactly that
08:40:50 <jonored> nitrix: There's a certain similarity between "this holds for all of this list" and "for all", yes...
08:41:15 <nitrix> I've apparently put the finger on a weakness of mine, interesting.
08:41:42 <nitrix> Granted I still understand quantification in type definitions, I seem to do these logical errors too often.
08:41:55 <black0range> Has anyone here tried to install haskell-mode for emacs from melpa recently?
08:47:13 <hvr> black0range: fyi, there's also #haskell-emacs  in case you don't get any answer here
08:47:31 <maerwald> and you shouldn't ask for people
08:47:39 <maerwald> but ask an actual question
08:47:43 <black0range> Thats nice :)
08:48:31 <black0range> Well i tried to download the haskell-mode package but it fails. Wondering if melpa is down or i've screwed up the configs :)
08:49:58 <monochrom> I have just asked my emacs to upgrade haskell-emacs from 13.20 to 13.20.1. It has finished.
08:50:43 <black0range> Must be a local issue then, thanks! 
08:51:35 <monochrom> err, s/haskell-emacs/haskell-mode/
09:22:39 <ahsfhyicxv> Why does this not error at compile time?
09:22:42 <ahsfhyicxv> (mfromMaybe (Nothing) :: IO Int)
09:23:04 <ahsfhyicxv> It errors at runtime:
09:23:05 <ahsfhyicxv> user error (mzero)
09:23:10 <Myrl-saki> Hmm
09:23:16 <Myrl-saki> Oh
09:23:19 <Myrl-saki> :t mfromMaybe
09:23:21 <lambdabot>     Not in scope: ‘mfromMaybe’
09:23:21 <lambdabot>     Perhaps you meant ‘fromMaybe’ (imported from Data.Maybe)
09:23:30 <Myrl-saki> What's the type of mfromMaybe?
09:23:38 * hackagebot genvalidity-hspec 0.2.0.4 - Standard spec's for GenValidity instances  https://hackage.haskell.org/package/genvalidity-hspec-0.2.0.4 (Norfair)
09:23:51 <ahsfhyicxv> mfromMaybe :: forall a (m :: * -> *). MonadPlus m => Maybe a -> m a
09:24:19 <Myrl-saki> ahsfhyicxv: `mfromMaybe = maybe mzero return`
09:24:19 <ahsfhyicxv> Not sure why the face appeared
09:24:27 <Myrl-saki> > print 1
09:24:29 <lambdabot>  <IO ()>
09:24:36 <Myrl-saki> > mzero :: IO ()
09:24:38 <lambdabot>  <IO ()>
09:24:41 <Myrl-saki> err
09:25:31 <glguy> ahsfhyicxv: It doesn't generate a compile time error because IO has a (questionable) MonadPlus instance
09:25:47 <Myrl-saki> glguy: mzero == fail?
09:26:14 <mniip> :t StateT (mfromMaybe . uncons)
09:26:15 <lambdabot>     Not in scope: ‘mfromMaybe’
09:26:15 <lambdabot>     Perhaps you meant ‘fromMaybe’ (imported from Data.Maybe)
09:26:19 <Myrl-saki> glguy: What ghc version is this?
09:26:38 <mniip> @let import Control.Monad.Plus
09:26:38 <lambdabot>  .L.hs:58:1:
09:26:38 <lambdabot>      Failed to load interface for ‘Control.Monad.Plus’
09:26:38 <lambdabot>      Perhaps you meant
09:26:38 <Myrl-saki> `    No instance for (MonadPlus IO) arising from a use of ‘mzero’
09:26:43 <mniip> shame
09:26:43 <Myrl-saki> `    No instance for (MonadPlus IO) arising from a use of ‘mzero’
09:26:47 <Myrl-saki> woops
09:26:52 <Myrl-saki> i said that twice, didn't notice.
09:26:56 <glguy> Myrl-saki: What version is what?
09:26:58 <Myrl-saki> 7.10.3
09:27:07 <Myrl-saki> glguy: IO haivng a MonadPlus instance.
09:27:20 <ahsfhyicxv> glguy: How is IO an instance of MonadPlus? How do you represent a failure in IO?
09:27:22 <mniip> Myrl-saki, is MonadPlus in scope?
09:27:34 <mniip> ahsfhyicxv, with exactly that - a failure
09:27:38 <glguy> Myrl-saki: I don't know when it was added, it is one in the current GHC
09:27:38 <Myrl-saki> mniip: lol
09:27:39 <mniip> an exception
09:28:05 <glguy> ahsfhyicxv: Failure (throwing an exception) is a valid IO action
09:28:18 <ahsfhyicxv> How do you know which IO operations can fail?
09:28:20 <Myrl-saki> Anyways, for what I came here for.
09:28:27 <Myrl-saki> How owuld I do sequencing in FRP?
09:28:35 <glguy> ahsfhyicxv: They all can
09:28:36 <Myrl-saki> Or should I *not* do sequencing in FRP?
09:28:55 <ertes> Myrl-saki: sequencing in what way?
09:29:13 <ertes> Myrl-saki: example application?
09:29:37 <Myrl-saki> ertes: I stumbled upon a thread about 2048.
09:30:34 <Myrl-saki> ertes: If you've played 2048, you'd notice that 2222 becomes a 44--. What I'm planning to do is to combine the 2 left 2s first, making it 422- and then combining the last 2s. 44--.
09:31:11 <Myrl-saki> ertes: I don't think I'll actually be implementing this, just something that crossed my mind.
09:31:46 <ertes> Myrl-saki: this doesn't seem to be FRP-related…  i'd combine first, then shift
09:32:06 <ertes> 2222 → 4-4- → 44--
09:32:27 <Myrl-saki> ertes: Yeah, that's what I was thinking too, but that's adding an additional check.
09:32:50 <ertes> shift, combine, shift again
09:33:39 * hackagebot stache 0.1.6 - Mustache templates for Haskell  https://hackage.haskell.org/package/stache-0.1.6 (mrkkrp)
09:34:03 <Myrl-saki> ertes: Also, it's easy to do with lists but I just thought it'd be nice to play with FRP
09:34:49 <ertes> Myrl-saki: to answer the original question: "sequencing" is not a concept in FRP…  you have events, and you can scan them and/or hold them
09:35:18 <Myrl-saki> ertes: Hmmm.. now that you said that, maybe I can daisy chain the events.
09:35:30 <ertes> 2048 is a rather trivial application regarding FRP
09:35:45 <ertes> basically one giant scanned event
09:35:53 <Myrl-saki> ertes: Pressing "left" would trigger an event on the leftmost squares, and each square would signal the one on the right.
09:36:52 <ertes> i don't see how you could make much use of FRP to drive the game logic…  if anything, it would be an awkward encoding of the simple updated state
09:37:13 <Myrl-saki> ertes: yeah, it'd be one giant mess.
09:37:22 <Myrl-saki> ertes: too many interdeps
09:38:09 <ertes> you can use FRP to encapsulate the game logic…  as said, 2048 is basically a single event scan
09:38:28 <ertes> scan :: (a -> b -> b) -> b -> Event a -> Behavior b
09:38:39 * hackagebot fresco-binding 0.2.0 - Fresco binding for Haskell  https://hackage.haskell.org/package/fresco-binding-0.2.0 (PeterAlthainz)
09:38:46 <sm> g'day all. I'm going to reset topic and abandon the #haskell-ide channel for now, unless someone wants to maintain/promote it
09:39:57 <ahsfhyicxv> Is there a version of MonadPlus that doesn't let you convert it into to anything that would cause an exception?
09:40:26 <ertes> ahsfhyicxv: "it"?
09:40:54 <Myrl-saki> ertes: mzero
09:40:59 <ertes> ahsfhyicxv: you mean a MonadPlus without mzero?
09:41:32 <ertes> ahsfhyicxv: there is Alt from the semigroupoids package, if that's what you're asking for, but i'm just guessing
09:43:28 <Myrl-saki> ertes: thanks. i guess i won't try making 2048 using frp for shifting and combining detection.
09:43:39 * hackagebot mustache 2.0.1 - A mustache template parser library.  https://hackage.haskell.org/package/mustache-2.0.1 (justus)
09:43:41 * hackagebot HGamer3D 0.8.0 - Toolset for the Haskell Game Programmer  https://hackage.haskell.org/package/HGamer3D-0.8.0 (PeterAlthainz)
09:44:41 <ahsfhyicxv> I mean MonadPlus where mFromMaybe Nothing :: IO Int fails at compile time but mFromMaybe Nothing :: MaybeT IO Int and mFromMaybe Nothing :: Maybe Int works.
09:45:53 <Myrl-saki> ahsfhyicxv: eh. i don't think that should be possible.
09:49:44 <osager> in Aeson i often see <*>, example SearchResult <$> t1 <*> t2 <*> t3, what is it?
09:50:06 <Myrl-saki> :t ap
09:50:07 <lambdabot> Monad m => m (a -> b) -> m a -> m b
09:50:14 <Myrl-saki> Hmmm.. it's not ap
09:50:17 <Clint> osager: do you know about Applicative?
09:50:28 <Myrl-saki> pure and...
09:50:33 <Myrl-saki> welp, forgot about the other one
09:50:35 <osager> ok so it's in applicatvie
09:50:40 <Myrl-saki> yeah
09:50:42 <osager> thanks
09:54:18 <osager> Myrl-saki, so how is it used here?
09:54:26 <osager> i read that it is sequential application
09:54:33 <Myrl-saki> oh. there's no non-infix operation.
09:54:43 <Myrl-saki> s/operation/synonym
09:55:09 <Myrl-saki> osager: well, in this case, it just means to finish completing the data, or something.
09:55:28 <osager> k
09:55:30 <osager> ok
09:55:36 <Myrl-saki> osager: I haven't really used aeson
09:56:20 <Myrl-saki> osager: deriving all the way.
09:57:43 <Myrl-saki> osager: iirc, that translates to `x <- t1; y <- t2; z <- t3; return $ SearchResult x y z`
09:58:07 <Myrl-saki> if i'm wrong, please correct me anyone
09:58:29 <osager> yeah that's true
09:58:50 <osager> it's jsut i dont undertand how
09:59:41 <Myrl-saki> osager: don't worry, we all start at that. which part don't you understand?
10:00:05 <osager> i know t1 t2 t3 are all Parser a
10:00:21 <Myrl-saki> right.
10:00:29 <osager> and SearchResult only needs the value wrapped inthose Parser
10:00:49 <mniip> osager, consider
10:00:53 <mniip> :t liftA3
10:00:53 <osager> and here SearchResult is used as a function
10:00:54 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
10:00:59 <Myrl-saki> osager: okay. first, lets check the result of `SearchResult <$> t1`
10:01:01 <mniip> do you understand in general what that does
10:01:17 <osager> which is feeded with three parameters
10:01:54 <osager> so i guess SearchResult <$> Parser a b c
10:02:16 <osager> so i guess SearchResult <$> Parser a b c = Parser SearchResult a b c
10:02:45 <mniip> osager, hold on a bit
10:02:54 <osager> but i dont know how Parser a <*> Parser b <*> Parser c becomes Parser a b c
10:03:06 <mniip> lemme explain
10:03:07 <Myrl-saki> mniip: i think he gets the part where the parsers are done in sequence and that it's being fed to `SearchResult`, but not why it's formed like that.
10:03:19 <mniip> Myrl-saki, clearly he doesn't :p
10:03:40 <mniip> osager, do you undestand what liftA2 does?
10:03:44 <mniip> :t liftA2
10:03:45 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:03:54 <mniip> for an arbitrary applicative
10:03:59 <Myrl-saki> osager: <$> and <*> have the same priority.
10:04:19 <osager> so it's applied from right to left ?
10:04:28 <Myrl-saki> osager: x <$> y <*> z == (x <$> y) <*> z
10:04:39 <Myrl-saki> osager: now, remember, partially applied functions.
10:04:55 <Myrl-saki> osager: let's assume that x :: a -> b -> c
10:05:08 <mniip> Myrl-saki, :I
10:05:14 <mniip> you aren't letting him answer
10:05:21 <mniip> TMI
10:05:32 <Myrl-saki> mniip: :(
10:05:42 <osager> ok ... x <$> y <*> z == (x <$> y) <*> z , i get this
10:05:46 <osager> so what's next step
10:05:56 <osager> what is the result of  (x <$> y) <*> z
10:06:03 <mniip> next step is understanding why we do that
10:06:03 <Myrl-saki> osager: so. what you're doing is manipulating the "return value" of the parser.
10:06:23 <osager> (SearchResult y) <*> z
10:06:25 <Myrl-saki> Now, let's go back to the type of <$>
10:06:29 <Myrl-saki> :t (<$>)
10:06:30 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:06:35 <mniip> sigh
10:06:51 <Myrl-saki> I'll let mniip take the stage. He has more experience than me.
10:07:07 <mniip> right, let's get back to liftA2
10:07:15 <mniip> :t liftA2
10:07:16 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:07:19 <osager> anyways, thanks guys, i think i have to spell out all the types of the operators to understand
10:07:29 <osager> it's hard to explain in words
10:07:32 <mniip> not really
10:08:43 <linduxed> so i've got two types: type BooleanLight = Bool; type IncrementalLight = Int
10:09:02 <linduxed> IIRC you can't separate statements like that with semicolons, but you get my point
10:09:24 <linduxed> now the thing is, these two types are both a kind of Light
10:09:38 <mniip> osager, the idea is that if you have a function (a -> b -> c -> ...), then <*> :: f (a -> b -> c -> ...) -> f a -> f (b -> c -> ...)
10:09:39 <linduxed> however, they (currently at least) don't share any real behaviour
10:09:47 <mniip> i.e you apply one argument of the function
10:09:59 <linduxed> subsequently, i don't really think that they can get any meaningful typeclass
10:10:00 <mniip> now, to initially wrap your pure function in f, you use pure
10:10:15 <mniip> and so you have: pure f <*> fx <*> fy <*> fz
10:10:18 <linduxed> do i in this case just accept them as being two separate types?
10:10:30 <mniip> pure f <*> x is commonly appreviated f <$> x
10:10:38 <linduxed> or could i do some sort of grouping nonetheless?
10:10:50 <osager> mniip, pure ?
10:10:55 <mniip> :t pure
10:10:56 <lambdabot> Applicative f => a -> f a
10:11:11 <osager> wrapper
10:11:38 <osager> mniip, thanks for all the tips, i will dig 
10:12:00 <mniip> I guess applicative is best explained in the case of []
10:12:20 <Myrl-saki> Maybe
10:12:41 <mniip> [(+), (*)] <*> [3, 5]  =  [(3+), (5+), (3*), (5*)]
10:13:42 <mniip> [(+), (*)] <*> [3, 5] <*> [1, 2] =  [3+1, 3+2, 5+1, 5+2, 3*1, 3*2, 5*1, 5*2]
10:14:04 <mniip> but if you only have one function, you can just use 'pure'
10:14:27 <Myrl-saki> this is in the context of aeson, so Maybe would have been really better
10:14:28 <mniip> pure (+) <*> [1, 2] <*> [10, 20] = [1+10, 1+20, 2+10, 2+20]
10:14:49 <mniip> parsers are more like StateT Maybe if anything
10:14:55 <mniip> StateT String Maybe
10:15:04 <Myrl-saki> True.
10:15:08 <mniip> or FreeT ((->) Char) Maybe
10:15:53 <cmr> this code parses, but what does it do? http://lpaste.net/176968
10:15:59 <cmr> in particular, the commas on line 5
10:16:12 <cmr> I would expect f (Just 1) == 0, but that's not the case..
10:16:19 <mniip> cmr, those are guards
10:16:26 <cmr> (interpreting the comma as conjunction)
10:16:28 <johnw> the right one is a guard pattern
10:16:33 <mniip> and commas are 'and'
10:16:36 <mniip> not 'or'
10:16:37 <johnw> oh, sorry, it's not
10:16:41 <johnw> guard patterns use "<-"
10:16:50 <cmr> ah, yes...
10:17:02 <mniip> if you want to use conjunction use multiple |-lines
10:17:07 <cmr> that's even consistent with my worldview, I just derped the program ;)
10:17:23 <mniip> or, you know
10:17:25 <Myrl-saki> or ||
10:17:27 <mniip> Data.Bool.||
10:17:52 <Myrl-saki> why don't we have fallthroughs
10:18:28 <mniip> because in core they are just as messy
10:19:01 <mniip> or do you want the haskell committee answer :o
10:19:03 <mniip> :p *
10:19:31 <Myrl-saki> go
10:20:23 <mniip> because the haskell committee decided so
10:21:08 <Myrl-saki> oh
10:22:48 <cmr> mniip: thanks.
10:25:40 <xplat> is there a way to get a list of your enabled cabal flags in code?
10:42:21 <hexagoxel> xplat: only manually via CPP afaik.
10:50:16 <xplat> hexagoxel: manually as in 'check each one'?
10:50:39 <hexagoxel> yeah.
10:50:53 <xplat> hrm.
10:50:58 <hexagoxel> maybe you can get a real list with custom setup.hs?
10:52:30 <hexagoxel> some configure hook that auto-generates a module containing a value listing the flags.
10:54:53 <fizruk> is there a foldMapM or foldMapA? something like foldMapM f t = fold <$> mapM f t
10:55:59 <fizruk> :t \f t -> fold <$> traverse f t
10:56:01 <lambdabot> (Applicative f, Traversable t, Monoid b) => (a -> f b) -> t a -> f b
11:03:59 <AaronFriel> I'm reading Haskell Session Types with (Almost) no Class and I found an implementation here: https://hackage.haskell.org/package/Coroutine-0.1.0.0
11:05:03 <AaronFriel> The implementation is interesting because - and I didn't know this was possible - it hides the Prelude's Monad class functions and aliases IxMonad's in its place
11:05:28 <AaronFriel> And this apparently allows "do" notation to work on indexed monads, but I can't get a simple example with my code to work.
11:06:02 <mniip> AaronFriel, you need to enable RebindableSyntax
11:06:17 <AaronFriel> THANK YOU!
11:06:31 <AaronFriel> that did it, I was getting a weird infinite type error
11:18:07 <tuxayo> Hi :) I want to make a program that 1: reads a file with a list of URLs, 2: make HTTP requests that return JSON 3: merge the responses (take an object in the JSON of each responses and add it in an array of the resulting JSON)
11:18:07 <tuxayo> As it's one of my first Haskell program, do you have any advice for which part start first?
11:18:26 <johnw> start with 1: read the file into a list of URLs
11:18:42 * hackagebot hsimport 0.8.1 - A command line program for extending the import list of a Haskell source file.  https://hackage.haskell.org/package/hsimport-0.8.1 (DanielTrstenjak)
11:18:46 <johnw> this problem would be a nice one for concurrency too
11:19:50 <johnw> (not the file reading part, but the HTTP requesting and then merging, which is very map/reduce-y)
11:20:16 <daniel_w> gotta love those catamorphisms
11:20:38 <johnw> daniel_w: how so?
11:21:05 <daniel_w> map-reduce is a catamorphism in two stages
11:21:09 <johnw> ah
11:21:51 <daniel_w> fold is a catamorphism over lists
11:22:13 <daniel_w> and you can combine the map and reduce stages into a single fold
11:22:22 <daniel_w> so, it's just a catamorphism
11:23:00 <johnw> i was suggesting not combining them, in order to produce a set of threads from the first fold, and then reduce over the results as they become available, such as async-pool does with its mapReduce function
11:23:39 <daniel_w> The important thing is the expressive power, rather than how it's executed.
11:24:06 <daniel_w> when you are thinking about classification
11:25:40 <tuxayo> johnw: you mean concurrency for the request
11:26:04 <johnw> yes
11:26:05 <tuxayo> johnw: oh I missed the next message
11:29:35 <tuxayo> johnw: this indeed looks totally map/reduce. Map urls to JSON and merge them into one JSON. That why I though of trying in Haskell :)
11:31:26 <ReinH> @google parallel and concurrent programming in haskell
11:31:28 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
11:31:28 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
11:31:31 <ReinH> tuxayo: suggest you start by reading this
11:32:39 <ReinH> johnw: The async package has retrieving urls in parallel as an example :)
11:32:49 <johnw> and see also http://hackage.haskell.org/package/async-pool-0.9.0/docs/Control-Concurrent-Async-Pool.html#g:10
11:33:02 <johnw> I wrote mapReduce for exactly this type of workload, and it's based on async
11:33:30 <ReinH> johnw: I didn't know you had a mapReduce package :)
11:33:42 <orion> ReinH: Is this the same thing?: community.haskell.org/~simonmar/par-tutorial.pdf
11:33:45 <johnw> it's a package for pooling async groups, which happens to have a mapReduce function within it :)
11:34:23 <ReinH> :)
11:34:40 <ReinH> orion: the book is an updated, expanded book version of the paper
11:34:41 <ertes> Myrl-saki: there is nothing wrong with using FRP for the UI, but the game logic i'd do with regular FP
11:34:43 <ReinH> both are free
11:35:11 <EvanR> for game logic i would rather use a new language
11:35:28 <EvanR> which may or may not be the same thing as "FP"
11:35:54 <ertes> Myrl-saki: as said, most of the application is a giant event scan…  note that scans have different names in different FRP frameworks…  for example reactive-banana calls it 'accum', while reflex calls it 'foldDyn' (in 0.4)
11:36:20 <ertes> EvanR: this is about a specific game (2048), which is not really FRP-friendly
11:36:39 <orion> ReinH: Is the free version of the book only available in HTML?
11:36:45 <ReinH> I think so
11:36:52 <orion> daww
11:36:53 <orion> ok
11:37:02 <ReinH> I mean, it's still free.
11:37:09 <orion> Yes, indeed.
11:37:43 <johnw> if you intend to use Haskell in future, the book is well worth it; not just for what it says about concurrency and parallelism, but also about exceptions
11:37:59 <ReinH> and its clear and direct way of writing haskell
11:38:03 <ReinH> is exemplary
11:38:03 <johnw> yes
11:38:09 <johnw> Simon is an example to follow
11:38:14 <orion> cool
11:38:41 <orion> Speaking of exceptions, what do you all think of the safe-exceptions package?
11:40:38 <lingxiao> hey all
11:40:40 <lingxiao> whats the best way to search through gigantic bytestrings?
11:40:45 <lingxiao> is this the best? https://hackage.haskell.org/package/stringsearch-0.3.6.6/docs/Data-ByteString-Search.html
11:41:57 <EvanR> lingxiao: that seems pretty good but requires strict bytestrings
11:42:00 <cocreature> lingxiao: while I don’t know anything about the specific package, using boyer-moore is generally the best option afaik
11:42:06 <ertes> lingxiao: it uses a good algorithm…  other than that, you have to benchmark
11:42:23 <EvanR> so it might not be best for gigantic, which lazy bytestrings might help with
11:42:44 <lingxiao> good point EvanR
11:42:51 <cocreature> there is a Data.ByteString.Lazy.Search module in the same package
11:42:56 <lingxiao> well tehres Data.ByteString.Lazy.Search
11:43:00 <lingxiao> oh beat me to it haha
11:43:16 <ertes> lingxiao: however, string search is the worst possible option…  not that there is always a better one, but when there is (like indexing a.k.a. "full text search"), you should use it
11:44:36 <lingxiao> ertes sorry what do you mean?
11:45:01 <lingxiao> so my use case is that I have 100+ files in a directory 
11:45:21 <lingxiao> Im using pipes to open the files one by one and counting occurences of some items, then summarizing them
11:45:26 <lingxiao> the files are .txt 
11:45:43 <cocreature> lingxiao: how often are you doing queries on the same set of files?
11:45:55 <lingxiao> it should be one pass
11:46:14 <lingxiao> i should say i hope conduit fuses things so its all one pass
11:52:57 <troydm> is there a builtin functio 'or' of type [Maybe a] -> Maybe a
11:53:33 <EvanR> :t listToMaybe . catMaybes
11:53:34 <lambdabot> [Maybe a] -> Maybe a
11:53:37 <lingxiao> how do you convert from string to lazy bytestring?
11:53:42 <lingxiao> if it makese any senes at all
11:53:50 <EvanR> with an encoder
11:53:56 <kadoban> lingxiao: You encode it, yeah.
11:54:01 <lingxiao> also cant seem to find how to convert from string  to GHC.Word.Word8 
11:54:10 <lingxiao> kadoban is there a function that does that 
11:54:16 <lingxiao> or i have to roll my own
11:54:19 <cocreature> lingxiao: if you are reading files, just read them as bytestring directly
11:54:23 <EvanR> > read "255" :: Word8
11:54:25 <lambdabot>  255
11:54:25 <lingxiao> yeah im testing right now
11:54:44 <EvanR> > read "256" :: Word8
11:54:45 <lambdabot>  0
11:54:48 <kadoban> Yeah, there's one somewhere *looks*
11:55:25 <lingxiao> ahh got it thanks
11:55:29 <lingxiao> i'll use read
11:55:42 <lingxiao> Im just fiddling around with some pure functions so its not really that important
11:56:00 <kadoban> https://www.stackage.org/haddock/lts-6.12/text-1.2.2.1/Data-Text-Lazy-Encoding.html These are what I use. I don't actually know if there's one directly from String, if not you can just use Text.pack to convert it to Text
11:56:07 <lingxiao> even more pressingly ... this is silly .. what's a clever way to write a function so that given data of this form:
11:56:19 <lingxiao> "foo\t322\nbar\t4322"
11:56:34 <lingxiao> I search the string for "foo" and output ("foo", "322")
11:56:45 <EvanR> you probably dont want to use String at all for this gigantic text search
11:56:51 <lingxiao> you know without converting the whole thing to a list of strings first
11:56:58 <lingxiao> oh sorry I meant lazy bytestring
11:57:06 <lingxiao> "string" like abstract sense of the word
11:57:14 <lingxiao> im using this lib: https://hackage.haskell.org/package/stringsearch-0.3.6.6/docs/Data-ByteString-Lazy-Search.html
11:57:25 <lingxiao> an i can use breakAfter  
11:57:25 <EvanR> that string search package probably lets you fold over the thing being searched
11:57:45 <EvanR> so you can keep counts
11:57:58 <kadoban> lingxiao: Are you only going to be doing one search on a particular input, or will you be doing multiple?
11:58:21 <lingxiao> so the assumption is that "foo" only appears once in the file
11:58:25 <lingxiao> so i only need to do one
11:58:36 <lingxiao> so i dont need to fold
11:58:54 <lingxiao> really my qestion is simpler than that. simpoly how to go from "foo\t322\nbar\t4322"  to ("foo", "322")
11:59:12 <EvanR> maybe you want an attoparsec parser 
11:59:29 <EvanR> then you can even feed it incrementally for more performance
11:59:45 <EvanR> and stop when you construct the ("foo", "322")
12:01:08 <lingxiao> hm .. does that parser handle lazy bytestrings?
12:01:22 <lingxiao> but yeah I like what you're saying ... stop when I find foo
12:01:39 <lingxiao> on the donwnside, have to learn that parser :|
12:01:40 <EvanR> if youre reading it from a file, you can manually hand it lots of strict bytestrings
12:01:56 <EvanR> this would be a kind of trivial attoparsec program
12:02:32 <lingxiao> hm ok ... thats good. but in rgards to "manually hand it" you mean I need to break into chunks using some function, then run an attoparsec program over it?
12:05:38 <lingxiao> EvanR i found this:
12:05:39 <lingxiao> https://hackage.haskell.org/package/attoparsec-0.13.0.2/docs/Data-Attoparsec-Lazy.html
12:06:00 <lingxiao> by bryan osullivan
12:06:07 <lingxiao> maybe  i'll just use that
12:06:35 <Welkin> you mean bos
12:07:00 <EvanR> maybe the lazy bytestring will work
12:07:15 <EvanR> but this is implying a lazy IO file reader which makes me uncomfortable
12:07:23 <tuxayo> ReinH: I should try to do it in parallel after having a sequential version right? (baby steps)
12:08:00 <EvanR> theres also attoparsec-hooked-up-with-pipes-or-conduit, for even more "stuff i would have to learn"
12:08:26 <Welkin> I used pipes-csv to parse csv files in a stream
12:08:43 * hackagebot yesod-auth-hashdb 1.5.1.2 - Authentication plugin for Yesod.  https://hackage.haskell.org/package/yesod-auth-hashdb-1.5.1.2 (paulrouse)
12:08:46 <Welkin> http://hackage.haskell.org/package/pipes-attoparsec
12:09:28 <Welkin> lol, this would help with what someone was working on in here yesterday http://hackage.haskell.org/package/pipes-files
12:09:36 <lingxiao> EvanR by lazy IO file reader, some thing like L.readFile is what you mean right?
12:09:43 <lingxiao> L as in Data.ByteString.Lazy as L
12:09:50 <EvanR> right
12:10:09 <lingxiao> that was me... im using conduit though
12:10:16 <lingxiao> oh why is it bad? my files are Huge
12:10:22 <EvanR> thats for like quick and dirty processing
12:10:31 <lingxiao> what does quick and dirty mean?
12:10:32 <EvanR> its not well behaved in the face of IO errors
12:10:43 <lingxiao> what kind of IO error could occur
12:10:55 <EvanR> theres something like 500 different things
12:11:10 <EvanR> some are rare, some are common like permission denied
12:11:13 <lingxiao> btw this is not to be run in production, im just doing a project for independent study and i dont want to use matlab
12:11:21 <lingxiao> or pythong
12:11:23 <lingxiao> python*
12:11:27 <EvanR> quick and dirty might work then
12:11:27 <lingxiao> freudian slip
12:11:27 <tuxayo> johnw: thanks for your advice!
12:11:33 <lingxiao> ok i'll go witht hat
12:12:14 <lingxiao> EvanR so maybe I could just use Data.ByteString.Lazy.Search then?
12:12:17 <lingxiao> also quick and dirty ...
12:12:24 <Cale> If you're only reading a small number of large files, and you don't care about being so robust in the face of I/O errors (like permissions issues, what happens if the file is removed while you're reading it, etc.), then lazy I/O is okay.
12:13:19 <lingxiao> Cale actually these files are 200 MB
12:13:30 <lingxiao> so not that big haha ... however there's 100 + of them
12:13:38 <lingxiao> so more like large number of small fiels
12:13:47 <EvanR> still using 200M of memory for something that should take almost none sucks
12:13:52 <Welkin> lingxiao: is this still the same thing you were working on yesterday?
12:13:54 <Welkin> made any progress?
12:13:55 <lingxiao> yup
12:13:59 <Cale> Yeah, so you probably want to be somewhat cautious about opening all those filehandles.
12:14:00 <EvanR> and it would put a lot of pressure on the GC when you switch files
12:14:09 <Welkin> just try whatever you think will work and get it going
12:14:15 <lingxiao> yeah i traversed the directory and unzipped all the files and can do trivial things like count num lines and add them
12:14:29 <lingxiao> Cale yeah I figured conduit would help me with that
12:14:33 <lingxiao> michaelt thought it would
12:14:40 <EvanR> did you call out to unzip to do the unzipping ;)
12:14:50 <EvanR> you could call out to grep to do this part ;)
12:14:55 <lingxiao> Evan harharhar
12:15:17 <EvanR> for more leet cred, unzip them incrementally too
12:16:09 <lingxiao> EvanR when you say: "still using 200M of memory for something that should take almost none sucks" you mean that's what lazy bytestring search will do right?
12:16:12 <lingxiao> versus attoparsec
12:16:21 <EvanR> no
12:16:45 <EvanR> i was referring to loading the whole string in memory at once with eg strict bytestring and using boyer moore
12:17:08 <lingxiao> oh no im using Data.ByteString.Lazy.Search
12:17:09 <EvanR> i know people have something like 200G of memory but still
12:17:30 <lingxiao> so i assume lazy bytestring
12:17:40 <lingxiao> I have 8G, but actually i can run this on the university's cluster
12:17:45 <EvanR> lazy bytestring makes the most sense when you are generating the data programmatically
12:17:47 <lingxiao> but then i have to deploy my code there
12:18:06 <Welkin> deploying haskell is nothing
12:18:07 <EvanR> otherwise youre stuck generating with lazy IO, which uses unsafeInterleaveIO, which we discussed already
12:18:10 <lingxiao> so suppose I do   Lazy.readFile path >>= \f -> seachForPattern pattern f
12:18:11 <Welkin> you just scp the binary
12:18:35 <lingxiao> is that generating data programatically? what does it mean to genrate data programatically?
12:18:44 * hackagebot safepath 0.1.0.0 - Safe Paths in Haskell  https://hackage.haskell.org/package/safepath-0.1.0.0 (Norfair)
12:18:45 <EvanR> generating it with a program, from a seed
12:18:48 <EvanR> no IO
12:18:55 <lingxiao> oh ok ..
12:19:01 <lingxiao> i see ..
12:19:08 <lingxiao> oh boy its really hard to reason about haskell programs
12:19:36 <EvanR> personally, i learned that its really hard to reason about almost all programs ;)
12:19:42 <EvanR> and haskell just makes it explicit
12:20:01 <lingxiao> I like people
12:20:05 <lingxiao> it's easy to reason about people
12:20:12 <lingxiao> i dont know why i program
12:20:51 <lingxiao> ok im off for a bit
12:20:56 <lingxiao> thanks everyone for your help!
12:21:20 <Welkin> that's bullshit...
12:21:29 <Welkin> no one can reason about people
12:21:43 <EvanR> thats bullofftopic
12:22:08 <EvanR> this is haskell, no one here is people
12:23:12 <rom1504> "it's easy to reason about people" hmm really ?
12:23:12 <nshepperd> you can read each file with Lazy bytestring, then evaluate the result to make sure the file is closed, except I guess who know when the finalizer will actuall be run
12:23:57 <EvanR> seems like thats just a convoluted way to do strict bytestrings
12:24:26 <nshepperd> no i mean evaluate the result of your computation
12:24:44 <nshepperd> so that the bytestring itself may be GC'd as it is used up
12:25:36 <EvanR> ah
12:26:44 <AaronFriel> Does -XApplicativeDo not work with -RebindableSyntax?
12:28:12 <AaronFriel> `x m = do { a <- m; b <- m; return (a, b) }` is translating to `join (...)` according to -ddump-ds
12:28:37 <AaronFriel> but due to the return, shouldn't it translate to "(<*>) (fmap (,) m) m"?
12:29:29 <nshepperd> is ApplicativeDo smart enough to turn 'return' into 'pure'?
12:30:03 <lyxia> https://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo suggests it is
12:31:03 <AaronFriel> even if I change "return" to "pure", I get this translation:
12:31:11 <AaronFriel> (using my own join, <*>, fmap, return), I see "x m = do { a < - m; b <- m; pure (a, b) }"  translate to: `join (<*> (fmap (\a b -> pure (a, b) m) m)` 
12:34:59 <troydm> how can I get UTC TimeLocale from time package?
12:35:32 <AaronFriel> :https://gist.github.com/AaronFriel/5d0c6b7a8bb711d9c48f6742c431d867
12:35:51 <AaronFriel> Should I file a bug?
12:36:30 <EvanR> troydm: it only comes with 1 TimeLocale, defaultTimeLocale
12:36:42 <EvanR> you either need to create your own or find another package if you want more selections
12:36:50 <nshepperd> AaronFriel: what happens if you add the type signature?
12:37:00 <troydm> EvanR: yeah well thing is I have UTCTime and i want to print it out in human readable form
12:37:08 <nshepperd> AaronFriel: with IxApplicative?
12:37:09 <troydm> EvanR: and I have no idea how to do that
12:37:19 <EvanR> troydm: the Show instance isnt readable?
12:37:36 <EvanR> for pretty printing, you use that Format module and use a format string
12:38:01 <AaronFriel> nshepperd: could not deduce IxMonad
12:38:12 <troydm> EvanR: haha silly me, it's human readable alright, thx for clariying
12:40:16 <AaronFriel> nshepperd: replacing "return" or "pure" with "ireturn" (which has only the constraint IxApplicative) does not work
12:42:33 <AaronFriel> nshepperd: is this the problem? https://github.com/ghc/ghc/blob/714bebff44076061d0a719c4eda2cfd213b7ac3d/compiler/rename/RnExpr.hs#L1784
12:44:47 <lyxia> AaronFriel: do you have your own pure defined as well?
12:44:58 <AaronFriel> lyxia, yes: pure :: IxPointed m => forall a (i :: k). a -> m i i a
12:44:58 <AaronFriel> pure = ireturn
12:45:13 <lyxia> I think it only picks up on the original pure and return
12:45:28 <AaronFriel> lyxia: according to -ddump-ds, it is picking up my pure, return, and join
12:46:15 <lyxia> I mean the desugaring of { a<- m ; b <- m ; pure (a, b) } to (,) <$> m <*> m is conditional to pure being the original one
12:46:25 <AaronFriel> nay
12:46:33 <AaronFriel> it is translating to my pure, my <*>, my fmap
12:46:37 <lyxia> I don't know RebindableSyntax but "ApplicativeDo respects RebindableSyntax: it will pick up whatever <*>, fmap, and join are in scope when RebindableSyntax is on."
12:46:43 <lyxia> pure and return are not in that list
12:47:01 <lyxia> and I don't see why they should be in fact
12:47:10 <AaronFriel> lyxia: in ghci, "let x m = do { a <- m; b <- m; return (a, b) }" translates to "My.join (My.<*> (My.fmap (\a b -> My.pure (a, b)) m))"
12:48:14 <AaronFriel> the question is, why the outer "My.join"? it's like it ALMOST got it right
12:48:16 <lyxia> is it Monad.Control.return here?
12:48:23 <nshepperd> AaronFriel: mm, yeah, looks like it just doesn't work yet
12:48:24 <lyxia> Control.Monad.return
12:48:32 <AaronFriel> lyxia: I'm using return = ireturn
12:48:34 <lyxia> It is not supposed to work with your own return
12:48:40 <AaronFriel> is it not?
12:49:28 <AaronFriel> lyxia: according to the docs "if the final statement does not have a return, then we need to use join"
12:49:52 <idob> guys, what am I doing wrong here? http://lpaste.net/new/haskell
12:50:15 <lyxia> Honestly, I don't know if it should work the way you think it should be. But I bet that's the reason it doesn't currently.
12:50:35 <Welkin> idob: your keyboard is not connected
12:50:50 <nshepperd> ApplicativeDo is pretty useless if you can't use return
12:50:54 <lyxia> AaronFriel: "if the final statement does not have a Control.Monad.return, then we need to use join"
12:51:04 <idob> Welkin: huh?
12:51:07 <nshepperd> or pure
12:51:25 <AaronFriel> lyxia: that ApplicativeDo doc is out of date anyway, or at least needs to be rewritten
12:51:29 <Welkin> idob: you did not paste anything
12:52:09 <idob> oh sorry: what am I doing wrong here? http://lpaste.net/177056
12:52:13 <AaronFriel> lyxia: The final statement can be "return" or "pure", and why would it pick up every rebindable symbol except those?
12:52:21 <idob> (thanks Welkin)
12:52:31 <AaronFriel> nshepperd: How do I search for a ticket on this or file one?
12:52:55 <lyxia> AaronFriel: how are return and pure rebindable?
12:53:01 <Welkin> idob: where can only be used in a function
12:53:02 <nshepperd> no idea, sorry. i think ghc bugs live on a trac
12:53:05 <Welkin> you want let
12:53:19 <liste> idob: is that from a haskellbook exercise?
12:53:20 <Welkin> > let x = 3 in x * 3 -- idob 
12:53:22 <lambdabot>  9
12:53:38 <idob> Welkin, yes it is
12:53:39 <AaronFriel> lyxia: RebindableSyntax works for return and pure
12:53:57 <AaronFriel> lyxia: I defined my own ">>=", "return", "pure", etc., and with that I can use "do" notation with indexed monads
12:54:01 <lyxia> What do you mean "works"? What syntax desugars to return and pure?
12:54:12 <AaronFriel> lyxia: do
12:54:29 <nshepperd> there's nothing to rebind with return and pure because you write them out explicitly
12:54:34 <idob> Welkin, is there a way to use where in the repl?
12:54:51 <lyxia> do notation has <-, which desugars to >>=, and sequencing actions desugars to >>
12:54:53 <Welkin> idob: not unless you use it in a function definition
12:55:11 <Welkin> idob: use `let ... in ...`
12:55:35 <idob> Welkin: a simple 1 line example (with where)?
12:55:37 <Welkin> > let fib a b = a : fib b (a + b) in fib 0 1
12:55:39 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:55:49 <AaronFriel> lyxia: Well I think you may be splitting hairs, but I had to turn on "RebindableSyntax" for do notation to work on indexed monads.
12:56:05 <Welkin> idob: if you want to define a function, write it in a file and :load it into ghci
12:56:18 <Welkin> or just push it into a let expression
12:56:30 <AaronFriel> lyxia: So RebindableSyntax clearly changed "Control.Monad.(>>=)" to whatever ">>=" was in scope, I feel like the same should work for -XApplicativeDo, that only makes sense.
12:56:37 <idob> Welkin. got it. Thanks!
12:57:14 <nshepperd> hmm
12:57:43 <nshepperd> AaronFriel: problem is that 'return' isn't actually syntax, it's just an ordinary function
12:58:19 <AaronFriel> nshepperd: Right, it seems -XApplicativeDo is checking for "Control.Monad.return" instead of just "return"? 
12:58:20 <nshepperd> ApplicativeDo eliminates the final 'return' from a block using the fact that m >>= return . f  =  fmap f m
12:59:16 <nshepperd> for it to work with custom 'return's, I guess it would have to take as an article of faith that that law holds for your custom return
12:59:29 <nshepperd> just on the basis that the name of the function is 'return'
13:00:02 <lyxia> I think you have a point though, that ApplicativeDo + RebindableSyntax ought to allow you to override return and pure.
13:00:25 <AaronFriel> nshepperd: I feel like, if you've redefined "return", and enabled -XRebindableSyntax and -XApplicativeDo, you are telling the compiler to take those leaps?
13:00:28 <lyxia> but RebindableSyntax alone actually has no reason to do anything with return and pure
13:00:32 <JonReed_> Hm, just wrote a simple couple of lines to test how Haskell is performing at simple 1G buffer copying vs classic `dd` and it seems that Haskell does just as good if not better. Expected it to be slower for some reason. http://lpaste.net/177058 
13:00:55 <nshepperd> this doesn't seem too unreasonable though, it is already taking that leap by assuming the law holds for ordinary Monad instances
13:01:13 <AaronFriel> lyxia, nshepperd: I do not know what the next step would be, do I have to sign up for Trac to file a ticket?
13:01:13 <nshepperd> (ie. it's entirely possible to write illegal Monad instances that break that law already)
13:01:37 <AaronFriel> is there a guide on writing a good ticket?
13:02:07 <felko> I have a question but I don't want to interrupt you, please notify me when your conversation will be over
13:02:59 <AaronFriel> felko: for me?
13:03:01 <lyxia> felko: It's fine to ask right away.
13:03:02 <nshepperd> felko: just ask the question
13:03:10 <felko> ok thanks
13:03:12 <felko> Hey, I'm trying to make an arrow which contains several functions and chooses a random one to apply to the parameter. My datatype looks like this: `newtype Seek a b = Seek [a -> b]` but I fail to define it as an Arrow instance. Can anyone help me ? Is it even possible ?
13:04:14 <AaronFriel> > "chooses a random one to apply" seems like the hardest thing to encode in the type system
13:04:15 <lambdabot>  <hint>:1:72: parse error on input ‘in’
13:04:28 <AaronFriel> thx lambdabot 
13:04:33 <mniip> id = Seek [id]
13:04:41 <felko> mniip: yeah i got that
13:04:45 <mniip> Seek f . Seek g = Seek ((.) <$> f <*> g)
13:05:00 <mniip> at least, that's the natural definition that comes to my mind
13:05:03 <felko> mniip: this is Category, not Arrow
13:05:07 <mniip> o
13:05:10 <mniip> right
13:05:14 <felko> no problem
13:05:21 * mniip checks
13:05:31 <EvanR> if you drop the "random" then maybe you can encode the concept of a choice function in the type system
13:05:37 <felko> the problem is that the `first`function from the Arrow typeclass requires a pure return value, whereas I want to return a Random-wrapped value
13:05:44 <EvanR> so it choses something
13:05:51 <mniip> I hope arr is obvious
13:06:07 <mniip> first (Seek f) = Seek (first <$> f)
13:06:29 <mniip> although
13:06:36 <mniip> sounds like it might be unlawful
13:06:52 <mniip> unless you say that 'Seek [a, b]' is the same as 'Seek [b, a]'
13:07:03 <mniip> in context of laws that say that something should equal something else
13:07:22 <felko> its not Seek [a, b] it Seek [a -> b]
13:07:32 <mniip> I'm speaking about the values
13:07:46 <mniip> @let newtype Seek a b = Seek [a -> b]
13:07:48 <lambdabot>  Defined.
13:07:50 <mniip> :t Seek [?a, ?b]
13:07:52 <lambdabot> (?a::a -> b, ?b::a -> b) => Seek a b
13:08:13 <felko> oh ok
13:08:33 <felko> I'm not sure what your definition of first does, I'll try it
13:09:22 <AaronFriel> nshepperd: should I file as "bug" or "feature request"? I mean, it's kind of a feature, but also -XApplicativeDo is not obeying the "spec", I guess?
13:09:24 <mniip> hmm
13:09:34 <mniip> I wonder how does (***) behave under that first
13:09:42 <mniip> ah
13:09:46 <mniip> it does thee right thing yes
13:10:34 <mniip> @let instance Category Seek where id = Seek [id]; Seek f . Seek g = Seek (liftA2 (.) f g)
13:10:36 <lambdabot>  Defined.
13:10:58 <mniip> @let instance Arrow Seek where arr f = Seek [f]; first (Seek f) = Seek (first <$> f)
13:11:00 <lambdabot>  Defined.
13:12:07 <mniip> > case (Seek [++"foo", ++"bar"]) *** (Seek [++"baz", ++"qux"]) of Seek fs -> ($ ("fst", "snd")) <$> fs
13:12:08 <lambdabot>      A section must be enclosed in parentheses thus: (++ "foo")    A section ...
13:12:24 <mniip> > case (Seek [(++"foo"), (++"bar")]) *** (Seek [(++"baz"), (++"qux")]) of Seek fs -> ($ ("fst", "snd")) <$> fs
13:12:26 <lambdabot>  [("fstfoo","sndbaz"),("fstbar","sndbaz"),("fstfoo","sndqux"),("fstbar","sndq...
13:12:33 <nshepperd> AaronFriel: feature i guess? probably doesn't matter
13:12:42 <mniip> so right, it does the right thing I suppose
13:12:51 <felko> wow
13:12:55 <mniip> if you don't consider the order of elements in the list important
13:13:14 <felko> No its not important
13:13:15 <felko> thats beautiful
13:13:20 <felko> thank you
13:15:00 <felko> when I code in Haskell I almost have a tear in the corner of my eye
13:15:16 <felko> it is so elegant and abstract
13:15:52 <mniip> actually
13:15:58 <mniip> I would ditch first and write *** instead
13:16:13 <felko> what would it change ?
13:16:17 <mniip> Seek f *** Seek g = Seek (liftA2 (***) f g)
13:16:31 <EvanR> "haskell was discovered rather than invented"
13:16:34 <mniip> and then
13:16:44 <mniip> I would generalize seek to arbitrary applicatives
13:16:44 <felko> yeah thats more comprehensible
13:17:07 <felko> mniip: what do you mean ? I'm relatively new to Haskell
13:17:14 <mniip> newtype App f a b = App (f (a -> b))
13:17:23 <mniip> type Seek = App []
13:18:35 <felko> mniip: doesn't it exist already ?
13:18:57 <mniip> if it does why are you using your own type? :p
13:19:08 <mniip> (honestly I don't know whether it exists)
13:19:25 <ertes> felko: is there a reason you're making an arrow to begin with?  there is nothing inherently arrowy there
13:19:50 <felko> ertes: no I'm just messing around to get familiar with arrows
13:20:13 <ertes> felko: then i suggest trying to implement a proper (i.e. non-monad) arrow
13:20:24 <ertes> felko: i can give you an exercise, if you want
13:20:29 <felko> the original purpose was to make some kind of tool for procedural generation
13:20:54 <felko> ertes: I'd love to, thank you
13:21:14 <ertes> felko: that's a rather vague purpose…  the most common advice i seem to give to newcoming haskellers is: have a problem before working on a solution =)
13:22:02 <ertes> felko: first step: understanding why we need arrows in the first place…  do you know how to implement state monads?
13:22:24 <felko> ertes: yes
13:23:05 <ertes> felko: good, now here is a slight variation:  data StateT s m a = StateT { runStateT :: s -> m (a, s), usesPut :: Bool }
13:23:14 <ReinH> mniip: if you're going to generalize an arrow combinator, shouldn't you generalize the choice of arrow too? :)
13:23:30 <ertes> felko: the idea is that usesPut should be True whenever there is a 'put' in a state action
13:23:53 <ertes> felko: write (or derive) the Functor and Applicative instances for this one
13:24:08 <troydm> how can I build RoutePath from Text?
13:24:08 <mniip> ReinH, haha yes
13:24:15 <troydm> in scotty?
13:24:16 <mniip> that makes sense
13:24:30 <ReinH> mniip: newtype App p f a b :)
13:24:30 <mniip> I wonder if such a category has a name
13:24:38 <ReinH> almost as bad as lenses
13:24:39 <ertes> felko: once you have that, this is your exercise #1: try to write a Monad instance
13:24:39 <mniip> ReinH, I'd go with s and t
13:24:43 <mniip> ha
13:24:59 <felko> ertes: how does it change from the original StateT instances ? 
13:25:04 <ReinH> mniip: every time I use Arrow, I wish you could use operators as type variables.
13:25:21 <ertes> felko: well, there is now an extra boolean field
13:25:23 <ReinH> newtype Arrow (~>) a b = Arrow a ~> b or w/e
13:25:44 <felko> ertes: mmh, don't know how it is different, but let me find out lol
13:26:07 <mniip> ReinH, haha
13:26:07 <AaronFriel> nshepperd: Does this look good? https://ghc.haskell.org/trac/ghc/ticket/12490#ticket
13:26:16 <ReinH> also profunctor, etc
13:26:26 <mniip> foo (+) x y = x + y where infixr 5 +
13:26:35 <ertes> felko: (<*>) will be the most interesting function
13:27:00 <mniip> ertes, wouldn't that just be <*> this and <> that
13:27:11 <Gurkenglas> Which stack template should I use if I want to provide a GUI?
13:27:23 <ertes> mniip: in principle, although you'd need an Or wrapper for that
13:27:29 <mniip> sure
13:27:36 <mniip> I think the wrapper is called Any though?
13:27:42 <ertes> oh, yeah
13:27:49 <mniip> not to be confused with GHC.Prim.Any
13:27:55 <ertes> indeed =)
13:30:03 <nshepperd> AaronFriel: the examples are good. I think I would describe the problem more precisely as "With RebindableSyntax, ApplicativeDo should eliminate return/pure"
13:32:25 <AaronFriel> okay! :)
13:32:35 <AaronFriel> nshepperd: As a title?
13:33:20 <Eduard_Munteanu> Does latest cabal-install do signature checking?
13:33:47 <Eduard_Munteanu> I read somewhere in the guide that you need to configure it. Why isn't it default yet?
13:34:05 <Gurkenglas> Also what library should I use to provide a GUI if gloss-built stuff won't run on my machine? (unknown GLUT entry glutInit, and the default advice of "install glut32.dll" didnt help)
13:34:38 <Eduard_Munteanu> Gurkenglas, gtk2hs?
13:36:57 <ertes> Gurkenglas: sounds like you want to render graphics rather than provide a widget UI, right?
13:37:25 <felko> ertes: struggling on that (<*>) lol, but let me find
13:37:36 <Gurkenglas> hmm https://wiki.haskell.org/Gtk2Hs/Demos/GtkGLext/hello.hs thats very imperative and low-level isnt it? gloss would have hello.hs be 'main = display white (Text "Hello")'
13:38:17 <ertes> felko: i'm sure you already have this template: StateT ff pf <*> StateT fx px = StateT _f _p
13:38:23 <ertes> (or something along the lines)
13:38:29 <felko> ertes: yeah
13:38:59 <ertes> felko: if the first state action uses 'put' (i.e. potentially changes the state), then pf will be True
13:39:20 <ertes> felko: _p should be True, if the resulting compound action uses 'put'
13:39:51 <ertes> (_f should be easy, if you have already written StateT)
13:40:52 * Eduard_Munteanu still has an Apache proxy configured to rewrite requests via https for cabal install :(
13:41:26 <ertes> felko: BTW, i assumed that you're already familiar with StateT…  if you're only familiar with State, you can implement that one instead…  it doesn't make a difference regarding Arrow
13:41:48 <ertes> data State s a = State { runState :: s -> (a, s), usesPut :: Bool }
13:41:59 <felko> I think I'm pretty comfortable with monad transformers
13:42:28 <Gurkenglas> main = display (InWindow "Hello" (10, 10) (800, 800)) white (Text "Hello") -- oh hello.hs would be this I guess
13:46:24 <ertes> Gurkenglas: do you need OpenGL?
13:46:45 <Gurkenglas> ertes, for gloss? Yes.
13:46:52 <ertes> Gurkenglas: no, for your application
13:48:03 <Gurkenglas> I'm not sure how to answer that. I just want to throw up a window with some buttons that changes based on the buttons pressed.
13:48:38 <Gurkenglas> (and sends terminal commands based on the buttons pressed. which library should I be using to run programs?)
13:48:49 <Welkin> even if it uses opengl underneath, it shouldn't matter to you
13:48:57 <Welkin> pretty much everything uses opengl underneath anyway
13:49:07 <ertes> Gurkenglas: i'm just trying to figure out whether to answer one of [gtk, gtk3, wx] or rather sdl2
13:49:18 <felko> ertes:I can't even get the _f value right I think
13:49:37 <felko> I mean, it typechecks, but it's not the only possible solution
13:49:39 <Gurkenglas> Which is the most high level?
13:49:52 <ertes> Gurkenglas: if you want to create simple buttons that respond to clicks, then gtk/gtk3/wx is most likely what you need
13:50:11 <ertes> Gurkenglas: they are all low-level, but you can wrap all of them in a layer of something high-level like FRP
13:50:44 <ertes> Gurkenglas: personally i'd use them with reflex, but due to the current lack of documentation i'm going to recommend reactive-banana instead
13:51:00 <Gurkenglas> gloss did the wrapping for me, is there something like gloss where I dont have to look at the underlying implementation, where I can just supply some callbacks or so?
13:51:08 <Welkin> I thought reactive banana was made specifically for creating UIs
13:51:24 <ertes> Gurkenglas: in fact heinrich, the author of reactive-banana, blogs a lot about how to make high-level UIs with his library
13:52:05 <Gurkenglas> Nice, gonna look at that, thanks.
13:52:31 <felko> ertes: Is it OK if there is another possible implementation of (<*>) ?
13:53:29 <ahsfhyicxv> Why does http://lpaste.net/177101 fail to typecheck?
13:53:43 <ertes> felko: there should be a few, but if your solution threads the state through the individual components, then it's correct
13:53:51 <ertes> felko: and there are two correct ways to do that
13:54:17 <ertes> felko: feel free to paste your implementation
13:54:30 <felko> i'm not sure for the _b ertes
13:54:50 <felko> i just have a boolean OR
13:54:58 <felko> but it can't be that simple
13:55:05 <ertes> felko: why not? =)
13:55:31 <ertes> if either of the components uses 'put', the composite uses 'put'
13:55:35 <lpaste> felko pasted “StateT” at http://lpaste.net/177104
13:55:53 <ertes> "either of the components uses put" = "the one component uses put, OR the other component uses put"
13:56:52 <felko> I was writing _f using "inline" notation first but it got me confused
13:56:52 <ertes> felko: that looks correct to me
13:57:03 <felko> I haven't tried it
13:57:24 <felko> I'm going to try to implement Monad
13:57:34 <ertes> personally i'd rather not use 'first' there, but that's a personal preference =)
13:58:02 <Gurkenglas> ahsfhyicxv, "z :: [(String -> x, x -> Int )]" is desugared to "z :: forall x. [(String -> x, x -> Int )]", so you're saying that the user can specify which x he wants, but in fact you only work for x = String, so that's the type you should put in there
13:58:17 <Gurkenglas> As in, call it "z :: [(String -> String, String -> Int)]"
13:58:22 <felko> ertes: I don't know, I'm writing this in my Arrow-experiencing file, it was already imported haha
13:58:42 <ertes> felko: alright, try Monad
13:59:20 <camm> Hello everyone, I want to contribute to open source Haskell projects. Could you give a suggestion before I start?
13:59:20 <felko> OK I know where the problem is
13:59:36 <ahsfhyicxv> Gurkenglas: I am using a simplified example. In the real thing x can be many different types.
13:59:55 <camm> Which projects could I contribute?
14:00:00 <ertes> felko: explain
14:01:30 <Gurkenglas> ahsfhyicxv, if it can be any x, it's fine. If it can be some xs, give different names to the different z-like functions. The functions that take a thing like z to work on it can then be of form "z :: [(String -> x, x -> Int)] -> ...". Unless you mean to say that x is going to vary within the list?
14:01:51 <ahsfhyicxv> Gurkenglas: x will vary within the list
14:02:28 <felko> ertes: I can't know if `f` (in `StateT fx b >>= f`) uses `put`
14:02:29 <ertes> ahsfhyicxv: exists x. (String -> x, x -> Int) ≃ String -> Int
14:02:52 <ertes> ahsfhyicxv: in other words: use [String -> Int]
14:03:43 <ertes> felko: exactly…  for Monad it can't be meta-information, but can only be decided after performing the state action
14:03:47 * hackagebot telegram-api 0.5.0.0 - Telegram Bot API bindings  https://hackage.haskell.org/package/telegram-api-0.5.0.0 (klappvisor)
14:04:24 <ertes> felko: it's still Applicative though, so how could one make state actions communicate with each other (without touching the state type)?
14:04:55 <ahsfhyicxv> ertes: Thanks, I can't believe I missed [String -> Int]
14:05:18 <felko> ertes: actually I've already came here for a similar problem, they told me that I couldn't make a Monad instance because my type had a "meta-information"
14:05:34 <felko> ertes: I didn't clearly understand at the time, but now I get it
14:06:13 <ertes> felko: yeah…  the point of arrows is to give you back as much of Monad as possible without crossing the "no-meta" line
14:06:45 <felko> ertes: for your question, I'd say that they could communicate through composition because that's what I came here at first, but I'm not sure
14:06:57 <ertes> imagine you had only 'get' and 'put'…  with the current version you couldn't even write 'modify'
14:07:21 <exDM69> http://www.pasteall.org/74512    I got taken by a fey mood last week and I wrote a small compiler
14:08:25 <ertes> felko: the idea is to make inputs a part of the abstraction and provide a opaque composition
14:09:20 <ertes> felko: so the type becomes:  data StateT s m a b = StateT { runStateT :: s -> a -> m (b, s), usesPut :: Bool }
14:10:02 <felko> ertes: I have to implement Functor, Aplpicative and Arrow here I guess 
14:10:07 <ertes> felko: that's a Category (as well as an Applicative), so you can compose again…  in particular you can write 'modify' in terms of 'get' and 'put'
14:22:54 <Gurkenglas> Is there a tutorial anywhere on how to actually set up reactive-banana until I have a hello-world on my screen?
14:23:02 <pkmx> How do I link to a pattern synonym in haddock if I have another Type with the same name?
14:23:08 <veggie_> so broken links on this page https://wiki.haskell.org/Example_code
14:23:14 <veggie_> so many*
14:24:16 <felko> ertes: got disconnected, sorry
14:24:28 <lpaste> felko pasted “StateT” at http://lpaste.net/177121
14:24:37 <felko> ertes: here it is
14:24:42 <Welkin> Gurkenglas: this? https://www.cs.cornell.edu/courses/cs312/2002sp/lectures/rec21.htm
14:24:45 <Welkin> er
14:24:49 <Welkin> https://github.com/no-moree-ria10/ReactiveBananaExmaples/blob/master/note.hs
14:25:49 <Gurkenglas> Welkin, that's an example of how to use the library, not how to get the library working on my machine.
14:25:55 <Welkin> Gurkenglas: here too https://wiki.haskell.org/Reactive-banana/Examples
14:26:04 <Gurkenglas> More examples!
14:26:35 <Welkin> oh
14:26:36 <Gurkenglas> (That wasn't a request, but an exclamation!)
14:26:46 <Welkin> more more!
14:26:49 <Welkin> he wants more!
14:27:45 <Welkin> what do you mean how to set it up?
14:27:52 <Welkin> just start a new project and import the library
14:30:49 <felko> ertes: so I got Arrow-StateT working, what were you trying to say when we were talking about my Seek arrow?
14:33:50 <ahsfhyicxv> ertes: What language extension so you use for exist?
14:35:21 <ahsfhyicxv> ertes: I could use String -> Int but it would result in a lot of boilerplate
14:35:39 <felko> ahsfhyicxv: I think he's afk :/
14:41:17 <felko> ping ertes
14:41:28 <Gurkenglas> Welkin, this happens if I try: http://lpaste.net/8669037246663360512 (stack solver --modify-config, stack build. I Ctrl-C'd it once in the middle of stack build, could that have broken something?)
14:42:04 <Welkin> Gurkenglas: just delete the whole project and start again
14:42:11 <osager> i have an action that i need to execute n times, and i want to pause every 50 times,how to do that ?
14:42:36 <osager> i understand that in haskell there is no loop with an counter
14:42:52 <Welkin> replicateM
14:43:07 <Welkin> for pausing, there is a way to delay
14:43:15 <Welkin> thread sleep/delay or something
14:43:29 <osager> yeah, thanks, i know the delay part
14:43:43 <osager> but how to keep track how many times have been executed
14:43:49 <osager> replicateM can do that ?
14:44:17 <Welkin> http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Concurrent.html#v:threadDelay
14:44:21 <Gurkenglas> intersperse delaythingyinio . fmap (chunksOf 50) . replicateM n
14:44:36 <Gurkenglas> Umm, the intersperse thing also in fmap
14:45:10 <Welkin> :t chunksOf
14:45:11 <lambdabot> Int -> [e] -> [[e]]
14:45:23 <Gurkenglas> Actually that's wrong, it's going to execute the actions first, then manipulate the resulting list
14:46:14 <osager> thanks, i think i've got the right direction by using replicateM
14:46:22 <Gurkenglas> sequence_ . intersperse delaythingyinio . chunksOf 50 . replicate n -- works only if the action has () output and you dont need any
14:47:44 <Gurkenglas> sequence . zipWith (>>) (cycle $ delay : replicate 49 (return ())) . replicate n -- if you need the results from the repeated action
14:48:06 <Gurkenglas> (Where delay has type "IO ()")
14:52:29 <ertes> felko: looks correct to me
14:52:54 <Gurkenglas> Welkin, copied only the Main.hs and the .cabal, same thing happened
14:53:00 <felko> ertes: at least it typechecks
14:53:03 <ertes> felko: what i'm trying to say is that you shouldn't use Arrow, unless you have an actual non-monad arrow
14:53:27 <felko> ertes: so I should make an Arrow only when I fail to write a Monad instance ?
14:53:33 <ertes> ahsfhyicxv: it's pseudo-syntax, no extension
14:54:07 <ertes> Gurkenglas: i'm pretty sure heinrich's blog has a post like that, but couldn't link to one right away…  there is also an extensive page in the haskellwiki
14:56:28 <ahsfhyicxv> ertes: So there is no way to write that type in haskell?
14:56:44 <ertes> Gurkenglas: i think wx has always paid attention to being reasonably easy to set up on most platforms, including windows, but i've never tried it myself
14:57:06 <ertes> ahsfhyicxv: there is the ExistentialQuantification extension, but it doesn't give you first-class existentials like that
14:57:24 <ertes> you always need a wrapper type in GHC haskell
14:57:26 <Gurkenglas> ahsfhyicxv, you can define a combinator ((String -> z), (z -> Int)) -> String -> Int
14:57:36 <Gurkenglas> (Because that one's gonna work regardless of the z)
14:57:59 <Gurkenglas> ertes, one of these? https://wiki.haskell.org/Reactive-banana https://wiki.haskell.org/FRP_explanation_using_reactive-banana none of those explain the actual setup
15:05:14 <ahsfhyicxv> Ok, I think I figured it out
15:05:19 <ahsfhyicxv> thanks
15:08:27 <orion> What role does the STG machine play in GHC and the RTS?
15:09:26 <orion> Does GHC create a STG machine data structure based on the Haskell code? Is the RTS is responsible for reading that structure and executing it?
15:12:06 <ReinH> orion: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts
15:12:12 <orion> ReinH: Thanks
15:12:41 <felko> ertes: sorry I was eating
15:12:54 <felko> ertes: I must leave, but thank you for the explanation
15:13:03 <ReinH> orion: also https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode
15:13:04 <felko> it makes more sense now
15:13:59 <ReinH> basically: Haskell becomes Core becomes STG becomes C-- becomes machine code
15:18:18 <veggie_> how do i resolve 'failed to load interface 'Text.Regex.Posix'
15:19:04 <orion> ReinH: When people talk about "evaluating" expressions. Where does that happen? In the compiler or in the runtime?
15:19:26 <ReinH> evaluation happens during execution
15:20:10 <ReinH> @where lazy
15:20:10 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
15:20:14 <ReinH> is a good explanation of evaluation
15:20:23 <mniip> evaluation of expressions is a model
15:20:30 <ReinH> that too
15:20:55 <mniip> in GHC code is compiled to machine code, so the line between "RTS" and "your code" is very thin
15:21:18 <glguy> veggie_: Maybe paste the full error message and command to http://lpaste.net
15:23:22 <veggie_> glguy: site says down for maintenance. but it's just the example code from here https://wiki.haskell.org/Simple_Unix_tools
15:23:33 <veggie_> error:     Failed to load interface for ‘Text.Regex.Posix’
15:23:52 <mniip> do you have the necessary packages installed
15:24:28 <veggie_> probably not, how do i install them?
15:24:54 <EvanR> the compiler cant usually evaluate anything because it might infinite loops
15:26:23 <ReinH> well, also because the compiler doesn't know what values will be at runtime.
15:26:44 <EvanR> if its from IO
15:26:52 <ReinH> everything is from IO
15:27:00 <ReinH> main :: IO ()
15:27:01 * EvanR refutes that
15:27:21 <glguy> veggie_: You'll need to: cabal install regex-posix
15:27:21 <mniip> explain GHCi!
15:27:35 <EvanR> top level foo = bar 5
15:27:45 <ReinH> Ok, now use it without doing IO.
15:27:52 <veggie_> glguy: thanks
15:27:54 <glguy> veggie_: This wiki page is old, to load you'll have to add this to the top of your source file: {-# Language FlexibleContexts #-}
15:28:10 <EvanR>  > foo
15:28:14 <glguy> veggie_: I don't know if this ever works, but it certainly doesn't now: $ cat file.txt | ghc -e 'wc_l' UnixTools.hs
15:28:26 <ReinH> And I'm making a general statement, so specific examples to the contrary do not refute it
15:28:35 <veggie_> glguy: are there newer examples that would be better to learn from?
15:28:39 <ReinH> it's enough that not *all* values are known, not that some values *are* known
15:28:50 * hackagebot generic-random 0.2.0.0 - Generic random generators  https://hackage.haskell.org/package/generic-random-0.2.0.0 (lyxia)
15:28:51 <mniip> glguy, I think that's supposed to be
15:28:55 <glguy> That tries to print the function wc_l rather than run the whole thing with wc_l as the name, which is what the program seems to try
15:28:58 <mniip> ghc -o wc_l UnixTools.hs
15:29:06 <EvanR> there are special cases where the compiler does precompute some answers, constant folding etc
15:29:12 <glguy> mniip: That wouldn't really explain the cat or |
15:29:16 <ReinH> Yes, and we call those things "optimizations".
15:29:18 <mniip> oh
15:29:21 <EvanR> but if we had total functions it could do more
15:29:41 <mniip> you would need -e 'interact wc_l'
15:30:27 <glguy> veggie_: There's a bunch of stuff linked on https://wiki.haskell.org/Learning_Haskell
15:32:20 <ReinH> My claim is that there exist expressions whose value cannot be known at compile-time. Your claim that there exist expressions whose value *can* be known at compile-time does not refute my claim.
15:32:48 <EvanR> actually i thought the original claim was "some evaluation occurs at runtime" which i agree with ;)
15:33:13 <ReinH> Some evaluation *must* occur at runtime, which is an equivalent claim.
15:33:20 <EvanR> but the value of an IO expression is known at compile time, technically
15:33:43 <EvanR> er, main :: IO ()
15:33:50 <ReinH> That was not my claim.
15:36:00 <johnw> if you see "if x < 10 then foo else bar", then "x < 10" must be evaluated at runtime
15:36:21 <johnw> the parsing of the if/then/else construction into some that the runtime can evaluate does happen at compile-time
15:36:31 <johnw> and might be reduced to some equivalent operation during optimization
15:36:42 <EvanR> if that was in the context of let x = 5 in _
15:37:11 <ReinH> Yes, no one is disputing that some values can be known at compile-time
15:37:16 <ReinH> it is also a non-sequitur
15:38:25 <EvanR> stop agreeing!
15:40:48 <ReinH> If I claim that some integers are even, your claim that some integers are odd does not refute my claim.
15:41:06 <EvanR> if there was any refutation it was about "everything comes from IO"
15:41:24 <ReinH> That was also not my claim.
15:41:37 * EvanR edits own logs so we agree
15:41:41 <ReinH> My claim was that you can't execute a Haskell program without executing an IO action.
15:48:50 * hackagebot hsrelp 0.1.0.0 - RELP (Reliable Event Logging Protocol) server implementation  https://hackage.haskell.org/package/hsrelp-0.1.0.0 (verrens)
16:04:50 <ertes> Gurkenglas: i think, they all assume that you know how to create haskell development environments
16:07:00 <linduxed> guys, i've messed up some indentation somewhere, or something to that effect
16:07:04 <linduxed> i just don't know where
16:07:06 <linduxed> https://gist.github.com/linduxed/ec8df781108547b5282cf0fda2b71257
16:07:15 <linduxed> it complains on line 28
16:07:26 <Gurkenglas> missing do in 20
16:07:33 <linduxed> ooooh
16:07:37 <linduxed> i thought that was redundant
16:07:42 <sm> Gurkenglas: how about fltks
16:07:44 <linduxed> thanks, i'll try that!
16:07:50 <sm> fltkhs
16:08:06 <Gurkenglas> "Low level bindings" uh oh
16:08:24 <sm> seems to be the easiest to setup GUI framework
16:08:52 <sm> comes with many examples
16:08:57 <ertes> setting up GUI frameworks is consistently difficult on windows
16:09:21 <linduxed> Gurkenglas: it worked!
16:10:00 <sm> here's fltkhs setup on windows (fits on one screen!) : http://hackage.haskell.org/package/fltkhs-0.4.0.9/docs/Graphics-UI-FLTK-LowLevel-FLTKHS.html#g:7
16:10:36 <sm> oops, no it doesn't. Still, it is documented
16:10:51 <Gurkenglas> I would make a CLI instead of a GUI but the whole point of what Im doing here is to make an automatic CLI -> GUI thing :D
16:10:54 <lingxiao> hey guys
16:11:06 <sm> Gurkenglas: what does that mean ?
16:11:13 <lingxiao> so im writting an attoparsec parser that scans a bytestring file and look for some word
16:11:23 <sm> converting generic CLIs to GUIs ?
16:11:28 <lingxiao> the format of the file is such that each word only appears once
16:11:50 <lingxiao> Im asking which of the dozens of functions I should use here:
16:11:53 <lingxiao> https://hackage.haskell.org/package/attoparsec-0.13.0.2/docs/Data-Attoparsec-ByteString.html
16:12:02 <Gurkenglas> Ya, parse the --help and/or man and turn it into buttons and such
16:12:10 <lingxiao> so im thinking using takeWhile to skip over all the words that's not my word
16:12:27 <lingxiao> or takeWhile1
16:12:42 <Gurkenglas> (so I dont have to interact with terminals so much)
16:13:26 <sm> Gurkenglas: nice. Those exist in other languages, don't they
16:14:03 <Gurkenglas> never heard of that. I guess I dont need to make it then. Name?
16:15:34 <sm> Gurkenglas: https://github.com/chriskiehl/Gooey is the one I just found
16:16:06 <Gurkenglas> Huh, why would it depend on which language the command line program is written in
16:16:13 <sm> I feel there are others
16:16:31 <ertes> Gurkenglas: --help texts are not in any standard format
16:16:53 <Gurkenglas> Oh. Well that sucks I guess.
16:17:11 <ertes> even "--help" is not a standard
16:17:41 <Gurkenglas> In the sense of this whole project just via theory went in the bin :D
16:18:18 <sm> better now than later :)
16:18:29 <ertes> that would have been a rather laborious job anyway ;)
16:18:47 <sm> but don't give up.. time to PIVOT!
16:18:49 <Gurkenglas> hah, writing an AI that can understand those sounds easier at this point than standardizing everyone
16:19:08 <Gurkenglas> this should have been done about 4 years before the computer was invented
16:19:24 <ertes> though you make the nature of the thing more experimental and employ machine learning instead of pattern-matching =)
16:19:24 <Gurkenglas> lambda calculus, --help standard.
16:19:40 <sm> these seems related: http://emboss.sourceforge.net/interfaces/
16:20:15 <sm> well. A lot of this stuff seems ancient, bioinformatics related, and scary
16:20:50 <lingxiao> why is that when i do  m = read "hello" :: word8
16:21:01 <lingxiao> :: Word8  i mean
16:21:03 <lingxiao> i get error:   *** Exception: Prelude.read: no parse 
16:21:20 <ertes> lingxiao: try:  read "123" :: Word8
16:21:33 <lingxiao> that works
16:21:35 <lingxiao> hmm ..
16:21:47 <lingxiao> read is the only way I can convert string to Word8 right?
16:21:49 <ertes> lingxiao: what Word8 value did you expect?
16:21:53 <Gurkenglas> Word8 is numbers, not words
16:22:12 <Koterpillar> lingxiao: readMaybe?
16:22:16 <lingxiao> yeah is 8 bit unsigned int right?
16:22:26 <lingxiao> so why does takeWhile have this signature: takeWhile :: (Word8 -> Bool) -> Parser ByteString
16:22:43 <mniip> what's wrong with it
16:22:57 <Gurkenglas> You've got the wrong takeWhile, look at another entry in the hoogle/hayoo result list
16:23:00 <lingxiao> or say this: takeTill :: (Word8 -> Bool) -> Parser ByteString
16:23:13 <lingxiao> say i want to takeTill (\w -> w /= "hello")
16:23:23 <lingxiao> or something to that effect, I need to convert "hello" to Word8 ...
16:23:32 <geekosaur> because a ByteString is made up of 8=bit words, and treating those as "characters" requires you to determine what encoding you want
16:23:46 <ertes> lingxiao: how?  what number do you expect "hello" to convert to?
16:23:53 <ertes> 15?  100?
16:23:57 <Gurkenglas> Ah, you have a bytestring like "asdasdhello5" and want to extract the "asdasd"?
16:23:59 <lingxiao> yeah it makes no sense ..
16:24:26 <lingxiao> no my file is like: "hello\t120\nadele\t49292"
16:24:44 <lingxiao> and I want to extract  say ... ("adele", "49292")
16:24:57 <Gurkenglas> Can there be anything in front of hello?
16:25:06 <lingxiao> so i need to parse until i see "adele", and then grab other stuff for example
16:25:18 <lingxiao> there might be, or what I'm looking for might be the very fist item
16:25:23 <geekosaur> let's try this: the bytestring corresponding to "hello" in most encodings is equivalent to [104,101,108,108,111] :: [Word8]
16:25:38 <ertes> lingxiao: note that there is the cassava library that reads CSV and allows you to change the delimiter to '\t'
16:26:20 <lingxiao> so mine is a text file ..
16:26:22 <lingxiao> .txt
16:26:33 <Gurkenglas> If your whole program looks like that, use parsers. If you just need a quick thing that works, convert it to string and use something like 'head . tail . dropWhile (/="adele") . words'
16:26:54 <lingxiao> well it'd be nice if performance is good
16:27:02 <lingxiao> so my files are about 200MB each, and theres 100+ of them
16:27:14 <lingxiao> I need to scan through all 100 at least once
16:27:35 <Gurkenglas> Oh hey Bytestring has words too. http://hayoo.fh-wedel.de/?query=words
16:28:18 <lingxiao> Gurkenglas sorry I dont see it?
16:28:29 <lingxiao> oh you mean ... BytString -> [ByteString] ?
16:28:32 <Gurkenglas> ya
16:29:02 <Gurkenglas> And maybe you want to use something other than "head . tail" if you dont want to become confused if the file does not contain what you're looking for
16:29:25 <geekosaur> you know, if you are working with textual data, maybe you want Text instead of ByteString
16:29:54 <ertes> lingxiao: quick-n-dirty solution (if you just need it once quickly): read to lazy Text (use Data.Text.Lazy.IO.readFile), then use 'lines' and 'words' (or 'break'), finally use Data.Text.Read
16:30:06 <lingxiao> :( i already wrote a bunch of conduit stuff for bytestring
16:30:33 <geekosaur> ByteString is not for textual data. it's for octet strings like you'd get from a network. which is why it wants you to use Word8 instead of Char
16:30:36 <lingxiao> there is also a use case where I might open one file thats several GB and scan that
16:30:46 <lingxiao> oh boy I really didnt know this :(
16:30:51 <lingxiao> thanks for clueing me in though
16:30:58 <Gurkenglas> geekosaur, so IsString ByteString is a travesty?
16:31:02 <Sgeo_> Is Rust's specializations more like OverloadedInstances or IncoherentInstances?
16:31:11 <lingxiao> ok so my use case ... worse case:   100 + files of several GB each
16:31:12 <ertes> lingxiao: if you need a stable approach (no lazy I/O), i would do the splitting through your streaming abstraction of choice
16:31:17 <Sgeo_> Either way I don't know how to defeat a limitation of Rust specialization as it currently exists
16:31:21 <geekosaur> it's got the same flaws as Data.ByteString.Char8
16:31:25 * Sgeo_ doesn't actually know what IncoherentInstances does
16:31:26 <lingxiao> what's the appropriate format
16:31:29 <lingxiao> assuming text file
16:31:36 <lingxiao> all my stuff is natrual language processing setting
16:31:44 <geekosaur> i.e. $DEITY help you if any codepoint > 255
16:31:46 <lingxiao> so wall street jouranl articles, yelp reviews ... google ngrams
16:32:37 <ertes> lingxiao: if the data is in any well known format, you're already done
16:32:45 <ertes> there is cassava for CSV, aeson for JSON, etc.
16:32:46 <lingxiao> so geekosaur under my setting : 100 + files of GB size each .. is Text still a good option?
16:32:49 <geekosaur> Sgeo_, IncoherentInstances means ghc should try to guess what you mean when multiple instances can match. there is no guarantee it will guess what you intended
16:32:55 <lingxiao> right now Im using lazy bytestring
16:33:46 <ertes> lingxiao: ByteString is roughly twice as fast, but it shouldn't matter…  if the string type is your bottleneck, you're already in trouble
16:33:48 <geekosaur> lazy Text is probably what you want, unless you are absolutely certain you won't ever have to deal with codepoints > 127
16:33:51 <lingxiao> there's alos  Data.Text.Lazy.Encoding 
16:33:52 * hackagebot hs-watchman 0.0.0.1 - Client library for Facebook's Watchman tool  https://hackage.haskell.org/package/hs-watchman-0.0.0.1 (BitConnor)
16:33:53 <ertes> lingxiao: so use Text
16:34:04 <Sgeo_> In Rust, currently overlaps are resolved by going with the more specific one,and if there is no more specific one it's invalid. There was suggestion of allowing it if there's one that covers the overlap, but that's not there yet, but I want it
16:34:08 <Sgeo_> For my HList stuff
16:34:18 <lingxiao> ertes could you elaborate on this: if the string type is your bottleneck, you're already in trouble
16:34:28 <lingxiao> actually i havnt bench marked it yet
16:34:50 <geekosaur> so, "more specific" is roughly OverlappingInstances, and IncoherentInstances allows you to disable the "it's invalid" part
16:35:00 <Sgeo_> Ah
16:35:05 <ertes> lingxiao: you would want I/O or meaningful computation (e.g. a learning algorithm) to be your bottleneck
16:35:10 <ertes> not the string type
16:35:16 <lingxiao> ah i see
16:35:22 <lingxiao> ok i'll switch over to text then 
16:35:23 <lingxiao> oh boy 
16:35:25 <Sgeo_> geekosaur, did oleg's original HList require Incoherent?
16:35:42 <ertes> lingxiao: Text has everything you need on board, including a number parser
16:35:50 <lingxiao> speaking of which, could I post a module here and have you gusy code smell it?
16:36:11 <geekosaur> I don't recall specifically but it would not surprise me; ghc's type system was not as advanced back then, and if you are very careful you can actually use IncoherentInstances semi-sanely
16:36:14 <lingxiao> so here's ConduitLib.hs:    http://lpaste.net/177163
16:36:29 <lingxiao> and Core.hs:  http://lpaste.net/177164
16:36:35 <lingxiao> so ConduitLib import Core
16:36:53 <lingxiao> it would be nice if my ConduitLib is agnostic to type of function
16:37:00 <lingxiao> for example I have bytestring peppered everywhere
16:37:14 <geekosaur> (if all the instances are defined in the same file and multiple instances match and cannot be disambiguated, iirc IncoherentInstances will pick the first one defined that matches. all bets are off if there are instances defined in other source files though)
16:38:05 <geekosaur> lingxiao, there is actually a package for that: mono-traversable. the downside of it is that if it can't figure out what you are doing, it can degrade to slow String operations
16:38:19 <lingxiao> geekosaur sorry package for what?
16:38:23 <geekosaur> ...except potentially with dictionary lookup overhead
16:38:28 <lingxiao> ertes ok commited to Text now
16:38:39 <Welkin> lol, trying to parse a bytestring
16:38:45 <Sgeo_> Even just Overlapping kills parametricity right?
16:38:45 <geekosaur> package for being String vs. ByteString vs. Text (and strict vs. lazy versions of the latter two) agnostic
16:39:27 <ertes> lingxiao: is this a quick-n-dirty thing?
16:39:35 <lingxiao> not sure yet haha
16:39:46 <Gurkenglas> lingxiao, idc doesn't look right - dont you just want awaitForever yield?
16:39:49 <geekosaur> Sgeo_, I think so, yes
16:39:52 <lingxiao> it needs to be done by Tuesday... I've already spent 3 days on it .. mostly fighting conduit
16:40:30 <lingxiao> Gurkenglas i think if i drop the idc after yield the whole conduit just terminates after yielding xs
16:40:40 <lingxiao> actually that one is not strictly necessary, im going to get rid of it
16:40:47 <ertes> lingxiao: you can get away with the most basic solution and still get good performance, but it doesn't scale well (in terms of code complexity)
16:41:00 <lingxiao> ertes basic solution wrt to what?
16:41:18 <lingxiao> Gurkenglas any other smells? mostly having to do with too many dependicies, bad abstraction etc
16:41:25 <lingxiao> maybe silencing errros ...
16:41:40 <ertes> lingxiao: converting gigabytes of string/number pairs from disk to a stream of tuples you can process
16:42:12 <lingxiao> ertes sorry why does that not scale well wrt code complexity?
16:42:30 <lingxiao> like .. how does it make future code more complex?
16:43:08 <toogley> i'm not sure if i understand that "Integral" thing, haskell provides correctly. I guess that's completly sth different as mathematical integration? I'm not sure..
16:43:18 <ertes> lingxiao: you can batch-read a bunch of files one by one…  you couldn't even sensibly concatenate the resulting strings…  anything more complicated, and your code will blow up
16:43:33 <ertes> if you know that you'll need more, go for the streaming approach right away
16:43:45 <toogley> completely*
16:43:53 <lingxiao> ertes wait so confused .. i am in the streaming approach right now I thought?
16:44:03 <ertes> lingxiao: yes, you are
16:44:11 <ertes> conduit = streaming
16:44:13 <Gurkenglas> toogley yep http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integral "Integral numbers, supporting integer division."
16:45:01 <lingxiao> yeah so my plan is to open 100+ files using conduit, which i presume open one at a time and close the handle when done, then for each file it is as lazy text
16:45:19 <lingxiao> then i use some attoparsec combinator to parse the file looking for my ("hello", 23) pair
16:45:27 <lingxiao> then go formo there
16:45:31 <lingxiao> that's streaming right?
16:45:34 <ertes> lingxiao: it's just space-separated like that?
16:45:45 <lingxiao> yeah ... "hello\t4222\n"
16:45:48 <lingxiao> is each line
16:45:50 <ertes> lingxiao: yeah, that's streaming
16:46:01 <lingxiao> but then I would also have:  "hello world stuff\t4322233\n"
16:46:08 <lingxiao> what would kill the streaming
16:46:30 <toogley> Gurkenglas: ah, thx
16:46:55 <ertes> nothing really…  one potential problem to watch out for, especially with conduit, is: if you do the splitting through a Conduit, your individual lines and fields should not get too long
16:47:19 <ertes> "some very long text\r12345\n"
16:48:41 <lingxiao> ertes oh woa why is that?
16:50:42 <ertes> lingxiao: if you use conduit to split into lines, most likely your individual lines will be read into memory in full
16:52:27 <lingxiao> oh i see .. wait but im parsing the lazy text stream though?
16:53:00 <lingxiao> so Im nt doing some like ...  readIntoText filePath >>=\f -> func <$> (lines f)
16:53:14 <lingxiao> it's just readIntoText filePath >>=\f -> parse f
16:53:22 <lingxiao> that is lazy right  -----^
16:59:44 <lingxiao> is there a conduit `sourceFile` that opens a lazy bytestirng
16:59:47 <lingxiao> bytestirng*
17:01:58 <lingxiao> funny it says: Stream the contents of a file as binary data.
17:02:03 <lingxiao> does stream mean lazy?
17:02:08 <lingxiao> because ByteString is not 
17:16:47 <Gurkenglas> Which recursion scheme corresponds to "\f (Fix xs) -> f . Fix . fmap f xs"?
17:17:25 <Gurkenglas> umm, replace those . by $.
17:17:31 <Gurkenglas> "." by "$".
17:26:26 <vctr> anyone use ghcjs / ghc within the same project?
17:27:05 <vctr> wondering how people go about organizing the physical directory/file structure of a project & stack configuration like that..
17:27:57 <ashishnegi> hi.. Is there in memory Handle in Haskell for simulating socket while testing ?
17:28:23 <ashishnegi> i need that write and read do not interfere with each other on this handle.
17:29:01 <ashishnegi> http://hackage.haskell.org/package/knob has only single ByteString buffer.. so read and write interfere.
17:31:29 <blubblub> i'm following the learn you book and am in the type section using ghci to define a function signature
17:32:02 <blubblub> i define this:
17:32:10 <blubblub> removeNonUppercase :: [Char] -> [Char]
17:32:20 <blubblub> and ghci tells me that removeNonUppercase isn't in scope
17:32:38 <blubblub> but learn you just shortly above says to use ghci,... i'm skeptical that there's a version mismatch,... i'm confused
17:32:49 <Koterpillar> blubblub: http://stackoverflow.com/questions/3093133/how-to-provide-explicit-type-declarations-for-functions-when-using-ghci
17:33:02 <Koterpillar> blubblub: don't use ghci for more than one line
17:33:11 <blubblub> oh?
17:33:19 <Koterpillar> ...of declarations
17:33:32 <blubblub> is this a wart or is there a good reason for this
17:33:46 <Koterpillar> it's harder :)
17:33:49 <blubblub> i was excited about being able to have an interpreter to use alongside my running code
17:34:00 <Koterpillar> you can load your code inside ghci
17:34:23 <blubblub> right but if i set up a system, i was hoping that i'd get scripting for free...
17:34:30 <Koterpillar> you get scripting
17:34:38 <Koterpillar> ghci yourfile.hs
17:35:39 <hydraz> runghc/runhaskell is also a thing
17:36:26 <geekosaur> ghci prompt is not like code in a file. you can do things but (at least before 8.0) you need to use `let` to define things (let removeNonUppercase :: [Char] -> [Char]; removeNonUppercase = ...)
17:36:32 <geekosaur> and all on one line
17:36:37 <vctr> Koterpillar blubblub eh don't quite agree... you can do more ambitious things with ghci
17:36:49 <lingxiao> hey all
17:36:50 <geekosaur> ghci's more like a desk calculator using haskell expressions
17:36:51 <vctr> but i think the mainstream hasn't embraced it yet
17:37:00 <lingxiao> does Haskell have a mixed integer linear programming solver?
17:37:16 <Koterpillar> vctr: yes, but you need to know what are you doing
17:37:17 <vctr> for example, with rapid or halive you can keep state between code reloadings
17:37:35 <Koterpillar> vctr: in the context of "I'm reading LYAH" I don't think that applies
17:37:44 <vctr> with a bit of elisp hacking, you can do "send code from source to repl" ala python or R workflows
17:38:33 <vctr> Koterpillar yeah but i don't want to prematurely discourage someone who's used to repl-driven-development in python or javascript saying that's not feasible in haskell 
17:38:48 <Koterpillar> vctr: agreed
17:40:04 <archaephyrryx> I am having some trouble with ghc 7.8.3 -> 7.10.3 compatability issues
17:40:25 <Koterpillar> archaephyrryx: please provide details
17:40:48 <archaephyrryx> specifically with regard to "Illegal polymorphic or qualified type" on (Integral a => a)
17:40:59 <archaephyrryx> it works when i compile it with 7.8.3, but not with 7.10.3
17:41:12 <vctr> will say the ghci/ghc differences is tricky for beginners unfortunately. I'm beginner-intermediate-ish and I was bitten by the type ambiguity differences between ghci and ghc just today.
17:41:18 <geekosaur> @paste actual code and full error
17:41:18 <lambdabot> Haskell pastebin: http://lpaste.net/
17:41:39 <glguy> archaephyrryx: It was probably a bug that GHC 7.8.3 accepted the code. It'll help to see the code
17:41:52 <geekosaur> vctr, :seti -XNoExtendedDefaultRules
17:42:44 <geekosaur> like I said, best to think of it as a desk calculator. its defaults are better suited for that use than for testing things you'd put in an actual program. (but you can override that one, at least)
17:43:24 <archaephyrryx> http://lpaste.net/177182
17:43:43 <archaephyrryx> on line 52
17:44:19 <lpaste> archaephyrryx revised “No title”: “Generic.hs” at http://lpaste.net/177182
17:44:51 <vctr> geekosaur i'm doing some data science analysis stuff
17:45:13 <vctr> have to use a repl for that, so i tend to push it's use cases more than most i think
17:47:01 <glguy> archaephyrryx: You can make a type family instance that only matches things that are an instance of a typeclass
17:47:04 <glguy> can't**
17:47:31 <archaephyrryx> ah
17:48:05 <archaephyrryx> so, does 7.8.3 make anything of this?
17:48:49 <archaephyrryx> or is it merely a bug that it accepts this
17:49:04 <glguy> archaephyrryx: It's a bug that it accepted it, I don't know what the behavior it used was
17:49:07 <geekosaur> 7.8.3 did have some bugs in that area iirc
17:50:01 <archaephyrryx> afaik, 'reveal 5' doesn't take the (Integral a => a) branch, and just defaults to "_"
17:50:15 <archaephyrryx> So it doesn't even do anything
17:50:30 <geekosaur> yeh, there's no machinery to check those constraints
17:50:36 <geekosaur> so it just fails to match in all cases
17:50:50 <archaephyrryx> I guess it's just an unpopulated type, which 7.8.3 failed to notice was illegal
17:50:56 <archaephyrryx> so it's actually useless either way
17:51:07 <archaephyrryx> :P
17:51:37 <archaephyrryx> I assume the same is true of (Show a => a)
17:52:06 <archaephyrryx> since there isn't much inherent difference between typeclasses (though Num is a bit weird)
17:53:51 <archaephyrryx> thanks for the hel[p
17:54:18 <archaephyrryx> glguy: going to fix my code now
17:58:54 * hackagebot hsrelp 0.1.0.1 - RELP (Reliable Event Logging Protocol) server implementation  https://hackage.haskell.org/package/hsrelp-0.1.0.1 (verrens)
18:02:15 <toogley> hey. i'm having trouble to define the function isPrime here https://paste.fedoraproject.org/408651/12224101/ . which essentially should implement the sieve of eratosthenes. i think i understand what is meant by "Not in scope: ‘x’"  generally (by reading the 'not in scope' explanation of http://book.realworldhaskell.org/read/getting-started.html ) but i have trouble to understand that here, because i
18:02:16 <toogley> defined x in 'isPrime x' as the integer argument. secondly, regarding "Illegal type signature": i don't get why this appears because my book gives as a example a very similar type signature : "bmiTell :: Double -> String", so i don't think my intension is generally false, right?
18:02:35 <eitanChatav> is it possible to turn this into a proper `Category` instance for type-level lists?
18:02:37 <eitanChatav> http://lpaste.net/177185
18:03:01 <Koterpillar> toogley: indentation; line 2 must not be indented
18:03:35 <toogley> Koterpillar: ah, lol. thanks. didn't thought it would be that simple :D 
18:03:52 <eitanChatav> @toogley: replace "fail" with `error "fail"`
18:03:52 <lambdabot> Unknown command, try @list
18:04:05 <eitanChatav> toogley: replace "fail" with `error "fail"`
18:04:23 <toogley> eitanChatav: thx
18:10:16 <saylu> Hey guys! I've been trying to source good research papers about Haskell, functional programming, or even general computer science which would be useful to a Haskell programmer. I'd love to hear recommendations of your favorite research papers if you have some to share!
18:10:19 <toogley> Koterpillar: eitanChatav just to understand the error message in this context: the haskell compiler had read "x" as a function (wich was of course not defined and therefore is out of scope), right?
18:10:21 <saylu> I've put up a thread about it here
18:10:22 <saylu> https://www.reddit.com/r/haskell/comments/4xr4q8/request_your_favorite_research_papers/
18:10:40 <Koterpillar> toogley: lines 1 and 2 were glued together
18:10:40 <eitanChatav> one more try :-) is it possible to turn this into a proper `Category` instance for type-level lists? http://lpaste.net/177185
18:11:18 <Koterpillar> toogley: so x was treated as a type level variable (and didn't make sense) and not as a parameter, which indeed wasn't defined
18:11:34 <toogley> kadoban: ah, thx.
18:12:01 <eitanChatav> toogley: yes, it parsed it wrong as Koterpillar said, but when you indent there will still be an error because "fail" is a `String` not a `Bool`
18:14:39 <lifter> How can I know if I should use the StrictData or Strict extensions? Do I need to profile to tell if it's worth it?
18:17:59 <toogley> eitanChatav: aah, okay. thx again :)
18:20:25 <toogley> regarding the sieve of eratosthenes/ https://paste.fedoraproject.org/408652/71223821/ again. what haskell thing can i use to implement sth like: "for every Integer x and n, mark x true and x*n false" i know, i could repeat the same pattern i've used in that file for more values of x but i don't want to repeat myself.
18:23:14 <Welkin> toogley: filter out the ones you don't want
18:24:03 <Welkin> toogley: you should remove the `otherwise = error ...` branch
18:24:06 <Welkin> that is not a good idea
18:26:06 <toogley> or asked differently (i have an idea how to do it :D) how can i define a variable n in a where clause as an Integer?https://paste.fedoraproject.org/408653/12242991/ here n is of course a list, which fails. but i don't how to descibe n as a plain integer. 
18:26:49 <geekosaur> the same way you do it at the top level but indented under the where
18:26:51 <toogley> Welkin: hm. okay, i'll look into it. thanks
18:27:32 <Welkin> toogley: list comprehensions come in useful for sieves
18:27:45 <lpaste> geekosaur pasted “isPrime” at http://lpaste.net/177187
18:28:04 <geekosaur> h, wrong questionm sigh
18:28:18 <Welkin> lol geekosaur 
18:28:30 <toogley> geekosaur: aah, thanks.
18:28:45 <Welkin> toogley: but `n` :: [Integer] there
18:29:36 <geekosaur> yeh, I tried to interpret from the restatement and then went back to the original staement and "oh"
18:29:38 <geekosaur> sigh
18:33:23 <toogley> hm, geekosaur did you mean like that http://lpaste.net/98839764555268096 ?
18:33:42 <geekosaur> no ``
18:34:47 <geekosaur> `` converts something to infix (operator). but type signatures are always prefix form
18:34:59 <toogley> geekosaur: which does this http://lpaste.net/672872919738613760
18:35:22 <geekosaur> right I did say I'd answered the wrong question...
18:35:56 <toogley> and if i remove the square brackets, of [Integer] i get http://lpaste.net/7646469502728667136
18:36:01 <geekosaur> I thought you wanted to know how to use a type signature in where, having read your restatement of your question, and only realized otherwise when I looked at the original statement
18:36:03 <toogley> geekosaur: ah, no problem :)
18:36:54 <toogley> Welkin: btw. great thanks for the tip for list comprehensions found some perls about that. :)
18:40:25 <toogley> but i still don't understand why http://lpaste.net/7646469502728667136 doesn't work, as square brackets around the Integer don't help much. especially i'm having difficulties to understand what is meant by " type ‘[t0]’
18:41:19 <glguy> toogley: [1 .. ] isn't an integer, it's a list of them
18:41:43 <glguy> and you're using it as an integer when you write: x `mod` n
18:41:54 <glguy> so changing the type signature to [Integer] won't help
18:42:05 <Welkin> :t mod
18:42:06 <lambdabot> Integral a => a -> a -> a
18:46:19 <toogley> glguy: ah, yes. i missed that, thanks
18:49:30 <toogley> hm.. how can i implement the "n :: Integer" function? i mean n should literally be every Integer. just leaving the implementation out doesn't work (of course)
18:50:13 <glguy> That's not a thing
18:50:32 <lingxiao> hey all 
18:50:36 <toogley> hey lingxiao 
18:50:40 <lingxiao> so im using combinators here: https://hackage.haskell.org/package/attoparsec-0.13.0.2/docs/Data-Attoparsec-Text.html
18:50:48 <lingxiao> and I m having trouble defining a parser that parses a word
18:51:04 <lingxiao> right now i'm doing http://lpaste.net/177191
18:51:29 <lingxiao> but when i run (parse (word "hello") (pack "hello world")) I get Fail " world" [] "Failed reading: mempty"
18:51:58 <toogley> what do you mean, glguy ? can i even do this in this way..? (using no lists)
18:52:12 <lingxiao> oh wait there's a combinator called string
18:52:14 <lingxiao> nvm
18:52:47 <eitanChatav> toogley: can you explain what function you want?
18:55:06 <lingxiao> how would you construct a parser similar to takeTill, but have signature  foo :: (Text -> Bool) -> Parse Text
18:58:45 <eitanChatav> lingxiao: what's wrong with the `text` parser?
18:59:01 <lingxiao> eitanChatav sorry which one?
18:59:22 <eitanChatav> sorry, I meant `string :: Text -> Parser Text`
18:59:22 <lingxiao> i dont see it?
18:59:30 <lingxiao> oh yeah I didnt see that
18:59:33 <eitanChatav> my mistake, meant `string` not `text`
18:59:43 <lingxiao> but I definitly dont see one with this:   foo :: (Text -> Bool) -> Parse Text 
19:00:18 <lingxiao> bascially takeTill
19:00:27 <eitanChatav> How do you want to use such a function?
19:00:40 <lingxiao> takeTill (\w -> w /= "hello")
19:00:56 <lingxiao> then chain this parser with one that parses hello with some stuff after
19:01:20 <lingxiao> my data looks like this:        "hello\t42222\nworld\t322"
19:01:34 <lingxiao> and I need to get out ("hello", 42222)
19:01:47 <lingxiao> note this hello might be somewhere deep in the text
19:03:20 <lingxiao> eitanChatav its weird it seems like a common pattern
19:03:25 <lingxiao> but theres no combinators for it
19:03:40 <eitanChatav> i'm looking
19:04:02 <lambdamu> what about manyTill?
19:04:37 <lambdamu> you want to apply an action until another one applies?
19:06:04 <jnorris> Is their a good channel for haskell newbies?
19:06:17 <eitanChatav> maybe :-/ I was thinking of just using `(text "hello" >> whatToDoWhenHello) <|> whatToDoWhenNotHello`
19:06:45 <lingxiao> jnorris i found this channel while a newbie
19:06:50 <lingxiao> people are very friendly and helpfull
19:07:07 <eitanChatav> bah...i meant `string` again :-)
19:07:12 <jnorris> thanks, i'll stick around :)
19:07:31 <toogley> eitanChatav: i want a function which can tell me for a given Integer/Int x if x is a prime or not (using the sieve of eratosthenes) => currently, i want to know if its possible to do that without list comprehensions. but as this http://lpaste.net/974560098443591680 example showed me, my thought about this the wrong way. of course, n in this example needs to be of a list of sth similar, because i can't
19:07:33 <lingxiao> eitanChatav so whatToDoWhenNotHello is just skip?
19:07:33 <toogley> represent more than one integer in one integer variable :D (its obvious now to me, that it doesn't work.)
19:07:59 <toogley> eitanChatav: so i'll use list comprehension then. thanks :P
19:08:31 <jnorris> anyone run into "duplicate symbols for x86_64" while cabal installing cabal-install?
19:08:40 <eitanChatav> toogley: I recommend this paper to learn about erathosthenes sieve in Haskell: https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
19:09:13 <glguy> jnorris: If you can paste as much of the terminal output as possible to http://lpaste.net it will help to diagnose
19:09:33 <toogley> eitanChatav: thanks
19:10:57 <jnorris> glguy: http://lpaste.net/177193
19:11:44 <eitanChatav> lingxiao: sorry, not sure, but do you understand how the `(<|>)` combinator lets you try the thing on the left and if it fails do the thing on the right, it seems like what you want to use in this situation
19:11:59 <lingxiao> yeah that one makes sense
19:13:17 <eitanChatav> the parser streams in characters, not words as tokens, if you want words as tokens then you gotta tokenize first
19:13:29 <eitanChatav> which would be a hassle for a simple problem
19:13:54 <lingxiao> eitanChatav yes i agree ...
19:14:24 <eitanChatav> try seeing if `string "hello"` and `(<|>)` let you express the logic of your parser
19:14:26 <lingxiao> hmm so that means on the right i'm just consuming the char and doing nothing with it, and recursing
19:14:32 <glguy> jnorris: You can't have more than one version of the unix package involved in any one compilation, it looks like you've installed unix-2.7.2.0 on top of the unix-2.6.0.1 that comes with your old version of GHC
19:14:44 <lingxiao> yeah so    string "hello" <|> string "world" definitely works
19:14:52 <lingxiao> you know for hello world and world hello
19:14:52 <glguy> jnorris: GHC 7.6.3 might be too old to build cabal-1.24 at this point
19:15:07 <EvanR> you can easily make a parser that uses a word parser
19:15:07 <lingxiao> so ineed a parser that says    foo = consume && foo
19:15:20 <lingxiao> or rather:
19:15:37 <lingxiao> foo = text "hello" <|> bar
19:15:45 <lingxiao> bar = consumeChar && foo
19:15:58 <lingxiao> eitanChatav make sense right?
19:16:07 <jnorris> glguy: ty - i'll go down that path.
19:17:22 <eitanChatav> lingxiao: I'm not sure without the problem statement. The one you gave me before was not enough to clarify for me.
19:17:51 <lingxiao> oh so imagine i have this setting:           ..................... hello\t\234\n ...............
19:18:09 <lingxiao> where .... is other characters
19:18:43 <eitanChatav> do the other chars matter or are you just building a sub parser for the non-... parts?
19:19:09 <lingxiao> i want to consume all the chars until i hit hello, then output ("hello", 234)
19:19:11 <lingxiao> no they dont
19:19:15 <eitanChatav> i mean just for {"hello" + space + number + space}
19:19:32 <lingxiao> im searching a file for hello and its number associated with it, then outputing it
19:19:59 <lingxiao> so even more general
19:20:16 <lingxiao> the file is a list of words and their occurences in some document, so:  Apple 21, Able 432
19:20:32 <lingxiao> I want to find the number of occurences of Able by searching the file
19:21:29 <eitanChatav> lingxiao: `do takeTill (== 'h'); (,) <$> string "hello" <*> space *> number`
19:21:55 <lingxiao> eitanChatav that wont work though since there's definitely a word that starts with h before hello
19:21:59 <lingxiao> the file is alphabetically listed
19:22:12 <lingxiao> what's <*> ?
19:22:30 <eitanChatav> <*> is the applicative combinator
19:22:40 <lingxiao> oh wait nvm .. haha didnt see the <$>
19:22:45 <eitanChatav> it lets you apply functions to parsers
19:22:50 <lambdamu> lingxiao: you should be able to get to the "hello" like this `manyTill anyChar (lookAhead (string "hello"))`
19:22:56 <glguy> Is there a finer-grained way to specify that my foreign exports should be available for runtime linking (dlopen) than ld-options: -rdynamic ?
19:23:22 <glguy> dcoutts: Any chance you know that one?
19:24:43 <dcoutts_> glguy: iirc it can be done with ld scripts on linux, and something similar for dlls on windows
19:24:52 * dcoutts_ has done this for windows dlls
19:25:06 <lingxiao> lambdamu oh that makes sense ... unfortunately there's only peekChar and peekChar'
19:25:13 <jnorris> glguy: regarding the duplicate unix package - any advice? I removed and then installed haskell platform which brought me to same point.
19:25:24 <dcoutts_> glguy: ie an explicit list of C symbols / linker names
19:25:27 <eitanChatav> `Data.Attoparsec.Combinator`
19:25:54 <lingxiao> ahh
19:25:57 <lingxiao> more goodies
19:26:16 <eitanChatav> Question: Is it possible to turn this into a proper `Category` instance for type-level lists? http://lpaste.net/177185
19:28:26 <glguy> dcoutts_: Oh, I figured it out, actually; -Wl,--dynamic-list and a file with my symbols inside surrounded by {...};, one symbol on each line terminated by ;
19:28:39 <lingxiao> lambdamu that worked thanks!
19:28:45 <lingxiao> attoparsec combinators are so cool
19:28:52 <dcoutts_> glguy: great
19:29:02 <lingxiao> i imagine a day where I know all of them by heart and can just spit attoparsec
19:29:06 <glguy> jnorris: Once you have a new enough version of GHC you won't need to replace your version of unix to build cabal-install
19:29:10 <lingxiao> but meanwhile ... i need to parse a number
19:29:16 <lingxiao> and Scientific gives me this Partial _
19:29:32 <lingxiao> which is what?
19:30:59 <eitanChatav> a partial parse...just tack on something at the end which consumes the rest
19:31:33 <lingxiao> so how do I parse a digit of arbitrary length?
19:31:47 <lingxiao> something like count 3 digit wont work since mine might be 1 - 10 digits long
19:32:03 <eitanChatav> either `decimal` or `scientific` should work
19:32:31 <lingxiao> wait but scientific doesnt output anything other than Partial_ thought?
19:32:36 <lingxiao> that's why im confused ..
19:32:49 <lingxiao> parse scientific $ pack "121"    gives me Partial _
19:33:22 <jnorris> glguy: ok progress, prompted with "there are older versions of ghc and/or haskell...run uninstall-hs" i've done this before, but perhaps missed something. onward!
19:33:48 <eitanChatav> try decimal
19:35:10 <lingxiao> hmm same thing
19:35:19 <eitanChatav> weird
19:35:23 <lingxiao> right?
19:35:26 <eitanChatav> installing
19:35:30 <lingxiao> parse decimal $ pack "3211"
19:35:52 <lingxiao> parse (decimal) $ pack "32.11"   this gives me Done ".11" 32
19:35:58 <lingxiao> so decimal is looking for deicmal
19:36:30 <eitanChatav> try using `parseOnly`?
19:38:08 <lingxiao> you mean like parseOnly scientific?
19:38:47 <buglebudabey> what does adding ! before something like data A = !B mean?
19:38:55 <alercah> it means it's strict
19:39:04 <buglebudabey> strictly evaluated?
19:39:07 <alercah> yeah
19:39:12 <buglebudabey> thanks
19:39:21 <alercah> if you have a constructor, say, Foo !Int, then Foo i will force i
19:39:30 <alercah> rather than leaving it as a thunk
19:39:53 <eitanChatav> lingxiao: > parseOnly decimal "341" Right 341
19:40:04 <lingxiao> eitanChatav ok that worked , but also discarded the rest of the Text
19:40:09 <buglebudabey> alercah what if it's nested in something that is normally a thunk?
19:40:11 <lingxiao> yup... ok that makes sense
19:40:25 <buglebudabey> alercah it gets evaluated when that parent expression is?
19:40:28 <alercah> buglebudabey: it will be forced, so it will continue to evaluate until it gets an actual Int
19:40:35 <buglebudabey> ok
19:40:37 <alercah> same as if you tried to pattern match on it
19:40:40 <eitanChatav> that's ok; if you want to parse an `Int` or `Integer` then decimal is what you want
19:40:41 <buglebudabey> thanks
19:40:48 <glguy> buglebudabey: Yeah, if you have that constructor in a thunk then it will stay a thunk
19:41:04 <buglebudabey> glguy cool
19:41:10 <buglebudabey> thank you agian
19:41:56 <glguy> Strict fields will introduce new thunks where there would have been thunks before, too
19:42:11 <glguy> Suppose you had: let x = StrictFieldsConstructor y
19:42:11 <eitanChatav> ok, heading off, good luck lingxiao
19:42:19 <lingxiao> eitanChatav yup thank you!
19:42:28 <glguy> now x is going to be a thunk because evaluating it will need to force y
19:42:42 <glguy> where there wouldn't have been*
19:44:13 <buglebudabey> glguy x = NormalConstructor y wouldn't have been lazy?
19:44:52 <glguy> It will be lazy, x will be a Thunk that forces y and returns NormalConstructor y
19:45:02 <glguy> without the struct field x wouldn't have been a thunk
19:45:19 <glguy> and its field would just have y, whatever y was
19:45:55 <buglebudabey> ok, i was asking assuming NormalConstructor didn't have a strict field
19:46:02 <glguy> OH
19:46:10 <glguy> yeah, what you said
19:46:21 <buglebudabey> gotcha
19:46:34 <buglebudabey> my bad for not being speific
19:47:05 <benzrf> ok, so
19:47:23 <benzrf> i'm thinking i have to fork a library that i'm using in order for it to work in my project
19:47:41 <jle`> is there any way to get 'reads' for a derived instance to return more than 1 result
19:47:42 <benzrf> i'd like to just keep it in the same repo ideally, since any changes i make are going to be related to that project
19:47:51 <jle`> i've been trying out different things but i can't seem to get more than 1 result
19:47:58 <jle`> if that's the case, why even return a list
19:48:05 <benzrf> up til now, i've had it as a dep from hackage in my cabal file
19:48:07 <Koterpillar> benzrf: git multiple remote
19:48:26 <benzrf> heuh?
19:48:32 <benzrf> i was gonna ask about the haskell end of things
19:48:36 <glguy> jle`: I think it returns a list becuase it could be used in a larger context where returning lists was useful
19:48:49 <glguy> jle`: but I don't believe that any of the derived instances ever do
19:48:50 <Koterpillar> benzrf: stack has a perfect solution for this use case
19:49:19 <benzrf> i haven't been using stack :>
19:49:33 <nitrix> benzrf: !
19:49:45 <glguy> benzrf: With the cabal new-build stuff you'd add the local fork'd package to your cabal.project
19:49:54 <buglebudabey> is there a good reason to use the LambdaCase extension other than getting rid of lambda variable bindings?
19:50:00 <glguy> I'm pretty sure sandboxes does that, too
19:50:03 <benzrf> buglebudabey: dont think so
19:50:08 <benzrf> it just makes your code nicer
19:50:08 <jle`> glguy: is it meant to only return 0 or 1 results?  because if that's the case, it could just return Maybe and let the user use maybeToList or something
19:50:17 <Welkin> benzrf: I have libraries I made a one-line change to in my git repo that I load in as a deppendecy using stack
19:50:20 <jle`> buglebudabey: yeah, the main reason i use it is to avoid having to pick useless names
19:50:22 <Welkin> it makes it very easy
19:50:25 <jle`> case x of Just x' -> ...
19:50:35 <Welkin> plus other libraries I wrote but never put on hackage, like web api bindings
19:50:36 <glguy> jle`: Then you'd end up with a bunch of maybeToList noise
19:50:47 <jle`> glguy: only in the contexts where you would want a list
19:50:54 <glguy> jle`: and just because the derived reads doesn't do it doesn't mean that a handwritten instance won't
19:50:56 <jle`> which seems like a very hypothetical thing at the moment
19:51:02 <glguy> and all the instances need to fit into the same class
19:51:02 <Welkin> just paste the git url and hash
19:51:12 <Welkin> in your stack.yaml
19:51:45 <benzrf> does new-build work well with nix
19:51:50 <jle`> glguy: ah, so reads is *meant* to potentially give more than 1 result, but just the derived instances don't?
19:51:58 <jle`> instead of my other suggestion, that reads is always meant to give 0 or 1 results
19:52:52 <glguy> jle`: I believe that to be the case
19:53:22 <glguy> jle`: The report identifies reads returning more than one result as an ambiguous parse
19:53:29 <jle`> hm
19:53:45 <jle`> ok, so 0-or-1 is just a quirk of the derived instances
19:55:08 <glguy> yeah
19:55:11 <lingxiao> ok guys im having a lot of trouble just parsing a bunch of digits
19:55:17 <lingxiao> say i have "422322ea;fjaf"
19:55:22 <lingxiao> i want to extract the number right
19:55:35 <glguy> jle`: That being said it's probably going to be disaster to do much branching
19:55:36 <Clint> is that base128
19:55:39 <lingxiao> so i did this: bar = takeWhile isNumber :: Parser Text
19:55:47 <glguy> given that the whole thing just backtracks blindly :)
19:55:48 <lingxiao> but when i run it:   parse bar "13221"  i get Partial _
19:56:01 <lingxiao> where isNumber :: Char -> Bool
19:56:18 <lingxiao> none of the attoparsec stuff works on digits of my form
19:57:26 <c_wraith> > (reads :: ReadS Int) "4580871087yhiusefyasg"
19:57:29 <lambdabot>  [(4580871087,"yhiusefyasg")]
19:57:39 <lingxiao> many' digit   also doesnt work
19:58:10 <lingxiao> c_wraith so Im using this as part of a larger attoparsec parser
19:58:31 <lingxiao> so it'd be nice if the thing that parses the number is also a Parser Text
19:58:45 <lingxiao> but that reads thing is cool   iv never seen anything like it before
19:58:52 <kv> If I had a set of rectangles associated with layout and it was expensive to compute their true height and width but it was easy to estimate, are there any cool academic concepts I can lean on when I try to model it in haskell?
19:59:19 <kv> I have heard people like to use lattices for partial information but not 100% sure if that is relevant
19:59:49 <buglebudabey> are there comma separated guard conditions such as "f x | x < 2, x > 0 = ..."?
20:00:05 <Welkin> yes
20:00:08 <buglebudabey> thanks
20:00:13 <Welkin> that is basically anding them together
20:03:47 <lingxiao> ahh i see what the paroblem is:
20:04:07 <lingxiao> parse (many' digit) $ pack "432"   --> Partial _
20:04:26 <lingxiao> parse (many' digit) $ pack "432foo"   --> Done "foo" "432"
20:04:29 <lingxiao> what gives?
20:05:11 <lingxiao> same with many', many1, many1'
20:06:01 <Koterpillar> lingxiao: maybe that indicates there might be _more_ digits later?
20:06:17 <lingxiao> yeah .. its weird.. i need to cap the parser some how
20:06:31 <lingxiao> like tell it to stop and just out put Done "" "432"
20:07:00 <Koterpillar> you can apply "" to Partial
20:07:24 <Koterpillar> lingxiao: https://hackage.haskell.org/package/attoparsec-0.13.0.2/docs/Data-Attoparsec-Text.html#t:IResult
20:07:43 <benzrf> glguy: can i use new-build to do a submodule but also load deps from nix?
20:08:07 <Koterpillar> lingxiao: case ... of Partial f -> f ""; Done _ r -> r 
20:08:08 <lingxiao> Koterpillar ok i se this:
20:08:08 <lingxiao>  To indicate that no more input is available, pass an empty string to the continuation.
20:08:33 <jnorris> glguy: going in circles. used install hs on 7.6.3, ghc --version indicated 7.6.3 was still in use, even after activate-hs.  IDK if this helps... ghc in my bin http://lpaste.net/177198
20:09:09 <benzrf> jnorris: how did you isntall hs?
20:09:34 <benzrf> u know what nvm, i should butt out
20:09:48 <jnorris> brew via instructions on haskell.org/platform/
20:10:07 <benzrf> use nix ;)
20:10:14 <benzrf> (not a totally serious suggestion)
20:10:22 <lingxiao> Koterpillar hmm ... so you're saying put this : case ... of Partial f -> f ""; Done _ r -> r
20:10:26 <lingxiao> somewhere in teh parser?
20:10:37 <jnorris> benzrf: another hour of this and i just might
20:10:40 <glguy> jnorris: ghc 7.6.3 is too old for me to have around to test with. i don't know that it's going to be possible to use it to build cabal-install 1.24
20:11:01 <Koterpillar> lingxiao: yes
20:11:11 <benzrf> jnorris: hehehe
20:11:28 <glguy> benzrf: I know that nix exists
20:11:29 <Koterpillar> lingxiao: when you get a Partial f, the result you want is f "" (or f empty)
20:11:38 <benzrf> jnorris: nix trades the pain of everyday use for the pain of climbing up a learning curve
20:11:44 <lingxiao> right .. so im not sure how to synatcially do that actually
20:11:57 <jnorris> glguy: uninstall-hs shows 8.0.1, only. doesn;t seem to match up with my bin (i'm a little out of my depth here, learning though)
20:12:07 <lingxiao> im guessing:   foo = (many1' digit) >> (\_ -> ??? )
20:12:12 <jnorris> benzrf: <3 curves
20:12:22 <buglebudabey> :t asum
20:12:23 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
20:12:37 <buglebudabey> @src asum
20:12:37 <lambdabot> Source not found.
20:12:58 <buglebudabey> what's the command to see a functions usage on lambdabot
20:13:04 <Koterpillar> lingxiao: http://lpaste.net/177199
20:13:04 <glguy> jnorris: make sure the Ghc 8.0.1 you have installed is in your PATH ahead of the old stuff
20:13:08 <Koterpillar> lingxiao: understand before using
20:14:47 <jnorris> exit
20:15:27 <lingxiao> ahh i see you're just pattern matching on the output
20:17:44 <lingxiao> thank you Koterpillar!
20:18:04 <jnorris> benzrf: have a few year old system76 with ubuntu (ofcourse) good for inx?
20:18:21 <Koterpillar> lingxiao: you're welcome, I decided to show a complete example since I wasn't sure which part was the problem
20:18:24 <benzrf> jnorris: i thought you were using a mac of some sort
20:18:46 <lingxiao> yeah thanks for that .. im not at all familar witht he datatypes of attoparsec
20:19:59 <jnorris> benzrf: well yes, my daily is mac. Have others.
20:20:08 <benzrf> jnorris: you can install nix on osx
20:22:52 <seafood> Which client-side library do most people use for  HTTP these days? 
20:23:20 <bitemyapp> http-client / wreq
20:23:32 <seafood> Is that two libraries?
20:23:53 <jnorris> glguy: found this This should not be problem for GHC 7.8 and newer, but
20:23:53 <jnorris> If using GHC 7.6.*  or older, one of several work arounds is needed!
20:23:56 <seafood> bitemyapp: Is that two libraries?
20:24:12 <bitemyapp> one is built on the other
20:24:13 <lifter> How can I know if I should use the StrictData or Strict extensions? Do I need to profile to tell if it's worth it?
20:24:17 <bitemyapp> question of interface you want
20:24:28 <seafood> bitemyapp: I’ll give wreq a go
20:24:48 <bitemyapp> seafood: if you hate lens or something, fall back to http-client.
20:25:34 <seafood> I’m okay with lenses
20:27:04 <bitemyapp> then play ball :)
20:27:44 <glguy> lifter: I'd say you should generally not use either of those extensions. if something needs to be strict you should mark it as such
20:28:29 <lifter> glguy: Ok. Why do you say that? Is it rare that everything in a module needs to be strict?
20:29:20 <glguy> everything in the module won't be strict, the names will be, that's going a create a lot of surprises
20:29:50 <lifter> Ah yes ok.
20:30:10 <ackpacket> Still going through this tutorial and I've seen something called "maybe".  Explanations I've looked at so far mention monads, something I haven't gotten to yet.
20:30:43 <LordBrain> the function maybe, or Maybe capitalized.... function maybe is easy to understand without knowing monads
20:30:44 <ackpacket> So when I see something defined as    foo :: Maybe Int -> Bool -> Bool, this is a function with an optional int argument?
20:30:53 <ackpacket> "Maybe"
20:31:10 <lifter> "Maybe Int" is itself a single argument
20:31:27 <glguy> lifter: I think to use Strict you not only need to be an expert in strictness in Haskell, you also need to be an expert in the extension itself
20:31:28 <LordBrain> data Maybe a = Just a | Nothing
20:31:30 <buglebudabey> where can i find the alternative instance for List?
20:31:37 <glguy> it's not something you just casually turn on
20:31:38 <buglebudabey> Alternative*
20:32:20 <lifter> glguy: Yeah I agree.
20:32:25 <ackpacket> LordBrain: Not sure what that means though.  Is Nothing null? and what is Just a?
20:32:51 <LordBrain> they're data constructors, tags that accompany the payload, or no payload in the case of Nothing
20:33:05 <LordBrain> :t Just 2
20:33:07 <lambdabot> Num a => Maybe a
20:33:24 <ackpacket> What is the =>?
20:33:42 <LordBrain> wel, haskell has this idea of type classes, it uses to do overloading... 
20:33:44 <lifter> glguy: I really haven't figured out when it would be advantageous in my code to use bang patterns.
20:33:46 <LordBrain> :t 2
20:33:47 <lambdabot> Num a => a
20:34:09 <LordBrain> it says basically, the type is a, where a is any type that has an instance of the Num class
20:34:21 <glguy> ackpacket: => separates the "context" from the "type"
20:34:40 <lifter> glguy: I feel like I'd have to do some profiling to be sure that I'm doing the right thing when using bang patterns...
20:35:35 <ackpacket> :t Just
20:35:36 <lambdabot> a -> Maybe a
20:35:37 <LordBrain> ackpacket, this way we can use + with both integers or floating points
20:35:48 <LordBrain> :t (+)
20:35:50 <lambdabot> Num a => a -> a -> a
20:36:39 <LordBrain> that says that + takes two arguments of the same type and gives you a result of that type, with the additional caveat the type must be a member of the Num class, or otherwise put, have an instance of Num declared for it.
20:37:04 <LordBrain> + isnt really a function, its a collection of functions
20:37:09 <LordBrain> overloaded
20:37:29 <ackpacket> Oh, ok, that makes perfect sense.
20:37:42 <ackpacket> :t Maybe a
20:37:44 <lambdabot>     Not in scope: data constructor ‘Maybe’
20:37:44 <lambdabot>     Perhaps you meant one of these:
20:37:44 <lambdabot>       ‘MaybeT’ (imported from Control.Monad.Trans.Maybe),
20:38:02 <LordBrain> Maybe is a type constructor, the data constructors are Just and Nothing
20:38:23 <ackpacket> Heh... reminds me of "who's on first"
20:38:24 <LordBrain> its a different name space, Maybe appears in your type signature, Just and Nothing appear in the code where values are expected
20:39:02 <LordBrain> you very well could define a data constructor called Maybe tho, but there is not one as part of the standard or commonly used libraries
20:39:35 <ackpacket> Well, this was helpful. But Some of the haskell terms are just a bit new to me.  Can I ask one last time what this means without referencing anything haskell specific?    myThing :: Maybe Int -> Bool -> Bool
20:40:12 <ackpacket> a function with an optional argument?
20:40:29 <LordBrain> data Maybe a = Just a | Nothing -- this is a declaration of a type called Maybe parameterized by any other type... so there is Maybe Int, Maybe Double, even things like Maybe (Maybe Int)
20:40:31 <Welkin> ackpacket: a function that takes an Int and a Bool that produces a Bool
20:40:44 <Welkin> but the Int might not be there instead
20:40:48 <Welkin> so yes, the Int is optional
20:41:04 <LordBrain> ackpacket, yeah, thats not a bad way to describe the meaning of MyThing's type signature in english
20:41:58 <LordBrain> its equivalent, but when you give it a value for that optional argument, you have to use the Just constructor, for example: myThing (Just 2) True
20:42:21 <LordBrain> alternatively, myThing Nothing True
20:42:57 <LordBrain> you could declare Bool, just like you could declare Maybe:
20:43:03 <LordBrain> data Bool = True | False
20:43:17 <LordBrain> you don't have to tho, these come defined already in the prelude
20:43:59 * hackagebot http2 1.6.2 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.6.2 (KazuYamamoto)
20:47:11 <ackpacket> Sounds like I've got quite a road ahead.  Any estimates for hours to get to a level where I can read and understand haskell well?  Not necessarily write it well from scratch, mind you.
20:47:30 <anohigisavay> hi...
20:47:43 <LordBrain> because Maybe implements the Monad class, and also the Applicative class you could alternatively write: myThing (return 2) True    or   myThing (pure 2) True
20:48:20 <anohigisavay> what kinds of monad functions are tail recursive? i find it should never be as long as it uses (>>=)
20:48:22 <LordBrain> well, you are starting in a good place
20:48:33 <ackpacket> I have no idea how (return 2) is different than 2, coming from other languages
20:48:35 <LordBrain> i mean, learning Maybe first off, might be a good way to dive in actually
20:48:40 <mniip> anohigisavay, what do you mean by tail recursive
20:49:08 <anohigisavay> but how does `printForever = print 123 >>= printForever` never stack overflows?
20:49:10 <kadoban> ackpacket: If it helps, return is just a function of a specific type.
20:49:13 <kadoban> :t return
20:49:14 <lambdabot> Monad m => a -> m a
20:49:19 <anohigisavay> s/>>=/>>
20:49:19 <LordBrain> ackpacket, return is not the same as you are accustomed to, it is a method in the Monad class
20:49:36 <kadoban> Some examples of Monad instances are IO, Maybe, [], etc.
20:49:42 <mniip> anohigisavay, why do you think it should
20:49:45 <ackpacket> Maybe is a monad?
20:49:46 <LordBrain> occasionally it can look equivalent, but that is misleading, its not at all like return in C or whatever.
20:49:48 <kadoban> > return 5 :: Maybe Int
20:49:50 <lambdabot>  Just 5
20:49:57 <LordBrain> ackpacket, yes
20:50:02 <anohigisavay> mniip: or it should eat up my memory?
20:50:08 <mniip> anohigisavay, why do you think it should
20:50:48 <buglebudabey> anohigisavay it just prints things out indefinitely, nothing is held in memory, and printForever is not evaluated until it's called
20:52:13 <anohigisavay> let sum' l = case l of { [] -> 0; (x:xs) -> x + sum' xs }
20:52:36 <anohigisavay> i don't see the difference between printForever and this, + in place of >>=
20:52:42 <mniip> that's going to eat up your memory
20:52:48 <buglebudabey> anohigisavay that function is not tail recursive
20:52:53 <mniip> + and >>= evaluate differently
20:53:43 <mniip> +, when entered, evaluates its first argument, then its second argument, and only then produces a result
20:53:53 <mniip> >>= is more tricky, especially in case of IO
20:54:13 <mniip> actually
20:54:18 <mniip> I think you mean >> not >>= there
20:54:31 <anohigisavay> ahh yes
20:55:10 <anohigisavay> but >> is just >>= that drops the argument
20:56:33 <LordBrain> ackpacket, one thing that is different from languages you might be used to, is that the return type can be polymorphic and so inference is used from the context to select the proper overloading to get the desired type... what languages are you comparing to?
20:56:38 <buglebudabey> anohigisavay i think the right function would be "printForever = \_ -> print 123 >> printForever
20:56:55 <mniip> that's beside the point
20:57:49 <ackpacket> LordBrain: Eh, it's not as though I can point out a specific language I'm holding up haskell to -- That'd be silly of me.  But You could see how the word return would be really confusing if coming from a lot of other places.
20:57:57 <LordBrain> for example, 1 + 2, it can't actually perform this until it knows which + to use, but neither of its arguments determine that, it has to know by the context
20:57:58 <mniip> in this case >> tailrecursively enters its second argument
20:58:21 <Welkin> has anyone else written minimax for tic tac toe and had the computer still choose really stupid moves?
20:58:22 <LordBrain> :t 2
20:58:24 <lambdabot> Num a => a
20:58:33 <Welkin> it looks like my game tree and evalute function is correct
20:58:44 <Welkin> but it makes terrible moves...
20:59:19 <LordBrain> ackpacket, well some languages are a bit more similar to haskell.. like ocaml or something
21:00:08 <nshepperd> > seq (undefined >>= undefined :: IO ()) ()
21:00:10 <lambdabot>  ()
21:00:30 <mniip> that's uninteresting
21:01:03 <LordBrain> default rules are used in the interpretter, so 1+2 works without context
21:01:33 <LordBrain> but in general, there aren't default rules like that
21:03:12 <LordBrain> occassionally you just have to put an actual type signature in your code, to get it to compile
21:03:26 <mniip> nshepperd, >>= returns a function before inspecting what its arguments are
21:03:38 <nshepperd> yes
21:03:59 <mniip> undefined >>= undefined = IO $ \_ -> undefined
21:04:42 <ackpacket> Welkin: Not in haskell
21:05:57 <jle`> Welkin: i've minimaxed in haskell before
21:06:01 <jle`> things seem to work as expected
21:06:45 <Welkin> jle`: what did you produce from your minimax function?
21:06:51 <jle`> connect 4
21:06:54 <Welkin> I'm just producing a node
21:06:58 <jle`> oh
21:07:04 <ackpacket> Welkin: Either you would produce a decision, or a list of decisions
21:07:10 <jle`> i forgot; it was a while ago, but i think it was producing a decision/move
21:07:17 <Welkin> that has the player's id, the move they made, and the value of that move
21:07:19 <jle`> not sure what you are considering a node here
21:07:33 <Welkin> well, I built a tree for the game
21:07:55 <nshepperd> I think that when you execute it, it evaluates (and executes) the left argument first
21:08:11 <nshepperd> then it can throw the left argument away
21:08:14 <Welkin> and at the end I choose the child with the highest value and produce that
21:08:40 <mniip> huh?
21:08:41 <mniip> no?
21:09:00 * hackagebot persistent-audit 0.1.0.2 - Parses a Persist Model file and produces Audit Models  https://hackage.haskell.org/package/persistent-audit-0.1.0.2 (mchaver)
21:10:11 <mniip> bindIO (IO m) k = IO (\ s -> case m s of (# new_s, a #) -> unIO (k a) new_s)
21:10:30 <mniip> clearly this returns an IO (\_ -> _) before even entering anything
21:10:41 <nshepperd> yes, that's why I said execution
21:11:26 <ackpacket> Welkin: You can generate a tree if you wish.  Some choose to pass in (or globally define) a transition function that generates children given a state.  This makes memoization a tad easier.
21:12:48 <mniip> oh
21:13:01 <anohigisavay> sorry was afk
21:13:35 <mniip> right, when it is executed it evaluates and executes the first argument
21:14:22 <mniip> then evaluates the second argument, applies it, evaluates the result and executes it
21:14:55 <mniip> the last action there can be tailcalld
21:17:37 <Welkin> d
21:17:44 <Welkin> I had to let the ai win
21:17:47 <Welkin> wow that was tough
21:18:08 <Welkin> it almost got 3 across the top, then it stupidly went elsewhere
21:18:26 <Welkin> dunno what's wrong
21:18:44 <jle`> Welkin: you don't have the AI chose the move at the child, right?
21:18:51 <jle`> the decision it makes is the move at the top
21:19:12 <Welkin> hm
21:19:26 <Welkin> the root of my game tree is the current game state
21:19:31 <Welkin> it seems not right
21:19:41 <jle`> then the first move from the current game state
21:20:02 <Welkin> what do you mean?
21:21:03 <Welkin> the game tree's root is the current state
21:21:11 <Welkin> maybe I am doing that wrong
21:21:14 <Welkin> but it makes sense
21:21:25 <Welkin> since it will have n children for n moves it can make
21:24:22 <Welkin> it seems to work a little better now
21:24:25 <Welkin> it blocked me once
21:24:32 <Welkin> maybe that was a fluke
21:24:48 <Welkin> I think I had the wrong player labels
21:24:54 <Welkin> still doesn't seem right yet
21:30:06 <jle`> Welkin: the root is the current state, and it branches on all the moves the player can make, and each branch is associated with a number -- the maximal score that the opponent could manage after you making that move
21:30:19 <jle`> Welkin: you then pick the branch/move that has the smallest of these
21:31:00 <jle`> calculating the maximal score for all of these branches involves running minimax again, but from the other player's perspective, for the modified state
21:31:11 <jle`> but the actual final answer of the algorithm is that first move
21:35:19 <Welkin> I understand the concept, it's just that I may have implemented it wrong somewhere
22:47:14 <lpaste> glguy pasted “initial libnotify integration” at http://lpaste.net/177249
22:47:43 <glguy> ?tell ongy I've started some initial libnotify integration http://lpaste.net/177249
22:47:43 <lambdabot> Consider it noted.
22:54:32 <mniip> glguy, why do you write if () then :v
22:55:23 <glguy> I forgot that the () were optional 
22:56:10 <glguy> There, fixed :)
22:56:44 <mniip> function handlers.NICK(network, prefix, nick)	if (prefix:match('[^!]+') == me[network]) then
22:56:54 <mniip> this is why normal clients can actually track what the nickname is
22:57:26 <glguy> The client does, I just haven't implemented all of the queries as mentioned on the first line
22:58:14 <glguy> At this point it's a normal client
22:58:20 <glguy> I'm just working on the scripting interface
23:08:09 <mniip> interfacing lua from haskell huh?
23:09:53 <glguy> It uses dlopen to pull in an object that exports a struct with callback
23:10:09 <glguy> and then one use of that interface is a lua module loader
23:10:50 <mniip> so ultimately all lua happens in C?
23:11:14 <glguy> Well, Lua's implemented in C, so I suppose so
23:11:21 <mniip> no I mean
23:11:30 <mniip> there's never a lua->haskell->lua stack is there
23:11:45 <glguy> Yeah, you can't do that easily because of how lua's error handling works
23:11:51 <mniip> exactly
23:11:52 <glguy> They use setjmp for that
23:12:05 <mniip> well to be fair it is configurable
23:12:15 <mniip> in luaconf.h
23:12:23 <glguy> yeah, there are macros you can set
23:12:29 <mniip> can be configured to use C++ exceptions of you wish
23:12:33 <glguy> they have c++ expns
23:12:35 <glguy> yeah, been there
23:15:42 <glguy> The hslua package works around it by wrapping all entries and manually threading the error
23:17:36 <ReinH> setjmp: totally a reasonable way to do errors that never causes problems
23:19:35 <ReinH> e.g., destructors failing to fire as it pops the stack, clobbering stack frames all over the place, 
23:19:46 <ReinH> but I think they switched to C++ exceptions to unwind the stack instead?
23:21:27 <glguy> Right, you'd use C++ exceptions to unwind the stack if you were using C++ with Lua
23:30:05 <mniip> tbf I've never had issues with setjmp
23:31:31 <shachaf> i,i setjmp = callCC (return . fix)
23:40:41 <glguy> :t callCC (return . fix)
23:40:42 <lambdabot> MonadCont m => m (m b)
23:45:44 <MauBot> join h
23:52:13 <seafood> Any good libraries for queues?
23:54:20 <ReinH> what kind of queue?
23:55:00 <LordBrain> i've used tbmqueue
23:55:08 <LordBrain> stm-chans library
23:55:36 <LordBrain> tho not in anything major
23:55:44 <LordBrain> but it seems to work alright
