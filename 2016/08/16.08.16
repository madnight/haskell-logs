00:02:12 <Reshi> srhb: Thanks! <!> looks meaningful :)
00:09:52 <saurabhnanda> added a lot more context now -- any help? http://lpaste.net/177548
00:52:53 <quchen> "log" sounds like a good name for logging.
00:53:01 <quchen> <!> does not.
01:03:13 * hackagebot snap-language 0.1.0.2 - Language handling for Snap  https://hackage.haskell.org/package/snap-language-0.1.0.2 (petterb)
01:05:55 <intellekt> hi guys, how can i know the channels that i can get into?
01:06:49 <intellekt> can anyone read this/
01:06:52 <intellekt> ?*
01:06:53 <lambdabot> Maybe you meant: v @ ? .
01:07:07 <intellekt> hello there am i visible
01:07:19 <tdammers> you are not invisible
01:08:13 * hackagebot relational-query 0.8.3.1 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.8.3.1 (KeiHibino)
01:18:33 <pavonia> What would you call a module that is an enhanced/more complete version of a module already present in the module hierarchy, in that case the Win32 package? I guess using the same name and leting the user cope with properly importing the module is considered bad practice?
01:18:53 <merijn> pavonia: Yes
01:19:15 <merijn> pavonia: Why not a submodule of whatever you're enhancing?
01:19:39 <merijn> i.e. "System.Win32.Extras" or "System.Win32.DLL.Extras", whatever
01:20:03 <pavonia> It already is a submodule
01:20:24 <pavonia> I thought of Extras too, but it'ns not really extras, it's the complete version
01:21:07 <merijn> pavonia: What does "it already is a submodule" mean?
01:21:47 <pavonia> That I don't see a way to divide it into more (sub)submodules
01:22:43 <pavonia> Maybe ".Alternate"?
01:23:04 <pavonia> *Alternative
01:27:58 <niluje> is minBound a function?
01:28:09 <niluje> why does it take a type as "param"?
01:28:11 <niluje> how is it possible?
01:28:32 <merijn> minBound is not a function
01:28:39 <niluje> Prelude> data Test = Red | Blue deriving (Show, Bounded)
01:28:41 <niluje> Prelude> minBound :: Test
01:28:43 <niluje> Red
01:28:43 <merijn> And it doesn't take a type as parameter
01:28:52 <niluje> what is it then?
01:28:53 <merijn> niluje: That's just a type signature
01:29:11 <merijn> or type annotation, whatever you wanna call it
01:29:14 <merijn> :t minBound
01:29:15 <lambdabot> Bounded a => a
01:30:22 <pavonia> niluje: Each type implementing the Bounded typeclass has its own minBound version, so you have to give it a hint about which version you want
01:31:33 <pavonia> if the type cannot be inferred, that is
01:32:41 <niluje> there's something I don't get :(
01:32:47 <niluje> Red and Blue are values, not types, right?
01:33:04 <pavonia> Yes
01:33:59 <niluje> how would you write myMinBound which would do exactly the same than minBound for my Test example?
01:34:02 <pavonia> minBound is a value of any type, as long as there is a Bounded instance for that type. That's what it's type says
01:35:05 <pavonia> "myMinBound :: Test; myMinBound = minBound" would work
01:35:28 <niluje> :D
01:35:50 <niluje> and is it possible without using minBound?
01:36:20 <pavonia> You could define it to be Red directly
01:36:45 <pavonia> e.g. myMinBound = Red, myMaxBound = Blue
01:37:03 <niluje> yes, I'm just trying to understand how minBound works, not to have the actual result 
01:37:51 <pavonia> It's exactly like that, just auto-generated by the compiler for you
01:38:53 <EvanR> :t read
01:38:54 <lambdabot> Read a => String -> a
01:39:16 <EvanR> read is kind of the same, depending on what return type you want, it does different things
01:39:53 <EvanR> it takes some getting used to, especially since you dont normally explicitly tell it which 'a' you want, its inferred
01:42:52 <niluje> pavonia: okay, so you can't rewrite minBound from scratch
01:43:29 <niluje> or write middleBound that returns the middle element 
01:43:31 <niluje> can you?
01:44:32 <pavonia> You can define a function that returns the middle element of your type, or define a typeclass that allows you to define it for several other types too
01:45:13 <pavonia> But you can't infer it solely from minBound and maxBound
01:45:46 <niluje> " or define a typeclass that allows you to define it for several other types too"
01:45:52 <niluje> thanks a lot, I guess that was the answer I was looking for
01:45:56 <niluje> that's*
01:46:01 * niluje googles
01:47:27 <pavonia> > toEnum ((fromEnum minBound + fromEnum maxBound) `div` 2) :: Char
01:47:29 <lambdabot>      No instance for (Enum a0) arising from a use of ‘fromEnum’
01:47:29 <lambdabot>      The type variable ‘a0’ is ambiguous
01:47:29 <lambdabot>      Note: there are several potential instances:
01:49:58 <pavonia> > let mid = toEnum ((fromEnum (minBound `asTypeOf` mid) + fromEnum (maxBound `asTypeOf` mid) `div` 2)) in mid :: Char
01:50:00 <lambdabot>  '\557055'
01:57:49 <{AS}> Is there a Haskell-like language that is good at manipulating graphs
01:58:00 <{AS}> I always find Haskell cumbersome to use for that particular thing
01:58:29 <toogley> in the satement "let .. in" is introducing a new variable in the "in" block forbidden? i receive an error there (parse error on input ‘=’) and am wondering if my idea causes this problem.
01:59:26 <phadej> toogley: hmm? paste your code somewhere
02:01:13 <merijn> {AS}: Depends on the size of your graphs?
02:01:20 <toogley> phadej: ah, i just read on another website that its forbidden ( https://paste.fedoraproject.org/409102/14713380/ , line 7)
02:01:21 <merijn> Also, the algorithms you want to run :)
02:01:38 <{AS}> merijn: So I mean things like typed/object graphs 
02:02:05 <{AS}> Like trees with backpointers
02:02:44 <{AS}> So I know I can use Zippers
02:03:07 <{AS}> but for a complex AST writing a lot of Zippers is not so nice unfortunately
02:03:14 <merijn> toogley: That code is a little messy, so I can't even tell if it's right or not. Why are you using let instead of where?
02:03:35 <merijn> {AS}: For ASTs I just use a recursive tree and build lookup maps
02:03:37 <pavonia> toogley: I think the problem is the pipe and the parts after it
02:03:53 <{AS}> merijn: OK thanks :)
02:04:08 <merijn> {AS}: i.e. "functions :: Map String Expr" and then when I walk my AST I look up any names in the map :)
02:04:22 <suppi> let x = 5 in x+x
02:04:26 <toogley> merijn: i'm new to haskell, i initially didn't realize i can also use where there
02:04:35 <suppi> is an example of a let expr
02:04:45 <{AS}> merijn: Yeah :)
02:05:05 <suppi> let <binding> in <expr>
02:05:23 <suppi> but you wrote let <binding> in <binding>
02:05:23 <merijn> toogley: Oh, wait, I see the problem you're using "completePrimeList = ..." inside the "in" which is not valid
02:05:37 <daniel_w> {AS}: There are generic zipper libraries, so that you don't need to create lots of types
02:05:55 <{AS}> daniel_w: Oh, maybe I should take a look, thanks
02:06:38 <daniel_w> {AS}: There's https://hackage.haskell.org/package/zippers , which work over arbitrary traversals
02:07:06 <{AS}> Great :)
02:07:26 <daniel_w> The downside is there's no delete
02:07:44 <daniel_w> Which is why I've been constructing my own: https://hackage.haskell.org/package/simple-zipper
02:08:25 <toogley> pavonia: ah, right. i forgot the [ ] for the list comprehension.
02:08:48 <toogley> suppi: ah, okay. thx
02:11:11 <daniel_w> {AS}: Also, if the AST you are working with is Haskell, you may be interested in https://hackage.haskell.org/package/haskell-src-exts-prisms
02:11:40 <{AS}> daniel_w: It is not, but thanks for the link anyway
02:13:15 * hackagebot persistent-audit 0.1.0.3 - Parses a Persist Model file and produces Audit Models  https://hackage.haskell.org/package/persistent-audit-0.1.0.3 (mchaver)
02:25:09 <julienchurch> Anyone care to answer a trivial beginners' question?
02:26:55 <bjs> julienchurch: ask your question :)
02:28:15 <julienchurch> A type like `data Foo = Foo Foo` is basically just an endless stream of nothingness, right?
02:28:46 <julienchurch> I take it there's no possible data that can be that value because it's infinite?
02:29:14 <daniel_w> you can construct a value, because of lazyness
02:29:21 <daniel_w> foo = Foo foo
02:29:43 <julienchurch> Oh. Derp. Gotcha.
02:29:50 <bjs> julienchurch: well, as daniel_w says you can construct values and only evaluate up to where you need it
02:30:19 <bjs> julienchurch: otherwise yeah
02:30:20 <julienchurch> Is there ever a point for such a type in Haskell?
02:30:59 <daniel_w> Not that one in particular, but very similar ones have lots of uses
02:31:15 <bjs> julienchurch: it looks a lot similar to things like a potential "Fix" datatype and things like that, which rely on similar principles
02:31:40 <julienchurch> Fix datatype?
02:31:45 <bjs> julienchurch: but i can't see any real for that
02:31:56 <daniel_w> data Fix f = Fix (f (Fix f))
02:31:56 <bjs> julienchurch: iirc it's something like data Fix f = Fix (f (Fix f))
02:32:15 <julienchurch> You two are quick.
02:32:21 <{AS}> can you case on a type family?
02:32:58 <{AS}> Oh, nevermind, I will just use Singleton types
02:33:12 <tsahyt> I have a record containing some monadic actions. Can I add a phantom type parameter encoding constraints on the monad those actions can run in? Say I have one record that requires a MonadReader and one that requires a State or something like that?
02:33:26 <toogley> why does this code "[ zip [1..10] (replicate 10 True) | prime <- [2,3], primeness <- (replicate 2 False) ]" generate a nested list, instead of changing the first one? i'd expect the following output: [(1,True),(2,False),(3,False),(4,True),(5,True),(6,True),(7,True),(8,True),(9,True),(10,True)]
02:33:47 <tsahyt> i.e. I want to encode the monad in a phantom parameter but without specifying a concrete monad, like Foo (MonadReader Bar m => m)
02:34:10 <daniel_w> tsahyt: I think you want ConstraintKinds
02:34:53 <tsahyt> daniel_w: I'll look into it
02:37:32 <julienchurch> bjs: Thanks for the tip on Fix.
02:38:16 <julienchurch> I just realized I've seen it before, but never understood it.
02:38:23 <{AS}> merijn: So I am using your solution with Maps, but the issue if I have multiple named elements I loose typing if I index by String
02:38:33 <{AS}> is there a way to recover typing there?
02:39:26 <merijn> {AS}: What kind of typing? Example, my own AST only has "named bindings" (i.e. I dont' distinguish variables and function), so I have "bindings :: Map String (Expr, Type)"
02:39:34 <merijn> Unless you were thinking of something else
02:39:52 <merijn> {AS}: Also, yes, you can case on a type family IFF you use closed type families
02:40:36 <{AS}> merijn: Yeah so if I want to make sure that I keep strongly typed references to B from A
02:40:56 <merijn> tsahyt: I think you want a RankN type
02:41:07 <tsahyt> merijn: I think I need both
02:41:15 <{AS}> let us say I have A { id :: String, bs :: [B} } and B { owningA :: String }
02:41:57 <merijn> tsahyt: Can you give an example definition of Foo? i.e. what does a Foo constructor look like?
02:42:08 <{AS}> where forall a in A, b in B. b in (bs a) => (owningA b) = a
02:42:32 <{AS}> (the latter is an informally specified property)
02:42:42 <merijn> {AS}: Not sure you can enforce that
02:42:52 <{AS}> merijn: OK, thanks for the help anyway :)
02:43:04 <tsahyt> merijn: I'm not quite sure what the type would be, but it'll take several functions (in some monad) using the same constraint, and return a Foo with that constraint encoded in its type somewhere
02:43:21 <merijn> tsahyt: hmm, lemme see
02:43:34 <tsahyt> for example Foo get put would return a record with a MonadState constraint annotated in a phantom parameter
02:44:10 <tsahyt> I think the exact types of the record fields don't matter that much, I'll have to find out what they should actually be later. but I'd like to fix the constraint
02:45:03 <tsahyt> merijn: the reason for all this is still this decision mode thing I was talking about yesterday, I'd like to constrain what parts of the state are being accessed in some mode through the type system
02:45:29 <daniel_w> {AS}: You can use Dynamic for the values of the map and have references with a phantom type that implements Typeable
02:45:59 <tsahyt> I've refactored everything to be generic enough that I have relatively fine-grained guarantees through effect classes, now I want to implement the mode record itself
02:45:59 <{AS}> daniel_w: Interesting proposal
02:46:07 <{AS}> thanks
02:47:20 <Gurkenglas> tsahyt, in Lens you can work with State PartOfYourRecord () and then use zoom fieldname to turn that into a State YourRecord () at some point
02:48:39 <merijn> tsahyt: I think I've got it working, lets see if it compiles :)
02:49:56 <Gurkenglas> (And some trickyness ekmetts applied there makes it so it works on any part of monads constructed through monad transformers that differ only in the state StateT's using)
02:50:08 <Gurkenglas> -part+pair
02:50:11 <tsahyt> Gurkenglas: I'll really have to look at lens one day. For now providing classes manually worked well enough. It does become unwieldy as the amount of state grows though.
02:50:23 <merijn> hmm, apparently this takes a bit longer since I don't have cabal or mtl installed globally so my small test doesn't work :p
02:50:41 <Gurkenglas> Show me the code and I could try refactoring it to use lens :D
02:51:09 <tsahyt> Gurkenglas: I think I'll put that on my own todo list for when I finally get around to dig through lens myself
02:51:20 <tsahyt> It's the first time I've actually had any use for it
02:51:30 <merijn> tsahyt: You'll have to try and see if it works for me
02:51:39 <lpaste> merijn pasted “No title” at http://lpaste.net/177601
02:52:07 <tsahyt> merijn: wouldn't that need GADTs enabled too, or do they get enabled by one of the other extensions?
02:52:10 <merijn> Not really a phantom parameter (since it's not unused), but it works
02:52:19 <merijn> tsahyt: Eh, yes xD
02:52:26 <merijn> Actually, I don't think it needs GADTs
02:52:33 <merijn> but it's more readable to write that way
02:53:35 <lpaste> merijn revised “No title”: “No title” at http://lpaste.net/177601
02:53:37 <tsahyt> eratkat: well it compiles
02:53:41 <tsahyt> merijn: ^
02:53:46 <merijn> tsahyt: I think that annotation should also work
02:53:59 <merijn> Because it doesn't actually use anything GADT
02:54:06 <tsahyt> merijn: the Foo itself, I didn't copy the function below
02:54:11 <tsahyt> let's see if ghci accepts an example
02:55:00 <tsahyt> it type checks
02:55:21 <tsahyt> so what I forgot was of course naming the constraint parameter
02:55:28 <merijn> :)
02:55:37 <tsahyt> it obviously needs to be quantified over the whole constructor
02:56:05 <merijn> The non GADT version also works here
02:57:11 <tsahyt> yep, for me too. thanks!
02:57:19 <tsahyt> I like how this doesn't even require a recent GHC version
02:57:25 <tsahyt> I'm bound to 7.8.4 here unfortunately
02:58:50 <merijn> tsahyt: If you wanted you could obviously have different constraint parameters and use a different constraint for each field
02:59:28 <tsahyt> merijn: I think it won't be necessary
02:59:58 <tsahyt> I want to implement my decision modes as smart constructors for this record and denote whether they need the queue or not in the type
03:00:19 <tsahyt> mostly to catch any obvious errors while refactoring
03:00:45 <tsahyt> so I can write the type first, piece them together from what I already have, and GHC should make sure that the queue is only used in modes that explicitly say so
03:03:14 <qqzw> this sounds silly: how do I do Int32 -> In32, which divides by 2 (and rounds down) ?
03:03:28 <qqzw> I'm trying div 2 :: Int32 -> Int32, div2 x = fromInteger $ toInteger $ x / 2
03:03:31 <qqzw> but I get type errors
03:04:02 <daniel_w> > :t div
03:04:03 <lambdabot>  <hint>:1:1: parse error on input ‘:’
03:04:08 <daniel_w> > div
03:04:10 <lambdabot>  <Integer -> Integer -> Integer>
03:04:39 <daniel_w> The actual type is: (div) :: Integral a => a -> a -> a
03:05:41 <ReinH> > 17 `div` 2
03:05:42 <lambdabot>  8
03:05:56 <ReinH> That's the behavior of div
03:06:07 <tsahyt> merijn: hmm, this is interesting. I can't use constraint synonyms with it to impose multiple constraints at once
03:06:16 <qqzw> that is indeed
03:06:20 <qqzw> it worked; thanks Reinh !
03:06:24 <ReinH> yw
03:07:17 <ReinH> > (-17) `div` 2
03:07:18 <lambdabot>  -9
03:07:24 <ReinH> > -17 `div` 2
03:07:25 <lambdabot>  -8
03:07:30 <ReinH> fixity can be confusing sometimes
03:09:20 <daniel_w> tsahyt: that should work
03:09:41 <daniel_w> can you share your code
03:10:26 <tsahyt> daniel_w: see the paste from above, http://lpaste.net/177601 and I'm using type Group m = (Bar m, Quux m) to group two constraints together.
03:11:00 <tsahyt> actually I can post the real thing, it's quite short right now.
03:11:43 <tsahyt> http://lpaste.net/177610
03:11:58 <tsahyt> Type synoym 'StackDriver' should have 1 argument, but has been given none
03:12:04 <tsahyt> adding the argument gives me a kind error of course
03:12:34 <dontrun> Hey
03:12:37 <Gurkenglas> Is there something like a Contralens' (a -> b) a?
03:13:41 <dontrun> I'm getting "parse error (possibly incorrect indentation or mismatched brackets)"
03:13:47 <Gurkenglas> Oh thats just a "Lens (b -> c) (a -> c) a b" isnt it
03:13:49 <dontrun> And there is no syntax error
03:14:07 <dontrun> I tried running the line on it's own in the ghci and it worked fine
03:14:13 <tsahyt> dontrun: layouting rules maybe?
03:14:19 <Gurkenglas> Did you use tabs?
03:14:44 <dontrun> https://ghostbin.com/paste/rvq84
03:14:50 <dontrun> That's the code where the error is
03:14:54 <dontrun> Second line
03:15:26 <dontrun> I don't use tabs
03:15:27 <tsahyt> dontrun: There's a | in the type signature that doesn't belong there
03:15:44 <dontrun> Ohh, and that causes the error?
03:15:46 <dontrun> Thanks!
03:15:50 <tsahyt> you can't inline sum types like this
03:16:10 <tsahyt> I suppose that's what you were trying to say with his
03:16:12 <tsahyt> this*
03:18:39 <merijn> tsahyt: Actually, you can, just write a type family that combines constraints
03:19:08 <daniel_w> tsahyt: yeh, the problem is that type synonyms don't produce real type functions
03:19:24 <tsahyt> merijn: what would that look like?
03:21:50 <merijn> tsahyt: "type family Combine :: Constraint -> Constraint -> Constraint where Combine a b = (a, b)" or something along those lines
03:22:00 <merijn> tsahyt: Can you show a minimal example that doesn't work?
03:22:08 <tsahyt> merijn: http://lpaste.net/177610
03:22:25 <daniel_w> merijn: I don't think that will work either
03:26:03 <tsahyt> http://lpaste.net/177618
03:26:05 <tsahyt> this at least compiles
03:26:31 <tsahyt> although I should probably put the constraints in the class definition rather than in the instance head
03:26:53 <merijn> daniel_w: Why?
03:27:23 <daniel_w> because the problem before was that type synonyms can't be partially applied
03:27:26 <toogley> what is wrong with this function/type signature? https://paste.fedoraproject.org/409134/13432011/ 
03:28:01 <toogley> i don't see why the type is wrong
03:28:24 <merijn> tsahyt: Those instances don't look right
03:28:36 <merijn> tsahyt: Are you sure you don't mean to put an instance on the class?
03:29:53 <daniel_w> looks right to me
03:30:14 <tsahyt> merijn: well the way it is now, an instance only exists when the parent instances exist
03:30:22 <tsahyt> but there's nothing stopping someone from adding more instances
03:30:33 <merijn> tsahyt: Eh, yes there is
03:30:41 <merijn> tsahyt: No one can ever add another instance
03:30:50 <merijn> tsahyt: Because your current instances overlap with everything
03:30:53 <daniel_w> they can so long as they mark it overlapping
03:31:15 <tsahyt> eh, why are they overlapping?
03:31:22 <merijn> daniel_w: Let's not make bad design worse by adding even WORSE features into it without first trying to avoid the entire problem
03:31:34 <merijn> tsahyt: Instances resolution does not take instance constraints into account
03:31:44 <tsahyt> ah well
03:32:05 <daniel_w> merijn: I'm not saying that someone should create a new instance, just that they can
03:32:17 <merijn> tsahyt: So "instance (BaseDriver m, StackAction m) => StackDriver m" looks like "instance StackDriver m" to GHC
03:32:42 <tsahyt> merijn: so I should put the constraints in the class head?
03:33:02 <lyxia> toogley: variables start with a lowercase letter
03:33:16 <toogley> lyxia: oh, okay.
03:33:42 <merijn> tsahyt: Constraint in the class head means "if someone tries to define an instance without ALSO defining these instances, it's an error"
03:33:59 <merijn> tsahyt: So constraint on the class effectively means "all instances MUST be instances of constraint"
03:34:15 <merijn> (It's up to the implemenator to instance the relevant classes)
03:34:48 <merijn> tsahyt: i.e., like "class Eq a => Ord a" which means you can only make something an instance of Ord if you also make it an instance of Eq
03:35:37 <tsahyt> but I'd like to have an instance iff there are instances of those other classes
03:35:42 <daniel_w> Since there's only ever going to be one instance, it might work better in this case
03:36:28 <merijn> tsahyt: Right, but then you have to accept that no other instance can be defined, except that one
03:36:57 <tsahyt> merijn: well since it's only meant as a synonym anyhow, that's fine imo
03:37:56 <toogley> lyxia: merci, it worked.
03:38:20 <lyxia> toogley: de rien
03:38:41 <tsahyt> merijn: I need the constraints in the instance head regardless. it won't compile otherwise.
03:46:11 <dontrun> Guys I wanna create a function that takes in a string and maybe outputs IO
03:46:22 <dontrun> String -> Maybe IO () doesn't work
03:48:18 <lyxia> Maybe (IO ()) is a valid type. What are you trying to do?
03:48:41 <merijn> I suspect he simply wants "String -> IO ()"
03:49:15 <tsahyt> why don't we have a type level lambda...
03:49:34 <tsahyt> Foo (\m -> (C m, D m)) would make this all a lot simpler
03:51:57 <quchen> tsahyt: Because then the type system would become a whole lot more complex.
03:52:20 <tsahyt> fair enough
03:52:54 <merijn> It's worse than that
03:53:25 <merijn> Type level lambda is sufficient to render the type system Turing complete and thus it's not guaranteed type checking actually terminates :)
03:53:47 <quchen> merijn: With the kind system still in place we’d only get a (strongly normalizing) typed lambda calculus, no?
03:53:49 <Gurkenglas> So only allow lambdas if the author also supplies a halting proof
03:53:53 <tsahyt> merijn: foo :: (forall m. c m ~ (C1 m, C2 m)) => Foo c compiles. Does this even do what I want it to do?
03:53:58 <merijn> Actually implementing type level lambda is pretty easy :p
03:54:08 <tsahyt> i.e. impose both constraints
03:54:14 <merijn> tsahyt: tbh, I have no idea xD
03:54:26 <Maxdamantus> Turing complete? Wouldn't it be basically equivalent to the simply typed lambda calculus?
03:54:29 <Maxdamantus> (which isn't TC)
03:54:43 <tsahyt> hmm.. I'll just leave it like that for now and see if it works. If it doesn't I'll fall back on explicitly defining synonyms via classes
03:54:49 <merijn> Maxdamantus: No, because we have recursive types
03:55:21 <Maxdamantus> I think the recursion that would be relevant here would be infinite types.
03:55:28 <Maxdamantus> which we don't have.
03:55:52 <Maxdamantus> s/\<would\>/might/
03:55:58 <merijn> Maxdamantus: We have those if you wrap them in a newtype and I think lambda's are enough to peer through the newtype
03:57:07 <daniel_w> Fix for example
03:58:24 <daniel_w> actually, that's not a good example
04:00:42 <Cynede_> hello, what's >>= priority number?
04:01:49 <tsahyt> why do I get the impression that while Haskell *lets* you encode a lot of invariants in types, it doesn't really want you to
04:02:17 <tsahyt> this all reminds me of this experiment I did with encoding the shape of a tree on the type level in order to restrict functions to only work on say balanced trees
04:02:34 <tsahyt> it works perfectly as long as the trees are known at compile time
04:02:40 <tsahyt> but I've been unable to construct them at runtime
04:03:46 <cocreature> tsahyt: you can often get around this by writing a toBalanced :: Tree a -> Maybe (BalancedTree a) function or something similar
04:04:41 <tsahyt> cocreature: that's one way yes, but ideally I'd like to have toBalanced :: Tree x a -> Maybe (Tree Balanced a) or similar
04:06:28 <merijn> Cynede_: You can query the fixity of any operator in ghci using ":info (>>=)"
04:07:16 <merijn> Cynede_: Which returns "infix[r|l] [0-9]" indicating right/left associativity and precedence, the default precedence (if none is printed) is "infixl 9"
04:14:44 <tsahyt> okay so now I've been trying to get a type family to work that combines constraints
04:15:04 <tsahyt> type family C a b m :: (* -> Constraint) -> (* -> Constraint) -> * -> Constraint where C a b m = (a m, b m)
04:15:22 <tsahyt> but GHC tells me that (a m, b m) is of kind *, and therefore doesn't accept this
04:17:44 <Cynede_> merijn 9 is pretty a lot, thank you
04:17:55 <merijn> tsahyt: If m is supposed to be, e.g., a Monad the kind is wrong :)
04:18:04 <merijn> tsahyt: Since monads have kind "* -> *", not * :)
04:18:14 <tsahyt> merijn: yep, I just wanted to save on typing for now
04:18:34 <Cynede_> merijn am I understand right that bigger number is higher priority?
04:18:39 <Cynede_> *do I
04:18:55 <merijn> Cynede_: Higher number is higher priority, yes. Function application is precedence 10 and record syntax precedence 11
04:19:08 <merijn> tsahyt: Can you make a minimal example type family like that that goes wrong?
04:19:26 <tsahyt> I think this already is a minimal example
04:21:27 <merijn> oh!
04:21:49 <merijn> I think you ran afoul of a REALLY annoying bit of type family syntax
04:21:50 <merijn> Lemme try
04:22:16 <tsahyt> quite possibly, I don't have much experience with them
04:23:15 <merijn> The signature after "C a b m" defines the RESULT kind of "C a b m", not the kinds of the parameter
04:24:02 <merijn> Use
04:24:03 <merijn> "type family C (a :: * -> Constraint)  (b :: * -> Constraint) (m :: *) :: Constraint where C a b m = (a m, b m)"
04:24:04 <tsahyt> ahh, using just Constraint there works
04:24:35 <merijn> Or just "C a b m :: Constraint" if you don't want to annotate the kinds of parameters :)
04:25:05 <tsahyt> I need to annotate them when m is a monad though
04:25:09 <tsahyt> otherwise I get a kind error
04:25:43 <{AS}> merijn: Although I wouldn't call it annonying, it makes sense that what you are saying when writing C a :: T that C a has type T, and not that C has type T :)
04:25:54 <tsahyt> unfortunately this doesn't work either though
04:26:17 <tsahyt> the type family does produce the constraint as I want it too, but it does not work because it's partially applied
04:27:02 <tsahyt> it seems like building type classes as synonyms is the only thing that actually works
04:27:19 <merijn> {AS}: The annoying bit is that you can't leave out the parameters and just write a kind for "C"
04:27:31 <{AS}> merijn: Oh, I see!
04:48:02 <exDM69> I have a newbie question about stack...
04:48:10 <exDM69> do I need to have .cabal file *and* stack.yaml
04:48:22 <exDM69> and keep them both up to date?
04:49:00 <hvr> exDM69: you can also just keep .cabal up2date, and have stack.yaml generated iirc
04:49:33 <hvr> `stack init` should be able to generate a stack.yaml file
04:49:47 <exDM69> I still do not quite grok the stack/cabal distinction...
04:49:59 <linduxed> so i've got .hs-files which i would refer to as source files
04:50:01 <srhb> exDM69: Cabal (the library) is not cabal-install (the `cabal` executable)
04:50:10 <linduxed> if i compile these source files, i get a bunch of new files
04:50:14 <exDM69> yeah, I meant cabal-install
04:50:14 <srhb> exDM69: Cabal (the library) is used by both cabal-install and Stack to build packages.
04:50:17 <linduxed> now they might be object files and other stuff
04:50:28 <hvr> exDM69: that's a big topic that would take quite long to explain :_)
04:50:40 <hpc> exDM69: so, ghc-pkg manages putting the compiled libraries somewhere ghc can recognize, and registering that they exist
04:50:44 <linduxed> but is there some genereal term for "the files that get generated once you've run the compiler"?
04:50:48 <zoran119_> is it possible to use a http client library (say wreq) to create a function which takes a url and returns and int with the response status (String -> Int)?
04:50:51 <linduxed> "compilation results", maybe?
04:51:08 <hpc> exDM69: cabal-install (executable "cabal") builds stuff, downloads dependencies, and calls ghc-pkg
04:51:24 <lambdamu> zoran119_: Not in a pure way if you mean that
04:51:24 <zoran119_> i'm having problems escaping from IO and i'm thinking i don't really understand how to use IO :(
04:51:25 <liste> zoran119_: String -> IO Int is possible
04:51:44 <hpc> exDM69: stack has extra stuff that ensures reproducable builds, uses its own repository, and calls cabal during the build step
04:51:52 <hpc> exDM69: (very rough overview)
04:52:02 <merijn> zoran119_: You don't escape from IO. The real question is "how do you get the non-IO stuff you want INTO IO"
04:52:03 <lambdamu> zoran119_: You can not escape from IO, at least not safely, that is the whole point
04:52:10 <exDM69> yeah, I already had quite a few issues w/ ghc 7.10 vs. ghc 8.0
04:52:21 <exDM69> that's why I'm looking into stack
04:52:39 <exDM69> stack didn't exist when I used haskell the last time 
04:52:46 <merijn> zoran119_: Note that IO is, amongst other things, an instance of Functor, so if you have "String -> Int" and "IO String" you can simply use fmap to turn it into "IO Int"
04:53:24 <lambdamu> exDM69: one way to think about it is, you use the .cabal file to describe your project and the stack file to pin it's dependencies
04:53:36 <hvr> exDM69: just be aware that Stack follows a different design philosophy from cabal, and yet needs to build on top of Cabal the library; which is the reason you may notice some impedance mismatches here and there 
04:53:59 <lambdamu> exDM69: that's a huge and somewhat incorrect simplification but still useful in my opinion
04:54:21 <zoran119_> ok, so i have it returning IO Int, but i'm under this impression that i'll get that Int out at some point and use it in pure functions
04:54:30 <hvr> lambdamu: IOW, stack.yaml file is what a freeze file is to cabal? :)
04:54:53 <zoran119_> at least it is starting to NOT make sense, can only get better from here i hope :)
04:55:20 <lambdamu> hvr: Yeah I guess you could put the analogy that way
04:56:08 <merijn> zoran119_: You can't get the Int out
04:56:09 <lambdamu> zoran119_: you can use the result with a pure function via a combinator, but the result is encapsulated in the IO type
04:56:17 <merijn> zoran119_: However, you can get your pure function *in*
04:56:42 <lambdamu> fmap (f :: a -> b) (x :: IO a) :: IO b
04:57:00 <zoran119_> merijn: would i get it in using a lift of some kind?
04:57:03 <deank> zoran119_ if you could just pull things out of IO then what would be the point in it
04:57:40 <merijn> zoran119_: fmap or bind (i.e., >>=) usually
04:58:16 <merijn> "fmap :: (a -> b) -> IO a -> IO b" and "(>>=) :: IO a -> (a -> IO b) -> IO b" in this case
05:03:20 * hackagebot MagicHaskeller 0.9.6.5 - Automatic inductive functional programmer by systematic search  https://hackage.haskell.org/package/MagicHaskeller-0.9.6.5 (SusumuKatayama)
05:04:25 <linduxed> compilation artifacts, maybe?
05:08:20 * hackagebot hw-diagnostics 0.0.0.3 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-diagnostics-0.0.0.3 (haskellworks)
05:08:37 <sshine> in the docs for Data.Trie, it says that it uses Data.ByteString; what if I want an efficient trie for Data.Text, is that made?
05:09:47 <Gurkenglas> https://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Zoom.html#t:Zoomed why don't these docs include the type instance values?
05:11:11 <zoran119_> that's making sense, thanks everyone
05:11:23 <zoran119_> merijn: thanks for the fmap hint
05:13:07 <jonored> zoran119_: the intuition I use is that IO is for building functions that take a state of reality and return a new state of reality; given that, it doesn't make much sense to be able to divorce a value pulled from reality and use it with a different one.
05:13:20 * hackagebot ede 0.2.8.5 - Templating language with similar syntax and features to Liquid or Jinja2.  https://hackage.haskell.org/package/ede-0.2.8.5 (BrendanHay)
05:13:22 * hackagebot hw-bits 0.0.0.12 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-bits-0.0.0.12 (haskellworks)
05:15:08 <jonored> You can also just use pure functions as part of IO actions you probably already need to write, and it might or might not be clearer than lifting things into IO, depending.
05:23:21 * hackagebot mueval 0.9.3 - Safely evaluate pure Haskell expressions  https://hackage.haskell.org/package/mueval-0.9.3 (ChrisDone)
05:26:23 <MrDetonia> I'm trying to build a project using stack and cabal. I need a certain version of a package, but running 'stack build' returns this error: " needed (>=1.2.5), 1.2.2.0 found (latest applicable is 1.2.7.0)"
05:26:35 <MrDetonia> what does this mean exactly, and how can I resolve the issue?
05:28:21 * hackagebot haskell-eigen-util 0.1.0.0 - Some utility functions for haskell-eigen library  https://hackage.haskell.org/package/haskell-eigen-util-0.1.0.0 (dilawars)
05:29:43 <Gurkenglas> What was the lens thing that allows you to turn a list into a list of lenses into that list?
05:36:58 <sshine> Gurkenglas, what?
05:37:28 <Gurkenglas> [a] -> Lens' [a] a, or perhaps even [a] -> Lens' [b] b
05:37:54 <skrio> MrDetonia: Your version is too old for the snapshot, add it to your .stack file to resolve it (i think)
05:38:01 <MrDetonia> so running "stack install directory-1.2.5.0" works fine; why isn't stack doing this automatically?
05:38:13 <MrDetonia> skrio: yeah, I thought that's exactly what stack was for
05:38:17 <MrDetonia> handling dependencies
05:38:40 <skrio> MrDetonia: For handling dependencies *known* to play well with each other
05:39:34 <MrDetonia> but I have no other strict dependencies
05:39:42 <MrDetonia> can't it just get other packages that work well?
05:39:58 <MrDetonia> that is the only package listed in my .cabal with version requirements
05:41:06 <skrio> MrDetonia: You can lower your LTS version down and hope to find one that includes your version, then they other packages should resolve to olders versions known to work with your version as well
05:42:24 <MrDetonia> well it's currently trying to use 1.2.2
05:42:27 <MrDetonia> I want 1.2.5
05:42:31 <MrDetonia> so shouldn't it be newer?
05:42:53 <MrDetonia> (1.2.5 or greater actually)
05:42:53 <mpickering> You can add other dependencies to your stack.yaml file 
05:42:57 <mpickering> which aren't in the snapshot
05:43:04 <exDM69> argh... I ran into issues with stack not being able to find llvm-config
05:43:12 <skrio> Oh, maybe :) Try a nightly snapshot?
05:43:24 <MrDetonia> okay, what is a good nightly point to use?
05:43:32 <MrDetonia> can I just use yesterday's date for example?
05:43:41 <Gurkenglas> To put it another way: (get >>=) . traverse :: (a -> State [a] ()) -> State [a] () will use the original list entries while determining the argument to all calls of the argument function. How do I make it respect updates done by the first call?
05:43:49 <skrio> MrDetonia: Depends, can your app support GHC 8?
05:44:13 <MrDetonia> it should be able to
05:44:24 <MrDetonia> there's nothing really version specific apart from this one library I need
05:44:32 <MrDetonia> I need a particular function
05:44:49 <orion> Hi. Sometimes I get error messages like this printed to stdout/stderr: openFile: resource busy (file is locked) Is there a way to prefix those messages with a timestamp?
05:44:53 <mpickering> Gurkenglas: This is a confusing question, can you be more specific?
05:44:55 <skrio> then nightly-2016-08-16 should be good? It has 1.2.6.2
05:45:43 <MrDetonia> I am trying now
05:45:53 <MrDetonia> thanks for the info btw
05:45:59 <mpickering> The way traverse works, if you want anything to be passed between calls you need to hide it in some monad
05:46:00 <MrDetonia> I couldn't find this on the web at all :s
05:46:45 <Gurkenglas> Imagine Civ players taking turns. Each can affect the whole board, and the actions each one can do depend on all turns done before his. traversing a list of players with a function that turns their options into their actions pretends for later players as if earlier players hadnt taken their turn yet.
05:46:54 <skrio> stackage.org has info on what packages are available in a snapshot
05:47:04 <mpickering> I used to be able to help people better when they asked questions about cabal :P 
05:47:37 <mpickering> Gurkenglas: Seems easy to write using a fold for example
05:47:48 <von_cidevant> hey guys, any SCOTTY masters ?
05:48:06 <mpickering> I'm not sure why you started out using (get >>=) . traverse, it's quite opaque 
05:48:21 * hackagebot feed-gipeda 0.2.0.0 - CI service around gipeda  https://hackage.haskell.org/package/feed-gipeda-0.2.0.0 (sgraf812)
05:48:36 <tdammers> von_cidevant: masters, not sure, but why don't you just ask your question?
05:49:05 <von_cidevant> How in Scotty concat to text several params ?
05:49:08 <Gurkenglas> I first thought I'd ask you to imagine a function f to be put into get >>= traverse f, but I thought (get >>=) . traverse saves that need
05:49:16 <von_cidevant> where to paste code ?
05:49:18 <von_cidevant> haskell code?
05:49:25 <Gurkenglas> lpaste.net
05:49:41 <Philonous> @paste
05:49:41 <lambdabot> Haskell pastebin: http://lpaste.net/
05:50:03 <mpickering> Gurkenglas: You are massively overcomplicating this, write a function, doPlayerTurn :: StateT .... and then  traverse doPlayerTurn
05:50:30 <mpickering> update the state necessary in doPlayerTurn so the next call can calculate the necessary information
05:51:08 <Gurkenglas> This is not the actual problem I have, I just gave you an explicit application because you asked for one. (My actual problem is trying to answer http://lpaste.net/177644 completely)
05:52:00 <mpickering> What is f1 meant to do?
05:52:17 <Gurkenglas> Int -> State Foo (), it's right there
05:53:02 <mpickering> I mean, which hole do you want us to fill in.. there's not really any description of the problem 
05:53:13 <Gurkenglas> I find it clear...
05:53:17 <Gurkenglas> Not my question :P
05:53:34 <tdammers> von_cidevant: fetch them one by one, then concatenate?
05:54:13 <mpickering> Perhaps you can explain then? There's no specification about how f1 should behave.
05:55:08 <Gurkenglas> He basically said ":exf Traversal' s a -> (a -> State s ()) -> State s ()". The (a -> State s ()) does something with s, which depends on a. He wants to do that thing for all targets of the traversal
05:55:14 <von_cidevant> tdammers: http://lpaste.net/9038792922501218304
05:55:27 <von_cidevant> tdammers: last line doesnt work
05:56:13 <mpickering> so why does mapM not work? or mapMOf_, whatever the lens version is
05:56:16 <Gurkenglas> Which is trivially answered with \l f -> use l >>= traverse f, but one should also give the possible answer that wants the changes done by one a to be reflected by the a that are used in the later applications of f
05:56:55 <mpickering> why is that the case?
05:57:23 <Gurkenglas> Because that is a sensible inhabitant of the type he asked for, as illustrated by the civ example
05:57:24 <tdammers> von_cidevant: define "doesn't work"
05:58:09 <mpickering> and I said the only way I thought to do this was remember the new values in some monad
05:58:25 <tdammers> von_cidevant: does it not compile? or does it produce unexpected results?
05:58:46 <divVerent> There really is no Bool -> (a, a) -> a already? :)
05:58:59 <divVerent> probably that one's TOO simple...
05:59:10 <lyxia> :t flip (uncurry bool)
05:59:11 <lambdabot> Bool -> (c, c) -> c
05:59:23 <tdammers> von_cidevant: actually, wait, I think I see the problem
05:59:33 <tdammers> text :: (ScottyError e, Monad m) => Text -> ActionT e m ()
05:59:34 <Gurkenglas> And I think this can be done by getting all possible lenses into the list, then applying each one in turn
05:59:37 <mpickering> But you really mean she has the more specific function where s = [a]?
05:59:40 <tdammers> however:
05:59:44 <tdammers> :t (++)
05:59:45 <lambdabot> [a] -> [a] -> [a]
06:00:09 <Gurkenglas> You mean you can't get all possible lenses into a traversal? sure, then replace s with [a].
06:00:54 <tdammers> which means that the last line doesn't typecheck: text takes a Text, but you're passing a String
06:00:56 <von_cidevant> tdammers: i should import some module?
06:01:00 <tdammers> no
06:01:04 <divVerent> lyxia: hehe, so that's where it was put :)
06:01:05 <Gurkenglas> > execState (get >>= traverse (\i -> modify $ map (+i))) [1,1,1,1,1] -- (the inhabitant im looking for should output [32,32,32,32,32] here)
06:01:07 <lambdabot>  [6,6,6,6,6]
06:01:13 <tdammers> you need to turn the String into a Text, or use Text right away
06:01:16 <mpickering> You can write a lens holesOf which gives you a lens Lens s [a] from Traversal s a
06:01:25 <tdammers> for the former, use pack from Data.Text
06:01:39 <mpickering> But I don't think there is a function Traversal s a -> [ALens s a], not that I remember anyway
06:01:53 <tdammers> for the latter, use <> instead of ++ and enable the OverloadedStrings extension, such that your string literals can be treated as Texts
06:02:15 <tdammers> (<> is in Data.Monoid, btw.; it's a generalization of ++ over arbitrary monoids)
06:02:33 <von_cidevant> tdammers: I love you man )) I will try and will tell you my result)
06:03:22 * hackagebot language-conf 0.2.0.0 - Conf parsers and pretty-printers for the Haskell programming language.  https://hackage.haskell.org/package/language-conf-0.2.0.0 (yamadapc)
06:03:42 <Gurkenglas> Well there obviously is such a function, only it's gonna be slow and inelegant: zipWith const (map (singular . ix) [0..]) (also you can't store lenses like that)
06:03:57 <mpickering> You can if you use ALens
06:04:11 <Gurkenglas> (That one's [a] -> [Lens' [b] b], but you just gave the way to get a list from a traversal ^^)
06:04:58 <mpickering> I agree it is possible to write such a function. 
06:05:26 <von_cidevant> tdammers: Couldn't match type ‘Data.Text.Internal.Text’ with ‘Data.Text.Internal.Lazy.Text’
06:05:39 <divVerent> lyxia: actually... Data.Bool.Extras's "cata" is of type (a, a) -> Bool -> a
06:05:45 <divVerent> why did Hoogle not find it?
06:05:51 <divVerent> :t cata
06:05:52 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
06:06:14 <divVerent> :t Data.Bool.Extras.cata
06:06:16 <lambdabot> Not in scope: ‘Data.Bool.Extras.cata’
06:06:37 <kadoban> Is there a package that can show amounts of time in a friendly manner? Thinking like it does on some blogs, like "6h ago" or "20m ago" instead of 6:04:20.34334 or whatever fixed format.
06:06:42 <lyxia> divVerent: it might not be on stackage
06:06:43 <Gurkenglas> You just mean there isn't one already defined in the library - what about elegantly definable from combinators?
06:07:21 <mpickering> Doesn't seem likely to me
06:08:13 <mpickering> You essential want "contextMap :: ([a] -> (a -> a)) -> [a] -> [a]"
06:09:28 <mpickering> If you want the context to be the whole list, with previous changes then you would need to perform in-place updates of the list
06:09:47 <mpickering> which isn't going to be efficient
06:10:02 <mpickering> What do you think?
06:10:09 <divVerent> lyxia: but where does this "bool" function then come from?
06:10:16 <lyxia> divVerent: Data.Bool
06:10:18 <divVerent> Data.Bool.Extras is where I found it
06:10:21 <divVerent> oh, I see
06:10:40 <divVerent> Data.Bool isn't on Hackage though :)
06:10:47 <lyxia> base
06:10:56 <divVerent> Doesn't Hackage index that?
06:11:06 <lyxia> It's base's Data.Bool.
06:11:20 <barrucadu> https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html
06:11:38 <lyxia> Nah, you can't search for modules on hackage.
06:11:52 <divVerent> ah, I see
06:12:01 <divVerent> thanks
06:12:05 <lyxia> For that you'd use hayoo or hoogle
06:12:18 <divVerent> yes, meant Hoogle
06:12:22 <divVerent> got confused by similar page layout :)
06:12:33 <guillaum2> I'm trying to create a class instance which match a specific type (Foo -> a) and another one which match any function (b -> a) and a final one which match anything else (t). I'm falling in an overlapping instance problem, is there a solution ?
06:12:33 <srhb> divVerent: There are also several Hoogles around. 
06:12:40 <divVerent> We've got BOTH kinds of booleans: "otherwise" and "not otherwise" :)
06:12:52 <srhb> divVerent: for instance, hoogle.haskell.org vs. haskell.org/hoogle
06:13:07 <divVerent> the latter is what I normally use
06:13:32 <divVerent> hehe, maybe this would be useful: when Hoogle outputs too many results, can I restrict the search to base (or even Prelude)?
06:13:40 <divVerent> well, sort of I can
06:13:49 <divVerent> https://www.haskell.org/hoogle/?hoogle=bool+%2bbase
06:13:54 <ongy> srhb: kinds of booleans?
06:13:55 <divVerent> but this doesn't output the "bool" function either
06:14:17 <lyxia> guillaum2: is the overlapping instance meant as an optimization or do they have different semantics altogether?
06:14:42 <srhb> divVerent: That I don't understand.
06:15:00 <mpickering> guillaum2: It is recommended to avoid OverlappingInstances
06:15:25 <divVerent> https://www.haskell.org/hoogle/?hoogle=a+-%3E+a+-%3E+Bool+-%3E+a+%2Bbase - also doesn't list this function
06:15:50 <lyxia> yeah haskell.org/hoogle has issues. I don't remember what exactly.
06:16:12 <von_cidevant> tdammers: it works ))) text $ "MSG_ID" <> mo_messageId <> "; SOURCE:" <> mo_source
06:16:17 <guillaum2> mpickering: actually I don't want OverlappingInstances, I want to solve a problem and for now I don't see any solution and the current draft of solutions involves overlapping instances...
06:16:33 <von_cidevant> tdammers: thank you very much !!)) Love this community
06:17:22 <mpickering> guillaum2: What problem are you trying to solve? The way type class resolution works is it first matches on the type constructor (in this case (->)) so both of your instances will match for functions 
06:17:31 <von_cidevant> Another question: How to make PARAM in Scotty conditional
06:17:36 <von_cidevant> ??
06:18:24 <Gurkenglas> How feasible would it be to have hoogle ask ghci to unify the query with all functions in its database? (Maybe even unify all versions of the query that had a function of the form \f a b c -> f c b a applied to them, or try to unify with all typechecking combinations of up to three or so functions from the database)
06:18:52 <lyxia> divVerent: hoogle.haskell.org works better, but it's WIP
06:19:18 <guillaum2> mpickering: if my type is a function where first argument is T, I want first instance. If it is a function where first argument is not T, I want second instance, else I want the third instance.
06:19:20 <mpickering> It would require quite  major restructuring as it currently works using haskell-src-exts iirc
06:19:25 <divVerent> "Warning: Alpha version, type search doesn't work!"
06:19:27 <divVerent> hehe
06:19:33 <divVerent> didn't even know it has ANOTHER search ;)
06:19:45 <srk> is there a bytestring prettyprinter? or an example how to define instances for ADTs for prettyprinting
06:19:47 <guillaum2> mpickering: this looks like a closed typeclass if this even exists.
06:19:48 <divVerent> it does find bool :: a -> a -> Bool -> a as first result for "bool" though
06:20:07 <divVerent> but to me function type search DOES seem to work
06:20:11 <mpickering> guillaum2: This kind of logic isn't possible to express using type classes as far as I know
06:20:12 <divVerent> good to know, thanks!
06:21:17 <guillaum2> mpickering: ;( Thank you.
06:21:22 <lyxia> guillaum2: If there are only a few types other than T that are supposed to appear on the left of (->) in such instances, you can implement an instance for each of them to avoid overlapping instances.
06:22:05 <Gurkenglas> Thats okay if it uses haskell-src-exts, as long as it already also does unification?
06:22:31 <mpickering> I'm not sure
06:23:23 * hackagebot hw-prim 0.0.3.8 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.0.3.8 (haskellworks)
06:24:01 <guillaum2> lyxia: in my dreams it should be generic for any type ;)
06:24:47 <mpickering> guillaum2: You could write a generic function using typeable if you really want this
06:33:23 * hackagebot language-conf 0.2.1.0 - Conf parsers and pretty-printers for the Haskell programming language.  https://hackage.haskell.org/package/language-conf-0.2.1.0 (yamadapc)
06:51:24 <guillaum2> mpickering: I did not thought about generic function. I should try, you are right.
06:51:41 <mpickering> If you think this is truly what you want!
06:52:10 <mpickering> I would advise searching for OverlappingInstances on google as there are many many threads about them and techniques to avoid it
06:53:24 * hackagebot currency-convert 0.2.1.0 - Typesafe currency conversion  https://hackage.haskell.org/package/currency-convert-0.2.1.0 (pigworts2)
06:55:51 <tdammers> mpickering: the most baffling one being "don't use so many instances"
06:59:06 <jgzh6> Still can't work out the currency converter problem
06:59:07 <jgzh6> http://lpaste.net/177664
07:00:12 * orion just compiled GHC 8 on a c3.8xlarge EC2 instance in 10 minutes.
07:04:58 <ertes> can we please remove those stupid, misleading hlint "errors" from lpaste?  i'm inclined to recommend other pastebins over lpaste right now
07:05:17 <lyxia> jgzh6: You're getting a type error, right?
07:05:26 <jgzh6> Yep
07:05:45 <kadoban> ertes: No. They're mostly good.
07:05:50 <lyxia> because you can't assign a proper type to func, since the type of the results depends on the *value* of its argument
07:06:10 <ertes> kadoban: they aren't good…  you like them, and that's all
07:06:13 <ertes> it's subjective
07:06:39 <jgzh6> I am not sure how to correct the function or codes to make it work
07:07:17 <jgzh6> Is it something to do with immutability..?
07:07:58 <kadoban> ertes: K. Well, a lot of other people appreciate them too, so I doubt they're going anywhere.
07:08:07 <lyxia> jgzh6: you can have func convert the result to AUD
07:08:25 * hackagebot hw-rankselect 0.2.0.1 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-rankselect-0.2.0.1 (haskellworks)
07:08:42 <ertes> kadoban: i don't mind them being there, but nothing indicates that they are merely style notes, and that the "errors" are not "errors"
07:09:05 <ertes> turn everything into warnings, and clearly indicate that these are *subjective style notes* and nothing else
07:09:40 <jgzh6> hm... I'm lost how it could be done..
07:09:47 <ertes> like the lpaste developer/maintainer is trying to force their style on everybody
07:10:22 <Welkin> I see that too ertes
07:10:44 <Welkin> almost all of them are just suggestions
07:10:51 <Welkin> like getting rid of extra parens
07:11:05 <ertes> *all* of them are suggestions, and some of them are good…  others are just stupid
07:11:31 <lyxia> jgzh6: http://lpaste.net/177664 something like that
07:15:16 <jgzh6> hm.. Not in scope : convert
07:16:06 <lyxia> jgzh6: oh right, I thought that was a global.
07:16:42 <jgzh6> and my mistake is I shouldn't have included "k <- getArgs" : sorry for this. 
07:17:19 <lyxia> jgzh6: refresh the annotation
07:20:09 <jgzh6> mycc.hs:15:51:     Couldn't match expected type `Converter'                 with actual type `Currency a0 -> Currency b0'     Probable cause: `convert' is applied to too few arguments     In the first argument of `func', namely `convert'     In the first argument of `show', namely `(func convert i 1)'
07:21:34 <lyxia> :'(  ok. I start compiling my stuff before putting it online
07:33:32 <damiansoriano> hello, I am trying to use conduit to send a post request to a service, my body is a string and ghc is complaining about "Couldn't match expected type RequestBody  with actual type [Char]"
07:33:38 <damiansoriano> I am using overloadedStrings
07:33:50 <lyxia> jgzh6: did you change this line back "convert <- getDefaultConverter"?
07:34:03 <damiansoriano> not sure what is the problem here.... the main thing I think is that I need to concatenate two strings to create the requestBody
07:34:13 <damiansoriano> does anyone know how can I solve that thing?
07:35:10 <lyxia> damiansoriano: is your request body a literal string?
07:35:17 <c_wraith> damiansoriano: there are different kinds of RequestBody, for different use cases.
07:35:27 <c_wraith> damiansoriano: Look at the constructors for it, and choose the right one.
07:35:36 <damiansoriano> right.. I am trying to generate a JWT and include the JWT in the request body
07:35:53 <jgzh6> My bad.
07:36:05 <jgzh6> I'm sorry I didn't change
07:36:09 <jgzh6> It works now
07:36:12 <lyxia> nice
07:36:14 <damiansoriano> I don't understand how this works if I pass the actual string (without constructing it dynamically)
07:36:22 <jgzh6> But the output is Currency 1.0\n\nCurrency 1.6772340914311967\nCurrency 1.2927844178840195\nCurrency 0.19528700583105976
07:36:42 <jgzh6> instead of unlined output
07:37:04 <jgzh6> How could I correct this?
07:37:10 <lyxia> jgzh6: you wrote "\\n" but newline is actually "\n"
07:37:24 <jgzh6> even in Windows system?
07:37:55 <jgzh6> Oh
07:37:59 <jgzh6> Works
07:38:02 <jgzh6> perfect
07:38:11 <jgzh6> Thank you so much lyxia
07:38:32 <hpc> "\\n" is \n
07:38:37 <hpc> "\n" is newline
07:38:54 <jgzh6> Right. Thanks
07:39:25 <hpc> and usually things operate in text mode, so the OS-specific newlines get converted to \n anyway
07:40:01 <jgzh6> ah ha.. ok.
07:40:46 <jgzh6> Really appreciate solving this problem. Thanks again lyxia. Have a nice day
07:41:08 <lyxia> You're welcome.
07:41:57 <c_wraith> damiansoriano: Assuming you're using http-conduit (the exact package name is useful to have), you need a RequestBody value
07:42:05 <kamyar> Hello everyone
07:42:07 <c_wraith> damiansoriano: https://hackage.haskell.org/package/http-conduit-2.2.0/docs/Network-HTTP-Conduit.html#t:RequestBody
07:42:22 <kamyar> Please help me about a Haskell question
07:42:26 <c_wraith> damiansoriano: You'll note it's not the same thing as a String.  In fact, it has a bunch of different constructors, for a bunch of different use cases.
07:42:29 <kamyar> http://stackoverflow.com/questions/22742001/what-is-pipes-conduit-trying-to-solve
07:42:36 <kamyar> what does '<>' operator mean here?
07:42:51 <kamyar> in first answer I mean
07:42:56 <jaspervdj> kamyar: It's an alias for `mappend`
07:42:58 <c_wraith> damiansoriano: and none of the constructors take a string, because http is defined in terms of byte streams, not strings
07:43:17 <kamyar> jaspervdj: Thanks
07:43:24 <jaspervdj> kamyar: So in this case concatenating the two chunks
07:43:33 <damiansoriano> c_wraith: thanks for the reply... http-conduit is the best lib to use if I just one to make https calls (like simpleHTTP)?
07:43:44 <damiansoriano> I am not interested in streaming or anything
07:43:57 <c_wraith> damiansoriano: So, you need to first convert your string to bytes, then use an appropriate RequestBody constructor on it.
07:44:08 <c_wraith> damiansoriano: no library will free you from needing to do the right thing.
07:44:29 <c_wraith> damiansoriano: http doesn't use strings.  Pretending it does will break lots of things.
07:44:42 <damiansoriano> c_wraith: understood, just wanted to know if there is something smaller than http-conduit for just doing https posts
07:44:52 <damiansoriano> c_wraith: thanks for the replies :)
07:45:17 <hpc> you could spend days going through all the http libraries on hackage
07:45:27 <kamyar> jaspervdj: Thanks again. I think it would better be >< haha
07:45:32 <c_wraith> damiansoriano: so convert your string to a ByteString by going through an appropriate transformation, then use RequestBodyBS to make it into the request body
07:46:40 <c_wraith> kamyar: it comes from CS literature, where using a diamond is common.  <> is an ascii equivalent
07:50:04 <c_wraith> damiansoriano: it looks like wreq may actually handle this case better..  assuming String is an element of the Postable class
07:50:04 <c_wraith> @hackage wreq
07:50:04 <lambdabot> http://hackage.haskell.org/package/wreq
07:52:51 <damiansoriano> c_wraith: wreq uses lens... know nothing about lens unfortunatelly :/
07:53:06 <c_wraith> damiansoriano: you don't really need to know anything about lenses to use them.
07:53:56 <c_wraith> damiansoriano: all you need to know to use wreq is that (^.) gets a named field out of a structure.
07:55:09 <damiansoriano> c_wraith: ok, will take a look... so you think that is better to use wreq that conduit if I just want to post https?
07:55:50 <c_wraith> damiansoriano: I suspect so.  My internet currently is slow enough that installing wreq is taking a few minutes, so I haven't verified yet
07:56:05 <sshine> @pl \x -> (x,x)
07:56:05 <lambdabot> join (,)
07:57:11 <damiansoriano> c_wraith: I am surprise... make https calls should be a non-problem... it's quite painful all the research someone needs to do to understand the best way to make https calls
07:57:33 <damiansoriano> in other languages, it's a non-problem
07:57:46 <c_wraith> I wouldn't say that.  Most libraries get it wrong in all languages.
07:58:10 <c_wraith> They let you do something that "works", but is totally insecure in the face of any sort of attack.
07:58:12 <geekosaur> most languages cater to people who think that encodings are little fairies that figure out what to do magically
07:58:36 <damiansoriano> you may be right... 
08:03:25 <c_wraith> in all honesty, wreq also makes it really easy to do https wrong. 
08:05:45 <oherrala> c_wraith: wreq's tls issues come from http-client-tls and it's issues come from tls
08:06:16 <tsahyt> @hoogle [a] -> Maybe a
08:06:18 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
08:06:18 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
08:06:18 <lambdabot> Prelude head :: [a] -> a
08:07:30 <sshine> :t (liftM, join)
08:07:31 <lambdabot> (Monad m, Monad m1) => ((a1 -> r) -> m a1 -> m r, m1 (m1 a) -> m1 a)
08:08:09 <oherrala> c_wraith: we have been developing little tool to test TLS client implementations in libraries: https://github.com/ouspg/trytls
08:09:23 <oherrala> c_wraith: there's wreq and http-client-tls test stubs under stubs/ :)
08:11:23 <sm> nice
08:13:12 <oherrala> For current state of languages and Linux distros: https://github.com/ouspg/trytls/tree/master/shootout (haskell not included (yet))
08:13:27 * hackagebot chatter 0.9.0.0 - A library of simple NLP algorithms.  https://hackage.haskell.org/package/chatter-0.9.0.0 (RoganCreswick)
08:13:51 <sm> very nice!
08:14:33 <oherrala> sm: Thanks. I forwarded your comments to team :)
08:14:54 <tsahyt> This is something I've been wondering about for a while. What's the most elegant way to temporarily wrap a Maybe around a monadic computation, i.e. short circuit to Nothing when part of it fails.
08:17:18 <hexagoxel> tsahyt: MaybeT (? have not read much backlog..)
08:18:04 <hexagoxel> maybeVal <- runMaybeT $ do { monadicStuffThatCanFailViaNothing; .. }
08:18:38 <tsahyt> but then I'd have to pull in transformers again and mix mtl and transformers
08:19:26 <tsahyt> either that or my docs are broken
08:19:51 <Myrl-saki> errr
08:19:53 <Myrl-saki> guys
08:20:46 <Myrl-saki> i don't know if i made a mess with my environment, but using NixOS and `nix-shell -p haskellPackages.random ghc` didn't expose the random package to GHCi.
08:20:46 <hexagoxel> tsahyt: "mix mtl and transformers" but mtl is based on transformers..
08:21:22 <tsahyt> hexagoxel: I just figured that out yep. I wonder if I can get similar behavior with MonadError from mtl though. More finegrained error reporting via Either would be beneficial I think
08:22:34 <hexagoxel> tsahyt: EitherT/ExceptT
08:22:35 <tsahyt> ExceptT that is
08:22:49 <tsahyt> what's the difference between EitherT and ExceptT?
08:23:16 <maerwald> MonadThrow is nice too, but it's not lossless
08:23:25 <maerwald> you lose specific info of the exception type
08:23:32 <maerwald> gets converted to SomeError or so afair
08:24:03 <tsahyt> maerwald: MonadThrow provides a lot more than I need though as I can handle the error a few lines of code later. Besides, it adds another dependency.
08:24:14 <c_wraith> oherrala, that's awesome work. and for the record, I wasn't really criticizing wreq. the fact is, the problem is hard, and most people want to ignore it, and libraries tend to try to make their users happy. :) 
08:24:26 <maerwald> tsahyt: but it allows the caller to decide what's gonna happen... throwing an exception, converting to Maybe, converting to Either etc
08:24:43 <oherrala> c_wraith: I agree
08:24:47 <tsahyt> maerwald: which is awesome, but much more than I need right now
08:24:58 <tsahyt> this is an internal function, not something that's exposed
08:25:04 <oherrala> c_wraith: And the lack of response to my issues (to wreq and http-client-tls) is concerning
08:28:27 <oherrala> c_wraith: btw, have you tried the libtls from LibreSSL?
08:28:38 <c_wraith> no
08:29:43 <glguy> oherrala: Is this one still valid? https://github.com/snoyberg/http-client/issues/212
08:29:47 <oherrala> for any new need for tls client/server that might be my current choice.
08:30:08 <oherrala> glguy: I can test it. moment
08:30:51 <glguy> oherrala: Connecting via the connection package, via the tls package, I got: *** Exception: HandshakeFailed (Error_Protocol ("certificate rejected: [NameMismatch \"wrong.host.badssl.com\"]",True,CertificateUnknown))
08:31:35 <glguy> oherrala: Oh, but going via your test case it still opens
08:32:23 <oherrala> takes some time to build everything with stack from lts-6.12
08:32:55 <glguy> Then don't do that :-p
08:33:08 <glguy> But anyway, your test case still fails, but in other contexts tls package gets it right
08:33:24 <glguy> so maybe it's a matter of http-client-tls providing the wrong TLSSettings
08:33:33 <oherrala> could be
08:34:54 <glguy> OK, I found the setting that makes the difference: clientUseServerNameIndication :: Bool
08:34:57 <oherrala> glguy: I can confirm #212 is still issue with at least lts-6.12 set of libs
08:34:59 <glguy> Allow the use of the Server Name Indication TLS extension during handshake, which allow the client to specify which host name, it's trying to access. This is useful to distinguish CNAME aliasing (e.g. web virtual host).
08:35:52 <glguy> http://hackage.haskell.org/package/tls-1.3.8/docs/Network-TLS.html#g:1
08:35:54 <oherrala> glguy: I don't think it's problem in SNI
08:36:11 <oherrala> SNI works fine in http-client-tls
08:36:24 <glguy> oherrala: Turning that *on* enables the bug
08:37:09 <glguy> Turning it off causes the connection to be rejected
08:37:36 <glguy> or are you saying that it's just rejecting it earlier and isn't related to the bug
08:37:45 <oherrala> ah
08:38:02 <oherrala> fresh set of results when running https-client-tls in TryTLS: http://lpaste.net/177674
08:40:33 <glguy> The last two failures with RC4 could be avoided by specifying ciphersuite_strong :: [Cipher] in the connection settings when making the manager
08:43:42 <oherrala> glguy: that's one thing I have been thinking about: Should the test stub use the defaults from lib or should it be tweaked for best results? :)
08:44:30 <glguy> oherrala: I think it should distinguish between bad defaults and bad implementation
08:44:39 <von_cidevant> Guys, any idea how to parse Query params into my data Type ?
08:45:00 <glguy> supporting RC4 isn't a bug, not validating a certificate is
08:45:52 <von_cidevant> i got [(key:: String, value:: String)], a want to build a type: key is accessor (string reperesentation) of my type..
08:45:57 <von_cidevant> Any ideas?
08:46:03 <oherrala> glguy: agree. Some of the fails are not as serious as others. RC4 being one test case has been part of the discussions lately.
08:46:08 <kadoban> Supporting RC4 without at least a huge warning is probably not a good idea.
08:46:36 <kadoban> Well, maybe it's not that bad, I dunno.
08:47:05 <Gurkenglas> von_cidevant, you want to say "type Foo = [(String, String)]"?
08:48:12 <oherrala> kadoban: making the decision is really hard. That's why I have used the recommendations from Mozilla: https://wiki.mozilla.org/Security/Server_Side_TLS
08:48:39 <oherrala> kadoban: not in TryTLS, but in sysadmin thingies
08:49:02 <von_cidevant> Gurkenglas: http://lpaste.net/177678
08:49:08 <oherrala> oh, from that page: "As of February 2015, the IETF explicitely prohibits the use of RC4: RFC 7465."
08:49:28 <von_cidevant> Gurkenglas: Is there any simple solution ?
08:49:38 <kadoban> Yeah, that's a pretty big sign it should just not be used silently then :-/
08:50:00 <Gurkenglas> von_cidevant, where does params come from?
08:50:41 <von_cidevant> Gurkenglas: http://hackage.haskell.org/package/scotty-0.10.2/docs/Web-Scotty.html#v:params
08:50:44 <oherrala> kadoban: yeah, RFC says: ''TLS clients MUST NOT include RC4 cipher suites in the ClientHello message.''
08:51:41 <von_cidevant> Gurkenglas: It should by something like this: reqParams <- params
08:52:21 <oherrala> glguy: heh, according to RFC7465 supporting RC4 is a bug :)
08:52:27 <glguy> oherrala: OK, I'm sold, then.
08:52:39 <von_cidevant> Gurkenglas: I've just updated lpaste
08:54:07 * glguy disables those bugs in his IRC client
08:54:28 <oherrala> glguy, kadoban; I'll try to squeeze time to make issues for http-client-tls and tls libs if you don't do it before :)
08:54:35 <Gurkenglas> von_cidevant, Param is (Text, Text), so params is a list of pairs of texts, not Strings/Ints - if params is actually [(Text, Text)], and if you already have findValueForKey, you can do let a = MyType (read $ unpack $ findValueForKey "msg_id" params) (read $ unpack $ findValueForKey "msg_txt" params)
08:54:52 <glguy> oherrala: It sounds like you have the references prepared already
08:55:28 <von_cidevant> Gurkenglas: Thx, man! I am searching for some ready FN) Is there any kind of  "findValueForKey" fn ?
08:55:41 <oherrala> glguy: btw. test your IRC client's TLS things with trytls ;)
08:55:46 <von_cidevant> Gurkenglas: for searching in tuples?
08:55:56 <Gurkenglas> :t lookup
08:55:57 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
08:56:08 <alercah> yeah, that works, but you really shouldn't use that for a list
08:56:13 <Gurkenglas> von_cidevant, though you probably want http://hackage.haskell.org/package/scotty-0.10.2/docs/Web-Scotty.html#v:param instead of that whole ordeal
08:56:14 <alercah> use a Data.Map
08:56:18 <von_cidevant> Gurkenglas: I love you !!
08:56:40 <Gurkenglas> alercah, it's fine if the list is short
08:56:53 <von_cidevant> Gurkenglas: I cant use `param` of Scotty, because my query params are not required
08:57:01 <glguy> oherrala: I use the tls package, so I'm going to be vulnerable to all of the things the other two are
08:57:11 <glguy> other than that I've turned off SNI and use the strong ciphersuite
08:57:34 <oherrala> glguy: why turn off SNI?
08:57:37 <Gurkenglas> von_cidevant, ah so you actually need to handle the case where the param doesnt exist?
08:57:44 <von_cidevant> Gurkenglas: So when I do something like this: myParam <- param "QUERY_PARAM_NAME", and QUERY_PARAM_NAME doesnt exists - scotty returns 500
08:57:45 <kadoban> Err, don't turn off SNI, that breaks a lot of legitimate sites.
08:57:52 <glguy> it's an IRC client
08:58:15 <oherrala> IRC server can probably use SNI, no?
08:58:17 <von_cidevant> Gurkenglas: Yes, you are right
08:58:23 <kadoban> Oh. Well I guess if the IRC servers you use don't require it.
08:58:26 <glguy> oherrala: I guess we'll find out
08:58:43 <glguy> leaving it on exposes bugs in the certificate validation
08:59:01 <glguy> not validating certificates would allow me to connect to even more servers
08:59:10 <oherrala> yep :)
08:59:50 <Gurkenglas> Weird that scotty doesnt have paramMay :: Parsable a => Text -> ActionM (Maybe a)
09:00:32 <oherrala> glguy: what was that irc client of yours? It has been open tab in my browser, but I have lost it
09:00:33 <von_cidevant> Gurkenglas: Yeahh.. Thats why I am dancing like monkey with this params
09:00:47 <von_cidevant> Gurkenglas: But you helped me with `lookup` )
09:01:01 <glguy> oherrala: https://hackage.haskell.org/package/glirc https://github.com/glguy/irc-core
09:01:09 <oherrala> thanks
09:01:21 <von_cidevant> Gurkenglas: Thank you, man !) If you have better idea how to handle this situation - will be pleased to hear that)
09:01:23 <glguy> This weekend's project has been adding a plugin API with Lua scripting as one of the plugins
09:01:29 <orion> Is anyone running GHC on a Linux 4.4 kernel?
09:02:34 <sm> I think I am
09:03:59 <Gurkenglas> von_cidevant, https://github.com/scotty-web/scotty/blob/9c885a036b20694e1ab26a4ae08bdd7feac8bc20/Web/Scotty/Action.hs#L188 :D
09:04:18 <Gurkenglas> The correct action is to submit a pull request to scotty to add paramMay
09:04:23 <cocreature> orion: is 4.4 important or >= 4.4? I’m currently using 4.7 and somewhere along the way I used 4.4 :)
09:06:09 <von_cidevant> Gurkenglas: They are saying, that paramMay can be achieved with `rescue` method
09:06:11 <glguy> oherrala: If you do happen to try it and have any questions or ideas or feedback there's #haskell-irc
09:07:35 <von_cidevant> Gurkenglas: I will try to wrap my fn in rescue
09:08:19 <oherrala> glguy: thanks, joined already :)
09:21:24 <magneticduck> does everybody use single-letter type variables?
09:22:15 <nitrix> Commonly.
09:22:15 <kadoban> magneticduck: Usually. It's fairly often hard to give them anything more meaningful.
09:22:21 <phadej> magneticduck: occasionally
09:23:01 <magneticduck> I don't think I've ever seen actual names given to type variables in a library I use
09:24:05 <phadej> magneticduck: which is ...?
09:24:28 <magneticduck> existential qualifiers
09:24:42 <magneticduck> qualifier* -- I haven't seen names used in any library I use
09:24:57 <nitrix> You mean quantifiers ?
09:25:28 <nitrix> quantified and qualified are different things.
09:25:41 <magneticduck> right
09:26:00 <argent0> Hi, if I have the type: `data Fin :: Nat -> *` with the usual definition, is it posible to write a function `int2fin :: Integral a => a -> Fin n'?
09:27:26 <phadej> argent0: nope, one can write `-> Maybe (Fin n)` (if requested wrong `n`) or `Some Fin`
09:27:35 <phadej> to existentially hide the `n`
09:28:21 <argent0> phadej: ok, but it complains that It doesn't know the n part of the (Fin n)
09:29:52 <phadej> argent0: check reifyNat in http://hackage.haskell.org/package/reflection-2.1.2/docs/Data-Reflection.html
09:30:12 <argent0> phadej: will do, thanks
09:32:05 <johnw> that uses continuation-passing style to communicate the existential; by using KnownNat, the recipient can reflect on the argument and determine the value of n
09:33:56 <Gurkenglas> von_cidevant, usually I would say having an exception thrown in a run where everything went correctly is bad style, but if the very package recommends it...
09:35:50 <von_cidevant> Gurkenglas: I agree with you
09:36:16 <von_cidevant> Gurkenglas: Probably I will use 'lookup' instead
09:36:33 <sshine> is there something like Data.Trie for Data.Text?
09:40:19 <Gurkenglas> In fact... everyone, shouldn't https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Error-Class.html#v:catchError have type m a -> (e -> m e) -> m a instead? (Or perhaps something zoom/magnify-like instead.)
09:40:38 <Gurkenglas> (And of course the arguments are the wrong way round)
09:42:12 <sshine> :t Control.Monad.Error.Class.catchError
09:42:13 <lambdabot> MonadError e m => m a -> (e -> m a) -> m a
09:42:37 <sshine> like that?
09:44:34 <tsahyt> @hoogle Maybe a -> ExceptT e m a
09:44:35 <lambdabot> Control.Monad.Trans.Except throwE :: (Monad m) => e -> ExceptT e m a
09:44:35 <lambdabot> Control.Monad.Trans.Maybe maybeToExceptT :: (Functor m) => e -> MaybeT m a -> ExceptT e m a
09:44:45 <tsahyt> @hoogle e -> Maybe a -> ExceptT e m a
09:44:45 <lambdabot> No results found
09:52:43 <von_cidevant> How to check, if array of Maybe are all JUST ?
09:53:40 <Welkin> isJust
09:53:43 <Clint> > sequence [Just 1, Just 2, Just 3]
09:53:45 <lambdabot>  Just [1,2,3]
09:53:49 <Clint> > sequence [Just 1, Nothing, Just 3]
09:53:51 <lambdabot>  Nothing
09:54:01 <Welkin> > all isJust [Just 3, Just 5, Nothing]
09:54:04 <lambdabot>  False
09:54:08 <Welkin> > all isJust [Just 3, Just 5, Just 9]
09:54:10 <lambdabot>  True
09:54:40 <Welkin> von_cidevant: you mean a list, right?
09:54:54 <von_cidevant> Welkin: yeat )) 
09:58:30 * hackagebot dotenv 0.3.0.3 - Loads environment variables from dotenv files  https://hackage.haskell.org/package/dotenv-0.3.0.3 (jpvillaisaza)
10:04:37 <nitrix> all (isn't _Just) ?
10:05:10 <nitrix> If you like lenses.
10:05:31 <nitrix> (prisms)
10:08:30 * hackagebot diagrams-lib 1.3.1.4 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.3.1.4 (BrentYorgey)
10:11:14 <nitrix> Are MonadName type classes common and recommended for deriving newtypes?
10:12:01 <dmwit> Common, yes. There are many folks around me that recommend writing an API and not deriving the usual classes.
10:12:15 <dmwit> Not sure I agree with them, but anyway my point is "recommended or not" is a bit up in the air.
10:12:59 <dmwit> Upsides of deriving them: the compiler writes a bunch of code for you, and people familiar with mtl will be up and running quickly by looking at the instance list.
10:13:16 <nitrix> My point is, my library offers like 15 monadic functions, and for someone using a stack of monad transformers as a newtype, it's a little painful for them to rewrap all these functions and lift them accordingly.
10:14:03 <dmwit> Downsides of deriving them: there may be a semantic mismatch between your intended API and the API you automatically get; stacks built on top of your thing will be more ambiguous.
10:14:11 <nitrix> So I was thinking, maybe a `class Monad m => MonadName m` would be useful, as they could simply derive it.
10:14:22 <nitrix> dmwit: Gotcha.
10:14:42 <dmwit> Oh, perhaps I misunderstood your question. Was `MonadName` intended to be an actual class? I thought that was a metavariable for the various existing mtl classes.
10:15:04 <nitrix> dmwit: It'd be a class, I'd mimick how MonadState works.
10:15:19 <dmwit> Oh, that's a very different question, then.
10:15:53 <dmwit> If you're building on top of mtl, defining a new class of monads can be a good idea.
10:16:30 <dmwit> e.g. MonadRandom is a great example of this
10:16:49 <dmwit> Under the hood, it's just `StateT`, but because they define a new class they don't have to overload the `MonadState` methods in a weird way.
10:16:55 <nitrix> Yeah that's what I'm doing.
10:17:00 <nitrix> Or intend to rather.
10:17:18 <nitrix> newtype Game a = Game { unwrapGame :: EnvironmentT (MaybeT (StateT GameState IO)) a } deriving (Functor, Applicative, Monad, MonadState GameState)
10:17:18 <dmwit> dmwit approves
10:19:27 <nitrix> The only downside is that, the class has to implement instances for all of the common transformers (and eventually support additional ones if I add them), but it's not that bad.
10:20:25 <nitrix> I'm just worried that the user of the library tries to derive my class on a transformer I didn't consider (mayeb provided by another library?)
10:20:32 <nitrix> Then things would break badly, no?
10:20:55 <dmwit> I'm not sure I understand the concern yet.
10:21:10 <dmwit> Are you asking whether overlapping instances would be bad?
10:21:39 <nitrix> dmwit: I'd write the instances of MonadName for EnvironmentT, MaybeT, StateT, which would work for my own use case, using my library.
10:22:28 <nitrix> dmwit: But if another user has a more complicated stack of monad transformers (additional ones that I didn't consider), then they wont be able to derive the class, right?
10:22:54 <dmwit> Usually the way it works is you define a fresh monad transformer which implements the MonadName interface.
10:23:00 <dmwit> Then all the other transformers just lift that instance.
10:23:15 <nitrix> Oh you're right.
10:23:25 <nitrix> So I need the class, and a transformer, to play happy with other libraries.
10:23:31 * hackagebot diagrams-cairo 1.3.1.1 - Cairo backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-cairo-1.3.1.1 (BrentYorgey)
10:23:42 <dmwit> right
10:23:52 <nitrix> dmwit: This is extremely valuable, thanks.
10:24:26 <nitrix> dmwit: Your reward is to know what it'll be named: RelationalT ;)
10:28:31 * hackagebot diagrams-canvas 1.3.0.6 - HTML5 canvas backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-canvas-1.3.0.6 (BrentYorgey)
10:28:33 * hackagebot diagrams-html5 1.3.0.7 - HTML5 canvas backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-html5-1.3.0.7 (BrentYorgey)
10:33:31 * hackagebot tubes 2.1.0.0 - Write stream processing computations with side effects in a series of  tubes.  https://hackage.haskell.org/package/tubes-2.1.0.0 (gatlin)
10:38:32 * hackagebot diagrams-svg 1.4.0.3 - SVG backend for diagrams drawing EDSL.  https://hackage.haskell.org/package/diagrams-svg-1.4.0.3 (BrentYorgey)
10:39:26 <Gurkenglas> How do I build this package using stack? http://lpaste.net/1738568856948965376
10:41:56 <nitrix> What's the tilda in front of  ~(x,y) <- foo
10:42:23 <glguy> nitrix: It makes it an "irrefutable" pattern
10:42:44 <glguy> the pattern won't be matched until x or y are used
10:42:55 <mpickering> Gurkenglas: The problem is that the package requires 7.10.3 but newer versions of http-conduit than in the last lts to use 7.10.3
10:42:58 <nitrix> glguy: So, lazy patterns?
10:43:09 <glguy> It's like writing:  xy <- foo; let x = fst xy; y = snd xy; ....
10:43:19 <mpickering> it seems to install fine using cabal for me 
10:43:30 <Gurkenglas> Then shouldnt stack exec -- cabal build work?
10:43:32 * hackagebot diagrams-rasterific 1.3.1.8 - Rasterific backend for diagrams.  https://hackage.haskell.org/package/diagrams-rasterific-1.3.1.8 (BrentYorgey)
10:43:46 <mpickering> or I guess you could choose a 7.10.3 resolver and fix the dependencies
10:43:54 <mpickering> does that use 7.10.3?
10:44:02 <nitrix> glguy: Appreciated, thanks.
10:44:18 <Gurkenglas> I don't know, how do I find out?
10:44:23 <glguy> Gurkenglas: You can do: stack init --resolver=ghc-7.10.3
10:44:56 <Gurkenglas> Thanks that worked.
10:45:15 <lispy> hvr: I'm having some trouble with the multi-ghc-travis tool. Do you have a minute to help me?
10:45:37 <Gurkenglas> Is specifying the correct ghc version always the thing to do in that case? If so, why doesn't stack do it?
10:45:41 <mpickering> lispy: Ask your question here and someone will answer if they know
10:46:07 <mpickering> I guess stack shouldn't try and use a 8.0.1 resolver when the base bound is for an older version. Maybe make a ticket.
10:46:24 <mpickering> lispy: A lot of people use that tool
10:46:45 <Gurkenglas> Ill make a github issue with a link to the ircbrowse of your line suggesting to make a ticket, right?
10:46:46 <lispy> This line (from the default generated script) fails with exit code 1: https://github.com/dagit/mattermost-api/blob/master/.travis.yml#L51
10:47:03 <lispy> I don't know enough about how this tool works to know why that might be happening
10:49:25 <Gurkenglas> In fact, lambdabot should have a command to do just that. @github-issue stack 19:45:02 to make an issue that has the line from that time in its title and a link to the ircbrowse of that line in its body (and then do @tell back to the issuer when there's an answer?) Problems: github.com/what?/stack; what timezone is it?
10:49:30 <glguy> lispy: You need happy
10:49:58 <lispy> glguy: ah, how did you know that?
10:50:10 <glguy> You have to look at the output of https://travis-ci.org/dagit/mattermost-api/jobs/152561936
10:50:18 <glguy> It said pretty-show failed to install
10:50:29 <glguy> if you look up where that happened there's an error message that says as much
10:50:53 <lispy> ah, I made the mistake of scrolling to the bottom :)
10:50:56 <lispy> Thank you!
10:51:08 <glguy> the bottom is where the error was about pretty-show failing
10:51:35 <glguy> missing alex or happy is my primary cause of failed builds
10:52:22 <glguy> lispy: Do you know how to add alex/happy to the multi-ghc-travis script? https://github.com/glguy/config-value/blob/master/.travis.yml
10:52:36 <glguy> If you don't you have to add the package, the envvars, and the path entries
10:55:21 <lispy> glguy: I looked in the lens .travis.yml
10:55:45 <lispy> looks pretty similar
10:55:51 <cloudhead> anyone have vim tags working with ghc 8.0?
10:56:14 <mpickering> cloudhead: Which tags program are you using?
10:56:29 <cloudhead> mpickering: hasktags & codex
10:56:51 <cloudhead> mpickering: but open to suggestions, mainly just want tag support with ghc 8
10:57:00 <joe9> need some advice, please? I have a function :: ExceptT CustomException IO () -- I want to run the function in a different thread. If there is an exception raised by the function, I want the main thread to stop/raise an exception too. How do I acheive this ? I am reading up on forkFinally. But, I am not sure what function I should call to stop/raise the exception in the main thread.
10:57:12 <mpickering> I use fast-tags which works still but works in quite a stupid way so it sometimes wrong
10:57:14 <cloudhead> and codex won't build, hasktags does build though with a small patch
10:58:08 <mpickering> It doesn't look like codex is maintained really
10:58:20 <lispy> hvr: glguy helped me solve it. So if you're reading your scrollback you can ignore me now :)
10:58:34 <cloudhead> mpickering: hmm that's too bad :(
10:58:43 <mpickering> actually maybe it doesn't look too bad
10:58:45 <synapticplastic> hey guys, I have a question about the >>= operator; how is it different from function composition? Is it just that it's composition within the context of a monad?
10:58:51 <synapticplastic> am I way off with that?
10:59:00 <mpickering> but I always found any non-trivial tooling to be quite brittle which is why I just use fast-tags now
10:59:11 <cloudhead> the dependency tree of codex is a rabbit hole of packages that don't support ghc8
10:59:29 <lispy> synapticplastic: are you familiar with join and fmap?
10:59:31 <cloudhead> such as 'machines'
10:59:59 <synapticplastic> @lispy yeah, although I'm still getting my head around join. fmap makes perfect sense.
11:00:00 <lambdabot> No module "yeah, although I'm still getting my head around join. fmap makes perfect sense." loaded
11:00:01 <cloudhead> mpickering: yeah same, I have a fairly simple setup, but didn't think tags would be so complicated, seeing as they are basically built into vim
11:00:10 <cloudhead> I'll have a look at fast-tags
11:00:14 <synapticplastic> lispy : yeah, although I'm still getting my head around join. fmap makes perfect sense.
11:00:24 <lispy> synapticplastic: I would say that join is he composition within a monad. Some people refer to join as multiplication in the monad.
11:00:41 <Cale> synapticplastic: It's more closely related to function application... you're taking the result of the first action, and applying the function to it to obtain a second action, whose result is the result of the overall combined action
11:00:48 <Cale> :t (=<<)
11:00:50 <lambdabot> Monad m => (a -> m b) -> m a -> m b
11:00:53 <Cale> :t ($)
11:00:56 <lambdabot> (a -> b) -> a -> b
11:00:56 <lispy> synapticplastic: So here is an exercise for you. Take some monads you know and write >>= in terms of join and fmap
11:01:07 <Cale> :t (<=<)
11:01:08 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
11:01:12 <Cale> ^^ this is more like composition
11:01:19 <Cale> :t (.)
11:01:19 <mpickering> I don't think join is really like composition (>=>) is about composition
11:01:21 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:01:28 <synapticplastic> ok, yeah, I see the type parallel
11:01:42 <Gurkenglas> :t flip Control.Concurrent.forkFinally (either throwIO pure) -- joe9, like this?
11:01:42 <joe9> Can anyone share a sample usage of forkFinally?
11:01:43 <lambdabot> IO () -> IO GHC.Conc.Sync.ThreadId
11:01:55 <synapticplastic> I'm going to play a bit in ghci and check back in a sec
11:02:01 <joe9> Gurkenglas: cool, Thanks.
11:02:05 <johnw> join could be seen as "composition of contexts", while >=> is composition of arrows that relate to that context
11:02:24 <lispy> johnw: That's a good way to think about it
11:02:52 <Cale> johnw, lispy: If only we knew what contexts were ;)
11:03:41 <glguy> Cale: They're on the left side of =>s
11:03:56 <maerwald> I don't see what Cales problem is with that term
11:04:11 <Cale> I tend to avoid the word "context" because of all the words people use surrounding monads, I think it's the easiest to misunderstand
11:04:23 <johnw> warm fuzziness
11:04:25 <maerwald> I think it's the best
11:04:28 <nitrix> Cale: I use contexts as an analogy to Functors as well.
11:04:33 <nitrix> It's much better than burrito or containers.
11:05:06 <Cale> I tend to talk about explicitly constructing action values now. What is the action we're producing?
11:05:22 <joe9> Gurkenglas: I have a synchronous exception that I want to pass to the forkFinally handler  http://bpaste.net/show/15394c7e653f Any suggestions, please?
11:05:27 <nitrix> Action bothers me as having side-effects, and this isn't what this is about.
11:05:30 <johnw> how is Identity an action? ;)
11:05:41 <synapticplastic> I guess my confusion is with the base concept, then, of application vs. composition. because the way I internally see something like (+1) . (+2) $ 3 is 3, then 3+2, then (3+2) +1
11:05:51 <joe9> Gurkenglas: http://bpaste.net/show/1e333268e8dd
11:06:47 <joe9> Gurkenglas: I would need to raise the ResponseException to SomeException
11:07:12 <joe9> Gurkenglas: probably, using withExceptT
11:07:17 <synapticplastic> is it just the the composition is combined before anything is applied? so that (+1) . (+2) $ 3 evals to a simpler (+3) 3 ?
11:07:24 <Cale> johnw: Well, return is surjective there -- actions of type Identity t simply produce a value of type t as their result, and have no additional information.
11:07:28 <maerwald> johnw: I dont even know how Maybe is an action
11:07:47 <ggole> synapticplastic: a tip, don't use a commutative operation like + if you are trying to figure out order
11:07:52 <maerwald> that's not the language an average non-haskell programmer uses
11:08:13 <Cale> synapticplastic: Well, the evaluation order is another thing -- no matter which order it is that we carry out evaluation, we're going to get 6 there.
11:08:38 <Cale> But lazy evaluation is outermost first, so we'll start with the ($)
11:09:14 <Cale> (+1) . (+2) $ 3 --> ((+1) . (+2)) 3
11:09:28 <Cale> and then the (.), because the function being applied is not a lambda
11:09:33 <synapticplastic> Cale : ok, following
11:09:46 <Cale>  --> (\x -> (+1) ((+2) x)) 3
11:09:58 <Cale>  --> (+1) ((+2) 3)
11:10:29 <Cale> and of course (+1) is syntax sugar for (\x -> x+1)
11:10:40 <Cale> --> (\x -> x+1) ((+2) 3)
11:10:51 <Cale> --> ((+2) 3)+1
11:11:06 <Cale> and then more syntax sugar...
11:11:12 <Cale> --> ((\x -> x+2) 3)+1
11:11:22 <Cale> --> (3+2)+1
11:11:28 <Cale> --> 5+1
11:11:30 <Cale> --> 6
11:12:22 <synapticplastic> Cale : I have teeth falling out from the amount of sugar here. Also, that makes great sense. I tried it with + and * together to get rid of the commutativity as well, it's clicking.
11:12:31 <Cale> But really, probably this whole thing gets simplified heavily by the compiler before it ever runs :P
11:12:46 <Cale> (.) and ($) are easy to inline, and generally do
11:13:01 <Cale> So you don't typically have to worry about costs associated with them
11:13:32 <Cale> But yeah, f . g is another function
11:13:40 <glguy> synapticplastic: fwiw + and * are both commutative operators
11:13:53 <Cale> The main thing about function composition is that you're putting functions together to obtain other functions
11:14:30 <Cale> Whereas function application, you're applying a function to an argument to obtain a result (which may or may not be a function)
11:14:31 <johnw> one might even suggest that that's what composition means :)
11:15:22 <Cale> Pretty much... that falls a bit short of a definition
11:15:43 <synapticplastic> :glguy of course, but for this ex it was (3*2)+1 vs (3+1) *2, just so I could see order :)
11:15:54 <Cale> But yeah, (f . g) = \x -> f (g x)
11:15:54 <Cale> vs. f $ x = f x
11:15:55 <synapticplastic> so application and composition are really close ideas.
11:15:57 <von_cidevant> Guys, I have one question about DO-NOTATION. What does "<-" mean ? For example I have :t params :: ActionM [Param]. Imagine, i am in do block and doing this "myVar <- params". What type of myVar is ??
11:15:57 <johnw> Cale: true, I forgot for a moment which channel I was on
11:16:12 <glguy> synapticplastic: Right, that's about associativity
11:16:30 <lispy> von_cidevant: the type of myVar is [Param]
11:16:33 <synapticplastic> ah right. 
11:16:48 <kadoban> von_cidevant: [Param]
11:16:59 <Cale> synapticplastic: It's also important to keep straight the difference between evaluation order vs. how the expressions are grouped (parenthesized)
11:17:18 <lispy> von_cidevant: "<-"  is going to bind the result of the thing on the right to the name on the left
11:17:33 <von_cidevant> lispy: kadoban: Bind ?? 
11:17:53 <von_cidevant> lispy: kadoban:  It must perform IO and then "provide value" ?
11:17:55 <lispy> von_cidevant: bind in the sense that you give something a name
11:18:10 <von_cidevant> lispy: Why taype is changed ?
11:18:18 <Cale> synapticplastic: With lazy evaluation, if you have f (g (h x)), it's f which is evaluated first, with its parameter bound to the as-yet-unevaluated expression (g (h x))
11:18:52 <joe9> glguy: What do you think of Control.Monad.Exception? http://hackage.haskell.org/package/control-monad-exception Is it the most recommended exception throwing mechanism?
11:18:52 <lispy> von_cidevant: It's not that it changed so much as you created a name for the value inside the ActionM monad
11:19:22 <glguy> joe9: I hadn't previously heard of that particular package
11:19:26 <von_cidevant> lispy: So I can think about it: Extracting value from Monad _
11:19:28 <von_cidevant> ??
11:19:37 <lispy> von_cidevant: yes
11:19:52 <lispy> von_cidevant: params is like a program that when you run it, it generates [Param]
11:19:59 <Cale> synapticplastic: It's always outermost first, and evaluation is driven forward by that outermost function or other sort of expression doing pattern matching -- expressions get evaluated because something wants to match them against a pattern.
11:20:27 <Cale> Well, I say "always", but really GHC is smart, and with optimisations turned on, it will find cases where it can bend the rules to be more efficient.
11:20:43 <Cale> The language is set up such that any evaluation order that terminates will produce the same result.
11:21:13 <Cale> So the compiler has a bunch of flexibility in the order in which it does things -- it's just that outermost-first is guaranteed to terminate if any evaluation order does.
11:21:36 <von_cidevant> lispy: Ok… Thank you. One more question. Param is defined: type Param = (Data.Text.Internal.Lazy.Text, Data.Text.Internal.Lazy.Text). How can I transform myVar :: [Params] into (String, String) ?
11:21:48 <von_cidevant> lispy: into [(String, String)]
11:21:53 <Cale> Innermost-first (strict) evaluation may in some cases not terminate even if outermost-first evaluation does, so the compiler has to be a bit cautious about which things it does in a strict fashion.
11:22:12 <nitrix> To demonstrate Cale's point:
11:22:14 <joe9> glguy:  What mechanism do you use to throw exceptions? if you do not mind answering. I have  a thread with ExceptT return type. I am trying to figure out how to raise that exception in the main thread.
11:22:15 <Cale> But if it can tell that you're eventually going to need something for sure, it might not wait to evaluate it later.
11:22:21 <nitrix> > length [undefined, undefined, undefined]
11:22:23 <lambdabot>  3
11:22:34 <lispy> von_cidevant: Yeah, if you go to here: https://www.haskell.org/hoogle/  and type in "Text -> String" it should show you the "unpack" function
11:22:54 <glguy> joe9: Raise the error in the main thread means you want to throw an IO exception? then I'd use throwIO
11:23:05 <Gurkenglas> joe9, since the runExceptT thing hasn't thrown the exceptions yet, you need to throw them yourself: forkFinally (runExceptT (marketInformationThread undefined undefined undefined undefined)) (either throwIO $ either throwIO pure). If it's supposed to be impossible that marketInformationThread throws an exception that does not use ExceptT, you could replace the leftmost throwIO by error.
11:23:27 <lispy> von_cidevant: how to use unpack to convert the list of tuples is left as an exercise :)
11:23:46 <von_cidevant> lispy: map (\x -> (unpack . fst $ x), (unpack . snd $ x) ) ?
11:23:52 <von_cidevant> lispy: Is it correct ?
11:24:04 <lispy> Yeah, that should work
11:24:30 <Cale> synapticplastic: But I would tend to say that all of this is a bit of a sidetrack when it comes to understanding the meaning of (>>=) for various monads.
11:25:14 <m___> Best FRP to use atm
11:25:27 <Cale> m___: I have to say Reflex ;)
11:25:35 <m___> no longer gtk+
11:25:35 <m___> ?
11:25:44 <Cale> gtk+ is not FRP
11:26:02 <lispy> Cale: hah, did you help write reflex?
11:26:21 <Gurkenglas> joe9, (error . displayException), that is, since exceptions are not Strings. No need to explicitly convert between exceptions anywhere.
11:26:23 <m___> misspoke then, I guess best library for GUI programming
11:26:28 <lispy> I see Ryan uploaded the package, but IIRC you work for him?
11:26:36 <Cale> lispy: Not really, but I'm working for the guy who did (Ryan Trinkle), and I helped him write earlier FRP systems which inspired Reflex.
11:27:18 <lispy> Cale: What do you think of FRPNow?
11:28:14 <maerwald> https://hackage.haskell.org/package/keera-hails-reactive-gtk
11:28:16 <Cale> m___: If you want to do just a traditional desktop GUI, then I guess gtk2hs is your best bet. But maybe check out reflex-dom and see if it does enough for you. If you compile a reflex-dom project with ghcjs, you get a web page GUI that will run in your browser. If you compile with GHC, you get a desktop application that will use GTK's webkit
11:28:23 <von_cidevant> lispy: But when I am in do block, I should do "myTransVar <- (map fn) paramsArray", it is enough to use let: let myTransVar = (map fn) paramsArray
11:28:33 * hackagebot gipeda 0.3.2.2 - Git Performance Dashboard  https://hackage.haskell.org/package/gipeda-0.3.2.2 (JoachimBreitner)
11:28:42 <von_cidevant> lispy: <- or let ?
11:28:49 <Cale> m___: I think for most GUI stuff that I would want to do, I would use reflex-dom now.
11:28:50 <von_cidevant> lispy: I think let
11:29:03 <von_cidevant> lispy: Coz there is no monad
11:29:43 <Cale> But at some point, we would really like to have a reflex module for gtk proper.
11:29:52 <lispy> von_cidevant: let doesn't "run actions" like '<-' will. Without knowing more about your program it's hard for me to say.
11:30:10 <Cale> lispy: I can't really comment on it, because I haven't looked at it too carefully yet
11:31:25 <von_cidevant> lispy: I am trying to construct my own data type, based on params in query (Scotty)
11:31:31 <lispy> von_cidevant: also, you don't need the parens in "let myTransVar = (map fn) paramsArray"
11:32:17 <merijn> Is GHC's binary format documented anywhere? i.e. can I inspect GHC produced libraries and figure out how to call functions in it? I know foreign exported function result in symbols for the wrapper, but presumably GHC needs to somehow find non-foreign exported symbols too
11:32:20 <m___> hlint 
11:32:36 <von_cidevant> lispy: But in Scotty there is no 'maybeParam'. There is only 'param' - required - if not found - crash 500. Params returns all params in request. So I have to find all params by key, and construct my data type
11:33:04 <von_cidevant> lispy: map fn = map (\x -> (unpack . fst $ x), (unpack . snd $ x))
11:34:01 <von_cidevant> lispy: But to search in [Params], I have to convert them to [(String, String)]  - and then use 'lookup'
11:35:32 <joe9> Gurkenglas: Thanks.
11:35:33 <m___> whois etabot
11:35:35 <joe9> glguy: Thanks.
11:36:25 <m___> can etabot refactor code ?
11:38:34 * hackagebot arbtt 0.9.0.10 - Automatic Rule-Based Time Tracker  https://hackage.haskell.org/package/arbtt-0.9.0.10 (JoachimBreitner)
11:38:36 * hackagebot tttool 1.6.1.2 - Working with files for the Tiptoi pen  https://hackage.haskell.org/package/tttool-1.6.1.2 (JoachimBreitner)
11:58:12 <Gurkenglas> Cale, https://github.com/reflex-frp/reflex-platform does not support Windows, right?
11:59:56 <Phyx-> Gurkenglas: seems like it requires Nix
12:02:30 <ertes> Gurkenglas: you may want to ask this in #reflex-frp
12:03:56 <MasseR> If I have `x :: Applicative f => f String`, I can do `(,) <$> x <*> x`
12:03:58 <MasseR> But
12:04:23 <MasseR> What if I have `x :: (Applicative f1, Applicative f2) => f1 (f2 String)`
12:04:58 <ertes> Cale: i think, writing a "reflex-gtk" library would be extremely tedious and wouldn't pay off too much…  same goes for most other GUI toolkits
12:05:21 <MasseR> I can do `liftA2 (,) <$> x <*> x`, but can I somehow get rid of liftAn
12:05:38 <ertes> Cale: understanding reflex and then just wrapping the portions of the toolkit API that you need is probably easier almost every single time
12:05:38 <MasseR> Assuming I have 10 or so <*> 
12:06:07 <ongy> :t fmap (,)
12:06:08 <lambdabot> Functor f => f a -> f (b -> (a, b))
12:06:21 <ongy> :t (fmap . fmap) (,)
12:06:22 <lambdabot> (Functor f, Functor f1) => f (f1 a) -> f (f1 (b -> (a, b)))
12:06:32 <ongy> which isn't nice either (and not quite sure about <*>)
12:07:01 <MasseR> :t tagIgnoreAttrs
12:07:02 <lambdabot> Not in scope: ‘tagIgnoreAttrs’
12:07:23 <MasseR> ongy: and I would still have fmap . fmap . fmap . fmap . fmap etc
12:07:54 <ongy> MasseR: are you in a f1 (f2 (f3 ...)) context, or do you have many arguments?
12:09:02 <MasseR> Err, hold on
12:09:45 <MasseR> The real type that I'm interested is `MonadThrow m => ConduitM Even o m (Maybe Text)`
12:09:55 <MasseR> *Event
12:11:13 <MasseR> So instead of getting `ConduitM Event o m (Maybe Text, Maybe Text)` I would like to get `ConduitM Event o m (Maybe (Text, Text))`
12:13:17 <ongy> I don't think there is a nice existing operator, but you can always create your own
12:13:35 * hackagebot llvm-ffi 3.5.1 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-3.5.1 (HenningThielemann)
12:13:37 * hackagebot llvm-tf 3.0.3.2 - Bindings to the LLVM compiler toolkit using type families.  https://hackage.haskell.org/package/llvm-tf-3.0.3.2 (HenningThielemann)
12:14:08 <OpCodeOmega> Does anyone know the syntax to pass the -Wall flag to "stack runghc"
12:15:10 <MasseR> :t (,) <$> content <*> content
12:15:12 <lambdabot> IO (Maybe String, Maybe String)
12:15:15 <MasseR> :t liftA2 (,) <$> content <*> content
12:15:17 <lambdabot> IO (Maybe (String, String))
12:15:48 <Welkin> :t content
12:15:49 <lambdabot> IO (Maybe String)
12:16:01 <ongy> @src content
12:16:02 <lambdabot> Source not found. Just what do you think you're doing Dave?
12:16:09 <lyxia> OpCodeOmega: stack runghc -- -Wall
12:16:12 <Welkin> someone defined it using @let
12:16:24 <MasseR> ongy: @let content = undefined :: IO (Maybe String)
12:16:31 <ongy> how long do those exist?
12:16:37 <Welkin> until someone undefines them
12:20:16 <OpCodeOmega> lyxia: Thanks, that got it working
12:24:46 <ongy> reflex-dom looks really impressive
12:30:34 <joe9> Is there a ToJSON or FromJSON for a Data.Map.Strict ?
12:31:03 <geekosaur> Data.Map.Strict is Data.Map
12:31:18 <geekosaur> the maps are exactly the same type; only the operations are different
12:31:36 <joe9> geekosaur: ok, Thanks.
12:33:01 <MasseR> :<, ended up making liftA6
12:36:26 <MasseR> And a liftA23 next
12:38:05 <Welkin> :t ((+3) .) . (+)
12:38:07 <lambdabot> Num c => c -> c -> c
12:38:09 <Welkin> this should work right?
12:38:34 <Welkin> > let f = ((+3) .) . (+) in f 6 1
12:38:35 <lambdabot>  10
12:38:36 * hackagebot tubes 2.1.1.0 - Write stream processing computations with side effects in a series of  tubes.  https://hackage.haskell.org/package/tubes-2.1.1.0 (gatlin)
12:38:36 <merijn> tbh, that's obfuscated to the point that I can't tell
12:38:41 <Welkin> there we go...
12:38:54 <Welkin> just playing around with it
12:39:08 <Welkin> :t (:.)
12:39:08 <kaol> > (((+3) .) . (+)) 1 2
12:39:09 <lambdabot>     Not in scope: data constructor ‘:.’
12:39:09 <lambdabot>     Perhaps you meant one of these:
12:39:09 <lambdabot>       ‘:+’ (imported from Data.Complex),
12:39:10 <lambdabot>  6
12:39:11 <Welkin> :t (.:)
12:39:12 <lambdabot>     Not in scope: ‘.:’
12:39:12 <lambdabot>     Perhaps you meant one of these:
12:39:13 <lambdabot>       ‘.’ (imported from Data.Function),
12:39:17 <Welkin> always forget what it is
12:39:19 <Welkin> is it not imported?
12:39:23 <Welkin> (.) . (.)
12:39:35 <kaol> > ((+3) .) . (+) 1 2
12:39:36 <lambdabot>      No instance for (Typeable a0)
12:39:37 <lambdabot>        arising from a use of ‘show_M372050114790604415332464’
12:39:37 <lambdabot>      In the expression:
12:39:46 <Welkin> @let (:.) = (.) . (.)
12:39:48 <lambdabot>  .L.hs:167:1:
12:39:48 <lambdabot>      Not in scope: data constructor ‘:.’
12:39:48 <lambdabot>      Perhaps you meant one of these:
12:39:51 <Welkin> @define (:.) = (.) . (.)
12:39:52 <lambdabot>  .L.hs:167:1:
12:39:52 <lambdabot>      Not in scope: data constructor ‘:.’
12:39:52 <lambdabot>      Perhaps you meant one of these:
12:39:58 <Welkin> @define (.:) = (.) . (.)
12:40:00 <lambdabot>  Defined.
12:40:14 <Welkin> :t (+3).: (+) $ 6 1
12:40:15 <lambdabot> (Num a, Num r, Num (a -> r)) => r -> r
12:40:21 <Welkin> > (+3).: (+) $ 6 1
12:40:22 <lambdabot>      Could not deduce (Num a0)
12:40:22 <lambdabot>      from the context (Num a, Num r, Num (a -> r))
12:40:22 <lambdabot>        bound by the inferred type for ‘e_1361’:
12:40:28 <Welkin> > let f = (+3).: (+) in f 6 1
12:40:30 <lambdabot>  10
12:40:31 <Welkin> why are those different?
12:40:35 <Welkin> oh
12:40:36 <Welkin> I see
12:40:42 <Welkin> > ((+3).: (+)) 6 1
12:40:43 <lambdabot>  10
12:40:46 <Welkin> of course
12:40:49 <Welkin> damn $!
12:42:56 <ongy> when I have a type '* -> *', what's the difference to 'a -> b'?
12:43:25 <merijn> ongy: It's not a type, it's a kind :)
12:43:39 <merijn> ongy: A kind is, basically, the "type of a type"
12:43:54 <MasseR> Yeah... liftA23 is not going to happen
12:47:08 <EvanR> ongy: A -> B is the type of functions from type A to type B. * -> * is the kind of type constructors which take types of kind * and output another type of kind *. examples of kind * types are Int, Char, [Bool]
12:47:29 <ongy> MasseR: can't you use (fmap . fmap) and a operator you define yourself that's just (fmap (<*>))?
12:47:32 <EvanR> examples of * -> * are Maybe, [ ], Map Int
12:47:54 <EvanR> Map is an example of a * -> * -> *
12:48:24 <ongy> so it tells me I don't get a value, but a type back?
12:48:29 <MasseR> ongy: I'm not sure if I follow
12:48:48 <MasseR> :t fmap (<*>)
12:48:48 <EvanR> ongy: yes, moreover you can only use it on the type level, like in a type signature or a type family
12:48:49 <lambdabot> (Functor f, Applicative f1) => f (f1 (a -> b)) -> f (f1 a -> f1 b)
12:49:01 <johnw> ongy: that's right; if you apply Maybe to Int, you get back Maybe Int, but this is a compile-time thing, not a run-time thing
12:51:13 <Aruro> what is motivation(if any) to "evolve" haskell towards type dependent lagnuages?
12:51:38 <merijn> Aruro: Wanting to rule out bugs at compile time
12:51:40 <ongy> EvanR johnw: ok thanks, I think I got it enough to start understanding it 
12:51:45 <ertes> the reason why i still install acme-dont to this day is that cabal-install can't handle an empty world file…
12:51:48 * EvanR motivation to evolve self toward dependently typed languages
12:51:57 <Aruro> merijn: which ones?
12:52:01 <ertes> and the only reason i even use cabal-install is that i want local documentation
12:52:05 <merijn> Aruro: i.e. imagine having static bounds checking on your arrays
12:52:33 <merijn> Aruro: Well, that's the point in a true dependently typed language you can write arbitrarily complex properties in your types
12:52:41 <johnw> EvanR: in some ways, they are really a lot simpler, just not in all ways
12:52:55 <merijn> Aruro: So the reason people want more dependently typed things is because they want to write complexer things in their types
12:52:56 <EvanR> yes i think haskell has a lot going for it the way it is
12:53:15 <Aruro> merijn: is it a good thing? to write very complex types?
12:53:21 <ertes> Aruro: i'd put it this way:  the reasons to have separate languages for terms and types become fewer and fewer as our APIs grow
12:53:24 <merijn> Aruro: Yes, no, maybe :)
12:53:24 <johnw> I have a hard time translating constructions I'd write easily in a dependently-typed language to GHC's hack-equivalent
12:53:32 <merijn> johnw: Word
12:53:34 <Aruro> merijn: :D
12:53:51 <EvanR> Aruro: theres complexity in your face, and theres abstractions
12:54:09 <ertes> Aruro: for example i'd like to have a "this user is logged in" type with a value of that type being a witness
12:54:12 <merijn> johnw: It's always funny when people try Idris or something the first time after struggling with GHC type level hacks and then going "oh...wait, this whole dependently typed stuff is pretty easy!"
12:54:20 <EvanR> and abstractions have a fighting chance of being non-leaky with dependent types
12:54:24 <ertes> Aruro: but in haskell you need singleton types, and everything is really awkward to encode
12:54:29 <johnw> merijn: yeah, I know what you mean
12:54:32 <EvanR> but it still seems very hypthetical
12:54:44 <johnw> merijn: especially explicit management of singletons seems like a weird amount of work
12:55:02 <EvanR> merijn: on the other hand, there is still not really a "statically bounds checked array" in idris either
12:55:09 <Aruro> ertes: is it a general example? or there are more?
12:55:11 <EvanR> unless you want to hack the runtime
12:55:29 <ertes> Aruro: there are many more
12:55:58 <Aruro> what a disadvantages of dependetly typed languages? compare to modern haskell?
12:56:10 <alercah> the compiler is stupider
12:56:29 <EvanR> that seems unfair
12:56:41 <ertes> Aruro: type inference would be more difficult
12:57:00 <Aruro> are they actually simpler and more beatiful than hardcore haskell 98?
12:57:10 <EvanR> also you put type signatures at the top level in modern haskell anyway
12:57:14 <alercah> Depends on what you're trying to do
12:57:21 <johnw> yeah, it really depends on your task
12:57:29 <alercah> They are simpler in the sense that they tend to have less complex features
12:57:41 <alercah> They are more complicated in the sense that coding in them is generally more difficult
12:58:07 <johnw> i really miss view patterns, guards, record update syntax, and a lot of other nice features that Haskell has; Idris is better at modernizing
12:58:12 <Aruro> alercah: is it like double layer? coding on values and coding on types?
12:58:21 <alercah> Aruro: No, it's not
12:58:22 <EvanR> idris has nested record update syntax
12:58:30 <EvanR> built in
12:58:35 <EvanR> its "first class"
12:58:47 <ertes> Aruro: i don't think h98 is a language i'd like to program in =)
12:58:49 <alercah> Aruro: The issue is that the compiler expects more of you
12:58:59 <Aruro> alercah: is it easier to "reason" about programs in DT languages?
12:59:13 <johnw> Aruro: if you express the problem correctly, yes
12:59:25 <ertes> let me think…  when was the last time i wrote a module without a LANGUAGE pragma?
12:59:33 <Aruro> never :D
12:59:35 <ertes> i have faint memories about doing that
12:59:55 <ertes> and that's not even h98, but h2010
12:59:58 <ongy> and then there's me just using CPP and OverloadedStrings
13:00:00 <alercah> Aruro: Have you ever had to use Proxy in Haskell?
13:00:10 <Aruro> alercah: not yet
13:00:22 <alercah> well, it's a great example of a feature that doesn't need to exist in a dependently typed language
13:00:28 <alercah> "feature"
13:01:03 <Aruro> alercah: is there a danger of mixing types and values in your mental picture of program?
13:01:15 <ertes> Aruro: using Proxy for the first time is the point of enlightenment, and at the same time the point of no return
13:01:30 <alercah> Aruro: rarely
13:01:39 <EvanR> Aruro: there is the added simplicity of mixing types and values in your mental picture of program ;)
13:01:41 <ertes> it's the moment in your life you realise that you want -XDependentTypes
13:02:14 <EvanR> i thought Proxy was when you wanted ExplicitTypeApplication
13:02:27 <Aruro> but isnt dependents types kill whole idea that we have values and types, being separated?
13:02:33 <alercah> yes
13:02:35 <alercah> but there's no risk
13:02:36 <alercah> ;)
13:02:41 <EvanR> thats the point of a type system
13:02:48 <EvanR> you cant mix things up if its well typed
13:03:05 <EvanR> 3 : Int, that is all there is to it
13:03:15 <EvanR> 3 and Int cant go where the other is expected
13:03:39 <EvanR> whereas you cant totally put 3 and Int wherever you want in Ruby
13:03:53 <johnw> Aruro: but even in DT, types exist at compile time, and values at run time
13:03:58 <johnw> there isn't a complete unity between them
13:04:14 <merijn> ongy: Don't feel bad, I claim to be a dependent type afficionado, but in reality most code I write is horrific python and C++ :p
13:04:34 <Aruro> but wasnt type inference something nice? is it very hard in DT?
13:04:38 <quchen> Python is depently type as well. Everything depends.
13:04:46 <quchen> Is this a string? Depends.
13:04:51 <johnw> type inference works in DT too, but it can be limited depending on your code
13:04:55 <EvanR> lol
13:05:02 <ongy> merijn: I don't feel bad. It's mostly that my projects are somewhat lowlevel partially ffi glue. So I don't need that much of the extensions power
13:05:10 <merijn> Aruro: tbh, the more I write haskell, the more I explicitly annotate types
13:05:10 <EvanR> idris infers enough for me
13:05:20 <merijn> Aruro: So I've decided I don't care so much about inference
13:05:24 <Aruro> merijn: but for your mental convenience?
13:05:39 <ongy> on the other hand, I have some (if only few) experience with isabelle/HOL which is really nice but such a pain to get it working
13:05:47 <merijn> Aruro: Yes
13:05:53 <johnw> I use inference all the time (I'm a full-time user of a dependently typed language)
13:06:06 <merijn> Aruro: I read code more often than I write it, so seeing the types there makes live easier
13:06:08 <EvanR> code inference? ;
13:06:25 <johnw> EvanR: there are times when you can infer code, indeed
13:06:41 <merijn> Aruro: It's like troubleshooting compilation issues from beginners here with no type signaturs. I can't be arsed to think about what the types *could* be
13:06:50 <tdammers> sometimes, leaving out the types is convenient because it means you don't have to enable ScopedTypeVariables and such :x
13:07:19 <tdammers> but normally, yes, writing the types down is often all it takes to debug typecheck failures in the first place
13:07:24 <EvanR> enable ScopedTypeVariables and jam it open with a crowbar ;)
13:07:42 <merijn> tdammers: Honestly, that's normally the only reason I don't write a type, if I'd need to enable SCTV and haven't already
13:07:50 <merijn> I even annotate let/where nowadays
13:07:50 <Aruro> so in DT language u can write equivalently complex type programs? which calculate types from types?
13:08:00 <johnw> Aruro: sure
13:08:06 <EvanR> the important part is calculating types from values
13:08:49 <Aruro> but can haskell evolve into DT or would be better to start from scratch?
13:08:54 <EvanR> you can think of a function from A to Types as a proposition
13:09:00 <EvanR> about A
13:09:01 <johnw> it can evolve very close
13:09:25 <Aruro> EvanR: so A has type T ?
13:09:26 <EvanR> then Sigma(x:A) (f x) would be the subset of A which satisfies the proposition
13:09:29 <lambdamu> the from scratch attempt also exists basically in the form of Idris
13:09:30 <EvanR> A : Type
13:09:43 <lambdamu> though not lazy
13:09:57 <EvanR> it does support laziness
13:10:07 <EvanR> but not by default
13:10:12 <lambdamu> yes i know practically every language does
13:10:26 <EvanR> well idris has the lazy force stuff, and it is managed for you
13:10:32 <EvanR> you dont need to do lambda wrappers
13:10:48 <Aruro> how would you compare learning curve for Idris vs Haskell+Extensions?
13:10:52 <merijn> Non-default laziness is rather useless
13:11:01 <johnw> I agree with merijn 
13:11:04 <merijn> Aruro: Assuming you know haskell without extensions?
13:11:08 <Aruro> yes
13:11:09 <merijn> Aruro: Easy
13:11:37 <shapr> I prefer non-strictness by default.
13:11:44 <EvanR> idris has a really low level feel to it, like they are expecting to rewrite the operating system in it. so being able to do a 10-character fibs list isnt a thing to optimize for
13:11:44 <merijn> Aruro: Haskell programmers are the target audience for Idris :p So all tutorials, etc. are basically comparing to haskell
13:12:08 <lambdamu> merijn: Can you elaborate on that, at least for data structures default strictness seems much more appropriate to me
13:12:12 <Welkin> EvanR: why is that?
13:12:28 <Welkin> how do you do fibs in idris?
13:12:41 <Aruro> can i write Haskell in Idris?
13:12:43 <EvanR> to do it the haskell way you would use a Stream
13:12:51 <EvanR> which is implemented with the lazy support
13:12:51 <merijn> lambdamu: Because solving excessive laziness is a local transformation, solving exccessive strictness is not
13:12:52 <Welkin> let fibs a b = a : fibs b (a + b) in fibs 0 1
13:13:00 <Welkin> does it look anything like that?
13:13:10 <EvanR> :: instead of :
13:13:13 <merijn> lambdamu: Consider the classical space leak of foldl
13:13:14 <Aruro> ok its not lazy so probably not.
13:13:15 <Welkin> yes, of course
13:13:22 <johnw> doesn't Idris allow corecursion?
13:13:23 <Welkin> bu other than that, there is no difference?
13:13:33 <Welkin> also, is idris lazy by default?
13:13:34 <merijn> lambdamu: It can be solved by simply annotating strictness right at the one place it occurs, inside foldl. No other code needs to be aware of it
13:13:37 * hackagebot gcodehs 0.1.0.0 - GCode processor  https://hackage.haskell.org/package/gcodehs-0.1.0.0 (srk)
13:13:39 <EvanR> johnw: yeah Stream is a codata type
13:13:50 <srk> \o/ just published my first package
13:13:55 <EvanR> Welkin: no, its like javascript
13:13:58 <johnw> srk: congrats!
13:14:05 <srk> thanks!
13:14:09 <Aruro> srk: +1
13:14:10 <Welkin> EvanR: o.o how is that
13:14:25 <EvanR> evaluate all the arguments, then push a stack frame to call the function
13:14:28 <srk> it's a GCode parser / prettyprinter if anyone is interested in 3d printers/CNC machines
13:14:37 <maerwald> Idris has typed laziness
13:14:43 <merijn> lambdamu: Now consider the opposite problem, excessive strictness. For example, a series of repeated strict transformations (for example, repeated folds) on a large input data structure
13:15:09 <merijn> lambdamu: To solve the problem of keeping the entire data set in memory, I need to modify EVERY intermediate strict transformation to be lazy
13:15:11 <maerwald> in that regard, you could say haskell is weakly typed, since the types don't tell you anything about laziness
13:15:17 <Welkin> so what is the use case for idris besides research?
13:15:30 <merijn> maerwald: I've been toying with the idea of strictness polymorphic typing
13:15:35 <EvanR> Welkin: and evaluating something *should* result in the normal form of that value, if you did your DTs correctly
13:15:39 <johnw> Welkin: you could have the asked the same question of Haskell ten years ago
13:15:42 <merijn> maerwald: Fund me and I'll actually hack on it ;)
13:15:51 <Welkin> johnw: lol, sure
13:15:58 <lambdamu> merijn: hm thanks, thinking about this now..
13:16:00 <Welkin> but the haskell ecosystem has evolved a lot
13:16:02 <maerwald> merijn: especially when it's about strict vs lazy IO I really dislike that the types don't tell me what's going on, because behavior is _fundamentally_ different
13:16:03 <merijn> lambdamu: If one intermediate transformation remains strict, the entire data set still gets forced
13:16:24 <vektorweg1> types don't tell anything about ressource use of a function. :p
13:16:31 <EvanR> Welkin: theres no idris ecosystem, its not even like haskell 10 years ago. if you want to use it for something serious youll be doing a lot of runtime hacks
13:16:55 <Welkin> so what is the real difference between idris and agda?
13:17:01 <merijn> lambdamu: So, solving excessive laziness is easy to do in hindsight with small local fixes. Whereas fixing excessive strictness requires rewriting substantial unrelated portions of code. This is why I believe lazy is a better default
13:17:08 <ertes> Welkin: idris is still in development, so at some point it may become the next haskell…  on the other hand, haskell may get DTs before idris reaches that point, and due to its weird default strictness, it will probably not become too popular among haskellers
13:17:35 <Welkin> I like my default laziness
13:17:36 <Aruro> so DP would be broken in haskell in many extensions? does it mean that DP is a mix of several concepts?
13:17:37 <EvanR> probably, you have to write functions really weird to get them to be efficient
13:17:44 <EvanR> accumulating parameters
13:17:51 <Aruro> *would be realized ^
13:17:53 <EvanR> pure + eager is weird
13:18:16 <vektorweg1> i like laziness with my sufficiently smart compiler i don't have.
13:18:21 <teurastaja> are there lstms or neural turing machines or basically anything thats not feedforward convolution-only neural systems in haskell?
13:19:11 <maerwald> I think laziness is vastly overrated and sometimes even tends to be sort of an emotional debate how people "feel" about it.
13:19:23 <Welkin> is agda lazy by default or strict?
13:19:28 <ertes> decades of research went into making laziness, a very convenient composability feature, efficient…  something you'd want, and you actually find hard to program without after you get used to it
13:19:32 <EvanR> you never run agda programs
13:19:37 <Welkin> lol
13:19:42 <EvanR> if it type checks, you win
13:20:10 <EvanR> there is something called "program extraction" though, which can output haskell code
13:20:13 <johnw> it seems that laziness increases the expressive power of the compositional style
13:20:33 <bjs> EvanR: my vector with length in type compiles, what do i win
13:21:07 <teurastaja> machine learning in haskell not involving simple feedforward layers?
13:21:09 <EvanR> youWin : A -> Type
13:21:16 <glguy> bjs: You've proven that length indexed vectors exist
13:21:16 <EvanR> not Sigma(x:A) youWin ;)
13:21:20 <EvanR> x
13:21:29 <jkeuhlen> Anyone have experience with parsing ISO-8559 crap in mail headers? I'm trying to convert it back to UTF-8 from a plain-text representation. Basically, this PHP question but for haskell: http://stackoverflow.com/questions/3468849/iso-8859-1-in-mail-subject
13:21:32 <bjs> glguy: haha, time to write that paper
13:22:19 <Aruro> so in type dependent language part of the algorithm is encoded and checked throught types? 
13:23:16 <EvanR> propositions about the results can be encoded and proven or disproven or left questioning
13:23:19 <ertes> teurastaja: i'm not aware of any
13:23:43 <merijn> jkeuhlen: THis looks like it deals with every encoding ever: https://hackage.haskell.org/package/encoding
13:23:59 <Aruro> EvanR: but its kinda snapshot of the algorithm? is output list non null, does program terminate.. or?
13:24:22 <teurastaja> ertes: so haskell, the smartest language in the universe, has no AI besides proofs of concept?
13:24:23 <EvanR> "does program terminate" is usually a thing you get just from doing things inductively
13:24:28 <Welkin> lol
13:24:29 <EvanR> so thats good
13:24:44 <Welkin> teurastaja: what do you mean by "having AI"?
13:24:48 <Welkin> haskell isn't the borg
13:24:51 <teurastaja> neural networks
13:24:55 <jkeuhlen> merijn: thanks! Have you ever used it before? Or just pulling it out of hackage?
13:24:57 <johnw> people want to read: https://hackhands.com/guide-lazy-evaluation-haskell/
13:25:01 <Welkin> there is some activity in machine learning in haskell
13:25:03 <teurastaja> through functional programming
13:25:04 <Welkin> not a whole lot yet
13:25:08 <merijn> jkeuhlen: First thing I found on hasckage
13:25:12 <Welkin> functional programming has nothing to do with it
13:25:18 <MasseR> ongy: I'm still missing some clues:
13:25:32 <MasseR> :t (fmap . fmap) (,) content
13:25:34 <lambdabot> IO (Maybe (b -> (String, b)))
13:25:38 <teurastaja> i know but i see it would look natural in haskell
13:25:39 <merijn> johnw: I usually just send them straight to the STG paper :)
13:25:48 <MasseR> Which is analogous to
13:25:50 <Welkin> the best machine learning support seems to be in numpy/scipy, lua/torch
13:25:59 <MasseR> :t fmap (,) (Just 1)
13:25:59 <teurastaja> yes ive seen
13:26:00 <lambdabot> Num a => Maybe (b -> (a, b))
13:26:01 <johnw> merijn: I accept your read the STG paper thunk, and defer it
13:26:06 <teurastaja> coded my own in scheme
13:26:16 <MasseR> But for what we have:
13:26:26 <teurastaja> but haskell has weird monoid types that could be useful
13:26:27 <jkeuhlen> merijn: cool thanks! I'll see where that takes me
13:26:29 <ertes> teurastaja: beside a few statistics libraries i don't think there are any, but if you're willing to fund me, i'm happy to write one – so far i have only written logistic regression and feed-forward neural networks
13:26:33 <MasseR> :t (<*>) (fmap (,) (Just 1))
13:26:34 <lambdabot> Num a1 => Maybe a -> Maybe (a1, a)
13:26:36 <EvanR> Aruro: the type of non empty lists would be a sigma type, the list coupled with a specific element it contains and a proof that it is in there somewhere
13:26:39 <MasseR> We don't have:
13:26:53 <merijn> johnw: tbh, the STG paper is a really easy read :)
13:26:56 <johnw> EvanR: that's just one of several ways to express non-empty lists
13:27:11 <EvanR> yeah
13:27:11 <johnw> a * list a is another, as is { x : list a | 0 < length x }
13:27:18 <Welkin> machine learning fad
13:27:19 <MasseR> :t fmap (<*>) ((fmap . fmap) (,) content)
13:27:20 <lambdabot> IO (Maybe a -> Maybe (String, a))
13:27:22 <Welkin> when will it end lol
13:27:23 <EvanR> ive tried (a, [a]) in haskell, its cute
13:27:26 <teurastaja> never
13:27:31 <jkeuhlen> man I didn't realize how active this IRC chat was. 
13:27:51 <Welkin> teurastaja: it wasn't popular for a long time, and many AI researchers don't consider it AI
13:28:16 <teurastaja> theres things called recurrent neural networks i see well using monoids
13:28:23 <ertes> i think machine learning and AI are best kept separate, if only to avoid the flamewars =)
13:28:52 <teurastaja> ok well i was talking about more advances neural network concepts
13:28:52 <Aruro> so compute types from values in particular case of lists meanst that [1], [1,1] , [1,1,1] have different types? 
13:29:02 <teurastaja> *advanced
13:29:06 <MasseR> What I would like to have instead is `f :: IO (Maybe a) -> IO (Maybe (String, a))
13:29:08 <EvanR> those all have the same type
13:29:16 <teurastaja> like long short term memories
13:29:18 <johnw> most such flamewars could easily be carried on by a Markov generator anyway
13:29:26 <EvanR> but you can make a family of types indexed by Lists of Ints
13:29:30 <ertes> teurastaja: there are actually more powerful abstractions to compose recurrent networks, but i haven't seen them in practical use except for a context-aware text generator experiment
13:29:38 <ertes> teurastaja: they are extremely difficult to train
13:29:47 <lispy> johnw: that would be particularly effective for simulating the way people talk past each other in flamewars
13:29:58 <teurastaja> algorithmwise or haskellwise?
13:30:05 <dmwit> :t fmap (fmap ((,) ""))
13:30:06 <lambdabot> (Functor f, Functor f1) => f (f1 b) -> f (f1 ([Char], b))
13:30:16 <ertes> teurastaja: algorithmwise
13:30:23 <dmwit> :t fmap (fmap ((,) "")) :: IO (Maybe a) -> IO (Maybe (String, a))
13:30:25 <lambdabot> IO (Maybe a) -> IO (Maybe (String, a))
13:30:30 <Aruro> EvanR: what would be canonical example of value->type computation?
13:30:32 <teurastaja> oh then its not really a problem i learn fast
13:30:43 <EvanR> Aruro: well, heres one...
13:31:05 <EvanR> code : Nat -> Type
13:31:15 <EvanR> code Z = ()
13:31:21 <EvanR> code (S k) = Void
13:31:22 <ertes> teurastaja: a more promising approach is deep learning, and there seems to be some interest in having a haskell implementation, but nobody has done it (and open-sourced it) as far as i know
13:31:39 <adimit> Hi, I'm using the dimensional library, and I'm trying to create a type for a ratio of mass over a dimensional quantity 'a'. A data type Ratio a, which represents something like 100g/1kg. I'd like to use DataKinds to make the Ratio type more type safe, but I'm failing at it: http://lpaste.net/5743600773564989440
13:32:01 <lispy> ertes: is there a good reason to reimplement it (as contrasted with making a binding or other interop layer)?
13:32:04 <teurastaja> ertes: yeah but deep learning with feedforward layers or recurrent?
13:32:14 <Aruro> EvanR: Type is type variable a like in haskell?
13:32:24 <ertes> lispy: probably not, though my experience with the last ML binding (FANN) was not very positive
13:32:24 <EvanR> Type is a type, of types
13:32:26 <lispy> ertes: I love having pure haskell libs as deps, but it seems like a lot of work if your goal is to apply the deep learning.
13:32:56 <Aruro> EvanR: so in modern haskell terms its a kind?
13:32:59 <adimit> Does anybody know how I could make Ratio of a Kind that only accepts things like (Ratio Mass) but not (Ratio Int)?
13:33:05 <teurastaja> lispy: just need efficient SSE and GPU support
13:33:09 <EvanR> kinds are unnecessary
13:33:15 <Aruro> yes, i thought that
13:33:19 <EvanR> each type lives in a type universe
13:33:29 <EvanR> including Type, its in a larger universe
13:33:36 <merijn> EvanR: Tbh kind is just the name for Type_0 in CoC terms
13:33:45 <ertes> teurastaja: deep learning mostly uses restricted boltzmann machines, if i'm still up to date…  they are recurrent in a sense, but not in the traditional sense
13:33:56 <EvanR> im not sure how stuff like * -> * fits into universes
13:34:06 <EvanR> two different * i imagine
13:34:14 <merijn> EvanR: Same *
13:34:22 <teurastaja> is hmatrix optimized for GPU or do i have to write assembly?
13:34:29 <johnw> * -> * is of kind *
13:34:45 <EvanR> assuming TypeInType ?
13:34:50 <johnw> err, sort *
13:34:51 <merijn> EvanR: No
13:34:55 <Aruro> EvanR: so in haskell terms type of code will be code:: Nat->* ?
13:34:56 <merijn> eh, wait
13:35:00 <teurastaja> ertes: i dont know about bolzmann or markov but i know they are related
13:35:03 <johnw> actually, I don't know now what the GHC term for it is
13:35:08 <merijn> johnw: sort
13:35:11 <EvanR> Aruro: yes, if Nat were a DataKind
13:35:12 <johnw> I just know that Set -> Set is in Set
13:35:19 <merijn> johnw: GHC has 1 sort named BOX
13:35:40 <teurastaja> the most complicated concept i heard of in AI is a long short term memory implementation of neural turing machines
13:35:53 <EvanR> * -> * is sort BOX, which goes away with TypeInType, i think
13:36:05 <EvanR> screw all this
13:36:25 <merijn> EvanR: * is Type_0, BOX is Type_1, etc. infinite hierarchy of universes
13:36:41 <merijn> EvanR: TypeInType says "bollocks to it all" and collapses the entire infinite universes into one
13:36:58 <teurastaja> infinite but not fully entropic
13:37:01 <merijn> EvanR: Which costs you soundedness, but then, we didn't have that in haskell anyway with the right extensions
13:37:05 <ertes> teurastaja: i had to look them up, but judging from the explanation i'd say that neural turing machines aren't that useful in practice
13:37:22 <EvanR> also kinds are really for keeping a bunch of different things straight, pertaining to boxing. which is not related to type theory stuff
13:37:29 <teurastaja> well, have you looked at LSTMs?
13:37:46 <ertes> teurastaja: difficult to train, and extremely prone to overfitting (which you might consider a *feature* in some cases for those things)
13:37:47 <EvanR> its also for keeping boxing straight and other stuff in addition to number of arguments to a type ctor
13:38:08 <MasseR> Huh, got the types to match
13:38:18 <teurastaja> ertes: i used one to train my computer to learn french so its all fine
13:38:22 <EvanR> Aruro: you can define code in haskell using a type family, but then Z and S need to be types (or type ctors), so data kinds
13:38:31 <Aruro> EvanR: so later on someone can use code function  code : Nat -> Type in a type signature?
13:38:51 <teurastaja> french is like 1000* harder to learn7 than english
13:38:55 <ertes> teurastaja: yeah, i've read about LSTMs, which is the context-aware text generation experiment i talked about earlier
13:38:56 <EvanR> you can use code in a type constructing expression
13:39:02 <ertes> teurastaja: i don't believe you =)
13:39:14 <EvanR> type signatures for example
13:39:18 <EvanR> or regular code
13:39:24 <ongy> MasseR: hwo did you get it to match?
13:39:27 <MasseR> ongy: fmap (<*>) was a good hint, but it wasn't enough. I declared let (<<*>>) f g = (fmap (<*>) f) <*> g
13:39:31 <teurastaja> ertes: really? i just followed Karpathy's code
13:39:34 <ongy> I'm staring at it and it's harder than I though
13:39:52 <MasseR> And `let (<<$>>) = fmap . fmap`
13:40:02 <ertes> teurastaja: what do you mean by "learn french"?
13:40:15 <teurastaja> reading 4 books and inventing
13:40:52 <Aruro> is it possible to have complicated bugs on Dep Types level?
13:41:23 <Aruro> like loops for example
13:41:25 <ongy> teurastaja: as long as you don't have to teach it pronouncing french
13:41:32 <johnw> Aruro: bugs in the sense of not understanding what you meant to say, yes
13:41:36 <teurastaja> ertes: LSTMs vs convolution layers are like comparing functions with programs
13:41:41 <johnw> Aruro: but nothing like infinite recursion, or crashes, or those sorts of bugs
13:42:00 <ertes> teurastaja: "inventing"?  like producing french text?
13:42:09 <johnw> Aruro: it's easy to code a type for which no possible implementation can exist, and then not realize that for hours as you beat your head against a wall
13:42:12 <EvanR> Aruro: a really good concept from DT languages is that of a total function, total functions cant loop or freeze or crash
13:42:12 <teurastaja> ongy: the time parameter was letters but if it was actual time listening to a voice it would still work
13:42:26 <teurastaja> ertes: yes, producing french text
13:42:37 <EvanR> most of the time, even in systems like PHP or ruby, you are really trying to write total functions
13:43:05 <maerwald> that's hard in ruby
13:43:11 <EvanR> yes it is
13:43:13 <maerwald> thanks to duck typing
13:43:29 <johnw> duck can only type with their bill, so I imagine it's a slow type system too
13:43:43 <ertes> teurastaja: ok, then i believe you…  i've been experimenting with a simple feedback method together with genetic learning to produce models with memory, but nothing serious yet
13:44:28 <teurastaja> ertes: long short term memories or gated recurrent units will wipe all your previous work
13:45:19 <teurastaja> but im still learning backpropagation through time on them
13:45:23 <Aruro> EvanR: DT languages make it casual to write total functions?
13:45:26 <ertes> teurastaja: not necessarily…  if you need a genetic/annealing method of learning, there is really no reason to pay the extra cost for LSTMs
13:46:01 <teurastaja> ertes: the description of lstms is as natural as you could get it to look like
13:46:27 <EvanR> Aruro: they include mechanisms to check totality
13:46:32 <teurastaja> and google, yahoo etc are running lstms all the time, not feedforward layers
13:47:05 <teurastaja> although feedforward layers MUST be understood before tackling LSTMs
13:47:35 <EvanR> but it can be non trivial to get current technology to agree beyond the shadow of a doubt your algorithm terminates on all inputs
13:47:49 <EvanR> and itll never be perfect because halting problem
13:47:59 <orion> teurastaja: You're working on ML? What's your background?
13:48:15 <teurastaja> EvanR: recurrent neural networks do learn when to stop
13:48:19 <EvanR> in practice i think this isnt that bad because your working with finite data structures
13:48:40 <EvanR> you do chains of maps, folds, groupings, sorts on finite arrays of data
13:48:41 <ertes> teurastaja: a single memory block in LSTMs needs quite a few units, while in a simple feedback loop they are essentially free
13:48:42 <teurastaja> my background is hacking in my moms basement
13:48:52 <jonored> Devices with finite memory you can tell if they'll terminate, at least, it'll just cost. A lot.
13:48:56 <ertes> teurastaja: there is no reason to use LSTMs, if you're not going to benefit from backprop
13:49:35 <orion> teurastaja: I don't have any formal/academic math or CS background. What resources did you use to learn these concepts?
13:49:40 <EvanR> jonored: a great example of how forcing people to admit that the computer is finite doesnt help much
13:49:49 <orion> Do you have any website recommendations? Books?
13:49:52 <EvanR> it might as well be infinite in that case
13:50:11 <teurastaja> ertes: you mean recurrent layers? because feedback is needed for feedforward layers to learn
13:50:34 <teurastaja> recurrent layers have the vanishing/exploding gradient problem
13:50:45 <teurastaja> orion: what level?
13:51:25 <Aruro> EvanR: so DT languages by all means are superior to haskell if inlcude/ignore laziness?
13:51:26 <teurastaja> orion: you could look at my code in Scheme or my translation in 8051 C
13:51:46 <teurastaja> hold on
13:51:58 <orion> teurastaja: I'm an intermediate haskell programmer (which I do professionally), and the highest math I've attained academically is multi-dimensional calculus and numerical methods.
13:52:12 <ertes> orion: i can recommend two online courses, one by geoffrey hinton on neural networks, and this one from caltech: https://www.youtube.com/playlist?list=PLD63A284B7615313A
13:52:33 <ertes> the former you can find by searching…  i think it's coursera, but not sure
13:52:34 <orion> I don't have any linear algebra or statistics, and I think that really handicaps me.
13:53:08 <ertes> orion: you should learn some basic linear algebra first, and your calculus knowledge will be very helpful
13:53:19 <teurastaja> http://pastebin.com/ZYwf5VZR
13:53:29 <teurastaja> simplest neural network ever
13:53:43 <ertes> orion: though most of the linear algebra is just multiplying matrices and taking dot products…  nothing too fancy
13:54:04 <teurastaja> orion: all you need is not to fear greek letters
13:54:06 <ertes> you won't be converting between bases or mapping between vector spaces
13:54:24 <teurastaja> think of them as just variables
13:55:05 <orion> I don't fear greek letters. In fact, my favorite one is lambda. :>
13:55:41 <teurastaja> orion: lambda is the least of your concerns there
13:55:48 <ertes> is nabla a greek letter?  i think not, but you'll use it a lot =)
13:55:55 <teurastaja> yes
13:55:57 <orion> teurastaja: I don't know scheme. You mentioned a C translation?
13:55:58 <teurastaja> it is
13:56:15 <teurastaja> orion: yes but C on a 8051 microcontroller
13:57:03 <ertes> orion: you should use one of the courses…  you really can't learn this stuff from code =)
13:57:11 <teurastaja> orion: there http://pastebin.com/hBdUsuuZ
13:57:21 <teurastaja> french comments
13:57:41 <teurastaja> dont expect you to understand anything on the C version. the scheme one thogh yes
13:57:45 <orion> ertes: Oh sure, I have no qualms about reading more formal literature.
13:58:25 <teurastaja> orion: what i linked you to are the simplest implementations you can read
13:58:30 <orion> teurastaja: Thank you.
13:58:54 <teurastaja> its about implementing boolean logic so nothing big
13:59:56 <ertes> orion: there is also my old and unmaintained feed-forward network library that is written in haskell…  you might get it to compile on GHC 8 with some minor adjustments
13:59:59 <ertes> @package instinct
13:59:59 <lambdabot> http://hackage.haskell.org/package/instinct
14:00:36 <orion> What's the state of ML algorithms/data structures in Hackage? Immature?
14:00:43 <ertes> immature
14:00:51 <teurastaja> orion: studying neural networks will be a very spiritual journey you wont regret just like haskell, but more algorithmwise
14:01:09 <Welkin> there is HLearn
14:01:28 <orion> ha, I love your use of the word "spiritual" -- I would definitely call my Haskell journey thus far spiritual.
14:01:44 <teurastaja> unfortunately, unless you learn very simple neural networks theres nothing on haskell ive seen
14:02:00 <orion> I would love to change that.
14:02:00 <Welkin> https://izbicki.me/public/papers/tfp2013-hlearn-a-machine-learning-library-for-haskell.pdf
14:02:06 <teurastaja> orion: youll understand why god does not exist
14:02:18 <teurastaja> or is merely just a concept
14:02:25 <EvanR> Aruro: haskell is a mature system you can use for all kinds of real world applications
14:02:30 <orion> "God is like a Monad"
14:02:43 <ertes> BTW, neural networks are a bit overhyped
14:02:47 <Welkin> https://github.com/mikeizbicki/HLearn
14:02:54 <Welkin> lol, yes
14:03:06 <Welkin> I have a friend who works with neural nets and other machine learning stuff
14:03:11 <ertes> most of the work i've done with machine learning involved simple logsitic regression and was very successful
14:03:14 <Welkin> he tells me about it sometimes
14:03:16 <Welkin> the problems
14:03:22 <teurastaja> ertes: i can think of stuff no one else has done yet so i dont think theyre overhyped. just underused
14:03:27 <EvanR> orion: youll understand why "either god exists, or he doesnt" isnt very compelling ;)
14:03:34 <mniip> does rm'ing a CNN state count as murder
14:03:48 <Welkin> neural nets were part of the cause of the AI winter, right?
14:03:53 <Welkin> all the hype and no results
14:03:55 <teurastaja> Convolutional Neural Network?
14:04:03 <mniip> yes
14:04:29 <teurastaja> ill tell you why neural nets were deceiving at that time
14:04:36 <ertes> teurastaja: they are too complex for *most* problems…  note that most machine learning problems don't involve google-scale data sets
14:05:00 <ertes> teurastaja: even two layers of neural networks quickly overfit for most problems i've been dealing with
14:05:02 <teurastaja> you had fixed-length binary weights and no control over sequences
14:06:16 <teurastaja> now you have
14:06:51 <ertes> Welkin: that's outdated information…  neural networks are useful…  my point is that they're not useful for *everything*
14:07:20 <Welkin> ertes: what is outdated?
14:07:33 <ertes> <Welkin> neural nets were part of the cause of the AI winter, right? <Welkin> all the hype and no results
14:07:46 <Welkin> yeah, that is the history of it
14:07:51 <ertes> yes, there was such a time, but the winter is over =)
14:07:55 <teurastaja> because of the points i just mentionned
14:09:07 <teurastaja> they are turing complete
14:10:07 <teurastaja> gtg but please guys, make efficient matrix libraries for gpu multiplication
14:10:25 <ertes> teurastaja: what about accelerate?
14:10:26 <vektorweg1> i'm still fascinated what the Creatures (1996) did. 
14:10:37 <teurastaja> ertes: its a library?
14:11:34 <orion> https://hackage.haskell.org/package/accelerate
14:11:36 <Welkin> teurastaja: numerical-haskell is something for that I think
14:11:44 <teurastaja> ill check later but you guys better revive the brain while im gone ;)
14:12:07 <teurastaja> orion thanks. bye folks
14:15:42 <carter> It's not released yet but :)
14:16:19 <ongy> how well does GHC vectorize? Or use something comparable to intrinsics to use the extension registers?
14:30:02 <vektorweg1> ongy: as good as llvm can, i think. 
14:30:33 <merijn> tbh, if you *really* care about performance stuff like accelerate doesn't cut it
14:35:02 <Athas> merijn: agreed.
14:35:09 <Athas> Fast Haskell is about FFIs!
14:35:41 <merijn> I'm not even using Haskell or FFIs, just handcoding GPU kernels >.>
14:35:44 <tommd> FFI to C code that is compiled with SSE, AVX, etc.
14:36:44 <merijn> Or just FFI to CUDA :p
14:37:40 <Athas> Yeah, I suppose the CUDA binding is decent.
14:37:43 <Athas> I think Accelerate uses it.
14:38:09 <merijn> Last time I looked at it I decided to use C++ instead of haskell, sadly
14:38:59 <dmj> merijn: not even w/ fusion?
14:39:03 <merijn> hmmm, looks more complete now
14:40:15 <merijn> dmj: So far none of the high-level DSLs I have seen come anywhere close to even mediocre hand-written GPU kernels
14:40:40 <merijn> dmj: Good hand-optimised kernels are an entirely different ballpark
14:40:46 <Athas> dmj: fusion is important but not everything, and Accelerate only does fairly straightforward fusion.
14:41:15 <merijn> dmj: The basic problem is that DSL try to abstract away messy architecture details, but that's where the real performance is :)
14:41:15 <Athas> You basically cannot beat hand-optimised primitive kernels.  Where high-level languages have an opening is that they can optimise composition of primitives.
14:41:16 <the_2nd> let's assume I want a floating number in the range of 0..1 as new data type. How can I restrict it's construction that the values will always be within that range?
14:41:21 <Athas> And, of course, be way easier to use.
14:41:24 <Welkin> merijn: even torch? http://torch.ch/
14:41:39 <Athas> the_2nd: hide the actual constructor and export a constructing function that returns a 'Maybe'.
14:42:04 <EvanR> the_2nd: aka, "smart constructor"
14:43:47 <dmj> the_2nd: could use a newtype as well, for extra safety
14:44:07 <the_2nd> Athas, EvanR, dmj thanks
14:44:44 <merijn> Welkin: Haven't heard of it before
14:44:52 <dmj> merijn: I see, removing intermediate constructors is one thing, but emitting specific instructions is another. 
14:45:09 <ongy> merijn: how portable are those handwritten gpu kernels?
14:45:11 <Welkin> dmj: still in ethpain?
14:45:20 <merijn> dmj: Not so much specific instructions
14:45:37 <Athas> It is pretty depressing to try to beat well-optimised GPU kernels for primitive things (like matrix multiplication) with a compiler.
14:45:40 <merijn> dmj: But, data layout decisions related to cache/memory sizes
14:45:46 <dmj> Welkin: #haskell-offtopic please
14:45:53 <Athas> Fortunately, it turns out much hand-written GPU code is of so-so quality, which is beatable.
14:46:18 <merijn> ongy: It Depends :)
14:47:01 <merijn> ongy: CUDA lets you compile portable versions, but generally you want to make architecture specific kernels and runtime due them for other parameters
14:47:52 <Athas> In principle, Accelerate could do that, since it performs JIT compilation.
14:48:19 <dmj> merijn: interesting, actually reading through dcoutts's thesis right now, piqued my interest
14:49:21 <merijn> dmj: The tricky bit with GPUs is that the cores are actually pretty slow, but they're REALLY good at latency hiding (i.e. SMT/hyperthreading but cheaper and better)
14:50:37 <merijn> dmj: So you wanna maximally saturate the cores to get the most out of latency hiding. Eliminate divergence between cores (because that gets sequentialised). Make sure memory access coalesce cores that read within the same cache line/memory bank/etc. get all their reads coalesced into one bulk transfer), that sorta stuff
14:51:23 <merijn> dmj: So you need to account for, how many cores, what kinda of memory and how much, how do I split my data across memory so I hit all those ideal cases the largest percentage of time
14:53:11 <merijn> dmj: Additionally things like "how expensive are atomics/barriers", the more recent Pascal and Maxwell architectures by NVidia have reduced the cost of atomics to like 10-20% of normal accesses for most scenarios, so on those you might wanna restructure your code to use atomics instead of other solutions
14:56:21 <lambdamu> merijn: wouldn't it be possible to capture those parameters per architecture/gpu and make it a combinatorial optimization problem suitable for solvers?
14:56:26 <ertes> merijn: you could have used CUDA from haskell…  why did you choose C++?
14:56:50 <merijn> ertes: CUDA bindings weren't as comprehensive when I started and worries about GC affecting my benchmarks
14:57:03 <ertes> ah
14:57:25 <Athas> lambdamu: some people are working on that approach.
14:57:33 <merijn> ertes: C++ because that's what CUDA is, C++11 with some limitations and extensions on recent versions
14:57:37 <Athas> lambdamu: http://homepages.inf.ed.ac.uk/slindley/papers/gpu-rewrite.pdf
14:58:03 <Athas> But I don't think it's a very well behaved search space, and you have all the usual autotuning problems.
14:58:19 <Athas> You could do the same thing for compilation on CPUs, and people tend not to.
14:58:21 <merijn> lambdamu: In theory? Yes
14:58:31 <merijn> lambdamu: In practice? Oh god...please help
14:58:40 <lambdamu> Athas: thanks for the link, will read
14:58:47 <merijn> lambdamu: I'm nearly 3 years into phd without any progress >.>
14:59:05 <Athas> merijn: me too!  My advisors hand-written GPU code is still faster!
14:59:13 <lambdamu> merijn: oh that means you work on that problem?
14:59:18 <dmj> merijn: very interesting, at this point do you think there'd be benefit to just using an FPGA? Using a DSL to target VHDL, etc.
14:59:20 <ertes> i hope vulkan finally is what OpenCL wanted to be
14:59:45 <ertes> but i haven't tried it (mostly because i don't have the hardware)
15:00:31 <merijn> lambdamu: I'm trying to predict which of a set of different implementations gives best performance based on structural properties of a graph (i.e. power-law/social graphs probably don't have the same "best" implementation as road networks)
15:01:31 <Athas> Well, graph algorithms are a particularly finicky fit on GPUs.  No wonder it's hard.
15:01:34 <merijn> dmj: I think FPGAs and the overlap of things FPGAs are good at and things GPUs are good at is fairly small
15:01:41 <merijn> Athas: Word
15:01:52 <merijn> Athas: And none of my observed results make any sense!
15:02:03 <Athas> merijn: what are you seeing?
15:02:44 <merijn> Athas: Implementations that have to perform more computation vastly outperforming those that do half the work, with slightly worse load balance
15:03:08 <Athas> merijn: could it be the memory access patterns?
15:03:09 <merijn> So then I thought "if I can predict load balancing I can predict based on that!" wrong again as soon as I use any other algorithm >.>
15:03:46 <merijn> Athas: Yes, no, maybe, nearly impossible to tell and even harder to predict >.>
15:04:07 <Athas> merijn: see, this is why I don't want to do irregular parallelism!
15:05:20 <merijn> Athas: I didn't know that when I agreed to this project xD
15:06:17 <Nastii> su0
15:06:24 <Nastii> sup
15:08:35 <Athas> merijn: which functional approaches to GPU computing do you know of, apart from Accelerate?
15:08:54 <Athas> There was something called NOVA once, from NVIDIA, but I haven't heard anything for years...
15:11:39 <merijn> Athas: Not many, SaC is purely functional and has a CUDA backend (that actually performed fairly well last I checked)
15:11:58 <dmj> merijn: true, very different, unless you're treating the gpu as general purpose, which it doesn't seem like you are
15:12:07 <merijn> But that's not really a framework for writing GPU code. More a language for array/matrix programming that happens to have a GPU backend :)
15:12:20 <Athas> merijn: unfortunately SaC is dead-ish, and the CUDA backend more so.
15:12:43 <merijn> dmj: Well, even if you treat them as general purpose, there strengths lie in different areas
15:13:48 <merijn> Athas: I'd have to poke some people, I'd be surprised if they'd stopped with SaC. Of the two main people I know that 1 isn't really working much on SaC anymore, but the other was expanding his group last I heard
15:14:05 <dmj> merijn: certainly, matrices vs. realtime systems
15:14:30 <merijn> FPGAs have very limited memory too
15:14:53 <merijn> dmj: Not just matrices, anything that is regular in execution and/or access pattern is good on GPU
15:15:07 <merijn> FPGAs are really good at stream processing/DSP stuff
15:19:54 <Athas> merijn: what do you think of Accelerate?
15:20:21 <merijn> Athas: Haven't used it beyond looking at it superficially, so I have no strong opinions :)
15:25:11 <dmj> since we're on the topic of performance... Am I correct in stating that stream fusion works similarly for both mutable *boxed* vectors and mutable *unboxed* vectors? 
15:25:57 <ertes> dmj: it doesn't work for mutable vectors at all
15:26:41 <ertes> dmj: there is nothing to fuse…  the only bulk operations the mutable interface gives you is copying and bulk setting
15:26:55 <merijn> ertes: So, technically: yes? :p
15:27:06 <ertes> lol
15:27:37 <dmj> ertes: so the API seems to indicate you can convert both a boxed and unboxed mutable vector into a stream
15:27:52 <dmj> mstream :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Stream m a
15:27:55 <ertes> dmj: sure, you can, but you don't get automatic fusion
15:28:19 <ertes> dmj: of course you can just compose stream operations, which you could consider manual fusion
15:28:52 <ertes> dmj: at that point you're basically just using a stream abstraction like pipes/conduit
15:32:02 <joe9> Is there a haskell control structure for just if and then without the else? http://bpaste.net/show/b18b929851c8 is my code and it do not want the else there. just leave the value as-is.
15:32:42 <Gurkenglas> What stack command do I use to upload a package candidate, rather than a whole package version?
15:33:14 <joe9>  ifThen :: Double -> Double -> Double; ifThen f d e = if d == 0 then e else d
15:33:30 <joe9> is there something in the standard library for that.
15:34:28 <Gurkenglas> First off "Map.foldl (\a ps -> a + (size ps)) 0 (rTradedVolume r)" is "sum $ fmap size $ rTradedVolume r" :P
15:34:59 <joe9> Gurkenglas:  cool. Thanks.
15:36:12 <Gurkenglas> That if clause has an else, doesn't it? You put d in there.
15:37:29 <Gurkenglas> But you probably want rTotalMatched wrapped in a Maybe, and then use rTotalMatched = rTotalMatched <|> sum (fmap size $ rTradedVolume r)
15:37:31 <joe9> ifThen d c = if d == 0 then c else d
15:38:08 <joe9> Gurkenglas: sum is a Data.List function. Would I need a Map.fromList there?
15:38:19 <joe9> sorry, Map.toList there
15:38:20 <Gurkenglas> Use sum from Data.Foldable
15:38:22 <Gurkenglas> :t sum
15:38:23 <lambdabot> (Num a, Foldable t) => t a -> a
15:38:47 <Gurkenglas> :t sum `asAppliedTo` (undefined :: M.Map k a)
15:38:48 <lambdabot> Num b => Data.Map.Map k b -> b
15:39:12 <dmj> ertes: I see, so it seems the only benefit of the streaming interface for mutable vectors is for dynamic creation then... I assumed the composition of stream / unstream was fusion and since the generic interface provides this on mutable, it seems like there would be some benefit. I'm a bit confused as to why it exists then.
15:39:40 <dmj> this on mutable vectors*
15:40:01 <Athas> merijn: are you doing a language or anything like that?  Is your work available somewhere?
15:41:31 <merijn> Athas: Most of my code is here: https://github.com/merijn/GPU-benchmarks
15:42:01 <merijn> Athas: I'll have to nuke it and replace it in the near future, since I have a new version and fucked with the history in a way that pushing to github gets all confuzzled, though
15:43:42 * hackagebot algo-s 0.1.0.0 - An implementation of Knuth's algorithm S.  https://hackage.haskell.org/package/algo-s-0.1.0.0 (EricRochester)
15:43:52 <joe9> Gurkenglas:Thanks that was a very good suggestion.
15:47:34 <joe9> Gurkenglas: if you have any such smart suggestions for this: http://bpaste.net/show/321661a9635c
15:51:54 <ReinH> joe9: updateRunners is a fold
15:52:57 <ReinH> updateRunner looks like it wants to live in the Maybe monad
15:53:45 <ReinH> certainly all those lambdas could be extracted as definitions (say, in a where clause), which would make it much easier to read
15:54:22 <Gurkenglas> joe9, you can watch me go through it on livecoding.tv/gurkenglas
15:57:08 <ReinH> actually, it does not look like it should be a Maybe action.
16:08:29 <pavonia> Just to make sure, the set of peek* and with* functions in the Foreign modules aren't lazy by any means, right? That is, it won't happen that some parts of the object it will be requested after the allocated memory has already been freed
16:11:56 <lingxiao> hey all
16:11:58 <lingxiao> i have a design decision id like to run by you guys
16:12:36 <lingxiao> i need to search through a large corpous looking for certain patterns
16:12:52 <Koterpillar> define pattern
16:13:09 <lingxiao> regular rexpression
16:13:17 <lingxiao> so like this:   * (,) but not *
16:13:31 <lingxiao> where * could match any word ... or i could specify the word... so ie:
16:13:50 <lingxiao> suppose   * (,) but not *   is a function, then  (* (,) but not *) good great = good (,) but not great
16:14:03 <lingxiao> right now im using attoparsec to parse these large Text files
16:14:32 <lingxiao> i dont want to write a new parser for each one .. 
16:15:18 <lingxiao> so my question is does it pay to write a function that turns a string like this:  "*(,) but not*" into some attoparsec parser
16:15:37 <Koterpillar> how many of these parserfunctions do you have?
16:15:39 <lingxiao> or im just better off writing some parser functions, and combining them using the provided combiantors
16:15:52 <lingxiao> Koterpillar what do you mean parserfunctions?
16:16:07 <lingxiao> like distinct patterns im looking for?   right now 20
16:16:10 <lingxiao> but really it's unbounded
16:16:15 <Koterpillar> * (,) but not * <== parserfunction
16:16:44 <Koterpillar> or what do you call them
16:17:13 <lingxiao> pattern ? haha yeah parsefucntion is a great name
16:17:15 <lingxiao> so right now 20
16:17:18 <lingxiao> but could be 50
16:17:31 <lingxiao> im parsing google ngrams , if that information is of any use
16:17:54 <lingxiao> but the point is that the data i'm parsing is of form:      foo\t000\nbar\t000\baz\t000 ...
16:18:51 <pavonia> You could write a combinator for that that allows you to define patterns like var <> text "(,) but not" <> var
16:19:12 <pavonia> which then translate into a Parser value
16:19:32 <the_2nd> Gurkenglas, please : https://hexchat.github.io/themes.html
16:21:13 <lingxiao> pavonia  sorry what's var ?
16:21:27 <lingxiao> but yea I'd like to stay with parsec if possible ... instead of putting some of my own stuff on it
16:21:35 <lingxiao> which realistically im not going to test
16:21:37 <pavonia> Some combinatore that translates to a Parser that parses a word
16:22:27 <lingxiao> oh i see
16:22:29 <lingxiao> what's <> ?
16:22:36 <lingxiao> it's that parser chaining?
16:22:42 <lingxiao> i've been looking for something like that
16:22:46 <pavonia> It's just an example
16:22:54 <maerwald> :t (<>)
16:22:56 <lambdabot> Monoid m => m -> m -> m
16:22:57 <lingxiao> oh you mean that's the combaintor?
16:23:04 <lingxiao> wait do attoparsecs form a monoid?
16:23:28 <pavonia> If you want to chain parsers, you can also use do-blocks
16:24:14 <lingxiao> pavonia that's what i mean though right, i'd like the structure of the program to be readable so that it reads like the expression: *(,) if not *
16:24:46 <lingxiao> so something like  anyString <> (comma <|> space) <> " if not " <> anyString
16:24:48 <lingxiao> would be great ..
16:25:21 <pavonia> Welly, that's basically how you write your attoparsec parser, no?
16:25:26 <pavonia> *Well
16:25:46 <lingxiao> yeah minus the (<>) part
16:25:52 <lingxiao> didnt know they form a monoid
16:25:57 <Welkin> using ap instead
16:25:58 <Welkin> <*>
16:26:38 <Welkin> lingxiao: monads are monoids
16:27:05 <lingxiao> but you can define a monad w/o giving a monoid interpretation in haskell no?
16:27:08 <lingxiao> or is it diferent now
16:27:17 <Welkin> you can
16:27:42 <mniip> 1471389976 [02:26:16] <Welkin> lingxiao: monads are monoids
16:27:46 <mniip> that might be confusing because
16:27:54 <mniip> Control.Monad.Monad's aren't Data.Monoid.Monoid's
16:28:23 <mniip> haskell's monoids are monoids in Hask under (,) as tensor product
16:28:39 <lingxiao> what's (,) ?
16:28:44 <lingxiao> tuple constructor?
16:28:47 <mniip> yes
16:28:51 <mniip> an example of a product
16:29:07 <lingxiao> oh how is it a monoid under product?
16:29:08 <mniip> haskell's monads are monoids in the Hask^Hask category with composition as tensor product
16:29:26 <mniip> well
16:29:41 <mniip> (Hask, (,)) is a monoidal category
16:29:49 <shachaf> The fact that it's confusing and doesn't mean what people who don't already know about category think it means doesn't stop people from saying it.
16:31:02 <mniip> and an object X in that category is a monoid if there are morphisms (X, X) -> X, and () -> X
16:31:18 <mniip> and some laws are held
16:31:46 <mniip> () being the identity of (,)
16:32:09 <mniip> hmm, I should have said that (Hask, (,), ()) is a monoidal category
16:32:17 <lingxiao> Welkin you said use <*> right?
16:32:32 <Welkin> that is what most parsers use
16:32:35 <Welkin> applicative parsers
16:32:43 <lingxiao> so im doing something like   foo <$> anyChar <*> anyChar
16:32:53 <Welkin> in the UPenn course, you build a parser yourself from scratch using <*>
16:33:09 <lingxiao> wrod
16:33:43 * hackagebot keter 1.4.3.2 - Web application deployment manager, focusing on Haskell web frameworks  https://hackage.haskell.org/package/keter-1.4.3.2 (ChristopherReichert)
16:34:34 <lingxiao> ok so no regular expression compiler that sends strings to parsers then
16:34:36 <lingxiao> just the parser itself
16:34:54 <Welkin> you don't need regex is you have these parsers
16:34:58 <Welkin> if*
16:34:59 <Welkin> regex sucks
16:36:04 <solrize> and then you  have two problems
16:36:59 <lingxiao> solrize that was definintely a meme/joke 
16:37:07 <lingxiao> some years back .. .it used to go around facebook
16:37:11 <lingxiao> when people used facebook 
16:37:23 <Welkin> fecebook?
16:38:03 <lingxiao> The book of Face
16:39:59 <lingxiao> its funny everytime i use facebook im like: what a worthless product, but every time i see zuckerberg in an interview im like: now theres a person i can trust
16:50:19 <Gurkenglas_> joe9: Here http://lpaste.net/2005204068816912384 , though I think that this stuff should instead be written at the place where you decide what goes in the RunnerChange. Can I see that?
17:05:05 <alunduil> 10
17:07:05 <lingxiao> hey all
17:07:09 <lingxiao> is there a way to refactor this: http://lpaste.net/177740
17:07:19 <lingxiao> so that instea of vocabn w <|> vocab1 w
17:07:22 <lingxiao> I just have some vocab w
17:07:49 <lingxiao> where in vocab w,   the first line is parsing either:   string w  or   any number of chars until string w
17:08:01 <lingxiao> basically my two cases are as follows,  suppose i want to parse foo:
17:08:13 <lingxiao> foo\t000\nbar\t000
17:08:18 <lingxiao> or bar\t000\nfoo\t000
17:09:20 <ertes> lingxiao: after a line, consume the '\n', so that each new parser starts at the start of a line
17:09:41 <lingxiao> ertes the thing is that foo could be at the beginning of the document
17:09:52 <lingxiao> with absolutely no character in front of it
17:09:54 <ertes> lingxiao: yes
17:10:41 <joe9> Gurkenglas_: Sorry, had to step away . Thanks a lot.
17:10:44 <ertes> not sure which parser library you're using, but the idea is this: vocab = theWord *> theSpace *> theNumber *> skipWhile (== '\n')
17:10:49 <lingxiao> attoparsec
17:11:16 <ertes> lingxiao: i.e. make sure the parser consumes the entire line, including the delimiting '\n'
17:12:21 <ertes> in fact you seem to be doing that already
17:12:59 <lingxiao> ertes yeah the parser needs to succed even if foo is buried deep within the stream of text though
17:13:16 <lingxiao> so   ......foo\t000\n......    and also:   foo\t\000\n......
17:13:27 <ertes> sure
17:13:33 <lingxiao> i think you parser you wrote would fail if it's buried in the text?
17:13:40 <ertes> no, it wouldn't
17:14:25 <ertes> but honestly i wouldn't even use a parser library for that one
17:14:38 <lingxiao> sorry and skipWhile :: (Char -> Bool) -> Parser () ... but I need some Parser String ?
17:14:41 <lingxiao> what would you use?
17:14:52 * ertes is having a deja vu
17:15:19 <lingxiao> what does that dot followed by  ertes is having a deja vu mean?
17:15:26 <lingxiao> I see thata lot ... who sends that 
17:15:38 <lingxiao> like dot [username] ...
17:15:57 <ertes> lingxiao: personally i'd use a stream abstraction
17:16:00 <Koterpillar> lingxiao: try typing: /me wonders what's happening
17:16:15 * lingxiao blurg
17:16:17 <kadoban> It's supposed to be used for "actions" someone is performing.
17:16:26 <lingxiao> oh ... isee interesting
17:16:55 <lingxiao> ertes i need to search for lots of different patterns in text, almost like regular expression
17:17:03 <mniip> kadoban, nonono, you're getting it all wrong
17:17:10 <lingxiao> what does stream abstraction give me that this pparsing doesnt?
17:17:18 <mniip> the CTCP spec says: ACTION This is used by losers on IRC to simulate "role playing" games.
17:17:28 <ertes> lingxiao: less engineering and likely better throughput
17:17:38 <lingxiao> what's throughput?
17:18:02 <ertes> lingxiao: speed…  characters per second, if you will
17:18:18 <lingxiao> ertes ok that's cool because it matters here ... by stream abstraction you mean something like conduit right?
17:18:32 <ertes> yeah
17:18:34 <lingxiao> i'm using conduit right now.... to traverse the 100 + files that i need to be seraching through
17:18:35 <Welkin> any idea what I'm doing wrong with minimax?
17:18:39 <Welkin> has anyone else written this?
17:18:45 <zomg> mniip: I remember I sent the word "nuke" over CTCP back in the day and people would freak out
17:18:47 <lingxiao> ok so you're saying i should conduit each file as well .. instead of parsing it
17:18:57 <Welkin> I don't get the optimal move, but seemingly stupid moves
17:18:59 <zomg> "are you trying to hack me"
17:19:04 <joe9> Gurkenglas_:  Why do you use lens? the code looks like it was written in a different language.
17:19:07 <ertes> lingxiao: that's what i would do (except with pipes)
17:19:08 <lingxiao> so these are "\n" delimited lines .... i still need to do some sort of "regular expression" thing for each line
17:19:18 <lingxiao> too far commited to conduit at this piont :(
17:19:29 <lingxiao> did agonize over it for a bout 3 mintues though
17:19:37 <Welkin> lingxiao: that is bullshit...
17:19:40 <Welkin> you keep saying that
17:19:45 <Welkin> switching to pipes is trivial
17:19:47 <Gurkenglas_> joe9: because I hate record update syntax, esp used to update one field at a time, and it allows much shortening :D
17:19:52 <ertes> lingxiao: it doesn't really matter…  conduit and pipes are pretty similar, although there is pipes-group, for which there is no conduit equivalent readily implement, as far as i know
17:20:17 <lingxiao> syntax is all different .. need to get this done by thursday morning... so really tomorrow 
17:20:33 <lingxiao> ertes what do you mean by conduit equivalent 
17:20:37 <lingxiao> like certain features ?
17:20:40 <Welkin> pipes is easier to use
17:20:42 <Gurkenglas_> joe9: Can I see the rest of your code? I think the definitions in my lpaste ought not to exist in the first place :D
17:20:59 <lingxiao> maybe for my next project
17:21:13 <lingxiao> why is it easer in your opionion?
17:21:24 <ertes> lingxiao: the idea is this:  get a stream of raw Text chunks (a source/producer), transform it to a stream of lines by rearranging the chunks (via a conduit/pipe), then transform that one to a stream of word/count pairs (another conduit/pipe)
17:22:19 <lingxiao> ertes sorry could i ask you to lpaste a simple example?
17:22:23 <lingxiao> maybe even in pseudocode
17:22:49 <lingxiao> so right now I have some Conduit FilePath m b  thing that is accepting a file path and opening the file im thinking of
17:23:14 <ertes> lingxiao: just try it…  make a prototype and paste it
17:23:20 <lingxiao> so you're saying in this cnt :: Conduit FilePath m b, I need to run another conduit ?
17:23:45 <lingxiao> this is what  i have now http://lpaste.net/177742
17:24:09 <lingxiao> where it says    case  (cnt w) <** ts of ... that's where the parsing happens
17:24:12 <ertes> there is probably a premade Source to read a text file
17:24:20 <coolgou> i use ERV 
17:24:26 <coolgou> i use ERC 
17:24:37 <coolgou> as irc client 
17:24:38 <coolgou> :D
17:24:45 <ertes> if you do the directory traversal with a conduit, then you need a second and unrelated layer for the actual text
17:24:48 <lingxiao> couldnt find it though?
17:24:48 <coolgou> and this is a test 
17:25:03 <lingxiao> what do you mean second and unrelated layer?
17:25:52 <ertes> i'm not overly familiar with the conduit ecosystem, so i can't really help you with the specifics
17:26:11 <lingxiao> ertes oh thats ok, but what does layer mean?
17:26:34 <c_wraith> I think it's just about separation of concerns - one conduit to traverse the directory structure and pass files back.  A second conduit for handling each file.
17:26:56 <c_wraith> Each conduit can be developed independently, as the library is all about composing pieces nicely
17:26:56 <ertes> lingxiao: what c_wraith said
17:27:15 <ertes> lingxiao: also i just found the conduit-extra library, which seems to come with most of the things you need
17:28:00 <ertes> the initial producer is sourceFile, which gives you a stream of ByteString
17:28:04 <ertes> https://hackage.haskell.org/package/conduit-extra-1.1.13.2/docs/Data-Conduit-Binary.html
17:28:37 <ertes> next you decode into a stream of Text using 'Data.Conduit.Text.decode'
17:28:44 <c_wraith> there's also https://hackage.haskell.org/package/conduit-extra-1.1.13.2/docs/Data-Conduit-Filesystem.html
17:28:55 <c_wraith> Which provides flat or recursive directory traversals
17:29:17 <lingxiao> c_wraith yup that's what im using to traverse the directory
17:29:22 <lingxiao> but i didnt know about conduit-extra though
17:29:35 <ertes> lingxiao: you're using it =)
17:29:53 <lingxiao> oh ops haha touche
17:30:16 <lingxiao> ok so cbytestring =$= toText =$= 
17:30:17 <lingxiao> then what?
17:30:26 <c_wraith> When I was first learning haskell, I remember a giant thread on r/haskell about how to do exactly what sourceDirectoryDeep does
17:30:36 <lingxiao> i see Data.Attoparsec.Combinator
17:30:41 <c_wraith> That thread predated all our fancy streaming IO libraries. :)
17:30:47 <lingxiao> yeah i didnt even touch that
17:30:51 <lingxiao> deep is a scary word
17:31:04 <c_wraith> Eh, not so much in this case. :)
17:31:05 <ertes> lingxiao: in Data.Conduit.Text there is also the 'lines' conduit
17:31:25 <lingxiao> https://hackage.haskell.org/package/conduit-0.0.1.1/docs/Data-Conduit-Text.html
17:31:29 <joe9> Gurkenglas_: sure, this is the library: https://github.com/joe9/streaming-betfair-api . I have not put this updateMarket/Runner code in github ye.
17:31:32 <lingxiao> i dont see lines?
17:32:07 <ertes> lingxiao: https://hackage.haskell.org/package/conduit-extra-1.1.13.2/docs/Data-Conduit-Text.html#v:lines
17:32:47 <lingxiao> ahh very clver emit each line separately
17:32:59 <lingxiao> ok this is great .. its solving a lot of my problems
17:33:05 <lingxiao> ok then for each line i can use a parser?
17:33:23 <lingxiao> so this gets rid of all the foo vs \nfoo shenaigans
17:33:29 <lingxiao> ?
17:34:09 <ertes> lingxiao: at that point you can just split at spaces
17:34:26 <lingxiao> ok and then just do text equality?
17:34:31 <ertes> you can write a conduit in terms of Data.Conduit.List.mapMaybe
17:34:53 <ertes> i wouldn't filter at that point…  just parse
17:35:39 <ertes> if you compose all of those things together you basically get a source of n-gram/count tuples
17:35:59 <lingxiao> ok so in summary .... openByteString >> convertToText >> lines >> splitAndParse
17:36:05 <lingxiao> ?
17:36:31 <ertes> yeah…  except with ($=), i think, rather than (>>)
17:37:05 <lingxiao> yeah word =$=
17:37:25 * lingxiao http://mrwgifs.com/wp-content/uploads/2013/07/That-Is-Genius-Reaction-Gif.gif   
17:37:54 <lingxiao> no parsing is definittly a +
17:38:17 <lingxiao> this channel is brillian
17:38:18 <lingxiao> t
17:41:11 <Welkin> does anyone have any resources on minimax?
17:41:15 <Welkin> everything I find sucks
17:41:29 <Welkin> I know it's simple, but I must be missing something
17:42:00 * Koterpillar built their share of minimax assignments, with a/b cut too
17:45:46 <Welkin> I haven't even added alpha-beta pruning
17:45:51 <Welkin> I can't even get the basic thing to work
17:46:23 <Gurkenglas_> joe9: My proposition is that "type RunnerChange = State Runner ()", and whereever you'd construct a RunnerChange record you instead put a do block of updating the right fields
17:47:24 <Gurkenglas_> joe9: You can even do that without lens - "type RunnerChange = Runner -> Runner", and then when you presumably would set multiple fields of a RunnerChange record at the same time, you can instead use record update syntax directly
17:48:17 <Koterpillar> Welkin: data Player = Min | Max; minimax :: Ord score => (pos -> score) -> (pos -> [move]) -> (pos -> move -> pos) -> Player -> pos -> move
17:52:02 <Welkin> Koterpillar: my minimax just takes the game state and the player, and produces the move for that player
17:52:40 <Koterpillar> Welkin: right, if you don't want it to be generic you don't have to pass all those in
17:53:06 <Koterpillar> Welkin: but how are you sure your scoring function is good?
17:54:18 <Welkin> it's not in haskell, but here is the code hastebin.com/acecewohoz.lua
17:54:42 <Welkin> starts at line 110
17:55:21 <Welkin> the scoring is pretty basic
17:55:31 <Welkin> I just check who won on the board
17:55:48 <Welkin> and produce Infinity for the max player, -Infinity for the min player, or 0 for a tie
17:56:08 <ReinH> Welkin: Look at Richard Bird's minimax, it's beautiful
17:56:13 <Koterpillar> oh, and you don't limit the depth
17:56:18 <ReinH> he extends it into alphabeta
17:57:01 <Koterpillar> sorry, I would have said something but I can't read lua well enough
17:57:51 <Welkin> ReinH: have a link?
17:58:07 <Welkin> Koterpillar: yeah, I am not limiting the depth because I just want it to work first
17:58:16 <Welkin> right now it just gives me the next open spot on the board
17:58:23 <Welkin> so it's as good as not running it
17:58:48 <Koterpillar> the only winning move is... any move?
17:59:01 <ReinH> All I can find is an Elsevier link :(
17:59:06 <ReinH> Wait!
17:59:07 <Koterpillar> what's the game? simplify it so _you_ know what the best move is
17:59:10 <ReinH> it's in Intro to FP
17:59:15 <Welkin> Koterpillar: tic tac toe
17:59:18 <Welkin> so, it is trivial
17:59:35 <c_wraith> Tic Tac Toe is harder than some.
17:59:54 <Koterpillar> Welkin: and if you let it run to completion, what happens?
17:59:58 <Koterpillar> against itself
18:00:20 <pavonia> c_wraith: Harder than what?
18:00:23 <c_wraith> like.. https://en.wikipedia.org/wiki/Nim is easier. :)
18:00:31 <Koterpillar> because in your terms, the score of the starting position, and every first move, is 0
18:00:37 <Welkin> found it here https://usi-pl.github.io/lc/sp-2015/doc/Bird_Wadler.%20Introduction%20to%20Functional%20Programming.1ed.pdf
18:00:46 <ReinH> Yeah
18:01:06 <Welkin> Koterpillar: I don't have it set up to run against itself
18:01:11 <Welkin> I am playing against it
18:01:25 <ReinH> its a beautiful example of program transformation, typical of Bird
18:01:43 <ReinH> and Hutton
18:01:56 <pavonia> One theorem and two lemmata, that doesn't sound easier :p
18:02:38 <Koterpillar> Welkin: right now you don't see what's happening, limit the depth and make a scoring function, even if it's a stupid one
18:02:52 <Koterpillar> Welkin: e.g. prefer filling the right side of the board
18:02:59 <Koterpillar> then you'll know what's correct and what's not
18:08:20 <seafood> What are people’s favourite automated testing libraries (besides QuickCheck)
18:08:41 <lingxiao> uh does anyone know if there's a conduit source that will open a file as lazy bytstring?
18:08:49 <lingxiao> https://hackage.haskell.org/package/conduit-extra-1.1.13.2/docs/Data-Conduit-Binary.html
18:08:54 <lingxiao> there is sourceLbs ---^
18:09:01 <lingxiao> but it doesnt actually open a file
18:09:12 <lingxiao> and then i need to convert a lazy bytestring into lazy text
18:09:19 <lingxiao> which there also isnt a functiont hat i can find
18:11:05 <ertes> lingxiao: why would you want that?
18:11:44 <lingxiao> ertes actually i cant explain it to you
18:11:53 <EvanR> classified
18:12:01 <lingxiao> could you explain to me why i would want to use a lazy bytestring or lazy text as a source
18:12:20 <ertes> lingxiao: no, because you wouldn't =)
18:12:24 <lingxiao> well backup i certainly wouldnt want to open a 1 GB file and put it all on disk
18:12:34 <lingxiao> so when i do sourceFile f
18:12:48 <lingxiao> what is happening there? is the whole thing opened up and put into memory?
18:12:55 <lingxiao> or is sourceFile actually streaming it
18:13:07 <ertes> lingxiao: no, it's called a streaming abstraction for a reason =)
18:13:17 <lingxiao> yeah ok that makese a lot of sense
18:14:00 <lingxiao> thanks!
18:17:13 <oelewapperke> does python or numpy have an equivalent of haskell's take() and window functions ? E.g. take(2, [1,2,3,4]) returns [(1,2), (3,4)] and window would return [(1,2), (2,3), (3,4)]
18:18:05 <Koterpillar> the latter is zip(x, x[1:])
18:18:21 <pavonia> Data.List.Split.chunksOf kind of does the first
18:18:34 <pavonia> > chunksOf 2 [1,2,3,4]
18:18:35 <lambdabot>  [[1,2],[3,4]]
18:19:41 <Koterpillar> I'm afraid the first one isn't builtin; don't know about numpy
18:20:10 <oelewapperke> thanks the zip thing is quite smart
18:20:24 <Koterpillar> also works in Haskell
18:21:06 <Koterpillar> (works properly; Python one needs adapting to work on iterators and such)
18:21:33 <jle`> anyone know how i can use higher-order type functions in singletons?
18:21:44 <jle`> something like Map Id [1,2,3] doesn't quite work becuase Id cannot be partially applied
18:22:31 <jle`> i'm pretty sure there's a way to do this within singletons, otherwise Map wouldn't exist v.v
18:22:57 <lingxiao> hey guys im getting some cryptic error message that makese no sense to me
18:23:30 <lingxiao> http://lpaste.net/177744
18:24:02 <lingxiao> ahh nevermind
18:24:05 <lingxiao> dropped parens
18:24:30 <jle`> ah i got it, Map (TyCon1 Id) [1,2,3]
18:24:56 <jle`> fun stuff
18:28:44 <lingxiao> sorry trivial question
18:28:48 <lingxiao> given string "\"swimspas\\t869\"" 
18:28:55 <lingxiao> or it's a Text actually
18:29:01 <lingxiao> I want to split it into (
18:29:11 <lingxiao> ("swimspas", 869)
18:30:49 <EvanR> use a parser
18:31:01 <lingxiao> breakOn (pack "\t") (pack "\"swimspas\\t869\"") seems liek a crude wayt to do it
18:31:09 <lingxiao> im trying to avoid a parser until the last step to be honest
18:31:58 <EvanR> (,) <$> word <* tab <*> number
18:32:21 <koz_> EvanR: Yay for applicatives!
18:33:15 <EvanR> dont be stuck in the dark ages
18:33:48 <EvanR> call today
18:35:35 <koz_> EvanR: Pay with your credit card, and receive free applicatives!
18:35:39 <Synergistics> The intmap documentation states that "Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of W -- the number of bits in an Int (32 or 64)." Does that mean that after 64 elements, the operation becomes O(n), and before that point it's O(1)?
18:36:01 <Cale> no
18:36:14 <kadoban> Synergistics: min(n, W) is at most 64
18:36:15 <lingxiao> is there a conduit source that awaits a filepath and open it as bytestring?
18:36:21 <lingxiao> i see sourceFile
18:36:30 <kadoban> It's a weird wayly specific way of specifying O(1) really.
18:36:31 <Cale> It means that it's actually O(1)
18:36:35 <lingxiao> but doing something like:    awaitForever $ \p -> sourceFile p
18:36:39 <lingxiao> clearly will not work
18:36:54 <kadoban> Wow those words ... dunno what I typed there.
18:37:04 <Cale> Synergistics: Well, assuming that the maximum size of an Int doesn't change.
18:38:15 <EvanR> its a weird wayly worldler
18:38:28 <Synergistics> kadoban: Ohh so it's like at most it will take 64 counts which is just linear complexity. Is it sort of saying that n and W are both constants and it just becomes the lower of the two?
18:38:53 <kadoban> n isn't a constant
18:39:01 <Cale> Synergistics: yes
18:39:16 <Cale> However, that seems highly questionable to me
18:39:35 <Cale> Surely they really mean O(min(log n, W))?
18:40:18 <EvanR> isnt min(n,W) = 1 in some big O sense
18:40:29 <Cale> Unless n is the log of the number of elements in the IntMap...
18:40:31 <EvanR> for fixed W
18:40:33 <kadoban> EvanR: Yeah
18:40:36 <Cale> EvanR: yes
18:40:42 <Synergistics> I would think so EvanR
18:41:03 <Cale> Oh, except the implementation of size really is O(n)
18:41:18 <Cale> ah, I see
18:41:30 <Synergistics> kadoban: Not constant, but trivial
18:41:40 <Cale> They aren't kidding, lookup really is O(min(n,W))
18:41:42 <Cale> interesting
18:41:44 <kadoban> Not sure what you mean by trivial.
18:42:32 <Synergistics> it won't grow unboundedly since it can only be O(n) up to n = 64
18:42:45 <kadoban> No, n is the number of items inside the IntMap
18:42:56 <kadoban> n can be ... really large
18:43:02 <Cale> The reason it's O(min(n,W)) and not O(min(log n, W)) is because they're not trying to balance anything (they can't)
18:43:54 <Synergistics> kadoban: But I thought we were saying that wouldn't matter after n is greater than 64
18:43:56 <Cale> But each descent gets us at least one bit closer to finding the element (or discovering it's not there)
18:44:02 <EvanR> so IntMap is theoretically big O equivalent to the holy grail functional O(1) array, except its cheating because 1) the constant factor overhead and 2) container doesnt have unlimited size
18:44:11 <Cale> So we can descend at most W times
18:44:12 <kadoban> I question how useful it even is to specify like that ... pretty sure they should just say O(1)
18:44:19 <Synergistics> Cale: would that require an Ord restraint
18:44:30 <Cale> Well, Int is certainly an instance of Ord
18:44:37 <kadoban> EvanR: Which is the same cheating that people use to say hashmaps are O(1) at least? So I guess it's ... consistently kind of goofy.
18:44:42 <Cale> It would require a different scheme for constructing the trees altogether
18:45:15 <EvanR> still interesting though
18:45:20 <Synergistics> Oh, ok
18:45:24 <EvanR> i wonder whats better, IntMap or hash tables
18:45:31 <EvanR> for Int keys
18:45:46 <Cale> The idea is that each branch node of the tree is labelled with a nonempty prefix of the bits for all the keys in that subtree.
18:46:01 <kadoban> Synergistics: Well, min(n, W) is trivial, yes.
18:46:19 <Cale> So if the prefix doesn't match, your element isn't anywhere in that subtree
18:46:33 <ertes> Synergistics: https://en.wikipedia.org/wiki/Radix_tree
18:46:56 <ertes> Synergistics: it's this, except with the bits of Int rather than characters of a string
18:48:23 <Synergistics> ertes: that sort of makes me think of an upside down merkle tree
18:48:53 <ertes> EvanR: depends on the hash function
18:51:03 <Synergistics> ertes: how so
18:51:08 <orzo> Does traverse preserve laziness?  If i have a lazy list (constructed with unsafeInterleaveIO) and use traverse on it to obtain a transformed list, will I have forced all members?
18:52:10 <glguy> orzo: That would depend on the type you used traverse at
18:52:28 <ReinH> unsafeInterleaveIO? :(
18:53:02 <jle`> orzo: you can usually make a good guess from looking at the specific implementation
18:53:03 <orzo> i don't really understand you, glguy
18:53:16 <ertes> Synergistics: as an IntMap fills up, it needs more and more branching for lookups, which involves jumping around in memory…  hash tables have far better memory locality, but they require a good hash function, which is a cost of its own
18:53:50 <orzo> my traversable is [] and my functor is IO
18:54:14 <orzo> i think invoking traverse will evaluate all the thunks
18:54:23 <glguy> orzo: With IO as the applicative it's going to force the list
18:55:55 <ertes> Synergistics: when in doubt benchmark, but my first instinct would be to choose IntMap over a hash table, if only to get a functional data structure…  hash tables need mutation to be efficient
18:56:02 <glguy> but not necessarily the elements of the list, that would depend on the function you provided to traverse
18:56:53 <orzo> i don't think it's what i intended when i wrote the code.  I think i intended to convert a lazy list of pointers to a lazy list of bytestrings, but things were complicated by the io action of converting Ptr to ForeignPtr
19:01:06 <orzo> ReinH, my unsafe use:  I'm using lazy references of bytestring-wrapped pointers into a memory-mapped database entry.  When I close the transaction, i use deepSeq and copyByteString to evacuate the bytestrings from the temporary region.  But before the transaction is closed, I can do computations with the bytestrings in place.  Does that sound like a reasonable use of unsafeInterleaveIO to you?
19:02:25 <orzo> if the ultimate result of the transactional computation is a small structure with no dangling references into the memory-mapped file, then i'll have avoided unnecessary copying
19:03:07 <seafood> What’s the favourite automated testing library at the moment (besides QuickCheck)
19:03:32 <Gurkenglas_> http://lpaste.net/1508941832082423808 <- gcc appears to be current, but stack does not setup. (Can I make it write the config.log to a place that doesn't get immediately deleted?)
19:03:35 <Synergistics> ertes: Well that brings up a question. I'm implementing a graph rewrite system and I'm thinking about storing two int maps, one for edges and one for nodes. These maps have to be rewritten quite a bit in the rewrites which gives me the feeling that going for a mutable data type would be the best option. Would you say that's a good enough reason, or
19:03:35 <Synergistics>  could intmaps handle many modifications?
19:05:17 <ertes> Synergistics: IntMap is good at pure modification
19:05:44 <ertes> in fact, depending on your algorithm, mutability may not even buy you much here
19:06:28 <ertes> there is also a rather popular graph library called fgl…  check it out, before you roll your own using IntMap
19:06:33 <ertes> @package fgl
19:06:33 <lambdabot> http://hackage.haskell.org/package/fgl
19:06:48 <Synergistics> Thanks I'll look
19:09:45 <ertes> Synergistics: indeed, it seems fgl already implements your idea
19:09:53 <ertes> https://hackage.haskell.org/package/fgl-5.5.2.3/docs/Data-Graph-Inductive-PatriciaTree.html
19:22:02 <biglambda> Is there a way to derive an instance of typeclass Storable?
19:24:02 <Synergistics> ertes: This looks pretty interesting. Some parts remind me of an earlier unfinished implementation I was working on
19:24:22 <glguy> biglambda: There exist packages for doing it with Generics, presumably template-haskell, and build tools like c2hs for automating some Storable tasks
19:24:38 <biglambda> Hmmm…
19:25:22 <biglambda> It might be better to just write an instance in this case.
19:26:39 <glguy> biglambda: hsc2hs comes with GHC and isn't hard to use
19:31:41 <kilimanjaro> i have a question about the haskell type system
19:32:05 <glguy> dcoutts (or others): is Install-includes: supposed to work when installing an executable?
19:32:36 <kilimanjaro> there are certain "randomized" algorithms, that are, when viewed in terms of inputs and outputs, functional in the sense of referential transparency
19:32:43 <glguy> In this case the header file defines an API provided for plugins which will be linked with the executable via dlopen
19:32:48 <kilimanjaro> but their implementation depends on random choices
19:33:07 <kilimanjaro> e.g. O(n) randomized median, or similar algorithms
19:33:54 <glguy> kilimanjaro: Such an algorithm would be a function from (Inputs,RandomSeed) -> (Outputs,RandomSeed)
19:34:18 <kilimanjaro> glguy: is there any (perhaps ghc-specific) way to avoid that?
19:34:29 <kilimanjaro> so that it would really just be a black box, from the end user's perspective
19:34:44 <kilimanjaro> since the actual input -> output relation is deterministic
19:35:47 <kilimanjaro> one option is to just have a seed value hardcoded
19:39:42 <lambdamu> if you know your function is pure unsafePerformIO is your friend
19:39:53 <EvanR> kilimanjaro: if the choice of seed has no effect on the purity, then you could do anything you wanted (up to IO safety) to get the seed
19:40:29 <EvanR> but if thats really the case, you could hard code it
19:40:36 <kilimanjaro> lambdamu: oh interesting
19:41:16 <EvanR> reseeding after each call is probably bad anyway
19:41:57 <EvanR> so you probably want to keep that seed as a state somehow, and then you need what glguy said
19:42:29 <EvanR> but then, the claim is it doesnt actually affect anything
19:44:26 <kilimanjaro> i think unsafePerformIO is what i wanted
19:45:15 * EvanR wonders whether reseeding with a constant, or continually reseeding with a random seed is worse
19:45:59 <lambdamu> EvarR has a point that reseeding everytime is maybe not what you want
19:46:05 <jonored> By the standards, can you readily get into trouble if an expression isn't /actually/ pure? Is it allowed to be computed twice?
19:46:24 <EvanR> it might be
19:46:51 <kilimanjaro> well, what i have in mind is a function orderStatistic :: Int -> [a] -> a
19:47:06 <kilimanjaro> so that orderStatistic n xs returns the nth largest element in xs
19:47:20 <jonored> So it does matter to keep your results /the same/, not equivalent and probably the same.
19:47:25 <lingxiao> is there a conduit funtion that folds over a stream and as soon as some condition is true, the fold stops?
19:47:39 <kilimanjaro> a randomized algorithm for this is to pick an element of xs, split the list into two halves (one less than the chosen element, the other greater than the chosen element), and then recurse
19:47:45 <EvanR> well you want to make sure youre not causing side effects
19:47:55 <lingxiao> maybe not fold, but traverse
19:48:09 <EvanR> and in this case, the results are consistent, independent of seed
19:48:41 <kilimanjaro> right, the seed effects the number of steps in the recursion
19:48:46 <kilimanjaro> for this specific example
19:48:59 <kilimanjaro> affects*
19:49:59 <kilimanjaro> so i think i could just write a helper function that takes a StdGen explicitly, and performs this computation
19:50:07 <glguy> If you're using unsafePerformIO to generate seeds you'll need to be careful that different parts of the same algorithm are seeing the same values and that new seeds are ever being generated
19:50:17 <kilimanjaro> and then wrap it in a :: Int -> [a] -> a function, using unsafePerformIO
19:50:25 <glguy> You'll be creating a lot of side conditions to discover and check
19:50:43 <ggzz> I want to do escaping. " -> \", \ -> \\, etc ... . I've googed for "haskell string escaping hackge" but not getting useful libraries.
19:50:47 <ggzz> Can someone suggest a package name?
19:51:17 <jle`> ggzz: what kind of escaping?
19:51:42 <EvanR> > show "/x/"
19:51:43 <lambdabot>  "\"/x/\""
19:51:44 <ggzz> escaping a ByteString
19:51:54 <kilimanjaro> here's very concretely what i have written http://lpaste.net/raw/5614299352894799872
19:51:56 <ggzz> preventing weird injections in HTML 
19:51:58 <EvanR> > show "\\x\\"
19:51:59 <lambdabot>  "\"\\\\x\\\\\""
19:52:07 <ggzz> so I'm outputting javascript code
19:52:12 <jle`> > text "\\x\\"
19:52:14 <lambdabot>  \x\
19:52:17 <ggzz> and I need ot handle things like alert("XYZ");
19:52:28 <ggzz> and making sure that XYZ does not end up beingn something like "); .... some stupid code injection ...
19:52:30 <EvanR> sounds like a recipe for disaster
19:52:56 <EvanR> you can usually stop that by escaping < > & ' and " in HTML
19:53:08 <EvanR> and not allowing javascript
19:53:17 <kilimanjaro> (in that code snippet i'm treating lists as if they were arrays, this is more of a learning exercise than anything)
19:53:36 <ggzz> EvanR: I'm writing a DSL -> JS compiler
19:54:00 <EvanR> well then isnt the security ensured by the DSL
19:54:31 <ggzz> yeah, but the DSL need to escape strings to ensure it compiles correctly
19:54:45 <ggzz> suppose I pass it the literal string consisting of one char ", I need it to expand to "\"", not """
19:55:34 <EvanR> what, then it sounds like a parsing problem
19:55:51 <EvanR> not a sanitizer
19:56:08 <ggzz> I'm writing a DSL that outputs javascript
19:56:15 <ggzz> suppose I have: data Stmt = Alert String
19:56:18 <kilimanjaro> lambdamu: so in my case, i guess this is actually wrong of me, as i am mutating global state (the global StdGen object)
19:56:37 <ggzz> Alert "\"" needs to expand to alert("\"");
19:56:43 <ggzz> but if I just write out tehs tring it's outputting alert(""")
19:56:56 <EvanR> theres packages for dealing with javascript syntax
19:57:08 <EvanR> maybe language-ecmascript
19:57:49 <EvanR> kilimanjaro: yeah thats pretty bad, but any two threads both doing that are suffering the same fate
19:58:01 <ReinH> how are you outputting it that it outputs """?
19:58:26 <ReinH> > show "\""
19:58:28 <lambdabot>  "\"\\\"\""
19:58:33 <kilimanjaro> EvanR: what do you mean?
19:58:40 <ReinH> heh
19:58:59 <jle`> hm, i want to make a constraint on a type that only shows up on the RHS of an associated type
19:59:02 <jle`> is there any way to do this?
19:59:22 <ReinH> jle`: eh?
19:59:23 <jle`> oh i just said it out loud and it sounds kind of clear how to do this now
19:59:24 <EvanR> kilimanjaro: by using randomIO, youre basically saying "i dont really care who is messing with this generator besides me"
19:59:32 <jle`> hm
19:59:52 <EvanR> if you did, youd use your own generator
19:59:59 <jle`> instance (Foo a) => Bar b where type Baz b = Something a
20:00:02 <jle`> does that even make sense
20:00:30 <jle`> class Bar b where type Baz b
20:00:50 <EvanR> with randomIO and "rand" in other languages, youre satisfied when you try it twice and it gives you two different answers
20:01:08 <ReinH> you can split a generator and hand one off to the forked thread
20:01:09 <EvanR> and thats about it
20:01:28 <glguy> jle`: what you wrote doesn't make sense but presumably what you wrote is more general than you meant
20:01:42 <lingxiao> hey gusy
20:01:49 <lingxiao> suppose i have this:   [\"Caribbean Photography\",\"272\"]  :: [Text]
20:01:54 <jle`> @tell gusy lingxiao says hi
20:01:54 <lambdabot> Consider it noted.
20:02:00 <lingxiao> why is that when i unpack the two elements
20:02:16 <lingxiao> the backslashes all disappear?
20:02:23 <EvanR> youre doing it the hard way, instead of using a parser
20:02:25 <lingxiao> like  what is this:  \"Caribbean Photography\"
20:02:36 <lingxiao> ahh it's you again!
20:02:40 <ReinH> where did it come from?
20:02:41 <lingxiao> you might be right
20:02:44 <EvanR> > [\"Caribean\"]
20:02:45 <lambdabot>  <hint>:1:15:
20:02:45 <lambdabot>      lexical error in string/character literal at end of input
20:02:52 <lingxiao> yeah exactly... i cant even print that
20:02:54 <jle`> lingxiao: i'm not really sure how [\"carribean photography\",\"272\"] is supposed to make sense as an expression
20:03:01 <ReinH>  that isn't Haskell syntax
20:03:03 <lingxiao> yeah i dont know either
20:03:12 <lingxiao> thats what it looks like when i rpint it
20:03:23 <lingxiao> anyways i decoded a bytestring into text 
20:03:34 <ReinH> show it, perhaps?
20:03:37 <lingxiao> and then split the text into lines
20:03:51 <lingxiao> and finally splitOn "\t"
20:04:09 <ReinH> the quotes would need to be escaped if it were shown, not printed
20:04:14 <lingxiao> on the screen thisis exactly what i see: "[\"Caribbean Pinball\",\"193\"]" 
20:04:23 <lingxiao> ok so that is ok
20:04:26 <lingxiao> it is legal
20:04:27 <ReinH> yes, as I said
20:04:52 <lingxiao> ok maybe i should use a parser
20:04:59 <lingxiao> :( 30 minutes wasted
20:04:59 <ReinH> that is a string-like, not a list of them
20:05:28 <lingxiao> so if i was to write a parser on this : "[\"Caribbean Pinball\",\"193\"]" 
20:05:36 <lingxiao> you know suppose its of type [Text]
20:05:53 <lingxiao> can i just take the first elemnt and trust that it's of form "Caribbean Pinball"
20:06:02 <lingxiao> no backslashes ... i dont even know what they mean
20:06:11 <glguy> randomRIO is safe to use across multiple threads with its atomic updates to the global, at least
20:06:13 <ReinH> why are you showing it in the first place?
20:06:25 <ReinH> just don't do that
20:06:25 <EvanR> yeah i assumed as much
20:07:04 <lingxiao> oh just printing to console to see what i have
20:07:13 <lingxiao> then i saw the \ and got confused
20:07:32 <jle`> lingxiao: a \" in a string literal is how you specify a " in the string
20:07:48 <ReinH> you are `show'-ing it, the backslashes are escapes
20:07:53 <jle`> for example, the string literal "a\"b" is the string `a"b`
20:08:11 <ReinH> you don't need to parse anything
20:08:25 <lingxiao> you mean refering to EvanR?
20:08:31 <jle`> the backslashes aren't "in" the string, they're just a part of string literal syntax to specify that there is a quotation mark there
20:08:49 <jle`> the string indicated by the literal "a\"b" is `a"b` -- there are no slashes in it
20:08:54 <ReinH> it is already a [Text] before you show it
20:09:05 <jle`>  \" is just how you type a " in string literal syntax
20:09:12 <lingxiao> ok got it
20:09:15 <lingxiao> oh boy ...
20:09:15 <ReinH> you don't need to show it and then parse it again
20:09:16 <lingxiao> so much to learn
20:09:32 <lingxiao> oh i just showed it to print it.. when parsing im not going to show it first
20:09:38 <lingxiao> i do need to parse though
20:09:46 <lingxiao> im looking for specific parttersn in the string
20:09:53 <lingxiao> like * (,) foo bar *
20:10:12 <lingxiao> i think EvanR was saying i should just parse it to begin with
20:10:22 <ReinH> btw to print it you can just use print. It looks like you are using print . show
20:11:23 <lingxiao> yeah i did  ... hmm 
20:11:24 <ReinH> yes, sounds like a case for parsing
20:11:25 <lingxiao> :t print
20:11:26 <lambdabot> Show a => a -> IO ()
20:11:31 <lingxiao> oh i see
20:11:38 <ReinH> print shows things already
20:12:24 <EvanR> > (show . show . show . show) "yoo hoo"
20:12:26 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"yoo hoo\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
20:12:29 <ReinH> you are printing the inspected version of the inspected version of the value
20:12:45 <ReinH> such \
20:12:48 <ReinH> wow
20:12:48 <lingxiao> oh i see
20:13:06 <lingxiao> im creating problems for myself 
20:13:08 <lingxiao> x(
20:13:20 <ReinH> print = putStrLn . show
20:13:31 <lingxiao> :t putStrLn
20:13:32 <lambdabot> String -> IO ()
20:13:39 <lingxiao> ok things make so much more sense now
20:13:41 <ReinH> print . show = putStrLn . show . show
20:13:53 <lingxiao> word
20:13:56 <ReinH> yay :)
20:14:41 <ReinH> jle`:  whatcha doin'?
20:15:10 <joe9>  I have a enum type defined in 2 different packages with same values. Is there a simple way to convert between them both.  http://bpaste.net/show/afd47fa8b928 is the type in one package and I am trying this http://bpaste.net/show/a0aba667b0e8
20:15:21 <jle`> ReinH: to prompt the question i asked earlier, or just in general?
20:18:33 <ReinH> jle`: yes
20:19:06 <ReinH> joe9: yes. write two functions.
20:19:40 <jle`> just playing around with the singletons library heh.  and in general in life, just busy with some contracts atm ><
20:19:43 <jle`> how about you?
20:19:47 <jle`> any haskellcasts in the future?
20:20:00 <ReinH> possibly doing some .NET work o_O
20:20:08 <joe9> ReinH: I could use deriving Enum and then toEnum . fromEnum?
20:20:24 <ReinH> Chris and I are planning on scheduling one soonish
20:20:29 <jle`> ReinH: fun stuff :O
20:20:53 <jle`> i hear that the whole .net stuff works well together smoothly if you stay in that world
20:21:05 <lingxiao> thanks all!
20:21:06 <lingxiao> im off!
20:21:12 <ReinH> you could, assuming the ctors match in number and order, but I would not call that simpler.
20:21:35 <ReinH> I would call that unnecessarily clever
20:22:06 <nanovad> Hi all, newbie to Haskell. I'm using listDirectory in a list comprehension, but it seems that listDirectory returns an IO [FilePath]. Can I somehow escape this IO in the list comprehension?
20:22:10 <ReinH> jle`:  maybe i can use F#
20:22:25 <ReinH> No, you cannot
20:23:04 <ReinH> but you can a function without an IO type from your action
20:23:35 <jle`> ReinH: yeah, microsoft seems to have put in a lot of work to make f# and all its pals work well together.  is this for work? :o
20:24:06 <ReinH> e.g., do paths <- listDirectory; let paths' = listComp paths; ...
20:24:30 * jle` imagines a .net backend for ghc
20:24:43 <ReinH> can call a*
20:25:19 <Rotaerk> if you build a library in F# that you intend to use from other languages, you have to build it a bit differently from a library you only intend to use from F#
20:25:45 <Welkin> jle`: ew
20:25:56 <Rotaerk> you can always use any library from C# to F# and vice versa, but it's going to be ugly if you don't design for it
20:28:49 <jle`> i always hear the interval in my head when people mention C# and F#
20:28:56 <nanovad> ReinH: Hmm. Okay, I think I've got it. Thanks :)
20:29:47 <ReinH> nanovad: or the lhs of the let could be a list comprehension
20:29:54 <ReinH> er, rhs
20:30:12 <nanovad> RHS?
20:30:31 <ReinH> right hand side (of the =)
20:30:36 <nanovad> Ah
22:00:12 <Myrl-saki> I'm making 2048. How should I track which coordinates are 0 so that I can have a random thing placed on it?
22:00:13 <Myrl-saki> s/thing/number/
22:00:15 <Myrl-saki> I'm thinking of using heaps and a vector. Or maybe
22:00:31 <Myrl-saki> just a vector
22:00:42 <Myrl-saki> I'm also considering using matrices.
22:08:40 <glguy> Myrl-saki: When I did it I went with lists of lists for the board https://github.com/glguy/TwosGame/blob/master/Main.hs
22:08:56 <Myrl-saki> glguy: Yeah, that's what I'm also doing right now.
22:14:23 <Myrl-saki> glguy: I wonder if it'd be evil to use an unstable queue to generate psuedo-random indices.
22:16:09 <Myrl-saki> glguy: I'm really theinking that I should use lens for this though.
22:16:32 <Koterpillar> Myrl-saki: if you do, just write your own for the lists, and you'll be able to switch out the implementation later
22:17:04 <Myrl-saki> Koterpillar: that's pretty smart.
22:19:39 <mniip> my bash implementation just uses a 16-array
22:19:45 <jle`> is there some function i can use for (a :~: b) -> Void if i know a is not b or something
22:20:05 <jle`> that might not even make sense
22:20:24 <jle`> how do people usually make their (a :~: b) -> Void's then
22:21:05 <jle`> i guess we just rely on GHC being able to check that such a branch doesn't exist
22:21:09 <jle`> er, is unreachable
22:21:13 <shachaf> That's the only way.
22:21:36 <shachaf> I sent an email about that to glasgow-haskell-users in Mar 2013.
22:22:20 <shachaf> With just Leibniz equality, you can't even write a value of the type Is Char Bool -> Void
22:22:28 <shachaf> It's not inhabited.
22:22:30 <shachaf> (As far as I know.)
22:22:53 <jle`> seems fair enough
22:23:08 <jle`> ghc's exhaustiveness checker has been pretty smart in 8.0 compared to 7.8
22:23:26 <jle`> so i've needed to ... -> error "unreachable" a lot less these days
22:24:40 <Hafydd> I prefer error "impossible".
22:31:08 <joe9>  I am looking for a logging package. Any recommendations, please?
22:34:53 <nshepperd> error "inconceivable!
22:38:51 <joe9> http://hackage.haskell.org/package/logger-0.1.0.2 looks pretty cool.
22:38:56 * hackagebot dbm 0.1.0.0 - A *simple* database migration tool.  https://hackage.haskell.org/package/dbm-0.1.0.0 (RickyElrod)
22:44:21 <nshepperd> jle`: set -XEmptyCase -XLambdaCase and call your function (\case)? :)
22:44:54 <nshepperd> works in ghc 8.0 \o/
22:45:35 <jle`> thanks :3
22:48:19 <Axman6> joe9: is EmptyCase a thing?
22:48:29 <Axman6> uh, s/joe9// - sorrt joe!
22:48:32 <Axman6> y*
22:49:08 <Axman6> joe9: I haven't found a logging framework I like yet, I've used a few but they all feel kind of heavey weight
22:49:40 <Axman6> it's particularly annoying when you're using a framework which seems to have pre-picked a logging framework (like persistent) but it's not the one you wanty
22:52:03 <joe9> Axman6: ok, Thanks.
22:52:55 <joe9> Instead of using Read or Show for serialization. Is it recommended to use json (and, aeson)?
22:54:49 <EvanR> whatever works
22:55:26 <Axman6> there are specific frameworks which aim to give you richer logging, such as katip: https://www.stackage.org/lts-6.7/package/katip-0.2.0.0
22:55:39 <izohask> if I have Applicative "CmdParser a"
22:55:49 <izohask> is it possible to have func 
22:55:50 <nshepperd> jle`: hmm, actually it's not warning on incomplete patterns for me, with (Int :~: Int) -> Void :S
22:55:51 <joe9> Axman6: Thanks, will check it out.
22:56:02 <izohask> readInt :: String -> CmdParser a 
22:56:58 <izohask> I want to be able to do this: "SomeData <$> readInt "abc" <*> readInt "something" 
22:57:11 <Axman6> looks like that shoulkd work to me
23:01:47 <izohask> hello 
23:02:08 <Axman6> izohask: hi, what you've written looks like it should work
23:02:18 <izohask> hi, thnx
23:02:28 <izohask> I do not understand how to write readInt
23:02:31 <lispy> joe9: also you could use the binary and cereal packages
23:02:40 <izohask> as I have to return "CmdParser a" somehow
23:02:54 <KB5> What's this I've heard about network package having issues on Windows? Can someone give me details on the situation as it is today?
23:02:57 <izohask> and I do not know what is "a" ?
23:03:06 <lispy> joe9: Read/Show are recommended to go together, but the Read parsers are slow and give bad error messages.
23:03:29 <lispy> joe9: So it's usually best to not rely on them for anything important. More of a debug tool.
23:04:06 <joe9> lispy, good to know. Thanks. aeson has been good to me. Not sure If I switch to using aeson for storing/reading state.
23:04:24 <lispy> KB5: it used to have issues building there. It was hard for people to get their build environments into the right shape. I think people were (or are?) actively working to change that. I haven't been following it though.
23:04:56 <Axman6> izohask: what is readInt supposed to do?
23:05:02 <KB5> lispy: so as long as you get it to build, it works for end-users?
23:05:08 <lispy> joe9: I would say the choice between aeson and cereal is probably one of do you want human readable or binary?
23:05:27 <joe9> lispy: human-readable for me.
23:05:29 <lispy> KB5: that's my understanding but I haven't really used it much on windows or otherwise
23:05:32 <izohask> data CmdParser a = CmdParser (a, [FiedType])
23:05:57 <izohask> readInt should add "FieldInt paramName" in "[FieldType]"
23:06:33 <izohask> so it should create same CmdParser, but with specific [FieldType]
23:06:51 <Axman6> then the only sensible type for it is readInt :: String -> CmdParser () - you don't know anything about the a so you can'r create one
23:07:12 <KB5> lispy: alright, thanks
23:07:45 <Axman6> izohask: what value are you expecting to be placed into the SomeData constructor?
23:08:43 <izohask> SomeData = SomeData {id::Int, name::String}
23:09:22 <izohask> but now I want to be able to "describe" someData , adding field descriptions using  CmdParser
23:09:56 <joe9> Axman6: one thing about aeson is that it needs TemplateHaskell. I wish it could use generics or typeable to figure out the structure.
23:10:53 <lispy> joe9: isn't that only if you use Data.Aeson.TH?
23:11:34 <lispy> joe9: i think it can figure out the structure from Generic. I'm not an aeson expert, but that's the way the docs read
23:11:49 <joe9> lispy, ok, cool. will check them out.
23:12:13 <lispy> night all
23:12:17 <joe9> lispy, I am trying to figure out if Data.Map.Strict has a FromJSON or ToJSON instance. What would be the best way to check it out.
23:13:18 <lispy> joe9: the two most likely places to find that instance or either where the type is defined or the class. In this case we wouldnt expect to see it where the type is defined. So look at th FromJSON class in the haddocks and look at the instances.
23:13:24 <nshepperd> oh, there's a bug about empty case not working with the exhaustiveness checker :( https://ghc.haskell.org/trac/ghc/ticket/10746
23:13:47 <joneshf-laptop> Anyone have some interesting examples of type level programming you can do with plain old Hindley-Milner?
23:14:12 <lispy> joe9: just glancing at it, I don't see an instance but you could write one fairly easily
23:14:18 <lispy> anyway, I'm off
23:14:51 <lispy> joe9: sorry, I do see the instance for map
23:15:09 <lispy> joe9: https://hackage.haskell.org/package/aeson-1.0.0.0/docs/src/Data-Aeson-Types-FromJSON.html#line-1466
23:19:38 <adarqui> any async packages which operate over some arbitrary monad, instead of IO?
23:19:52 <adarqui> with a base MonadIO maybe? i dno
23:20:20 <adarqui> need to possibly run a bunch of queries asynchronously in my yesod app .. want to experiment with it
23:21:14 <quchen> You cannot async arbitrary monads, you always need IO.
23:21:35 <adarqui> maybe this: https://hackage.haskell.org/package/lifted-async
23:23:38 <angerman> how do i construct some recursive data type over some other data type? Say T a = N a a | L, now I want have `a` be `Either String a`. And I want to end up with a type T', such that `T' Int` would be a tree like structure with Either String T' Int. 
23:24:47 <Koterpillar> angerman: data T f a = N (f a) (f a) | L
23:25:43 <angerman> Koterpillar let me play with that a little.
23:30:13 <adarqui> dang.. yesod uses MonadBaseControl under the hood.. so lifted-async might just work.
23:30:32 <adarqui> just replaced my forM with mapConcurrently.. this is exciting .. need to wait a few minutes for this thing to build though hehe.
23:36:53 <adarqui> that is crazy.. this page I load which has tons of data takes ~5s to load without async.. just by changing that one line, it's down to 1.59 seconds with async.. i mean the queries and such are not optimized at all, but right now i'm not trying to optimize them soo.. i'd like this page to load fast even with my 'novice query system' .. so simply dropping in async really helped
23:37:01 <adarqui> pretty cool
23:39:12 <johnw> Haskell is really nice that way
23:39:30 <johnw> I've often had the experience that adding concurrency to double or triple speed only take a few lines of code, and introduces no new bugs
23:40:10 <johnw> the lack of shared state helps so much
23:59:29 <adarqui> ya
23:59:33 <adarqui> absolutely amazing
