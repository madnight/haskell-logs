00:08:54 <ocramz> I'm watching the "Being lazy with class" pres by SPJ (HOPL'07, https://www.youtube.com/watch?v=3bjXGrycMhQ ): fun and informative 
00:10:24 <kosmikus> ocramz: indeed. certainly worth watching.
00:18:21 * hackagebot emailaddress 0.1.6.0 - Wrapper around email-validate library adding instances for common type classes.  https://hackage.haskell.org/package/emailaddress-0.1.6.0 (cdepillabout)
00:21:51 <ongy> I have a type that consists mostly of FunPtr and StablePtr (for FFI interface). When I poke an object of this type into a pointer and the object runs out of scope, does the GC remove the functions pointed to?
00:24:25 <mauke> what do you mean by "scope"?
00:25:52 <ongy> I have a function that's 'do { impl <- getImplementation; ptr <- malloc; poke ptr impl; return callToFFI ptr }' where the library stores the ptr (which points to a struct containing FunPtrs)
00:28:46 <quchen> ongy: Ptr and FunPtr are not tracked by GHC in any way.
00:29:05 <quchen> ForeignPtr is a data type that does things like these.
00:29:27 <ongy> I may have to explain a bit better, brb with a paste
00:36:58 <lpaste> ongy pasted “Ptr example” at http://lpaste.net/179462
00:37:12 <ongy> I have a structure somewhat similar to that
00:38:28 <ongy> and the library call I make stores the ptr, which then points to a struct with some FunPtrs created by the ffi-wrapper mkFun function. afaik GC should clean up 'impl' from 'getWrapper' and therefore the FunPtrs stored in that object. Will this also free the functions made with the wrapper?
00:38:47 <Rudes> i'm having a logic issue with Function :: String -> [String] -> IO () where if [String] has more than one value it jumps to my Function _ _ pattern.
00:39:03 <ongy> Rudes: can you paste your code?
00:39:13 <Rudes> yep, two seconds
00:39:37 <Rudes> http://cryopaste.com/8e9b26
00:39:55 <Rudes> and it's the whichCommand function
00:40:06 <Koterpillar> Rudes: [s] is a list of one element, s
00:40:23 <ongy> Rudes: the pattern match [s] is for "singleton list, with element called 's'", for more than one element it's (s:xs) where xs will be the tail of the list
00:40:52 <Koterpillar> Rudes: to match any list at all, use just '_' or 'args'
00:41:01 <Rudes> oh i see
00:41:36 <ongy> ah, since freeHaskellFunPtr exists and "should be released with freeHaskellFunPtr' I guess it's fine to use it like I do
00:41:38 <Rudes> thank you all that's exactly what was going on!!
00:41:43 <Koterpillar> Rudes: there are also libraries to help you parse arguments
00:41:57 <Rudes> Koterpillar: i'll check those out
00:42:29 <Koterpillar> Rudes: can't vouch for any of them though
00:42:47 <Rudes> okay
00:43:22 * hackagebot result 0.1.0.0 - Encode success or at least one error  https://hackage.haskell.org/package/result-0.1.0.0 (srijs)
00:48:22 * hackagebot result 0.2.0.0 - Encode success or at least one error  https://hackage.haskell.org/package/result-0.2.0.0 (srijs)
01:03:22 * hackagebot purescript-bridge 0.7.0.0 - Generate PureScript data types from Haskell data types  https://hackage.haskell.org/package/purescript-bridge-0.7.0.0 (eskimo)
01:14:27 <ongy> the magic power of haskell. Running almost 2 days of work (ok, most of it was digging through apis) for the first time. And it works
01:14:40 <Rudes> ongy: nice
01:14:59 <Rudes> anyone here running vim for haskell development? if so what's the best plugin for haskell on vim
01:15:11 <mauke> I use no plugins
01:15:28 <Koterpillar> Rudes: I have bookmarked http://www.stephendiehl.com/posts/vim_2016.html, but I didn't follow it through yet
01:15:33 <Rudes> mauke: i can respect that.
01:17:35 <Rudes> Koterpillar: idk man, suggesting we use his .vimrc, almost disrespectful.
01:18:07 <Koterpillar> Rudes: who says you have to follow guides by the letter?
01:18:19 <Rudes> i know. just saying
01:18:22 <Rudes> how dare he
01:18:24 <Rudes> lol
01:19:05 <pkmx> For neovim: neomake for ghc-mod/hlint errors, deoplete+neco-ghc for auto-completion, haskell-vim for syntax highlighting
01:19:30 <Rudes> haskell-vim on the neovimhaskell github?
01:19:53 <pkmx> yep
01:20:31 <pkmx> but i remove the indent file that comes with it since it never works the way i want
01:20:55 <Rudes> yeah, indents usually operate weird in plugins
01:21:27 <mauke> ooh, so you're (indirectly) one of my users
01:22:03 <Rudes> hmm?
01:22:40 <mauke> I've written the terminfo library that neovim uses
01:22:50 <Rudes> oh, awesome dude.
01:22:58 <Rudes> i'm still running vim, haven't made the switch to neo.
01:23:03 <mauke> wait, that's "I wrote", isn't it? /me is confused with tenses
01:24:20 <Rudes> mauke src/nvim/tui/tui.c?
01:24:38 <mauke> unibilium
01:24:43 <mauke> is that in there somewhere?
01:24:50 <pkmx> I can totally see another great editor war coming when vim 8.0 releases lol
01:25:15 <Rudes> mauke: sure is
01:25:28 <Rudes> pkmx: that's why i'm going back to ed for a while
01:29:58 <Rudes> mauke: this is a cool lib man, nice work.
01:31:45 <mauke> thanks
01:48:24 * hackagebot mysql-haskell 0.4.0.0 - pure haskell MySQL driver  https://hackage.haskell.org/package/mysql-haskell-0.4.0.0 (winterland)
01:54:07 <{AS}> The difference between quot and div is what they are truncated towards, right?
01:55:12 <{AS}> ?check \(x, y) -> x `quot` y == x `div` y
01:55:14 <lambdabot>  *** Failed! Exception: 'divide by zero' (after 1 test):
01:55:15 <lambdabot>  (0,0)
01:55:29 <{AS}> ?check \(x, y) -> y != 0 ==> x `quot` y == x `div` y
01:55:30 <lambdabot>  Not in scope: ‘!=’
01:55:30 <lambdabot>  Perhaps you meant one of these: ‘!’ (imported from Data.Array), ‘Data.Map.!’...
01:55:52 <exDM69> ?check \(x, y) -> y /= 0 ==> x `quot` y == x `div` y
01:55:52 <lambdabot>  : -1: -1:Ambiguous infix expression
01:56:24 <{AS}> ?check \(x, y) -> (y /= 0) ==> (x `quot` y == x `div` y)
01:56:25 <lambdabot>  *** Failed! Falsifiable (after 10 tests and 6 shrinks):
01:56:25 <lambdabot>  (5,-11)
01:56:54 <exDM69> looks like the rounding mode, yeah
01:57:04 <exDM69> other one rounds to zero and other one rounds down
02:00:07 <{AS}> exDM69: Thanks
02:25:04 <niluje> how can I write (.) print ((+) 3) 3 with the infix notation?
02:26:20 <liste> niluje: start with (.) a b -> a . b
02:26:46 <liste> so it's "print . (((+) 3) 3)"
02:27:13 <mniip> no
02:27:29 <mniip> (print . ((+) 3)) 3
02:27:46 <liste> oh, mniip's right, just noticed there's 4 items
02:28:39 <niluje> :o
02:28:50 <niluje> and is it possible to remove the parenthesis around (print ..)?
02:28:52 <niluje> (just wondering)
02:29:03 <mniip> no
02:29:17 <mniip> a b . c d = (a b) . (c d)
02:29:35 <niluje> ok
02:29:53 <niluje> thanks a lot, again :)
02:30:44 <edwardk> niluje: print . (+) 3 $ 3
02:31:03 <niluje> oh nice
02:31:03 <mniip> a wild edwardk appareated
02:31:07 <mniip> appeared
02:31:19 <edwardk> he used ($), it was super effective
02:31:20 <mniip> (how did I type that)
02:31:40 <niluje> operators priority is still magic to me
02:31:51 <mniip> idunno, ($) seems pretty... uneffectful to me
02:31:55 <edwardk> $ has very low priority, . has very high priority
02:32:15 <niluje> 9 is the highest priority, right?
02:32:19 <edwardk> as in they are at the extremes
02:32:21 <edwardk> yes
02:32:24 <niluje> okay
02:32:48 <edwardk> the only thing that binds tighter is ' ', @ and the { ... } record manipulation stuff
02:33:11 <niluje> what is @?
02:33:19 * niluje understands
02:33:21 <edwardk> @ is used in patterns and now for type application
02:33:31 <niluje> that's why you can write print $ 3 + 3 and not print 3 + 3
02:33:48 <niluje> okay, I guess I'll dig into that later
02:33:52 <edwardk> yeah because the latter becomes (print 3) + 3
02:33:56 <niluje> yep
02:34:14 <edwardk> the at stuff gets used for things like  foo xxs@(x:xs) = ...
02:34:15 <niluje> a function taking an Int and returning an IO ()
02:34:22 <niluje> no wait
02:34:25 <edwardk> binding xxs to the whole composition of x:xs  and x and xs to the parts
02:34:49 <mniip> hey edwardk, I sent you a message thingy
02:34:51 <niluje> yeah ok sorry nevermind
02:35:01 <edwardk> print 3 + 3   would require Num (IO ())   =)
02:35:08 <niluje> yes
02:35:25 <ongy> Num (IO ()) sounds so reasonable
02:35:45 <edwardk> mniip: i have a weaker version of Lifting in constraints
02:36:03 <edwardk> mniip: it only has one * -> Constraint argument though
02:36:22 <edwardk> ongy: well, it is easily defined, if silly
02:36:29 <mniip> yeah
02:36:32 <mniip> that's what I was looking at
02:37:25 <mniip> but you can write silly stuff like instance Lifting (Lifting (Lifting Show Show) (Lifting Show Show)) Show WriterT
02:38:13 <ongy> I don't know enough about the IO type for that. Isn't it (# state, a #) or something similar? Is the state a Num type?
02:39:14 <ocramz> I'd like to write an instance of Fractional, but the (:%) constructor is not exported from Data.Ratio , how can I do it?
02:39:18 <mniip> lazily speaking IO a is just an 'a'
02:39:32 <mniip> strictly speaking it's State# RealWorld -> (# State# RealWorld, a #)
02:40:16 <mniip> as State# RealWorld not only has one value, but is represented by literally nothing at runtime
02:42:06 <ocramz> mniip: and this is where it gets metaphysical
02:43:18 <mniip> it gets worse once you bring GHC threaded semantics in
02:44:37 <ocramz> so getting back to ongy 's question, IO a is not a Num
02:44:47 <mniip> it could be
02:44:55 <mniip> but it would hardly be useful
02:47:53 <mniip> edwardk, have you ever been able to extend reflection to typeclasses with multiple methods?
02:49:13 <edwardk> mniip: just make a record that exposes each of the methods, then make the instance peel out the fields of the record it needs
02:49:21 <edwardk> even the Monoid example has multiple methods
02:49:30 <edwardk> you don't reflect directly as the class
02:49:30 <mniip> except
02:49:33 <mniip> it doesn't work
02:50:09 <mniip> er which monoid example you mean
02:50:31 <edwardk> no, i'm not saying make a record like the Reifies s a class. i'm saying follow the general example that thoughtpolice wrote up based on how i did it in an early reflection demo
02:51:20 <mniip> ah
02:51:27 <mniip> you just Reflect the datatype
02:51:55 <mniip> edwardk, I was talking about the unsafeCoerce (->) -> (=>) trick
02:52:27 <edwardk> yeah you can't do that
02:52:42 <edwardk> not even trying to
02:52:52 <mniip> I got it working in -fobject-code and compiled haskell
02:53:07 <mniip> but it suffers from weird pointer tagging issues in ghc/runhaskell
02:53:20 <edwardk> Constraint isn't *, so you can't rely on the representation allowing things like unevaluated thunks, tags, etc.
02:53:21 <mniip> ghci/runhaskell
02:54:27 <mniip> I thought the difference between => and -> is erased in Core?
02:54:39 <edwardk> short answer is don't bother, and stick with a single member 'class' that then is used to derive the instance for the multi-member one. by the time it gets done building the new instance through => all the parts get swizzled into place anywyas
02:54:51 <mniip> oh no, I'm doing something else
02:54:53 <int-index> edwardk, re "Constraint isn't *": in Core it is, and in surface Haskell can become in the future
02:55:16 <mniip> data family DictRep :: Constraint -> *
02:55:16 <mniip> save :: Dict c -> DictRep c
02:55:16 <mniip> instantiate :: DictRep c -> Dict c
02:55:16 <int-index> https://ghc.haskell.org/trac/ghc/ticket/11715
02:56:00 <edwardk> int-index: in core they act the same, but then we don't do all the same things on them, es evidenced by mniip's issue here with pointer tags.
02:56:46 <edwardk> int-index: and i'm dubious about that ticket
02:56:55 <edwardk> i've not been vocal enough on it =)
02:57:04 <mniip> if they are the same in core shouldn't they compile to the same stg
03:03:54 <mniip> a-ha
03:03:56 <bsmt> right, so I have an ADT with a bunch of constructors (no parameters), and another data type with constructors that may require this type or others. problem is for some of the constructors in the latter, only some values of the former make sense. is there a way to tell the compiler to enforce that?
03:04:18 <bsmt> I figured maybe existential types would do it, but it doesn't seem so
03:05:30 <mniip> base_GHCziEnum_maxBound_info+64 is expecting %rbx to contain a pointer tagged with 1 (as the C:Bounded con has index 0)
03:05:42 <mniip> but in my homemade instance dictionary the pointer is untagged
03:08:08 <bsmt> in other words, I'd like some constructors to be valid only for a subset of their parameters. how do without making a bunch of new types?
03:23:26 * hackagebot genvalidity 0.2.0.2 - Testing utilities for the validity library  https://hackage.haskell.org/package/genvalidity-0.2.0.2 (Norfair)
03:25:44 <mniip> I wish I could read stg
03:25:44 <edwardk> int-index: i've raised my issues on the ticket. thanks for forcing that function =)
03:28:27 * hackagebot validity 0.3.0.2 - Validity typeclass  https://hackage.haskell.org/package/validity-0.3.0.2 (Norfair)
03:28:29 * hackagebot result 0.2.1.0 - Encode success or at least one error  https://hackage.haskell.org/package/result-0.2.1.0 (srijs)
03:34:50 <mniip> edwardk, ooh magical newtype
03:34:55 <mniip> I suggested that in #ghc the other day
03:35:06 <dibblego> what is the earliest version of lens that compiles with ghc-7.10.3?
03:35:32 <puregreen> dibblego: http://matrix.hackage.haskell.org/package/lens
03:35:36 <dibblego> thanks
03:35:47 <puregreen> 4.8, it seems
03:36:17 <dibblego> hmm, I have it compiling 4.12.3 with ghc-7.10.1 but not ghc-7.10.3
03:40:36 <dibblego> src/Control/Lens/Internal/Zoom.hs:50:1: Data.Functor.Bind: Can't be safely imported!
03:40:37 <dibblego> I meant #haskell-lens oops
03:59:13 <rahulmutt> Does anyone know how to implement a MonadFix instance for the Get monad from the binary package?
04:03:16 <fr33domlover> rahulmutt, idk but Get seems to wrap a continuation. So maybe check if ContT has a MonadFix instance
04:03:20 <fr33domlover> and see how it's written
04:05:51 <rahulmutt> I did take a look and was not able to find one. I wonder if it's not possible.
04:06:36 <rahulmutt> Moreover, the old versions of the binary package seem to have a Get with a MonadFix instance, but the new ones don't. Maybe because of a switch from state to continuations
04:18:27 <fr33domlover> rahulmutt, maybe there is a logical issue with having MonadFix for continuations. I just don't know enough about MonadFix to say
04:43:42 <lyxia> http://www.carlssonia.org/ogi/mdo-callcc-slides.pdf it seems there is an incompatibility between continuations and monadfix indeed
04:54:54 <Cale> lyxia: Isn't the conclusion of the paper somewhat opposite to that? I suppose you lose left-shrinking.
04:55:52 <Cale> Perhaps that's what you meant though :)
04:56:13 <Cale> http://www.carlssonia.org/ogi/mdo-callcc.pdf has more details
04:58:32 <lyxia> The prerequisite that we have references seems too strong for Get.
05:00:02 <Darwin226> Hey, is there a reason why lazy bytestrings don't have an isInfixOf and strict ones do?
05:04:58 <cocreature> Darwin226: seems like an oversight
05:08:50 <cocreature> lazyness would even be potentially useful in both arguments
05:08:59 <cocreature> in the first if there is no match and in the second if there is a match
05:14:52 <Darwin226> It's actually commented out in the export list
05:15:01 <Darwin226> weird
05:15:16 <liste> sounds like a use case for git blame
05:17:19 <Darwin226> https://github.com/haskell/bytestring/commit/a12fd51380e4357b607614d30eddab53eb456e8d
05:17:29 <Darwin226> Sounds like nobody got around to implementing it
05:18:09 <int-e> Hmm, I'd actually expect a mixed signature for that function: the needle would be a strict bytestring while the haystack would be lazy.
05:19:07 <int-e> anyway, git blame says: "Add commented out exports for functions we're missing"
05:23:30 * hackagebot mollie-api-haskell 0.1.0.0 - Mollie API client for Haskell http://www.mollie.com  https://hackage.haskell.org/package/mollie-api-haskell-0.1.0.0 (matsrietdijk)
05:28:30 * hackagebot xdcc 1.1.2 - A wget-like utility for retrieving files from XDCC bots on  IRC  https://hackage.haskell.org/package/xdcc-1.1.2 (JanGerlinger)
05:30:49 <saurabhnanda> piyush-kurur: are you around?
05:31:33 <yamadapc> How can I clear the cache on stack without breaking things?
05:32:04 <yamadapc> There're over 50GB of ~/.stack/snapshots on my computer atm...
05:37:01 <{AS}> Is there any reason why ==> in quickcheck is not Property -> prop -> ... ?
05:37:11 <{AS}> Property -> prop -> Property
05:39:07 <Rudes> {AS}: are you talking about Test.QuickCheck.quickCheck?
05:39:12 <{AS}> Rudes: Yeah
05:39:20 <{AS}> The (==>)
05:39:27 <{AS}> It expects a bool on the left hand side
05:39:29 <{AS}> not a Property
05:39:41 <Rudes> Testable prop => prop means is prop of Testable typeclass
05:40:09 <Rudes> would be like saying Integral prop => prop translates to "If prop is of type integral, keep going"
05:40:33 <{AS}> Rudes it was more why I couldn't give a Property on the left hand side
05:40:35 <{AS}> of ==>
05:41:03 <Rudes> you don't give anythying on the left hand side of ==>
05:41:20 <Rudes> you provide the right hand side and it returns the IO (), the left hand side isn't a param
05:41:21 <Saizan> Rudes: https://hackage.haskell.org/package/QuickCheck-2.9.1/docs/Test-QuickCheck.html#v:-61--61--62-
05:41:23 <Rudes> it's a requirement
05:41:54 <Saizan> Rudes: {AS} is not talking about the => that separates the typeclass constraints, it's talking about the operator (==>)
05:41:56 <Rudes> Saizan: oh, thanks
05:42:06 <{AS}> Saizan: Thanks!
05:42:21 <Rudes> sorry bout that
05:42:27 <Saizan> (nor Test.QuickCheck.quickCheck tbh)
05:43:01 <Rudes> Saizan: yeah i see that now
05:48:21 <Rudes> {AS}: so you can't write p ==> False?
05:48:31 * hackagebot cryptonite 0.15.1 - Cryptography Primitives sink  https://hackage.haskell.org/package/cryptonite-0.15.1 (LukeTaylor)
05:48:33 <{AS}> Rudes: Yeah, exactly
05:48:40 <Rudes> that is weird
05:48:44 <Rudes> i mean they don't handle for it in the code
05:48:50 <Rudes> https://hackage.haskell.org/package/QuickCheck-2.9.1/docs/src/Test-QuickCheck-Property.html#%3D%3D%3E
05:49:12 <Rudes> it only shows logic for Bool ==> p and _
05:49:17 <{AS}> Rudes: Yeah
05:49:39 <{AS}> I was wondering why not Property, but only Bool
05:49:44 <{AS}> if there was a theoretical/pratical reason
05:50:04 <Rudes> perhaps it's a representation of something in mathematics
05:53:48 <Rudes> {AS}: only thing i can think of is if you give it a prop first and it's gonna be False anyway that's more processing than is necessary
05:54:04 <{AS}> Rudes: I guess
05:54:05 <Rudes> {AS}: so they'r just keeping it from calculating more information than they have to, haskell is lazy after all.
06:03:54 <Gurkenglas> :t \f g -> contramap f . g . f -- Why does Getter a b have a Functor constraint?
06:03:56 <lambdabot> Contravariant f => (a -> b) -> (b -> f b) -> a -> f a
06:08:44 <mniip> :t (\f g -> contramap f . g . f) ?f Const
06:08:45 <lambdabot> (?f::a -> a1) => a -> Const a1 a
06:12:50 <mniip> Gurkenglas, does it?
06:12:53 <mniip> :t to
06:12:54 <lambdabot> (Profunctor p, Contravariant f) => (s -> a) -> Optic' p f s a
06:13:04 <mniip> :t (id .) . to
06:13:05 <lambdabot> (Profunctor p, Contravariant f) => (s -> a) -> p a (f a) -> p s (f s)
06:13:45 <Rudes> this lambdabot thing is pretty sweet, but also christ that's a long translation
06:14:24 <mniip> :t \f -> dimap (contramap f) f
06:14:25 <lambdabot> (Profunctor p, Contravariant f) => (c -> d) -> p (f c) c -> p (f d) d
06:14:39 <mniip> oops
06:14:43 <mniip> :t \f -> dimap f (contramap f)
06:14:44 <lambdabot> (Profunctor p, Contravariant f) => (a -> b) -> p b (f b) -> p a (f a)
06:15:02 * mniip . o O ( dimap <*> contramap )
06:15:04 <Rudes> lol this is so over my head right now..
06:16:31 <mniip> Gurkenglas, not sure where you're getting Functor from
06:17:39 <puregreen> maybe from https://github.com/ekmett/lens/commit/14c35e022591a88c5142a9c63dd99419070479f0
06:18:54 <puregreen> I think I've seen a bunch of commits in lens regarding functors+getters, but I never bothered investigating what for
06:19:11 <Gurkenglas> Actually this http://stackoverflow.com/questions/39068004/what-is-the-story-behind-a-getter ._.
06:19:14 <mniip> >moral Functor constraint
06:19:17 <mniip> >moral
06:20:56 <mniip> Gurkenglas, if you create a getter that is not 'dimap <*> contramap' you'd be violating the lens laws
06:21:12 <mniip> namely, l pure = pure
06:21:15 <Rudes> laws, morals... what is this language?
06:21:18 <mniip> no wait
06:22:03 <mniip> you'd violate something
06:26:04 <mniip> :t (\f g -> contramap f . g . f) ?f (Op . (==))
06:26:05 <lambdabot>     Not in scope: data constructor ‘Op’
06:26:05 <lambdabot>     Perhaps you meant one of these:
06:26:05 <lambdabot>       variable ‘ap’ (imported from Control.Monad.Writer),
06:26:54 <mniip> :t (\f g -> contramap f . g . f) ?f (Op . (==))
06:26:55 <lambdabot> (Eq b, ?f::a -> b) => a -> Op Bool a
06:27:16 <Rudes> how did you?
06:27:53 <mniip> right
06:28:02 <mauke> > Op ()
06:28:03 <lambdabot>      Couldn't match expected type ‘b -> a’ with actual type ‘()’
06:28:03 <lambdabot>      In the first argument of ‘Op’, namely ‘()’
06:28:03 <lambdabot>      In the expression: Op ()
06:28:12 <puregreen> mniip: teach me how to use implicit parameters with lambdabot, it looks useful
06:28:22 <mniip> Gurkenglas, there simply isn't any getter that isn't 'dimap <*> contramap'
06:28:28 <merijn> Any pointers for introductions to: 1) linear types and 2) rowtypes?
06:28:33 * hackagebot hpc-coveralls 1.0.6 - Coveralls.io support for Haskell.  https://hackage.haskell.org/package/hpc-coveralls-1.0.6 (killy971)
06:28:34 <Rudes> mniip is too powerful
06:29:54 <mniip> puregreen, um, instead of \x -> f x you write f ?x
06:30:10 <mniip> and it upgrades the dependency on x into the context
06:30:19 <puregreen> oh, that simple
06:30:22 <mniip> which makes it propagate upwards automatically
06:30:29 <puregreen> (I just never used implicit parameters so I've no idea)
06:30:42 <mniip> I've never used them outside of lambdabot
06:30:52 <merijn> I have, it was pretty neat :)
06:31:02 <puregreen> :t reverse ?x
06:31:03 <lambdabot> (?x::[a]) => [a]
06:31:13 <Rudes> :t ?x
06:31:14 <lambdabot> (?x::t) => t
06:31:23 <puregreen> :t reverse (reverse ?x) ++ ?y
06:31:24 <lambdabot> (?x::[a], ?y::[a]) => [a]
06:31:29 <Rudes> lol
06:32:01 <merijn> Lemme see if that code is online somewhere
06:32:13 <mauke> that reminds me, I've been meaning to implement implicit parameters manually
06:33:16 <Rudes> yeah i'm not understanding ?x, is it the lambda version of function :: (Show a) => a
06:33:27 <mniip> no
06:33:29 <lambdamu> merijn: regarding linear types have you read the slides "Wandering through linear types, capabilities, and regions"? as a first introduction I found them very helpful
06:33:45 <mniip> it's literally a thing with a type forall t. (?x :: t) => t
06:33:54 <merijn> lambdamu: I've not really read anything, just some talks I saw which just confused me a lot :p
06:34:20 <merijn> Here is some abuse of ImplicitParameters to deal with child/parent threads and killing them: https://github.com/merijn/GPU-benchmarks/blob/master/src/Process.hs
06:34:53 <merijn> I wanted to do things like running finalizers that(among other things) either kill all children, or wait for them to finish, or...
06:34:56 <mniip> you could probably implement it on your own with some hacks
06:35:06 <merijn> And wanting children to propagate exceptions from child to parent
06:35:15 <merijn> mniip: Yes, they're just a typeclass + fundep
06:35:22 <lambdamu> merijn: maybe you find them helpful then, I don't know if there was an accompanying talk, but they are very readable on their own
06:35:36 <mauke> merijn: isn't that what async does?
06:36:21 <mniip> @undefine
06:36:21 <lambdabot> Undefined.
06:36:34 <mniip> @let import GHC.TypeLits
06:36:36 <lambdabot>  Defined.
06:36:37 <mniip> @let class (s :: Symbol) ::: t | s -> t where param :: Proxy s -> t
06:36:38 <lambdabot>  Defined.
06:37:00 <mniip> :t reverse (param (Proxy :: Proxy "foo"))
06:37:00 <merijn> mauke: Not quite, because async deals with tasks that run and then finish
06:37:01 <lambdabot> ("foo" ::: [a]) => [a]
06:37:22 <merijn> mauke: I wanted something more like Erlang supervisors
06:37:54 <merijn> mauke: Async doesn't, for example, know how to kill all threads spawned from thread X if any child of thread X dies
06:38:21 <merijn> mauke: It mostly deals with async operations that, may produce an exception and propagating those back to the caller
06:38:33 <mniip> :t (first not (param (Proxy :: Proxy "foo")), second negate (param (Proxy :: Proxy "foo")))
06:38:35 <lambdabot> (Num b, "foo" ::: (Bool, b)) => ((Bool, b), (Bool, b))
06:38:40 <mniip> :t (first not (param (Proxy :: Proxy "foo")), second negate (param (Proxy :: Proxy "bar")))
06:38:41 <lambdabot> (Num b, "bar" ::: (d1, b), "foo" ::: (Bool, d)) => ((Bool, d), (d1, b))
06:40:47 <mniip> merijn, meanwhile have a look at this http://hackage.haskell.org/package/box-tuples-0.1.0.0/docs/Data-Tuple-Unboxed.html
06:41:29 <ongy> what's :::?
06:41:32 <merijn> mniip: What exactly am I supposed to look at/for? :)
06:41:43 <merijn> ongy: An operator constructor
06:41:48 <mniip> ongy, I just defined it above
06:42:16 <merijn> ongy: You are allowed to define infix constructors just like infix operators
06:42:59 <merijn> ongy: Since all constructors must start with an uppercase letter it was decided (arbitrarily) that ':' is *the* uppercase symbol character, so operator constructors must start with :
06:44:22 <ongy> That also works for type constructors?
06:45:10 <merijn> ongy: It used too, but, a couple years ago the restriction was lifted, so you can use arbitrary operators as constructor on the type level, iirc
06:45:24 <merijn> Not entirely sure, though, I'd have to look
06:45:46 <merijn> @define data a + b = Left a | Right b deriving Show
06:45:47 <lambdabot>  Defined.
06:45:52 <ongy> it's used as a type a few lines up, or do I read it incorectly?
06:45:52 <merijn> eh
06:46:16 <ongy> :t \x -> Left x
06:46:17 <lambdabot>     Ambiguous occurrence ‘Left’
06:46:18 <lambdabot>     It could refer to either ‘L.Left’,
06:46:18 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:160:16
06:46:29 <ongy> :t \x -> L.Left x
06:46:31 <lambdabot> a -> a L.+ b
06:46:34 <merijn> ongy: Yeah, I just bolloxed it up, but didn't wanna wipe mniip's work :)
06:46:45 <merijn> also
06:46:59 <merijn> :t L.Left -- is the same (module eta reduction)
06:47:00 <lambdabot> a -> a L.+ b
06:47:03 <merijn> *modulo
06:47:23 <merijn> ongy: You can also use ::: as a type constructor, if you wish
06:47:37 <ongy> now if only I knew what eta reduction is
06:47:54 <merijn> ongy: Literally that, removing a variable from a lambda binding :)
06:48:08 <merijn> "\x -> f x" -> "f" is eta reduction
06:48:09 <mniip> you remove all etas :P
06:48:22 <merijn> "f" to "\x -> f x" is eta expansion
06:49:24 <ongy> oh
06:50:11 <merijn> ongy: Since, if you dive into the theory, you can get into tricky questions like "are '\x -> f x' and 'f' the same?"
06:50:40 <mniip> interesting
06:50:54 <mniip> homemade unsafePerformIO apparently is unsafe enough to segfault :o
06:50:56 <maerwald> well in GHC they are definitely not the same
06:51:23 <ongy> maerwald: semantically or how they are emitted to code?
06:51:23 <merijn> ongy: Same for "are '\x -> x' and '\y -> y' the same?", by saying "modulo eta-reduction" you can say "let's handwave the comparison" and for the x/y example you could say "modulo alpha-equivalence" (i.e. renaming variables)
06:51:27 <phadej> and one hint in that deep dive is: is '5' and '\x -> 5 x'  the same?
06:51:30 <mniip> >case return "moo" of IO r -> box2s_ (r realWorld#) (\_ x -> x) 
06:51:30 <mniip> "Segmentation fault (core dumped)
06:51:32 <merijn> maerwald: For which definition of the same?
06:51:41 <merijn> mniip: Yes, unsafePerformIO lets you segfault :)
06:52:02 <merijn> maerwald: 'f' and '\x -> f x' are certainly denotationally equivalent
06:52:07 <Rudes> woah i didn't know segfault was even possible..
06:52:28 <ongy> :t \x -> 5 x
06:52:30 <lambdabot> Num (t -> r) => t -> r
06:52:33 <ongy> :t 5
06:52:34 <lambdabot> Num a => a
06:52:35 <merijn> Segfaulting is easy
06:52:46 <merijn> "poke nullPtr 'c'" <- there you go
06:52:56 <phadej> GHC is too smart, I meant (5 :: Int) e.g.
06:52:59 <Rudes> i've dont lots of C so i know how easy it is in C
06:53:00 <mniip> Rudes, oh it's easy if you go even as far even as decided to use even go want to do look more like
06:53:07 <merijn> Rudes: No, that was haskell
06:53:20 <merijn> Rudes: "poke :: Storable a => Ptr a -> a -> IO ()"
06:53:29 <Rudes> mniip: -.-
06:53:32 <merijn> Rudes: You can just call malloc/free using the FFI
06:53:39 <mniip> ew
06:53:40 <mniip> FFI
06:53:46 <Rudes> merijn: no i know, i just meant i'm used to segfaulting in C
06:54:29 <BMWPower> Hi I am new to Haskell
06:54:35 <BMWPower> just starting
06:54:37 <mniip> case writeInt8OffAddr# nullAddr# 0# 0# realWorld# of s -> ()
06:54:39 * ongy actually has a project that uses segfault as feature... I should fix that
06:54:42 <mniip> Rudes, ^
06:54:48 <merijn> ongy: Well, when you ask "semantically or how they are emitted to code" you are asking exactly the sorta question that makes people hedge by saying "modulo eta reduction" :)
06:55:05 <BMWPower> I want to combine RabbitMQ with Haskell and Sparql
06:55:32 <merijn> ongy: Incidentally, those two are not necessarily distinct. (semantics and which code is emitted) It depends on *which* semantics we are talking about
06:55:38 <mniip> merijn, anyway, this looks a bit like a bug in GHCi
06:55:52 <mniip> I wonder if I can isolate it into something sane
06:56:02 <ongy> merijn: "if we are diving into theory". But I get it
06:56:24 <merijn> ongy: The two most common ones being "denotational semantics" (what does a piece of text mean in an abstract mathematical sense) and "operational semantics" (what does it mean in terms of what *actually* runs on my CPU)
06:57:06 <Rudes> no one knows what happens on the actual CPU
06:57:11 <Rudes> that's wizard magic
06:57:34 <{AS}> Rudes: Of course you do, most CPUs today have verified VHDL/Verilog components
06:57:50 <Rudes> {AS}: ;)
06:58:02 <merijn> For example, the Haskell Report merely describes denotational semantics, which is why talking about thunks when saying how haskell runs is technically wrong. There's no guarantee a haskell implementation even uses thunks :)
06:58:04 <ongy> {AS}: let's pair that with microcode and we get intel :)
06:58:32 <{AS}> ongy:  :)
06:58:39 <maerwald> merijn: e.g. https://github.com/quchen/articles/blob/master/fbut.md#a-op-is-not-x---a-op-x
06:58:50 <deank> -disconnect
06:59:40 <merijn> maerwald: Last I checked that is technically a bug in GHC
06:59:47 <maerwald> well sure
06:59:56 <merijn> maerwald: Since the report (also last I checked) defines the semantics of sections to be equivalent to lambdas
07:00:04 <maerwald> yes, I said it's not the same in GHC
07:00:06 <merijn> Oh, it says below
07:00:23 <{AS}> So GHC is not eta-preserving
07:00:25 <{AS}> interesting 
07:00:42 <osa1> what do you mean by eta-preserving?
07:00:51 <merijn> maerwald: Well, the sameness depends on language (I wasn't specifically referring to haskell in my examples) and semantics under discussion (operational or denotational), which were unspecified :)
07:00:58 <{AS}> osa1: eta expansion changes the strictness
07:01:05 <merijn> osa1: Wrapping with a trivial lambda doesn't change strictness
07:01:30 <lambdamu> I think denotional semantics is a bit of a strong word for the Haskell Report
07:01:50 <merijn> To be fair, seq breaks basically every bit of semantics
07:01:57 <merijn> Because it's semantics is unspecified
07:01:58 <osa1> is it GHC or Haskell though
07:01:59 <maerwald> merijn: sameness depends on what one is talking about
07:02:20 <merijn> osa1: GHC
07:02:51 <merijn> osa1: The report explicitly states that the behaviour *should* expand like a lambda for sections
07:02:56 <merijn> osa1: Whereas GHC does not
07:03:18 <merijn> lambdamu: What would you call it, then?
07:03:44 <{AS}> why would (op ()) be forced?
07:03:58 <merijn> {AS}: Avoid adding an extra lambda + associated overhead
07:04:05 <{AS}> merijn: Ah, makes sense
07:04:18 <{AS}> so basically it is a non-semantics preserving optimization :)
07:04:58 <{AS}> where GHC translates op x y = ... to op = \x -> case x of ... -> \y -> ...
07:05:14 <{AS}> instead of op x y = \x y -> case x of ... 
07:06:02 <merijn> lambdamu: I found the slides you mentioned (incidentally, apparently I found them before, because google marks the link purple) but that doesn't really go into implementation, does it?
07:06:23 <mniip> aha!
07:06:32 <mniip> I crashed ghci without any use of IO :D
07:06:48 <ongy> mniip: did you use unsafeCoerce?
07:06:52 <mniip> no
07:06:59 <mniip> only semantically valid code
07:07:06 <ongy> cool
07:08:01 <mizu_no_oto_work> BWMPower: it looks like there's bindings for both RabbitMQ (https://hackage.haskell.org/package/freddy) and Sparql (https://hackage.haskell.org/package/hasparql-client) on hackage.  Looks like there's a lot more support for ZeroMQ, though, if you have a choice between mq's.  Did you have a specific question, though?
07:08:32 <mizu_no_oto_work> BMWPower, I mean, not BWMPower
07:11:37 <{AS}> so (False, xor) is a valid Monoid Bool instance?
07:12:10 <merijn> {AS}: Probably (as in, I'm too lazy to think about, but there's plenty of valid Bool monoids)
07:12:22 <{AS}> It seems that it is :)
07:12:47 <{AS}> merijn: Thanks anyway
07:13:57 <BMWPower> mizu: Yes questions enough. As I am programming for all my life in C/C++/Java/Python.etc I now want to learn a FP language. Started with Erlang, which seems to come close and easy 4 me.
07:15:17 <BMWPower> mizu: But the power of Haskell I also see. And I really love semantics and Graph stores. Performance and transactional wise I do not think RabbitMQ+Haskell can cope realtime transactional systems. What do you think?
07:15:50 <{AS}> There is an FP Humble Bundle now btw
07:16:02 <merijn> BMWPower: Soft realtime or hard realtime? Do you care about throughput, latency, or jitter, or a combination of them. etc.
07:16:11 <Rudes> {AS}: WHaaaaaat? link?
07:16:17 <{AS}> Rudes https://www.humblebundle.com/books/joy-of-coding-book-bundle
07:16:19 <mizu_no_oto_work> BMWPower: Why do you not thing it can cope with realtime transactional systems?
07:16:25 <mizu_no_oto_work> *think
07:16:38 <BMWPower> merijn: combination of them
07:16:46 <Rudes> {AS}: is this written by Bob Ross?
07:16:49 <merijn> mizu_no_oto_work: Haskell is not a particularly good candidate for (hard) realtime  with low latency restrictions
07:17:08 <mizu_no_oto_work> merijn: this is true
07:17:26 <merijn> Throughput focussed soft-realtime would be ok
07:17:32 <BMWPower> mizu: Graph (I have been using Jena) seem to be slower on realtime queries
07:17:33 <Rudes> merijn: what is Haskell a good candidate for?
07:17:46 <merijn> Most other things? :p
07:17:50 <Rudes> LOL
07:18:06 <lambdamu> merijn: I would probably say it's a technical standard, regarding the slides I never implemented linear types so I don't know how straightforward it is to translate the typing rules into implementations, they seem rather concrete though
07:18:22 <mizu_no_oto_work> merijn: you can however go with the Atom approach for writing hard realtime stuff in Haskell
07:18:25 <merijn> Rudes: But especially concurrent/throughput oriented programs (think web servers, etc.)
07:18:46 <merijn> mizu_no_oto_work: I don't know atom. Stuff like Clash would also let you do hard realtime using haskell :)
07:18:54 <Rudes> merijn: would you say it's better than something like Go for concurrent web servers?
07:18:57 <mizu_no_oto_work> i.e. Have your Haskell code generate C code with particular properties
07:18:57 <merijn> lambdamu: I'm reading now, so we'll see :)
07:19:14 <barrucadu> Haskell throughput is typically good, but the stop-the-world GC means sometimes you get bad latency :(
07:19:18 <merijn> Rudes: I'd expect you could get the same sort of performance, but with a nicer language :)
07:19:37 <merijn> Rudes: Note that haskell's green threads are cheaper/more lightweight than goroutines
07:19:51 <mizu_no_oto_work> BMWPower: Are you interested in soft realtime or hard realtime?
07:19:57 <Rudes> merijn: well that's opinion based. but i'd like to test that out. maybe i'll setup a copy of my go server and test it on some benchmarks
07:20:16 <maerwald> Rudes: haskell usually requires more up-front engineering than when using other languages, but check out https://github.com/facebook/Haxl for example
07:20:18 <merijn> Rudes: The fastest SDN (software defined networking) server was written in Haskell :)
07:20:24 <BMWPower> mizu: soft realtime (and embedded realtime hardware but not for now)
07:20:34 <merijn> Rudes: See this paper: https://www.semanticscholar.org/paper/Mio-a-high-performance-multicore-io-manager-for-Voellmy-Wang/0b92c2e3b28bb380bfe06202fe003d01c1b635f5/pdf
07:21:34 <maerwald> there's also a talk about haxl on youtube somewhere
07:21:37 <merijn> Rudes: I think Haskell might require a little more engineering at first (to get good performance you'll want to, depending on problem, use things like proper streaming IO libraries like pipes/conduit), but will be easier to maintain and modify
07:22:06 <Rudes> merijn: i can respect that
07:22:36 <merijn> Rudes: The paper is very interesting, it describes bottlenecks in the old GHC IO manager (the thing that manages blocking/unblocking green threads and file/socket IO) and how those bottlenecks were solved/reduced and magically made every threaded haskell program faster by updating your GHC version :p
07:23:02 <mizu_no_oto_work> BMWPower: one datapoint that you might find interesting is that Facebook's automated spam detection service that gets run on every single action every user does (liking, posting, getting posts, seeing likes, etc.) is run in Haskell.
07:23:38 <BMWPower> mizu: ;-)
07:24:02 <mizu_no_oto_work> Which may or may not be a comparable workload to what you're imagining
07:24:19 <BMWPower> mizu: A worked through my first book from Haskell and using Atom as IDE. But its not hitting me just yet ;-)
07:25:01 <mizu_no_oto_work> Have you worked through https://www.schoolofhaskell.com/school/starting-with-haskell/introduction-to-haskell ?
07:25:14 <merijn> BMWPower: I think it takes a fairly long time to get productive in Haskell, but I also think it's a good investment. There's problems I try to tackle using Haskell that I would never dream of attempting in other languages
07:25:32 <BMWPower> mizu: no I will do this! Thanks!
07:25:47 <barrucadu> Even if you don't end up using Haskell as your main language, it influences your code (for the better, I think) in other languages.
07:26:13 <BMWPower> merijn: Hmm time is always an issue ;-) In other languages I can always get the job done quickly .. only also maintainance ;-)
07:26:57 <barrucadu> I had a task at my current internship where to optimise something I rewrote it as I would in Haskell (immutable state), which then made it possible to reduce copying, and made some small benchmarks 30x faster.
07:27:29 <jonored> barrucadu: It can lead to some unfortunateness with templates in C++, though, especially if you're stuck too far back in C++...
07:27:34 <mizu_no_oto_work> The biggest issue with learning Haskell is that it's fundamentally a bit different from C/Java/Python/etc., so you need to relearn some of the fundamentals
07:27:36 <barrucadu> Without being forced by Haskell to use immutability, I'm not sure that would have occurred to me.
07:27:36 <merijn> BMWPower: I know, but I would say that when I finally became productive in Haskell I became a LOT more productive with it :)
07:27:40 <nitrix> I'll argue that it's not Haskell that really makes you a good programmer. Other languages have the option to be just like Haskell, but they don't. What's more special about it is that it puts you into a context where abstractions are favorable and encouraged.
07:27:49 <merijn> jonored: ;_; tell me about it
07:27:51 <int-index> Richard Eisenberg has finalyl published a PDF of his thesis (on Dependent Haskell). What a great read!
07:27:52 <barrucadu> jonored: "Fortunately", this was in Go ;)
07:27:52 <nitrix> Learning these abstractions can get you really far.
07:27:54 <int-index> https://github.com/goldfirere/thesis/raw/master/built/thesis.pdf
07:28:00 <merijn> jonored: My templates are horrific
07:28:01 <mizu_no_oto_work> But once you do that, a lot of higher-level experience transfers, both ways.
07:28:08 <bjs> barrucadu: well, any language will help with teaching you new approaches and problem solving techniques :)
07:28:22 <merijn> nitrix: Also, community that encourages learning
07:28:35 <BMWPower> barrucadu: I will go on. I am thinking of using Haskell as microservices Architecture (multicored). Reading queues from RabbitMQ...doing stuff with it in Haskell and give back respons.
07:28:44 <jonored> merijn: I seem to mostly have ended up with a lot of iterator adaptors because I want simple building blocks...
07:28:51 <barrucadu> bjs: Sure, but the common wisdom in most languages is, I think, that immutability is typically bad for performance because you need to do extra copying, but I had completely the opposite experience in this small case.
07:29:06 <jonored> ...unfortunately, that does mean template error messages. Lots of them. chained.
07:29:18 <merijn> jonored: pssh
07:29:42 <mizu_no_oto_work> BMWPower: as I mentioned, it looks like there's more library support for ZeroMQ on hackage, if that makes any difference.
07:29:55 <merijn> jonored: Witness this horror: https://github.com/merijn/GPU-benchmarks/blob/master/CUDA.hpp#L183-L201 :p
07:30:37 <jonored> ...also maybe an implementation of only-a-little-uglier do notation in C preprocessor?
07:30:45 <mizu_no_oto_work> BMWPower: you might find this interesting: https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
07:31:42 <{AS}> So I see that: https://github.com/quchen/articles/blob/master/fbut.md#a-op-is-not-x---a-op-x recommends Parsers over Regex libraries
07:32:05 <{AS}> I mean aren't regular expressions supposed to be more efficient (in cases where people actually use _regular_ expressions) :)
07:32:06 <BMWPower> mizu: I have made a solution with websockets to connect mobiles. Then going to AMQP (with Haskell). For this I used RabbitMQ...maybe ZeroMQ could do the same...
07:32:33 <merijn> {AS}: There's no reason why you couldn't implement the regex subset of parsers equally efficient as regular expressions
07:32:54 <{AS}> merijn: There is
07:32:56 <merijn> {AS}: I mean, regular expressions are just a DSL for describing a parser
07:33:00 <{AS}> You have to recognize the subset is a regular language
07:33:14 <{AS}> I think that it is a very very hard problem :P
07:33:40 <BMWPower> mizu: I will look at the link!
07:33:48 <merijn> {AS}: Why do you need to recognize that? Things like * and {} translate directly to other parser approaches
07:33:59 <jonored> merijn: But the algorithms that get you linear time don't.
07:34:16 <merijn> jonored: I'm not sure that's necessarily true
07:34:29 <quchen> {AS}: Regex is terrible coding practice. There are no names, the highest form of abstraction are back references, and so on.
07:34:29 <{AS}> merijn: I mean you can make your parser library have regex operations
07:34:45 <{AS}> but then it is a regex library ++ :P
07:34:52 <quchen> It’s like coding with de Bruijn indices only.
07:35:01 <{AS}> quchen: I agree, there are bad uses of regexes
07:35:11 <merijn> {AS}: Most parser combinator libraries are supersets of regex libraries
07:35:19 <Rudes> quchen: lol my co-workers name has De Bruijn in it.
07:35:23 <{AS}> but not all uses of regexes are bad (especially those that confine themselves to _regular expressions_)
07:35:27 <merijn> {AS}: So most of them already have regex operations :)
07:35:29 <{AS}> merijn: They are, but not as efficient
07:35:44 <merijn> Rudes: It's not a particularly uncommon name
07:35:51 <{AS}> and recognizing the efficient subset and optimizing towards that is usually not done
07:35:55 <merijn> Rudes: It's literally the Dutch version of "Brown"
07:35:59 <mauke> quchen: "There are no names, the highest form of abstraction are back references" <- that's never been true
07:36:02 <Rudes> merijn: oh
07:36:26 <Rudes> merijn: then are de Bruijn indices brown indices?
07:36:31 <merijn> mauke: Are we talking regexes or PCRE
07:36:31 <{AS}> I mean, if you target is to parse something then yes, regular expressions are not what you need
07:36:34 <Rudes> and if so what are brown indices? lol
07:36:38 <quchen> mauke: “in practice”, where “in practice” means “in my experience”. What a cop-out, I know :-þ
07:36:38 <mauke> merijn: regexes
07:36:58 <mizu_no_oto_work> Rudes: https://en.wikipedia.org/wiki/Nicolaas_Govert_de_Bruijn
07:37:02 <{AS}> but if you need them to recognize a simple pattern, then they are perfect
07:37:09 <Rudes> mizu_no_oto_work: thanks
07:37:12 <merijn> Rudes: They are named after a Dutch computer scientist Nicolaas Govert de Bruijn
07:37:16 <jonored> merijn: From what I recall, the transform from nondeterministic to deterministic doens't work on pushdown automata and above.
07:37:22 <quchen> https://en.wikipedia.org/wiki/De_Bruijn_index <--- those
07:37:40 <mauke> quchen: most languages embed regexes as strings, and most languages let you build bigger strings from smaller strings
07:37:51 <mizu_no_oto_work> merijn: Was he a computer scientist or a mathematician?
07:38:05 <merijn> Rudes: I just meant it's a surname that's about as common as the surname "Brown" is, so having a colleague with that name isn't particularly odd :)
07:38:07 <jonored> a /lot/ of practical parsers have a regular language layer to build tokens.
07:38:08 <quchen> mauke: But then you’re not talking about regexes anymore, you’re using the covering language as a convenient regex preprocessor.
07:38:12 <merijn> mizu_no_oto_work: Hard to tell :p
07:38:15 <Rudes> man, these IRC channels are great. i think i learned like 45 things in the past 4 hours
07:38:20 <merijn> mizu_no_oto_work: He did mostly type theory and lambda calculus
07:38:25 <mizu_no_oto_work> Ah
07:38:38 <merijn> Rudes: This is an exceptional channel compared to others :)
07:38:40 <mauke> quchen: does the difference matter?
07:38:44 <BMWPower> Hmmm ZeroMQ is something to look at!
07:39:06 <Rudes> merijn: Larry Wall did call it a language for geniuses by geniuses
07:39:37 <mniip> merijn, looksie it wasn't my unsafePerformIO that was at fault
07:39:45 <mniip> https://ghc.haskell.org/trac/ghc/ticket/12520
07:40:13 <{AS}> quchen: The biggest issue is that a lot of parser libraries have polynomial to exponential running time and are harder to write
07:40:25 <ongy> Rudes: I can use haskel somethwat resonably, so it's not only for geniuses
07:40:25 <Rudes> merijn: also we have a very small dutch pop in my area. so it's uncommon to me. haha
07:40:42 <Rudes> ongy: same here man, same here.
07:40:48 <merijn> mniip: I'm not familiar with Proxy#, so I'm not sure what it's supposed to do :)
07:40:49 <{AS}> Whereas regular expressions (when they are really regular) have a lot of nicer model theoretical properties
07:41:11 <jonored> ...Has anyone done a haskell regular language specific parsing DSL?
07:41:13 <ongy> {AS}: I will take harder to write (and sometimes slower) for better type-safety anytime. But I haven't looked to much into parser how much they provide that
07:41:18 <anelson-> hey guys, I'm writing hspec tests which use the filesystem and I want to use temporary directories. I thought maybe I could just use System.IO.Temp.withSystemTempDirectory, but turns out that running an IO action inside of an `it` is hard (impossible?). I thought maybe I could use a 'runIO' to create the temporary directory, but I'd only be able to create it during the "describe" portion; I don't know how to make it available to the
07:41:18 <anelson-> inner "it" actions. Can anyone give me advive
07:41:24 <anelson-> *advice?
07:41:28 <merijn> jonored: Not sure, but it should be pretty straightforward to make
07:41:29 <quchen> mauke: I think so, yes. If a language is so weak that it’s so hard to write in it that you shift your work to a more powerful language, it gradually becomes a compilation backend. And when something is just a backend, you’re not really writing it anymore, it becomes a technical detail. I would also say that ASM is a terrible language for writing a webservice, although many do use it behind the scenes.
07:41:55 <quchen> Regex on the other hand is used pervasively for doing all kinds of things, by many developers, by hand, right there in the code.
07:42:03 <ongy> hm, I think for regex usecases there schouldn't be much type to worry about
07:42:07 <mauke> to that I say "meh"
07:42:11 <{AS}> ongy: That doesn't make sense, if you want to have a scalable server architecture, you most likely do not want to use exponential time when you can use linear
07:42:40 <{AS}> type safety is important, but not everything (yes, I know, I am on the #haskell channel)
07:42:42 <jonored> I mean, mathematical regex is all of alternation, concatenation, and star, so...
07:42:54 <ongy> {AS}: grouping was bad in that sentence. Harder to write for more compiler support -> Always, slower -> sometimes (startup thingys)
07:43:13 <Rudes> ongy: so it returns a startup thingy?
07:43:30 <Rudes> ongy: and wouldn't it be [startup thingy]
07:43:36 <merijn> {AS}: Note that "type safety" without context is a meaningless term :)
07:43:56 <ongy> Rudes: That's not really valid haskell. I was trying to express that I would use slower code when it's config reading or similar that has to be done once on startup and not everywhere littered in the code
07:44:00 <Rudes> merijn: and note that Haskell is a Useless language apparently
07:44:04 <merijn> {AS}: Language are "type safe" with respect to a specific model. So what type safety means depends on your choice of model
07:44:09 <Rudes> ongy: i was just messing
07:44:10 <jonored> it's basically union, intersection, concatenation, and recursive concatenation on languages. That and some convenience bits and you've got your DSL up in haskell with names and such.
07:44:17 <puregreen> anelson-: I think just using liftIO inside “it” should work
07:44:21 <{AS}> merijn: I know :), I was answering ongy 
07:44:24 <merijn> {AS}: There are models for C that result in C being a type safe language :p
07:44:32 <{AS}> merijn: :P
07:45:08 <ongy> merijn: how do those deal with that one problem called "random access to memory"?
07:45:13 <lyxia> anelson-: it accepts any instance of Example, Expectation = Assertion = IO () is an instance.
07:45:22 <ongy> or do they degrade type-safety far enough that's just not a problem?
07:45:22 <{AS}> ongy: basically I would think they type the memory
07:45:39 <merijn> jonored: I would totally encourage someone (i.e., not me :D) to implement a Haskell regex library that used parser combinators instead of regex syntax. Bonus points for implementing a fromString instance that turns regex syntax into said parser type
07:46:01 <maerwald> ouch
07:46:10 <puregreen> ongy: I will take “easier to write” for type safety maybe 30% of times, which only shows that we have different priorities, different levels of risk-aversion, and probably are writing completely different things :P
07:46:25 <merijn> ongy: How is that a problem? You simply say that your memory is a linear address space and you can read/write to arbitrary parts
07:46:41 <merijn> ongy: Then every operation is type safe, since all they do is read/write bytes anyway
07:46:53 <jonored> merijn: Except, it wouldn't be normal parser combinators, it'd have to be restricted to the regex operators. It's practically identical, just without the quotes :p
07:47:08 <merijn> jonored: Yes, I mean a restricted set of parser combinators
07:47:09 <ongy> merijn: so it degrade the type system far enough
07:47:36 <ZYXoas> Peeps. :-)
07:47:37 <anelson-> lyxia: aw man, I don't know what I was thinking. That worked fine, thanks :)]
07:47:37 <ongy> puregreen: currently I'm working on a pulseaudio wrapper for haskell, since I couldn't find one. And getting system volume requires the full api, not pulse-simple
07:47:38 <merijn> ongy: That's not part of the type system, it's part of the execution model (i.e., what does running C mean?)
07:47:40 <{AS}> merijn: How do they handle illegal dereferencing? 
07:47:52 <merijn> {AS}: No such thing if everything is bytes :)
07:48:04 <{AS}> merijn: what is the semantics of *p 
07:48:05 <Rudes> ongy: that on github?
07:48:20 <ongy> Rudes: https://github.com/Ongy/pulseaudio
07:48:20 <{AS}> if p = -1
07:48:23 <ongy> but I'm not that far
07:48:23 <{AS}> where would they read?
07:48:23 <merijn> {AS}: p points to a part of memory, *p reads it
07:48:31 <merijn> {AS}: Pointers can't be negative
07:48:38 <{AS}> merijn: so the memory is modelled infinitely?
07:48:41 <ongy> well, I guess I have the most annoying part done, now it's mostly getting types and functions into it
07:48:48 <{AS}> err, it is an unbounded memory?
07:48:48 <merijn> {AS}: Yeah
07:48:59 <{AS}> merijn: Ah, I guess that makes sense
07:49:06 <{AS}> An unrealistic model of C
07:49:20 <Rudes> pls, C is unrealistic
07:49:26 <puregreen> merijn: so basically you want a quasiquoter/FromString instance for regex-applicative?
07:49:42 <merijn> {AS}: Not particularly useful if you care about it running in any useful manner
07:49:54 <merijn> {AS}: But certainly an execution model in which C is typesafe
07:49:58 <Rudes> ongy: i'm gonna have to dive into your code and learn from it, i'm sure there's lots to learn.
07:50:04 <ongy> can C pointers be negative? I though virtual memory takes care of expanding the memory space to everything pointers can address
07:50:05 <jonored> merijn: so... make operators for some or all of Text.Regex.TDFA.Pattern.Pattern's constructors :p
07:50:13 <mauke> ongy: no, because pointers aren't numbers
07:50:16 <merijn> puregreen: I don't want it, I think implementing it would be a good intermediate challenge :)
07:50:37 <puregreen> ah, okay
07:50:38 <ongy> Rudes: Not sure if that's such a good idea. There's quite ugly things in there, because pulse api is, I'll say questionable
07:50:54 <ongy> mauke: then calling them positive or negative doesn't make sense either way
07:50:55 <puregreen> I'll remember it for the time when someone asks me to give them a Haskell challenge
07:51:10 <merijn> puregreen: And that I'd recommend people wanting something like that to implement it, because it'd be very educational
07:51:18 <Rudes> ongy: can't disagree on pulse api, but sometimes learning what not to do is just as valuable, and maybe i'll find a better way and can submit a pull request.
07:51:47 <merijn> puregreen: My queue is already filled with far more unrealistic and ambitious dreams :p
07:52:09 <Rudes> merijn: can't call yourself a programmer if it isnt
07:52:38 <merijn> lambdamu: Incidentally (if you're still around) are you aware of any Rust papers on how their borrow checker, etc. is implemented?
07:53:10 <{AS}> https://wiki.haskell.org/Regular_expressions has a good discussion
07:53:20 <{AS}> merijn: above states that using parsec as a backend is very slow :)
07:53:40 <merijn> Sure, parsec is doing recursive descent parsing :)
07:53:49 <merijn> Which deals especially badly with backtracking
07:53:54 <Rudes> {AS}: slow is good, gives you time to go make a drink
07:54:06 <{AS}> merijn: Yeah, exactly
07:54:21 <{AS}> that is why you sometimes want to use a regex library instead of a parsing library ;)
07:54:28 <Rudes> https://xkcd.com/303/
07:54:43 <{AS}> You can see that regex-tdfa takes around 0.03s for their benchmark
07:56:21 <Adeon> hey, aside from LYAH, was there some new beginner resource for learning haskell
07:56:33 <Adeon> I have this faint memory that someone started working on something like that but can't quite remember
07:56:45 <merijn> haskellbook.com ?
07:56:46 <mauke> @where cis194
07:56:46 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
07:56:48 <Rudes> idk if it fits your needs but Derek Banas has a good video on the basics.
07:56:54 <phadej> haskellbook.com
07:56:58 <sm> there's somewhere between 10 and 50 ?:)
07:56:58 <Adeon> hmm yes I think this is what I was looking for
07:57:00 <Adeon> thanks :)
07:57:08 <mmaruseacph2> mightybyte also had some tutorial/book
07:57:25 <Rudes> and apparently it' son Humble Bundle now
07:57:43 <sm> http://www.happylearnhaskelltutorial.com
07:58:13 <merijn> mmaruseacph2: haskellbook.com is mightybyte's :)
07:58:35 <puregreen> isn't it bytemyapp's
07:58:37 <merijn> eh, wait, bitemyapp
07:58:42 <merijn> I confuse IRC names
07:58:45 <sm> https://www.schoolofhaskell.com, https://haskell-lang.org/documentation
07:58:48 <merijn> It had byte in it!
07:59:02 <phadej> :)
07:59:05 <mmaruseacph2> hmm, could be that I wanted to say bitemyapp instead of mightybite
07:59:08 <Rudes> close enough
07:59:17 <mmaruseacph2> actually, I think both have, let me check HCAR
08:00:05 <dfeuer> mniip, did you figure out that indexed MonadFix thing yet?
08:00:40 <mmaruseacph2> nop, only bitemyapp
08:01:37 <merijn> If anyone has any good pointers on row typing, I'd be glad to hear 'em :)
08:01:38 <mniip> yes
08:01:42 <lambdamu> merijn: I can't recommend anything specifically and I fear the rust community isn't as much into paper writing, but I would assume they are not using fundamentally new techniques
08:01:45 <mniip> but I'm currently on mobile
08:02:04 <lambdamu> merijn: their achievement is probably more to form a coherent language out of those ideas that people actually want to use
08:02:38 <lambdamu> merijn: they were kind enough to point out a few relevant papers in their documentation, though
08:02:41 <lambdamu> merijn: https://forge.rust-lang.org/bibliography.html
08:03:13 <merijn> lambdamu: Ah, that's helpful too :)
08:03:34 <Rudes> rust is a cool language, that being said theres not many languages i don't think are neat
08:03:36 * hackagebot mollie-api-haskell 0.1.0.1 - Mollie API client for Haskell http://www.mollie.com  https://hackage.haskell.org/package/mollie-api-haskell-0.1.0.1 (matsrietdijk)
08:04:41 <merijn> lambdamu: Hence my curiosity, I want something that's kinda like Haskell and kinda like Rust and kinda like Ur and... :p
08:05:44 <lambdamu> merijn: Haha, I guess everyone has some image of his ideal language, that we hope to write some day
08:05:58 <lambdamu> I certainly have mine
08:06:28 <int-index> I first need a language to implement my ideal language in
08:06:36 <int-index> so, gotta improve Haskell :)
08:06:38 <merijn> int-index: I already have that, it's haskell
08:06:50 <merijn> int-index: See, I need this language because I need a good language to write my OS in
08:07:13 <lambdamu> Gotta start somewhere, iteration is key
08:07:30 <merijn> If Rich Hickey can implement a major language why can't I! :D
08:10:34 <bjs> merijn: not still trying to write the perfect language are you?
08:11:01 <magneticduck> merijn: didn't you hear? somebody just implemented a perfect language
08:11:05 <merijn> bjs: I haven't been trying to write the perfect language at all. I've been trying to design it :p
08:11:16 <bjs> same thing :)
08:11:33 <lambdamu> don't try to force that thunk :D
08:11:38 <merijn> Not quite, often implementing is harder than defining :p
08:11:39 <magneticduck> anyway now we just have to write an OS in it and software will be a utopia
08:12:01 <merijn> magneticduck: :)
08:12:20 <ongy> magneticduck: I don't think IO will ever be nice to deal with (not the file IO stuff, gpio and such)
08:12:27 <Jenaf> hm... this night I left a simple sieve of erathostenes runing on the first 2 Million integers; it too severl hours to run
08:12:54 <Jenaf> today i wrote a little faster sieve and it took about a minute to sieve the first 20m integers
08:12:56 <Jenaf> ^.^
08:13:09 <magneticduck> what a metaphor
08:13:12 <ongy> is there a reason why the wrapper/dynamic functions here https://hackage.haskell.org/package/base-4.9.0.0/docs/Foreign-Ptr.html#t:FunPtr are more restrictive than normal foreign import?
08:13:26 <Jenaf> (still not running in O(n log log n), I guess I'm at O(n sqrt n) or so
08:13:37 * hackagebot rest-gen 0.20.0.0 - Documentation and client generation from rest definition.  https://hackage.haskell.org/package/rest-gen-0.20.0.0 (AdamBergmark)
08:13:51 <merijn> ongy: In what way is that more restricted?
08:13:53 <ZYXoas> Hi, peeps.
08:14:17 <ZYXoas> Is Esqueleto dead? Doesn't work with GHC8 or the latest Persistent.
08:14:26 <ongy> merijn: the wrapper/dynamic functions only accept the "marshallable" types, FFI imports can use Storable type class
08:14:29 <magneticduck> ongy: in the perfect OS, instead of 'everything is a file' we have 'everything is a proof'
08:14:31 <merijn> ZYXoas: Has GHC8 even been released yet?
08:14:35 <ZYXoas> At least, the latest version on Hackage is broken.
08:14:37 <merijn> ongy: So do foreign imported functions
08:14:47 <ZYXoas> GHC8 was released 2 months ago, or something. Yes.
08:14:58 <ZYXoas> Yes, merjin .
08:15:15 <ongy> merijn: -.- would if I could. Not that it's that much of a problem, I can easily write the wrapper myself. I was just wondering
08:15:35 <lambdamu> the only meaningful thing to say about everything is that it is something
08:15:35 <cocreature> 3 months ago iirc
08:15:39 <cocreature> end of may
08:15:47 <merijn> ongy: No, I meant, it has the same restrictions as foreign imports afaict?
08:16:03 <merijn> ongy: Like, what exactly can't you do with wrapper than you CAN do with foreign imports according to you?
08:16:04 <ZYXoas> It was released 21 May, merijn: https://www.haskell.org/ghc/
08:16:23 <dfeuer> ZYXoas, it's new enough that not everything has caught up. The github master was updated in March, which isn't terribly long ago, so the project's likely alive but sluggish.
08:16:48 <merijn> ZYXoas: Anyway, I would generally not recommend using the latest GHC
08:16:53 <ZYXoas> The beta was avalilable from GHC head for something like half a year.
08:17:14 <glguy> ongy: You might look at section 8.4.2 "Foreign Types" to see what types are valid in the FFI
08:17:24 <merijn> ZYXoas: I generally only switch to a new GHC after it has been out for like 6+ months, unless I have a concrete reason to switch earlier (needing a specific feature)
08:17:31 <glguy> ongy: Storable doesn't feature
08:17:36 <dfeuer> ZYXoas, yes, and not all package maintainers remember to add GHC HEAD to their CI, if they even have CI.
08:17:41 <ZYXoas> Any package developers with proper Continuous Integration (Travis CI) would have upgraded to GHC8 months before it was released, merijn
08:17:57 <dfeuer> merijn, GHC 8 has some pretty whiz-bang stuff!
08:18:03 <ongy> I thought I did it with storable and not doing explicit 'with', but trying to write up the example I fail
08:18:08 <ongy> hm, maybe my memory is wrong
08:18:34 <merijn> dfeuer: I haven't been doing much Haskell :(
08:18:38 <glguy> ongy: You can certainly export pointers to storable (or non-storable) things
08:18:38 <dfeuer> ZYXoas, not everyone configures Travis. Not every project can use it effectively. Etc.
08:18:39 <merijn> dfeuer: Mostly C++
08:18:39 <ZYXoas> So....
08:18:56 <geekosaur> yay linux mindset. "no commits in the past 5 minutes it's a dead package" always run the buggiest version you can find
08:19:07 <ZYXoas> I'm pretty sure every project can use Travis effectively, dfeuer
08:19:14 <merijn> ongy: You don't use Storable values directly, you use "Storable a => Ptr a"
08:19:21 <dfeuer> merijn, oh dear. I'm sorry. Maybe next year you'll get to work with a modern programming language like FORTRAN?
08:19:37 <merijn> dfeuer: At least it's C++14 and I have lambdas :)
08:19:45 <ongy> merijn: yes, I must have mixed a few things up
08:20:12 <geekosaur> they don;t run the absolute latest of everything, they obviously don't know what they are doing. stability is the most heinous thing imaginable. use nosql databases that aren't capable of reliable operation, etc. etc.
08:20:38 <NaOH> Hi! I have a simple question: I wrote some code related to 2d-geometry. So I use a definition for a "Point" as "type Point = (Coord, Coord)" where "type Coord = Float". Now I realize that if I want to distribute this as a library, it makes no sense to hardcode Coord to Float, as the library user might want to use Double for instance. Is the only solution to redefine Point as "type Point a = (a, a)" and restrict all my functions so th
08:20:45 <merijn> ZYXoas: Maybe you would, I have a life besides my job and investing hours to fix bugs with a compiler that isn't widely adopted yet isn't the best use of my time :)
08:20:45 <cocreature> geekosaur: but it’s webscale!
08:20:53 <glguy> geekosaur: Which rant is this?
08:21:35 <merijn> glguy: "Why does everyone insist on running bleeding edge?!?!" rant :)
08:21:47 <ongy> NaOH: you would have it as type Point a = (a, a) and restrict your functions to what you need
08:21:53 <merijn> ZYXoas: Anyway, unless you can name a specific reason to use GHC8 I would just use 7.8
08:22:29 <ongy> NaOH: have a look at the Fractional type class for that
08:22:36 <dfeuer> Is there some way to get Atkey-style and McBride-style indexed functors and monads to play reasonably nicely with each other without forcing users to muck around with the at-key GADT or construct and deconstruct horrifying type pairs?
08:22:37 <ZYXoas> merijn You only need 2 or 3 hours. In the past half a year, that's how much time I have spent investigating issues caused by GHC8 on my library -- mostly third party libraries failing to build or causing slightly incompatible changes.
08:22:39 <mauke> ZYXoas: why would I install a non-released ghc?
08:22:45 <merijn> NaOH: Yes, if you wanna generalise away from float you have to constraint the individual functions using Fractional or something
08:22:47 <NaOH> ongy: that's what I feared, I guess I'll get down to refactoring. thanks!
08:23:01 <ZYXoas> mauke GHC8 was released officially on May 21 of this year.
08:23:14 <puregreen> geekosaur: you're forgetting about Linux reality: your wifi driver and latest kernel are incompatible and every year or so you try installing new version of the kernel, check that wifi still doesn't work, sigh and go back to your old kernel
08:23:16 <NaOH> merijn: thanks, I was hoping not to have to refactor all my functions hehe
08:23:17 <merijn> ZYXoas: You haven't answered my question. Why not use GHC 7.8?
08:23:39 <mauke> <ZYXoas> The beta was avalilable from GHC head for something like half a year.
08:23:41 <ZYXoas> Because it's two years old, merijn
08:23:50 <merijn> ZYXoas: So?
08:23:54 <merijn> ZYXoas: Does it magically not work?
08:24:06 <dfeuer> puregreen, that tends to be a problem with closed-source drivers whose manufacturers have abandoned them. It's not a Linux problem.
08:24:06 <ZYXoas> Yes, mauke. And the final version released May 21.
08:24:17 <merijn> Oh well, I guess I meant 7.10
08:24:25 <mauke> ZYXoas: yes, so why mention the beta if you don't expect people to install it?
08:24:31 <puregreen> dfeuer: I said nowhere it was a Linux problem :)
08:24:38 <merijn> Although, tbh, I don't see a reason why not to use 7.8 either >.>
08:25:05 <glguy> Maybe because it's a hassle on recent OS X versions
08:25:20 <cocreature> merijn: the main reason is that pure is not in the prelude :)
08:25:40 <merijn> glguy: Did I miss something? I use OSX and used 7.8 for a bunch of time too and I don't remember noticing anything?
08:25:46 <ZYXoas> mauke using the beta is the job of library developers, and can be done very easily with Travis. You, as an end user of GHC, not a library maintainer, do not need to download GHC8 nbefore it is released. But GHC8 was released 3 months ago, so I do not see the point of this line of questioning.
08:25:47 <dfeuer> And Data.Functor.Identity is not in base, but I guess that only causes headaches for people like me.
08:26:01 <cocreature> 90% of the times where I break travis builds, it’s 7.8 builds because I used pure
08:26:08 <merijn> ZYXoas: How are library developers not end users?
08:26:08 <mauke> ZYXoas: I'm a library maintainer
08:26:24 <ongy> ZYXoas: "job of library developer", not really. Unless it's a core library, I don't think there's any reason to be ahead of releases
08:26:37 <glguy> merijn: When they came out with the new secure system directory stuff (has a catchy short name I can't remember) the version of unix that came with GHC wasn't compatible with the new error message you'd get checking files in the system directories
08:26:39 <merijn> ZYXoas: Anyway, this discussion is pointless. Use GHC 7.10 or wait several months for things to be fixed
08:26:59 <merijn> ZYXoas: Those are your two options
08:27:07 <ZYXoas> It works just fine. The question was not whether I should be using it, merijn. It was whether or not the maintainer of Esqueleto is okay with the version on Hackage -- which was released at the very beginning of the year -- being incompatible with the current PErsistent landscape.
08:27:09 <koomi> ZYXoas: esqueleto is certainly not dead, you could open an issue or fix it yourself and make a pull request
08:27:26 <maerwald> ZYXoas: ecosystem policies and workflow is not as ironed out in the haskell community as in others
08:27:37 <dfeuer> In ZYXoas's defense, I have been keeping GHC HEAD running in containers CI for quite some time, and I've had at most one (minor) issue that affected GHC 8 or its runners-up.
08:27:37 <ZYXoas> PRs exist, koomi. Dev involvement in merging them has been minimal.
08:27:53 <maerwald> ZYXoas: and there are a lot of semi-dead libraries
08:28:30 <ZYXoas> maerwald: if my stuff stops working with the latest releases, I make sure it works again. That's a pretty simple policy/workflow, methinks.
08:28:32 <merijn> dfeuer: I always get annoyed by people insisting library authors "should" do whatever, despite being completely unpaid
08:28:55 <mauke> especially the "it's your job!" kind
08:29:13 <merijn> People should contribute however much time they feel comfortable contributing. Any entitled people can go suck it when making demands
08:29:14 <ZYXoas> dfeuer: I had the same experience. And I am an unpaid library maintaner, merijn.
08:29:27 <maerwald> ZYXoas: except in haskell it's not just the new GHC version but potentially 20+ other libraries/APis too that need updating...
08:29:36 <merijn> ZYXoas: Good for you, you have lots of spare time to do unpaid work. Others don't
08:29:44 <lambdamu> If you are blocked by upstream you workflow is broken
08:29:49 <shapr> It's my opinion that sending money to library maintainers is always a good plan
08:29:56 <merijn> shapr++
08:29:56 <dfeuer> shapr++
08:30:00 <ongy> shapr++
08:30:30 <glguy> shapr: There you go, your next three sources of money
08:30:32 <puregreen> I'd argue that if you make a popular library, upload it on Hackage, and don't tell people “I won't maintain it”, then the social contract of having to maintain it applies to you (because it was *entirely predictable* that people would expect things from you and you did nothing to persuade them otherwise)
08:30:32 <maerwald> oh the money argument again
08:30:32 <ongy> PRs also help quite often. and if those don't help, forks are an option :)
08:30:46 <puregreen> and “should” applies to social contracts
08:30:46 <ongy> shapr: which libraries do you maintain?
08:30:53 <dfeuer> ZYXoas, OTOH, it can be much harder for "far downstream" libraries. They have to wait for everything upstream to catch up before they can even get a working build plan.
08:31:06 <merijn> puregreen: Why is that a precondition for uploading to Hackage?
08:31:10 <shapr> ongy: nothing at the moment, but I do send money to library maintainers :-)
08:31:36 <ongy> puregreen: most licenses have the nice "this is released as is", so...
08:31:39 <mauke> I'm not sure that a bit of money would convince me to work more on haskell libraries
08:31:41 <dfeuer> shapr, how can I get on your gift list? :-)
08:31:42 <lambdamu> It is not hard to check out the repo locally the pr on it, add it to stack.yaml and call it a day
08:31:45 <merijn> puregreen: I've uploaded stuff I wrote for myself (and will update whenever I have to), simply because "well, this seems like something others might find usefull, no point keeping it secret on my harddrive"
08:31:49 <shapr> I'd like to dump money on hackage and have it sent to authors by popularity by default, or choose to send it to a particular library.
08:32:00 <shapr> Sort of like humble haskell bundle :-)
08:32:07 <mauke> haskell's package system is too awful to deal with
08:32:15 <shapr> mauke: fix it?
08:32:21 <shapr> dfeuer: what libraries do you maintain?
08:32:23 <tdammers> haskell has a package system? :x
08:32:27 <mauke> yeah, I've thought about uploading to CPAN instead
08:32:38 <ZYXoas> Me complaining about this is a form of contribution. PRs, issue requests, gentle nudging, or outright changing code and pushing (if you have write access). Sometimes the only tool you have is exhasperation. At least it reminds library authors that the larger community appreciates their work and has a vested interest in it not disappearing due to ne
08:32:39 <ZYXoas> glect.
08:32:45 <mauke> but that would require a lot of work to make it work :-)
08:32:46 <shapr> mauke: do it! if you find a better way, it's all good!
08:33:01 <ongy> shapr: do you need a netlink library? I need money :)
08:33:15 <merijn> mauke: I swear, you'll be immortalised if you make packaging not suck :p
08:33:29 <dfeuer> shapr, at the moment, I co-maintain containers. I also nominally maintain boxes, but I'm not doing anything with it at the moment.
08:33:35 <shapr> ZYXoas: I've certainly grabbed dead libraries and cleaned them up
08:33:40 <mauke> merijn: hah, I don't know whether it will even suck less :-)
08:33:42 <tdammers> ZYXoas: there's a difference between "what a terrible shame that feature X doesn't work, it'd be a great library otherwise", and "feature X doesn't work, that is unacceptable, I demand you fix it"
08:33:44 <shapr> ongy: what I really need is a SIP parser in Haskell
08:34:01 <ZYXoas> But I shall see about downgrading GHC, merijn. Hopefiully none of the libraries I use will complain when I change the Stackage version...
08:34:22 * jonored does think that an appropriate response is "send me a pull request and I'll load it up or pass it off, I don't actually have time for more", and that that would fall under his expectation of the social contract.
08:34:24 <shapr> I'd totally dump a small amount of money on somebody to write the skeleton of such a thing. By small amount I mean a k or so
08:34:27 <ongy> shapr: I have no idea what that is :)
08:34:42 <dfeuer> shapr, I'm also in the process of putting together a more-pleasant-to-my-tastes set of packages for dealing with indexed functors/applicatives/monads (also offering foldables and traversables unlike the others), type-aligned lists, and reflection-without-remorse-style free monads.
08:34:43 <shapr> ongy: https://en.wikipedia.org/wiki/Session_Initiation_Protocol
08:34:46 <ZYXoas> I didn't demand, tdmmers. But I was perturbed by the default response of "then downgrade!"
08:34:55 <ZYXoas> tdammers
08:35:00 <shapr> I really want most of a VoIP stack in Haskell (sip, sdp, rtp, etc)
08:35:00 <ongy> ZYXoas: talking about supporting landscapes: you may want to support down to 7.6 since that's current debian stable. The game can be played both ways
08:35:20 <shapr> dfeuer: that's awesome!
08:35:24 <merijn> ZYXoas: Well, it's more that the majority don't stay on the bleeding edge, because there is no reason to EXCEPT when you need a new feature
08:35:41 <merijn> ZYXoas: So it's not so much "downgrade!" as "why did you already upgrade?"
08:35:44 <puregreen> merijn: sure, Hackage is a dump of people's code and people don't tend to expect things from code that's *merely* on Hackage. However, code that is “merely” on Hackage doesn't tend to become popular either.
08:35:48 <mauke> also, every ghc release breaks everything
08:35:58 <dfeuer> ZYXoas, you don't need to downgrade stack to use an earlier GHC. Just change your stack.yaml or whatever.
08:36:07 <ongy> merijn: there's environments that are on 8.0 already (ok, arch isn't known for stability anyways)
08:36:30 <merijn> ZYXoas: My beginner advice is always "use GHC version (latest -1)", maximum support, no weird new bugs/regressions, etc.
08:36:43 <shapr> I doubt I have enough money to pay for an entire VoIP stack in Haskell, but I'd certainly like to pay for the seed of one so I could work on it in my spare time.
08:36:46 <ZYXoas> GHC breaking everything can be ameliorated by aggressive use of CI, mauke.
08:36:54 <ongy> shapr: maybe if I'm bored and out of things to do. So in ~5years :)
08:36:58 <mauke> puregreen: counterexample: Data.Default
08:36:59 <shapr> ongy: aw
08:37:02 <mauke> ZYXoas: what's CI?
08:37:33 <ongy> ZYXoas: on whose side?
08:37:38 <dfeuer> ZYXoas, unless you have a lot of stuff upstream that's someone else's responsibility and you don't want to try to maintain shadows of dozens of other packages.
08:37:50 <ZYXoas> Yes, I will look into changing my stack.yml, dfeuer. The hope is that I am not using new library features from new major versions.
08:37:56 <tdammers> ZYXoas: downgrading is often the sane choice
08:38:32 <kresbak> ahh it's a wonderful day
08:39:04 <ongy> kresbak: can't complain either :)
08:39:33 <puregreen> mauke: and in case of Data.Default I would consider it totally fine if the author says “what the actual heck are you doing, people, trying to turn my thing into a Solution To Named Arguments or something” and refuses to maintain it
08:39:50 <ZYXoas> mauke: Continuous Integration. Travis CI is the default choice on Github. Ensures that your library builds and tests pass, at a minimum, otherwise you can use it with multiple GHC versions, including HEAD and beta versions, and various Stackage releases, etc: https://github.com/hvr/multi-ghc-travis
08:40:26 <mauke> ZYXoas: and that will fix my installed code for me?
08:40:41 <cocreature> the cloud fixes everything, don’t you know that?
08:40:42 <maerwald> jesus
08:41:01 <lambdamu> ZYXoas: if it is only esqueleto, there appears to be a pull request that fixes compatibility with ghc8, why not check it out and link to it locally from your stack.yaml?
08:41:15 <ZYXoas> No, it will not fix your code. It will tell you when shit gets broken by other libraries or GHC features.
08:41:27 <monochrom> I think you have the wrong expectation on GHC backward compatibility.
08:41:33 <ZYXoas> Or if any 3rd party clients stop working as expected.
08:41:37 <mauke> I already know when things break
08:41:38 <mauke> because then they no longer work
08:42:07 <mauke> also, travis only rebuilds when I commit a change
08:42:12 <Rudes> are there any good haskell vim linters that check like type safety and missing patterns for example
08:42:18 <ZYXoas> That's what Ruby programmers also say, mauke. But that SPJ for strict, strong typing.
08:42:35 <merijn> Rudes: I use hdevtools and that can warn about anything GHC can warn about
08:42:39 <glguy> Rudes: Type safety is checked by the compiler
08:42:43 <monochrom> The GHC team announced explicitly they will move fast and certain versions will sacrifice backward compatibility. It is the job of Haskell Platform to pick conservative GHC versions.
08:42:49 <Rudes> merijn: excellent
08:43:04 <cocreature> Rudes: intero also does that
08:43:24 <shapr> yeah, intero is amazingly cool
08:43:36 <merijn> Rudes: It's a bit of a pain, in that it links to a specific GHC version, which can sometimes result in issues. Last I checked people were working on ghcid to add similar features to ghci
08:43:38 * hackagebot twitter-feed 0.2.0.9 - Client for fetching Twitter timeline via Oauth  https://hackage.haskell.org/package/twitter-feed-0.2.0.9 (jpvillaisaza)
08:43:47 <monochrom> If you think the GHC team does not know CI, you greatly underestimate them.
08:43:56 <mauke> monochrom: it's not just backwards compatibility, it's also having to recompile the world
08:43:57 <ZYXoas> CI is strong, static typing for your libraries. If you claim to support GHC 6 to 8, and you claim to build on with all versions of network, etc, wouldn't it be nice if all of these claims are checked every time you push to your repository?
08:44:08 <merijn> shapr, cocreature: But intero is emacs, no?
08:44:14 <shapr> nah, it's for both
08:44:24 <cocreature> merijn: I think there is an atom integration and a neovim integration, but emacs is definitely the focus
08:44:25 <mauke> ZYXoas: no, "every time you push" is the wrong trigger
08:44:26 <Rudes> merijn: ghci doesn't already do that? i thought it did, or at least seems to
08:44:33 <shapr> merijn: https://github.com/parsonsmatt/intero-neovim ?
08:44:52 <cocreature> Rudes: ghcid is basically a wrapper around ghci that passes the right options to make it fast and tracks file changes to autoreload
08:44:54 <merijn> shapr, cocreature: I'm a luddite who doesn't use Neovim, though
08:45:08 <cocreature> merijn: well that’s your problem :)
08:45:16 <shapr> merijn: I use emacs, so I only know that I've heard intero works fine with vim
08:45:26 <merijn> cocreature: It isn't time for my annual "redo setup of my environment" yet
08:45:31 <ZYXoas> Here is the CI status page for the Hackage TLS library: https://travis-ci.org/vincenthz/hs-tls How would the programmer have been to verify that TLS works on all versions of GHc from 7.0 and up? Or, if they used Stackage, how coul;d they keep track of Stackage releases? Etc?
08:45:31 <monochrom> who claims to support GHC 6 to 8? a strawman?
08:46:04 <cocreature> merijn: I think you meant your annual “wtf, which upgrade broke everything this time?”
08:46:12 <Rudes> merijn: weird, vundle is making me give it a username/pass for vim-hdevtools
08:46:31 <ZYXoas> IF you can do that. I'm happy/. But just like juggling types in your head when using a languuages without types, some of us don't want to spend time checking that our scode builds under every environment every time we make a change.
08:46:34 <merijn> cocreature: No, every year or so I reserve half a week to a week, to fix longstanding annoyances in my commandline setup
08:46:38 <Rudes> oh no, that's myfault
08:46:40 <Rudes> i'm an idiot
08:47:00 <Gurkenglas> When msys2 runs ghci, pressing up moves me off the prompt line and the line I was writing gets like corrupted with \ESC characters. Can that be fixed?
08:47:07 <merijn> cocreature: Small things that take too long to fix at the time, but whose solution makes me feel better long term :p
08:47:19 <mauke> ZYXoas: ghc changes more often than I make changes to my code. this would have done nothing to help me with ghc 8, for example
08:47:36 <merijn> shapr, cocreature: I've considered switching to emacs + evil, but the upfront setup cost of replacing my setup has been too high so far
08:47:52 <Rudes> merijn: does hdevtools bind to save so it tells me when i mess up or
08:47:54 <monochrom> OK I see it now. This is a new variant of that Aesop tale.
08:47:56 <cocreature> well as an emacs user I don’t recommand switching to emacs :)
08:48:06 <merijn> Rudes: Yes, if you combine it with Syntastic
08:48:29 <merijn> cocreature, shapr: I'm hoping Neovim catches up with emacs features before I get around to it, so I won't have to bother :p
08:48:57 <Gurkenglas> Like so https://gyazo.com/720782c64ec82a406220a5acb99f5b6b
08:49:21 <monochrom> A group of mice is being cracked down by a cat real hard. They convene to discuss countermeasures. One mouse says, if we could tie a bell on the cat's neck, we'll get very good early warning. But frankly I don't have time to do it. Also click on these URLs on the benefits of early warnings.
08:49:24 <printline> how can I call Data.List.(\\) without importing it?
08:49:42 <puregreen> mauke: when your code doesn't build with GHC 8, hvr creates an issue at your issue tracker. So that's a solved problem /s
08:49:55 <puregreen> printline: foo Data.List.\\ bar
08:50:01 <Rudes> puregreen: no way
08:50:03 <puregreen> hm, isn't it //
08:50:10 <puregreen> :t (\\)
08:50:11 <lambdabot> Eq a => [a] -> [a] -> [a]
08:50:13 <puregreen> okay
08:50:51 <printline> thank you
08:50:57 <Gurkenglas> (Also this https://gyazo.com/51ebcb7ac34ed6ea537756e03d82ec9c )
08:51:16 <mauke> puregreen: I think something like cpantesters would be nice for hackage
08:51:17 <merijn> lambdamu: One more question ;) I'm looking at the typing judgement on slide 43, but I'm not familiar with it's use of the reverse turnstile?
08:54:04 <merijn> Or, for that matter, anyone else familiar with linear types that would like to enlighten me :)
08:54:04 <puregreen> mauke: what exactly does it do? (also, we have matrix.hackage.haskell.org which builds all packages with all versions of GHC – is it something similar or not?)
08:55:29 <mauke> puregreen: basically it collects test results of CPAN modules, and there are a few people that test all uploaded modules (on several versions of perl)
08:56:28 <ongy> something that could also be nice, is subscribe CI to upstream changes. Not that it's really feasable
08:56:36 <puregreen> what does “test results” mean? Is it “people test functions manually”, or is every library on CPAN expected to have a test suite?
08:57:25 <mauke> puregreen: the latter
08:58:21 <mauke> I mean, why would you upload a distribution to CPAN without tests? it's so easy to just write a few
08:59:04 * ongy has no idea how to write tests for most stuff he works on
08:59:35 <mauke> (it's easy in perl)
08:59:51 <merijn> Easiness of writing tests depends a lot on what you do :)
09:00:22 <mauke> it also depends on the available tools
09:00:23 <ongy> digging around in /proc/ and /sys/, doing netlink and currently pulse wrapper. So really easy to test things
09:00:33 <merijn> ongy: :)
09:03:08 <merijn> Cale: ping?
09:03:15 <{AS}> merijn: can you point me to the paper for linear type thing?
09:03:38 * hackagebot i18n 0.4.0.0 - Internationalization for Haskell  https://hackage.haskell.org/package/i18n-0.4.0.0 (filib)
09:04:09 <{AS}> The one with the reverse turnstile you asked about
09:04:25 <merijn> {AS}: I'm reading the slides lambdamu mentioned earlier, not a paper unfortunately :)
09:04:31 <merijn> {AS}: This one http://pauillac.inria.fr/~fpottier/slides/fpottier-2007-05-linear-bestiary.pdf
09:04:34 <{AS}> merijn: Ah, thanks
09:04:47 <{AS}> merijn: So it seems to me as a notation to keep separate contexts
09:04:57 <{AS}> I would guess separate linear and non-linear contexts
09:06:05 <merijn> {AS}: The red Cs are the separate linear contexts, afaict
09:06:06 <merijn> {AS}: Hence my confusion about the reverse turnstile, seems like it's something like a "before/after" rule?
09:06:07 <{AS}> merijn: let me see
09:06:07 <merijn> But I don't understand where the τ bits of the rules are coming from
09:06:13 <{AS}> Yeah you are right
09:06:23 <Rudes> merijn: got hdevtools working, syntastic picks it up automatically but i didn't have cabal in my path, lol
09:06:29 <{AS}> Anyway, seems to be purely notational
09:06:50 <Rudes> merijn: thanks for your help
09:08:42 <riaqn> Hi, I get a wierd problem: https://github.com/riaqn/copy2gmail/blob/master/src/Main.hs
09:08:48 <merijn> Rudes: np :)
09:08:50 <riaqn> the above program prints all network traffic.
09:08:54 <riaqn> which I don't want to.
09:09:04 <{AS}> merijn: so it seems that the tau is the result type
09:09:05 <{AS}> And C is the result capability
09:09:05 <riaqn> I suspect it's some debug feature, but I can't find anything to config during the connection construction.
09:09:21 <Rudes> merijn: looks like hdevtools is assigned to my current ghc compiler thankfully
09:09:38 <Rudes> can we go back to blowing my mind with lambdas?
09:10:33 <Rudes> lol
09:10:42 <{AS}> merijn: it is just a confusing way of writing the ordinary let rule
09:10:47 <{AS}> Because capabilities are now mixed in as outputs
09:13:57 <{AS}> merijn  So read Gamma, C1 |- t1 -| tau1, C2 as t1 has type tau1 under Gamma and Capabilieties C1 producing Capabilieties C2
09:16:00 <merijn> {AS}: Right, so it's kinda like regular typing judgements mixed with Hoare logic
09:16:14 <{AS}> Yeah
09:17:12 <nitrix> If I forkIO inside runInBoundThread, will the created thread be unbound or bound?
09:17:29 <glguy> unbound
09:19:13 <roconnor> @seen Philippa_
09:19:13 <lambdabot> fI1IPpA_
09:19:28 <glguy> so leet
09:20:20 <merijn> roconnor: Lambdabot has never had a seen command. Anyway, she hasn't been around in a while
09:21:08 <roconnor> merijn: https://github.com/jwiegley/lambdabot/blob/master/Plugin/Seen.hs
09:21:44 <roconnor> glguy: :(  That's a log time ago.
09:21:48 <roconnor> *long
09:23:29 <lpaste> lambdafan pasted “Help me think about this problem” at http://lpaste.net/179539
09:26:08 <glguy> lambdafan: Read them as Integer and compare
09:26:39 <lambdafan> glguy: really? That simple. I thought I would have to do some kind of algroithmic trickery due to the fact the numbers could be so big
09:26:40 <geekosaur> yes, seen plugin was broken and memory-leaky and removed long ago. several of us made attempts to fix it first
09:27:12 <lambdafan> glguy: so I am just doing z < y comparison?
09:27:43 <lambdafan> glguy: they make it sound so tricky :)
09:28:05 <pavonia> > 2^(2^16) < 2^(2^17)
09:28:07 <lambdabot>  True
09:28:49 <pavonia> > length $ show $ 2^(2^16)
09:28:52 <lambdabot>  19729
09:29:03 <geppettodivacin> lambdafan: You could make it tricky, if you wanted to.
09:29:31 <lambdafan> geppettodivacin : Go on ...
09:29:55 <glguy> lambdafan: Integer is a more compact representation of numbers than String
09:29:59 <geppettodivacin> Well, if you wanted to skip the conversion to Integer, you could do it with a few cases.
09:30:18 <lambdafan> oh crap, I can't use Integer,read,reads,fromIntegral,fromInteger, or toInteger)
09:31:01 <geppettodivacin> First check signs, and if one of the two is negative, it's really simple.
09:31:46 <geppettodivacin> Then, you can check the magnitude of the number, and there's a really simple way to do that with a string.
09:31:57 <geppettodivacin> (But I'll let you think about it for a bit)
09:32:10 <lambdafan> geppettodivacin : cool, yeah I just wanted directon in my thought.
09:32:13 <geppettodivacin> And after you check the magnitude, you'll have to check the digits.
09:32:49 <geppettodivacin> There might be a simpler way to approach it, but that's the first way I see it.
09:32:53 <chsn> anyone here writing haskell with an kinesis ergo keyboard? I find the => and -> combos to be more annoying to hit; and was wondering if people had clevere keyboard rebindings
09:33:23 <osa1> chsn: I am
09:33:31 <osa1> chsn: I haven't had any problems so far
09:33:48 <osa1> is it annoying because of > ?
09:34:14 <chsn> osa1: I have the 'home' key rebound to backspace, and I want to make the 'backspace' key a new modifier, so that when I hold it down, all of !@#$%^&*()_+{}:"<> are easly accessible
09:34:51 <chsn> osa1: yeah, the <> [] {} are annoying, especially given how close they are to UPARROW DOWNARROW, which I often hit by accident, and kills my focus -- as in -- wheredid my code just go?
09:35:00 <chsn> "oh, i hit a wrong key, and it shifted me half a screen"
09:35:18 <glguy> chsn: I've been using a Kinesis for years. The remapping I use is just to switch the up and down arrows around.
09:35:19 <chsn> backspace  -io, kl, <> being bound to () [] {} would be sorta nifty I think
09:35:23 <osa1> maybe you should just give it some time. I never accidentally hit arrows.
09:35:45 <osa1> btw, arrow keys and {} are in different fingers. maybe you're using wrong fingers?
09:36:33 <glguy> osa1: I think it's that <> and []{} are on different fingers
09:36:44 <osa1> I use exactly the same mapping glguy. in addition I make caps lock ctrl, and also add an extra meta key somewhere
09:36:48 <osa1> (I don't remember the default layout)
09:37:02 <chsn> osa1: yeah, they are different fingers
09:37:05 <chsn> maybe I'm just bad a typing
09:37:16 <glguy> osa1: Oh,right. I swapped capslock and tab
09:37:32 <chsn> I no longer use capslock, as I bound "delete" to capslock
09:37:37 <chsn> and deltete with delete-H = ctrl-h
09:41:36 <chsn> on qwerty, => is : left hand hits "shift", right hand hits =, > // on kinesis, it's "right shift + left =", followed by "left shirt + right >"
09:41:46 <chsn> even though it's only one mor ekey, it just feels much more slower
09:42:43 <glguy> chsn: On Kinesis it's left-=, left-shift right->
09:43:23 <biglambda> I’m trying to reinstall cabal dependencies with the profiling versions. Everything is working swimmingly except on package OpenCL-1.0.3.4 doesn’t compile because there is something in the OpenCL header that c2hs doesn’t like. The fix is to add some cpp options to the .cabal file for OpenCL. But once I do this how do I make the modified package into the dependency for my project?
09:43:37 <osa1> chsn: you should have a += key on your kinesis, look at upper left
09:43:45 <osa1> chsn: you don't need shift for = on kinesis
09:43:50 <chsn> glguy: osa1 : you're right, I'm wrong
09:52:23 <puregreen> roconnor: if Philippa is the same as Philippa_ then she's been seen in May: http://chrisdone.com:10001/browse/haskell/?events_page=1&events_per_page=25&q=Philippa
10:12:24 <chsn> glguy: osa1 : did either of you do deliberate practice of typing haskell with kinesis keyboard? I'm considering using, i.e. https://typing.io/lesson/haskell/xmonad/StackSet.hs/1
10:12:54 <osa1> chsn: no, I did some general typing practice when I first bought it but that's it.
10:14:45 <Sonolin> does kinesis work well with vim? I'm assuming with arrow keys rebound?
10:14:55 <chsn> vim doens't use arrow keys
10:14:56 <chsn> vim uses hjkl
10:14:58 <osa1> it works as well as any other keyboard
10:15:34 <Sonolin> yea no shit chsn
10:15:43 <glguy> Sonolin: language
10:15:44 <Sonolin> my point was that one should probably rebound the arrow keys right?
10:15:59 <osa1> I never use arrows so that's not a problem. but even if you use arrows their position on kinesis is more comfortable I think
10:16:11 <chsn> I must be misunderstanding your question -- why would you rebind arrow keys in vim?
10:16:22 <puregreen> can I somehow get these overlapping instances to work? http://lpaste.net/179548
10:16:25 <Sonolin> it has arrows near thumb right? (The Kinesis)
10:16:40 <glguy> chsn: I don't remember exactly, it has been about 9 years. I think I just used it rather than deliberately practicing
10:16:53 <Sonolin> my concern is I virtually never use them so I wouldn't want a keyboard with arrow keys in my way
10:17:12 <glguy> Sonolin: No, they aren't in the way. There are pictures of the keyboard online
10:17:16 <puregreen> Sonolin: I know a Haskeller who bought a Kinesis and got comfortable with it after 2 weeks
10:17:40 <puregreen> wait, or should've I pinged chsn instead
10:17:45 <Sonolin> nice... thanks guys, I'll have to do more research
10:17:52 <Sonolin> wish there was a place to try them out in person
10:17:53 <chsn> puregreen: yeah, it's been a few days for me so far
10:19:18 <glguy> chsn: Are you using XMonad? Have you seen the picture of my Kinesis keyboard on xmonad.org ? :)
10:19:25 <osa1> chsn: few days may just be too short to get comfortable with this keyboard. I remember getting very frustrated with it during the first week because of typos etc. I wasn't fast enough until several weeks IIRC
10:19:28 <chsn> glguy: I am using xmonad; I have not seen you rpicture yet
10:19:38 <glguy> http://xmonad.org/
10:19:42 <osa1> glguy: oh that's your keyboard?
10:19:43 <osa1> heh
10:19:51 <chsn> https://wiki.haskell.org/wikiupload/a/aa/Screen-triplehead-galois.jpg this is yours
10:19:54 <chsn> ?
10:19:57 <glguy> osa1: Yeah ^_^
10:20:18 <glguy> I've since poured coffee into that specific keyboard; my current one is black 
10:21:29 <chsn> glguy: do people in nearby cubicles get annoyed at the clicky click of the kinesis?
10:21:37 <chsn> I think the only louder keyboard is the model M
10:21:46 <glguy> chsn: Just about everyone here has a Kinesis, so not really
10:21:59 <haldean> also the clickiness of it is at least partially due to a little speaker
10:22:03 <haldean> that makes a little click
10:22:05 <haldean> that you can turn off
10:22:21 <shapr> my office is converting to ergodoxes
10:22:57 <glguy> shapr: I have one of those (ergodox infinity), it's not quite in the same tier
10:23:29 <chsn> the ergodox looks alot more portable
10:23:47 * hackagebot acid-state 0.14.2 - Add ACID guarantees to any serializable Haskell data structure.  https://hackage.haskell.org/package/acid-state-0.14.2 (JeremyShaw)
10:23:47 <glguy> at least for my preferences, I can imagine someone liking it more
10:24:05 <chsn> I think the main thing tripping me up right now is just hitting shift. Maybe I should get a foot pedal.
10:24:14 <shapr> glguy: I have a stack of kinesis contoured keyboards, but I prefer my ergodoxes with cherry mx blue or green keyswitches.
10:24:41 <shapr> I am sad that I haven't seen any Atom or Ivory code to generate ergodox keymaps :-(
10:24:42 <ertes> a few years ago a colleague gave me a second screen, and the only use i got out of it was to leave movies/series running while coding, and it ended up distracting me so much that i gave him the screen back
10:24:48 <glguy> chsn: I've never figured out what the foot pedal is for. I've got one collecting dust under my desk
10:24:52 <ertes> (yes, i'm using xmonad)
10:25:18 <chsn> glguy: you can find it to modifier keys :-)
10:25:45 <glguy> Yeah, it's just so much less responsive than a finger key that I didn't find it useful for that. I tried it as an ESC key for vim, too :)
10:25:54 <shapr> glguy: I swapped insert and shift_l to put all mod keys under my thumbs, that's really helped me
10:26:15 <shapr> I also remapped pgup/pgdn home/end to hyper and super
10:27:18 <shapr> and yes, xmonad has several users at my company :-)
10:27:27 <ertes> glguy: you could program the pedal to lock your screen as soon as you release it, so while working you have to leave your foot resting on it
10:27:59 <chsn> shapr: is this via kinesis or xmoand? I don't see hyper/super keys on the kinesis
10:29:03 <geekosaur> they're x11 terms. super is usually the windows key. hyper is usually not bound on pc keyboards by default
10:29:05 <Welkin> super is the OS key, hyoer is the function key
10:29:12 <Welkin> hyper*
10:29:21 <geekosaur> (actually they're lispm terms repurposed by x11...)
10:29:55 <Welkin> like Meta
10:30:04 <Welkin> I like Alt to be called Meta
10:30:21 <mauke> only if it sets the meta bit
10:30:44 <Welkin> on mac it is called "option"
10:30:50 <Welkin> with "alt" in tiny font in the corner
10:31:29 <Welkin> does anyone use a those piano-like keyboards?
10:31:33 <Welkin> forgot what they are called
10:31:44 <glguy> On macOS with VTY the Alt key sends the MMeta modifier. Anyone know what it takes to send an MAlt modifier?
10:31:44 <Welkin> Doug Engelbart used one in his demo
10:34:44 <Rarrikins> Welkin: A Chorded Keyboard
10:43:12 <JonReed> Hi, wasn't there some way to disambiguate literals? I remember something about the "default" keyword. For example, I use TagSoup and it has functions accepting "StringLike str => ", which works with Strings
10:43:42 <JonReed> but if you set OverloadedStrings, then it will start complaining about ambigiuos literals unless to explicitly specify every literal (like :: Text).
10:44:15 <puregreen> {-# LANGUAGE ExtendedDefaultingRules #-} will default them to String, I think
10:44:23 <JonReed> wasn't there some way to say, "hey every literaly in this file is going to Text by default, so stop complaining
10:45:08 <JonReed> puregreen: Ahh, yeah. I remember something like this. Do you remember how to set it to Text by default or whether that was possible?
10:45:16 <puregreen> “default (Text)” somewhere in your file
10:45:23 <JonReed> puregreen: Thanks!
10:46:02 <mauke> shouldn't that be default (Integer, Double, Text)?
10:47:06 <puregreen> maybe
10:47:25 <geekosaur> unless you like meeding to ascribe a type to every numeric literal 
10:47:29 <geekosaur> *needing
10:48:40 <Sonolin> how do I refer to subfield with Aeson? I was hoping for something like 
10:48:51 <Sonolin> obj .: "parentField" .: "subField"
10:49:11 <puregreen> obj .: "foo" >>= (.: "bar")
10:49:13 <alercah> Sonolin: you'll need to add another obj in there
10:49:31 <alercah> oh wait, that's *not* a lens combinator is it?
10:49:32 <alercah> lol
10:49:33 <Sonolin> ah nice thanks puregreen, I'll try that
10:49:39 <alercah> ignore me
10:49:43 <Sonolin> just confused by the type signatures, totally makes sense
11:02:38 <Rudes> ongy: the real trick for pulseaudio would be to write the pulseaudio API in pure haskell
11:03:22 <ongy> Rudes: not that easy. And not really something I would do. If it only had the local functionality maybe with the DBus package, but network-foo I don't want to reimplement
11:03:32 <ongy> nor the fdmem sharing stuff
11:03:39 <Rudes> oh i don't blame you
11:03:44 <Rudes> but that'd be something else.
11:03:55 <Rudes> is the api source available?
11:04:14 <ongy> for pulse? both server and client lib are in the same repo on freedesktop.org
11:04:17 <Welkin> ongy: what are you doing with pulseaudio?
11:04:17 <Welkin> :D
11:04:27 <Welkin> I'm working with midi/sund things now too
11:04:29 <Welkin> sound*
11:04:32 <Rudes> https://github.com/Ongy/pulseaudio
11:04:34 <Welkin> I'm using fluidsynth
11:04:34 <ongy> Welkin: https://github.com/Ongy/pulseaudio 
11:04:53 <ongy> Mainly I want to read current system volume
11:05:05 <ongy> but that's not possible with pulse-simple, so I'm writing a wrapper for the async api
11:05:11 <ongy> and it's a pain :(
11:05:48 <Welkin> yeah, a lot of sound things are a pain
11:05:58 <ongy> and I'm sure any sane person would tell me I'm crazy for doing it (and especially the reason why)
11:05:59 <Welkin> I've been fighting with fluidsynth to do what I want too
11:06:08 <Rudes> my buddy is an embeded guy and he
11:06:14 <Rudes> he's been working on BT for a long time
11:06:16 <Rudes> he HATES it
11:07:40 <ongy> Welkin: something fun (but not that much of a problem for my wrappers): pulse uses rtclock for events, instead of a monotonic clock source
11:08:17 <Rudes> ongy: i'm not familiar, why does it cause an issue?
11:09:53 <ongy> Rudes: it's not monotonic :) So if I want to wait for let's say 30 seconds I have to get current time, add 30 seconds and if ntp or something similar decides that my system time is wrong, system time changes and 30s may become a few minutes, or nothing at all
11:10:14 <Rudes> oh man, bummer
11:10:34 <ongy> because I register a event for 3:00 instead of some non specified timer (I think normally process-start) that will not be changed
11:16:50 <Athas> How would I go about installing accelerate-examples through Stack, without creating an entire directory with a stack.yaml for it?
11:19:41 <int-e> @botsnack
11:19:41 <lambdabot> :)
11:19:50 <int-e> (poor thing, I broke it, working on it)
11:20:57 <lysgaard> Anyone have a reference on how typechecking in haskell works for "rigid" types, those type variables specified in type signatures by the programmer?
11:21:47 <Rudes> :t (\\)
11:21:51 <lambdabot> Eq a => [a] -> [a] -> [a]
11:21:59 <Rudes> int-e: didn't break it too much
11:22:26 <hsk3> What's the difference between Control.Exception and Control.Monad.Error? Are these two different ways of doing exception handling?
11:22:44 <Rudes> errors aren't exceptions usually
11:22:46 <Cale> lysgaard: perhaps http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/jfp-outsidein.pdf
11:23:30 <bergmark> hsk3: yes, but note that Control.Monad.Error is deprecated in favor of Control.Monad.Except
11:23:39 <Cale> hsk3: Control.Exception is mainly for dealing with the exception mechanism which is built in to IO, while Control.Monad.Error is about adding an exception system to another monad.
11:24:15 <Rudes> bergmark: good point
11:25:25 <ongy> Cale: it's possible to throw an exception in pure code to later catch it in an IO function, right? Can something like that be done with Control.Monad.Error?
11:25:40 <Cale> no
11:26:07 <Cale> But also, you probably shouldn't ever rely on that ability
11:26:27 <Rudes> i thought the point of haskell was to not have errors/exceptions
11:26:43 <Rudes> perfect pure code
11:26:59 <Cale> I would fork a library I was using to fix the way it was throwing exceptions from expression evaluation before trying to catch them.
11:27:05 <grantwu> The real world doesn't work that way
11:27:24 <grantwu> Rudes: See http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf
11:27:29 <Cale> Rudes: There are still lots of things you might not want to deal with in the ordinary case
11:27:56 <ongy> e.g. directories suddenly disapearing
11:28:00 <ongy> after you checked for them to exist
11:28:11 <Cale> Note:
11:28:16 <Cale> :t Control.Exception.try
11:28:20 <lambdabot> Exception e => IO a -> IO (Either e a)
11:28:24 <Rudes> grantwu: maaybe one day
11:28:38 <ongy> microsoft is in marktoberdorf? o.0
11:29:06 <Cale> ongy: Generally you should always use throwIO if you're using IO exceptions.
11:29:18 <Rudes> ongy: if IBM can back docker and leave it FOSS microsoft can appear in marktoberdorf
11:29:35 <Cale> The reason is that it throws the exception *when executed*
11:29:43 <Cale> Rather than when it's evaluated
11:30:03 <ongy> Cale: I don't think I ever threw an IO exception. I would prefer the ExceptT to make it more explicit.
11:30:24 <Cale> Usually, yes.
11:30:37 <Cale> Sometimes it's nice to be able to put off the handler to much later.
11:30:53 <Cale> Also, monad transforming IO is a big cost to pay
11:32:04 <lysgaard> Cale: the reference seems to cover the most advanced parts of ghc type checking with extentions. I am asking for extremly simple stuff, Haskell98 style. How does a function like this "foo :: a -> Int; foo x = -x" get rejected. The rule seems to be that "a" can not be "specialized" to Int. I wonder if there is any solid theory for this constraint that appears in user supplied type signatures.
11:32:05 <hsk3> If a function says it can throw IOError, does it mean I should be using the Control.Exception mechanism to handle it?
11:33:04 <Cale> lysgaard: Ah, well, in Haskell 98 when you provide a type signature, all the type variables in it are implicitly forall quantified at the top level of the signature.
11:33:11 <ongy> Cale: cost as in execution complexity?
11:33:27 <Cale> ongy: Cost as in hassle to the programmer due to the loss of things like catch and forkIO
11:33:44 <Cale> ongy: and the need to liftIO everything
11:34:27 <ongy> ahh, yes
11:34:42 <Cale> I wouldn't take monad transforming IO lightly. You want to have a good coherent plan from the outset about the monad you're constructing, what its primitives and capabilities ought to be, before you start applying transformers.
11:35:05 <alercah> ^ sage advice
11:35:24 <ongy> for my usecase it was mostly internal use and then export a function that's IO (Either a b), which makes it a hassle for me, not the user
11:36:20 <Cale> Yeah, that kind of thing is fair enough.
11:38:56 <Cale> lysgaard: hm... what's a good paper on HM type inference...
11:39:13 <Cale> lysgaard: I dunno, but look up "Hindley-Milner type inference"
11:39:24 <lysgaard> Cale: I see that in haskell all type variables are implicitly forall. I am wondering if there is some name for the algorithm that decides if the function can have that signature or not. Eg. my foo function can not have this signature, but how does one decide this? The problem seems to be with unification of signatures, which is different than for inferred types.
11:39:38 <int-e> > 1
11:39:40 <Cale> Yeah, that's what HM type inference is about
11:39:40 <lambdabot>  1
11:39:46 * int-e is confused.
11:40:03 <Cale> int-e: ?
11:40:35 <cocreature> int-e: it might be suprising but for most value of 1 it is equal to 1
11:40:46 <int-e> Cale: I'm not sure why it works now, just after restarting that gave me an error that semigroups should be trusted... and I did not tell it to trust semigroups in the meantime
11:41:11 <Cale> lysgaard: There's a section in https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system about "polymorphic type order"
11:41:52 <Cale> I don't know how comprehensible the article is if you're new to this stuff...
11:42:20 <Cale> But a good book to read if you're interested in the details of type systems is "Types and Programming Languages" by Benjamin Pierce
11:42:21 <amf> is there a util like threadscope but for memory profiling? the hp2ps is a little barebones
11:42:23 <hsk3> If a function says it can throw IOError, does it mean I should be using the Control.Exception mechanism to handle it?
11:45:13 <cocreature> hsk3: yep (assuming you don’t want the error to just propagate up the callstack)
11:45:36 <hsk3> Ok cool
11:46:08 <Jenaf> I have a Question:
11:46:17 <Jenaf> can i do stuff like this:
11:46:42 <hsk3> Are Control.Exception and  Control.Monad.Error/Control.Monad.Except the only methods for exception handlers in Haskell?
11:46:48 <hsk3> Or are there others that are commonly used as well?
11:47:10 <Jenaf> foo :: Integer -> [Integer] -> [Integer]; foo n = (\l -> [x|x<-l,predicate x])
11:47:19 <BMWPower> working through school for Haskell ;-)
11:47:38 <Jenaf> I get a pares error at -> if i type that into ghci
11:47:43 <Jenaf> *parse
11:47:59 <BMWPower> as a "coder" I still get it ;-)
11:49:32 <Jenaf> or I could just use filter, *facepalm*
11:54:46 <geekosaur> Jenaf, ghci is a bit like the inside of a "do"; you need to prefix that with a "let" (re: [22 18:47] <Jenaf> I get a pares error at -> if i type that into ghci)
11:55:11 <geekosaur> ghc8.0.1 changed that partially but I wouldn't be surprised if it's incomplete
11:55:26 <Jenaf> yeah i had that let in when I typed into ghci
11:55:34 <Jenaf> I was just to lazy to copy that into this chat
11:56:50 <Jenaf> as far is I undestood it so far with the integer -> ([Integer]->[Integer]) predicate that should be possible, but there seems to be some issue using a lamda there
11:57:06 <lysgaard> Cale: The wikipedia reference seems good. I am not completely new to type checking theory, but still a rookie.
11:57:46 <merijn> lysgaard: I missed context, but insert obligatory recommendation of TaPL here ;)
11:57:49 <Jenaf> maybee I woudl have to somehow declare that l is an [Integer] inside the lamda?
11:57:56 <int-e> Hah, found it. I had messed up my sandboxing.
11:58:16 <geekosaur> hm, I get an error that predicate is not in scope (not surprising) but that means it got past parsing
11:59:00 <Jenaf> omfg i'ms tupid
11:59:06 <Jenaf> *stupid
11:59:13 <Jenaf> I forgot the :: b4 the signature
11:59:23 <Jenaf> sorry for bothering you
12:00:17 <lysgaard> Cale, merijn: So when typechecking function signatures, sometimes the user signature can be more special than the inferred signature, eg. "myId :: Int -> Int; myId a = a" this is valid. But this signature "foo :: a -> Int; foo x = -x" is not more specialized, but still invalid. Is it so that the user supplied signature never should be more "general" than the inferred type?
12:02:08 <jonored> lysgaard: That would mean that the programmer is saying that the function can do things that it actually can't.
12:03:06 <lysgaard> jonored: I understand. So this means there exists some partial ordering for types? If so, that's pretty rad!
12:03:07 <merijn> lysgaard: Consider this, what if I pick 'a' as being "Maybe Bool" what would "-" applied to Maybe Bool mean?
12:03:36 <int-e> sigh, lambdabot will be even more prone to timeouts now... ghci init time for L.hs has increased by 60%.
12:03:55 <merijn> lysgaard: Yes! There exists a partial ordering of types, and every type (in haskell, this is not true in all other type theories) has a unique "most general type" (which is what GHC will infer)
12:03:57 <lysgaard> merijn: I understand that my example has an ill typed signature, what I am struggeling with is converting my intuition intoo a solid algorithm, math, theory.
12:04:34 <merijn> In fact, this isn't even true in Haskell + GHC extensions :)
12:05:05 <merijn> Which is why RankNTypes only works with explicit signatures, you cannot infer a unique most general type in the presence of RankN :)
12:05:06 <dolio> It's not even true that GHC will infer it for Haskell expressions.
12:05:28 <merijn> dolio: No? I thought it did? Can you give a counterexample?
12:05:45 <dolio> @type let f x = f () in f
12:05:50 <lambdabot> () -> t
12:06:07 <dolio> @type let f x :: a -> b ; f x = f () in f
12:06:11 <lambdabot> error:
12:06:11 <lambdabot>     Invalid type signature: f x :: ...
12:06:11 <lambdabot>     Should be of form <variable> :: <type>
12:06:16 <dolio> Oops.
12:06:20 <dolio> You get the idea, though.
12:06:30 <merijn> dolio: Oh, is this related to let-generalisation?
12:06:41 <merijn> Or the inverse?
12:06:49 <dolio> No, it's related to polymorphic recursion.
12:07:05 <merijn> This is not a strong part of my knowledge :p
12:07:24 <dolio> f calls itself at a potentially different type than it was called with.
12:07:44 <merijn> lysgaard: Anyway, as I mentioned a bit back, if you wanna learn this stuff TaPL is the best starting point :)
12:07:47 <dolio> Inference of the most general type of such functions isn't decidable.
12:08:15 <lysgaard> dolio, merijn, Cale, jonored: Is there any fora for pl-theory like this which people hang out in?
12:08:19 <mauke> :t show . read
12:08:24 <lambdabot> String -> String
12:08:29 <merijn> lysgaard: This is a pretty decent place :p
12:08:38 <OdinSec> lol
12:08:39 <dolio> The normal Hindley-Milner algorithm gets the wrong answer (or says there's a type error).
12:08:39 <lysgaard> merijn: I agree!
12:08:50 * hackagebot haskell-lexer 1.0.1 - A fully compliant Haskell 98 lexer.  https://hackage.haskell.org/package/haskell-lexer-1.0.1 (IavorDiatchki)
12:08:54 <OdinSec> Whats is this channel about?
12:09:12 <mauke> haskell
12:09:15 <merijn> lysgaard: TaPL starts with untyped lambda calculus and builds up to Haskell (and far more complex stuff), including example implementations of those type checkers
12:09:34 <geekosaur> lysgaard, maybe work through how "foo :: a -> Int; foo x = -x" gets typechecked? (what happens is that it concludes that "a", which you specified in the signature so it is a "rigid" type variable, must unify with Int --- but because "a" is rigid, that unification is not permitted)
12:09:37 <merijn> lysgaard: The examples are in ocaml, but since it's only basic ocaml you should be able to read/understand them with only basic haskell knowledge
12:09:37 <johnw> it's about Haskell primarily, but we also indulge theory that relates to the sort of concepts that we might use in Haskell (category theory, PL, logic, etc)
12:09:43 <lysgaard> merijn: I have had TaPL on my reading list for a long time, but can't find time to work on it.
12:10:51 <dolio> merijn: Anyhow, the problem isn't the let, it's the definition of f. And the addition of signatures and using Milner-Mycroft lets f have a more general type.
12:10:52 <merijn> The first 10-14 chapters are pretty easy to read, you can just gloss over the actual proofs and take it on faith if you wanna make some progress
12:11:03 <lysgaard> geekosaur: Exactly! What are these "rigid" things. I would love to see some papers, blog posts, books etc. explaining how rigid type variables differ from my normal SystemF type variables.
12:11:04 <geekosaur> put otherwise, that type signature says foo will produce an Int for any type a the caller specifies, but the implementation forces a to always be Int
12:11:07 <johnw> yeah, don't feel you need to work through it all the first time
12:11:47 <merijn> lysgaard: tbh, any blogposts and papers will take more effort and time than TaPL will, you don't need to finish the entire book to get something useful out of it :)
12:11:54 <geekosaur> which is what "rigid" means, as a practical matter (that you specified it as being up to the caller to choose what "a" is, so the function must abide by that)
12:12:11 <merijn> lysgaard: I think my first attempt I only got to chapter 12, second until 24 or so, and a bunch of later ones are still unread
12:12:30 <merijn> lysgaard: It even has a DAG that shows which chapters are prerequisite knowledge for others if you wanna skip stuff :)
12:12:58 <lysgaard> So in the Haskell type checker there are two types of type variables, normal ones which can be specialized, and rigid ones, which can not?
12:13:15 <lysgaard> merijn: I really have to read that book.
12:13:33 <merijn> lysgaard: Rule 1 of academic reading: It's ok to skip stuff. Rule 2: It's ok to not finish something when you stop understanding stuff. Rule 3: Even skimming is useful
12:14:01 <merijn> lysgaard: Half the type theory papers I don't have a clue what the hell they're talking about until like reading attempt 5 or 6 :)
12:14:02 <geekosaur> there's more than two actually. wait until you hit skolems :)
12:14:11 <senoj> rule n+1: read something, wait a while, read it again
12:14:17 <merijn> senoj++
12:14:33 <ongy> skolems? I haven't seen that yet
12:14:50 <lysgaard> You guys, I am starting to think I should have studied type theory, sounds fun.. and pretty tricky :)
12:15:08 <merijn> lysgaard: People always think academics understand all this stuff and papers immediately
12:15:15 <senoj> skolems are like golems, but they wear roller skates
12:15:17 <ongy> lysgaard: so does summoning the devil. At least to me. Still won't  do it
12:15:20 <merijn> lysgaard: In reality academics have gotten used to feeling perpetually confused
12:15:44 <merijn> It's the feeling of learning :p
12:15:45 <geekosaur> http://stackoverflow.com/questions/12719435/what-are-skolems
12:16:03 <dolio> lysgaard: A hard part is that there is implicit stuff going on that makes more sense when it's made explicit.
12:16:10 <mniip> I prefer 'rigid tyvars'
12:16:18 <geekosaur> (read all the comments as well, because in the actual question there isn't actually a difference between rigid and skolem)
12:16:26 <dolio> Like, do you know the difference between a and b in: a |- e : forall b. a -> b
12:18:02 <dolio> From that judgment, it makes sense to derive `a |- e : a -> Int` but not `a |- e : forall b. Int -> b`.
12:18:30 <mniip> a |- e?
12:18:31 <merijn> ongy: tbh, the basics of this stuff isn't even that hard :)
12:18:34 <geekosaur> lysgaard, in any case, to understand the "foo :: a -> Int; foo x = -x" case it helps to explicitly state the qualification. foo :: forall a. a -> Int
12:18:38 <mniip> wouldn't that make 'a' a context and not a tyvar?
12:18:50 * hackagebot hscaffold 0.4.0.0 - Very simple file/directory structure scaffolding writer monad EDSL  https://hackage.haskell.org/package/hscaffold-0.4.0.0 (yamadapc)
12:19:01 <geekosaur> which makes it obvious that a can be anything, and therefore cannot be forced to Int
12:19:01 <dolio> The context is mentioning a single used variable 'a'.
12:19:03 <ongy> merijn: devil summoning?
12:19:07 <mniip> ah
12:19:08 <merijn> ongy: type theory :p
12:19:38 <mniip> I never figured out what those pesky \Gamma things are
12:19:44 <ongy> I have to start reading into it at some point. But I always try to understand it in terms of haskell, which fails (for me)
12:19:47 <mniip> although I can kinda follow them in the inference axioms
12:19:55 <ongy> and maybe I'm starting at the wrong place
12:20:03 <merijn> mniip: "assorted unspecified variables in scope"
12:20:28 <ongy> merijn: so if you can point me to a good paper for starting :)
12:20:47 <merijn> mniip: Suppose we define a lambda inside a bunch of nested lambda's, then we already have a bunch of stuff in scope. We don't wanna explicitly enumerate it, so we just name everything we already had Γ 
12:21:12 <merijn> ongy: TaPL :)
12:21:19 <ongy> is that a book?
12:21:23 <merijn> @where tapl
12:21:24 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
12:21:45 <merijn> If you find it too expensive, most university libraries should carry it.
12:22:54 <mniip> merijn, I thought the meaning of \Gamma depends on the System?
12:23:34 <merijn> mniip: Oh sure, but 95% of the time (maybe) more, it means "some context"
12:23:57 <ongy> merijn: :( It's not included in online access
12:24:04 <lysgaard> Do any of you know what part of TaPL would cover these rigid type variables, and what their unifification rules are?
12:24:05 <ongy> now I actually have to go outside tomorow to get it
12:24:06 <mniip> so that you can say like
12:24:20 <merijn> mniip: Which is why you have things like weakening/contraction rules which says "we can add/remove unused variables from the context without changing the validity"
12:24:56 <mniip> G,(x::a) |- (v::t)    ====>    G |- (\x -> v) :: (forall b. [a->b]t)
12:25:50 <merijn> mniip: Not quite? unless I misunderstand your notation?
12:26:07 <mniip> no?
12:26:27 <merijn> mniip: "G,(x::a) |- (v::t) ===> G |- (\(x::t) -> v) :: a -> t"
12:26:29 <joe9> is there a way to derive the pretty text instances using Generics? https://hackage.haskell.org/package/wl-pprint-text-1.1.0.4/docs/Text-PrettyPrint-Leijen-Text.html
12:27:07 <merijn> eh
12:27:18 <merijn> "\(x::a) -> v" obviously
12:28:08 <merijn> mniip: i.e. "if we can conclude "v :: t" with some variable "x :: a" in scope, we can also add a lambda binding for "x :: a" and remove it from the scope without changing the type of 'v'
12:28:32 <ongy> oh wow, the book is quite expensive :(
12:29:26 <ggole_> Might be cheaper second hand
12:30:01 <merijn> Hence why i said university library
12:30:30 <shapr> ATTaPL is more like a bunch of papers in a single book
12:30:32 <ggole_> Uni libraries are great (I often sneak in), but not everybody is close to one
12:30:45 <shapr> also, those books are very heavy and great for killing insects.
12:31:26 * ggole_ wonders what kind of arthropods shapr is contending with that requires the heft of a type theory book
12:32:02 <merijn> Yeah...
12:32:09 <merijn> TaPL is heavy enough to kill a small dog...
12:32:12 <ggole_> Some of the larger centipedes, maybe
12:32:32 <ggole_> A big scolopendra isn't something I'd wanna whack with a newspaper
12:33:51 * hackagebot userid 0.1.2.7 - The UserId type and useful instances for web development  https://hackage.haskell.org/package/userid-0.1.2.7 (JeremyShaw)
12:34:31 <mniip> I should finish TaPL someday
12:35:10 <ongy> ggole_: afaik my unis library is quite cool
12:35:33 <shapr> mniip: it's really fun, though I don't think I've made it all the way through either.
12:36:52 <merijn> shapr: I'm getting an echo of #haskell on twitter :p
12:36:57 * shapr grins
12:37:04 <shapr> merijn: I thought it was funny ;-P
12:37:27 <shapr> ggole_: I modified your quote and put it on twitter
12:38:00 <lambdamu> why would one go to a library these days?
12:38:13 <shapr> lambdamu: they're the only place left that doesn't have TVs on the wall
12:38:29 <mniip> tyvars? on the wall?
12:38:38 <merijn> Relatedly, is there a blogpost/good example of implementing type checking for case-of ADTs?
12:38:52 <c_wraith> libraries have advanced incredibly well with the times.  Most of them have free wifi and ebook lending (even remotely) these days
12:39:11 <merijn> I implemented the stuff described in "Henk: a typed intermediate language" by SPJ and Erik Meijer, but they kinda gloss over how to typecheck case expressions
12:39:16 <lambdamu> c_wraith: that's cool, though never heard of ebook lending
12:39:23 <lambdamu> how would that work
12:40:54 <merijn> And my first N attempts have resulted in kinda buggy results >.>
12:41:00 <c_wraith> lambdamu: you download an app like overdrive.  It asks for what library and what your library card number is.  Then it lets you download ebooks (as long as the library has a copy available in their licenses) and read them in a period of a few weeks.  After that, you need to check them out again.  There's some DRM involved, but it's trivial stuff - mostly just to make you have to mean it to copy the stuff you download.
12:41:08 <c_wraith> merijn: maybe N+1 is the magic number
12:41:49 <merijn> c_wraith: Sure, but before I attempt "solution by smashing head against wall repeatedly" I figured I'd see if anyone had done something similar :p
12:41:54 <implementation_> in my library it depends on the publisher. either with a DRM app or you can only read it on a webpage in a browser. but sometimes it really is a drm-free PDF or EPub, that's great
12:42:18 <merijn> I know Tekmo's Morte is based on Henk, but he doesn't have ADTs, he uses Scott (or Church?) encoding for ADTs
12:42:39 <merijn> So I can't crib his implementation :)
12:42:59 <ongy> lambdamu: because it's cheap (and for me closer than any bookstore)
12:43:16 <implementation_> most libraries also have public book scanners
12:43:59 <lambdamu> all good reasons, i consider myself educated now on the merits of contemporary libraries
12:44:01 <ggole_> merijn: you mean, how to compile pattern matching? Or just type checking?
12:44:10 <merijn> ggole_: The type checking
12:44:31 <merijn> ggole_: I know how to do "simple" matching, i.e. patterns that only inspect a single constructor
12:44:51 <lambdamu> maybe i'll take my ebook reader to a library some time
12:44:53 <ongy> implementation_: I never found an actually usable book scanner for bound books :(
12:45:33 <geekosaur> also, reference librarians. (you know those annoying people who always seem to be able to build search engine queries that get what they want in the first few hits? they're like that but for pretty much any reference media)
12:45:34 <ggole_> I don't think it's all that different to type checking terms 
12:46:37 <kjslag> +RTS -s reports information such as "bytes maximum residency". Is there a way to access this information from within a haskell program?
12:47:18 <ggole_> There's some boring stuff like collecting an map of variable patterns to their types, and making sure they are unique
12:47:29 <implementation_> ongy: we have some. the image quality is usually quite bad, but sufficient and it's incredibly easy and fast to use. you can scan some chapters in no-time.
12:47:52 <ggole_> Which isn't tricky unless you have or-patterns, and not very difficult then
12:48:24 <ggole_> merijn: which bit did you have trouble with?
12:48:45 <BMWPower> getting the hang of it
12:49:04 <merijn> ggole_: The thing is that I'm dealing with System F, so my constructors include type arguments, like "data Foo a b where Foo :: forall a b . a -> b -> Foo" so that if I have "case bar of Foo a Bool x True -> baz" I need to somehow compute a type from the pattern to unify with the type of bar
12:49:04 <BMWPower> Haskell is defining and thinking in types.
12:49:12 <BMWPower> Types give functionality
12:49:40 <merijn> ggole_: Which somehow keeps coming out wrong
12:49:43 <BMWPower> functions give back this functionality
12:51:37 <lpaste> merijn pasted “No title” at http://lpaste.net/179588
12:51:49 <merijn> ggole_: So, suppose I have that paste
12:51:55 <ggole_> Oh, system f. Hmm.
12:52:04 <ggole_> The one I did was boring old HM.
12:52:25 <merijn> ggole_: 't' must clearly equal 'z' in that context so that "Just t x" comes out as "Maybe x", but I can't get that to work
12:52:28 <ggole_> (Where you just get the constructor type from the environment, generalise, and then unify away.)
12:52:35 <merijn> ggole_: And the Henk paper completely glosses over how to deal with this
12:53:07 <merijn> ggole_: Yeah, but with HM I don't have RankN types
12:53:18 <ggole_> Sure.
12:53:40 <merijn> And I wanted to know how to implement RankN types :p
12:53:52 <ggole_> Hmm, I would think that a matching with a polymorphic constructor would require a type application somewhere?
12:54:20 <merijn> I guess I should, at some point, read the huge tome "Practical Type Inference for Arbitrary Rank Types"
12:54:32 <merijn> ggole_: 't' is the type in that case :)
12:54:39 <ggole_> Well, inference and type checking for system F are a bit different.
12:54:40 <int-e> okay, lambdabot should be functional again, including evaluation (with a moderately increased timeout to make up for longer initialization time) and @hoogle (whose database is now finally populated again)
12:55:06 <jle`> > text "hi"
12:55:18 <merijn> ggole_: I know, right know I'm not doing inference at all
12:55:20 <lambdabot>  mueval-core: Time limit exceeded
12:55:20 <lambdabot>  mueval: ExitFailure 1
12:55:25 <jle`> im so sorry
12:55:38 <int-e> > text "hi"
12:55:46 <lambdabot>  mueval-core: Time limit exceeded
12:56:04 <int-e> hmm, still busy with something else.
12:56:31 <merijn> ggole_: But I can't find any simple examples, despite the rest of Henk being so deceptively simple :\
12:56:32 <int-e> > text "hi"
12:56:35 <lambdabot>  hi
12:56:42 <merijn> ggole_: So the lack of rules for ADTs is a bit of a bummer
12:57:03 <merijn> I'm not ruling out I fucked up something else, but I wouldn't know where to start
12:57:36 <Gurkenglas> umm might have been something to do with me the last few minutes? Probably not tho lpaste.net/383225711185362944
12:57:38 <ggole_> ...dammit, now you've got me wanting to do it
12:58:26 <merijn> ggole_: Go do it, then explain me how! ;)
12:58:36 <merijn> ggole_: Then in the meantime I can continue reading about linear types :p
12:58:51 * hackagebot hscaffold 0.4.1.0 - Very simple file/directory structure scaffolding writer monad EDSL  https://hackage.haskell.org/package/hscaffold-0.4.1.0 (yamadapc)
12:58:53 * hackagebot hscaffold 0.4.2.0 - Very simple file/directory structure scaffolding writer monad EDSL  https://hackage.haskell.org/package/hscaffold-0.4.2.0 (yamadapc)
12:59:15 <ongy> oh wow, one of the services my uni uses for book online access completion suggests TaPl but doesn't have it :(
13:00:34 <EvanR> TAPL is freely available online... well some version of it at least
13:00:36 <ongy> int-e: you broke it
13:00:43 <ongy> EvanR: legally?
13:00:59 <int-e> ongy: I broke what?
13:01:10 <EvanR> yes
13:01:16 <ongy> lambdabot, or at least I have never seen it part/join before
13:01:23 <merijn> EvanR: Oh? Where?
13:01:38 <merijn> ongy: I'm assuming he was restarting lambdabot :)
13:01:42 <int-e> ongy: I restarted it, killed it, restarted it again... it happens.
13:01:44 <EvanR> oh, maybe not...
13:01:57 <EvanR> but if its pops up on google it cant be that bad
13:01:58 <merijn> EvanR: Software Foundations is, but not TaPL, afaik
13:02:07 <int-e> > text "hi"
13:02:18 <lambdabot>  hi
13:03:38 <geekosaur> people were using a russian pdf yesterday... I assume it was a not entirely sanctioned copy
13:05:00 <int-e> anyway, hopefully done for now
13:05:12 <ongy> :t hi
13:05:14 <int-e> (with updating and torturing lambdabot)
13:05:19 <lambdabot> error:
13:05:19 <ongy> :t "hi"
13:05:25 <lambdabot>     • Variable not in scope: hi
13:05:31 <lambdabot> [Char]
13:05:40 <ongy> int-e: did it get slower? or is my bouncer lagging?
13:05:46 <ongy> :t \x -> x
13:05:52 <lambdabot> t -> t
13:05:55 <int-e> ongy: it's probably still joining channels
13:06:06 <ongy> how many channels is it in?
13:06:21 <int-e> 90
13:08:05 <int-e> :t \x y -> y x
13:08:07 <lambdabot> t -> (t -> t1) -> t1
13:08:29 <ongy> :t flip ($)
13:08:31 <lambdabot> a -> (a -> c) -> c
13:08:53 <ongy> so when is it t,t1 and when is it a,b?
13:09:05 <merijn> ongy: Compiler heuristic
13:09:16 <merijn> ongy: GHC *tries* to use names similar to user input
13:09:22 <merijn> :t id :: x -> x
13:09:24 <lambdabot> x -> x
13:09:29 <merijn> :t id :: r -> r
13:09:32 <lambdabot> r -> r
13:09:44 <Gurkenglas> https://www.reddit.com/r/haskell/comments/1dpk2b/haskell_for_all_program_imperatively_using/c9sy0pd?context=10000 huh? Couldn't you just compose (rmap . fmap) (\x -> if p x then x else error "filtered': variant property")
13:09:44 <Gurkenglas>  to the right of filtered p to add that check?
13:09:44 <ongy> @src id
13:09:44 <lambdabot> id x = x
13:09:46 <merijn> ongy: Occasionally suffixing by adding, e.g. numbers if the same name overlaps
13:09:54 <Gurkenglas> @letlpaste 234626933734768640
13:09:58 <lambdabot>  Defined.
13:10:25 <merijn> ongy: But there's no real reason/logic behind the names that get selected besides some heuristics
13:10:36 <merijn> ongy: They don't have a special meaning
13:11:05 <geekosaur> if it has no idea what the type is, it starts with t (currently; some older versions used r for some reason). if it has something that it's seen a type signature for, it will try to use types from that signature
13:12:42 <dmwit_> Gurkenglas: What did that @letlpaste command actually define?
13:12:59 <Gurkenglas> dmwit, http://lpaste.net/234626933734768640
13:13:19 <dmwit> oh my
13:13:29 <Gurkenglas> I would demonstrate but I'm not sure lambdabot is responsive enough
13:13:54 <int-e> Gurkenglas: give it a try?
13:13:59 <dmwit> Can it handle imports?
13:14:05 <Gurkenglas> > traverse . filtered' even +~ 1 $ [1,2,3,4]
13:14:13 <lambdabot>  mueval-core: Time limit exceeded
13:14:31 <Gurkenglas> It could until apparently today. http://ircbrowse.net/browse/haskell?q=letlpaste
13:14:51 <int-e> > traverse . filtered' even +~ 1 $ [1,2,3,4]
13:14:57 <lambdabot>  [1,*Exception: filtered': variant property
13:14:57 <lambdabot>  CallStack (from HasCallStack):
13:14:57 <lambdabot>    error, called at /tmp/mueval2145174067468703135.hs:164:38 in main:L
13:15:33 <Gurkenglas> It's just http://hackage.haskell.org/package/lens-4.14/docs/src/Control.Lens.Fold.html#filteredwith an extra invariance check
13:15:41 <int-e> uh that callstack is going to be annoying.
13:18:52 * hackagebot VKHS 1.7.2 - Provides access to Vkontakte social network via public API  https://hackage.haskell.org/package/VKHS-1.7.2 (SergeyMironov)
13:22:28 <int-e> and that can't be switched off without patching base... brilliant.
13:22:51 <glguy> int-e: You could `catch` ErrorCall and not render the callstack
13:23:32 <glguy> but since you probably know that there must be another complication I'm missing
13:24:17 <ahsfhyicxv> Are (MonadIO m, MonadPlus m) => m a and (MonadIO m) => m (Maybe a) isomorphic?
13:24:44 <int-e> glguy: hmm, perhaps, but that means digging into hint code... not sure which I prefer
13:25:12 <glguy> int-e: Oh, OK.
13:25:43 <dmwit> int-e: There's always the crappy solution: `sed /^CallStack/,$d` ;-)
13:26:33 <merijn> dmwit: Props for sed use other than search/replace ;)
13:27:09 <dmwit> ahsfhyicxv: I kind of doubt it. Nothing about `MonadPlus` promises that there is at most one `a`.
13:27:44 <glguy> Also MonadPlus doesn't allow you to observe the failure directly
13:29:09 <ahsfhyicxv> dmwit: How do create a monad plus with more than one `a`?
13:29:46 <int-index> ahsfhyicxv, [] has a MonadPlus instance
13:29:47 <dmwit> ahsfhyicxv: `ListT IO a` sounds like a good candidate.
13:29:48 <merijn> ahsfhyicxv: List, for example
13:30:03 <merijn> > mplus [1,2,3] [4,5,6]
13:30:06 <lambdabot>  [1,2,3,4,5,6]
13:31:14 <int-index> although if your type is universally quantified, this is not an option
13:31:36 <int-index> the actual difference is due to pattern matching. `MonadPlus` doesn't have a way to check for a failure
13:32:34 <int-index> you can go from `forall m a . MonadIO m => m (Maybe a)` to `forall n . (MonadIO n, MonadPlus n) => n a`, but not in the opposite direction
13:33:20 <ahsfhyicxv> int-index: What values does MaybeT fail on?
13:33:34 <ahsfhyicxv> > :t mplus [1,2,3] [4,5,6]
13:33:38 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
13:33:45 <ahsfhyicxv> :t mplus [1,2,3] [4,5,6]
13:33:47 <lambdabot> Num a => [a]
13:34:16 <int-index> ahsfhyicxv, `MaybeT m a` is isomorphic to `m (Maybe a)` but you can't generalize it over arbitrary `MonadPlus` instances
13:34:20 <ahsfhyicxv> int-index: Sorry runMaybeT
13:36:01 <int-index> hmm. This actually might work. 
13:37:02 <glguy> int-index: can you recover failure detection with MonadPlus via \m -> Just <$> m <|> pure Nothing ?
13:37:03 <intothemountains> Set.map :: Ord b => (a -> b) -> Set a -> Set b
13:37:11 <intothemountains> Why does b have to be Ord?
13:37:21 <glguy> int-index: Oh, nevermind, that could give back both results in [] case
13:37:41 <merijn> intothemountains: Sets are balanced search trees. How do you balance without comparison operator?
13:38:04 <intothemountains> But isn't that an implementation detail?
13:38:22 <intothemountains> They don't have to be implemented as balanced search trees right?
13:39:03 <dmwit> It is indeed an implementation detail leaking into the type.
13:39:10 <dmwit> Nevertheless, that is the explanation for the type.
13:40:03 <merijn> intothemountains: It's also hard to imagine how one could have efficient sets without that knowledge
13:40:25 <MarLinn> That's what the real world does to your mathematical perfection I guess 
13:40:30 <merijn> intothemountains: How else would you implement them? Hash map based set? Now you need a hash operation
13:40:41 <ahsfhyicxv> Ia there a similar type to MonadPlus a that only allows one a or zero a?
13:40:58 <merijn> intothemountains: You could have a list with just Equality and checking for membership in O(n) complexity, but that seems undesirable...
13:41:06 <jonored> ahsfhyicxv: MonadPlus isn't a type, it's a class of types. One that includes Maybe, I believe.
13:41:10 <merijn> intothemountains: And would STILL require an Equality constraint
13:41:22 <merijn> jonored: Maybe is an instance of MonadPlus, yes
13:41:23 <intothemountains> Yes, equality would be a must
13:42:03 <ahsfhyicxv> jonored: Ok is there a class of types that only allows one or zero a?
13:42:21 <merijn> ahsfhyicxv: Why a class of types, as opposed to just Maybe?
13:42:25 <jonored> ahsfhyicxv: Probably not, because there's a type that does it just fine.
13:43:29 <ahsfhyicxv> merjin: It makes dealing with monad stacks easier
13:43:58 <BMWPower> oke trying to import System.ZMQ4.Monadic
13:44:07 <BMWPower> do I have to reference in Haskell?
13:44:45 <int-e> glguy: actually it seems I can do that in mueval... will try
13:44:58 <jonored> ahsfhyicxv: Are you looking for a typeclass, or are you looking for MaybeT?
13:45:36 <ahsfhyicxv> jonored: A typeclass that includes MaybeT and Maybe.
13:46:02 <Gurkenglas> glguy, but that wouldn't even make lambdabot say a message passed to error, right?
13:46:27 <pikajude> will the argument to `finally` run in the case of ThreadKilled?
13:47:00 <ertes> pikajude: yes, but only if the main thread is still running
13:47:03 <pikajude> ok
13:47:08 <jonored> There's a random question: can you have a typeclass with no methods?
13:47:13 <pikajude> well, that's fine, if the main thread isn't running the whole program is fucked
13:47:18 <ertes> jonored: sure
13:47:34 <BMWPower> i used stack install zeromq4-haskell
13:47:49 <ertes> pikajude: it's still important, because if you're doing mandatory cleanup, make sure the main thread actually waits for it to finish
13:48:01 <merijn> jonored: Yes
13:48:10 <merijn> jonored: You can even have a typeclass without a type :)
13:48:30 <merijn> "class Foo where something"
13:48:36 <ertes> pikajude: note that the 'async' library does most of that plumbing for you in a safe way (use 'wait' after 'cancel')
13:48:47 <jonored> So I suppose if you really want the "MaybeT and Maybe" to pass that constraint around you could.
13:49:21 <int-index> ahsfhyicxv, http://lpaste.net/179604
13:49:37 <int-index> now use equational reasoning to prove `fg = id` and `gf = id`
13:49:48 <int-index> if you succeed, the types are isomorphic
13:51:48 <ahsfhyicxv> int-index: They are not isomorphic because there can be more than one t in a MonadPlus t
13:51:52 <BMWPower> ahh i had to use cabal update and then cabal install
13:52:30 <int-e> glguy: But meh, it's all baked into Show instances of the various exception types.
13:52:34 <int-index> ahsfhyicxv, not really as long as it's `forall m . MonadPlus m`, not `exists m . MonadPlus m`. that's where the confusion stems from
13:53:02 <int-index> so if you pick a concrete type, like [], that has a `MonadPlus` instance, then yes, you can have multiple values.
13:53:30 <int-index> if all you have is `forall m . MonadPlus m`, you can only have one value (via return) or no values (via mzero)
13:53:52 <int-index> note the RankNTypes in the snipped I provided
13:53:58 <int-index> *snippet
13:55:20 <ahsfhyicxv> Ok, thank you for your help. I am closer to understanding it. I need to look at it again later.
13:57:52 <ahsfhyicxv> int-index: What about mfromList? It converts a list to a MonadPlus
14:02:22 <merijn> Right, so I just finished a 140 slide crash course on linear types. Anyone got a similar intro to row types? :p
14:02:51 <shachaf> Oh, do you understand par now?
14:03:16 <int-index> ahsfhyicxv, nice catch!
14:03:53 <int-index> ahsfhyicxv, http://lpaste.net/179611
14:04:01 <int-index> so `fg` is not `id`
14:05:03 <int-index> so indeed we can have multiple values via `mplus`
14:05:28 <int-index> `return 1 <|> return 2` will give you `Just 2` for `Maybe` and `[1,2]` for `List`
14:06:14 <johnw> > Just 1 <|> Just 2
14:06:17 <lambdabot>  Just 1
14:06:36 <int-index> So I guess if you want to preserve all the structure, the obvious choice would be "Free MonadPlus" instead of "Maybe"
14:06:40 <int-index> https://hackage.haskell.org/package/free-3.3/docs/Control-MonadPlus-Free.html
14:07:03 <int-index> johnw, well, yes, but my point stands
14:08:15 <merijn> johnw: To be fair, a right biased <|> would be an equally valid MonadPlus for Maybe :)
14:10:00 <ahsfhyicxv> What exactly is "Free MonadPlus"? Is it "MonadPlus" with only one value? Does a MonadMaybe exist?
14:11:17 <int-index> "Free MonadPlus" is to MonadPlus as [] is to Monoid
14:12:32 <int-index> MonadMaybe almost exists, it's MonadError ()
14:13:24 <BMWPower> ha! Got RabbitMQ and Haskell working!!!!
14:13:48 <int-e> > error "better..."
14:13:51 <lambdabot>  *Exception: better...
14:13:54 * hackagebot predictive 0.1.0 - Predict the future, backtrack on failure  https://hackage.haskell.org/package/predictive-0.1.0 (esz)
14:14:32 <int-e> are there any other expected exceptions with stack traces, in lambdabot's context?
14:15:01 <int-e> (I'm now modifying the ErrorCallWithLocation ones)
14:16:29 <int-e> glguy: and thanks for the hint, this is probably the easiest way.
14:17:39 <ahsfhyicxv> int-index: Any reason it does not exist? Every other monad seems to have a typeclass? (MonadIO, MonadWriter, MonadReader, etc)
14:17:41 <jle`> :t fmap @[]
14:17:43 <lambdabot> error:
14:17:43 <lambdabot>     Pattern syntax in expression context: fmap@[]
14:17:43 <lambdabot>     Did you mean to enable TypeApplications?
14:17:49 <mniip> wew
14:17:52 <mniip> GHC 8.0
14:18:17 <jle`> just checking :3
14:18:45 <mniip> @let type family KindOf a where KindOf (a :: k) = k
14:18:47 <lambdabot>  Defined.
14:19:03 <BMWPower> Question: how can I make Haskell work like a microservice? Suppose I get messages in a Queue and this triggers Haskell "running" module?
14:19:06 <mniip> :t undefined :: KindOf (->)
14:19:08 <lambdabot> * -> * -> *
14:19:26 <dmwit> > 1/0
14:19:28 <lambdabot>  Infinity
14:19:33 <dmwit> > 1 `div` 0
14:19:36 <lambdabot>  *Exception: divide by zero
14:19:41 <int-index> ahsfhyicxv, https://www.reddit.com/r/haskell/comments/3ded39/why_cant_we_have_an_eithert_in_transformers/ct4rt77
14:19:52 <mniip> :t undefined :: KindOf Eq
14:19:54 <lambdabot> * -> Constraint
14:20:03 <ReinH> BMWPower: run a process that consumes a queue?
14:20:13 <BMWPower> ReinH: yes
14:20:15 <mniip> fascinating
14:20:20 <int-index> we don't have MonadMaybe because more classes = more instances (quadratic) = more problems
14:20:20 <ReinH> Yes, you can do that.
14:20:43 <BMWPower> ReinH: oke cool! Then every module is a microservices on its self?
14:20:51 <ReinH> No?
14:21:18 <ReinH> Every executable can be a microservice, I suppose.
14:21:48 <ReinH> and you can have multiple executables in a single package, if you want
14:22:14 <BMWPower> Oke...is there an example online? I googled on "Haskell Process"
14:22:19 <dmwit> :t listArray
14:22:21 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
14:22:25 <ReinH> I mean, you're just running an executable.
14:22:58 <ertes> int-index: one thing i like about (MaybeT m) is that it is indeed (m . Maybe), which saves me from having to convert
14:22:59 <BMWPower> ReinH: yes at the background, but then it has to listen continously
14:23:28 <ReinH> Yes, it can do that. It can read from the queue in a loop.
14:23:35 <ertes> int-index: i use it exclusively in the cases when i have a bunch of Maybe-producing actions that i need to sequence
14:23:36 <ReinH> Depending on the queue and library you choose.
14:23:55 <BMWPower> ReinH: ahh like embedded loops ;-)
14:24:09 <ReinH> it's not really different in principle from writing a TCP server
14:24:22 <ReinH> except that you select from some sort of external queue rather than a socket.
14:24:27 <BMWPower> Yes you are right!
14:24:39 <int-index> ertes, yes, I do that too. This use case doesn't require a MonadMaybe class, though
14:24:57 <int-index> so, no problem here
14:25:01 <ertes> int-index: i'm responding to your top comment on reddit
14:25:03 <ReinH> @google parallel and concurrent programming in haskell
14:25:09 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
14:25:09 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
14:25:14 <ReinH> BMWPower: this book will help you with managing threads and stuff
14:25:30 <ReinH> and includles examples that are similar enough to be directly useful
14:25:39 <ReinH> it's also free
14:26:06 <ReinH> i.e., in haskell it is common to fork a thread to handle a request, message, etc.
14:26:06 <BMWPower> THANKS!!
14:26:51 <BMWPower> Oke now I have a infra: Mobile to RabbitMQ (Que)...and Haskell (handler)
14:27:41 <BMWPower> I want to add an Triplestore (Jena) with SPARQL and Graphviz
14:28:08 <BMWPower> I want to inject triples with Haskell... I have it working (solid) in Java
14:28:54 * hackagebot hscaffold 0.4.3.0 - Very simple file/directory structure scaffolding writer monad EDSL  https://hackage.haskell.org/package/hscaffold-0.4.3.0 (yamadapc)
14:29:42 <BMWPower> Java to Haskell ;-)
14:31:45 <ongy> java to haskell? pretty sure that will be fun
14:32:21 <BMWPower> well I have a solid solution made in Java communicating with a triplestore (using an external Lib)
14:33:27 <greg> cant we just drop the let keyword in do notation?
14:33:32 <BMWPower> there is a haskell library for "reading" with SPARQL (SELECT). But not inserting in an ontology
14:36:31 <hpc> greg: imo it's a pretty important visual signal that nothing effectful is happening on that line
14:36:58 <hpc> the difference between "=" and "<-" isn't enough when the brain is trained to gloss over symbols in other languages
14:37:11 <int-e> Btw I have *not* looked at the new extensions in ghc 8.0.1 to see which may be suitable for lambdabot.
14:37:40 <hpc> int-e: just use all of them, what could possibly go wrong!
14:38:32 <ertes> i wonder if lambdabot could do appropriate isolation to run IO
14:38:44 <greg> how does it show nothing effectful is happening , do you mean in the same way other let clauses are confined to the let scope?
14:38:54 <jonored> Maybe something like tryhaskell does..
14:38:54 * hackagebot hscaffold 0.4.4.0 - Very simple file/directory structure scaffolding writer monad EDSL  https://hackage.haskell.org/package/hscaffold-0.4.4.0 (yamadapc)
14:38:58 <int-e> ertes: perhaps but I have no intention of going there.
14:39:12 <hpc> each command makes a new VM instance
14:39:20 <hpc> using xen or something ridiculous
14:39:26 <ertes> it runs separate processes anyway, so it could just as well set up the appropriate namespaces
14:39:55 <jonored> (although tryhaskell just has it's own almost-IO work-alike.)
14:40:48 <int-e> it does actually run in its own namespace, but it's meant as a safety net, not as a replacement for Haskell's type system and SafeHaskell.
14:45:05 <int-e> hmm, one more thing to test...
14:47:19 <int-e> good thing I tested, that wouldn't have worked (restarting the bot when the VM reboots)
14:48:55 * hackagebot hspec-setup 0.2.1.0 - Add an hspec test-suite in one command  https://hackage.haskell.org/package/hspec-setup-0.2.1.0 (yamadapc)
15:03:55 * hackagebot generic-random 0.3.0.0 - Generic random generators  https://hackage.haskell.org/package/generic-random-0.3.0.0 (lyxia)
15:08:30 <mniip> :t liftA5
15:08:32 <lambdabot> error:
15:08:32 <lambdabot>     • Variable not in scope: liftA5
15:08:32 <lambdabot>     • Perhaps you meant one of these:
15:08:48 <glguy> liftA1
15:08:50 <glguy> liftA2
15:09:25 <glguy> (and hopefully you didn't mean liftA1 either...)
15:15:40 <ReinH> Personally I sort of wish pure was called liftA0 and fmap wa called liftA1.
15:16:45 <hpc> :t \x y -> liftA2 id x y
15:16:46 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
15:17:15 <hpc> hmm, there's almost a really elegant pattern there
15:17:22 <ReinH> almost!
15:17:29 * hpc was envisioning liftA(n-1) = liftA(n) id
15:17:50 <hpc> :t liftA2
15:17:52 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
15:18:03 <lyxia> or just "liftN" (N <- [0 ..]), while mtl got liftT
15:18:05 <hpc> but there's no way that can work
15:20:01 <athan> ReinH: Doesn't purescript do something like this?
15:27:08 <MarLinn> why liftAn if you've got (<$>) and (<*>)?
15:27:13 <Sonolin> I love Aeson <3
15:27:33 <Sonolin> so wonderful to work with haskell's type system
15:27:39 <glguy> Well, in time you'll get to 3 or even more
15:28:00 <MarLinn> liftA3 f x y z == f <$> x <*> y <*> z
15:29:03 <athan> MarLinn: try making them point free :)
15:29:12 <athan> meta pointfree
15:29:42 <MarLinn> mhh... how do I ask lambdabot to do that again? XD
15:30:00 <ertes> MarLinn: instance (Num a) => Num (MyType a) where (+) = liftA2 (+); (-) = liftA2 (-); …
15:30:06 <athan> @pf yo dawg (i heard you like) . functions
15:30:06 <lambdabot> Maybe you meant: pl bf
15:30:26 <athan> @pl yo dawg (i heard you like) . functions --?
15:30:26 <lambdabot> yo dawg (i heard you like) . functions
15:30:30 <athan> lol
15:34:17 <MarLinn> @pl \f x y z -> f <$> x <*> y <*> z
15:34:17 <lambdabot> (. (((<*>) .) . (<*>))) . (.) . (.) . (<$>)
15:36:37 <MarLinn> @unpl (. (((<*>) .) . (<*>))) . (.) . (.) . (<$>)
15:36:37 <lambdabot> (\ x x0 x1 x2 -> x <$> ((x1 <*> x1) <*> x2))
15:36:48 <koz_> Yay for applicatives!
15:37:20 <MarLinn> word!
15:37:23 <Rarrikins> @pl \x y z -> if x then y else z
15:37:23 <lambdabot> if'
15:38:07 <Rarrikins> @hoogle if'
15:38:12 <lambdabot> Data.Bool.HT if' :: Bool -> a -> a -> a
15:38:12 <lambdabot> Diagrams.Backend.Cairo.Internal if' :: Monad m => (a -> m ()) -> Maybe a -> m ()
15:38:12 <lambdabot> Language.Javascript.JMacro.Util if' :: (ToJExpr a, ToStat b) => a -> b -> JStat
15:40:35 <athan> @hoogle bool
15:40:36 <lambdabot> Data.Bool bool :: a -> a -> Bool -> a
15:40:36 <lambdabot> Data.Aeson.Encoding bool :: Bool -> Encoding
15:40:36 <lambdabot> Data.Aeson.Encoding.Internal bool :: Bool -> Encoding
15:40:42 <athan> hu
15:43:52 <athan> Sonolin: Check this out! http://hackage.haskell.org/package/hasql-0.19.15/docs/Hasql-Decoders.html#t:Row
15:52:29 <Sonolin> Hmm interesting
15:52:53 <Sonolin> not sure I quite understand, is that a more abstract take at an Aeson-like library?
15:54:07 <Sonolin> Oh I see, Aeson for SQL? 
15:54:09 <Sonolin> Very nice :)
15:54:23 <MarLinn> I just noticed that both @pl and @unpl made errors in my queries. The unpl one is just a naming bug, the pl one... too much reliance on one specific instance of Applicative maybe?
15:55:03 <athan> MarLinn: How do you mean it made an error?
15:55:10 <athan> it doesn't look at instances at all
15:55:13 <athan> er wait
15:55:20 <mniip> @pl \x -> x
15:55:20 <lambdabot> id
15:55:28 <athan> maybe it didn't know `(<$>)` is infix?
15:55:35 <athan> @pl f <$> x
15:55:35 <lambdabot> f <$> x
15:55:52 <athan> @pl f <$> x <*> y
15:55:52 <lambdabot> f <$> x <*> y
15:55:55 <athan> :S
15:56:06 <mniip> ah yes
15:56:16 <mniip> it has issues with parsing precedences of some things
15:56:34 <mniip> @pl id <$> x <$> y
15:56:34 <lambdabot> id <$> x <$> y
15:56:57 <MarLinn> Ah, ok. I thought it might abuse the function instance or something
15:57:32 <MarLinn> In @unpl x0 is dropped on the RHS and replaced by x1. The current result doesn't even typecheck
15:57:36 <mniip> @pl \x y z -> x <$> y <*> z
15:57:36 <lambdabot> (. (<*>)) . (.) . (<$>)
15:57:41 <mniip> @pl \x y z -> (x <$> y) <*> z
15:57:41 <lambdabot> ((<*>) .) . (<$>)
15:57:53 <mniip> I'm not sure if I can provide a cleaner demonstration
16:00:07 <MarLinn> Well, I wasn't gonna use the results in production code anyway. Sorry, lambdabot. I still like you, just in a different way... 
16:02:25 <mniip> MarLinn, aww you haven't even been to a date yet
16:03:03 <athan> Has anyone here used distributed process?
16:03:29 <athan> I am considering using it with acid-state as my main database :x
16:05:31 <MarLinn> mniip: Well, you know how it is... there are things that somehow feel like a Date but don't quite typecheck... You're asking yourself if you should Text or if that would just keep Stringing someone along...
16:06:39 <mniip> Maybe
16:06:54 <mniip> Just $ do { it }
16:08:18 <MarLinn> And then, one day, you realise: It's great to be able to talk about Booleans, but when you seriously think if you would want to invite the other party to "look at my monad Stack" or the "Collection library"... it just doesn't... fire an Event Handler.
16:08:42 <Rarrikins> MarLinn: The Event Handler didn't deserve to be fired :(
16:09:18 <hpc> you just don't know design patterns
16:09:46 <hpc> you create a new event, the event calls the EventDispatcherManager singleton which picks an appropriate AbstractEventHandler using a ReflectionHelper
16:11:38 <MarLinn> That's just the thing: FRP people work differently. It's hard to get a Handle on them at all
16:11:57 <TimWolla> I'm currently trying to use Wreqs asJSON inside the Either monad. Unfortunately it does not type check (Couldn't match type JSONError with GHC.Exception.SomeException). What am I doing wrong?
16:12:00 <TimWolla> This is my code: http://lpaste.net/179622
16:12:14 <hpc> MarLinn: haha
16:12:19 <TimWolla> Using Maybe instead of Either it works just fine.
16:18:58 * hackagebot diagrams-svg 1.4.0.4 - SVG backend for diagrams drawing EDSL.  https://hackage.haskell.org/package/diagrams-svg-1.4.0.4 (BrentYorgey)
16:19:09 <MarLinn> TimWolla: I don't know any of the libraries involved, but the error seems quite obvious: asJSON returns SomeException but process wants to return a JSONError.
16:19:16 <glguy> TimWolla: If you want to use Either, you'll need  Either GHC.Exception.SomeException
16:19:20 <glguy> rather than Either JSONError
16:22:34 <glguy> and rather than importing GHC.Exception, you can import Control.Exception
16:22:48 <TimWolla> Whoops. Look's I was confused by the docs and thought SomeException was a type class. Thanks.
16:22:58 <TimWolla> *Looks like
16:23:40 <glguy> TimWolla: If it was a type class you've have gotten a different error about applying Either to a type class
16:24:20 <TimWolla> Yes, theoretically I am aware of it.
16:32:08 <dmwit> Well, that's mildly annoying. In Cabal, the version range `>=1.0 && <1.1` does not include version 1.
16:32:43 <hpc> yeah, apparently 1 /= 1.0
16:32:55 <chsn> am I better off using monads-tf or mtl ?
16:33:05 <merijn> chsn: mtl
16:33:08 <chsn> I need Control.Monad and stack is telling me to use one of them
16:33:12 <glguy> Yeah, 1 < 1.0. It'd be *ridiculous* if it match >= 1.0 ;-)
16:33:15 <merijn> chsn: wut
16:33:23 <merijn> chsn: Control.Monad shouldn't not be in either of those
16:33:33 <merijn> eh
16:33:38 <merijn> Ignore the double negative :p
16:33:41 <merijn> It's late :)
16:33:51 <dmwit> I mean, I understand why 1 < 1.0. And also it's mildly surprising and annoying.
16:34:10 <glguy> Yeah, hvr scolded me for utf8-string-1 
16:34:29 <glguy> even worse is that you can't write: 1.0.* to match that
16:34:53 <hpc> moral of the story is always use all four version sub-numbers
16:34:58 <hpc> or something
16:35:07 <dmwit> hm =)
16:39:29 <Sgeo_> In Haskell, are there functions that return an empty type/bottom type?
16:39:42 <Sgeo_> Does undefined count as doing that?
16:39:56 <dmwit> id :: Void -> Void
16:39:57 <Rarrikins> Sgeo_: Yes. That's bottom.
16:40:14 <Rarrikins> Sgeo_: Though I'm not sure whether it's bottom type.
16:41:18 <Sgeo_> I guess in Haskell you can have a value of an empty type in scope?
16:41:19 <shachaf> There is no empty type in Haskell.
16:41:25 <Sgeo_> data Foo; isn't empty?
16:41:37 <shachaf> No, it has _|_ as an inhabitant.
16:41:40 <mmaruseacph2> f :: Foo, f = undefined
16:42:59 <Sgeo_> shachaf, I'm trying to see if Rust's model makes sense (where a -> Never where Never is an empty type is a thing that can be written)
16:45:04 <MarLinn> Sgeo_: Isn't an empty type different from a bottom type?
16:45:28 <Sgeo_> MarLinn, you're probably right, I meant empty type
16:47:01 <glguy> Sgeo_: A better comparison might be: forever :: Applicative f => f a -> f b
16:48:22 <glguy> when comparing to Rust's a -> Never
16:49:04 <dmwit> Using an empty type seems a pretty good model, too.
16:49:51 <glguy> The distinction I'm making is that a fucntion in Rust -> Never can still "do stuff"
16:50:10 <dmwit> right
16:59:56 <mniip> 1471909257 [02:40:57] <shachaf> There is no empty type in Haskell.
17:00:04 <mniip> State# ()
17:00:50 <koz_> I want to define an Arbitrary instance for something that needs a list of Maybe Bools with at least one Just somewhere in it. What would be the easiest way to write this?
17:01:33 <shachaf> That's hardly Haskell.
17:02:27 <Koterpillar> data Never = Never Never
17:03:07 <mniip> Koterpillar, fix Never
17:03:08 <aarvar> koz_: why not represent that invariant in a type: (a, Nat, [Maybe a])
17:03:26 <aarvar> with  the a being the Just value, and the Nat being its position
17:04:39 <dmj`> koz_: instance Arbitrary Thing where arbitrary = do x :: Bool <- arbitrary; xs :: [Maybe Bool] <- arbitrary; pure $ Just x : xs
17:04:39 <koz_> aarvar: That's actually pretty neat - thanks!
17:04:54 <aarvar> koz_: except wait, that isn't quite right
17:05:06 <mmaruseacph2> aarvar: that's has exactly one Just, not at least one
17:05:08 <aarvar> the Nat needs to be less than the length of the list
17:05:09 <mmaruseacph2> lag :(
17:05:11 <koz_> dmj`: That means that only a subset of possible valid values are generated. aarvar: I think I get the gist.
17:05:17 <aarvar> mmaruseacph2: no, it has at least one
17:05:43 <mmaruseacph2> oh, the others are in the list?
17:05:48 <aarvar> right
17:05:56 <mmaruseacph2> cool.io
17:06:03 <dmj`> koz_: only a subset?
17:06:45 <dmj`> koz_: it guarantees at least one Just is in there, as you asked for
17:07:09 <Koterpillar> why not post-filter?
17:10:42 <dmwit> dmj`: But it will never generate e.g. [Nothing, Just False].
17:11:02 <dmwit> dmj`: So there's a large chunk of values one might like to have positive probability which have probability 0.
17:11:52 <dmwit> koz_: How about `arbitrary = liftA3 (\x y z -> x ++ y ++ z) arbitrary ((\x -> [Just x]) <$> arbitrary) arbitrary`?
17:11:53 <Koterpillar> xs1 :: [Maybe Bool] <- arbitrary; x :: Bool <- arbitrary; xs2 :: [Maybe Bool] <- arbitrary; pure $ xs1 ++ [x] ++ xs2
17:12:27 <dmwit> Or yes, fold the fmap into the first `liftA3` as Koterpillar did: `liftA3 (\x y z -> x ++ [Just y] ++ z) arbitrary arbitrary arbitrary`.
17:12:42 <Koterpillar> yes, that's the same thing dmwit suggested
17:20:42 <dfeuer> Ping Cale.
17:37:53 <libman> I'm writing a little tool (not in Haskell) that compares the license statistics for various programming language ecosystems.  I notice that Cabal has a very big tar file of ".cabal" files.  Are there by any chance any shortcuts for getting this info?
17:38:43 <Koterpillar> libman: https://github.com/commercialhaskell/all-cabal-files ?
17:38:54 <dmwit> https://github.com/barrucadu/cabal-info
17:39:19 <dmwit> `cabal-info license` seems more or less like what you want
17:40:09 <libman> Is there a cabal command line that lists each package and license that I can parse?
17:40:46 <dmwit> There's also `cabal info`, of course.
17:40:47 <libman> (Sorry, my knowledge level of Haskell is ZERO.)
17:41:22 <libman> Is there by any chance command like arguments to have cabal dump package name and license is a more compact format?
17:41:39 <Koterpillar> libman: maybe https://hackage.haskell.org/api#package-contents?
17:41:39 <dmwit> And there's even `cabal search *`.
17:41:53 <dmwit> libman: So that's now three ways I've suggested, once for each time you've asked the question. ;-)
17:43:10 <libman> Unless the Web API can provide aggregate information (X total packages for each license), it would be slower than parsing `cabal info` output...
17:44:09 <libman> Does Cabal take like a format string or a list of columns to return?
17:44:21 <dmwit> libman: Are you ignoring me?
17:44:50 <libman> dmwit: no, I saw all of your suggestions, I'm just wondering if there's a more efficient way to do this...
17:45:58 <koz_> If I'm writing a QuickCheck test, what should I call in main to have the test outcomes display properly in a 'cabal test' run? I've written 'main = quickCheckWith stdArgs fooProp', but this always prints a test success, but the log says it failed.
17:46:29 <libman> OK, thank you.
17:47:04 <dmwit> `cabal search * | grep license` is lightning fast on my machine. What do you mean by "efficient"?
17:47:53 <dmwit> Sorry, I meant `cabal list * | grep '^    License: '`.
17:48:08 <ClaudiusMaximus> koz_: main = do { r <- quickCheckBlah ... ; unless r exitFailure }
17:49:27 <ClaudiusMaximus> koz_: System.Exit.exitFailure, Control.Monad.unless - assuming test suite of type exitcode-stdio-1.0
17:49:40 <koz_> ClaudiusMaximus: OK, thanks!
17:50:35 <libman> Some other package managers use JSON, SQLite, etc.  So I was wondering if there's a faster way than parsing `cabal list` output.  If there isn't, that's OK.
17:51:05 <koz_> ClaudiusMaximus: It doesn't like the r there, as quickCheckWith returns ().
17:51:21 <koz_> Should I change to the one that returns IO Result instead?
17:52:05 <ClaudiusMaximus> koz_: hmm, possibly - i'm using the template haskell $quickCheckAll
17:52:15 <mniip> doesn't 'type family Foo a = b | b -> a' let me derive a ~ b from Foo a ~ Foo b?
17:52:15 <Koterpillar> koz_: yes, looks like that's what you need, and then isSuccess
17:53:00 <dmwit> libman: Getting just the license field from `cabal list` takes less than a second on my machine. Is that really too slow for you?
17:53:26 <koz_> Koterpillar: Thanks!
17:53:30 <libman> No problem.  Thank you.
17:54:52 <ertes> there are also hackage tags
17:54:56 <ertes> https://hackage.haskell.org/packages/tag/bsd3
17:55:09 <ertes> "6191 packages have this tag."
18:11:00 <tippenein> What am I looking for if I want to be able to do t - 1 where data Time = Time { h :: Int, m :: Int, s :: Int }
18:11:08 <tippenein> basically wanna do math on a time object
18:11:45 <Koterpillar> tippenein: Data.Time.Clock?
18:11:57 <Koterpillar> tippenein: does t - 1 mean hour, minute or second?
18:12:22 <tippenein> say t = T 0 20 30
18:12:33 <tippenein> t - 1 should be T 0 20 29
18:12:41 <Koterpillar> tippenein: please please don't reimplement time
18:13:00 <Koterpillar> tippenein: http://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time
18:13:17 <tippenein> thanks, I've read that. That's not what this is about
18:13:26 <Koterpillar> tippenein: Data.Time.Clock still can do what you ask for
18:19:43 <ertes> that looks more like something Data.Time.LocalTime can do
18:19:53 <Koterpillar> yes
18:20:10 <jchia> I'm using makeFields (from lens) to access record fields. Can this be written more clearly or more succintly?
18:20:19 <jchia> (||) <$> (> "15:00:00") <*> Data.Text.null $ myRecord ^. myField
18:20:42 <jchia> i'm checking that the field is > "15:00:00" or empty
18:21:14 <jchia> of course i could do let mf = myRecord ^. myField in ..., but I'm wondering if there's a concise way to express this in lense
18:21:40 <Koterpillar> jchia: I feel like that will be actually understandable
18:22:16 <Koterpillar> let test x = x > "15:00:00" || T.null x in myRecord ^. myField . to test
18:25:29 <sm> hello tippenein
18:25:38 <jchia> is there a way to get the benefits of RecordWildcard while using lens to access fields so that I don't have to do ^. for every field access?
18:25:43 <sm> to break it down a bit more, since it's not obvious..
18:26:07 <jchia> with RecordWildcard, I can just use MyRecord{..} and use the fields by name directly
18:26:30 <jchia> RecordWildcards
18:26:31 <sm> with Data.Time.Clock's UTCTime, you can eg addUTCTime (-1) to it
18:27:10 <sm> eg import Data.Time.Clock, t <- getCurrentTime, formatTime defaultTimeLocale rfc822DateFormat t, formatTime defaultTimeLocale rfc822DateFormat $ addUTCTime 1 t
18:27:58 <sm> Data.Time.LocalTime is more like the type you described, but I'm not sure how to do time arithmetic on it
18:29:00 <Koterpillar> when you use either of them, you're forced to think about what it is that you're adding, and whether you want to support leap seconds and all of thata
18:30:04 <sm> my example ignores leap seconds (since it infers a NominalDiffTime)
18:31:49 <sm> but I think it's the most generally correct way of doing time arithmetic you'll find in the libs
18:32:21 <sm> unless thyme does it better
18:34:03 <sm> doesn't look like it 
18:39:03 * hackagebot diagrams-canvas 1.3.0.7 - HTML5 canvas backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-canvas-1.3.0.7 (BrentYorgey)
18:49:04 * hackagebot diagrams-cairo 1.3.1.2 - Cairo backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-cairo-1.3.1.2 (BrentYorgey)
18:56:19 <jchia> If i have a tuple, how do I concisely express a lens for getting the sum of the _1 and the _2? This does not work but captures what I want to accomplish: (1, 2, 3) ^. ((+) <$> _1 <*> _2)
18:57:36 <jchia> i want to get back 3 (1 + 2)
18:57:56 <MarLinn>  uncurry (+)
18:58:05 <MarLinn> no lens necessary ;)
18:58:19 <Koterpillar> :t _1
18:58:21 <lambdabot> (Field1 s t a b, Functor f) => (a -> f b) -> s -> f t
18:58:31 <Koterpillar> MarLinn: only works on 2-tuples
18:58:45 <jchia> MarLinn: I'm in a situation where i have to access things with lens (using makeFields). _1 and _2 are just to simplify the explanation.
19:00:04 <aarvar> > liftA2 (+) (^. _1) (^. _2) (1, 2)
19:00:06 <lambdabot>  3
19:00:09 <aarvar> would work
19:01:19 <glguy> jchia: Just   view _1 x + view _2 x
19:01:54 <glguy> If there's some common prefix, you can: let x = view commonPart y in view _1 x + view _2 y
19:01:55 <jchia> glguy: OK. But if the "_1" and "_2" are deep then it's a long expression.
19:02:29 <aarvar> jchia: how so?
19:02:56 <jchia> if it's not a tuple but two things deep in a nested record, e.g. fieldA . fieldB . fieldC and fieldA . fieldB . fieldD, and i want to add them
19:03:20 <glguy> jchia: Yeah, so name the lookup of fieldA . fieldB
19:03:27 <glguy> and then find the sum of C and D
19:03:36 <jchia> OK
19:04:03 <dfeuer> Hey, anyone here want to help me with a bit of typeclass design? One corner of my hierarchy is a bit muddy.
19:05:15 <jchia> thanks
19:06:50 <glguy> Now that we've covered what you should do to write clear code...
19:07:10 <glguy> > sumOf (_1 . (_1 <> _2)) ( (10,20) , 'a' )
19:07:13 <lambdabot>  30
19:08:33 <dfeuer> MarLinn++
19:09:57 <MarLinn> dfeuer?
19:10:13 <jchia> Actually, i would like to do let fieldB = theRecord ^. fieldB in ..., if not for the shadowing. What are some things that people do to deal with the shadowing? Do they follow some naming convention, e.g. let theFieldB = therecord ^. fieldB in ...?
19:10:43 <aarvar> jchia: does it matter what you name it?
19:11:19 <jchia> aarvar: I would like a convention for this usage pattern so that i can tell clearly what's going on
19:11:39 <jchia> wild wildcardrecords, i don't have to worry about naming, the names are the same
19:11:52 <jchia> with wildcardrecords, i don't have to worry about naming, the names are the same
19:12:05 <peddie> jchia: you could also look into `makeClassy`
19:14:23 <jchia> peddie: OK, I'm going to figure out the difference between makeDefaults and makeClassy
19:19:05 * hackagebot hashabler 1.3.0 - Principled, portable & extensible hashing of data and types, including an implementation of the FNV-1a and SipHash algorithms.  https://hackage.haskell.org/package/hashabler-1.3.0 (BrandonSimmons)
19:52:32 <koz_> What's the easiest way to get [(a, b)] -> ([a], [b])?
19:52:42 <glguy> unzip
19:52:49 <koz_> glguy: .... I feel retarded now. Thanks.
19:56:57 <mniip> :t map fst &&& map snd
19:56:58 <lambdabot> [(b, b1)] -> ([b], [b1])
19:59:32 <mniip> :t traverse (first pure)
19:59:34 <lambdabot> (Monoid (f b1), Traversable t, Applicative f) => t (b1, b) -> (f b1, t b)
20:00:42 <mniip> which reminds me
20:01:34 <mniip> why are TypeFamilyDependencies so weak
20:02:05 <mniip> isn't "type family Foo a = b | b -> a" supposed to mean (Foo a ~ Foo b) :- (a ~ b)
20:07:59 <HallaSurvivor> so, I want to get into dependent types... Does anybody know what the broad differences are between agda and idris?
20:11:10 <Squarism> theres no "bind" version of "lift"? 
20:11:35 <Squarism> that lets me create a new "container" so to speak?
20:12:05 <jle`> Squarism: what is the type of the thing you are thinking of?
20:12:08 <glguy> HallaSurvivor: That'd be a good question for #agda and #idris
20:13:27 <HallaSurvivor> I'm currently in #idris, I was going to hit up #agda next. I figured I'd ask here because I know this community better and I expected some overlap. Plus, I'll get (somewhat) biased remarks from either of those channels
20:14:02 <Welkin> HallaSurvivor: agda seems more formal and for academic use
20:14:03 <Squarism> jle`, liftBind :: ((a-> b -> c) -> m b) -> m a -> m b -> m c
20:14:09 <Welkin> idris is meant as a haskell successor
20:14:14 <Squarism> ops
20:14:17 <Squarism> sorry wrong
20:14:19 <Welkin> afaik
20:14:48 <HallaSurvivor> yeah, I seem to be getting the idea that agda is for proofs (primarily) while idris has programming at the forefront
20:14:50 <Squarism> jle`, liftBind :: (a -> b -> m c) -> m a -> m b -> m c
20:14:53 <glguy> HallaSurvivor: That makes sense, but that question is offtopic in #haskell
20:15:00 <glguy> you guys can go to #idris to discuss it, though
20:15:09 <jle`> Squarism: ah yeah, i think it's mostly that it's not commonly used enough to be worth giving a name for
20:15:10 <HallaSurvivor> glguy, fair point :)
20:15:23 <jle`> Squarism: fairnbain threshold or something like that
20:15:34 <jle`> usually do notation or an extra join is clean enough
20:15:46 <Squarism> oh ok
20:15:57 <codygman> Is there a way to tell if two types can be compared on the type level? I'm guessing I could define some typeclasses to do this. Is there an easier way?
20:16:01 <MarLinn> Squarism: that looks almost like liftM2
20:16:02 <Squarism> yeah.. doing to much at once can be complicated
20:16:16 <jle`> i feel like things like this is what do notation was invented for, anyway
20:16:28 <jle`> but some people also like join (f <$> x <*> y)
20:16:58 <Welkin> Squarism: composing simpl functions into a pipeline to make more complex ones is one of the coolest things about haskell
20:17:11 <Welkin> not creating specialized overly-complex functions
20:17:29 <Squarism> yeah, im starting to see that
20:19:07 * hackagebot inchworm 1.0.2.1 - Inchworm Lexer Framework  https://hackage.haskell.org/package/inchworm-1.0.2.1 (BenLippmeier)
20:19:22 <glguy> mniip: That would have seemed like a reasonable assumption
20:19:34 <mniip> glguy, well
20:19:36 <mniip> if only
20:23:16 <mniip> I don't think you can get that coercion in honest ways
20:23:24 <mniip> with the current typechecker at least
20:23:29 <MarLinn> codygman: if you mean if there's a type level equality test, yes, there is. The squiggle in things like f :: (IsSet s, Elem s ~ e) => s -> e
20:23:54 <glguy> mniip: they seem like they are about as weak as fundeps
20:24:05 <codygman> MarLinn: Ah that's it, I knew I'd seen that before!
20:24:12 <mniip> well
20:24:20 <mniip> it all comes down to skolems being ununifiable
20:29:59 <mniip> @where L.hs
20:29:59 <lambdabot> what lambdabot has in scope is at http://silicon.int-e.eu/lambdabot/State/Pristine.hs
20:37:56 <ReinH_> Ugh those skolems
20:38:19 <ReinH_> Really aren't team players
20:38:38 <akison> http://pornhublive.com/cam/UrSweetAangel/?AFNO=1-0-595728-338243&stno=2-630-829-3050-0-0-2073-2055
20:38:50 <ReinH_> @where ops
20:38:50 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
20:39:08 * hackagebot optparse-generic 1.1.3 - Auto-generate a command-line parser for your datatype  https://hackage.haskell.org/package/optparse-generic-1.1.3 (GabrielGonzalez)
20:39:10 <Squarism> akison, looks safe for work
20:39:25 --- mode: ChanServ set +o edwardk
20:39:34 --- kick: akison was kicked by edwardk (akison)
20:39:35 --- mode: edwardk set +b akison!*@*
20:39:41 <ReinH_> Thanks
20:39:43 --- mode: edwardk set -o edwardk
20:40:03 <mniip> edwardk: !
20:40:07 <Squarism> Say type S = ([a],[b]). how can i write a simple S -> S -> S that concatenates both?
20:40:22 <edwardk> Squarism: 'mappend' =)
20:40:25 <mniip> edwardk, I figured out the Dict coercion issue
20:40:30 <mniip> !
20:40:41 <edwardk> mniip: i forget the issue
20:40:59 <mniip> coercing between * and Constraint
20:41:03 <edwardk> oh that
20:41:08 <mniip> you said the two are largely incompatible
20:41:21 <mniip> actually it's the ghci <-> compiled code link that is broken
20:41:22 <mniip> https://ghc.haskell.org/trac/ghc/ticket/12523
20:41:29 <Squarism> edwardk, hmm.. so tuples are monoids? 
20:41:36 <pavonia> > ("foo", [1,2,3]) <> ("bar", [4,5,6])
20:41:38 <lambdabot>  ("foobar",[1,2,3,4,5,6])
20:42:00 <edwardk> Squarism: instance (Monoid a, Monoid b) => Monoid (a,b)
20:42:03 <ReinH_> Squarism: products of monoids are monoids
20:42:05 <Cale> Squarism: The types they belong to are monoids
20:42:10 <Squarism> how cool
20:42:18 <edwardk> [x] is a monoid, so you can borrow the instances all the way down
20:42:21 <ReinH_> This is generally pretty useful.
20:42:29 <edwardk> hence 'mappend' is the function you want here right out of the box
20:42:57 <ReinH_> You can fold over the product of counting and summing to get an average
20:42:59 <edwardk> mniip: yes, but notice that the core generated relies on them being evaluated and tagged
20:43:11 <edwardk> which is the hazardous part
20:43:14 <mniip> edwardk, it does that for all constructors
20:43:41 <ReinH_> And this averaging method also minimizes floating point errors and works in a streaming context
20:43:43 <edwardk> you can enter an unknown constructor sans tag
20:43:53 <edwardk> which is why what ghci does is sound
20:44:04 <mniip> and the runtime will return you that same constructor with its tag
20:44:09 <edwardk> yes
20:44:17 <Cale> Squarism: Another cool one is that  data Ordering = LT | EQ | GT  used to mark the results of comparisons, is a monoid, where LT <> y = LT and GT <> y = GT, but EQ <> y = y, i.e. take the result of the first comparison if it's LT or GT, but use the second comparison if the first gives EQ
20:44:20 <mniip> typeclass methods do no different
20:44:28 <mniip> they enter the dictionary and assume that the result is tagged
20:44:31 <edwardk> assuming you don't have too many constructors for that to work
20:44:37 <Squarism> Cale, i think you taught me that earlier
20:44:39 <ReinH_> Cale: that one is my favorite actually
20:44:45 <Cale> Squarism: Together with the fact that (e -> m) is a monoid whenever m is, you have that comparison functions of type e -> e -> Ordering are a monoid
20:44:49 <mniip> edwardk, if there's more than 7 the tag is always '1'
20:45:05 <edwardk> *nods*
20:45:11 <Cale> > sortBy (comparing length <> compare) (words "here is a bunch of words to sort first by length and then alphabetically")
20:45:13 <lambdabot>  ["a","by","is","of","to","and","here","sort","then","bunch","first","words",...
20:45:15 <edwardk> i think we're saying the same thing in slightly different language
20:45:48 <Cale> (not the most efficient way to do that, but certainly cute)
20:46:22 <koz_> Is there something similar to the IntSet in containers, but for Integer keys rather than Int ones? Or should I just accept the inevitable and use Data.Set.Set?
20:47:04 <ReinH_> No, Integer isn't really amenable to that treatment
20:47:38 <koz_> ReinH_: I had the feeling...
20:48:09 --- mode: ChanServ set +o glguy
20:48:09 --- mode: glguy set +b-bo *!*@89-172-145-238.adsl.net.t-com.hr akison!*@* glguy
20:48:55 <edwardk> glguy: thanks for shoring that up
20:58:20 <koz_> If I have [(Int, Int)], and I wanna know if every second element of each tuple is the same, what's the best way to write it?
20:58:56 <alercah> all p $ map snd $ l
21:00:17 <suzu> i'm trying to inspect WHNF in ghci and i'm either doing something wrong or it's borked. let z = [1,2,3,4]; length z; :sprint z; prints out 'z = _' for the sprint but i'm expecting 'z = [_,_,_,_]'. am i doing something wrong?
21:00:29 <koz_> alercah: What is 'p' in this context?
21:00:35 <suzu> this is ghci 8.0.1
21:00:35 <alercah> koz_: a predicate
21:01:03 <koz_> alercah: Yeah - how do I write a predicate which will determine if every second element of every tuple in that list is identical?
21:01:13 <alercah> you don't
21:01:19 <alercah> :t map
21:01:20 <lambdabot> (a -> b) -> [a] -> [b]
21:01:21 <alercah> :t snd
21:01:22 <lambdabot> (a, b) -> b
21:01:27 <koz_> My only thoughts right now involve taking a list head and then comparing to the relevant second part of that.
21:01:31 <alercah> :t all
21:01:34 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
21:01:48 <Welkin> wtf are those all robots?
21:02:50 <Koterpillar> :t map head . chunksOf 2 -- koz_
21:02:52 <lambdabot> [b] -> [b]
21:02:58 <alercah> you could also use allSame/allEqual which exist in a number of utility packages
21:03:17 <alercah> Koterpillar: eh? that doesn't help at all
21:03:27 <alercah> Koterpillar: it's a list of tuples
21:03:27 <Koterpillar> alercah: it helps with the first part
21:03:31 <MarLinn> koz_: how about allEqual ((_,x):xs) = all (==x) $ map snd xs
21:03:37 <Koterpillar> oooh, sorry
21:03:44 --- mode: ChanServ set +o glguy
21:03:45 --- mode: glguy set -bbbb ghostlight!*@*$##fix_your_connection san4!*@*$##fixyourconnection stuntaneous!*@*$##fixyourconnection quetzakubica1!*@*$##fix_your_connection
21:04:09 * hackagebot github-backup 1.20160922 - backs up everything github knows about a repository, to the repository  https://hackage.haskell.org/package/github-backup-1.20160922 (JoeyHess)
21:06:45 <lpaste> tippenein pasted “print vs putStr . show” at http://lpaste.net/179652
21:07:19 <glguy> tippenein: print = putStrLn . show
21:07:31 <glguy> with line buffering you'll see the line that way
21:08:48 <koz_> MarLinn, Koterpillar and alercah: Never mind, found a way to do it.
21:08:55 <koz_> http://hackage.haskell.org/package/utility-ht-0.0.11/docs/src/Data-List-HT-Private.html#allEqual <-- this here
21:08:57 <glguy> and line buffering is the default for stdout in a ghc compiled executable
21:09:16 <tippenein> @glguy so I'd have to do line buffering with putStr . show ?
21:09:16 <lambdabot> Unknown command, try @list
21:09:46 <glguy> tippenein: @ is for bot comands; if you don't want the newline but you want immediate output, you can 1) use hFlush 2) set buffering to NoBuffering with hSetBuffering
21:09:51 <Welkin> you can set it using hSetBuffering
21:10:50 --- mode: glguy set -o glguy
21:14:12 <tippenein> that worked perfect, thanks
21:15:42 <Squarism> if i create a type : data (SomeClass a ) => MyType a = Const1 a | Const2 SomeType ... How can i use MyType in another data type wo restating that type bound (and possibly that its parameterized at all?
21:16:22 <Welkin> putting restrictions on your data is discouraged
21:17:01 <glguy> Squarism: It's not necessarily a good idea, but it looks like you're trying to do: data MyTime = forall a. SomeClass a => Const1 a | Const2 SomeType
21:17:09 <glguy> which requires the ExistentialQuantification extension
21:17:47 <MarLinn> ...in which case you could just as well step up to GADTs
21:17:50 <Squarism> is that discouraged also? 
21:18:05 <Squarism> ExistentialQuantification
21:18:30 <aarvar> Squarism: depends on how you're using it
21:19:09 * hackagebot result 0.2.2.0 - Encode success or at least one error  https://hackage.haskell.org/package/result-0.2.2.0 (srijs)
21:19:11 * hackagebot quickcheck-arbitrary-adt 0.2.0.0 - Generic typeclasses for generating arbitrary ADTs  https://hackage.haskell.org/package/quickcheck-arbitrary-adt-0.2.0.0 (mchaver)
21:28:29 <mniip> edwardk, I just "fixed" the bug and look
21:28:31 <mniip> *Main> given (BoundedDict 'a' 'z') minBound :: Char
21:28:31 <mniip> 'a'
21:28:34 <mniip> huzzah
21:31:07 <EvanR> Squarism: for stuff like this i try not to use classes, instead bundle the operations in a record type and put that in your bigger type
21:32:15 <EvanR> in any case you wont know which is more inconvenient without trying both ways
21:42:44 <dfeuer> mniip, what were we talking about before? And why are you touching that horrifying Given thing?
21:43:16 <mniip> Given?
21:43:55 <dfeuer> mniip, oh, sorry, maybe I misread. I thought you were talking about Given from reflection.
21:44:08 <dfeuer> But yeah, what'd you figure out about the indexed MonadFix?
21:44:26 <mniip> no, it's even better than reflection :D
21:44:38 <mniip> given :: DictRep c -> (c => a) -> a
21:49:10 * hackagebot diagrams-pgf 0.1.0.5 - PGF backend for diagrams drawing EDSL.  https://hackage.haskell.org/package/diagrams-pgf-0.1.0.5 (BrentYorgey)
21:49:12 * hackagebot casr-logbook 0.1.3 - CASR 61.345 Pilot Personal Logbook  https://hackage.haskell.org/package/casr-logbook-0.1.3 (TonyMorris)
21:49:44 <dfeuer> mniip, eh? How's that better than reflection? Is DictRep different from the Dict type in the constraints package?
21:50:09 <mniip> yes
21:50:10 <dfeuer> Also, what'd you work out about indexed MonadFix?
21:50:31 <mniip> data family DictRep :: Constraint -> *
21:50:37 <mniip> data instance DictRep (Bounded a) = BoundedDict { cminBound :: a, cmaxBound :: a }
21:51:34 <Squarism> EvanR, i see your point. In this case i wanted some be able to be specific about the type parameter in some cases. And to be able to do that i had to create 1 extra level of data types to achive the same thing
21:51:44 <dfeuer> mniip, so do you have to get all the fields *in the right order*?
21:52:12 <dfeuer> If so, that sounds horrible.
21:52:34 <dfeuer> Or am I missing something?
21:52:52 <glguy> I'm sure mniip would have settled for terrifying :)
21:53:08 <dfeuer> That *is*!
21:54:15 <dfeuer> I mean, that's the sort of thing that could be lovely if it were wired into GHC, but I don't think there's a non-terrifying way for a library to offer it.
21:54:36 <dfeuer> Maybe could be lovely.
21:54:49 <dfeuer> Eh... would need some work.
21:55:08 <dfeuer> I like the reflection phantom better.
21:55:35 <dfeuer> Anyway, mniip, are you just teasing me about the MonadFix thing, or will you spill those beans?
21:56:37 <EvanR> Squarism: if all you want is a type parameter, you can add those anywhere and just not use them. i.e. phantom types
21:56:56 <Squarism> oh ok
21:57:13 <EvanR> so if you use records to allow customizing functionality, you can also add type parameters that do nothing
21:58:51 <lpaste> mniip pasted “DictRep” at http://lpaste.net/179663
22:00:07 <mniip> not only it is imporatant to preserve method order
22:00:14 <mniip> but also to iclude any hidden methods
22:00:18 <mniip> and superclass constraints
22:00:29 <dfeuer> Yes, it's horrible.
22:00:30 <Squarism> EvanR, Ok.. found some haskell wiki article about. Ill read that
22:00:30 <mniip> and if there's only one field total you make it a newtype
22:00:40 <mniip> oh and
22:00:41 <dfeuer> Get that away from me.
22:00:49 <mniip> you'll need this ghci patch http://lpaste.net/179653
22:00:52 <dfeuer> o.O
22:01:18 <dfeuer> What's that patch do?
22:01:38 <mniip> it's my WIP fix for https://ghc.haskell.org/trac/ghc/ticket/12523
22:02:09 <Squarism> i really prefer the guard construct over if-else. The work well for definitions of values, but can they be used in an expression alone? 
22:02:10 <mniip> anyway
22:02:18 <Squarism> They
22:02:18 <mniip> I really better go to sleep right now
22:02:25 <mniip> sorry for teasing you about ixmonad
22:02:37 <geekosaur> so everyone else gets to have the nightmares :)
22:02:55 <dfeuer> mniip, um ... so ... why not tell me?
22:03:19 <dfeuer> *sigh*
22:04:02 <nshepperd> don't forget - it kills instance coherency
22:04:16 <nshepperd> you're a monster mniip :)
22:04:36 <dfeuer> geekosaur, I would actually like to see GHC offer a primop to help implement reflection. Currently, reflection doesn't get any inlining, which I think has to do with where GHC puts a certain type lambda.
22:05:10 <dfeuer> I'd love to see that fixed. I have a library hack that *seems* to work, but it's pretty dangerous-looking.
22:05:28 <dfeuer> It'd be better done in the compiler.
22:05:50 <mniip> nshepperd, many new things were learned that day
22:05:59 <geekosaur> of course, now that you have a new benchmark for dangerous-looking...
22:07:08 <dfeuer> geekosaur, I can say that my *intentions*, unlike mniip's, are honorable.
22:07:47 <dfeuer> It may even be safe, but I don't know how to convince myself of that.
22:09:47 <EvanR> haskell: a purely honorable programming language with non strict semantics
22:11:42 <dfeuer> @remember EvanR haskell: a purely honorable programming language with non strict semantics
22:11:42 <lambdabot> Nice!
22:19:11 * hackagebot lol-calculus 1.20160822 - Calculus for LOL ( language).  https://hackage.haskell.org/package/lol-calculus-1.20160822 (julm)
22:19:13 * hackagebot lol-typing 1.20160822 - Type inferencer for LOL ( language)  https://hackage.haskell.org/package/lol-typing-1.20160822 (julm)
22:20:48 <Koterpillar> yay broken utf-8
22:23:56 <Squarism> ok.. so its impossible to use guards in expressions alone?
22:25:03 <koz_> What's the recommended bitvector/bit twiddling lib/set of libs?
22:25:36 <liste> Squarism: you mean like (x a b | a > 0) ?
22:25:37 <glguy> Squarism: Guards are associated with a declaration
22:26:42 <Squarism> list i meant like "return (| x > 0 = 1 ; | otherwise = 2 )"
22:27:03 <glguy> Squarism: No, that doesn't make sense, but you can get close with the MultiWayIf extension
22:27:14 <glguy> return (if | x > 0 = 1 | otherwise = 2)
22:27:25 <Koterpillar> Squarism: return v where v | x > 0 = ...
22:27:25 <Squarism> nice
22:28:22 <liste> there's also https://www.schoolofhaskell.com/user/PthariensFlame/guide-to-ghc-extensions/basic-syntax-extensions#multiwayif
22:57:45 <glguy> Koterpillar: http://hub.darcs.net/simon/rss2irc/browse/Irc.hs#178
22:58:35 <Koterpillar> glguy: ?
22:58:41 <Koterpillar> ah
22:58:50 <EvanR> hubs darc
22:58:58 <EvanR> someone turn that damn light on
22:59:37 <glguy> sm: You already depend on utf8-string, that might be a good line to use it on
23:11:40 <seafood> Is Data.Lens.Light a good library?
23:11:47 <seafood> Or should I just use the regular lens library? 
23:11:54 <seafood> Or should I use another light lens library?
23:13:44 <ertes> koz_: if you're going for maximum efficiency, use the vector library, ideally with unboxed Vector Word
23:14:20 <srhb> seafood: This is difficult to answer without knowing your criteria for choosing one over the other.
23:14:45 <seafood> srhb: Don’t want too many dependencies. Just want very basic lens functionality (getters and setters)
23:15:00 <srhb> seafood: Data.Lens.Light has very light dependencies, yes.
23:15:14 <seafood> srhb: Is it useful enough though?
23:15:27 <srhb> seafood: Only you can answer that. :)
23:15:51 <srhb> seafood: If all you need is what you mentioned, it sounds probable.
23:16:04 <seafood> Cool.
23:16:26 <ertes> koz_: Vector Bool uses a whole byte per bit, so don't use that one…  if you don't want to do the shifting/masking yourself, the old 'array' library has a sane implementation of UArray Int Bool
23:17:20 <ertes> koz_: and the corresponding STUArray as well, which you'll probably need
23:18:30 <ertes> koz_: there are a few libraries on hackage that attempt to fix bit vectors, but as far as i've seen they are consistently terrible
23:20:03 <ertes> seafood: i'd go with microlens instead of data-lens-light
23:20:21 <seafood> ertes: Thanks. Wasn’t aware of that library
23:20:26 <ertes> seafood: reason: though you want minimal dependencies, you probably still want van laarhoven lenses
23:20:41 <seafood> Who is van Laarhoven?
23:20:50 <ertes> data-lens-light gives you the more traditional getter/setter lenses
23:21:03 <ertes> twan van laarhoven came up with modern CPS-based lenses
23:21:18 <ertes> http://twanvl.nl/
23:22:32 <koz_> ertes: OK. Why are they consistently terrible?
23:23:23 <ongy> what's the best way to make a storable instance for an enum taken from a C api?
23:23:45 <ongy> or even making the type automatic from some enum
23:23:47 <ertes> koz_: manual shifting/masking gave me 1/5th CPU time
23:26:03 <ertes> koz_: unboxed MVector Word gave me the best performance, on a few occasions even outperforming equivalent C code with GCC and clang
23:27:01 <ertes> koz_: STUArray s Int Bool has similar performance, slightly slower
23:29:03 <ertes> if you want to go further: the former can provide huge performance benefits, if you can do bulk operations on individual words, while STUArray will insist on redoing the arithmetic for every bit access
23:34:15 <maerwald> wow, these redundant constraint warnings are annoying
23:40:56 <Cale> maerwald: Annoying, but nice information to know quite often.
23:41:07 <maerwald> mostly wrong for what I've seen so far
23:41:12 <Cale> Oh?
23:41:21 <maerwald> yeah, it cannot know about API design can it?
23:41:50 <maerwald> while a constraint may _technically_ be redundant, it may not be redundant API-wise
23:42:13 <maerwald> and those are a lot of cases
23:42:13 <Cale> Well, okay. If the constraints are fake, or you intend to eventually provide an implementation which will need them, you don't have much recourse.
23:43:15 <Cale> But in a lot of cases in the code I work on, we were ending up with lots of redundant constraints because things would get reworked and perhaps didn't need one of their constraints any more, but you wouldn't see it, and then all the things which depended on that thing would additionally get the same constraint
23:52:50 <maerwald> Cale: for it to be remotely useful to me I'd need a "not redundant" annotation on function/data level. Currently it's just "whole module or not"
23:53:06 <maerwald> or whole project even
