00:13:31 * hackagebot casr-logbook-reports-html 0.0.1 - CASR 61.345 logbook (casr-logbook) reports HTML output  https://hackage.haskell.org/package/casr-logbook-reports-html-0.0.1 (TonyMorris)
00:13:33 * hackagebot dbm 0.2 - A *simple* database migration tool.  https://hackage.haskell.org/package/dbm-0.2 (RickyElrod)
00:34:54 <Guest7289> How do I deconstruct "IO T"? A function I use returns an IO T and I want the T from it.
00:36:12 <phadej> if you have t :: IO T, and f :: T -> U, you can do fmap f t to get IO U, but you cannot escape IO
00:36:46 <phadej> i.e. if something is launching missiles, you cannot hide that fact.
00:37:08 <Guest7289> "you cannot escape IO". That's something I'm going to print out and hang on my wall. :)
00:37:33 <Guest7289> I don't get the analogy.
00:38:05 <ongy> IO contains side effects in Haskell. So an IO function *could* launch a missile (or rm -rf /), while a function missing IO can not
00:39:20 <Guest7289> Is there no way to let the side effects to their thing and then take the "pure" results without IO and use them to continue the workflow?
00:40:06 <ongy> you would usually have a rather thin IO function, that calls other functions to do the pure calculations
00:40:09 <Guest7289> problem is that I have a bunch of functions that take a T as parameter and are therefore not compatible with what I have.
00:40:53 <cocreature> Guest7289: you can combine them with do notation
00:41:37 <Guest7289> cocreature: could you perhaps elaborate or give a minimal example?
00:42:17 <cocreature> do t <- expressionReturningIOT; functionTakingT t
00:42:24 <cocreature> you can replace ; by a newline
00:42:43 <Guest7289> ah, I see! Thanks to both of you :)
00:43:02 <cocreature> Guest7289: if you have an example of what exactly you’re trying to do, I’d be happy to be more precise in how you solve it
00:43:25 <Guest7289> let me see, maybe I can solve it by myself now
00:43:32 * hackagebot casr-logbook-meta 0.0.3 - Meta-information about entries in a CASR 61.345 logbook (casr-logbook)  https://hackage.haskell.org/package/casr-logbook-meta-0.0.3 (TonyMorris)
00:47:19 <Guest7289> cocreature: hm, nope. http://lpaste.net/180012 I'm basically trying to pass the string yielded by stringLiteral to parseFile and return it's contents.
00:48:32 * hackagebot casr-logbook-meta-html 0.0.2 - Meta-information about entries in a CASR 61.345 logbook (casr-logbook) HTML output  https://hackage.haskell.org/package/casr-logbook-meta-html-0.0.2 (TonyMorris)
00:49:15 <cocreature> Guest7289: so first you need to change the type of importStmt to IO [Kerne]
00:49:18 <cocreature> *Kernel
00:50:54 <Guest7289> That would only shift the problem. The calling functions expect to handle Kernels (or lists of them). That's why I would like to get rid of IO to have a consistent interface.
00:51:00 <cocreature> Guest7289: I don’t quite understand the rest of your code. you are ignoring the result of pimport and then casing on the parser instead of it’s result. I assume you probably want something like case pimport (stringLiteral)
00:51:24 <cocreature> Guest7289: you can’t get rid of IO, that’s what phadej was referring to when he said that you can’t escape IO
00:51:52 <cocreature> the whole point of IO is to make it explicit if a function has side effects. if you could somehow hide that you would be lying about its behavior
00:52:47 <cocreature> but what you can do is combine functions that do io with functions that don’t do io but that combination will always give you something in io
00:53:25 <Guest7289> Maybe I am wrong about the analogy but it sounds a bit like "nullable" in other languages to me. It makes sense to explicitely state the potential pitfalls. But there you can do something like a nullcheck and then cast to a non-nullable type - since you've made sure. Is there no equivalent for side effects?
00:54:03 <cocreature> your analogy is wrong. what should the equivalent of a nullcheck be for side effects?
00:54:21 <Guest7289> Well, if I'd knew that I wouldn't be asking. :)
00:54:22 <liste> Guest7289: not really, because Haskell separates evaluation from execution
00:55:49 <Guest7289> hum, that's a shame. But I can't really change the whole API of my parser to be all IO Kernel. Isn't there a way to work around this?
00:55:59 <cocreature> Guest7289: so for nullable you can check if it is actually nullable and if it was not continue. but if you performed sideeffects you a) don’t have a way to check if they have been performed and b) the case where they have been performed is actually the case you are interested in
00:56:20 <liste> Guest7289: there's an "IO a -> a" function, but it breaks totally and horribly if there's any mutability or side effects - and why would you need IO if there's none?
00:58:23 <cocreature> and reading a file is not a case w here you should use that function
00:58:33 * hackagebot casr-logbook-reports-meta 0.0.1 - Reports on meta-information about entries in a CASR 61.345 logbook (casr-logbook)  https://hackage.haskell.org/package/casr-logbook-reports-meta-0.0.1 (TonyMorris)
00:58:57 <Guest7289> well there actually is IO at some point. http://lpaste.net/180015 but that's a not a choice I made deliberately but rather got from the tutorial.
00:59:50 <ongy> reading in a file will always be IO
01:00:00 <ongy> since that's exactly what it does.
01:00:04 <phadej> Guest7289: separate IO part and the rest. I.e. don't ry to build 'IO EndResult' directly. But make "IO IntermediateResult" and "IntermediateResult -> EndResult" values/functions
01:00:27 <Guest7289> I assumed so. But not that the file has been read I don't intend on doint any more side effects. So I don't really understand why the result has to be IO still.
01:00:35 <phadej> Guest7289: ^^
01:00:38 <Guest7289> *now
01:00:51 <liste> Guest7289: then read the file once and pass to the functions using it
01:01:18 <phadej> Guest7289: readFile is IO [String], then you could write "your logic" in "logic :: [String] -> EndResult"
01:01:29 <phadej> and combine them at the top-level (e.g. main)
01:02:08 <ongy> phadej: I think it's IO String
01:02:41 <phadej> ongy: thanks. though doesn't matter here (could be ByteString ;))
01:03:04 <phadej> imho that's how you should structure programs in not-so-strict-about-io languages too
01:03:15 <Guest7289> guess I have to take a minute to wrap my head around that. My inaptness with haskell doesn't really help here. But thanks so far. I will probably report back after fiddling around a bit.
01:03:17 <phadej> e.g. if you want to write a tests for 'logic'
01:04:08 <ongy> or want to have it maintainable
01:04:19 <phadej> :)
01:07:20 <kamyar> hello all
01:07:34 <liste> hi kamyar 
01:07:38 <kamyar> Can anyone train me the TypeOperator extension?
01:08:02 <phadej> Guest7289: in your case, btw, parseFile name is `readFile name >>= parseTest whileParser` (module the way error is reported). and if you want to work further from [Kernel] to some 'Foo', you  write 'stuff :: [Kernel] -> Foo' function, and compose it with parseFile
01:08:02 <kamyar> Apparently there is no good documentation about it
01:09:40 <phadej> kamyar: it's just a parser extension AFAIK, i.e. gives you nicer syntax but doesn't change any semantics
01:10:34 <kamyar> phandej: I need accurate and detailed explanation. I know what extension are in general
01:10:46 <phadej> I.e. you could write 'type (\/) = Either' and 'a \/ b' for 'Either a b', but that's all?
01:11:52 <phadej> kamyar: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#type-operators
01:12:52 <kamyar> thnx
01:13:34 * hackagebot intero 0.1.17 - Complete interactive development program for Haskell  https://hackage.haskell.org/package/intero-0.1.17 (ChrisDone)
01:26:07 <intothemountains> Is there a way to export all lenses of a record?
01:26:26 <intothemountains> (Without explicitly exporting them all one by one)
01:26:39 <jle`> intothemountains: i think you can use makeClassy, which makes lenses as a part of a typeclass, and export the typeclass
01:26:56 <intothemountains> jle`: I have to look into that, cheers
01:27:08 <jle`> that's how i hear of people doing it, but there might be more modern ways
01:28:35 * hackagebot casr-logbook-reports-meta 0.0.2 - Reports on meta-information about entries in a CASR 61.345 logbook (casr-logbook)  https://hackage.haskell.org/package/casr-logbook-reports-meta-0.0.2 (TonyMorris)
01:28:52 <jakub_> hi, what would be a concise way of implementing "precomposition" for two argument functions: (a -> b) -> (c -> d) -> (b -> d -> e) -> a -> c -> e
01:30:35 <ongy> is there a variant of (=<<) that binds like (.) instead of ($)?
01:31:20 <mpickering> <=<
01:31:35 <ongy> thx
01:33:35 * hackagebot casr-logbook-reports-meta-html 0.0.1 - HTML output for reports on meta-information about entries in a CASR 61.345 logbook  https://hackage.haskell.org/package/casr-logbook-reports-meta-html-0.0.1 (TonyMorris)
01:38:19 <lyxia> @djinn (a -> b) -> (c -> d) -> (b -> d -> e) -> a -> c -> e
01:38:19 <lambdabot> f a b c d e = c (a d) (b e)
01:39:26 <lyxia> @pl \f g -> dimap f (lmap g)
01:39:26 <lambdabot> (. lmap) . dimap
01:39:39 <lyxia> jakub_: ^
01:39:46 <jakub_> thx
01:42:57 <jle`> jakub_: you can use 'on' for a less general version where the two argument functions are the same
01:43:14 <jle`> actually yeah, 'on' is the same thing but with the same precomposition function used for both values
01:43:36 * hackagebot casr-logbook-types 0.0.1 - CASR 61.345 Pilot Personal Logbook  https://hackage.haskell.org/package/casr-logbook-types-0.0.1 (TonyMorris)
01:43:44 <jakub_> thanks, i actually needed different functions though
01:43:46 <dibblego> liftA2 where the arguments themselves are the same
01:44:09 <jle`> :t \f g h -> curry (uncurry h . bimap f g)
01:44:11 <lambdabot> (a1 -> a) -> (c1 -> b) -> (a -> b -> c) -> a1 -> c1 -> c
01:45:38 <Xnuk> :t on
01:45:40 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
01:58:36 * hackagebot intero 0.1.18 - Complete interactive development program for Haskell  https://hackage.haskell.org/package/intero-0.1.18 (ChrisDone)
02:04:55 <Guest7289> Alright, I pondered this for a while and I just don't see how I can work around it. I *have* to call readFile as I need the contents of the file to process. From then on my types carry that nasty IO with them. No amount of separation and splitting rids me of actually reading the file.
02:05:28 <ongy> Guest7289: can you post the complete file, so we can give you better suggestions?
02:06:13 <Guest7289> ongy: I'll condense it a bit for readability, one second.
02:06:22 <peteretep> So, given: f e = pure e >>= decrementAndGT5 >>= decrementAndGT5
02:06:30 <peteretep> If I have an array of [decrementAndGT5]
02:06:33 <peteretep> How do I write that?
02:06:33 <lyxia> what's the problem with using >>= ?
02:06:50 <peteretep> I don't know how many decrementAndGT5s I have
02:07:27 <ongy> :t \f e -> pure e >>= f e
02:07:29 <lambdabot> Monad m => (t -> t -> m b) -> t -> m b
02:07:40 <ongy> :t \f e -> pure e >>= f
02:07:40 <lyxia> oh you can write a recursive function that traverses the list
02:07:42 <lambdabot> Monad m => (a -> m b) -> a -> m b
02:07:43 <lyxia> or a fold
02:08:12 <peteretep> How would I do it with a fold?
02:08:16 <tsahyt> Hello. I need a function [(a, Bool)] -> [(a, Int)] where the input list can contain duplicates and I want to count for each a how many elements are True in the second component. I've got an Ord constraint on the as if necessary so I know that I can use something with groupBy and sortBy etc, but sorting introduces n log n complexity. There's an iterative solution that takes O(n) steps. How would I go about
02:08:18 <tsahyt> doing this in O(n) in a functional way?
02:09:14 <tsahyt> thinking about it, the iterative solution sorts too but basically uses a bucket sort
02:09:24 <lyxia> :t foldr (>=>) return ?listOfDecrements
02:09:26 <lambdabot> (?listOfDecrements::t (c -> m c), Foldable t, Monad m) => c -> m c
02:09:42 <peteretep> thankyou
02:09:57 <tsahyt> to make this easier, let's assume that a is Int. I guess I can then use some sort of bucket sort-ish solution
02:10:17 <Guest7289> ongy: http://lpaste.net/180027 
02:11:07 <ongy> tsahyt: you can do a fold, and accumulate the count list. Adding in the list is O(length list) though, if (a~Int) and you know that a is bound, you could use an array as accumulator
02:12:40 <tsahyt> ongy: I guess that could work yes. It never ceases to amaze me just how many things turn out to be folds.
02:13:15 <tsahyt> on the topics of arrays, why aren't they in base btw?
02:13:21 <dramforever> ongy: Maybe you can use accumArray
02:13:37 * hackagebot casr-logbook-meta 0.0.4 - Meta-information about entries in a CASR 61.345 logbook (casr-logbook)  https://hackage.haskell.org/package/casr-logbook-meta-0.0.4 (TonyMorris)
02:13:39 * hackagebot casr-logbook-html 0.0.2 - CASR 61.345 Pilot Personal Logbook HTML output  https://hackage.haskell.org/package/casr-logbook-html-0.0.2 (TonyMorris)
02:13:41 * hackagebot casr-logbook-meta-html 0.0.3 - Meta-information about entries in a CASR 61.345 logbook (casr-logbook) HTML output  https://hackage.haskell.org/package/casr-logbook-meta-html-0.0.3 (TonyMorris)
02:13:43 * hackagebot casr-logbook-reports 0.0.2 - CASR 61.345 logbook (casr-logbook) reports.  https://hackage.haskell.org/package/casr-logbook-reports-0.0.2 (TonyMorris)
02:13:45 * hackagebot casr-logbook-reports-html 0.0.2 - CASR 61.345 logbook reports HTML output  https://hackage.haskell.org/package/casr-logbook-reports-html-0.0.2 (TonyMorris)
02:14:01 <ongy> dramforever: I think you wanted to tell tsahyt 
02:14:20 <dramforever> Oh sorry
02:14:27 <dramforever> tsahyt: Maybe you can use accumArray
02:14:54 <tsahyt> dramforever: I'm looking at it right now. I've kinda ignored arrays in favour of vectors so far
02:15:15 <peteretep> lyxia: Right, sorry, got called away. I think >=> was the missing part of my puzzle
02:15:22 <dramforever> tsahyt: http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector.html#v:accum
02:15:31 <dramforever> Got you covered
02:16:43 <ongy> Guest7289: I' a bit confused, about your pimport there. But you will have to make importStmt 'IO [Kernell]' here. But you can make parseFile 'String -> [Kernel]' and move the readFile up to importStmt
02:16:54 <tsahyt> Now I just need to know bounds of a
02:17:18 <tsahyt> but I can find that easilty
02:17:21 <tsahyt> easily*
02:18:47 * hackagebot casr-logbook-reports-meta 0.0.3 - Reports on meta-information about entries in a CASR 61.345 logbook (casr-logbook)  https://hackage.haskell.org/package/casr-logbook-reports-meta-0.0.3 (TonyMorris)
02:18:49 * hackagebot casr-logbook-reports-meta-html 0.0.2 - HTML output for reports on meta-information about entries in a CASR 61.345 logbook  https://hackage.haskell.org/package/casr-logbook-reports-meta-html-0.0.2 (TonyMorris)
02:19:43 <lyxia> peteretep: you can get the same result by writing a recursive function that works and then refactoring it
02:19:51 <Guest7289> ongy: pimport just reads "import" and forgets it. Just an indicator that we're in fact dealing with an import-statement. I sadly can't move readFile anywhere else as it is also the exposed API and entrance point for the parsing. I could be called recursively by importStatement but that's just convenient reusing and not it's original intent.
02:20:51 <ongy> Guest7289: ah, I asumed importStmt would be exported by the module.
02:21:51 <Guest7289> ongy: no, that's just one parser used to parse "import x.y" followed by more code.
02:23:02 <ongy> ohh, now I get it. Ok that makes things ugly.
02:23:37 * hackagebot ltiv1p1 1.0.0.3 - Partial implementation of a service provider for LTI 1.1.  https://hackage.haskell.org/package/ltiv1p1-1.0.0.3 (achirkin)
02:24:10 <Guest7289> ongy: I'm afraid so. Some guys already advised me to split things up to get rid of IO, but I can't seem to split it up enough
02:24:37 <ongy> Guest7289: do you need them to complete parsing? If not I would parse them into a string and complete parsing into an intermediate value
02:26:35 <jakub_> I am facing this problem: a lot of container provide pure adjust function ((a -> a) -> k -> C k a -> C k a) but instead of (a -> a) I have (Monad m => a -> m a) can I turn the adjust function into (Monad m => (a -> m a) -> k -> C k a -> m C k a) myself (because, adjustM is not provided afaik)?
02:27:04 <tsahyt> @pointfree \i p -> if p then succ i else i
02:27:04 <lambdabot> Unknown command, try @list
02:27:11 <tsahyt> huh
02:27:13 <dramforever> Guest7289: If you had types like (MonadParsec Dec Text m => m Foo) instead of (Parser Foo) they need not mention IO.
02:27:18 <ongy> @pl \i p if p then succ i else i
02:27:18 <lambdabot> (line 1, column 8):
02:27:18 <lambdabot> unexpected reserved word "if"
02:27:18 <lambdabot> expecting pattern
02:27:23 <ongy> tsahyt: ^
02:27:29 <tsahyt> ahh, it's pl. thanks!
02:27:30 <dramforever> The overall parser still needs to be in IO because of, you know, pimport
02:27:49 <ongy> I failed while writing the term though
02:27:54 <tsahyt> @pl \i p -> if p then succ i else i
02:27:54 <lambdabot> flip =<< flip if' . succ
02:27:59 <tsahyt> that's not exactly nicer
02:28:04 <jakub_> I tried to come up with f: (a -> m b) -> m (a -> b) but that is probably nonsense
02:28:09 <tsahyt> I'll keep the lambda then I suppose
02:28:42 <ongy> :t succ
02:28:44 <lambdabot> Enum a => a -> a
02:29:02 <cocreature> jakub_: sadly you can’t. if adjustM is provided it easy easy to write adjust but the other way around is not possible
02:29:04 <dramforever> jakub_: No
02:29:14 <tsahyt> ongy: (+ 1) would do as well
02:29:31 <tsahyt> according to some criterion benchmarks I did a while ago, succ and pred were marginally faster though for some reason
02:29:39 <dramforever> But if they've exported a "get" function you can use that and adjust to write adjustM
02:30:29 <nmdanny> @pl users    <- forM files $ \file -> decode <$> (liftIO $ BS.readFile file)
02:30:30 <lambdabot> users <- forM files $ (decode <$>) . liftIO . BS.readFile
02:30:38 <jakub_> thx, this is rather sad, could you please point out the reason. to me it seems counter intuitive that adjustM could yield pure adjust, but I can imagine that adjust to adjustM is impossible
02:30:40 <lyxia> tsahyt: flip (bool id succ) ?
02:30:58 <lyxia> :t if'
02:31:00 <lambdabot> error:
02:31:00 <lambdabot>     • Variable not in scope: if'
02:31:00 <lambdabot>     • Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
02:31:11 <cocreature> jakub_: you can Identity from Data.Functor.Identity to get adjust
02:31:53 <tsahyt> > (flip (bool id succ)) 0 True
02:31:55 <lambdabot>  1
02:31:58 <lyxia> Uh, @pl should probably use bool instead
02:32:03 <jakub_> cocreature: right. and why the other direction doesn't work?
02:32:22 <dramforever> jakub_: Because this doesn't exist: (a -> m b) -> m (a -> b)
02:32:44 <cocreature> jakub_: because the information on how to combine the effects is not available
02:33:25 <jakub_> thanks a lot dramforever and cocreature 
02:33:36 <dramforever> you're welcome
02:33:37 * hackagebot hw-prim 0.1.0.0 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.1.0.0 (haskellworks)
02:43:38 * hackagebot casr-logbook 0.2.0 - CASR 61.345 Pilot Personal Logbook  https://hackage.haskell.org/package/casr-logbook-0.2.0 (TonyMorris)
02:53:38 * hackagebot hw-bits 0.1.0.0 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-bits-0.1.0.0 (haskellworks)
03:02:21 <jakub_> slock
03:04:33 <tsahyt> in terms of levels of indirection, is it better to have a newtype T = T (A,B) or data T = T A B?
03:04:56 <tsahyt> I guess data is better when used with the unpack pragma atleast
03:08:39 * hackagebot casr-logbook-reports-meta-html 0.0.3 - HTML output for reports on meta-information about entries in a CASR 61.345 logbook  https://hackage.haskell.org/package/casr-logbook-reports-meta-html-0.0.3 (TonyMorris)
03:13:39 * hackagebot casr-logbook 0.2.1 - CASR 61.345 Pilot Personal Logbook  https://hackage.haskell.org/package/casr-logbook-0.2.1 (TonyMorris)
03:18:39 * hackagebot ginger 0.3.0.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.3.0.0 (TobiasDammers)
03:31:21 <wz1000> I have a function f :: Ord a => [a] -> Bool which returns true if its input list is increasing. I want to express it as a fold that shortcircuits if it sees two adjecent decreasing elements.
03:31:26 <wz1000> Is this possible?
03:32:42 <wz1000> For example I want f [3,2..] and f [1,2,3,2,undefined] to both evaluate to False
03:36:07 <liste> wz1000: doesn't that work out of the box?
03:36:28 <liste> > let { f [] = True; f [a] = True; f (a:b:xs) | b > a = f (b:xs); f _ = False } in (f [1,2,3], f [1,2,3,2,undefined])
03:36:30 <lambdabot>  (True,False)
03:36:40 <wz1000> liste: I don't want to express it as a general recursive function, but as a fold
03:39:03 <puregreen> I don't think you can express it as a fold easily. The fold produces a Bool so the accumulator is a Bool, but since you want to do a comparison at each step you'd have to carry the previous value in the accumulator as well (so, (a, Bool) now), but now you'll have to provide an initial value of type (a, Bool) and if you want “increasing” and not “non-decreasing” you can't always do that
03:40:08 <puregreen> you can fold tails of the list but then you'll have something that looks awfully similar to liste's function but a bit perverted
03:40:20 <wz1000> puregreen: I want non decreasing. But that isn't really the problem. Whatever fold I've tried either fails for an infinite list, or for a list with undefined as an element.
03:40:31 <puregreen> can you show a fold you tried?
03:43:40 * hackagebot casr-logbook 0.2.2 - CASR 61.345 Pilot Personal Logbook  https://hackage.haskell.org/package/casr-logbook-0.2.2 (TonyMorris)
03:45:04 <wz1000> > let go prev f | f prev = (<= prev); otherwise = const False; f [] = True; f (x : xs) = foldr go (const True) xs x
03:45:07 <lambdabot>  <no location info>: error:
03:45:07 <lambdabot>      not an expression: ‘let go prev f | f prev = (<= prev); otherwise = cons...
03:45:40 <wz1000> > let go prev f | f prev = (<= prev); otherwise = const False; f [] = True; f (x : xs) = foldr go (const True) xs x in (f [1,2,3,4], f [1,3,2,undefined])
03:45:43 <lambdabot>  (True,*Exception: Prelude.undefined
03:45:51 <wz1000> puregreen: ^
03:48:40 * hackagebot ContextAlgebra 1.0.0.0 - Implementation of the context algebra.  https://hackage.haskell.org/package/ContextAlgebra-1.0.0.0 (jhahn)
03:52:59 <lyxia> your function is too strict
03:55:19 <wz1000> lyxia: I can't figure out how to make it lazy in the second argument
03:57:48 <puregreen> isn't the problem that it goes in the opposite direction? e.g. f [3,2,undefined] doesn't work but f [undefined,3,2] does (and prints False)
03:58:33 <lyxia> oh interesting
04:00:33 <lyxia> I would have used a (Maybe a, Bool) accumulator but I'm trying to figure out it would work with something like your a -> Bool
04:03:54 <lyxia> > let go a1 k a0 = a0 <= a1 && k a1 ; f (x : xs) = foldr go (const True) xs x in (f [1,2,3,4], f [1,3,2,undefined])
04:03:57 <lambdabot>  (True,False)
04:04:32 <wz1000> lyxia: Would that work with an infinite list?
04:05:09 <lyxia> > let go a1 k a0 = a0 <= a1 && k a1 ; f (x : xs) = foldr go (const True) xs x in f $ [1,3,2] ++ repeat 1
04:05:15 <lambdabot>  False
04:05:27 <lyxia> hurray \o/
04:05:31 <wz1000> lyxia: Nice. Thanks!
04:06:36 <Kawa_> Do I need to learn mathematics for AI?
04:06:56 <mmaruseacph2> mostly, yes
04:07:08 <mmaruseacph2> otherwise, it's like script kiddies "hacking"
04:12:01 <lyxia> > let go a0 ~(a1, ok) = (Just a0, maybe True (a0 <=) a1 && ok) ; f = snd . foldr go (Nothing, True) in (f [1,2,3,4], f (1 : 3 : 2 : undefined)) -- wz1000 
04:12:04 <lambdabot>  (True,False)
04:12:31 <maerwald> Depends what kind of AI. Also, depends what you want to do.
04:12:47 <maerwald> you don't need to understand a lot of math to implement crypto algorithms either
04:15:24 <maerwald> the relevant maths is usually part of AI courses anyway
04:16:01 <wz1000> lyxia: Why the lazy pattern match?
04:17:38 <lyxia> wz1000: evaluating the second argument directly forces the tail of the list, which might not be defined.
04:23:01 <ironChicken> does anyone know of anything that may convert XML schemata (DTD, RNG, etc.) into a collection of ADTs?
04:23:16 <ironChicken> i've already looked at HXT's pickling stuff
04:23:59 <ironChicken> but that's for when you know the Haskell types already and you just want to convert data between a known XML schema and a known set of ADTs
04:33:30 <AzureStigma> whats the avg salary of haskell programmers
04:33:40 <saurabhnanda> techempower benchmarks. I'm surprised with Yeod's dismal performance. My comment: https://www.reddit.com/r/haskell/comments/4zb72m/techenpower_web_framework_benchmarks_round_13/d6uiim5
04:33:56 <AzureStigma> if its off-topic i apologize and disregard my question
04:34:41 <Rembane> AzureStigma: I think it is ludicrously high since most of the Haskell programmers are working within finance.
04:35:18 <AzureStigma> thanks google doesnt seem to give a good  or reasonable answer since its not popular
04:36:52 <AzureStigma> has anyone have experience with intellji IDEA for an IDE for haskell 
04:37:34 <AzureStigma> sorry IntelliJ IDEA i mean*
04:38:01 <tdammers> AzureStigma: IDEs tend to be not very popular in general among haskellers
04:38:21 <AzureStigma> may I know the reason for this?
04:38:23 <tdammers> AFAIK, most people program haskell from a plain text editor, driving the build toolchain from the command line
04:38:37 <maerwald> tdammers: how do you know?
04:38:48 <Rembane> Emacs and haskell-mode is quite popular.
04:39:06 <tdammers> maerwald: I don't actually know, it's just something that consistently comes up when discussing development environments
04:39:11 <maerwald> yeah and emacs is not an editor :)
04:39:32 <tdammers> maerwald: and I hardly ever hear people mention IDEs; the popular choices seem to be vim, emacs, atom, etc.
04:39:35 <saurabhnanda> no thoughts on why Yesod is performing so poorly on techempower benchmarks?
04:40:04 <maerwald> tdammers: exactly, a lot of people used pumped-up emacs, which is basically an OS, not an editor
04:40:16 <tdammers> anyway, I believe there are three reasons why people don't use IDE's with Haskell
04:40:52 <tdammers> one, the chicken-and-egg situation that there are no good IDE's for Haskell because nobody writes them, and nobody writes them because it's just too much work to do on your own, and there's not enough there yet to build upon
04:41:13 <tdammers> i.e., the Haskell IDE situation has failed to reach critical mass so far
04:41:42 <AzureStigma> since its not as big as lets say java I'm guessing?
04:41:47 <tdammers> two, because Haskell's abstractive power is so good that the language itself is perfectly capable of solving many of the problems you'd normally have an IDE solve for you
04:42:01 <maerwald> I disagree.
04:42:10 <maerwald> see spacemacs and intero etc
04:42:19 <maerwald> that's not what you call "just an editor"
04:42:28 <tdammers> well, the thing with emacs-based things is that the threshold is smaller
04:42:53 <tdammers> you can start with vanilla emacs, and gradually extend your setup to something that is eerily similar to an IDE, as far as features go
04:42:55 <maerwald> and even vim users use a  crapload of extensions which basically end up having the same functionality as using eclipse
04:43:10 <tdammers> well, I don't - my vim is pretty vanilla
04:43:23 <maerwald> you are an exception then, ime
04:43:35 <tdammers> the only thing that's special about Haskell here is a custom .ftplugin that sets up some useful macros
04:44:23 <tdammers> anyway, it's easier and more productive to use an existing editor and write extensions that solve a tiny subset of the "Haskell development tooling" problem than to go out and try to write a complete Haskell IDE
04:44:41 <tdammers> also works better in a community that is quite heavily subscribed to open-source dynamics
04:45:19 <tdammers> and I'm still pretty convinced that the "better language" thing is relevant
04:45:31 <tdammers> I've seen people drag huge slabs of "snippets" along with them for Java development
04:45:40 <maerwald> tdammers: who said "write a complete Haskell IDE"? you can juse use an existing one
04:45:43 <tdammers> stuff like macros to automatically scaffold a visitor pattern and stuff like that
04:45:56 <saurabhnanda> IDE == easier refactoring for me.
04:45:56 <AzureStigma> dumb question if anyone has a mac and haskell do they know if the full package install cabal and where to?
04:46:02 <maerwald> and making assumptions about what is more productive in that regard isn't useful imo
04:46:15 <tdammers> saurabhnanda: maybe, but refactoring Haskell is already ridiculously easy compared to most other languages
04:46:25 <saurabhnanda> tdammers: no, no no, it's not
04:46:36 <ironChicken> ah, there is a JSON equivalent: https://hackage.haskell.org/package/json-autotype
04:46:39 <saurabhnanda> tdammers: I wrote a program with hardcoded creds
04:46:42 <ironChicken> might be useful
04:46:49 <tdammers> saurabhnanda: yes, and?
04:46:54 <tdammers> saurabhnanda: you want to remove them?
04:47:18 <saurabhnanda> tdammers: needed to read the creds from the environment or config file
04:47:27 <tdammers> saurabhnanda: yes, so?
04:47:34 <saurabhnanda> tdammers: needed to change the function signature of a lot of function to a ReaderT
04:47:35 <tdammers> saurabhnanda: that probably means you need to drag some state around
04:47:42 <saurabhnanda> and that's painful
04:47:48 <saurabhnanda> and that's something IDEs should be able to solve
04:47:51 <saurabhnanda> it was busy work
04:47:53 <tdammers> maybe
04:47:55 <saurabhnanda> nothing interesting
04:48:00 <saurabhnanda> I knew what I needed to change in each function
04:48:23 <AzureStigma> nvm got it
04:48:29 <tdammers> at least doing the bulk work with a bunch of sed rules and then having the compiler catch the edge cases is possible and pretty safe
04:48:46 <tdammers> trying the same in Python will probably get you fired
04:49:27 <maerwald> why convince people of a different workflow when theirs already work fine?
04:49:58 <cloudhead> tdammers: re: refactoring, is there a tool to semantically rename types/functions?
04:50:46 <AzureStigma> where is ghc-mod executable?
04:50:58 <saurabhnanda> tdammers: that's the wrong comparison
04:51:20 <saurabhnanda> tdammers: if the IDE situation needs to get better Java (or Scala?) should be the benchmark
04:51:48 <tdammers> saurabhnanda: Java and Scala were designed with an IDE-supported workflow in mind. Writing Java without an IDE is just plain painful.
04:52:02 <saurabhnanda> tdammers: pick the good, leave the bad.
04:52:18 <saurabhnanda> tdammers: change the question -- can the IDE situation in Haskell be made better than what it is?
04:52:23 <ggVGc> tdammers: donät agree
04:52:25 <tdammers> saurabhnanda: yes, but the benefit of good IDE support for Haskell is tiny compared to the benefit of good IDE support for Java
04:52:28 <saurabhnanda> tdammers: are there quick wins, low hanging fruit?
04:52:28 <liste> IMO Haskell has just as much potential for IDE support, being statically typed and having clear parsing rules
04:52:30 <ggVGc> you can write java in the IDE way
04:52:31 <ggVGc> or not
04:52:45 <tdammers> ggVGc: idiomatic Java, then :P
04:52:55 <ggVGc> however, the java community is mainly IDE based, hence working with most java code becomes a pain without an IDE
04:53:15 <ggVGc> liste: yes but not as much need
04:53:16 <ggVGc> I'd argue
04:53:48 <ggVGc> there simply isn't a reason to generate 100 lines of "Factory manager skeleton" code in haskell
04:54:19 <saurabhnanda> btw, people should really be discussing https://www.reddit.com/r/haskell/comments/4zb72m/techenpower_web_framework_benchmarks_round_13/d6uiim5
04:54:32 <ahihi> saurabhnanda, tried #yesod?
04:54:34 <tdammers> that's my point - Haskell can bake repetitive stuff into libraries, generic code, TH, etc.
04:54:56 <tdammers> with Java, the options for that are limited, and the general approach is to automate things using IDEs
04:55:14 <maerwald> tdammers: have you ever used a haskell IDE?
04:55:34 <tdammers> maerwald: haven't felt the need
04:55:43 <tdammers> maerwald: I stopped using IDEs before learning Haskell, even
04:55:46 <maerwald> then I don't understand how you can make those comparisons
04:55:49 <ahihi> tdammers: in this respect, I find scala is more similar to haskell than to java, so I wonder what makes you say it's "designed with an IDE-supported workflow in mind"
04:56:03 <liste> tdammers: I how about automating refactoring? it's the most important feature of IDEs IMO
04:56:04 <tdammers> ahihi: well, maybe not Scala
04:56:21 <maerwald> I think the language doesn't make a lot of difference here. It's about personal taste and workflow.
04:56:25 <tdammers> liste: sure, that's a nice-to-have, but IME the need is not as pressing as it is with Java
04:56:40 <maerwald> I've used java in vim and compiled via cli. You don't need eclipse for that either.
04:56:45 <saurabhnanda> maerwald: is there  a haskell IDE?
04:56:56 <hpc> imo the feedback of "refactoring this takes a lot of keystrokes" is worth the pain in order to more easily recognize that you have a code structuring problem
04:56:58 <maerwald> There's no significant difference of "IDEs in haskell" vs "IDEs in java"
04:57:04 <quchen> tdammers: In Java you can bake a lot of things in annotations too.
04:57:08 <ahihi> I can't say I use my scala IDE for much more than autocompletion, inline type checking and semantic renames
04:57:09 <tdammers> maerwald: I've come to dislike IDEs with a passion, but if I had to do extensive work on a Java codebase again, I'd install an IDE without flinching
04:57:10 <liste> perl -pi -e and cut-paste go longer way in Haskell than other languages though (:
04:57:13 <quchen> Same caveat as in Haskell: it’s not really Haskell.
04:57:31 <AzureStigma> is there any default location for cabal data path
04:57:53 <quchen> AzureStigma: ~/.cabal
04:57:53 <maerwald> I don't understand why people want to convince others of their personal taste and workflow.
04:58:20 <maerwald> saurabhnanda: yes, emacs, vim, leksah, ...
04:58:23 <tdammers> also, IME refactorings that are painfully complex are much less common in Haskell code than in any of the other languages I've used
04:58:24 <maerwald> even eclipse afair
04:58:26 <AzureStigma> would that work on a mac?
04:58:31 <tdammers> except maybe lisp
04:58:41 <tdammers> but lisp has its own slew of problems in that regard
04:59:02 <ggVGc> saurabhnanda: why is erlang not even in the benchmarks :(
04:59:07 <hpc> maerwald: because discussions about IDEs are a matter of personal taste and workflow?
04:59:23 <maerwald> not necessarily no
04:59:28 <quchen> tdammers: Semantic rename and go to definition are fairly useful in a Haskell setting, those are the two I miss the most.
04:59:37 <quchen> (go to def exists, but is painfully slow)
04:59:41 <AzureStigma> also modi is ghci correct?
04:59:52 <tdammers> go to def: hasktags + vim -> good enough
04:59:59 <tdammers> also very fast
05:00:06 <maerwald> hpc: you can talk about features, stability, maturity, ...
05:00:08 <maerwald> lots of things
05:00:09 <ggVGc> quchen: ime project folder grep works 99% as well as "go to definition"
05:00:14 <ggVGc> and also works in cases where IDE's don't
05:00:23 <puregreen> maerwald: so you can't relate to the common human feeling that one's personal taste is “better” than others' tastes?
05:00:48 <tdammers> nice thing about hasktags is that it blends seamlessly into the vim ecosystem, so "go to definition" works exactly the same as in any other language
05:00:49 <maerwald> E.g. using vim as a haskell IDE often ends up being unstable, ghc-mod being incompatible again with syntastic and whatnot. That's not about personal taste. That's just experience.
05:00:50 <quchen> ggVGc: But it’s a very manual process. Go to console, type in grep, find result line, open that line in the editor. Compare that to “Ctrl+click”.
05:01:07 <maerwald> puregreen: sure, but I try to keep that to myself
05:01:12 <quchen> Hasktags does not give you go to definition, but go-to-(thing named X). It’s a useful workaround, but unaware of the semantics of your program.
05:01:22 <tdammers> quchen: hence, "good enough"
05:01:48 <tdammers> quchen: the alternative is a tool that knows enough about the source code to require most of the build process to run in the background
05:01:50 <puregreen> maerwald: well, then there's your answer: some people are worse at keeping stuff to themselves than you are :)
05:01:55 <quchen> Yeah, I can live with it as well. Still, seeing my PHP IDE going to definitions is a slap in the face ;-(
05:01:58 <tdammers> quchen: that's not a sacrifice I'm willing to make
05:02:15 <tdammers> and PHP IDE's get it wrong all the time
05:02:54 <maerwald> puregreen: we can bash each others taste in -offtopic. I just find it unproductive here when people ask about editors/IDEs in here and it always ends up in the same stuff.
05:03:16 <maerwald> "nah, you don't need IDE, haskell refactoring is more cool with sed, awk and a magnetic needle"
05:03:48 <tdammers> maerwald: nobody said it's *better*; I just said that it's *good enough*, so not enough people feel enough pain to invest a lot of work into making it better
05:03:56 <tdammers> that's not a judgement, it's just how it is
05:04:03 <ggVGc> quchen: I've got a vim binding to just grep the current word and put the results in quickfix list. And also wrote another one that lets me fuzzy search in my quickfix list. So grepping and jumping to where I want to go is usually less than a second for me
05:04:27 <lingxiao> hey all
05:04:44 <tdammers> I'm pretty sure most Haskellers would embrace a refactoring tool that works perfectly and otherwise stays out of the way, but nobody has built one, and not enough people seem to be willing to sink a lot of time into it
05:04:52 <lingxiao> i have a parsing problem and i'm not sure if I should write a more discriminitive parsr
05:05:03 <lingxiao> or do some preprocessing before the parsing
05:05:21 <lingxiao> Right now I havea n attoparsec parser of form: word w = spaces *> string (pack w) <* lookAhead term 
05:05:23 <tdammers> also, third reason why IDE's are not very popular in Haskell is because one of Haskell's big strengths is in writing compilers, parsers, DSLs, and such
05:05:35 <maerwald> erm
05:05:38 <lingxiao> so it parses words like "hello" but not "hellooo"
05:05:41 <maerwald> wat
05:05:47 <lingxiao> but it also parses words like "word."
05:06:11 <tdammers> so if that's what you're doing, you want a toolchain that works well even for the languages you are currently designing
05:06:22 <tdammers> IDEs don't really match with that situation very well
05:06:24 <maerwald> IDEs *are* popular in haskell.
05:06:27 <lingxiao> so unfortunataely it also allows words like "word.com" or "word-/.com"
05:06:43 <tdammers> maerwald: that is not my impression, but maybe my impression is wrong
05:07:04 <AzureStigma> wow total noob sorrry got it thanks!
05:08:05 <maerwald> What is not so common in haskell are IDEs that are _specifically_ designed for haskell and don't need to be assembled painfully. They are not unpopular though, it's just that there are not many (yet). Part of that being poor adoption of haskell in industry.
05:08:29 <AzureStigma> cabal install ghc-mod failed what are the dependencies 
05:08:32 <maerwald> IDEs in general (e.g. spacemacs with intero etc) are rather common though.
05:08:43 * hackagebot ntha 0.1.0 - A tiny statically typed functional programming language.  https://hackage.haskell.org/package/ntha-0.1.0 (zjhsdtc)
05:13:05 <AzureStigma> nvm re cache fixed the issue
05:22:19 <AzureStigma> needed to manually install happy then it worked this is for the issue of installing ghc-mod
05:57:45 <MarLinn> As y'all just had this lovely discussion: Can anyone point me towards solutions to configure one of the popular editors to be usable without hand cramps or a 50y-old keyboard? It was big enough of a pain point for me to stay with lesser tools until now, but trying them is still on my todo-one-day-list...
05:59:01 <merijn> MarLinn: What do you consider "the popular editors"?
05:59:12 <Rembane> MarLinn: For Vim: https://gist.github.com/benmccormick/4e4bc44d8135cfc43fc3
06:00:11 <MarLinn> merijn: vim and emacs. Atom might be considered popular, but it got booted for other reasons
06:00:38 <merijn> For vim I personally just use syntastic + hdevtools
06:01:05 <Rembane> MarLinn: The catch with vim is that you have to learn how it works.
06:01:45 <ongy> I recommend remapping CapsLock to something useful, or either will get annoying
06:03:12 <kadoban> vimtutor takes like a half hour. After that you're not doing too badly.
06:03:45 <MarLinn> Rembane, yeah I heard that... The approach sounded like a good idea from what I understood, but I never got far enough to stay
06:04:29 <jonored> MarLinn: vi(m) just being modal takes out most of the hand-cramp factor for me; editing is mostly just the same collection of keystrokes as typing, just after hitting escape.
06:04:34 <merijn> MarLinn: Vim is not an editor that magically becomes better/more usable by configuring it. In fact, one of the main selling points of vim is that if you use it, you can use it pretty much as-is on any platform
06:04:58 <merijn> So, I'm not sure I understood the initial question
06:05:40 <jonored> what you lose by not having the 50-year-old-keyboard is mostly not having arrow keys printed on the hjkl keycaps.
06:08:54 <MarLinn> Well, maybe the hand-cramps where just from the unusual configuration. My hands know WASD, and something like IJKL might be "close enough", but HJKL is at such a weird position AND layout
06:09:34 <kadoban> It's at the home row where you're supposed to hold your hands anyway, hehe.
06:09:53 <MarLinn> kadoban, thanks for vimtutor. I didn't know about that
06:09:53 <locallycompact> wtf is a home row
06:10:11 <kadoban> MarLinn: 'welcome. And yeah it's pretty cool.
06:10:23 <kadoban> As far as anything is cool with a text editor anyway, haha.
06:10:52 <MarLinn> That's just it, the home row is a row, it's one-dimensional ;p
06:11:08 <locallycompact> which row
06:12:10 <MarLinn> Rembane and ongy, thanks for your tips, too.
06:12:53 <MarLinn> locallycompact, the one from A to L (on an American keyboard)
06:12:56 <ongy> locallycompact: home row is on qwerty layout the middle one. Where you rest your fingers per default
06:13:02 <ongy> MarLinn: ;
06:13:07 <kadoban> locallycompact: The one with the knobby things where your index fingers are supposed to go.
06:13:23 <Rembane> MarLinn: np, good luck!
06:13:35 <locallycompact> home is not on that row
06:13:39 <locallycompact> just letters
06:13:51 <locallycompact> and ;'#
06:14:26 <merijn> Anyway...
06:14:31 <merijn> This is getting rather offtopic
06:15:24 <funk> hi there, still new to haskell... i need a global configuration file as .toml. stumbled upon htoml and now i can parse my file. but how do i use it like having something like a global struct initialized at "main" startup. heard about reader monad, but don't understand it for now. Looked at Data.Configurator, but can i use this with toml files? And how can i build up a global accessible data struct, like "lazy_static" for those that pl
06:16:03 <Rembane> funk: Your row truncated at "for those that pl"
06:16:04 <tdammers> funk: short answer, haskell doesn't have mutable global variables
06:16:18 <yaxu> Hi all, looking for database library recommendations.. I just want to timestamp and store simple data, then query on timestamp ranges.. Is something like sqlite-simple a good choice?
06:16:54 <tdammers> funk: the simple approach is to have main load a configuration, and then pass it around explicitly, i.e., all the functions down your call chain that need the configuration have an extra parameter
06:17:34 <kadoban> funk: If it's very simple you could express it in haskell syntax, then it's just another source file with a normal haskell value in it. Otherwise, yeah ^ read it in it 'main' and then do whatever with it.
06:18:45 <tdammers> funk: if it's compile-time configuration, people sometimes use TemplateHaskell to read the configuration file at compile time, convert it to Haskell AST, and splice it directly into the compiled program, but that's probably way too advanced for you at this point
06:19:14 <yaxu> there is a plurality of sqlite libraries on hackage..
06:19:27 <funk> tdammers: explicit pass around is what i want to avoid. kadoban: can't do that in compile time. needs to be a user changeable runtime config.
06:19:41 <Rembane> funk: Then a reader monad is what you need.
06:19:45 <funk> and has to be in .toml by customer 
06:20:14 <funk> ok, stumbled upon that fabulas reader monad. any pointers for a noober how to use it?
06:20:20 <funk> fabulous..
06:20:23 <kadoban> funk: Reader or State, depending on if you need to be able to change it. There's almost certainly a library to help with mutable-at-runtime config.
06:20:33 <funk> reader. immutable
06:20:39 <Rembane> funk: https://hackage.haskell.org/package/htoml to parse toml
06:20:53 <tdammers> funk: in the end, explicit passing-around is actually quite a sane option
06:21:17 <tdammers> funk: if you have a lot of things to pass around, something I like doing is wrap them all into one record type (ApplicationState or whatever), and pass just that around
06:21:45 <kadoban> funk: I would start with explicitly passing around myself. If you really want to learn Reader, I dunno, how much do you know about haskell? What have you read/done so far?
06:22:32 <funk> first - thx to all. found reader, but don't understand it yet. will work on it. found htoml and can parse my files. but i really don't want to pass around my configuration, as it affects many pieces of code.
06:22:41 <tdammers> you can use Reader, but IMO it's not usually worth it, because you remove a little bit of clutter from the type signatures (ReaderM Config m a vs. Config -> m a), but you add clutter in the function bodies themselves (ask vs. just using the value directly)
06:22:43 <sm> both passing around and reader monad affect all your code
06:23:10 <sm> which if you think about it, is as it should be
06:23:18 <MarLinn> funk: If a lot of your code needs the whole config, that can also be a code smell. Eg if your config is actually re-structuring the whole program, then the program should reflect that by first laying out its own structure, then executing it.
06:23:33 <kadoban> funk: If you're fairly familiar with Monad and Applicative, Reader is not much to learn. Otherwise you have some conceptuals to cover first.
06:23:35 <yaxu> ah this looks helpful http://haskelliseasy.readthedocs.io/en/latest/#sql
06:23:47 * hackagebot hills 0.1.2.3 - Generate STL models from SRTM elevation data.  https://hackage.haskell.org/package/hills-0.1.2.3 (djf)
06:28:00 <funk> i'm very new to haskell... i'm trying to learn it while reimplementing a python gui app (measuring and displaying power station data) to run on smaller hardware. made it in go, nearly completely done it in rust (where i have lazy_static, that perfectly fits my need) and now i try it in haskell. For what my gut tells me, i desperately *want* to learn haskell. seems so beautiful at first, second, third glance :-) And then convince my su
06:28:46 <MarLinn> funk: Your message got truncated again
06:29:49 <funk> .. in short: want to use haskell because it seems to be fun. Alternatively did it rust and go. 
06:30:14 <funk> Different languages with different targets, i know.
06:30:19 <Rembane> funk: That sounds like an amazing reason!
06:30:25 <kadoban> It is fun. Though I personally wouldn't want to learn it without reading a good book on it before using it.
06:30:40 <MarLinn> funk: You're in for a treat with Haskell gui programming. If you stay after that, nothing can get you away from it ;)
06:30:55 <maerwald> funk: gui is rather annoying in haskell, there's no pure gui framework, except a few FRP things that are either underdeveloped or involve js.
06:31:10 <funk> got "learn you a haskell" and "real world haskell" and many online resources under my pillow.
06:31:27 <funk> for me gui is annoying everywhere ;-)
06:31:53 <maerwald> using haskell Gtk+ bindings is worse than using Gtk+ in C
06:31:56 <funk> im using wxhaskell for now, because i used wx in python. 
06:32:00 <sm> building haskell apps on small hardware can also be tricky (needs 1G+ of memory)
06:32:57 <funk> tests ran on a raspberry pi 2, but i didn't proove it for the whole application (since it's not ready yet)
06:33:09 <sm> funk: you might also be interested in fltkhs, I seem to remember it builds small
06:33:20 <puregreen> maerwald: are you using gtk or haskell-gi?
06:33:36 <MarLinn> ...if only diagrams would support dynamic diagrams, then they could carry FRP sources as queries and we could build a widget library... ah, beautiful dreams...
06:33:54 <maerwald> puregreen: I am using haskell gtk bindings
06:34:13 <puregreen> maerwald: there are several packages that provide them
06:34:19 <maerwald> provide what
06:34:22 <funk> for a non functional programmer to learn haskell, wxhaskell is great in a way, because you can use it more or less in imperative style. but this smells afterwards.
06:34:26 <puregreen> gtk bindings
06:34:56 <maerwald> puregreen: https://git.io/v67jE
06:34:57 * jonored is, now that he /finally/ got the thing to /build/... rather enjoying using reflex & reflex-dom.
06:35:20 <srhb> MarLinn: Hmm, couldn't you do that with the svg backend potentially?
06:35:26 <srhb> Well, with any I suppose
06:36:34 <puregreen> maerwald: okay, gtk3. I'm asking because I'm using gtk3 too (which is indeed worse than using GTK in C) and recently I saw haskell-gi which looks nicer (but haven't used it yet) and wondered which exactly bindings you meant when you said that it's worse than C
06:36:46 <funk> back to my q in the first place: i will parse my toml file with htoml and explicitly pass around my config as a record to all pieces of code that will need it (eg. number of measuring points, displayed in the gui, affects some calculations and data layout. Thank you all for your help!!
06:36:48 <MarLinn> srhb: admittedly I haven't looked into it too closely. Transporting queries should be no problem. And you could have your backend produce a new diagram on every update I suppose
06:37:09 <srhb> MarLinn: Yes... I'm not sure if it's really fast enough to do it meaningfully :-P
06:37:18 <srhb> MarLinn: I sympathize with your dream, though!
06:38:40 <tdammers> funk: sounds like a good plan. you can always refactor things when this turns out insufficient
06:39:21 <maerwald> puregreen: and... I'm never sure with haskell gtk bindings if I get memory leaks
06:42:09 <maerwald> so much for "haskell programs are easy to reason about" :P
06:43:15 <kadoban> If I had to do a GUI currently ... I'd probably use reflex-dom and webkitgtk I guess, until someone comes up with a reflex bindings for a real GUI library
06:43:24 <tdammers> maerwald: in all fairness, the memory leaks probably originate in the FFI-bound C code, not the Haskell code itself
06:44:02 <maerwald> tdammers: depends
06:44:48 <maerwald> but in C I have more clarity about what happens where
06:44:57 <maerwald> after all, it's a C framework
06:48:48 * hackagebot hw-rankselect 0.3.0.0 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-rankselect-0.3.0.0 (haskellworks)
06:49:25 <chsn> github is *almost* perfect for reading haskell code -- except, when I click on a function/type, I want it to jump me to the definition - is there anytool that will let me do this?
06:49:58 <kadoban> If you mean actually inside of github, I doubt it.
06:50:08 <kadoban> hdevtools can do that, probably ghc-mod too
06:50:29 <chsn> kadoban: how dyou you read source code with hdevtools?
06:50:53 <puregreen> there's Sourcegraph which is exactly that, but they don't support Haskell yet :(
06:51:37 <puregreen> you can read code on Hackage and get hyperlinked source, if the docs of a package were built recently enough 
06:52:18 <puregreen> e.g. see http://hackage.haskell.org/package/lens-4.14/docs/src/Control.Lens.Each.html
06:53:05 <puregreen> but there are no hyperlinks for types/functions not in the lens package itself
06:56:56 <chsn> for such an advanced language, we hae tools vasty inferior to those of java
06:58:42 <linduxed> the same can be said for javascript
06:58:48 * hackagebot hw-mquery 0.1.0.0 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-mquery-0.1.0.0 (haskellworks)
06:58:53 <linduxed> in the end it's all about how much money has been thrown on the thing
06:59:00 <linduxed> in the case of java, lots
06:59:04 <linduxed> in the case of js, lots
06:59:15 <linduxed> same goes for php and a couple of others
06:59:35 <linduxed> not much more to it
07:01:27 <MarLinn> chsn: So, "jump to definition" is missing. (but search is a decent short-term solution) What else is missing?
07:01:39 <chsn> MarLinn: it's mainly just jump to definition
07:01:43 <chsn> which always breaks my flow when reading
07:02:02 <chsn> it turns "clicking" into "open up google, search for this; get wrong version; try hoogle; give up, github checkoiut related libraries and grep all of them"
07:02:20 <chsn> it overwrites short term memory and makes a 1 second op a 5 minute op
07:02:23 <exDM69> chsn: generate a tags file for your haskell project and use tags-capable $EDITOR
07:02:46 <exDM69> plain old ctags should do haskell alright and there's another project that's haskell-specific
07:03:01 <exDM69> GHCi also had a way to dump tags, but not sure if it's supported any more
07:03:09 <MarLinn> For external things, you can integrate hoogle/hayoo into ghci or your editor
07:04:05 <exDM69> correction: ctags (ie. exuberant-ctags) can't do haskell, you'll need hasktags
07:04:48 <exDM69> GHCI has command :tags to generate tags file
07:05:14 <exDM69> https://wiki.haskell.org/Tags  more info
07:07:00 <exDM69> http://www.stephendiehl.com/posts/vim_2016.html   <---  I recently came across this one... lots of nice tricks for vim+haskell
07:08:27 <exDM69> btw... does stephen diehl hang around this channel?  I recently read a lot of his stuff and I'm working on a project similar to some of his work
07:08:48 * hackagebot unbound 0.5.1 - Generic support for programming with names and binders  https://hackage.haskell.org/package/unbound-0.5.1 (sweirich)
07:11:26 <kadoban> exDM69: It already seems out of date though. ghc-mod doesn't work in syntastic anymore, for example. (with most recent versions of both)
07:11:26 <OnOut2k16> http://ilredentore.dynv6.net updated..)
07:12:17 <kadoban> Don't go there ^
07:12:24 <kadoban> malware spam from bitcoin
07:13:33 <exDM69> kadoban: yeah, that's sad... vimscript plugins aren't great...
07:13:56 <kadoban> exDM69: Well, it's less random incompatability and more syntastic dropped support for ghc-mod intentionally.
07:13:56 <exDM69> kadoban: I recently stopped using *all* vim plugins because all of them feel half-assed
07:14:28 <exDM69> I've been considering getting CTRL-P
07:14:36 <exDM69> and perhaps some ghc-mod magic...
07:14:55 <exDM69> but honestly, just having a tags file covers most of the intelligence I require from my editor
07:15:00 <kadoban> I mostly just use some completion stuff and snippets, and not much else really.
07:16:49 <exDM69> some thing slike syntastic would be kinda nice... but then it's working with vim/vimscript's non-existent async facilities
07:17:10 <exDM69> it's more likely to cause frustration and non-responsiveness than a net increase in productivity
07:17:13 <kadoban> Ya. I keep waiting for neovim to mature more.
07:17:22 <kadoban> syntastic with quick checkers like hlint is nice though, IMO.
07:17:36 <exDM69> I've considered migrating to the new vis editor
07:17:49 <exDM69> I give it a go every now and then, but it's not good enough for me yet...
07:18:28 <kadoban> I may try spacemacs someday, but ... I never actually work up the energy to spend time on editor stuff anymore, haha.
07:18:49 * hackagebot hquantlib 0.0.3.2 - HQuantLib is a port of essencial parts of QuantLib to Haskell  https://hackage.haskell.org/package/hquantlib-0.0.3.2 (PavelRyzhov)
07:20:04 <jchia_> According to https://wiki.haskell.org/GHC/Memory_Footprint , Int, Int8, Int16, Int32 and Int64 all take 2 words. In a lower-level language like C++, smaller ints are used to save memory/cache. In Haskell, why would someone use a smaller int type given that the memory footprint is the same? Perhaps to save serialization footprint? Anything else?
07:21:42 <puregreen> jchia_: I believe that an unboxed Vector of Int8s would be smaller than the same of Int64s
07:22:48 <chsn> doe stack have a lts supporting ghc 8.0 yet, or is anything newer than 7.10 still hackey?
07:23:00 <puregreen> still hackey
07:23:14 <jchia_> puregreen: I see. Thanks
07:23:26 <kadoban> There's the nightlies. Last time I used them they had all of the few libraries I needed *shrug*
07:23:55 <geekosaur> I assume you at least considered type correctness, this being haskell?
07:24:09 <jchia_> the difference in number of libraries between lts and nightly is now <100.
07:24:31 <kadoban> jchia_: Nice
07:25:30 <sm> chsn: the nightlies work well, not hacky
07:27:28 <nshepperd_> Sometimes numeric types are unboxed in loops also
07:28:49 * hackagebot ntha 0.1.1 - A tiny statically typed functional programming language.  https://hackage.haskell.org/package/ntha-0.1.1 (zjhsdtc)
07:29:21 <Squarism> noone happens to know if intero emacs plugin requires you to install (add) ghc as plugin too?  
07:38:40 <chsn> sm: so I replace "resolver: lts-6.13" with "resolver: nightly-2016-08-24" in stack.yaml ?
07:40:25 <sm> chsn: that's right, or I usually pick the first of the month for more stability
07:47:20 <lpaste> lambdafan pasted “what's wrong with my parser?” at http://lpaste.net/180071
07:48:50 * hackagebot bookkeeper 0.1.2.0 -   https://hackage.haskell.org/package/bookkeeper-0.1.2.0 (jkarni)
07:51:58 <merijn> lambdafan: You're combining pure and <$>
07:52:17 <merijn> lambdafan: You, presumably, meant either "(,) <$> ..." or "pure (,) <*> ..."
07:52:30 <merijn> lambdafan: Look at the types of pure, <$> and <*>
07:52:37 <lambdafan> merijn, so the stackoverflow code is wrong?
07:53:02 <Rudes> :t pure
07:53:04 <lambdabot> Applicative f => a -> f a
07:54:05 <lambdafan> huh, yeah fixed it. I was assuming I wrote parseChar incorrectly.
07:54:23 <merijn> lambdafan: Yeah, looks like the SO example is wrong
07:54:45 <merijn> Someone should edit that
07:54:51 <merijn> I don't have the reputation to do it
07:55:01 <lambdafan> I'll do it, thanks :)
07:55:31 <Rudes> merijn: if only they took into consideration your IRC rep
07:55:38 <merijn> Rudes: :)
07:55:46 <Rudes> you'd be able to delete entire subdomains
07:56:34 <pyon> merijn: Can't you even propose an edit? I have enough reputation to vote for an edit to be approved.
07:56:51 <merijn> pyon: My reputation is like 21 or something :p
07:56:56 <lambdafan> merijn, I just found out why it has not been corrected. You have to correct at least six xharacters from the post in order to do an edit
07:56:58 <pyon> Aw. :-|
07:57:15 <merijn> I've got 144 rep on the CS stackexchange :)
07:57:16 <lambdafan> which sounds silly
07:58:01 <Rudes> we're gonna work together to get enough rep to make this happen. go team
07:58:11 <merijn> Deleting pure is only 4, I guess :)
07:58:40 <merijn> Edit it + some 7 nonsense characters, then someone can edit the 7 nonsense characters out
07:59:14 <Rudes> merijn: as in C#?
07:59:36 <merijn> Rudes: hmm?
07:59:44 <Rudes> cs stackexchange
07:59:48 <Rudes> as in c#?
07:59:58 <merijn> Rudes: No, as in Computer Science :)
08:00:02 <Rudes> OH lol
08:00:03 <MarLinn> Huh. Later in the answer he not only gets it right but also provides an implementation of getChar, only with a different name
08:00:09 <lambdafan> strangely enough, only removing text does not count as an edit
08:00:17 <lambdafan> they expect you to add something as well
08:00:38 <kadoban> That sounds pretty genius
08:01:25 <peteretep> Can I use GADTs to constrain: `data Mug e = Mug e` such that e has to be a Monoid?
08:01:49 <MarLinn> peteretep: Yes.
08:01:55 <dmj> peteretep: sure, but you can do that w/o GADTs too
08:02:04 <peteretep> dmj: oh. Can you give me some keywords to google?
08:02:14 <peteretep> My google fu only found me GADTs
08:02:25 <dmj> data Mug e where Mug :: Monoid e => Mug e
08:02:35 <peteretep> Ah, I thought that was a GADT
08:02:37 <peteretep> OK
08:02:40 <dmj> data Mug e = forall e . Monoid e => Mug e
08:02:45 <dmj> ExistentionalQuantification
08:02:51 <dmj> Existential*
08:03:15 <peteretep> Is there any major reason to prefer one over the other? I am simply trying to stop annotating every function that uses taht type
08:03:48 <k0ral> Hello
08:03:53 <dmj> peteretep: unless you're modifying the return type (which GADTs let you do), I think they're equivalent
08:04:57 <peteretep> "Illegal generalised algebraic data declaration for ‘ResultEnv'’"
08:04:59 <peteretep> trolololo :P
08:05:11 <peteretep> data ResultEnv' e e1 where ResultEnv' :: (Monoid e, Monoid e1) => ResultEnv' Result (Either e e1)
08:05:19 <MarLinn> peteretep: You can even do data Mug e where Mug :: Monoid e => { unMug :: e } -> Mug e
08:05:47 <Rudes> unMug, i like that
08:05:50 <nshepperd_> You're better off keeping the annotation imo
08:06:09 <peteretep> oh lord, it's an extension? This throws my paper out
08:06:34 <peteretep> maybe it doesn't, I can just hide it in the prelude and hope no-one notices
08:06:40 <k0ral> I'd like your advice on the Applicative semantic for parsers, as it seems there are 2 possible instance implementations: the first is to sequentially execute the parsers, and combine their results with <*>, while the second is to simultaneously apply all parsers and combine their output when each of them has succeeded once
08:07:19 <peteretep> OK, doing that. Thanks for the help
08:07:31 <k0ral> is there a reason why most parsing libraries implement the first and not the second ?
08:07:32 <peteretep> I am building something mildly useful, so perhaps I will be able to give back at the end :D
08:07:42 <jchia_> is there a version of fromInteger that checks for overflow?
08:08:51 * hackagebot irc-core 2.1.1.0 - IRC core library for glirc  https://hackage.haskell.org/package/irc-core-2.1.1.0 (EricMertens)
08:09:05 <merijn> k0ral: Because the latter one seems really useless to me?
08:09:23 <nshepperd_> k0ral: apply both and return the one that succeeds is <|>
08:09:24 <saurabhnanda> why is yesod slower than Ruby? https://www.reddit.com/r/haskell/comments/4zb72m/techenpower_web_framework_benchmarks_round_13/d6uiim5
08:09:55 <nshepperd_> Apply both and require both to succeed seems very rarely useful
08:09:58 <k0ral> merijn: it seems really useful when you want to be able to parse multiple pieces of information whatever their order
08:10:40 <merijn> k0ral: oh, wait, I misread what you said. No, I'm pretty sure that violates the Applicative laws
08:10:45 <k0ral> nshepperd_: I don't mean to return the one that succeeds, I mean to wait until all of them succeed and combine their results afterwards
08:11:03 <MarLinn> saurabhnanda: You're the web dev with the company behind him. Why don't you solve it for us instead of the other way around? :p
08:11:37 <saurabhnanda> MarLinn: :)
08:12:03 <ironChicken> is there a limit to the number of constructors a type can have?
08:12:19 <merijn> ironChicken: Theoretically or practically?
08:12:19 <saurabhnanda> I'd like to run this benchmark with MySql and Postgres and see if that has a significant impact
08:12:34 <ironChicken> merijn: hmm, both
08:12:41 <merijn> ironChicken: Theoretically, no. In practice GHC doesn't like types with like >50 constructors
08:13:02 <MarLinn> saurabhnanda: I looked at it but found nothing major on first glance. Might need quite some profiling that I can't do. But I think the Yesod big shots are on it
08:13:02 <merijn> ironChicken: Even like 30ish get questinable. Especially if you're deriving instances. GHC becomes very slow
08:13:05 <nshepperd_> k0ral: yeah "wait" as in apply the parsers repeatedly would break some laws probably
08:13:36 <sm> +1! save us saurabhnanda !
08:13:47 <ironChicken> merijn: ok. do you mean that it's slow to compile? does it end up affecting the performance of the compiled code?
08:13:49 <k0ral> merijn: could you please hint at why it would violate the Applicative laws ? At first sight, I don't see what's wrong
08:14:07 <merijn> ironChicken: No, like GHC taking long to compile
08:14:08 <sm> I built their VM the other day but I think I'll need a machine with more ram to run tests
08:14:13 <nshepperd_> Besides that would be incompatible with the monad instance
08:14:36 <merijn> k0ral: I'm not 100% sure, but I have a 90% certainty hunch that it breaks them
08:14:38 <k0ral> merijn: also, I know at least 2 libraries that made this choice (json-stream, conduit)
08:15:51 <saurabhnanda> is there a good tutorial about how to profile Haskell code? Also without call-stacks how will profiling work?
08:16:05 <bartavelle> k0ral, you mean that (,) <$> anyChar <*> anyChar could produce ('a','a') instead of ('a','b') when run on "ab" ?
08:16:09 <saurabhnanda> Persistent uses https://github.com/bos/mysql-simple for MySQL. No known performance issues there.
08:16:14 <sm> saurabhnanda: the GHC user guide is a good place to start
08:16:15 <dmj`> saurabhnanda: real world haskell has a section on profiling, and the GHC User guide does too
08:16:26 <sm> the best place, in fact
08:16:56 <k0ral> nshepperd_: you could interpret the "wait" as "parse one occurrence of X, separated by any number of anything", that doesn't strike me as odd
08:17:16 <k0ral> bartavelle: precisely
08:17:20 <sm> and you do get call stacks in a profiling report, essentially
08:17:26 <bartavelle> k0ral, how would you combine parsers then ?
08:17:56 <bartavelle> k0ral, for example, how can you parse "ab" with just the (char :: Char -> Parser Char) primitive ?
08:18:17 <k0ral> bartavelle: monadically
08:18:38 <bartavelle> k0ral, yeah but then "a *> b" wouldn't be the same as "a >> v" :)
08:18:42 <bartavelle> erm "a >> b"
08:18:49 <k0ral> bartavelle: monads are for sequential semantic while applicatives are for simultaneous semantics, are they not ?
08:18:50 <dolio> No you wouldn't, because that parser couldn't have a Monad instance that agrees with the Applicative instance.
08:18:56 <bartavelle> k0ral, no they are not
08:19:21 <dolio> Or, wouldn't.
08:19:45 <MarLinn> k0ral: The core parsers went from monads to applicatives (through a short detour to arrows) because of performance.
08:19:58 <MarLinn> (As far as I know)
08:20:13 <k0ral> ok I think I get it
08:20:16 <bartavelle> I would say it's more about convenience than performance
08:20:31 <k0ral> if I want to define a simultaneous semantic, I need an Applicative that isn't a Monad
08:20:39 <k0ral> am I right here ?
08:20:40 <bartavelle> also all the big parsers have a monadic interface
08:20:47 <nshepperd_> You can have an applicative with concurrent semantics but it has to be a different newtype
08:21:03 <nshepperd_> Without a monad instance
08:21:20 <dolio> Can't you define a simultaneous monad? It just still wouldn't allow you to sequence.
08:21:21 <k0ral> that explains why the conduit library defines a newtype ZipConduit with a distinct Applicative semantic, and without a Monad instance
08:21:23 <bartavelle> k0ral, I think there are "non consuming parser" combinators in many parsing libraries
08:21:28 <dolio> It'd be like reader instead of state.
08:22:13 <nshepperd_> dolio: with sufficient laziness i guess
08:22:40 <merijn> k0ral: Basically, it's possible for a type to have multiple Applicative instance, but (afaik) monad instances are unique. And it's rather underisable to identical Monad and Applicative operations have different behaviours
08:22:48 <merijn> k0ral: See ZipList applicative
08:23:09 <dolio> 'Simultaneous' parsers are `String -> Maybe a`, 'sequential' are `String -> Maybe (String, a)`.
08:23:32 <RiverDance> Hey, is this the right place to ask for help on some of my code (super beginner stuff)?
08:23:49 <puregreen> yep, ask away
08:23:51 <k0ral> okay it clicked in my mind, thank you guys, I'll resort to a newtype wrapper then
08:25:42 <lpaste> RiverDance pasted “Permutations on a list” at http://lpaste.net/180078
08:25:51 <MarLinn> I wonder if there is a reason in the underlying theory why a structure could not have more than one monad instance (via newtypes)
08:28:05 <ertesx> merijn: monad instances are unique per type up to isomorphism?  is that what you're saying?
08:28:22 <merijn> ertesx: I'm not sure they're unique
08:28:42 <merijn> ertesx: But they *seem* to be, because I've never heard of an "alternative monad instance"
08:28:52 <Gurkenglas> Its called MonadPlus
08:28:58 <bartavelle> :)
08:29:29 <merijn> Gurkenglas: That's not what I meant :)
08:29:46 <ertesx> interesting…  off the top of my head i can't think of two disagreeing Monad instances for the same type
08:30:11 <dolio> Monads aren't unique per type, because monoids aren't, either.
08:31:02 <Gurkenglas> Pair a = (a, a) would have two possible ones, though one could count one of them canonical since Pair a is Either a a
08:31:33 <Gurkenglas> Umm that came out wrong
08:31:46 <ertesx> _ >>= _ = empty; pure = empty  -- this seems to be a valid Monad instance for every Alternative
08:32:08 <dolio> It does?
08:32:16 <ertesx> whoops
08:32:19 <ertesx> _ >>= _ = empty; pure _ = empty  -- this seems to be a valid Monad instance for every Alternative
08:32:33 <dolio> That wasn't the only problem.
08:32:47 <Gurkenglas> "data Pair a = Pair (a, a)" would have two possible ones, though one could count one of them canonical since it would look kinda like the monad instance of (,) a
08:32:53 <ertesx> ah, nope, it isn't
08:33:13 <ertesx> pure is not an identity
08:33:18 <sshine> is (mapM Data.ByteString.getLine) an efficient way to get one line from a file at a time?
08:33:50 <nshepperd_> You could interpret State s as ReaderT s (Writer s)
08:34:23 <nshepperd_> Which has a different instance
08:34:27 <Gurkenglas> sshine, getLine doesn't take an argument, do you mean replicateM n Data.ByteString.getLine?
08:35:23 <ertesx> but [] has two disagreeing Monad instances, doens't it?  ZipList is a monad, as far as i can tell, just a very inefficient one
08:35:35 <Gurkenglas> ZipList isnt a monad
08:35:43 <merijn> ertesx: ZipList can't be a monad
08:36:15 <ertesx> merijn: why not?
08:37:14 <merijn> ertesx: Ok, what would the implementation of >>= be? concatMap?
08:37:34 <RiverDance> This is the code I wanted help for - http://lpaste.net/180078 - I am trying to generate a list of lists, each containing a different permutation of my input list... however I am having difficulties.
08:37:35 <nshepperd_> Holes in the diagonal
08:37:56 <sshine> Gurkenglas, whoops. I mean something like: lines = do { eof <- isEOF; if eof then [] else getLine <$> lines }
08:38:42 <Gurkenglas> Your else clause should be (:) <$> getLine <*> lines
08:38:53 <sshine> er, yes.
08:38:54 <latro`a_> ertesx: concatMap repeat is not id
08:39:23 <ertesx> it's not concatMap, gimme a minute
08:39:30 <sshine> Gurkenglas, that will lazily read one line at a time in spite of it being the result of an effect, right?
08:40:55 <ertesx> @let zipBind [] _ = []; zipBind (x:xs) f = case f x of [] -> []; y : _ -> y : zipBind xs (drop 1 . f)
08:41:00 <lambdabot>  Defined.
08:41:14 <ertesx> merijn, latro`a_: ^
08:41:15 <MarLinn> RiverDance: please tell us about your difficulties. Sometimes just explaining a problem in words can lead yourself to an insight. If not it helps us understand what's missing in the picture.
08:41:25 <Gurkenglas> Not sure, try it? >>= it into print and see whether you get a pause before printing when reading a huge file
08:42:11 <latro`a_> ertesx: well, check whether the resulting ap is the familiar <*>
08:42:31 <Gurkenglas> Though readFile is lazy for Strings, so try it with readFile too, and check whether you're using lazy bytestring on that one
08:43:00 <ertesx> @let zipAp fs xs = zipBind (\f -> zipBind (repeat . f) xs) fs
08:43:02 <lambdabot>  .L.hs:181:24: error:
08:43:02 <lambdabot>      • Couldn't match expected type ‘[t1]’
08:43:02 <lambdabot>                    with actual type ‘(a0 -> a1) -> [t2]’
08:43:19 <ertesx> :t zipBind
08:43:21 <lambdabot> [t1] -> (t1 -> [t]) -> [t]
08:43:33 <nshepperd_> ertesx: iirc the problem is (>=>) is not associative
08:43:34 <ertesx> @let zipAp fs xs = zipBind fs (\f -> zipBind xs (repeat . f))
08:43:36 <lambdabot>  Defined.
08:43:56 <ertesx> > zipAp [(+1), (^2), (*2)] [10, 20, 30]
08:43:59 <lambdabot>  [11,400,60]
08:45:06 <mniip> :t zipBind
08:45:08 <lambdabot> [t1] -> (t1 -> [t]) -> [t]
08:45:26 <mniip> I think that's unlawful
08:46:00 <mniip> > zipBind [0,1,2] ([[1,2,3],[],[4,5,6]] !!)
08:46:07 <lambdabot>  mueval-core: Time limit exceeded
08:46:22 <mniip> > zipBind [0,1,2] ([[1,2,3],[4,5,6],[7,8,9]] !!)
08:46:29 <lambdabot>  mueval-core: Time limit exceeded
08:46:48 <ertesx> that should work…
08:46:53 <mniip> > ()
08:46:57 <lambdabot>  ()
08:47:01 <tommd> Are there any heavy users of the gremlin-haskell package here att?
08:47:04 <ertesx> it works locally
08:47:06 <chsn> anyone got spacemacs + intereno working?
08:47:08 <Gurkenglas> @check \fs xs -> zipAp fs xs == getZipList (ZipList fs <*> ZipList xs)
08:47:11 <lambdabot>  +++ OK, passed 100 tests.
08:47:20 <mniip> ertesx, what's the result of the first then
08:47:38 <ertesx> mniip: [1]
08:47:47 <mniip> hm
08:48:04 <ertesx> i'm pretty sure zipBind is a valid monad
08:48:35 <merijn> ertesx: I remember looking into it and being convinced it wasn't possible (also, the practical evidence of ZipList not having a monad instance)
08:49:08 <ertesx> merijn: i suspect the reason that ZipList doesn't have a monad instance is more likely efficiency
08:49:17 <ertesx> zipBind is horribly inefficient
08:50:07 <mniip> @check \a f -> repeat a `zipBind` f == f (a :: ())
08:50:16 <lambdabot>  mueval-core: Time limit exceeded
08:50:16 <lambdabot>  mueval: ExitFailure 1
08:50:23 <mniip> @check \a f -> repeat a `zipBind` f == (f :: () -> Int) (a :: ())
08:50:36 <lambdabot>  mueval-core: Time limit exceeded
08:50:51 <dmwit> Is there even an Arbitrary instance for (->)?
08:50:55 <mniip> er that wasn't even correct
08:50:56 <Gurkenglas> Should we call int_e with a -?
08:50:58 <mniip> dmwit yes
08:51:31 <Gurkenglas> dmwit just use sequenceIO from acme-iot :)
08:52:35 <mniip> ertesx, hmm, what can we say about (m >>= f) >>= g === m >>= (\x -> f x >>= g)
08:53:13 <mniip> @let zipComp k f x = k x `zipBind` f
08:53:18 <lambdabot>  Defined.
08:53:19 <mniip> :t zipComp
08:53:21 <lambdabot> (t2 -> [t1]) -> (t1 -> [t]) -> t2 -> [t]
08:53:28 <ertesx> @let (>>~) = zipBind
08:53:37 <lambdabot>  Defined.
08:53:37 <RiverDance> MarLinn: Thanks, your tip helped :)
08:53:42 <ertesx> @let infixl 1 >>~
08:53:59 <lambdabot>  Defined.
08:54:50 <MarLinn> RiverDance: Rubber Duck Programming wins again! XD
08:55:31 <barrucadu> @check \xs -> let join x = zipBind x id in join (join xs) == join (fmap join xs)
08:55:34 <lambdabot>  *** Failed! Falsifiable (after 7 tests and 7 shrinks):
08:55:34 <lambdabot>  [[[(),(),(),(),(),()]],[[],[(),(),(),()],[(),(),(),(),()],[()],[(),(),(),()]...
08:55:50 <mniip> dear
08:56:01 <mniip> I wonder what the full testcase is
08:56:08 <barrucadu> Got the idea from https://mail.haskell.org/pipermail/haskell-cafe/2013-October/111020.html
08:56:21 <barrucadu> I remembered there had been a few instances of zliplist monads on haskell-cafe beforew
08:56:34 <ertesx> @let zipJoin = (>>~ id)
08:56:37 <lambdabot>  Defined.
08:56:59 <mniip> @check \ns -> let join x = zipBind x id; xs = map (map (`replicate` ())) ns in join (join xs) == join (fmap join xs)
08:57:01 <lambdabot>  *** Failed! Falsifiable (after 36 tests and 23 shrinks):
08:57:02 <lambdabot>  [[27,-29,-29,30,26,-8,21,-7,-21,-12,-29,16,34,-18,35,33,10,2,26,13,-34,-7,-3...
08:57:05 <ertesx> > zipJoin [[1,2,3], [10,20,30], [100,200,300]]
08:57:07 <lambdabot>  [1,20,300]
08:57:11 <ertesx> weird
08:57:43 <mniip> @check \ns -> sum (map length ns) < 10 ==> let join x = zipBind x id; xs = map (map (`replicate` ())) ns in join (join xs) == join (fmap join xs)
08:57:47 <lambdabot>  error:
08:57:47 <lambdabot>  • Couldn't match expected type ‘Int’ with actual type ‘Test.QuickCheck.Safe....
08:57:54 <mniip> @check \ns -> (sum (map length ns) < 10) ==> let join x = zipBind x id; xs = map (map (`replicate` ())) ns in join (join xs) == join (fmap join xs)
08:57:57 <lambdabot>  *** Failed! Falsifiable (after 4 tests and 3 shrinks):
08:57:57 <lambdabot>  [[1],[-1,3],[-2]]
08:58:06 <Jenaf> is there a way to ensure in a [Int]->[Int]->[Int] to ensure that the first list is one element longer than the second?
08:58:09 <ertesx> doesn't seem to be a monad after all =/
08:58:11 <mniip> so
08:58:25 <Welkin> Jenaf: if you use a phantom type tag
08:58:28 <mniip> [[[()]],[[],[(),(),()]],[]]
08:58:33 <bartavelle> Jello_Raptor, Int -> [Int] -> [Int] -> [Int] :)
08:58:45 <mniip> > zipJoin (zipJoin [[[()]],[[],[(),(),()]],[]])
08:58:47 <lambdabot>  [(),()]
08:58:48 <bartavelle> erlm
08:58:48 <Welkin> Jenaf: but otherwise, dependent types
08:58:50 <bartavelle> Jenaf, 
08:58:51 <mniip> > zipJoin (fmap zipJoin [[[()]],[[],[(),(),()]],[]])
08:58:53 <Jenaf> phantom type tag? any link abouer information on this?
08:58:54 <lambdabot>  [()]
08:59:06 <bartavelle> Jenaf, sorry misread the question :/
08:59:41 <Jenaf> well atm i just need it for single-purpose code so it would not be that bad, but If something like this exists it woud be nice to know
09:00:10 <ertesx> mniip: i wonder how you came to suspect this…  was there a formal hint or just gut feeling?
09:00:33 <Jenaf> I'm new to haskell
09:00:45 <Jenaf> so I was like " would be nice if this existed, why not just ask"
09:00:48 <mniip> I knew that attempts to implement a lawful ZipList monad so far have been unnsuccessful
09:01:00 <ertesx> i see
09:01:05 <shapr> Jenaf: asking is always a good approach
09:01:09 <bartavelle> Jenaf, it does exist, but it really depends on your needs
09:01:34 <Jenaf> I want to solve PrejectEuler #067
09:01:49 <bartavelle> Jenaf, it's the posterchild example of dependent type programming (vector operations with the length encoded in the type)
09:01:54 <Jenaf> and its about rows of a triangle; I want to write a function I can fold ofer the list of rows
09:02:19 <ertesx> but i think it's okay to have some unlawful monads…  nobody really cares that much about associativity
09:02:22 * ertesx ducks and runs away
09:02:28 <bartavelle> ertesx :)
09:02:28 <glguy> Jenaf: When working with [Int] you can't generally enforce that one list is one larger than the other
09:02:41 <Jenaf> to solve the problem i don't really need it, but I'm solving those riddles I try to learn things
09:02:44 <glguy> Jenaf: But you can write your program to ensure that
09:03:21 <Jenaf> one could do a pair ( Int , [Int]) (a,l) with a=length l
09:03:32 <EvanR> ive been doing the idris book, and programming with Vects is actually really nice
09:03:36 <glguy> Jenaf: You probably don't benefit from storing the length
09:03:45 <alercah> Yet another Project Euler problem easily solved by dynamic programming
09:03:52 <EvanR> programming, rather than theorem proving
09:03:59 <Jenaf> 67 isn't really complicated
09:04:16 <Gurkenglas> @check \f g h x -> ((f >~> g) >~> h) x == (f >~> (g >~> h)) x {- why doesnt this work? -}
09:04:18 <bartavelle> Jenaf, you can just use something like Vector, where you get fast access to its length if that's what you need
09:04:19 <lambdabot>  error:
09:04:19 <lambdabot>  • No instance for (Typeable t10) arising from a use of ‘myquickcheck’ • In t...
09:04:28 <_JoeShanahan> Hello friends, I'm playing around with GHCi's breakpoints for the first time. Is there a way a force something to bind? My breakpoint is at the end of a pattern match inside a case statement. I don't have access to the values bound by the pattern match; can I force them to be visible?
09:04:35 <glguy> Jenaf: If it made you feel better you could do a check of your input that the input was well-formed and had increasing lengths
09:04:36 <Jenaf> well I'll just write it without that for now
09:04:53 <ertesx> :t (>~>)
09:04:54 <lambdabot> (t2 -> [t1]) -> (t1 -> [t]) -> t2 -> [t]
09:04:56 <Jenaf> my approach on 67 is some sort of krippled dijkstra
09:05:28 <_JoeShanahan> To add my question, I'd rather not have to add something to the code, if possible
09:05:34 <ertesx> Gurkenglas: probably because x' type can't be inferred
09:05:37 <Jenaf> (krippled as in I do not store the path, just the value)
09:06:08 <ertesx> @check \f g h x -> ((f >~> g) >~> h) x == (f >~> (g >~> h)) (x :: Int)
09:06:11 <alercah> The optimal algorithm is in \Theta(n^2) where n is the number of rows
09:06:16 <lambdabot>  error:
09:06:16 <lambdabot>  • No instance for (Typeable t10) arising from a use of ‘myquickcheck’ • In t...
09:06:46 <Jenaf> yeah thats where mine will should be
09:07:13 <Jenaf> unles I'm having some overhead wich I don't know about from the way the datatypes i use are handled
09:08:01 <Jenaf> so it could be O(n^3) if I overlook something
09:08:19 <ertesx> @check \f g h x -> (((f :: Int -> [Char]) >~> (g :: Char -> [Bool])) >~> (h :: Int -> [Int])) x == (f >~> (g >~> h)) x
09:08:23 <lambdabot>  error:
09:08:23 <lambdabot>  • Couldn't match type ‘Bool’ with ‘Int’ Expected type: Bool -> [Int] Actual ...
09:08:26 <Jenaf> still ok
09:08:50 <ertesx> Gurkenglas: in any case it's a type inference issue
09:09:05 <Gurkenglas> @check \f g h x -> (((f :: () -> [()]) >~> (g :: () -> [()])) >~> (h :: () -> [()])) (x :: ()) == (f >~> (g >~> h)) (x :: ()) {- yep this worked -}
09:09:08 <lambdabot>  +++ OK, passed 100 tests.
09:09:24 <ertesx> @check \f g h x -> (((f :: Int -> [Char]) >~> (g :: Char -> [Bool])) >~> (h :: Bool -> [Int])) x == (f >~> (g >~> h)) x
09:09:27 <lambdabot>  *** Failed! Falsifiable (after 30 tests):
09:09:27 <lambdabot>  <Int -> [Char]> <Char -> [Bool]> <Bool -> [Int]> 1
09:09:36 <ertesx> Gurkenglas: ^
09:11:55 <nitrix> Is `mapM f . map g` subject to fusion?
09:12:01 <Gurkenglas> Hrrm it should return a context in which to use the found f g and h.
09:13:12 <ertesx> Gurkenglas: while i admire quickcheck's feature to pull random functions out of thin air, the not-so-helpful Show instance makes me avoid it
09:13:33 <ertesx> nitrix: for which type?
09:13:50 <glguy> Lists, hopefully (given map)
09:13:51 <ertesx> oh, map
09:13:52 <nitrix> ertesx: Something simple, lists.
09:14:08 <nitrix> ertesx: I'm trying to develop an instinct for RULEs.
09:14:57 <nitrix> I unfortunately cannot find them :/
09:15:00 <ertesx> nitrix: see if mapM is implemented using foldr
09:15:10 <nitrix> ertesx: I think mapM = traverse, no ?
09:15:18 <ertesx> yeah
09:15:42 <nitrix> So I'd have to look at traverse? Does fusion happens before/after that?
09:15:53 <nitrix> This is where I get confused. Should I look at RULEs for traverse?
09:16:54 <ertesx> :t \f -> foldr (\x r -> do y <- f x; (y :) <$> r) (pure [])
09:16:56 <lambdabot> (Foldable t, Monad f) => (t1 -> f a) -> t t1 -> f [a]
09:17:31 <jchia_> I want to represent 3 types of quantities, e.g. distance, force, energy. 3m * 2N = 6J. Is there a clean way to represent the values and multiplication/division between them? I thought of using newtype over Int, Float, or something in Data.Fixed. But, there's no way I can reasonably defined (*) between, say, Distance and Force, is there, since it's already taken by Num?
09:18:04 <ertesx> nitrix: see if it's implemented in terms of foldr, because then it will likely fuse…  check core to make sure it actually does
09:18:05 <jchia_> My goal is unit safety and being able to multiply and divide between related unit types
09:18:29 <EvanR> you can use phantom types to tag each number with a unit
09:18:39 <kadoban> You should be able to do unit-safety, with a type with annotated units, that knows how to do unit math.
09:18:48 <kadoban> Yeah, phantom types.
09:18:50 <EvanR> type families can do the unit math for you
09:18:55 <ertesx> nitrix: you can also look out for rule firings (there is a flag to enable them), but the output is a bit convoluted
09:19:06 <jchia_> What if I also want to use a different underlying type? E.g. Int32 for one unit, Pico for another?
09:19:13 <EvanR> well that doesnt make much sense
09:19:24 <EvanR> you have to convert to the same number type before doing arithmetic
09:19:42 <EvanR> which you can just do
09:19:48 <Welkin> Pico?
09:19:54 <EvanR> fromIntegral realToFrac etc
09:20:01 <guillaum2> hello. I was reading a book and in an example they use a function called `bak :: (a -> [a]) -> (a -> Bool) -> a -> Maybe [a]`. Here `a` is a state of a state machine, and bak takes respectivey a function from a state to a list of state, a function to test if a state is terminal, and initial state, and maybe returns a list of states. The function is not detailed in the book. Do you know if it exists 
09:20:03 <jchia_> let's say in my use case Distance happens to always be integer and energy needs to be represented using fixed point
09:20:07 <guillaum2> somewhere (hoogle don't know) ?
09:20:16 <jchia_> Welkin: Data.Fixed.Pico
09:20:18 <EvanR> Welkin: Pico is from Data.Fixed and is 10^12 shifted fixed point
09:20:49 <EvanR> jchia_: you can embed faithfully any integer into Pico
09:20:55 <EvanR> use fromIntegral
09:20:57 <ertesx> jchia_: note that unit math is inconvenient in haskell, because it doesn't know basic arithmetic laws for the phantom types
09:21:00 <jchia_> but i can use * between Int and Pico
09:21:02 <EvanR> or fromInteger
09:21:02 <jchia_> can't
09:21:28 <ertesx> jchia_: so if x and y have different units, you may have to convince haskell that x*y = y*x from time to time
09:21:33 <asenn> Not sure if good channel for install questions, but looking for info on Silent Install of the 8.0.1 Windows Client, using /S /D=  Does not seem to go fully silent as still get a Window
09:21:36 <EvanR> > (fromIntegral (3 :: Int)) * (3 :: Pico) 
09:21:38 <lambdabot>  9.000000000000
09:22:04 <Welkin> aren't they bot Num?
09:22:07 <Welkin> both*
09:22:19 <EvanR> you still cant multiply two Nums that are different types
09:22:27 <adarqui> weird.. out of nowhere, haskell-vim-now is removing my {-# LANGUAGE BangPatterns #-} pragma wtf? hah. everything else is fine. wierd/funny.
09:22:27 <Welkin> oh, yeah
09:22:37 <glguy> asenn: No, this is only a good channel for questions about Haskell programming
09:22:38 <jchia_> EvanR: yeah, I could do that, but it'll be nice to have a concise way to express it.
09:22:52 <Welkin> guillaum2: never heard of it. Looks like some made up example
09:22:54 <EvanR> jchia_: for conversions, that is how you do it
09:23:01 <EvanR> for unit math, there are type families
09:23:06 <jchia_> in C++ i would do operator overloading
09:23:19 <EvanR> * is already overloaded
09:23:27 <EvanR> Haskell eschews implicit conversions
09:23:47 <dmwit> > zipBind [1] (\x -> [])
09:23:49 <lambdabot>  []
09:24:02 <EvanR> you can of course make a complex sum type of numbers that implements a javascript style strategy to do implicit coercion
09:24:16 <EvanR> its just not popular, probably not worth the effort
09:24:21 <asenn> kk thanks
09:24:27 <jchia_> c++ overloading works differently. Would I be able to define my own function 'times' that can automatically do the conversion i want?
09:25:03 <merijn> Haskell doesn't have overloading at all, so the overloading doesn't work differently. It doesn't exist :)
09:25:16 <ertesx> jchia_: do you want to convert between representation types (Int vs. Double) or units (meters vs. inches)?
09:25:19 <jchia_> yeah, i suppose calling it overloading is not accurate
09:25:33 <implementation_> you can implement the typeclass Num and write your own implementation for *. but you won't have conversion.
09:25:34 <jchia_> i want to define
09:25:43 <Welkin> adhoc polymorphism
09:25:47 <Welkin> is what it is
09:25:54 <srhb> merijn: I think the authors of the report would be sad if you didn't consider ad hoc polymorphism overloading.
09:26:05 <jchia_> times:: Distance -> Force -> Energy
09:26:05 <jchia_> times :: Force -> Distance -> Energy
09:26:05 <jchia_> ...
09:26:21 <jchia_> Welkin: I think that's right, i want ad-hoc polymorphism, but i think haskell only has parametric
09:26:29 <Welkin> jchia_: no, haskell has both
09:26:34 <merijn> srhb: Certainly not overloading in the C++ sense
09:26:41 <Gurkenglas> Looks like a case for dependent types keeping track of the units?
09:26:43 <Welkin> type classes give you adhoc
09:26:44 <srhb> merijn: Agreed (I think it even explicitly says that.)
09:26:54 <ertesx> jchia_: times :: MyNum u1 -> MyNum u2 -> MyNum (u1 * u2)  -- that's not conversion, but using type families to compute the proper unit
09:27:01 <glguy> I'd be impressed if the Report could be sad
09:27:14 <srhb> glguy: I think you accidentally a word. :-P
09:27:43 <ertesx> you don't need dependent types for units, but you do need a lot of patience, because you're likely going to convert a lot
09:27:46 <glguy> It'd be more impressive if the report itself was
09:27:51 <srhb> Yes! :-)
09:28:07 <EvanR> ertesx: as far as units go, you dont need explicit conversions in there
09:28:12 <jchia_> OK, I'll think about these some more. Thanks for the discussion. i gotta go
09:28:13 <implementation_> write a typeclass like:   class Multipliable a b c | a b -> c where  (*.) :: a -> b -> c    and then you can instantiate  Multipliable Distance Force Energy, which gives you  (*.) :: Distance -> Force -> Energy
09:28:20 <EvanR> just multiply by a conversion factor, and let type families do their thing
09:28:36 <mniip> implementation_, ewwww
09:28:37 <ertesx> MyNum (Meters * Seconds) and MyNum (Seconds * Meters) don't agree, and it's not quite straightforward to make them agree
09:28:46 <mniip> | a b -> c, a c -> b, b c -> a, please
09:29:11 <mniip> this is not C++, inference works both ways
09:29:14 <implementation_> yeah, okay, that's better
09:29:54 <EvanR> define a different * which is like Num a => T a u1 -> T a u2 -> T a (MultUnits u1 u2)
09:30:16 <hpc> and type family MultUnits u v?
09:30:23 <ertesx> are we naming types T again? =)
09:30:24 <EvanR> yeah
09:30:30 <EvanR> Const, something
09:30:47 <mniip> :k Const
09:30:48 <EvanR> PhysicsYo a u
09:30:49 <lambdabot> * -> k -> *
09:30:54 <mniip> okay then
09:30:57 <hpc> i think if you did that you could get away with just u1 -> u2 -> MultUnits u1 u2
09:31:05 <EvanR> no
09:31:12 <EvanR> * would do the multiplication
09:31:20 <EvanR> of numbers
09:31:49 <ertesx> hpc: you'd repeat all of that logic to go from MultUnits u1 u2 to T (u1*u2) a
09:32:04 <ertesx> s/T/PhysicsYo/
09:33:54 * hackagebot hpack-convert 0.14.6 - Convert Cabal manifests into hpack's package.yamls  https://hackage.haskell.org/package/hpack-convert-0.14.6 (yamadapc)
09:38:54 * hackagebot bookkeeper 0.2.0.0 -   https://hackage.haskell.org/package/bookkeeper-0.2.0.0 (jkarni)
09:46:42 <nmdanny> Question: If I have a certain ADT/record, and I want it to be compared to others based on a certain field (e.g when storing that ADT in a set), would the idiomatic way to do this be implementing the Eq and Ord instances myself?
09:47:33 <EvanR> you can customize the default Eq and Ord using a newtype
09:47:48 <EvanR> kind of annoying but kind of the only way with the way Set and Map are
09:48:12 <nmdanny> im actually setting up these datatypes from scratch, so I don't have to use a newtype
09:48:51 <EvanR> but the defaults might be useful for some other purpose, or not
09:54:12 <MarLinn> Knowing our community I would not be surprised if there where SetBy and MapBy ADTs with customizable comparison functions out there somewhere
10:04:18 <nmdanny> How can I see every unqualified function available in my file?
10:04:49 <nmdanny> (I imported classyPrelude and I'm looking for a function that does something..)
10:05:44 <MarLinn> nmdanny: ":t ClassyPrelude." + <tab>
10:06:30 <nmdanny> is there any way to filter that output? 
10:06:31 <geekosaur> I think they want :browse, actually
10:06:36 <mniip> I just made something weird...
10:07:45 <MarLinn> :browse just gives you the local definitions, not the ones from libraries
10:07:58 <mniip> :browse ClassyPrelude
10:08:15 <mniip> that's kinda most of the point of it
10:08:20 <nmdanny> is there a way to filter output from :browse ClassyPrelude, something like grep?
10:08:29 <MarLinn> Ok, I didn't know about that
10:09:40 <nmdanny> or rather, can I have hoogle search a specific library?
10:09:41 <glguy> nmdanny: Terminals often allow you to search e.g. Command-F on Terminal.app
10:10:09 <haldean> r
10:10:27 <geekosaur> there isn't a filter built in. there are ghc add-ons that provide that capability via :cmd
10:10:42 <nmdanny> ^right, I forgot that, though I'm using the integrated terminal in emacs which is pretty confusing
10:11:32 <mniip> int-e, so are we using GHC-8.0 now?
10:11:36 <mniip> what about TypeInType
10:14:47 <dmwit> nmdanny: `echo :browse ClassyPrelude | ghci | grep` ;-)
10:15:09 <dmwit> nmdanny: And yes, you can have hoogle search a specific package by adding `+package-name` to the search.
10:15:32 <sal23> hello, any one familiar with ghcjs here? Will appreciate help with this FFI question regarding callback - if we have a javascript function that can return either success or failure, how can we wrap it in Either using callback? 
10:15:32 <dmwit> nmdanny: The online Hoogle may not have indexed your particular package; in that case, you can install hoogle locally, and cabal has some integration with hoogle I think.
10:15:33 <mniip> so um
10:15:56 <mniip> I just made this
10:16:09 <mniip> what :: forall (a :: forall k. k). a; what = what
10:16:22 <mniip> ghci tells me: what :: a *
10:16:37 <Profpatsch> cabal-install as library?
10:16:38 <mniip> what *is* this after all >_>
10:16:40 <Profpatsch> want
10:18:23 <nmdanny> dmwit, is it possible to make that search recursive, aka, search modules re-exported by a certain library?
10:18:48 <dmwit> nmdanny: When you say "library", do you mean "module" or "package"?
10:18:58 <Gurkenglas> lpaste.net/7402444463290712064 why doesnt this work?
10:18:59 <nmdanny> module
10:19:07 <dmwit> nmdanny: If "module", that is the default. If "package", I don't understand the question.
10:20:04 <nmdanny> ok, the "ClassyPrelude" module(of the "classy-prelude" package), exports modules such as "Data.Containers", "Data.Foldable" etc..
10:20:32 <nmdanny> so basically I want to search inside the ClassyPrelude module and in all modules reexported by it
10:21:00 <dmwit> Yes, `:browse` does that.
10:21:09 <nmdanny> in hoogle
10:22:19 <dmwit> I don't know that Hoogle supports that, no.
10:22:31 <geekosaur> Gurkenglas, because "Uploaded	Wed Aug 24 16:34:37 UTC 2016" but "Commercial Haskell all-cabal-hashes Travis job Update from Hackage at 2016-08-23T20:48:01+0000"
10:22:55 <dedgrant_> mniip: (a *) = (a Type) meaning the type of all types that can apply Type? :D
10:23:16 <mniip> dedgrant_, I'm afraid it's something else
10:23:25 <mniip> and some code in GHC knows that but some other code doesn't
10:23:52 <dedgrant_> Uh oh'
10:23:55 <Gurkenglas> Can I update my local cabal hashes from hackage?
10:23:56 * hackagebot language-conf 0.2.2.0 - Conf parsers and pretty-printers for the Haskell programming language.  https://hackage.haskell.org/package/language-conf-0.2.2.0 (yamadapc)
10:24:03 <mniip> what :: (a{tv a19a} [sk] :: forall (k{tv a17Z} [tv] :: *). (k{tv a17Z} [tv] :: *)) *
10:24:35 <geekosaur> I don't think so since it's expecting additional metadata generated by the travis job
10:24:40 <mniip> the ' ' applies a kind-forall here, not a kind-(->)
10:24:58 <dedgrant_> mniip: Maybe worth bringing up at least on the cafe mailing list, if not the ghc list?
10:25:54 <ettev> Is there a way to make QuickCheck keep going for a fixed number of iterations and print all failures rathen than abort on the first failure?
10:27:01 <dedgrant_> mniip: So you read (a *) as "a for all *"? This is new to me.
10:27:21 <mniip> no
10:27:23 <mniip> it's more like
10:27:25 <mniip> a @Type
10:28:13 <mniip> except
10:28:19 <mniip> you can't fit 'what' into an id
10:28:30 <dmwit> dedgrant_: No, you read `a *` as `(a :: forall k. k) * ~ a :: (k[*/k]) ~ a :: *`
10:28:50 <dedgrant_> I should go re-read the type-in-type changes again.
10:29:51 <mniip> to be honest
10:30:00 <mniip> I have no idea what that type is
10:30:24 <dmwit> mniip: It seems to be like this declaration should be rejected as not kind correct.
10:31:09 <dmwit> mniip: i.e. we should check whether `what` can be given a type whose kind is `(a :: forall k. k)` -- which it can't -- and it should therefore be an error.
10:31:27 <dmwit> Or rather, a type whose kind is `forall k. k`.
10:31:42 <mniip> RankNKinds :D/D:
10:31:43 <dmwit> s/seems to be/seems to me/
10:32:04 <mniip> ImpredicativeKinds
10:33:05 <geekosaur> IncoherentKinds
10:33:25 <mniip> AllowAmbiguousKinds?
10:34:18 <int-e> mniip: yes, lambdabot is on ghc 8.0.1 now
10:34:24 <dedgrant_> Ahh the forall parity always throws me for a loop.
10:34:37 <mniip> int-e, what about TypeInType
10:36:16 <int-e> I have no opinion yet
10:36:20 <nmdanny> Is it possible to perform list-like pattern matching on container types (e.g Vector,Seq,Set)?
10:36:43 <mniip> int-e, opinion?
10:37:14 <mniip> is there anything blocking you from including TypeInType in Pristine.hs?
10:38:07 <ongy> nmdanny: if you have access to the constructors. But in general: no
10:38:25 <geekosaur> nmdanny, OverloadedLists can do that provided the container has an IsList instance
10:40:12 <Gurkenglas> Bah Im stupid I can just clone the github repos
10:42:33 <nmdanny> @pl \u -> _userName u == name
10:42:33 <lambdabot> (line 1, column 7):
10:42:33 <lambdabot> unexpected "_"
10:42:33 <lambdabot> expecting lambda abstraction or expression
10:43:57 * hackagebot uri-encode 1.5.0.5 - Unicode aware uri-encoding.  https://hackage.haskell.org/package/uri-encode-1.5.0.5 (AdamBergmark)
10:44:16 <Gurkenglas> Can you make travis provide a link to the haddocks it built?
10:48:07 <int-e> mniip: what's stopping me is ignorance, basically... I have yet to find out what the extension does.A
10:48:36 <mniip> int-e, * :: *
10:49:06 <int-e> I'll find out but it's not going to happen today.
10:49:14 <mniip> okay
10:49:28 <mniip> it's my favourite extension after MagicHash nowadays :p
10:50:00 <ongy> Kind of type Kind?
10:50:04 <mniip> int-e, among other things you can write
10:50:16 <mniip> type family KindOf a where KindOf (a :: k) = k
10:50:24 <shachaf> Does TypeInType let you write unsafeCoerce?
10:50:43 <mniip> shachaf, there's nothing in the idea pointing to that
10:50:48 <mniip> if it does it's probably a bug
10:51:59 <mniip> fancy how safe haskell is so fragile
10:52:09 <mniip> ex unsafeCoerce/unsafePerformIO quod libet
10:53:53 <int-e> well, it's by design... if the type system can be broken, leveraging the type system for safety is futile.
10:55:00 <mniip> we need a class of functions
10:55:10 <mniip> where each function can be implemented in terms of each other
10:55:21 <mniip> and the class includes unsafePerformIO
10:55:38 <mniip> so we can say things like
10:55:44 <mniip> unsafeCoerce is ???-complete :p
10:55:55 <Gurkenglas> ??? = unsafeCoerce, done
10:56:01 <mniip> okay
10:56:15 <mniip> unsafePerformIO is unsafeCoerce-complete
10:57:44 <mniip> IO^-1 is unsafeCoerce-complete
10:57:59 <Gurkenglas> Actually isn't everything expressible using unsafeCoerce?
10:58:00 <mniip> or not
10:58:08 <mniip> Gurkenglas, the inverse has to hold too
10:58:12 <Gurkenglas> I know
10:58:21 <Gurkenglas> But maybe we just want to say complete or maximally complete
10:59:06 <mniip> also I don't think so
10:59:22 <Gurkenglas> (or "inconsistent" because principle of explosion)
10:59:23 <hpc> unsafeCoerce can't express changing bytes of memory
10:59:36 <mniip> hpc, well actually
10:59:42 <mniip> that isn't true either
10:59:49 <hpc> oh right that whole thing
10:59:56 <hpc> this is like the third time you've reminded me of it
11:00:09 <mniip> of the RTS' existence?
11:00:18 <int-e> implementing unsafePerformIO with unsafeCoerce (but without the ST monad) is actually a bit tricky because of the void state tokens.
11:00:36 <hpc> the weird RTS type system stuff
11:01:22 <mniip> well yes
11:01:29 <mniip> I was thinking of runST
11:01:44 <int-e> @let import Control.Monad.ST
11:01:46 <lambdabot>  Defined.
11:01:50 <int-e> hmm, okay.
11:05:50 <mniip> int-e, hmm I can write IO a -> b
11:05:58 <mniip> in the sense that it crashes right after executing IO
11:06:12 <mniip> with an unsafeCoerce to '() -> a'
11:07:03 <mniip> > case (# #) of (# #) -> ()
11:07:06 <lambdabot>  ()
11:07:11 <mniip> oh
11:07:15 <mniip> with unboxed tuples that's just
11:07:28 <mniip> :t \x -> case (Unsafe.Coerce.unsafeCoerce :: IO a -> () -> (# GHC.Prim.State# b, a #)) x () of (# _, s #) -> s
11:07:30 <lambdabot> IO a -> a
11:08:34 <int-e> mniip: I have this old paste... have not tested it on newer ghc versions; the basic idea is to fix the balance of void tokens using IO's >>=: http://lpaste.net/74498
11:08:57 <mniip> it is safe to coerce a 'VoidRep -> k' function into a 'PtrRepLifted -> k' because the value in R1 is just discarded
11:09:24 <int-e> mniip: but indeed, unboxed tuples offer a clean solution
11:09:37 <mniip> balance of void tokens?
11:09:53 <mniip> you mean trying to maintain linear lambda calculus over State# RealWorld?
11:10:19 <int-e> mniip: something like that
11:10:34 <mniip> why
11:13:02 <Gurkenglas> How bad would it be to make a version of StateT that allows concurrency by actually being ReaderT . TVar?
11:13:22 <Gurkenglas> (with its own MonadState instance)
11:13:48 <johnw> Gurkenglas: I've used that pattern often
11:13:49 <peteretep> My God, it lives! I have a model that can accurately describe and implement imperative languages test suites
11:13:51 <shachaf> If you have GHC without any IO primitives or anything from the Prelude, and you can't import any modules, what can you do?
11:14:06 <shachaf> Oh, and you have unsafeCoerce.
11:14:08 <shachaf> Can you execute arbitrary code? Seems tricky.
11:14:10 <dolio> dmwit: The declaration is okay. in `what :: forall (a :: forall k. k). a` the occurrence of a has been instantiated with k = * so that it has kind *. Which is probably also why the reported type is `a *`.
11:14:22 <jle`> Gurkenglas: it's a nice type, but the MonadState instance might break some expectations
11:14:26 <Roxxik> Shachaf cffi?
11:14:28 <Gurkenglas> (And probably there should be a version for each of TVar, MVar and IORef?)
11:14:28 <hpc> you can coerce bytestrings into instructions maybe?
11:14:33 <shachaf> No FFI, of course.
11:14:39 <shachaf> You don't have ByteStrings.
11:14:44 <hpc> ah right
11:14:45 <glguy> Integer?
11:14:48 <jle`> Gurkenglas: i say might because there aren't official laws, but there are some unofficial laws floating around
11:15:40 <Gurkenglas> jle`, like, modify f >> modify g == modify (g . f)?
11:15:54 <Gurkenglas> Which would be different for this instance because it would be two atomic transactions?
11:16:04 <int-e> Gurkenglas: I would also be worried about updates getting lost. get s; do stuff; put s'
11:17:03 <Gurkenglas> Perhaps "zoom id" could be used to denote atomic modifications
11:17:03 <int-e> (this is related to the composition law, obviously)
11:17:06 <jle`> Gurkenglas: yeah, that would no longer hold
11:17:24 <Roxxik> int-e then use Stm to compose your actions and them work on a shared state 
11:17:53 <int-e> Roxxik: it's not my idea. I'd use ReaderT (TVar s) ... which is basically what you suggest
11:17:58 <jle`> Gurkenglas: also put s >> get == put s >> return s is a law i hear floating around
11:18:11 <jle`> get >>= put = return ()
11:18:54 <johnw> get >>= put = return () should still be true, because he's not modifying the TVar in that operation
11:19:07 <jle`> `do x <- get; y <- get; f x y` == `do x <- get; f x x`
11:19:09 <Gurkenglas> Another thread might.
11:19:16 <johnw> but you're not inspecting it
11:19:21 <jle`> johnw: ah yeah that's true
11:19:39 <jle`> the ones i mentioned came from https://hackage.haskell.org/package/ClassLaws-0.3.1.0/docs/Control-Monad-State-Class-Laws.html but i don't think they're official anyways
11:19:50 <Gurkenglas> But it's not "return ()" because it has the side effect of deleting whatever operations other threads did in the meantime
11:20:04 <johnw> unless you are intending to incorporate effects into your MonadState instance, which then I think could be bad
11:20:23 <johnw> but if your "state" is just the TVar itself, and not its contents, then you're fine
11:20:34 <johnw> otherwise, I think you're being too magical
11:20:42 <Roxxik> Hmm i dont use Stm that offen. ..would have to look into this for a moment. .. but i think that concurrent state modifications are only useful if the actions you compose are order independent 
11:20:49 <johnw> plus, you'd need to invoke atomically every time you'd want to call get or put
11:21:20 <mniip> int-e, reading cmm leads me to believe that unsafeCoerce :: IO a -> () -> a, should work, but it does not
11:21:35 <Gurkenglas> Well obviously it's the contents, the user would not be supposed to know there's TVars involved... except to make him familiar with the atomically stuff.
11:21:51 <johnw> yeah, i'd suggest not doing that
11:22:58 <mniip> Gurkenglas, might want to read the accursedUnutterableUnsafePerformIO story
11:23:10 <johnw> better to hide the TVar in another way, like Cale's trick of passing around a function from (a -> STM ()) and another (STM a)
11:23:25 <Gurkenglas> No Unsafe in there!
11:23:30 <mniip> https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs#L527
11:28:12 <jle`> peteretep: congrats!
11:28:45 <peteretep> Thanks. It almost killed me.
11:32:25 <mniip> int-e, oh
11:32:35 <mniip> apparently that unsafeCoerce would work in compiled code
11:32:40 <mniip> but not in ghci bytecode
11:32:49 <mniip> which is why Cmm showed no issues
11:38:16 <dmwit> dolio: I don't understand your comment to me about why `what :: forall (a :: forall k. k). a` is okay.
11:38:34 <dmwit> dolio: Would you say `what :: forall a. a; what = 3` is okay because `a` has been instantiated to `Int`?
11:39:00 <dmwit> dolio: If not, then what makes it okay to say `what :: forall (a :: forall k. k). a; what = what` is okay because `k` has been instantiated to `k`?
11:39:01 <mniip> what = what; places no restrictions on the kind of 'what'
11:39:03 <dolio> No, but that example isn't the same at all.
11:39:12 <mniip> well
11:39:18 <mniip> yeah that
11:39:21 <dmwit> mniip: Yes, it does. It restricts the type of `what` to have kind `*`.
11:39:45 <mniip> dmwit, what about 'undefined' then
11:39:49 <dmwit> same
11:39:58 <dmwit> The type of `undefined` has kind `*`.
11:40:07 <mniip> hmm
11:40:08 <mniip> tricky
11:40:16 <dolio> dmwit: what has type `forall (a :: forall k. k). a`.
11:40:20 <mniip> depends on if we include HasCallStack => in the type
11:40:29 <dmwit> dolio: I don't know of anything with that type.
11:40:50 <dolio> what does.
11:41:03 <byorgey> who's on first?
11:41:08 <mniip> which might also explain why the definition of 'undefined' is allowed
11:41:17 <dmwit> dolio: Okay. Why is it okay for what to have that type?
11:41:19 <mniip> because it's a function from HasCallStack to something
11:41:40 <dolio> dmwit: Anyhow, your analogy is wrong, because the correct analogy is like saying that 'foo :: (forall a. a) -> Int ; foo x = x' is fine.
11:42:02 <dolio> It's fine for x, which has type 'forall a. a' to be used such that it also has type Int.
11:42:18 <mniip> dolio, are you saying that 'forall k. k' is a specialization of *?
11:42:25 <dolio> And it's fine for a, which has kind `forall k. k` to be used in a spot where it must have kind *.
11:42:36 <mniip> hmm
11:42:38 <merijn> mniip: A type that has ALL kinds, necessarily also has kind *
11:42:45 <mniip> dolio, might have said that initially
11:42:46 <merijn> mniip: Therefore it can always be specialised to *
11:43:08 <mniip> dolio, that explains everything
11:43:09 <dolio> Which is what is happening in the type of `what`.
11:43:30 <mniip> except that, well,
11:43:35 <mniip> we don't have RankNKinds
11:43:39 <mniip> and what doesn't kindmatch with anything
11:44:00 * hackagebot bookkeeper 0.2.1.0 - Anonymous records and overloaded labels  https://hackage.haskell.org/package/bookkeeper-0.2.1.0 (jkarni)
11:45:05 <dmwit> dolio: No, I don't think your example is a good analogy. The analog of what you say would be something like `type family Foo :: (a :: forall k. k) -> *; type instance Foo a = a`.
11:45:40 <mniip> which is exactly what is happening here
11:46:14 <mniip> what :: forall (a :: _). Foo a
11:46:17 <dmwit> No, `forall` is not the same as a type-level function.
11:46:29 <dmwit> There is no `Foo` in the signature you gave, or else it would be a different story!
11:46:45 <mniip> dmwit, turn on visible type application
11:46:52 <mniip> type instance Foo a = a @*
11:47:06 <mniip> what :: forall (a :: forall k. k). a @*
11:47:20 <dmwit> oh
11:47:24 <dolio> dmwit: It's better than yours, because my example involves instantiating a universal, and yours involves ascribing a too-polymorphic type to a concrete thing.
11:47:41 <dmwit> dolio: I agree my analogy was crappy, too.
11:47:43 <dolio> And what's happening in `what` is instantiating a universal.
11:48:09 <dolio> But because we're at the type level, there are pis, which don't have any analogue at the value level.
11:48:19 <dmwit> Anyway, I understand why it's okay now. mniip's comment about GHC inserting an implicit application cleared it up.
11:48:41 <dmwit> dolio: Thank you to you as well for the explanations.
11:53:19 <dmwit> Wow, that ties my head in knots even after it's explained.
11:53:27 <dolio> Yeah, it's really weird.
11:54:34 <dolio> If we had Agda-like pi syntax, you could also write it like: (x :: forall a. a) -> x
11:56:35 <mniip> aha
11:56:43 <mniip> so it's not an application
11:56:53 <mniip> it just shows up as one in output
11:57:11 <mniip> or... if it is it might be ill-kinded
11:57:37 <byorgey> there is still an implicit application happening
11:57:50 <mniip> I mean
11:57:57 <mniip> it's not the same space as in 'Maybe Int'
12:00:16 <dolio> It's instantiation.
12:00:20 <mniip> yes
12:00:39 <dolio> In some systems that's the same thing as application.
12:00:49 <byorgey> OK, fair
12:00:50 <mniip> true
12:03:00 <mniip> ok what
12:04:00 * hackagebot wai-route 0.3.1.1 - Minimalistic, efficient routing for WAI  https://hackage.haskell.org/package/wai-route-0.3.1.1 (romanb)
12:04:45 <mniip> :kind! forall k (a :: forall k. k). (a ::: *) => Proxy a
12:04:45 <mniip> = forall (k :: GHC.Prim.Any) (a :: forall k1. k1). GHC.Prim.Any ~ * => Proxy (a GHC.Prim.Any)
12:05:14 <mniip> type family (:::) (a :: k) (l :: *) where (:::) (a :: k) (l :: *) = KindOf a ~ l
12:05:15 <mniip> type family KindOf (a :: k) :: * where KindOf (a :: k) = k
12:08:20 <ph88> hey guys, when my parser makes an error how can i move forward in the string that i'm parsing and continue parsing?  https://paste.fedoraproject.org/413523/20655861/
12:09:37 <johnw> do you want to just ignore the error and skip the text it failed parsing, or retry with another parser?
12:10:25 <mniip> dmwit, dolio, I suppose we could prod goldfire for answers
12:10:26 <reqq456> http://stackoverflow.com/questions/26415122/unable-to-compile-writer-monad-example-from-learn-you-a-haskell
12:10:43 <reqq456> could someone tell me what the right thing in ghc 8.0.1 is?
12:11:10 <ph88> johnw, i want to collect the error in State, skip text till next new line and continue with the same parser
12:11:18 <mniip> reqq456, see the first answer
12:12:03 <johnw> ph88: you'll need to upgrade to ParsecT for that, and then use <|> plus a parser that knows to "consume" the text you want to skip
12:12:10 <reqq456> how stupid, thx
12:12:29 <johnw> for example: (parserA <|> (reportError "foo"; skipText; parserB))
12:12:50 <johnw> note that depending on how parserA is written, it may already skip some of the text
12:13:13 <ph88> johnw, sorry i copy paste the wrong source code, i will prepare a new pastebin
12:14:48 <Gurkenglas> An old commit doesnt build using stack build, probably because some bounds were too wide and new versions broke compatibility. Can I tell stack to use the earliest versions that fit into the bounds?
12:15:59 <ph88> johnw, i used the State monad on line 99  https://paste.fedoraproject.org/413530/72066115/
12:16:26 <johnw> but you're still not using ParsecT
12:16:34 <johnw> which you'd need to, to be able to modify that state within your parsers
12:16:37 <ph88> johnw, i'm using megaparsec not parsec
12:16:41 <johnw> ah, then i can't help
12:16:47 <ph88> :(
12:17:25 <cocreature> megaparsec also has a ParsecT type
12:17:38 <cocreature> it doesn’t include a state so you will need to put it ontop of a state monad
12:18:31 <ph88> didn't i do that ?
12:18:41 <cocreature> sorry I haven’t been following too closely
12:18:50 <mniip> reqq456, oh wait
12:18:59 <mniip> you can just write
12:19:01 * hackagebot bookkeeper 0.2.1.1 - Anonymous records and overloaded labels  https://hackage.haskell.org/package/bookkeeper-0.2.1.1 (jkarni)
12:19:05 <mniip> type Writer w a = (w, a)
12:19:29 <mniip> or data Writer w a = Writer (w, a) deriving (Functor, Applicative, Monad)
12:21:24 <johnw> ph88: if you just want to accumulate errors, you can use Writer instead of State
12:21:41 <ph88> yes i know, i will change to Writer later
12:21:46 <johnw> k
12:21:48 <ph88> but i think it's not the main issue where i'm stuck
12:22:01 <cocreature> ph88: which function is supposed to set the state?
12:22:05 <cocreature> or rather which parser
12:23:06 <ph88> i haven't thought about that yet .. 
12:27:13 <thomasd> can someone help me with a types question?
12:27:25 <dmj`> thomasd: only if you ask it :)
12:27:31 <ph88> cocreature, well .. the parser for 1 line is "equation" .. so i guess i can make a wrapper parser there that if equation doesn't match it will use a parser that goes till end of the line and also set some state ... but how can i get the error out of the first parser ?
12:27:47 <thomasd> I have several types that I want to remain their own, not just different constructors of the same type
12:28:08 <thomasd> however, I do want the types to have some sort of signifier that they are similar
12:28:10 <dfeuer> Oh boy... I got an internal error in GHC.
12:28:12 <thomasd> like a type class
12:28:21 <thomasd> but I don't necessarily need the type class to have any functions...
12:28:37 <thomasd> I just want some way of saying "These types are 'Reports'"
12:28:49 <johnw> thomasd: you can create another type that relates them
12:28:55 <thomasd> so like 
12:28:59 <johnw> data MyTypes = TypeA Foo | TypeB Bar | TypeC Baz
12:29:09 <thomasd> yeah... I thought about that
12:29:13 <thomasd> guess it's the best decision
12:29:21 <johnw> this is a common trick for limited heterogeneity
12:29:28 <thomasd> the reason I don't really want that, is that TypeA and Foo would be basically redundant
12:29:37 <johnw> they are, and they aren't
12:29:40 <thomasd> I have two types "ClientReport" and "SentimentReport"
12:29:45 <johnw> you can still write functions in terms of Foo that don't need to consider Bar
12:29:47 <thomasd> so basically I'd do
12:30:00 <thomasd> data Report = ClientReport ClientReport | SentimentReport SentimentReport
12:30:05 <johnw> yes
12:30:13 <johnw> now you can either have functions on ClientReports or functions on Reports
12:30:27 <thomasd> yeah ok, something about that just doesn't feel "pretty", but I'll get over it
12:30:27 <thomasd> thanks
12:30:38 <jle`> thomasd: are you talking about picking names for the constructors?
12:30:56 <thomasd> no, just whether it's the best approach for what I want to do
12:31:02 <johnw> thomasd: you could try another trick for encoding "members of a type set"
12:31:23 <thomasd> a trick, huh?
12:31:54 <johnw> data Report = Report; type family ReportType where ClientReport = Report.  And then some function report :: forall a. ReportType a ~ Report => ...
12:32:06 <johnw> I haven't thought it out fully, but there should be a way to assert that 'a' can only be a type within a closed set
12:32:22 <cocreature> ph88: set the state in "recover"
12:32:26 <johnw> it's like the methodless type class you mentioned
12:32:27 <jle`> hm. well, if we're going to go there
12:32:51 <jle`> you can use Data.Dependent.Sum from the dependent-sum package
12:33:02 <Jenaf> if i use : contents=readFile "file.txt"; contentLines= lines contents; I get an error that the type is IO String and not [Char]
12:33:10 <Jenaf> what can i do to fix this problem?
12:33:28 <jle`> and have data ReportType c where CR :: ReportType ClientReport; CS :: ReportType SentimentReport
12:33:30 <Jenaf> (It's the first time I use file input with haskell, so its a really noob question
12:33:51 <johnw> jle`: that requires a tag type which is almost the same ugliness as what we began with, no?
12:33:52 <jle`> and then type AnyReport = DSum ReportType
12:34:07 <jle`> ah yeah
12:34:14 <Gurkenglas> Jenaf, types that start with IO are recipes to construct a value of the type that follows. you need to use some special syntax to make one recipe use the output of another recipe
12:34:22 <jle`> i'm solving the wrong problem :)
12:34:38 <Jenaf> dang
12:34:44 <ph88> cocreature, then i make a parser   many rawData  so that i will get that parse or recover thing again and again and again ?
12:34:52 <Jenaf> I just need the contents of that file, it does nto change
12:35:05 <Jenaf> so i don't really need the whole IO stuff wou would need for pipes etc
12:35:10 <johnw> I guess in a real dependently-typed langauge, I'll just write a type-level predicate on types to return True if it was a report, which is kind of what I was aiming at with the closed type family
12:35:20 <Gurkenglas> Jenaf, here's some example syntax http://lpaste.net/7198190391516987392
12:35:35 <jle`> johnw: in the end you'd still need to pattern match
12:35:44 <jle`> to figure out what type of report you're dealing with
12:35:47 <johnw> yes, somewhere a pattern match needs to happen, that's unavoidable
12:35:50 <thomasd> Jenaf: do { contents <- readFile "file.txt" ; let contentLines = lines contents ; return contentLines ; }
12:35:53 <johnw> because we're making a decision about types
12:36:02 <Jenaf> thy, is there some kind of information on what the "<-" operator does there?
12:36:04 <jle`> but i guess picking the best way to state that predicate is the issue here
12:36:09 <thomasd> you need to retrieve the value from the IO type by using "<-"
12:36:15 <Jenaf> I don't just want it to work, I also want to understand it
12:36:25 <cocreature> ph88: I’m a bit confused about your code RawData already seems to contain an errrorcase, can’t you just use that rather than throwing in a state monad like you seem to be trying to do?
12:36:26 <thomasd> what don't you understand
12:36:37 <johnw> thomasd: "retrieve the value from the IO type" may be the  worst possible way to explain what <- means :)
12:36:47 <Jenaf> ^
12:36:47 <cocreature> and it also is already a list so many rawData might not be what you want
12:36:56 <thomasd> johnw: oh come on, WORST?
12:36:59 <jle`> Jenaf: you can have two IO actions sequenced one-after-the-other with ;, so do { readFile "file.txt"; putStrLn "hello" } would read the file, the print "hello"
12:37:00 <thomasd> maybe bad
12:37:07 <thomasd> the value is in the IO "context"
12:37:10 <thomasd> and the "<-"
12:37:11 <johnw> there are maybe worse ones that somehow associate IO to a political candidate
12:37:20 <jle`> Jenaf: however, this is a bit limiting, as you lose the result of readFile, and you can't use it later in your do block
12:37:28 <jle`> johnw: <- lets you name the result, and use it later on
12:37:40 <ph88> cocreature, yes i can do that for ONE error ... but i want to continue parsing and collect all the errors
12:37:59 <johnw> <- can be thought of as a form of "let" that respects the current monad
12:37:59 <jle`> so do { x <- readFile "file.txt"; more; actions; in; this; block ... }, is essentially the same thing, except now you can refer to 'x', the result of readFile "file.txt"
12:38:16 <ph88> cocreature, right now it works like this:  find error, go into recover, find second error, can not handle second error, parsing stops
12:38:28 <jle`> the same thing as sequencing the actions, at is.  it's sequencing, but letting you name the result so you don't lose it into the abyss
12:38:35 <Jenaf> is the <- operator in [x|x<-list,predicate x] the same operator or is it overloaded?
12:38:58 <johnw> let x = y in z  ==  (\x -> z) y      x <- y; z   ==  (\x -> z) =<< y
12:39:17 <jle`> it's a different operator, although there are some deeper similarities that aren't obvious
12:39:27 <Jenaf> okay
12:39:35 <jle`> but syntactically they are different operators, yes
12:39:40 <Jenaf> okay
12:40:05 <jle`> i actually would be careful about calling them operators because operators have a specific meaning in haskell.  not sure what i'd call it though.
12:40:10 <cocreature> ph88: why does it stop at the second error?
12:40:17 <jle`> *meaning in haskell syntax
12:40:40 <Jenaf> does it exchange livers?
12:40:49 <thomasd> isn't "<-" in list comprehensions the same operator as in do blocks, because list comprehensions desugar to do blocks?
12:41:06 <jle`> list comprehensions do not desugar to do blocks
12:41:06 <MarLinn> You can make the one from list comprehensions more general with a language extension. So in a way, it's a restricted version. But both are syntactic sugar.
12:41:18 <thomasd> "<-" in list comprehensions does the same thing it does when using "do" in the do blocks in the list monad
12:41:32 <cocreature> ph88: let me try to make a minimal example
12:41:42 <jle`> yeah, there is a link, but they're still different syntactical constructs
12:41:53 <thomasd> what do list comprehensions desugar to...
12:41:57 <Jenaf> I though that some things are really up to the compiler how to handle it?
12:42:09 <jle`> thomasd: there's a good description in the report :)
12:42:17 <jle`> s/report/Report
12:42:18 <thomasd> assuming do blocks and monadic function compositions with (=<<) are the same?
12:42:30 <Gurkenglas> He asked whether "<-" is overloaded when used in list comprehensions versus IO-do blocks, and the answer is yes right?
12:42:42 <MarLinn> They are not overloaded.
12:42:50 <MarLinn> They are sugar
12:42:55 <MarLinn> You can't overload sugar
12:42:58 <Gurkenglas> Is (+) overloaded when used in Int versus Double?
12:43:01 <thomasd> for what, MarLinn, don't make me look it up!
12:43:05 <thomasd> XD
12:43:08 <kadoban> thomasd: do blocks are desugared into (>>=) and such, yes.
12:43:16 <jle`> MarLinn: the lexical token <- is overloaded
12:43:19 <thomasd> and list comprehensions are... 
12:43:26 <MarLinn> Without any extensions, just some list functions
12:43:37 <MarLinn> map, filter, that stuff
12:43:42 <jle`> i think that was the question -- if the lexical token "<-" is overloaded in haskell syntax
12:43:46 <jle`> and it is, just like -> is
12:44:16 <jle`>  <- is also used in pattern synonym syntax and in pattern guard syntax
12:44:34 <jle`> there are some deeper similarities to their purpose, but in each case they are unique syntax constructs
12:44:35 <MarLinn> Ok, maybe I'm using the word "overloading" wrong XD
12:47:44 <geekosaur> you are likely imagining overloading like it works in c++ or java. what's happening in haskell is different and treating it like what happens in c++ can lead you into cul-de-sacs
12:49:03 * hackagebot proto-lens 0.1.0.2 - A lens-based implementation of protocol buffers in Haskell.  https://hackage.haskell.org/package/proto-lens-0.1.0.2 (gnezdo)
12:49:05 * hackagebot proto-lens-protoc 0.1.0.2 - Protocol buffer compiler for the proto-lens library.  https://hackage.haskell.org/package/proto-lens-protoc-0.1.0.2 (gnezdo)
12:49:28 <nitrix> Hi. I have a strange issue with a project that has multiple executables.
12:49:51 <nitrix> `stack ghci lspace` works perfectly fine, but `stack ghci` then picking `lspace` yields errors.
12:51:38 <Jenaf> so If I read a file and want to handle its contents i need it to be loaded in a do statement in main and then pass it through functions?
12:52:30 <geekosaur> or reachable via IO actions from main
12:53:17 <Jenaf> okay, thats a bit more typing ^.^
12:53:46 <ReinH> And indeed main does not need to be a do block, to complete the nitpicking.
12:53:46 <Jenaf> a single function with a lot of nested where blocks is considered evil?
12:54:03 <ReinH> Evil? No. Questionable? Probably.
12:54:14 <Jenaf> I got an error when trying to use the "<-" to get the contents from readfile into a string when not inside a do
12:54:20 <geekosaur> correct
12:54:35 <ReinH> Yes, you did.
12:54:42 <geekosaur> <- is not an operator, it is specific to "do" (and list comprehensions and a few other places)
12:55:27 <cocreature> ph88: there you go http://lpaste.net/180125
12:55:53 <Jenaf> I'll just write my code now and post a gist later
12:56:12 <Jenaf> I hope you guys can give me some hints on style / hidden unneeded overhead etc
12:57:34 <thomasd> oh we will give you so many hints
12:57:47 <thomasd> you have no idea
12:58:11 <nitrix> We're off a good start...
12:59:53 <MarLinn> Let's - do - the style - wars again... *sing*
13:03:27 <nitrix> I think the goal here is to share style suggestions with him (everyone having different style preferences) rather than looking for a winner.
13:05:03 <nitrix> Unless there was something implicit in his request that I didn't get. I'm not very good at doing interpretation or twisting people's words.
13:07:00 <Jenaf> can you do things like "foo :: [Int] -> [Int] -> t ; foo [a:b:rest1] [c:rest2]= smthn 
13:07:10 <Jenaf> (does this pattern match work?
13:07:24 <lyxia> (a : b : rest1)
13:07:31 <MarLinn> nitrix: Oh I really expect it to be civil. But I look forward to reading the discussion, maybe I can learn something
13:07:40 <ski> you probably meant `foo (a:b:rest1) (c:rest2) = smthn'
13:07:43 <Jenaf> parans and not "[" "]"?
13:07:49 <lyxia> [a:b:rest1] is a list containing one element, which matches the pattern (a : b : rest1)
13:07:51 <Jenaf> oh wait
13:07:53 <Jenaf> yeah
13:07:55 <ski> `[a:b:rest1]' is a list having a single element, which is also a list
13:08:07 <Jenaf> indeed sry brainfarted there for a moment
13:08:22 <ski> np
13:08:45 <ongy> he, I'm getting somewhere. My pulse package can do what I want it to do :) I have event based output of current audio :)
13:09:00 <ongy> audio-volume that is
13:09:19 <Jenaf> and foo [a,b] [c] would then match if the first list has 2 elements and the second only one?
13:09:49 <MarLinn> Jenaf exactly
13:10:16 <Jenaf> okay then the only abomination I'm not going to fix is that foo needs the first list to have exactly one more element than the second
13:10:35 <Jenaf> hehe I'm evil
13:11:12 <mniip> data AListAndAListOneShorter a = L [(a, a)] a
13:11:16 <hpc> if you're really evil you'd write foo :: [(a, b)] -> a -> c
13:11:39 <mniip> haha
13:11:44 <cocreature> hpc: that sounds like something you should add to acme-php
13:12:17 <Jenaf> oh I created other abominations b4
13:12:22 <hpc> it's lacking that special something
13:12:40 <cocreature> yeah it’s too obvious that the implementation is crap
13:13:14 <hpc> i think i might leave acme-php as-is unless i can come up with something to continue the theme of (<>) = getLine
13:13:17 <lpaste> RiverDance pasted “partially applied function troulbe” at http://lpaste.net/180128
13:14:09 <glguy> RiverDance: That's the Monomorphism Restriction
13:14:24 <glguy> RiverDance: Add an explicit type signature to the first listToNum and it should work without the xs
13:14:46 <Jenaf> I always ad signatures to my functions
13:14:53 <RiverDance> glguy: holy smokes you're quick haha. Thanks a lot.
13:14:55 <Jenaf> and then a little comment above about what the arguments are
13:15:05 <Jenaf> so I can remember what I wrote later
13:15:30 <Jenaf> also i got the feeling that signatures help me find errors when compiling/loading into ghci
13:16:51 <geekosaur> signatures help you find errors, period. if you get ghc/ghci infer types, a type error at one point in your program will usually get reported somewhere else
13:17:13 <MarLinn> hpc: rofl. I suppose you must have a cat to stroke while you're sitting in your evil mastermind chair. And/or a cloak. No one can be as evil without one of those.
13:17:17 <geekosaur> signatures help it realize where the error actually is, instead of where it finally notices things don't quite fit
13:18:07 <RiverDance> gluy: I added listToNum :: [Int] -> Int , however this did not appear to fix the issue when I compiled it.
13:18:27 <RiverDance> glguy: sorry spelled your name wrong
13:18:44 <glguy> RiverDance: then you'll have to paste the actual error
13:18:58 <glguy> RiverDance: It's possible [Int] -> Int isn't the type you needed it to have
13:19:40 <glguy> Maybe you were using it on Integer?
13:19:41 <ph88> thank you cocreature :)
13:19:53 <glguy> Double? Float? the error will guide us
13:21:51 <lpaste> RiverDance revised “partially applied function troulbe”: “partially applied function troulbe” at http://lpaste.net/180128
13:23:53 <RiverDance> glguy: I changed Int to Integer, and that worked
13:24:07 <RiverDance> glguy: thank you very much!
13:29:04 * hackagebot proto-lens-combinators 0.1.0.2 - Utilities functions to proto-lens.  https://hackage.haskell.org/package/proto-lens-combinators-0.1.0.2 (gnezdo)
13:37:03 <Jenaf> I get a parse error here
13:37:07 <Jenaf> and I do not know why:
13:37:11 <Jenaf> map (\line (map (\s -> (read s :: Int)) line)) theWords
13:37:37 <Jenaf> where theWords ::  [[String]]
13:37:54 <mniip> you forgot ->
13:38:01 <Jenaf> *facepalm
13:38:02 <ph88> is it possible to embed haskell code in a C program ?
13:38:04 <Jenaf> thy
13:38:11 <mniip> ph88, yes/kinda
13:38:25 <ph88> what's the kinda part ?
13:38:43 <mniip> if you're ready to include the whole RTS in your program
13:38:55 <mniip> that will do bad things to your address spaces, signal handlers, and whatnot
13:39:05 <ph88> like what bad things ?
13:39:08 <Jenaf> yay it worked
13:39:16 <Jenaf> gist incoming, tipps appreciated
13:40:37 <Jenaf> https://gist.github.com/anonymous/e93adf130d42cdb80e45d3d0833b1f2a
13:40:46 <mniip> ph88, well currently haskell programs allocate about 1 terabyte of memory
13:41:07 <ph88> o_O
13:41:39 <mniip> it's mapped as PROT_NONE right after the heap and isn't used
13:41:58 <mniip> as the heap is used it is mprotected and appended to the heap
13:42:32 <mniip> > 0x200100000-0x10200100000
13:42:35 <lambdabot>  -1099511627776
13:42:54 <ph88> don't know what you're talking about
13:42:57 <mniip> > (0x200100000-0x10200100000) / 1024 / 1024 / 1024
13:43:00 <lambdabot>  -1024.0
13:43:06 <mniip> exactly 1024 gibibytes
13:43:45 <ongy> ghc uses VMEM for a 2step allocator. This is also visible in htop
13:43:59 <ongy> if you have an application compiled with ghc-8.0
13:44:18 <MarLinn> Jenaf, first tip: work with all warnings activated
13:44:28 <Jenaf> huh?
13:44:38 <ongy> I'm not quite sure if that will interfer with your C code. But if you haven't read into vmem and mmap, I doubt it
13:44:42 <Jenaf> please elaborate
13:44:59 <ph88> well i don't have 1 TB of memory
13:45:04 <ph88> so i can't use haskell in c program ?
13:45:13 <mniip> I didn't say that
13:45:14 <MarLinn> ghci can give you warnings for things like unmatched patterns, missing signatures etc
13:45:15 <cocreature> ph88: that’s virtual memory
13:45:17 <cocreature> not physical memory
13:45:23 <ongy> ph88: you don't need 1TiB physical memory, that's virtual memory
13:45:35 <mniip> 200100000-10200100000 ---p 00000000 00:00 0 
13:45:36 <mniip> Size:           1073741824 kB
13:45:36 <mniip> Referenced:            0 kB
13:45:37 <cocreature> and that is not special to embedding haskell in a c program it happens for any haskell program (starting from 8.0 on linux)
13:45:44 <Jenaf> can't you just compile the haskell code to C and then copy and paste it? (hehehe best idea)
13:45:50 <mniip> that's saying that 0 bytes of physical memory is used to represent that mapping
13:45:53 <geekosaur> no, you can't
13:46:06 <mniip> Jenaf, not since 7.0 iirc
13:46:07 <Jenaf> MarLinn that would have propably warned my of the potential pitfall with dijkFrag
13:46:29 <MarLinn> Jenaf, jup.
13:46:37 <Jenaf> mniip: I gues that would also be a way to create horrible source files
13:46:38 <geekosaur> an unregisterised build, if it's working at the moment, could generate crappy but portable C code. otherwise ghc does not generate C code except for FFI stubs
13:46:56 * jonored wonders how that interacts with limited overcommit... (it's not the default, but it's doable.)
13:46:58 <mniip> Jenaf, haskell is nothing without an RTS
13:47:04 <Jenaf> MarLinn : what flag do I need?
13:47:09 <mniip> geekosaur, unregistered builds do work but do they emit C?
13:47:11 <Jenaf> mniip RTS?
13:47:16 <MarLinn> Jenaf: -Wall
13:47:17 <mniip> Jenaf, runtime system
13:47:20 <Jenaf> ah kk
13:47:25 <ph88> is it a good or bad idea to use haskell code from C ?
13:47:26 <MarLinn> Jenaf: also see if your editor has support for hlint. That gives you style tips like "Redundant bracket"
13:47:43 <Jenaf> I use notepad++
13:47:44 <geekosaur> mniip, unless someone completely reimplemented the unregisterised backend, it emits ANSI C
13:47:52 <mniip> the thing responsible for sequencing thunks, GCing your objects, managing your IO, and doing all of this in a multithreaded environment
13:48:05 <Jenaf> mniip: then paste the C code for the RTS, too; and that everytime when you need haskell code
13:48:15 <Jenaf> so you may end up running hundreds of RTSes
13:48:17 <Jenaf> hehe
13:48:20 <mniip> a good percentage of RTS is assembly
13:48:29 <MarLinn> Jenaf: sorry, I am familiar with it by name but I have no idea what it supports.
13:48:36 <Jenaf> k
13:48:51 <Jenaf> As far as I'm concerned its a basic text editor with some highlighting
13:48:58 <ongy> is jhc dead? or why did nobody mention that?
13:49:22 <Jenaf> also I sometimes saw other people use $ to get rid of parans, but I tend to get errors using it
13:49:30 <Jenaf> and I don't want to use soethign i do not understand
13:49:39 <EvanR> C, use more brackets just in case. haskell remove extra brackets just because. lisp more brackets will crash
13:49:42 <Jenaf> *something
13:49:51 <ongy> ok, last release 2010 looks a bit old
13:50:07 <geekosaur> jhc's effectively dead at this point, yes :(
13:50:40 <Jenaf> MarLinn any other obvious errors / code smells etc?
13:50:48 <geekosaur> maybe someone else will pick it up again (there was a fork ajhc for a while but it too fizzled)
13:51:23 <mniip> geekosaur, I'll go try building an unregistered ghc
13:51:43 <MarLinn> ($) is basically "assume everything to the right is in brackets". Under the hood it's function application (with some magic, but nobody must know)
13:51:53 <ReinH> (and to the left)
13:52:01 <ReinH> (unless there are multiple $)
13:52:12 <geekosaur> but I said "if it's working" because in the 7.8-7.10 timeframe you could build it but it was producing broken code, or something like that
13:52:13 <Jenaf> but with that assumption it kinda sometimes throws erros i don't understand
13:52:34 <geekosaur> $ is just function application with lowest precedence instead of highest
13:52:42 <geekosaur> and, for some reason, right associative
13:52:47 <ReinH> to annoy me
13:52:51 <ReinH> me particularly
13:52:52 <MarLinn> Yeah, it can get confusing
13:52:56 <dfeuer> It seems to annoy most people.
13:53:16 <dfeuer> Except people using $'s magic impredicative type.
13:53:17 <MarLinn> Jenaf: so from -Wall: dijkFrag is incomplete and main is missing a signature
13:53:38 <geekosaur> once you understand how precedence works, it's easy to use it without causing errors. if you try to just treat it as magic mind-reading parentheses, it will bite you
13:53:49 <Jenaf> dijFrag beeing incomplete is already in the comments ;)
13:53:53 <mniip> um
13:53:56 <mniip> I like $
13:54:03 <mniip> foo $ bar $ baz quux
13:54:09 <Jenaf> and main propably needs some standard signature I can copy from elsewhere?
13:54:11 <MarLinn> Jenaf, in getTriangleFromString you can drop the "line" parameter and use partial application instead
13:54:22 <geekosaur> and half the channel will tell you to rewrite using . :)
13:54:27 <mniip> dfeuer, impredicative?
13:54:41 <ongy> foor . bar . baz $ quux?
13:54:42 <jonored> $ is bash's | backwards :)
13:54:46 <Jenaf> MarLinn: that sounds interesting and reasonable, I need to think it through
13:55:19 <geekosaur> mniip, yes, try (runST  . something) vs. (runST $ something)
13:55:23 <dfeuer> mniip, well... if you have  f :: (forall a . .....) -> ..., then you can use  f $ p $ q just fine, but f . p $ q won't work.
13:55:28 <mniip> is that impredicative
13:55:38 <Jenaf> I'm not sure how to do it
13:55:39 <mniip> I mean I know what you mean but is it caled that
13:55:39 <dfeuer> Well, $ has an impredicative type.
13:55:46 <MarLinn> Jenaf, the type of "read" can be inferred, so you can even drop the "s"
13:55:52 <geekosaur> (.) isn't impredicative and will throw an error. ($) is recognized in the typechecker and forced to be impredicative
13:55:56 <dfeuer> Yes.
13:56:08 <dfeuer> Which is really a broken way to deal with this.
13:56:31 <Jenaf> so i could just say map read ["123123","222"]
13:56:35 <dfeuer> If we *really* want that special treatment, I think it should be done before the type checker sees it (actually putting in the parentheses).
13:56:37 <Gurkenglas> Does bottom count as an inhabitant, or can only maximally defined values be inhabitants?
13:57:00 <mniip> Gurkenglas, depends
13:57:06 <dfeuer> Gurkenglas, that depends on what you're doing and/or care about?
13:57:06 <Jenaf> I wasn't sure if it would end up in errors, so I went for better save then sorry and type explicitely
13:57:29 <MarLinn> Jenaf, in general, no. But you gave the whole function a signature, and that is enough for ghc
13:57:34 <dfeuer> Does GHC ever give memory back to the OS?
13:57:39 <Gurkenglas> Okay, just trying to make sure "Void is the type without inhabitants" wont get me thrown at with bottoms
13:57:53 <dfeuer> Gurkenglas, no guarantees :P
13:58:00 <dfeuer> You can't trust Haskellers.
13:58:10 <mniip> Gurkenglas, "with bottoms the Hask category becomes incredibly boring"
13:58:19 <mniip> (it's not even cartesian)
13:58:40 <Jenaf> MarLinn my gut feelign tells me that its "saver" to have that thing with an explicit type
13:58:41 <Gurkenglas> Wasn't there talk about it not even being a category?
13:58:47 <dfeuer> mniip, Haskell isn't consistent even without bottoms :/
13:59:06 <MarLinn> Jenaf, Absolutely.
13:59:07 <dfeuer> (once you toss in some extensions, anyway)
13:59:33 <Jenaf> also it could in some cases increase the readability of the code.
13:59:59 <dfeuer> mniip, once GHC's allocated a boatload of virtual address space, does it have any way to return long-unused memory to the OS? Does it ever try?
14:00:09 <MarLinn> Jenaf, yes. For example now that I've done that it seems apparent that you're doing two consecutive applications of "map" which you might want to combine. List fusion _should_ make both versions equally performant, but why rely on that
14:00:10 <johnw> Gurkenglas: there was a recent discussion, but it was more like, "If you want to call it a category, prove it."
14:00:25 <johnw> there was no proof that it wasn't some form of category
14:00:26 <mniip> dfeuer, no idea
14:00:37 <mniip> memory management is way outside my knowledge
14:00:58 <dfeuer> Hm.
14:01:02 <geekosaur> it tries to, in ghc8
14:01:12 <dfeuer> Cool. How's that work?
14:01:27 <Jenaf> MarLinn: I don't get that one, basically the [[Int]] is the structure wich represents the problem at hand best
14:01:40 <geekosaur> someone was actually having trouble with it the other week because the madvise call to tell the OS to reclaim a page was producing EINVAL
14:01:43 <dfeuer> I imagine it looks at the last few major collections to see if it's been greedy?
14:01:50 <Jenaf> ah wait
14:01:54 <MarLinn> Jenaf: shortest version I got is getTriangleFromString = map (map read.words) . lines
14:02:01 <Jenaf> you ment the map in the where clause?
14:02:07 <MarLinn> Yup
14:02:42 <Jenaf> actually I used that where because its more readable and it was the way i was thinking about the problem when I coded the solution
14:02:47 <MarLinn> "lines" does another traversion, but meh. Fusion will sort it out. Maybe.
14:03:19 <Jenaf> oh
14:03:24 <dfeuer> I wouldn't necessarily trust lines and unlines to fuse....
14:03:35 <Jenaf> now I get that partial application!
14:03:39 <dfeuer> I don't remember what the issues were, but I think they only partially fuse.
14:03:55 <Jenaf> the . chains functions?
14:04:11 <Jenaf> so foo.bar baz == foo (bar baz) ?
14:04:21 <geekosaur> @src (.)
14:04:22 <lambdabot> (f . g) x = f (g x)
14:04:24 <dfeuer> You're probably better off avoiding lines and unlines if you need to process a huge amount of text really quickly.
14:04:31 <geekosaur> function composition
14:04:40 <Jenaf> thats good to know
14:04:47 <dfeuer> Jenaf, you need to write it  (foo.bar) baz
14:04:54 <mniip> foo . bar baz == \x -> foo (bar baz x)
14:05:08 <dfeuer> Jenaf, because function application binds more tightly than composition (or any other operator).
14:05:13 <Jenaf> yeah
14:05:25 <Jenaf> dfeuer : why?
14:05:36 <Jenaf> ah wait missread
14:05:54 <dfeuer> Jenaf, we like it like that? It's simple? Tradition?
14:06:06 <Jenaf> I missread your tipp
14:06:21 <JonReed> Hi, guys. If I have a function like "myDiv :: (Monad m) => Float -> Float -> m Float", I can do "case (myDiv 5 5) of; Rigth e-> bla bla bla; Left a -> bla bla bla; ". The same can be done for Maybe. Now if I have `myDiv :: Float -> Float -> Except String Float`, is there a trick to quickly convert it to Either or Maybe (`case (magic $ myDiv 5 5) of; Nothing -> bla bla bla)`?
14:06:25 <Jenaf> in this case lines was the right solution: the file is small and i wanted to be done with the coding fast
14:06:43 <Jenaf> only 100 lines
14:06:59 <Jenaf> (with at most 100 words per line)
14:08:10 <mniip> JonReed, you mean Either?
14:08:19 <mniip> or actually ExceptT?
14:08:29 <Jenaf> MarLinn: map (map read.words) . lines <- here the . binds more tightly than the map?
14:09:00 <Jenaf> no wait
14:09:04 <Gurkenglas> Is there some way to get lensy StateT do block syntax if the type of the state can change?
14:09:07 <JonReed> mniip: In case of (Monad m =>) it can be used with either Either or Maybe automatically. I'm wondering how to make Except as user friendly
14:09:15 <MarLinn> Jenaf, no, actually. map read . words == (map read) . words
14:09:30 <MarLinn> Or...
14:09:31 <MarLinn> oups.
14:09:51 <Jenaf> in that case I would vote for having a bit more code wich is easier to read
14:09:52 <MarLinn> yes, I was right.
14:10:03 <MarLinn> I get confused myself. Thanks, typechecker.
14:10:20 <MarLinn> Yeah. It doesn't hurt there
14:10:25 <Jenaf> anyway smoke time and thanks a LOT for the tipps and the help!
14:10:50 <Jenaf> it really helps having people like you arround when learnign a new programming language
14:11:03 <MarLinn> Jenaf, there are more issues to solve ;-p
14:11:42 <MarLinn> namely empty files or files with empty lines - if that could be an issue, that is
14:12:45 <JonReed> mniip: I mean if I write `Monad m => myDiv :: Float -> Float -> m Float`. It's quite easy to use it as either Maybe Or Either, because when you do `case (myDiv 5 5) of; Nothing -> bla bla bla` it works as Maybe and when do `case (myDiv 5 5) of; Right e -> bla` it also works automatically.
14:13:11 <mniip> but with a type that generic
14:13:18 <mniip> there's no way myDiv can ever produce a Nothing
14:13:47 <JonReed> mniip: It can with `fail`.
14:14:04 <mniip> that's uh
14:14:07 <mniip> not a good thing to use
14:14:16 <JonReed> mniip: But that's considered to be a bad practice, so I want to switch to Except
14:14:39 <mniip> you might want to use MonadPlus instead
14:14:42 <mniip> in which case
14:15:01 <mniip> :t either (const empty) pure . runIdentity . runExceptT
14:15:03 <lambdabot> Alternative f => ExceptT b Identity a -> f a
14:15:49 <mniip> oh but Either has no Alternative I don't think
14:17:50 <ertesx> > Left () <|> Right "yes"
14:17:52 <lambdabot>  error:
14:17:52 <lambdabot>      • No instance for (Control.Monad.Trans.Error.Error ())
14:17:52 <lambdabot>          arising from a use of ‘<|>’
14:18:02 <lambdafan> I'm looking for function of this type : (a -> a) -> Maybe a -> a
14:18:05 <ertesx> what?!
14:18:50 <kadoban> lambdafan: That type doesn't seem to make a ton of sense. What would   f id Nothing    result in?
14:18:58 <ski> silliness
14:19:00 <ertesx> ok, the error is nonsense
14:19:11 <mniip> not at all
14:19:14 <lambdafan> kadoba : yeah I realized the use case dosn't match the function type
14:19:23 <lambdafan> kadoban : yeah I realized the use case dosn't match the function type
14:19:27 <mniip> :t empty `asAppliedTo` isRight
14:19:29 <lambdabot> Alternative ((->) (Either a b1 -> Bool)) => (Either a b1 -> Bool) -> b
14:19:32 <ertesx> but i'm a bit surprised that (Either e) is not an Alternative…  its Monad instance has left-catch semantics after all
14:19:39 <mniip> hrmph
14:19:46 <mniip> @where L.hs
14:19:46 <lambdabot> what lambdabot has in scope is at http://silicon.int-e.eu/lambdabot/State/Pristine.hs
14:19:58 <mniip> :t empty `asTypeIn` isRight
14:20:00 <lambdabot> Control.Monad.Trans.Error.Error a => Either a b
14:20:18 <ertesx> lambdafan: would 'maybe' be what you need?
14:20:19 <ertesx> :t maybe
14:20:34 <geekosaur> you killed it :p
14:20:34 <lambdabot> b -> (a -> b) -> Maybe a -> b
14:20:48 <ertesx> i don't kill lambdabot…  that's mniip's job =)
14:20:53 <ertesx> SCNR
14:21:34 <mniip> oh that's easy
14:23:53 <mniip> :t moo
14:23:55 <lambdabot> I am dead inside
14:24:06 * hackagebot servant-auth-hmac 0.1.0.0 - Authentication via hashed message code (HMAC) based on RFC1945.  https://hackage.haskell.org/package/servant-auth-hmac-0.1.0.0 (zohl)
14:24:41 <ertesx> somehow that one smells like pizza margherita
14:25:16 <Rarrikins> lambdabot: :(
14:27:37 <mniip> ertesx, that's easy too
14:27:47 <mniip> @let deriving instance Generic I
14:27:49 <lambdabot>  .L.hs:161:19: error:
14:27:49 <lambdabot>      Not in scope: type constructor or class ‘Generic’
14:28:10 <mniip> @let import GHC.Generic
14:28:11 <lambdabot>  .L.hs:132:1: error:
14:28:11 <lambdabot>      Failed to load interface for ‘GHC.Generic’
14:28:11 <lambdabot>      Perhaps you meant GHC.Generics (from base-4.9.0.0)
14:28:14 <mniip> @let import GHC.Generics
14:28:16 <lambdabot>  Defined.
14:28:19 <mniip> @let deriving instance Generic I
14:28:20 <lambdabot>  .L.hs:162:27: error:
14:28:20 <lambdabot>      • Expecting three more arguments to ‘I’
14:28:20 <lambdabot>        Expected a type, but ‘I’ has kind ‘* -> * -> * -> *’
14:28:25 <mniip> bleh
14:28:32 <mniip> forget it then :p
14:28:43 <ertesx> hehe
14:29:06 * hackagebot servant-auth-hmac 0.1.0.1 - Authentication via HMAC  https://hackage.haskell.org/package/servant-auth-hmac-0.1.0.1 (zohl)
14:30:59 <Gurkenglas> Will "let (a, _) = (b, c)" keep c and everything it references from being garbage collected until a can be?
14:32:11 <ertesx> Gurkenglas: until the tuple can be…  constructors (like tuples) hold on to their fields…  however, you never actually refer to the tuple, so in this case it's fine
14:32:16 <Welkin> > let (a, _) = (2, 3) in _
14:32:19 <lambdabot>  error:
14:32:19 <lambdabot>      • Found hole: _ :: t
14:32:19 <lambdabot>        Where: ‘t’ is a rigid type variable bound by
14:32:31 <Welkin> > let (a, _) = (2, 3) in show _
14:32:34 <lambdabot>  error:
14:32:34 <lambdabot>      • Found hole: _ :: ()
14:32:34 <lambdabot>      • In the first argument of ‘show’, namely ‘_’
14:32:39 <Welkin> okay, so _ is special
14:32:56 <Welkin> > let (a, _) = (2, 3) in show a
14:32:58 <lambdabot>  "2"
14:33:00 <mniip> _ has is special syntax in patternss
14:33:05 <mniip> -has
14:33:16 <mniip> it's documented in haskell98 actually
14:33:38 <Gurkenglas> Ah, so this guy keeping the complicated, often modified field in his state record behind a cpp flag is actually wise
14:33:50 <mniip> > tail (let (a, _) = undefined in [a])
14:33:52 <lambdabot>  []
14:33:59 <mniip> the bind is lazy
14:34:02 <mniip> a is referencing the tuple
14:34:31 <mniip> > tail (let !(a, _) = undefined in [a])
14:34:33 <lambdabot>  *Exception: Prelude.undefined
14:35:24 <Welkin> what do you mean a is referencing the tuple?
14:35:30 <Welkin> a is inside the tuple
14:36:36 <lyxia> a will be bound to a thunk that will pattern match on the tuple only when a is needed.
14:37:12 <Welkin> yeah
14:37:51 <Gurkenglas> So if I never use that field and keep modifying it, I in fact get a space leak?
14:39:07 <ertesx> Gurkenglas: likely
14:39:25 <ertesx> Gurkenglas: unless you force it in appropriate places
14:41:09 <Gurkenglas> Wait. If seq is used nowhere and I never use that field, wouldnt even "let q@(a, _) = (b, c)", even before any of the modifications to c are piled on, resolve all the places where q is used, see that the second element still hasnt been used, and drop c completely?
14:41:24 <squall> Sounds relevant too lazy evaluation of mapping over duplicate applied to a zipper?
14:41:47 <joe9> anyone using a logger thread? Any recommendations for a logger thread library? I am trying out fast-logger but it does not rotate logs automatically.
14:43:17 <mniip> Gurkenglas, only if it knows that (b, c) is not a bottom
14:43:27 <mniip> then ghc *could* make that optimization
14:43:33 <mniip> (does it?)
14:43:42 <Gurkenglas> > snd $ (`execState`(1, undefined)) $ replicateM_ 1000000 $ _2 += 1
14:43:46 <lambdabot>  *Exception: stack overflow
14:43:48 <Gurkenglas> > fst $ (`execState`(1, undefined)) $ replicateM_ 1000000 $ _2 += 1
14:43:51 <lambdabot>  1
14:44:10 <mniip> (b, c), not c
14:45:44 <Gurkenglas> Can you give an example like the above where asking for fst fails?
14:46:15 <squall> _1?
14:46:52 <Gurkenglas> *even though snd is the one that has the gigantic thunk, and is never read. <.<
14:47:07 <ertesx> joe9: not exactly answering your question, but if you're thinking about rotating logs, that sounds a bit like overengineering
14:48:02 <ertesx> (in a perfect unix world all programs log to stderr)
14:48:54 <johnw> yes, logging should be a concern of the system, not the program
14:49:18 <squall> > fst $ (`execState`(1, 0)) $ replicateM_ 1000000 $ _2 += 1
14:49:22 <lambdabot>  1
14:50:10 <squall> :t execState
14:50:12 <lambdabot> State s a -> s -> s
14:50:24 <squall> Sry, noob
14:50:34 <joe9> johnw, ertesx, good point. Thanks. will put it out to the system. If I do that, I would have to have the program respond to a signal handler to switch logs.
14:51:01 <joe9> johnw, ertesx, logrotate can send a signal to the program after it rotates the logs.
14:51:03 <ertesx> joe9: no, you just log to stderr and let whatever is connected to it handle that
14:51:17 <joe9> ertesx,
14:51:31 <lpaste> hexagoxel pasted “Gurkenglas” at http://lpaste.net/180172
14:52:19 <Gurkenglas> "<Gurkenglas> Wait. If seq is used nowhere" <- hexagoxel that included bang patterns :P
14:52:35 <joe9> ertesx, oh, ok. I have multiple threads logging and the terminal output was getting messed up. I started a fast-logger thread and am logging to that. Would you recommend using a logger thread or just write to stderr ?
14:53:11 <squall> Never seen anything like lines 5,7 before
14:53:11 <ertesx> joe9: a logger thread is better, otherwise you might see interleaved lines
14:53:20 <squall> "
14:53:35 <hexagoxel> Gurkenglas: but in exference i do effectively force parts of the record all the time.
14:53:46 <joe9> ertesx: any library recommendations for the logger thread, please?
14:54:12 <ertesx> joe9: one: async, along with a design note: make sure the logger thread exits before the main thread
14:54:13 <Gurkenglas> ((Even the searchtree, when the user didn't ask for it? Why?))
14:54:32 <squall> When do these bang patterns become useful?
14:54:36 <johnw> async + fast-logger is a good choice
14:55:08 <johnw> squall: when you need to force evaluation, to avoid leaks generally (once you know that that is the problem)
14:55:29 <squall> I think I had something like that in my viewer, did you see?
14:55:34 <monochrom> bang patterns are a convenient syntax sugar for "seq". "seq" is useful when laziness becomes a burden rather than a benefit.
14:55:42 <mniip> geekosaur, huh
14:55:56 <mniip> I configured with --enable-unregistered but it still built a registered compiler
14:56:02 <squall> It cast between types to avoid building up lots of compounded updates
14:56:14 <joe9> johnw, ertesx, Thanks for the recommendations. I have an issue with async, where I cannot see which thread is being overloaded, etc. Is there a better thread manager library? Something like threadscope application?
14:56:18 <monochrom> no, nothing casts types.
14:56:26 <ertesx> joe9: alternatively use an MVar for locking, which saves you from the trouble of ensuring proper cleanup (it's easy to lose log messages in a multi-threaded setting)
14:56:35 <monochrom> and types are irrelevant to building up
14:56:46 <geekosaur> ok, so they disabled unregisterised. I thought I had heard they were going to do that, since any more the preferred way to do things is to use the llvm backend and compile llvm IR on the target
14:56:49 <mniip> I think ./configure is broken
14:56:52 <ertesx> joe9: "overloaded"?
14:57:08 <geekosaur> also I thought it was --enable-unregisterised
14:57:17 <monochrom> the almost opposite of bang patterns are tilde patterns. tilde patterns are useful when nonlaziness becomes a burden rather than a benefit.
14:57:22 <mniip> config.mk stated that registered ghc would be built
14:57:23 <joe9> ertesx, each thread writes to a logger - TChan Text, and the logger thread reads from it. Can stuff get lost in that scenario?
14:57:29 <geekosaur> (the meaning being "doesn't know how to use target registers optimally")
14:57:43 <monochrom> I don't think TChan is lossy.
14:57:55 <mniip> geekosaur, I figured it's something to do with registers rather than registration :p
14:57:56 <ertesx> joe9: yes, at the very end of your application
14:57:57 <joe9> ertesx: the only reason I am checking the logger stuff is that I have a HTTPException raised by one of the threads and the log does not have much messages on it.
14:58:15 <joe9> ertesx: yes, that is exactly what is happening.
14:58:48 <joe9> ertesx: losing stuff after an exception is handled by async (which closes all the threads.)
14:58:50 <ertesx> joe9: one way is to use async, but even then you can lose log messages
14:59:08 * hackagebot casr-logbook-meta-html 0.0.4 - Meta-information about entries in a CASR 61.345 logbook (casr-logbook) HTML output  https://hackage.haskell.org/package/casr-logbook-meta-html-0.0.4 (TonyMorris)
14:59:17 <ertesx> an easy way to never lose log messages is to lock with an MVar
14:59:49 <joe9> ertesx: did you see that being used anywhere? So, I can check out the code on how that is being done.
15:00:21 <joe9> ertesx:  I suspect that the main thread should have an exception handler for all exceptions and then on any exception, flush the log and then exti.
15:01:05 <ertesx> joe9: create an MVar (), then do this:  bracket_ (takeMVar lockVar) (putMVar lockVar) loggingSection
15:01:18 <joe9> ertesx, so, start the logger thread in the beginning, keep the threadId, start the processing, handle any exception on the processing, on any exception, flush log, close log, async throwTo logThreadId and then exit.
15:01:19 <ertesx> i.e. no logger thread, just MVar locking for stderr
15:02:19 <ertesx> that also gives you an easy way to keep multiple log messages together
15:02:23 <monochrom> there may be a "withMVar" that packages up that pattern
15:02:46 <geekosaur> mniip, from 8.0.1 configure.ac: AC_ARG_ENABLE(unregisterised [...]
15:03:25 <geekosaur> you said you did --enable-unregistered which was probably ignored
15:03:49 <mniip> well that's what --help says
15:03:56 <mniip> um
15:04:00 <mniip> that's what AC_ARG_ENABLE does
15:04:04 <mniip> --enable-XXX
15:04:20 <monochrom> yes, withMVar, also withMVarMasked if you need it extremely
15:04:36 <geekosaur> [AC_HELP_STRING([--enable-unregisterised]
15:04:55 <joe9> ertesx: from a noob standpoint, the logger thread seems a better idea as you do not have to worry about MVar state, etc. (potential for lockups,?)
15:05:10 * geekosaur must away for a bit
15:05:11 <justatech> how to read a code is there any system to read code
15:05:17 <mniip> haha
15:05:22 <mniip> configure didn't even ask for LLVM
15:05:30 <mniip> <no location info>: error: Warning: Couldn't figure out LLVM version! Make sure you have installed LLVM 3.8
15:06:02 <joe9> esterx , I am not questioning your advice, just trying to understand.
15:07:12 <MarLinn> justatech: I hear good things about a system called Braille. It's not really mainstream, though.
15:07:26 <ertesx> joe9: i'm not overly fond of locking either, but it is in this case really the easiest way to avoid losing messages
15:08:12 <ertesx> joe9: otherwise you need some extra engineering not only to make sure the logger thread exits properly, but also that it never misses a message once it has been sent
15:08:23 <squall> Wait how do you do blocking asynchronous get?
15:08:31 <justatech> Marlinn thanks very  much 
15:10:04 <EvanR> squall: shell exec wget
15:10:28 <EvanR> or curl
15:10:51 <squall> Using MVar
15:11:51 <EvanR> er. blocking is the opposite of asynchronous isnt it
15:11:53 <squall> Just simple mpi stuff
15:11:55 <joe9> ertesx, ok, Thanks.
15:12:12 <squall> I mean to kind of mix them up
15:12:37 <squall> I guess the monad TVar would be appropriate
15:13:37 <monochrom> yeah, blocking is usually regarded as sychronous
15:13:42 <monochrom> or synchronizing
15:13:44 <squall> Sorry. What interface does TVar provide to implement common message parsing paradigms such as MPI
15:14:01 <squall> ?
15:14:08 * hackagebot bond-haskell-compiler 0.1.4.0 - Bond code generator for Haskell  https://hackage.haskell.org/package/bond-haskell-compiler-0.1.4.0 (blaze)
15:14:10 * hackagebot bond-haskell 0.1.4.0 - Runtime support for BOND serialization  https://hackage.haskell.org/package/bond-haskell-0.1.4.0 (blaze)
15:15:05 <squall> How does it tie into lazy evaluation?
15:15:50 <squall> The example of using a bang pattern above could be seen as such
15:15:52 <johnw> squall: I understood none of that question
15:16:02 <johnw> what do you mean?
15:16:04 <squall> Yes me too very sorry nvm
15:16:17 <int-e> hmm, interesting, searching for "distributed STM" turned up https://hackage.haskell.org/package/DSTM-0.1.2 ... probably bitrotted though (its from 2010)
15:16:46 <monochrom> TVar is a shared variable. Not a message queue.
15:16:47 <EvanR> byzantine tolerant transactional memory eh
15:16:57 <monochrom> TChan etc would be message queues.
15:17:14 <squall> I mean if threads are interacting then they could force evaluation of lazy thunk lists or whatever you call them
15:18:08 <int-e> johnw: MPI = message passing interface  is a popular API for implementing parallel computations. To my mind it has little to do with TVars (although MPI does offer synchronization operations)
15:18:39 <monochrom> clearly, message queues can implement shared variables.
15:19:41 <joe9> ertesx: on a different note, any library suggestions for managing threads? Do you use threadscope? just to see what thread is under what load, etc?
15:19:56 <johnw> threadscope isn't for managing threads, it's for analyzing profiler thread traces
15:20:30 <squall> It's about handling the construction of blocking and non blocking intra thread information sharing
15:21:05 <squall> (Mpi)
15:22:29 <int-e> squall: STM is implementing composable transactions. There is really a conceptual mismatch here, I believe. Yes, both allow threads to communicate, but the focus is very different.
15:22:59 <squall> I imagine one thread conducting an unfold and another thread interrupting this rather than sitting around waiting for the infinite operation to cease
15:23:38 <johnw> squall: for that there's just "timeout"; maybe I'm missing something here
15:24:33 <squall> No idea sorry
15:26:46 <squall> I could almost write it, setting up two threads and having one iterate (+1) and the other getting the last value every second or something
15:27:40 <mniip> geekosaur, ah
15:27:51 <mniip> I've been misspelling unregisterised all along :(
15:28:27 <squall> I'm just worried about that memory leak issue and it's treatment regarding forkIO
15:30:32 <squall> I'm not sure but it seems to fit in, sending a function to each element of a list to repeatedly operate on the elements and interact with neighbouring threads. Is that a thing?
15:31:27 <squall> Rather than having to direct the functions to their respective elements each time
15:32:40 <mniip> Jenaf, geekosaur ah well, unregisterised ghc simply emits C-ified Cmm
15:32:54 <Jenaf> ?
15:34:00 <Jenaf> foo::[[Int]]->[[Int]]; foo first:rest = ... gives me a parse error on pattern matching
15:34:35 <mniip> ' ' takes over the precedence from :
15:34:50 <Jenaf> and what is "unreguisterised ghc"?
15:34:58 <ertesx> joe9: personally i rarely use anything other than async and stm
15:34:59 <mniip> just like you wouldn't be calling it 'foo first:rest' you can't define a pattern match like that
15:35:24 <ertesx> joe9: i tend to build my abstractions around the application rather than the other way around
15:35:30 <mniip> Jenaf, one that doesn't handle registers manually and hence can emit C code
15:35:44 <squall> By repeatedly applying fmap, i ensure the operation is conducted simultaneously. Conversely with interacting threads, i should be able to synchronise their gather and interaction calls
15:36:17 <Jenaf> huh? that worked on non-nested lists
15:36:30 <squall> I'm using free lists
15:36:40 <mniip> Jenaf, think about it 'head 1:2' is invalid
15:36:45 <joe9> ertesx:  Thanks a lot.
15:37:03 <Jenaf> ahh...
15:37:03 <squall> Oh sry nvm
15:37:10 <Jenaf> parans!
15:37:20 <Jenaf> I love parans
15:37:49 <mniip> they're called parens
15:37:57 <squall> Did anyone get the gist of my query?
15:38:38 <johnw> I understood none of it, sorry
15:38:55 <johnw> I have no idea what fmap would have to do with simultaneity
15:39:26 <johnw> I think you need to show us code, with specific questions, in order to make progress
15:40:02 <squall> It's not going to do more operations on one element than another. If each element just had iterate acting on it in its own thread they might perform operations at different rates
15:40:18 <johnw> still cannot parse
15:40:29 <johnw> I know what every word you're using means independently, but not when combined
15:40:36 <joe9> johnw: Thanks.
15:41:07 <joe9> When using async, which thread would get user presed Ctrl-C? or, is it sent to all threads?
15:41:14 <Jenaf> parens remindes me to much of parents
15:41:15 <johnw> it's sent to the main thread
15:42:41 <MarLinn> Jenaf: How about "brackets"
15:42:55 <Jenaf> thats too close to braces
15:43:08 <MarLinn> lol
15:43:12 <Jenaf> XD
15:43:20 <squall> At the moment I'm using duplicate defined over a (free) zipper, it constructs a new zipper who's shape is that of the original one. fmap over this structure allows efficient access to neighbor elements, but the whole process of duplicate must be performed again so that the neighbors accessed in successive operations are updated
15:43:47 <joe9> johnw, thanks.
15:44:09 <MarLinn> Jenaf, it's easy to see why you would pick a language where it's easy to define your own language on top
15:44:31 <squall> I wish to instead map a function which starts interacting threads and wonder about performance considerations
15:44:51 <squall> With me thus far?
15:45:26 <Jenaf> that kinda reminds me off that article on tdwtf about "#define then" in a C file so that the devs could keep writing "if(foo())then {bar()}
15:46:16 <MarLinn> Jenaf, what are you doing in my browser history O_o
15:46:42 <squall> (The elements of the nested zipper returned by duplicate are the input (free) zipper accessed at each location)
15:46:45 <Jenaf> I'm actually a sentinent AI that was born from your browser history
15:47:12 <Jenaf> pls don't delete me
15:47:34 <squall> ...
15:47:52 <MarLinn> Ah, ok. Yeah, makes sense. I'll keep feeding you random input then. XD
15:48:18 <Jenaf> yay!
15:48:20 <MarLinn> squall: doesn't explicit synchronization defeat the purpose of parallelity?
15:48:22 <squall> Ai should be teaching us Haskell
15:48:48 <Jenaf> but I'm only learning from this chat and MarLinns browser history
15:48:58 <Jenaf> and thats a bit much tdwtf, so ...
15:49:48 <JonReed> Is it possible to write an instance of MonadError for Maybe? https://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control-Monad-Error-Class.html#MonadError
15:49:49 <MarLinn> Current open tab: wikipedia page on brazil nuts. GO!
15:49:50 <Jenaf> I'm a GENIUS! with enough definitions i can make my own goto in haskell!
15:49:51 <squall> I just don't want to keep accessing the structure to insert the function which accesses the neighbors as it's this navigation which is expensive. The functions should happily operate in the location they are sent, exchanging information with each other
15:50:52 <dmwit> `MonadError () Maybe` is probably possible.
15:51:12 <squall> It's about retaining constant data exchange geometry
15:51:49 <timehelp> using the time library what is the easiest way to generate a list of dates? Past 3 days would be [2016-08-24,2016-08-23,2016-08-22]. I don't see an enum instance for UTCTime. I see one for DiffTime and NominalDiffTime but I'm not really sure what those are.
15:52:03 <MarLinn> I once saw a thing that used reflection to add goto-capability to java. Ugh.
15:52:08 <squall> Iterate fmap is super costly on difficult to navigate things like my free duplicate zipper
15:52:23 <hpc> DiffTime and NominalDiffTime are differences between UTCTimes
15:52:50 <hpc> if you want a list of days you might use a UTCTime for one day and repeatedly add a day of DiffTime
15:52:56 <dmwit> timehelp: There are `Num` instances for `DiffTime` and `NominalDiffTime` that convert from seconds.
15:53:05 <hpc> or use Day - https://hackage.haskell.org/package/time-1.6.0.1/docs/Data-Time-Calendar.html#t:Day
15:53:18 <MarLinn> squall: That sounds like you might need some serious refactoring. Maybe two threads that send each other messages with the current position in their structure or something
15:53:41 <Jenaf> I've always wondered what beautifull wtfs can be created with the longjmp.h in C
15:53:46 <dmwit> hpc: I think you probably want one day of `NominalDiffTime`, not one day of `DiffTime`.
15:53:51 <Profpatsch> Haddock: Can we have multiple comments per product type?
15:53:54 <hpc> or yeah, that
15:54:10 <squall> Nope, simultaneous global update, no element left unchanged
15:54:31 <dmwit> Profpatsch: You definitely can for records. Not sure about non-record products.
15:54:58 <Profpatsch> dmwit: I’m trying to get the cabal docs to build.
15:55:04 <Profpatsch> *cabal-install
15:55:36 <Profpatsch> Someone apparently didn’t know about that and also didn’t bother to build the docs.
15:55:50 <MarLinn> squall: sorry, now you've lost me too, I think.
15:56:15 <Profpatsch> I’d like to expose the cabal-install modules for outside usage, so I have been patching around a bit.
15:56:29 <Profpatsch> Very large piece of software, that.
16:00:17 <MarLinn> Profpatsch: I like having all that automatic documentation, but seriously, Haddock has quite some shortcomings. If that is one, I don't know. Yet another tool we don't have enough community members for...
16:01:28 <mniip> Jenaf, here's what a haskell-C file looks like (I annotated it with STG is has been generated from) http://lpaste.net/8135255330977218560
16:01:30 <mniip> er
16:01:35 <mniip> Cmm it has been generated from
16:01:44 <Profpatsch> MarLinn: Yes, the parsing should not stop on the first error as well.
16:02:08 <Profpatsch> Also, it wrongly tried to parse comments in between normal lines of code that started with -- ^
16:02:39 <MarLinn> And it chokes on unicode
16:02:40 <johnw> squall: I imagine you've timed your zipper operations, and found out why they are slow?
16:02:43 <Jenaf> Nice work, Jenaf, you've just advanced to Level 1 .
16:02:45 <Jenaf> 84731 members (13.56%) have made it this far.
16:02:48 <Jenaf> yay ^.^
16:03:44 <Profpatsch> MarLinn: Sounds like the parser needs to be completely rewritten.
16:04:01 <ertesx> Jenaf: whatever brain damage longjmp has to offer, ContT most likely tops it
16:04:09 <ertesx> Jenaf: and yes, you can make goto with ContT =)
16:04:15 <MarLinn> Jenaf: Conglaturations! (^_^)-d
16:04:38 <Jenaf> longjmp= save the whole program status, jump to error handling code and then jump back
16:04:47 <Jenaf> like C has no exception handling..
16:04:57 <johnw> I didn't think that longjmp could jump back
16:05:06 <johnw> unless you setjmp again
16:05:07 <ertesx> Jenaf: longjmp is actually a bit more simplistic, because it can only jump in one direction
16:05:12 <Jenaf> oh
16:05:21 <Jenaf> I actually never looked into it that far
16:05:22 <ertesx> Jenaf: ContT on the other hand actually *can* go in both directions
16:05:31 <Jenaf> yay!
16:05:49 <Jenaf> can you jump anywhere? like between different functions? or even source files?
16:05:50 <johnw> ContT is really just passing functions around that represent "the rest of the computation" at each point, so you can call any one of those functions and "jump" to that point
16:06:19 <ertesx> :t \x0 -> ContT (\k -> let again x = ContT (\_ -> k (x, again)) in k (x0, again))
16:06:21 <lambdabot> forall k (r :: k) (m :: k -> *) a t. t -> ContT r m (t, t -> ContT r m a)
16:06:35 <ertesx> Jenaf: goto =)
16:06:39 <johnw> it's not transfer of control in any magical way; it works because we're always dealing with pure functions
16:06:55 <MarLinn> Profpatsch: As far as I read, the unicode stuff comes from the fact that Haddock relies on the locale to determine encoding or something. Yeah...
16:07:10 <ertesx> Jenaf: unfortunately ContT-goto can only jump to labels in scope, so you need to have passed a label at least once in order to jump to it
16:07:14 <Jenaf> ah I was still not back from C
16:07:34 <ertesx> Jenaf: if ContT were a MonadFix, it could jump anywhere, but i don't think anyone has figured out how to make it one properly yet
16:07:48 <Jenaf> would be fun In C to jum upt of a function and then forget to terminate it and have a stack leack
16:08:06 <ertesx> @let goto x0 = ContT (\k -> let again x = ContT (\_ -> k (x, again)) in k (x0, again))
16:08:07 <lambdabot>  Defined.
16:08:15 <johnw> http://stackoverflow.com/questions/25827227/why-cant-there-be-an-instance-of-monadfix-for-the-continuation-monad
16:08:27 <ertesx> whoops
16:08:29 <johnw> so, there can be, but under certain constraints
16:08:50 <ertesx> anyone object to @undef?  i'll do it in five seconds
16:08:55 <ertesx> @undef
16:08:55 <lambdabot> Undefined.
16:08:57 <ertesx> thanks, everybody
16:09:04 <ertesx> @let label x0 = ContT (\k -> let again x = ContT (\_ -> k (x, again)) in k (x0, again))
16:09:06 <lambdabot>  Defined.
16:09:08 <ertesx> @let goto = id
16:09:10 <lambdabot>  Defined.
16:09:55 <ertesx> > flip runCont id $ do (x, l) <- label 0; if x < 10 then goto l else return x
16:09:57 <lambdabot>  error:
16:09:57 <lambdabot>      Ambiguous occurrence ‘label’
16:09:57 <lambdabot>      It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.label’,
16:10:03 <ertesx> great
16:10:09 <ertesx> @let label' x0 = ContT (\k -> let again x = ContT (\_ -> k (x, again)) in k (x0, again))
16:10:11 <lambdabot>  Defined.
16:10:16 <ertesx> > flip runCont id $ do (x, l) <- label' 0; if x < 10 then goto l else return x
16:10:18 <lambdabot>  error:
16:10:18 <lambdabot>      • Couldn't match expected type ‘ContT c Identity c’
16:10:18 <lambdabot>                    with actual type ‘c -> ContT c Identity a0’
16:10:27 <ertesx> > flip runCont id $ do (x, l) <- label' 0; if x < 10 then goto l (x + 1) else return x
16:10:30 <lambdabot>  10
16:10:34 <ertesx> there we go
16:10:52 <ertesx> Jenaf: label + mutable variable in one =)
16:12:32 <MarLinn> Now I finally know how to implement a decent brainfuck interpreter in Haskell. Thanks!
16:14:54 <ertesx> MarLinn: now try unlambda with 'c'…  ContT may actually be handy for that one =)
16:17:24 <MarLinn> ertesx, I tried implementing unlambda once. It think it started to become a mess when I wanted to debug it.
16:18:30 <ertesx> MarLinn: unlambda is actually easier to implement than brainfuck (in haskell)
16:20:26 <MarLinn> It should be, but I guess I was a puny little freshman back then who didn't even know about monads
16:23:26 <Cale> MarLinn: One thing you can basically always do to turn an imperative program into a functional one (though it might result in a bit of a mess at first, it's an easy mess to clean up), is to turn each point of control in the imperative program into a function, and each of the local mutable variables into function parameters.
16:23:58 <Cale> You can then specify how those things change, and where the program goes just by having the result of one function be an application of the next to the new values of the mutable variables.
16:24:19 <Cale> (loops result in mutual recursion)
16:24:58 <Cale> The nice thing about this is that you end up with a bunch of equations which you can immediately start simplifying by substituting in.
16:28:03 <MarLinn> I suppose that could be why arrows became a thing: They're basically a codification of that approach, especially in arrow notation
16:28:35 <ertesx> MarLinn: no, that's unrelated
16:30:27 <MarLinn> Well maybe the original idea was different. That doesn't necessarily mean Imperatives didn't adopt it for that reason.
16:31:15 <ertesx> MarLinn: there is little reason to use arrows when you have a monad…  the legitimate use cases of arrows are specificly non-monads
16:32:04 <ertesx> ever wondered why hxt is awkward to use and you feel that it should be a lot easier?  that's why =)
16:33:15 <MarLinn> I know that by now. And when I last used them in a bigger project I later realised applicative would have been enough except for one or two places - where a monad would have sufficed.
16:34:08 <MarLinn> Still, they looked so nice from an imperative standpoint. Just replace every line by an arrow...
16:34:32 <ertesx> how do they look nicer than monads?
16:34:46 <ertesx> monadic do-notation is arrow notation on steroids
16:35:10 <ertesx> it's simpler, clear *and* more powerful
16:35:21 <ertesx> s/clear/cleaner/
16:36:18 <MarLinn> I suppose the explicit input makes it feel more fine-grained or something
16:37:04 <ertesx> if you really need that visual cue, you can always make a low-precedence operator =)
16:37:48 <MarLinn> Heh. Good idea
16:37:56 <ertesx> :t let (-<) = ($); infixr 0 -< in do putStrLn -< "blah"; putStrLn -< "blubb"
16:37:58 <lambdabot> IO ()
16:39:31 <MarLinn> And something like (-<<) = (=<<)
16:40:09 <MarLinn> But if you're using that you should already know arrows are wrong
16:43:30 <ertesx> BTW, i'm a huge fan of -XApplicativeDo…  that extension may become the number one reason why my code doesn't compile with GHC 7 =)
16:44:41 <MarLinn> Does it also change MonadComprehensions into ApplicativeComprehensions?
16:45:32 <MarLinn> And what about co-monad-do, is that somewhere in a pipeline? XD
16:45:44 <ertesx> apparently not
16:47:30 <MarLinn> I am disappoint.
16:48:14 <mniip> ertesx, tbh I hate extensions that can be easily desugared into non-extension code
16:48:23 <mniip> such as ApplicativeDo or ScopedTypeVariables
16:48:51 <monochrom> ScopedTypeVariables is not so easily desugared. Actually I don't consider it sugar either.
16:48:55 <mniip> well
16:49:06 <monochrom> ApplicativeDo, I agree.
16:49:09 <mniip> it is not *easily* desugared
16:49:12 <mniip> but it is doable
16:49:28 <mniip> and I have insofar not used scopedtyvars a single time
16:49:30 <ertesx> mniip: i don't mind them…  ApplicativeDo makes my code easier to read and write, especially when records are involved
16:49:51 <monochrom> that is very slippery. from "easily" to "doable". Next, will it be further broadened to "Turing-computable"?
16:50:18 <mniip> you know what forget haskell
16:50:25 <mniip> I'll just program in system-fc core
16:51:03 <monochrom> I have recently used ScopedTypeVariables in a natural way. To avoid it would be artificial in that place.
16:51:26 <monochrom> (I actually know a tie-the-knot trick to avoid it. I know how to be evil, too.)
16:51:47 <mniip> I always tie the knot
16:51:52 <mniip> I just assume it optimizes away
16:52:04 <mniip> if I were ghc I would optimize it away
16:52:36 <ertesx> if i were haskell, i would make ScopedTypeVariables standard
16:52:45 <monochrom> I think you're drunk. To want to write in System-FC core directly.
16:53:35 <mniip> Om jag var en tjej så skulle jag heta Agneta
16:53:39 <mniip> no wait that's something else
16:53:50 <monochrom> OK you are drunk.
16:56:17 <ertesx> we use haskell to avoid writing boring code, don't we?  you know: the kind of code that's only there, because the language is not powerful enough to get rid of it…  using haskell without extensions just doesn't make sense to me…  it's not like i'll use another compiler any time soon
16:57:57 <monochrom> That is not my only reason for using Haskell. But yes it is one of my many reasons (and they conflict a bit, I am OK with some trade-offs.)
16:58:18 <monochrom> Some boring code appears in my Haskell code but not too badly.
16:58:30 <maerwald> code should be boring
16:58:31 <ertesx> sorry if that sounds overly economic, but there is some merit to economic arguments =)
16:58:56 <maerwald> code shouldn't surprise the reader, so it should be boring
16:59:08 <ertesx> maerwald: that's another sense of boring, and i agree
16:59:15 <monochrom> I agree fully with economic arguments. It's why I accept trade-offs and compromises.
16:59:29 <ertesx> maerwald: the kind of "boring" i mean is: Functor and Traversable instances
16:59:35 <maerwald> if I want to read or write exciting stuff, I write an actual sci-fi book or something.
17:00:05 <monochrom> I want to surprise you by generating a random number sequence.
17:00:36 <Sonolin> I liken programming in haskell to vispanna meditation... not very "fun" but very peaceful and inspiring :)
17:00:38 <ertesx> and indeed glue code between type inference and type variables:  the type variable is there and already has a name…  you should refer to it
17:00:57 <ertesx> i.e. you should use ScopedTypeVariables
17:01:29 <monochrom> There are times I don't need ScopedTypeVariables. But that's when I don't even write types.
17:02:07 <ertesx> sure…  there are also times when a proxy of the right type is already in scope
17:08:18 <agocorona> hi
17:10:13 <MarLinn> So, ertesx, you mentioned the ugliness of hxt.
17:10:22 <MarLinn> I have to admit that the awful project of my own that I mentioned was yet another arrowized XML library - albeit using arrows completely differently.
17:10:44 <MarLinn> So... what is a good xml library? I know that there are many. But which one is good?
17:11:06 <monochrom> I actually like hxt the most.
17:11:43 <monochrom> I agree that regrettedly it is a monad and it could benefit from do-notation more than from arrow notation.
17:12:29 <monochrom> however haxml is even worse. it is not even made an applicative. much manual plumbing.
17:12:58 <agocorona> XML is still used?
17:13:38 <monochrom> I still use XML.
17:14:28 <agocorona> I used it a lot too time ago
17:14:46 <ertesx> MarLinn: i had success with xml-conduit in the past, but that one only parses XML as far as i know
17:15:18 <agocorona> Even created decent programs in xpath
17:15:34 <monochrom> yeah, when I mention hxt and haxml, I have tree surgery in mind.
17:16:28 <ertesx> MarLinn: i've also used tagsoup to "parse" "XML"…  you know…  "business XML"
17:16:42 <ertesx> ironically that was so far the most pleasant experience
17:16:54 <Jenaf> yay, I just learned how import can be used way better than just importing everything!
17:17:43 <Jenaf> import qualified Data.Sequence as Seqq (take,empty,drop,null,Seq,index,fromList)
17:17:45 <Jenaf> import Data.Sequence ((<|),(|>),(><)) 
17:17:53 <Jenaf> much cleaner ^.^
17:18:17 <monochrom> I think you may want import Data.Sequence (Seq,(<|),(|>),(><))
17:18:49 <monochrom> so that you can mention the Seq type without much prefix. (and mostly likely there is no clash anyway)
17:19:03 <Jenaf> yeah but then I would have to rereplace the things I already replaced
17:19:03 <MarLinn> So it's not like there's one "good" library, but they all have their strong points for some applications? What an anticlimactic answer ;)
17:19:06 <Jenaf> but thanks for the tipp
17:19:09 <MarLinn> But thanks!
17:19:15 <ertesx> Jenaf: also it doesn't really make sense to list your imported symbols on qualified imports
17:19:32 <Jenaf> indeed
17:19:59 <Jenaf> I'm sure it saves the compiler very many very important seconds
17:20:13 <ertesx> Jenaf: not really
17:20:37 <Jenaf> hm... now i nee to think of another reason
17:20:40 <Jenaf> *need
17:21:06 <Jenaf> it's because then the compiled .exe files are smaller! (spoiler: I don't really believe that)
17:21:27 <monochrom> don't second guess how hard the computer works. (if you need to know, measure, don't think. you're always wrong.)
17:21:28 <ertesx> perhaps you just love writing =)
17:21:46 <Jenaf> I learned about it so i had to use it.
17:21:53 <Jenaf> is that a good excuse?
17:21:57 <monochrom> yes :)
17:22:00 <Jenaf> yay
17:22:28 <monochrom> Let me teach you an evil trick.
17:22:37 <Jenaf> I like evil tricks
17:23:06 <ertesx> Jenaf: i've done that to myself with PHP…  i thought that all those hours i spent learning it would go to waste if i didn't use it…  i ended up wasting many more hours
17:23:16 <monochrom> import qualified Control.Monad as X; import qualified Data.Functor as X
17:24:01 <Jenaf> import Prelude hiding ((+),(*));import qualified Prelude ((+),(*)); (*)=P.(+);(*)=P.(+) ?
17:24:09 <Jenaf> and hide that somewhere in your package?
17:24:42 <monochrom> I waste more hours than all of you. I waste hours on creating exam questions that involve topics, just because I have taught those topics in the course and so I have to invent questions that have to use those topics.
17:24:52 <Jenaf> lol
17:25:14 <Jenaf> but I like the idea I just posted
17:25:17 <monochrom> (and because I did tell students "yes it will be on the exam", clearly)
17:25:24 <Jenaf> hide that into some thing your students have to import
17:25:35 <Jenaf> should be fun
17:25:51 <Jenaf> (would be an idea for april 1st)
17:26:14 <puregreen> wait, how was monochrom's trick evil? I'm not getting it
17:26:14 <Koterpillar> "here's why you import everything explicitly"
17:26:27 <ertesx> it isn't
17:26:40 <ertesx> import qualified Data.Text as T; import qualified Data.Text.IO as T
17:26:47 <puregreen> oh, okay
17:26:53 <monochrom> ertesx's is a natural, non-evil use.
17:27:40 <monochrom> but consider import qualified Data.ByteString as B; import qualified Data.ByteString.Lazy as B; import qualified Data.Set as B
17:28:01 <MarLinn> module Foo (module X) where { import qualified A as X; import qualified B as X } -- the beauty of "evil"
17:28:31 <monochrom> MarLinn: You know what? Nothing is exported by that.
17:28:45 <MarLinn> I'm missing a (..) or something, right?
17:28:59 <monochrom> No, that won't help either.
17:29:11 <MarLinn> Eh. Something like that.
17:29:15 <monochrom> Read my http://www.vex.net/~trebla/haskell/module.xhtml for why.
17:29:40 <ertesx> MarLinn: scratch the "qualified"
17:29:41 <monochrom> You would have never guessed it. It is completely unexpected.
17:29:53 <monochrom> yeah, that will help.
17:30:08 <puregreen> @hackage text-all -- one day I got tired of retyping “import ... as T”
17:30:09 <lambdabot> http://hackage.haskell.org/package/text-all -- one day I got tired of retyping “import ... as T”
17:30:37 <MarLinn> Well, I saw some working version somewhere XD
17:30:39 <monochrom> It is completely why I wrote that article. It is a total surprise because the word "module" there is deceiving. It has never been about modules.
17:31:02 <monochrom> The working version you saw must have subtle differences from what you wrote.
17:31:28 <monochrom> Yes I am 100% sure. I actually read the Haskell report. And tested it.
17:31:40 <MarLinn> off to read your article to find out which!
17:31:49 <mniip> oh!
17:31:53 <mniip> so it was your article after all!
17:31:54 <mniip> http://www.vex.net/~trebla/haskell/prerequisite.xhtml
17:32:07 <monochrom> and my article has such test cases too so you can validate hypotheses
17:32:16 <monochrom> yes
17:32:33 <biglambda> What is the alignment function in typeclass Storable?
17:32:41 <mniip> I needed to show it to someone one day but couldn't remember the name, the url, nor the author
17:33:42 <monochrom> alignment is whether you want addresses to be multiples of 1? 2? 4? 8? 16? 32? 65536?
17:33:53 <ertesx> biglambda: if alignment says 8 for Double, it means that your architecture prefers or even requires Double values to be aligned at a multiple of 8 in memory
17:33:56 <geekosaur> biglambda, it specifies the memory alignment expected by the ABI
17:34:05 <monochrom> or in reality, never what you want, always what the computer wants.
17:35:01 <mniip> also hmm
17:35:19 <biglambda> Ok so if I’m hand coding an instance that is basically a packet header that includes ints and floats how would I determine the alignment.
17:35:23 <ertesx> biglambda: may make your computer love you by giving you extra speed…  in the opposite case it may make your computer hate you by not computing at all =)
17:35:52 <MarLinn> Before I go reading and forget: Jenaf, try defining functions that start with "--". (--|) = (*) Weee!
17:36:16 <Jenaf> oh
17:36:27 <Jenaf> can you pull that stunt?
17:36:28 <geekosaur> biglambda, in general, for a compound structure / C struct, you can use whatever alignment malloc() uses on the platform/ABI
17:36:41 <monochrom> What does the protocol specification say about the packet header? Do what it says.
17:36:59 <monochrom> Always obey the computer.
17:37:05 <biglambda> It’s my own packets that I’m sending to a GPU
17:37:25 <puregreen> * except when it tells you to enable FlexibleContexts
17:37:35 <biglambda> GPU will take apart my structure after it
17:37:46 <biglambda> loads into local memory.
17:37:47 <monochrom> OK, what does the GPU want? (Is this GPU to be designed by you and you have a say, too?)
17:38:07 <biglambda> OpenCL handles the transfer.
17:38:20 <biglambda> From CPU memory into GPU global memory
17:38:23 <monochrom> OK, what does OpenCL say?
17:38:47 <monochrom> And yes, this is getting almost Zenist.
17:38:59 <biglambda> Hmmm…. Is alignment just for doubles
17:39:17 <monochrom> But I'm afraid when it comes to FFI, you never really have a say, you're always obeying someone else's ABI
17:39:23 <monochrom> No.
17:39:35 <biglambda> Is it just determining what values a pointer to my structure can have
17:39:38 <mniip> we can represent the category of monoids in haskell with 'data Mon k t u a b = Homomorph { moprhMempty :: k (k u a) (k u b), morphMappend k (k (p a a) a) (k (p b b) b) }'
17:39:40 <mniip> :O
17:39:45 <biglambda> In terms of multiples of some integer?
17:40:18 <monochrom> I'm afraid not just where the structure begins, but also where its individual fields are.
17:40:59 <biglambda> I see. Don’t I determine that when I create the poke function.
17:41:08 <Jenaf> okay at least in ghci (--|)=(+) works
17:41:12 <Jenaf> 0.ô
17:42:16 <monochrom> OK I see, you're right.
17:43:07 <mniip> x --| y = atomicModifyIORef x $ \x -> (x - 1, x .|. y)
17:43:16 <monochrom> what geekosaur said about just needing to be consistent with malloc
17:43:17 <biglambda> So alignment just creates padding basically. And determines what multiple your pointer can be created on I think.
17:43:27 <biglambda> Sorry, thinking out loud.
17:43:36 <monochrom> yes
17:43:57 <biglambda> Ok thanks, that makes a lot of sense.
17:44:29 <biglambda> The upshot is you can set alignment to sizeOf and see from there if adjustments help.
17:46:47 <monochrom> Actually I now wonder where is the alignment method actually used.
17:47:04 <monochrom> Foreign.Marshal.Alloc doesn't seem to use it.
17:47:39 <MarLinn> The (--...) trick is evil because I have not seen a single syntax highlighter that got that. Combine with thisC'c'IsNotAChar  - which I have not seen recognised correctly either - and you're in for fun times
17:48:16 <monochrom> :)
17:48:36 <biglambda> Maybe it’s used by container poke and peek functions
17:48:58 <biglambda> To determine the offset of an element?
17:49:04 <monochrom> True
17:49:38 <biglambda> maybe in Data.Vector.Storable
17:50:18 <Cale> MarLinn: I also wish that  foo :: Integer <- bar  wouldn't hopelessly throw my editor's syntax highlighting off for the rest of the line.
17:50:46 <monochrom> haha
17:51:13 <Cale> Or if the first line inside a 'let' is a type signature, it for some reason thinks the entire rest of the let block is as well.
17:51:18 <Cale> Super annoying.
17:51:39 <monochrom> oh, I haven't suffered that.
17:53:16 <Cale> Yeah, that one is from this SublimeHaskell package for Sublime Text, which fixes a few different bugs in the Haskell syntax highlighter which comes with Sublime, but introduces its own.
17:54:07 <Cale> Maybe I should just stick with the default highlighter, since its bugs seem generally a bit less annoying.
17:55:27 <Cale> Oh, right, but the default one gets the foo :: T <- bar  thing much more incorrect: it'll affect the rest of the whole do-block in those cases.
17:56:26 <MarLinn> FWIW the default highlighter also has a better default colour scheme - IMHO
18:00:02 <Cale> Oh, I don't use the colour scheme which comes with SublimeHaskell, just the Sunburst one which comes with ST.
18:00:20 <Cale> I like Twilight as well, but the contrast is a bit low. I should fix it.
18:03:33 <mniip> woah
18:03:43 <mniip> I've never had to use UndecidableSuperClasses before
18:04:19 <monochrom> wait, there is such a thing?
18:04:36 <monochrom> will there also be UndecidableSubClasses?
18:04:40 <Cale> Yeah, that's Ed's thing :)
18:04:49 <Cale> To get Hask to compile :)
18:05:25 <monochrom> will there also be parametrized-by-Nat {-# LANGUAGE UndecidableAncestorsUpTo 4 #-}?
18:05:38 <mniip> class (Functor k (NT k k) t, Ob k i) => Monoidal (k :: kk -> kk -> *) (t :: kk -> kk -> kk) (i :: kk) | k -> t, t -> i where
18:05:59 <mniip> it's telling me that UndecidableSuperClasses is required, which is reasonable since Ob is a type family
18:06:11 <monochrom> I see
18:06:22 <mniip> and Ob k could be Monoidal _ _
18:06:25 <monochrom> We're living in an exciting time.
18:07:32 <Cale> mniip: haha, funny that you should be doing basically the same thing as the thing which motivated the extension in the first place
18:08:15 <mniip> funnily enough there actually will be a superclass loop
18:08:28 <mniip> category of monoids -> monoid -> monoidal category -> category
18:12:33 <monochrom> necessary invention or something
18:25:51 <earldouglas> I recently found a way to make a GADT to represent pure, bind, etc. so that I could get IO out of my function signatures, and corral it all in one interpreter function of that GADT.  Does this pattern have a name?  I'd love to read more about it.
18:26:13 <earldouglas> It seems like it's related to Free, but I'm too noob to spot it.
18:27:25 <earldouglas> I think Rúnar Bjarnason calls it "compositional application architecture".
18:27:41 <Koterpillar> earldouglas: Freer?
18:35:14 <dappletasm> when writing type-families, is there an easy way to write tests? so far I have to check everything by hand in ghci with :kind!
18:35:38 <puregreen> @hackage should-not-typecheck
18:35:38 <lambdabot> http://hackage.haskell.org/package/should-not-typecheck
18:35:48 <earldouglas> Koterpillar: maybe, I haven't read that one deeply yet.  I'll give it a read.
18:35:52 <puregreen> not sure if it'll help
18:37:29 <dappletasm> puregreen: that's helpful for testing that i've created "boundaries" where there should be..
18:37:57 <dappletasm> but less so for asserting that "TypeFun Int String" evaluates to a desired type..
18:38:27 <dappletasm> i'm interested in asserting positive things too
18:51:42 <mniip> hmm
18:55:07 <Gurkenglas> Is there some magic to have your state's type differ within a single do block?
18:56:39 <Axman6> as in calling a State Foo a inside a State Bar b?
18:56:58 <chsn> I'm at this point, where I feel the greatest limit to my haskell abilites is not writing code; but my ability to grok a large haskell codebase. Is there any tutorial for "reading large haskell codebases in vim/emacs"? (I'm willing to use either editor for reading)
18:57:53 <Welkin> chsn: start reading the yesod source
18:57:53 <Welkin> lol
18:58:04 <Welkin> there are better ones though
18:58:08 <chsn> no no, I meant *tools* to help me read large codebases
18:58:11 <Welkin> is parsec a good one?
18:58:12 <chsn> currently, I'm reading haste-compiler
18:58:25 <chsn> I want better *tools* to help me read large haskell cod ebases, not suggested codebases
18:58:37 <Welkin> what kind of tools?
18:58:49 <chsn> well, anythinb better than github.com
18:58:51 <Welkin> like emacs with haskell-mode mods?
18:58:59 <chsn> maybe a nice screencast would be helpful
18:59:16 <chsn> a screencast of soeone, using their editor of choice, showing how they jump around / use tools to help them grok haskell codebases
19:00:20 <Koterpillar> with eye tracking
19:00:50 <Gurkenglas> What was the correct way to get happy for building ghc-mod with stack?
19:01:23 <chsn> Koterpillar: fMRI of their brain as they read too
19:05:29 <ertesx> chsn: first choose an editor
19:05:36 <Gurkenglas> I thought this was right and that I'd already done that at some point but apparently not? lpaste.net/8821634045961043968
19:05:41 <ertesx> chsn: which tools you use to navigate code bases will depend on that
19:05:46 <byorgey> Gurkenglas: re: changing type of a state, maybe check out http://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Zoom.html
19:07:36 <ertesx> chsn: i can't speak for vim, but with emacs you would normally just use haskell-mode, ideally with haskell-interactive-mode…  the latter embeds a GHCi session and can query it to find symbols more precisely
19:08:24 <ertesx> chsn: find the entry point into the project, which is really a per-project thing…  if there are executables, Main is a good start, otherwise there is probably a module that has "core" character
19:08:36 <Gurkenglas> I mean something that doesn't look like composing (s -> (a, s)) and (a -> s -> (b, s)) into (s -> (b, s)), but (s -> (a, t)) and (a -> t -> (b, u)) into (s -> (b, u)).
19:08:40 <ertesx> chsn: from there just use symbol lookup to jump around
19:08:47 <ertesx> lookup and return
19:09:18 <Gurkenglas> (Where the a would, in the do block, be bound explicitly, but the t passed through the lines implicitly)
19:10:55 <Gurkenglas> I mean StateT Any works if you put toDyn and fromDyn around everything except what monster would do that
19:11:18 <ertesx> chsn: i think there are also extensions to get the "overview" style of navigation…  how helpful you find that probably depends on your brain wiring a bit…  personally i'm more comfortable with local views
19:12:47 <ertesx> haskell-mode can probably use the speedbar, if you configure it, to get yourself a bird's eye view
19:12:56 <Gurkenglas> It's the same sort of transformation where you write a lens library, delete the type annotation and let ghc reinfer it, and find out that your Lens' s a has actually been Lens s t a b all along
19:14:27 <ertesx> Gurkenglas: you may be interested in indexed monads, but you need extensions to use them with do-notation
19:14:40 <mniip> hmm
19:14:43 <c_wraith> lens is such a stabby library 
19:15:10 <Gurkenglas> And ideally %= would be "(Profunctor p, WeirdStuff s t m) => Setting p s t a b -> p a b -> m ()" rather than the current "(Profunctor p, MonadState s m) => Setting p s s a b -> p a b -> m ()"
19:15:17 <ertesx> Gurkenglas: those extensions (RebindableSyntax, NoImplicitPrelude) are pretty invasive
19:15:44 <Gurkenglas> Hmm pregoogling it sounds exactly correct (of course regular monads arent gonna do it i didnt expect that)
19:16:40 <athan> are hashmaps useful only for large collections? What about something with a known maximum, small size, like 4?
19:17:05 <Gurkenglas> And of course ekmett wrote it it's probably already lens-compatible or something :D
19:17:43 <ertesx> "pregoogling" sounds like a lens combinator
19:18:38 <ertesx> athan: sounds fine to me…  at that scale you may be giving up a few bytes, but also at that scale it probably doesn't matter =)
19:19:30 <athan> ertesx: I was considering an IntMap instead, with a let-binding mapping the 4 options to a small number, but that's basically just hashing isn't it?
19:19:44 <ertesx> athan: yeah
19:19:51 <athan> hah, right on
19:20:11 <ertesx> athan: if the size is static and fixed, and the field names are also predetermined, consider just using a record
19:20:37 <athan> ertesx: I was thinking that, but they're all optional
19:20:59 <ertesx> athan: data MyRec a = MyRec { _f1 :: Maybe a, _f2 :: Maybe a, … }
19:21:06 <athan> so a record of maybes might work, idk I was also thinking of an array or something haha
19:21:19 <athan> yeah :) thanks ertesx 
19:21:22 <mniip> hmm
19:21:24 <mniip> 	functor :: Ob k a => p a -> q f -> (Ob l (f a) => r) -> r
19:21:26 <mniip> I don't like this
19:21:55 <mniip> 1472091288 [05:14:48] <Gurkenglas> And ideally %= would be "(Profunctor p, WeirdStuff s t m) => Setting p s t a b -> p a b -> m ()" rather than the current "(Profunctor p, MonadState s m) => Setting p s s a b -> p a b -> m ()"
19:22:01 <mniip> IxState IxMonad?
19:22:03 <ertesx> athan: … deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
19:22:44 <mniip> https://hackage.haskell.org/package/category-extras-0.52.1/docs/Control-Monad-Indexed-State.html#t:IxMonadState
19:23:00 <mniip> (I didn't know this exists until just now)
19:23:19 <Gurkenglas> mniip, having read indexed-extras, "(Profunctor p, IxMonadState m) => Setting p s t a b -> p a b -> m s t ()"
19:23:47 <mniip> mst :D
19:24:59 <Gurkenglas> mniip, category-extras is deprecated and I think you're looking for the indexed and indexed-extras package
19:26:51 <mniip> argh
19:26:58 <mniip> why can't I use data in a where-clause
19:28:38 <Gurkenglas> And then the great part would be combining that with the bookkeeper package with my suggestions about reducing all the combinators to a single Lens s t a b for each symbol where (a ~ ()) means adding a field to your "book" (~record) and (b ~ ()) means removing it, and then you can build up your record at the start of your do block
19:28:40 <monochrom> would you fund a researcher to add it?
19:34:02 <MarLinn> mniip, that's actually something I'm working on. Or rather, I'm trying to figure out if/how we can drop "modules" and unify all remaining closures, giving them all the same power.
19:34:18 <MarLinn> Not something that'll come to any compiler near you soon, sadly.
19:35:36 <mniip> closures?
19:35:52 <MarLinn> Or "scopes" or "entities"
19:35:59 <mniip> scopes sounds better
19:36:04 <mniip> closures is already taken
19:37:28 <Welkin> clojures
19:37:35 <Welkin> no wait
19:37:40 <Welkin> cljrs
19:37:49 <Welkin> need to drop some vowels
19:37:54 <Welkin> and change some consonants
19:38:01 <Welkin> it's the new trend
19:38:09 <mniip> clos
19:38:15 <Welkin> CLOS
19:38:18 <mniip> one clo, two clos
19:38:32 <Welkin> CLOZ
19:38:47 <Welkin> what is the dumbest name you can come up with?
19:38:54 <Welkin> I have seen some pretty bad package names lately
19:38:55 <mniip> Welkin
19:38:56 <geekosaur> except to really be hip it'd need to be clozr
19:39:00 <Gurkenglas> https://hackage.haskell.org/package/indexed-extras-0.2/docs/Control-Monad-Indexed-State.html why would IxState not be IxStateT Identity
19:39:35 <Welkin> coffee-is-for-closures
19:40:01 <mniip> Gurkenglas, I don't think there quite exists a similar hierarchy of ixmonad ixtransformers
19:40:11 <mniip> also
19:40:16 <geekosaur> "extensions to haskell 98" I suspect it's still mtl1-flavored
19:40:35 <geekosaur> oh, or I misread that on quicj look... sigh
19:40:54 <geekosaur> (quicj? someone hurry and make that a module name >.> )
19:40:54 <geekosaur> package name
19:41:08 <mniip> I just spent 15 minutes trying to write an instance of a constraint-resolving function ((c => r) -> r) only to find out that I simply didn't import a module and didn't have instances in scope
19:41:16 <mniip> and the default \x -> x worked ;_;
19:42:49 <geekosaur> otherwise I guess look through the instances and see if any of them would be different, or perhaps identical but egregious
19:49:33 <xuxu> and i'm back
19:50:10 <xuxu> companies <- R.run h $ table "companies" :: IO [Datum] 
19:50:13 <xuxu> companies is [{"name":"tesla","id":"7781ee7e-1e43-4608-bb96-fe10cac3b53a"}]
19:50:28 <xuxu> Data.Aeson.toJSON companies
19:50:28 <xuxu> Array [Object (fromList [("name",String "tesla"),("id",String "7781ee7e-1e43-4608-bb96-fe10cac3b53a")])]
19:51:06 <xuxu> how does this work? this is where i struggle with haskell: interfacing with different types
19:51:53 <xuxu> i know that applicatives allow us to lift a value into a context and monads allow different types to interface with one another
19:52:24 <xuxu> i don't see how Data.Aeson.toJSON knew how to extract data from IO [Datum]
19:52:33 <xuxu> oh, IO is a monad
19:52:51 <xuxu> how did it know how to extract values from a Datum though?
19:53:31 <xuxu> :info Datum --> data Datum = R.Null | R.Bool Bool | R.String Text
19:53:52 <xuxu> | R.Object Database.RethinkDB.Datum.Object
19:54:19 <pavonia> There are typeclasses To/FromJSON that defines how to extract values of a certain type from JSON objects
19:54:19 * hackagebot pointedalternative 0.1.0.0 - Alternative done right  https://hackage.haskell.org/package/pointedalternative-0.1.0.0 (Gurkenglas)
19:54:29 <xuxu> there is an instance ToJSON Datum
19:54:47 <xuxu> pavonia: are you saying Data.Aeson looks from these ToJSON types?
19:55:11 <pavonia> It looks for the instances
19:55:21 <xuxu> if there wasn't a toJSON type, it wouldn't know how to translate the type?
19:55:43 <pavonia> *instance, yes
19:55:44 <xuxu> toJSON instance*
19:56:51 <xuxu> pavonia: thank you. that is greatly helpful
19:57:09 <xuxu> books and tutorials don't seem to mention this
19:57:55 <pavonia> What package are you using here?
19:58:14 <xuxu> Data.Aeson and Rethinkdb
19:58:37 <xuxu> Database.RethinkDB to be specific
20:01:32 <pavonia> Hhm, the aeson documentation explains how converting between JSOn and types work
20:01:51 <geekosaur> recent versions can also use generics, iirc
20:02:25 <xuxu> i'm also using spock
20:03:05 <ovum> Are you aware about any bridge bot?
20:03:19 <xuxu> i sent a message to the haskell beginners mailing list, but never saw a response
20:03:32 <xuxu> https://mail.haskell.org/pipermail/beginners/2016-August/017050.html
20:05:53 <xuxu> ovum: what's a bridge bot?
20:06:17 <ovum> I came to know about it last night only.
20:06:34 <ovum> Jaykul made for power shell
20:06:59 <ovum> Can you Google a bit or else I Could link you
20:07:09 <ovum> But I am on 2g connection
20:07:13 <ovum> xuxu
20:07:19 <xuxu> i googled but didn't find anything
20:07:34 <xuxu> are you taling about bridging irc with something else?
20:07:39 <xuxu> talking
20:07:42 <ovum> It's a bot for integration freenode and slack
20:07:46 <xuxu> ah
20:07:47 <ovum> Yes
20:08:05 <ovum> Are you aware about it?
20:08:26 <xuxu> are you asking if there is a bridge bot for this irc channel to a slack channel?
20:08:33 <Welkin> ovum: there was one in here and it got banned
20:08:38 <Welkin> because it was annoying stupid
20:08:45 <pavonia> Or a bot for playing brigde over IRC? :)
20:08:47 <ovum> (xuxu) are you asking if there is a bridge bot for this irc channel to a slack channel?
20:08:49 <ovum> Yes
20:09:18 <ovum> And also for any other bot for other channels and other  networks too
20:09:24 <ovum> Except irc also
20:09:25 <Welkin> why would you do that
20:09:31 <Welkin> that just causes problems
20:09:32 <Welkin> it is spam
20:09:48 <Welkin> no one wants slack in their irc
20:09:49 <ovum> banned Welkin Oh I see
20:10:48 <ovum> Which are other creative uses of bot you have came across?
20:10:55 <ovum> And found wonderful
20:11:45 <Welkin> games
20:11:49 <Welkin> and downloads
20:11:58 <ovum> Next question:which things you came across recently or learned; like I came to know about bridge bot and got excited to hear about its work
20:12:03 <Welkin> and, of course, lambdabot (and other interpreter bots)
20:12:18 <Welkin> ovum: chatterbots too
20:12:19 <ovum> Can you elaborate with some example? Welkin
20:12:25 <Jenaf> why doesn't ghci like to execute this function?
20:12:29 <Jenaf> propab :: Int -> Double
20:12:31 <Jenaf> propab b = 1/(fromIntegral (b+1))
20:12:33 <glguy> ovum: did you have a Haskell question?
20:12:38 <Welkin> Jenaf: because it isn't alive, so it can't like anything
20:13:21 <Jenaf> *non type-variable argument in the constraint Num [a]
20:13:24 <ovum> Can Haskell fetch image meta dat?
20:13:24 <ovum> Data
20:13:29 <Welkin> > let propab b = 1/(fromIntegral (b + 1) in propab 2
20:13:31 <lambdabot>  <hint>:1:40: error: parse error on input ‘in’
20:13:39 <Welkin> > let propab b = 1/(fromIntegral (b + 1)) in propab 2
20:13:41 <lambdabot>  0.3333333333333333
20:13:55 <Welkin> :t propab b = 1/(fromIntegral (b + 1))
20:13:57 <lambdabot> error:
20:13:57 <lambdabot>     parse error on input ‘=’
20:13:57 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
20:14:05 <Welkin> :t \b -> 1/(fromIntegral (b + 1))
20:14:07 <lambdabot> (Integral a1, Fractional a) => a1 -> a
20:14:34 <Welkin> :t \b -> 1/(fromIntegral (b + 1)) :: Int -> Double
20:14:35 <lambdabot> error:
20:14:35 <lambdabot>     • Could not deduce (Num (Int -> Double))
20:14:35 <lambdabot>         arising from the literal ‘1’
20:14:44 <Welkin> :t (\b -> 1/(fromIntegral (b + 1))) :: Int -> Double
20:14:45 <lambdabot> Int -> Double
20:14:48 <pavonia> Jenaf: What's the rest of the code? Your function doesn't use lists
20:14:53 <geekosaur> perhaps show what you actually did, since it works here
20:14:54 <MarLinn> How did a list get into the error message?
20:15:06 <Jenaf> I have no f*ing clue
20:15:12 <Jenaf> it also loades the file nicealy
20:15:26 <Jenaf> but when i try to execute the function I get that error
20:15:33 <Jenaf> gist incoming
20:16:23 <Jenaf> https://gist.github.com/anonymous/297b362cbecbac6767cfe9f5196108cf
20:16:28 <Jenaf> it's not much
20:17:31 <Jenaf> ghci says non type-variable argument in the constraint: Num [a] *When checking the inferred type
20:17:43 <pavonia> How do you call the function?
20:17:48 <MarLinn> Well there's your problem...
20:17:56 <geekosaur> still works here...
20:18:02 <MarLinn> (takeD (a-1) (b+1))+ ...
20:18:22 <geekosaur> that works too, I tried takeD 1 1
20:18:30 <MarLinn> no, mis-thought. Need more coffee.
20:18:34 <Jenaf> hehe
20:18:58 <Jenaf> somehow ghci fails at knowing that the fromIntegral should spit out a Double
20:18:58 <dmwit> Jenaf: Include the actual file you're loading, the command you try, and the exact error you get.
20:19:26 <glguy> dmwit: you're going to spoil the game
20:19:42 <dmwit> I just lost the game.
20:19:44 <geekosaur> can you add the *full* error message to the gist?
20:21:36 <glguy> does the error message have a mustache? guess who?!
20:22:15 * glguy wonders how common that kids' game was
20:22:20 <Jenaf> https://gist.github.com/anonymous/8ce6681e1b7302371349a2390a3fd919
20:22:48 <glguy> take
20:22:49 <pavonia> take /= takeD
20:23:06 <Jenaf> oh
20:23:17 <Jenaf> oh dang
20:23:21 <Jenaf> ineedmorecofee
20:23:52 * geekosaur glad he's not the only one having that kind of a $timeofday
20:24:22 <Jenaf> our cofee beans are all gone
20:24:31 <Jenaf> and its 5am so no cofee for jenaf
20:24:33 <Jenaf> =(
20:25:31 <Jenaf> at least it spit out the solution in less than a second 
20:29:36 <MarLinn> I feel that at 5am some of the more obscure typelevel stuff starts to make sense. (not to the compiler, naturally)
20:58:11 <chw> exit
20:58:11 <chw> quit()
21:32:48 <xuxu> are generics mostly useful for boilerplate, i.e. deriving instances of Eq, Show, etc.?
21:36:17 <dopplefuz> hello! more questions about type-level programming here
21:36:19 <dopplefuz> http://lpaste.net/180199
21:36:33 <dopplefuz> It seems type-level functions don't curry well!
21:36:47 <dopplefuz> or, i have to learn to program with them differently?!
21:36:58 <glguy> You mean you can't partially apply them?
21:37:22 <dopplefuz> glguy: yes, that seems to be the case
21:37:35 <glguy> Yes, it is the case that they must be fully saturated
21:37:36 <dopplefuz> even using the singletons library, I've run into issues
21:37:55 <dopplefuz> glguy: how does one use `Map` at the type-level, then?
21:38:38 <glguy> without type family arguments
21:39:09 <dopplefuz> glguy: i don't follow..
21:40:01 <dopplefuz> in my example, (+) is a type family, i guess? you're saying, i shouldn't use type families as arguments..?
21:40:10 <glguy> Yeah, you can use data types as arguments
21:40:24 <glguy> or data families
21:41:53 <glguy> "defunctionalization" is one of the tricks to work around this and the singletons package has some tools for that
21:42:10 <glguy> basically you provide a name for all the type families you want to use
21:42:29 <glguy> and when you're ready to resolve that name back to a type family you use an Apply type family
21:43:44 <dopplefuz> glguy: yes, i looked at TyFun and TyCon1,Tycon2,etc in singletons
21:44:04 <dopplefuz>  i was able to use them to create the example, which I pasted above..
21:44:43 <glguy> Your paste doesn't include any error messages
21:45:53 <dopplefuz> glguy: updated to contain the error message
21:46:25 <dopplefuz> to my understanding, one indexes TyCon1 with a k->k1 type family to get a "curriable" version...
21:46:45 <glguy> currying and partial application aren't the same thing
21:48:43 <Welkin> currying is required for partial application to work
21:49:04 <Welkin> currying is turning a function of many parameters into a function of one parameter that produces another function of one parameter
21:49:18 <dopplefuz> yes, i guess i need partial application at the type level
21:50:16 <dopplefuz> and that seems to be what the error is indicating i cannot do (the `((+) 1)` type family is an unsaturated version of `(+)`)
21:51:18 <dopplefuz> I tried wrapping it with `type Add1 a = a + 1`, but this still had the same error, because in the application to `Map` it's still unsaturated
21:51:47 <glguy> dopplefuz: Is this what you wanted: type Result = Map ((:+$$) 1) [1,2,3,4] ?
21:52:11 <glguy> *Type.List> :kind! Result -- Result :: [Nat] -- = 2 :$$$ '[3, 4, 5]
21:52:29 <glguy> http://hackage.haskell.org/package/singletons-2.2/docs/Data-Singletons-Prelude-Num.html#t::-43--36--36-
21:53:58 <dopplefuz> glguy: yes, that appears to be what i'm looking for, though i'd also like to know how it works! :)
21:54:02 <dopplefuz> thank you.
21:55:38 <glguy> dopplefuz: There's a unique name for every partial application of all the various type functions you might want
21:56:05 <glguy> and then the originally desired type function can be later reconstituted using Apply http://hackage.haskell.org/package/singletons-2.2/docs/Data-Singletons.html#t:Apply
21:56:10 <nshepperd> by the way, is there a special reason partially applying functions isn't allowed? will that ever be enabled?
21:56:13 <glguy> type family Apply (f :: k1 ~> k2) (x :: k1) :: k2
21:56:18 <nshepperd> er, type functions
21:57:32 <dopplefuz> glguy: yes, that makes sense.. i'd have to study apply a bit more, but the shape of it seems reasonable.
21:58:09 <geekosaur> there's some talk of finding a way to expose system f type lambdas, but at haskell level type lambdas pretty much destroy type inference
21:58:49 <dopplefuz> > :kind ((:+$$) 1) -- gives ((:+$$) 1) :: TyFun Nat Nat -> *
21:58:52 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
21:59:12 <dopplefuz> this seems not-saturated..
21:59:20 <dopplefuz> and yet it works with `Map`?
21:59:49 <glguy> dopplefuz: (:+$$) is a data type
22:00:10 <dopplefuz> therefore the partial-application restriction doesn't apply to it?
22:00:19 <asivitz> is there an easy way to turn a matrix (from the linear library) into a flat list of its values?
22:00:23 <glguy> dopplefuz: Right
22:00:51 <glguy> dopplefuz: It's a full-on "type" rather that a synonym or some other type
22:01:37 <glguy> dopplefuz: It's a full-on "type" rather than a synonym for some other type
22:02:03 <dopplefuz> ah, yes, i'd forgotten about that.. i don't really understand why that means partial application is suddenly ok, but i guess it makes sense since a full type would have more bookkeeping kept around 
22:03:58 <dopplefuz> now to figure out the shorthand for the defunctionalization symbols
22:04:02 <dopplefuz> :) thanks glguy 
22:04:12 <Welkin> asivitz: concat
22:04:17 <glguy> There's probably a paper or something to read
22:04:30 <Welkin> assuming a matrix is Vector (Vector a)
22:04:37 <dopplefuz> there are two in the docs for singletons
22:05:14 <Welkin> oh, wait
22:05:18 <Welkin> that is for a list of vectors
22:06:04 <Welkin> asivitz: create a new vector of size m x n, then copy the data over one vector at a time?
22:06:48 <Welkin> oh, of course
22:06:53 <Welkin> just cons the vectors all together
22:07:10 <Welkin> er, concatenate (++) them
22:09:28 <asivitz> they aren't lists. a matrix is a Vector4 (Vector4 Float). but the Vector4s can't be concatenated
22:10:16 <Welkin> asivitz: you could write your own function to do it though
22:10:41 <asivitz> yea. they do have traversable instances, I guess I can use that?
22:11:34 <asivitz> er, foldable I guess
22:13:51 <asivitz> ok, got it: (concatMap toList . toList) -- thanks :) I thought there might be some special sauce lens stuff but maybe not
22:26:20 <lpaste> MarLinn pasted “An extensible annotated tree - theoretically” at http://lpaste.net/180207
22:28:36 <MarLinn> I spent the night creating something complicated. I did not find any obvious errors yet. But I would still appreciate it if some of more experienced people could look at it and tell me what they think before I run headlong into disaster.
22:29:13 <MarLinn> The idea is to create a central structure that might be used by things like multi-stage compilers, pandoc, or diagrams
22:47:39 <MarLinn> Heh... wither the pros are not here, not interested, or still reading... welp, I guess I'll ask again later
22:47:44 <MarLinn> *either
22:51:22 <dramforever> MarLinn: What are the benefits of this over, say, data types a la carte?
22:53:17 <MarLinn> I don't know
22:53:45 <dramforever> You don't know that 'carte' thing? Maybe you want to have a look? http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf
22:54:12 <MarLinn> Thanks, I'll take a look!
22:55:19 <dramforever> (Note that Expr is well-known as recursion-schemes:Data.Functor.Foldable.Fix, and Term as free:Control.Monad.Free.Free. package:Module.Name, that is)
22:57:47 <MarLinn> So that would solve on of the three problems I tried to attack here, right? Namely the extensibility of node types.
22:58:29 <MarLinn> *one of
22:59:27 <dramforever> MarLinn: sorry but what are the three problems?
23:00:47 <dramforever> Hmm I think I can see 'annotation' and 'folding'
23:01:07 <MarLinn> Yes, exactly
23:01:15 <MarLinn> Those two plus extensibility
23:01:46 <dramforever> You have a huge deal of recursion combinators in recursion-schemes
23:02:15 <MarLinn> And maybe a la carte could do something about annotations, too, now that I think about it
23:02:47 <dramforever> Yeah I think you can put the annotation inside your functor
23:03:41 <dramforever> There's free:Control.Comonad.Cofree.Cofree like data Cofree f a = a :< (f (Cofree f a)), which is Fix but annotated, but you lose recursion-schemes to some extent
23:05:04 <dramforever> Hey, data Annot annot f a = Annot annot (f a)
23:05:19 <MarLinn> well if I can squeeze everything into types the normal fix might still work. That was the easiest trick once I found it
23:06:22 <MarLinn> That's in Control.Comonad.Cofree.Cofree?
23:06:24 <dramforever> The associativity problem can actually be fixed with a type-level list, you see
23:06:42 <dramforever> MarLinn: module Control.Comonad.Cofree, type Cofree
23:08:13 <MarLinn> Mhh... so much to read and learn XD
23:08:21 <dramforever> Annot works better with recursion-schemes
23:08:38 <dramforever> MarLinn: well for these things, literally just read the types
23:09:18 <dramforever> (Well, may fail with recursion-schemes though, but there are quite a few tutorials out there I think)
23:09:26 * hackagebot wires 0.1.0 - Functional reactive programming library  https://hackage.haskell.org/package/wires-0.1.0 (esz)
23:10:25 <MarLinn> Ok, I'll look for that
23:11:35 <MarLinn> Do you think the general approach - stuffing these three things into such a structure, not necessarily the way I did - would make a good framework for compiler-like stuff?
23:12:51 <joe9> http://dpaste.com/0Y65NR0 : my attempt to ensure that the logger thread does not lose stuff at the end. Any kind comments, please?
23:13:26 <MarLinn> The idea was that a compiler could transform an AST into a different one step by step or even into diagrams or documentation
23:13:41 <joe9> this is the output from ghci: http://bpaste.net/show/5cafd9ca0953
23:13:43 <joe9> when I run it.
23:14:25 <joe9> I am a noob with threads, so, any suggestions, please/
23:14:26 <ertesx> joe9: your logger can lose messages
23:14:27 * hackagebot stochastic 0.1.0.0 - Monadic composition of probabilistic functions and sampling.  https://hackage.haskell.org/package/stochastic-0.1.0.0 (chokboy)
23:14:42 <joe9> ertesx: still?
23:14:57 <dramforever> MarLinn: The annotation part just works as you see. As for folding, it may be painful to squeeze your function into a fold, but you could just take the structure apart
23:15:26 <ertesx> joe9: there is a gap between writing to a TChan and the logger thread picking it up…  if during that time the application exits, the message may never make it out of the TChan
23:17:06 <ertesx> joe9: why don't you just use a simple MVar lock?  anything more than that is basically just a highly convoluted version of that
23:17:09 <MarLinn> dramforever, yeah, I actually wanted to write a traverse, but then I didn't want to put even more types into it. So I went with the traverse-can-be-a-fold solution for now
23:17:37 <dramforever> The extensible part is the hardest, I think. You need to squeeze your function through typeclasses. *Or* you could make certain parts of your program pick a specific tree, but the other functions are not affected and still take general trees (may be constrained to some extent)
23:18:19 <joe9> ertesx, one of my threads is reading from a streaming server. I am logging the messages received. If I single-thread the logging portion, that will create a bottleneck as I am logging pretty generously.
23:18:59 <joe9> ertesx, I am generating too much logs (as I am still testing) and I cannot have the streaming thread blocked from reading.
23:19:55 <joe9> ertesx, I am using the lock on line 40 to signal shutting down to the logger thread.
23:20:17 <MarLinn> dramforever: mhh... and the way I have it now I would not need typeclasses but explicit type level sets plus wrapped functions, which boils down to the same
23:20:49 <joe9> ertesx, my assumption is that by using the lock and tryReadTChan, I would be flushing the channel
23:22:32 <ertesx> joe9: i'm not entirely sure about the semantics of TChan, but if you kill the logger last, it may work
23:22:54 <ertesx> joe9: BTW, instead of signalling you should use exception handling
23:23:05 <MarLinn> Maybe after I've read some more I'll just build a toy application with both approaches and see what I like. It's no use if the core structure that should make everything better is the one making everything harder
23:23:11 <ertesx> ideally together with withAsync (instead of async)
23:23:45 <MarLinn> So thanks a lot for the feedback and the tips, dramforever!
23:25:42 <dramforever> MarLinn: you might want to fix this: nodeChildren :: [Tree treeType annotationSystemN] (on line 63). Grammar trees have 'shapes' but you just put a list there. Functors specify the shape of the trees they want
23:26:56 <joe9> ertesx: s/async/withAsync on line 29?
23:28:34 <dramforever> Also this wouldn't quite work with stuffs like 'statements can contain expressions, expressions can contain lambdas, lambdas can contain statements' because the nesting is not homogenous here. I'm not aware adoptations of current extensible methods to these situations
23:28:35 <MarLinn> Mh.. so I guess I would want to pull out a functor from the node type with another type family
23:31:15 <MarLinn> Good point. Right now I can nest those, but not restrict the nesting. So... a type level tree, maybe...
23:31:34 <ertesx> joe9: basically, but the premise of withAsync is that you use exceptions for cleanup rather than signalling
23:31:52 <dramforever> Type parameters?
23:31:54 <ertesx> joe9: withAsync gets asynchronous exceptions right
23:32:45 <ertesx> joe9: use 'finally' (Control.Exception) to do the actual cleanup
23:33:31 <dramforever> data ASTKind = Expr | Stmt
23:33:31 <ertesx> joe9: note that you need to use 'cancel' explicitly, because withAsync only kills the thread…  it doesn't actually wait for it to exit
23:33:33 <dramforever> data
23:34:51 <joe9> ertesx, I am using withException of Control.Exception.Safe . It captures both synchronous and asynchronous exceptions
23:34:56 <dramforever> Hmm this is interesting, I think I'll investigate
23:35:24 <joe9> ertesx: nothing in the manual says that withAsync gets asynchronous exceptions.
23:35:33 <joe9> ertesx, it just says exceptions.
23:37:04 <joe9> ertesx: using withAsync instead of async http://dpaste.com/198H5JW
23:37:20 <joe9> interesting that there is no withTChan
23:40:21 <lpaste> MarLinn revised “An extensible annotated tree - theoretically”: “An extensible annotated tree - theoretically” at http://lpaste.net/180207
23:41:36 <joe9> ertesx: formatted version http://dpaste.com/0A0NW0Q
23:42:42 <joe9> ertesx: I think I get it about what you mentioned about using exception instead of signalling.
23:42:58 <joe9> ertesx: using throwTo loggerThread?
23:43:03 <MarLinn> So this could be a fix for the sub-tree shape. Now trees are only one of the shapes and the sub-shape can further restrict the node types. Absolutely not elegant, sadly.
23:44:28 * hackagebot tasty-golden 2.3.1.1 - Golden tests support for tasty  https://hackage.haskell.org/package/tasty-golden-2.3.1.1 (RomanCheplyaka)
23:45:19 <dramforever> Actually I was thinking, if we could use not functors, but let the last parameter take a tree shape instead
23:45:49 <dramforever> Something like: data AstKind = EXPR | STMT, then data AstF (kind :: AstKind) (r :: AstKind -> *) where ExprStmt :: r EXPR -> AstF STMT r
23:46:18 <joe9> ertesx: or, using cancel of async package
23:48:35 <ertesx> joe9: i recommend using the async library rather than throwTo/killThread, because it has waiting mechanisms
23:49:54 <joe9> ertesx, you mean the "cancel" of the async,correct?
23:50:05 <ertesx> joe9: yeah
23:50:16 <joe9> ertesx, and running the logging in a finally block
23:53:29 <MarLinn> Let me see if I get that right: r is the shape, and the constructor turns a shape of expressions into an ast of statement. I other words you're encoding the fact "an expression consists of a shape of statements"
23:55:06 <joe9> ertesx:  http://dpaste.com/24BSMX6 it actually made the code simpler.
23:55:33 <lpaste> dramforever pasted “'My best idea ever'” at http://lpaste.net/180217
23:55:35 <joe9> ertesx: formatted version : http://dpaste.com/1DP63JM
23:55:46 <dramforever> MarLinn: ^ that paste
23:56:13 <dramforever> Extensibility doesn't seem to fit in yet
