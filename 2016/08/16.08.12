00:01:04 <pavonia> Okay, so for simple structs it seems to be pretty simple, just create another wrapper function that gets an extra parameter of type struct_t* and assign the C function result to the dereferenced pointer, and then peek the pointer from the Haskell code
00:01:28 <athan> pavonia: lord have mercy...
00:02:46 <pavonia> Well, at least that's not as ugly as I was told it would be :p
00:07:07 <athan> :u
00:07:33 <athan> I can't `mod` 2
00:08:23 <ongy> :t mod
00:08:25 <lambdabot> Integral a => a -> a -> a
00:11:21 <athan> Do you even bro?
00:29:42 <eklavya> why is there a Tagged when there is newType ?
00:30:49 <glguy> The two aren't really related
00:31:11 <glguy> What connection were you focused on?
00:31:17 <eklavya> doesn't newType also provide phantom types?
00:31:30 <eklavya> I mean there is no runtime overhead
00:31:36 <eklavya> and I get a new type while compiling
00:31:52 <eklavya> so why have Tagged types?
00:32:39 <eklavya> wait, I maybe confusing ScalaZ Tagged types with Tagged
00:32:45 <eklavya> what is Tagged in Haskell?
00:33:16 <dramforever> This? https://www.stackage.org/haddock/lts-6.11/tagged-0.8.4/Data-Tagged.html#t:Tagged
00:34:10 <eklavya> dramforever: I am still understanding it like it's being used for phantom types
00:34:24 <eklavya> I read the docs on hackage
00:34:32 <glguy> eklavya: It is, and it has a bunch of instances and functions defined for it
00:35:02 <glguy> Your question is similar to asking why do we have a list type when we have the data keyword
00:35:14 <eklavya> omg :D
00:35:22 <eklavya> sorry
00:35:27 <eklavya> I am just not getting it
00:35:32 <eklavya> glguy: newTypes also provide the benefits of phantom types, no?
00:36:18 <glguy> Right, just like you could define your own list type and operations on that instead of using the built in []
00:36:21 <dramforever> Doesn't mean we shouldn't have a grand Tagged
00:36:33 <glguy> you could define a new type with a phantom type parameter
00:36:40 <glguy> and then define some operations on it
00:37:44 <eklavya> I think I am misunderstanding the terminology
00:38:04 <eklavya> Tagged types in Scala were being used as a newType alternative
00:38:13 <eklavya> in Rust they call them phantom types I think
00:38:23 * hackagebot stm-containers 0.2.15 - Containers for STM  https://hackage.haskell.org/package/stm-containers-0.2.15 (NikitaVolkov)
00:38:25 * hackagebot slave-thread 1.0.2 - A principal solution to ghost threads and silent exceptions  https://hackage.haskell.org/package/slave-thread-1.0.2 (NikitaVolkov)
00:38:33 <eklavya> but here Tagged is a Phantom type but it provides something else/more?
00:38:38 <saurabhnanda> Please read and give feedback: https://medium.com/@saurabhnanda/why-building-web-apps-in-haskell-is-harder-than-it-ought-to-be-c9b13de0be4f#.ya3siitlq
00:38:39 <dramforever> If I get it right Tagged in Haskell is just a normal type
00:38:57 <glguy> Yeah, Tagged in the tagged package is a normal newtype already defined
00:39:15 <glguy> that you can use and then it's got instances and functions ready to go
00:39:36 <glguy> A "phantom type parameter" is a type parameter that isn't used in any of the fields of the type
00:39:37 <eklavya> glguy: can you please give an example of where this is useful?
00:40:39 <glguy> You could make: class C a where specialInt :: Tagged a Int
00:41:05 <glguy> Tagged plays a role in the lens package as being one of the types you use as a profunctor as a more exciting case
00:42:10 <eklavya> what do I gain with that specailInt?
00:42:33 <saurabhnanda> Why building web-apps in Haskell is harder than it ought to be  -- https://medium.com/@saurabhnanda/why-building-web-apps-in-haskell-is-harder-than-it-ought-to-be-c9b13de0be4f#.ym0npkbz0
00:42:36 <glguy> http://lpaste.net/167805
00:43:14 <glguy> eklavya: You can associate an Int with a type, whatever that might mean for your particular application
00:43:40 <glguy> Here, that paste uses Tagged to compute the field names of a record
00:44:28 <dramforever> ( Tagged t a ) is like ( Proxy t , a )
00:44:35 <eklavya> I don't understand that paste, I will take a better look
00:45:13 <eklavya> glguy: so kind of like changing semantics? like tagging stages of an operation? Which stage is this Int at kind of thing?
00:45:51 <eklavya> but that is I think easier with just newTypes, let me try and understand your paste
00:46:02 <eklavya> that looks like a better case
00:46:12 <glguy> You could define your own Tagged type using the newtype keyword
00:46:23 <glguy> but you'd just be reinventing something that's already done and packaged
00:46:35 <eklavya> ok
00:46:45 <glguy> and you might do that if you wanted it ot be distinct from the existing Tagged newtype
00:46:50 <glguy> Tagged is a newtype
00:47:29 <eklavya> ok
00:47:45 <eklavya> what does the @ before f mean in your paste?
00:49:14 <glguy> Explicit type application
00:49:36 <eklavya> meaning?
00:50:13 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=typeapplication#ghc-flag--XTypeApplications
00:50:13 <dramforever> "Let the type variable be ..."
00:50:45 <glguy> retag @f gselNames   is short for     retag (gselNames :: Tagged f [String])   in this context
00:51:19 <eklavya> wow, this is a useful extension I have to do type annotations all the time :P
00:51:51 <eklavya> oh wait
00:51:56 <eklavya> ok
00:52:43 <av_> hi everyone, is there a way of finding out where exactly a variable is bound to its type?  I ran into yet another conflict while using AD and can't figure out where to put that auto
00:53:07 <bitfurry> hi everyone, I have started learning functional programming. Can someone suggest good paper to start learning ?
00:54:46 <eklavya> glguy: that paste is way beyond my Haskell understanding for now :(
00:55:41 <glguy> That's OK, you probably won't need Tagged generally, either
00:55:47 <saurabhnanda> is there a way to "extend (or wrap) a record" such that all lenses that worked on the original record, still continue to work?
00:56:29 <glguy> saurabhnanda: That's the idea behind the "makeClassy" TH lens/class generator
00:56:44 <av_> bitfurry: any blank paper and a pencil will do, that's how I started. it's amazing how much you learn that way
00:57:26 <av_> bitfurry: and the Euler project
00:59:24 <saurabhnanda> glguy: here's what I mean: http://lpaste.net/176137
00:59:30 <bitfurry> av_: you suggesting to solve Project Euler problems  ?
01:02:25 <saurabhnanda> glguy: any idea how to make this work?
01:03:07 <saurabhnanda> glguy: actually even if I can figure out how to write my own lenses, I can make this work. Will require a lot of boilerplate code, but it will still work.
01:04:07 <platz> is there a more general way to define this func that doesn't deconstruct and then throw, would expect some way to lift Either into MonadError more naturally
01:04:10 <platz> eitherToMonadError :: MonadError e m => Either e a -> m a; eitherToMonadError = either throwError return
01:04:47 <glguy> platz: looks pretty good
01:06:14 <platz> hrmmm.. so i can specialize a MonadError into an Either, but I can't lift Either into MonadError without a pattern match + return
01:06:17 <platz> can't
01:06:45 <av_> bitfurry: that's right
01:07:30 <glguy> saurabhnanda: I don't know what the tricky part of your paste is other than that your download record doesn't have a gid or logid, so those aren't going to be accessible with lenses from a download value
01:07:56 <saurabhnanda> glguy: Download wraps DB.Download, which has all those fields
01:08:10 <saurabhnanda> glguy: that's what I mean when I said I want to "extend/wrap a record"
01:08:21 <glguy> saurabhnanda: OK, then check out makeClassy from the lens package
01:08:24 <glguy> It's relevant
01:09:02 <bitfurry> av_: thanks 
01:09:03 <saurabhnanda> okay, checking now
01:10:08 <glguy> I'm going to bed, but hopefully someone else online knows about makeClassy if you get stuck
01:12:57 <James123> Hi! I am doing `import qualified Data.Set as Set' in ghci, and then let s = Set.Set [] and I am getting not in scope data constructor Set.Set. Any ideas?
01:14:03 <ahihi> maybe you wanted Set.fromList?
01:14:57 <James123> Thanks! So Set.Set is not really a constructor?
01:15:08 <James123> Even if I do :t Set.Set I get the same error.
01:15:12 <ahihi> there is no constructor for Set exported
01:15:14 <saurabhnanda> glguy: do you know how to combine multiple lensRules?
01:15:32 <saurabhnanda> glguy: I need to combine classyRules and abbreviatedFields
01:17:27 <pavonia> If you have a ``foreign import ccall "wrapper.h function"´´, what exactly does that "wrapper.h" part denote? It doesn't seem to have any effect if I include it, leave it off or even use a different header file name than the one that declares the function
01:35:18 <maybefbi> how do i use CPP preprocessor with stack?
01:37:03 <Axman6> you can use the LANGUAGE CPP pragma in the file which needs it
01:43:37 <maybefbi> Axman6, thanks. i got it working finally using cpphs as a build dependency and "  ghc-options:         -cpp  -pgmPcpphs  -optP--cpp" line in the library target in my stack project cabal file.
01:43:49 <maybefbi> LANGUAGE CPP pragma was already there
01:51:26 <Axman6> huh, strange, I've never had to do any of that to use CPP
01:52:28 <maybefbi> Axman6, i need __LINE__ and __FILE__ in my error messages. or else it is very hard to debug
01:53:48 <quchen> Can anyone point me to the Report mentioning how definitions with multiple cases are translated? e.g. “not True = False; not False = True” has two definitions of “not” following each other
01:54:13 <quchen> (The result is a single definition of the “not” value, of course)
01:56:28 <saurabhnanda> anyone familiar with lenses? Can classy-lenses handle overloaded field names?
01:58:10 <pavonia> quchen: 4.4.3.1 of https://www.haskell.org/onlinereport/haskell2010/haskellch4.html
01:58:50 <mauke> maybefbi: alternatively, you can use TH versions of __FILE__ and __LINE__ without needing cpp
01:59:06 <quchen> pavonia: Thanks!
01:59:37 <mauke> maybefbi: http://hackage.haskell.org/package/pseudomacros-0.0.2/docs/PseudoMacros.html
01:59:52 <maybefbi> mauke, yeah but TH slows down build times
01:59:58 <maybefbi> CPP is fast
02:00:14 <mauke> point
02:00:42 <mauke> I just distrust cpp because it likes to fuck up non-C code
02:01:22 <maybefbi> maybefbi, i will change away from CPP when i face that
02:01:25 <ongy> TH is haskell cpp is borrowed from outside (though cpp might be less intrusive at the end)
02:03:26 * hackagebot quickcheck-arbitrary-adt 0.1.0.0 - Generic typeclasses for generating arbitrary ADTs  https://hackage.haskell.org/package/quickcheck-arbitrary-adt-0.1.0.0 (mchaver)
02:06:36 <saurabhnanda> anyone familiar with lenses? Can makeClassy be used along with makeFields? Basically I need classy-lenses for overloaded field names. Is it possible?
02:25:08 <Axman6> shookees: #haskell-lens might be more helpful (though conversation in there can be few and far between)
02:26:36 <shookees> hi Axman6?
02:26:44 <Axman6> Hello
02:26:54 <Axman6> uh, sorry, that was for saurabhnanda >_<
02:27:09 <saurabhnanda> Axman6: thanks
02:33:54 <quchen> Is there a way to suppress "expected ..." in Trifecta?
02:34:10 <quchen> I’ve got an error where that information is misleading, and I’d like to get rid of it.
02:40:32 <srhb> Is there a way to disable the infinite loop detection?
02:51:03 <saurabhnanda> hi lens gurus, can anyone help me with http://stackoverflow.com/questions/38914782/how-to-get-classy-lenses-with-overloaded-field-names
02:58:43 <jchia> I'm trying to find the index of an element in a Data.Array.IArray.Array. is using findIndex on the elems of the array a good idea? Is ghc smart enough to avoid actually creating any list?
03:00:15 <athan> jchia: Where's findIndex?
03:00:22 <jchia> Data.List
03:00:35 <jchia> basically convert array to list and then doing findIndex on the list
03:01:02 <jchia> Array itself doesn't seem to have a function to find the index given a value
03:01:15 <James123> Can anyone explain foldl (\acc@(x,y) elem@(x',y') -> if y > y' then acc else elem) (0,0). The function for foldl confuses me as it doesn't look like a standard \x y. What is the @ for?
03:01:15 <athan> yeah, arrays aren't intended for that :\
03:01:28 <athan> jchia: I would bet on its worst case
03:01:52 <athan> James123: Those are "as patterns", basically a reference to the pattern match
03:01:59 <jchia> there are only 5~12 items in the array
03:02:25 <jchia> should i use a list? lists have poor data locality
03:02:42 <athan> let xs = (,) <$> [1..5] <*> [1..5] in map (\x@(_,_) -> x) xs == xs
03:02:47 <athan> > let xs = (,) <$> [1..5] <*> [1..5] in map (\x@(_,_) -> x) xs == xs
03:02:48 <lambdabot>  True
03:02:59 <glaukon> I have created a new stackoverflow question at http://stackoverflow.com/questions/38904378/duplicate-edsl-code-generated-with-recursivedo-in-haskell
03:03:02 <athan> jchia: I think you should be asking "why don't I know the index of this element?"
03:03:11 <michaelt> use Data.Vector.Unboxed (if possible) and then `elemIndices`
03:03:20 <athan> michaelt++
03:04:12 <cocreature> you can just use findIndex, vector provides that
03:05:13 <michaelt> there are several operations like this in vector
03:06:17 <jchia> athan: Example: There are 50 students in a class. For each of 5 subjects, I store the top 3 students' names in a sequence. Given a student's name, and a subject, I want to find the student's ranking if the student is one of the top three.
03:07:16 <jchia> i don't need to store every student's ranking. the ranking sequence is small, so using a hashmap would be overkill
03:08:35 <athan> I'm not sure how array is represented under the hood, but I'm pretty sure folding over them lazilly isn't feasible
03:09:00 <athan> like they're intentionally block-y; to turn an array into a list means you turn the _whole_ array (structure) into a list
03:09:03 <athan> (I think)
03:09:08 * athan hides
03:09:29 <jchia> OK, i could use Data.Vector.elemIndex, but I already know at compile time the size of the sequence
03:09:45 <athan> jchia: You may find better luck with lists honestly
03:09:58 <athan> you don't seem new to haskell, are you writing benchmarks?
03:10:18 <jchia> no, usually write C++ where i have the habit of paying only for what i use
03:10:32 <jchia> no, i usually write C++ where i have the habit of paying only for what i use
03:10:46 <athan> ahh okay
03:10:46 <jchia> i'm newer to haskell than to C++
03:10:49 <michaelt> Lists are seeming okay for this.
03:10:53 <athan> I would start with lists then
03:11:14 <athan> they can actually be pretty darn fast
03:11:41 <maerwald> only if you walk through all elements anyway
03:14:41 <av_> can nobody tell me a way of finding out where exactly a variable is bound to its type?  I ran into yet another conflict while using AD and can't figure out where to put that auto
03:14:45 <jchia> I'll try list. In C++, I usually pick the leanest structure that provides the features i need. In haskell, I suppose it's write first, profile and then optimize?
03:15:01 <athan> av_: a term variable or a type variable?
03:15:04 <jchia> i haven't tried profiling anything in haskell
03:15:13 <ggVGc> I mostly end up with a Map or IntMap in the end...
03:15:18 <ggVGc> so now I tend to just start off with that
03:15:21 <athan> jchia: haskell isn't exactly a traditional machine :)
03:15:25 <av_> athan: term variable
03:15:39 <maerwald> jchia: yeah, reasoning about performance (also wrt data structures) isn't that straight-forward in haskell and usually involves try&error
03:15:42 <athan> av_: Okay wait, so what compile error are you getting?
03:15:55 <jchia> OK
03:16:20 <athan> jchia: think more about the least-amount of witnessed data during computation, and that's what's actually getting plumbed under the hood
03:16:21 <jchia> i suppose i shouldn't feel uncomfortable using list unless i see actually unacceptable performance
03:16:25 <ggVGc> maerwald: is this inherent for FP implementations, or for haskell?
03:16:28 <athan> sorta kinda
03:16:35 <ggVGc> the difficulties of measuring performance
03:16:39 <athan> jchia: Which there are times too!
03:16:58 <maerwald> ggVGc: mh, both I guess. One thing that is a problem is laziness, but also the fact how "functional" works
03:17:27 <jchia> athan: what does it mean by "least-amount of witnessed data"? Do you mean the parts that actually get evaluated?
03:17:41 <maerwald> ggVGc: which is the reason why idris went strict-by-default
03:17:43 <athan> jchia: Yep, exactly
03:17:52 <ggVGc> I uess the main issue is that our machines are not functional at all
03:17:56 <saurabhnanda> trying again, can anyone help me with http://stackoverflow.com/questions/38914782/how-to-get-classy-lenses-with-overloaded-field-names
03:18:05 <athan> when I do `let foo = ... in ....` but never reference foo, it's never evaluated
03:18:36 <athan> (again don't quote me lol)
03:18:44 <athan> (something something Core closures)
03:18:51 <maerwald> ggVGc: yeah, our functions don't translate directly to machine instructions. C/C++ is pretty darn low-level and the step to asm isn't even that big. So it's not uncommon to look at the asm code and check what happened.
03:18:55 <maerwald> that's not so much fun in haskell
03:19:43 <ggVGc> and not useful
03:19:46 <ggVGc> mostly
03:19:58 <lpaste> av pasted “AD build error” at http://lpaste.net/176168
03:20:10 <ongy> for haskell C-- representation (is that still a thing?) is low level to look at
03:20:27 <ggole> As a counterpoint, I look at ocamlopt's asm output fairly regularly
03:20:34 <ggVGc> ongy: doesn't tell you much about your overall performance characteristic though I think
03:20:37 <ggole> Some of the common performance pitfalls are fairly easy to spot
03:20:38 <maerwald> ongy: ok, can you reason about C-- wrt performance? does anyone know about it? where are tutorials and blog posts?
03:20:40 <ggVGc> since things get rewritten so much
03:20:43 <av_> athan: just hpasted the ghc error
03:21:38 <cocreature> av_: your functions need to be polymorphic to be ad’eable (is that a word?)
03:21:45 <athan> ongy: iirc it's Core/System_Fc -> STG -> C--
03:21:49 <ongy> I was told to look at the C-- when I was asking here for something. But iirc it was about if ghc is able to optimize something out. So reasoning about performance in a case of "is this list even build". But I don't really have any experience with it
03:22:17 <athan> cocreature: fmap eable [a,d]
03:22:42 <athan> ongy: me neither :\
03:22:48 <athan> core isn't too hard to read though
03:22:58 <athan> (with small inputs)
03:23:13 <ongy> I still haven't figured out how to read the -ddump-simpl with optimization...
03:23:21 <ongy> I should look into that at some point. but it's hard
03:23:37 * athan glances to lens
03:23:39 <athan> yeah...
03:24:48 <av_> athan: sure. this is part of a large program, if I try to make a small demo for this problem, it just works...  so I need to figure out where the monomorphism comes from
03:25:37 <athan> av_: I'd bet there's a warning saying "assuming blah blah blah to Double"
03:26:30 <av_> athan: no, I probably wouldn't have to ask then...
03:26:47 <athan> av_: Ahh okay yeah, so you must be using number literals and expecting them to coerce to `Reverse s Double`
03:27:02 <athan> hrm
03:27:46 <athan> maybe you're mixing scalar logic with it?
03:27:55 <athan> ahh yeah totally
03:28:02 <athan> type Scalar (Reverse s a) = a
03:28:24 <athan> so you must be just trying to natively use `*` or something with a `Scalar (Reverse s a)` or some shit
03:28:58 <athan> av_: ^
03:29:57 <athan> av_: I think you should use *^ or something
03:31:54 * av_ is scratching his head
03:32:02 <athan> av_: If I were you, I would staple it to the teeth and pin down the types of all your variables
03:32:12 <quchen> “Is this list even built” is answered at the Core level.
03:32:28 <quchen> I doubt C-- is of any help here.
03:33:16 <av_> athan: that's what I tried to avoid
03:33:37 <av_> athan: thanks anyway
03:33:37 <athan> av_: ambiguity be damned :)
03:33:43 <athan> np
03:35:26 <athan> av_: Can I see the expression?
03:35:30 <athan> with jacobian I mean
03:36:40 <{AS}> Has anyone tried Haskell for OS X and can recommend it?
03:36:55 <athan> {AS}: I've known many who have, and enjoy it
03:37:04 <athan> it's practically the same as *nix
03:37:17 <{AS}> athan: I meant http://haskellformac.com/
03:37:23 <athan> oh herp
03:37:31 <{AS}> sorry, I got the name wrong :)
03:37:31 <athan> I'd just use stack
03:37:38 <ahihi> I just use stack as well
03:37:41 <Gurkenglas> Where should "uniformMay :: MonadRandom m => [a] -> m (Maybe a)" be put? Control.Monad.Random right?
03:37:43 <athan> stack will fetch your ghc versions, all the goodies
03:37:52 <{AS}> ah cool
03:37:59 <Gurkenglas> (Because I'm considering safe, but ehhh unneeded dependency?)
03:38:17 <athan> Gurkenglas: I'd say so, due to MonadRandom
03:38:26 <athan> all mtl-y
03:40:04 <av_> athan: sorry, can't make the rest public
03:40:19 <athan> foux shoux
03:45:36 <Wizek_> puregreen, monochrom, ertes First working POC of a dependency injection in haskell :) https://github.com/Wizek/haskell-dependency-injection/commit/fe022da6356d6640a7c179d50d3e54119263f3e0 Very messy at this point though, hoping to clean it up considerably
03:58:22 <{AS}> Is Overloaded record fields not available yet?
03:58:34 <black0range> It is available in the latest release of ghc :) 
03:58:39 <athan> {AS}: Nope
03:58:48 <{AS}> Ah, thanks
03:58:50 <athan> I think we have duplicate record fields, but you still run into namespace issues
03:58:59 <athan> iirc
03:59:41 <black0range> Sorry i mixed those names together :) 
04:04:45 <{AS}> why can't one derive show for an empty data type?
04:05:03 <{AS}> or eq
04:05:54 <{AS}> I mean it is empty so everything that takes it as input can derive something :)
04:05:56 <athan> {AS}: What can you reference? :)
04:06:03 <athan> try writing it by hand
04:06:05 <ahihi> I'm not sure what those instances would look like
04:06:14 <{AS}> show :: Void -> String; show x = case x of { }
04:06:15 <mniip> show = absurd
04:06:38 <athan> Oh wait yeah you're right
04:06:47 <athan> I think derived data needs to be tangible in a sense
04:06:51 <athan> ...from Generic?
04:06:59 <mniip> Generic has V
04:07:07 <athan> hm :\
04:07:32 <athan> that's a really interesting correlation though {AS}
04:07:47 <athan> so you're saying `Void` can satisfy _any_ `* -> Constraint`?
04:07:53 <mniip> no
04:08:04 <mniip> only those where the constraintee appears contravariant
04:08:38 <athan> mniip: Ahh, (* -> Constraint) -> Constraint?
04:08:49 <{AS}> athan: It depends on the functions for the constraint
04:09:14 <{AS}> if Void appears in all of the functions as an argument then it is satisfiable
04:09:21 <athan> Ahh shoot okay yeah that makes sense
04:09:50 <athan> so only ones that "consume" Void?
04:09:57 <{AS}> athan: Yeah
04:10:10 <athan> and are pointed in the codomain?
04:10:21 <mniip> well actually it can "produce" Void too but only after "consuming" it
04:10:38 <mniip> I'm not sure I can exactly formulate this structurally
04:10:59 <athan> I understand that
04:11:09 <athan> given it's already provided, you can produce it
04:28:35 <fuk-off> Don't EVER smoke shrooms without PCP!
04:29:10 <fuk-off> its just that the shrooms make the aliens appear and you need the PCP burst of strength to fight the alien invasion like the Hulk
04:30:18 -fuk-off(~flop-dick@162.243.78.182)- Don't ever smoke shrooms without PCP.  its just that the shrooms make the aliens appear and you need the PCP burst of strength to fight the alien invasion like the Hulk
04:30:45 <srhb> @ops
04:30:45 <lambdabot> Maybe you meant: pl oeis docs
04:30:47 <srhb> @where ops
04:30:48 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
04:31:24 <fuk-off> LOL
04:31:30 <fuk-off> @where ops
04:31:30 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
04:33:03 --- mode: ChanServ set +o mauke
04:33:03 --- mode: mauke set +b $a:fuk-off
04:33:22 <ongy> is the list in lambdabot not up to date?
04:33:24 --- kick: fuk-off was kicked by mauke (bye)
04:33:31 <mauke> it doesn't have to be
04:33:37 <mauke> I highlight on "@where ops"
04:34:34 <srhb> mauke: Thanks.
04:35:24 --- mode: mauke set -o mauke
04:41:53 <ongy> @pl oeis docs
04:41:53 <lambdabot> oeis docs
04:45:48 <srhb> ongy: Silly you, oeis docs is already pointless ;-)
04:46:09 <ongy> srhb: also pointfree :)
04:46:38 <ongy> are nicks like implementation and pointfree here so we can tabcomplete on common stuff, or just people that like highlights?
04:47:09 <srhb> @oeis A000045
04:47:14 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.[0,1,1,...
04:47:19 <srhb> Useful...
04:47:36 <ongy> what?
04:48:02 <ahihi> @oeis A000004
04:48:05 <lambdabot>  The zero sequence.[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
04:48:05 <srhb> oeis is that integer sequence encyclopedia
04:48:45 <Saizan> @oeis 0,1,1,2
04:49:14 <lambdabot> Plugin `oeis' failed with: <<timeout>>
04:51:17 <implementation> ongy: if I wasn't highlighted that often, I'd totally forget that this channel exists. but this keeps me reminded :)
04:52:42 <implementation> but you can use me for tab completion too, i won't complain about it
04:52:52 <srhb> Haha, I had no idea.
04:57:35 <Maxdamantus> @oeis 0,2,4,5,7,9,11,12
04:57:39 <lambdabot>  Numbers that are congruent to {0, 2, 4, 5, 7, 9, 11} mod 12.[0,2,4,5,7,9,11,...
04:57:50 <Maxdamantus> Heh.
04:58:10 <Maxdamantus> What is X? It is X.
04:58:31 * hackagebot language-hcl 0.1.1.0 - hcl and conf parsers and pretty-printers for the Haskell programming language.  https://hackage.haskell.org/package/language-hcl-0.1.1.0 (yamadapc)
04:58:33 * hackagebot language-conf 0.1.1.0 - Conf parsers and pretty-printers for the Haskell programming language.  https://hackage.haskell.org/package/language-conf-0.1.1.0 (yamadapc)
05:03:32 * hackagebot language-conf 0.1.2.0 - Conf parsers and pretty-printers for the Haskell programming language.  https://hackage.haskell.org/package/language-conf-0.1.2.0 (yamadapc)
05:03:34 * hackagebot kaleidoscope 0.1.0.0 - Haskell Kaleidoscope tutorial  https://hackage.haskell.org/package/kaleidoscope-0.1.0.0 (sdiehl)
05:03:44 <implementation> @oeis 0,3,8,15,24,35,48,63
05:03:49 <lambdabot>  a(n) = n*(n+2) (or, (n+1)^2 - 1).[0,3,8,15,24,35,48,63,80,99,120,143,168,195...
05:04:04 <implementation> wow
05:08:32 * hackagebot language-hcl 0.1.2.0 - HCL parsers and pretty-printers for the Haskell programming language.  https://hackage.haskell.org/package/language-hcl-0.1.2.0 (yamadapc)
05:18:32 * hackagebot fay 0.23.1.13 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  https://hackage.haskell.org/package/fay-0.23.1.13 (AdamBergmark)
05:30:49 <quchen> Does anyone know more about the ParsecT type? It has a number of fields that I don’t really understand.
05:31:14 <quchen> committed ok, committed error, empty ok, empty error?!
05:35:46 <lyxia> the continuation to take depending on whether input was consumed, and whether parsing failed?
05:41:52 <Ford_Prefect> Anyone know what this kind of failure might mean?
05:41:55 <Ford_Prefect> http://hastebin.com/iladomorad.js
05:42:07 <Ford_Prefect> (yes, I know I'm a terrible person for building as root, will fix that once I actually get things working)
05:42:13 <Ford_Prefect> This is on an ARMv7 box
05:42:46 <mniip>  /root/raaz-crypto/raaz/.stack-work/logs/mtl-2.2.1.log
05:43:27 <Ford_Prefect> Pretty much just has the two lines from the output about 'Perhaps a 'foreign import unsafe' should be 'safe'?'
05:44:05 <Ford_Prefect> rerunning stack setup since it didn't succeed when I first ran without a system ghc
05:44:51 <Ford_Prefect> Lots of:
05:44:54 <Ford_Prefect> Did not find .cabal file for time-parsers-0.1.0.0 with Git SHA of ab587516bfbdef95a0b7ae0171584b05760990eb
05:45:10 <mniip> what was the command that preceeded that
05:56:28 <Ford_Prefect> stack build is pretty much it
05:56:52 <Ford_Prefect> What I pasted is the entire output of the command line from when I stack build
05:59:03 <joe9> Can anyone please comment on this: http://dpaste.com/314ZVEQ Which is a better option? using a typeclass or a record.
05:59:24 <joe9> I cannot figure out how to thread user state across callbacks when using the record option.
06:08:39 <c_wraith> joe9: why are your operations different between the two versions?
06:09:25 <c_wraith> joe9: Oh, I see.  Your question isn't really record of functions vs typeclass, since you have no record of functions version.
06:10:16 <c_wraith> joe9: to make the comparison work, you need the MarketState data type to contain functions.
06:13:12 <saurabhnanda> trying again. Can anyone help with http://stackoverflow.com/questions/38914782/how-to-get-classy-lenses-with-overloaded-field-names (How to get classy lenses with overloaded field names?)
06:13:57 <joe9> c_wraith: I want to be able to show and read the data, hence, am not using the functions
06:14:30 <c_wraith> joe9: You have to use functions to do what you want.  That means you'll have to write your own serialization, but it's not that hard.
06:15:25 <c_wraith> joe9: you can't show or read StreamingStateC either.  *shrug*
06:15:54 <c_wraith> Oh, I guess you can.  I was mislead into thinking it was an existential, when it's clearly not.
06:16:01 <c_wraith> If it was, you couldn't show or read it.
06:16:32 <jchia_> What can I do to simplify this? I'm interested in getting rid of the 'if-then-else'. http://lpaste.net/176209
06:16:56 <c_wraith> jchia_: use guards?
06:17:12 <lyxia> or the guard function
06:19:07 <unit73e> hey. I have a theoretical question. do you guys think it would be a good idea to make a new DB engine more compatible with haskell type system or is it better to just continue doing the binding with current DB engines?
06:19:09 <c_wraith> the guard function is definitely better for the if on line 12
06:19:58 <netheranthem> unit73e: I'm not sure, it sounds like using something like a subset of Postgres could very well do the trick
06:20:24 <c_wraith> unit73e: depends on your purpose.  a full RDBMS is a massive undertaking, especially to get ACID guarantees.
06:21:05 <c_wraith> unit73e: if your goal is something simpler, it starts to make more sense to reimplement it.
06:23:45 <joe9> c_wraith: How can I read/show data when I change the 'a' in StreamingStateC to (a -> MarketState)?
06:24:22 <joe9> c_wraith: "writing your own serialization, but, it's not that hard" - any pointers, please?
06:24:27 <c_wraith> joe9: you can't use read/show.  That doesn't mean you can't serialize.  It just means you need to take a bit more care.
06:24:34 <unit73e> yeah. It is kind of a massive undertaking and postgres seems to be nicely built. Maybe I'm just gonna do it anyway and probably fail hard but learn something :P
06:24:35 <unit73e> thanks
06:24:55 <c_wraith> unit73e: take a look at acid-state as a potential starting point.
06:25:01 <c_wraith> @hackage acid-state
06:25:01 <lambdabot> http://hackage.haskell.org/package/acid-state
06:25:41 <c_wraith> As a first step, learn how it works - and why it's basically unused these days. :)
06:25:49 <jonored> Fiddling with building building RDBMS bits /is/ a pretty interesting project, at the least. I did some streaming database stuff in college for similar reasons.
06:27:41 <srhb> What's the simple way of parsing a UTCTime (today) from a simple hh:mm clock time in thyme?
06:29:27 <hpc> srhb: look at the FormatTime and ParseTime classes
06:29:51 <hpc> oh, thyme is a package
06:30:25 <c_wraith> thyme was designed to have as close to the time interface as possible, but a much faster internal representation.  iirc
06:30:36 <srhb> c_wraith: That's how I understood it as well. 
06:31:04 <joe9> c_wraith:  IS this what you have in mind for serializing functions?
06:31:22 <srhb> But I think parseTime in time behaved differently, ie. it would parse hh:mm with "%H:%M" as a clock time _today_. Or maybe I'm misremembering.
06:31:24 <ongy> what's the current state of haskell (ghc) on arm? 
06:31:30 <c_wraith> joe9: the basic approach is to put a serialize function into the record that writes it to a serializable formate. Then you write a bunch of deserialize functions that look for specific serialized forms or fail.  Then you compose the deserialization functions to get extensibility.
06:31:40 <c_wraith> *format
06:31:41 <srhb> ongy: There's a docker image that seems to be cargo culted around a lot. :-)
06:34:11 <srhb> Hackage should have an "index of all functions related to this type in this package" view
06:34:30 <maerwald> what does "related to this type" mean
06:34:32 <c_wraith> Oh, thyme uses the vector-space interfaces.  Nice.
06:34:54 <srhb> maerwald: "has it in its signature"
06:34:57 <c_wraith> The vector-space classes are incredibly underused, given how widely applicable they are.
06:35:19 <srhb> c_wraith: Yes, I can't decide whether it's over-engineered (in the cool way) or just cool. :-P
06:36:06 <unit73e> thanks c_wraith
06:36:44 <c_wraith> Well, given that time is exactly an affine space, using classes designed to represent affine spaces for operations on structures representing times is a good idea. :)
06:41:12 <srhb> c_wraith: I was mostly kidding, and yes :-)
06:43:38 <infandum> Is there an easy way to derive Functor for a simple newtype wrapper "newtype Test = Test { unTest :: Int }", for instance? I can easily make an instance for it, but I wondered what the way to do it with generic programming is.
06:45:12 <lyxia> Test can't be a functor
06:45:23 <lyxia> It has kind *
06:45:36 <srhb> infandum: You can do it for Test a = Test { unTest :: a } though. simply deriving Functor
06:46:00 <infandum> Whoops, that makes sense.
06:46:38 <infandum> But the idea is for using the type system to prevent stupid mistakes with similar types, I don't want test to be anything other than Int. Is there another way to do this without using fmap then?
06:47:08 <jchia_> c_wraith, lyxia: I've updated the code to use guards. Any more suggestions? http://lpaste.net/176209
06:47:25 <lyxia> infandum: you wouldn't use Functor if the contained value must have a fixed type
06:47:29 <infandum> I might just have to write Test . f x . unTest instead of some other thing
06:47:32 <dramforever> infandum: What do you want to achieve?
06:47:37 <infandum> yeah I just realized that
06:47:42 <Welkin> infandum: Functor is only for Functors
06:47:43 <Welkin> :D
06:47:45 <infandum> haha
06:48:04 <Welkin> you can just use a newtype and that's all
06:48:10 <dramforever> Well you *are* required to do the (un)wrapping because they override your attempt to prevent stupid mistakes
06:48:48 <infandum> dramforever: I guess...maybe I'm too confident with those kinds of boilerplate
06:49:09 <c_wraith> jchia_: nothing stands out to me
06:49:26 <lyxia> jchia_: +1
06:50:01 <jchia_> if i am dealing with an Either instead of a Maybe, guard wouldn't let me specify the Left, right? In that case, what's a good alternative to guard?
06:50:36 <Welkin> jchia_: why are you using mondaic guards?
06:50:40 <Welkin> o.o
06:50:49 <Welkin> monadic*
06:50:52 <Zemyla> jchia_: maybe (Left x) Right . guard
06:50:53 <c_wraith> jchia_: the errors package has handy functions for that sort of thing
06:50:54 <jchia_> in fact i think Either is not an Alternative, so no guard
06:50:58 <c_wraith> I think it's named errors
06:51:19 <jchia_> Welkin: I didn't like the many levels of if else in the original code
06:51:52 <dramforever> > Left "err" | Right 'c'
06:51:53 <lambdabot>  <hint>:1:12: parse error on input ‘|’
06:51:56 <dramforever> > Left "err" <|> Right 'c'
06:51:58 <lambdabot>  Right 'c'
06:52:14 <dramforever> > guard False -- Let's see
06:52:16 <lambdabot>      No instance for (Show (f0 ()))
06:52:16 <lambdabot>        arising from a use of ‘show_M51836860977224600825028’
06:52:16 <lambdabot>      The type variable ‘f0’ is ambiguous
06:52:28 <Zemyla> :t \x y -> Left x <|> Right y
06:52:30 <lambdabot> Control.Monad.Trans.Error.Error a1 => a1 -> a -> Either a1 a
06:52:41 <Welkin> jchia_: I meant why not just use case expressions
06:53:01 <dramforever> Control.Monad.Trans.Error looks like a big red sign
06:54:23 <jchia_> Welkin: I suppose I'm not very good with case. I only know how to do:
06:54:23 <jchia_> case x of
06:54:23 <jchia_>   value1 ->
06:54:23 <jchia_>   value2 ->
06:54:23 <jchia_>   ...
06:54:38 <jchia_> Welkin: How could I use case for this?
06:54:46 <linduxed> so i've got this line
06:54:48 <linduxed> data Coordinate = Coordinate { x :: Int, y :: Int }
06:54:51 <Welkin> jchia_: just like that
06:55:04 <Welkin> you can throw a let or a where in there too
06:55:05 <linduxed> what code would be necessary to make Coordinate an instance of Ix?
06:55:08 <linduxed> https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Ix.html#t:Ix
06:55:18 <maerwald> using case there doesn't give you anything, except switching verbose syntax for verbose syntax
06:55:46 <Welkin> maerwald: I think it's more clear
06:55:51 <linduxed> is it just a one line implementation or something to that effect?
06:55:53 <maerwald> that's just personal style preference
06:55:56 <maerwald> and not really relevant imo
06:56:01 <jchia_> Welkin: So, like this? if compareLength .. then case rightToMaybe $ decimal t of ...?
06:56:08 <dramforever> linduxed: See the "Minimal complete definition" part? That means you would need to implement range, inRange, as well as one of index and unsafeIndex
06:56:33 <Welkin> jchia_: yeah, there are many ways to write it
06:56:40 <linduxed> dramforever: oh, ok...
06:56:48 <c_wraith> Welkin: I don't understand your advice.  It would lead to deeply nested cases, and therefore right back to the original problem.
06:56:54 <linduxed> dramforever: i'll think about how to do that then!
06:56:54 <jchia_> Welkin: but if i use case, i would incur some nesting, right?
06:57:07 <dramforever> linduxed: 2D array indices are so confusing, what should I do? Well, I could just call those functions defined on pairs instead!
06:57:16 <maerwald> jchia_: using case here doesn't make the code more concise, it's just personal style preference
06:57:49 <dramforever> Like range (Coordinate x1 y1, Coordinate x2 y2) = range ( (x1, y1), (x2, y2) ), if that's what you mean
06:58:53 <linduxed> dramforever: i just meant that i'll just have to write those functions, i guess
07:00:08 <dramforever> yep, and I just meant that there's a guaranteed working way to write them :)
07:03:32 <linduxed> ok, thx!
07:05:59 <jchia_> Zemyla: It took me a while to parse the "maybe (Left x) Right . guard" you gave me. I'm relatively new to Haskell. Is this something that someone could recognize quickly with some months or years of Haskell experience, or just a common idiom to some Haskellers?
07:06:34 <sm> jchia: it gets easy with a bit more exposure
07:07:26 <maerwald> jchia_: there are thousands of ways to write stuff, the only thing you get used to is how to read certain "sequences" (e.g. monadic expressions, function composition etc). But people write stuff in so many different ways that you often have to look closer at the types to know what's happening
07:07:47 <Welkin> writing a pipeline of composed functions is natural in haskell
07:07:50 <Welkin> and usually easy to read
07:07:56 <Welkin> unless it is a pointfree mess
07:08:08 <jchia_> I don't remember the argument order of certain common functions like maybe, either and Data.HashMap lookup. I spend much time lookup up haddocks. Am I right that to be productive, I just gotta remember what certain functions mean?
07:08:09 <mniip> typechecking it though
07:08:21 <Welkin> jchia_: you will get used to it
07:08:27 <Welkin> I reference docs a ton while writing
07:08:42 <maerwald> this part of the zen of python does not apply to haskell: "There should be one-- and preferably only one --obvious way to do it."
07:08:44 <mniip> yeah took me a while to read that actually
07:08:47 <Welkin> maybe <default if Nothing> <function to apply to value if Just> <value>
07:08:54 <sm> yes, you'll be much more productive once you've internalised more common things
07:09:02 <Welkin> then there is fromMaybe which is slightly different
07:09:12 <Welkin> it takes two functions
07:09:35 <Welkin> haskell is more like perl :D
07:09:48 <Welkin> there are a million ways to do it, not all of them are good ways, and some are better than others
07:10:08 <maerwald> jchia_: also, I wouldn't bother so much about "I want the perfect function/way to express this thing". I find that to be a common fallacy where you switch stuff around without really changing semantics. Those things come with time anyway.
07:10:22 <daniel_w> python is more like perl than python in that respect too
07:10:31 <Welkin> jchia_: being clear is better than being concise or trying to do something fancy
07:10:59 <Welkin> some pople go crazy with pointfree and end up with things like this
07:11:18 <jchia_> I want to be productive and write maintainable code. I spend a lot of time juggling types in my head when reading and writing Haskell. That juggling gets interrupted when I have to lookup the functions on Haddock.
07:11:30 <sm> jchia_: hopefully you have an efficient haddock lookup process, eg a browser shortcut for hoogle
07:11:30 <Welkin> @pl (\x y z -> f x y (g y z))
07:11:30 <lambdabot> (`ap` g) . ((.) .) . f
07:11:53 <Welkin> jchia_: write down your types, always
07:12:03 <Welkin> write the types, then write the code
07:12:07 <Welkin> there should be no juggling
07:12:15 <Welkin> if you find yourself doing that, break it down into smaller functions
07:12:16 <absence> is there a naive frp library (for learning) that uses behaviour a = time -> a and event a = [(time, a)]?
07:12:24 <maerwald> jchia_: if you want to be productive, stop asking yourself "is there already a function for that?". Instead, just write your own pseudo-prelude and when the project has a certain size, try to remove that custom prelude, which will force you to dig into libraries.
07:12:26 <dramforever> Also try holes
07:12:42 <maerwald> it's also a good exercise
07:12:48 <Welkin> absence: reflex?
07:12:58 <linduxed> dramforever: so these two lines don't seem to work (if you assume semi-colon line breaking was allowed):
07:13:01 <linduxed> dramforever: instance Ix Coordinate where; range (Coordinate x1 y1, Coordinate x2 y2) = range ((x1, y1), (x2, y2))
07:13:06 <jchia_> i find myself writing rather long verbose code that i wonder whether i could shorten using some nifty haskell device
07:13:07 <maerwald> otherwise, you get sidetracked too much
07:13:40 <linduxed> dramforever: couldn't match expected type Coordinate with actual type '(Int, Int)'
07:13:40 <dramforever> @let data Coordinate = Coordinate { x :: Int, y :: Int }
07:13:40 <jchia_> before today, i used to have a lot of nested if-else. now, maybe i'll start using guards more
07:13:41 <lambdabot>  Defined.
07:14:05 <dramforever> linduxed: Oh stupid me, you would need to convert them back
07:14:12 <Welkin> jchia_: yes, break it down into a pipeline of small functions you compose together
07:14:13 <dramforever> map with (uncurry Coordinate)
07:14:25 <sm> jchia_: pretty soon you'll be seeing how to squash your old code without effort
07:14:34 <dramforever> @let instance Ix Coordinate where range (Coordinate x1 y1, Coordinate x2 y2) = uncurry Coordinate <$> range ((x1, y1), (x2, y2))
07:14:36 <lambdabot>  .L.hs:158:10:
07:14:36 <lambdabot>      No instance for (Ord Coordinate)
07:14:36 <lambdabot>        arising from the superclasses of an instance declaration
07:14:52 <Welkin> jchia_: you mean | guards? or Control.Monad.guard, because the first is what we typically call a guard
07:14:56 <dramforever> :t \ (Coordinate x1 y1, Coordinate x2 y2) -> uncurry Coordinate <$> range ((x1, y1), (x2, y2))
07:14:58 <lambdabot> (Coordinate, Coordinate) -> [Coordinate]
07:15:03 <jchia_> i mean Control.Monad.guard
07:15:08 <dramforever> linduxed: ^
07:15:15 <Welkin> I've never used Control.Monad.guard
07:15:22 <Welkin> also, you can only use that with a monad
07:15:35 <Welkin> jchia_: have you gone through the UPenn course?
07:15:36 <linduxed> dramforever: oh shit, that's... mappend?
07:15:41 <Welkin> @where learnhaskell -- jchia_ 
07:15:41 <lambdabot> https://github.com/bitemyapp/learnhaskell
07:15:44 <linduxed> dramforever: or am i confused now?
07:15:46 <linduxed> i'm confused
07:15:49 <linduxed> yes
07:15:56 <jchia_> I often want 'early-exit' in a Maybe or Either monad, so I'll use guard
07:16:06 <jchia_> i used to have a lot of nested if-else
07:16:13 <absence> Welkin: reflex seems a lot more complicated than a naive implementation
07:16:28 <dramforever> :t \ (Coordinate x1 y1, Coordinate x2 y2) -> map (\(x, y) -> Coordinate x y) range ((x1, y1), (x2, y2)) -- linduxed 
07:16:29 <lambdabot>     Couldn't match expected type ‘((Int, Int), (Int, Int)) -> r’
07:16:30 <lambdabot>                 with actual type ‘[Coordinate]’
07:16:30 <lambdabot>     The function ‘map’ is applied to three arguments,
07:16:34 <dramforever> Arrgh
07:16:39 <Welkin> jchia_: if-else is rarely used, instead we use pattern matching with case expressions (or the top-level pattern matching)
07:16:57 <absence> Welkin: i mean, class (MonadHold t (PushM t), MonadSample t (PullM t), MonadFix (PushM t), Functor (Event t), Functor (Behavior t)) => Reflex t 
07:17:10 <dramforever> :t \ (Coordinate x1 y1, Coordinate x2 y2) -> map (\(x, y) -> Coordinate x y) (range ((x1, y1), (x2, y2))) -- linduxed do you understand this?
07:17:11 <lambdabot> (Coordinate, Coordinate) -> [Coordinate]
07:17:17 <Welkin> absence: well, frp is not simple
07:17:20 <jchia_> Welkin: if failure can be due to multiple things, case won't be useful
07:17:21 <Welkin> you could try netwire 5
07:17:32 <dramforever> I unpack into coords, use range on pairs, and pack back into coord
07:17:33 <linduxed> dramforever: yes
07:17:39 <dramforever> That's it
07:17:43 <dramforever> range
07:17:46 <jchia_> Welkin: I don't know about the UPenn course
07:17:58 <linduxed> dramforever: i mostly reacted to the use of <$>
07:17:58 <absence> Welkin: netwire uses arrows
07:18:01 <Welkin> jchia_: it's in the link
07:18:28 <Welkin> absence: it's pretty easy to use for learning frp, don't worry about the arrows
07:18:33 <jchia_> OK
07:18:37 <Welkin> there is also reactive banana
07:18:45 <maerwald> jchia_: instead of asking yourself how you can _avoid_ those if-then-else, you should have asked yourself how you can _abstract_ over them yourself
07:18:50 <maerwald> maybe do that, write those functions
07:18:51 <Welkin> absence: https://github.com/gelisam/frp-zoo
07:21:09 <absence> Welkin: i already know frp, i want to learn the semantics for implementing something frp-like myself. as far as i understand, the basic semantics are that behaviours are functions from time to some value, and events are values at certain points in time, but no "real-world" implementation does exactly that because of space leaks and other inefficiencies
07:21:56 <absence> Welkin: but a naive toy implementation that does would be useful to study
07:27:35 <Eduard_Munteanu> Is vcache still developed? Any other alternatives worth looking at?
07:29:15 <nitrix> Eduard_Munteanu: I'm working on something similar but gamedev-oriented, with loading and unloading resources (entities, assets, etc) that have relations between them.
07:30:01 <lingxiao> hey all
07:30:21 <lingxiao> I am trying to make a monad transformer for doing operations on file path
07:30:53 <maerwald> on file path or files?
07:31:05 <lingxiao> sorry files ...
07:31:15 <lingxiao> so one example would be      f <- openFile filePath
07:31:31 <lingxiao> this openFile is an example of the monad, if the filePath is valid then the coputation goes on
07:31:43 <lingxiao> if not it should fail with a message ..
07:31:59 <lingxiao> so Im thinking this Monad is an instance of IO, Either, and I'd also like it to be an instance of State
07:32:10 <lingxiao> and maybe conduit  if im ambitious
07:32:20 <nitrix> Eduard_Munteanu: You're also arbitrarily stitch relational things together in a pure way. Resolving a relation or modifying something related to someting else happens in IO though.
07:32:29 <lingxiao> but i'm having trouble definiing this monad
07:32:36 <nitrix> You can also*
07:32:48 <lingxiao> so I'm thinking like:  data FileOp a = Monad m => F { access :: FilePath -> m a } 
07:32:49 <daniel_w> lingxiao: I'd recommend looking into operational: https://hackage.haskell.org/package/operational-0.2.3.2/docs/Control-Monad-Operational.html
07:33:26 <lingxiao> daniel_w looking at i now .. but not quit sure how it's relevlant?
07:33:35 <lingxiao> so my FileOp is inccorrect syntax wise ..
07:33:36 <Eduard_Munteanu> lingxiao, note IO can't be made into a transformer
07:34:04 <dramforever> lingxiao: It's easier to define operations that way
07:34:10 <lingxiao> Eduard_Munteanu oh ok that's fine then ... just state, either and  conduit would be nice
07:34:17 <daniel_w> lingxiao: it allows you to define monad transformers by specifying the operations as a GADT
07:34:26 <lingxiao> dramforever so you're syaig I should use operational rather than roll my own monad
07:34:26 <Eduard_Munteanu> nitrix, I'd use acid-state and ixset but those imply keeping everything in memory
07:34:40 <maerwald> lingxiao: what does 'openFile' actually do? IO or just validating a filepath?
07:34:41 <lingxiao> daniel_w sorry could you give me an example?
07:35:08 <dramforever> lingxiao: if you do find managing the operations hard
07:35:13 <lingxiao> maerwald   openFile should be like    openFile p = validate p >> openTheActualFile p
07:35:26 <maerwald> so you have two levels of exceptions
07:35:36 <maerwald> you should pull the validation to type-level and have it checked at compile-time
07:35:40 <lingxiao> but validate could fail with Left (InValidPathError p)
07:35:40 <nitrix> Eduard_Munteanu: ixset has O(log n) lookups and editions. Mine's O(1) :)
07:35:41 <linduxed> dramforever: omg
07:35:42 <maerwald> @hackage path
07:35:42 <lambdabot> http://hackage.haskell.org/package/path
07:35:45 <maerwald> see that
07:35:58 <linduxed> dramforever: i just realized that i can just do "deriving (Eq, Ord, Ix)
07:36:00 <linduxed> "
07:36:02 <linduxed> thing just works
07:36:06 <linduxed> wonderful
07:36:17 <dramforever> Wow
07:36:22 <daniel_w> lingxiao: the docs are quite good: https://hackage.haskell.org/package/operational-0.2.3.2/docs/Control-Monad-Operational.html#v:viewT
07:36:34 <linduxed> dramforever: for Coordinate, that is
07:36:35 <dramforever> Wow wow wow (insert 17 more "wow"s here)
07:36:37 <daniel_w> The PlusI is defining an instruction
07:36:54 <lingxiao> ok so there's two things going on here ... monad operational and this path library i see
07:37:02 <linduxed> dramforever: so "data Coordinate = Coordinate { x :: Int, y :: Int } deriving (Eq, Ord, Ix)
07:37:16 <dramforever> Yeah I see what you mean
07:37:18 <lingxiao> i assume they can work togethr?
07:38:26 <daniel_w> they could do. The path library is just makes invalid paths unrepresentable
07:39:01 <lingxiao> ok great .. so im looking at this operational link you sent me but I cant quit make sense of it?
07:40:06 <mniip> Eduard_Munteanu, well actually
07:40:11 <hackrilege> great news my thing works good!! check it out its nuts and fun! http://lpaste.net/176234
07:40:44 <hackrilege> im sure its some kind of idiom id love to lean more about
07:40:48 <mniip> hmm, I should use some bits of acme-timemachine to write an IO transformer
07:40:56 <mniip> acme-iot :p
07:41:08 <Eduard_Munteanu> mniip, hm?
07:41:21 <maerwald> lingxiao: also, you should make sure you don't throw away the low-level exceptions from the libc calls and _don't_ convert it. They should be preserved. file operations are by nature low-level and you want the information those low-level calls throw back at you
07:41:31 <hackrilege> as always anyone that would take a look over and give me the briefest of hints would be much appriciated
07:41:41 <lingxiao> maerwald ok so you're saying dont wrap it in either?
07:41:51 <maerwald> I personally would not
07:41:51 <lingxiao> or if i do wrap it, make sure the message gets through?
07:42:01 <lingxiao> I guess i was just taught to write total functions
07:42:05 <maerwald> lingxiao: there are ways of converting exceptions to either anyway, if someone wants that
07:42:07 <lingxiao> and thwroing an error is kind of like not total
07:42:24 <Welkin> kind of like not?
07:42:27 <Welkin> you mean it's not
07:42:28 <hackrilege> quite specifically id love to know whats happening on line 150. http://lpaste.net/176234
07:42:41 <maerwald> also, with file operations I feel it can be better that the program crashes with an unhandled exceptions instead of going some weird monadic either-callstack
07:43:00 <lingxiao> maerwald this is what I'm doing right now: http://lpaste.net/176236
07:43:04 <lingxiao> so yeah im throwing it away
07:43:12 <maerwald> if you don't know how to handle a failure, just let it crash the program. That's what I consider safe when it's about file IO.
07:43:30 <mniip> oh wait
07:43:33 <lingxiao> in my instance Im folding over a list of files ina  directory and concactenating them
07:43:35 <maerwald> sure, there are use cases where your program should never crash, but that's a diufferent topic
07:43:42 <mniip> @unmtl StateT s m a
07:43:42 <lambdabot> s -> m (a, s)
07:43:43 <lingxiao> so if some path is not valid I just skip over it
07:43:50 <mniip> hmm, that complicates it a bit
07:44:21 <maerwald> lingxiao: btw, I've writte a hpath package which is a fork of path which also includes high-level file operations like recursive copy
07:44:31 <maerwald> not sure if that can be useful to you
07:44:33 <lingxiao> can i see i please?
07:44:42 <maerwald> @hackage hpath
07:44:42 <lambdabot> http://hackage.haskell.org/package/hpath
07:44:54 <lingxiao> is there an example of sane and clean code that does path stuff ?
07:44:59 <maerwald> mind that it uses real filepaths (as in ByteString), not fake String
07:45:17 <maerwald> String is a wrong type for filepaths, still widely used
07:45:40 <lingxiao> why is it wrong?
07:45:47 <lingxiao> whats the advantage of bytestrings ?
07:45:48 <daniel_w> it's just a list of characters
07:45:53 <maerwald> because what you get back from the libc calls are just bytes
07:45:53 <Gurkenglas> Whats the problem with using String for filepaths? Isn't the only problem with String performance?
07:46:05 <maerwald> not interpreted characters
07:46:23 <maerwald> there are a lot of encoding issues with String you have to work around then
07:46:31 <daniel_w> also filepaths aren't necessarily human readable
07:46:36 <maerwald> exactly
07:46:42 <maerwald> also see https://ghc.haskell.org/trac/ghc/wiki/Proposal/AbstractFilePath
07:46:55 <maerwald> doubt we will ever get that though
07:47:46 <maerwald> lingxiao: if you are doing more complicated file operations, you might need your own exception type on top of it, but should still leave the libc/posix failures untouched
07:47:50 <Eduard_Munteanu> Unfortunately, the POSIX filepaths are kinda stupid too. They really shouldn't have defined anything but a readable representation of paths. '/' and such should have been out of band.
07:48:21 <maerwald> Eduard_Munteanu: heh, yeah... my favorite question is "what's the filename of '/'?"
07:48:42 * hackagebot hspec-golden-aeson 0.1.0.0 - Use tests to monitor changes in Aeson serialization  https://hackage.haskell.org/package/hspec-golden-aeson-0.1.0.0 (mchaver)
07:48:51 <lingxiao> ok so suppose for self edification purposes ..
07:48:52 <Eduard_Munteanu> maerwald, or of NUL :(
07:49:03 <lingxiao> I wwant to roll my own monad transformer for what im doing
07:49:24 <lingxiao> and I want to define a primitive operation:   monad m => FilePath -> m a
07:49:31 <lingxiao> How would I even state this so that it parses?
07:49:47 <lingxiao> and just to get started, how would I define a MonadIO instance for this computation ?
07:49:58 <mniip> what computation
07:50:03 <lingxiao> my monad
07:50:16 <mniip> does your monad completely embed all IO operations?
07:50:43 <lingxiao> so really this is the monad I want:     FileOp a := MonadEither m, MonadIO m, MonadState m => FilePath -> m a
07:50:49 <lingxiao> mniip sorry what does embed mean?
07:50:53 <daniel_w> lingxiao: what's the a?
07:51:00 <lingxiao> a is output type
07:51:06 <lingxiao> daniel_w some generic a
07:51:19 <lingxiao> and i guess suppose I want to use the path library
07:51:23 <daniel_w> so, like serializabe things?
07:51:32 <Gurkenglas> Can you choose a to be Void (Void has no value)
07:51:44 <lingxiao> right now no restrictions
07:51:54 <lingxiao> but Im fine with putting any restrictions on it to make things easier
07:52:04 <lingxiao> rigth now my a is like [String]
07:52:12 <lingxiao> or gigantic list of ByteString
07:52:47 <daniel_w> ok, but some representation of the contents of the file?
07:52:59 <lingxiao> yeah
07:53:22 <Eduard_Munteanu> readFromFile :: (Read a, MonadIO m) => FilePath -> m a
07:53:37 <mniip> newtype FileOp = FileOp (ReaderT FilePath (EitherT E (StateT S IO)) a) deriving (Functor, Applicative, Monad, MonadReader FilePath, MonadEither E, MonadState S, MonadIO)
07:53:58 <lingxiao> this is my usecase: http://lpaste.net/176240
07:54:03 <umib0zu> Hey is anyone going to the Haq Phi in October?
07:54:20 <lingxiao> please note im hadnling gigantic things so this FoldOverItAndDoStuff should be lazy
07:54:32 <lingxiao> actually there's some operational sematncis stuff I need to enforce and I'm not sure how
07:55:01 <daniel_w> lingxiao: http://lpaste.net/176242
07:55:10 <maerwald> this reminds me of how ugly monad transformers are
07:55:13 <Eduard_Munteanu> Or something like   type MonadFileOp m = (MonadReader FilePath m, MonadState S m, MonadIO m)    with -XConstraintKinds
07:55:18 <daniel_w> I haven't compiled it, so there may be typos
07:55:30 <daniel_w> but that's roughly what operational looks like
07:55:39 <lingxiao> maerwald yea to be honest I would like to not roll my own transformer if I can
07:55:48 <Welkin> umib0zu: what's that?
07:55:50 <lingxiao> but for the sake of learning I'd like to know how it Could be expressed
07:56:16 <umib0zu> A hackathon at uPenn in Philly October 21st
07:56:23 <lingxiao> umib0zu im at penn so i'll drop by
07:56:46 <umib0zu> lingxiao https://www.reddit.com/r/haskell/comments/4x2u53/hac_%CF%86_a_haskell_exchange_in_philadelphia_oct_2123/
07:58:17 <lingxiao> daniel_w  sorry Im still not clear on what moand.operational does
07:58:36 <lingxiao> im reading the docs but im in like GO GO GO mode so it's not really sinking in
07:58:40 <lingxiao> could you give me a gist?
07:59:34 <lingxiao> Eduard_Munteanu sorry what is that thing you just wrote?
07:59:48 <lingxiao> it's a tuple ?
07:59:52 <lingxiao> how does it even work?
08:00:13 <lingxiao> umib0zu sweet  if youve never been its pretty chill
08:00:35 <lingxiao> Penn is big on PL so the grad students are there just talking through problems and hanging out and stuff
08:00:40 <umib0zu> lingxiao haha I grew up across the river from Philly actually
08:01:07 <umib0zu> super stoked… but I have no project except for a webserver I wanted to make for a buddy of mine
08:01:44 <lingxiao> yeah people dont really come in with projects
08:02:02 <sm> lingxiao: lol
08:02:04 <lingxiao> so theres no pressure
08:02:04 <AppleJacks24> I'
08:02:04 <Welkin> they only come *from* the projects
08:02:08 <lingxiao> sm huh?
08:02:18 <sm> GO GO GO how can you even read this :)
08:02:26 <AppleJacks24> I'm just geeting my feet wet in haskell, would it be a good place for a beginer?
08:02:44 <lingxiao> yeah first time i went i was very green
08:02:52 <lingxiao> peole are very open to otusiders
08:02:55 <Welkin> any hackathons are good for beginners
08:03:09 <lingxiao> and its liek a hackathon where eccentric people still go
08:03:19 <lingxiao> where as mahy hackathons are professionalized now
08:03:30 <lingxiao> so its like recuriting session in disguise
08:03:46 <Welkin> most people don't actually compete
08:03:49 <lingxiao> and you get a lot of brogrammers
08:03:51 <Welkin> they just go to have fun and meet people
08:03:51 <umib0zu> lingxiao or just a blatent attempt to steal code
08:04:01 <lingxiao> oh haha : |
08:04:14 <AppleJacks24> I saw somewhere that they may be giving talks on Saturday too?
08:04:15 <Welkin> no, I would never go to a corporate hackathon
08:04:18 <umib0zu> I actually don’t mind a fun weekend with other coders. (I’m a brogrammer)
08:04:21 <Welkin> I only went to university ones run by the students
08:04:21 <lingxiao> yeah thers one table where people code
08:04:22 <JuanDaugherty> it's an alien concept to me
08:04:29 <lingxiao> every other table people just have their editor open but do nothing 
08:04:41 <lingxiao> theres a range of people htere
08:04:49 <Welkin> I never built anything
08:04:53 <Welkin> I just learned new things and had fun
08:04:57 <Welkin> and got free food
08:05:12 <JuanDaugherty> needs new society context to not suck I think
08:05:59 <Welkin> I remember seeing a lot of people who had never programmed before
08:06:04 <Welkin> they had a finished project at the end
08:06:07 <Welkin> a game or an app
08:06:19 <Welkin> that happened at the hackathon I ran at my uni too
08:06:34 <JuanDaugherty> yeah one reason it would be awkward for me, since I wrote first program c. 1974
08:07:21 <daniel_w> lingxiao: http://lpaste.net/176242
08:07:46 <lingxiao> daniel_w sweet!
08:07:53 <lingxiao> thats exactly the kind of stuff i look for in this channel
08:07:56 <lingxiao> thanks!
08:08:06 <maerwald> that looks like a boring version of freer :P
08:08:22 <lingxiao> maerwald sorry are you referring to daniel_w's code?
08:08:24 <lingxiao> whats freeer
08:08:33 <maerwald> an alternative to mtl
08:08:43 * hackagebot snaplet-scoped-session 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/snaplet-scoped-session-0.1.0.0 (justus)
08:08:44 <maerwald> which looks slightly similar to his code
08:09:07 <maerwald> @hackage freer
08:09:07 <lambdabot> http://hackage.haskell.org/package/freer
08:09:23 <lingxiao> maerwald i keep on hearing about mtl
08:09:26 <lingxiao> does it suit my use case?
08:09:34 <daniel_w> boring is often a feature
08:09:39 <lingxiao> really I just want to write clean code using a library that's user friendly
08:10:00 <maerwald> mtl is just a class wrapper around monad transformers
08:10:26 <lingxiao> ok so like make them usable?
08:10:33 <lingxiao> i used to think monad transforers are so cool
08:10:49 <lingxiao> now i think it's like the worlds most beautfil ghetto
08:11:09 <daniel_w> The novelty wears off
08:11:25 <lingxiao> yeah it slike this: http://stophavingaboringlife.com/images/dailyphoto/100/guangzhou_china_ghetto_apartment_low_income.JPG
08:11:43 <daniel_w> oh, good illustration
08:11:48 <maerwald> that's the best picture describing monad transformers I've seen so far
08:11:52 <lingxiao> oh its by kmett ok makese sense
08:11:56 <lingxiao> haha thanks guys
08:12:51 <nshepperd> the kowloon walled city of programming
08:13:08 <dolio> mtl was not written by edwardk, he just maintains it now.
08:13:19 <dolio> It's from way before he even started using Haskell.
08:13:31 <daniel_w> nshepperd: I think that title is held by npm
08:13:36 <lingxiao> oh ops soryr
08:13:56 <lingxiao> yeah it says andy gill  ops
08:14:50 <dolio> It used to be one big package with all the transformers and classes, but it got split up to build on another package at some point.
08:15:31 <Eduard_Munteanu> lingxiao, that was a constraint
08:15:46 <Eduard_Munteanu> Like all stuff to the left of =>
08:15:52 <dolio> Also, it's effectively an implementation of an effect system, much like the ones that are popular today, except apparently no one who's into effect systems actually realizes it.
08:16:26 <lingxiao> dolio are you referring to mtl?
08:16:30 <lingxiao> what do you mean effect system?
08:16:30 <dolio> Yes.
08:16:30 <nshepperd> I actually like mtl just fine
08:16:36 <maerwald> describing effects without a lot of random lifting and clumsy newtype hacks is one of the main weaknesses of practical haskell imo. freer is promising, but it has some problems and limitations too
08:16:44 <lingxiao> Eduard_Munteanu so this: type MonadFileOp m = (MonadReader FilePath m, MonadState S m, MonadIO m)
08:16:54 <Eduard_Munteanu> Yes.
08:17:04 <lingxiao> is just saying suppose we have MonadFileOp m, where m is a reader state and Io
08:17:21 <lingxiao> and that means we can interact with this monad using reader io and state operations ?
08:17:28 <Eduard_Munteanu> It is equivalent to typing those constraints by yourself all the time.
08:17:33 <Eduard_Munteanu> Yes.
08:17:58 <lingxiao> so i can write:   foo :: String -> MonadFileOp m  ?
08:18:09 <lingxiao> its funny because constraints usually appear right after the ::
08:18:21 <daniel_w> foo :: MonadFileOp m => String -> ...
08:18:22 <lingxiao> but here it's saying:   string -> (MonadReader FilePath m, MonadState S m, MonadIO m)
08:18:30 <lingxiao> oh i see
08:18:37 <Eduard_Munteanu> lingxiao, foo :: MonadFileOp m => String -> m Something 
08:18:37 <lingxiao> so ok its just like a synoym
08:18:47 <Eduard_Munteanu> It's a constraint synonym.
08:18:52 <lingxiao> ok fascinating .... 
08:18:55 <lingxiao> thats really simple
08:19:01 <lingxiao> how do i run it?
08:19:10 <lingxiao> and how does it relate to this: newtype FileOp = FileOp (ReaderT FilePath (EitherT E (StateT S IO)) a) 
08:19:14 <Eduard_Munteanu> {-# LANGUAGE ConstraintKinds #-}
08:20:07 <Eduard_Munteanu> You no longer have to create a monad per se, just a runner function runFileOp = runReaderT . runEitherT ...
08:21:31 <lingxiao> Eduard_Munteanu ok perfect that's what i was looking for
08:22:22 <lingxiao> it's amazing i think i finally cross the threshold from wow every in haskell is cool to ... get stuff done
08:23:16 <daniel_w> time to learn idris then
08:28:43 * hackagebot glirc 2.8 - Console IRC client  https://hackage.haskell.org/package/glirc-2.8 (EricMertens)
08:28:51 <lingxiao> harhar
08:28:58 <lingxiao> i took a proof class in coq
08:29:04 <lingxiao> it was nice
08:29:38 <lingxiao> funny i remember a couple of years ago i asked kmett about dependent types and he says they're really not needed most of the time
08:29:43 <lingxiao> dont know what his opinion is now
08:31:14 <daniel_w> There's definitely an art to putting the right amount of information in the type.
08:31:56 <lingxiao> yeah am not a proficient pactioner of that art 
08:37:20 <nitrix> Does Haskell has other form of polymorphisms other than paremetric (type variables) and ad-hoc (type classes) ?
08:38:28 <nitrix> Does TH classifies as polymorphism?
08:38:40 <Welkin> that's meta programming
08:39:34 <quchen> Parametric and ad-hoc is all Haskell has.
08:40:02 <nitrix> quchen: Welkin Appreciated, thanks.
08:41:12 <daniel_w> How would you categorize implicit parameters, not that I'd advocate using them?
08:41:36 <saurabhnanda> anyone knows how to get classy-lenses with overloaded field names? http://stackoverflow.com/questions/38914782/how-to-get-classy-lenses-with-overloaded-field-names
08:44:07 <dmwit> daniel_w: Unpopular, but not because there's a technical reason to think they are dangerous or introduce technical debt or anything like that.
08:45:32 <Welkin> daniel_w: you mean using a record as the parameter where you only change what you want to provide and everything else has a default?
08:46:06 <dmwit> I assumed he meant the ImplicitParameters extension.
08:46:11 <daniel_w> I mean, what kind of polymorphism do implicit parameters provide
08:46:22 <daniel_w> Is there a name?
08:47:00 <dmwit> I think it's implemented in essentially the same way type classes are.
08:47:16 <Welkin> a dictionary of values passed around?
08:47:24 <dmwit> So if you wanted to name it, I guess I'd probably say it was just another kind of ad-hoc polymorphism.
08:47:40 <dmwit> Welkin: I think it's not even a dictionary. Just a value.
08:47:44 <dolio> Is taking an extra argument to a function polymorphism?
08:47:56 <dolio> If so, what kind?
08:48:47 <maerwald> you mean optionally taking an extra argument?
08:49:16 <dolio> No, just adding one, which maybe gives you a way of selecting more of what the function does.
08:49:45 <maerwald> sounds like object oriented programming, where the extra argument is hidden by a lot of sugar?
08:50:27 <daniel_w> It's typed dynamic scoping
08:50:42 <dolio> Like, is `reverseOnto = foldl (flip (:))` more "polymorphic" than `reverse = foldl (flip (:)) []`
08:52:36 <dolio> Is foldl more polymorphic than both?
08:52:45 <Gurkenglas> Why doesn't https://docs.haskellstack.org/en/stable/GUIDE/#travis-with-caching test the build on windows too >:o
08:52:53 <dmwit> is id the most polymorphic of them all?
08:53:18 <daniel_w> does more polymorphic form a quasi well-ordering
08:53:29 <glguy> foldl might be "more polymorphic than the first two, it can take a superset of the types the first two can
08:53:50 <glguy> modulo the extra arguments...
08:54:05 <glguy> so they aren't directly comparable.. it looks like I need to read some chat history
08:54:41 <dolio> That's not what the question meant.
08:56:26 <dolio> Anyhow, my real question is: what's the point of trying to come up with ways of describing various language features as, 'foo polymorphism'?
08:58:27 <parsnipM_> dolio: point is that when something can be applied to more than one situation, that is good? 
08:58:33 <roberth> i think 'generic' might be an appropriate term, instead of polymorphic
08:58:44 * hackagebot hspec-snap 1.0.0.0 - A library for testing with Hspec and the Snap Web Framework  https://hackage.haskell.org/package/hspec-snap-1.0.0.0 (DanielPatterson)
08:58:52 <dolio> Generic is even more overloaded than 'polymorphism'. :)
08:59:09 <roberth> exactly
09:00:07 <roberth> that seemse to be the right amount of vagueness to include both polymorphism, parameters and higher order functions :)
09:02:53 <hackrilege> i would like to clean up the instance on line 160; http://lpaste.net/176234 any clues
09:03:26 <hackrilege> 163*
09:07:47 <linduxed> so i've got these two lines
09:07:53 <linduxed> type STGrid s a = S.STUArray s Coordinate a
09:07:55 <linduxed> type Mutation = STGrid s a -> Coordinate -> Coordinate -> ST s ()
09:08:26 <linduxed> the second line is complaining that the type variable `s` is not in scope
09:08:27 <monochrom> type Mutation s ?
09:08:40 <hackrilege> "
09:08:44 <linduxed> ooooh
09:08:54 <linduxed> i need the `s` in the start?
09:09:01 <glguy> linduxed: add an 's' to Mutation's definition
09:09:02 <hackrilege> and an a
09:09:10 <linduxed> makes sense
09:09:13 <monochrom> type Mutation s a =
09:09:16 <linduxed> thanks, i'll try that
09:10:24 <dmwit> hackrilege: `\(Left a) -> Left a` looks odd. Why the partiality?
09:10:34 <hackrilege> omg
09:10:44 <hackrilege> its insane
09:10:58 <hackrilege> it was in another sort of Either
09:11:15 <hackrilege> does that make sense?
09:11:19 <dmwit> No.
09:11:46 <hackrilege> ok, so there is a function switch :: Either a b -> Either a b
09:11:57 <hackrilege> which takes Left to Right and visa versa
09:12:06 <hackrilege> im using it to wrap isomorphisms
09:12:17 <linduxed> damn it, this is making things complicated...
09:12:20 <dmwit> hackrilege: No, there isn't.
09:12:33 <hackrilege> ...
09:12:38 <glguy> What do you suppose happens when you apply (\(Left a) -> Left a) to (Right x)?
09:12:40 <hackrilege> class Switch a b
09:12:42 <monochrom> wait, do you mean Either a b -> Either b a?
09:13:07 <linduxed> now this doesn't work anymore: data Instruction = Instruction { mutation :: Mutation }
09:13:13 <hackrilege> so you have to get it out of one either you were using to convert between some types and put it in a new one to convert to another type
09:13:20 <glguy> linduxed: Lather, rinse, and repeat
09:13:26 <linduxed> "expected a type, but Mutation has kind * -> * -> *
09:13:30 <monochrom> data Instruction s a = Instruction { mutation :: Mutation s a }
09:13:32 <linduxed> :-(
09:13:55 <hackrilege> I guess i should make a spectial case for when there is no way to map back again...
09:14:11 <hackrilege> i was lazy!
09:14:32 <monochrom> Do you actually need to be general about "a"?
09:14:54 <linduxed> monochrom: not yet, but will probably need to be soon
09:15:11 <linduxed> right now it's only used for one thing, soon it will be one more
09:15:20 <linduxed> necessitating some generality
09:16:02 <dmwit> hackrilege: The amount of partial functions in this paste is making klaxxons go off in my head.
09:16:04 <monochrom> There is another extreme. So general about s that it is always "forall s".
09:16:17 <hackrilege> so there is a lot of crazy code for converting between types now, but it has this convenient common syntax of just passing between various Eithers...
09:16:18 <linduxed> this `s` parameter for state is making things complicated...
09:16:33 <linduxed> but i guess this is the part of haskell i've been procrastinating getting in to...
09:16:42 <dmwit> hackrilege: I think there is a deep and fundamental problem with your design.
09:17:31 <hackrilege> i was hoping to make the instances easier to write but that damn manualWitch call is brutal, do you think i could get it with a type family which would represent an intermediate type in the mapping
09:17:47 <monochrom> Both extremely specific and extremely general can let you omit a type variable. (extreme specific --- no type variable at all. extreme general --- the type variable is hidden by a forall. Either way no type variable outside.)
09:18:00 <dmwit> hackrilege: What are you actually trying to achieve with all this?
09:18:16 <monochrom> It is in the middle where you are not specializing nor generalizing that makes you mention the type variable all the time
09:18:29 <hackrilege> it allows me to mix lazy evaluation with a kind of midway state which is stored using the function save
09:18:43 <hackrilege> if you run the last two test you will see it in action with an animation
09:19:06 <monochrom> for example "type Mutation a = forall s. STGrid s a -> Coordinate -> Coordinate -> ST s ()" is possible (needs an extension)
09:19:55 <monochrom> (But don't do that to STGrid.)
09:20:05 <hackrilege> by repeatedly modifying the accessor you build up a composition of lazyness, but if you get concrete values and store them it forces the evaluation and breaks the lazy memory leak which otherwise would have to make reference to the initial conditions via an increasingly long set of functions opperating on the index
09:20:10 <dmwit> hackrilege: I just get exceptions when I try `test5` and `test6`: user error (unknown GLUT entry glutInit). So try to explain what you're trying to do.
09:20:24 <dmwit> hackrilege: Are you just looking for `deepseq`...?
09:20:26 <dmwit> :t deepseq
09:20:28 <lambdabot> Not in scope: ‘deepseq’
09:20:30 <monochrom> (which extension? I forgot. Just toss the code to GHC and let it tell you.)
09:20:30 <dmwit> :t deepSeq
09:20:32 <lambdabot> Not in scope: ‘deepSeq’
09:20:45 <dmwit> :t Control.DeepSeq.deepseq
09:20:47 <lambdabot> Control.DeepSeq.NFData a => a -> b -> b
09:21:34 <hackrilege> cabal install JuicyPixels might get it
09:21:57 <monochrom> Anyway the middle ground is always the worst of both worlds. Tell that to the moderate people. :)
09:22:49 <dmwit> hackrilege: Okay, I think I understand.
09:23:09 <hackrilege> oops, gloss-juicy
09:23:14 <hackrilege> cabal install
09:23:14 <dmwit> hackrilege: I propose: eliminate `SwitchGrid` entirely. Write `save :: Grid a -> Grid a` which roundtrips through `[[a]]` internally.
09:23:29 <dmwit> hackrilege: Eliminate all the other `Switch` nonsense while you're at it.
09:23:38 <hackrilege> worst surgestion ever
09:23:48 <hackrilege> i wrote the whole thing as an example of this style
09:24:03 <dmwit> "This style" is...?
09:24:10 <hackrilege> i want to get to the bottom of how to write the instances good and program more like this
09:24:49 <hackrilege> if ever you just want one isomorphism between types you can define the function and compose these to map between all the types you like to use
09:25:14 <dmwit> `Either a b` is not a good type for isomorphisms between `a` and `b`.
09:25:24 <hackrilege> and to use it you just select the target type and hope the instances are all good
09:25:34 <dmwit> It is not a good type for values which will be supplied to isomorphisms between `a` and `b`, either.
09:25:40 <hackrilege> and use the function switch, which now outputs any type you specify
09:26:07 <dmwit> Okay, it is clear that our goals are misaligned enough that I can't be helpful.
09:26:40 <hackrilege> my goal was to produce a paste that allowed me to communicate what i wanted to
09:27:41 <hackrilege> im happy for any new direction, and yeh scrapping the whole thing is always an option, but i was kind of intrigued as to what was going on, i seemed to be able to abstract a lot of stuff
09:28:11 <hackrilege> i thought maybe there would be some cool result of trying to formalise it properly
09:28:40 <hackrilege> ill admit its strange style, anyway check it out and tell me what you think; http://lpaste.net/176234
09:29:46 <EvanR> (f : A -> B) -> (g : B -> A) -> (f (g y) = y) -> (g (f x) = x) -> Iso A B
09:30:21 <hackrilege> most of those symbols are incorrect
09:30:39 <dmwit> Not incorrect, just off-topic. =)
09:30:41 <hackrilege> : = and -> all in the same line!?
09:30:45 <EvanR> which one, : f A ) or
09:30:55 <EvanR> yeah off topic
09:31:46 <hackrilege> thing is im sure when you look at what i was doing with Either you know some part of lens which does this which i should know about
09:31:46 <dmwit> Unless it was implicitly a suggestion that Haskell is the wrong choice for the problem. Then it might be on-topic.
09:32:26 <hackrilege> thanks
09:33:11 <lingxiao> hey guys I have a problem here:
09:33:45 <lingxiao> http://lpaste.net/176262
09:33:54 <EvanR> the haskell version would be (A -> B) -> (B -> A) -> CrossedFingers -> Iso A B
09:34:05 <lingxiao> the error is in the lpaste
09:34:26 <lingxiao> basically expected a type but FileOp s m has kind ghc-prim-0.4.0.0:GHC.Prim.Constraint
09:34:26 <hackrilege> i cry when my haskell code is ill received by this board :'( but then i remember what cool code i have and i go and make it more illustrative of its coolness, to no avail
09:34:50 <dmwit> lingxiao: Presumably you mean `foo :: FileOp s m => m ()` or similar.
09:34:54 <daniel_w> lingxiao: it's the difference between a -> Monad m and Monad m => a -> ... again
09:35:21 <lingxiao> ahh right that makes sense
09:35:44 <lingxiao> daniel_w  took a break and forgot our previous discussion :)
09:36:47 <hackrilege> "no no no, you shouldnt do that with haskell, you have made it all wrong" but while your all all using realToFrac and fromIntegral all over, i will have defined a Switch instance. its just a shame if you cant help me make it good enough so other people can use it too...
09:38:37 <hackrilege> basically, you can make a newtype and wrap all functions like this
09:39:58 <hackrilege> so neat to just select the desired transformation type, write a constrained synonym of switch (just redefining it with a set type) and it will work magic!
09:40:12 <hackrilege> im sure there must be something like this in lens
09:41:58 <hackrilege> if i can cast from one type to another, and from this type to many other types, writing castings from the first type to those accessible from the seccon should be trivial and algorithmic
09:43:46 * hackagebot preliminaries 0.1.3.0 - A larger alternative to the Prelude.  https://hackage.haskell.org/package/preliminaries-0.1.3.0 (yghor)
09:51:04 <lingxiao> hey guys im getting error: 
09:51:05 <lingxiao> http://lpaste.net/176269
09:51:18 <lingxiao> when I try to add category-extras in my .cabal file
09:51:36 <EvanR> hackrilege (belatedly): there is the Convertible type class
09:52:11 <joe9> I feel that I am doing something wrong http://dpaste.com/3SWTZWG by having getStreamingState and setStreamingState fields. Any suggestions, please?
09:52:29 <joe9> on lines 32 - 36
09:53:02 <lambdamu> lingxiao: it's not on stackage add it to extra-deps in your stack.yaml file
09:53:26 <lingxiao> where is the extra-deps field?
09:53:30 <joe9> It would be cool to use something like MonadState for this. But, I am not knowledgeable enough to foresee if it is a good/bad idea?.
09:53:38 <lingxiao> or where would i add that field?
09:53:42 <joe9> lingxiao:in stack.yaml.
09:53:54 <lingxiao> oh right haha
09:54:33 <lingxiao> extra-deps: ["category-extras"]
09:54:33 <EvanR> joe9: i doubt that MonadState is a good idea for this
09:54:43 <lingxiao> but im getting faile dto parse
09:55:15 <geshe> extra-deps:\n- category-extras-0.1.0.0
09:55:19 <begriffs> lingxiao: you can find more about it at https://docs.haskellstack.org/en/stable/yaml_configuration#extra-deps
09:57:13 <lingxiao> it doesnt say anything about syntax though?
09:58:13 <joe9> EvanR: Any ideas on what is a good solution, please?
09:58:56 <geshe> lingxiao: I gave you the syntax
09:58:58 <EvanR> do you want an action that gets the streaming state from the record
09:59:05 <joe9> lingxiao:  like this http://bpaste.net/show/bc8b647c29d7
09:59:06 <EvanR> just make one
09:59:22 <EvanR> with the proper type signature, not MonadState
09:59:47 <joe9> EvanR: this is a library and I want the user to specify the State data type . So, I can pass the state to any callbacks.
10:00:03 <EvanR> so put the state type in the type of your monad
10:00:06 <joe9> EvanR: But, I also maintain the library's state in that State data type.
10:00:24 <EvanR> well you cant do both, youll need to put the user state in the library state
10:00:32 <EvanR> or make your own monad with two states
10:00:54 <EvanR> either way the user state type goes in the library type
10:02:29 <lingxiao> got it thank you joe9 and geshe!
10:02:47 <joe9> EvanR: like this? http://bpaste.net/show/55db134bc12f
10:03:03 <lingxiao> is there a monadeither construction that's not in category-extras?
10:03:48 <EvanR> joe9: alright... and make monadic actions that do what you want with this context so the user doesnt have to extract stuff manually
10:04:28 <joe9> EvanR: ok, Thanks.
10:08:31 <Gurkenglas> lingxiao, you mean https://hackage.haskell.org/package/either or a typeclass for that?
10:08:52 <lingxiao> hmm maybe i'll use that
10:09:10 <lingxiao> Im looking for this use case: type FileOp s m = (MonadState s m, MonadIO m, EitherT e m a)  
10:09:24 <lingxiao> FileOp s m a = (MonadState s m, MonadIO m, EitherT String m a)
10:09:39 <lingxiao> Gurkenglas should work right?
10:10:17 <Gurkenglas> EitherT String? If you're just gonna throw exceptions you might as well use ExceptT
10:10:58 <Cooler216> http://ilredentore.dynv6.net/ OneHostX...)
10:11:48 <joe9> lingxiao: ExceptT is cool. I like it.
10:11:54 <EvanR> class warfare
10:11:56 <lingxiao> ok cool thanks
10:12:15 <lingxiao> Gurkenglas sorry i just put there 
10:12:24 <lingxiao> i have other type there
10:12:48 <lingxiao> see the problem is in my setting if i cant find a file i just want to go on to the next file that can be found
10:12:57 <lingxiao> does excepT support a good api for that use case?
10:13:14 <lingxiao> exceptT in mtl right?
10:13:59 <Gurkenglas> yep, its not the string thats special to it, its the exception-throwing/catching stuff
10:14:57 <lingxiao> oh isee 
10:15:01 <lingxiao> ok so use controlmonad.except
10:15:15 <lingxiao> specifically catchError right
10:15:39 <geshe> http://lpaste.net/176278 anyone had trouble with linking .so files in stack? i think this has something to do with the order of operations, way over my head though
10:16:03 <lingxiao> so Gurkenglas you're saying use Either a b when a actually outputs something you can use?
10:20:56 <Gurkenglas> You can use EitherT for exceptions and ExceptT for data but ExceptT provides combinators that are more useful for exception stuff and EitherT for data stuff
10:22:01 <Gurkenglas> (and methinks the exception stuff is not that hard to tinker out of the data stuff so EitherT should be the one in the big library but ehh theres more important problems)
10:26:57 <joe9> EvanR: this is what I ended up with: Any suggestions are welcome, please? http://dpaste.com/2T7MP15
10:28:23 <EvanR> were you trying to make a monad
10:29:36 <joe9> EvanR: No, I am already using an ExceptT monad. Adding a monad on top of it just complicates it. I will leave it as-is and let the user app deal with that (manipulating the user state) stuff.
10:30:15 <joe9> EvanR: I mean the user app == callback function.
10:31:04 <EvanR> eh... having the user manually manage ExceptT and this context record (without something State-like or reader-like) doesnt seem like a great library abstraction 
10:31:24 <EvanR> since its already a monad, you might as well make it nicer to use
10:32:33 <dmwit> joe9: I'm not sure which part of the paste you're hoping for feedback on, so forgive me if this is only tangential to your interests, but:
10:33:14 <dmwit> joe9: Since you're exporting `Context`'s constructor and fields, I might consider lightening the definition of `initializeContext`. Something like `initializeContext :: AppKey -> SessionToken -> Context ()`.
10:33:40 <dmwit> joe9: Then let the caller use record update syntax to fill in any other fields they want.
10:34:10 <joe9> dmwit:  https://github.com/joe9/streaming-betfair-api is the whole library, This is the file I am working on: https://github.com/joe9/streaming-betfair-api/blob/master/src/Betfair/StreamingAPI/API/Context.hs
10:34:37 <joe9> dmwit: ok, Thanks. good idea, will do that.
10:35:26 <joe9> dmwit, EvanR ; This is how I am using Context https://github.com/joe9/streaming-betfair-api/blob/master/src/Betfair/StreamingAPI.hs
10:40:01 <dmwit> Why is the bullet for `String` at a different level than the other bullets on https://hackage.haskell.org/package/string-conversions-0.4/docs/Data-String-Conversions.html ?
10:40:12 <dmwit> The bullets in the source are not at different levels.
10:42:14 <alercah> magic
10:42:14 <dmwit> More to the point: should I complain to the haddock folks or to the string-conversions folks?
10:44:32 <dmwit> Doesn't happen on my machine. Perhaps Hackage and I are using different versions of haddock.
10:48:10 <monochrom> interesting
10:53:48 * hackagebot fay 0.23.1.14 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  https://hackage.haskell.org/package/fay-0.23.1.14 (AdamBergmark)
10:58:48 * hackagebot pinboard 0.9.9 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.9.9 (jonschoning)
11:23:39 <lingxiao> hey all
11:23:46 <lingxiao> suppose i have this setup:
11:23:56 <lingxiao> whats the correct type signature for runOp ?
11:24:19 <lingxiao> http://lpaste.net/176309
11:24:27 <lingxiao> I'm getting the rror scene at the bottome
11:25:25 <nitrix> Can you combine parsec combinators?
11:26:31 <nitrix> As in, noneOf "[]" && someThingElse    <|> fallbackParser1 <|> fallbackParser2
11:29:12 <ReinH> Well, not with &&.
11:29:15 <ReinH> What do you want it to do?
11:29:26 <lingxiao> similarly for this operation execOp m s = runExceptT $ execStateT m s
11:29:42 <nitrix> ReinH: I want a logical AND in a similar way that there's a logical OR with alternative <|>
11:29:43 <lingxiao> the problem is: execOp :: FileOp s m => m () -> s -> m (Either Message a) ,  the m in m() is not aprorpiately defined
11:29:56 <ReinH> lingxiao: does it compile without explicit type signatures?
11:30:00 <lingxiao> yeah
11:30:02 <lingxiao> and it works
11:30:16 <ReinH> Then load it up in ghci and ask for :t execOp
11:30:19 <Marqin> Why I'm getting "parse error" on Just? http://lpaste.net/127089289174450176
11:30:33 <byorgey> nitrix: logical AND?  You mean, the same string has to satisfy *both* parsers?
11:30:38 <lingxiao> its funny because FileOp s m = (MonadState s m, MonadIO m, MonadError Message m)
11:30:42 <lingxiao> so m () should work
11:30:56 <ReinH> Marqin: lines 4 and 5 need to be indented past the `c' in case because of layout rules
11:30:58 <lingxiao> m a doesnt work either
11:31:02 <ReinH> @google haskell wiki layout
11:31:03 <lambdabot> https://wiki.haskell.org/Template_Haskell
11:31:05 <ReinH> no
11:31:24 <ReinH> https://en.wikibooks.org/wiki/Haskell/Indentation
11:31:38 <Marqin> ReinH: thanks
11:31:39 <ReinH> See the golden rule.
11:32:11 <__Myst__> What's [| |]?
11:32:14 <ReinH> lingxiao: Just ask ghci
11:32:25 <ReinH> __Myst__: quasiquotation
11:32:31 <lingxiao> it gives this huge verbose thing
11:32:36 <ReinH> https://wiki.haskell.org/Quasiquotation
11:32:43 <ReinH> lingxiao: Well, that's the type.
11:32:56 <ReinH> Perhaps it can be simplified with synonyms that ghci isn't applying
11:33:00 <ReinH> but not to m () or m
11:33:07 <ReinH> So perhaps the type isn't what you believe it to be
11:33:13 <__Myst__> ReinH: Thanks!
11:34:06 <lingxiao> http://lpaste.net/176316
11:34:14 <ReinH> Marqin: for long lines, it's common to swing the case down to the next line
11:34:39 <ReinH> Well, it's only long because it's fully qualifying StateT and ExceptT
11:34:40 <lingxiao> thats ghci output
11:35:10 <nitrix> byorgey: Correct.
11:35:16 <lingxiao> oh right because I said evaluate execStateT then runExceptT   it now is a  concret instance of monad transforer?
11:36:24 <nitrix> byorgey: I'm assuming it's not a common case?
11:36:37 <ReinH> lingxiao: It accepts a value of that type, which is a monad transformer.
11:36:43 <byorgey> nitrix: you can do that with lookahead.  p1 && p2 = try (lookAhead p1) *> p2
11:36:55 <byorgey> actually you probably don't need that 'try'
11:37:18 <nitrix> So applicative <*>, but I drop the result of the first parser?
11:37:22 <nitrix> *>
11:37:28 <ReinH> yes
11:37:46 <byorgey> yep
11:37:50 <ReinH> byorgey: ideally there should be a combinator that steps through both parsers concurrently, but I don't think it exists.
11:38:11 <byorgey> of course if you want the result of p1 instead you can just switch them
11:38:44 <byorgey> ReinH: right, agreed, though I don't know how useful that would be in general.  It doesn't seem like a common use case.
11:38:51 <ReinH> Which is probably why it doesn't exist
11:39:10 <byorgey> unless the common section being parsed is really long it probably doesn't make much difference anyway
11:39:16 <ReinH> yep
11:39:42 <ReinH> although `noneOf "[]"` could be pretty long in some corpa...
11:39:57 <nitrix> I was more trying to isolate the complexity of both parsers.
11:40:15 <ReinH> if you do expect one to fail more quickly, you can at least do that one first.
11:40:34 <ReinH> oh, no, because it parses a single char
11:40:55 <ReinH> but probably it doesn't matter
11:40:57 <byorgey> nitrix: makes sense
11:47:03 <Gurkenglas> http://lpaste.net/5298530041578127360 is my actual OpenGL installation too new?
11:54:50 <geekosaur> I think it's saying the implicit default resolver is too new?
11:57:12 <dmwit> liftA2 (,) (lookAhead p1) p2
11:57:20 <dmwit> Get both results! =P
11:58:38 <geekosaur> Gurkenglas, it's using 6.10 resolver which has OpenGL-3.0.1.0, but gloss only claims to work with OpenGL-2.12.*
12:00:28 <Gurkenglas> So I need to either change the global stack.yaml to use a different resolver, or put the thing that needs gloss in a project instead of using it as a script (executed like "stack dragger.hs")?
12:01:24 <geekosaur> well, it's worse than that; I can't find a stackage release that has OpenGL prior to 3.0
12:02:32 <geekosaur> so you'd have to figure out an old LTS release based on other dependencies and then specify OpenGL-2.12.0.1 and maybe other packages as an external dependency
12:07:12 <lingxiao> hey all
12:07:24 <lingxiao> is this lib depricated? https://hackage.haskell.org/package/filesystem-conduit
12:07:26 <lingxiao> it has this deprecated Tag on top
12:07:42 <ReinH> Then yes.
12:07:47 <lingxiao> but its still being downloaded
12:07:55 <lingxiao> and it goes all the way up to 1.0.0.2
12:08:02 <ReinH> Yes, in 2014.
12:08:06 <lingxiao> where as this: https://hackage.haskell.org/package/conduit-0.0.1.1/docs/Data-Conduit-Binary.html
12:08:27 <lingxiao> exposes the same api
12:08:34 <ReinH> And is the one that isn't deprecated.
12:08:34 <lingxiao> but it's like version 0.0.1
12:08:40 <ReinH> No, it's version 1.0.4
12:08:41 <lingxiao> ok just making sure
12:08:44 <ReinH> and it's development is ongoing
12:08:49 <ReinH> latest release in July 2016
12:09:02 <ReinH> *its
12:09:22 <Welkin> what who
12:09:30 <ReinH> Generally when package authors state that their package is deprecated, it's because the packaage is deprecated.
12:09:43 <Welkin> maybe they meant to say it was depreciated
12:09:53 <ReinH> Well, I suppose I do value it less now than I used to.
12:10:25 <ReinH> There isn't even a version 0.0.1 of that package.
12:10:45 <Welkin> 0.0.0\
12:10:52 <ReinH> Or that.
12:12:04 <lingxiao> ok i have three packages that i could use
12:12:06 <lingxiao> zip-conduit
12:12:10 <lingxiao> zip-arhive
12:12:14 <lingxiao> and zip
12:12:35 <lingxiao> my use case is that I'm opening and unzipping gigantic zip files and concatenating them into even a larger file
12:12:49 <ReinH> The first one seems to work with conduit. The second two do not.
12:12:51 <lingxiao> earlier incarnation of the program incurred space leak
12:13:06 <ReinH> No, zip works with conduit as well.
12:13:41 <lingxiao> I'd like my code to run years from now so I'm tryig to figure out which lib to commit to
12:13:42 <Gurkenglas> geekosaur, but I was able to just write stack install gloss on another machine and it worked. How can that be? Did it not have a global stack.yaml yet and choose one that works, maybe?
12:13:47 <lingxiao> if not years at least a year
12:13:58 <ReinH> lingxiao: your code will work forever once it's written, either way
12:14:08 <ReinH> Well, for at least as long as the relevant things can be downloaded
12:14:13 <geekosaur> I think the default resolver might depend on the version of stack itself
12:14:15 <lingxiao> what about breaking changes?
12:14:21 <lingxiao> in the api that is
12:14:27 <mtae> Hello, is there a way to have ghci print floats, doubles etc in decimal rather than scientific notation?
12:14:28 <lingxiao> then i have to go back and yadayada
12:14:30 <ReinH> Constrain the versions of things whick break
12:14:30 <geekosaur> since it's not using the latest LTS, but one version behind
12:14:35 <ReinH> so that you don't use the broken versions
12:14:43 <mtae> (I tried printF but I'm using an algebraic data type containing doubles)
12:14:47 <geekosaur> but, I don't know enough about stack to answer that really.
12:14:49 <mtae> *printf
12:14:50 <ReinH> that's exactly why cabal lets you add version constraints to deps
12:14:59 <Gurkenglas> Cool I still have the version of stack that I used to stack install gloss. So I rename the global stack.yaml and use it to install gloss?
12:15:00 <Welkin> I sometimes fork a package and put it in a remote repo and then add it to my stack.yaml
12:15:09 <Welkin> so it pulls from my personal repo instead of hackage to install
12:15:14 <Welkin> if I need to make a tiny change
12:15:48 <ReinH> Gurkenglas: stack will always have a global resolver in its global config, and they were probably just different.
12:16:50 <ReinH> lingxiao: we are generally not in the business of predicting the future, so we can't say which package would be better a year from now. Both zip and zip-conduit seem to be actively developed.
12:17:01 <lingxiao> ok great thanks
12:17:13 <Welkin> it's pretty easy to switch libraries in haskell
12:17:20 <Welkin> because refactoring is trivial
12:17:41 <ReinH> Also true.
12:18:05 <nitrix> Also, swapping between modules of the same library is common. e.g. containers, the insert/lookup/etc of Map/Set/etc are very similar.
12:18:08 <ReinH> Well, trivial is a bit of an oversell, but certainly easier than in any other language I've tried.
12:18:29 <nitrix> Or Debug.Trace vs. Debug.NoTrace (two different libraries).
12:18:50 <ReinH> Well, those things are specifically designed to be API compatible.
12:19:39 <ReinH> (e.g., Map.Strict and Map.Lazy)
12:20:16 <nitrix> Yeah, but I suppose it's a telling sign of what the expectations can realistically be.
12:20:55 <nitrix> If you have a data structure with an insert operation and you call it `add`, you might get funny looks.
12:23:24 <begriffs> What's the most elegant way to construct a function "Eq a => [a] -> [a] -> Maybe a" that returns the first element in the first list to appear in the second list? Is it a combination of find and (<|>) or something?
12:24:14 <glguy> begriffs: probably using find and elem
12:25:04 <saurabhnanda> praise the gods. GHCJS has compiled.
12:25:32 <Gurkenglas> :t \xs ys -> find (`elem` ys) xs
12:25:34 <lambdabot> (Eq a, Foldable t, Foldable t1) => t a -> t1 a -> Maybe a
12:26:33 <Gurkenglas> @let (f .: g) x = f . g x
12:26:34 <lambdabot>  Defined.
12:26:38 <Gurkenglas> :t listToMaybe .: intersect
12:26:39 <lambdabot> Eq a => [a] -> [a] -> Maybe a
12:27:48 <begriffs> Gurkenglas: Oh the first one makes sense. Might the second one calculate more than is needed or will laziness stop it from finding the whole intersection?
12:28:03 <Gurkenglas> It will.
12:28:28 <mtae> how does one have ghci print ouput in decimal notation truncated at a certain number of digits rather than scientific? i.e. 5.66 as opposed to 5.6600001e-5
12:28:33 <ph88^> hi all
12:28:54 <nitrix> Gurkenglas: I was always writing that (.) . (.) until now, nice.
12:29:12 <begriffs> Gurkenglas: will the first element of intersect definitely be the first matching item from the first list? It's important that I get the first item, and not an arbitrary item.
12:29:48 <Gurkenglas> begriffs, I too had to look that up: http://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.OldList.html#intersect
12:29:58 <ph88^> can anyone help me using state monad here?  https://paste.fedoraproject.org/407113/47103016/
12:30:43 <Welkin> OldList?
12:32:16 <ph88^> im also looking for a haskell coach
12:32:38 <nitrix> begriffs: It's checking for elements of the first list present in the other list with `any (==)`. Duplicates are preserved, but it doesn't matter since listToMaybe will short-circuit at the first element.
12:32:52 <begriffs> Thanks guys
12:33:04 <nitrix> begriffs: So yes, you're good.
12:33:41 <nitrix> s/first element/first successful result/
12:33:51 * hackagebot mtl-extras 0.1 - Higher order versions of MTL classes  https://hackage.haskell.org/package/mtl-extras-0.1 (int_index)
12:33:54 <nitrix> s/result/intersection/
12:33:57 <nitrix> :P
12:35:26 <Gurkenglas> ph88^, where are you defining initialState and s? You are also going to want to import Control.Monad.Identity to have access to runIdentity.
12:37:07 <lambdafan> ph88^: check your pm
12:37:33 <lingxiao> hey all is there a MonadConduit class?
12:37:38 <lingxiao> I know there's a conduitM
12:37:52 <lingxiao> it's certainly not in the mtl package
12:37:54 <Gurkenglas> ph88^, you can also replace (runIdentity . runParserT') by the identical runParser'
12:38:28 <ReinH> lingxiao: what would it do?
12:38:52 <lingxiao> not clear to me yet, so i was hoping if a package exist it would tell me
12:38:56 <ReinH> conduitM works with an arbitrary Monad instance.
12:39:04 <lingxiao> Im trying to add it to this: type FileOpS s m = (MonadState s m, MonadIO m, MonadError Message m) 
12:39:06 <ReinH> I don't know what MonadConduit would do
12:39:15 <ReinH> Why?
12:39:19 <ReinH> m isn't a conduit
12:39:30 <ReinH> it has no relationship to conduits
12:39:58 <lingxiao> so suppose i have a fileOpS function, instead of opening a file using readFile
12:40:01 <lingxiao> I want to use sourceFile
12:40:19 <lingxiao> how would I accomplish it as of now?
12:40:25 <ReinH> What is the type of fileOpS?
12:40:33 <lingxiao> FileOpS s m = (MonadState s m, MonadIO m, MonadError Message m)
12:40:38 <ReinH> No, fileOpS
12:40:57 <lingxiao>  StateT s (ExceptT Message m) a
12:41:00 <ReinH> No
12:41:08 <ReinH> You said "suppose I have a fileOpS function"
12:41:12 <ReinH> what is "a fileOpS function"?
12:41:36 <lingxiao> ok heres an example
12:41:42 <lingxiao> http://lpaste.net/176363
12:41:55 <ReinH> (that isn't a function)
12:42:18 <lingxiao> what is it?
12:42:19 <lingxiao> a program?
12:42:22 <ReinH> An action
12:42:24 <ReinH> A value
12:42:33 <lingxiao> functions are values 
12:42:35 <ReinH> functions are types constructed with ->
12:42:41 <ReinH> Yes, but not all values are functions
12:43:01 <lingxiao> ok so suppose I want to use sourceFile with that
12:43:02 <ReinH> So it is both a value and not a function
12:43:14 <ph88^> Gurkenglas, initialState is in here https://hackage.haskell.org/package/megaparsec-5.0.1/docs/src/Text-Megaparsec-Prim.html
12:43:19 <ReinH> It's a MonadIO, so you can do anything you can do in IO
12:43:22 <ReinH> which includes using conduits
12:43:41 <ph88^> Gurkenglas, i would like to use runParserT' because it's the most general way to run a parser. I can always use the helper functions later if needed
12:44:29 <Gurkenglas> Then you'll need to import runIdentity and initialState, and define s, because it's telling to it doesnt know those three names.
12:45:18 <Gurkenglas> (import Text.Megaparsec.Prim, as you linked)
12:45:30 <ReinH> The typeclasses in the mtl refer to the behavior of the monadic context. Does it contain state? Can you read a value? Can you write a value? Etc.
12:45:32 <ph88^> Gurkenglas, i think initialState is not exported by this package
12:45:36 <ReinH> There is no "conduit-ness" in the monadic context
12:45:40 <Gurkenglas> Then you can't use it.
12:45:41 <ReinH> MonadCondiut doesn't make sense
12:46:11 <ReinH> s/iu/ui
12:46:12 <Gurkenglas> (or are you asking whats actually supposed to go there?)
12:46:36 <Welkin> yay :D
12:46:38 <Welkin> won a hearthstone
12:46:41 <ph88^> i will copy it instead
12:46:56 <Gurkenglas> Good luck :D
12:47:46 <lingxiao> ok so ReinH so suppose I have openFile = sourceFile "" >> return ()
12:47:51 <lingxiao> what would its type be?
12:48:08 <ReinH> It would have no type. It would be a type error.
12:48:20 <Gurkenglas> How do I tell stack to install any version at all of a package I specify? I dont care what resolver it uses. It can even install it into a project, as long as I can put scripts in there and have them use that package.
12:48:31 <lingxiao> ok so if I want to use souceFile with what i have so far how might i open a file with it/
12:48:45 <lingxiao> so say open a file using sourceFile and then incrment an underlying counter
12:48:57 <Welkin> Gurkenglas: stack install <package>
12:49:01 <ReinH> Basically, the same way you would in IO, just with liftIO in front.
12:49:06 <Welkin> it will install it in the global cache for you to use anywhere
12:49:26 <ReinH> Just like you've done with readFile
12:49:34 <lingxiao> ReinH so I think I dont really get what conduit is on a conceptual level is then
12:49:39 <lingxiao> even though I can read the source file
12:49:47 <lingxiao> why is there no conduit-ness to conduit?
12:49:55 <ReinH> That is not what I said
12:49:56 <Gurkenglas> Welkin, it'll use the global resolver for that, right? That doesn't work. Can I tell it to use whichever resolver works?
12:50:03 <ReinH> There is obviously conduit-ness to conduit, since it is conduit.
12:50:12 <Gurkenglas> Doesnt work in the sense of the package fails to build
12:50:22 <ReinH> there are no conduits or conduit behaviors contained in the monadic context of FileOpS
12:51:10 <lingxiao> ReinH can you clarify that last statement
12:51:36 <ReinH> If I have a MonadFoo typeclass, then presumably instances of that typeclass have something to do with Foo
12:51:44 <ReinH> like MonadState instances have something to do with state
12:52:00 <ReinH> a MonadConduit typeclass would imply that the instances have something to do with conduits
12:52:09 <absence> i have an operation that is somewhere between map and fold, as it can merge neighbour items only in certain cases. does that have a name?
12:52:24 <Welkin> map is just a special fold
12:52:37 <ReinH> Aside from possibly containing conduits as values in staet or reader or etc (which is already handled by MonadState or MonadReader), there is no relationship between a monad and a conduit.
12:52:37 <lingxiao> ReinH so based on what you just said why does it not make sense to have a MoandConduit class
12:52:55 <absence> Welkin: yes
12:53:01 <lingxiao> so you mean you cannot define (>>=) over the set of conduits
12:53:11 <ReinH> No, I don't mean that
12:53:12 <lingxiao> ?
12:53:28 <lingxiao> yeah that would make no sense since it's a monad
12:53:32 <lingxiao> there is no relationship between a monad and a conduit.
12:53:34 <ReinH> Why *does* it make sense to have a MonadConduit typeclass?
12:53:38 <ReinH> What would it do?
12:54:05 <lingxiao> you can compose anything that has conduit "traits" using ($$) for example
12:54:12 <absence> Welkin: but if there's a more specific recursion scheme, that would be nice
12:54:13 <ReinH> Anything?
12:54:17 <ReinH> Then why is Monad in the name?
12:54:52 <Welkin> absence: you mean left/right fold?
12:55:31 <Welkin> absence: when you say merge neighbor items, do you mean a Monoid?
12:56:00 <lingxiao> ReinH i see. why is that when i do (liftIO $ sourceFile "") I am getting this error: 
12:56:00 <lingxiao> http://lpaste.net/176375
12:56:07 <Welkin> well, a map cannot affect the structure of the data
12:56:15 <Welkin> a fold can
12:56:23 <ReinH> because sourceFile is not an IO action
12:56:31 <ReinH> You wouldn't say do { sourceFile "" } in main
12:56:38 <absence> Welkin: no not a monoid, because merging is only defined for some values
12:56:41 <ReinH> you need to use the conduit machinery
12:57:03 <lingxiao> ok so i have to run sourceFile right?
12:57:07 <lingxiao> :t runResrouceT
12:57:08 <lambdabot> Not in scope: ‘runResrouceT’
12:57:20 <lingxiao> import Control.Monad.Trans.Resource
12:57:23 <lingxiao> :t resourceT
12:57:24 <lambdabot> Not in scope: ‘resourceT’
12:57:53 <ReinH> lingxiao: Now, your monad is not a conduit, but conduits *are* monads, and in fact they are monad transformers.
12:58:01 <ReinH> So there are two possibilities:
12:58:17 <ReinH> 1) use conduit machinery in IO actions with lift()
12:58:37 <ReinH> 2) add ConduitM to your transfomer stack and use the conduit machinery on your monad which now *is* a conduit.
12:59:19 <ReinH> There is no MonadConduit typeclass because arbitrary monads aren't conduits. Only ConduitM is a conduit.
12:59:30 <ReinH> s/lift()/liftIO
13:00:10 <ReinH> (2) is not the usual way of using conduits, so you will find fewer examples of it and will have to just rely on the documentation
13:00:38 <ReinH> (ConduitM is http://hackage.haskell.org/package/conduit-1.2.7/docs/Data-Conduit.html#t:ConduitM)
13:00:47 <coolest_head> help
13:01:48 <ph88^> Gurkenglas, i fixed the code https://paste.fedoraproject.org/407129/14710320/ but how can i use runParserT' ?
13:01:57 <ReinH> lingxiao: Data.Conduit.Lift will probably help if you pursue option 2.
13:02:11 <lingxiao> ReinH I think I'll pursue option 1
13:02:20 <ReinH> But, then again, the mtl typeclass instances are already there for ConduitM, so perhaps not.
13:02:34 <ph88^> https://hackage.haskell.org/package/megaparsec-5.0.1/docs/src/Text-Megaparsec-Prim.html#runParser%27
13:03:17 <lingxiao> ReinH so the thing you sent me for conduitM
13:03:32 <lingxiao> it's basically saying a conduitM could have ERror, State etc correct
13:03:52 <ReinH> Yes, if it transforms a monad which has those instances, it also has those instances.
13:04:01 <ReinH> by doing the appropriate lifting internally
13:04:18 <lambdamu> I think it is useful to think of conduit as the top of your transformer stack
13:04:44 <ReinH> e.g., ConduitM i o (StateT state m) is an instance of MonadState state
13:04:51 <lambdamu> if you pile on another transfomer the result isn't nescessarily a conduit anymore
13:05:00 <ReinH> lambdamu: Well, it's useless to think of it anywhere else :)
13:05:30 <lambdamu> yes but that gives an intuition maybe why there is no MonadConduit class
13:05:37 <saurabhnanda> any one with knowledge about reflex and ghcjs?
13:05:38 <ReinH> Right, I think I did mention that :)
13:05:57 <ReinH> But you put it more clearly
13:06:15 <ReinH> saurabhnanda: it's better to ask your question and see if anyone can answer it.
13:06:36 <ReinH> There is also #reflex-frp
13:06:58 <lingxiao> ok gtg thanks ReinH and lambdamu!
13:07:10 <Gurkenglas> ph88^, import Control.Monad.Identity and replace runParser' by (runIdentity . runParserT').
13:07:34 <ph88^> Gurkenglas, i have the import on line 17, no ?
13:07:39 <ph88^> when i replace that i get an error
13:08:29 <ph88^> Gurkenglas, this is the error i get https://paste.fedoraproject.org/407133/32479147/
13:09:36 <Gurkenglas> Sorry, replace "runParser'" by "runIdentity $ runParserT'".
13:10:20 <ph88^> ah yes works now ^^
13:10:41 <ph88^> Gurkenglas, does that mean the parser runs inside the identity monad ?
13:10:57 <Gurkenglas> yes
13:11:17 <Gurkenglas> It already does so, runParser' internally just uses runParserT'
13:12:29 <ph88^> Gurkenglas, how can i replace the identity monad by the state monad ?
13:12:30 <saurabhnanda> I'm trying to build https://github.com/yamafaktory/reflex-starter with some modifications  in stack.yml and 'stack build' is failing with '.stack-work/dist/x86_64-osx/Cabal-1.24.0.0_ghcjs/: openBinaryTempFileWithDefaultPermissions: does not exist (no such file or directory)'
13:14:43 <elben> In haskell-servant, we see type signatures that look like this: type Post   = Verb 'POST 200, Get '[JSON] [User]. What does the single quote do here?
13:15:39 <Welkin> elben: it is a type-level list
13:15:45 <absence> Welkin: i guess i could have each step of the fold return a list (or other monad) of either one or two values, then concat (or join) the result
13:15:55 <absence> Welkin: just curious if such a structure has an existing name :)
13:15:59 <geekosaur> means it's a value promoted to type level
13:16:16 <Gurkenglas> ph88^, you make "(rawData <* eof)" a ParsecT that has a state monad in its third type argument, and unwrap the state monad stuff instead of doing runIdentity
13:18:14 <ph88^> i'm amazed you know that (rawData <* eof) is of type ParsecT and also that it should go in the 3rd argument
13:18:18 <ph88^> i checked the type it seems right
13:20:04 <elben> Welkin: hmm thanks, i’ll have to read about type level values
13:21:18 <ph88^> Gurkenglas, i don't know how to do what you are suggesting, by the types you seem to be on the correct solution
13:21:45 <Gurkenglas> Neither do I x)
13:22:09 <ph88^> haha funny xD
13:22:41 <Welkin> elben: http://stackoverflow.com/questions/31786828/what-is-this-haskell-syntax-type-level-operators
13:25:09 <koz_> What's the name of the extension that lets me have two different records with the same field?
13:25:29 <elben> Welkin: thanks
13:27:24 <cocreature> koz_: DuplicateRecordFields
13:27:30 <koz_> cocreature: Thank you!
13:27:31 <ReinH> saurabhnanda: you could try my https://github.com/reinh/reflex-dom-stack-demo
13:28:19 <ReinH> I found that version dependencies had to be managed carefully and explicitly (which ghcjs do you download, etc.) or nothing would work.
13:28:41 <ReinH> (It is a bit old now and may not be the state of the art for running ghcjs on stack)
13:28:52 <saurabhnanda> ReinH: checking. Is that lts-6.6 with GHC 7.10.3 by any chance?
13:29:14 <saurabhnanda> ReinH: ouch. lts-3.16
13:29:32 <saurabhnanda> ReinH: I just spent 3 hours installing GHCJS with lts-6.6
13:31:09 <ReinH> I said it's old :)
13:31:33 <ReinH> But you might have some luck updating it to new versions of things
13:31:36 <ReinH> if so please do send a PR
13:32:21 <ReinH> ofc the trouble I had finding which versions of things work together is the reason that it exists in the first place
13:40:16 <ph88^> does anyone know why (rawData <* eof) is of type  ParsecT Dec String Identity  ??   https://paste.fedoraproject.org/407143/71033844/
13:44:04 <geekosaur> http://hackage.haskell.org/package/megaparsec-5.0.1/docs/Text-Megaparsec-String.html#t:Parser
13:45:17 <ph88^> hhmm geekosaur i see Parsec there not ParsecT
13:45:25 <geekosaur> since most of your component parsers are declared as (Parser something) and you are using Text.Megaparsec.String, you get its expansion of Parser as ParserT Dec String Identity
13:45:38 <geekosaur> yes, so click on it to find type Parsec e s = ParsecT e s Identity
13:46:51 <geekosaur> (which is why types in haddock are hyperlinks to their definitions)
13:48:35 <ph88^> geekosaur, i'd like to use the state monad instead of identity .. should i declare my own type Parser ?
13:48:50 <geekosaur> if you want an easier way to refer to it, sure
13:49:08 <geekosaur> "Parser" is not a magical name you need to use for things to be recognized as parsers
13:49:43 <ph88^> so the main magic is about ParserT ?
13:49:55 <WhoP> If some of you could spam https://docs.google.com/spreadsheets/d/11KJFtjueGC99t7U243xJ8YTmnuTwpljVIz_VeOcqyvI/edit#gid=0 :)
13:50:01 <WhoP> Please ;)
13:50:16 <Welkin> no spam allowed
13:50:26 <geekosaur> yes, insofar as that is the actual type of a Megaparsec parser
13:50:39 <geekosaur> the others are just convenience aliases for common use cases
13:51:11 <lambdumb> question: is there a way to have a list comprehension use dynamically generated generators?
13:51:41 <Welkin> lambdumb: sure, you can use variables inside it
13:51:54 <geekosaur> or even functions
13:52:05 <monochrom> what is dynamically generated generator?
13:52:21 <monochrom> and does "generator" = "list"?
13:52:22 <Welkin> I think they mean a lazy list that is created at runtime
13:52:32 <Welkin> instead of [1..10]
13:52:45 <lambdumb> so what I mean is this
13:52:47 <lambdumb> let a = [ (a,b,c,d,e) | a <- [0..8], b <- [0..10], c <- [0..15], d <- [0..30], e <- [0..30], (a*20) + (b*15) + (c*10) + (d*5) + (e*5) == 150]
13:52:58 <Welkin> [x | x <- xs, x > 5]
13:53:09 <lambdumb> a <- [0..8] is a generator in that context, no?
13:53:38 <monochrom> I would not think of "a <- [0..8]" as one single thing.
13:54:12 <monochrom> I would follow the truth: it's <pattern> <- <expression, type has to be list>
13:54:31 <jonored> It might be worthwhile to think about list comprehensions, do notation, and what it actually expands to to get a solid understanding of that.
13:55:03 <lambdumb> I agree jonored
13:55:14 <geekosaur> more to the point, you can specify any expression but the pattern cannot be constructed at runtime
13:55:19 <Welkin> list comprehensions are syntactic sugar
13:55:21 <lambdumb> but just to make my question clear
13:55:24 <lambdumb> yes
13:55:25 <Welkin> it is all just >>= underneath
13:55:28 <lambdumb> for list monads
13:55:29 <lambdumb> yeah
13:55:42 <lambdumb> I think I am still lacking something though
13:55:47 <monochrom> OK, your code is legal. Is that it?
13:55:55 <lambdumb> that desugaring the comprehension won't sort out
13:56:09 <lambdumb> so this LC
13:56:10 <lambdumb> let a = [ (a,b,c,d,e) | a <- [0..8], b <- [0..10], c <- [0..15], d <- [0..30], e <- [0..30], (a*20) + (b*15) + (c*10) + (d*5) + (e*5) == 150]
13:56:17 <lambdumb> is a local solution to the problem I am working on
13:56:38 <lambdumb> what I'd like to be able to do is have tuples of different arity
13:56:53 <jonored> You can do that, but not with list notation :)
13:56:58 <monochrom> No, they have different types, cannot be put in the same list.
13:57:17 <monochrom> You cannot even have [(1), (1,1), (1,1,1)].
13:57:36 <jonored> (they don't go in the same list, or they become lists, or otherwise the type system has new requirements for you when you do, but the effect is achievable.)
13:58:24 <lambdumb> interesting
13:58:34 <Welkin> lambdumb: you can define your own type to hold them
13:58:42 <EvanR> you want tuples of different arity, and are uniformly containing numbers
13:58:52 <lambdumb> basically
13:58:54 <EvanR> how about [[Int]]
13:58:54 * hackagebot validity 0.3.0.1 - Validity typeclass  https://hackage.haskell.org/package/validity-0.3.0.1 (Norfair)
13:58:55 <Welkin> data Container a = C1 a | C2 a a | C3 a a a
13:59:31 <geekosaur> you could use an expression which can work with tuples of variable but matching arity; this would probably involve zipList* or its Applicative
13:59:50 <geekosaur> (and would end up being ugly, but sometimes thats the lemon life gives you)
13:59:58 <lambdumb> yeah
14:00:18 <Welkin> why do people always want the most convoluted solutions to problems they don't have?
14:00:21 <Welkin> lol
14:00:25 <monochrom> lemon is great. lemon is why the cloth-washing powder smells good.
14:00:26 <lambdumb> damnit, LC's felt like such an elegant way of solving the problem
14:00:32 <Welkin> like the guy who wanted dependency injection yesterday
14:00:50 <jonored> lambdumb: Well, but how would you write it out?
14:01:10 <lambdumb> well, I feel like I could write a program to generate the list comprehension that I want
14:01:13 <monochrom> and lemon is why my kettle doesn't accumulate deposit infinitely
14:01:26 <lambdumb> found the brit :)
14:02:10 <jonored> lambdumb: I think there's a fold you can do across a list of lists to the same effect, though.
14:02:26 <jonored> (Well, two, because you want a guard expression somewhere in there.)
14:02:34 <lambdumb> that's probably the route to go down
14:02:46 <monochrom> My current theory for why people invent convoluted (convolved?) solutions is that people perform depth-first search.
14:02:49 <jonored> it's probably small, really.
14:03:55 * hackagebot genvalidity-hspec 0.2.0.3 - Standard spec's for GenValidity instances  https://hackage.haskell.org/package/genvalidity-hspec-0.2.0.3 (Norfair)
14:03:57 * hackagebot cabal-mon 1.0.2 - A monitor for cabal builds  https://hackage.haskell.org/package/cabal-mon-1.0.2 (IavorDiatchki)
14:03:58 <lambdumb> basically I want to write a program that counts solutions to a linear equation
14:04:21 <quchen> Welkin: DI is what we have hidden arguments (achieved with various techniques) for. Like DI, it’s a mess.
14:04:53 <monochrom> I do have a convoluted solution for that. Look for algorithms for the integer programming problem.
14:04:58 <quchen> But wanting something that passes down values you’d just like to be “there” is something we have in Haskell just as well.
14:06:58 <monochrom> quchen, but it gets better. Specifically, the other day the DI discussion was sparked by an attempt that involves Data.Dynamic and multiple arities.
14:07:31 <quchen> I lost you when I realized that I did not want to not lose you.
14:07:43 <quchen> That sounds terrible and I would like to know nothing about it.
14:08:12 <monochrom> I think that if that person was just doing vanilla DI rather than completely-the-most-general-DI, Welkin would not have felt it convoluted.
14:08:27 <monochrom> Yeah don't worry, I can't remember the details.
14:09:28 <JuanDaugherty> dependency injection?
14:09:59 <monochrom> quchen: If it's any consolation, consider "dependent injection" instead :)
14:10:13 <monochrom> yes JuanDaugherty.
14:11:02 <quchen> monochrom: Dynamic dependent injection!
14:12:17 <monochrom> dependent injection is an injective type family (injection; think also surjection, bijection) that is indexed by values rather than types (dependent)
14:12:51 <ph88^> :D
14:13:03 <monochrom> for example (n : Nat) -> Vec n Double
14:13:10 <ph88^> thank you Gurkenglas & geekosaur 
14:14:45 <hololeap> is it possible to pattern match a function passed as an argument?
14:15:06 <monochrom> No.
14:15:11 <Gurkenglas> http://lpaste.net/2245980274733088768 why is queryString empty? That's the one that should contain the important values, right?
14:15:18 <hololeap> also would you say arguments or parameters?
14:15:43 <hololeap> in haskell
14:15:53 <Gurkenglas> I would say parameters if it "changes what the function does", and argument if the function "operates on it"
14:16:12 <hololeap> Gurkenglas: gotcha
14:16:12 <quchen> Both are fine.
14:16:18 <Gurkenglas> For example, in DebugFlag -> Network -> Network, DebugFlag is a parameter and Network an argument
14:16:37 <quchen> Like in math, there’s only a very subjective difference between parameter, argument, and even constants.
14:16:58 <hololeap> so is there any way to check the identity of a function when it is passed as an argument or otherwise assigned to a variable?
14:17:26 <quchen> No. All you can do is apply the function to a value.
14:17:37 <geekosaur> Gurkenglas, isn't the request body for a POST separate from the query string?
14:17:39 <quchen> You cannot check whether you were given the identity function or something else as parameter, for example.
14:17:45 * monochrom starts the School of Argumentative Polymorphism.
14:18:02 <hololeap> ok, i didn't think so but i wanted to check anyway
14:18:10 <monochrom> in which free theorems are obtained by argumentation :)
14:18:11 * geekosaur is just guessing though. a request body is the content, not part of the URL
14:18:50 <Gurkenglas> geekosaur, I don't know, I'm improvising this, someone tell me how this should be done.
14:19:16 <jonored> ...and lambdumb left before I finished just-done-at-work golfing with: foldM (fmap . flip (:)) [] [[1,2],[3,4]]
14:19:40 <sleblanc> Gurkenglas, the queryString is the part after ? in a url
14:19:52 <sleblanc> e.g. http://example.com/?key=value&key2=value2
14:20:06 <geekosaur> but this is a POST and the POST data is usually in the body, not the URL
14:20:10 <sleblanc> what you seem to have is an encoded form, which is the body of a POST request
14:20:44 <sleblanc> you can even have both
14:21:09 <mikail`> Hi, is it idiomatic in Haskell to call the leaf element in a tree a Tip?
14:21:18 <mikail`> data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show) 
14:21:24 <Gurkenglas> Oh, so I dont want to put the form values in the requestBody? Hmm I could just do parseReqest "http://lpaste.net/new?private=Private&title=&author=Gurkenglas&language=haskell&channel=&paste=test&email=" couldnt i
14:21:25 <mikail`> data Tree a = Tip | Node a (Tree a) (Tree a) deriving (Show)
14:22:22 <hololeap> so is one of the rules of functions that it must be able to take any function as an argument as long as it meets the type constraints?
14:22:30 <lpaste> author pasted “disregard me” at http://lpaste.net/6897401170214518784
14:22:36 <hololeap> (for functions that take other functions as arguments)
14:22:56 <quchen> mikail`: Certainly not idiomatic, but somewhat common.
14:23:09 <quchen> You can also call it “Empty” or whatever you like.
14:23:34 <orion> Anyone know of any good SO answers or articles/blog posts about how to write performant data structures? (As opposed to performant functions)
14:23:38 <sleblanc> Gurkenglas, this is just a test, but it seems that everything needs to be encoded in the body. the body of that "disregard me" test is: private=Private&title=disregard+me&author=author&language=haskell&channel=%23haskell&paste=Hello%2C+this+is+a+test%2C+please+disregard+me.&email=
14:23:46 <mikail`> quchen: ok, good to know - I'm working through Okasaki's book and translating the ML code into Haskell for the exercises.
14:23:55 <quchen> hololeap: “There is no ‘case’ for types”
14:24:21 <hololeap> ok, sorry i'm used to languages with dynamic dispatch
14:24:22 <quchen> hololeap: And it’s very important that it is this way, because the usefulness of the type system relies heavily on that fact
14:25:19 <quchen> When I give you a function “a -> a”, I promise you that it does exactly the same thing for all admissible inputs.
14:25:40 <quchen> In Python on the other hand, you could write an identity function that adds one to its argument if it’s an integer.
14:26:13 <mikail`> I've been coding in Haskell for about 6 months now and just starting to appreciate the type system. I code in Scala for food and water and I have to say, compared to Haskell, it's type inference system is poor.
14:26:37 <mikail`> especially when trying to write recursive functions.
14:27:04 <Gurkenglas> sleblanc, can you tell how to do that in Network.HTTP.Simple? Or of course you can suggest another library that makes this simple x)
14:27:18 <mikail`> even it's foldleft function needs type annotations in some circumstances in order for it to work
14:29:51 <sleblanc> Gurkenglas, I don't have much experience with this library. looking at the docs, you should have great success using the function setRequestBodyURLEncoded → http://hackage.haskell.org/package/http-conduit-2.2.0/docs/Network-HTTP-Simple.html#v:setRequestBodyURLEncoded
14:31:25 <sleblanc> you would use it like so: setRequestBodyURLEncoded [("private", "Private"), ("title", "disregard me")…] myRequest
14:31:35 <sleblanc> replace strings with bytestrings
14:32:51 <quchen> mikail`: Haskell also needs type annotations occasionally. Probably nowhere as often as Scala from what I hear though.
14:33:08 <sleblanc> Gurkenglas, re: bytestrings, I see you are using OverloadedStrings; you should be ok with this
14:33:18 <quchen> Type classes can introduce ambiguous types, so we have to specify those explicitly.
14:33:51 <Gurkenglas> sleblanc, nah I just copypasted that from an example for, it turned out, another library. But I guess I can deal
14:36:23 <Gurkenglas> Another thing: "dragger.exe: user error (unknown GLUT entry glutInit)" Ive got a glut32.dll in my SysWOW64 already (see third question from the bottom http://gloss.ouroborus.net/ ) what do?
14:38:25 <mikail`> quchen: yes Haskell does sometimes usually when dabbling in some of the more esoteric extensions and type-level programming.
14:38:40 <sleblanc> Gurkenglas, if it's not too much to ask, can you try building a simple Hello world GLUT program in a language other than Haskell?
14:38:56 * hackagebot glabrous 0.1.1.0 - A template library  https://hackage.haskell.org/package/glabrous-0.1.1.0 (MichelBoucey)
14:39:51 <Gurkenglas> Umm. That'd probably take a while. I guess I could find my java stuff and maybe figure out how to install a library or two "about this GLUT stuff" and see what I can do but Im not too good with this interface stuff :D
14:40:20 <Gurkenglas> You could send me an executable?
14:40:51 <sleblanc> Gurkenglas, sorry, I do not run Windows.
14:43:56 * hackagebot hsparql 0.2.8 - A SPARQL query generator and DSL, and a client to query a SPARQL server.  https://hackage.haskell.org/package/hsparql-0.2.8 (RobStewart)
14:47:52 <Gurkenglas> sleblanc, http://lpaste.net/5553249790101291008
14:52:10 <mniip> woohoo
14:52:10 <sleblanc> Gurkenglas, my intuition tells me it worked ok, save for two things: the program did not give you the URL to the paste (so you cannot retrieve it) and it seems like it is not using the proper encoding to decode the body
14:52:14 <mniip> I wrote IOT
14:52:36 * jonored will need to idle here more, hsparql is something he needed a week ago for his puzzling lambdabot...
14:56:52 <lpaste> author pasted “disregard me again” at http://lpaste.net/1267729579611521024
14:57:48 <Gurkenglas> (I assumed I would get the url back somehow if I actually got it to paste correctly. Should have tried public and seen the new paste pop up)
14:58:01 <Gurkenglas> Wait, its still just your intuition we should test it
14:58:57 * hackagebot servant-auth-token 0.2.0.1 - Servant based API and server for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-0.2.0.1 (NCrashed)
15:00:09 <Gurkenglas> sleblanc, nope, no new entry on http://lpaste.net/browse
15:00:17 <Gurkenglas> (only the one i manually constructed with that url)
15:08:18 <CarMeister> hello. i am going to start learning how to program in haskell and want to know if there is anything i should know before i start
15:12:29 <lambdamu> http://dev.stephendiehl.com/hask/
15:14:52 <Welkin> dmj: jazztel? spain?
15:15:10 <dmj> Welkin: si, en barcelona
15:15:38 <Welkin> dmj: some kind of haskell event going on?
15:15:47 <dmj> no, just vacation
15:15:51 <Welkin> haha
15:16:10 <dmj> Welkin: more in #haskell-offtopic? 
15:16:12 <Welkin> you'd join #haskell on vacation?
15:16:28 <dmj> es el cielo azul?
15:18:20 <absence> is there no library function to append [a] to NonEmpty a?
15:18:32 <pikajude> is there an implementation of the van Laarhoven free monad for which I could add an Error effect (that is, with catchError :: m a -> (e -> m a) -> m a)
15:23:25 <pikajude> i don't understand how i'd be able to write an effect that has an 'm a' in other than the terminal position
15:26:45 <sleblanc> absence, let appendN (x :| xs) ys = x :| (xs ++ ys)
15:26:53 <sleblanc> @let appendN (x :| xs) ys = x :| (xs ++ ys)
15:26:54 <lambdabot>  .L.hs:154:12:
15:26:54 <lambdabot>      Not in scope: data constructor ‘:|’
15:26:54 <lambdabot>      Perhaps you meant one of these:
15:27:06 <sleblanc> @let import Data.List.NonEmpty as NE
15:27:07 <lambdabot>  Defined.
15:27:09 <sleblanc> @let appendN (x :| xs) ys = x :| (xs ++ ys)
15:27:11 <lambdabot>  Defined.
15:27:14 <sleblanc> :t appendN
15:27:15 <lambdabot> NonEmpty a -> [a] -> NonEmpty a
15:33:14 <absence> sleblanc: yeah it's easy to make one, just seemed like something that should already be there :)
15:47:16 <c_wraith> pikajude, I'm pretty sure that's a limitation all encodings of free monads have. 
15:47:23 <pikajude> nice
15:47:31 <hololeap> this is really confusing me: http://dpaste.com/25MGY3C
15:47:47 <pikajude> so what do I do if I want to use it, but I also want to be able to catch errors in my program?
15:49:45 <c_wraith> hololeap, look at the type of flip const in isolation 
15:50:22 <hololeap> flip const :: b -> c -> c
15:50:45 <hololeap> so if c is an Integral, it should work, right?
15:51:44 <c_wraith> heh. your first example doesn't say what you think it does, either. 
15:51:44 <ReinH> well, it is unlikely that even . const is what you want either
15:51:59 <hololeap> i'm just playing around with syntax
15:52:36 <ReinH> it requires functions to be Integral
15:52:41 <c_wraith> then why are you concerned with type errors? 
15:52:55 * mniip prefers const id to flip const
15:53:27 <hololeap> oh man my head hurts
15:53:35 <ReinH> do you also prefer id to ($)?
15:54:02 <c_wraith> yes but `id` isn't worth it. 
15:54:07 <ReinH> heh
15:54:23 <glguy> I like Skittles®
15:54:30 <ReinH> at least ($) has better errors
15:55:55 <ReinH> hololeap: well you are making it do silly things
15:56:10 <hololeap> what i can't wrap my head around is why "even (const id 4 5)" works but "(even . const id) 4 5" doesnt
15:56:22 <ReinH> because they are different
15:56:33 <ReinH> inline the definition of (.)
15:56:50 <ReinH> see if you can get your first expression out of it
15:57:39 <hololeap> i'm essentially trying to make a function that takes two arguments, drops the first one, and returns if the second one is even
15:57:39 <ReinH> make sure you parenthesize expressions properly
15:57:57 <ReinH> what does it do if it is odd?
15:58:12 <hololeap> sorry for the noob stuff
15:58:20 <sleblanc> returns if the second one is even, as in True or false? so you want to apply `even` to your second argument, right?
15:58:27 <hololeap> right
15:58:32 <hololeap> and drop the first one
15:58:37 <ReinH> ah returns (if second one is even)
15:58:37 <sleblanc> const even
15:59:03 <ReinH> how about \_ x -> even x
15:59:08 <sleblanc> == const even
15:59:36 <hololeap> jesus, i must have confused myself
15:59:38 <sleblanc> (const even) will drop the first argument, "return" the even function, then the second argument is applied to even
15:59:51 <hololeap> time to take a break
16:00:00 <ReinH> I'm just saying sometimes the straightforward way is best
16:00:08 <sleblanc> (const even) 4 5 == even 5
16:00:08 <ReinH> usually, really
16:00:25 <ReinH> yes, I know
16:00:53 <sleblanc> it was directed at hololeap 
16:01:11 <ReinH> But I think that's just clever
16:02:07 <hololeap> holy crap i'm confused.... wouldn't const even mean that const takes a function and returns a function?
16:02:19 <ReinH> See?
16:02:22 <jonored> hololeap: Have you hit currying yet?
16:02:50 <hololeap> yeah, but i thought const :: a -> b -> a didn't mean it can take a function
16:03:02 <jonored> Ah! But it can.
16:03:03 <ReinH> const takes a value and gives a value, as do all functions
16:03:15 <ReinH> functions *are* values
16:03:15 <jonored> it just doesn't /have/ to.
16:03:29 <sleblanc> "a", as a type variable, stands for anything. numbers, functions, other values…
16:03:56 <hololeap> i thought functions were denoted like :: (a -> a) -> b     (or something)
16:04:02 <ReinH> so const can take a function
16:04:28 <ReinH> a is a type variable that represents any type
16:04:43 <sleblanc> const is exactly like id, except it drops its second argument. Since you can pass a function to id, you can also pass a function to const
16:04:53 <hololeap> i'll try to wrap my head around that
16:04:54 <ReinH> including (b -> b) -> c
16:05:09 <ReinH> (names changed to protect the innocent)
16:05:42 <hololeap> thanks though, i think understanding this fact will really help
16:06:07 <ReinH> > id even 2
16:06:08 <lambdabot>  True
16:06:11 <hololeap> i'll try to imagine the currying order on my break
16:06:46 <ReinH> id even = even, so (id even) 2 = even 2
16:06:51 <jonored> hololeap: it's the same sort of difference between the type :: [a] -> b and :: a -> b
16:07:03 <sleblanc> hololeap, here's a fun little web app that lets you play with "pointfree" functions: http://blunt.herokuapp.com/
16:07:23 <sleblanc> hololeap, for instance, try typing in "f _ x = even x"
16:07:39 <ReinH> you can also stack install pointfree pointful and play along at home
16:07:48 <jonored> [a] and (b->c) are both subsets of the "anything" that is a free type variable.
16:11:42 <hololeap> so the ordering can be manipulated with id const and fix?
16:13:46 <ReinH> fix? No.
16:14:37 <hololeap> i just see fix used when i followed sleblanc's advice
16:14:44 <ReinH> I'd recommend just writing the function you mean. It'll be easier to read later.
16:14:46 <hololeap> and use the web app
16:15:08 <jonored> Oh, yeah, the pointfree thing knows a lot of arbitrary little combinators.
16:15:09 <ReinH> Don't worry about making things pointfree.
16:15:23 <ReinH> pointfree is good for reasoning about composition
16:15:38 <ReinH> but here you are explicitly reasoning about application
16:16:07 <hololeap> well, i was just playing around
16:16:56 <mniip> oh
16:16:58 <hololeap> i was trying to see if i could use pointfree to make a function that uses deleteBy and deletes the first even element
16:17:02 <mniip> the webapp is kinda dumb
16:17:19 <mniip> it uses fix on first occasion it can
16:17:34 <mniip> hololeap, what's the pointful function look like?
16:18:29 <ReinH> isn't that just deleteBy even?
16:18:38 <hololeap> (deleteBy (\_ b -> even b)
16:18:55 <hololeap> sorry.... (deleteBy (\_ b -> even b) 0)
16:19:01 <mniip> deleteBy (const even) 0
16:19:29 <hololeap> yep :)
16:19:36 <ReinH> oh right it takes two args
16:19:48 <mniip> not sure where the fix came from
16:20:27 <hololeap> anywho, thanks everyone
16:21:50 <ReinH> deleteBy is the wrong thing for that, but the right thing isn't in Data.List so
16:23:26 <ReinH> imo deleteBy should take an a -> Bool and delete should be delete x = deleteBy (== x)
16:23:59 <ReinH> like filter, not like nub
16:33:03 --- mode: ChanServ set +o mauke
16:33:03 --- mode: mauke set -b $a:fuk-off
16:35:03 --- mode: mauke set -o mauke
16:57:51 <mniip> :t deleteBy
16:57:52 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
16:58:37 <mniip> hmm, never used that function
16:58:46 <mniip> and I can't say I can tell what it does from the type
16:59:40 <mniip> oh
17:00:00 <mniip> so it's like filterFirst
17:00:09 <mniip> filterOutFirst rather
17:04:01 * hackagebot autoproc 0.2.1 - EDSL for Procmail scripts  https://hackage.haskell.org/package/autoproc-0.2.1 (JasonDagit)
17:11:34 <alphonse23_> Could anybody here tell me what this is: https://github.com/google/proto-lens
17:11:48 <ReinH> mniip: right
17:11:54 <alphonse23_> I found it on google github repo, which says it's not an official google product
17:12:40 <alphonse23_> but it looks like a boiler plate generator that automatically generates len accessors for haskell classes
17:12:44 <ReinH> Apparently it's a Haskell library for google's protocol buffers that uses lenses
17:12:45 <alphonse23_> if that's what they're called...
17:13:05 <alphonse23_> okay, but that sounds like a boiler plate code generator
17:13:12 <alphonse23_> that's what that means right?
17:13:33 <ReinH> I believe that it generates Haskell files based on .proto definition files
17:13:43 <ReinH> Since that's what the readme says that it does
17:13:46 <alphonse23_> are .proto a google thing
17:13:51 <alphonse23_> I think I've heard them before.
17:13:56 <ReinH> protocol buffers are a google thing, yes
17:14:02 <alphonse23_> k, cool
17:14:03 <alphonse23_> thanks
17:14:04 <ReinH> .proto files are the files that define their schemas
17:14:26 <ReinH> I assume "not an official google product" means that someone at google developed it but the company doesn't provide support etc
17:14:28 <alphonse23_> they have those for go to i noticed
17:20:45 <ReinH> those what?
17:24:07 <alphonse23_> proto buffers
17:24:18 <alphonse23_> I just read some of the docs on proto buffer
17:24:47 <alphonse23_> in a way, I feel like what google is doing is unwise. They basically want to turn everything into a class based langauge like java and c++
17:24:57 <alphonse23_> but haskell isn't really meant to be used that way
17:25:24 <ReinH> Eh?
17:25:46 <ReinH> that's a pretty strange read on the goals of protobuffers.
17:26:08 <alphonse23_> https://www.irccloud.com/pastebin/vIyLiL86/
17:26:22 <ReinH> Yes?
17:27:03 <alphonse23_> aren't the uses of lenses already on shady ground?
17:27:07 <ReinH> No?
17:28:52 <ReinH> There is nothing "shady" about lenses.
17:29:18 <ReinH> They are, if anything, highly principled.
17:29:44 <Welkin> unless you are wearing shades
17:29:49 <Welkin> those lenses are dark
17:29:56 <Welkin> shady
17:31:24 <ReinH> I wear my sunglasses at night, etc
17:33:16 <nshepperd> xml is a strange comparison. 'think XML, but it doesn't suck'
17:33:52 <ReinH> nshepperd: protobuffers are a bit weird
17:34:09 <ReinH> But I don't think they're part of a secret plot to add OOP classes to Haskell.
17:35:25 <nshepperd> they're more like C structs with an official serialization format
17:35:28 <ReinH> Yes.
17:35:38 <JuanDaugherty> in a world of ugly there's something reassuring about the fact nobody might have tried to introduce OOP hs
17:35:39 <ReinH> extensibility =/= oop classes
17:35:55 <JuanDaugherty> but it's like false, somebody prolly has
17:36:00 <JuanDaugherty> *likely
17:36:01 <ReinH> I'm sure they have.
17:36:31 <hpc> perhaps the sort of person who would introduce OOP without understanding the language will just be too frustrated by not understanding haskell?
17:37:00 <nshepperd> it's not that uncommon for people to come into #haskell and ask how to implement some OOP thing with typeclasses
17:37:26 <exio4> ReinH: it is part of an illuminati conspiracy
17:37:34 <hpc> and once you do break into the mindset to use haskell well, OOP just leaves your mind
17:38:41 <geekosaur> oleg did an oo haskell thing, just to prove it could be done.
17:39:19 <hpc> oleg also wrote a lambda calculus in make ;)
17:42:41 <ReinH> hpc: I wrote a redis client in bash, which I guess is not as significant an achievement.
17:43:20 <hpc> i wrote part of a game in imagemagick :D
17:43:32 <hpc> (the rest was happstack, it was horrible)
17:43:58 <ReinH> you wot m8
17:44:04 <ReinH> sorry, *u
17:44:17 <ReinH> Ok actually I can sort of see it
17:44:42 <hpc> the whole thing was actually an excuse to write imagemagick bindings
17:44:48 <ReinH> heh
17:44:51 <hpc> or at least a high-level binding
17:44:52 <ReinH> fair play
17:45:08 <hpc> i ended up not being happy with the C interface, so instead it does it with command line calls
17:45:15 <divVerent> when using Control.Monad.Trans.Cont, how can I get the continuation out of callCC (returning it or passing it back would return an infinite type)
17:45:19 <ReinH> I'm thinking about writing a dungeon crawl stone soup bot in Haskell. Someone already wrote one in crawl's own config language.
17:45:25 <divVerent> alternatively, where can I actually read how reset/shift actually work
17:45:27 <ReinH> Which is less impressive when you realize that you can use lua
17:45:27 <hpc> which at least makes the behavior easier to understand, but also it didn't work on windows at the time i wrote it
17:45:46 <divVerent> the description on Wikipedia seems to skip the most interesting step (namely, why calling shift twice works)
17:45:52 <Welkin> crawl?
17:46:14 <ReinH> Welkin: read the first sentence.
17:46:40 <divVerent> (regarding the callCC question: in Ruby I can do something like c = callcc { |c| return c }
17:46:43 <Welkin> what is crawl?
17:46:49 <divVerent> and then invoking the continuation loops back to where the original callcc was)
17:46:55 <geekosaur> someone did a partial bot in haskell, but I can't remember who at this point
17:47:10 <Welkin> do a nethack bot in haskell
17:47:15 <ReinH> Welkin: dungeon crawl stone soup
17:47:19 <geekosaur> welkin: https://crawl.develz.org
17:47:54 <geekosaur> (and something like a quarter of the folks over in ##crawl are also in here...)
17:47:55 <ReinH> geekosaur: Oh I think they're in here occasionally but the name escapes me too
17:48:04 <Welkin> geekosaur: really? why is that?
17:48:12 <geekosaur> no idea
17:50:24 <hpc> divVerent: you probably want delimited continuations
17:50:25 <geekosaur> ah, right. https://github.com/rwbarton/rw
17:50:50 <ReinH> oh yeah
17:51:03 <ReinH> nice thanks
17:51:31 <divVerent> hpc: right
17:51:59 <divVerent> hpc: I'm trying to understand them, but just can't - like, what IS the actual control flow
17:53:36 <divVerent> it all seems easy as long as shift is called only once
17:53:55 <ReinH> divVerent: it helps if you draw a diagram.
17:54:28 <divVerent> probably, but which diagram
17:54:57 <divVerent> reading the implementation in Control.Monad.Trans.Cont also just poses even more questions (e.g. how does THAT reset implementation even work)
17:56:44 <hpc> @unmtl ContT r m r -> ContT r' m r 
17:56:44 <lambdabot> ContT r m r -> ContT r' m r
17:56:47 <hpc> :(
17:56:54 <hpc> @unmtl ContT r' m r
17:56:54 <lambdabot> (r -> m r') -> m r'
17:57:59 <hpc> so that's ((r -> m r) -> m r) -> (r -> m r') -> m r'
17:58:01 <hpc> for reset
17:59:01 <hpc> turns out there already exists an (r -> m r), that's just return
17:59:10 <hpc> so that's something like
17:59:18 <divVerent> reset is defined as lift . evalContT
17:59:30 <hpc> reset f g = (f return) >>= g
17:59:35 <divVerent> so to me that kinda looks like inserting a continuation block into another continuation block
17:59:48 <hpc> with that (>>=) being the one for m
18:00:03 <divVerent> (what happens if I call the outer block's "shift argument" from an inner reset block?)
18:00:07 <hpc> evalContT m = runContT m return
18:01:48 <hpc> you'll probably just have to mess with it in ghci and see what it does
18:02:11 <ReinH> geekosaur: Oh, it connects to webtiles? I would have thought that writing a telnet client would be easier.
18:02:25 <hpc> and use a general understanding of Cont/ContT as a baseline
18:02:43 <geekosaur> my recollectoon is all the bots use the webtiles json because it's more consistent; the console interface does things like prompting at strange times
18:02:52 <hpc> i don't know of any really good resources for continuations offhand
18:03:10 <geekosaur> (even with the webtiles interface you still have to deal with some of that, but it's worse there)
18:03:28 <geekosaur> also it's just easier to deal with json in general
18:03:40 <hpc> but basically, those reset and shift definitions are encoding delimited continuations in terms of undelimited continuations by taking advantage of the fact that ContT is sort of delimited already
18:04:18 <hpc> there's no global continuations, it's all limited to actions with the ContT type being consumed by runContT
18:04:20 <ReinH> geekosaur: ah, but you also have to maintain the entire game state yourself, right?
18:04:34 <geekosaur> that I don't know offhand.
18:04:47 <divVerent> hpc: that's where I am currently at:
18:04:51 <divVerent> > evalContT $ resetT $ do { a <- shift $ \ f -> return $ ["<"] ++ f "a" ++ f "A" ++ [">"]; b <- shift $ \ f -> return $ ["{"] ++ f "b" ++ f "B" ++ ["}"]; return ["(", a, ",", b, ")"] }
18:04:52 <divVerent> Identity ["<","{","(","a",",","b",")","(","a",",","B",")","}","{","(","A",",","b",")","(","A",",","B",")","}",">"]
18:04:53 <lambdabot>  Not in scope: ‘evalContT’Not in scope: ‘resetT’
18:04:54 <geekosaur> have seen some discussion of bot writing and operation, but you'd do better talking to rwbarton or elliptic or etc. about specifics
18:04:57 <ReinH> Yeah, I don't know what the network protocol is
18:04:59 <divVerent> and that looks a bit too magical
18:05:07 <divVerent> that it seems to manage to produce the cartesian product here
18:05:38 <divVerent> especially as I can't seem to manage to get similar behavior from just callCC
18:05:39 <hpc> divVerent: make less magical examples that do things you can attempt to predict
18:05:55 <divVerent> as for that I'd have to somehow get the argument of callCC out of the callCC
18:08:30 <divVerent> hpc: now that I look at it, wonder if one way of understanding this could be that each shift (in execution order) wraps the current computation, which starts at the initial reset expression, but values get inserted where the shift is every time
18:08:38 <divVerent> i.e. calling shift multiple times acts like composition
18:08:54 <divVerent> just - HOW can it possibly do something like THAT
18:08:57 <divVerent> ;)
18:10:09 <divVerent> essentially, what I'm wondering is how to replicate something similar using just ContT, evalContT, lift, (.) - as that's all what resetT and shiftT are actually using
18:10:26 <divVerent> while additionally also understanding what I'm doing :)
18:11:05 <ReinH> for the former, just inline resetT and shiftT. For the latter, good luck. :)
18:11:22 <divVerent> ReinH: right
18:11:27 <divVerent> the former is "easy" ;)
18:11:43 <divVerent> it just doesn't go into my head that two functions defined so trivially can do something as "magic" as this
18:12:08 <Welkin> :t const id
18:12:09 <lambdabot> b -> a -> a
18:20:55 <divVerent> ok, first of all I noticed that resetT REALLY doesn't do much other than executing one delimited continuation computation inside another
18:20:58 <divVerent> so I can ignore that one
18:25:24 <kilimanjaro> is there a variant of fold that would look like :: (a->b->b) -> (a->b) -> [a] -> b
18:25:48 <kilimanjaro> so that f g [x,y,z] would be x `f` (y `f` (g z))
18:26:27 <kilimanjaro> i could define my own, just wondering whether this sort of operation has a name / shows up elsewhere
18:27:42 <divVerent> ah, HERE is the real magic:
18:27:45 <divVerent> evalContT $ do { lift (print "1"); ContT (\ next -> do { next 0 >> next 1 }); lift
18:27:47 <divVerent>  (print "2"); }
18:27:49 <divVerent> "1"                                                                                                                                                   "2"
18:27:51 <divVerent> "2"
18:28:03 <divVerent> so these continuation do NOT serve as an escape only (which is what callCC seems to be restricted to)
18:28:34 <Welkin> kilimanjaro: kilimanjaro just wrap a fold
18:28:42 <kilimanjaro> ok
18:28:56 <Welkin> myfold f g = foldr ...
18:29:02 <divVerent> so I suppose that tells me what I wanted to know about reset/shift
18:29:09 <divVerent> as the "magic" seems to be the same in the end
18:29:32 <divVerent> so essentially, reset just opens a new continuation, and shift wraps "what follows"
18:29:40 <divVerent> (but has no influence over what was before it)
18:29:51 <divVerent> should have tried it with IO first to see that :)
18:38:08 <divVerent> thank you!
18:38:46 <mniip> :t \f g -> foldr (\x -> maybe (Just $ g x) (Just . f x)) Nothing
18:38:47 <divVerent> (and BTW confirmed with ContT+IO that shift doesn't re-execute anything before it - so the reset serves "practically" more to define the end, not the start)
18:38:47 <lambdabot> Foldable t => (a -> r -> r) -> (a -> r) -> t a -> Maybe r
18:40:19 <mniip> hmm, \x -> Just . maybe (g x) (f x)
18:40:24 <mniip> it's irritating me
18:41:27 <mniip> clearly, join (((Just .) .) . (. f) . maybe . g) is no good
18:41:44 <mniip> and 'on' doesn't have the type
18:43:08 <lingxiao> hey guys im trying to express some conduitM here and i'm really struggleing
18:43:27 <mniip> could say, \x -> mplus (Just $ g x) . fmap (f x)
18:44:13 <lingxiao> here sthe code
18:44:14 <lingxiao> http://lpaste.net/176487
18:44:16 <Xandaros> mniip: I think what you're trying to do is rather pointless
18:44:19 <lingxiao> the error is at foo
18:44:38 <lingxiao> wait .. nvm
18:45:11 <Xandaros> lingxiao: Add a MonadResource constraint? ^^
18:45:23 <lingxiao> yeah .. its weird when i first did that it didnt work .. ha
18:45:27 <lingxiao> myabe i typoed
18:45:35 <lingxiao> btw hate to take it off topic
18:45:48 <lingxiao> but does any of you work in the valley and have seen the show silicon valley
18:46:04 <lingxiao> whats your opinion on how on the nose it is with the satire?
18:46:09 <mniip> Xandaros, exactly
18:47:59 <Xandaros> mniip: In both senses of the word... What's so bad about one... point?
18:49:03 <miscyb> lingxiao, i interviewed at google one time and the type of people i saw fit the stereotype pretty well
18:49:38 <lingxiao> miscyb which character?
18:49:47 <Welkin> miscyb: autistic?
18:49:48 <lingxiao> theres a few stereotypes in the show
18:50:05 <miscyb> lingxiao, the brogrammers mostly
18:50:18 <lingxiao> thats so funny i would think google is a "nerdy" place
18:50:26 <lingxiao> but now it's a lot of rank and file?
18:50:31 <lingxiao> and what exactly is a brogrammer?
18:50:51 <Welkin> lingxiao: a douchebag who thinks they are still in a college frat house
18:52:34 <lingxiao> hmm interesting
18:58:44 <lingxiao> ok now im getting this bug again .. and im not sure how to fix it
18:58:50 <lingxiao> type error not bug
18:59:18 <lingxiao> http://lpaste.net/176489
18:59:55 <lingxiao> it says no instance for monadRsource arising from a use of `sourceFile`
19:00:08 <lingxiao> because i presume sourceFile is not an instance of MonadResource
19:01:06 <glguy> I added the ability to load extensions at runtime with the runtime dynamic linker, and then made an extension that loads a Lua interpreter (it'd be possible to add other languages via the same interface but I know Lua the best of these scripting languages)
19:02:09 <glguy> Hopefully the Haskell and Lua sides don't react as opposites and release some kind of explosion
19:02:24 <lingxiao> ok nvm fixed it
19:02:27 <lingxiao> its so werid
19:08:01 <lingxiao> hey does conduit provide a nice way to open all files in a directory and fold over the files
19:08:11 <lingxiao> as if all the files form a list, and say i want to fold an concactenate the files
19:09:44 <Clint> lingxiao: https://hackage.haskell.org/package/conduit-extra-1.1.13.2/docs/Data-Conduit-Filesystem.html ?
19:10:44 <lingxiao> ok thanks@
19:33:41 <earldouglas> Where can I report bugs on haskelliseasy.com?  I can't find it on GitHub or anywhere else.
19:33:57 <Welkin> to bitemyapp 
19:34:04 <Welkin> he's the creator
19:35:49 <glguy> Anyone have any favorite examples of versioned, dynamically loaded extensions? I'd like to be able to reliably detect that an extension is not likely to work when loaded via dlsym
19:36:10 <glguy> I have some ideas but I'm curious how this gets solved in other situations
19:36:15 <linoge> Hi, howdy :).
19:37:32 <linoge> I'm reading about Monad transformers right now. I saw in RWH that IO should be at the bottom of the "stack". Naively put, this means that if I've got an IO computation that might result in failure, I should be returning, let's say, something along the lines of Either (String, IO)?
19:38:11 <linoge> And thus, IO Either a b would be... less adequate, if not wrong?
19:45:48 <geekosaur> neither of those makes a lot of sense as written
19:46:49 <dmwit> ?unmtl ErrorT e IO a
19:46:49 <lambdabot> IO (Either e a)
19:47:37 <dmwit> IO (Either a b) seems like a perfectly cromulent type to me
19:49:04 <geekosaur> but IO Either a b is not the same thing
19:49:09 <dmwit> The problem with Either e (IO a) is you have to decide whether an error happened before you can do any of the IO. That seems too restrictive to be useful in most cases.
19:49:15 <geekosaur> (and is invalid)
19:50:31 <dmwit> Yes, my answer is predicated on assuming some newbie imprecision in the question.
19:51:19 <dmwit> linoge: (just highligtting you)
19:52:04 <linoge> Yup sorry I was reading something ^^. I see
19:52:41 <linoge> Thanks ^^.
20:05:05 <lingxiao> hey all i want to say this:
20:05:37 <lingxiao> http://lpaste.net/176496
20:05:44 <lingxiao> but im gettin the error as suggetsed
20:08:36 <geekosaur> iirc that type can never be inhabited
20:10:51 <geekosaur> or more correctly, the existential 's' can't unify with anything and is completely inaccessible. (forall does not do what you want there. I'm not sure what you do want, but an unusable type alias is probably not it)
20:11:24 <lingxiao> ah i see htat makes sense
20:12:09 <glguy> You just can't have quantifiers like this in constraints
20:14:15 <hackrilege> probably everyones asleep but i wrote up my crazy isomorphism thing really neatly and it looks great! http://lpaste.net/176500
20:19:42 <hackrilege> im aware of the dangers of overlapping instances. to use this approach you have to vet your instances carefully and is only useful in a narrow setting where only one isomorphism exists. ii intended to use for Zippers wrapping lists. the idea would be that to convert to a ListZipper (data ListZipper a = ListZipper [a] [a]) it would not make sense to
20:19:42 <hackrilege>  define many ways to convert to it, only a single definition to convert from [a] should be written, and anything that wants to be convertable to a zipper should just have an instance defined taking it to [a]. this short framework provides this interface
20:28:15 <alphonse23_> so you guys are saying I don't understand OO then....
20:28:44 <alphonse23_> oh well, I had to leave to drink with my coworker. I'm only now learning protobuf...
20:28:47 <ReinH> alphonse23_: I don't remember anyone saying that
20:29:02 <ReinH> If anything, I was suggesting that you don't seem to understand protobuf
20:29:07 <ReinH> since it has nothing to do with OO
20:29:20 <alphonse23_> setters and getters feel OO though to me.
20:29:27 <Welkin> no one understands OO
20:29:35 <Welkin> because what you think is OO is not
20:29:44 <Welkin> it's just java
20:29:57 <hackrilege> datatypes in haskell are like objects in OO
20:30:14 <ReinH> Anyone else want to demonstrate Welkin's point for him?
20:30:37 <ReinH> Because no, they are not.
20:30:59 <ReinH> They don't hold mutable state, they don't hold behavior, they don't receive messages.
20:31:04 <glguy> OO is a license to kill
20:31:07 <hackrilege> in haskell, classes provide the ability to provide abstract functions
20:31:37 <alphonse23_> you know, the thing to about lens, is that I always though they were invented because haskell made it hard to do the same thing you can do with typicall oo classes really hard with records.
20:31:56 <ReinH> I suppose that's true fsvo "abstract", but I don't see the relevance.
20:32:22 <hackrilege> i have no clue what les does, it seems non trivial
20:32:27 <hackrilege> lens
20:32:46 <alphonse23_> "OO is a license to kill" so doesn't that make my point about adding setters/getter aka "Composable field accessors via lenses" bad practice
20:32:51 <glguy> Most OO language's can't do what lens does
20:32:52 <alphonse23_> i mean bad practice, like subject
20:32:54 <alphonse23_> ive
20:32:56 <alphonse23_> but
20:33:01 <glguy> lens is like field selectors as values
20:33:24 <hackrilege> eg snd?
20:33:24 <ReinH> composable ^
20:34:04 <ReinH> you can't set with snd
20:34:34 <hackrilege> as in (\(a,b) c -> (a,c)?)
20:35:10 <hackrilege> how can you easily write this using snd?
20:35:23 <ReinH> I just said that you can't.
20:35:47 <hackrilege> snd (f a b) = b
20:35:56 <ReinH> Yes, I know what snd is.
20:36:06 <ReinH> wait, what?
20:36:06 <hackrilege> no that defines f
20:36:12 <glguy> > set (upon snd) 'c' ('a','b')
20:36:14 <lambdabot>  ('a','c')
20:36:19 <glguy> >_<
20:36:32 <hackrilege> :t set
20:36:32 <ReinH> ...
20:36:33 <lambdabot> ASetter s t a b -> b -> s -> t
20:36:37 <hackrilege> nooo
20:36:50 <hackrilege> that ASetter spells doom
20:37:12 <pavonia> FFI question: How do you define a Storable.peek function for a type "union { WCHAR UnicodeChar; CHAR  AsciiChar; }"? Always return a WCHAR and write an extra conversion function WCHAR -> CHAR?
20:37:13 <hackrilege> :t upon
20:37:13 <ReinH> That doesn't "define f"
20:37:14 <lambdabot> (Data s, Data a, Applicative f, Indexable [Int] p) => (s -> a) -> p a (f a) -> s -> f s
20:37:16 <alphonse23_> what protobuf does: Once you've defined your messages, you run the protocol buffer compiler for your application's language on your .proto file to generate data access classes. These provide simple accessors for each field (like name() and set_name()) as well as methods to serialize/parse the whole structure to/from raw bytes – so, for instance, if your
20:37:16 <alphonse23_> chosen language is C++, running the compiler on the above example will generate a class called Person. You can then use this class in your application to populate, serialize, and retrieve Person protocol buffer messages. You might then write some code like this:
20:37:25 <hackrilege> ReinH, sure it does
20:37:32 <ReinH> Not in Haskell, at least.
20:37:45 <hackrilege> oh it defines snd.f
20:37:52 <alphonse23_> accessors, are they not a very OO way of thinking.
20:37:58 <pavonia> Usually there's a flag telling you which of the union's types should be used, but here ther's not
20:38:18 <ReinH> No, they are not.
20:38:22 <ReinH> structs have accessors.
20:38:26 <ReinH> scructs are not oop
20:38:32 <Welkin> lol
20:38:35 <alphonse23_> I mean, if they couldn't do it without lens, seems suspicious to me.
20:38:40 <ReinH> do what?
20:38:47 <ReinH> who is "they"?
20:38:51 <alphonse23_> google
20:38:57 <Welkin> I don't use lens
20:38:58 <ReinH> how do you know they couldn't?
20:39:02 <ReinH> they didn't
20:39:04 <Welkin> it's never necessary
20:39:06 <ReinH> that isn't the same as couldn't
20:39:06 <alphonse23_> they did
20:39:07 <Welkin> just a nice to have sometimes
20:39:20 <ReinH> perhaps they could have but chose not to
20:39:22 <alphonse23_> https://github.com/google/proto-lens they did it with lens
20:39:24 <hackrilege> so can i use this set upon with (!!)?
20:39:26 <alphonse23_> it's even in the libs name
20:39:26 <ReinH> Yes, I know they did
20:39:32 <ReinH> but that doesn't imply that they *had to*
20:39:39 <Welkin> google does a lot of dumb things
20:39:47 <ReinH> alphonse23_: you misunderstood me
20:40:02 <ReinH> by "they didn't", I meant "they didn't do it without lens"
20:40:07 <Welkin> they just add on to their bloated codebases all the time
20:40:21 <alphonse23_> thanks welkin
20:40:26 <hackrilege> what does that library even do?
20:40:34 <ReinH> hackrilege: it generates code for protobuf definitions
20:40:49 <hackrilege> ...
20:40:52 <hackrilege> awesome
20:41:21 <alphonse23_> hackrilege: its a boiler plate generator int their protobuf format for haskell https://developers.google.com/protocol-buffers/ that add accessors to haskell records
20:41:32 <ReinH> what
20:41:35 <hackrilege> hmm, this setter thing must be implementable in an easier way
20:41:41 <ReinH> it doesn't "add accessors to haskell records"
20:41:54 <ReinH> haskell records already have field accessors
20:42:11 <hackrilege> and it doesnt even target haskell, its just written in haskell
20:42:32 <ReinH> hackrilege: No, the haskell lib targets haskell
20:42:36 <alphonse23_> no i think it's for haskell and haskell like languages
20:42:36 <ReinH> and afaik protobuf isn't written in haskell
20:42:48 <ReinH> google doesn't even do much haskell afaik
20:43:04 <hackrilege> "Protocol buffers currently supports generated code in Java, Python, and C++. With our new proto3 language version, you can also work with Go, JavaNano, Ruby, and C#, with more languages to come."
20:43:10 <ReinH> what we're talking about is a haskell library that generates haskell code for protobuf definitions
20:43:18 <ReinH> protobuf is a standard
20:43:21 <ReinH> it has many implementations
20:43:22 <alphonse23_> that lib i linked to is not an official google product
20:43:35 <alphonse23_> so it's probably not gonna go up on their product page
20:43:35 <hackrilege> okok all this is quite an aside
20:44:03 <Welkin> Ook Ook?
20:44:15 <alphonse23_> I'm simply complaining that via their protocol their trying to turn haskell in to an OO language like java and c++
20:44:23 <hackrilege> the distinction of object orientation in Other languages is hardly a haskell topic
20:44:25 <ReinH> Welkin: I should read more pratchett.
20:44:30 <Welkin> who is going to write the protobuf api wrapper for Ook?
20:44:51 <hackrilege> did you get the number of that grocery cart?
20:44:54 <ReinH> alphonse23_: yes, and I am saying that that is ridiculous
20:44:59 <ReinH> it just generates records and lenses
20:45:01 <alphonse23_> maybe
20:45:03 <ReinH> plenty of libraries use records and lenses
20:45:03 <alphonse23_> could be
20:45:28 <Welkin> alphonse23_: was it you?
20:45:36 <alphonse23_> what do you mean>
20:45:38 <alphonse23_> ?
20:45:45 <Welkin> couldn't be
20:45:53 <Welkin> said who?
20:45:56 <hackrilege> lol
20:46:04 <ReinH> Not only does the library not in fact do that, it's ridiculous to think that google has some ulterior motive to change a language they basically don't even care about
20:46:13 <hackrilege> Welkin trolls forth
20:46:32 <hackrilege> i want ookies now
20:46:37 <ReinH> this is some sort of weird conspiracy theory
20:46:47 <ReinH> "google is trying to corrupt Haskell"
20:46:50 <alphonse23_> is that what it is, you think I'm being paranoid
20:47:02 <hackrilege> can i get some direction as to how these generic setters are implemented
20:47:14 <ReinH> hackrilege: which what?
20:47:23 <hackrilege> eg set upon snd
20:47:28 <ReinH> magic I guess
20:47:32 <hackrilege> !!!
20:47:36 <alphonse23_> I mean I'm not, and you just said it, google probably doesn't care. so hence my concern of turning haskell into an oo like lang, when it shouldn't be.
20:47:55 <ReinH> Well, if anyone tries I will let you know
20:48:07 <hackrilege> it cant need to be as involved as lens, were is the introductory material!?
20:48:12 <ReinH> also I think maybe the people who actually work on haskell might have something to say about that
20:48:21 <glguy> Yeah, that concern is nonesense.
20:48:31 <glguy> without the first e
20:48:38 <ReinH> either way really
20:48:50 <alphonse23_> k, I'm none sense, I'm okay with that though.
20:48:58 <glguy> hackrilege: upon is a side-show, it exists because it can but not because anyone should ever use it
20:49:00 <hackrilege> why shouldnt it be!? Types are like super awesome objects
20:49:14 <ReinH> No, they are nothing at all like super awesome objects
20:49:20 <alphonse23_> types are way differen't though
20:49:23 <ReinH> or any other kind of objects
20:49:31 <hackrilege> glguy, damn it was the closest id found to an application of the lens library
20:49:33 <alphonse23_> like, in java you can turn a int into an object
20:49:36 <alphonse23_> it's way different
20:49:58 <alphonse23_> I don't think types can be easily equated to objects
20:50:05 <hackrilege> hmm
20:50:06 <alphonse23_> that's nonsense 
20:50:30 <hackrilege> values are like objects i guess
20:50:40 <ReinH> No, again, they are not
20:50:41 <alphonse23_> no, and object is more like a container
20:50:52 <Clint> an object is like a burrito
20:50:53 <alphonse23_> a type is more like the primative values that a container holds
20:50:59 <ReinH> what
20:51:04 <ReinH> none of this is at all correct
20:51:33 <Welkin> primative values? You mean Ook?
20:51:34 <alphonse23_> wait, so am I wrong then, type != objects?
20:51:41 <ReinH> ...
20:51:43 <alphonse23_> can we agree on that?
20:51:47 <hackrilege> objects, can be created, have methods attached. ok so if you instantiate a class you get a bunch of methds, you make a value of that type and its like an object, as if it had a bunch of methods you could get to suffixing with a dot in java
20:52:01 <alphonse23_> the idea of an object in java/c++ is different from a type in haskell?
20:52:12 <ReinH> Yes, they are entirely different things.
20:52:23 <alphonse23_> k, good, we can agree on something
20:52:51 <ReinH> That seems like a good place to end it.
20:53:00 <hackrilege> but there is a wealth of transferable intuition
20:53:05 <ReinH> No, there really isn't.
20:53:10 <hackrilege> !!!
20:53:13 <hackrilege> abstract methods
20:53:16 <ReinH> In fact, trying to do so just messes up your haskell learnings
20:53:16 <hackrilege> boom
20:53:19 <ReinH> what
20:53:21 <ReinH> no
20:53:23 <hackrilege> yes
20:53:23 <ReinH> no boom
20:53:26 <alphonse23_> k, let me sit on it for a bit
20:53:29 <alphonse23_> but I will be back
20:53:45 <ReinH> trying to transfer oo intuitions into Haskell causes problems, it doesn't solve them
20:54:01 <alphonse23_> but see, like that's what protobuf is to me
20:54:25 <hackrilege> some people need that to make the leap, they say "where are my abstract methods" and then they find haskell classes have a reasonable interface to do basically what they want and they go aha, found it
20:54:45 <ReinH> what are abstract methods?
20:54:49 <hackrilege> exactly
20:54:55 <hackrilege> you dont even know what your talking about
20:54:58 <ReinH> what
20:55:00 <ReinH> that isn't a term
20:55:02 <ReinH> you just made it up
20:55:13 <hackrilege> https://www.google.co.uk/webhp?sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8#q=abstract%20methods
20:55:21 <ReinH> ok, methods on abstract classes?
20:55:31 <hackrilege> ohh so you do know
20:55:37 <ReinH> maybe instead of showing them where abstract methods are, you should just say "there are no methods".
20:55:41 <hackrilege> being pedantic is dumb
20:56:11 <ReinH> java =/= OOP
20:56:22 <hackrilege> thats my point. you could instead take the oppertunity to introduce them to somthing that bares reasonable resemblance which does what they need
20:56:28 <ReinH> It doesn't.
20:56:53 <ReinH> There are no abstract methods in Haskell. There are also no methods.
20:57:06 <ReinH> There are no objects, which are a prerequisite for having methods.
20:57:09 <hackrilege> i want to make a thing which i can write the functions of later = haskell class, abstract methods
20:58:26 <hackrilege> while there are no methods, there are functions yet to be defined, and while pedantic comparison finds that for some reason, these undesegnated values are not methods, it does no real harm to think of them as such
20:58:53 <ReinH> Ok, let's just agree to disagree.
20:58:55 <hackrilege> then you get a nice definition of what we think we Mean my object and method in haskell, and everyone is happy.
20:59:03 <ReinH> No, we don't, and no, they aren't.
20:59:05 <ReinH> Let's agree to disagree.
20:59:49 <hackrilege> i think your priorities are more long sighted and as an introduction, refusing to pander to existing intuition is just unhelpful
20:59:55 <ReinH> Ok.
20:59:58 <ReinH> Let's agree to disagree.
21:00:01 <hackrilege> k
21:00:25 <ReinH> Because I both strongly disagree and strongly don't want to keep arguing about it.
21:00:33 <hackrilege> i get it!
21:00:46 <hackrilege> did you see this? http://lpaste.net/176500
21:00:57 <hackrilege> its highly ill advised
21:01:02 <hackrilege> but i like it!
21:01:20 <hackrilege> what do you think?
21:04:24 <hackrilege> i promise if ever i mislead anyone into thinking haskell can be thought of in an object oriented context ill give the caveat that actually you cant.
21:04:39 <hackrilege> it cant*
21:05:51 <enthropy> hackrilege, have you seen https://github.com/nkaretnikov/OOHaskell-encodings
21:06:23 <hackrilege> sweeet
21:08:16 <hackrilege> thats helpful, it gives the things haskell hasnt been shown to provide that is OOP
21:10:09 <hackrilege> it says; "OOHaskell lends itself as a sandbox for typed OO language design"
21:10:19 <hackrilege> know any languages written using it?
21:14:21 <enthropy> no. I mean you can write haskell code using objects containing iorefs as that paper mostly describes
21:15:14 <enthropy> that's a pretty empty niche I think
21:19:41 <hackrilege> hmm, ok so the way i was trying to do that used UndecidableInstances which were overlapping all over the place. i guess i should figure out how i can do it properly
21:20:27 <hackrilege> the problem is in; instance (Cast a b,Cast b a) => Switch a b where
21:20:27 <hackrilege>  switch (Right a) = Left   (cast a)
21:20:27 <hackrilege>  switch (Left a)  = Right  (cast a)
21:20:32 <hackrilege> woah
21:20:33 <hackrilege> sorry
21:20:38 <hackrilege> clipboard error
21:20:56 <hackrilege> http://lpaste.net/176500
21:21:12 <hackrilege> i cant add the line;
21:21:13 <hackrilege> instance (Switch a b,Switch b c) => Switch a c where
21:21:37 <hackrilege> what is the correct way to do this?
21:21:46 <geekosaur> you'd have to use a newtype
21:22:00 <hackrilege> yeh!
21:22:03 <geekosaur> remember that the context plays no part in instance selection, so that instance overlaps *every* instance
21:22:10 <hackrilege> the i can write functor instances too
21:22:55 <geekosaur> as does the existing instance, so as far as ghc is concerned you have two different "instance Switch _ _ where"s
21:23:08 <hackrilege> i get the error
21:23:24 <hackrilege> i was just dismayed that my isomorphism ato composing thing wasnt going to work
21:24:00 <joe9> I have 2 ExceptT types with different e's . Is there any way I can join them using >>=?
21:24:10 <joe9> I can use withExceptT to convert e to e'
21:24:28 <joe9> In that manner, I would have e' to be a superset of e.
21:24:36 <hackrilege> basically if there exists a set of functions (which i guess should not contain cycles) which i can use to map from one function to another, i want just one super polymorphic function which can cast to that type to perform a function on it
21:24:46 <joe9> Just want to check if there is a better way of doing the composition.
21:24:56 <hackrilege> d you think with newtypes ill get this? or is there some mighty hurdle i cant see?
21:26:04 <hackrilege> have you seen this done before geekosuar, is it common or impossible?
21:27:15 <hackrilege> is there a better way to do it?
21:28:32 <hackrilege> like maybe even what joe9 said!
21:38:53 <jle`> joe9: you can also convert them to a comon e
21:39:41 <jle`> but yeah, the "merge them to a a common type" is a common haskell pattern
21:39:53 <jle`> called the Functor Design Pattern by Tekmo
21:48:57 <joe9> jle`: "merge them to a common e" -- using a type class?
21:49:48 <jle`> using a natural transformation
21:50:13 <jle`> like foo :: EitherT e m a -> EitherT g m a
21:50:23 <jle`> and bar :: EitherT f m a -> EitherT g m a
21:50:54 <joe9> jle`:  Thanks for your response. and g is a superset of both e and f. correct?
21:51:02 <jle`> maybe, or something sensible
21:51:07 <jle`> depending on your application
21:52:09 <joe9> jle' what do you mean by "sensible"? please. Is there a better way of doing that? everytime I have a new e or f, the definition of g has to change.
21:52:27 <joe9> jle`: sorry for bothering you. I am just trying to understand.
21:52:41 <jle`> joe9: it depends on what you want to do with it in the end
21:53:12 <jle`> whatever "g" error type is most useful to you in your situation
21:53:21 <jle`> it doesn't have to be able to completely subsmue all of e or all of f
21:56:46 <jle`> for example if you want to combine an Either String a and an Either Int a, you might want to just turn it into an Either Bool a giving where the source of the error was and ignoring the contents
21:56:55 <jle`> if the contents don't matter to you and the source does
21:57:14 <eklavya> glguy: found this! https://wiki.haskell.org/Phantom_type
21:57:25 <eklavya> I think I will get Tagged now :P
21:57:41 <jchia_> how come Monoid is not a subclass of Semigroup? mappend seems more verbose than (<>). How come mconcat is defined for [a] instead of Foldable a?
21:58:03 <jchia_> is it just historical reasons?
21:58:10 <dramforever> Historical reasons obviously
21:58:15 <jle`> historical reasons
21:58:23 <jchia_> are they going to fix the irregularity?
21:58:27 <ReinH> hysterical raisins
21:58:28 <jle`> well, mconcat is a different story, i think
21:58:31 <dramforever> Monoid is in base but Semigroup was long outside in a separate ekmett package
21:58:46 <ReinH> `fold' exists
21:58:52 <dramforever> :t fold -- jchia_: mconcat?
21:58:54 <lambdabot> (Foldable t, Monoid m) => t m -> m
21:59:09 <jle`> mconcat is a part of the Monoid typeclass itself for instances to provide specialized definitions for lists
21:59:15 <jle`> lists-of-them
21:59:24 <jchia_> OK, fold does what mconcat does more generally
21:59:29 <jle`> so in a way its monomorphism is its entire point
22:00:36 <dramforever> :t (<>) -- Let's see which one we have
22:00:37 <lambdabot> Monoid m => m -> m -> m
22:00:45 <joe9> Any opinion on this package http://hackage.haskell.org/package/explicit-exception recommended or obsolete?
22:01:37 <jchia_> Are they going to make Monoid a subclass of Semigroup? <> is concise but can only be used on Semigroups.
22:01:57 <ReinH> Only if Semigroup makes it into base
22:02:03 <ReinH> <> is also on Monoid
22:02:11 <dramforever> :t (<>) -- Not if you use Data.Monoid.<>
22:02:13 <lambdabot> Monoid m => m -> m -> m
22:02:47 <ReinH> It seems reasonable to put Semigroup in base, but I don't know if there are plans to do so
22:05:58 <dramforever> Whee we already have -Wmonoid-semigroup obviously
22:06:32 <dramforever> No not under that name
22:07:54 <dramforever> jchia_: Looks like we *are* moving in that direction already https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid
22:13:52 <jchia_> cool
22:20:36 <solrize> semigroups don't necessarily have zero
22:20:39 <solrize> so they're not monoids
22:21:06 <solrize> oh ic further up, make monoid a subclass of semigroup
22:21:11 <solrize> that's better
22:30:21 <eklavya> is the llvm backend faster, is it the default, if it's not, why not and should I use it for production?
22:47:00 <cocreature> eklavya: it is definitly slower during compilation since it duplicates some of the work that GHC does. I think there is no exact answer as to whether the generated code is faster, but I have at least seen a few examples where it is significantly faster and I don’t think I have seen significant slowdowns. I can’t judge if it is reasonable to use it for production
22:47:18 <dysfun> they're gone :)
22:48:07 <cocreature> oh damnit
23:12:44 <saurabhnanda> has anyone successfully installed GHCJS with stack LTS 6.6 and GHC-7.10.3?
