00:06:52 <paolino> iterate has no case matching, I will keep that, but I guess I miss some recursion schema that express that :-)
00:07:28 <paolino> > snd . last . takeWhile ((/=0) . snd) . iterate (\(n,m) -> (m,rem n m)) $ (48,56)
00:07:30 <lambdabot>  8
00:09:08 <cocreature> is there a list of ghc versions and the versions of packages that are shipped with it?
00:09:30 <cocreature> ofc I can download the ghc releases I’m interested in and check for myself but that’s not that convenient :)
00:12:26 <alar> Greetings! I'm looking for teammates to write IFCPC with
00:15:33 <paolino> IFCPC ?
00:15:53 <alar> icfpcontest.org
00:20:27 <paolino> not sure to have the points to partecipate, that should be hard on algorithmics I guess
00:21:36 <alar> it can be anything
00:22:04 <alar> battle of robots, solving puzzles, even booooring computational tasks
00:22:36 <sdx23> how time intensive is it usually?
00:23:29 <rydgel> Hi, do you guys have any example of a good API wrapper made in Haskell?
00:23:40 <rydgel> I'm struggling to find the right abstraction
00:23:57 <sdx23> rydgel: of what?
00:24:23 <rydgel> I want to make a Discord API wrapper
00:24:42 <rydgel> Not sure if I should use MonadIO, or more advanced stuff
00:24:49 <paolino> alar, how do you plan the interaction between teammates ?
00:25:26 <rydgel> like ReaderT for reading config
00:26:41 <alar> I don't have teammates yet :)
00:27:02 <rydgel> So I wanted to know if you guys know about a lib you love to use because it's well designed
00:28:36 <paolino> alar, have you already had an experience on this ?
00:28:59 <sdx23> rydgel: this is rest right? there's a package for that on which you could build (though that's not exactly what you asked for)
00:30:05 <paolino> alar, I was wondering on how it's set up to cooperate 
00:30:07 <rydgel> sdx23: REST yes, and a part with websocket
00:36:56 <alar> teams set it up as it wishes
00:37:20 <alar> some friends of mine write OCFPC being in the same house
00:37:28 <alar> ICFPC
00:37:40 <alar> some use voicechats
00:58:31 <osager> how to generate x number of UUIDs with each run of the program?
00:58:48 <osager> i know about the uuid library
00:59:12 <osager> but havnt figured out the quick short example yet
01:02:25 <sdx23> osager: UUID has a Random instance. So it's the same as you'd do to get x number of random Ints.
01:04:01 <osager> sdx23, thanks. then what's the point of using uuid library ?
01:05:46 <sdx23> osager: You don't have to implement all the stuff again? It's conforming to RFC and provides conversion functions.
01:09:24 <sdx23> osager: depending on what you want to do, (e.g. if it's only used internally and never visible "outside") the only advantage may be that it's clear from the type what it is.
01:11:16 <osager> sdx23, i think it also generate hash code
01:18:33 <cocreature> hvr: does multi-ghc-travis support projects that consist of multiple cabal projects or do I need to hack around that myself?
01:32:49 <cocreature> ah there is a new-build version, it should be reasonably easy to hack it in there
01:45:13 <marrrk> Hello! Is there a library that reads epubs?
01:45:32 <M-ou-se> i'm looking for something like 'ghci --something "print 123"' that just runs that code and exits. like 'python -c "print(123)"' does. is there a flag or tool that does that?
01:46:26 <dramforever> ghc -e IIRC
01:46:57 <M-ou-se> :D awesome. i've been searching for quite a while, but couldn't find it. thanks!
02:02:54 <MasseR> marrrk: pandoc possibly
02:02:58 <MasseR> at least it writes epubs
02:03:19 <marrrk> I would like to get the content of an epub and turn it into split emails.
02:03:47 <MasseR> https://hackage.haskell.org/package/pandoc-1.17.2/docs/Text-Pandoc-Readers-EPUB.html
02:08:56 <marrrk> thanks
02:12:22 <{AS}> Has anybody tried QuickSpec?
02:15:23 <tsahyt> I'm trying to do some profiling using perf, and that requires usage of --disable-library-stripping with cabal. Is there a way to pass cabal arguments through stack?
02:30:43 <orion> Would it be accurate to say that try/catch can only be used in IO?
02:33:50 <ReinH> marrrk: fwiw, epub files are basically just zip files containing xhtml (and sometimes images)
02:39:50 <gargawel> Using MonadBaseControl, what would be the correct way to lift a function of type:: IO a -> IO (T a)  to m a -> m (T a) ? (with MonadBaseControl IO m)
02:40:41 <gargawel> (case in point: async function from the async-pool package)
02:40:41 <tsahyt> are symbols created by GHC deterministic? i.e. does it use the same symbols when compiling the same code twice?
03:02:21 <tsahyt> do the list fusion rules fire across a let binding? say I have let xs1 = someproducer; xs2 = foldr f foo xs1.
03:13:56 <jophish> It's annoying that I can't DeriveFunctor for something like data Foo a = Foo (a, a)
03:14:23 <jophish> and no existing deriveFunctor TH seems to be up to it
03:14:56 <jophish> it's so tedious to write functor/foldable/traversable by hand
03:15:00 <ReinH> jophish: Why not use data Foo a = Foo a a instead?
03:15:45 <jophish> ReinH: well, my actual data type is a little more complex
03:16:32 <ReinH> You only need to derive Traversable yourself.
03:17:37 <ReinH> Functor and Foldable can use fmapDefault and foldMapDefault, respectively.
03:17:51 <ReinH> s/derive/write
03:19:36 <ReinH> For the case you gave, GHC can't derive them because of the tuple, which is most likely unnecessary indirection anyway.
03:20:37 <cocreature> is there some special option for setting the path to g++? I thought just using --with-gcc would work as ghc somehow does magic and compiles c++ using gcc, but I run into "unrecognized command line option ‘-std=c++11’" even though I’m using gcc-5.4 which should have this option
03:31:14 <malice`> Hello! I would like to see how is !! implemented in haskell ghc; any idea where can I find it?
03:31:32 <cocreature> malice`: https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.List.html#%21%21
03:31:56 <cocreature> malice`: there are source links in the haddock at the right https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#v:-33--33-
03:32:34 <malice`> Thank you very much :)
03:36:22 <volkand> Hello everybody, I am newbie :)
03:37:52 <Boomerang> Hello volkand :)
03:39:24 <volkand> Hello
03:40:34 <volkand> I need a resource
03:40:59 <volkand> I want to work haskell.
03:43:31 <meditans> In the middle of preprocessing a file to strip it from cpp annotations with the ghc pipeline, I arrive at a file like this http://lpaste.net/174086 Basically it's the preprocessed file, plus some weird annotations and a ton of whitespace. Could someone explain to me where do they come from?
03:47:47 <zyla> meditans: the annotations are emitted by CPP
03:48:27 <zyla> try running 'echo test | cpp'
03:49:38 <meditans> zyla: oh, I see, thanks! So, that's the lines that begin with #. Does cpp also emit blank lines, or do they come from another point in the preprocessing?
03:50:06 <zyla> the blank lines are probably to maintain line numbers
03:50:31 <zyla> for example, #defines will not be removed completely, but replaced by blank lines
03:50:50 <meditans> zyla: no, the point is exactly that: I'd like to mantain the line numbers and the huge volume of blank lines offsets that
03:51:08 <meditans> zyla: you're right that the lines in the file are substituted by blank lines
03:51:38 <meditans> but there is a huge amount of lines at the top of that file, and those do not correspond to previous cpp directives
03:52:33 <meditans> so, if cpp emits blank lines _only_ to preserve line numbers, it's actually better, but I have to find where those are generated
03:52:37 <zyla> yes, but they can correspond to directives in the included fules
03:52:40 <zyla> files*
03:53:38 <zyla> hm, my cpp is actually smarter and doesn't emit chunks of blank lines
03:53:56 <meditans> zyla: oh, I see. So basically the files are concatenated before preprocessing, right? Do you know of any smart way to get rid of the extra lines to mantain indentation?
03:54:00 <zyla> Instead it advances the line number and emits another #-annotation
03:55:02 <zyla> meditans: yes, when cpp sees #include it just spits out the contents
03:55:12 <matrium_> hi, can't the compiler infer that a = Word8 for http://lpaste.net/174097 ?
03:55:23 <zyla> Or rather preprocesses the file recursively
03:56:02 <merijn> matrium_: You're type says it can return any integral
03:56:06 <zyla> matrium_: because `a` is a type parameter
03:56:23 <merijn> matrium_: But "getWord8" only returns a Word8, so you're type is lying about what your function does
03:56:54 <matrium_> and how to express that it can either return Word8 or Word16?
03:57:23 <merijn> You can't, you have to pick one type too return and return that
03:57:40 <zyla> Or use dependent types
03:58:40 <zyla> meditans: Why do you want to get rid of these lines?
03:58:59 <matrium_> hmm, ok. I'm reading samples from a binary file and it depends on the file header weather the samples are Word8 oder Word16
03:59:43 <meditans> zyla: I'd like to get the source of a generic haskell module without cpp, so that I can then use tools like haskell-src-exts to do some static analysis
03:59:53 <matrium_> so all my processing methods must be able to deal with both kinds
04:00:11 <meditans> zyla: in the meantime, I found https://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html which explains the syntax of the output I'm getting
04:00:49 <meditans> so I may be able to correct the problem using these (we'll see)
04:01:01 <matrium_> so how would I model that? have an sample GADT and define a Num type instance?
04:02:31 <merijn> matrium_: Or convert them to another type in both branches
04:03:24 <matrium_> the thing is that I have to depend on correct type overflow while processing
04:04:01 <matrium_> first I simply used int, but it won't overflow correctly for the defined arithmetics
04:04:30 <merijn> So convert to an unsigned type?
04:05:08 <matrium_> thing that still has the problem that 0 - 1 :: Word8 != 0 - 1 :: Word16
04:07:52 <zyla> matrium_: You can have a SampleType GADT, parameterized by the actual Haskell sample type
04:08:16 <ertesx> matrium_: is that using the cereal library?
04:08:53 <matrium_> ertesx: no
04:09:51 <ertesx> matrium_: is that using any of the libraries that provide the Get type?
04:11:09 <matrium_> I'm using "Data.Binary.Get" of "binary"
04:11:36 <ertesx> matrium_: it doesn't mind you returning Either Word8 Word16 (or a custom type, if you prefer)
04:12:49 <ertesx> even as part of a Binary instance, if you're writing one, as long as you make sure that the encoder and decoder are mutually inverse
04:13:46 <ertesx> matrium_: alternatively you could stretch the Word8 to a Word16
04:14:01 <ertesx> > fromIntegral (250 :: Word8) :: Word16
04:14:03 <lambdabot>  250
04:14:13 <ertesx> > fromIntegral (250 :: Int8) :: Int16
04:14:15 <lambdabot>  -6
04:14:24 <ertesx> if you care about sign, don't word Word* to begin with
04:15:14 <ertesx> s/word/use/
05:22:26 <yyyyy> anyone knows if there's a way to reuse “default extensions” sections between parts of a cabal file — say, between two executables.
05:22:58 <yyyyy> as in a defaults setting
05:26:24 <merijn> yyyyy: Reuse suggest you're asking because you have a lot of them, which raises the question: Why do you have a lot of them?
05:37:20 * hackagebot nanovg 0.5.0.0 - Haskell bindings for nanovg  https://hackage.haskell.org/package/nanovg-0.5.0.0 (cocreature)
05:53:20 <matrium_> why isn there an uncurry3, ... uncurry10?
05:59:10 <geekosaur> because tuples are usually the wrong way to do things. note that you can achieve the same effect with zipWith* (although only up to 7) or via Applicative (no limit)
06:10:36 <hpc> also tuples only go up to 62 anyway
06:10:42 <hpc> "only"
06:13:52 <orion> Tuples are the wrong way to do which things?
06:14:03 <hpc> most things
06:15:05 <orion> Then why do we have Arrows?
06:15:08 <merijn> 63, I think? :p
06:15:52 <mniip> 62
06:15:53 <hpc> Arrow was intended to be an API for arbitrary computation on top of Category
06:16:09 <hpc> but the addition of arr made it very weak
06:17:53 <hpc> the tuple-y operations in Arrow were a tool to make that "arbitrary" bit possible, and it makes sense there as there's not really a sensible data type you can define for that
06:28:16 <angryShiva> hello?
06:28:27 <Shou> Hey.
06:32:03 <ertesx> orion: the real question is: why do we have tuples in Arrow?
06:32:31 <Cale> ertesx: Arrow is very close to the definition of a symmetric monoidal category. It's just that 'arr' is taking the place of a bunch of data those usually come equipped with.
06:33:19 <ertesx> Cale: sure…  i just wanted to reinforce the notion that tuples are almost always bad =)
06:33:25 <Cale> bad?
06:33:37 <ertesx> "the wrong way to do things"
06:33:41 <angryShiva> :O
06:33:41 <av_> hello chaps, I really love ":t" of ghci, but it seems it works on top-level definitions only -- is there a way of asking ghci for the type of a definition inside another ?(let or while)?
06:33:42 <Cale> hm
06:33:58 <Cale> I don't know, categorically, products seem pretty important to me.
06:33:59 <angryShiva> tuples arn't bad - they're pretty handy!
06:34:18 <Cale> I would rather say that tuples are fundamental.
06:34:18 <angryShiva> why do you think they're bad?
06:34:24 <ertesx> av_: yes, use typed holes, i.e. unbound identifiers beginning with an underscore
06:34:50 <hpc> :t let x = Just <*> id <*> "bananas?" in x
06:34:51 <lambdabot>     Couldn't match expected type ‘[a0 -> Char -> b1]’
06:34:52 <lambdabot>                 with actual type ‘a1 -> Maybe a1’
06:34:52 <lambdabot>     Relevant bindings include x :: [b1] (bound at <interactive>:1:5)
06:34:56 <ertesx> av_: try this:  f x = x + _y  -- GHC will tell you that it doesn't know _y and what type it thinks it should have
06:34:58 <hpc> :t let x = Just <$> id <*> "bananas?" in x
06:35:00 <lambdabot>     Couldn't match type ‘Maybe a0’ with ‘Char -> b1’
06:35:00 <lambdabot>     Expected type: a0 -> Char -> b1
06:35:00 <lambdabot>       Actual type: a0 -> Maybe a0
06:35:10 <hpc> well, like that anyway
06:35:50 <hpc> Cale: they're fundamental and theoretically useful, but it's easy to misuse them
06:35:55 <av_> ertesx: fabulous, thanks.  I love how every time I enter this channel I learn something new. :)
06:36:13 <angryShiva> huh. what do you know
06:36:17 <hpc> Cale: compare with using a huge chain of Eithers instead of writing a custom enum, which people are generally better about not doing
06:36:54 <Cale> hpc: Well, sure, but when we're talking about the structure that Arrow is meant to express, there isn't a better thing to use than pairs
06:36:59 <ertesx> Cale: they take the same place as stuff like Product or other functors-a-la-carte for me…  i try to avoid them in practice
06:37:08 <ertesx> rarely i'd like to use them directly
06:37:24 * hackagebot servant-auth-token 0.1.1.0 - Servant based API and server for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-0.1.1.0 (NCrashed)
06:37:29 <Cale> I'm not saying you wouldn't want to build some better notational device on top :)
06:38:15 <ertesx> av_: my pleasure =)
06:38:34 <Cale> But the basic idea of Arrow is to make the wiring together of computations explicit. It fails in this to some degree due to lacking a handful more explicit operations manipulating pairings
06:38:53 <Cale> But something very close to Arrow can be quite effective in that regard.
06:39:10 <ertesx> something that probably doesn't involve (,) =)
06:39:46 <Cale> In particular, the things which are missing are the associators and unitors, and the commutator for (,)
06:39:59 <Cale> you want both directions of all those isomorphisms
06:40:23 <mniip> 1470317820 [16:37:00] 18<hpc> Cale: compare with using a huge chain of Eithers instead of writing a custom enum, which people are generally better about not doing
06:40:39 <angryShiva> @Cale, what are you talking about? Kinda lost, would appreciate some help
06:40:39 <lambdabot> Unknown command, try @list
06:41:12 <mniip> (&&&) :: (Arrow a, Limit (Empty :: Bool) (->) (PairFunctor c c') d) => a b c -> a b c' -> a b d
06:41:30 <mniip> err
06:41:38 <mniip> (Empty :: Bool -> Bool -> *)
06:41:47 <Cale> assocL :: a (x,(y,z)) ((x,y),z), assocR :: a ((x,y),z) (x,(y,z)), swap :: a (x,y) (y,x), unitL :: a x ((),x), unitR :: a x (x,()), retractL :: a ((),x) x, retractR :: a (x,()) x
06:41:50 <Cale> ^^ that stuff
06:42:25 <mniip> Cale, the natural isomorphisms of the monoidal category (Hask, (,)) ?
06:42:28 <Cale> yeah
06:42:46 <Cale> well, of a monoidal category internal to it
06:42:51 <eklavya> do I need to install cabal or I can I do the "hackage upload precheck" using stack?
06:43:04 <Cale> Maybe you also want to generalise (,) to some arbitrary bifunctor
06:43:15 <Cale> But usually it's going to be (,) anyway :P
06:43:16 <mniip> I did up there with my product limit :p
06:57:41 <danilo2> Hello! Is there any syntax suger in Haskell to write (Proxy :: Proxy t)? I was originnally hoping that the new @-sugar in GHC8 would allow it by translating @t into (Proxy :: Proxy t). Unfortunatelly it works other way around (which doesnt eliminate the needs of Proxies) and writing often the full form is not readable and could be improved
06:58:41 <yyyyy> merijn: i use them frequently. about 10 of them are indispensable for everything i do. some 21 others are frequent enough that warrant usage. i don't use anything other than GHC, so i don't mind enabling it always.
07:00:59 <yyyyy> ScopedTypeVariables, FlexibleInstances, TypeOperators, MultiParamTypeClasses, RankNTypes, DataKinds, GADTSyntax, LambdaCase, MultiWayIf, Overloaded(…), PartialTypeSignatures, FunctionalDependencies, RecordWildcards etc etc etc
07:01:21 <merijn> yyyyy: My objection to default signatures is that when I open a random file in your project I know need to remember checking your cabal file for which extensions are enabled, instead of looking at the top
07:01:36 <merijn> eh
07:01:44 <merijn> default extensions, not default signatures :)
07:01:58 <yyyyy> merijn: ah, but those are for internal projects, where they're more or less standard.
07:02:05 <yyyyy> we have an internal prelude as well.
07:02:15 <yyyyy> i wouldn't publish something on hackage with this.
07:02:26 <yyyyy> (in this case it's better to be more explicit imo)
07:02:32 <merijn> But anyway, no, I don't think there's a way to share default extensions between libraries/binaries
07:03:11 <yyyyy> sad times :/
07:03:28 <yyyyy> it's not the end of the world, but it does add noise to each target
07:03:53 <yyyyy> i guess i could simply disable all of them and wait for the errors, re-enabling for each target those in use
07:09:56 <mniip> danilo2, I think you can say 'Proxy@t'
07:10:38 <mniip> the API you're using will need to be adapted to visble type application
07:10:49 <mniip> possibly with use of AllowAmbiguousTypes
07:12:43 <danilo2> mniip: nope, I can say `Proxy @t` - there have to be space before @
07:13:29 <danilo2> mniip: anyway yeah, its still long :/ I'd love to see somethin really short, like `@Int === Proxy :: Proxy Int`. Anyway, I think it is impossible to define by our own such syntax currently
07:14:19 <mniip> but that
07:14:25 <mniip> 's not the point of @
07:15:19 <mniip> you could have foo :: (C a b c, D e f) => g -> h
07:15:38 <mniip> and while in usual haskell it would be ambiguous in any use site, with @ you could write
07:15:45 <mniip> foo @A @B @C @D @E @F @G @H
07:15:59 <Cale> C and D aren't variables there
07:16:08 <Cale> er
07:16:15 <Cale> no just d :)
07:16:35 <mniip> oops
07:16:37 <mniip> -@D
07:17:07 <danilo2> mniip: I know, bu t Icannot define `class Foo a where foo :: Int -> Bar a` (Bar is NOT injective) - because GHC will reject it
07:18:01 <danilo2> mniip: and then I have to use Proxy. I'd love to trow Proxy away and use such definition and use it like `foo @X` 
07:18:07 <mniip> danilo2, AllowAmbiguousTypes
07:18:42 <danilo2> mniip: hmm, interesting. Is AllowAmbigous types safe in such use cases?
07:19:08 <mniip> it isn't unsafe per se
07:19:12 <danilo2> mniip: additional - does it affect performance in any way ? (I think no, but internals can surprise often)
07:19:15 <mniip> just will lead to confusing errors if misused
07:20:09 <danilo2> mniip: What is the general state of the mind - of Haskell community? It is better to write `class Foo a where foo :: Proxy a -> Int -> Bar a` or `class Foo a where foo :: Int -> Bar a` (with AllowAmbigousTypes) ? 
07:20:30 <mniip> type application is fairly new
07:20:38 <mniip> I don't thin consensus has reached a quasistatic state yet
07:21:04 <danilo2> mniip: right. Thank you :)
07:23:26 <mniip> on a related note, is it possible to express in a superclass constraint on f that 'C a (f a)' holds for any a
07:24:03 <mniip> i.e I'm looking for something like class Foo a (f a) => Bar f
07:24:32 <dolio> Not directly.
07:25:27 <Drezil> o/ i need some help with constrains on rewrite rules for recycling and monadic stream fusion. anyone got experience with that?
07:27:23 <Drezil> https://github.com/Drezil/subhask/blob/ghc8.0-indexed_update/src/SubHask/Algebra/Vector/RMStreams.hs#L85-L86 won't compile with error http://lpaste.net/174113
07:27:28 <dolio> data F f a where Foo a (f a) => F ; class AFoo f where aFoo :: F f a ; class AFoo f => Bar f ...
07:27:49 <danilo2> mniip: Right. By the way - does using allowAmbigous types as I shown above will decrease performacne in any way or the compiled code would run as fast as when using Proxy ?
07:28:09 <Drezil> thing is that i KNOW that s0~s and s1~s .. but i don't know how to write those constraints into the rewrite-rule..
07:33:08 <OutlawStar> question, if i have a type (data Key t = ...) where t is a data kind, is there a way to pattern match on 't' so that I can have for example "show :: Key t -> String" and then for each t output a different string?
07:34:04 <danilo2> OutlawStar: yes, using TypeClasses ;)
07:34:23 <Drezil> hmm.. noone here who can help me?
07:34:55 <Drezil> maybe i should write that question to SO .. :)
07:35:03 <OutlawStar> danilo2: That doesn't exactly work, it would be for example instance Show (Key t), but how do I differentiate on t?
07:35:11 <mniip> dolio, noted
07:36:06 <mniip> Drezil, it's whining about ambiguous type variables
07:36:29 <mniip> which basically means it can't know what instance to use at use site
07:36:42 <danilo2> OutlawStar: either by writing `instance Show (Key A)` (etc for every type) or `instance Repr (Key t) => Show (Key t) where show = ("oh" <>) . repr` and make such instances for Repr
07:38:08 <OutlawStar> danilo2: I have an instance for every permutation of (Key t), but if for example i then create "foo :: Key t -> String" where "foo = show", thats does not type check
07:39:17 <danilo2> OutlawStar: show me tho code with an minial example please :)
07:39:30 <OutlawStar> k sec
07:39:37 <danilo2> OutlawStar: take your time :)
07:42:21 <ertesx> danilo2: when you want to write (Proxy :: Proxy a), sometimes it helps that Proxy is an Applicative:  if (x :: a), then (pure x :: Proxy a)
07:43:01 <ertesx> danilo2: but that doesn't always help, because many proxy consumers are polymorphic in the proxy type itself:  myConsumer :: proxy n -> X
07:43:09 <danilo2> ertesx: cool observation
07:43:43 <danilo2> ertesx: yep, but I've never though about it. It could be sometimes very useful, thanks! :)
07:43:58 <ertesx> you're welcome
07:44:27 <vin-ivar> hi spaceghost 
07:44:48 <Drezil> mniip: yes. i know. and i know that they should not be ambigious in that rule. and that i need to add a constraint stating that s0 ~ s. But HOW?
07:45:03 <mniip> that's not a constraint that you add
07:45:36 <spaceghost> Hello vin-ivar.
07:45:37 <OutlawStar> danilo2: http://lpaste.net/2320716450894970880
07:45:40 <spaceghost> What am i loosing?
07:45:52 <vin-ivar> the ability to say things
07:45:55 <Drezil> mniip: ?
07:46:19 <OutlawStar> beaware, that my example in channel was a little different. That is actual code and I am using Store instead of Show
07:46:56 <Eduard_Munteanu> Does some extension provide qualified exports?
07:46:59 <Drezil> mniip: can you elaborate?
07:47:06 <OutlawStar> danilo2: Line 29 is the issue, gives Coudl no deduce (Store (Key t))
07:47:46 <danilo2> OutlawStar: add `Store (Key t)` to constraints
07:48:55 <OutlawStar> danilo2: "facepalm"
07:48:56 <danilo2> OutlawStar: Haskell cannot deduce that you've created all possible isntances for every `t`. In fact you can later add another mathcing t` so such rule tyou have to add to constraints
07:49:12 <danilo2> OutlawStar: :)
07:49:19 <OutlawStar> thx
07:50:57 <OutlawStar> danilo2: What do you mean by ur last statement?
07:52:05 <danilo2> OutlawStar: I thought that you assumed that Haskell will ifer that this constraint is met for every possible `t` and because of that you havent written it.
07:52:42 <OutlawStar> danilo2: I was hoping, but that does not seem to be the case, is there a way to enforce that?
07:53:31 <c_wraith> Nope.  Not even in obvious cases, like everything of kind Nat having a KnownNat instance.
07:54:19 <danilo2> OutlawStar: you can "hide" it by making it a superclass of a class you are using or using some tricks ith closed type families. Other methods do not allow you to tell Haskell you are working on a finite set of types 
07:55:01 <c_wraith> It turns out that the instance constraint is used as an extra argument in GHC's compilation model.  If you don't have the constraint present, it doesn't know how to pass the dictionary required.
07:55:06 <OutlawStar> danilo2: :( O well, It will all be locked down to one module, so it shoudl be somewhat locked own
07:55:51 <OutlawStar> c_wraith: are you saying there is a compiler option for it?
07:56:19 <Eduard_Munteanu> What happens for concrete types, though?
07:56:45 <c_wraith> no. I'm saying that making "obvious" instances implicit would break the way ghc works. 
07:56:53 <OutlawStar> ah
07:58:22 <Eduard_Munteanu> e.g. you don't need the constraint in Num Bool => Bool -> Bool -> Bool
07:58:59 <Drezil> mniip: seems like adding a phantom-typeparameter helped resolve that constraint as i now have a way to express s0 ~ s :)
07:59:06 <OutlawStar> yup, can't see how a flag like tha twould work without some sort of pragma
07:59:54 <Drezil> oh.. now i get a "ghc: panic! (the 'impossible' happened)" :)
08:09:39 <bjs> Drezil: if you enable enough extensions anything is possible
08:11:09 <zomg> everything is possible with Acme.Zombo
08:13:58 <dabd> How can I fold over a sequence of functions [f1, f2, ... fn] applying each fn and "exit" early as soon as a function returns some given value? 
08:14:37 <ongy> dabd: that sound weird, what are you trying to do?
08:14:46 <ongy> if you have the output already, why run the functions?
08:14:52 <janos_p> maybe build a recursive function with guards?
08:15:10 <dabd> I don't have the output f1, f2 are the functions to be called
08:15:12 <dolio> What happens to the values before the one you're looking for?
08:15:13 <dabd> evaluated
08:15:40 <dabd> I just keep the value and pass it to the next function in the sequence
08:15:44 <janos_p> function (f:fs) x = if f x == 10 then 10 else function fs x 
08:15:47 <bjs> dabd: then how will you know when to stop if you don't have the output?
08:16:08 <janos_p> or something like that :)
08:16:15 <bjs> (since the output will just be the last function's value?)
08:16:21 <dabd> I will have the output because on each step of the fold I am calling each function fn
08:16:45 <dabd> In other words my problem is how do I fold and exit early on some condition
08:16:51 <dolio> Are you building a list of all the results or something?
08:16:59 <dolio> Or just feeding it forward?
08:17:06 <janos_p> couldn't that be computed in parallel with async and kill all threads as soon one function returns the desired value?
08:17:07 <dabd> I am just feeding forward
08:17:18 <dabd> each function is an endomorphism F: A -> A
08:17:27 <dabd> f: A -> A
08:17:40 <dolio> What happens if you never see the value you're looking for?
08:18:31 <dabd> ok, forget my initial statement. I just want to learn how can I fold and exit early as soon as some condition is met
08:19:01 <dolio> If it's foldr, you just don't use the second argument of the binary operation.
08:19:03 <c_wraith> foldr exits early implicitly. 
08:19:13 <dolio> If it's foldl, you don't exit early.
08:19:50 <c_wraith> ie, when the function being folded doesn't force it's second argument, foldr is complete without considering the rest of the list. 
08:19:57 <c_wraith> *its
08:20:03 <dabd> foldr then seems to be the answer
08:20:18 <bjs> dabd: so either, utilise laziness and just don't look at the second argument once the conidtion is met or look at the source of foldr and create a new one with a conditional recursive call
08:20:40 <c_wraith> but you need to be clever here. the fold is going to need to create a function. 
08:21:03 <dislongusername> Hello everyone! nice to be here:)
08:21:12 <c_wraith> it isn't that hard, but if you're unfamiliar it's very different. 
08:21:31 <dabd> bjs: this is helpful. Actually I am trying to do this in Scala, but I couldn't get a clear answer about how I can achieve this
08:21:50 <c_wraith> Scala is totally different, due to lack of laziness 
08:21:52 <bjs> dabd: oh okay then foldr won't work haha
08:22:07 <ongy> is scala non strict?
08:22:13 <dabd> I am using a functional library for scala called scalaz which has a lazy foldr
08:23:35 <bjs> ongy: i think scala can do call-by-name stuff, but it's not a haskell style call-by-need iiuc
08:26:39 <DrSpatula> question:  If I define f :: Num a => a, why doesn't f = 1.0 typecheck if Fractional is a "subclass" of Num?
08:27:13 <liste> DrSpatula: because f should be *any* Num
08:27:44 <liste> it should make sense in any context a Num is wanted
08:28:08 <DrSpatula> got it now, I was thinking of f as a value, not as a function
08:28:15 <DrSpatula> makes complete sense now, thank you
08:29:08 <Shou> dabd: you might be able to use monads http://stackoverflow.com/a/21239547/1692268
08:34:04 <c_wraith> dabd: http://lpaste.net/174131  That exits early, in my testing
08:34:08 <erisco> bump this up please http://stackoverflow.com/questions/38743576/write-f-in-pointfree-style/38771680#38771680
08:35:08 <c_wraith> erisco: did you really just ask for people to upvote your answer?  That's sorta tacky, even if it is a good answer. :)
08:35:17 <glguy> #haskell isn't for requesting votes on stack overflow
08:35:22 <dabd> thanks everyone
08:35:45 <c_wraith> dabd: So..  My solution depends on foldr being properly lazy.  And it's also.. weird. :)
08:36:01 <liste> IMO the accepted answer is more educational
08:39:01 <erisco> c_wraith, I am practicing shamelessness ;)
08:39:10 <glguy> No, you're spamming #haskell
08:39:39 <erisco> I've given this answer quite a few times now and I'm just trying to get the knowledge out there
08:43:44 <infandum> Is there a function like "maybe" but for bool? Like, doBool boolean (+ 1) (- 3)?
08:43:53 <erisco> :t bool -- infandum
08:43:54 <lambdabot> a -> a -> Bool -> a
08:44:16 <c_wraith> did that get added to Data.Bool yet? 
08:44:28 <erisco> @hoogle bool
08:44:32 <lambdabot> package bool-extras
08:44:32 <lambdabot> package boolean-list
08:44:32 <lambdabot> package boolean-normal-forms
08:44:41 <infandum> Seriously?
08:44:43 <infandum> ugh
08:44:51 <infandum> boy do I feel stupid
08:44:53 <c_wraith> it's in base now 
08:44:56 <infandum> wait no
08:45:00 <infandum> that's not what I want
08:45:38 <infandum> It would be Bool -> (a -> b) -> (a -> b) -> a -> b
08:45:50 <infandum> or flipped or whatever
08:45:54 <infandum> :t maybe
08:45:56 <lambdabot> b -> (a -> b) -> Maybe a -> b
08:46:20 <infandum> so (a -> b) -> (a -> b) -> Bool -> a -> b
08:46:22 <c_wraith> that's the same type. 
08:46:44 <c_wraith> well, they unify 
08:46:46 <erisco> "bool" is already more general than that :)
08:47:04 <c_wraith> remember, a can be a function. 
08:47:15 <erisco> I wonder why this is a frequent oversight
08:47:35 <infandum> oh
08:47:45 <infandum> really? I thought -> signified a function
08:48:03 <nitrix> infandum: `a` can have any type, including (x -> y)
08:48:03 <c_wraith> yes, but a type variable signifies *any* type. 
08:48:12 <infandum> ah
08:48:20 <sdx23> erisco: aside from your message being spam, I'd even argue that it's worse than most of the other suggestions.
08:49:23 <Drezil> bjs: nah .. only 4 common extensions (GADTs, MultiParamTypeClasses, KindSignatures and RankNTypes) :)
08:49:33 <infandum> yup!
08:49:36 <infandum> great!
08:49:36 <Drezil> but there is a ticket referencing such error wtih a fix in GHC-Head
08:49:37 <infandum> thaaaaaanks
08:51:41 <erisco> sdx23, I recommend reading the articles I linked, starting with conal's Semantic Editor Combinators
08:52:00 <erisco> apparently people take these Internet points far more seriously than I do!
08:56:59 <tolt> Does anyone know if (\x -> coerce $ f x) results in the same core as (unNewtypeThing . f) ?
09:02:46 <nitrix> tolt: coerce isn't supposed to have a runtime overhead.
09:03:05 <nitrix> tolt: So both run unNewtypeThing and coerce are simply going to get eliminated.
09:03:10 <tolt> nitrix: yeah, but newtype things aren't supposed to either right? I guess there are two things here
09:03:12 <tolt> yea
09:03:40 <nitrix> As far as I know. Looking at the core would confirm this.
09:04:17 <ongy> can coerce convert between type and newtype wrapper?
09:08:51 <dmj`> ongy: type is just an alias
09:09:10 <dmj`> you can coerce between newtype F = F Int and type Foo = Int, it's the same as coercing between F and Int
09:09:43 <dmj`> newtype doesn't exist at runtime, coerce will inspect underlying representation
09:11:05 <sdx23> erisco: It's really about the content of the answer itself that I critizise. Introducing functions for basic stuff that already exists is bad style, imo. Just the same as with extensions. It's burdensome to read that code for non insiders. 
09:11:35 <Wizek> Hi, can I compile a haskell project with GHC in such a way that certain functions are still accessible (and it is possible to invoke them with arguments), e.g. with the help of ghci? I can easily load a file/module/project to ghci, but afaik then much of the code is interpreted, right?
09:12:53 <ongy> sdx23: "insiders" is hard to define though. By now, I think I would recommend uncurry + (&&&), but I don't wouldn't have been able to read that like a month ago
09:12:54 <oherrala> Wizek: you need to export the functions out from module aka "module Foo (func1, func2) where .."
09:13:14 <nitrix> Wizek: What is interpreted are the expressions fed to the REPL, your module is still precompiled.
09:13:43 <erisco> sdx23, again I recommend reading the articles. You will find '~>' especially to be clever, and not something that already exists in the commonplace.
09:14:26 <nitrix> Wizek: But I think that's not the questions you aimed to ask. By default, a module export all of its functions. If you start explicitly listing the functions that are exported, then it works like a whitelist system.
09:15:28 <c_wraith> Wizek, you can tell if ghci has loaded a file as interpreted or compiled by whether the module name in the prompt has a * in front of it. if it does, it's interpreted. 
09:15:36 <erisco> everyone who has typed in @pl owes it to themselves to read these
09:16:51 <Wizek> c_wraith, that's interesting. It seems only my *Main module is interpreted according to the prompt
09:17:47 <Wizek> but during loading, I see many lines like "[2 of 9] Compiling Utils            ( /home/wizek/sandbox/exp-proj/src/Utils.hs, interpreted )"
09:18:17 <Wizek> and in the prompt, Utils has no immediately preceding asterisk.
09:18:17 <nitrix> That seems to confirm those are compiled and not interpreted ;)
09:18:56 <Wizek> nitrix, even the ", interpreted" part/
09:18:57 <Wizek> ?
09:20:08 <Wizek> nitrix, wouldn't it say ", compiled" if it was compiled? :D
09:20:34 <dramforever> it would say <some path>.o
09:20:54 <dramforever> I thought the * means that you are "inside" the module
09:21:23 <dramforever> if you define a function but not export it, you can access it in *-mode anyway
09:21:54 <Wizek> dramforever, That makes sense for me.
09:21:58 <eklavya> stackoverflow suggests I can update docs for my lib on hackage at any time, is that true? something I should beware?
09:23:25 <dramforever> Question: What's the current Standard Way to distribute haskell binaries? I'm more and more confused with all the strip, split-objs, split-sections, -static, etc.
09:24:17 <dramforever> It's for Windows users, if this helps/matters
09:24:17 <eklavya> also can I do a hackage upload precheck with stack? (I don't want to accidentally do some breakage trying to use cabal)
09:25:38 <nitrix> Wizek: It's because the terminology overlaps a little.
09:26:27 <nitrix> Wizek: GHCi normally converts your code to byte-code and runs it with an interpreter. Tha means no asterisk and it'll say "interpreted", which is a fancy way to mean it loaded the symbols and whatnot.
09:26:59 <nitrix> Wizek: The alternative is that it supported running interpreted code alongside compiled code, those modules aren't precompiled to byte-code and are marked with an asterisk.
09:27:33 <nitrix> I can't english today.
09:27:44 <Wizek> hmm, I see
09:29:44 <glguy> eklavya: You can upload documentation manually for a package that you maintain at any time, yes
09:30:25 <Wizek> I also have just tried out that it is possible to do something like this: `echo "1+1" | stack ghci exp-proj`, which is nice
09:30:36 <glguy> eklavya: This is what I wrote and use to upload documentation; there are other tools as well: https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
09:30:55 <orion> Does GHC 8 offer any enhanced debugging capabilities?
09:31:06 <Wizek> although it does take 5.6s on my system loading [9 of 9] modules
09:31:09 <nitrix> What's overlapping is the definition of "interpreter". Even if the code was compiled to byte-code, it stills needs to be loaded in the REPL and you can place breakpoints, step through, poke around with symbols and whatnot.
09:31:18 <eklavya> glguy: so I need to have cabal?
09:31:41 <glguy> eklavya: If you want it to be easy
09:31:47 <eklavya> :D
09:31:49 <mgsloan> Haha
09:31:55 <mgsloan> Depends on the level of checking you want
09:32:04 <glguy> You could manually assemble the tarball and use stack to build the haddocks and upload it yourself
09:32:19 <mgsloan> If you want to be 100% sure it works with cabal, then yes you need to use cabal.  It ought to likely work with cabal-install, though, since stack uses the Cabal library
09:32:20 <glguy> I have a version of the script that does it more like that if you're on stack
09:32:39 <Wizek> nitrix, So is what you are saying is there are levels of compilation: interpreted .hs, copiled bytecode + symbols, binary with stripped symbols, perhaps?
09:32:54 <mgsloan> It's pretty much either a cabal-install bug or stack issue if stack can install something and there's no way to convince cabal to do the same
09:33:13 <Wizek> nitrix, Also, any idea how I could get rid of that 5.6s delay that I mentioned above?
09:33:31 <glguy> It's not about installing anything, it's just that cabal-install now has a flag for building haddocks as expected for hackage
09:33:40 <dramforever> Wizek: try -fno-code
09:34:01 <mgsloan> eklavya: We do have plans for stack to support thorough vetting of sdists before upload - https://github.com/commercialhaskell/stack/issues/717
09:34:15 <mgsloan> Which would really address a point of annoyance with upload in general
09:34:18 <nitrix> Wizek: Not quite. Modules can be compiled or interpreted, but ultimately GHCi is an interpreter. When it loads the file, it'll say "interpreted", because it has to load a bunch of information that makes it able to be a useful REPL.
09:34:31 <glguy> My previous version is probably more amenable to be used with stack https://github.com/ekmett/lens/blob/4e01a13f2fe738e77af29e09370a6cbaa74e6af9/scripts/hackage-docs.sh
09:34:49 <glguy> you'd just need to add the word stack in a couple places
09:35:04 <eklavya> I'll go with cabal, if all I am doing is upload, nothing should break :P
09:35:15 <eklavya> thanks glguy mgsloan :)
09:35:21 <nitrix> Wizek: The asterisk denotes if the module was compiled or not when it got loaded. Think of it as GHCi dealing with two different formats. .o or .hs
09:36:52 <glguy> mgsloan: stack being able to easily build documentation tarballs and upload to hackage would be great
09:37:42 <glguy> stack already can do the hard part, it's just the bundling into a tarball and making sure to use the correct base urls
09:38:16 <Wizek> dramforever, did you mean like this? `echo "1+1" | stack ghci --ghc-options="-fno-code" exp-proj` still takes about 6s to return.
09:38:57 <nitrix> Wizek: You might want runhaskell for that.
09:39:48 <nitrix> Wizek: Seems a little overkill to start the entire repl environemnt including loading existing projects if you're only going to do some simple arithmetic.
09:40:05 <Wizek> that's just a simple example
09:40:16 <Wizek> I hope to be able to invoke some internal functions
09:40:19 <Wizek> with arguments
09:40:19 <dramforever> what about --ghci-options?
09:41:03 <monochrom> perhaps stack is taking those 6 seconds.
09:41:05 <Wizek> dramforever, hmmm, something has changed: "[2 of 8] Compiling Utils            ( /home/wizek/sandbox/exp-xml/exp-xml/src/Utils.hs, nothing )"
09:41:17 <Wizek> note the nothing at the end
09:41:27 <Wizek> still takes 4.9s
09:42:07 <nitrix> Consider yourself lucky. My projects take minutes to build ;)
09:42:09 <Wizek> but it seems I am closer to my target by 0.7s, that's something!
09:42:18 <nitrix> Why do you need 0.7 ?
09:42:29 <Wizek> Not to, by.
09:42:43 <nitrix> Then what's your target?
09:43:41 <nitrix> It seems unrealistic to expect 0s to load modules, resolve symbols and whatnot.
09:43:44 <monochrom> Here is a scientific experiment to find out just how much -fno-code still does. Introduce some type error in your code. Load with -fno-code. See if it cares.
09:43:53 <dramforever> Wizek: http://chrisdone.com/posts/making-ghci-fast
09:44:07 <dramforever> found the supposedly almighty post
09:44:21 <nitrix> If your intention is to build some kind of system that uses GHCi to feed inputs in real-time (ala lambdabot), I'd strongly recommender you keep the process running instead.
09:44:52 <nitrix> Oh even better, actually include the ghci library.
09:44:54 <nitrix> http://hackage.haskell.org/package/ghci
09:45:01 <Wizek> nitrix, 5.6s was without -fno-code. Well, I'd hope that it would take less then a second, ideally. I hope to use something like this with a loose collection of utility functions that I invoke multiple times daily, and am still developing. I tried defining a CLI interface for them via opt-parse-appicative, but that is too rigid for the unstable api at the moment. I would hope to invoke the functions directly somehow.
09:45:44 <Wizek> *optparse-applicative
09:45:48 <dramforever> So chrisdone says that you should use -fobject-code
09:46:05 <Wizek> giving it a try
09:46:06 <dramforever> so that compilations are cached
09:46:16 <Wizek> that sounds splendid, sec
09:46:51 <Wizek> we are getting somewhere:
09:47:30 <Wizek> [2 of 8] Compiling Utils            ( /home/wizek/sandbox/exp-xml/exp-xml/src/Utils.hs, /home/wizek/sandbox/exp-xml/exp-xml/.stack-work/odir/Utils.o )
09:47:37 <Wizek> takes 7.2s the first time
09:47:38 <Wizek> and then:
09:47:47 <Wizek> [2 of 8] Compiling Utils            ( /home/wizek/sandbox/exp-xml/exp-xml/src/Utils.hs, /home/wizek/sandbox/exp-xml/exp-xml/.stack-work/odir/Utils.o ) [flags changed]
09:47:53 <dramforever> !
09:48:07 <Wizek> some flags change and takes 7.2s again
09:48:55 <nitrix> Have you considered running the actual binary ?
09:49:17 <nitrix> And passing your variants as arguments to the program?
09:49:50 <Wizek> nitrix, I think that's what I did with optparse, but that didn't seem flexible enough
09:49:51 <nitrix> More information on your goal could help us help you.
09:50:02 <dramforever> can you try to skip stack a bit and do stack exec ghci -fobject-code or something
09:50:02 <nitrix> Wizek: What kind of flexibility do you need?
09:50:14 <Gurkenglas> Is there an At without the Maybe?
09:50:52 <glguy> Gurkenglas: Ixed is similar to At "without the Maybe"
09:51:05 <Wizek> dreamseeker, gicing that a try
09:51:10 <glguy> But what are you actually doing?
09:51:40 <Gurkenglas> Thinking how I could make a PR to replace https://github.com/lukexi/extensible-ecs/edit/master/src/Data/ECS/System.hs with an At instance
09:53:18 <Zemyla> You know, I thought of something regarding using an array with an IntMap to store updates, and also on having data structures with mutable elements showing up as referentially transparent.
09:53:21 <Wizek> dramforever, So, this does load up ghci, "stack exec -- ghci -fobject-code" but without any locally defined modules in the project, just vanilla Prelude
09:53:32 <Wizek> dramforever, same with "stack exec --package exp-xml -- ghci -fobject-code"
09:54:08 <dramforever> uh, then :m Utils
09:54:40 <Wizek> Could not find module ‘Utils’
09:54:44 <Zemyla> Basically, the structure has an immutable array, an IntMap for holding updated values, and a mutable bytearray.
09:54:54 <dramforever> Screw it
09:55:19 <dramforever> :( Sorry, no more suggestions from dramforever
09:55:28 <Zemyla> The bytearray is one bit for every value in the array, starts with all values zero, and when an element is updated, that bit is set to one.
09:55:35 <Wizek> dramforever, Thanks for the dance anyway :)
09:55:52 <dramforever> at least we are moving towards it
09:55:56 <Wizek> yup
09:56:24 <Wizek> I am writing some context just now to respond to nitrix about what kind of flexibility I am looking for
09:56:45 <Zemyla> The genius part is that, when an element is read, the corresponding bit is read first. If it's 0, then it just checks the array. If it's 1, then it checks the map first, and if it fails to find it, then goes to the areay.
09:58:05 <JonReed> Hi, is there some way to automatically load files into ghci when they are saved and preserve previous state? When I do `let constant = 5` and I do `:load myModule.hs`, then constant suddenly disappears.
09:58:16 <dmwit> nope
09:58:17 <Zemyla> So two copies of the array can have different hashmaps after updates, and still share the same flag array; it's just an optimization
09:58:20 <volhovm> Hi! I have an acid-state related problem. It takes HUGE amount of memory. Here's a raw data & plotted data for an application that is changing each state each period and crates checkpoint. First column is period number. Second is `BS.length $ runPut safePut` of safecopy. Third is `du -sb` of acid-state folder:
09:58:25 <volhovm> http://pastebin.com/70HFpAe5
09:58:25 <dramforever> Zemyla: sounds like a diffarray
09:58:39 <volhovm> http://imgur.com/a/e5af5
09:58:49 <danilo2> Hello guys! Are there any plans to allow such syntax on typelevel in Haskell? so If I write (a :: Bar #foo) it will be translated into (a :: Bar "foo") ? IT would be so convinent when using the new labels sugar from ghc8
09:59:03 <Zemyla> dramforever: Oh, diffarray was what I was looking for, thanks. I should send a PR to add that method of updating.
09:59:09 <volhovm> What can cause that big acid overhead?
09:59:34 <Zemyla> dmwit: Wasn't there someone who posted in /r/haskell about a way to preserve values in GHCi?
10:00:10 <sdx23> volhovm: see createArchive . Without checkpoints do not reduce space consumption
10:00:49 <volhovm> http://tinypic.com/r/2cdwccn/9 fixed photo
10:00:54 <volhovm> s/photo/screenshot
10:01:46 <volhovm> sdx: mhm, will look into it. But it's also interesting what is the reason of such a terrible overhead? 
10:02:35 * hackagebot idris 0.12.2 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.12.2 (EdwinBrady)
10:02:57 <Zemyla> Oh, speaking of array, is there a way to add a monadic access to Data.Array so you can access a value and have it be strict in the array but not the value returned?
10:03:40 <dmwit> The default indexing operations are lazy in the value returned.
10:03:46 <dmwit> Why does the access need to be monadic?
10:04:06 <Zemyla> dmwit: Because they're lazy in both the value and the array.
10:04:25 <Gurkenglas> Is there a way to give a (Map k Any) newtype At instances to retrieve anything?
10:04:51 <Zemyla> If you do x = a ! i, then x retains a reference to a until it's fully evaluated.
10:05:10 <Atomic_lQBvA> maybe haxx anon.fm
10:05:17 <eklavya> glguy: your script is for uploading docs, right? Do you have something for uploading the package too?
10:05:25 <Zemyla> This is a problem when creating a new array with a subset of elements from the old one.
10:05:25 <glguy> eklavya: cabal upload does that
10:05:31 <Gurkenglas> More exactly https://github.com/lukexi/extensible-ecs/blob/1ee6e71943b0b1ec7188fa674798a4f3b7864c78/src/Data/ECS/Vault.hs
10:05:39 <eklavya> oh ok
10:05:50 <glguy> eklavya: I use cabal sdist to make a tarball, and then I cabal upload that tarbal
10:06:03 <eklavya> ok
10:06:38 <glguy> Gurkenglas: No, you'll need to provide a specific type when implementing the type instance of IxValue for your newtype
10:06:59 <glguy> Gurkenglas: rather than using Any directly you should probably be using Dynamic
10:07:41 <dmwit> Zemyla: Interesting. I wonder whether one could fake it by defining `data Box a = Box a` and then doing strict lookups in `fmap Box a`.
10:07:54 <dramforever> Let me rephrase my earlier question: How do you build a nice standalone binary from haskell code? Does anyone have good example build scripts to follow?
10:08:22 <monochrom> how "nice standalone" do you need?
10:08:22 <Wizek> nitrix, So, let me try to expand on what kind of flexibility I am looking for: I have many functions defined/imported to Main, some are simply `IO ()`, others are `xyz -> IO ()`. I have tried to deal with running/configuring+running these via saying `main = myFunc 1 2 3` then compile+run. Previous to this, I was using opt-parse, until my app was taking 2 arguments: input and outputKind (and did some conversions in-between). But defini
10:08:23 <Wizek> ng and maintaining these commands takes effort, which is often wasted since the while project and api is in much flux (if only I had a crystal clear idea of what user-interface would suite best these functions... but I am experimenting with that as I go along) Do i would like to be able directly invoke/compose some of these functions from the CLI, basically: a CLI where the interface is native haskell functions and code. That is the a
10:08:23 <Wizek> mount of flexibility I am looking for! And btw, I think I have found it like this: "echo "showDone" | stack ghci --ghci-options="-fobject-code" exp-xml". The only issue is that this takes 7.2s to invoke as opposed to optparse compiled binary taking 0s upfront. 
10:08:41 <Zemyla> dmwit: No, because fmap Box a will have a bunch of values of the form (Box (a ! i)).
10:08:54 <dmwit> Zemyla: Are you sure?
10:08:54 <Wizek> so if/when I am able to figure out that [flags changed] issue, I might be all set.
10:09:36 <Wizek> nitrix, does that make sense for you?
10:09:57 <Zemyla> Yeah. It uses unsafeAt in the implementation, which is of type a i e -> i -> e.
10:10:18 <Wizek> dramforever, what do you mean by "nice standalone binary"? Static linking? Or something different?
10:10:24 <dmwit> bummer
10:10:33 <dramforever> static linking yep
10:10:44 <dramforever> and Ideally not too large binaries
10:10:57 <Wizek> dramforever, Well, you are in luck, because static linking is by default
10:10:58 <volhovm> sdx23: it's not getting better with `createArchive`.
10:11:05 <Wizek> until I read your second criteria...
10:11:05 <nitrix> Wizek: You're supposed to work _in_ the repl, not by relaunching it everytime and piping inputs to it :/
10:11:23 <Wizek> nitrix, using the repl is not a must for me
10:11:37 <Wizek> I would be happy to use anything else that allows me such functionality
10:11:46 <nitrix> Wizek: Your workflow right now is akin to rebooting your computer everytime you want to open a new webpage in your browser, changing the start webpage and launching your browser again.
10:12:01 <ongy> Wizek: on linux it looks like a mix, static for haskell libraries, dynamic for others, does windows ghc handle it differently?
10:12:36 * hackagebot hascas 0.1.0.0 - Cassandra driver for haskell  https://hackage.haskell.org/package/hascas-0.1.0.0 (eklavya)
10:12:38 <nitrix> Wizek: The REPL does exactly the work flow you're trying to achieve. Modifying files, reloading definitions, running them with different arguments. It's what it's designed for.
10:12:40 <dramforever> I can't be the only one on earth wishing for that, and I do think someone has already figured it out
10:12:50 <eklavya> what?
10:12:59 <eklavya> it failed on my machine
10:13:05 <Wizek> dramforever, I haven't yet figured out how to make small binaries though. I sometimes get 14.33 MB even for smallish projects. Maybe JHC compiler could help, but I haven't tried that yet
10:13:08 <eklavya> I don't have gpg setup
10:13:32 <dramforever> I heard that strip can work
10:13:58 <Wizek> ongy, I have limited experience with haskell on win32, but FWIW, IIRC the binary size for building a project on linux and win were roughly the same for me
10:14:09 <mgsloan> Wizek: You can probably get that to go faster by adding "--no-build --no-load", and adding a ":load" to the echo
10:14:19 <glguy> dramforever: You can reduce executable sizes compiling with split-objs, but you basically have two choices: large and statically linked, small and dynamically linked. This isn't specific to GHC
10:14:26 <Wizek> mgsloan, giving that a try
10:14:43 <shapr> Does it help to run strip on Linux binaries after building them? I'd guess that shrinks the size?
10:14:51 <dramforever> glguy: Sounds reasonable
10:15:37 <Wizek> I haven't had success with split-objs before :( but maybe that was an incompatibility with stack a few months back
10:15:59 <dramforever> I really don't want to see a 15MB executable when the python cxfreeze'd version is 7MB
10:15:59 <glguy> Wizek: Well, it's a real thing, and it cuts down sizes noticably
10:16:24 <dramforever> (numbers are randomly given, but I think you get the idea)
10:16:50 <dramforever> version: equivalent program
10:17:59 <dramforever> glguy: "noticably", well, that would be great!
10:19:27 <eklavya> I can't seem to stack install haddock, some version error, isn't stack lts not supposed to do that?
10:19:33 <eklavya> I am getting haddock-api: needed (==2.17.*), 2.16.1 found (latest applicable is 2.17.3)
10:19:40 <eklavya> what does that mean?
10:20:13 <dramforever> Thanks for that glguy, I guess I'll measure real code for sure
10:20:50 <Wizek> I would love to see a similar decrease: "No pre-written runtime. other than 20 lines of boilerplate all code is generated from the Grin intermediate code and subject to all code simplifying and dead code elimination transformations. As a result, jhc currently produces the smallest binaries of any Haskell compiler. (main = putStrLn "Hello, World!" compiles to 6,568 bytes vs 177,120 bytes for GHC 6.4)" Source: http://repetae.net/compute
10:20:51 <Wizek> r/jhc/jhc.shtml
10:20:52 <glguy> eklavya: The haddock executable doesn't appear to be in lts, so you'll need to pick a particular version from hackage that builds with the resolver you picked
10:20:54 <Wizek> http://repetae.net/computer/jhc/jhc.shtml
10:21:01 <glguy> eklavya: Also you probably don't need to install haddock again, it comes with GHC
10:21:13 <Wizek> even in ghc
10:21:29 <eklavya> glguy: I didn't install ghc, I only have stack, it did the rest
10:21:41 <glguy> eklavya: then stack installed ghc with haddock
10:22:06 <eklavya> there doesn't seem to be a haddock binary
10:22:29 <glguy> It's in there
10:22:46 <eklavya> wait doing "stack haddock" in doing something
10:22:51 <eklavya> is*
10:24:51 <eklavya> oh that's just building with haddock :(
10:27:35 <dramforever> Wizek: Sounds interesting
10:27:37 * hackagebot TransformeR 0.1.0.0 - eDSL in R for Safe Variable Transformarion  https://hackage.haskell.org/package/TransformeR-0.1.0.0 (remy)
10:28:59 <dramforever> but you see I'm not competing with C, I just want to make sure it's not too larger than a python or ruby or whatever high-level language
10:29:18 <dramforever> *than a program in python ...
10:29:28 <dedgrant> Wizek: JHC looks really interesting.
10:30:54 <Wizek> dramforever, makes sense. I would be interested in hearing back from you if/when you do make -split-objs work
10:30:57 <orion> If I have a function f :: (MonadThrow m) => Foo -> m Bar and I have the following: instance e ~ SomeException => MonadThrow (Either e) <-- is it possible to convert the result of 'f' to MyPersonalException, given that there is an "instance Exception MyPersonalException" ?
10:31:03 <Wizek> I am curious the real world savings it produces
10:31:18 <orion> I am not sure what ~ means in this case.
10:31:24 <glguy> orion: It means "equals"
10:31:43 <dramforever> That would be much later I'm afraid
10:32:14 <glguy> orion: Given some: Either SomeException a, you can case on that to get a Left SomeException. You can use fromException :: SomeException -> Maybe MyPersonalException
10:34:05 <orion> hmm, I see.
10:34:46 <Atomic_lQBvA> ruby
10:35:14 <orion> glguy: Thank you for that information.
10:35:58 <Wizek> dedgrant, Indeed. I kinda want to just give it a try now reading the linked page. But I really rather use stable software, so that is detering me
10:36:24 <glguy> Atomic_lQBvA: Did you have a Haskell question?
10:38:44 <Atomic_lQBvA> not now
10:39:28 <Atomic_lQBvA> I read
10:42:10 <Atomic_lQBvA> who can give me worked bruteforce
10:42:21 <Atomic_lQBvA> for win
10:42:38 <Atomic_lQBvA> link
10:43:08 <Atomic_lQBvA> with txt
10:43:20 <Atomic_lQBvA> for web
10:43:22 --- mode: ChanServ set +q *!*@ppp109-252-72-34.pppoe.spdop.ru
10:43:25 <zebr> hi all. is there a way to write a function :: IO (a -> IO b) -> IO (a -> b) ?
10:43:44 <glguy> zebr: No
10:44:42 <zebr> damn, i'm using IORef and that type seemed uglier than it needed to be. alright then, thanks.
10:49:13 <dedgrant> Wizek: I recall the ajhc fork (which I think was abandoned?), but the redux on a compiler seems fruitful. I'd like to learn a bit more about region inference.. kind of surprised to learn of this being used in place of a garbage collector.
10:50:23 <eklavya> my package is on hackage, but stack can't find it, I even added it to extra-deps, didn't work, what am I missing?
10:50:55 <shapr> eklavya: what's the error?
10:51:04 <sm> and the command ?
10:51:06 <shapr> eklavya: when that happens to me it's usually spelling
10:51:28 <eklavya> Could not find package hascas in known packages
10:51:35 <shapr> dedgrant: there's a section in ATTaPL on region inference
10:51:36 <eklavya> and when added as extra-deps
10:51:47 <eklavya> The following package identifiers were not found in your indices: hascas-0.1.0.0
10:51:57 <shapr> eklavya: stack update?
10:52:00 <eklavya> I did that
10:52:25 <eklavya> does it need to be a part of lts/stackage something?
10:52:33 <kadoban> No
10:53:32 <kadoban> Hmm, doesn't stack use its own cache of hackage? It looks like you just uploaded that recently, there might be some delay there.
10:53:49 <eklavya> oh ok
10:53:57 <eklavya> I will try tomorrow then
10:54:00 <dedgrant> shapr: ty!
10:54:01 <kadoban> eklavya: In the mean-time, you can specify packages to use as extra-deps from like local directories, if you want to do that.
10:54:06 <kadoban> Or git repos or a couple of other ways
10:54:16 <eklavya> yeah I have been doing that
10:54:21 <sm> there might also be some outage causing a delay
10:54:23 <eklavya> was testing using from hackage
10:54:36 <kadoban> Ah okay, yeah waiting should be the answer then, I'm like 75% sure.
10:54:52 <eklavya> ok, I will try tomorrow then
10:55:01 <eklavya> thanks kadoban shapr sm :)
10:55:12 <shapr> sorry we couldn't fix it :-/
10:55:25 <sm> I'd ask on #haskell-stack
10:55:33 <shapr> kadoban: oh, how do I specify local dir extra-deps?
10:55:57 <kadoban> shapr: You put them in "packages" and then specify extra-dep: true for each one
10:56:23 <kadoban> So like - ../someproject/<newline> extra-dep: true     or something like that
10:56:33 <eklavya> kadoban: I didn';t have to do anything for extra-deps
10:56:39 <eklavya> I just listed dirs in packages
10:57:13 <kadoban> I forget what exactly it does specifying as an extra-dep or not. It might have something to do with what tests are run when you do 'stack test', like it won't test the extra-deps, since you usually don't care, and etc.
10:57:46 <eklavya> ok
10:59:02 <glguy> once you're adding properties to a package you have to use the location: key for the path afaik
10:59:10 <glguy> - location: lib/thing
10:59:15 <glguy>   extra-dep: true
10:59:49 <kadoban> That's possible, I didn't think so though. I basically screw up yaml syntax more than I get it correct though, heh.
10:59:55 <pikajude> Can OverloadedLabels be used for anything yet?
10:59:57 <pikajude> in GHC 8
11:00:10 <glguy> Yes, anything you can fit into the IsLabel class
11:00:43 <pikajude> I see
11:01:06 <pikajude> but overloaded record fields for realsies don't exist yet
11:01:49 <glguy> There's more work to do on that front, but DuplicateRecordFields and OverloadedLabels exist for you to build things with
11:02:19 <pikajude> I see
11:02:31 <pikajude> so if I wanted to use a label as an accessor I'd have to write the code for that myself
11:02:39 <glguy> Yeah
11:03:02 <pikajude> Oh
11:12:49 <pikajude> and I can't use a label in a record update yet, I'm assuming
11:13:39 <glguy> That depends what you mean, I don't think there are plans to use #labels in record{field=update} syntax
11:13:49 <glguy> but you can make instances of IsLabel to support updates via functions or lenses
11:14:42 <pikajude> oh
11:15:00 <pikajude> oh yeah, I guess I could write an instance that is a lens
11:16:21 * ertesx isn't overly impressed by OverloadedLabels
11:18:31 <ertesx> normal record fields and lenses probably work better most of the time, and it seems like a lot of hassle to cover the few cases not covered by DisambiguateRecordFields and DuplicateRecordFields
11:19:37 <ertesx> in the rare cases you actually want that, it probably makes sense to write your own class instead, because it's no longer about "having a field with that name" and more about "have that particular common feature"
11:21:27 <mniip> what's the convention on naming cothings?
11:21:34 <mniip> Data -> Codata, or CoData
11:22:45 <ertesx> mniip: Codata, as far as i've seen
11:22:58 <ertesx> Cofree, Codensity, …
11:23:03 <mniip> Coclass, too?
11:25:00 <orion> glguy: Would you consider a return type of "Either (Maybe MyPersonalException) MyResult" to be bad form?
11:26:15 <Zemyla> orion: What does Left Nothing mean?
11:26:47 <orion> Zemyla: It means that the exception thrown was something other than MyPersonalException.
11:26:58 <ReinH> Submit yourself to makeFields
11:27:16 <orion> It might be better to just use SomeException and let the caller handle it themselves.
11:27:44 <monochrom> makeFields monochrom ---> now monochrom is a field
11:27:56 <monochrom> or a lot of fields, I don't know which.
11:27:56 <mniip> monochrom is a fields
11:29:44 <Zemyla> orion: So it forgets what exception it was?
11:30:12 <orion> Zemyla: Indeed.
11:30:26 <Zemyla> Well, it sjouldn't do that.
11:30:33 <orion> You're right... that does seem pretty unhelpful.
11:31:31 <joe9> What is the recommended way for haskell errors? there seem to be many recommended methods? throwDyn or throw ( http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/ ) seems to favour throwDyn . http://stackoverflow.com/questions/6070316/how-to-throw-an-exception-and-exit-the-program-in-haskell seems to favour just throw
11:31:37 <joe9> any suggestions , please?
11:31:54 <joe9> and , there is this: http://hackage.haskell.org/package/enclosed-exceptions-1.0.2/docs/Control-Exception-Enclosed.html
11:33:22 <joe9> got it, looks like throwDyn is obsolete.
11:33:52 <sm> https://haskell-lang.org/tutorial/exception-safety is good on exceptions
11:34:17 <joe9> sm, thanks.
11:41:26 <Hi-Angel> I don't understand, what does mean "(stringToTextObject -> PartialMatch)" here https://github.com/yi-editor/yi/blob/610989e3e9108b588af62ec9d61e9d5ded7d293b/src/library/Yi/Keymap/Vim/VisualMap.hs#L139-L140
11:41:26 <Hi-Angel> Is it like… Err… Pattern match of a function?
11:42:17 <geekosaur> it's a view pattern
11:42:52 <Hi-Angel> Ah, thank you! I'll read.
11:43:17 <geekosaur> basically instead of matching directly, it calls the specified fucntion and then matches against that function's output
11:44:01 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#view-patterns although it's actually been standard since Haskell2010, no longer an extension
11:44:16 <ertesx> geekosaur: huh?
11:44:24 <geekosaur> weren't they?
11:44:26 <ertesx> PatternGuards have become standard
11:44:32 <geekosaur> oh. sigh
11:44:36 <geekosaur> thought both were
11:44:43 <ocramz> hullo all
11:44:52 <ertesx> i wish, but it's only one
11:45:06 <geekosaur> (in any case pattern guards are also listed as an extension in ghc still... https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-guards)
11:46:19 <ertesx> as long as GHC supports h98, it will probably stay there
11:46:48 <ocramz> anyone feels like teaming up for the ICFP contest?
11:48:52 <joe9> i have json objects coming like this: https://gist.github.com/a3b111af0de7f2722d4da5b161704529 . I have to check the "op" field to figure out the type definition for it.
11:49:14 <monochrom> On the negative side, NoNPlusKPatterns is also an extension :)
11:49:17 <joe9> Other than checking/recursing the Value, is there any library function that can help?
11:49:44 <janos_p> Hey, one question, is there an easy way to combine case of structures which return Maybe's ?
11:50:03 <janos_p> as sometimes I do case .. of ... case .. of 
11:50:25 <mniip> hey dolio
11:50:30 <monochrom> yes, recall that Maybe is a Functor, an Applicative, and a Monad.
11:50:31 <janos_p> is there something like func1 >>= \x -> func 2 x 
11:50:36 <ertesx> janos_p: not sure if that helps, but Maybe is a monad
11:50:37 <monochrom> yes, like that
11:50:40 <joe9> janos_p: >>= ? maybe monad_cat
11:50:49 <mniip> in that data AFoo f where AFoo :: Foo a (f a) => AFoo f
11:50:56 <janos_p> but how I handle than at the end Nothing ?
11:50:57 <mniip> the variable 'a' is existentially quantified
11:51:02 <joe9> janos_p:  That is exactly what >>= does if teh result is a maybe value.
11:51:08 <mniip> i.e Foo a (f a) has to hold for some unspecified a
11:51:12 <janos_p> ah OK 
11:51:19 <mniip> how would I do a similar thing for universally quantified types?
11:51:27 <monochrom> OK, handling Nothing requires an outer function
11:51:30 <dolio> mniip: Is that what I wrote? If so, a should be a parameter.
11:51:33 <ertesx> janos_p: do x <- case … of { … }; y <- case … of { … }; pure (x + y)
11:51:53 <mniip> 1470320890 [17:28:10] <dolio> data F f a where Foo a (f a) => F ; class AFoo f where aFoo :: F f a ; class AFoo f => Bar f ...
11:52:28 <monochrom> fromMaybe "x" (do {a <- Map.lookup k1 m; b <- Map.lookup k2 m; return (k1++k2)})
11:52:46 <monochrom> err, s/k1++k2/a++b/
11:53:22 <janos_p> cool thanks
11:53:23 <janos_p> !
11:53:34 <dolio> The thing I wrote is for 'forall a. Foo a (f a)'.
11:54:11 <monochrom> @type fromMaybe
11:54:12 <lambdabot> a -> Maybe a -> a
11:55:11 <janos_p> so I could do fromMaybe (defaultfunction) (func1 >>= func2) right?
11:55:19 <monochrom> yes
11:55:22 <janos_p> nice
11:55:29 <monochrom> except it's defaultvalue not defaultfunction
11:55:48 <janos_p> oh yes I see
11:56:19 <ongy> monochrom: where's the difference? :)
11:56:36 <monochrom> most examples of values are not functions.
11:57:26 <janos_p> what if both results end in a IO () ?
11:57:32 <ReinH> Also an infinite number of examples of values are functions, but that's beside the point.
11:57:42 * hackagebot servant-smsc-ru 0.1.0.0 - Servant client for smsc.ru service for sending SMS to cell phones  https://hackage.haskell.org/package/servant-smsc-ru-0.1.0.0 (NCrashed)
11:57:45 <janos_p> e.g. default :: IO () and func2 :: IO ()
11:57:50 <mniip> hmm
11:57:55 <mniip> I'm not liking this signature
11:57:55 <ReinH> :t fromMaybe
11:57:56 <lambdabot> a -> Maybe a -> a
11:57:58 <mniip> 	observeProduct :: p k -> q f -> s a -> t b -> (forall d. Limit (Singleton KnownBool) k (d a b) (f a b) => r) -> r
11:58:06 <monochrom> janos_p: do you have an example?
11:58:20 <janos_p> wait
11:58:31 <ongy> mh, I thought I read that every value in haskell is also a function that returns exactly that value, maybe it was the the other way around (every function can be a value)
11:58:41 <monochrom> all hypothetical questions can be resolved by asking for examples :)
11:58:59 <mnoonan> ongy: the first one is a common false thing that you hear sometimes. the second one is true though!
11:59:00 <geekosaur> mniip, what's the problem? it's set up for use as a partial function (fromMaybe yourDefault)
11:59:04 <monochrom> This is why I don't read from the Internet too much. Too many rumours.
11:59:22 <Shou> janos_p: you can also use Functor and Applicative to deal with Maybes. join $ fmap readMay (Just "1"); (++) <$> Just "Hello, " <*> Just "World!"
11:59:22 <kadoban> orion: http://conal.net/blog/posts/everything-is-a-function-in-haskell
11:59:28 <mniip> geekosaur, er, I'm not liking the signature that I pasted
11:59:30 <kadoban> ongy: ^ (sorry orion)
11:59:44 <geekosaur> oh
11:59:57 <ReinH> janos_p: func2 :: a -> Maybe b for some a, b, and default :: b, in that scenario
12:00:03 <monochrom> "False 2" is a type error, therefore False is not a function. You don't need to read blogs to know this. In fact, if you read blogs you won't think of this.
12:00:13 <mniip> I guess I'll have to settle with a gadt
12:00:16 <ReinH> also func1 isn't a function
12:00:37 <ReinH> It's simple: Functions are values of type a -> b for some a, b.
12:00:50 <ReinH> If the outermost type constructor is (->), it is a function.
12:01:17 <monochrom> This is why it's more important to be have critical, independent thinking than to read blogs.
12:01:22 <janos_p> http://lpaste.net/174236
12:01:28 <janos_p> that is how I thought about it
12:01:34 <ReinH> In other languages, it might be different, but in Haskell it is how it is in Haskell
12:01:44 <ReinH> func is not a function
12:02:43 * hackagebot cacophony 0.8.0 - A library implementing the Noise protocol.  https://hackage.haskell.org/package/cacophony-0.8.0 (jgalt)
12:02:46 <monochrom> janos_p: OK, then it's again fromMaybe default (do {x <- value; z <- y; return func})
12:03:22 <monochrom> I disbelieve in meaningful names, so I won't pick on names. Name it "func", name it "monster", it's all Greek to me.
12:03:38 <ReinH> I disbelieve that you disbelieve in meaningful names
12:03:44 <janos_p> ok thanks monochrom
12:03:51 <ReinH> Since you use meaningful ones more frequently than chance alone would indicate
12:04:07 <monochrom> I believe in mnemonic names.
12:06:58 <monochrom> And keeping a healthy hamming distance between names.
12:07:07 <ongy> mh, thinking about it I guess the "value is function" may come from lazyness (every value may need some computation)
12:07:17 <ongy> and I hope that statemant isn't false again...
12:07:57 <monochrom> Do you use a function to model a computation? Or do you simply use a chunk of code?
12:09:27 <ongy> monochrom: usually functions, since I have a somewhat strong C background
12:10:14 <monochrom> then you will need to qualify it, i.e., "C-function" vs "Haskell-function". There is also "math-function".
12:12:24 <mniip> I have basically "Could not deduce C a b from the context C a0 b" where class C a b | b -> a
12:12:27 <mniip> how do I resolve that
12:13:15 <monochrom> Do not think that someone with a strong C++ background can just come here and say "functor means it has an operator() method" (a true statement for C++).
12:13:46 <ertesx> there is no such thing as "someone with a strong C++ background"
12:13:59 <monochrom> just relatively speaking
12:14:06 <ongy> monochrom: I don't say it's a good thing to do, I just suggest it's the reason this idea is so popular
12:15:29 <mniip> @let class Cls a b | b -> a
12:15:29 <monochrom> mniip, perhaps you really have two unequal types "a" and "a0".
12:15:31 <lambdabot>  Defined.
12:15:51 <mniip> monochrom, you mean two rigid tyvars?
12:15:56 <monochrom> perhaps
12:16:08 <mniip> but that would violate the instance assumption, no?
12:16:33 <monochrom> I would love to see how to get that error.
12:17:03 <dolio> Fundeps don't use information like 'that would violate the instance assumption'.
12:17:39 <dolio> Knowing that C a0 b and C a1 b does not tell you that a0 ~ a1.
12:17:43 * hackagebot servant-auth-cookie 0.3.0.1 - Authentication via encrypted cookies  https://hackage.haskell.org/package/servant-auth-cookie-0.3.0.1 (zohl)
12:18:31 <mniip> hrm
12:18:39 <mniip> I just tried it in my ghci and it worked
12:18:57 <mniip> but I have a bit more complicated class setup over here that exhibits what I think is the same behavior
12:19:01 <monochrom> but ghci turns on more extensions than normal
12:19:12 <mniip> no
12:19:19 <mniip> does it
12:19:36 <acowley> cocreature: Are you around?
12:20:16 <joe9> sm, love the article https://haskell-lang.org/tutorial/exception-safety great read . Thanks again.
12:20:19 <monochrom> consider how "print []" is an error normally, but not an error in ghci
12:20:20 <dolio> monochrom: You get errors like that by existentially quantifying over variables in a constraint, and thinking the fundep will allow GHC to figure out that the skolem is equal to something else.
12:21:03 <monochrom> That is sad. I.e., it is sad that some people actually think that way.
12:21:10 <dolio> But fundeps don't do that. That is the way in which they are weaker than type families and equality constraints.
12:21:25 <shachaf> Is there a reason that fundeps don't do that?
12:21:54 <monochrom> oh wait, maybe you mean something else.
12:22:10 <dolio> Because the implementation hasn't changed since way before people wrote the whole system for GHC to do that kind of reasoning.
12:22:36 <shachaf> Is there a reason that fundeps couldn't do that?
12:22:52 <dolio> No, although it might disallow some other things you can do with fundeps right now.
12:22:57 <dolio> Like overlapping instances.
12:24:30 * mniip tries to minify the test case
12:26:31 <dolio> monochrom: I mean that the fundep in 'C a b | b -> a' means (in theory) that when you have 'C skolem b', 'exists F. skolem = F(b)'. So if you have two such skolems, they should be equal.
12:28:13 <dolio> But fundeps do not actually enable such reasoning.
12:30:59 <dolio> For a long time having that fundep didn't even mean that was true, per se.'
12:31:56 <dolio> Because you could write instances like 'C a T', where T is a concrete type and a is a variable.
12:32:43 <dolio> And it would only ensure that you wrote one instance for T.
12:33:36 <monochrom> yikes, that is only syntactically unique
12:33:55 <dolio> So you could actually get two different as for a given T.
12:34:53 <dolio> That might be a useful thing to have, but it shouldn't be called functional dependencies, I think.
12:37:45 * hackagebot hats 0.1.0.0 - Haskell client for the NATS messaging system  https://hackage.haskell.org/package/hats-0.1.0.0 (PatrikSandahl)
12:42:34 <mniip> hmm
12:42:40 <mniip> this testcase is still fairly convoluted
12:44:23 <cocreature> acowley: yep
12:44:30 <cocreature> well now I am at least :)
12:45:12 <acowley> cocreature: I can't figure something out with llvm-general
12:45:26 <acowley> cocreature: I have a Module whose LLVM IR looks fine
12:45:32 <acowley> cocreater: I can jit and execute it
12:45:38 <acowley> cocreature: I can save it to a file
12:46:03 <acowley> cocreature: If I save it to a file, and compile it into a dylib, I can then load the function symbol after dlopen'ing the library
12:46:29 <acowley> cocreature: However, if I link llvm-general's object file output into a dylib, the symbol isn't found
12:46:50 <acowley> cocreature: So I backtracked, and found that if I llc --filetype=asm the IR file, the function symbol has a _ prefix
12:47:01 <acowley> cocreature: Whereas the llvm-general asm otuput does not
12:47:28 <acowley> cocreature: If I add the _ prefix to teh .globl directive and the label itself, everything links and loads fine
12:47:38 <acowley> cocreature: So I want to figure out what llc is doing differently that my use of the API
12:48:00 <lpaste> mniip pasted “No title” at http://lpaste.net/174247
12:48:07 <mniip> monochrom, dolio ^
12:48:21 <cocreature> acowley: do you have a minimal example of this? (also we might want to consider moving to #haskell-llvm since I guess this could become a longer discussion :)
12:48:35 <acowley> Sure, yes
12:51:31 <lpaste> mniip revised “No title”: “No title” at http://lpaste.net/174247
12:52:45 * hackagebot pipes-cacophony 0.4.0 - Pipes for Noise-secured network connections.  https://hackage.haskell.org/package/pipes-cacophony-0.4.0 (jgalt)
12:56:25 <Hi-Angel> What is this magic "VimBindingE (f . T.unpack . _unEv)" here https://github.com/yi-editor/yi/blob/610989e3e9108b588af62ec9d61e9d5ded7d293b/src/library/Yi/Keymap/Vim/VisualMap.hs#L137 ?
12:56:25 <Hi-Angel> It is obviously pattern match on constructor, and in the pattern match is a function applied.. But e.g. I can't write such pattern match, e.g. even simple "Just (i)" would trigger an error
12:56:47 <monochrom> I'm wondering why you sometimes write "Lim d f" and some other times "Lim f b".
12:57:31 <Hi-Angel> I didn't do it :з
12:57:37 <mniip> welll
12:57:44 <mniip> it comes from a much larger piece of code
12:58:06 <mniip> and it used to be Lim (d a b) (f a b) and a half dozen other parameters
12:58:54 <amf> lets say data A = { a :: Int64, b :: Sum Integer }. (this is my MonadWriter structure, it requires a Monoid instance, but how do i get that if i cant derive Monoid? instance Monoid A; didnt work :)
12:59:14 <amf> is this where Generic comes in?
12:59:39 <mniip> instance Monoid where mappend (A x y) (A z t) = A (mappend x z) (mappend y t)
13:00:03 <mniip> or are you trying to derive it at all costs?
13:00:17 <dolio> mniip: Yes, that's exactly the sort of thing that doesn't work.
13:00:35 <mniip> dolio, why?
13:00:45 <mniip> is it possible to make that work?
13:00:51 <dolio> Use type families.
13:00:52 <mniip> is there a workaround while it doesn't?
13:01:19 <amf> mniip: not sure what you mean by at all costs, but my A has a lot more fields than what i listed...
13:01:55 <Hi-Angel> Ah, silly me, it's just a constructor application, the sign = is on the other side..
13:01:56 <mniip> amf, hmm, you might have some luck with deriving (Generic, Monoid)
13:02:15 <monochrom> Pay me cdn$100 to write it for you
13:09:04 <ertesx> amf: Monoid is not a derivable class…  if your type has monoid semantics, you have to implement them
13:09:28 <ertesx> instance Monoid A where …
13:09:34 <babelchips> Hi - looking for some advice on using Data.Vector.Storable.
13:10:41 <amf> ertesx: I get that... but if all my fields already have monoid instances, i'd like it to use those instead of having to pre-declare it.. might be able to use this http://www.yesodweb.com/blog/2012/10/generic-monoid
13:11:10 <babelchips> I want to modify pairs of elements in a Data.Vector.Storable.  I _could_ converr to a List first and do pattern matching and recursion, but is there is better way?
13:12:35 <ertesx> amf: with the Monoid class you have to write that out…  even if you use a helper class with generics, unless you use template haskell, you have to say:  instance Monoid A where mappend = myDerivedMappend; mempty = myDerivedMempty
13:12:54 <ertesx> amf: for this small type trying to derive at all costs probably doesn't pay off
13:13:33 <Shou> babelchips: pairs as in two elements at a time?
13:14:17 <babelchips> Shou: yes - apply a function to both pairs and swap them if necessary
13:14:38 <ertesx> amf: you may find this predefined instance useful for quick-n-dirty writer usage:  instance (Monoid a, Monoid b) => Monoid (a, b)
13:14:55 <ertesx> babelchips: do you do this many times?
13:15:35 <babelchips> ertesx: yes - a single pass of a bubble sort essentially.
13:16:00 <ertesx> babelchips: use a mutable vector
13:16:18 <ertesx> babelchips: or even just use the vector-algorithms library that has a number of sorting algorithms
13:18:26 <amf> ertesx: thanks. i just kept it explicitly written out. still way less code than any other language for the same idea.
13:19:07 <babelchips> ertesx: ah ok.  I couldn’t see a single pass of a bubble sort in the vector-algorithms library.
13:20:49 <babelchips> ertesx: but a mutable vector sounds interesting.  Get a raw pointer and do an imperative style loop through all the elements?  
13:22:24 <dmj`> babelchips: might as well use an unboxed vector
13:23:03 <ertesx> babelchips: the vector library has a mutable variant for each of the flavours…  see the .Mutable modules
13:24:48 <ertesx> babelchips: also unless you actually need a *pointer* to the memory (for FFI purposes) i suggest that you use unboxed vectors (Data.Vector.Unboxed.Mutable) or the generic vector interface (Data.Vector.Generic.Mutable)
13:25:08 <dmj`> babelchips: all your favorite imperative algos can be done with mutable vectors
13:25:19 <ertesx> take inspiration from the vector-algorithms library…  all the sorting functions use the generic interface
13:26:44 <babelchips> ertesx: I’m using Data.Vector.Storable currently.
13:27:48 * hackagebot servant-auth-cookie 0.3.0.2 - Authentication via encrypted cookies  https://hackage.haskell.org/package/servant-auth-cookie-0.3.0.2 (zohl)
13:28:15 <ertesx> babelchips: you use storable vectors when you need a pointer to the memory, for example if you were preparing vertex data for OpenGL
13:28:48 <babelchips> ertesx: yes that’s exactly what i’m doing :)
13:29:26 <ertesx> yeah, i had a feeling =)
13:29:40 <ertesx> are you sorting by distance?
13:30:17 <babelchips> ertesx:  Yep.  Sorting particles for transparency 
13:31:19 <mniip> so
13:31:57 <ertesx> babelchips: sorting is probably the last-resort way of doing that, but if you have no other choice, i strongly suggest using vector-algorithms…  it has very fast implementations of very fast sorting algorithms
13:32:13 <ertesx> babelchips: in most contexts bubble sort is about the worst sorting algorithm you could use
13:34:09 <babelchips> ertesx: I agree.  But I read about a good use for bubble sort for my purposes.  Just one pass at a time (per-frame) to home in on the sorted list and keep it up to date is supposed to be ideal.  
13:35:33 <ertesx> babelchips: ah, i see…  in that case i think you'll have to code it yourself…  also note that some blending formulas are commutative, so you don't need sorting at all
13:36:09 <ertesx> babelchips: for example additive blending (fire, light or generally "hot" stuff) doesn't need it
13:36:55 <babelchips> ertesx: yep.  I’m doing volumetric effects though.
13:39:37 <babelchips> ertesx: dumb question: Do I need to freeze and unfreeze a storable.mutable each time I need to give the vertex data to OpenGl?…
13:41:45 <ertesx> babelchips: no, there is unsafeWith for mutable ones, too
13:44:03 <babelchips> ertesx: ok so mutable all the way.  I assume i’ve got iterate through the mutable vector in a (non-functional) way to check and swap pairs of data, right?
13:45:29 <babelchips> ertesx: the swap function on given positions seems ideal but it also seems wrong to be writing the equivalent of a for..loop…
13:46:23 <ertesx> babelchips: but that's basically what you're doing there…  if a for-loop is what you're doing, i wouldn't disguise it =)
13:46:44 <ertesx> being honest in haskell:  forM_ [0 .. Vsm.length arr - 1] $ \i -> …
13:47:27 <ertesx> babelchips: if that feels wrong, repeat the following sentence ten times before going to bed tonight:  "haskell is the best imperative language"
13:47:45 <babelchips> ertesx: I know that ;)
13:47:55 <Zekka> (don't drink too much kool aid)
13:50:11 <babelchips> ertesx: Glad to hear it!  Controlled side-effects right?
13:50:30 <ertesx> babelchips: one useful hint with OpenGL:  you can construct mutable vectors from pointers like those returned by glMapBufferRange
13:51:27 <babelchips> ertesx: OK, if the types line-up there’s no conversion at all I presume?
13:51:48 <ertesx> you need to make them ForeignPtr first; you can use that opportunity to attach the unmapping as a finalizer
13:52:03 <ertesx> then instead of unmapping you just finalize the ForeignPtr
13:52:31 <ertesx> and yes, in that case there is no copying going on…  it literally just uses the buffer memory you got from OpenGL
13:56:52 <danilo2> Hello guys! :) Can I run a "haskell quasiqoter" from within my custom quaiquoter in TH? 
13:57:14 <danilo2> haskell quasiquoter is the one that parses the Haskell code into TH datatypes
14:01:37 <babelchips> ertesx: One step at a time! :) I’m still trying to get to grips with Data.Vector.Storable versus Data.Vector.Storable.Mutable.  I thought Mutable was a superset?… But some functions are not avaialble in Mutable…
14:02:03 <babelchips> ertesx: i.e. head
14:02:50 * hackagebot hgeos 0.1.6.0 - Simple Haskell bindings to GEOS C API  https://hackage.haskell.org/package/hgeos-0.1.6.0 (rcook)
14:03:21 <ertesx> babelchips: they are different things
14:04:37 <ertesx> babelchips: a storable, mutable vector is pretty much exactly what an array in C is
14:04:50 <ertesx> a memory region with a known, fixed address
14:05:34 <c_wraith> with the downside that every read and write marshals values between C and haskell representations. 
14:06:03 <ertesx> and that's really all it is…  the vector library doesn't even insist on allocating it by itself (so you get unsafeFromForeignPtr)
14:06:50 <ertesx> to prevent marshalling just use the types the GL library of your choice defines for you (GLfloat, etc.)
14:06:51 <danilo2> Hello guys! Does anybody know where "haskell" uasiquoter is defined and if I can use it from within my TH ? 
14:07:36 <babelchips> ertesx: I see.  So if I want to get the head of a storable mutable do I need to convert it to a storable (freeze?) ?
14:07:42 <c_wraith> danilo2, I'd guess haskell-src-exts
14:08:22 <c_wraith> danilo2, and if that's not where it is, it's the package you should be using anyway. 
14:09:44 <danilo2> c_wraith: hmm, I want just a simple utility that will generate Q Expr from Haskell string and I dont want to create custom solution for that. I'm looking into this package! I know that there is "built-in" haskell quasiquoter - if you write "let a = [haskell| 1 + 2 |]" it works
14:09:52 <ertesx> babelchips: "head"?  you mean the first item?
14:11:19 <babelchips> ertesx:  Yeah.  The non-mutable version supports head but Mutable doesn’t. I’ve been treating it as a superset and assuming DVS and DVSM overlap in some way...
14:11:31 <glguy> danilo2: I don't think Template Haskell offers a  String -> Q Exp
14:12:24 <danilo2> c_wraith, glguy : it does, I've just found it! :) haskell-src-meta
14:12:54 <ertesx> babelchips: the head item is the item with index 0…
14:13:09 <glguy> That's not Template Haskell, but it uses Template Haskell, and it's incomplete, but if it does what you want, great!
14:14:25 <danilo2> glguy: yeah, the incompletness is a bad side of it, because it is not maintained as part of GHC :/ but yeah, it does what I want. I'm afraid it will not support some syntax from ghc8 though
14:14:42 <babelchips> ertesx: :) Maybe I should have picked a better example!  Don’t worry it was my assumption about the Mutable version somehow being linked functionally to the non-mutable one.  But I’m slowly realising that’s not the case!
14:14:51 <danilo2> glguy: I didnt wanted TH to support something like that. I Just wanted String -> THSomething
14:15:11 <glguy> cool
14:15:50 <orion> From what I understand, type classes are implemented as an extra parameter passed to each function ("dict") which contains the functions for the given type. It seems that many things on the type level can be brought down to the value level. What can types do that values can not?
14:17:03 <monochrom> types are statically known. values are not. that's what types can do.
14:17:30 <c_wraith> orion, types get handled by the compiler. with more interesting classes, the compiler ends up writing code for you. 
14:17:40 <monochrom> values can wait for run time. types cannot. that's what values can do.
14:18:39 <monochrom> This is meant to be tautological. Static semantics can be statically resolved. Dynamic semantics can be dynamically resolved.
14:18:42 <ertesx> babelchips: well, technically the immutable vectors are built on the mutable ones, but consider that an implementation detail…  the two have almost nothing in common semantically
14:19:03 <ertesx> babelchips: even just reading an element has vastly different types for the two
14:19:29 <babelchips> ertsex: I think that’s where I’ve been struggling - trying to marry them up somehow
14:19:41 <ertesx> yeah, don't =)
14:20:08 <babelchips> ertesx: have you used OpenGL with Haskell  much yourself?
14:20:13 <ertesx> babelchips: sometimes it makes sense, for example when using 'create' or 'modify'
14:20:57 <ertesx> babelchips: i've done a bunch of effects and benchmarks, but nothing fancy (yet)
14:22:47 --- mode: ChanServ set +o glguy
14:23:24 <mniip> orion, dependent kinding
14:23:34 <babelchips> ertesx: I’m loving the way the Graphics.GL bindings produce really clean looking code (combined with Haskell)
14:24:28 <babelchips> ertesx: it’s better than writing openGL in C
14:24:39 <ertesx> babelchips: yeah, as far as you can consider GL code "clean" =)
14:26:30 <babelchips> ertesx: yeah good point!  :)  Haskell is really helping me enjoy writing C code again!
14:28:34 <mniip> orion, consider
14:28:35 <ertesx> oh, you like computer games?  don't worry, the lovely puzzle-solving aspects of C come back soon enough by virtue of what has to be the most pointlessly convoluted API i've ever witnessed =)
14:28:57 <mniip> type family Id (a :: k) :: k where Id False = True; Id x = x
14:29:19 <mniip> this family has a dependent kind
14:29:31 <mniip> k is a relevant kindvar and is pi (not forall) quantified
14:29:32 <danilo2> Hello guys! Can TH reify a type of a variable from a scope? 
14:30:13 <babelchips> ertesx: i’d love to do some Vulkan in Haskell using similarly clean bindings but it’s early days still I think
14:30:16 <hodapp> hmmm. Haskell did a great job helping me avoid write C code, while still letting me write it when needed.
14:31:07 <ertesx> babelchips: also the potential audience of your virtual stage will be minimal right now…  you need bleeding edge hardware and drivers
14:31:10 <mniip> wohoo
14:31:34 <mniip> fst :: Product k f => k (f a b) a
14:32:40 <c_wraith> danilo2, nope. it runs before type checking. 
14:32:57 <babelchips> ertesx: Yeah, a fun journey ahead.
14:34:23 <ertesx> babelchips: also vulkan is *extremely* verbose…  it's a more sensible API, but a very low-level one, too…  for most graphical applications it probably doesn't pay off without some abstraction
14:37:12 <babelchips> ertesx:  I’m happy with GL really. Metal would be nice (for the same reasons as Vulkan) but compiling Haskell for iOS and Mac OS is not good from what I can tell.
14:40:23 <danilo2> c_wraith: hmm, top-level splices can do it - becasue of that we've got multi-part file compiling. But I see that in expressions it is impossible though. Ok, thank you :)
14:41:31 <c_wraith> danilo2, it boils down to being able to see the type of things that have already been type checked - ie, other modules that you depend on. 
14:42:53 * hackagebot glirc 2.3 - Console IRC client  https://hackage.haskell.org/package/glirc-2.3 (EricMertens)
14:45:04 <orion> mniip: How do you pronounce, "type family Id (a :: k) :: k where Id False = True" ?
14:45:23 <mniip> ?
14:46:30 <orion> I am not sure what "(a :: k) :: k" means.
14:46:40 <mniip> it's a type family head
14:47:08 <mniip> type family TyFam (var1 :: kind1) (var2 :: kind2) :: resultKind
14:47:09 <hpc> it means a :: k, and (Id _) :: k
14:47:43 <mniip> more like
14:47:48 <mniip> (Id (a :: k)) :: k
14:56:50 <danilo2> Ok, one more TH question - when reifying a type, can we ask GHC to expand it before we get the reified version? I've got some type fmailies applications resulting in Nat and I want to get this Nat in TH
14:57:20 <danilo2> I assume not, which should be argumented that when executing TH we could not know all possible instances
14:57:24 <danilo2> am I right? :(
15:15:55 <orion> mniip: I thought kinds were represented by asterisks.
15:16:27 <geekosaur> * is the kind of normal values
15:16:31 <mniip> well some things are kind-polymorphic
15:16:37 <monochrom> * is one specific kind, but not the only possible kind.
15:16:45 <geekosaur> DataKinds extension lets you create your own kinds, which you can use for tagging
15:16:55 <mniip> :k Proxy
15:16:56 <lambdabot> k -> *
15:17:15 <mniip> this lets you have Proxy Int, Proxy Maybe, Proxy Proxy, without kind errors
15:17:47 <geekosaur> I should ay of normal types, not normal values
15:18:00 <geekosaur> (since kinds apply to types)
15:19:39 <orion> So in (a :: k) :: k, 'a' and 'k' are kind variables in the same way that func :: a -> b -> c are type variables?
15:20:12 <mniip> a is a type variable
15:21:17 <geekosaur> that's actually missing a piece
15:21:18 <geekosaur> Id (a :: k) :: k
15:21:34 <geekosaur> Id is a type function that takes a type a of kind k, and produces a type of kind k
15:23:59 <orion> I don't see the usefulness of "type family Id (a :: k) :: k where Id False = True; Id x = x"
15:24:23 <mniip> it's not useful but it's a demonstration of violation of parametric polymorphism
15:24:43 <mniip> because dependent kinds
15:24:44 <monochrom> but that's useful :)
15:24:57 <orion> If 'Id' is a type function, how are you able to apply a value (False) to it?
15:25:07 <mniip> False is a type
15:25:10 <geekosaur> False is not a value there, but a type
15:25:11 <mniip> of kind Bool
15:25:25 <orion> I thought Bool was a type and False/True were values for that type.
15:25:35 <geekosaur> this is an example of DataKinds in action, where things originally defined at value and type level get promoted to type and kind level,r espectively
15:25:39 <mniip> same thing in presence of DataKinds
15:27:01 <orion> This is so foreign to me.
15:27:06 <geekosaur> there is no confusion because the type and value levels are distinct, so the compiler will never confuse the type-level False with the value-level False
15:27:45 <geekosaur> (because you can't use types as values, so if it ever sees a type in an "expression", it knows the expression is at type level)
15:27:57 <mniip> errr no
15:28:00 <orion> So with DataKinds and the above definition of Id, I can write a function "foo :: Id False -> Foo" ?
15:28:10 <mniip> if it ever sees a value constructor in a type it knows the constructor is promoted
15:28:13 <mniip> not vice versa
15:28:41 <mniip> no
15:28:50 <mniip> Id False :: Bool
15:28:54 <mniip> and -> wants a *
15:29:13 <monochrom> simply say "if it sees () in a type, that's the () type not the () value" and be done with it :)
15:30:10 <monochrom> more interesting is the [] type. now there are two of them :)
15:30:25 <mniip> the () type too actually
15:30:30 <mniip> and (,)
15:31:08 <monochrom> kind-directed type resolution
15:32:09 <orion> How can I write a function that takes advantage of Id {false/True}?
15:33:02 <hpc> you'd probably start with a GADT or something, to take advantage of the False and True types to begin with
15:34:35 <mniip> monochrom, wait is [] as tricky as (,) ?
15:34:58 <c_wraith> yep. 
15:35:00 <hpc> [] is just a bit silly, because [] :: * -> * but [] also :: [a]
15:35:27 <hpc> and of course the major difference is, the kind of [] has a root of (->) but [] has a root of []
15:36:15 <hpc> (in some ways that makes it easier, if you've applied [] to something then you know that [] is actually [] and not [])
15:36:21 <hpc> ((yes i am being ambiguous on purpose))
15:37:27 <fartmaster> so am i understanding this right that in haskell recursion is favored over loops?
15:37:58 <hpc> not so much "favored" as recursion is available to you and loops are not
15:38:09 <fartmaster> when i loop in code, i'm careful to always have some kind of maximum number of iterations. is there a favored way of doing this in haskell?
15:38:18 <hpc> but you can write loop-like control flow yourself using recursion or other loop-like functions
15:38:39 <fartmaster> right, but restricting the depth of the recursion is important for writing non-crap code
15:38:42 <hpc> and in fact, the haskell ecosystem has a much wider variety of "loops" than you'll find in any other language
15:39:17 <hpc> ghc's execution model makes "how deep you are recursing" very different from what you're likely used to
15:39:24 <hpc> @src forever
15:39:24 <lambdabot> forever a = let a' = a >> a' in a'
15:39:52 <hpc> a function call doesn't immediately create a stack frame that persists until it returns or anything like that
15:39:59 <fartmaster> ok?
15:40:35 <hpc> there is a stack, but it's for evaluation
15:40:51 <hpc> it basically expresses "to evaluate this i have to evaluate that, which requires evaluating some other thing"
15:41:08 <fartmaster> right, laziness
15:41:09 <hpc> and controlling the size of that matters at times
15:41:10 <c_wraith> you also have corecursive loops where infinite depth is expected. 
15:41:43 <fartmaster> as a simple example of this, the default Integer type ,... if i tell it to multiply a couple of huge numbers
15:42:03 <fartmaster> instead of saying overflow and stopping in a well-defined amount of time
15:42:10 <fartmaster> it will compute sorta forever
15:42:21 <hpc> when you do that, it's calling out to libgmp, which is written in C
15:42:34 <hpc> (with ghc)
15:42:37 <fartmaster> which is nice if you truly need bigint
15:42:40 <c_wraith> you would need truly huge numbers for Integer to fail. 
15:42:50 <c_wraith> like.. not fitting in RAM
15:42:50 <fartmaster> right, i'm thinking about this differently 
15:43:22 <fartmaster> right but if you want some control over the timing of the execution of your code
15:43:44 <fartmaster> you can't have your codebase littered with computations which sometimes will take 1 msec and othertimes might take ten minutes
15:43:46 <orion> Could someone please point me to a well-written package which takes advantage of DataKinds/PolyKinds?
15:43:52 <hpc> fartmaster: in which case don't use Integer
15:43:58 <hpc> that problem exists in any language with bignums
15:44:13 <fartmaster> right but i'm concerned that this philosophy is endemic
15:44:18 <fartmaster> to many implementations in haskell
15:44:24 <fartmaster> i'd need to audit all the libraries i use
15:44:30 <fartmaster> and make sure they don't use Integer
15:44:31 <c_wraith> there's always the timeout module. 
15:44:47 <fartmaster> and likewise any other kind of computation which can theoretically take forever
15:44:50 <cloudhead> is there something close to a 2d array in haskell? With O(1) access and fixed size?
15:45:10 <hpc> cloudhead: Array (Int, Int) is one
15:45:14 <c_wraith> any value (mostly) in Haskell can diverge. 
15:45:25 <c_wraith> it's just plain different. 
15:45:25 <fartmaster> diverge as in take forever to compute
15:45:28 <hpc> yes
15:45:32 <fartmaster> yeah
15:45:36 <hpc> because thunks are effectively function calls
15:45:36 <fartmaster> well that's concerning
15:45:41 <hpc> any function call can potentially diverge in C
15:45:47 <fartmaster> really?
15:45:54 <kadoban> fartmaster: Welcome to programming? Everything can fail to compute.
15:46:02 <c_wraith> if that's too concerning, use timeouts. 
15:46:04 <cloudhead> hpc: interesting, thanks
15:46:06 <hpc> unless you read the source of that function, assume it launches nuclear missles and eats babies
15:46:11 <kadoban> (Not really true, there's some languages that can guarantee with the type system, but they're harder than haskell)
15:46:20 <fartmaster> well actually i'm saying that i'd prefer that the code fails to compute and guarantees finite execution time
15:46:24 <hpc> nobody actually writes sprintf() so it fails to terminate in C, of course
15:46:34 <fartmaster> than that it hangs doing some kind of fifty day computation
15:46:39 <kadoban> fartmaster: Nothing in ... any language that's commonly used prevents that.
15:47:00 <fartmaster> kadoban: but it's in the JPL coding guidelines
15:47:03 <hpc> and ditto in haskell, you won't find a print operation that fails to terminate on its own
15:47:06 <c_wraith> fartmaster, then use System.Timeout and stop worrying. 
15:47:13 <hpc> maybe you give it an infinite string, but... don't do that
15:47:20 <fartmaster> so i litter my code with system.timeout everywhere?
15:47:35 <fartmaster> in C i can restrict myself to a single while loop which is the main execution thread
15:47:48 <fartmaster> and then everything else is a for loop with some kind of finite timeout
15:48:11 <hpc> for loops can diverge
15:48:13 <glguy> fartmaster: Haskell is like C, you can't count on everyone else having followed the JPL coding guidelines
15:48:39 <hpc> for (int i = 0; i < 5; i++) { i--; }
15:48:55 <hpc> better not pass &i to any functions!
15:49:20 <deank> fartmaster write an timeoutIn :: Int -> IO a -> IO a function, then wrap IO body in main (or whenever) with it
15:49:24 <kadoban> fartmaster: None of this is limited to any particular language, it's certainly not specific to haskell.
15:49:37 <hpc> basically, the abstraction boundaries of "will this thing even compute?" are exactly as non-existent in haskell as they are in C
15:50:24 <fartmaster> i'm saying that for loops are good and while loops are bad
15:50:51 <fartmaster> and i think haskell is littered with while loops, whereas C, less so... maybe not perfect
15:51:16 <maerwald> that doesn't make a lot of sense
15:51:22 <kadoban> They're equally powerful and dangerous? And ... no not really.
15:51:40 <fartmaster> well, provided that the for loop is written non-pathologically
15:51:57 <maerwald> you can express for loops with while loops
15:52:03 <hpc> what's "pathological"?
15:52:06 <fartmaster> right and vice versa
15:52:14 <hpc> if we restrict haskell to non-pathological examples it always terminates too
15:52:18 <maerwald> yes, so that general statement doesn't make a lot of sense
15:52:22 <kadoban> Haskell doesn't use much of either really. A 'map' is a lot closer to a for loop, except it's even safer. It's like a foreach that C doesn't have.
15:52:31 <fartmaster> for (; true; )
15:52:43 <fartmaster> would be an example of a pathological for loop
15:53:04 <fartmaster> right
15:53:04 <hpc> fartmaster: can you provide a full specification of for loops that are pathological?
15:53:22 <hpc> fartmaster: (don't actually do that, it's going to be very long if you want to include everything that isn't guaranteed to terminate)
15:53:22 <maerwald> I smell a troll bait, actually :P
15:53:23 <fartmaster> hpc: maybe,... any non-bounded computation
15:53:34 <hpc> that's a stupid definition
15:53:45 <mniip> what computation is bounded
15:53:59 <hpc> "X is bounded when you take away the non-bounded Xs"
15:54:07 <kadoban> That definition is pretty circular. You're defining for loops as "good" and then saying well any for loop that isn't good is pathological, so we don't care about it.
15:54:15 <fartmaster> bounded as in you must compute in this amount of time else generate failure code
15:54:26 <mniip> what's this amount?
15:54:30 <fartmaster> or, if not time, then iterations
15:54:46 <hpc> fartmaster: so for(i = 0; i < j; i++); is pathological by your definition
15:54:59 <fartmaster> i suppose this discussion does expose that time might be a better bound than iterations
15:55:06 <fartmaster> j is bounded somewhere else
15:55:11 <hpc> is it?
15:55:17 <hpc> why should you assume that
15:55:23 <fartmaster> or you assert a limit on j on the prior line
15:55:32 <hpc> that's not part of the for loop though
15:55:34 <fartmaster> or something to that effect
15:55:44 <fartmaster> that's true, but if it's immediately adjacent that's fine,...
15:55:49 <hpc> so you've now imposed context on what's a valid loop
15:56:04 <hpc> we can no longer consider what's a "good" loop without considering the entirety of the program preceeding it
15:56:24 <hpc> which eliminates any sort of modular reasoning power you have
15:56:30 <hpc> and THAT is bad
15:56:32 <joe9> I am trying to figure out how to use "throw" of https://hackage.haskell.org/package/safe-exceptions-0.1.4.0/docs/Control-Exception-Safe.html .
15:56:40 <fartmaster> modular reasoning? i don't think i quite understand
15:56:45 <joe9> Are there any code samples that can help me, please?
15:56:47 <fartmaster> and i also don't understand the "entirety" of the program
15:57:00 <joe9> this is for a synchronous exception
15:57:07 <maerwald> hpc: it's a troll, he now forces you to define things and is going to nitpick on your definitions
15:57:26 <fartmaster> i'm not trying to troll nor am i trying to nitpick
15:57:58 <fartmaster> i'm trying to understand what you mean by modular reasoning and why you consider a one line check like assert(j < MAX_J); as something which draws in the full program
15:58:27 <mniip> so it's not loops that are bad
15:58:41 <hpc> modularity is considering a piece of code independent of what's around it
15:59:05 <hpc> it's a required part of programming in any form
15:59:19 <fartmaster> if loops are not bad, then what is?
15:59:43 <hpc> if you can't say "i know what this does as a single unit", you have to include understanding of something outside it
16:00:00 <hpc> and what something that is depends on what's happening outside it
16:00:07 <mniip> fartmaster, your code?
16:00:10 <hpc> and what's happening outside it depends on what's happening further outside it
16:00:23 <mniip> the entirety of it, not just the loop construct of the language
16:00:27 <fartmaster> ok so if i define a "iteration restricted for loop" as:
16:00:39 <fartmaster> (1) a block of code containing a for loop with asserts immediately prior
16:00:39 <hpc> repeat until you're forced to trace a thread of logic from start to finish in order to consider one line of code
16:01:04 <mniip> asserts what
16:01:16 <fartmaster> ah i see
16:01:24 <fartmaster> you're going to say that something could modify the iterator accidentally
16:01:31 <kadoban> fartmaster: Which, by the way is really easy to do in haskell if that's really what you want to do: map whatever (take 10 something)  or mapM_ or whatever you need.
16:01:51 <fartmaster> somewhere in the code a line could say i = 3;
16:01:55 <kadoban> Which is, safer if anything.
16:02:00 <fartmaster> and now my i < 5; loop never terminates
16:02:14 <hpc> where i am actually planning on going with this is the halting problem, and if you really want proven termination you have to go weaker than turing completeness
16:02:35 <fartmaster> but you can always check the wall clock time
16:02:45 <fartmaster> so really the way to think about this perhaps is
16:02:45 <hpc> when?
16:02:56 <fartmaster> at any time in your code, you can look at the wall clock time
16:03:03 <fartmaster> so you can always stop computing
16:03:08 <hpc> okay, so when?
16:03:09 <kadoban> fartmaster: Which is what you mocked before, about putting timeouts everywhere? So why is that ridiculous in haskell but not in C?
16:03:14 <hpc> before or after the never-terminating computation?
16:03:18 <hpc> or in between?
16:03:20 <fartmaster> i'm saying that you're convincing me that timeouts are better
16:03:23 <fartmaster> than i had expected
16:03:29 <fartmaster> i was thinking in terms of trying to restrict the variables
16:03:41 <hpc> how granularly in-between are you willing to go?
16:03:48 <dmwit> There is certainly a fragment of Haskell which is terminating. e.g. if one only ever uses structural recursion.
16:03:57 <kadoban> Oh, timeouts are pretty terrible in general. You *very* rarely want to settle for a quick, wrong answer (or error) instead of a correct answer.
16:04:06 <hpc> how primitive do you need to get in the language to give up and say "this line of code will terminate"?
16:04:06 <dmwit> GHC doesn't happen to have a termination checker, but there are languages which do this.
16:04:40 <monochrom> You write fewer loops in Haskell than in C.
16:04:47 <dmwit> Certainly C doesn't do that; though again there may be a fragment of C which is terminating and which it is easy for humans to check membership of.
16:04:48 <fartmaster> i'm not mocking timeouts i just thought it wasn't a good idea
16:04:49 <hpc> and then you need to set up the style guidelines to actually follow that
16:04:51 <Joh_> cya ppl
16:04:55 <monochrom> No no, that's the wrong way to put it.
16:05:09 <monochrom> You write fewer recursions yourself than you write loops yourself in C.
16:05:10 <hpc> (if you are planning to use timeouts)
16:05:24 <kadoban> fartmaster: Well, that's because it's not.
16:05:51 <monochrom> The logical conclusion is that in Haskell you can afford more time reviewing your recursions in Haskell and not need restrictions.
16:06:01 <fartmaster> these wallclock checks are dirt cheap?
16:06:30 <dmwit> I wonder whether we have managed to keep sight of the real goals during this discussion.
16:06:37 <hpc> fartmaster: sure, but they do you no good if they aren't happening until after infinity time has passed
16:06:44 <kadoban> I wonder if there *are* real goals.
16:07:06 <monochrom> No, people always lose sight of the real goals. People always get nerd-sniped.
16:07:20 <hpc> the original question was "so am i understanding this right that in haskell recursion is favored over loops?"
16:07:23 <fartmaster> the goal, as i was trying to describe it, is that i'd like to make sure that i have a reliable grip on whether my computation is taking a ridiculous amount of time, and if so stop and do something else
16:07:31 <hpc> and it turned into "what's the difference"
16:07:43 <fartmaster> hey guys i'm not questioning that you guys know more than i do
16:08:11 <fartmaster> my opinion of haskell is generally changing for the better
16:08:58 <johnw> fartmaster: the reasons it might be slow are many; it's not just a distinction between recursion and looping (which sometimes are the same thing, where GHC is concerned)
16:09:11 <hpc> fartmaster: going back to modular reasoning, because this will genuinely make you a better programmer, take a look at https://en.wikipedia.org/wiki/Hoare_logic#Hoare_triple
16:09:18 <kadoban> fartmaster: Rarely do you do explicit checks on what "ridiculous amount of time" is. In any language really.
16:09:27 <hpc> fartmaster: and find a book or something that goes over them in detail
16:09:30 <fartmaster> kadoban: what do you do, then
16:09:47 <hpc> fartmaster: and apply that to some of your own code, ideally something somewhat simple
16:09:54 <dmwit> fartmaster: Can you comment briefly on what techniques you use to have a reliable grip on whether your computation is taking a ridiculous amount of time in your preferred language?
16:10:01 <hpc> fartmaster: you'll be amazed at how quickly the environment of "things i need to keep track of" grows
16:10:12 <fartmaster> i'm not saying that i'm good at practicing this myself
16:10:13 <kadoban> fartmaster: You reason about performance in pretty standard ways and trust that your reasoning is correct.
16:10:29 <mniip> meanwhile I did a thing
16:10:32 <mniip> :t safeMap
16:10:34 <lambdabot> (a -> b) -> [a] -> [b]
16:10:43 <mniip> > safeMap ord "hello world"
16:10:45 <lambdabot>  [104,101,108,108,111*Exception: Too much
16:11:04 <mniip> implemented as a foldr over State
16:11:46 <hpc> fartmaster: a fun thing you'll find with hoare logic is that the reasoning for while loops is significantly simpler than the reasoning for for loops
16:12:12 <dmwit> > safeMap id (fix (drop 1))
16:12:16 <lambdabot>  mueval-core: Time limit exceeded
16:12:23 <mniip> duh
16:12:29 <fartmaster> i mean you could argue that in C i could have some some kind of pointer which points to the address of my variable used to control the number of for loop iterations
16:12:44 <fartmaster> and then my reasoning is all just junk
16:12:44 <mniip> terminating computations -> terminating computations :p
16:13:04 <dmwit> map already has that property
16:13:16 <mniip> you could have infinitely many terminating computations
16:13:28 <kadoban> fartmaster: Yes ... which you shouldn't do.
16:13:45 <dmwit> mniip: Not if you want to terminate.
16:14:04 <mniip> and I just realized that I solved a really simple thing in a very complex way
16:14:16 <dmwit> yes =)
16:14:23 <mniip> State to count over a list...
16:14:24 <dmwit> :t map . take 5
16:14:26 <lambdabot>     Couldn't match type ‘[a1]’ with ‘a -> b’
16:14:26 <lambdabot>     Expected type: [a1] -> a -> b
16:14:26 <lambdabot>       Actual type: [a1] -> [a1]
16:14:31 <dmwit> :t (map .) . take 5
16:14:33 <lambdabot>     Couldn't match type ‘[a2]’ with ‘a -> a1 -> b’
16:14:33 <lambdabot>     Expected type: [a2] -> a -> a1 -> b
16:14:33 <lambdabot>       Actual type: [a2] -> [a2]
16:14:48 <mniip> :t (. take 5) . map
16:14:49 <lambdabot> (a -> b) -> [a] -> [b]
16:14:56 <Koterpillar> that's not it
16:15:07 <mniip> yes it is
16:15:11 <dmwit> No, it's better: it doesn't throw an exception if you give too much stuff.
16:15:33 <hpc> exceptions are terminating ;)
16:15:41 <mniip> > fix error
16:15:44 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
16:15:51 <hpc> mniip: hooray, it works!
16:15:56 <benzrf> thats what happens if u try to fix error
16:16:00 <benzrf> just let errors be
16:17:48 <fartmaster> alright well thanks guys
16:17:52 <hpc> fartmaster: anyway welcome to #haskell, where "is this list empty" turns into a huge philosophical debate and "are zygohistomorphic prepromorphisms in the category of monoidal endofunctors isomorphic to transfinite diagonalization" gets answered with "yes, here's the DOI reference"
16:18:02 <fartmaster> hahaha
16:18:10 <fartmaster> sorry, didn't mean to bikeshed
16:18:20 <exio4> it just happens, that's how we are
16:18:22 <hpc> as long as you learned something
16:18:34 <hpc> discussion is what this channel is for after all
16:18:36 <fartmaster> wow zygohistomorphic prepromorphisms are a real thing
16:18:37 <fartmaster> lol
16:18:49 <mniip> is (⊥:⊥) half-empty or half-full
16:19:07 <fartmaster> what the fuck lol
16:19:21 <hpc> fartmaster: never seen a bottom before? ;)
16:19:28 <dmwit> I think everybody answering "nothing is possible in any language" missed all of the interesting parts of the question, honestly.
16:20:33 <dmwit> I would personally be very interested to read a Haskell analog to JPL's C guidelines.
16:21:24 <mniip> "The coding rules defined here primarily target the development of mission critical flight software written in the C programming language. "
16:21:25 <dmwit> And it's not like we're missing the expertise in here to suggest a few such rules of thumb.
16:21:28 <hpc> honestly, that guideline would likely turn into "use another ML-family language with strong normalization"
16:21:39 <mniip> you have to have a rather twisted mind to let a graph reduction machine control your flight
16:21:59 <fartmaster> dmwit: thanks, yeah, that's part of what i was getting at
16:22:25 <dolio> Strong normalization isn't good enough for flight software.
16:22:33 <kadoban> dmwit: "Don't use haskell" would be pretty high on the list, wouldn't it?
16:22:50 <dmwit> For termination: restrict yourself to structural recursion. That is all you need for very many interesting things anyway. For hard real-time: that might be harder. I'm not sure if we have much expertise on that floating around.
16:23:05 <hpc> dmwit: the GC is another big sticking point too
16:23:12 <dmwit> kadoban: Not on my list.
16:23:26 <kadoban> dmwit: Well, these kinds of coding guidelines are for like real-time, no?
16:23:35 <hpc> you might have to come up with something like "never use more than X RAM" or "only values of these types can escape the nursery"
16:23:44 <hpc> which... that would be a neat thing to try out
16:23:46 <dmwit> hpc: Indeed, a very good version of the list would need to talk about how to manage memory.
16:23:53 <hpc> if something like that could even be written into GHC
16:24:11 <hpc> something like ST would feature heavily in it i would expect
16:24:19 <hpc> or maybe you use haskell to generate some DSL
16:24:36 <Gurkenglas_> Can you complete the rectangle ((^?!), view, use)?
16:24:43 <hpc> and then you can use the type-system to control a much more wacky language like whatever assembly the flight controller uses
16:24:48 <mniip> Rule 4 (recursion) There shall be no direct or indirect use of recursive function calls. [MISRAC:2004 Rule 16.2; Power of Ten Rule 1]
16:24:58 <fartmaster> so is this zygo..gobbledigook something that i would need to understand to write a significant haskell program?
16:25:00 <dolio> I think a domain specific language is all you get to do.
16:25:03 <benzrf> fartmaster: lmao no
16:25:07 <exio4> fartmaster: nah, it's more of a joke ;)
16:25:08 <hpc> fartmaster: it's a joke
16:25:15 <fartmaster> with C the entire language fits in a small booklet
16:25:29 <hpc> it's haskell's version of java's AbstractSingletonFactory
16:25:38 <fartmaster> and when i read K&R i feel confident that i know every single line
16:25:40 <mniip> haskell report is pretty small too
16:25:46 <mniip> but there's a lot of theory behind it
16:26:03 <hydraz> zygohistomorphic prepromorphisms?
16:26:03 <mniip> and you have to understand it if you want to be competent in haskell
16:26:07 <fartmaster> with haskell i have this anxiety that there is an infinity of abstractions
16:26:09 <mniip> nope none of those
16:26:11 <fartmaster> rather than a finite number of them
16:26:32 <exio4> the haskell report is written in a surprisingly clear english to be the specification of a programming language, though
16:26:35 <mniip> True :: Bool, Bool :: *, * :: *, * :: *, * :: *, * :: *, * :: *, * :: *
16:26:40 <dolio> Why weren't you anxious that in C you had no abstractions, and that was awful?
16:26:45 <fartmaster> the document i want is "the haskell report"
16:26:51 <dmwit> fartmaster: The Report is only like 30 pages long, and quite readable.
16:26:55 <dmwit> ?where Report
16:26:55 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
16:27:02 <exio4> mniip: hahah 
16:27:06 <fartmaster> ok i'll try it
16:27:08 <glorias> hi
16:27:18 <hpc> mniip: but then what's the type of *?!?!?!
16:27:21 <glorias> Im a Code Monster :-)
16:27:27 <mniip> hpc, see above
16:27:51 <hpc> oh i see, * :: (*, * :: (*, * :: ...
16:28:02 <glorias> all is clear if u look at the code
16:28:11 <glorias> stand 2 meters  away ;-)
16:28:35 <glorias> code is like music
16:28:46 <glorias> and mathematics
16:28:48 <hydraz> datakinds confuses me to no end
16:28:59 <dmwit> glorias: Do you have a Haskell question?
16:28:59 <mniip> haskell code is mathematics
16:29:04 <glorias> yes
16:29:23 <glorias> could u pl4ease give me a simple 
16:29:24 <hpc> hydraz: it's easy, just imagine universe polymorphism and restrict it to the special case of Set 0 and Set 1 :P
16:29:31 <glorias> code example
16:29:38 <hpc> (the haskell version of "imagine an n-dimensional space where n = 4)
16:29:44 <glorias> I love mathematics
16:29:51 <fartmaster> mathematics doesn't love you
16:29:55 <glorias> Data and alghorythmen
16:30:05 <dmwit> glorias: There are many good tutorials online; any of them would be a fine resource for code samples.
16:30:06 <hydraz> a haskell oneliner? (nub .) . flip (filter . (. head) . (==)) . permutations
16:30:13 <sm> main = print "hello world"
16:30:13 <glorias> why u say so stinky master?
16:30:22 <exio4> sm: putStrLn! 
16:30:32 <glorias> I studie computer sience
16:30:39 <glorias> last semester
16:30:45 <mniip> Rule 5 (heap memory) There shall be no use of dynamic memory allocation after task initialization. [MISRA-C:2004 Rule 20.4; Power of Ten Rule 3]
16:30:51 <mniip> so we can do what ghci does
16:30:56 <mniip> allocate a terabyte and go with it
16:31:08 <glorias> I do not have to stidie - I do it for fun
16:31:12 <glorias> u
16:31:21 <fartmaster> can the haskell compiler be formally verified
16:31:27 <sm> exio4: typical.. my four word program has a bug
16:31:32 <hpc> mniip: and use virtual memory? does that even work?
16:31:40 <glorias> love isw love
16:31:44 <exio4> mniip: well, that's actually a way to do memory management
16:31:46 <glorias> I love Debian
16:31:56 --- mode: ChanServ set +o dmwit
16:32:12 <glorias> We get build to be Hackers
16:32:13 <dmwit> glorias: Please stay on the topic of Haskell.
16:32:24 <glorias> okay
16:32:36 <cromachina> embedded haskell
16:32:38 <glorias> I programm everything wich moves
16:32:42 <glorias> :-)
16:33:11 <fuki> hi all, is there any generic place i could go for general pointers about functional programming?
16:33:13 <glorias> Machines  and engines love me
16:33:28 <glorias> but Haskel - wow respect u all very much
16:33:33 --- mode: ChanServ set +o shachaf
16:33:49 <glorias> u know siems and trumpf?
16:33:54 <glorias> siemens
16:33:56 * sm watches all the ops arming up
16:34:12 --- kick: glorias was kicked by dmwit (You may come back when you have something on-topic to contribute.)
16:34:28 <hpc> fuki: sometimes here, if those pointers will be for improving haskell
16:34:51 <hpc> or various other functional language channels
16:34:51 <fuki> well, i'm trying with F# right now as its closer to C# which is where i'm coming from
16:34:53 <dmwit> fuki: There is also a code review StackExchange that may be worth visiting if you have already written a chunk of code.
16:35:00 --- mode: dmwit set -o dmwit
16:35:00 <fuki> so not haskell right now
16:35:13 <sm> there's an fpchat slack channel isn't there
16:35:24 <sm> also https://en.wikipedia.org/wiki/Functional_programming
16:35:38 <fartmaster> alright guys may the foldr be with you
16:35:56 <hydraz> Does point-free style have any (positive or negative) performance implications? is blah . bleh $ foo faster than blah $ bleh $ foo?
16:35:57 <fuki> i am trying to understand if what i wrote is too OO, or if its more or less appropriate
16:36:00 <fuki> design wise
16:36:08 <hpc> iirc there's a generic ##categorytheory or something like that but it's not the most useful place to go?
16:36:14 <sm> hydraz: no
16:36:25 <dmwit> hydraz: I believe (.) and ($) are inlined and compiled away when they're saturated.
16:36:27 <hpc> i might be misremembering, i don't go channel surfing on irc very much
16:36:30 <dmwit> hydraz: ...as they are there.
16:36:35 <hydraz> Good
16:36:46 <dmwit> hydraz: ...in GHC. =P
16:37:09 <hydraz> I only use the GHC :P
16:37:49 <ertesx> IRC needs multikicks…  and perhaps fatalities
16:37:49 <hpc> if we qualified everything that's not specified in the report with "in ghc", i wonder what proportion of lines would contain that string
16:38:02 --- mode: shachaf set -o shachaf
16:38:53 <fuki> anyhow, thanks i suppose.. i guess i'll just try waiting and see if anyone on the f# channel will reply
16:39:20 <hydraz> dmwit: Hm, what does 'saturated' mean in this context?
16:40:07 <dmwit> hydraz: Ah! Good question. Generally it means "has been given all its arguments". But that's a deceptively simple answer because how many arguments is all of them, right?
16:40:18 <dmwit> hydraz: For (.) and ($), I believe two is all of them.
16:40:22 <hydraz> I see
16:40:35 <dmwit> But we can check the source to find out for sure.
16:40:59 <hydraz> Though I'm pretty sure (.) takes three arguments
16:41:05 <dmwit> (.) f g = \x -> f (g x)
16:41:12 <dmwit> from https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#.
16:41:14 <ertesx> hydraz: unless you literally compute functions (example: foldl' (.) id), the cost is either negligible or zero
16:41:41 <hpc> so "saturated" means "has been given all the arguments left of the equals sign"
16:42:08 <hydraz> I see.
16:42:08 <dmwit> And now we should ask whether `(\x -> blah (bleh x)) foo` gets compiled away to `blah (bleh foo)`.
16:42:15 <dmwit> I don't know the answer to that for sure but suspect yes.
16:42:25 <dolio> Yes. Although (.) can also be defined as `(f . g) x = f (g x)` and then you'd have to do experiments to figure out what 'saturated' means for that case.
16:42:28 <ertesx> hydraz: in principle composition is not free, but in GHC it pretty much is
16:43:05 <hydraz> dmwit: Well, given how clever compilers tend to be, I'd suspect that's a trivial inlining
16:46:04 <dmwit> hydraz: Inlining may not be the right word. But I agree with the sentiment.
16:49:34 <danilo2> Hello! :) Is there a way in Haskell to define a set of CPP pragmas in a library and import them to different files?
16:49:44 <dolio> It's not even a legal transformation in some languages.
16:49:51 <dolio> (But it is in Haskell.)
16:51:26 <dmwit> danilo2: Does #include work?
16:52:22 <danilo2> dmwit: not exactly - i dont have a "local path" to include the files. I want to include them from a library
16:52:58 <danilo2> dmwit: or just define where are the "root points" to start looking for such library. By root points I mean CPP lib paths
16:53:45 <danilo2> dmwit: by library I mean just normal hasakell's library
17:10:19 <troydm> so my Haskell app starts and then eats up all memory and gets Killed automaticly (probably by operating system or maybe GHC runtime) and I'm wondering what's the best way to start profiling it to understand what went wrong?
17:16:17 <begriffs> troydm: stack build --executable-profiling --library-profiling
17:16:28 <begriffs> stack exec -- programname +RTS -hc -p
17:17:15 <begriffs> hp2ps programname.hp
17:17:47 <begriffs> (then inspect the graph in programname.ps)
17:18:33 <Vulpyne> This may be a dumb question, but with HSpec is there any way to calculate an IO value and then run multiple tests on it? It seems like the types are set up so that's impossible and you have to run the action repeatedly but I may be missing something here.
17:19:51 <troydm> begriffs: thx, will try that
17:20:13 <lpaste> av pasted “AD weirdness” at http://lpaste.net/174291
17:20:38 <av_> hi everybody, I'm stuck and need help -- here's the code: http://lpaste.net/174291
17:21:11 <av_> basically, I need to know why three out of four examples don't work, and why
17:22:30 <Vulpyne> av_: Have you tried turning off the monomorphism restriction?
17:22:32 <av_> interestingly, I observed that some of the trials I did previously worked OK in ghci even though ghc wouldn't compile the same definitions
17:23:27 <Vulpyne> I don't know anything about whatever Numeric.AD is but the f = sum thing makes me think it could be a problem with that.
17:24:04 <Vulpyne> If that doesn't help, you probably need to be more specific than "doesn't work".
17:24:08 <zort> I'm following along here https://en.wikibooks.org/wiki/Haskell/Applicative_functors#The_monoidal_presentation and it says "Write implementations for unit and (*&*) in terms of pure and (<*>), and vice-versa." but I simply cannot see how it's possible. To write pure in terms of unit and (*&*) for example, what do you do with pure's input type a?
17:24:59 <zort> that is I can't do the "vice-versa" part 
17:25:10 <shachaf> zort: You are also permitted to use fmap
17:25:25 <zort> that would explain it
17:26:32 <av_> Vulpyne: gosh. that did it.  though I realized that some of the lines in my pasted code were commented out even though they shouldn't have been.
17:27:15 <Vulpyne> av_: It was pretty much just the f = sum thing that lead me to guess it was a monomorphism restriction issue so that didn't really matter. Glad to help!
17:27:23 <zort> shachaf: actually no, how do you do it?
17:27:34 <av_> Vulpyne: thanks a lot anyway, I'll post again if I run into more trouble
17:27:51 <pavonia> av_: You usually can avoid these problems by giving explicit type signatures for all top-level bindings
17:27:52 <shachaf> What do you have, and what do you want?
17:28:29 <av_> pavonia: that's what I normally do but this is what got me in trouble with AD in the first place
17:28:53 <Vulpyne> av_: Sure, I probably won't be able to help much if it's something specific to Numeric.AD. pavonia's advice is also helpful, I think it's always good to type annotate top level stuff (and sometimes even stuff like let bindings) because it tests that your assumptions about what types are being inferred are actually correct. It's especially important when you're just learning.
17:29:14 <Vulpyne> Does anyone have any ideas about my HSpec question?
17:29:42 <Koterpillar> Vulpyne: I think I did it, let me see
17:30:27 <Vulpyne> Koterpillar: Thanks for checking. It's not absolutely critical, it just really bugs me to have to recompute stuff for every test, when what I just want to do is run expectations on the same value a bunch of times.
17:30:34 <Koterpillar> Vulpyne: like this? https://github.com/koterpillar/uv-alert-server/blob/master/test/TestFetcherJMA.hs#L81
17:30:45 <Vulpyne> Which you actually can do, but you don't get a label for each one.
17:32:22 <Vulpyne> Koterpillar: Huh... Maybe I'm just dumb, I thought I did essentially that and it didn't work.
17:32:36 <Koterpillar> Vulpyne: see down there for the multiple labels and all
17:34:27 <Vulpyne> Koterpillar: I do see, checking...
17:40:00 <Vulpyne> Koterpillar: It still doesn't work for me. I assume your testImage and testImages things are IO actions, but they aren't type annotated. http://lpaste.net/174293
17:41:51 <Koterpillar> Vulpyne: ooh, no
17:41:57 <Koterpillar> Vulpyne: https://github.com/koterpillar/uv-alert-server/blob/master/test/Images.hs#L14
17:41:59 <Koterpillar> runIO
17:42:53 <metl> can anyone suggest a library to write a bytestring of RGB8 values to .png file?
17:43:14 <Koterpillar> I think JuicyPixels can do this
17:44:12 <Vulpyne> Koterpillar: Ahhh, that explains it! I actually saw runIO but I passed over it since it talked about "constructing the spec tree" which didn't sound like what I was trying to do.
17:44:24 <Vulpyne> Koterpillar: Thanks!
17:44:43 <metl> i was looking at it, decodeImage supposedly reads into a DynamicImage, but it doesn't take an argument for the image dimensions
17:45:49 <Koterpillar> metl: don't you want generateImage?
17:46:21 <zort> shachaf: got no clue mate http://slexy.org/view/s26yJubydd
17:46:57 <shachaf> To write pure, you don't need *&*
17:47:08 <Koterpillar> metl: decodeImage will decode your bytestring as PNG/etc.
17:47:32 <metl> Koterpillar: oh i see, the generating function threw me off. i suppose i can just index into the pixel data i already have
17:48:43 <zort> shachaf: k got it, \aard -> fmap (const aard) unit
17:50:17 <Vulpyne> Koterpillar: Any special reason you didn't use beforeAll instead of runIO? It seems to do what I'm trying to in a less lowlevel way: https://gist.github.com/nh2/eb304ed519ec75b1b120
17:51:07 <Koterpillar> Vulpyne: I like the type of testImages
17:52:35 <Vulpyne> Koterpillar: I see. Seems like you can't even get to SpecM to annotate it without depending on hspec-core explicitly. Anyway,thanks. I'll probably just use beforeAll.
17:53:10 <Koterpillar> Vulpyne: maybe I'll change it, it seemed like the most straightforward way to proceed
17:54:56 <Vulpyne> Koterpillar: Works perfectly for what I'm trying to do: http://lpaste.net/174293#a174295
17:57:21 <Koterpillar> Vulpyne: in my case, I'd like to treat testImages as static data (they are!), not as an IO action
17:58:48 <Vulpyne> Koterpillar: That's basically how it seems to work. It runs the IO action once and then passes the result for each specify/it. It does'n recompute it each time.
17:59:20 <Vulpyne> So it wouldn't be passing in an "IO whatever" type, just "whatever".
17:59:50 <Koterpillar> Vulpyne: don't think it'll be as nice here: https://github.com/koterpillar/uv-alert-server/blob/master/test/TestFetcherJMA.hs#L57
18:02:00 <Koterpillar> Vulpyne: I could wrap the whole thing in "beforeAll testImages", though
18:02:43 <Vulpyne> Koterpillar: Yeah, maybe not. You'd have to have a lambda to take the arguments for each one. beforeAll ((,,,,) <$> testImage 1 <*> testImage 4 <*> testImage 6 <*> testImage 7) . describe "imageUVLevel" $ do int "returns the correct UV level" $ \(img1,img4,img6,img7) -> etc etc
18:03:01 <Vulpyne> Err, "it" not "int" but you get the idea
18:04:25 <Vulpyne> Koterpillar: Anyway, time to go. Thanks again for the help.
18:04:33 <Vulpyne> You put me on the correct path at least!
18:04:35 <Koterpillar> Vulpyne: thanks for the before* suggestion, too :)
18:14:50 <jchia> I'm using a function that returns a Maybe a in a function that returns an Either String a. Is there a function with a type like "String -> Maybe a -> Either String a" that I can use to convert the Maybe a to an Either String a" so that I don't need to write a case expression for the Maybe?
18:15:50 <Koterpillar> :t maybe (Left "blah") Right
18:15:51 <lambdabot> Maybe b -> Either [Char] b
18:16:01 <Koterpillar> jchia: ^
18:16:05 <jchia> thanks
18:33:05 * hackagebot store 0.2.1.0 - Fast binary serialization  https://hackage.haskell.org/package/store-0.2.1.0 (MichaelSloan)
18:38:40 <metl> Koterpillar: hmm, generateImage seems to be infinitely looping, any ideas? there aren't any issues in the JuicyPixels repo
18:39:14 <Koterpillar> I haven't used it, I'm only parsing the images with JuicyPixels
18:53:08 <onel> When building a type checker plugin, is there a way to get a list of the package dbs loaded in order to compile the module being type checked?
19:04:03 <lpaste> boj pasted “better way to write this?” at http://lpaste.net/174307
19:04:37 <boj> could someone help suggest an alternative way to write this? or is it semi-acceptable?
19:05:21 <metl> ah well, looks like i can just put the bytes into a vector and create an image manually
19:16:55 <glguy> boj: it would help answer to know more about the types of things involved
19:21:58 <glguy> probably the only sorts of improvements might be too use generics to implement that, unlikely that there's much else to do
19:23:05 <glguy> possibly using something like mapAccumOf that could get a little simpler
19:30:22 <boj> glguy: ok, i was hoping that there was a more elegant way to thread that together without all the (pN, cN) daisy chaining
19:32:15 <boj> thanks for taking a glance at that
19:32:35 <glguy> mapAccumLOf would probably allow you to chain that together nicely
19:34:37 <boj> glguy: ah! that may be what i was searching for, thank you
19:38:09 * hackagebot qtah-generator 0.1.2 - Generator for Qtah Qt bindings  https://hackage.haskell.org/package/qtah-generator-0.1.2 (khumba)
19:38:11 * hackagebot qtah-cpp-qt5 0.1.2 - Qt bindings for Haskell - C++ library  https://hackage.haskell.org/package/qtah-cpp-qt5-0.1.2 (khumba)
19:38:13 * hackagebot qtah-qt5 0.1.1 - Qt bindings for Haskell  https://hackage.haskell.org/package/qtah-qt5-0.1.1 (khumba)
20:03:52 <alpha1> Hello, I saw a data type with no constructors in some source, I'm really confused on why you'd do such a thing? 
20:04:15 <alpha1> like... If you can't construct it... How do you do it?..
20:04:26 <glguy> You don't construct one, they're empty types
20:04:43 <alpha1> Why were they there?
20:04:52 <glguy> You can use one to indicate that you don't have a value of a given type, or as a "phantom" type that is just used to track information
20:05:04 <glguy> the canonical example is: data Void
20:05:23 <glguy> If I gave you an    Either Void Char, you could be pretty sure that it was a Right someChar
20:05:28 <glguy> and not a Left
20:06:19 <alpha1> I don't really get it. Why would you do that, rather than just using Char? or like... 
20:06:47 <alpha1> You Can't have a Left Void, because you can't construct it. So it's like that doesn't even exist. 
20:11:27 <pavonia> alpha1: A typical usecase for empty types is to provide informattion only at the type level, like you could have different empty types for different character encodings, and conversion functions that only work for mapping one specific encoding to another
20:12:29 <alpha1> OHhhhhhhhh That makes sense now!
20:13:19 <alpha1> I think that using an Either for that would be a bit... Misleading? wouldn't it?
20:14:00 <glguy> the point is that you can indicate that you don't have values of certain parameter types
20:14:21 <glguy> but you can still use functions that work parametrically on a data type
20:16:29 <glguy> perhaps you have a function :: [Either a b] -> Either a b
20:16:52 <glguy> if we picked a to be Void we'd know the function shouldn't return a Left
20:17:27 <kevinkjt2000-tab> alpha1: I agree that empty types make no sense
20:17:28 <glguy> there are more interesting data types than Either but this should be a simple example
20:18:07 <alpha1> It makes sense, I saw it in one of Edward Kmetts talks. 
20:18:19 <glguy> an IO Void is useful, it tells you that the action doesn't return
20:19:14 <kevinkjt2000-tab> using an empty type is what I do when I want to disprove something, by showing that I construct an empty type
20:19:25 <kevinkjt2000-tab> which usually makes the implementation empty
20:19:56 <dibblego> should forever have that type?
20:19:57 <pavonia> glguy: Wouldn't that be equivalent to an action of type IO a?
20:20:02 <alpha1> Heh... Pretending Haskell is a total language.
20:20:06 <kevinkjt2000-tab> *I agree that empty types don't make much sense in an Either is what I meant
20:20:30 <glguy> pavonia: IO Void stores nicely in other data
20:20:56 <glguy> they make perfect sense in either when used after the fact
20:21:25 <glguy> you're unlikely to see a function that asks for Either Void b
20:21:51 <glguy> but you might pick a to be Void when using a function that works on Either a b
20:23:02 <pavonia> What are examples of real-world functions that use Void?
20:23:12 * hackagebot woot 0.0.0.6 - Real time group editor without operational transform.  https://hackage.haskell.org/package/woot-0.0.0.6 (tgolson)
20:23:23 <Hafydd> Hahah.
20:24:15 <glguy> dibleggo: forevers type is easier to use as is, but it could use Void
20:24:42 <glguy> Void would be more useful in a negative position
20:25:03 <glguy> suppose you wanted to take an action that didn't return as an argument
20:25:47 <glguy> IO Void -> ...
20:26:08 <glguy> without void you might resort to a rank 2 type there
20:28:21 <alpha1> What are the drawbacks to using rank2types/rankntype extensions? I recall that bringing in GADTs kills some type inference or something. 
20:36:58 <dfeuer> There's an answer in the test-framework FAQ ( https://batterseapower.github.io/test-framework/ ) that I don't understand. It talks about tests that just call error but pass anyway. Could someone maybe explain what it's talking about or how its explanation makes sense?
20:37:43 <kevinkjt2000-tab> glguy: a monad that has a Void value seems absurd
20:38:14 <kevinkjt2000-tab> glguy: https://hackage.haskell.org/package/void-0.7.1/docs/src/Data-Void.html#vacuousM
20:38:50 <dfeuer> BTW, I just pulled a trick straight out of something Oleg once wrote. I wanted to constrain a type variable to be Int but not use any GHC extensions. So I used  class IsInt a where fromIntF :: f Int -> f a, and tacked on Ord and Show constraints for convenience (because those were the ones I needed).
20:39:07 <glguy> kevinkjt2000-tab: That's a pun, right? :)
20:39:33 <kevinkjt2000-tab> possibly :)
20:39:46 <tommd> alpha1: You miss out on some things with GADTs vs regular ADTs.  Deriving instances like Show, non head-exploding error messages, succienct syntax in some cases.
20:39:58 <dfeuer> kevinkjt2000-tab, it's not necessarily actually absurd...   foo :: IO Void; foo = putStrLn "Hello again!" >> foo
20:40:10 <tommd> Though I seem to recall something was done about the deriving issue at some point.
20:40:32 <dfeuer> I think there may be a few things that can be derived? Lots of things can't.
20:40:33 <glguy> dfeuer: It was a joke
20:40:43 --- mode: ChanServ set -o glguy
20:40:54 <dfeuer> glguy, I hope so?
20:41:03 <glguy> You do?
20:41:14 <dfeuer> Does anyone know about that test-framework question?
20:41:42 <dfeuer> > [] :: [Void]
20:41:43 <lambdabot>  Not in scope: type constructor or class ‘Void’
20:41:47 <dfeuer> > [] :: [V.Void]
20:41:49 <lambdabot>  Not in scope: type constructor or class ‘V.Void’
20:41:52 <dfeuer> > [] :: [Void.Void]
20:41:53 <lambdabot>      Not in scope: type constructor or class ‘Void.Void’
20:41:55 <dfeuer> Grr.
20:42:01 <dfeuer> > data Void
20:42:02 <lambdabot>  <hint>:1:1: parse error on input ‘data’
20:42:20 <Koterpillar> > data VoidVoid = VoidVoid VoidVoid
20:42:22 <lambdabot>  <hint>:1:1: parse error on input ‘data’
20:42:29 <dfeuer> > [] :: [Void]
20:42:31 <lambdabot>      No instance for (Show Void)
20:42:31 <lambdabot>        arising from a use of ‘show_M32318963951666550725270’
20:42:31 <lambdabot>      In the expression:
20:42:52 <kevinkjt2000-tab> > import Data.Void
20:42:53 <lambdabot>  <hint>:1:1: parse error on input ‘import’
20:43:02 <kevinkjt2000-tab> ah, that's unfortunate
20:43:09 <glguy> Do the lambdabot experiments in private message
20:43:16 <glguy> and then you can show your cleverness publicly without flooding
20:43:39 <alpha1> tmmd: What kind of drawbacks come with rankntypes? 
20:44:26 <dfeuer> > [] :: [Void]
20:44:28 <lambdabot>  []
20:44:29 <dfeuer> Sorry, glguy 
20:45:14 <dfeuer> alpha1, well, Oleg wrote an essay called "Impredicativity Bites", which gets into even the limited impredicativity of RankNTypes. I'm not sure it's of more than academic concern.
20:49:09 <dfeuer> @define class (Ord a, Show a, Read a, Integral a) => IsInt a where fromIntF :: f Int -> f a
20:49:10 <lambdabot>  Defined.
20:49:20 <dfeuer> @define instance IsInt Int where fromIntF = id
20:49:21 <lambdabot>  Defined.
20:50:39 <dfeuer> @define fromInt = runIdentity . fromIntF . Identity
20:50:40 <lambdabot>  .L.hs:167:1:
20:50:40 <lambdabot>      Multiple declarations of ‘fromInt’
20:50:40 <lambdabot>      Declared at: .L.hs:166:1
20:50:44 <dfeuer> :t fromInt
20:50:46 <lambdabot> IsInt c => Int -> c
20:51:12 <dfeuer> @define newtype Flip f a b = Flip { unflip :: f b a }
20:51:14 <lambdabot>  Defined.
20:51:50 <dfeuer> @let toInt = unflip . fromIntF . Flip $ id
20:51:51 <lambdabot>  Defined.
20:51:53 <dfeuer> :t toInt
20:51:54 <lambdabot> IsInt b => b -> Int
20:52:23 <glguy> If you want to show code use the paste bin
20:52:26 <dfeuer> Sorry.
20:52:36 <Koterpillar> is there a pastebin that will compile things?
20:52:41 <dfeuer> That was rude.
20:53:06 <glguy> Koterpillar: I think codepad.org might do something like that
20:53:28 <dfeuer> Is that still using a truly ancient version of GHC? Like 6.something?
20:56:52 <glguy> Dunno, I never used it
21:19:22 <Denommus> any easy way to produce sound in a Haskell program?
21:19:40 <shachaf> Haskell's type system is unsound.
21:19:44 <nitrix> Denommus: Hi good sir.
21:19:59 <nitrix> Denommus: Is it a game? I could recommend SDL2-mixer.
21:20:32 <johnw> I produce plenty of sound while writing Haskell programs
21:21:03 <glguy> I've heard of portaudio / sndfile being used
21:21:14 <Denommus> nitrix: no, it's just an alert to wake me up in case something goes wrong
21:21:36 <joe9> What is the recommended library to have Show for Text fields: http://dpaste.com/2F053B3 is my code.
21:21:49 <Zemyla> Well, is it for Linux or Windows?
21:22:00 <dfeuer> Denommus, you might or might not be interested in http://haskell.cs.yale.edu/?post_type=publication&p=112  which is a partial draft of a book about music in Haskell. Sadly, the author died, so it's not likely to be finished.
21:22:05 <joe9> there seem to be quite a few packages implementing Show to convert to Text
21:22:17 <joe9> Zemyla: for me, linux, please?
21:22:55 <Zemyla> No clue then. If it were Windows, I'd say use the PlaySound function.
21:23:27 <Denommus> I think I'll just fork a process that pipes /dev/urandom to alsamixer
21:23:42 <Koterpillar> if you fork, fork mplayer
21:24:27 <Denommus> uh, I'll fork aplay
21:33:16 * hackagebot hgeos 0.1.7.0 - Simple Haskell bindings to GEOS C API  https://hackage.haskell.org/package/hgeos-0.1.7.0 (rcook)
22:27:37 <dfeuer> This look reasonable? https://github.com/nick8325/quickcheck/pull/108
22:27:47 <dfeuer> I want a MonadGen class for QuickCheck.
22:28:19 * hackagebot persistent-template 2.5.1.5 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.5.1.5 (GregWeber)
22:29:45 <jchia> If I have a function that returns an foo and a function that returns Either String foo, is there a widely-used naming convention for distinguishing the two versions of the function? I want to know what naming convention to use to indicate that a function returns an Either String (for passing back an error message).
22:30:23 <dfeuer> jchia, unfortunately, I think you're likely to find *several* conventions for that.
22:30:42 <dfeuer> The `safe` package offers one such.
22:30:53 <dfeuer> But its conventions are not universally appreciated.
22:31:22 <jchia> does suffixing my function names with "E" sound reasonable?
22:31:28 <jchia> just for my own use for now
22:31:59 <dfeuer> It sounds reasonable to me, but I'm certainly not the arbiter of naming or even particularly good at it.
22:33:10 <dfeuer> merijn is probably the expert at that.
22:33:19 * hackagebot persistent-template 2.5.1.6 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.5.1.6 (GregWeber)
22:34:29 <dfeuer> Oh boy. Two versions of persistent-template in five minutes? Something must have gone wrong.
22:51:27 <johnw> sometimes, the pace of change is just that fast
22:54:32 <jchia> For Data.Map, why is there no fromTraversable :: (Traversable t, Ord k) => t (k, a) -> Map k a?
22:54:54 <jchia> there's only fromList
22:55:16 <jchia> but i may want to use something else, such as a Vector
22:56:26 <jchia> Like right now, I'm trying build a map with a CSV that I read using Data.CSV, which gives me a Vector
22:57:12 <ReinH> you can turn the vector into a list
22:57:21 <jchia> will it be expensive, though?
22:57:27 <ReinH> That depends.
22:57:51 <ReinH> It's possible the list will disappear during optimization, or it might not matter either way
22:58:21 <ReinH> or you can fold over the vector directly
22:58:22 <jchia> i'll try that. seems like the simplest way for now
22:58:46 <ReinH> e.g., Vector.foldl'
22:59:14 <jchia> legacy support aside, would it be a good idea to replace the fromList with the more general fromTraversable?
23:01:15 <jchia> actually, I think it should be fromFoldable
23:04:11 <ReinH> Maybe.
23:04:20 <ReinH> Or at least offer both.
23:37:21 <joe9> Any recommendations for a socket library that handles asynchronous exceptions properly?
23:37:44 <joe9> When a user presses Ctrl-c, that is an asynchronous exception, correct?
23:37:54 <joe9> Is there a withSocket?
23:38:02 <joe9> or, withConnection
23:46:17 <dramforever> joe9: I suppose you can just use bracket to define one
23:48:04 <joe9> dramforever:  ok, Thanks.
23:49:29 <rabbi1> Hey friends, new to haskell 
23:49:39 <liste> hi rabbi1 
23:50:25 <rabbi1> All the posts/ article about haskell easily drew me to try it… :) 
23:51:11 <liste> great!
23:52:01 <kadoban> rabbi1: Welcome :)
23:52:44 <rabbi1> Anyway, I am a front end guy, mostly in to UI/UX. but have good experience with django/ror. and i would like to start with a web application project. Any framework suggestions ? i am looking in to yesod.  
23:53:06 <rabbi1> liste: kadoban thank you
23:53:16 <liste> rabbi1: scotty is one of the beginner-friendliest
23:53:33 <rabbi1> also, any book suggestion on that front. I am old school i like more paper reading than electronic
23:53:37 <liste> rabbi1: and it's pretty switch to spock for extra type safety
23:55:22 <rabbi1> I don't mind spending good about of time as i am learning than looking for a very easy way/ very tough way. you know what i mean.. any descent one, which help to understand with a web development and make it lil easy when i get into systems level.
23:56:02 <cocreature> joe9: if you need to use that more than once it probably makes sense to wrap the bracket version into a withSocket :: ConnectionData -> (Socket -> IO a) -> IO a which ensures that the socket is closed afterwards (ConnectionData is just a madeup name)
23:59:58 <rabbi1> liste: what you think of yesod ? 
