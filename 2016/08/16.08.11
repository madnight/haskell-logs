00:07:40 * hackagebot hjsonschema 1.1.0.1 - JSON Schema library  https://hackage.haskell.org/package/hjsonschema-1.1.0.1 (seagreen)
00:07:40 * hackagebot codeworld-api 0.1.0.1 - Graphics library for CodeWorld  https://hackage.haskell.org/package/codeworld-api-0.1.0.1 (ChrisSmith)
00:08:01 <hackrilege_> hey, i corrected my paste with the advice given to me earlier and now i have a (!!!) which works on Free structures and I am happy;
00:08:02 <hackrilege_> http://lpaste.net/175773
00:08:18 <KB5> quchen: got it working again. Reinstalled Atom, haskell packages and binary dependencies. One of these solved it.
00:08:57 <quchen> KB5: Binary dependencies?
00:09:00 <quchen> Like GHC-Mod?
00:09:31 <KB5> stylish-haskell, ghc-mod and hlint
00:26:14 <James123> I am trying import Data.List.Split on ghci 7.10.3 but it does not work. Any ideas?
00:26:56 <pavonia> What means "does not work"?
00:26:57 <Koterpillar> James123: it's not in base, you have to install it somehow - stack, cabal, distro package
00:27:17 <James123> Koterpillar: Thanks!
00:32:35 * hackagebot monky 2.0.1.0 - A system state collecting library and application  https://hackage.haskell.org/package/monky-2.0.1.0 (ongyerth)
00:37:00 <xxdxx> hi
00:37:19 <ongy> 'cabal haddock --for-hackage' looks nice, any pitfalls?
00:39:49 <jchia> I want to have a special type of string to represent, e.g. the name of a type of thing. This type of string cannot be used for any other purpose and I want it to have all or at least some of the features of String or Text, such as mappend, null and empty. It's conceptually a wrapper around String Text. How can I implement this while minimizing boilerplate code?
00:40:56 <phadej> jchia: GeneralisedNewtypeDeriving
00:41:12 <chrisbarrett> jchia: use a newtype to wrap it, and use GeneralizedNewtypeDeriving to pick the typeclasses that String implements that you want
00:41:24 <phadej> with z, I never spell it right :/
00:41:37 <chrisbarrett> I'm from NZ, it pains me too :p
00:41:54 <xxdxx> Good IRC channel group for hackers?
00:42:32 <phadej> that will work for type class functions, `null` you'll need to reimplement though.
00:42:35 <chrisbarrett> jchia: if the particular functions you care about depend on string concretely and not some typeclass you'll have to re-write those to unwrap the newtype yourself
00:42:35 <jchia> OK, thanks. i'll check that out
00:42:56 <liste> xxdxx: the whole Freenode. though you may need to widen your perception of what a hacker is (:
00:43:22 <phadej> there is also Tagged http://hackage.haskell.org/package/tagged-0.8.5/docs/Data-Tagged.html
00:45:12 <chrisbarrett> phadej: oooh, that's a useful lib
00:45:51 <phadej> ekmett has done something practical as well! :)
00:46:27 <chrisbarrett> :o
00:48:41 <glguy> ongy: i use a variant of that haddock command
00:49:24 <glguy> https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
00:49:33 <saurabhnanda> Looking for feedback: Why building web-apps in Haskell is harder than it ought to be -- https://docs.google.com/a/vacationlabs.com/document/d/1LuwVtf7J6zHUns01CTeM3CoeoXNuJsvEU60SjHdvT2g/edit?usp=sharing 
00:50:13 <Koterpillar> saurabhnanda: access denied
00:50:49 <saurabhnanda> Sorry. Fixed: https://docs.google.com/document/d/1LuwVtf7J6zHUns01CTeM3CoeoXNuJsvEU60SjHdvT2g/edit?usp=sharing
00:51:18 <saurabhnanda> Please feel free to comment on the document, or here.
00:56:24 <saurabhnanda> do these seem like valid points?
00:56:37 <Koterpillar> saurabhnanda: editor support is pretty nice with vim
00:56:50 <Koterpillar> saurabhnanda: limited experience in other areas, particularly in SQL
00:57:17 <saurabhnanda> Koterpillar: thanks
01:03:57 <saurabhnanda> no other feedback from anyone else?
01:04:20 <Koterpillar> post it on reddit, the answers here are limited to one timezone
01:04:37 <Koterpillar> (or somewhere else where it'll be visible for a while)
01:04:38 <saurabhnanda> ah okay
01:04:51 <saurabhnanda> I wanted to get feedback **before** posting on Reddit.
01:04:52 <saurabhnanda> :)
01:05:02 <saurabhnanda> don't want to start an unnecessary / non-constructive flamewar there
01:05:27 <mauke> I don't like to click on google docs urls. they look icky
01:06:15 <ongy> saurabhnanda: just for reference (may be just me) https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition is what I think of when I read business-level
01:06:29 <saurabhnanda> ongy: what's a better name?
01:07:47 <ongy> not sure, how would you describe the word? of some size with sensible design? Think about what you want to express and use that. business-level says pretty much nothing. But as I said, that's my view, and I may be totally wrong
01:09:33 <saurabhnanda> low-level, mid-level, high-level API?
01:10:10 <srhb> If that's what you mean I find business-level even stranger :P
01:10:20 <srhb> I assumed "makes managers happy"
01:11:22 <saurabhnanda> how else do you name this? you want an API that maps to your problem domain. not low-level stuff like read/update/insert.
01:11:31 <Eliel_> I interpreted business level as "code that performs mission critical tasks".
01:11:44 <srhb> saurabhnanda: high level.
01:12:06 <Eliel_> and needs to be easy to understand and easy to modify.
01:12:59 <ongy> saurabhnanda: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields for the "how many names can you come up with", but if I read it right, it's not ready yet
01:14:48 <saurabhnanda> removed all references to "business" if that was throwing people off.
01:15:10 <saurabhnanda> ongy: no, it does not solve the naming problem completely
01:20:08 <joe9> Is there an emacs haskell mode other than the haskell-mode of github.com/haskell/haskell-mode. I am looking for something simpler.
01:21:06 <ongy> saurabhnanda: it doesn't?
01:21:47 <saurabhnanda> ongy: you still can't have a local variable and record field with the same name
01:21:58 <saurabhnanda> ongy: haskell can't figure out which to use based on usage context
01:26:11 <srhb> No, we need TDNR first.
01:26:21 <ongy> tdnr?
01:26:27 <srhb> type directed name resolution
01:27:13 <ongy> looking at the error message for something like 'let test = test t' that wouldn't help either
01:27:39 <ongy> since the field name is shadowed in the definition
01:29:31 <saurabhnanda> Another example: You have a record field called ‘status’. If you’re using OverloadedRecordFields or Lenses, it will result in a ‘status’ function or a Getter/Setter respectively. However, what do you do if you need a variable called ‘status’ and to you, as a programmer, the call-sites are enough to disambiguate which ‘status’ you’re referring to? You can’t do that. You have to come up with another name for ‘sta
01:29:31 <saurabhnanda> tus’, something like ‘status_’, or ‘statusWanted’, or ‘targetStatus’. 
01:29:50 <Eliel_> saurabhnanda: probably not a solution, but you might find this library interesting also. It does the same job as an SQL db, but is perhaps better suited for Haskell projects. https://hackage.haskell.org/package/acid-state
01:30:16 <ongy> oh, I should read everything first
01:30:25 <ahihi> acid-state requires all of your data to fit in memory
01:30:34 <ahihi> it's not really comparable to an RDBMS
01:30:51 <Eliel_> ahihi: ok, that's a serious problem with it then
01:31:02 <saurabhnanda> Eliel_: native object stores aren't the answer. I've gone down that rabbit hole with Common Lisp to not try that stunt ever again.
01:31:09 <ahihi> no, it just has different use cases :)
01:31:32 <Eliel_> ahihi: well, ok, a serious problem for this use case.
01:33:15 <Eliel_> although, would it be impossible to have an acid-state like API for an external DB?
01:34:51 <saurabhnanda> Eliel_: what's so unique about the acid-state API?
01:37:30 <Eliel_> saurabhnanda: It's designed for accessing data directly with haskell code rather than through SQL structure... come to think of it, that might not work.
01:37:39 <ahihi> you may want to look at persistent
01:38:30 <Eliel_> It's been a while since I last played with haskell, so I'm a bit rusty.
01:38:37 <saurabhnanda> ahihi: I've been working with Persistent for the past 2 months
01:39:24 <saurabhnanda> ahihi: I'm trying to raise awareness about issues that Persistent doesn't solve. And it surprises me because any non-trivial RDBMS backed webapp would face these.
01:39:44 <saurabhnanda> unless, I'm trying to map Ruby/Rails concepts on to Haskell and they're becoming anti-patterns
01:40:00 <saurabhnanda> which is also fine. In which case, I'd like to learn the correct Haskell way of doing things.
01:40:04 <ahihi> oh, I didn't read that far back
01:41:18 <saurabhnanda> ahihi: https://docs.google.com/document/d/1LuwVtf7J6zHUns01CTeM3CoeoXNuJsvEU60SjHdvT2g/edit?usp=sharing
01:41:58 <ahihi> I gotta head to work, but I'll check it out later
01:42:21 <Eliel_> saurabhnanda: there's a way to solve your naming problem present on this page in the example: http://www.yesodweb.com/book/persistent
01:42:38 * hackagebot ghc-typelits-knownnat 0.1.1 - Derive KnownNat constraints from other KnownNat constraints  https://hackage.haskell.org/package/ghc-typelits-knownnat-0.1.1 (ChristiaanBaaij)
01:42:41 <Eliel_> In other words, just prefix the field names with the record name.
01:43:36 <saurabhnanda> Eliel_: as I said, I know there is a **a solution**, but is it really programmer friendly? Btw, that level of problem is already solved by OverloadedFields, I believe.
01:44:12 <saurabhnanda> Eliel_: I'm using ClassyLenses instead of prefixing everything with the record name -- it makes everything too clunky
01:44:13 <Eliel_> saurabhnanda: it's a little annoying to write but it definitely makes the code more readable.
01:44:32 <Eliel_> no guessing involved.
01:44:48 <Eliel_> so, it's a little of a mixed bag
01:47:08 <Eliel_> saurabhnanda: also, it occurs to me that it's relatively simple to solve the nesting problem by simply not trying to fetch fields from all tables in one query. That might also allow lazy fetching when you actually don't need all data.
01:47:38 <saurabhnanda> Eliel_: which would introduce the classic N+1 Sql bug
01:48:04 <Eliel_> saurabhnanda: what's that?
01:48:41 <saurabhnanda> http://stackoverflow.com/questions/97197/what-is-the-n1-selects-issue
01:48:53 <saurabhnanda> select a collection
01:49:06 <saurabhnanda> for each item in the collection execute another sql-query to fetch a dependent row
01:49:16 <saurabhnanda> N queries for each dependent in the collection
01:49:22 <saurabhnanda> 1 query for fetching the top-level collection
01:49:27 <saurabhnanda> results in N+1 queries
01:49:31 <saurabhnanda> and is a performance killer
01:49:43 <Eliel_> even using prepared statements?
01:50:29 <Eliel_> but laziness could prevent most of those queries from executing and only execute the ones required.
01:50:38 <Eliel_> when used
01:52:07 <Eliel_> but wait a minute, I'm not saying one query per row but rather one query per logical element.
01:52:25 <Eliel_> you could still fetch a list of rows in one query if there are multiple of the same type.
01:52:51 <saurabhnanda> Eliel_: could be possible. But no library solves for this problem, yet. Hence "Why building web-apps in Haskell is harder than it ought to be "
01:55:34 <lemonxah> good day
01:55:49 <lemonxah> going to be building my first haskell app for work now but i have no clue where to start 
01:56:03 <lemonxah> i have done scala and i can read haskell 
01:56:33 <srhb> lemonxah: main = undefined, then go from there! :P
01:56:54 <srhb> lemonxah: Just typing something usually helps getting started. Unless you have a more concrete issue.
01:57:22 <lemonxah> no i mean i know what i want to achieve i would have used regex to do this
01:57:50 <lemonxah> i have 
01:57:51 <lemonxah> case class Test(name: String /* Test Name for testing */, age: Int /* Test Age for testing */)
01:58:15 <lemonxah> i want to get out the name of the class, the name and type and desc of the fields between ( and )
01:58:28 <lemonxah> would i still do this with regex in haskell?
01:58:31 <srhb> lemonxah: Sounds like you want to look into parsers.
01:58:46 <srhb> Parser combinators is the usual way, but sure, regexes can work too.
01:58:54 <srhb> I see them used very rarely.
02:00:19 <lemonxah> i want 
02:00:32 <lemonxah> sorry i want to do it propper so i would look at parsers
02:01:40 <cocreature> I think regexes are a bit underused in haskell. there are a lot of problems for which they are a perfectly good solution
02:09:37 <maerwald> cocreature: people tend to call things "bad" when it doesn't work very well in their favorite language :P
02:13:30 <dysfun> someone have a nice overview of the properties of the various *kanren?
02:17:22 <dysfun> oh looks like there's a list at minikanren.org
02:17:39 * hackagebot hpack-convert 0.14.4 - Convert Cabal manifests into hpack's package.yamls  https://hackage.haskell.org/package/hpack-convert-0.14.4 (yamadapc)
03:06:19 <hackrilege_> ok, check out this paste, its has a test which shows use of the code giving polymorphic accessor (!!!) with example application to [a], [[a]] and Free [] a; http://lpaste.net/175773
03:09:08 <hackrilege_> it seems like its a nice way to separate out functions acting on an argument to a function from functions acting on the result of the function applied to its argument
03:10:31 <hackrilege_> i hope that i can use it to commit lazy evaluations to memory on the fly. does that sound reasonable?
03:12:26 <hackrilege_> (given that a polymorphic accessor is just a function from a to b)
03:39:51 <kamyar> Hello everyone
03:40:07 <kamyar> What is the meaning of ':::' operator?
03:40:12 <kamyar> triple colons
03:40:31 <MasseR> In what context?
03:40:40 <hpc> @hoogle (:::)
03:40:42 <lambdabot> No results found
03:40:49 <hpc> it's whatever it was defined to be
03:40:58 <hpc> it's not built in and doesn't seem to be from hackage
03:41:39 <chrisbarrett> is that used by HList?
03:41:56 <chrisbarrett> to represent hlisty-cons?
03:44:06 <chrisbarrett> kamyar: I'm curious now. Can you point us to a usage example, or where you saw it? It'll be an operator defined by some library.
03:44:30 <kamyar> chrisbarret: https://github.com/grayjay/json-rpc-client/blob/master/demo/Signatures.hs
03:46:58 <chrisbarrett> thanks. it's defined here: https://github.com/grayjay/json-rpc-client/blob/master/src/Network/JsonRpc/Client.hs#L105
03:47:53 <chrisbarrett> basically, looks like a home-grown typelevel list.
03:48:58 <kamyar> chrisbarrett: Cant understand the meaning. Please help
03:52:40 <chrisbarrett> kamyar: in your example, looks like it gives you a way to specify the type of an RPC method.
03:53:39 <chrisbarrett> there's two usages of (:::) there: one at the term level, which specifies a procedure called "concatenate" with parameters "x" and "y"
03:54:20 <chrisbarrett> and a corresponding corresponding haskell type signature for that procudure, which re-uses the (:::) operator at the type level.
03:54:55 <chrisbarrett> this is a complete guess, I don't know the library. :)
03:56:41 <chrisbarrett> NB. the type signature `concatenateSig :: Signature (String ::: String ::: ()) String` says that `concatenateSig` takes two Strings and returns a String. That extra unit `()` in there represents the end of the list
03:56:44 <Profpatsch> I’ve got a type Translated a = Trans (UIMessages -> Html, a)
03:57:30 <Profpatsch> That is a type combined with a function to translate messages (e.g. for site rendering).
03:58:06 <yamadapc> anyone running a hackage mirror (with the full state, not just tarballs) knows how much disk space it takes?
03:58:16 <Profpatsch> Now I want to replace the Html part with anything that implements FromMarkup
03:58:22 <Profpatsch> class FromMarkup where
03:58:31 <Profpatsch>   fromMarkup :: Markup -> a
03:58:54 <Profpatsch> What would my type Translated look like?
03:59:12 <Profpatsch> I suspect I either need Rank2Types or ExistentialTypes, but I’m not sure which.
04:00:08 <chrisbarrett> Profpatsch: RankNTypes kinda subsumes those, if I understand correctly
04:00:35 <Profpatsch> chrisbarrett: How would you write Translated?
04:01:48 <chrisbarrett> depending on your usage, `Translated a = Trans (forall s. FromMarkup s => UIMessages -> s, a)` might work
04:01:50 <chrisbarrett> \_(ツ)_/¯
04:02:08 <Profpatsch> Yeah, that’s as far as I got. :)
04:03:35 <chrisbarrett> honestly, half the time I just move the existential binder around until things typecheck :p
04:04:11 <chrisbarrett> I should not be giving advice to people. :p
04:21:27 <troydm> I have a Text and I want to unpack it into String, how do I force it's evaluation to String strictly?
04:21:38 <troydm> map seq str?
04:21:52 <Profpatsch> troydm: There are functions in Data.Text for that.
04:26:49 <Profpatsch> troydm: Why would you want to unpack to String anyway?
04:27:01 <troydm> Profpatsch: was just testing
04:27:06 <troydm> Profpatsch: well the thing is 
04:27:09 <Profpatsch> If it’s a long piece of Text, stay with Tex.
04:27:11 <Profpatsch> *-
04:27:34 <Profpatsch> Most libraries that use String only do so for short Strings, like error messages.
04:27:56 <troydm> I have an 200mb dataset in MongoDB wchi I want to load to HashMap Int32 Str  
04:28:17 <troydm> now I've tried using Bytestring as my resulting type for those strings
04:28:34 <cocreature> if you have a 200mb dataset you don’t want to load that as Strings
04:28:35 <troydm> and memory usage after being loaded into Haskell explodes to 1gb 
04:28:46 <Profpatsch> Is the dataset unicode text? Then convert it to Text.
04:28:52 <troydm> I've switched to String and it went down to 500mb
04:28:59 <Profpatsch> Is it bytes? Then use bytestring
04:29:03 <troydm> now I've went to Text and it's now near 200mb
04:29:04 <cocreature> then you have a bug in your bytestring code
04:29:14 <Profpatsch> [Char] is the worst kind of encoding you could use.
04:29:29 <cocreature> or a lot of 1 char strings, I think in that case String might actually be shorter
04:29:30 <troydm> cocreature: what kind of bug?
04:30:15 <troydm> cocreature: 1.6 million strings of 15 chars average length
04:30:22 <troydm> to be precise
04:30:35 <cocreature> troydm: some memory leak? it’s hard to tell without seeing the code, but bytestring should be smaller starting from two chars iirc so it’s almost impossible that your string implementation takes up less memory
04:30:38 <troydm> and when loaded -hy says I have ARR_WORDS of 1gb
04:30:57 <troydm> cocreature: code is at my github repo called edda
04:31:35 <troydm> cocreature: https://github.com/troydm/edda/blob/master/src/EDDA/Data/Database.hs
04:31:44 <troydm> cocreature: function called getSystemEDDBIdsMap
04:32:11 <troydm> cocreature: you can build the thing yourself and test it using 
04:32:21 <troydm> stack build --executable-profiling
04:32:34 <troydm> stack exec edda -- import -s eddb -t stations +RTS -hy
04:32:41 <troydm> hp2ps -c edda.hp
04:33:10 <troydm> sorry you'll have to import systems dataset before trying to import stations 
04:33:19 <troydm> so you need MongoDB and 
04:33:27 <troydm> stack exec edda -- import -s eddb -t systems
04:33:42 <cocreature> troydm: you are not using ByteString in that module nor String as far as I can see
04:33:57 <troydm> cocreature: type EddbIdMap = HM.HashMap Int32 Str
04:34:04 <troydm> cocreature: look at Type.hs
04:34:22 <cocreature> ah k
04:35:37 <troydm> cocreature: well the thing is I've switched from ByteString to Text and memory usage went down to 250mb
04:35:41 <troydm> which is reasonable
04:35:56 <cocreature> a Text is a totally different story
04:35:58 <troydm> 4x times less than ByteString
04:36:21 <cocreature> it still shouldn’t need less memory than ByteString but it’s nowhere near as bad as String
04:37:09 <cocreature> troydm: "return $! (fromIntegral eddbId, toStr systemName)" probably doesn’t do what you expect it to do. it will only force the evaluation of the tuple to whnf which doesn’t evaluate the elements in the tuple
04:37:15 <cocreature> so that toStr might be leaking memory
04:37:44 <troydm> cocreature: how so?
04:38:00 <troydm> cocreature: TE.encodeUtf8
04:38:36 <cocreature> troydm: what I mean is that it can’t throw the Text away until it has evaluated toStr systemName and that line doesn’t force the evaluation
04:38:59 <cocreature> anyway if you already get Text out of your db there is little to no reason to convert that to ByteString
04:40:01 <cocreature> depending on the kind of text you store it could be slightly smaller (utf8 vs utf16) but it’s probably not worth the trouble
04:41:27 <troydm> cocreature: I've tried forcing evalutation of toStr, no difference
04:44:47 <ertesx> troydm: if going from ByteString to Text actually *saved* you memory, it may be because your language has a shorter UTF-16 encoding than whatever you were using with ByteString, but more likely it's due to fusion and better strictness
04:47:16 <troydm> ertesx: data is in English, all of it
04:48:48 <ertesx> troydm: then it's definitely fusion/strictness…  it means that you were using too many intermediate steps with ByteString, which doesn't fuse them together the way Text does
04:49:52 <ertesx> however, it also hints to a potential memory leak, because i would expect GC to take care of keeping the memory usage low anyway
04:54:10 <Guest85615> hello
04:54:50 <__avi__> Hello
04:55:18 <__avi__> I here looking for help on some macfiltering issue
04:55:46 <__avi__> so for upping the security on my network I filtered the mac addresses
04:56:02 <__avi__> I did it from my router config page
04:56:14 <__avi__> that requires a login
04:56:23 <__avi__> but now ive forgoten my credentials
04:56:33 <__avi__> and I just bought a new phone 
04:56:50 <__avi__> which doesnt have the mac registered in the whitelist
04:57:06 <__avi__> The only way I can think of is to brute force the login page
04:57:11 <ahihi> this doesn't appear to be haskell-related
04:57:11 <__avi__> using hydra
04:57:21 <__avi__> okay
04:57:28 <__avi__> hacking channels?
04:58:22 <ahihi> you can use the alis bot to search for channels. /msg alis help
04:58:35 <__avi__> okay cool thanks
05:12:44 * hackagebot glabrous 0.1.0.1 - A template library  https://hackage.haskell.org/package/glabrous-0.1.0.1 (MichelBoucey)
05:20:32 <Gurkenglas> http://hayoo.fh-wedel.de/?query=StateT+s+STM+a+-%3E+STM+a why doesn't this find anything?
05:32:05 <bergmark> Gurkenglas: what do you expect to find?
05:33:58 <roberth> edwardk, do you know of a type definition somewhere like newtype On a b = On { runOn :: a -> a -> b }?
05:35:05 <Gurkenglas> bergmark, a combinator defined in some utility library. (Too bad hayoo doesnt give more general combinators that would specialize to this one or something)
05:35:30 <bergmark> are you sure there is one?
05:35:48 <bergmark> if there is, hayoo might not index that package
05:37:58 <bergmark> i usually use hoogle on stackage.org since it contains a lot of packages
05:40:41 <Gurkenglas> Nah I just expected there to be one because STM gives a way to handle state and StateT assume a way to handle state
05:40:45 <Gurkenglas> *assumes
05:41:56 <Gurkenglas> Too bad MonadState s m has m -> s or you could just do MonadState s STM
05:42:32 <humanoyd> anyone using stack on arch linux? Should I install the `community` or the `haskell-core` version?
05:46:17 <quchen> roberth: There’s the Comparison newtype, which would be “On Ordering a”. It’s in contravariant.
05:47:45 * hackagebot language-dockerfile 0.3.2.0 - Dockerfile linter, parser, pretty-printer and embedded DSL  https://hackage.haskell.org/package/language-dockerfile-0.3.2.0 (yamadapc)
05:53:03 <cocreature> humanoyd: I just build the first version using cabal and have been using “stack install” in the github repo since then
05:55:26 <roberth> quchen: i see, On would generalize both Comparison a (On a Ordering) and Equivalence a (On a Bool). I could not find it in the profunctors package, but didn't think of looking at the contravariant package
05:57:55 <cocreature> humanoyd: and by first version I mean the first version I install you don’t need to go back to the first stack version
05:59:48 <humanoyd> cocreature: Just to confirm: you basically clone the stack repo, `cabal build` (in a sandbox, I guess?) and put the resulting executable somewhere in your PATH?
05:59:59 <cocreature> humanoyd: exactly
06:00:22 <cocreature> humanoyd: but if you want to install it from a repo I would go for community since it’s an official repo contrary to haskell-core
06:02:22 <humanoyd> cocreature: ok, thanks! I'm already using `haskell-core` because it used to have more recent versions than the standard repos...but that seems to have changed lately...
06:03:16 <cocreature> humanoyd: personally I only use cabal sandboxes and stack since installing packages globally has caused problems in the past for me
06:04:27 <ertesx> Gurkenglas: STM and StateT are pretty much completely unrelated
06:05:26 <ertes> Gurkenglas: in particular a function of type (StateT s STM a -> STM a) does not exist (disregarding partial ones)
06:07:16 <humanoyd> cocreature: yeah, usually when there's a new ghc version :) I guess I'll try out your approach, thanks
06:07:46 * hackagebot vector-sized 0.3.3.0 - Size tagged vectors  https://hackage.haskell.org/package/vector-sized-0.3.3.0 (jophish)
06:07:48 <cocreature> humanoyd: even before that, cabal sandboxes don’t sandbox you from your global package database so you can run into conflicts
06:09:05 <edwardk> roberth: i don't think i have it packaged, but its isomorphic to Costar ((->) Bool)
06:09:18 <Gurkenglas> Ah yes ertes it would be (TVar s -> StateT s STM a -> STM a) wouldnt it
06:10:10 <eklavya> how to support both ghc 7.10 and 8 in a template haskell function? ifdefs or something?
06:10:31 <cocreature> eklavya: yeah CPP and ifdefs
06:10:50 <eklavya> ok, just wanted to make sure it was the best way
06:10:55 <eklavya> thanks cocreature :)
06:11:15 <cocreature> it’s not a good way but afaik it’s the best way
06:11:28 <eklavya> :D
06:19:31 <black0range> Hello! Are there any class in prelude or hackage for Key-value data types? 
06:20:02 <ludat> black0range, map?
06:20:06 <yyyyy> black0range: `containers` has Map, which is what you want
06:20:32 <ongy> is there a way to remove warnings about redundant imports, that have to exist with older ghc? For example Control.Applicative.(<$>) is in Prelude(I think) since ghc-7.10
06:21:07 <cocreature> ongy: I think if you do an explizit import, i.e. import Control.Applicative (<$>) it doesn’t warn on newer ghcs
06:21:13 <ongy> and I do know about ifdefs, but I would prefer some compoiler flag
06:21:21 <ongy> cocreature: it does
06:21:46 <black0range> correct me if i'm wrong but map is data not a class
06:21:59 <ongy> at least it did with 7.10
06:22:47 <cocreature> ongy: hm 8.0 doesn’t do that
06:22:54 <cocreature> import Control.Applicative gives me a warning
06:23:09 <cocreature> import Control.Applicative ((<$>)) (and I use <$> in both cases) doesn’t give me a warning
06:24:38 <Shou> black0range: https://hackage.haskell.org/package/collections-api-1.0.0.0/docs/Data-Collections.html
06:24:41 <Shou> Maybe this?
06:34:14 <jonkri> I'm wondering whether genetic algorithm-based testing could be helpful in reproducing crashes in Haskell programs/functions, given exceptions, knowledge modules (exported primitives), line numbers, etc.
06:35:08 <jonkri> If not, I would appreciate any suggestions of other search-based problems that could be relevant in the Haskell world. :)
06:36:40 <jonkri> My question could also be generalized to other search algorithms.
06:36:42 <roberth> edwardk: Indeed they are. If there's a difference in (asymptotic) performance, it could be worth it to also have 'On' or something. Then maybe the one can be used to 'improve' the other? I don't know.
06:38:32 <jonored> jonkri: So, like, you give it some information about a crash, and it tries to find something that reproduces that crash?
06:39:59 <jonored> I don't see how you can get the sort of "this is closer" information that you need to drive a genetic algorithm from that.
06:43:10 <netheranthem> Seems like the fitness function would be mostly 0 or 1 :)
06:44:14 <ertes> Gurkenglas: depends on what you want it to do
06:44:43 <jonkri> jonored, netheranthem: Yeah, that was my concern too. :)
06:44:44 <ertes> jonkri: yes, it would
06:45:08 <ertes> jonkri: but only if you can come up with a measure of how hard it crashes =)
06:45:35 <netheranthem> and then there's the fact that haskell never crashes, so that wouldn't help ;)
06:45:43 <ertes> > head []
06:45:45 <lambdabot>  *Exception: Prelude.head: empty list
06:45:45 <ertes> crashed
06:46:05 <netheranthem> shh, we have to perpetuate haskell's greatness to outsiders
06:46:11 <ertes> in fact there is a whole test framework around exploiting such crashes called lazysmallcheck
06:47:47 * hackagebot socket 0.6.1.0 - An extensible socket library.  https://hackage.haskell.org/package/socket-0.6.1.0 (LarsPetersen)
06:48:48 <jonkri> ertes: Thanks for the link!
06:49:11 <yyyyy> black0range: sorry, yes. you can use the classes in `mono-traversable` then.
06:49:20 <jonkri> Can you think of any search problems that would perhaps be more relevant?
06:50:42 <jonkri> Actually, I should get going, but please PM me if you happen to have some ideas, and I'll get back to you later. :)
06:59:44 <{AS}> Ha "cabal install happy" :)
07:00:17 <owoce> hi everyone, i'm looking for advice on doing interactive terminal uis, ncurses style
07:00:46 <owoce> any experience with ncurses/vty/brick ? which one did you like best?
07:00:54 <srhb> owoce: I find Brick pretty cool
07:01:44 <owoce> it looked nice. i hope i can get it to work on windows though :/
07:02:12 <glguy> I've been using vty. none of brick out vty will work on Windows currently
07:02:48 * hackagebot labels 0.0.0 - Declare and access tuple fields with labels  https://hackage.haskell.org/package/labels-0.0.0 (ChrisDone)
07:02:52 <glguy> or vty*
07:03:20 <owoce> that's a shame. not even with cygwin or something?
07:04:02 <pavonia> Have you tried building ncurses on Wndows?
07:04:42 <glguy> I'm not sure about how cygwin changes things
07:04:56 <srhb> glguy: According to the vty docs, it is "cygwin only" on Windows
07:05:11 <glguy> ah, neat
07:05:38 <owoce> pavonia: havent really tried anything yet, i started researching the topic 10 mins ago and thought id ask here
07:05:42 <owoce> oh good
07:06:06 <glguy> owoce: I've been doing this with vty recently:
07:06:20 <glguy> ?hackage glirc
07:06:20 <lambdabot> http://hackage.haskell.org/package/glirc
07:07:07 <owoce> the Brick docs say that it uses vty under the hood, so maybe it can work on cygwin?
07:07:45 <owoce> glguy: cool ill check it out
07:08:02 <pavonia> I'm coincidentally exploring how far I can get porting the Windows console API to Haskell at the moment :p
07:09:21 <glguy> yeah if vty works in cygwin, brick will
07:09:40 <smorele> Hi. I'm currently working on the problem #5 from https://wiki.haskell.org/99_questions/1_to_10 which asks to reverse a list. My solution is to use the "reverse" function but the solution (https://wiki.haskell.org/99_questions/Solutions/5) presents another way. Do someone does the aim of the problems ? Reinvent the wheel ?
07:10:13 <netheranthem> Reinventing the wheel is sometimes the only way to learn how to do simple things
07:10:55 <netheranthem> they might ask you to sort a list later on as well, and while it's already implemented, doing it yourself helps in learning some things
07:12:06 <smorele> ok, then i'll find a solution to reverse a list without using the "reverse" function. Thanks to 2 cents
07:12:15 <smorele> *for 2 cents
07:13:21 <Welkin> smorele: writing your own library functions/utilities is a very useful exercise for learning a language
07:13:40 <Welkin> writing reverse is simple and actually fun
07:14:17 <owoce> pavonia: do you have a repo up?
07:14:36 <pavonia> Not yet, no
07:15:18 <Welkin> > foldl' (flip (:)) [] [1..10]
07:15:19 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
07:15:26 <Welkin> that is just one way
07:15:29 <smorele> Welkin: yep I agree, I have to find a way to do it. It's not simple right now but It cam becomes with habit :)
07:15:30 <Welkin> I like the recursive way too
07:15:49 <Welkin> you get to destructure the list
07:16:01 <smorele> yep easy when you know foldl' and flip but I'm a newbee :)
07:16:38 <Welkin> foldl and foldr are very useful, you'll get used to them
07:16:47 <Welkin> in fact, write your own version :D
07:17:20 <srhb> I think writing reverse on your own comes before writing foldr and foldl on your own :)
07:17:21 <glguy> foldl is actually the right fold for reverse
07:17:31 <quchen> The strict foldl is redundant there, it forces cons cells which are already in WHNF
07:17:37 <glguy> rather than '
07:17:47 <glguy> the print version is actually worse
07:17:52 <glguy> prime
07:18:37 <quchen> It’s still the only valid use case for “foldl” that I can remember :-)
07:19:32 <quchen> glguy: Why is it redundant though? I wouldn’t be surprised if the “seq” is eliminated by GHC
07:19:43 <quchen> s/redundant/worse/
07:21:12 <ertes> glguy: thanks for splitting out irc-core
07:23:07 <ertes> glguy: is there a reason why you chose Text for everything?  because by the protocol definition some things are legitimately *bytes*
07:25:55 <glguy> it was a lot of trouble to keep everything separate for functionality i never intended to use
07:29:18 <ertes> ah, it's entirely Text everywhere, from the parser up until rendering
07:29:45 <glguy> and irc doesn't support arbitrary encodings, just encodings that happen to overlay nicely with whatever the Swedish encoding was
07:30:01 <ertes> so it's up to me to go from bytes to Text in the network code
07:30:12 <Welkin> irc client in haskell
07:30:52 <Welkin> glguy: did you just not like anything available?
07:30:59 <Welkin> or did you just want to make it for fun?
07:31:13 <glguy> ertes: there should be a permissive decoder in the module you can use
07:32:00 <glguy> welkin: I wanted stuff from a client that didn't exist without heavily scripting an existing on if at all
07:32:51 <ertes> glguy: ah, found it
07:33:10 <glguy> toggleable detail level, pervasive search, smarter tab completion, condensed join part info, temporary/retroactive ignores where i can still tell someone is taking
07:33:29 <ertes> interesting that you fall back to CP1252, when most clients fall back to latin-1
07:33:43 <glguy> good support for less common freenode and znc features
07:34:10 <glguy> cp1252 is what xchat and mirc are likely to use
07:34:19 <Welkin> lol mirc
07:34:26 <glguy> it handles all latin1 text
07:34:27 <Welkin> I used to write mirc scripts
07:34:37 <glguy> and then a few more things
07:34:50 <Welkin> mostly irc games
07:34:50 <ertes> ditto…  i certainly wasted a lot of time in that terrible built-in editor of mirc
07:35:11 <glguy> it's Latin 1 with some control codes replaced with usable characters
07:37:13 <glguy> default xchat transmits cp1252 unless it needs something outside of that code page at which point it switches to utf8
07:37:42 <Welkin> what does irssi use?
07:38:10 <glguy> as far as i know all the other normal clients use utf8
07:38:45 <ertes> Welkin: it uses whatever LANG or LC_CTYPE is set to, falling back to "C"
07:38:50 <ertes> (i.e. binary)
07:40:01 <ertes> they probably considered that a feature, but with IRC it's a bug…  with IRC any charset customisation is a bug
07:42:49 * hackagebot pretty-types 0.1.1.0 - A small pretty printing DSL for complex types.  https://hackage.haskell.org/package/pretty-types-0.1.1.0 (SvenHeyll)
07:52:54 <netheranthem> I'm curious, is there a compile option to check for functions that do not have a declaration for each possible variable?
07:53:30 <shapr> netheranthem: -fwarn-incomplete-patterns ?
07:54:02 <netheranthem> That's neat
07:54:26 <shapr> netheranthem: http://stackoverflow.com/questions/28888587/can-ghc-warn-about-the-uses-of-dangerous-non-total-functions ?
07:54:48 <netheranthem> Seems like -W and -Wall will warn of most dodgy things happening
07:55:17 <netheranthem> Thanks!
07:56:14 <smorele> wow, I'm reading the haskell source code about the reverse function and I just understand I'm stupid :)
07:56:23 <smorele> it's quite difficult to understand !!
07:56:30 <shapr> @src reverse
07:56:30 <lambdabot> reverse = foldl (flip (:)) []
07:56:41 <smorele> reverse l =  rev l []
07:56:41 <smorele>   where
07:56:41 <smorele>     rev []     a = a
07:56:41 <smorele>     rev (x:xs) a = rev xs (x:a)
07:56:41 <netheranthem> that's elegant
08:11:01 <linduxed> so there's a function in the matrix package that is called toList
08:11:09 <linduxed> can be seen here https://hackage.haskell.org/package/matrix-0.3.5.0/docs/Data-Matrix.html
08:11:24 <linduxed> if you search for "toList" in hoogle, you don't find this
08:11:34 <linduxed> if you search for "toList" in hackage, you don't find this
08:11:48 <linduxed> one has to do a google search for "haskell matrix tolist"
08:11:56 <linduxed> the first result gives me what i needed
08:12:14 <linduxed> is there some haskell-specific search engine that would do what i just did with google?
08:12:45 <dexterph> http://stackage.org/lts/hoogle
08:12:57 <dexterph> or http://stackage.org/nightly/hoogle
08:13:30 <dexterph> (if the package is on stackage, that is)
08:13:54 <lyxia> indeed https://www.stackage.org/lts-6.11/hoogle?q=toList+package%3Amatrix
08:13:58 <geekosaur> hoogle has problems searching across many packages
08:14:03 <geekosaur> @where hayoo
08:14:03 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
08:15:05 <linduxed> dexterph: that technically did what i said, yes. i did find the function in question on page 10
08:15:21 <linduxed> after only searching for "toList"
08:15:34 <linduxed> there was no way to do a search for "matrix tolist" or something to that effect
08:15:52 <linduxed> so "toList" was the only option, which obviously dumped every toList function out there
08:15:55 <lyxia> "toList package:matrix"
08:16:16 <linduxed> lyxia: that works!
08:17:27 <dexterph> you coul dhave also just searched for the type
08:17:38 <dexterph> https://www.stackage.org/lts-6.11/hoogle?q=Matrix+a+-%3E+%5Ba%5D
08:17:38 <linduxed> hayoo seems to be working nicely though
08:17:57 <linduxed> i just wrote "tolist matrix" and it gave me what i wanted as the second result
08:18:00 <linduxed> so that's nice
08:19:15 <lyxia> yeah hayoo seems like the neatest one of the bunch
08:20:02 <geekosaur> hoogle handles fuzzy types better (that is searching by type instead of by name, it handles differences in polymorphism better than hayoo does)
08:20:09 <hpc> hayoo is more complete, but the site is pretty slow and hoogle's results are usually better
08:21:23 <maerwald> I have the opposite experience
08:22:14 <quchen> I’m also strongly favouring Hayoo these days
08:22:29 <quchen> Fast enough, better results, complete
08:22:41 <quchen> I never search for types though
08:26:36 <Welkin> I always use hayoo
08:26:42 <yyyyy> anyone knows if there's a way to bypass a package during `stack haddock`? i'm suffering from a haddock bug when building microlens as a dependency. `--keep-going` doesn't cut it.
08:26:58 <yyyyy> (latest haddock from git master)
08:28:58 <puregreen> yyyyy: you can bypass all dependencies (--no-haddock-deps), but that's probably not good enough for you
08:29:39 <puregreen> yyyyy: unfortunately I can't fix it on microlens side because Haddock seemingly can't be detected with CPP
08:30:20 <puregreen> hmmm, actually, what if I just did “ifdef GHC” or something, I wonder whether that'd work
08:30:37 <glguy> What is the bug, anyway? I've noticed a problem with microlens and haddock too, but I never went looking to see what it was
08:36:17 <puregreen> glguy: the bug is that Haddock crashes when I export each but not Each(..)
08:36:54 <puregreen> and I can't export Each(..) from the main Lens.Micro module because I don't want people writing lens-incompatible Each instances willy-nilly
08:37:28 <glguy> I'd consider it a bug to export a thing but not its type in general haddock asidd
08:37:43 <glguy> You should be able to write the type signatures of things
08:38:15 <glguy> What're the lens-incompatible each instances you're worried about?
08:39:28 <yyyyy> puregreen: there was a fix on the haddock repository, but it seems to have come back in newer versions.
08:39:37 <yyyyy> how would `ifdef GHC` change it?
08:40:02 <glguy> You should just fix microlens and then we have can the ability to write type signatures for things and also to see the haddocks
08:40:49 <yyyyy> puregreen: can't you add a warning for Each as a pragma? “This shouldn't be used directly” etc.
08:41:52 <yyyyy> microlens is great, btw :)
08:42:27 <puregreen> glguy: if your type signature involves microlens's Each you're likely doing something bad – specifically, if you export something that has microlens's Each as a constraint, it's unusable with types that have a lens-Each instance but not a microlens-Each instance. Cue people shouting at me “you're fracturing the ecosystem”.
08:42:58 <glguy> Maybe, but this is a hamfisted solution to those concerns
08:43:17 <glguy> I care more for the missing documentation than for the correctness of exporting the types though
08:43:33 <puregreen> glguy: moreover, you can already write signatures if you want to – just import Lens.Micro.Internal which has a warning at the top and stuff
08:43:43 <puregreen> it all was working pretty nicely until that Haddock bug
08:44:11 <puregreen> which I hoped would be fixed and not... fixed and then unfixed, apparently
08:44:40 <yyyyy> i can try tracking down the patch that did the regression and revert it, but i doubt it would go upstream.
08:45:23 <puregreen> yyyyy: “ifndef GHC” might be able to replace “ifdef HADDOCK”, in theory (I simply forgot to check that when I was looking for workarounds)
08:50:28 <puregreen> oh, by the way, while I'm busy with trying that: glguy, can you look at https://github.com/aelve/microlens/issues/83 (no idea why this was reported against microlens when fixing it in lens would've “raised awareness” much faster, but still)? Specifically, a) would lens accept a PR fixing this, and b) have you got any preference on how this should be done? So far I could only think of implementing an ordered set/map, but that might not be the best
08:50:28 <puregreen> approach.
08:51:13 <glguy> puregreen: I actually just saw that about 15 minutes ago. I guess it would be good to workaround that aspect of GHC. I cna do that upstream
08:54:29 <mcgru> hello! why my EclipseFP setup does not show context help on pressing F4 ?
08:55:06 <mcgru> hoogle, scion-browser, cabal is installed
08:56:12 <mcgru> "No result!" is shown on Hoogle tab serach result list
08:58:04 <AzureStigma> what does it mean variables and data constructors are term-level 
08:58:41 <Welkin> AzureStigma: they are not types
08:58:45 <Welkin> there are two namespaces
08:58:52 <Welkin> one for types and one for values
08:59:00 <AzureStigma> gotcha 
08:59:07 <AzureStigma> thanks broskii
08:59:24 <Welkin> at least that is how I interpreted your question
09:11:35 <AzureStigma> what is type variables vs type classes
09:12:34 <dexterph> AzureStigma: type variables are parametric polymorphism and type classes are ad-hoc polymorphism :) if that even helps
09:12:55 <AzureStigma> no
09:13:03 <AzureStigma> please put in lamens term 
09:13:37 <dexterph> do you know what each looks like and just want to know more about their differences? or do you not know what the terms refer to at all?
09:14:10 <AzureStigma> i know what they are
09:14:25 <AzureStigma> like type signature is like :t bool the result it gives i believe
09:14:47 <dexterph> both will show up in a type signature but that's not what they _are_ really
09:15:18 <dexterph> here: https://wiki.haskell.org/Polymorphism is probably a good primer, and explains better than i could on irc
09:15:18 <AzureStigma> :: Is a type signature right
09:15:52 <dexterph> yes :: defines a type
09:20:50 <AzureStigma> why is not (x == 5) false?
09:21:27 <lyxia> maybe x is 5?
09:22:36 <AzureStigma> okay making sure that it was going by that since i thoguht u first wuld have to put let x = 5
09:22:43 <AzureStigma> then ask not (x==5
09:23:01 <ertes> > let x = 5 in not (x == 5)
09:23:03 <lambdabot>  False
09:23:24 <AzureStigma> o okay so i was right thanks!
09:23:26 <lyxia> ah "not" was part of the expression...
09:24:03 <ertes> AzureStigma: whenever you talk about variables, be sure to know where they came from
09:24:32 <ertes> in the example above it came from a 'let' definition
09:24:52 <AzureStigma> i see he probably forgot to add it in the book
09:25:15 <AzureStigma> so how does not evaluate in lambda?
09:25:41 <ertes> 'not' is just a function of booleans
09:25:42 <ertes> :t not
09:25:43 <lambdabot> Bool -> Bool
09:25:46 <ertes> > not True
09:25:48 <lambdabot>  False
09:26:10 <AzureStigma> comparsion functions evaluate to a bool so i guess i wanted to see how it did that
09:26:18 <AzureStigma> in lambda terms
09:27:10 <ertes> in the example x = 5 is defined, so (not (x == 5)) first evaluates to (not True), then further evaluates to False
09:27:41 <ertes> not (x == 5) = not (5 == 5) = not True = False
09:27:49 <ertes> (under the assumption that x = 5)
09:32:52 <nitrix> AzureStigma: (==) as a lambda would be written (\x y -> x == y) if that was the question?
09:34:31 <nitrix> As to "how it did that [evaluating to a Bool]", it's because of the Eq type class.
09:34:44 <nitrix> :t (==)
09:34:46 <lambdabot> Eq a => a -> a -> Bool
09:34:55 <palat> :t (<>)
09:34:56 <lambdabot> Monoid m => m -> m -> m
09:36:33 <nitrix> The two type variables `a` are constrained to types that have an Eq instance. These types must implement that instance to describe how the equalty checks happens for that given type.
09:37:58 <nitrix> data Foo = F Int Int;  instance Foo where (F x y) == (F x' y') = x == x' && y == y'
09:38:01 <AzureStigma> yes thanks bro
09:38:08 <nitrix> Eqq, *Eq Foo
09:39:30 <nitrix> AzureStigma: I don't like being called "bro".
09:39:37 <AzureStigma> i apologize
09:39:46 <AzureStigma> thanks nitrix
09:40:10 <Welkin> nitrix: bru?
09:41:14 <nitrix> Welkin: Pertinent, as always.
09:42:53 * hackagebot hindent 5.0.0 - Extensible Haskell pretty printer  https://hackage.haskell.org/package/hindent-5.0.0 (ChrisDone)
09:44:21 <palat> thanks bro
09:45:16 <palat> sum 1 2
09:45:43 <palat> How do I get the bot to compute something
09:45:48 <puregreen> > sum 1 2
09:45:50 <lambdabot>      Could not deduce (Num a0)
09:45:50 <lambdabot>      from the context (Num a,
09:45:50 <lambdabot>                        Num (t (a -> t1)),
09:45:51 <puregreen> er
09:45:54 <puregreen> > sum [1,2]
09:45:54 <byorgey> palat: you have to put > in front of it
09:45:55 <lambdabot>  3
09:45:59 <palat> ah ok
09:46:08 <palat> :t foldr
09:46:10 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
09:46:22 <nitrix> palat: You'd prefix your expression with `>` to evaluate that expression. It doesn't execute side-effects.
09:46:36 <palat> > foldr (+)  0 [1,2,3]
09:46:37 <lambdabot>  6
09:46:51 <pipeline_> hello
09:47:04 <byorgey> hi pipeline_ 
09:47:10 <nitrix> palat: For just experimenting, it's probably better to do so in private or in GHCi, unless you have a specific question.
09:47:35 <puregreen> yyyyy: okay, I found that “#if defined(__GHC__) || ...” works, expect a new release shortly
09:47:57 <palat> :t lazyByteStringHexFixed
09:47:58 <lambdabot> Not in scope: ‘lazyByteStringHexFixed’
09:48:41 <nitrix> You want Data.ByteString.Lazy.Builder.ASCII.lazyByteStringHexFixed
09:48:52 <nitrix> Data.ByteString.Lazy.Builder.ASCII is not imported by default.
09:48:58 <palat> yeah forgot the path
09:49:45 <dfeuer> GRRRR
09:50:03 <pie_> you guys ever play with nim (language)?
09:50:24 <palat> sounds like a combination of nano and vim
09:50:50 <dfeuer> I want a portable way to tell GHC to kindly separate a function into a worker and a wrapper, to INLINE the wrapper, and NOINLINE the worker.
09:51:02 <dfeuer> But I can't.
09:51:23 <dfeuer> Unless I use unboxed tuples.
09:51:25 <puregreen> pie_: I once took a small freelance job in Haskell and ended up rewriting everything in Nim after spending two days unsuccessfully trying to optimise Haskell code
09:51:43 <glguy> Nim would be generally off-topic in #haskell. There might be a #nim, though.
09:51:44 <pie_> heh
09:52:29 <c_wraith> dfeuer, when is it important to NOINLINE the wrapper? 
09:52:33 <pikajude> is there an implementation of the van Laarhoven free monad for which I could add an Error effect (that is, with catchError :: m a -> (e -> m a) -> m a)
09:52:37 <c_wraith> err, worker. 
09:52:58 <dfeuer> c_wraith, when it's big and you don't want your code to balloon?
09:53:07 <dfeuer> c_wraith, probably other times too?
09:53:38 <dfeuer> I know how to do exactly what I want by hand with unboxed tuples, but I don't know any *other* way to do it.
09:54:28 <c_wraith> hmm. can you just split into multiple top level definitions? 
09:54:48 <yyyyy> puregreen: nice! i'll be waiting for it. thanks for the quick response into this.
09:55:09 <puregreen> yyyyy: if only I had thought of that three months ago when it was reported, tho :(
09:57:17 <dfeuer> c_wraith, in Data.Map, we have   data Map k v = Bin !Int k v !(Map k v) !(Map k v) .  We have a balancing "smart constructor"  balance :: k -> a -> Map k a -> Map k a -> Map k a which is big and complicated.
09:57:34 <dfeuer> Currently, balance is marked NOINLINE.
09:57:47 <dfeuer> I'd like GHC to be able to see that its result is always a Bin constructor.
09:58:36 <dfeuer> I think I can do that by using a worker producing  (# Int#, k, v, Map k v, Map k v #), which can be marked NOINLINE, and a wrapper that applies Bin.
09:59:52 <Zemyla> dfeuer: Doesn't containers have to stay compatible with Hugs and NHC?
10:00:00 <c_wraith> my thought was breaking it into a wrapper that can be inlined, then a second worker/wrapper definition marked NOINLINE. 
10:00:23 <Zemyla> Wait, you can use CPP.
10:00:50 <dfeuer> Zemyla, we haven't tested against those in ages, and (following a message to various lists) I've stripped out all the code trying to maintain that compatibility.
10:01:08 <glguy> niteria: Is your lens issue resolved by the commit a few minutes earlier?
10:01:09 <dfeuer> c_wraith, what can the types look like?
10:02:03 <geekosaur> ... people care about compatibility with hugs, when hugs hasn't been updated since 2006? (nhc98 has been dead even longer; the answer is "no")
10:02:10 <Zemyla> Actually, you could have the return type be basically (Int -> k -> v -> Map k v -> Map k v -> r) -> r.
10:02:43 <niteria> glguy: possibly, I opened the issue before seeing the commit
10:02:59 <c_wraith> probably very similar to what you've already got. the NOINLINE function would return an unboxed tuple of the arguments to the Bin constructor 
10:03:36 <Zemyla> Oh, dfeuer, I can't benchmark this, but could you make the unstable sort in Data.Sequence stable by having the heap store an index with each value?
10:03:50 <dfeuer> c_wraith, the question is whether there's any way to do it without hand-unboxed tuples.
10:04:18 <Zemyla> dfeuer: You do it using Church-encoding, like I mentioned.
10:04:30 <dfeuer> Zemyla, sure you could. It would be interesting to benchmark that. It would also be interesting to try using fancier heap implementations.
10:05:05 <Zemyla> I'm going to see how much increasing my EC2 quota is.
10:05:21 <dfeuer> Zemyla, NOINLINE will prevent GHC from seeing that what you're passing in *is* the continuation.
10:05:21 <c_wraith> well, you really don't want that boxing. I don't think ghc will remove it if it can't inline the worker, so.. 
10:06:17 <Zemyla> dfeuer: Right. I mean, Agda or Idris might see it based on parametricity, but Haskell's type system is unspund.
10:06:21 <Zemyla> *unsound
10:06:40 <niteria> glguy: that's less fixing than I expected, is this the only place where Set Name, Map Name a are turned into lists?
10:07:02 <niteria> I'm looking at typeVarsEx now
10:07:34 <Zemyla> Actually, if the return type in an Agda function only appears as the return type of a function you're passing it, does it realize that it can only come from that function?
10:08:18 <niteria> hm it looks to be OK
10:09:33 <c_wraith> dfeuer, what's the unportability you're worried about with unboxed tuples? 
10:10:13 <dfeuer> c_wraith, hypothetical future Haskell implementations other than GHC.
10:10:16 <Zemyla> Also, dfeuer, why doesn't IntMap store its size? Keeping size updated from the outside is an uphill battle.
10:10:30 <dfeuer> Zemyla, because it's expensive and not always necessary.
10:11:05 <dfeuer> Zemyla, it costs an extra word per tree node, which is pretty lousy in a binary tree.
10:11:51 <c_wraith> dfeuer, I'm not sure that goal is worth the effort you're putting in here. any such implementation will likely have such different performance characteristics that lots more of the current implementation wouldn't be a good idea anyway. 
10:12:17 <dfeuer> Zemyla, if you want, you can copy the source code and add one, making a new SizedIntMap.
10:12:41 <glguy> niteria: So what goes wrong with the order of type variables in the forallT changes?
10:12:53 <glguy> niteria: What does GHC do with that order?
10:16:19 <Zemyla> dfeuer: Actually, what I would probably wind up doing is have SizedMap f k v and SizedIntMap f v, where f is an instance of class Sized f where size :: f a -> Int.
10:16:35 <Zemyla> So each element in it can be sized, for nested maps.
10:17:13 <dfeuer> Zemyla, yeah, that's better.
10:17:35 <joeyh> ocharles: you around? Your argon2 package seems to be generating truncated hashes (probably up until NUL)
10:17:52 <dfeuer> I wish it were easier to write Haskell code that could handle both cases nicely, but I don't want to spew TH or whatever all over the place.
10:20:02 <Zemyla> Also, the other thing I would fix with my SizedMap and SizedIntMap would be makimg insertLookupWithKey work the same way for both of them. Because seriously, what is up with that?
10:21:49 <greg`> 🙊
10:22:37 <schjetne> jackdaniel: excellent work on the CLIM web page! I also have to try Masamune some time soon, looks really interesting
10:29:15 <greg`> whats the clim page?
10:29:36 <Symbiont> I
10:30:34 <palat> I
10:30:43 <Welkin> why are you a monkey?
10:30:53 <acowley> cocreature: Yet another annoyance: the LLVM shared library name is wrong for me using nix to build llvm. The only solution I've come up with is manually looking in the lib directory in Setup
10:32:55 * hackagebot mech 0.0.0.0 - mecha are the most complex composite machines known to humanity, lets build them well!  https://hackage.haskell.org/package/mech-0.0.0.0 (CarterSchonwald)
10:32:57 * hackagebot Mecha 0.0.0.0 - mecha are the most complex composite machines known to humanity, lets build them well!  https://hackage.haskell.org/package/Mecha-0.0.0.0 (CarterSchonwald)
10:32:59 * hackagebot mechs 0.0.0.0 - mecha are the most complex composite machines known to humanity, lets build them well!  https://hackage.haskell.org/package/mechs-0.0.0.0 (CarterSchonwald)
10:33:01 * hackagebot hopenpgp-tools 0.19.2 - hOpenPGP-based command-line tools  https://hackage.haskell.org/package/hopenpgp-tools-0.19.2 (ClintAdams)
10:33:15 <greg`> i was just playing at being a monkey
10:36:13 <johnw> carter: what in the world is that all about?
10:37:55 * hackagebot Mechs 0.0.0.0 - mecha are the most complex composite machines known to humanity, lets build them well!  https://hackage.haskell.org/package/Mechs-0.0.0.0 (CarterSchonwald)
10:38:08 <maerwald> -.-
10:38:13 <johnw> i wonder if his account was hacked
10:38:22 <maerwald> the modules are empty
10:38:38 <johnw> this really isn't like him either
10:39:23 <mizu_no_oto_work> Could have left his computer unlocked
10:39:34 <mizu_no_oto_work> And this is someone's idea of a prank
10:39:56 <johnw> i'll send him an SMS
10:40:10 <maerwald> well, it's more confusing than funny... but yeah
10:40:42 <lambdamu> hi everyone, is it expected that the following type declaration fails with "Operator applied to too few arguments: *" when TypeInType is activated
10:40:45 <lambdamu> data Foo (xs :: [*]) where
10:40:45 <lambdamu>   Bar :: Foo '[]
10:41:16 <niteria> glguy: the will affect how things get specialized or how worker-wrapper happens
10:41:23 <niteria> they*
10:41:50 <lambdamu> There was talk about an alternative name for *, but did that ever happen?
10:42:02 <johnw> ok, carter is not hacked, he actually uploaded those; so now begins a different conversation... :)
10:42:19 <geekosaur> I think Any is available as a different name?
10:42:32 <carter> maerwald: will upload a build able version shortly
10:42:37 <geekosaur> (and this has itself provoked a few bugs...)
10:42:58 <nitrix> lambdamu: Are you talking about TYPE Lifted ?
10:43:11 <carter> Either way, I was also curious if case insensitivity was added to hackage server yet ;)
10:43:18 <nitrix> type * = TYPE Lifted
10:43:27 <nitrix> type # = TYPE Unlifted
10:43:35 <lambdamu> nitrix: That looks right
10:43:52 <nitrix> lambdamu: It's effective as of GHC 8. * and # are now aliases.
10:43:54 <mniip> there was a proposal for something like type T = *
10:44:31 <mniip> and gradually removing * from the language
10:45:02 <lambdamu> Whats about the orginal error though, should I report it or is it expected that * doesn't work with TypeInType in all cases?
10:46:22 <nitrix> lambdamu: The situation now is  `a :: forall (a :: TYPE v) (v :: Levity). a`
10:46:28 <nitrix> lambdamu: where data Levity = Lifted | Unlifted
10:46:57 <nitrix> Then you ahve the two type aliases above for * and #. The goal is unifying types and kinds.
10:47:55 * hackagebot file-modules 0.1.2.4 - Takes a Haskell source-code file and outputs its modules.  https://hackage.haskell.org/package/file-modules-0.1.2.4 (yamadapc)
10:51:47 <thoughtpolice> lambdamu: Yes, it's called 'Type'
10:52:54 <lpaste> Glaukon pasted “RecursiveDo problem” at http://lpaste.net/175892
10:53:27 <thoughtpolice> lambdamu: Leaving it as * with -XTypeInType is syntactically kludgy (especially if you want something like a type-level multiply) so when you enable that extension you can import Data.Kind to get 'Type' itself or '*', which is now just a type-alias for some other 'magical' built in.
10:53:57 <thoughtpolice> lambdamu: And similarly Data.Kind defines 'type Type = *' now, so you can move away from *
10:54:28 <thoughtpolice> It also means you can enable -XTypeInType and hide '*' using something like 'import Data.Kind hiding (type (*))'
10:55:36 <lambdamu> thoughtpolice: Ah thank you, Data.Kind was what I was looking for
10:55:43 <glaukon> I'm having a problem with RecursiveDo (mdo). There are two slightly different functions that should produce the same output, but they don't (see proc1 and proc2 in the pasted code).
10:55:49 <lambdamu> thoughtpolice: hoogle suggested GHC.Types
10:56:29 <thoughtpolice> Technically, Data.Kind is just a re-export of GHC.Types, but you should use it anyway since GHC.* modules have little guarantees.
10:56:36 <nitrix> lambdamu: GHC.Types is the lower level implementation stuff. Where TYPE is :: ReuntimeRep -> * and stuff.
10:56:41 <nitrix> lambdamu: It's not pretty down there :P
10:57:12 <lambdamu> yes, I was hesitant to depend on ghc-pri
10:57:13 <lambdamu> m
10:57:53 <nitrix> I'm not sure what the Phase 2 entails, but there's more work ahead.
10:58:11 <nitrix> Meanings a few things are bound to change and complexify.
11:02:56 * hackagebot cabal 0.0.0.0 - placeholder for Cabal package, you want the upper case Cabal  https://hackage.haskell.org/package/cabal-0.0.0.0 (CarterSchonwald)
11:03:45 <dcoutts> carter: ^^ ?
11:04:35 <carter> Dcoutts im tired of the shitty error message when Someone forgets to capitalize cabal. 
11:04:54 <dcoutts> carter: cabal's cli is case insensitive
11:05:06 <carter> The cabal file isn't though
11:05:16 <dcoutts> I'm not sure this is a good solution
11:05:24 <carter> I agree
11:05:35 <carter> But it's the one I could deploy today
11:05:54 <dcoutts> I don't want to encourage polluting the namespace with fake packages
11:06:34 <dcoutts> carter: if you used 'cabal' in a build-depends in a .cabal file you'll get an error about no such package existing
11:06:47 <dcoutts> so what's the problem you're trying to solve exactly?
11:06:52 <hexagoxel> most package luckily are lowercase already, so the problem is rare.
11:08:11 <carter> The it's not a good error message problem.   Also cabal should have been a disallowed upload.  Now it is
11:09:02 <dcoutts> carter: ok, can you at least make sure there's a ticket about the error message
11:09:09 <dcoutts> it doesn't sound that hard to fix
11:09:17 <carter> Will do.
11:09:25 * hexagoxel recently discovered there are "extra" and "Extra" packages.
11:11:19 <hexagoxel> i wonder how many other only-case-distinguished pairs there are.
11:11:41 <glguy> safe and Safe is one
11:12:41 <johnw> i almost wish that case-insensitive and Case-Insensitive was another
11:12:50 <hexagoxel> heh
11:14:02 <carter> I'm just being a tad off the rails and I also realized that an unlocked down lower case cabal is a problem 
11:14:16 <yamadapc> I was mirroring hackage earlier today, so happy I had gone through the whole alphabet of packages... Then I noticed there were 60k+ more starting with lowercase letters :|
11:15:35 <johnw> yamadapc: what are you using to mirror it?
11:16:41 <yamadapc> just the hackage-mirror in hackage-server, with some patches
11:16:57 <johnw> ah, ok
11:17:10 <johnw> but not the utility on Hackage called "hackage-mirror" :)
11:17:36 <yamadapc> no; I wanted to get the smart hackage running
11:17:44 <johnw> ah, right
11:18:02 <yamadapc> now I'm in the process of uploading some of the state to S3
11:22:01 <yamadapc> why? is there something I should know about hackage-mirror? I'd guess it's much faster & smaller, but idk
11:22:44 <johnw> it is, but only mirror the file tree for directly use by cabal
11:24:33 <dcoutts> yamadapc, johnw: if you want a minima mirror these days then you don't want to use the hackage-mirror package on hackage, as it only does the old non-secure format. There's a new mirroring tool for efficiently doing nearly-live mirroring for the secure format.
11:24:34 <dmwit> carter: Great, so now if somebody tries `cabal install cabal` they're going to get the wrong thing where before they wouldn't? I'm not sure you really thought this through...
11:24:56 <carter> Dimwit : try
11:24:59 <johnw> dcoutts: ah
11:25:03 <carter> It still works
11:25:23 <yamadapc> dcoutts: you mean the local option on hackage-server/HackageClient or...?
11:25:29 <carter> Cabal cli is case insensitive...
11:25:31 <carter> Fuck
11:25:36 <carter> Fuck fuck fuck
11:25:40 <johnw> um, language
11:25:42 <dcoutts> :-)
11:26:17 <carter> dcoutts: it's not case insentive any more
11:26:19 <dmwit> carter: Okay, I tried. It doesn't still work.
11:26:21 <dcoutts> yamadapc: that's one impl, yes, and there's another one that hvr wrote recently that's a bit more efficient with memory use
11:26:36 <yamadapc> I wonder if the case thing it causes a bug in OSX
11:26:39 <dmwit> carter: Can I recommend that you contact a Hackage trustee ASAP to undo this?
11:26:53 <carter> I am a trustee. You can't undo stuff
11:26:55 <dcoutts> dmwit: carter is a hackage trustee :-)
11:27:22 <dcoutts> we will now enslave carter until he writes a patch to allow deletion :-)
11:27:36 <dmwit> carter: So, you did something you knew you wouldn't be able to undo, which was the wrong solution to a minor problem, without asking anybody who would be affected?
11:28:01 <carter> Well, at least it's a known person who fucked up :)
11:28:13 <carter> Not some malicious actor
11:28:20 <hexagoxel> carter: should have added a dependency on the you-want-upper-case-Cabal package.
11:28:27 <hexagoxel> x-version that in?
11:28:44 <dcoutts> dmwit: btw, we're always trying to recruit good hackage trustees :-)
11:28:45 <carter> hexagoxel: you can't add new deps in revisions
11:28:55 * hexagoxel has not checked that that would improve the error message
11:29:22 <carter> Hexagonal, I think making it not constrain base would help.  Lemme try that
11:30:24 <dmwit> dcoutts: Hm. It sounds like fun, but I'm not really looking for new responsibilities at the moment.
11:30:30 <dcoutts> 'k
11:30:37 <yamadapc> can't you deprecate packages? that's a nice feature in NPM; not removing though
11:30:38 <carter> Hex hexagoxel try now?
11:30:56 <yamadapc> it'll just display a big yellow warning when you install
11:31:09 <hexagoxel> cabal update "Skipping download: local and remote files match."
11:31:25 <carter> Damn cdn
11:32:59 <puregreen> dcoutts: how much work is being a trustee? 
11:33:11 <carter> Cabal get still gives me revision 1
11:33:19 <dcoutts> puregreen: depends on how much time you want to put in
11:33:20 <hpc> can i put "hackage trustee" on my resume and then just not do anything? :D
11:33:35 <athan> hpc: Yes
11:33:57 <dcoutts> hpc: yes but we won't buy you beers at hackathons :-)
11:34:04 * athan is sorry he couldn't resist, and will shutup back to the shame corner ._.
11:34:06 <carter> https://www.irccloud.com/pastebin/tQS5aMqD/good%20error%20messages
11:34:07 <hpc> lol
11:34:12 <carter> ok, revision 3 looks good
11:34:19 <carter> next goal: youProbablyWantCapitalCabal (dependency of cabal-0.0.0.0)
11:34:25 <Welkin> revision 3 is defunct
11:34:39 <carter> que?
11:34:50 <Welkin> Revision3 I mean
11:34:58 <carter> explain
11:35:01 <Welkin> lol
11:35:09 <carter> i mean revision 2
11:35:20 <Welkin> it's a game news company owned by discovery that shut down 2 years ago
11:35:29 <dcoutts> puregreen: if you want to get a good idea, join #hackage and talk to hvr
11:35:59 <carter> dcoutts:  do you approve of my approach to revision2? :)
11:37:43 <hexagoxel> "next goal: youProbablyWantCapitalCabal (dependency of cabal-0.0.0.0)"
11:39:14 <hexagoxel> works too if requesting "cabal" indirectly.
11:40:29 <hexagoxel> (presuming you want to call this hack "work"ing at all :p)
11:53:39 <yamadapc> out of curiosity... to deploy hackage-server you build binaries on the production server?
11:54:52 <Welkin> you never have to build anything on a server
11:54:55 <Welkin> you deploy the binary
11:56:25 <yamadapc> no packaging?
12:01:28 <yamadapc> but I mean; on this specific instance, just because on the wiki there was a comment about https://github.com/haskell/hackage-server/wiki/Community-server:-server-layout
12:22:58 * hackagebot vty 5.8 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.8 (JonathanDaugherty)
12:23:00 * hackagebot cassava-streams 0.3.0.0 - io-streams interface for the cassava CSV library.  https://hackage.haskell.org/package/cassava-streams-0.3.0.0 (PeterJones)
12:24:58 <mheinzel> A question regarding transformer stacks: The interpreter I am working on runs in a Interpreter a = Interpreter { unwrap :: ContT Object (StateT InterpreterState IO) a }.
12:25:48 <mheinzel> When I encounter an error in the program, I call a continuation which terminates execution.
12:26:01 <tolt> does anyone know where the source for hackagebot is?
12:26:30 <mheinzel> But I need a way to tell whether the execution was ended by an error or not.
12:26:50 <ClaudiusMaximus> @hackage rss2irc -- tolt, think it's one of these
12:26:50 <lambdabot> http://hackage.haskell.org/package/rss2irc -- tolt, think it's one of these
12:27:07 <mheinzel> I could simply add a flag to my InterpreterState and check it, but it feels slightly hacky.
12:27:23 <tolt> ClaudiusMaximus: awesome thanks!
12:27:46 <mheinzel> Would it be better to add something like ExceptT to the stack?
12:29:24 <sm> tolt: http://hub.darcs.net/simon/rss2irc
12:30:13 <tolt> sm: I didn't even think to ask the maintainer owner... my bad. Thank you though!
12:37:59 * hackagebot stratosphere 0.1.4 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.1.4 (jdreaver)
12:38:01 * hackagebot tz 0.1.2.0 - Efficient time zone handling  https://hackage.haskell.org/package/tz-0.1.2.0 (MihalyBarasz)
12:41:13 <lambdamu> mheinzel: generally speaking i found that being pedantic with monad stacks isn't really worth it, i'd probably just a flag
12:41:26 <lambdamu> *set
12:42:25 <mheinzel> okay, thanks.
12:49:45 <nitrix> Can stack list all versions of all packages it chose to use to build a project?
12:50:51 <nitrix> For some reason, one project on windows is building fine with `directory`, and another fails on it because of `sh / setup.exe` is missing. I suspect the first one is successful because directory is shipped by the haskell platform and it manages to pick it up because the version matches, while the other project probably has different requirements?
12:53:50 <sm> stack exec -- ghc-pkg list ?
12:54:25 <dmwit> mheinzel: I think I'd probably replace `ContT` with `ExceptT` if all you're doing with it is using it to exit early on errors.
12:54:39 <dmwit> mheinzel: (rather than adding `ExceptT` to the stack)
12:56:14 <mheinzel> dmwit: I need ContT for control flow handling (loops, break, continue, try, except, ...)
12:57:11 * dmwit nods
12:58:12 <nitrix> sm: Solved. Your command confirmed the versions were the same and the package picked up from a common stack place of HaskellPlatform.
12:58:28 <nitrix> sm: The issues, as it turns out, was a forgotten extra-deps in stack.yaml
12:58:42 <nitrix> sm: Thanks :)
12:58:50 <sm> great. I alias that to stack-list, it's quite useful
13:06:37 <ahsfhyicxv> Is there a good library for haskell that can parse amounts like "1000 mg salt" -> {num: 1000, unit: "mg", of_what: "salt"}?
13:09:28 <ongy> ahsfhyicxv: will your input always be 3 words like that?
13:10:56 <sm> ahsfhyicxv: looks a bit like http://hackage.haskell.org/package/hledger-lib-0.27.1/docs/Hledger-Read-JournalReader.html#v:amountp
13:11:01 <yyyyy> ahsfhyicxv: any of the parsing libraries can handle that easily. try `parsec`.
13:12:16 <lambdamu> i would use megaparsec over parsec
13:13:36 <ahsfhyicxv> ongy: No
13:15:40 <ahsfhyicxv> I will look into those libraries. Thanks
13:20:38 <johnw> ahsfhyicxv: I have a commodities library that is good at doing math with multiple commodities
13:24:42 <yyyyy> lambdamu: i've never used megaparsec. what do you get over parsec?
13:26:51 <sm> yyyyy: more docs, maintenance, features
13:28:14 <glguy> Is that all?
13:28:58 <ahsfhyicxv> sm: amountp' "1000 mg salt" gives an error
13:29:14 <ahsfhyicxv> unexpected "s"
13:29:14 <ahsfhyicxv> expecting "@"
13:29:29 <sm> well, I didn't say it was a ready-made solution to your unique problem :)
13:29:57 <puregreen> glguy: parse errors that are actually a data type and you can inspect them and work with them + a MonadParsec class (parsers-style) that's kinda useful
13:30:20 <puregreen> indentation parsing
13:30:28 <hackrilege> hi, i made this paste yesterday, but i only finished when everyone was asleep, i was hoping i could get some feedback today.
13:30:29 <hackrilege> http://lpaste.net/175773
13:30:34 <sm> http://hledger.org/journal.html#amounts is what it parses. Similar syntax to what johnw is talking about also. If you need something more custom, you could look at those parsers for  ideas
13:32:12 <puregreen> and – most important of all, doubtlessly – a <|> that doesn't clash with the one in Control.Applicative
13:36:44 <hackrilege> is the approach taken here found elsewhere? iv been directed towards the type family 'key' which is similar, but really i would like to talk about the function 'tweak' and this approach of operating on the arguments that are supplied to a function; http://lpaste.net/175773
13:38:10 <lyxia> hackrilege: why did you define a wrapper for (->)
13:38:38 <yyyyy> sm, puregreen: sounds interesting. i'll take a look.
13:38:40 <hackrilege> :t (!!)
13:38:42 <lambdabot> [a] -> Int -> a
13:39:27 <hackrilege> i guess i was trying to separate out the notion of an index for a monad, but keeping things as polymorphic as possible
13:40:41 <hackrilege> i hoped that if i just treated (Int->b) is if it were ([a]!!) then i would derive a more general (!!!), which i did
13:40:55 <hackrilege> for (a->b)
13:41:46 <hackrilege> i mean; (!!!) :: f b -> T f -> b for some associated type T f
13:42:14 <hackrilege> does that make sense lyxia?
13:42:30 <dmwit> No, it doesn't explain why you defined a wrapper for `(->)`.
13:42:42 <lyxia> :t \f a -> (\ a b -> a (f b)) a
13:42:43 <lambdabot> (r2 -> r1) -> (r1 -> r) -> r2 -> r
13:42:56 <lyxia> :t flip (.)
13:42:57 <lambdabot> (a -> b) -> (b -> c) -> a -> c
13:43:01 * hackagebot preliminaries 0.1.2.0 - A larger alternative to the Prelude.  https://hackage.haskell.org/package/preliminaries-0.1.2.0 (yghor)
13:43:33 <hackrilege> this looks promising, what are you getting at?
13:44:03 <lyxia> I'm trying to understand what you are getting at actually.
13:44:11 <glguy> puregreen: Oh, well if that's all ;-) (but seriously it does sound pleasant)
13:45:18 <hackrilege> ok, so i have some synonyms and classes and stuff (wrappers) around what you identify as simple function composition, thats fine so long as you dont berate the overhead, i guess it was just something i needed to write for myself to be able to communicate what i was getting at.
13:45:31 <dmwit> hackrilege: I don't know what lyxia is getting at. But what I'm getting at is: what goes wrong if you use `(->)` in place of `Accessor` everywhere? You will have less code, and some of your functions will just be the identity (hence not worth defining).
13:46:00 <hackrilege> i guess i didnt want such an overlapping instance?
13:46:20 <dmwit> What does it overlap with?
13:47:02 <hackrilege> instance Accessible (->) where access = id
13:47:16 <amf> the time package added a new function that unpacks new-typed data, its literally, d2p :: (MkD (MkFixed p)) = p; unfortuntately i cant get my app (via stack & co) to play nicely with time 1.6 as everyone depends on 1.5, thus, is there a way to unwrap without knowing MkD?
13:47:36 <amf> or recommend a time / date library that isnt so difficult to use :)
13:48:01 * hackagebot postgresql-binary 0.9.1 - Encoders and decoders for the PostgreSQL's binary format  https://hackage.haskell.org/package/postgresql-binary-0.9.1 (NikitaVolkov)
13:48:03 * hackagebot hasql 0.19.15 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.19.15 (NikitaVolkov)
13:48:17 <hackrilege> basically, instead of passing around objects, you pass around the object with its accessor applied, and then you can perform functions on the accessor, such as tweak
13:49:21 <hackrilege> eg (\f -> (\aTob -> \a -> aTob (f a)))
13:50:29 <Marqin> howdy, is there some still maintained GUI library fro Haskell? I'm checking those from https://wiki.haskell.org/Applications_and_libraries/GUI_libraries but they seem  not beeing actively developed :/
13:50:39 <lyxia> instance Accessible (->) would not overlap with anything...
13:51:03 <lambdamu> Marqin: fltkhs is pretty active
13:51:13 <hackrilege> ok, so presume i rewrote it with that ammendment which i hope will work because it sounds great
13:52:04 <hackrilege> if i give you [a] you can use !! to access its elements. if i give you [a]!! :: Int -> a, then you can act on the Int or the List...
13:52:27 <Marqin> lambdamu: thx, so something more than just hsqml
13:52:28 <yyyyy> amf: `hourglass` is quite nice, but i think it's easier for you to just stick to 1.5 instead of updating time.
13:53:01 * hackagebot deque 0.1 - Double-ended queue  https://hackage.haskell.org/package/deque-0.1 (NikitaVolkov)
13:53:05 <Marqin> lambdamu: that flkt looks ugly
13:54:05 <amf> yyyyy: totally forgot about hourglass! thanks for the reminder, ditching time as i cant access one of its data types so its useless to me
13:54:48 <lambdamu> Marqin: haha, i don't know, i haven't used it, i just mentioned it because the author promoted it a few times recently and it looks maintained
13:55:17 <lambdamu> Marqin: that can not be said about the bindings to qt or gtk afaik
13:55:57 <hackrilege> would it be helpful if i made that amendment?
13:56:07 <sm> Marqin: beggars can't be choosers :)
13:56:25 <hackrilege> its just it seems like its a triviality
13:56:37 <Welkin> sm: beggars can choose lots of things
13:56:46 <Welkin> unless your argument is against free will
13:56:48 <sm> it's just an expression :)
13:57:16 <sm> fltkhs seems to be maintained and reasonably portable/installable, that's not common in haskell GUI land 
13:57:48 <Welkin> it seems like GUIs are not a haskell problem. because all of them universally suck
13:57:52 <Welkin> and no one likes any of them
13:58:02 * hackagebot difftodo 0.1.0 - Generate todo lists from source code  https://hackage.haskell.org/package/difftodo-0.1.0 (jml)
13:58:10 <lambdamu> Marqin: there seems to be new bindings for qt, though
13:58:22 <lambdamu> Marqin: http://khumba.net/projects/qtah/
13:58:28 <lyxia> hackrilege: I just don't see what you find interesting in what you wrote.
13:58:33 <sm> I don't think they're such a problem for a dot net or objective-c/swift developer
13:58:47 <hackrilege> ok!
13:58:53 <Marqin> lambdamu: oh
13:59:00 <lambdamu> Marqin: haven't used them either, not sure anyone has at 11 hackage downloads, but give it a shot if you like
14:00:00 <hackrilege> i needed to have a discussion about efficiency and i wrote this post to illustrait it
14:04:37 <dmwit> hackrilege: Here is what I'm getting at. A version with none of the Access or Accessor nonsense, but the exact same functionality.
14:04:42 <dmwit> hackrilege: http://lpaste.net/annotate/175773
14:05:37 <Marqin> lambdamu: i think i'll stay with HsQML
14:06:25 <glguy> dmwit: http://lpaste.net/176006 ?
14:07:16 <dmwit> It's at the bottom of the link I pasted.
14:07:18 <dmwit> ...I think.
14:07:34 <yyyyy> amf: np :)
14:07:38 <dmwit> hackrilege: And if you stare at `HasAccess`, and then stare at the `Indexable` class from `keys`, which I pointed you at yesterday, you will see some striking similarities.
14:08:11 <Marqin> lambdamu: qtah look more like oriented for creating GUI with code, and hsqml uses Qt QML for creating GUI 
14:08:33 <ertes> i find that GUI frameworks are really not that terrible
14:08:38 <dmwit> glguy: Oh, odd. I wonder how that `annotate/` got in there.
14:09:21 <dmwit> hackrilege: Apologies for my mispaste. http://lpaste.net/175773 has my annotation, or glguy gave a direct link to the annotation as well.
14:09:56 <ertes> they can be horrible to learn, because you get a plethora of different (and sometimes even redundant) widgets thrown at you, each with a giant number of properties, most of which you'll never need
14:10:39 <dmwit> hackrilege: In short: `Accessor a b` just becomes `a -> b` everywhere. And the only way you ever used a value of type `Access f a b` was to apply its two fields to each other to get an `a -> b`; so `Access f a b` *also* becomes `a -> b` everywhere.
14:10:51 <ertes> but they aren't really that terrible to *use*…  just make sure you don't write event handlers
14:12:11 <lambdamu> Marqin: Yes qtah semms ot bind all of qt's c++ api, I imagine it can do somewhat more than QtQuick, but the QML approach certainly has it's merits and if suits no reason to change it
14:12:41 <hackrilege> hmmmmmmmmmmm interesssting
14:14:57 <pikajude> is there an implementation of the van Laarhoven free monad for which I could add an Error effect (that is, with catchError :: m a -> (e -> m a) -> m a)
14:15:37 <hackrilege> ok anyway, thanks i didnt realise how much overhead i had introduced needlessly. but still i wanted to talk about something else and just use the paste as reference, thanks dmwit for cleaning up the paste so thats not all that will be worth talking about
14:19:11 <dmwit> Is there a Monad Emancipation Proclamation? Are all monads free?
14:19:23 <hackrilege> :t flip (.) $ (-1) $ ([3]!!)
14:19:24 <lambdabot> (Num a1, Num ((Int -> a1) -> a -> b)) => (b -> c) -> a -> c
14:19:41 <dmwit> :t flip (.) (subtract 1) ([3]!!)
14:19:43 <lambdabot> Num c => Int -> c
14:19:54 <hackrilege> thanks
14:20:03 <hackrilege> ok, well yes that is a lot shorter
14:20:04 <hackrilege> thanks
14:21:16 <hackrilege> can we say anything more general about this flip (.) business?
14:21:26 <dmwit> More general than what?
14:21:35 <monochrom> I'm pretty sure most monads we use are not free.
14:21:48 <c_wraith> :t flip fmap
14:21:49 <lambdabot> Functor f => f a -> (a -> b) -> f b
14:22:08 <c_wraith> there. more general. :) 
14:22:16 <dmwit> :t (>>>)
14:22:16 <hackrilege> im menling
14:22:17 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
14:22:20 <hackrilege> melting*
14:22:35 <dmwit> More general in another direction.
14:22:45 <Wizek> Hey! Anyone might have an idea how to deal with this 'ambiguous type variable' type error mentioned in the body of this commit message? https://github.com/Wizek/haskell-dependency-injection/commit/7d31ae72107abb6ebdee111d0ed923cc2430009e#diff-63e7d2cbf23880a9c902c91fa34f6043R73
14:24:51 <Wizek> I've been trying to make dependency injection work in haskell to ease testing and allow for powerful mocking capabilities, but I seem to be at odds with the type system, even while resorting to such dark magic as Data.Dynamic.
14:27:32 <hackrilege> wow that code is hard to read, ill have to clean my specs
14:28:35 <Cale> hackrilege: Now you know how I feel :D
14:28:36 <monochrom> Wizek, you have to specify what type you would like for dynF $> fromDynamic $> fromJust.
14:29:05 <monochrom> This is totally a downcast. Downcast is fine but you have to say downcast to what.
14:29:10 <Cale> But yeah, the problem is basically that whenever you use applyMany, you'd better specify the type of its argument
14:29:12 <hackrilege> Hi Cale, long time, yes thanks for all your patience over the years
14:29:34 <Cale> hackrilege: No problem :D
14:29:54 <lyxia> ($>) = flip ($) ... that's kinda confusing given that Data.Functor.($>) exists.
14:30:25 <Cale> Yeah, that's the other really confusing part, I thought it *was* Data.Functor.($>)
14:30:41 <monochrom> yeah, you should use the euro symbol for your own flip ($) :)
14:30:56 <hackrilege> im going to enumerate all programs by decomposing them into prime components but i have to write a haskell interpreter and writer first...
14:31:12 <monochrom> Have a euro symbol. copy and paste: €
14:31:12 <dmwit> ?hackage language-haskell
14:31:12 <lambdabot> http://hackage.haskell.org/package/language-haskell
14:31:27 <Welkin> dwnot found
14:31:32 <Welkin> dmwit: not found
14:31:41 <Cale> @hackage haskell-src-exts
14:31:41 <lambdabot> http://hackage.haskell.org/package/haskell-src-exts
14:31:47 <dmwit> that one
14:31:56 <Welkin> @hackage sdgsdfgsdg
14:31:56 <lambdabot> http://hackage.haskell.org/package/sdgsdfgsdg
14:31:58 <Welkin> lol
14:32:00 <Welkin> what a hack
14:32:01 <dmwit> There's also the GHC API, of course, if you're into that kind of thing.
14:32:04 <hackrilege> wow nice
14:32:10 <monochrom> yes, @hackage is the identity function
14:32:27 <monochrom> the beauty of it is that it is an isomorphism
14:32:35 <dmwit> Well, ("http://.../"++), anyway.
14:32:36 <Cale> @hackage http://hackage.haskell.org/package/
14:32:36 <lambdabot> http://hackage.haskell.org/package/http://hackage.haskell.org/package/
14:32:55 <monochrom> oh, it is also a total function
14:33:01 <amir107> guys check out my friend video its about windows 10 it help you using it and fixing problems you never knew about https://www.youtube.com/watch?v=X1nRXSxdnTo&feature=youtu.be
14:33:01 <hackrilege> can i compile this to c!
14:33:02 <hackrilege> ?
14:33:04 <amir107> guys check out my friend video its about windows 10 it help you using it and fixing problems you never knew about https://www.youtube.com/watch?v=X1nRXSxdnTo&feature=youtu.be
14:33:17 <Welkin> lol what
14:33:37 <Cale> hackrilege: I don't think any Haskell -> C compiler exists at present.
14:33:46 <Welkin> Cale: embedded haskell
14:33:52 <Welkin> and inline-c
14:34:05 <Welkin> sort of
14:34:07 <hackrilege> c++ or jave even would do
14:34:10 <hackrilege> java
14:34:19 <Cale> It used to be the case that GHC compiled via C, but the C it produced wouldn't work as-is. A perl script in GHC had to mangle the output of GCC after to fix things up.
14:34:19 <monochrom> I have a cunning plan. Use ghcjs. Then find a javascript -> C compiler.
14:34:34 <hackrilege> or just target java
14:34:38 <Welkin> hackrilege: ew
14:34:49 <netheranthem> I think there has to be a compiler for the JVM
14:34:57 <hackrilege> there isnt
14:34:57 <netheranthem> Don't remember the name though
14:34:58 <Welkin> frege
14:34:59 <netheranthem> Oh?
14:35:05 <hackrilege> not for android anyway
14:35:32 <netheranthem> Yeah, sounds like frege is it
14:35:49 <lambdamu> there is Summer of Haskell project targeting the JVM
14:35:57 <lambdamu> GHCVM
14:36:29 <monochrom> There was once upon a time people thought that FFI to JVM would be done soon. You can see the relic of this in the FFI spec, it has designated the reserved word "jvm".
14:37:39 <Wizek> monochrom, I wouldn't mind giving `dynF $> fromDynamic $> fromJust` a type signature, but it can be any arity of `Dynamic -> Dynamic -> ...` function. Which applyMany is already equipped to handle, but not sure what concrete type I could give to that intermediate expression
14:38:06 <hackrilege> i cant get ghci on android
14:38:18 <monochrom> applyMany also wants you to tell it which instance you want to use.
14:38:26 <Welkin> what's with people wanting to do all kinds of weird things with the type system lately using things like Dynamic? o.o
14:38:46 <Wizek> Welkin, we've gone mad.
14:39:03 <monochrom> It is equipped to do anything you want. Sure. So what do you want?
14:39:52 <Wizek> monochrom, Fair enough. let me get another way I was trying to deal with that:
14:40:34 <Welkin> wtf!?
14:40:44 <Welkin> I searched for "hackage dynamic"
14:40:56 <Welkin> and got one result titled ""Hackage binary generic viagra
14:41:00 <Welkin> and accidentally clicked on it
14:41:32 <Welkin> weird spam viagra site stuffed with programming keywords O.o
14:41:43 <lambdamu> using yahoo?
14:41:46 <Welkin> no
14:42:21 <Wizek_> monochrom, `map ($ (toDyn ((2,3) :: (Int, Int), (*) :: Int -> Int->Int))) [((fromDynamic :: Dynamic -> Maybe ((Int, int), Int -> Int -> Int)) .> fmap (\((a,b), f) -> f a b)), (fromDynamic .> fmap (\((a), f)-> f a ))] :: [Maybe Int]`
14:42:34 <Symbiont> does anyone know of a good place to learn about using guards in haskell? I'm trying to come up with a solution for an algorithm caled towers of hanoi that will return a list of tuples 
14:43:07 <Wizek> monochrom, Trying to cast the dynamic into multiple types at once
14:43:39 <Welkin> > let f a | a > 5 = True | otherwise = False in f 2 -- Symbiont 
14:43:39 <Wizek> But this also fails with a type error
14:43:41 <lambdabot>  False
14:43:48 <Welkin> those guards?
14:43:51 <monochrom> At most one type, the original type, will give you a Just. All other types give you Nothing.
14:44:12 <Symbiont> yes. I don't understand how to use them.
14:44:41 <Wizek> monochrom, Yes, I would hope for that to happen, but I get this type error instead: 
14:44:41 <Symbiont> \n
14:44:57 <lambdamu> Symbiont: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-guards
14:45:00 <Symbiont> I'm currently using them as follows hanoi n a b c
14:45:02 <Symbiont>   | n <= 0 = []
14:45:04 <Symbiont>   | n == 1 = return (a,c)
14:45:06 <Symbiont>   | n >= 2 = return (a,c)
14:45:18 <Wizek_> monochrom, https://gist.github.com/Wizek/335d1652f5b0c4d99fa933085b2690ad
14:45:19 <Symbiont> thank you :)
14:45:34 <Welkin> it's not pattern guards though
14:45:36 <Welkin> that is an extension
14:45:49 <monochrom> No instance for Typeable Int? You probably haven't imported something.
14:45:54 <lambdamu> uh you're right sorry
14:46:12 <Welkin> it's for using pattern matching inside of guards
14:46:33 <Welkin> Symbiont: looks like you are using them right
14:46:42 <Welkin> but you could replace the last one with `otherwise`
14:46:57 <Welkin> also, why are you returning?
14:47:05 <Welkin> that is only for monads
14:47:05 <Wizek_> monochrom, Yeah, that does sound weird. Same after explicitly importing Data.Typeable
14:47:09 <Wizek_> > > map ($ (toDyn ((2,3) :: (Int, Int), (*) :: Int -> Int->Int))) [((fromDynamic :: Dynamic -> Maybe ((Int, int), Int -> Int -> Int)) .> fmap (\((a,b), f) -> f a b)), (fromDynamic .> fmap (\((a), f)-> f a ))] :: [Maybe Int]
14:47:10 <lambdabot>  <hint>:1:1: parse error on input ‘>’
14:47:18 <Wizek_> > map ($ (toDyn ((2,3) :: (Int, Int), (*) :: Int -> Int->Int))) [((fromDynamic :: Dynamic -> Maybe ((Int, int), Int -> Int -> Int)) .> fmap (\((a,b), f) -> f a b)), (fromDynamic .> fmap (\((a), f)-> f a ))] :: [Maybe Int]
14:47:19 <lambdabot>      No instance for (Typeable int) arising from a use of ‘fromDynamic’
14:47:19 <lambdabot>      In the first argument of ‘(.>)’, namely
14:47:19 <lambdabot>        ‘(fromDynamic :: Dynamic -> Maybe ((Int, int), Int -> Int -> Int))’
14:47:28 <Symbiont> Im completely new to haskell, I started yesterday ish, coming from javascript.
14:47:39 <Welkin> @where learnhaskell -- Symbiont 
14:47:39 <lambdabot> https://github.com/bitemyapp/learnhaskell
14:47:42 <Wizek_> Symbiont, hello from JS! :)
14:48:14 <Cale> Symbiont: Doing the homework for CIS194? :)
14:48:21 <Symbiont> Yes.
14:48:26 <Welkin> I hate towers of hanoi
14:48:39 <Welkin> the most annoying programming exercise
14:48:56 <monochrom> The exercise is poorly phrased.
14:49:13 <Symbiont> I've implemented a solution in javascript. Im just having problems structuring the logic in haskell
14:49:46 <monochrom> First problem: You think they ask you to invent your own algorithm. But no, it already tells you the algorithm, you just have to translate English to code.
14:50:12 <Welkin> yeah, I always find it confusing
14:50:26 <Welkin> there are far better exercises to teach recursion
14:50:58 <Welkin> like a simple fibonacci generator
14:51:39 <hackrilege> or (*) ala wadler
14:51:49 <monochrom> Second problem: Due to functional enthusiasism, it fails to distinguish between "perform actions to move the discs" and "just output, in the format of a list of strings, what actions you would perform". (It really justs wants the latter.)
14:51:49 <Welkin> *?
14:52:09 <Wizek> monochrom, Any ideas what I could import if it wasn't the Data.Typeable module missing?
14:52:16 <hackrilege> (recursivly in terms of (+))
14:52:27 <Symbiont> *nods @ monochrom*
14:52:46 <Welkin> oh yeah
14:52:52 <Welkin> church numerals!
14:53:03 * hackagebot labels 0.1.0 - Declare and access tuple fields with labels  https://hackage.haskell.org/package/labels-0.1.0 (ChrisDone)
14:53:09 <Welkin> implement add and multiply using church numerals
14:53:10 <Welkin> that is fun
14:53:27 <hackrilege> what is this churchnumerals?
14:53:39 <monochrom> Wizek: what is the definition of .> again?
14:53:52 <hackrilege> is it like peano/
14:53:54 <hackrilege> ?
14:53:54 <Welkin> peano
14:53:55 <Wizek> monochrom, flip (.)
14:53:55 <Welkin> yeah
14:54:07 <johnw> hackrilege: it's the final encoding of Peano
14:54:13 <hackrilege> cool, whats peano!?
14:54:21 <johnw> O | forall n, S n
14:54:32 <johnw> err, n -> S n
14:54:50 <hackrilege> okok ill google it brb
14:54:51 <monochrom> Wizek: Oh I see now. int vs Int. that's all.
14:55:42 <Wizek_> dangit!
14:55:50 <hackrilege> ooooh you can use them to tie the knott, this could be useful for indexing Free structures woot woot
14:55:51 <Wizek_> monochrom, good catch
14:56:35 <hackrilege> id love an integer paramatriasable function that could handel different levels of recursive nesting of lists for converting back and forth from free
14:56:43 <Welkin> handel
14:56:45 <Welkin> lol
14:56:47 <Welkin> water music?
14:57:04 <hackrilege> can i use Ints as types using this church peano stuff?
14:57:38 <hackrilege> eg toFree 3 :: [[[a]]] -> Free [] a
14:58:03 * hackagebot list-t 1 - ListT done right  https://hackage.haskell.org/package/list-t-1 (NikitaVolkov)
14:59:07 <monochrom> OK, there will be another error after you fix spelling, but it is again the kind where you have to say which instance you want.
14:59:37 <Wizek_> monochrom, Yes, already on it
14:59:44 <Wizek_> > map ($ (toDyn ((2,3) :: (Int, Int), (*) :: Int -> Int->Int))) [((fromDynamic :: Dynamic -> Maybe ((Int, Int), Int -> Int -> Int)) .> fmap (\((a,b), f) -> f a b)), ((fromDynamic :: Dynamic -> Maybe (Int, Int -> Int)) .> fmap (\((a), f)-> f a ))] :: [Maybe Int]
14:59:45 <lambdabot>      Couldn't match type ‘((Int, Int), Int -> Int -> Int)’ with ‘Int’
14:59:45 <lambdabot>      Expected type: Dynamic -> Maybe Int
14:59:45 <lambdabot>        Actual type: Dynamic -> Maybe ((Int, Int), Int -> Int -> Int)
15:00:35 <Wizek_> that's weird, it actually works on my machine: 
15:00:44 <monochrom> me too
15:01:10 <monochrom> oh, it's because lambdabot has a different .>
15:01:26 <monochrom> @type (.>)
15:01:27 <lambdabot> (st -> r) -> (kab -> st) -> kab -> r
15:01:41 <Wizek_> > let (.>) = flip (.) in map ($ (toDyn ((2,3) :: (Int, Int), (*) :: Int -> Int->Int))) [((fromDynamic :: Dynamic -> Maybe ((Int, Int), Int -> Int -> Int)) .> fmap (\((a,b), f) -> f a b)), ((fromDynamic :: Dynamic -> Maybe (Int, Int -> Int)) .> fmap (\((a), f)-> f a ))] :: [Maybe Int]
15:01:42 <lambdabot>  [Just 6,Nothing]
15:01:46 <Wizek_> Look at that!
15:01:51 <monochrom> that is fantastic. but I don't actually like kabobs too much.
15:02:05 <palat> what does this compute
15:02:13 <Welkin> wtf is that horrendous mess you just wrote?
15:02:14 <palat> or for what purpose
15:02:34 <Wizek_> haha, I assure you Gentlemen, that there is a method to this madness.
15:02:40 <palat> but what is it
15:02:41 <palat> for
15:02:43 <monochrom> if you have a recipe from stew to r, and you have a recipe from kabob to stew, then .> can turn kabob to r
15:03:11 <hackrilege> oh no i started this didnt i, i see a flip (.)
15:03:15 <heisenbug> Anybody doing frequent profiler runs here? What is the typical slowdown factor when running a program compiled with „-prof“ ?
15:03:17 <mniip> 1470952287 [00:51:27] <monochrom> Second problem: Due to functional enthusiasism, it fails to distinguish between "perform actions to move the discs" and "just output, in the format of a list of strings, what actions you would perform". (It really justs wants the latter.)
15:03:24 <monochrom> wait, that's the same .>
15:03:25 <Wizek_> "I've been trying to make dependency injection work in haskell to ease testing and allow for powerful mocking capabilitie"
15:03:25 <mniip> it's all the same in a writer monad though innit :p
15:03:36 <Wizek_> +s
15:04:44 <Wizek_> heisenbug, I've observed a slowdown to around 50% in terms of time.
15:05:16 <Wizek_> (based on around 5-20 profiler runs)
15:05:29 <hackrilege> what is the Dynamic package for?
15:05:34 <heisenbug> I seem to get x3 time
15:05:40 <monochrom> Beware of enthusiastic teachers, they tend to give you information overload and/or assume that advanced facts are obvious.
15:06:11 <hackrilege> or just be an enthusiastic student
15:06:54 <hackrilege> i thought i was moving the lesson towards the state monad, but if its more relavent to this Dynamic stuff then maybe thats where i need to be looking
15:07:10 <Wizek_> monochrom, Btw, what did you mean by kabob?
15:07:54 <monochrom> a food
15:08:05 <Wizek_> monochrom, relevant here, how?
15:08:15 <Wizek_> palat, Welkin are you satisfied by my answer of trying to make a dependency injection work in haskell?
15:08:27 <palat> yeah, i get it now
15:08:32 <Wizek_> cool
15:08:36 <monochrom> just because I saw the type variable "kab".
15:08:45 <palat> mniip: What uni are you from
15:08:46 <hackrilege> whats dependency injection?
15:09:07 <mniip> huh?
15:09:07 <monochrom> "(st -> r) -> (kab -> st) ..."  kab must be kabob, st must be stew.
15:09:12 <palat> university
15:09:21 <Welkin> haha
15:09:28 <mniip> that's a surprisingly random question to ask
15:09:29 <Welkin> of course, Dynamic uses unsafeCoerce
15:09:34 <Welkin> is this a new fad?
15:09:38 <hrumph> Wizek, does dependencey injection make any sense in haskell?
15:09:46 <mniip> Welkin, well it could use GADTs
15:10:02 <Wizek_> hrumph, I'll make it make sense.
15:10:04 <palat> Not if someone brought up enthusiastic teachers 
15:10:27 <hackrilege> its a troll?
15:10:28 <hrumph> Wizek, can you give a context in which it would be of benefit?
15:10:35 <Wizek_> hrumph, On a more serious note: Yes, I hope that it will be a powerful addition in my haskell toolbelt
15:10:46 <puregreen> hackrilege: who?
15:11:06 <mniip> palat, am I missing some context there
15:11:07 <hackrilege> the user asking for pid
15:11:30 <Wizek_> hrumph, hmm, sec, trying to look for an example
15:12:06 <Welkin> I thought dependency injection is just passing a function
15:12:10 <hackrilege> is this one? Wizek_ http://lpaste.net/176006
15:12:48 <monochrom> some people may prefer dependent injection :)
15:13:35 <Welkin> http://mikehadlow.blogspot.com/2010/03/functional-dependency-injection.html
15:13:36 <Welkin> lol
15:14:12 <athan> ditto Welkin
15:14:40 <Welkin> lol
15:14:46 <Welkin> Tony Morris commented on that blog post
15:15:50 <athan> Welkin: https://twitter.com/mattoflambda/status/752628247960100865
15:16:08 <dibblego> dependency injection exists in haskell as instance Monad (RWST f r w s)
15:16:18 <Wizek_> Yes, currying is close to what DI can do on a very basic level, but it falls apart when we want to use it for any non-trivial DI mocking scenario
15:16:33 <Wizek_> I do have an article on that phenomena: https://byorgey.wordpress.com/2010/04/03/haskell-anti-pattern-incremental-ad-hoc-parameter-abstraction/
15:16:42 <dibblego> https://www.youtube.com/watch?v=ZasXwtTRkio
15:19:29 <hackrilege> lol " I can now succesfully control the furblization"
15:20:12 <monochrom> dibblego: I look at the conclusion slide, it has "little languages" and "multiple interpreters of the same language". this sounds like free monad. (and the middle of the talk seems to show an example free monad.)
15:20:57 <Wizek_> hrumph, Quick googleing gave me this articlie: https://www.sitepoint.com/mocking-dependencies-angularjs-tests/ I haven't read the english text, but the code examples seem to illustrate what mocking through DI can do
15:21:01 <dibblego> monochrom: yeah it goes reader then free; Runar and I did another talk where it was RWST.
15:21:11 <monochrom> ok neat
15:21:35 <dibblego> I actually don't know what dependency injection is (I contend, nobody does) :)
15:22:35 <Wizek_> hrumph, Trying to summarize: it makes it really easy to swap any function in your injector to a mock implementation during testing, and re-assembles your whole hierarchy of functions dependent on each other with that one change included
15:22:45 <bshelden> That just leads to asking what definition of "know" you're going with.
15:23:06 <monochrom> All I know about dependency injection I learned from that famous Stackoverflow answer that says "forget it, just use higher-order functions", as in, take an extra parameter of type say "Int -> IO ()" and use it.
15:23:26 <hackrilege> how can i think of (!!) in terms of the State monad??
15:23:28 <Wizek_> monochrom, I morbidly beg to differ.
15:23:31 <bshelden> That remains the way I solve those use cases.
15:23:41 <dibblego> "a pretentious way of passing arguments to functions" 
15:23:47 <bshelden> "DI" is irrelevant.  Focus on the use case.  What tools exist to solve it.
15:24:20 <Welkin> bshelden: you know it biblically?
15:24:41 <bshelden> Non sequitor
15:25:47 <lingxiao> hey all i havea  byte string conversion problem
15:25:59 <lingxiao> I am trying to read a .gz file and unzip it, using lib: Codec.Compression.GZip (decompress)
15:26:12 <lingxiao> this outputs an IO Bytestring
15:26:15 <lingxiao> but it's lazy
15:26:20 <nak> question !
15:26:30 <lingxiao> which means now I cant concat the bytestrings using this library: https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString-Char8.html
15:26:46 <nak> is there anything that combines to partially applied functions, like f= (5+) and g = (+5) => 10 ?
15:26:55 <monochrom> but you can use Data.ByteString.Lazy.Char8's concat.
15:27:01 <nak> two* partially applied functions
15:27:27 <monochrom> nak, consider "f . g" and "g . f".
15:28:03 <dmwit> nak: What should this hypothetical tool do with `(5+)` and `(*5)`?
15:28:04 * hackagebot microlens 0.4.7.0 - A tiny lens library with no dependencies. If you're writing an app, you probably want microlens-platform, not this.  https://hackage.haskell.org/package/microlens-0.4.7.0 (Artyom)
15:28:05 <Wizek_> > let f= (5+) and g = (+5) in f . g $ 0
15:28:06 * hackagebot microlens-th 0.4.0.1 - Automatic generation of record lenses for microlens  https://hackage.haskell.org/package/microlens-th-0.4.0.1 (Artyom)
15:28:07 <lambdabot>  <hint>:1:19: parse error on input ‘=’
15:28:09 * hackagebot microlens-ghc 0.4.7.0 - microlens + array, bytestring, containers, transformers  https://hackage.haskell.org/package/microlens-ghc-0.4.7.0 (Artyom)
15:28:10 <Welkin> :t (.) -- nak 
15:28:11 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:28:17 <Wizek_> > let f= (5+); g = (+5) in f . g $ 0 -- nak
15:28:18 <lambdabot>  10
15:28:45 <nak> Wizek_ but you're threading a third value, 0, in there
15:28:59 <dmwit> Why is everybody suggesting `(.)`? It appears unrelated to nak's question to me.
15:29:06 <puregreen> @tell yyyyy microlens-0.4.7's haddocks should build normally with GHC 8
15:29:06 <lambdabot> Consider it noted.
15:29:08 <nak> dmwit the expectation is that the two functinos would be partial applications of the same function (+, in this case)
15:29:27 <nak> (.) is composition. i know it's not what i'm looking for
15:29:27 <dmwit> nak: I propose that, therefore, you supply the function and the two arguments separately.
15:29:34 <nak> hehe ok
15:29:43 <nak> it was just an idea i had that came to mind
15:29:58 <lingxiao> thans monochrom
15:31:11 <monochrom> dmwit, it can get them to actually explain, like I am not telepathic, the specification.
15:31:31 <Wizek_> Well, anyways, thanks monochrom with helping me nudge the `Dynamic -> Maybe _` issue forward, maybe tomorrow will be the day I finally will have a POC working DI in haskell.
15:31:55 <dmwit> monochrom: Proposing a known wrong answer seems like an awfully roundabout way to achieve that goal.
15:32:08 <Welkin> I'm still not clear on the benefit of what you are doing Wizek_ beyond just passing in a function
15:33:05 * hackagebot microlens-platform 0.3.6.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.3.6.0 (Artyom)
15:33:13 <monochrom> dmwit, programmers tend to be poor explainers (a self-selection thing). All direct enquiries tend to fail.
15:33:26 <Wizek_> Welkin, maybe I can construct a somewhat contrived example that illustrates what I am trying to do:
15:34:29 <ertes> isn't "dependency injection" just "function"?
15:34:47 <Welkin> lol ertes 
15:35:01 <Welkin> that's what everyone has been saying and what I thought too
15:36:45 <ertes> it takes a while to get rid of that OO habit of giving the most basic things enterprisy names and wrapping them in layers of abstraction nobody asked for…  most of the time OO seems to be busy solving problems nobody has
15:37:24 <ertes> i know…  it used to be a guilty pleasure of mine, but i gave it up quickly enough =)
15:37:33 <netheranthem> I blame haskell for the bad grade I got in a Java patterns exam.
15:37:39 <netheranthem> No regrets!
15:37:48 <Welkin> netheranthem: java patterns exam...? wtf kind of school do you go to?
15:37:58 <Welkin> better that you flunk out than continue there
15:38:08 <puregreen> yay, outgroup bashing! fun!
15:38:18 <netheranthem> It's supposed to be a "Software Engineering" course, but it was essentially java patterns
15:38:50 <netheranthem> I am a few weeks away from graduating, and the other half of courses are actually good, it's just that there is no pressure to remove outdated material.
15:39:26 <Wizek_> ertes, no, it's not according to how I use it. Constructing an example now.
15:41:27 <hexagoxel> puregreen: welcome to the reflecting-about-grouping-group. we see through the pointlessness of bashing an outgroup.
15:44:49 <puregreen> hexagoxel: well, actually the worst thing is that I'm doing the same outgroup-bashing except that my outgroup is people who bash my fargroup (OOP programmers) – and so I'm not better :( eh, whatever, and that's all offtopic anyway
15:46:55 <lingxiao> hey all
15:47:05 <lingxiao> hey all
15:47:13 <lingxiao> so I have this function  readFile :: FilePath -> IO ByteString
15:47:14 <Welkin> 大家好
15:47:23 <lingxiao> that throws exception if file is not found
15:47:44 <dmj> lingxiao: yes, go on
15:47:45 <lingxiao> I want to turn this into a  readFileM  :: FilePath -> IO (Maybe ByteString)
15:47:55 <lingxiao> what's the kosher way to catch expceptions here?
15:47:59 <Wizek_> Welkin, ertes: https://gist.github.com/Wizek/e3fb2d540b48d198299dea8f8bc7b48e
15:48:24 * Welkin throws a dart at dmj
15:48:39 <Wizek_> pseudo code, since not sure what syntax will enable this in haskell yet.
15:48:40 <hexagoxel> puregreen: my statement was just making fun of my statement. but yeah, off topic :)
15:48:45 * dmj dodges
15:48:45 <ertes> Wizek_: do you mean reactivity?
15:48:54 <Welkin> @dice 1d20
15:48:54 <lambdabot> Welkin: 16
15:48:57 <Welkin> damn
15:49:13 <dmj> lingxiao: seems like a synchronous exception, did you try 'try'
15:49:14 <ertes> Wizek_: values that update when others update, and that can react to events?
15:49:38 <lingxiao> dmj from control.excption ?
15:50:10 <puregreen> Wizek_: this is usually done with typeclasses, but you have to explicitly choose which methods to make replaceable
15:50:38 <Wizek_> puregreen, I'd ideally like to have all of them potentially replacable
15:50:43 <dmj> :t tryJust
15:50:44 <lambdabot> Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
15:50:48 <dmj> @lingxiao: ^
15:50:48 <lambdabot> Unknown command, try @list
15:50:58 <ertes> Wizek_: should i look at the regular code or the tests?
15:51:10 <Wizek_> ertes, hmm, I am not sure if FRP is of help here. Maybe.
15:51:41 <ertes> Wizek_: it may be more helpful to explain the problem rather than the solution you used in another language
15:51:43 <dmj> tryJust (\(e :: SomeException) -> pure Nothing) (Just <$> readFile "foo.txt")
15:52:05 <lingxiao> dmj that is from control.Exception right?
15:52:15 <Welkin> I have seen some atrociously ugly haskell that was a direct translation from c++
15:52:29 <Welkin> direct translations don't go well
15:53:01 <lingxiao> :t tryJust
15:53:03 <lambdabot> Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
15:53:04 <lingxiao> :i tryJust
15:53:12 <monochrom> wait a second, (\(e :: SomeException) -> pure Nothing) says that you want to intercept no exception whatsoever
15:53:15 <lingxiao> :info tryJust
15:54:25 <lingxiao> dmj ?
15:54:41 <monochrom> anyway, read my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
15:54:47 <lingxiao> oh nvm control.expcetion.base
15:54:54 <lingxiao> didnt know you can hoogle function signatures too
15:54:56 <puregreen> Wizek_: I'm not familiar with DI, so I'm curious: how do you specify where to stop when applying DI? For instance, if you mock (++) in some code, and that code uses (++) not only on the outer level, but also deep under the hood in some library function it calls
15:56:14 <Wizek_> puregreen, That's a good question! In the context where I've used DI previously, it only applied to the current project, and never any imported libraries.
15:56:39 <Wizek_> puregreen, since those libraries were supposed to thest their own code, and that is not the responsibilirty of the current project
15:58:07 <puregreen> okay, so the language itself makes it impossible for method replacement to cross module boundaries (or something like that)?
15:58:46 <Wizek_> puregreen, It was more the design/conventions of the DI framework rather than the language, but yes
15:59:49 <Wizek_> Also, even if I re-defined such a low-level building block, the mock is applied in a very narrow-scope, only to test a function, and all the other tests would still run against the vanilla (++)
16:00:13 <Wizek_> That's a powerful feature I miss, such a surgical locality.
16:01:53 <monochrom> Wizek_, check out the old idea of "functorial programming" from the SML people.
16:02:24 <monochrom> (Their "functor" means parameterized modules.)
16:06:02 <Wizek_> ertes, I am thinking about a response to you, but it may not be simple: I found the 'solution' of DI to be applicable to many smaller and some larger 'problems'. Maybe I can enumerate them, but really, If only I could replicate how I remember it working I hope that it will be similarly useful in haskell too.
16:06:52 <Wizek_> monochrom, Maybe I'll look into it, however, I am more looking for a practical method that works in current haskell
16:07:33 <monochrom> I mentioned it in the context of "can you do global overriding?"
16:07:48 <Wizek_> monochrom, I see
16:08:02 <mniip> 1470953382 [01:09:42] <palat> Not if someone brought up enthusiastic teachers 
16:08:05 <mniip> what are you referring to there
16:09:36 <ertes> Wizek_: you really shouldn't translate solutions like that…  it probably gets you stuck more than it helps
16:09:47 <ertes> Wizek_: try in the context of a practical problem
16:09:56 <ertes> a *specific* practical problem
16:09:59 <monochrom> mniip, would it be simply that palat wanted to ask me, not you, which university I came from? because I mentioned enthusiastic teachers, and now combine that with an erroneous nick-completion.
16:10:27 <ertes> Wizek_: background: problems that look very similar in OO may look almost nothing alike in FP, especially haskell
16:10:30 <mniip> ah
16:10:53 <mniip> that explains many things
16:11:08 <hackrilege> http://lpaste.net/176039
16:11:30 <puregreen> Wizek_: to answer your question directly: I've never seen this done in Haskell (with the exception of using reflection to mock methods of classes, but that approach is pretty limited). I agree that it'd be a cool thing to have, but it'd be also pretty hard to get right and it might destroy many properties of the language that other people like (even local instances are controversial, and local instances are a much more limited version of this)
16:14:57 <Wizek> puregreen, Right. Although my fingers are still a bit crossed with the Data.Dynamic POC that I've started to put together (see above when I started to talk about this question with monochrom initially). I hope above all else that I can do this as a library without interfering with anything that anyone else might like about the language.
16:16:24 <hackrilege> thanks for helping me write this nice and neatly. ok so this code runs into an error as follows, repeatedly operating on the accessor (e.g. repeatedly shuffling a list) will become slower and slower the more operations are supplied. how do i save my work as it were and partially apply the shuffles...
16:16:37 <ertes> Wizek_: i just saw that i should read the *tests* rather than the regular code
16:16:49 <ertes> Wizek_: and i still think you should just use functions
16:17:09 <Wizek> ertes, some specific, real world usages can be seen here: https://github.com/Wizek/loadr/blob/master/spec/main.spec.js 8 usages of the `mod()` function, that is responsible for replacing a dependency in a specific context.
16:17:43 <ertes> Wizek_: example: f (+) x y = x + y
16:18:03 <ertes> (though i'd choose a different name for the argument, just to avoid confusion)
16:18:54 <puregreen> ertes: passing all those functions when you want to mock something is going to get pretty annoying
16:18:56 <Wizek> ertes, yes, that's nice when the depth of the dependency graph (tree?) is limited, and the number of dependencies is small, but it falls apart if either of those starts to increase
16:19:11 <Wizek> exactly what puregreen says!
16:19:53 <orion> When I try to bootstrap cabal I get this error: gcc: error: unrecognized command line option '-nopie'; did you mean '-no-pie'? -- anyone know what could be going wrong?
16:20:09 <ertes> is this really a problem that pops up *in haskell*?
16:20:18 <orion> It happens when Setup.hs for mtl is linked.
16:21:02 <ertes> Wizek: in any case, if i'd really face that problem, i'd most likely use reflection -- pass arguments through *types* rather than values
16:21:26 <ertes> then the usual type class machinery kicks in and passes arguments implicitly for you, as long as the type system can infer them
16:21:41 <ertes> the injection points are then applications of 'reify'
16:22:16 <ertes> Wizek: the original term for this approach is "implicit configurations", but we tend to just call it reflection nowadays
16:22:40 <ertes> and there is a ready-made package for it, too
16:22:42 <ertes> @package reflection
16:22:43 <lambdabot> http://hackage.haskell.org/package/reflection
16:24:11 <Wizek> looking into it
16:26:34 <ertes> Wizek: you will have to abstract over the replacable part anyway, even with this approach, except that in this case you will need a *type* variable rather than a function argument variable, and to refer to the implicit argument, you refer to a *type*
16:27:56 <ertes> it can make sense, if the information you pass is inherently type-bound, but if it isn't, it will feel more like just an awkward way to pass arguments to functions
16:29:06 <hackrilege> omg this reify stuff is totaly opaque
16:29:49 <ertes> i highly suggest that you try to use regular functions before trying anything else, if only to get a *real* feeling for how complicated it becomes
16:29:55 <hackrilege> > reify 6 (\p -> reflect p + reflect p)
16:29:57 <lambdabot>  Not in scope: ‘reify’Not in scope: ‘reflect’Not in scope: ‘reflect’
16:30:23 <nshepperd> imo needing to mock anything is a code smell
16:31:17 <ertes> Wizek: most likely it will not become as complicated as you think, because haskell gives you complete control over the granularity of abstraction…  you may only be typing an extra word per top-level definition, which is really cheap
16:31:35 <ertes> nshepperd: you could consider 'sortBy' mocking
16:31:38 <hackrilege> how is this related to State?
16:32:01 <ertes> hackrilege: it isn't, as far as i see
16:32:15 <nshepperd> for testing, I mean
16:32:22 <hackrilege> how can it be then
16:32:48 <nshepperd> but I would consider sortBy to be just a normal function
16:33:26 <ertes> i think "mocking" and "abstraction" are the same thing in different contexts
16:33:33 <hackrilege> etres: is it at all related to this paste? http://lpaste.net/176039
16:35:22 <ertes> hackrilege: good question
16:35:25 <ertes> and good night =)
16:35:36 <hackrilege> :-(
16:35:43 <hackrilege> ciao
16:36:49 <hackrilege> (yes?no?...)
16:47:15 <Welkin> lol occam's blazer?
16:50:45 <c_wraith> it's probably very stylish. 
16:57:28 <nshepperd> but no more stylish than necessary
16:58:07 <monochrom> haha
17:06:55 <immersion> Using any parsing library (parsec, attoparsec, megaparsec, justparse, etc.), is there a way to get the list of tokens that were expected next at the end of the input, regardless of whether or not the input was successfully parsed?
17:08:41 <puregreen> immersion: I think with megaparsec you should be able to throw an error, recover from it, keep parsing, and then at the end analyse the error and take the list of tokens
17:08:59 <immersion> For example, if I'm parsing strings of balanced parentheses, I'd like to know that either `(` or `)` are expected at the end of the input `(()`, but only `(` is expected at the end of `()`
17:10:24 <puregreen> if you only need it at the end of the input, then it's even simpler
17:10:46 <puregreen> just do “p *> fail ""” or something and look at the parse error
17:11:04 <puregreen> a sec
17:11:13 <immersion> puregreen: Ooh I think that just might work. So you're saying to not include EOF in the parser (which causes a parse failure at the end of a string), recover by parsing EOF, then extract the list of tokens at the end?
17:11:35 <immersion> Gotcha, that sounds promising. I'll give it a shot - thanks!
17:12:03 <puregreen> you don't even have to recover by parsing EOF
17:12:17 <puregreen> you have to fail at the end of the parse unconditionally
17:12:30 <puregreen> maybe by doing “fail” or “notFollowedBy eof”
17:12:38 <puregreen> I don't know which of these will work
17:24:19 <immersion> `fail "foo"` just spits out "foo", whereas `notFollowedBy eof` says what was expected next
17:36:13 <larp> plutoniix: /!\ #haskell has moved to iam.reallyemo.net #fartlek /!\
17:37:05 --- mode: ChanServ set +o monochrom
17:37:23 --- mode: monochrom set +b *!*@cpe-74-134-218-138.kya.res.rr.com
17:37:23 --- kick: larp was kicked by monochrom (larp)
17:37:28 --- mode: monochrom set -o monochrom
17:37:47 <Welkin> who is larp? o.o
17:37:55 <Welkin> oh
17:38:06 <wespiser> scam?
17:39:01 <wespiser> has anyone used Snap for web dev? I'm looking for a platform suitable for a start-up project in Haskell
17:39:41 <Welkin> wespiser: I used yesod, or servant + elm/reflex-dom on the frontend
17:40:02 <Welkin> some people use snap still
17:41:13 <wespiser> thanks! I'm coming from the backend and want to get involved in the full stack
17:41:48 <Symbiont> I've been looking at the haskell documentation on stack overflow. It's pretty nice.
17:44:54 <lingxiao> any of you have ever encountered this problem?
17:44:58 <lingxiao> "*** Exception: Codec.Compression.Zlib: incorrect header check
17:45:12 <lingxiao> using the decommpress function from import Codec.Compression.GZip     (decompress)
17:48:13 <monochrom> perhaps the input data is not gz?
17:49:17 <lingxiao> ahh let's see
18:00:05 <zort> I'm trying to use Binary with Generics to deserialize a large record type, but the problem is the Binary instance for Int32 is big-endian whereas I need little-endian. I don't suppose there's any way to override that?
18:01:04 <zort> http://stackoverflow.com/questions/8121430/what-is-a-better-way-to-decode-encode-binary-little-endian-data-in-haskell ah
18:01:36 <monochrom> You probably have to write a lot of manually written code to control endianness.
18:01:46 <monochrom> One little, two little, three little endians...
18:02:13 <lpsmith> shapr, I heard that you are working on a sip parser.
18:02:20 <lpsmith> we should talk.
18:02:38 <mgsloan> zort: Consider using our "store" package.  It blows Binary out of the water performance-wise, defaults to machine native encoding
18:02:54 <zort> I will consider it!
18:03:14 <zort> consider it considered
18:03:17 <mgsloan> At some point it will likely support architecture independent serialization with explicit endianness: https://github.com/fpco/store/issues/36
18:13:10 * hackagebot invertible 0.1.2 - bidirectional arrows, bijective functions, and invariant functors  https://hackage.haskell.org/package/invertible-0.1.2 (DylanSimon)
18:18:52 <athan> That one looks pretty sweet o_o
18:19:03 <athan> I really need to spend more time diving into hackage ._.
18:20:37 <nshepperd> / inver
18:21:00 * nshepperd >_>
18:23:07 <athan> nshepperd: ?
18:23:57 <nshepperd> i messed up an irc command
18:27:58 <bbielsa> hi O_O
18:28:11 * hackagebot ginsu 0.8.2.2 - Ginsu Gale Client  https://hackage.haskell.org/package/ginsu-0.8.2.2 (DylanSimon)
18:43:24 <kilimanjaro> is it generally understood that the prelude's numeric typeclasses are poorly designed?
18:44:26 <kilimanjaro> e.g. Num requires both arithmetic operations but also order operations (abs, signum), Real requires toRational for no clear reason, etc
18:44:30 <mgsloan> I think it's generally understood to be difficult to design a good set of numeric typeclasses
18:45:14 <kilimanjaro> mgsloan: i don't doubt that
18:46:26 <c_wraith> I think what the Prelude has is just as good as anything else I've seen, in practice. 
18:46:59 <c_wraith> I'd be much more inclined to complain about the Enum instances for Float and Double. 
18:47:13 <mgsloan> Yup, I remember when I first encountered the numeric it was better than anything I'd seen in other languagese
18:48:10 <Cale> kilimanjaro: Real is just poorly named... perhaps. The idea is more along the lines of "not complex", and is an abuse of the fact that actual computable reals and numeric types that can represent things which are irrational are somewhat rare in practice.
18:48:28 <Cale> (but there ought to be *some* class with a toRational method)
18:49:31 <dolio> Yeah, 'Real' means they aren't imaginary.
18:50:14 <dolio> Integers really exist.
18:50:20 <Cale> heh
18:50:23 <dolio> But not complex numbers.
18:50:47 <kilimanjaro> Cale: abs, signum seem out of place too, if you take a Num to simply be something you do arithmetic with
18:51:32 <Cale> kilimanjaro: Yeah, that I agree with. Adjusting Num at this point is fraught with political and code-breaking peril, but ideally those belong as methods of their own subclass
18:52:25 <Cale> In the cases where you can't otherwise define something so great, it's possible to define the signum of all elements to be 1, and abs = id.
18:53:15 <kilimanjaro> fair enough
18:53:33 <mgsloan> Yup, first we need a good way of restructuring typeclasses without breaking code.  Maybe something like https://ghc.haskell.org/trac/ghc/wiki/InstanceTemplates
18:54:28 <mgsloan> second, we need a numeric hierarchy that people actually want to use
18:54:45 <mgsloan> There isn't an alternative one that's become widely used, AFAIK
18:55:15 <mgsloan> Probably because each application / mathematical domain wants something a bit different
18:55:21 <dolio> I don't think any of the type class refactoring proposals really consider moving things out of one type class into another.
18:55:33 <mgsloan> Mine did
18:55:38 <dolio> Unless the plan were just to keep Num as is, and define it as an alias for two other things.
18:55:50 <mgsloan> And it is very similar to Richard's instance templates proposal, even has the same name
18:56:01 <mgsloan> Yeah, that's the plan
18:56:13 <mgsloan> These templates create a constraint synonym!
18:56:52 <divVerent> Haskell has the most elegant fork bomb: fix $ forever . forkProcess. It has the highest density of f-words.
18:56:56 <mgsloan> I'm opinionated, though, I think all the other proposals aren't well thought out, heh
18:57:37 <dolio> I guess keeping Num as a bad collection of stuff is acceptable.
18:57:55 <mgsloan> They either run into issues with duplicate specification of methods or issues with instance uniqueness / orphans (superclass defaults)
18:58:01 <mgsloan> Yuup
18:58:07 <mgsloan> We'll just need a new hierarchy
18:58:21 <kilimanjaro> Cale: what i was playing around with specifically was arithmetic in quadratic field extensions of the rationals
18:58:47 <mgsloan> At some point base 5 is gonna happen.  I really like the look of the memory buffer aspects of the stuff in https://github.com/haskell-foundation/foundation/
18:58:59 <mgsloan> Which aims to be a new base + prelude
18:59:00 <dolio> I haven't really seen a hierarchy that's significantly better than the current one, either. At least if you do minor fixes, like moving abs and signum around.
18:59:00 <kilimanjaro> so the objection to Real here is, as you mentioned, i'm trying to work with irrational numbers
19:27:08 <lingxiao> hey all
19:27:26 <lingxiao> I'm reading a bunch of large .gz files, unzipping them and concacentenating them together
19:27:33 <lingxiao> but I'm getting startup disk is full on my mac
19:27:41 <lingxiao> I guess that means i have a space leak somewher correct?
19:29:11 <geekosaur> if it expanded swap to use up all of disk space, yes
19:34:10 <lingxiao> geekosaur what does it mean expanded swap?
19:34:17 <lingxiao> because I think I did see that meessage
19:35:55 <lingxiao> could I ask you to quickly peruse the code and tell me if you see anything glaringly wrong? 
19:35:56 <lingxiao> http://lpaste.net/176077
19:36:04 <lingxiao> or alternatively... would conduit help here?
19:36:10 <lingxiao> in particular concactenating huge files
19:36:12 <geekosaur> when the system gets low on memory, it moves stuff to swap files on disk. it creates these as needed (they're generally in /private/var/vm)
19:36:44 <joe9> need some advice, please? I have a library which does some stuff. On a state change, the library calls the specified callback function. I am trying to figure out how I can pass  the user state between the callback functions. I am reading up about ExistentialState that xmonad uses. Not sure if that can help in this case.
19:37:16 <geekosaur> joe9, it won't
19:37:36 <lambdamu> lingxiao: Yes if you process large files you should certainly use a streaming library
19:37:46 <lingxiao> ok great thanks
19:37:49 <geekosaur> you can only directly pass static state normally. if you need it to be dynamic, then your static state needs to be an IORef holding the actual state
19:38:31 <lambdamu> lingxiao: the zip-archive and the zip package support streaming out of the box
19:38:45 <geekosaur> lingxiao, yes, it sounds like you have all the file data in your process's memory, so it's using a lot of swap and that is using up your disk space. (try: sysctl vm.swapusage)
19:39:01 <geekosaur> I lost some time checking for swap files on my Mac, but it's got none at the moment >.>
19:39:43 <lambdamu> lingxiao: sorry i meant the zip package and the zip-conduit package
19:39:43 <joe9> geekosaur: ok, Thanks.
19:39:50 <lingxiao> geekosaur i see this: vm.swapusage: total = 1024.00M  used = 33.00M  free = 991.00M  (encrypted)
19:40:01 <lingxiao> can I free up the used swap space
19:40:21 <geekosaur> with used at 33M, probably not
19:40:34 <lingxiao> I think it was freed up w/o my superision?
19:40:34 <nshepperd> I would be surprised if you managed to fill up your HD with swap files before throwing you keyboard out the window in rage
19:40:38 <geekosaur> that will be things that are only used at boot time
19:40:59 <joe9> geekosaur:  Can I parametrise the library state to take a user defined type? data State a = {internalId :: Int, userState :: a} ?
19:41:02 <lingxiao> because at one opint when i did stack ghci   i got some sort of out of memory error
19:41:29 <lingxiao> lambdamu so that zip-conduit package is all i need to work with zip files?
19:41:32 <geekosaur> also note that the 1G file you see there is what's left after it cleaned up the swap files --- this is all handled dynamically
19:41:43 <geekosaur> if you had looked when you were getting the error, it probably would have been a lot more in use
19:42:12 <geekosaur> so any swap files currently remaining (likely only 1 or 2) will stay there until the things in them are needed
19:42:48 <lambdamu> lingxiao: I think yes but i would try zip at first, it looks better
19:42:50 <geekosaur> you might get some of them back by logging out and back in. you *will* get it back by rebooting. but I don't think you need to bother at this point since the program that was using it has exited
19:43:21 <lingxiao> geekosaur ah ok great very fasincating stuff acutally
19:43:33 <lingxiao> never actaully encountered a space leak  in haskell in real life
19:43:44 <geekosaur> and. I'm looking at your code, and I suspect it does force all the file data into memory (foldM is strict))
19:43:47 <lingxiao> lambdamu im also getting this error when tryig to stack build it
19:43:53 <lingxiao> oh boy... foldM
19:43:57 <lingxiao> is there a lazy foldM?
19:44:06 <geekosaur> no, and there probably can't be
19:44:06 <lingxiao> just since it's late and I need sometihing quick
19:44:17 <lingxiao> like there cannot be a laz foldM?
19:45:11 <lingxiao> lambdamu by zip package did you mean zip-archive?
19:45:23 <lingxiao> geekosaur so you think the problem is in fold right?
19:45:33 <lingxiao> what if I did a manual recursion
19:45:45 <lambdamu> lingxiao: https://hackage.haskell.org/package/zip
19:45:50 <lingxiao> no optimization there ether right?
19:45:57 <lingxiao> ah thanks
19:46:26 <geekosaur> I think the problem is in the way foldM interacts with lazy I/O (write
19:46:27 <geekosaur> er
19:46:29 <geekosaur> no.
19:46:39 <lingxiao> why this error: http://lpaste.net/
19:46:46 <lingxiao> yeah i see ..
19:46:52 <lingxiao> hmm ok conduit here i come then
19:47:04 <lingxiao> ops sorry lambdamu http://lpaste.net/176079
19:47:09 <lingxiao> I got the same error with zip-conduit
19:47:25 <geekosaur> readFile is lazy but when processed through foldM via concatFile it ends up strict, I think. that is not the way I
19:48:14 <geekosaur> d have done it; process each file individually as an append instead of trying to do all of them into a single writeFile, because if anything along the way strictifies you're going to have all the files you're processing in memort
19:48:18 <lambdamu> lingxiao: thats odd which stackage snapshot are you using?
19:48:26 * geekosaur tends to not trust lazy I/O anyway
19:48:31 <lingxiao> sorry no idea what a stackage snapshot is
19:48:48 <lingxiao> yeah i'm def going to use conduit then ..
19:49:00 <lambdamu> lingxiao: sorry its called resolver in the stack.yaml
19:49:28 <lingxiao> here it is: http://lpaste.net/176080
19:49:35 <lingxiao> lts-3.18
19:49:51 <lingxiao> is that the latest?
19:50:02 <lingxiao> funny .. all i did was stack new [MyProject]  
19:50:06 <lambdamu> no that's pretty old
19:50:11 <lingxiao> which should give me the lastest one right?
19:50:25 <lingxiao> oh ok how do I check what the latest one is?
19:50:31 <lambdamu> the newest would be 6.11
19:50:39 <lambdamu> https://www.stackage.org/snapshots
19:50:57 <lingxiao> so how did i get that version if all i did to setup the project was stack new
19:51:00 <lingxiao> is that command outpdated?
19:51:28 <lambdamu> just change it in your stack.yaml
19:51:34 <lambdamu> then stack build
19:51:36 <lingxiao> yeah i did that .. 
19:51:43 <lambdamu> or stack build --only-dependencies
19:51:57 <lingxiao> what does th --only-dependencies flag do
19:52:11 <lambdamu> it builds only the dependencies e.g. the zip package
19:52:28 <lambdamu> stack build builds your project too
19:52:42 <lingxiao> ah ok got it
19:52:44 <lingxiao> that akes sense
19:55:28 <dustmote> super confused by the three syntaxes for associated type synonym families
19:55:55 <dustmote> also confused by the distinction between type families (data families?) and type synonym families .. though, less so than the above
19:55:55 <lingxiao> lambdamu ok im getting a bunch of  write to restore size failed   erros
19:56:13 <mgsloan> dustmote: type families == type synonym families
19:56:18 <dustmote> anyone have a good resourche beyond the wiki? https://wiki.haskell.org/GHC/Type_families
19:56:28 <mgsloan> As far as I know there's just one way to write associated type families?
19:57:04 <dustmote> mgsloan: the wiki shows pages and pages of 'data families' before getting into type synonym families in sectino 5 :/
19:57:56 <dustmote> mgsloan: and in section '6.2 Type instance declarations
19:58:10 <dustmote> ' it shows three sytaxes.. i'll paste them
19:58:13 <mgsloan> Distinction between data families and type families is that data family instances introduce a constructor, so they're guaranteed to be injective
19:58:24 <mgsloan> Yeah, it should start with type families, they seem to be used more
19:58:48 <mgsloan> Generally, other resources are better than the wiki
19:59:06 <dustmote> mgsloan: '^'
19:59:20 <dustmote> do you have any suggestions?
19:59:31 <lambdamu> The new GHC user guide is quite readable
19:59:48 <lambdamu> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?#ghc-flag--XTypeFamilies
19:59:58 <mgsloan> Yeah, I usually just read the manual / blog posts
20:00:44 <lambdamu> lingxiao: how do you get that error?
20:01:37 <dustmote> ah, mgsloan, not three syntaxes: open type families, closed type families, and associated type families.. my bad!
20:02:18 <mgsloan> Right, well, we've really got both type families and data families, and either can be associated with a typeclass
20:05:41 <slack1256T> I made a little snake-clone on sdl2 (haskell lib). Is there a easy way to put it in a sever (yesod, purescript, etc) so a friend can play it?
20:10:25 <dustmote> lambdamu: this is maybe dumb, but would explanation about GHC.TypeLits also be in the users guide?
20:12:00 <ReinH> slack1256T: No.
20:12:04 <lambdamu> dustmote: why would that be dumb? but no I don't think there is
20:12:08 <ReinH> SDL isn't a web technology.
20:12:15 <geekosaur> slack1256T, sdl2 uses opengl. I don't think you can get from there to something web-based without something truly horrid (there used to be an X server in javascript...)
20:12:25 <dustmote> lambdamu: thanks!
20:13:18 <mgsloan> dustmote: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#type-level-literals
20:13:29 <mgsloan> Google and ctrl-f
20:13:30 <mgsloan> :D
20:16:50 <dustmote> jackpot! thanks mgsloan :)
20:16:51 <lingxiao> hey guys
20:17:06 <lingxiao> does it make sense if went into ~/Library/Caches and deleted ALL the files
20:17:13 <lingxiao> i need to free up space on my mac
20:20:19 <sm> slack1256T: nice, you should mention it in #haskell-game
20:27:42 <slack1256T> geekosaur: you're right. 
20:59:38 <joe9> is the use of GADT's considered bad practice?
21:01:28 <glguy> Only if it's unnecesary or making something more complicated than it needed to be. For most situations you won't need them.
21:06:43 <joe9> glguy: need some advice, please? My library maintains some state https://github.com/joe9/streaming-betfair-api/blob/master/src/Betfair/StreamingAPI/API/StreamingState.hs . Every time a certain event happens, it updates the state and calls callback function. I am trying to figure how a user of this library can thread his state across the callbacks.
21:07:25 <joe9> I am thinking of changing the line 27 MarketState to a TypeClass
21:07:40 <joe9> StreamingState {ssMarkets :: Map.Map MarketId MarketState -- this line
21:08:18 <joe9> MarketState a =>  StreamingState {ssMarkets :: Map.Map MarketId a -- not syntactically correct. but, to convey my intention.
21:08:46 <joe9> I could do that with a GADT and not have to worry about adding the MarketState a => to each function using it.
21:09:10 <joe9> or, just use a GADT and not worry about specifying it wherever the StreamingState data type is used.
21:09:18 <joe9> glguy, any suggestions, please?
21:10:40 <joe9> https://wiki.haskell.org/Data_declaration_with_constraint got the idea of a GADT from here
21:42:44 <mjrosenb> /usr/local/bin/ld: cannot find -lHStransformers-compat-0.5.1.4-9QztagRWyOyIfLMXpD0KI1-ghc7.10.2
21:42:47 <mjrosenb> /usr/local/bin/ld: cannot find -lHSstm-2.4.4-C1kFMnPqFjvDhFjgMZGUpr-ghc7.10.2
21:43:13 <mjrosenb> I keep getting these when using cabal install --dependencies-only.  any idea how to fix it?
21:43:40 <DefinatelyNotBen> Hello
21:43:41 <glguy> mjrosenb: Does ghc-pkg check report any problems with those packages?
21:45:53 <mjrosenb> ghc-pkg check complained about a lot of packages.  I'm reinstalling all of them now.
21:49:34 <mjrosenb> after reinstalling everything, ghc-pkg check still complains about tagged.
21:49:54 <koz_> Is there something like ncurses for Haskell?
21:50:19 <glguy> koz_: vty is a library for building console UIs
21:50:31 <Clint> and brick is a library on top of vty
21:50:36 <glguy> mjrosenb: Did you unregister the broken things before reinstalling them?
21:50:46 <mjrosenb> glguy: no.  how do I do that/
21:50:48 <mjrosenb> ?
21:50:58 <glguy> ghc-pkg unregister $THEPKG
21:51:14 <glguy> mjrosenb: Did you use --force flags recently?
21:51:25 <glguy> (forcing things is a good way to break things)
21:51:44 <mjrosenb> glguy: only to fix things after they started breaking.
21:52:04 <mjrosenb> I'm also not opposed to wiping out my .cabal directory and starting over.
21:52:15 <koz_> Clint: Brick looks neat. Thank you!
21:52:23 <glguy> Wiping out .cabal isn't likely to help much, but .ghc can
21:53:15 <glguy> mjrosenb: What version of GHC? cabal-install?
21:53:16 <mjrosenb> done.
21:53:24 <mjrosenb> 7.10.2
21:53:43 <mjrosenb> cabal-install version 1.22.6.0
21:53:43 <mjrosenb> using version 1.22.4.0 of the Cabal library 
21:56:12 <Clint> koz_: have fun
21:59:31 <mjrosenb> /usr/local/bin/ld: cannot find -lHSstm-2.4.4-C1kFMnPqFjvDhFjgMZGUpr-ghc7.10.2
21:59:32 <glguy> mjrosenb: OK, just checking that it wasn't GHC 8 w/o Cabal 1.24
21:59:42 <mjrosenb> bah.
21:59:59 <mjrosenb> (this was after removing .cabal and .ghc)
22:00:13 <glguy> and running what command?
22:01:35 <mjrosenb> cabal install --dependencies-only in a project I wrote
22:01:57 <mjrosenb> I can get the same behavior just trying to install one package though.
22:03:00 <glguy> mjrosenb: It might be worth unregistering stm again, cabal installing it with -v, and then cabal installing the problem package that requires stm with -v
22:03:15 <glguy> and pasting that log to the paste bin. I don't know what's wrong off the top of my head but maybe someone will see something they recognize
22:03:42 <mjrosenb> it looks like stm was installed by a package manager, not cabal.
22:04:06 <mjrosenb> glguy: how do I unregister it?
22:04:10 <glguy> Are you mixing package manager packages with cabal install packages?
22:04:29 <mjrosenb> that was not my intention, but it appears to have happened.
22:04:45 <glguy> I'd use your package manager to uninstall them, then
22:04:59 <mjrosenb> cabal should prefer pacakges from ~/.cabal over system packages, right?
22:05:24 <glguy> Yes, but if you installed something into .cabal that already depends on the system package
22:05:35 <mjrosenb> true.
23:03:20 * hackagebot cryptonite 0.18 - Cryptography Primitives sink  https://hackage.haskell.org/package/cryptonite-0.18 (VincentHanquez)
23:06:44 <pavonia> Looks like I finally ran into one of these "ugly" cases with FFI where I have to get a pure struct as return value from a foreign function call. What is the general pattern for this or where do you find an example for it?
23:16:38 <nak> is it common to indent all lines after a `module` declaration ?
23:18:20 * hackagebot cryptonite 0.19 - Cryptography Primitives sink  https://hackage.haskell.org/package/cryptonite-0.19 (VincentHanquez)
23:18:21 <liste> nak: no
23:18:29 <liste> nak: or do you mean the export list?
23:22:21 <nak> liste sorry for any confusion; my question was answered in #haskell-beginners
23:22:37 <nak> liste it was a question that arose whilst reading "Haskell Programming" book
23:22:52 <nak> the book also answers it in the following pages
23:22:58 <nak> i should've just read further ^_^
23:28:20 * hackagebot connection 0.2.6 - Simple and easy network connections API  https://hackage.haskell.org/package/connection-0.2.6 (VincentHanquez)
23:30:35 <mcgru> could you help me with EclipseFP and Hoogle ?
23:31:13 <mcgru> i cannot get help on selected text with F4
23:36:49 <liste> mcgru: "EclipseFP is currently NOT maintained anymore. Feel free to fork and take up maintainership!"
23:37:06 <liste> so I doubt it works well with Haskell tool updates
23:54:35 <DefinatelyNotBen> that would be awesome. \
23:59:55 <DefinatelyNotBen> Σ
