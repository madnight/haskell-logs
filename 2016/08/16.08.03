00:07:09 * hackagebot isobmff-builder 0.10.5.0 - A (bytestring-) builder for the ISO-14496-12 base media file format  https://hackage.haskell.org/package/isobmff-builder-0.10.5.0 (SvenHeyll)
00:07:09 * hackagebot tagsoup-megaparsec 0.2.0.0 - A Tag token parser and Tag specific parsing combinators  https://hackage.haskell.org/package/tagsoup-megaparsec-0.2.0.0 (kseo)
00:14:26 <pyon> Is there some way to query in GHCi which infix functions are defined at each fixity level?
00:20:19 <mniip> pyon, :browse?
00:20:25 <mniip> hmm
00:25:39 <nkaretnikov`> is it possible to define a class for working with ordinary lists and hlists?  something like class Add t where end :: t a; add :: a -> t b -> t c
00:25:45 <nkaretnikov`> this definition doesn't work, of course
00:26:04 <nkaretnikov`> ah, and my definition of hlist is the old one with a gadt
00:26:39 <nkaretnikov`> data HList a where Nil :: HList Nil; Cons :: a -> HList b -> HList (Cons a b); data Nil; data Cons a b
00:26:46 <nkaretnikov`> ideas?
00:28:01 <nkaretnikov`> when trying to provide an instance for the above class def'n, i get a lot of rigid variable errors
00:28:09 <nkaretnikov`> which i understand
00:28:17 <nkaretnikov`> but i don't see a way to make it work :\
00:29:00 <nkaretnikov`> if this attempt fails, i can always work with them as monoids, but that'd be less ideal
00:30:00 <cocreature> nkaretnikov`: what exactly is Add supposed to do? could you provide some code sample of what you are trying to achieve and where the errors come in?
00:31:43 <nkaretnikov`> cocreature: add is either (:) or cons
00:32:00 <nkaretnikov`> cocreature: i think i've just defined what i needed
00:32:14 <nkaretnikov`> cocreature: by moving each function argument to a typeclass parameter
00:32:18 <nkaretnikov`> and splitting the class into two
00:32:30 <nkaretnikov`> gonna experiment with that for a bit
00:38:07 <shafox> I have stack no ghc is installed in the system. I want to install ghc in the system, can stack do that or else I have to do that manually ? 
00:38:27 <Koterpillar> shafox: what do you want ghc for?
00:39:00 <shafox> Koterpillar: I want to use it for vim. ghc-mod is required for vim and sublimehaskell as well. I cant use any of those.
00:39:10 <MasseR> shafox: stack install ghc-mod
00:39:15 <MasseR> stack exec -- vim
00:43:29 <shafox> MasseR: Ohh I can do that ? :/
00:44:05 <pavonia> Is there no function to split the last element and the init by just one function call?
00:44:14 <pavonia> of a list, that is
00:45:14 <xtreak> let myrepeat a = [a, a] . Can I make a to be only of Int and String in the signature?
00:46:31 <MasseR> shafox: yup
00:47:12 <pavonia> xtreak: How would that be useful in this case?
00:48:57 <phanimahesh> Is it a good idea to move a number crunching heavy operation from python numpy to haskell?
00:49:01 <xtreak> Sorry. I couldn't think of a better use case for it. Just wanted to know if its possible to make the function accept only arguments of some types.
00:49:10 <srhb> phanimahesh: "Depends"
00:49:30 <phanimahesh> There's a part that does matrix inversions and multiplications etc on sizes 30,000x30,000.
00:49:36 <cocreature> numpy is basically an api over a C layer iirc so I doubt you’ll get a lot faster
00:49:36 <srhb> phanimahesh: data science stuff is often more comfortable in Python, but you can often get more speed from Haskell. Depends what you need.
00:49:38 <phanimahesh> And we only need a handful of the results.
00:49:42 <srhb> phanimahesh: Those things are usually C libraries anyway
00:49:57 <srhb> phanimahesh: In both Haskell and Python. :)
00:50:17 <phanimahesh> I'm hoping to leverage haskell's laziness and avoid "computing" the unnecessary bits, without having to do it manually myself
00:51:46 <xtreak> Discussions that might help https://www.reddit.com/r/haskell/comments/3vwn69/equivalent_of_numpy_for_haskell/, https://www.reddit.com/r/haskell/comments/2dd2um/what_are_some_haskell_alternatives_to_pandasnumpy/
00:52:02 <phanimahesh> srhb: Yep, you are right. I was hoping someone who did something similar can comment if it's a good idea.
00:52:09 <phanimahesh> xtreak: thanks, reading them now.
00:52:28 <cocreature> phanimahesh: lazyness won’t really help you since as srhb said these libs mostly go via C which is obviously strict
00:52:49 <phanimahesh> There appears to be Data.Matrix which is pure haskell.
00:53:21 <phanimahesh> It uses lists heavily though, so I'm skeptical if that'll offset some of the gains
00:53:43 <srhb> phanimahesh: It uses lists heavily for things lists are fast at.
00:54:04 <srhb> phanimahesh: And Vector for other things :)
00:56:46 <phanimahesh> Oh. It should be worth a shot then.
00:57:18 <phanimahesh> I'm toying with the idea since a week. I'm the only one around who even knows haskell, and my haskell is rusty at best.
00:58:03 <srhb> phanimahesh: BLAS and Lapack and companya are really, really heavily optimized. It's probably easier to try your specific use case and compare if there are any wins rather than theoretically determining whether that will be the case. :-P
01:00:18 <gargawel> Hi, does someone have experience using postgresql-simple with a custom monad stack ? "withTransaction" explicitly requires an IO action instead of being generalized to MonadIO
01:01:06 <phanimahesh> srhb: Okay, will just create it to see the difference.
01:07:11 <fr33domlover> gargawel, persistent uses postgresql-simple iirc for its postgresql backend
01:07:17 <fr33domlover> and it uses a custom monad stack
01:07:48 <gargawel> fr33domlover: I think you're right, there may be something to learn there
01:07:54 <fr33domlover> you can check how the persistent-postgresql package works, gargawel 
01:08:44 <gargawel> I am trying to run my computation to get an IO action, call withTransaction on it and re-wrap it in my custom monad, but I am not sure that's the right approach
01:09:45 <cocreature> gargawel: try "liftBaseOp_ (withTransaction conn)"
01:09:52 <cocreature> gargawel: liftBaseOp_ is from monad-control
01:10:06 <cocreature> it requires an instance of MonadBaseControl for your monad but most monad stack have one
01:10:19 <gargawel> cocreature: looks wonderful ! I already have that instance
01:11:25 <gargawel> (unrelated, but I feel like something finally clicked and I'm getting productive in Haskell - that's an absolutely amazing feeling !)
01:11:39 <cocreature> monad-control is a useful tool to have in your toolbox
01:12:24 <gargawel> cocreature: so, is MonadBaseControl basically doing what I inteded to do manually ?
01:12:28 <gargawel> *intended
01:13:15 <cocreature> gargawel: yep, so let’s say your custom monad was a state monad, then monadbasecontrol unwraps the state and passes it manually and then restores it afterwards
01:13:52 <gargawel> cocreature: nice !
01:14:09 <cocreature> gargawel: so what you are doing is exactly what MonadBaseControl is intended for :)
01:14:28 <cocreature> gargawel: for some packages there exist also lifted-* versions, like lifted-async which already provide the necessary wrappers
01:14:54 <shafox> I have installed hsdev but while building through sublime using ctl+b it is saying runhaskell is not found. Which package is it ? 
01:15:45 <cocreature> runhaskell is bundled with ghc
01:15:50 <cocreature> shafox: are you using stack by any chance?
01:16:03 <shafox> cocreature: yes using stack. 
01:16:27 <ongy> is it just me, or does 'cabal install' only use one core, but 'cabal build' use all?
01:17:01 <cocreature> shafox: not familiar with hsdev, but try adding ~/.stack/programs/x86_64-linux/ghc-yourghcversion/bin to your path
01:18:11 <phanimahesh> replace ghc-yourghcversion as appropriate
01:18:21 <phanimahesh> Or better, use `stack runhaskell`
01:18:45 <pyon> mniip: Ah, didn't know about :browse, thanks!
01:18:49 <shafox> cocreature: one of the project that I am building using the nightly and I have 2 ghc in my programs dir. ghc-7.10.3/ ghc-8.0.1/ , If I allow to use both then that would be in conflict with each other right ? 
01:19:00 <phanimahesh> I don't know if hsdev allows you to customize the command
01:19:19 <shafox> phanimahesh: that was going to be my next question :?
01:21:27 <phanimahesh> I'm a vimmer, sorry, no idea about Sublime.
01:21:46 <cocreature> shafox: well it would just chose whatever appears first in your path
01:22:20 <shafox> phanimahesh: ahh ok. :) 
01:22:28 <shafox> cocreature: okies. will try out.
01:30:23 <shafox> phanimahesh: by any chance are you using haskell-vim-now ? or your own settings.
01:31:17 * phanimahesh greps init.vim
01:31:54 <phanimahesh> Nope. Custom stuff cobbled up.
01:32:01 <phanimahesh> Will check it out.
01:32:37 <phanimahesh> I don't write much haskell, only do it in my free time to cleanse my sins of working with JS during the day.
01:34:46 <phanimahesh> I remember why I wasn't using it. It wants to replace my vim config, and I'm too lazy to integrate it cleanly with my existing stuff
01:37:05 <phanimahesh> I remember checking it out coz I have filed https://github.com/begriffs/haskell-vim-now/issues/160
01:48:27 <joneshf-laptop> I could've sworn there was a new thing to choose the constraints in ghci, anyone know what I'm talking about?
01:48:42 <joneshf-laptop> Like, i've got this:
01:48:44 <joneshf-laptop> λ: :t lmap Right
01:48:46 <joneshf-laptop> lmap Right :: Profunctor p => p (Either a b) c -> p b c
01:48:58 <joneshf-laptop> and I want to see it where I choose `p = (->)`
01:49:18 <joneshf-laptop> Is that a thing, or did I just make that up?
01:50:07 <merijn> joneshf-laptop: You could copy lambdabot's asAppliedTo?
01:50:25 <merijn> :t lmap Right `asAppliedTo` (undefined :: Either a b -> c)
01:50:27 <lambdabot> (Either a b -> c) -> b -> c
01:50:30 <phanimahesh> or make up undefined values typed to whatever you want and apply them?
01:50:51 <shafox> phanimahesh: ahh. Not too efficient in vim. 
01:50:52 <phanimahesh> ah. asAppliedTo is neat!
01:51:02 <joneshf-laptop> hmm, interesting
01:51:06 <joneshf-laptop> :t asAppliedTo
01:51:08 <lambdabot> (a -> b) -> a -> a -> b
01:51:17 <merijn> asAppliedTo is const with a custom signature, so trivial to copy
01:51:23 <joneshf-laptop> word
01:51:39 <joneshf-laptop> So did i actuallymake that up then?
01:51:50 <merijn> :t let foo :: (a -> b) -> a -> a -> b; foo = const in foo
01:51:51 <lambdabot> (a -> b) -> a -> a -> b
01:52:05 <merijn> :t let foo :: (a -> b) -> a -> a -> b; foo = const in lmap Right `foo` (undefined :: Either a b -> c)
01:52:06 <lambdabot> (Either a b -> c) -> b -> c
01:52:13 <shachaf> joneshf-laptop: You didn't make it up. GHC 8 has type application.
01:52:16 <merijn> joneshf-laptop: Such a feature might exist, but I don't know
01:52:42 <joneshf-laptop> wow, apparently I've also asked this before, because I've alread copied `asAppliedTo` into my .ghci :P
01:52:51 <joneshf-laptop> merijn, thanks though!
01:54:23 <joneshf-laptop> shachaf, yes! that's it! Thank you!
01:56:54 <gargawel> cocreature: BTW, liftBaseOp_ seems to work fine, thanks !
02:07:03 * hackagebot clash-prelude 0.10.11 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-0.10.11 (ChristiaanBaaij)
02:07:05 * hackagebot clash-lib 0.6.20 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.20 (ChristiaanBaaij)
02:07:07 * hackagebot clash-systemverilog 0.6.8 - CAES Language for Synchronous Hardware - SystemVerilog backend  https://hackage.haskell.org/package/clash-systemverilog-0.6.8 (ChristiaanBaaij)
02:07:09 * hackagebot clash-verilog 0.6.8 - CAES Language for Synchronous Hardware - Verilog backend  https://hackage.haskell.org/package/clash-verilog-0.6.8 (ChristiaanBaaij)
02:07:11 * hackagebot clash-vhdl 0.6.16 - CAES Language for Synchronous Hardware - VHDL backend  https://hackage.haskell.org/package/clash-vhdl-0.6.16 (ChristiaanBaaij)
02:08:03 <eklavya> how does template haskell manage imports?
02:08:23 <eklavya> the same imports will have to be present at call site too, right?
02:09:12 <gargawel> eklavya: I think Template haskell does not "manage" imports
02:09:17 <gargawel> so, yes
02:09:59 <eklavya> all the things I am using in the template will also have to be imported on call site and with the same names?
02:10:23 <merijn> eklavya: All the things using in the code generated by the template has to be imported on the call site, yes
02:10:40 <eklavya> ok
02:10:43 <eklavya> thanks :)
02:12:13 * hackagebot clash-ghc 0.6.22 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.22 (ChristiaanBaaij)
02:22:03 * hackagebot microlens-mtl 0.1.10.0 - microlens support for Reader/Writer/State from mtl  https://hackage.haskell.org/package/microlens-mtl-0.1.10.0 (Artyom)
02:22:05 * hackagebot microlens-platform 0.3.5.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.3.5.0 (Artyom)
02:27:59 <cocreature> gargawel: yw :)
02:37:19 <matrium_> Hi, I'm trying to parse some binary format and the size of some dates depends on the header. the header states either 1 for 1 byte or 2 for 2 bytes. So I wrote a monadic function, returning the right parser, depending on the header information: 
02:37:34 <matrium_> sampleGetter :: Integral a => Int -> Get a sampleGetter 1 = getWord8 sampleGetter 2 = getWord16be
02:37:47 <matrium_> sampleGetter :: Integral a => Int -> Get a
02:37:53 <matrium_> sampleGetter 1 = getWord8 
02:37:57 <matrium_> sampleGetter 2 = getWord16be
02:38:57 <matrium_> unfortunately, the compiler gives me a "Couldn't match type ‘a’ with ‘Word8’       ‘a’ is a rigid type variable bound by           the type signature for sampleGetter :: Integral a => Int -> Get a           at app/Main.hs:56:17     Expected type: Get a       Actual type: Get Word8     Relevant bindings include       sampleGetter :: Int -> Get a (bound at app/Main.hs:57:1)     In the expression: getWord8     In an equati
02:39:06 <gargawel> matrium_: don't you want "Get (Get a))" instead of "Get a" ?
02:39:18 <gargawel> (there is one too many parenthesis here)
02:39:43 <merijn> matrium_: You probably want liberal application of fromIntegral? :)
02:39:56 <merijn> "fromIntegral <$> getWord8"
02:40:17 <gargawel> (sorry, misunderstood)
02:42:11 <matrium_> merijn: thanks, that fixed it!
03:22:03 * hackagebot pontarius-xmpp 0.5.2 - An XMPP client library  https://hackage.haskell.org/package/pontarius-xmpp-0.5.2 (PhilippBalzarek)
03:23:51 <wz1000> Hi! I'm using GHC.TypeLits, and I want to prove to GHC that (n-1) < n' given n < n'. How do I do this?
03:28:56 <phanimahesh> How can I compose a function n times?
03:29:07 <jle`> phanimahesh: iterate and !!, normally
03:29:11 <phanimahesh> I can write a simple wrapper but it feels there should be a simpler way
03:29:19 <phanimahesh> Ah. Without building the list?
03:29:21 <jle`> but be careful of non-strictness
03:29:26 <jle`> well, the list usually doesn't get built
03:29:36 <jle`> litsts are just control flow in haskell, for the most part
03:29:58 <phanimahesh> cool. So GHC can optimise it away if I use a generator function and !!?
03:30:02 <jle`> if you look at the source for iterate and the source for !!, you can kind of see that the list is constructed/deconstructed at the same time, and never really exists
03:30:35 <jle`> hm, i don't think I'd call it a GHC thing
03:30:44 <jle`> just a consequence of ahskell's evaluational model
03:31:53 <jle`> but yeah, if 'n' is too big, you might have to start worrying about how iterate/!! are not strict
03:32:03 * hackagebot servant-aeson-specs 0.3 - generic tests for aeson serialization in servant  https://hackage.haskell.org/package/servant-aeson-specs-0.3 (SoenkeHahn)
03:32:11 <jle`> but for small n it should be fine
03:32:37 <phanimahesh> reductions under the hood?
03:33:12 <jle`> hm?
03:33:19 <wz1000> Is there anyway to use something like unsafeCoerce to prove a constraint to ghc?
03:33:43 <jle`> wz1000: it's a bit more tractable with things like 'Dict' and the cosntraints library
03:33:47 <jle`> *constraints
03:34:06 <jle`> but there are a couple of ways to do it, yeah
03:34:24 <jle`> well, whether or not it's possible/coherent depends on the specific thing you're trying to do
03:34:53 <wz1000> jle`: I'm trying to get this(http://lpaste.net/173825) to compile
03:35:26 <jle`> what's the issue?
03:35:49 <jle`> ah
03:35:56 <wz1000> jle`: GHC doesn't know that if n <n' then n-1<n'-1
03:36:13 <jle`> yeah
03:37:09 <jle`> usually the safe path here is to provide a "proof" to GHC (usually made using unsafeCoerce)
03:37:20 <wz1000> How?
03:37:21 <jle`> but to abstract away the unsafeCoerce
03:37:28 <fr33domlover> In the function 'matchGr' whose source is at https://hackage.haskell.org/package/fgl-5.5.2.3/docs/src/Data-Graph-Inductive-PatriciaTree.html , if I need only the 'fst' of the result, will the 'snd' still be evaluated just because of the '!' used there?
03:37:31 <jle`> it's better if you have a library you trust providingit, though
03:38:05 <jle`> hm, let me think if there's any way you can get the proof using current libraries
03:39:01 <wz1000> jle`: I have an idea. If I make a version without the CompNat constraint and use it to recurse in the exported vIndex function, will that work?
03:39:18 <jle`> try it :)
03:42:03 * hackagebot reddit 0.2.1.0 - Library for interfacing with Reddit's API  https://hackage.haskell.org/package/reddit-0.2.1.0 (Intolerable)
03:45:07 <wz1000> jle`: That error went away, but now it can't deduce KnownNat (n-1), and I can't add it to the constraints because (0-1) isn't KnownNat
03:45:30 <jle`> ah, you can deduce KnownNat (n - 1) from KnownNat n using singletons
03:45:57 <wz1000> jle`: How do I do that?
03:46:03 <jle`> withKnownNat (SNat @n %:- Snat @1) $ -- ... continuation where you have KnownNat (n - 1)
03:47:57 <jle`> wz1000: you can use unsafeCoerce on Refl to get (CmpNat (n - 1) (m - 1) :~: 'LT), and if you pattern match on it, you'll have CmpNat (n - 1) (m - 1) ~ 'LT in that case statement
03:48:35 <jle`> if you're lucky it might just work when you do it from within your function, but sometimes you might have to define a wrapper data type
03:49:25 <jle`> that's somewhat a safe unsafeCoerce as long as you're user about the implication
03:49:32 <jle`> s/user/sure
03:50:06 <jle`> the unsafe part would come when functions assume that (n - 1) `CmpNat` (m - 1) ~ LT is true and do things with it that only make sense with that assumption
03:51:05 <wz1000> jle`: Where's Refl defined?
03:51:11 <jle`> Data.Type.Equality
03:51:40 <jle`> if you have a value of type (a :~: b), and you pattern match on the constructor (Refl), then in that case branch, (a ~ b) is a constraint
03:53:52 <jle`> that's becuase Refl can only be "constructed" if (a ~ b), so if you pattern match on it (and show that your `a :~: b` is not bottom), it's a witness that (a ~ b) at the time of construction, so you can use (a ~ b)
03:54:16 <jle`> so with some clever unsafeCoerce's you can trick GHC
03:55:40 <jle`> the main problem with your situation here is that CmpNat is treated by GHC as just an arbitrary type family; it can't use any properties of Nat or its ordering to make conclusions while typechecking.
03:55:55 <jle`> so one alternative here would be to use a type-checker plugin that *does* take advatnage of CmpNat and the structure of Nat's
03:56:09 <jle`> i'm not sure if such a type checker plugin exists
03:57:01 <blodstone> Hi, new to haskell here. Just bought the Programming in Haskell book. How do I run the code in the book? Do i use GHCI or other? 
03:57:20 <jle`> blodstone: hopefully the book would explain when the time comes
03:57:24 <matrium_> what is the right pattern when I have n monadic operations I want to sequence (collect all the results) but the result of the i-th computation repensed on i-1? fold? StateT and sequence?
03:58:05 <jle`> matrium_: there's an iterateM or something similar in monad-loops
03:58:29 <jle`> blodstone: using ghci and writing haskell code in a source file is a bit differnet, so hopefully the book explains which to do in what situation
03:59:11 <merijn> matrium_: Both fold and StateT seem reasonable depending on context
04:00:00 <lpaste> BlueSkull pasted “b^n” at http://lpaste.net/173832
04:00:16 <BlueSkull> Hi all
04:00:43 <BlueSkull> can anyone tell me why didn't run the code that i had pasted?
04:00:50 <wz1000> jle`: I tried that. Now it can't prove that n1 ~ (n' - 1) where n' ~ (n1 + 1)
04:01:21 <blodstone> jle`: the book starts by giving example like "double x = x + x", how do I test it? 
04:01:43 <jle`> blodstone: you can write a haskell file with that line, and load it in ghci using ":l myfile.hs", and test it out in ghci
04:01:50 <jle`> or you can define it in ghci with "let double x = x + x"
04:02:03 <jle`> wz1000: heh, what did you do?
04:02:08 <blodstone> jle`: thank you
04:02:54 <merijn> BlueSkull: What's the error?
04:03:13 <BlueSkull> The code i had pasted comes from this definition of b^n: if even (b^1/2)^2, and if its odd b*(b^(n-1/2))^2
04:03:29 <BlueSkull> merijn, the code didn't stop
04:03:31 <jle`> wz1000: my typical approach here is to create an ADT that encapsulates the possible case splits you'd want to have, and then write a function that creates it using unsafeCoerce
04:03:35 <BlueSkull> its like a infinite loop
04:03:42 <jle`> (after making sure I couldn't write it using other functions other libraries already provide)
04:04:51 <merijn> BlueSkull: It only stops if 'n == 0' (line 2), but you always call it with 'n == 2'?
04:05:03 <wz1000> jle`: http://lpaste.net/173834
04:05:09 <BlueSkull> merijn: sorry, even is (b^(1/2))^2
04:05:27 <BlueSkull> merijn: let me check
04:05:28 <jle`> wz1000: that process is the basis of this module: http://hackage.haskell.org/package/typelits-witnesses-0.2.3.0/docs/GHC-TypeLits-Compare.html
04:05:47 <merijn> BlueSkull: Your code always calls itself with 'n == 2', so it can never terminate
04:06:26 <jle`> none of those would directly help you here because all of the checks happen at run-time, but you can adopt a similar process
04:07:03 * hackagebot HaRe 0.8.3.0 - the Haskell Refactorer.  https://hackage.haskell.org/package/HaRe-0.8.3.0 (AlanZimmerman)
04:07:53 <BlueSkull> merijn: no, in line 3 we compute n/2, this is the case with n even, and in odd case its line 4 that call with n-1
04:09:32 <BlueSkull> merijn: ahhhhhhhh, ok ok, now i see, you mean the first call potencia'
04:09:56 <BlueSkull> merijn, not the inner one
04:10:02 <merijn> BlueSkull: Right :)
04:10:17 <BlueSkull> but its the definition...
04:10:21 <jle`> wz1000: can you put up your definition of Vec?  i'll try something out
04:10:24 <BlueSkull> how can i do it?
04:10:56 <wz1000> jle`: How about I simply unsafeCoerce the constraint NatCmp (n-1) n1 ~ LT where xs :: Vec n1 a
04:11:39 <jle`> try it?
04:15:43 <wz1000> jle`: Back to "can
04:15:59 <wz1000> 't deduce KnownNat (n-1)" :)
04:16:23 <jle`> did you try the singletons prover?
04:17:16 <wz1000> jle`: No. How do I do that?
04:53:31 <srhb> jle`: Wouldn't the typelits natnormalize plugin be a better fit here?
05:04:20 <Gurkenglas> Where does STM define fail?
05:05:18 <hpc> https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Conc.Sync.html#line-638
05:05:25 <hpc> fail = error, it appears
05:07:43 <Gurkenglas> Ah, I was looking in https://hackage.haskell.org/package/stm-2.4.4.1/docs/Control-Monad-STM.html and on https://www.google.de/?client=firefox-b#q=site:hackage.haskell.org%2F+%22instance+Monad+STM%22+%22fail%22
05:08:06 <hpc> i searched hoogle for STM, clicked the newtype, then under instances clicked "Source" on the Monad instance
05:08:31 <hpc> that last bit is probably the best feature of new hackage
05:13:24 <maerwald> the newtype?
05:15:52 <cocreature> hpc: yeah I love these source links for instances
05:16:07 <maerwald> I neither see a newtype, nor source links for the instances
05:22:03 * hackagebot shared-fields 0.1.2.0 - a tiny library for using shared lens fields  https://hackage.haskell.org/package/shared-fields-0.1.2.0 (Intolerable)
05:22:21 <hpc> maerwald: http://hoogle.haskell.org/?hoogle=STM - first result?
05:22:36 <maerwald> ah
05:32:03 * hackagebot servant-matrix-param 0.1 - Matrix parameter combinator for servant  https://hackage.haskell.org/package/servant-matrix-param-0.1 (SoenkeHahn)
05:37:22 <phanimahesh> Is it a bad idea to define a Memoizable Float?
05:47:02 <zxtx> hey what's the easiest way to dispatch on type for something primitive
05:47:16 <zxtx> like I want to call one function if its a Double and another if it is Integer
05:50:44 <mniip> a typeclass
05:51:28 <wz1000> Why doesn't GHC have transitive type equality? If (a ~ b) and (a ~ c), then why can't it infer (b ~ c)?
05:52:55 <zxtx> mniip, oh yes, I had forgotten about those for a while
05:53:58 <mniip> wz1000, it can't?
05:54:14 <mniip> pretty sure it can
05:55:07 <wz1000> mniip: Sorry, I misunderstood the error. It can't infer n1~n2 where n ~ (n1 + 1) and n ~ (n2 + 1). Understandable, but still annoying 
05:55:49 <mniip> + might not be injectivee
06:01:44 <wz1000> mniip: Yeah I understand, but I'm using TypeLits from base. I would expect functionality atleast equivalent to what I can get for free by promoting a simple data Nat = O | S Nat type.
06:01:55 <mniip> ehh
06:02:00 <mniip> GHC.TypeLits are far from that
06:02:11 <cocreature> which is quite annoying sometimes
06:05:56 <zxtx> mniip, I'm getting the error, No instance for (Foo a) arising from a use of 'foo', add (Foo a) to the context of the type signature for: pure :: a -> Bar a
06:06:40 <mniip> code?
06:11:06 <sgronblo> Does this seem like a valid use of PartialTypeSignatures? newTodoItem <- jsonData :: ActionT _ _ TodoItem
06:12:13 <zxtx> mniip, http://lpaste.net/173850
06:12:55 <zxtx> I've simplified the code as Bar is much larger and nastier than I want to express
06:13:17 <zxtx> the point being more if I know the type I can easily construct Bar
06:14:36 <mniip> zxtx, that's an invalid instance
06:14:45 <mniip> you can't do that
06:17:50 <zxtx> mniip, so assuming I want to make a monad instance that generates a GADT what's the easiest route
06:18:14 <hpc> "a monad instance that generates a GADT"?
06:18:38 <mniip> what
06:18:44 <hpc> oh, you want to write instance Monad SomeGADT
06:18:45 <Clint> sounds exciting
06:19:09 <zxtx> hpc, yea
06:19:36 <hpc> it's tricky, and if it's even possible depends entirely on what GADT you are writing
06:20:17 <hpc> consider data Foo a where A :: Int -> Foo Bool; B :: a -> Foo a
06:20:29 <hpc> how do you write fmap for that?
06:21:13 <hpc> it's pretty normal if you don't have the A constructor, but then things get weird when you're using fmap with a type that admits it
06:22:03 * hackagebot hw-bits 0.0.0.9 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-bits-0.0.0.9 (haskellworks)
06:22:16 <zxtx> so I can imagine writing a specific fmap for Foo
06:22:42 <hpc> remember it needs to satisfy fmap id = id, but also still work for any a, b
06:23:09 <hpc> so imagine fmap (\b -> if b then "yes" else "no") (A 175)
06:23:42 <hpc> is the result B "yes" or B "no"?
06:24:02 <exio4> I like fmap id as an even weirder example
06:24:05 <hpc> it certainly can't be A
06:24:18 <exio4> fmap id (A 42) 
06:24:41 <hpc> yeah
06:25:13 <hpc> for that, it obviously can't be a B because then is it B False or B True?
06:25:47 <hpc> either one breaks the Functor laws, but having it be A 42 breaks parametricity
06:26:13 <exio4> well, fmap id (A 42) should be (A 42)!
06:26:27 <hpc> you'd never be able to get it to typecheck, and certainly you wouldn't be able to get both that behavior and the yes/no behavior in one definition
06:26:39 <hpc> without type-case of some sort, which is exactly what breaking parametricity is
06:27:03 * hackagebot thentos-cookie-session 0.9.1 - All-in-one session handling for servant-based frontends  https://hackage.haskell.org/package/thentos-cookie-session-0.9.1 (MatthiasFischmann)
06:27:22 <hpc> there's certainly some GADTs for which it's possible to write a Monad instance though
06:27:33 <hpc> and the proof of that is that there is a GADT encoding of IO that goes something like
06:27:49 <hpc> data IO a where GetLine :: IO String; PutStrLn :: String -> IO (); ...
06:28:26 <hpc> and somewhere in there IOBind :: IO a -> (a -> IO b) -> IO b
06:28:32 <zxtx> well for the GADT I have something like Foo won't happen
06:29:34 <hpc> what is the type you're trying to write an instance for?
06:29:49 <hpc> is it Bar from that paste, or something else?
06:30:06 <zxtx> hpc, its basically Bar
06:30:09 <exio4> hpc: is that IO encoding accurate? 
06:30:21 <zxtx> where instead of String we have something like Real
06:30:39 <zxtx> and all the constructors are one to one with the return type
06:32:03 * hackagebot webapi 0.3 - WAI based library for web api  https://hackage.haskell.org/package/webapi-0.3 (ersran9)
06:34:31 <hpc> zxtx: can you lpaste it?
06:36:51 <zxtx> hpc, replace String with Rational, and you basically have the datatype
06:37:01 <zxtx> or should I show more fields of it
06:37:50 <hpc> does it have a way for you to write pure :: a -> Foo a?
06:38:02 <hpc> or is only Foo Rational inhabited?
06:40:07 <zxtx> hpc, if I know the a I can write it
06:40:16 <zxtx> I don't know a way to write something polymorphic in a
06:40:33 <mniip> then you break parametricity
06:41:15 <prohobo> ill polymorphize ur face
06:41:18 <prohobo> sry
06:44:11 <zxtx> assuming I'm ok breaking parametric polymorphism, what's the way to do this
06:45:04 <mniip> err you can't
06:45:59 <hpc> also you are definitely not as okay with it as you think you are
06:46:34 <hpc> those sorts of invariants are there to keep everything making sense
06:46:46 <hpc> breaking them breaks all sorts of assumptions you likely didn't even know you were making
06:47:06 <mniip> oh
06:47:10 <mniip> there is something you can do
06:47:51 <mniip> using the ghc api, in particular RtClosureInpect.cvObtainTerm
06:48:13 <hpc> that's like unsafeCoerce on crack
06:48:16 <mniip> but at that point you're digging in the bytes of the heap
06:48:22 <mniip> you don't want to do this
06:58:50 <Gurkenglas__> How do i turn http://lpaste.net/150858 into a hackage package? Ideally, a command that I can run on a .hs with that lpaste in there to make it so anyone doing stack install pointedalternative and import Control.Alternative.Pointed has access to those combinators
06:59:40 <mauke> start by writing a .cabal file
07:09:47 <Gurkenglas__> *reads https://downloads.haskell.org/~ghc/7.0.4/docs/html/Cabal/authors.html * Like so? http://lpaste.net/173855 Can I use a pseudonym for the author? What license is the most permissive, but will allow me to write academic papers about what I put in there?
07:10:23 <sm> also add a module Control.Alternative.Pointed declaration at the top, and an export list and haddock docs
07:11:35 <mauke> if you're the author, you can choose as many licenses as you want, whenever you want
07:11:38 <Gurkenglas__> (I am concerned that I needed to know that I need to make sure I can use it in academic papers. Is there anything else of that sort I need to know?)
07:11:51 <mauke> licenses are for other people that want permission to use your code
07:11:52 <sm> linking to lpaste as your home page makes me think you may want something lighter, like https://www.reddit.com/r/haskell/comments/4vu9ju/why_does_wai_use_cps/d627m2f
07:12:10 <hpc> specifically, if you are the sole copyright holder
07:12:53 <hpc> contributions from others where they retain copyright make it so you need agreement from anyone who contributed or you need to cut out their code
07:15:21 <Gurkenglas__> (why would making it so being able to say desperately and ascertain and manyLazy in pull requests in random github code be so hard? https://xkcd.com/592/ )
07:16:16 <Gurkenglas__> sm, what do you mean I want something lighter? An easier way to make that code available to everyone, or a lighter webpage to link to, or something?
07:18:26 <sm> Gurkenglas__: I was thinking you just wanted to make your code runnable by others, which can be achieved with a stack hashbang line. But now I think you want more than that
07:18:43 <MichaelK> Hi, does anyone know of a library with per-instance QuickCheck properties? I want to test a couple Bits instances, but I'd rather not reinvent the wheel
07:19:01 <Clint> Gurkenglas__: "MIT" (Expat) is the most permissive of the non-OtherLicense .cabal licenses
07:23:36 <Gurkenglas__> Using the MIT license means I have to use the MIT license in future versions of the library?
07:24:00 <ongy> Gurkenglas__: if you made all of it (or have permission from all contributors) you can change licenses freely
07:24:23 <Gurkenglas__> "The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software."
07:24:31 <ongy> but code once published under a permisive license cannot be "unpublished", so old versions may still float around
07:26:06 <Gurkenglas__> Is that clause needed for me to write papers about the contents? (Because someone could copy it without that license and call it prior art to my paper?)
07:27:09 <ongy> you generally want to apply the license as is, without removing clauses.
07:28:50 <ongy> and if you publish your library somewhere that can be related to you, it should be hard for others to call it prior art to your paper, but I'm not to knowledgeable about that
07:30:38 <mauke> Gurkenglas__: the license is what gives other people permission to copy
07:30:45 <mauke> without a license, they have nothing
07:33:22 <ongy> mauke: afaik that's country related and may default to public domain (or equivalent)
07:33:25 <Gurkenglas__> Maybe this is getting offtopic and you can point me to another channel, but Ive heard that you can't make something public domain and later write a paper about it
07:36:58 <sm> Gurkenglas__: laws vary depending on your country, but eg in the US you can publish something with a copyright message, "all rights reserved" etc., without a license for reuse. That's not public domain, and not reusable either (except for small portions allowed under "fair use")
07:38:41 <sm> though if it communicates useful ideas, people can certainly make use of those
07:38:43 <sdx23> Considering this to be a deutsches Gurkenglas__: It is controversal that it's even possible to make something public domain in Germany.
07:39:07 <mauke> debian told me I couldn't when I tried
07:39:21 <mauke> but it's definitely possible in the US because djb did it
07:40:53 <ongy> but as always: if you need real legal advice, you might want to consult a lawyer
07:42:03 * hackagebot dot 0.2.2 - Data types and encoding for graphviz dot files  https://hackage.haskell.org/package/dot-0.2.2 (andrewthad)
07:47:03 * hackagebot llvm-tf 3.0.3.1.8 - Bindings to the LLVM compiler toolkit using type families.  https://hackage.haskell.org/package/llvm-tf-3.0.3.1.8 (HenningThielemann)
07:52:39 <sbrg> I am trying to use the twitter-conduit package with stack, and the instructions tell me to run (for example)) `cabal run oauth_callback` so that I can retrieve some oauth credentials. This doesn't work. cabal complains about the required packages being missing, even though they are in the cabal file. I figured this may could've been something to do with environment variables, so I tried `stack exec cabal run oauth_callback`, but this
07:52:39 <sbrg> also fails with an error. Any idea what the correct way to go about this with stack would be?
07:53:43 <sbrg> The error is: https://gist.github.com/1dd5f5e6f84169e9a6eaa124dc5f8235
07:55:30 <mgsloan> sbrg: The "cabal" program doesn't directly work with stack.  You probably want "stack exec oauth_callback"
07:56:01 <sbrg> Yeah, forgot to mention I also tried that.  
07:56:07 <sbrg> no such executable is found
07:56:27 <sbrg> I also tried finding it with `find`, no luck. So maybe outdated docks?
07:56:29 <sbrg> docs*
07:56:45 <mgsloan> What's supposed to build that executable?  If it's part of a pkg called "a-pkg", run "stack build a-pkg"
07:56:51 <mgsloan> Could be
07:58:13 <sbrg> hmm, I may have to pass some build flags to the twitter-conduit package. How does one go about doing that with stack?
08:01:43 <mgsloan> --flag twitter-conduit:flag-name
08:02:03 * hackagebot uber 0.1.1.0 - Uber client for Haskell  https://hackage.haskell.org/package/uber-0.1.1.0 (zzat)
08:02:31 <mgsloan> sbrg: I highly recommend the user's guide! https://docs.haskellstack.org/en/stable/GUIDE/#flags-and-ghc-options
08:03:56 <sbrg> Yeah, I managed to figure it out. Modified the yaml file, though. Thanks!
08:10:35 <Shou> Is there a typeclass containing only an empty value, like Monoid, but without the operator, or associativity?
08:10:54 <Shou> An existing one.
08:12:13 <glguy> Shou: The closest thing to that is http://hackage.haskell.org/package/data-default-0.7.1.1/docs/Data-Default.html
08:12:32 <glguy> But without any other operations or guidelines about what an "empty" value it it isn't useful generically
08:12:44 <glguy> It just allows you to reuse the same name
08:13:24 <thomasfuston> Hello, are there a good recommended way to learn haskell? (i am usually using pyhton)
08:13:29 <alercah> Pointed
08:14:20 <glguy> Pointed is similar but has a different kind than Monoid and Default
08:14:24 <glguy> and has the same limitations
08:14:33 <mauke> Default is lawless
08:14:55 <glguy> so is Pointed
08:17:35 <ertesx> it seems that hutton's book is out
08:18:27 <glguy> thomasfuston: This is the link for the book ertesx mentioned http://www.cs.nott.ac.uk/~pszgmh/pih.html
08:19:26 <glguy> ertesx: The 2nd edition appears to still be in pre-order, but is also listed as coming this month
08:22:30 <fragamus> hi im trying to do something like this:
08:22:32 <fragamus> [Maybe (Monoid)]->Maybe Monoid
08:22:48 <mauke> in what way?
08:22:57 <glguy> fragamus: Also remember that Monoid isn't a type
08:23:03 <ertes> fragamus: do you mean ((Monoid a) => [Maybe a] -> Maybe a)?
08:23:04 <fragamus> whatever
08:23:18 <fragamus> i wrote a monoid 
08:23:23 <fragamus> instance
08:23:44 <glguy> mconcat :: Monoid a => [a] -> a
08:23:44 <fragamus> yeah
08:23:56 <nshepperd_> I think that's just mconcat
08:24:10 <glguy> but that depends on what you wanted it to do for Just and Nothing
08:24:15 <fragamus> ((Monoid a) => [Maybe a] -> Maybe a)
08:24:40 <ertes> fragamus: what semantics would you like it to have?  there are many functions of that type
08:24:42 <fragamus> I want it to mappend as it goes and abort if it encounters a nothing
08:24:46 <Clint> > mconcat [Just 3, Nothing, Just 7]
08:24:48 <lambdabot>      No instance for (Show a0)
08:24:48 <lambdabot>        arising from a use of ‘show_M91283872734057964856017’
08:24:48 <lambdabot>      The type variable ‘a0’ is ambiguous
08:24:52 * Clint sighs.
08:24:57 <ertes> fragamus: abort with a Just or with a Nothing?
08:25:03 <fragamus> Nothing
08:25:17 <ertes> fragamus: and if all are Just, then combine everything?
08:25:20 <glguy> sequence :: [Maybe a] -> Maybe [a], and mconcat :: [a] -> a
08:25:23 <fragamus> yes
08:25:30 <fragamus> but 
08:25:45 <fragamus> i am trying to actually do a fold here
08:26:17 <mauke> why?
08:26:24 <ertes> fragamus: to collapse the list of Maybes to a single Maybe, first use 'sequence'…  then if you get a Just, you can use a fold
08:26:27 <fragamus> ok lets zoom out
08:26:31 <ertes> fragamus: note that mconcat is a fold
08:27:00 <fragamus> i am working on a game that uses minimax theorem - but there is an optimization that allows for pruning the game tree
08:27:33 <fragamus> so when a node is exploring the nodes below it, it can come to the realization that none of what it is doing is viable
08:27:50 <fragamus> at that point it must abort (prune)
08:28:04 <fragamus> here I'll paste the current version
08:28:29 <mauke> so far everything is compatible with sequence/mconcat
08:29:03 <ertes> fragamus: wouldn't just ignoring those branches be enough?  descend, and if you find that the branch isn't worthwhile, just don't go deeper
08:29:04 <lpaste> fragamus pasted “Non-pruning ” at http://lpaste.net/173867
08:30:04 <fragamus> well I'd like to use a fold because there is state that is updated
08:31:19 <ertes> those two things are really orthogonal…  since haskell is lazy, there is usually no need to "prune" semantically, but just not descent along certain branches
08:32:39 <fragamus> can you see why i like the foldr there in the code
08:33:38 <fragamus> the realization to prune occurs during that fold
08:33:53 <fragamus> when the alpha exceeds the beta
08:35:53 <Morgawr> how can I use guards to match on a record type?
08:36:12 <Morgawr> Like I have something similar to this: data TestRecord = TestRecord { string :: String } | TestRecord' { string :: String }
08:36:21 <glguy> Morgawr: You don't. You can use a pattern though like this:
08:36:41 <glguy> case x of TestRecord { string = x } -> y ; TestRecord' { string = x } -> z
08:37:01 <mauke> yz (string x)
08:37:03 <Morgawr> But I don't care what's inside the TestRecord
08:37:03 <Shou> glguy: thanks, it seems to be used consistently but you're right that since there are no laws it can be aberrant.
08:37:14 <Morgawr> I just want to check if it's TestRecord or TestRecord'
08:37:32 <glguy> Morgawr: OK, you can use the pattern:   TestRecord{}
08:37:34 <mauke> Morgawr: case x of TestRecord{} -> ...; TestRecord'{} -> ...
08:38:09 <Morgawr> What if I have TestRecord, TestRecord' and TestRecord'' and I want to check if x is either TestRecord or TestRecord', otherwise do something else?
08:38:12 <Morgawr> Can I use or?
08:38:35 <Morgawr> case x of TestRecord{} or TestRecord'{} -> ...; would this work?
08:38:58 <mauke> no
08:38:59 <glguy> No, there's no "or" syntax
08:39:07 <Morgawr> But that's what I need... :/
08:39:13 * Morgawr scratches head
08:39:29 <mauke> case x of TestRecord{} -> stuff; TestRecord'{} -> stuff; _ -> ...
08:39:32 <mauke> where stuff = ...
08:40:14 <Morgawr> mauke: Repeating things is what I wanted to avoid...
08:40:24 <alercah> Morgawr: you could make an auxiliary function like "isGoodThing : TestRecord -> Bool" and guard on that
08:40:56 <leftbeefonly> is there any way to extract type information in a typeclass instance's function definition without directly referencing it on the lhs of the function?
08:41:07 <Morgawr> The problem is that I have a huge set of possible values a record can have (it's kind-of like a CPU matching on opcodes) and for some specific opcode/case I want to have the same outcome.
08:41:19 <alercah> leftbeefonly: I don't think so, but could you maybe give an example of what you mean?
08:41:39 <alercah> Morgawr: or write an auxiliary function
08:42:01 <Morgawr> That sounds excessively verbose though..
08:42:02 <alercah> case x of TestRecord {} -> foo; TestRecord' {} -> foo; TestRecord'' -> bar
08:42:12 <fragamus> ertes you said    "to collapse the list of Maybes to a single Maybe, first use 'sequence'…  then if you get a Just, you can use a fold"       but I think that would generate all the elements of the list without the part of the list that comes after the first Nothing
08:42:34 <fragamus> *without pruning the part*
08:42:44 <alercah> fragamus: concatMaybes?
08:42:53 <leftbeefonly> alercah: sure. the type looks something like `data Thing a = Thing Int` and the typeclass has a function signature of something like `doSomething :: Ptr (Container a) -> Whatever`
08:43:00 <byorgey> fragamus: you want to take all the Justs up until the first Nothing?
08:43:10 <fragamus> yes
08:43:12 <mauke> Morgawr: the only repetition in my code is the identifier "stuff"
08:43:18 <alercah> fragamus: takeWhile isJust
08:43:20 <byorgey> fragamus: catMaybes . takeWhile isJust
08:43:22 <mauke> that's a constant overhead of 5 characters
08:43:29 <dmj`> > takeWhile isJust [Just 1, Nothing]
08:43:33 <lambdabot>  [Just 1]
08:43:39 <alercah> Morgawr: Then write a test function and guard on it
08:44:11 <dmj`> > [ x | Just x <- takeWhile isJust [Just 1, Nothing] ]
08:44:13 <lambdabot>  [1]
08:44:30 <Morgawr> Well, since the way I wanted it implemented is not possible, I guess it's no use to complain :) thanks for the help guys I'll think about it a bit more and then decide what to do
08:44:38 <leftbeefonly> alercah: the problem i'm facing is that i can't seem to expand the type like `Ptr (Container (Thing a)))` on the lhs of the function because Foreign.Ptr doesn't have a data constructor
08:45:08 <alercah> leftbeefonly: Ah I see.
08:45:21 <alercah> leftbeefonly: You must give GHC some way to infer the type, yeah
08:45:28 <alercah> there's a bit of a hack you can do
08:45:36 <fragamus> that's very nice, but I need a fold, because there is state that is updated each time an element is encountered
08:45:44 <alercah> change the function type to Proxy a -> Ptr (Container a) -> Whatever
08:45:51 <dolio> > foldr (maybe (const []) (:)) [] [Just 1, Just 2, Nothing, Just 3]
08:45:53 <lambdabot>  [1,2]
08:45:53 <alercah> then you pass Proxy :: Proxy a as the first argument
08:46:02 <alercah> it's a phantom which doesn't carry any data, but forces the type inference
08:46:43 <leftbeefonly> ah dang, i like that solution, but i'm adding functionality to an existing library. not sure if i'll be able to change the signature of that function
08:46:47 <mauke> leftbeefonly: are you a pizza?
08:47:38 <leftbeefonly> mauke: ha, didn't think anyone knew what that reference was
08:48:28 <alercah> leftbeefonly: if you don't have a Ptr, how are you going to invoke the function at all?
08:52:50 <leftbeefonly> alercah: there's a Ptr, but the FFI stuff is kind of strange
08:54:14 <leftbeefonly> probably just something i'm not grokking with it, but it seems gross to do something like `peek $ unwrap $ unwrap ptr`
08:54:25 <alercah> leftbeefonly: but don't you need to pass in a Ptr?
08:54:52 <leftbeefonly> alercah: yeah, that's the only argument
08:55:07 <alercah> leftbeefonly: so how can you use the function if you don't have one?
08:56:26 <leftbeefonly> alercah: i'm lost. sorry
08:57:03 * hackagebot servant-auth-token-api 0.1.1.0 - Servant based API for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-api-0.1.1.0 (NCrashed)
08:59:00 <leftbeefonly> alercah: the typeclass defines the function signature as so: `doSomething :: Ptr (Container a) -> IO ()` where a is the type that is going to instance the typeclass
09:00:30 <alercah> leftbeefonly: Right. So how do you propose to use the function if you don't have a Ptr (Container a)?
09:00:45 <leftbeefonly> alercah: what i tried was `instance Blah (Thing a) where ... doSomething Ptr (Container (Thing a)) = extern_func_call (Ptr (Container (Thing a))) a`
09:01:11 <alercah> leftbeefonly: can you make a compileable example?
09:01:33 <leftbeefonly> alercah: i do have one, but i'm not supplying it, another function that's already defined is
09:02:26 <leftbeefonly> alercah: yeah, the problem comes with expanding the description of that Ptr type. the compilable one looks like `doSomething ptr = extern_func_call ptr 12345`
09:03:09 <leftbeefonly> alercah: my attempt was to encode that 12345 into the type `data Thing a = Thing Int`
09:03:44 <pchiusano> if I have `module Foo (module Bar.Qux, module Bar.Quaffle, ...) where`, does that reexport typeclass instancess in the exported modules?
09:03:55 <mauke> leftbeefonly: I don't understand what you're trying to do there
09:04:10 <glguy> pchiusano: instances are reexported always
09:04:15 <pchiusano> as in suppose Bar.Qux has a `Binary MyType` inside
09:04:31 <glguy> pchiusano: even with an empty export list, all the instances are exported
09:04:59 <pchiusano> glguy: I'm not sure that is what I am asking
09:05:16 <mauke> leftbeefonly: how is Container defined?
09:05:43 <pchiusano> glguy: if Bar.Qux as a `Binary MyType` in it, does that mean that `import Foo ()` will also bring that `Binary MyType` into scope
09:06:23 <pchiusano> assuming the `module Foo (module Bar.Qux, module Bar.Quaffle, ...) where` declaration for `Foo`
09:06:43 <leftbeefonly> mauke: it's something like `newtype Container a = Container Bytes` with some deriving
09:07:14 <mauke> is there even an 'a' in there?
09:07:50 <leftbeefonly> mauke: no, the type i'm defining derives some things to make it compatible
09:07:54 <pchiusano> because I get a warning with that export list - `module Bar.Qux exports nothing`, which is true, except that it does export a typeclass instance
09:08:28 <glguy> pchiusano: You don't need to list Bar.Qux in your export list if you're just trying to export its instances
09:08:45 <glguy> and when you import that module you can import it with an empty import list to indicate that you're *only* importing it for its instances
09:09:22 <Gurkenglas__> :t foldr (\x y -> ((:) <$> x <*> y) <|> pure []) (pure [])
09:09:23 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f [a]
09:09:33 <leftbeefonly> mauke: what i'm trying to do is encode more information into that Thing type and extract it in the implementation of doSomething
09:09:59 <mauke> when you say "type", do you really mean type?
09:10:05 <pchiusano> glguy: okay, I have say 10 modules with instances in them (and only instances), and I'd like to create a single module that I can import which gives me all these instances
09:10:16 <pchiusano> how do I do that without getting warnings
09:10:24 <glguy> empty export lists
09:10:27 <glguy> import Module ()
09:10:33 <glguy> module MyModule ()
09:11:01 <pchiusano> glguy: can you spell it out some more
09:11:11 <Gurkenglas__> (That one loses the information that the f [a] returned is not empty, see pointedalternative)
09:11:13 <glguy> Which part are you stuck on?
09:11:16 <leftbeefonly> mauke: what are you interpreting it as?
09:11:34 <pchiusano> what are the 10 modules with instances in them, and what does the one module look like
09:11:38 <glguy> module BunchOfInstances () where import SomeInstances (); import OtherInstances ();
09:11:44 <pchiusano> that reexports all their instances
09:11:51 <leftbeefonly> mauke: does `data Thing a = Thing Int` not represent a type?
09:12:03 * hackagebot servant-auth-token-api 0.1.2.0 - Servant based API for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-api-0.1.2.0 (NCrashed)
09:12:25 <pchiusano> ah, glguy so you are saying that simply _importing_ the instances is enough to reexport them
09:12:28 <glguy> Yeah
09:12:37 <pchiusano> okay, I did not understand that
09:12:52 <pchiusano> thank you!
09:14:30 <mauke> leftbeefonly: the 'Thing a' part is a type, the 'Thing Int' part is a value
09:14:36 <glguy> pchiusano: You're welcome.
09:14:38 <mauke> the number is not encoded in the type
09:14:52 <dmj`> If I make an IsString instance for UUID can I throw a compiler error on a parse failure in the instance
09:16:05 <dmj`> I bet it would be possible to make a type level UUID parser
09:17:03 * hackagebot llvm-tf 3.0.3.1.9 - Bindings to the LLVM compiler toolkit using type families.  https://hackage.haskell.org/package/llvm-tf-3.0.3.1.9 (HenningThielemann)
09:17:05 <leftbeefonly> mauke: ok, so semantics aside, what i want is to get at `Thing a`'s `a` in the typeclass instancing of `Thing a`, specifically in the implementation of doSomething
09:17:21 <zcourts> From the Haskell 2010 spec I see `gdrhs	→	guards = exp [gdrhs]`, can someone give me an example of how the optional gdrhs on the end might be used?
09:19:18 <leftbeefonly> mauke: but expanding the lhs to be specific like `doSomething Ptr (Container (Thing a)) = extern_func_call (Ptr (Container (Thing a))) a` doesn't work and `peek`ing into the Ptr and unwrapping the values seems unnecessarily involved
09:19:44 <mauke> that doesn't expand the LHS
09:19:59 <mauke> that's all just data
09:20:08 <mauke> i.e. the type-level stuff is not involved
09:21:01 <glguy> zcourts: x | a = b | c = d
09:21:10 <leftbeefonly> so what you're saying is the introspection into the value *is* necessary?
09:21:45 <matrium> hi, is there some kind of scan that collects 'n' elements from the stream?
09:21:56 <matrium> and returns a list of 4-tupels
09:22:03 * hackagebot hans 3.0.0.1 - Network Stack  https://hackage.haskell.org/package/hans-3.0.0.1 (TrevorElliott)
09:22:03 <matrium> *n-tupels
09:22:06 <fsestini> guys, do you know if Agda has something like haskell's Data.Set in its library?
09:22:51 <glguy> fsestini: Have you asked in #agda yet?
09:23:07 <mauke> leftbeefonly: if you want to get an Int out, yes, because your type doesn't contain one
09:23:19 <fsestini> glguy, nope, that seems like a good idea
09:25:35 <leftbeefonly> mauke: thanks
09:28:36 <ertes> is there (Anything :: * -> Constraint), a non-constraint that doesn't insist on being fully applied?
09:29:31 <zcourts_> §
09:29:31 <zcourts_> \
09:29:32 <zcourts_> \]
09:29:34 <zcourts_> \]
09:29:36 <zcourts_> \]
09:31:43 <mauke> ertes: huh?
09:34:20 <glguy> ertes: You're looking for some True or False :: * -> Constraint that could be used as an argument to a data type in a position with kind * -> Constraint?
09:35:16 <glguy> data D c = forall a. c a => C a    maybe as a non-constraint in something like this?
09:36:47 <mauke> :k (~) ()
09:36:48 <lambdabot> * -> Constraint
09:37:22 <glguy> something like: class AllTypes a; instance AllTypes a
09:43:25 <ongy> what's :k?
09:43:35 <hpc> kind
09:43:44 <hpc> it's like asking the type of a type
09:43:50 <hpc> (in fact it's exactly like that)
09:50:34 <ongy> :k Show a
09:50:36 <lambdabot> Not in scope: type variable ‘a’
09:50:39 <ongy> :k Show a =>
09:50:41 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
09:50:55 <ongy> looks like I'm doing it wrong
09:52:07 <Shou> :k Show
09:52:08 <lambdabot> * -> Constraint
09:56:27 <glguy> :k forall a. Show a
09:56:28 <lambdabot> Constraint
09:56:43 <glguy> If you want to use some type variables, you have to declare them
09:56:50 <dmj`> does anyone know where the type level Char proposal is
09:57:23 <dmj`> ah nvm, https://ghc.haskell.org/trac/ghc/ticket/11342
10:08:19 <ongy> type level Char? sound like fun with unicode support
10:08:19 <ertes> glguy: exactly
10:08:43 <zcourts> Thanks glguy makes sense! My keyboard and internet went a bit crazy after I asked.
10:08:44 <ertes> glguy: i thought of using Typeable, but that has an unnecessary cost
10:10:06 <Zemyla> You know what I really with Data.Map had?
10:10:21 <ertes> i'll probably just write a separate type
10:12:16 <Zemyla> traverseMergeWithKey :: (Ord k, Applicative f) => (k -> a -> b -> f (Maybe c)) -> (Map k a -> f (Map k c)) -> (Map k b -> f (Map k c)) -> Map k a -> Map k b -> f (Map k c).
10:13:48 <glguy> ertes: Yeah, I asked Iavor about Typeable, it seemed like it would work, but it's certainly not portable and the constraint could only discharge once the type was actually known
10:14:33 <ertes> let me just explain my problem with more context:  newtype T m a b = T (a -> m (b, T m a b))  -- i'm rewriting this type to an equivalent representation that gives me access to the "current state" as a value:  data T m a b = forall s. T s (s -> a -> m (s, b))
10:14:59 <ertes> now that the state has a type, i can give it a context in order to store multiple of those "current states" in an unboxed vector
10:15:17 <ertes> data T c m a b = forall s. (c s) => T s (s -> a -> m (s, b))
10:16:43 <ertes> of course if there were a way to do that with the original version, that would be awesome, but then i'd basically be asking to serialise closures efficiently
10:16:50 <eklavya> glguy: I have incorporated auto instance derivation here https://github.com/eklavya/hascas/blob/master/src/Derive.hs
10:17:06 <eklavya> please tell me if you think I could do it better in some way
10:17:19 <eklavya> if you have time :P
10:18:38 <glguy> eklavya: Instead of using mkName for names like runGet and Get you should use 'runGet and ''Get so that your derived code isn't dependent upon the names in scope at the time of using the deriver
10:19:22 <eklavya> dependent upon the names in scope?
10:19:33 <glguy> eklavya: Instead of using mkName for the name of your pattern variable in fromRow you should use newName
10:20:05 <glguy> eklavya: Using mkName you're requiring the user of deriveBuildRec to import Data.Binary, and Data.Map.Strict
10:20:06 <eklavya> but that name needs to be the same as the one used in the lookup
10:20:16 <eklavya> it came out different and it was not working
10:20:29 <glguy> eklavya: You'll use a single mName <- newName "m"
10:20:39 <glguy> but then you'll pass that mName to both use sites
10:21:20 <glguy> eklavya: I don't quite understand why you're having to pattern-match apart these InstanaceD and Clause
10:21:32 <eklavya> for this very reason :P
10:21:38 <eklavya> m was different :D
10:21:46 <glguy> Well, when you're done you shouldn't need to do that
10:21:52 <eklavya> yeah
10:22:04 * hackagebot servant-auth-token 0.1.0.0 - Servant based API and server for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-0.1.0.0 (NCrashed)
10:22:11 <glguy> Avoid these irrefutable patterns like: let (RecC conName args) = head constructors
10:22:43 <eklavya> what does that (irrefutable patterns) mean?
10:22:51 <glguy> better to case constructors of [RecC conName args] -> return (conName,args); _ -> fail "deriveBuildRec: expeted single record constructor"
10:23:35 <eklavya> yeah that too
10:23:44 <eklavya> right now it will fail for just about everything else
10:23:54 <dfeuer> Thinking back on the intersection strictness issue: the laziness only helps foldr if one of the list elements is empty.
10:24:22 <dfeuer> It does no good whatsoever if some intermediate intersection is empty.
10:25:01 <eklavya> glguy: how to avoid "Using mkName you're requiring the user of deriveBuildRec to import Data.Binary, and Data.Map.Strict" ?
10:25:03 <dmwit> > foldr S.intersection undefined [S.singleton 3, S.singleton 4]
10:25:04 <lambdabot>  fromList *Exception: Prelude.undefined
10:25:24 <fragamus> http://lpaste.net/173867
10:25:29 <dmwit> bummer!
10:25:33 <dfeuer> Yeah.
10:25:40 <ertes> dfeuer: yesterday i was bit by the lazy Traversable instance of IntMap…  perhaps it would be useful to have separate types for lazy and strict data structures, or at least to make the instances strict
10:25:56 <dfeuer> You need a strict left fold I think.
10:25:59 <dmwit> > foldl S.intersection (S.singleton 3) (S.singleton 4:undefined)
10:26:01 <lambdabot>  fromList *Exception: Prelude.undefined
10:26:09 <glguy> eklavya: That's the '' notation for types and ' for value names
10:26:19 <dmwit> ?src foldl
10:26:20 <lambdabot> foldl f z []     = z
10:26:20 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:26:26 <glguy> eklavya: e.g. ''Get :: Language.Haskell.TH.Syntax.Name
10:26:36 <glguy> 'runGet :: Language.Haskell.TH.Syntax.Name
10:26:38 <dfeuer> ertes, unfortunately, that won't change for those modules. However, Wren Romano and I are both interested in potentially adding new modules to containers that could offer somewhat different APIs.
10:26:42 <dmwit> > foldl S.intersection (S.singleton 3) [S.singleton 4,undefined]
10:26:43 <lambdabot>  fromList []
10:27:01 <eklavya> glguy: and that will automatically error out on missing imports?
10:27:02 <dfeuer> ertes, also, a strict version of traverse doesn't really obey the Traversable laws.
10:27:24 <dfeuer> So a truly strict type doesn't get Functor or Traversable instances.
10:27:40 <ertes> dfeuer: even in the fast and loose sense?
10:27:54 <dfeuer> ertes, fast and loose, of course!
10:28:12 <ertes> as in: it's a proper functor, if you ignore bottoms
10:28:37 <dfeuer> ertes, well, yes.
10:29:16 <glguy> eklavya: No, that will avoid having to worry about imports
10:29:27 <dfeuer> But fmap (f . g) might be more defined than fmap f . fmap g
10:29:51 <dfeuer> Arguably that might be okay.
10:29:58 <eklavya> glguy: I don't understand, if the call site doesn't have Data.Binary, how will referencing ''Get work?
10:30:09 <glguy> it will work great
10:30:19 <danilo2> Right now (with such declaration) the result is still polymorphic and we have to tell GHC that we want the one with kind *
10:32:11 <eklavya> :D
10:32:15 <eklavya> glguy: how?
10:32:39 <mniip> glguy, heya
10:32:46 <glguy> Because the names were already resolved when deriveWhatever was compiled
10:32:51 <mniip> mind a PM
10:32:57 <glguy> so they don't have to be reresolved when deriveWhatever is used
10:33:08 <mnoonan> I want to do a little project to learn some template haskell, and had an idea. Looking for feedback. The idea is:
10:33:34 <mnoonan> automatically generate F-algebras and friendly patterns from a base functor
10:33:37 <glguy> mniip: No, I don't mind.
10:34:12 <JuanDaugherty> mnoonan, sounds grandiose for just learning, maybe just do a programmery thing
10:34:19 <ertes> dfeuer: i see what you mean…  practically speaking i wouldn't mind any way to have a strict 'traverse' with a single traversal
10:34:21 <JuanDaugherty> since it's a programmery feature
10:35:04 <mnoonan> e.g. you write "data ListF a e = Nil | Cons a e" and then makeFAlgebra ''ListF, and "type List a = Fix (ListF a (List a))" comes out the other end, along with "pattern Nil = NilF" etc
10:35:11 <mnoonan> oops, meant NilF / ConsF in ListF
10:35:37 <mnoonan> that *is* a programmery thing, I've had to write that code a few times already :|
10:35:48 <ertes> dfeuer: of course it would be most useful as part of Traversable, but doesn't have to be
10:36:13 <lpaste> fragamus revised “Non-pruning ”: “Non-pruning ” at http://lpaste.net/173867
10:36:41 <mnoonan> ergh, "pattern Nil = Fix NilF" and "pattern Cons x xs = Fix (ConsF x xs)"
10:36:48 <dfeuer> ertes, if the new modules happen, the debate will surely rage.
10:36:57 <eklavya> glguy: oh yeah, I remember now, if I don't hard place "m", I will need to change the whole instance declaration to AST, I wanted to do it as less often as I could
10:37:13 <dfeuer> glguy, what do you think about Functor and Traversable instances for strict containers?
10:37:18 <eklavya> I won't be able to use [d| |] at all if I don;'t do it
10:37:43 <glguy> eklavya: then define fromRow = \m -> ...
10:37:50 <glguy> and have your expression use a lambda to getthat m
10:37:57 <glguy> and you can use your [d| syntax
10:38:27 <glguy> eklavya: Even if you do it the way you're doing it you can still switch to newName
10:38:31 <danilo2> Hello guys! :) Is there any way in GHC to make a type family, which will infer the output kind based on the input types? I want for example to have `type family Foo (a :: k) (b :: l) :: m` and be sure that if there is instance for `type instance Foo Int Char = Int` then if GHC infers in some use case `a` to be `Int` and `b` to be Char it will infer the result as well ?
10:39:20 <eklavya> glguy: how? as soon as I do a fromRow $(varP mName) I lose [d| |]
10:40:11 <glguy> eklavya: no, you end up with   formRow = $(lamE1 .... 
10:40:26 <eklavya> uhh
10:40:31 <eklavya> let me try that
10:42:44 <dmj`> danilo2: you can vary the kind based on the type using PolyKinds
10:44:41 <fragamus> byorgey could you have a look at my revised paste
10:45:14 <lambdafan> should it be possible to auto-generate a Serial instance for Vector3?
10:45:42 <eklavya> glguy: btw why is it important to not hardcode this "m", it's local to our generated function anyway?
10:47:52 <dfeuer> dmj`, as far as I can see, GHC won't reduce the family until something else tells it what the result kind should be.
10:54:55 <dfeuer> Actually, it *is* possible in GHC 8.
10:54:56 <dfeuer> Huh.
10:56:00 <dfeuer> You can calculate a kind from a type with a type family, and use that kind in the signature of another type family.
10:56:16 <glguy> eklavya: You can generate shadowing warnings when you hardcode pattern names into your generated template haskell
10:56:32 <glguy> which is annoying for users. 'm' is probably not a common top-level name but it's a good idea to avoid this
10:56:50 * dfeuer just installed GHC 8 and hasn't had the chance to play with TypeInType too much yet.
10:57:02 <eklavya> glguy: understood
10:57:04 <glguy> there are other cases where you can refer to an unintended name using mkName
10:57:36 <eklavya> so newName unless there is a good reason
10:57:44 <eklavya> which is not often
10:58:33 <glguy> Yeah, newName for new names, mkName for capturing external names by what's in scope
10:58:46 <glguy> ''names for resolving names to fixed existing things
10:58:56 * dfeuer is definitely looking forward to playing with TypeInType, however. Type-level sorted lists....
10:58:56 <eto`> How do people feel about the mildly wacky idea of never having "pure" functions and instead always being in the `Identity` monad? The goal would be to reduce switching costs (`(.)` to `(<=<)` etc) when/if you do need to introduce monadic capabilities to a formerly pure area. What are the downsides?
10:59:02 <danilo2> dmj`: Hmm Im using PolyKinds, because without PolyKinds my example would not even compile. I dont want to vary the types. I want to have the output kind infered based on input types. I dont want to be able to define `type instance Foo Int Int = Int; type instance Foo Int Int = 7`, while currently its possible
10:59:09 <dfeuer> eto`, that sounds awful.
10:59:24 <dfeuer> danilo2, you need GHC 8 with TypeInType.
10:59:43 <eto`> dfeuer: Why?
11:00:07 <dfeuer> danilo2, you can then make a type family that takes a type and gives you a kind, and another type family whose kind signature uses the first type family. At least, that's the way I found.
11:00:08 <joe9> Is this a good way to add a CRLF terminator to a bytestring? (\s -> (concat [s,"\r\n"]) :: L.ByteString)
11:00:50 <glguy> for combining two bytestrings you can use Monoid's <> operator, or bytestring's append function
11:01:49 <dfeuer> eto`, there's a principle of least power. Use the least powerful tool that gets the job done. It's also a lot harder to see what's going on if you're wrapping and unwrapping every single thing every time. And so on.
11:02:03 * hackagebot servant-aeson-specs 0.4 - generic tests for aeson serialization in servant  https://hackage.haskell.org/package/servant-aeson-specs-0.4 (SoenkeHahn)
11:02:08 <suzu> Identity won't give you any gains
11:02:11 <dolio> eto`: The problem with potentially effectful functions is that they are just as bad as actually effectful functions with respect to equivalences of implementation.
11:02:38 <joe9> glguy, Thanks.
11:02:39 <eto`> `Identity` is clearly not effectful though. It doesn't violate the principle of least power?
11:04:09 <dfeuer> eto`, the trouble is that a function implemented for Identity only gets interesting when you generalize it to m, for any Monad m. You can only do this if the function doesn't care what monad it's in. So then you have to be very careful to write it so it really doesn't care..... What dolio said.
11:04:21 <danilo2> dfeuer: hmm I see it would work, but it is very very verbose- I have to define the kinds manually for every type. There is easier solution currently - just output everything as Proxy, then the "thing" in Proxy will have kind infered based on the usage of type family without the need of manual instances, but its a bit ugly
11:04:31 <eklavya> glguy: thank you so much for your time and feedback :)
11:05:25 <dfeuer> danilo2, I've only *just* started playing with GHC 8, and my experience with kind class tricks is *extremely* limited.
11:05:53 <glguy> eklavya: You're welcome
11:06:04 <dfeuer> danilo2, I wonder if there's a way to write one type family to do both. One sec.
11:06:17 <dfeuer> er .... Hrm.....
11:06:39 <eto`> I don't really want to generalize it to `m` though. It's really just a kind of hacky way to ensure that a semantic transform (eg. from `Identity` to `Reader Int`) doesn't entail a syntactic transform. (Because we're always using monadic composition, etc.)
11:07:28 <dolio> Everything has to be generalized to m, or else you have to do a syntactic transform anyway.
11:09:27 <dolio> You gave an example, even. (.) has to have the type of (<=<).
11:10:40 <eto`> I'm suggesting that you'd use `(<=<)` from the start to compose all your `a -> Identity b` functions?
11:11:27 <edwardk> eto`: So now you have a -> Identity (b -> Identity c) -- currying to pass multiple arguments goes to crap.
11:11:30 <dolio> Yes, and all the functions like (<=<) are worse than their pure versions.
11:11:44 <dolio> Except (<=<), really. That only has one implementation.
11:12:06 <dolio> But many other functions have two or more distinct implementations, and now the choice matters.
11:12:34 <dolio> So you have to worry about more things all the time.
11:13:43 <danilo2> dfeuer: I doubt so, because it will require overlapping type families, which is just not available. Or do you have any other idea?
11:14:14 <edwardk> eto`: One nice thing about the existing system is that when you go to, say, implement Functor today there is exactly one legal definition for any given type. Once you start plumbing effects through "for free", that ceases to be true. Many constructions cease to be canonical. So if you generalize over 'm' all the time, then the machinery we use to pick out
11:14:15 <edwardk> fmap from the space of all possible fmaps ceases to be the only right thng to do. On the other hand using Identity as a fixed thing introduces a metric crapton of newtype noise, and after all what is the type of runIdentity? How do you peel those layers off
11:14:29 <dfeuer> danilo2, yes, I have another idea, but I don't know if it will work.
11:14:39 <dolio> Or you have to revisit all your decisions that didn't matter when you were using Identity, but now they do matter. But the compiler will not tell you where they are, because you preemptively wrote them such that there would be no errors when switching.
11:15:05 <dfeuer> danilo2, the question is whether you can make something like a type-level sigma, packaging the type with its kind, and then find a way to unpack it....
11:15:06 <danilo2> dfeuer: Ok, I'll wait for any further info. Thank you for helping out with it! :)
11:15:15 <dfeuer> Don't know if this can work.
11:15:29 <fr33domlover> Why would you write " instance (key ~ Text, val ~ Text) => RedirectUrl master (Route master, [(key, val)]) where" instead of just using [(Text, Text)] there at the end?
11:15:35 <edwardk> The downside is you have to switch notation, but given that the monadic notation kinda sucks, I personally wouldn't want to live there all the time =P
11:15:47 <danilo2> dfeuer: Ok I see it, so you can define types with kind infomration and use one type family instead of two
11:15:49 <dolio> Yeah, that too.
11:16:01 <dfeuer> danilo2, maybe. I don't know if it can actually work or not.
11:16:15 <danilo2> dfeuer: still it requires packing all types with their kinds which is more cumbersome for the user than using just Proxy, but you are right, it should work
11:16:17 <fr33domlover> (tbh maybe I don't understand what ~ does there)
11:17:03 <dfeuer> danilo2, I still haven't figured out how :/
11:17:03 * hackagebot servant-matrix-param 0.1.0.1 - Matrix parameter combinator for servant  https://hackage.haskell.org/package/servant-matrix-param-0.1.0.1 (SoenkeHahn)
11:17:38 <matrium> hi, how to read a Char from an ascii encoded Word8? I only found bytesToString :: [Word8] -> String on hoogle
11:18:08 <nitrix> Hi, can I group constraints into a single name? Some kind of constraintsynonym or type class synonym system?
11:18:25 <nitrix> Or do I have to introduce a new type class with a dummy method that does `id` ?
11:18:32 <dolio> fr33domlover: 'instance Foo (T A)' matches when the type checker can prove that you have exactly 'T A'. 'instance (x ~ A) => Foo (T x)' matches whenever the outermost type constructor is T, and adds information that its argument must be A.
11:18:40 <nitrix> class (Typeable a, ToJSON a, FromJSON a) => Linked a where
11:19:06 <Shou> nitrix: type C a = (Monoid a, Functor a)
11:19:07 <eto`> dfeuer: edwardk: Thanks!
11:19:13 <Shou> Is that what you mean?
11:19:24 <eto`> dolio: Thanks!
11:19:30 <dolio> No problem.
11:19:39 <nitrix> Shou: Almost, this introduces a type `C` right ?
11:19:52 <Shou> It's a type synonym for those two constraints
11:20:12 <nitrix> @let type C a = (Monoid a, Functor a)
11:20:13 <lambdabot>  .L.hs:168:31:
11:20:14 <lambdabot>      The first argument of ‘Functor’ should have kind ‘* -> *’,
11:20:14 <lambdabot>        but ‘a’ has kind ‘*’
11:20:27 <fr33domlover> dolio, thanks :)
11:20:40 <Shou> nitrix: You need LANGUAGE ContraintKinds
11:20:51 <dolio> fr33domlover: So, the first one is 'if t = TA then ...' and the second is 'if t = T x then (conclude x = A ; ...)'
11:21:01 <Shou> Also oops shouldn't have used Functor there lol
11:22:00 <nitrix> Shou: Essentially, I have user functions getting soiled by my numerous constraints when they use functions of my library.
11:22:21 <ExcaliburZero> matrium: I think I had to do a similar thing. Let me do some looking around and I might be able to help you.
11:22:33 <nitrix> Shou: I'm trying to regroup the constraint into a single one to make it more manageable and encapsulate a little.
11:24:36 <Shou> It sounds like you can use ConstraintKinds and type synonyms for that. Use it like a normal constraint after defined, e.g. `f :: C a => a -> ...` and a will be constrained by all constraints within C.
11:25:37 <ExcaliburZero> matrium: Looking at the source code for the bytesToString function, you can convert a Word8 into a Char by using (chr . fromIntegral) where chr is imported from Data.Char. 
11:25:38 <ExcaliburZero> https://hackage.haskell.org/package/template-haskell-2.11.0.0/docs/src/Language.Haskell.TH.Ppr.html#bytesToString
11:26:24 <nitrix> Shou: Worked with ConstraintKinds.
11:26:41 <matrium> ExcaliburZero: Thanks, it works! 
11:26:44 <nitrix> Shou: That's really cool. Thanks.
11:27:09 <ExcaliburZero> matrium: You're welcome!
11:28:12 <Shou> nitrix: No problem!
11:29:28 <joe9> addCRLF :: L.ByteString -> L.ByteString ;addCRLF a = a <> "\r" <> "\n" -- looks like this is not adding the carriage return (0xa ascii charactery)
11:31:58 <pyon> dmwit: Now that I think about it, that paper you mentioned yesterday (Lightweight Monadic Programming in ML) is kinda like the mmorph package, except automated by the type checker, right?
11:32:47 <dfeuer> What the heck is GHC.Types.RuntimeRep?
11:34:01 <dfeuer> Hrmm.
11:43:58 <lpaste> fragamus pasted “what wheel am i reinventing” at http://lpaste.net/173906
11:44:22 <glguy> liftA2 mappend
11:45:47 <dmj`> > (<>) <$> Just "foo" <*> Just "baz"
11:45:49 <lambdabot>  Just "foobaz"
11:45:55 <senoj> glguy: that's not a wheel, that's a suspension system
11:46:05 <glguy> oh, nevermind then
11:46:55 <suzu> how can i sanely use Excepts / Maybes inside some imperative IO code?
11:47:06 <suzu> my head is leaking from all the type-juggling and i feel like i'm not going about this the right way
11:47:39 <dmj`> > Just "foo" <> Just "bar"
11:47:41 <lambdabot>  Just "foobar"
11:48:18 <fragamus> glguy: doe you mean liftM2 mappend
11:48:30 <suzu> here's what i've got:
11:48:32 <dmj`> suzu: how would it be any different from using Maybe / Except in any monad ?
11:48:33 <suzu> http://lpaste.net/6837100314709983232
11:48:57 <suzu> likely not, but what i have here i feel is too ugly to be the nice way of doing it
11:50:32 <glguy> fragamus: That works too, but liftM2 is old tech now
11:50:32 <suzu> in this snippet i'm decoding a bytestring to some JSON which can fail
11:50:32 <fragamus> haha ok
11:50:32 <suzu> then after that, I want to extract two keys from that json object, which may not be there and so this may fail
11:50:32 <suzu> then i want to pass those two keys up to the outer IO code, which will do some things with them
11:50:32 <suzu> and what i have here i feel is a mess
11:50:32 <suzu> lol
11:50:32 <orion> Anyone know of any papers published about building a functional CPU?
11:50:35 <suzu> oh yeah and those two keys may not even be there, so that can fail too
11:51:13 <suzu> hence i feel like this is a job for .. ExceptT?
11:51:13 <suzu> if any of this fails out i want the whole program to go down in flames
11:51:13 <suzu> or perhaps retry later
11:51:40 <suzu> dmj`: does my code there make sense?
11:51:42 <dmj`> suzu: HM.lookup "exception" <$> eitherDecode (responseBody reponse) :: Either String (Maybe Value)
11:52:17 <suzu> that's genius
11:52:21 <suzu> why didn't hlint think of that
11:52:33 <suzu> hm wait
11:52:37 <suzu> if i do that, i lose the Object
11:52:47 <suzu> which i need, because i want to extract a couple other things out too (which may fail)
11:53:18 <dmj`> suzu: you should write a FromJSON instance then
11:53:48 <suzu> there's only two other keys that I want
11:54:04 <suzu> writing an instance out feels like overkill for me? i don't know
11:54:15 <dmj`> suzu: using a transformer should feel like overkill for you
11:54:33 <dmj`> suzu: can you lpaste your json object
11:54:43 <suzu> i don't have a json object
11:54:49 <suzu> i just want to pluck two keys out of this ad-hoc object
11:54:59 <suzu> and yeah using a transformer is twisting my brain a little bit here
11:55:02 <suzu> lol
11:55:20 <suzu> i sometimes forget and need to reevaluate to myself what is the type of some substatement
11:55:22 <suzu> ~_~
11:55:28 <dmj`> suzu: where are you getting the type Object from?
11:55:44 <suzu> from an GET request
11:55:48 <suzu> comes out of an http response body
11:55:59 <eto`> orion: https://www.cs.york.ac.uk/fp/reduceron/ along the lines you're looking for?
11:56:13 <dmj`> suzu: if you comment out 'import Data.Aeson' at the top of your file does ghc say it cannot find 'Object'
11:56:23 <suzu> likely, let me try
11:56:41 <suzu> yes
11:56:48 <shapr> orion: yeah, the reduceron's graph reduction is the way to go
11:58:15 <dmj`> data SuzuFields = SuzuFields { field1 :: Int, field2 :: Int, field3 :: Int } deriving (Show, Generic); instance FromJSON SuzuFields; decode "{ \"field1\" : 10, \"field2\" : 20, \"field3\" : 30 }" == Just SuzuFields 10 20 30. 
11:59:09 <suzu> yeah that's a lot easier than juggling a transformer..
11:59:13 <suzu> thanks a lot
11:59:41 <dmj`> Generics will infer that as 'Object', and parse it accordingly, looking up those fields
12:00:01 <suzu> ah hence you wanted to check if Object was from Aeson
12:00:33 <dmj`> suzu: yep
12:01:03 <suzu> ok, i'll just write the json instances and save myself the trouble
12:01:19 <suzu> now, if i had wanted to do this by hand with the transformer, what would that look like?
12:01:44 <dmj`> suzu: you'd end up reimplementing what FromJSON is already doing
12:02:04 <suzu> is the code that i already wrote on the right track?
12:02:17 <suzu> lookup a, lookup b, chuck up a tuple at the end with a return
12:02:25 <suzu> have a case statement outside to test if the whole thing failed
12:02:28 <suzu> etc etc
12:03:11 <dmj`> suzu: you can use the Maybe monad, but even if all fields are found, they won't be converted in to the types you want, they'd still be Value
12:03:50 <dmj`> (,,) <$> lookup "field1" o <*> lookup "field2" o <*> lookup "field3" o :: Maybe (Value, Value, Value)
12:04:02 <suzu> given that i'm not doing any IO inside this, would i have even needed an ExceptT or would just Except have been fine
12:04:08 <suzu> or really not using a second monad inside it at all
12:04:43 <suzu> let result = do { a <- lookup "f1"; b <- lookup "f2"; return (a,b) }
12:04:55 <suzu> case result of { Just a = ... ; Nothing = error "halp" }
12:05:10 <suzu> ah i see
12:05:17 <suzu> fmapping (,,)
12:05:48 <dmj`> suzu: I can't see a case for a base monad of IO, no. Identity would be your base monad.. but then you'd have Either :) ExceptT e Identity a ~ Either e a
12:06:05 <dmj`> most of mtl defines types this way
12:06:05 <suzu> right! :)
12:06:11 <dmj`> er, transformers :)
12:06:15 <suzu> no need for the transformer then, silly me
12:07:26 <suzu> thanks for your help!
12:08:12 <dmj`> suzu: cheers!
12:26:58 <janos_p> Hi, a short question. If I want to allow multiple threads to write to one TChan, can I just pass around the TChan or should I use dupTChan ?
12:27:36 <bergmark> janos_p: you can just pass it around
12:27:50 <janos_p> bergmark, Thank you!
12:27:52 <cocreature> how does threadWaitRead behave if multiple threads are reading? e.g. I have one thread calling threadWaitRead, data arrives but another thread reads it very fast. will my first thread not wake up?
12:28:12 <cocreature> janos_p: dupTChan is only useful if you have multiple readers and want to make sure each of them gets the same sequence of messages
12:29:15 <janos_p> cocreature: Ah I see, so one TChan for multiple writers but one reader, dupTChan for multiple readers but one/multiple writer/s 
12:30:08 <cocreature> janos_p: you can have multiple readers on a single tchan
12:30:20 <cocreature> janos_p: the difference is that then each message will be read by exactly one reader
12:30:23 <dfeuer> I wish danilo2 were still here. I think I solved his problem.
12:30:24 <cocreature> and then it is popped from the chan
12:30:39 <janos_p> cocreature: OK, that answers my next question :)
12:30:45 <janos_p> Thanks!
12:30:55 <cocreature> so you just need to decide what kind of semantics you need
12:31:06 <cocreature> having multiple readers on a single chan is nice for work distribution
12:31:15 <cocreature> dupChan will give you some sort of broadcast
12:32:18 <janos_p> I see
12:33:07 <lpaste> dfeuer pasted “Kind dependency” at http://lpaste.net/173921
12:33:34 <lpaste> dfeuer revised “Kind dependency”: “Kind dependency” at http://lpaste.net/173921
12:37:03 * hackagebot pipes-protolude 0.1.0.0 - Alternate Prelude for the pipes ecosystem  https://hackage.haskell.org/package/pipes-protolude-0.1.0.0 (mckeankylej)
12:42:04 * hackagebot text-zipper 0.5 - A text editor zipper library  https://hackage.haskell.org/package/text-zipper-0.5 (JonathanDaugherty)
12:47:11 <joe9> I have a library that streams data out. It reads data from a channel, writes output to a channel and logs to another channel. I understand how channels work and feel comfortable using them. Would pipes or conduit help me?
12:47:33 <joe9> I do not understand pipes or conduit and hence the question.
12:48:09 <joe9> I do not mind reading up and learning about them, if they help. If not, then I do not want to research/read about them
12:49:34 <erisco> joe9, possibly it will help you. It is certainly helpful if you need to do IO
12:50:25 <osager> im developing a cli program that prompts the user for inputs. is there any library to manage this ?
12:50:30 <mgsloan> joe9: sequenceSinks / sequenceConduits (or the related newtypes) will let you use the output of a conduit as the input to two other conduits
12:51:38 <joe9> erisco, mgsloan, there is a part of me if I should leave the library as a standalone program and use the shell script to pipe its stdin/stderr/stdout.
12:51:53 <erisco> :t getLine -- osager
12:51:54 <lambdabot> IO String
12:51:57 <joe9> erisco: mgsloan will probably help with complexity.
12:52:20 <mgsloan> Sure, but will it help with learning conduit? :D  Depends on your goal
12:52:23 <erisco> joe9, you know more than either of us
12:53:57 <joe9> erisco, mgsloan, Thanks.
12:54:02 <joe9> Is there a non-blocking getLine?
12:54:25 <erisco> Haskell is not designed for asynchrony in this way. Instead you create a new thread
12:55:34 <joe9> hGetBufNonBlocking seems to be doing it.
12:57:23 <erisco> it isn't impossible, it just isn't the grander vision
12:58:07 <zlens> how do i tell ghc-mod: look, I like my _'s don't tell me to use camelCase
12:58:29 <kadoban> zlens: Ew.
12:59:26 <joe9> erisco: Thanks.
12:59:34 <erisco> cargo_case
13:00:14 <zlens> kadoban: deal_with_it isSoMuchEasierToReadThanDealWithIt
13:00:46 <joe9> https://hackage.haskell.org/package/network-simple-0.4.0.5 is so cool. I wish it could do SSL.
13:00:55 <erisco> <g==gT;_all_aboard
13:02:56 <kadoban> zlens: It's really not. Usually I don't care even, but in haskell you have enforced capitalization rules on certain things, and a *very* strong community choice. Your code is going to stick out like a sore thumb, and what are your types going to look like? This_Looks_Goofy This_is_even_worse
13:03:39 <zlens> kadoban: this is a constant namae
13:03:47 <zlens> btree_kv_chunk_threshold looks much better than btreeKVChunkThreshold
13:04:31 <erisco> yeah but we might just shorten that to t for "threshold"
13:04:48 <kadoban> zlens: If you say so.
13:05:09 <ZelteHonor> In Haskell we should use camelCase?
13:05:49 <erisco> yup, you should, and you shouldn't care about it
13:06:08 <ZelteHonor> This is what I am doing until now. Thanks
13:06:13 <erisco> out of things to worry about this cannot be too high on the list
13:06:21 <erisco> minor syntax quibbles
13:06:27 <zlens> erisco: lol, did you just point out that both I and kadoban are wrong? (one for using _, the other for arguing in favor of camelcase) ?
13:07:14 <erisco> zlens, I wouldn't happily use an egregiously long name such as that
13:07:46 <zlens> erisco: I'm rewriting https://github.com/benoitc/cbt/blob/master/src/cbt_btree.erl in haskell
13:07:49 <erisco> zlens, for TLDs longer names seem more appropriate, but for local names less so I think
13:08:56 <erisco> you have as much room as you'd like in a code comment to elaborate
13:09:24 <erisco> it can be distracting from the overall shape of things to have really long names
13:11:45 <erisco> but, ASCII crafting is not particularly interesting
13:11:45 <ZelteHonor> I have ridiculously long function (vertical lenght) and something like 5 or 6 where definition. I find it pretty ugly. What should I do to to make it prettier?
13:11:45 <ertes> zlens: FWIW i don't think there is anything wrong with underscores…  i don't mind either style, but got used to reading camelCase
13:11:45 <erisco> you can pastebin it and then maybe someone will golf it
13:12:09 <ertes> zlens: what's more important to me is *what* you write and less how you do it
13:12:13 <kadoban> ZelteHonor: Are there obvious ways to split it up into separate functions?
13:13:36 <ZelteHonor> I am not sure. It's because I am doing a lot of things on some data. And the where definition the definition are mostly use in the next definition. 
13:15:38 <ZelteHonor> I,ll lpaste it. I also have terrible name.
13:15:41 <ZelteHonor> http://lpaste.net/173944
13:15:41 <ZelteHonor> The code itself does not work. It's a part of some bigget codebase.
13:15:41 <fr33domlover> Q: In an associated type synonym, is there a way to require that the type is an instance of a certain typeclass?
13:15:42 <ertes> ZelteHonor: stylewise your functions are fine, but you can make them easier to read by streamlining data dependencies:  use composition instead of naming every individual result
13:16:41 <ertes> fr33domlover: just write it in the class context
13:16:43 <ZelteHonor> I'll explain the problem. If I use composition I end up with super long line.
13:17:05 <ertes> fr33domlover: class (Num (T a)) => C a where type T a; …
13:17:26 <fr33domlover> ertes, ah cool I didn't know I could refer to it in the context
13:17:30 <fr33domlover> thanks
13:20:08 <ertes> fr33domlover: you just need FlexibleContexts
13:20:09 <fr33domlover> ertes, already have it :P
13:20:14 <rightfold> Hi, where can I read about the details of the GHC optimization that eliminates currying in STG? Googling "GHC uncurry", "GHC uncurry optimization" and similar queries yield no useful results
13:20:48 <dmj`> @google how to make a fast curry
13:20:51 <lambdabot> http://community.haskell.org/~simonmar/papers/evalapplyjfp06.pdf
13:20:51 <lambdabot> Title: Under consideration for publication in J. Functional Programming 1 Making a F...
13:23:30 <rightfold> dmj`: thank you :3
13:29:19 <dmj`> rightfold: sure!
13:37:50 <fr33domlover> I started using type families yesterday, getting this error: http://paste.rel4tion.org/373
13:37:52 <fr33domlover> Anyone can give me advice plz? :P
13:37:52 <fr33domlover> I could make PersistEntityGraphSelect a single-param class, but then I'd lose the chance to have different instances for different edge types
13:37:52 <fr33domlover> (not a big deal for my use cases, but just wondering about the general case)
13:40:38 <immersion> Could parsec be used to implement autocomplete, or suggestions, *while* the user is in the middle of typing out a query? For example, "car color:gr" should suggest "green" from a predefined list of colors.
13:41:03 <osager> erisco, i found Haskeline
13:42:06 <immersion> Another example could be expressions with unbalanced parentheses, e.g. "foo * (bar + ba" should suggest "baz" if that variable is defined
13:42:23 <dolio> fr33domlover: If you take two proxies instead of a proxy of a pair, does it work?
13:42:54 <immersion> The problem is that an unfinished expression (with unbalanced parentheses) will fail to be parsed, and there's no context as to where in the grammar parsing failed
13:43:56 <fr33domlover> dolio, no, same error
13:45:12 <fr33domlover> does the 2nd class there make sense though? it's a mptc just so that different edge types could specify a different node selector field
13:51:52 <dfeuer> Wyyyyyy
13:52:14 <mniip> wryyyyyyyyy
13:57:32 * fr33domlover plays with some more variants, nothing seems to work :-/
14:00:41 <dfeuer> Blech.
14:03:53 <dolio> fr33domlover: Oh, I know what your problem is. The problem is that selectorField has no way of selecting an e.
14:05:25 <fr33domlover> dolio, I was hoping that the proxy selects it, since there's at most one (PersistEntityGraphSelector n e) per n and e
14:05:34 <dolio> So, it knows that it should have `PEGS n e ~ PEGS n e'`. But it has no way of deducing that you want e ~ e' from that.
14:05:44 <dolio> selectorField doesn't take a proxy.
14:06:17 <mniip> does 'mfilter (const False) (pure x) == empty' come from monad laws?
14:06:24 <fr33domlover> dolio, do you have suggestions how I can fix that? maybe make selectorField take a proxy?
14:06:27 <mniip> monadplus laws rather
14:06:35 <dolio> fr33domlover: That would work, I think.
14:07:17 <dolio> You could try using the new explicit type application stuff, but I think that's still pretty experimental.
14:07:39 <dolio> So I wouldn't necessarily recommend going for that.
14:09:16 <pmikkelsen> hello #haskell
14:09:51 <dmj`> pmikkelsen: hello! 
14:11:08 <mniip> does 'pure x >>= f' come from monad laws?
14:11:14 <mniip> er
14:11:18 <mniip> pure x >>= f = f x
14:11:43 <glguy> Applicative says that pure = return if there's a Monad instance
14:11:45 <shachaf> Well, there's a law that return = pure, I would hope.
14:11:57 <glguy> and monad says return a >>= k  =  k a
14:12:02 <mniip> mhm
14:12:23 <pmikkelsen> Is this not only true in some of the latest releases of GHC?
14:12:25 <glguy> The restrictions for mfilter are that it has to behave like filter when instantiated to [] and that it can only use MonadPlus operations
14:12:37 <mniip> well
14:12:58 <glguy> so I'm struggling to think of a way for your equality not to be true
14:13:02 <mniip> I would expect that mfilter = \p mx -> do x <- mx; if p x then return x else empty
14:13:07 <mniip> yes
14:13:10 <mniip> it has to hold
14:13:27 <mniip> which is sorta unfun because it means that what I'm thinking of is an unlawful monad
14:13:45 <glguy> aka not a monad?
14:13:52 <shachaf> Unlawful monads are great.
14:14:00 <glguy> they're certainly easy
14:14:02 <shachaf> I should add a nonfree "monad" to nonfree.
14:14:14 <shachaf> But I didn't decide whether to implement it with >>= or with join
14:15:52 <glguy> Maybe we could use the terminology from the Agda standard library (and other places, I'm sure) of "raw"
14:16:03 <glguy> raw monads would be the type and operations without any laws
14:17:32 <glguy> shachaf: I'd think that the >>= version would be the most instructive given that it's the class method
14:17:32 <fr33domlover> dolio, it worked :) I may be abstracting too much regardless, but at least I learned something
14:17:43 <shachaf> glguy: Right, that's what I was thinking.
14:17:48 <glguy> I like how you think
14:17:59 <mniip> hmm
14:18:50 <mniip> I'm looking for a generalization of interspersion on an Alternative
14:19:38 <mniip> something like '(m (b, a), b)' or '(b, m (a, b))'
14:19:41 <fr33domlover> :t asum
14:19:42 <glguy> sound like something you could make with foldr1 from Foldable
14:19:42 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
14:20:02 <glguy> err, I guess that'd be more of an intercalate
14:20:05 <mniip> the element types are different
14:20:12 <Gurkenglas__> He wants a -> f a -> f a
14:20:20 <mniip> nononon
14:20:27 <Gurkenglas__> Where specializing f to [] yields the standard thing?
14:20:35 <mniip> no
14:20:46 <c_wraith> I can't imagine that type actually working, anyway
14:20:52 <mniip> hm, intersperse is a poor word choice
14:21:03 <Gurkenglas__> Yea he'd have to make an extra class for the nononono thing
14:21:12 <fr33domlover> :t \ x -> asum . intersperse x
14:21:13 <lambdabot> Alternative f => f a -> [f a] -> f a
14:21:32 <mniip> well basically, I want a 'b' between any pair of 'a's and two extra 'b's at the ends
14:22:04 * hackagebot constrained-dynamic 0.1.0.0 - Dynamic typing with retained constraints  https://hackage.haskell.org/package/constrained-dynamic-0.1.0.0 (jh3141)
14:22:23 <Gurkenglas__> Why two? And what has this to do with Alternative rather than []
14:22:23 <mniip> hmm
14:22:30 <fr33domlover> mniip, what if you use Data.List.intersperse and then apply asum to that
14:22:52 <Gurkenglas__> He would have thought of that :P
14:23:26 <mniip> no I'm talking of a type transformation kinda thing: Maybe a -> Either b (b, a, b)
14:23:34 <mniip> [a] -> ([(b, a)], b)
14:23:42 <mniip> or something
14:23:47 <mniip> algebraically it makes sense
14:24:00 <Cale> glguy, shachaf: throughout mathematics, it's common to use the prefix "pre-" for such things, though I think unfortunately there's some precedent use of the term "premonad" to refer to a pointed functor. But that's clearly not the right name. :P
14:24:27 <Gurkenglas__> Then we'll do cedent use!
14:24:42 <glguy> prefixes are fixes without laws?
14:24:59 <Cale> haha
14:25:11 <fr33domlover> press is... ss without laws
14:25:23 <Cale> precedents are cedents without laws :)
14:25:45 <Gurkenglas__> prelaws are _
14:26:30 <fr33domlover> predicates are dicates without laws?
14:26:53 <glguy> no, that'd be ridiculous
14:26:56 <mniip> are zygohistomorphic prepromorphisms zygohisomorphic promoprhisms without laws?
14:27:26 <Gurkenglas__> No, first you take the laws from prepromorphisms and than you add tygohisomorphicity
14:27:34 <Gurkenglas__> *z
14:28:22 <mniip> ahh
14:29:45 <Shou> Why isn't Data.Map.Map Applicative?
14:30:00 <glguy> Shou: What was pure do?
14:30:03 <hpc> what's pure?
14:30:08 <hpc> heh
14:31:15 <Cale> I've often thought that there ought to be a place for a "finite map with default value" data structure which would have that instance.
14:32:25 <glguy> Cale: I do too https://github.com/glguy/5puzzle/blob/master/src/SparseMap.hs#L27
14:32:54 <Shou> glguy: ah I see. It needs the key and the value to form a Map.
14:33:29 <Cale> Shou: Intuitively, pure x ought to be the Map which has the value x at all keys
14:33:59 <Cale> But, depending on what k is, that might not be possible to construct, and in any case, it's quite awkward.
14:34:14 <hpc> you could conceivably do it by representing the map as a function
14:34:19 <hpc> in which case pure = const
14:34:31 <glguy> we have that instance already
14:34:37 <Cale> Well, Map is a representation of a function on a finite domain
14:34:59 <Cale> So what we really want is a representation of a function with finite support (but perhaps infinite domain)
14:35:24 <benzrf> Cale: can't you have Map Integer?
14:35:37 <hpc> benzrf: any Ord can be a key
14:35:45 <Cale> benzrf: you can.
14:35:50 <benzrf> so then thats not finite domain :o
14:36:01 <Cale> benzrf: The domain of the function represented by such a Map is a finite subset of the integers
14:36:10 <benzrf> .. true
14:36:54 <hpc> i am sure the report admits implementations of Map that admit infinite associative pairs
14:37:08 <Cale> Which report?
14:37:15 <hpc> 2010
14:37:23 <Cale> The Haskell Report doesn't mention Map at all
14:37:24 <Cale> as far as I recall...
14:37:28 <glguy> containers-2016
14:37:30 <hpc> oh, no?
14:37:40 <hpc> oh right, it's in containers
14:39:09 <dmwit> pyon: Well, yes, but the entire selling point of the paper is the automation. mtl already handles these problems fine if you don't care about inserting lifts, binds, and returns by hand.
14:40:59 <dmwit> Cale, etc: http://hackage.haskell.org/package/total-map
14:41:28 <dmwit> Shou: Perhaps you, too.
14:41:34 <dmwit> Shou: TMap is Applicative.
14:46:03 <joe9> Which is recommended? unagi-chan or TChan?
14:46:28 <Xe> joe9: depends on how you eel
14:46:30 <joe9> unagi-chan seems to be the fastest. but, I want to stick with the more widely accepted, stable version.
14:48:23 <hpc> Xe: is that deliberate, or did you just make the best accidental pun ever?
14:48:31 <GLM> Is there a way for me to apply a unary function to two arguments of a binary function? i.e. double 2 + double 5
14:49:07 <hpc> > let f = (* 10) `on` (+) in f 3 5
14:49:09 <lambdabot>      Occurs check: cannot construct the infinite type: c1 ~ c1 -> c1
14:49:09 <lambdabot>      Expected type: (c1 -> c1) -> (c1 -> c1) -> c1
14:49:09 <lambdabot>        Actual type: (c1 -> c1) -> c1 -> c1
14:49:13 <hpc> :t on
14:49:14 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
14:49:17 <hpc> erp
14:49:26 <hpc> > let f = (+) `on` (* 10) in f 3 5
14:49:29 <lambdabot>  80
14:49:46 <hpc> GLM: ^
14:50:28 <GLM> hpc: Thanks. Is there a more concise way to do that like <$>? I'm trying to apply a function before using < on the output
14:51:34 <dmwit> > on (<) show EQ LT
14:51:35 <lambdabot>  True
14:51:57 <dmwit> > show EQ < show LT
14:51:58 <lambdabot>  True
14:52:47 <dmwit> ?quickcheck \x y -> (on (<) show x (y :: Ordering)) == (show x < show y)
14:52:48 <lambdabot> Unknown command, try @list
14:53:12 <Xe> hpc: it was an interntional pun, 
14:53:16 <shachaf> > compare (-5) a
14:53:16 <geekosaur> just @check, iirc
14:53:17 <lambdabot>  GT
14:53:18 <shachaf> > compare (-5) z
14:53:20 <lambdabot>  LT
14:53:21 <hpc> :t comparing
14:53:22 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
14:53:34 <dmwit> GLM: It's hard to imagine getting more concise than applying a two-character function.
14:53:36 <hpc> > comparing negate 5 10
14:53:38 <lambdabot>  GT
14:53:50 <Gurkenglas__> The ghci debugger keeps cycling between these 3 steps (with :set stop :list): http://lpaste.net/5813289912182505472 can I make it tell me why?
14:54:42 <monochrom> double 2 + double 5 = liftA2 (+) ($ 2) ($ 5) double
14:54:57 <dmwit> = on (+) double 2 5
14:55:08 <monochrom> on your double? :)
14:56:32 <Gurkenglas__> My program runs into an infinit eloop, but I don't know why or where exactly. Can I make ghci run for a few seconds, then tell me where it is right now? Because that should be the point where its stuck
14:57:04 * hackagebot ifcxt 0.1.1 - put if statements within type constraints  https://hackage.haskell.org/package/ifcxt-0.1.1 (MikeIzbicki)
14:57:27 <dmwit> Gurkenglas__: :set -fbreak-on-exception, then hit ^C
14:57:50 <Gurkenglas__> Thanks
15:00:00 <Gurkenglas__> Umm now how do I make it tell me where it is ._. http://lpaste.net/18189968182607872
15:02:40 <Gurkenglas__> If I try to :trace when its paused at the ctrl-c, the ctrl-c goes through
15:04:11 <dmwit> I don't know.
15:06:22 <GLM> What is the difference between Maybe and Either ()?
15:06:35 <monochrom> no conceptual difference
15:06:36 <hpc> GLM: how much you get made fun of ;)
15:06:36 <Gurkenglas__> Maybe has an Alternative instance
15:07:07 <GLM> hpc: Fair enough. I was trying to ask if they're alpha equivalent
15:07:24 <hpc> but yeah, they're pretty much the same
15:07:45 <hpc> Maybe has more instances, but you can (sometimes with extensions) write all of those for Either () too
15:08:06 <glguy> GLM: beyond naming, Either () has an extra element missing from Maybe
15:08:15 <glguy> Left bottom
15:08:45 <GLM> Can Nothing not have bottom?
15:09:05 <glguy> There's Left () and Left bottom but only Nothing
15:09:30 <monochrom> what does "Nothing has bottom" mean?
15:09:47 <GLM> Can Constructors only have bottom if they take an argument?
15:10:19 <nitrix> Hi, how do I solve this issue with Typeable / Dynamic?  http://lpaste.net/173977
15:10:20 <monochrom> what does "my constructor has bottom" mean?
15:10:48 <nitrix> `a0` is ambiguous but I'm not clear as to what needs an explicit type annotation.
15:10:48 <glguy> nitrix: Youhave to specify what type you were expecting
15:10:49 <monochrom> explain what it means, then you will see the logical conclusion
15:11:05 <glguy> nitrix: saveLink (x :: SomeType)
15:11:53 <nitrix> glguy: I thought the idea of Dynamic was precisely that the type was encoded with the value; the problem that I have is that I stored all these Dynamic in a data structure and now trying to save them to disk.
15:12:05 <Gurkenglas__> GLM, these are the definedness graphs of Maybe Bool and Either () Bool: http://sketchtoy.com/67323911
15:12:33 <nitrix> glguy: saveLink is normally able to infer based on context, but here, the context is essentially only available from the Dynamic.
15:12:45 <glguy> nitrix: Sure, but when you take it out you have to take it out at a certain type
15:13:15 <glguy> nitrix: If you're just going to saveLink on it you might just as well store IO () values instead of Dynamics
15:13:29 <Gurkenglas__> Perhaps I can add trace to every line and see what trace output my program converges to...
15:13:31 <monochrom> Dynamic won't save your data. You need to design a type class that does. For example Show and Read.
15:13:41 <nitrix> monochrom: I'm fully aware.
15:13:49 <glguy> If you really want to put in something that is an instance of Linkable but you don't care which, you can make a newtype Wrapper = forall a. Linkable a => Wrapper a
15:13:54 <glguy> and pull wrappers out of the dynamic
15:13:55 <nitrix> monochrom: This is reduction of the problem at hand.
15:13:57 <monochrom> maybe Show and Read aren't enough either, they don't save types.
15:15:09 <nitrix> glguy: Let me rephrase the problem then.
15:15:20 <monochrom> you may need multiple trace's on the same line, seeing how long your line is, and how many millions of functions you're composing in just one line
15:16:09 <glguy> nitrix: Dynamic doesn't "save the type" as much as it saves the name of the type. it checks that the name of the type you want to extract the value is the same name as the name of the type when you wrapped the value in the first place
15:16:15 <nitrix> glguy: The values that needs to be stored are IORefs; they have to be stored because Weak pointers are pointing at them. I'm using the foundation of IORef and Weak to create something even stronger.
15:16:18 <glguy> if they match then it just unsafeCoerces
15:17:29 <nitrix> glguy: The problem is that once I have any form of existantial quantification to allow to homogenously hold these IORef, I seem to immediatly loose the ability to cast them back to their original type (so they can be serialized and saved persistently).
15:17:53 <nitrix> glguy: Right. It uses Typeable's :~: I beleive.
15:18:06 <glguy> nitrix: No, nothing that cool
15:18:23 <glguy> https://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.Dynamic.html#fromDynamic
15:18:51 <glguy> nitrix: What does it mean to serialize and save an IORef persistently?
15:19:59 <glguy> and you can use existential quantification for something like this as long as you also carry around a class constraint with the operations you're going to need when you take it back out
15:20:07 <nitrix> glguy: The IORef to store have type `IORef (Link a)`, different a's. Again, this is a system that's meant to be even more powerful than IORef.
15:20:26 <nitrix> I don't want to write it as a compiler extension so I'm trying to use the existing stuff.
15:21:03 <nitrix> glguy: The class constraint is currently a {-# LANGUAGE ConstraintKinds #-}
15:21:20 <nitrix> type Linkable a = (Typeable a, FromJSON a, ToJSON a)
15:22:00 <glguy> What about:  newtype LinkedIORef = forall a. Linkable a => LinkedIORef (IORef (Link a))
15:22:14 <glguy> If you don't want to use extensions you can pick the set of types you support
15:22:26 <glguy> data LinkableThing = LinkableThis This | LinkableThat That
15:22:33 <joe9>  instead of a RWST monad. I want just an RST monad. Is that available? or I can just use RWST read undefined state
15:22:35 <glguy> and have IORef (Link LinkableThing)
15:23:05 <nitrix> glguy: I'm sorry, I feel I'm taking some of your time solving a problem I haven't described very well.
15:23:13 <glguy> joe9: You can either use RWST with () as the writer parameter, or combine ReaderT and StateT
15:23:15 <kadoban> joe9: Usually you just use () for parts you don't want
15:23:17 <glguy> or just avoid all of that mess
15:23:51 <nitrix> Showing my current proof-of-concept would make any haskeller puke so it's preventing me from asking help :)
15:23:55 <joe9> glguy, "avoid all of that mess" -- What is the alternative?
15:24:22 <glguy> writing things just using functions
15:25:14 <nitrix> glguy: Actually, I couldn't write a class because the instance ends up being    instance Linkable a where, which is non-sensical.
15:25:33 <nitrix> glguy: I think GHC will refuse if the T in the pattern is missing.
15:25:41 <joe9> glguy, but, you need to carry the state somewhere?
15:25:48 <joe9> glguy, just use StateT?
15:26:16 <glguy> Depends on what you're doing. Often just passing the "state" around as an argument is cleaner
15:26:37 <joe9> glguy: you have a good point.
15:27:51 <glguy> nitrix: Well, you can use (Typeable a, FromJSON a, ToJSON a) all 3 constraints in an with "existential quantification" rather than using constraint kinds
15:28:24 <glguy> but I'm not sure where you're getting stuck with the unsaturated constraint synonym
15:28:57 <nitrix> glguy: I'm going with the approach of storing the Dynamic and an IO to serialize the value together.
15:29:23 <glguy> OK, cool :)
15:29:25 <nitrix> We'll see if that works.
15:37:04 * hackagebot hw-bits 0.0.0.10 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-bits-0.0.0.10 (haskellworks)
15:54:02 <Zemyla> What is that array called, where updates to it are stored in an IntMap and then when there are enough, it copies them to a new array?
15:56:07 <buglebudabey> does anyone have any resources for learning about STG?
16:07:04 * hackagebot hgeos 0.1.5.1 - Simple Haskell bindings to GEOS C API  https://hackage.haskell.org/package/hgeos-0.1.5.1 (rcook)
16:09:16 <nitrix> glguy: Ahahah! It works! After struggling for a while, turns out it was simply a path issue.
16:09:36 <nitrix> glguy: Nontheless, the idea of encoding the respective IO along the Dynamic is brilliant and removed a lot of code.
16:09:45 <nitrix> Times to clean this up and release it :]
16:09:49 <glguy> Good thinking, then :)
16:10:12 <hpc> Zemyla: perhaps an array with a journal, or a staging area?
16:10:29 <hpc> it depends on what role the IntMap takes on in practice
16:10:42 <nitrix> I shall call it, IORel, we'll see. Relation is taken and Link is an odd name.
16:11:10 <hpc> if it's for pooling writes or for concurrent transactions or whatever
16:34:50 <jakeehrlich> So how do I get ghci to load a shared library to call ffi functions?
16:41:22 <lpaste> glguy pasted “for jakeehrlich” at http://lpaste.net/173989
16:44:52 <jakeehrlich> glguy: so the "-lssh" part was what I was looking for. Where does ghci look for those libraries? What if I want it to look locally?
16:45:35 <glguy> jakeehrlich: I'd expect -L to help with setting the library search path
16:46:07 <senoj> or setting env variable LD_LIBRARY_PATH temporarily
16:59:03 <jakeehrlich> setting LD_LIBRARY_PATH might let me to do this automagically in a stack project
16:59:45 <geekosaur> beware on OS X; LD_LIBRARY_PATH doesn't behave the same as on Linux, and it can break things rather impressively
16:59:56 <geekosaur> -L is more portable and safer
17:04:08 <glguy> Who doesn't want to be impressed?
17:08:21 <jakeehrlich> ^ me
17:08:32 <jakeehrlich> my primary dev platform is OS X too :(
17:08:56 <maerwald> I feel sorry
17:09:05 <senoj> also DYLD_LIBRARY_PATH
17:09:07 <maerwald> I had to dev on OS X once, never again
17:09:34 * Cale has flashbacks of running the iPhone Simulator inside of VMware
17:09:43 <maerwald> haha
17:10:03 <jakeehrlich> really? I don't mind it. It's like dev on *nix 99% of the time
17:10:20 <senoj> I have flashbacks of trying to get X11 configured correctly
17:10:38 <maerwald> try an empty configuration, works most of the time
17:10:52 <senoj> it does now
17:10:58 <jakeehrlich> yea I don't fiddle with that stuff luckily
17:11:02 <senoj> not so much 10 years ago
17:11:12 <maerwald> well, that was 10 years ago, so...
17:12:04 * hackagebot micrologger 0.3.0.0 - A super simple logging module. Only for use for very simple projects.  https://hackage.haskell.org/package/micrologger-0.3.0.0 (savannidgerinel)
17:16:59 <thoughtpolice> jakeehrlich: just to clarify - generally GHC is just going to use your default path for searching for libraries etc, much like GCC or Clang will. -L, as geekosaur mentioned, is probably what you want, if your libraries are in a non-standard place.
17:17:21 <jakeehrlich> thanks!
17:17:29 <thoughtpolice> If they're in something like /usr/, /usr/local etc, you should be fine by default. (On OS X, Homebrew uses /usr/local IIRC, although systems like Macports don't)
17:18:00 <c_wraith> homebrew uses /usr/local *now*, since mavericks forced it to
17:18:37 <thoughtpolice> I was definitely using Homebrew like 3-4 years ago, well before Mavericks, and only used it in /usr/local
17:18:51 <thoughtpolice> I'm not really sure what's changed; OS X is not my main development environment these days.
17:19:35 <thoughtpolice> And even before Mavericks had SIP, installing it into like, /usr probably would have completely hosed your system anyway. Installing it in $HOME was also an option IIRC.
17:19:54 <senoj> yep, or e.g. /opt
17:20:10 <thoughtpolice> Yeah, then you wouldn't get pre-built brew binaries, though. The only catch.
17:29:04 <Sinestro> Is there a library for geography? Stuff like going into subdivisions of a country
17:29:09 <Sinestro> For the US, ideally FIPS codes
17:30:07 <Clint> Sinestro: what would it do?
17:30:34 <Sinestro> Like
17:31:09 <Sinestro> Ideally, I want a way to go state by state, and then drill down further, to the county or CD level
17:31:16 <Sinestro> The US is 99% of what matters
17:31:19 <Sinestro> For this at least
17:31:20 <Koterpillar> so just static data
17:31:21 <Koterpillar> ?
17:31:23 <Clint> so you want it to contain all the gazeteer data
17:31:29 <Clint> t
17:31:53 <Sinestro> Basically
17:32:24 <Sinestro> It exists, I'm not making it up
17:32:41 <Sinestro> I want something like this Python module: https://pypi.python.org/pypi/us
17:33:37 <Sinestro> It's a wrapper around a SQLite database
17:33:41 <Sinestro> But like... effort, man
17:35:31 <Clint> you could just write parsers for http://www.census.gov/geo/maps-data/data/gazetteer2015.html
17:39:50 <Sinestro> It has shape data in it too, which I'll need later
17:39:55 <Sinestro> So I might as well bite the bullet
18:04:20 <hodapp> hmmm. Looking at hmatrix-glpk and talking to people here, I've been told that as GLPK is not thread-safe the foreign calls should require locks around them, but looking at https://github.com/jyp/glpk-hs (which did not exhibit the same issues for me) I don't see anything that seems to resemble a lock or a mutex
18:04:47 <hodapp> unless newForeignPtr somehow accomplishes this indirectly
18:07:57 <hodapp> e.g. https://github.com/jyp/glpk-hs/blob/master/Data/LinearProgram/GLPK/Internal.hs#L97 & https://github.com/jyp/glpk-hs/blob/master/Data/LinearProgram/GLPK/Solver.hs#L77
18:08:13 <AaronFriel> How easy/hard is it to perform type level functions on a Nat right now, and get a KnownNat out? e.g.: I have a type family Foo ... :: Nat, but how do I use that with, e.g., sameNat?  
18:12:03 * hackagebot text-zipper-monad 0.2.0.0 - Monadic interface to the text-zipper package  https://hackage.haskell.org/package/text-zipper-monad-0.2.0.0 (kseo)
18:18:41 <henrylaxen> ?
18:26:56 <glguy> hodapp: ForeignPtr doesn't help with thread-safety
18:27:15 <glguy> It only integrates the lifetime of the pointer into the GC
18:32:19 <Koterpillar> Anyone from or familiar with hspec-wai here, by any chance?
18:35:03 <geekosaur> hm. would using a monad to enforce sequential calls also enforce non-reentrant use?
18:42:19 <glguy> If all the calls were in the same Haskell thread and the calls are sequenced with IO it should be fine
18:43:55 <geekosaur> was trying to figure out if the monadic interface in glpk-hs could be enforcing thread safety. I suppose not, though
18:44:24 <geekosaur> (that is, ensuring calls are not being made simultaneously from different threads)
19:20:18 <hodapp> geekosaur: I don't think the monadic interface is really used for the solver, just for constructing the linear programming problem
19:22:01 <nshepperd> hmm, you *could* use types to ensure singlethreadedness, with eg. existential tag. probably mostly a silly idea
19:22:39 <geekosaur> using a non-thread-safe library is a silly idea... until it's the only real option. then it's a frustrating idea
19:23:03 <hodapp> geekosaur: I looked for others when I ran into this problem, and options seemed really quite limited.
19:23:23 <hodapp> I found a handful of simplex implementations that were varying levels of "slow" and "broken".
19:23:26 <c_wraith> You're probably best off using a top-level MVar to control access
19:23:36 <nshepperd> well, it would be more reasonable to just use locks to make it thread safe
19:23:38 <c_wraith> Despite the horrible hacks that implies
19:23:56 <c_wraith> except top-level MVars don't prevent issues if the code is reloaded.
19:24:01 <nshepperd> put the non-thread-safe variable in an mvar and access it with withMVar
19:24:02 <hodapp> c_wraith: how does one make a top-level MVar?
19:24:07 <c_wraith> unsafePerformIO
19:24:15 <c_wraith> and NoInline pragmas
19:24:30 <hodapp> sounds like a horrible hack
19:24:36 <c_wraith> it is
19:24:48 <hodapp> nshepperd: I don't think there is just a non-thread-safe variable
19:24:57 <c_wraith> But so is making your library depend on global state!
19:25:02 <hodapp> nshepperd: I am fairly sure it's state that is internal to GLPK
19:25:13 <amatos> Hi everyone. I'm learning Haskell and I've got a question I couldn't find in the usual channels (stack overflow, etc..). Is there any way I can convert an [IO String] to IO [String]?
19:25:33 <Koterpillar> :t sequence
19:25:34 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
19:25:37 <nshepperd> oh, it's global stuff in the library
19:25:44 <hodapp> nshepperd: as far as I understand it
19:25:47 <Koterpillar> amatos: sequence
19:26:07 <nshepperd> yeah, I mean you could write your own C wrapper around the library and do the locking there
19:26:17 <glguy> couldn't find in the usual channels? this is the usual channel :)
19:26:20 <hodapp> nshepperd: maybe that's what glpk-hs does, hmm
19:26:37 <Koterpillar> amatos: http://hayoo.fh-wedel.de/?query=%5BIO+a%5D+-%3E+IO+%5Ba%5D 
19:26:49 <hodapp> maybe it does that, maybe it does something else obvious that I missed, or maybe it just does a bunch of wrong calls all over the place and somehow my code didn't trigger this bug
19:26:55 <Koterpillar> amatos: http://hayoo.fh-wedel.de/?query=Monad+m+%3D%3E+%5Bm+a%5D+-%3E+m+%5Ba%5D
19:27:03 <amatos> Koterpillar: thanks! 
19:32:29 <amatos> Koterpillar: didn't know about http://hayoo.fh-wedel.de, this is very neat, thanks!
19:32:53 <Koterpillar> I think it's also wired up to lambdabot here, but I forgot the invocation
19:33:29 <geekosaur> not hayoo
19:33:58 <geekosaur> hoogle (for just the packages that come with ghc) is, thoughj
19:34:16 <Koterpillar> @hoogle [IO String] -> IO [String]
19:34:19 <lambdabot> No results found
19:34:25 <Koterpillar> @hoogle [IO a] -> IO [a]
19:34:26 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
19:34:26 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
19:34:26 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
19:34:55 <geekosaur> ...and it's not even up to date with ghc 7.10 much less 8.0
19:35:00 <Koterpillar> that's actually better than Hayoo, which couldn't specialize to []
19:35:24 <geekosaur> hoogle is generally better with fuzzy types than hayoo is. but hayoo handles fuzzy names better
19:35:30 <geekosaur> often it's a good idea to try both
19:55:22 <GreenCeleryStick> Hey all, I'm wondering if in Core, a Var's unique id is the same as its Name's unique id. I ran some tests and on the examples I tested it appeared to be the case. Wondering if anyone can confirm.  https://downloads.haskell.org/~ghc/7.10.1/docs/html/libraries/ghc/Var.html#t:Var
20:01:21 <geekosaur> "Every Var has fields varName::Name and a realUnique::FastInt. The latter is identical to the Unique in the former, but is cached in the Var for fast comparison." https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/EntityTypes
20:01:46 <geekosaur> GreenCeleryStick, ^
20:01:56 <GreenCeleryStick> Thanks!
20:02:19 <geekosaur> in general you probably want to go through the commentary I linked to, to find out what's going on inside of ghc
20:02:57 <GreenCeleryStick> Thanks for the pointer, will do
20:04:34 <et09> maybe someone can help clear this up for me
20:04:57 <et09> i guess i could phrase it like this, what is the closest thing to an activerecord-style ORM in haskell
20:05:20 <et09> and how much limitation is there re: modification of data types that would be considered a 'model' in rails
20:29:13 <amatos> I've got another related question: I'm trying to build a Data.HashMap.Strict inside the IO monad, so I want a IO (HashMap String String). I'm trying to build it like this: HMS.singleton "String1" (functionA "String1"), where functionA :: String -> IO String (I'm simplifying this a little bit). But this gives me HashMap String (IO String). Is there any way I can go from here to IO Hashmap String String?
20:30:01 <glguy> amatos: First execute the action, then put the result in a HashMap:
20:30:21 <glguy> do result <- functionA "String1"; return (HMS.singleton "String1" result)
20:30:57 <amatos> glguy: I see, let me try that. Thanks!
20:31:43 <glguy> also another thing to know about is that: sequenceA :: HashMap k (IO v) -> IO (HashMap k v)
20:32:14 <glguy> That's a general function that works in this case
20:32:24 <glguy> sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
20:33:55 <dmj`> could also fmap fromList onto the IO action
20:34:00 <dmj`> :t IM.fromList <$> (undefined :: IO [(Int, String)])
20:34:02 <lambdabot> IO (Data.IntMap.IntMap String)
20:34:09 <amatos> glguy: that's neat as well. Ultimately I'm trying to build a hashmap with multiple elements, not only a singleton
20:34:53 <Clint> sensible
20:36:07 <dmj`> amatos: can we see your code, what you have so far
20:36:57 <Xpalo> i just stepped in, but i like the approch  in the hashtables package, although i am not quite sure how to replicate it
20:37:03 * hackagebot case-insensitive-match 0.1.0.0 - A simplified, faster way to do case-insensitive matching.  https://hackage.haskell.org/package/case-insensitive-match-0.1.0.0 (mikehat)
20:37:53 <jchia> Suppose I have a record type situation like this: data Foo = Foo { a :: Int, b :: Char, c :: String }; data Bar = Bar { a :: Int, c :: String }
20:37:54 <jchia> The record types have related fields, i.e. a field can occur in multiple record types. How can I define my record types without repeating myself? I'm also looking for a way to easily get a Bar value from a Foo value without verbosely mentioning all the fields. I suppose I could make use of RecordWildCards and make a function for each (X, Y) record type pair to copy fields from X to Y. Is there a better way?
20:38:04 <Xpalo> in fact, it would be awesome to have a tutorial from those guys, on exactly how that works, with all that ghc primstate foo
20:38:57 <Xpalo> because it would be nice to use that technique for other kinds of key value pair lookups
20:39:46 <dmj`> is hackage down?
20:40:09 <glguy> Doesn't appear to be.
20:40:47 <amatos> dmj`: Thanks for the help. I'll paste  in the lpaste shortly
20:41:44 <dmj`> Xpalo: which technique?
20:41:50 <dmj`> glguy: I must be crazy
20:42:49 <Xpalo> dmj`, in hashtables package, they did something cool with primstate realworld and primstate s, or whatever... so you have a shared interface with ST and IO and so forth, look at the source to see what i mean.
20:43:38 <glguy> Xpalo: That's part of the primitive package if you find yourself wanting to do more of that http://hackage.haskell.org/package/primitive-0.6.1.0/docs/Control-Monad-Primitive.html
20:43:41 <Xpalo> it would be cool if we expanded that to things like memory-mapped file- kv-lookups and so forth
20:43:53 <dmj`> Xpalo: what glguy said
20:44:01 <dmj`> that's used with vector I believe
20:44:05 <glguy> memory-mapped files wouldn't work in ST, though
20:44:56 <Xpalo> no, but you make an entirely new monad, for example LMDB monad which lets you store persistent key-value pairs in an lmdb databse
20:45:43 <Xpalo> i guess you'd have an s parameter, just like ST, but then you top it off using a technique like they did, so that users can forget its in LMDB and use it like it were IO or whatever.
20:45:49 <dmj`> Xpalo: PrimState is a type family on PrimMonad, of which ST and IO have instances, so the vectors hashtables uses are constructed in either
20:47:03 * hackagebot case-insensitive-match 0.1.1.0 - A simplified, faster way to do case-insensitive matching.  https://hackage.haskell.org/package/case-insensitive-match-0.1.1.0 (mikehat)
20:47:14 <lpaste> amatos pasted “Hashmap InvestmentCategory IO [Investment] to IO Hashmap InvestmentCategory [Investment]” at http://lpaste.net/4824330197144698880
20:47:38 <dmj`> jchia: use lens, makeClassy to have lenses that work on different records. Or use duplicate record fields in ghc8. Unsure how you'd get a bar value from a foo value...
20:47:42 <Xpalo> right, you need PrimMonad instance of LMDB monad
20:48:51 <Xpalo> i understand it at a distance, but there is a barrier in how the whole thing is conveyed, i wish i could somehow wet my feet in a tutorial before diving into the deep end.
20:49:27 <amatos> dmi': I've just pasted some code to lpaste. Database.lookupInvestmentsByCategory returns IO [Investment]. investmentsAverage is [Investment] -> Benchmark. I'm trying to get an IO (Hashmap InvestmentCategory Benchmark), but the resulting type is Hashmap InvestmentCategory (IO Benchmark)
20:49:55 <dmj`> @google Primitive Haskell
20:49:56 <lambdabot> https://hackage.haskell.org/package/primitive
20:49:56 <amatos> dmj': sorry I've just pasted some code to lpaste. Database.lookupInvestmentsByCategory returns IO [Investment]. investmentsAverage is [Investment] -> Benchmark. I'm trying to get an IO (Hashmap InvestmentCategory Benchmark), but the resulting type is Hashmap InvestmentCategory (IO Benchmark)
20:50:11 <dmj`> Xpalo: https://www.fpcomplete.com/blog/2015/02/primitive-haskell
20:50:23 <Xpalo> yeah that sort of hting, i was already aware of that one tho, i wanted yet more
20:50:27 <dmj`> amatos: can you annotate your lpaste with the types
20:50:41 <amatos> dmj' : Sure, just a sec.
20:50:50 <dmj`> amatos: I'd check out fp complete's vector tutorial
20:51:01 <dmj`> Xpalo: *
20:51:05 <Xpalo> oh okay
20:51:49 <dmj`> you can treat PrimState as you would IO or ST
20:52:07 <dmj`> suppose you wanted to build a BloomFilter
20:52:24 <dmj`> Xpalo: http://lpaste.net/174033
20:52:43 <ChewyCheeks> Sweden!
20:52:47 <dmj`> Xpalo: PrimState is applied to (m :: * -> *)
20:53:28 <lpaste> amatos annotated “Hashmap InvestmentCategory IO [Investment] to IO Hashmap InvestmentCategory [Investment]” with “Hashmap InvestmentCategory IO [Investment] to IO Hashmap InvestmentCategory [Investment] (annotation)” at http://lpaste.net/4824330197144698880#a5928461027887808512
20:54:18 <amatos> dmj' I've added the types, hopefully it is clear. Thanks for the help. 
20:54:31 <dmj`> Xpalo: I actually have a simple hashtable implementation that uses vector and resolves collisions with chaining
20:55:09 <Xpalo> simple enough to lpaste?
20:55:30 <dmj`> amatos: is this supposed to be lookupInvestmentsByCategory :: InvestmentCategory -> IO [Investment] ?
20:55:50 <amatos> dmi': It is, sorry
20:55:56 <amatos> dmi' : It is, sorry
20:56:14 <lpaste> amatos revised “Hashmap InvestmentCategory IO [Investment] to IO Hashmap InvestmentCategory [Investment] (annotation)”: “Hashmap InvestmentCategory IO [Investment] to IO Hashmap InvestmentCategory [Investment] (annotation)” at http://lpaste.net/5928461027887808512
20:56:28 <jchia> dmj`: A Bar value can be obtained from a Foo value by copying the a and c fields
20:57:03 * hackagebot hjsonschema 1.1.0.0 - JSON Schema library  https://hackage.haskell.org/package/hjsonschema-1.1.0.0 (seagreen)
20:57:18 <jchia> i have places where i need to get a 'simpler' record from a more 'complex' record, and there are many record types resulting from different situations requiring different subsets of the fields
20:57:29 <amatos> dmj' : it is supposed to be yes, I've updated the code in paste.
20:57:42 <Xpalo> dmj`, thanks, i actually have to go
20:57:52 <glguy> jchia: lens would be a clean way to relate the two record types
20:59:39 <glguy> fooBar :: Lens' Foo Bar;   view fooBar :: Foo -> Bar;   set fooBar :: Bar -> Foo -> Foo;    etc
20:59:39 <jchia> thanks
21:02:36 <jchia> if I have data Foo = Foo { a :: Int, b :: Char}; data Bar = Bar { a :: Int}; data Baz = Baz { b :: Char }; is there a way to express that Foo is just Bar + Baz and avoid repeating mentioning the fields?
21:03:00 <jchia> then when I update Bar or Baz, I don't need to update Foo
21:03:24 <Koterpillar> jchia: lazy way: data Foo = Foo { bar :: Bar, baz :: Baz }
21:04:02 <Koterpillar> jchia: fancy way: https://hackage.haskell.org/package/record https://hackage.haskell.org/package/vinyl
21:05:58 <glguy> jchia: No, records don't support reusing fields or subtyping on their own
21:06:54 <dmj`> amatos: http://lpaste.net/8239938170905427968
21:08:10 <amatos> dmj'. Thanks! I'll need a bit of time to parse it all but I think I got the gist of it.  
21:08:21 <dmj`> or just
21:08:23 <dmj`> H.fromList . zip allInvestmentCategories . map investmentsAverage <$> mapM lookupInvestmentsByCategory allInvestmentCategories 
21:09:10 <amatos> dmj' Yes, I was trying to use mapM before but I can't remember why it didn't work. But I think I have a better understanding how it all hangs now.
21:10:38 <dmj`> amatos: sure beats that singleton hash map you had before ;)
21:10:52 <amatos> dmj' It definitely does :)
21:32:31 <dmwit> dmj`: He never did quite figure out the difference between ` and ', did he? ...but at least he worked out the i vs j thing.
21:33:54 <dmj`> dmwit: :)
21:37:49 <joe9> I am writing a simple network client using tcp sockets. I want to tryJust (Control.Exception) to capture only network related errors (could not connect, etc). What exception should I match upon?
21:38:24 <glguy> IOError
21:38:49 <joe9> glguy: Thanks.
21:41:42 <zlens> suppose I open a file in Haskell, and I write to it in a series of blocks, b0, b1, b2, b3, ... ; furthermore, suppose this app is terminated by someone pulling the power plug; is there any guarantee that I can get of the form: there is some $i$, s.t. blocks b -> b(i-1) are completely written b(i) may be corrupted, and nothing from b(i+1) onward are written?
21:42:03 <zlens> i.e. there is soem i, for which the file looks like b(0), b(1), ..., b(i-1), some possible corruption of b(i)
21:43:20 <Koterpillar> zlens: ask this question from your filesystem
21:43:23 <dmwit> If you want that, you probably have to do something lower level than what's currently in the standard libraries.
21:43:32 <dmwit> i.e. cooperate with your specific FS, as Koterpillar suggested
21:43:53 <dmwit> But there's a simpler thing you can do: write a temporary file, then rename it.
21:44:15 <Koterpillar> zlens: or not even, because a hard drive [made more than 30 years ago, but still] might not auto-park and just scratch arbitrary data everywhere
21:44:16 <dmwit> rename is atomic, so you will either have the full file or none of it (though you may have a stray temp file lying around that wasn't cleaned up).
21:44:55 <zlens> dmwit , Koterpillar : this is an XY problem; I'm implementing a copy-on-write/append-only btree
21:45:07 <dmwit> (You may possibly want to fsync before rename.)
21:45:58 <zlens> I'm writing the file out in 'segments'; and on crash recovery, reading them backwards
21:46:07 <zlens> so I need the property that "only the last wtiten segment may be corrupted"
21:48:37 <joe9> glguy, can I wrap the connection in a bracket? such as bracket openConnection connectionClose (\connection -> send and recv loop)
21:48:48 <glguy> joe9: You can!
21:48:53 <joe9> glguy: Thanks.
21:49:06 <c_wraith> Just beware of lazy IO in that pattern
21:49:14 <c_wraith> but beware of lazy IO in general
21:49:26 <ongy> and IO buffers, and all the other things that can go wrong here
21:49:53 <ongy> have a look at the guaranties sync gives you aswell
21:50:43 <zlens> Koterpillar , ongy : anything worth reading besides "man fsync" ?
21:51:20 <zlens> Note that while fsync() will flush all data from the host to the drive
21:51:21 <zlens>      (i.e. the "permanent storage device"), the drive itself may not physi-
21:51:21 <zlens>      cally write the data to the platters for quite some time and it may be
21:51:21 <zlens>      written in an out-of-order sequence.
21:51:23 <zlens> WTF
21:51:33 <zlens>      Specifically, if the drive loses power or the OS crashes, the application
21:51:33 <zlens>      may find that only some or none of their data was written.  The disk
21:51:33 <zlens>      drive may also re-order the data so that later writes may be present,
21:51:34 <zlens>      while earlier writes are not.
21:51:38 <zlens> this is insane
21:51:41 <zlens> (sorry for flooding)
21:51:49 <zlens> how do people write databases when fsync gives such terrible gaurantees?
21:51:54 --- mode: ChanServ set +o dmwit
21:52:06 <dmwit> carefully
21:52:32 --- mode: dmwit set -o dmwit
21:52:36 <ongy> ever wondered why software is terrible?
21:52:38 <zlens> is 'sync' stronger than 'fsync' ?
21:52:45 <ongy> no, weaker
21:52:52 <ongy> sync only says "now it's the drivers fault"
21:53:02 <zlens> fsync says: now it's the hard driven's fault?
21:53:11 <johnw> "guarantees".  lol
21:53:13 <ongy> if I understand the manpage correctly
21:54:00 <ongy> there was some discussion around this with regards to btrfs, it's terrible.
21:54:29 <zlens> the worst part of the man page:
21:54:29 <zlens>      This is not a theoretical edge case.  This scenario is easily reproduced
21:54:31 <zlens>      with real world workloads and drive power failures.
21:54:33 <zlens> lol
21:55:48 <joe9> glguy: quick question, connectionLoop = bracket openConnection connectionClose (\connection -> send and recv loop) >> connectionLoop ;  In this situation, I am creating connections, if the connection ended for some reason. If for some reason, the openConnection cannot connect, I want to sleep to avoid too many attempts in a short span.
21:56:37 <joe9>  glguy, , connectionLoop = bracket (onException openConnection (threadDelay 6000)) connectionClose (\connection -> send and recv loop) >> connectionLoop ;  will this work?
21:56:52 <joe9> glguy, I added the onException on openConnection
21:58:14 <joe9> but, I am not sure if onException will propogate the error/exception to bracket.
21:58:28 <joe9> in the event of an error or exception in openConnection.
21:58:44 <glguy> joe9: Move the threadDelay outside of the first argument of bracket. You can use try around the whole bracket to catch the IOError, and if you check it an it's a NoSuchThing then you can do the logic for delay and reconnect
21:58:55 <glguy> you should do the minimum possible inside the first two arguments of bracket
21:59:18 <glguy> also as written you'd delay 6 seconds andthen continue failing afterward, the exception will propagate out of bracket
22:01:08 <joe9> glguy, thanks.
22:02:03 * hackagebot warp 3.2.8 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.2.8 (KazuYamamoto)
22:03:02 <joe9> glguy, instead of a try outside the bracket, is it a good idea to wrap the bracket with an onException?
22:03:24 <glguy> onException won't catch the exception, so it won't help with that
22:03:56 <glguy> It only allows you to execute an action in the case that an exception occurred
22:12:03 * hackagebot servant-router 0.9.0 - Servant router for non-server applications.  https://hackage.haskell.org/package/servant-router-0.9.0 (willfancher)
22:12:37 <zlens> https://wiki.apache.org/couchdb/Durability_Matrix <-- why does calling fsync twice makes this safe?
22:12:47 <zlens> couchdb, iirc, uses a copy-on-write/append-only mvcc btree
22:14:37 <joe9> glguy, quick question, wrapping the bracket in try loses the return value of bracket on error, correct?
22:14:57 <glguy> The value?
22:19:01 <joe9> glguy: http://bpaste.net/show/ab1ab12e6814 is my uncompiled code.  If I wrap the try around bracket, the 's' returned by the runRWST ..Loop would be lost, correct?
22:20:28 <joe9> glguy, does that make sense?
22:20:46 <glguy> It'll be "lost" whether or not you have try if there's an exception that causes execution to stop
22:22:53 <joe9> glguy:  if I put the try in the authenticateAndReadDataLoop , then the state of the failed iteration is lost. But, I will have the state of the previous iteration, correct?
22:23:19 <geekosaur> zlens, the first one ensures the new data is committed to disk, the second one ensures the new metadata is committed. if a failure happens at/before the first one, the partially written data will be ignored on the next open because it is not referenced; the database is consistent with its pre-write state. if a failure happens at/before the second write, the new data are complete but unreferenced; the database is still consistent but contains an
22:23:20 <geekosaur>  additional data record.
22:23:20 <joe9> whereas in this case, I will lose the state even if the loop ran for 1 time or 100 times
22:23:31 <joe9> glguy: does that make sense?
22:23:32 <glguy> if you put the try inside there you won't be able to catch the exception from a failed connection
22:23:50 <glguy> and you'll have to thread the RWST in and out of try, you won't be able to use it on its own
22:24:10 <glguy> My recommendation against RWST is going to stand
22:24:11 <geekosaur> this ends up being similar to the first case as far as recovery, but because the new header that references the new data is synced separately, it should not be possible to have a header but partially written data record
22:25:14 <joe9> q
22:25:25 <joe9> glguy: makes sense.
22:25:27 <glguy> joe9: What you can do while in RWST is wrap your IO actions in a try before you liftIO them into RWST
22:25:38 <geekosaur> (but, as they warn, some OSes --- notably linux --- do not actually ensure the data are committed to permanent storage, only sent to the storage device and left to that device's firmware to commit. the double commit helps some with this, since most devices will at least force the first data to be committed at that point.)
22:25:38 <glguy> but that doesn't address connection failure
22:25:58 <glguy> joe9: In the case of connection failure, however, you can just use the old ss value that never actually made it into runRWST
22:26:23 <orion> Does anyone know how to call this function?: https://github.com/centromere/cacophony/blob/safe-exceptions/src/Crypto/Noise.hs#L62
22:27:09 <geekosaur> note also that the reason linux does this is that many disks provide no documented way to ensure commit. apple can and does sign NDAs to get access to private commands that will (usually) ensure the data are written
22:28:27 <geekosaur> also note that cheap consumer grade disks don't even have private commit commands; you pretty much lose in this case. use high end disks if you care about your data.
22:29:27 <glguy> orion: What aspect of that function are you having problems with?
22:29:52 <benzrf> geekosaur: that's one of the more bullshit things ive heard today
22:30:18 <geekosaur> there's a bunch of storage folks who would like to know your references
22:30:31 <benzrf> oh, sorry
22:30:37 <benzrf> i meant that - it's bullshit that the industry works like that
22:30:39 <glguy> benzrf: There are better ways to disagree with people than that in #haskell
22:31:07 <benzrf> i didn't mean that anything you stated was false
22:31:12 <benzrf> just that it's scummy
22:31:19 <glguy> k
22:31:22 <geekosaur> it is indeed. but disk tech has been in the cheaper-by-any-possible-means downward spiral for over a decade now
22:31:31 <benzrf> (on the part of the disk manufacturers)
22:31:47 <geekosaur> which is why zfs and btrfs, which is why fancy RAID disk controllers, etc.
22:32:02 <ongy> why does noone plug a sensor between hard/software that supports it to figure it out? not worth the effort?
22:32:33 <orion> glguy: I seem to be unable to craft a function which can use it. This was my attempt: http://lpaste.net/4413218955523522560
22:33:21 <geekosaur> ongy, if you read that link, Apple does so in the OS. generally those interfaces are under NDA, so Linux/FreeBSD/etc. can't get access to them
22:33:59 <Koterpillar> geekosaur: won't tapping the bus be fair game then?
22:34:02 <glguy> orion: writeMessage :: (Cipher c, Hash h) => NoiseState c d h -> ScrubbedBytes -> Either SomeException (ByteString , NoiseState c d h)
22:34:21 <geekosaur> someone could sell devices to do it, but the constant drive for cheaper and for better benchmarks means drive manufacturers would add countermeasures
22:35:06 <ongy> fun with hardware. but I still think it should be doable (and somewhat should be done)
22:35:19 <ongy> but this may be a bit off topic here
22:36:04 <geekosaur> the incentives here are all wrong, disk manufacturers have incentives to make things cheap and make things fast but no incentive to make them reliable. up to a point third parties can try to hack around this, but at some point the bus you have to tap is one inside the drive electronics and good luck with that, then
22:36:19 <peddie> geekosaur: how does keeping the commit instruction secret save money?
22:36:46 <Koterpillar> geekosaur: the command has to come from the OS
22:36:59 <ongy> peddie: makes it harder to force clearing caches. and caches feel fast
22:37:16 <joe9> glguy, yes. Thanks. That is a good idea.
22:37:58 <ongy> if you have free ram, start a big copy and look at the reported write-speed, it will be really fast until your ram fills with io-buffers. it actually completes while quite a chunck of the file is still in ram buffers
22:40:07 <peddie> ongy: I understand how that works, but I'm surprised that they save that much money or perform better in correct benchmarks by simply preventing reliability unless you sign an NDA . . .
22:40:30 <joe9> glguy http://bpaste.net/show/3591ee9ebdb4 what do you think about this? I will wrap the IO actions in the RWST loop with try.
22:40:51 <geekosaur> peddie, generally it means they use cheap firmware until they need to sell to someone who requires data guarantees or won't buy your crap, then they charge 5x the cost and add the firmware with the secret command. (which isn't really "secret" so much as "only the documentation that comes with that special firmware admits to its existence"). which only makes sense because the market provides perverse incentives
22:41:24 <peddie> geekosaur: I see, thanks for the explanation
22:41:34 <joe9> glguy: http://bpaste.net/show/30c3e87a15d4 using try
22:41:35 <geekosaur> and they don't want to document the command in the normal docs so people won't try to use it and then RMA the drive as broken when it's rejected
22:41:50 <peddie> because they got the cheapo firmware
22:41:56 <joe9> glguy: try seems to the cleanest
22:42:31 <glguy> joe9: Yeah, but now you aren't ensuring that the connection gets closed on exception
22:42:39 <geekosaur> from the system integrator POV it's completely broken, from the manufacturer's point of view it ends up making a perverse kind of sense because the market rewards that insanity with higher low end sales and better high end profits.
22:43:37 <peddie> geekosaur: ouch
22:43:42 <joe9> glguy: This try is only on connection open failures. If there is a failure in opening the connection, why bother with the close.
22:44:00 <glguy> joe9: You should just name the process of opening a connection and running an action with that connection.
22:44:02 <glguy> e.g. https://github.com/glguy/irc-core/blob/v2/src/Client/Connect.hs#L112
22:45:00 <zlens> geekosaur: can I PM you about the couchdb fsync / header / fsync issue? The words you are saying are similar to things I am reading, but (1) I don't understand them and (2) I don't want to spam #haskell with fsync issues
22:45:16 <joe9> glguy: That is a good idea. let me think it through.
22:45:29 <glguy> joe9: If you don't care about cleaning up on failure then it doesn't really matter how you manage the errors
22:46:01 <joe9> glguy: the problem with bracket is that it is not catching open errors.
22:46:29 <joe9> glguy: it is good for catching processing errors. but, open errors is the issue I am thinking about.
22:46:32 <geekosaur> zlens, can it wait until tomorrow sometime? it's 0147 here and I had intended to go to bed...
22:46:37 <glguy> bracket isn't for catching errors
22:46:43 <glguy> That's where the try comes in
22:46:50 <zlens> geekosaur: sure, I will bug you tomorrow/ g'night
23:52:39 <paolino> hello, is there a recursion schema/name for gcd ?
23:53:28 <kadoban> paolino: Hmm?
23:53:34 <paolino> unfoldr seems not to fit nice
23:53:50 <paolino> nor iterate
23:55:31 <suzu> gcd a b = gcd b%a a ?
23:56:10 <paolino> yes I was referring to that gcd
23:58:41 <paolino> last unfoldr or last takeWhile iterate seem not better than plain recursion with base case
