00:04:01 <peteretep> I have a recursive `t a`. It's able to be filtered with: filter :: (a -> Bool) -> t a -> t a
00:04:06 <peteretep> Is there a generic name for that pattern?
00:04:18 <peteretep> Hoogle shows me mfilter
00:04:32 <peteretep> and obv there's filter :: (a -> Bool) -> [] a -> [] a
00:11:53 <Cale> peteretep: There's an interesting approach to that here... I don't know if it's popular at all: https://hackage.haskell.org/package/witherable-0.1.3.3/docs/Data-Witherable.html
00:12:37 <peteretep> That is interesting, and suggests that there's no common name for the concept
00:12:41 <srhb> peteretep: Also, if you're talking about Traversable, https://wiki.haskell.org/Foldable_and_Traversable#Some_trickier_functions:_concatMap_and_filter
00:12:53 <peteretep> thanks
00:13:21 <srhb> Witherable is such a silly name... :-P
00:14:27 <Cale> It is silly, but I don't entirely hate it
00:15:32 <Cale> "blightM is witherM with its arguments flipped" -- this part is perhaps a little over the silliness line :)
00:15:44 <dysfun> you don't say :)
00:15:54 <dysfun> makes it sound like some sort of fungus
00:16:41 <Cale> There's also an applicative functor here called "Peat"
00:16:55 <Cale> I'm not sure what that's meant to suggest
00:17:06 <dysfun> that it stinks of dead things?
00:17:42 <dysfun> once you've had that sort of dubious inspiration, it's very hard to stop continuing the theme
00:19:16 <Cale> Reminds me of http://arxiv.org/pdf/math/0002089.pdf
00:21:35 <dysfun> ooh, this looks good
00:21:54 <Cale> There was zero sharp, and zero dagger, and zero sword... why not zero hand-grenade? :)
00:21:55 <dysfun> anything that starts with the phrase "zero hand-grenade"...
00:22:36 <Cale> look at section 8
00:23:04 <dysfun> page number?
00:23:09 <Cale> 63 physical
00:23:20 <Cale> "Beavers and the existence of K."
00:23:22 * dysfun giggles
00:23:32 <dysfun> "let W be an iterable weasel"
00:23:58 <Cale> Set theory gets so bizarre that they just give up naming things sensibly.
00:24:09 <dysfun> i have literally no idea what this is saying, but it's amusing
00:27:44 <Cale> I only have a very vague sense of what's going on, and understand none of the details
00:28:05 <dysfun> well i can infer things, but that way often leads disaster
01:03:18 * hackagebot mars 0.1.0.4 - Generates mountainous terrain using a random walk algorithm.  https://hackage.haskell.org/package/mars-0.1.0.4 (infrared)
01:14:56 <kamyar> Hello friends
01:15:04 <kamyar> Any Haskell Pro here to help me?
01:16:07 <kamyar> I am trying my best to dig in Haskell IO concepts: Coroutine->Conduit/Pipes...
01:16:22 <Cale> This is a good place to ask questions
01:16:24 <kamyar> I am trying to read so many articles and tutorial
01:16:33 <kamyar> But still confused.
01:16:59 <kamyar> Please help me get a complete intuition about Haskell IO and related packages
01:17:33 <kamyar> Where can I study a good step-by-step tutorial
01:17:47 <kamyar> I am familiar with Monads and I think I understand them
01:19:54 <Cale> Well, it helps to have a specific thing you're trying to accomplish. Pipes and Conduit are intricate libraries, and honestly despite the fact that I've been writing Haskell code for 15 years, they still manage to confuse me (though I get by fine using them, I have to think hard about what I'm doing quite often)
01:23:08 <Cale> There's a tutorial for pipes here: http://hackage.haskell.org/package/pipes-4.2.0/docs/Pipes-Tutorial.html
01:23:49 <kamyar> Cale: I am currently reading it! But it exactly confuses me: 
01:24:15 <kamyar> Cale: The first 3 items and the description is not easily underatndable
01:25:00 <kamyar> Cale: Can I use pipes and conduit blindly? I am not used to do so but I may have to
01:25:10 <Cale> It's assuming that you've spent a bunch of time writing other kinds of I/O performing code
01:26:14 <kamyar> Cale: I am absolutely a beginner: I just wrote some code connecting to Redis and Postgresql (HDBC)
01:26:44 <kamyar> Cale: The most complicated code I wrote recently is calling some RESTful services using wreq and parsing JSON
01:26:45 <Cale> Yeah, in that case, ignore pipes and conduit until you really find a reason you need to know more about them.
01:27:38 <kamyar> Cale: These two real world samples made me get a better understanding of Monads and monad transformers and laziness
01:28:09 <kamyar> Cale: I have to write more advanced code to get more familiar with Haskell, 
01:28:32 <kamyar> Cale: Now I wanna port some of my Python codes into Haskell: WebSocket
01:28:49 <kamyar> Cale; I have to understand STM/TVar and maybe IO
01:29:35 <kamyar> Cale: I have a websocket server in Python/asyncio which gets some data from ZMQ and dispatch them to connected websocket clients.
01:30:01 <kamyar> Cale: Do I need Conduit/Pipes for using it?
01:30:22 <kamyar> Cale; Sorry! Do I need conduit/Pipes for porting it
01:30:56 <Cale> I wouldn't expect it
01:31:38 <Cale> You can do anything you can do with pipes without pipes -- it just helps make certain kinds of complex streaming I/O programs easier to write.
01:32:07 <kamyar> What about STM? I know STM/TVar is much more powerful than MVar
01:32:24 <Cale> That's not to say that pipes might not be effective in your case -- it's altogether possible that it would be a good idea to use it if you already knew the library well.
01:32:28 <kamyar> Since I wanna write a multithread program I cant rely on State monad, and at least I have to use MVar
01:32:36 <kamyar> but do I have to?
01:32:57 <Cale> But learning pipes is a big sidetrack to getting things done.
01:33:31 <kamyar> Cale: Maybe MVar fulfills my need! Do u recommend TVar?
01:34:47 <Cale> MVar is often quite good, but sometimes you run into a situation where you really want to atomically manipulate more than one MVar or IORef at a time, and at that point STM begins to shine.
01:35:10 <Cale> (and you'd then switch to TVar and/or TMVar)
01:35:40 <Cale> But there's a lot you can get done with just MVar and Chan
01:35:53 <kamyar> Cale: I just 
01:36:04 <kamyar> Cale: I just need a list of connected users 
01:36:25 <kamyar> Cale: then I could dispatch data to special users
01:37:51 <Cale> kamyar: Depending on the access pattern, a simple MVar with a Map or list of users might be fine.
01:38:47 <kamyar> Cale: Thanks! Really I a, thankful for your great time and help! Sorry if I distracted you! 
01:38:56 <Cale> kamyar: One thing I can recommend is that when you go creating the MVar somewhere near the top level of your program, rather than passing around the MVar, instead write some things which manipulate it, and pass those around
01:39:04 <kamyar> Cale: I really appreciate your help as a Pro Haskell developer!
01:41:05 <kamyar> Cale: As last favor, can u please give me a roadmap for the rest of my way learning haskell?
02:01:09 <dysfun> i am starting to get bogged down by repetitive type signatures. I can see room for abstraction (e.g. if i could declare a custom constraint somehow), but I don't know how. any ideas?
02:05:11 <kamyar> Cale: u there?
02:05:22 <lambdamu> dysfun: you know of ConstraintKinds?
02:05:37 <dysfun> nope
02:06:12 <delYsid> "Could not find package dice-entropy-conduit in known packages" when running "stack install keysafe".  Any ideas?
02:06:49 <lambdamu> dysfun: So is your problem with contexts or with types? you mentioned a custom constraint which would be context, Constraintkinds lets you do that essentially
02:07:13 <dysfun> perhaps i should give you more detail
02:07:52 <lambdamu> dysfun: One constraint kinds examples: type MyMonad m = (MonadIO m, MondState MyState m, LogMonad m)
02:08:09 <dysfun> I am using freer, which declares effects using a type-level list r. to define a function working with it, you put on constraints like Member (State Foo) r
02:08:34 <dysfun> i'm building an interpreter, so i'm freely tapping into these effects, but I have no real means of aggregating them because it's just a constraint on the end function
02:09:08 <dysfun> does your constraint kinds example mean that MyMonad must fit all of those constriants?
02:09:58 <lambdamu> dysfun: yes
02:10:01 <dysfun> sweet :)
02:10:02 <dysfun> thanks
02:10:21 * dysfun adds ConstraintKinds to his toolbelt
02:11:57 <lambdamu> dysfun: another thing i use to cut down type signatures is PartialTypeSignatures, though I don't know how relevant that is in your case
02:12:27 <dysfun> i'll investigate that too. thanks! :)
02:13:37 <lambdamu> dysfun: constraint kinds it pretty general you can also write type families computing with constraints
02:13:47 <dysfun> interesting
02:18:20 <dysfun> oh wow, constraintkinds is making this much cleaner already, thanks a lot :)
02:20:11 <lambdamu> yeah, it's a very pleasant extension I have it on by default, it's very satisfiying to say contexts are just types of kind Constraint
02:20:28 <dysfun> would you say it's safe to enable by default?
02:20:52 <lambdamu> dysfun: I think so, I didn't encounter any downside
02:20:56 <dysfun> sweet :)
02:58:22 * hackagebot unused 0.6.1.0 - A command line tool to identify unused code.  https://hackage.haskell.org/package/unused-0.6.1.0 (joshuaclayton)
02:58:24 * hackagebot servant-swagger-ui 0.2.0.2.1.5 - Servant swagger ui  https://hackage.haskell.org/package/servant-swagger-ui-0.2.0.2.1.5 (phadej)
03:08:22 * hackagebot llvm-ffi 3.6.0 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-3.6.0 (HenningThielemann)
03:48:24 * hackagebot hindent 5.0.1 - Extensible Haskell pretty printer  https://hackage.haskell.org/package/hindent-5.0.1 (ChrisDone)
03:58:50 <joncol> Hi, can stack be used to create new single templated files, instead of whole projects? For instance, when creating a new module...
04:13:24 * hackagebot type-operators 0.1.0.3 - Various type-level operators  https://hackage.haskell.org/package/type-operators-0.1.0.3 (Shou)
04:18:25 * hackagebot llvm-tf 3.0.3.3 - Bindings to the LLVM compiler toolkit using type families.  https://hackage.haskell.org/package/llvm-tf-3.0.3.3 (HenningThielemann)
05:20:25 <jchia_> question about conduit. Why does the documentation on awaitForever say that it "returns the upstream result type" when given the type signature of "... -> ConduitM i o m ()", it it returns ()?
05:21:42 <jchia_> or, am i misunderstanding something about the 4th argument to ConduitM?
05:25:08 <pavonia> jchia_: Maybe this is referring to the handler function you pass it as argument?
05:32:55 <jchia_> Monad m => (i -> ConduitM i o m r) -> ConduitM i o m ()
05:32:55 <jchia_> http://hackage.haskell.org/package/conduit-1.2.7/docs/Data-Conduit.html#v:awaitForever
05:34:12 <lyxia> This is continuation passing style, the value of type i is "returned" to the continuation you provide.
05:35:25 <jchia_> lyxia: Do you mean the 'returns' in "returns the upstream result type" is referring to the i, not the r?
05:35:39 <lyxia> Indeed.
05:37:27 <jchia_> lyxia: OK. I suppose I was confused by the multiple meanings of "result"
05:38:24 <lyxia> yeah maybe it's confusing more than it helps
05:38:51 <lyxia> or I am also interpreting this incorrectly
05:51:55 <joncol> Hi, what's a good way of combining the results of multiple Parsec parsers? For instance, parsing a number surrounded by optional spaces: do P.many P.space >>= \s1 -> P.many1 P.digit >>= \d -> P.many P.space >>= \s2 -> return (s1 ++ d ++ s2). Is there a more succinct way of doing this?
05:52:50 <maerwald> why not use the applicative instance?
05:53:36 <maerwald> (\s1 d s2 -> s1 ++ d ++ s2) <$> P.many P.space <*> P.many1 P.digit <*> P.many P.space -- should work I guess
05:54:22 <joncol> maerwald: that's pretty cool. thx.
05:56:43 <pavonia> joncol: Do you really need the spaces in the result? Otherwise Parsec already has combinators for parsing things between other things, IIRC
05:56:52 <maerwald> :t liftA3
05:56:52 <maerwald> :t \f fa fb fc -> f <$> fa <*> fb <*> fc
05:56:53 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
05:56:53 <lambdabot> Applicative f => (a2 -> a1 -> a -> b) -> f a2 -> f a1 -> f a -> f b
05:56:58 <maerwald> those are the same
05:59:35 <joncol> pavonia: I need the spaces because I have to find a text, and then remove (if found) the text from the original string (including spaces). Maybe regexes would by nicer in this case, but I don't know how to use them in Haskell yet :)
06:00:07 <absence> defining map for lists in terms of foldr is quite easy, but seems like a bit of a challenge for NonEmpty. has anyone tried it? am i missing something obvious?
06:01:09 <maerwald> joncol: regexes are clumsy in haskell and a lot of people will argue that they are "bad" because of that, which they are not. There are some regex libraries though: https://wiki.haskell.org/Regular_expressions
06:01:17 <lyxia> absence: Convert NonEmpty to a list, apply foldr
06:02:02 <absence> lyxia: then you get a list out instead of a NonEmpty, no?
06:03:28 * hackagebot http-streams 0.8.4.0 - An HTTP client using io-streams  https://hackage.haskell.org/package/http-streams-0.8.4.0 (AndrewCowie)
06:04:00 <dramforever> Only those (\[:a!^]?=) regexes are ugly. Check out https://hackage.haskell.org/package/regex-applicative for regex combinators
06:04:48 <joncol> maerwald: is there a nice way of lifting some function to avoid having to write the expression \s1 d s2 -> s1 ++ d ++ s2 ?
06:04:52 <lyxia> absence: Ah, I see your point.
06:07:36 <dramforever> Hmm...Why don't MonadComprehensions and ApplicativeDo work together?
06:09:52 <hpc> maerwald: it's more that there's just better options than stringy regexes
06:10:14 <hpc> maerwald: i quite like regexes in other languages, but they're /relatively/ bad in haskell due to the presence of other libraries
06:16:50 <absence> lyxia: i guess the "z" would have to be a nonempty list with the last element instead of [], which means it would have to traverse the nonempty list twice
06:18:28 * hackagebot generic-deriving 1.11 - Generic programming library for generalised deriving.  https://hackage.haskell.org/package/generic-deriving-1.11 (ryanglscott)
06:26:34 <pavonia> In this FunPtr example <https://en.wikibooks.org/wiki/Haskell/FFI#Passing_Haskell_Functions_to_the_C_Algorithm> they declare a wrapper function "makeFunPtr :: CFunction -> IO (FunPtr CFunction)" but don't give an implementation of this function. What would it look like?
06:27:22 <pavonia> I found other examples of this in the mailing list but all omit the important part :S
06:31:25 <pavonia> Oh wait, it does generate the C file automatically for this
06:49:01 <alpounet> pavonia: yes, the glue is written for you. you basically just have to "declare" that wrapper
06:58:29 * hackagebot text-show 3.4 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-3.4 (ryanglscott)
07:02:53 <pavonia> The documentation of the freeHaskellFunPtr says "This should be called whenever the return value from a foreign import wrapper function is no longer required". This is a bit confusing because if I free the pointer after I registered a handler function to a foreign function, and thus don't need the pointer value anymore, my program crashes with "internal error: stg_ap_p_ret" whenever the...
07:02:55 <pavonia> ...handler is called
07:04:51 <pavonia> However, if I don't free the pointer at all, it works fine
07:07:01 <ertesx> pavonia: you're still using the pointer
07:08:44 <pavonia> Yeah, I guess that makes sense, but it's a bit confusing first
07:10:01 <ertes> pavonia: a pointer is a memory reference – a number…  whether you use that number from haskell or C doesn't matter, you're using it
07:12:27 <dramforever> pavonia: I suppose registering the function == registering the function pointer?
07:12:49 <pavonia> Yes
07:15:48 <ertes> a haskell function, unlike a C function, is an abstract object…  it may not have a clear memory address and may have extra data (like a closure) associated with it
07:16:08 <ertes> the wrapper turns all of that into a concrete memory reference that can be treated as a C function
07:17:14 <ertes> this requires allocation and an intentional blind spot in the garbage collector (because it can't track whether pointers are used in foreign code)…  that's why you need to free them yourself after you used them
07:18:30 * hackagebot llvm-ffi 3.7.0 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-3.7.0 (HenningThielemann)
07:23:30 * hackagebot text-show-instances 3.4 - Additional instances for text-show  https://hackage.haskell.org/package/text-show-instances-3.4 (ryanglscott)
07:23:46 <pavonia> Which makes it a bit harder because I have to keep track of the pointer until the handler is finally removed (if I should even take care of this)
07:40:28 <saurabhnanda> ping
07:40:40 <saurabhnanda> how come the channel is so quiet today?
07:41:13 <PunkFrog> is this quiet? never been on before.
07:41:33 <saurabhnanda> what happens to all the category theory talk today?
07:41:47 <saurabhnanda> bifunctors, profunctors, contramaps, semigroupid?
07:42:09 <PunkFrog> for that conversation I would be a learner / observer
07:42:19 <saurabhnanda> he he
07:42:22 <saurabhnanda> PunkFrog: what're you using Haskell for?
07:42:54 <PunkFrog> been doing imperative langs too long. Haskell is my way out ;)
07:43:29 <PunkFrog> right now trying to use hmatrix to do some simple linear regression stuff
07:44:07 <saurabhnanda> hmm
07:45:02 <PunkFrog> and looking for a good plotting package. Trying to use gnuplot, it's not cooperating with my subliminal suggestions
07:48:03 <saurabhnanda> which other language have you worked with?
07:48:07 <saurabhnanda> and what did you use it for?
07:48:25 <PunkFrog> C++, Java, Scala, some Python
07:48:59 <PunkFrog> back in the day I wrote assembly language drivers for Wintel add-on hardware
07:49:29 <PunkFrog> more recently IT-related J2EE websites - not interesting but remunerative
07:52:23 <PunkFrog> Interested in Haskell because if purity, parallelism, static typechecking, and mindbending abstractions that might even be useful
07:53:09 <PunkFrog> saurabhnanda: are you working with langs other than Haskell?
07:53:23 <saurabhnanda> PunkFrog: yes. Ruby and Javascript.
07:54:07 <mniip> saurabhnanda, I figured out a fancy trick recently
07:54:24 <mniip> that bi/profunctors can be "curried"
07:54:39 <saurabhnanda> must be quite a gravy train :)
07:54:53 <saurabhnanda> I still don't know how to USE these abstractions
07:54:54 <mniip> you turn a bifunctor CxD->E into a functor C->[D,E]
07:54:58 <rick____> Hello everyone
07:55:06 <saurabhnanda> sometimes it just seems to me that people spot these interesting properties and go harping about them
07:55:09 <saurabhnanda> what's the real-life use-case
07:55:10 <saurabhnanda> I don't know
07:55:20 <Rembane> mniip: Can you give an example on where it's useful?
07:55:43 <mniip> Rembane, you can use the same 'fmap' to map over both arguments of a bifunctor
07:56:17 <mniip> just in one case fmap will give you a Hask morphism, and in the other case it will give you an End(Hask) morphism
07:56:26 <mniip> a natural transformation
07:57:03 <rick____> I recently found out that Text.PrettyPrint.Boxes makes it very easy to work with tables, while with Text.PrettyPrint, just to give an example, is almost impossible to tile horizontally two or more tables (at least for me it was). Unfortunately, Text.PrettyPrint.Boxes  is not updated since 2009. So I would like to know if there is a (more recent) library for formatting tables better than the two I just mentioned.
07:57:38 <Rembane> mniip: I'm afraid I don't follow. Lets see... what's a bifunctor?
07:58:43 <saurabhnanda> RFC: https://github.com/vacationlabs/haskell-webapps
07:59:44 <tsahyt> Hello! I've got some code returning a (SomeMonadConstraints m) => m (Either e a) for some e and a. I thought about refactoring it to return ExceptT e m a, but I'm not sure if this would even make sense as the control flow is quite understandable right now. So my question is stylistic, when should I use one over the other?
08:01:31 <saurabhnanda> ==> Request for comment (especially from people building webapps in Haskell): https://github.com/vacationlabs/haskell-webapps <==
08:02:19 <Welkin> saurabhnanda: comment on what exactly?
08:02:47 <mniip> Rembane, a functor from a cartesian product of two categories
08:03:02 <Welkin> saurabhnanda: I think it's a good idea, since there are people who often ask what to use in here
08:03:04 <Rembane> mniip: Nice!
08:03:13 <saurabhnanda> Welkin: Comments/feedback on the idea actually. I'm wondering if this is just my concern or is this something that the community will appreciate.
08:03:13 <mniip> usually the multiplied categories are the same
08:03:42 <saurabhnanda> Welkin: and if the idea is good, then the approach. How to get the best ROI. Which libraries am I missing? Which can be dropped? 
08:03:50 <saurabhnanda> Any flaws that you can spot?
08:03:52 <Welkin> I usually tell them yesod if you are building some kind of CMS website, or servant if you just need a json api, with either reflex or elm for the frontend
08:04:54 <saurabhnanda> Welkin: and how many of them actually complete the project and deploy it to production?
08:05:11 <Welkin> saurabhnanda: I don't think including bootstrap and css stuff makes sense
08:05:29 <Welkin> saurabhnanda: I don't know, but I have deployed all of mine to production
08:05:43 <Welkin> at least the yesod ones
08:06:46 <saurabhnanda> actually yesod seems to be the most mature framework. And also well documented.
08:06:52 <saurabhnanda> but I got stack very, very bad with it.
08:06:56 <saurabhnanda> *stuck
08:07:05 <sm> saurabhnanda: sounds great! and a lot of work
08:07:12 <Welkin> yes
08:07:19 <Welkin> I did almost everything you mentioned on that page with just yesod
08:07:33 <Welkin> I had to read a lot of sourcecode to figure it out though
08:07:35 <Welkin> and ask around a lot
08:09:44 <saurabhnanda> actually, I was trying to read-up on the  the Yesod deployment story right now. Does it copy over your executable to your prod server and **gracefully** restart your app?
08:09:45 <Welkin> saurabhnanda: I think it would make sense to have a brief section where you recommend defaults, then you can go into detail for people who want to learn more or have a special situation
08:09:49 <saurabhnanda> and what's the rollback story?
08:09:55 <saurabhnanda> and migrations?
08:10:03 <Welkin> I have been using keter for deployment and it is trivially easy
08:10:13 <Welkin> persistent does the migrations
08:10:23 <saurabhnanda> and static asset minifications?
08:10:24 <Welkin> but you have to manually delete or rename columns/tables yourself
08:10:29 <Welkin> it does not do destructive migrations
08:10:45 <Welkin> you can add that into the build step, sure
08:10:48 <saurabhnanda> how does that work for a deployment scenario? longish downtime?
08:10:52 <Zemyla> https://twitter.com/Papapishu/status/693871840318590976
08:10:55 <orion> If I have a choice, under what circumstances should I prefer lazy data structures like Data.Text.Lazy, and when would it be better to prefer strict ones like Data.Text?
08:11:00 <Welkin> you can use the middleware to minify/gzip things
08:11:12 <Zemyla> Wait, wrong channel.
08:11:14 <saurabhnanda> so, not bundled by default?
08:11:18 <Welkin> orion: if you need the whole thing at some point, use strict
08:11:41 <Welkin> saurabhnanda: you just add an extra function to the pipeline in Application.hs
08:11:52 <Welkin> there are settings you can enable for it
08:12:22 <Welkin> saurabhnanda: there is zero downtime for deployment with keter
08:12:29 <Welkin> and you can use keter with anything, not just haskell things
08:12:36 <Welkin> any web server you want
08:12:48 <saurabhnanda> rollbacks?
08:12:56 <Welkin> keter starts up your new app and checks to make sure it is running before shutting down the old one
08:12:58 <saurabhnanda> does it maintain the last N versions you've deployed, for quick rollback?
08:13:05 <Welkin> not sure
08:13:09 <Welkin> I haven't looked into that
08:13:23 <sm> Welkin: thank you for explaining what keter actually does (finally I understand) :)
08:13:25 <Welkin> I'm sure snoyberg wuold add it if asked
08:13:34 <Welkin> all you do is push a keter bundle to the server
08:13:46 <saurabhnanda> sm: yeah, the tutorial on github isn't that great.
08:13:52 <Welkin> which is just a zip ending in .keter
08:14:14 <Welkin> er, a tar
08:15:51 <Welkin> saurabhnanda: also should mention that servant-client is incredible for writing web api bindings
08:16:04 <Welkin> I wrote 3 for my last project
08:16:31 <saurabhnanda> Welkin: I'm very bullish on Servant
08:16:34 <nitrix> Can I force a garbage collection pass on program's cleanup ?
08:16:44 <Welkin> saurabhnanda: in english?
08:16:44 <saurabhnanda> I'm going to do Servant + Opaleye in this exercise
08:16:52 <Welkin> bull is good, right?
08:17:01 <saurabhnanda> stock market reference
08:17:04 <Welkin> yeah
08:17:10 <saurabhnanda> bullish => positive outlook
08:17:14 <saurabhnanda> bearish => negative outlook
08:17:20 <Welkin> I looked into opaleye, but found it too much work
08:17:24 <Welkin> and had no migrations
08:17:30 <Welkin> I just use Persistent by default
08:17:44 <Welkin> with esqueleto when necessary (or even raw sql if I have to)
08:18:05 <saurabhnanda> Welkin: how do you deal with generating nested JSONs where the data source is a complicated set of related DB tables?
08:18:19 <Welkin> nested json?
08:18:30 <Welkin> you mean json in postgres?
08:18:48 <Welkin> I've stored json in postgres before, but I think I just stored it as a string
08:18:50 <saurabhnanda> Welkin: Esqueleto is *bad.* So much nonsense about type-safe JOINs and the wrong order of `on` clauses compiles, but errors at runtime.
08:19:04 <Welkin> yeah, I haven't used esqueleto that much
08:19:10 <Welkin> my queries were to custom for it anyway
08:19:20 <Welkin> so I used persistent and `rawsql` last time
08:19:31 <Welkin> too*
08:19:43 <saurabhnanda> Welkin: let the JSON problem be. Takes very long for me to explain. I'm not sure why other people don't see that problem almost immediately when you're dealing with any complicated database schema.
08:19:45 <Welkin> which is one reason I like the idea of opaleye
08:20:22 <Welkin> oh, you mean reconstructing json from various queries?
08:23:25 <jchia_> Is there a package that allows me build a task scheduler that knows dependency? A task is roughly a process that takes some input params and needs to run to compute some output. A task may use as input the output of zero or more output tasks, so it can't start until those are finished. The user can create tasks (specifying dependencies for each task, if any) and the system must start them in an order consistent with the partial ordering defined by the task de
08:23:42 <jchia_> Which packages can be helpful for building something like this?
08:24:58 <jchia_> *A task may use as input the outptu of zero or more _other_ tasks*
08:26:16 <saurabhnanda> Welkin: yes. one:many relationship. many:many relationship.
08:27:21 <sm> jchia: async, maybe shake ?
08:34:44 <magneticduck> jchia_: a 'package'?
08:34:47 <jchia_> sm: The scheduler don't necessarily need to use multiple threads. I just needs to start (fork) new processes
08:35:27 <jchia_> magneticduck: packages that allow me to express the computation (e.g. the depedency semantics) so that i don't have to reinvent the wheel
08:36:51 <sync2k16> http://ilredentore.dynv6.net/ updated :)
08:37:43 <ertes> pavonia: you should, unless you're fine with a memory leak
08:39:34 <jchia_> sm: as i understand, shake is a build system. do you know of cases where people use it for something other than building software?
08:39:59 <sm> no
08:43:23 <ertes> jchia_: shake is a better 'make'
08:43:33 * hackagebot emailaddress 0.1.2.0 - Wrapper around email-validate library adding instances for common type classes.  https://hackage.haskell.org/package/emailaddress-0.1.2.0 (cdepillabout)
08:43:46 <ertes> jchia_: it handles cases like dynamic dependencies and non-files
08:45:50 <jchia_> ertes: yeah, it encapsulates the idea of dependencies but i don't know whether i can use it for expressing dependency in a task queue
08:46:35 <jchia_> another way i could ask my question is: is there a task queue package? is there one that can express dependencies?
08:48:29 <jchia_> in python there's celery, but afaik it can't express task dependencies. is there a haskell task queue?
08:50:16 <Welkin> jchia_: http://hackage.haskell.org/packages/search?terms=queue
08:50:31 <Welkin> just search hackage
08:50:33 <Welkin> I found this
08:50:40 <Welkin> http://hackage.haskell.org/package/kazura-queue
08:51:01 <Welkin> oh, nevermind
08:51:04 <Welkin> that is a fifo queue
08:51:06 <aarvar> Is there an Endo newtype which abstracts over category? Or a KleisliEndo?
08:51:27 <Welkin> here we go
08:51:28 <Welkin> http://hackage.haskell.org/package/jobqueue
08:51:57 <Welkin> this too http://hackage.haskell.org/package/yesod-job-queue
08:52:00 <ongy> can I not use a type (typedef) inside a Class declaration with associated types?
08:52:01 <buglebudabey> aarvar maybe this is what you mean https://hackage.haskell.org/package/endo-0.3.0.1/docs/Data-Monoid-Endo.html
08:52:47 <aarvar> buglebudabey: I need a -> m a
08:53:35 <buglebudabey> is that still an endo then?
08:53:44 <glguy> some: newtype T k a = C (k a a); instance Category k => Monoid (T k a) ?
08:53:49 <aarvar> yeah
08:53:54 <aarvar> exactly
08:54:19 <glguy> I don't know of one in base, but it seems like that would make sense to have
08:54:31 <aarvar> yeah, I'm wondering if it exists somewhere
08:54:39 <aarvar> seems like it would
08:56:32 <jchia_> Welkin: OK. I still haven't found anything that can express dependencies
08:57:13 <Schrostfutz> Hi, I seem to be unable to get the Hello World of my tutorial running. This is the code: http://sprunge.us/eTgb?hs but I get a "last line of do block must be an expression" error . What am I doing wrong?
08:57:20 <Welkin> a queue by definition has dependencies
08:57:29 <Welkin> you adjust the priority of each task
08:58:17 <pavonia> Schrostfutz: The indentation is wrong, you shouldn't use tabs in your Haskell file
08:58:24 <aarvar> glguy: found one https://hackage.haskell.org/package/SimpleH-0.9.1/docs/SimpleH-Core.html
08:59:01 <jchia_> Welkin: Are you talking about jobqueue? 
08:59:38 <Schrostfutz> pavonia: Oh. didn't know that. Now I get a different error, a Syntax error at "putStrLn"
09:00:25 <aarvar> and another one https://hackage.haskell.org/package/monoid-extras-0.4.2/docs/Data-Monoid-Endomorphism.html
09:01:00 <pavonia> Schrostfutz: Could you paste the new version too?
09:01:23 <pavonia> Schrostfutz: Make sure args and putStrLn are aligned
09:01:29 <monochrom> no, there is a computational gap between dependency and priority. from dependency, you have to compute a topologic sort before you have priority.
09:03:34 <Schrostfutz> pavonia: The alignment was the error. Thanks so much, it seems I missed the part about alignment being important...
09:04:02 <pavonia> Yup, it is very important in Haskell
09:04:05 <ahsfhyicxv> Does a generic version of liftIO, eitherToMonadError, mfromMaybe, etc. exist?
09:04:09 <jchia_> Welkin: priority normally means which task wins when there's contention for resources. dependency is something else
09:04:24 <Welkin> right, but what monochrom just said is how you do it
09:04:36 <Welkin> it's just a graph sort
09:05:19 <Welkin> I saw several other job queues and bindings to things like zeromq as well
09:05:26 <Welkin> take a closer look at that search page on hackage
09:05:34 <monochrom> Still, the two questions "how/what to code it up myself" and "does hackage have it" are very different questions.
09:07:22 <bollu> guys, I need a (preferably modern) openGL library
09:07:26 <bollu> what do I pick?
09:09:33 <Welkin> bollu: gl
09:09:36 <Welkin> @hackage gl
09:09:36 <lambdabot> http://hackage.haskell.org/package/gl
09:09:45 <jchia_> Welkin: The task scheduler starts tasks in parallel according to resource constraints. It's not running the task one-by-one.
09:10:36 <jchia_> It's not scheduling by computing a static order of tasks
09:13:32 <monochrom> then you don't need your own queue, do you? you just have to use a thread for a task, and use some concurrency primitive to get a thread blocked for waiting on another thread's answer. Then the thread scheduler will sort it out for you.
09:14:21 <monochrom> in which case the async library is a pretty high level and convenient way. but you can use threads and MVar's yourself directly too.
09:16:04 <jchia_> monochrom: the scheduler needs to support multiple dependencies, being able to tell whether a task has succeeded or failed (so that it can decide whether downstream tasks can be started). the queue could be provided by some external component -- e.g. i could use redis or rabbitmq but those have no concept of dependencies, afaik
09:18:33 <jchia_> monochrom: i suppose i could model the tasks as threads. however, if the process crashes for whatever reason, i won't be able to restore the state of the tasks (which tasks have finish, which haven't started, which are running), right?
09:18:44 <jchia_> i mean the scheduler process
09:19:34 <jchia_> what kind of thread synchronization mechanism are available in haskell?
09:20:20 <jchia_> i.e. does it have anything special that's not a semaphore, mutex, or pipe?
09:22:52 <jchia_> can mvar have multiple receivers? if i use mvar to signal that a task is finished, multiple downstream tasks need to know about it
09:24:49 <bollu> Welkin: that is the standard I assume?
09:25:11 <bollu> Welkin: uhh, that's pretty freaking low level
09:25:13 <fr33domlover> jchia_, the MVar module iirc has some multi-wakeup functions, check if those help you
09:25:17 <bollu> Welkin: is there something like glium?
09:25:42 <jchia_> monochrom: i'm not familiar with concurrency in haskell, but i think QSem may be more suitable than MVar because MVar take is destructive and i have multiple downstream dependents. OTOH, waitQSem is not destructive
09:26:08 <glguy> jchia_: You can use a normal MVar and have all the downstream tasks use readMVar
09:26:16 <Welkin> bollu: lol, that is pretty much all we have in haskell at this point, raw opengl bindings
09:26:26 <Welkin> there are some higher level ones, but they deviate from the API
09:27:25 <ertes> jchia_: unlikely that you can use shake for that…  rather seems like you need a data structure
09:27:41 <jchia_> glguy: OK, I see that readMVar is non-destructive
09:27:45 <fr33domlover> bollu, there are other libs on top of OpenGL, depends on what exactly you want to do
09:27:59 <ertes> jchia_: but if by "task" you mean an actual IO action, there are other options, and without reading the backlog i'm guessing that most of them have already been mentioned
09:28:02 <fr33domlover> I mean, Haskell ones
09:28:20 <bollu> fr33domlover: I want something that simplifies shaders basically. Takes care of the messy API calls and gives me some type safety
09:28:31 <bollu> fr33domlover: some text rendering would be nice too, but I think that's asking for too much
09:28:56 <Welkin> bollu: something like gloss?
09:29:02 <ertes> bollu: https://hackage.haskell.org/package/luminance
09:29:04 <jchia_> ertes: my tasks are usually external processes that the scheduler needs to start
09:29:08 <Welkin> http://hackage.haskell.org/package/gloss
09:29:21 <sm> http://hackage.haskell.org/package/ombra
09:29:24 <ertes> bollu: i haven't used it, but it looks promising and like something you could actually use for real stuff (unlike gloss)
09:29:36 <jchia_> ertes: It seems that the most missing piece is the dependency semantics
09:30:08 <Welkin> ertes: nice, I haven't seen that one yet
09:30:19 <ertes> jchia_: do you need dependencies to be first class?  i mean: do you need to compute with dependencies?  or do you just need tasks to be started in order?
09:30:55 <jchia_> i just need to start the tasks in an order consistent with the dependencies
09:31:05 <bollu> sm: what is ombra?
09:31:05 <bollu> ertes: thank you
09:31:09 <jchia_> multiple tasks running concurrently according to available resources
09:31:22 <ertes> jchia_: hmm, actually that sounds a lot like something shake does very well
09:31:29 <sm> I just gave you a link to its description :)
09:31:34 <bollu> luminance v/s ombra?
09:31:42 <fr33domlover> could use topsort / priority queue to maintain the pending tasks?
09:31:47 <sm> nobody knows, it was released yesterday
09:31:52 <fr33domlover> and then pick them one by one from the structire etc.
09:31:53 <jchia_> it doesn't except i don't know how well it would work if i were to use it for something other than building software and i'm not familiar with it
09:31:56 <bollu> seriously? -_^
09:32:02 <sm> do some homework :)
09:32:08 <bollu> sm: :)
09:32:11 <Welkin> sm: another new lib I haven't seen
09:32:21 <Welkin> these look promising
09:32:37 <ertes> bollu: luminance and ombra look very similar in scope and purpose, though ombra seems higher-level…  ultimately you'll just have to try them out
09:32:49 <bollu> ertes: cool, I think I will give luminance a shot
09:33:00 <bollu> ertes: I'm trying to build a graphics-aware file explorer 
09:33:09 <bollu> ertes: let's see how the experiment goes :P
09:33:22 <Welkin> this is also something to look into http://lambdacube3d.com/
09:33:27 <ertes> bollu: do you really want to build the UI toolkit from the ground up?  because that's what you're going to do if you use either of those
09:33:33 <bollu> Welkin: I've tried getting lambdacube up
09:33:34 * hackagebot mars 0.2.0.0 - Generates mountainous terrain using a random walk algorithm.  https://hackage.haskell.org/package/mars-0.2.0.0 (infrared)
09:33:35 <Welkin> although it is a DSL built on top of haskell I believe, not actually haskell
09:33:39 <bollu> ertes: yes, I do to be honest
09:33:53 <bollu> ertes: I'm trying to reimagine what a shell-ish file explorer could be like
09:33:54 <ertes> bollu: then go ahead, but prepare to be working on it for a while =)
09:34:01 <bollu> ertes: that's what pet projects are for! =)
09:34:54 <ertes> bollu: you probably need to find a solution for rendering text, too…  there is cairo/pango, but i have not the slightest clue how well they work in practice
09:35:27 <ertes> rendering text is surprisingly difficult, especially with the lack of support in haskell outside of existing toolkits (like GTK)
09:35:44 <fr33domlover> http://hackage.haskell.org/package/caramia
09:35:57 <fr33domlover> this too... all depends on requirements, bollu :P
09:36:19 <fr33domlover> perhaps play with them a bit
09:36:36 <Welkin> there is also sdl_ttf you can use
09:36:39 <Welkin> with sdl2
09:36:41 <bollu> ertes: really? can't you use HarfBuzz and have it give you the textures?
09:36:45 <bollu> ertes: haven't used it
09:36:51 <bollu> ertes: but I believe it's capable
09:37:16 <ertes> bollu i'm not familiar with HarfBuzz
09:37:21 <bollu> omfg so many libraries 
09:37:45 <bollu> I need help deciding >_<
09:38:07 <ertes> start with the one that looks most maintained
09:38:17 <ertes> look at repo activity and latest release *date*
09:38:19 <bollu> ertes: I think that is luminance right?
09:38:27 <ertes> i think, both are maintained
09:39:11 <ertes> if the last release was in 2015 or 2016, it's probably "maintained", but if you see a library from 2009, it's reasonable not to even bother
09:39:50 <ertes> there are also cases if libraries that haven't been released for a long time, but they do have regular repo activity…  accelerate was like that for a long time
09:39:54 <ertes> s/if/of/
09:41:45 <Welkin> what are you using for input handling bollu?
09:42:03 <Welkin> if you are already using sdl2, you can use sdl2_ttf
09:42:19 <fr33domlover> bollu, http://hackage.haskell.org/package/font-opengl-basic4x6
09:42:29 <fr33domlover> this may help but it seems very basic
09:42:34 * sm would start with fltkhs and port later
09:42:50 <ertes> i'd start with sdl2 right away
09:43:01 <Welkin> http://hackage.haskell.org/package/sdl2-ttf
09:43:38 <ertes> it's the least intrusive library that gives you windows you can render into and a stream of events you can handle
09:43:57 <ongy> when I have a function with '\x -> do y <- newStablePtr x; z <- newStablePtr x' is it guaranteed that y == z?
09:44:41 <bollu> sm: what's fltkhs?
09:44:56 <Welkin> fl toolkit (haskell)
09:45:17 <fr33domlover> bollu, http://hackage.haskell.org/package/FreeTypeGL
09:45:21 <bollu> sm: but, no fun :)
09:45:29 <fr33domlover> (tell me to stop if you don't need more links :P)
09:46:00 <bollu> ertes: I guess that is reasonable (SDL that is)
09:46:06 <bollu> can I use luminance with SDL?
09:46:10 <ertes> ongy: no
09:46:14 <bollu> damn
09:46:15 <bollu> as in, can I hand the SDL render context over to luminance?
09:46:17 <sm> the only mature, just-works cross platform haskell GUI framework
09:46:19 <bollu> wait, no?
09:46:20 <Welkin> fr33domlover: that is deprecated
09:46:22 <ertes> ongy: in fact it's very unlikely
09:46:30 <ertes> bollu: that "no" was not for you
09:46:34 <bollu> ertes: ah
09:46:38 <ertes> bollu: and yes
09:46:42 <bollu> ertes: I can? :D
09:46:45 <bollu> yiss
09:47:07 <ertes> sm: just-works on windows?
09:47:43 <bollu> this the correct SDL package? https://hackage.haskell.org/package/sdl2
09:47:49 <ertes> bollu: yeah
09:48:15 <fr33domlover> Welkin, oops didn;t notice. But there's the similar FTGL which isn't
09:49:13 <bollu> how do you guys write haskell tutorials?
09:49:27 <bollu> as in, the code should be compilable right? so how do you ensure that what you post remains compilable?
09:49:30 <sm> ertes: well, the closest we can manage right now, as in there's a short up-to-date maintained repeatable recipe for it
09:49:55 <sm> bollu: literate haskell files are often used
09:50:11 <ertes> bollu: you maintain it
09:50:25 <bollu> sm: but I have a problem with lhs - what if I want to have three separate examples, each of which exaplain some part, and then have all of them tied together?
09:50:29 <bollu> sm: I'm not sure how to do that
09:50:30 <fr33domlover> bollu, if you care a lot about it building you can use a cron job to build it, say, once a week :P
09:50:41 <fr33domlover> and if it fails it sends you an email so you can fix it etc.
09:50:54 <bollu> sm: I've written a you application called "warp" - It was a really fun experience, and I'd like to share my experience
09:51:00 <bollu> sm: but I'm hesitant
09:51:04 <bollu> sm: because I don't really know how to write 
09:51:08 <sm> bollu: me neither. The pet project is growing! :)
09:51:13 <bollu> sm: I don't know if that makes sense :P
09:51:39 <bollu> sm: age also makes me feel a little weird. I'm 19 >_<; don't know if I know enough to teach other people 
09:51:41 <ertes> bollu: call them 'example1', 'example2' and 'example3' instead of 'example'
09:51:42 <sm> I think the only way to get good at writing is just write and put it out there
09:51:56 <sm> and avoid over-complex technology that would block you
09:52:07 <bollu> I see
09:52:09 <bollu> hm
09:52:22 <sm> I've seen some folks put serious posts on github gists
09:52:23 <ertes> bollu: or even better: give them descriptive names…  surely there is some noteworthy difference between the examples, right?
09:52:37 <bollu> ertes: good point
09:52:46 <bollu> sm: gists are fugly, they get lost too quickly
09:53:09 <bollu> orthogonal question: how do I upgrade stack?
09:53:13 <ertes> i've put serious tutorials on lpaste =)
09:53:14 <Gurkenglas> stack upgrade
09:53:15 <fr33domlover> you can write in pandoc markdown, then `pandoc` it and upload the HTML to your favorite location...
09:53:29 <bollu> uhh, I'm behind a proxy
09:53:36 <bollu> stack isn't able to fetch build plans
09:53:55 <nabs> Does anyone have a good resource for explaining parsers in general? I'm struggling with the concept. 
09:54:20 <pavonia> Parsers or parser combinators?
09:54:24 <fr33domlover> nabs, you mean like parsec, or the theory of parsing in the math sense
09:54:37 <fr33domlover> *?
09:54:52 <nabs> well i took at look at the parsec page and it didnt make sense
09:55:06 <nabs> i guess parsers in genreal
09:55:24 <Welkin> nabs: go through the applicatives portion of the UPenn course
09:55:29 <fr33domlover> nabs, parsers in general is a way more complicated topic than just using parsec :)
09:55:31 <sm> bollu: just download the latest binary then
09:55:33 <Welkin> it teaches you how to build a parser from first principles
09:55:37 <fr33domlover> you can read some examples
09:55:42 <nabs> oh ok
09:55:42 <Welkin> @where learnhaskell -- nabs 
09:55:42 <lambdabot> https://github.com/bitemyapp/learnhaskell
09:55:46 <fr33domlover> that's how i learned parser combinators
09:55:46 <bollu> sm: hm, right
09:55:51 <monochrom> https://github.com/JakeWheat/intro_to_parsing is a parsec tutorial
09:56:30 <Welkin> nabs: http://www.seas.upenn.edu/%7Ecis194/spring13/lectures.html
09:56:34 <nabs> Thanks, will read.
09:57:34 <nabs> I just thought that since parsers are general to many languages, there is something fundamental that I'm missing
09:58:09 <nabs> I'll focus on parsec for now
09:58:19 <alercah> nabs: https://www.amazon.ca/Introduction-Theory-Computation-Michael-Sipser/dp/113318779X
09:58:49 <sm> I'd like something like that too. More general than "parser combinators", and brief. Start at wikipedia I guess
09:59:13 <bollu> I have a Coq question
09:59:28 <bollu> the Polymorphic type inference isn't working for me in Poly.v
09:59:44 <glguy> This is the wrong channel for Coq questions
10:00:10 <Welkin> is there a #coq ?
10:00:27 <bollu> Welkin: there is, but it is dead
10:00:32 <bollu> Welkin: (usually dead)
10:00:33 <Welkin> lol
10:00:40 <glguy> That's not a license to be off-topic in #haskell
10:00:42 <bollu> glguy: usually Cale or someone responds :)
10:00:51 <bollu> glguy: fair enough, sorry
10:01:06 <Welkin> bollu: you can ask in #category-theory
10:01:23 <bollu> Welkin: interesting, did not know that existed
10:13:17 <jmcarthur> Why is #category-theory any more relevant for Coq questions than #haskell? That's a confusing recommendation.
10:14:16 <mniip> because coq is a different language
10:14:38 <mniip> it's relevant to ct which is relevant to haskell
10:14:42 <mniip> 2 cuils
10:15:41 <monochrom> I think it is only because Cale runs it and Cale allows everything.
10:18:20 <vinylstuffsandth> In the Vinyl library you can ahve something like '(Sleeping ∈ fields) => Rec Attr fields -> Rec Attr fields. Is there anything like existential quantification for constraints that would let me supply "Sleeping" and replace it with say, "Name", thereby requiring the subsequent Rec Attr fields parameters contain the "Name" field label instead of "Sleeping"?
10:20:43 <dmwit> That doesn't sound like existential quantification to me. Also I don't know the answer to your question, but suspect no.
10:23:51 <ahsfhyicxv> If Maybe is a MonadPlus and a MonadPlus can be cast to a list, why can't maybe be cast to a list?
10:24:37 <dmwit> 1. MonadPlus can't be cast to a list
10:24:44 <dmwit> 2. Maybe can be converted to a list in several ways
10:24:51 <dmwit> 3. casting isn't really a thing in Haskell
10:25:16 <dmwit> :t maybeToList
10:25:18 <lambdabot> Maybe a -> [a]
10:25:46 <dmwit> Oh, I think I understand the point of confusion that led to this question.
10:25:50 <ahsfhyicxv> dmwit: I know about maybeToList
10:26:04 <ahsfhyicxv> mfromMaybe (Just 5) :: [Int]
10:26:07 <dmwit> A value of type `MandPlus m => m a` can take on type `[a]`.
10:26:07 <ahsfhyicxv> [5]
10:26:27 <dmwit> But a value of type `Maybe a` can't (directly) be given type `MonadPlus m => m a`.
10:28:21 <ahsfhyicxv> z :: (MonadPlus m) => m a -> m a
10:28:21 <ahsfhyicxv> z x = x
10:28:21 <ahsfhyicxv> z (Just 5)
10:28:59 <dmwit> You are fooling yourself. You haven't given `Just 5` the type `MonadPlus m => m Int`; rather, you have given `z` the type `Maybe Int -> Maybe Int`.
10:29:01 <Schrostfutz> Is there a resource where I can find explanations for the most common error messages in Haskell? Beginning to learn it I find it difficult to interpret the messages.
10:29:40 <dmwit> (Specifically in the application `z (Just 5)`, I mean.)
10:29:53 <ahsfhyicxv> dmwit: Oh. It makes sense now.
10:29:57 <ahsfhyicxv> Thanks
10:30:23 <mniip> ahsfhyicxv, it is neccessary to clarify that when we say that Maybe a is a Monad m => m a
10:30:28 <dmwit> Schrostfutz: I don't know of one, but you could consider asking a few questions here.
10:30:31 <mniip> we mean that Maybe a can be used in place of the latter
10:30:38 <mniip> but not necessarily vice versa
10:30:44 <MarLinn> Schrostfutz: There's a list for hugs: https://www.cs.kent.ac.uk/people/staff/sjt/craft2e/errors.html
10:30:46 <mniip> it's not equality
10:30:48 <mniip> it's subtyping
10:31:21 <MarLinn> A little out of date and not for ghci, but most are almost the same
10:33:08 <mniip> shachaf, when you say that forall and exists are products and coproducts
10:33:28 <mniip> do you mean forall a. f a = \product_{a \in Hask} f a
10:33:49 <dmwit> mniip: That's what I would mean if I said it.
10:34:09 <mniip> that makes some sense because forall a. f a ~~ f Void
10:34:09 <shachaf> Yes, something like that.
10:34:14 <Schrostfutz> dmwit: Okay, it's just that I feel really stupid asking questions so frequently. However: I want my code to give the result of an addition: http://sprunge.us/RPPc?hs. I get an error "No instance for (Read (IO a0)) arising from use of 'read'" which I don't undestand
10:34:25 <mniip> but with exists a. f a = \sum_{a \in Hask} f a
10:34:31 <shachaf> mniip: That's not true.
10:34:36 <mniip> how can you say that exists a. a has only one inhabitant
10:34:54 <dmwit> Schrostfutz: Ah. In this case explaining the error message is a bit convoluted, but explaining the problem is pretty easy.
10:35:11 <shachaf> Well, hmm.
10:35:13 <Schrostfutz>  MarLinn: I couldn't find the current ghc error in the list unfortunately
10:35:18 <dmwit> Schrostfutz: Use `x <- y` for binding IO actions; use `let x = y` for defining pure values.
10:35:54 <Schrostfutz> dmwit: A pure value is a value not bound in a monad?
10:36:07 <dmwit> Schrostfutz: To a first approximation, that's right.
10:36:45 <Schrostfutz> dmwit: Okay. But isn't x in a monad, too because it depends on a monadic value? (Sorry about probably abusing the terminology...)
10:37:05 <dmwit> Schrostfutz: That's actually a pretty good question!
10:37:24 <dmwit> But, the thing you should be asking about is not `x` but rather `read args !! 0` (and its friend on the next line).
10:37:53 <dmwit> Schrostfutz: In `do` blocks, you can treat values bound by `<-` earlier in the block as pure (in most cases).
10:38:20 <dmwit> Schrostfutz: Specifically: if `expr :: IO a`, then in `do { x <- expr; ... }` you can treat `x` has having type `a` in the `...`.
10:38:40 <Schrostfutz> dmwit: Okay, I think I understood a bit more now.
10:38:40 <mniip> Schrostfutz, all values are pure in haskell!
10:38:55 <dmwit> mniip: Hush. Let's start with the wrong but useful way of thinking of things. =)
10:39:01 <Schrostfutz> Okay, I was mistaken :D
10:39:07 <mniip> in 'do x <- getLine; putStrLn x', x is not a specific value
10:39:22 <mniip> if you desugar it into getLine >>= \x -> putStrLn x, you can see clearly what I mean
10:39:30 <dmwit> Schrostfutz: Since `getArgs :: IO [String]`, then in `do { args <- getArgs; ... }`, we can consider `args :: [String]`.
10:40:39 <Schrostfutz> dmwit: Alright, I think I get it.
10:40:40 <dmwit> Schrostfutz: You might also like sigfpe's "IO Monad for People Who Simply Don't Care" or whatever it's called. A delightful first introduction to doing `IO` in Haskell.
10:40:59 <mniip> ah well
10:41:09 <mniip> I guess I misinterpreted their skill level
10:41:19 <Schrostfutz> mniip: I don't know much more about the >>= operators etc yet, but it will be covered in the tutorial I'm following soon
10:42:02 <Schrostfutz> dmwit: Great, I'll read that post. Thanks for helping a total newbie :)
10:42:19 <mniip> well, the thing to keep in mind is that <- bindings aren't singular like toplevel name bindings
10:42:28 <mniip> they're more like lambda argument bindings
10:43:05 <mniip> depending on the monad x may iterate though many different values, or even none at all or even values that come from outside of your program
10:43:09 <Welkin> they are exactly lambda bindings 
10:43:36 <mniip> yes but that's hardly useful to them at this point
10:43:38 <mniip> see above
10:44:15 <dmwit> mniip: It has only one inhabitant if you take equality to be observational equivalence.
10:44:26 <dmwit> mniip: Unlike the usual coproduct, you can't even observe the constructor here.
10:44:31 <Schrostfutz> Okay, I think it'll become clear when I get more used to using monads.
10:44:34 <dmwit> s/here/with exists/
10:45:00 <orion> http://www.yesodweb.com/blog/2015/10/using-wais-vault <-- In this blog post, Michael Snoyman uses unsafePerformIO. In this particular case, what would happen when multiple concurrent requests come in, assuming each request is handled in a different thread?
10:45:17 <mniip> hmm
10:45:25 <mniip> pi quantifier comes to mind
10:45:46 <dmwit> mniip: Pi specializes to forall. Sigma specializes to exists.
10:46:17 <mniip> oh wait there's also a sigma?
10:46:34 <int-index> dmwit, it doesn't *quite* specialize
10:46:39 <mniip> that kinda explains the choice of letter for pi
10:46:40 <dmwit> Wait, Pi specializes to (->). I think I may have got that wrong.
10:47:02 <int-index> forall is irrelevant, pi is relevant, so pi doesn't have the same parametricity guarantees.
10:47:10 <mniip> so what *is* forall/exists
10:47:25 <bollu> can I generate markdown from a .lhs file?
10:47:27 <mniip> type-algebraically
10:48:26 <dmwit> They are their own part of the algebra, surely?
10:48:38 <dmwit> Maybe I didn't understand the question.
10:49:40 <mniip> what are the axiomatics of that then?
10:50:41 <MarLinn> bollu: Don't know what you mean by "generate", but you can reinterpret the source. Code will be interpreted as blockquotes instead of code blocks though
10:50:58 <bollu> MarLinn: as in?
10:51:15 <bollu> MarLinn: given a .lhs file, can I create markdown with the comments and the code in it?
10:51:45 <mniip> dmwit, do you just say that we introduce a new operator '∀x. ...x...' akin to 'Λx -> ...x...'
10:52:56 <MarLinn> bollu, not directly. Maybe haddock can create something other than html or you can pipe haddock output into pandoc
10:53:03 <bollu> MarLinn: hmm
10:54:32 <MarLinn> the last approach should definitely work, but it is a bit long-ish...
10:56:30 <dmwit> mniip: I'm trying to find the section in a Russian translation of TAPL that covers this (the grammars and typing rules and stuff are still readable).
10:56:47 <dmwit> mniip: I had forgotten how much stuff there was in TAPL before it gets to quantification...
10:57:05 <mniip> russian translation of TAPL?
10:57:09 <mniip> why would someone do that
10:57:27 <kadoban> Because they're russian?
10:57:48 <dmwit> This would be a lot easier if I could read the table of contents.
10:58:24 <mniip> er?
10:58:36 <kadoban> What are you looking for in tapl? I have an english version around here somewhere.
10:58:55 <mniip> I do too somewhere in my lgs
10:59:10 <dmwit> kadoban: I think mniip would like to see the section that introduces `forall` and `exists`.
10:59:32 <dmwit> It has a chapter on System F, right?
11:00:37 <kadoban> Chapter 23 appears to be something to do with system f? (I haven't actually read the book yet, it's just in my to-read pile, heh)
11:01:08 <dmwit> yes, perfect
11:01:11 <kadoban> Hmm, and 24 is Existential Types ... 25 is "An ML Implementation of System F"
11:01:20 <mniip> I er, am not going to read russian TAPL :v
11:01:33 <kadoban> Haha, that sounds like a good choice.
11:01:53 <dmwit> mniip: Well, of course if you have your own copy you should look at that one.
11:02:24 <dmwit> mniip: But if you don't, the gray boxes on page 368 of http://starling.rinet.ru/~goga/tapl/tapl.pdf have what I might call the "axiomatics" of forall.
11:02:57 <dmwit> Although TAPL uses `\X. t` instead of `forall x. t`.
11:03:09 <x1f577> anyone super familiar with wreq here? is there a way to prevent non-200 responses from throwing StatusCodeExceptions? it's quite annoying wrapping everything in catch
11:03:34 <mniip> mmmyeah, I prefer to to use consistent notation
11:03:55 <mniip> and a russian translation would distort all the terms
11:04:44 <mniip> not sure what gave you the idea that I like reading computer literature in russian :)
11:08:30 <Welkin> damn russians
11:08:43 <Welkin> you have files for everything
11:08:54 <Welkin> I actually bought the book because I couldn't find a pdf
11:11:01 <int-index> there is an English version of this book, in PDF. on a Russian torrent tracker =р
11:11:12 <Welkin> rutracker?
11:11:15 <mniip> umm it's not that hard to find a pdf link online
11:11:15 <int-index> Yes.
11:11:26 <Welkin> I already bought the book though o.o
11:11:31 <Welkin> and read maybe 2 pages
11:12:29 <mniip> dmwit, hmm that's not exactly what I'm referring to
11:12:50 <mniip> these are typing/reduction rules for a typesystem with universal types
11:13:06 <mniip> I was asking about the algebra of types
11:14:22 <mniip> like
11:15:14 <mniip> (A+B)*C ≅ A*C+B*C
11:15:24 <mniip> from a type-theory standpoint
11:18:05 <mniip> hmm, I suppose the rules you linked can be described as axioms
11:18:08 <int-index> What's there to read about? Distributivity holds and you can prove it
11:18:10 <mniip> but the question is more about what theorems can we prove
11:18:22 <mniip> and what the resulting object looks like in our algebra of types
11:19:32 <int-index> just write 'f: (A+B)*C -> A*C+B*C' and 'g: A*C+B*C -> (A+B)*C' and then construct proofs that 'f . g = id' and 'g . f = id'
11:19:56 <int-index> can be done in Agda
11:19:57 <mniip> right
11:20:08 <mniip> I know how to prove that
11:20:17 <mniip> but I can't possibly come up with all possible theorems
11:20:54 <c_wraith> Don't worry about all possible thoerems.
11:22:17 <nicknight> hello everyone,, I have some basic knowlege with python then I wan't to ;earn javascript and nodejs I know few basics...I am looking for some job but I saw this book http://book.realworldhaskell.org/read/types-and-functions.html and now I wan't to learn haskel but is it going to help me? After python haskel a right choice ?
11:22:52 <nicknight> Between I am very much interested in Machine Learning and I don't kow what is machine learning which language should I go with ?
11:23:41 <mniip> int-index, do you understand what I'm trying to say
11:24:25 <mniip> like, e.g, if we examine zipper types
11:24:31 <ertes> nicknight: haskell and python are very different languages, so your python knowledge will not help with haskell (more likely it will hinder)…  on whether you should learn haskell: i'd say yes (of course)
11:24:32 <int-index> they are derivatives
11:24:37 <mniip> we would notice that they have exactly the same laws as function derivatives yes
11:24:50 <mniip> and similarly coproducts are similar to addition
11:24:51 <zipper> mniip: :)
11:25:05 <mniip> what does forall "look like" in that construction
11:25:10 <int-index> oooh
11:25:19 <int-index> it's an exponential
11:25:22 <int-index> like (->)
11:25:42 <ertes> nicknight: machine learning with haskell is possible to some extent, but if you want to do any of the newer, fancier models, you will likely have to write some of the code yourself…  personally (!) i'd do that rather than use python
11:26:13 <sm> nicknight: learn both js and haskell
11:26:15 <int-index> or something that resembles exponentials quite closely, I think
11:26:19 <mniip> int-index, how does that work
11:26:31 <nicknight> ertes:  can you tell me for a complete noob and beginner who is almost 27 and looking for job Python or Haskell?
11:26:35 <mniip> hmm
11:26:42 <mniip> reminds me of extranatural transformations
11:26:46 <nicknight> sm learning two things is hard right?
11:26:48 <mniip> even though I didn't understand them fully
11:26:56 <ertes> nicknight: if you want to land a job, learn JS
11:27:09 <ertes> it's a horrible language, but it definitely gets you a job
11:27:18 <int-index> mniip, 'forall' is like (->) except it's dependent and irrelevant
11:27:27 <int-index> and since (->) are exponential, I assume foralls are too
11:27:31 <int-index> just a different sort
11:27:32 <nicknight> ertes:  but in my place for devops python more demanding so I postponed js
11:27:33 <sm> nicknight: just learn a little at a time. Nobody learns all of one language either
11:28:13 <nicknight> sm what do you mean ? 
11:28:14 <sm> by exposing yourself to these two very valuable languages, you will learn much more 
11:28:39 <ertes> nicknight: as a devop you might benefit more from python, yes…  if this is exclusively about making money, and you don't plan to get involved with the community, haskell is the worst choice out of the three
11:28:53 <sm> I mean I think it's reasonable to study two languages "at once" (maybe not on the same day :)
11:28:58 <mniip> int-index, but (->) is of kind * -> * -> *, whereas forall is (* -> *) -> *
11:29:11 <ertes> nicknight: i'd learn all three of them, but beware that haskell ruins you for the other two =)
11:29:25 <nicknight> Ok then first I learn python then js then if time haskell and go as I need job how is it ?
11:29:29 <mniip> it is an unary operator on a type function
11:29:38 <mniip> whereas -> is a binary operator on types
11:30:09 <int-index> 'forall' is surely not unary
11:30:14 <ertes> nicknight: is this only about making money?
11:30:21 <aarvar> int-index: yes it is
11:30:40 <int-index> aarvar, you forgot about the kind!
11:30:46 <aarvar> good point
11:30:47 <int-index> forall (a :: k) . t
11:31:02 <nicknight> ertes:  I love programming and learn all but first I should survive and take care of my family tooo so first money then with time my interest for coding
11:31:17 <int-index> compare: (1) A -> B; (2) forall (a : A) . B
11:31:26 <nicknight> I am not a computer guy and a machine engineer
11:31:27 <aarvar> yeah, you're right
11:31:46 <sm> nicknight: to get started making money, find a business you can work with who needs some not-too-hard programming and learn what they need
11:31:57 <mniip> ok then
11:31:57 <aarvar> forall : (A : *) -> (f : A -> *) -> *
11:32:02 <mniip> yes
11:32:03 <mniip> that
11:32:13 <mniip> was about to type that but was unsure about the notation
11:32:22 <aarvar> you can use forall in the type of forall now
11:32:46 <nicknight> sm so I decided python 3 then js then once I am good come bacj to haskell and new languages like go rust etc dont know how many years I can learn all
11:33:38 * hackagebot text-all 0.3.0.2 - Everything Data.Text related in one package  https://hackage.haskell.org/package/text-all-0.3.0.2 (Artyom)
11:35:51 <nicknight> ok thanks a lot see you friends
11:35:54 <aarvar> forall : forall Type (λA. (A -> Type) -> Type)
11:35:55 <aarvar> is that right?
11:35:56 <nicknight> bye take care
11:37:03 <int-index> aarvar, I don't know, it hurts my head to think about the type of a type quantifier
11:37:06 <mniip> looks good
11:37:18 <int-index> you might be interested in so-called "very dependent types"
11:37:22 <mniip> hmm
11:37:24 <aarvar> what are those
11:37:26 <mniip> we can introduce two
11:37:43 <int-index> aarvar, those are generalizations of Pi and Sigma
11:38:15 <mniip> forallType : (Type -> Type) -> Type
11:38:21 <aarvar> int-index: what are?
11:38:35 <mniip> forall : forallType (λA. forallType (λB. (A -> B) -> B))
11:39:38 <aarvar> mniip: B needs to be Type?
11:40:48 <aarvar> and now we need to add in universes to make our heads explode
11:41:07 <mniip> does B not?
11:41:20 <aarvar> does it not what
11:41:30 <aarvar> I mean, B has to equal Type
11:41:40 <mniip> not necessarily
11:41:48 <aarvar> how can you have a forall quantified type that isn't a type
11:42:03 <mniip> (forall a. Either a) b
11:42:16 <aarvar> what does that mean
11:44:01 <mniip> hmm
11:44:09 <mniip> it doesn't work in ghc without impredicative types
11:44:21 <mniip> and with them it's just as broken as the rest of impredicative types
11:44:37 <mniip> but imo quantificatio totally makes sense at different kinds
11:44:54 <aarvar> what's an example of something with type (forall a. Either a) b
11:44:59 <aarvar> I don't get what that type means
11:45:04 <mniip> well, substitute b ~ ()
11:45:21 <aarvar> okay
11:45:35 <aarvar> and?
11:45:57 <mniip> hmm
11:46:44 <aarvar> int-index: have any links on what a "very dependent type" is?
11:46:45 <mniip> ok that isn't a terribly good example
11:47:25 <mniip> ok indeed
11:47:30 <mniip> it makes no sense
11:47:34 <aarvar> :)
11:48:10 <mniip> you need λA. (λA. Either A) A B
11:49:15 <aarvar> what?
11:49:31 <int-index> aarvar, http://www.cs.cornell.edu/jyh/papers/fool3/paper.pdf
11:49:40 <mniip> forall a. (forall a. Either a)[a] b
11:49:44 <mniip> or whatever notation TAPL uses
11:50:25 <aarvar> int-index: do they define object oriented?
11:50:57 <int-index> that's just a motivating example. They actually generalize dependent types beyond all repair and beyond my understanding
11:51:41 <aarvar> did they throw in the words object oriented to make their work seem practical or something?
11:55:30 <ertes> skimming paper.pdf didn't help understand what it's about
11:55:35 <ertes> its file name didn't either
11:55:35 <monochrom> haha beyond all repair
11:55:56 <ertes> i thought we went past image.jpg and info.nfo
11:56:19 <monochrom> no, I think they throw in the words object oriented to make object orientation seem impractical.
11:56:42 <aarvar> lol
11:56:45 <monochrom> my exam file is called exam.pdf
11:57:27 <monochrom> also, I know of a project that has a file called Cabal.cabal
11:57:29 <ertes> probably because your directory has a more descriptive name…  i.e. not "fool3" =)
11:58:28 <aarvar> I think that's pretty descriptive
11:58:36 <ertes> (in case it's not obvious: i'm joking)
11:58:59 <ReinH> ertes: a damning critique
12:02:14 <Welkin> lol
12:02:21 <Welkin> pdf.pdf
12:02:25 <Welkin> jpg.jpg
12:02:41 <Welkin> pdf.jpg
12:04:34 <ertes> "pdf.jpg" might be the title of a philosophical poem, a journey into the meaning of information and shape, and ultimately an interpretation of the universe as we know it
12:04:57 * mniip imagines a 640x128931 jpg file
12:05:26 <mniip> of text
12:06:10 <hydraz> :D:
12:06:12 <glguy> It doesn't seem unreasonable that you could have a jpg format file contain content pertaining to pdfs
12:07:54 <ertes> it's probably just a plot of a probability function
12:09:12 <glguy> I wish Steam had a setting where I could tell it that I wasn't interested in any Steam too-early access or Steam red-light games
12:09:18 <glguy> at all, ever
12:09:32 <glguy> and this is the wrong channel for taht coment
12:09:33 <int-e> mniip: I've seen a 1000x40k jpg recently... it was some XML schema.
12:09:43 <glguy> All that .jpg talk and I thought I was in -offtopic
12:11:35 <int-e> mniip: btw you pinged me a few days ago, was that about the L.hs thing? My reasoning for not making the L.hs file itself available was that people may not expect their @lets to be publicly visible just like that. It's just a symlink and a minor edit if there's a consensus that it should be online.
12:13:19 <jmcarthur> int-e: Are you talking about lambdabot?
12:13:30 <int-e> jmcarthur: yes
12:13:33 <int-e> @where L.hs
12:13:33 <lambdabot> what lambdabot has in scope is at http://silicon.int-e.eu/lambdabot/State/Pristine.hs
12:13:51 <jmcarthur> int-e: I've always thought @lets should just be public information. They were posted publicly in a channel that's already known to be logged, after all.
12:14:04 <jmcarthur> I guess not all @lets are added that way...
12:14:13 <int-e> jmcarthur: lambdabot can be used in private
12:14:17 <jmcarthur> Yeah
12:14:30 <jmcarthur> Session local @lets seem like they would be useful, but I imagine that is more work.
12:14:50 <int-e> that would be a significant effort indeed.
12:16:14 <zcourts> in the expression `section3 a = foldl (+) a [3, 4, 5, 6, 7, 8]` is (+) here a section or just a parenthesised expression?
12:16:48 <mauke> section
12:17:08 <buglebudabey> what's a section?
12:17:45 <mauke> it's like (x + y) but one or both of x and y are missing and + is any operator
12:18:07 <glguy> The haskell report calls (infixexp qop) and (qop infixexp) left and right sections respectively
12:18:30 <zcourts> I'm looking at the 2010 report but can see where section like that is handled, there's one for left/right explicitly but is this either of the two?
12:18:32 <int-e> jmcarthur: actually it would pose a UI problem as well... imagine you've fed some definitions to lambdabot and now you want to show them off on some channel... how should the bot know that you want the definitions transferred? tricky.
12:18:48 <mauke> oh, hmm
12:18:55 <glguy> "Sections are written as ( op e ) or ( e op ), "
12:18:55 <aarvar> I think I've found a bug
12:18:58 <aarvar> @let foo = 2 * 3
12:18:59 <lambdabot>  Defined.
12:19:06 <aarvar> > foo
12:19:09 <lambdabot>  10
12:19:12 <buglebudabey> lol
12:19:13 <aarvar> haskell sucks
12:19:14 <jmcarthur> int-e: My first assumption would be that I just have to copy and paste it in the channel.
12:19:34 <mauke> zcourts: ok, I'm wrong. it's neither
12:19:46 <jmcarthur> int-e: Which would be pretty reasonable anyway, if you're showing it off. The only time this sucks is when you want to hide the definition until after you've shown how to use it.
12:19:48 <aarvar> 2 * 3 = 10
12:20:02 <buglebudabey> @let bar = 2 * 4
12:20:04 <lambdabot>  Defined.
12:20:08 <buglebudabey> > bar
12:20:10 <lambdabot>  8
12:20:13 <buglebudabey> seems okay to me
12:20:22 <zcourts> mauke: so it is in fact a parenthesised expression i.e. (exp) from the report?
12:21:02 <aarvar> buglebudabey: hm, try it again
12:21:02 <jmcarthur> zcourts: I think it's just the syntax for naming an operator without applying it to anything.
12:21:09 <buglebudabey> @let bar = 2 * 4
12:21:10 <lambdabot>  .L.hs:155:1:
12:21:10 <lambdabot>      Multiple declarations of ‘bar’
12:21:10 <lambdabot>      Declared at: .L.hs:154:1
12:21:12 <jmcarthur> zcourts: I don't even know that it has a name.
12:21:16 <buglebudabey> > bar
12:21:17 <mauke> zcourts: var → varid | ( varsym )
12:21:19 <lambdabot>  10
12:21:22 <aarvar> see?
12:21:24 <buglebudabey> > bar
12:21:26 <lambdabot>  10
12:21:29 <buglebudabey> lol
12:21:31 <jmcarthur> @clear
12:21:31 <lambdabot> Maybe you meant: clear-auto-reply clear-messages clear-topic learn
12:21:34 <jmcarthur> err...
12:21:36 <jmcarthur> I forget
12:21:39 <aarvar> @undefine
12:21:39 <lambdabot> Undefined.
12:21:43 <jmcarthur> there we go
12:21:46 <buglebudabey> @let bar = 2 * 4
12:21:49 <buglebudabey> > bar
12:21:50 <lambdabot>  Defined.
12:21:52 <lambdabot>  12
12:21:56 <buglebudabey> alrighty then
12:22:03 <jmcarthur> Yeah, Haskell sucks.
12:22:05 <jmcarthur> :)
12:22:09 <buglebudabey> or just lambdabutt
12:22:30 <mauke> zcourts: I don't know how you get "it's a parenthesized expression" from "it's neither a section nor a parenthesized expression"
12:22:31 <Welkin> > let fish = 2 * 9 in fish
12:22:33 <lambdabot>  18
12:22:59 <aarvar> Welkin: the bug only applies to @let, and only if you wait for me to send lambdabot some commands changing the value first
12:23:11 <Welkin> aarvar: I suspected that 
12:23:12 <buglebudabey> aarvar privately?
12:23:17 <aarvar> buglebudabey: yes
12:23:27 <glguy> ((+)) would be a parethesized exp, with (+) being the exp
12:23:29 <jmcarthur> Yeah I think aarvar is privately, perhaps even in a loop, redefining (*).
12:23:30 <Welkin> which is why I foiled your plan
12:23:41 <aarvar> so, someone could be demonstrating something, and someone else could privately change the definitions so things suddenly don't work
12:23:49 <zcourts> mauke: ahhhh, okay! I and varsym ofcourse includes + and others. I saw the parens and for some reason misinterpreted and didn't think it meant literally paranthesised.
12:23:49 <Welkin> state sucks
12:23:51 <Welkin> :p
12:23:58 <Welkin> go stateless or go home
12:24:20 <zcourts> glguy: Makes sense, thanks all
12:24:24 <mauke> how can I go anywhere when I have no position?
12:24:31 <aarvar> jmcarthur: no, I'm not that clever
12:24:36 <aarvar> I was just redefining bar
12:24:47 <kaol> > let (*) = \x y -> (+1) $ (Prelude.*) x y in 2 * 3
12:24:49 <lambdabot>  7
12:24:49 <aarvar> (what if he used + ?)
12:24:58 <jmcarthur> aarvar: Ah, just every time somebody defined bar, you redefined it really quickly?
12:24:59 <aarvar> I suppose one could redefine all of the arithmetic operators
12:25:06 <aarvar> jmcarthur: right
12:25:26 <aarvar> if I was smart I would redefine arithmetic
12:25:43 <jmcarthur> @let (+.) = (+)
12:25:43 <Welkin> @let Prelude = undefined
12:25:44 <lambdabot>  Defined.
12:25:45 <lambdabot>  .L.hs:156:1: Not in scope: data constructor ‘Prelude’
12:25:58 <jmcarthur> @let a + b = if a == 0 then b +. 1 else a +. b
12:25:59 <lambdabot>  .L.hs:155:8:
12:25:59 <lambdabot>      Ambiguous occurrence ‘+’
12:25:59 <lambdabot>      It could refer to either ‘L.+’, defined at .L.hs:159:3
12:26:14 <jmcarthur> Ah, you can't shadow anyway.
12:26:15 <glguy> Maybe we could have a #haskell-lambdabot for flooding the channel with lambdabot?
12:26:34 <jmcarthur> glguy: ... Probably a good idea anyway, but I will stop feeding the fire at least.
12:27:50 <aarvar> why not have a separate instance of lambdabot which only accepts commands from the channel?
12:29:01 <glguy> I'd rather people who need a private lambdabot compile and run a lambdabot
12:29:52 <geekosaur> someone should make setting up a local lambdabot less nightmarish
12:30:05 * geekosaur still remembers running his own. by all reports, it has not improved since
12:30:42 <glguy> I'm sure patches would be welcome
12:31:01 <glguy> Or if it's hard someone in need of a private lambdabot could pay int-e to do it :)
12:46:06 <riaqn> Hi, how to break out of a monad sequence? That is, not executing the remaining "statements".
12:46:59 <riaqn> Now I'm doing a pattern match, so one of the branch will "return", while the other branch continue execution.
12:47:16 <Rotaerk> maybe make it a MaybeT and return Nothing?
12:47:55 <riaqn> but then the other branch is one level inner than the statement before the pattern match, while I prefer treating the early-exit as some error, not a case.
12:49:16 <lyxia> "early-exit" is what MaybeT enables.
12:49:48 <ahsfhyicxv> riaqn: Can you post it?
12:50:05 <riaqn> Rotaerk: lyxia: thanks, will try.
12:50:17 <riaqn> ahsfhyicxv: wait for a second.
12:51:50 <riaqn> http://lpaste.net/179095
12:52:49 <riaqn> ahsfhyicxv: ^
12:55:29 <ahsfhyicxv> raiqn: I agree with lyxia that MaybeT is the best option unless you need to know the error type in which case use EitherT
12:57:38 <riaqn> ahsfhyicxv: thanks! will try
12:59:06 <lyxia> Maybe you can put the non-erroring body in a separate top-level definition.
13:00:06 <riaqn> lyxia: yeah, that may be a better style.
13:03:56 <ahsfhyicxv> Maybe is to mfromMaybe as List is to what?
13:06:53 <lyxia> mfromList?
13:08:32 <ahsfhyicxv> No. I am looking for [a] -> MonadList a.
13:09:41 <ahsfhyicxv> Nevermind. I don't need it.
13:14:01 <Gurkenglas> http://hackage.haskell.org/package/optparse-applicative-0.13.0.0/docs/Options-Applicative-Extra.html#v:helper what is this antipatternry
13:16:11 <geekosaur> looks like they implement a --help option as a parser that always fails and triggers the help/usage message
13:16:44 <geekosaur> sadly, option parsing usually ends up being a choice between antipatterns
13:20:52 <kadoban> How do you get optparse-applicative to show the help for subcommands, without just screwing up a subcommand royally?
13:21:41 <athan> kadoban: --help?
13:21:46 <athan> oh wait
13:21:50 <athan> subcommands :s
13:22:07 <kadoban> Ya :-/
13:22:29 <kadoban> thecommand --help thesubcommand     doesn't work, nor does the other way around. Seems odd
13:22:52 <kadoban> It clearly has the ability, because: thecommand thesubcommand bunches of nonsense     shows the usage and help stuff
13:23:23 <athan> File an issue! :p
13:23:36 <kadoban> Well, I assume there's some way and I just don't know it, heh.
13:24:51 <sm> I think cmdargs is more flexible
13:25:12 <kadoban> That's a different library I assume?
13:28:58 <saurabhnanda> Announcing my crazy plan. Call for help. https://medium.com/@saurabhnanda/trying-to-make-building-webapps-easier-in-haskell-46130553ed1a
13:29:04 <sm> kadoban: yes, it's the other one
13:29:58 <kadoban> Ehh, I'd rather stick with optparse-applicative, it's been fine so far.
13:30:25 <sm> kadoban: ok, I'd like to know the answer to your q too
13:31:15 <kadoban> I could probably add an option to each subcommand that just makes it fail, but .. that seems repetative.
13:31:55 <kadoban> Hmm, also it apparently couldn't be called --help, which is super unfortunate. I wonder if I can make it work git style, like  'thecommand help thesubcommand'
13:33:34 <geekosaur> kadoban, actually Gurkenglas's link above is relevanrt
13:34:18 <geekosaur> specifically "helper" that they linked is used to implement http://hackage.haskell.org/package/optparse-applicative-0.13.0.0/docs/Options-Applicative-Extra.html#v:hsubparser
13:34:44 <geekosaur> which gives you subcommands which support -h/--help
13:35:36 <kadoban> Hmm, thanks I'll look at that. Been a while since I modified this code, gotta get familiar again with the types.
13:37:46 <kadoban> Oh hah nice, yeah I just have to use hsubparser instead of subparser. Thanks :)
13:38:43 * hackagebot pandoc-types 1.16.1.1 - Types for representing a structured document  https://hackage.haskell.org/package/pandoc-types-1.16.1.1 (JohnMacFarlane)
13:49:20 <mniip> int-e, no it was about FreeT
13:49:27 <mniip> and why is exceptions not marked as safe
13:50:34 <glguy> The package?
13:50:42 <mniip> yes
13:51:19 <glguy> At a minimum because it uses GeneralizedNewtypeDeriving
13:51:27 <glguy> and then TH
13:51:50 <glguy> import Language.Haskell.TH.Syntax (Q)
13:51:57 <mniip> hrmph
13:54:42 <mniip> can't we mark template-haskell as unsafe then?
13:56:03 <mniip> hmm
13:56:14 <mniip> perhaps free can be downgraded to 4.11?
13:56:57 <mniip> glguy, what's unsafe about GND?
13:57:41 <ReinH> mniip: safe haskell is an honor system :)
13:58:01 <mniip> ultimately I'm looking to have Control.Monad.Trans.Free in lambdabot
13:58:07 <ReinH> mniip: it has bad interactions with some other pragma
13:58:09 <mniip> @let import Control.Monad.Trans.Free
13:58:10 <lambdabot>  <no location info>:
13:58:11 <lambdabot>      The package (exceptions-0.8.0.2) is required to be trusted but it isn't!
13:58:18 <ReinH> (GND does)
13:58:58 <mniip> oh
13:59:00 <mniip> GADTs
13:59:18 <aarvar> I thought type roles sovled that?
14:00:00 <ReinH> @google GeneralizedNewtypeDeriving is Profoundly Unsafe
14:00:01 <lambdabot> http://joyoftypes.blogspot.com/2012/08/generalizednewtypederiving-is.html
14:00:01 <lambdabot> Title: The Joy of Types: GeneralizedNewtypeDeriving is Profoundly Unsafe
14:00:14 <mniip> hmm
14:00:19 <Cale> monochrom: wait, I run ##categorytheory?
14:00:19 <mniip> looks like I can implement unsafeCoerce
14:00:30 <glguy> Congratulations :)
14:01:03 <ReinH> aarvar: perhaps? https://www.cis.upenn.edu/~eir/talks/2013/hiw-roles.pdf
14:01:14 <ReinH> istr that they're unsafe again
14:01:21 <mniip> ooh
14:01:37 <ReinH> I still use them anyway because YOLO
14:01:39 <Cale> Oh, I guess I kind of do... going by chanserv's access list
14:01:44 <mniip> I didn't realize haskell had a very well built-in method to implement unsafePerformIO using unsafeCoerce
14:01:48 <mniip> that being runST
14:02:19 <aarvar> type roles are so ugly though
14:03:01 <Cale> bollu, Welkin, mniip: Coq is also off-topic in ##categorytheory -- #coq generally will respond to questions though.
14:03:22 <dolio> ReinH: That blog post is both light on details, and old.
14:04:49 <slack1256> Did somebody write a bidirectional pipes tutorial?
14:05:19 <slack1256> google doesn't show anything apart from the Pipes.Tutorial module that focuses on uni-directional pipes
14:05:58 <mniip> ooh
14:06:11 <mniip> typeclasses can be used to ontroduce higher ranked types into haskell98
14:06:49 <exio4> mniip: how so?
14:08:29 <mniip> exio4, just represent any 'forall v. type' with a typeclass with a method of type 'N v -> type' where N is a newtype containing type
14:09:49 <aarvar> mniip: there's no higher ranked type there
14:09:54 <mniip> hmm
14:11:05 <mniip> I guess you're right that this is a dead end approach
14:11:15 <mniip> though the above article states >but it is highly possible that Haskell 98 + GeneralizedNewtypeDeriving admits unsafeCoerce, using type classes to simulate higher ranked types. Research for another day.
14:11:18 <exio4> mniip: those don't really look close at all
14:11:28 <exio4> got some code? 
14:11:31 <mniip> none
14:11:35 <mniip> I'll experiment
14:17:46 <Jenaf> hello everyone
14:17:56 <Jenaf> I have a beginner question about using ghci
14:18:11 <Welkin> Jenaf: type ghci
14:18:14 <CubicE> Jenaf, ask it then
14:18:23 <aarvar> wait no, I want to guess
14:18:33 <mniip> hmm
14:18:34 <Jenaf> is there a command to release all bindings in a ghci session?
14:18:39 <Welkin> is your computer plugged in?
14:18:50 <aarvar> did you try turning it off and on again?
14:18:55 <Jenaf> I'm just playing arround a bit and I don't want to many bindigs to hang arround
14:19:03 <glguy> Jenaf: If you use :reload it will clear them
14:19:08 <Jenaf> thy
14:19:17 <mniip> haha
14:19:25 <Jenaf> aarvar: yeah truning it on and off again was the solution i used so far
14:19:25 <mniip> I was thinking about :reload in the guessing phase
14:19:48 <Jenaf> anyway thanks for the help
14:20:02 <CubicE> oh goody
14:20:23 <CubicE> I have an error in my rendering code that doesn't happen with the (apparently) equivalent C code
14:20:30 <CubicE> off to a good start
14:21:39 <Cale> CubicE: What kind of rendering code?
14:23:06 <CubicE> Cale, I'm using SDL2 to draw a bunch of cards stacked on top of each other
14:24:04 <CubicE> for some reason my cards bleed through each other. Either I'm doing something very screwy, or my textures are corrupt in ways that are imperceptible when I draw them individually
14:24:17 <grantwu> z fighting?
14:24:20 <grantwu> alpha channel issues?
14:24:36 <grantwu> wait, if this is 2d, ignore the z fighting
14:25:28 <hexagoxel> anyone know of a manually managed (pinned) memory pool implementation/library?
14:26:15 <mniip>       Use -freduction-depth=0 to disable this check (any upper bound you could choose might fail unpredictably with minor updates to GHC, so disabling the check is recommended if you're sure that type checking should terminate)
14:26:18 <mniip> I don't like this message
14:26:48 <CubicE> grantwu, it looks like zfighting, but yeah it shouldn't happen with sdls renderer api
14:26:56 <CubicE> and it doesn't happen if I write it in C
14:28:31 <saurabhnanda> can anyone help me with the TODOs at https://github.com/vacationlabs/haskell-webapps/blob/master/ServantOpaleye/DomainApi.hs#L96-L129
14:28:39 <CubicE> I guess I might have a corrupt alpha channel though
14:28:49 <saurabhnanda> lots of questions related to dealing with user-input validation in Haskell.
14:29:07 <CubicE> my image loading code pretty much justs casts between 3 different types of buffers
14:29:25 <CubicE> so it's entirely possible I screwed that up somewhere
14:29:57 <Welkin> I've been screwing up my midi code all day
14:30:05 <Welkin> making slow progress though
14:31:54 <aarvar> saurabhnanda: do you mean you want the ValidationState to be part of Product2's type?
14:32:20 <aarvar> you could do that with DataKinds, but you probably don't want to
14:34:03 <saurabhnanda> aarvar: would you mind putting your opinion up on Reddit at https://www.reddit.com/r/haskell/comments/4yr1a2/call_for_help_trying_to_make_building_webapps/ -- that will help centralize the discussion?
14:34:10 <saurabhnanda> if not, just let me know your thoughts here.
14:44:58 <riaqn> Rotaerk: lyxia: many thanks! I'm done: http://lpaste.net/179133
14:45:17 <riaqn> but the indenting is ugly, any suggestions?
14:46:36 <aarvar> saurabhnanda: can you just do something like data Product a b c d = Product { field1 :: a, field2 :: b, field3 :: c, field4 :: d }
14:47:10 <aarvar> and use lenses
14:47:17 <aarvar> but then you have to learn lenses
14:47:29 <lyxia> riaqn: I'd just replace loop with try tag
14:49:36 <riaqn> lyxia: huh, I thought it's better to seperate the function from a loop in that function...
14:49:41 <lyxia> riaqn: if length args /= 1 then ... else right ()    is    when (length args /= 1) then ...
14:49:49 <riaqn> lyxia: it's not that much difference in this case of course.
14:49:57 <saurabhnanda> aarvar: know lenses.
14:50:21 <riaqn> lyxia: thanks, let me check out the "when then" clause.
14:50:46 <lyxia> riaqn: ah no, "then" shouldn't be there
14:50:53 <lyxia> riaqn: when is a function from Control.Monad
14:51:24 <riaqn> lyxia: thanks! let me check.
14:51:38 <aarvar> saurabhnanda: and for errors, why not MonadError and classy prisms
14:51:56 <riaqn> lyxia: ok, I see what it's doing. very handy.
14:51:58 <saurabhnanda> aarvar: how? do you have working code to point to?
14:52:05 <lyxia> riaqn: _ <- doStuff    is just    doStuff
14:52:31 <riaqn> lyxia: yeah, I prefer to be explicit, otherwise get warnings sometimes.
14:52:59 <saurabhnanda> aarvar: if I understand correctly, MonadError will bail on the first error. User-input validation needs to keep continuing as long as possible (while collecting all errors).
14:53:13 <saurabhnanda> aarvar: user-input validation is not an error or exception.
14:53:47 <aarvar> oh, then you want Validation
14:54:14 <aarvar> so this or something https://hackage.haskell.org/package/Validation-0.2.0
14:55:15 <saurabhnanda> the current Validation packages work for scenario (1). What about scenario (2)
14:55:26 <saurabhnanda> btw, have you used the validation packages in a real-life project?
14:55:31 <riaqn> lyxia: but I don't get warning this time.
14:55:38 <aarvar> saurabhnanda: nope
14:55:55 <aarvar> it's by dibblego though, so it probably works
14:55:59 <aarvar> but who knows
14:57:15 <Jenaf> i need help about types
14:57:36 <Jenaf> how can I ensure that somethign i declare is a given type?
14:58:09 <aarvar> saurabhnanda: here's another one https://hackage.haskell.org/package/either-4.4.1.1/docs/Data-Either-Validation.html
14:58:13 <Jenaf> thenumber=23841883 will result in an integer; but if i add another expretion later it changes to double
14:58:42 <saurabhnanda> aarvar: do you know how to use it based on just that documentation?
14:58:46 * hackagebot postgresql-simple-bind 0.2.0.0 - A FFI-like bindings for PostgreSQL stored functions  https://hackage.haskell.org/package/postgresql-simple-bind-0.2.0.0 (zohl)
14:59:15 <aarvar> saurabhnanda: sure
15:00:31 <saurabhnanda> aarvar: actually it's just an Either where all errors are collected int he Left
15:00:46 <saurabhnanda> aarvar: but it's a pain to use in real-life use cases. It's **just the container**
15:01:06 <saurabhnanda> aarvar: where's the regular stuff like email validation, regex validation, length validation, etc.
15:01:35 <saurabhnanda> aarvar: and how do you stitch all this together given https://github.com/vacationlabs/haskell-webapps/blob/master/ServantOpaleye/DomainApi.hs#L119-L129
15:03:39 <dibblego> It was first used in a real-life, not-even-pretend email validation application, in 2005.
15:04:43 <intothemountains> Given I have some Maybe a, how can I do to convert it to Nothing if it is, let's say, Just 3
15:05:01 <intothemountains> Sorry, Maybe Int
15:05:04 <ertes> intothemountains: "convert"?
15:05:08 <lyxia> riaqn: this loop block can be more clearly expressed with catchError from mtl
15:05:12 <ertes> intothemountains: just use Nothing
15:05:41 <intothemountains> ertes: if p == Just 3 then Nothing else p
15:05:48 <intothemountains> Something like that but better?
15:05:58 <ertes> intothemountains: ah…  well, there is 'guard'
15:06:21 <glguy> validating email addresses, does it have an @?
15:06:34 <lyxia> riaqn: the case line 50 too
15:06:38 <mniip> intothemountains, mfilter (/= 3)
15:06:53 <intothemountains> mniip: cheers!
15:06:54 <ertes> intothemountains: alternatively you can enable MonadComprehensions and write:  [ x | x <- myValue, x == 3 ]
15:07:04 <ertes> oh, i forgot about mfilter
15:07:23 <saurabhnanda> dibblego: didn't catch you
15:08:46 * hackagebot wai-middleware-verbs 0.3.1 - Route different middleware responses based on the incoming HTTP verb.  https://hackage.haskell.org/package/wai-middleware-verbs-0.3.1 (athanclark)
15:09:04 <riaqn> lyxia: thanks so much! let me check.
15:10:57 <dibblego> saurabhnanda: that data structure was first written, in 2005, for a web application, precisely for web form field validation, where you don't want to stop at the first error, but you want to collect all "invalid fields", notify the user, or, they were all filled correctly and so you compute a value. It was done in Scala. The Applicative instance collects errors using a Semigroup. It is also briefly mentioned (as a variant) in Applicative P
15:10:58 <dibblego> rogramming with Effects. It is not difficult to use. My colleagues were using springframework at the time, to attempt to (and fail) achieve a similar goal (web form field validation), and telling me about "difficulty to use",  which provided me some amusement and motivation. I'm not sure what about "just the container" changes it to difficult to use.
15:11:39 <saurabhnanda> dibblego: are you referring to https://hackage.haskell.org/package/either-4.4.1.1/docs/Data-Either-Validation.html
15:12:09 <dibblego> no this, https://hackage.haskell.org/package/validation but the one you mention is very similar
15:12:33 <saurabhnanda> dibblego: the container is obviously not difficult to use. There's boilerplate around it I mean. Standard functions for basic validations occuring in webapp contexts.
15:12:43 <dibblego> Ed and I share a lot of code and for whatever reason, he decided to rewrite it
15:12:51 <dibblego> what boilerplate?
15:14:04 <saurabhnanda> this -- https://github.com/NICTA/validation/blob/master/examples/src/Email.hs#L44-L47
15:14:26 <dibblego> what boilerplate though?
15:14:51 <saurabhnanda> and this -- https://github.com/NICTA/validation/blob/master/examples/src/Person.hs#L23-L38
15:15:08 <saurabhnanda> having to write that stuff. Most commonly occurring validations in a webapp
15:15:53 <dibblego> What exactly, about that, makes you believe that to be boilerplate and not "code that is absolutely necessary"?
15:16:07 <saurabhnanda> I'm probably misusing the term boilerplate
15:16:29 <saurabhnanda> that is absolutely necessary code. But that is code I would expect my validation library to already have.
15:16:49 <saurabhnanda> for a contrast -- https://www.stackage.org/haddock/lts-6.12/validate-input-0.4.0.0/Data-Validator.html#g:3
15:17:16 <glguy> you'd expect a validation library to have an arbitrarilyRestrictNameFieldToFiftyCharacters?
15:17:22 <dibblego> here's the thing, it's not even necessary, and not only that, every alternative I have ever seen, does require necessary boilerplate. So, if you are to argue against boilerplate strongly, as I do, then you are on my team and I agree with you, but I also contend that you *have no choice now*
15:17:44 <ertes> i think the validation library is merely a better Either…  it provides abstractions for validation, not actual validation functions
15:18:05 <dibblego> another library on top does that
15:18:17 <ertes> saurabhnanda: what you need is a library named saurabhnanda-business-logic-validation =)
15:18:57 <glguy> oh, I'd that exists it might be just the ticket
15:19:52 <saurabhnanda> dibblego: which is that library?
15:20:17 <ertes> since this is about web forms (isn't it?) note that most form libraries come with built-in validation abstractions as well as a library of specific validation functions
15:20:25 <ertes> see e.g. digestive-functors
15:21:19 <saurabhnanda> ertes: I hope that has a usable tutorial, and not two pages of category theory first :)
15:21:49 <Roey> hello
15:21:56 <Roey> when did Haskell start, 1990?
15:21:58 <saurabhnanda> better error handling, so a web page can display input errors right next to the corresponding fields;
15:22:03 <Roey> bjs:  hola
15:22:08 <saurabhnanda> ertes: seem to have hit pay-dirt!
15:22:15 <bjs> Roey: hi
15:22:17 <saurabhnanda> have a good feeling about this :)
15:22:33 <ertes> saurabhnanda: depending on your level of haskell that one may even explain itself through the API
15:22:59 <ertes> saurabhnanda: otherwise see the snap framework tutorial…  i think it includes a tutorial on digestive-functors
15:23:15 <ertes> (mildly snap-specific of course)
15:24:27 <dibblego> I've either not written it yet, or I can't find it :) I have written it for Scala.
15:27:32 <saurabhn_> one of the densest "tutorials" I've read: https://github.com/jaspervdj/digestive-functors/blob/master/examples/tutorial.lhs
15:28:55 <ertes> i was wrong…  snap has no tutorial
15:29:15 <saurabhn_> trying https://ocharles.org.uk/blog/posts/2012-12-02-digestive-functors.html
15:29:28 <saurabhn_> wow, someone wrote an academic paper about form validation -- https://ocharles.org.uk/blog/posts/2012-12-02-digestive-functors.html
15:29:44 <saurabhn_> wonder if it was peer reviewed and published in Elsevier :)
15:29:51 <saurabhn_> sorry, http://groups.inf.ed.ac.uk/links/formlets/
15:30:40 <saurabhn_> who came up with this name - digestive-functors. What was wrong with - form-validator?
15:31:23 <saurabhn_> :t (<$>)
15:31:25 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:31:30 <saurabhn_> :t fmap
15:31:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:31:45 <saurabhn_> :t (.:)
15:31:47 <ertes> saurabhn_: look again at the tutorial.lhs, and try not to assume that there is some huge theory behind it
15:31:47 <lambdabot>     Not in scope: ‘.:’
15:31:47 <lambdabot>     Perhaps you meant one of these:
15:31:47 <lambdabot>       ‘.’ (imported from Data.Function),
15:32:22 <saurabhn_> :t (Text.Digestive.(.:))
15:32:23 <glguy> saurabhn_: you can query lambdabot with /msg lambdabot
15:32:24 <lambdabot> Not in scope: data constructor ‘Text.Digestive’
15:32:24 <lambdabot>     Not in scope: ‘.:’
15:32:24 <lambdabot>     Perhaps you meant one of these:
15:32:29 <ertes> saurabhn_: also it's a form library, not just a validation library…  so it does everything for you from HTML rendering to input gathering to validation
15:33:01 <saurabhn_> glguy: will do. sorry for the noise.
15:33:34 <saurabhn_> is postForm at https://ocharles.org.uk/blog/posts/2012-12-02-digestive-functors.html doing JSON parsing?
15:33:52 <ertes> saurabhn_: the important thing to note is that with digestive-functors you need two extra libraries
15:34:13 <ertes> 1. a rendering library like digestive-functors-lucid
15:34:30 <ertes> 2. an HTTP glue library like digestive-functors-snap
15:34:56 <sm> it really is a terrible name :)
15:34:57 <ertes> choose the libraries that match your HTML and web framework
15:35:15 <k0ral> Hello
15:35:44 <k0ral> I'm playing around with free monads, and I rewrote various layers of my application using the DSL/interpreter pattern
15:36:30 <k0ral> now I'm wondering: should I apply that pattern to mere IOs as well ? I'm currently observing some strange interleaving between IOs from the DSL and IOs from the interpreter
15:37:04 <ertes> k0ral: do you need it?
15:37:07 <saurabhn_> ertes: in that blog post is postForm written in point-free style? https://ocharles.org.uk/blog/posts/2012-12-02-digestive-functors.html
15:37:28 <k0ral> ertes: well, considering the interleaving issue, yes
15:37:34 <ertes> saurabhn_: nope, it's applicative style
15:37:37 <k0ral> e.g. my logging layer is abstracted using a free monad
15:37:52 <k0ral> in the end, it's just putStrLn-ing text to stdout
15:38:04 <saurabhn_> ertes: where is the form input actually coming from? Shouldn't the function signature be postForm :: FormData -> Blah
15:38:11 <k0ral> but sometimes I'm using putStrLn within the DSL
15:38:20 <k0ral> and then the result is odd
15:38:24 <ertes> k0ral: there is also FreeT
15:38:56 <ertes> k0ral: if you mainly use free monads as an effect system, also check out the freer library
15:39:37 <ertes> saurabhn_: read "postForm" not as a verb, but as a noun
15:39:38 <k0ral> I've done things manually without any "free monad framework" up to now
15:39:42 <ertes> "the post form"
15:40:07 <ertes> saurabhn_: it's literally a form, and nothing else
15:40:08 <k0ral> ertes: I'm already using FreeT
15:41:02 <ertes> saurabhn_: it includes information about the existing fields and their types as well as how they map to a haskell value (of type BlogPost here)
15:41:32 <k0ral> my question is simply: should I define a data type like `data IOFunctor next = PutStrLn next | ReadFile (Text -> next) | ...` 
15:41:32 <saurabhn_> I think http://hackage.haskell.org/package/digestive-functors-aeson might clear things up without the UI to worry about.
15:41:51 <k0ral> is that recommended ? is there any library out here already doing that ?
15:42:33 <ertes> k0ral: if you don't need to compute with the individual actions, i wouldn't bother and just use FreeT
15:42:42 <Guest90851> Hi, why does some package create typeclass with the pattern "TypeClass" "TypeClass1" "TypeClass2"? Like aeson with "ToJSON" "ToJSON1" "ToJSON2"
15:43:09 <ertes> k0ral: with the functor only model the effects you want to *interpret*, i.e. those that should be transparent to your interpreter
15:43:38 <saurabhn_> ertes: what's Form in http://hackage.haskell.org/package/digestive-functors-aeson-1.1.19/docs/Text-Digestive-Aeson.html
15:43:47 * hackagebot wai-middleware-verbs 0.3.2 - Route different middleware responses based on the incoming HTTP verb.  https://hackage.haskell.org/package/wai-middleware-verbs-0.3.2 (athanclark)
15:43:49 * hackagebot wai-middleware-content-type 0.4.1 - Route to different middlewares based on the incoming Accept header.  https://hackage.haskell.org/package/wai-middleware-content-type-0.4.1 (athanclark)
15:43:51 <ertes> k0ral: if PutStrLn is just going to be a putStrLn in the end, don't bother with PutStrLn and use FreeT
15:44:21 <k0ral> ertes: that's what I'm already doing, and it's not behaving correctly
15:44:42 <k0ral> ertes: I have IOs on both the interpreter and the DSL side
15:44:44 <Cale> Guest90851: Well, the distinction is between kind * and * -> * and * -> * -> *
15:45:01 <k0ral> ertes: and they get evaluated in an unwanted order
15:46:03 <ertes> k0ral: if in your action you write (liftIO c >> wrap d), then before the next free monad layer is known, c will have executed
15:46:07 <k0ral> ertes: I can even tell that the evaluation order isn't deterministic
15:46:24 <saurabhn_> do most people here seriously understand stuff like http://groups.inf.ed.ac.uk/links/papers/formlets-essence.pdf
15:46:34 <ertes> k0ral: that's pretty much a law
15:47:11 <ertes> k0ral: if you still think it's out of order, then it would be best if you could post a small example where it fails
15:47:47 <Guest90851> Cale: what's the point, since highter kind are already in the first case, such as ToJSON a => ToJSON [a]. What is the practical gain for having ToJSON1 []?
15:48:15 <ertes> saurabhn_: i recommend that you read ocharles' post in a slower pace
15:48:17 <mniip> so that you can write ToJSON1 f => ToJSON (Foo f)
15:48:25 <mniip> Guest90851, ^
15:48:37 <ertes> s/in/at/
15:48:59 <ertes> saurabhn_: to be honest i feel that you're trying to rush something that can't be rushed
15:49:26 <mniip> Guest90851, define a show instance for MaybeT
15:49:31 <mniip> protip: you can't
15:49:48 <mniip> either you dip into Data.Functor.Classes.Show1 or you go off haskell98 into FlexibleContexts
15:49:56 <ertes> instance (Show1 m, Show a) => Show (MaybeT m a)
15:49:57 <Cale> Guest90851: Well, sometimes you want to express that f is some type of kind * -> * such that whenever we have FromJSON a, we'll be able to get FromJSON (f a)
15:50:15 <Cale> Guest90851: It's hard to write that as a constraint directly.
15:50:24 <saurabhn_> ertes: actually I get the core Idea
15:50:28 <ertes> protip: Show1 sucks =)
15:50:52 <saurabhn_> the Form data-type encapsulates the behaviour of a form. Parse/validate user-input and result in a bunch of errors OR the parsed object.
15:51:01 <k0ral> ertes: you're probably right, I think the issue comes from the fact that my logger layer is running in a distinct thread actually
15:51:11 <Cale> Guest90851: I believe that in particular, this shows up in the mechanism that's being used to implement generic ToJSON/FromJSON instances.
15:51:32 <mniip> hmm
15:51:36 <Cale> But I could be wrong about that part
15:51:39 <mniip> ghc needs constraint introspection
15:51:42 <ertes> k0ral: that's much more likely…  the way FreeT is implemented, lifted effects can't be out of order with the free monad effects
15:51:47 <mniip> so that we could write typeclass combinators
15:52:55 <Cale> There is actually already a way to express this more directly, but whether you want to use it is another thing...
15:53:02 <ertes> in fact even the free monad effects must be in order, as long as they have a continuation
15:53:02 <mniip> I mean we can already pretty much tackle typeclass dictionaries, if we know ahead of time the exact methods they contain
15:53:33 <Cale> http://hackage.haskell.org/package/constraints-0.8/docs/Data-Constraint-Forall.html
15:53:46 <mniip> homemade skolems huh
15:53:49 <Cale> (This is polykinded now too)
15:54:56 <k0ral> ertes: ok the issue is clear to me now, thanks you for pointing me to the right direction
15:55:30 <k0ral> somehow I need to synchronize any call to putStrLn with my logger, to avoid those interleaved strings
15:55:47 <ertes> k0ral: you should do log I/O only from one thread
15:55:58 <Cale> But it would be nice to have some kind of quantification of constraints built in
15:56:09 <saurabhn_> is this the recommended approach? have an interim dataytpe to represent validated form input? Why would this code not result in a User object? https://github.com/j-hannes/digestive-functors-snap-auth-example/blob/master/src/Form/RegistrationForm.hs#L35-L41
15:56:12 <ertes> k0ral: in simple applications i just use an MVar (IO ())
15:56:27 <ertes> k0ral: forever (join (takeMVar logVar))
15:57:32 <Cale> saurabhn_: Because it doesn't register a user, it just validates that the input to the form is sane.
15:57:45 <saurabhn_> Cale: So, User Unsaved
15:57:49 <k0ral> ertes: well, I want to distinguish between logs, that are technical information, and program output, which happens to be text sent to stdout
15:57:57 <k0ral> ertes: I don't want to "log" the program output
15:58:23 <saurabhn_> ertes: do we really need a completely new data-type? Cant the existing User record be reused?
15:58:29 <Cale> saurabhn_: Right, it's just building one of these RegistrationData records while making sure some things are not empty and the email is "valid" for some definition of valid.
15:58:58 <Cale> Oh, it is checking that the username isn't taken as well
15:59:04 <Cale> Fair enough.
15:59:26 <ertes> saurabhn_: it's an applicative functor…  you decide what the form fields map to…  i've used tuples in simple cases
16:00:18 <ertes> saurabhn_: in other words: there is no obligation to define/use any particular type for every form
16:00:26 <ertes> s/every/any/
16:01:29 <saurabhn_> ertes: what's the 80/20 way to go for a beginner?
16:02:08 <jonored> saurabhn_: I'd lean towards using a different type for the form input than the user if only to have the type system make /sure/ a user object can't pop up out of nowhere. Might just be a newtype, though, if it's really all the same data.
16:02:28 <ertes> saurabhn_: to get your hands dirty
16:02:53 <ertes> use either tutorial.lhs or ocharles' post and start writing code
16:03:39 <saurabhn_> hmm okay.
16:03:48 * hackagebot nested-routes 7.2.1 - Declarative, compositional Wai responses  https://hackage.haskell.org/package/nested-routes-7.2.1 (athanclark)
16:03:57 <saurabhn_> now, the next problem -- servant's story with digestive-functors
16:04:08 <ertes> saurabhn_: and keep in mind that there isn't really much to it…  in the end it's a really simple library, and you only notice that by using it
16:04:49 <ertes> servant might be a problem =)
16:05:05 <ertes> i can't find a digestive-functors-servant
16:05:14 <saurabhn_> ertes: that's fine. But tying all these disjoint libraries together takes time, and weighs you down even before you can get any real work done.
16:05:41 <ertes> but then if you're serving forms, is servant really the right choice?  i thought it's mostly for web APIs
16:06:10 <ertes> saurabhn_: you're learning a new abstraction…  don't expect to get real work done just yet
16:06:47 <saurabhn_> ertes: it's for web APIs, but even they need to return validation errors in a structured manner. I don't want to reinvent the validation on the UI.
16:09:01 <ertes> saurabhn_: so there are no actual forms involved?  only GET/POST validation?
16:10:18 <saurabhn_> ertes: in Phase 2.1 However, In Phase 2.2 of my grand plan actual forms are also involved.
16:32:48 <mniip> wha
16:35:01 <niluje> Given extract :: (Eq a) => [a] -> Int -> (a, [a])
16:35:03 <niluje> extract xs idx =
16:35:05 <niluje>     (xs !! idx, filter ((/=) (xs !! idx)) xs)
16:35:33 <niluje> (which takes a list, remove the nth element idx from it and returns the element and the list without the element)
16:35:45 <niluje> why is it impossible to do:
16:35:45 <mniip> that's not what that does
16:35:56 <niluje> d = [1..10]
16:36:13 <niluje> let (a, d) = extract d 3
16:36:23 <niluje> reusing the name "d" causes an infinite recursion
16:36:31 <mniip> that's a recursive binding
16:36:32 <geekosaur> let is recursive in Haskell
16:36:38 <niluje> mniip | that's not what that does >> ??
16:36:44 <Welkin> lol
16:36:45 <grantwu> Also, what happens if there are duplicates in the list?
16:36:51 <geekosaur> you delete every element with the same value, not just the one element
16:36:51 <mniip> it also removes all other 3's from the list
16:36:59 <niluje> yeah
16:37:08 <grantwu> geekosaur: Hello again o/
16:37:10 <niluje> my list doesn't have duplicates :p
16:37:31 <Welkin> niluje: then why not use a Set?
16:37:46 <niluje> can I just answer you in a minute?
16:37:56 <niluje> I'd like to understand the recursive thing with let
16:38:00 <Welkin> or even a Map
16:38:01 <niluje> what does it mean?
16:38:10 <Welkin> niluje: it means this
16:38:27 <Welkin> > let fib a b = a : fib b (a + b) in fib 0 1
16:38:29 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
16:39:07 <riaqn> lyxia: I use catchError in the loop block now, but I still can't use it in line 50.
16:39:14 <niluje> hm
16:39:40 <riaqn> lyxia: current code: http://lpaste.net/179163 the old line 50 is now line 54.
16:39:48 <niluje> okay
16:39:56 <niluje> and for the Map/Set, I honestly don't know
16:40:28 <grantwu> Welkin: Wait, I'm also kind of a Haskell noob - that just looks kind of like a normal recursive function defined inside a let
16:40:43 <niluje> I'm trying to make my first "real" haskell program so I guess I make a lot of mistakes
16:40:43 <Welkin> > let a = 2:b; b = 1:a in b
16:40:44 <grantwu> Welkin: How does the original example of let (a, d) = extract d 3 work?
16:40:45 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
16:40:49 <grantwu> ah
16:41:45 <niluje> what's the "in b" :(
16:42:02 <Welkin> let <expression> in <expression>
16:42:04 <grantwu> niluje: It's what the entire let expression evaluates to
16:42:13 <geekosaur> the normal form of let is let {bindings} in expression
16:42:30 <grantwu> Also, I found this helpful https://mail.haskell.org/pipermail/beginners/2009-February/000901.html
16:42:34 <geekosaur> inside a "do" you can use the short form without the "in"; it translates to the longer form
16:43:20 <geekosaur> (specifically: `let {bindings}` becomes `let {bindings} in do <rest of do goes here>`
16:44:53 <niluje> yeyy thanks a lot for the mailing list
16:45:04 <niluje> it helped me to understand
16:45:26 <niluje> not for the "in" part though
16:45:58 <ertes> someone wrote a clear, readable fibs in #haskell
16:45:59 <Gurkenglas> arkeet, your recursion drawing is gone D: http://puu.sh/isDAc/a70bc263c5.jpg got it anywhere still?
16:46:02 <grantwu> niluje: Well, suppose there was no in
16:46:06 <ertes> what a weird day
16:46:10 <grantwu> niluje: What would a let expression evaluate to?
16:46:41 <niluje> I see let expressions are imperative variable assignments :p
16:46:48 <niluje> as*
16:47:05 <grantwu> Ah... well they aren't
16:47:36 <niluje> what are they then?
16:47:56 <grantwu> They let you bind values to names
16:48:17 <grantwu> So, kind of like variable assignments, except the values are immutable, at least, most of the time.
16:48:18 <ertes> niluje: you're literally just naming values
16:48:25 <grantwu> (Not sure how IORefs work)
16:48:57 <grantwu> Like, suppose you have some common value you want to use over and over again
16:49:04 <ertes> niluje: here is an example that shows you why you're *defining* and not *assigning*:  let x = x  -- this is an infinite loop
16:49:20 <Welkin> ertes: I always write it clearly :P
16:49:36 <niluje> ok
16:49:40 <niluje> and what's the in for then?
16:49:49 <grantwu> Well, expressions need to have values
16:49:59 <Welkin> niluje: it is the expression to be evaluated
16:50:07 <grantwu> (although, is _|_ a value? I forget.)
16:50:10 <Welkin> you can define something, for example a function
16:50:15 <Welkin> but it won't do anything until you run it
16:50:39 <Welkin> outside of a do-block you must use `let ... in ...`
16:50:43 <ertes> niluje: after defining a value you probably want to use it, too…  that's what the 'in' is for =)
16:50:51 <Welkin> only the do-block has a special notation for `let`
16:51:02 <ertes> niluje: you're defining for a certain scope, namely the expression after 'in'
16:51:11 <arkeet> Gurkenglas: oh yeah, puush deletes stuff that hasn't been accessed in a while
16:51:16 <arkeet> what was it?
16:51:37 <niluje> !!!
16:52:07 <ertes> > let x = 7 in (let x = 5 in x) + x
16:52:09 <lambdabot>  12
16:52:09 <niluje> ok, I understand
16:52:27 <ertes> niluje: inner scopes override outer scopes
16:52:37 <Welkin> and there is no assignment in haskell
16:52:43 <ertes> we call that shadowing, which is easy to mistake for assignment
16:52:45 <Welkin> only variable bindings
16:52:55 <niluje> ahah every new day learning haskell feels like when I started to understand pointers in C, years ago
16:53:04 <Welkin> it's like equations in math
16:53:13 <niluje> yes ok
16:53:41 <grantwu> I'm not sure what I'm going to do without being able to shadow in the same let, coming from SML
16:53:52 <grantwu> It was ugly, yes, but convenient...
16:54:18 <niluje> and you suggested to use a Map or a Set instead of a list, I will
16:54:42 <Welkin> niluje: well it depends on what you are trying to do
16:54:43 <niluje> I guess the Set will be more appropriate in my case 
16:54:46 <riaqn> I find my browser having 50+ tabs after I write a small haskell program.
16:54:50 <Welkin> different data structures are good for different problems
16:54:53 <ertes> grantwu: i name the final variable x and add a prime for every step backwards
16:54:53 <riaqn> mostly hackage docuemnt page.
16:55:06 <niluje> trying to implement a simple chinese poker game, and the extract function above is used to pick a card from a deck of 52 cards
16:55:07 <grantwu> ertes: Okay, but sometimes I had like, 3 or 4 versions
16:55:13 <riaqn> how do you guys search for document?
16:55:15 <grantwu> that's a *lot* of primes
16:55:16 <ertes> grantwu: let x'' = f x0; x' = g x''; x = h x' …
16:55:26 <ertes> grantwu: other times i go x0, x1, x2, x
16:55:33 <grantwu> hrm, yeah, that does make sense.
16:55:58 <grantwu> riaqn: Hoogle?  I'm not sure that's going to help you with your tab problem
16:56:00 <Welkin> grantwu: or you can avoid that by just composing functions in the right way and piping the data through
16:56:13 <Welkin> use Hayoo and Hoogle
16:56:19 <ertes> riaqn: get GHCi integrated in your editor…  very often names and types are what you need, and an integrated GHCi gives you those
16:56:21 <Welkin> Hayoo being more broad
16:56:43 <ertes> riaqn: other than that personally i just have a firefox keyword search to go straight to a hackage package
16:56:51 <arkeet> Gurkenglas: found it on my phone https://i.imgur.com/bxxMUp8.jpg
16:56:58 <Welkin> if you use duckduckgo, you can search hoogle using !h
16:57:02 <niluje> is there a coding style somewhere for haskell, like the python pep8 or the gofmt tool for golang?
16:57:06 <Welkin> or hayoo using !hayoo, or !hackage for hackage
16:57:18 <ahsfhyicxv> !stackage
16:57:20 <Welkin> niluje: yes
16:57:26 <Welkin> ahsfhyicxv: in your browser
16:57:37 <Welkin> niluje: https://github.com/tibbe/haskell-style-guide
16:57:49 <ahsfhyicxv> Welkin: I know
16:58:09 <ertes> riaqn: with firefox you can create a bookmark to <https://hackage.haskell.org/package/%s> (literally with the "%s"), then open the properties of that bookmark and type "p" for the keyword
16:58:20 <ahsfhyicxv> I was just mentioning that it existed
16:58:30 <ertes> riaqn: then typing "p mtl" will take you to the hackage page of the mtl package
16:59:27 <ertes> works best with an empty homepage, such that the address bar is initially highlighted
16:59:27 <riaqn> ertes: thanks. There's a addons named "instantFox" doing that too.
16:59:30 <niluje> thanks
16:59:58 <ertes> riaqn: the most important thing (IMO) is to get GHCi into your editor
17:00:04 <mniip> is there a package for browsing the GHC heap besides vacuum?
17:00:09 <Welkin> ertes: I haven't done that yet
17:00:09 <mniip> vacuum doesn't seem to support GHC 8.0
17:00:13 <Welkin> I look everything up manually
17:00:27 <Welkin> it would probably be nice to have that in emacs though
17:00:38 <riaqn> ertes: yes I agree. I'm using intero now; seen from the homepage it does not have much features.
17:00:44 <ertes> Welkin: if you use emacs, there is almost no excuse not to have it =)
17:00:54 <riaqn> ertes: by GHCi integration you mean?
17:01:28 <ertes> riaqn: not sure about intero, i use haskell-mode, which comes with haskell-interactive-mode
17:01:41 <Welkin> ertes: it does?
17:01:51 <ertes> it does for me
17:02:09 <ertes> i think i got it from MELPA, but let me check
17:02:10 <riaqn> ertes: AFAIK intero can works together with haskell-mode. let me try.
17:02:31 <ertes> yeah, MELPA
17:04:23 <riaqn> ertes: wait, by ghci you mean loading current buffer into a haskell environment, and be able to query something about the program?
17:04:50 <whacked> haskell, am i sexy? https://i.imgur.com/qddjCzc.jpg
17:04:57 <riaqn> ertes: if so, intero has this too; but I don't understand how it can help with my productivity.
17:05:37 <riaqn> whacked: dude, you need to photoshop you eyes. it's shining.
17:06:02 <riaqn> which is scaring.
17:06:32 <ertes> riaqn: yeah, that's what i mean…  haskell-interactive-mode shows you :type and on request :info, which is *usually* enough
17:07:12 <ertes> and when you really need the haddocks, make your way to the documentation as short and aimed as possible
17:07:15 <niluje> what the variables names xs and ys stand for?
17:07:30 <ertes> niluje: x, xs ~ house, houses
17:07:38 <niluje> ok
17:08:02 <ertes> usually a list, of which you'd call each element "x", but it's just a name
17:08:19 <riaqn> ertes: hmm.. in that case, intero is even more convenient. C-c C-t shows the type of the term selected, C-c C-i for the info.
17:08:24 <niluje> yep I thought there was something else 
17:08:29 <monochrom> Let's start a movement to change the convention to "xus" and "xi" :)
17:09:09 <ertes> riaqn: yeah, and haskell-interactive-mode also shows the type of the thing under point
17:09:24 <riaqn> nevermind, I think I have to google for functions I needed anyway.
17:09:38 <riaqn> As I don't know the type signature or name.
17:09:57 --- mode: ChanServ set +o monochrom
17:10:02 --- mode: monochrom set +b *!*@cpe-96-28-68-79.kya.res.rr.com
17:10:02 --- kick: whacked was kicked by monochrom (whacked)
17:10:13 <riaqn> otherwise I can integrate hoogle into emacs.
17:10:23 <monochrom> unless someone confirms that whacked's picture is legitimate
17:10:27 --- mode: monochrom set -o monochrom
17:11:08 <MarcelineVQ> not really the place to ask anyway
17:12:19 <Welkin> #haskell-hot-or-not
17:13:09 <monochrom> oh w00t, haskell-interative-mode also does "type of selected expression" for C-c C-t
17:14:49 * monochrom does the ultimate test: select a whole do-block and ask C-c C-t. The answer is no.
17:15:47 <Welkin> select the whole file
17:15:49 <athan> What do you call a graph where an edge might be connected to more than one node?
17:15:51 <Welkin> and ask for the type
17:15:59 <athan> derp, two nodes*
17:16:15 <Welkin> athan: what...?
17:16:20 <Welkin> how does that work?
17:16:44 <athan> Welkin: :)
17:16:57 <athan> It's undirected (for now)
17:17:04 <athan> I'm just trying to see if the concept exists
17:17:10 <Welkin> an edge connected to 3 ore more nodes?
17:17:16 <Welkin> or*
17:17:19 <athan> There's definitely a morphism `Rank3Graph -> Rank2Graph` though
17:17:32 <athan> where an implicit node is inserted at the 3-edge junction
17:17:38 <athan> Welkin: Yep
17:17:44 <grantwu> athan: Hypergraph
17:17:50 <athan> grantwu: Thank you!!
17:18:04 <Welkin> unless grantwu is joking
17:18:10 <grantwu> I definitely did not google "higher order graph" and "supergraph" before I found it
17:18:22 <Welkin> https://en.wikipedia.org/wiki/Hypergraph
17:18:24 <Welkin> guess not
17:18:25 * grantwu retreats into the shadows
17:20:25 <athan> Or maybe.... a graph where certain nodes are _forcibly_ known to be connected to >n or ==n other nodes?
17:20:28 <athan> idk
17:21:24 <ertes> athan: if you include a few laws, it might just be a category
17:21:39 <Welkin> imagine a quantum graph where the nodes are not there... or are they?
17:22:17 <ertes> they're neither there nor not there…  they are (there + not there) / sqrt 2
17:22:34 <Welkin> Schrodinger's graph
17:25:13 <niluje> let's say I have 
17:25:22 <niluje> data CardsValues =
17:25:24 <niluje>     Two | Three | Four | Five | Six | Seven | Eight | Nine | Ten
17:25:26 <niluje>     | Jack | Queen | King | Ace
17:25:28 <niluje>     deriving (Bounded, Enum, Eq, Show)
17:26:14 <niluje> to override the show method, do I need to write "instance Show CardsValues where Two = "two" ; Three = "three" ..." ?
17:26:35 <niluje> where show Two = "two"  show Three = "tree"*
17:27:12 <alercah> yeah
17:27:18 <grantwu> niluje: https://cdn.meme.am/instances/500x/71211787.jpg
17:27:31 <niluje> can't I get the constructor index anyhow and display it for cards from 2 to 10?
17:28:05 <dinomons> should i learn haskell or scala?
17:28:05 <niluje> grantwu: meaning?
17:28:11 <Welkin> dinomons: dumb question
17:28:19 <dinomons> why's that
17:28:30 <Welkin> dinomons: you are in #haskell, first of all
17:28:47 <ertes> dinomons: i wouldn't call it a dumb question, but you should expect to get biased answers =)
17:28:49 <Welkin> haskell and scala are nothing alike
17:29:01 <Welkin> scala is java with nicer types
17:29:12 <grantwu> niluje: I was just suggestion naming your type Card, instead of CardsValues
17:29:30 <ertes> dinomons: and which one you should learn depends on what you want to do (trying my best not to be biased)
17:29:40 <niluje> grantwu: I actually have a type card, gathering the value and the color
17:29:49 <Guest90851> dinomons: Haskell is the best language ever, but I may have a little bias ;)
17:30:02 <Welkin> if you want to learn real "functional programming" learn haskell
17:30:11 <grantwu> niluje: Oh, hrm.
17:30:29 <grantwu> I suppose that makes sense then.
17:30:38 <dinomons> yeah i'm about to install it and read the docs 
17:30:53 <niluje> good luck :D
17:33:59 <dinomons> cabal or stack? 
17:35:11 <systemfault> stack
17:35:40 <ertes> dinomons: religious question
17:35:50 <systemfault> Is it?
17:35:54 <ertes> yes
17:36:01 <systemfault> One works badly.. the other is a charm to work with.
17:36:11 <pavonia> niluje: Don't (mis)use Show for pretty-printing your data type. In most of the cases the deriving instance is just fine. If you need another function for rendering your values into a string, define your own
17:36:20 <dinomons> lol ok I wont ask that. I'll google instead
17:36:37 <ertes> dinomons: which operating system?
17:36:57 <Welkin> templeos
17:36:59 <dinomons> linux fedora 24 
17:37:02 <Welkin> what else would he be using
17:37:11 <dinomons> still haven't installed it :/
17:38:13 <systemfault> Welkin Haha
17:38:21 <ertes> dinomons: there are at least three options and little community consensus on which one is the best or even whether there is a best (it may be situational)
17:38:42 <systemfault> Welkin: You could write "Holy Haskell" for TempleOS since "Holy C" already exists
17:38:53 <ertes> dinomons: cabal-install, stack and nix in order of steepness of learning curve
17:39:00 <Welkin> someone should write "Holy Shit"
17:39:09 <Welkin> the Shit programming language
17:39:18 <ertes> dinomons: if you want the simplest tool, use cabal-install, if you want the most powerful tool, use nix…  stack is somewhere inbetween
17:39:24 <systemfault> SHIT should be some clever acronym
17:39:38 <ertes> dinomons: as a beginner cabal-install is fine under linux
17:40:00 <dinomons> ertes thnx I'll probably try the cabal and go from there 
17:40:02 <systemfault> Even the Haskellbook shows Stack first :P
17:40:16 <ertes> systemfault: the haskellbook is controversial as well
17:40:29 <systemfault> lol
17:40:29 <Welkin> systemfault: that is written by one of the biased users
17:40:29 <Welkin> lol
17:40:31 <Welkin> so of course
17:41:13 <tamago_> Shit : Start Hacking Incredible Types
17:41:47 <systemfault> Right
17:41:55 <Welkin> Left
17:42:00 <Welkin> I mean
17:42:03 <Welkin> ExceptT
17:42:16 <ertes> dinomons: don't worry about tooling for now…  you'll know when you need something more powerful, and by then you'll probably also know which one to use =)
17:42:47 <pavonia> Is there anthing trickier you can do with the FFI than passing functions as parameters to foreign functions? I'm trying to explore how far you can got with it
17:43:03 <dinomons> ertes thank you <3 
17:43:06 <Welkin> pavonia: threading?
17:43:20 <Welkin> pavonia: you mean something in the style of acme?
17:43:42 <pavonia> Not sure what that is
17:44:02 <Welkin> !hackage acme-iot
17:44:07 <Welkin> @hackage acme-iot
17:44:07 <lambdabot> http://hackage.haskell.org/package/acme-iot
17:44:23 <Welkin> it's a joke package
17:44:27 <Welkin> that does something dumb
17:45:12 <Gurkenglas> mniip you implemented my suggestion :D
17:45:47 <tamago_> Hey guys I have a monad question
17:46:08 <pavonia> Welkin: Hhm, no. I'm learning how to use the FFI and so far I know how to call C functions in Haskell, how to peek and poke data structures, and pass non-primtive data types or functions as parameters to foreign functions. I'm wondering if there is something even more complicated
17:46:39 <Welkin> pavonia: threading?
17:46:52 <Welkin> managing c threads in haskell
17:46:55 <Welkin> sounds like a nightmare
17:47:17 <mniip> Gurkenglas, I what
17:48:31 <Gurkenglas> mniip, http://ircbrowse.net/browse/haskell?id=23162206&timestamp=1470147539#t1470147539
17:48:44 <pavonia> Welkin: Where can you read about this?
17:48:51 <Welkin> pavonia: no idea
17:48:57 <mniip> but that already exists
17:48:57 <Welkin> I'm not even sure it's possible
17:48:58 <mniip> MonadIO
17:49:21 <Gurkenglas> What no I meant what you implemented in http://hackage.haskell.org/package/acme-iot
17:49:28 <mniip> ah
17:49:35 <mniip> I misread the link
17:49:55 <Gurkenglas> (Time to install that and see what happens)
17:50:19 <mniip> not responsible for any segfaults
17:50:34 <mniip> ghc optimizations are cray
17:50:48 <Gurkenglas> "-O0" turns even the default ones off right?
17:50:59 <Gurkenglas> Oh wait ghci doesnt do any optimizations right
17:53:48 <Welkin> hm
17:54:25 <Welkin> does anyone know how I would be able to bind to a commandline utility if there is no library available for me to hook into?
17:54:28 <Welkin> is that common?
17:54:39 <Welkin> seems like a bad way to do it
17:57:40 <monochrom> It is not common. But you can use System.Process stuff to invoke a command-line utility. The yucky part is you have to parse its output strings.
17:58:07 <mniip> seems alright if you don't have to spawn processes to use as callbacks
17:59:36 <Welkin> I'm not sure how to find out if there is a library I can use instead
18:00:19 <Welkin> http://lilypond.org/download.html
18:00:23 <Welkin> seems like not?
18:00:51 <mniip> Gurkenglas, the funniest part was
18:01:24 <mniip> [13:28:49] <hexagoxel> finally i can use IOT (IOT IO) and affect three different real worlds!
18:03:57 <geekosaur> Welkin, the conventional way is "expect". which is ... parsing its output. and even worse than it sounds
18:07:07 <lpaste> mniip pasted “cabal install ghc-vis” at http://lpaste.net/179171
18:07:11 <mniip> ideas?
18:12:04 <Cortlandd> how do I utilize a struct from a C header using FFI?
18:12:20 <Gurkenglas> aww no I didnt mean it that way mniip, IOT m should be directly runnable
18:13:08 <mniip> Gurkenglas, ?
18:13:09 <Gurkenglas> Like, IOT [] gives you Coil's power, IOT Maybe lets you oblivion the universe
18:13:37 <mauke> Cortlandd: usually with a tool like hsc2hs or c2hs
18:13:40 <mniip> oh it does
18:14:33 <mniip> 'sequenceIO Nothing' destroys the real worls
18:14:35 <mniip> world
18:15:24 <mniip> it's just that runIOT is a bit of a cheap trick, it actually simply uses the real world supplied in the input
18:15:30 <mniip> akin to unsafeInterlaveIO
18:16:14 <athan> Cortlandd: ayo
18:17:09 <athan> Anyone here know of a memcached that merely acts as a set, and not a key-value mapping?
18:17:15 <imPure> Hello. Does anyone know how to handle .so library dependencies with stack ghci? I have a .so with an undefined symbol, and then another library with that symbol, but including them both isn't sufficent.
18:18:52 * hackagebot rdf 0.1.0.0 - Representation and Incremental Processing of RDF Data  https://hackage.haskell.org/package/rdf-0.1.0.0 (TravisWhitaker)
18:19:14 <geekosaur> imPure, what version of ghc? (7.10 had some bugs in that area on various platforms; stack can't help you with them.)
18:19:26 <imPure> It's 7.10
18:19:49 <imPure> geekosaur: The only reason I'm using 7.10 is because I thought that was the newest that stack supported
18:20:37 <geekosaur> stackage LTS is still 7.10. sufficiently recent stack can use 8.0.1-based stackage nightlies or the "ghc-8.0.1" resolver
18:21:14 <geekosaur> (even older ones will try to, but may encounter bugs)
18:21:46 <imPure> geekosaur: I'm just switching to stack from cabal after years of... not stack. So when trying to parse what you're saying, I'm thinking "Wait, can I mix 7.8 and 8.0 with stack?"
18:22:09 <imPure> geekosaur: I have a few other interpretations of what you're saying, like, there's a bleeding edge stack that's 8.0
18:22:46 <imPure> geekosaur: I'd prefer 8.0, but want something stable.
18:23:41 <geekosaur> stack itself is not specific to a compiler. stack allows you to use "resolvers" which are package sets that are known to work together.
18:24:12 <geekosaur> ghc 8.0.1 did uncover some small bugs in stack, but it will likely work for most uses. otherwise, the question is not stack, but what resolver you pick to build something
18:24:32 <Welkin> lts-3.6
18:24:33 <Welkin> lol
18:24:58 <geekosaur> (you specify the resolver in stack.yaml, or there is a default global one which is set to whatever ghc was current when you first installed stack)
18:25:03 <imPure> geekosaur: Ahhh. So 7.8 GHC has bugs with .so, and stack resolvers for GHC 8.0 may have bugs, but they may not apply, and I can stick with stable GHC 8.0 and just use unstable stack 8.0?
18:25:35 <imPure> geekosaur: If I interpereted correctly, that sounds worth a shot
18:25:41 <geekosaur> um not quite. stack itself can occasionally get into trouble trying to use ghc8, but you can "stack upgrade" to install a newer stack to get around those.
18:26:21 <geekosaur> the long-term support resolvers are all still based on ghc 7.10. the nightly resolvers are all based on ghc 8.0
18:27:16 <geekosaur> ("nightly" doesn't necessarily mean "unstable", just "uses newer features". some packages you might build require the newer resolvers and ghc8)
18:30:00 <imPure> geekosaur: Upgrading. Thanks
19:11:27 <ahsfhyicxv> Does anyone know how to get ghcmod working with ghcjs?
19:11:39 <ahsfhyicxv> #ghcjs is dead
19:14:43 <imPure> geekosaur: Gave up trying to do it the right way, changed my c++ code to compile all the functions into a single .so, and that works. But I'm glad I'm on GHC 8.0 now :)
19:15:19 <Cale> ahsfhyicxv: https://github.com/ghcjs/ghcjs/issues/271 (would've linked you in #ghcjs but you left :)
19:16:16 <Cale> ahsfhyicxv: Apparently it's blocked by https://github.com/DanielG/ghc-mod/issues/654
19:16:20 <Cale> oops
19:16:39 <Cale> Sorry, I was going to say "Apparently it's blocked by upstream issues"
19:16:43 <Cale> and then link things :)
19:17:52 <Cale> there's also this bug https://github.com/DanielG/ghc-mod/issues/782
19:19:23 <ahsfhyicxv> Cale: Thanks. So no autocomplete yet. :(
19:20:15 <Cale> ahsfhyicxv: I just use my editor's autocomplete
19:20:29 <Cale> (which isn't terribly smart, but meh)
19:22:10 <ahsfhyicxv> Cale: Do you know how to get ghcjs-dom and webkitgtk working? Then, I could get autocomplete.
19:22:20 <ahsfhyicxv> I use stack and homebrew
19:22:33 <OMGilluminated> Homebodies
19:22:53 <Cale> ahsfhyicxv: Well, what I'd do personally, is just use reflex-platform
19:23:39 <OMGilluminated> oooooooo Got What you Meant
19:23:42 <Cale> ahsfhyicxv: It has a try-reflex script in it which will put you in a nix environment with a working ghc, ghcjs, and of course reflex-dom which uses webkitgtk.
19:24:15 <Cale> I haven't tried stack for this, but I know some people use it successfully.
19:24:26 <OMGilluminated> Where the 49ers fans at?
19:24:38 <Cale> OMGilluminated: This channel is for discussion of the programming language Haskell.
19:24:52 <OMGilluminated> Respect Teach me
19:25:29 <OMGilluminated> STart BAsic
19:26:01 <OMGilluminated> 1.78654231 782 25 15 12 5g 99og 2500ooG 19
19:26:09 <OMGilluminated> teach me please
19:26:20 <ertes> what?  respect?
19:26:38 <OMGilluminated> WoW
19:26:47 <Cale> OMGilluminated: a lot of people like this course http://www.cis.upenn.edu/~cis194/spring13/lectures.html
19:26:54 <OMGilluminated> Dont Destroy This Comp
19:27:34 <OMGilluminated> Word
19:27:38 <OMGilluminated> ty
19:28:31 <ahsfhyicxv> Cale: I will try it. Thank you for your help
19:28:47 --- mode: ChanServ set +o shachaf
19:29:02 <dogweather> Anyone care to give critique a type? I wrote Amendment to be a 'model' in my apps http://lpaste.net/179176
19:29:08 --- mode: shachaf set +q-o OMGilluminated*!*@* shachaf
19:29:38 <Cale> ahsfhyicxv: I know Ryan tests it on MacOS X, but I'm not sure how many Mac users there are, so we would certainly be interested in knowing if you have any trouble
19:33:55 * hackagebot dirstream 1.0.1 - Easily stream directory contents in constant memory  https://hackage.haskell.org/package/dirstream-1.0.1 (GabrielGonzalez)
19:35:12 <Cale> ahsfhyicxv: any luck?
19:35:33 <ahsfhyicxv> Cale: Installing now.
19:35:36 <Cale> cool :)
19:37:11 <ertes> (after yesterday's discussion i have taken the time to properly evaluate git, and i might find myself switching to it from darcs)
19:38:19 <Cale> ertes: I use git all the time and wish that it worked more like darcs
19:39:53 <ertes> Cale: i'll probably have the same experience, but cherry-picking, reverting and merging seem to cover most of my darcsy workflows, although in a slightly awkward way
19:40:08 <ertes> + rebasing
19:43:09 <ahsfhyicxv> Cale: It installed
19:46:26 <dmwit> "constant memory" seems unlikely
19:47:19 <ahsfhyicxv> Cale: Hello World works
19:49:39 <ahsfhyicxv> In both browser and in gtk.
19:58:38 <lpaste> dmwit pasted “graph construction monad” at http://lpaste.net/179178
19:58:53 <dmwit> I put together a cute hack this weekend that I thought I would share.
19:59:07 <dmwit> Also, feel free to tell me about the Hackage library that already does this that I should know about.
19:59:51 <dmwit> The main improvement over fgl's own graph construction monad is that you don't have to remember to create endpoints every time you add an edge.
20:00:16 <dmwit> But also the interface is a little cleaner, in my opinion.
20:04:14 <Cortlandd> Found a solution but having trouble
20:06:06 <Cortlandd> decided to go with inline-c library. But creating a struct is a bitch
20:07:56 <Cortlandd> Nevermind. Haskell isn't the tool for the job in this caser
20:21:35 <ahsfhyicxv> Cale: Should I use nix instead of stack? ghcjs-dom works with gtk in the hello.js. Now I just have to get it to work in the project.
20:23:56 * hackagebot kawaii 0.0.1.1 - Utilities for serving static sites and blogs with Wai/Warp  https://hackage.haskell.org/package/kawaii-0.0.1.1 (etcinit)
20:35:33 <jchia_> conduit question: cereal package is to Data.Conduit.Cereal as binary package is to X. Does X exist? What is it? X is not Data.Conduit.Binary, which is only for working with files as sources and sinks.
20:36:33 <jchia_> i think the answer is Data.Conduit.Serialization.Binary
20:37:40 <c_wraith> jchia_: https://hackage.haskell.org/package/binary-conduit
20:37:51 <c_wraith> jchia: go by package name, not module name
20:38:22 <jchia_> c_wraith: thanks
21:43:32 <Gurkenglas> https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Free.html#v:unfoldM should say that the effects are in preorder, and maybe there should be a version in breadth-first order.
22:35:38 <gestone> hey all, i'm trying to solve this hackerrank problem
22:35:44 <gestone> https://www.hackerrank.com/challenges/maximum-element
22:36:02 <gestone> and i'm sort of lost on how to do this cleanly
22:36:12 <gestone> i was thinking about using the State monad
22:36:33 <gestone> but i'm not sure how i would effectively do that with [String] representing each of the commands
22:37:27 <saurabhnanda> gestone: if you can write the program in any other language, I can help you translate it to Haskell
22:37:45 <gestone> sure i can write in java
22:39:10 <kadoban> gestone: If you have something like [String], and  String -> State Whatever (Maybe Element)   (which, if it's a type 3 query, outputs the maximum element, if not just does whatever it's supposed to do to the state), then you can do something like mapM to get all of the results
22:39:41 <kadoban> If that made any sense
22:40:21 <maybefbi> does hasql need protection from sql injection?
22:40:36 <gestone> yeah, i was originally thinking to have a function that went from [String] -> [IO] and use traverse on that
22:41:01 <Rarrikins> gestone: I know a nice way to represent it.
22:41:30 <gestone> Rarrikins: excellent, please do explain
22:41:45 <kadoban> You could use IO instead, it's strictly more powerful that State, but you shouldn't need it for this.
22:42:21 <Rarrikins> gestone: You store (elementJustAdded, max elementJustAdded maxJustBelow)
22:42:38 <Rarrikins> gestone: Then you store that on a list, using it as a stack.
22:43:41 <kadoban> maybefbi: It looks like you use prepared statements, which if you do it correctly is safe from sql injection.
22:43:51 <gestone> hmm then when an element is popped, i would have to check if that was the max
22:44:13 <Rarrikins> gestone: Nope, each element of the list has the maximum for itself and everything below it.
22:44:14 <gestone> kadoban: how would i just use IO instead?
22:44:25 <Rarrikins> gestone: No need to recalculate maxes when you pop.
22:44:29 <gestone> ahhh
22:44:44 <maybefbi> kadoban, thanks. i do ask it to prepare statements
22:45:08 <kadoban> gestone: You'd use pretty much the same thing, except instead of  String -> State Whatever (Maybe Element), you'd use   String -> IO (Maybe Element)
22:45:47 <kadoban> maybefbi: It's of course possible to do prepared statements wrong, but if you know the phrase "sql injection" you probably know how not to do that, most likely.
22:47:10 <gestone> how would i keep track of the state of the stack then with that approach? for String -> IO (Maybe Element)?
22:47:11 <kadoban> gestone: I wouldn't really recommend it though, the State is kinda just better use of the type system.
22:47:16 <gestone> ah
22:47:23 <maybefbi> kadoban, ive got a job using sql injection, but i dont know how to do prepared statements wrng
22:47:32 <kadoban> With IORefs and such
22:48:29 <gestone> so have an IORef [] where the [] represents the stack?
22:48:49 <gestone> and everytime the function is executed, mutate that IORef?
22:49:20 <kadoban> gestone: Sounds right
22:49:42 <gestone> hmm i feel like that's cheating since IORef doesn't really seem pure
22:50:04 <kadoban> It's pretty much not at all, yeah. Certainly wouldn't be my first choice of solutions.
22:50:27 <maybefbi> kadoban, its ok i figured it out. i should not use string concatenation for prepared statements
22:50:43 <gestone> yeah, part of the reason i really want to learn haskell is to learn how to write cleaner and purer code
22:50:44 <maybefbi> kadoban, im already only using $1, $2 style parameters
22:51:33 <kadoban> maybefbi: Sounds right
22:51:39 <gestone> so i think i might go to try with Rarrikins' solution
22:51:46 <saurabh__> gestone: does the problem really need to use the State monad?
22:52:19 <gestone> saurabh__: i don't actually think so, but i feel like having tuples to represent intermediate state might not be the cleanest way to do things
22:52:25 <gestone> though i could be wrong
22:53:06 <saurabh__> where the FPcomplete online haskell IDE?
22:53:13 <kadoban> You never *need* to use State.
22:53:27 <gestone> is a general rule of thumb to avoid using State and other similar monads?
22:53:52 <gestone> i would like to see where it could be used though, even after reading haskellbook i'm still a little lost on when it could be useful
22:54:00 <gestone> i've only seen it used in toy examples with manipulating stacks
22:54:00 <saurabh__> how come I can't find the FP Complete online haskell IDE?
22:54:09 <saurabh__> is it this? https://tryhaskell.org
22:54:59 <kadoban> gestone: I'd try using it (which you can do with Rarrikins solution, by the way, his answer is orthogonal to how you organize the code itself), see how it turns out. See if you can find a better way to structure it, etc.
22:55:33 <gestone> i'll give it a shot
22:56:18 <Squarism> Cant say ive really tried to understand the motivations around its use of a monad more than the general concept. I played around a little with IO here. Now that i tried to write impure functions i atleast conclude its hard making io actions happen if your function doenst return IO a. Ie the only values IO actions give are IO actions. I guess this is very intentional right?
22:56:33 <Squarism> Regarding IO
22:57:25 <gestone> that's what i thought, it signals the intent that the function is impure
22:58:37 <Squarism> i thought i could do : myFunk = 1 == (putStrLn "hello") - but it doesnt have a Eq even 
23:02:53 <Squarism> *rambeling*
23:03:03 <riaqn> Hi, my machine's memory is very limited; when I run "stack build" it crashes very frequently.
23:03:13 <riaqn> Any solutions?
23:03:32 <Cale> Squarism: The way to think of it is that IO actions are simply descriptions of what needs doing.
23:03:32 <Squarism> rasberry pi? 
23:03:45 <kadoban> riaqn: You can try -j1 or whatever, so at least it doesn't try to do much at once.
23:03:57 <riaqn> kadoban: stack build -j1?
23:04:03 <Cale> Squarism: You can have IO actions which say to execute other IO actions, but simply evaluating which IO action you have won't cause it to be executed
23:04:11 <kadoban> riaqn: Other than that ... maybe increase swap space and settle in for a long time?
23:04:16 <saurabh__> gestone: see if this solves the problem -- https://gist.github.com/saurabhnanda/643165da6af60c6110a7500dfc10fdb3
23:04:21 <kadoban> riaqn: Should be, I think. I don't use it anymore.
23:04:31 <riaqn> I suspect it's -j1 by default. It's a single-core machine.
23:04:41 <Cale> Squarism: (any more than, say, opening /bin/ls in a hex editor would cause the contents of your home directory to be printed to the terminal)
23:04:46 <riaqn> does make sense to use -j4 by default, right?
23:04:53 <riaqn> s/does/does not
23:05:06 <saurabh__> gestone: you'll have to process the entire input to [Query] in one shot
23:05:11 <Squarism> riaqn, i read rasberry pi users often build in staging environment and then copy their code over to the rasberry to execute. 
23:05:12 <saurabh__> gestone: that's the downside of this approach
23:05:29 <riaqn> Squarism: not raspberry pi, but VPS.
23:05:37 <gestone> saurabh__: ah thanks
23:05:42 <Cale> Squarism: In a compiled program, you define an IO action called main, and it gets executed when the program runs, and in turn it may say to execute other IO actions.
23:05:42 <riaqn> CPU is strong, but memory is limited(only 768M)
23:05:43 <Rarrikins> riaqn: In general, that makes sense, since a good portion of CPUs these days have four simultaneous threads.
23:06:10 <Rarrikins> riaqn: s/have/can handle/
23:06:25 <riaqn> Rarrikins: but does it make sense?
23:06:39 <riaqn> Rarrikins: and I don't know what you means by "can handle"
23:06:53 <Cale> Squarism: But yeah, if you have something, say, whose type is IO String -> Integer, then you know it's not doing anything interesting with the IO String value -- IO t is an abstract data type, and so you can't inspect what would be performed and compute something based on that.
23:07:12 <Rarrikins> riaqn: I mean that the CPU has enough cores or hyperthreading to run four threads simultaneously.
23:07:17 <riaqn> of course the CPU doesn't crash. But no faster.
23:07:25 <saurabh__> gestone: the problem itself is not completely defined. What should be printed if the Query is '3' but the stack is empty? My code is going to throw a runtime error in that case. You might want to handle it gracefully.
23:07:35 <riaqn> Rarrikins: I said that it's a single-core cpu.
23:07:45 <Cale> Squarism: But even if you could inspect the IO action, simply evaluating a function of that type wouldn't cause the effects described by the IO String value to actually be carried out.
23:07:58 <systemfault> pyon: Do you have a favorite "general purpose language"?
23:08:00 <Cale> Does that make sense?
23:08:24 <Squarism> Cale, oh ok.. so what triggers that? 
23:08:33 <Squarism> Cale, the execution?
23:08:33 <systemfault> pyon: I know you love languages like SML and AGDA, dislike Haskell to some extent
23:09:06 <dmwit> Squarism: `main` is executed. There are no other triggers.
23:09:14 <systemfault> Oh god, wrong chan.
23:09:21 <riaqn> Rarrikins: and my impression is that, hyper-threading is good for context switching, but does nothing for heavy computation.
23:09:21 <dmwit> Squarism: In ghci, you can ask for particular actions to get executed.
23:09:24 <Cale> Squarism: main gets executed, and inside a do-block, when you see  v <- x  it means "execute the action x, and call its result v", and if x :: IO t, then v :: t, and the do block as a whole will also be an IO action.
23:09:35 <riaqn> heavy computation = compilation.
23:09:58 * dmwit tries to imagine what Squarism would want `1 == putStrLn "hello"` to do and boggles
23:09:59 <cocreature> one of the nice things that made IO really click for me is that you can write an io action to an mvar without executing it reading it from another thread and only then execute it
23:10:07 <Cale> Squarism: Also, if you give an IO action at the ghci prompt, ghci will automatically execute it for you.
23:10:35 <riaqn> Rarrikins: "Just remember, for computation heavy workloads Hyper-Threading doesn’t add any real compute capability."
23:10:36 <riaqn> https://www.pugetsystems.com/labs/hpc/Hyper-Threading-may-be-Killing-your-Parallel-Performance-578/
23:10:41 <kadoban> riaqn: I can't imagine this thread of conversation actually matters to your problem at hand?
23:11:00 <Squarism> Cale, im down with all that that.. monads, io actions, the do sugar... i just wanted to gain some deeper understanding here. =D
23:11:06 <Cale> cocreature: I even use that quite a bit -- it's often nice in a multithreaded server or something to set up a Chan of IO actions to be carried out in a single thread
23:11:22 <riaqn> kadoban: yeah, not related, sorry.
23:11:23 <cocreature> Cale: yeah I use that a lot as well
23:11:42 <Squarism> dmwit, i just wanted to fool ghc
23:11:45 <kadoban> Squarism: There's not a lot to deeply understand. Monad is just a pattern that fits in quite a few places and can be encoded in the language/type-system nicely.
23:15:22 <Cale> Squarism: You basically never use it, but there is a primitive called unsafePerformIO such that evaluating (unsafePerformIO x) will cause x to be executed and its result to be produced as the result of the evaluation. It basically only exists for cases that you'd otherwise end up modifying the compiler to extend evaluation with some new feature, or for doing FFI to C functions which you know are actually pure functions (and even in 
23:15:22 <Cale> that case it will usually bite you, since C functions are often not as pure or threadsafe as one might expect)
23:18:49 <Cale> I've been programming in Haskell for 15 years and I've only really put unsafePerformIO to use in real code once or twice -- I've actually needed unsafeCoerce (which just bypasses the type system altogether) more often than unsafePerformIO.
23:20:43 <Squarism> Cale, thanks for all your hints.
23:21:23 <Cale> gestone: btw, for that "stack" problem, I would use something like  data Stack a = S [a] (Map a Integer), where you maintain the stack as a list, and then keep track of the count of how many elements of any given value there are in a Map. There's a findMax function which will efficiently tell you the element with the maximum key.
23:22:05 <Squarism> kadoban, well as im new to the paradigm i need to get rid of all the why's
23:23:55 <gestone> Cale: ah i see. would the runtime of that function be log(n)?
23:26:33 <kadoban> gestone: Insertion/deletion/modification/lookup in the Map is O(lg n), yeah.
23:27:48 <Squarism> Ok.. some statements ive gathered. True or am i just confused. 1. IO is modelled with monads that only can be returned for them to take place. 2. modelling the side effect in the function signature by means of IO action let us call the function pure. 3. writing programs with pure functions makes the easier to reason about and we could do deterministic executions of the code (if we were in control of th
23:27:49 <Squarism> e IO monad)
23:27:56 <Squarism> ?
23:28:43 <gestone> but it would be cheaper to keep track of intermediate state of the current maximum for this particular problem, i.e keep track of the cur max for each elem in the stack
23:28:58 <gestone> don't think it would be as nice though
23:31:53 <kadoban> gestone: Annotating the stack (or using two stacks) is pretty much just better, it's a tad harder to come up with though.
23:33:19 <gestone> so i was reading haskellbook the other day and chris mentioned the vector library
23:33:31 <gestone> how does indexing into a vector have O(1) runtime?
23:33:32 <dmwit> gestone: I think the approach you suggest would be quite nice indeed.
23:34:49 <cocreature> gestone: are you familiar with arrays/vectors in imperative languages like c++ or java?
23:34:56 <gestone> mhm
23:35:08 <gestone> vectors are implemented with finger trees yes?
23:35:12 <cocreature> no
23:35:15 <gestone> ahh
23:35:27 <gestone> that's what i thought i had read
23:35:28 <cocreature> vectors are just a contigous area in memory
23:35:46 <cocreature> so to index all you have to do is calculate base + index * elementsize
23:35:51 <cocreature> and access memory at that position
23:35:58 <gestone> right
23:36:17 <gestone> so is that how it's implemented in haskell?
23:36:22 <cocreature> yep
23:37:46 <dmwit> :t foldM
23:37:47 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
23:37:51 <arkeet> maybe the thing implemented with finger trees that you're thinking of is Data.Sequence
23:38:20 <gestone> so... then why can't we have O(1) lookups for hash maps like in imperative languages? since hashmaps and dictionaries are implemented with hashtables which are backed by arrays, why is haskell's hashmap implemented with a balanced tree?
23:38:33 <arkeet> it's not a hash map
23:38:45 <arkeet> (you mean Data.Map?)
23:38:48 <gestone> ah yeah
23:38:56 <gestone> whoops
23:39:25 <gestone> to clarify, i'm just curious to know why Data.Map is implemented with a balanced tree
23:39:25 <Squarism> Despite this lack of sideeffects - Doing threaded IO, channels and STM feels as if it bring you back to imperative land in terms of "make it easy to reason about". Should we be happy we can reason about separate threads or should we just call the effort good - but not a complete solution. *rambelling*
23:39:26 <kadoban> gestone: You could make a hashmap in IO fine. It by nature isn't a persistent data structure. It doesn't really work in pure code at all.
23:40:09 <dmwit> gestone: Traditional hashmaps are ephemeral.
23:40:20 <dmwit> gestone: If you're okay with that, you can have it in Haskell, too.
23:41:01 <gestone> along with the quick O(1) lookup?
23:41:17 <gestone> i've noticed reading the hackage docs on Data.HashMap that all operations are still log(n)
23:41:21 <ongy> when wrapping a C api, which type should I marshal 'struct timeval' to?
23:41:38 <cocreature> gestone: see https://hackage.haskell.org/package/hashtables-1.2.1.0/docs/Data-HashTable-Class.html for an actual hashmap
23:42:31 <dmwit> gestone: Data.HashMap is trying to make a tradeoff between persistence and non-asymptotic performance.
23:42:58 <dmwit> gestone: But you can have a real hashmap if you want it. Dunno whether a good implementation exists on Hackage, to be fair.
23:43:34 <gestone> hmm okay
23:43:48 <kadoban> (The "real" ones would be in IO or ST)
23:43:56 <gestone> kadoban: so what's the defn of a persistent data structure?
23:44:03 * hackagebot bioinformatics-toolkit 0.2.2 - A collection of bioinformatics tools  https://hackage.haskell.org/package/bioinformatics-toolkit-0.2.2 (kaizhang)
23:44:22 <gestone> one that's alloced on the heap?
23:44:39 <glguy> ongy: you'd probably make a new type to marshal it to
23:44:43 <kadoban> gestone: A persistent data structure doesn't screw up previous versions of itself when it's updated.
23:45:18 <kadoban> gestone: If you have a Map and add an element to it, you get a new Map back, the original Map still works perfectly (and doesn't have the new element).
23:45:30 <glguy> the time package doesn't export its low level c struct
23:46:06 <dmwit> gestone: For fun, here's how your proposed implementation -- a stack with the max at each entry -- might look. I think it came out quite nice.
23:46:11 <dmwit> http://lpaste.net/179196
23:46:26 <kadoban> gestone: You can't really do that with a hash table. There's no way to add an element, and have old copies of the hash table still work unchanged (without horrible horrible performance, like copying the whole thing or something)
23:46:55 <gestone> kadoban: ahh but you could do that with a tree
23:47:05 <dmwit> gestone: With a persistent data structure, when you modify the data, you can still use the old version of the structure without paying any additional cost.
23:47:22 <kadoban> gestone: This is important, because in pure code, if you have a value ... it always means the same thing. If you have a Map called  blah, blah *always* needs to have the same value, it can't change or cease existing when you add an element to it and get a new value back.
23:47:47 <kadoban> gestone: Right, you can create a new BST based on an existing one (with an element added or removed), efficiently in time and space, and both work perfectly.
23:47:57 <gestone> got it
23:48:28 <gestone> so then
23:48:32 <gestone> by using something like IORef
23:48:51 <gestone> we would be violating that principle
23:48:59 <dmwit> right
23:49:15 <dmwit> It would probably be something like IOArray, though. Or one of the mutable vector types.
23:49:37 <dmwit> And of course you still have to deal with collisions in whatever way you plan to do that.
23:50:11 <dmwit> There are easy ways to handle collisions that introduce a log(n) cost. ;-)
23:50:30 <gestone> you'd do something similar to seperate chaining right?
23:50:39 <gestone> except you'd just have it point to the root of a balanced BST
23:50:55 <gestone> instead of a LL
23:51:10 <dmwit> Pointing at a balanced BST is a good way to be back in O(log n)-lookup-time land.
23:51:16 <kadoban> Sure, you could use Data.Maps as the buckets.
23:52:01 <kadoban> dmwit: Well, hash tables are usually O(n) lookup worst-case, so the O(log n) thing isn't a problem. The real problem is that would probably screw your constant factors.
23:52:17 <kadoban> I guess? I dunno.
23:52:51 <dmwit> Personally I would be more than happy to throw a `Data.Map` in each bucket.
23:53:01 <dmwit> But then, I'm morethan happy to just use `Data.Map` in the first place.
23:53:10 <kadoban> I kinda hate hash tables in general, so yeah I'd be fine with that too xD
23:53:13 <gestone> dmwit: oh also, i took a look at your solution that was really concise
23:54:01 <gestone> dmwit: this is what i came up with (with the help of other fellow haskellers) http://lpaste.net/179199
23:54:14 <gestone> though i think there's a bug somewhere
23:54:19 <gestone> it's not passing the hacker rank tests
23:54:34 <dmwit> gestone: Yes, your `PrintMax` case doesn't recurse.
23:54:43 <dmwit> I fixed that in passing by not having manual recursion on the queries. ;-)
23:54:55 <gestone> oh whoops
23:58:03 <Rarrikins> gestone: Maybe putStrLn instead of print.
23:58:17 <dmwit> nah
23:58:21 <dmwit> That doesn't even typecheck.
23:58:31 <gestone> can't putStrLn an int
23:59:01 <gestone> i'd have to do something like putStrLn (show x) where instead i could just do print x
23:59:04 <dmwit> Oh, I misread your `pop`. I should have written `pop = drop 1` to match yours.
