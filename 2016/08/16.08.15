00:00:57 <seafood> ReinH: A priority queue would be good
00:06:25 <cocreature> seafood: pqueue is a fairly popular package, but I haven’t used it myself
00:07:04 <ReinH> pqueue or fingertree
00:07:19 <ReinH> fingertrees, fingertrees everywhere
00:07:37 * hackagebot http2 1.6.2 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.6.2 (KazuYamamoto)
00:07:37 * hackagebot persistent-audit 0.1.0.2 - Parses a Persist Model file and produces Audit Models  https://hackage.haskell.org/package/persistent-audit-0.1.0.2 (mchaver)
00:08:42 <ReinH> or a leftist heap from Okasaki
00:08:44 <ReinH> @hackage heap
00:08:44 <lambdabot> http://hackage.haskell.org/package/heap
00:09:41 <ReinH> not to be confused with
00:09:43 <ReinH> @hackage heaps
00:09:43 <lambdabot> http://hackage.haskell.org/package/heaps
00:09:49 <cocreature> he number of priority queue implementation on hackage is crazy
00:10:09 <ReinH> Which are Brodal/Okasaki skew-binomial heaps with O(1) merge
00:10:32 <ReinH> finger trees are actually a bit silly for min (or max) priority queues, but they work
00:10:59 <ReinH> heaps is an edwardk joint so I assume it's good
00:12:07 <daniel_w> finger trees won't work well if you want to merge heaps with overlapping priorities
00:12:50 <ReinH> daniel_w: really they just have niche usage when you want quick access to min and max
00:13:00 <daniel_w> yes
00:13:41 <ReinH> TMR 16 has a thing on them too https://themonadreader.files.wordpress.com/2010/05/issue16.pdf
00:18:18 <daniel_w> One thing to watch out for is that some data structures, like finger-trees, make essential use of laziness, so when you delete things, it doesn't necessarily mean that memory can be reclaimed
00:27:54 <toogley> hey. why does "take 1  [ (zip [1..10] (cycle [True])) | primes <- [3..10], primeness <- (cycle  [False]) ]" output "[[(1,True),(2,True),(3,True), ....]]" and not "...(3,False) ? i'd expect that the second part (the list ocmprehension) creates a new list, based on the old one, but with changed values (from true to false) of anything in [3..10]. why is this not happening?
00:29:17 <shachaf> Where would False get involved in anything?
00:29:32 <shachaf> You aren't using "primeness" at all.
00:29:47 <shachaf> (Also, that would be much easier to read if you dropped redundant parentheses.)
00:33:16 <todaystommorow> Where could I find a full algorithm like DSA being implemented in haskell from the ground up?
00:33:23 <toogley> shachaf: /57
00:34:04 <toogley> shachaf: (the /57 was not meant to you)
00:36:57 <toogley> shachaf: hm, i think i missunderstood list comprehension..
00:36:59 <toogley> shachaf: thx
00:37:50 <Athas> todaystommorow: I'm not sure Haskell is a good fit for DSA.
00:38:01 <todaystommorow> athas why not?
00:38:20 <todaystommorow> Or what crypto algorithm would haskell look good with?
00:38:44 <todaystommorow> RANDOM CHANGE OF SUBJECT: Do people seriously get jobs programming haskell if they are self taught?
00:38:47 <Athas> todaystommorow: crypto generally doesn't play well to Haskell's strengths, and you may end up vulnerable to side channel attacks.
00:39:09 <Athas> Pretty much every Haskell programmer is self-taught to some degree.
00:39:22 <todaystommorow> Do some of them have jobs programming haskell?
00:40:14 <Ashy> todaystommorow: i think most haskell jobs are in finance where it's likely you'll need a degree of some sort
00:40:44 <todaystommorow> So I could major in maths and then get a job in finance programming haskell?
00:41:25 <Ashy> i dont have finance experience so someone else might have to answer
00:41:41 <Ashy> but i think it's possible, especially if you study the kind of maths the quant guys use
00:42:03 <merijn> todaystommorow: Not sure maths would be a better degree than CS for that
00:42:17 <Athas> todaystommorow: I notice a lot of physicists getting jobs in finance.
00:42:18 <todaystommorow> Would it be equal?
00:42:19 <merijn> todaystommorow: but on the other hand, with math you could probably get into finance anyway :p
00:42:32 <todaystommorow> Cool because I like maths
00:42:35 <Athas> Apparently there is some morphism between physical and financial models.
00:42:56 <todaystommorow> Well that is strange
00:43:05 <todaystommorow> maybe it's just because they have a degree in STEM?
00:43:32 <Athas> Many physicists also gain a lot of experience with high-performance computing, which is useful in computational finance.
00:43:35 <merijn> Athas: Also, physics people usually know a decent amount of programming/math and are comfortable learning more :)
00:43:39 <Athas> Most CS students don't really have that experience.
00:44:00 <Athas> That too!  They probably know more calculus than the average CS student.
00:44:31 <Athas> And from my own computational finance experience, they are really heavy on differential equations and their numerical solution.
00:44:51 <todaystommorow> Can you get a compuational finance job without a degree?
00:45:39 <Athas> todaystommorow: potentially, but you'd need to demonstrate some serious skill and experience.
00:46:03 <todaystommorow> An epic portfolio with open source code they use?
00:46:12 <Athas> One of my friends never bothered getting his bachelor's degree, and he now works for a computational finance startup.  He makes more than the average CS grad here.
00:46:18 <todaystommorow> You could put comments in open source code saying, "Hire me I want a job"
00:46:33 <todaystommorow> Athas I'm thinking of doing something like that
00:46:41 <Athas> Sure, maybe, I'm a PhD student, I have no idea how this "getting a job" thing actually works.
00:46:51 <todaystommorow> I'm going to go into interviews for jobs
00:47:15 <merijn> Athas: Getting a job is when recruiters email you, no? ;)
00:47:17 <todaystommorow> Cool, you get good greades athas?
00:48:03 <tzaeru> it's not specific to finances, but most people I know who work in somewhat specialized fields are degreeless actually.
00:48:31 <tzaeru> doesn't really seem to matter that much nowadays.
00:48:50 <todaystommorow> Cryptocurrency without a degree?
00:49:17 <tzaeru> I don't know anyone working specifically on stuff related to finances unfortunately.
00:49:31 <tzaeru> but I'd presume it'd be similar; a good portfolio can replace a degree.
00:49:47 <Athas> merijn: yeah, I could just stop refusing!
00:50:05 <Athas> todaystommorow: not unusually so, except on projects.
00:50:16 <todaystommorow> Athas how have you avoided working?
00:50:24 <todaystommorow> I've been experimenting with living very cheap
00:50:33 <todaystommorow> and doing online learning
00:52:11 <Athas> todaystommorow: every student in Denmark gets a government stipent of around $900, and the monthly salary for a PhD student is around $3700.  I also worked as a TA before I was a PhD student, which pays around $4100 per course (approximately three months of half-time work).
00:53:20 <merijn> ffs, now I feel I'm getting ripped off :\
00:54:00 <tzaeru> mm, salary for PhD students is quite something
00:54:11 <Athas> I think it's a little different in Denmark.  PhD students are considered part of faculty, not just students.
00:54:12 <tzaeru> you're making more than I am with 5 years on the field :P
00:54:25 <merijn> tzaeru: It's generally the norm in Europe
00:54:25 <Athas> I also have (some) teaching and supervision obligations.
00:54:33 <merijn> Except the UK, that is
00:54:54 <srhb> merijn: Not an exception anymore :-P
00:54:55 <merijn> Every phd I know around Europe has salary and is considered part of the faculty
00:55:27 <merijn> Although they are running an experiment with bursary phds here, which reminds me I should probably complain to some union
00:56:23 <tzaeru> merijn, not here in Finland, PhD students are mostly responsible for finding income themselves, though there are various stipend systems and other such supports.
00:57:00 <tzaeru> most PhD students more or less work in the uni they study in.
00:57:42 <liste> tzaeru: scholarship systems?
00:58:40 <tzaeru> well the university might pay you for research or teaching assistance, or you might apply for various funds for support etc.
00:58:59 <tzaeru> and you might be eglible for the standard (but pretty low nowadays) student support.
01:00:00 <fr33domlover> same here in Israel. They aren't paid by default, but most of them have a job in the university, teaching and research etc.
01:00:12 <tzaeru> tbh student support systems have been going to crap in last ~15 years. default student support is 250€.
01:00:35 <Athas> So basically PhD students are treated reasonably everywhere but in the US?
01:00:43 <tzaeru> and cheapest rent for 1-room apartment is like 550€ in the capital region
01:01:04 <tzaeru> and lunch outside uni faculties is like 10€.
01:01:12 <fr33domlover> (but in Israel there's fees for being a student, which you pay to the university)
01:02:47 <tzaeru> I think here fees were just added for foreign students :V
01:02:58 <tzaeru> part of government pushes to cut education budgets I guess.
01:04:57 <merijn> Athas: You
01:05:03 <merijn> Athas: You're surprised? :p
01:05:42 <Athas> I wish I was.
01:06:36 <liste> Athas: time come to the other side of the pond (:
01:06:52 <merijn> liste: He's already on the right side of the pond :p
01:21:48 <cocreature> what do people use for lru caches? the lrucache contains a bug making it useless to me (and the issue has been open for months so I doubt it’ll get fixed anytime soon)
01:23:01 <cocreature> there is an LRU package but that is marked as deprecated
01:23:11 <cocreature> (and hasn’t been updated since 2007)
01:24:19 <quchen> Wasn’ there a post by the Better people about LRU caches a couple of years ago?
01:24:24 <quchen> I think they put it into a library
01:24:56 <quchen> https://jaspervdj.be/posts/2015-02-24-lru-cache.html cocreature 
01:25:08 <cocreature> quchen: that doesn’t seem to be packaged up sadly
01:25:32 <quchen> Arr.
01:26:42 <cocreature> @seen jaspervdj
01:26:42 <lambdabot> JA5PERVDJ
01:26:52 <cocreature> eh that’s not what I was expecting
01:27:01 <merijn> There is no @seen
01:27:23 <merijn> You're probably thinking of preflex, which is no longer in the land of the living
01:27:52 <merijn> I think @seen gets autocorrected to @leet
01:28:59 <srhb> Very useful. :-P
01:29:07 <cocreature> there is also no explicit opensource license at that post so I can’t just package it up myself
01:29:13 <cocreature> meh
01:29:32 <cocreature> I’ll drop him an email
01:32:06 <quchen> Where did Preflex go?
01:32:31 <quchen> Any whyyy does Lambdabot have this silly autocorrection feature
01:43:54 <merijn> quchen: Preflex was hosted on mauke's home machine (IIRC), which died like a year or so ago?
01:44:35 <quchen> mauke: Chop chop! ;-)
01:44:37 <merijn> quchen: If a non-existent command is provided to lambdabot it auto-corrects to the closest command with a Levenshtein distance of up to 2
01:44:52 <merijn> @tpye id
01:44:52 <lambdabot> Maybe you meant: type time
01:45:09 <merijn> @ytpe id
01:45:11 <lambdabot> a -> a
01:45:29 <quchen> ?until StateT s m a
01:45:29 <lambdabot> Maybe you meant: unpl unmtl
01:45:40 <quchen> Hm. That has distance 2.
01:45:48 <quchen> Maybe it’s also randomizing.
01:45:51 <merijn> quchen: Yeah, but not unambiguous
01:45:55 <quchen> Oh.
01:46:16 <quchen> ?unmeld StateT s m a
01:46:16 <lambdabot> s -> m (a, s)
01:46:17 <quchen> Hah.
01:46:23 <quchen> I wonder what the best correction pun is.
01:49:02 <orion> Functor? I barely even know her!
02:00:44 <Myrl-saki> ertesx: Yeah. I understand. I was just curious on how to do the game logic with FRP. Now that I'm less bored, it sounds way more insane.
02:06:24 <merijn> Myrl-saki: Have you read the FRAN paper? That describes, for example, how to do animation using FRP. Games are basically "just" animations parameterised over user input ;)
02:11:38 <angerman> I have a data structure like: data Named = (Name, Value), where data Value = Label Name | Leaf | Node Value. Now I want to resolve all Labels. I'm wondering if I should use fix to resolve this? 
02:12:30 <Rarrikins> What do you mean by resolve?
02:12:36 * hackagebot hspec-hashable 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/hspec-hashable-0.1.0.0 (mchaver)
02:12:58 <merijn> Replace "Label Name" by "Value", presumably?
02:13:01 <angerman> Ohh sorry. I Wantt o replace all Label Name items with their respective Node Value
02:13:41 <merijn> angerman: Recursively?
02:13:54 <angerman> Sorry, got carried away, trying to describe the problem coherently, and forgot to mention what I actually want.
02:14:06 <angerman> merijn yes.
02:14:19 <merijn> Looks you probably want some knot-tying sort of trick
02:14:36 <angerman> merijn If a Label points to some partially Value with Labels, I want those to be resolved as well.
02:14:50 <angerman> merijn ahh well, no not recursively in the data.
02:15:13 <angerman> The final graph will not have cycles.
02:15:52 <merijn> angerman: I would probably first write out the subsitution recursion manually and then try to simplify/generalise from there
02:16:39 <merijn> angerman: Tying the knot should work even if it's cycle free, then the result will just be a DAG
02:17:26 <angerman> merijn, that could work as well. I had "let's iteratively replace labels until none are left"... but replacing the labels in the replacement recursively might jsut do the trick.
02:17:36 <merijn> angerman: The simplest method is recursing until you hit a fixpoint. But repeatedly traversing the tree wastes cycles. The knot-tying approach could probably do it in linear time, but it's trickier to write and I don't have time to help with it :)
02:18:06 <angerman> merijn nah, no need. Just needed the pointers in the right direction. Thanks.
02:23:55 <jle`> i feel like _@pat shouldn't be an error
02:24:00 <jle`> for consistency
02:24:10 <jle`> *syntax error
02:26:14 <quchen> And it is an error?
02:26:30 <quchen> It doesn’t sound like a very useful pattern though.
02:27:30 <quchen> Well, _ is not a variable, so _@pat does not make any sense.
02:27:40 <quchen> _x is a variable, on the other hand.
02:27:55 <quchen> > let f _x@y = y in f ()
02:27:57 <lambdabot>  ()
02:28:25 <quchen> It would actually be *in*consistent to allow _@ because that would suggest the part before the @ is a pattern which can be wildcarded.
02:28:32 <merijn> It is consistent to reject _@pat, because that makes no sense syntactically
02:28:53 <merijn> (or denotationally, really...)
02:31:02 <telmich> good evening
02:32:18 <srhb> telmich: Hello.
02:32:25 <telmich> I'm trying to program the collatz conjecture, but trying so I get No instance for (Fractional Int) arising from a use of ‘aux’ 
02:32:28 <lpaste> telmich pasted “collatz” at http://lpaste.net/177327
02:32:44 <telmich> I wonder how to ensure that Int divided by 2 stays an Int?
02:32:46 <srhb> :t (/)
02:32:48 <lambdabot> Fractional a => a -> a -> a
02:32:52 <{AS}> telmich: use div
02:32:55 <{AS}> :t div
02:32:56 <lambdabot> Integral a => a -> a -> a
02:32:58 <telmich> Ahhhhh
02:33:09 <telmich> {AS}: many thanks!
02:33:10 <{AS}> works for floats/reals,etc.
02:33:24 <{AS}> (/) works for floats/reals
02:34:11 <{AS}> Is there a good description of what coarbitrary does?
02:34:27 <{AS}> Like one that gives a good intuition
02:36:17 <tsahyt> Hello! I'm implementing a decision procedure that gets called from another program periodically. So far the mode of operation required use of a stack to track past decisions. Now the requirements changed and I need it to run in different modes that can be selected at compile-time (although doing so at run-time with quasi zero overhead would be great). In particular some of those other modes require different
02:36:18 <tsahyt> state elements. What would be the best way to go about refactoring this with code reuse in mind? I thought about making different state types based on the mode but ideally I'd like to be able to compose different state elements based on what mode is selected.
02:37:12 <tsahyt> I suppose I can use one state type that is the closure under composition of all possible elements and use only what's necessary but that seems somewhat ugly
02:37:22 <{AS}> tsahyt: Have you considered using type classes?
02:37:30 <merijn> tsahyt: So you want a identical set of operations with different runtime behaviour?
02:38:03 <{AS}> Make a type class for your operations, and instances for each possible thing you can change at compile-time
02:38:35 <merijn> If the problem is what I think it is, typeclasses sound like a terrible solution
02:38:50 <{AS}> merijn: Perhaps, I misunderstood the issue?
02:39:04 <tsahyt> merijn: Only for some parts. The main loop consists of getting messages (via Chan), branching on what comes in, modifying state, sometimes returning something
02:39:21 <tsahyt> it's the way I return things that mainly changes, but some of the state operations become redundant in different modes
02:39:41 <tsahyt> for example, if I get told that my decision was wrong I'm currently unrolling the stack, but that'd be useless in a stackless mode
02:39:57 <merijn> tsahyt: Right, but you basically want to expose a single interface with multiple different implementations, right?
02:40:09 <tsahyt> basically, I guess you could say that
02:40:25 <merijn> tsahyt: Lemme copy+paste together a sample of something similar I used
02:40:30 <{AS}> Oh, that sounds like something for Backpack
02:40:31 <tsahyt> those implementations would share quite a bit of code between them
02:40:54 <merijn> tsahyt: It has a bunch GADT noise in there if you don't mind
02:41:05 <tsahyt> merijn: I should be able to read it I suppose
02:41:50 <tsahyt> I thought about parameterizing my monad stack on the type of state, but then I'd still like to compose a state type based on the requirements of the mode without having to carry everything around in a sort of "master state"
02:42:10 <lpaste> merijn pasted “No title” at http://lpaste.net/177330
02:42:20 <merijn> tsahyt: Something like this: http://lpaste.net/177330
02:42:52 <merijn> tsahyt: i.e., you provide a record of possible operations and use local state by capturing the state in, e.g. an IORef/TVar inside a closure of the functions used
02:42:59 <tsahyt> I think I've never seen record syntax used with GADTs before
02:43:53 <merijn> tsahyt: The GADT part is just explicitly specifying the return type using "-> Socket sock" after the record
02:44:31 <tsahyt> and restricting the parameter to the SocketType kind if I get that correctly
02:44:45 <merijn> tsahyt: Yeah, that's a bit overcomplicated voodoo I was playing with :)
02:45:10 <tsahyt> I'm never quite sure whether it's a good idea to restrict things like this
02:45:43 <merijn> tsahyt: You can ignore that part. The basic idea is to have a record containing functions that implement your functionality and deal with implementation specific state by capturing it in closures, i.e. the partial MVar application on line 31
02:45:51 <merijn> tsahyt: For your use case, probably not :)
02:46:23 <tsahyt> what's Sing?
02:46:43 <merijn> I'd just have "data Queue a = Queue { {- operations here -} }" "regularQueue :: IO (Queue a)" "stacklessQueue :: IO (Queue a)", etc.
02:46:56 <merijn> tsahyt: Sing is from Singletons to create values from type level parameters.
02:47:14 <merijn> tsahyt: It's basically "how do I ask a socket which type it is?"
02:47:35 <tsahyt> okay, so in my IO thing where I handle the message passing I'd then call the accessors in the record
02:47:36 * hackagebot microlens-th 0.4.1.0 - Automatic generation of record lenses for microlens  https://hackage.haskell.org/package/microlens-th-0.4.1.0 (Artyom)
02:48:17 <merijn> Presumably a queue would have like "{ push :: a -> IO (); pop :: IO a; unroll :: IO [a]}" and then make unroll like "return []" or something for stackless
02:48:39 <merijn> tsahyt: Which gives "push :: Queue -> a -> IO ()" since it's a record accessor :)
02:48:42 <merijn> Eh
02:48:57 <merijn> "push :: Queue a -> a -> IO ()"
02:49:45 <tsahyt> that'd all require a major rewriting effort I think
02:50:47 <merijn> tsahyt: You could use "internalPush :: IORef a -> a -> IO ()" and define "regularQueue = do ref <- newIORef; return $ Queue { push = internalPush ref }"
02:51:11 <merijn> tsahyt: Would it? You already have a queue type, no? You can simply name your replacement queue's operations the same?
02:52:30 <tsahyt> ah wait you're always just referring to the queue (stack actually, LIFO is important) itself, not the entire monad stack
02:52:37 * hackagebot microlens-platform 0.3.7.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.3.7.0 (Artyom)
02:53:26 <merijn> tsahyt: Right, assuming you just need to change the behaviour of the queue and not the rest of the program, the rest can remain unchanged, no? Unless your queue is tied into your monad stack, I suppose?
02:53:42 <tsahyt> not really, it's just a state element there
02:54:03 <{AS}> How can I quick check a function with two parameters?
02:54:09 <merijn> tsahyt: Right, if you simply replace your state element with a record type like my "Queue a" it should just work, no? :)
02:54:34 <tsahyt> i.e. it's a field in the DriverState constructor, I've got a MonadState DriverState Driver, and actually use it through a separate class to have more fine-grained control over what function can modify what bits of the state
02:55:06 <merijn> tsahyt: If you need a specific stack you can even make your operations "{ push :: a -> ReaderT r (StateT s IO) () }" or whatever
02:55:07 <tsahyt> merijn: yes it could work but I still end up with a queue (although one that does nothing) in the state
02:55:51 <merijn> Hmm, maybe then I'm not quite understanding the problem :)
02:56:36 <tsahyt> I'm not sure if it even is that much of a problem to begin with, worst case I carry around a queue that doesn't see any use
02:57:15 <tsahyt> it just doesn't strike me as the cleanest solution
02:59:12 <tsahyt> the solution with records would still require me to use a sort of master state that provides everything necessary for ANY mode to work
02:59:22 <tsahyt> even if I have the queue initialized to something that doesn't do anything
03:00:01 <tsahyt> Ideally I'd like to compose the state based on what's needed. That's mostly due to the fact that I'd like to compose modes in some ways
03:00:16 <tsahyt> for example I have a mode that alternates between making decisions in my code and using the solver itself for decision making
03:00:26 <tsahyt> I'd like to have a stackless version of that one too
03:00:54 <tsahyt> but alternating means another state element (i.e. how many decision do I have left until I defer decision making to the solver)
03:01:32 <tsahyt> so my DriverState would be something like AlternateCounter <> Stack <> Variables when using a stack, but AlternateCounter <> Variables when not using one
03:02:05 <tsahyt> I'd like to be able to use composition to build the actual state type somehow
03:02:37 <tsahyt> I could then use some type class wizardry to make sure that functions requiring say the AlternateCounter can only use state types that have it
03:03:57 <tsahyt> merijn: FWIW don't take this as criticism of the records idea. I use a similar pattern quite often when I run into problems with type classes, e.g. something akin to the existential antipattern. But I don't think it solves my problem here.
03:04:24 <tsahyt> iirc I actually learned about that from you on this channel a year or so ago
03:04:40 <merijn> Hard for me to say without better understanding of what you're doing :)
03:07:04 <tsahyt> well right now I have a monad stack handling my state and logging, as well as communication with the outside world (i.e. talking to the solver). I have a MonadState instance for a specific state type. Now I'd like to determine the state used based on what's needed by the chosen mode.
03:07:35 <tsahyt> i.e. instead of Driver () I'll end up with something like (HasStack m, HasFoo m, HasBar m) => m (), throughout most of my code
03:08:01 <tsahyt> but eventually I'll need some concrete type
03:08:10 <yaxu> Does anyone know of up-to-date resources for getting ghc (including ghci) running on the pi zero?
03:08:54 <tsahyt> at the same time the mode also determines the implementation of (parts) of the main loop
03:09:18 <tsahyt> man now I'm confused myself...
03:10:20 <{AS}> If I try to quickcheck something that takes a function as argument, I get missing Show for (Integer -> Bool)
03:10:24 <{AS}> is there anyway to fix this?
03:10:52 <tsahyt> I guess I can use the record idea for the implementation part of the mode though. I.e. data Mode = { makeDecision :: .., .. } and use this when branching on the messages from the Chan
03:11:34 <tsahyt> (missing a constructor there but you get the idea)
03:12:18 <tsahyt> {AS}: the hacky way would be to provide an instance that just shows something, like show x = "<function>" or so
03:12:26 <{AS}> tsahyt: Thanks!
03:12:34 <tsahyt> the problem is that you won't be able to display any counterexamples to your properties
03:13:24 <tsahyt> TIL there's an Arbitrary instance for (a -> b)
03:13:38 <tsahyt> assuming CoArbitrary a, Arbitrary b
03:14:46 <tsahyt> merijn: I think it comes down to whether it's possible to create a data type based on requirements, and I think it isn't (without TH anyhow)
03:15:01 <{AS}> tsahyt: I did one for Show (Bool -> a)
03:15:06 <{AS}> this was enough for my use case :)
03:15:14 <tsahyt> what I'd need would be something of type Requirements -> *
03:15:44 <tsahyt> with a monoid instance for Requirements
03:39:58 <Myrl-saki> merijn: I'll check  it outh, thanks!
03:45:48 <puregreen> how do you safely upgrade from one Stackage LTS version to another? I feel like there should be some command like “show me changelogs for all packages that I depend on and that have gotten their major versions bumped”, but I wonder what others do
03:47:14 <puregreen> or do you just keep tight upper bounds and then review the changelogs of packages that prevent you from moving to the next LTS version?
03:48:26 <MarcelineVQ> I just change my lts number, if it's bad I put in the old number, that's kind of what lts is for :>
03:49:21 <puregreen> but how do you find that it's bad? I'm not talking about “it doesn't compile”, I'm talking about “aeson subtly changed the behavior of a commonly used operator and my tests haven't caught it”
03:52:23 <fr33domlover> puregreen, perhaps then you're simply out of luck? :P
03:52:30 <srhb> puregreen: Complain loudly that it didn't break typechecking and that my tests were bad and bite the bullet and fix it
03:52:34 <fr33domlover> I too just upgrade the version and see if the app works
03:53:08 <MarcelineVQ> I imagine the big libs like that one have deprecation cycles that help you out with that so you'd just check the docs every significant version change, that's a good question though, you should ask in #haskell-stack and see if anything might match your requirements.
03:53:32 <merijn> puregreen: Release and wait for users to yell at you
03:53:36 <merijn> :p
03:53:43 * puregreen tsks
03:54:16 <MarcelineVQ> stack list-dependencies and stack query will give you some useful info but as far as comparing between lts you'd probably need to make a script currently
03:55:21 <puregreen> okay, thanks, I'll ask in #haskell-stack and keep tight bounds for now
03:56:59 <deyaa> anyone heard of JMeter?
03:57:07 <{AS}> If I test something which expects a Monoid with Quickcheck
03:57:15 <{AS}> why does Quickcheck only use Monoid () ? 
03:58:43 <deyaa> {AS} what is Monoid
03:58:45 <deyaa> ?
03:58:57 <{AS}> :t Monoid
03:58:58 <lambdabot> Not in scope: data constructor ‘Monoid’
03:59:00 <MarcelineVQ> puregreen: you could plunk in stack list-dependencies and then stack list-dependencies --resolver lts-somenumber and diff them
03:59:05 <{AS}> deyaa: A type class
03:59:16 <{AS}> which has two (three?) core operations
03:59:20 <{AS}> mempty and mappend
03:59:23 <MarcelineVQ> And if the versioning is significantly changed you'd know to look closer
03:59:48 <troydm> Cale: hey, are you here?
04:00:05 <deyaa> ppl i need help sending 1000 request per second
04:00:36 <{AS}> deyaa: why do you want that?
04:01:19 <quchen> {AS}: Quickcheck does not only use Monoid ().
04:01:31 <{AS}> quchen: It did for me
04:02:11 <deyaa> {AS} bruteforce some activation code
04:02:13 <{AS}> quchen: I am trying prop_Monoidic m = m === m `mappend` m
04:02:29 <deyaa> which has 6^10 possibility 
04:03:11 <{AS}> quchen and it says passed 100 tests
04:03:28 <quchen> {AS}: Who says that? GHCi? GHC? Hugs?
04:03:45 <{AS}> quchen: GHCi using verboseCheck prop_Monoidic
04:03:48 <quchen> GHC has extended default rules, so that might be the issue
04:04:08 <{AS}> quchen: Hmm, interesting
04:04:12 <quchen> Try giving your value a type signature.
04:04:23 <quchen> prop_Monoidic, that is.
04:04:33 <quchen> [Int], for example.
04:04:34 <deyaa> so .... 
04:04:43 <{AS}> quchen:  prop_Monoidic :: (Eq m, Show m, Monoid m) => m -> Property
04:05:30 <{AS}> deyaa: I don't know sorry
04:05:33 <quchen> You’ll need to specify “m”, or Quickcheck won’t know which ones it should randomly generate.
04:05:46 <{AS}> quchen: Ah, thanks :)
04:06:02 <phadej> fwiw m === m `mappend` m doesn't hold for generic monoid
04:06:03 <{AS}> I just hoped it would pick a variety of available Monoid's but that might have been too optimistic I guess
04:06:17 <{AS}> phadej: Exactly 
04:06:21 <quchen> GHCi has defaulting rules to avoid the ambiguous type error in these cases. The upside is that your program does something, the downside is that it can be something you did not intend.
04:06:25 <{AS}> But it picked Monoid () so it did hold for that
04:06:37 <{AS}> quchen: Ah, thanks
04:06:52 <quchen> Try compiling it with GHC, it should complain
04:07:10 <quchen> You can also set -XNoExtendedDefaults to disable this behaviour
04:07:27 <phadej> {AS}: and you can "trivially" see that behaviour by e.g. saying
04:07:29 <phadej> > mempty
04:07:31 <lambdabot>  ()
04:07:32 <quchen> -XNoExtendedDefaultRules
04:07:36 <quchen> That’s what I meant.
04:07:44 <phadej> vs. 
04:07:51 <phadej> > mempty :: Sum Int
04:07:53 <lambdabot>  Sum {getSum = 0}
04:08:12 <{AS}> phadej: quchen Ah thanks
04:08:18 <{AS}> quchen: Actually it doesnt complain
04:08:24 <{AS}> even with NoExtendedDefaultRules on
04:08:37 <quchen> Then I’m puzzled too.
04:09:15 <phadej> it does to me (with mempty example)
04:09:32 <lpaste> “{AS}” pasted “Testy.hs” at http://lpaste.net/177349
04:09:39 <{AS}> The above compiles fine with me
04:09:52 <{AS}> Oh, I should probably write quickCheck this :)
04:10:08 <phadej> {AS}: of course it does, there `m` is still universal
04:10:16 <{AS}> Yeah
04:10:26 <phadej> the NoExtendedDefaultRules has to be in your ghci session
04:10:31 <phadej> :set -XNoExtendedDefaultRules
04:10:35 <{AS}> Thanks
04:11:00 <{AS}> Yeah, now I get the ambigious error 
04:11:05 <phadej> good :)
04:11:15 <{AS}> Now, it totally makes sense
04:11:24 <{AS}> I could not understand why it picked something as random as Monoid () 
04:21:55 <verma314> Hi! I have been wanting to learn haskell since ages! Started today, reading "Real World Haskell".
04:22:16 <liste> verma314: great \o/'
04:22:24 <verma314> :)
04:29:15 <deyaa> emergency here
04:29:30 <deyaa> i'm dying 
04:30:01 <exDM69> call 112 or 911, don't irc
04:31:16 <deyaa> irc is faster man
04:32:28 <deyaa>  i should make 1k requests per sec 
04:40:40 <Morgawr> Is there a haskell function that takes a single parameter and returns a couple (tuple of 2) of itself?
04:40:46 <Morgawr> like f x -> (x, x)
04:41:07 <skrio> Just define \x -> (x, x) yourself?
04:41:44 <puregreen> there's “dup” in various utility libraries but nothing in base, I think
04:42:04 <merijn> :t join (,) -- for max obscurity!
04:42:05 <lambdabot> a -> (a, a)
04:42:19 <int-e> :t id &&& id -- only slightly less obscure
04:42:20 <lambdabot> c -> (c, c)
04:42:22 <Morgawr> skrio: lambda syntax looks ugly :( but thanks
04:43:21 <int-e> :t ap (,) id -- when did (,) become an infix operator?
04:43:22 <lambdabot> a -> (a, a)
04:43:46 <exDM69> :t join
04:43:48 <lambdabot> Monad m => m (m a) -> m a
04:43:59 <merijn> int-e: Always has been
04:44:11 <merijn> :t (,,) -- just like the other tuple constructors
04:44:12 <lambdabot> a -> b -> c -> (a, b, c)
04:44:30 <int-e> :t join (curry id) -- time to stop?
04:44:32 <lambdabot> a -> (a, a)
04:44:47 <merijn> And then there's "TupleSections" for added awesomeness
04:44:58 <puregreen> (,,1,,,,4,2,) etc
04:45:03 <Gurkenglas> :t \x -> (x, x) -- Unheard of obscurity levels?
04:45:04 <alercah> (,) is not an infix operator
04:45:05 <lambdabot> t -> (t, t)
04:45:09 <alercah> never was
04:45:24 <puregreen> (previously I thought tuple sections only could do (,a) and (a,), for some reason)
04:45:37 <alercah> (,) is just an application of TupleSections
04:45:42 <merijn> alercah: It is not
04:46:26 <toogley> hey. what is wrong with https://paste.fedoraproject.org/408742/12614231/ i can't make sense of the error message " parse error on input ‘primeList’", i don't see my fault..
04:46:43 <alercah> merijn: I thought tuple constructors weren't in the report?
04:46:59 <merijn> alercah: (,) and (,,) etc are all legal (at least in Haskell 2010) without TupleSections
04:47:38 <alercah> oh, so you're right
04:47:41 <merijn> alercah: Section 3.8 "The constructor for an n-tuple is denoted by (,…,), where there are n − 1 commas. Thus (a,b,c) and (,,) a b c denote the same value."
04:47:43 <alercah> huh
04:50:40 <merijn> Note that the report also doesn't limit the arity of tuples in anyway, although GHC does not support anything above 64, because "WTF are you even doing?!"
04:50:53 <skrio> toogley: I think you're missing a [ in your comprehension
04:51:23 <int-e> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
04:51:24 <lambdabot>     A 63-tuple is too large for GHC
04:51:24 <lambdabot>       (max size is 62)
04:51:24 <lambdabot>       Workaround: use nested tuples or define a data type
04:51:38 <merijn> oh, 62 even :)
04:52:21 <toogley> skrio: do you know where?
04:53:02 <toogley> skrio: (as i don't have closed, but not opened brackets)
04:53:09 <skrio> toogley: OH! sorry.
04:53:27 <skrio> toogley: your main function is indented. Remove indent there and it should fix it
04:56:25 <toogley> skrio: like so? https://paste.fedoraproject.org/408748/62100147/ that changes the error message, but doesn't solve it. 
04:57:41 * hackagebot bmp 1.2.6.2 - Read and write uncompressed BMP image files.  https://hackage.haskell.org/package/bmp-1.2.6.2 (BenLippmeier)
04:57:43 * hackagebot bmp 1.2.6.3 - Read and write uncompressed BMP image files.  https://hackage.haskell.org/package/bmp-1.2.6.3 (BenLippmeier)
04:57:45 <skrio> toogley: precisely, that fixes the first parse error
04:57:47 <toogley> skrio: ah, this is a different place in the code.
04:57:59 <toogley> skrio: sry, didn't looked carfully enough.
05:07:41 * hackagebot d-bus 0.1.4 - Permissively licensed D-Bus client library  https://hackage.haskell.org/package/d-bus-0.1.4 (PhilippBalzarek)
05:32:42 * hackagebot hsimport 0.8.2 - A command line program for extending the import list of a Haskell source file.  https://hackage.haskell.org/package/hsimport-0.8.2 (DanielTrstenjak)
05:34:04 <joe9> Is there a haskell package for non-blocking recv from a tcp tls socket?
05:34:34 <joe9> https://mail.haskell.org/pipermail/haskell-cafe/2010-August/082729.html there was not any in 2010 . not sure if the situation is different now.
05:37:32 <ertesx> Myrl-saki: 2048 can still benefit a lot from FRP, not only for the UI events, but also for the animation, the score, etc.  you can make everything an independent component
05:40:25 <merijn> joe9: Why non-blocking?
05:42:09 <exDM69> joe9: haskell has a green threading system that deals with non-blocking IO
05:42:42 * hackagebot asciidiagram 1.3.1.2 - Pretty rendering of Ascii diagram into svg or png.  https://hackage.haskell.org/package/asciidiagram-1.3.1.2 (VincentBerthoux)
05:43:36 <exDM69> joe9: ie. just launch a thread per socket and use the "blocking" send/recv... the I/O and thread manager will do epoll/kqueue/WaitForMultipleObjects behind the scenes
05:45:06 <quchen> merijn: What’s even better is the reason we only have 62-tuples.
05:45:26 <joe9> merijn: exDM69 : I have 1 connection (TCP TLS) to the server. I get a large amount of json data . The json object is CRLF delimited. Sometimes the line is more than 16384 bytes. So, my plan is to read the data into a bytestring variable and scan for the CRLF. If not found, then keep reading and appending to the variable.
05:45:32 <jonored> joe9: in a lot of ways, a forkIO thread is more like a sort of fancy handler for IO events than a process with shared address space. It's not particularly like a process at all.
05:45:38 <quchen> It’s literally because “Manuel says”.
05:45:42 <quchen> {- Manuel says: Including one more declaration gives a segmentation fault.
05:45:44 <quchen> http://hackage.haskell.org/package/ghc-prim-0.5.0.0/docs/src/GHC.Tuple.html
05:46:20 <MasseR> joe9: so why not read with the blocking interface and read into a variable?
05:46:23 <joe9> merijn: exDM69, if the bytestring variable already has multiple lines, then I want to start using them instead of waiting for the recv call to complete.
05:46:23 <quchen> I like how they kept scaling for future use in mind and included the even larger tuples as comments.
05:46:45 <Axman6> Manuel's a smart man
05:46:54 <MasseR> joe9: check the content before calling another recv?
05:47:20 <joe9> MasseR:I understand that, but, I would be scanning each byte of the content before recv.
05:47:22 <merijn> joe9: 'recv' already returns with any amount of data
05:48:12 <Myrl-saki> ertesx: I see. I'll give it a try. ^_^
05:49:54 <joe9> merijn: Network.Socket.ByteString . recv, will check that. Thanks.
05:50:06 <jonored> joe9: parallel-io is probably convenient in this case, as well.
05:50:21 <joe9> jonored: and use TChan to communicate between the forkIO and the main process? Thanks.
05:50:37 <joe9> jonored: Thanks, will check out parallel-io.
05:52:24 <meditans> hi all, when trying to preprocess the code of the "text" library to remove cpp, I get the following error: 
05:52:33 <meditans> uncaught exception: GhcParseError (42:3  error: #error "You need to use either GMP or integer-simple." # error "You need to use either GMP or integer-simple."
05:52:40 <exDM69> joe9: I didn't quite understand why you require non-blocking io for that
05:52:41 <jonored> joe9: or just hit the parallel function from parallel-io, which runs a bunch of IO actions and returns a list of the results.
05:52:55 <meditans> do you know how I should pass GMP or integer-simple to the build process?
05:54:24 <jonored> (what you seem to be trying to do isn't hard, it's just less manual work to do than in C :)
05:54:51 <joe9> jonored: ok, Thansk.
05:54:53 <joe9> Thanks.
05:55:30 <joe9> exDM69: the recv system call is non-blocking. It is the haskell interface to it that makes it blocking. That is what I get from the mailing list.
05:57:06 <exDM69> joe9: yeah, but I fail to see how that affects your use case
05:57:38 <exDM69> joe9: bytes <- recv ; if clrfFound bytes then process bytes else repeatFromRecv
05:57:43 * hackagebot protolude 0.1.7 - A sensible set of defaults for writing custom Preludes.  https://hackage.haskell.org/package/protolude-0.1.7 (sdiehl)
05:58:31 <exDM69> joe9: but yeah, haskell doesn't have your typical callback based async i/o calls
05:58:44 <exDM69> it relies on forkIO and magic behind the scenes
05:59:26 <joe9> exDM69: the (if crlfFound bytes) call would be scanning each byte of bytes each time.
05:59:57 <peteretep> http://lpaste.net/177368 -- I don't understand why I'm getting an unexpected type back
06:00:01 <peteretep> Any help appreciated
06:00:07 <joe9> exDM69: it would be nice if I can do, if (not null bytes) then nonblockingRevc ; else blockingRecv ;
06:00:31 <exDM69> joe9: how should nonblockingRecv work?
06:00:52 <joe9> exDM69: That is the problem that I need help with. Is that possible?
06:00:52 <exDM69> joe9: your use case doesn't need non-blocking I/O unless your data volumes are huge, but then you want threaded i/o anyway
06:01:19 <joe9> exDM69: What do you recommend for threaded i/o?
06:01:23 <peteretep> Does something like this even make sense? : data TestAssertion f e = TestAssertion TestName (e -> (Result f e))
06:01:45 <exDM69> joe9: for your use case... I'd just do a single threaded loop
06:03:31 <exDM69> recv until you find one or more newlines, then process all full lines and continue recv'ing (and appending to the buffer) until another newline is found
06:05:03 <peteretep> Any pointers appreciated
06:06:43 <{AS}> Is there a general form of partition?
06:07:05 <{AS}> Like partition :: Foldable t => (a -> Bool) -> t a -> (t a, t a) ?
06:09:23 <puregreen> it's impossible to write because Foldable doesn't let you remove elements
06:09:30 <puregreen> you need Witherable or something like that
06:09:43 <puregreen> @hackage witherable
06:09:43 <lambdabot> http://hackage.haskell.org/package/witherable
06:10:45 <{AS}> puregreen: Thanks!
06:12:11 <puregreen> and even then you'd have to do filtering twice, apparently, because witherable doesn't provide partition
06:12:32 <{AS}> Ha, interesting :)
06:15:30 <{AS}> puregreen: I guess one could define a witherable that works with Either a a instead 
06:16:40 <{AS}> Applicative f => (a -> f (Either b c)) -> t a -> f (t b, t c)
06:17:46 <Hi-Angel> What do I do wrong: I initialized sandbox, set "library-profiling" and "executable-profiling" to True in "cabal.sandbox.config", successfully finished "cabal install regex-tdfa"; still the command "ghc my-code.hs -prof" complains "Failed to load `Text.Regex.TDFA"
06:18:44 <Hi-Angel> I even did "cp cabal.sandbox.config cabal.config", just for the safe case.
06:20:28 <skrio> Hi-Angel: when you are running the command, are you running it through cabal?
06:21:05 <Hi-Angel> skrio, sorry, I'm not sure I unerstood, but I run it in the sandbox directory
06:21:32 <Hi-Angel> s/unerstood/understood
06:21:33 <skrio> as in `cabal (run/ghc/??) my-code.hs -prof` ?
06:21:49 <Hi-Angel> Hmm, nope, I didn't know such way
06:22:43 <Hi-Angel> it says "cabal: unrecognised command: ghc" "run" and "exec" options seems do not exist either
06:23:13 <skrio> So long since i used cabal, sec
06:24:29 <Hi-Angel> skrio, oh, cool, I googled it up, it is "cabal exec -- ghc"^^
06:24:33 <joe9> exDM69: Thanks.
06:24:35 <Hi-Angel> Thank you
06:24:43 <Hi-Angel> That works
06:25:41 <skrio> Hi-Angel: Good :)
06:30:00 <waweros> Hello, so when installing ghc from a Tarball, I get the error 'bad interface file dist-install/build/ghc/cstring.hi, magic number mismatch: old/corrupt interface file? (wanted 33214052, got 
06:30:00 <waweros> 129742)'
06:32:44 * hackagebot keycode 0.2.1 - Maps web browser keycodes to their corresponding keyboard keys  https://hackage.haskell.org/package/keycode-0.2.1 (ryanglscott)
06:32:46 * hackagebot midi-utils 0.1.0.0 - Utilities for working with MIDI data  https://hackage.haskell.org/package/midi-utils-0.1.0.0 (GuiltyDolphin)
06:49:50 <carlosayam> hi, quick question: I'm trying to install keter
06:50:11 <carlosayam> ... but the shell script fails downloading stuff from fpcomplete, any ideas?
06:55:31 <Geff22> Hello. In my code I use Zlib and now I want to handle exceptions that may occur during decoding. Is it possible to get something like "decode :: ByteString -> Maybe ByteString"? Or should I use the IO?
06:58:43 <Hi-Angel> carlosayam perhaps link is broken
07:02:56 <danielsmw> Geff22 that's too bad the library doesn't provide that functionality. If you look at the ZLib.Internal library, it looks like decompress throws exceptions using Control.Exception, so you may need to catch the errors that way.
07:03:38 <danielsmw> You should be able to find plenty of Control.Exception error catching examples on stackexchange, e.g.
07:10:57 <Geff22> Thanks a lot! Really a pity that such a popular library does not provide a way to avoid exceptions.
07:13:28 <{AS}> How does DeriveAnyClass work?
07:15:06 <glguy> did you read the section about it in the ghc user's guide?
07:16:17 <{AS}> glguy: Ah, found it there thanks!
07:16:56 <{AS}> so it will basically only work (nicely) for classes where you have defaults
07:18:15 <phadej> it /only/ works for classes where you have defaults
07:18:51 <phadej> i.e. saves you from `instance SomeClass MyType` boilerplate
07:19:05 <{AS}> Ah
07:19:07 <{AS}> Interesting
07:20:15 <lingxiao> hey all
07:20:29 <lingxiao> hey all
07:20:59 <lingxiao> there doesnt appear to be a string -> Data.Text.Internal.Lazy function does there
07:21:04 <lingxiao> if that function even makes sense
07:21:13 <phadej> lingxiao: there is
07:21:24 <lingxiao> phadej i cant find it here?
07:21:26 <lingxiao> https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Internal-Lazy.html
07:21:35 <phadej> Data.Text.Lazy.pack
07:21:36 <{AS}> lingxiao: Is it not pack?
07:21:46 <lingxiao> i dont see pack ?
07:21:48 <{AS}> https://www.haskell.org/hoogle/?hoogle=String+-%3E+Text <-
07:21:59 <lingxiao> oh i see it
07:22:00 <lingxiao> thanks
07:22:03 <joe9> lingxiao:  check out data.string.conversions cs
07:22:45 * hackagebot socket 0.6.2.0 - An extensible socket library.  https://hackage.haskell.org/package/socket-0.6.2.0 (LarsPetersen)
07:42:46 * hackagebot digestive-functors 0.8.1.0 - A practical formlet library  https://hackage.haskell.org/package/digestive-functors-0.8.1.0 (JasperVanDerJeugt)
07:44:02 <Gurkenglas> The "This problem can usually be solved by installing the system package that provides this library (you may need the "-dev" version). If the library is already installed but in a non-standard location then you can use the flags --extra-include-dirs= and --extra-lib-dirs= to specify where it is." error should provide information how to do that install stuff on Windows.
07:44:49 <Gurkenglas> Maybe a link to a page that lists for each missing C library what to do.
07:47:20 <nitrix> Gurkenglas: Which library is that?
07:47:46 * hackagebot digestive-functors-snap 0.7.0.0 - Snap backend for the digestive-functors library  https://hackage.haskell.org/package/digestive-functors-snap-0.7.0.0 (JasperVanDerJeugt)
07:47:56 <Gurkenglas> hackage package openvr-hs, C library openvr_api
07:49:01 <nitrix> Seems like there's no mingw precompiled libraries for it yet.
07:49:18 <svenpanne> @free fmap :: (a -> b) -> (F a -> F b)
07:49:18 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
07:49:19 <nitrix> If I take SDL as an example, you'd simply do: stack exec -- pacman -S mingw-w64-x86_64-pkg-config mingw-w64-x86_64-SDL2
07:49:40 <nitrix> Or copy manually the include and lib files in your GHC mingw folder.
07:50:00 <svenpanne> @free foo :: Maybe a -> Maybe a
07:50:00 <lambdabot> $map_Maybe f . foo = foo . $map_Maybe f
07:50:44 <Gurkenglas> The what and what files into where? :D
07:50:49 <svenpanne> @free foo :: f (a -> b) -> f a -> f b
07:50:49 <lambdabot> Extra stuff at end of line
07:50:50 <nitrix> Gurkenglas: So presumably, you'd have to compile that library with mingw and put the library in your GHC mingw folder too. Windows not having global package management for C libs is a little painful, but doable.
07:50:56 <svenpanne> @free foo :: f (a -> b) -> f a -> f b
07:50:56 <lambdabot> Extra stuff at end of line
07:51:10 <svenpanne> @free foo :: F (a -> b) -> F a -> F b
07:51:10 <lambdabot> (forall h. (forall k p. g . k = p . f                        =>                         h k = p)           =>            $map_F h x = y) => $map_F g . foo x = foo y . $map_F f
07:51:13 <Gurkenglas> If its just a stack exec -- command why doesnt stack do it when encountering that error?
07:52:45 <nitrix> Gurkenglas: Stack isn't a package manager of C libraries.
07:53:09 <nitrix> Those are linked with GHC's FFI and assumed to be installed on the system beforehand.
07:53:27 <nitrix> Gurkenglas: C:\HaskellPlatform\8.0.1\mingw\{include,lib,bin}
07:54:17 <Gurkenglas> But stack would be a better "the haskell tool stack" if I didnt need to worry about all that stuff right? Why not have it be a package manager too? (or at least recommend some :P)
07:54:37 <Gurkenglas> *"(or at least have it recommend some)"
07:54:50 <nitrix> Gurkenglas: You're confused; it's not a Haskell problem, and neither a stack problem, it's the C ecosystem.
07:55:09 <nitrix> There's no community agreed common repository for C libraries.
07:55:20 <jgzh6> Hello, I have a question http://lpaste.net/177400
07:55:54 <maerwald> Gurkenglas: because it isn't a package manager
07:55:56 <jgzh6> How can I read a list from a file and read them not as String?
07:56:01 <nitrix> Gurkenglas: mingw is attempting to port the common libraries to windows but it's limited.
07:56:09 <maerwald> use a real package manager if you want a real package manager
07:56:52 <Gurkenglas> maerwald, we could take a real package manager and include it in stack so people like me dont need to know what a package manager is
07:56:59 <jonored> Isn't that what the nix stuff in stack does? :)
07:57:59 <nitrix> Gurkenglas: The general story is, on linux you have the package maintainers on each distro list the dependencies of your application; on windows, you ship the binar and the dlls with an installer.
07:58:03 <maerwald> Gurkenglas: I think that's the wrong way.
07:58:40 <jonored> a package manager, with associated set of packages, is basically most of a linux distro.
07:58:53 <cocreature> how exactly am I supposed to specify a password containing special chars in ~/.cabal/config?
07:59:11 <jonored> (most of that is because of the "associated set of packages" part, but still.)
08:02:47 * hackagebot snap-blaze 0.2.1.4 - blaze-html integration for Snap  https://hackage.haskell.org/package/snap-blaze-0.2.1.4 (JasperVanDerJeugt)
08:02:48 * hackagebot lrucaching 0.1.0 - LRU cache  https://hackage.haskell.org/package/lrucaching-0.1.0 (cocreature)
08:02:55 <nitrix> Gurkenglas: Thus, why C development on windows has always been painful. To simplify things, people rely on local project dependencies, git submodules, cmake and all that stuff.
08:03:25 <nitrix> Gurkenglas: A lot of that cruft could be removed in a linux environment with the package managers we have :)
08:03:51 <maerwald> oh, he's a windows user, that explains the confusion
08:03:57 <Gurkenglas> But people dont have to rely on local stuff if stack decides how to do it for all windows users
08:04:41 <Gurkenglas> Or would you need to do it differently for different windows versions?
08:05:16 <Gurkenglas> jgzh6, line 9 has a ")" too many, "(filter (/= '\"') i)" is a list and you're trying to apply it to 100.
08:06:32 <Gurkenglas> if i contains only " and digits, gbp (read (filter (/= '\"') i)) should read the number contained in i as gbp, etc.
08:07:41 <jgzh6> But my problem is I should read "usd" :: String as usd
08:07:48 <jgzh6> which is a function
08:08:40 <ongy> how up to date is https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts and pages linked by it?
08:09:54 <sm> jgzh6: the normal way is pattern match on each valid string and call the corresponding function
08:10:21 <sm> there's no "eval" function, usually
08:10:21 <Gurkenglas> Shame that there's no "KnownSymbol s => Read (Currency s)" instance, maybe complain to the package maintainer. Unless you want to bring in mueval for actually executing code given in a String, I'd just define a function like 'case currencytype of "usd" -> usd; "gbp" -> gbp; 
08:11:16 <jgzh6> hm.. complicated.
08:11:42 <sm> not really
08:11:52 <Gurkenglas> Pretend he said boilerplatey then :P
08:12:31 <sm> currency-convert.. neat
08:14:33 <jgzh6> Thank you for the advice
08:15:21 <MiniCow> Does anybody know how I can make this (http://lpaste.net/177401) Hspec/QuickCheck test report which values it’s testing? I’ve been trying using `verbose` in various places, but it’s not seeming to have an effect. It’s testing a parser for C like identifiers, and seems to work, but I’d like to visually check it, make sure the generator is correct.
08:16:35 <sm> jgzh6, Gurkenglas: you could contribute that function (look up currency constructor from a string) to the library, then there'd be no boilerplate
08:17:21 <jgzh6> I'm a total noob :p
08:17:35 <Gurkenglas> How do you contribute to a package if its not on github?
08:17:56 <sm> https://github.com/tuomas56/currency-convert
08:18:01 <phadej> Gurkenglas: is it somewhere?
08:18:08 <Gurkenglas> Oh wait it is.
08:18:15 <sm> phew!
08:18:47 <Gurkenglas> Ewww his Show instance does not generate Haskell code
08:20:19 <tdammers> fwiw, RWH used to actually recommend using Show for pretty-printing, not sure if that bit is still in there
08:21:43 <Gurkenglas> Hmm should I put the Read instance in with a Show-generates-Haskell rider on the bill or just make the read also take the currency type from where the Show puts it
08:24:17 <jgzh6> I have another noob question http://lpaste.net/177411
08:25:23 <phadej> >>= has String -> (String -> IO [String]) -> IO [String] type there
08:25:33 <phadej> :t return . lines
08:25:35 <lambdabot> Monad m => String -> m [String]
08:25:43 <phadej> :t return . lines :: String -> IO [String]
08:25:45 <lambdabot> String -> IO [String]
08:25:53 <Gurkenglas> Wait, the "KnownSymbol s => Read (Currency s)" wouldn't work - you'd need to specify the currency you're reading before reading it. His type setup "data Currency (s :: Symbol) = Currency Double" made the Symbol not need to be a part of the runtime representation, but traded in the ability to read :( 
08:27:41 <jgzh6> hm.. strange. But repl said the result is [String] instead of IO [String]
08:27:47 <Gurkenglas> The best you could do is immediately converting the read String to a currency of the caller's choice
08:28:00 <raek> jgzh6: note that the ghci repl executes IO actions
08:28:12 <raek> and displays what they produce
08:28:28 <Gurkenglas> I'll just add it as an issue, this sounds like something the maintainer should decide
08:28:50 <jgzh6> Ah, that's why.. 
08:28:53 <jgzh6> Thanks !
08:29:31 <qleap> Hi there, does somebody tries to run Haskell on Windows XP? I am stuck with error " unknown symbol `__localtime32' "
08:29:49 <raek> jgzh6: also note that "list >>= return.lines" means "(list >>= return).lines"
08:30:11 <jgzh6> hm..
08:30:16 <jgzh6> Right..
08:30:26 <Welkin> Left
08:30:34 <jgzh6> :)
08:30:35 <qleap> As far as I understand ghc does not load MSVCR100.dll
08:30:50 <jgzh6> Thanks
08:32:02 <raek> jgzh6: if you want to play around with the values that IO actions produce in GHCi, you can use this syntax: "listContents <- readFile "list.txt"
08:32:09 <qleap> So everything I get: ghc.exe: unable to load package `time-1.5.0.1'
08:32:15 <raek> listContents then has type String, not IO String
08:32:34 <otau> hi, is there something I can pass to ghc from stack that would be equivalent to "cabal install --disable-shared"?
08:32:42 <raek> the GHCi repl is like a do-block syntax-wise
08:33:54 <Cale> Yeah, you should read "v <- x" as meaning "execute the action x, and name its result v"
08:34:09 <Welkin> "v from x"
08:34:10 <Welkin> :D
08:34:33 <jgzh6> Thanks
08:34:37 <tdammers> "v is smaller than negative x" :x
08:34:39 <tdammers> ignore that
08:34:40 <Gurkenglas> :t ?a >>= ?b . ?c -- raek, no it doesnt
08:34:41 <lambdabot> (Monad m, ?a::m a, ?b::b1 -> m b, ?c::a -> b1) => m b
08:34:58 <Gurkenglas> :t (?a >>= ?b) . ?c
08:34:59 <Cale> (Whereas "let v = x" would define v and x to be the same action, without causing anything to occur)
08:35:00 <lambdabot> (?a::b -> a1, ?b::a1 -> b -> c, ?c::a -> b) => a -> c
08:36:20 <Gurkenglas> ("the GHCi repl is like a do-block syntax-wise" <- your friendly reminder that letless = in do blocks should be desugared to let lines)
08:37:40 <jgzh6> so many things to learn :p
08:42:48 * hackagebot OpenGLRaw 3.2.2.0 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGLRaw-3.2.2.0 (SvenPanne)
08:45:35 <hwanzike> greetings, i need some help understading composition. see the definition of isVowel here: https://tartarus.org/martin/PorterStemmer/haskell.txt. how come you can't just do isVowel = not . isConsonant ? While isVowel a b = not $ isConsonant a b does work
08:46:49 <jonored> hwanzike: check the types on .
08:46:51 <hwanzike> also, i don't understand how its composing by using a partially applied composition on not
08:47:39 <jonored> basically, . isn't quite right for composing a two argument thing with a one argument thing.
08:48:41 <Welkin> :t (.) . (.)
08:48:42 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
08:48:48 <Welkin> you can use that though :D
08:48:52 <Welkin> but it is hard to read
08:48:59 <Welkin> :t (:.)
08:49:00 <lambdabot>     Not in scope: data constructor ‘:.’
08:49:00 <lambdabot>     Perhaps you meant one of these:
08:49:00 <lambdabot>       ‘NE.:|’ (imported from Data.List.NonEmpty),
08:49:09 <Welkin> :t (.:)
08:49:11 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
08:50:58 <hwanzike> that's not very intuitive :/
08:51:13 <hwanzike> specifically:  isVowel = (not .) . isConsonant
08:51:19 <conal> and more generally, fmap.fmap, which fits the broader pattern of semantic editor combinators
08:51:39 <toogley> why does "myLast :: [a..b] ->  b" give me the error message "parse error on input ‘..’  " ? i don't really understand why its different than :t head or :t tail or sth similar. 
08:52:16 <conal> i like defining "result = (.)", and then saying "result . result", which is analogous to things like "first.first", "second.second", "liftA2.liftA2", etc.
08:52:25 <conal> and they mix & match: "fmap . first . fmap . result".
08:52:27 <conal> see http://conal.net/blog/posts/semantic-editor-combinators
08:52:34 <bjs> toogley: what does the type [a..b] represent? lists are homogenous
08:53:19 <conal> hwanzike: you may find that blog post helpful
08:54:56 <hwanzike> thanks
08:59:23 <shock_one> Using a free monad, you can take a coproduct of two algebras, and execute them together. But can you take a product of two interpreters and execute both of them at the same time?
09:00:08 <shock_one> Like one would perform actions, and another would log function calls.
09:01:22 <toogley> bjs: ah, right. i didn't realize that.. well i wanted to describe a list very generally with that, thought about a and b in this case as particular integers and not types. 
09:01:40 <bjs> toogley: the type of a list is [a] (i.e. a list of things of type a)
09:01:56 <bjs> toogley: so head :: [a] -> a, is the type
09:02:48 * hackagebot hs-watchman 0.0.0.2 - Client library for Facebook's Watchman tool  https://hackage.haskell.org/package/hs-watchman-0.0.0.2 (BitConnor)
09:03:42 <toogley> bjs thx
09:07:49 * hackagebot lrucaching 0.2.0 - LRU cache  https://hackage.haskell.org/package/lrucaching-0.2.0 (cocreature)
09:08:06 <geekosaur> toogley, there are languages where you can describe lists with that kind of type level detail (coq, agda, idris, ...) but, you need to specify even more details and provide proofs that your lists conform to those descriptions
09:08:38 <ertesx> shock_one: what's the type of an interpreter?
09:12:49 <shock_one> In one tutorial it's `interpret :: (Show b) => Free (Toy b) r -> IO ()`, where Toy defines the algebra. But I guess the return type can be anything.
09:12:54 <shock_one> ertesx: 
09:17:07 <ertesx> shock_one: the idea is that you create an interpreter type that happens to be a monoid/monad
09:20:03 <shock_one> Here's the link. http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html. So, I thought if you can execute a function for each element of a structure, how hard can it be to execute a pair of functions? But it seems that the interpreter has recursive calls to itself, and I'm not sure how to make two interpreters simultaneously, not one after another. What are the consequences of it being monoid/monad, I didn't get it?
09:21:24 <phadej> shock_one: http://hackage.haskell.org/package/transformers-0.5.1.0/docs/Data-Functor-Product.html#t:Product ?
09:26:24 <shock_one> OK, I can take a product, phadej. As far as I understood from https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/ you're guaranteed to have a product in Set. But can I make an interpreter for a product that would run both sides simulteniously? For example, having a program like `buy; sell` and two interpreters `upcase`, and `downcase`, which print the words in a corresponding case, I want to see `BUY buy SEL
09:26:25 <shock_one> L sell`, not `BUY SELL buy sell`.
09:29:46 <toogley> geekosaur: well i missdescribed what i actually wanted to do a bit. i thought that the syntax "myLast :: [a..b] -> b" was the actual implementation and not the typesystem.^^ but anyways thanks for those information :)
09:32:40 <phadej> shock_one: then what you want is more of newtype IOPair a = IOPair (a,a) which can be made into a monad as well
09:32:54 <Cale> er...
09:32:55 <phadej> = IOPair (IO (a,a))
09:33:02 <Cale> I'm not sure it makes sense
09:33:20 <Cale> The different interpreters might disagree on the results of individual computations
09:33:28 <phadej> thus pair
09:33:51 <phadej> but same monad (otherwise interleaving doesn't make sense)
09:33:53 <Cale> I'm not sure I understand what the plan is there
09:34:54 <Cale> Let's imagine we're doing terminal IO for a moment...
09:35:26 <Cale> So our free monad is basically  data TermIO a = Return a | GetChar (Char -> TermIO a) | PutChar Char (TermIO a)
09:36:01 <Cale> (which it might immediately be helpful to factor into a functor with Free applied to it)
09:36:30 <Cale> But, even before doing so, if we have two interpreters for this, they might disagree on which Char is the result of the GetChar
09:36:41 <Cale> and so they might disagree on what the continuation is
09:37:13 <Cale> Maybe there's a way in which that's okay somehow, but I'm not sure I see it :)
09:37:49 * hackagebot gitHUD 1.3.4 - More efficient replacement to the great git-radar  https://hackage.haskell.org/package/gitHUD-1.3.4 (gbataille)
09:38:28 <shock_one> Cale: what about free applicative?
09:39:14 <Cale> Well, that sounds a little more plausible
09:39:51 <joe9> What is the recommended haskell library to connect to a TLS socket? found this: https://hackage.haskell.org/package/network-simple-tls-0.2.1 , but, am wondering if there is a more popular one out there.
09:40:38 <yaxu> Hi all, I'm desperately trying to get ghc working on a raspberry pi zero, with ghci
09:41:22 <luite_> i hope you have a lot of patience :)
09:41:56 <yaxu> Does anyone have some tips for this? many months ago I managed to get it working using qemu, but managed to lose the SD card..
09:43:07 <yaxu> Now I am struggling to get qemu working at all.. Online blogposts etc seem to have bitrotted. Have been bashing at this all day but getting nowhere..
09:44:30 <yaxu> What I wouldn't give for raspbian .deb packages right now! But can't find anything for armv6
09:44:50 <Cale> joe9: There's also a library called simply "tls"
09:47:19 <owoce> hi everyone! I'm wondering, how can I achieve something like this: `data Consonant = 'a' | 'e' | 'i' | 'o'| 'u' | 'y' ` 
09:47:46 <Cale> owoce: Surely you mean Vowel
09:47:51 <owoce> basically, i want to constrain the characters that can go into this datatype which is actually a char
09:47:54 <Cale> and you would have to define new data constructors
09:48:03 <owoce> dam youre right. i always mess those two up!
09:48:05 <Cale> You don't get to reuse Char values
09:48:37 <buglebudabey> owoce what is your goal with that data type
09:49:58 <owoce> buglebudabey: it's complicated :/ but basically i wanted to define a new sum type using existing values, characters
09:50:05 <owoce> like that example
09:50:17 <ertesx> shock_one: one thing you can do is to pair up interpreters with "extra actions"…  that will work for things like logging
09:50:20 <Cale> In Haskell, we can't quantify over values at the type level, so it's tricky to express types like that.
09:50:39 <buglebudabey> I would just define it as "data Consonant = A | E | ... and later down the road convert it to Char
09:50:40 <ertesx> shock_one: otherwise you will need to have the interpreters in a chain with the final link deciding on the result
09:51:11 <Cale> owoce: One thing you *can* do is to make a newtype wrapper for Char
09:51:11 <Cale> newtype Vowel = Vowel Char
09:51:12 <buglebudabey> owoce with a toChar fromChar instance maybe
09:51:13 <gypsyking22> grep >
09:51:28 <buglebudabey> Cale forgot we were talking about vowels lol
09:51:42 <Cale> and then only export from the module in which it's defined ways in which to obtain vowels
09:51:53 <Cale> i.e. don't export the data constructor for Vowel
09:52:15 <Cale> but instead export values a, e, i, o, u :: Vowel perhaps
09:52:34 <Cale> Not sure that's worth doing though
09:54:12 <owoce> Cale: yeah, sounds like too much work
09:54:45 <owoce> I think i'll do what buglebudabey said, "data Consonant = A | E | ... and later down the road convert it to Char"
09:55:00 <owoce> jesus are those consonants or vwels im confused now
09:55:03 <buglebudabey> owoce I wouldn't discount Cale's advice either :P
09:55:20 <Cale> In something like Coq, Agda, or Idris, you could write something like  exists x:Char, isVowel x = True, which would be the type of pairs (x,p) where x was a Char, and p was a proof that isVowel x and True are equal.
09:55:28 <joe9> Cale, Thanks.
09:55:45 <Cale> But in Haskell, that's not really practical to express.
09:55:59 <hellyeah-DMC> audio said you dudes are cool
09:56:06 <hellyeah-DMC> what are you saying about this?
09:56:23 <Cale> (You can do things with singleton types, but it's awkward and usually not worth the trouble)
09:56:27 <audio> usually some interesting convos in here
09:56:33 <audio> and i know nothing about #haskell
09:56:35 <Welkin> who is audio
09:56:43 <audio> except that its a functional programming language
09:56:47 <audio> function programmers are cool
09:57:01 <Cale> hellyeah-DMC, audio: If you have any questions about Haskell, feel free to ask :)
09:57:22 <audio> hellyeah-DMC: you might check out #R-finance too
09:57:28 <ongy> is this a good place to ask questions about RTS code, if not, which mailing list is the best? ghc-devel?
09:57:40 <Cale> ongy: There's also #ghc
09:57:49 <hellyeah-DMC> not yet
09:58:44 <arkeet> Cale: instead of smart constructors we can now do pattern synonyms :>
09:59:09 <owoce> sorry i gotta go. thanks for all the help though!
09:59:23 <phadej> Coldblackice: https://gist.github.com/phadej/a8aa2d235cd31e38f00cb71cd461b7c6
09:59:28 <phadej> Cale: sorry ^
10:01:30 <phadej> that's something, where if you get types to match, it's most likely right :)
10:08:10 <orion>  Cale> In something like Coq, Agda, or Idris, you could write something like ... are those called dependent types?
10:13:23 <geekosaur> orion, yes; the type depends on a value
10:17:42 <sm> blahblah!
10:17:53 <maerwald> sm: it works
10:18:00 <sm> ha sorry, wrong window! :)
10:27:24 <nitrix> Is there a   maybeIOToIO = fromMaybe (return ())  ?
10:27:41 <Profpatsch> Do I need additional type annotations if I use ExistentialQuantification?
10:28:07 <nitrix> Profpatsch: Additional other than what's existiantially quantified?
10:28:26 <Profpatsch> nitrix: Oh, wait. I think I noticed the error of my ways.
10:28:34 <nitrix> Profpatsch: data Foo = forall a. F a
10:30:33 <begriffs> I'm using the monad-parallel package and have compiled with `-rtsopts -with-rtsopts=-N`, but do I also have to add the `-threaded` option in order to have things happen in parallel?
10:30:44 <supki_> nitrix: Data.Foldable.fold in GHC 8
10:30:55 <mniip> well that's a useless data
10:31:20 <shachaf> Agreed, it should just be Foldable.fold
10:31:51 <nitrix> return () is the identity of the IO monoid?
10:32:23 <nitrix> I'm testing your suggestion supki_ 
10:33:37 <zzgg> in haskell/ghci, is there a way to create a 'process dictioonary'? I want some map that can persist between :reloads within a ghci session
10:33:38 <supki_> it's the identity of the IO () monoid
10:34:07 <sm> zzgg: yes, there is some package for that
10:34:10 <zzgg> so ghci fires off (in another thread) some loop that is running; taht loop has a callback, I want to be able to update this callback across :reloads of ghci
10:34:13 <zzgg> sm: cool, which one?
10:34:18 <sm> I forget, try a search
10:35:09 <nitrix> supki_: Passes the tests. Thank you. I'll have another look at monoids, I seem to never think of them when I'd need to.
10:35:13 <zzgg> sm: ok
10:35:23 <zzgg> sm: thanks anyways
10:36:41 <zzgg> So I'm following https://wiki.haskell.org/OpenGLTutorial1 . I also have a standard setup where I have a terminal running "stack repl" and edit code in another window. I would like to :reload code in ghci. This does not work right now becuase (1) mainLoop eats up the main athread and (2) I can't call getArgsAndInitialize twice (otherwise glut dies). Thus, I need someway of updating 'displayCallback' across ghci :reloads. Is there some wa
10:36:46 <zzgg> of some sort which persists across ghci :reloads ?
10:38:22 <ClaudiusMaximus> zzgg: afaik live coding environments like Tidal pipe source code to ghci's stdin instead of using :reload or similar
10:38:56 <sm> zzgg: the one I'm thinking of is by chris done, but I'm not finding it
10:39:13 <sm> https://github.com/chrisdone/ghci-reload-demo or http://hackage.haskell.org/package/ghci-ng might be related
10:39:21 <sm> there's also http://hackage.haskell.org/package/rapid
10:41:17 <zzgg> sm: I initially thougt you were being sarcastic, but was not aware there were packages on hackage that solved this problem. The ChrisDone link looks very close to what I need. Thanks!
10:44:59 <Profpatsch> Existentials question: I‘ve got a piece of code for handling translation, which roughly looks like this: http://lpaste.net/177433
10:45:46 <Profpatsch> I want to use the translation function t :: FromMarkup a => Markup -> a in the site template like:
10:46:05 <Profpatsch> t TranslationTypeConstructor :: Html
10:46:18 <Profpatsch> t OtherConstructor :: AttributeValue
10:46:44 <sm> zzgg: let us know how it works
10:46:56 <glguy> Profpatsch: It looks like you might want: data Translated a = Trans (forall t. FromMarkup t => UIMessages -> t) a
10:47:03 <Profpatsch> In the example on line 23/24
10:47:13 <Profpatsch> glguy: With Rank2Types?
10:47:14 <glguy> Profpatsch: as an existentially quantified type you'd never be able to use that function to do anything interesting
10:47:31 <glguy> It'd just be some unknown type. Your FromMarkup class doesn't offer any useful functions on it
10:47:57 <glguy> Profpatsch: Rank2Types is old news and is a synonym now for RankNTypes, but yes, that
10:48:25 <glguy> Profpatsch: Even better would be: data Translated a = Trans (UIMessages -> Markup) a
10:48:28 <glguy> no extensions needed
10:48:43 <glguy> then later you can use fromMarkup on the resulting Markup values
10:49:00 <Profpatsch> glguy:   • Illegal polymorphic type:
10:49:02 <Profpatsch>         forall t. I.FromMarkup t => I.UIMessages -> t
10:49:04 <Profpatsch>       GHC doesn't yet support impredicative polymorphism
10:49:20 <glguy> Profpatsch: I don't know what you did wrong, then
10:49:28 <glguy> You'll have to paste what you tried to the pastebin
10:49:48 <Profpatsch> data Translated a = Trans (∀ t. I.FromMarkup t => I.UIMessages -> t, a)
10:49:51 <Profpatsch> Maybe I did a type.
10:49:53 <Profpatsch> *typo
10:49:56 <glguy> Profpatsch: No, don't use (,)
10:50:11 <mnoonan> I want to wrap a large-ish C++ library that thankfully is simple enough that I think I can generate good Haskell bindings from a pretty shallow parse of the header files.  But now I need to figure out how to model the C++ classes in Haskell-land.
10:50:17 <glguy> You can't put a polymorphic type inside of a tuple like that
10:50:20 <mnoonan> thankfully there is essentially no inheritance
10:50:30 <Profpatsch> glguy: Ah, lol.
10:50:47 <mnoonan> but there are many identically-named accessors across the different classes
10:50:48 <Profpatsch> I think the tuple was an old relict from before.
10:50:57 <glguy> Profpatsch: anyway, you don't need extensions
10:51:13 <glguy> UIMessages -> Markup is just as expressive
10:51:27 <Profpatsch> Hm, probably, yes.
11:02:52 * hackagebot read-env-var 0.1.0.1 - Functions for safely reading environment variables.  https://hackage.haskell.org/package/read-env-var-0.1.0.1 (cdepillabout)
11:03:00 <dmwit_> mnoonan: Check out fficxx.
11:03:16 <dmwit_> http://hackage.haskell.org/package/fficxx
11:17:55 <radens> How does haskell handle once initialized global state? My understanding is that you wrap the global state in the State monad, but then you have to pass that state to future functions which really don't care at all about the global state.
11:18:39 <radens> I write the global state once, and then I forget about it.
11:20:35 <nitrix> For one, you shouldn't have such thing as "global" state.
11:20:54 <danielsmw> radens A stateful computation of the form f >>= g >>= h passes the state along as part of the monadic machinery. You give that computation an initial state when you run the stateful computation with runState
11:21:28 <nitrix> What you have are stateful computations, that has access to read and modify a state, as well as producing a result. These computations can be chained (they're monadic), and at the very begining of the chain, you feed your initial state.
11:22:18 <nitrix> You can evalute the computation for its result and/or the final state, with evalState, runState, execState.
11:22:37 <yyyyy> radens: you can also pass it explicitly without a State monad if they're used very infrequently or in very few places.
11:22:53 * hackagebot lrucaching 0.2.1 - LRU cache  https://hackage.haskell.org/package/lrucaching-0.2.1 (cocreature)
11:24:07 <yyyyy> sometimes a monad is too much.
11:24:42 <nitrix> Except the part where yyyyy has somewhat assumed using State implies a monadic interface, I'd agree.
11:32:08 <nitrix> > execState (StateT (\s -> pure ((), s + 1))) 0
11:32:09 <lambdabot>  1
11:32:51 <nitrix> You can manually write the lambda or even use the applicative instance :)
11:38:56 <dmwit> radens: For once-initialized state, I think `Reader(T)` is more appropriate than `State(T)`. Or just plain old functions that take the state as an argument.
11:39:12 <lambdamu_> or you make a good old top-level IO action
11:39:25 <dmwit> radens: There are clean ways to lift state-unaware actions to state-aware actions.
11:39:28 <dmwit> :t lift
11:39:29 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
11:39:59 <johnw> they aren't state aware, really, they just become state agnostic
11:40:27 <johnw> i.e., nothing that you "lift" can ever modify the state, by parametricity
11:41:49 <dmwit> Nothing can modify the "state" anyway with `Reader(T)`. But by parametricity, you also can't read it.
11:42:56 * nitrix hisses at the top-level global state with unsafe IO idea.
11:43:31 <nitrix> Enough of that. I tought this was generally agreed as disgusting, why is it still being recommended :(
11:44:26 <dmwit> I don't see anybody recommending it.
11:44:37 <nitrix> dmwit: 14:39:14       lambdamu_ | or you make a good old top-level IO action
11:44:39 <nitrix> dmwit: They left.
11:44:55 <dmwit> I don't see any part of that suggesting unsafe things.
11:45:08 <lambdamu> No still here, but I do not recommend it, I mention it as an alternativ
11:45:21 <lambdamu> But it was indeed meant as such
11:45:32 <dmwit> A top-level IO action could just mean `main = do { state <- initState; doThingsThatMentionState }`.
11:45:55 <dmwit> Well, okay.
11:46:49 <dmwit> I guess I won't try to defend you if you plan to incriminate yourself in plain sight. ;-)
11:47:04 <lambdamu> dmwit: thanks anyway :D
11:47:27 <lambdamu> it is right that reade and state are mentioned as first solutions
11:47:30 <nitrix> dmwit: I'm almost certain it meant unsafe; the point was to globally access it as in, modify myGlobalVar (const 0)
11:47:45 <lambdamu> but sometimes global state is ok
11:47:47 <puregreen> people defending unsafe IO stuff and not being disgusted by it? count me in
11:48:06 <nitrix> Otherwise, then the global IO function is as useful as using your original IO, which makes the global idea useless and you might as well just use State properly.
11:48:22 <lambdamu> or rather the overhead isn't always worth the safety you gain
11:48:34 <lambdamu> it's an engineering trade-off
11:48:46 <jonored> Wasn't there a degree of "a restricted form of this would be useful for things where you aren't actually talking about IO state would be reasonable, but we don't actually /have/ one"?
11:49:01 <lambdamu> One should be honest about the pros and cons but still complete to mention all alternatives
11:49:24 <nitrix> lambdamu: I replaced my library that was using a global state with a Context that the user can pass implicitly. Needless to say, it's now thread-safe and a lot more flexible (allowin different contexts and whatnot).
11:49:32 <jonored> (like creating MVars at the top level)
11:50:10 <lambdamu> nitrix: glad to here that, it usually the right direction and apparently in your case too
11:52:02 <ertesx> radens: i recommend regular functions over everything else that was suggested
11:52:57 <yyyyy> nitrix: it's true that you can manually write the lambdas, but why would you inflict that to yourself? :p
11:53:49 <ertesx> radens: functions are the least intrusive, most flexible choice, and if you really really really need it, you can always tack on a ReaderT for certain portions of your program
11:54:08 <Benzi-Ju1ior> hey is there no function similar to mapM for the array types ?
11:54:53 <puregreen> if the array is Traversable, you can use mapM from Data.Traversable
11:54:56 <danielsmw> There should be for immuatable arrays, because they're traversable
11:54:57 <dmwit> mapM works for the array types.
11:55:00 <yyyyy> i agree with ertesx. it's much easier to pass the parameters around than dealing with monad transformers.
11:55:34 <nitrix> yyyyy: The orignal argument was that too many people seem to talk of IO as being the "IO monad" and State as being the "State monad" and understanding that the type isn't linked to one specific instance is important.
11:55:44 <ertesx> Benzi-Ju1ior: since nobody else is doing it, i'm going to recommend the vector library over the array library, which also provides mapM for unboxed/storable arrays
11:56:22 * dmwit ponders: perhaps `mapM` is *too* similar to `mapM` to qualify as an answer to the question
11:56:54 <ertesx> (*someone* has to recommend 'vector' whenever the 'array' library comes up) =)
11:57:23 <danielsmw> speaking of recommending vector over array, are there any good higher-dimensional interfaces for vector?
11:57:32 <danielsmw> i find myself needing naturally 2D (or higher) structures too often
11:57:52 <danielsmw> i know some libraries like juicypixels just hand-roll that internally but i'd rather not
11:57:53 <nitrix> I'd imagine 3D vectors to grow extremely large very quickly.
11:57:54 * hackagebot libmpd 0.9.0.5 - An MPD client library.  https://hackage.haskell.org/package/libmpd-0.9.0.5 (JoachimFasting)
11:58:14 <dmwit> REPA, hmatrix come to mind
11:58:30 <yyyyy> nitrix: ahhh, ok. agreed. though in general using the monadic interface is generally easier, at least until ApplicativeDo becomes commonplace.
11:58:31 <danielsmw> i love hmatrix, but I meant bindings to the haskell vector library specifically
11:58:41 <yyyyy> from an ergonomic standpoint
11:58:47 <ertesx> danielsmw: alternatively you can use an iso lens to convert between linear and spatial coordinates
11:58:50 <danielsmw> i and i guess REPA, but it hasn't been updated in years and it's so rough to tune the performance
11:59:15 <ertesx> danielsmw: the arithmetic is very simple
11:59:16 <danielsmw> ertesx: okay, thanks. that's actually pretty much what i wanted to hear.
11:59:28 <danielsmw> ertesx: i figured something like that existed, but i'm not good enough with lenses yet.
11:59:55 <ertesx> danielsmw: an iso lens is pretty much just a pair of functions (a function together with its inverse)
12:00:10 <ertesx> but written in a way that allows them to be composed with other lenses
12:01:06 <danielsmw> ertesx: I see. So i could essentially give it Ix -> Int and Ix -> Int maps, and then access my vector using an Ix through the Iso lens.
12:03:16 <ertesx> :t \w -> iso (\(q, r) -> q*w + r) (divMod w)
12:03:18 <lambdabot> (Integral a, Functor f, Profunctor p) => a -> p a (f a) -> p (a, a) (f (a, a))
12:03:28 <ertesx> @let linear w = iso (\(q, r) -> q*w + r) (divMod w)
12:03:30 <lambdabot>  Defined.
12:03:50 <ertesx> > (2, 3) ^. linear 5
12:03:52 <lambdabot>  13
12:04:17 <ertesx> > 13 ^. from (linear 5)
12:04:19 <lambdabot>  (0,5)
12:05:14 <ertesx> weird
12:05:18 <ertesx> oh
12:05:22 <ertesx> @undef
12:05:22 <lambdabot> Undefined.
12:05:29 <ertesx> @let linear w = iso (\(q, r) -> q*w + r) (`divMod` w)
12:05:30 <lambdabot>  Defined.
12:05:33 <ertesx> > 13 ^. from (linear 5)
12:05:35 <lambdabot>  (2,3)
12:05:41 <ertesx> danielsmw: like that
12:06:16 <danielsmw> ertesx: Cool, I think I see what's going on now. Thanks!
12:06:35 <ertesx> danielsmw: but use that sparingly…  as you see, you pay a multiplication or division for each conversion
12:07:25 <ertesx> danielsmw: given a linear coordinate, you can do relative movement very easily…  you just have to pay attention not to cross the edges
12:07:37 <danielsmw> ertesx: That's a fair point. But with that said, is Data.Array doing that arithmetic internally anyway?
12:07:44 <danielsmw> In terms of comparing vector vs array usage.
12:07:49 <ertesx> danielsmw: yeah, it is
12:08:15 <ClaudiusMaximus> ugh. raspbian repo has ghc-7.6.3 without ghci/TH support, so i installed ghc-8.0.1 binary tarball. ghc-8.0.1 requires recent cabal, so i try cabal install -w ghc-7.6.3 cabal-install - ultimately fails after 1hr compiling because hackage-security needs TH :-( i guess i retry with bootstrapping cabal-install from tarballs...
12:09:20 <ertesx> danielsmw: in general stick to linear coordinates and only go to spatial coordinates when you absolutely need to
12:10:19 <ertesx> > (linear 5 . _1 +~ 1) 13  -- moving one row down
12:10:20 <lambdabot>      No instance for (Show b0)
12:10:20 <lambdabot>        arising from a use of ‘show_M159296987915546451710065’
12:10:20 <lambdabot>      The type variable ‘b0’ is ambiguous
12:10:28 <ertesx> > (from (linear 5) . _1 +~ 1) 13  -- moving one row down
12:10:30 <lambdabot>  18
12:11:09 <ertesx> danielsmw: i just paid a multiplication and division for what is essentially just adding the width:  18 = 13 + w
12:13:35 <joobus> ClaudiusMaximus: wouldn't it be easier to build in the raspbian docker image, then move whatever you're building to an rpi?
12:14:23 <joe9> it wrong to define a datatype http://dpaste.com/1HXFPG1 like this. having record fields for one constructor?
12:14:32 <dmwit> I know there's no well-known technique for 2D zippers that incurs O(1) cost during motion. Is there a well-known technique that incurs O(log n) cost during motion?
12:14:58 <ClaudiusMaximus> joobus: probably, but i've no experience of docker - i also read that latest qemu can't boot latest raspbian because of missing device drivers
12:15:01 <ertesx> joe9: it's semi-wrong
12:15:01 <dmwit> joe9: It is allowed by the spec but mildly dangerous: the field accessors will be partial.
12:15:10 <mnoonan> dmwit: (responding to earlier) I've looked over the fficxx docs before, but couldn't figure out how it would handle classes A and B that both implemented a function foo(). From the docs, it looks like it would have tried to have a foo function in two typeclasses IA and IB? 
12:15:16 <ClaudiusMaximus> joobus: i'll do some more research
12:15:52 <dmwit> mnoonan: I don't recall the details, but I'm pretty sure it handles that case gracefully. It's sophisticated enough to automatically generate bindings for ROOT, which is a pretty big C++ library.
12:16:02 <joobus> ClaudiusMaximus: running a docker image or vm would at least cut down on the hour long compile times.  pi's are slow.
12:16:06 <dmwit> mnoonan: I've only used it for a few hours total. =)
12:16:09 <lingxiao> hey all
12:16:11 <lingxiao> I'm having trouble describing this parser
12:16:18 <mnoonan> dmwit: ok, thanks. That at least encourages me that it's worth a try.
12:16:51 <ertesx> dmwit: what about just storing the index/path together with the original data structure?
12:17:05 <lingxiao> I want to parse "hello" that could be in a stirng in one of a few ways:
12:17:18 <lingxiao> "world\t000\nhello\t111"
12:17:23 <dmwit> ertesx: I still want O(1) update. Should have been more clear about that.
12:17:30 <lingxiao> or:   "hello\t000\nworld\t111"
12:17:44 <lingxiao> so hello either appear in the beginning of the document or somewhere in the middle
12:17:55 <lingxiao> right now i have this manyTill anyChar . lookAhead . string . pack $ "hello"
12:18:00 <ClaudiusMaximus> joobus: yep, reading more about docker/arm/qemu etc at the moment
12:18:09 <dmwit> ertesx: And to be even more clear: I think I have a way to do it. I just wonder whether it's a known thing.
12:18:11 <lingxiao> but this will also parse hello in this case "foo hello\t000\n"
12:18:32 <lingxiao> but in dont want that ... "hello" has to be preceded by no characters what soever or precded by "\n"
12:19:04 <ertesx> dmwit: i'd love to know what it is
12:20:10 <dmwit> ertesx: First, a (1D) zipper for [a] with O(log n) motion.
12:20:39 <dmwit> ertesx: Store O(log n) zippers for [a], with "indices" offset by 1, 2, 4, 8, etc. in each direction.
12:20:55 <dmwit> ertesx: To move, move one step in each of them.
12:21:08 <dmwit> ertesx: To update... ah, update is O(log n) here, too. Dang! =)
12:22:03 <ertesx> dmwit: in general, O(log n) update seems good enough, if you have O(1) motion, because you can collapse them anyway, so if your grid is regular, i'd go with explicitly stored indices
12:22:22 <dmwit> Yep, it's not a bad solution.
12:23:11 <ertesx> dmwit: i don't think you lose any functionality that way, either…  you even get the comonadic interface (store comonads)
12:24:47 <ertesx> disclaimer: i'm not a huge fan of zippers =)
12:25:03 <dmwit> They're occasionally convenient.
12:25:25 <lambdamu> lingxiao: how about `manyTill anyChar (space >> lookAhead (string "hello"))`
12:25:47 <lambdamu> lingxiao: OverloadedStrings is nice
12:26:16 <lambdamu> lookAhead (space >> string "hello") of course
12:27:06 <lingxiao> so you mean this:  manyTill anyChar lookAhead (space >> (string . pack $ w))  ?
12:27:33 <lingxiao> im sorr this: pUntil w = manyTill anyChar (lookAhead (space >> (string . pack $ w))) 
12:28:02 <lambdamu> lingxiao: Well yeah basically, now the parser wont stop if there isn't a space before w
12:28:11 <lambdamu> lingxiao: or rather space-like character
12:28:22 <lingxiao> wait no i think i didnt explain my setting well enough ...
12:28:24 <ertesx> dmwit: i'm wondering: what about cascading two 1D zippers?
12:28:27 <lingxiao> the .txt file either:
12:28:30 <lingxiao> hello 334
12:28:32 <lingxiao> world 344
12:28:34 <lingxiao> or:
12:28:36 <lingxiao> world 422
12:28:38 <lingxiao> hello 322
12:28:42 <lingxiao> but if i see:
12:28:43 <ertesx> dmwit: ah, nevermind, that doesn't work
12:28:45 <lingxiao> hello world 002
12:28:46 <EvanR> has this problem been going on for 24 hours or
12:28:52 <lingxiao> I shouldnt parse that .. .
12:29:26 <lambdamu> lingxiao: Ah yes you want to parse also if there is nothing in front
12:29:34 <lingxiao> this is what i have right now
12:29:35 <lingxiao> http://lpaste.net/177463
12:29:43 <lingxiao> which doesnt work ... also has a lot of repetiion but thats another story
12:29:50 <lingxiao> t1 .. t4 on top are my 4 cases
12:30:02 <lingxiao> t1 and t2 should parse into ("hello", 900)
12:30:07 <lingxiao> t3 and t4 shouldn't parse
12:31:59 <lingxiao> hmm thats weird what i had before works: http://lpaste.net/177464
12:32:07 <lingxiao> but fail on real data
12:32:23 <lambdamu> lingxiao: well it can be certainly achieved, but what are getting at?
12:32:39 <lingxiao> hang on let me double check my bug on real data
12:33:11 <lambdamu> lingxiao: if your input is rather random and you want just specifics you could just use a regex
12:33:19 <lingxiao> ahh this one:  t5 = L.pack "world hello\t999\nworld\t\900"
12:33:28 <lingxiao> no it's very structured, they're google ngrams
12:33:57 <lingxiao> the problem is "world hello", manyTill anyChar . lookAhead . string . pack "hello"  will consume the world
12:34:01 <lambdamu> lingxiao: ok but for example, can there be any data before the first hello?
12:34:08 <lingxiao> no there isnt
12:34:25 <lingxiao> like suppose hello is in line one, then no
12:35:03 <lingxiao> then i guess i can write a parser that says parse  hello \t 000 \n  or parse \n hello \t 000 \n
12:36:07 <lambdamu> ok then i would parser like (("hello" or "world")\t{number}\n)*
12:36:12 <lambdamu> *write
12:36:29 <lambdamu> * is basically many
12:36:42 <lambdamu> and or is <|>
12:37:40 <Guest86645> hi, is there a way to simplify this: https://gist.github.com/pkamenarsky/3629feb6664a96be35ba83e7ab93ee5f
12:37:50 <lingxiao> ahh this fixed it .. http://lpaste.net/177465
12:37:55 * hackagebot currency-convert 0.1.1.0 - Typesafe currency conversion  https://hackage.haskell.org/package/currency-convert-0.1.1.0 (pigworts2)
12:38:13 <lingxiao> but fails on this one: "hello\t999\nworld\t\900"
12:38:19 <lingxiao> let me see
12:38:21 <lingxiao> ...
12:38:31 <pka> i'm lookint for a way to unify Fields and DBRow somehow
12:52:56 * hackagebot lrucaching 0.3.0 - LRU cache  https://hackage.haskell.org/package/lrucaching-0.3.0 (cocreature)
13:09:51 <orion> Do I need to install cabal-install to build GHC?
13:10:34 <buglebudabey> orion not if youre talking about stack
13:11:20 <orion> I am not talking about stack.
13:11:30 <buglebudabey> then i am unsure
13:11:45 <quchen> GHC comes with its own Cabal
13:12:58 <quchen> So no, you do not need cabal-install, I think
13:13:03 <joe9> Is Data.Map.Strict the fastest for lookups and inserts when the key is a double? Or, there better libraries? Or, is the performance difference negligible?
13:13:11 <quchen> orion: See here for more information, https://ghc.haskell.org/trac/ghc/wiki/Building/Preparation
13:13:30 <quchen> joe9: Both lazy and strict Map are the same data type.
13:13:41 <quchen> The strict module just has an API that forces things more.
13:13:46 <quchen> So lookups are identical.
13:14:20 <quchen> And both lazy and strict Map are strict in the keys.
13:14:21 <orion> quchen: I heard somewhere that you need alex and happy.
13:14:28 <daniel_w> joe9, HashMaps are better when you don't need ordering.
13:14:51 <joe9> daniel_w: cool, Thanks.
13:15:00 <quchen> orion: Hm, not sure. GHC bootstraps a lot of things, I think Alex and Happy are part of that.
13:15:10 <quchen> Your stage0 compiler can compile Alex and Happy from source, after all.
13:15:45 <quchen> orion: The link I posted talks about Alex and Happy too though. Debian seems to be special here.
13:15:47 <daniel_w> joe9, IntMaps are better still; you may be able to cast your Doubles, but I'm not sure.
13:16:11 <joe9> daniel_w: ok, will check how to convert double to int's
13:16:15 <quchen> orion: Note that because Alex and Happy are binary dependencies, you can build them with Stack as well, if that’s your cup of tea.
13:16:27 <dmwit> Casting `Double` to `Int` seems like a good way to have very subtle bugs.
13:16:52 <quchen> dmwit: Well, it’s a hash, maybe a poor one, but should not alter correctness, no?
13:16:54 <daniel_w> it's tricky, it would need to be a bitwise cast
13:17:24 <daniel_w> hashing with Hashable might already be doing the right thing.
13:17:28 <dmwit> quchen: I dunno. Is negative 0 equal to 0? I can't recall the details of IEEE754.
13:17:33 <quchen> There’s some function that gives you the mantissa and exponents of a Double in a tuple. You can add those up to get some kind of hash.
13:17:37 <dmwit> What about other numbers that have multiple representations?
13:18:14 <quchen> Doesn’t Double have a Hashable instance anyway?
13:18:18 <daniel_w> dmwit, I forget if -0 == 0, but if they are different, they'd cast to different values
13:18:33 <quchen> http://hackage.haskell.org/package/hashable-1.2.4.0/docs/src/Data.Hashable.Class.html#line-373
13:18:56 <dmwit> According to wikipedia, -0 == 0. So that would break the property that `x == y` implies `hash x == hash y`.
13:19:07 <quchen> Woah. That hash function is a beast.
13:19:15 <quchen> hash ((unsafePerformIO $ with x $ peek . castPtr) :: Word64)
13:19:24 <daniel_w> dmwit, oh, good point
13:19:32 <dmwit> Anyway, I didn't even realize you were suggesting the cast as a hash. I thought you were suggesting the cast, followed by using an `IntMap`. Which would be dangerous for basically the same reasons.
13:19:35 <johnw> so the "hash" is just the address of the object?
13:20:04 <johnw> or I guess, whatever is stored there as a number
13:20:05 <dmwit> johnw: Looks like a cast to me, not an addressof.
13:20:09 <quchen> johnw: GC wouldn’t like that.
13:21:25 <daniel_w> > hash (0 :: Double) 0 > hash (-0 :: Double) -9223372036854775808
13:21:26 <quchen> It seems to assume the sizes of Double and Word64 are the same, so it reinterprets the values.
13:21:27 <lambdabot>      Not in scope: ‘hash’
13:21:27 <lambdabot>      Perhaps you meant ‘has’ (imported from Control.Lens)    Not in scope: ‘h...
13:21:27 <lambdabot>      Perhaps you meant ‘has’ (imported from Control.Lens)
13:21:39 <quchen> Reminds me of the fast inverse square root hack.
13:22:04 <daniel_w> dmwit, you've found a bug in Hashable.
13:22:55 <pikajude> how would I introduce error handling into `Free eff a` based on this module http://hackage.haskell.org/package/free-vl-0.1.4/docs/Control-Monad-Free-VanLaarhovenE.html
13:23:30 <dmwit> > (-1) / (2^512) -- what just happened
13:23:32 <lambdabot>  -7.458340731200207e-155
13:23:59 <dmwit> Oh, I get it.
13:24:01 <quchen> ?
13:24:43 <dmwit> That doesn't take 512 bits, it takes log(512) bits to store the exponent. duh
13:25:24 <quchen> (-1) / (2^(2^512))
13:25:27 <quchen> ;-)
13:25:32 <dmwit> > (-1) / 2^(2^10) -- there we go
13:25:34 <lambdabot>  -0.0
13:25:56 <dmwit> ?let negZero :: Double; negZero = (-1) / 2^(2^10)
13:25:57 <lambdabot>  Defined.
13:26:11 <quchen> > 1 / (-1/0)
13:26:12 <dmwit> > hash negZero
13:26:13 <glguy> dmwit: https://github.com/tibbe/hashable/issues/116
13:26:13 <lambdabot>      Not in scope: ‘hash’
13:26:13 <lambdabot>      Perhaps you meant ‘has’ (imported from Control.Lens)
13:26:13 <lambdabot>  -0.0
13:26:31 <dmwit> yay
13:26:40 <dmwit> > -0 :: Double -- the easy way
13:26:42 <lambdabot>  -0.0
13:26:52 <quchen> Oh.
13:27:03 <dmwit> I was getting fooled by Integer defaulting when I tried that without the type signature.
13:27:16 <daniel_w> https://github.com/tibbe/hashable/issues/117
13:27:19 <dmwit> glguy: Neat, thanks!
13:27:27 <glguy> daniel_w: You're too late
13:27:29 <dmwit> daniel_w: oh no!
13:27:39 <daniel_w> fail,
13:27:48 <daniel_w> I'll close mine
13:30:38 <daniel_w> joe9, why do you want to use Doubles as keys anyway? That's quite a odd requirement
13:30:39 <dmwit> > 1 / (-0) == (-1) / 0
13:30:41 <lambdabot>  True
13:30:47 <dmwit> > 1 / 0 == (-1) / 0
13:30:49 <lambdabot>  False
13:30:56 <ongy> > 1 / (-0)
13:30:58 <lambdabot>  -Infinity
13:31:03 <dmwit> So at least there is a way to test for -0. =P
13:33:30 <glguy> dmwit: How about isNegativeZero :: RealFloat a => a -> Bool
13:33:44 <dmwit> too easy
13:34:48 * dmwit wipes the egg off his face
13:36:15 <joe9> daniel_w: I am getting the identifier as "1.223423432423" format. It is not exactly a double. It is meant to be treated as a string.
13:36:55 <daniel_w> joe9, you might want: https://hackage.haskell.org/package/scientific-0.3.4.9/docs/Data-Scientific.html#t:Scientific
13:37:02 <orion> When I install something with cabal by manually compiling Setup.hs, how do I change this path?: usr/local/lib/x86_64-linux-ghc-8.0.1/mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM
13:37:07 <joe9> daniel_w: Thanks.
13:37:12 <orion> Specifically, the "x86_64-linux-ghc-8.0.1" part.
13:37:53 <dmwit> orion: Use a different compiler. ;-)
13:38:43 <geekosaur> I think the point is it's supposed to be a cross compile, but it's been registered as a host compile?
13:39:15 <orion> I'm running cabal-install's bootstrap.sh script. I want it to install packages in to /usr/local/lib/ghc-8.0.1/ rather than /usr/local/lib/x86_64-linux-ghc-8.0.1/
13:40:05 <lingxiao> hey all
13:40:14 <lingxiao> im still having trouble with my parser ...
13:40:18 <lingxiao> despite help from earlier
13:40:47 <orion> Shouldn't all global packages go in ghc-8.0.1?
13:41:04 <lingxiao> http://lpaste.net/177469
13:41:16 <lingxiao> the problem is  t5 should fail
13:41:18 <begriffs> You do you "explode" a Text value "abc" into ["a","b","c"]::[Text]? splitOn requires a non-empty first parameter
13:41:21 <lingxiao> but right now it's succesding
13:41:35 <buglebudabey> if im compiling something to c, should i compile to some abstract form of c or use the ffi or some other method
13:41:53 <lyxia> > fmap (:[]) "abc"
13:41:55 <lambdabot>  ["a","b","c"]
13:42:15 <hexagoxel> orion: you do like `./Setup install` ?
13:42:25 <begriffs> lyxia: wow that's nice.
13:42:30 <Marqin> i need some CSPRNG (can be just using /dev/null on UNIX and CryptGenRandom on Windows) - is there some stable package for that?
13:42:54 <Marqin> GHC-included random and tf-random say that are not for cryptographic purposes
13:43:04 <begriffs> Now I see there's a chunksOf function that would probably work
13:44:15 <orion> hexagoxel: cabal-install's ./bootstrap.sh script does that, yes.
13:45:02 <dmwit> ?hackage DRBG
13:45:02 <lambdabot> http://hackage.haskell.org/package/DRBG
13:45:04 <dmwit> ?hackage crypto-random
13:45:05 <lambdabot> http://hackage.haskell.org/package/crypto-random
13:46:08 <lingxiao> geekosaur could i target the question to you?
13:46:18 <lingxiao> http://lpaste.net/177469   t5 shouldnt parse but it is
13:48:42 <lingxiao> bascially i want to parse an occurence of "hello" that's not precded by white space
13:48:51 <lingxiao> but im not sure how to say no white space
13:51:13 <Gurkenglas> Well read something that's not a whitespace
13:52:10 <Gurkenglas> something like "mfilter (not . isSpace) <$> anyChar"
13:53:37 <lingxiao> Gurkenglas sorry where does mfilter come from?
13:54:00 <lingxiao> oh but in the process of arrivng at "hello" in the string "......\nhello...."
13:54:04 <lingxiao> I could encoutner white space though
13:57:57 <cocreature> lingxiao: mfilter is in Control.Monad
13:59:30 <lingxiao> cocreature what's its type signautre?
13:59:34 <lingxiao> because i only see filterM
13:59:38 <lingxiao> wait nvm
13:59:46 <cocreature> lingxiao: https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#v:mfilter
14:00:28 <Benzi-Ju1ior> the forgotten beast that just showed up in the lake cavern in my fort is a "gigantic quadruped composed of flame" 
14:00:41 <cocreature> lingxiao: http://hoogle.haskell.org/ is imemnsely useful if you want to figure out where a function comes from
14:01:06 <lingxiao> oh hm didnt know you can search for function names on hoogle too
14:01:10 <lingxiao> i thought it was only signature
14:01:25 <lingxiao> also posted this quetsion on SO: http://stackoverflow.com/questions/38962964/parsing-the-first-occurrence-of-a-word-that-is-not-precded-by-white-space
14:12:58 * hackagebot keycode 0.2.2 - Maps web browser keycodes to their corresponding keyboard keys  https://hackage.haskell.org/package/keycode-0.2.2 (ryanglscott)
14:24:08 <quchen> Benzi-Ju1ior: #dwarffortress sounds like a better place for this.
14:33:07 <Benzi-Ju1ior> quchen: ye wrong window sorry yall 
14:33:34 <vaibhavsagar> how do I parse a word32 with attoparsec?
14:34:55 <dmwit> I guess that depends a lot on what format you expect it to be in.
14:35:39 <vaibhavsagar> so I can currently `take 4` which gives me a bytestring
14:35:57 <vaibhavsagar> how do I convert this bytestring to a word32?
14:36:43 <dmwit> foldr (\x y -> fromIntegral x * 256 + y) 0 -- or similar
14:37:17 <glguy> You'll have to decide what encoding those 4 bytes are using
14:37:59 <vaibhavsagar> right, that makes sense
14:39:18 <vaibhavsagar> I'm trying to read crc32 checks from a git pack index, in case anyone was wondering
14:52:40 <troydm> I'm wondering how bytestring works internaly
14:53:07 <troydm> does it allocates a byte array of some fixed size for string or it just takes the string length and allocates accordingly?
14:54:27 <troydm> because apparen
14:56:30 <Eduard_Munteanu> troydm, strict bytestrings are basically buffers. Lazy bytestrings are lists of chunks, which in turn are strict bytestrings.
14:57:37 <Eduard_Munteanu> Of course functions like 'pack' check the String length.
15:03:31 <sm> Benzi-Ju1ior: feel free to mispaste more, not enough adventure around here
15:06:50 <zomg> Benzi-Ju1ior: dorf fortress? :P
15:08:03 <sm> and where, wheere is the haskell port of dwarf fortress ??
15:08:34 <sm> surely we can catch up to those guys in a few years
15:09:58 <CubicE> sm, for a suitable value of "a few" sure xD
15:11:49 <zomg> Aurora4x is in much direr need of a port considering how unstable and error prone it can be... =)
15:31:28 <troydm> Eduard_Munteanu: well thing is I do a lot of bytestrings and Document from aeson and somehow my Haskell app eats up over 3gb of memory
15:33:24 <Eduard_Munteanu> troydm, might be lazy evaluation or failure to garbage-collect the bytestrings in time.
15:33:44 <troydm> Eduard_Munteanu: or 32k Documents in memory
15:33:58 <johnw> troydm: check out http://neilmitchell.blogspot.com/2015/09/detecting-space-leaks.html
15:34:17 <troydm> johnw: read it done that
15:34:21 <johnw> lol
15:34:31 <Eduard_Munteanu> :t B.copy
15:34:32 <lambdabot>     Not in scope: ‘B.copy’
15:34:32 <lambdabot>     Perhaps you meant one of these:
15:34:32 <lambdabot>       ‘BS.copy’ (imported from Data.ByteString),
15:34:33 <johnw> then maybe it's heap residency
15:34:36 <Eduard_Munteanu> :t BS.copy
15:34:38 <lambdabot> Data.ByteString.Char8.ByteString -> Data.ByteString.Char8.ByteString
15:35:32 <Eduard_Munteanu> Try adding strictness when decoding.
15:35:38 <Eduard_Munteanu> @hoogle decodeStrict
15:35:38 <lambdabot> No results found
15:35:48 <Eduard_Munteanu> @hoogle decode'
15:35:48 <lambdabot> No results found
15:36:46 <troydm> johnw: http://imgur.com/a/Bvgs8
15:36:56 <johnw> yep
15:37:16 <johnw> you're linearly allocating more and more heap space
15:37:31 <johnw> question is, why can't GC free any of it?  is it being held by thunks?
15:39:01 <troydm> johnw: it's being saved into HashMap
15:39:08 <troydm> johnw: well my code is at fault
15:39:35 <troydm> and honestly I'm too tired to think about how to refactor it coz it's 2AM now and I'm bit sleepy
15:40:09 <troydm> johnw: https://github.com/troydm/edda/blob/master/src/EDDA/Data/Import/EDDB/Stations.hs
15:40:22 <troydm> johnw: downloadAndImportListings function
15:41:11 <troydm> johnw: I was thinking about rewriting the whole thing into recursive function that wouldn't build HashMap but instead will do it line by line
15:41:34 <troydm> johnw: but that is something that I'm too tired to do right now
15:42:04 <troydm> but still I can't understand why a dataset that is literally only few 80mb's can blow up into 3gb's 
15:42:36 <troydm> Haskell is very inefficient in it's memory usage when dealing with tons of bytestrings
15:43:54 <lambdamu> Well you most probably have a spaceleak
15:44:04 <johnw> he checked for space leaks
15:44:16 <johnw> and his profile does show a huge heap blowup
15:44:25 <johnw> mainly from tons of bytestring
15:44:40 <johnw> troydm: somehow, you're copying your 80mb bytestring a ton of times
15:44:45 <johnw> I don't think it's bytestring that's at fault here
15:45:01 <troydm> johnw: I'm not sure how that is even possible
15:45:14 <johnw> nevertheless, your heap profile shows that it's happening
15:45:18 <troydm> johnw: I download the file and convert it into [Bytestring] using lines
15:45:24 <johnw> either that, or you're generate 2GB of bytestrings with some other content
15:45:35 <johnw> because that's what ARR_WORDS means
15:45:53 <troydm> johnw: probably that
16:57:04 <dustmote> i'm attempting to use the sdl2 package, SDL.Audio module... i got the system to initialize, and give me an audio device.. i'm poking at the device spec, and got a compile error i've never seen before
16:57:08 <dustmote> 'Cannot use record selector ‘A.audioSpecFormat’ as a function due to escaped type variables'
16:57:29 <biglambda> Hmmm…
16:57:30 <dustmote> i think this means that the type variable is ambiguous, and therefore i cannot extract the value from the audio device spec?
16:58:11 <biglambda> Try limiting the type.
16:58:29 <biglambda> Specify the type at the point of application.
16:58:56 <biglambda> Or use ScopedTypeVariables
16:59:12 <hpc> data AudioSpec = forall sampleType. AudioSpec {...
16:59:18 <hpc> yeah, that
16:59:35 <biglambda> Paste some code and I’ll show you where.
17:00:11 <hpc> it's surprising to see sdl2 go for that sort of thing, considering how faithfully it sticks to the C API
17:00:46 <dustmote> i tried `A.audioSpecFormat spec :: A.AudioFormat Int8` but it didn't work
17:00:47 <biglambda> I’ve had huge issues because of overlaps between the various SDL libraries
17:00:50 <dustmote> i'll paste; one sec
17:01:10 <biglambda> SDL2 is not quite as good, IMHO
17:01:35 <dustmote> http://lpaste.net/177482
17:01:50 <hpc> by SDL2 do you mean sdl2 or SDL?
17:02:00 <dustmote> sdl2, the c library or the haskell package?
17:02:16 <hpc> also that
17:02:25 <biglambda> Between sdl2 and SDL I mean
17:02:31 <hpc> the choice of names for the sdl packages is unfortunate
17:02:46 <Welkin> and sdl2 contains the raw bindings too
17:02:52 <Welkin> you don't have to use the high-level wrapper
17:03:07 <Welkin> which deviates from the official api
17:03:19 <biglambda> dustmote are you still having that compile issue?
17:03:23 <dustmote> yeah, i might drop down to the raw bindings
17:03:33 <dustmote> biglambda: yes; i pasted above
17:03:53 <hpc> i wonder if that's a deliberate choice
17:03:54 <dustmote> line 20
17:04:08 <biglambda> What is the type of spec?
17:04:18 <hpc> to force audioSpecFormat to be impossible to extract
17:04:37 <biglambda> I think it must have a type variable in there.
17:04:44 <biglambda> So it’s ambiguous.
17:05:09 <dustmote> it does
17:05:32 <dustmote> data AudioSpec = forall sampleType. AudioSpec
17:05:36 <biglambda> So you need to specify the type of “spec”
17:05:40 <dustmote> ah!
17:05:45 <biglambda> or specify sampleType
17:06:01 <biglambda> Sorry my haskell nomenclature is rusty
17:08:42 <troydm> is there a simple function to partition list to lists of elements by some fixed size at max?
17:08:59 <Koterpillar> :t chunksOf
17:09:01 <lambdabot> Int -> [e] -> [[e]]
17:09:03 <dustmote> hmm, yeah, actually sampleType is a forall'd variable, AudioSpec isn't paramerterized
17:09:08 <Koterpillar> troydm: see above
17:09:09 <troydm> Koterpillar: thx
17:09:15 <biglambda> Hmmm…
17:10:22 <dustmote> what was the solution using scoped type variables?
17:12:55 <biglambda> It’s not actually a solution to this problem I don’t think
17:15:42 <biglambda> I don’t think you are supposed to directly access that parameter.
17:20:27 <biglambda> Basically the changeable type keeps it ambiguous
17:20:45 <biglambda> And the compiler doesn’t want to let you specify it because it’s not a parameter.
17:21:47 <biglambda> The actual value in foreign memory.
17:21:58 <biglambda> So it’s an SOL situation.
17:22:04 <dustmote> erm.... so what do ou think the sdl2 folks meant by giving it back to me via the AudioSpec data structure?
17:22:10 <dustmote> perhaps it's a mistake in their api design?
17:22:14 <biglambda> Yeah
17:22:21 <biglambda> The design is not great
17:22:45 <biglambda> They are trying to abstract out implementation details.
17:22:54 <biglambda> Why do you need that parameter?
17:23:54 <biglambda> And if by “folks” you mean “one guy” who worked on this 4 years ago. Then YEEES!
17:25:23 <dustmote> biglambda: sure, yes, not trying to blame; just understand
17:25:30 <dustmote> i don't need the parameter
17:25:35 <biglambda> I’m kidding around.
17:25:40 <dustmote> the api gave be back a configuration object, so i wanted to check it out :
17:25:46 <dustmote> :P curiosity!
17:26:20 <biglambda> I would just let it be unless you need it. Or see if there is another API call to get that info.
17:28:31 <dustmote> there is!
17:28:40 <biglambda> Haha!
17:28:40 <dustmote> the callback function receives it as the first argument...!
17:28:50 <biglambda> Well there you go
17:29:12 <biglambda> I think that spec is mostly and internal structure
17:37:19 <dustmote> ok! well i think that got me almost all the way to the demo program, any how.. thanks!
17:37:33 <biglambda> np
17:38:04 * hackagebot optparse-applicative 0.13.0.0 - Utilities and combinators for parsing command line options  https://hackage.haskell.org/package/optparse-applicative-0.13.0.0 (huw)
17:43:04 * hackagebot mysql-haskell 0.1.0.0 - pure haskell MySQL driver  https://hackage.haskell.org/package/mysql-haskell-0.1.0.0 (winterland)
18:26:54 <dmwit> Hm, ?seen definitely doesn't do what I expected it to do. =P
18:27:30 <Axman6> pretty sure it doesn't work any more, can't remember what it corrects it to though
18:27:35 <Axman6> @seen dmwit 
18:27:36 <lambdabot> dm\/\/i+
18:27:43 <Axman6> @leet dmwit 
18:27:44 <lambdabot> DM\/\/iT
18:28:27 * dmwit nods
19:03:06 * hackagebot hs-watchman 0.0.0.3 - Client library for Facebook's Watchman tool  https://hackage.haskell.org/package/hs-watchman-0.0.0.3 (BitConnor)
19:24:19 <Eduard_Munteanu> Was there ever a "seen" in lambdabot? I thought only preflex had one.
19:25:40 <Welkin> there was
19:25:43 <Welkin> it was removed
19:25:57 <Welkin> it caused a space leak or something
20:17:43 <Vulpyne> Hi. I have a question about unsafeThaw and the vector package. If I'm using a mutable vector and I unsafeThaw it in the ST monad and perform an operation that *only* reads, do I actually have to unsafeFreeze it again and propagate that result?
20:18:35 <Vulpyne> I actually have found some examples of people doing this, but from the documentation it doesn't seem like it's necessarily safe. 
20:32:21 <ecco`> Visible type application only works with *?
20:32:30 <mniip> no?
20:33:08 <ecco`> Expected a type but `"Foo"` has kind `Symbol`
20:33:17 <ecco`> quoth GHC
20:34:00 <Welkin> ecco`: Earth Coincidence Control Office?
20:35:33 <ecco`> haha, no
20:37:02 <glguy> ecco`: sounds like you're specifying a type you didn't expect to be
20:37:21 <glguy> as in the order was different
20:39:03 <ecco`> Ah, yup. Thanks
20:39:35 <jloomis> I'm having issues with Persistent. 1. There's no instance for "PersistFieldSql (Maybe a)" and 2. When I try to create an instance for Maybe, it still says there's no instance. http://lpaste.net/177525
20:40:13 <Welkin> you are defining it wrong
20:40:24 <Welkin> in the schema you do it backward
20:40:25 <ecco`> The entity declaration syntax has the `Maybe` trailing the type
20:40:29 <Welkin> Text Maybe
20:40:35 <jloomis> Ohhhhhh
20:40:42 <grantwu> How do I search a nonstandard package on Hoogle?
20:40:51 <grantwu> Like, Megaparsec doesn't appear to be there
20:40:57 <Welkin> grantwu: use hayoo
20:41:04 <jloomis> I'd ask why, but I guess it doesn't matter
20:41:23 <Welkin> jloomis: probably because you can't use maybe things like Maybe
20:41:29 <Welkin> in fact, the only one I know of is Maybe
20:41:35 <Welkin> it corresponds to NULL
20:41:43 <Welkin> or, not NOT NULL
20:41:57 <Welkin> many things*
20:42:00 <grantwu> Welkin: http://hayoo.fh-wedel.de/?query=megaparsec doesn't seem to find anything...
20:42:06 <Welkin> the type pretty much has to be a basic type
20:42:48 <jloomis> Welkin: ah I see. Thank you for the help!
20:43:00 <Welkin> grantwu: then it's not there
20:44:42 <ReinH> jloomis: if it's in Stackage you can search therre https://www.stackage.org/lts-6.12/hoogle?q=megaparsec
20:44:55 <ReinH> the usual hoogle has a limited database
20:45:25 <jloomis> grantwu: ^
20:45:42 <ReinH> oh, woops
20:45:48 <Welkin> even better, you can use local hoogle on your machine
20:45:55 <Welkin> and search whatever packages you have installed
20:45:55 <ReinH> Also true
20:48:40 <x1f577> > :t Reflex.Dom.Time.debounce
20:48:42 <lambdabot>  <hint>:1:1: parse error on input ‘:’
21:29:14 * hackagebot mysql-haskell 0.1.0.0 - pure haskell MySQL driver  https://hackage.haskell.org/package/mysql-haskell-0.1.0.0 (winterland)
21:29:14 * hackagebot hs-watchman 0.0.0.3 - Client library for Facebook's Watchman tool  https://hackage.haskell.org/package/hs-watchman-0.0.0.3 (BitConnor)
21:34:31 <teegee-> dmwit: wow, blast from the past there. I'll commit once I reset my password.
21:53:12 * hackagebot mysql-haskell 0.1.0.0 - pure haskell MySQL driver  https://hackage.haskell.org/package/mysql-haskell-0.1.0.0 (winterland)
21:53:12 * hackagebot hs-watchman 0.0.0.3 - Client library for Facebook's Watchman tool  https://hackage.haskell.org/package/hs-watchman-0.0.0.3 (BitConnor)
21:53:47 <Koterpillar> hmm
22:03:07 * hackagebot zxcvbn-c 1.0.0 - Password strength estimation  https://hackage.haskell.org/package/zxcvbn-c-1.0.0 (JoeyHess)
22:24:18 <FlakBoi> Sup all
22:24:32 <FlakBoi> Got an xmonad question if anyone is around. Xmonad room looks a little lonely
22:24:39 <Koterpillar> ask away
22:24:53 * Koterpillar probably should join #xmonad
22:26:00 <FlakBoi> Is there a pre-baked way to resize the contents of a terminal in xmonad? I know technically the terminal in question would control this, but I see people doing this on the fly in other window managers all the time.
22:26:23 <FlakBoi> Like using a key binding to grow and shrink the text as needed.
22:26:30 <Koterpillar> which window managers?
22:26:46 <FlakBoi> Like cool and i3 
22:27:07 <FlakBoi> I see no reason why it's not possible in xmonad, just no idea how it's done.
22:27:13 <glguy> Many terminals simply have shortcuts for changing the font size, like Control-+/-
22:27:21 <Koterpillar> I don't think it's the WMs doing that
22:27:25 <FlakBoi> Ah.
22:27:26 <Koterpillar> except compiz and friends
22:30:09 <Koterpillar> I also think this should be possible in Wayland, but don't quote me on it
22:34:05 <angerman> say f :: C -> D -> A, g = A -> B, is there an operator similar to (.) that would allow g . f :: C -> D -> B?
22:34:36 <johnw> sometimes it's called .:
22:34:44 <johnw> or you write (g .) . f and get used to the pattern
22:34:56 <Koterpillar> @pf (c -> d -> a) -> (a -> b) -> (c -> d -> b)
22:34:56 <lambdabot> Maybe you meant: pl bf
22:35:28 <mniip> @. pl djinn (c -> d -> a) -> (a -> b) -> (c -> d -> b)
22:35:28 <lambdabot> f = flip ((.) . (.))
22:35:40 <angerman> johnw that looks bit weird. But ok.
22:35:45 <mniip> @. pl djinn (a -> b) -> (c -> d -> a) -> (c -> d -> b)
22:35:45 <lambdabot> f = (.) . (.)
22:35:54 <johnw> it is a bit weird, and future readers may not thank you for it
22:36:31 <angerman> If only (.) would do it :) maybe I should define (°) ... 
22:37:11 <angerman> I just find myself looking for that operator quite often :-/
22:38:09 <johnw> write this in your file: f .: g = (f .) . g
22:38:23 <srhb> mniip: @. ?
22:39:23 <srhb> mniip: Composition for lambdabot commands?
22:39:28 <mniip> yes
22:39:37 <srhb> ... I did not know that was possibl :-P
22:39:42 <shachaf> Or you don't make it point-free in the first place.
22:40:05 <shachaf> Usually much clearer to write \x -> f . g x
22:40:11 <shachaf> Or even \x y -> f (g x y) is fine.
22:40:15 <mniip> @. type eval Just ()
22:40:17 <lambdabot> <no location info>: not an expression: ‘’
22:40:19 <mniip> aww
22:40:22 <angerman> shachaf point taken.
22:41:09 * glguy marks that down as a pun
22:41:49 <mniip> @. type run Just ()
22:41:52 <lambdabot> Maybe ()
22:42:46 <liste> mniip: is that a new feature?
22:42:49 <mniip> @. kind . type run Just ()
22:42:53 <lambdabot> *
22:42:54 <mniip> no it's years old
22:43:02 <liste> never seen anyone use it
22:43:12 <mniip> I've seen once or twice maybe
22:43:24 <mniip> in the, what, 2 years that I'm here?
22:48:08 * hackagebot friday-juicypixels 0.1.2 - Converts between the Friday and JuicyPixels image types  https://hackage.haskell.org/package/friday-juicypixels-0.1.2 (ThomasDuBuisson)
22:48:10 * hackagebot step-function 0.1.1.1 - Step functions, staircase functions or piecewise constant functions  https://hackage.haskell.org/package/step-function-0.1.1.1 (petterb)
22:49:17 <Eduard_Munteanu> Is VCache or something similar still being developed?
22:54:03 <mmhelloworld> Hi all, a newbie question: If I have a shared library dependency in my Haskell program and I have it added in "extra-lib-dirs" in my cabal file, is there a way I can run this without having to add the shared library path to LD_LIBRARY_PATH?
22:56:12 <FlakBoi> I'm no expert
22:56:19 <FlakBoi> But I'm told it's easier to manage this sort of thing with stack.
22:57:31 <mmhelloworld> I am using stack for this project
22:57:44 <kadoban> AFAIK stack doesn't help much more than usual with C shared libraries or whatever.
23:02:04 <mmhelloworld> Stack compiles fine with "extra-lib-dirs" but I can't run it without adding the path to the shared lib in LD_LIBRARY_PATH. There doesn't seem like any other way. Anyway it works with LD_LIBRARY_PATH so I will just continue with that. It is just inconvenient to set LD_LIBRARY_PATH before running it.
23:13:24 <dmwit> teegee-: You change nicks so often... at least once every ten years or so! How am I supposed to keep track of you?
23:14:13 <dmwit> mmhelloworld: What happens when you use stack to run it?
23:16:04 <mmhelloworld> dmwit: my use case is bit different.  It is an Idris code generator which will be invoked by Idris compiler so I can't run it with stack.
23:19:02 <mmhelloworld> I am starting to understand it may not be a Haskell thing. It may be a system (dynamic loader) thing. Probably there is some flag for the c compiler that can bundle together including shared lib dependency during compilation/linking time.
23:23:09 * hackagebot ginger 0.2.7.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.2.7.0 (TobiasDammers)
23:32:28 <geekosaur> mmhelloworld, you probably want to specify a -R option (likely ghc-options: -optl-R/dir/with/shlib)
23:33:25 <mmhelloworld> geekosaur: thanks! I didn't know about that. I will look it up.
23:43:07 <saurabhnanda> hi there, can anyone point me to a concise example of using lenses to modify a value of a nested record?
23:45:36 <Koterpillar> saurabhnanda: https://github.com/ekmett/lens/blob/master/examples/Pong.hs#L154
23:50:12 <ggws> What is a good set of tutorials for doing OpenGL ES 3.0 in Haskell? The GLFW bindings do not appear to work with Stack, and the Glut bindings appear old.
23:52:09 <osfameron> saurabhnanda: hey. interesting post on Medium
23:52:26 <saurabhnanda> osfameron: thanks. I'm still struggling with the same problems.
23:52:32 <saurabhnanda> unfortunately.
23:52:51 <saurabhnanda> Nested records seems to be a MAJOR MAJOR achilles heel. Either for me. Or for Haskell.
23:53:13 <Koterpillar> saurabhnanda: read through that file
23:53:15 <osfameron> I would've expected lenses to help there (but I've not studied lenses yet in anger)
23:53:31 <osfameron> saurabhnanda: templating is definitely a huge problem though
23:53:53 <osfameron> none of the templating libraries are *documented* in the way that anyone coming from a non-Haskell programming background can understand :D
23:54:22 <saurabhnanda> can anyone help me with this lens + nested records related problem: http://lpaste.net/177548
23:56:49 <Reshi> Any recommendation for a design of a infix operator/function to make logging easy? Ex: Error @@ "Error description" , Info @@ "Information.".
23:58:41 <saurabhnanda> okay, i've updated my code with some notes
23:58:42 <saurabhnanda> http://lpaste.net/177548
23:59:48 <srhb> Reshi: Parsec uses <?> to modify error messages, perhaps you can find some inspiration there.
