00:00:06 <adarqui> im adding mapConcurrently to all of backend code right now.. then im going to sleep, feeling victorious.
00:07:38 * hackagebot keter 1.4.3.2 - Web application deployment manager, focusing on Haskell web frameworks  https://hackage.haskell.org/package/keter-1.4.3.2 (ChristopherReichert)
00:07:38 * hackagebot dbm 0.1.0.0 - A *simple* database migration tool.  https://hackage.haskell.org/package/dbm-0.1.0.0 (RickyElrod)
00:16:41 <joe9> For some reason, I cannot get http://bpaste.net/show/b6f5c77a4969 aeson-1.0.0.0 installed.
00:16:45 <joe9> any suggestions, please?
00:17:33 * hackagebot twitch 0.1.7.1 - A high level file watcher DSL  https://hackage.haskell.org/package/twitch-0.1.7.1 (AndreasSchacker)
00:18:02 <Koterpillar> joe9: cabal.config requires semigroups==0.18.1
00:18:27 <Koterpillar> joe9: that's not compatible with aeson-1.0.0.0
00:21:00 <johnw> adarqui: the sleep of the concurrent is a thing of manifold wonders
00:21:26 <joe9> Koterpillar:  Thanks. I cannot figure out where that cabal.config value is coming from.
00:21:31 <ReinH> johnw: That version of stackage LTS isn't designed to be compatible with aeson-1.0.0.0
00:21:41 <ReinH> it's designed to be compatible with the version that is already included
00:21:48 <joe9> Koterpillar:  Do you use ghc-8? the nightly version needs ghc 8
00:22:33 <Koterpillar> I have ghc 8 thanks to the OS packages, but I use stack all the time
00:22:56 <joe9> ReinH: Should I use the Nightly Stackage for using aeson 1.0.0.0?
00:23:37 <ReinH> No, the nightlies haven't been updated yet either
00:24:29 <ReinH> it isn't trivial, they can't just bump the version number and put out a new nightly
00:25:37 <joe9> ReinH: I think I got myself into a corner here. I am trying to use aeson on a data structure with Map.Strict.
00:25:52 <ReinH> bumping the aeson version number will effect literally hundreds of transitive dependencies, each of which might have an upper bound on aeson that excludes the new version (and they would generally be wise to do so, since it's a major version change)
00:26:08 <Freeze16> http://ilredentore.dynv6.net/ updated :)
00:26:42 <ReinH> So back yourself down from the ledge and use the version of aeson supported by the version of lts you're on?
00:27:34 <joe9> ReinH: ok, Thanks.
00:36:32 <joe9> ReinH: http://bpaste.net/show/ed97061318ba I know that this code worked earlier before I tried installing aeson-1.0.0.0 . corresponding haskell code: http://dpaste.com/2P89NKJ
00:36:57 <joe9> I tried with aeson-0.11.1.4 and 0.11.2.0  and 0.11.2.1
00:37:05 <joe9> same error on all these package versions.
00:37:27 <joe9> I removed .stack-work and tried each package.
00:38:02 <joe9> ReinH: Any suggestions on how to fix it, please?
00:39:10 <ReinH> make it match the version listed on stackage.org for your lts version or remove the version specifier entirely
00:39:50 <ReinH> if you aren't releasing a library for others to use, you don't really need the version specification
00:40:01 <ReinH> the point of stackage is to make sure all the package versions work with each other already
00:40:18 <ReinH> so the one that the resolver chooses is the one you want to use
00:41:42 <joe9> ok, Thanks. That makes sense. I did not have the version specifier earlier when it worked.
00:42:23 <joe9> same error without the version specifier : http://bpaste.net/show/0bf56286ef28
00:42:51 <ReinH> I'm pretty sure that is a different error
00:43:18 <glguy> old aeson has a more restrictive instance on Map
00:43:18 <ReinH> since it isn't a cabal error
00:43:54 <joe9> ReinH: It is the same error as earlier with just a different aeson version
00:44:04 <ReinH> ah
00:45:47 <joe9> glguy:  it worked fine until a few hours ago when I started specifying aeson versions
00:46:56 <glguy> you need the 1.0 version to have maps with integer keys
00:47:38 <joe9> glguy: It worked just a few hours ago and I did not have 1.0 version then.
00:47:59 <joe9> glguy: 1.0 is for using Generics (I think).
00:48:14 <joe9> glguy: http://dpaste.com/1XK081F is my code.
00:48:59 <joe9> glguy: error : http://bpaste.net/show/f53232187d91
00:51:18 <glguy> yeah, like i said aeson 0.11 didn't have the generalized map instance
00:52:45 <joe9> glguy: How do I get aeson 1.0 installed ? Is that possible?
00:53:28 <glguy> you could change your map to have text keys
00:54:40 <ReinH> Or switch to an IntMap
00:55:00 <joe9> ReinH: good idea. I can use IntMap.
00:55:05 <ReinH> joe9: aeson 1.0 will conflict with package versions specified by stackage
00:55:09 <glguy> that sounds pretty good too
00:55:14 <ReinH> Integer shouldn't be your go-to integer type
00:55:27 <glguy> you don't have to use stackage
00:55:29 <ReinH> It has niche uses
00:55:36 <ReinH> Int should be your go-to integer type
00:55:47 <ReinH> glguy: but he is
00:56:09 <ReinH> you can try to set allow_newer: true in your stack.yml
00:56:27 <ReinH> but a major version bump implies (possible) incompatible changes
00:56:31 <ReinH> so that's not at all guaranteed to work
00:56:36 <joe9> ReinH, I wanted it to be integer but am constrained by the spec of another application.
00:56:55 <ReinH> You can convert between Int and Integer
00:57:04 <ReinH> your own representation isn't forced to use Integer
00:57:39 <ReinH> (unless you actually do need larger/smaller integers than Int provides)
01:05:56 <ongy> is there a general rule, when to use Either and when to create your own type with 2 Constructors that each have one field?
01:07:20 <EvanR> the general rule is kind of weird, to use Left/Right when you want generic success failure
01:07:29 <EvanR> and use something else when its not that
01:08:10 <EvanR> (Right being success, Left being failure)
01:11:24 <joe9> IntMap also uses Int as the Key
01:11:51 <ReinH> joe9: yes, that's why it's called IntMap. :)
01:12:50 <joe9> ReinH: will just Int and use fromIntegral for the conversion.
01:14:22 <{AS}> Are there any plans to standardize some of the GHC language extensions?
01:15:07 <{AS}> Oh there is
01:15:10 <{AS}> https://mail.haskell.org/pipermail/haskell-prime/2016-April/004050.html
01:39:03 <niluje> I'm sorry for the stupid question incoming
01:39:07 <niluje> http://lpaste.net/177839
01:39:42 <niluje> "zero" here is something that returns an IO Int. It's for the sake of the example, but it would return something random in a real example
01:40:26 <niluje> how can I modify "build" so the second "do" statement would work on a "lst" without the first element that is used just above?
01:40:29 <niluje> (not sure to be clear)
01:41:42 <nmattia> niluje: not sure I understand
01:41:47 <opqdonut> niluje: write a helper function "get :: [a] -> Int -> (a,[a]"
01:42:06 <opqdonut> niluje: using e.g. splitAt
01:42:14 <lyxia> the two elements of the list are independent actions, so you can't with that type signature
01:42:17 <opqdonut> niluje: that returns the indexed element and the rest of the list
01:42:36 <opqdonut> niluje: but then of course you need to return IO [a], not [IO a]
01:42:41 <opqdonut> niluje: as lyxia says
01:44:31 * niluje processes
01:45:45 <niluje> :( not possible to do something like : let x, y = (0, 1) ?
01:46:13 <ongy> niluje: let (x, y) = (0, 1)
01:46:34 <ongy> > let (x, y) = (0, 1) in y
01:46:36 <lambdabot>  1
01:46:58 <niluje> oh
01:47:36 * hackagebot haskell-eigen-util 0.1.0.1 - Some utility functions for haskell-eigen library  https://hackage.haskell.org/package/haskell-eigen-util-0.1.0.1 (dilawars)
01:47:47 <{AS}> maybe False == any, right?
01:53:03 <quchen> :t maybe False
01:53:04 <lambdabot> (a -> Bool) -> Maybe a -> Bool
01:53:05 <quchen> :t any
01:53:06 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
01:54:01 <niluje> opqdonut: http://lpaste.net/177844
01:54:10 <niluje> lst' is not in the scope on line 14
01:54:25 <niluje> is that the reason why you suggested to return a IO [a] instead of a [IO a] ?
01:55:01 <{AS}> niluje: The first is a list of a's which run in the IO monad, the latter is a list of IO actions that return as
01:55:51 <quchen> {AS}: You can even quickcheck things like these here. any is a generalized version of maybe False.
01:55:52 <niluje> yes, I think I get the difference
01:55:59 <quchen> ?check \x f -> maybe False f x == any f (x :: Maybe Int)
01:56:00 <lambdabot>  +++ OK, passed 100 tests.
01:56:02 <{AS}> quchen: Thanks!
01:59:33 <niluje> hm there's really something I dont' get, will go back on it tonight :(
02:00:31 <{AS}> niluje: It is not, because the two do-blocks are separate
02:01:10 <{AS}> so the let binding will only bind in the do-block from line 9 to line 10
02:01:36 <niluje> yep, I guessed so
02:02:27 <niluje> but what I don't understand is how to update this code to make it work :p
02:03:06 <{AS}> Usually you want IO [a] instead of [IO a] because you usually want the list you return to depend on IO actions, instead of creating a pure list of IO actions which internally have side-effects
02:03:32 <{AS}> The latter is useful, but only if you somehow do not want to execute all side effects in the resulting list
02:03:47 <niluje> I returned a [IO a] because I wanted to have some recursion
02:04:04 <niluje> like build n = [do ...] ++ build n - 1
02:04:25 <niluje> or actually build lst, n = [do ...] ++ build n - 1
02:04:43 <niluje> where build :: [a] -> Int -> [IO a]
02:04:47 <{AS}> let us call the (do ...) expression step
02:05:04 <niluje> I want build ot take a list, and take n random elements from it without duplicates
02:05:20 <{AS}> then you usually would do build n = do a <- step; as <- build (n - 1); return (a : as)
02:05:33 <niluje> !
02:05:44 <niluje> thank you so much
02:05:49 <{AS}> or (:) <$> step <*> (build (n - 1))
02:05:52 <{AS}> in Applicative syntax
02:05:54 <niluje> that's exactly what I was looking for
02:05:54 <{AS}> niluje: sure :)
02:06:03 <niluje> my brain is not yet made for haskell :p
02:06:28 <niluje> (and if far from being prepared for the <$>, (:) and <*>)
02:07:20 <eklavya> a distributed STM will fix my problems (distributed resource manipulation)
02:07:27 <eklavya> but the DSTM lib is really old
02:07:42 <eklavya> does anybody have any experience in this area?
02:08:28 <{AS}> niluje: (:) is just the name of the operator for list construction :
02:08:44 <{AS}> i.e. (x : xs) is the same as (:) x xs 
02:09:08 <niluje> okay
02:09:11 <niluje> right
02:09:30 <{AS}> You can do it for other operators as well
02:09:37 <{AS}> such as (+) (*), etc. 
02:11:35 <niluje> http://lpaste.net/177849
02:11:37 <niluje> hoora it works
02:11:45 <niluje> thanks a lot again
02:11:54 <{AS}> cool
02:12:13 <troydm|work> hey all! Was wondering if Haskell by default optimizes strings or not, for example I have a function f s = [ Const "string" s] and have overloadedstrings enabled Const Text Text is the type of the Const definitiona, if I have function f called 10000 times will Haskell's memory contain 10000 strings called "string" Text memory objects in memory or t
02:12:13 <troydm|work> hey all will point to one object
02:15:40 <mpickering> troydm|work: The answer is, it depends
02:17:36 <troydm|work> mpickering: yes it depends? can you explain a little bit in detail?
02:18:17 <troydm|work> mpickering: so I don't have to like define separate labels in order for haskell to use one and the same definition
02:19:25 <mpickering> the way to check is to look at the core by using -ddump-simpl
02:19:43 <troydm|work> mpickering: hmm
02:19:53 <{AS}> niluje: Btw, for that kind of recursion you could consider using traverse/mapM instead
02:19:55 <mpickering> If you put things in let bindings, then that is a guarantee that they will be shared 
02:20:10 <mpickering> let str = "abc' in [x,x,x,x,x] for example
02:20:14 <{AS}> niluje: no, nevermind
02:20:33 <niluje> why?
02:20:38 <niluje> because it's too complicated or not possible?
02:20:55 <troydm|work> mpickering: I don't get how that is a guarantee if let is inside a function?
02:21:17 <mpickering> I don't really understand either, this is just the advice I have been given
02:21:19 <{AS}> niluje: It is possible but requires a bit more work than I thought
02:21:36 <mpickering> experimenting and looking at core will be the most intstructive I feel
02:21:42 <niluje> grml I want to know now
02:21:57 <troydm|work> mpickering: hmm
02:22:32 <quchen> “let” does not *guarantee* sharing, the inliner might duplicate thunks for example. I doubt GHC does that, but it would not be illegal.
02:23:06 <quchen> In GHC, you should assume there is no common subexpression elimination, and trust the inliner to work quite well.
02:23:25 <troydm|work> mpickering: you know what? I feel like since OverloadedStrings is used and my definition uses Text which is actually converted from IsString class function I think it doen's works that way and I need to go over all my code and redefine every label in separate definitions file
02:23:36 <quchen> In other words, explicitly sharing things by introducing a let binding probably does what you want. :-)
02:24:01 <troydm|work> mpickering: that is probably one of the reasons my app eats a lot of memory
02:24:25 <mpickering> It's hard to say without anything concrete
02:24:54 <mpickering> you should profile and look at the core before doing any optimisation
02:25:14 <troydm|work> mpickering: agreed
02:25:49 <grayling_> Anyone with experience using Intero?
02:28:22 <lambdamu> grayling_: well I use it if that qualifies
02:30:27 <grayling_> lambdamu: That qualifies. I'm on debian with emacs 24 and just setup stack and intero. But whenever I c-c c-l intero makes emacs hang with a "Started Intero process for REPL." Have you seen that issue?
02:31:34 <lambdamu> grayling_: No, the repl loads without problems
02:32:13 <grayling_> And you're using vanilla emacs?
02:32:21 <lambdamu> grayling_: no spacemacs
02:32:37 <lambdamu> is it only the repl that fails or does nothing work?
02:32:59 <grayling_> Everything else seems to work. It's quite frustrating.
02:33:06 <grayling_> I'm soo close...
02:33:27 <grayling_> So I guess I have to use spacemacs.
02:33:36 <lambdamu> you are in project? and stack ghci from the cmd works?
02:34:04 <lambdamu> nah, I don't think that should be nescessary
02:34:22 <grayling_> Yes. Stack ghci works fine.
02:35:09 <grayling_> So my guess is that I need something quite obvious. I just cannot seem to find out what it is.
02:36:12 <lambdamu> So your emacs hangs completely and you have to kill it?
02:36:15 <{AS}> Does loch not work with GHc 7.10?
02:36:32 <grayling_> lambdamu: Yes. I have to kill the process.
02:36:39 <lambdamu> maybe try to get some debug output from emacs
02:36:48 <lambdamu> or trace
02:37:03 <lambdamu> though I don't really know anything about debugging emacs
02:37:38 * hackagebot ghc-typelits-natnormalise 0.5 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-natnormalise-0.5 (ChristiaanBaaij)
02:37:40 * hackagebot ghc-typelits-knownnat 0.2 - Derive KnownNat constraints from other KnownNat constraints  https://hackage.haskell.org/package/ghc-typelits-knownnat-0.2 (ChristiaanBaaij)
02:38:15 <grayling_> Me neither. But I think you're right.
02:39:32 <lambdamu> there are command toggle-debug-on-quit and toggle-debug-on-error
02:39:44 <dysfun> anyone fluent in freer around that can help with this? http://stackoverflow.com/questions/38993017/how-do-i-compose-freer-effects-in-haskell
02:40:04 <grayling_> lambdamu: Yes. I just found them. Will give it a try.
02:40:16 <lambdamu> if you kill the pocess with SIGUSR2 you might get the trace
02:48:22 <ggzz> how do I tel lhaskell to use aeson 1.0.0.0 instead of aeson 0.11.2.1 ?
02:50:27 <tdammers> ggzz: how are you invoking ghc?
02:50:52 <ggzz> stack repl
02:50:56 <tdammers> ah
02:51:13 <tdammers> then you need to either find a resolver that will use aeson-1.0.0.0, or override things in stack.yml
02:52:16 <tdammers> you can also specify aeson >= 1.0.0.0 in your .cabal file, but I believe stack will by default choke on that if it doesn't match the chosen resolver
02:53:07 <ggzz> do I overload this in stack.yaml extra-deps ?
02:53:12 <bergmark> ggzz: add aeson-1.0.0.0 under extra-deps
02:53:12 <ggzz> (the cabal file is auto generated from the stack  yaml)
02:53:21 <ggzz> it complains about semigroups-0.18.2
02:53:23 <ggzz> then I added it
02:53:41 <ggzz> so now, I have:
02:53:51 <ggzz> extra-deps: [ semigroups-0.189.2, aeson-1.0.0.0 ]
02:54:10 <ggzz> but stack repl complaings about ;failure to add dependencies: semigroups
02:54:36 <ggzz> despite the fact it clearly exists: https://hackage.haskell.org/package/semigroups
02:54:55 <bergmark> did you compile it? though i think stack repl should do that when it's invoked
02:55:18 <ggzz> let me gist a bunch of these files
02:55:19 <ggzz> give me 1 min
02:55:31 <lambdamu> semigroups-0.189.2 doesn't exist
02:55:48 <lambdamu> typo in the version number?
02:56:02 <ggzz> https://gist.github.com/ad1ec60695b64f2ddfa4cd15aea7b34e
02:56:16 <ggzz> lambdamu: good catch, unfortunately, typo happened between stack.yaml <-> irc, not in stack.yaml
02:56:29 <ggzz> https://gist.github.com/ad1ec60695b64f2ddfa4cd15aea7b34e is now my stack.yaml and the error I get from running "stack build"
02:57:00 <ggzz> bergmark: if I should be running something besides stack build, please let me know
02:57:16 <bergmark> ggzz: you probably also need `flags: semigroups: bytestring-builder: false' to get the correct bytestring version
02:57:38 * hackagebot overloaded-records 0.4.2.0 - Overloaded Records based on current GHC proposal.  https://hackage.haskell.org/package/overloaded-records-0.4.2.0 (PeterTrsko)
02:58:15 <bergmark> that flag should toggle automatically, but maybe stack doesn't do that
02:59:21 <ggzz> bergmark: https://gist.github.com/55dd35ada75e0e5e001512ab41607728
02:59:33 <ggzz> I have never updated the "flags: " field before, I think I am doing somethign wrong (line 46)
03:00:03 <bergmark> i don't know how one-line yaml syntax works
03:00:37 <ggzz> anyone here know how to fix: https://gist.github.com/anonymous/55dd35ada75e0e5e001512ab41607728#file-stack-yaml-L46 ? :-)
03:00:49 <bergmark> http://lpaste.net/177864
03:01:39 <ggzz> bergmark: it is now compiling
03:01:42 <ggzz> let's see if all resolves
03:02:26 <ggzz> bergmark: it worked! thanks! mind explaining to me why we need this bytestring-builder: false? semigroups is about abstract algebra right? why do we care about some bytestring-builer ?
03:03:08 <tsahyt> @hoogle mapMaybeM
03:03:11 <lambdabot> No results found
03:03:39 <tsahyt> @hoogle (a -> m (Maybe b)) -> [a] -> m [b]
03:03:40 <lambdabot> No results found
03:03:43 <bergmark> that flag is used to decide whether to use an older version of bytestring along with bytestring-builder (for older GHCs), or just a new version of bytestring
03:05:26 <bergmark> the docs for that flag is wrong
03:11:15 <jle`> tsahyt: sounds like that's just a mapMaybe and a sequence, or a mapM and a catMaybes ?
03:11:34 <tsahyt> jle`: I went with mapM and catMaybes
03:11:45 <tsahyt> I was just wondering if there was a function already providing this functionality
03:11:58 <jle`> tsahyt: ah, it's also 'wither' from the delightful witherable package
03:12:02 <jle`> http://hackage.haskell.org/package/witherable-0.1.3.3/docs/Data-Witherable.html#v:wither
03:12:46 <ertes> tsahyt: consider using a streaming abstraction
03:12:50 <tsahyt> interesting package
03:13:50 <tsahyt> ertes: Like what?
03:14:30 <ertes> tsahyt: most monads (particularly IO) will require the list to be in memory; that's why i'm suggesting streaming…  like pipes
03:14:59 <tsahyt> ertes: the list is already in memory before I reach this code
04:04:14 <ReinH> :t \f -> fmap catMaybes . mapM f
04:04:16 <lambdabot> Monad f => (a1 -> f (Maybe a)) -> [a1] -> f [a]
04:04:43 <ReinH> tsahyt: ^
04:07:02 <cloudhead> is there a library to pretty print records in an indented/multiline style?
04:07:35 <cloudhead> I tried pretty-show, but it does the same thing as the default show
04:09:51 <lyxia> cloudhead: pretty
04:11:21 <lyxia> ah, it's not automatic
04:11:22 <cocreature> cloudhead: pretty-show only breaks lines if it would be longer than some threshold
04:11:31 <cocreature> not sure if it’s possible to configure that
04:12:07 <cocreature> doesn’t look like it is
04:12:49 <mniip> that's why GHC has classes like Outputable
04:13:15 <mniip> with a ton of pretty printing configuration passed in via DynFlags
04:14:42 <Hafydd> What a Java-esque class name.
04:17:42 <cloudhead> lyxia: yeah, seems like I have to create an instance manually with pretty
04:33:20 <fodil> Hi there, sorry to bother you
04:33:28 <fodil> I don't understand how (-) works
04:33:34 <fodil> can someone help me ? :D
04:33:44 <liste> :t (-)
04:33:46 <lambdabot> Num a => a -> a -> a
04:34:03 <liste> fodil: what do you want to know about it?
04:34:16 <liste> fodil: do you know how sections work in general?
04:34:32 <liste> :t (+)
04:34:33 <lambdabot> Num a => a -> a -> a
04:34:35 <liste> :t (/)
04:34:36 <lambdabot> Fractional a => a -> a -> a
04:34:54 <fodil> i am just getting into Haskell, and i dont understand the fact that it is unary
04:35:10 <fodil> when I am doing 2 - 3, it does 2 + (-3) ?
04:35:10 <mniip> what s
04:35:18 <mniip> no
04:35:23 <liste> fodil: unary minus is a special case, it's part of the number literal
04:35:42 <liste> oh wait
04:35:54 <liste> > -x
04:35:55 <fodil> ok then why 2+ -3 doesnt work ?
04:35:56 <lambdabot>  negate x
04:36:07 <mniip> > x-y
04:36:09 <lambdabot>  x - y
04:36:11 <liste> it's not part of the literal, but it's special anyway
04:36:18 <mniip> fodil, you need parentheses
04:36:35 <mniip> without them parsing would be even more complicated than it is now
04:36:59 <fodil> ok
04:37:07 <liste> unary - is parsed differently than binary -
04:37:30 <fodil> ye i understand it now
04:37:38 <fodil> it works as a litteral
04:37:51 <liste> fodil: no, it's not a literal, that's why -x works
04:37:52 <fodil> but cannot get mixxed with infix operators
04:38:02 <liste> fodil: but yeah, it cannot be mixed without parenthesis
04:38:40 <liste> sometimes it's more clear to use `subtract' and `negate' instead
04:38:45 <liste> :t (subtract, negate)
04:38:46 <lambdabot> (Num a, Num a1) => (a -> a -> a, a1 -> a1)
04:41:10 <fodil> ok its 2 different operators 
04:41:28 <liste> yes
04:47:42 * hackagebot servant-subscriber 0.3.0.0 - When REST is not enough ...  https://hackage.haskell.org/package/servant-subscriber-0.3.0.0 (eskimo)
04:54:35 <kamyar> Hello everyone
04:54:57 <kamyar> Please help me about coroutines
04:55:02 <kamyar> https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/coroutines-for-streaming/part-2-coroutines
04:55:05 <kamyar> see this link
04:55:44 <kamyar> I have a question about the article
04:58:42 <zoran119> is there a way to write (\e -> e >>= print) 'point free' (whatever the monadic name would be)?
04:59:14 <zoran119> something like (>>=) print maybe?
04:59:15 <merijn> zoran119: "(>>= print)"?
04:59:43 <zoran119> merijn: ah, cool
04:59:54 <zoran119> don't know why i didn't try that :(
05:01:38 <fodil> liste, ok thanks
05:02:10 <mniip> (print =<<)
05:08:06 <kamyar> Anyone answering my question?
05:08:35 <merijn> kamyar: You didn't ask one. You linked and article
05:08:50 <kamyar> Yea, My question is:
05:09:02 <kamyar> in the head of the article
05:09:11 <kamyar> it is a code block
05:09:15 <kamyar> defining 2 types
05:09:23 <kamyar> each depends on the other
05:09:28 <kamyar> how it is possible?
05:10:06 <kamyar> Coroutine depends on CoroutineState and the opposite
05:10:17 <kamyar> CoroutineState depends on Coroutine
05:10:37 <Philonous> Is there a package for automatically generating (quickcheck's) Arbitrary instances? (Using any of TH, Generics, SYB ...)
05:10:51 <Philonous> I can't seem to find anything on hackage
05:12:02 <lyxia> generic-random
05:12:27 <kamyar> Any answer for my question? Sorry for disturbing u
05:12:50 <lyxia> kamyar: haskell declarations are all mutually recursive
05:12:57 <lyxia> even types
05:13:12 <quchen> > let x = 1:y; y = 1:x in x
05:13:14 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:13:26 <quchen> > let x = 1:y; y = 0:x in x -- woops, this is less pointless
05:13:27 <merijn> quchen: Maybe use 0 for one of those? :p
05:13:28 <lambdabot>  [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0...
05:14:48 <Philonous> lyxia, Thanks!
05:17:50 <Philonous> lyxia, Awww, it's not on stackage :(
05:18:17 <cocreature> Philonous: why do you need it to be in stackage?
05:29:48 <kaol> I'm curious about the Identity functor, $ and <$>. Given how (+1) $ 1 == 2 and (+1) <$> Identity 1 == Identity 2, has anyone explored the idea that $ and <$> would be the same if Identity was a first class citizen?
05:30:37 <Philonous> cocreature, Makes it easier to install / work with
05:31:48 <quchen> Identity is a first class citizen.
05:32:27 <kaol> I can't do (+1) <$> 1.
05:32:43 * hackagebot wai-app-static 3.1.6.1 - WAI application for static serving  https://hackage.haskell.org/package/wai-app-static-3.1.6.1 (MichaelSnoyman)
05:33:04 <quchen> That’s a type error, yes. But that doesn’t mean Identity is not a first-class citizen.
05:33:30 <opqdonut> he wants Identity to be implicit
05:33:40 <opqdonut> I thought that would be a good idea too, at some point
05:33:47 <kaol> Yes. What would happen if it was?
05:34:13 <opqdonut> you can do that, with OverlappingInstances I think
05:34:14 <Philonous> Well, (Identity a) is not the same as (a), so Identity isn't really the identity functor 
05:34:39 <opqdonut> no, you can't, because of how the Functor class is written
05:35:27 <lyxia> kaol: you'd have lots of ambiguities
05:35:31 <quchen> kaol: You’d still get a type error.
05:36:11 <kaol> I don't know if it would be Haskell anymore, but I'd like to see how coding with something where <$> and $ were the same.
05:36:31 <quchen> (+1) <$> 1, what does this mean?  Identity (+1) <$> 1? Identity (+ (Identity 1)) <$> Identity (Identity (Identity 1))?
05:36:46 <kaol> +were somewhere in that sentence.
05:37:32 <ertes> kaol: for some applicative functors i like to write Num instances…  Identity would be one of them, but unfortunately the base library disagrees with me =)
05:37:57 <ertes> kaol: with a Num instance you could write, for example:  (+ 1) <$> 1 :: Identity Integer
05:39:05 <Gurkenglas> What should I use to test the relative performance of two implementations of a function? QuickCheck seems like it ought to fit, but I see no combinator for it
05:39:17 <quchen> Gurkenglas: Criterion
05:39:41 <quchen> QuickCheck tests for incorrectness, not performance.
05:40:49 <kaol> ((+1) <$> (+2)) 3 could be ((+1) $ (+2)). That is, (.) == ($). It'd be interesting.
05:41:15 <ertes> > ((+ 1) <$> (+ 2)) 3
05:41:17 <lambdabot>  6
05:41:20 <ertes> kaol: ;)
05:41:28 <kaol> > ((+1) . (+2)) 3
05:41:30 <lambdabot>  6
05:41:39 <ertes> but that's a different functor…  you're now using the reader functor
05:42:19 <ertes> (<$>) :: (a -> b) -> F a -> F b,  where F = ((->) E)
05:42:37 <ertes> (<$>) :: (a -> b) -> (E -> a) -> (E -> b)
05:43:16 <ertes> in your example (3 :: E)
05:43:36 <ertes> s/the reader functor/a reader functor/
05:44:51 <Gurkenglas> quchen, QuickCheck generates parameters and Criterion looks like I have to supply them
05:45:08 <mniip> 1471437349 [15:35:49] <kaol> I don't know if it would be Haskell anymore, but I'd like to see how coding with something where <$> and $ were the same.
05:45:39 <mniip> consider if we had fmap :: (a -> b) -> F a -> F b, where F is a type family
05:46:17 <mniip> obviously F wouldn't be injective, because Maybe Int is both Int lifted into Maybe and Maybe Int lifted into identity
05:46:39 <ertes> Gurkenglas: criterion needs you to write functions rather than simple values (otherwise sharing will distort your results), but that has nothing to do with parameters
05:46:44 <mniip> now fmap has no way to infer from context what functor to use
05:47:06 <mniip> so you introduce a tag
05:47:22 <mniip> fmap :: Functor f => proxy f -> (a -> b) -> F f a -> F f b
05:47:24 <ertes> Gurkenglas: criterion assumes that you're benchmarking with fixed parameters
05:47:27 <mniip> and now everything is ugly
05:48:23 <Gurkenglas> ertes, so if I have an actual function I want to test, and not bother with what to give it, I also import QuickCheck, derive Arbitrary instances, and generate arbitraries to pass to benchmarks?
05:49:10 <mniip> although
05:49:11 <ertes> Gurkenglas: you could do that, but it would be more useful to pick an average/"normal" case and several edge cases
05:49:13 <mniip> :t coerce fmap
05:49:15 <lambdabot>     Could not deduce (Functor f0) arising from a use of ‘fmap’
05:49:15 <lambdabot>     from the context (Contravariant ((->) (a -> b1)))
05:49:15 <lambdabot>       bound by the inferred type of
05:49:32 <mniip> that's the wrong coerce
05:49:39 <mniip> :t Data.Coercible.coerce fmap
05:49:40 <lambdabot> Not in scope: ‘Data.Coercible.coerce’
05:49:47 <Gurkenglas> I'm trying to convince an "enemy", the less choices I make the better ^^
05:50:03 <mniip> :t Data.Coerce.coerce fmap
05:50:05 <lambdabot> (Functor f, GHC.Types.Coercible b ((a -> b1) -> f a -> f b1)) => b
05:50:41 <ertes> Gurkenglas: criterion takes a list of benchmarks…  you can generate that list randomly, but it makes your benchmarks harder to reproduce
05:51:11 <Gurkenglas> I can just use the schelling point for the seed
05:51:16 <ertes> Gurkenglas: also QuickCheck is not that helpful here…  it would be easier to use a regular random number generator library like 'random' or 'mwc-random'
05:51:58 <Gurkenglas> The argument to the function is something defined via "data", QuickCheck's Arbitrary looks made for the task?
05:52:53 <ertes> Gurkenglas: map (\x -> bench ("mybench-" ++ show x) (nf f x)) randomValues
05:53:20 <Gurkenglas> Right, where does randomValues come from
05:53:28 <kaol> Interesting.
05:54:02 <ertes> Gurkenglas: that's up to you…  example with the 'random' library:  replicateM 100 (randomRIO (-20, 20))
05:54:38 <Gurkenglas> Then the other could accuse me of choosing fitting bounds to the range.
05:54:58 <ertes> use randomIO to use the full range with bounded integer types
05:55:55 <ertes> > randoms (mkStdGen 0) :: [Word8]
05:55:58 <lambdabot>  [3,221,135,94,72,115,105,129,41,54,133,22,124,172,78,221,34,211,237,164,42,1...
05:56:01 <ertes> > randoms (mkStdGen 0) :: [Word16]
05:56:04 <lambdabot>  [64771,3805,49287,35934,39240,63859,5737,36737,9257,20534,42117,3094,36476,4...
05:56:56 <Gurkenglas> The argument is also still more than an Integer, basically reimplementing Arbitrary is more work than saying "deriving Arbitrary" and "replicateM 1000 arbitrary". But yes, your way works if you inspect what the argument type actually looks like :P
05:57:42 <ertes> as said: it's up to you…  if Arbitrary is the easier choice, go for it =)
05:58:18 <Gurkenglas> Urgh we're not even disagreeing we're just in argument mode someone say this is getting offtopic or something :D
05:58:55 <ertes> i was just giving an example with the 'random' library, because that's what i'm more familiar with
06:02:44 * hackagebot haskell-docs 4.2.7 - A program to find and display the docs and type of a name  https://hackage.haskell.org/package/haskell-docs-4.2.7 (IvanMiljenovic)
06:12:55 <yamadapc> Is there a way to take an existent quasiquoter and add variable interpolation to it without too much work?
06:19:39 <sshine> what's a good way to sort a Data.Text value?
06:19:55 <sshine> it doesn't seem to have a Seq instance.
06:27:14 <srhb> sshine: Seq instance?
06:27:57 <sshine> srhb, for Data.Sequence.sort :)
06:28:46 <srhb> sshine: I'm not familiar with a Seq typeclass.
06:30:26 <sshine> srhb, whoops. I'm not reading closely enough.
06:35:04 <srk> how long does it take for hackage to generate docs? or do I have to do it manually?
06:43:02 <Darwin226> Hey guys. Could someone familiar with wreq tell me what the best way to serialize a session is? I actually only need the cookies but I don't see a way to get them from the session
06:43:30 <lyxia> srk: several minutes at most I'd say
06:44:11 <lyxia> srk: if it doesn't then yes, consider uploading them manually
06:44:48 <srk> lyxia: any pointers how to do that?
06:46:45 <ertes> srk: here is how i do it (lines 16-41): http://hub.darcs.net/esz/skeleton/browse/Makefile
06:47:59 <ertes> (it's a nix-specific workflow, but you can easily see the individual steps)
06:49:29 <nmattia> ertes: bookmarked
06:51:12 <srk> ertes: thank you!
06:53:34 <ertes> note: someone said that the --hoogle flag is obsolete, but i have no confirmation, so i'm still using it
06:56:47 <mniip> does the category of logical propositions have a name?
06:57:06 <mniip> I mean, the thing used in curry-howard correspondence and the like
06:57:33 <srhb> mniip: OTher than types?
06:58:29 <mniip> ?
06:58:51 <quchen> Cabal also has a `upload -d` mode to upload documentation to Hackage.
06:58:59 <srhb> mniip: Derp, didn't read "category of"
06:59:03 <srhb> mniip: Sorry :)
06:59:03 <mitchty> quick question, if i have a c function that expects a void * pointer that it will use to call malloc() on and expect me to call c free after, is storable mutable the right choice or foreign ptr? I've tried both so far and don't see the pointer ever getting changed with peeks, but if I allocate a char * on the stack and point the function at that its fine, bit weird
07:04:05 <Cale> mitchty: The difference between Ptr a and ForeignPtr a is the ability to associate a finaliser to the pointer which will run when no further references to the ForeignPtr exist in the Haskell heap and stack.
07:05:55 <mitchty> Cale: sure, the issue i'm getting is less that and more anything i pass in never actually seems to get anything malloc()'d to the void * i pass in via ffi
07:07:11 <Cale> That sounds like the C library isn't doing what you expect it to do?
07:07:45 <mitchty> so i'm a bit confused as to what pointers are getting sent comprise, if i allocate a char * on the stack inside an ffi function and run the function with the same input, it does what I expect, i just can't get anything from haskell to get stuff
07:07:48 <geekosaur> or they have used a void* where they need a void** (and some random chunk of memory got changed instead...)
07:07:54 <Freundlich> mitchty: What does "call malloc on void *" mean?
07:08:16 <Cale> hah, good question
07:08:37 <mitchty> Freundlich: malloc() some memory , assign it to the void * in the function args, return an int (enum) of success or not
07:08:39 <Cale> malloc doesn't usually take a pointer as an argument
07:09:01 <Freundlich> mitchty: So the function does get a void ** as argument?
07:09:05 <Cale> It just takes a size, and produces a void *
07:10:12 <EvilMachine> Hi, I’m in over my head with HXT and arrows. All I want, is to read a few text nodes into a [String] from a HTML snipped i have as a String…
07:10:43 <EvilMachine> runX (readString [withParseHTML yes, withValidate no] ht >>> getXPathSubTrees "/table/tr[*]/td[*]/text()" >>> thisDoesntWork) htmlSnippet
07:10:59 <Cale> EvilMachine: That sounds like something which would be easier to do with tagsoup than HXT
07:11:37 <geekosaur> mitchty, perhaps you could put your (C and Haskell) code on lpaste or a gist? (gist is probably better for multiple files)
07:12:10 <EvilMachine> Cale: If tagsoup supports XPath…? Because later on, I also want to read other stuff from there. (Like a constant from an embedded javascript snippet, and some onclick values.)
07:12:39 <EvilMachine> Cale: I agree that HXT may be too much for my purposes. :)
07:12:44 <Cale> EvilMachine: It doesn't at all, it just gives you a list of tags, and you use list partitioning stuff to scrape out the bits you want
07:13:04 <Cale> If you really want XPath, then sure...
07:13:09 <mitchty> Freundlich: so i'm abusing things a bit from a python spiel but basically its this function, and was char ** rather, i'm confusing myself with other things https://github.com/dun/munge/blob/master/src/libmunge/encode.c#L62
07:13:37 <EvilMachine> Cale: This will be quite a bit of data though. which might change in structure once a year, requiring not too much work to fix it.
07:13:55 <mitchty> and i'm using inline c with basically this cMungeEncode o i l = let il = fromIntegral l in [C.exp| int { munge_encode(&$(char *o), NULL, $(char *i), $(int il)) } |]
07:14:49 <mitchty> so far inline-c has been pretty boring but this one's hit me in the face with not knowing enough about the ffi and runtime system
07:14:57 <EvilMachine> Cale: So, how do I fix runX (readString [withParseHTML yes, withValidate no] >>> getXPathSubTrees "/table/tr[*]/td[*]/text()" >>> thisDoesntWork) htmlSnippet
07:15:06 <Cale> EvilMachine: getXPathSubTrees :: String -> XmlTree -> XmlTrees
07:15:32 <Cale> Perhaps you want  getXPathTrees :: ArrowXml a => String -> a XmlTree XmlTree
07:16:01 <EvilMachine> Cale: As usual, the documentation on XmlTree is completely useless in finding out what you can do with it. Especially due to “arrow magic” being different anyway.
07:16:26 <Cale> hm?
07:16:30 <mitchty> i'll have to clean up this code a bit but mostly its not anything special to be honest, my biggest question is what i end up passing into the c function
07:16:49 <geekosaur> mitchty, that's not going to work. you are, in effect, trying to overwrite (as seen at haskell level) o with that code
07:17:00 <geekosaur> o *itself* needs to be a (char **)
07:17:06 <geekosaur> passed as such, not with &
07:17:37 <mitchty> geekosaur: so i need a Ptr Ptr CChar not Ptr CChar?
07:17:43 <geekosaur> yes
07:17:58 <mitchty> figured it was something dumb
07:18:17 <geekosaur> C is ... absolutely not helpful with this kind of thing
07:18:42 <mitchty> might explain some of what i saw though with some of my experiments
07:19:03 <mitchty> and sadly there is a lack of good examples with inline-c and some of this
07:19:32 <mitchty> but thanks geekosaur i'll give this a go
07:19:34 <EvilMachine> Cale: But what do I do with that XmlTree then? (As in: XmlTree -> [Strirng] -- String, because they are text nodes)
07:19:49 <EvilMachine> Cale: s/Strirng/String/
07:23:05 <Cale> EvilMachine: I believe the thing you want is runX
07:23:13 <Cale> https://hackage.haskell.org/package/hxt-9.3.1.15/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html
07:24:23 <Cale> EvilMachine: You're going to want to obtain an (a XmlTree String) computation for picking out the Strings that you're interested in, and then runX applied to it will get you an IO [String]
07:25:30 <sshine> when doing 'stack build' for a project that depends on text-icu, I need to add --extra-include-dirs and --extra-lib-dirs parameters to my 'stack build' command. is there a way to stuff this into the cabal file or something?
07:25:37 <lingxiao> hey all
07:25:47 <lingxiao> im getting this error information when putting Hunit in my build-depends in my .cabal file:
07:26:17 <lingxiao> http://lpaste.net/177935
07:27:00 <geekosaur> sshine, include-dirs: and extra-lib-dirs: ?
07:27:28 <EvilMachine> Cale: But the result of getXPathTrees "/table/tr[*]/td[*]/text()" is just a list, even if it sits in some stupid rose tree, isn’t it? 
07:27:45 <geekosaur> lingxiao, case independent filesystem is biting you, I think. package name is "HUnit"
07:27:47 * hackagebot xdcc 1.0.5 - A wget-like utility for retrieving files from XDCC bots on  IRC  https://hackage.haskell.org/package/xdcc-1.0.5 (JanGerlinger)
07:27:58 <geekosaur> "Hunit" will work for *some* things but not others...
07:28:39 <lingxiao> ok got it geekosaur! what do you mean work for *some* things
07:28:48 <lingxiao> you mean like i should use quickckeck?
07:28:52 <geekosaur> no
07:29:15 <geekosaur> I mean, if a program checks for the package solely by looking it up in the filesystem, "Hunit" will find HUnit
07:29:34 <geekosaur> if it checks an index structure or package list, "Hunit" will not be found because it is "HUnit"
07:29:59 <EvilMachine> Cale: tagsoup might indeed be better suited here. ^^
07:31:17 <lingxiao> ohh i see .. yeah in my case i just didnt notice the U is capitalized
07:36:22 <lingxiao> thank you all!
07:50:38 <divVerent> hpc: Thanks for the help with understanding ContT a few days ago - I now understand it well enough to actually use it and managed to reimplement reset/shift in Go for fun (in a crappy way, but not surprising)
07:51:19 <divVerent> apparently the main trick is that >>= is a binary operator in a Monad, which means that the left argument can get access to the right argument simply by defining >>= that way
07:51:43 <divVerent> the rest of ContT is type hackery to get this done without infinite types :)
07:52:13 <hpc> :D
07:52:31 <divVerent> also, I learned that Haskell doesn't have REAL continuation
07:52:55 <divVerent> i.e. even if you do get the ContT object out of its scope (e.g. doable via IORef)
07:53:03 <divVerent> calling it doesn't reset the entire control flow
07:53:25 <divVerent> it only works from within the same runContT scope
07:53:30 <hpc> yep
07:53:31 <divVerent> not surprising at all, just mentining it
07:54:12 <hpc> in that sense, ContT defines delimited continuations
07:54:12 <divVerent> of course, being a monad transformer, you could simply write your entire program in a single ContT IO scope
07:54:18 <divVerent> right
07:54:42 <hpc> and with the ability to run those actions, you can write the delimiting operators reset/shift
07:54:48 <divVerent> of course, my Go implementation of reset/shift didn't do much else
07:54:48 <hpc> it took me a while to notice that one
07:55:19 <divVerent> in fact, it's way more stupid than that, as it needlessly calls all from the reset to the shift all over again
07:55:29 <divVerent> as I didn't want to make the remaining code to run an argument of shift
07:55:42 <divVerent> it'd be the sensible thing to do, and it's done that way in Haskell but hidden by >>=
07:55:47 <divVerent> but it kinda loses the magic ;)
07:56:53 <divVerent> so yes, now I really know how delimited continuations work... essentially, shift "inserts a wrapper" in front of the following code that can call the following code more than once
07:56:56 <Cale> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> (b -> r) -> r
07:56:56 <lambdabot> f a b c = a (\ d -> b d c)
07:57:28 <divVerent> funnily, while writing the imperative implementation of it in Go, I learned why shift is called shift... because it actually shifts the first element from a list of "future return values for shift"
07:57:47 <divVerent> so it's basically splitting a list into first and rest, which Perl calls "shift"
07:57:47 * hackagebot glabrous 0.1.2.0 - A template library  https://hackage.haskell.org/package/glabrous-0.1.2.0 (MichelBoucey)
07:58:14 <divVerent> of course, in a purely functional language like Haskell, you wouldn't do that, as you have the Monad context to not have to do that
07:58:52 <jonored> Shells call it shift usually too, Perl didn't start it that :p
07:59:00 <divVerent> so I suppose I can now say - you truly understand an algorithmic concept if you can implement it both imperatively and functionally
07:59:12 <divVerent> I know, except that a shell's shift doesn't return the first arg :P
07:59:21 <lensaesonhelp> Given some simple json { "a": {"a1": 0}, "b": {"b1" 0, "b2": [{"c1": 0},{"c2":0}] }} how could I increment every value. Preferably using lens, but any solution is very welcome. I was thinking I could use traverse to do this
07:59:43 <divVerent> This oddly smells like fmap - except recursively
08:00:06 <divVerent> which JSON parser are you using?
08:00:14 <Cale> divVerent: but see: https://hackage.haskell.org/package/CC-delcont-0.2.1.0/docs/Control-Monad-CC.html
08:00:58 <mitchty> geekosaur: and working, now to bracket this so free gets called, i hate when i make stupid simple mistakes, danke
08:01:00 <divVerent> Cale: I saw that, but all this about "prompts" makes it even harder to understand :)
08:01:23 <divVerent> but yes, now that I understand how the Control.Monad.Trans.Cont one works, I can retry understanding Control.Monad.CC :)
08:02:55 <Cale> divVerent: It's kind of like internalising the kind of "purity" you get from the outside when you runCont/runContT
08:02:57 <lyxia> lensaesonhelp: maybe Control.Lens.Plated.rewrite from lens
08:04:08 <lyxia> lensaesonhelp: Control.Lens.Plated.transform, actually
08:04:29 <lensaesonhelp> lyxia: Oh, cool thanks I'll look at it.
08:04:38 <Cale> divVerent: but yeah, it's difficult to understand in a way which makes it probably dangerous to use :P
08:05:18 <lambdamu> are type families lazy?
08:05:55 <lyxia> lensaesonhelp: traverse doesn't seem appropriate because Value is not an instance of Traverse, which actually only makes sense for * -> * types.
08:06:17 <lyxia> lensaesonhelp: you can get the Plated instance from lens-aeson
08:07:07 <lensaesonhelp> lyxia: Cool. I'm going to try to figure it out myself. If I can't I'll post my failed attempts
08:16:17 <lingxiao> hey all, have a silly question
08:16:27 <hpc> we have sillly answers
08:16:31 <lingxiao> suppose I want to parse these two possible stream of texts:   ",hello"   ", hello"
08:16:40 <lingxiao> im parsing for commas
08:16:57 <lingxiao> does it make sense to say:    comma = string "," <|> string ", "
08:17:09 <lingxiao> or i should say:   string ", " <|> string ","
08:17:19 <lingxiao> or do i just not worry about the space that may come after the comma
08:17:46 <lyxia> get a comma, followed by an optional space
08:18:09 <hpc> string "," *> many space
08:18:11 <hpc> or something like that
08:19:34 <Shou> Isn't (char ',') slightly faster? In case this is Attoparsec.
08:20:34 <lingxiao> ah that makese sense
08:20:44 <lingxiao> yeah I think ill do char',' now that i know about many spaces
08:29:44 <lingxiao> it's funny when i do    p = many' space   i get a partial result on     parse p (pack "   ")  = Partial _
08:31:04 <lingxiao> i then have to pattern match on Partial g and evalate g on ""
08:31:10 <lingxiao> which seems not very ideal to me
08:34:00 <pavonia> lingxiao: Parse on p <* eof
08:34:18 <lingxiao> sorry what's eof?
08:34:28 <lingxiao> I just want to consume as many spaces as it takes to get to the next word
08:34:31 <pavonia> end of file
08:34:40 <lingxiao> so ",   foo"
08:34:47 <lingxiao> should consume , and all the spaces
08:34:51 <lingxiao> and output ", "
08:35:06 <pavonia> That should work as part of a bigger parser then
08:35:32 <pavonia> But when you are testing individual parsers, it might finish with a partial result
08:35:40 <lingxiao> ok so you're saying just do    char ',' for now ?
08:35:46 <pavonia> I thing therE's also an extra function parseOnly or so
08:35:56 <eskimod> binary parsing question: i'm trying to write an rtmp parsing library but rtmp streams have 2 levels of encapsulation. the first layer is like a fixed packet of length X bytes. the second layer is inside the first and variable length based on the header - this is the actual data. my problem is how can i parse the second layer if every X bytes i get a new interrupting header from layer 1? using the binary library
08:36:04 <pavonia> lingxiao: No, just use the parser with spaces
08:37:10 <lingxiao> whats spaces ?
08:37:24 <lingxiao> like another parser that parse the curreent token separated by spaces?
08:37:38 <lingxiao> syntax wise i want my parser in the end to look like this:
08:37:39 <pavonia> You said "I just want to consume as many spaces as it takes to get to the next word" O.o
08:38:02 <lingxiao> string "foo >> comma >> string "but not" >> string "bar"
08:38:15 <lingxiao> and all the spaces that may occur among words/tokens are taken care of
08:38:48 <lingxiao> pavonia yeah that'd be ideal, but there is no `spaces` function in attoparsec? sorry i shouldve clarified that is what im using
08:39:49 <pavonia> There's a "space" parser for an arbitrary whitespace character
08:40:19 <pavonia> or use char ' '
08:40:31 <lingxiao> yeah so i wrote many' space
08:40:35 <lingxiao> spaces = many' space
08:40:44 <pavonia> Okay, that's fine then
08:41:00 <lingxiao> but yeah like you said i have to use parseOnly to run it all the way through
08:41:29 <iphy> is there a way to pass different compiler flags in ghc 8 than in ghc <8?
08:41:31 <machinedgod> Just to add because this one bit me in the ass the other day with parsec - if you use spaces, it'll eat newlines and CRs as well!
08:41:38 <iphy> ghc 8 needs a new flag that old compilers don't have
08:41:53 <alercah> iphy: in cabal?
08:42:11 <alercah> pragmas in the source?
08:42:21 <iphy> either
08:42:29 <iphy> pragmas or cabal, whichever works
08:42:35 <alercah> in the source, you can use CPP
08:42:45 <iphy> I'll try that
08:42:56 <iphy> I didn't try it, because I thought cpp would run after parsing OPTIONS_GHC
08:43:21 <alercah> it's linear, I believe
08:43:30 <alercah> you can put the LANGUAGE CPP pragma first, then preprocessor
08:44:33 <pavonia> eskimod: Can't you just parse the individual packets with headers, and combine the result to the final value?
08:44:44 <pavonia> *results
08:48:04 <eskimod> pavonia: you mean just parse X at a time then do a second parse on the un-interupted output? how does that work?
08:48:12 <iphy> alercah: seems to work
08:49:35 <lingxiao> this throws an error?
08:49:44 <lingxiao> p = (\_ -> (pack ", ")) <$> char ',' <*> many' space  :: Parser Text
08:49:58 <lingxiao>  Couldn't match expected type ‘[Char] -> Text’ with actual type `Text`   Possible cause: ‘pack’ is applied to too many arguments
08:51:20 <lingxiao> nvm this worked p = (\_ _ -> pack $ ", ") <$> (char ',') <*> (many' space)
08:51:26 <pavonia> eskimod: Maybe I'm misunderstanding the problem, but I meant parse all the packets with the first layer parser, then you get a list of raw data or so which you combine, and run a second parser on that bytestring
08:51:37 <lingxiao> but why??
08:51:39 <lingxiao> :t (<$>)
08:51:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:51:56 <lingxiao> :t (char ',' <*> many' space)
08:51:57 <lambdabot>     Not in scope: ‘many'’
08:51:57 <lambdabot>     Perhaps you meant ‘many’ (imported from Control.Applicative)
08:52:10 <lingxiao> import Data.Attoparsec.Text
08:52:17 <lingxiao> import Data.Attoparsec.Combinator
08:52:23 <pavonia> lingxiao: You combine two parsers, so the first function should take two arguments
08:52:44 <lingxiao> yeah that makes sense .... but now im really confused about fmap
08:52:44 <lingxiao> X(
08:52:49 * hackagebot hasql-cursor-transaction 0.6 - An abstraction for simultaneous fetching from multiple PostgreSQL cursors  https://hackage.haskell.org/package/hasql-cursor-transaction-0.6 (NikitaVolkov)
08:53:03 <lingxiao> :t (<$>)
08:53:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:53:21 <lingxiao> what is `f a` in this case?
08:53:38 <c_wraith> whatever
08:53:59 <c_wraith> It's a value of some type that unifies with the type expression "f a" where f has a Functor instance
08:54:02 <eskimod> pavonia: ok so stream > parse fixed length packets > stream > parse data un-interrupted
08:54:19 <c_wraith> > (+1) <$> Just 10
08:54:21 <lambdabot>  Just 11
08:54:34 <c_wraith> > (*2) <$> [1,2,3,7]
08:54:37 <lambdabot>  [2,4,6,14]
08:55:01 <c_wraith> > show ("Hello", ())
08:55:05 <lambdabot>  "(\"Hello\",())"
08:55:10 <c_wraith> > show <$> ("Hello", ())
08:55:12 <lambdabot>  ("Hello","()")
08:55:27 <c_wraith> There, that's what I meant.
08:55:48 <lingxiao> ok so in the case here .... (\_ -> (pack ", ")) <$> char ',' <*> many' space
08:56:04 <lingxiao> sorry ... (\_ _ -> (pack ", ")) <$> char ',' <*> many' space
08:56:08 <ongy> is there a description of the core language somewhere? I found https://downloads.haskell.org/~ghc/7.6.2/docs/html/users_guide/informal-semantics.html but it doesn't explain the Str and Unf values ghc dumps with core
08:56:09 <c_wraith> It's applying the function on the left to the value returned by the parser on the right
08:56:25 <maerwald> :t (,) <$> Just 3 -- lingxiao, you get back a partially applied function, now check what <*> does
08:56:26 <lambdabot> Num a => Maybe (b -> (a, b))
08:56:43 <lingxiao> :t (<*>)
08:56:45 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:56:54 <lingxiao> does <$> have precedent over <*> ?
08:57:11 <glguy> lingxiao: You can use GHCi's :info command to learn associativities
08:57:49 * hackagebot contravariant-extras 0.3.3 - Extras for the "contravariant" package  https://hackage.haskell.org/package/contravariant-extras-0.3.3 (NikitaVolkov)
08:57:58 <lingxiao> ok theyre both infixl 4
08:58:03 <lingxiao> so same precedace
08:58:30 <pavonia> eskimod: What do you mean by the second "stream"? I thought the second layer data is already part of the first stream's data
08:58:33 <lingxiao> :t (\_ _ -> pack $ ", ") <$> (char ',')
08:58:34 <lambdabot>     Not in scope: ‘pack’
08:58:35 <lambdabot>     Perhaps you meant one of these:
08:58:35 <lambdabot>       ‘Data.ByteString.pack’ (imported from Data.ByteString),
08:58:46 <lingxiao> import Data.Text hiding (foldr)
08:58:58 <lingxiao> :t ((\_ _ -> pack $ ", ") <$> (char ','))
08:58:59 <lambdabot>     Not in scope: ‘pack’
08:58:59 <lambdabot>     Perhaps you meant one of these:
08:58:59 <lambdabot>       ‘Data.ByteString.pack’ (imported from Data.ByteString),
08:59:11 <glguy> lingxiao: You can experiment with lambdabot in /msg
08:59:22 <lingxiao> ops sorry
08:59:25 <lingxiao> didnt know about /msg
08:59:34 <lingxiao> im just doing it on my console now
09:07:50 * hackagebot preliminaries 0.1.4.0 - A larger alternative to the Prelude.  https://hackage.haskell.org/package/preliminaries-0.1.4.0 (yghor)
09:11:25 <ocramz> hullo!
09:11:31 <johnw> hi ocramz 
09:12:24 <ocramz> I just noticed that this funny syntax is legit: `asdf = let in 5`. `asdf :: Num a => a` as expected, but hlint doesn't complain about the redundancy 
09:12:35 <slack1256T> easy way to plot with hmatrix?
09:13:05 <ocramz> slack1256T : what/how do you need to plot?
09:13:36 <slack1256T> fourier transforms
09:13:59 <ocramz> then use `chart`, I guess. One for Re and one for Im
09:14:17 <ocramz> FTs in time, I guess?
09:14:17 <slack1256T> got it!
09:14:36 <nmattia> anybody here managed to use nix-build-ghc-android?
09:14:44 <slack1256T> yes, mostly to show the polar coordinate interpretation
09:17:50 * hackagebot hasql-cursor-query 0.4.1 - A declarative abstraction over PostgreSQL Cursor  https://hackage.haskell.org/package/hasql-cursor-query-0.4.1 (NikitaVolkov)
09:18:25 <ocramz> slack1256T : or go the kludgy way and call matplotlib from within iHaskell
09:18:44 <ocramz> and do share the glue code :D
09:19:45 <ocramz> Also `diagrams` can produce scientific graphs but it's a bit more abstract/low level
09:27:34 <lensaesonhelp> using lens aeson I can do myByteString ^. _Object and have an Object, but apparently it isn't plated so can' tbe used with things like transform? How do I get a plated value?
09:27:50 * hackagebot contravariant-extras 0.3.3.1 - Extras for the "contravariant" package  https://hackage.haskell.org/package/contravariant-extras-0.3.3.1 (NikitaVolkov)
09:28:58 <lyxia> lensaesonhelp: convert the bytestring to a value instead
09:28:59 <glguy> lensaesonhelp: Use _Value to get a Value 
09:29:09 <glguy> rather than _Object to get a HashMap
09:30:13 <lensaesonhelp> glguy, lyxia: Thanks! That seemed to work
09:33:58 <dot> Does there exist any other Haskell FFI libraries for languages besides C
09:36:00 <nitrix> Presumably, the other languages have an FFI for C :P
09:36:23 <dot> But is there another FFI for Java
09:36:26 <dot> or C++
09:37:19 <phadej> you can interact with C++ thru C FFI, it's not fun though.
09:37:25 <phadej> And with java thru JNI
09:37:36 <dot> What about Haskell -> C++
09:37:54 <phadej> what I just said :)
09:37:54 <jonored> The usual approach to avoid a bit of a combinatorial explosion is for both sides to talk C at each other. C is not that far from assembly, which is what the code is running as anyways.
09:38:19 <dot> ah I see
09:38:32 <nitrix> The thing is it needs to support the calling convention and the representation of the values in that other language. (ccall, stdcall are supported, and for the representation, I don't think we have other solutions than Foreign.C.Types).
09:50:03 <kadoban> dot: There is a JS FFI in GHCJS
09:50:31 <dot> oh sweet
09:50:34 <dot> lemme check it out
09:51:42 <huta> This may be off-topic for #haskell, but I have an algorithm (in haskell) that I'm having a hard time translating to a strict, imperative language (*sigh*). I'm foldr-ing over a list and the "combinging" function uses the recursive result to compute each element. I don't know how to carry over this concept in an imperative language. Any suggestions? http://lpaste.net/177966
09:52:58 <maerwald> huta: convert everything to explicit recursion. When you have done that, replace the recursion with regular loops and states.
09:53:14 <Gurkenglas_> huta, if nobody else needs to work on the code, you could compile it to javascript or C
09:53:57 <huta> Unfortunately, I can't transpile it. I'll try converting to explicit recursion
09:54:43 <Gurkenglas_> (Begs the question of whether there are any -> Haskell FFIs)
09:56:19 <Gurkenglas_> huta, this particular algorithm doesnt sound hard to translate though - shall I annotate it with Java?
09:56:34 <huta> Gurkenglas_: yes, that would be great
10:03:44 <ThePatrik> Hi. Maybe a strangely abstract formulation but: Pure memoisation can be done via lazy data. But is there a way to do it without allocating-declaring all the keys-arguments?
10:06:14 <Gurkenglas_> huta, not sure whether I got the syntax right after all this time but this should be basically correct http://lpaste.net/177966
10:06:51 <huta> Gurkenglas_: thanks, I'll give that a look
10:08:26 <lyxia> ThePatrik: A list can memoize a function Int -> a without allocating for the Int...?
10:09:27 <Gurkenglas_> ThePatrik, you mean by carrying the information about the key of a value in the value's position in memory? That can only carry an Int, and it's what Arrays do.
10:12:52 * hackagebot xdcc 1.0.6 - A wget-like utility for retrieving files from XDCC bots on  IRC  https://hackage.haskell.org/package/xdcc-1.0.6 (JanGerlinger)
10:17:20 <joe9> The Data.HashMap does not have a differenceWith function. Would this be a good implementation of it: differenceWith :: Eq k => (a -> b -> Maybe a) -> HashMap k a -> HashMap k b -> HashMap k a ; differenceWith a b = HashMap.union (HashMap.difference a b) (HashMap.intersectionWith f a b)
10:18:26 <amyers> Is anyone familiar with Turtle patterns?  I just want the greedy match, not all possible matches in a list.
10:18:51 <amyers> i.e. fmap head <normal match> gives me what I want, but seems like a dangerous cludge
10:20:40 <lyxia> joe9: do you really need the call to difference? doesn't union overwrite keys from the first map?
10:20:58 <phanimahesh> joe9: do you mean differenceWith f a b = ...
10:21:16 <joe9> phanimahesh: yes,
10:21:23 <joe9> lyxia: let me think that through.
10:21:58 <ThePatrik> Thanks, I knew I didnt say what I tried to. I meant allocating for all possible keys, or something. I'll use actual code (python): http://lpaste.net/1250529777484300288 Clearly impure like this, is there a reasonable solution for similar usage?
10:22:53 <phanimahesh> HashMap.difference a b won't work on HashMap k a, HashMap k b. You are forcing a and b to be same 
10:23:10 <phanimahesh> (type level a and b, not function params)
10:24:53 <lpaste> ertes pasted “Reflex benchmark (Newton gravity simulation)” at http://lpaste.net/177975
10:24:54 <lyxia> phanimahesh: difference allows different value types
10:25:07 <Gurkenglas> ThePatrik, why not let it allocate the space for each key only once it is needed? You can allocate for all the ints in a range immediately by using a lazy array
10:25:41 <phanimahesh> lyxia: Is that so? What will be the return type?
10:25:55 * phanimahesh goes to docs
10:26:04 <lyxia> difference :: (Eq k, Hashable k) => HashMap k v -> HashMap k w -> HashMap k v
10:28:35 <Gurkenglas> (So Reflex's MonadFix works by feeding the value at each time step into the computation at the subsequent one? But where does the initial value come from?)
10:28:36 <slack1256T> what is the easy way to have offline documentation?
10:29:08 <slack1256T> I use haddocset to generate dash's docsets but it always brokes
10:29:30 <ThePatrik> Lazy list works fine for a range of ints but I'd like it for say a tuple of ints or some big ints and some small or arbitrary strings.
10:30:39 <nitrix> I would like to know what is the general sentiment on defining (.:) in base as  f .: g = f . g x before I propose it.
10:30:47 <joe9> differenceWith f a b = HashMap.union (HashMap.difference a b) (HashMap.mapMaybe id (HashMap.intersectionWith f a b))
10:30:59 <nitrix> Possibly in Data.Function.
10:31:15 <anohigisavay> hi, how can i get value from an optional nested field with Aeson?
10:31:19 <joe9> lyxia:  but, I want something to happen when there are common keys
10:32:11 <anohigisavay> {"a": {"b": 1}}. "a" is optional, and i want to get Just 1 or Nothing
10:32:34 <nitrix> err, (.:) = (.) . (.)   or (.:) f g x = f . g x, doesn't matter.
10:33:13 <lyxia> joe9: isn't that what intersectionWith is for
10:35:01 <lyxia> joe9: ah you have to flip the union, it's the first value which is actually kept
10:35:08 <c_wraith> anohigisavay, you've found what might be the single best motivator for learning the lens library. :) 
10:35:20 <lyxia> joe9: union (mapMaybe id (intersectionWith f a b)) a
10:35:43 <lyxia> joe9: I wouldn't call it a difference though.
10:35:45 <anohigisavay> c_wraith: _(:з」∠)_
10:36:01 <c_wraith> anohigisavay, in particular, the lens-aeson library makes that really easy. 
10:36:23 <c_wraith> @hackage lens-aeson
10:36:23 <lambdabot> http://hackage.haskell.org/package/lens-aeson
10:36:38 <anohigisavay> c_wraith: i got the lens library pulled in but never touched it :D
10:36:46 <anohigisavay> c_wraith: thanks
10:37:04 <joe9> lyxia: That is what Data.Map.Strict calls it.
10:37:19 <joe9> https://hackage.haskell.org/package/containers-0.5.7.1/docs/src/Data.Map.Strict.html#differenceWith lyxia
10:37:43 <glguy> hmm, someone should update lens-aeson for 1.0.0.0
10:38:12 <lyxia> joe9: oh... okay, fine.
10:38:21 <joe9> lyxia: I need the difference :  differenceWith (\x y -> Just (x - y)) (HashMap.fromList [(5::Int,40::Int),(10,20)]) (HashMap.fromList [(2,3),(3,5),(5,20)])
10:38:40 <joe9> lyxia: http://bpaste.net/show/1459a278d9b6
10:39:10 <izohask> Hola
10:39:22 <izohask> how do you wrap your head arround definitions like this:
10:39:23 <izohask> data Parser a = NilP a| forall x . MulP (Parser (x -> a)) (Parser x)
10:39:40 <izohask> how do you "think" about such ? 
10:39:48 <izohask> what can you understand based on this ?
10:39:53 <lyxia> joe9: Pass the intersection first to union.
10:40:12 <lyxia> joe9: then you can omit the call to difference
10:40:33 <lyxia> oh wait I'm reading the docs for Lazy
10:40:35 <joe9> lyxia: That will only give the common elements. What about elements in a and not in b.
10:40:48 <lyxia> no they are the same
10:41:58 <ertes> Gurkenglas: reflex' mfix is no different from other mfixes: it's instant value feedback and relies on laziness to make it work
10:42:01 <lyxia> joe9: union (mapMaybe id (intersectionWith f a b)) a    <- if it is in a and not in b, then it is not in the first argument
10:42:10 <anohigisavay> c_wraith: does it still play well with FromJSON instance?
10:42:22 <ertes> Gurkenglas: and it can indeed blow up, if you get your causalities wrong
10:43:40 <anohigisavay> c_wraith: i'm trying to fill in a parseJSON function
10:43:58 <joe9> lyxia: I think your function above is wrong. union with a again adds back all the elements of a (which were in b, though with updated values)
10:44:13 <joe9> lyxia: can you try the example to test it out.
10:44:31 <lyxia> joe9: I refer to the docs on union: "The union of two maps. If a key occurs in both maps, the mapping from the first will be the mapping in the result."
10:44:49 <ExcaliburZero> izohask: Where did you find that definition?
10:45:07 <izohask> optoparse applicative
10:45:13 <izohask> command line parser library
10:45:31 <joe9> lyxia:  I want only the elements in a which are not in b. and, if there are common elements, use the combining function on the common elements.
10:45:41 <alunduil> 12
10:45:48 <izohask> ExcaliburZero: it is later defined this is applicative and monad etc
10:46:42 <joe9> lyxia: let me think this through. I think you are onto something.
10:46:57 <izohask> but I find it difficult to construct any data that is not really basic
10:47:57 <izohask> ExcaliburZero: Options/Applicative/Types.hs , Parser definition
10:50:39 <ExcaliburZero> Looking over the GitHub readme for optparse-applicative yields this:
10:50:40 <ExcaliburZero> "A Parser a is essentially a heterogeneous list of Options, implemented with existential types."
10:51:38 <izohask> OK... 
10:52:20 <izohask> is it now everything clear immediately ? 
10:52:27 <ExcaliburZero> Unfortunately the documentation on it doesn't seem very helpful.
10:52:45 <izohask> OK... So it is not easy to understand "how this it work" only based on type definition ? 
10:52:57 <izohask> *how does it work
10:55:05 <dmwit> izohask: Your definition doesn't make a lot of sense, but mostly because you only put part of the definition there.
10:55:16 <dmwit> izohask: There are three other constructors for `Parser a`.
10:55:51 <ricky---> is there something similar to the Data.Maybe, but lets you know where in the `>>=` chain that a failure occurred without resorting to a conditional ladder?
10:56:10 <dmwit> izohask: The most important of the ones you omitted for making sense of the thing is `OptP (Option a)`.
10:56:24 <lingxiao> hey all
10:56:33 <lingxiao> so i want to write a function that will parse any word
10:56:39 <dmwit> izohask: Then you can read the definition roughly this way: a parser either consumes nothing and immediately returns a value; or it consumes a single option before returning a value; or it's a combination of two parsers, one that feeds the other.
10:56:41 <lingxiao> my attempt:   anyWord = (\xs -> pack xs) <$> manyTill anyChar (space <|> ((const '/') <$> endOfInput))
10:56:44 <lingxiao> is too permissive
10:56:47 <kadoban> ricky---: There's 'Either e' if you want error messages. Or do you want something like it to count how many succeed or something?
10:56:53 <lingxiao> it parses space, comma and anything
10:57:01 <lingxiao> i need to parse not anyChar, but anyAlphabet
10:57:09 <lingxiao> is this thinking correct?
10:57:29 <lwm> oh, I don't need to type `let` in statement like `x = 5` in ghci 8+ anymore. Was that in a changelog anywhere?
10:57:30 <lingxiao> using letter
10:57:56 <dmwit> izohask: (Consumes nothing is `NilP`; consumes one thing is `OptP`; sequential composition is `MultP`.)
10:58:12 <ertes> ricky---: there is no way to count binds, but you can put marks around
10:58:23 <izohask> dmwit: OK... will try to go in this way then thnx
10:58:42 <lingxiao> but this version: anyWord = (\xs -> pack xs) <$> manyTill letter (space <|> ((const '/') <$> endOfInput))
10:58:42 <lingxiao> also parses leading space
10:58:46 <glguy> lwm: Yeah, the changelog is at http://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/8.0.1-notes.html
10:58:47 <ThePatrik> Is there a reasonable way to do a pure version of memoisation like this (python) http://lpaste.net/1250529777484300288 . Usable with fairly arbitrary arguments, ideally Hash arg, Eq arg?
10:59:24 <ertes> ricky---: either use Either to fail with an error value, or use MaybeT over State to modify a value as the computation progresses
10:59:44 <ertes> ricky---: note that you can't use StateT over Maybe…  you need need MaybeT over State
10:59:51 <ertes> s/need/indeed/
11:00:08 <dmwit> ThePatrik: Yes, just search "memoize" on Hackage. There's many packages.
11:02:00 <ThePatrik> Now why did I fail at searching the only keyword ... Thanks!
11:02:32 <ricky---> kadoban: not after the counts, no. Either does seem like it could fit.
11:02:42 <ricky---> ertes: right, thanks.
11:02:50 <lwm> glguy: thanks, looking over it now ...
11:03:28 <joe9> lyxia: Thanks for persisting. It makes sense now. I do not need the difference. Thanks a lot again.
11:04:01 <demize> glguy: Doesn't seem like the answer to his question is actually in the changelog though.
11:05:09 <dmwit> demize: It is. See the section on ghci.
11:05:15 <kadoban> ThePatrik: Note that you could do pretty much exactly the same thing in haskell too, using a Data.Map.Map or whatever.
11:05:21 <lwm> demize: yeah, I can't see to find it ... searching back through 7.X versions ...
11:05:28 <ertes> (optional exercise: find out why you can't count binds)
11:05:31 <dmwit> demize: "Added support for top-level function declarations (Trac #7253)"
11:05:54 <dmwit> demize: Just slightly imprecise in that it also allows top-level declarations of non-functions. =P
11:06:13 <demize> Aah, I apparently scrolled to the wrong place.
11:06:27 <demize> Well, my browser did when I clicked the sidebar link, hmm.
11:07:32 <ThePatrik> kadoban: Not keeping a (k-v) signature. I'd need to thread the map through calls.
11:07:41 <ThePatrik> (k -> v)
11:08:56 <lingxiao> hey all
11:08:56 <lingxiao> http://lpaste.net/177982
11:09:05 <lingxiao> can someone tell me why this parser ---
11:09:06 <lingxiao> ^
11:09:28 <lingxiao> is parsing any letter sequence *and* any sequence of spaces?
11:11:01 <dmwit> lingxiao: Include your imports.
11:11:16 <dmwit> What is `endOfInput`?
11:11:20 <lingxiao> updated
11:11:20 <lingxiao> http://lpaste.net/177982
11:11:23 <lingxiao> attoparsec
11:11:45 <lingxiao> id like to get rid of endofInput if possible
11:12:54 * hackagebot wai-middleware-crowd 0.1.4.2 - Middleware and utilities for using Atlassian Crowd authentication  https://hackage.haskell.org/package/wai-middleware-crowd-0.1.4.2 (MichaelSnoyman)
11:13:31 <lingxiao> really i just want to parse any word .. by word i mean some sequence of alphabet
11:14:26 <dmwit> I agree it is odd.
11:14:58 <ongy> what's the compile error "Found hole"
11:15:07 <glguy> lingxiao: letter isn't going to match space or endOfInput, so you don't need manyTill
11:15:21 <lingxiao> so i should use many1 ?
11:15:33 <lingxiao> so word = many1 letter   ?
11:15:35 <glguy> You can just do something like: many1 letter <* skipSpace
11:16:09 <lingxiao> sorry what package does skipSpace come from?
11:16:13 <glguy> and if you wanted Text at the end it is better to do: takeWhile1 isAlpha   than pack <$> many1 letter
11:16:21 <dmwit> glguy: Setting aside how the parser should be written, I think his question about how the existing parser behaves is kind of interesting.
11:17:16 <glguy> dmwit: What's an interesting input that it accepts?
11:17:27 <dmwit> glguy: " x"
11:17:38 <lingxiao> parseOnly anyWord (pack "   ")
11:17:44 <lingxiao> yeah and that one
11:17:48 <glguy> dmwit: That just matches no letters (manyTill accepts 0 matches)
11:17:56 <glguy> and then successfully matches space
11:17:57 <dmwit> glguy: Nope. It returns `" x"`.
11:18:04 <dmwit> glguy: not `""`
11:18:30 <dmwit> glguy: Okay, wait.
11:18:41 <dmwit> glguy: I was wrong, because I didn't test it, and now I'm even more confused.
11:19:44 <dmwit> glguy: Aha, I had read the outputs wrong. Now I understand what is going on.
11:33:38 <dmj> just curious, why do mutable vectors supporting streaming operations if there are no intermediate structures produced? Is it just a convenience for construction? I'm specifically referring to the 'internal operations' section in Data.Vector.Generic.Mutable module
11:37:54 * hackagebot fathead-util 0.1.0.0 - Utilities for working with DuckDuckHack's FatHead Instant Answers  https://hackage.haskell.org/package/fathead-util-0.1.0.0 (GuiltyDolphin)
11:49:38 <ulidtko> http://i.imgur.com/Y1kknHB.png
11:49:53 <Welkin> spam?
11:50:02 <Welkin> who clicks on random links on irc?
11:50:38 <mniip> I do and it's ok
11:51:43 <ulidtko> imgur is kinda well-known image site
11:51:54 <dmwit> ulidtko: For what it's worth, I think that's a terrible hint. `compare2D (x,y) (x',y') = case (x<x', y<y') of ...` seems much saner.
11:52:29 <dmwit> And "well-known image site" doesn't preclude spam the way you seem to think it does.
11:52:38 <dmwit> Then again, neither does "well-known text-paste site".
11:52:47 <ulidtko> that.
12:12:33 <dot> :t Control.Monad.>>=
12:12:34 <lambdabot> parse error on input ‘Control.Monad.>>=’
12:12:46 <dot> :t SUM
12:12:47 <lambdabot> Not in scope: data constructor ‘SUM’
12:12:53 <dot> :t :t
12:12:54 <lambdabot> parse error on input ‘:’
12:14:29 <mniip> :t (Control.Monad.>>=)
12:14:30 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:18:17 <whittle> I have a cabal file with a library section and a test-suite section. When the library is getting compiled to be tested, I would like a CPP option to be set. What’s the best way to signal to the library section that it’s being compiled as part of the test suite? 
12:19:06 <dcoutts> whittle: don't have the test-suite depend on the library, instead have it use the modules directly. Then just use cpp-options: in the test suite section.
12:19:35 <dcoutts> e.g. cpp-options: -DEXPORT_TESTS
12:21:21 <whittle> dcoutts: Do I need to list all of the libarary’s modules in the test-suite section, or just the one that consumes the CPP flag? 
12:21:56 <dcoutts> whittle: in principle every section needs to list all the modules it uses, e.g. in other-modules for the test-suite
12:22:13 <whittle> dcoutts: Got it. Thank you. 
12:33:07 <athan> Yall got any of them HList versions for GHC 8.x?
12:33:37 <athan> I have a feeling it's going to be epic
12:38:48 <ThePatrik> Is there a IO-mutable HashTable that would be available in a basic haskell installation? It's an intentionally limited environment, so can't install whatever.
12:40:06 <athan> ThePatrik: You mean an alternative to the ST hashtables?
12:41:10 <athan> NV's hashtables are awesome
12:41:12 <ThePatrik> Sure, those might be ok. Do you think they owuld be available? They're not on whatever I've installed currently.
12:41:34 <athan> They're pretty widely supported iirc, on latest distributions/stackage
12:41:35 <ThePatrik> Clumsily put, yes rather IO though.
12:41:53 <athan> ThePatrik: stToIO : ST a -> IO a :)
12:41:59 <lpaste> muesli4 pasted “Issue” at http://lpaste.net/178013
12:42:12 <muesli4> Hi, what's the issue with this ^ code?
12:42:32 <athan> but there's also `runST : (forall s. ST s a) -> a`
12:42:43 <athan> @type stToIO
12:42:45 <lambdabot> ST RealWorld a -> IO a
12:42:47 <athan> there we go
12:42:57 <muesli4> If I can pass values with all-quantified types, why can't I wrap them in lists?
12:43:11 <athan> the state threading unit (correct me?) is RealWorld in the IO case ThePatrik 
12:43:28 <Cale> muesli4: That has (what GHC calls) an impredicative type
12:43:28 <athan> muesli4: You mean like impredicative types?
12:43:42 <Cale> You can try turning on the ImpredicativeTypes language extension
12:44:21 <shachaf> ImpredicativeTypes doesn't work. You're better off treating it as impossible.
12:44:30 <Cale> But it doesn't interact so nicely with everything -- it's annoying to maintain and basically nobody uses it.
12:44:42 <Cale> yeah
12:44:48 <Cale> What shachaf said
12:44:51 <athan> Could always just use an existential type though
12:45:08 <athan> er.. can't you? :s
12:45:13 <athan> derp, an HList
12:45:14 <Cale> Not an existential
12:45:15 <deepakkapiswe> hello i am new to this place
12:45:30 <Cale> You could introduce a new data type with a rank 2 data constructor
12:45:35 <ski> `PolymorphicComponents' with `newtype Foo = MkFoo (forall a. (a, a) -> (a, a))'
12:45:54 <deepakkapiswe> can anyone make me understand what  the hell this place is ...
12:45:57 <athan> ski!
12:46:12 <Cale> deepakkapiswe: This is an IRC channel for discussion of the programming language called Haskell.
12:46:12 <ski> (`Rank2Types' or `RankNTypes' also works. slightly overkillm, though, unless you already need the extra power, which was the case here)
12:46:17 * ski looks at athan
12:46:40 <shachaf> In GHC Rank2Types and RankNTypes are the same as PolymorphicComponents.
12:46:43 <deepakkapiswe> and whom i am talking to ..... is this all public 
12:46:47 <Gurkenglas> Could one make an extension that wraps every impredicative type in a newtype automatically? Coz those are removed during compilation anyway right
12:47:00 <ski> ok. do you know when they changed it to be the same ?
12:47:08 <muesli4> Cale: Alright, I think I'll wrap it up, thanks.
12:47:36 <athan> ski: Never knew newtypes could be existential
12:47:58 <Gurkenglas> deepakkapiswe, yep people come here to talk about all things Haskell, currently 1495 people in the channel but most of them just keeping it open in the background. You can look at ircbrowse.net/browse/haskell to see all the things that have been said in here.
12:48:30 <deepakkapiswe> ohk thanks
12:48:31 <ski> deepakkapiswe : you are (potentially) talking to everyone who's currently in this channel (#haskell) (try the command `/names' to (hopefully) get a list of names of the people now in this channel. you can use e.g. `/whois ski' (&c.) to get some more info on someone)
12:48:39 <ski> athan : not existential
12:48:50 <deepakkapiswe> well I have a question about Haskell...
12:49:10 <ski> deepakkapiswe : go ahead :)
12:49:25 <ski> deepakkapiswe : and yes, this channel happens to be (publicly) logged
12:49:50 <athan> ski: How is it not existential, if you can spare the time?
12:50:35 <ski> athan : it's just a data constructor with a rank-2 type. we have `MkFoo :: (forall a. (a, a) -> (a, a)) -> Foo'
12:51:00 <athan> but how does that differ from being existential?
12:51:02 <Gurkenglas> In the interest of signal-to-noise, put code you want to show us on lpaste.net instead of copying it in if it's more than one time, and put "I have a question" lines on the same line as the question
12:51:08 <athan> iirc, haskell's existential == rank-2
12:51:44 <ski> athan : an "existential data constructor" would be something like `MkBar :: forall a. (((a,a) -> (a,a)) -> Bar)', declared by `data Bar = forall a. MkBar ((a,a) -> (a,a))' (btw, this is a silly example)
12:52:34 <ski> athan : so, an "existential data constructor" is a data constructor which is polymorphic (in this case in `a'), but where the type variable (`a' here) doesn't occur in the result type (here `Bar')
12:53:07 <ski> athan : otoh, the data constructor `MkFoo' isn't polymorphic at all (however it *requires* a polymorphic function as argument)
12:54:45 <deepakkapiswe> Hello Haskellers ....m sad today because I love Programming in functional style too much (specially Haskell) and is too much enthusiastic for learning new concepts of the same and I wanted to make a career as a Software Engineer working with Haskell. But when I came to know that there are no companies which uses Haskell or even provide jobs or internships for Freshers .... all my hope and zeal for functional language are facing
12:55:26 <ski> athan : the reason for "existential" in "existential data constructor" is because `MkBar :: forall a. (((a,a) -> (a,a)) -> Bar)' is logically (and operationally ..) equivalent to `MkBar :: (exists a. ((a,a) -> (a,a))) -> Bar', where `exists a. ((a,a) -> (a,a))' *is* an existential type (currently not possible to write directly in GHC. iirc LHC had (pretty limited) support for it)
12:56:00 <deepakkapiswe> yes I know that this is not the right place to discuss all these but I don't know anyone with whom I could share my feelings. If my words are being heard by great Programmers then I argue that how our Haskell community will grow up when new comers where not provided enough opportunities....Currently i am totally confused and want help from our big brothers ...that what should I do whether I should go for finding a job with trad
12:56:07 <ski> athan : in the case where the type variable occurs in multiple argument types, you'd have to uncurry before being able to (re)express with `exists'
12:56:52 <ski> deepakkapiswe : it seems like the end of your first message was cut off near the end of ".... all my hope and zeal for functional language are facing" -- if so, perhaps you could repeat the missing part ?
12:56:55 <ThePatrik> Allright, after having located a nicer Haskell installation i found Data.HashTable, but the module is deprecated and refers to an external package as an alternative.
12:57:25 <deepakkapiswe> yes
12:58:09 <deepakkapiswe> is there any character limit ... I cant paste my whole message once
12:59:06 <Gurkenglas> How feasible would it be to have travis build the docs hackage uses?
12:59:44 <bennofs> Gurkenglas: that is very feasible. I do it for my th-lift-instances project
12:59:52 <ski> athan : iow, if we had `data Bar1 = forall a. MkBar1 a (Int -> a -> (String,a))' which gives `MkBar1 :: forall a. (a -> (Int -> a -> (String,a)) -> Bar1), we'd first have to uncurry this as `data Bar1UC = forall a. MkBar1UC (a,Int -> a -> (String,a))' before being able to (re)express the data constructor type signature `MkBar1UC :: forall a. ((a,Int -> a -> (String,a)) -> Bar1UC)' as `MkBar1UC :: (exists a. (a,Int -> a -> (String,a))) -> Bar1UC'
13:00:15 <ski> athan : er, last bit was ".. before being able to (re)express the data constructor type signature `MkBar1UC :: forall a. ((a,Int -> a -> (String,a)) -> Bar1UC)' as `MkBar1UC :: (exists a. (a,Int -> a -> (String,a))) -> Bar1UC'"
13:00:47 <Gurkenglas> Can we add a link to a guide on how to set that up on https://hackage.haskell.org/upload so people dont have to keep having that idea themselves?
13:00:49 <ski> athan : in case it wasn't clear, i have added some brackets for emphasis and less ambiguity (to the reader)
13:01:06 <athan> ski: Ahh wow, that makes perfect sense! Sorry I keep tripping up about this
13:01:52 <deepakkapiswe> (1)-->>Hello Haskellers ....m sad today because I love Programming in functional style too much (specially Haskell) and is too much enthusiastic for learning new concepts of the same and I wanted to make a career as a Software Engineer working with Haskell. But when I came to know that there are no companies which uses Haskell or even provide jobs or internships for Freshers .... all my hope and zeal for functional language are
13:02:13 <muesli4> deepakkapiswe: I basically worked most of university with Haskell, both of my thesis have been written in Haskell. Now that I'm almost finished, I fear that I never get a job with a functional language. I guess most people using Haskell feel that way.
13:03:26 <Gurkenglas> You could try being born in a country or family where you don't have to work if you don't want to, and then work on open source projects ._.
13:03:52 <deepakkapiswe>  yes I know that this is not the right place to discuss all these but I don't know anyone with whom I could share my feelings. If my words are being heard by great Programmers then I argue that how our Haskell community will grow up when new comers where not provided enough opportunities....Currently i am totally confused and want help from our big brothers ...that what should I do whether I should go for finding a job with tra
13:04:13 <ski> athan : anyway, i don't really like the term "existential data type" because (a) consider `data A = A0 Int | A1 (forall a. [a] -> [a]) | forall a. A2 a (a -> (Integer,a))'. the `A2' data constructor is what's related to existentials, but `A0' and `A1' are not related
13:04:27 <bennofs> Gurkenglas: sorry, I don't think there is any writeup on how to do this yet
13:04:38 <ExcaliburZero> deepakkapiswe: Have you tried looking for jobs on the specifically functional programming job sites?
13:04:39 <deepakkapiswe> (3)-->>Or is there any place where freshers are also entertained ....Or if I should do some open source Project using and enhancing knowledge of functional programming and hope for getting a job in Functional field ...Even I m ready to travel long distances for it (even across countries). Only thing I want to work for what I like..Thanks in advance for any support .... hope that someone would understand my feelings. ----Deepak 
13:05:19 <ski> athan : so, "existential data constructor" is better, though really it's the argument (possibly after uncurrying) of the data constructor which (conceptually) has an existential type (a type of the shape `exists a. ..a..')
13:05:24 <Gurkenglas> If you're willing to travel to far-off places to do it, getting a Haskell job sounds workable. There aren't _no_ postings
13:05:31 <deepakkapiswe> ExcaliburZero:yes I hv looked but not found any for freshers
13:06:10 <ski> deepakkapiswe : "is there any character limit ... I cant paste my whole message once" -- yes, somewhat less than 512 characters iirc (how much less depends on the IRC server)
13:06:21 <athan> thank you ski :) I hope one day to fully appreciate your level of expertise
13:06:53 <ski> athan : just practice (doing and explaining :)
13:07:05 <deepakkapiswe> ski:thanks 
13:08:16 <ski> deepakkapiswe : fwiw, your second try for the first message, starting with "(1)-->>Hello Haskellers" got cut off a little earlier in the main text, namely after ".... all my hope and zeal for functional language are" (so there also missing "facing")
13:08:36 <ExcaliburZero> deepakkapiswe: Your best bet would probably be to try to get a development job that either uses another functional programming language (Scala is a good one for this), or works with some functional programming in non-primarily-functional languages (ex. Java8).
13:08:52 <bennofs> Gurkenglas: the code for it is at https://github.com/bennofs/th-lift-instances/blob/master/travis/script.sh#L77-L103, but it uses some of my travis helper infrastructure (the step bash function) and also uploads packages (for any tag pushed to the gh repo) or candidates (for every commit)
13:09:35 <ExcaliburZero> deepakkapiswe: Once you get a job in the field and start networking it should become a bit easier to find jobs where you can use the languages that you like to work with.
13:09:37 <ski> deepakkapiswe : and your second try for your second message, starting with " yes I know that this is not" got cut off one letter earlier ("...that what should I do whether I should go for finding a job with tra") -- why not try breaking your messages up a bit, sending a few more, but shorter ones ?
13:09:45 <bennofs> Gurkenglas: oh and https://github.com/bennofs/th-lift-instances/blob/f62eaf1aaaa1d10b5f3da229143cfe39efcaffe1/travis/script.sh#L60-L75 to generate the docs on travis
13:09:55 <ski> athan : i suppose the last bit i said was (b)
13:10:09 <ski> @hackage Haskell in industry
13:10:09 <lambdabot> http://hackage.haskell.org/package/Haskell in industry
13:10:20 <ski> deepakkapiswe : have you looked there ^ yet ?
13:10:44 <deepakkapiswe> ski: no
13:11:06 <ski> err
13:11:09 <ski> sorry, wrong link
13:11:13 <ski> @wiki Haskell in industry
13:11:13 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
13:11:19 <ski> deepakkapiswe : that one ^
13:11:47 * ski apparently got the commands confused in mind for a bit
13:13:20 <deepakkapiswe> ExcaliburZero: actually i am searching for the same but not finding any job and there is another problem with me that I know only Haskell and C language currently ...so facing a bit problem as I hv done my bachelors withs mathematics and currently doing masters in Computer science..
13:13:23 <Gurkenglas> Hmmmmmm. If travis lets opensource projects use travis for free as a public service and advertisement for their paid service, maybe we could ask them to build all the hackage docs? It could probably work with less of a wait than the current volunteering setup
13:14:25 <Welkin> just generate docs locally
13:14:27 <Welkin> problem solved
13:14:37 <Welkin> should be the default
13:14:39 <deepakkapiswe> ski: yes I hv tried that.
13:15:17 <ski> ok
13:16:42 <ExcaliburZero> deepakkapiswe: I'd definitely recommend looking into learning a bit of Scala.
13:16:43 <ExcaliburZero> It has good functional programming support, while also working well with Java, so there are more companies willing to work with it than Haskell.
13:17:08 <Gurkenglas> How much does building docs take in relation to building packages?
13:20:17 <deepakkapiswe> ExcaliburZero: ohh scala ...ok currently we have been introduced with erlang in University how about it ..
13:22:28 <Welkin> ExcaliburZero: scala sucks
13:22:33 <Welkin> it's basically java
13:22:37 <Welkin> why compromise?
13:22:41 <Welkin> very few companies use scala anyway
13:22:50 <Welkin> and joining a company because of the languages they use is a dumb idea
13:23:03 <EvanR> oh?
13:23:10 <TCZ> xd
13:23:15 <TCZ> n00bs report
13:23:18 <TCZ> -.-
13:23:20 <Welkin> if they use haskell but treat you like shit, would you join?
13:23:31 <EvanR> quite possibly yes
13:23:35 <ExcaliburZero> ExcaliburZero: I haven't heard much about Erlang being used in industry. There are definitely some companies that use it, but I haven't heard of too many that do.
13:23:45 <EvanR> because otherwise i use java and treat them like shit
13:23:54 <EvanR> which is even worse
13:24:01 <ski> deepakkapiswe : see what ExcaliburZero said above ^
13:24:19 <maerwald> ExcaliburZero: energy companies do a lot
13:25:28 <divVerent> "The general problem with Prelude seems to be that it's mispurposed: the module aims to provide things that are enough to play with Haskell as part of an introduction, as even its name suggests" - true?
13:25:45 <divVerent> I was always reading the name in the music sense - "the part before e.g. the fugue"
13:26:11 <divVerent> also explains why it's somewhat... baroque in parts :)
13:26:22 <deepakkapiswe> ExcaliburZero:ohh me too haven't heard of the same but we had to learn it and do programming as our course guides us..
13:26:25 <Gurkenglas> What's the difference? You play the prelude as an introduction x)
13:26:27 <Welkin> I find it amusing that "baroque" is used as a perjorative
13:26:34 <Welkin> when baroque music is the most beautiful of all
13:26:42 <geekosaur> the general problem with Prelude is that everyone wants it to provide things that are enough to play with what they are doing with Haskell. but Haskell has many "dialects" because a dialect is just a library.
13:26:46 <Welkin> same with baroque art
13:26:53 <divVerent> Gurkenglas: that quote seems to represent Prelude as more of a toy than anyhing to seriously use
13:27:04 <ReinH> ExcaliburZero: you haven't heard about erlang being used in industry? Seriously?
13:27:29 <divVerent> Welkin: I like baroque... but if it ain't baroque, fix it anyway
13:27:32 * geekosaur wonders if ExcaliburZero knows what the "er" in erlang stands for
13:27:40 <ReinH> Erlang has been used heavily in industry for 30 years
13:27:51 <divVerent> still Prelude certainly contains some stuff it shouldn't
13:27:53 <bennofs> geekosaur: oh what does it stand for?
13:27:55 <ReinH> If you have talked on a phone, you have probably used a system that uses erlang
13:28:02 <maerwald> yeah, it was created for practical purposes, not for research like haskell
13:28:06 <geekosaur> Ericsson, the company that developed it and still uses it heavily
13:28:07 <Welkin> Ericsson
13:28:08 <divVerent> especially some list ops shouldn't exist as they're "unexpectedly inefficient"
13:28:11 <divVerent> e.g. lookup
13:28:16 <ReinH> it is ubiquitous in telecomms
13:28:24 <Welkin> it is ugly though
13:28:32 <Welkin> and annoying to type
13:28:38 <ReinH> Welkin: you are not wrong
13:28:49 <ReinH> that's why, e.g., elixir exists
13:28:58 <Welkin> elixir is also no good
13:29:00 <Welkin> it looks like ruby
13:29:10 <ReinH> elixir is pretty good
13:29:15 <Welkin> it is for ruby people who are scared of functional languages
13:29:27 <ReinH> nah
13:29:28 <divVerent> speaking of lookup though
13:29:42 <divVerent> why is there no typeclass for maps?
13:30:06 <mniip> because it's uncategorical?
13:30:07 <divVerent> to help standardize common operations basically
13:30:36 <ReinH> There are, e.g., in lens
13:30:50 <ReinH> and in fact those typeclasses generalize far beyond maps
13:31:04 <huta> divVerent: there is https://hackage.haskell.org/package/hashtables-1.2.1.0/docs/Data-HashTable-Class.html for hashmaps
13:32:13 <EvanR> a type class for looking up something doesnt seem very useful
13:32:57 <divVerent> huta: that's a weird one
13:33:02 <divVerent> why do these maps need to live in ST?
13:33:15 <divVerent> EvanR: yes, I wouldn't actually _use_ this typeclass, that's true
13:33:28 <divVerent> it'd mainly serve for authors of Map implementations to use standard conventions for naming and arguments
13:33:54 <EvanR> well a 100 method type class also seems like it just wouldnt work
13:33:59 <wrengr> divVerent: the problem is, what should such a type class *mean*?
13:34:05 <EvanR> one or two methods would not apply and youd have java style "error undefined"
13:34:22 <divVerent> EvanR: it sure shouldn't contain ALL methods of Data.Map
13:34:26 <wrengr> i.e., some of the most important things are runtime costs of execution; but types don't capture that
13:34:35 <divVerent> as usual, some kind of core interface that can insert, delete, lookup, etc.
13:34:36 <ongy> EvanR: are you telling me, the Multiple parameter type class paper was lying?
13:34:41 <divVerent> kinda like Data.HashTable.Class, but without the ST nonsense
13:34:47 <divVerent> instead returning the newly modifed map
13:34:50 <wrengr> abstracting over runtime cost is a Bad Idea. That way lies java
13:34:51 <EvanR> ongy: about what
13:34:59 <divVerent> how does it even have a runtime cost?
13:35:04 <ongy> it uses the map class as motivation, so there seems to be some people that like the idea
13:35:12 <divVerent> I'd still use the explicit type I need in my code
13:35:21 <EvanR> a map class is ubiquitous outside haskell
13:35:31 <divVerent> but being able to automatically switch my Data.Map code to hashmaps
13:35:33 <divVerent> that'd be useful
13:35:50 <wrengr> EvanR: indeed. And it's a bad idea outside of Haskell too, imo.
13:35:53 <EvanR> divVerent: if that would even work, you can actually do that
13:35:57 <divVerent> essentially why I am getting to this
13:35:59 <EvanR> just change the import
13:36:05 <divVerent> lookup in Prelude is a horribly bad function to ever use
13:36:09 <wrengr> Lots of folks have no idea about the costs of their data structures; henc euse the same one everywhere
13:36:20 <divVerent> as it "strongly suggests" using [(a, b)] as a map type
13:36:24 <divVerent> which it is horribly bad at
13:36:32 <divVerent> but what this function's existence DOES achieve
13:36:37 <ski> wrengr : how about different module functors for different implementations with different costs associated ?
13:36:40 <divVerent> is making all other map type authors use this name
13:36:45 <geekosaur> divVerent, so, with respect to my earlier remark, consider that when the Prelude was frozen, the "dialect" of Haskell that was popular looked a lot like Lisp
13:36:48 <EvanR> wrengr: something to be said about just using an "array" or "table" without having to think about it
13:37:00 <geekosaur> and alists are rather heavily used
13:37:21 <dmwit> divVerent: Have you looked at the `keys` package? Much of it is superceded by lens, of course.
13:37:24 <dmwit> ?hackage keys
13:37:24 <lambdabot> http://hackage.haskell.org/package/keys
13:37:30 <wrengr> ski: I'd be fine with something sufficiently modular that it doesn't hide the cost model. But that gets... tricky, very quickly
13:37:33 <ski> divVerent : perhaps you'd want ML-style module signatures ?
13:37:47 <divVerent> ski: yes, maybe that
13:37:52 <divVerent> it doesn't have to be typeclasses per se
13:37:59 <geekosaur> the edison package also used to do this (for maps and a number of other collection types), but iirc had significant runtime overhead
13:38:02 <et09> so if i write a function f a b c d, can i write (in pseudocode) f _ 1 _ 2, which will return a function taking two arguments - partial application based on arbitrarily missing parameters?
13:38:14 <divVerent> especially as typeclasses typically don't make much sense in such a case, as you'd gain not much from accepting arbitrary maps
13:38:18 <wrengr> lots of languages with map interfaces/classes just use hashmaps for everything, regardless of the usage patterns. Makes /me sad
13:38:23 <divVerent> (except if your module's API uses maps)
13:38:28 <ski> wrengr : are you thinking of something that (to some degree) keeps track of costs (at least abstractly) statically ("in the types", if you will/must) ?
13:38:35 <divVerent> wrengr: how is that sad?
13:38:43 <divVerent> ordered maps have their own problems :P
13:38:51 <dmwit> et09: No (see also https://www.reddit.com/r/haskell/comments/4fqoke/thoughts_on_using_as_syntactic_sugar_for/) but you can write `\x y -> f x 1 y 2`.
13:39:01 <et09> ahh.
13:39:01 <ski> et09 : no
13:39:46 <divVerent> of course, there could be totally different solutions to the same problem
13:39:48 <jonored> I suppose there are usability problems for having a collection of typeclasses for smaller subsets of a map interface?
13:40:05 <divVerent> e.g. uploading a module on Hackage could run some kind of lint that verifies that functions with "similar looking" type signatures have the same name
13:40:17 <divVerent> and asks the uploader to confirm differences
13:40:33 <wrengr> ski: something that actually keeps track of the costs in the types would be awesome (and very tricky). But no, even just distinguishing CanAccessFrontQuickly vs CanAccessBackQuickly is crucial for sequence-like types
13:40:57 <divVerent> the problem with a general Map typeclass is that different kinds of maps have different operations, and covering every single subset of them is nontrivial
13:41:12 <mniip> divVerent, that requires the server to be able to parse the code
13:41:17 <divVerent> mniip: right
13:41:19 <divVerent> not saying it's easy
13:41:31 <wrengr> problem is, things get increasingly hard to factor apart for other more interesting structures. What are the fast classes of actions for, e.g., maps? Well, how fast do we mean?
13:41:37 <ski> et09 : the other problem is that there's no explicit delimiter. why should `f _ 1 _ 2' mean `\x y -> f x 1 y 2' rather than `(\x y -> f x 1 y) 2' or `(\y -> (\x -> f x) 1 y) 2' or `f (\x -> x) 1 (\y -> y) 2' or ...
13:41:37 <mniip> I mean
13:41:41 <ski> et09 : ?
13:41:41 <mniip> that's not always possible
13:41:47 <divVerent> wrengr: well, exactly
13:41:55 <divVerent> hash maps and tree maps have different usage patterns
13:42:01 <wrengr> It too easily heads down towards one-method-per-class, which isn't very user-friendly nor a terribly good abstraction
13:42:04 <ReinH> wrengr: that's a documentation problem, there isn't a type system that exists which can do what you suggest
13:42:07 <divVerent> and sorted array backed maps might be sometimes useful too, even
13:42:09 <ReinH> and, afaik, there can't be one either
13:42:18 <divVerent> wrengr: exactly
13:42:30 <ski> et09 : and the other problem here is that it becomes (much) harder to reason equationally with this, even if you add rules for where to add the implicit delimiter
13:42:34 <divVerent> indeed, the type system doesn't seem to be the right place to handle this
13:42:36 <et09> well this takes care of like 90% of my so-called 'metaprogramming' needs
13:42:51 <divVerent> as this is mainly about standardization of naming and calling conventions
13:43:03 <ReinH> You'll find that many haskell libraries describe the complexity of operations in the docs
13:43:06 <ReinH> containers, vector, etc
13:43:14 <wrengr> ReinH: I'm well aware there doesn't
13:43:20 <ski> wrengr : *nod*. "CanAccessFrontQuickly vs CanAccessBackQuickly" is roughly the direction i meant by "keeps track of costs (at least abstractly) statically"
13:43:24 <ReinH> it's a common practice for libraries that are concerned with performance / complexity
13:43:26 <et09> i love functions that take data and return functions
13:43:41 <Welkin> et09: weird fetish
13:43:42 <wrengr> still, that lack doesn't make the alternatives any nicer to work with
13:44:27 <ski> et09 : i'd suggest considering argument ordering more carefully, perhaps sometimes adding aliases with different ordering
13:44:32 <ReinH> Yeah, but they do have the important property of existance.
13:44:49 <dmwit> ski: Easy, any `_` becomes a fresh variable bound at the nearest `\{ }`. So your examples are, in order, `\{f _ 1 _ 2}`, `\{f _ 1 _} 2`, `\{\{f _} 1 _} 2`, `f \{_} 1 \{_} 2`.
13:44:50 <ski> et09 : and to define local helper functions when reasonable and sensible
13:44:53 <et09> perhaps 
13:45:03 <et09> not really writing the code in question yet
13:45:24 <ReinH> There are languages that do this, but I can't think of any off hand
13:45:37 <ski> dmwit : and `\{case e of P -> _}' ?
13:45:46 <divVerent> but yes. e.g. Data.Map.Lazy and Data.HashMap.Lazy don't seem to have any obvious inconsistencies in their interface
13:45:49 <dmwit> ski: `\x -> case e of P -> x`
13:45:52 * jonored thinks that once you're standardizing names, you are getting towards reinventing (weak) typeclasses but without checking. Making duckish typeclasses easier to deal with actually sounds preferable.
13:45:54 <ReinH> Or of existence, which exists.
13:46:04 <divVerent> except that quite some operations missing in HashMap could be trivially ported over from Data.Map
13:46:08 <dmwit> ski: `x` fresh, of course, not mentioned in `P`
13:46:16 <divVerent> e.g. findWithDefault
13:46:33 <dmwit> ski: (or `e`)
13:46:36 <divVerent> ideally the "magic API linter" I'm imagining could detect these and suggest adding them, too :)
13:46:46 <ski> dmwit : ok, how about `\{\{_} _ \{_}}' ?
13:47:12 <dmwit> ski: `\x -> (\y -> y) x (\z -> z)`
13:47:19 <divVerent> oh wait
13:47:25 <divVerent> findWithDefault is called lookupDefault in HashMap
13:47:44 <divVerent> exactly the kind of inconsistency I mean :)
13:48:00 <ReinH> Well, they're written by different authors
13:48:05 <divVerent> indeed
13:48:12 <divVerent> I know why this happens... but that's not how it should be
13:48:17 <ReinH> Ok
13:48:25 <wrengr> yeah, I never liked the find* names
13:48:27 <divVerent> some kind of API spec for "all maps" would be cool
13:48:31 <divVerent> and some kind of verifier
13:48:43 <divVerent> but indeed, due to invariably partial implementations, typeclasses don't fill this hole
13:48:44 <wrengr> we're looking at trying to clean things up, but backward compatibility makes things hard
13:48:46 <ski> dmwit,et09 : another problem here is nesting. now when subtituting, you'd have to be careful. e.g. how to beta-reduce `\{(\x -> \{_ x}) _}' (without desugaring this "template expression" extension" ?
13:48:50 <dmwit> divVerent: Again: use `keys` or `lens`.
13:49:04 <dmwit> ski: Why avoid desugaring?
13:49:21 <divVerent> dmwit: right, lens is a step in the right direction there
13:49:24 <dmwit> ski: Anyway, that's not a redex.
13:49:30 <ski> dmwit : to be able to reason at the level of the sugar
13:49:31 <divVerent> but if I look at lens documentation and want to see "how do I use a map with that"
13:49:37 <divVerent> really, I wouldn't find it out quickly
13:49:39 <ski> dmwit : it contains a beta-redex
13:49:49 <ski> (at least apparently)
13:49:52 <divVerent> that's of course another idea - considering Data.Map's own functions "legacy"/"internal" and documenting the access via lens instead :)
13:50:22 <dmwit> ski: Substituting always requires care.
13:50:36 <ski> with bound variables, yes
13:50:50 <ski> now we seem to need to add labels to the delimiters
13:51:25 <ski> (and to the `_'s, to determine which delimiter they correspond to. we could say that the default is the nearest enclosing, if no label is given)
13:51:48 <dmwit> Desugaring already does that. And seems perfectly reasonable to me.
13:51:53 <ski> (well, labels, or deBruijn numbering)
13:52:13 <divVerent> dmwit: BTW, of course HashMap isn't an instance of Control.Lens.At :)
13:52:29 <divVerent> but indeed, that'd be a way forward
13:52:53 <ski> i want new syntax to "behave well" with existing reductions and laws
13:53:36 <divVerent> wait, no, HashMap is At, sorry
13:53:38 <dmwit> That seems hopeless. The existing reductions and laws don't mention the new syntax.
13:53:43 <divVerent> but that weird ST-using one is not
13:54:09 <dmwit> Well. Anyway, I understand your objection, and don't value it in the same way you do.
13:54:15 <ski> they mention meta-variables which now will be able to be instantiated with phrases involving the new syntax
13:54:36 <ski> ok
13:54:46 <dmwit> It has always been possible for metavariables to range only over a subset of the syntax of a language.
13:55:03 <dmwit> e.g. it is common to say "tau is a type" and for things mentioning tau to assume that tau is not suddenly a term.
13:55:13 <dmwit> So our term language would have different syntactic categories. Nothing new there.
13:55:51 <geekosaur> divVerent, the only thing Data.HashTable is suited for is the trash bin. Don't even bother trying to fit it into a reasonable API
13:56:16 <geekosaur> it's a highly unfortunate piece of history
13:58:00 <ski> dmwit : hm. i'd prefer to think of it as the metatype of `tau' as being distinct from the metatype of `e'. unless you specifically had suptyping for the metatypes (the syntactic categories) in mind
13:58:36 <ggVGc> checks #haskell, within 5 seconds reads "subtyping for the metatypes"
13:58:43 <ski> (.. and i don't really see how "our term language would have different syntactic categories" would be relevant here. (i took it for granted))
13:58:44 <ggVGc> only in #haskell
13:59:33 <wrengr> I'm not sure that calling them "metatypes" helps any
13:59:47 <dmwit> ski: I'm not sure I understood your complaint yet. So my proposal is: we now have metavariables for "terms that can contain holes" and metavariables for "terms that do not contain holes". Beta reduction uses the "no-holes" metavariable on the right-hand side.
13:59:48 <wrengr> sure, syntactic categories form a type system
13:59:49 <ggVGc> I'm not sure what a metatype is
14:00:13 <wrengr> and sure, (Church-style) type systems just form a syntactic grammar
14:00:55 <wrengr> but I don't know that we need any extra terminology to talk about that connection
14:02:10 <wrengr> e.g., Curry-style type systems are not transparently just a grammar; does it help to call the syntactic category of the type expressions their "metatype"?
14:02:36 <ski> dmwit : oh, i didn't follow that you were proposing metavariables for "terms that can contain holes". why would you do that ?
14:02:53 <dmwit> Or perhaps beta reduction simply isn't allowed inside `\{ }`. That wouldn't be unprecedented, either. I admit I hadn't tried to build a metatheory for terms with holes.
14:03:46 <shachaf> I never metatheory for terms with holes I didn't like.
14:04:08 <ski> ggVGc : in this context, just a type at the meta level. iow when defining abstract data types for a language, we'd perhaps define (meta)types `Expr' (expressions), `Decl' (declarations), `Pat' (patterns), `Comm' (commands), `Type' ((object-level) types)
14:05:07 <ski> wrengr : i suppose i used the word "metatype" since we were mentioning "metavariables"
14:05:36 <dmwit> ski: Why wouldn't I do that? Since holes are not always a valid syntax, it seems natural to want to be able to talk about the "can/can't have a hole here" distinction.
14:05:39 <wrengr> if that's all you mean, then that's fine :)
14:05:50 * ski wouldn't really think of this as "terms with holes" (which i'd consider to be something different)
14:06:09 <dmwit> I'm happy to pick a name other than "hole" for `_`.
14:06:28 <dmwit> How about "terms with _". ;-)
14:06:57 * ski doesn't really care that much about the name used, as long as we don't mix it up with that other thing (unless that's intended)
14:07:55 <wrengr> "terms with that-other-thing"
14:08:42 <ski> "Since holes are not always a valid syntax," makes me think of how quasiquotation in e.g. Scheme (or MetaML/MetaOCaml) is handled. we have a syntactic category `expr-n' for every natural number `n', unquotation is only included for positive `n'
14:09:37 <wrengr> ski: have you looked at how MetaML does staged metaprogramming? type-theory-wise I mean
14:11:01 * ski playfully feeds wrengr through <http://www.lisperati.com/landoflisp/f060.png>
14:11:27 <ski> wrengr : do you mean as related to some modal logic system ?
14:11:45 <ski> wrengr : i've read the papers on MetaML, years ago, if that's what you mean
14:12:35 <wrengr> They have a rather nice way of dealing with types of holes (at least for the variety of holes/metavariables they allow)
14:13:18 <wrengr> alas, that got dropped in newer incarnations of the quasiquoting stuff (e.g., TH)
14:13:27 <ski> yes, you can analyze/inspect their code values, and, iirc, use L-lambda matching
14:13:35 * wrengr forgets whether MetaOCaml kept it around
14:13:44 <ski> i don't recall whether .. what wrengr just said
14:13:53 <Shou> Does the constraint arrow (=>) have precedence? Operators on the LHS seem to require parentheses.
14:14:01 * ski has mostly played with MetaML
14:14:28 <ski> Shou : presumably
14:14:41 <jle`> Shou: it might jus be syntax, but it's super low and right-associative
14:15:28 <jle`> ah, hadn't thought about operators on the lhs.  i presume it's testable then
14:15:29 <ski> wrengr : have you seen lambdaProlog ? (or Lolli ?)
14:15:55 <wrengr> yeah. It's been a few years since I've looked in detail though
14:16:07 <ski> wrengr : did you see the paper on "MacroML", iirc using ideas from MetaML ?
14:16:25 <wrengr> don't think so
14:18:19 <Shou> jle`: it's a bit odd. Even infix 9 operators result in errors. I'm assuming => is just a syntax thing right now.
14:18:25 <alercah> it is
14:18:43 <jle`> Shou: => seems to be higher than any operator i try to use on the lhs, can you give an example?
14:18:45 <jle`> s/higher/lower
14:20:01 <ski> wrengr : "Macros as multi-stage computations: type-safe, generative, binding macros in MacroML" by Steve Ganz,Amr Sabry,Walid Taha in 2001 at <https://www.cs.indiana.edu/~sabry/papers/macroml.pdf>
14:20:24 <Shou> jle`: type (c <+> a) = c a; let f :: Show <+> a => a -> String; f = show
14:20:29 <ski> wrengr : also i was reminded of "An Extension to ML to Handle Bound Variables" by Dale Miller in 1990 at <http://www.lix.polytechnique.fr/Labo/Dale.Miller/papers/mll.pdf> (cf. lambdaProlog)
14:21:47 <jle`> Shou: seems to parse fine for me
14:22:22 <ski> wrengr : for the former, it helps to know a little about macros in the lisps (preferably of the hygienic kind, so Scheme then)
14:23:16 <teurastaja> ski: macros are just about the only thing i dont use in scheme
14:25:19 <teurastaja> i prefer continuations or lazy evaluation but i didnt follow the conversation
14:25:20 <ski> have you used continuations (possibly delimited ones) for anything interesting ?
14:25:46 <Shou> jle`: that's odd. Any language extensions that could be accepting it maybe?
14:25:54 <teurastaja> me? yeah
14:26:07 <wrengr> ski: this looks... familiar. Have you seen the stuff on ABTs? in particular, languages like JonPRL which provide them directly as part of the host language?
14:26:07 <jle`> Shou: i think you only need TypeOperators and PolyKinds
14:26:11 <jle`> what error are you getting?
14:26:19 <ski> macros can be nice when you want/need to make a new DSL (not EDSL), especially if it has non- trivial/standard binding structure
14:26:24 <Shou> jle`: "parse error on input ‘=>’"
14:26:26 <jle`> well you don't even need PolyKinds if you use ConstraintKinds + KindSignatures
14:26:35 <jle`> but PolyKinds makes it a bit simpler
14:26:38 <teurastaja> ski: then i define structure types
14:27:01 <jle`> Shou: hm, maybe put the type synonym and the function declaration on separate lines?
14:27:05 <teurastaja> dont know about kinds though
14:27:33 <teurastaja> its something i should study i guess
14:28:23 <ski> (e.g. a new syntactic category of patterns for a pattern-matcher. or a loop clause specification language for an advanced looping macro (see "The anatomy of a loop: a story of scope and control" by Olin Shivers in 2005-09, and <https://mumble.net/~campbell/scheme/foof-loop.txt> by Riastradh))
14:28:49 <jle`> for the most part i just treat it as lower-than-low precedence and infixr
14:28:57 <ski> teurastaja : structure types for continuations ?
14:29:17 <ski> teurastaja : and what do you mean by "structure types" ?
14:29:17 <teurastaja> ski: no but you could if you wanted
14:29:33 <ski> (teurastaja : when i said "hygienic kind", i didn't mean "kind" in the Haskell sense)
14:29:46 <teurastaja> ski: (quote define-structure-type)
14:30:17 <ski> teurastaja : whence "structure types", then ?
14:30:49 <ski> wrengr : "ABT" ? i haven't heard about "JonPRL"
14:30:49 <teurastaja> if you want to create non-trivial bindings, structures are nice
14:31:12 <ski> is that in Racket or ?
14:31:23 <teurastaja> just standard 7 of scheme
14:31:31 <teurastaja> R7RS
14:31:35 <wrengr> ski: ABT = abstract binding trees. It's a CMU thing, though some of us are trying to sell them more broadly
14:31:50 <ski> ok, i haven't kept track of all the latest updates on R⁷RS
14:32:23 <teurastaja> ski: according to me, its saving the language, making it portable
14:32:29 <ski> wrengr : short elaboration / pointers ?
14:32:38 <wrengr> JonPRL is a variant of NuPRL which just exposes the ABT stuff to users directly. Thus, users can define things like \Pi for themselves rather than relying on special syntax or macros
14:33:04 <ski> wrengr : is it related to HOAS ?
14:33:17 * ski guesses that it is
14:33:18 <teurastaja> i tend to avoid macros they can break easily
14:33:24 <wrengr> related only in as much as both are solutions to the same sort of problem
14:33:31 <Welkin> teurastaja: c macros? or lisp macros?
14:33:53 <teurastaja> welkin: both
14:34:01 <ski> teurastaja : which kind of breakage are you thinking of ? perhaps you're thinking about code-walking macros ? (another (obvious) disadvantage is that you can't pass them around dynamically)
14:34:29 <wrengr> ski: I talk a little bit about our particular variant of them in Hakaru, here: http://winterkoninkje.dreamwidth.org/103978.html
14:34:52 <ski> wrengr : ty
14:35:08 <wrengr> ski: I've been told that's not terribly readable for anyone who doesn't already know what's going on; but Neelk's discussions are quite nice
14:35:19 <wrengr> I link to neelk's two posts in the first para
14:35:50 <wrengr> me, neel, and jon are the three folks I'm aware of trying to get ABTs to be more widely known
14:36:43 <wrengr> ski: I've changed my blog's theme since writing that post, so let me know if the code hilighting is broken anywhere
14:37:19 <wrengr> I've been meaning to write a followup which more clearly goes through the stuff we're doing in Hakaru, but that's on the back burner now
14:37:55 <Shou> jle`: It seems to work now, just not in GHCi.
14:38:11 <Shou> Probably missing an extension
14:38:36 <wrengr> in particular, ccshan wants me to write it as a paper submission rather than as a blog post or doccumentation writeup; I agree, but am focused on dissertating at the moment
14:38:52 <jle`> Shou: hm, it might be that you can't declare type synonyms and term-level functions on the same line
14:39:21 <Shou> Oh, I just contracted that for IRC
14:41:35 <teurastaja> ski: im not an expert in macros but they tend to be a source of bugs
14:46:29 <ski> wrengr : ok
14:47:11 <ski> teurastaja : should i look in small or large ?
14:48:12 <teurastaja> teurastaja: the one thats finished
14:48:18 <teurastaja> oope
14:48:23 <teurastaja> ski: 
14:49:28 <teurastaja> http://trac.sacrideo.us/wg/raw-attachment/wiki/WikiStart/r7rs.pdf
14:50:03 <teurastaja> CRTL-f define-structure-type
14:51:20 <mettekou> Is anyone else here on the beta of macOS 10.12? There seems to be an issue with GHC 7.10.2, 7.10.3, and 8.0.1 (so possibly all earlier versions as well) on it. Building yesod-auth or stack causes GHC to panic reporting "malformed mach-o: load commands size".
15:00:31 <ski> teurastaja : ok, small
15:00:41 <pikajude> christ, i hope they haven't changed the mach-o format
15:01:03 <pikajude> mettekou: I'll have an opportunity to try 10.12 later this week, if you're still having the issue I can help debug it
15:01:14 <pikajude> I happened to be messing around with mach-o files earlier this week so I have a little background
15:04:46 <ski> teurastaja : hm, not found. i assume you didn't mean `define-record-type' ?
15:05:13 <teurastaja> yes
15:06:02 <lambdafan> is there a way to read a config file at runtime to generate a sum type?
15:07:25 <ski> teurastaja : if you meant record types, then i don't see how your "then i define structure types" was relating to what i said earlier (presumably "macros can be nice when you want/need to make a new DSL (not EDSL), especially if it has non- trivial/standard binding structure" ?)
15:07:39 <geekosaur> they change the mach-o format with pretty much every major os release
15:09:13 <lambdafan> so like I have a config, maybe in a db says (Foo Bar Baz Bin), and at runtime I can turn that into a sum type data Foo = Bar | Baz | Bin
15:09:21 <ReinH> lambdafan: no, types don't even exist at runtime.
15:09:52 <ski> (perhaps if something like TH could be run at run-time ..)
15:10:01 <mettekou> geekosaur: So the issue has been dealt with before a few times?
15:11:02 <geekosaur> mettekou, yes. one difficulty is that it's hard to get detail about what changed without signing an NDA, before the public release (not beta)
15:16:02 <glguy> mettekou: I don't use Yesod, but I have been using GHC 8.0.1 for development on the latest beta macOS
15:16:02 <glguy> (and I haven't had mach-o issues)
15:20:42 <mettekou> glguy: You don't use Stack either?
15:21:14 <geekosaur> I'd be surprised if this is stack's fault
15:23:22 <Welkin> beta macos?
15:23:28 <glguy> mettekou: I usually avoid it, but I have used it and it has worked there, too
15:24:45 <mettekou> geekosaur: It probably isn't, but stack and yesod-auth are the only libraries I know to suffer from the problem when built with GHC 7.10.2-8.0.1 on macOS 10.12.
15:25:10 <Welkin> 10.12?
15:25:11 <mettekou> Packages, not libraries, my bad.
15:25:13 <Welkin> I'm on 10.10
15:25:24 <glguy> Welkin: Then you probably won't be able to help with this issue :-p
15:25:40 <pikajude> wait. they change the mach-o format every release?
15:25:42 <pikajude> that can't be right
15:25:49 <glguy> pikajude: It probably isn't right
15:25:57 <glguy> At most they add extra load commands
15:26:03 <pikajude> oh, that's probably it then.
15:29:43 <glguy> mettekou: I was able to build my IRC client using 1.1.2 in that environment. Maybe you could post a minimal test-case that doesn't work somewhere
15:29:52 <glguy> using stack-1.1.2* in that
15:30:25 <mettekou> I was trying to create a minimal example to reproduce https://ghc.haskell.org/trac/ghc/ticket/12198 and https://ghc.haskell.org/trac/ghc/ticket/12479 by looking at common modules imported by the affected modules from stack and yesod-auth.
15:30:30 <mettekou> No luck, though.
15:33:03 * hackagebot aeson-injector 1.0.5.1 - Injecting fields into aeson values  https://hackage.haskell.org/package/aeson-injector-1.0.5.1 (NCrashed)
15:44:29 <buglebudabey> i just want to say, you guys are the most helpful channel out there
15:44:36 <buglebudabey> beginner friendly and patient
15:44:39 <buglebudabey> top notch
15:46:20 <Gurkenglas> I have a "glut32.dll" in both my System32 and SysWOW64 folders, but gloss-made programs still crash with "user error (unknown GLUT entry glutInit)". What do I do? (I think I put it into SysWOW64 manually a week or so ago, and I don't remember where the one in System32 comes from)
15:47:18 <hpc> Gurkenglas: are you using the platform?
15:47:39 <Gurkenglas> Nah stack
15:47:47 <Gurkenglas> (Assuming you mean Haskell Platform)
15:47:49 <hpc> ah, you might need to install something
15:48:06 <hpc> the haskell platform comes with a bunch of stuff, and it ends up that gloss "just works"
15:48:16 <hpc> and that bunch of stuff includes some opengl stuff
15:48:29 <hpc> (among mingw, msys32, etc)
15:48:30 <Gurkenglas> Make stack install it when it's told to install gloss :D
15:48:46 <hpc> tell me about it
15:48:49 <Welkin> Gurkenglas: why on earth are you still using windows?
15:48:58 <hpc> i had a similar issue with sdl2
15:48:58 <Gurkenglas> Because terminals hate me
15:49:30 <sm> Gurkenglas: how about putting it in your current directory
15:50:35 <Gurkenglas> sm, same error
15:50:53 <sm> maybe https://www.google.com/search?q=%22user+error+(unknown+GLUT+entry+glutInit)%22+windows+haskell has a solution
15:58:04 * hackagebot dbm 0.1.0.1 - A *simple* database migration tool.  https://hackage.haskell.org/package/dbm-0.1.0.1 (RickyElrod)
16:00:24 <Phyx-> Gurkenglas: where'd you get the dll from?
16:01:47 <Gurkenglas> Phyx-, dunno. Somewhere on the internet. Probably one of the first google results
16:02:14 <Gurkenglas> I went by the info gloss.ouroborus.net gave me :D
16:02:27 <sm> what could possibly go wrong :)
16:03:04 * hackagebot werewolf 1.5.1.0 - A game engine for playing werewolf within an arbitrary chat client  https://hackage.haskell.org/package/werewolf-1.5.1.0 (hjwylde)
16:03:44 <baordog> Anyone know anything like topcoder for haskell?
16:04:40 <Phyx-> Gurkenglas: heh. 
16:04:54 <Phyx-> I wanted to verify if the dll actually exports this symbol.
16:05:50 <Gurkenglas> Here you can have it and see for yourself? http://www.filedropper.com/glut32_1
16:09:42 <Phyx-> right, so it has it. 
16:09:57 <Phyx-> so compiling works fine but running it fails?
16:10:33 <Phyx-> what's ghc --version say?
16:13:05 * hackagebot werewolf 1.5.1.1 - A game engine for playing werewolf within an arbitrary chat client  https://hackage.haskell.org/package/werewolf-1.5.1.1 (hjwylde)
16:13:07 * hackagebot dbm 0.1.1.0 - A *simple* database migration tool.  https://hackage.haskell.org/package/dbm-0.1.1.0 (RickyElrod)
16:13:38 <Phyx-> Gurkenglas: ?
16:15:15 <Gurkenglas> Phyx-, 7.10.3
16:16:12 <koz_> What Haskell library do you folks recommend for working with an SQLite database? There seem to be a lot of them, and I dunno which one is best.
16:16:29 <Welkin> koz_: Persistent
16:16:36 <Welkin> the best sql library
16:16:52 <Phyx-> Gurkenglas: sorry, i meant the arch, is it a 64bit or 32bit ghc? that dll is 32bit so you'll need to produce a 32bit exe to be able to load it
16:17:13 <Phyx-> Gurkenglas: if you don't know, try "ghc --info | findstr arch"
16:17:36 <Gurkenglas> (Prepending stack exec -- to everything)
16:17:58 <koz_> Welkin: Thanks - I will look at it!
16:18:01 <Gurkenglas> Phyx-,  ,("target arch","ArchX86_64")
16:18:05 * hackagebot werewolf-slack 1.0.2.0 - A chat interface for playing werewolf in Slack  https://hackage.haskell.org/package/werewolf-slack-1.0.2.0 (hjwylde)
16:18:41 <Phyx-> Gurkenglas: right, you'll need a 64bit version of glut then, I suspect the error is a bit cryptic because they're manually calling LoadLibrary somewhere and that's failing
16:18:52 <Gurkenglas> Phyx-, you mean I need a glut64.dll? I assumed since gloss.ouroborus.net only named glut32.dll, the 64 version would also be called glut32.dll for... compatibility reasons or something
16:20:19 <Phyx-> Gurkenglas: could be.., but the dll you gave me is definitely 32bit though
16:20:52 <Phyx-> >dumpbin /headers r:\glut32.dll | findstr machine 14C machine (x86)
16:21:04 <Phyx-> wow, it ate the newline lol
16:21:15 <Phyx-> \>dumpbin /headers r:\glut32.dll | findstr machine
16:21:15 <Phyx-> 14C machine (x86)
16:21:18 <Phyx-> better
16:21:18 <Gurkenglas> Oh hey this is where I got the file http://www.dlldll.com/glut32.dll_download.html
16:22:14 <Gurkenglas> Eating newlines in a chat client sounds like a feature
16:22:16 <Phyx-> yeah.. that's a bit fishy. I'd just go with the freeglut version
16:22:19 <Phyx-> http://freeglut.sourceforge.net/
16:24:24 <Phyx-> just download the MingW variant of the binaries and rename the freeglut.dll to whatever it's especting
16:34:48 <Gurkenglas> Not tested on Win 10 :D
16:36:01 <Gurkenglas> (and sure why not, renaming the freeglut.dll to the glut32.dll, I shoulda thought of that, and why not just rename some other .dll on my system to that :D)
16:37:35 <Gurkenglas> Still the same error with the originally-named-freeglut.dll in the same folder. Do I need to remove the glut32.dlls from SysWOW64?
16:37:44 <Gurkenglas> *and System32
16:40:14 <Phyx-> the one in the same folder as the exe should take precidence. 
16:41:35 <Phyx-> I assume you're trying to run one of the flass examples?
16:42:38 <Gurkenglas> Nah an executable whose .hs just worked on another machine in another part of the country when I did "stack dragger.hs"
16:43:17 <Gurkenglas> Lemme regenerate the output of trying that on here
16:43:37 <Gurkenglas> (That one is also Windows, of course.)
16:44:18 <Gurkenglas> http://lpaste.net/2553829662060969984 I think on the other machine it installed the required packages automatically?
16:45:05 <Gurkenglas> Updated http://lpaste.net/2553829662060969984 right this made me think if I make a project for it maybe itll figure out the right versions to use
16:46:25 <Phyx-> yeah, seems like some packages are missing. when do you get that error if you can't compile?
16:47:45 <Phyx-> just that freeglut dll is not enough btw
16:47:54 <Phyx-> it has a dependency on two other dlls
16:48:12 <Phyx-> OPENGL32.dll and  GLU32.dll
16:49:23 <Phyx-> well, the freeglut one only on OPENGL32.dll so that should be fine
16:50:09 <Phyx-> stack has msys2 doesn't it? if you can run msys2 command somehow run, strace <exe you're trying to load>
16:50:14 <Phyx-> should tell you what's going on
16:50:24 <Gurkenglas> At some point it compiled on this machine, I have an executable
16:50:30 <Koterpillar> does strace work on windows?
16:50:40 <Phyx-> Koterpillar: on msys2 yes
16:51:01 <JuanDaugherty> is that the new post 10 MS dev env?
16:51:18 <JuanDaugherty> runs on unix/linux?
16:51:35 <Gurkenglas> No such .dll files in freeglut-MinGW-3.0.0-1.mp.zip
16:52:20 <Gurkenglas> Yeah rumpus requires me to install msys2 hold on
16:52:37 <Phyx-> no, msys2 is a completely unrelated project. msys2 provides a shell to the mingw-w64 tools, which are tools to produce native windows binaries from posix compliant source
16:52:45 <JuanDaugherty> not. A mingw cyqwin pkging apparently
16:52:54 <JuanDaugherty> *cygwin
16:52:54 <Gurkenglas> Ya I already installed msys2 back then I mean
16:53:09 <Phyx-> Gurkenglas: then run strace on the exe
16:53:33 <Gurkenglas> That fails at the part where I navigate to the right folder, msys2 seems to be running in some alternate folder universe
16:54:03 <Phyx-> JuanDaugherty: the biggest difference between cygwin and msys2 is that msys2 allows the production of native binaries instead of emulated posix ones like cygwin.
16:54:07 <Gurkenglas> I think this is kinda what it looks like on linux? http://lpaste.net/4418499149662519296
16:54:46 <Phyx-> Gurkenglas: quote the paths, then the shell will convert the windows paths
16:55:22 <Phyx-> Otherwise, msys2 paths are normalized to unix path format, so c:\foo\ becomes /c/foo
16:55:42 <Gurkenglas> http://lpaste.net/1453078622687461376
16:58:46 <Phyx-> agr, could you send me that exe?
17:00:29 <Gurkenglas> k. it's a simple game, controlled by lmb and rmb. You start it by calling it with a filename, itll use that as a savefile
17:00:41 <Gurkenglas> (uploading)
17:02:09 <Phyx-> alright :)
17:05:14 <Gurkenglas> (Oh hey look at that stack exec ghc-pkg check output http://lpaste.net/856105355686445056 )
17:05:53 <Phyx-> yeah, that's the reason you can't compile it now, shouldn't affect the binary though
17:06:32 <Phyx-> don't know enough about to stack to help with that part..
17:06:36 <Phyx-> upload finished?
17:07:26 <Gurkenglas> http://en.file-upload.net/download-11858659/dragger.exe.html
17:08:50 <JuanDaugherty> Phyx-, ah thx, good to know
17:12:29 <Phyx-> Gurkenglas: that works  fine here
17:12:57 <Gurkenglas> ( https://gyazo.com/3ca287d0ade923a3415f0aa2d7785984 seeing lotsa bs ^^)
17:14:20 <Phyx-> you piped the console output to a file, what you're seeing is the control character that is used to reset the cursor
17:14:31 <Phyx-> normally you would see all that on one line
17:16:31 <Gurkenglas> http://lpaste.net/6891951161658572800
17:16:55 <Phyx-> Gurkenglas: do you have C:\Windows\System32\opengl32.dll and C:\Windows\System32\glu32.dll on your system?
17:16:59 <Gurkenglas> (Some library made its major version bounds too large?)
17:18:26 <Phyx-> It looks like that package was made for a different version of cabal
17:18:32 <whacked> sup haskell
17:18:34 <Gurkenglas> Yup theres one of each in System32 and SysWOW64
17:18:34 <whacked> can i blog here?
17:19:08 <Gurkenglas> No one will throw sand at you if you link to a haskell related blogpost here
17:19:25 <Phyx-> i find it odd that strace doesn't show anything for you..
17:19:33 <whacked> If I append all my IRC blogs with - haskell, is it on topic?
17:19:50 <whacked> What if I write my blogs in haskell
17:20:09 <Gurkenglas> What's an IRC blog? And if we could define "related" exactly we would have general AI right
17:20:11 <johnw> we're not a satisfying channel to troll
17:20:34 --- mode: ChanServ set +o dmwit
17:20:34 <Gurkenglas> he isn't that is
17:20:41 <EvanR> omg im so mad at trolls, better?
17:20:51 --- mode: ChanServ set +o johnw
17:21:07 <dmwit> Further questions about what is on-topic may be directed to a channel where those questions are on-topic.
17:21:14 <Gurkenglas> aww I remember when trolls were converted instead of banned
17:21:25 <dmwit> Nobody has been banned yet.
17:21:40 <Gurkenglas> this isn't the path to conversion!
17:21:53 <lingxiao> hey all
17:21:53 --- mode: johnw set -o johnw
17:22:15 <lingxiao> suppose i want to parse a sentence like "foo bar"
17:22:31 <lingxiao> but it may have many spaces before foo and bar, but at least one space between foo and bar
17:22:34 <lingxiao> so "   foo bar"
17:22:44 <lingxiao> or "foo     bar"  or "   foo   bar   "
17:22:55 --- mode: dmwit set -o dmwit
17:23:19 <lingxiao> what's a good way to break these down into parsers?
17:23:33 <lingxiao> ideally I like to say:       foobar = pFoo <*> pBar
17:23:42 <dmwit> manySepBy (many letter) (many space) -- ?
17:23:59 <EvanR> put many space after each parser
17:23:59 <shachaf> Gurkenglas: Please direct comments about channel moderation to #haskell-ops
17:24:16 <lingxiao> dmwit yeah so I'd like a `word` primitive that consumes all the spaces until it reaches a word, and try to parse the word
17:24:22 <Koterpillar> lingxiao: congratulations, you've discovered a side effect of *parsec to failing to differentiate between tokenization and parsing
17:24:41 <EvanR> no consume space at the end of each parser
17:24:44 <whacked> is there a haskell library for sending email?
17:24:44 <lingxiao> sepBy is not so good here ...
17:24:58 <lingxiao> Koterpillar using attoparsec but is it the same flaw?
17:25:12 <Phyx-> Gurkenglas: have to go to bed, 1.30am. If you truelly want to get this working and stop guessing, then you can install the Debugging tools for windows https://msdn.microsoft.com/en-us/library/windows/hardware/ff551063(v=vs.85).aspx , run gflags and enable loader snaps for the image. https://blogs.msdn.microsoft.com/junfeng/2006/11/20/debugging-loadlibrary-failures/ then attach a debugger, and you'll be able to see the windows loader's reasons for not loading 
17:25:14 <whacked> i would like to write a functional mailer
17:25:16 <lingxiao> EvanR ok so you're saying only:   consume as many space as possible >> consume word
17:25:19 <Koterpillar> lingxiao: if its interface is [Char] -> Parser a, then yes
17:25:21 <lingxiao> but after that don't consume string
17:25:30 <dmwit> whacked: http://hackage.haskell.org/packages/search?terms=email
17:25:33 <Gurkenglas> :t (,) <$ spaces <*> string "foo" <* many1 Text.Parsec.space <*> string "bar" <* spaces -- lingxiao, using Text.Parsec
17:25:34 <Phyx-> Gurkenglas: it works here so must be something related to your system, that would tell you what's wrong
17:25:35 <lambdabot> Stream s m Char => ParsecT s u m (String, String)
17:25:56 <lingxiao> Gurkenglas ok I'll play with that and get back to you guys
17:26:02 <Koterpillar> lingxiao: what you want is [Token] -> Parser a, where Token = Whitespace | Word Text | ...
17:26:21 <lingxiao> yeah Korterpillar very approrpriate because eventually i need to port a tokenziation library over to haskell
17:26:29 <lingxiao> so I'll have many questions in the comming weeks
17:26:56 <Koterpillar> lingxiao: AFAIK *parsec are generalized over the stream element type
17:27:09 <dmwit> lingxiao: When using Parsec in the past, I have occasionally defined a function `token` which consumed spaces at the beginning and end of another parser. e.g. `token p = spaces *> p <* spaces`.
17:27:13 <dmwit> It's often handy.
17:27:26 <lingxiao> ok yeah that's what im looking for
17:27:41 <lingxiao> where spaces is 0 or more spaces right?
17:27:48 <dmwit> Generally you want to decide on one side or the other and have all your tokens consume spaces on that side, though.
17:27:52 <lingxiao> this way i can chain parsers as if they're a sentence and not worried about it
17:27:53 <Gurkenglas> http://hayoo.fh-wedel.de/?query=spaces yep
17:28:05 <lingxiao> dmwit ok so maybe i should pick front size just to be safe
17:28:09 <dmwit> lingxiao: Depends on what your grammar is, of course.
17:28:14 <lingxiao> so    word p = spaces *> p
17:28:18 <lingxiao> what do you mean grammar?
17:28:36 <dmwit> I mean, whether you should consume 0+ spaces or 1+ spaces depends on the grammar you are trying to parse.
17:28:42 <dmwit> There's no library-level answer to that question.
17:28:55 <Koterpillar> lingxiao: proper tokenization beats this if you want to parse things like "foo,bar", for example
17:29:05 <dmwit> You... have written down the grammar you want to parse, right? =P
17:29:28 <dmwit> And yes, tokenization is often an excellent idea.
17:29:38 <lingxiao> dmwit no haha...
17:29:54 <lingxiao> im parsing arbitrary english phrasese
17:30:07 <lingxiao> what grammar should i use?
17:30:17 <Koterpillar> lingxiao: what about punctuation?
17:30:20 <dmwit> I'm not sure that the usual parser libraries are very good for NLP.
17:30:36 <Gurkenglas> I've heard https://hackage.haskell.org/package/gf does that
17:30:48 <lingxiao> yeah ... im searchig for specfic occurenrances of speficif phrases though
17:31:10 <lingxiao> oh wow very interesting Gurkenglas iv never heard of that 
17:31:24 <lingxiao> ok for tonight im in get sh*t done mode so i'll stick iwth out with parsing
17:31:31 <lingxiao> then i'll play with PGF 
17:36:11 <lingxiao> ok dmwit this makes no sense:    word w = spaces *> string w
17:36:34 <Koterpillar> :t \w -> spaces *> string w
17:36:36 <lambdabot> Stream s m Char => String -> ParsecT s u m String
17:36:37 <lingxiao>  parse (word "hello") (pack "world")      --->   Done "world" "hello"
17:36:56 <lingxiao> sorry,  word :: String -> Parser Text
17:37:02 <lingxiao> from Attoparsec
17:37:36 <lingxiao> dmwit Korterpillar  bascially it's succeding on any given string
17:38:34 <lingxiao> ok nevermind ... thats weird i reloaded and the problem went away
17:38:41 <lingxiao> even though i reloaded multiple time already
17:54:49 <joe9> Is  Data.IntMap ordered?
17:55:57 <EvanR> if you ask for the contents it comes out in some order
17:58:01 <jchia> joe9: toAscList gives you the items in ascending order of key, if that's what you want
17:58:09 <ski> @type Data.IntMap.toAscList
17:58:10 <lambdabot> Data.IntMap.IntMap a -> [(Data.IntSet.Key, a)]
17:58:12 <ski> @type Data.IntMap.toDescList
17:58:13 <lambdabot> Data.IntMap.IntMap a -> [(Data.IntSet.Key, a)]
17:58:15 <ski> > IM.empty > IM.empty
17:58:16 <lambdabot>  False
17:59:03 <EvanR> how is it comparing IM.emptys with no type specified
17:59:20 <ski> defaulting
17:59:28 <joe9> Ski, EvanR jchia, Thanks.
17:59:44 <EvanR> > [] < []
17:59:48 <lambdabot>  False
17:59:57 <Koterpillar> > IM.singleton 1 id > IM.singleton 1 id
17:59:58 <lambdabot>      No instance for (Ord (a0 -> a0))
17:59:59 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
17:59:59 <lambdabot>        arising from a use of ‘>’
18:00:04 <Koterpillar> sanity restored
18:00:12 <ski> @where L.hs
18:00:12 <lambdabot> what lambdabot has in scope is at http://silicon.int-e.eu/lambdabot/State/Pristine.hs
18:00:26 <ski> lists `()' in a `default' declaration, iirc
18:00:27 <geekosaur> it's just ExtendedDefaultRules... which basically means () is the final fallback
18:04:47 <mniip> ski, but that's Pristine, not L
18:04:52 <mniip> misleading name :v
18:05:14 <ski> apparently int-e has changed the name
18:05:16 <malabaris> si quieres ganar mirando anuncios mira esto: 12https://www.facebook.com/malabarista72/
18:05:25 <ski> (or maybe someone before them)
18:05:33 <mniip> @let data Test
18:05:34 <lambdabot>  Defined.
18:05:54 <mniip> nope
18:06:41 <ski> malabaris : if you're looking for a spanish-speaking Haskell channel, try #haskell.es
18:07:17 <mniip> I don't think they are
18:07:33 <ski> `let' declarations didn't reflect themselves at the `L.hs' address ever, afaicr
18:07:48 * ski was doubting it as well, but just in case ..
18:07:54 <mniip> um
18:07:57 <malabaris> 4[ski4] is for all person take money looking advertisement
18:07:57 <mniip> let goes into L.hs
18:08:03 <mniip> undefine cats Pristine into L
18:08:10 <EvanR> hmm #haskell.es seems dead
18:08:16 --- mode: ChanServ set +q *!*@222.red-88-19-26.staticip.rima-tde.net
18:08:30 <mniip> it should be #haskell-es anyway :)
18:08:40 <ski> doesn't exist (i already checked)
18:10:33 <ski> mniip : perhaps that's the case now. afair, that wasn't the case earlier
18:10:52 <mniip> I mean it should be because of how channel names work
18:11:13 <peddie> EvanR, malabaris: yes, #haskell.es is pretty dead :/  but there've been conversations there, it should be OK to ask
18:12:33 --- mode: ChanServ set -q *!*@222.red-88-19-26.staticip.rima-tde.net
18:13:41 <Gurkenglas> Phyx-, btw http://lpaste.net/6891951161658572800 was unrelated to what we were doing I switched up channels and neither of noticed
18:35:05 <archaephyrryx> i am having some weird issues with TH 2.11
18:36:20 <archaephyrryx> does anyone know about the interface for that version
18:36:25 <archaephyrryx> because it seems a bit off
18:38:15 <Gurkenglas> Generally people don't like to answer that until they've seen enough to offer some insight
18:38:29 <archaephyrryx> specifically
18:38:44 <archaephyrryx> i am having trouble understanding the notation for type constraints
18:38:49 <archaephyrryx> and also
18:39:03 <archaephyrryx> the Show method for type constraints seems to be 2.9-based
18:39:23 <archaephyrryx> in that it refers to "ClassP", which is in 2.9 but not 2.11
18:39:39 <archaephyrryx> @paste
18:39:39 <lambdabot> Haskell pastebin: http://lpaste.net/
18:40:47 <lpaste> archaephyrryx pasted “TH-2.11” at http://lpaste.net/178051
18:41:20 <archaephyrryx> this is specifically with 2.11
18:41:31 <archaephyrryx> and I checked, but 'ClassP' is not in scope
18:42:19 <archaephyrryx> can anyone confirm this issue, or is it just pollution from my haskell package installs
18:42:28 <archaephyrryx> als
18:42:31 <archaephyrryx> also
18:42:49 <archaephyrryx> trying to run a certain module with 2.11 in ghci caused a SEGFAULT
18:43:34 <archaephyrryx> but that's something weird
18:44:39 <archaephyrryx> when I run 'cabal repl'
18:44:48 <archaephyrryx> I get 'Bad interface file: /usr/local/haskell/ghc-7.8.3-x86_64/lib/ghc-7.8.3/template-haskell-2.9.0.0/Language/Haskell/TH.dyn_hi         Something is amiss; requested module  template-haskell-2.9.0.0:Language.Haskell.TH differs from name found in the interface file template-haskell:Language.Haskell.TH'
18:45:23 <archaephyrryx> anyone have any insight?
18:45:29 <glguy> archaephyrryx: http://hackage.haskell.org/package/template-haskell-2.11.0.0/docs/Language-Haskell-TH.html#t:Pred
18:46:24 <cromonbat> Hi all, I can't seem to find foldl' in prelude, is foldl' now the default foldl?
18:46:45 <glguy> no, foldl' still isn't in the prelude
18:47:03 <cromonbat> ah, so it has to be imported.. I see
18:48:47 <lingxiao> hey all
18:48:55 <lingxiao> i havea  problem with the way my word parser is dfeined
18:48:56 <mniip> archaephyrryx, looks like you might have broken .hi/.hs-boot files
18:49:21 <lingxiao> word w = spaces *> string (pack w)  :: String -> Parser Text
18:49:34 <lingxiao> right now parse (word "hello") (pack "helloooo") will output "hello"
18:50:25 <lingxiao> I cant quite do word w = spaces *> string (pack w) *> (many1' space)  since the word might be the en of input
18:51:00 <glguy> lingxiao: this is why it's a good idea to use a lexer before you parse
18:51:42 <lingxiao> oh boy ... i thought i could skip it
18:51:53 <lingxiao> right now my input is of form ["foo", "00"]
18:51:56 <lingxiao> so it's very restricted ..
18:52:10 <lingxiao> actually "foo" could be ":" or "23a;"  or anything really
18:52:30 <lingxiao> but my setting is very limited for tonight
18:52:55 <Koterpillar> lingxiao: append a space to your input all the time
18:53:02 <nitrix> Whoever recommended me `fold` yesterday and reminded me of Monoids indirectely prompted me to do a refactor that went really deep down the rabbit hole.
18:53:21 <nitrix> It's now, so, so much more readable and neat. Thank you so much :]
18:53:30 <Gurkenglas> Show me the codebase! I wanna see
18:53:41 <Koterpillar> lingxiao: do you actually have a Partial match with that "hello"?
18:53:50 <lingxiao> yup
18:54:11 <lingxiao> Koterpillar lingxiao: append a space to your input all the time,   oh boy i guessed i asked for a hacky solution
18:54:37 <Koterpillar> lingxiao: do you have a Partial match there? Are you using the function I suggested earlier?
18:54:41 <glguy> lingxiao: If you didn't want to match the literal sequence of characters, but wanted to take a word and then consider which word you got,
18:54:58 <glguy> then you should parse out a whole word and make a decision based on which one you got
18:55:01 <Koterpillar> it's not a hacky solution, it's often used in parsers, state machines and such
18:55:06 <lingxiao> Koterpillar sorry what was the one you suggested ...
18:55:20 <lingxiao> this is mine:   word w = spaces *> string (pack w)
18:55:26 <Koterpillar> lingxiao: case parse ... of Partial f -> f ""; Done _ r -> r 
18:55:56 <Koterpillar> lingxiao: maybe it's not Partial but something else, forgot the constructor name
18:55:56 <glguy> If you're never use the Partial cases, you can use parseOnly :: Parser a -> Data.Text.Internal.Text -> Either String a
18:56:06 <lingxiao> Korterpillar wait that doesnt output a parser though
18:56:18 <lingxiao> I need word to be String -> Parser Text
18:56:41 <glguy> lingxiao: That's find, you'll build that out of something that parses any word and test which word you got
18:56:44 <lingxiao> oh interesting i didnt know it is actually often used .. i guess it makese sense .. parsing is a very dirty job
18:56:45 <glguy> That's fine*
18:57:12 <lingxiao> yeah im testing with parseOnly actually
18:57:31 <lingxiao> parseOnly (word "hello") (pack "hellooo")   ----> Right "hello"
18:58:07 <lingxiao> the reason i dont want to consume a space after the word is because i picked in the beginning to consume zero or more spaces  *before* the word
18:58:45 <Koterpillar> with that decision, you'll have to tuck something at the end of your parser
18:59:13 <Koterpillar> that parses endOfInput and spaces before it
18:59:19 <Koterpillar> (whatever it is called)
18:59:59 <mniip> hmm
19:00:06 <lingxiao> yeah endOfInput .. that might be the way to go
19:00:16 <lingxiao> so i can either parse for endOfInput or peak for space ..
19:00:36 <lingxiao> oh boy, but then i really have to peak for commas ... etc ... but not numbers
19:00:42 <lingxiao> hello, is ok.   hello12 is not
19:00:43 <Koterpillar> peek?
19:00:46 <lingxiao> peek*
19:00:56 <lingxiao> pinacle for space 
19:02:31 <mniip> int-e, you around?
19:04:51 <mniip> hrmph
19:05:01 <mniip> I found a slight flaw in yoctoparsec
19:07:41 <ReinH> lingxiao: You might want to look at the token parsers in the parsers library
19:07:55 <lingxiao> you might be right ..
19:08:01 <lingxiao> im looking for ways around it but ..
19:08:19 <ReinH> token parsers consume whitespace with the tokens, so they may be similar to what you want
19:08:35 <lingxiao> i feel like there has to be a clver way around it
19:08:35 <ReinH> and there are a variety of combinators to choose from that work with most parsing libraries
19:08:40 <lingxiao> i want to match hello, not helloooo
19:09:02 <ReinH> That requires lookahead or backtracking
19:09:11 <lingxiao> i was thinking i can peak ahead on character and have that parser fail if it sees an alphabet or 1..9
19:09:14 <lingxiao> yup ...
19:09:54 <lingxiao> but im having a little trouble expressing it ..
19:10:04 <lingxiao> i have inClass :: String -> Char -> Bool
19:10:27 <lingxiao> peakChar' :: Parser Char
19:10:30 <ReinH> so something like: word "hello" <* lookahead (noneOf ['A'..'z'])
19:10:50 <ReinH> or alphaNum or whatever parser you want
19:11:12 <lingxiao> where does noneOf come from?
19:11:52 <lingxiao> https://hackage.haskell.org/package/attoparsec-0.13.0.2/docs/Data-Attoparsec-Text.html
19:11:59 <lingxiao> im here ---^ and dont seem to find any
19:14:10 <Gurkenglas> http://hayoo.fh-wedel.de/?query=noneOf
19:14:41 <Gurkenglas> "As the dual of oneOf" aaaaaaaaaaaaaaaa
19:18:10 * hackagebot canteven-parsedate 1.0.1.2 - Date / time parsing utilities that try to guess the date / time format.  https://hackage.haskell.org/package/canteven-parsedate-1.0.1.2 (taphu)
19:18:56 <nitrix> Gurkenglas: Nothing fancy yet: https://github.com/nitrix/lspace
19:19:55 <ReinH> lingxiao: are you using attoparsec?
19:21:42 <lingxiao> yup
19:21:52 <lingxiao> nothing in combinators or attoparsec.text
19:29:48 <Gurkenglas> nitrix, is the again-lookup of gameCamera . cameraWindowSize deliberate as it mighta changed?
19:29:59 <lingxiao> does anyone else know the comparable thing of noneOf in attoparsec?
19:30:52 <Gurkenglas> The one in Renderer.hs:150, meant to append that
19:31:11 <nitrix> Gurkenglas: An accident after a refactoring with a TODO ugly note.
19:31:25 <nitrix> It'll get memoized anyway :P
19:31:49 <lingxiao> for conduit, does anyone know how much overhead is consumed for opening 100 files of x size each, or 10 files of 10x sized each
19:32:14 <lingxiao> and traverse over all files in both casese
19:32:32 <nitrix> Gurkenglas: The renderer is the worst piece, but I've been through really nice stuff. Core and Game, where you can embed Game in Core, for one.
19:33:35 <nitrix> Gurkenglas: Both are monad transformers stacks, but Core has a MonadIO instance, while Game only lets you do a handful of carefully selected IOs.
19:33:50 <lingxiao> im traversing over all files in a directory, opening them, split them into lines, and filtering using some small parser
19:34:00 <nitrix> Gurkenglas: Then there's Link, which is going to become a library and I've discussed many times on #haskell-game. That thing is awesome.
19:34:00 <lingxiao> the parser is consuming strings whose length is < 100 characters
19:34:19 <lingxiao> im watching my RAM go from 300 mb free to now 45mb, and dropping
19:34:40 <Gurkenglas> nitrix, if you do it carefully you can make Game an actual subtype of core, as in specialized, or did you already mean that
19:35:27 <nitrix> Gurkenglas: They're the same type, I just wanted different set of operations on them :/
19:35:48 <nitrix> Well, "same type", they're still newtypes.
19:37:19 <Gurkenglas> As in "type Game = Monad m => StateT S m a", "type Core = StateT S IO a"
19:37:36 <Gurkenglas> The same sort of trickery ekmett does in lens
19:38:28 <nitrix> I might go towards that.
19:38:53 <nitrix> Gurkenglas: Ultimately, the object system will also be really cool with dedicated modules for each object. I found a way to have them become Automatas, with message passing. Once I have multiplayer, it'll just be a matter of broadcasting the messages. There's a nifty trick where you can trap a state in them if you define their constructor as a function that's tying a knot. You're able to get all objects into
19:38:56 <nitrix> a single Object type, and yet, they'd be stateful and react on the messages.
19:39:11 <nitrix> I already had a prototype but scraped it during a gigantic refactor of the Link module :P Link is a amazing :P
19:39:25 <nitrix> Gurkenglas: Want to take this to #haskell-game ?
19:39:32 <Gurkenglas> k
19:39:32 <archaephyrryx> there don't seem to be any examples of how to use Pred, as it is just an alias for Typoe
19:39:32 <benzrf> > 3
19:39:34 <lambdabot>  3
19:39:35 <archaephyrryx> *type
19:40:41 * ski idly wonders where Gurkenglas would like to bind `m',`a'
19:41:02 <Gurkenglas> Umm, remove the a of course. The m is bound in the Monad m => part
19:41:34 <Gurkenglas> Like the f in Lens s t a b = Functor f => (a -> f b) -> s -> f t
19:42:04 <mniip> archaephyrryx, in the past, there were two types of contexts
19:42:11 <mniip> TyClass tv1 tv2 tv3
19:42:16 <mniip> and (a ~ b(
19:42:22 <mniip> (a ~ b)
19:42:31 * ski thinks an explicit `forall' ought to be mandatory in such places
19:42:37 <mniip> nowadays ~ is not so special and is kinda a typeclass too
19:42:49 <mniip> or is it a tyfam?
19:44:53 <Gurkenglas> It might be, Im not sure that syntax was correct, but isnt that forall in that place the only interpretation that would make sense?
19:47:32 <Gurkenglas> :t Data.Attoparsec.Text.satisfy . flip notElem -- <lingxiao> does anyone else know the comparable thing of noneOf in attoparsec?
19:47:33 <lambdabot> Foldable t => t Char -> attoparsec-0.13.0.1:Data.Attoparsec.Text.Internal.Parser Char
19:52:56 <archaephyrryx> mniip: still having trouble with a concrete example of how to use the new TH API
19:53:11 <archaephyrryx> mniip: and the Show method still seems polluted with 2.9
19:54:54 <glguy> archaephyrryx: You use Pred the same way you use Type
19:57:24 <ski> Gurkenglas : not in case local `type',`data',`newtype' declarations ever get allowed .. or module parameters
20:17:44 <archaephyrryx> glguy: Don't know how to formulate a constraint though
20:18:15 <glguy> apply Show to whatever it is you wanted to constrain
20:21:00 <khumba> I tried writing a function that takes a list of parameters, f :: IsParam p => [p] -> ... (with IsParam instances for two data types Param and Type), but then passing the empty list is ambiguously typed.  At least, I'd like to be able to pass a [Type] and an empty list without adornment.
20:21:08 <khumba> Is there something obvious I'm missing?  GHC extensions are acceptable.
20:23:17 * ski idly wonders whether `...' mentions `p'
20:24:08 <khumba> No, I'm just leaving off the remaining parameters.
20:25:35 <khumba> I also tried "class IsParamList a; data ParamList = P [Param]; instance IsParamList [Type]; instance IsParamList ParamList" but GHC still didn't like the empty list.
20:25:49 <khumba> f :: IsParamList p => p -> ...
20:25:54 <grantwu> Can someone explain the functional dependency part of https://www.stackage.org/haddock/nightly-2016-08-15/megaparsec-5.0.1/Text-Megaparsec-Prim.html#t:MonadParsec
20:26:02 <ski> perhaps you could try adding `default Type' to the module where you'd like to pass an empty list
20:26:12 <grantwu> I read through https://wiki.haskell.org/Functional_dependency and I understand the first example
20:26:20 <whacked> any haskell programmers in here
20:26:34 <ReinH> grantwu: a b | a -> b says that a uniquely determines b, i.e., that there can only be one instance for each choice of a.
20:26:37 <whacked> is there a way to implement tor support into a haskell program
20:26:57 <grantwu> ReinH: Right, but what does it mean to have m -> e s ?
20:27:06 <ReinH> that m uniquely determines e and s
20:27:07 <grantwu> Does m uniquely determine e AND s?
20:27:09 <grantwu> ok
20:27:11 <ski> grantwu : yes
20:27:17 <grantwu> I guess that makes sense
20:27:20 <mniip> m -> e, m -> s
20:27:21 <whacked> I want to create a stand-alone binary
20:27:26 <whacked> for Windows operating systems
20:27:34 <whacked> that can connect to hidden serivce
20:27:46 <whacked> +a
20:28:06 <mniip> tor support?
20:28:10 <whacked> yea
20:28:12 <mniip> you mean socks5 proxy support?
20:28:21 <whacked> No, it has to be a totally standalone binary
20:28:30 <khumba> ski: thanks for the idea, it doesn't seem to do anything (tried [Type] too).  Better defaulting rules *are* what I'd like here though; I saw the proposals but didn't see that anything had been done.
20:28:33 <ski> grantwu : it logically means `forall m. unique e s. MonadParsec e s m', which is equivalent to `forall m e0 e1 s0 s1. (MonadParsec e0 s0 m,MonadParsec e1 s1 m) => (e0 = e1 /\ s0 = s1)'
20:28:42 <mniip> that sounds suboptimal
20:28:46 <ReinH> How does a program support Tor?
20:29:00 <whacked> mniip: far from it. in fact, it's optimal if things are this way
20:29:04 <whacked> binary size needs to be small too
20:29:24 <mniip> >binary size needs to be small
20:29:26 <mniip> wrong language
20:29:31 <glguy> probably needs to be fast, too.
20:29:52 <anohigisavay> hi. i have a class `class Resource res` and a function `uri :: res -> URI` not until i have written several instances did i realize i need to add IO to this function
20:30:09 <ski> anohigisavay : then do so
20:30:23 <ReinH> (hint: it's by supporting a SOCKS proxy)
20:30:36 <anohigisavay> so as to avoid changing much existing code i added a default uri implementation uri = undefined and add another function uriIO = return . uri
20:30:37 <whacked> https://github.com/wbenny/mini-tor
20:30:39 <whacked> i found this...
20:30:52 <mniip> ReinH, I presume they're doing something shady that wouldn't let them have a regular tor setup running alongside
20:30:58 <mniip> like normal people would do
20:31:09 <ski> anohigisavay : alternatively, perhaps you can return a description of I/O to do later (by making new constructors for `URI') .. though i doubt that this is what you want here
20:32:13 <anohigisavay> ski: URI comes from an external library...
20:32:18 * ski nods
20:32:50 <anohigisavay> ski: 80% of all instances don't need IO
20:33:13 <ski> ok
20:34:34 <anohigisavay> doesn't look so appealing with lots of returns as in uri = return "a/b/c"
20:34:40 <ski> one variant might be to make a new class, `ResourceIO', which is a subclass of `Resource', and which has `uriIO'
20:35:36 <anohigisavay> ski: but then the problem is instances need to provide a dummy uri implementation?
20:35:54 <anohigisavay> still doesn't get rid of `uri = undefined`
20:36:27 <ReinH> sounds like uri and uriIO are two separate concerns
20:37:34 <anohigisavay> i conceive the instance provides either of those
20:38:02 <anohigisavay> but not like regular mutual definitions of classes because uriIO doesn't depend on uri
20:38:25 <anohigisavay> sorry, uri doesn't depend on uriIO
20:38:26 <ski> as ReinH indicated, you haven't really told us much about how you're intending to use (and are already using) `uri', and also this new `uriIO'
20:39:14 <archaephyrryx> glguy : Show doesn't work, as I have mentioned
20:39:15 <anohigisavay> ok let me prepare some code
20:39:44 <archaephyrryx> glguy: http://lpaste.net/178051
20:40:19 <glguy> archaephyrryx: What's the error message?
20:42:31 <ski> (i was first thinking of `ResourceIO' as a *super*class of `Resource'. on second thought, perhaps that's more sensible anyway, since to be able to compute an `URI' without I/O seems to be stronger (require more) than to compute it possibly using I/O. the former satisfied by fewer types than the latter. using <http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generic-defaults>, i think one could add `uriIO = return . uri' as a 
20:42:47 <ski> (er, cut off near ".., i think one could add `uriIO = return . uri' as a default in the superclass, used in case the subclass is also made an instance)")
20:43:26 <anohigisavay> http://lpaste.net/178066
20:44:22 <ski> btw, `uri = undefined' as a default is pretty useless
20:45:48 <anohigisavay> ski: really? the compiler complains that an instance has no implementation for uri no?
20:46:03 <glguy> archaephyrryx: You have two problems 1) you're trying to apply a kind signature, so you got an error message that you needed to turn on that extension
20:46:19 <glguy> archaephyrryx: 2) your type was wrong that you were annotating that lambda with
20:47:39 <ski> anohigisavay : surely that's better than getting no warning ?
20:48:04 <anohigisavay> ski: ahh thought was a compile error xD
20:48:17 <glguy> archaephyrryx: When you add :: Constraint to   Show a :: Constraint you need KindSignatures
20:48:29 <ski> anohigisavay : `catch' is from `Control.Exception', yes ?
20:48:58 <anohigisavay> ski: yes i'm using MonadThrow so it's a reexport from Control.Exception to Control.Monad.Catch
20:49:17 <ski> @type Control.Exception.catch
20:49:18 <ski> @type Control.Monad.Catch.catch
20:49:18 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
20:49:19 <lambdabot> (Exception e, Control.Monad.Catch.MonadCatch m) => m a -> (e -> m a) -> m a
20:49:36 <anohigisavay> _(:з」∠)_ well not a re-export i'm wrong
20:49:51 <ski>   return a `catch` handle  =  return a
20:50:31 <lpaste> glguy annotated “TH-2.11” with “TH-2.11 (annotation)” at http://lpaste.net/178051#a178069
20:50:36 <ski> hm, or is that parsed as enclosing the whole `do'-expression ?
20:51:45 <ski> (yes, i suppose it must be, or the following `where' would be a syntax error)
20:55:23 <ski> is `uri' and `uriIO' only used in (those default implementations of) `uriIO' and `get_' ?
20:57:28 <immersion> @pl \x y -> pure (++) <*> x <*> y
20:57:28 <lambdabot> (<*>) . (pure (++) <*>)
20:57:50 <glguy> immersion: You can play with lambdabot in /msg
20:58:50 <anohigisavay> ski: sorry was away for a moment
20:58:59 <immersion> Like this? /msg @pl ...
20:59:09 <glguy> immersion: /msg lambdabot @pl ...
20:59:15 <immersion> Thanks
20:59:39 <anohigisavay> ski: yes that's the only place they are used
21:00:52 <grantwu> Sorry if this is a dumb question, but why are typeclass methods named they way they are?
21:01:13 <grantwu> Like, method makes me think of function
21:01:18 <grantwu> but they don't have to always be function values
21:18:37 <jle`> maybe it's linked to how classes/objects have methods in OOP
21:18:47 <jle`> despite being unrelated to typeclasses
21:20:52 <grantwu> Never mind, I had it explained to me
21:38:10 <jle`> well now i'll never know :(
21:53:17 <joe9> does anyone have a sample usage of fast-logger?
22:06:59 <orion> Hi. In a WAI Application, I want to have a different set of HTTP routes depending on the value of the Accept header. Is it possible to use Middleware for this purpose?
22:08:03 <Axman6> sure, you could easily start with something like: middlewareChoice :: (Request -> Bool) -> Application -> Application -> Application
22:08:27 <Axman6> there might be better ways using a proper framework though - it should be doable with Servant AFAICT
22:08:39 <orion> I am already using Scotty.
22:10:26 <orion> The problem though is that my Middleware definition looks like this: fooMiddleware app req sendResponse = do ...
22:11:22 <orion> Within that Middleware I do the following: app req $ λres -> do ... sendResponse res
22:11:55 <Axman6> what's the problem there?
22:12:10 <orion> Axman6: I don't understand what will happen to the `app` variable.
22:12:17 <orion> Do I just throw it out?
22:14:01 <Axman6> with the above, it'd look like middlewareChoice myPred alternativeApp normalApp = \req sendResp -> if myPred req then alternativeApp req sendResp else normalApp req sendResp
22:14:33 <orion> Ah, I see.
22:15:57 <Axman6> that implementation might actually work
22:17:02 <orion> I might want to generalize it for more than two Applications too.
22:17:22 <Axman6> yeah
22:17:45 <orion> This has been very helpful, thank you Axman6.
23:03:17 * hackagebot mars 0.1.0.0 - Generates mountainous terrain using a random walk algorithm.  https://hackage.haskell.org/package/mars-0.1.0.0 (infrared)
