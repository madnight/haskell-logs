00:10:11 <ocramz> hullo!
00:10:27 <Axman6> Hu!
00:11:50 <ocramz> is anyone here familiar with `diagrams`? What's the incantation for drawing a list of segments (pairs of endpoints in 2D space)? 
00:12:33 <ocramz> I'm getting a bit lost with the typeclass hierarchy 
00:12:41 <ocramz> do I need a Located?
00:13:50 <shachaf> You might ask in #diagrams.
00:14:19 <ocramz> shachaf: I will, thanks
00:35:30 <moop> there's apparently a sale at humble bundle for LYAH
00:35:41 <moop> is it still good or is it outdated?
00:36:09 <moop> or both
00:37:07 <MasseR> IIRC lyah was a bit theoretical, the concepts it has in it hasn't outdated
00:37:25 <MasseR> The most outdated concepts I can think of are that nowadays monads have applicatives as super classes
00:43:22 * hackagebot haskell-eigen-util 0.1.0.3 - Some utility functions for haskell-eigen library  https://hackage.haskell.org/package/haskell-eigen-util-0.1.0.3 (dilawars)
00:57:23 <Axman6> mpickering: Hey, I'm having a look at you slack-api, and I was wondering if it's possible to send any response other than a message? I've looked everywhere and can't see a way to send the more structures bot messages
01:19:32 <int-e> mniip: I try not to be around at 4 am in Europe.
01:24:20 <mpickering> Axman6: The RTM API only supports sending basic messages
01:24:49 <Axman6> oh, what a shame
01:28:23 * hackagebot emailaddress 0.1.0.0 - Wrapper around email-validate library adding instances for common type classes.  https://hackage.haskell.org/package/emailaddress-0.1.0.0 (cdepillabout)
01:31:36 <peteretep> So I have a Monoid
01:31:52 <peteretep> But there are two ways, rather than one way, that these items are naturally foldable
01:32:17 <peteretep> And it's a container class that should decide which fold to use
01:32:22 <peteretep> What's the right way to encapsulate that?
01:33:19 <peteretep> So I guess I don't have a Monoid, I have a set, with two possible binary functions
01:33:41 <mpickering> Axman6: I did just merge a pull request which allows you to send more complicated messages though
01:34:01 <mpickering> peteretep: Using a newtype wrapper
01:34:11 <mpickering> then defining a different instance for each newtype
01:34:26 <peteretep> If I google `newtype` will I find what you're talkingabout?
01:34:34 <mpickering> newtype Prod = Prod { getProd :: Int } vs newtype Sum = Sum { getSum :: Int }
01:35:18 <mpickering> newtype is like `data` but you can only have one constructor with one field. There is no runtime overhead to using newtypes as they just exist to add additional type information so can be erased at runtime. 
01:35:24 * peteretep reads
01:53:24 * hackagebot haskell-eigen-util 0.1.0.4 - Some utility functions for haskell-eigen library  https://hackage.haskell.org/package/haskell-eigen-util-0.1.0.4 (dilawars)
02:07:34 <peteretep> OK, related question
02:07:40 <peteretep> Can I express: data (MetaAssertion e) => TestSuite e = TestSuite TestName [e]
02:08:37 <peteretep> I want to say that a TestSuite `e` contains a [e], but I want to put a constraint on that e
02:09:40 <merijn> peteretep: The constraint there doesn't do anything useful, so no
02:11:31 <peteretep> I know that MetaAssertion requires an implementation of `foo`, and I want to be able to specify that every item in [e] must support a `foo`
02:11:35 <peteretep> How would I do that?
02:11:42 <aphorisme> peteretep: I had the some habit in designing types -- but it is not OO! There is no need to put constraints. The logic comes by the functions you use, i.e. there you put the constraints.
02:11:47 <aphorisme> the same*
02:12:25 <aphorisme> whenever you "use" a type it happens in a function.
02:12:34 <aphorisme> So put that constraint in the type of the function. 
02:12:52 <merijn> For example, note how Data.Set doesn't require Ord on the elements, only functions do
02:13:04 * peteretep tries something
02:13:14 <merijn> So "singleton :: a -> Set a", but "insert :: Ord a => a -> Set a -> Set a"
02:15:00 <merijn> peteretep: Usually people want to put constraint on data types to avoid having to type the constraint on every function, but that doesn't actually work since those functions STILL need to have the relevant constraint
02:15:54 <merijn> peteretep: So adding a constraint on datatypes doesn't reduce any typing on functions and since functions already enforce the relevant constraint, there's no real reason to restrict the datatype itself
02:16:04 <peteretep> ok, I think it's time for hpaste
02:16:31 <peteretep> http://lpaste.net/5164956404053704704
02:16:34 <peteretep> This is what I have
02:16:43 <aphorisme> I wish there was a framework compiling into native UI stuff; virtual-dom like.  : /.
02:17:06 <peteretep> I would like to make TestClass not specify TAssertion directly, I'd like it to support any type of MetaAssertion
02:18:37 <merijn> peteretep: But you have no generic way of creating MetaAssertion instances?
02:18:55 <peteretep> I don't understand that statement
02:19:29 <peteretep> Please could you explain what you mean?
02:19:52 <aphorisme> Why don't you just parametrize it: `data TestClass a e = TestClass TestName [a e]`?
02:20:02 <merijn> Actually, I have no idea what "test" is even doing, because I don't see newReport or append anywhere
02:20:37 <peteretep> newReport = ""
02:20:40 <peteretep> and append is (++)
02:20:57 <peteretep> aphorisme: hrm
02:21:02 <merijn> So basically, it doesn't even do anything?
02:22:06 <peteretep> merijn: Right
02:22:28 <peteretep> aphorisme: I think that might be what I needed
02:22:31 * peteretep makes it compile
02:23:50 <ski> peteretep : it's not clear to me how `data (MetaAssertion e) => TestSuite e = TestSuite TestName [e]' is related to your paste
02:24:15 <ski> peteretep : is `TestSuite' now renamed into `TestClass' ?
02:24:32 <peteretep> I am looking for a generic container of MetaAssertions which could be called either
02:24:44 <peteretep> The difference between them being how results are folded
02:25:34 <ski> peteretep : a `TAssertion e' doesn't contain any `e', so i don't see how replacing it by `e' as in that `TestSuite' attempt above would help
02:26:34 <ski> peteretep : the difference between `TAssertion' and `TestClass' ? or between one of them, and `TestSuite' ?
02:30:23 <troydm|work> hey all! I have a question regarding Haskell compiler, now let's say i have following code: http://lpaste.net/178163  will Haskell create "Mylongstring" in memory 10000000 + n times or not, and how can I check it?
02:31:22 <sdx23> troydm|work: check what?
02:31:51 <troydm|work> sdx23: how haskell will run this code, will it use a lot of memory or not?
02:32:22 <sdx23> ah, didn't read everything, sry. No, it's lazyness. As long as you don't use the list, it's not build up.
02:32:39 <sdx23> you should have a look into ghc-vis i guess
02:33:13 <lyxia> the string will only be created once
02:33:22 <sdx23> http://felsin9.de/nnis/ghc-vis/ there, it's really helpful to understand lazy evaluation by playing around
02:33:29 <troydm|work> lyxia: are you sure about it?
02:33:45 <lyxia> but list cons cells will take space
02:34:24 <troydm|work> lyxia: well nvm list cons cells, I somehow feel like what you say is not entirely correct
02:34:45 <troydm|work> lyxia: before creating "Mylongstring" it needs to convert it into Text
02:34:49 <troydm|work> for that it applies a function
02:35:15 <merijn> troydm|work: I think that gets fused away
02:35:31 <merijn> troydm|work: i.e. it builds the Text incrementally, but it also depends on strict vs lazy text, etc.
02:36:13 <anoe_> Hello, debug purpose. How to get line number (and file) that produced an error ? There is a ghc option ?
02:36:24 <troydm|work> Data.Text.Char8 is Strict
02:36:27 <troydm|work> for example
02:36:50 <merijn> Data.Text.Char8 is evil and should never be used >.<
02:37:02 <merijn> eh, wait
02:37:11 <merijn> *Text*.Char8?
02:37:12 <troydm|work> merijn: what should I use for short strings?
02:37:31 <merijn> There's no such thing
02:37:41 <troydm|work> well okey never mind that
02:37:56 <troydm|work> in my entire application I use bytestrings a lot of them
02:37:57 <merijn> ByteString.Char8, however is still evil
02:38:04 <troydm|work> and they take a lot of memory space
02:38:06 <merijn> https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
02:38:08 <sdx23> from the definition of repeat I expect that to point to the same thunk all the time. So, why should multiple Texts be generated?
02:38:10 <troydm|work> should I switch to Text ?
02:38:22 <merijn> troydm|work: That depends on what you're doing
02:38:33 <merijn> troydm|work: Is it text? Use Text. Is it Bytes? Use ByteString
02:38:46 <troydm|work> merijn: it's text
02:39:01 <merijn> (Note that the string part of ByteString is a historical accident and has nothing to do with it's function. It should just be called Bytes)
02:39:15 <troydm|work> okey
02:39:28 <troydm|work> merijn: I think now I need to do a lot of refactorings
02:39:35 <robot_smith> accident?
02:40:02 <merijn> robot_smith: Someone thought it was a good name because the very first versions didn't really have proper unicode strings and named them like that
02:40:13 <lyxia> anoe_: You have to write/use special functions. Prelude.error shows its location in GHC 8. For other versions there's the located-base package, or you can roll your own with GHC.Stack.
02:40:16 <troydm|work> merijn: also I'm not sure why every time I allocate short ByteString.Char8 it takes more space than it has characters
02:40:34 <troydm|work> like for example 15 char bytestring
02:40:37 <merijn> robot_smith: Now haskell has had proper strings for over 15 years (maybe 20?), unfortunately so much code uses ByteString that changing the name would break almost every library ever
02:40:58 <merijn> Actually, maybe even more than 20 years, not sure when unicode came to Haskell
02:41:02 <anoe_> lyxia: ok thanks
02:41:03 <robot_smith> hehe
02:41:17 <troydm|work> merijn: u mean Text is the proper unicode string type?
02:41:43 <merijn> troydm|work: String and Text are both proper unicode, Text, however is more efficient in terms of space and processing
02:42:00 <merijn> Also more correct for basic operations like "uppercase"
02:42:09 <troydm|work> merijn: ic
02:42:32 <merijn> > toUpper 'ﬃ' -- wrong
02:42:33 <troydm|work> merijn: thx for clarifying
02:42:33 <lambdabot>  '\64259'
02:42:44 <merijn> eh
02:42:50 <merijn> > text $ toUpper 'ﬃ' -- wrong
02:42:52 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
02:42:52 <lambdabot>      Expected type: String
02:42:52 <lambdabot>        Actual type: Char
02:42:58 <merijn> > text . return $ toUpper 'ﬃ' -- wrong
02:43:00 <lambdabot>  ﬃ
02:43:17 <merijn> > Data.Text.toUpper $ text ['ﬃ']
02:43:19 <lambdabot>      Not in scope: ‘Data.Text.toUpper’
02:43:19 <lambdabot>      Perhaps you meant ‘Data.Char.toUpper’ (imported from Data.Char)
02:43:49 <merijn> hmmm
02:44:03 <merijn> Anyway, Data.Text.toUpper properly returns "FFI" for that
02:45:45 <troydm|work> merijn: thx for explanations
02:45:56 <eshan> Hello everybody!
02:46:04 <eshan> I have a bit of a question
02:46:23 <liste> hi eshan, go ahead
02:46:27 <eshan> Is it possible to make optional parameters in Haskell?
02:46:31 <eshan> I'm not sure because of currying
02:46:36 <merijn> eshan: Not really
02:47:05 <eshan> So should I just make a guard for each possiblity?
02:47:06 <merijn> eshan: The usual solutions are: Take a record of values and provide a "default" record whose contents can be overwritten
02:47:21 <eshan> Ah, I see. Let me try it out. Thanks!
02:47:23 <merijn> eshan: Or, provide the general function and then partially apply optional arguments
02:47:41 <eshan> Actually that would be a better solution
02:47:51 <eshan> Take advantage of partial application
02:47:55 <merijn> eshan: Yeah, depends on how many optional arguments you're dealing with :)
02:48:00 <eshan> Right now 2
02:48:13 <merijn> eshan: If you have LOTS records are better. For one or two, partial application :)
02:48:18 <eshan> Yeah
02:48:30 <eshan> For lots records would even make it more readable
02:48:39 <eshan> Thanks so much, man
02:50:19 <merijn> eshan: As a bonus, this way people can make their own specialised functions by just doing "foo = generalFoo customDefault" :)
02:53:26 * hackagebot clash-prelude 0.10.13 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-0.10.13 (ChristiaanBaaij)
02:53:28 * hackagebot clash-lib 0.6.21 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.21 (ChristiaanBaaij)
02:53:30 * hackagebot clash-systemverilog 0.6.9 - CAES Language for Synchronous Hardware - SystemVerilog backend  https://hackage.haskell.org/package/clash-systemverilog-0.6.9 (ChristiaanBaaij)
02:53:32 * hackagebot clash-verilog 0.6.9 - CAES Language for Synchronous Hardware - Verilog backend  https://hackage.haskell.org/package/clash-verilog-0.6.9 (ChristiaanBaaij)
02:53:34 * hackagebot clash-ghc 0.6.23 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.23 (ChristiaanBaaij)
03:08:20 <AdituV> Is attosec any less powerful than parsec, etc?  As in is there anything parsec can parse that attoparsec can't, rather than more convenient combinators?
03:08:59 <liste> AdituV: parsec gives better error messages, if you consider that power
03:09:04 <AdituV> Trying to decide whether to switch which library I'm using or do multiple parsing passes
03:09:20 <ski> eivarv : sometimes people wrap with `Maybe' for an optional argument
03:09:24 <ski> er
03:09:35 <ski> oh, eshan left
03:09:42 <AdituV> This file type is horrible.  :P
03:15:34 <Morgawr> I'm trying to test some properties in my system using quickcheck, I have a data type which is made of records from various constructors. I have a generator for this data type, however I need to constrain the generator to only a subset of constructors, is there a way to do this?
03:15:59 <Morgawr> Like I have data = A { ... } | B { ... } | C { .... } and I need to only generate values using the B and C constructors in that specific test case.
03:16:10 <liste> Morgawr: you can use ==>
03:16:49 <liste> @check (x::Int > 0) ==> x*x > 0
03:16:49 <lambdabot>  <unknown>.hs: 1: 12:DataKinds is not enabled
03:17:27 <Morgawr> liste: How would that work with a record type though? I'm a bit confused on how I would make sure to only get a specific subset of constructors
03:17:35 <liste> Morgawr: https://hackage.haskell.org/package/QuickCheck-2.9.1/docs/Test-QuickCheck.html#v:-61--61--62-
03:19:01 <liste> like someCheckFor x = (isB x || isC x) ==> .... -- where isB is true for B's and isC is true for C's
03:19:42 <Morgawr> liste: Alright, thanks, I'll see what I can do
03:20:36 <liste> Morgawr: see also forAll
03:23:39 <ski> @check \x -> ((x :: Int) > 0) ==> (x*x > 0)
03:23:41 <lambdabot>  +++ OK, passed 100 tests.
03:24:53 <phadej> @check \x -> ((x :: Large Int) > 0) ==> (x * x > 0)
03:24:55 <lambdabot>  *** Failed! Falsifiable (after 21 tests and 16 shrinks):
03:24:55 <lambdabot>  Large {getLarge = 4050616393}
03:25:17 <phadej> ski: ^
03:26:07 <{AS}> chcec
03:26:09 <{AS}> sorry
03:27:45 <ski> Morgawr : `forAll' is quite possibly better in this case. `(==>)' will discard each generated value that don't satisfy the precondition, and try to generate a new one. but (a) that (wasteful) generation might be expensive, and (b) it won't try forever to generate as many pre-condition-passing values as desired. perhaps worst, (c) that filtering may in some cases skew the distribution of generated values in undesirable ways
03:27:53 <ski> phadej : *nod*
03:28:25 <{AS}> You should consider using SmallCheck/LazySmallCheck for test generation as well
03:28:36 <ski> Morgawr : in your case, (c) is possibly not a problem, but (a) and maybe (b) could be
03:28:48 <{AS}> https://hackage.haskell.org/package/lazysmallcheck 
03:28:54 <ski> @check True
03:28:56 <lambdabot>  +++ OK, passed 100 tests.
03:28:56 <ski> @check False ==> True
03:28:58 <lambdabot>  *** Gave up! Passed only 0 tests.
03:29:41 <ski> the latter ^ quick-checking here gave up after failing to produce 100 testcases satisfying the precondition
03:30:56 <lyxia> @check \x -> (x == 0) ==> True
03:30:58 <lambdabot>  *** Gave up! Passed only 34 tests.
03:31:38 <lyxia> I didn't know ==> worked that way
03:32:03 <ski> Morgawr : a simple example of (c) would be generating a list, and adding a precondition with `(==>)' that it must be sorted. in this case, probably very many of the generated lists that pass the precondition will be either empty or singletons, so quick-checking will probably check less "interesting" cases, and is then less likely to find counterexamples
03:34:20 <ski> Morgawr : to use `forAll', you simply write your own `Gen Foo' generator, naming it whatever, perhaps `sortedList :: Arbitrary a => Gen [a]' in the above example, instead of defining `arbitrary' for an `Arbitrary' instance of `SortedList a' (or whatever). then instead of `propFoo xs = ..xs..' you use `propFoo = forAll sortedList $ \xs -> ..xs..'
03:35:22 <ski> (an alternative there would be to have `sortedList :: Gen a -> Gen [a]', allowing you to specify a custom generator for the elements as well)
03:35:43 <Morgawr> I understand how that works, the only problem I have is that it's not quite clear to me how to generate only a subset of records from the same datatype.
03:35:48 <ski> (er, and of course there should also be an `Ord a' constraint on `sortedList')
03:35:58 <Morgawr> Can't I just tell quickcheck to generate record B and C and not A?
03:36:23 <ski> you tell it that by writing a custom generator that does that, and pass that to `forAll'
03:37:00 <ski> (or, make a new data type and an `Arbitrary' instance for that. but that seems a roundabout way to achieve it here)
03:37:19 <fr33domlover> Hello. I have a type "data D t = A t | B Int" is it good practice to use 't' like that where it appears only in the A cnstructor?
03:37:31 <ski> Morgawr : have you written the "ordinary" `Arbitrary' instance for your data type ?
03:37:38 <Morgawr> Yeah.
03:38:15 <saurabhnanda> does anyone here use ClassyPrelude? Is there some documentation on how to use MonoTraversable? Especially the non-zero list thingie?
03:38:29 <ski> Morgawr : then copy the definition of `arbitrary' in there out of the instance declaration, rename `arbitrary' in the copy to something else, and modify it to not generate `A { ... }' records
03:38:30 <pavonia> fr33domlover: If it is necessary, why not?
03:38:45 <ski> Morgawr : finally use `forAll' with this custom generator. all clear ?
03:38:54 <fr33domlover> pavonia, just wondering if there's a better way, dunno :P
03:39:19 <pavonia> Well, what is you aim?
03:39:24 <fr33domlover> saurabhnanda, iirc the same as traversable?
03:39:25 <pavonia> *your
03:40:09 <ski> fr33domlover : if it's what you intend, then there's no problem with it, in itself
03:40:33 <fr33domlover> pavonia, basically SqlColumnType t = PrimitiveType (Proxy t) | ForeignKey ColumnName
03:40:51 <Morgawr> ski: I kind-of get it, I'm still wrapping my head around it but I'm sure I can come to something, thanks a lot for the help :)
03:40:55 <ski> fr33domlover : you might in a few cases have to explicitly annotate a use of `B' with an explicit type ascription to fix `t' to some particular type, but most commonly the context should determine it
03:40:57 <saurabhnanda> fr33domlover: is it?
03:41:23 <saurabhnanda> fr33domlover: it's not letting me use 'head' on a list. 
03:41:49 <saurabhnanda> fr33domlover: I assume it wants me to ensure it's NOT a zero-length list, which is good. But I can't figure out how to do that, exactly
03:42:15 <fr33domlover> sujeet, i dunno but take a look at Daa.List.NonEmpty in base
03:42:18 <fr33domlover> maybe it will help
03:42:21 <fr33domlover> *Data
03:42:50 <fr33domlover> I just avoid that classy prelude thing until/unless it becomes standard...
03:44:42 <merijn> fr33domlover: I don't see why you wouldn't have a datatype where a parameter is only used for one constructor
03:45:03 <merijn> fr33domlover: Hell, consider "data Maybe a = Nothing | Just a" and "data Either a b = Left a | Right b" :)
03:45:13 <merijn> fr33domlover: They do exactly that :)
03:45:51 <ski> @src [][
03:45:51 <lambdabot> Source not found. Wrong!  You cheating scum!
03:45:52 <ski> @src []
03:45:52 <lambdabot> data [] a = [] | a : [a]
03:46:01 <merijn> ski: Oh, good point :)
03:46:05 <merijn> Yet another one :)
03:46:07 <saurabhnanda> Basically, I’m stuck with the following error message, with no clue how to solve it. I thought I was using a standard list, but it’s not a standard list after all. “Couldn't match type ‘[J.File]’ with ‘MinLen (Succ nat0) mono0’ arising from a functional dependency between: constraint “
03:46:27 <merijn> fr33domlover: In other words, there's already gazillions of datatypes doing exactly what you asked that everyone uses daily :)
03:47:58 <ski> saurabhnanda : i don't see `MonoTraversable' at <https://hackage.haskell.org/package/ClassyPrelude-0.1/docs/Prelude-Classy.html>. which package is it in ?
03:48:12 <saurabhnanda> https://hackage.haskell.org/package/mono-traversable-1.0.0.1/docs/Data-MonoTraversable.html
03:49:29 <ski> (dunno why the search didn't turn that up)
03:50:22 <ski> saurabhnanda : and `MinLen' ?
03:51:29 <saurabhnanda> ski: I'm clueless
03:52:18 <ski> saurabhnanda : what code gave rise to that type error, then ?
03:52:34 <saurabhnanda> f1 = head (j1 ^. J.files)
03:54:01 <saurabhnanda> complete code: http://lpaste.net/177548
03:54:27 <saurabhnanda> (j1 ^. J.files) :: [J.File] if it helps
03:55:02 <saurabhnanda> line http://lpaste.net/177548#line108 to be precise. The error comes if I change `headEx` to `head`
03:55:50 <fr33domlover> merijn, good point :P
03:57:37 <ski> saurabhnanda : and `headEx' is from ?
03:57:48 * ski suspects `MinLen' is a lens thing ?
03:58:27 <zoran119> say i fire off a couple of forkIO from the main. how can i keep main from terminating and ending my threads with it?
03:59:05 <saurabhnanda> class MonoFoldable mono where  ...  headEx :: mono -> Element mono  ...  	-- Defined in ‘mono-traversable-0.10.2:Data.MonoTraversable’
03:59:22 <zoran119> i get the effect i want by using _ <- getLine but that's a bit yuck (and still terminates when i press enter)
03:59:27 <troydm|work> zoran119: use MVar
03:59:51 <saurabhnanda> type role MinLen phantom representational
03:59:52 <saurabhnanda> newtype MinLen nat mono = mono-traversable-0.10.2:Data.MinLen.MinLen {unMinLen :: mono}  	-- Defined in ‘mono-traversable-0.10.2:Data.MinLen’
04:00:21 <zoran119> troydm|work: that's streching my imagination i bit :(
04:00:27 <zoran119> troydm|work: example?
04:00:51 <saurabhnanda> ski: any idea? do I need to make my data types use Data.List.NonEmpty instead of the plain ol' []
04:02:28 <ski> saurabhnanda : i suspect that either `(j1 ^. J.files) :: [J.File]' doesn't hold, ior the error is somewhere else
04:02:45 <ski> saurabhnanda : otherwise i don't see where the `MinLen' in the error message could come from
04:03:44 <saurabhnanda> isn't there any tutorial for ClassyPrelude?
04:04:06 * ski isn't even sure the problem has to do with `ClassyPrelude'
04:04:12 <{AS}> Hi, is there a good way to check whether a path relative or absolute?
04:04:12 <ski> saurabhnanda : apart from already having an idea of where the error may be, i'd suggest divide-and-conquer debugging
04:04:23 <saurabhnanda> it changes the behaviour of so many regular functions. Most Haskell tutorials don't consider that you'll be using ClassyPrelude. However, if you're writing a webapp in Yesod, that's what you get, by default.
04:04:41 <merijn> {AS}: Pretty sure there's functions for that
04:05:37 <ski> saurabhnanda : iow, try to shrink the code generating the error, while preserving (the essentials of it), by removing (or commenting out) sections of code that are not related, possibly replacing bodies of definitions with `undefined', and otherwise cutting down on it
04:05:53 <{AS}> merijn: Yeah, I guess I will look for one :)
04:05:56 <{AS}> thanks
04:09:54 <sshine> geekosaur, thanks.
04:15:55 <saurabhnanda> is there a site (on the lines of plnkr) to quickly generate proof-of-concept code for Haskell? For example, if I have to write the minimal reproducible case for a bug I'm facing?
04:18:54 <saurabhnanda> ski: here's the minimal case: http://lpaste.net/178218
04:21:04 <saurabhnanda> ski: and here is MinLen https://hackage.haskell.org/package/mono-traversable-0.10.2/docs/Data-MinLen.html
04:22:16 <saurabhnanda> which seems to be no longer present in the latest version of mono-traversable: https://hackage.haskell.org/package/mono-traversable
04:22:26 <sshine> is there a function somewhere that does String -> [Word8]?
04:23:49 <ski> saurabhnanda : oh, `Data.MinLen' seems to have been removed from the latest version of `mono-traversable'
04:24:17 <saurabhnanda> and there's some documentation about minlen at https://hackage.haskell.org/package/mono-traversable-0.10.2 just scroll to the yellow section
04:25:03 <saurabhnanda> and some more: https://hackage.haskell.org/package/mono-traversable-0.10.2/docs/Data-MinLen.html#g:3
04:25:08 <ongy> sshine: https://hackage.haskell.org/package/utf8-string-1.0.1.1/docs/Codec-Binary-UTF8-String.html
04:25:45 <ski> saurabhnanda : it seems you're supposed to use `toMinLen' (or `toMinLenZero', though that can't apply here, since you're trying to use `head') to convert
04:26:16 <saurabhnanda> yes
04:26:26 <saurabhnanda> which means my core data-type has to change from [] to something else
04:26:46 <saurabhnanda> **if** I want to continue using the safe 'head' exported by ClassyPrelude
04:26:53 <saurabhnanda> else I can just use headEx and call it a day
04:27:13 <sshine> thanks, ongy!
04:27:36 <ongy> sshine: generally hoogle is nice for this. You can just search 'String -> [Word8]'
04:28:38 <sshine> ongy, I did, but your suggestion didn't turn up on the first page, so I figured it wasn't there.
04:29:34 <ongy> sshine: hm, I found it. But what are you going to do with it either way?
04:29:42 <sshine> but now that you say it, I recall that Hayoo is pretty good for extra libraries.
04:30:22 <saurabhnanda> ski: to make matters more confusing, there's Data.MinLen and Data.NotNull
04:30:41 <sshine> ongy, well, I really wanted a Data.Trie that works for Data.Text values, but since Data.Trie only supports ByteString, I figured I'll just make a Trie Text and map the bytes to the Texts instead.
04:32:00 <sshine> ongy, so if there's a funky unicode character in what I'm looking up in my Trie, it should still find it by a slightly longer byte path. :)
04:32:20 <sshine> ongy, and the lookup value will be the properly encoded Text.
04:32:36 <ongy> sshine: why do you not use Data.Text.Encoding.encodeUtf8 and use the ByteString version?
04:33:28 <sshine> ongy, oh. yeah, that's silly
04:33:37 <sshine> ongy, I should do that. thanks.
04:33:42 <ongy> :)
04:34:41 <sshine> so ByteStrings can contain UTF8.
04:35:08 <sshine> well, they can contain anything, I suppose, but people find it meaningful to put UTF8-encoded data in ByteStrings.
04:35:11 <merijn> sshine: UTF8 is a method of encoding unicode as binary data, so that question is a bit weird
04:35:26 <tdammers> what else would you use to store utf8-encoded strings?
04:35:42 <merijn> tdammers: Pixie dust, it has a high information density!
04:35:50 <sshine> hehe.
04:36:02 <tdammers> the alternatives are all either functionally equivalent to bytestrings, or they involve decoding your utf8 into something encoding-agnostic
04:42:04 <saurabhnanda> so MinLen got split-out into its own repo -- https://github.com/snoyberg/mono-traversable/tree/master/minlen#readme
04:44:48 <muzzle> hi, I have a question of terminology. What do i call "instances" of a datatype in haskell?
04:45:09 <merijn> muzzle: values?
04:45:18 <merijn> "maybe values", "either values", etc.
04:45:45 <muzzle> So if I have e.g. the type Connection for a database connection i would write "Connection value"
04:45:51 <muzzle> thx
04:45:54 <merijn> or just "Connection"
04:46:38 <merijn> muzzle: Usually you use the type to indicate either 1) the type or 2) a value of that type, since it's (almost always) unambiguous which you mean in context
04:46:41 <hpc> or "value of type foo" if you need to say precisely what foo is and it's non-trivial
04:57:20 <ski> usually "a" or "the" in connection with a (perhaps incomplete) description of a type serves to indicate a value of that type
04:57:41 <ski> (perhaps that's what you mean by the context)
05:00:18 <zoran119> i'm trying to use parList like this: (map f xs) `using` parList rdeepseq
05:00:31 <zoran119> should this work for any return type of f?
05:01:25 <zoran119> my f is retrning IO (Either Int Int) and i'm getting this error: No instance for (NFData (IO (Either Int Int))) arising from a use of ‘rdeepseq’
05:01:27 <phadej> which is instance of `NFData`
05:02:05 <phadej> fwiw, parList doesn't work in IO monad, only fore pure functions
05:02:51 <phadej> zoran119: you probably want something like http://hackage.haskell.org/package/async-2.1.0/docs/Control-Concurrent-Async.html#v:mapConcurrently
05:04:06 <zoran119> phadej: cool! that's much more like what i'm after (i'm trying to kick off multiple http clients at the same time)
05:33:38 <Gurkenglas> That error at the end is because I didnt run msys2 as root? http://lpaste.net/432423797056864256 and can stack prompt me there for admin permissions instead of crashing?
05:38:31 * hackagebot FunGEn 1.0.1 - A lightweight, cross-platform, OpenGL/GLUT-based game engine.  https://hackage.haskell.org/package/FunGEn-1.0.1 (SimonMichael)
05:43:32 * hackagebot libmpd 0.9.0.6 - An MPD client library.  https://hackage.haskell.org/package/libmpd-0.9.0.6 (JoachimFasting)
05:50:41 <fProgrammer> quick question: i m planning to build a RESTFul web server using servant. The request is some sensor data, and response is result of  computation(SVM support vector machine). SVM is supervised machine learning algorithm and it has a precomputed training model. My pre computed trained models are a bunch of 10-100mb files. how do i load them efficiently for each request?
05:51:40 <liste> fProgrammer: so there's a different model for each request? you don't want to pre-load them?
05:51:43 <fProgrammer> forgot to mention, each request determines which trained model to load
05:54:13 <fProgrammer> liste: there are about 40-50 models, each varying in size,  preloading all the models will take a good 2-3GB of memory (I am still new to haskell, and space leaks which is not fully understood by me, can cause problems here ) 
05:56:31 <Gurkenglas> https://github.com/lukexi/rumpus/blob/master/Building.md how do I tell stack to use that preview build of GHC 8.0.2?
05:58:08 <fProgrammer> liste: any idea/suggestions?
05:59:51 <liste> fProgrammer: does Servant allow output using some kind of pipe/conduit/stream?
06:00:00 * liste is not familiar with Servant
06:02:42 <fProgrammer> liste: I googled up, there are few programmers who have used conduit to stream data from s3. https://github.com/haskell-servant/servant/issues/271
06:17:12 <ent> does anyone know of a tutorial for starting with ghcjs with stack?
06:25:03 <infandum> What is everyone's opinion on "literate programming" as a "replacement" for shell scripting using haskell in something like org-mode?
06:25:16 <infandum> Like, using Turtle
06:25:19 <infandum> in org-mode
06:25:23 <infandum> for instance
06:26:12 <ent> I've converted some of my dotfiles into org-mode exports
06:26:22 <kadoban> ent: The docs give you the magic stuff you have to add to stack.yaml, and other than that there's not much to do. I think there's a github repo with that stuff already in place if you want, forget what it's called though.
06:26:24 <ent> so far it's been nice
06:27:10 <ent> kadoban: the ghcjs docs?
06:27:27 <kadoban> ent: The stack ones
06:27:31 <ent> ah
06:27:39 <kadoban> https://docs.haskellstack.org/en/stable/ghcjs/
06:27:47 <infandum> ent: Yeah, it seems great for stuff like that. But what about for scripts rather than configurations?
06:28:05 <infandum> I'm unsure of how I want to move forward...
06:29:56 <ent> kadoban: thanks!
06:30:26 <ent> infandum: I haven't really had any long scripts in it so it's hard to say
06:33:08 <infandum> hmm
06:33:38 <infandum> it's just a bit difficult to split a haskell program up with big functions in org-mode and on top of that I don't know how you would run it with stack
06:33:57 <Gurkenglas> Is "Gurkenglas" an acceptable pseudonym for uploading packages to hackage?
06:34:29 <quchen> Sure.
06:34:46 <quchen> (I’m German, and I still think it’s okay.) :-)
06:34:55 <maerwald> why would it not be?
06:35:50 <quchen> It means Cucumber Glass. Which is a bit silly, but who am I to call names silly
06:36:11 <quchen> Well, pickle glass, rather.
06:36:30 <Gurkenglas> Picklejar is more fitting I think
06:36:43 <tdammers> No
06:36:45 <maerwald> I know what it means, hence I don't understand why it wouldn't be ok
06:36:52 <Welkin2> kosher pickles?
06:37:07 <tdammers> picklejar has too many connotations from other languages
06:37:23 <ongy> quchen: what's better, pickles or cake?
06:37:28 <maerwald> don't get carried away by political correctness cancer ;)
06:37:49 <quchen> ongy: qake!
06:37:58 <Rotaerk> the qake is a lie
06:38:05 <Gurkenglas> Just wondering why I'm not getting a verification email, and thought "We ask only that such people choose a name (and username) that looks at home among a collection of real names; we will be unwilling to add Kittenlover97 to the package uploader group." might be a reason
06:38:36 <quchen> If it’s your accepted IRC nick and people know you by it I think it’s probably the best choice you can make.
06:39:12 <ongy> I just used my full last name, which may be something weird in another language
06:39:28 <ongy> I think it means something where it's from, but as long as I don't know :)
06:39:39 <maerwald> I feel like that restriction must be lifted and discussed on the ML.
06:39:40 <Welkin2> is it ongy?
06:39:46 <ongy> Welkin2: ongyerth
06:40:00 <maerwald> it goes pretty much against decades of internet culture and common sense
06:40:03 <ongy> I either use ongy, or if it's taken ongyerth as username
06:40:08 <Gurkenglas> (Seeing https://gyazo.com/630f9571e493a377fccf92c9537d2995 now and last time I tried this... like a week ago?)
06:40:43 <Welkin2> what is gyazo
06:40:57 <ongy> maerwald: the rule in general is ok, but I doubt haskell has the kiddis that would do weird names
06:41:17 <Welkin2> check your spam Gurkenglas 
06:41:24 <maerwald> I think the rule is nonsense
06:41:32 <Welkin2> what rule?
06:41:35 <jchia_> I'm trying c2hs for the first time. I'm trying to read some C++ structs from a file. Although I normally use stack, I'm now running c2hs by hand to make sure that my .chs makes sense syntactically. However, when I run c2hs CPP_HEADER.h CHS.chs, I get a cryptic error "c2hs: Prelude.last: empty list". What am I missing? I was expecting at least something related to the syntax in my chs but I got this error instead.
06:41:36 <Gurkenglas> Welkin, a think that allows me to do Ctrl-Shift-D, drag a rectangle, copy the link from the site that just opened
06:41:41 <Gurkenglas> *thing
06:42:31 <Gurkenglas> Welkin, not in the spam folder either. And the "hackage" search query into the email client finds only 3 irrelevant mails
06:42:44 <maerwald> Internet nicks have always been wild and free. If someone uses Kittenlover97 on github, bitbucket, email, irc, jabber and all of his social media, why would he not be allowed to have that hackage nick? He's known by that nick.
06:43:02 <Welkin2> jchia_: you are using the 'last' function somewhere on an empty list 
06:43:27 <Welkin2> maerwald: there is no rule
06:43:41 <maerwald> I'd even say it's discrimination
06:43:44 <jchia_> Welkin2: not in my own code
06:43:45 <Welkin2> Gurkenglas just made it up
06:43:46 <Gurkenglas> Welkin, https://hackage.haskell.org/upload
06:43:59 <maerwald> Welkin2: oh did he
06:44:23 <Gurkenglas> I appreciate it when people stick their neck out far enough to be chopped off cleanly, I often do it myself :D
06:44:34 <maerwald> so what was the fuss all about?
06:45:18 <Gurkenglas> Oops wrong link https://hackage.haskell.org/users/register-request
06:45:26 <Gurkenglas> "Most contributors to Hackage attach their real name to their packages and contributions. However, we have no wish to discourage contributors with personal or professional reasons for wanting pseudonymity. We ask only that such people choose a name (and username) that looks at home among a collection of real names; we will be unwilling to add Kittenlover97 to the package uploader group."
06:45:42 <Welkin2> oh, you mean this? https://hackage.haskell.org/users/register-request
06:45:51 <maerwald> so he didn't make it up
06:45:52 <Welkin2> never saw that before
06:46:33 <maerwald> yeah and that restriction should be removed
06:46:59 <lonokhov> Is there a proper name for ST (runST) phantom variable trick?
06:47:22 <Welkin2> lonokhov: are you a ghost?
06:47:36 <lonokhov> why?
06:48:06 <Welkin2> haven't seen you in a very long time 
06:48:27 <lonokhov> Oh, I mostly stick to #-blah and ruhaskell gitter
06:51:22 <humanoyd> Can anyone give me some intuition for https://hackage.haskell.org/package/profunctors-5.2/docs/src/Data.Profunctor.Types.html#Forget?
06:52:19 <pavonia> Uh, why aren't charsToCWchars and cWcharsToChars exported from Foreign.C.String :(
06:52:31 <lonokhov> humanoyd: I think it turns contravariant into profunctor, with phantom `b`
06:53:47 <lonokhov> humanoyd: the `b` in `Forget r a b` is a Functor part of profunctor
06:54:30 <lonokhov> So it will behave like `Const a b` does, it just ignores b
06:55:00 <humanoyd> lonokhov: ah...okay, I think I know where this is going...will have to think about it some more...thanks!
06:55:55 <Gurkenglas> Well, only the particular Contravariant that is (_ -> b). Shouldn't it be "data Const1 f a b = Const1 { runForget :: f a }" with instance Contravariant f => Profunctor (Const1 f)"?
06:56:02 <Gurkenglas> *runConst1
06:56:30 <lonokhov> Oh, it has `a -> r`, I've read it like `r a` for some reason
06:57:24 <sphalerite> What's a good representation for a 2-dimensional grid, specifically in the context of a board game (board like a chessboard, but may have different sizes)? For a fixed size, I've defined a Data type for coordinates in each dimension and then define the board as a function (XCoord, YCoord) -> Piece (where Piece can be an "Empty" value); however, I don't really see this working for variable-sized boards.
06:57:42 <lonokhov> So Forget turns any function into profunctor with only contravariant part working and covariant one ignored. weird
06:58:33 <Welkin2> sphalerite: use a flat vector with an index expression or use a Map
06:59:49 <Gurkenglas> Use lenses to interface with your bord and then just use lists or something until you need to substitute something better
06:59:50 <Welkin2> or use Array for its Ix instance
06:59:54 <Gurkenglas> *board
07:00:19 <pankaj0010> hi
07:00:42 <srhb> pankaj0010: Hi.
07:00:42 <pankaj0010> hey anyone there?
07:01:02 <pankaj0010> @srhb hi
07:01:02 <lambdabot> Source not found. Sorry.
07:01:05 <Welkin2> pankaj0010: no one
07:01:26 <Welkin2> don't prefix names with @
07:01:34 <pankaj0010> i am new
07:01:36 <Welkin2> that is the bot trigger
07:01:42 <pankaj0010> need someone to help me out
07:01:46 <srhb> pankaj0010: With what? :)
07:01:51 <pankaj0010> new with irc
07:02:12 <srhb> pankaj0010: In general, if you have a Haskell question, you can just ask the channel, and if someone wants to help out with the question, they will respond.
07:02:55 <Gurkenglas> Enter "/join ##freenode" without "" to get into the channel that busies itself with asking irc questions, and directly ask the question without saying hi.
07:03:05 <Gurkenglas> *answering
07:03:35 <ongy> is @srhb autocorrected to @src by lambdabot ?
07:03:53 <srhb> ongy: It would appear so.
07:04:02 <kadoban> Probably. lambdabot's autocorrect is ... ambitious.
07:04:12 <Gurkenglas> @seen ongy
07:04:12 <lambdabot> oNGy
07:04:17 <Welkin2> info becomes undo
07:04:27 <Welkin2> seen is leet
07:04:35 <ongy> why does it even exist? and not git style: Do this, it's what you want
07:05:12 <kadoban> Because in theory "hey maybe you meant: " is just two extra lines, which matters in IRC more than it does in your command line.
07:05:26 <kadoban> Also git has to worry about commands with side effects, it guessing what you meant would be terrible.
07:06:22 <srhb> kadoban: Your argument works equally well to discourage the current lambdabot behaviour considering the amount of extra lines we're up to now. :-P
07:07:23 <sphalerite> Welkin2: those sound like alright options, but how would I handle errors (OOB coordinates) in that case?
07:07:27 <kadoban> srhb: Assuming that the other behavior wouldn't provoke even more voluminous conversations.
07:07:38 <srhb> kadoban: True!
07:07:46 <sphalerite> Gurkenglas: I'll read about lenses, thanks
07:08:28 <Welkin2> sphalerite: they are handled for you
07:08:46 <Welkin2> for a map, you get Nothing
07:09:43 <Welkin2> lens is overkill for this
07:10:11 <Welkin2> i don't understand why everyone is so quick to tell others to use lens 
07:11:01 <pankaj0010> hey
07:11:08 <sphalerite> hm, yeah they don't seem all that suitable for this case, but they do look very useful
07:11:16 <sphalerite> in general
07:11:39 <sphalerite> That makes sense (Map giving Nothing), thanks Welkin2 
07:12:18 <ongy> Welkin2: http://www.doxdesk.com/img/updates/20091116-so-large.gif ?
07:12:22 <Welkin2> vector also has a !? lookup function that produces a Maybe a 
07:12:38 <sphalerite> Although it allows non-square boards too...
07:12:43 <ongy> somewhat random link (the jquery stackoverflow joke)
07:12:53 <Welkin2> sphalerite: use a vector then
07:13:26 <sphalerite> ongy: nice
07:13:37 <sphalerite> Welkin2: makes sense. Thanks!
07:32:26 <jchia_> i have a c2hs question. do i need to have "-*-haskell-*-" in the chs file in order for c2hs to process it properly?  I couldn't find any recent tutorial and this one from 2010 doesn't mention "-*-haskell-*-". http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/
07:33:11 <jchia_> without the "-*-haskell-*-" c2hs tries to use Prelude.last on an empty list
07:35:01 <chsn> Where does the complexity of Haste/GHCJS come from? Is it not as simple as writing a STG -> JS compiler?
07:35:22 <chsn> Doesn't GHC handle all the difficult parts, and all we need is just a STG -> JS part?
07:36:02 <merijn> chsn: Haste is not actually haskell, afaik, merely a common subset
07:36:16 <chsn> merijn: I thought Haste was Haskell2010 + most of the extensions, but not TH
07:36:18 <merijn> chsn: i.e. "everything that's valid haste also happens to be valid haskell, but it's not haskell"
07:36:51 <nyson> ls
07:36:54 <nyson> sorry
07:36:57 <merijn> chsn: Well, to begin with, GHC doesn't actually produce STG as output and any intermediate output like Core is non-standard and prone to change
07:36:58 <chsn> merijn: I thikn that depends on whether 'haskel' is defined as Haskel2010 standard or "all the standards that ghc supports"
07:37:10 <merijn> chsn: So targetting that as input is hard
07:37:24 <merijn> chsn: Last I checked Haste was not Haskell2010 compliant, but I can check again
07:37:38 <chsn> merijn: http://stackoverflow.com/questions/27348937/ghc-pipeline-core-stg-asts-or-text seems to imply that there definitely is a "STG" stage
07:38:06 <chsn> http://jozefg.bitbucket.org/posts/2014-10-28-stg.html also implies there's a "STG" layer (i..e between layers 6 & 7"
07:38:07 <merijn> chsn: There is a stage, yes, but it only exists as internal AST
07:38:22 <merijn> chsn: There is no textual format and certainly not a stable format, afaik
07:38:33 <merijn> chsn: Looks like Haste expanded to include Haskell2010, though
07:38:39 <jonored> chsn: There's a simpler version in that you can, I believe, just chain ghc to llvm to js.
07:39:12 <merijn> jonored: Except, of course, compiling Core to JS will deliver vastly better JS than compiling LLVM assembly to JS :)
07:39:59 <jonored> Ah, I see. And I expect you're doing a lot of the "of course you want this but it's not free" interface to js code yourself, as well.
07:40:12 <chsn> yeah; I also want small *.js output
07:40:25 <Welkin2> greedy bastard
07:40:35 <merijn> chsn: Anyway, my point is that, while STG and Core exist, they are not documented/standardised or even stable formats
07:40:39 <jonored> asm.js doesn't compress well, I suppose?
07:40:56 <merijn> chsn: Which means that GHC devs are free to change them at any time, since no one is supposed to be using those anyway
07:41:23 <chsn> merijn: that's fine; I don't ind modifying my compiler every time ghc updates
07:41:30 <merijn> chsn: So if you merely write a STG -> JS compiler you might have to update every time GHC does
07:42:18 <merijn> chsn: But anyway, I don't think GHCJS is substantially more complex than any other compiler, but of course, compilers are already plenty complex on their own :)
07:43:10 <chsn> merijn: ghcjs is HUGE; Trump would be proud; I'm looking for a Haskell->JS compiler that'd be ~1K lines of haskell, by just doing STG -> JS
07:43:10 <merijn> chsn: Your original question seems to imply that compiling "STG -> JS" is substantially simpler than, e.g. compiling Haskell to JS
07:43:14 <kadoban> Isn't GHCJS just GHC with some parts swapped out anyway?
07:43:36 <merijn> chsn: GHCJS is literally GHC with a new backend for translating STG to JS and a JS based runtime system
07:43:37 <chsn> merijn: at the very least, STG -> JS means no type cehcking / resolving type classes; Haskell -> JS has to do all forms of type inference for all the ahskell extensions
07:43:41 <nyson> I personally think Haste is easier to develop in, but I haven't tried GHCJS that much
07:43:46 <merijn> chsn: So it's the same size as GHC
07:43:49 <nyson> and Aplite seems very cool
07:43:53 <merijn> plus/minus epsilon
07:44:05 <chsn> STG is a very simple language right
07:44:10 <chsn> and GHC itself does all compiler optimizations
07:44:13 <chsn> so why is GHCJS so huge?
07:44:21 <merijn> chsn: Because it's literally GHC
07:44:39 * lonokhov thought GHCJS uses GHC as a library
07:44:46 <merijn> chsn: GHCJS doesn't consume output of GHC, it's a fork of the GHC codebase with an added JS backend and a JS runtime
07:44:54 <chsn> merijn: it's "cp GHC GHCJS; sed 's/asm/js' GHCJS/** -R" ?
07:44:59 <merijn> lonokhov: Is that not the same as being literally GHC?
07:45:03 <Cale> haha
07:45:19 <lonokhov> merijn: well, you don't have to rebase/merge that much
07:45:31 <merijn> chsn: You still need a runtime system and code generation
07:45:37 <Cale> chsn: You've discovered luite's top secret development method!
07:46:00 <merijn> chsn: Also, you have to make sure your code generation does not suck :)
07:46:15 <chsn> merijn: can I get around all that by "just writing a stg interpreter in js" ?
07:46:30 <merijn> chsn: I think you're underestimating lots of tricky details
07:46:42 <merijn> chsn: Such as: How do you implement Integer in JS
07:46:59 <chsn> merijn: oh right, arbitrary precision integers hmm
07:47:05 <merijn> JavaScript doesn't actually have integers, but code has to behave identical to Haskell integers
07:47:08 <nyson> trampolining isn't all that simple either
07:47:12 <merijn> chsn: Hell, just implementing Int is hard
07:47:29 <c_wraith> yay for float only languages 
07:47:30 <merijn> chsn: If you want a Int64 in GHCJS you have a problem
07:47:31 <Cale> Also, you can't "just" implement things quite the same way as the native RTS because you need the trampolining trick
07:47:37 <merijn> c_wraith: *double only
07:47:54 <c_wraith> still floating point. 
07:48:09 <merijn> chsn: Because JS only has doubles it cannot accuratel represent integers bigger than 2^53
07:48:20 <merijn> chsn: There's 100s of "tiny" problems like that you need to tackle
07:48:40 <Cale> chsn: Also, don't forget about threads
07:48:48 <merijn> Strings
07:48:56 <merijn> etc
07:48:58 <Cale> GHCJS gives you concurrency just like the native code generator
07:48:58 <chsn> Strings are just list of Chars
07:49:01 <nyson> I think haste implements int64 as two javascript nums together
07:49:04 <chsn> threads - continuation passing style?
07:49:08 <merijn> chsn: What is a Char in JS?
07:49:20 <chsn> merijn: a string of length 1
07:49:33 <nyson> Cale: haste uses a separate concurrent library based on koens poor mans concurrency monad
07:49:51 <merijn> chsn: Do JS strings support all bits of unicode?
07:50:06 <chsn> merijn: I have no clue.
07:50:48 <merijn> chsn: Right, so yet ANOTHER thing to check/implement/test, etc. :)
07:51:24 <Cale> GHCJS gives you a proper thread scheduler
07:51:36 <merijn> chsn: Clearly this is not impossible, luite did it after all, but it's easy to gloss over the 100s of edge cases and issues and incompatibilities, etc. you have to work around
07:51:48 <Cale> At least, if I recall correctly
07:51:57 <merijn> chsn: "Oh, I just need to translate functions to JS, it'll be 1k lines"
07:52:08 <kadoban> In summary: like anything else, it's super easy unless you ... actually have to do it.
07:52:15 <merijn> chsn: Catching everything is hard, catching everything and being fast is even harder :)
07:52:44 <merijn> kadoban: I would actually say it's super easy even if you have to do it. It's just crazy amounts of work :)
07:53:07 <merijn> Tedious annoying work too
07:53:13 <Gurkenglas> Still no verification email from hackage. Is anyone else able to create accounts?
07:53:17 <kadoban> Ya, differing versions of "easy", heh.
07:53:24 <Zemyla> Gurkenglas: Nope.
07:53:29 <Cale> I think it also has JS implementations of a bunch of C libraries so that libraries that do C FFI will also sometimes work.
07:53:40 <Cale> But I'm not sure about the extent of that
07:54:02 <Cale> I've just noticed that it's sort of unreasonable what things you can get to build and work sometimes. :)
07:54:02 <merijn> In other words, luite is a crazy masochist and we should all be grateful he did all the tedious hassle for us :)
07:54:03 <nyson> that sounds like a horrible workaround doing Haskell->C->JS when JS doesn't have real pointers
07:55:01 <merijn> But hey, at least he can claim his work powers public infrastructure :)
07:56:46 <chsn> I bet luite and the qemu guy is the same person, using two names, to avoid getting too much credit
07:57:01 <c_wraith> Yeah, making Bytestring work in ghcjs couldn't have been easy
07:57:02 <Welkin2> qemu?
07:57:17 <merijn> nyson: No, he was saying a bunch of C stuff had to get JS replacements so that Haskell libraries that use said C stuff can work on GHCJS too
07:57:24 <chsn> Welkin2: http://wiki.qemu.org/Main_Page
07:57:30 <chsn> Welkin2: it's an x86 emulator
07:57:34 <chsn> that can boot linux
07:57:51 <merijn> nyson: i.e. ByteString/Text use pointers internally, so that won't work in JS, so if people wanna use Haskell that uses ByteString he has to somehow make that work with GHCJS
07:58:13 <chsn> Welkin2: and it's been ported to JS: http://bellard.org/jslinux/
07:58:26 <chsn> you can boot linux on qemu in your browser
07:59:10 <nyson> merijn: ah, true
08:01:42 <Gurkenglas> Ah well as long as things keep not working at least I can churn out github issues https://github.com/haskell/hackage-server/issues/528
08:02:27 <Gurkenglas> Zemyla maybe you wanna add to that issue? Or even just say more things on here when they click on that ircbrowse link.
08:02:42 <Gurkenglas> *for when
08:03:08 <akegalj> is there any way to get statistics about how much memory does particular fields of some record datatype take? We are trying to prifile this but don't know proper way to do this. If it is ghc profiling, can you mention which combination of parameters. If it is using ekg library or other solution, what can you advice about that?
08:26:43 <saurabhnanda> any lens gurus here? is there any tutorial talking about how to change values within a deeply nested record?
08:26:58 <ertes> akegalj: one advice is to be patient and stay in the channel
08:27:22 <ertes> saurabhnanda: just compose the lenses
08:27:48 <saurabhnanda> ertes: line 102 at http://lpaste.net/177548#line102
08:27:50 <ertes> (_1 . _2 +~ 1) ((1, 1), (1, 1))
08:27:53 <ertes> > (_1 . _2 +~ 1) ((1, 1), (1, 1))
08:27:55 <lambdabot>  ((1,2),(1,1))
08:28:09 <ertes> second component of first component:  _1 . _2
08:29:00 <ertes> myRecord ^. myField . mySubfield . mySubsubfield
08:29:14 <saurabhnanda> ertes: wouldn't each of those need a ^.
08:29:17 <saurabhnanda> ?
08:30:13 <ertes> x ^. l1 ^. l2 = (x ^. l1) ^. l2  -- so it has the same effect as composition
08:30:31 <ertes> (x ^. l1) ^. l2 = x ^. (l1 . l2)
08:30:59 <ertes> a major point of lenses is that you can compose them
08:31:42 <saurabhnanda> okay, got that
08:31:59 <ertes> > ((10, 20), (30, 40)) ^. _1 ^. _2  -- get the fst, then get the snd of the result
08:32:01 <lambdabot>  20
08:32:12 <ertes> > ((10, 20), (30, 40)) ^. _1 . _2  -- get the snd of the fst
08:32:14 <lambdabot>  20
08:32:18 <saurabhnanda> when I go deep into a nested record and use  (%~) to replace it's value -- what does the entire expression evaluate to?
08:32:35 <ertes> to the same value with that particular field updated
08:32:51 <saurabhnanda> what type does the entire expression evaluate to? the outermost record's type, or the innermost record's type (the one I updated)?
08:33:14 <ertes> the outermost
08:33:35 <ertes> > (_1 . _2 *~ 10) ((1, 2), (3, 4))  -- you're updating an individual component, but the result is a tuple of tuples
08:33:36 <lambdabot>  ((1,20),(3,4))
08:34:03 <saurabhnanda> okay
08:34:13 <ertes> again, the point of lenses =)
08:34:17 <saurabhnanda> ertes: just by looking at the following expression, would you be able to help me with it?
08:34:17 <saurabhnanda> ((jsonHead ^. J.files ^. (ix 0)) & J.urls %~ (\us -> (urlEntityToJson u):us))
08:34:56 <saurabhnanda> Couldn't match type ‘J.File’ with ‘J.Download’
08:34:59 <saurabhnanda>      Expected type: Getting J.Download [J.File] J.Download
08:34:59 <saurabhnanda>        Actual type: (IxValue [J.File]
08:34:59 <saurabhnanda>                      -> Const J.Download (IxValue [J.File]))
08:35:00 <saurabhnanda>                     -> [J.File] -> Const J.Download [J.File]
08:35:02 <saurabhnanda>      In the second argument of ‘(^.)’, namely ‘(ix 0)’
08:35:04 <saurabhnanda>      In the first argument of ‘(&)’, namely
08:35:06 <saurabhnanda>        ‘(jsonHead ^. J.files ^. (ix 0))’ (intero)
08:35:08 <saurabhnanda> --- sorry for pasting that here.
08:35:29 <CubicE> saurabhnanda, use gist or pastebin or something along those lines for long texts
08:35:54 <ertes> first let me rewrite it: jsonHead ^. J.files . ix 0 & J.urls %~ (urlEntityToJson u :)
08:36:21 <ertes> so you're taking ix 0 of J.files of jsonHead, and you want to update *that* value
08:36:27 <ertes> you don't want to update jsonHead
08:36:29 <saurabhnanda> jsonHead :: J.Download // jsonHead ^. J.files :: [J.File] // jsonHead ^. J.files ^. J.urls :: [J.Url]
08:36:42 <ertes> is that your intention?
08:36:53 <saurabhnanda> ertes: yes
08:37:23 <saurabhnanda> ertes: and one more layer, inside the first element of J.files, which is basically a J.File, I want to update the field called J.url
08:37:26 <CubicE> Is there some kind of accepted way to create a binary distribution from a cabal package? Like, "here have a zip, unpack it and click on the executable and it just works"? Something I can just send to people and they don't even need to know it was made with haskell if they don't care
08:37:43 <ertes> so you want to get the following value:  the ix 0 of J.files of jsonHead, but that one with J.urls updated by prepending something
08:38:19 <ertes> saurabhnanda: wait, listen closely: you do *not* want to update jsonHead whatsoever…  you want to get a part of that value and update that one independently
08:38:20 <saurabhnanda> ertes: exactly, but I want it to evaluate to the new nested record. So the final type should be J.Download (which is the type of jsonHead)
08:38:21 <dcoutts> CubicE: for many cases it's as simple as: cabal copy --dest-dir=./image
08:38:50 <ertes> saurabhnanda: you do *not* get an updated jsonHead that way
08:39:25 <ertes> if you want to update jsonHead itself, you have to compose the lenses
08:39:30 <saurabhnanda> ertes: hmm, please continue..
08:39:50 <ertes> jsonHead & J.files . ix 0 . J.urls %~ (urlEntityToJson u :)
08:40:42 <CubicE> dcoutts, is there a stack equivalent for that?
08:40:48 <dcoutts> CubicE: probably
08:41:04 <ertes> saurabhnanda: if you first *view* (a.k.a. "get", a.k.a. (^.)) a subfield and then update that one, you will get that value updated, not the original value updated
08:41:37 <saurabhnanda> so (^.) is for viewing
08:41:37 <saurabhnanda> and (&) is for?
08:41:49 <ertes> (&) is just function application flipped
08:42:09 <saurabhnanda> opposite of ($)?
08:42:10 <ertes> saurabhnanda: myLens %~ f  -- this is a function
08:42:16 <saurabhnanda> :t (&)
08:42:18 <lambdabot> a -> (a -> b) -> b
08:42:51 <ertes> saurabhnanda: i mean this whole thing is a function:  (myLens %~ f), and with (&) you're applying it
08:43:22 <ertes> > _1 %~ (+ 1) $ (3, 4)
08:43:24 <lambdabot>  (4,4)
08:43:29 <ertes> > (3, 4) & _1 %~ (+ 1)
08:43:31 <lambdabot>  (4,4)
08:43:43 <saurabhnanda> what the...
08:43:58 <saurabhnanda> why reinvent function application for lenses?
08:44:20 <CubicE> saurabhnanda, not reinvent. Just write it the other way round for convenience
08:44:25 <ertes> because lens users like the OOP style of putting the updated thing first for some reason…  personally i don't like it =)
08:45:17 <saurabhnanda> so the way to read lenses is, here's a way to get to my required element (which is the composition part of lenses)
08:45:30 <saurabhnanda> once you get to it, here's what you have to change, which is the (%~) part of it
08:45:39 <saurabhnanda> and finally, here's the messy record that you need to do this on?
08:46:02 <ertes> lenses are like a path to a certain element…  you can view them together with a value and get that particular element
08:46:21 <ertes> or you can (%~) them, in which case you get a function that updates that particular element using the supplied function
08:46:31 <CubicE> It gets a lot clearer if you've seen the implementation
08:46:52 <jonored> so... lenses are xpath but for haskell structures?
08:47:12 <ertes> jonored: that's surprisingly accurate =)
08:47:25 <CubicE> I want to say no but I honestly can't say how that's wrong
08:47:53 <saurabhnanda> CubicE: okay, random rant. This is what I'm hating in haskell. Everything is clearer only once you've implemented it yourself. What's the point of abstraction then? Same thing happened with the Reader monad. #haskell walked me through the implementation, only then did I get it.
08:48:54 <ertes> saurabhnanda: for many of the basic functional abstractions we use that's the truth
08:49:02 <saurabhnanda> sorry about the rant. Please continue.
08:49:16 <ertes> the point of abstraction is not to *hide* something, but just to abstract over something
08:49:18 <CubicE> you don't need to know the actual implementation per se, but you do need to know how it works to use it properly. Kind of like while you don't need to know the HTTP RFC by heart, you do at least need the basic ideas behind it to write a http application
08:49:31 <bjs> saurabhnanda: abstraction makes it easier later, not right away
08:49:33 <ertes> saurabhnanda: well, that's all really
08:49:51 <jonored> The same could also be said of addition and multiplication.
08:50:04 <ertes> saurabhnanda: the basics of lenses is those three concepts:  lens composition, viewing, modifying
08:50:32 <saurabhnanda> ertes: that's fine. But when you're trying to get things done, those error messages...
08:50:56 <ertes> saurabhnanda: more reason to learn how they work =)
08:51:25 <saurabhnanda> ertes: nothing about those error messages make sense. I've been writing large-scale systems for 10 years now, and these error messages make me feel like a fresh-out-of-college programmer, staring at his first stacktrace, not knowing where to even begin.
08:51:52 <exDM69> learning experiences are the best!
08:51:54 <CubicE> saurabhnanda, well, have you been staring at haskell error messages for 10 years? 
08:51:56 <ertes> saurabhnanda: i have to admit: van laarhoven lenses are quite a brainteaser at first, because there is no proper abstraction *wrapper* as you would normally find with other abstractions
08:52:01 <c_wraith> saurabhnanda: so..  the same as an C++ error message involving templates. :)
08:52:16 <ertes> saurabhnanda: so you get weird error messages about weird functions and unsatisfied constraints
08:52:18 <CubicE> Haskell is much more different from C than C# or Java are
08:52:40 <ertes> saurabhnanda: with lenses i highly recommend that you learn them properly, i.e. reinvent them
08:52:40 <CubicE> so of course the concepts end up being somewhat different, and you need to learn some things over again
08:52:57 <ertes> saurabhnanda: it will take 2-3 hours of your life, but will pay back for a long time
08:53:02 <kadoban> saurabhnanda: Abstractions existing doesn't mean you can skip the *learning the abstraction* part.
08:53:32 <kadoban> However you learn, which can include reimplementing parts, seems fine to me.
08:54:05 <saurabhnanda> while that's true, in most other tech-stacks, you can live with the outer-shell of the abstraction for a while and get some stuff done. then you need to up your game gradually and understand it deeper. In haskell it seems like you need to understand everything at once.
08:54:08 <ertes> saurabhnanda: the main difference is that, say, with StateT you have that wrapping StateT type…  with lenses you get raw functions with higher rank types…  that's what makes the error messages confusing
08:54:47 <saurabhnanda> okay, need to get back to getting the code to work. Thanks a lot ertes
08:54:58 <saurabhnanda> will get back to the philosophical discussions in a while
08:55:31 <ertes> saurabhnanda: well, you should distinguish between two kinds of abstractions in haskell…  there is abstraction over functionality, which can very well have that "black box" feel to it (things like pandoc or hakyll)
08:55:57 <ertes> saurabhnanda: but lenses belong to the other type of abstraction:  a pattern abstraction, that you really need to understand from the ground up
08:56:25 <ertes> sorry, but you really have to learn it
08:56:37 <ertes> (and you won't regret having done it)
08:57:13 <CubicE> compare learning how to use vector in C++ and how to use the pimpl idiom or how template metaprogramming works
08:57:28 <Gurkenglas> How do I make stack sdist include documentation?
08:58:44 <ParkeT> Hi gyus. Can somebody explain how (and why) this works? http://pastebin.com/RWwLFZpC
08:58:53 <kadoban> Gurkenglas: I don't think you do (unless that's been added recently)
08:59:28 <ertes> ParkeT: you have defined a function called (.)
08:59:49 <ertes> ParkeT: it takes two arguments that you have called (+) and (*), ignores them and just results in 10
09:00:14 <ongy> Gurkenglas: if you can use cabal, there's the cabal haddock --for-hackage. And a script floating around that builds and uploads documentation (as a 2nd step to code upload)
09:00:39 <Gurkenglas> Just put stack exec -- in front right x)
09:00:44 <ertes> > let (+) . (*) = (+)^2 - (*)^2 in 4 . 3
09:00:46 <lambdabot>  7
09:00:52 <ertes> ParkeT: ^
09:00:52 <ParkeT> Oh. Shi... U are right. Shame on me!
09:01:11 <pavonia> Why does withCAString use this weird loop internally instead of using withArray0 the same way withCWString does? Is there a subtle difference I cannot spot? https://hackage.haskell.org/package/base-4.9.0.0/docs/src/Foreign.C.String.html#withCAString
09:03:41 <aesonlenshelp> How would I access the b1 key here: "{ \"a\": 0, \"b\": [{\"b1\": 0}, {\"b2\": 0}]}" ^? key "b"
09:03:44 <ParkeT> Ok. The next question. How can i use it's arguments inside of my new function? 
09:03:56 <aesonlenshelp> the above returns: Just (Array [Object (fromList [("b1",Number 0.0)]),Object (fromList [("b2",Number 0.0)])])
09:05:56 <ParkeT> <ertes> Your solution, with let, works fine. Coll. Thanks guys. ^_^
09:09:57 <pavonia> aesonlenshelp: Objects are just HashMaps in aeson, so you can use the functions from that for accessing values
09:11:58 <glguy> aesonlenshelp: key "b" . nth 0 . key "b1"
09:12:49 <aesonlenshelp> pavonia: Thanks. I basically want to lookup another key inside of one of those
09:13:16 <aesonlenshelp> glguy: Is there a way I could use over (or something) to look for results from any keys named "b1"?
09:14:04 <baordog_> Good morning
09:14:12 <ski> Good evening
09:14:25 <baordog_> Does anyone know any hackerone style coding competitions that take haskell? Sorry to see it isn't commonly accepted. 
09:15:34 * ski doesn't know
09:15:50 <Gurkenglas> aesonlenshelp, try "{ \"a\": 0, \"b\": [{\"b1\": 0}, {\"b2\": 0}]}" ^? key "b" . _Array . ix 0 . _Object . ix b1
09:16:13 <kadoban> baordog_: hackerrank does, though it's a kinda old version of GHC, I think some of the others do as well.
09:16:36 <kadoban> SPOJ does
09:17:16 <Gurkenglas> Also "This module also exports orphan Ixed Value and Plated Value instances." at the top of http://hackage.haskell.org/package/lens-aeson-1.0.0.5/docs/Data-Aeson-Lens.html so http://hackage.haskell.org/package/lens-aeson-1.0.0.5/docs/src/Data.Aeson.Lens.html#line-449 makes it look like you can leave out the ". _Object " part
09:17:57 <acertain> what's the best way to `MTLStackT Maybe a -> MTLStackT Identity (Maybe a)`?
09:18:25 <Gurkenglas> http://hayoo.fh-wedel.de/?query=MTLStackT o.o
09:18:52 <aesonlenshelp> Gurkenglas: I'm sorry I wasn't clear. I want to check inside of b for a key named "b1" that would check both "b1" and "b2"
09:19:35 <Gurkenglas> aesonlenshelp, you mean look through each part of the Array? try "{ \"a\": 0, \"b\": [{\"b1\": 0}, {\"b2\": 0}]}" ^? key "b" . _Array . each . _Object . ix b1
09:19:39 <acertain> Gurkenglas, e.g. `newtype MTLStackT m a = MTLStackT (StateT s (ReaderT r m) a)`
09:19:41 <Gurkenglas> (Again, _Object is optional)
09:19:50 <aesonlenshelp> Gurkenglas: Yeah, I think thats it. Trying it now
09:20:45 <Gurkenglas> aesonlenshelp, that "b" provides an array of singletons is confusing anyway, shouldn't that all be one Object?
09:22:18 <Gurkenglas> acertain, how indeed: StateT s Maybe a -> State s (Maybe a) is (s -> Maybe (a, s)) -> (s -> (Maybe a, s)). Where does the last s come from? Just repeat the given s?
09:22:33 <aesonlenshelp> Gurkenglas: Exactly. A config I'm working with basically uses top level keys as categories with values, with some values also being on the top level. I've wrote something to search the top level, but I need something to also search within a specified category.
09:25:03 <aesonlenshelp> Gurkenglas: So out of "{ \"attr1\": 0, \"category1\": [{\"attr2\": 0}, {\"attr3\": 0}]}\n" I would search the top level for attr3 as well as category 1  for attr3. Does lens have a notion of alternatives?
09:26:06 <Gurkenglas> I don't think you can have a union of traversals, because you'd have to way to prove two traversals to be union'd are disjoint
09:26:16 <ski> acertain : not in scope : `s',`r'
09:26:18 <ski> @unmtl StateT s (ReaderT r Maybe) a
09:26:18 <lambdabot> s -> r -> Maybe (a, s)
09:26:21 <ski> @unmtl StateT s (ReaderT r Identity) (Maybe a)
09:26:21 <lambdabot> s -> r -> (Maybe a, s)
09:26:23 <Gurkenglas> Though I'd be like to be proven wrong there
09:26:40 <ski> @djinn (s -> r -> Maybe (a, s)) -> /s -> r -> (Maybe a, s)(
09:26:40 <lambdabot> Cannot parse command
09:26:46 <ski> @djinn (s -> r -> Maybe (a, s)) -> (s -> r -> (Maybe a, s))
09:26:46 <lambdabot> f a b c =
09:26:46 <lambdabot>     case a b c of
09:26:46 <lambdabot>     Nothing -> (Nothing, b)
09:26:46 <lambdabot>     Just (d, e) -> (Just d, e)
09:27:23 <ski> acertain : did you want that behaviour, or ?
09:28:35 <glguy> aesonlenshelp: So you want to visit all keys "attr3" that are either at the top-level or one level down? and do what to them?
09:28:39 * hackagebot micrologger 0.3.1.0 - A super simple logging module. Only for use for very simple projects.  https://hackage.haskell.org/package/micrologger-0.3.1.0 (savannidgerinel)
09:29:43 <aesonlenshelp> glguy: I'm just trying to find the value of "attr3", either in the top level or under a specified "category"
09:30:04 <aesonlenshelp> to make the example comprehensive
09:30:38 <Gurkenglas> Oh wait Folds have a monoid instance
09:30:52 <aesonlenshelp> "{ \"attr1\": 0, \"category1\": [{\"attr2\": 0}, {\"attr3\": 0}], \"category2\": [{\"attr2\": 0}, {\"attr3\": 0}]}\n" I am targeting attr3 in category 1 or in the top level
09:30:59 <aesonlenshelp> and don't want to match attr3 in category2
09:31:01 <glguy> aesonlenshelp: It sounds like you'll end up needing the 'failing' function
09:31:40 <glguy> so you can do: failing (key "attr3") (key "category1" . nth 0 . key "attr3") or whatever your logic was
09:31:54 <Gurkenglas> So try "{ \"a\": 0, \"b\": [{\"b1\": 0}, {\"b2\": 0}]}" ^? (ix "b1" <> (key "b" . _Array . each . ix "b1")) -- not sure which of those brakcets are needed
09:32:39 <Gurkenglas> So try "{ \"a\": 0, \"b\": [{\"b1\": 0}, {\"b2\": 0}]}" ^? (key "b1" <> (key "b" . _Array . each . ix "b1")) -- or maybe this not sure when to use key or ix there
09:32:49 <Gurkenglas> -the last So try
09:34:25 <Welkin> lenses compose backwards o.o
09:34:28 <Welkin> so weird to read
09:34:30 <Welkin> always confuses me
09:34:56 <glguy> stop thinking of them as accessors and they'll make more sense
09:34:57 <Gurkenglas> They compose backwards the same way (fmap . map . first) does
09:35:15 <Welkin> eh?
09:35:20 <Welkin> regular compisition is right to left
09:35:26 <Welkin> lenses compose left to right, I thought
09:35:35 <glguy> lenses compose like regular composition
09:35:42 <glguy> they modify functions, then aren't "getters"
09:35:48 <Gurkenglas> A lens transforms a small modification into a big modification
09:36:03 <Welkin> then I don't understand that example
09:36:14 <Welkin> how can you acces "b1" before you access "b"?
09:36:39 <glguy> (key "a" . key "b") f
09:36:42 <Gurkenglas> Welkin, he's looking for "b1" on the top level and in "b", in this example there happens not to be a "b1" at the top level
09:36:50 <Welkin> oh
09:36:53 <glguy> first it's modifying a function that works on some value to one that works on some value contained inside key b
09:37:10 <glguy> next you take that and get one that works on b keys inside a key a
09:39:14 <glguy> aesonlenshelp: Anyway, the behavior you wanted it captured by: failing (key "attr3") (key "category1" . values . key "attr3")
09:39:19 <Gurkenglas> Ah key is a specialized-to-text optimized version of ix, so aesonlenshelp: (key "b1" <> (key "b" . _Array . each . key "b1"))
09:39:34 <glguy> The <> will be less useful
09:39:51 <glguy> and _Array . each is better as values
09:40:09 <Gurkenglas> Agreed on the last one
09:40:12 <Gurkenglas> But what's wrong with <>?
09:40:25 <glguy> It only gets you a Fold
09:41:36 <c_wraith> I wish <|> was an infix version of failing. but it can't be, here. 
09:43:17 <Gurkenglas> You can have failing, which already is only lawful if used correctly, but not a union of traversals? :(
09:43:39 <glguy> Hmm, maybe it's not limited to Fold, but it ends up meaning something different, one only falls through to the second attr3 if the first doesn't match
09:43:55 <c_wraith> I think failing is lawful in any case. 
09:44:06 <c_wraith> are you sure you're not thinking of filtered? 
09:44:30 <glguy> This is only a valid Traversal if the second Traversal is disjoint from the result of the first or returns exactly the same results. These conditions are trivially met when given a Lens, Iso, Getter, Prism or "affine" Traversal -- one that has 0 or 1 target.
09:44:40 <c_wraith> ah
09:45:31 <c_wraith> you can certainly glue traversal together with <>, but they won't be lawful either. 
09:45:44 <Gurkenglas> Huh that works?
09:46:06 <johnw> I believe it works because traversals are simply functions
09:46:50 <Gurkenglas> :t (each <> ix 2) %~ (+1) $ [0,0,0,0,0,0] -- doesnt look like
09:46:51 <lambdabot> (Num a, Monoid (Identity [a])) => [a]
09:47:35 <aesonlenshelp> glguy, Gurkenglas : Thanks! I'll try those in a bit
09:47:52 <aesonlenshelp> looks like exactly what I need
09:48:42 <aesonlenshelp> it is :)
09:48:49 <Gurkenglas> http://hackage.haskell.org/package/lens-4.14/docs/src/Control.Lens.Traversal.html#failing doesnt this go through the first traversal twice if it works?
09:50:05 <Gurkenglas> Oh it'd stop at the first match wouldn't it. Though if the first match is very late, it'd need to go uselessly through what it already has gone through?
09:52:24 <ski> Welkin : seen SEC yet ?
09:52:31 <Welkin> ski: what's that?
09:52:37 <ski> @where SEC
09:52:37 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
09:52:45 <ski> (predates lenses)
09:53:41 <ski> @type fmap . map . first  ::  Functor f => (a0 -> a1) -> f [(a0,b)] -> f [(a1,b)]  -- Gurkenglas' example
09:53:42 <lambdabot> Functor f => (a0 -> a1) -> f [(a0, b)] -> f [(a1, b)]
09:54:29 <ski> `first' will convert a function of type `a0 -> a1' into one of type `(a0,b) -> (a1,b)', operating on the first component of the pair
09:55:11 <ski> then `map' will convert that function of type `(a0,b) -> (a1,b)' into one of type `[(a0,b)] -> [(a1,b)]', operating ("in turn") on each element of the list
09:56:25 <ski> then `fmap' will convert that function of type `[(a0,b)] -> [(a1,b)]' into one of type `f [(a0,b)] -> f [(a1,b)]' (provided `Functor f' holds), operating in turn on each "element" of the functor "collection/structure"
09:57:02 <ski> Welkin : this is "right to left" composition, as usual
09:58:43 <ski> Welkin : it's another matter than you can here also choose to view the same thing as describing how you can effect a "modification" of a value of a type with shape `f [(...,b)]', provided you specify how to "modify" the value(s) corresponding to the selected `...' part (the "hole")
09:59:40 <ski> Welkin : namely, reading from left to right, `fmap' will first "focus" (or "step into") the `f ...' part, going from the overall shape to `f [(...,b)]' to `[(...,b)]'
10:00:04 <ski> Welkin : then `map' will focus into `[...]', so going now from `[(...,b)]' to `(...,b)'
10:00:13 <Welkin> that makes some more sense
10:00:51 <ski> Welkin : finally, `first' will focus into `(...,b)', so just going from `(...,b)' to `...', at which point the provided "individual" modification function (of type `a0 -> a1') will be applied
10:02:21 <ski> @let res :: (b0 -> b1) -> ((a -> b0) -> (a -> b1)); res mod f = mod . f  -- for "result"
10:02:23 <lambdabot>  Defined.
10:02:43 <ski> @let arg :: (a1 -> a0) -> ((a0 -> b) -> (a1 -> b)); arg mod f = f . mod  -- for "argument"
10:02:44 <lambdabot>  Defined.
10:03:11 <ski> `res' and `arg' can be similarly used to "focus" into the "result type" and the "argument type" of a function
10:03:27 <ski> @type res . res . arg . map
10:03:28 <lambdabot> (a2 -> b1) -> (a -> a1 -> [b1] -> b) -> a -> a1 -> [a2] -> b
10:04:01 <ski> will focus on each of the elements of the list which is passed as the "third argument" of the function
10:04:28 <johnw> ski: aren't your "res" and "arg" the same as lmap and rmap?
10:04:33 <ski> (btw, note how the modification function in case of `arg' is reversed. if you use `arg' twice, then it is reversed again, back to "forward direction")
10:05:44 <ski> @let infixr 9 ~->; (~->) :: (a1 -> a0) -> (b0 -> b1) -> ((a0 -> b0) -> (a1 -> b1)); (modArg ~-> modRes) f = modRes . f . modArg
10:05:46 <lambdabot>  Defined.
10:06:44 <ski> is a more general SEC, for (possibly) modifying / focusing on both the argument type and the result type of a function. note that `res mod = id ~-> mod' and `arg mod = mod ~-> id'
10:07:34 <schell> there’s an editor someone is working on that allows you to edit haskell using the syntax tree - does anyone remember the name or the author? 
10:07:42 <ski> @let onLines :: ([String] -> [String]) -> (String -> String); onLines = lines ~-> unlines
10:07:43 <lambdabot>  Defined.
10:08:19 <ski> @let perLine :: (String -> String) -> (String -> String); perLine = onLines . map
10:08:20 <lambdabot>  Defined.
10:08:45 <ski> Welkin : that's an example of how `~->' could be used
10:08:47 <ski> see
10:08:50 <ski> @where TV
10:08:50 <lambdabot> http://www.haskell.org/haskellwiki/TV
10:08:56 <ski> for where that came from
10:09:01 <schell> schell: lamdu! thanks ;)
10:10:04 <ski> johnw : possibly. though i can never recall whether profunctors are the same as difunctors or not
10:10:30 <ski> (or rather, `lmap' and `rmap' would then be generalizations)
10:10:43 <johnw> what is a difunctor?
10:11:18 <ski> a functor from `C^op * C' to `D', for some categories `C' and `D'
10:11:26 <johnw> oh, then yes, the very same
10:11:58 <ski> (possibly even from `C^op * D' to `E', for some specific categories `C',`D',`E' you have in mind, when you'd rather not consider `C^op' instead of `C')
10:11:59 <shachaf> A profunctor is more general, I think: C^op * D -> E
10:12:18 <shachaf> OK, then maybe not more general.
10:12:32 <johnw> according to Wikipedia, it's D^op * C -> Set
10:14:16 <ski> schell : Peaker
10:14:22 <Ed_> Hello. So I have a integer of type String and I want to sum up all the digits of that integer. If str = "1234" then I generate the list of digits as [(read [y] :: Int) | y <- str] but it won't let me do a foldl (+) ... on it
10:14:26 <baordog_> Profunctor? 
10:14:28 <schell> ski: thankyou :)
10:14:53 <Ed_> this is a codeeval challenge im doing as practice...
10:15:19 <ski> @type digitToInt
10:15:21 <lambdabot> Char -> Int
10:15:24 <kadoban> Ed_: Use a function :: Char -> Int   or  :: Char -> Maybe Int, depending on how safe you want this to be
10:16:10 <baordog_> Where can I find the official documentation for haskell's type notation? 
10:16:11 <Welkin> ski: thanks for the detailed example
10:16:20 <baordog_> like a -> b -> c etc...
10:16:27 <Ed_> but isn't digitToInt part of some package/library?
10:16:35 <ski> Ed_ : perhaps you meant `foldl1 (+)' or `foldl (+) 0' or `sum' ?
10:17:07 <kadoban> Ed_: It's in the module Data.Char, from the 'base' package that comes with GHC.
10:17:25 <ski> Welkin : anyway, afaiu, (edwardk's) lenses can be seen as an "upgraded" version of the above SEC idea, so i think it can help to grok the latter first
10:17:41 <ski> baordog_ : in the Haskell report
10:17:55 <ski> @where report
10:17:55 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
10:18:15 <Ed_> My GHC can't find digitToInt (Not in scope: 'digitToInt')
10:18:15 <ski> Ed_ : so `import Data.Char' ?
10:18:36 <Ed_> but I don't think I can import anything in CodeEval... I'll try
10:19:39 <baordog_> ski: Thanks
10:19:50 <kadoban> Ed_: It's not a difficult function to implement yourself if you have to. Consider it a separate exercise if you don't see how.
10:20:27 <Ed_> how do I install Data.Char into my GHC?
10:20:45 <Welkin> it's already there
10:20:46 <Welkin> in base
10:22:00 <Ed_> But do I have to import Data.Char every time?
10:22:10 <ski> baordog_ : `Int -> [Double] -> String', which is short for `Int -> ([Double] -> String)' means : the type of functions which will accept an `Int' as argument and returns : a function which will accept a list of `Double's as argument and returns : a `String'
10:22:51 <ski> baordog_ : to abbreviate that, we say that it's the type of functions which will accept an `Int' and a list of `Double's as the two arguments, before returning a `String'
10:23:25 <ski> Ed_ : in every module you want to use `digitToInt', yes (unless you reexport it from another module and import that one)
10:26:40 <Ed_> @type foldl
10:26:41 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
10:26:53 <Ed_> @type foldl1
10:26:54 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
10:26:56 <baordog_> ski: I seem to recall more complex situations being possible, like specifying something like a -> mondad -> b or a -> applicative -> c somehow. 
10:27:02 <ski> baordog_ : really, every function in Haskell takes exactly one argument. but we tend to get a little sloppy with the wording sometimes, to ease on the wording. it's ok as long as you understand the bottom reality, and that the others you talk to also understand it, and understand the type you're describing in such sloppy wording
10:27:23 <Ed_> difference between foldl and foldl1?
10:27:38 <baordog_> I just want to understand the exact syntax rules so I can construct types without being totally ignorant. 
10:27:52 <c_wraith> Ed_, the types explain the difference pretty well. 
10:28:01 <ski> baordog_ : a more advanced example could be a function of type `([String] -> [String]) -> (String -> String)' (being the same as the type `([String] -> [String]) -> String -> String', but not the same as `[String] -> [String] -> (String -> String)', nor `[String] -> [String] -> String -> String')
10:29:02 <c_wraith> Ed_, foldl1 uses the first element of the list as the initial accumulator state. it breaks when there is no first element 
10:29:24 <ski> baordog_ : that would be the type of a function that takes a *callback* function as argument (which is expected to accept lists of `String's and return lists of `String's), and returns a new function (probably depending on the previous argument, iow the callback function) that will accept a `String' and return a `String'
10:30:13 <ski> baordog_ : so it transforms a function operating (here, taking as input and returning as output) on lists of `String's into a function operating on (single) `String's
10:31:02 <ski> baordog_ : the alternate way to write this type, `([String] -> [String]) -> String -> String' suggests that you can also think of a function of this type as taking one callback function as argument, and also a `String' as argument, before returning a `String'
10:32:04 <ski> @let onWords :: ([String] -> [String]) -> (String -> String); onWords = words ~-> unwords  -- never mind the implementation of this, for now
10:32:05 <lambdabot>  Defined.
10:32:26 <ski> @let perWord :: (String -> String) -> (String -> String); perWord = onWord . map  -- ditto
10:32:27 <lambdabot>  .L.hs:188:11:
10:32:27 <lambdabot>      Not in scope: ‘onWord’
10:32:27 <lambdabot>      Perhaps you meant ‘onWords’ (line 185)
10:32:35 <ski> @let perWord :: (String -> String) -> (String -> String); perWord = onWords . map  -- ditto
10:32:36 <lambdabot>  Defined.
10:33:33 <ski> > onWords reverse "The quick brown fox jumps over the lazy dog"  -- example use of `onWords', applying the callback `reverse' on each word
10:33:35 <lambdabot>  "dog lazy the over jumps fox brown quick The"
10:33:59 <ski> er, rather .. applying it on the whole list of words, once
10:34:16 <ski> > perWord reverse "The quick brown fox jumps over the lazy dog"  -- example use of `perWord', applying the callback `reverse' on each word
10:34:18 <lambdabot>  "ehT kciuq nworb xof spmuj revo eht yzal god"
10:34:48 <ski> > words "The quick brown fox jumps over the lazy dog"  -- `words' splits a `String' into a list of `String's, on whitespace boundaries
10:34:49 <lambdabot>  ["The","quick","brown","fox","jumps","over","the","lazy","dog"]
10:35:05 <ski> > unwords ["The","quick","brown","fox","jumps","over","the","lazy","dog"]  -- `unwords' goes in the other direction
10:35:07 <lambdabot>  "The quick brown fox jumps over the lazy dog"
10:35:45 <ski> baordog_ : that's just to attempt to give some small hint of what can be possible with types like `([String] -> [String]) -> String -> String'
10:36:06 <baordog_> Gotcha. 
10:36:07 <ski> baordog_ : anyway, if in doubt, use extra brackets when writing types
10:36:30 <baordog_> But isn't there a notation like a-> b a -> c or some such. 
10:36:37 <baordog_> or a -> f a -> c
10:37:09 <ski> baordog_ : the simplest way to think of function signatures is that it's like `functionName :: ArgumentType0 -> ArgumentType1 -> ArgumenType2 -> ... -> ArgumentTypeLast -> ResultType'
10:37:39 <ski> yes, you can have types that look like `b a' or `f a', or `Maybe String' or `IO Integer' for concreteness
10:37:50 <ski> `[String]' is the type of lists of `String's
10:38:18 <divVerent> Does that make ([]) a "circumfix operator"? ;)
10:39:01 <divVerent> (referring to the fact that [String] is just another way to write [] String)
10:39:24 <geekosaur> as implemented, it's syntax. circumfix isn't really a thing in Haskell
10:39:27 <ski> `IO Integer' is the type of I/O (iow interactive) programs ("recipies", if you want), that, when *executed*, will interact with the environment/context in which the process is running (possibly including the universe outside the computer), and (perhaps) yield a `Integer' as result afterwards
10:39:38 <ski> (it might also abort the current computation with an exception)
10:40:04 <divVerent> geekosaur: right, you can't define your own "circumfixes".
10:40:52 <ski> the only way in which an I/O action can be executed is if either (a) it's part of another I/O action that's being executed; or (b) it's the `main' entry point to the compiled program; (or (c) it's entered directly into an interactor like GHCi)
10:41:20 <divVerent> speaking of crazy syntax... I somehow love TupleSections
10:41:26 <ski> so, ultimately, the only way to start execution will be to make `main' (or your testing expression in the interactor) eventually execute it
10:42:19 <ski> in particular, you can't e.g. make a function of type `Blah -> [String]' execute an I/O action, nor can it be executed because some expression is *evaluated*
10:42:40 <ski> "evaluation" and "execution" are separate concepts in Haskell. the latter can cause the former, but not vice versa
10:43:04 <ski> divVerent : sometimes called "distfix" (slightly more general term)
10:43:09 <ski> also there's "mixfix"
10:43:23 <divVerent> ski: right
10:43:46 <divVerent> I suppose that's how one could call constructs like (a,,b,) c d when seeing the a and b as constants
10:43:54 <ski> (`... ? ... : ...' and `if ... then ... else ...' being examples of mixfix)
10:44:02 <divVerent> or, of course, the examples there, if-then-else and similar
10:45:02 <ski> baordog_ : i'm not sure whether you followed much re I/O. i figured i'd just add it, in case it was useful at this point
10:46:28 <ski> baordog_ : there's also something that looks like `=>' in types. that doesn't signify a function type (as `->') does, but instead signifies a "constraint" on (normally) "type variables"
10:47:20 <ski> baordog_ : `reverse :: [a] -> [a]' is the type signature of a function that can reverse a list of `a's, for any actual type we use in place of `a' (e.g. `Integer', or `[String]')
10:48:48 <ski> baordog_ : but sometimes, such a function doesn't work for *all* types `a', but only for "numeric" ones, or for ones supporting ordering operations, &c. .. e.g. `sort :: Ord a => [a] -> [a]' can sort a list of `a's, for any type `a', *provided* (the constraint) `a' supports ordering operations
10:49:10 <ski> baordog_ : i'll stop here, unless you have more questions
10:56:28 <lambdamu> Hi does anyone have advice for performant type level computation? a type family mergesort eats 5 gigabyte memory to sort 24 elements until I kill it
10:57:17 <dmwit> Use a more suitable language...?
10:57:35 <lambdamu> is there something specific that can avoided to keep performance in check or is it just generally to unomptimized?
10:57:48 <lambdamu> dmwit: you realize this isn't helpful?
10:58:31 <lambdamu> dmwit: unless you have a type level ffi
11:00:57 <dmwit> The only advice I know is to purge your brain of lazy evaluation tricks, because the type level is not lazily evaluated.
11:01:23 <dmwit> I don't think you can rely on it being strictly evaluated, either. So often you have to try both the version that works well with laziness and the version that works well with strictness to see which is better.
11:01:34 <Cale> lambdamu: Perhaps try insertion sort instead? :)
11:03:03 <dmwit> And I think there are other situations where my original advice could be useful than just "there exists a type-level FFI". =)
11:03:11 * koomi would recommend searching for a simpler solution to the actual problem at hand
11:03:20 <koomi> but I have a feeling that won't be seen as helpful either
11:03:42 <Cale> Yeah, I don't really understand why, in Haskell, you would be performing a mergesort at the type level.
11:03:49 <lambdamu> dmwit: Ah that was another question of mine, this blog post suggests the evaluation order coincidences with the lazy term level language: http://lambda.jstolarek.com/2014/09/promoting-functions-to-type-families-in-haskell/
11:03:58 <Cale> Apart from some sort of attempt to one-up oleg :)
11:04:41 <dmwit> lambdamu: Well, semanticses generally don't talk about evaluation time or space requirements.
11:05:13 <lambdamu> Cale: you mean you wouldn't sort in general at the type-level or that you can understand why someone uses mergesort specifically?
11:05:14 <ReinH> isn't... isn't semantics already plural?
11:05:24 <ReinH> or is it its own plural? something?
11:05:36 <lambdamu> dmwit: well operational semantics do
11:05:37 <Cale> lambdamu: Well, I intended the first, but really both.
11:05:38 <dmwit> Probably. I was having a bit of fun. =)
11:05:48 <ReinH> dmwit: no fun allowed
11:06:56 <dmwit> lambdamu: That blog post does not appear to talk much about operational semantics.
11:07:08 <lambdamu> Cale: mergesort isn't really harder for me to do than insertion or selection sort and sorting is necessary for sets
11:07:15 <mniip> [19:04] (Cale) [18:03:20] Yeah, I don't really understand why, in Haskell, you would be performing a mergesort at the type level.
11:07:24 <lambdamu> Cale: but you might think those are unnecessary at the type level, too
11:07:26 <Cale> lambdamu: Most of the reasons I can imagine wanting to sort something at the type level involve scenarios which aren't really well-suited to Haskell in the first place, and would be better carried out in a dependently typed language proper.
11:07:27 <mniip> so that you can compare sets of types
11:07:31 <Gurkenglas> Can I use stack solver to modify the global config?
11:07:33 <dmwit> Just the sentence, "Type-level computations performed by GHC are about constraint solving.", and maybe "we have an order of dependencies between the closures and there is a way which we can run these closures to get the final result.".
11:07:43 <Gurkenglas> (In order to stack install a package)
11:08:12 <Gurkenglas> ( http://lpaste.net/2879106647991517184 )
11:08:31 <Cale> mniip: Or bags of them, I suppose. But why?
11:08:42 <lambdamu> dmwit: no but it mentions the lazy vs. strict question at the type level
11:09:15 <mniip> so that you can manipulate data types making use of those
11:09:36 <mniip> you can probably come up with a datatype utilising a set yourself
11:10:02 <dmwit> lambdamu: Yes. But a non-strict semantics does not imply a lazy implementation strategy.
11:10:02 <Cale> I can come up with use cases for such things, but not ones which would be practical in Haskell.
11:10:25 <lambdamu> dmwit: you mean it doesn't imply efficient implementation?
11:11:39 <dmwit> Strict implementations can be efficient, assuming the programs are written with that in mind.
11:11:43 <dmwit> So no, I don't think I mean that.
11:12:11 <Cale> A set of types is more useful if you get to use it, say, in a dependent pair or something -- so you can say "I have this set of types, and this thing is going to pick one of them, and give you the type selected, along with an element of *that* type."
11:12:17 <lambdamu> dmwit: Well thats true
11:12:43 <lambdamu> dmwit: but I think I get what you mean
11:15:45 <jonored> did I hear something about template haskell not having access to some of this information? Because apart from that, this sounds very "why aren't you shifting this into the full langauge instead of just type programming" to me.
11:15:54 <Cale> Or, you know, maybe in a dependently typed language you want to express that merge sort is a sort, which will involve using merge sort at the type level (though not on a specific list of elements, it would probably be applied only to variables)
11:16:12 <Cale> But in Haskell, that doesn't make sense, because it's not the same function.
11:18:11 <Cale> So I dunno, this feels like either an XY problem, or a desire to use Coq/Agda/Idris instead of Haskell.
11:18:35 <lambdamu> jonored: was that directed at me? If so I don't quite get what you mean
11:19:01 <johnw> Cale: does that make it an { x : X | Y x } problem?
11:23:08 <saurabhnanda> ertes: thanks for the lens help. The code at least compiles now.
11:23:30 <saurabhnanda> :t (:)
11:23:31 <lambdabot> a -> [a] -> [a]
11:26:32 <ertes> saurabhnanda: glad to help
11:28:39 <baordog_> ski: Thanks. I'm sure I'll run up against an edge case somewhere lol
11:29:11 <aesonlenshelp> My json I'm working with is even sillier than I thought, How would I filter based on "key" (the duplicated json object identifier in this list of json objects). Here is my attempt: "[{\"key\": \"key1\", \"value\": \"val1\"}, {\"key\": \"key2\", \"value\": \"val2\"}]\n" ^. ifiltered (const True) . ix 0
11:32:02 <saurabhnanda> advanced haskell question -- it is possible to make a type polymorphic in the **field name** of a record?
11:32:35 <saurabhnanda> eg. data JsonResponse fieldName fieldType = JsonResponse { fieldName :: fieldType } 
11:32:48 <ertes> saurabhnanda: no(t with haskell records), but lenses are values
11:32:54 <ertes> so you can take or return lenses
11:34:27 <saurabhnanda> ertes: how will lenses help in this case?
11:34:51 <saurabhnanda> basically my webapp needs to return JSONs with a root-key
11:34:57 <ertes> saurabhnanda: if you need to associate values with *types*, you need a bit of help from the type system…  common solutions include reflection and implicit parameters
11:34:59 <saurabhnanda> the root-key typically has the same name as the entity being returned
11:35:29 <ertes> saurabhnanda: so the name is itself a value you want to keep track of?
11:35:50 <saurabhnanda> ertes: actually, not that interested in keeping track of it
11:35:58 <saurabhnanda> this JSON occurs at the very boundary of my app
11:36:08 <saurabhnanda> just when the data is about to be pushed to the wire
11:36:24 <saurabhnanda> but it's causing boilerplate types for every entity that needs to be sent out
11:36:33 <saurabhnanda> is it a better idea to write my own toJSON function to handle this?
11:36:41 <ertes> possibly
11:36:44 <saurabhnanda> myToJson rootName rootObject
11:37:06 <ertes> you can keep track of the name as an extra field, or you can associate it with the type using reflection…  in most cases the former is simpler and preferable
11:37:11 <saurabhnanda> but if I switch my code from Yesod to Servant this will become a problem
11:37:12 <ertes> then you can just write a custom ToJSON instance
11:37:41 <ertes> not a custom toJSON function, but a custom instance that produces the JSON you need
11:37:48 <saurabhnanda> basically servant has strongly types JSON endpoints. And that helps it give you automated API docs.
11:38:13 <saurabhnanda> going down this route, will take away my ability to use Servant OR servant's ability to type-check and give me API docs
11:38:38 <ertes> i'm not sure why…  it does use aeson's FromJSON and ToJSON classes, doesn't it?
11:39:48 <saurabhnanda> ertes: ah got it
11:40:00 <saurabhnanda> there's no need to write myToJson name type
11:40:16 <saurabhnanda> just write a ToJSON instance for each type, which wraps it in the top-level root node
11:40:17 <ertes> saurabhnanda: the first (dynamic) solution is:  data MyType = MyType { fieldName :: String, fieldContent :: Integer }
11:40:21 <saurabhnanda> still results in a bit of boiler-plate
11:40:31 <ertes> (you can abstract the Integer, but it doesn't matter for demonstration)
11:41:02 <ertes> saurabhnanda: the second (static) solution is:  newtype MyType name = MyType { fieldContent :: Integer }
11:41:03 <saurabhnanda> I'm sure this is possible using Data.Typeable and GHC.Generics
11:41:39 <ertes> in the latter case the ToJSON instance looks like this:  instance (Reifies name String) => ToJSON (MyType name) where …
11:42:52 <ertes> the latter makes the field name type-bound rather than value-bound, which can be useful for book-keeping
11:42:54 <saurabhnanda> is that pseudo code or actual code?
11:42:57 <ertes> actual code
11:43:01 <ertes> using the reflection library
11:43:13 <saurabhnanda> and this happens at runtime or compile time?
11:43:50 <ertes> "this"?
11:45:40 <saurabhnanda> the "reification", i believe
11:45:44 <saurabhnanda> or the reflection
11:46:02 <saurabhnanda> doesn't haskell have type erasure, or something?
11:46:12 <saurabhnanda> Reifies arbitrary terms at the type level. Based on the Functional Pearl: Implicit Configurations paper by Oleg Kiselyov and Chung-chieh Shan.
11:46:13 <dfeuer> Benchmarks take too long to run.
11:46:29 <saurabhnanda> how does 50% of the stuff in haskell begin with this. Based on an a paper.
11:46:29 <dfeuer> Such a pain.
11:47:29 <dfeuer> saurabhnanda, Haskellers tend to come from an academic background, and therefore cite their sources. Some other places, the documentation simply ignores where the algorithm/idea comes from.
11:48:59 <saurabhnanda> ertes: in the toJSON instance, I would be able to use 'name' as a regular variable?
11:49:29 <saurabhnanda> ertes: and how exactly would I "pass" the name to the toJSON function?
11:51:59 <aesonlenshelp> I'm getting an ambiguity error from this lens code: "[{\"key\": \"key1\", \"value\": \"val1\"}, {\"key\": \"key2\", \"value\": \"val2\"}]\n" ^@..traversed.ifiltered (\a _ -> a ^? key "key" == "key1")
11:52:39 <quchen> What’s the paper about Haskell’s error semantics again?
11:52:56 <saurabhnanda> aesonlenshelp: clueless newbie here as well, but wouldn't you need to parse that JSON first?
11:53:06 <quchen> It’s by SPJ and the gist is “if code can throw many exceptions, all of them are equally valid results”
11:53:11 <aesonlenshelp> saurabhnanda: Not with aeson-lens ;)
11:53:31 <aesonlenshelp> or lens-aeson. Whichever one mentions "law-abiding" in the description
11:53:53 <ertes> saurabhnanda: the reification and reflection (which is really just function application and referring to an argument, respectively) happen at run-time in principle, but they might be optimised away in certain cases
11:54:16 <ertes> saurabhnanda: you don't use (name), but (reflect (Proxy :: Proxy name))
11:54:17 <saurabhnanda> aesonlenshelp: what's the abmiguity error
11:54:28 <ertes> saurabhnanda: and you need the ScopedTypeVariables extension to write that
11:54:53 <aesonlenshelp> saurabhnanda: I can't access any pastebin sites and probably shouldn't paste here
11:54:53 <ertes> (because you're not creating a type variable 'name' there, you're referring to the one from the instance)
11:54:58 <saurabhnanda> ertes: I guess, I'll just let this idea be, for now. It's way above my IQ-grade.
11:55:14 <dmwit> quchen: "A semantics for imprecise exceptions" maybe?
11:55:31 <saurabhnanda> aesonlenshelp: lpaste, pastebin, gist?
11:56:06 <saurabhnanda> does anyone use Data.NonNull from MonoTraversable and can guide me with https://github.com/snoyberg/mono-traversable/issues/95#issuecomment-240730520 ?
11:56:16 <aesonlenshelp> saurabhnanda: Oh goodie, gist worked: https://gist.github.com/anonymous/f847fc9fa5eaa50bbce79929f2297c2d
11:56:19 <ertes> saurabhnanda: reflection has some heavy theory behind it, but the practical use is surprisingly simple…  it consists of two parts
11:56:36 <ertes> saurabhnanda: first you reify a value:  reify x (\p -> …)
11:57:15 <ertes> p :: Proxy x
11:57:37 <ertes> the type 'x' is now equivalent to the value 'x' you passed with 'reify'
11:57:41 <quchen> dmwit: Ah, that sounds right. Thanks!
11:57:49 <saurabhnanda> aesonlenshelp: about https://gist.github.com/anonymous/f847fc9fa5eaa50bbce79929f2297c2d#file-gistfile1-txt-L14 -- ^? gives you back a Maybe.
11:58:02 <ertes> to get the value 'x' back:  reflect (Proxy :: Proxy x)
11:58:04 <saurabhnanda> you need to do (\a _ -> a ^? key "key" == Just "key1")
11:58:12 <ertes> saurabhnanda: and that's pretty much it
11:58:13 <aesonlenshelp> saurabhnanda: correct
11:58:25 <saurabhnanda> aesonlenshelp: about the other error, I'm not sure where Int came into the picture from.
11:59:16 <ongy> ertes: how can a type be equal to a value?
11:59:28 <ertes> saurabhnanda: try this:  main = reify "blah" (\(p :: Proxy str) -> putStrLn (reflect p) >> putStrLn (reflect (Proxy :: Proxy str)))
11:59:30 <aesonlenshelp> saurabhnanda: Oh, I am. It's because a should be named i, since a in that is actually an index
11:59:40 <aesonlenshelp> because i'm using an "indexed traversal"
11:59:51 <ertes> ongy: equivalent in the sense that the type communicates a value and not a type with inhabitants that you can use
12:00:11 <aesonlenshelp> I'll post in a second
12:00:53 <ongy> ertes: I will have to look into it when I have more time for it
12:01:01 <ertes> ongy: the point of doing that you now have a type that can be an argument to *types*
12:01:07 <ertes> but it still communicates a *value*
12:01:27 <ertes> newtype Mod n = Mod { fromMod :: Integer }  -- where the type n communicates the modulus
12:01:56 <aesonlenshelp> ambiguity errror for this code: "[{\"key\": \"key1\", \"value\": \"val1\"}, {\"key\": \"key2\", \"value\": \"val2\"}]\n" ^@..traversed.ifiltered (\a b -> b ^? key "key" == "key1")
12:01:57 <aesonlenshelp> link to type/ambiguity errors: https://gist.github.com/anonymous/ac3769b674b231b11e6ed50802d4063f
12:06:14 <saurabhnanda> aesonlenshelp: try the 'Just' I mentioned above. Does it solve the second type error?
12:06:16 <ongy> ertes: what exactly is the advantage over having a typeclass with 'toNumber'? Less boiler plate?
12:07:37 <ongy> oh right, type class doesn't do it as I thought
12:07:42 <ongy> I get it, I think
12:09:20 <aesonlenshelp> saurabhnanda: nope, https://gist.github.com/anonymous/d20dc8960144bd17080e7b52bf3fece8
12:09:22 <saurabhnanda> is [] and List the tsame?
12:09:48 <saurabhnanda> aesonlenshelp: it did!
12:09:53 <saurabhnanda> the second type error went away
12:10:14 <aesonlenshelp> saurabhnanda: Oh, lol good point
12:11:28 <saurabhnanda> aesonlenshelp: can you try doing this outside of the REPL
12:11:46 <saurabhnanda> aesonlenshelp: just put it in a file and compile it, or let your IDE do the compilation
12:12:02 <saurabhnanda> aesonlenshelp: I think it's getting confused between Text vs String
12:12:07 <saurabhnanda> and it's a REPL only problem
12:13:53 <ertes> ongy: some values you want to communicate are inherently type-bound rather than value-bound
12:14:17 <ertes> ongy: (+) :: Mod n -> Mod n -> Mod n  -- there is only one modulus, not one per argument and one for the result
12:14:20 <aesonlenshelp> saurabhnanda: I did it in a repl, but would need to redact some stuff to paste
12:14:33 <saurabhnanda> aesonlenshelp: DON'T do in a REPL
12:14:33 <aesonlenshelp> it did give me a ton of other errors so I think you were right there
12:14:38 <ertes> ongy: i mostly use it for configuration data
12:14:44 <aesonlenshelp> sorry, I misspoke
12:14:48 <aesonlenshelp> I did not do it in the repl
12:14:49 <saurabhnanda> what's [] called in haskell? list?
12:14:52 <ertes> ongy: it also helps not to mix up configurations
12:15:17 <ertes> ongy: the (+) specifically wants two values modulo *the same* modulus
12:15:24 <kadoban> saurabhnanda: Yes
12:16:28 <saurabhnanda> kadoban: thanks.
12:16:39 <saurabhnanda> any thoughts on https://www.reddit.com/r/haskell/comments/4ye5yy/if_classyprelude_is_a_good_idea_should_one_be/ ?
12:33:28 <ReinH> saurabhnanda: It wouldn't be a good idea to replace [a] with NonNull a, and afaik Data.List.NonEmpty (from semigroups) is isomorphic to Data.NonNull.
12:33:48 <ReinH> I mean, I don't see how it could be otherwise
12:34:12 <ReinH> What I'd like is for semigroups to be added to base, and then things like Monoid retrofitted to it.
12:34:42 <ReinH> ideally head in base would then be changed to NonEmpty a -> a, but that would break a huge amount of code in the wild so it isn't practical
12:34:48 <saurabhnanda> is there a haskell dictionary somewhere? I keep getting thrown off by isomorphic, monomorphic, polymorphic, profunctor, comonad, etc.
12:35:02 <ReinH> isomorphic = "the same shape", more or less
12:35:13 <ReinH> I can convert to/from them without losing or gaining any information
12:35:23 <ongy> ReinH: or/and some things form safe (or is it Safe?) being in Prelude
12:35:47 <saurabhnanda> ReinH: which is good in theory, but bad in practice. It's the same problem as Text String and ByteString. Working with them is no longer fun.
12:36:39 <ReinH> saurabhnanda: what do you mean?
12:36:48 <ReinH> what is good in theory but bad in practice?
12:37:31 <ReinH> in fact, I think NonEmpty and NonNull are alpha equivalent: they have exactly the same structure but use different names.
12:37:39 <fr33domlover> saurabhnanda, perhaps the haskell wiki and wikipedia can help
12:37:57 <saurabhnanda> I probably misunderstood what you were saying. Were you saying the following -- "it doesn't matter. NonNull and NonEmpty are isomorphic and you can use any without losing information"
12:38:03 <fr33domlover> i won't mind having a glossary either :P
12:38:11 <fr33domlover> so much type theory stuff to learn
12:38:44 <Gurkenglas> http://ircbrowse.net/browse/haskell?q=what+is+profunctor etc. can be helpful
12:38:45 <ReinH> oh no, that is not true at all
12:38:47 <ReinH> NonNull is something weird
12:39:06 <saurabhnanda> to which my answer is -- "No. While I can convert between them without losing information, it adds to my mental overhead as a programmer. what's the best approach -- I'd like to pick that and move on with my real work"
12:39:59 <ReinH> If you're working with yesod, which is really a very distinct haskell dialog, you should do things the "yesod way".
12:40:11 <ReinH> (to the extent that you can figure out what that is)
12:40:14 <ertes> saurabhnanda: since most haskell terms are from math (and not just inspired by math, but literally reused), you can typically just ask wikipedia
12:41:02 <ReinH> So NonNull is a newtype for things which mono-traversable asserts are not nullable.
12:41:17 <ongy> though I don't think the wikipedia entry on monads is so useful when trying to understand them for haskell (but I may be stupid)
12:41:53 <ReinH> while NonEmpty is literally the sum a and [a], (data NonEmpty a = a :| [a])as one would expect.
12:42:08 <ertes> not that <https://en.wikipedia.org/wiki/Profunctor> is particularly great at explaining what the profunctors package is about, but they are indeed the same thing =)
12:42:41 <saurabhnanda> ongy: I still don't completely understand monads, but I know enough to work with them and get work done. However, I still don't understand how I'll be able to use that as an abstraction for my code. What kind of a problem will I look at and say, "ah! perfect place to use my own monad"
12:43:03 <ertes> saurabhnanda: if you know enough to work with them and get work done, then congratulations, you understand monads
12:43:05 <saurabhnanda> ReinH: what's :|
12:43:14 <ReinH> saurabhnanda: mostly you write an ADT and say 1) can I make a Monad instance? 2) can I do anythign useful with it?
12:43:36 <ReinH> Haskell data constructors can be put infix if they begin with :|
12:43:45 <ReinH> it's the same as data NonEmpty a = NonEmpty a [a]
12:43:49 <ertes> saurabhnanda: monads aren't about inventing your own monad…  monads are about mapM, sequence, replicateM, etc.
12:43:52 <ReinH> er, if they begin with ":"
12:44:00 <ReinH> and :|, of course, begins with ":"
12:44:02 <saurabhnanda> ReinH: who woulda thunk!
12:44:28 <saurabhnanda> ReinH: so, how do I build a non-empty list?
12:44:43 <saurabhnanda> and can I use any function that expects a list on it?
12:44:53 <ongy> ertes: what about monads like MPD monad? As far as I can see those mostly exist to force user to have valid handle
12:44:58 <ongy> or is that a missuse?
12:45:01 <ReinH> 1 :| [2,3,4]
12:45:05 <saurabhnanda> ertes: I get that. But I don't think I've truly understood the abstraction till I can build and use my own.
12:45:07 <ertes> ongy: i'd consider that a misuse
12:45:44 <ertes> ongy: it's really just an extremely rigid ReaderT
12:45:57 <saurabhnanda> ReinH: and if I want to make [1] NonEmpty?
12:46:00 <ertes> (or perhaps StateT, i don't know)
12:46:06 <ReinH> saurabhnanda: https://hackage.haskell.org/package/semigroups-0.18.1/docs/Data-List-NonEmpty.html
12:46:25 <ertes> ongy: personally i prefer when libraries give me a handle…  i know to use ReaderT, if i really need it (hint: i don't)
12:46:59 <ongy> I prefer handle (and raw access to Fd) but that's personal preference
12:48:37 <ertes> that's what i think is wrong with almost all web frameworks: it seems like most framework developers think that the monad stack is what defines your framework
12:50:32 <ReinH> ertes: bonus points if your monad stack is too rigid to allow me to, e.g., add a StateT layer for in-memory storage between requests.
12:51:04 <ertes> yeah
12:51:14 <ReinH> I've written off entire frameworks for this
12:51:14 <saurabhnanda> should I just ditch Yesod and move to Servant rightaway?
12:51:39 <ReinH> Just let me store a resource Pool between requests. Please.
12:52:21 <ertes> ReinH: i'd love to see a framework that is more like a toolkit than an abstraction
12:52:55 <ertes> wai gets close, but it's too low-level
12:53:15 <ertes> snap is close, too, but it still has its own monad
12:53:17 <ReinH> at least writing wai middleware can be a good solution for some problems
12:53:34 <ReinH> my slack bot is a wai middleware
12:57:25 <hsk3> I just created a new empty app skeleton with "stack new"
12:57:33 <ski> quchen : something about "imprecise exceptions" ?
12:58:16 <hsk3> I now want to create modules outside of Main.hs and refer to those from Main.hs.
12:58:16 <hsk3> How should I set things up? What should I call the files, where should I put them, and what should I put into the .cabal file of the project created by stack?
12:59:06 <ongy> hsk3: not sure about stack, but module names (and therefore file names) are problem specific
12:59:11 <ongy> so something that makes sense to you
12:59:44 <ertes> hsk3: to create a module named "A.B.C", create "A/B/C.hs" relative to your Main.hs
12:59:45 <hsk3> ongy: I have one section "executable foo" in the cabal file. Do I need other sections?
13:00:05 <ertes> hsk3: if this is an executable project, add extra modules to the "other-modules" field of your .cabal file
13:00:15 <kadoban> hsk3: Usually you have a library section as well, and the executable just calls into your library. But it's up to you.
13:00:28 <orion> For anyone familiar with WAI: When writing Middleware, normally your function looks like "fooMiddleware app req = ..." -- is it acceptable to throw away the 'app' parameter and provide a different one? Will that mess with anything else going on in the framework?
13:02:59 <lpaste> ertes pasted “Other modules” at http://lpaste.net/178324
13:03:08 <ertes> hsk3: http://lpaste.net/178324
13:03:16 <ertes> hsk3: like that
13:03:18 <ongy> is there a documentation about the existing module names and what to put where? e.g. Data/Control
13:03:55 <ertes> ongy: basically do what everybody else does, and if you don't know what everybody else does, ask here
13:03:57 <sm> hsk3: a simple way to start is to put new modules alongside your Main.hs
13:04:02 <ertes> ongy: you get a feeling for it
13:04:37 <hsk3> ertes: nice, thanks. this means I must put those files into src/MyProject.A.hs, src/MyProject.B.hs, and src/MyProject.C.hs?
13:04:53 <hsk3> No sorry
13:04:58 <ongy> hsk3: src/MyProject/B.hs
13:05:05 <hsk3> Yeah ok cool
13:05:06 <ertes> orion: if you throw away the 'app' argument, it's no longer a "middleware", is it?  it's just an Application =)
13:05:11 <ongy> to create the file MyProject.B
13:05:21 <ongy> s/file/module
13:05:38 <hsk3> sm: By that you mean putting for instance "GreatModule" into other-modules, and just puting the GreatModule.hs file directly in the same folder as Main.hs ?
13:05:47 <sm> yup
13:05:50 <hsk3> NICE.
13:05:52 <hsk3> Makes sense
13:06:04 <orion> ertes: I throw /that/ app away, but I replace it with another.
13:06:19 <ertes> orion: in other words, you're pretty much just writing an application
13:06:24 <hsk3> Thanks mates.
13:06:34 <ski> <someone> someoneelese : So if I understand correctly when you name a module X.Y.Z you must locate it in src/X/Y/Z.hs ?
13:06:39 <ski> <someoneelse> someone: With GHC, yes. The report doesn't actually specify
13:06:42 <ski> <someoneelse> someone: Well, you can change the src/ prefix to whatever you want (including nothing)
13:06:48 <ski> hsk3 ^
13:07:23 <hsk3> Cool.
13:07:43 <ertes> orion: a middleware is nothing but an application that depends on another application, i.e. a function of type Application -> Application…  if you ignore the argument, you're just writing an application, which you could think of as a "constant middleware"
13:07:47 <hsk3> ski: So how 3rd party modules are essentially bringing in more search directories, in addition to src?
13:07:53 <hsk3> For instance Data.Bool
13:07:59 <hsk3> being in a data folder somewhere
13:08:11 <hsk3> no sorry, the Data folder.
13:08:11 <orion> ertes: Ok. My goal is to call a different Application depending on the value of the Accept header.
13:08:18 <hsk3> Data/Bool.hs
13:08:28 <ongy> hsk3: module that exist in packages you have on your system (sandbox) can be included
13:08:38 <orion> I think what I've described is the right way to do it.
13:08:59 <ongy> so if some module (e.g. base) has a Data/Map.hs and exports the Data.Map module, you can include it in your project, provided you have base installed
13:09:04 <ertes> orion: since a middleware is literally defined to be a function of that type, yes, you're writing a valid middleware
13:09:22 <ertes> orion: there is no rule that states that the original application has to be called for each request
13:09:31 <orion> Ok.
13:10:15 <baordog_> So
13:10:21 <baordog_> I am trying to build this thing I found on github
13:10:28 <baordog_> https://github.com/adyxax/hsbot/blob/master/hsbot.cabal
13:10:32 <hsk3> ongy: makes sense. thank you!
13:10:45 <baordog_> Cabal says it doesn't exist as a package so I am just using cabal build.
13:10:51 <baordog_> How do I tell cabal to go fetch the dependencies?
13:11:11 <sm> cabal install --only-dep
13:11:12 <ongy> hsk3: with cabal you have to explicitly mention every package you depend on, see build-depends field in your .cabal file (it should contain base, for the skeleton)
13:12:08 <baordog_> sm: Will that be smart enough to figure out what I'm referring to?
13:12:20 <baordog_> shouldn't it cabal install --only-dep NAMEOFSOMECABALFILE or somesuch
13:12:24 <sm> no, because that package has not been touched in 5 years
13:12:52 <sm> if you add --allow-newer, it might work
13:12:54 <baordog_> Hmm good point 
13:13:03 <baordog_> I might as well go find a better maintained chat bot
13:13:06 <orion> ertes: Based on my stated goal, does what I described make sense? Is that how you'd do it?
13:13:17 <hsk3> ongy: Yeah. So build-depends is for 3rd party modules and extra-modules is for my own modules.
13:13:55 <baordog_> Any suggestions?
13:14:21 <sm> http://hackage.haskell.org/packages/search?terms=bot shows some
13:14:22 <ongy> hsk3: build-depends lists packages not modules, but those provide the third party modules
13:14:32 <sm> (quite a lot actually)
13:14:33 <kadoban> h3adrush: build-depends is for packages you depend on. (not modules).   extra-modules is for modules you write but aren't shared
13:14:36 <ertes> orion: typically Accept should be handled by the application itself
13:14:37 <kadoban> hsk3: ^
13:14:54 <baordog_> I was hoping you had one that you preferred.... I don't know which ones are bad. 
13:14:56 <sm> ircbot sounds good
13:15:01 <ertes> orion: so i'm not sure if you're doing the right thing architecturally, but it's too little information
13:15:36 <baordog_> It's not a bot, it's just a library... no documentation. In fact it appears to be abandoned as well.
13:15:39 <orion> ertes: I see. The Accept header contains API version information: application/vnd.fooProject;version=7
13:15:54 <sm> baordog_: what are you looking for ?
13:16:11 <baordog_> A simple IRC bot that I can add some minimal functionality to that supports ssl.
13:16:19 <orion> Different versions can have different endpoints and different parameters, etc, so it makes sense to have different Applications for each API version.
13:16:26 <sm> a release two months ago doesn't seem abandoned
13:16:51 <baordog_> "A simple haskell ircbot library. I have better ideas now, but this one is needed to support clckwrks-plugin-ircbot for now."
13:17:00 <ertes> orion: it *may* be the right thing to do…  as long as your middleware doesn't deprive the individual applications of other important information in the Accept header
13:17:09 <sm> ack, damn devs always thinking up better ideas
13:17:19 <hsk3> ongy, kadoban, makes sense. thanks guys
13:17:44 <ertes> orion: i see Host-based switching as a legitimate use case for middlewares, so there is no reason *in principle* that Accept-based switching should be disallowed
13:18:00 <sm> baordog_: lambdabot is the most used general irc bot. I think you'll be lucky to find anything with ssl support
13:18:16 <ertes> orion: just make sure your approach scales, because architectural changes hurt, even in haskell =)
13:19:34 <orion> ertes: Indeed. Thanks for the advice!
13:20:21 <baordog_> sm: SSL is kind of a hard requirement... peering at lambdabot to see if it supports. I actually want something much more basic. 
13:20:21 <quchen> ski: Thanks to you as well :-)
13:20:23 <sm> phaazon: does your tellbot support ssl ?
13:21:52 <et09> how do you get the type of == 
13:21:55 * ski didn't notice dmwit already gave an answer
13:22:00 <kadoban> :t (==)
13:22:00 <ertes> :t (==)
13:22:00 <glguy> My IRC client and its supporting library have lots of code that are useful for constructing an IRC bot.
13:22:01 <lambdabot> Eq a => a -> a -> Bool
13:22:02 <lambdabot> Eq a => a -> a -> Bool
13:22:03 <ski> @type (==)
13:22:05 <lambdabot> Eq a => a -> a -> Bool
13:22:05 <et09> ah 
13:22:21 <et09> why parens and not just == 
13:22:23 <ski> `:t' in the interactor, `@type' in lambdabot
13:22:24 <et09> :t ==
13:22:25 <lambdabot> parse error on input ‘==’
13:22:28 <ongy> et09: generally to convert an operator like == or + to a function (for things like :t) put it in parens
13:22:31 <glguy> And the winners in medal order are: ertes, kadoban, and ski!
13:22:34 <et09> got it
13:22:39 <ski> (the former also happens to work in lambdabot)
13:22:43 <ertes> where's my medal?
13:23:26 <ertes> baordog_: if i'd write an IRC bot or really anything IRC, i'd most likely use irc-core together with reflex
13:23:31 <ski> et09 : it takes a complete expression, e.g. `:t [(False,"True"),(True,"Beauty")]'
13:23:50 <ski> et09 : `==' is an infix operator, it isn't a complete expression on its own
13:23:59 <ertes> baordog_: the 'connection' library makes things like TLS connections easy, too
13:24:02 <jle`> hm, there's some product-sum interaction in (a -> c, b -> c) -> Either a b -> c; would the dual be Either (a -> c) (b -> c) -> (a, b) -> c ?
13:24:09 <jle`> is there a real duality there? or are they just equivalent in some way?
13:24:10 <et09> i see
13:24:15 <troydm> I have a lazy bytestring how can I convert it to strict Text?
13:24:16 <ski> et09 : however, you can turn an infix operator into an ordinary function (accepting two arguments), by wrapping it in brackets
13:24:22 <baordog_> Yeah I was just hoping to not have to throw the basic guts of it together myself 
13:24:39 <ski> et09 : therefore `2 == 3' is the same as `(==) 2 3' (which really means `((==) 2) 3')
13:25:22 <ertes> baordog_: i understand that, but it's the most scalable approach currently
13:25:35 <ertes> i can't recommend any ready-made IRC bot library, not even lambdabot
13:25:35 <ski> jle` : `(a -> b0,a -> b1) -> (a -> (b0,b1))'
13:26:12 <jle`> hm i think my original things are just the same thing stated in different ways/isomorphic
13:26:50 <et09> how do i convert a tuple of variable length to a list
13:26:58 <et09> given that the tuple contains only elems of same type
13:27:07 <fr33domlover> same here, I have an IRC bot with related libraries which do most of the work
13:27:31 <ertes> baordog_: i'll write a reactive IRC bot library at some point, so if you're patient for a few years, you can use it =)
13:27:46 <ertes> might take decades at this pace
13:28:01 <kadoban> et09: You generally don't. Tuples of differing lengths are not the same type.
13:28:02 <baordog_> https://wiki.haskell.org/Roll_your_own_IRC_bot <-- do you think it would be hard to alter this thing to support TLS?
13:28:15 <baordog_> This is basically all I need, just need to make it support TLS
13:28:27 <ski> @djinn Either (a0 -> b) (a1 -> b) -> ((a0,a1) -> b)
13:28:27 <lambdabot> f a =
13:28:27 <lambdabot>     case a of
13:28:27 <lambdabot>     Left b -> \ (c, _) -> b c
13:28:27 <lambdabot>     Right d -> \ (_, e) -> d e
13:28:32 * sm would try adding the connection lib to tellbot
13:28:33 <et09> got it
13:28:35 <ski> @djinn ((a0,a1) -> b) -> Either (a0 -> b) (a1 -> b)
13:28:36 <lambdabot> -- f cannot be realized.
13:29:01 <ertes> baordog_: please don't use that page…  it's wrong in almost every way imaginable
13:29:12 <et09> @let f x = x * 3
13:29:14 <lambdabot>  Defined.
13:29:19 <baordog_> I'm kind of new, but why is it wrong? 
13:29:21 <et09> @let g x = x * 5
13:29:22 <lambdabot>  Defined.
13:29:26 <baordog_> I mean does it just give bad advice?
13:29:35 <et09> how do i get him to show something again 
13:29:37 <ertes> baordog_: yes
13:29:41 <et09> or just eval sothing
13:30:28 <ertes> baordog_: anything that suggests to use String, especially hGetLine, for anything networking, especially IRC, is really really bad advice
13:30:32 <et09> oh right
13:30:34 <mauke> @undefine
13:30:34 <lambdabot> Undefined.
13:30:36 <et09> > f . g 20
13:30:37 <ReinH> this is a particular sort of tragedy of the commons that happens especially to wikis.
13:30:38 <lambdabot>      Could not deduce (Show b0) arising from a use of ‘f’
13:30:38 <lambdabot>      from the context (Show a, FromExpr c)
13:30:38 <lambdabot>        bound by the inferred type of it :: (Show a, FromExpr c) => a -> c
13:30:46 <et09> > f $ g 20 
13:30:47 <lambdabot>      Could not deduce (Show r0) arising from a use of ‘f’
13:30:47 <lambdabot>      from the context (FromExpr t)
13:30:48 <lambdabot>        bound by the inferred type of it :: FromExpr t => t
13:30:54 <ski> jle` : consider `(a+ -> a- -> c) -> (b+ -> b- -> c) -> ((a+,b+) -> Either a- b- -> c)'
13:30:59 <baordog_> ertes: I'm not sure I understand why.... performance?
13:31:14 <ReinH> someone wrote that page once and uploaded it, but there's no way to know if it's been vetted or reviewed in any way, or kept up-to-date (aside from timestamps, which are not accurate indicators).
13:31:20 <et09> well, anyway, why does the 1st one return "non-type variable argument" for that?
13:31:29 <ertes> baordog_: because it violates the protocol, because it doesn't scale, because it opens you up for DoS attacks, etc.
13:31:55 <baordog_> Wait why does string violate the IRC protocol?
13:32:27 <ski> jle` : if you set `a+ = a- -> c' and `b+ = b- -> c', and feed `($)' for the first two arguments, you get your `(a -> c, b -> c) -> Either a b -> c'. if you instead set `a- = a+ -> c' and `b- = b+ -> c' and feed `($)' for the first two arguments, you get (the `flip'ped version of) your `Either (a -> c) (b -> c) -> (a, b) -> c'
13:32:33 <ertes> baordog_: hGetLine considers \r to be what it is:  carriage return, while IRC considers it equivalent to a line feed
13:32:42 <mauke> ertes: since when?
13:33:03 <ertes> mauke: since IRC exists
13:33:09 <mauke> unlikely
13:33:16 <ReinH> It's also not generally safe to assume that bytes have a particular encoding.
13:33:27 <mauke> last time I looked, it specified CR LF as message terminator, with single CR and LF being invalid
13:33:27 <hpc> another point is that irc doesn't specify an encoding beyond being ascii-compatible
13:33:46 <hpc> so your client's choice of encoding is significant and not something you can encode in String
13:34:04 <baordog_> >.< see I just wanted like a semi-functioning bot I could write modules for. 
13:34:05 <hpc> you'll get valid bytestrings from other clients that can't exist in your chosen encoding
13:34:11 <mauke> hpc: you could set the encoding to latin-1 and live with the garbage
13:34:20 <mauke> baordog_: irssi
13:34:25 <hpc> yeah, but that's a LOT of garbage in a world of UTF-8
13:34:33 <mauke> granted, the modules aren't in haskell :-)
13:34:43 <hpc> especially here too where we love using unicode arrows
13:34:56 <sm> baordog_: esotericbot may be of interest - old but has plugins and claims to be a cleaner lambdabot 
13:35:04 <fr33domlover> my IRC bot assumes UTF-8 which works in freenode 99.999% of the time
13:35:16 <ertes> mauke: first paragraph of: https://tools.ietf.org/html/rfc1459#section-2.3.1
13:35:41 <ReinH> Both 1459 and 2813 state "No specific character encoding is specified". ASCII-compatibility is common but, again, not enforced. It just happens to be that the components of the protocol use ASCII and the vast majority of message traffic is ASCII-compatible.
13:35:46 <ertes> in any case hGetLine will return the \r, and you have to cut it
13:35:58 <hpc> ReinH: ah yeah, good point
13:36:03 <ertes> baordog_: really, just use irc-core
13:36:30 <ertes> baordog_: the approach from the wiki page has disadvantages, but more importantly it has no advantages
13:36:36 <ertes> it's not shorter, cleaner, …
13:36:41 <baordog_> ertes: I don't know the protocol well enough to string together the guts. 
13:36:50 <baordog_> I have hoping for more of 1-2 hour project, not a 2 week one. 
13:36:51 <ertes> baordog_: you don't need to
13:36:53 <hpc> ReinH: so i guess all a line body has to follow is that the newline codepoints match ascii
13:36:53 <mauke> ertes: ooh, that's fun. the text supports your interpretation, the BNF mine
13:36:57 <hpc> so the line can be parsed
13:37:11 <hpc> and then the encoding of the protocol parts are separately ascii encoded
13:37:13 <ReinH> hpc: the protocol defines such things, yes
13:37:24 <ertes> mauke: IRC wants you to send CR-LF, but is fine with receiving things that are not CR-LF
13:37:42 <ertes> baordog_: sorry, i doubt that 1-2 hours will be enough
13:37:48 <mauke> I think the RFC is just bad
13:38:08 <ertes> we can all agree on that, i think =)
13:38:11 <ReinH> I think the protocol is just bad.
13:38:14 <sm> agreed. :)
13:38:19 <baordog_> ertes: IRC core does not not support ssl by the looks of things.
13:38:19 <ertes> IRC is terrible
13:38:29 <ertes> baordog_: it doesn't support networking
13:38:50 <ertes> baordog_: it's a parser/renderer library…  for the networking look at the connection library
13:39:51 <ertes> baordog_: my approach would be:  connect using 'connection', split into lines using 'pipes', parse/render using 'irc-core', write the actual IRC application using 'reflex'
13:40:01 <ReinH> Vincent is everywhere
13:40:46 <ertes> you can also use the lower-level 'tls' library for connecting, if you need more control, but you likely don't
13:43:51 <baordog_> ertes: I mean maybe someday someone will do all of those things. Maybe if irc-core had api-docs that demonstrated a simplified bot using all of those moving parts I would attempt it, but my very limited haskell skills are not nearly nearly up to the task. I guess I need to go find a language that has a valid, simple reference implementation I can crib of. I could literally spend a week just wading through the code to understand 
13:44:36 <ertes> baordog_: yeah, your best bet may be to choose a different language at this point
13:44:37 <ertes> sorry
13:45:25 <ertes> no matter what you do, don't follow that wiki page =)
13:45:40 <sm> bah! tellbot + connection, 1-2 hours
13:46:08 <baordog_> I mean I assumed there was a good libary for haskell because every other rizon channel I join has a stupid haskel bot running in the background.
13:46:14 <baordog_> I guess they all just run lambda bot. 
13:47:56 <ertes> lambdabot is more like an IRC shell
13:49:54 <baordog_> I just want something that print simple stuff like "bot speak" "someword!" - all the code evaluation stuff is the absolute opposite of what I want.
13:50:29 <mauke> I'd use irssi + scripts
13:50:37 <ertes> baordog_: maybe follow sm's suggestion
13:51:04 <ertes> grab the source code of tellbot, add TLS to it, implement the functionality you need
13:51:28 <mauke> unfortunately irssi's documentation isn't that great either, but there are examples and it's great for interactive debugging because it's a full irc client already
13:51:49 <ertes> there is also "good" old eggdrop, if all else fails
13:52:02 <ertes> but TCL is reason enough not to use it
13:52:24 <jonored> I actually use ii for simple bots, rather than irssi.
13:52:42 <ski> @src Maybe (>>=)
13:52:42 <lambdabot> (Just x) >>= k = k x
13:52:42 <lambdabot> Nothing  >>= _ = Nothing
13:52:55 <jonored> but I'm not sure I expect that to have SSL.
13:55:08 <glguy> If you want to write Haskell for your bot you could always add some extra code to my IRC client
13:55:21 <glguy> and then you're also have the ability to manually control the bot via the client, too :)
13:57:59 <baordog_> glguy: Maybe? I mean, if there's a workable api in there, I'd do it.
14:01:34 <ertes> i wouldn't even know how to maintain such a thing with git =)
14:02:10 <ertes> not that i'm a git expert, but it doesn't seem to support maintaining "slight alternatives" very well
14:02:17 <glguy> Mostly you'd do it by keeping the logic in a new module so that merges were easy
14:03:02 <donkey_hotei> how to import Data.IntMap such that IntMap.empty is in scope?
14:03:16 <ertes> glguy: do you actually merge?  or do you rebase after every pull?
14:03:19 <donkey_hotei> I'd like to have an instance method like "empty = IntMap.empty"
14:03:43 <glguy> ertes: U
14:03:43 <mauke> import qualified Data.IntMap as IntMap
14:04:00 <glguy> ertes: In such a situation I think merging would be better so that you don't throw away your history each time
14:04:12 <ertes> hmm
14:04:47 <donkey_hotei> mauke: ty
14:04:54 <glguy> The long term solution there is just to flesh out the Hook api a little more so that it supports sending messages
14:05:11 <baordog_> Currently just trying to force hsbot to compile. Maybe that will get me what I need. 
14:05:18 <glguy> and then the extension would require very little modification if any to the client as it evolves
14:05:37 <glguy> that or use the extension API and maintain the bot logic as an external dependency
14:05:55 <glguy> then you wouldn't have to modify the client directly or fuss with its git history
14:06:37 <glguy> if one was willing to write the bot logic in Lua one could use it as is
14:07:02 <ertes> git should never have become so popular
14:07:54 <ongy> ertes: do you know a better solution?
14:08:31 <ertes> ongy: i'm a darcs user, and every single time i have to use git it's a nightmare
14:08:32 <dfeuer> glguy, Data.Map.Strict.Merge and Data.Map.Lazy.Merge? What do you think of the rest of the names? Have you come up with an argument for mergeWithKey yet?
14:09:05 <ongy> ertes: but is it better? or are you just more used to it?
14:09:25 <glguy> The argument is that I've used it successfully and seen other people manage just fine and not need all the complexity of the new API
14:09:38 <glguy> I haven't checked all my usecases to see if they would fit into the new API or not
14:09:54 <ertes> ongy: it supports more workflows
14:10:00 <baordog_> There goes that, hsbot wont build. Let's see if tellbot builds. 
14:11:11 <ertes> ongy: it's not better in every way, but it doesn't force you to shape your workflow around its limitations
14:11:22 <mauke> I had the opposite experience
14:11:36 <jonored> ertes: Do you have an example of a workflow that is available in darcs and not with git?
14:11:45 <mauke> darcs was a (sometimes broken) toy
14:11:51 <ertes> jonored: maintaining slight alternatives
14:12:25 <jonored> Ahh, you object to having a chain of parents?
14:12:32 <glguy> darcs had a workflow of working around exponential blowup that I never had with git
14:12:49 <mauke> darcs also regularly corrupted its repo
14:12:52 <dfeuer> glguy, that sounds all right. My challenge to you: come up with a way to document how to write functions to pass to mergeWithKey to ensure balance-invariance.
14:13:02 <mauke> or created conflicts from thin air
14:13:08 <ertes> darcs is stable and efficient today…  i haven't seen any of those problems for a very long time
14:13:41 <mauke> me neither, because I switched to git
14:13:48 <glguy> dfeuer: I'm OK with improving the documentation for it, just not destroying it
14:14:45 <dfeuer> glguy, I don't know *how* to improve the documentation for it.
14:14:48 <lambdamu> darcs it in fact quite stable today, but the tooling around is pretty spare e.g. only very recently meld (re)gained support for darcs diffs
14:15:13 <lambdamu> but I don't think there is a workflow you can't somehow do with git
14:15:13 <dolio> jonored: Adding an empty directory, or moving a file.
14:16:00 <ertes> lambdamu: the problems with git start when upstream and you disagree
14:16:12 <baordog_> Why does cabal cause my cpu to skyrocket
14:16:15 <baordog_> and my fan to go on.
14:16:20 <baordog_> What the HECK is it computing in there?
14:16:27 <ReinH> what cabal command?
14:16:31 <ertes> lambdamu: or when there simply is no upstream
14:16:32 <ReinH> and compiling is computing, so...
14:16:35 <mauke> ertes: separate branch + rebase?
14:16:35 <sm> it's building a lot of packages, doesn't it say so ?
14:16:52 <sm> and using all of your cpu cores at once to do it
14:16:56 <ertes> mauke: yes, but that's not a feature, that's a bug…  a shortcoming of git
14:17:03 <mauke> what
14:17:09 <baordog_> cabal install --dependencies-only
14:17:11 <lambdamu> ertes: yeah it's certainly not nice to sort out broken git repos, but to be honest that shouldn't occur in practice often
14:17:18 <mauke> that's supporting that workflow
14:17:50 <lambdamu> ertes: that is if you follow sane workflows
14:17:51 <ongy> ertes: what is the problem with git, when thereis no upstream?
14:18:10 <ertes> ongy: git prefers, if people agree about the history of a project
14:18:43 <lambdamu> personally I like working with patches more than with branches
14:18:54 <baordog_> outsider opinion here
14:18:59 <lambdamu> but I guess that is just a matter of practice
14:19:08 <baordog_> but I think the haskell community would be better off with fewer weird haskell only things.
14:19:16 <baordog_> There's a big barrier to entry there
14:19:25 <ongy> baordog_: like stack and cabal?
14:19:39 <baordog_> Isn't stack for other unix stuff?
14:19:45 <baordog_> I meant in reference to darcs 
14:20:06 <lambdamu> only very few projects use darcs these days
14:20:45 <ertes> maybe we should just work on fixing darcs; in the sense of writing the missing tools…  it has genuine, objective advantages over git
14:20:50 <sm> lambdamu: 2200 projects at darcs hub
14:20:51 <jonored> I mean, patches are a prettier idea than very compressed copies of the full source tree, but...
14:20:58 <sm> small ones, yes :)
14:21:07 <mauke> how many projects at github?
14:21:13 <lambdamu> ertes: i'm counting on pijul
14:21:59 <lambdamu> sm: I did not know that, this was more spoken from experience, I rarely do darcs pull on public projects these days
14:22:01 <ertes> it needs a better and more darcs-oriented web interface rather than a bad github clone like darcsden, it needs integration and more than anything else it needs users
14:22:53 <lambdamu> ertes: the darcs ship has sailed I don't think it will regain momentum
14:23:04 <sm> ertes: this won't happen until a productive hacker dedicates their time to it, and more likely it'll be called something else
14:23:35 <baordog_> I mean, I really want to be more involved in haskall, it's just like - the barrier to entry for small projects is kind of nasty. I can't seem to get anything done without a language extension or some library that takes a day to comprehend 
14:23:47 <sm> baordog_: still building ?
14:24:49 <lambdamu> baordog_: it's all true, but there is no easy fix to this, since fixing those problems inherently involve consensus building
14:25:04 <dolio> How is needing a language extension to be enabled a barrier?
14:25:06 <ertes> baordog_: you basically need only two things to build something: GHC and a hackage interface…  there are a few of the latter, including cabal-install, stack and nix (in order of steepness of learning curve)
14:25:49 <ertes> baordog_: in fact you can get pretty far with only GHC
14:25:56 <dolio> Or you mean, you need to learn something?
14:26:02 <ertes> the other one you only need, if you want to use libraries that aren't on your system
14:26:04 <ongy> dolio: language extension have a similar character to small libraries. I am somewhat comfortable with haskell by now, but things like TypeFamily or DataKinds I have to look up and wrap my head around
14:26:47 <ertes> baordog_: oh, and culturally we are very open to language extensions, unlike other languages…  expect to use your first language extension very soon
14:27:00 <ertes> baordog_: and don't feel guilty about it when you do =)
14:27:17 <lambdamu> I don't think it is any one thing that makes the learning curve steep rather the mass of small annoyances
14:27:35 <sm> projects specify their language extensions, you don't have to know anything about them
14:27:50 <kadoban> baordog_: The extensions that require learning anything more than like, 10 minutes are all extremely optional.
14:28:12 <mauke> huh. I guess perl kind of does the same thing as haskell here, except they're called "features", not "language extensions"
14:28:19 <ertes> i long thought that haskell and PHP have absolutely nothing in common other than that they run on computers, but there is one relationship
14:28:36 <mauke> HHVM? acme-php?
14:28:37 <lambdamu> sm: that is not true, if you want to use the mtl state transformer first thing you need is flexible contexts
14:28:39 <Squarism> Ok.. stupid question maybe.. but i wonder why this http://lpaste.net/178347 is so?
14:28:50 <lambdamu> which is suggested in the error message
14:28:54 <glguy> lambdamu: That one's easy to avoid by not doing it
14:29:07 <lambdamu> but then again AmbigiousTypes are also suggested
14:29:18 <lambdamu> which you almost never want
14:29:33 <ertes> PHP: nothing is completely unusable, but everything is slightly bent or broken…  it works just enough to get the job done, but as you start combining things, the damage builds up until your whole code crashes and burns
14:29:41 <Squarism> ...or why cant i require a data type have a member with "wildcard" type params?
14:29:44 <sm> lambdamu: we were talking about "barrier entry for small projects". That means building, tweaking on existing code. You don't need to know what a flexible context is for that
14:30:08 <mauke> Squarism: you can, but you need to parameterize the whole type or else use explicit 'forall'
14:30:13 <kadoban> Squarism: You can if you make it  data MoveConfig a = ...
14:30:29 * sm doesn't know what a flexible context is, but knows enough to add it at the top when so ordered by GHC
14:30:58 <lambdamu> sm: I read your comment in such a way that language extensions were completely encapsulated in libraries that use them
14:31:04 <lambdamu> sm: which is not the case
14:31:13 <ertes> haskell: nothing is completely unlearnable, but everything is slightly difficult to learn…  you can learn it just quickly enough to get the job done, but as you start combining things, the learning curve builds up and you find yourself reading many blog posts and papers, sometimes even for simple tasks
14:31:37 <ertes> the difference: the pain goes away and pays off with haskell =)
14:31:46 <lambdamu> sm: sure but as i said you don't want to follow all suggestions, which means you have to learn what the extensions mean
14:31:49 <ReinH> ertes: one is capex, the other is opex :)
14:31:53 <ski> Squarism : every type variable must be bound
14:32:30 <ski> Squarism : in the type signature `verifyMoveType2 :: CategorizedMove -> a -> Either InputError a', this really means `verifyMoveType2 :: forall a. CategorizedMove -> a -> Either InputError a', and it's `forall a.' which is binding `a' here
14:32:48 <lambdamu> sm: which again is not inherently bad, but adds to the learning curve
14:33:12 <ski> Squarism : that's a shorthand that's available for type signatures. but not for field specifications in record syntax
14:33:41 <ertes> ReinH: i had to look those up, but yeah =)
14:34:08 <Squarism> ski, mauke: So could i move that "forall a" to my data type member?  
14:34:12 <ReinH> ertes: yeah: learning things (to the extent that they stay learned) is a one-time expense.
14:34:18 <Squarism> ...having some trouble with that when i try
14:34:38 <ReinH> (realistically, maintaining a body of knowledge has operational costs)
14:35:27 <ertes> ReinH: oh, actually i disagree about that…  you need to reinforce your knowledge from time to time…  but it gets progressively cheaper
14:35:31 <ski> Squarism : yes. if you enable `PolymorphicComponents' or `Rank2Types' or `RankNTypes'
14:36:16 <ertes> ReinH: so yeah, i agree with the latter =)
14:36:16 <ReinH> ertes: yes, that is what I also just said :)
14:36:51 <ski> Squarism : that would then require that the function you put in the `verifyMoveType' field in a `MoveConfig' "record" *must* be a polymorphic function (polymorphic in that `a')
14:36:54 <Squarism> ski, thanks - that worked
14:38:48 * hackagebot ghc-datasize 0.2.0 - Determine the size of data structures in GHC's memory  https://hackage.haskell.org/package/ghc-datasize-0.2.0 (DennisFelsing)
14:38:56 <ski> Squarism : in some cases people want to "hide" an "implementation type" inside a data type like that, as a type variable. in that case, you'd look up "existential data constructor" or something similar. this is very different from what was just described above, though it also happens to use the keyword `forall' (in a different place)
14:40:09 <ski> Squarism : i'm just mentioning this as another way in which you can use a type variable in a data type definition, without adding it as a parameter (which was kadoban suggested)
14:40:37 <Squarism> ski, okey.. ill try to remeber that. This is just means to realize some OO type "Strategy pattern".. not aiming to go deep about this right now
14:41:27 <baordog_> ski: Took cabal 20 minutes to figure out it couldn't install all the deps for tellbot
14:41:42 <baordog_> So yeah, idk I guess tellbot is broken and doesn't build anymore.
14:41:44 <sm> baordog_: stack build --resolver lts
14:42:16 <et09> http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/#install i'm reading this and got to the part where he writes "NameConstr", and i don't understand where he's getting that ... don't quite understand constructors
14:43:07 <ski> Squarism : "existentials" can be used to describe some OO-like things (like a collection of `Widget's where each widget can actually be of a different type, as long as they all have the same interface). but often one can do it nicely without existentials as well
14:43:28 <et09> did he just omit it or something
14:44:11 <ski> Squarism : (some) people often seem to reach for existentials (after having learned about them), even though they aren't called for / justified that often .. presumably because they think in an overly OO-centric way
14:45:06 <ski> Squarism : .. that's just some caution to go with the (cool !) concept of existentials, whenever you get around to learning about it
14:45:18 <mauke> et09: do you mean "data Name   = NameConstr String"?
14:45:27 <et09> yeah
14:45:41 <mauke> that's the definition of Name and NameConstr
14:46:16 <mauke> (Name being a type and NameConstr being a constructor)
14:46:28 <et09> oh i think i wrote it with type instead of data in console, hence the confusion
14:46:41 <mauke> 'type' just creates new names for existing types
14:46:42 <baordog_> Is stack more reliable than cabal?
14:46:48 <maerwald> er wat?
14:46:52 <mauke> it's simple aliasing. it doesn't let you define new types
14:46:53 <maerwald> stack uses cabal
14:46:58 <sm> yes
14:47:07 <Squarism> ski, oh ok. I used "existential types" in scala (defining values as having certain functions defined instead of a certain type).. dont know if its similar
14:47:09 <kadoban> baordog_: stack is easier to use in general than cabal-install, IMO.
14:47:18 <maerwald> I disagree
14:47:18 <kadoban> More reliable? I dunno.
14:47:22 <sm> baordog_: while waiting for that to finish, maybe look at how to hook up connection to make it do SSL. Still half an hour remaining of your 1-2h, go go
14:47:37 <geekosaur> also are we talking about the old cabal-install or the new one (cabal new-build)?
14:48:33 <Squarism> for a noob id recommend stack any day. /noob 
14:48:47 <ski> Squarism : possibly. i don't know Scala that much, though i know some parts of it was inspired/borrowed from functional programming
14:50:32 <baordog_> sm: I was going to try to use network.TLS instead 
14:50:46 <baordog_> Making it use connection would involve me rewriting a lot more of it tha I want to
14:50:55 <baordog_> it already uses "network" so network.tls might be a drop in.
14:51:03 <sm> maaaaybe...
14:51:04 * baordog_ told himself in a dilusional tone
14:51:19 <baordog_> Doesn't matter
14:51:22 <baordog_> cause the build failed.
14:51:26 <baordog_> Choked on some native code.
14:51:35 <sm> oh, are on windows too ?
14:51:45 <sm> are you
14:52:01 <sm> it worked for me (non-windows)
14:52:14 <ertes> baordog_: stack adds a layer of complexity to achieve reproducible deployments…  in that sense stack has a steeper learning curve
14:52:38 <baordog_> Wrap.hsc:148:10: fatal error: 'pcre.h' file not found
14:52:41 <baordog_> I'm on OSX 
14:52:51 <ertes> baordog_: you never *need* it though, so if cabal-install works for you, go for it
14:53:01 <baordog_> Well in this case it doesn't
14:53:12 <mauke> oh, it needs libpcre?
14:53:13 <sm> ok, you need to install some libpcre C library, which neither cabal nor stack can do for you
14:53:17 <dolio> baordog_: That sounds like you need to install the dev libraries for pcre.
14:53:21 <mauke> huh
14:53:28 <sm> brew install pcre
14:53:31 <Squarism> i cannot judge if cabal (with new-build) is better. But for a complete newcommer it can be an extra level of confusion having to make sure you operate in the correct "mode". haskell.org should just provide one alternative for curious newcommers - the easiest / least-possible-to-mess-up-choice
14:53:42 <ertes> doesn't stack handle non-haskell deps?
14:53:48 <Squarism> ...instead of 3 as is now
14:54:16 <baordog_> sm: Warning: pcre-8.38 already installed
14:54:19 <et09> (just learned how deriving works) ;) 
14:54:33 <et09> @let data Foobar = Foobar {whatever :: Int, whatever2 :: Int} deriving Show
14:54:35 <lambdabot>  Defined.
14:54:40 <et09> > whatever $ Foobar 2 5
14:54:40 <sm> hmm. I shall try it on mac
14:54:43 <lambdabot>  2
14:55:17 <ertes> et09: deriving is one of haskell's killer features, but it shows its true strength once you have a type variable =)
14:55:37 <et09> what kind of type variable
14:55:46 <ertes> @let data Vec3 a = Vec3 a a a  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
14:55:48 <hpc> usually * ;)
14:55:48 <lambdabot>  Defined.
14:56:03 <ertes> > sum (Vec3 1 2 3)
14:56:05 <lambdabot>  6
14:56:08 <baordog_> sm: even tried brew reinstall. Same error pops up.
14:56:14 <et09> whoa
14:56:20 <dolio> baordog_: What about 'brew install --devel'?
14:56:41 <et09> > map (\x -> x ** 3) $ Vec3 1 2 3 
14:56:45 <lambdabot>      Couldn't match expected type ‘[b]’ with actual type ‘Vec3 Integer’
14:56:47 <lambdabot>      In the second argument of ‘($)’, namely ‘Vec3 1 2 3’
14:56:49 <lambdabot>      In the expression: map (\ x -> x ** 3) $ Vec3 1 2 3
14:56:49 <ertes> et09: fmap
14:56:52 <et09> > fmap (\x -> x ** 3) $ Vec3 1 2 3 
14:56:57 <lambdabot>  Vec3 1.0 8.0 27.0
14:57:04 <baordog_> dolio: Error: No devel block is defined for pcre
14:57:11 <et09> what if it has mixed Int and String, can you do it selectively for Int
14:57:15 <sm> baordog_: does "brew list pcre -v" show a pcre.h file ?
14:57:38 <baordog_> /usr/local/Cellar/pcre/8.38/include/pcre.h
14:57:48 <ertes> et09: this kind of deriving relies heavily on parametricity, so you can't auto-derive something like that
14:57:49 <baordog_> Yes
14:58:05 <ertes> et09: mostly because haskell wouldn't know what behaviour you want
14:58:07 <et09> right
14:58:28 <et09> haskell = climb a tibetan mountain for mastery language
14:58:30 <hpc> @let Tagged a = Tag String a deriving (Eq, Ord, Show, Foldable, Functor, Traversable)
14:58:30 <lambdabot>  Parse failed: Parse error: deriving
14:58:35 <sm> baordog_: hmm, then I am out of ideas. It works here, but I don't remember if I did something special with brew install
14:58:39 <hpc> er
14:59:13 * ski hands hpc a `data'
14:59:33 <ertes> et09: you can of course have extra fields that are ignored
14:59:41 <hpc> ski: my bot on another network is named Data
15:00:02 <ertes> et09: like this: data Blah a = Blah String a a  deriving (…)
15:00:31 <ertes> (could an op please kick me every time i use String in an example?)
15:00:33 <baordog_> For the record, I blame none of you, and I don't want to seem petulent or angry or whatever but finicky compiler stuff is kind of a turn off to using haskell on a day to day basis. Looking at the logs it appears to be searching for a version of pcre that is newer than the latest brew install version.
15:01:10 --- mode: ChanServ set +q *!*@p5485EA71.dip0.t-ipconnect.de
15:01:17 --- mode: ChanServ set -q *!*@p5485EA71.dip0.t-ipconnect.de
15:01:52 <Gurkenglas> cygwin and msys2 have the same type, right?
15:01:55 <hpc> did chanserv just go mad with power?
15:02:11 <ertes> i think someone just tried to grant my wish =)
15:02:14 <sm> baordog_: things could be a lot better, agreed. I think you will find equivalent issues with most languages as soon as you step outside their beaten path though
15:02:24 <kadoban> baordog_: Kind of just a fact of life in programming really, unfortunately.
15:02:43 <baordog_> regex-pcre-0.94.4 (haskell) vs. pcre/8.38 in brew. Those seem way off.
15:02:46 <hpc> baordog_: (for the record, the beaten path in haskell is parser combinators)
15:03:04 <glguy> baordog_: Homebrew doesn't install pcre into a standard place, so you have to provide thepath manually to caba
15:03:06 <sm> baordog_: the first is the haskell lib, the second is the c lib (no relation except one depends on the other)
15:03:33 <hpc> glguy: shouldn't it be looking at your library path?
15:03:49 <sm> glguy: I didn't
15:03:50 <baordog_> kadoban: I've never had this happen in Haskell, Java, or even C/C++. 
15:03:51 <glguy> hpc: Lots of packages in Homebrew are not installed into your library path
15:03:51 <hpc> or is brew really /that/ non-standard?
15:03:56 <hpc> ew
15:04:17 <glguy> hpc: pcre apparently isn't one of them (that seems to have changed, just tried again)
15:04:18 <baordog_> s/haskell/python
15:04:25 <et09> what is () 
15:04:29 <glguy> hpc: but it's good, they do it to avoid colliding with stuff that comes with OS X
15:04:38 <et09> :t () 
15:04:40 <lambdabot> ()
15:04:42 <et09> ^ this is super helpful 
15:04:42 <kadoban> baordog_: Then you haven't used many libraries in C or C++ ... this is literally the same thing "satisfy my deps". It happens a bit less in python probably, since not as many things have C deps.
15:05:31 <baordog_> The difference is I can get through something relatively simple without things detonating. Most small projects rely on a small group of relatively standardized libs.
15:05:59 <baordog_> But I'm just grumpy, I don't like dealing with dependencies.
15:06:05 <hpc> the same in haskell, but pcre isn't in that small group
15:06:18 <hpc> regexes are inferior to the other options for regular language parsing that haskell offers
15:06:30 <baordog_> That's... reassuring.
15:06:37 <baordog_> So now what?
15:06:59 <Gurkenglas> et09, http://hayoo.fh-wedel.de/?query=()
15:07:18 <et09> oh
15:07:22 <sm> glguy: brew automatically symlinks pcre.h in /usr/local/include, etc.
15:07:44 <hpc> you can hold cabal's hand and tell it exactly where to find your pcre library, try out applicative parsing, or whatever
15:07:59 <baordog_> >.< 
15:07:59 <ertes> is the foreign library situation on OS X that bad?
15:08:19 <ertes> and what about stack?  does it handle those?
15:08:28 <intothemountains> How can I apply `any` to a `Data.Set.Set`?
15:08:37 <kadoban> stack does not handle non-haskell dependencies, no.
15:08:45 <ertes> intothemountains: convert to a list first
15:08:57 <ertes> intothemountains: don't worry, it's cheap
15:08:59 <baordog_> The error came from a stack build.... cabal doesn't even get that far.
15:09:02 <intothemountains> ertes: I do that now, but seems a bit of a waist
15:09:06 <intothemountains> hm, ok
15:09:12 <ertes> intothemountains: the list never ends up in memory
15:09:22 <glguy> sm: Yeah, I mentioned that I was wrong about PCRE 
15:09:29 <sm> ah
15:09:34 <glguy> but in general Homebrew will install stuff that might conflict into the cellar
15:09:42 <glguy> (which is good)
15:09:51 <intothemountains> at a conceptual level though, any seems a perfect candidate to be applied to a set
15:10:00 <hpc> intothemountains: for what you're using it for (lists as control structures), the list never really exists and is just a loop waiting to happen
15:10:10 <sm> both stack install regex-pcre and cabal install regex-pcre work on this mac with no hand holding (other than "brew install pcre" or so). I'm curious why baordog_ is different. I have the current OSX release
15:10:12 <ertes> intothemountains: yes, but since Set is not (and can't be) a Foldable, you would have to write a Set-specific version
15:10:24 <ertes> intothemountains: and that one would be equivalent to (\p -> any p . toList)
15:10:47 <intothemountains> why is there a Set.filter though?
15:10:51 <hpc> :t any <*> S.toList
15:10:52 <lambdabot>     Couldn't match type ‘Data.Set.Set a’ with ‘a -> Bool’
15:10:53 <lambdabot>     Expected type: (a -> Bool) -> [a]
15:10:53 <lambdabot>       Actual type: Data.Set.Set a -> [a]
15:10:55 <glguy> ertes: No, Set is Foldable
15:11:01 <hpc> :t (any <*>)
15:11:02 <lambdabot> Foldable t => ((a -> Bool) -> t a) -> (a -> Bool) -> Bool
15:11:26 <ertes> oh!
15:11:31 <ertes> indeed, it is
15:11:40 <glguy> any :: (a -> Bool) -> Set a -> Bool
15:11:45 <ertes> intothemountains: 'any' should work out of the box for Set
15:12:18 <intothemountains> Oh
15:12:20 <intothemountains> My god
15:12:24 <intothemountains> Sorry!
15:12:45 <hpc> heh, it's easy to miss things when they're behind class instances
15:12:52 <et09> when does deriving Eq not work 
15:13:13 <ertes> et09: most notably when functions are involved
15:13:33 <ertes> @let newtype Can'tDerive = Can'tDerive (Bool -> Bool)  deriving (Eq)
15:13:34 <lambdabot>  .L.hs:165:30:
15:13:35 <lambdabot>      No instance for (Eq (Bool -> Bool))
15:13:35 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
15:13:56 <et09> that's strange
15:13:58 <hpc> et09: you can only derive Eq for data types where every field of every constructor has an Eq instance
15:14:06 <et09> ah, that makes sense
15:14:13 <hpc> functions are an obvious case where you can't compare them for equality
15:14:30 <hpc> you have to decide if \x -> x + x is equal to \x -> x * 2
15:14:43 <et09> btw how does the compiler handle a data Foo = Foo { a :: Int }  etc., is it represented as a hashmap or something?
15:14:52 <hpc> and it can go either way with some interesting theoretical consequences
15:15:06 <mauke> et09: it's basically a tuple
15:15:06 <et09> isn't that like P and NP or something
15:15:09 <ertes> et09: it's handled just like:  data Foo = Foo Int
15:15:12 <hpc> foo :: a -> Foo
15:15:18 <hpc> a :: Foo -> Int
15:15:30 <et09> thats giving me a headache
15:15:35 <baordog_> sm: I think I needed to run stack setup first?
15:15:39 <baordog_> Trying that now. 
15:15:39 <ertes> et09: you're just naming the fields
15:15:41 <mauke> 'a' is the worst field name
15:15:46 <hpc> it's the same as data Foo = Foo Int; a (Foo x) = x
15:15:47 <et09> yeah just for an example
15:15:48 <baordog_> If it needed setup.... why did it even run in the first place?
15:15:58 <baordog_> Why didn't it setup on install >.<
15:15:58 <sm> it didn't.. but no harm in trying
15:16:07 <et09> btw if a field name overlaps in different data's, does it just pattern match the deconstructor/accessor? 
15:16:16 <mauke> that should be an error
15:16:28 <et09> what i said should be an error?
15:16:32 <ertes> (why did i think that Set can't be Foldable?)
15:16:35 <hpc> et09: it'd be duplicate definitions of the same function
15:16:36 <mauke> yeah, you're redefining functions
15:16:52 <et09> umm
15:16:54 <haldean> @et09 that's slated for GHC 8.0, called OverloadedRecordFields: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
15:16:54 <lambdabot> Unknown command, try @list
15:16:58 <hpc> data Foo = Foo {a :: Int}; data Bar = Bar {a :: String}
15:17:01 <hpc> et09: what's the type of a?
15:17:07 <et09> how on earth would you do an ORM then with like "id" as a field name
15:17:26 <mauke> I wouldn't do an ORM
15:17:32 <Welkin> et09: you can if you want to
15:17:35 <sm> baordog_: may I ask your osx, stack, cabal versions ?
15:17:39 <haldean> and/or don't use records
15:17:58 <mauke> also, how would you do an ORM with "if" as a field name?
15:18:07 <mauke> or "case". or "type"
15:18:08 <baordog_> sm: Stack setup appears to have fixed it, it's at least attempting to isntall pcre now.
15:18:14 <baordog_> We'll see if the other build is resolved.
15:18:17 <et09> how do i represent a record then?
15:18:28 <baordog_> Is stack the one with the cool constraint based dep. resolver? Or is that cabal?
15:18:43 <sm> cabal has that (and stack also uses it)
15:18:48 <mauke> cabal has a constraint solver. not sure how cool it is
15:18:58 <baordog_> Guess it's just some sat solver thing. 
15:18:58 <hpc> it's not that cool
15:19:01 <geekosaur> new-build's is pretty cool
15:19:07 <ertes> et09: data Person = Person { _name :: Text, _birthday :: UTCTime }  -- like that?
15:19:16 <glguy> I went to a party with cabal and he was pretty cool
15:19:30 <haldean> et09: you can use ADTs with no names on the fields, so you have to unpack to get at the contents of the row
15:19:42 <baordog_> sm: Crapped out with the sam errror on pscre-install 
15:19:45 <baordog_> *pcre 
15:19:50 <haldean> ertes: that still has the problem that if two of your types store a "name", you'll have a collision on _name
15:19:57 <ertes> sure
15:20:00 <baordog_> I bet this would build flawlessly on linux
15:20:03 <et09> how do you do that
15:20:03 <sm> baordog_: when building regex-pcre, right ?
15:20:29 <baordog_> sm: yup
15:20:30 <baordog_> cabal-install version 1.22.9.0
15:20:31 <sm> does "cd; stack install regex-pcre" work ?
15:20:45 <ertes> et09: is there anything wrong with what i wrote?
15:20:53 <baordog_> Version 1.0.4.3 x86_64 (stack)
15:20:59 <glguy> baordog_: You can get better help if you paste the terminal output from the command you typed until it finished
15:21:03 <et09> ertes: only question is, how do you then access the _name field
15:21:06 <glguy> to a pastebin
15:21:16 <ertes> et09: _name is a function
15:21:19 <baordog_> glguy: maybe later tonight, I'd have to sanitize the paths
15:21:26 <ertes> et09: _name :: Person -> Text
15:21:29 <et09> ..doesn't it then overlap something else with _name ? 
15:21:35 <ertes> et09: it does
15:22:12 <ertes> et09: you can either use the traditional style of prepending the record name to each field, or you can use GHC 8's latest extensions that resolves collisions by type
15:22:29 <glguy> or qualified imports
15:22:46 <et09> and by that you mean the type of the data itself?
15:22:47 <mauke> that forces you to put your types in separate modules
15:22:59 <glguy> which isn't a terrible plan
15:23:09 <baordog_> sm: with cd; it blew up in exactly the same manner. 
15:23:15 * mauke proceeds to name all his types 'T'
15:23:36 <sm> baordog_: and the same with "cd; cabal install regex-pcre" ?
15:23:40 <ertes> some libraries do that unfortunately
15:23:49 <ertes> et09: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#duplicate-record-fields
15:23:52 <sm> just being thorough
15:24:18 <ertes> et09: haven't used it yet…  somehow i rarely get such collisions
15:24:40 <sm> baordog_: and do you have a working /usr/local/include/pcre.h symlink ?
15:25:25 <et09> i guess you'd probably be using Yesod or something in this case anyway
15:25:57 <baordog_> sm: How would I test that?
15:26:05 <ertes> i can see how it can come up when using yesod/persistent =)
15:26:11 <sm> head /usr/local/include/pcre.h should show stuff
15:26:12 <ertes> but i don't like ORM
15:26:31 <baordog_> sm: Yeah dude it's definitely there.
15:26:36 <baordog_> Works like a charm.
15:26:54 <sm> >:|
15:26:58 <et09> what's the alternative ertes
15:27:21 <ertes> et09: the alternative is not to model "databases", but your application
15:27:34 <et09> right
15:27:35 <ertes> write a data/storage semantics for your application and then implement it
15:28:05 <baordog_> Gotta run. Be back on later tonight.
15:28:16 <sm> good luck
15:28:16 <ertes> that also helps you to use advanced features of the storage engine you use…  for example postgresql has lots of features that most people never use, because it doesn't fit their "ORM"
15:28:24 <sm> maybe open a bug
15:28:47 <et09> true
15:29:16 <sm> is it possible you have a broken GHC installed ? you could try removing that
15:29:42 <dfeuer> Ping glguy
15:30:36 <sm> or, try "stack build --resolver lts --no-system-ghc" (if you read this)
15:30:53 <ertes> sm: (they're gone)
15:31:02 <sm> I know. Hard to move on :)
15:31:32 <ertes> sm: i mean they're no longer in the channel =)
15:34:07 <aesonlenshelp> I cannot figure out how to filter "key"'s within this list of "key"/"value" objects and then get the value: "[{\"key\": \"key1\", \"value\": \"val1\"}, {\"key\": \"key2\", \"value\": \"val2\"}]\n" ^@..traversed.ifiltered (\_ b -> b ^? key "key" == Just "key1") . nth 0 . key "value" . _String
15:34:59 <aesonlenshelp> say I wanted I wanted to search the list for the value of "key1", I'd expect "val1" back
15:40:59 <dmj> aesonlenshelp: so you want to lookup the key based on the value?
15:41:36 <squall> How do I extract values from an existential datatype?
15:41:36 <dmj> aesonlenshelp: or are you saying, given the value of "key1", I want to receive the value "val1"
15:42:07 <aesonlenshelp> dmj: The second one.
15:42:25 <aesonlenshelp> dmj: Someone should have just made this another json object, but instead for whatever reason they made a list of key value objects
15:42:35 <aesonlenshelp> I can't change it so I have to parse it
15:44:46 <ski> squall : pattern-matching
15:45:09 <squall> Something about escaping it's scope
15:45:18 <dmj> aesonlenshelp: I would change the data first to be appropriate. You can do that in the FromJSON instance
15:45:20 <ski> they mustn't escape
15:45:48 <aesonlenshelp> dmj: I can't do that. This is an internal tool for work and hundreds of applications depend on that silly format
15:46:00 <ski> squall : hard to say more, without more info ..
15:46:18 <dmj> aesonlenshelp: I'm not saying change the json, but the data type you parse into, should be representative of the correct format
15:47:16 <aesonlenshelp> dmj: I'm using lens throughout my code for various reasons (avoiding making *a lot* of types that would frequently change) so I was asking specifically for a lens solution. I know how to do this with types/fromJson instances.
15:47:38 <dmj> aesonlenshelp: your json sources frequently change?
15:47:44 <squall> I can instantiate a class Cast a b which requires cast :: a -> b too but not from an existential type?
15:48:02 * ski doesn't understand squall's question
15:49:30 <squall> As in, instance Cast ExistentialType OtherType where cast :: ExistentialType  -> OtherType
15:49:38 <dmj> aesonlenshelp: in this case, the data is shallow, so I wouldn't reach for lens, but that's just me. 
15:50:08 <ski> squall : depends on how `ExistentialType' and `OtherType' are defined
15:50:12 <squall> cast (ET a)  = OT a
15:50:40 <aesonlenshelp> dmj: this is a distilled version of my problem. It's about 3 levels deep and there are many different categories. I use lens to switch from doing lookups in various categories at various depths
15:51:43 <dmj> aesonlenshelp: if the json is that bad, I'd wrap all calls to that service with another server that normalizes the data, then slowly migrate the other apps to call the new API, then phase out the API that has fields named "key", "value"
15:51:52 <squall> data ET where ET Constraint a => a -> ET
15:52:11 <ski> s/Constraint/:: Constraint/, presumably
15:52:27 <squall> Et ::
15:52:31 <squall> Yeah
15:53:05 <squall> data ET where ET :: Constraint a => a -> ET
15:53:14 <dmj> aesonlenshelp: could you paste the entire example then?
15:53:20 <squall> OT = Maybe for exemple
15:53:33 <ski> that doesn't work
15:53:44 <dmwit> :t fromDynamic
15:53:44 <squall> I know
15:53:45 <lambdabot> Typeable a => Dynamic -> Maybe a
15:53:53 <ski> given `class Cast a b where cast :: a -> b', `b' must have kind `*'
15:54:22 <ski> but `Maybe' has kind `* -> *', so `instance Cast ExistentialType Maybe' can't possibly work
15:54:44 <ski> (it's ill kinded)
15:55:12 <squall> Um, OT = Maybe a
15:55:18 <squall> Or just Int
15:55:22 <squall> Idk
15:55:45 <ski> neither `data OT = MkOT (Maybe a)' nor `data OT = MkOT Int' will work
15:56:06 <ski> in the first, `a' is not bound, so the `data' declaration is bad
15:56:06 <squall> Gosh
15:56:08 <dmwit> You will only be able to define such an instance of `Cast` in such a case if `Constraint` gives you a way to construct an `Int` from your value.
15:56:32 <dmwit> (Or the specific `Maybe a` type you write in the instance head, assuming you write that instead of `Int`.)
15:56:42 <squall> That seems reasonable
15:56:46 <ski> in the second, it doesn't work since if you get a value of an arbitrary type `a' about which it is only known that `Constraint a', then it doesn't follow directly that `a' must be `Int'
15:57:07 <squall> But I can't even use eg cast (ET a) = a
15:57:29 <ski> right, what would the type of this `cast' be ?
15:57:29 <dmwit> `data ET where ET :: Integral a => a -> ET; instance Cast ET Integer where cast (ET v) = toInteger v` would work okay. But certainly not `cast (ET a) = a`, ever.
15:57:53 <aesonlenshelp> dmj: The entire example: https://gist.github.com/anonymous/9fe5ec87759ec3cfc358df34876b5ed0
15:58:08 <mniip> instance Cast ET (forall a. a)
15:58:10 <mniip> :)
15:58:24 <ski> mniip : wouldn't work either :)
15:58:25 <squall> It should at least instantiate constraint so I guess forall a. Constraint a => a
15:58:32 <mniip> right, that's not valid
15:58:38 <dmwit> ski: Well, unless `type Constraint x = x ~ Int` or something. ;-)
15:58:42 <ski> (`instance Cast ET (exists a. a)' would be another matter)
15:58:51 <mniip> eh
15:58:57 <mniip> not really
15:59:07 <ski> dmwit : yeah, except squall already ruled out that :)
15:59:14 <mniip> oh yes indeed
15:59:17 <mniip> really
15:59:20 <dmwit> Oh, okay. Sorry I hadn't read enough scrollback.
15:59:24 <squall> No?
15:59:33 <dfeuer> Ping Cale 
15:59:47 <ski> squall : no `instance Cast ET (forall a. Constraint a => a)' would be just as wrong
15:59:57 <dmwit> squall: Generally: you don't extract values from existential types. You only run typeclass methods that return monomorphic types on them.
16:00:07 <ski> squall : the caller of `cast' does not get to pick which type `a' to use (which that would suggest)
16:00:27 <dfeuer> dmwit, you can also wrap them back up in new existentials, like dmap.
16:00:31 <ski> squall : rather, the producer of the `ET' value have already picked a type to use for `a' inside `ET'
16:00:33 <dfeuer> er ... DMap?
16:00:40 <Gurkenglas> aesonlenshelp, why are you using ifiltered if you dont use the index?
16:00:44 <dmwit> squall: See also the canonical "existential antipattern" blog post: https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
16:01:01 * dmwit nods at dfeuer
16:01:05 <ski> squall : and any use of `ET' which pattern-matches will have to be satisfied with any possible choice for `a' that this producer have struck
16:01:28 <squall> I think if it instantiates constraint I should be able to return it without fixing it's type
16:01:40 <dfeuer> Existentials start looking more useful once you start sticking GADTs inside them.
16:01:43 <Gurkenglas> aesonlenshelp, try previewing values . filtered (views (key "key") (== "key1")) . key "value"
16:01:57 * ski isn't sure whether the antipattern blag is appropriate to point to, just yet
16:02:00 <dmwit> squall: Are you sure you don't rather want `newtype UT = UT (forall a. Constraint a => a)`?
16:02:20 <squall> That's not the same?
16:02:26 <aesonlenshelp> Gurkenglas: Trying
16:02:28 <dmwit> squall: A value of type `UT` says that somebody can come along later and choose which instance of `Constraint` to use.
16:02:32 <ski> (to me, this looks more like not understanding how existentials work, rather than not having enough judgement on when to use them and when not to)
16:02:44 <dmwit> squall: Nope. In short: `ET` says the producer chooses the instance; `UT` says the consumer chooses the instance.
16:02:53 <Gurkenglas> aesonlenshelp, oh um the code starts after "previewing", I meant you're supposed to preview that fold :D
16:03:12 <squall> Hmm I thought I could use gadt and existential interchangeably
16:03:22 <ski> squall : `UT' is more or less the "opposite" of `ET'. very different
16:03:23 <dmwit> UT isn't a GADT.
16:03:29 <mniip> both exist in gadt
16:03:36 <squall> (squall) data ET where ET :: Constraint a => a -> ET
16:03:56 <squall> (dmwit) squall: Are you sure you don't rather want `newtype UT = UT (forall a. Constraint a => a)`?
16:03:58 <ski>   data UT where UT :: (forall a. Constraint a => a) -> UT
16:04:03 <squall> Thanks
16:04:04 <dmwit> squall: In GADT syntax, this would be `data UT where UT :: (forall a. Constraint a => a) -> UT`.
16:04:06 <mniip> data ET where ET :: forall a. Constraint a => a -> ET
16:04:10 <ski> the brackets there are very important
16:04:14 <mniip> data UT where UT :: (forall a. Constraint a => a) -> ET
16:04:25 <dfeuer> I'm trying to decide whether the strict merge tactics and lazy merge tactics for Data.Map should be the same type or different types.
16:04:35 <squall> Hmmmm
16:04:36 <ski> the definition for `ET' is equivalent to `data ET where ET :: (exists a. Constraint a *> a) -> ET'
16:04:39 <squall> Looks hopeful
16:04:42 <ski> (hence "existentials")
16:04:46 <dfeuer> There's more potential for confusion if they're the same type, but also more flexible.
16:04:50 <mniip> ski, what's that *> you keep referring to
16:05:01 <dfeuer> *they're also more flexible that way.
16:05:21 <squall> Exists I hadn't seen that keyword
16:05:23 <ski> mniip : (->) : (,) :: (=>) : (*>)
16:05:28 <dmwit> mniip: I think it's a hypothetical analog to `(,)` of kind `Constraint -> * -> *`.
16:05:45 <dmj> aesonlenshelp: I guess I would first parse it into a format that makes sense, then use lens on that
16:05:51 <squall> Wowza
16:06:11 <mniip> ski, now you're just making up more syntax
16:06:23 <shachaf> data k *> a = k => Foo a
16:06:24 <dmwit> Making up syntax is fun. =)
16:06:28 <shachaf> There you go, not made up.
16:06:28 <geekosaur> exists isn't a keyword (except in uhc). the point is more that we can "derive" exists from forall
16:06:37 <ski> squall : it doesn't exist (in GHC. it exists in LHC, but only in a restricted way). i use it (also `*>') as pseudo-code, to conceptually describe the existential types which then `ExistentialQuantification' language extension allows *one* *encoding* of
16:06:38 <dmj> aesonlenshelp: [{}], should really just be {}
16:06:55 <shachaf> The real scow is when people say something like (exists a. Show a => a) when they mean (exists a. Show a *> a)
16:07:12 <squall> Oh my god this is intense
16:07:12 <shachaf> Like exists, *> is a useful concept to have, even if GHC doesn't support it.
16:07:33 * mniip is confuse
16:08:00 <squall> Maybe I'll just try messing around with that UT version to see if it will work... Unless you would like to see the code
16:08:06 <shachaf> "data k *> a = k => Foo a" is a valid definition of *> in GHC.
16:09:03 <mniip> ah
16:09:11 <squall> Is there a resource or keyword for this UT object?
16:10:13 <ski> mniip : see "A:B::C:D" at <https://en.wikipedia.org/wiki/Ratio#Notation_and_terminology>
16:10:27 <ski> mniip : it means "`A' is to `B' as `C' is to `D'"
16:10:38 <mniip> ski, forall a. Constraint a => a -> ET  --->  forall a. (Constraint a *> a) -> ET  ---> (exists a. (Constraint a *> a)) -> ET
16:10:39 <mniip> right?
16:10:51 <ski> yes
16:10:58 <ski> it's basically (un)currying
16:11:28 <mniip> hmm, I'm familiar with A:B, but not ::
16:11:30 <squall> I wish my brain was stronger
16:12:16 <squall> Anyway out sounds hopeful
16:13:04 <squall> Id like to put up a paste of the code if you might be able to direct me through the procedure, but not if that's going to waste time
16:13:11 <ski> squall : the data constructor `ET' is polymorphic (in `a'), but doesn't mention `a' in the return type (`ET'). so any call of the data constructor on a value of type `a' will "hide" the type `a', so that it's not visible in the result type `ET'
16:13:12 <aesonlenshelp> Gurkenglas: That didn't seem to work: https://gist.github.com/anonymous/10708169f23b7f194c78dde27c039cea
16:13:36 <squall> Ok I'm with you so far
16:13:47 <ski> squall : constrast this with applying `Just' to a value of type `a'. then the result type is `Maybe a', and so the type `a' can be recovered from that (when pattern-matching)
16:14:03 <squall> It's all a that instantiate constraint
16:14:20 <squall> a isn't specified
16:14:48 <squall> How does UT get round this?
16:14:50 <ski> squall : because an "existential data constructor" like the data constructor `ET' for the type `ET' *hides* the type variable `a', this means that we could have used e.g. type `Int' when constructing one value of type `ET', and e.g. type `String' when constructing another value of type `ET'
16:15:23 <squall> Ok
16:15:35 <ski> squall : so, the type `ET' tells us nothing about the actual type `a' used when constructing the value (except that we know that it must have been a type which is an instance of `Constraint')
16:15:41 <Gurkenglas> aesonlenshelp, I answered the question you put in the channel, not the one you pasted, as visible by the fact key1 doesnt appear in the paste. Let me try for the paste
16:15:58 <squall> Yes I understand that much fine
16:16:07 <aesonlenshelp> Gurkenglas: Thanks. I'm sorry for the inconsistency.
16:16:43 <phaazon> sm: nope (for ssl on tellbot)
16:16:50 <mniip> I wonder if you can come up with english spellings of 'forall' and '=>' that will make everything easy to understand
16:17:12 <ski> squall : so, when pattern-matching, to be on the safe side, we can't assume *anything* about which actual type `a' was used. if we e.g. get two different `ET' values (or even the same one, passed twice in two separate arguments), we must assume that their "internal/hidden/opaque" types `a' are distinct from each other, and from any other concrete type like `Int' and `String'. simply because they *might* actually have been different
16:17:50 <ski> squall : in short, the *user* of an "existential value" has to be *polymorphic* in the "internal type variable", can't assume anything about it
16:18:16 <squall> Hmm
16:18:21 <ski> squall : in the same way that `reverse :: forall a. [a] -> [a]' has to be polymorphic in `a', can't assume anything about the actual type chosen by the caller for `a'
16:18:31 <Gurkenglas> aesonlenshelp, try previewing 'key "category1" . (key "attr3" <> (key "category1.2" . values . filtered (views (key "key" (=="attr3"))) . key "value"))'
16:18:40 <Kaidelong> how does church encoded Env look like? ((e -> t -> w) -> w) -> w ?
16:18:44 <squall> So I can't cast it to Constraint a => Maybe a
16:18:50 <mniip> Kaidelong, Env?
16:18:59 <Kaidelong> http://hackage.haskell.org/package/lens-3.10/docs/Control-Comonad-Env.html
16:19:08 <mniip> squall, it will be an "exists"
16:19:29 <squall> Yeah I need that resource...
16:19:43 <Gurkenglas> (Still not sure which of the first two opened bracket pairs are necessary)
16:19:46 <squall> Is that what the UT example was doing?
16:20:02 <ski> squall : the *producer* of a polymorphic value (like `reverse'. the producer is the implementation of `reverse') must treat the type variable "opaquely", can assume nothing about it (except any type class constraints that are explicitly granted, as in `sort :: forall a. Ord a => [a] -> [a]')
16:20:25 <mniip> forall $var. = the user of the following is able to pick anything for $var:
16:20:25 <squall> (mniip) data ET where ET :: forall a. Constraint a => a -> ET
16:20:38 <squall> (mniip) data UT where UT :: (forall a. Constraint a => a) -> ET
16:21:18 <ski> squall : while the *consumer* of an "existential value", one of type `exists a. Constraint a *> a' e.g. (or, the workaround `ET' that is one option that we can actually use in practice) must similarly treat the type variable opaquely
16:21:42 <mniip> squall, can you see the difference between: foo :: forall a. (a -> a) -> X; bar :: (forall a. a -> a) -> X
16:22:13 <ski> squall : otoh. the *consumer*/caller of a polymorphic value may pick the type variable to be anything they like (provided any specified type class constraints are satisfied). a caller of `sort' can pick `a' to be `Integer' e.g.
16:22:54 <benzrf> in ZFC without LEM, can you prove the existence of non-continuous functions R -> R?
16:23:13 <squall> I'm struggling to see the difference
16:23:21 <ski> squall : similarly, the *producer* of an "existential value" may pick the type variable to be anything they like (provided ditto). in the `ET' case, a producer like `ET False' would pick `a' as `Bool' (assuming `Constraint Bool' indeed holds)
16:23:31 <benzrf> actually im not sure ive really thought about ZFC without LEM before
16:23:37 <benzrf> how much *does* it break down?
16:23:40 <ski> squall : so, `forall' and `exists' are in some sense the opposite of each other
16:23:43 <benzrf> oh christ i thought this was ##math
16:24:32 <ski> benzrf : there's intuitionistic set theory
16:24:46 <latro`a> @ benzrf: sorry for briefly off-topic, but smooth infinitesimal analysis is a form of nonstandard analysis in an intuitionistic logic, in which all functions from R to R are in fact smooth
16:24:50 <benzrf> yeah but is that just ZFC without LEM, or is it otherwise defined
16:25:01 <squall> If you could show me how to use exists to fix my code it would be super helpful
16:25:05 <benzrf> latro`a: yeah, i was wondering specifically about ZFC
16:25:11 <ski> benzrf : iirc, "Constructivism in Mathematics. Volume 2" by Troelstra goes into it
16:25:13 <mniip> but
16:25:17 <mniip> exists doesn't exist
16:25:19 <haldean> ZFC without LEM and axiom of choice I think
16:25:27 <squall> Nooooo
16:25:29 <aesonlenshelp> Gurkenglas: Did you mean like this: preview (key "category1" . (key "attr3" <> (key "category1.2" . values . filtered (views (key "key" (=="attr3"))) . key "value"))) bs
16:25:39 <benzrf> squall: here's a tip
16:25:40 <mniip> it's a mathematical thing that we might use to reason about haskell
16:25:46 <mniip> but it's not an actual part of syntax
16:26:03 <benzrf> squall: my problem, when i was learning about existential types, was that i was thinking about types wrong
16:26:14 <benzrf> squall: in haskell at least - there aren't certain values which naturally have an existential type
16:26:30 <benzrf> squall: instead, some values which already have some other type, can *also* be viewed as having an existential type
16:26:40 <ski> mniip : i think it might be better to get the difference between `forall' and `exists' firm, before treating higher-rank
16:26:44 <Gurkenglas> aesonlenshelp, preview l bs is just bs ^. l
16:26:46 <benzrf> [1, 2, 3] :: [Int], but you can also say [1, 2, 3] :: exists a. [a]
16:26:49 <orion> What's the IRC command for poinfree?
16:26:53 <orion> Pointfree
16:26:56 <Gurkenglas> and yes :P
16:26:57 <benzrf> orion: it's a bot command, not an irc command, but it's @pl
16:27:10 <ski> benzrf : or `[1,2,3] :: [exists a. a]' (which isn't the same thing)
16:27:14 <benzrf> ski: yeah
16:27:30 <ski> orion : `pointless'
16:27:39 <squall> As far as I can tell existential types are datatype contexts
16:27:42 <benzrf> squall: so for example, "exists a. [a]" is the type of lists of anything
16:27:54 <benzrf> squall: anything that has type [Something] can also work as a value of type "exists a. [a]"
16:28:23 <benzrf> (the "exists." isn't actual haskell syntax fyi)
16:28:31 <orion> @pl foo f = test f
16:28:31 <lambdabot> foo = test
16:28:37 <squall> That makes sense
16:28:43 <benzrf> good :)
16:28:49 <squall> Thanks
16:28:49 <ski> conceptually, `[False,"Hello",3]' has type `[exists a. a]' (because every element has type `exists a. a', because for every element there exists a type `a' such that the element has type `a')
16:28:49 <orion> @pl isConnectionUp c = not <$> isEmptyMVar (rmqConn c)
16:28:49 <lambdabot> isConnectionUp = (not <$>) . isEmptyMVar . rmqConn
16:28:50 <benzrf> so that's basically the idea of existential types
16:29:12 <mniip> so uh
16:29:14 <mniip> okay
16:29:16 <orion> Awesome, thanks ski/benzrf.
16:29:21 <benzrf> np
16:29:34 <mniip> with forall, the user is free to pick anything and the producer has to be able to accomodate for anything
16:29:36 <ski> `[1,2,3]' also has type `[exists a. a]' (in addition to `exists a. [a]')
16:29:39 <mniip> with exists the roles are swapped
16:29:42 <squall> I can't seem to understand how to get get the code to compile yet which is frustrating me
16:29:57 <mniip> which code
16:30:05 <aesonlenshelp> Gurkenglas: Still an error. I think I know why though. I need to look into the Value object right? error: https://gist.github.com/anonymous/22811d260c06dc101a5e4ebfaedb7390
16:30:08 <ski> however, `[False,"Hello",3]' doesnt have type `exists a. [a]' (since there doesn't exists a single type `a' such that every element has that type `a')
16:30:15 <benzrf> squall: "forall a. ([a] -> Int)" is the same as "(exists a. [a]) -> Int" - see why?
16:30:19 <johnw> after using Coq for a while, writing in Haskell feels similar to coding in Python :)
16:30:21 <squall> Wait I'll make a paste but it's long
16:30:24 <benzrf> johnw: i know, right
16:30:28 <ski> (unless you believe in impredicativity ..)
16:30:31 <johnw> there's just so much you can do easily and get away with!
16:30:47 <johnw> and the syntax features are amazing
16:30:51 <baordog_> baaack
16:31:02 <benzrf> i dunno, coq has nutso syntax features
16:31:06 <benzrf> notations! :)
16:31:10 <johnw> Haskell really is at a nice sweet spot between the two
16:31:23 <ski> squall : "existential types" doesn't exist in Haskell. however we can *encode* them (in two main ways, we're, partly, discussing one of these ways)
16:31:29 <squall> Benzrf, no that's not apparent yet
16:31:30 <Gurkenglas> aesonlenshelp, nah I misplaced a bracket ._. 'key "category1" . (key "attr3" <> (key "category1.2" . values . filtered (views (key "key") (=="attr3")) . key "value"))'
16:31:36 <benzrf> ive been writing haskell for the purpose of producing an executable, useful program
16:31:38 <benzrf> for the first time in ages
16:31:43 <benzrf> i forgot how much fun it could be
16:31:43 <baordog_> apt-get install xmonad
16:31:46 <baordog_> derp
16:31:48 <benzrf> squall: ahh
16:31:58 <dolio> ski: How is impredicativity going to help?
16:32:20 <squall> I'll make a paste hang on
16:32:20 <dolio> Or do you mean a = exists a. a?
16:32:25 <ski> dolio : every element has type `exists a. a', therefore there exists a common type `a' such that every element has type `a'
16:32:30 <ski> yep
16:32:47 <squall> I have to boot up the old analog machine
16:33:11 <Gurkenglas> aesonlenshelp, also I said previewing it, not viewing it. You need to use ^?, because there might not be a result
16:33:17 <dmj> johnw: between python and coq? :) 
16:33:23 <johnw> dmj: yeah :)
16:33:46 <Gurkenglas> aesonlenshelp, oh shoot I said preview l bs is bs ^. l? I meant ^? :(
16:33:47 <dolio> ski: Huh, I hadn't thought about that before. That kind of mucks things up.
16:33:53 <benzrf> hmm, python and coq...
16:33:57 <benzrf> two great sources of immature jokes (:
16:34:04 <johnw> between "I don't care what my program means" to "I have to prove that it means exactly what I said it did"
16:34:07 <Gurkenglas> (aesonlenshelp, view l bs is bs ^. l)
16:34:31 <mniip> why do people use operators :(
16:34:37 <LettuceThree> Coq is way too hard for my uses
16:34:49 <benzrf> LettuceThree: ( ͡° ͜ʖ ͡°)
16:35:37 <LettuceThree> Just look at the logo. The French knew exactly what they were doing
16:35:40 <johnw> and yak shaving can be terminal in dependently typed languages
16:35:45 <dolio> ski: If you don't believe in impredicativity, you're going to have a hard time arguing for [exists a. a], too, though. :)
16:35:51 <aesonlenshelp> Gurkenglas: I think I'm close: https://gist.github.com/anonymous/a29221a3a5df512716b812de111e41c2
16:35:59 <johnw> (oh wait, I just spent 9 hours proving a property about lattices that I don't actually need)
16:35:59 <mniip> LettuceThree, something tells me you're not using Coq appropriately there
16:36:31 <LettuceThree> mniip: I may need to ease into it a little more. I may have come on too strong
16:36:42 <ski> dolio : i suppose :)
16:36:51 <jle`> is impredicativity inherently flawed? or is it just GHC's attempts to implement it?
16:37:13 <jle`> s/flawed/uber bad
16:37:25 <dmj> dolio: can I ask you a vector question
16:37:25 <dolio> GHC's inference algorithm isn't designed to handle it.
16:37:28 <LettuceThree> jle`: Impredicativity leads to inconsistencies in martin-lof. For example, here's a proof of any statement: proof = proof
16:37:51 <Gurkenglas> aesonlenshelp, ah of course, filtering needs a way to always get the bool, not the possible lookup we've been giving it. We can either substitute Nothing with False or promise there's never Nothing. Do you want to error out if an object in category1.2 has no "key" entry?
16:37:57 <dolio> It's also suspiciously close to being inconsistent, though not known to be so if you're careful enough.
16:38:01 <dolio> dmj: Sure.
16:38:13 <ski> LettuceThree : that's general recursion
16:38:16 <aesonlenshelp> Gurkenglas: I want to just return nothing if no key entry exists
16:38:50 <LettuceThree> ski: What's the difference? General recursion is impredicative
16:38:50 <Gurkenglas> aesonlenshelp, 'key "category1" . (key "attr3" <> (key "category1.2" . values . filtered (fromMaybe False . views (key "key") (=="attr3")) . key "value"))'
16:39:09 <Gurkenglas> aesonlenshelp, 'key "category1" . (key "attr3" <> (key "category1.2" . values . filtered (fromMaybe False . previews (key "key") (=="attr3")) . key "value"))' :(
16:39:39 <dolio> What's the difference between fish and animals?
16:40:02 <benzrf> dolio: there's all kinds of differences!
16:40:12 <benzrf> ;)
16:40:39 <dmj> dolio: if mutable vectors don't produce intermediate data structures, what benefit is there to using the Stream/Bundle interface with them? I'm specifcally referring to the 'internal operations' section of Data.Vector.Generic.Mutable (i.e. mstream / unstream). Is it only for ease in constructing vectors? Or is my initial assumption incorrect? 
16:41:09 <aesonlenshelp> Gurkenglas: I was about to post the previews edit
16:41:51 <dolio> dmj: I'm not sure what you mean by 'intermediate data structures'. But writing actual mutable vector code will involve actual vectors.
16:42:11 <LettuceThree> dolio: He means that operations on mutable vectors don't produce a new copy of the vector
16:42:20 <aesonlenshelp> Gurkenglas: That works. Now to understand it :D
16:42:41 <LettuceThree> dolio: The question is why bother with streaming and stream fusion if mutable vectors don't get copied anyway
16:42:46 <LettuceThree> (I assume)
16:43:04 <dolio> Oh. Well, what if you don't want there to be a vector at all? Just a loop.
16:43:51 <lambdamu> does someone know why the first type family explodes and the second does not? :kind! EnumFromToAsc 1 2 eats all memory with the first while the second one works even with :kind! EnumFromToAsc 1 30000
16:43:53 * ski naively imagines the mutable vector might be used to seed a loop (constructed by fusion)
16:43:53 <lambdamu> http://lpaste.net/178370
16:44:51 <dolio> But the fusion stuff is built for immutable vectors mostly. If you ever have to build on of those, part of doing that is a mutable vector that you write to and then freeze.
16:45:08 <lambdamu> Somewhere I read single equation type families are expanded in Core whatever that means exactly
16:46:45 <dolio> If what you have is a mutable vector, and you want an immutable one, it may not be appropriate to just freeze it, either, if you want it to stay mutable, so you might need to stream out of it and into another one that you then freeze.
16:48:31 <dolio> And of course there are also rules for simplifying away that stuff if it's just an artifact of some pipeline.
16:51:13 <squall_> hi
16:51:18 <squall_> sorry that took so long
16:51:23 <squall_> http://lpaste.net/178371
16:51:28 <squall_> its brutally long, sorry
16:52:07 <dmj> dolio: ah, that's what I assumed, that Bundle / Stream was moreso for immutable vectors. So it seems like there won't performance gains when used with mutable vectors, but it's just a convenience for constructing new vectors, transforming them into different mutable vectors (or immutable).
16:52:19 <squall_> i guess really i should upload it to Hackage, but id rather iron out this last bug first
16:52:55 <dmj> there won't be*
16:53:28 <dolio> dmj: Yeah. The bundle/stream stuff is mostly so that you can write algorithms in terms of immutable vectors that use as few actual vectors as possible.
16:53:51 <squall_> the error is on line 101
16:53:59 <dolio> Which I suppose is kind of odd, in a way.
16:54:00 <ski> squall_ : and ther type class `Switch' ?
16:54:11 <squall_> what about it?
16:54:28 <ski> oh, sorry. now i see that you included it as well
16:54:52 <squall_> yeah, many modules, sorry
16:55:16 <squall_> if you either seperate that paste into appropriate files it compiles
16:55:26 <squall_> or remove the module and import lines
16:55:52 <squall_> if your clipboard is up to it!
16:56:31 <squall_> i think its worth looking at the pixels module on its own as its getting almost neat enough to read
16:57:04 <squall_> cabal install gloss-juicy needed also
16:57:42 <dmj> dolio: ah perfect, thanks. 
16:58:34 <dmj> dolio: just didn't want to be missing out on something good, that's all :) 
16:58:53 * hackagebot hpack-convert 0.14.5 - Convert Cabal manifests into hpack's package.yamls  https://hackage.haskell.org/package/hpack-convert-0.14.5 (yamadapc)
17:00:36 <squall_> ski: any joy?
17:00:57 <dfeuer> Hey, can someone suggest a place on the web where I can stick Haddocks for a proposed containers API?
17:01:17 <ski> squall_ : `class Cast a b where cast :: a -> b' and `instance (Switch a b,HasCanvas a) => (Cast (Either a b) ToCanvas) where ...' implies `cast :: forall a b. (Switch a b,HasCanvas a) => Either a b -> ToCanvas' for that instance
17:02:06 <squall_> thats correct
17:02:43 <squall_> is it bad?
17:02:51 <dmj> dolio: trying to diff two mutable rose trees, and perform IO on certain patterns. Something like data RoseVec v m a where VNode :: MutVar (PrimState m) Text -> v (PrimState m) (RoseVec v m a) -> RoseVec v m a... realized boxed mutable vectors is what I need, heard using the Generic interface was most kosher, saw Stream, then got confused as to how that works with mutable vectors... But it seems like to construct this type Stream will be
17:02:51 <dmj> very helpful (or bundle)
17:03:12 <dmj> dfeuer: http://bitballoon.com has a drag and drop API for static sites, and it's free
17:03:21 <dfeuer> Thanks, dmj.
17:03:22 <dmwit> `getCanvas :: HasCanvas p => p -> Canvas p` seems very unlikely to be what you actually want.
17:03:38 <squall_> no thats wrog!
17:03:51 <dmj> dfeuer: np
17:03:52 <squall_> HasPicture
17:04:02 <squall_> ohh what line was that?
17:04:12 <dmwit> 149
17:04:14 <squall_> thanks
17:04:29 <ski> squall_ : using `ToCanvas :: forall a. HasCanvas a => a -> ToCanvas', we can handle the `a' case. using `Switch a b' we can convert from `b' to `a' (really you're converting from `Either a b' to `Either a b', by using `cast' and "mirroring" the `Either' data constructors in `switch') .. and then you call recursively. so by `switch', we'll get an `a' which now has `HasCanvas a' so we can use `ToCanvas'
17:04:54 <squall_> outch criticall error!
17:05:59 <squall_> but we dont actually want to cast to a Canvas using toCanvas
17:06:04 <squall_> as cant cast back
17:06:05 <ski> squall_ : however, `instance HasCanvas a => (Cast ToCanvas (Either a b)) where' looks less reasonable, since it would require `cast :: forall a. HasCanvas a => ToCanvas -> Either a b', which promises to work for *any* `b' (and `a', with `HasCanvas a'), that the caller happens to choose
17:06:10 <squall_> no switch instance is defined
17:06:16 <squall_> nor could it be or should it be
17:06:52 <squall_> the viewer has a function which opperates on the HasCanvas a => a and also only casts *to* canvas for viewing
17:07:31 <squall_> it hust be kept as ToCanvas so that functions defined over eg HasColour a => [[a]] can be used
17:07:52 <ski> squall_ : e.g. a caller could choose `a' as `Canvas Pixel', and choose `b' as `[Int -> IO Bool]'
17:08:58 <squall_> viewer needs a HasCanvas Constraint. if i can instantiate Cast a ToCanvas then im ok, but i cant cast back, so i need to opperate on the gnereal polymorphic forall a. Canvas a
17:09:22 <squall_> i dont want to have to call getCanvas
17:09:36 <squall_> as i couldnt get back for opperating on with the function of the viewer
17:09:40 <ski> squall_ : ignoring for the moment that you probably didn't intend this, the only way that `cast :: forall a. HasCanvas a => ToCanvas -> Either a b' in `instance HasCanvas a => (Cast ToCanvas (Either a b)) where ...' could reasonably work is by always return a value of shape `Left x', with `x :: a'. so the `b' alternative for `Either a b' seems useless here
17:10:44 <squall_> its just so i can be in a frame where i switch between two versions of representations of a grid, see line 212
17:11:14 <squall_> if i can cast from Either a or b then basically i have a HasCanvas Instance
17:11:15 <ski> squall_ : re that dmwit was talkinig about, i think `instance HasPicture p => HasPicture (Canvas p)' looks pretty strange. why would you like to be able to nest `Canvas'ses ?
17:11:24 <squall_> its an error
17:11:29 <squall_> it should be HasPicture
17:11:32 <ski> mhm
17:12:01 <squall_> Im glad your able to read all this and understand what im getting at so far, thanks
17:12:34 * ski starts to think that the existential antipattern blag might look more appropriate for squall_
17:12:59 <squall_> earlier seemed to suggest moving a single bracket could do the trick...
17:13:44 <squall_> is that what you mean by "the existential antipattern blag"
17:13:54 * hackagebot language-dockerfile 0.3.4.0 - Dockerfile linter, parser, pretty-printer and embedded DSL  https://hackage.haskell.org/package/language-dockerfile-0.3.4.0 (yamadapc)
17:13:58 <ski> well, we didn't see the actual code (or a representative sample reduced from it) then
17:14:06 <dmwit> Honestly, there are so many antipatterns here. I might classify the `Cast` typeclass itself as an antipattern.
17:14:07 <ski> @where existential-antipattern
17:14:07 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
17:14:22 * ski would agree with dmwit
17:15:03 <dmwit> I suspect there's a deep misunderstanding of what makes typeclasses useful. But I'm not sure how to remedy it.
17:15:47 <mniip> dmwit, not having to provide class dictionaries by hand?
17:15:59 <ski> squall_ : i'm not sure i see any reason for `Switch' to have any methods at all
17:16:36 <squall_> basically rather than having classes such as HasSomething where a -> Something i can just cast to a HasSomething instance, and make a dangerous Undecidable cast instance which is ok if your careful
17:17:18 <squall_> ski, its just a nice way of showing methods derived from cast instances in both directions
17:17:18 <ski> the point of `Switch' seems to be to abbreviate `(Cast a b,Cast b a)' as `Switch a b' (and perhaps add a law about them being inverses)
17:17:35 <squall_> basically yeah
17:17:38 <squall_> not good
17:17:39 <squall_> ?
17:17:56 <squall_> it works fine and its kind of indormative
17:17:59 <ski> apart from the law, one could use `type Switch a b = (Cast a b,Cast b a)' with some extension(s), i think
17:18:06 <squall_> informative*
17:18:19 <squall_> ooh nice
17:18:20 <ski> squall_ : in any case, all the methods of `Switch' could be moved outside of it
17:18:23 <mniip> ski, ConstraintKinds
17:18:41 <dfeuer> dmj, hmm..... I'm trying to upload to bitballoon, but it's quite extremely slow. Too much traffic, perhaps? Haddocks shouldn't really put a strain on anything....
17:18:44 <squall_> its not a big deal but thats a nice syntax
17:18:56 <squall_> thans
17:19:39 <dmj> dfeuer: hmm, I'll try mine
17:19:42 <ski> squall_ : fwiw, `[[]]' isn't the only list of lists with no elements-of-element-lists
17:19:43 <squall_> so anyway this approach is great until you get to the point of having to cast back from an existential type and that doesnt seem well defined
17:19:58 <ski> squall_ : other such values include `[]' and `[[],[]]'
17:20:29 <squall_> im not sure how to make use of that but i see what you mean
17:20:38 <dfeuer> dmj, it seems to have worked now.
17:20:45 <ski>   cast [[]] = error "empty Grid is an error"
17:20:52 <ski> i was talking about that ^
17:20:57 <dmj> dfeuer: ah, wonderful
17:21:17 <squall_> oh dear! thats bad
17:21:37 <squall_> ok at least i know why that pattern might fail now
17:22:20 <squall_> still most worried about line 101
17:22:27 <squall_> http://lpaste.net/178371
17:23:09 <ski> squall_ : oh, sorry. i forgot the main problem with `instance HasCanvas a => (Cast ToCanvas (Either a b))'
17:24:03 <squall_> which is basically just: instance HasCanvas a => Cast ToCanvas a
17:24:06 <ski> squall_ : as i mentioned, this requires you to implement `cast :: forall a. HasCanvas a => ToCanvas -> Either a bcast :: forall a. HasCanvas a => ToCanvas -> Either a b'
17:24:11 <ski> squall_ : which is completely wrong
17:24:27 <ski> er, sorry for double paste
17:24:31 <Welkin> squall_: ff8?
17:24:34 <ski>   cast :: forall a. HasCanvas a => ToCanvas -> Either a b
17:24:46 <ski> that is equivalent to
17:24:49 <squall_> rhinoa
17:25:12 <squall_> yes Welkin
17:25:13 <ski>   cast :: ToCanvas -> (forall a. HasCanvas a => Either a b)
17:25:26 <ski> but what actually might be possible would be
17:25:33 <ski>   cast :: ToCanvas -> (exists a. HasCanvas a *> Either a b)
17:25:41 <ski> (ignoring `b' for the moment)
17:25:54 <ski> squall_ : so, it's completely the wrong way around
17:26:14 <squall_> !!? it seems so hopeful! is it not?
17:26:15 <ski> 180° in the wrong direction, so to speak
17:26:36 <squall_> can my viewer work?
17:26:40 <Welkin> !!? is a function
17:26:43 <ski> this is probably due to not quite grokking what existentials are and do
17:26:53 <squall_> :t (!!?)
17:26:54 <lambdabot>     Not in scope: ‘!!?’
17:26:54 <lambdabot>     Perhaps you meant ‘!!’ (imported from Data.List)
17:27:34 <Welkin> it's somewhere as "safe index"
17:27:36 <squall_> yes, this was my first interaction with existentials and they do the job good except that which i didnt forsee
17:27:39 <Welkin> like the safe index for vector !?
17:29:02 <ski> @let infix 3 !!?; (!!?) :: [a] -> Int -> Maybe a; [] !!? _ = Nothing; (x:_) !!? 0 = Just x; (_:xs) !!? i | i > 0 = xs !!? (i-1)
17:29:04 <lambdabot>  Defined.
17:29:24 <squall_> i feel like i wish to write; instance (Cast a ToCanvas) => HasCanvas a
17:30:05 <ski> squall_ : i think the key here is understanding what `cast :: forall a b. HasCanvas a => ToCanvas -> Either a b' promises, and realizing that this is unreasonable
17:31:09 <squall_> meaning Switch a ToCanvas is impossible
17:31:23 <squall_> forgettign about Either _ b
17:32:23 <squall_> can suggest a workaround? do you get the aim?
17:35:10 <squall_> my viewer requires a HasCanvas instance, i cannot write instance (Switch a ToCanvas) => HasCanvas a
17:35:25 <ski> it promises that, regardless of which `ToCanvas' value you feed it (e.g. one constructed as `ToCanvas x' with `x :: Canvas Pixel'), you (the caller) could be possible to convert this into an `Either a b', for any `a' and `b' you pick (provided only that you ensure `HasCanvas a'), iow be able to convert from any one instance of `HasCanvas' to any other such instance (or to an arbitrary `b', that we've already mentioned that's absurd)
17:36:12 <ski> presumably you intended for `instance HasCanvas a => (Cast ToCanvas (Either a b))' to expose the hidden `a' inside `ToCanvas' as the `a' in `Either a b' here
17:36:14 <ski> correct ?
17:36:46 <squall_> basically
17:37:10 <ski> but that's not what the signature for `cast' implied by this instance declaration entails
17:37:11 <Cale> Pong dfeuer 
17:37:32 <dfeuer> Cale, please take a look: http://treeowl-containers-general-merge.bitballoon.com/data-map-lazy-merge
17:37:37 <ski> it promises to be able to convert to *any* `a', provided it's an instance of `HasCanvas'
17:37:51 <ski> i doubt that you intended this, or that it's really possible
17:37:53 <Cale> very haddocks wow
17:38:07 <squall_> its not possible and i dont wish to demand it
17:38:45 <ski> something like `Case ToCanvas (exists a. HasCanvas a *> a)', otoh, would be reasonable
17:38:48 <squall_> i want to say, if you can instantiate Switch to any HasCanvas instance, then you can use the viewer
17:38:49 <ski> that would entail
17:38:59 <ski>   cast :: ToCanvas -> (exists a. HasCanvas a *> a)
17:39:06 <ski> while the other direction
17:39:21 <ski>   instance Cast (exists a. HasCanvas a *> a) ToCanvas
17:39:25 <ski> would entail
17:39:35 <ski>   cast :: (exists a. HasCanvas a *> a) -> ToCanvas
17:39:39 <ski> which is the same thing as
17:39:52 <ski>   cast :: forall a. HasCanvas a => a -> ToCanvas
17:40:00 <joe9> I am trying to figure out how to use hlint.ghci: I added it to the .ghci file using :script <location of hlint.ghci>. I think the file is getting loaded. But, cannot figure out how to use it though. Any suggestions, please? https://raw.githubusercontent.com/ndmitchell/hlint/master/data/hlint.ghci
17:40:26 <ski> or, `exists a b. (HasCanvas a,Switch a b) *> Either a b' would probably also work
17:40:43 <squall_> when you say work what do you mean?
17:40:51 <ski> work conceptually
17:40:55 <squall_> im having parsing this new syntax
17:40:59 <squall_> trouble*
17:41:02 <ski> not go horribly wrong at run-time
17:41:11 <ski> not crash
17:41:19 <squall_> thats a bonus, i just want it to compile
17:41:21 <Cale> dfeuer: symmetricDifference = generalMerge preserveMissing preserveMissing dropMatched ... but where is dropMatched? :)
17:41:49 <ski> but then there's the added difficulty of encoding `exists' (and `*>') in current Haskell-with-extensions
17:41:56 <ski>   cast :: ToCanvas -> (exists a. HasCanvas a *> a)
17:42:00 <ski> would be encoded as
17:42:06 <ski>   cast :: ToCanvas -> ToCanvas
17:42:07 <ski> or
17:42:09 <ski>   cast :: ToCanvas -> ToCanvas2
17:42:22 <ski> where `ToCanvas2' is basically a clone of `ToCanvas'
17:42:31 <squall_> i guess im a bit deterred by this encoding issue, im not sure my problem is soluble from what you are saying
17:42:53 <ski> and an instance for `Cast ToCanvas ToCanvas' or `Cast ToCanvas ToCanvas2' wouldn't be much helpful
17:43:24 <ski> from my position, i don't even know why you're trying to do this thing
17:43:25 <squall_> they cant even all be transfered via HasColour a => [[a]]
17:43:26 <dfeuer> Cale, hmm... Do you want dropMatched, preserveFirstMatched, preserveSecondMatched? I don't do anything fancy with any of the Matched tactics yet, so it seems a tad silly.
17:43:41 <squall_> it was 1 milisecond from working perfectly
17:43:48 <ski> i'm only trying to explain why it's either unreasonable, or trivial
17:44:04 <squall_> lets stick with trivial, that sounds better
17:44:05 <Cale> I guess  dropMatched = zipWithMaybeAMatched (\_ _ _ -> pure Nothing)
17:44:25 <ski> squall_ : trivial would be `instance Cast ToCanvas ToCanvas' or `instance Cast ToCanvas ToCanvas2'
17:44:50 <squall_> i dont see how that will make it compile
17:44:52 <Cale> Oh, there's zipWithMaybeMatched
17:44:57 <Cale> a little simpler for that
17:45:18 <ski> squall_ : the implementation of `cast' would then be `cast x = x' or `cast (ToCanvas x) = ToCanvas x'
17:45:26 <ski> (trivial, as i said)
17:45:34 <squall_> but how does that help?
17:45:42 <ski> it doesn't help
17:45:44 <ski> it's trivial
17:45:48 <dfeuer> Cale, yes, that's the best for now. Later, I could make WhenMatched a record, and add flags describing the behavior. That would allow for some special-case optimizations. But I want to get the basics down first!
17:45:52 <squall_> i dont know what your talkng about!
17:46:00 <squall_> why about this trivial instance
17:46:18 <squall_> ?
17:46:34 <ski> <ski> presumably you intended for `instance HasCanvas a => (Cast ToCanvas (Either a b))' to expose the hidden `a' inside `ToCanvas' as the `a' in `Either a b' here
17:46:39 <ski> <ski> correct ?
17:46:41 <ski> <squall_> basically
17:47:04 <ski> squall_ : i was just spelling out what this intension would be, conceptually speaking
17:47:16 <squall_> or just HasCanvas a => Cast ToCanvas a
17:47:20 <Cale> dfeuer: Yeah, I dunno, if there's dropMissing, might as well have dropMatched, but it's fine to just implement it as a derived thing. The preserveFirstMatched and preserveSecondMatched also seem nice for completeness' sake.
17:47:25 <ski> (and i siplified away the `b', the `Either', and the `Switch a b')
17:47:40 <squall_> which does not seem unreasonable given every HasCanvas instance is a member of ToCanvas
17:48:00 <Cale> dfeuer: Of course, the point of this thing is mostly operations which do something more interesting with collisions than that
17:48:05 <dfeuer> Yes.
17:48:10 <dfeuer> That's true.
17:48:26 <dfeuer> Although preserveSecondMatched has some value.
17:48:32 <Cale> But yeah, just to make other merges which already exist east to implement
17:48:34 <ski> squall_ : `instance HasCanvas a => Cast ToCanvas a' corresponds to `cast :: forall a. HasCanvas a => ToCanvas -> a', which one can imagine "conversing" as `cast :: forall a. HasCanvas a => a -> ToCanvas', right ?
17:48:34 <Cale> easy*
17:48:38 <dfeuer> But I don't know if preserveSecondMatched has much optimization potential.
17:49:09 <squall_> yes
17:50:36 <squall_> ok i get your trivial instance.
17:50:40 <ski> squall_ : hm, actually, sorry. i think i did that backwards
17:50:46 <ski> squall_ : i think you were considering `instance HasCanvas a => Cast a ToCanvas' (or something similar) before, corresponding to `cast :: forall a. HasCanvas a => a -> ToCanvas', which one can imagine "conversing" as `cast :: forall a. HasCanvas a => ToCanvas -> a', right ?
17:50:57 <squall_> much better
17:51:00 <ski> ok
17:51:52 <squall_> its like Switch ToCanvas ToCanvas, but now im confused
17:53:02 <ski> squall_ : however, an alternate way to spell `cast :: forall a. HasCanvas a => a -> ToCanvas' (conceptually), is `cast :: (exists a. HasCanvas a *> a) -> ToCanvas', and if you "converse" this, you get the (very) different `cast :: ToCanvas -> (exists a. HasCanvas a *> a)', and i believe the meaning of this is what you intended, based of your "basically" comment above
17:53:04 <squall_> i wish to write instance (Switch a ToCanvas)  => HasCanvas a
17:53:30 <squall_> so that i can write a switch instance rather than a HasCanvas instance
17:53:35 <joe9> any hlint from ghci users? How do you use it? I get errors when I do :hlint
17:54:50 <ski> you can't write `instance Switch a ToCanvas => HasCanvas a', and simultaneously have other instances for `HasCanvas' (without `OverlappingInstances', but i would suggest not using that)
17:55:05 <glguy> joe9: I don't use hlint, but you'll get better help pasting the error
17:55:09 <squall_> it uses that
17:55:27 <Cale> dfeuer: You can easily implement weird things like  generalMerge preserveMissing dropMissing preserveSecondMatched
17:55:27 <squall_> it requires you are careful it works good
17:55:30 <dfeuer> I dearly wish OverlappingInstances did not exist.
17:55:36 <squall_> im sorry
17:55:39 <jle`> ReaderT = Flip Kleisli
17:55:39 <Cale> dfeuer: (But this is good)
17:56:09 <Clint> 8d/win 23
17:56:52 <Welkin> @dice 8d23
17:56:52 <lambdabot> Welkin: 81
17:57:08 <squall_> i have a HasCanvas instance, i dont intend to write another, im just going to switch to that thing, which at the moment is HasColour a => [[a]]
17:57:28 <ski> squall_ : anyway, `foo :: Bool -> (exists a. [a])' means that if we feed a `Bool' to `foo', then there exists some type `a' (possibly depending on that `Bool') argument, such that the result is a list of `a's
17:57:49 <dfeuer> Cale, yeah, I'm more focused on making this piece right than on filling out all the pieces. But yes, I hope to eventually expand a bit, especially once I figure out how to represent the optimization flags.
17:57:50 <Cale> (i.e. you'd get a Map with the same set of keys as the first Map, but with values taken from the second if they exist)
17:58:15 <squall_> ski, i see why its hard to do that in practice
17:58:34 <ski> squall_ : while `bar :: Bool -> (forall a. [a])', which is the same thing as `bar :: forall a. Bool -> [a]', means that if we feed a `Bool' to `bar', then it will return a list of `a's for any type `a' *we* (the caller) chooses
17:58:50 <ski> squall_ : so the difference is in who gets to pick the type for `a'
17:58:52 <dfeuer> alwaysDrops, neverDrops, alwaysPreservesFirst, .....
17:59:21 <ski> with `forall', it's the user/caller/consumer. with `exists', it's the producer/implementor
17:59:24 <squall_> the type should be decided by the Switch instance
18:00:09 <ski> squall_ : shouldn't it be decided by the actual type used inside the `ToCanvas' value ?
18:00:10 <squall_> if i write instance Switch a [[Int]] then i expect that to be a member of ToCanvas
18:00:31 <squall_> since it has a HasCanvas instance
18:00:58 <squall_> derived from the Switch a ToCanvas and instance HasCanvas [[Int]]
18:01:13 <ski> `Switch a [[Int]]' isn't a type, it's a constraint, so it can't be the internal type inside a `ToCanvas' value
18:01:23 <squall_> instance Switch a ToCanvas
18:01:53 <ski> (`exists a. Switch a ToCanvas *> a' would be a type)
18:01:58 <squall_> ok but i could do the same existential trick and make a ToSwitch thing but im scared of doing that now
18:02:14 <ski> (and also `exists a. Switch a [[Int]] *> a' would be a type)
18:02:45 <squall_> instance Switch a [[Int]] => HasCanvas a
18:02:54 <ski> (fwiw, i prefer a naming convention of `WrapCanvas' or `SomeCanvas', rather than `ToCanvas')
18:03:00 <squall_> thanks
18:03:12 <ski> (or `ExistsCanvas')
18:03:13 <squall_> thats good it was a total random poor choice
18:03:33 <squall_> Exists is good, from this discussion
18:03:39 <squall_> not that im 100% there
18:03:51 <squall_> it still wont compile
18:04:10 <ski> the point is that `ExistsCanvas' is defined to be isomorphic to `exists a. HasCanvas a *> a'
18:04:39 <jle`> SomeCanvas is a common idiom i see
18:04:44 <jle`> SomeX
18:04:48 <jle`> but might as well use a generic wrapper
18:05:06 <squall_> from what i can tell i does not seem unreasonable to be able to have a HasCanvas instance for any (HasColour b,Switch a [[b]])
18:05:13 <ski> the former, defined with `data ExistsCanvas where WrapCanvas :: HasCanvas a => a -> ExistsCanvas' would be the most common way to *encode* the type `exists a. HasCanvas a *> a'
18:05:20 <dfeuer> Cale, totally unrelated:  https://batterseapower.github.io/test-framework/  has a section entitled "I have some tests that just call error but the tests pass". I can't for the life of me understand what that section is saying. Any idea?
18:05:30 <jle`> actually nvm, SomeX is actually a different idiom, often used for GADTs
18:06:37 <ski> squall_ : "have a HasCanvas instance for any (HasColour b,Switch a [[b]])" is meaningless. possibly you meant something like "have a HasCanvas instance for any `a' such that there exists a `b' where `(HasColour b,Switch a [[b]])' holds"
18:07:07 <squall_> instance (HasColour b,Switch a [[b]])  => HasCanvas a
18:07:41 <ski> yes, you have `HasCanvas a', not `HasCanvas (HasColour b,Switch a [[b]])', which is what "have a HasCanvas instance for any (HasColour b,Switch a [[b]])" would mean
18:07:47 <squall_> knowing that instance HasColour a => HasCanvas [[a]] is provided
18:09:09 <squall_> it seems i need instance Switch a ToCanvas => HasCanvas a
18:09:35 <squall_> which cant work for the reasons stated
18:09:54 <squall_> that ToCanvas is existential
18:10:21 <ski> (btw, i'm sorry if i may seen a bit overly pedantic on language. but i'd prefer you (a) to be able to communicate more efficiently about this; (b) realize important distinctions and learn common terminology in order to do (a) better)
18:10:26 <jle`> is data Op a b = Op (b -> a) in any common package?
18:10:30 <squall_> preventing cast :: HasCanvas a => ToCanvas -> a
18:11:03 <squall_> its ok i dont know why i just kind of left that sentance unfinished, i think i cleared it up now
18:12:02 <ski> anyway, i'm starting to get sleepy here ..
18:12:23 <squall_> yeah, is what im trying to do possible?
18:13:31 <ski> i think that in order to give better advice for your pasted code (apart from better explaining polymorphism, existentials, how they contrast to each other, possibly also higher-rank types .. in general that is), one would need to get a better idea for what you're trying to do
18:13:54 <squall_> instance (HasCanvas b,Switch a b) => HasCanvas a
18:14:05 <Squarism> common problem.. i have some [(k,v)] "maplike" structure. Say v is a List or an Int that want to add to. is there some nice short for this? 
18:14:09 <ski> (i don't have a very good idea about what you're trying to do, i'm just observing things in your code, and hear warning bells go off in head)
18:14:37 <squall_> thats whay im trying to do^
18:15:00 <squall_> which seems totally reasonable to me
18:15:42 <ski> the problem here is that i can't be sure if i can take `instance (HasCanvas b,Switch a b) => HasCanvas a' at face value as a description of what you're trying to do. perhaps it's a mistaken expression of what you *really* would like to do
18:15:44 <squall_> then i define a single HasCanvas instance, and then just define Switch instances to that instance instead of new HasCanvas instances
18:16:19 <ski> or perhaps you're confused about what you want to do (or want to do something that you wouldn't want to do, with more reflection on the ramifications)
18:16:22 <squall_> that is the overall design goal
18:16:46 <Koterpillar> :t Data.Map.insertWith (++) -- Squarism
18:16:47 <squall_> write single instance, rather than new instances, write Switch instances
18:16:48 <lambdabot> Ord k => k -> [a] -> Data.Map.Map k [a] -> Data.Map.Map k [a]
18:17:28 <ski> expecting `instance HasCanvas a => (Cast ToCanvas (Either a b))' to work already suggested to me *some* kind of confusion or non-grasping of how existentials work, what they could possibly do and not do
18:18:06 <squall_> i can operate on some type, so if you can Cast to and from that type to some other type, then the operation will now work on that
18:19:20 <ski> squall_ : also, there's the problem of overlapping instances. and in your case, if i take `instance (HasCanvas b,Switch a b) => HasCanvas a' at face value, i suspect this can lead to incoherence
18:20:08 <squall_> i should be able to do instance (HasCanvas x,HasCanvas a,Cast x a) => (Cast x (Either a b))
18:20:09 <ski> (what if you can convert from `A' to `B' with `Switch', and then from `B' to `C'. but also directly from `A' to `C' -- but these two different ways don't have to be equal)
18:20:50 <squall_> there should only be one HasCanvas instance other than that
18:21:37 <squall_> instance HasColour a => HasCanvas [[a]]
18:21:48 <ski> (i tend to sometimes err on the side of warning people not to do X, then explain in more detail how to go about doing X ..)
18:22:06 <squall_> darn
18:22:09 <squall_> i see why
18:22:20 <squall_> usually if there is a warning there is a reason not to do it
18:22:25 <squall_> and i guess im hitting that
18:22:35 <ski> (.. preferably with reasons why not to do X, and possible exceptions why you might want to do it anyway)
18:22:45 <squall_> its a shame i only hit the channel when i have a reason for someone to tell me st to scrub my code because it sucks
18:23:43 <hpc> squall_: if you just hang out here more, you might even get to be the one telling people to scrub their code because it sucks :D
18:24:00 <squall_> ok thanks for all the helpful tips. im less happy i dicovered these damn forall things, i was excited for a second
18:24:27 <squall_> if you can switch to it i can opperate on it
18:24:37 <squall_> *sigh*
18:24:39 * ski doesn't follow the "i see why"
18:24:52 <squall_> usually if there is a warning there is a reason not to do it
18:25:01 <ski> (but then i should go to sleep. good night)
18:25:06 <squall_> oh i read than
18:25:11 <squall_> night
18:25:47 <Squarism> Koterpillar, thanx. Somehow i got the impression haskell people just used [(k,v)] for maps. 
18:27:01 <Squarism> Hmm.. well i see alot of [(k,v)]. Should i use that or Map k v  in my signatures/records?
18:27:39 <Koterpillar> Squarism: where do you see that?
18:28:01 <Squarism> tutorials, places google sends me
18:28:06 <Koterpillar> example
18:28:22 <Koterpillar> are you sure you're not confused with the Show instance of Map?
18:28:33 <Welkin> lol
18:28:38 <Welkin> that is an association list
18:28:45 <Welkin> which is a basic representation of a map
18:28:47 <Squarism> ok.. i might be crazy also. somehow i found Data.List#lookup 
18:28:53 <Welkin> but not a proper map
18:28:53 <Squarism> and stuck with that
18:29:01 <Koterpillar> > Data.Map.insert 2 True $ Data.Map.singleton 1 False
18:29:01 <Welkin> yes
18:29:03 <lambdabot>  fromList [(1,False),(2,True)]
18:29:15 <Welkin> it can be useful for small maps
18:29:16 <Koterpillar> Squarism: above is a Map, even though there are [ ] and ( )
18:29:23 <Welkin> or for teaching
18:30:04 <Squarism> okok.. well.. my map usage has been small so far
18:30:23 <Welkin> Squarism: you will love Data.Map
18:30:25 <Welkin> and Data.Set
18:30:30 <Welkin> and maybe Data.Sequence
18:30:41 <Welkin> Seq is one of my favoite data structures in haskell
18:30:46 <Welkin> it uses finger trees :D
18:30:53 <Welkin> favorite
18:31:01 <Squarism> it has been a bit "primitive" to just use Data.List in my now 5000 line project
18:31:09 <Squarism> i admit that
18:31:28 <Welkin> Maps are probably the most used data structure besides vectors
18:31:39 <Welkin> lists are typically control structures
18:32:00 <Koterpillar> ^ maps can be too,\
18:32:07 <Koterpillar> ^ maps can be too - vtable anyone?
18:32:44 <Welkin> and I learned that you can implemented anything using a Map/HashMap
18:32:49 <Welkin> implement*
18:33:08 <Welkin> mostly from using lua
18:33:31 <Squarism> im not new to maps - they are in all languages. But because i found more mentions of the list variant i thought.. haskell is to smart for me - they only need one datastructure and proper haskell knowhow
18:33:56 * hackagebot dns 2.0.5 - DNS library in Haskell  https://hackage.haskell.org/package/dns-2.0.5 (KazuYamamoto)
18:34:27 <Squarism> so it seems Data.Map.Strict is what i whould use no?
18:35:15 <Koterpillar> Squarism: see here: http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Map.html
18:35:16 <Welkin> only if you want to use all of the data in the Map
18:35:20 <Welkin> otherwise use a lazy Map
18:36:06 <Squarism> ok
18:37:41 <plakband> Can anyone tell me why the following evaluates to 0:
18:37:46 <plakband> (fromList [(0,0)])^.at 0.non undefined
18:37:51 <plakband> Yet this bottoms out:
18:38:02 <plakband> execState (at 0.non undefined +=1) (fromList [(0,0)])
18:38:45 <Squarism> so is there some easy trick to deal with the conflicts between List, Map, Set?
18:38:57 <Koterpillar> Squarism: import them all qualified
18:41:23 <Welkin> I usually import them as L, Map, an Set
18:41:42 <Welkin> V for Vector
18:42:11 <Gurkenglas> plakband, it checks whether the new, incremented value is now undefined, to see whether it should be removed from the data structure
18:42:21 <Gurkenglas> Of course, == is strict and so that bottoms out.
18:42:43 <Gurkenglas> (State monad has nothing to do with it)
18:42:51 <Squarism> Welkin, Koterpillar: thanks for guidance
18:43:49 <Gurkenglas> plakband, you might be looking for "singular (ix 0)" or "at 0 . singular _Just"
18:45:11 <Gurkenglas> Or if you don't want to assert justice, "at 0" will also work for the setter, while during getting you'll need to combine that with one of the singular-things or, I'd recommend, ^?!.
18:45:22 <Gurkenglas> "^?!"
18:47:08 <plakband> Gurkenglas: Thanks, that's exactly what I was looking for!
18:47:19 <Gurkenglas> plakband, the typey thing that coulda told you that is the Eq constraint on non
18:47:52 <plakband> I'm not really comfortable reading Lens type signatures yet :/
18:48:11 <Gurkenglas> Hah, I'm only just now getting there
19:00:08 <Boobie> https://www.youtube.com/watch?v=AlFi0QUboxs
19:00:08 <Boobie> ^-- Hillary Clinton Brags About Voting For A Barrier To Keep Out Illegal Immigrants
19:00:17 <Boobie> https://www.youtube.com/watch?v=WXLmmYRjDKw
19:00:18 <Boobie> ^-- Hillary Clinton's Racist Statements About Mexicans and Mexico
19:00:31 --- mode: ChanServ set +o glguy
19:00:32 --- mode: glguy set +b *!*@2602:306:cf06:80b0:b055:b84e:94aa:2057
19:00:32 --- kick: Boobie was kicked by glguy (Boobie)
19:02:25 --- mode: glguy set -o glguy
19:05:22 <dfeuer> Ping mokus__ 
19:10:25 <Squarism> how do i pattern match Data.Map? I.e with associative list i can write [("a",x)] = myList
19:10:41 <Squarism> ...how would that look for the same "Data.Map"
19:10:54 <kadoban> Squarism: You don't. You use the provided functions, like lookup or null or whatever.
19:11:13 <Squarism> kadoban, even if its a test? 
19:11:50 <kadoban> Squarism: I don't understand the question? Data.Map doesn't provide you with enough insight into its inner workings to pattern match anything though, so all you have is what it gives you.
19:13:45 <Squarism> ok.. clarification. I had a testsuite that verified associative lists looked certain ways. wanted to migrate those to Map versions
19:14:33 <kadoban> Squarism: Sure, I mean use the provided things. If you want to test that certain items are in there, you can do that. If you want to build your own Map to test against and use (==), you can do that, if you want to test that it's a certain size, etc.
19:15:16 <Squarism> i found toList.. might help
19:16:45 <jchia> I have a question about Data.Serialize.Get. I have some data that is layed out a certain way -- I want to extract various parts of a Data from a block of bytes of fixed size. i know at what offset from the front i want to extract each part, and each part is a simpler type like an Int. The only interface in see is getting things serially, so I have to read-skip-read-skip-...., and I would have to calculate the number of skipped bytes manually. Is there a more 
19:41:44 <tmciver> I'm following along with the paper "Monad Transformers Step by Step" (https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf). In it they state that "Map.lookup is defined to work within any monad by simply calling the monad’s fail
19:42:13 <tmciver> function". But this no longer seems to be the case. Anyone know what Map.lookup used to be?
19:43:16 <ertes> :t M.lookup
19:43:17 <lambdabot> Ord k => k -> Data.Map.Map k a -> Maybe a
19:43:54 <ertes> tmciver: not sure if it was ever actually the case, but you could choose an arbitrary monad instead of Maybe, but it's a terrible idea
19:44:00 <geekosaur> it was back in 6.6
19:44:18 <tmciver> Yeah, the paper is from about 2006 I think.
19:44:38 <ertes> 6.6?  containers is at 0.5 right now…
19:44:52 <ertes> or is this about list lookup?
19:44:53 <geekosaur> http://downloads.haskell.org/~ghc/6.6.1/docs/html/libraries/base/Data-Map.html#v%3Alookup
19:45:11 <ertes> oh, it used to be in base?
19:45:13 <dolio> GHC 6.6.
19:45:51 <dolio> Anyhow, it's not strictly "terrible" as long as `fail` isn't part of `Monad`.
19:46:14 <dolio> It's actually nicer than a Maybe result in a way.
19:47:00 <dolio> Because a string with an indication of what caused the problem can be given to `fail`, but `Maybe` doesn't have such a thing.
19:47:24 <buglebudabey> are there any resources you guys regularly read up on to stay fresh/learn new things related to haskell?
19:48:02 <geekosaur> #haskell, mostly :)
19:48:18 <geekosaur> and the haskell-cafe mailing list
19:50:06 <ertes> buglebudabey: there are no regular resources to begin with except perhaps community-generated content like reddit
19:50:26 <ertes> or are there?  is HWN still alive?
19:50:42 <buglebudabey> whats HWN expand to?
19:50:50 <ertes> haskell weekly newsletter
19:50:53 <buglebudabey> ah
19:51:22 <geekosaur> hasn't been seen in a long time, sadly
19:51:45 <ertes> there is/was also the low-frequency haskell communities/activities report
19:52:11 <ertes> but in most of the cases the editors couldn't keep up, because it's just a lot of work
19:52:20 <geekosaur> sep 30 2015 was the last HWN
19:53:27 <peddie> there is also http://haskellnews.org/ which kind of aggregates a few sources
19:53:43 <ertes> https://ro-che.info/ccc/6
19:56:25 <systemfault> Does anyone know if the Haskellcast podcast is dead? 
19:56:41 <ertes> ReinH: ^
19:58:30 <systemfault> Got my answer there: https://www.reddit.com/r/haskell/comments/4h58nb/what_happened_to_haskell_cast/
20:01:26 <joe9> can this (>>) be replaced with (*>). >> is for m a -> m b , whereas *> is for f a -> f b. is (*> ) the more accepted version?
20:03:03 <glguy> There's no difference between the variable f and m on their own
20:03:42 <glguy> *> is more general than >> now
20:03:45 <joe9> glguy: so, (*>) is the recommended version?
20:03:50 <joe9> glguy: Thanks.
20:06:03 <Jackoe> systemfault: So good to hear it's still going! I loved that podcast
20:06:47 <systemfault> Well, if ReinH doesn't have the time, it's neither alive or dead
20:07:05 <systemfault> schrodinger's cast
20:14:45 <Jackoe> Good point. I wonder how popular it was.
20:18:41 <dfeuer> Why did mokus use ImpredicativeTypes in dependent-sum?
20:18:59 <dfeuer> It was totally unnecessary.
20:19:26 <dfeuer> Just a drop of newtype clears it all up.
20:22:03 <jchia> how can i get a Double from a ByteString? I don't see anything I can use in Data.Serialize.Get, although there are things to read words
20:23:11 <dfeuer> jchia, what package are you using?
20:23:16 <jchia> cereal
20:23:47 <dfeuer> jchia, just use get.
20:25:34 <dfeuer> jchia, you can use, say,   runGet ((,,) <$> get <*> get <*> get) str to produce an Either String (Double,Double,Double)
20:26:10 <jchia> OK, I see that Double is an instance of Data.Serialize
20:26:27 <dfeuer> There's also an attoparsec-style incremental interface.
20:30:52 <Gurkenglas> "Documentation for library packages should be generated by a maintainer. The means of doing this is still up in the air." that means I have to wait for those volunteer machines to do it?
20:38:21 <jchia> thanks
20:39:11 <jchia> dfeuer: What's the attoparsec-style you're talking about?
20:41:11 <glguy> Gurkenglas: to do what specifically?
20:41:16 <glguy> (I don't know where you're reading that)
20:41:24 <dfeuer> jchia, https://hackage.haskell.org/package/cereal-0.5.3.0/docs/Data-Serialize-Get.html#g:2 is very similar to the interface that attoparsec provides.
20:41:39 <Gurkenglas> https://www.google.de/search?q=%22Documentation%20for%20library%20packages%20should%20be%20generated%20by%20a%20maintainer.%20The%20means%20of%20doing%20this%20is%20still%20up%20in%20the%20air.%22&rct=j :D
20:42:32 <glguy> Gurkenglas: OK, what's your question?
20:42:59 <Gurkenglas> Is there a way for me to upload a haddock for my library?
20:43:03 <glguy> Yes!
20:43:28 <glguy> Here's my script, should work for you
20:43:28 <glguy> https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
20:44:00 * hackagebot acme-omitted 3.0.0.0 - A name for omitted definitions  https://hackage.haskell.org/package/acme-omitted-3.0.0.0 (JoachimFasting)
20:45:44 <enthropy> documentation on hackage used to be generated automatically (barring some issues like the hackage server missing a c library you need to compile your code)
20:47:09 <jle`> i remember those days
20:47:26 <HallaSurvivor> Hey! I have a question about eta reduction, but it's easier if there's code, so: http://pastebin.com/Rz8YdzdX
20:49:27 <Gurkenglas> HallaSurvivor, you make the String the first argument and the Stack the last
20:50:25 <HallaSurvivor> Gurkenglas, getting rid of Stack is easy. Is there a way to pattern match on the String while not having it on both sides of the equality? Sorry if I wasn't clear
20:51:07 <geekosaur> no, because (a) no other way to distinguish from the default pattern (b) and you determine the operator parameter to fnGen from the String
20:51:53 <geekosaur> and you can't both pattern match *and* eta reduce the parameter being matched away
20:53:11 <HallaSurvivor> geekosaur, alas, that's what I thought. It would be so much prettier, though :P
20:53:46 <HallaSurvivor> Sorry again for being unclear, and thanks! I'll live with slightly redundent looking code
21:47:03 <jle`> HallaSurvivor: you can write "flip operations" instead :)
21:47:41 <jle`> or write a helper function that's just foo "+" = (+)
21:48:01 <jle`> or foo "+" = Right (+)
21:49:02 * hackagebot glirc 2.9 - Console IRC client  https://hackage.haskell.org/package/glirc-2.9 (EricMertens)
21:49:42 <HallaSurvivor> jle`, The reason I'm doing this is to make defining new functions easy. i.e. if I want to add support for sin, I only need: operations s "sin" = fnGen sin s "sin"
21:50:22 <HallaSurvivor> I need "sin" on the left so that I know what the token looks like, and I need "sin" on the right to use in error messages, i.e. "sin requires at least one argument on the stack"
21:51:43 <jle`> HallaSurvivor: it might be worth pulling out a simpler function, anyways
21:51:54 <jle`> foo "+" = Right (+); foo "-" = Right (-)
21:51:56 <jle`> separates out concerns
21:52:17 <jle`> separates the concern of parsing from the concern of w/e fnGen does
21:53:30 <HallaSurvivor> There may well be a better way to do what I want. The code is ~150 lines, if you're willing to read it over
21:53:51 <jle`> might not have time, but that's just a general suggestion :)
21:54:04 <HallaSurvivor> haha, it was worth a go :) 
21:54:22 <HallaSurvivor> thanks!
21:54:56 <eshan> Hello everybody, quick question
21:55:07 <eshan> I've heard a lot that LYAH isn't a good resource
21:55:36 <eshan> What do you think right now is the best resource for beginners learning haskell
21:55:44 <eshan> ?
21:56:59 <Cale> eshan: I don't know what's best, but a lot of people seem to like the materials from the CIS 194 course that Brent Yorgey gave...
21:57:14 <Cale> http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
21:57:24 <eshan> Cale: I see, will check it out
21:57:57 <glguy> And I think that the Spring '13 version of the course is the one that people liked the best
21:58:16 <glguy> (as linked by Cale) but you'll find that it was since updated. something to keep in mind if you try to find it again
21:58:16 <Cale> Yeah, that's byorgey's :)
21:58:17 <jle`> everything was better during Spring '13
21:58:21 <eshan> glgy: good to know
22:00:27 <eshan> Cale: thanks for that
22:24:39 <clintm> Ah, yes, the spring of '13.  I was newly divorced.  Such a magical time.
22:27:21 <ongy> now I feel young again...
22:30:36 <jchia> c2hs question. How do I get sizeof(Foo::bar) (10) given the following struct?
22:30:36 <jchia> struct Foo {
22:30:36 <jchia>     char bar[10];
22:30:36 <jchia> };
22:34:38 <cocreature> jchia: I think it’s {#sizeof Foo.bar#}
22:35:33 <jchia> cocreature: c2hs complains "The phrase '.' is not allowed here."
22:36:30 <jchia> for #offsetof, it compiles
22:36:35 <jchia> but not for #sizeof
22:36:42 <cocreature> jchia: hm that’s weird do you want to know the actual size of bar or the space it takes up in the struct (i.e. with padding and alignment)
22:36:52 <jchia> i want to get back 10
22:37:41 <jchia> concretely, i have some c structs stored in a file that i'm trying to deserialize and getting the struct definition from the C header
22:38:51 <cocreature> jchia: hm sorry not sure what to do about this. might be a good idea to open an issue
22:38:58 <jchia> i suspect c2hs's #sizeof is not as flexible as the C counterpart
22:39:03 <jchia> OK
22:41:29 <anohigisavay> hi. i have `class X a b` that declares a function. i want to provide a default function for `class X SomeConcreteType b`
22:43:06 <intothemountains> Is there a way to pattern match sets and extract one element of them?
22:44:00 <alercah> anohigisavay: GHC 8 has an extension that does this, I forget the  name though
22:45:06 <cocreature> I think you are referring to -XDefaultSignatures but that extension is not new in 8.0
22:45:07 <anohigisavay> alercah: _(:з」∠)_thanks.. i'm in a strong need of GHC 8 starting from today
22:45:37 <cocreature> intothemountains: no you can’t pattern match on sets, but there are function such as deleteFindMin and deleteFindMax that allow you to remove one element
22:45:54 <intothemountains> ok, cheers!
22:48:45 <anohigisavay> cocreature: ohmy that's the extension i was looking for!
22:48:50 <anohigisavay> cocreature: thanks
22:51:15 <cocreature> anohigisavay: hm maybe I was wrong. I can’t figure out how to make it work
23:08:17 <anohigisavay> just add `default func :: A ConcreteType b -> Int` inside class A declaration is okay no?
23:08:23 <anohigisavay> cocreature: 
23:09:55 <anohigisavay> i have another question: is it possible to add forall quantification to a class signature?
23:10:20 <anohigisavay> class forall a. A a b -> B b where...
23:11:10 <cocreature> anohigisavay: that results in ambiguity warnings
23:12:28 <anohigisavay> no that doesn't compile
23:13:17 <cocreature> sorry I was still referring to the default signature
23:13:45 <anohigisavay> xD i'm still dealing with compile errors before i can check if that extension works for me
23:13:49 <cocreature> anohigisavay: what are A and B supposed to be here?
23:14:22 <cocreature> oh do you mean class forall a. A a b => B b where …
23:14:31 <cocreature> -> and => are not the same thing in haskell
23:14:40 <anohigisavay> oh yes i meant =>
23:14:50 <anohigisavay> sorry
23:14:53 <cocreature> I don’t think you can do that
23:15:21 <cocreature> but if you have an instance that holds for all as why is A parametrized by a in the first place?
23:15:33 <anohigisavay> A is a previously defined class. i want to say "as long as there exists an instance A SomeType b" then b is an instance of B
23:16:04 <cocreature> and how is ghc supposed to choose the instance if there is A SomeType b and A SomeType' b?
23:16:13 <anohigisavay> actually A is like : class A a b | b -> a
23:16:32 <anohigisavay> so given b i can uniquely determine a
23:16:32 <cocreature> ah now we’re talking
23:19:04 * hackagebot servant-auth-cookie 0.3.1 - Authentication via encrypted cookies  https://hackage.haskell.org/package/servant-auth-cookie-0.3.1 (zohl)
23:19:39 <anohigisavay> in a class with functions i can just add the constraints to function signatures
23:19:54 <anohigisavay> but B actually has no funcs
23:22:56 <cocreature> anohigisavay: you could try something like this http://lpaste.net/178401
23:24:59 <anohigisavay> cocreature: thank should've worked. actually i started my A just like your suggestion. But sadly i need injective type families which is not available in 7.10.3
23:25:53 <cocreature> anohigisavay: if you need injectivity then your functional dependency will not give you that either
23:27:18 <anohigisavay> cocreature: um... let me paste some code
23:28:31 <anohigisavay> http://lpaste.net/178406
23:28:38 <anohigisavay> that's a bit too much
23:28:53 <anohigisavay> s/too much/too much of code
23:29:03 <anohigisavay> Resource works like my A
23:31:21 <anohigisavay> wait let me see...
23:33:00 <anohigisavay> yes no problem
23:37:58 <sigrlami> is "summer of haskell" ended already? I don't see activity for a month for some projects
23:45:33 <srhb> sigrlami: The info page says: september 2nd
23:45:54 <srhb> sigrlami: With results announced on the 12th :)
23:46:35 <sigrlami> yeah, but projects are developed in open source and usually you can see how work is going
23:47:14 <sigrlami> but for example ghcvm last commit 17 july
23:47:21 <srhb> sigrlami: I don't think there's a requirement that the participators make visible their progress. :)
23:47:39 <sigrlami> I'm not talking about requirement
23:47:49 <srhb> sigrlami: THe last commit in ghcvm is 3 days ago. :)
23:48:40 <sigrlami> ah, yep, I found wip branch
23:48:42 <sigrlami> sorry
23:49:01 <srhb> sigrlami: No need to be sorry. :-P
23:49:07 <srhb> That's an exciting project, too.
23:49:12 <srhb> Looking forward to hearing all the results, really.
23:49:50 <sigrlami> no, I mean my fault)) yeah, I'm very interested in 2 
23:55:15 <HallaSurvivor> Is there a builtin function for: f p x = if p then Just x else Nothing
23:55:56 <HallaSurvivor> nvm, I just remembered hoogle exists
23:56:29 <liste> @hoogle Bool -> a -> Maybe a
23:56:32 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
23:56:32 <lambdabot> Control.Exception assert :: Bool -> a -> a
23:56:32 <lambdabot> Control.OldException assert :: Bool -> a -> a
