00:01:21 <liste> rabbi1: I think it's a very productive framework but it's a bit too opinionated and relies on Template Haskell too much
00:03:27 <liste> rabbi1: but as long as you're willing to do things "the Yesod way" it's not a problem (:
00:03:41 <pavonia> In Parsec, shouldn't "fromMaybe x <$> optional p" and "option x p" be equivalent?
00:04:10 <rabbi1> liste: :) 
00:04:15 <liste> rabbi1: and "opinionated" is relative - RoR is much more opinionated than Yesod
00:05:21 <liste> rabbi1: but note that you need to understand some very advanced Haskell concepts (type families, template haskell etc) to really make sense of Yesod
00:05:35 <liste> you can use it before that but it'll have magic
00:07:00 <rabbi1> liste: cool. It is really hard to decide 
00:07:05 * hackagebot persistent-template 2.5.1.5 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.5.1.5 (GregWeber)
00:07:05 * hackagebot persistent-template 2.5.1.6 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.5.1.6 (GregWeber)
00:07:42 <pavonia> Nevermind, it was a precedence problem
00:08:05 <kaz> what are some good first projects to write in haskell?
00:08:37 <pavonia> Something with parsers
00:09:06 <pavonia> Writing a Scheme interpreter is a quite famous starting project, I think
00:09:32 <kaz> hmm
00:09:45 <kaz> I guess I know a bit of Scheme
00:09:47 <kaz> thanks!
00:11:57 <dramforever> rabbi1: I hope you already know that Haskell is too different from most languages to have concepts transferred from them
00:12:19 <dramforever> Well, I mean *most* of the concepts
00:12:56 <kaz> rabbi1: some of the clisp I learned has been helpful. I hear people recommend learning a LISP if you struggle with Haskell at the beginning.
00:15:12 <rabbi1> dramforever: yeap, I started knowing about functional programming from RxJS and I am here.
00:15:38 <rabbi1> so, i know things like map, filter and combining those 
00:15:53 <rabbi1> very basic though
00:16:35 <dramforever> There's a lot more than that :)
00:16:58 <rabbi1> kaz: I am thinking for starting with an web app using framework, so looking for framework which is not quite different from haskell type of coding.. 
00:17:51 <rabbi1> Once i get the hang of it, i can try to get deep in to haskell 
00:18:29 <kadoban> rabbi1: I would suggest that trying to learn a framework in haskell without actually knowing haskell isn't going to work very well.
00:18:40 <kaz> ^
00:19:55 <kadoban> rabbi1: You'll probably get frustrated really quickly when little things don't make any sense, or when you get off script of the materials you're following *at all*.
00:20:11 <rabbi1> oops :(
00:20:56 <dramforever> rabbi1: How many programming languages have you learned?
00:21:16 <dramforever> Haskell is >= 3rd, I suppose?
00:22:43 <rabbi1> Java and Ruby
00:23:02 <rabbi1> a lil on python
00:23:05 <slack1256> do other languages that static compile by default have big size binaries too? I would guess is a pretty common "problem"
00:23:24 <liste> rabbi1: JavaScript too? you mentioned RxJS
00:23:35 <rabbi1> o yeap
00:23:42 <slack1256> --enable-executable-dynamic reduced my binary size from 15MB to 1.3MB :-)
00:23:52 <rabbi1> As i already said, i am more a frontend guy..
00:23:58 <Axman6> stripping usually helps quite a lot too
00:24:16 <dramforever> rabbi1: Then try to learn Haskell as you learned your first programming languages helps greatly
00:24:16 <rabbi1> I only do frontend for my clients. 
00:24:36 <liste> rabbi1: for frontend, you could also check out http://www.purescript.org/, it's pretty similar to Haskell
00:24:37 <cocreature> slack1256: I have a c++ codebase that results in a 50mb executable when statically linked iirc
00:24:43 <cocreature> slack1256: so yes they do :)
00:24:59 <slack1256> cool, so we are in the same league!
00:25:02 <dramforever> Expect a heck of frustration
00:26:32 <dramforever> Expect "none of these makes sense". Expect "why this stupid computer doesn't understand me"
00:26:52 <kadoban> rabbi1: I'd personally suggest to start would be: http://haskellbook.com/ (great, but not free), or if it must be free, https://github.com/bitemyapp/learnhaskell has some decent pointers to free material. Maybe just bookmark those for when you get frustrated with trying to learn a framework first.
00:26:52 <cocreature> slack1256: then again I think executable sizes don’t really matter these days unless you’re doing embedded or maybe mobile, but for both cases you probably wouldn’t use haskell
00:28:39 <jchia> How do I convert a Data.ByteString.ByteString to a String and vice versa? I can't find anything that seems relevant on hoogle with "::ByteString -> String". I see stuff from Data.ByteString.Char8 but I don't really know how Data.ByteString.Char8 relates to Data.ByteString.
00:28:50 <rabbi1> kadoban: thanks a lot
00:28:56 <slack1256> you are right. I wanted to have a "sense" of how much of that size is by the static compilation instead of the amount of inlining ghc does with code
00:29:24 <cocreature> I definitely got shocked the first time I looked at the size of a haskell hello world :)
00:29:28 <slack1256> jchia: Data.ByteString.Char8 has an unpack function IIRC
00:29:38 <kaz> anyone recommend a good way to set up a haskell IDE in emacs?
00:29:44 <Axman6> jchia: Data.Bytestring.Char8 gives functions on Data.Bytestring.Bytestrings which let you treat them as containing ASCII data
00:29:46 <cocreature> Char8 is evil
00:29:50 <slack1256> yet is not recomended. Data.ByteString data can be really... Binary
00:29:57 <kaz> i've tried intero-mode and it says "stack" is missing
00:30:12 <cocreature> utf8-string supports decoding and encoding utf8 in bytestrings
00:30:16 <jchia> I always use ASCII
00:30:39 <cocreature> jchia: wait until someone comes along and breaks your system by entering unicode
00:30:42 <jchia> in fact, i disallow non-ASCII in my application
00:31:20 <cocreature> well then char8 is ok
00:31:41 <slack1256> if that is so you could then use the `text` package directly
00:32:09 <slack1256> done by the same guy that made bytestring but with the assumption of representable strings (unicode)
00:32:36 <slack1256> so you don't have to deal with á ñ as different characters
00:32:54 <liste> jchia: is there a reason for that? is there a reason you don't use Text?
00:33:14 <jchia> i thought i could save memory by using latin1
00:33:23 <jchia> but i suspect i'm wrong
00:34:11 <jchia> Well if I use ByteString to represent Latin1 strings, i should be saving memory, right?
00:34:11 <dramforever> kaz: get that "stack" thing: https://haskellstack.org
00:34:26 <kadoban> Unless you're doing ridiculous amounts of data, the savings isn't likely to be noticeable. The brokenness when people try to use anything other than ASCII is likely worse.
00:34:42 <kaz> dramforever: thanks dude
00:35:24 <dramforever> And of course setup stack, you can see it in that page too
00:35:26 <jchia> what about performance? I have tight loops that involving operating on those strings?
00:35:43 <jchia> if the strings have fewer bytes, they'll be faster to copy/compare/etc.
00:36:09 <slack1256> are you sure the copy compare etc are the heavy parts of your loops?
00:36:18 <dramforever> basically if you "start your new project" and open a hs file intero will get itself setup automagically
00:36:25 <slack1256> usually the heavy parts are other things done on the strings
00:36:46 <slack1256> what I am trying to say is "know where you weight is"
00:37:01 <kadoban> jchia: You have to be talking about a *lot* of data for that to really matter, most of the time. I would suggest that correctly handling a wide variety of text is a good default, and if profiling suggests that the text handling is truly the bottleneck and if it's causing a real problem, then you can consider the tradeoff of limiting to ASCII.
00:37:12 <dramforever> jchia: Yes they will, if you're really working with a hell lot of data, go for bytestring text.
00:37:58 <jchia> well, not only that, i should be disallowing non-latin1 in the input in the first place
00:37:59 <slack1256> just for refence, to you guys how much is *hell of data*
00:38:06 <dramforever> Otherwise it would be an unnecessary trip-up for users. You know, it's 2016 already
00:38:14 <jchia> the use case disallows non-latin1
00:39:04 <dramforever> jchia: to the point that a text-based solution is *not tolerable* but a bytestring-based solution is
00:39:24 <kaz> dramforever: I got it working on MinGW. Thanks for the help!
00:41:10 <jchia> i'm coming from the perspective of not allowing invalid states to be stored. general unicode codepoints constitute invalid state
00:41:42 <jchia> because, as i said, my use case precludes anything not in latin1
00:47:01 <ongy> jchia: sounds like a weird usecase. And this will make it harder to reuse if you ever need something similar
00:47:39 <jchia> i agree. it's a very specific non-consumer application
00:47:54 <liste> that would make sense if the point was to interface with an ASCII-only legacy system
00:47:56 <jchia> For representing errors, is it preferable to use Except String or Except Text?
00:48:17 <jchia> the specific input i'm processing is ASCII
00:48:43 <slack1256> neither. Use a custom ADT for expressing the range of possible errors
00:49:20 <slack1256> MyError = DumbUsser | NotSoDumbButStillPissingMeOffUser
00:49:22 <jchia> you mean like data Error = Error1 ... | Error2 ... | ...?
00:50:09 <jchia> what if the errors can come from all over the place, different libraries? I just want to show a human-readable message so that a human user can intervene
00:50:23 <ongy> slack1256: bet with a deriving (Show) and output to user?
00:50:44 <slack1256> but be careful. If you base type is already IO it can throw exceptions and those aren't catch on ExceptT
00:51:03 <slack1256> ongy: with a custom made Show instance better. There you stick the message
00:51:07 <dramforever> jchia: You put error data types all over the place, different libraries (if you can)
00:51:18 <slack1256> Although I like to use ExceptT for exceptions I can do something about, not just reporting
00:52:02 <liste> slack1256: instance Show MyError where show DumbUser = "there seems to be a ID-10-T error, please report it to administrators"
00:52:08 <dramforever> What are those libraries? If you don't want to be more specific a {data MyError = FooLibError Fooooo | BarLibError Baaaar} could work
00:52:34 <dramforever> Or you *might* want to use exceptions for things not really easily recovered from
00:53:20 <slack1256> jchia: if you instead of recovering from the errors you can to log them, you don't need ExceptT, probably Monad-logger that is like Writer
00:53:20 <dramforever> Like disk full or something, if crashing is okay (it seems to be)
00:53:38 <slack1256> if is just for reporting to the user
00:54:59 <rabbi1> kadoban: so install stack and not platform ? 
00:55:32 <kadoban> rabbi1: Yeah.
00:56:04 <rabbi1> thumbs up
01:00:33 <jchia> yeah, my exceptions are always about crash diagnostics
01:09:36 <|{ame> hello everybody
01:09:43 <zyla> hi
01:09:44 <ongy> good morning
01:10:17 <|{ame> I just started haskell, so I am sorry for the probably dumb question. 
01:10:31 <|{ame> Is there something like the c comma operator
01:11:00 <|{ame> I want to execute a function, ignore its return value, and return the value of the following function instead
01:11:08 <maerwald> :t (>>)
01:11:10 <lambdabot> Monad m => m a -> m b -> m b
01:11:19 <merijn> |{ame: What's the point of evaluating a function and ignoring it's result?
01:11:28 <merijn> |{ame: Might as well not evaluate it then
01:11:37 <|{ame> it has side effects
01:11:41 <merijn> maerwald: I don't think that's accurate. Comme operator in C is an expression
01:11:44 <dramforever> you mean IO?
01:11:48 <merijn> |{ame: Haskell functions can't have side effects
01:11:51 <|{ame> I am configuring xmonad
01:12:00 <|{ame> and I have this code
01:12:05 <|{ame> isVisible w ws = any ((w ==) . W.tag . W.workspace) (W.visible ws)
01:12:05 <|{ame> lazyView w ws = if isVisible w ws then ws else W.view w ws
01:12:06 <maerwald> merijn: er wat?
01:12:13 <dramforever> someAction >> anotherAction
01:12:32 <slack1256> and those are functions (to IO) but functions
01:12:40 <dramforever> maerwald: I think merijn means the side effect is in 'IO' not '->'
01:13:31 <|{ame> If I change it to lazyView w ws = if isVisible w ws then spawn "xmessage hello " >> ws else W.view w ws
01:13:56 <|{ame> I get  No instance for (MonadIO
01:13:56 <|{ame>                        (W.StackSet WorkspaceId (Layout Window) Window ScreenId))
01:13:56 <|{ame>       arising from a use of `lazyView'
01:15:14 <dramforever> |{ame: Unfortunately Haskell functions don't work that way
01:16:00 <|{ame> I have read about do
01:16:05 <Maxdamantus> or fortunately, depending on how you look at it.
01:16:22 <|{ame> but I don't know how to put
01:16:41 <|{ame> somthing like "return ws"
01:16:46 <|{ame> inside the do statement
01:17:02 <dramforever> Do you plan to learn Haskell?
01:17:15 <Maxdamantus> Putting it inside the definition of `lazyView` isn't going to help, unless you change its type.
01:17:37 <merijn> dramforever: No
01:17:45 <merijn> dramforever: I mean that IO has effects, not side effects
01:17:46 <slack1256> heh
01:17:57 <dramforever> ooh
01:17:59 <slack1256> oh
01:17:59 <merijn> maerwald: You can't have side-effects unless you abuse unsafePerformIO, that's the entire point
01:18:06 <dramforever> Interesting point!
01:18:20 <maerwald> merijn: I didnt say anything about side effects, not really sure what you mean
01:18:24 <dramforever> I guess I've never considered what the "side" part
01:18:29 <dramforever> what it means
01:18:31 * slack1256 thought for a moment dramforever asked merijm if he planned to learn haskell
01:18:34 <slack1256> the nerve
01:18:44 <merijn> maerwald: Oh, I just realised you replied to a different remark from me :)
01:19:00 <dramforever> The Grand Topic Messup
01:19:26 <merijn> That's what happens if you check IRC every few minutes and you just see yourself highlighted and the first line up from you is something else than the response :)
01:19:44 <slack1256> well unsafaPerformIO doesn't guarrante ordering ;-) so yeah The Grand Topic Messup
01:19:56 <merijn> maerwald: Anyway, I was saying that >> is more akin to ; than the comma operator, which doesn't really make sense in Haskell :)
01:20:24 <dramforever> I'm trying to answer from a usage point of view
01:20:28 <ongy> comma operator? I'm so confused
01:20:59 <merijn> ongy: C has a comma operator that almost everyone forgets about
01:21:19 <maerwald> merijn: I was answering to "I want to execute a function, ignore its return value, and return the value of the following function instead". >> comes pretty close imo
01:21:31 <implementation> |{ame: You should have a look at the types of the individual expressions, esp. `isVisible w ws`, `spawn "xmessage hello "`, `ws` and `W.view w ws`.
01:22:06 <implementation> then you'll find the problem.
01:22:40 <merijn> ongy: "x, y" returns 'y', except that it guarantees that 'x' is evaluated before evaluating 'y' and returning it
01:22:41 <|{ame> implementation: `ws` and `W.view w ws` have the same tyope
01:22:55 <ongy> fwhy would one ever? things I didn't know, ok
01:23:08 <slack1256> ongy: while(read_string(s), s.len() > 5)
01:23:18 <liste> it's useful in for loops too
01:23:27 <merijn> Additionally, ',' introduces a sequencing point
01:23:37 <slack1256> on C read_string probably would allocate some memory that you would use inside the while
01:23:50 <implementation> |{ame: and the other ones?
01:23:56 <merijn> ongy: But yeah, it's usually not particularly useful :)
01:24:23 <ongy> slack1256: that's C++, and iirc ',' operator in C++ is subject to overloading, which makes it even more fun
01:24:34 <slack1256> oh
01:24:55 <slack1256> those pagans, they overloaded the shift memory operator to do IO!
01:25:40 <ongy> slack1256: ever noticed that map<list<char>> doesn't compile on old compilers?
01:26:05 <slack1256> I never used C++, sorry
01:26:08 <dramforever> while(readSomething(&x), readingSucceeded())
01:31:28 <|{ame> implementation: I tried to simplify the problem
01:32:01 <|{ame> I wrote this printAndReturn x= do
01:32:01 <|{ame>                      spawn "xmessage hello"
01:32:01 <|{ame>                      return x  
01:32:16 <|{ame> but x and printAndReturn x have different types
01:32:30 <|{ame> Occurs check: cannot construct the infinite type:
01:32:30 <|{ame>       sd0 = W.StackSet i0 l0 a0 s0 sd0
01:32:33 <|{ame>     Expected type: W.StackSet i0 l0 a0 s0 (W.StackSet i0 l0 a0 s0 sd0)
01:32:36 <|{ame>       Actual type: W.StackSet i0 l0 a0 s0 sd0
01:33:14 <gilligan_> looks like perl-WWW-Curl is broken on OSX *sigh*
01:37:46 <ongy> |{ame: return is something different than the return statement from imperative languages
01:38:52 <ongy> so 'x' has a different type than 'return x'.
01:40:18 <gilligan_> oops. i wrote to the wrong channel.. 
01:47:05 * hackagebot encoding-io 0.0.1 - Encoding-aware file I/O.  https://hackage.haskell.org/package/encoding-io-0.0.1 (terrorjack)
01:51:04 <chaosmasttter> |{ame: try just printAndReturn x = do
01:51:20 <chaosmasttter>                      spwan "xmessage hello"
01:51:27 <chaosmasttter>                     x
01:52:12 <chaosmasttter> oops. the x should have been indented one space more
01:52:43 <|{ame> chaosmasttter: I did,but that does not work
01:52:52 <|{ame> I tried also with the >> syntax
01:53:04 <|{ame> but the MonadIO is added to the type
01:53:25 <|{ame> I the tried to prefix the whole function with
01:53:58 <|{ame> i0 l0 a0 s0 sd0
01:54:01 <|{ame> sorry
01:54:06 <|{ame> printAndReturn  :: IO  W.StackSet i0 l0 a0 s0 sd0
01:54:23 <|{ame> but I then get
01:54:25 <|{ame>  `IO' is applied to too many type arguments
01:54:25 <|{ame>     In the type signature for `printAndReturn':
01:54:25 <|{ame>       printAndReturn :: IO W.StackSet i0 l0 a0 s0 sd0
01:54:37 <|{ame> however, if I delete the i0..sd0
01:54:50 <dramforever> It could disappoint you, but you need to sit down and learn Haskell
01:54:56 <|{ame> I get
01:54:58 <|{ame> Expecting five more arguments to `W.StackSet'
01:54:58 <|{ame>     In the type signature for `printAndReturn':
01:55:03 <ongy> |{ame: ready made: http://lpaste.net/174351
01:55:26 <ongy> the problem is, that you are trying to do unpure things in a pure function (spawn requires IO, but the type required does not allow IO)
01:55:47 <dramforever> Ready...made?
01:55:48 <|{ame> dramforever: you are completely right, it feels so dumb just to proceed by trial and error
01:55:56 <dramforever> It's unlikely to work
01:56:35 <dramforever> Haskell is not one of the "Copying and Pasting from Stackoverflow" languages
01:57:37 <|{ame> ongy: thanks, the code you shown is what I have with this lazyView pasted here
01:58:10 <ongy> oh, then I missed something.
01:58:16 <ongy> what are you currently trying to do?
01:58:16 <|{ame> I just wanted to add a notification when returing ws
01:59:00 <ongy> ah, that's not possible like this. you'd have to construct the binding a bit differently
01:59:25 <|{ame> the idea is "if it is already visible on another screen, do nothing, (return ws) but tell me that I am dumb and I should turn my head", otherwise (if it is hidden) bring it to the current screen
02:00:09 <dramforever> I don't know about XMonad but I think you should put it elsewhere
02:01:00 * dramforever finds the code you gave
02:02:33 <ongy> |{ame: you are doing your binding with that fancy list comprehension, where you have: '((m .|. mod4Mask, k), windows $ f i)', the 'windows' function takes care of stateful things here and accepts a pure function. So if you want to do unpure things (like spawn) you will have to bind them without the 'windows' function
02:02:43 <dramforever> hmm domain names aren't resolving here, wait a bit
02:03:13 <lpaste> av pasted “AD cont'd” at http://lpaste.net/174354
02:04:15 <dramforever> |{ame: It looks like W.view takes a StackSet and gives a new one back, without actually changing anything on screen
02:05:06 <|{ame> dramforever: yes,exactly
02:05:10 <dramforever> I think you would need to find the place where the actual changing happens, and chances are you can send a notification there
02:05:43 <av_> hi again, could anyone give me a hand with this piece of code: http://lpaste.net/174354
02:05:50 <|{ame> the place is this http://pastebin.com/076brmy2
02:06:44 <av_> what do I need to do to make g2 work?
02:07:35 <ongy> |{ame: this modifies a stackset passed to the function and returns a new one. The function doing interaction with xmonad is 'windows'
02:08:58 <dramforever> |{ame: No I mean where does the view change
02:09:21 <dramforever> Ok I admit that this is not going to work either because I don't know xmonad
02:49:02 <lpaste> Shou pasted “ld returned 1 exit status” at http://lpaste.net/174362
02:49:54 <Shou> Anyone know what this is about? I get this linker error every time I try to use a test-suite, or install a new compiler with Stack. Any GHC installed through Nix works fine, however.
02:57:16 <lynx> hello
03:06:35 <mniip> Shou, hmm, I'm familiar wit this error in C land but I'm not sure what it means in haskell
03:08:59 <mniip> you have some code in an object file that's requesting absolute position of some symbol
03:09:08 <mniip> which is not possible when you're linking a shared object
03:13:58 <jgt3> how do I entity-encode some HTML?
03:14:08 <jgt3> i.e., I have "<form action=\"hello\"></form>", and I want "&lt;form actio=\"hello\"&gt;&lt;/form&gt;"
03:14:34 <jgt3> I'm using Yesod, so I have blaze available to me
03:17:10 * hackagebot equational-reasoning 0.4.1.0 - Proof assistant for Haskell using DataKinds & PolyKinds  https://hackage.haskell.org/package/equational-reasoning-0.4.1.0 (HiromiIshii)
03:24:27 <unit73e> hello
03:24:34 <cocreature> jgt3: how about > renderHtml (toHtml "<form action=\"hello\"></form>"))
03:25:10 <unit73e> what's the current best high level database library for haskell?
03:25:30 <cocreature> jgt3: you need to import the correct render module from blaze depending on what you want to encode to, but they the render methosd are all called renderHtml afaik 
03:27:05 <jgt3> cocreature: that's super helpful. Thanks so much! :D
03:27:11 * hackagebot type-natural 0.6.1.0 - Type-level natural and proofs of their properties.  https://hackage.haskell.org/package/type-natural-0.6.1.0 (HiromiIshii)
03:27:16 <cocreature> jgt3: yw
03:29:02 <dysfun> i'm writing a lisp interpreter at the moment and i'm using a State monad transformer to deal with the state. I'm not quite satisfied with this as an approach because I have lexical state and global variables (defun etc.). Can anyone suggest a better way of modelling this?
03:32:11 * hackagebot dawg-ord 0.5.0.2 - Directed acyclic word graphs  https://hackage.haskell.org/package/dawg-ord-0.5.0.2 (JakubWaszczuk)
03:32:13 * hackagebot equational-reasoning 0.4.1.1 - Proof assistant for Haskell using DataKinds & PolyKinds  https://hackage.haskell.org/package/equational-reasoning-0.4.1.1 (HiromiIshii)
03:45:20 <unit73e> guess I'll ask again later
03:45:44 <unit73e> I only know about haskelldb. hopefully it doesn't have hibernate flaws.
03:54:39 <liste> unit73e: persistent+esqueleto is pretty established
03:55:45 <liste> unit73e: opaleye is interesting too
03:56:46 <unit73e> thanks liste the wiki seems outdated :s
03:58:15 <unit73e> lol esqueleto, did a spaniard implement it or something?
03:58:28 <unit73e> or portuguese
04:00:17 <unit73e> felipe lessa, probably brazilian. esqueleto looks nice.
04:07:13 * hackagebot simple-zipper 0.1.0.0 - Zippers made slightly easier  https://hackage.haskell.org/package/simple-zipper-0.1.0.0 (DanielWaterworth)
04:07:41 <jchia> instance Foo a where
04:07:41 <jchia>     justAName :: String
04:07:42 <jchia> How do I define and use different instances of justAName for different types without compiler complaining about ambiguity?
04:07:58 <jchia> Sorry, typo
04:08:25 <jchia> class Foo a where
04:08:25 <jchia>     justAName :: String
04:08:41 <mniip> jchia, what would the type of 'justAName' be
04:08:46 <lyxia> you can't write this
04:08:50 <black0range> Are there any way to make haskell binaries really small? :) 
04:09:01 <lyxia> the type of a typeclass method has to depend on a
04:09:06 <mniip> lyxia, well really you can
04:09:17 <mniip> with visible type application and allowambiguoustypes
04:09:26 <lyxia> oh?
04:09:31 <jchia> i want to let the types define a string that's different for each type that another function defined in Foo itself, can use
04:09:39 <lyxia> nvm
04:10:18 <jchia> similar to how virtual functions are used in C++
04:10:33 <cocreature> AllowAmbigousTypes sounds so evil that I never dared into looking what it actually does
04:10:38 <mniip> jchia, the said function would be unable to tell the typechecker what type to use 'justAName' for
04:10:51 <mniip> cocreature, defers the ambiguity check to use site
04:11:17 <jchia> OK. I Foo is actually a class type for things that can be aeson-parsed in a certain way. the only difference is the name for an object somewhere in the document
04:11:35 <jchia> how do i express this?
04:11:56 <jchia> sorry, another difference is what to do when they get to that part of the document
04:12:08 <mniip> well
04:12:09 <cocreature> mniip: now you removed all the mistery from it
04:12:16 <mniip> one way is to use a proxy
04:12:23 <mniip> justAName :: Proxy a -> String
04:12:34 <jchia> so two differences i want the different types of the type class to implement: 1) the name of the object to look for down the path to the data 2) How to actually parse when I get to that part
04:12:53 <jchia> the front part of the path is the same for all the types
04:13:52 <jchia> the useful information is somewhere deep in the document and paths taken for the different types have the same prefix
04:17:47 <cocreature> parsing the data is related to the a? (e.g. returns an a or something like that)
04:17:50 <osa1> is there something like mapAccumLM in base? like mapAccumL except the function (first argument) is monadic
04:31:31 <|{ame> still fighting with types...
04:31:39 <|{ame> in Xmonad-Core there's type WorkspaceId = String,
04:33:15 <|{ame> but scWorkspace0 ++ " " does not work, with scWorkspace0 of type X (Maybe WorkspaceId)
04:33:52 <opqdonut> the string is two layers deep
04:33:59 <opqdonut> within an X container and within a Maybe
04:34:11 <opqdonut> try something like:
04:34:21 <opqdonut> fmap (fmap (++" ")) scWorkspace0
04:34:42 <opqdonut> some examples:
04:34:51 <opqdonut> > fmap (++" ") (Just "abc")
04:34:52 <Wizek> black0range, Are you still looking for an answer? I have heard, but haven't yet successfully tried the --split-objs GHC flag. There is also the JHC compiler but afaik that is quite experimental (allegedly it can produce a 6 KB Hello World binary vs GHC's 1.1 MB minimum; source: http://repetae.net/computer/jhc/jhc.shtml )
04:34:53 <lambdabot>  Just "abc "
04:35:04 <opqdonut> > fmap (fmap (++" ")) (Just (Just "abc"))
04:35:06 <lambdabot>  Just (Just "abc ")
04:36:37 <black0range> Wizek: That sounds nice :) Was just wondering if it would be possible to compete in the demo scene with haskell
04:39:25 <|{ame> opqdonut: it works,thank you! I will now have a look at fmap
04:41:14 <merijn> black0range: I don't think Haskell is a serious contender for the demo scene
04:41:27 <merijn> Maybe if you implement a custom minimal runtime and hack GHC to support it...
04:42:02 <jaspervdj> maybe you can write a Haskell EDSL that is a thin layer over ASM or sth like that
04:42:07 <cocreature> isn’t there a demoscene guy doing haskell?
04:42:16 <cocreature> the one who  wrote luminance, I forgot his name
04:42:24 <cocreature> phaazon
04:42:33 <merijn> Using Haskell to generate asm for demo scene stuff seems reasonable, yes
04:42:36 <black0range> You could easily write newschool demos in haskell :)
04:42:45 <black0range> The limit is 64 MB 
04:42:49 <merijn> But at that point you're honestly just writing a custom compiler for a demo scene language :p
04:43:03 <black0range> merijn: let a man dream :'( 
04:43:09 <merijn> Which is perfectly fine (actually, I'd recommend it, you'll learn a lot)
04:43:16 <mniip> 1470397369 [14:42:49] <black0range> The limit is 64 MB 
04:43:29 <mniip> even then your best bet is encoding all neccessary data as unboxed strings
04:43:30 <merijn> black0range: tbh, using haskell to implement a special demoscene compiler sounds like a pretty cool project
04:43:52 <mniip> because all other forms of data storage are very inefficient
04:44:11 <jchia> http://lpaste.net/174379
04:44:32 <jchia> I'm trying to parse something from deep inside a JSON. there are a few types of things i'm trying to parse
04:45:06 <phaazon> hi! :)
04:45:13 <black0range> mniip: Would you like to elaborate on that? :) 
04:45:18 <mniip> jchia, you need either ScopedTypeVariables or a trick to bring that 'a' over
04:45:39 <jchia> the difference is the path from the root to part of the JSON i want, and how to parse that part once i get there. the paths have a common prefix, so I put it in the parseJSON of SfConfig
04:45:56 <phaazon> black0range: I stopped working on luminance for demoscene purposes as I discovered Rust, which suits the need way better ;)
04:46:27 <phaazon> I think you can still write demo in Haskell, but the GC is not needed for such a task
04:46:30 <mniip> black0range, [1,2,3,4,5,6,7,8,9,10] is like, maybe, 1000 bytes in the executable
04:46:36 <phaazon> and such an overhead is just a pain in the ass 
04:47:28 <jchia> is ScopedTypeVariables known to have bad side effects, i.e. cause code that already compiles to not compile or behave differently?
04:47:35 <mniip> "\x01\x02\x03\x04\x05\x05\0x06\x07\x08\x09\x0A"# :: Addr# is honestly 10 bytes
04:47:54 <mniip> jchia, yes, it changes how type variables are scoped
04:48:04 <merijn> jchia: No, because you need to change the type signatures syntax to enable it
04:48:11 <black0range> mniip: sheze... speaking about storage if you do fromString "Whatever" :: ByteString does ghc store it as a String or a ByteString internally? 
04:48:17 <merijn> jchia: SCTV requires explicit forall in a signature to work
04:48:18 <mniip> ah right, you do need foralls don't you
04:48:56 <merijn> jchia: i.e. if you have "foo :: a -> b -> c" and wanna use SCTV in the where clause you need to change it to "foo :: forall a b c. a -> b -> c"
04:48:57 <mniip> black0range, strings are optimized into unboxed strings
04:49:07 <mniip> "foo" -> unpackCString# "foo"#
04:49:20 <mniip> not sure about ByteString
04:49:35 <merijn> mniip: You can easily use GHC's low level guts to embed arbitrary binary data
04:50:04 <merijn> At least, if you don't restrict yourself to ONLY using haskell source files to generate your executable
04:50:25 <rydgel> What's best for the client. Should my API wrapper lib throw exceptions, or return Either?
04:50:27 <mniip> well
04:50:28 <mniip> that yes
04:50:40 <mniip> but with haskell only the best you've got is unboxed strings
04:50:51 <mniip> maybe with TH assisting you in building those
04:50:53 <merijn> mniip: Doesn't require a second language for binary data, though
04:51:19 <mniip> can you do something similar to raw objcopy?
04:51:21 <merijn> mniip: You can have the system linker turn an arbitrary binary blob into an object file and link it using GHC
04:51:23 <black0range> rydgel: what kind of client are are we talking about? 
04:51:56 <rydgel> black0range: another Haskell user that will use my lib to make requests to some API endpoints
04:52:06 <mniip> so like I said
04:52:30 <mniip> how are you going to use it then though?
04:52:54 <mniip> foreign import "foo" foo :: Addr# ?
04:53:13 <merijn> mniip: "Ptr Word8" or whatever
04:53:21 <mniip> hmm
04:53:31 <black0range> rydgel: Miight be subjective but i would prefer eithers 
04:53:38 <merijn> mniip: The linker just generate symbols which are like any other symbol, just pointers
04:54:11 <rydgel> black0range: I prefer that too. At least the type are explicit.
04:54:28 <mniip> merijn, yes I'm familiar with that mechanism
04:54:59 <mniip> I'm contemplating the preference of marshalled types over unboxed ones
04:55:35 <merijn> mniip: "ld -r -b binary foo.bar" generates an object file with 3 symbols, _binary_foo_bar_end _binary_foo_bar_start and _binary_foo_bar_size, which are pointers and size_t respectively
04:55:49 <merijn> You can easily go from Ptr to Addr#, afaik
04:55:53 <mniip> I've been doing that with objcopy
04:56:37 <mniip> wait
04:56:39 <mniip> pointers?
04:56:41 <mniip> not chars?
04:56:49 <jaspervdj> .quit
04:57:06 <merijn> mniip: huh, chars? How does that make sense?
04:57:06 <mniip> I'm fairly sure you have to do &file_start to get to its contents
04:57:46 <merijn> mniip: I'm getting terminology at different levels mixed up :)
04:58:11 <merijn> But, yeah, you have to take the address of them
04:58:31 <merijn> They can't be chars, or anything, really, though. Because object files have no notion of types
04:58:56 <mniip> char* is allowed to alias void*
04:59:04 <mniip> or any other pointer type
04:59:14 <merijn> mniip: I don't see how aliasing is relevant?
04:59:27 <merijn> mniip: You can give them whichever type you want in your C file
04:59:49 <mniip> &file_start :: ???*
04:59:56 <mniip> the only sane always-working choice is char
05:00:20 <merijn> mniip: Presumably you know what the file contained, so you can just hardcode whatever type you plan to use it as
05:00:29 <mniip> sure
05:00:51 <mniip> but what I'm saying is that it makes sense for it to be char by default
05:00:52 <merijn> So not sure I'd say "char*" or "void*" are the only sane always-working choices :)
05:06:32 <jchia> mniip, merijn: Not sure where I should add the forall. Turning on SCT itself doesn't help.
05:06:54 <mniip> ewait
05:07:04 <mniip> SCT should add instance tyvars into scope
05:07:24 <mniip> class tyvars too
05:08:43 <jchia> what is tyvars?
05:09:02 <mniip> type variables
05:09:04 <mniip> ghc slang
05:10:16 <mniip> jchia, could you post your whole code with the error message?
05:10:49 <jchia> it's quite big. let me tease out the problematic part
05:34:54 <Wizek> Is it possible to nest applicative records, something like so? `Rec1 <$> pure Nothing <*> f1 <*> (Rec2 <$> f2 <*> (pure $ Just 1))`
05:37:49 <Wizek> hmm, it appears to be possible: `Just 3 >>= Just <$> (Just <$> id)`
05:38:15 <Wizek> I wonder what might have gone wrong last time I tried to do such a thing
05:40:53 <mniip> what does  records have to do with this
05:41:23 <mniip> looks like a pretty simple applicative computation
05:51:48 <Cale> hm, nobody in #haskell-hacboston yet? :)
05:57:53 <Unhammer> newtype QF = QF Int deriving (Eq, Ord, Show, Num) – can I not use such newtypes as indexes/values of UArray's?
05:58:14 <mniip> deriving Ix
05:58:15 <mniip> I think
05:58:19 <Unhammer> aha
05:59:24 <Unhammer> that works for indexes at least =D
06:00:01 <Unhammer> but doesn't seem to help for values …
06:00:58 <ongy> why exactly do people limit the highest version of a library they accept, before anything that introduces breaking changes is actually released?
06:01:15 <unit73e> I always wondered that as well
06:01:29 <iphy> is there an S2 geometry library for haskell?
06:01:35 <unit73e> why not just make it > 0.1.x.x
06:01:37 <iphy> like this one: https://github.com/google/s2-geometry-library-java
06:02:03 <iphy> or this one: https://code.google.com/archive/p/s2-geometry-library/
06:02:27 <unit73e> At least I think cabal uses something like semantic versioning right?
06:03:56 <unit73e> unless 0.1.2.1 breaks compatibility with 0.1.1.1 (but it shouldn't)
06:05:22 <ongy> unit73e: it's up to the maintainer of the library, and "breaking" is hard to define. If people use unlimited imports, any new symbol may break things
06:05:32 <ongy> and unlimited is most likely not the best word here
06:06:14 <unit73e> ongy: but the MINOR version should only add things, not change things
06:06:40 <unit73e> that's why > 0.N.x.x makes sense to me
06:07:07 <unit73e> and > 0.N.x.x && < 0.M.x.x does not make any sense IMO
06:07:24 <Unhammer> oh I can just deriving(Eq,Ord,Show,Num,IArray UArray) on the value it seems …
06:07:42 <unit73e> errr... that's wrong I meant 0.1.N.x but you get the idea
06:08:02 <ongy> unit73e: exactly, but adding something *can* break (if others aren't careful)
06:08:22 <unit73e> ongy: well just be careful :p
06:08:25 <unit73e> I say
06:08:39 <Unhammer> what's a bit interesting about that is that I can pass a plain Int as the value in and it boxes it for me …
06:08:43 <Unhammer> or not boxes 
06:08:43 <unit73e> better than having a versioning hell
06:08:51 <Unhammer> whatever it's called
06:09:09 <hexagoxel> ongy: because you'd need to fix/add the upper bound on every one of your releases once there is a breaking change in a dep. this is work proportional to the number of releases of your package times number of breaking releases of deps. in contrast, "premature" upper bounds have the cost of having to update upper bounds from time to time.
06:09:14 <mniip> Unhammer, "a plain int"?
06:09:24 <Unhammer> mniip, Int
06:09:24 <mniip> what do you mean by that
06:09:38 <Unhammer> when the newtype QF = QF Int
06:09:39 <phadej> libraries on hackage use http://pvp.haskell.org/
06:09:51 <phadej> unit73e Unhammer ^
06:10:07 <Unhammer> array (QI 0, QI 0) [(QI 0, 0)] :: UArray QI QF
06:10:09 <Unhammer> array (QI 0, QI 0) [(QI 0, QF 0)] 
06:10:28 <phadej> it also defines "breaking"
06:10:41 <unit73e> phadej: I'll bookmark that page, thanks
06:11:09 <unit73e> I have to check what's stack as well
06:11:12 <Unhammer> mniip,  first line is what I wrote, second what the repl spit back
06:11:43 <unit73e> better be easier to understand than cabal-install :p
06:12:11 <mniip> Unhammer, what do you think that 0 is
06:12:16 <phadej> ongy: the word you seek for is "unqualified". It would be great if more people https://wiki.haskell.org/Import_modules_properly
06:12:43 <ongy> phadej: no I wasn't. I was refering to the (use, these, symbols) part, not qualified imports
06:12:52 <ongy> but qualified imports do fix it aswell
06:13:11 <ongy> unless unqualified is more than the 'qualified' keyword does
06:13:56 <phadej> ongy: the something which python peple call "wildcard" import?
06:14:02 <phadej> i.e. just 'import Module' ?
06:14:14 <ongy> pretty much
06:15:02 <unit73e> stupid question... what does "^" mean in "unit73e Unhammer ^" lol
06:15:10 <phadej> I use 'unqualified' for that style as well, i.e. specifying explicit import list is "qualified" yet it doesn't use the keyword
06:15:23 <phadej> unit73e: referring to the line above
06:15:24 <mniip> unit73e, "see above"
06:15:37 <unit73e> oh cool, I don't IRC that much
06:15:38 <unit73e> thanks
06:16:01 <ongy> what's a good way to save a structure (e.g. Map FilePath Metadata) between application runs? 
06:16:33 <Unhammer> mniip,  the confusing bit is that I can have both of these in the same file and it compiles: http://sprunge.us/XMVb?hs
06:16:49 <phadej> ongy: binary/store/... serialisation libraries
06:17:00 <Unhammer> feels a bit … dynamic
06:17:21 <mniip> Unhammer, again
06:17:24 <mniip> what do you think that 0 is
06:18:22 <Unhammer> the qf variable there is of type Int
06:18:36 <Unhammer> M is  Intmap (shoulda mentioned, sorry)
06:18:37 <mniip> in the second declaration - suree
06:18:55 <mniip> and in the second declaration that 0 is inferred to have type Int
06:19:06 <mniip> but in the first 0 is inferred to have type QF
06:19:30 <mniip> and QF is a Num
06:19:54 <Unhammer> M.toList :: M.IntMap a -> [(M.Key, a)]
06:19:56 <Unhammer> aha
06:20:02 <mniip> you're missing a huge chunk of types there
06:20:30 <Unhammer> I was sure IntMap.toList had to return [(Int, a)]
06:20:45 <Unhammer> oh wait it is
06:20:47 <Unhammer> wat
06:20:57 <Unhammer> type Key = Int says https://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:Key
06:21:41 <mniip> ah well
06:21:43 <mniip> indeed
06:21:53 <mniip> you're just ignoring the qf's
06:21:56 <mniip> in your accumArray
06:22:19 <mniip> :t accumArray (\a _ -> a)
06:22:21 <lambdabot> Ix i => e -> (i, i) -> [(i, a)] -> Array i e
06:23:19 <Unhammer> ah I was ignoring the wrong thing, doh
06:23:22 <Unhammer> there's my type failure
06:23:33 <Unhammer> … why are they different types in that function, that does not make sense
06:23:44 <Unhammer> but ok
06:23:57 <Unhammer> not ghci's being weird, but Data.Array
06:24:20 <mniip> nothing is weird in haskell
06:24:30 <mniip> it's just that you don't see the underlying structure yet :p
06:24:38 <Unhammer> hah
06:24:43 <c_wraith> some libraries have weird interfaces.  :P
06:26:02 <mniip> c_wraith, you're not seeing the underlying structure!
06:26:04 <Unhammer> mm, accumArray was a bit more general than I expected. I shall make a wrapper.
06:26:05 <mniip> :)
06:26:40 <c_wraith> mniip: pfft.  I'm talking about libraries I wrote. :P
06:26:46 <c_wraith> I assure you, there was no underlying structure!
06:27:04 <mniip> you just haven't seen it yourself yet
06:31:23 <piyush-kurur>  hi folks: do you know of any CI systems like Travis that give multi architecture builds. I would like to use one for raaz (http://github.com/raaz-crypto/raaz) because we would like the CI to catch errors like endian confusion when the test build are run.
06:32:02 <piyush-kurur> As of now we are planning to just use launchpad but lauchpad seems to be as convoluted as Klein bottle
06:36:13 <pkug> Hi there, what would be a nice first project for somebody in network security field just finishing with haskellbook.com?
06:36:51 <hpc> a simple proxy server maybe?
06:37:30 <unit73e> implement a distributed chat client
06:37:36 <unit73e> and then give it to me because I want that
06:38:10 <unit73e> with libre license of course
06:38:16 <unit73e> go!
06:39:04 <pkug> I was initially thinking about tiny DNS server because I need that.. can some nice Haskell'ish event-driven (if there are) programming idioms be applied to network services?
06:39:22 <umib0zu> unit73e…. you mean like IRC?
06:39:28 <umib0zu> (distributed chat client)
06:39:37 <unit73e> umib0zu: IRC isn't distributed, it is server/client
06:39:48 <unit73e> but yeah something like that
06:39:52 <unit73e> without a server
06:40:03 <hpc> pkug: haskell is pretty nice for running servers because you can make each request/response its own thread and spin up thousands at a time
06:40:56 <pkug> hpc: I presume you mean lightweight threads (green or whatever they are called now..), similar to goroutines?
06:41:03 <unit73e> I have another idea I want. A distributed (again) thing that allows to tell you who owes you money, instead of a server/client architecture.
06:41:30 <srhb> pkug: Yes. :) What you get from forkIO, basically.
06:41:42 <srhb> pkug: I don't know if they are similar to goroutines.
06:42:21 <hpc> forkIO threads are the threadliest threads to ever concurrently compute ;)
06:42:23 * hackagebot makefile 0.1.0.4 - Simple Makefile parser  https://hackage.haskell.org/package/makefile-0.1.0.4 (nmattia)
06:42:25 * hackagebot makefile 0.1.0.5 - Simple Makefile parser  https://hackage.haskell.org/package/makefile-0.1.0.5 (nmattia)
06:43:41 <vincenzo> Does anyone have a good read on Data.Typeable & Data.Data? http://chrisdone.com/posts/data-typeable seems out of date. Is it?
06:44:47 <phadej> vincenzo: it isn't, why you think so?
06:45:09 <pkug> sounds nice, also as this is going to be the first project ideally I'd like to stick with standard library only.. that is, use network sockets and write protocol parser (for limited DNS it's going to be easy) myself, same question about parsers.. would that fit beautifully with functional idioms? any hints or maybe resources you could share as a starting point? :)
06:45:25 <vincenzo> The output of :i Typeable is diffrent now?
06:45:44 <c_wraith> Typeable has changed a few times recently, but the ideas are identical.  It's just safer.
06:46:24 <srhb> pkug: Using just the "standard library" (ie. base) is rarely something anything does, mind.
06:46:41 <srhb> pkug: And there are so many fantastic parser libraries out there that it seems really painful and counterproductive not to use one of them :)
06:47:20 <vincenzo> c_wraith: phadej: also the typeOf method is not there anymore?
06:47:21 <srhb> pkug: Otherwise the answer is going to be "rewrite attoparsec" if you're doing binary and network (de)serialization :P
06:47:35 <Cale> H... Hac Boston hype?!
06:47:40 <c_wraith> vincenzo: it's still a function with the same type.  It's just not part of the class anymore
06:47:52 <c_wraith> > typeOf (undefined :: Int)
06:47:53 <phadej> vincenzo: it is?
06:47:54 <lambdabot>  Int
06:48:18 <phadej> vincenzo: it's deprecated though, but still it's there for backward compat
06:48:24 <c_wraith> :t typeOf
06:48:25 <lambdabot> Typeable a => a -> TypeRep
06:48:33 <c_wraith> That's the exact same type it always had
06:49:46 <vincenzo> c_wraith: phadej: Ok, I see. The link I posted is still valid for the old version. Maybe it describes such deprecated APIs?
06:50:07 <c_wraith> The differences really aren't important if you're using Data.Data
06:56:03 <vincenzo> c_wraith: I'm trying to undertand what it does. I have no idea at the moment. So I'm asking just to know if a more up to date descrption would help. Maybe I'll write one once I understand it. Thank you!
07:00:07 <joeyh> ocharles: hey, nice to see you made argon2 bindings!
07:00:50 <JonReed> Hi, what do you guys use for more interactive developmentt? So far my strategy is to have a ghci shell open and a vim script that, when I press a shortcut or save file, without unfocusing the current vim window, instantly types `:load env.hs` and then `main` into the ghci
07:01:24 <JonReed> this reloads the module I'm currently working on and loads the file where main is function that currently outputs something I want
07:01:30 <Cale> JonReed: That kind of thing tends to work well... ghcid can be useful if you're working through a lot of type errors
07:01:39 <Cale> :r will also reload your module
07:02:11 <Cale> oh, my train is stopping, be back in a while
07:02:26 <srhb> I've also used ghcid with :main for when there's no type errors
07:03:00 <srhb> JonReed: Something like ghcid --restart . --test=":main (arguments...)"
07:09:53 <phadej> vincenzo: I'd recommend to come to Haskell eXchange in two month, Simon Peyton Jones will talk about newer Typeable
07:10:31 <sm> JonReed: ghcid -c '..suitable ghci invocation..' in a side window
07:10:42 <phadej> vincenzo: ... and SPJ is very good presenter, I'm sure you'll understand the previous (i.e. current) Typeable as well
07:11:23 <sm> and an interactive ghci in another one
07:12:01 <black0range> Yo, doing some procrastenation on work solving this little problem. Just for fun i did the following two solutions Exponents: http://lpaste.net/174402 and List: http://lpaste.net/174403 (Please dont mock my sloppy solutions :'() However! The list based solution is faster, could anyone explain why?
07:12:02 <JonReed> Yeah, thx for suggestions. It seems that everybody is using ghcid, so I'll check that out.
07:12:24 <black0range> where "this little problem" = https://open.kattis.com/problems/classy
07:16:05 <srhb> phadej: Ooooh, exciting. I hope there will be videos, there's no chance I can afford travelling there.
07:17:04 <AaronFriel> I rewrote parts of Oleg's "eff" (particularly, OpenUnion51) to use type level naturals instead of the unpacked int parameter, and I get worse performance on his benchmarks (-Odph, with or without -fllvm -optlo-O3), and I'm not sure why.
07:17:13 <AaronFriel> My Union looks like:   Union :: KnownNat n => t v -> Union n r v
07:17:48 <phadej> srhb: there was previous year, but nothing beats being there physically :)
07:18:06 <srhb> phadej: Obviously. :) But it's much better than nothing, if you're broke. :P
07:18:19 <jchia_> mniip, merijn: I solved the JSON parsing problem that we talked about just now. STV works
07:18:21 <AaronFriel> Is the existential quantification causing it to pay additional overhead at run time? (e.g.: larger structure in memory, more indirections?)
07:20:42 <AaronFriel> I would figure that by making it parameterized by a type level natural would improve performance and move the index parameter juggling to compile time
07:25:24 <joe9> The prelude is a nuisance when working with Data.Text instead of String. Is there a better prelude?
07:25:53 <shapr> joe9: there are several options, have you seen things like https://github.com/parsonsmatt/lifted-protolude ?
07:26:31 <black0range> joe9: the problem is that all the String functions are functions that are defined for lists and not primarily ment to be working on text
07:27:31 <black0range> joe9: I would suggest importing Data.Text qualified as T, and maybe change the prelude show, print etc functions yourself :) 
07:27:51 <glguy> joe9: once you import qualified it doesn't clash with the prelude
07:28:26 <joe9> shapr: Thanks, will check out protoprelude. there is a classy-prelude, any comments on that, please?
07:29:05 <shapr> joe9: I haven't investigated all the options, but if you do, I want to read that blog post :-)
07:29:05 <glguy> I'd recommend against learning a new prelude, also you can import multiple modules to the same name, e.g.
07:29:22 <joe9> glguy: black0range , I understand using qualified. but, when most of the functions have T., it feels that aI am not doing something correct.
07:29:25 <glguy> import Data.Text as T; import Data.Text.IO as T
07:30:04 <glguy> joe9: sounds fine. if you're using text functions they're likely to be qualified, the module was intended for that
07:30:59 <black0range> joe9: I understand what you mean. Sadly it is the only sane way (assuming you still want to keep the functions for list operations) 
07:33:03 <joe9> black0range: I seem to be using fmap more than map. so, maybe, I could just move to Foldable and Traversable. Do I need to bother with List functions in that case?
07:36:06 <black0range> joe9: that could be a good idea, concat and append exists in monoid, you still want (:) though but you could export that and maybe a few others only
07:37:54 <joe9> black0range:  Thanks.
07:38:44 <leshow> how would one define a type in haskell to represent only unsigned integers?
07:39:01 <black0range> leshow: look in Data.Word :)
07:39:19 <leshow> i looked online and i  was directed to liquidhaskell
07:39:31 <black0range> leshow: Data.Word :P 
07:40:08 <leshow> ok, what about if i wanted to define a type of integers from 1 to 100
07:40:30 <joe9> I am trying to understand this. finally of Control.Exception.Safe does not do cleanup when I press Ctrl-C . or, Does it?
07:42:21 <merijn> joe9: That depends on so many details your question is impossible to answer
07:42:44 <merijn> joe9: Ctrl-C sends SIGINT to a process, what that does depends on what said process has done
07:42:56 <merijn> The default behaviour for SIGINT is to kill the process
07:43:34 <merijn> It *might* be that GHC's runtime by default installs a handler that throws an exception to the main thread, but that handler can be removed/overridden
07:44:14 <joe9> ok, Thanks. it could be the ghci's signal handler doing something then.
07:44:36 <leshow> is there a way to define types with a constraint, like an int from 0 to 100, or a list with length 10 or something
07:44:47 <joe9> merijn: I am running the code from ghci and notice that when I press Ctrl-C , the finally is not being called.
07:46:03 <JonReed> leshow: To my knowledge, you'll have to use refined types like liquid Haskell. CPU will still represend 0-100 as a Word.
07:46:37 <JonReed> leshow: For havivg lists of a certain lenght, you can use dependent types.
07:47:05 <leshow> haskell has support for dependent types?
07:47:52 <AaronFriel> on that note, does anyone here have experience working with the singletons library and TypeLits?
07:48:02 <merijn> JonReed: or....the simple approach, newtype Int, don't export constructor
07:48:08 <JonReed> leshow: Not really, but there are similar tricks. 
07:48:21 <JonReed> leshow: E.g., check this out: https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell
07:48:26 <danilo2> Hello guys! :) I want to run my custom pre-processor in GHc using the -F -pgmF flags . Is there any way to pass a relative path, not an absolute one? I would like to bunddle this pre-processor into a bigger package and include this option in a stakc config. For now I can run it only by providing absolute path
07:52:14 <leshow> im trying to add liquid haskell to my project, i added liquidhaskell-0.6.0.0 to my extra deps in the cabal file
07:52:26 <leshow> but the import wont compile
07:52:49 <leshow> sorry i added it to the stack.yaml
07:52:57 <leshow> do i also have to add it to the cabal file?
07:53:09 <danilo2> leshow: yes
07:53:22 <danilo2> leshow: you dont have to add it to stack unless it is not included in LTS
07:53:59 <leshow> so many negates in that sentence lol
07:54:07 <leshow> if it's not in LTS, add it to the stack file?
07:55:19 <danilo2> leshow: ugh, yes. Sorry for too many negates. Its a funny thing, because in my mother-language if you want to tell "unless it is included in" you tell "unless it is not included in" (and it means the same as the one without "not" in english). 
07:55:46 <leshow> haha its all good
07:56:20 <leshow> so i added it to both, and when i build its saying i need more dependencies
07:56:24 <leshow> do i have to manually add those as well
07:56:39 <leshow> is there a way for stack to auto add all of the deps
07:56:43 <JonReed> leshow: Hav you tried using nix? 
07:56:58 <leshow> no? isnt that a package manager for an OS
07:58:02 <leshow> i dont want to change my package manager for my system, i just want to compile this test project
07:58:12 <JonReed> leshow: It's a package manager which have fully reproduciable environments, which removes a lot of the pain
07:58:27 <JonReed> leshow: You can use it along side your system
07:59:11 <JonReed> leshow: E.g., I use it on arch which has pacman as the main package manager
08:00:03 <leshow> im sure it's possible to compile this project with stack, ill look and see if there's an auto add deps command or something
08:01:26 <JonReed> leshow: I would suggest using it to remove a lot of the pain, because usually it just works. But as I was suggesting it, it failed to install liquid haskell :), so nevermind. 
08:01:41 <leshow> lol
08:01:44 <rabbi1> Hey, what is the difference between 'yesod init' and 'stack new my-project yesod-sqlite' ?
08:02:26 <jchia_> What are some effective ways to deal with functions that are defined in multiple packages? E.g. (<>) defined in both Data.Semigroup and Data.Monoid? I find myself spending more time than I like managing imports and it breaks my train of thoughts.
08:02:27 * hackagebot currency-convert 0.1.0.0 - Typesafe currency conversion  https://hackage.haskell.org/package/currency-convert-0.1.0.0 (pigworts2)
08:02:32 <leshow> rabbi1: one of those is going to make a new project with stack, the other one is going to do whatever yesod init does lol
08:03:14 <rabbi1> leshow: sorry,  i am new. and trying to install yesod. the quick start page, shows log of installs 
08:04:32 <rabbi1> let me reframe my question… if stack creates new project, then later when i install yesod and the run yesod init ? 
08:05:22 <leshow> i assume yesod init creates a new yesod project for you, so you probably dont want to run both
08:06:23 <Clint> yesod init doesn't do anything anymore
08:06:46 <rabbi1> yeap, that is what my doubt is..
08:07:03 <Clint> so that would be the significant difference
08:07:20 <leshow> rabbi1: about my other issue, after adding liquidhaskell to extra-deps, i ran stack solver and it auto added all the extra deps i needed
08:07:24 <rabbi1> yesod init will ask me for scaffolding of new project, then why i need stack new project_name ?
08:07:38 <Clint> rabbi1: it doesn't do that anymore
08:07:59 <rabbi1> Clint: it ? 
08:08:03 <rabbi1> that ?
08:08:09 <Clint> rabbi1: % yesod init
08:08:09 <Clint> The init command has been removed.
08:08:21 <sm> leshow: stack solver can auto-add deps to your stack.yaml
08:08:32 <sm> stack probably suggested it already
08:08:51 <rabbi1> Clint: cool, to sum up.. i should do stack new project and so on …. 
08:09:16 <rabbi1> The book is also not updated then
08:09:25 <sm> ack, you figured that out already
08:10:34 <glguy> leshow: After you add a new dependency to your package's cabal file you can update your local environment with stack solver --update-config
08:12:09 <leshow> thanks guys, stack gave that helpful message when i attempted to build after adding the dep
08:12:27 <rabbi1> sm: already ?
08:12:28 * hackagebot type-natural 0.6.1.1 - Type-level natural and proofs of their properties.  https://hackage.haskell.org/package/type-natural-0.6.1.1 (HiromiIshii)
08:12:42 <leshow> just so i understand, in the stack.yaml file, you can add freely whatever packages are included in the LTS version you're using right?
08:12:51 <leshow> and if you want to add anything else, you add it to the other file?
08:12:55 <sm> rabbi1: sorry, that was not to you
08:13:13 <leshow> sorry projectname.cabal for the LTS packages
08:13:16 <glguy> leshow: If you want something that isn't in the resolver you're using you add it to the extra-deps: section of your stack.yaml
08:13:34 <leshow> yeah ok, i understand
08:13:35 <leshow> thanks
08:13:48 <glguy> Your .cabal file lists the dependencies of your package; your stack.yaml lists the versions you happen to be using at the moment in the current directory
08:14:10 <leshow> is liquidhaskell a popular dependency to add to projects?
08:14:13 <leshow> it seems pretty useful
08:14:42 <leshow> or do haskellers prefer to handle stuff like "int must be between 0 and 100" in the function body
08:15:00 <leshow> by returning a maybe type or something
08:16:30 <glguy> I've only seen people using Liquid Haskell in talks about Liquid Haskell, myself.
08:17:54 <leshow> how would you handle constraints like that then
08:17:58 <leshow> in idiomatic haskell code
08:17:59 <sm> leshow: you might be leading the way here, let us know how it works out
08:19:28 <glguy> leshow: writing a function to return an indication of invalid arguments like you said sounds right
08:20:11 <glguy> If there's a particular range that values need to be in, they can be validated in a smart constructor for a newtype
08:20:35 <glguy> so that the validation can be handled in one place rather than spread out
08:21:02 <glguy> newtype SpecialInt = SpecialInt Int, and then providing a function :: Int -> Maybe SpecialInt
08:22:49 <leshow> okay that makes sense, i didnt think about using newtype
08:34:25 <c_wraith> hmm. how much does http://lpaste.net/174131 depend on laziness? even if g is calculated strictly, it's going to be a function, and therefore not recurse unless called, right? Holy crap, I'm having trouble understanding strict evaluation. take that people who say laziness is harder! 
08:36:02 <glguy> c_wraith: That looks fine, I don't think I understand your concern
08:36:16 <c_wraith> it's fine in Haskell. 
08:36:46 <c_wraith> my question was more like whether it could terminate without traversing the whole list in a strict language. 
08:37:07 <glguy> I wouldn't expect so
08:37:58 <glguy> computing 'g' requires computing 'p x'
08:38:26 <c_wraith> hmm, yes. 
08:38:42 <c_wraith> strict evaluation is hard. why do people like it, again? 
08:38:59 <glguy> Are you assuming that foldr in this context is itself written to be lazy in some way?
08:39:23 <c_wraith> no. just that it runs front to back. 
08:39:45 <c_wraith> instead of some weird thing that tries to optimize by running back to front. 
08:39:46 <glguy> because it would seem to be the case that in a strict setting it wouldn't matter what the computation was; foldr would still not work on an infinite list
08:39:55 <leshow> liiquid haskell doesn't seem to be working out very well for me lol
08:40:06 <leshow> it wont compile with strange errors
08:40:20 <glguy> foldr f z (x:xs) = f x (foldr f z xs) -- foldr f z xs    would have to return before f was ever run
08:41:12 <c_wraith> right. 
08:41:50 <glguy> It's basically the Haskell version of foldl
08:42:00 <glguy> nothing's happening until the list is consumed
08:42:25 <glguy> err, the non-Haskell version of foldl
08:42:30 * hackagebot phoityne-vscode 0.0.8.0 - ghci debug viewer on Visual Studio Code  https://hackage.haskell.org/package/phoityne-vscode-0.0.8.0 (phoityne_hs)
08:42:45 <pchiusano> ByteString uses a ForeignPtr... does that mean that all temporary ByteString values need to be traversed by the GC (to invoke finalizer for the ForeignPtr)?
08:43:42 <glguy> Yes, the GC is used to determine when to free the memory associated with a bytestring
08:43:56 <pchiusano> what a horrible technical decision
08:44:08 <pchiusano> what were they thinking
08:44:45 <glguy> That... that's the only way it could work? What'd you have in mind?
08:45:10 <glguy> The whole bytestring itself isn't traversed, just in case that's what you're asking
08:45:22 <paolino> using attoparsec to parse a decimal or a decimal ^ decimal . If I pass it a "2\n" it gives me a Partial _ instead of a Done "\n" 2
08:45:42 <glguy> pchiusano: remember that not all bytestrings are new allocations
08:45:53 <pchiusano> glguy: regular values that become garbage do not need to be visited if they become garbage while in the nursery
08:46:20 <pchiusano> since the nursery is collected by copying live values to a new space
08:46:34 <pchiusano> so only live values are traversed
08:46:35 <glguy> pchiusano: so if you use ByteString's take, for example, you're not allocating a new bytestring
08:46:57 <paolino> how can I make it fail the exponential parsing fail and give me the number ?
08:47:28 <pchiusano> glguy: yes, that is good, but there is still a huge penalty when allocating large numbers of temporary bytestrings
08:47:42 <pchiusano> compared to alternate representations
08:48:33 <pchiusano> and it's done, apparently, to make it easier to pass bytestrings to C??? WHO CARES
08:48:44 <glguy> pchiusano: Do you know about http://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString-Short.html ?
08:49:28 <glguy> The ShortByteString type (and the Text type from the text package) use unpinned memory so they do not contribute to heap fragmentation. In addition, with GHC, small unpinned strings are allocated in the same way as normal heap allocations, rather than in a separate pinned area.
08:50:06 <pchiusano> ah, no i did not
08:50:41 <pchiusano> unfortunately it has a rather limited API, and no other libraries use it
08:54:38 <c_wraith> you can also use Vector.Unboxed of Word8
08:54:39 <pchiusano> ByteString and Text are impossible to avoid, used everywhere, and terrible
08:54:56 <c_wraith> err, Vector.Storable
08:55:20 <c_wraith> that will give you fusion to eliminate intermediate values, with some luck. 
08:56:26 <pchiusano> c_wraith: you are referring to rewrite rules? the ones that are super brittle and depend on what gets inlined?
08:56:40 <glguy> Yeah, those
08:56:48 <pchiusano> any library relying on rewrite rules for performance is broken by design
08:56:49 <c_wraith> they're not *that* brittle. 
08:57:11 <c_wraith> they work pretty well in practice. 
08:57:22 <c_wraith> way better than complaining does, anyway. 
08:57:40 <JonReed> leshow: I did not use liquid haskell myself much. The only benefit of it tha I can remember is that it tracks constrains (like what happens if you define a number as Odd and then add two Odd numbers). Most people would use newtypes, so something like `module MyModule (Hundred, toHundred); newtype Hundred = ToHundred Int; toHundred :: Int -> Maybe Hundred`. 
09:01:24 <pchiusano> c_wraith: you're right complaining doesn't accomplish anything
09:01:45 * pchiusano gets back to work
09:02:18 <jfischoff> Vector has a pretty interface FWIW and the Unboxed version is backed by MutableByteArray
09:03:57 <vaibhavsagar> paolino: feed it a ""
09:04:32 <vaibhavsagar> paolino: by which I mean ByteString.empty
09:05:04 <paolino> it's skipMany space that get me wrong
09:05:33 <vaibhavsagar> what happens if you feed it ""?
09:06:06 <vaibhavsagar> I usually like to do (either error id (parseOnly <parser> <input>))
09:07:12 <vaibhavsagar> e.g. https://github.com/vaibhavsagar/duffer.hs/blob/master/src/Duffer/Loose.hs#L38
09:09:56 <pchiusano> jfischoff: ah, does MutableByteArray use finalizers, or is it just like a 'regular' value
09:11:14 <jfischoff> AFAICT ’regular’
09:13:51 <pchiusano> I bet I could concoct a benchmark where Haskell using bytestrings had embarassingly bad performance vs, say, Java
09:15:21 <jfischoff> yes this happened at IMVU with url parsing
09:15:58 <pchiusano> jfischoff: IMVU?
09:16:21 <jfischoff> company I worked at that uses Haskell
09:16:33 <jfischoff> I think they wrote about it ...
09:17:08 <pchiusano> jfischoff: ah, you had a situation where you had lots of temp bytestrings, and it was pummeling the GC? 
09:18:22 <jfischoff> I don’t know the exact diagnose other than lots of small bytestring where to blame … the issue occured right before I left … but they updated me a few months later
09:18:33 <jfischoff> https://chadaustin.me/2015/02/buffer-builder/
09:19:28 <jfischoff> I’m not sure if that is the best solution or not but it worked for them
09:23:11 <orion> pchiusano: Hi. :)
09:27:11 <pchiusano> jfischoff: interesting thanks
09:27:14 <pchiusano> hi orion 
09:27:56 <pchiusano> should i recognize the name orion from somewhere...?
09:33:03 <glguy> It's a famous constellation
09:48:50 <ongy> what's the general thing with hackage and licenses? Are license compatibilities checked anywhere? And do GPL "package together" things even apply when it's downloaded separatly?
09:50:10 <shapr> ongy: I don't think the licenses are checked.
09:51:34 <shapr> ongy: put up a PR against hackage?
09:52:09 <Clint> for what
09:52:17 <Clint> hackage can't do accurate license analysis
09:52:58 <monochrom> some people have their company lawyers check manually.
09:52:59 <geekosaur> hackage also doesn't do binary downloads, and any license lets you combine things *for local use* --- you just can't distribute binaries
09:53:42 <geekosaur> (outside your org, so you can build once and deploy binaries internally)
09:53:49 <monochrom> the company lawyers already receive a monthly salary. may as well give them something to do manually.
09:53:59 <orion> pchiusano: You and tmciver are using cacophony on a project.
09:54:06 <monochrom> in fact if you automate their jobs away, they may actually be upset :)
09:54:20 <infandum`> Is it appropriate to ask about haskell and emacs integration here?
09:55:02 <monochrom> yes
09:56:42 <infandum`> I use haskell. I use haskell over ssh most of the time. Is it possible in emacs to use ghc-mod and haskell-mode over tramp? Tramp works fine, but it doesn't seem to find the other files in the project for use with ghc-mod and syntax checking and the like. It finds it with projectile, but not syntax checking.
09:57:25 <infandum`> So I can switch to those files with projectile, but syntax checking doesn't "see" those other modules in the project.
10:02:23 <geekosaur> that might be better asked on the haskellmode-emacs list, if nobody here can help
10:02:31 <geekosaur> http://projects.haskell.org/cgi-bin/mailman/listinfo/haskellmode-emacs
10:02:57 <infandum`> I'll check it out
10:15:29 <ongy> geekosaur: I think fsf would consider it a violation (closest I can find) https://www.gnu.org/licenses/gpl-faq.html#NFUseGPLPlugins
10:17:14 <geekosaur> they would indeed. they just don't have a legal leg to stand on, much as they'd prefer it.
10:17:46 <geekosaur> however your link is about dynamically linked plugins which is a different issue (and iirc not one that's been tested in court, so still a bit up in the air)
10:18:46 <cocreature> I still find the idea weird, that the technical difference between dynamic and static linking should make a legal difference
10:20:12 <Clint> legal systems are fuzzy
10:20:26 <geekosaur> this part is reasonably well tested since it's not unusual for technical theses to involve software that links things, whichc an be source distributed but not binary (the case of thesis software linking GPL libs and Matlab came up a lot at $prevjob)
10:21:55 <geekosaur> it's a bit edge-case-y but permitted for that use case (thesis supporting software is considered more personal-use than, say, distributing a general use software package that required you to do that same linking)
10:22:52 <geekosaur> (and the edge cases don't often cone up because if the software's *that* interesting then there's probably already commercial activity pending involving it, for which the licensing issues are much more clear)
10:29:32 <geekosaur> all this said, source building environments (bsd ports, etc.) don't generally check licenses except when determining whether they are allowed to build distributable packages; otherwise it's left to the user
10:29:52 <ongy> geekosaur: I was searching for the objective-c gcc thingy, but can't find the full story, that's the closest case I could find. But it's a bit different either way. And I don't know of any court case for that either
10:30:55 <Clint> you'd be asking for all sorts of trouble if your software started giving you legal advice
10:31:01 <Clint> especially since half of it would be incorrect
10:31:09 <geekosaur> yeh
10:41:27 --- mode: ChanServ set -q *!*@ppp109-252-72-34.pppoe.spdop.ru
10:49:27 <mauke> :t fmap fmap fmap
10:49:28 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
10:50:29 <ongy> :t fmap . fmap
10:50:31 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
10:52:04 <infandum> Okay, I've narrowed it down. Using sshfs I can mount a remote system with my haskell code and stack project. However, flycheck spits out this error from stack: You are not the owner of '/path/to/.stack-work/'. Aborting to protect file permissions. This seems to be a stack issue? I own the directory, but it's over sshfs so maybe that's the issue?
10:52:57 <geekosaur> seems likely, as permissions are tricky over sshfs
10:53:23 <infandum> hmph
10:53:35 <infandum> ls -la says that I do own the directory though
10:53:37 <infandum> :/
10:53:39 <geekosaur> stack might need (or even might have somewhere) an option to disable the pickiness for use with filesystems that don't handle permissions the same way as local unix-like filesystems (vfat/ntfs, cifs, ...)
10:54:03 <infandum> it said to pass something called "--alow-other-users" or something like that
10:54:20 <infandum> I didn't want to mess around with any function calls in flycheck though, but I can check it out
10:54:27 <infandum> --allow-different-user
10:55:48 <infandum> Allow users other than the owner of the stack root directory (typically ~/.stack) to use the stack installation. 
10:56:08 <infandum> So it's emacs?
10:56:09 <infandum> weird
10:56:27 <infandum> even though it was find WITHOUT sshfs. Boy, sshfs seems more confusing than it needs to be
10:57:01 <ongy> sshfs is weird
10:57:18 <ongy> try doing something with sudo in it, or anything that's not a basic usecase
10:57:38 * hackagebot sqlite 0.5.5 - Haskell binding to sqlite3  https://hackage.haskell.org/package/sqlite-0.5.5 (AdamWick)
10:57:57 <infandum> well adding that allow users to my config worked
10:57:59 <infandum> weird
10:58:26 <infandum> I think someone mentioned nfs...is that better?
10:58:36 <dmwit> nfs comes with its own oddities.
10:58:51 <dmwit> I don't think you can get away with both of "networked" and "no oddities".
10:59:33 <infandum> drat
11:00:00 <ongy> nfs is no fun with laptop that moves between networks :(
11:00:01 <dmwit> Hell, I'm not sure you can get away with one of "no oddities". -_-
11:00:05 <infandum> someone also mentioned working locally and pushing the changes to the server. The downside of that is that I have multiple computers I work from, so I would have to constantly keep everything in sync
11:00:22 <dmwit> infandum: You may like unison for keeping things in sync.
11:00:24 <infandum> I would have to remember to commit and push every time I make a change
11:00:28 <infandum> unison?
11:00:29 <dmwit> infandum: Or any of the usual VCSs.
11:00:46 <infandum> I use git, but it's not like an automatic thing
11:00:48 <dmwit> https://www.cis.upenn.edu/~bcpierce/unison/
11:00:51 <infandum> nor would I want it to be
11:01:28 <dmwit> I ran unison once in the morning before I got to work and once in the evening before I left work for several years. Worked great.
11:02:14 <infandum> is that different from pushing with git in the morning and in the evening?
11:02:43 <dmwit> Yes: there is no version control, and it is bidirectional rather than unidirectional.
11:03:27 <dmwit> e.g. if you make some changes locally on your work computer and remotely make some changes to your home computer, *both* sets of changes will be propagated.
11:03:50 <dmwit> Whereas with git you are always pushing (resp. pulling) from one location to another.
11:03:57 <dmwit> (and rsync and other backup-like tools)
11:04:15 <infandum> I see, like a dropbox command
11:04:19 <dmwit> The bidirectionality has saved my bacon several times.
11:04:35 <dmwit> Like dropbox, but unlike dropbox it has a carefully thought-out semantics.
11:04:57 <infandum> haha
11:05:07 <infandum> unfortunately it doesn't look like it's maintained anymore
11:06:09 * dmwit shrugs
11:06:28 <dmwit> It hasn't given me any trouble. If it works, why maintain it?
11:07:25 <infandum> That makes sense
11:07:26 <vincenzo> phadej: Thank you for the suggestion!
11:08:11 <monochrom> what it needs is donation
11:10:24 <vincenzo> phadej: I'll try to attend.
11:14:00 <leshow> how does one specify a typeclass constraint on one argument and not on another
11:14:15 <leshow> for example, if i wanted a to be Num and b to be polymorphic
11:14:20 <dysfun> is there some good introductory material to 'freer'? I've spent most of the day trying to work with it but I'm still having a bit of difficulty
11:14:30 <monochrom> Num a => a -> b -> ()
11:14:31 <dmwit> leshow: Num a => a -> b -- ?
11:14:32 <leshow> fn :: (Num a, b) => a -> b -> c
11:14:37 <leshow> oh
11:14:39 <leshow> lol
11:14:42 <leshow> that makes sense
11:14:44 <hpc> :t \x y -> x + 4
11:14:46 <lambdabot> Num a => a -> r -> a
11:14:48 <hpc> ;)
11:14:51 <leshow> thanks
11:14:53 <dmwit> leshow: In other words, if you don't want to constrain `b`, just... don't. =)
11:15:04 <leshow> feels like a dumb question now lol
11:15:13 <monochrom> the power of emptiness and saying nothing
11:15:35 <monochrom> it did took humanity thousands of years to think up the idea of zero.
11:16:55 <leshow> i got liquidhaskell working now, it wasnt what i expected really
11:17:03 <leshow> i thought it would be integrated into GHC
11:17:12 <hpc> more fun math facts: pythagoras had someone killed for proving that the square root of 2 was irrational
11:17:15 <leshow> i didnt think i'd have to run the SMT solver on it additionally
11:17:22 <nak> if i want to override a prelude definition with one of my own methods, how do i do that?
11:17:34 <leshow> just write your new definition i think
11:17:45 <dmwit> hpc: That's false advertising! That's a history fact, not a math fact.
11:17:46 <nak> but ghci warns "ambiguous occurence"
11:17:55 <monochrom> was that pythagoras? or was that some disciple long after pythagoras had died?
11:18:00 <dmwit> nak: import Prelude hiding (foo)
11:18:07 <nak> and fails to load the module
11:18:43 <dmwit> nak: But beware that this is not overriding anything. Other libraries that used that Prelude function will still be using it; no monkey-patching in Haskell.
11:20:15 <hpc> "Legend has it that the Pythagorean philosopher Hippasus used geometric methods to demonstrate the irrationality of sqrt(2) while at sea and, upon notifying his comrades of his great discovery, was immediately thrown overboard by the fanatic Pythagoreans"
11:20:33 <hpc> monochrom: can't actually find a citation stronger than that, hmm
11:20:58 <nak> dmwit ok thanks. i'm just doing some learning stuff where i want to implement my own methods and i ran into a function that already existed
11:23:12 <nak> > rem 5 2
11:23:13 <lambdabot>  1
11:23:16 <dmwit> nak: Sure. It's common; picking names that don't collide with anything that exists is hard.
11:23:19 <nak> > rem -5 2
11:23:20 <lambdabot>      Could not deduce (Num a0)
11:23:21 <lambdabot>      from the context (Integral a,
11:23:21 <lambdabot>                        Num a1,
11:23:24 <dmwit> > rem (-5) 2
11:23:25 <lambdabot>  -1
11:23:33 <nak> oooo
11:23:43 <nak> arigatou
11:23:59 <dmwit> > abs (-5)
11:24:01 <lambdabot>  5
11:24:02 <dmwit> > x -5
11:24:04 <lambdabot>  x - 5
11:24:12 <dmwit> > f (-5)
11:24:14 <lambdabot>      No instance for (Show a0)
11:24:14 <lambdabot>        arising from a use of ‘show_M374333981423294524218114’
11:24:14 <lambdabot>      The type variable ‘a0’ is ambiguous
11:24:17 <dmwit> heh
11:24:20 <dmwit> > f (-5) :: Expr
11:24:21 <lambdabot>  f (-5)
11:24:24 <nak> wait wait
11:24:31 <dmwit> I'm actually mildly surprised that Expr got that right.
11:24:49 <sm> leshow: how hard is it to run the extra liquidhaskell checks ?
11:24:52 <nak> dmwit how the heck did > x -5  get evaluated to "x - 5"
11:24:58 <dmwit> nak: There's `-` the infix subtraction function, and `-` the prefix negation function.
11:25:03 <dmwit> nak: Oh, that.
11:25:14 <nak> why is lambdabot not complaining about undefined x ??
11:25:23 <dmwit> nak: Because it's defined. =)
11:25:25 <dmwit> :t x
11:25:26 <lambdabot> Expr
11:25:30 <nak> o
11:25:58 <dmwit> nak: There's a sneaky module loaded in lambdabot that defines an `Expr` type that implements a bunch of typeclasses -- including `Num` -- and just prints the expression rather than doing any computation.
11:26:08 <dmwit> ?hackage simple-reflect has the implementation
11:26:09 <lambdabot> http://hackage.haskell.org/package/simple-reflect has the implementation
11:26:16 <nak> very handy
11:26:21 <nak> thank you thank you
11:26:41 <dmwit> nak: Then there's a bunch of constants defined -- x, y, z, f, g, h -- that correspond to "variables" and "functions".
11:26:44 <geekosaur> > foldr f z [a,b,c] -- what this does
11:26:45 <lambdabot>  f a (f b (f c z))
11:27:02 <nak> oo very nice
11:27:18 <dmwit> > foldl f z [a,b,c]
11:27:20 <lambdabot>  f (f (f z a) b) c
11:27:28 <nak> > foldl1 f [a,b,c]
11:27:30 <lambdabot>  f (f a b) c
11:27:33 <nak> yay
11:28:15 <nak> > map (+2) [a,b,c]
11:28:17 <lambdabot>  [a + 2,b + 2,c + 2]
11:28:22 <nak> that's bad ass
11:28:39 <geekosaur> it does have its limits, but it's pretty nice for the stuff it can handle
11:29:00 <geekosaur> but that's why all the single character names are already bound in lambdabot
11:29:02 <dmwit> It is of course completely useless in real code. But hot darn is it handy for pedagogy here in #haskell. =)
11:29:46 <nak> for sure
11:29:54 <ongy> map (+2) [a, b, ab]
11:30:00 <ongy> > map (+2) [a, b, ab]
11:30:01 <lambdabot>      Not in scope: ‘ab’
11:30:02 <lambdabot>      Perhaps you meant one of these:
11:30:02 <lambdabot>        ‘a’ (imported from Debug.SimpleReflect),
11:30:10 <ongy> so it's only the one character names
11:30:13 <ongy> good to know
11:30:25 <kadoban> There's only a few of them, I don't think it's even all one-character ones.
11:30:26 <hpc> it's whatever is defined
11:30:27 <hpc> :t a
11:30:29 <lambdabot> Expr
11:30:48 <dmwit> > map (+2) [a, b, var "ab"]
11:30:53 <hpc> a-d are definitely defined, as are f and g
11:30:54 <lambdabot>  [a + 2,b + 2,ab + 2]
11:30:59 <hpc> i think x, y, z are too?
11:31:35 <hpc> :t e
11:31:36 <lambdabot> Expr
11:31:52 <hpc> :t v
11:31:57 <lambdabot> Expr
11:32:04 <hpc> huh, maybe all 26 are defined
11:32:15 * hpc pms lambdabot to confirm
11:32:24 <ongy> > f `fmap` [a..z]
11:32:25 <lambdabot>      No instance for (Show b0)
11:32:25 <lambdabot>        arising from a use of ‘show_M576326883282194997618465’
11:32:25 <lambdabot>      The type variable ‘b0’ is ambiguous
11:32:40 <ongy> does the list not work, or is something else being weird?
11:33:06 <cocreature> is there any way to get something like the line number in a th splice in an error message/warning instead of the line generating that TH?
11:33:11 <hpc> yeah, they all :: Expr, except for f, g, h which are (FromExpr t) => t
11:33:28 <Iceland_jack> > scanr1 (⊗) [a,b,c]
11:33:30 <lambdabot>  [a ⊗ (b ⊗ c),b ⊗ c,c]
11:33:47 <ongy> btw. what's the type for [a..b]? SomeClass a => [a]?
11:33:50 <hpc> (f/g/h are as such so you can apply them to other things)
11:34:02 <ongy> > a [b, c]
11:34:03 <hpc> ongy: it'd be Enum Expr => Expr
11:34:04 <lambdabot>      Couldn't match expected type ‘[Expr] -> t’ with actual type ‘Expr’
11:34:04 <lambdabot>      The function ‘a’ is applied to one argument,
11:34:04 <lambdabot>      but its type ‘Expr’ has none
11:34:05 <Iceland_jack>  :t [a..b]
11:34:22 <ongy> :t [a..b]
11:34:23 <lambdabot> [Expr]
11:34:25 <hpc> (which is a type error if there's no Enum Expr, and just Expr if there is)
11:34:34 <ongy> I was talking about general case for ghc
11:34:45 <hpc> > [a .. d]
11:34:47 <lambdabot>  *Exception: not an integer: a
11:34:48 <ongy> what's required of the type for that notation to work
11:34:57 <hpc> oh that's funny
11:35:13 <hpc> :t \x y -> [x .. y]
11:35:14 <lambdabot> Enum t => t -> t -> [t]
11:35:18 <dmwit> > [3..5] :: [Expr]
11:35:21 <lambdabot>  [3,4,5]
11:35:32 <hpc> ongy: it just needs Enum
11:35:33 <hpc> @src Enum
11:35:34 <lambdabot> class Enum a where
11:35:34 <lambdabot>     succ, pred               :: a -> a
11:35:34 <lambdabot>     toEnum                   :: Int -> a
11:35:34 <lambdabot>     fromEnum                 :: a -> Int
11:35:34 <lambdabot>     enumFrom                 :: a -> [a]
11:35:35 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
11:35:37 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
11:35:40 <dmwit> I'll admit I would have expected `[a..z]` to print `enumFromTo a z`.
11:35:41 <hpc> whoops that's a long one
11:36:23 <dmwit> `Enum` and `Num` are odd nods to practicality in an otherwise strongly theory-friendly language.
11:36:56 <ongy> can lamdabot print all instances of a class it knows?
11:37:03 <dmwit> ?instances Enum
11:37:06 <lambdabot> (), (Shrink2 a), Blind a, Bool, CReal, Char, Double, Expr, Float, GeneralCategory, Int, Int16, Int32, Int64, Int8, Integer, Large a, Natural, NonNegative a, NonZero a, Ordering, Positive a, Ratio a, Small a, Sym a, Word, Word16, Word32, Word64, Word8
11:37:07 <ongy> mh, for most classes that would be quite long, so...
11:37:09 <hpc> the pair of classes Floating and RealFloat are nods to impracticality ;)
11:37:10 <ongy> oh, nice
11:37:29 <ongy> @src Floating
11:37:29 <lambdabot> class (Fractional a) => Floating a where
11:37:29 <lambdabot>     pi                  :: a
11:37:29 <lambdabot>     exp, log, sqrt      :: a -> a
11:37:29 <lambdabot>     sin, cos, tan       :: a -> a
11:37:29 <lambdabot>     asin, acos, atan    :: a -> a
11:37:31 <lambdabot> [3 @more lines]
11:37:55 <ongy> hpc: why does it print more when you use @src? are you moderator of some kind?
11:38:03 <dmwit> ongy: Beware: whether ?instances answers your question depends on what you mean by "knows".
11:38:18 <hpc> ongy: it's for flood prevention, type @more to see more
11:38:24 <hpc> ongy: but also don't, it's pretty spammy
11:38:39 <hpc> also hoogle RealFloat instead of looking it up here, because it's even longer
11:39:03 <dmwit> hpc: You didn't really answer ongy's question.
11:39:39 <dmwit> ongy: I don't know the explanation, but I believe it is not because lambdabot believes hpc is special.
11:39:52 <hpc> oh, it's because mine was 7 lines
11:40:05 <hpc> the math works out that shrinking it and doing @more is spammier than just showing it
11:40:12 <dmwit> ongy: I have a few guesses: lambdabot may remember how much it's said recently; or it may have asymmetric line limits.
11:40:45 <ongy> oh, so 7 is ok, but if it's 8 or longer it limits to 5 (+ telling me there's more?)
11:40:54 <dmwit> ongy: e.g. a limit of 7 lines, or only the first 5 + the @more line if it's greater than 8. Don't know that for sure.
11:41:03 <hpc> looks like that's it
11:41:20 <hpc> since ours were exactly one line different
11:41:41 <dmwit> If you're super curious, you could consult the source to know for sure...
11:41:51 <hpc> 7 lines shrunk would be 5 lines plus "type @more" which is 6
11:42:02 <hpc> then @more followed by the two more lines, 9
11:42:07 <ongy> pi looks so random there
11:42:39 <hpc> and i guess that one line is deemed not worth the extra nonsense
11:42:39 <dmwit> hpc: If you are eventually going to demand all the lines, it is never economical to replace some lines with "say @more to get the rest".
11:43:04 <hpc> dmwit: yeah, it's a ratio thing
11:43:06 <dmwit> ongy: pi fits with sin, cos, tan nicely
11:43:11 <hpc> or it's just arbitrary, who knows
11:43:13 <ongy> how long does it keep state?
11:43:15 <ongy> @more
11:43:15 <lambdabot>     sinh, cosh, tanh    :: a -> a
11:43:15 <lambdabot>     asinh, acosh, atanh :: a -> a
11:43:15 <lambdabot>     (**), logBase       :: a -> a -> a
11:43:16 <maerwald> lambdabot is a liar, don't trust him :P
11:43:24 <ongy> I guess until the next usage
11:43:32 <APic> Uh oh.
11:44:22 <hpc> dmwit: that cutoff makes sense if you assume @more is typed 50% of the time
11:44:26 <hpc> if my math is right
11:47:04 <nak> dmit re: (-5) vs (- 5) is some of this a matter of preference ?
11:47:36 <nak> since "-" is a function here, obviously (f5) would not be equal to (f 5) since f5 is just a function name, not f applied to 5
11:48:04 <dmwit> nak: No performance implications, just a matter of syntax.
11:48:22 <nak> haskell is able to understand (-5) as (- 5) probably because function names cannot begin with "-", right ?
11:48:26 <dmwit> nak: There is the infix function `-` for subtraction, and the prefix function `-` for negation, and there needs to be a syntactic way to distinguish between them.
11:48:41 <dmwit> nak: So the implementors chose a tradeoff there.
11:48:48 <hpc> nak: subtraction is a wart in the language syntax
11:48:59 <dmwit> nak: There's a special case in the syntax of the language (hence in the parser) to deal with `-`.
11:49:00 <hpc> (-5) parses the same as (- 5), both are negative 5
11:49:17 <hpc> if you want a flipped section of (-) like that, use subtract
11:49:23 <hpc> > subtract 5 28
11:49:25 <lambdabot>  23
11:49:45 <cocreature> what exactly is the difference between 'x and lookupValueName "x" in TH? I tried deciphering the docs but I’m still not sure what the difference is supposed to be
11:49:47 <nak> well, where i was going with this is, could we define our own `-` or any symbol-named functions if we wanted ?
11:49:50 <hpc> the reason is that '-' is both a unary negation and binary subtraction
11:49:58 <dmwit> nak: `foo-bar` applies the subtraction function to `foo` and `bar`; `foo(-bar)` applies `foo` to the application of the negation function to `bar`.
11:50:13 <dmwit> nak: Yes, you can define your own infix functions.
11:50:14 <hpc> currying and sections make it impossible to lexically distinguish between the two as you could in other languages
11:50:33 <dmwit> > let f * x = "hi " ++ x in 3 * "nak"
11:50:34 <lambdabot>  "hi nak"
11:51:00 <dmwit> > let f - x = "hi " ++ x in 3 - "nak"
11:51:01 <lambdabot>  "hi nak"
11:51:13 <dmwit> I don't think you can redefine the prefix version of `-`, though.
11:51:17 <nak> can we create an prefix definitino for a function of that same name now ?
11:51:21 <dmwit> > let -x = "nak" in -3
11:51:23 <lambdabot>  <hint>:1:5: Parse error in pattern: - x
11:51:28 <hpc> yeah, you can't
11:51:29 <ongy> > uncurry (-) (1,2)
11:51:31 <lambdabot>  -1
11:51:38 <hpc> it's sugar for negate
11:51:39 <hpc> :t negate
11:51:40 <lambdabot> Num a => a -> a
11:51:45 <hpc> which you /can/ redefine
11:52:00 <hpc> @let instance Num Bool where negate = not
11:52:01 <lambdabot>  .L.hs:187:10: Warning:
11:52:02 <lambdabot>      No explicit implementation for
11:52:02 <lambdabot>        ‘+’, ‘*’, ‘abs’, ‘signum’, and ‘fromInteger’
11:52:16 <dmwit> ?quote dmwit instance Num Bool
11:52:16 <lambdabot> dmwit says: ?let instance Num Bool where (+) = (/=); (*) = (&&); negate = id; abs = id; signum = id; fromInteger = odd
11:52:28 <hpc> oh nice
11:52:32 <hpc> ?let instance Num Bool where (+) = (/=); (*) = (&&); negate = id; abs = id; signum = id; fromInteger = odd
11:52:34 <lambdabot>  Defined.
11:52:36 <hpc> > (- False)
11:52:38 <lambdabot>  False
11:52:49 <hpc> oh, because it's id there
11:52:52 <dmwit> > (-0) `mod` 2
11:52:53 <lambdabot>  0
11:52:54 <ongy> dmwit: netagte=id? sounds weird
11:52:55 <dmwit> > (-1) `mod` 2
11:52:57 <lambdabot>  1
11:53:11 <dmwit> ongy: think Word1
11:53:49 <nak> > let x % y = x `mod` y in 5 % 3
11:53:51 <lambdabot>  2
11:53:59 <dmwit> > let f x = (-x) `mod` 2 in map f [0,1]
11:54:00 <lambdabot>  [0,1]
11:54:03 <ongy> dmwit: word1?
11:54:07 <hpc> nak: but yeah, there's a non-zero amount of "syntax" in haskell that you can manipulate, it just doesn't end up looking like syntactic manipulation
11:54:12 <dmwit> ongy: Two's-complement one-bit numbers.
11:54:19 <hpc> do-notation is another one
11:54:40 <hpc> also Enum, numeric literals in general
11:54:44 <hpc> > 5 :: Bool
11:54:46 <lambdabot>  True
11:54:58 <dmwit> ongy: Or, to say it another way: the nice thing about `negate = id` is that `x + negate x = 0`.
11:55:01 <hpc> probably a couple of others i am forgetting
11:55:18 <ongy> dmwit: ah, that makes sense
11:55:36 <hpc> a lot of those things that would normally be syntax are actually regular functions
11:55:40 <hpc> :t (<)
11:55:41 <lambdabot> Ord a => a -> a -> Bool
11:55:57 <hpc> or they get translated to functions during compilation
11:56:03 <ongy> "normally"
11:56:07 <hpc> like [x..] being enumFrom x
11:56:11 <dmwit> ongy: Or, to say it yet another way, we associate `False` with `0` and `True` with `1`. Now, with only the numbers `0` and `1` available, what should `negate 1` be? Surely not `0`...
11:57:33 <hpc> for the most part it's very principled, but if you are feeling particularly heinous you can use the RebindableSyntax extension and write your own ridiculous fromInteger or whatever
11:58:14 <nak> > let x % y = x `mod` y in (%) 5 3
11:58:16 <lambdabot>  2
11:58:19 <nak> ahhhh
11:58:19 <nak> ok
11:58:22 <nak> now i get it
11:58:59 <ongy> dmwit: I understood the Word1, it just didn't parse (I'm used to Z2 for that). negate on Bool feels wrong, but makes sense for that
11:59:55 <geekosaur> it is "wrong", but it's required for Num
12:00:38 <hpc> > True - True
12:00:40 <lambdabot>  False
12:02:17 <dmwit> :t div
12:02:18 <lambdabot> Integral a => a -> a -> a
12:02:20 <dmwit> :i Integral
12:02:25 <dmwit> ?src Integral
12:02:26 <lambdabot> class (Real a, Enum a) => Integral a where
12:02:26 <lambdabot>     quot, rem, div, mod :: a -> a -> a
12:02:26 <lambdabot>     quotRem, divMod     :: a -> a -> (a, a)
12:02:26 <lambdabot>     toInteger           :: a -> Integer
12:02:41 * hackagebot haskell-src-exts-simple 1.18.0.1.1 - A simplified view on the haskell-src-exts AST  https://hackage.haskell.org/package/haskell-src-exts-simple-1.18.0.1.1 (BertramFelgenhauer)
12:02:49 <dmwit> ongy: Your comment about Z2 makes me think I should define an Integral instance, too. =P
12:03:21 <ongy> hm
12:03:29 <ongy> > [False..True]
12:03:31 <lambdabot>  Not in scope: ‘False..’    A section must be enclosed in parentheses thus: (...
12:04:03 <dmwit> div = id; mod = const False; toInteger = toInteger . fromEnum
12:04:07 <dmwit> > [False .. True]
12:04:09 <lambdabot>  [False,True]
12:04:23 <dmwit> ongy: `False..` parses as the `.` function from the `False` module
12:04:34 <dmwit> > f Prelude.. g $ x
12:04:36 <lambdabot>      Could not deduce (Show b0) arising from a use of ‘f’
12:04:36 <lambdabot>      from the context (FromExpr c)
12:04:36 <lambdabot>        bound by the inferred type of it :: FromExpr c => c
12:04:39 <dmwit> > f Prelude.. g $ x :: Expr
12:04:40 <lambdabot>      No instance for (Show b0) arising from a use of ‘f’
12:04:40 <lambdabot>      The type variable ‘b0’ is ambiguous
12:04:40 <lambdabot>      Note: there are several potential instances:
12:04:51 <ongy> > f . g
12:04:53 <lambdabot>      Could not deduce (Show b0) arising from a use of ‘f’
12:04:53 <lambdabot>      from the context (Show a, FromExpr c)
12:04:53 <lambdabot>        bound by the inferred type of it :: (Show a, FromExpr c) => a -> c
12:04:54 <dmwit> > (f Prelude.. g $ x) :: Expr
12:04:55 <lambdabot>      No instance for (Show b0) arising from a use of ‘f’
12:04:56 <lambdabot>      The type variable ‘b0’ is ambiguous
12:04:56 <lambdabot>      Note: there are several potential instances:
12:05:00 <dmwit> ...huh
12:05:05 <ongy> > f $ g x
12:05:06 <lambdabot>      Could not deduce (Show r0) arising from a use of ‘f’
12:05:07 <lambdabot>      from the context (FromExpr t)
12:05:07 <lambdabot>        bound by the inferred type of it :: FromExpr t => t
12:05:09 <dmwit> Anyway I think I've demonstrated what I wanted to demonstrate.
12:05:19 <ongy> I guess
12:05:24 <dmwit> > (f :: Expr -> Expr) Prelude.. g $ x
12:05:26 <lambdabot>  f (g x)
12:09:10 <ecro> Is there any principled reason that GHC can't automatically discharge the `Show` constarint here? http://lpaste.net/174458
12:10:22 <ongy> ecro: discharge?
12:11:31 <shapr> ctag: oh hai!
12:11:38 <ctag> o/
12:11:44 <moodee> ?
12:12:26 <shapr> howdy moodee, how's code?
12:12:32 <ecro> If I do `foo :: Int -> String; foo = show`, I don't have to say `Show Int` because GHC knows that `Int` has `Show`. It seems like it also ought to be able to know that `Qux m` has `Show`
12:13:33 <ongy> ecro: where is Qux defined?
12:13:59 <ecro> In the lpaste: http://lpaste.net/174458
12:15:51 <joe9> Text.JSON seems to have less boilerplate than aeson. Is it recommended over haskell?
12:15:56 <joe9> s/haskell/aeson/?
12:26:37 <tippenein> anyone have a successful large project built on circle ci?
12:26:58 <tippenein> I think the task is hitting some limit, but now sure
12:26:59 <tippenein> https://circleci.com/gh/tippenein/hasken/5
12:30:53 <nak> is there a way i can have ghci automatically reload somemodule if somemodule.hs is updated ? 
12:31:17 <monochrom> no, but I just keep entering ":reload"
12:31:31 <nak> ok that's easy enough
12:31:35 <ongy> tippenein: it looks like a linker issue to me, but I am not sure what triggered it
12:31:39 <nak> looks like i can use ":r" for short
12:31:40 <nak> nice
12:32:04 <tippenein> ongy: it builds locally, so I just assume it's hitting some arbitrary limit
12:32:08 <monochrom> I use emacs haskell-mode, so it's a C-c C-r
12:32:33 <tippenein> I used begriff's sample as a place to start https://github.com/begriffs/haskell-circle-example
12:32:48 <monochrom> the real thorny question is if my new code has an error, can ghci roll back to the old one?
12:32:53 <geekosaur> I'd check Cabal library versions
12:33:09 <ongy> cabal tends to build in /tmp which hits my ram limit (/tmp is ramdisk for me) but I don't know about those containers
12:33:15 <monochrom> and the thorny answer is no, but some people emulate it by keeping two ghci sessions
12:33:49 <tippenein> geekosaur: am I wrong in assuming stack takes care of that?
12:33:53 <monochrom> the database people would be laughing at us "you are reinventing two-phase commit"
12:35:00 <geekosaur> I am seeing object files being linked twice, which is going to involve one of (in descending order of likelihood): Cabal lib, stack, ghc
12:35:29 <geekosaur> and would be a *weird* thing to get from running out of resources, since doubling the need for said resources is not exactly the right response
12:36:34 <geekosaur> (...and wouldn't likely be a response anyway, if ghc ran out of resources while building the linker command line it wouldn't even run the linker, not run it with a doubled file list)
12:36:48 <nak> lol my `ld` procedure took 33 seconds to find the lowest common denominator for 12409543
12:36:55 <jakeehrlich> The following command "/Users/jakeehrlich/FFITest/minisat/*.so" returns "/Users/jakeehrlich/FFITest/minisat/minisat.so" on my computer
12:37:35 <jakeehrlich> *but* "ghci -lminisat  -L/Users/jakeehrlich/FFITest/minisat/ src/Lib.hs" says that it ca't find minisat
12:37:37 <geekosaur> (why are you using .so extension on os x?)
12:37:53 <geekosaur> the shared object file extension on OS X is .dylib
12:38:08 <jakeehrlich> because that's what happens when I ask for a shared library from g++?
12:38:21 <geekosaur> that sounds highly broken and suspicious to me
12:38:25 <jakeehrlich> also ghci doesn't search for a .dylib
12:38:55 <jakeehrlich> I get "user specified .o/.so/.DLL could not be loaded (dlopen(libminisat.dylib, 5): image not found)" from ghci
12:39:44 <geekosaur> libminisat.dylib would be the filename there
12:40:14 <jakeehrlich> ah well first off I havn't prefixed it with lib so that might be an issue
12:40:18 <geekosaur> did you forget that -lFOO looks for libFOO.dylib?
12:40:24 <jakeehrlich> yea
12:40:28 <jakeehrlich> let me try that
12:43:29 <jakeehrlich> bam! everything works!
12:43:50 <jakeehrlich> actully I had a few bugs in my ffi but the primary issue was the lib thing
12:44:05 <jakeehrlich> I'm going to read up on .dylib vs .so thing now
12:46:28 <jakeehrlich> ok so it seems that I need the dylib thing as well. outputting as .so is wrong
12:47:07 <nak> can you use `let` to assign multiple vars on the same line ?
12:47:18 <nak> i'm trying to write an example to share here with lambdabot
12:47:20 <jakeehrlich> let (x, y, z) = (10, 20, 30)
12:47:25 <nak> oh
12:47:45 <jakeehrlich> not exactly what you're looking for but I bet it solves your issue
12:48:04 <nak> can procedure guards be written on one line too ?
12:48:07 <jakeehrlich> really just exploiting pattern matching to get the effect that you want
12:48:39 <jakeehrlich> I don't know that. Syntax seems like it should be valid
12:48:45 <nak> ok i'll try
12:49:02 <geekosaur> or let {x = 10; y = 20; z = 30}
12:49:15 <jakeehrlich> there, a better solution ^
12:49:19 <nak> money money
12:49:36 <geekosaur> whether the braces are needed or not depends on the context; in a do block, for example, you need to tell it where the let ends and the do resumes
12:49:36 <nak> geekosaur now put a recursive function in there
12:50:05 <geekosaur> should work fine. it's just the single line version of layout
12:50:20 <geekosaur> layout even gets translated to braces and semicolons
12:51:05 <monochrom> always put in more braces
12:51:14 <monochrom> and more semicolons
12:51:29 <monochrom> > let {{{ ;;;;; }}} in ()
12:51:31 <lambdabot>  <hint>:1:6: parse error on input ‘{’
12:51:37 <monochrom> oops
12:52:24 <geekosaur> also for example: let x :: Int -> String; x = {- whatever here -}
13:02:26 <dmwit> > let f x | x == 0 = 3 | x == 1 = 4 | otherwise = g x; g x = f (x`div`2) in f 37 -- recursive definition and single-line guards
13:02:27 <lambdabot>  4
13:05:38 <Athas> I must admit, I'm really impressed with how GHC 8 handles variables not in scope.
13:06:12 <nak> does anyone here have a killer technique for preparing raw octopus ?
13:06:26 <nak> (like how to gut it and cook it so it turns out good)
13:06:31 <hpc> that's off topic here
13:06:50 <monochrom> wait, you cook it and then it's still raw?
13:07:17 <nak> monochrom i mean like how to bring it from raw to cooked in a good way
13:07:20 <nak> but sorry, hpc is right
13:07:22 <nak> it's off topic
13:10:24 <fr33domlover> nak, my advice is: if they're still alive, return to nature. If not, bury under a tree and never do that again... forgiveness can still be attained though by saving some other octopus from death
13:18:37 <nak> well i cannot save everything from death, fr33domlover. i feel just as guilty eating spinach or lentils as i do eating octopus or chicken eggs
13:19:09 <muesli4> nak: Except that an octopus actually has a brain.
13:19:41 <hpc> take this to -blah
13:22:46 <jakeehrlich> did I stumble into a conversation on ethical veganism? or is this a euphemistic joke about doing bad things in Haskell?
13:23:18 <c_wraith> hmm. what's a good way to do back-propagation of MCTS results? 
13:23:49 <fr33domlover> nak, eating fruit of a plant or seeds that come out of the fruit, doesn't kill the plant... it's actually one of the ways a plant brings animals to eat, leave their faeces there and thus feed the plant back... that's cooperation. Hw is that the same as murder of an animal for pleasure
13:24:03 <srhb> fr33domlover: This is off topic.
13:24:30 <fr33domlover> srhb, true... sorry, felt a duty to give that answer... excuse me
13:24:38 <c_wraith> I'm tempted to just use an IORef or something so that I don't need to continually rebuild a tree matching the game tree. 
13:25:17 <c_wraith> I guess on the plus side, that would allow for easily making the search concurrent. 
13:25:38 <nak> fr33domlover i'm in -blah if you want
13:26:46 <fr33domlover> jakeehrlich, yes you did, it wasn't a joke :P
13:26:56 <fr33domlover> anyway indeed offtopic, won't continue here
13:27:22 <hpc> c_wraith: that operation doesn't change the structure of the tree does it?
13:27:34 <hpc> c_wraith: maybe have an IORef just around the weight of each node
13:27:44 <hpc> and the shape of it itself is immutable
13:28:10 <c_wraith> hpc, yes, that's what I was thinking of using the IORef for. 
13:28:39 <c_wraith> I was just wondering if there was a pure structure suites for that kind of use. 
13:28:55 <c_wraith> *suited
13:30:38 <hpc> can't think of anything offhand
13:33:14 <jakeehrlich> ok so I want to write a finalizer for a ForeignPtr in Haskell. Seems like there should be a way to convert a haskell function to a FunPtr
13:34:02 <monochrom> yes there is
13:34:35 <jakeehrlich> which is what? I can't seem to find it
13:36:37 <monochrom> it is a fairly long story. you will have to read a good FFI explanation on "dynamic wrapper" aka "foreign import ccall "wrapper""
13:37:36 <monochrom> For every Haskell function type, you need to do that once for a converter tailored for that type.
13:38:24 <monochrom> If you can't find a good explanation, the one I find good is the Haskell 2010 Report itself
13:38:47 <monochrom> I don't know of any better one.
13:41:55 <monochrom> one day I may write one. but you need to give me money to make it happen earlier.
13:42:43 <monochrom> because otherwise I may prefer to write something more useless earlier, such as denotational semantics.
13:43:25 <maerwald> wow, so cool
13:44:10 <jakeehrlich> welp...this project of mine keeps getting more and more complicated
13:44:19 <monochrom> All projects do.
13:44:38 <Zemyla> Hmm. Would the package for a MinesweeperT monad transformer be stored in Game.Minesweeper or Control.Monad.Minesweeper?
13:44:55 <monochrom> This is why I recommend against "learn haskell by doing a project". It always drowns you. Always.
13:45:12 <hpc> it depends on the project
13:45:47 <monochrom> And the beginner knows perfectly which projects are suitable, right.
13:45:59 <hpc> yeah, that's definitely an issue
13:46:14 <monochrom> Clearly, the Dunning-Kruger effect implies that they always chooses the wrong projects. Always.
13:46:56 <Zemyla> Well, it wouldn't be an actual playable game in and of itself, just a monad transformer that would handle Minesweeper-specific actions.
13:48:16 <hpc> an ideal project is something broad and adjustable with a low initial barrier to entry
13:48:16 <c_wraith> why would that be a transformer? 
13:48:27 <Zemyla> It would maintain the board state, allow viewing and clicking squares, and quit on error or on victory.
13:48:44 <c_wraith> but.. why is it a transformer? 
13:48:48 <Zemyla> And it'd be a transformer so it could be run in IO and a player could play it.
13:49:08 <hpc> an irc bot is close to perfect, the issues being you have a fairly tiny space for output and the initial connecting to a server can be a real piece of work
13:49:09 <c_wraith> why isn't it just a state and a set of functions for modifying it?
13:49:43 <c_wraith> then someone could use State or StateT if they wanted, but they aren't forced to. 
13:49:49 <mniip> I wrote a threaded IRC bot once
13:49:51 <mniip> it wasn't fun
13:49:59 <TheMG> is there a way to turn a function that has inexhaustive patterns into one that returns Maybe?
13:50:02 <Zemyla> c_wraith: Because this way, it prevents cheating.
13:50:07 <hpc> my currently running bot is self-modifying perl
13:50:07 <mniip> I'm still not sure there aren't any combinations of timings that will make it deadlock
13:50:31 <c_wraith> TheMG, yes, sorta, but it's dirty. 
13:50:44 <TheMG> c_wraith: go on?
13:50:49 <c_wraith> TheMG, see the spoon package on hackage 
13:50:59 <hpc> mniip: you were using MVars extensively, i take it?
13:51:05 <mniip> hpc, the fun part is having a thread for the write end and a thread of the read end of the socket
13:51:15 <mniip> no I was using python
13:51:19 <hpc> ah
13:51:31 <Zemyla> I mean, I would also expose functions for creating and maintaining a board, but a value of type MinesweeperT m wouldn't be able to inspect the hidden board state.
13:51:39 <monochrom> you need to go self-modifying python :)
13:51:40 <c_wraith> @hackage spoon
13:51:40 <lambdabot> http://hackage.haskell.org/package/spoon
13:51:46 <mniip> monochrom, oh it was
13:51:52 <mniip> it was able to reload parts of itself
13:51:55 <mniip> hpc, the error handling in those two threads is a piece of art
13:52:05 <dmwit> ?unmtl ExceptT e (Writer w) a
13:52:05 <lambdabot> ExceptT e (Writer w) a
13:52:12 <dmwit> ?unmtl EitherT e (Writer w) a
13:52:12 <lambdabot> EitherT e (Writer w) a
13:52:20 <TheMG> c_wraith: thanks
13:52:21 <mniip> when an error occurs you try to acquire a lock, and if you fail it means the other thread already reported an error
13:52:29 <monochrom> hmm what does unmtl know? :)
13:52:32 <mniip> then if you were successful you set an event that the other thread will see and terminate
13:52:47 <Zemyla> dmwit: I think it's ExceptT.
13:52:47 * hackagebot liquid 0.1.0.1 - Liquid template language library  https://hackage.haskell.org/package/liquid-0.1.0.1 (james_rth)
13:52:56 <mniip> and the thread that terminates upon seeing an event triggers a reconnection sequence
13:53:03 <Zemyla> ?unmtl ExceptT e (Writer w) a
13:53:03 <lambdabot> ExceptT e (Writer w) a
13:53:19 <Zemyla> @unmtl ExceptT e (Writer w) a
13:53:19 <lambdabot> ExceptT e (Writer w) a
13:53:24 <Zemyla> Okay then.
13:53:34 <monochrom> Oh God, acquiring a lock for error handling. I can see how it's evil.
13:53:37 <glguy> (w, Either e a)
13:55:05 <dmwit> Zemyla: Turns out the correct incantation is ErrorT. I played around with it in privmsg.
13:55:40 <dmwit> It probably wouldn't be hard to teach ?unmtl about ExceptT as well.
13:56:10 <hpc> newtype ExceptT e m a = ExceptT (m (Either e a))
13:56:49 <hpc> so they're exactly the same
13:58:01 <implementation> three names for the same type ;_;
14:00:53 <monochrom> I'm thinking their instance code and assumptions are a bit different, it's why one of them is deprecated.
14:01:03 <hpc> implementation: relevant to your nickname, IO, ST, and STM are all three names for the same type :D
14:01:37 <hpc> (well, forall s. ST s)
14:02:22 <monochrom> you have a slippery slope that concludes you that binary heap and binary search tree are the same.
14:02:27 <implementation> STM? really? i always thought STM kept a list of recent operations it needs to undo on failure
14:02:46 <hpc> the type itself is the same State# shennanigans as IO
14:03:30 <hpc> and then it just has a smaller API where you can define atomic and such
14:04:16 <hpc> but yeah, newtype is called "new type" for a reason :P
14:24:57 <jfortti> is active this forum ???
14:27:49 * hackagebot hgeos 0.1.7.1 - Simple Haskell bindings to GEOS C API  https://hackage.haskell.org/package/hgeos-0.1.7.1 (rcook)
14:33:03 <geekosaur> somtimes
14:33:08 <geekosaur> oh, they left
14:33:48 <orion> If you're using a stackage cabal.config file, is it usually unnecessary to specify version constraints in your cabal config file?
14:35:16 <glguy> your package.cabal should define the range of versions that your package supports
14:35:39 <glguy> so someone using a different resolver knows if it is intended to work
14:35:50 <hexagoxel> orion: depends on if all your packages are on stackage.
14:36:06 <hexagoxel> s/packages/package deps/
14:36:16 <Phyx-> and if you only want people using stackage to be able to reliably use your packages
14:37:25 <glguy> resolvers are chosen by the local user, package constraints are chosen by the package developer
14:37:39 <glguy> If you expect to be the only user then it doesn't matter
14:41:37 <orion> I see, thanks.
14:47:50 <orion> Ah, does stackage not work with GHC 8?
14:48:03 <suzu> it does
14:48:05 <orion> "NOTE: Requires GHC 7.10." foo
14:48:13 <suzu> what are you talking about?
14:48:26 <orion> I'm quoting the website.
14:48:39 <suzu> oh. strange. i'm using an lts resolver with ghc 8 and it's running fine.
14:49:02 <orion> I can't build my package with https://www.stackage.org/lts/cabal.config
14:49:14 <glguy> lts-6.* uses GHC 7.10
14:49:20 <glguy> nightly uses GHC 8.0
14:50:08 <suzu> err yes, i'm using the nightly
14:50:10 <suzu> my mistake
14:50:36 <mgsloan> orion: Oh, huh, yeah I guess there's some old text on stackage.org
14:50:42 <glguy> orion: "stackage" isn't a single resolver, it's more of a source of resolvers
14:51:24 <orion> hmm
14:51:40 <orion> The URL for the nightly cabal.config doesn't seem to be easily located.
14:52:09 <glguy> orion: Take the URL for the non-nightly one and change it to nightly
14:52:18 <orion> glguy: That did the trick.
14:55:27 <nineonine> hi there
14:55:33 <nineonine> im trying to get a powerset of a list
14:55:40 <nineonine> im using subsequences
14:56:08 <nineonine> but when i do it with [1..29]
14:56:11 <nineonine> it takes too long
14:56:14 <suzu> yes
14:56:16 <Iceland_jack> The classic "codegolf" is 
14:56:17 <nineonine> is there a way to do it faster ?
14:56:17 <Iceland_jack> > filterM (\_ -> [False, True]) "hello"
14:56:19 <lambdabot>  ["","o","l","lo","l","lo","ll","llo","e","eo","el","elo","el","elo","ell","e...
14:56:25 <suzu> well, no
14:56:33 <suzu> the powerset of a list of length n
14:56:33 <nineonine> yeah i tried filterM version
14:56:36 <suzu> is 2^n to compute
14:56:47 <suzu> > 2^29
14:56:49 <lambdabot>  536870912
14:57:01 <suzu> thats how many sets subsequences is going to make
14:57:03 <suzu> lol
14:57:07 <nineonine> yea good point
14:57:08 <suzu> so that's why it will take you a while
14:57:09 <nineonine> :)
14:57:12 <suzu> :)
14:57:16 <nineonine> ok so what im trying to solve is 
14:57:41 <nineonine> give me a second please
14:57:51 * hackagebot Plot-ho-matic 0.11.0.0 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.11.0.0 (GregHorn)
14:58:20 <nineonine> Find the number of ways that a given integer, X , can be expressed as the sum of the  Nth power of unique, natural numbers.
14:58:41 <nineonine> this is my algorithm
14:58:46 <suzu> and how are you approaching it so far
14:59:02 <nineonine> first im trying to find the biggest Integer
14:59:26 <nineonine> lets say
14:59:30 <nineonine> integer y
14:59:37 <nineonine> so y^n <=  x
14:59:48 <nineonine> then im getting powerset of [1..y]
14:59:55 <nineonine> and then do the filtering
15:00:03 <nineonine> is there a better way ?
15:00:59 <nineonine> sumofpowers :: Int -> Int -> Int
15:01:00 <nineonine> sumofpowers x n = length $ filter ( (==x) . sum . fmap (^n) ) $ subsequences possibleRange
15:01:01 <nineonine>                   where powerSet = filterM ( const [True, False] ) possibleRange
15:01:02 <nineonine>                         possibleRange = takeWhile ( \v -> (v^n) <= x) [1..x]
15:01:18 <nineonine> oops thats an old version
15:01:37 <nineonine> sumofpowers x n = length $ filter ( (==x) . sum . fmap (^n) ) $ subsequences possibleRange where possibleRange = takeWhile ( \v -> (v^n) <= x) [1..x]
15:02:03 <suzu> i'm not sure i understand the problem statement
15:02:10 <suzu> so you have a positive integer X
15:02:17 <suzu> is N also given?
15:02:28 <nineonine> here is the link, i hope you can access it withour registration
15:02:29 <nineonine> https://www.hackerrank.com/challenges/functional-programming-the-sums-of-powers
15:02:32 <suzu> and you want to write X as the sum of some integers each raised to the power of N?
15:03:20 <nineonine> yeah, N and X is given
15:03:46 <kadoban> It's that really common problem where you have to count the number of ways to make change. Except the coins you have are  map (^2) [1..]
15:03:49 <suzu> ahhh
15:03:52 <suzu> i get it
15:04:06 <suzu> so yes we want sums of integers where each integer is raised to n
15:04:14 <suzu> okay, so this is a recursive / dp problem
15:04:21 <kadoban> Oh of unique numbers though, that's slightly different, but not much.
15:04:58 <suzu> so for me to solve this problem
15:05:05 <suzu> the first thing i'm thinking of is a function that works like this
15:05:07 <mniip> total x n = go 1 x n where go m 0 n = 1; go m x n | m^n > x = 0; go m x n = go m (x - m^n) n + go (m + 1) x n
15:05:16 <mniip> but that is going to be horribly inefficient I believe
15:05:40 <mniip> like you can save a lot of computation for a large n
15:05:47 <suzu> you have a function called 'magic' or something, that takes in n and x and a set s
15:05:54 <suzu> that set s is all the numbers you can use
15:06:01 <suzu> so it starts as [1..x]
15:06:04 <mniip> oh
15:06:08 <mniip> unique natural numbers
15:06:14 <mniip> total x n = go 1 x n where go m 0 n = 1; go m x n | m^n > x = 0; go m x n = go (m + 1) (x - m^n) n + go (m + 1) x n
15:06:18 <kadoban> Yeah, unique.
15:06:23 <mniip> less inefficient
15:06:45 <nineonine> wow 
15:07:06 <mniip> @let countsums x n = go 1 x n where go m 0 n = 1; go m x n | m^n > x = 0; go m x n = go (m + 1) (x - m^n) n + go (m + 1) x n
15:07:07 <lambdabot>  Defined.
15:07:11 <mniip> > countsums 100
15:07:13 <lambdabot>  <Integer -> Integer>
15:07:21 <mniip> > countsums 100 3
15:07:22 <lambdabot>  1
15:07:27 <mniip> > countsums 100 2
15:07:29 <lambdabot>  3
15:07:30 <nineonine> im only hitting runtime error with 800 2
15:07:39 <mniip> I think that means it works
15:07:39 <nineonine> but that version works so fast
15:07:57 <nineonine> yeah i checked it in ghci
15:07:59 <suzu> for each number in s, compute how to make X - s^n with the set s with that one number removed
15:08:00 <nineonine> awesome !
15:08:14 <mniip> suzu, "for each"
15:08:23 <suzu> yes, for each
15:08:32 <suzu> then you memoize the thing
15:08:33 <mniip> you're going to get solutions for (1, 2) and (2, 1)
15:08:35 <mniip> counted twice
15:08:43 <suzu> ah damn
15:08:45 <suzu> you are right
15:08:46 <mniip> just pick the least number
15:08:51 <suzu> yeah use an ordering
15:08:54 <mniip> at which point your set is really a range
15:08:58 <mniip> i.e see my implementation
15:09:03 <suzu> i dont understand your implementation
15:09:08 <suzu> it looks like magic
15:09:10 <suzu> could you explain it?
15:09:20 <jchia_> According to https://wiki.haskell.org/GHC/Memory_Footprint, on a 64-bit machine, Int8 takes as much memory as Int and Int64. So, what's a good reason to bother using Int8, Int16 or Int32 instead of just Int or Int64?
15:09:21 <nineonine> yeah
15:09:23 <nineonine> please do
15:09:26 <nineonine> explain it
15:09:38 <mniip> go m x n -- count how in how many ways x can be partitioned using nth powers of numbers that are at least m
15:09:49 <suzu> ah m is your floor
15:09:51 <suzu> ok
15:10:37 <suzu> go m x n = go (m + 1) (x - m^n) n + go (m + 1) x n
15:10:53 <suzu> this is a choice between using m^n and not?
15:10:56 <mniip> yes
15:11:02 <suzu> okay
15:11:05 <suzu> this is genius
15:11:07 <suzu> how did you write this in 10s
15:11:11 <mniip> not really
15:11:15 <mniip> simple induction
15:11:17 <mniip> er
15:11:31 <mniip> yes, that's what it is
15:11:35 <suzu> man i need alg practice
15:11:42 <mniip> me too :(
15:11:45 <suzu> liar
15:11:48 <suzu> gtfo
15:11:49 <suzu> you're already a wizard
15:11:54 <nineonine> amazing !!!!
15:11:58 <nineonine> thanks guys
15:12:17 <nineonine> gonna give it a good thought now
15:12:18 <nineonine> haha
15:13:02 <mniip> suzu, but I can't even find strongly connected components on a graph in O(N)
15:13:20 <suzu> eh nor can i
15:13:32 <suzu> there's some tarjan thing
15:13:36 <suzu> and that's all i know
15:14:00 <suzu> also i think there's some DFS based solution too
15:14:18 <mniip> I failed miserably on google code jam
15:14:46 <nineonine> so this thing is fast because we are using accumulating parameter here right ?
15:14:49 <suzu> i never tried
15:14:53 <suzu> never been all about that algorithm contest life
15:15:00 <mniip> neither have I
15:15:02 <suzu> it seems to have not a lot in common with making cool shit
15:15:15 <suzu> which i prefer
15:15:24 <suzu> so i never could really get into it except for like job interviews and stuff
15:15:27 <suzu> :/
15:15:44 <nineonine> i read about it on wiki but im still uncomfortable with it
15:15:54 <suzu> practice!
15:16:07 <nineonine> yeah thats what im trying to do here :)
15:16:11 <suzu> good shit
15:17:29 <mniip> nineonine, it is fast because we aren't generating unnecessary lists
15:17:33 <mniip> we're just counting the ways
15:17:35 <jakeehrlich> @geekosaur, @glguy: using interleaved IO inside unsafe IO worked. I forgot the other guy's name somthing starting with 's' and had a 'j' in it?
15:17:36 <lambdabot> Unknown command, try @list
15:17:39 <mniip> we're not interested in what the ways are
15:17:46 <mniip> also we're not leaking any thunks
15:17:56 <jakeehrlich> geekosaur & glguy: using interleaved IO inside unsafe IO worked. I forgot the other guy's name somthing starting with 's' and had a 'j' in it?
15:18:09 <mniip> every evaluation of 'go' forces the n thunk and then shortly thereafter the x and m thunks
15:18:35 <nineonine> o_0
15:19:01 <suzu> it needs to read `n` to figure out what to do so `n` is forced?
15:19:24 <suzu> i figured this was more efficient because we are not computing the powerset of the ocean, among other things
15:19:27 <mniip> the first equation checks if n is zero
15:21:06 <mniip> compare with e.g 'length [] = 0; length (_:xs) = 1 + length xs'
15:21:15 <mniip> which is terrible in terms of thunk consumption
15:29:53 <cschneid_> do any of conduit or similar streaming libs have windowing functions built in? 
15:32:04 <suzu> what is a windowing function?
15:32:31 <cschneid_> [1,2,3,4] -> [1,2], [2,3], [3,4] then -> "avg each sublist" 
15:32:49 <cschneid_> that's the lower level idea, higher level you'd say: "90 element rolling mean" or similar
15:33:43 <suzu> ah okay
15:33:51 <suzu> you want to collect some of that data up together before processing
15:33:54 <suzu> based on some
15:33:56 <suzu> criteria
15:33:58 <suzu> i guess
15:34:01 <suzu> yes conduit can do that
15:34:02 <Iceland_jack> > [ (a, b) | a:b:_ <- tails "hello" ]
15:34:03 <cschneid_> yeah, typically in a rolling fashion. 
15:34:04 <lambdabot>  [('h','e'),('e','l'),('l','l'),('l','o')]
15:34:16 <Iceland_jack> > [ (a, b) | a:b:_ <- tails [1,2,3,4] ]
15:34:17 <Iceland_jack> etc.
15:34:18 <lambdabot>  [(1,2),(2,3),(3,4)]
15:34:19 <cschneid_> and against an "infinite" stream. 
15:34:20 <suzu> take a look at https://hackage.haskell.org/package/conduit-combinators
15:35:26 <suzu> it's got drops / filters / folds / few other things
15:35:35 <suzu> takeWhile or takeExactly might be what you're looking for here
15:36:06 <implementation> > let as = [1,2,3,4] in zip as $ tail as
15:36:08 <lambdabot>  [(1,2),(2,3),(3,4)]
15:36:23 <cschneid_> tl;dr - we're building an alerting system, and I'd love to build it in haskell. Just haven't really used the streaming libs beyond simple toys
15:36:30 <implementation> but the `tails` trick looks prettier :)
15:37:14 <suzu> the streaming libs are kinda neat
15:37:18 <suzu> i've only used conduit myself
15:37:28 <suzu> a cookbook or something like that would be a great step forward for the streaming libs
15:37:46 <suzu> ..... i guess i'll get on that, someday.
15:38:12 <dmwit> > scanl (\xs x -> take 2 (x:xs)) [] "abcdefg"
15:38:13 <lambdabot>  ["","a","ba","cb","dc","ed","fe","gf"]
15:38:28 <suzu> cschneid_: could you tell me more about what you're trying to make?
15:38:55 <dmwit> cschneid_: I guess suzu's proposed module includes a `scanl`-alike that could be used in that way.
15:38:59 <cschneid_> an alerting system.  Data in, rules in, data continually streams in, triggers output if/when rules fire
15:39:21 <dmwit> cschneid_: Or implementing it yourself from `await` and `yield` should be relatively easy.
15:39:36 <cschneid_> some awkwardness around dynamically inserting new data feeds, and new rules into a running system.  
15:40:55 <jchia_> How do I efficiently lookup the index of a first occurrence of a value in a Data.Array.IArray? I don't see any function for that. Is it reasonable to linearly scan the assocs return value, or a list of indexes I make, for the first element that matches? How do I make sure the list gets optimized away and doesn't actually get created in memory, given that I'm just scanning it?
15:42:52 <cschneid_> I am still in the design / idea phase. Just want to be sure I don't hit a barrier right away
15:43:13 <kadoban> jchia_: If that needs to be fast, and if you're doing it often, an array is likely not the correct data structure. Which is to say ... either you're worrying about something that doesn't matter (yet, until profiling time), or you're using the wrong data structure.
15:43:52 <jchia_> it's a small array (3-20 elements) but i know the size at compile-time
15:44:26 <jchia_> array has good memory locality. list doesn't but it's more convenient to use
15:45:05 <jchia_> why is array not the correct data structure? what might be more suitable?
15:45:26 <kadoban> jchia_: For 20 elements, unless you're doing it in the world's tightest loop, I simply don't see that mattering at all.
15:45:48 <kadoban> jchia_: Because a linear scan through an array is kind of fugly for a large array. You don't have a large array though, so doesn't matter.
15:47:24 <jchia_> let's say it's a performance-critical loop, because that's the sort of thing i often write and i want to know what to do in that situation. what's something reasonable to do?
15:47:45 <jchia_> i know for a large array i would not be doing a linear search
15:49:41 <suzu> cschneid_: does this need to run in real-time?
15:49:51 <suzu> hard real time or soft real time?
15:49:58 <kadoban> jchia_: I don't understand what exactly the hypothetical is.
15:50:02 <cschneid_> suzu: soft real time.  Data comes in ~1/minute. 
15:50:06 <cschneid_> so human scales of time. 
15:50:20 <cschneid_> needs to scale to large number of concurrent rules running. 
15:50:20 <suzu> if the alarm system doesnt fire for 200ms will people die or something?
15:50:28 <jchia_> i mainly write soft-realtime in C++ in my work and i want to know how to approach that in haskell
15:50:42 <jchia_> GC aside
15:50:50 <cschneid_> nah, we do webapp monitoring. So ... their app may be slower or be down for a minute longer than they like
15:50:54 <suzu> ah ok
15:51:01 <suzu> then sure hs may be the tool for you
15:51:12 <suzu> i would not recommend it for say a car brake system
15:51:19 <suzu> :P
15:51:51 <cschneid_> been drawing out components and such on paper. I'll mock something up over weekend / early next week.  We have a few structures, but once they go, they are setup, wired to input data, and let run.  So I imagine an app that listens for new data / new rules and spawns a thread for each.
15:52:01 <jchia_> kadoban: the hypothetical is that i need to make this search as fast as i can
15:52:16 <cschneid_> who knows if it'll really be what my bosses go for, but it at least seems feasible. 
15:53:13 <suzu> i've never been able to convince my bosses to let me check hs code in
15:53:21 <suzu> which is entirely reasonable tbh
15:53:30 <suzu> it's not the easiest thing to learn or hire for or maintain
15:53:34 <cschneid_> well, I just do stuff, then ask forgiveness. Yay small company
15:53:37 <suzu> from a management pov
15:53:40 <suzu> haha
15:53:57 <cschneid_> there may be reason for us to go after elixir instead though - since elixir / phoenix is growing, and getting experience there is valuable
15:54:20 <cschneid_> but it's Haskell / Elixir / Scala - it's gonna be functional damn it.
15:54:50 <verement> is there a more portable equivalent to System.Posix.Directory.changeWorkingDirectory?
15:56:31 <cschneid_> suzu: thanks, off for weekend :) 
15:56:46 <geekosaur> https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/directory-1.2.6.2/System-Directory.html#v:setCurrentDirectory ?
15:56:51 <suzu> cschneid_: cya
15:57:15 <verement> geekosaur: thanks!
16:02:54 * hackagebot xmlhtml 0.2.3.5 - XML parser and renderer with HTML 5 quirks mode  https://hackage.haskell.org/package/xmlhtml-0.2.3.5 (DougBeardsley)
16:08:01 <plakband> Is there a way to have `ghc-mod find` search through package modules, and not just dependencies?
16:14:38 <suzu> can someone explain how this works:
16:14:41 <suzu> > :t ap
16:14:42 <lambdabot>  <hint>:1:1: parse error on input ‘:’
16:14:46 <suzu> > :type ap
16:14:48 <lambdabot>  <hint>:1:1: parse error on input ‘:’
16:14:57 <suzu> > ap
16:14:59 <lambdabot>      No instance for (Typeable m0)
16:14:59 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
16:14:59 <lambdabot>        arising from a use of ‘show_M844660878333191781823012’
16:15:01 <suzu> err
16:15:03 <dmwit> :t ap
16:15:04 <lambdabot> Monad m => m (a -> b) -> m a -> m b
16:15:10 <suzu> right
16:15:11 <suzu> :t ap
16:15:12 <lambdabot> Monad m => m (a -> b) -> m a -> m b
16:15:14 <suzu> :t zip
16:15:16 <lambdabot> [a] -> [b] -> [(a, b)]
16:15:17 <suzu> :t ap zip
16:15:19 <lambdabot> ([a] -> [b]) -> [a] -> [(a, b)]
16:15:27 <suzu> how did that happen
16:15:33 <dmwit> suzu: Take `m ~ ([a] ->)`.
16:15:53 <suzu> ??
16:16:00 <suzu> what
16:16:43 <suzu> i dont get it.
16:17:00 <dmwit> http://stackoverflow.com/q/29361326/791604
16:17:15 <hpc> (~) is type equality, and (x ->) is an operator section on (->)
16:17:28 <hpc> suzu: so basically it means, m x = [a] -> x
16:18:32 <dmwit> ap :: ([a] -> c -> d) -> ([a] -> c) -> ([a] -> d) -- this is what you get when the monad is ([a] ->)
16:19:51 <dmwit> then pick `c` to be `[b]` and `d` to be `[(a, b)]` and you can see that the type of the first argument is exactly the type of `zip`.
16:19:52 <lpaste> lambdafan pasted “My weakness, regex” at http://lpaste.net/174521
16:20:00 <suzu> my brain is melting
16:20:15 <suzu> let me think about this
16:20:21 <lambdafan> oh yeah, I just tried doing regex in haskell. brain melted.
16:20:38 <dmwit> lambdafan: Don't use a regex for this.
16:20:41 <dmwit> ?hackage cassava
16:20:41 <lambdabot> http://hackage.haskell.org/package/cassava
16:21:25 <lambdafan> dmwit: whew thanks
16:21:34 <suzu> i still don't get it
16:21:39 <suzu> so firstly
16:21:45 <suzu> the first arg of ap is m (a -> b)
16:21:53 <suzu> how is `zip` an m (a -> b)
16:22:38 <suzu> you let m be ([a] ->)..? what about the a -> b in there
16:22:52 <dmwit> suzu: Let's make the first argument of `ap` be `m (c -> d)` instead, to avoid confusion with the `a` and `b` in `zip`'s type. Okay with that change?
16:22:57 <suzu> yes
16:23:27 <dmwit> Okay. So taking `m` to be `([a] ->)`, this makes the first argument of `ap` have type `([a] ->) (c -> d)`.
16:23:34 <dmwit> Which is `[a] -> c -> d`.
16:23:41 <suzu> y..es
16:23:47 <suzu> yup
16:24:01 <dmwit> Further taking `c` to be `[b]`, we have `[a] -> [b] -> d`.
16:24:14 <dmwit> Further taking `d` to be `[(a, b)]`, we have `[a] -> [b] -> [(a, b)]`.
16:24:39 <suzu> how does c become [b]
16:24:42 <dmwit> So the full set of choices is: choose `m ~ ([a] ->)`, choose `c ~ [b]`, and choose `d ~ [(a, b)]`.
16:24:45 <suzu> and how does d become [(a, b)]
16:25:04 <dmwit> `ap` works for *any* choice of `c` and `d`, in particular for the choices `[b]` and `[(a, b)]`.
16:25:19 <suzu> my question is how did those get there though
16:25:25 <dmwit> We picked them.
16:25:31 <dmwit> That's a power we have with polymorphic functions.
16:25:43 <dmwit> We can pick which type to use the polymorphism at.
16:25:50 <dmwit> For example:
16:25:51 <dmwit> :t id
16:25:52 <lambdabot> a -> a
16:25:57 <dmwit> Let's pick `a ~ Int`.
16:26:01 <dmwit> > id (3 :: Int)
16:26:03 <lambdabot>  3
16:26:11 <suzu> right, the a means anything
16:26:16 <dmwit> yes
16:26:19 <dmwit> Same with the type of `ap`.
16:26:26 <dmwit> We can pick anything -- including list types.
16:27:52 <suzu> so, how does the type of zip
16:27:53 <suzu> [a] -> [b] -> [(a, b)]
16:28:01 <suzu> get rewritten as an m ( c -> d)
16:28:17 <suzu> oh hang on
16:28:20 <dmwit> By choosing `m ~ ([a] ->)`, `c ~ [b]`, and `d ~ [(a,b)]`.
16:28:22 <suzu> so the only choice of m here must be [a] -> 
16:28:26 <dmwit> yes
16:28:40 <suzu> and if that's the case, then the inner [b] -> [(a, b)] is directly subbed for c -> d
16:28:42 <suzu> ?
16:28:45 <dmwit> yes
16:28:54 <suzu> and then we can solve out the whole type of ap zip
16:28:59 <dmwit> yes =)
16:29:00 <suzu> okay this is trippy as fuck
16:29:08 <dmwit> yes =D
16:29:20 <suzu> is this proper haskell?
16:29:26 <dmwit> ...sort of.
16:29:28 <suzu> am i supposed to be able to deduce this quickly at some point?
16:29:29 <dmwit> It is at least a popular trick.
16:29:37 <suzu> this is unreadable at first glance imo
16:29:39 <suzu> lol
16:29:46 <dmwit> You will probably be able to deduce this more quickly at some point.
16:30:03 <suzu> well if i could see that [a] -> is a monad immediately then the rest falls into place
16:30:12 <dmwit> Using the function Applicative instance can be handy at times, and you will notice places where it makes sense.
16:30:23 <suzu> i already abuse <$> and <*> a lot but not like this
16:30:25 <suzu> lol
16:30:32 <dmwit> Have you heard the "monads as containers" analogy? `(r ->)` is particularly easy to understand in that analogy.
16:30:40 <suzu> i understand monads
16:30:53 <suzu> i have never seen the (r ->) instance of a monad htough
16:30:54 <kilimanjaro> what's the easiest way to remove *all* ghc packages
16:31:00 <kilimanjaro> removing ghc as well would be fine
16:31:07 <suzu> i will attempt to derive it myself before taking a look
16:31:15 <dmwit> Good idea!
16:31:18 <suzu> :D
16:31:30 <kilimanjaro> i'd basically like my system to look as if i never installed anything related to haskell
16:31:36 <dmwit> kilimanjaro: Assuming you haven't installed anything to  the global database, nuking .ghc should do the trick.
16:31:41 <kilimanjaro> ok
16:32:00 <dmwit> kilimanjaro: If you have installed things in the global database, you will have to ask ghc-pkg where it is, nuke that, and reinstall GHC.
16:32:16 <mheinzel> suzu: It's basically a Reader monad.
16:32:19 <dmwit> "have to"
16:35:44 <dmwit> > liftA2 (+) last length [1,5,4,3]
16:35:46 <lambdabot>  7
16:36:15 <suzu> instance Monad (r ->) where
16:36:18 <suzu>     return = const
16:36:20 <suzu>     (>>=) :: (r -> a) -> (a -> (r -> b)) -> (r -> b)
16:36:22 <suzu>     x >>= y = \d -> y $ d x
16:36:24 <suzu> i think that's right?
16:36:53 <dmwit> Ask GHC if it type-checks. But it doesn't look quite right to me.
16:38:05 <dmwit> > (reverse <> take 5) "hello, world!"
16:38:06 <lambdabot>  "!dlrow ,ollehhello"
16:38:10 <suzu> i can't just load it into ghci, can i? it claims there's a double defn of Monad ((->) r)
16:38:33 <dmwit> Oh, bummer.
16:38:48 <dmwit> Well, you can ask whether your proposed function has the type you claim without naming it `(>>=)`.
16:39:22 <dmwit> > let bind :: (r -> a) -> (a -> (r -> b)) -> (r -> b); bind x y = \d -> y $ d x in ()
16:39:23 <lambdabot>      Couldn't match expected type ‘b’ with actual type ‘r -> b’
16:39:23 <lambdabot>        ‘b’ is a rigid type variable bound by
16:39:23 <lambdabot>            the type signature for bind :: (r -> a) -> (a -> r -> b) -> r -> b
16:39:35 <suzu> ah i think i see my mistake
16:39:41 <suzu> i should have just left it as ((->) r)
16:43:36 <suzu> > let foo x y = \d -> y $ d x
16:43:37 <lambdabot>  <no location info>:
16:43:37 <lambdabot>      not an expression: ‘let foo x y = \d -> y $ d x’
16:43:41 <suzu> > @let foo x y = \d -> y $ d x
16:43:43 <lambdabot>  <hint>:1:1: parse error on input ‘@’
16:43:45 <suzu> wat
16:44:11 <suzu> @let foo x y = \d -> y $ d x
16:44:12 <lambdabot>  Defined.
16:44:16 <suzu> :t foo
16:44:17 <lambdabot> t1 -> (r -> t) -> (t1 -> r) -> t
16:45:38 <suzu> that's not right
16:45:41 <dmwit> no
16:46:02 <dmwit> suzu: Some oddities in your definition: 1. `d` is not a function (hint: `x` *is* a function) 2. `y` takes two arguments, but was only given one
16:46:29 <dmwit> And when I say "not a function" there, I mean "not necessarily a function", of course.
16:47:29 <suzu> @let foo x y = \d -> y (d x) d
16:47:30 <lambdabot>  .L.hs:204:18:
16:47:31 <lambdabot>      Occurs check: cannot construct the infinite type:
16:47:31 <lambdabot>        t1 ~ (t -> r) -> t1
16:47:38 <suzu> oh oh oh
16:47:40 <dmwit> ?undefine
16:47:40 <lambdabot> Undefined.
16:47:40 <suzu> i got it
16:48:41 <suzu> @let foo x y = \d -> y (x d) d
16:48:42 <dmwit> :t let foo x y = \d -> y (d x) d in foo -- this way does not add a spurious binding to lambdabot's environment
16:48:43 <lambdabot>  Defined.
16:48:43 <lambdabot> t2 -> (t1 -> (t2 -> t1) -> t) -> (t2 -> t1) -> t
16:48:54 <dmwit> suzu: Yes, you got it!
16:48:56 <suzu> :t foo
16:48:57 <lambdabot> (t2 -> t1) -> (t1 -> t2 -> t) -> t2 -> t
16:49:02 <suzu> i had d and x swapped rofl.
16:49:13 <suzu> d was just supposed to be a value
16:49:15 <suzu> silly me
16:49:25 <suzu> trying to apply x to d made the type whacko
16:49:29 <suzu> inferred type that is
16:49:30 <dmwit> ?. djinn ty foo
16:49:30 <lambdabot> Plugin `compose' failed with: Unknown command: "ty"
16:49:36 <dmwit> ?. djinn type foo
16:49:37 <lambdabot> f a b c = b (a c) c
16:50:07 <suzu> whats the use of the ((->) r) monad?
16:50:29 <dmwit> suzu: Imagine you have some configuration information that you want to set once, and then have a bunch of actions that all have access to the configuration to decide what to do.
16:50:39 <dmwit> suzu: Choose `r` to be the type of your configuration data.
16:50:59 <dmwit> suzu: Now actions that execute in this monad have access to the configuration, but you don't have to manually pass it around to all the actions.
16:51:40 <suzu> so..... reader
16:51:42 <suzu> !
16:51:46 <dmwit> suzu: This is especially useful in the transformer version, `ReaderT`, which lets you squirrel away such configuration information into whatever other monad you're actually interested in running your actions in.
16:51:49 <suzu> Config -> a
16:52:03 <suzu> is our m a
16:52:08 <dmwit> suzu: Yes, `Reader r a` is isomorphic to `r -> a` (and has a matching instance for `Monad`).
16:52:15 <suzu> m ~ (-> Config)
16:52:17 <dmwit> ?src Reader
16:52:17 <lambdabot> type Reader r = ReaderT r Identity
16:52:17 <lambdabot> --OR
16:52:17 <lambdabot> data Reader r a = Reader { runReader :: r -> a }
16:52:58 <dmwit> suzu: Actually, `m ~ (Config ->)`. But yes.
16:53:11 <suzu> and then follow-up actions are a -> Config -> b?
16:53:29 <suzu> b -> Config -> c?
16:53:31 <suzu> etc?
16:53:41 <suzu> and you string em all together with >>=
16:53:44 <dmwit> If those actions are getting threaded in via `(>>=)`, sure.
16:53:59 <suzu> and you can kick off the whole thing with a return yourconfigdata
16:54:01 <suzu> i see
16:54:15 <dmwit> No, you kick the whole thing off with a `($yourconfigdata)`.
16:54:35 <suzu> that's just a value. i don't need to lift it into a function first?
16:54:39 <suzu> with const / return?
16:55:00 <dmwit> Lifting it into a function would be counterproductive.
16:55:04 <dmwit> It would get you back into the monad.
16:55:08 <dmwit> You want to get *out* of the monad.
16:55:29 <hydraz> nope; you apply the runReader (Reader r a -> r -> a) function to your data to get your result
16:55:37 <suzu> ahh
16:55:41 <suzu> the data is just an argument.
16:55:43 <dmwit> suzu: Recall: your monadic action has type `ConfigData -> a`.
16:55:46 <suzu> because everything is a Config -> a
16:55:46 <hydraz> Yup
16:55:47 <suzu> yup yupypu pyu
16:55:53 <dmwit> suzu: So the way to *use* that action is to just apply it to your configuration data.
16:55:54 <suzu> got it
16:56:43 <suzu> cool.
16:56:46 <suzu> i need to think about this more
16:57:10 <suzu> is it bad practice to be using ScopedTypeVariables?
16:57:20 <suzu> sometimes i forget what the type of a subclause in some statement boils down to :/
16:57:57 * hackagebot acme-http 0.2.3 - fastest Haskell PONG server in the world  https://hackage.haskell.org/package/acme-http-0.2.3 (JeremyShaw)
17:01:04 <koz_> Are there higher-tupled versions of uncurry in any library?
17:01:14 <suzu> :t uncurry
17:01:15 <lambdabot> (a -> b -> c) -> (a, b) -> c
17:01:30 <koz_> So something like (a -> b -> c -> d) -> (a, b, c) -> d
17:01:35 <hydraz> apparetly not
17:01:39 <suzu> hoogle says no
17:01:44 <hydraz> apparently, too
17:01:48 <koz_> Sadface. :(
17:01:54 <koz_> Oh well.
17:02:18 <hydraz> You can just do (\(x, y, z) -> f x y z), and there's prolly a better way to do it I don't know about
17:04:16 <koz_> hydraz: Yeah, I did it that way already.
17:04:35 <koz_> Writing that lets me be clever and use the list applicative to do 'every combination of'-type shenanigans.
17:04:59 <hydraz> oh boy, type shenanigans :P
17:05:16 <koz_> hydraz: In this case, not specifically type shenanigans.
17:05:27 <koz_> More like 'shenanigans of a particular type'.
17:05:37 <koz_> I meant 'Shenanigan a', not 'Shenanigan Type'.
17:06:08 <koz_> Well, 'CombinationOf a => Shenanigan a'.
17:13:42 <shirt> foo :: Foo a => IO a  -- How do I make the foo function do different (IO related) things, based on the type of the return result?
17:15:25 <suzu> based on the type?
17:15:41 <shirt> yeah
17:19:02 <johnw> shirt: you can't, that's actually the point of parametricity :)
17:19:30 <johnw> your caller can access the Foo value, however
17:19:44 <koz_> Double is what I should use if I want a 'general floating-point thing' in Haskell right?
17:19:45 <johnw> so whatever that interface exposes, the behavior can vary; but it can't vary "in IO"
17:19:57 <johnw> since the IO part of your type isn't related to Foo
17:20:10 <johnw> i.e., "which Foo is chosen" is locally hidden from IO in your type
17:21:02 <shirt> johnw: thanks. good to get confirmation that i was going down the wrong path. guess i need to figure out another way to accomplish my task
17:21:30 <johnw> you could upgrade Foo to FooIO a, but I have a feeling that may be the wrong road
17:22:21 <koz_> OK, how do I do an Int divided by an Int to yield Double again?
17:22:36 <koz_> (/) won't work with Ints, obviously...
17:23:04 <Gurkenglas__> :t fromIntegral :: Int -> Double
17:23:05 <lambdabot> Int -> Double
17:24:06 <Gurkenglas__> Perhaps someone should write a Data.Coerce thing to cast numerical values.
17:24:08 <koz_> Gurkenglas__: Thanks!
17:24:49 <Gurkenglas__> (As in, Data.Coerce.Num which would allow you to write "coerceNum (/) :: Int -> Int -> Double")
17:27:59 * hackagebot transient 0.4.2.2 - Making composable programs with multithreading, events and distributed computing  https://hackage.haskell.org/package/transient-0.4.2.2 (AlbertoCorona)
17:28:47 <elco`> Is there any reason, in principle, that GHC couldn't automatically discharge the `Show (Qux m)` constraint here? http://lpaste.net/174458
17:29:19 <jakeehrlich> Does anyone know of a tutorial on custom builds for Cabal/Stack
17:32:11 <pavonia> elco`: What do you mean? The constraint is required for showing the values
17:33:25 <elco`> pavonia: GHC wouldn't require a `Show` like `foo :: Show Int => Int -> String; foo = show`
17:33:54 <elco`> Seems it should be similar here because every value in the closed range of `Qux` has a `Show`
17:34:37 <pavonia> How would you show the Int without a Show Int instance?
17:35:10 <dmj`> pavonia: could pattern match :) 
17:35:43 <pavonia> What?
17:37:00 <elco`> I'm not saying there shouldn't actually be a `Show` instance. Just that you don't have to explicitly remind the compiler in the type signatures that the instance exists
17:38:15 <dmj`> pavonia: f 1 = "1"; f 2 = "2" ... 
17:38:37 <pavonia> elco`: But that would give the false impression that it isn't required at all, e.g. if you export that function
17:38:44 <pavonia> dmj`: Ah ;)
17:40:36 <elco`> No more so than the absence of `Show Int` constraint on `foo :: Int -> String`? The type family is closed.
17:42:07 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org' by ChanServ
17:43:26 <nshepperd> elco`: there's nowhere for a Show dictionary to be passed in 'corge :: SFoo m -> Qux m -> String'
17:44:58 <elco`> nshepperd: How so? What are the rules for where a dictionary can be passed?
17:46:41 <nshepperd> well, I would assume that you can pass a dictionary whenever you have a constraint
17:48:00 <shirt> queryFields (Name, Height) >>= (\(name, height) -> putStrLn name >> print (height > 190))
17:48:01 <shirt> How do I write such a "queryFields" function, so that it can work with a tuple containing any number of fields? What type signature would "queryFields" have?
17:48:31 <nshepperd> you could imagine 'secretly' passing a dictionary somehow, but then 'corge' would have different representation than other functions with 'a -> b -> c' even though they unify, and then you could cause crashes or something
17:54:54 <nshepperd> unlike 'Show Int => Int -> String', the dictionary for 'Show (Qux m)' can't be taken directly from the environment, even though Show Int and Show Double are available, because ghc doesn't know which one is needed
17:55:57 <elco`> yeah, that's what I was thinking. I'll go try looking at the core now. Thanks for the tip 
17:57:43 <nshepperd> elco`: however, note that 'corge sfoo qux = case sfoo of {SBar -> show qux; SBaz -> show qux}' works
17:58:18 <elco`> ooh, very interesting
17:58:31 <nshepperd> there the dictionary is pulled from the environment inside each branch of the case, because the identity of m is known statically there
17:59:51 <nshepperd> in fact, even 'corge sfoo = case sfoo of {SBar -> show; SBaz -> show}' works
18:05:53 <elco`> nice, thanks!
18:09:11 <lpaste> nshepperd annotated “No title” with “Dictionaries” at http://lpaste.net/174458#a174533
19:23:05 * hackagebot expiring-cache-map 0.0.6.0 - General purpose simple caching.  https://hackage.haskell.org/package/expiring-cache-map-0.0.6.0 (elblake)
19:38:06 * hackagebot hw-prim 0.0.3.6 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.0.3.6 (haskellworks)
19:48:07 * hackagebot hw-prim 0.0.3.7 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.0.3.7 (haskellworks)
19:56:50 <lpaste> lambdafan pasted “ViewPatterns Question” at http://lpaste.net/174546
19:58:09 <glguy>       Perhaps you intended to use ScopedTypeVariables
19:59:13 <geekosaur> lambdafan, just turn on ScopedTypeVariables. (the independent extension went away years ago)
19:59:25 <LordBrain> lambdafan, well, it may depend on the version of ghc you use, trying to do that ':' thing... instead you can use BS.uncons :: ByteString -> (Word8,ByteString)
20:01:30 <lambdafan> okay I will give that a try
20:01:49 <LordBrain> add a type signature for processFile too
20:01:58 <lambdafan> oh I have that
20:02:28 <LordBrain> make sure you're using the right 'breakOn'
20:02:35 <LordBrain> i notice you dont have a BS in front of it
20:03:25 <LordBrain> oh data.text, you state that in the post, sorry
20:03:45 <LordBrain> :t Data.Text.breakOn
20:03:46 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text -> (Data.Text.Internal.Text, Data.Text.Internal.Text)
20:03:49 <glguy> lambdafan: breakOn :: Text -> Text -> (Text, Text)
20:03:57 <glguy> so you're not getting a bytestring out of that
20:04:08 <glguy> It's going to look like this: (breakOn ":" -> (h,t))
20:04:22 <LordBrain> you have to convert it using utf8
20:04:48 <glguy> or figure out what it is you're actually trying to do
20:05:30 <glguy> something like Data.ByteString.Char8.break :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
20:05:40 <glguy> might be closer to what you've got going on
20:11:33 <synergistics> Is there a better way to parse for one of many strings in a string than to fold over a list of possible strings with  <|>  ?
20:11:42 <synergistics> (using parsec)
20:13:34 <LordBrain> if its not performance critical or anything, you can often get away with just using a case and pattern matching, leave parsec out.
20:14:41 <LordBrain> i know taht's not your question, but its just an observation i've made... like if you are doing command line parsing or whatever, i think the code actually has a lower barrier of entry and stuff using fewer libraries and keeping it to the basics.
20:15:02 <zort> Hi, I'm trying to parse a fairly large binary format. I don't really know what I'm doing. This is what I've got: http://slexy.org/view/s21xHozEfF It works, but I was hoping I could use "generics" (still not sure what exactly that constitutes) like this guy did so I don't have to write getInt32le <*> getInt32le <*> getInt32le <*> ...: https://github.com/gitfoxi/Stdf/blob/WIP/Data/Stdf/Types.hs The difference in my case is that I
20:15:03 <zort>  have bytestring fields (longest one 4*1622207 bytes). Can I somehow encode that huge length statically in the type?
20:16:15 <lambdafan> how do I convert a Data.Text into a Data.ByteString.Lazy
20:16:33 <synergistics> LordBrain: Well another problem I'm having is figuring out how to parse with user state. I'd like to avoid the complexity of parsec though.
20:16:34 <LordBrain> convert it to bytestring and then use fromChunks
20:16:58 <elco`> If I want a list of packages DBs for a given project, is there a pre-existing library for that? Or is digging around in `ghc-mod` the closest I'll get?
20:17:57 <LordBrain> cabal library i think
20:18:26 <LordBrain> the api tends to fluxuate tho
20:18:26 <elco`> I'd like to support `stack` as well...
20:18:29 <lambdafan> ByteString.pack wants a [Word8] whereas I have a Text
20:18:40 <LordBrain> you will
20:18:52 <elco`> ooh, interesting
20:19:16 <lambdafan> LordBrain: how do I convert a Text to a [Word8] for ByteString.pack?
20:19:33 <geekosaur> do you know the encoding you need?
20:20:06 <lambdafan> OverLoadedStrings seemed to do the right thing with String
20:20:43 <lambdafan> so when I had a foo :: String, doing foo' = foo :: Lazy.ByteString worked
20:20:54 <lambdafan> I supposed I could turn into String
20:20:59 <lambdafan> that seems wrong
20:21:10 <LordBrain> lambdafan, i believe there is a function utf8
20:21:12 <geekosaur> OverloadedStrings only works with constants
20:21:14 <LordBrain> :t utf8
20:21:15 <lambdabot> Not in scope: ‘utf8’
20:21:17 <LordBrain> hmm
20:21:34 <LordBrain> i may misremember its exact title, its in the text package
20:21:44 <elco`> :t decodeUtf8
20:21:45 <lambdabot> Not in scope: ‘decodeUtf8’
20:22:38 <elco`> Pretty sure that's the right name
20:23:58 <LordBrain> its encodeUtf8
20:24:10 <LordBrain> :t Data.Text.Encoding.encodeUtf8
20:24:11 <lambdabot> Data.Text.Internal.Text -> Data.ByteString.Char8.ByteString
20:41:22 <dramforever> Question: How do you close a conduit-extra:Data.Conduit.Network.AppData ?
20:41:47 <dramforever> http://hackage.haskell.org/package/conduit-extra-1.1.13.2/docs/Data-Conduit-Network.html#t:AppData
20:43:13 <dramforever> I've found this, but the documentation is weird: http://hackage.haskell.org/package/streaming-commons-0.1.15.5/docs/Data-Streaming-Network.html#v:appCloseConnection
20:43:45 <dramforever> "Close the underlying connection. One possible use case is simulating connection failures in a test suite." No I just want to close the connection normallu
20:43:49 <dramforever> *normally
20:47:15 <glguy> dramforever: it's not your job to close the connections
20:47:36 <glguy> dramforever: the run function manages that for you when the continuation you provide completes
20:47:48 <dramforever> !
20:48:57 <dramforever> glguy: Thanks a lot for that
20:49:34 <dramforever> Yeah that's a good API design for sure
20:56:49 <monadgona> so i was at a bar last night
20:56:55 <monadgona> and this girl told me she wanted coq
20:57:34 <monadgona> and i was like, it's free open source software distributed under the LGPL
20:57:47 <monadgona> go ahead and download it
20:57:48 <glguy> monadgona: The topic of #haskell is the Haskell programmign language, not inappropriate jokes about proof management systems
20:58:01 <monadgona> :(
21:02:24 <dramforever> monadgona: #haskell-blah may be suitable
21:02:34 <dramforever> Wait are you already gone...
21:02:42 <glguy> He's gone already, but it's best not to direct random visitors to -blah or -offtopic
21:03:12 <dramforever> Got it :)
21:06:03 <jloomis> Can someone help me figure out servant authentication? Where does the tutorial get "c2VydmFudDpzZXJ2ZXI="? http://haskell-servant.readthedocs.io/en/stable/tutorial/Authentication.html
21:08:11 * hackagebot idringen 0.1.0.0 - A project manage tool for Idris.  https://hackage.haskell.org/package/idringen-0.1.0.0 (zjhsdtc)
21:08:40 <dramforever> jlouis: That's base64 for "servant:server" (without quotes)
21:09:21 <dramforever> It's defined by "Authorization: Basic" I think. Googling for "HTTP basic authentication" might help
21:09:53 <jloomis> @dramforever thank you so much! I'm not very well versed in web dev in general.
21:09:54 <lambdabot> Unknown command, try @list
21:10:20 <clarkenciel> has anyone else had performance issues in using haskell for hackerrank exercises?
21:11:26 <clarkenciel> I'm having timeout errors for some of the tests for https://www.hackerrank.com/challenges/circular-array-rotation but when I run locally I have no trouble
21:11:35 <clarkenciel> http://lpaste.net/174565
21:50:29 <bunny67> I'm trying to build liquidhaskell on windows, but it depends on the 'unix' package and fails. Is there any way of using liquidhaskell on windows?
21:51:17 <tnks> aloiscochard: hey, with codex, have you thought much about multi-project stack?
21:51:21 <tnks> curious what's involved.
21:56:09 <geekosaur> bunny67, you can try swapping it for unix-compat, but iirc that isn't very complete
21:57:45 <bunny67> geekosaur: I'll try that, thanks.
21:57:50 <geekosaur> (there isn't a whole lot in the unix package that can be done on windows with significant compatibility, which is why it's in unix instead of a cross-platform package. I'd guess liquidhaskell uses POSIX file and/or process control stuff that might be hard to do properly cross platform
21:59:39 <bunny67> Oh I see, that's unfortunate :(, I'll try unix-compat anyway
22:13:26 <wagle> whats best libraries for processing json?
22:13:36 <wagle> library
22:14:52 <glguy> aeson is the standard library for processing JSON
22:17:37 <wagle> glguy: tx
22:45:20 <wagle> is there a nice way to have a string with a billion "s without having to backquote all of them?
22:51:15 <icicled> anyone here use nix with ghc8 ?
22:51:39 <icicled> I'm interested in what a typical workflow looks like
23:42:43 <wagle> why is ghc not importing the prelude?
23:43:38 <wagle> nm, i cant see
23:54:34 <Phyx-> bunny67: I agree with geekosaur, the unix package is often unneeded.
23:54:58 <Phyx-> bunny67: *But* you should be able use msys2 to build the package.
