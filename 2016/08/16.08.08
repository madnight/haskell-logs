00:04:06 <cocreature> systemfault: I think builtin functions such as (+) are also in whnf if they are applied to too few arguments, e.g. (+) 1
00:04:35 <systemfault> Ha, that would make sense since (+1) is basically \x -> x + 1
00:04:57 <systemfault> Thanks :)
00:04:58 <cocreature> yeah, I just wanted to make clear that there might not be an explicit lambda involved
00:06:11 <opqdonut> actually
00:06:48 <opqdonut> (+) 1 ==> (\x -> \y -> magic) 1 ==> \y -> magic'
00:07:08 <opqdonut> takes a couple of steps to get from (+) 1 to whnf
00:07:30 <opqdonut> or, well, one, expanding the definition isn't really a step
00:07:50 <cocreature> right, but these are not steps visible to the user
00:08:06 <opqdonut> (and (+) isn't a built-in function, it's just a normal one)
00:08:10 <opqdonut> yeah sorry I'm just nitpicking
00:08:18 <cocreature> yeah builtin was a stupid term, I stole that from the haskell wiki
00:09:13 <opqdonut> but theoretically speaking it's important to note that (+) 1 can't be in WHNF because it's an non-constructor function application
00:09:35 <opqdonut> but it is really close to WHNF
00:09:54 <systemfault> opqdonut: So (+) 1 is not WHNF but (+1) would?
00:10:09 <systemfault> I think I'm getting confused now :P
00:13:02 <kadoban> (+) 1   shouldn't be, IIUC. You have to apply the 1 to the function (+) before you get a lambda form. But maybe cocreature was saying that GHC magics it into being WHNF? I might not be understanding.
00:14:36 <cocreature> I guess the correct whnf would be \(I# y) -> I# (1# + y)
00:15:06 <cocreature> (I don’t think 1# is a thing in actual Haskell code)
00:15:21 <joe9> kadoban: when building xmonad with stack, do you have a .cabal file alongwith the xmonad.hs ?
00:15:42 <kadoban> I don't really know anything about xmonad :-/
00:15:45 <opqdonut> systemfault: hmm, yeah I guess so since (+1) gets expanded to \y -> y + 1 AFAIK
00:15:59 <opqdonut> cocreature: +# or something, right?
00:16:13 <cocreature> opqdonut: oh yeah
00:16:16 <cocreature> to many magic hashes
00:16:19 <cocreature> *too
00:16:47 <kadoban> Heh, when it starts having # in it, I never know what's going on.
00:17:20 <cocreature> just assume it’s magic, after all the extension that allows you to use # is called -XMagicHash
00:43:16 <koz_> How would I write a String -> ReadM Int function which is meant to give me only positive numbers (and error out otherwise)? I'm a bit unsure.
00:44:31 <nkaretnikov`> template haskell time!  given a function add1 :: Int -> Q (TExp Int); add1 x = [||x + 1||], how do i define a function addLst :: [Int] -> Q (TExp [Int])? i keep hitting the stage restriction.  e.g., a naive attempt: addLst xs = [||(<$> xs) $ \x -> $$(add1 x)||] fails because of it
00:46:31 <nkaretnikov`> i've also tried "unfolding" the map function and pattern match on that, but that has the same issue
00:47:12 <nkaretnikov`> the only way i can think of is to match on a "raw" Exp, basically work with the syntax tree
00:47:21 <nkaretnikov`> which is i'd like to avoid
00:47:39 <nkaretnikov`> since that leads to "impossible" error cases
00:48:03 <nkaretnikov`> and texp doesn't help here either because you can't do anything with it, only cast it to the untyped version
00:49:02 <wedens> what would be suggested ncurses library?
00:50:26 <MasseR> brick
00:50:30 <MasseR> https://hackage.haskell.org/package/brick
00:51:45 <liste> wedens: brick is built on libvty, if you need "lower-level" access
00:51:47 <Axman6> yeah brick is pretty cool
00:52:01 <liste> @hackage vty
00:52:01 <lambdabot> http://hackage.haskell.org/package/vty
00:52:33 <MasseR> Oh there was a hackage command. And here I've been doing it manually :)
00:53:16 <wedens> liste: thanks. brick looks nice
00:54:04 <lyxia> nkaretnikov`: pattern match on xs
00:54:25 <lyxia> nkaretnikov`: write a recursive function
00:54:49 <nkaretnikov`> lyxia: could you show me an example? because i keep getting the same error
00:55:53 <nkaretnikov`> lyxia: the problem is with the consing case
00:56:22 <cocreature> nkaretnikov`: http://lpaste.net/175089
00:57:20 <nkaretnikov`> cocreature: i think i've tried something like that, but it seems to require addLst to be in a separate module to be used inside a typed splice
00:57:27 <nkaretnikov`> anyway let me try your code
00:57:48 <cocreature> nkaretnikov`: work for me™ :)
00:59:06 <lyxia> cocreature: it reads like you're recruiting nkaretnikov`
00:59:09 <nkaretnikov`> cocreature: i think it's usually "works for me", no? or are you giving me a job offer :)
00:59:15 <nkaretnikov`> lyxia: yeah :)
01:00:35 <cocreature> heh
01:00:45 <cocreature> nkaretnikov`: sorry that was just a typo :)
01:01:13 <nkaretnikov`> cocreature: anyway, that gives me a type mismatch error between [Int] and Int
01:01:34 <nkaretnikov`> cocreature: looks like th looks at the type of add1 and infers the type of addLst from that
01:01:40 * nkaretnikov` is confused :\
01:02:11 <cocreature> nkaretnikov`: the complete module I was using to try this is http://lpaste.net/175092
01:02:14 <cocreature> and ghc 8
01:02:36 <nkaretnikov`> ah, i'm on 7.10.3 that might be the cause
01:02:54 <cocreature> nope, just tried that one
01:02:57 <cocreature> works fine as well
01:03:40 <nkaretnikov`> cocreature: lol, i'm an idiot. that was an error from a different module, i forgot to change the type there
01:03:45 <cocreature> heh
01:04:04 <nkaretnikov`> cocreature: okay, it works.  ty!
01:08:44 <Axman6> MasseR: The @hackage command is pretty simple though...
01:08:49 <Axman6> @hackage anything you want
01:08:49 <lambdabot> http://hackage.haskell.org/package/anything you want
01:12:23 <suzu> @hackage \r\n
01:12:23 <lambdabot> http://hackage.haskell.org/package/\r\n
01:20:55 <osa1> suzu: what was that for? :-)
01:23:24 <kadoban> Probably just to test if it was clever or just a string plug-in thing.
01:34:52 * hackagebot htestu 0.1.1.2 - A library for testing correctness of pseudo random number generators in Haskell.  https://hackage.haskell.org/package/htestu-0.1.1.2 (DominicSteinitz)
01:48:59 <mpr_> How can I add ld flags to ghc using cabal or stack? I need to add 'ld -z wxneeded'
01:50:26 <srhb> mpr_: There's ghc-options for cabal-install
01:50:45 <srhb> mpr_: It goes in the library or executable section
01:50:51 <mpr_> srhb: I know, I tried -optl -z,wxneeded
01:51:35 <mpr_> srhb: but that doesn't seem to work.
01:52:00 <srhb> mpr_: Hmm, are you sure the -z,wxneeded is right?
01:52:45 <srhb> I mean, does it work when you use ghc directly?
01:52:49 <cocreature> try running cabal with -v3 it should show you the linker invocations so you can make sure your arguments appear
01:53:31 <mpr_> srhb: I haven't tried it directly with ghc, but I also tried '-zwxneeded' and -z wxneeded'.
01:56:09 <ongy> there is ld-options in cabal, it might not use the ghc-options in linker step
01:56:25 <cocreature> ah good point
01:57:12 <ongy> also pkgconfig-depends, iirc wxwidgets supports that (library names look like wxwidgets)
01:58:40 <mpr_> srhb: 'ghc -optl -z,wxneeded Main.hs' gives 'gcc: unrecognized option '-z,wxneeded''.
02:00:10 <cocreature> probably needs a -Wl
02:01:36 <mpr_> cocreature: 'ghc -optl -Wl,-z,wxneeded Main.hs' seems to work.
02:02:25 <jchia> what's the most convenient way to call a monomorphic haskell function from python? (ByteString -> ByteString -> ByteString -> IO (Either String BL.ByteString))
02:03:20 <jchia> i want to call it and get back a Either String ByteString
02:04:57 <mpr_> cocreature: but not when I put it in my cabal file (neither ghc-options nor ld-options).
02:12:09 <ongy> mpr_: what are you putting into ld-options?
02:13:22 <nkaretnikov`> is there a way to turn the definition of 'get' that's inside 'quoteFile' into a splice?
02:13:49 <nkaretnikov`> cts <- runIO $ readFile f; addDependentFile f; return cts
02:13:54 <mpr_> ongy: I tried '-Wl,-z,wxneeded' and '-optl -Wl,-z,wxneeded'.
02:14:31 <nkaretnikov`> the problem with this is that runQ $ f "foo" will result in a an error because addDependentFile cannot be used inside IO
02:14:47 <nkaretnikov`> but is there a way to make it work such that it sort of does?
02:15:03 <nkaretnikov`> (see a bunch of badIO in the Quasi typeclass)
02:15:07 <ongy> mpr_: try ' ' instead of ',' with the first one (I have no idea, just a guess)
02:18:50 <mpr_> ongy: If I use a ' ' instead of a ',' I get an unrecognised flag error.
02:19:55 * hackagebot VKHS 1.7.0 - Provides access to Vkontakte social network via public API  https://hackage.haskell.org/package/VKHS-1.7.0 (SergeyMironov)
02:21:33 <daniel_w> What do I do if stack solver successfully creates a build plan, but then stack build fails to create the same build plan?
02:23:04 <bennofs> daniel_w: have you saved the result of stack solver to your stack.yaml? i.e. stack solver --modify-stack-yaml?
02:23:12 <daniel_w> yes
02:25:27 <ddof> hi
02:27:02 <ddof> I'm quite a haskell noob and I'm trying to write an rpc server that supplies some data insights. I use messagepack rpc for that.
02:27:14 <ddof> relevant code: https://gist.github.com/ChristianSch/6c696240e96f9ee9455cf4a855853d10#file-main-hs-L114
02:27:39 <ddof> how would I pass a function to `serve` with the ConnectionInfo, which I need and don't want to build for each call?
02:28:01 <ddof> All the examples only use simple functions which have no "state"
02:29:18 <ddof> error looks like this: https://gist.github.com/ChristianSch/b1cfc9374198bf5ca90ce84fd42786f1
02:31:26 <ongy> mpr_: "-Wl,-z wlneeded" for ld-options. I can't properly try since my linker doesn't have wxneeded, but this syntax reaches ld
02:33:13 <mpr_> ongy: so a space after -z instead of a comma?
02:41:04 <jchia> I'm trying to make a Data.MessagePack wrapper so that certain types can get automatically converted into a Data.MessagePack.Object, implementing functions toObject :: a -> Data.MessagePack.Object and fromObject :: Data.MessagePack.Object -> Either String a, where a is some type that can be expressed. Examples of expressible types include : [Int64], (Int64, [ByteString]), (Int64, Int64, Int64). (I'm going to serialize tuples as arrays.)
02:41:07 <ongy> mpr_: and the "" in the file
02:41:10 <jchia> how do i express the type constraint for a?
02:43:02 <jchia> will it work if i define a class Obj and make instances for Int64, Bool, Float, [Obj], (Obj), (Obj, Obj), etc?
02:43:04 <daniel_w> jchia: https://hackage.haskell.org/package/msgpack-1.0.0/docs/Data-MessagePack-Object.html#t:MessagePack
02:44:03 <jchia> daniel_w: i want to make it work automatically for any structured type that can be expressed. i don't want to make the Data.MessagePack.Object for each type by hand
02:44:34 <jchia> i want to call "toObject (1, 2, 3, (True, Fals))"
02:45:13 <jchia> and the get back a Data.MessagePack.Object representing (1, 2, 3, (True, False))
02:45:38 <daniel_w> For that to work,  there just need to be instances like: (MessagePack a, MessagePack b) => MessagePack (a, b)
02:45:49 <ddof> jchia: do you by any chance also use the rpc server? I just asked for help a few minutes ago about it 
02:46:11 <jchia> ddof: no, i'm just trying to call haskell from python by passing messagepacks
02:46:37 <mpr_> ongy: Unfortunately that still doesn't seem to work.
02:46:44 <ddof> me too, but you'd have to run the rpc server in haskell from python, wouldn't you?
02:47:31 <mpr_> ongy: I still get: '    ghc: mmap 630784 bytes at 0x40000000: Not supported     ghc: Try specifying an address with +RTS -xm<addr> -RTS     ghc: panic! (the 'impossible' happened)       (GHC version 7.10.3 for x86_64-unknown-openbsd):         loadObj "/usr/local/lib/ghc/ghcpr_8TmvWUcS1U1IKHT0levwg3/HSghc-prim-0.4.0.0-8TmvWUcS1U1IKHT0levwg3.o": failed'
02:47:59 <jchia> i'll just use subprocess.Popen()
02:48:08 <ddof> oh, ok
02:48:27 <ddof> I use the server and it works fine. Pretty nice thing
02:48:33 <ddof> (except for my problem though)
02:48:45 <ddof> but all in all really cool technology
02:48:56 <daniel_w> jchia, the class I linked does what you want
02:51:29 <jchia> daniel_w: OK, I only saw the constructors and missed the toObject and fromObject. thanks
02:56:37 <jchia> any idea why Data.MessagePack.Object has an instance of the MessagePack class? Why do we need toObject and fromObject for an Object?
02:59:42 <daniel_w> It allows you to turn a [Object] into an Object
03:04:57 * hackagebot insert-ordered-containers 0.2.0.0 - Associative containers retating insertion order for traversals.  https://hackage.haskell.org/package/insert-ordered-containers-0.2.0.0 (phadej)
03:07:23 <jchia> daniel_w: it turns out i got confused about packages. you gave me a link to msgpack but i was looking at messagepack, and they both have Data.MessagePack
03:07:43 <daniel_w> ah, confusing
03:09:33 <jchia> msgpack is older than messagepack but seems more featureful. i don't know what's going on
03:09:59 <jchia> featureful meaning having a higher-level interface
03:10:00 <daniel_w> I used both about a year ago
03:10:25 <daniel_w> I vaguely remember having to switch
03:11:45 <daniel_w> There was a weird interaction between the ruby message pack library and msgpack IRC
03:13:26 <jchia> the MessagePack in msgpack has Binary instance and the other MessagePack has Serialize instance. binary and cereal are two different serialization libraries, correct? how else are they related? is one of them preferred nowadays? how do I interoperate between them?
03:14:05 <daniel_w> binary is the older of the two
03:14:39 <daniel_w> I think cereal is preferred generally, I certainly prefer it
03:14:53 <daniel_w> You don't tend to need to use them together
03:15:23 <jchia> if you put with Binary, can you get with Serialize? Would it work?
03:16:20 <jchia> i want to use msgpack but it uses Binary, not Serialize (from cereal)
03:18:12 <AfC> Been writing Haskell for over 5 years, and I still feel like a noob.
03:19:32 <AfC> Today's challenge (which, come to think of it, is almost every day's challenge) pick from eighteen different packages which is The One to use.
03:21:34 <daniel_w> jchia, both libraries are just taking data and turning them into bytestrings and vice versa. You can put with one and get with the other so long as they use the same format, which, IIRC, is not true in general, but is true when they are being used to serialize messagepack
03:22:24 <jchia> OK. I'll stick with one for this application just to be safe
03:22:38 <jchia> why do you prefer cereal?
03:23:01 <AfC> Anyone got an opinion about doing some basic matrix operations? There's https://hackage.haskell.org/package/matrix-0.3.5.0/docs/Data-Matrix.html which seems well enough,
03:23:12 <AfC> but most people seem to be using https://hackage.haskell.org/package/linear-1.20.5/docs/Linear-Matrix.html (obviously repa and friends would be contenders too, but I just need matrix product, transpose, basics)
03:23:49 <daniel_w> jchia, I think the big difference is that cereal parses incrementally, whereas binary relies on lazy bytestrings
03:25:30 <cocreature> these days bytestring also has an interface for incremental parsing of strict bytestrings
03:26:20 <daniel_w> and there's always attoparsec
03:26:42 <daniel_w> wait, did you mean bytestring or binary
03:26:54 <cocreature> eh binary
03:29:59 * hackagebot smoothie 0.4.2.3 - Smooth curves via several interpolation modes  https://hackage.haskell.org/package/smoothie-0.4.2.3 (DimitriSabadie)
03:35:38 <jle`> AfC: linear is decently common, and is implemented in pure haskell using a lot of haskell's idiomatic typeclass hierarchy
03:36:01 <jle`> it's not super performant, though, and it wasn't exactly meant to be when compared to hmatrix, repa, etc.
03:36:10 <jle`> but it'll give you those basic operations
03:36:28 <jle`> and actually generalize them into neat ways that fit into haskell's typeclasses that you don't realize at first
03:36:36 <jle`> it's good enough for simple usage
03:39:00 <AfC> jle`: I'm happy to use Ed's code.
03:40:40 <jchia> I'm trying to use msgpack with stack nightly-2016-08-06 and getting this error:
03:40:41 <jchia> --  Failure when adding dependencies: 
03:40:41 <jchia>       binary: needed (==0.7.*), 0.8.3.0 found (latest applicable is 0.7.6.1) 
03:40:41 <jchia>     needed for package msgpack-1.0.0
03:40:43 <jchia> what are my options?
03:41:23 <jchia> (i tried to get msgpack using extra-deps)
03:43:47 <bergmark> jchia: try setting allow-newer: true in stack.yaml
03:43:53 <Morgawr> What's the complexity of sort/sortBy in Haskell? What underlying algorithm is it using? I assume it's O(nlogn), right?
03:44:09 <AfC> jchia: have you got msgpack down from git or unpack? Either way, you'll need to hack it to try it with a newer binary.... but first what bergmark said :)
03:44:34 <bergmark> jchia: another option is to use an older snapshot that uses that version of binary
03:44:46 <daniel_w> Morgawr: http://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.OldList.html#sortBy looks like a mergesort to me
03:45:31 <Morgawr> daniel_w: Thanks. :)
03:49:50 <jchia> bergmark: I get compilation error in msgpack with allow-newer. i want to use GHC 8. so, i suppose the options i'm left with is to make my own local version of msgpack or help make an newer, fixed, official version, correct?
03:50:45 <daniel_w> Morgawr: it's kind of interesting actually. So, it first finds all of the sequences of consecutive ascending or descending runs, then does merge sort on those
03:54:36 <daniel_w> Since it doesn't take the length of the sequences into account when merging, I wonder if there's a pathological case where it's worse than O(n log n)
03:59:21 <bergmark> jchia: the third option is to use an older version of binary, it should work according to http://matrix.hackage.haskell.org/package/binary
03:59:56 <lyxia> daniel_w: every mergeAll step is O(n) regardless of the lengths of the individual lists, and divides the number of lists by 2.
04:02:40 <daniel_w> lyxia, yep, you're right
04:02:51 <daniel_w> thanks
04:09:18 <jgzh6> Hello
04:09:20 <jgzh6> http://lpaste.net/175130
04:10:00 <jgzh6> I'm not sure why ghci is saying 'Not in scope: 'convert'
04:11:17 <daniel_w> jgzh6, why do you expect it to be in scope?
04:11:57 <jgzh6> Because the function 'fa' was called in the do block and I called the convert function after that
04:12:39 <daniel_w> The only way to bring a variable into scope is with a binding
04:13:16 <daniel_w> did you mean: convert <- getDefaultConverter
04:13:17 <jgzh6> um.. I'm not sure how to bind it in the main function..
04:13:31 <daniel_w> and convert <- fa
04:17:21 <jgzh6> http://lpaste.net/175130
04:17:29 <jgzh6> um.. doesn't seem to work
04:17:47 <daniel_w> jgzh6, the same thing on line 4
04:18:55 <jgzh6> line 4 edited as 'convert <- getDefaultConverter' 
04:19:05 <jgzh6> and it gives me errors like
04:19:23 <jgzh6> Couldn't match expected type 'USD -> GBP'
04:19:32 <jgzh6> with actual type 'Converter'
04:20:02 * hackagebot conduit 1.2.7 - Streaming data processing library.  https://hackage.haskell.org/package/conduit-1.2.7 (MichaelSnoyman)
04:20:04 * hackagebot resourcet 1.1.7.5 - Deterministic allocation and freeing of scarce resources.  https://hackage.haskell.org/package/resourcet-1.1.7.5 (MichaelSnoyman)
04:20:25 <jgzh6> The function 'convert' is applied to one argument,  but its type 'Converter' has non
04:20:53 <jgzh6> In the first argument of 'print', namely '(convert (usd 1) :: GBP)'
04:21:20 <jgzh6> in a stmt of a 'do' block: print (convert (usd 1) :: GBP)
04:21:22 <srhb> jgzh6: What's the type of getDefaultConverter?
04:21:27 <srhb> jgzh6: Also use lpaste.net fo rlong pastes
04:21:35 <srhb> Befire we get a 20 line error :-)
04:22:02 <jgzh6> ipaste returned an error (redundant code)
04:22:04 <Gurkenglas> Is there a guide that tells me what vm image to download and how to set it up to minimize the amount of terminal hell when i want to work on Haskell stuff?
04:22:41 <srhb> jgzh6: Anyway, what's the type of getDefaultConverter?
04:22:51 <jgzh6> type of getDefaultConverter is: IO Converter
04:23:06 <srhb> jgzh6: OK, so I guess you meant to have fa = getDefaultConverter
04:23:07 <Gurkenglas> Failing that, what vm image should I use, if I'm planning to use one of the installer command lines from https://docs.haskellstack.org/en/stable/README/ ? (Why are there two? Which should I use?)
04:24:01 <jgzh6> still gives me the exactly same error
04:24:02 <Gurkenglas> I tried some random linux mint mate image, and the first installer said my system isnt supported, and ghc "fails sanity checks"
04:24:07 <srhb> jgzh6: Oh, I see daniel_w already suggested that. Can you repaste your new code with the error on lpaste.net?
04:24:32 <srhb> jgzh6: It would also be nice to know what Converter is
04:24:48 <puregreen> what would be a good name for a Haskell book that describes a bunch of intermediate/advanced topics in great detail but doesn't try to cover only “pragmatic” stuff?
04:25:11 <srhb> jgzh6: It sounds like you may have a function that takes a converter AND an amount of a currency
04:25:32 <srhb> jgzh6: (Which may be named convert, and you've now shadowed it with your redefinition, but now I'm just guessing)
04:26:08 <jgzh6> http://lpaste.net/175130
04:26:11 <jgzh6> edited
04:26:13 <daniel_w> srhb, convert wasn't in scope before, so it's not called convert
04:26:15 <Shou> Gurkenglas: http://lpaste.net/175139 this the error you get?
04:26:28 <Gurkenglas> puregreen, "selected topics in higher haskell"? I'm not natively English
04:26:33 <srhb> daniel_w: Ah, right!
04:26:40 <srhb> jgzh6: We need to know what Converter is. :)
04:26:44 <jgzh6> the package I'm using is https://hackage.haskell.org/package/currency-convert-0.1.0.0/docs/Data-Currency-Convert.html
04:26:51 <puregreen> Gurkenglas: that's a pretty precise name but not exactly marketable :)
04:26:57 <puregreen> STHH, eh
04:27:11 <srhb> jgzh6: Note the top example: Converter convert <- getDefaultConverter
04:27:37 <jgzh6> I think Converter is just a wrapper..?
04:27:44 <srhb> jgzh6: Yes, so you need to unwrap it.
04:27:44 <Gurkenglas> Our universities professor used the corresponding name for their logic course and it was visited x)
04:27:53 <Gurkenglas> Shou, http://lpaste.net/7351735579723169792 here's one
04:28:34 <Gurkenglas> Shou, here's another terminal tab http://lpaste.net/1687736746474733568
04:29:02 <Gurkenglas> Shou, here's the installer's output http://lpaste.net/175140
04:29:08 <jgzh6> um.. how could I unwrap it..?
04:29:16 <srhb> jgzh6: That's what the example does, by pattern matching on the data constructor and the function
04:29:23 <srhb> jgzh6: Converter convert <- getDefaultConverter
04:29:37 <srhb> jgzh6: Here Converter is the data constructor and convert is the function.
04:30:34 <srhb> jgzh6: http://lpaste.net/175130#a9091601057234026496
04:30:58 <Gurkenglas> Oh hey the website says how to install those extra packages i didnt see that last time, why wouldnt the installer do that
04:31:37 <jgzh6> Oh
04:31:41 <jgzh6> that works
04:31:52 <jgzh6> Thank you so much
04:31:53 <Shou> Gurkenglas: Yeah I'm getting weird linker errors with the Stack GHC packages too. The way I've solved it is to use Nix' GHC packages which doesn't have the issue.
04:31:56 <srhb> jgzh6: No problem.
04:32:56 <Gurkenglas> That sounds like I cant use stack commands afterwards, and I've heard using stack is supposed to be the easy way
04:33:10 <Shou> You can. You just tell stack to use the system GHC.
04:33:31 <Shou> https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#system-ghc
04:34:10 <bennofs> Gurkenglas: there is also https://github.com/commercialhaskell/stack/blob/master/doc/nix_integration.md
04:34:55 <Shou> Do note that your GHC version has to match the Stackage LTS you're using. Luckily with Nix you can have two packages installed at once and just switch between which is visible in the PATH.
04:35:01 <bennofs> Gurkenglas: also http://nixos.org/nixpkgs/manual/#how-to-build-a-haskell-project-using-stack
04:35:16 <bennofs> Shou: if you use stack --nix, then stack will install the correct GHC version with nix automatically afaik
04:35:30 <Shou> Oh sweet
04:37:17 <bennofs> Gurkenglas: installing the addtional packages is likely the easiest way though
04:37:21 <Gurkenglas> "Executable named nix-shell not found on path: ["/usr/local/sbin","/usr/local/bin","/usr/sbin","/usr/bin","/sbin","/bin","/usr/games","/usr/local/games"]" sudo apt get nix I guess?
04:37:54 <bennofs> Gurkenglas: I didn't notice you're on linux mint, you should not need Nix in that case
04:38:16 <Gurkenglas> this docker thing sounds sweet btw
04:39:06 <daniel_w> docker is a huge hack
04:39:54 <Gurkenglas> huh the first docker tutorials im seeing also assume you're not using windows
04:40:42 <Gurkenglas> well yea docker is as much of a hack as trying to use a vm to build my haskell stuff because it doesnt on windows right
04:41:30 <Gurkenglas> aw docker supports "64bit Windows 10 Pro, Enterprise and Education" but not my home
04:41:56 <Gurkenglas> maybe i should make a mac vm and use docker in there
04:42:09 <bennofs> Gurkenglas: make a linux vm in that case
04:42:21 <bennofs> Gurkenglas: because docker on mac is basically: "create a linux vm and run docker in there"
04:42:32 <bennofs> Gurkenglas: but "If you have an earlier Windows system that doesn’t meet the Docker for Windows requirements, get Docker Toolbox."
04:42:37 <Gurkenglas> ah yep i already have a linux vm installing docker to that is probs easier, just the tutorials ive seen have been for mac :P
04:43:06 <bennofs> Does stack work fine on native Windows though?
04:43:27 <daniel_w> I'd hazard a guess that most developers using docker are using it on a mac in a vm
04:43:38 <bennofs> Gurkenglas: for windows there is https://docs.docker.com/toolbox/overview/
04:43:49 <Gurkenglas> ya, but when i tried starting to make PRs to projects the first three didnt build (two because an old-time dependency, the third wont git clone because a filename is "?")
04:44:05 <Gurkenglas> kk docker toolbox didnt see that
04:45:03 * hackagebot hdevtools 0.1.4.0 - Persistent GHC powered background server for FAST haskell development tools  https://hackage.haskell.org/package/hdevtools-0.1.4.0 (ch1bo)
04:49:25 <bennofs> Anyone know what the current status of haskell-ide-engine is?
04:49:37 <Gurkenglas> Perhaps stack should come with a docker installer in case it detects a package its got snapshotted didnt build
04:50:41 <bennofs> Seems we now have hdevtools, intero, (ide-backend? idk if still maintained ), ghc-mod, ...???
04:51:38 <Gurkenglas> hexagoxel's brittany is "like (--) this close"
04:51:58 <Gurkenglas> *to a first alpha release
04:52:43 <srhb> bennofs: shm, haskell-mode, ...
04:53:48 <bennofs> srhb: and all of these tools trying to support stack/cabal/...
04:54:25 <srhb> bennofs: No, just those two, sadly. :-P
04:55:04 * hackagebot servant-auth-token 0.1.2.0 - Servant based API and server for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-0.1.2.0 (NCrashed)
04:57:54 <Gurkenglas> So can this haskell ide engine already be used to improve working with haskell on Windows beyond using sublime-text's preinstalled haskell syntax highlighter, without me having to do more in the terminal than paste in some commands block?
05:01:39 <Unhammer> when working with "IO (Maybe a)" and chains of if-thens like in http://sprunge.us/ZAAA?hs , is there a nice way to make it more readable?
05:01:55 <Unhammer> I was thinking a wrapper mfail :: IO Bool -> m -> IO m -> IO m
05:02:00 <Unhammer> but doesn't seem to improve much
05:02:08 <bennofs> Gurkenglas: i have no idea
05:02:41 <hpc> Unhammer: without even looking at your paste, perhaps MaybeT?
05:03:05 <Gurkenglas> Unhammer, ExceptT. Let me annotate that with how it'd look using ExceptT
05:03:13 <hpc> ah, it's kind of backwards
05:03:22 <Gurkenglas> Oh, you used sprunge instead of lpaste
05:04:37 <srhb> Unhammer: Using maybe helps at lot for starters
05:04:42 <Unhammer> ah
05:05:01 <Unhammer> yeah, MaybeT looks a bit inside-out to me heh
05:05:47 <Unhammer> http://lpaste.net/175142 Gu
05:05:50 <Unhammer> Gurkenglas,  
05:07:03 <lpaste> Gurkenglas pasted “Unhammer, here” at http://lpaste.net/175143
05:07:07 <Unhammer> does that lpaste use hlint to give suggestions btw? (I don't get those suggestions myself, though I do often get others …)
05:07:13 <srhb> Unhammer: Yes.
05:08:22 <Unhammer> oh that looks real nice
05:08:27 <Gurkenglas> Unhammer, you usually want isNothing/isJust to test for nothingness because that way you can test whether, say, a member of Maybe (Int -> Int) is Nothing, even though you can't compare functions for equality.
05:09:25 <lpaste> Gurkenglas revised “Unhammer, here”: “Oh actually I forgot two liftIOs. You can use IO actions in this do block, which is in the monad "ExceptT String IO", but you have to lift them.” at http://lpaste.net/175143
05:09:27 <Unhammer> yeah, this was rewritten a bit hurriedly for irc (actually a bit larger code heh)
05:11:17 <Gurkenglas> Note that the algebraically sound either transformer thing is EitherT, which you can find in ekmetts either package
05:11:31 <Gurkenglas> (Because either is not intrinsically for errors)
05:12:10 <Gurkenglas> (though in this case you've got exactly the ExceptT usecase x))
05:13:38 <Unhammer> huh I should read up on transformers … but thanks Gurkenglas 
05:16:26 <clynamen> I would like to play with clash, but it requires older ghc and libraries version than the ones that I have currently installed
05:16:57 <clynamen> how can I install it? Is there a way to automatically pick those dependencies (including ghc)?
05:21:31 <srhb> clynamen: stack or nix will probably do that for you
05:22:14 <srhb> clynamen: It's a pretty new GHC it uses though, how have you been trying to install it out of curiosity?
05:22:57 <clynamen> just: cabal install clash-ghc --enable-documentation --enable-executable-dynamic
05:23:25 <srhb> clynamen: And you're using ghc 8.0.1?
05:23:34 <srhb> clynamen: Anyway, this page might be helpful: https://github.com/clash-lang/clash-compiler/wiki/FAQ
05:23:46 <clynamen> yes, 8.0.1
05:24:10 <clynamen> thanks!
05:38:38 <YoungBubble> @edwardk Hi
05:38:38 <lambdabot> Unknown command, try @list
05:39:45 <YoungBubble> help
05:41:16 <mniip> hmm?
05:41:35 <mniip> do you have a specific problem you need help with?
05:44:26 <YoungBubble> It's okay!
05:54:58 <Morgawr> Simple question that is hurting my brain a bit, I have a list of Maybe bool, like [Just True, Nothing, Just False, Just False, Just True, Nothing] and I want to map a logical or over the list (treating the Nothing as a False).
05:55:09 <Morgawr> I'm pretty sure there is a simple one-liner way of doing this but at the moment I can't recall.
05:56:00 <MasseR> Morgawr: msum?
05:56:12 <MasseR> > msum [Just 1, Nothing, Just 2]
05:56:14 <lambdabot>  Just 1
05:56:23 <lyxia> :t elem (Just True)
05:56:25 <lambdabot> Foldable t => t (Maybe Bool) -> Bool
05:56:51 <MasseR> Oh sorry, I misunderstood
05:57:17 <Morgawr> > msum [Just True, Nothing, Just False, Just False, Nothing]
05:57:20 <lambdabot>  Just True
05:57:26 <Morgawr> > msum [Just False, Nothing, Just False, Just False, Nothing]
05:57:30 <lambdabot>  Just False
05:57:34 <Morgawr> Seems to be working.
05:57:45 <MasseR> It's not
05:57:51 <MasseR> > msum [Just False, Just True]
05:57:53 <lambdabot>  Just False
05:57:55 <Morgawr> Oh...
05:57:57 <MasseR> Assuming you wanted Just True
05:58:00 <Morgawr> Yeah.
05:58:05 <MasseR> See lyxia above
05:58:13 <MasseR> Like I said, I misunderstood :)
05:58:26 <daniel_w> mconcat . map (maybe False) id
05:58:41 <daniel_w> oops
05:58:50 <daniel_w> mconcat . map (maybe False id)
05:58:55 <dfranke> edwardk: cleaning house on the algebra package, I see :-)
05:58:56 <Morgawr> I could just look for the "Just True" element in the list, I gues...
05:59:23 <bennofs> daniel_w: mconcat on Bool? isn't that a type error?
05:59:37 <bennofs> :t True <> False
05:59:39 <lambdabot>     No instance for (Monoid Bool) arising from a use of ‘<>’
05:59:39 <lambdabot>     In the expression: True <> False
06:00:08 <daniel_w> oh yeh, there's a newtype wrapper though, isn't there
06:00:20 <daniel_w> Any
06:00:44 <daniel_w> getAny . mconcat . map (maybe False id . Any)
06:01:11 <bennofs> > any (fromMaybe False) [Just True, Nothing] -- is probably what I would write
06:01:13 <lambdabot>  True
06:01:39 <daniel_w> that's good too ;)
06:02:42 <bennofs> :t or . catMaybes 
06:02:43 <lambdabot> [Maybe Bool] -> Bool
06:04:01 <daniel_w> my golfing skills need work
06:06:10 <YoungBubble> When does typeclass resolution happen? When does context reduction happen?
06:36:12 <sm> huh.. https://www.reddit.com/r/EnHaskell
06:36:33 <sm> good morning
06:36:53 <hpc> sm: is that narrower than EmHaskell?
06:38:01 <sm> strange name, but I like the topic
06:44:17 <osa1> I'm wondering why is this not used more http://hackage.haskell.org/package/base-4.9.0.0/docs/Text-Printf.html#v:printf instead of "" ++ show x ++ ".." style concatenation. are there any drawbacks that I'm not aware of?
06:45:11 <sm> osa1: it's prone to annoying type errors as you refactor, requires more explicit type annotations
06:45:45 <sm> but it's still useful
06:47:24 <osa1> yeah type errors arising from the are bad (shows the found type but doesn't show the expected type)
06:55:52 <bennofs> osa1: also it is not typechecked, is it?
06:56:15 <bennofs> osa1: so if could specify too many / not enough arguments
06:58:43 <Gurkenglas> https://github.com/commercialhaskell/stack/issues/2421 nooooooooooooooooooooooooooooooo
07:01:20 <Gurkenglas> Oh wait that ignores docker toolbox, just as i did
07:03:09 <osa1> bennofs: yeah arity is not checked
07:03:45 <osa1> > Text.Printf.printf "%d"
07:03:47 <lambdabot>      No instance for (Show a0)
07:03:47 <lambdabot>        arising from a use of ‘show_M309805638392977912214449’
07:03:47 <lambdabot>      The type variable ‘a0’ is ambiguous
07:04:01 <osa1> > Text.Printf.printf "%d" :: String
07:04:03 <lambdabot>  "*Exception: printf: argument list ended prematurely
07:04:10 <osa1> > Text.Printf.printf "%d" 1 2 3 4 :: String
07:04:12 <lambdabot>  "1*Exception: printf: formatting string ended prematurely
07:04:34 <Gurkenglas> http://lpaste.net/2826857224079409152 <- how do I use an lts resolver, or what image should i explicitly set that config to, and why doesnt it tell me that
07:05:52 <bennofs> Gurkenglas: use resolver: lts-<some lts version> in your stack.yaml is what "use an lts resolver" means
07:06:37 <Gurkenglas> hmm. shouldn't it try multiple, and see which works?
07:07:33 <Gurkenglas> (coz i dunno which lts version to use)
07:15:12 * hackagebot x86-64bit 0.1.1 - Runtime code generation for x86 64 bit machine code  https://hackage.haskell.org/package/x86-64bit-0.1.1 (PeterDivianszky)
07:15:37 <sm> sometimes it does try multiple resolvers, but I guess not in this case. Just pick the latest lts
07:37:53 <dysfun> anyone around familiar with freer? I can't work out why this won't compile
07:39:14 <bitfurry> @dysfun what do you mean by freer ?
07:39:14 <lambdabot> Unknown command, try @list
07:39:28 <dysfun> the package 'freer' on hackage
07:40:01 <bitfurry> thanks, let me try it out. I'll let you know if it compiles for me.
07:40:05 <dysfun> it's an implementation of the Freer monad, Extensible Effects etc.
07:40:21 <dysfun> no, it compiles, it's my code that doesn't. I'm still a bit hazy on how it works
07:41:28 <bitfurry> ohk, Sorry I have not tried it, so won't be able to comment on its working.
07:41:50 <dysfun> yeah, it really requires someone who knows how it works already
07:44:46 <Gurkenglas> freer, if someone comes along they'll need to see your code anyway so why not paste it
07:44:52 <Gurkenglas> *dysfun
07:48:49 <riaqn> Hi, I 'm using ghc-mod on emacs. How to instruct ghc-mod not using stack?
07:49:28 <riaqn> ghc-mod on emacs gives me this: "Compiler version mismatched, found ghc-8.0.1 (x86_64), but expected minor version match with ghc-7.10.3 (x86_64) (based on resolver setting in /home/riaqn/.stack/global-project/stack.yaml)."
07:54:22 <amyers> I'm reading this: https://artyom.me/lens-over-tea-3 and was trying to do the 'both' exercise which artyom says is simple
07:54:41 <obadz> riaqn: maybe try (custom-set-variables '(haskell-process-type 'ghci) '(haskell-process-path-stack "stack-go-to-hell"))
07:54:56 <amyers> After looking at it a bit I don't understand how this is possible because Fold doesn't let you change the type of the container?
07:55:30 <amyers> Well, the input type 's'
07:55:33 <amyers> in Fold s a
07:55:51 <puregreen> amyers: I wrote that exercise and frankly I've no idea how to do it so I must've been a tiny bit wrong when I wrote it was simple
07:56:03 <puregreen> (no idea now)
07:56:17 <obadz> riaqn: this is what I meant when I said "this probably won't solve your problem in the long run"
07:56:17 <amyers> puregreen, haha, okay :)
07:56:18 <puregreen> (I obviously had an idea before)
07:56:35 <obadz> riaqn: you ought to be using ghcWithPackages( h: with h; [ ghc-mod … ] )
07:56:35 <amyers> I don't see how you can change the type from tuple to list
07:56:45 <bennofs> puregreen, amyers: what excercise? write bothF :: Fold (a,a) a ?
07:56:57 <amyers> bennofs, correct
07:57:17 <bennofs> that one is certainly possible to write
07:57:35 <puregreen> I managed to forget even the definition of Fold, huh
07:58:08 <amyers> bennofs, Fold s a = <constraints> => (a -> f a) -> s -> f s
07:58:14 <Gurkenglas> Without looking at the lens source, and without using its combinators?
07:58:19 <Gurkenglas> The constraints are important
07:58:35 <amyers> Given that s = (a,a) how do you change it to return a list?
07:58:54 <bennofs> amyers: since any Traversal' s a is also Fold s a, I would just write a Traversal (a,a) a
07:59:01 <bennofs> amyers: Folds do not return lists
07:59:07 <amyers> Gurkenglas, forall (f :: * -> *). (Contravariant f, Applicative f)
07:59:36 <amyers> bennofs, okay, the example from the exercise returns a list
07:59:37 <bennofs> amyers: you need to write bothF :: (Applicative f, Contravariant f) => (a -> f a) -> (a,a) -> f (a,a)
08:00:13 <puregreen> amyers: the example from the exercise has ^..
08:00:20 <bennofs> amyers: then you can use `toListOf bothF :: (a,a) -> [a]`
08:00:24 <Gurkenglas> Contravariant and Applicative give you that for any a and b and c, you can turn (a -> b) into f a -> f b, f b -> f a, (a -> b -> c) into f a -> f b -> f c, and a into f a
08:00:26 <puregreen> it's a feature of ^.. that it returns a list, not a feature of the fold itself
08:01:25 <bennofs> Gurkenglas, amyers: the important combinator that Contravariant + Applicative give you is coerce :: (Contravariant f, Functor f) => f a -> f b
08:01:26 <amyers> Ah, okay, I was misunderstanding what I needed to implement ...
08:02:00 <bennofs> (the one that matters for Fold, anyway)
08:02:23 <Gurkenglas> puregreen, maybe set that exercise up on that online visual haskell ide that lets you combine lego blocks, put the stuff provided by Contravariant and Applicative in there etc
08:02:41 <Gurkenglas> bennofs, that's Contravariant + Functor
08:03:17 <bennofs> Gurkenglas: yeah, if you have applicative also get a way to combine two separate f a and f b into f x
08:03:24 <puregreen> Gurkenglas: would I have to implement that online visual Haskell IDE by myself?
08:03:39 <Gurkenglas> No there's one lemme find it
08:05:34 <amyers> puregreen, evidently I was not "following along to this point" :p  I like the articles though, they've been really helpful
08:05:45 <Gurkenglas> Oh it was two of them, and one is online, and the other is Haskell :/
08:05:50 <puregreen> lol
08:05:59 <Gurkenglas> https://github.com/viskell/viskell https://code.world/blocks
08:09:47 <Gurkenglas> Can I tell the stack.yaml to always use the latest resolver?
08:09:54 <Gurkenglas> the *global
08:10:18 <riaqn> obadz: you mean in the shell.nix?
08:11:33 <haskell289> Is it possible to use case with two parameters? case x y of 1 2 -> 3
08:12:18 <puregreen> case (x, y) of (1, 2) -> 3
08:12:19 <srhb> haskell289: case (x,y) of (1,2)
08:12:40 <srhb> haskell289: Works for arbitrary sizes up to.. 64? :P
08:12:46 <haskell289> srhb: only with tuple?
08:12:52 <srhb> haskell289: Or list, if you like
08:13:07 <srhb> haskell289: It doesn't really matter, you're constructing the tuple from your x and y as you go, and deconstructing it again on your pattern match.
08:15:11 <haskell289> srhb: so syntax like `1 2 -> 3` doesn't exist in haskell?
08:16:18 <srhb> haskell289: Sure, if 1 were a function.
08:16:22 <srhb> 1 2 is "apply 1 to 2"
08:16:39 <__Myst__> Hi
08:16:46 <__Myst__> I was reading through learnyouahaskell and it mentions System.Random
08:16:47 <srhb> But really, in this setting it would have to be a data constructor of kind * -> * for the pattern to be valid
08:16:49 <haskell289> srhb: I can use it with function foo 1 2 = 3 but cannot use with case?
08:16:50 <__Myst__> However it's not in my ghc
08:16:51 <srhb> haskell289: Short answer: No!
08:16:55 <__Myst__> do I have to downlod it through cabal or..?
08:16:58 <srhb> haskell289: That's two aguments.
08:17:04 <srhb> haskell289: Not 1 applied to 2.
08:17:12 <lyxia> __Myst__: it's in the "random" package
08:25:18 <Gurkenglas> __Myst__, if you've used command line commands involving the word "stack", "stack install random".
08:26:16 <__Myst__> Gurkenglas: I honestly did "cabal install random"
08:27:35 <Gurkenglas> Yep, that'll work too. Beware, if you install many packages, at some point different packages used in different projects will want different versions of some same package, and then you're in trouble until you use cabals sandboxes or stack
08:29:04 <mbuf> how does one setup HTTPS with scotty?
08:29:54 <dmj`> mbuf: scotty-tls
08:33:18 <mbuf> dmj`, are there other options than basic authentication with scotty-tls?
08:34:48 <mbuf> dmj`, or, what are good authentication options for a REST API service with scotty-tls
08:35:53 <mbuf> also how does one handle database migrations when using scotty?
08:47:31 <mbuf> never mind, Spock has what I need, https://www.spock.li/tutorial/
08:47:34 <orion> mbuf: Database migrations are outside the scope of what scotty provides.
08:49:01 <mbuf> orion, okay
08:49:11 <mbuf> orion, is there a tool that can help manage them?
08:55:17 * hackagebot uri-bytestring 0.2.2.0 - Haskell URI parsing as ByteStrings  https://hackage.haskell.org/package/uri-bytestring-0.2.2.0 (MichaelXavier)
09:00:18 * hackagebot git-annex 6.20160808 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20160808 (JoeyHess)
09:02:36 <srhb> mbuf: I think Persistent does migrations.
09:02:43 <srhb> mbuf: It's quite popular in the Yesod ecosystem, I think.
09:02:47 <srhb> possibly outside too.
09:03:26 <mbuf> srhb, thanks!
09:06:56 <fr33domlover> Persistent does /some/ migrations automatically, and it can warn about some that it can't do. But generally it doesn't provide a complete solution for migrations
09:07:11 <mbuf> fr33domlover, I see
09:07:17 <fr33domlover> e.g. if you change a table column name, you need to manually do that in the DB
09:07:21 <shapr> fr33domlover: is there another solution for migrations?
09:07:36 <mbuf> or how do people handle their migrations?
09:07:41 <fr33domlover> shapr, i don't know but I definitely want one
09:07:49 <srhb> mbuf: I migrate by hand. :-P
09:07:54 <fr33domlover> mbuf, sadly some people make their web apps proprietary
09:07:58 <alercah> I'm not aware of one. Persistent can't do it because it isn't aware of the history
09:07:58 <fr33domlover> and then it's easy to do by hand
09:08:02 <mbuf> srhb, okay
09:08:20 <alercah> I don't think I've ever seen a system that can automatically handle a column rename
09:08:38 <fr33domlover> i need a good solution for migrations for my web app. If I can't find one, I'll write one
09:08:39 <alercah> at some point you need to tell it that it is a migrated column, not a new one
09:09:07 <fr33domlover> alercah, yeah but persistent could provide syntax for that
09:09:15 <fr33domlover> i.e. provide a previous name of a column
09:09:28 <fr33domlover> but currently it doesn't
09:09:45 <fr33domlover> some frameworks auto generate the schema
09:09:54 <fr33domlover> based on incremental changes
09:09:56 <alercah> yeah I suppose it could
09:10:04 <shapr> fr33domlover: what do you use for a db backend?
09:10:11 <fr33domlover> shapr, I use persistent
09:10:15 <alercah> fr33domlover: I'm willing to believe that though I've never encountered one of those myself
09:10:16 <fr33domlover> with PostgreSQL
09:10:29 <shapr> fr33domlover: thanks, I'll try that for my next webapp
09:10:44 <fr33domlover> alercah, neither have I but I'm making my first web app :P
09:10:49 <shapr> I wanted to use firebase as a backend, but that's been more difficult than I expected
09:20:19 * hackagebot bitcoin-payment-channel 0.2.1.0 - Library for working with Bitcoin payment channels  https://hackage.haskell.org/package/bitcoin-payment-channel-0.2.1.0 (runeks)
09:30:09 <Gurkenglas> On my VM here, I have trouble getting any of these three projects to run. Anyone wanna hop in remotely and see what they can do?
09:32:28 <Gurkenglas> Here are contents from four terminal tabs: http://lpaste.net/9021282993670455296
10:05:22 * hackagebot Glob 0.7.11 - Globbing library  https://hackage.haskell.org/package/Glob-0.7.11 (MattiNiemenmaa)
10:05:24 * hackagebot haddocset 0.4.2 - Generate docset of Dash by Haddock haskell documentation tool  https://hackage.haskell.org/package/haddocset-0.4.2 (HirotomoMoriwaki)
10:15:22 * hackagebot map-syntax 0.2.0.1 - Syntax sugar for defining maps  https://hackage.haskell.org/package/map-syntax-0.2.0.1 (DougBeardsley)
10:21:32 <Gurkenglas> stack setup didnt work, pls send help http://lpaste.net/5680207700521123840
10:23:24 <Gurkenglas> I'll paste that config.log if I'm told how to find it
10:25:11 <srhb> Gurkenglas: Try stack upgrade first, if you didn't
10:25:16 <srhb> Gurkenglas: I think that version is ancient.
10:25:23 * hackagebot snap-loader-static 1.0.0.0 - Snap static loader  https://hackage.haskell.org/package/snap-loader-static-1.0.0.0 (DougBeardsley)
10:32:19 <ElMoloko> quit
10:35:23 * hackagebot snap-loader-dynamic 1.0.0.0 - Snap dynamic loader  https://hackage.haskell.org/package/snap-loader-dynamic-1.0.0.0 (DougBeardsley)
10:36:15 <Gurkenglas> srhb, no sell http://lpaste.net/2176146430077435904
11:05:26 * hackagebot proc-net 1.0.0.0 - Parse /proc/net/  tcp,tcp6,udp,udp6  https://hackage.haskell.org/package/proc-net-1.0.0.0 (implementation)
11:09:56 <lpaste> tippenein pasted “decodeError” at http://lpaste.net/175189
11:10:18 <tippenein> I got a decodeError but the responseBody was returned correctly
11:10:38 <tippenein> How can I track this down. I'm assuming a bad FromJSON instance?
11:11:53 <Cale> Can you try decoding as type Value? Perhaps some JSON was sent that wasn't expected.
11:17:09 <Cale> tippenein: ^^?
11:19:56 <Gurkenglas> On yet another snapshot of that vm on my quest to get stack running, I'm trying to follow https://docs.haskellstack.org/en/stable/install_and_upgrade/#linux
11:20:34 <tippenein> Cale: I'm using entityIdFromJson (https://hackage.haskell.org/package/persistent-2.2.2/docs/src/Database-Persist-Class-PersistEntity.html)
11:21:19 <Gurkenglas> https://gyazo.com/99e413a02d25f4c0077d5a65bba6c143 you can see the end of my .bashrc there and where i extracted that "Linux 64-bit, standard" link to, ive restarted after doing that
11:21:37 <Gurkenglas> the terminal still doesnt know the stack command
11:22:21 <mgsloan> Gurkenglas: "mv ~/.local/bin/stack-1.1.2-linux-x86_64/stack ~/.local/bin/stack"
11:22:40 <mgsloan> Then you can "rm -r ~/.local/bin/stack-1.1.2-linux-x86_64/stack"
11:22:51 <mgsloan> TBH I wish we just shipped linux executables for those instructions
11:23:02 <mgsloan> Instead its packaged up with other auxillary files the exe doesn't need
11:23:29 <Gurkenglas> I guess you mean removing the folder, because the last command doesnt find its target
11:23:38 <mgsloan> Err yeah
11:23:47 <Cale> tippenein: Does it look like there's a key called documentUserKey in the generated JSON?
11:24:35 <Gurkenglas> Okay now lets try stack setup, thats where the "curl -sSL https://get.haskellstack.org/ | sh" and the "sudo apt install haskell-stack" failed
11:25:32 <mgsloan> Gurkenglas: Interesting!  Please open a bug report about that, as things should "just work"
11:25:53 <Gurkenglas> Maybe I should record me doing all that so I can just upload a video if it doesnt work
11:26:23 <tippenein> Cale: documentUserKey is just an accessor persist created. There isn't any json attribute called that
11:26:32 <Gurkenglas> But you can just look at the logs of the last few hours in this channel ^^
11:27:02 <ecro> Is there a way to explicitly import a data instance defined in a module other than the module that defines the data family?
11:27:34 <Gurkenglas> An instance is where you say how something implements a class. Are you sure you wanted to say instance?
11:27:59 <monochrom> Yes. Instance of data family.
11:28:01 <mgsloan> Well the first problem you have seems to be that it lacks libgmp
11:28:11 <ecro> I think so? I want to import the constructor for a singleton.
11:28:28 <mgsloan> Gurkenglas: There are two solutions, either switch to a ghc variant that doesn't use libgmp ("integersimple")
11:28:34 <mgsloan> Or install libgmp.
11:29:12 <ecro> But `import Data.Singleton (Sing(..))` doesn't contain the constructor and `import Foo(Sing(..))` fails because `Foo` doesn't export `Sing`
11:29:49 <geekosaur> Gurkenglas, non-associated data family https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#data-instance-declarations
11:30:10 <mgsloan> Gurkenglas: In the future, I recommend taking a look at the docs - we talk about this gmp issue in quite a few places https://readthedocs.org/search/?q=gmp&check_keywords=yes&area=default&project=stack&version=stable&type=file
11:30:54 <Gurkenglas> Oh yes I remember that being a problem at some point on the other tries. I dont think it worked after that the other times, so I dont need to go back to the other snapshots, but yea ill install that
11:31:31 <Gurkenglas> geekosaur, huh shame on me
11:32:25 <geekosaur> unfortunately said document doesn't say how you import them explicitly 
11:33:03 <Cale> tippenein: I believe the problem is that you're using some auto-generated JSON instance which is looking for keys corresponding to the actual fields of the type, rather than using entityIdFromJSON? But I don't feel like I have enough context to be sure.
11:33:18 <Cale> Lemme walk down the street to somewhere that has an outlet for my laptop :)
11:33:24 <Cale> bbiab
11:33:59 <Gurkenglas> mgsloan, turns out I actually remembered that from this time too - its already installed: http://lpaste.net/9097891530760257536
11:35:00 <mgsloan> Gurkenglas: The issue is probably that mint uses a ramdrive for /tmp
11:35:15 <Gurkenglas> gesundheit :D
11:35:50 <mgsloan> Should fix it, here's the issue - https://github.com/commercialhaskell/stack/issues/996
11:35:55 <mgsloan> Solution is manually setting TMPDIR
11:36:17 <Gurkenglas> (now says no space left on device? but i gave it 8 gigs and installed only this)
11:36:37 <mgsloan> tmp is usually on a different partition
11:36:46 <mgsloan>  err, well, sometimes
11:37:08 <mgsloan> Take a look at the output of "df"
11:37:59 <mgsloan> Gurkenglas: BTW, I saw that you opened some rumpus PRs.  Have you gotten it running then?
11:38:18 <Gurkenglas> no
11:38:41 <Gurkenglas> I dont even have a VR thing ^^
11:39:05 <Gurkenglas> *reads link* "never reclaimed" means the disk is filled with unused stuff and i need to revert to a snapshot?
11:39:17 <mgsloan> Gotcha!  Yeah, still working on getting it to run properly.  I got a Vive recently to play around with VR stuff
11:39:35 <mgsloan> Dunno
11:39:36 <Gurkenglas> http://lpaste.net/3380413895045808128
11:39:40 <Gurkenglas> (output of df)
11:39:59 <mgsloan> Oh, huh, I guess it isn't the ramdrive thing
11:40:32 <Gurkenglas> I could give you remote access or something so you can try things quickly, ill revert the vm to the part before i install stack
11:43:35 <Gurkenglas> you got teamviewer?
11:44:48 <mgsloan> I don't, not sure what's going on there :/
11:45:00 <mgsloan> Seems like it's an upstream issue with ghc's installer
11:45:10 <mgsloan> I recommend doing the ghc install yourself - it's pretty easy!
11:45:21 <mgsloan> (and stack will use it)
11:45:28 * hackagebot twitter-feed 0.2.0.8 - Client for fetching Twitter timeline via Oauth  https://hackage.haskell.org/package/twitter-feed-0.2.0.8 (jpvillaisaza)
11:45:55 <monochrom> IGB may be insufficient for installing GHC
11:46:06 <Gurkenglas> Different github projects i wanted to debug my prs for use different ghc versions i think
11:46:45 <mgsloan> Yeah, tricky to use the GHC switching if "stack setup" isn't working for you
11:46:48 <Gurkenglas> Does it take up less space after its installed?
11:46:56 <mgsloan> I mainly mention it is a way we can figure out what is causing the problem
11:47:07 <mgsloan> My theory is that you won't be able to setup ghc, because stack can't
11:47:22 <mgsloan> If you can, but stack can't, then we have something interesting to investigate
11:47:27 <Gurkenglas> k sure is there a oneline command for that before ill look around for minutes
11:47:45 <monochrom> Yes. It takes twice as much space during installation. Because you untar and then you copy.
11:48:24 <kadoban> Gurkenglas: https://gist.github.com/ion1/2815423 is how I used to setup GHC and cabal-install (the old directions), if that helps.
11:48:30 <mgsloan> True, stack does leave the old tar around
11:49:01 <mgsloan> Less than twice because it's still gzipped
11:49:39 <mgsloan> You're free to delete it if you care
11:49:52 <Gurkenglas> "Get the GHC binary tarball and extract it." which one?
11:50:02 <mgsloan> Whichever one you want!
11:50:22 <ion> The one that matches your system
11:50:46 <Gurkenglas> my system isnt in that list
11:51:11 <ion> Do you have a 64-bit CPU? Which OS do you have?
11:51:39 <Gurkenglas> but there are more distributions than items in that list, so i guess one tarball matches multiple systems. 64 bit, the vm is linux mint xfce i think
11:52:21 <ion> You'll almost certainly want deb8 for a recent version of Mint.
11:52:27 <Gurkenglas> thats the one i was told here to use when i asked which to use to check whether stuff that wont build on windows typechecks
11:53:02 <mgsloan> What's the distinction between deb7 / deb8?  stack is using the deb7 ones for linux
11:54:54 <Gurkenglas> (Its like playing keep talking and nobody explodes, except whenever you lose you waste an hour of your time or a minute of 20 other people)
11:55:03 <ion> I thought the difference might be the version of libgmp they use, but it seems both Debian 7 and 8 have libgmp10
11:57:12 <mgsloan> ion: Could be.  Stack is using the centos ghc builds for the gmp4 variants
11:57:28 <Gurkenglas> so your hypothesis is that itll all work if i double the vms hard disk space?
11:57:31 <mgsloan> (the tarball metadata is all here https://github.com/fpco/stackage-content/blob/master/stack/stack-setup-2.yaml ) 
11:57:44 <mgsloan> Seems like a good thing to try
12:01:45 <lysgaard> Let's say I have two record types, data Small = Small { width :: Int }, data Bigger = Bigger { width :: Int, length :: Double }, and I would like to automate the task of transforming from Smaller to Bigger: addLength :: Smaller -> Double -> Bigger. My actual records have many fields, and this makes writing the addLength function quite tedious, would be nice to have a way to automatically generate such fu
12:01:51 <lysgaard> nctions.
12:02:42 <lysgaard> Does there exist some fancy machinery to do this in a nice way?
12:04:54 <tippenein> Cale: This is where the instances are defined. - https://github.com/tippenein/hasken/blob/master/lib/Remote/Database.hs - I think you're right.
12:05:13 <tippenein> I wanted to leave the userKey out of the json payloads.. but I think that's breaking it
12:05:29 * hackagebot libzfs 0.1.0.0 - Bindings to libzfs, for dealing with the Z File System and Zpools.  https://hackage.haskell.org/package/libzfs-0.1.0.0 (implementation)
12:05:48 <troydm> how do I enable executable profiling when using stack build?
12:05:59 <troydm> I've tried --executable-profiling flag
12:06:19 <troydm> but when I try to run my app with +RTS -p it says -prof is not enabled, I'm confused
12:09:33 <platz> seems odd that 'time' has only 105 downloads in the last 30 days
12:09:38 <platz> according to hackage
12:10:06 <Clint> doesn't everyone get it with ghc?
12:10:19 <platz> ah, that might explain it
12:14:20 <troydm> nvm figured it out
12:14:20 <Gurkenglas> yep it fails on the part where i try to extract the tarball
12:18:22 <Cale> lol, sitting next to the only accessible outlet in Union Station Toronto, and what do you know, it's unpowered. It'll be nice when they finally finish the reconstruction.
12:19:13 <Gurkenglas> mgsloan, why doesn't stack extract that tar in-place to conserve disk space?
12:19:23 <troydm> what exactly is ARR_WORDS?
12:19:39 <troydm> I have some hashmap that has Int32 ByteString type
12:19:49 <troydm> and 1.6mil records
12:20:09 <troydm> and my app's memory footprint is 1.6gig
12:20:13 <troydm> is that reasonable?
12:20:13 <koala_man> Cale: argh. Will the reconstruction provide more outlets or less? I've seen in go both ways
12:20:18 <Cale> troydm: That's how ByteArray# values show up, which are the primitive type used for ByteString and Text
12:20:30 <troydm> most of memory is occupied to ARR_WORDS
12:20:47 <Cale> Sounds like you really have that much ByteString in memory.
12:20:52 <koala_man> some go the route of having USB and/or AC outlets by every seat, others make them all unavailable and add those $5/hour charging stations
12:21:05 <troydm> in MongoDB the same dataset occupies only 100mb disk space? how so? 
12:21:27 <troydm> and that includes extra info that I don't load into Haskell app
12:21:42 <Cale> Well, what are you doing with the hashmap?
12:22:03 <troydm> that hashmap is basicly id -> name mapping of some 1.6 mill records
12:22:06 <Cale> Is it possible that you're doing something like retaining old versions of it accidentally?
12:22:28 <troydm> Cale: not really no, unless HashMap works in mysterious ways
12:22:37 <troydm> I'm using HashMap's insert method
12:22:38 <Cale> What's the average length of the ByteStrings?
12:22:49 <troydm> 15 characters
12:22:55 <hseg> Question: Was annotating the constructors of a GADT with Haddock comments impossible pre-GHC 8? Because the CPP used in https://github.com/haskell/containers/pull/317/files#diff-52bcc964836f9c44f05804a0c2267321R1904 seems to suggest so.
12:24:06 <Cale> troydm: So, 24 megabytes total, plus pointer overhead?
12:24:15 <Cale> Something must be going wrong...
12:24:27 <troydm> Cale: indeed something goes terribly wrong
12:24:41 <mgsloan> Gurkenglas: One reason is that this way we can start from a clean slate without re-downloading, if setup fails
12:25:00 <mgsloan> The other reason is that conserving HD space is not a high priority
12:25:04 <troydm> Cale: I can upload the source code into github since it's an opensource anyway, only not rly finished one
12:25:05 <Cale> troydm: Are you doing lots of inserts without ever observing the contents of the HashMap?
12:25:18 <troydm> Cale: yes, recursively
12:25:35 <Cale> troydm: I wonder if you're building up a large unevaluated expression for building a HashMap, rather than the HashMap you actually want.
12:25:51 <Cale> However, I still am dubious that this would be the only problem...
12:26:23 <Cale> Such an expression would really be not much larger (and perhaps a bit smaller) but much less efficient to access, than the HashMap itself
12:26:33 <Cale> (much less efficient the first time you access it)
12:27:36 <troydm> Cale: well I can upload the source to github so you can look if you want
12:27:45 <Cale> However, that expression might, if you were inserting things which were not simple values, but things which were themselves expressions, end up retaining lots of other data on the heap.
12:27:56 <Cale> okay, I'll take a peek
12:30:36 <Gurkenglas> mgsloan, http://lpaste.net/797374108865134592 I ran "curl -sSL https://get.haskellstack.org/ | sh" (it said theres no gurantee itll work at all because my system isnt supported) and got this (top fell off the scrollback)
12:34:41 <Cale> troydm: btw, if I suddenly disappear, it's probably because my laptop is out of power or I have to board my train.
12:35:18 <Cale> But I think I'll make it... should be pretty close at least, and I'll finally have an outlet (and wifi) on the train.
12:35:19 <troydm> Cale: okey, sure https://github.com/troydm/edda
12:35:40 <troydm> Cale: so you build it and then you run it using stack exec edda -- import -s eddb -t stations
12:36:28 <troydm> Cale: the functions in question are in Database.hs called getSystemEDDBIdsMap
12:36:47 <troydm> Cale: and related toEddbIdPair
12:37:09 <troydm> Cale: my Haskell code is not perfect and sometimes ugly so brase yourself
12:37:28 <Cale> Ah, that bang pattern won't do much
12:37:38 <Cale> It's just going to determine if the list is empty or not
12:37:40 <troydm> Cale: I was mistaken btw I'm using HM.fromList as you can see
12:37:52 <Cale> hmm
12:38:24 <fProgrammer> Quick question: what is the best svm (support vector machine) library out there for Haskell? The libsvm bindings for Haskell I found are quite old. 
12:38:56 <Cale> troydm: However, that $! should be forcing the HashMap at least.
12:39:13 <Adeon> just because it's old doesn't mean they are bad
12:39:23 <Adeon> although if you mean the very low level C like API bindings then yeah those aren't very good
12:39:28 <Adeon> (once tried to find svm lib myself)
12:39:34 <troydm> Cale: I'm not entirely sure it does but well
12:40:01 <Cale> Oh, and the $! on the pair does nothing
12:40:05 <Adeon> I'm not sure if decent svm bindings or libraries exist for haskell
12:40:10 <troydm> Cale: hmm
12:40:13 <Adeon> I didn't find any good ones if I recall correctly
12:40:17 <Cale> Try to understand why you're putting each of the bangs in
12:40:20 <fProgrammer> Adeob
12:40:31 * hackagebot json-api 0.1.1.0 - Utilities for generating JSON-API payloads  https://hackage.haskell.org/package/json-api-0.1.1.0 (toddmohney)
12:40:33 * hackagebot SVGFonts 1.6.0.0 - Fonts from the SVG-Font format  https://hackage.haskell.org/package/SVGFonts-1.6.0.0 (BrentYorgey)
12:40:34 <Cale> Putting more bangs in can be just as harmful as it is helpful
12:40:41 <fProgrammer> Adeon: this is what I am talking about https://hackage.haskell.org/package/svm-simple
12:40:47 <troydm> Cale: hmm, ic
12:41:03 <Cale> What's toStr?
12:41:12 <Cale> What's its type?
12:41:21 <JonReed> Hi, is there some library for persistent memoization. I have a scraper that parses pages and I want to have something like `withPersistence :: (Serialize a, Serialize b) -> (a -> IO b) -> IO b` where it just it memoizes (a -> IO b) based on an argument and stores the result in sqlite, leveldb, or just filesystem.
12:41:22 <Adeon> I wonder why that library doesn't have any documentation despite being years old
12:41:33 <troydm> Cale: in Util.hs it's just decodeUtf8
12:41:34 <Adeon> that is, does it actually have any documentation or is this a haddock problem
12:42:04 <troydm> Cale: sorry not in Util.hs, in Type.hs
12:42:18 <Cale> troydm: okay...
12:42:23 <troydm> Cale: and it's encodeUtf8
12:42:28 <fProgrammer> Adeon : sparse documentation on github link(last updated in 2012) along with some examples. 
12:43:25 <Cale> Try this... make it  let { systemNameStr = toStr systemName }; evaluate systemNameStr; return (fromIntegral eddbId, systemNameStr)
12:43:27 <troydm> Cale: basicly I'm getting json Document with {id: .., name: ..} and I want to put them in HashMap and something terribly goes wrong since it needs 1.6gigs to do that for some 40mb dataset
12:43:48 <troydm> Cale: let me do try it out
12:43:53 <fProgrammer> Anyway thanks, I will keep looking 
12:44:04 <Cale> evaluate is in Control.Exception
12:44:08 <Cale> (for whatever reason)
12:44:41 <Cale> (it's because you tend to need it especially if you want to try to cause exceptions thrown by evaluation to occur in the middle of a catch)
12:45:32 * hackagebot aeson-injector 1.0.4.0 - Injecting fields into aeson values  https://hackage.haskell.org/package/aeson-injector-1.0.4.0 (NCrashed)
12:45:34 * hackagebot libzfs 0.1.0.1 - Bindings to libzfs, for dealing with the Z File System and Zpools.  https://hackage.haskell.org/package/libzfs-0.1.0.1 (implementation)
12:45:36 <JonReed> Is anybody using vcache here for some kind of persistent memoization?
12:45:51 <troydm> Cale: ic, I've read some blog post describing thunk leaks with pretty pictures today
12:46:07 <troydm> Cale: from a series of blog posts about how haskell memory heap works
12:46:32 <Cale> anyone know if there's an easy way to tell the android phone I'm tethering with not to charge itself off my laptop's battery power? :D
12:46:49 <Cale> I guess I could create a mobile hotspot instead...
12:47:12 <kadoban> Cale: Not sure that's actually possible :-/ Yeah, mobile hotspot would be a good way.
12:47:36 <zomg> It might be something you could do with USB drivers if you're crafty enough, but at least Android itself doesn't have an option for that
12:48:27 <zomg> tbh the drain from that could probably be mitigated by reducing monitor brightness or something :D
12:48:45 <puregreen> if your phone is rooted you can probably do echo 0 > /sys/class/power_supply/usb/device/charge on your phone
12:49:10 <kadoban> That works? puregreen wins, heh.
12:49:22 <puregreen> or use something like https://play.google.com/store/apps/details?id=es.guille.stopcharge or one of other apps
12:49:56 <troydm> Cale: I'm having problem with that piece of code, evaluate expects IO action and I have Maybe action
12:50:11 <troydm> Cale: is there an easy way to turn IO to Maybe?
12:50:35 * hackagebot proc-net 1.0.0.1 - Parse /proc/net/  tcp,tcp6,udp,udp6  https://hackage.haskell.org/package/proc-net-1.0.0.1 (implementation)
12:51:34 <nmdanny> does there exist a function that is like: `Either AuthError (Either AuthError UserStatus) -> Either AuthError UserStatus`
12:52:02 <puregreen> join
12:52:47 <puregreen> :t join (undefined :: Either Int (Either Int Bool))
12:52:49 <lambdabot> Either Int Bool
12:52:54 <puregreen> nmdanny: &
12:52:56 <puregreen> * ^
12:55:06 <divVerent> troydm: IO to Maybe? Not really... you mean e.g. turning IO x to IO (Maybe x), from which you can extract the Maybe x? Also, I assume you want it to be Nothing if an exception was thrown, and the return value otherwise?
12:55:19 <troydm> divVerent: it can be done using unsafePerformIO
12:55:48 <troydm> divVerent: Just . unsafePerformIO
12:55:50 <nmdanny> didn't know lambdabot can fill polymorphic types like that, cool ^^
12:56:04 <troydm> :t Just . unsafePerformIO
12:56:06 <lambdabot> Not in scope: ‘unsafePerformIO’
12:56:30 <divVerent> troydm: sure, but probably not what troydm meant, right?
12:56:46 <divVerent> could imagine something like
12:57:12 <Gurkenglas> divVerent, Putin found out Putin sent Putin on a mission to assassinate Putin?
12:57:13 <troydm> divVerent: yes well anyway the optimization didn't worked so it's not needed anymore
12:57:18 <divVerent> maybeX <- catch (liftM Just x) (const Nothing)
12:57:41 <divVerent> not that this is how one usually should handle exceptions :)
13:00:49 <Gurkenglas> Turns out the command I found on the internet didnt enlarge the vm's disk after all, so I made a new one with 4x the size. https://gyazo.com/3f609c29ba54480608f4c4e0d246939f is not the step where I doom myself to stack not working, right?
13:01:28 <Gurkenglas> (that dialog box appeared last time too, i continued)
13:02:04 <mgsloan> Seems fine
13:04:27 <nmdanny> wtf, my either function somehow collapsed/joined a nested Either?
13:05:45 <byorgey> nmdanny: that's what the Monad instance for Either does
13:06:20 <nmdanny> emmm, but I haven't used any monadic operations
13:06:25 <nmdanny> I have the following stuff:
13:06:47 <nmdanny> tokOrErr :: Either AuthError Token
13:06:47 <nmdanny> mkUserStatus :: Token -> Either AuthError UserStatus
13:07:09 <nmdanny> and the following expression: `userOrErr = either Left mkUserStatus tokOrErr`
13:07:24 <nmdanny> gave me `Either AuthError UserStatus`, but I expected `Either AuthError (Either AuthError UserStatus)`
13:07:53 <byorgey> nmdanny: you should adjust your expectations =)
13:08:04 <byorgey> @type either
13:08:06 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
13:08:37 <nmdanny> can lambdabot define type aliases?
13:08:41 <byorgey> here we have  a = AuthError, b = Token, c = Either AuthError UserStatus
13:08:54 <byorgey> @let type X = Int
13:08:58 <lambdabot>  Defined.
13:09:03 <byorgey> I guess so =)
13:09:09 <byorgey> > 3 + 4 :: X
13:09:11 <lambdabot>  7
13:09:18 <nmdanny> @let type AuthError = String
13:09:21 <lambdabot>  Defined.
13:09:50 <nmdanny> @let type Token = Int
13:09:53 <lambdabot>  Defined.
13:10:02 <byorgey> nmdanny: using 'either' gets rid of one layer of Either.  Notice how the output type of 'either' does not have Either in it.  You specify what should happen in the Left case and in the Right case.
13:10:02 <nmdanny> @let tokOrErr :: Either AuthError Token
13:10:03 <lambdabot>  .L.hs:286:1:
13:10:04 <lambdabot>      The type signature for ‘tokOrErr’ lacks an accompanying binding
13:10:47 <byorgey> so 'either Left mkUserStatus' says how to handle the result of tokOrErr: if it is a successful Token, pass it to mkUserStatus; if it is unsuccessful, re-throw the error
13:11:21 <nmdanny> oooh I see
13:11:37 <byorgey> you would get a nested Either if you did   fmap mkUserStatus tokOrErr
13:12:04 <nmdanny> im thinking my code might be more understandable by using join and fmap, rather than either
13:12:14 <byorgey> I agree
13:12:25 <byorgey> even better, tokOrErr >>= mkUserStatus
13:12:58 <nmdanny> thats a law right?
13:13:01 <byorgey> yep
13:17:18 <nmdanny> also, not sure if this question belongs here, but, are there any GHCJS libraries that are similar to react/redux and such?
13:20:34 * hackagebot libzfs 0.1.0.2 - Bindings to libzfs, for dealing with the Z File System and Zpools.  https://hackage.haskell.org/package/libzfs-0.1.0.2 (implementation)
13:20:54 <ertes> nmdanny: reflex
13:22:24 <ertes> nmdanny: it's a generic FRP library, so you can use it on bare metal as well as JS
13:22:41 <nmdanny> i've heard of reflex, but the problem is that it doesn't seem to have much documentation, and it seems a little too "low level"
13:23:56 <ertes> nmdanny: it's true, but if you already have FRP experience, then learning it is surprisingly simple through haddocks and the examples repo
13:25:04 <kadoban> nmdanny: I found the talks linked here: https://github.com/reflex-frp/reflex quite useful. It is quite possible to learn if you work at it. And #reflex-frp is ... ridiculously helpful.
13:25:17 <nmdanny> is reflex as composable, as, say react?
13:25:29 <Cale> ahhhh... so nice to finally be on the train. I have a desk seat and two electrical outlets and wifi
13:25:56 <nmdanny> because from what I've seen it is pretty close to raw DOM manipulation 
13:26:00 <ertes> nmdanny: i have no experience with react, so all i can tell you is:  it's composable
13:26:18 <ertes> nmdanny: note that reflex is an FRP library…  you're probably thinking of reflex-dom
13:26:58 <nmdanny> well I'm gonna need reflex-dom if i'm going to be making a dynamic website
13:27:46 <nmdanny> right now i'm using purescript with pux(which is a UI/state library very similar to the elm architecture if you hear'd abotu it), but I miss some of haskell's tools and libraries
13:27:51 <Cale> nmdanny: Similarly, I haven't yet had the chance to really look at what react does, but it's very composable. You can build nice polymorphic components which even might take other widgets (or data structures full of them) as parameters, and build something out of those.
13:29:22 <nmdanny> maybe i'll try reflex, the problem is that I've been trying for too long to get it to work but to no avail
13:29:26 <ertes> nmdanny: think of reflex as pre-0.17 elm, but higher-order
13:29:47 <Cale> nmdanny: For example, in reflex-dom, there's a data type called Workflow, which lets you have "state machines" where you redirect the user between a bunch of widgets that swap themselves out in an arbitrary fashion. I wrote a thing on top of that (which I plan to clean up and open source sometime soon) which sticks specified CSS transitions automatically whenever the widgets switch.
13:30:35 * hackagebot proc-net 1.0.0.2 - Parse /proc/net/  tcp,tcp6,udp,udp6  https://hackage.haskell.org/package/proc-net-1.0.0.2 (implementation)
13:30:45 <nmdanny> sound interesting
13:31:00 <nmdanny> does GHCJS have support for ghc-mod or something similar?
13:31:05 <ertes> nmdanny: note that i mainly use reflex on its own, without reflex-dom…  that means two things: firstly i have no experience with reflex-dom, secondly it means that reflex is a great FRP library on its own =)
13:31:07 <Cale> Yeah, elm's sort of FRP kind of falls over once your application gets to a certain level of complexity because of the lack of any higher order combinators (also, they awkwardly munged together the properties of Behaviours and Events into a confusing Signal type)
13:32:01 <Cale> ertes: btw, if you would write some sort of tutorial about getting started writing reflex drivers, I think it would be much appreciated.
13:32:29 <ertes> Cale: yeah, actually i already considered doing that
13:32:35 <nmdanny> btw, what can you do with `reflex` by itself? without dom?
13:32:50 <asivitz> Cale: I'm actually working on those higher order combinators: https://github.com/asivitz/layer It's haskell, but I assume it could be easily ported to elm
13:33:01 <ertes> nmdanny: anything you can do with "FRP":  writing programs with interactions over time
13:33:11 <Cale> nmdanny: It's a library for managing any kind of complex state interactions in a pure declarative way.
13:33:22 <ertes> nmdanny: "interaction" doesn't mean "user interaction"…  for example you could write an IRC bot
13:33:46 <Cale> Or AI for game entities
13:34:06 <Cale> Or various kinds of simulations
13:34:06 <kadoban> nmdanny: I don't use ghc-mod anymore, but you can do reflex-dom stuff with GHC as well, with webkit-gtk, so I would be shocked if you can't use ghc-mod if you want.
13:35:14 <nmdanny> thing is I really like GHC-mod's ability to show the types of a selected expression(with atom editor), its a super useful feature IMO
13:35:36 * hackagebot hlint 1.9.37 - Source code suggestions  https://hackage.haskell.org/package/hlint-1.9.37 (NeilMitchell)
13:35:37 <luite_> nmdanny: no ghc-mod support yet as far as i know, getting it to use ghcjs is actually pretty simple (i have a proof of concept pull request there), but a few more changes are needed for it to properly choose ghc or ghcjs depending on the project config automatically
13:35:43 <Cale> However, it is probably fair to say that reflex *does* emphasise the ability to run your system in real time, and gives up on providing certain operations with which it is easy to shoot yourself in the foot in the cases where your system can't get lagged behind.
13:36:07 <Cale> (but which perhaps it would be nice to have in the case where you only care about performing a non-real-time simulation)
13:36:13 <ertes> i was quite surprised that `ghcjs --interactive` actually works, and does so even within a session of haskell-interactive-mode in emacs
13:36:23 <Cale> Of course, I mean soft-real-time, like UIs and games and such.
13:36:40 <ertes> but currently i have no GHCJS stuff in development, so again: no experience in practice =)
13:37:46 <hpc> i wonder if there's a better name for that
13:37:52 <Cale> ertes: Yeah, I really have to try it out... I saw Luite demo it at Compose, and it looked pretty sweet.
13:38:28 <Cale> hpc: ghcjsi?
13:38:32 <hpc> to distinguish 60fps "realtime" from measured-in-ms "realtime" from measured-in-cycles "realtime"
13:38:34 <ertes> Cale: i wasn't even aware of that…  just tried it and it worked
13:38:39 <Cale> hpc: oh, yeah
13:38:42 <luite_> ertes: i still need to finish porting it to ghc 8, but i seem to have other priorities at the moment :p
13:40:36 * hackagebot glirc 2.5 - Console IRC client  https://hackage.haskell.org/package/glirc-2.5 (EricMertens)
13:41:06 <Cale> hpc: I've heard soft- and hard- prefixes used for various pairs of those three, but they're not quite adequate.
13:41:48 <ertes> luite_: sure =)
13:41:50 <manek> Hello! :)) How would you name a data structure, that allows you to keep different data in "layers" and has nothing more than just those layers. There are some implementation details that show better what it is - it has defined type - level list of layer names and each name is associated with the contained data
13:42:09 <luite_> ertes: (still GHCJS though, lots of different areas to work on)
13:42:10 <manek> I'm looking for a name for such structure, that can be filled with user-provided layers and their related datas
13:42:19 <hpc> Cale: maybe phrasing it as "i have to hit a timing of X"
13:42:23 <johnw> manek: I'm unable to picture what you mean
13:42:27 <ertes> manek: can you express that type in terms of types you already know?
13:42:32 <hpc> but good luck convincing everyone to switch terminology ;)
13:42:47 <hpc> this can probably go in -offtopic
13:43:05 <ertes> luite_: one area i'd love to see improved is generated code size
13:43:22 <Cale> manek: That sounds very vaguely like a Map
13:43:28 <luite_> ertes: good guess ;)
13:43:33 <Cale> But yeah, it's too vague to tell
13:43:42 <manek> johnw, ertes: sure! Lets name it X for now. We can use it as follow : type MyType = X '[Type, Assocs, Funcs] . There is a type family similar to `type family DataOf a` and there are instances : `type instance DataOf Assocs = ...` etc.
13:44:50 <ertes> manek: could you explain the *application* of that?
13:44:58 <glguy> vinyl is basically the thingn described above
13:44:58 <ertes> i.e. explain the problem, not the solution =)
13:44:59 <glguy> http://hackage.haskell.org/package/vinyl-0.5.2/docs/Data-Vinyl-Core.html
13:45:08 <glguy> data Rec :: (u -> *) -> [u] -> *
13:46:21 <manek> ertes: its a little simplified model. In fact the X has also attribs. Ok, maybe I'll show you the full model. Lets think about X as follow: `data X (attrs :: [*]) (layers :: *) = X (TMap layers (DatasOf attrs layers))` 
13:46:25 <manek> ertes: and now the use case
13:46:59 <manek> ertes: you can allow your user to define additional data to be kept in X, so it can handle in each X object additional elements accessed by its type-level-tag
13:47:23 <ertes> manek: is the "user" an application user or a developer?
13:47:39 <manek> ertes: so If I've got `X '[Type, Apps]`, you can add a tag `Succs` (successors in a graph) and use `X '[Type, Apps, Succs]` etc
13:47:51 <manek> ertes: developer
13:48:04 <glguy> manek: The messages above were for you
13:48:05 <manek> ertes: of course developer of part of library using this api
13:48:11 <ertes> manek: then see glguy's answer
13:49:11 <ertes> vinyl is for certain kinds of applications like that where everything is statically known or explicitly checked
13:49:19 <ertes> for more dynamic cases there is the dependent-map library
13:49:32 <Zemyla_> You know, I think I've figured out a way to do a fingertree-based free applicative.
13:49:37 <manek> glguy: thanks! I know Vinyl. I need a little different and simplified use case, but yeah it is in the rigth direction. In fact maybe I'm looking for a name `Record` here ! 
13:49:54 <manek> ertes: I know everything at compile time
13:50:26 <manek> ertes, glguy: I just want to express in the name that this structure is just like Vinyl Record but it is just a set of independent layers that users can attach or deteach using the type system
13:50:53 <ertes> manek: "extensible record" seems popular, though personally i don't like it that much
13:51:34 <ertes> (for no particular technical reason)
13:52:56 <x1f577> tips for finding hidden bottoms in code?
13:52:59 <dmwit_> Jello_Raptor: The `dependent-map` package that ertes just mentioned is the one I was thinking of in our discussions about having a `Map`-alike that could support different types of values per key.
13:53:52 <dmwit> one month late, but...
13:54:22 <hpc> haha how long is your scrollback
13:54:29 <Cale> x1f577: hehe, that is a bit like asking "tips for solving the Halting Problem?" :)
13:54:36 <manek> ertes, glguy : thank you guys! I was indeed looking for name "Record" here :)
13:54:41 <Cale> x1f577: But one thing you can practically do is turn on profiling
13:54:44 <ertes> x1f577: use abstractions that don't allow bottoms in the first place =)
13:55:02 <ertes> finding them post-hoc is difficult
13:55:17 <hpc> x1f577: warning on non-exhaustive patterns will catch most
13:55:20 <Cale> x1f577: and then run the program with +RTS -xc  if you have an exception happening
13:55:22 <dmwit> hpc: I have logs going back to 2010...
13:55:27 <x1f577> ertes: until 5 minutes ago i thought i didnt have any!
13:55:32 <x1f577> hpc: i have -Wall on
13:55:35 <hpc> and then searching for "error" and "undefined" catch a few more developer-placed ones
13:55:39 <Cale> or just profile normally if you have plain ol nontermination
13:55:58 <Cale> and the profiling output will contain a count of entries to each cost centre
13:56:07 <Cale> which can usually help pin it down
13:56:20 <hpc> ultimately there's no substitute for writing modular code and understanding how it fits together
13:56:38 <Zemyla> I think it would be able to have optimal conversion to an applicative, with an n-element tree being converted to n-1 <*>s and one fmap.
13:57:30 <Cale> Or if it's an exception, just grep the source code for the exception, and then grep for the thing which throws it
13:58:21 <ertes> x1f577: i thought you mean "hidden" in the sense that you're not even aware of their existence
13:58:33 <pushpush> Hey guys, I have question regarding higher ranked types. I know that a type 'a -> a' (on its own) is implicitly 'forall a. a -> a'. And that you can encode Bool in such a fashion: 'type Bool' = forall a. a -> a -> a'. Any reason why that definition isn't equal (or isomorph) to type Bool' a = a -> a -> a? In both cases Bool' seems to be a function expecting a type and then an expression-level function.  
15:58:49 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
15:58:49 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
15:59:15 <significance> Hello all! Noob here - is there a way to rewrite the function here (http://lpaste.net/175202) to work with non-applicable functors (i.e. same functionality, but without relying on <*> and pure?)
15:59:45 <glguy> significance: No, that's what the Applicative class adds to the mix
16:01:22 <chrisbarrett> Gurkenglas: It's really elegance. I'm running validation against the keys and values, then putting the validated results into a data type, at which point the Nothings need to be filtered out.
16:01:25 <significance_> glguy: sorry! my connection dropped - did I miss your response?
16:01:32 <glguy> significance: No, that's what the Applicative class adds to the mix
16:02:00 <significance_> Gotcha - so it is impossible to turn a list of functors into a functor of a list?
16:02:47 <Gurkenglas> chrisbarrett, are the keys/values maps the whole time? you could filter before turning into a map
16:04:04 <chrisbarrett> Gurkenglas: actually, that's a good idea. I'll do that :)
16:05:12 <Gurkenglas> :t mapMaybe (_1 id)
16:05:14 <lambdabot> Field1 s b (Maybe b1) b1 => [s] -> [b]
16:05:42 <significance_> glguy: wouldn't there be a way to do it with pattern matching out the value and recursively appending to a list?
16:05:57 <Gurkenglas> :t mapMaybe (_1 id) :: [(Maybe k, a)] -> [(k, a)] -- chrisbarrett
16:05:59 <lambdabot> [(Maybe k, a)] -> [(k, a)]
16:06:23 <mniip> 1470697175 [01:59:35] <significance_> Gotcha - so it is impossible to turn a list of functors into a functor of a list?
16:06:29 <mniip> that's a traversable
16:06:53 <glguy> The traversable part is the list in that case
16:06:54 <mniip> oh
16:06:59 <mniip> the other way around, sure
16:07:09 <mniip> yes indeed
16:07:22 <glguy> significance_: No, but it might be interesting to try that idea to see where you get stuck
16:07:56 <significance_> glguy: I'll give it a shot - that's always something fun to do :)
16:07:56 <Gurkenglas> I wonder if theres a way to search whether lens contains an alias for ($id). Something like "hoogle ((a -> a) -> b) -> b", except that its allowed to replace a and b with anything
16:08:00 <significance_> thanks!!
16:08:08 <mniip> oh just pick a divisible instanc--
16:08:16 <mniip> errr
16:08:21 <mniip> distributive
16:10:48 <mniip> :t foldr (liftA2 (:)) (pure []) 
16:10:50 <lambdabot> (Applicative f, Foldable t) => t (f a) -> f [a]
16:10:53 <mniip> :o
16:11:06 <mniip> :t foldr (liftA2 $ liftA2 (:)) (pure $ pure []) 
16:11:08 <lambdabot> (Applicative f, Applicative f1, Foldable t) => t (f (f1 a)) -> f (f1 [a])
16:11:20 <mniip> ooh
16:11:27 <mniip> that's some structure I didn't notice before
16:14:40 <ontop> glguy, puregreen: Using strings and using error (couldn't figure out how to use throwIO without custom data types) led to 23 lines of useless stuff being culled!
16:15:41 <estonoboo> hello
16:16:09 <alercah> helloo
16:16:42 <ertes> with GHC 8 it's easy to figure out which class you need: remove constraint, add -XApplicativeDo =)
16:17:51 <ertes> GHC will complain that you missed to add a Functor/Applicative/Monad/MonadFix/… constraint
16:17:59 <estonoboo> are there any people here who came from F#?
16:18:13 <estonoboo> hi
16:18:24 <ertes> estonoboo: i've briefly used F# a few years ago
16:18:33 <chrisbarrett> estonoboo: I learnt F# before Haskell, but wasn't expert. Doing Scala now.
16:19:07 <estonoboo> well, I want to try Haskell first, hopefully not killing myself in the process :))
16:19:15 <estonoboo> is this good? http://learnyouahaskell.com/introduction
16:19:20 <mniip> :t \f -> do x <- f; return x
16:19:22 <lambdabot> Monad m => m b -> m b
16:19:25 <mniip> aw
16:19:46 <ertes> i had haskell experience before using F#, so it was quite a painful experience, but it was the best choice for that job
16:19:59 <hpc> mniip: not sure what you expected :P
16:20:02 <ontop> estonoboo: From someone who learnt from that, and then bought a book on the subject. I'd save yourself the time and buy a book :p
16:20:06 <mniip> ApplicativeDo in action
16:20:26 <ontop> It was a very cool introduction in what you could do. But it gave me a bunch of surface knowledge without deep understanding.
16:20:33 <ontop> Maybe it's just my style of learning tho :p
16:20:57 <estonoboo> then what are some (serious) books on Haskell?
16:20:59 <Gurkenglas> It builds! old-time builds! exference builds! wooo thanks mgsloan time for sleep.
16:21:09 <hpc> ertes: what was it that made it hard, out of curiosity?
16:21:37 <ontop> estonoboo: bitemyapp makes a pretty decent book. I read that one. And although I'll curse him forever for using Random as a State Monad example. The rest of the book was to my liking.
16:21:39 <hpc> it being an impure member of the ML family i would expect to contribute, as well as the wonky way type inference works to deal with being in .NET
16:21:40 <ertes> estonoboo: judging by who wrote it, i have faith in this book without having read it: http://www.cs.nott.ac.uk/~pszgmh/pih.html
16:21:43 <chrisbarrett> estonoboo: I found F# was nice because I was already familiar with .NET, so it was easy to grok what example code did. Haskell will be very unfamiliar at first.
16:22:12 <chrisbarrett> estonoboo: but yeah, go for gold: http://haskellbook.com/
16:22:14 <ertes> hpc: it pretended to support many things that haskell does without *really* supporting them
16:22:21 <estonoboo> but in theory, if I'm learning Haskell now, wouldn't it make my F# learning experience easier?
16:22:24 <ontop> estonoboo: chrisbarrett has the link for the book I read.
16:22:25 <ontop> :)
16:22:48 <Koterpillar> estonoboo: prepare for a lot of disappointments :)
16:22:57 <ertes> hpc: it pretends to support algebraic abstractions, but all it does is give you some syntax (e.g. for monads)
16:23:01 <estonoboo> oh boi
16:23:07 <estonoboo> dis gun b gud
16:23:24 <hpc> estonoboo: imo learning almost any language will make you a better programmer in general, and after your first two or three languages it really starts to pay off and you can pick up a lot of others in an hour or less
16:23:28 <ertes> hpc: in particular it does not support polymorphism with higher kinds, so you don't get any monadic combinators
16:23:36 <mgsloan> Gurkenglas: Welcome, sleep well!
16:23:41 <ertes> you can't even write mapM_ in F#
16:23:48 <hpc> ertes: ouch
16:24:02 <estonoboo> you can't have a timing function in Haskell :^)
16:24:18 <estonoboo> I've heard that that is impossible in haskell
16:24:23 <ertes> estonoboo: hmm?
16:24:50 <estonoboo> how do you deal with counting time?
16:24:59 <hpc> @hoogle IO UTCTime
16:25:01 <lambdabot> Did you mean: :: IO UTCTime
16:25:01 <lambdabot> No results found
16:25:08 <hpc> ... wut
16:25:17 <geekosaur> there are lots of things you can't do in pure code... but every program starts out in IO, and IO does not have these restrictions
16:25:21 <Koterpillar> :t getCurrentTime
16:25:23 <lambdabot> Not in scope: ‘getCurrentTime’
16:25:26 <hpc> https://hackage.haskell.org/package/time-1.6.0.1/docs/Data-Time-Clock.html#v:getCurrentTime
16:25:26 <ertes> estonoboo: you use IO
16:25:44 <hpc> new hoogle needs to be just a smidgeon smarter
16:26:05 <estonoboo> hoogle?
16:26:07 <hpc> estonoboo: it's not a "function", because getting the clock time doesn't follow the properties of a function
16:26:18 <hpc> specifically that for the same input, you always get the same output
16:26:29 <hpc> input being (), output being come nebulous concept of "now"
16:26:39 <ahsfhyicxv> :t "test"
16:26:41 <lambdabot> [Char]
16:26:50 <hpc> instead it's an IO action that when executed produces the current time
16:26:53 <estonoboo> also what are some games made in Haskell?
16:27:14 <hpc> however see https://hackage.haskell.org/package/acme-now-1.0.0.1/docs/Acme-Time-Now.html
16:27:36 <hpc> which is a joke on that very idea
16:27:54 <chrisbarrett> estonoboo: that's a very specific domain which not every language tries to target :)
16:27:55 <ertes> estonoboo: there is an ages old mini-game that is more of a demo, called 'frag'…  it allows you to load quake 3 maps and run around in them and shoot a weapon, but not really much else
16:28:15 <hpc> the only guarantee you can reasonably get with that definition of "now" is that it is greater than or equal to the time you started the program and less than or equal to the current time
16:28:17 <estonoboo> not that we F#ers have much more than that
16:28:26 <ertes> estonoboo: it's really old, and its purpose was to show that a certain abstraction (called functional reactive programming) can be used to write real-time games without a performance hit
16:28:27 <estonoboo> we also have a Quake 3 remake
16:28:34 <estonoboo> oh, and also a game engine
16:28:38 <shanemikel> is there a fn :: Bool -> s -> ExceptT s m ()
16:28:41 <chrisbarrett> estonoboo: The Halo 3 matchmaking backend was F# iirc
16:28:43 <hpc> iirc there's a gradius clone
16:28:47 <shanemikel> like a guard?
16:28:47 <ertes> estonoboo: i doubt that it even compiles today
16:28:53 <hpc> https://hackage.haskell.org/package/Monadius
16:28:57 <chrisbarrett> estonoboo: probably lots of invisible backend stuff
16:29:06 <estonoboo> also why do people fear monads?
16:29:30 <kadoban> Because they learn them out of context, from bad materials that make too much of them.
16:29:33 <codehero> because they're confusing
16:29:47 <hpc> they're only confusing if taught wrong
16:29:56 <ertes> estonoboo: because there is a misconception that you can understand "monads" by reading about them
16:29:56 <shanemikel> they're just really abstract
16:30:06 <hpc> just ask anyone who is "bad at math" because they had trouble in 7th grade
16:30:12 <ertes> estonoboo: the only way to understand "monads" is to look at specific examples and use them *a lot*
16:30:20 <sm> estonoboo: for more, see hackage Game category, haskell games wiki page, and #haskell-game
16:30:27 <codehero> i've read through so many explanations and still don't really get it
16:30:44 <hpc> codehero: there's sort of two levels of understanding you need to reach
16:30:55 <ertes> codehero: stop reading and write code
16:30:55 <hpc> codehero: the theoretical understanding is that Monad = Applicative + join
16:31:11 <hpc> codehero: and the practical understanding is knowing some instances and using it a bunch, writing your own occasionally, etc
16:31:23 <estonoboo> also how many use vim?
16:31:27 <estonoboo> also how many use vim here*?
16:31:45 <chrisbarrett> I think most people get an intuition for what monads (and other abstract things) are by working with them, not by reading about them. You just have to put in some hours playing around, putting them together, breaking them and interpreting type errors, etc
16:31:49 <hpc> codehero: and a very very important point to emphasize is that Monad builds on Applicative
16:32:11 <hpc> learning Functor, then Applicative, then Monad gives it a really smooth build-up of concepts
16:32:41 <hpc> jumping straight into Monad, or jumping straight into IO which is magical in every way, won't build understanding as easily because too much new stuff is dumped on you
16:32:48 <codehero> hpc: oh, okay
16:33:16 <chrisbarrett> estonoboo: Kmett uses vim I think? I think most people use Emacs or Vim.
16:33:21 <ertes> hpc: i disagree about the latter part
16:33:28 <ertes> one should learn about IO as early as possible
16:33:29 <hpc> Monad is the main API for IO, so a lot of people misunderstand it to mean that Monad has the properties of IO (that it's a compiler built-in or that it's for impure definitions or whatever)
16:33:44 <hpc> ertes: er yeah, i mean jumping deep into IO
16:33:49 <ertes> "deep"?
16:33:52 <shanemikel> codehero for me, the understanding is a combination of comfort with specific monads.. as far as abstract understanding goes, I had a nice clicky moment when I learned what associativity means for code blocks (e.g. procedures).. take a look at http://dev.stephendiehl.com/hask/#eightfold-path-to-monad-satori and scroll down to the part where he shows what the laws look like in code
16:34:14 <hpc> ertes: any further into it than "just do things this way and you'll learn why later"
16:34:55 <hpc> i agree you need enough of IO to be able to write stuff that runs, or you'll be ghci-ing and it'll feel like you can't do shit with the language
16:35:08 <ertes> hpc: i'm not sure what you mean…  IO is a rather shallow type conceptually
16:35:23 <ertes> even (>>) and (>>=) are easy to explain, if you instantiate m = IO
16:35:59 <shanemikel> codehero: specifically the part where he illustrates each law in terms of "do notation"
16:36:34 <alercah> ertes: yeah, and then you're halfway to explaining monads generally
16:36:50 <estonoboo> I'm gonna search for books in the meantime
16:36:57 <hpc> ertes: IO itself is shallow but a full understanding depends on so much else
16:37:13 <hpc> ertes: that if you start with it, you're going to bake in a lot of that other stuff and it becomes a rather big concept
16:37:31 <ertes> hpc: i really don't know what you mean…  could you give an example?
16:37:52 <ertes> IO never left the "shallow" category for me
16:38:19 <hpc> :t (>>=)
16:38:21 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:38:21 <shanemikel> Doing IO you run into using libraries and other functions (many of which use Either and Maybe), and you end up diving into a rather deep rabbit hole in order to get it all
16:38:39 <ertes> when i was starting with haskell my main difficulty with IO was that i was making it deeper than it really was
16:39:13 <ertes> then i came across the "IO = Program that produces" interpretation, and it immediately became shallow
16:39:28 <ertes> you're not doing anyone a favour by making IO deeper than it is
16:39:30 <hpc> right there you have to have an intuition about passing functions to functions, and then put that together with operators being functions so that xs >>= \x -> ... doesn't look weird
16:39:56 <ertes> sure…  you need to understand functions and application on the value and type level
16:40:00 <shanemikel> and of course, learning good style and how to structure code brought me very quickly to transformers, and I spent a while trying to figure out how to get everything and the kitchen sink baked into a single monad.. tried to invent my own exception monad with ContT
16:40:03 <ertes> but you need that anyway
16:40:13 <alercah> the wonderful thing is you don't really need to talk about those things any more than you need to in order to tell someone how to use do notation
16:40:20 <estonoboo> I managed to find haskell programming from first principles, I hope that's good
16:40:20 <alercah> you can go back and help them learn about the cooler monad stufflater
16:40:51 <estonoboo> 1076 pages :O
16:41:00 <hpc> ertes: you can skip it and just say "to do multiple things in IO, use do-notation - you'll learn how it works later"
16:41:12 <hpc> and suddenly they're writing wonky python
16:41:46 <ertes> hpc: i tend to explain (>>=) before do-notation, but i don't oppose the idea of doing it the other way around
16:41:52 <hpc> you haven't lied to them the way you would in say, chemistry with the bohr model
16:42:00 <ertes> the reason i do it in that order is to associate as little magic with IO as possible
16:42:18 <hpc> (that's not a knock on lying, sometimes in teaching it is necessary and there are varying levels of lying)
16:42:42 <shanemikel> anybody using ExceptT?
16:42:50 <shanemikel> or Except for that matter
16:43:00 <estonoboo> good night
16:43:04 <hpc> ertes: i would probably wait for them to ask
16:43:13 <ertes> good night, estonoboo
16:43:26 <ertes> hpc: they'll ask anyway =)
16:43:35 <ertes> regardless of the order
16:43:37 <hpc> ertes: and then say "do notation is syntax sugar and later you'll learn how to use the mechanism it desugars to"
16:44:06 <hpc> and then maybe show them a desugar so they have a benchmark of "i didn't understand that before and now i do"
16:44:36 <ertes> hpc: i think many teachers are underestimating their students…  i've found that to be a mistake…  the reason i don't like the top-down approach with haskell is that it involves so much lying
16:44:52 <ertes> and so many questions i have to answer with: "you'll learn that later"
16:45:25 <ertes> it makes haskell mysterious…  more mysterious than other languages
16:45:29 <hpc> i wouldn't anticipate having to lie at all with the way i just suggested
16:45:41 <hpc> and "you'll learn that later" happens a lot naturally
16:46:06 <ertes> right, let's call it "leaving people in the dark"
16:46:16 <hpc> ertes: did you ever ask in your C class "what happens if you cast a function pointer to void*?"
16:47:13 <ertes> since i learned C/C++ from prose, no =)
16:47:17 <hpc> heh
16:47:24 <mniip> is void allowed to alias function pointers?
16:47:31 <hpc> it's not
16:47:36 <ertes> mniip: void *
16:47:52 <hpc> function pointers are weird magic and there's stuff you just can't do with them
16:47:52 <mniip> I wasn't sure if it's "void can alias anything" or "nothing can alias function pointers"
16:47:53 <alercah> mniip: nope. the implementation doesn't even need to support such a conversion
16:47:58 <hpc> obviously you can't dereference them
16:48:32 <monochrom> I think you should simply refer students to my http://www.vex.net/~trebla/haskell/IO.xhtml
16:49:15 <hpc> there's some other weird stuff in C where the language spec forbids something that POSIX demands
16:49:25 <mniip> monochrom, ah
16:49:35 <mniip> I was hoping that'd be the page with all gory implementation details
16:49:56 <monochrom> I am against telling implementation details.
16:50:01 <hpc> nobody asks those questions though because they have already been duped (though not intentionally)
16:50:03 <mniip> and how RealWorld is never what you think it is even when you try to think really hard
16:50:03 <ertes> monochrom: while i like your introduction contentwise, i don't like it on a pedagogical/rhetorical level
16:50:18 <hpc> they'll learn void pointers in some shallow way, and assume it generalizes
16:50:34 <hpc> then when they learn function pointers, there's an invisible understanding that everything is still the same
16:50:45 <Zemyla> hpc: Yeah, there's no reason IO couldn't be some kind of free monad.
16:50:46 <hpc> and never ask the question
16:51:00 <monochrom> ertes: what is not to like?
16:52:08 <hpc> imo asking a question and hearing back "that's coming up in a couple of weeks" is like a "good job, you understand this enough to anticipate the next concept"
16:52:32 <ertes> monochrom: i'm a bit divided on the in-your-face style of writing combined with the rather dry tone…  generally i think of both as good things, but they should be kept separate
16:52:37 <hpc> while seeing "oh, this doesn't work the way i was taught" is like "did i even learn this correctly?"
16:53:34 <hpc> or if you somehow anticipate and do ask, then hearing back "i don't know" or "it's some stupid crap that makes no sense" is just even worse
16:54:21 <mniip> :(
16:54:32 <mniip> hpc, I've had that
16:55:04 <puregreen> ertes: yeah but the “cunning plan” bit and the analogy after that is cool
16:55:27 <hpc> while showing a coworker why his perl code wasn't working, he asked some questions that i ended up answering with "google it later, it'll take an hour or two to fully grasp"
16:56:01 <monochrom> I don't think of "extract signals into my own hands" and "Hi it's me fineprint again!" as dry.
16:56:31 <hpc> partly because it was faster, but also it was list flattening and there's absolutely no way to answer what was going on without a rabbit hole of "why does (5 + 2) not result in an array"
16:56:58 <hpc> and i just didn't want to deal with it :P
16:57:46 <puregreen> monochrom: I wouldn't call it dry, more like... sometimes deadpan and sometimes sarcastic/irritated? “It can be correctly described by a few simple axioms, but I guess you are not an axiomatic kind of person.” is in the second category, for instance
16:57:48 <hpc> actually i think my exact words to him were "it's just one of those things", which is even worse lol
16:57:51 <monochrom> I can agree that "extract signals into my own hands" is in-your-face. It directly insults all of imperative programming. But it can't be dry at the same time.
16:57:51 <ertes> monochrom: i think the section that turned me off most was the "Prerequisite" section
16:58:56 <hpc> monochrom: in that prerequisites, s/parsing/making sense of/ and then delete that other sentence
16:58:57 <ertes> i would either rewrite it, ideally with links, or remove it
16:59:24 <ertes> i think there is little reason for it to be there
16:59:46 <mniip> hpc, no I mean I had cases where a teacher wasn't able to answer my pretty simple questions
17:00:23 <hpc> mniip: oh that sucks
17:00:36 <hpc> like what questions?
17:01:00 <mniip> I don't remember
17:01:42 <mniip> I think the topic was memory management in C, which I was already familiar with, and the question was "why do XXX"
17:01:57 <mniip> [and not the simple analog thereof]
17:03:24 <hpc> i am torn between thinking "that's not so bad because it's C" and "the teacher should have at least known if it was UB or implementation defined or whatever"
17:03:58 <hpc> or maybe it was one of those "the book says to do it this way, K&R are the one true god" :(
17:04:33 * hpc never asked questions in his C class, but was also under no illusions that he was being taught how to write C code
17:05:00 <mniip> I keep thinking I'm familiar with intricate details of C but every so often the standard manages to baffle me
17:05:04 <hpc> it was more or less an "if you can't grasp pointers you won't make it through this class" kind of first-year filter
17:06:01 <aoeu> is there such a thing as 2-way functions in Haskell?
17:06:12 <mniip> isomorphisms?
17:06:13 <hpc> (not to say it didn't teach pointers, but like with CS101 if you can't get in the right frame of mind for it, you probably want to try another major"
17:06:19 <hpc> bijections?
17:06:24 <aoeu> Like, to get the inverse of a function. To unapply it. To use the same function to both convert a string to an int, and an int to a string
17:06:25 <mniip> er yes
17:06:34 <ertes> aoeu: we have isomorphism lenses
17:06:36 <ertes> uhm
17:06:41 <ertes> let me call them iso lenses instead
17:06:42 <aoeu> ertes: what's that
17:06:45 <mniip> aoeu, lens magic allows you to convert two functions into an isomorphism object
17:06:52 <hpc> aoeu: they're not a language feature but you can express the relationship
17:07:03 <ertes> aoeu: you basically keep a function together with its inverse at all times
17:07:33 <mniip> @let foo = iso (*5) (/5)
17:07:34 <aoeu> ertes: wow, that's cool
17:07:36 <lambdabot>  Defined.
17:07:40 <ertes> aoeu: pretty much like a pair of functions, but with the feature that you can compose them with non-iso things by giving up the iso property
17:07:53 <mniip> > (view foo 3, view (from foo) 3)
17:07:54 <hpc> :t iso -- lens is pretty powerful
17:07:57 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
17:07:57 <lambdabot>  mueval-core: Time limit exceeded
17:08:00 <mniip> > (view foo 3, view (from foo) 3)
17:08:05 <lambdabot>  mueval-core: Time limit exceeded
17:08:08 <hpc> wut
17:08:10 <mniip> hrmph, did I break it
17:08:13 <ertes> @undef
17:08:14 <lambdabot> Undefined.
17:08:16 <ertes> mniip: try again
17:08:19 <mniip> @let foo = iso (*5) (/5)
17:08:20 <lambdabot>  Defined.
17:08:22 <mniip> > (view foo 3, view (from foo) 3)
17:08:23 <lambdabot>  (15.0,0.6)
17:08:29 <hpc> that was interesting
17:08:36 <aoeu> are iso lens usually unit tested as well?
17:08:40 <mniip> yeah the type of foo might be scary
17:08:41 <aoeu> that should be trivial to automate
17:08:42 <ertes> lesson: don't use 'foo' with lambdabot =)
17:08:45 <mniip> :t foo
17:08:46 <lambdabot> (Fractional t, Functor f, Num a, Profunctor p) => p a (f t) -> p a (f t)
17:09:06 <hpc> aoeu: if you care enough about the relationship being correct, and it's not something you can tell just by looking at it
17:09:13 <ertes> aoeu: the isomorphism property follows from the type, so there is no reason to test *that*
17:09:24 <hpc> (or if you REALLY care about it being correct enough to automate it even if it's obvious)
17:09:47 <mniip> hpc, doesn't lens use unsafe profunctor machinery internally?
17:09:50 <aoeu> it's necessary for TDD
17:10:12 <aoeu> only animals don't do TDD
17:10:13 <ertes> aoeu: you would be writing an empty test
17:10:14 <hpc> @let badfoo = iso (*5) (+5)
17:10:15 <lambdabot>  Defined.
17:10:35 <aoeu> badfoo would fail the unit test
17:10:36 <ertes> aoeu: tests only make sense if they can fail
17:10:41 <hpc> you can write bad isomorphisms with lens
17:10:43 <ertes> ah
17:10:58 <mniip> yeah uh,
17:11:00 <ertes> well, you can test them like everything else
17:11:05 <mniip> whenever you implement something with morphisms in haskell
17:11:09 <puregreen> @hackage lens-properties
17:11:09 <lambdabot> http://hackage.haskell.org/package/lens-properties
17:11:16 <hpc> aoeu: the neat thing is you can... that
17:11:25 <mniip> usually there is no way to express the compository laws in haskell
17:11:32 <hpc> write extremely generic tests
17:11:35 <ertes> @check x = view (from badfoo . badfoo) x == (x :: Integer)
17:11:35 <lambdabot>  <unknown>.hs: 1: 3:Parse error: =
17:11:41 <ertes> @check \x -> view (from badfoo . badfoo) x == (x :: Integer)
17:11:43 <lambdabot>  *** Failed! Falsifiable (after 1 test):
17:11:43 <lambdabot>  0
17:11:45 <puregreen> :t isIso
17:11:46 <lambdabot> Not in scope: ‘isIso’
17:11:48 <puregreen> oh well
17:11:55 <hpc> which are basically just manual verifications of some equality relationship
17:11:59 <mniip> e.g the Functor typeclass doesn't include information about 'fmap id == id'
17:12:41 <aoeu> what's the isomorphic function of fizzbuzz?
17:12:47 <aoeu> given "Buzz", what's the number?
17:13:15 <hpc> unit testing in haskell has a funny sort of thing where you don't have to do as much as you would in a lot of other languages
17:13:33 <ertes> mniip: the Profunctor trick is actually quite clever in making sure that you can't drop information in any direction
17:13:47 <ertes> so it's actually quite difficult to write an improper iso
17:13:54 <hpc> and sometimes you can get away with even more by writing sufficiently polymorphic code
17:13:57 <hpc> :t id
17:13:58 <lambdabot> a -> a
17:14:13 <hpc> for instance, there are only three inhabitants of the type (a -> a)
17:14:19 <hpc> id, undefined, and \_ -> undefined
17:14:34 <hpc> you don't need to test that id x == x, it's proven for you
17:14:42 <mniip> (the last two we don't usually talk about)
17:15:04 <hpc> if you really want, you can test that id () doesn't crash
17:15:19 <hpc> and that will 100% prove that id is defined correctly
17:15:30 <hpc> in the "it will never ever be wrong by the laws of math" sense
17:16:12 <hpc> other languages get really deep into it, but there's a culture of it in haskell even without mechanical help
17:16:21 <hpc> that if you can prove a property it's better than unit tests
17:16:32 <hpc> and then touching that code later requires redoing the proof
17:16:53 <puregreen> hpc: I suspect that the main benefit of TDD is psychological
17:16:54 <ertes> also TDD is not too popular around here =)
17:17:04 <hpc> yeah
17:17:04 <ertes> what puregreen said =)
17:17:12 <mniip> 1470701572 [03:12:52] 18<hpc> and that will 100% prove that id is defined correctly
17:17:17 <mniip> unless we're talking GHC haskell :)
17:17:28 <puregreen> if you strictly follow TDD, you *will* have tests written for functions that need them, even if it means also writing useless tests
17:17:43 <hpc> imo TDD is really rigid in how it requires coverage and tests-first
17:17:52 <aoeu> If you don't do TDD you're animals.
17:17:55 <aoeu> How do you test your code?
17:17:56 <puregreen> if you don't, well, you risk not writing any tests 'cause you're lazy— fine, *I'm* lazy
17:17:59 <aoeu> How do you know if it works?
17:18:01 <hpc> to the point where saying you follow "agile" and "TDD" at the same time is an obvious buzzword test
17:18:05 <monochrom> I am an animal, yes.
17:18:14 <hpc> TDD isn't the only way to test
17:18:22 <ertes> if you strictly, formally follow TDD, you go insane before finishing your first project
17:18:23 <hpc> nor is it the only methodology that uses unit tests to begin with
17:18:48 <aoeu> no, you write specs
17:18:49 <ertes> because you will be writing an infinite amount of code
17:18:50 <Axman6> aoeu: TDD is a symptom of a language which does not allow you to specify your problem domain precisely enough to ensure you can't write wrong code
17:18:53 <puregreen> aoeu: I'm fine with my code working only occasionally as long as it lets me avoid the annoyance of having to write tests or specs
17:18:59 <hpc> (TDD itself isn't an actual testing mechanism, just a development process with testing in it)
17:19:05 <puregreen> that's a tradeoff I consciously make
17:19:16 <aoeu> puregreen: i see, you don't want to share your code with the world
17:19:22 <Koterpillar> aoeu: "If you don't do TDD you're animals." -- "If you're making generalizations, you're a cucumber."
17:19:28 <puregreen> no, all my code is shared with the world
17:19:33 <ertes> now i can understand how – let's call it – Loose TDD can become popular in non-static languages, or in languages with bad type systems
17:19:36 <aoeu> puregreen: nobody uses it
17:19:50 <aoeu> i'm not testing types, it's unecessary
17:19:53 <aoeu> animals use dynamic languages
17:20:11 <monochrom> haha, and plants use static languages
17:20:17 <puregreen> nobody uses it because I'm the laziest person I know, not because my code is buggy
17:20:35 <Koterpillar> aoeu: can you please stay on topic? Genii of the entities using such or such languages are not relevant
17:21:02 <mniip> hpc, \x -> case unpackClosure# x of (# i#, _, _ #) -> if indexInt32OffAddr# (plusAddr# i# 8#) 0# ==# CONSTR_NOCAF_STATIC then x else undefined
17:21:15 <puregreen> translation: it's no longer clear whether “animals” was meant to be a joke or not
17:21:17 <monochrom> No, animal and plant are two kingdoms, not two genii. :)
17:21:40 <aoeu> animal was meant to be pejorative
17:21:47 <Axman6> I haven't written proper tests for my code in a very long time, they're mostly unnecessary
17:21:48 <aoeu> "uncivilized"
17:21:53 <hpc> we must overthrow the animal kingdom and install an animal democracy in its stead
17:22:01 <scinawa> lol
17:22:02 <hpc> also mniip you are bad and should feel bad
17:22:22 <aoeu> i'm baffled at the state of programming
17:22:23 <monochrom> mniip: what does that do?
17:22:30 <aoeu> it's the dark age
17:22:32 <mniip> I feel good nanana nananana
17:22:40 <hpc> you've managed to make me feel totally at ease with writing (isn't unsafeCoerce) in code published under my name
17:22:40 <ertes> can we have a type-level quickcheck, please?  because i can't perform TDD in haskell
17:22:44 <mniip> monochrom, reads the closure type from the heap
17:22:51 <monochrom> ah
17:22:53 <agocorona> the mushrooms uses OOP
17:22:59 <monochrom> yes, you are evil :)
17:24:52 <agocorona> aoeu:  why?
17:25:04 <monochrom> You know what's really dark age about programming? A finite set of tests pretending to be a specification, and having the gut to think it has the moral high ground.
17:25:16 <aoeu> agocorona: why what? why programming is so primitive?
17:25:49 <aoeu> ertes: you can TDD in Haskell with QuickCheck
17:25:56 <hpc> or hunit
17:26:14 <hpc> if you want something more traditional
17:26:22 <hpc> quickcheck has that haskell flair to it
17:26:27 <ertes> aoeu: i can also "just write tests" with quickcheck =)
17:27:11 <agocorona> don't test. Just make programs combining trivial programs with trivial combinators that keep the properties
17:27:30 <hpc> i just never run my programs
17:27:35 <hpc> can't have bugs if they don't do anything
17:27:38 <ertes> you test stuff that matters to you, and that doesn't follow from formal properties anyway
17:27:50 <koala_man> monochrom: argh, yes. I'm glad people write tests, but damn.
17:28:14 <monochrom> Yes, I support tests, but testing is not so much holier.
17:28:53 <agocorona> aoeu:  why it is so primitive?
17:28:57 <hpc> also what's considered a "test" here?
17:29:31 <hpc> because it could be as simple as "it doesn't crash" or "i can still double-click this"
17:29:36 <aoeu> ertes: you define properties as your specs, and you prove them
17:29:43 <hpc> when you run it once on your dev box
17:30:11 <hpc> smoke tests are perfectly valid for low-impact or one-off things
17:30:20 <monochrom> I use specifications and stepwise refinement.
17:30:27 <aoeu> you run manually with the interactive mode?
17:30:48 <aoeu> writing a test is as simple as running your code manually and reading the result...
17:30:58 <hpc> this is getting more away from haskell and into general programming practices, so this should probably move channels
17:31:23 <aoeu> whenever i save, it checks if my tests pass, if you don't do that... i don't know
17:31:34 <aoeu> agreed
17:31:41 <agocorona> there is a lot of cargo cult in programming and test. and very few common sense
17:34:11 <ertes> aoeu: i don't feel like writing easy or trivial tests…  even if writing a property were as simple as using the REPL (it isn't), there is still a maintenance burden that usually doesn't pay off
17:34:34 <ertes> again, i can see why loose TDD would be appealing in non-static languages, but in haskell i don't see the point
17:34:43 <agocorona> buzzwords come and go because nobody is sure what to do. I do not imagine buzzwords in established disciplines like mathematics of engineering airplanes
17:35:15 <ertes> also i'm calling it "loose TDD", because real TDD is a theoretical construct with no real-world counterpart
17:35:46 <monochrom> Suppose you have written a polymorphic function: func :: a -> [a].
17:35:50 * hackagebot hpack-convert 0.14.1 - Convert Cabal manifests into hpack's package.yamls  https://hackage.haskell.org/package/hpack-convert-0.14.1 (yamadapc)
17:35:52 * hackagebot hpack-convert 0.14.2 - Convert Cabal manifests into hpack's package.yamls  https://hackage.haskell.org/package/hpack-convert-0.14.2 (yamadapc)
17:36:11 <monochrom> Then I just need one test to know what it is doomed to do. I just need the answer to "func ()".
17:36:44 <monochrom> There are two aspects of this. One, I still need a test case. Two, I don't need a hundred, I just need one.
17:38:56 <ertes> another thing i noticed:  in haskell i tend not to change functions once i've written them
17:39:13 <ertes> a huge contrast to pretty much every other language i've used
17:49:40 <Axman6> monochrom: but just to be sure, you should quickcheck it =)
17:49:53 <Axman6> paramatricity can't be trusted
17:51:58 <monochrom> What aspect don't you trust? Do you mean there may be an unsafeCoerce behind?
17:52:28 <hpc> monochrom: https://www.youtube.com/watch?v=mSy5mEcmgwU :P
17:52:50 <monochrom> OK!
17:53:01 <hpc> :D
17:55:02 <Sonarpulse> Does Hackage predate the minimum Cabal version field in Cabal files?
17:55:36 <agocorona> the path of functional programming is not types neither test. It is creating programs combining trivial pieces of code that do not fail. Types help to find the right combinations, but are instrumental
17:55:55 <agocorona> that's my opinion
17:56:04 <monochrom> I like to think of turning that into a Haskell magic show. "Implement func :: a -> [a], write it on paper. Don't show it to me. Just tell me the answer to func(). Then I will tell you the answers to func 5, func 'x', etc.  Without reading your code!"
17:57:38 <monochrom> I think Hackage was after Cabal.
17:57:59 <Sonarpulse> monochrom: ok. I
17:58:05 <agocorona> for example, a monadic parser assures that the next parse element will get the rest of the string not parsed by the previous one instead of letting the programmer to handle the string. That would be prone to errors
17:58:06 <Sonarpulse> 'm talking to rust people right now about Cargo
17:59:54 <Axman6> just had a micro mind blown moment when I realised that forall x. func x == map (const x) (func ()), no matter what func is
18:00:48 <monochrom> \∩/
18:01:14 <monochrom> See! It is a good Haskell magic show!
18:02:16 <agocorona> a formlet carries out the form rendering and the logic of the element, so there may not be  "tag element not found" errors.  Such is the kind of guaranties that neither types neither tests can guarantee
18:02:19 <Sonarpulse> there is no version field, which makes adding anything but new top-level keys very difficult
18:02:21 <Sonarpulse> with Cargo
18:12:57 <agocorona> and proper usage of functional programming using the right monadic/applicative combinators that keep properties is underused. Why there is no accounting monad/EDSL that operates with double accountability or a billing one that operates with product/services and their prices at the same time?
18:14:59 <ahsfhyicxv> Is there a good library for parsing free form or ISO durations? Ex: "1 hour 30 min" "PT1H20M" It would be great if it could extract them from a string. Ex: "It takes 1 hour and 5 minutes".
18:19:18 <monochrom> agocorona: A few days ago I just learned that SQL's "cross apply" is a monadic bind.
18:19:30 <nshepperd> agocorona: it sounds like you're saying "just don't write any bugs" :)
18:19:39 <agocorona> for me there is a incomprehensible lack of vision in the common understanding that there are only four monads.
18:21:09 <monochrom> Reader, Writer, Gamer, and GameDev? :)
18:21:41 <agocorona> nshepperd:  No. just study the problem, find the basic trivial elements and combine them keeping the properties
18:21:50 <mniip> Monads form an infinite set I'm afraid
18:21:53 <mniip> (is it countable?)
18:22:05 <hpc> one monad, two monads, three monads
18:22:08 <hpc> mwahahahaha
18:22:19 <mniip> (is small enough to be called a set?)
18:22:31 <hrumph> (are infinite sets real)
18:22:40 <monochrom> 1 little, 2 little, 3 little rabbits
18:22:42 <mniip> how can mirrors be real
18:22:45 <hpc> how can infinite sets be real if our eyes aren't real
18:22:49 <hpc> dammit mniip beat me to it
18:22:50 <monochrom> 5 little, 8 little, 13 little rabbits
18:23:22 <hrumph> turns out that completed infinities aren't necessary for doing most math
18:24:50 <hrumph> all of set theory could be a big lie as soon as you add the axiom of infinity
18:26:46 <mniip> what's that
18:27:07 <hrumph> it's the axiom guaranteeing at least one infinite set
18:27:54 <mniip> no I mean the formulation
18:28:47 <hrumph> something like there exists a set x such that for all y in x, there exists a z in x such that y is in z
18:28:49 <hrumph> i can't remember
18:28:57 <nshepperd> it says that the set of all zfc encoded naturall numbers is in fact a set
18:29:29 <hrumph> nshepperd, no that's not the normal formulation
18:30:04 <nshepperd> wikipedia reckons it is
18:30:20 <nshepperd> so i dunno
18:31:04 <hrumph> the formal statement on wikipediat is this
18:31:19 <hrumph> it won't cut and paiste
18:32:11 <hrumph> the definition i had in mind was closer to the one in the "Apparently weaker version" section
18:33:16 <nshepperd> exists N. 0 ∈ N and (forall x ∈ N. (x ∪ {x}) ∈ N)
18:35:29 <hrumph> there;s also a different definition at wolfram closer to what i had in mind
18:36:03 <nshepperd> I think the set of haskell monads must be very big, since 'forall k. instance Monad (Const (Proxy k))'
18:37:11 <nshepperd> although that's a very boring reason
18:37:17 <ontop> If I have (IO String, IO String) - How can I make this into IO (String)
18:37:33 <ontop> Er sorry
18:37:35 <ontop> IO (String, String)
18:38:08 <glguy> ontop: use do notation to name the result of executing the first and second component of your pair, and then return the pair of those results
18:38:29 <hpc> :t \(a, b) -> a >>= \a -> b >>= \b -> (a, b)
18:38:30 <lambdabot> Monad ((,) t) => ((t, t), (t, b)) -> (t, b)
18:38:48 <hpc> erp
18:39:00 <ontop> glguy: Makes sense.
18:39:08 <hpc> but yeah, that
18:39:17 <hpc> and deciding which one runs first too
18:39:44 <ontop> glguy: I'm still trying to Haskell golf my program.
18:39:52 <ontop> I'm down to 4 lines of real code.
18:39:55 <ontop> It's the worst thing in the world. :D
18:40:00 <glguy> :t sequenceOf both
18:40:01 <lambdabot> (Monad m, Data.Bitraversable.Bitraversable r) => r (m b) (m b) -> m (r b b)
18:40:15 <glguy> sequenceOf both :: (IO String, IO String) -> IO (String,String)
18:40:23 <ontop> Oh neat.
18:41:03 <ontop> glguy: Looks like sequence actually handles this?
18:41:06 <ontop> :t sequence
18:41:08 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
18:41:16 <glguy> no, not quite
18:41:19 <ontop> Oh?
18:41:42 <glguy> and if we're golfing: both id :: (IO String, IO String) -> IO (String,String)
18:41:46 <mniip> :t sequence `asAppliedTo` (undefined :: (IO String, IO String))
18:41:47 <lambdabot> (IO String, IO String) -> IO (IO String, String)
18:42:21 <ontop> What in the world is that?
18:42:31 <mniip> :t uncurry $ liftA2 (,)
18:42:32 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
18:43:23 * mniip . o O ( is it doable with bitraversable *and* applicative )
18:44:10 <ontop> This is actually almost readable
18:44:12 <hpc> either or
18:44:15 <ontop> The worst part is the toml parsing.
18:44:17 <ontop> Curse you toml parsing.
18:44:25 <ontop> If I get rid of that, it simplifies so much.
18:44:29 <hpc> but which one is the more interesting abstraction, that's the question
18:49:40 <ontop> glguy: 20 lines. That's as good as I can do.
18:50:02 <ontop> I did it in 3 ruby lines. :( I wish there was a way to import multiple things on a line
18:50:25 <hpc> semicolon?
18:50:44 <hpc> hmm, guess not with imports
18:50:52 <ontop> Worked for me?
18:50:57 <ontop> It's not really pretty though.
18:50:57 <ontop> lol.
18:51:01 <hpc> oh, or maybe it does
18:51:13 <hpc> i was using ghci, which isn't quite haskell syntax in a few ways
18:51:15 <ontop> I guess it's part of the common complaint that any "real" Haskell program has 6 pages worth of imports before you see any code.
18:52:04 <hpc> managing imports imo is one of those indicators that you haven't abstracted out enough
18:52:15 <mniip> hpc, are you telling me there's no (Arrow a, Bifunctor b) => b (a c d) (a e f) -> a (b c e) (b d f)
18:52:41 <hpc> like, you've done a good job when your main file only imports stuff from My.FooLib.Wrapper and not from FooLib.Bar, FooLib.Baz directly
18:53:09 <hpc> mniip: better actually, https://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Traversal.html#v:both
18:53:14 <hpc> BiTraversable
18:53:25 <hpc> or well, Bitraversable
18:53:26 <ontop> Okay. http://lpaste.net/7515532068885889024 - Golfing challenge. Do it in less plz :)
18:53:28 <mniip> import Utils
18:53:32 <hpc> that's a bit of a goofy capitalization
18:53:33 <ontop> :D
18:53:40 <mniip> main = runMain defaults
18:53:54 <ontop> I can't compress this thing anymore without making it completely unwieldly.
18:54:02 <mniip> :t both
18:54:03 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable r) => (a -> f b) -> r a a -> f (r b b)
18:54:05 <hpc> ontop: also re-exports don't count as not importing those things, so don't try and shorten import lists that way or you lose feedback of how well you've organized things :P
18:54:11 <mniip> ehh
18:54:14 <mniip> it's symmetic
18:54:34 <hpc> (there's good reasons to re-export, but just "this is too many lines" isn't really one of them)
18:54:45 <ontop> hpc: I saw an article from someone magical the other day (some important Haskeller) who said I should make my own Prelude.
18:54:51 <hpc> mniip: oh i see
18:54:56 <hpc> mniip: not sure then
18:55:11 <hpc> ontop: it was probably a joke
18:55:39 <hpc> ontop: unless it wasn't, in which case i recommend https://hackage.haskell.org/package/acme-php-0.0.3
18:55:43 <ontop> hpc: I assure you he was quite serious. I'll try to find the article.
18:55:54 <mniip> oh yes
18:55:56 <mniip> that sort
18:56:19 <ontop> hpc: http://www.stephendiehl.com/posts/production.html
18:56:23 <hpc> (i don't have an opinion on using alternate preludes, but writing new ones isn't terribly necessary i think)
18:56:31 <ontop> "Consider rolling an internal prelude"
18:56:39 <ontop> Not necessary I guess.
18:56:52 <hpc> oh, an internal prelude
18:57:17 <hpc> that's sort of better, as long as you exercise restraint about what goes in it
18:57:24 <ontop> ^
18:57:26 <hpc> and it doesn't just become an "import AllTheThings"
18:57:40 <hpc> publishing it on hackage would be useless
18:57:50 * hpc uncomplains
18:57:51 <monochrom> I am lazy. So I would consider my own Prelude. But it would only be Prelude + Control.Monad + Control.Applicative. It would be easy to explain to other people what I have.
18:58:33 <hpc> there should be a language extension that lets you retroactively enable CPP in files that #include it
18:58:40 <reinh1> monochrom: for me a big argument for a custom prelude is to make it easier get away from String
18:58:42 <hpc> (and don't tell me that's impossible, because of course it is)
18:59:11 <hpc> so you can do {-# LANGUAGE MagicCPP #-} import ThingsYouWant
18:59:19 <hpc> and #include "magic.h"
19:00:26 <mniip> 1470707457 [04:50:57] <mniip> import Utils
19:00:26 <mniip> 1470707469 [04:51:09] <mniip> main = runMain defaults
20:22:17 <soniku> Hi, just reading learnyouahaskell.com , I was wondering any good places also to learn about best practices, such as writing pure functions and how to mix pure and unpure functions? Thanks!
20:23:31 <Koterpillar> soniku: finish that book first
20:25:09 <soniku> yep, am on it
20:28:10 <psh_> Hi all, I've recently been turned onto NixOS as a purely functional written in Haskell and was wondering if anyone here had any experience with it?
20:30:18 <hiptobecubic_> i'm sure it has a channel
20:31:46 <dmj`> psh_: think it's written in C++
20:32:04 <Koterpillar> it's not written in Haskell; it defines a language called Nix though
20:37:38 <psh_> Ah thank you. That was my misunderstanding
20:38:57 <psh_> hiptobecubic_: I'm sure you're right. I'll take my curiosities elsewhere
20:39:30 <hiptobecubic_> psh_, not trying to shoo you away. I just think you'll have better luck there.
20:45:55 <ertes> psh_: one on-topic note: i use nix for haskell development and deployment
20:46:33 <ertes> (without stack)
20:53:47 <soniku> btw just interested if anyone is in the mood of summarizing the key advantages of haskell over other functional programming languages (even their own biased opinions) let me know
20:59:22 <Axman6> soniku: the type system is a lot more powerful than most other FP languages (though less powerful than the dependently typed languages like Coq, Agda, etc.). This means you can restrict your system to only the things which work in many more cases
21:01:08 <SrPx> Is there any linkable ring signature implementation on Haskell?
21:01:48 <soniku> axman6: thank you
21:02:30 <Axman6> soniku: it's also much stricter about being a FP language than say Scala or Ocaml, meaning you definitely know* when something needs to perform side effects
21:03:03 <Axman6> * there are escape hatches, like all languages, but "good code" either doesn't use them or uses them in ways that can be shown to be pure
21:05:34 <soniku> that sounds great
21:05:35 <Axman6> soniku: do you have any specific questions?
21:06:29 <soniku> oh well yes i was going to hone my skills mostly in functional programming, so i was going to pick up haskell
21:06:59 <soniku> to see if i was missing out on some things and best practices and structuring code, etc
21:07:18 <Axman6> many people see the strictness of Haskell in keeping to principles like purity and laziness as making it potentially less pragmatic, but many (others) believe that spending the time climbing the steeper learning curve teaches good software design practices, even if you don't end up using Haskell
21:07:45 <sid> Anyone has encountered "MIN_VERSION_base redefined" when compiling the haskell compiler 7.10.3 from source? Also does it matter if I use ghc-8 to bootstrap ghc 7.10.3 compilation?
21:07:47 <soniku> yes i am on the latter spectrum
21:08:17 <geekosaur> sid, in general newer compilers won't build older ones
21:08:33 <sid> geekosaur: thanks, how am I supposed to bootstrap then?
21:09:02 <geekosaur> you have to bootstrap using an older compiler, within 2 major versions (i.e. any 7.6 or 7.8 will work to bootstrap any 7.10)
21:09:05 <soniku> i have used (and really liked) functional programming in other languages but i am looking for best practices also so if haskell compiler yells or warns me when i am doing something wrong then all the better, but yes i do realize that compilers cant replace great code
21:09:56 <geekosaur> this is annoying but it's how things work; the problem is that newer compilers may not accept older syntax (for a recent example, pattern synonyms are not compatible between 7.10 and 8.0)
21:10:04 <soniku> however i think that haskell striving to have as pure as functions as possible is a good thing and can eventually help you to hone your skills in FP
21:10:08 <funkyfun> how mature are the haskell graph libraries?
21:10:49 <funkyfun> i used the boost graph libraries a few years ago and was pretty disappointed
21:10:52 <Axman6> funkyfun: charts is very good, really powerful (thought takes a bit of searching through the docs to piece it all together - it has excellent examples)
21:11:13 <funkyfun> sorry, by graph i mean mathematical graph, not plotting graph
21:11:15 <soniku> thanks axman6, I will definitely be hanging around here more
21:11:39 <geekosaur> another example is that 7.10 has Applicative as prerequisite for Monad, so code that worked with 7.8 and earlier, possibly including ghc itself, won't build with 7.10
21:12:05 <geekosaur> unless it made sure to provide Applicative instances to go along with every Monad instance
21:12:32 <GGuy> Hi, I'm trying to understand the Cont continuation monad. I want it to equal "12": evalCont ( (cont $ \k -> k $ (++) "1") >> (cont $ \k -> k $ (++) "2") ) ""
21:12:57 <glguy> whoa whoa, We've got enough g guys here ;-)
21:13:35 <Axman6> soniku: yeah there's some good resources out there, but #haskell is an excellent place to ask questions
21:13:42 <Axman6> :t cont
21:13:43 <lambdabot> ((a -> r) -> r) -> Cont r a
21:14:54 <dmwit> funkyfun: I think your question is a bit too nebulous to answer meaningfully.
21:15:21 <dmwit> funkyfun: I recommend taking a look through the fgl paper (or the fgl docs if you're not into design philosophy).
21:16:03 * hackagebot irc-core 2.0.0.0 - IRC core library for glirc  https://hackage.haskell.org/package/irc-core-2.0.0.0 (EricMertens)
21:16:35 <funkyfun> cool, i'll check out fgl
21:16:43 <funkyfun> my question is nebulous, you're right
21:17:50 <glguy> GGuy: Maybe you could start with why you expected what you wrote to return "12"
21:18:36 <pavonia> Isn't there any terminal GUI package with native Windows support? The ansi-terminal package and some of the haskeline internals should already capture most of the prerequisites necessary for such a library
21:20:53 <funkyfun> do you mean something like ncurses?
21:21:32 <pavonia> Yeah, but without extra C library dependencies
21:21:54 <funkyfun> i saw something vty,... was it vty-ui? i haven't tried it :P
21:22:10 <funkyfun> my bad, brick
21:23:07 <glguy> vty, vty-ui, and brick won't support Windows
21:23:27 <glguy> Or at least they currently don't
21:23:37 <pavonia> brick depends on vty which depends on unix
21:24:24 <GGuy> glguy: Just because... lol. as far as the types are concerned my understanding is I should be able to use the result from the last continuation but i always just get "2" so I must have a missing piece with my understanding/code
21:24:30 <dmwit> pavonia: Be careful. That kind of complaint is how you sign up to create things in the open source world.
21:27:07 <pavonia> I would actually try it there really isn't some package somewhere
21:36:42 <glguy> Anyone know how one specifies extra-lib-dirs for dependencies when building with cabal's new-build?
21:39:45 <funkyfun> so i'm trying to use fgl in the interpreter with stack
21:39:48 <funkyfun> so i run stack ghci
21:39:55 * glguy figured it out https://github.com/haskell/cabal/issues/2997
21:40:02 <funkyfun> and then i say import Data.Graph.Inductive
21:40:06 <funkyfun> and i get
21:40:28 <funkyfun> Could not find module ‘Data.Graph.Inductive’ It is a member of the hidden package ‘fgl-5.5.3.0@fgl_BiRaIodhxQaGoWvYhVxdWI
21:40:39 <funkyfun> i've already done stack install fgl with success
21:40:53 <funkyfun> and i've already been searching google for 10 min for relevant advice but not dice... what am i doing wrong?
21:41:16 <dmwit> funkyfun: list it as a dependency
21:41:24 <Axman6> are you in a directory with a haskell package already? (are there any .cabal files?)
21:41:30 <funkyfun> in a yaml?
21:41:39 <funkyfun> ah, stack makes use of the cwd?
21:41:49 <alercah> yeah
21:42:04 <funkyfun> d'oh,... i didn't realize,... ok let me try this somewhere else
21:42:21 <Axman6> stack ghci --package fgl should work though
21:43:14 <mgsloan> "stack ghci --package fgl --no-build --no-load" should ignore anything about the current set of packages
21:43:53 <mgsloan> Hmm, that doesn't work as well as it should.  --only-dependencies instead of --no-build
21:45:06 <dmwit> ...or just `cabal install fgl`. Then boring old ghci will have it lying around.
21:45:19 <mgsloan> Or "stack exec ghci"
21:45:33 <mgsloan> Or "stack exec --package fgl ghci" will do it as well :D
21:45:40 <dmwit> stack exec ghci won't work if you haven't set up all the stack infrastructure.
21:45:50 <funkyfun> ... how many years do you guys think until this stuff is as easy as python
21:46:07 <mgsloan> dmwit: what infrastructure do you mean?
21:46:29 <mgsloan> Setting it up is easy, if it's not it's a bug
21:46:39 <dmwit> In this case, I meant a yaml or cabal file or whatever is needed to list dependencies. If it can be done on the command line, then that's great.
21:47:02 <Koterpillar> funkyfun: "The future is already here, it's just not evenly distributed."
21:47:09 <mgsloan> It'll use your global project, but you can override the defaults with the cli
21:48:00 <funkyfun> Koterpillar: you think it's easier to get things running than with python?
21:48:11 <mgsloan> (if you aren't in a dir with a parent that has stack.yaml, etc)
21:57:19 <linoge> I'm trying to wrap my head around some concepts here. But need some examples. Would a login to an external service match a state machine use case?
21:57:40 <funkyfun> ls
22:00:29 <dmwit> linoge: It could, though it's usually a pretty simple state machine.
22:03:29 <linoge> Ok then, let's say my login, implemented as a state machine, must at some point communicate with exterior world. I use the IO monad for that. I would then have to use some monad transformers wizardry (learning about monads and glanced the term near the bottom).
22:03:44 <funkyfun> so stack creates stack.yaml in the cwd and in the project directory
22:04:07 <funkyfun> which file do i modify to specify the fgl dependency (the stack docs don't specify)  ?
22:05:42 <mgsloan> funkyfun: You'd probably enjoy the user guide! https://docs.haskellstack.org/en/stable/GUIDE/
22:06:23 <dmwit> linoge: sounds plausible
22:07:23 <funkyfun> right, i'm following that documentation
22:08:35 <linoge> dmwit: thank you very much once again :). I'll then read about monad transformers ^^
22:10:28 <johnw> funkyfun: the "ease" of Python simply shifts the difficult parts to later in the process
22:23:27 <monochrom> You don't need a monad transformer for state transitions triggered by I/O.
22:25:03 <monochrom> You just need a pure function for the state transition. It is still a pure function even when it is (State, InputMsg) -> (State, OutputMsg).
22:25:41 <monochrom> You then have an IO loop that loops over calling that pure function.
22:26:04 <monochrom> In fact, s/calling/applying/
22:26:53 <monochrom> I should rewrite my number guessing game to do that.
22:46:08 * hackagebot normalization-insensitive 2.0 - Normalization insensitive string comparison  https://hackage.haskell.org/package/normalization-insensitive-2.0 (ppelleti)
22:48:49 <johnw> there's usually relatively little IO that programs need to do, relative to how much computation they perform; it seems a bit heavy to plumb IO everywhere "just in case"
23:02:35 <estonoboo> hey
23:03:40 <srhb> estonoboo: Hello.
23:04:33 <estonoboo> how good is Haskell Programming from first principles?
23:05:02 <srhb> estonoboo: I like it. I think it has a very principled approach and gives you most of the tools in the right order.
23:05:24 <estonoboo> all hail torrenting :V
23:06:02 <srhb> I think the authors will be veyr sad to hear that, you could probably talk to bytemyapp if you have financial difficulties acquiring it.
23:07:02 <srhb> bitemyapp even.
23:07:26 <srhb> estonoboo: That's Chris, one of the authors, who frequents this channel and #haskell-beginners
23:07:27 <Axman6> yeah he's pretty open to helping people out
23:08:11 <Axman6> bitemyapp is a top bloke and has put in a huge amount of effort writing that book
23:08:48 <estonoboo> I do respect his effort, but I sincerely don't have money, and 59$ is a lot here in Romania
23:08:58 <srhb> estonoboo: So talk to him. :) He can usually help out.
23:09:39 <estonoboo> it seems that bitemyapp is Haskell's equivalent of fsharpforfunandprofit
23:10:11 <srhb> No idea about that.
23:11:32 <estonoboo> once I will get money, I'll be sure to donate to the original authors
23:12:12 <estonoboo> does haskell have any IDE or is Vim/Emacs enough?
23:12:33 <srhb> Vim/Emacs is fine, there are some attempts at IDEs, but none are really good in my opinion.
23:12:49 <ongy> talking about books, is there a good book, for people that have an intermidiate understanding about using haskell, but want to improve the theoretical knowledge?
23:13:17 <magthe> estonoboo: vim/emacs is enough for sure, if you happen to fall squarely in between the two I can recommend spacemacs :)
23:13:20 <srhb> ongy: Haskell specifically? I think Purely Functional Data Structures is really, really good.
23:13:26 <srhb> But that's not specific.
23:13:35 <ongy> estonoboo: vim/emacs is fine. Main things I use: ghc-mod (get type of expression) and maybe the hoogle plugin
23:13:56 <estonoboo> what's hoogle?
23:13:59 <srhb> I just have syntax highlighting. Everything else breaks too often in my (probably poor) setup
23:14:12 <srhb> estonoboo: It's a search engine for Haskell functions and values based on types
23:14:16 <liste> estonoboo: a search engine that finds functions based on their type signatures
23:14:24 <srhb> @hoogle [a] -> Int -> a
23:14:24 <ongy> srhb: Haskell centered would be nice, but functional languages in general is good too
23:14:28 <lambdabot> Prelude (!!) :: [a] -> Int -> a
23:14:28 <lambdabot> Data.List (!!) :: [a] -> Int -> a
23:14:28 <lambdabot> Prelude drop :: Int -> [a] -> [a]
23:14:49 <srhb> estonoboo: Ie. "I want a function that takes two arguments: a list of a, and an Integer, and gives me back an a"
23:14:57 <srhb> estonoboo: And Hoogle gives you back such functions. :)
23:15:05 <magthe> estonoboo: https://www.haskell.org/hoogle/
23:15:26 <estonoboo> I am honest, we don't have that in F# :)
23:15:38 <srhb> It's probably not impossible. It's very nice to have.
23:15:56 <estonoboo> @hoogle [a] -> Float -> b
23:15:56 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
23:15:56 <lambdabot> Data.List foldl :: (a -> b -> a) -> a -> [b] -> a
23:15:56 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
23:16:15 <estonoboo> @hoogle [a] -> [b]
23:16:16 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
23:16:16 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
23:16:16 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
23:16:26 <ongy> talking about hoogle, I noticed that the hoogle vim plugin has a local version of the database, can I limit the scope of that database to e.g. my cabal sandbox?
23:16:27 <estonoboo> what's with that Prelude?
23:16:37 <ongy> Prelude is the default imports
23:16:40 <srhb> estonoboo: Prelude is the standard module imported in every Haskell program.
23:16:53 <liste> ongy: hoogle --help
23:17:04 <liste> ongy: esp hoogle data
23:18:04 <srhb> ongy: Maybe this is useful: https://parenz.wordpress.com/2015/05/14/hoogle-inside-the-sandbox/
23:19:10 <estonoboo> is there an online version of hoogle?
23:19:20 <srhb> estonoboo: It was already linked. haskell.org/hoogle
23:19:37 <estonoboo> oops, didn't see it :C
23:19:39 <srhb> estonoboo: In fact there are various versions in the wild, with different packages in scope
23:20:11 <estonoboo> tfw you can integrate hoogle with firefox
23:23:26 <srhb> estonoboo: A word of caution, the rabbit hole of tools is very deep, you'll probably be most productive by just grabbing the compiler and start hacking :-P
23:24:23 <estonoboo> what are the essential plugins for vim for haskell?
23:24:31 <srhb> None, really.
23:25:16 <estonoboo> wait, does vim now have syntax highlighting for haskell?
23:25:22 <kadoban> ghci is the essential thing, and ... spaces instead of tabs. Everything else haskell-specific is optional and ... often more trouble than it's worth.
23:25:38 <kadoban> Vim does by default I think, yeah. At least my OS's version did.
23:25:40 <srhb> estonoboo: I don't remember installing it manually at least, but I may be wrong. It was a long time since I touched it.
23:25:42 <Koterpillar> estonoboo: and a lot of languages too
23:26:05 <srhb> estonoboo: Remember, it's a quite old language. ;-)
23:26:06 <estonoboo> kadoban: are you on windows?
23:26:11 * hackagebot snap-language 0.1.0.1 - Language handling for Snap  https://hackage.haskell.org/package/snap-language-0.1.0.1 (petterb)
23:26:13 <kadoban> No
23:26:18 <estonoboo> :C
23:26:53 <estonoboo> I hope syntastic does syntax checking for haskell
23:27:32 <srhb> estonoboo: This post is quite good I hear, but again, you can get stuck doing tooling for a long time before even touching Haskell: http://www.stephendiehl.com/posts/vim_2016.html 
23:27:50 <estonoboo> I was just looking at that
23:28:19 <liste> estonoboo: it does
23:28:38 <liste> estonoboo: using ghc-mod or hdev, IIRC hdev works better with 7.10
23:28:57 <estonoboo> hdev?
23:29:17 <estonoboo> http://www.stephendiehl.com/posts/vim_2016.html
23:29:19 <liste> hdevtools*
23:29:21 <estonoboo> I found a newer post
23:29:34 <srhb> hdevtools, one of the editor-compiler integrations, and 7.10 refers to the GHC version, the compiler.
23:29:40 <srhb> estonoboo: That was what I linked. :)
23:29:58 <estonoboo> oh, I was looking at the old version then
23:30:36 <connor__> BitchX.theme
23:30:36 <connor__> config
23:30:36 <connor__> default.theme
23:30:36 <connor__> nitz.theme
23:31:11 * hackagebot XMLParser 0.1.0.0 - A library to parse xml  https://hackage.haskell.org/package/XMLParser-0.1.0.0 (AlanHawkins)
23:34:21 <estonoboo> one final thing, does Haskell have any lib for symbolic algebra?
23:34:51 <srhb> estonoboo: I don't know of a big/feature complete one
23:35:08 <estonoboo> also what's cabal?
23:35:26 <estonoboo> it seems to come out in every haskell vim plugin so what's that
23:35:30 <srhb> estonoboo: It's a library for building and also an executable (from cabal-install) for installing packages.
23:35:47 <estonoboo> will I get it along with ghci?
23:35:54 <srhb> estonoboo: Depends how you get GHC.
23:37:55 <ertes> estonoboo: the library cabal comes with GHC, while the utility cabal is more like a convenience
23:38:11 <estonoboo> um, what difference is there between haskell98 and haskell2010 or why are those packages?
23:38:21 <srhb> estonoboo: haskell98 is an earlier standard.
23:38:57 <ertes> estonoboo: those libraries are not particularly useful in practice
23:38:58 <srhb> estonoboo: And those packages just provide exact compatibility with the respective language reports (standards)
23:39:05 <srhb> And we don't use them much :-)
23:39:20 <estonoboo> what, haskell98 or both?
23:39:25 <ertes> both
23:39:25 <kadoban> Just use haskell2010 as a base, and then whatever extensions when you get that far
23:39:51 <ertes> estonoboo: kadoban is talking about the haskell2010 *standard*, not the library
23:40:04 <kadoban> Oh there's a library? don't even know what that is
23:40:06 <glguy> haskell2010 package doesn't come with GHC as of 8.0
23:40:15 <estonoboo> https://www.haskell.org/platform/contents.html
23:40:19 <estonoboo> so is this outdated?
23:40:29 <srhb> estonoboo: No.
23:40:46 <glguy> estonoboo: No, the - mark in the first column indicates that that package isn't in that release
23:40:56 <estonoboo> oh, it indeed isn't in there now
23:41:17 <srhb> estonoboo: Even if it were included, it doesn't make the distribution of these specific packages outdated.
23:41:22 <srhb> estonoboo: You don't have to use them.
23:41:26 <sigrlami> can I do some `stack setup --magic ghc-blah` to explicitly setup a compiler?
23:41:42 <srhb> sigrlami: I think the ghc version will be chosen based on the resolver?
23:42:07 <kadoban> sigrlami: 'stack setup --resolver ghc-7.10' or whatever should work
23:42:16 <sigrlami> well I'm trying to use it for ghcjs
23:42:25 <kadoban> There's a resolver for each GHC version, that just really includes the stuff that comes with GHC.
23:42:47 <kadoban> For GHCJS, there's stuff in the docs about how to do that pretty easily, you just have to copy and paste some stuff into a config file.
23:43:02 <sigrlami> yeah, for old versions =)
23:43:10 <sigrlami> I'm using it with lts6-10
23:43:26 <sigrlami> and there is some from scratch building
23:43:30 <estonoboo> I wonder just how many libs does the full version have
23:43:31 <kadoban> Not that old of versions.
23:43:34 <sigrlami> and I have several ghcjs with same version
23:43:38 <srhb> estonoboo: Full version of what>?
23:43:39 <estonoboo> I'm sure more than I'll ever need
23:43:45 <estonoboo> of haskell platform
23:43:46 <ertes> estonoboo: note that the platform is a convenience as well
23:43:52 <srhb> estonoboo: The Haskell platform? Yeah, you'll probably have a lot of unnecessary packages.
23:44:00 <ertes> estonoboo: the bare minimum is just GHC
23:44:02 <srhb> estonoboo: Not that it matters. :)
23:44:17 <kadoban> Haskell Platform is a convenience for a very short time, and then you outgrow it and wish you'd installed some other way.
23:44:31 <estonoboo> why is it a convenience?
23:44:44 <glguy> Because you can easily install more packages afterward
23:45:01 <ertes> estonoboo: it's supposed to be a "batteries included" distribution
23:45:12 <kadoban> What? That's precisely when you outgrow it, when you have to install more packages. Because then they all break.
23:45:47 <ertes> estonoboo: which operating system are you using?
23:46:06 <srhb> estonoboo: There are many different ways of getting Haskell setup on your system, and each discussion of the different methods tends to ignite a minor flame war in here. :P
23:46:43 <kadoban> Do any people recommend Haskell Platform anymore? Isn't it just stack or cabal-install and manually install GHC or whatever now?
23:47:19 <srhb> kadoban: Yes.
23:47:24 <srhb> (Some people do.)
23:47:33 <ertes> i have no experience with stack, and i've been grateful for the platform's existence on windows
23:47:51 <ertes> (back then stack probably didn't exist)
23:49:06 <srhb> estonoboo: Don't worry about it too much, once your needs become more specific, you can just switch and try out whatever different method you want.
23:49:43 <estonoboo> srhb: I'm using windows
23:49:49 <liste> "Note: as of 8.0.1 there are two download options available — minimal and full. The minimal option is currently the generally recommended one. It does not include any additional global libraries beyond those packaged with ghc, though it does include all tools. This ensures maximal compatibility with a variety of library sets." -- this sounds good
23:49:54 <liste> from haskell.org/platform
23:50:16 <estonoboo> not the best dev platform ever made but eh
23:50:20 <ertes> liste: good to know
23:50:24 <srhb> estonoboo: I can't really give any sound recommendation for Windows, as I'm inexperienced with it.
23:50:33 <srhb> estonoboo: Pick anything! :-P
23:50:33 <ertes> estonoboo: in that case i recommend the minimal distribution
23:50:43 <kadoban> Yeah, that sounds better than it used to be.
23:51:53 <ertes> estonoboo: one advantage of the platform on windows is that it comes with some libraries precompiled that are a rather interesting experience to compile by yourself =)
23:51:57 <estonoboo> brb uninstalling programs to make space
23:52:20 <estonoboo> what do you mean exactly?
23:52:33 <estonoboo> do I have to compile them manually? :^)
23:52:37 <ertes> estonoboo: compiling foreign libraries tends to be a nightmare on windows
23:52:48 <ertes> "foreign" as in "not haskell"
23:53:01 <estonoboo> ah, much better
23:53:35 <estonoboo> https://hackage.haskell.org/package/lojysamban
23:53:42 <estonoboo> >prolog >lojban >haskell
