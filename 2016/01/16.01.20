00:00:03 <jle`> nineonine: if you had main1 = putStrLn "hello", main2 = putStrLn "world", and main = putStrLn "hi", those are all IO actions with different names; GHC will compile the one that you name 'main'
00:00:05 <jle`> it's kind of arbitrary
00:00:32 <jle`> but yeah, the file itself doesn't have to be any sort of module
00:00:48 <jle`> nineonine: also, 'main' can't be a function
00:01:11 <jle`> it has to be of type `IO ()` (or sometimes it's lenient and can be an `IO somethingelse`)
00:01:20 <jle`> main is the name of a specific IO action
00:01:24 <nineonine> yeah right, action, sorry :)
00:01:29 <jle`> np!
00:01:42 <jle`> if main is a function i don't think it'll compile
00:02:46 <quchen> jle`: The Report specifies that (IO r) is valid
00:03:02 <jle`> oh neat
00:03:13 <cocreature> is there any reason to use IO a where a is not ()?
00:03:25 <jle`> to avoid a `return ()`, i guess
00:03:29 <cocreature> fair enough
00:03:36 <quchen> jle`: It also specifies that "the result of type r is discarded"
00:03:48 <quchen> So there's an implicit "pure ()" at the end of main
00:04:04 <jle`> or i guess you can say, it actually compiles/runs `main *> pure ()`, not `main`
00:04:31 <jle`> we should do it like C, where main :: IO Int
00:04:36 <jle`> by "should" i mean "should not"
00:05:55 <quchen> exitWith (ExitCode 3) seems a bit verbose when main could just return 3
00:06:34 <jle`> but then now haskell-the-language is tied with unix
00:06:56 <quchen> Hm, okay.
00:07:02 <jle`> *would be tied to unix the spec
00:07:37 <cocreature> what happens when you use exit codes in something like C on windows?
00:09:06 <liste> DOS (and Windows) has exit codes
00:09:16 <liste> not as many as *nix though
00:09:51 <liste> only 0-255 iirc
00:10:13 <jle`> i guess exit codes as a concept are beyond unix
00:10:47 <jle`> but still, you'd be creationg "an IO action that returns an exit code", instead of "an IO action", which sort of seems unecessarily operational
00:11:33 <quchen> Ressource allocation question. do { h <- openHandle; forkFinally (\_ -> close h) (doStuff h) } -- This isn't safe if an exception is thrown right after "openHandle".
00:11:43 <quchen> Is there a "forkBracket" function somewhere?
00:19:11 <hunteriam> why is `put s = state (\_ -> ((), s))` instead of `put s = state $ const ((), s)` in https://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control-Monad-State-Class.html#put
00:19:47 <jle`> hunteriam: probably stylistic
00:19:58 <hunteriam> const is not better?
00:20:01 <liste> you can see the relation to "get" that way
00:20:15 <jle`> why not put s =     state   $ (\q ->  (const () "hello",        id s)) ?
00:20:44 <hunteriam> longer?
00:20:57 <hunteriam> have been told const is preferred
00:21:10 <jle`> longer doesn't always mean worse :o
00:21:22 <hunteriam> its impossible to rigorously define worse
00:21:39 <jle`> i think it's just a stylistic thing, either one would work
00:21:43 <jle`> const would be inlined to the first thing, anyway
00:21:56 <jle`> sometimes `const` gives more readable code, sometimes \_ -> does
00:21:59 <liste> hlint complains about using \_ though :(
00:22:18 <jle`>  i do like using \_ -> when i'm contrasting it with other lambda's nearby
00:22:18 <liste> unless you configure it not to
00:22:19 <timothyh> hlint is trying to rigorously define worse
00:22:28 <`Guest00000> why is hlint is named hlint and not hint?
00:22:36 <liste> hint is a different thing
00:22:38 <timothyh> seo, i bet
00:22:40 <jle`> it looks like that's what they're doing here, specifically
00:22:43 <`Guest00000> oh..
00:23:11 <kadoban> `Guest00000: Because what it does is called 'lint'ing.
00:23:13 <`Guest00000> hm
00:23:18 <liste> @hackage hint -- this is for executing Haskell code at runtime ("haskell interpreter")
00:23:18 <lambdabot> http://hackage.haskell.org/package/hint -- this is for executing Haskell code at runtime ("haskell interpreter")
00:24:35 <jle`> hunteriam: i guess if you're asking "why did the author decide to do that", it'd probably be to draw a parallel/contrast with the definition of get, but if you're asking "why is this the better way to write it?" the answer is that, either way is just as good
00:24:47 <hunteriam> thanks
00:25:00 <hunteriam> im trying to do something that i dont think is currently possible
00:25:11 <hunteriam> I want to use monad notation for function composition
00:25:15 <jle`> do it first and then wonder if it's possible after
00:25:18 <hunteriam> i know its not a monad
00:25:23 <hunteriam> but i want to use do
00:25:29 <jle`> you can use do to compose (a -> a)'s
00:25:35 <`Guest00000> in future, when choosing a name, i will think about whether a name would be better for some other thing than mine.
00:25:36 <hunteriam> jle`: what?
00:25:36 <jle`> using Writer (Endo a) ()
00:25:50 <hunteriam> jl:o
00:25:50 <`Guest00000> and choose name more carefully.
00:26:13 <jle`> myChain = execWriter $ do
00:26:17 <jle`>   tell $ Endo f
00:26:19 <jle`>   tell $ Endo g
00:26:23 <jle`>   tell $ Endo h
00:26:30 <jle`> that should be the same as myChain = f . g . h
00:26:38 <quchen> +runEndo
00:26:44 <jle`> ah yeah.
00:26:56 <`Guest00000> kadoban: we get "hint" by replacing 'l' with 'h' in "lint"... so "hint" is as related to "linting"
00:26:57 <jle`> you'd probably want to alias (tell . Endo) if you're doing a lot of this style
00:27:23 <`Guest00000> jle`: tellEndo = tell . Endo
00:27:28 <jle`> mhm
00:27:42 <quchen> let (.) x = tell Prelude.. Endo
00:27:44 <jle`> #define tailEnd (tell . Endo)
00:27:53 <jle`> {-# LANGUAGE CPP #-}
00:28:25 <`Guest00000> if i wrote a thing which would do "linting", and could choose between naming it hlint ot hint, i would choose hint
00:28:56 <jle`> `Guest00000: i try doing that all the time and i end up in naming paralysis
00:29:24 <liste> github name generator solves that ; )
00:29:31 <`Guest00000> jle`: which is not bad.
00:29:35 <Cale> `Guest00000: hint is also a thing though
00:29:43 <`Guest00000> more time spent thinking, the better name.
00:29:51 <jle`> but less time getting stuff done
00:30:02 <jle`> sometimes i spend three months thinking of the name and then two days writing it
00:30:04 <`Guest00000> better stuff vs. more stuff
00:30:11 <jle`> when i could ahve written it in two days and used it for three months
00:30:22 <Cale> `Guest00000: It's a library which wraps the GHC API to provide a more convenient way to use it as an interpreter. :)
00:30:24 <`Guest00000> jle`: don't name that thing then?
00:30:40 <jle`> but it needed a name
00:31:11 <Cale> Name it after a zany sound effect
00:31:17 <Cale> GHC has zonking
00:31:22 <Cale> because that's the sound it makes
00:32:01 <quchen> Can I hear zonking somewhere?
00:32:33 <`Guest00000> Cale: but i wrote "if i could".
00:32:33 <Cale> Probably in some talk by SPJ
00:33:12 <jle`> i don't know about you but i hear an audible zonk every time i run ghc
00:34:07 <zd234> is there a way to tell "cabal fetch" "install in this directory instead of ~/.cabal" ?
00:35:09 * Cale finds an old GHC commit "Remember to zonk the skolems of an implication. Their kinds may contain kind unification variables!"
00:35:41 <quchen> Cale: Is it a sound only SPJ can make?
00:35:47 <frerich> I suppose that no longer applies since the skolems have been frobnicated by now.
00:37:10 <hunteriam>  ~(a, w)  <- runWriterT m'
00:37:15 <hunteriam> what is ~?
00:37:41 <quchen> hunteriam: "irrefutable pattern"
00:37:47 <EvanR> is zonking a step in a unification algorithm
00:38:18 <hunteriam> quchen: as in this is definitely the pattern?
00:39:09 <jle`> yeah, it doesn't resolve the constructor before going on
00:39:14 <jle`> to "check"
00:39:30 <jle`> > case Nothing of ~(Just x) -> 100
00:39:31 <lambdabot>  100
00:39:55 <jle`> it doesn't check if the thing is Just or Nothing or not before going down the branch
00:40:25 <hunteriam> > do ~(x) <- Nothing; return x;
00:40:27 <lambdabot>  Nothing
00:40:41 <jle`> "checking" involves doing enough evaluation to resolve the constructor
00:40:48 <jle`> > case undefined of (x, y) -> x
00:40:50 <lambdabot>  *Exception: Prelude.undefined
00:40:52 <jle`> > case undefined of ~(x, y) -> x
00:40:54 <lambdabot>  *Exception: Prelude.undefined
00:40:57 <jle`> oops
00:40:59 <hunteriam> is it a compiler optimization?
00:40:59 <jle`> > case undefined of (x, y) -> 100
00:41:00 <Jinxit> is FRP useful for program control flow if IO isn't involved?
00:41:01 <lambdabot>  *Exception: Prelude.undefined
00:41:08 <jle`> > case undefined of ~(x, y) -> 100
00:41:09 <lambdabot>  100
00:41:29 <jle`> in the first one it has to resolve that the constructor is (,) before going on, in the second one, it doesn't care about resolving the (,)
00:41:34 <jle`> Jinxit: yes! :O
00:41:37 <hunteriam> case undefined of ~(x,y) -> x
00:41:40 <hunteriam> > case undefined of ~(x,y) -> x
00:41:41 <lambdabot>  *Exception: Prelude.undefined
00:41:55 <jle`> Jinxit: FRP itself is actually unrelated to IO
00:42:12 <jle`> hunteriam: in that case it needs to eventually evaluate `x`, which requires resolving the (,)
00:42:23 <Jinxit> I thought it was a good way of connecting IO to the rest of the code
00:42:28 <Jinxit> probably incorrect
00:42:49 <jle`> it's a good way of specifying programs (which can be IO actions) without reasoning about things imperatively
00:42:58 <jle`> but "x is a good way to do y" doesn't mean "x can only do y"
00:43:07 <Jinxit> true
00:43:25 <Jinxit> I keep hearing conal say that most implementations are disregarding the theory
00:43:29 <Jinxit> (continuous time etc)
00:43:31 <jle`> FRP itself is unrelated to IO, but people have had success using it to describe IO nicely
00:43:57 <Jinxit> does that actually matter?
00:44:00 <jle`> but a lot of people use FRP and related concepts for things unrelated to IO
00:44:08 <jle`> well, your question was if FRP can be useful for things that don't involve IO
00:44:13 <jle`> so, the answer is yes
00:44:22 <Jinxit> yeah, now I'm asking the next question :)
00:44:36 <jle`> oh, about implementations disregarding the theory?
00:45:01 <Jinxit> yeah
00:45:09 <jle`> well, if the implementations are practical and let you do good things, then i can't say that the existence of those implementions are a bad thing in the world
00:45:30 <jle`> but one problem is that calling them "FRP" does dilute the meaning of the word
00:45:50 <Jinxit> are there any "pure" implementations?
00:45:52 <jle`> as in, if we start calling imperative programs "functional programming"  ... i mean, the aren't functional, but it's the english language
00:46:03 <jle`> so then the word functional stops becoming meaningful
00:46:07 <jle`> and stops becoming useful
00:46:11 <jle`> (to an extent, this has already happened)
00:46:19 <Jinxit> or is "pure" FRP not practical maybe?
00:47:08 <jle`> there is a deeper problem -- that FRP itself offers a lot of great tools for equational reasoning, program optimizations, simplifications, theory, mathematical aspects you can take advantage of to rewrite your code, prove things about your code, make it faster, etc.
00:47:42 <jle`> so, if your implementation is "pseudo-FRP", and it lets you do things well, then cool, but you're missing out on one of the biggest "advantages" of FRP in the first place
00:47:51 <Jinxit> yeah I've been watching talks and everyone speaks of the beautiful theory
00:47:55 <Jinxit> but then nobody shows code
00:48:06 <jle`> there are a lot of FRP implementations that could be called 'correct enough'
00:48:10 <jle`> and that are practical
00:48:11 <Jinxit> and nobody mentions good implementations
00:48:12 <merijn> Jinxit: That's because getting FRP right is hard
00:48:25 <Jinxit> so has anybody done it?
00:48:45 <Jinxit> or gotten close?
00:48:47 <fr33domlover> Jinxit, there is a wealth of FRP(-related) packages in Hackage to go through :)
00:48:51 <jle`> i think that sodium, reactive-banana, reflex, etc. try their best to stick to the denotative semantics of FRP
00:49:01 <merijn> Conal was working on it, and got quite far but is nowadays working on haskell for hardware/SoCs
00:49:20 <Jinxit> fr33domlover: yeah, but when I'm not 100% on how it /should/ work it becomes difficult to pick them out
00:49:22 <jle`> some things that are "called FRP but are clearly not FRP at all", like Elm, have now changed their descriptions to be "inspired by FRP" instead of "is FRP"
00:49:43 <merijn> Jinxit: I can highly recommend the Push-Pull FRP paper and original FRAN paper by Conal
00:49:56 <jle`> 'netwire' is also a decently faithful implementation of FRP that's performant but optimized for different use cases than reflex/sodium/etc.
00:50:22 <Jinxit> merijn: in that order?
00:50:31 <jle`> so I would say that actual FRP is possible to implement, but there's definitely a space to innovate/explore
00:50:31 <merijn> Jinxit: http://conal.net/papers/icfp97/ http://conal.net/papers/push-pull-frp/
00:50:32 <Jinxit> jle`: thanks, I'll check them out
00:50:45 <Jinxit> thanks
00:50:46 <merijn> Jinxit: I'd try Push-Pull first and use FRAN as a fallback if you get lost
00:51:07 <merijn> Jinxit: Push-Pull is more in-depth, iirc, but if you need some context FRAN might help
00:51:24 <jle`> honestly the actual ideas of FRP are extremely simple, so most implementations are either "so blatantly wrong that they're not even trying", or "they try and are aware, and have small edge cases where things might be off slightly even though they try"
00:51:44 <jle`> when people say that FRP implementations disregard the theory, they're usually referring to the first case
00:52:35 <Jinxit> yeah exactly because it sounds so simple is why I've been confounded as to why there hasn't been any "definitive" implementations
00:52:40 <jle`> and with the second case, you definitely get the nice equational reasoning advantages that follow from the theory, if you are aware that sometimes things won't be perfect.  but that's the same case as Haskell, too
00:53:17 <jle`> Haskell is supposed to have a lot of nice denotative properties that give you equational reasoning tools, but usually they're only if you "ignore bottom", or something like that
00:53:33 <Cale> It's really not so easy to do it well and get good performance at scale.
00:53:37 <Jinxit> ah yeah
00:54:02 <Jinxit> I care less about performance in this case and more about correctness of my code
00:54:03 <merijn> Jinxit: The biggest problem is time leaks, i.e. not having to store past stuff indefinitely to get correct behaviour
00:54:11 <Jinxit> (even though I see the need for performance, of course)
00:54:26 <merijn> Jinxit: And getting rid of those while not losing power is tricky
00:54:44 <merijn> jle`: Fast and Loose Reasoning is Morally Correct! :p
00:55:39 <jle`> to me it might not also make sense to have a "definitive implementation", becuase FRP to me is more about a language to state ideas in, rather than a roadmap to an implementation
00:56:03 <jewels> Hi there. I need to define a Functor instance for a type which has multiple type parameters. At the moment I'm not able to set a constraint on both of them. Can you help me with this code? Here is the link: http://lpaste.net/150293
00:56:06 <jle`> so in a way it might be like asking for a "definitive implementation" of sets, integers, etc.
00:56:20 <hunteriam>  is this idea dumb?
00:56:33 <Jinxit> maybe I should say "one that makes full use of the theory" instead
00:56:43 <Jinxit> ~words~
00:57:02 <hunteriam> instead of needing data Endo a = e  (a->a), we could just have some type level anonymous function like (\a -> (a->a)) which would still have kind * -> *
00:57:23 <merijn> hunteriam: Type level functions make typechecking undecidable
00:57:25 <jle`> jewels: you can't have an `fmap` that only works for constrained types
00:57:39 <jle`> er, where the last type is constrained
00:57:46 <jle`> Jinxit: think about the type signature for fmap
00:57:54 <jle`> fmap :: Functor f => (a -> b) -> f a -> f b
00:57:56 <merijn> hunteriam: So, conceptually you could (and some language do let you), but it would break haskell pretty badly, i.e. no more type inference
00:58:11 <hunteriam> Its undecidable in general?
00:58:16 <jle`> if a and b had to be constrained, fmap might have different type signatures for each instance
00:58:19 <hunteriam> Undecidable in idris?
00:58:39 <merijn> hunteriam: It undecidable unless you restrict yourself to total functions
00:58:40 <Cale> Yeah, one of the main lessons we learned while struggling to get good performance out of our earlier FRP systems while working on Blood Knight (and which has been carried through to reflex) is that when you see a semantic model like Time -> a for Behaviour a, it's tempting to put in lots of operations which make assumptions about the structure of Time there which can make it easy to write performance-destroying bugs wh
00:58:40 <Cale> en you go to use the system.
00:58:54 <merijn> hunteriam: But haskell allows recursive types, so type level functions would be Turing complete
00:59:02 <jle`> jewels: fmap is supposed to be, at its heart, a way to lift an (a -> b) with *any* a and *any* b, not just some satisfying some constraints
00:59:19 <merijn> hunteriam: So decidability of type checking in haskell + lambdas would boil down to Halting problem :)
00:59:26 <hunteriam> damnit
00:59:28 <jle`> Jinxit: so it's supposed to be able to lift an (Int -> Bool), or a (String -> (Bool -> Int)), etc.
00:59:31 <jle`> *jewels
00:59:48 <Jinxit> Cale: what kind of assumptions?
01:00:00 <merijn> hunteriam: Idris with totality checker could get away with it, but then Idris already has type level lambdas (I'm assuming, since it's dependent anyway)
01:00:06 * hackagebot flaccuraterip 0.3.5 - Verify FLAC files ripped form CD using AccurateRip"  https://hackage.haskell.org/package/flaccuraterip-0.3.5 (NicolaSquartini)
01:00:18 <hunteriam> Side note, I cant find the Monoid instance of Endo in source code anywhere.
01:00:18 <hunteriam> Its not where its meant to be (https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#line-82) nor anywhere in that file
01:00:32 <jle`> hunteriam: it's probably in Data.Monoid
01:00:34 <hunteriam> merijn: idris undecidable?
01:00:53 <jle`> hunteriam: ghci should tell you :o
01:00:54 <jewels> jle`: Ok. But is there a way to solve my problem? According to the code that I have linked, do you have any suggestion?
01:00:58 <jle`>  :i Endo
01:00:58 <merijn> hunteriam: If you keep the totality checker it's decidable
01:01:06 <hunteriam> jle`: its said GHC.Base
01:01:07 <Cale> Jinxit: Well, if Time is sort of like the real numbers, it might make sense to be able to do things like delay the occurrences of an Event by some delta -- this actually is an important operation, but you really need to be careful about it!
01:01:08 <jle`>   > instance Monoid (Endo a) -- Defined in 'Data.Monoid'
01:01:14 <jle`> hunteriam: huh that's interesting
01:01:20 <merijn> Data.Monoid too
01:01:43 <merijn> ghci just reports where it got it from, so if you import GHC.Base (from which Data.Monoid presumably reexports) it'll say that
01:01:44 <Jinxit> Cale: since you've used it in practice, do you feel the benefits would be as big if the problem itself isn't realtime?
01:01:44 <jle`> jewels: you can't implement a Functor instance for it, because even "if you could", a lot of code would stop making sense
01:01:46 <Cale> Jinxit: Also, the identity function Time -> Time makes it seem like a very reasonable thing to have currentTime :: Behavior Time laying around
01:01:51 <Jinxit> trying to figure out where FRP is and isn't useful
01:01:53 <jle`> jewels: the best solution is to not make it a Functor
01:02:06 <jle`> jewels: and to just write a "mapFuzzySet"
01:02:15 <jle`> (and use that instead of fmap)
01:02:15 <hunteriam> merijn: Data Monoid on hackage is giving me source from GHC.Base and it doesnt include Endo
01:02:25 <merijn> Jinxit: Talking to the right person then, considering Cale used to work on an FRP action-RPG ;)
01:02:34 <Jinxit> that's why I asked :)
01:02:38 <merijn> hunteriam: Old link?
01:02:44 <merijn> hunteriam: https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Monoid.html#Endo
01:02:44 <Cale> While currentTime was actually responsible for some of our worst performance issues in practice -- just working around having to use it helped improve things over and over.
01:03:07 <hunteriam> merijn: weird!
01:03:10 <Cale> The reason is that currentTime, and anything whose value depends on it, is perpetually invalidated -- it must be recomputed all the time.
01:03:22 <Jinxit> ah
01:03:32 <Cale> It's the enemy of caching
01:03:47 <Cale> and the key to these systems is doing caching well
01:03:55 <jle`> maybe you could reify dependence on time
01:04:12 <merijn> hunteriam: Google often points to old versions of the docs
01:04:54 <merijn> hunteriam: If you use Chrome there's a Hackage-Fu extension that inserts warnings on old docs and a quick link to the latest version
01:05:06 * hackagebot ghc-typelits-extra 0.1.1 - Additional type-level operations on GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-extra-0.1.1 (ChristiaanBaaij)
01:06:27 <hunteriam> merijn: cool
01:06:31 <jle`> i wonder if it's time to start targeting ghc 8.0
01:06:50 <Cale> Which is not to say that you can't have things which change all the time, but you want to be wary of them. If you have operations which introduce new times at which events fire, you really have to be careful, because events are firing more frequently than you can compute the values of the stuff you need to compute, then your system lags behind and more and more unfinished work piles up.
01:12:53 <hunteriam> how do i change the editor that :e in ghci uses?
01:12:53 <Cale> So, in Reflex.Dom.Time, the main things you're given to work with are lossy timers, which drops occurrences if the system starts running behind. Sure, it's denotationally a bit messy, but it's something built on top of the FRP system (via interaction with the driver that's running it). The denotationally cleaner alternative of being able to create timers with arbitrary intervals is quite dangerous to soft real-time per
01:12:54 <Cale> formance, and obviously a lossy timer is impure.
01:13:24 <Cale> So you kind of have to treat such things as input to the system.
01:13:52 <Jinxit> what if you're not working with real-time problems?
01:13:59 <Jinxit> think more like a turn-based game
01:14:07 <MasseR> hunteriam: probably $EDITOR env variable
01:14:13 <Cale> Jinxit: In that case, you don't have to worry so much
01:14:22 <Jinxit> is FRP still a useful tool?
01:14:25 <Cale> Jinxit: Probably you don't even have a continuous notion of time there
01:14:30 <Jinxit> yeah
01:14:42 <Jinxit> so I could maybe use natural numbers instead of reals?
01:14:53 <hunteriam> MasseR: on windwos*
01:15:04 <MasseR> hunteriam: Oh. No idea
01:15:52 <hunteriam> its :set editor __, but its temporary
01:16:28 <Cale> Jinxit: Yeah, though in Reflex, there aren't even necessarily time values in an implementation of the interface.
01:16:28 <jle`> Jinxit: if you're just describing turn-based logic, then frp wouldn't be a useful tool
01:16:34 <hunteriam> is there a ghci startup config anywhere?
01:16:42 <Cale> I'm not sure I agree that FRP wouldn't be useful
01:17:05 <jle`> it might be overkill, at least
01:17:08 <Cale> It may still be quite useful for arranging a complicated state machine
01:17:25 <Jinxit> I mean, I'm working with a lot of state, but not necessarily a state machine
01:17:28 <Cale> Even with discrete time, things can change in pretty complicated ways
01:17:45 <Cale> I mean in an abstract sense
01:18:02 <jle`> yeah, i wouldn't manage it all manually
01:18:26 <jle`> there are some libraries that present a denotative approach to talking about things like this where "time" is discretized
01:18:38 <Cale> You're providing these sequences of inputs to your game, and complicated stuff happens involving lots of changes to internal pieces where some updates trigger others, and outputs are happening
01:18:54 <Jinxit> exactly
01:18:54 <jle`> yeah, but i'd feel like that's sort of a ... degenerative use case of FRP
01:19:19 <Cale> FRP really is just a way to help manage that mess and ensure that you're making updates in a consistent fashion
01:19:19 <jle`> what you essentially have is FRP with only events, no behaviors
01:19:31 <Cale> There may still be behaviours!
01:19:49 <jle`> but, not in your logic?
01:19:54 <Jinxit> right now everything is just in State
01:20:00 <jle`> yes, don't do everything in state
01:20:14 <Cale> Behaviours are still different from events in terms of how they can be used, even if in the end, you use a discrete model of time
01:20:17 <Jinxit> well, of course not everything, but many things
01:20:21 <Cale> You're not allowed to ask when a behaviour updates.
01:20:45 <Cale> You can only determine its value at times that an event which is in scope is firing.
01:21:03 <Cale> So it *might* be changing continuously
01:21:10 <Cale> and you can't tell
01:21:18 <jle`> but "continuously" doesn't even have a meaning in this context
01:21:29 <jeeger> Thanks for your help yesterday! I had totally forgotten about my question...
01:21:43 <jle`> idk it's for situations like this that i wrote `auto`
01:21:53 <Jinxit> auto?
01:21:59 <cocreature> @hackage auto
01:22:00 <lambdabot> http://hackage.haskell.org/package/auto
01:22:01 <cocreature> that one
01:22:27 <Cale> Well, any description of what's going on will tend to have multiple implementations -- whenever there's a discrete-time model, there's also going to be a continuous-time model
01:22:40 <Cale> (even if you didn't need it)
01:22:50 <jle`> yeah, it's for managing complicated transitions and "turn-based streams" in a denotative framework, without the concept of continuous time
01:23:02 <jle`> ^ Jinxit 
01:23:20 <Cale> and even if *you* know that time is discrete or continuous, the functions you write don't necessarily
01:23:52 <Cale> They still just get Behaviors and Events
01:23:57 <Cale> and turn them into others :)
01:25:35 <Cale> It is quite reasonable to imagine that not everything in your system is going to have access to a global clock event which ticks on every time step (in fact, you should probably avoid that if you care about performance, even in the discrete case)
01:26:17 <jle`> i feel like for something like writing the logic for a turn based game, all you're going to be working with is events
01:26:26 <jle`> the fact that behaviors also exist might convolute the denotation
01:26:41 <jle`> you're trying to find a way to "denote"/describe the logic of your game
01:26:43 <Jinxit> looking at auto atm
01:27:01 <jle`> not to find a way to implement your game on top of a framework
01:28:15 <Cale> jle`: Well, okay, I do admit if the system is small enough, then probably just making everything an Event (or more likely a Dynamic) is going to be fine
01:28:45 <jle`> i'm still not seeing how a behavior is semantically meaningful, though
01:28:57 <Cale> Behaviors are still fundamentally the way that you remember things between occurrences of events
01:29:09 <Cale> If you only have the Event fragment of the system, you don't have hold
01:29:19 <Cale> and your system is stateless
01:29:42 <Cale> At least, this is true of reflex and the other FRP systems I've worked on
01:29:50 <jle`> okay, so your behaviors have to exist for you to implement your thing in FRP, but they are semantic noise
01:29:57 <Cale> I don't think they are
01:29:59 <jle`> they aren't involved in the logic of whatever you're specifying
01:30:29 <Cale> You need a way to carry information from the firing of one event, forward through time, to a following occurrence of a possibly different event
01:30:45 <Cale> For that, you need values which exist at all times, and not just at particular ones
01:31:36 <jle`> i si see waht you mean, but to me, that feels like a mathematical trick that can bring discrete time semantics to work inside continuous time semantics
01:31:52 <jle`> like an embedding
01:32:06 <Cale> Well, it's also important to what the implementations are doing to make everything efficient
01:32:17 <jle`> if you really want to describe/denote a discrete time game, you want to work with discrete time logic
01:32:19 <Cale> Behaviors are stuff which gets polled
01:32:23 <jle`> not discrete-time-logic-embedded-into-continuous-time
01:32:36 <jle`> like doing integer math using Double
01:32:54 <Cale> But there is no Double
01:32:58 <Cale> Right?
01:33:14 <Cale> I'm sort of assuming that you're familiar with what Reflex's basic operations look like
01:33:40 <jle`> i mean it like an analogy; if you're a number theorist trying to prove properties about integers, you are going to be working with integers, not working wouth real numbers
01:33:40 <Cale> There's nothing in there which reveals in any way what time "is" -- it can even branch
01:34:01 <jle`> i'm talking more about the denotation aspect than the implementation, heh
01:34:13 <Cale> When we finally get down to writing what the laws are, there will be nondetermistic models of reflex :)
01:34:29 <tdammers> the way I see it, you have your FRP network that is programmed for continuous time, but, by necessity, you drive it from an outside context that is, by necessity, discrete
01:34:39 <Cale> (i.e. ones whose notion of time is tree-like)
01:34:50 <Jinxit> jle`: you say that auto is not imperative, but isn't that in the same way as State isn't imperative?
01:35:06 <jle`> using State is inherently imperative
01:35:18 <jle`> you state your program by describing how state changes and transforms
01:35:33 <jle`> in `auto`, you state your pgraom by describing streams and operations on streams, compositions of streams, as mathematical ideas
01:35:46 <jle`> (that's the same thing as in FRP, btw)
01:36:15 <Cale> jle`: You can look at it this way: the FRP system is really a way to use a whole bunch of IORefs to get good performance while lots of stuff is being updated repeatedly, in a way which is safe and consistent and where you can't tell that all this is going on.
01:36:20 <Jinxit> but to me the code looks the same
01:36:41 <Cale> From that perspective, it doesn't matter whether time is continuous or discrete
01:36:43 <jle`> tdammers: that's a different story altogether, though; FRP isn't about the thing you drive it from the outside.  the analogy is, vector graphics have to be rendered as bitmaps anyway, so why bother with vectors?
01:36:46 <Jinxit> (not looked in-depth yet of course)
01:36:56 <jle`> Jinxit: hm, how so?  which examples are you talking about?
01:36:56 <tdammers> jle`: that is kind of my point
01:37:15 <Cale> and Behaviour is still very important, because events that are firing constantly are going to force lots of computation to happen constantly
01:37:19 <Cale> and you might not want that
01:38:37 <jle`> it looks like you're saying that the behavior is important for the implementation
01:38:48 <jle`> but not for the denotation/description of actual game logic
01:38:51 <Cale> Everything is important
01:39:48 <Cale> The denotational models are important, the algebraic laws that the system abstractly satisfies are important, and the implementation mechanisms which obtain good performance are too.
01:39:57 <Jinxit> jle`: sorry, I see some differences now. but I guess it's not very different if you're only interested in the "last" timestep? as opposed to the entire history (as a fold)
01:39:59 <jle`> you can embed a discrete time denotation into a continuous time denotation, for sure
01:40:23 <Cale> jle`: Maybe stop thinking about denotations for a moment, because they're all lies, right?
01:40:35 <Cale> jle`: Well, apart from the denotation which is in terms of IO actions
01:40:42 <Cale> hah
01:41:08 <Cale> It's good to have denotational models
01:41:26 <jle`> Jinxit: the difference is how you state your ideas.  in auto and in FRP, you have definitions and "pure" functions on definitions, compositions of definitions, transformations of definitions, etc., and you work with those ideas
01:41:40 <jle`> if you're using State, you work with mutating things in certain points in time
01:41:54 <jle`> and your result is the end of those mutations
01:42:08 <Cale> But it's really the algebraic properties of the system which are more relevant.
01:42:26 <Cale> (we should be writing these down, but it's hard to determine what they all are)
01:42:29 <jle`> Jinxit: with auto and FRP, the advantage is that you get a system that is easier to talk about by just talking abotu the ideas and how they interact, without worrying about implementations, states, things like that
01:42:37 <jle`> and you can refactor, etc.
01:42:41 <Cale> Or what they all should be
01:42:42 <Jinxit> hm
01:43:00 <jle`> Jinxit: you can implement the same things in both, but the import thing is how you work with the ideas and talk about the ideas
01:43:38 <jle`> Jinxit: i said this earlier, but it's like vector graphics and bitmaps.  eventually a vector graphic will be "equivalent" to a bitmap, once you export it or render it to a file.  but the important thing is that vector graphics allows you reason about lines as if they were lines, not as if they were discrete dots
01:43:56 <jle`> and you can manipulate lines by scaling them, making them thicker, etc. --- working with them as if they were *lines*
01:44:16 <pharaun> i'm too tired, i parsed that as "by scalping them,"
01:44:43 <fr33domlover> can anyone plz give an example for defining a Monad that is ContT on top of IO? Something like this: type M = ContT r IO except I'm not sure what 'r' should be
01:45:28 <jle`> Cale: i definitely get the feeling that we're sort of talking about different things, though
01:45:32 <jle`> heh
01:46:00 <Cale> jle`: I mean, you just gave a perfectly good analogy for why you'd still want Behaviors in a system where time is actually going to end up being discrete
01:46:26 <jle`> you mean the vector one?
01:46:29 <Cale> yep
01:46:33 <hunteriam> fr33domlover: "Cont r a is a CPS computation that produces an intermediate result of type a within a CPS computation whose final result type is r."?
01:46:53 <jle`> well, yeah, because you use vector graphics in a situation where lines, shapes, etc. are meaningful ideas and things to manipulate/denote
01:47:01 <EvanR> jle`: so from what i read, you are basically saying that auto or an honestly discrete model / language is useful for cases when "I'm really just thinking of this thing as being discrete", like the number theory analogy
01:47:01 <fr33domlover> hunteriam, i read that but i'm still not sure... :P
01:47:26 <jle`> EvanR: yes, it's a set of denotative semantics for reasoning with discrete-time processes
01:47:34 <fr33domlover> in examples i see, functions have a type like ContT r IO String etc.
01:47:39 <Cale> jle`: Behaviors are like your shapes in that analogy, and their values at the times taken by the discrete clock are the "rasterization"
01:47:45 <fr33domlover> so I'm not sure what do use for 'r' in my monad
01:47:46 <EvanR> but video games with graphics and interactivity, would you say thats really how youd want to think of that?
01:47:53 <jle`> EvanR: not with realtime games
01:47:56 <EvanR> ok
01:47:58 <Cale> jle`: But when you're rasterizing shapes, sometimes one will obscure another
01:48:18 <jle`> Cale: it's more of an example of how the *denotation* might be different from the actual hard implementation, but picking the right denotation is the more useful thing
01:48:20 <Cale> jle`: You might avoid having to rasterize the entirety of some shape because it's mostly covered up
01:48:21 <EvanR> jle`: whats an example where this discrete version makes more sense?
01:48:22 <Cale> right?
01:48:41 <hunteriam> I can write a `m a -> (a -> m a) -> m a`, and `m a -> m a -> m a`, is there a way to use these in do notation?
01:48:50 <jle`> yes, but there are some situations where having lines, vectors, etc. isn't even meaningful
01:49:05 <Jinxit> EvanR: we've been talking about turn-based games
01:49:18 <Cale> jle`: Yeah, we're making an analogy here between graphics and FRP
01:49:34 <EvanR> the game part of the turn based game is discrete right, but what about the UI
01:49:41 <jle`> EvanR: a chatbot is another sort of the 'canonical' example i've been using
01:49:49 <jle`> where things are just updated every incoiming message
01:50:15 <Jinxit> EvanR: personally I would prefer to separate the game logic from the UI
01:50:21 <EvanR> right
01:50:23 <jle`> Cale: yeah, FRP:vectors :: game loop : bitmaps
01:50:43 <EvanR> Jinxit: so were just talking about the implementation of game rules...
01:50:51 <jle`> but vectors aren't a good system for every type of graphic
01:50:53 <EvanR> seems like FRP isnt on topic
01:50:54 <Jinxit> at least I was :)
01:51:06 <Jinxit> we're also talking about 'auto'
01:51:08 <Cale> jle`: But also  Behaviors : vector descriptions :: underlying clock : bitmaps
01:51:08 <hunteriam> fr33domlover: what are you trying to do with it?
01:51:19 <Jinxit> as a "discrete FRP"
01:51:24 <Gurkenglas> hunteriam, what do you mean? Presumably not "How do I write them using do notation?".
01:51:48 <EvanR> jle`: when I think of a "large complex network of stream processing" i think of the horror that is enterprise integration patterns
01:51:50 <Cale> jle`: When you have your vector descriptions of the geometry, you can do clever things to determine what parts of shapes are obscured and what really needs to be rasterised in the final image
01:51:53 <hunteriam> Gurkenglas: I have those two functions for my type, can I use those as substitutes for `then` and `bind` in co notation?
01:51:57 <hunteriam> *do
01:52:03 <hunteriam> Its not a monad
01:52:11 <fr33domlover> hunteriam, define a monad (using a newtype that hides the ContT) where, among other things, the user can allocate resources using functions similar to withFile
01:52:16 <Cale> jle`: Just as when you have a description of what's taking place in terms of Behaviours, it's easier to tell when you *don't* need to compute something
01:52:52 <Cale> jle`: Does it make sense what I'm trying to get at here?
01:53:30 <jle`> i see what you mean ... aspects of your discrete time thing might not always be updated at every discrete time "update"/tick
01:53:38 <Cale> right
01:53:56 <EvanR> Jinxit: even if its a turn based game, but theres the possibility of two players making a move asynchronously, like in "uno", you could simply do a simple rules-based transformation of the game state, based on the move, with a transaction
01:53:58 <Cale> you only really want to worry about the small handful of things which are actually changing
01:54:33 <Cale> and you want to know what things are relevant to cache for the future and what things are only relevant now
01:54:54 <jle`> i don't think that'd be a hard thing to implement straight from a discrete time denotation, though
01:54:54 <Cale> and that's exactly the distinction between Behaviour and Event as well
01:55:02 <Jinxit> well if you can act out of turn it's not really turn-based, but I see your point
01:55:08 <Gurkenglas> hunteriam, could you define fmap and pure for your m, and generalize your two functions so they would work as >>= and >>, and the monad laws would hold? If so, you can define a newtype wrapper for m a and define your own monad instance.
01:55:21 <jle`> but yes, i see that that does mean that behaviors are still *useful* when using FRP to describe discrete time things
01:55:31 <hunteriam> Gurkenglas: no, monad laws would break
01:55:43 <Cale> jle`: But it is! When everything potentially updates all the time, it gets really hard to tell what is really going to update.
01:55:51 <Cale> jle`: and what you really need to compute
01:56:03 <EvanR> Jinxit: its more like the set of valid moves that could come next might not all be from the same player
01:56:21 <Cale> Data flow is cool, but it sort of gets the worst of both worlds with respect to Behavior and Event
01:56:31 <Jinxit> I disagree, since real-time matters in uno
01:56:44 <Jinxit> it doesn't in chess (unless you're playing with a clock, let's disregard that)
01:56:44 <EvanR> the real time can be separated from the game logic
01:57:00 <Cale> Everything updates every tick, and you can only tell if it's updated by looking.
01:57:12 <Jinxit> true, but then you're back in discrete time
01:57:13 <Cale> Or rather, you can only tell if it's *changed* by looking
01:57:24 <EvanR> when it comes to a point where you are asked to make a move, and someone COULD yell out, then only one thing happens, not both
01:57:30 <Gurkenglas> hunteriam, by then and co notation you mean >> and do notation right?
01:57:38 <hunteriam> yes 
01:57:47 <EvanR> Jinxit: right, its turn based, theres not really any time. its more like a sequence of transactions
01:57:55 <Jinxit> yes
01:57:58 <Jinxit> agreed
01:58:19 <EvanR> and writing the move handlers, transistions from game state to state probably doesnt need any FRP (for a card game)
01:58:22 <jle`> Cale: i still don't think that that's a *fundamental* limitation of discrete time denotations
01:58:22 <Cale> Which is sort of true of Events -- you have to make a Behavior and then observe that to determine if subsequent values are different, but in general, Events aren't going to fire for no reason
01:58:29 <EvanR> theres probably a better "card game" dsl 
01:58:42 <Jinxit> which is why jle` recommended auto
01:58:43 <Cale> and events which aren't firing can be implemented with zero cost
01:58:55 <jle`> you just have to pick the right denotation
01:59:02 <Jinxit> which operates on discrete streams
01:59:02 <jle`> but now i'm being hypothetical :p
01:59:11 <jle`> i see your point
01:59:21 <jle`> a naive translation of FRP into discrete time doesn't allow us to do this sort of reasoning
01:59:36 <EvanR> Jinxit: well maybe to implement the external interface yeah... but the game logic itself only involves one move at a time, following the rules
02:00:02 <Gurkenglas> hunteriam, https://ocharles.org.uk/blog/guest-posts/2014-12-06-rebindable-syntax.html
02:00:31 <EvanR> jle`: so pipes is a "denotative" stream processing thing, would that count as frp?
02:00:35 <Cale> jle`: I think if you go to all the trouble of finding that denotation which lets you do the reasoning, and then implement a system which is inspired by it, you'll find that it's identical to the system which we implemented for potentially continuous time as well.
02:00:57 <Cale> jle`: Because time is neither discrete nor continuous really :)
02:01:07 <Cale> It's "you can't tell"
02:01:29 <jle`> but hold on, the fact that behavior allows you to encode things that can't change sounds like like a very operational aspect
02:01:39 <EvanR> not (not continuous || not discrete)
02:01:54 <EvanR> hmm should that be an &&
02:02:34 <Cale> Yeah, time in FRP is not (not continuous)
02:02:36 <jle`> i don't think that this aspect is a part of FRP inherently
02:02:50 <Cale> That's actually a perfect way to say it :D
02:03:04 <jle`> but rather a consequence of implementation
02:03:28 <EvanR> the "you cant tell" aspect of these models is the important part to composability i think
02:03:46 <EvanR> thats the interface secret sauce
02:04:12 <Cale> Yes -- well, you can add things which throw away more discrete models
02:04:18 <jle`> but, if you were to sit down and write logic for a turn-based game, it still feels really weird to do it by writing logic for a continuous system
02:04:39 <Gurkenglas> hunteriam, btw what data structure is this for? Sets?
02:04:47 <hunteriam> Gurkenglas: Endo
02:04:57 <Cale> jle`: But you're not writing logic for a continuous system
02:05:01 <pharaun> how so?
02:05:14 <pharaun> I keep on struggling with the continuous aspect
02:05:15 <EvanR> yeah no, turn based game (like cards, boards) those are realizing rule systems
02:05:20 <Cale> jle`: You're writing logic for a not (not continuous) and not (not discrete) system :D
02:05:21 <EvanR> not doing physics
02:05:41 <Cale> (if you get what I mean by that -- I hope you do!)
02:05:41 <pharaun> ie continuous seems useful for physics
02:05:51 <pharaun> or things where you have variable tick rate, or etc
02:05:59 <Cale> The FRP primitives don't really let you discern the nature of the passage of time
02:06:14 <Cale> Oddly enough, they aren't actually really concerned with how time passes
02:06:15 <jle`> in reflex, you mean?  or in FRP
02:06:40 <Cale> I mean in abstract FRP -- not Conal's particular denotation of the language, but in the language itself.
02:06:44 <EvanR> in any case i wouldnt want to be worrying about tick rates while writing an application
02:06:47 <Gurkenglas> :exf "(a -> a) -> (a -> a -> a) -> (a -> a)" -- hunteriam, which of these are you using and why?
02:06:48 <exferenceBot> \ f1 f2 c -> f2 (f1 c) c
02:06:48 <exferenceBot> \ f1 f2 c -> f2 c (f1 c)
02:06:48 <exferenceBot> \ f1 f2 c -> f1 (f2 c c)
02:06:51 <hunteriam> @where paste
02:06:52 <lambdabot> Haskell pastebin: http://lpaste.net/
02:07:16 <Cale> jle`: If you just take the primitives and the fundamental combinators, well, it somewhat depends on which combinators you choose
02:07:48 <EvanR> the language itself?
02:07:51 <Cale> jle`: But if you take the usual ones that everyone agrees on, you get something from which you can't discern the precise nature of time
02:07:56 <jle`> any denotation has to be consistent with type Behavior a = Double -> a, type Event a = [(Double, a)] | sorted, though
02:07:59 <statusfailed> Is anybody using travis/circleCI to deploy Haskell binaries?
02:08:06 <Cale> jle`: sure!
02:08:23 <Cale> jle`: but that doesn't say anything about all the *other* valid denotations of the system
02:08:25 <statusfailed> if so, how do you manage the dynamic library dependencies?
02:08:40 <EvanR> Cale: are you referring to reactive?
02:08:42 <Cale> jle`: and it *heavily* overspecifies things
02:09:06 <Cale> There are *way* more operations on those types than are really allowed by FRP
02:09:25 <Cale> EvanR: I'm being intentionally vague about which FRP system I'm discussing :)
02:09:43 <EvanR> well throwing out a specific denotation is fine but
02:09:45 <Cale> EvanR: but I spend most of my time these days working in reflex :)
02:09:52 <EvanR> i was hoping something was specific somewhere ;)
02:09:53 <hunteriam> Gurkenglas: http://lpaste.net/150295
02:09:56 <EvanR> ok
02:10:13 <hunteriam> Gurkenglas: actually...
02:10:44 <Cale> These points apply to at least a good fragment of most FRP systems -- you might have to avoid certain primitives which allow you to discover the nature of time because some FRP systems don't abstract things enough
02:11:42 <EvanR> so you could take a set of combinators, and their types, and ask what is the "freeest" (???) meaning
02:11:44 <Cale> If you throw out enough operations though (but not too many), you eventually end up with something which is totally ambiguous about whether it's discrete or continuous -- it can admit implementations with continuously varying behaviours and those without
02:11:56 <EvanR> instead of starting with a denotation and building a language on it
02:12:31 <Cale> Yeah, and not necessarily freest, but freest which is consistent with the properties that we expect these things to have
02:12:50 <Cale> Or maybe you don't actually build a denotation, maybe you just write down algebraic laws
02:12:56 <EvanR> start with combinators and the laws
02:12:57 <Cale> (but that is tricky!)
02:13:08 <Cale> Denotations are ultimately a cop-out though
02:13:21 <Cale> They're an aid when we don't know what the laws ought to really be
02:13:30 <hunteriam> Gurkenglas: want to be able to write a `monad` for Endos where <- gives you the result of the function at that point and >> is composition
02:13:47 <Jinxit> jle`: mind looking at some State code?
02:13:48 <EvanR> well if the denotation is some math object you might get a bunch of laws for free
02:13:58 <Cale> I think if we put our minds to it though, it would be possible to write down enough meaningful laws for, say, reflex's operations
02:13:59 <EvanR> but i guess in practice thats hard
02:14:19 <jle`> Jinxit: sure, feel free to post it, but my mind is currently using its cycles processing this all, heh
02:14:31 <Cale> EvanR: Well, consider, say monoids
02:14:34 <EvanR> functions of a real variable arent exactly the most well-behaved thing
02:14:47 <Jinxit> https://github.com/Jinxit/firestone/blob/master/src/Firestone/Player.hs#L18-L28 "if the player has cards in the deck, draw one, but discard it if the hand is full; if the deck is empty, do accumulating damage"
02:14:53 <Cale> Sum Integer is like a "denotation" of the monoid language
02:15:07 <hunteriam> is there anyway to use `do` notation for non monads?
02:15:10 <Jinxit> roughly how would this look in a more declarative sense? (like auto)
02:15:22 <Cale> But you can get wrong ideas about monoids in general if you stare too closely at Sum Integer
02:15:50 <EvanR> Jinxit: i was actually working on a language for specifying card rules, since card games now a days come with a shit ton of card-specific rules...
02:16:02 <Cale> Free monoids are better in that regard, but if you only look at free monoids (list types), you'll also get some incorrect impressions
02:16:23 <Jinxit> EvanR: https://github.com/Jinxit/firestone/blob/master/src/Firestone/Database.hs#L54-L67
02:16:34 <Jinxit> not saying it's -the- way, but that's how I do it
02:17:20 <EvanR> but to cope with realistic card games it comes down to the cards specifying logic programs
02:17:25 <EvanR> which may not even make sense
02:17:28 <Gurkenglas> hunteriam, would your second arguments to >>= ever make v' differ from v?
02:17:34 <jle`> Jinxit: you'll have to zoom a little further out to get a translation/analogy
02:17:45 <hunteriam> Gurkenglas: what i linked you is not very useful
02:17:56 <Gurkenglas> hunteriam, what about the link I posted?
02:18:00 <Jinxit> jle`: https://github.com/Jinxit/firestone/blob/master/src/Firestone/Game.hs#L106-L119 maybe this?
02:18:07 <hunteriam> Gurkenglas: dont see it
02:18:11 <Jinxit> that's as far as it gets
02:18:16 <Gurkenglas> <Gurkenglas> hunteriam, https://ocharles.org.uk/blog/guest-posts/2014-12-06-rebindable-syntax.html
02:18:27 <EvanR> Cale: lists being an instance of all the isomorphic free monoids
02:19:02 <Cale> EvanR: yeah, that too (but not all free monoids are isomorphic to each other of course, which type of elements you pick matters)
02:19:41 <EvanR> yeah they are indexed by something
02:20:10 <EvanR> good point, concatting expressions doesnt really tell you about monoid math
02:20:39 <Gurkenglas> Wut? How can there be more than one "free" (in the universal object sense) monoid without isomoprhisms between them?
02:20:44 <EvanR> but FRP seems like something else because were not just interested in syntactic manipulations.
02:20:57 <jle`> Cale: i still feel like exposing behaviors exposes a little bit too much of implementation; i'll have to write some examples of discrete time things in reflex or a real continuous system and see how they reall interact before being able to say anything in confidence
02:21:12 <Cale> Gurkenglas: think about [()] vs. [Bool]
02:21:15 <EvanR> Gurkenglas: well people talk about "the" free monoid (over a particular alphabet)
02:21:48 <Cale> jle`: It's not really exposing anything about implementation
02:22:12 <hunteriam> Gurkenglas: how does he make the monoid instance work there? I don't see a `where` clause
02:22:15 <Gurkenglas> Oh okay I thought you were just talking about [] vs. []. (And for the record lists are not the free monoid yadda yadda)
02:22:21 <EvanR> Cale: on the other hand, i was thinking about a syntax-only frp where the denotation is literally the syntax of your program, but the syntax continuously changes ;)
02:22:22 <jle`> but, i do see that reflex etc. would be useful for writing a discrete time thing and describing discrete time logic
02:22:37 <Gurkenglas> hunteriam, "For the next couple of examples, well use the following top-level bindings:"
02:22:43 <Cale> jle`: It's just saying "there are these things which always have a value, and that value may be different whenever you look at it, but you can't be notified when it changes"
02:23:23 <Cale> (because the information of when it changes is not present)
02:23:57 <Cale> It may be continuously (or even discontinuously!) varying
02:24:34 <EvanR> maybe it changed to a value for a zero-interval of time!
02:24:39 <EvanR> and changed back
02:24:40 <Cale> In some perverse model, some behaviours might have graphs which are dense in R^2 :)
02:24:45 <jle`> right; i probably have to do some more real world mucking about to see what role that has in the description of discrete logic
02:24:57 <hunteriam> Why isnt there a `Do` typeclass with `then :: a -> b -> c` and `bind :: a -> b -> c`?
02:25:11 * hackagebot HGL 3.2.3.1 - A simple graphics library based on X11 or Win32  https://hackage.haskell.org/package/HGL-3.2.3.1 (AlanHawkins)
02:25:25 <jle`> hunteriam: what are the instances, there?
02:25:27 <Cale> jle`: I mean, you'd use them any time you have state which persists and needs to be accessed later
02:25:29 <EvanR> jle`: discrete logic, as in... imperative code?
02:25:31 <jle`> is it a multiparam typeclass
02:25:39 <hunteriam> jle`: Monad m => Do m
02:25:45 <Cale> jle`: Because you simply can't use events for that :)
02:25:52 <jle`> hunteriam: so what are the types of then and bind, in that case?
02:26:03 <hunteriam> then = >> and bind = >>=
02:26:20 <jle`> there is no 'm' in your type signatures
02:26:28 <hunteriam> ?
02:26:33 <jle`> then :: a -> b -> c
02:26:35 <jle`> where is the m?
02:26:45 <Cale> jle`: A reflex system with only Events in it is basically a sequence of pure computations each of which is entirely independent of the results of the others
02:26:59 <hunteriam> damn
02:27:33 <dramforever> Hello, I just got started with persistent and was happy about avoiding boilterplate so far
02:27:38 <hunteriam> Do m, then 
02:27:41 <Cale> (which is something I'd usually be happy to claim about FRP more broadly... but some systems break it)
02:27:53 <dramforever> however, it seems to be missing a crucial feature of databases: relations
02:27:55 <Jinxit> hunteriam: isn't that just Monad m?
02:28:32 <hunteriam> jle`: same sigs as Monad
02:28:41 <hunteriam> damnit actually no
02:29:05 <jle`> Cale: i don't mean think about how I use them, but what they would meaningfully represent in a sense other than their operational aspects, heh.  but i'll think about
02:29:28 <dramforever> For example, I can't seem to just state that "a User has many Post" and get the user's blog posts for free
02:29:38 <hunteriam> jle`: i dont actually demand polymorphic functions, Im just tryhing to talk about function structure
02:29:41 <Cale> jle`: Well... retaining things over time and knowing about the past isn't entirely an operational thing
02:30:21 <jle`> Jinxit: have to go a bit higher even, unfortunately.  "attack" is still inherently about mutating states.  try thinking about values that vary over ticks, and how those values relate to other values
02:30:26 <Cale> jle`: The only way that the future of your system can depend on its past is via behaviours
02:30:33 <jle`> Jinxit: maybe `playerHealth` would be one ... describe how player health depends on other things
02:30:51 <Cale> jle`: We're not talking about any particular implementation here
02:30:52 <EvanR> Cale: yeah like Rx, which lets you group two event streams by attaching the latest value of one to occurrences of the other
02:30:58 <Jinxit> like how it depends on previous attacks?
02:31:02 <Cale> EvanR: yeah...
02:31:10 <hunteriam> jle` Do m, then :: a -> b -> b, bind :: a -> b -> c | m -> a, m -> b, m -> c
02:31:17 <EvanR> instant memory 
02:31:29 <Cale> EvanR: of course, you can implement that operation in reflex, but it needs a Behavior to do it
02:31:43 <jle`> Jinxit: yes, express maybe how player health depends on the damages from previous attacks
02:31:48 <Cale> (internally)
02:31:55 <jle`> playerHealth <- sumFrom 100 -< attacks
02:32:01 <dramforever> Now I just have to 1. fetch the user's other data 2. fetch all posts belonging to the user and 3. combine them into a nice data type
02:32:12 <hunteriam> jle`: does it work?
02:32:18 <jle`> or rather, playerHealth <- sumFrom 100 -< attackDamage
02:32:29 <jle`> "player health is the sum of the attack damages, starting from 100"
02:32:37 <Jinxit> hm ok
02:32:56 <jle`> or if you also have healings, you can do playerHealth <- sumFrom 100 -< attackDamage + healingAmount
02:33:07 <jle`> describe values and relationships between values
02:33:17 <jle`> from here you'd have to describe how attackDamage relates to other things
02:34:17 <Jinxit> I see
02:34:32 <Jinxit> might try to rewrite it with auto just to see how it works out
02:36:55 <jle`> Cale: okay, so, behaviors represent persistent state, and events represent transitions
02:37:16 <jle`> and the frp-ness helps in that not all transitions have to occur altogether, they're not all lockstepped
02:37:39 <EvanR> or you dont have to specify how a behavior works
02:38:09 <EvanR> it could be specified externally, like a primitive is
02:39:22 <jle`> in this case i'm talking about the role of the behavior in the description of discrete time logic, and how they add to the expressiveness of the denotation
02:39:40 <jle`> i should write a turn based game in reflex to try this out
02:40:21 <EvanR> so board games and card games are naturally "written" (specified) as rules in a rulebook
02:40:23 <jle`> in this case you're not using any of the "continuous time" part of a behavior, only the fact that they tie together state for events
02:40:33 <EvanR> that seems like the best way
02:41:47 <EvanR> and some games have an hour glass, and a rule specifies when its used and how
02:41:58 <EvanR> which sort of throws discrete time out the window
02:42:10 <EvanR> but its still a turn based game
02:42:42 <jle`> well, you can separate your discrete transitions from real time aspects
02:44:20 <EvanR> maybe a synthetic holistic solution would be cleaner
02:44:40 <hunteriam> http://lpaste.net/150297
02:44:40 <EvanR> its 4:44 AM so I'm just ramblin
02:44:50 <hunteriam> Why isnt it using the instance for Do Monad
02:45:56 <latk> I want to parse a single command line argument, which will point to a config file. What is my best option ?
02:46:49 <jle`> latk: if it's a single argument, then getArgs should do; anything more complicated, then a command line argument library like optparse-applicative would help
02:47:03 <latk> jle` : Cool, thanks.
02:47:15 <frerich> latk: I'd start your 'main' with 'getArgs >>= \case [fn] -> ...; _ -> printUsage'
02:47:23 <frerich> latk: That's my poor-man's argument parsing :-}
02:47:36 <EvanR> or
02:47:42 <EvanR> do
02:47:47 <EvanR>   [fn] <- getArgs
02:47:49 <EvanR>   ...
02:48:30 <EvanR> mines poorer
02:48:30 <YellowOnion> Is there any way to use existing OpenGL libraries with GHCjs/WebGL?
02:48:53 <frerich> latk: In case your program does not read any data from stdin yet, you could also consider reading from stdin right away and invoking your program like 'myprogram < config.conf' :o)
02:49:18 <latk> frerich: Oh, that might be a better idea :)
02:49:53 <frerich> latk: In that case, you *might* find the 'interact' function useful. Depending on what your program does.
02:50:22 <jle`> hunteriam: did you try enabling FlexibleContexts like the error suggests?
02:51:10 <hunteriam> jle`: i think i can use Functional Dependency
02:51:29 <latk> frerich: Thanks, I will have a look at it.
02:52:28 <hunteriam> jle`: is there a way to say (a, c) -> b in functional dependency?
02:52:49 <jle`> a, c -> b, i think, but i'm not too great a this
02:54:19 <hunteriam> hmm
02:54:27 <hunteriam> is it definitely possible?
02:55:05 <mniip> a, c -> b
02:55:07 <mniip> indeed
02:55:11 <mniip> no wait
02:55:14 <mniip> a c -> b
02:55:35 <hunteriam> brilliant
02:55:46 <hunteriam> haha!
02:55:55 <hunteriam> can we implement this in GHC, a Do typeclass? it appears to work
02:56:23 <hunteriam> http://lpaste.net/150298
02:56:26 <hunteriam> compiles
02:58:02 <pharaun> that moment when your hacky 1000 line project finally get broken up and structured >_<
03:03:06 <hunteriam> http://lpaste.net/150299
03:03:12 <hunteriam> not sure why these are conflicting instances
03:03:49 <Gurkenglas> hunteriam, that'd make error messages less readable. Although maybe we shouldn't stop better syntax because error messages get worse, but instead increase the pressure on someone to make error messages generally better
03:03:59 <jle`> hunteriam: 'm a' matches on 'a', as well
03:04:03 <Gurkenglas> (By making syntax better and error messages worse.)
03:04:08 <jle`> `Maybe Int` matches for 'm a' as we  as 'a'
03:04:19 <jle`> in the first one, m ~ Maybe, a ~ Int, and the second one, a ~ Maybe Int
03:04:33 <hunteriam> gotcha
03:04:44 <hunteriam> maybe its for the better that the second fails
03:04:56 <jle`> the typical way people deal with this is to not have a Monad m => ... instance
03:05:08 <jle`> but have a WrappedMonad newtype wrapper and write an instance for that
03:05:25 <jle`> but that's still oging to match on `a`
03:05:53 <jle`> i think the more sane normal approach is to not write polymorphic instances and just write instances for specific types you will use
03:05:58 <jle`> that's how mtl, etc. do it
03:06:05 <hunteriam> Agreed
03:06:16 <hunteriam> Now why doesnt haskell just default to the most specific instance?
03:06:28 <jle`> is the most specific instance always the one you want?
03:06:29 <hunteriam> And raise a conflict when there are equally specific instances
03:06:38 <hunteriam> tbh no its not
03:06:59 <hunteriam> this is the same problem as multiple valid monoids for Int
03:07:03 <jle`> i think you might be able to get some mileage out of overlapping/incoherent instances, but you're still treading on dangerous territory
03:10:00 <hunteriam> jle`: is it possible to import a file and hide an instance declaration?
03:12:24 <hunteriam> does this seem worse than RebindableSyntax?
03:20:02 <jle`> it's not possible; that's why typeclasses are the worst(tm)
03:20:17 <jle`> (well, there are lots of reasons)
03:22:47 <hunteriam> jle`: if i stuck an instance declaration in a module and didnt import that module, would it work?
03:23:26 <jle`> it will be imported if you import any module that imports that module
03:26:27 <hunteriam> damn
03:40:02 <merijn> hunteriam: Because, suppose I compile code with one class in scope, then compile code that uses the same class, but has a more specific instance in scope, so I use that. Now these two separately compiled pieces are linked together
03:40:10 <merijn> hunteriam: Now every single things goes to hell
03:40:16 <hunteriam> ;_;
03:40:31 <hunteriam> if theres a way around that, this is kinda cool
03:41:00 <merijn> hunteriam: Which is why GHC needs to decide on a globally unique instance, without knowing for sure that it has seen all of them. The only way to guarantee that is: no overlap
03:41:42 <merijn> hunteriam: Scala does what you want with implicits, and every single Scala programmer I've talked to complains about how hard it is to debug
03:45:14 * hackagebot PUH-Project 0.1.0.0 - This is a package which includes Assignments, Email, User and Reviews modules for Programming in Haskell course.  https://hackage.haskell.org/package/PUH-Project-0.1.0.0 (att)
03:50:59 <hunteriam> need a little bit of advice here
03:51:59 <hunteriam> http://lpaste.net/150300
03:52:02 <hunteriam> the error is in line 36
03:52:15 <hunteriam> i dont know why its not selecting the only valid instance for use here
03:53:06 <merijn> hunteriam: Line 11 will never work out
03:53:13 <hunteriam> ?
03:53:17 <hunteriam> why?
03:53:23 <merijn> hunteriam: The 'b' in the constraint is not mentioned in the type
03:53:32 <merijn> hunteriam: And GHC will refuse to guess which 'b' you meant
03:53:33 <hunteriam> if you substitute ++ for app everything compilkes
03:53:40 <hunteriam> or are you saying thats why you cant
03:53:41 <merijn> oh, you have a fundep
03:53:47 <merijn> nvm, that might work
03:54:30 <hunteriam> it does!
03:54:38 <hunteriam> except i have to use the function `app` instead of ++
03:54:41 <hunteriam> or i get the error i listed
03:55:08 <hunteriam> but why?
03:55:37 <hunteriam>     No instance for (Do ([a0] -> [a0]) b0 ([Int] -> [Int]))
03:55:46 <hunteriam>     Note: there is a potential instance available:
03:55:46 <hunteriam>       instance Do (a -> a) a (a -> a)
03:55:52 <hunteriam> why doesnt it select that instance?
03:55:54 <merijn> Afaict the problem is that it can't infer the type of '1'
03:56:19 <merijn> hunteriam: Well, how does it know that 'a0' is Int and not anything else?
03:56:41 <hunteriam> hm
03:56:46 <hunteriam> i feel like it has to be
03:56:57 <hunteriam> idk why it thinks a0 is not Int
03:57:17 <lyxia> could be Integer
03:57:32 <merijn> Or any other Num instance
03:57:39 <hunteriam> but you cant do [Integer] ++ [Int] can you?
03:58:47 <KaneTW> no
03:59:09 <merijn> hunteriam: No, but that's not relevant
03:59:16 <merijn> Since (>>) ignores it's first argument
04:00:42 <merijn> hunteriam: There could be a "Do (Char -> Bool) a (a -> a)" instance somewhere with a different implementation of "thenn", which GHC would be totally fine with
04:00:54 <merijn> hunteriam: How do you expect GHC to proof that that instance does not exist?
04:01:25 <hunteriam> I mean if GHC doesnt know about it then why does it care?
04:01:53 <hunteriam> Wait no there couldnt be that instance cause it would overlap
04:02:03 <hunteriam> Char -> bool ~ a -> a
04:02:05 <hunteriam> or nevermind
04:02:59 <merijn> hunteriam: It doesn't overlap, because "Char -> Bool" doesn't unify with "a -> a"
04:03:26 <merijn> hunteriam: GHC cares because as I said before: Instances *must* be globally uniquee
04:03:36 <merijn> hunteriam: Proving that there is an instance that can apply is NOT enough
04:03:58 <merijn> hunteriam: GHC needs to proof that there cannot be an other instance that can also apply
04:04:19 <hunteriam> ok
04:04:48 <hunteriam> i dont get why the function i wrote wasnt a composition of (a->a) though
04:04:54 <hunteriam> whats this a0??
04:05:20 <lyxia> :t (++ [1])
04:05:21 <lambdabot> Num a => [a] -> [a]
04:05:32 <merijn> hunteriam: It's a function "a -> a", but how does GHC proof that it's the SAME "a -> a" as the third parameter of Do?
04:06:00 <hunteriam> because all the functions in the do are the same function!
04:06:02 <merijn> hunteriam: Your Do instance only applies if both the 'a' and 'c' functions share the same type
04:06:21 <hunteriam> and so if it applied >> to two consecutive ones it would see that!
04:06:30 <merijn> hunteriam: Nope, they're not
04:06:46 <hunteriam> arent they all [Int] -> [Int]?
04:07:03 <merijn> hunteriam: The "<-" and the "[Int] -> [Int]" signature causes GHC to infer "[Int] -> [Int]" for line 42
04:07:17 <merijn> hunteriam: No, line 41 is "Num a => [a] -> [a]"
04:07:35 <merijn> I bet that if you change it to "(++ [1 :: Int])" it will compile
04:07:51 <hunteriam> :o
04:07:54 <merijn> Which is why using "app" instead of "++" fixes it
04:07:55 <hunteriam> strange
04:08:03 <lyxia> isn't there the same problem for line 42?
04:08:15 <merijn> Because "app" does the same thing, force GHC to decide that it's "[Int] -> [Int]"
04:08:24 <merijn> lyxia: Maybe, I'd need to look more carefully
04:08:42 <merijn> tbh, this code is super confusing to reason about
04:09:09 <hunteriam> there is
04:09:17 <hunteriam> ill paste some compilable code
04:09:38 <hunteriam> http://lpaste.net/150301
04:09:54 <hunteriam> now I for one cant think of a way to reduce the burden of saying :: Int but can either of you?
04:10:42 <merijn> No, and any use of multiparametertypeclasses like this is generally going to lead to this sort of inference hell
04:11:13 <merijn> Anyway, I should start writing my paper outline if I plan to finish it before friday >.>
04:12:12 <hunteriam> thesis?
04:12:15 <hunteriam> ?
04:14:28 <lyxia> hunteriam: f >> g = f >>= const g doesn't hold in your Do (a -> a) a (a -> a), is that intentional?
04:14:36 <merijn> No, just a paper, but I've been postponing writing for nearly a week and the deadline is approaching :p
04:15:58 <hunteriam> lyxia: well the point was to be able to access the result of the function when using `<-` 
04:18:00 <wz1000> What does the THUNK_STATIC exception mean?
04:19:22 <merijn> wz1000: That you won a lucky price in the "something went very wrong somewhere" lottery ;)
04:20:43 <wz1000> How do I figure out what went wrong? 
04:20:54 <wz1000> Also, what does IND_STATIC mean?
04:22:21 <merijn> wz1000: My guess from limited knowledge is that it's somehow trying to call/enter functions wrongly
04:22:44 <merijn> wz1000: You might wanna bring this up in #ghc (although be warned it can take a few hours to get an answer)
04:23:04 <merijn> wz1000: Can you manage to construct a minimal example?
04:23:11 <lyxia> hunteriam: Anyway, the problem is that when you pass a polymorphic function, such as (++ [1]), instance resolution will be looking for Do ([a] -> [a]) b ([Int] -> [Int]) and will not specialize a to Int.
04:23:11 <Axman6> and they're not usually open to helping users
04:23:50 <lyxia> hunteriam: How is it supposed to decide if you also had written Do ([Bool] -> [Bool]) Char ([Int] -> [Int])
04:26:00 <merijn> Axman6: huh, you must go to a different #ghc than me. As long as your issue is related to GHC doing weird things they're perfectly helpful and I'm pretty sure "THUNK_STATIC" exception is a sign of something seriously wrong happening
04:26:03 <wz1000> merijn: My program gives a bunch of IND_STATIC exceptions on calls to System.Process.readProcessWithExitCode, but continues to run fine. Then it invariably dies a few hours later after a THUNK_STATIC.
04:28:03 <merijn> A quick grep of the GHC source reveals that (as I expected) THUNK_STATIC is only referenced in the RTS
04:28:38 <merijn> wz1000: If you're brave and know a little C debugging you can try to trace the error yourself to see what's going wrong
04:29:20 <wz1000> I'm running it with +RTS -xc because it was silently crashing for some reason
04:30:24 <merijn> wz1000: You might wanna build using the profiled runtime system and get a core dump to see where it dies
04:31:46 <wz1000> merijn: Yeah, I'm using -prof -fprof-auto -fprof-cafs to build
04:32:51 <Axman6> merijn: this is true, but it is explicitly a channel for GHC development and not for getting assistance with the compiler
04:33:23 <merijn> Axman6: Development includes bug reports, which I'm pretty sure this will end up being
04:39:30 <kstt> hi guys
04:41:50 <kstt> I'm looking for a simple definition for function 'f' (libraires welcome) such that f("this is [foo] and this is [bar]")=["foo", "bar"]
04:41:59 <Hiro`> Hey everyone, trying to install MonadRandom for a CIS 194 homework using stack. `stack install MonadRandom` seems to work, but then when I try to import `Control.Monad.Random` in my code I get errors. Can anyone tell me what I'm doing wrong?
04:44:49 <Axman6> Hiro`: have you included MonadRandom in your cabal file as a dependency?
04:44:55 <lyxia> Hiro`: what errors
04:46:01 <Axman6> kstt: as a first attempt you could get there pretty easily using dropWhile and break in a loop
04:46:18 <Axman6> assuming that ] never appears inside foo or bar
04:46:37 <kstt> Axman6: thx
04:47:02 <Axman6> > dropWhile (/='[') "this is [foo] and and this is [bar]"
04:47:04 <lambdabot>  "[foo] and and this is [bar]"
04:48:07 <kstt> Thx. Indeed, it is not a big deal to write a simple parser this way, but I prefer to use a librairy when available.
04:48:41 <Axman6> depends how complex your data is really
04:49:07 <kstt> not that complex. Ok I'm lazy :) 
04:49:23 <kstt> I'll bite the bullet and dropWhile/takeWhile
04:50:03 <Hiro`> Axman6: no I just stack installed outside of a project. Doesn't this make the executable available globally?
04:50:37 <Hiro`> (assuming that the .stack directory is in my path)
04:50:41 <Axman6> no, you'll need to use --package MonadRandom if you're trying to use stack without cabal and stack.yaml files
04:50:43 <exio4> many1 (takeWhile '[' *> takeWhile (/= ']')) -- should a parser like this parse that easily? 
04:50:51 <dramforever> esqueleto Question: is it possible to return multiple fields from a single select query?
04:53:30 <Hiro`> Axman6: Thanks, but there is no --package option for `stack install`, as far as I can see.
04:55:34 <lyxia> Hiro`: hqve you tried stack ghc instead of ghc
04:56:16 <Axman6> Hiro`: you seem to be trying to use stack as if it is cabal, an that is probably not going to work well
04:57:34 <bergmark> Hiro`: stack install always puts the binary in (default) ~/.local/bin, also within existing projects
04:58:05 <Axman6> Hiro`: if you want to use stack you should use it properly. run stack new <project name> and then start writing Main.hs there, adding the libraries you need to the .cabal file
04:59:01 <Axman6> bergmark: Hiro` appears to be trying to build using the MonadRandom library, not looking for an executable
04:59:12 <Hiro`> Axman6: the stack docs say, "virtually all cabal commands have an equivalent in stack"
04:59:24 <Axman6> yes, but that does not mean they are the same
05:00:24 <Axman6> Hiro`: are you just trying to run ghc on your Main.hs file? if so, you probably want stack runghc --package MonadRandom Main.hs
05:01:03 <Hiro`> No, that's true. But it does seem to suggest that, e.g., there is a stack equivalent for `cabal install`.
05:01:57 <Axman6> there is, but that is mainly used for things which provide executables so they can be made available globally (and their libraries will be made available to stack based projects without having to recompile that library)
05:02:38 <Hiro`> Seems like a lot of overhead to generate a project just to write a few functions for a homework script. What I'd like to do is install MonadRandom globally.
05:03:35 <Axman6> it is installed globally, but is only available to stack projects (or by jumping through hoops)
05:03:35 <jle`> Hiro`: if you stack instlal MonadRandom, then MonadRandom is installed for stack environments
05:03:50 <jle`> Hiro`: if you want to run it with MonadRandom in scope, you can do `stack runghc Foo.hs`
05:03:55 <jle`> and it should work with MonadRandom
05:04:02 <jle`> `stack runhaskell Foo.hs`
05:04:04 <jle`> etc.
05:04:42 <jle`> by the way, MonadRandom doesn't have any executable as far as I know
05:05:16 <jle`> (just checked; it doesn't)
05:05:17 * hackagebot HaTeX-qq 0.0.1.2 - Quasiquoters for HaTeX  https://hackage.haskell.org/package/HaTeX-qq-0.0.1.2 (HiromiIshii)
05:05:54 <Axman6> pretty sure you need the --package flag too
05:06:01 <Hiro`> jle` so I'd have to do something like stack ghci or stack exec ghci to run my code in the repl?
05:06:16 <jle`> yeah, it's like "ghci, in the environment stack has"
05:06:36 <Axman6> yes
05:07:09 <jle`> it's nice because if you ever decide to change your version of GHC, which versions of which packages you're using, etc., you can just do so without nuking your .cabal or your already installed packages
05:07:23 <Hiro`> Got it working, thanks.
05:07:34 <jle`> stack install, stack ghci, stack runghc, etc., will use the setup of dependencies that work
05:07:47 <Hiro`> Anyone know if there is any emacs integration for haskell-interactive mode?
05:21:02 <quchen> Can I somehow throw old Stack package DBs away? All the lts-3.16 packages do is clutter up my hard drive, for example
05:22:19 <bergmark> quchen: iirc there's no safe way to remove parts of the stackage db, packages are reused between snapshots
05:22:43 <hunteriam> what is the alternative to super deep MonadT stacks
05:25:17 * hackagebot argon2 1.1.0 - Haskell bindings to libargon2 - the reference implementation of the Argon2 password-hashing function  https://hackage.haskell.org/package/argon2-1.1.0 (OliverCharles)
05:28:02 <bartavelle> hunteriam, free monads I'd say, but that really depends on your use case. There also is extensible effects, but I know next to nothing on the subject.
05:29:04 <zudov> quchen: I am thinking about making a cronjob which would periodically wipe ~/.stack/, check the latest resolvers and builds `lens` and `yesod`
05:40:34 * hackagebot pandoc-japanese-filters 0.1.0.0 - Japanese-specific markup filters for pandoc.  https://hackage.haskell.org/package/pandoc-japanese-filters-0.1.0.0 (HiromiIshii)
05:40:36 * hackagebot pandoc-japanese-filters 0.1.0.1 - Japanese-specific markup filters for pandoc.  https://hackage.haskell.org/package/pandoc-japanese-filters-0.1.0.1 (HiromiIshii)
05:54:20 <nomeata> Im sure it is a bad idea, but I wonder why: What if GHC would learn to prove code to be equivalent (at least in simple cases), and not complain if two (orphan) instances are in scope, as long as it can ensure that they are semantically equivalent?
05:54:58 <merijn> nomeata: Semantic equivalence? Good luck :p
05:56:00 <nomeata> merijn: As I said: Best effort only, catching simple cases. Id be happy if it catches those where the the original source code was identical, just happend to be living in a different module.
05:56:58 <merijn> nomeata: Right, intensional equivalence is much simpler, I think that would be nice. The problem is that you might not have the second orphan in scope
05:57:15 <merijn> nomeata: They don't have to both be in scope in order for problems to happen
06:01:00 <nomeata> merijn: really? How so?
06:02:17 <merijn> nomeata: I forgot, but I remember someone mentioning here that that's possible
06:24:44 <Eduard_Munteanu> Hi. Any recommendations for logging (append-style) data in binary form?
06:25:13 <ironChicken> just spent 30 mins discovering that (joinPath ["/foo", "/bar"]) => "/bar" :-(
06:28:04 <JustCaws> So I'm a bit new to IRC, and Haskell, and #haskell. Do I just ask a question? Is that how this works?
06:28:21 <mpickering> yes just ask a question and someone will answer if they know
06:28:38 <maerwald> ironChicken: that's a serious bug imo
06:28:52 <maerwald> and not documented in the function documentation
06:29:09 <Eduard_Munteanu> JustCaws, exactly
06:29:14 <maerwald> imagine what that could do if you use the resulting path for e.g. removing a directory
06:29:38 <JustCaws> Alright. Thanks. I'll think of a way to formulate my question then.
06:30:11 <ironChicken> maerwald: good point
06:31:30 <maerwald> joinPath ["/foo", "/"] -- ouch
06:35:36 * hackagebot fn 0.2.0.2 - A functional web framework.  https://hackage.haskell.org/package/fn-0.2.0.2 (DanielPatterson)
06:35:38 * hackagebot fn-extra 0.2.0.1 - Extras for Fn, a functional web framework.  https://hackage.haskell.org/package/fn-extra-0.2.0.1 (DanielPatterson)
06:40:37 <maerwald> ironChicken: https://github.com/haskell/filepath/issues/49
06:42:30 <ironChicken> maerwald: thanks for that
06:43:35 <maerwald> I really start to get angry about filesystem handling haskell libraries. System.Directory does similar semi-defined stuff
06:44:18 <maerwald> I guess it's best when you write your own module for that
06:44:23 <merijn> maerwald: Sounds like you want something like: https://hackage.haskell.org/package/path-0.5.3/docs/Path.html
06:44:57 <`Guest00000> a nice problem... i want to enumerate all types which belong to a typeclass
06:45:36 <`Guest00000> i need only the types in form TC :: *, where TC is type constructor
06:45:52 <`Guest00000> so, no types like [Int], only types like Int, Char, ...
06:46:50 <wz1000> merijn: When I try to compile my program with -debug, ld says it cannot fine -lHSrts_debug_p (I didn't want to clutter up #ghc)
06:47:36 <`Guest00000> how will i use it: that typeclass will have a method :: MyTypeclass t => t -> SomeStuff
06:48:03 <`Guest00000> that method doesn't look into its argument... i want to collect all the Stuffs returned by instances of method
06:48:05 <merijn> wz1000: oh, probably it doesn't have both a profiled AND debug build of the RTS :\
06:50:21 <wz1000> merijn: Should I proceed with just -debug, or is there a (relatively less time consuming way) to get that build?
06:52:35 <merijn> wz1000: tbh, I've never build debug+profiling, so you might wanna go with just -debug
06:54:50 <albeit> When running stack build I'm getting an error on two packages, "Could not find module xyz... There are files missing in the xyz package"
06:54:55 <albeit> How can I vix that?
06:55:59 <kadoban> albeit: Are the module files named correctly? Are they in the correct place in the directories?
06:56:15 <albeit> kadoban: I honestly do not know. How can I check that?
06:56:46 <albeit> My program directory is in a Dropbox folder, and this was the first time trying to build on a different comptuer with the synced folder, which sounds liek the source of the issue.
06:56:48 <jewels> Hi there. How can I avoid that haddock prints the quickcheck properties in the generated HTML files?
06:56:58 <kadoban> albeit: Are the module statements at top of the files correct?  Hmm. I mean I guess you can run 'cabal check' and it might tell you, I think it does.
06:57:12 <kadoban> albeit: Oh, well if that's the issue then it's probably nothing that I'm talking about.
06:57:32 <kadoban> albeit: I guess you'd just have to kick dropbox and get it working or something, and/or transfer the files in some other way?
06:58:00 <hunteriam> stack ghci is trying to build a file that is not included 
06:58:03 <hunteriam> or in the .cabal
06:58:52 <albeit> hunteriam: What do you mean by not included? I have the module listed at the top of the program, and the package is listed under build-depends in the .cabal
06:59:05 <hunteriam> not you
06:59:12 <albeit> Ah, sorry ;)
07:00:59 <puregreen> I have a small program that listens to commands and updates some data structure according to those commands (let's say a <10kB Map) ; I want this program to handle sudden restarts correctly (i.e. the map is saved after every operation and loaded from somewhere on startup). Should I use acid-state, persistent, or something else?
07:02:19 <puregreen> also, are there *any* up-to-date tutorials on acid-state?
07:02:45 <bergmark> puregreen: the simplest would probably be to just use `binary' to dump a blob? I can not tell what would be the best alternative in your case
07:05:21 <Eduard_Munteanu> puregreen, acid-state is fine
07:07:38 <kstt> puregreen: acid-state will do the job and provide decent perfs. However, in my opinion (based on a real-world software), there is a lot of black magic behind, and I don't like data to go through balck magic.
07:08:56 <puregreen> okay, I guess I'll use acid-state just because it's an opportunity to learn about a new library
07:09:07 <puregreen> thanks everyone
07:19:53 <hunteriam> what is the equivalent of (+1) for subtraction?
07:20:04 <hunteriam> ((-)1) ~ 1 - x
07:20:09 <hunteriam> (-1) ~ -1
07:20:16 <puregreen> subtract 1
07:20:17 <kadoban> :t subtract 1
07:20:18 <lambdabot> Num a => a -> a
07:20:23 <hunteriam> ah
07:20:48 <puregreen> note that there's no add or times
07:21:06 <puregreen> also note that you can use pred and succ if you need 1/+1 specifically
07:22:38 <tsahyt> Hello! Is there a preferred XML library like aeson is for JSON? Hackage turns up a bunch of libraries like hxt, xml, and haxml.
07:25:34 <merijn> tsahyt: I've had good experience with using xml-conduit and html-conduit respectively for scraping XML/websites
07:25:58 <merijn> Bonus points for easily plugging into http-conduit for easily fetching stuff from the web
07:30:24 <tsahyt> merijn: Thanks! It doesn't seem to provide stuff like schema validation though. Not that it matters, I'm asking purely out of curiosity because I'm studying for an interoperability class and was forced to work with XML.
07:30:43 * hackagebot jukebox 0.1.5 - A first-order reasoning toolbox  https://hackage.haskell.org/package/jukebox-0.1.5 (NickSmallbone)
07:31:34 <ironChicken> in GHCi, i've issued: :m System.PosixCompat.Files
07:31:41 <ironChicken> but then when i do: :i createSymbolicLink
07:31:54 <ironChicken> it says "Not in scope: createSymbolicLink"
07:32:16 <tsahyt> ironChicken: Works for me on GHC 7.8.4
07:32:27 <tsahyt> What GHC version are you on?
07:32:42 <ironChicken> hmm. 7.10.3
07:33:05 <byorgey> ironChicken: what message (if any) does it print after you enter  :m System.PosixCompat.Files ?
07:33:07 <ironChicken> with unix-compat installed from debian
07:33:19 <ironChicken> byorgey: none. it appears to work
07:33:29 <byorgey> ironChicken: what is the output of :browse
07:33:52 <tsahyt> ironChicken: Does it list the function with :browse System.PosixCompat.Files ?
07:34:06 <merijn> tsahyt: Yeah, not sure if it has that fancy kinda stuff, but then again I mostly scraped html, so there was no schema :p
07:34:22 <ironChicken> byorgey: http://pastebin.com/PqF7Ld8b
07:34:53 <ironChicken> tsahyt: no, it doesn't seem to be mentioned
07:34:55 <Eduard_Munteanu> Hm... I think I can use Data.Acid.Log to implement my logfile.
07:35:01 <byorgey> ironChicken: that seems to be the contents of Text.Printf
07:35:07 <byorgey> ironChicken: did you also do  :m Text.Printf?
07:35:10 <ironChicken> yes
07:35:16 <tsahyt> Try :m +...
07:35:32 <tsahyt> You can also use the import keyword in GHCi I believe
07:35:34 <byorgey> ironChicken: OK, that's the problem then.  If you want multiple modules loaded you have to do  :m +module.name
07:35:47 <byorgey> ironChicken: just doing :m Module.Name   loads that module and unloads all others
07:36:29 <ironChicken> ahh. i now recall that from very long ago
07:36:32 <ironChicken> byorgey: thank you
07:36:43 <tsahyt> merijn: The last time I actually needed an XML library it was in a C project (or C++ possibly, it's been a few years), and libxml2 is a powerhouse that does everything. Being a C library it's rather unwieldy though
07:43:52 <statusfailed> does "bindM2 :: (a -> b -> m c) -> m a -> m b -> mc" exist ?
07:44:07 <statusfailed> oh I guess join + liftM2 
07:44:13 <jeeger> Greetings! I'm trying to run a haskell program written with fairly new packages on a Debian Wheezy. I've tried haskell-platform, but wheezy's glibc is apparently too old to run haskell platform. Any other way of getting a newer ghc and install it as a user?
07:46:18 <Ankhers> jeeger: You could try using stack.
07:46:34 <merijn> jeeger: tbh, installing the binary release of GHC is pretty simple
07:46:52 <merijn> jeeger: Just grab the tarball and follow the README, I do this all the time on the university cluster
07:47:34 <merijn> At least, it works on our ancient CentOS servers. Not sure how old wheezy is
07:48:16 <jeeger> merijn: Hm, seems I'm still looking for libgmp3.so.6
07:49:22 <jeeger> sorry, libgmp.so.3
07:53:41 <jeeger> Ah, got it from squeeze.
08:01:05 <linuss_> Hey guys, I'm working through the following tutorial: http://mightybyte.github.io/monad-challenges/pages/ex1-6.html , and I'm stuck trying to figure out genTwo. I have the following, which if I follow the types should be right, but gives a type error on compilation: http://pastebin.com/XFa1ca9v 
08:07:10 <tsahyt> Why does Haskell actually use /= for inequality instead of != ?
08:07:40 <tsahyt> I believe that I read the reason once but I've forgotten it
08:07:57 <ggole> It's meant to be like 
08:08:07 <jackhill> tsahyt: because it looks like  ? I don't actually know, but that could be the reason
08:08:43 <tsahyt> Okay, I thought there was some deeper reason, like != being used for something else somewhere
08:08:49 <ggole> Haskell may have borrowed it from Lisp
08:08:53 <KaneTW> looking like \ne seems like a good enough reason for me
08:09:05 <KaneTW> ?let (!=) = (/=)
08:09:07 <lambdabot>  Defined.
08:09:11 <KaneTW> > 1 != 2
08:09:13 <lambdabot>  True
08:09:24 <tsahyt> Well I'm fine with /=, it's different from most other languages
08:10:09 <ggole> I've also seen =/= in some older languages (Prolog, uh, Algol?)
08:11:14 <tsahyt> Prolog has a bunch of different inequality notions
08:11:56 <tsahyt> \= for not unifiable, =\= for arithmetic inequality, \== for term inequality
08:14:12 <Tom7> hello, I have a question: can I combine a 'StateT a Identity' with a 'StateT a m'? (Convert the Identity to any other monad)
08:14:27 <tdammers> combine how?
08:14:36 <liste> @type zoom -- Tom7
08:14:37 <lambdabot> Zoom m n s t => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
08:15:04 <liste> that one at least runs a smaller state in larger state
08:15:11 <liste> but I guess it's not what you're after
08:15:40 <nut> anyone using the haskell couchdb driver? is it complete?
08:15:42 <Tom7> Thanks
08:16:08 <nut> i get the impression that it's less formal than the mongodb driver
08:24:14 <merijn> tsahyt: The deeper reason is probably that haskell is inspired by the ML branch of libraries, rather than Algol inspired ones like C (ocaml uses != for pointer inequality rather than structural inequality, for example)
08:24:46 <merijn> liste: That doesn't do what he want, he wants to change the under monad
08:24:50 <merijn> Tom7: You want
08:24:52 <merijn> @hackage mmorph
08:24:53 <lambdabot> http://hackage.haskell.org/package/mmorph
08:25:09 <merijn> Tom7: Specifically, you want "hoist generalize" (or "hoist generalise"? I forget)
08:25:36 <merijn> Tom7: In other words, yes, you can do that
08:26:54 <ggole> merijn: well, OCaml has both "physical" (identity) and structural comparison operators, and the latter are in the Pascal style (<>)
08:27:03 <merijn> ggole: I know :)
08:27:19 <merijn> tbh I find haskell's /= a lot better than <>
08:27:58 <ggole> I don't really care all that much. It's a bit irritating that there are so many variants out there.
08:28:06 <kstt> What is the canonical way to fold a '[Maybe a]' to a 'Maybe a' please ? msum ?
08:28:11 <Hafydd_> In an alternate universe, (not .) . (==) = (<>) and mconcat = (/=).
08:28:47 <Hafydd_> Er... mappend, I mean.
08:28:57 <Rembane> kstt: Maybe a and not Maybe [a]?
08:29:09 <kstt> Rembane: yes
08:29:59 <Rembane> kstt: sequenceA will turn [Maybe a] to Maybe [a] and then you can run fmap (foldr ...) on that.
08:30:17 <kstt> msum does the job directly, but needs an import
08:30:23 <merijn> :t listToMaybe . catMaybes
08:30:28 <lambdabot> [Maybe a] -> Maybe a
08:30:31 <kstt> > msum [Nothing, Just 1, Nothing]
08:30:34 <lambdabot>  Just 1
08:30:47 <merijn> > listToMaybe . catMaybes $ [ Nothing, Just 1, Nothing]
08:30:49 <lambdabot>  Just 1
08:30:53 <kstt> nice :)
08:31:04 <liste> does that return the leftmost Just value?
08:31:05 <merijn> Probably also needs an import, though
08:31:23 <Rembane> Data.Maybe I believe.
08:31:35 <merijn> liste: It basically strips all Nothing's and then does "safeHead" on the resulting list, so yes
08:33:36 <liste> > foldMap Last [Just 4, Nothing, Just 8, Just 2, Just 4] -- if you want the rightmost one
08:33:38 <lambdabot>  Last {getLast = Just 4}
08:33:56 <Tom7> merijn: Thank you merijn, this did the trick for me
08:34:12 <merijn> Tom7: np :)
08:34:54 <kstt> liste: msum rather folds the list using its MonadPlus instance
08:35:29 <kstt> like 'foldr (<|>) Nothing'
08:35:50 <kstt> > foldr (<|>) Nothing [Nothing, Just 1, Nothing]
08:35:52 <lambdabot>  Just 1
08:35:53 <liste> which is one way to fold [Maybe a] to Maybe a
08:38:18 <liste> > ala First foldMap [Nothing, Just 1, Just 7, Nothing, Just 12, Nothing]
08:38:20 <lambdabot>  Just 1
08:39:54 <frerich> @check \s -> (let v = read s :: Double in show v) == s
08:39:56 <lambdabot>  *** Failed! Exception: 'Prelude.read: no parse' (after 1 test):
08:39:56 <lambdabot>  ""
08:39:57 <Eduard_Munteanu> > listToMaybe . catMaybes $ [Nothing, Just 1, Just 7, Nothing, Just 12, Nothing]
08:39:59 <lambdabot>  Just 1
08:40:00 <frerich> Euhm...
08:40:30 <frerich> Can anybody think of a nice number which has a perfectly fine string representation but which has no exact representation of a Double? Something which isn't totally contrived. :-}
08:41:01 <frerich> s/representation of/representation as/
08:41:10 <Eduard_Munteanu> > show (0.1 :: Double)
08:41:10 * hackagebot generics-eot 0.1 - A library for generic programming that aims to be easy to understand  https://hackage.haskell.org/package/generics-eot-0.1 (SoenkeHahn)
08:41:11 <lambdabot>  "0.1"
08:41:28 <KaneTW> 0.1, yeah
08:41:30 <liste> is Double cheating?
08:41:35 <liste> with its Show instance
08:42:05 <alex-v> Hi, does anybody know the meaning of ":|" in the definition of sconcat for Semigroup? (https://github.com/ekmett/semigroups/blob/master/src-ghc7/Data/Semigroup.hs#L208) Thanks
08:42:06 <KaneTW> > decodeFloat (0.1 :: Double)
08:42:08 <lambdabot>  (7205759403792794,-56)
08:42:15 <frerich> Eduard_Munteanu: Yeah I know there are plenty of numbers which cannont be modelled precisely (such as 0.1) but I thought I had a case where reading a number and then showing it again would give a different string.
08:42:32 <Eduard_Munteanu> Hm.
08:43:13 <phadej> alex-v: :| is NonEmpty's constructor
08:43:14 <byorgey> alex-v: it is a data constructor for NonEmpty
08:44:12 <alex-v> phadej: thanks!
08:44:20 <alex-v> byorgey: thanks!
08:44:22 <byorgey> liste: I think the Show instance does a bit of rounding, yes
08:44:26 <byorgey> > 0.1 + 0.1
08:44:26 <ggole> 0.1 printed as "%.60f" => 0.100000000000000005551115123125782702118158340454101562500000
08:44:28 <lambdabot>  0.2
08:44:31 <byorgey> > 0.1 + 0.1 + 0.1
08:44:33 <lambdabot>  0.30000000000000004
08:44:40 <ggole> Further digits are just more zeros
08:44:59 <Eduard_Munteanu> > printf "%.60f" 0.1
08:45:01 <lambdabot>      No instance for (Show a0)
08:45:01 <lambdabot>        arising from a use of show_M28576545655453584946607
08:45:01 <lambdabot>      The type variable a0 is ambiguous
08:45:09 <Eduard_Munteanu> > printf "%.60f" (0.1 :: Double)
08:45:11 <lambdabot>      No instance for (Show a0)
08:45:11 <lambdabot>        arising from a use of show_M16212653544017484246617
08:45:11 <lambdabot>      The type variable a0 is ambiguous
08:45:14 <frerich> > 0.3
08:45:16 <lambdabot>  0.3
08:45:24 <athan> Did the new version of wai (3.2.*) make HTTP/2 a traditional Middleware?!
08:45:27 <Eduard_Munteanu> > printf "%.60lf" (0.1 :: Double)
08:45:29 <lambdabot>      No instance for (Show a0)
08:45:29 <lambdabot>        arising from a use of show_M89546922869691977876639
08:45:29 <lambdabot>      The type variable a0 is ambiguous
08:45:43 <merijn> Eduard_Munteanu: The result of printf is polymorphic
08:45:49 <Eduard_Munteanu> Oh, yeah.
08:45:56 <Eduard_Munteanu> > printf "%.60lf" (0.1 :: Double) :: String
08:45:59 <lambdabot>  "*Exception: printf: bad formatting char 'l'
08:46:06 <Eduard_Munteanu> > printf "%.60f" (0.1 :: Double) :: String
08:46:08 <lambdabot>  "0.100000000000000000000000000000000000000000000000000000000000"
08:46:30 <ggole> Sure looks like some rounding
08:47:04 <ggole> (I used C and OCaml's printf, both of which give the same result.)
08:47:05 <Eduard_Munteanu> Weird, no %lf in printf?
08:47:43 <merijn> Down with Double, up with Ratio!
08:47:50 <merijn> > 0.1 :: Ratio Int
08:47:52 <lambdabot>  1 % 10
08:47:59 <Ygg> I think I'm in love with functional programming
08:48:22 <badmash> hello there
08:48:52 <Eduard_Munteanu> Ygg, that or you're staring at its ass :P
08:49:03 <Eduard_Munteanu> badmash, hi
08:49:09 <badmash> i am running a quicksort algorithm like this -- main = print $ qsort2 $ take 10000 [100000,99999..1]
08:49:10 <frerich> Hmm, maybe the instances are really cheating a bit. I was sure I once found a string for which '\s -> (let v = read s :: Double in show v) == s' did not hold.
08:49:36 <badmash> when i pass the list to be sorted as take 10000
08:50:11 <haasn`web> Basic Parsec question: I want to parse a string like aXXXXXXXXb" where X can be any character, including a or b. Basically, something like the regex "^a.*b$". The naive approach char 'a' *> many anyChar <* char 'b' <* eof does not work, because many anyChar already consumed the b at the end and did not backtrack. What's the correct way to write something like this?
08:50:12 <badmash>                 [100000,99999..1], the algorithm gets slower vs if i created the input list by other means
08:50:22 <badmash> any idea why this happens?
08:51:02 <merijn> haasn`web: manyTill
08:51:17 <Eduard_Munteanu> haasn`web, use try to backtrack
08:51:19 <Ygg> Its ass is magnificient, then
08:51:33 <merijn> haasn`web: I'm assuming your terminating parser is unique
08:51:49 <merijn> Eduard_Munteanu: Doesn't work, many will consume every character including terminating "b" and fail
08:52:22 <badmash> just to be clear -- quick sort with input take 10000 [100000,99999..1] is lot slower than if i created the input list by other means
08:52:22 <haasn`web> merijn: Ah, perfect. So basically something like: char 'a' *> manyTill anyChar (char 'b' <* eof)
08:52:32 <merijn> haasn`web: Yeah
08:52:35 <haasn`web> Eduard_Munteanu: I'm not sure where to backtrack in that parser in a way that is both efficient and actually works
08:52:49 <Eduard_Munteanu> Ah, since many succeeds anyway.
08:52:57 <byorgey> badmash: what do you mean by "other means"?
08:53:07 <merijn> haasn`web: manyTill will FIRST try to succesfully parse "char 'b' <* eof" and fail (unless it's the end and you wanna stop) and only THEN try the next anyChar
08:53:47 <haasn`web> merijn: Ah, it has to be manyTill anyChar (try $ char 'b' <* eof) in this example
08:54:14 <badmash> byorgey: for example -- like this main = print $ qsort2 $ take 1000000 . randomRs (2 :: Int, 10000000 :: Int) . mkStdGen $ 5
08:54:30 <merijn> badmash: quicksort has terrible worst case performance
08:54:44 <athan> Ygg: If you can read this, you will be mega: http://www.cse.chalmers.se/research/group/logic/book/book.pdf
08:54:59 <merijn> badmash: That produces a random list, your original list is "reversed sorted", might be hitting quicksorts worst case complexity
08:55:38 <badmash> merijn: i tried the reverse form of that list as well -- the same problem persists
08:55:43 <infandum> Is there a way to derive all types for a newtype wrapper that make sense? So for newtype Cheese = Cheese Int, I would want it to behave like an Int so I would use GeneralizedNewtypeDeriving and deriving (Eq, Ord, Show, Read, Num, etc.). Is there a way to automate that last deriving part?
08:56:03 <athan> Ygg: Have you read Bird & Walder's Introuction to Functional Programming vol. 1?
08:56:08 <kadoban> badmash: Sorted or reverse sorted tends to be quicksort's worst case inputs, if you do a naive pivot selection.
08:56:12 <athan> that's one of the best imo :)
08:56:36 <badmash> kadoban: i see
08:56:50 <Ygg> thanks for the links
08:57:03 <Ygg> No, I didn't read it, I'm just starting
08:57:20 <Ygg> began to learn haskell a bit more than a week ago
08:58:15 <ggole> frerich: err, there are many such strings?
08:58:30 <marrrk__> How can I check whether some Text matches a regex?
08:58:33 <ggole> "1", for instance :)
08:58:39 <ggole> But also anything which is long enough to be truncated
08:58:49 <frerich> ggole: There are infinitely many such strings, right!
08:59:02 <ggole> (And things like the various formats of floats, but I don't think that kind of thing is what you meant.)
08:59:05 <badmash> kadoban: could you elaborate?  
08:59:44 <Eduard_Munteanu> infandum, not really
08:59:46 <kadoban> badmash: Well, how familiar are you with quicksort?
08:59:57 <kadoban> badmash: What's the basic idea?
09:00:20 <frerich> ggole: Well yeah, I guess i didn't mean "tricks" like too long numbers, scientific notation of that '1 vs. 1.0' thing. :-)
09:00:21 <badmash> kadoban: in the haskell code, it does the same number of steps no matter what the pivot is
09:00:42 <kadoban> badmash: Then it's not quicksort.
09:01:15 <dmj> is there no pipes-stm package?
09:01:22 <tsahyt> For the naive "quicksort" implementation in Haskell it does indeed hit the worst case, because the pivot point is picked as the head, hence partitioning the already sorted list in (n-1) + 1 elements, and then recursing.
09:02:33 <tsahyt> You could pick the pivot using median of medians or something, or randomize it, but lists are not the right data structure to do any of this
09:02:47 <kadoban> badmash: I suspect very strongly that it actually *doesn't* do the same number of "steps" for a reasonable definition of "steps".
09:05:39 <badmash> kadoban: sorry, i got disconnected
09:05:47 <tsahyt> badmash: Why are you not using Data.List.sort btw? It's merge sort if I remember correctly and doesn't have the same issue with worst case complexity
09:06:10 * hackagebot djembe 0.1.1.1 - Hit drums with haskell  https://hackage.haskell.org/package/djembe-0.1.1.1 (ReedRosenbluth)
09:06:42 <badmash> tsahyt: well, i wanted to just check out quicksort algorithm in haskell just as part of learning haskell
09:07:06 <tsahyt> Well that makes sense. Is it the one with two filters and a ++ ?
09:07:15 <dmj> badmash: I'd check out vector-algorithms then
09:07:18 <kadoban> badmash: If you share your code we can probably point out a bit more what's going on.
09:07:40 <badmash> kadoban: shall i paste it here?
09:07:41 <tsahyt> qsort (x:xs) = filter (<= x) xs ++ [x] ++ filter (x <) xs?
09:07:55 <kadoban> badmash: http://lpaste.net/new/haskell please
09:07:57 <infandum> Eduard_Munteanu: So I hear that people use newtypes for easy help with mixing up types by accident. Is the downside to this versus just Type Cheese = Int that I would have to derive everything?
09:08:00 <badmash> kadoban: i don't have it on the web
09:08:12 <tsahyt> badmash: That's what pastebins are for
09:08:18 <tsahyt> lpaste.net for example
09:08:57 <kadoban> infandum: That's (part of) the upside, actually.
09:09:29 <badmash> kadoban: http://lpaste.net/150314
09:09:31 <kadoban> infandum: The downside is that it's an actual separate type, so sometimes you end up having to do a bit of manual wrapping and unwrapping, depending on what it is.
09:09:36 <tsahyt> infandum: Sometimes you don't even want your wrapper to provide everything the contained type has. It's also great for having a different instance than the wrapped type provides
09:10:03 <dmj> infandum: newtype everything or pay for it later
09:10:16 <infandum> Makes sense
09:10:55 <infandum> So in the end, if I want to convert the value or print the value I would have to unwrap it, right? So printing Cheese 7 would write Cheese 7 when I just want 7 while the wrapper is a helper really
09:11:20 <infandum> Do I need to write the unwrapper (unCheese) or is it automatic (I guess I can pattern match easily)
09:11:25 <badmash> kadoban: i have pasted the code ...
09:11:29 <dmj> infandum: if you derive Num you don't have to
09:11:38 <infandum> dmj: How so?
09:11:48 <dmj> @def newtype Cheese = Cheese Int deriving (Num, Show)
09:11:50 <lambdabot>  .L.hs:172:26:
09:11:50 <kadoban> badmash: Okay, right. So you're picking the first value of the list for the 'pivot' each time. Now, what happens in quicksort when the pivot is the smallest or largest element of the list? What are the sizes of us and vs in that case?
09:11:50 <lambdabot>      Can't make a derived instance of Num Cheese:
09:11:50 <lambdabot>        Num is not a derivable class
09:12:05 <athan> Ygg: This one should be your top priority to read then: http://usi-pl.github.io/lc/sp-2015/doc/Bird_Wadler.%20Introduction%20to%20Functional%20Programming.1ed.pdf
09:12:07 <kadoban> badmash: How familiar are you with quicksort in general, by the way? I can't tell if this is really a haskell question or a quicksort/algorithms question.
09:12:40 <infandum> dmj: But I mean print $ Cheese 3 will print Cheese 3, not 3
09:13:14 <dmj> instance: http://lpaste.net/150315
09:13:19 <dmj> infandum: yes, true
09:13:28 <dmj> infandum: unless you change the Show instance
09:13:33 <badmash> kadoban: i am familiar with quicksort, but this is the first quicksort code i am looking at in haskell
09:13:44 <infandum> So I would need to write Cheese = Cheese { unCheese :: Int } or something
09:13:54 <infandum> or pattern match (\Cheese x -> x)
09:13:57 <infandum> before printing
09:14:05 <Ygg> ok !
09:14:07 <kadoban> badmash: Okay, cool. Alright, so what is the general idea of quicksort? Let's start there.
09:14:29 <dmj> infandum: what are you extracting it for?
09:14:37 <dmj> to pass it into another function?
09:14:57 <infandum> dmj: To print it out without the wrapper in there. I would want to output 3 rather than Cheese 3
09:15:13 <kadoban> badmash: quicksort sorts an array by [ fill in here ]
09:15:25 <dmj> @def newtype C = C Int
09:15:26 <badmash> kadoban: basically, as the code says, sort less < x ++ [x] ++ sort > X
09:15:27 <infandum> For converting it to a pure Int then yes I would definitely need to convert by one of those methods
09:15:27 <lambdabot>  Defined.
09:15:43 <dmj> @def instance Show C where; show (C x) = show x
09:15:44 <lambdabot>  Defined.
09:15:50 <infandum> ah
09:15:51 <dmj> > show (C 3)
09:15:52 <lambdabot>  "3"
09:15:53 <tsahyt> infandum: For printing you could theoretically just define your Show instance to do what you want, but that's not really what it's supposed to be
09:16:03 <infandum> but I would need that for each type
09:16:08 <infandum> which would get really ugly
09:16:14 * hackagebot djembe 0.1.1.2 - Hit drums with haskell  https://hackage.haskell.org/package/djembe-0.1.1.2 (ReedRosenbluth)
09:16:16 * hackagebot pipes-transduce 0.2.3.0 - Interfacing pipes with foldl folds.  https://hackage.haskell.org/package/pipes-transduce-0.2.3.0 (DanielDiazCarrete)
09:16:19 <tsahyt> Template Haskell could help with the boilerplate I believe
09:16:33 <tsahyt> That's ugly in its own right, but at least you don't have to do it manually every time
09:16:48 <infandum> I think it would be cleaner to just unwrap it each time before printing
09:16:48 <badmash> kadoban: my question really is that, looking at the haskell code, i don't see how the order of input list matters
09:17:19 <tsahyt> badmash: Look at the size of the lists passed in the recursive calls
09:17:24 <dmj> infandum: safety first, unwrapping leaves you open to mixing up the value with another type
09:17:51 <kadoban> badmash: Bleh, I suck at teaching and this isn't leading where I hoped, here's the problem: quicksort is only quick when the two lists you separately recurse over are close to the same size. Your lists are *not* anywhere near the same size when you recurse over them. One has  no elements, the other one has all of the elements except for the pivot.
09:17:52 <Hafydd_> Put a wrapper on it!
09:18:02 <badmash> kadoban: may be i got some things wrong, but basically i am having difficulty reasong through the haskell code because of lazy evaluation
09:18:04 <kadoban> badmash: In this case, quicksort is (n^2)
09:18:09 <dmj> infandum: if it's really bothering you, you could make your own typeclass 'CustomShow' and use generics to only print the value, this would remove boilerplate
09:18:21 <kadoban> badmash: Thankfully this has nothing at all to do with lazy evaluation or even haskell.
09:18:23 <dmj> using DefaultSignatures, instance CustomShow Cheese
09:19:18 <infandum> Then use that for each type, let's say I have 20 types, it wouldn't look as bad
09:19:37 <infandum> What is the standard way of handling all of this? I think people use it a lot
09:19:43 <infandum> Fromn what I understand
09:20:04 <badmash> kadoban: thanks, i have seen that ... in fact, i deliberately created such an input to test the code
09:20:35 <kadoban> badmash: Your code is doing: qs [1,2,3,4,5] -> qs [] ++ [1] ++ qs [2,3,4,5] -> [] ++ [1] ++ qs [] ++ [2] ++ [3,4,5]    each step only gets you one element closer to being sorted, and at each level you do (n) work.
09:20:37 <badmash> kadoban: my question is -- how is what you are saying evident from the haskell code?
09:21:00 <dmj> infandum: lenses help with dealing with types. You get the safety, but they feel "lighter"
09:22:10 <badmash> kadoban: you are correct
09:22:32 <infandum> dmj: Lenses instead of newtypes? I didn't know you could do that. But they don't have the performance of newtype, right? They are formed in data types
09:23:29 <kadoban> badmash: It's largely evident from the algorithm analysis mostly. Seeing it in the haskell code is a matter of  recognizing how many steps are needed in the partitioning and how the list splitting is happening.
09:23:52 <kadoban> badmash: I'm not really sure what the question is I guess, you seem to have moved on to a new one compared to the original question. Which is fine, but  I'm not clear on it.
09:24:25 <badmash> kadoban: i am just learning haskell, so i had a bit of difficulty analysing the code
09:24:37 <tsahyt> badmash: The y < x predicate is always true in sortp for your input list. Say that the list has n entries, then length us == n-1 (because x is excluded) and length vs == 0. In the next recursive step, you'll take exactly one more element from the list etc, so you'll do n + (n-1) + (n-2) + ... = n(n+1) / 2 steps, which is in O(n^2).
09:24:52 <kadoban> badmash: Ah, yes that will take a while to get used to.
09:33:38 <dmj> infandum: you can derive lenses from your types. Lenses are great for traversing arbitrarily long / nested data structures. They're also great for viewing types. i.e. customType ^. packed, and can do millions of other things
09:35:49 <badmash> sorry ... got disconnected
09:36:18 <badmash> if someone had responded to my questions, i may have missed their response
09:36:28 <dmj> infandum: any data type you define, if it has multiple fields, should probably newtype every field
09:38:25 <badmash> kadoban: if you had already responded to my last question, i may have missed it, as i got disconnected.  apologoze
09:38:34 <badmash> apologize
09:43:33 <infandum> dmj: Okay, I'll check it out! Thanks for your help!
09:56:15 * hackagebot pipes-transduce 0.3.0.0 - Interfacing pipes with foldl folds.  https://hackage.haskell.org/package/pipes-transduce-0.3.0.0 (DanielDiazCarrete)
10:01:16 * hackagebot HaRe 0.8.2.3 - the Haskell Refactorer.  https://hackage.haskell.org/package/HaRe-0.8.2.3 (AlanZimmerman)
10:20:04 <Franciman> Hello
10:21:45 <Franciman> If I have a list [a] where a is Ord, I can use minimum and maximum to get min and max of the list, but is there a way to compose these two functions to get a fold that calculates min and max traversing the list only once?
10:21:54 <Franciman> (Without writing the fold explicitly)
10:22:33 <tsahyt> Franciman: I'm not sure but maybe stream fusion can do this?
10:24:15 <lingxiao> hey all
10:24:28 <lingxiao> anyone would like to chat with me briefly over at #coq?
10:24:49 <ecognium> hello I am trying to disable TLS checks for some internal testing with wreq but i cannot seem to update the Options record returned by default. What's the best way to do this? http://pastebin.com/4TybX6CX
10:24:51 <Gurkenglas> Franciman, https://hackage.haskell.org/package/foldl-1.1.4/docs/Control-Foldl.html ">>> L.fold ((,) <$> L.minimum <*> L.maximum) [1..10000000]"
10:26:17 * hackagebot jukebox 0.1.6 - A first-order reasoning toolbox  https://hackage.haskell.org/package/jukebox-0.1.6 (NickSmallbone)
10:26:38 <Franciman> oh great, thanks a lot
10:42:30 <ReinH> Franciman: note that you don't need all that extra machinery
10:42:33 <ReinH> > foldl' (\(x,y) z -> (min x z, max y z)) (maxBound, minBound) [1..10000] :: (Int,Int)
10:42:35 <lambdabot>  (1,10000)
10:42:54 <ReinH> It's even nicer when you are folding over monoids, since the product of monoids is a monoid:
10:43:49 <ReinH> > foldMap (Sum &&& Product) [1..10000]
10:43:51 <lambdabot>  (Sum {getSum = 50005000},Product {getProduct = 28462596809170545189064132121...
10:44:45 <Franciman> oh cool
10:45:05 <ReinH> (Min and Max form a semigroup, not a Monoid, generally)
10:46:20 <ReinH> but Option (Min a) and Option (Max a) are monoids
10:46:47 <ReinH> That said, foldl is a really nice package.
10:47:14 <ReinH> :t Pair
10:47:16 <lambdabot> Not in scope: data constructor Pair
10:47:57 <ReinH> (Sometimes tuples can be a problem because they are lazy, so you want something like data Pair a b = Pair !a !b)
10:48:07 <Franciman> ReinH, that's cool
10:48:25 <Franciman> I don't fully understand what it's being done in foldMap
10:49:29 <Franciman> ok nevermind, I figured it out
10:49:58 <ReinH> (&&&) is fanout, a very useful combinator for such things
10:50:10 <Franciman> yup, from Arrows, right?
10:50:14 <ReinH> It's overly general for what we need, which is just fanout f g a = (f a, g a)
10:50:16 <ReinH> yes
10:50:22 <Franciman> I didn't understand Sum and Product
10:50:25 <Franciman> then got it
10:50:38 <ReinH> Just data constructors for the sum and product newtypes
10:50:59 <Franciman> yes
10:51:44 <Franciman> very nice, indeed, thanks
10:51:58 <ReinH> In a more detailed typeclass universe, we might have class Additive a where (+) :: a -> a -> a; zero :: a and class Multiplicative a where (*) :: a -> a -> a; one :: a
10:52:25 <tsahyt> > minimum &&& maximum $ [1..100]
10:52:27 <lambdabot>  (1,100)
10:52:34 <tsahyt> this does two passes over the list though, right?
10:52:38 <ReinH> tsahyt: yes
10:53:04 <ReinH> Franciman: this more detailed typeclass universe exists in:
10:53:08 <ReinH> @hackage numeric-prelude
10:53:09 <lambdabot> http://hackage.haskell.org/package/numeric-prelude
10:53:19 <ReinH> fwiw
10:54:00 <ReinH> although Additive is a group, not a monoid.
10:55:57 <goran> :t (&&&)
10:55:58 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
10:56:09 <tsahyt> :t Min
10:56:11 <lambdabot>     Not in scope: data constructor Min
10:56:11 <lambdabot>     Perhaps you meant one of these:
10:56:11 <lambdabot>       variable sin (imported from Prelude),
10:56:20 <ReinH> There is a Min in semigroups
10:58:27 <tsahyt> ReinH: foldMap ((Just . Min) &&& (Just . Max)) $ [1..100]? Would that be correct?
10:58:36 <tsahyt> It complains about a missing show instance
10:58:50 <ReinH> No, because the Monoid instance for Maybe is wrong
10:59:24 <ReinH> it has a Monoid a => Monoid (Maybe a) constraint. There are two viable options, one is Semigroup a => Monoid (Maybe a), the other is Monoid (Maybe a) that works like First.
10:59:42 <ReinH> The first is available in the semigroups package as Option
11:00:20 <Gurkenglas> All that extra machinery, eh?
11:00:31 <ReinH> foldl
11:00:37 <tsahyt> So, foldMap ((Option . Just . Min) &&& (Option . Just . Max)) [1..100] then
11:00:57 <tsahyt> that's growing quite a bit larger than I expected
11:01:01 <ReinH> Yeah.
11:01:26 <tsahyt> There's also quite a bit of unwrapping left at the end.
11:02:15 <ReinH> that's where ala comes in handy
11:03:18 <tsahyt> ala?
11:03:22 <Tom7> merijn: Thank you merijn, this did the trick for me
11:03:29 <Tom7> oops
11:03:35 <Gurkenglas> Where's "Semigroup m => NonEmpty m -> m"? :(
11:03:37 <Tom7> wignor that
11:04:41 <tsahyt> ReinH: Also, is there a way to generalize that to n-tuples in the fold without giving the fold function explicitly?
11:04:42 <ReinH> Gurkenglas: sconcat
11:04:52 <ReinH> Gurkenglas: in the Semigroup typeclass
11:04:53 <tsahyt> For a fixed n I mean
11:05:09 <ReinH> tsahyt: what do you mean?
11:05:12 <Gurkenglas> Okay, now sconcatMap
11:05:27 <ReinH> Gurkenglas: sconcat . map
11:05:35 <johnw> next!
11:05:35 <Gurkenglas> :(
11:07:38 <tsahyt> ReinH: Say I want a minimum, a maximum, and the sum of all the numbers in a list in a single pass
11:08:38 <tsahyt> So I'd fold over a 3-tuple instead, but (&&&) only fans out to two
11:09:13 <Franciman> ReinH, thank you
11:09:52 <dmj> > ((sum &&& maximum) &&& minimum) $ [1..10 :: Int]
11:09:54 <lambdabot>  ((55,10),1)
11:10:59 <tsahyt> Ah right, there're recursive Monoid instances for nested tuples
11:11:04 <tsahyt> so I can still use foldMap
11:14:05 <dmj> > foldl' (\(a,b,c) acc -> (if a < acc then a else acc, if b > acc then b else acc, c + acc)) (0,0,0) [0..100]
11:14:06 <lambdabot>  (0,100,5050)
11:14:30 <ReinH> And there's always the foldl package
11:18:52 <roelof> Hello, Are there alternatives to boxes to display the contents of a map in a tabular layout ? 
11:19:41 <ReinH> For the terminal? Not really.
11:19:58 <hunteriam> all :: Foldable t => (a -> Bool) -> t a -> Bool
11:19:58 <hunteriam> all p = getAll #. foldMap (All #. p)
11:20:02 <hunteriam> ???
11:20:08 <ReinH> ???
11:20:10 <roelof> ReinH:  bummer 
11:20:25 <ReinH> hunteriam: can you ask a better question than "???"?
11:21:20 <hunteriam> All? coerce?
11:21:37 <roelof> I try to make a financial app and there I need tabular layouts to make things like a balance :( 
11:21:39 <ReinH> Why can't you look those things up?
11:21:47 <ReinH> That's how I learned what they are.
11:22:08 <tsahyt> :t All
11:22:09 <lambdabot> Bool -> All
11:22:12 <tsahyt> Well that was helpful
11:22:15 <Gurkenglas> :t au (bimapping (_Wrapping Min) (_Wrapping Max)) (\f -> sconcat . NE.map (f . (id &&& id)))
11:22:17 <lambdabot> Ord b => NE.NonEmpty b -> (b, b)
11:22:35 <ReinH> Gurkenglas: nice
11:22:39 <ReinH> well, sort of
11:23:00 <hunteriam> m8 I did look them up
11:23:02 <Gurkenglas> Yea that sconcatMap part wants some love
11:23:04 <hunteriam> I wouldnt ask if i hadnt
11:23:12 <ReinH> hunteriam: And? What is your specific question then?
11:23:18 <hunteriam> why?
11:23:27 <ReinH> Can you try to use complete sentences?
11:23:30 <hunteriam> no
11:23:37 <ReinH> Because.
11:23:41 <ReinH> That's why.
11:23:57 <ReinH> if you want help, put some effort into asking questions.
11:25:20 <j0nat> hey
11:25:54 <j0nat> Anyone here?
11:29:09 <roelof> Gurkenglas : Do you know a alternative to boxes to make a tabular input like a financial balance 
11:29:28 <Gurkenglas> > concat ["Why" ++ becauses ++ "? Because" ++ becauses ++ ". " | becauses <- map (concat . (`replicate` " because")) [0..]]
11:29:29 <lambdabot>  "Why? Because. Why because? Because because. Why because because? Because be...
11:29:39 <ReinH> Gurkenglas: <3
11:30:15 <ReinH> That's actually amazing.
11:30:35 <ReinH> roelof: boxes is designed to do that. What problem are you having?
11:31:53 <roelof> I try to make it work so I can us it on 2 , 3  and 4 colums and on a map. Me and my partner can make it work. We have to make fixed columns 
11:36:04 <goran> roelof: not sure I follow, but why isn't lists containing some composite datatype (list, tuple, array, etc) satisfying?
11:36:14 <Gurkenglas> Why not use boxes?
11:36:21 <sleblanc> I am messing around with First and IO; I was expecting the repeating prompts to terminate early as soon as a user typed in something: http://lpaste.net/6177025315181690880
11:37:19 <roelof> I use a datatype who looks like this:  data Table = Table {tableHeaders :: [String], tableData :: [[String]]}
11:37:36 <sleblanc> This is what I am trying to achieve: [IO (Maybe String)] -> IO (Maybe String), where the returned String is the result of the first non-Nothing prompt
11:37:58 <roelof> Gurkenglas:  I use now boxes but I cannot make it generilaze so it can work with any numbers of columns 
11:38:09 <`Guest00000> if i use Language.Haskell.Interpreter, will the compiler just link a lot of GHC code to my program?
11:38:24 <sm> roelof: there is a package called tabular
11:38:32 <Gurkenglas> sleblanc, the IO isn't someone thing coincidentally happens as your code is evaluated - any IO effects you iniate are guranteed to happen at some point. (Barring Ctrl-C or the like.)
11:39:16 <sm> though, I don't know why boxes wouldn't handle any number of columns
11:39:17 <Gurkenglas> :t ala MaybeT (asum .: map) -- This'll do that tho
11:39:19 <lambdabot> Monad n => [n (Maybe b)] -> n (Maybe b)
11:39:35 <Gurkenglas> (But you need to also define my "(f .: g) x = f . g x" ^^)
11:39:52 <tsahyt> :t ala
11:39:53 <lambdabot> (Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
11:39:57 <tsahyt> wat
11:40:08 <tsahyt> What is this function doing?
11:40:09 <Gurkenglas> (And import the lens module ala comes from, and Control.Monad.Trans.Maybe for MaybeT, and Control.Applicative for asum
11:40:41 <sleblanc> Gurkenglas, yowz, seems like a lot of work. I have not touched lenses yet
11:41:06 <Gurkenglas> sleblanc, you can also use monad-loops
11:41:27 <roelof> sm, I also not but me and my partner are trying the whole day to make this work 
11:41:43 <Gurkenglas> Or use MaybeT without any lens stuff, if you know monad transformer stuff - let me annotate your paste
11:42:07 <Gurkenglas> roelof, can you paste your code for a fixed number of boxes?
11:43:51 <roelof> Gurkenglas:  here you have : http://lpaste.net/150324 , This is the lastest version where we have fixed columns which are all left or right aligned 
11:45:09 <Gurkenglas> sleblanc, this should work http://lpaste.net/6177025315181690880
11:45:51 <Gurkenglas> (Oh right you'll need the Control.Monad.Trans.Maybe import)
11:46:41 <OverCoder> Um, when using guard, are we forced to have the latest guard to be with name 'otherwise' or it's just what my tutorial uses?
11:46:56 <geekosaur> @src otherwise
11:46:56 <lambdabot> otherwise = True
11:46:58 <Gurkenglas> > otherwise
11:46:59 <lambdabot>  True
11:47:10 <OverCoder> What does that even mean?
11:47:18 <jle`> OverCoder: otherwise isn't any special syntax
11:47:22 <TimWolla> It is an alias of 'True'
11:47:23 <jle`> it's just True, so it always matches
11:47:25 <sleblanc> OverCoder, "otherwise" is a convention
11:47:29 <geekosaur> guards are just expressions that return True or False
11:47:33 <Gurkenglas> That means putting otherwise in a guard is like putting True in a guard.
11:47:35 <OverCoder> ah, alright, thank you all
11:47:43 <OverCoder> ah right, gotcha
11:48:17 <Gurkenglas> Although I guess that didn't answer his question - are guard chains allowed to be partial?
11:48:41 <sleblanc> Gurkenglas, thank you, I will try it out
11:49:23 <geekosaur> I think so and you get the same exception you'd get for partial pattern matches?
11:50:01 <geekosaur> yep
11:50:04 <MarcelineVQ> don't they drop out to the next pattern if they don't match anything
11:50:13 <geekosaur> "Exception: Non-exhaustive patterns in function ..."
11:50:32 <hunteriam> weird error
11:51:07 <jle`> sleblanc: this pattern looks a lot like "asum"/Alternative, but the default instances won't give you the right behavior
11:51:17 <geekosaur> MarcelineVQ, yes IIRC
11:51:19 <jle`> sleblanc: you want something like foo [x,y,z] = x <|> y <|> z
11:51:42 <jle`> sleblanc: luckily, MaybeT is a newtype wrapper that gives you the instance you want for <|>/Alternative
11:52:01 <jle`> so i'd do asum (map MaybeT xs)
11:52:09 <jle`> and well, unwrap the MaybeT newtype wrawpper afterwards
11:52:18 <Gurkenglas> roelof, why would this not already work with any number?
11:52:19 <jle`> runMaybeT . asum . map MaybeT
11:52:25 <geekosaur> (yes, from testing in ghci)
11:52:29 <bitemyap1> hrm
11:52:47 <jle`> sleblanc: are you familiar with using newtype wrappers to give different instances to types?
11:53:06 <jle`> sleblanc: like, how we often use `Sum`, `Product` to give different Monoid instances to numbers
11:53:42 <roelof> LIke I said, Every colums is or left-or right aligned and I can not set the length and alignment of every column 
11:55:00 <jle`> sleblanc: ah it looks like you are aware, becuase you use First
11:55:38 <Cale> ecognium: Hey, did you ever answer your question? (I just happened to notice it in the scrollback)
11:55:47 <jle`> sleblanc: Alternative is a typeclass that somewhat represents "choice", so x <|> y <|> z is like, x or y or z, whichever one succeeds first.  MaybeT wrappig an `IO (Maybe a)` gives <|> the proper behavior
11:57:41 <ocharles_> Does anyone know of any laws for MonadReader and MonadWriter?
11:57:49 <jle`> hah
11:57:56 <jle`> good one
11:58:03 <bitemyapp> ocharles_: ur funny
11:58:05 <Gurkenglas> roelof, why wouldn't what you have already work for all numbers of columns?
11:58:25 <bitemyapp> ocharles_: steal theirs: https://github.com/non/cats/blob/master/laws/src/main/scala/cats/laws/discipline/MonadReaderTests.scala
11:58:28 <roelof> Gurkenglas:  because I have no clue how 
11:58:35 <Cale> Wait, why is that a joke?
11:58:36 <johnw> ocharles_: get >> get = get is a super trivial one
11:58:57 <roelof> The code gets harder and harder to read and to change to my oponion, Gurkenglas 
11:59:10 <johnw> or rather, ask >> ask = ask
11:59:11 <ocharles_> johnw: yes I can think of laws buy I wondered if anything was agreed upon
11:59:20 <johnw> agreed upon?  muhahaha
11:59:30 <jle`> mtl classes are sort of notorious for being undisciplined wrt laws
11:59:34 <ocharles_> Likewise tell should use the monoid instance
11:59:47 <Cale> local f ask = fmap f ask
11:59:50 <jle`> at least, canonical laws
11:59:55 <johnw> ocharles_: it's been asked before https://mail.haskell.org/pipermail/haskell-cafe/2013-February/106430.html
11:59:57 <johnw> and not responded to
11:59:58 <ecognium> Hi Cale:  No, not yet. 
11:59:59 <jle`> ocharles_: tell is a monoid homomorphism
12:00:08 <jle`> x <> y = tell x *> tell y
12:00:12 <ocharles_> Cale: local isn't algebraic so I'm hoping to not need to rely on that
12:00:23 <ocharles_> I'm thinking of a slightly more principled mtl
12:00:37 <Cale> ecognium: Okay, let's have a look -- what is the type of defaults?
12:00:39 <bitemyapp> jle`: good catch
12:00:49 <ocharles_> jle`: yea
12:01:03 <jle`> so, tell (x <> y) = tell x *> tell y, traverse tell xs = tell (mconcat xs), etc., are consequences
12:01:09 <jle`> but these are just cute properties
12:01:12 <ocharles_> Just bizzare that this isn't stated any whets
12:01:18 <ecognium> Thanks, Cale. `defaults` returns `Options` from  Network.Wreq.Types
12:01:25 <jle`> s/traverse/traverse_
12:01:26 <hunteriam> is there a way to get around `pkg-config` requirements for `stack install sdl2`?
12:01:34 <hunteriam> (windows
12:01:45 <Gurkenglas> roelof, here I refactored some for you on that paste. Where do you even use tableData2?
12:02:16 <Gurkenglas> (divving by []'s length is no problem because the function isn't actually applied to any element.)
12:02:25 <jle`> ocharles_: yeah, some people brought this up after my "mtl isn't a monad transformer library" post; if mtl was supposed to be a package of typeclasses abstracting over effects, where are the laws?
12:02:34 <Cale> ecognium: How are you importing that module?
12:02:45 <ocharles_> hunteriam: check out the SDL 2 issue tracker, we're trying to sort windows out there
12:02:53 <Cale> ecognium: Is it just a simple  import Network.Wreq.Types ?
12:02:54 <hunteriam> ocharles_: thanks
12:03:03 <ocharles_> jle`: rightly so, IMO :)
12:03:21 <jle`> there's a package on hackage with MonadState laws but i don't think they're canonical
12:03:53 <roelof> Gurkenglas:  where is the past, or is that the annoted one on my paste ?
12:04:06 <ecognium> Cale:  I did not import the Types for updating the defaults. I was just importing these: 
12:04:14 <ecognium> import Network.Wreq
12:04:14 <ecognium> import Network.HTTP.Client.TLS
12:04:14 <ecognium> import Network.Connection
12:04:16 <ecognium> import Control.Lens
12:04:21 <roelof> Gurkenglas:  TableData2 is some text data 
12:04:38 <ocharles_> jle`: do you know which package that is?
12:04:48 <Gurkenglas> roelof, but where is it *used*? (yep the annotation)
12:05:05 <roelof> I used it in ghci 
12:05:12 <ecognium> Cale: I am guessing to update a field I need to import the record fields? sorry I am just a beginner in Haskell. 
12:05:22 <roelof> I could make a main that uses it 
12:05:27 <Cale> ecognium: Okay, it looks like the problem is that Network.Wreq isn't re-exporting the field selectors of that Options type
12:06:20 <jle`> ocharles_: hm, i can't seem to find it
12:06:29 <OverCoder> I've had this before, it was because of bad indentation, but this time I can't see anything wrong, the error is missing required 'in' http://p.samuraimanpurse.com/tx7c72JQ.txt
12:06:43 <jle`> OverCoder: "smaller" is considered a part of "bigger"
12:06:52 <jle`> because it's indented past the b
12:06:54 <ecognium> Cale: got it. I guess I need to import some of these libraries qualified so I can get manager field and update it. It seems like there is a conflict with the one defined in Network.Wreq.Lens
12:07:04 <jle`> let bigger = ...
12:07:10 <jle`>     smaller = ...    -- should work
12:07:23 <Cale> ecognium: Actually, just importing the module qualified ought to do
12:07:23 <OverCoder> o.o
12:07:27 <roelof> Gurkenglas:  I annoted it with a old version with main that uses datatable2 
12:07:27 <OverCoder> um, lemme take you a screenshot
12:07:40 <Cale> ecognium: Like, add the line  import qualified Network.Wreq.Types
12:08:12 <Cale> ecognium: and just keep doing what you're doing -- you shouldn't even need to add qualifiers (I don't think they're allowed inside record update field names anyway)
12:08:17 <Gurkenglas> OverCoder, your editor uses tab width 4 and apparently ghc's uses 8 and so smaller appears further indented than bigger, so don't use tabs.
12:08:26 <MarcelineVQ> use spaces instead of tabs OverCoder, your life will be much simpler
12:08:29 <OverCoder> ah
12:08:30 <OverCoder> hm
12:08:40 <MarcelineVQ> Gurkenglas: beat me to it :>
12:09:10 <Cale> ecognium: I'm guessing the name conflicts are why it doesn't already export the field names by default, but that's kind of a silly solution rather than just making them more unique. :)
12:09:10 <OverCoder> Ayyyyy it works now :>
12:09:24 <Cale> ecognium: See if that works, anyway
12:09:34 <OverCoder> Basically I was shocked why the code showed different in the paste, I mean it shows exactly what jle said in my editor
12:09:37 <OverCoder> Stupid tabs
12:10:00 <Gurkenglas> I have a dream that IDEs of the future will tell you exactly what you did wrong with your indentation because it took me ridiculously long to get the rules even given the documentation and that's just a stupid source of errors
12:10:02 <Cale> ecognium: Oh, of course, Network.Manager.Lens has *lenses* for the fields
12:10:40 <Cale> ecognium: Which of course, you could use instead
12:11:14 <ecognium> Cale: importing qualified did not solve the problem :( I don't know much about lens how do I use it in this case to update the manager? 
12:11:36 <Cale> http://hackage.haskell.org/package/wreq-0.4.1.0/docs/Network-Wreq.html#v:defaults -- there's some example code here
12:12:01 <OverCoder> Gurkenglas, I wish they could, it can't be hard to make
12:12:46 <Cale> ecognium: I think maybe your problem now is that the manager field is internally some type called Mgr, which doesn't look like it's used externally? Are you getting type errors now?
12:13:02 <Gurkenglas> It sounds like the sort of stuff horifically overfed expert systems of the past decades should work for, as opposed to say medicine.
12:13:10 <roelof> Gurkenglas:  thanks for the help, Im going to sleep over it 
12:13:11 <Cale> ecognium: If that's the case, then definitely using the lens in a way similar to the examples should help
12:13:44 <ecognium> Cale: I used this and it type checks in ghci. let opts = defaults & manager .~ Left ms
12:13:53 <Cale> okay, cool
12:14:02 <ecognium> Not sure I understand it all but blindly copying the example link you shared
12:14:07 <sleblanc> Gurkenglas, thanks, it works in context. jle`, thanks for the input. I am sure I can find an use for <|> with a handful of values but I am not sure how to use it with potentially infinite lists
12:14:37 <ecognium> I was not getting type errors with the other approach but the same error which is `manager` is not a record selector. 
12:14:50 <sleblanc> I see there's `some` and `many`, but when I use it like so: some [Nothing, Just 1], my ghci interpreter hangs (??)
12:15:00 <sleblanc> ^ jle`
12:15:13 <ecognium> Thank you for pointing me to the Lens example, Cale. I am going to try to make a Get call to see if it works 
12:15:19 <Gurkenglas> sleblanc, asum is foldl (<|>) empty
12:15:56 <sleblanc> Gurkenglas, oh, ha, that was obvious. What are `some` and `many`, then?
12:16:14 <Cale> ecognium: So yeah -- the types are complicated, but basically, whenever you have a lens l from some record to one of its fields, l .~ x gives the operation for updating that field to the value x
12:16:26 <Gurkenglas> You are so lucky I am here because I just got this like a few days ago and Im not sure anyone else ever has
12:16:40 <sleblanc> :-)
12:16:44 <Gurkenglas> And Ive been wondering for months or so
12:16:47 <Cale> ecognium: and the & is just silly backwards function application (I don't know why people like this, but I guess we'll just go with it)
12:16:59 <Gurkenglas> :t liftM fromJust . runMaybeT . many . MaybeT
12:17:01 <lambdabot> Monad m => m (Maybe a) -> m [a]
12:17:38 <Gurkenglas> Does it until Nothing is returned, then (!) returns all the results until then in a list
12:17:42 <sleblanc> Gurkenglas, I'm just learning Haskell, and for me there were so many instances of writing stuff and wondering if there's a simpler way. Then I'd go to bed, ponder a bit before falling asleep and wake up the next day knowing what to change
12:17:53 <Gurkenglas> I know that feel
12:18:34 <Gurkenglas> some is the same, but will return Nothing if the list would be empty - so don't use fromJust there :P
12:18:48 <Cale> ecognium: Whenever you can write  myRecord & fieldLens .~ newValue  you could also write  set fieldLens newValue myRecord
12:19:09 <Cale> Which I find way easier to read personally
12:20:25 <Gurkenglas> It doesnt give you anything until the Nothing that ends the chain because it doesn't know whether the end result will be a Nothing (even though a Nothing (after the first Just for some) is impossible), and so must wait for the rest of the monadic computation to complete
12:20:40 <Cale> sleblanc: Yeah, everyone is also doomed to write at least half of the standard library while they're learning :D
12:21:21 <Gurkenglas> Cale, the left version is easier to convert to stateful code
12:21:42 <Cale> Gurkenglas: You can  modify (set fieldLens newValue)
12:21:48 <EyeJoy> how to do type constraint on data, for example :  data SomeType a = (Monoid a) => First a | Second  
12:21:49 <sleblanc> Cale, it's okay, I did it in C in embedded systems class, I can do that in Haskell too! If only I learned about category theory earlier
12:21:58 <Gurkenglas> Okay, to the better stateful code :P
12:22:19 <Cale> EyeJoy: Generally the correct answer is "put the constraints on the functions that operate on your data"
12:23:44 <ecognium> Cale: thank you again. I was able to successful make a request avoiding the TLS Exception.  Also thanks for the tip on how to read the lens.  I am going to read through the wreq tutorial now and it has some explanation around lenses. I could not get past the first few lines of the tutorial coz of the TLS issue so got stuck there. 
12:23:49 <Gurkenglas> I'm still trying to get sufficiently many people to think about how to get ghc to use the "irrefutable pattern match" promise made by fromJust and propagate it to make "liftM fromJust . runMaybeT . many . MaybeT" lazy
12:23:50 <aweinstock> Cale: is using existential types the only place where that sort of constraint (on data) is useful?
12:24:21 <Gurkenglas> > fromJust $ (1:) <$> undefined -- ie this should print "[1," before crashing
12:24:23 <lambdabot>  *Exception: Prelude.undefined
12:24:55 <aweinstock> :t (1:) <$> undefined
12:24:57 <lambdabot> (Functor f, Num a) => f [a]
12:25:37 <lyxia> > fromJust $ (1:) <$> Just undefined
12:25:38 <lambdabot>  [1*Exception: Prelude.undefined
12:25:48 <aweinstock> > Maybe [1:undefined]
12:25:50 <lambdabot>      Not in scope: data constructor Maybe
12:25:50 <lambdabot>      Perhaps you meant one of these:
12:25:50 <lambdabot>        MaybeT (imported from Control.Monad.Trans.Maybe),
12:25:51 <Gurkenglas> Right, it should infer that Just from the fromJust
12:25:56 <aweinstock> > Just [1:undefined]
12:25:58 <lambdabot>  Just [[1*Exception: Prelude.undefined
12:26:06 <aweinstock> > Just [1,undefined]
12:26:08 <lambdabot>  Just [1,*Exception: Prelude.undefined
12:26:13 <aweinstock> > fromJust $ Just [1,undefined]
12:26:15 <lambdabot>  [1,*Exception: Prelude.undefined
12:26:20 <int-e> aweinstock: lambdabot answers private messages
12:26:50 <aweinstock> int-e: sorry for spamming
12:28:28 <aweinstock> Gurkenglas: how is (Just [1,undefined]) different from (fmap (1:) undefined :: Num a => Maybe [a])?
12:28:59 <aweinstock> (because they behave differently w.r.t. fromJust)
12:29:11 <Gurkenglas> You want (1:undefined) there on the left
12:30:04 <aweinstock> [1, undefined] == 1:undefined:[] ,so that's the difference?
12:30:23 <Gurkenglas> undefined is not undefined : []
12:31:09 <aweinstock> > fromJust $ Just (1:undefined) -- this still behaves differently
12:31:10 <lambdabot>  [1*Exception: Prelude.undefined
12:31:27 <jle`> sleblanc: some and many really only make sense for some Alternative instances
12:31:52 <jle`> for MaybeT (IO (Maybe a)), it doesn't really make sense, i don't think
12:31:53 <Gurkenglas> > fmap (1:) Nothing -- So you don't know that "fmap (1:) undefined" has the form "Just (1:undefined)" - it might be Nothing
12:31:55 <lambdabot>  Nothing
12:31:58 <jle`> or, for IO (Maybe a), i should say
12:32:04 <infandum> Is there a function like groupBy that checks all pairs, not just adjacent pairs?
12:32:18 <infandum> Complexity would be O(n^2)
12:32:44 <kadoban> infandum: \f -> groupBy f . sort  -- ?
12:34:21 <infandum> kadoban: I can't do that because I have no way to sort
12:34:39 <kadoban> infandum: They're not Ord ?
12:34:42 <infandum> Let's say there is no Ord
12:34:44 <Gurkenglas> :t M.elems . M.fromListWith (++) . map (?f &&& pure) -- If the target of f is Ord
12:34:44 <infandum> yeah
12:34:46 <lambdabot> (Ord k, ?f::a -> k) => [a] -> [[a]]
12:35:36 <infandum> There is only Eq (a fuzzy eq really, defined by % similarity)
12:36:41 <infandum> So group everyone within +/- 2 of each other in a list [1,2,3,6,7,9] would be [[1,2,3],[6,7,9]]
12:36:52 <infandum> but pretend they were unordered and unsorted
12:37:12 <infandum> I thought I could find a function already existing to do that but no luck so far
12:37:15 <ocharles_> jle`: no problem if you're busy, but I'm thinking of adding the monoid homomorphism property as a law to MonadLog. I can't do with   logMessage :: a -> m ()  because I know nothing about a. 
12:37:22 <kadoban> infandum: "within 2 of each other" isn't an equivalence class I don't think. Does that matter? It's going to get pretty funky what answer you end up with, it'll depend on the order you check them in.
12:37:28 <Gurkenglas> infandum, so it's ok if the grouping that results depends on the initial order?
12:37:29 <ocharles_> I'm thinking of having:  logMessageF :: (forall n. Monoid n => (a -> n) -> n) -> m ()
12:37:41 <ocharles_> can you see any other way? (other than choosing [a] or some other container)
12:38:27 <infandum> kadoban: Yes. I would have to recursively run it over and over until the length doesn't change
12:38:45 <infandum> Gurkenglas: No. There is no order at all
12:38:57 <kadoban> infandum: Hmm  I'm not sure that makes sense/fixes the problem.
12:39:32 <lyxia> :t \f -> unfoldr (\xs -> case xs of [] -> Nothing ; x : xs -> first (f x) $ partition (==x) xs) -- infandum 
12:39:33 <lambdabot>     Couldn't match type (c, [a1]) with Maybe (a, [a1])
12:39:33 <lambdabot>     Expected type: ([a1], [a1]) -> Maybe (a, [a1])
12:39:33 <lambdabot>       Actual type: ([a1], [a1]) -> (c, [a1])
12:39:40 <lyxia> aaaaahhh
12:39:50 <lyxia> :t \f -> unfoldr (\xs -> case xs of [] -> Nothing ; x : xs -> Just . first (f x) $ partition (==x) xs) -- infandum 
12:39:51 <lambdabot> Eq a1 => (a1 -> [a1] -> a) -> [a1] -> [a]
12:40:16 <infandum> kadoban: Why not? You would compare sublists then by comparing each list with another list and if one of the elements with another of the elements has that fuzzy equivalence, then merge them
12:40:18 <kadoban> infandum: What do you want the answer to be for [1..6] ?    [[1,2,3], [4,5,6]] I guess? But if you do it in a different order, you'd get [[1,2,3,4], [5,6]] for instance (from [2,1,3,4,5,6], say you check for 'within 2 of 2 first')
12:40:30 <infandum> kadoban: It would be [1,2,3,4,5,6]
12:40:46 <infandum> as the final answer
12:40:54 <lyxia> uh
12:41:15 <lyxia> so, the transitive closure?
12:41:36 <kadoban> infandum: This is starting to sound a bit more like a graph algorithm than anything to me. It's like uhm  connected components for the undirected graph where each node is connected to the nodes numbered within 2 of each other.
12:41:52 <infandum> something like that
12:41:58 <kadoban> But everything can be a graph algorithm if you try hard enough, maybe there's a better way to express it.
12:42:05 <infandum> haha
12:42:08 <infandum> true
12:42:43 <dedgrant> kadoban: an interpretation of clustering?
12:43:07 <infandum> I tried just having a recursion of sets merging together, but in order to compare each set with another set I used the <$> <*> applicative trick. Unfortunately I had no way of getting rid of multiples that would have merged so it went on forever
12:43:41 <kadoban> infandum: What kind of representation of sets were you using? Just unordered lists?
12:44:39 <infandum> The data is ordered, but the order has no effect. I just used the sets for union convenience
12:45:20 <infandum> Like, the order has no effect on clustering with this distance
12:45:38 <kadoban> Ah
12:46:14 <kadoban> I mean I guess the naive simple recursive solution should be pretty easy to write up, but it's also going to be pretty slow. How big is your data?
12:46:26 <infandum> lyxia: I don't think it would be transitive closure because 1 - 6 > 2, right?
12:46:31 <justicefries> wow, what's the best way to mix my existing vim/nvim setup with https://github.com/begriffs/haskell-vim-now?
12:46:35 <infandum> or maybe that's what it means
12:46:44 <justicefries> i like it, but wow does it stomp all over everything
12:47:53 <lyxia> infandum: that's not how transitive closure works. 1 is related to 3 which is related to 5 which is related to 6 by your relation r. Thus 1 is related to 6 by the transitive closure of r.
12:48:05 <infandum> infandum: Then yes, haha
12:48:09 <infandum> er lyxia
12:49:12 <kadoban> wikipedia says it can be solved with floyd-warshall? *ponders*
12:50:36 <infandum> That might be overthinking it a bit
12:50:37 <tsahyt> justicefries: I just went through their vimrc and copied the mappings that I wanted
12:50:48 <kadoban> I guess that makes sense. But yeah is it necessary? How big is your data? Pretty small, or?
12:50:55 <infandum> smallish
12:50:59 <infandum> say 100 - 200 in the list
12:51:07 <infandum> that's why n^2 didn't matter to me
12:51:35 <kadoban> Well I think it's worse than n^2, unless I'm missing something (which is quite possible)
12:51:52 <infandum> hm
12:51:54 <kadoban> But that still should be okay for data that big, depending on how responsive it has to be.
12:52:00 <jle`> ocharles_: i can't think of a nice way either at the moment, sorry
12:52:06 <jle`> but it's an interesting question
12:52:57 <justicefries> tsahyt: ah, fair.
12:53:13 <justicefries> yeah, lots of good stuff in here.
12:53:24 <infandum> kadoban: Is there a findWithInsert function or something that compares a single element to all elements in a list, and when True is returned combined the element with the found element in the list? That would solve my problem pretty quickly 
12:53:26 <infandum> maybe
12:53:53 <infandum> I guess I could write that myself pretty easily now that I thought of it
12:54:48 <kadoban> infandum: Not that I know of. I think 'partition' might be useful? You'll still have to do a decent amount of plumbing though.
12:54:51 <kadoban> :t partition
12:54:52 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
12:55:22 <kadoban> So you could use that to pick out "within 2 of the current one I'm looking at" and then for each of *those* check the remaining list again, etc.
12:55:57 <kadoban> Kind of funky, but sounds doable.
12:57:07 <infandum> kadoban: Ah, so that searches, I can insert it to the search, recombine then, go another round until none work. Got it!
12:57:09 <infandum> Thank you!
12:57:30 <kadoban> infandum: 'welcome. Hope it goes well. Kind of interesting problem.
12:58:04 <infandum> Wow, even better! It separates the true from false! This will be a lot faster than I thought as I can just join the left side, nice
12:58:09 <jle`> ocharles_: on an unrelated note, it'd be interesting to use your library with something like http://www.haskellforall.com/2014/02/streaming-logging.html
12:58:21 <kadoban> infandum: Heh yeah, it's a pretty nice function.
12:58:50 <ocharles_> jle`: runLoggingT m yield. done! :)
12:58:59 <jle`> sweet!
12:59:15 <kadoban> It should be O(n^3) ? I don't know if that's a tight bound though. Might be.
12:59:23 <kadoban> Not too bad.
12:59:59 <ocharles_> jle`: I did start with something like that though, but I think the type I now have (with the free monoid) is as general as you can get while retaining some sense of expectedness
13:00:21 <lyxia> http://lpaste.net/150330 infandum 
13:01:57 <infandum> lyxia: Ah, yes, using partition as well!
13:02:32 <lyxia> A bit too many tuple-deconstructing to my tastes but that seems to work
13:02:50 <infandum> I'll check it out
13:08:40 <infandum> lyxia: Perfect! You're amazing!
13:09:15 <infandum> You should put that in Data.List or something as I can't be the only one who finds it useful
13:12:38 <lyxia> infandum: I annotated it with a one-line-shorter version
13:12:51 <jle`> ocharles_: so your law would be logMessageF x *> logMessageF y = logMessageF (\f -> x f <> y f) ?
13:13:20 <ocharles_> jle`: logMessageF x *> logMessageF y = logMessageF (x <> y) is enough
13:13:24 <ocharles_> see Monoid instance on functions
13:13:30 <jle`> oh yeah, that is a thing
13:13:33 <ocharles_> :)
13:13:42 <ocharles_> so that's pretty elegant
13:13:50 <ocharles_> I'm entirely sure how to prove my instances satisfy it though
13:13:57 <jle`> but, is this an actual law for your instances?
13:14:22 <jle`> good luck :)
13:14:28 <ocharles_> I have newtype Ap m = Ap { runAp :: m () }, and then logMessageF foldMap = LoggingT (\handler -> runAp (foldMap (Ap . handler)))
13:15:17 <ocharles_> I can prove it if I know what foldMap is (e.g., \inj -> inj x), but I'm not sure I'm allowed to do that in equational reasoning
13:19:43 <infandum> lyxia: Nice. I can even use sequences with it
13:23:47 <OverCoder> Can I think of $ as a replacement for parenthesis?
13:24:20 <OverCoder> Because I find it somewhat hard to think what $ is doing in a code
13:24:34 <OverCoder> It takes me few seconds before I figure out
13:24:40 <liste> OverCoder yes, basically
13:24:46 <OverCoder> hm, thanks
13:25:33 <liste> a (b c) = a $b c
13:27:53 <bergmark> a b $ c d = (a b) (c d)
13:29:05 <jle`> OverCoder: i think about it like the spine of a butterfly that spreads its wings over both sides
13:29:24 <jle`> a b c d $ w x y z = (a b c d) (w x y z)
13:29:32 <jle`> but that's just me
13:29:57 <OverCoder> hm, gotcha, thank you all
13:29:59 <srhb> I think of it as right associative function application... 
13:30:02 <jle`> it's a little more convoluted when you have more than one $ in a line, but
13:30:03 <srhb> :-)
13:30:20 <jle`> it's a butterfly ok TT_TT
13:30:25 <liste> multi-spine butterfly
13:30:36 <liste> an abomination created by scientists
13:30:38 <verement> $ has a nice mnemonic: the shape of the symbol itself looks like an opening and closing parenthesis
13:31:28 <lyxia> That explains why I keep typing O instead.
13:31:53 <jle`> what hath man wrought
13:32:36 <OverCoder> meh, I just think that $ is a crappy thing
13:32:40 <OverCoder> Is only brings confusion
13:32:51 <OverCoder> None of the imperative langauges support anything like it
13:33:27 <liste> that's not a con
13:36:45 <Gurkenglas> lyxia, http://lpaste.net/150342 have some refactoring! (Not sure what sort of ListT stuff to use to get the recursion out of line 15)
13:37:24 <hodapp> I never found $ to only bring confusion... I found the explanation pretty simple, and in a language where nesting is very common, I think it can greatly assist making the code less confusing.
13:45:32 <lyxia> Gurkenglas: Hahaha awesome.   < infandum
13:48:00 <lyxia> Gurkenglas: it's an amazing coincidence that partition gives its result in the order that fits state
13:48:51 <Gurkenglas> Coincidence? I think not.
13:54:25 <OverCoder> Seriously, what's the difference between notElem and not elem
13:54:32 <OverCoder> I mean, aren't they the same thing? >.>
13:55:08 <OverCoder> I mean notElem is simply the negation of elem
13:55:14 <OverCoder> There's no point of making it a separate function
13:55:14 <liste> notElem is convenient to use in backticks? (just a guess)
13:55:24 <Gurkenglas> lyxia, next version: http://lpaste.net/1137723792894722048
13:55:47 <liste> foobar a b | a `notElem` [1,2,3]= ...
13:55:58 <liste> as an example
13:56:03 <KaneTW> @src notElem
13:56:03 <lambdabot> notElem x = all (/= x)
13:56:04 <KaneTW> @src elem
13:56:05 <lambdabot> elem x = any (== x)
13:56:08 <OverCoder> but either way it's not worth a new function
13:56:16 <infandum> Gurkenglas: Now it's just getting more confusing haha
13:57:14 <KaneTW> OverCoder: with that attitude a lot of functions aren't worth it
13:57:35 <lyxia> Do we pay anything for them? :P
13:57:57 <OverCoder> Well, spamming the namespace, other than that, no
13:58:30 <KaneTW> using it in backticks is a good enough reason to have it
13:59:04 <Gurkenglas> "fix $ \f x -> return x <|> ?g x >>= f" sounds like it ought to be a recursion pattern.
13:59:43 <Gurkenglas> *scheme
14:06:28 <goran> What does "?g" mean?
14:07:04 <Gurkenglas> Some function g that I'm not defining. It is useful in :t queries because it doesn't require you to put \g -> at the start
14:07:14 <Gurkenglas> :t map ?f
14:07:15 <lambdabot> (?f::a -> b) => [a] -> [b]
14:07:28 <liste> they're implicit parameters, right?
14:08:14 <sleblanc> What is the name of this value: ()
14:08:17 <sleblanc> Is it the 0-tuple?
14:08:30 <Gurkenglas> Pretty much, yep. we call it unit
14:08:53 <Gurkenglas> All of its deconstructors are defined in every module btw
14:09:23 <goran> Ah, so "?g" wouldn't ever be used in real code then?
14:10:24 <Gurkenglas> > head [1, ?f]
14:10:27 <lambdabot>  mueval-core: internal error: PAP object entered!
14:10:27 <lambdabot>      (GHC version 7.10.2 for x86_64_unknown_linux)
14:10:27 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
14:11:15 <goran> I take that as a "no" :-)
14:11:48 <shachaf> It can be used in real code.
14:12:05 <shachaf> It's an argument which is passed implicitly to functions that need it.
14:12:23 <liste> > let foobar :: (?arg :: Int) => Int; foobar = ?arg + ?arg in (let ?arg = 5 in foobar)
14:12:25 <lambdabot>  10
14:13:16 <goran> my brain...
14:14:06 <jcowan> Question:  Is it useful (as opposed to meaningful) to fold over a sequence of exact integers specified by start and end?  How would you achieve this without writing your own fold from scratch?
14:15:17 <liste> > foldr (*) 1 [1..5] -- jcowan you mean this?
14:15:18 <lambdabot>  120
14:15:20 <shachaf> i,i is it meaningful to fold over a short exact sequence?
14:15:56 * jcowan nods.
14:16:11 <jcowan> Yes, that's the brute force way.  But is there any shortcut to it?
14:16:23 <sleblanc> jcowan, monoids
14:17:09 <sleblanc> > mconcat $ map Sum [1..10]
14:17:10 <lambdabot>  Sum {getSum = 55}
14:17:16 <Gurkenglas> > (ala Product foldMap [1..5], foldMap Product [1..5])
14:17:17 <lambdabot>  (120,Product {getProduct = 120})
14:17:29 <sleblanc> > getSum . mconcat $ map Sum [1..10]
14:17:30 <lambdabot>  55
14:17:42 <sleblanc> ohh, foldMap
14:17:44 <jcowan> Presumably that only works if the seed for the fold is the monoid identity, no?
14:18:15 <Gurkenglas> > foldr1 (+) [1..5]
14:18:16 <lambdabot>  15
14:18:26 <liste> yeah, foldMap uses mempty and mappend
14:18:44 <liste> @src foldMap
14:18:44 <lambdabot> Source not found. My brain just exploded
14:18:55 <liste> (I guess it was a method)
14:19:00 <sleblanc> poor lambdabot
14:19:46 <liste> jcowan what do you mean by brute force btw?
14:20:00 <Gurkenglas> hardcoded presumably
14:20:05 <jcowan> construct a lazy list, fold over it
14:20:15 <jcowan> obvs works with any data structure
14:20:56 <liste> well, all of the solutions here construct a lazy list (:
14:21:04 <jcowan> but in some cases we know there are closed-form solutions, as in Gauss's solution for adding up consecutive integers
14:21:12 <jcowan> can we take advantage of this in general?
14:21:55 <kadoban> jcowan: You need to know (much) more about it than it's a monoid for that.
14:22:15 <Gurkenglas> Pretty sure CS can prove you can't reduce all the folds to constant time
14:22:18 <Hafydd> jcowan: I believe that GHC has rewrite rules for cases like that.
14:22:33 <jcowan> Sure, monoids weren't my idea.  Is there a more general possible type class (not necessarily already implemented)?
14:23:00 <Hafydd> (Although I have no idea why you'd write something that can obviously be reduced to a closed form.)
14:23:25 <kclancy> does anyone know of a haskell library that allows me to control the rounding modes of individual floating-point operations? I've tried the first few to show up in google searches, but they have all been deprecated, or fail to build.
14:23:41 <Gurkenglas> closed form doesnt sound well defined what operators do you allow?
14:24:09 <kadoban> jcowan: I just mean it's going to be specific to exactly what fold you're doing and what the range is.
14:24:18 <Hafydd> Gurkenglas: I recommend you make more use of the Comma Operator.
14:24:35 <Gurkenglas> Ill return to doing that once my hands arent all grapefruity
14:24:37 <Hafydd> (Or the semicolon, or full stop operator.)
14:24:49 <kadoban> The sentence composition operator?
14:25:08 <jcowan> Gurkenglas: Anything that doesn't depend on a recurrence over every value in the sequence
14:26:16 <osa1> we don't have anything in base for showing ints/words etc. in binary, right?
14:26:38 <KaneTW> Text.Printf maybe?
14:26:57 <osa1> ha
14:27:04 <osa1> I didn't even know we have such a module
14:27:27 <liste> osa1 Numeric.showIntAtBase
14:27:32 <KaneTW> that's not base
14:27:44 <KaneTW> or is it
14:27:46 <liste> yes it is
14:27:46 <KaneTW> it is
14:27:48 <KaneTW> huh
14:27:50 <KaneTW> yeah
14:27:54 <osa1> liste: amazing, thanks
14:28:15 <osa1> base is full or surprises o_o
14:28:55 <jakeehrlich> Is there a monad that stores previous values? So that m >>= f first stores the value I would get by run m before computing f? Im having a hard time figuring out how to handle the typeing issue.
14:28:56 <osa1> it has showHex but not showBin
14:29:03 <osa1> sad
14:30:26 <liste> > showIntAtBase 2 (\x -> if x = 0 then '0' else '1') 127
14:30:29 <lambdabot>  <hint>:1:24:
14:30:29 <lambdabot>      parse error in if statement: missing required then and else clauses
14:30:43 <liste> > showIntAtBase 2 (\x -> if x == 0 then '0' else '1') 127
14:30:45 <lambdabot>  <[Char] -> [Char]>
14:31:58 <liste> > showIntAtBase 2 (\x -> if x == 0 then '0' else '1') 127 ""
14:32:00 <lambdabot>  "1111111"
14:33:41 <twanvl> > showIntAtBase 2 intToDigit 127 ""
14:33:43 <lambdabot>  "1111111"
14:34:21 <Gurkenglas> > ((reverse . concatMap show . fromJust) .: evalStateT $ many $ getsT (guard . (>0)) >> state (swap . flip divMod 2)) 124
14:34:22 <lambdabot>  "1111100"
14:34:51 <Gurkenglas> Hmm maybe that was a coincidence after all.
14:36:51 <Gurkenglas> jakeehrlich, if you want access to them later in the monad, State, else Writer.
14:37:45 <liste> maybe wrap that in a newtype with a different Monad instance
14:37:46 <jakeehrlich> State dosnt do what I want I think. State stores 1 state. I want to store every value the state has undergone
14:37:55 <goran> :t (.:)
14:37:56 <lambdabot> (b -> c) -> (t -> a -> b) -> t -> a -> c
14:38:05 <Gurkenglas> Defined by yours truly
14:38:26 <Gurkenglas> Note that (f .: g) x = f . g x and (f . g) x = f $ g x
14:39:07 <goran> So order of evaluation differs?
14:39:35 <goran> Or not?
14:40:10 <sleblanc> jakeehrlich, can this state change type?
14:40:11 <Gurkenglas> I use .: mostly to be able to write "f .: g $ some big line of code" instead of "f . g (some big line of code)"
14:41:09 <Gurkenglas> jakeehrlich, if you use the Writer monad with the [] monoid you can store one element per operation
14:41:25 <kadoban> goran: It's not the evaluation order that differs, it's the type of 'g'.
14:42:20 <kadoban> goran: In  f . g    g probably takes only one argument.   In f :. g, g probably takes two arguments
14:42:24 <crossroads1112> @src seq
14:42:24 <lambdabot> Source not found. :(
14:43:53 <goran> Ah, ok. That clarifies stuff, thx. Dont know why I didn't get that from the type...
14:43:58 <Gurkenglas> lyxia, http://lpaste.net/1137723792894722048 (need a better name for phi)
14:44:46 <Gurkenglas> crossroads1112, the specification is "seq _|_ _ = _|_; seq _ x = x"
14:58:46 <Gurkenglas> Oh hey phi looks kind like the Monad instance of Cofree http://hackage.haskell.org/package/free-4.12.4/docs/src/Control-Comonad-Trans-Cofree.html#line-170
15:05:54 <jakeehrlich> sleblanc: Im not conveying this very well. I want two functions. run and runValues. run will return the value of the monad. runValues will return both the current value and all previous values (which might have diffrent types). So a value should be added the the list of previous values on every call to >>=. So m >>= f should add run m to the list of values output by runValues. Basically just 
15:05:54 <jakeehrlich> like the identity monad except that each value the monad undergoes is recorded in the history 
15:06:37 <Gurkenglas> How can it return a list of previous values if they can h ave different types?
15:08:12 <sleblanc> Gurkenglas, I suppose in jakeehrlich it can't; that was the intent behind my question
15:08:36 <AbelianGrape> Hello all. I would like to make an IDE extension that looks at a hole and searches through in-scope terms to look for those that could ostensibly fill the hole. Two questions: 1. Does GHC have a facility for determining the type of holes that works better than "_"? This often gives incorrect results. For example, "main = print $ 5 + _" infers the type of "_" to be "Integer", although it should be "Nu
15:08:42 <AbelianGrape> m a, Show a => a". 2. What is a good starting point to read about building GHC plugins?
15:08:55 <jakeehrlich> Gurkenglas: thats what Im trying to overcome and why I put list in quotes
15:09:43 <Gurkenglas> :t print $ 5 + ?hole -- AbelianGrape
15:09:44 <lambdabot> (Num r, Show r, ?hole::r) => IO ()
15:09:45 <AbelianGrape> jakeehrlich: If you know the possible types in advance, you can wrap them in a type with one constructor for each possible previous value type.
15:10:17 <AbelianGrape> jakeehrlich: If you don't know in advance, you can use a typeclass and Existential types (forall types)
15:10:57 <jakeehrlich> AbelianGrape: so basically a homogenous list is the right idea
15:11:16 <Gurkenglas> Although if you use a typeclass whose only features are conversion to a common successor type (imagine Show), you can just convert to that type immediately and store the results in your list
15:11:27 * hackagebot atrans 0.1.1.0 - A small collection of monad (transformer) instances.  https://hackage.haskell.org/package/atrans-0.1.1.0 (apho)
15:11:36 <AbelianGrape> jakeehrlich: Yeah, homogenous lists are best. E.g. if the list might contain A or B, make a type Wrapper = WA A | WB B
15:12:02 <AbelianGrape> jakeehrlich: Avoid heterogenous lists if you can. They work fine, but are a little less aesthetically pleasing.
15:12:51 <AbelianGrape> Gurkenglas: When I type that into GHC, it tells me "parse error on input ?". Is this an extension?
15:13:13 <jakeehrlich> Gurkenglas: That might be possible. Ultimentlly I want to print out a the list so the final result is a list of strings. Problem is I dont know how to make a monad on the condition that the argument type is showable
15:13:47 <geekosaur> AbelianGrape, it's ImplicitParameters extension
15:14:18 <AbelianGrape> geekosaur: I don't have that available. Is that a very new extension?
15:14:28 <geekosaur> it's a fairly old one...
15:14:42 <AbelianGrape> geekosaur: Oh, it's ImplicitParams
15:14:46 <AbelianGrape> no "eters"
15:14:50 <geekosaur> oh, sorry
15:15:26 <Gurkenglas> jakeehrlich, I am reminded of http://ircbrowse.net/browse/haskell?id=22104513&timestamp=1452643593#t1452643593
15:15:27 * geekosaur doesn;t actually use it very often, except with lambdabot (sometimes in /query)
15:15:27 <AbelianGrape> geekosaur: Gurkenglas: thanks, that is exactly what I wanted
15:16:01 <AbelianGrape> Also, does anyone know of similar projects? Basically a unification of ImplicitParms ?holes and Hoogle
15:16:03 <jakeehrlich> can I use that with the Monad syntax?
15:16:28 <Gurkenglas> Oh right do notation.
15:16:51 <Gurkenglas> jakeehrlich, http://ircbrowse.net/browse/haskell?id=22143682&timestamp=1453283979#t1453283979 :D
15:17:11 <chrisdotcode> hey guys, is (>>) isomorphic to (*>) ?
15:17:23 <chrisdotcode> er, in functionality
15:17:37 <chrisdotcode> I think *> only works on applicatives and >> only for monads, I think
15:17:54 <kadoban> chrisdotcode: AFAIK they should be exactly the same thing for those that have both, yeah.
15:18:00 <chrisdotcode> kadoban: thanks 
15:18:19 <Gurkenglas> (All monads are applicatives nowadays.)
15:18:49 <jakeehrlich> Fantastic!! thanks guys!
15:19:26 <jakeehrlich> didnt know about RebindableSyntax. near perfect solution
15:25:13 <funnyman2213> Hello?
15:26:18 <Gurkenglas> Don't say things where you couldn't tell apart our answers from Cleverbot's.
15:26:27 * hackagebot idris 0.10 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.10 (EdwinBrady)
15:27:00 <exio4> Gurkenglas: Cleverbot is a freaking troll, so it should be easy
15:31:47 <jle`> chrisdotcode: it's a "law" that if (>>) and (*>) both exist for the type, they should be the same
15:31:54 <jle`> by "law" i mean law
15:31:57 <jle`> heh
15:32:39 <jle`> and you can always substitute (>>) for (*>)
15:33:13 <chrisdotcode> jle`: was curious cause I got a type error - and wanted to double check my theory
15:33:16 <chrisdotcode> of course, I was right :)
15:33:36 <jle`> :)
15:33:49 <jle`> but yeah, you can't always substitute (>>) with (*>)
15:33:55 <Lokathor> tfw you might need to use MVar because STM doesn't gurantee fairness of access :/
15:34:07 <AbelianGrape> OK, so my goal is to make some software that inspects Haskell source code and figures out the type of expressions (or holes) in the source files. What is the best way to interface with GHC to acheive this?
15:34:38 <Lokathor> AbelianGrape, i think ghc-mod is designed for this sort of thing
15:35:12 <AbelianGrape> Lokathor: Looks good
15:35:56 <Gurkenglas> AbelianGrape, I had some fairly few-lined success with Language.Haskell.Interpreter https://www.google.de/webhp?sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8#q=site:lpaste.net+Gurkenglas+buildUpUniverse
15:37:12 <AbelianGrape> Gurkenglas: I don't need to actually run the code, just statically analyze the type of terms within it
15:40:48 <sleblanc> The listing mentions "mzero" while the actual page says "empty" https://www.haskell.org/hoogle/?hoogle=guard  https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html#v:guard
15:41:32 <Gurkenglas> Because the hoogle database is old. Consider hayoo
15:43:38 <OverCoder> lol
15:43:38 <OverCoder> guys
15:43:46 <OverCoder> Try and type in the interpreter 't'
15:43:51 <OverCoder> I've got this: http://uploadpie.com/CK4du
15:45:40 <Ygg> I'm going to install NixOs
15:46:06 <Ygg> does xfce work well with it ? Not really fond of KDE
15:47:30 <Ygg> nvm, there's a nixos channel. Should have looked it up before
15:54:22 <geekosaur> fwiw not seeing that in 7.10.3 ubuntu
15:54:30 <geekosaur> what modules did you have loaded?
15:54:57 <OverCoder> Hm, okay I think I have misunderstood something with the interpreter? ._.
15:55:27 <OverCoder> I mean, nobody even mentioned me about the image, I think that's interpreter's normal behavior when we query a non-existing variable?
15:56:28 <geekosaur> a ghc panic would not be normal
15:56:30 <seachange> Can anyone provider suggestions on a conduit problem?
15:56:36 <geekosaur> <interactive>:4:1: Not in scope: `t'
15:56:41 <EvanR> > t
15:56:43 <lambdabot>  t
15:56:43 <geekosaur> is what I would expect
15:56:47 <pavonia> If that'd be the normal behaviour for a non-existing variable, what would even happen on a type error?
15:56:57 <geekosaur> t is in scope in lambdabot because of simple-reflect
15:57:00 <geekosaur> :t t
15:57:01 <EvanR> pavonia: blue screen
15:57:02 <lambdabot> Expr
15:57:57 <Axman6> OverCoder: no it's not the normal behaviour, but you gave absolutely no background of what lead up to that happening that meant no one could help you
15:59:24 <sleblanc> Ygg, fwiw, you can also have nix (the package manager) without running NixOS
16:02:29 <OverCoder> Ooh um
16:02:38 <OverCoder> Well, nothing, there's really no background
16:02:53 <Axman6> is the error reproducable?
16:02:59 <ReinH> OverCoder: uh, I get "<interactive>:2:1: Not in scope: t" as expected. What did you do?
16:03:02 <OverCoder> I only had my own quicksort function included through an extra file, I had Data.List imported... and nothing
16:03:19 <OverCoder> I couldn't reproduce it actually
16:03:28 <OverCoder> But I wonder why it even happened in the first place
16:03:30 <Hijiri> osa1: ping
16:04:04 <ReinH> You can use :show bindings to show any bindings in scope
16:04:07 <Axman6> well if it's not reproducable then we'll never know. I blame windows
16:04:08 <OverCoder> And that's the exact code that has been included http://p.samuraimanpurse.com/Bxw0ZdTK.txt
16:04:17 <geekosaur> probably too late now
16:04:17 <OverCoder> Axman6++
16:04:18 <sleblanc> I remember having "watch cabal build" in a terminal, catching a glimpse of a one-time occurrence of an error message. I did not have time to see the message itself though
16:04:20 <OverCoder> I'd blame windows too
16:05:12 * OverCoder tries again to reproduce it
16:05:13 <geekosaur> hmm
16:05:29 * geekosaur tries to remember if something about that came up with the runtime on windows
16:21:39 * hackagebot bank-holiday-usa 0.1.1 - A library for determining US bank holidays  https://hackage.haskell.org/package/bank-holiday-usa-0.1.1 (tippenein)
16:31:39 * hackagebot bindings-lxc 0.2.1 - Direct Haskell bindings to LXC (Linux containers) C API.  https://hackage.haskell.org/package/bindings-lxc-0.2.1 (NickolayKudasov)
16:53:21 <Serka> CANAL DE YOUTUBE EN EXPANSION CON TUTORIAL DE COMO GANAR DINERO GRATIS CON APLICACION DE GOOGLE PLAY PUEDES COBRAR EL DINERO CON STEAM ,GOOGLE PLAY,PAYPAL,PLAY STORE,ETC (NO ES PARA HACERSE RICO PERO 10$ EN DOS SEMANAS LOS GANAS) NO TE OLVIDES DE SUSCRIBIRTE AL CANAL UN SALUDO A TODOS/AS(CUALQUIER DUDA ESCRIMIRME A MI CANAL (Http://sh.st/nBwwh)
16:56:55 * hackagebot lxc 0.3.2 - High level Haskell bindings to LXC (Linux containers).  https://hackage.haskell.org/package/lxc-0.3.2 (NickolayKudasov)
16:57:05 --- mode: ChanServ set +o johnw
16:57:05 --- kick: Serka was kicked by johnw (Kicked)
16:57:05 --- mode: johnw set -o johnw
17:12:05 * hackagebot concurrent-machines 0.2.0 - Concurrent networked stream transducers  https://hackage.haskell.org/package/concurrent-machines-0.2.0 (AnthonyCowley)
17:14:16 <dalastboss> is there a function I can use to split a list at the first instance of "."
17:14:27 <dalastboss> neither partition nor splitAt does the trick
17:17:30 <lyxia> dalastboss: break
17:17:45 <dalastboss> perfect
17:17:47 <dalastboss> thank you
17:22:25 <lyxia> You're welcome.
17:24:29 <sleblanc> :t break
17:24:30 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
17:26:45 <sleblanc> dalastboss, just curious, is it for file extensions?
17:27:12 <dalastboss> yes; is there a more robust way you have in mind?
17:27:34 <sleblanc> in System.FilePath there's splitExtension/splitExtensions
17:27:42 <sleblanc> > splitExtensions "db.tar.gz"
17:27:43 <lambdabot>  Not in scope: splitExtensions
17:27:49 <dalastboss> Ah! Nice
17:27:58 <sleblanc> > System.FilePath.splitExtensions "db.tar.gz"
17:28:00 <lambdabot>  Not in scope: System.FilePath.splitExtensions
17:28:17 <sleblanc> lambdabot, how do you work?
17:28:30 <dalastboss> just hoogled, its in System.Filepath.Posix
17:29:30 <sleblanc> dalastboss, Posix implements it, but to remain system-independent, use System.FilePath
17:29:36 <sleblanc> > System.FilePath.Posix.splitExtensions "db.tar.gz"
17:29:38 <lambdabot>      Not in scope: System.FilePath.Posix.splitExtensions
17:29:45 <sleblanc> > import System.FilePath
17:29:46 <lambdabot>  <hint>:1:1: parse error on input import
17:31:11 <geekosaur> @let import System.FilePath
17:31:13 <lambdabot>  Defined.
17:31:51 <sleblanc> ooooo
17:31:56 <sleblanc> > splitExtensions "db.tar.gz"
17:31:58 <lambdabot>  ("db",".tar.gz")
17:32:03 <sleblanc> > splitExtension "db.tar.gz"
17:32:05 <lambdabot>  ("db.tar",".gz")
17:34:26 <stevejb> When using Control.Aeson.Lens, can I extract multiple keys in one line? Perhaps as a tuple.
17:34:28 <stevejb> ?
17:52:25 <osa1> Hijiri: hi
18:02:06 * hackagebot quickcheck-instances 0.3.12 - Common quickcheck instances  https://hackage.haskell.org/package/quickcheck-instances-0.3.12 (AntoineLatter)
18:10:28 <koz_> Is there a more concise way to write this? http://paste.rel4tion.org/222
18:12:15 <stevejb> I am trying to use wreq to make a post request. One endpoint I am posting to requires a JSON value which is an array of strings called "uris",
18:12:31 <stevejb> if I do this:  let x = pairs ("uris" .= ["abc", "def", "ghi"])
18:12:41 <stevejb> it creates the JSON that I want, but it is not Postable
18:32:12 * hackagebot wai-middleware-content-type 0.2.1 - Route to different middlewares based on the incoming Accept header.  https://hackage.haskell.org/package/wai-middleware-content-type-0.2.1 (athanclark)
18:36:43 <JamesJRH> Hi.
18:36:46 <JamesJRH> liste: Hi, are you around?
19:19:10 <JamesJRH> Any suggestions on how this can be simplified?:
19:19:12 <JamesJRH> > let divDecStr p n d = if mod n d == 0 then show $ div n d else (\s -> if mod (10^(p - 1)*n) d == 0 then reverse $ dropWhile (=='0') $ reverse $ s else s) $ Text.Printf.printf (concat ["%.",show p,"f"]) $ (fromIntegral n)/(fromIntegral d) in map (uncurry $ divDecStr 3) [(50,100),(4,3),(5000,3000),(1110,1000),(11101,10000),(0,1)]
19:19:14 <lambdabot>  ["0.5","1.333","1.667","1.11","1.110","0"]
19:20:54 <JamesJRH> divDecStr is a function that takes a precision, p, the number of decimal places and does a divide and returns a string such that exact divide omit trailing zeros where possible.
19:21:12 <JamesJRH> I.e. where shorter than the precision.
19:21:48 <JamesJRH> s/omit/omits/
19:22:31 <JamesJRH> Um, I mean: s/divide omit/divides omit/
19:30:58 <seliopou> Hey anybody know where I can find a source distribution of Hugs 1.4?
19:31:16 <JamesJRH> @let divDecStr p n d = if mod n d == 0 then show $ div n d else (\s -> if mod (10^(p - 1)*n) d == 0 then reverse $ dropWhile (=='0') $ reverse $ s else s) $ Text.Printf.printf (concat ["%.",show p,"f"]) $ (fromIntegral n)/(fromIntegral d)
19:31:18 <lambdabot>  .L.hs:167:9:
19:31:18 <lambdabot>      Could not deduce (PrintfArg r0) arising from a use of printf
19:31:18 <lambdabot>      from the context (Integral a, Integral a1, Show a, Show a1)
19:32:58 <JamesJRH> @let divDecStr p n d = if mod n d == 0 then show $ div n d else (\s -> if mod (10^(p - 1)*n) d == 0 then reverse $ dropWhile (=='0') $ reverse $ s else s) $ Text.Printf.printf (concat ["%.",show p,"f"]) $ (fromIntegral n)/(fromIntegral d) :: Integer -> Integer -> Integer -> String
19:33:00 <lambdabot>  .L.hs:163:7:
19:33:00 <lambdabot>      Couldn't match expected type Integer
19:33:00 <lambdabot>                                    -> Integer -> Integer -> String
19:33:53 <JamesJRH> @let divDecStr p n d = (if mod n d == 0 then show $ div n d else (\s -> if mod (10^(p - 1)*n) d == 0 then reverse $ dropWhile (=='0') $ reverse $ s else s) $ Text.Printf.printf (concat ["%.",show p,"f"]) $ (fromIntegral n)/(fromIntegral d)) :: Integer -> Integer -> Integer -> String
19:33:54 <lambdabot>  .L.hs:162:27:
19:33:54 <lambdabot>      Couldn't match type [Char]
19:33:54 <lambdabot>                     with Integer -> Integer -> Integer -> String
19:34:32 <JamesJRH> @let divDecStr (\p n d -> if mod n d == 0 then show $ div n d else (\s -> if mod (10^(p - 1)*n) d == 0 then reverse $ dropWhile (=='0') $ reverse $ s else s) $ Text.Printf.printf (concat ["%.",show p,"f"]) $ (fromIntegral n)/(fromIntegral d)) :: Integer -> Integer -> Integer -> String
19:34:32 <lambdabot>  Parse failed: Left-hand side of type signature is not a variable: divDecStr
19:34:32 <lambdabot>    (\ p n d ->
19:34:32 <lambdabot>       if mod n d == 0 then show $ div n d else
19:34:50 <JamesJRH> @let divDecStr = (\p n d -> if mod n d == 0 then show $ div n d else (\s -> if mod (10^(p - 1)*n) d == 0 then reverse $ dropWhile (=='0') $ reverse $ s else s) $ Text.Printf.printf (concat ["%.",show p,"f"]) $ (fromIntegral n)/(fromIntegral d)) :: Integer -> Integer -> Integer -> String
19:34:52 <lambdabot>  .L.hs:162:12:
19:34:52 <lambdabot>      No instance for (PrintfArg r0) arising from a use of printf
19:34:52 <lambdabot>      The type variable r0 is ambiguous
19:35:00 <JamesJRH> Oh c'mon.
19:36:27 <JamesJRH> > let divDecStr p n d = if mod n d == 0 then show $ div n d else (\s -> if mod (10^(p - 1)*n) d == 0 then reverse $ dropWhile (=='0') $ reverse $ s else s) $ Text.Printf.printf (concat ["%.",show p,"f"]) $ (fromIntegral n)/(fromIntegral d) in map (uncurry $ divDecStr 3) [(50,100),(4,3),(5000,3000),(1110,1000),(11101,10000),(0,1)]
19:37:00 <thimoteus> you know, you can PM lambdabot for a private session
19:38:06 <JamesJRH> lambdabot? That worked before.
19:38:09 <geekosaur> oh, right, I see why the type error. one of those fromIntegral-s needs to specify its result type
19:38:09 <JamesJRH> Why does that let work but not on its own?
19:38:34 <JamesJRH> Oh.
19:39:27 <JamesJRH> (concat ["%.",show p,"f"]) $ (fromIntegral n)/(fromIntegral d) in map (uncurry $ divDecStr 3) [(50,100),(4,3),(5000,3000),(1110,1000),(11101,10000),(0,1)]
19:39:38 <JamesJRH> Oops
19:39:48 <JamesJRH> Copy/paste error.
19:40:01 <JamesJRH> In PM'ing lambdabot.
19:41:08 <JamesJRH> lambdabot seems to have died, anyway.
19:41:13 <JamesJRH> > 1 + 1
19:41:20 <geekosaur> defaulting doesn't work with non-builtin typeclasses (notably PrintfArg)
19:41:39 <geekosaur> @ping
19:41:39 <lambdabot> pong
19:41:47 <geekosaur> just @run seems to be broken, I couldn't say why
19:42:05 <geekosaur> ping int-e
19:43:21 <geekosaur> (I should say non-Prelude typeclasses)
19:43:37 <lambda-11235> > 2+2
19:43:39 <lambdabot>  4
19:44:05 <JamesJRH> 03:40:57 < geekosaur> defaulting doesn't work with non-builtin typeclasses (notably PrintfArg)   The let statement worked when it was used on the same line with > , though. Just not for @let.
19:44:22 <JamesJRH> Oh, lambdabot's back?
19:45:20 <JamesJRH> Still no PM. :-/
19:46:32 <JamesJRH> > 1 + 1
19:47:45 <JamesJRH> > 2+2
19:48:23 <JamesJRH> lambda-11235: Why'd it work for you and not me?
19:49:21 <lambda-11235> I don't know. Does it work for anyone else?
19:49:58 <lambda-11235> I PM'ed the lambdabot, could that be it?
19:50:44 <kadoban> lambda-11235: lambdabot works the same in PM as it does here. It seems to be having problems at the moment though, might want to wait a few.
19:52:26 * hackagebot polynom 0.1.0.0 - Polynomial types and operations  https://hackage.haskell.org/package/polynom-0.1.0.0 (MatthewFarkasDyck)
19:56:08 <anohigisavay> type ProjectionRestriction (u (UniqueMarker v)) (RestrictionHolder v' c) = (~) * v v'
19:56:15 <anohigisavay> what does this * mean?
19:58:12 <shachaf> anohigisavay: It's a kind argument, since (~) is kind-polymorphic.
19:59:52 <anohigisavay> i tried type X a  = (~) * a and it says * is not in scope
20:00:01 <anohigisavay> in ghci
20:00:05 <shachaf> Just use (~) a
20:00:21 <shachaf> The * is inferred.
20:01:02 <crossroads1112> What are the syntactic rules for declaring a datatype like so data List a = Nil | a :> List a
20:01:19 <crossroads1112> Is there a place I can read up more on this?
20:01:19 <anohigisavay> shachaf: thanks :)
20:01:30 <shachaf> crossroads1112: You can read the Haskell report.
20:01:32 <shachaf> @where report
20:01:32 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
20:01:41 <crossroads1112> Thanks!
20:01:47 <Axman6> crossroads1112: infix constructors must start with :, that's about it
20:02:36 <geekosaur> well, in general constructor names have to start with uppercase, it's hard to type an uppercase symbol so a : prefix is used (with the built-in (:) being the "prototype" for that choice)
20:02:55 <crossroads1112> Axman6: Ahh, thank you very much
20:03:15 <geekosaur> archetype, I guess, not prototype
20:04:09 <nitrix> How do you break up an exceedingly large and complex function? It's already devided into a bunch of where clauses but, those are like 4-5 level deeps now.
20:04:49 <nitrix> I don't want to pull out everything out at the top level in the module since it isn't re-used anywhere, but I that same time, I feel this cannot stay the way it is.
20:06:23 <threepin> I'm trying to render a svg to png using rasterific but the fonts are not rendered but the shapes are. Here is the relevant code: http://lpaste.net/150370
20:06:31 <threepin> Has anyone run into this issue before?
20:06:38 <zomg> nitrix: I don't think there's anything wrong with having single-use top level funcs if it improves code clarity. Just don't export 'em :)
20:08:44 <zomg> threepin: I don't have experience with that particular library, but font-related problems usually often relate to either missing font files or character encoding problems, so if you've not checked those cases they might be worth looking into
20:11:02 <koz_> Is there a more concise way to write this? http://paste.rel4tion.org/222
20:11:03 <threepin> zomg, I checked that the specified font is loaded into the font cache. I'm not sure how I can check for the character encoding
20:15:40 <glguy> composeOrderings f g x y = f x y <> g x y
20:19:25 <conal> glguy:  equivalently, composeOrderings = (<>), as Tikhon Jelvis pointed out
20:19:45 <conal> glguy: sorry if i missed context
20:20:22 <koz_> glguy and conal: Where is the <> operator defined?
20:20:36 <conal> koz_: it's mappend from Monoid
20:20:56 <koz_> conal: That works? Woah.
20:21:00 <koz_> That's pretty cool.
20:21:16 <conal> https://www.quora.com/Why-do-computer-scientists-like-Haskell-so-much/answer/Tikhon-Jelvis
20:21:40 <conal> yeah. Monoid + function + Ordering rocks!
20:22:14 <conal> the Ordering monoid is the essence of lexicographic ordering.
20:22:28 <koz_> I guess I should read my instances more carefully next time.
20:22:33 <conal> yeah!
20:22:59 <conal> i've gotten a lot of mileage out of knowing instances of common classes for common type constructions
20:23:07 <conal> it can make a lot of code vanish.
20:23:19 <koz_> I'm sure it can - I just don't know enough of it yet.
20:23:19 <conal> and it's what led me to discover type class morphisms
20:23:19 <KaiJia> > 5 + 2
20:23:20 <lambdabot>  7
20:23:24 <koz_> I'm still fairly new to Haskell, y'see.
20:23:30 <conal> for denotational design
20:23:42 <conal> koz_: cool. having fun?
20:24:14 <koz_> conal: I *love* Haskell.
20:24:26 <koz_> I come from a background in logic and algorithms, and I absolutely *adore* it.
20:24:34 <koz_> (I'm doing a PhD in machine learning right now)
20:24:56 <conal> koz_: awesome.
20:25:09 <koz_> conal: Your name rings a bell. Are you famous for something in Haskell-land?
20:26:53 <kadoban> No, he's famous for a *bunch* of things.
20:27:12 <conal> koz_: i invented functional reactive programming in the early 90s, pioneered compiling deeply embedded DSLs. and have done a bunch of work in graphics. and i discovered & promote denotational design. http://conal.net
20:27:29 <conal> koz_: maybe one of those things
20:27:40 <koz_> conal: Ah, yes, FRP, that was it. First-off - you invented an amazing thing. Secondly - I'm apparently too stupid to understand it...
20:27:44 <conal> koz_: now i'm working on compiling haskell programs to massively parallel hardware.
20:27:56 <koz_> conal: Your work in this may actually interest me.
20:28:07 <koz_> Since it relates to my (proposed) PhD topic quite neatly.
20:28:35 <conal> koz_: on FRP, check out https://github.com/conal/essence-and-origins-of-frp and http://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language#5878525 and follow links. and feel free to ask questions.
20:28:47 <koz_> conal: I might just do that, thank you!
20:29:24 <conal> koz_: FRP is an incredibly simple idea. a lot of extraneous operational cruft often gets added to it or confused with it.
20:29:50 <koz_> conal: I'm sure that's the case - I suspect I just need to adjust my thinking a bit or find a presentation of it that makes sense to me.
20:30:17 <conal> koz_: sure. besides those two pointers, there's also http://conal.net/fran/tutorial.htm
20:30:23 <wedens> how to read `char*` using in Storable instance? it's not a \0 terminated string, just array of chars
20:30:29 <koz_> I'm also diving into these things kinda face-first - I picked up Haskell about a month ago, and I've been trying to get my head around *all the Haskellisms*.
20:31:09 <conal> koz_: if you haven't read the Typeclassopedia, be sure to add it to your list.
20:31:40 <koz_> conal: I have, several times. It helped me get the hang of monads.
20:32:08 <conal> koz_: good! there's so much misguided magical thinking about Monad. people almost always ask the wrong questions.
20:32:31 <conal> and "The answers you get depend upon the questions you ask." - Thomas Kuhn
20:33:03 <c_wraith> Well, it'd be sad if I only ever answered "7", regardless of the question.
20:33:20 <conal> const 7
20:33:20 <koz_> But yeah, my research basically is going to relate to distributed supervised learning. And I'm *definitely* going to use Haskell as my proof-of-concept implementation language.
20:34:02 <conal> koz_: good luck. and welcome to the haskell community.
20:34:17 <koz_> conal: Thank you - I feel I will need it.
20:35:17 <dfeuer> Shalom, conal.
20:35:31 <conal> dfeuer: peace
20:35:48 <conal> dfeuer: and thanks. :)
20:36:41 <verement> wedens: peekCStringLen?
20:39:35 <dfeuer> People in general: Some casual testing in GHCi suggests that for [],  it may be better to have  u <*> (v <*> w)  than to have an equivalent  u' <*> v' <*> w'. Is this a real thing, or just an artifact of my particular test or GHCi weirdness?
20:39:40 <dfeuer> er....
20:40:34 <dfeuer> Maybe that's a bad way to put it. An example:
20:40:35 <dfeuer> foldl' (\a b -> a + b) 0 $ (+) <$> ((+) <$> [(1::Int)..48] <*> [1..49]) <*> ((+) <$> [1..50] <*> [1..100])
20:40:42 <dfeuer> vs
20:41:04 <dfeuer> foldl' (+) 0 $ (\a b c d -> a+b+c+d) <$> [(1::Int)..48] <*> [1..49] <*> [1..50] <*> [1..100]
20:41:22 <wedens> verement: yeah, thanks. I was using it wrong. how to do the opposite? poke CStringLen 
20:41:28 <dfeuer> The first one (in GHCi 7.8) runs almost three times as fast as the second.
20:41:52 <dfeuer> This annoys me deeply.
20:42:18 <verement> wedens: withCStringLen
20:42:50 <wedens> verement: yeah, it gives me CStringLen. but how to write this CStringLen?
20:43:04 <wedens> verement: what should be second argument to withCStringLen
20:43:29 <verement> wedens: it's already written; you get back a pointer and length to use in your IO action
20:44:08 <dfeuer> Anyone? I tried figuring out all the mess with concatMap and such, but .... ugh.
20:44:39 <nolrai2> so is there a up to date VM image for messing around in haskell?
20:45:40 <wedens> verement: sorry, I don't understand. I have a pointer and length, what IO action should I perform to write it?
20:45:48 <kadoban> nolrai2: Not that I know of, but if you just install 'stack' it's pretty easy to get going. It can install ghc and whatever else for you pretty transparently, and in a way that's easy to nuke if you don't want it later.
20:46:08 <nolrai2> Okay, that makes sense actually.
20:46:46 <verement> wedens: the characters of the string have already been written to the memory pointed to by the pointer you receive when the IO action you return runs
20:47:36 <verement> wedens: if you need to write the characters somewhere else, you could copyBytes
20:48:52 <nineonine> hello
20:48:53 <nineonine> i have a type synonym of (a, b)
20:48:54 <exio4> dfeuer: woah, that's a big difference
20:49:02 <nineonine> but i want to have Eq this instance
20:49:07 <nineonine> (a1, b1) == (a2, b2) = a1 == a2
20:49:24 <geekosaur> nineonine, a synony is exactly that, you cannot give it different instances
20:49:34 <geekosaur> newtype lets you make different instances
20:49:42 <nineonine> but if i want to store it in a primitive vector ?
20:49:59 <dfeuer> exio4, I'm imagining this has to do with the Applicative instance for [], but it's annoying because it means this sort of reassociation could be either good or bad depending on the chosen functor.
20:50:13 <verement> wedens: e.g. withCStringLen str (\(ptr, len) -> copyBytes dest ptr len)
20:50:16 <dfeuer> Not so nice for functions polymorphic over Applicatives!
20:50:53 <geekosaur> you derive an appropriate instance through the newtype?
20:51:14 <wedens> verement: ok. thanks
20:51:30 <geekosaur> except i doesn't look to me like (,) has a Prim instance eiter
20:51:44 <Axman6> nineonine: newtype MyType a b = MyT (a,b); instance WhateverYouNeedForWritingToPrimVec (MyType a b) where writeFoo vec (MyT x) = writeFoo vec x
20:52:02 <Axman6> or derive the instance, as gamegoblin said
20:52:19 <gamegoblin> Axman6: what?
20:52:29 <geekosaur> nick complete error, they meant me
20:52:45 <nineonine> ok thanks
20:52:57 <geekosaur> but you joined at just the right time to confuse their client :p
20:53:06 <Axman6> bleh, hate it when that happens
20:53:20 <gamegoblin> heh
20:53:56 <wedens> verement: hm. no I can't use it. pointer types are different. http://lpaste.net/5679813821955309568
20:54:08 <exio4> dfeuer: funnily enough, the code wouldn't mind reducing some indirections
20:54:17 <exio4> dfeuer: (looking at the core generated by GHC7.8)
20:54:32 <dfeuer> exio4, explain? I don't understand that statement.
20:55:33 <exio4> dfeuer: it's just that there are some weird calls in the GHC core, which could be avoided (or at least, looks like so)
20:55:40 <dfeuer> Huh.
20:55:55 <geekosaur> wedens, castPtr is often useful there. but hard to tell as the C type isn't visible there
20:56:48 <dfeuer> exio4, I'll have to look into that later.
20:57:11 <JamesJRH> > 1 + 1
20:59:14 <dfeuer> exio4, I'm specifically considering the applicativeTree function used to implement Data.Sequence.replicateA. It uses some "extra" fmaps to group things nicely. I'm thinking now that those might actually improve performance for some functors, including [].
20:59:49 <dfeuer> It's way too big to say INLINABLE and hope to specialize...
21:00:06 <dfeuer> [or so I imagine]
21:00:43 <verement> wedens: probably something like: copyBytes (#ptr ActivationRequest, machineId) ptr' len
21:00:57 <exio4> dfeuer: if I understand the Core correctly, the first version does some magic inlines, which lead to less intermediate work done, (basically, (+) <$> [a..b] gets converted into (well, [\x -> a+x, \x -> a+1+x, ..] or so)
21:01:03 <wz1000> Hi! I'm using the libstatgrab bindings for haskell. I'm occasionally and erratically getting a segfault. Can somebody help me figure out whether this is an issue with the bindings or an upstream issue?
21:01:44 <dfeuer> exio4, oh, I was doing it in GHCi, which shouldn't have any of that stuff....
21:03:11 <exio4> dfeuer: er, well, in GHCi I wouldn't really assume anything
21:03:18 <wedens> verement:     Couldn't match expected type Ptr a0 -> Ptr b0 with actual type Ptr CChar
21:03:20 <exio4> dfeuer: there are lots of things which rely on optimizations to work.
21:04:15 <dfeuer> exio4, fair. My point is that for my specific purpose, I don't think I can rely on the specializer to enable these sorts of optimizations.
21:04:18 <exio4> the example code runs fast enough I can't really see any noticeable difference on my desktop, though (<=1.5s runtime)
21:04:29 <verement> wedens: sorry, I missed an argument: copyBytes ((#ptr ActivationRequest, machineId) ptr) ptr' len
21:05:11 <exio4> dfeuer: alright, I can't really help with the polymorphic case :/
21:05:16 <dfeuer> :/
21:06:25 <exio4> dfeuer: either way, I wouldn't say anything until there are benchmarks which say "this is noticeable case for X,Y,Z types and the functions f,h,g :) 
21:06:34 <dfeuer> Fair.
21:07:03 <exio4> s/case // -- or something, really sleepy already :(
21:09:05 <wedens> verement: now it's ambiguous type...  No instance for (Storable a0) arising from a use of pokeByteOff; The type variable a0 is ambiguous
21:09:18 <Axman6> add a type
21:10:00 <verement> wedens: I'm not sure that related to what we've been discussing. What line does the error point to?
21:11:12 <verement> wedens: note I used #ptr, not #poke
21:12:48 <wedens> verement: I guess, I'll figure it. thanks for help
21:13:56 <verement> wedens: np
21:14:15 <tac_> join #haskell-blah
21:14:18 <tac_> ooops
21:17:06 <radens> So I'm writing an embedded dsl in haskell. We're supposed to have macros with C-style curly braces. How can I make an edsl with these sorts of macros?
21:18:20 <Axman6> do notation already lets you use do notation, if that's what you need
21:18:26 <monochrom> you have a problem of clashing because curly braces have a haskell meaning, too.
21:18:41 <Axman6> do { x <- foo; y <- bar; baz x y 7 }
21:20:43 <dmj> > do do 1
21:20:45 <lambdabot>  1
21:22:44 * hackagebot werewolf 0.1.0.0 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.1.0.0 (hjwylde)
21:22:46 * hackagebot werewolf 0.2.0.0 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.2.0.0 (hjwylde)
21:24:02 <radens> Yeah, that's what I was thinking. Rereading the assignment we may not need to implement the parser.
21:24:05 <monochrom> one day, we will run quantum wereworlf in a nondeterministic chat client, too
21:24:37 <Axman6> radens: if you need to output curly braces, then you could use something like: scoped :: MyDSL a -> MyDSL a, scoped $ do ...
21:25:30 <radens> hm, maybe
21:27:44 * hackagebot werewolf 0.2.0.1 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.2.0.1 (hjwylde)
21:29:19 <monochrom> scooby doo?
21:30:21 <monochrom> it seems to take 3 hangings to publish the perfect werewolf engine
21:32:55 * hackagebot werewolf 0.3.0.0 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.3.0.0 (hjwylde)
21:32:57 * hackagebot werewolf 0.3.0.1 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.3.0.1 (hjwylde)
21:32:59 * hackagebot werewolf 0.3.0.3 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.3.0.3 (hjwylde)
21:33:01 * hackagebot werewolf 0.3.1.0 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.3.1.0 (hjwylde)
21:33:02 <kadoban> Is there a Data.Text.Lazy.Text -> Data.Text.Text I'm missing somewhere? It's kind of hard to search for :-/
21:33:03 * hackagebot cblrepo 0.19.1 - Tool to maintain a database of CABAL packages and their dependencies  https://hackage.haskell.org/package/cblrepo-0.19.1 (MagnusTherning)
21:33:30 <kadoban> Oh, toStrict  of course.
21:35:27 <monochrom> yikes, it takes more hangings. now the werewolves are about to win.
21:37:56 * hackagebot werewolf 0.3.1.1 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.3.1.1 (hjwylde)
21:39:05 <nocturne777> In a typical Haskell web application, do people usually put their common types in a file like "Types.hs" ?
21:41:28 <monochrom> not always. sometimes yes, but only when: the thing is really too big, or to avoid circular dependency
21:42:58 <monochrom> just break things up or merge things according to your judgment of good organization
21:44:16 <monochrom> if your preferred organization contains circular dependency, you can still choose to stick to it (with a bit more work) or re-organize to avoid. see the GHC user's guide (it's already on your hard disk) for how to do circular dependency.
21:45:11 <nocturne777> ok
21:59:26 <mathu> i'm trying to pattern match in a lamdbda against an ADT. one of the data constructors takes an integer, others don't. is there a way to write, in one filter, "values with this data constructor and also value >50"?
21:59:58 <Rembane_> mathu: filter (\C i -> i > 50)
22:00:17 <Rembane_> mathu: But then it will fail runtime for all other constructors.
22:00:20 <mathu> Rembane_: i don't know that it'll always be a C, though. it could be a B, or an A
22:00:25 <mathu> Rembane_: exactly my problem
22:00:48 <mathu> i can do two filters, just wondering if i can mash em together into one somehow
22:01:09 <Rembane_> mathu: Then you need another function! Like this: f (C _) = True; f _ = False
22:01:29 <Rembane_> mathu: And then f2 (C i) = i > 50
22:01:40 <Rembane_> mathu: And then: filter (f2 . f)
22:02:10 <mathu> yeah, that's what i currently have. i was just hoping there was a conventional way to merge the two
22:02:15 <mathu> thank you!
22:02:38 <mathu> er, a different conventional way :v
22:03:34 <Rembane_> mathu: Well, you can make your ADT an instance of Functor with that constructor as the place where stuff happens, but I think that's more work than creating two functions.
22:03:41 <Rembane_> mathu: No worries, good luck! ^^
22:05:31 <Guest66230> anyone?
22:07:17 <Rembane_> mathu: And you could of course write f and f2 as one function.
22:07:33 <Rembane_> mathu: But then you cannot write it as a lambda.
22:08:16 * hackagebot streaming-utils 0.1.4.2 - http, attoparsec, pipes and conduit utilities for the streaming libraries  https://hackage.haskell.org/package/streaming-utils-0.1.4.2 (MichaelThompson)
22:08:31 <monochrom> I recommend turning on the LambdaCase extension, then write: (\case C i -> i > 50; _ -> False)
22:11:28 <Guest66230> "purely functional" is amazing 
22:11:56 <mathu> monochrom: hm, didn't know about that extension. sounds interesting, never actually used ghc extensions before
22:11:59 <mathu> monochrom: thanks for the top
22:12:02 <mathu> tip*
22:13:35 <mathu> also wow the compiler is smart, noticed an unmatched pattern in a fairly convoluted function on ADTs
22:48:17 * hackagebot these 0.6.2.1 - An either-or-both data type & a generalized 'zip with padding' typeclass  https://hackage.haskell.org/package/these-0.6.2.1 (phadej)
23:02:12 <anohigisavay> sorry. again, question on TH.
23:02:23 <anohigisavay> [d|instance Eq $(conT name)|] works fine
23:02:31 <anohigisavay> [d|data $(conT name)|] does not
23:02:40 <anohigisavay> why is that?
23:03:04 <nocturne777> with DataKinds extension, we can write "newtype UserId Text" instead of "newtype SessionId = SessionId Text". would it be a bad idea to use datakinds in this case just to save a few keystrokes ?
23:03:09 <anohigisavay> Malformed head of type or class declaration: $(conT name)
23:09:22 <koz_> For an arbitrary Enum x, what number is the first possible value of x mapped into with fromEnum - 1 or 0?
23:12:54 <anohigisavay> koz_: did some very simple test in GHCi: data X = A | B | C deriving Enum
23:13:02 <anohigisavay> fromEnum A returns 0
23:13:08 <koz_> anohigisavay: OK, thanks.
23:13:57 * hackagebot authenticate 1.3.3 - Authentication methods for Haskell web applications.  https://hackage.haskell.org/package/authenticate-1.3.3 (MichaelSnoyman)
23:16:09 <sleblanc> koz_, if the data derives a Bounded instance, you can get it with maxBound :: Enum x => x
23:16:24 <sleblanc> oops, "minBound
23:16:25 <sleblanc> "
23:17:16 <sleblanc> Does the data represented make sense in such a way? You should ask yourself if those data have some inherent order
23:17:38 <koz_> sleblanc: It does, don't worry.
23:18:31 <koz_> Is it possible to have ranges of numbers in case statements? I don't really wanna write something like 'case x of 1 -> ... 2 -> ...' etc.
23:18:46 <liste> koz_ you can use guards
23:19:06 <liste> foo x |x > 100 && x < 200 = 2 * x 
23:19:29 <koz_> liste: Thanks.
23:19:47 <sleblanc> > (100, 200) `inRange` 150
23:19:49 <lambdabot>  True
23:21:31 <anohigisavay> may i ask once again? how to dynamically define a data type? [d|data ...|] then what?
23:21:47 <movedx> Any ideas on this one, guys? http://lpaste.net/150373 (I'm following: http://www.seas.upenn.edu/%7Ecis194/spring13/lectures/01-intro.html)
23:23:26 <anohigisavay> movedx: you had a redundant = at line 5
23:23:39 <thimoteus> movedx: your guards have to be before the = sign
23:23:50 <movedx> Ah right, well spotted. Thanks chaps.
23:23:56 <hiptobecubic> pip pip
23:25:02 <movedx> :D
23:25:17 <liste> anohigisavay do "module Foo where myDataDecl = [d|data ...|]" in one file and "module Bar where import Foo <line break> $(myDataDecl)" in another module
23:25:40 <koz_> TFW you *actually need* a 27-member Enum...
23:26:55 <mniip> GHC has worse examples
23:27:30 <koz_> While I'm on the subject: is there a more concise way to define Show for for said Enum than this? http://paste.rel4tion.org/223
23:29:12 <anohigisavay> liste: my problem is i can't dynamically assign a name to the data declaration :[d|data $(conT name)|]
23:31:21 <liste> anohigisavay please paste your code and compiler error messages
23:31:32 <anohigisavay> liste: do i really need to mess around with the dataD function and all weird arguments?
23:31:36 <anohigisavay> liste: ok
23:33:04 <anohigisavay> http://lpaste.net/150374
23:37:59 <liste> anohigisavay there's a name in that position of a `data' declaration, not a type
23:38:12 <liste> so x name = [d|data $(name) = ...|] should be enough
23:46:18 <sLite> what the go-to test framework these days?
23:46:21 <sLite> tasty?
23:46:37 <movedx> http://lpaste.net/150375 -- is my solution the reason why using Guards are too complicated?
23:46:43 <movedx> No need for them in the first place?
23:47:43 <anohigisavay> liste: i don't think so. splice works on Q monads. conT converts a name to a Q Type
23:48:20 <movedx> I hope the newbie questions aren't wasting your time, by the way.
23:48:36 <frerich> movedx: Yes. To be more precise, it's not the guards per se which complicated things. You would have the same with 'if n `mod` 2 == 0 then True else False'.
23:48:58 <thimoteus> movedx: well, if your function returns a Boolean, you won't need to use a guard
23:49:11 <anohigisavay> movedx: or more consise: isEven n = n `mod` 2 == 0
23:49:13 <frerich> movedx: Beginner questions are perfectly fine in this channel!
23:49:27 <anohigisavay> oops sorry
23:49:33 <movedx> anohigisavay: That looks a lot like my code?
23:49:43 <anohigisavay> movedx: sorry i missed the second part xD
23:50:31 <movedx> frerich: So because the express returns a Bool, we can just return the result of that as the function's result? Makes sense. Cheers.
23:50:36 <movedx> anohigisavay: No problem!
23:51:04 <frerich> movedx: Right (this is not even specific to Haskell).
23:51:13 <JamesJRH> > 1 + 1
23:51:16 <liste> anohigisavay but you need a name, not a type
23:51:20 <movedx> frerich: Yeah :)
23:51:23 <JamesJRH> liste: Hi.
23:51:31 <liste> JamesJRH hi!
23:51:54 <liste> anohigisavay $(return name) then?
23:52:12 <liste> conT looks up a type based on a name
23:53:20 <JamesJRH> liste: From Saturday, does this actually work for you?: 09:20:03 < liste> JamesJRH in ghci:
23:53:23 <JamesJRH> 09:20:11 < liste> :set -XOverloadedStrings
23:53:25 <JamesJRH> 09:20:18 < liste> import Data.Bytestring.Base64
23:53:28 <JamesJRH> 09:20:26 < liste> encode "I want to do this in Haskell"
23:53:32 <anohigisavay> liste: that makes sense. but still no luck. i guess that's some restriction of splice
23:54:03 <anohigisavay> doc says a splice can occur in place of an expression/type/list of declaractions
23:54:04 <JamesJRH> liste: It took me ages to notice the typo lowercase S for some reason.
23:55:10 <liste> JamesJRH I re-typed it after running it in GHCi, sorry
23:55:23 <JamesJRH> For me, only import Data.ByteString.Base64 works. Was it renamed or is that actually a typo.
23:55:28 <JamesJRH> Ah.
23:55:29 <liste> it's a typo
23:55:30 <JamesJRH> Okay.
23:59:25 * hackagebot yesod-auth 1.4.12 - Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-1.4.12 (MichaelSnoyman)
23:59:27 * hackagebot werewolf 0.2.0.2 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.2.0.2 (hjwylde)
