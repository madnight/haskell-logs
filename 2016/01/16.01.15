00:00:46 <Heather> how to have optional depends for operating system in cabal?
00:01:36 <Heather> found! https://github.com/haskell/cabal/blob/master/Cabal/Cabal.cabal#L185-L187
00:07:39 * hackagebot sbv 5.11 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-5.11 (LeventErkok)
00:07:39 * hackagebot language-thrift 0.7.0.0 - Parser and pretty printer for the Thrift IDL format.  https://hackage.haskell.org/package/language-thrift-0.7.0.0 (abhinav)
01:02:07 <castlelore> #unity3d
01:02:38 <jle_> it might be because it's late at night, but does anyone know a data Foo f a = A a | FA (f a) ?
01:02:52 <jle_> i feel like i've seen this before but I can't plac eit
01:07:14 <supki> jle_: Control.Applicative.Lift from transformers, maybe?
01:07:35 <jle_> supki: that's it :O
01:07:39 <jle_> thanks :)
01:07:47 <jle_> have you used it, by any chance?
01:07:56 <jle_> just wondering what made you recall it, heh
01:08:45 <jle_> so now i'm using type Foo = Fix Lift
01:08:51 <jle_> i wonder if that is used anywhere else
01:09:08 <jle_> er, type Foo f = Fix (Lift f)
01:27:01 <johnw> jle_: is Fix (Lift f) = Free f?
01:29:51 <johnw> ah, no
01:34:15 <supki> jle_: no, I haven't; IIRC it came up in a discussion about moving Validation to base a while ago, and I use Validation a lot.
01:37:21 <gfixler> Are pattern functions always to do with recursion?
01:37:27 <gfixler> functors*
01:37:36 <johnw> what are pattern functors?
01:37:46 <gfixler> johnw: that's what I'm trying to figure out :)
01:37:59 <gfixler> brought up a few times in various LambdaConf videos
01:38:07 <gfixler> very limited info online
01:38:09 <gfixler> https://books.google.com/books?id=_8epCAAAQBAJ&pg=PA69&lpg=PA69&dq=%22pattern+functor%22&source=bl&ots=bszfBc0AVh&sig=wJzZdSasFrhAjBV-gZrsDmXX9bA&hl=en&sa=X&ved=0ahUKEwjXpZyIwKvKAhVC_mMKHTlZAl0Q6AEIOTAF#v=onepage&q=%22pattern%20functor%22&f=false
01:38:40 <dramforever> you mean something like recursion-schemes?
01:38:52 <gfixler> they seem intimately tied to them, yes
01:38:58 <gfixler> hence my question
01:39:29 <gfixler> Gershom talks about them in this talk (and recursion schemes are part of it): https://www.youtube.com/watch?v=JDqD6RZpnZA&index=54&list=PLE7tQUdRKcybh21_zOg8_y4f2oMKDHpUS
01:39:48 <dramforever> no much idea about them then...sorry
01:39:54 <johnw> ah, I guess pattern functors are what other papers call "term algebra"
01:40:15 <johnw> i.e., a data type functorial in its recursion
01:40:32 <gfixler> I see
01:41:53 <johnw> i guess pattern functor is as good a name as any, since it identify the pattern that will recur in any constructed values of the fixed-point of that functor
01:42:10 <johnw> gfixler: http://www.timphilipwilliams.com/posts/2013-01-16-fixing-gadts.html
01:42:18 <johnw> it's described clearly as such there
01:46:21 <nut_> hello all im pulling articles(100k articles of around 1k words per article) from the web and want to store them on a local database for queries later. could anyone suggest the database to choose and haskell interface?
01:47:22 <liste> nut_ any rdbms really. what kind of queries?
01:47:45 <nut_> search words from a vocabulary list
01:47:51 <Darwin226> Hey guys. A question. Is Set really a monad or not? I know it can't be made an instance due to the constraints, but let's say it could. Would it satisfy the laws?
01:47:59 <nut_> search words in those articles
01:48:07 <liste> nut_ some full-text search system
01:48:14 <liste> solr, lucene etc...
01:48:15 <nut_> exactly
01:48:36 <liste> postgresql has decent fulltext index functionality too
01:49:04 <liste> not sure about haskell bindings though
01:49:33 <johnw> Darwin226: http://www.randomhacks.net/2007/03/15/data-set-monad-haskell-macros/
01:49:50 <liste> nut_ elasticsearch has haskell bindings:  https://hackage.haskell.org/package/bloodhound
01:50:16 <nut_> liste, thx let me take a look
01:50:19 <liste> and postgresql has a ton of haskell bindings
01:50:55 <Darwin226> johnw: So my question isn't actually answered in the article.
01:52:22 <pavonia> Is there a clever way to check if in a list of lists, all lists have the same length?
01:52:22 <johnw> Darwin226: I guess we'd have to work out the laws to know
01:53:09 <johnw> pavonia: all ((== N) . length) xs?
01:54:00 <Darwin226> johnw: Specifically, I don't think fmap (f . g) == fmap f . fmap g holds
01:54:11 <pavonia> johnw: I don't know the length in advance
01:54:58 <pavonia> Also, I would like to no check very long list up to the end, if there are very short lists too
01:55:10 <johnw> true
01:55:37 <Darwin226> johnw: As far as I'm aware, there's nothing requiring me to define the Eq instance so that if a == b, no function can distinguish a from b
01:57:03 <johnw> Darwin226: does it help to know that mathematical sets are monads?
01:57:43 <Darwin226> johnw: Only a little bit :D
01:57:58 <johnw> I only know because I did the proofs earlier today :)
01:58:24 <johnw> the proofs did rely on the axiom of propositional extensionality
02:00:32 <gfixler> johnw: the unorderedness of sets doesn't matter to monads?
02:00:55 <johnw> no, Set (Set a) has a pretty obvious join operation
02:00:57 <danilo2> Hello guys! Do you know if we can configure stack in such way, that it displays info which file is currently being buid? Right now I've got just output "the library is building" and nothing more
02:03:03 <gfixler> johnw: I'm think of functors, which monads must be
02:03:30 <gfixler> fmap isn't structure-preserving if the values can collapse on each other, no?
02:03:51 <gfixler> fmap (*0) <some set of Ints>
02:03:57 <johnw> the only structure fmap has to preserve is its two laws
02:06:08 <gfixler> johnw: I'm confused now. https://www.schoolofhaskell.com/user/chad/snippets/random-code-snippets/set-is-not-a-functor
02:06:25 <gfixler> does that just mean the Haskell implementation isn't?
02:07:11 <progboy> What are some interesting and unique projects that I can do in Haskell?
02:07:12 <jle_> gfixler: one way you can think of it is that for any `forall a. f a -> b` that you run to your data, the result won't be changed if you fmap it first
02:07:44 <johnw> gfixler: I'm not sure about that article at all
02:08:21 <johnw> gfixler: he's saying you can write bad Eq/Ord instances that cause the functor laws to fail. Well, yeah, incorrect methods do cause laws to fail.
02:09:05 <jle_> gfixler: so for set, consider the function `length :: Set a -> Int`; fmapping something can change the result of the function
02:09:16 <jle_> s/set/Set
02:09:39 <johnw> jle_: can you show a code snippet, in the form of the 2nd functor law?
02:09:56 <jle_> a code snippet of what?
02:10:09 <johnw> length . fmap f . fmap g, should = length . fmap (f . g), even where sets are concerned
02:11:21 <jle_> i think you would need to think of length as a natural transformation :: f a -> Const Int a
02:11:34 <jle_> and then functors preserve natural transformations
02:12:23 <progboy> ???
02:12:24 <jle_> er, fmap preserves natural transformations
02:12:31 <johnw> well, I'm looking a proof that sets are functors, so...
02:13:11 <jle_> are we talking about the Set type or actual sets
02:13:23 <johnw> actual sets
02:13:40 <johnw> we already know Data.Set can't be a functor due to the missing constraint
02:13:49 <johnw> so are we talking about a mythical thing that doesn't exist?
02:14:34 <phaazon> hm, is there a way to declare new kinds with their values (types) without using ticks and DataKinds?
02:14:38 <phaazon> ticks are boring :(
02:14:56 <phaazon> a keyword kind would be nice
02:15:24 <gfixler> johnw: what missing constraint?
02:15:30 <johnw> Ord
02:15:34 <jle_> i guess the constraint already being there makes it a non-starter
02:15:46 <jle_> although i wonder if we could consider it a functor on a subset of hask
02:15:46 <gfixler> and I'm thinking that maybe the few times I've heard someone say that sets aren't functors, they meant Set
02:16:03 <johnw> for example, Typeclassopedia says sets are not functors because they require Ord
02:16:21 <gfixler> ah, Ord - that was part of what I heard (Haskell meetup, IIRC)
02:16:27 <johnw> there are other people who say sets can't be functors, for presumably other reasons, but I haven't been able to find any clear proof of those reasons
02:16:51 <gfixler> johnw: okay, then it's a bit more nebulous than I'd thought - I'll tread carefully
02:16:58 <Hafydd> What does it mean for "sets" to be functors? In what category does "set" map between morphisms?
02:17:21 <jle`> progboy: hm, maybe a compiler?
02:17:25 <jle`> or a parser
02:19:23 <progboy> jle: how??
02:19:37 <phaazon> hm, in an AST, I guess else if == else + if, right
02:20:13 <gfixler> progboy: https://wiki.haskell.org/Parsing_a_simple_imperative_language
02:20:52 <jle`> http://www.haskellforall.com/2015/12/how-to-contribute-to-haskell-ecosystem.html shows a way to build a simple parser
02:22:27 <MarcelineVQ> neato
02:23:39 <phaazon> hm, I guess this is good for if/else if/else :
02:23:57 <phaazon> data Cond f a = If (f Bool) (f a) (Maybe (Cond f a)) | Else (f a)
02:24:01 <johnw> gfixler: I'd call this a slightly more reliable source: http://babel.ls.fi.upm.es/~pablo/Papers/adt-functors.pdf
02:24:07 <johnw> in which it says "ordered sets are functors"
02:24:14 <phaazon> hm, no
02:24:24 <phaazon> I could put a Just (Else _)
02:24:27 <phaazon> which would have no sense
02:24:35 <phaazon> hm, actually
02:24:36 <phaazon> it does!
02:24:40 <phaazon> nevermind then :)
02:24:41 <gfixler> johnw: I think it was the ordered bit that made the difference
02:25:00 <johnw> you mean, the Ord constraint?
02:25:14 <gfixler> johnw: yes
02:25:22 <gfixler> johnw: I'm still not sure about unordered sets being functors
02:25:26 <johnw> you can build a restricted functor using the new associated types machinery
02:26:23 <gfixler> johnw: I'm still working on GADTs :)
02:27:06 <johnw> gfixler: another article: http://mmisamore.github.io/2015/04/28/SetFunctor/
02:27:21 <phaazon> hm thereâ€™s actually an issue
02:27:26 <phaazon> I can start with Else
02:27:27 <gfixler> johnw: nice first two sentences!
02:27:28 <johnw> that one is pointing out that Snoyman's example pertains to uses of fmap where the chosen 'f' does not preserve the meaning of equality
02:27:29 <phaazon> which has no sense
02:27:37 <gfixler> this article is for me
02:29:48 <johnw> I can see his point from this article: if Set is based on Eq, and you are allowed to fmap a function that does not respect equality (where equal terms go to unequal terms), then the functor laws break down
02:36:29 <phaazon> http://lpaste.net/3581313464217370624
02:36:32 <phaazon> now itâ€™s fixed :)
02:40:46 <johnw> gfixler: thanks for asking, that helped to clarify some things for me too
02:43:50 <gfixler> :)
02:48:10 <joash> hey! anyone know if it's possible to compose free monad interpreters?
02:50:00 <jle`> yea, i think there was that 'data types a la carte' that talked about different techniques
03:06:36 <jle`> it'd be nice to have a way to declare that a specific 'let' is non-recursive
03:06:54 <jle`> like in ocaml
03:12:39 * hackagebot lp-diagrams 1.0 - An EDSL for diagrams based based on linear constraints  https://hackage.haskell.org/package/lp-diagrams-1.0 (JeanPhilippeBernardy)
03:12:41 * hackagebot lp-diagrams-svg 1.0 - SVG Backend for lp-diagrams  https://hackage.haskell.org/package/lp-diagrams-svg-1.0 (JeanPhilippeBernardy)
03:34:09 <fractalsea> Can someone tell me if this benchmark of Map is correct? Iâ€™m worried about laziness meaning that because Iâ€™m testing alternating insert and deletes that the elements that were inserted and then deleted are never actually inserted if that makes any sense. http://lpaste.net/5724246886425034752
03:34:54 <Nadrieril> well, if that were the case, it seems like it would benefit performance
03:35:11 <fractalsea> If I put a `force` in the fold, then the performance becomes terrible, and for some reason there is no GC
03:35:58 <fractalsea> Nadrieril, hmm yeah I guess that is true. Thing is that in reality, there will be lookups being performed on it, interleaved
03:36:10 <fractalsea> Nadrieril, I guess I should add that to the benchmark
03:36:30 <Nadrieril> I would be interested to see the result
03:36:57 <Nadrieril> but I don't think it would happen like that
03:37:19 <wlad> Guys, any graphics or GUI packages you would recommend?
03:37:48 <Nadrieril> when you look for the element to remove, you would have to evaluate the shape of the tree at least in the path leading to the element, so it would force it to be correctly inserted
03:38:11 <Nadrieril> I admit I have a very impresice idea of the actual implementation of map
03:48:10 <Gurkenglas> wlad, for 2D "put a line here, a square there, and move it for every second passed since program starting", gloss
03:52:57 <wlad> Gurkenglas: thanks
03:54:00 <fractalsea> Nadrieril, thatâ€™s true. Thanks for your help
03:55:10 <Nadrieril> np :)
04:07:32 <Heather> Failed to load interface for `Data.Functor.Coproduct' ... where is it
04:08:12 <Heather> in comonad should be?
04:08:36 <jle`> looks like yeah it's in Comonad
04:10:21 <Heather> nvm, strange error was there
04:15:05 <Heather> jle` wait...
04:15:36 <Heather> jle` it disappeard
04:16:00 <Heather> jle` I can't find it
04:16:15 <Heather> I see https://github.com/ekmett/comonad/commit/f6070674f848034ca83699a78973062dac238b8b
04:19:58 <jle`> oh hey :o
04:33:32 <nomeata> Ah, werenâ€™t we talking about Elevence yesterday? According to http://www.infsec.ethz.ch/people/alumni.html Simon Meier is there. At least a name I recognize.
04:33:41 <nomeata> I wonder if he is on IRC :-)
04:37:41 * hackagebot fay 0.23.1.11 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  https://hackage.haskell.org/package/fay-0.23.1.11 (AdamBergmark)
04:50:50 <bollu> how do I use Store to "actually" memoise a structurE?
04:52:42 * hackagebot fay 0.23.1.12 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  https://hackage.haskell.org/package/fay-0.23.1.12 (AdamBergmark)
04:57:22 <quchen> nomeata: Maybe he's mauke and nobody ever made the connection :-D
04:57:51 <quchen> â€¦ similar things happened to me with this Breitner guy before
04:58:28 <nomeata> quchen: Yes, always fun when that happens.
04:58:35 <MarcelineVQ> Don't you see? You were mauke the whole time. mauke is within us all.
04:59:15 <nomeata> Although I belive mauke is Lukas Mai, so this is a false hint
05:15:12 <SX> Could you recommend some good RPC lib for python<->haskell comms?
05:36:54 <nut_> Hi im inside a new empty folder, i ran cabal sandbox init, then i run cabal init to create template files. after this am i still inside the sandbox?
05:49:25 <quchen> nut_: Yes.
05:49:48 <quchen> nut_: cabal init should be orthogonal to cabal sandbox.
06:00:57 <Black0range> are there any way that one can make "polymorphic" constats? such that for example "x = 5" on the global scope can be used as any kind of Number (Integral, Real etc) inside other functions?
06:01:48 <ibid> just give it a polymorphic type?
06:02:39 <mauke> x :: (Num a) => a
06:02:43 <nut_> quchen, thx
06:02:50 <dramforever> Black0range: what's stopping you?
06:03:02 <mauke> the dreaded monomorphism restriction
06:03:19 <Black0range> oh i thought ghc did that automaticly 
06:03:45 <dramforever> put {-# LANGUAGE NoMonomorphismRestriction #-} on top of your file
06:04:34 <dramforever> Black0range: you see, if it is polymorphic *and* takes a lot of time to compute, then making it polymorphic will make performance suck
06:04:46 <dramforever> because it just can't store the computed value
06:05:11 <dramforever> so here we got a restriction that turned out to trip people more than it helps =(
06:05:12 <Black0range> dramforever: But this shouldn't matter for constants? 
06:05:48 <Black0range> since they most probably should be inlined anyhow?
06:06:00 <dramforever> It should, say you have that x = something that takes 5s to compute
06:06:25 <dramforever> Black0range: ahh I see, but it seems weird to let that affect type checking
06:06:44 <Hafydd> Hence the controversy.
06:09:37 <Black0range> Simply adding x :: (Integral a) => a solved it as someone said :)
06:09:42 <mauke> Black0range: inlining makes no difference. that just means you'll have several places in your code that takes 5 seconds to compute
06:10:15 <Black0range> mauke: but since it's a constant value i thought ghc would calculate those at compile time?
06:10:16 <dramforever> mauke: I think Black0range meant that stuff like x = 42 could be dealt with specially
06:10:33 <dramforever> "specially" sounds really suspicious, you know
06:10:35 <Black0range> or even x = sum [1.....100]?
06:10:37 <mauke> Black0range: it's not constant
06:10:54 <mauke> Black0range: it has different values depending on the type
06:11:10 <Black0range> i know but i don't know what to call it :) 
06:11:27 <mauke> doesn't matter what you call it; the point is it's not a simple value
06:11:28 <Black0range> the type should be known at compile time? 
06:11:38 <mauke> not in general
06:11:54 <Black0range> why not?
06:12:04 <mauke> someone could say y = x
06:12:11 <mauke> with y also being polymorphic
06:13:11 <Black0range> yes but then using y in a function with a fixed type would give the compiler a hint of what the value is?
06:13:37 <Black0range> Of course this wouldn't work in an interpeted environment but in a fully compiled program?
06:13:44 <mauke> it's a potentially different type at each use ite
06:13:47 <mauke> *use site
06:14:23 <mauke> we have separate compilation, so the compiler doesn't see all code at once
06:14:23 <Black0range> but proper inlining should make that problem go away?
06:14:34 <mauke> no, inlining causes that problem
06:14:43 <mauke> sort of
06:15:30 <Black0range> well I take your word on it then :)
06:15:50 <mauke> if you have x = sum [1 .. 100] and a program that uses x several times, then inlining means 'sum [1 .. 100]' will appear several times in your code
06:16:55 <mauke> Black0range: ghc implements typeclasses as dictionaries
06:17:29 <Black0range> but all variables in "sum [1..100]" is known meaning that a compiler could compute the exact value for any given type?
06:17:31 <mauke> so an apparent constant like x :: (Num a) => a gets turned into something like x :: NumDict a -> a
06:17:42 <mauke> i.e. a function
06:17:54 <Black0range> oh... :(
06:18:13 <nut_> when i start a new cabal sandbox, it will reuse the package cache in my home .cabal folder so it avoids redownloading a lot of stuff
06:18:21 <nut_> but stack doesnt do this
06:18:24 <nut_> am i right ?
06:18:36 <dcoutts> nut_: yes, it uses the same downloaded package tarballs
06:18:38 <mauke> Black0range: theoretically it could, but that's at odds with laziness
06:19:04 <nut_> can i make stack do the same ?
06:19:09 <mauke> Black0range: so it'd have to prove that evaluating that code doesn't fail .. (I think?)
06:19:27 <nut_> my connectiont to stack server is really slow
06:19:36 <Black0range> mauke: i thought haskells types worked something along the lines like c++ templates 
06:19:44 <dcoutts> nut_: no idea I'm afraid
06:19:45 <nut_> i got connection failure in fact
06:20:05 <nut_> dcoutts, ok np
06:20:24 <dcoutts> nut_: fyi, currently each sandbox will rebuild the packages locally in that sandbox, though a future version will cache those too to make it quite cheap
06:20:50 <nut_> good to know
06:20:56 <mauke> Black0range: not really
06:21:11 <mauke> Black0range: haskell supports polymorphic recursion
06:21:57 <mauke> > let foo :: (Show a) => Int -> a -> String; foo 0 x = show x; foo n x = foo (n - 1) (x, x) in foo 2 42
06:21:59 <lambdabot>  "((42,42),(42,42))"
06:22:12 <mauke> can't do that with templates
06:23:04 <mauke> template<typename T> string foo(int n, T x) { if (n == 0) return show(x); return foo(n - 1, make_tuple(x, x)); }  // doesn't compile because infinite template recursion
06:23:18 <mauke> we're sort of generating types at runtime :-)
06:23:41 <mnoonan> mauke: well, you can do a type-level Int template.. :)
06:23:57 <mauke> the haskell version can read n from the user
06:24:06 <mnoonan> fair enough
06:24:28 <Black0range> thats pretty awesome and scary at the same time
06:25:28 <mauke> the haskell version just builds up class dictionaries as it goes
06:26:07 <mauke> using this rule: instance (Show a, Show b) => Show (a, b) where ...
06:29:28 <Black0range> mauke: where did you learn these things?
06:29:50 <c_wraith> Hmm.  I have a question about lazy pattern matches I'm not sure how to answer.  Or even ask.
06:30:14 <Black0range> just try to ask something :) 
06:30:27 <mauke> Black0range: lurking in this channel :-)
06:30:32 <c_wraith> If you have a lazy pattern match, it isn't actually performed until a value bound by it is forced.
06:31:18 <Black0range> true
06:31:19 <c_wraith> But when you have multiple names bound by the same lazy pattern match, like say...  let (a, b) = ... in ...
06:31:45 <c_wraith> Does forcing a also have the side effect of evaluating the lazy pattern match on b?
06:32:33 <Black0range> as far as i know, yes :)
06:32:40 <c_wraith> That seems like a detail that can't even be observed with Debug.Trace
06:32:58 <c_wraith> Maybe I could observe it with vacuumLazy.  If that still works on modern ghf
06:33:00 <c_wraith> err, ghc
06:33:43 <geekosaur> forcing a should not force b, since b itself is irrefutable
06:34:12 <Black0range> isn't touples allways treated as one object?
06:34:13 <c_wraith> geekosaur: Not force b.  Remove the pattern match overhead, since the pattern match has already been performed
06:34:16 <geekosaur> although if you are using b as a placeholder for a pattern including a constructor tag then that shold be forced
06:34:23 <ggole> My understanding is that let (a, b) = ... will force the computation to produce a pair, the contents of which are suspended until forced
06:35:02 <c_wraith> Ok, guys, I understand the semantics of lazy evaluation just fine.  My question is about GHC's operation model when binding multiple names in a lazy match.
06:36:04 <ggole> I don't understand what multiple names has to do with it.
06:36:11 <geekosaur> same
06:36:26 <geekosaur> (granted I am still waking up...)
06:36:37 <c_wraith> Like I said, I don't even know how to ask the question.
06:36:38 <c_wraith> :)
06:36:55 <Black0range> as far as i understand it if you're using any kind of touple etc it is always treated as one object meaning that the computation is done in one big swoop. 
06:37:30 <mauke> is this about let (a, b) = expensive_computation; evaluate a; evaluate b ?
06:37:33 <ggole> c_wraith: are you asking whether there is some relationship or dependency between a and b as a result of matching?
06:37:38 <c_wraith> Basically, I'm asking if let (a, b) = .. in ... a ... b  ever has different operation semantics from let ab = .. in ... fst ab ... snd ab
06:37:41 <ggole> (Ignoring any other sharing for now.)
06:37:43 <c_wraith> ... operational
06:38:13 <ggole> I believe so: let (a, b) = ... forces the computation to a pair right away
06:38:19 <c_wraith> ggole: no, it doesn't
06:38:26 <Black0range> are you asking if a will be evaluated if b is?
06:38:31 <c_wraith> ggole: let bindings are always lazy
06:38:51 <c_wraith> Black0range: No.  I know it won't be fully evaluated.  I understand the semantics.
06:40:28 <ggole> c_wraith: hmm, you're quite right
06:40:28 <geekosaur> I See what ggole was trying to say, the tuple itself is forced at a different time because fst itself introduces a thunk
06:40:42 <geekosaur> I am not sure this is relevant in practice
06:40:48 <ggole> Guess I need to stop thinking of let as sugar for case
06:40:52 <Cale> ggole: case ... of (a,b) -> ...  would force the evaluation of the pair, but let-bound things won't be evaluated unless used.
06:40:58 <nut_> can cabal warn any coding suggestions like hlint ?
06:41:03 <c_wraith> ggole: indeed.  let and case are not even close to the same. :)
06:41:16 <nut_> if so what is the parameter for maximum warning ?
06:41:18 <Cale> You can think of let as sugar for case, but you need to put ~'s on all the patterns
06:41:21 <nut_> cabal build
06:41:33 <Cale> (as well as introduce fix a bunch to deal with recursion)
06:41:42 <Cale> I don't particularly like that though
06:41:52 <geekosaur> nut_, caal does not have hlint built in, nor IIRC a way to hook it in.
06:41:55 <c_wraith> ggole: that's why things like putting a GADT constructor on the RHS of the = in a let results in GHC saying "my brain exploded"
06:42:25 <geekosaur> warnings: cabal build --ghc-options=-Wall
06:42:26 <ggole> c_wraith: well, with that your question begins to make a lot more sense :)
06:43:28 <c_wraith> Anyway, the motivation for my question is here:  https://www.reddit.com/r/haskell/comments/412n6n/new_blog_post_efficient_amortised_and_realtime/cyz6cgu
06:44:02 <c_wraith> And now that I've thought about it a bit more, I'm sure that edsko is correct, there is no sharing of the work
06:44:20 <c_wraith> Because if there was, it would add a lot of unnecessary overhead in some cases.
06:44:29 <edsko> whatwhatwhat?
06:44:49 <edsko> what did I miss?
06:44:57 <c_wraith> edsko: nothing.  You were correct! :)
06:45:09 <edsko> thank god for that! :) 
06:45:21 <danza> you notice that something is wrong when you start to write "hack", and your fingers go for "hask"... :(
06:45:23 * edsko thought very hard and very long about that whole runDelay thing
06:46:14 <c_wraith> But it makes me want a way to ask for a delayed pattern match that, when forced, does the work to remove itself from every name it bound.
06:46:25 <c_wraith> Not just the specific name being demanded.
06:46:34 <edsko> that's not going to happen I think
06:46:39 <edsko> nor would we want it to
06:46:40 <edsko> space leaks
06:46:51 <c_wraith> Well, it'd only be an optional feature.
06:47:07 <edsko> I think it's good if we leave control over sharing in the ahnds of the programmer
06:47:10 <c_wraith> Something you have to actively ask for.  I want this match to be... eagerly lazy?
06:47:18 <edsko> well you can do that
06:47:21 <c_wraith> Yes, I'm saying to leave it in the hands of the programmer
06:47:23 <edsko> just make sure you share the variable
06:47:28 <c_wraith> Just make a way to ask for it directly.
06:47:39 <c_wraith> Without having to go through unsafeInterleaveST
06:47:44 <nut_> geekosaur, so how do people check warnings ?im using sublime
06:47:57 <edsko> c_wraith : I am not yet convinced a definition of runDelay without unsafeInterleaveST is not possible
06:48:03 <edsko> in fact, I feel it ought to be ossible
06:48:05 <nshepperd> c_wraith: "foo xs = let (a, b) = xs in a `seq` b" gives different core than "let a = fst xs; b = snd xs in a `seq` b" under -O0
06:48:10 <edsko> I'm just not smart enough to think of one :)
06:48:25 <c_wraith> nshepperd: but only -O0?
06:48:33 <nshepperd> i'm not sure how to test this under more realistic conditions
06:48:51 <geekosaur> nut_, I told you how to turn on warnings. hlint is a different thing. and one reason it's not hooked in is that it's based on simplistic source analysis; it doesn;tknow types, and it can guess wrong as a result
06:48:53 <c_wraith> Oh, I suppose inlining probably defeats the test under higher levels
06:49:08 <nshepperd> yeah with optimisations they compile to exactly the same thing due inlining yeah
06:49:35 <c_wraith> nshepperd: well, you can look at the thread I linked above for a case where it actually matters.
06:51:07 <c_wraith> edsko: what about something terrible like a strict pair data type inside a lazy wrapper?  (At what point does execution overhead outweigh code craziness?)
06:51:35 <edsko> c_wraith : try it. I think any such attempt will leave a stack of O(n) calls to unwrap whatever you wrapped
06:52:05 <kubrat> dskj/qui
06:52:10 <c_wraith> edsko: hmm.  Yeah.  I think this is actually another instance of the IVar problem.
06:52:24 <geekosaur> kubrat, hope that wasn't a password
06:52:38 <oggy> does HSpec allow one to test console I/O? 
06:52:51 <geekosaur> nut_, [15 14:42] <geekosaur> warnings: cabal build --ghc-options=-Wall
06:52:55 <edsko> c_wraith : IVar? we're writing multiple times to this variable though.
06:55:02 <c_wraith> edsko: it would depend on the semantics of demanding the contents of the IVar - If it forces evaluation...  It becomes the exact same thing as the lazy ST solution.  Just with a different look.
06:56:00 <c_wraith> On the other hand, if reading from an IVar that hasn't been written does anything other than force evaluation...  The problem is entirely different.
06:56:16 <c_wraith> Yeah, this is a bit of a special case in that way.
06:56:25 <edsko> it's also crucial that we can evaluate only a little bit
06:56:41 <c_wraith> That part seems natural, though.
06:56:46 <edsko> with IVars?
06:56:47 <edsko> perhaps
06:56:53 <c_wraith> With Haskell in general. :)
06:56:56 <edsko> I've read the paper, haven't used them  in practice
06:57:10 <spuz> oggy: what do you mean by 'test console IO'?
06:57:14 <c_wraith> edwardk was working on IVar-related stuff to make laziness more efficient.
06:57:23 <edsko> c_wraith : hmmm, evaluating a little bit of (++) is natural IN haskell. evaluating a little bit of reverse.. not so much :)
06:57:44 <c_wraith> edsko: pfft.  I'm talking about evaluating a little bit of Delay. :)
06:57:58 <edsko> ... but through a proxy (Progress)
06:58:01 <edsko> well try it :)
06:58:04 <edsko> let me know how you get on :)
06:58:09 <oggy> spuz: i want to ensure that a certain console input to the code under test produces certain console output
06:58:16 <c_wraith> That's not the part I had trouble with! The natural solution did that just fine. :)
06:58:43 <edsko> you mean the one you posted on reddit?
06:58:46 <c_wraith> yeah
06:58:50 <edsko> right, but that doens't work :)
06:59:13 <edsko> anywa,y a solution using IVars without any unsafeInterleave would be nice, as it avoids the proof obligation
06:59:24 <edsko> blog about it if you manage it :)
06:59:25 <geekosaur> oggy, I think that's going to be difficult. and it WILL be nonportable, at least if you want to include things like color or cursor positioning
06:59:39 <spuz> oggy: i have no idea whether that's possible or not. i spent a while trying to figure out how to simply read input in an HSpec test
06:59:42 <geekosaur> (worst case, not even possible on Windows)
06:59:58 <spuz> but i would recommend testing your functions inside the IO boundary
07:00:22 <c_wraith> edsko: edwardk has been working on an IVar approach to problems like making replicateM lazier.  It's a different use case, though, in that the IVar will always be written to before it can be read.
07:01:49 <edsko> pehraps it could work with IVars actually
07:01:53 <edsko> setting up the lattice in the right way 
07:01:58 <edsko> so that we can replace (Later d) with d
07:02:06 <edsko> it would be a fun experiment
07:02:12 <nut_> is there stack delete like cabal delete ?
07:02:54 * hackagebot bini 0.1.3 - A collection of various methods for reading and writing bini files.  https://hackage.haskell.org/package/bini-0.1.3 (TWeise)
07:03:10 <oggy> geekosaur: thanks. i don't need anything fancy. i have some (yes, messy) code that works for simple I/O (hPutStrLn and getLine) but i was wondering if i can convert to HSpec instead
07:03:21 <nut_> geekosaur, sorry i missed that
07:03:21 <byorgey> nut_: try 'stack clean'
07:03:30 <oggy> spuz: thanks. you read input from a file?
07:03:34 <nut_> geekosaur, thanks
07:03:43 <spuz> oggy: yeah
07:04:26 <nut_> byorgey, after stck clean i can delete any stack related files without hurting my folder?
07:04:57 <byorgey> nut_: I don't know
07:05:01 <edsko> c_wraith : I think you'll LVars, not IVars
07:05:14 <edsko> and then the proof obligation will be in the construction of the lattice
07:05:17 <edsko> much of a muchness, I suspect
07:05:28 <oggy> spuz: ok, thanks. do you have pointers for that? i need to redirect stdin and stdout, but maybe HSpec can still come in handy
07:05:29 <edsko> but an interesting experiment nonetheless
07:06:48 <nut_> can cabal build detect unused imports ?
07:07:04 <nut_> i would like to clean up the code
07:07:11 <nut_> with probably some unused imports
07:07:45 <byorgey> nut_: well, GHC can, if you pass it -Wall
07:07:57 <byorgey> cabal build --ghc-options=-Wall    then look at the log
07:08:08 <spuz> oggy: this is how i'm doing it: https://github.com/alexspurling/adventofcode/blob/master/test/Main.hs
07:08:34 <nut_> byorgey, great thx
07:08:35 <spuz> have a look at the individual DayXSpec modules as well
07:08:47 <hexagoxel> nut_: are you using sublimehaskell? you can get errors+warnings into sublime
07:09:52 <oggy> spuz: thanks!
07:10:38 <geekosaur> oggy, for what it's worth, in cases like this it's often better to write your main code in terms of a free monad and then have the actual program interpret that in IO while the test harness uses a mock I/O framework interpreter
07:11:00 <spuz> geekosaur: i would love to see an example of that
07:11:36 <geekosaur> spuz, oggy: http://hackage.haskell.org/package/MonadPrompt
07:12:14 <geekosaur> contains examples
07:12:21 <nut_> hexagoxel, i4m trying to figure how to make sublime work with sandbox
07:12:24 <oggy> geekosaur: thanks. but i'm using this to automatically grade student assignments. might be hard to get them to use free monads in week one :o
07:12:34 <geekosaur> oh. :/
07:13:16 * geekosaur can think of ways to do that, but still requires extra setup. (basically give them a modified Prelude that implements e.g. getLine in terms of the free monad)
07:14:17 <oggy> actually that's not too far fetched. we might need to go with a modified Prelude anyway, due to the Foldable/Traversable thing
07:15:16 <hexagoxel> nut_: you can either install sublime-haskell, or add a custom build-system thingy. if you want, i can pm you some simple setup.
07:15:19 <oggy> and hope nobody tries to :type their I/O functions :D
07:17:39 <nut_> hexagoxel, thanks, i just install sublime-haskell from sublime package system
07:17:52 <nut_> hexagoxel, so you mean it will automatically detect sandbox 
07:19:21 <hexagoxel> nut_: yes, i don't think i had to configure anything for sandboxes.
07:20:12 <nut_> hexagoxel, great
07:43:08 * hackagebot haxr 3000.11.1.3 - XML-RPC client and server library.  https://hackage.haskell.org/package/haxr-3000.11.1.3 (BrentYorgey)
07:43:34 <nut_> can't install ghc-mod on arch linux
07:43:35 <nut_>  Not in scope: data constructor ‘ExposePackageId’
07:43:36 <nut_>     Perhaps you meant ‘ExposePackage’ (imported from DynFlags)
07:43:39 <nut_> any hint ?
07:44:45 <Arguggi> nut_, pacman, cabal, stack?
07:45:46 <nut_> cabal
07:45:50 <nut_> cabal: Error: some packages failed to install:
07:45:50 <nut_> ghc-mod-5.2.1.2 failed during the building phase. The exception was:
07:45:50 <nut_> ExitFailure 1
07:46:35 <nut_> can i maybe install a lower version of ghc-mod ?
07:46:56 <hexagoxel> how about the latest version?
07:47:10 <Arguggi> try using stack, they just added it the the community repo, and then installing ghc-mod is just `stack install ghc-mod`
07:47:49 <nut_> i can't use stack that's why
07:48:17 <quchen> Can you use Cabal?
07:48:22 <quchen> Then cabal install stack, then use stack.
07:49:27 <nut_> stack download files from amazon
07:49:33 <nut_> i can not access amazon
07:52:03 <sshine``> what was the not-haskell channel called?
07:52:19 <sshine``> #nothaskell. great.
07:57:12 <sm> nut_: hmm unfortunate
07:58:45 <byorgey> nut_: as far as I understand, stack downloads cached stuff from amazon just to speed up build times, there's probably a way to turn it off at the expense of longer builds
07:58:53 <lingxiao> hey all
07:58:56 <lingxiao> anyone use emacs ehre?
07:59:27 <nut_> byorgey, how to turn it off?
08:00:16 <byorgey> nut_: I don't know, I just suspect there might be a way.  you could ask on https://groups.google.com/forum/#!forum/haskell-stack
08:00:35 <nut_> i will delete cabal sandbox and build ghc-mod first
08:01:39 <nut_> when i run cabal update inside a sandbox it will update the global index or just the one inside the sandbox ?
08:02:01 <hexagoxel> global
08:02:06 <quchen> sshine``: #haskell-blah?
08:02:16 <nut_> thx
08:02:35 <hexagoxel> (i.e. there is no local index)
08:02:37 <byorgey> lingxiao: if you have an emacs question you should just ask the question =)
08:03:00 <lingxiao> hey brent! yup I just installed company-coq
08:03:10 <lingxiao> mainly to prettify my symbols, ie forall
08:03:22 <byorgey> lingxiao: oooh, sounds nifty =)
08:03:32 <lingxiao> yup! however my symbols are not prettified
08:03:55 <lingxiao> i know company-coq is properly installed since the kyboard shortcuts are there
08:04:00 <byorgey> hmm, no idea, I use emacs but have never tried company-coq
08:04:11 <lingxiao> but i think my emacs cannot display math symbols?
08:04:17 <lingxiao> i assume yours does? im new to emacs
08:04:51 <byorgey> lingxiao: try finding a forall symbol somewhere and try pasting it into emacs?
08:05:16 <byorgey> I find it hard to imagine that any version of emacs these days would be unable to deal with unicode.
08:06:42 <lingxiao> yup displays correctly in a .v file
08:06:44 <dramforever> lingxiao: you could use the emacs input method TeX (type C-u C-\ T e X RET) for that, it enables you to, for example, type that inverted A as \forall
08:07:08 <bitemyapp> Agda mode has that turned on by default I think
08:07:13 <dramforever> Alternatively, you could use the Agda input method built into agda-mode, which is nicer for programming, but requires installation
08:07:18 <lingxiao> dramforever hmm i;m doing the comapny-coq tutorial right now and i assume when i type in forall it should automactially convert to âˆ€
08:07:27 <bitemyapp> sorta. I think the ->'s are special
08:07:51 <dramforever> lingxiao: ah, sorry then
08:08:09 * hackagebot linear 1.20.4 - Linear Algebra  https://hackage.haskell.org/package/linear-1.20.4 (EdwardKmett)
08:08:47 <lingxiao> how do i check what font i am using in emacs
08:09:24 <lingxiao> M-x describe-font gives me nothing
08:09:37 <lingxiao> ah nvm
08:13:09 * hackagebot QuickCheck 2.8.2 - Automatic testing of Haskell programs  https://hackage.haskell.org/package/QuickCheck-2.8.2 (NickSmallbone)
08:14:25 <nut_> before i install a package through cabal, can i check first if there is no dependency issues ?
08:14:49 <hexagoxel> `cabal install --dry-run`
08:15:46 <nut_> ok
08:16:52 <hexagoxel> but that won't promise that dependencies will compile/install successfully :p
08:17:56 <nut_> why ghc-mod is so different? i remember it caused me trouble before
08:18:00 <mag__> lingxiao, check if the pid of the process that handles the fonts in emacs it's up and running... from the emacs command line run `emacs-ps -e` 
08:18:18 * hackagebot exceptions 0.8.1 - Extensible optionally-pure exceptions  https://hackage.haskell.org/package/exceptions-0.8.1 (EdwardKmett)
08:18:20 * hackagebot free 4.12.2 - Monads for free  https://hackage.haskell.org/package/free-4.12.2 (EdwardKmett)
08:20:15 <lingxiao> mag__ ok thanks!
08:20:23 <mag__> :D!
08:41:44 <berson_r> Hi guys, how can I unbox an Int? Is there a function to do that? (Int -> Int#). I didn't find anything about that (maybe I didn't look in the right place...)
08:47:45 <mauke> pattern matching, I'd guess
08:47:57 <cocreature> import GHC.Types that exposes the constructor
08:48:13 <cocreature> https://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/GHC-Types.html#t:Int
08:48:14 <dramforever> :t case n of I# t -> t
08:48:15 <lambdabot>     Not in scope: data constructor â€˜I#â€™
08:48:15 <lambdabot>     Perhaps you meant â€˜Inâ€™ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
08:48:30 * hackagebot type-combinators 0.2.1.0 - A collection of data types for type-level programming  https://hackage.haskell.org/package/type-combinators-0.2.1.0 (KyleCarter)
08:51:29 <berson_r> Thank you for your answer. I imported GHC.Types, but when I give an Int to a function of type :: Int# -> Int# I get a : "Couldn't match kind â€˜*â€™ with â€˜#â€™" error
08:51:45 <berson_r> Do I have to use a special constructor ? (I# or Int#) ?
08:52:36 <dramforever> berson_r: I#, as seen in the definition of Int
08:52:41 <berson_r> (@mauke, I didn't understand how to use pattern matching to unbox an Int)
08:52:54 <dramforever> case n of I# t -> t
08:52:56 <mauke> berson_r: dramforever gave you an example
08:53:24 <monochrom> Int is not Int#
08:53:44 <monochrom> Int# does not have constructors at all
08:54:46 <monochrom> see GHC user's guide for "magic hash" on how to enter a literal of type Int#
08:55:29 <dramforever> oh that! almost forgot it, berson_r you need to turn on the extension MagicHash to be able to use the names ending in #
08:55:45 <dramforever> monochrom: you are very smart :P
08:56:28 <monochrom> no, by the time the message "couldn't match kind * with #" appears, MagicHash is already in effect, otherwise no way kind # happens
08:57:00 <dramforever> sounds reasonable
08:57:34 <monochrom> however, the syntax "143#" is largely unknown until one reads the manual
08:57:35 <berson_r> Yeah you're right, thank you. In fact I think I had two issues (unboxing) and then printing the result of type #Int (print n). The error seems to be from this statement instead... Sorry, I got confused about that.
08:57:56 <monochrom> Int# probably cannot have a Show instance
08:59:00 <berson_r> Mmh, is there a way to get an Int back from Int#?
08:59:07 <Xandaros> Int# has kind #, not *. Don't confuse it with a normal type
08:59:16 <monochrom> yes, use Int's constructor, which is I# as said
08:59:23 <dramforever> berson_r: hint: we already told you that, in a way...
08:59:37 <monochrom> in fact, you shouldn't even confuse two types of kind *
09:00:15 <berson_r> I'm sorry, I didn't understand that I# was Int's constructor
09:00:30 <berson_r> what do you mean by confusing two types of kind * ?
09:01:20 <monochrom> for example presuming that "Reader X Y" is interchangeable with "X -> Y" just because "they are intuitively the same"
09:02:15 <monochrom> err, "Y -> X"
09:02:28 <monochrom> no, "X -> Y" is right
09:02:40 <geekosaur> was gonna say
09:02:54 <geekosaur> (but I'm being pulled about 6 directions at once today...)
09:02:57 <Xandaros> Yeah, they can actually be rather different, even though they should be isomorphic
09:03:24 <berson_r> I see
09:03:28 <geekosaur> well, the main point is that the former is a newtype, so as far as typechecking is concerned they are never the same type
09:03:29 <berson_r> Thanks a lot for the help
09:10:18 <berson_r> Sorry to bother again, but I get the following error: "Couldn't match expected type â€˜Boolâ€™ with actual type â€˜Int#â€™" on the following line: ((n `remInt#` 3#) ==# 0#) || ((n `remInt#` 5#) ==# 0#)
09:10:27 <berson_r> But I don't understand what is wrong about it
09:10:55 <monochrom> ==# does not have codomain Bool. have you looked up its type for real?
09:11:00 <berson_r> ho
09:11:03 <berson_r> Yeah you're right
09:11:07 <berson_r> it returns an Int#
09:11:22 <glguy> berson_r: Are you hoping that if you write fizzbuzz with unboxed types that it will go fast?
09:11:42 <monochrom> you need to read docs for real
09:12:10 <berson_r> glguy: I'm juste experimenting :) Not hoping anything, expect to learn new stuff in Haskell
09:12:55 <glguy> In that case monochrom's hint about reading the documentation will be a great way to learn!
09:13:15 <berson_r> monochrom: Yeah sorry about this one, I didn't think that `==#` would return an `Int#`
09:13:16 <berson_r> my mistake
09:13:44 <berson_r> wrong belief
09:13:51 <geekosaur> I would expect an unlifted operation to have an unlifted result. since there is no hardware boolean, just hardware ints, I'd expect Int#
09:14:27 <monochrom> the best expectation is to expect that oneself is always absolutely wrong
09:14:56 <alpha123> also :t everything, good way to learn
09:15:11 <glguy> monochrom: that'd require you to expect that expectation to be wrong...
09:15:31 <berson_r> Thanks for the advice
09:16:24 * alpha123 supposes ==# is slightly unintuitive at first but geekosaur gives a good explanation
09:16:55 <monochrom> by definition, everything new to you is unintuitive (until no longer new to you)
09:17:17 <orion> Is it possible to detect the presence of an if statement in a DSL?: do w; if x then y else z
09:17:27 <alpha123> monochrom: I wouldn't really say that, lots of new things are rather like old things and conform to the same expectations
09:17:28 <berson_r> except that with the wrong background it's hard to leave everything behind
09:17:34 <alpha123> orion: ...okay, what are you trying to do
09:17:52 <glguy> orion: no
09:18:34 <exio4> alpha123: then it isn't new enough ;)
09:18:53 <alpha123> Fair :-)
09:19:29 <orion> alpha123: If someone writes a program using my DSL, I want to "look ahead" at what they've written so I can evaluate the code more efficiently.
09:20:58 <alpha123> orion: 2 options: 1) write a simple VM 2) have your DSL produce some graph that you run with a separate call (which can optimize it)
09:21:03 <alpha123> the options aren't mutually exclusive
09:21:43 <orion> So really, I can't treat the Free Monad as an AST that I can traverse at will.
09:21:49 <alpha123> (actually the second is a special case of the first)
09:23:10 <alpha123> orion: Generally it is much easier to just define your own AST
09:23:41 <monochrom> you probably have to define your own if-then-else combinator rather than reuse Haskell's. and then you have to tell users to use your combinator.
09:23:53 <orion> I thought I defined my own AST when I defined the Free Monad functor.
09:28:03 <davean> orion: you did, but the haskell one is being used to CREATE your AST
09:29:03 <alpha123> orion: Sorry, I think I've confused you. Your Free monad doesn't have a node for the If-Then-Else. You should probably add one, if you want to have if statements in your DSL. Otherwise it runs when the do block is run, not when your DSL is run.
09:29:30 <davean> And you can traverse it at will if it is pure, you just have to do some tricks.
09:29:50 <orion> davean: What are those tricks?
09:30:47 <davean> orion: like converting values to classes, and when you want to look at the AST pass in versions that extract how they're inspected instead of being actual values
09:31:10 <davean> Like AD does
09:31:17 <davean> http://hackage.haskell.org/package/ad
09:31:26 <shaleh> Say I have a parsec parser for extracting a date in the form of "YYYY,YYYY-YYYY,....." from some content. Since it is comma separate I use sepBy and get a list of years. All good so far. NOw what I would like to do is change or insert a date in that list and replace the original section in the content with the new list of years. I am not having much luck discovering how to find the begin and end of a grabbed region of parsed 
09:31:26 <shaleh> content. Thoughts?
09:34:00 <sm> shaleh: look in the haddocks, there is support for getting the current parse context including position
09:34:14 <deni> I have a function that given a link returns a IO (Maybe [URL]). I have to map that function ove a infinite list. Which basically gives me a list of IO actions. Now I wanna sequence that list to get the result but break out if the result is Nothing. Is there a sequenceUntil or something like that? Or am I thinking abut this totally wrong?
09:34:48 <shaleh> sm: hmmm, ok.
09:41:14 <kadoban> deni: So okay, you have a [IO (Maybe [URL])] , right? So use 'sequence' and then you have :: IO [Maybe [URL]], then you can use 'catMaybes', which is type :: [Maybe a] -> [a] (so you have to use 'fmap' with it), so if you use fmap catMaybes, then you have IO [[URL]] . If it's truly an infinite list, you can just fmap head on that and it'll give you the first one that succeeded.
09:43:03 <exio4> kadoban: would it work? 
09:43:18 <kadoban> Not sure XD I think so?
09:43:31 <ddellacosta> reading through this: http://www.well-typed.com/blog/2016/01/efficient-queues/ and I realized I don't know what "@" means--looking at the example about halfway down the "Strict, Non-Persistent Queues" section
09:43:32 * hackagebot type-combinators 0.2.2.0 - A collection of data types for type-level programming  https://hackage.haskell.org/package/type-combinators-0.2.2.0 (KyleCarter)
09:43:34 <exio4> kadoban: it's an infinite list
09:43:38 <sm> shaleh: see getPosition and http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Pos.html
09:43:43 <ddellacosta> would someone mind telling me what that means?
09:43:52 <ddellacosta> specifically, "inv1 q@(Q1 f xs r ys)"
09:43:56 <kadoban> exio4: What part is that a problem for though?
09:44:00 <shaleh> sm: thanks
09:44:11 <exio4> > sequence (repeat (return 1)) :: Maybe [Int] 
09:44:13 <lambdabot>  *Exception: stack overflow
09:44:33 <deni> kadoban: it's an infinite list in the sense that I'm scraping a URL with pagination...so given a URL i get back a list of links that I need and then page to the next page. Since I don't know how many pages I have for a given url I just page til [1..] and assume that when the scraper can't find any more links there to stop
09:44:42 <deni> perhaps there's a better way to model this
09:46:12 <kadoban> exio4: Hmm, that error is suspicious I guess :-/ It should just be the timeout one if it was going to work how I hoped, huh?
09:46:40 <deni> kadoban: so I don't think I ca just sqeuence the list and then catMaybes
09:46:44 <deni> it would go on forever
09:46:50 <deni> right?
09:47:02 <exio4> kadoban: it should have done "Just [1,1,1,1,1,1,1,1,1..." which would mean it was able to look ahead and know the computations wouldn't have returned Nothing
09:47:43 <exio4> kadoban: the same goes for IO, you need to compute everything before returning the [Maybe [URL]] list, and if it is an infinite list.. 
09:47:54 <deni> I was playing around with mapM and takeWhile but I haven't gotten anywhere
09:48:03 <exio4> kadoban: (or you can always use unsafeInterleaveIO and ... well, let's ignore that :p)
09:48:12 <deni> :D
09:48:35 <codedmart> I am working with an api that uses params as `user_login`, if I make a data UserParams = {userLogin :: Text} and derive instances for (To,From)JSON will that use "userLogin" in the json?
09:50:38 <deni> I could probably get the exact page number and just run through that exact page count so it won't be an infinite list anymore but I thought it would be possible to model it this way
09:57:44 <shaleh> sm: worked like a charm. do { pos1 <- getPosition; parsed <- csv input; pos2 <- getPosition } 
10:00:54 <sm> shaleh: good
10:07:49 <ddellacosta> so, can anyone tell me what the "@" means in "inv1 q@(Q1 f xs r ys)", in this article: http://www.well-typed.com/blog/2016/01/efficient-queues/ (see toward the bottom of the "Strict, Non-Persistent Queues" section)
10:09:38 <geekosaur> it lets you have a pattern while naming the whole thing it matches ("as-pattern")
10:15:12 <ddellacosta> geekosaur: I don't quite get it but that gave me enough to actually search on it.  Now I can at least RTFM.  Thanks!
10:15:45 <geekosaur> basically, q gets bound to the (Q1 f xs r ys), while also binding the 4 things inside it
10:16:11 <geekosaur> rather than having to say inv1 q = let (Q1 f xs r ys) = q in ...
10:17:15 <geekosaur> or having to say (Q1 f xs r ys) somewhere in the code (which will do a new allocation, and may not preserve the type)
10:43:55 <broma0> is there a typeclass floating around somewhere that captures the general idea of encoding/decoding - 'enc :: a -> Maybe b, dec :: b -> Maybe a'? There are so many specialized versions of this
10:45:16 <bergmark> broma0: the convertible packages has one, but I don't think having a general type class for conversions makes sense, it's unlikely that everyone wants to convert every type in the same way
11:11:13 <ReinH> codedmart: you can supply your own rules to deriveJSON http://hackage.haskell.org/package/aeson-0.10.0.0/docs/Data-Aeson-TH.html
11:11:44 <ReinH> codedmart: but it's easy to write instances manually if you want more control
11:12:02 <codedmart> ReinH Thanks! I found that after I asked.
11:12:10 <ReinH> codedmart: :D
11:42:08 <rdrx> I can't tell if cps in haskell forces continuations to evaluate sequentially. I've walked through a couple examples and can't see that the continuations would necessarily evaluate in the order they're passed. Does cps in a lazy lang force sequential evaluation, or does it give the same result sequential evaluation would?
11:42:32 <rdrx> Or something else entirely...
11:47:07 <Saizan> it depends how you use the continuations, but they do give you the opportunity to be stricter
11:49:39 <dolio> Generally continuation passing gives you the ability to represent whatever evaluation order you want, regardless of the evaluation order of the ambient language.
11:50:33 <rdrx> I can see how strict continuations would force sequential evaluation, but I can't see how you could get strict evaluation from lazy continuations.
11:51:16 <rdrx> Can you get strict eval from lazy continuations?
11:52:15 <codedmart> I am trying to use wreq inside servant and catch errors. I still have a hard time parsing errors sometimes. Can anyone spot what I am missing with this small snippet? https://gist.github.com/codedmart/78bf57eb2f508b9d11aa#file-main-hs-L11-L19
11:53:04 <shaleh> rdx: you can always for strict eval when needed
11:53:11 <shaleh> s/for/force/
11:53:42 <Saizan> rdrx: the strictness of the continuation doesn't matter, you decide the control flow by how you pass the continuations around
11:54:23 <Saizan> ?ty runCont
11:54:24 <lambdabot> Cont r a -> (a -> r) -> r
11:54:34 <Saizan> > runCont (mapM return (1:undefined)) id
11:54:37 <lambdabot>  *Exception: Prelude.undefined
11:55:14 <Saizan> rdrx: see? we're being strict in the list because the Cont monad corresponds to call-by-value cps
11:57:48 <jle`> > head (runCont (mapM return (1:undefined)) id)
11:57:50 <lambdabot>  *Exception: Prelude.undefined
11:57:52 <jle`> neat
11:59:17 <rdrx> ohh, that makes sense: you're not ordering evaluation, but control flow. So the ordering of the continuations determines their scope?
12:00:03 <Saizan> scope?
12:00:48 <rdrx> the results of previous computations are within the scope of subsequent computations?
12:03:02 <Saizan> i'm not sure i follow, but you might like to specialize the mapM code to the Cont monad and compare to what would instead happen with the Identity monad to see what the continuations achieve
12:03:30 <Saizan> it's also similar to how foldl is strict in the list while foldr is not
12:03:34 <Saizan> ?src foldl
12:03:34 <lambdabot> foldl f z []     = z
12:03:34 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:04:30 <Saizan> since foldl recurses directly, using f in the accumulator, then it's always going to consume the whole list
12:04:36 <Saizan> ?src foldr
12:04:36 <lambdabot> foldr f z []     = z
12:04:36 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:05:12 <Saizan> the recursion in foldr instead happen in an argument to 'f', so if 'f' is lazy enough you might not look at the whole list before producing some result
12:05:57 <Saizan> my runCont-mapM example works similarly to foldl, but what is being accumulated is a continuation
12:06:05 <dolio> Also, if you're compiling to CPS, any matching on a list in your host language would likely turn into something that calls a continuation with the head and tail of the list.
12:06:48 <dolio> Same with other data types.
12:07:03 <rdrx> thanks, might take a while to digest :)
12:07:40 <dolio> So, you cannot do something like 'pass a lazily evaluated `fst p` to a function.'
12:08:13 <dolio> You can only call a function in the continuation of matching on p with the first piece given to you.
12:23:20 <itsu`> anyone has an idea why fmap has the signature Functor f => (a -> b) -> f a -> f b
12:24:09 <itsu`> and the instance functor (->) has fmap :: (b -> c) -> (a -> b) -> a -> c
12:24:45 <itsu`> why are the signatures different ?
12:24:54 <danilo2> Hello guys! What is the best regex library nowadays in Haskell? 
12:25:26 <johnw> itsu`: it's just different variable names; but f b == a -> b in this case
12:26:27 <itsu`> johnw: oh ok, I see
12:28:10 <itsu`> thanks!
12:28:54 <ralu> is there option for type alias in type signature?
12:30:33 <eitanChatav> what is the proper invocation to run `stack test` with a `quick-check-replay` seed?
12:35:56 <eitanChatav> what is the proper invocation to run `stack test` with a `quickcheck-replay` seed?
12:36:17 <johnw> we saw the question the first time
12:41:00 <eitanChatav> sorry
12:41:14 <johnw> there is also #haskell-stack
12:41:38 <eitanChatav> thanks, I'll ask there
12:41:58 <johnw> at this time of day, it may be even quieter :(
12:53:31 <quakehead> Anyone familiar with Parsec?
12:53:43 <johnw> just ask your qustion
12:54:40 <quakehead> Why are some functions like "many" have the type signature "Text.Parsec.Prim.ParsecT s u m a" but the individual parsers we write are type "Parser <our type>"?
12:54:52 <quakehead> I'm following the "Write yourself a scheme" tutorial.
12:55:33 <tdammers> type synonyms
12:55:44 <quakehead> Oh.
12:56:34 <tdammers> ParsecT s u m a is the most generalized way of writing the type
12:56:57 <tdammers> (s u m and a being the stream type, user state, underlying monad, and output type)
12:56:59 <tommd> Parser is an alias for ParsecT String () Identity
12:59:39 <quakehead> Thanks tdammers. I'll have to learn more about the type system I guess.
12:59:57 <koz_> quakehead: If you want something a bit simpler for parser combinators, attoparsec is your game.
13:00:05 <koz_> I picked it up in, like, a few hours with some help.
13:00:26 <koz_> It's not as powerful as Parsec, but for simpler stuff, it's a bit easier to make sense of.
13:02:06 <quakehead> Thanks koz_
13:02:19 <quakehead> I still need to learn what a combinator is.
13:02:31 <koz_> quakehead: Basically, the idea is 'writing parsers in small parts'.
13:02:49 <koz_> So instead of writing a parser than can read something complicated, you write a series of simple alternatives and wire them together.
13:03:44 <quakehead> thanks. gtg...
13:03:51 <koz_> quakehead: https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec
13:03:57 <koz_> Check that out some time.
13:04:10 <quakehead> alright...
13:05:18 <mfitton> Hey y'all, I'm getting an error where it's saying that some data constructors don't exist. I'm guessing it has something to do with how I set up my where statement http://lpaste.net/7628441489172856832
13:05:27 <mfitton> If someone could help me out I'd really appreciate it
13:06:31 <mfitton> Do I need to nest where clauses that are dependent on other where clauses?
13:12:00 <mfitton> Nevermind, I found the issue. identifiers have to be lower case in haskell!
13:12:54 <Fuco> is there some built-in urldecode or should I get some package?
13:13:24 <sleblanc> Can I pass args to ghci / cabal repl such that those args will be available from the System.Environ(getArgs) function?
13:13:40 <sleblanc> System.Environment*
13:13:54 <koala_man> sleblanc: VAR=foo ghci 
13:14:04 <koala_man> oh I misread that
13:14:45 <bergmark> sleblanc: withArgs
13:15:18 <mauke> Fuco: nothing is built in
13:15:36 <Fuco> well, some standard package... there's million things outside
13:15:38 <Fuco> half of it broken :P
13:15:46 <mauke> sleblanc: :set args ...
13:16:51 <sleblanc> bergmark, withArgs is cool. mauke, exactly what I needed
13:21:13 <Cale> mfitton: Yeah, this is just so that it's easy to syntactically distinguish, when reading a pattern to be matched, which things are data constructors to be matched, and which things are variables to be bound
13:21:55 <Cale> mfitton: data constructors always start with an uppercase letter (or if they're infix symbols, a colon), while other variables don't.
13:23:08 <exio4> sleblanc: :main ab cde works too
13:26:34 <sleblanc> exio4, good for one-off changes, thanks
13:27:33 <jgrocho> quit
13:34:14 * hackagebot fltkhs 0.4.0.0 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.4.0.0 (deech)
13:36:32 <broma0> So i know we can't have two record types with the same record field names, but is there any template-haskell / lensy magic somewhere that will satisfy my need for OverloadedRecordFields before it's out?
13:37:32 <broma0> basically, are there any libraries out there that to any degree provides what OverloadedRecordFields will? 
13:38:56 <mauke> I remember some TH thing for first-class record types
13:39:06 <mauke> does anyone remember the name?
13:40:27 <broma0> was it fclabels?
13:41:06 <mauke> unlikely, that says it is "first class accessor labels"
13:42:23 <mauke> https://nikita-volkov.github.io/record/
13:43:43 <broma0> mauke: ooo fancy
13:49:15 * hackagebot fltkhs-fluid-examples 0.0.0.3 - Fltkhs Fluid Examples  https://hackage.haskell.org/package/fltkhs-fluid-examples-0.0.0.3 (deech)
13:49:17 * hackagebot fltkhs-hello-world 0.0.0.2 - Fltkhs template project  https://hackage.haskell.org/package/fltkhs-hello-world-0.0.0.2 (deech)
13:59:21 <monochrom> haha I love what lukewarm says about industry quality software
14:02:35 <tdammers> "industry", "quality", and "software", right next to each other? hah!
14:03:10 <monochrom> yeah! he wrote something sarcastic
14:09:47 <Cale> monochrom: lukewarm?
14:10:39 <sleblanc> Hiding a data constructor in an internal module seems like a good way to enforce value-dependent types, by exposing functions that have access to the constructor. If I cannot afford to put things in a sub-module (as in a GHCI session) is there a way to hide a data constructor?
14:11:17 <sleblanc> Like a compiler pragma that would tell GHC/GHCI "From now on, newly-defined functions cannot refer to this constructor anymore"
14:23:37 <Cale> sleblanc: Not as far as I'm aware. Modules are the main way to abstract things.
14:24:12 <Cale> sleblanc: Generally you want to keep the amount of important code and definitions that you type into ghci to a minimum, since it's easy to lose things that way
14:30:06 <sleblanc> Cale, yeah, I get it. It seems like a :delete or :hide command would be useful in GHCI.
14:30:38 <Welkin> Cale: or have one giagantic let ... in
14:31:23 <Cale> Yeah, I guess if we're going to have all these declaration forms, we could also just allow module declarations
14:32:08 <Cale> But I don't know how I feel about allowing declarations in the first place :P
14:33:05 <Cale> I guess I grew up in a time when what GHCi did was much more straightforward
14:33:27 <Welkin> Cale: get off my lawn!
14:33:43 <Cale> (it used to be that you couldn't even make new declarations, let alone data declarations)
14:35:20 <Cale> Which while it seems like a convenience (and I'll admit, sometimes is), it's also asking users to shoot themselves in the foot to some extent. Maybe ghci should only let you make declarations if it had a file to put them in for you, and it should work by adding to that file and reloading it as you go.
14:35:53 <sleblanc> Cale, at this point, you might as well make GHCI an Emacs mode or Vim extension
14:36:35 <Cale> sleblanc: I like that it's editor agnostic though
14:36:59 <Cale> sleblanc: The standard thing to do is just to always have your favourite text editor open alongside ghci
14:37:15 <Cale> sleblanc: when you make changes to the set of declarations, you type :r in ghci and it reloads
14:54:16 <ReinH>  sleblanc well, there is an interactive mode for emacs that gives you a ghci window
14:54:28 <ReinH> but there's no reason to get rid of plain ghci
15:13:36 <haslklklk> hello (i hope this is the correct place to ask this), i recently started learning haskell and I run in a problem when I try to compile my code. Haskell seems to expect a bool where I expect an Int: https://gist.github.com/anonymous/fb01d317bf7e7700658d  
15:14:29 <glguy> haslklklk: The second clause in your containsFour definition is matching on the number 4, not a list starting with a 4
15:14:42 <acowley> haslklklk: You have a couple problems there. The one you're referring to is due to returning a list.
15:14:51 <glguy> haslklklk: the third clause is returning a new list instead of the boolean answer
15:15:35 <acowley> haslklklk: What do you intend "x:" to be doing on the right-hand side of the third equation?
15:17:12 <haslklklk> i have a list of ints (i.e 1,2,3,4) and want to get the first number as an integer. The rest of the list should be checked again  
15:17:47 <acowley> haslklklk: The type you've written for your function says it returns a Bool
15:18:28 <acowley> haslklklk: So it's not clear how you could "get the first number as an integer" if you are producing a Bool
15:19:08 <haslklklk> i have to write a programm that checks if a list of ints contains a "4" and return true or false, and i should use recursion
15:19:39 <acowley> haslklklk: Okay, so when you're working with a list, the way to approach it is to break it down: A list can be empty, or non-empty.
15:19:54 <acowley> haslklklk: You've written the first equation correctly, so you're half done! :)
15:20:51 <acowley> haslklklk: The next case to consider is a non-empty list. So you pattern-match on that as you've done in the third equation.
15:21:07 <acowley> haslklklk: Those two patterns cover all possible lists!
15:21:49 <acowley> haslklklk: Now you've got x and xs from the pattern match, what do we do with the x?
15:22:26 <haslklklk> I'd to check if the x equals 4
15:22:30 <haslklklk> *want
15:22:36 <acowley> haslklklk: Right!
15:22:54 <acowley> haslklklk: There are several ways to write this, but we'll stick to the way you've done it.
15:23:21 <acowley> haslklklk: So we'll take the pattern (x:xs), and replace the x with 4 in the pattern.
15:23:50 <acowley> haslklklk: That gives you an equation "containsFour (4:xs) = _". What do we replace the "_" with?
15:25:41 <haslklklk> um, we still want to have :containsFour(xs) at the end I guess?
15:26:05 <haslklklk> no wait, we want a bool at the end right?
15:26:15 <acowley> haslklklk: Right, we need to replace "_" with a Bool
15:26:25 <acowley> haslklklk: And we know we have a list that begins with a 4
15:26:40 <haslklklk> we would need true there
15:27:23 <haslklklk> (since our lists starts with a four)
15:27:32 <acowley> haslklklk: Right! So we've considered empty lists, and lists that begin with 4.
15:27:56 <acowley> haslklklk: So, writing things this way, we'll need one more equation that will look at lot like the second.
15:28:11 <acowley> "a lot like"
15:28:35 <acowley> haslklklk: What do the lists we haven't pattern matched look like? Can they be empty?
15:29:03 <haslklklk> They can't be empty (would be first case) and they can't begin with 4 (second case)
15:29:54 <acowley> haslklklk: Awesome, so how can we match a non-empty list where we don't look for any particular value in its head?
15:31:40 <haslklklk> something along the lines of x:xs ?
15:31:47 <acowley> haslklklk: You got it!
15:32:05 <acowley> haslklklk: And now we know what about x?
15:32:57 <haslklklk> it's an int (except 4)
15:34:06 <acowley> haslklklk: Exactly right, so what's left is to figure out if the rest of the list containsFour, and you know how to do that, right?
15:35:45 <haslklklk> I'd cut the first element of the list until it starts with 4 or it's empty
15:36:12 <acowley> haslklklk: We already have a name for that from the pattern we used in the third equation!
15:37:12 <acowley> haslklklk: The third equation we've written thus far is "containsFour (x:xs) = _" We know x is not 4, and we need to return a Bool. What do have left to work with?
15:38:17 <haslklklk> containsFour(xs) ?
15:38:27 <acowley> haslklklk: Bingo!
15:38:34 <acowley> haslklklk: Except we'd write it "containsFour xs"
15:38:59 <haslklklk> thanks, a lot acowley
15:39:17 <acowley> haslklklk: One way to think about getting there is to consider that we still have "xs" from our pattern, and we need to turn it, an [Int], to a Bool. A function that does that is containsFour.
15:39:44 <acowley> haslklklk: No problem!
15:42:01 <haslklklk> I understood it now (and it compiles now), thanks for that awesome explaination 
15:42:25 <haslklklk> *explanation
15:46:22 <dobq> is it right that STM objects are destroyed/freed by the garbage collector? since there are new* but no free* methods
16:02:58 <jsqr> 
16:16:30 <Enigmagic> dobq: yes
16:29:20 * hackagebot brick 0.4.1 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.4.1 (JonathanDaugherty)
16:30:05 <bscode> does haskell have a builtin lastN :: Int -> [a] -> [a] ?
16:30:10 <bscode> where it returns the lastN items instead of just the last1 item ?
16:34:42 <acowley> bscode: Not in base afaik, but "join . (drop .) . flip ((-) . length)" just rolls off the tongue, no?
16:35:21 <bscode> acowley: I prefer " let len = length fname \n let rst = drop (len - 4) fname ... "
16:35:32 <bscode> acowley: but yours looks more advanced, like a magical incantation
16:35:44 <acowley> bscode: Yes, I think writing it pretty much any way other than I pasted there would be better :)
16:36:02 <acowley> All I did was
16:36:14 <acowley> @pl \n xs -> drop (length xs - n) xs
16:36:15 <lambdabot> join . (drop .) . flip ((-) . length)
16:36:40 <acowley> It's often written in passing as "reverse . take n . reverse" though
16:37:20 <bscode> it's the type of thing, where I feel, in a pure langauge, should be do-able in O(1) time if one has a right representation fo ByteString
16:37:32 <bscode> but I guess I asked [a] -> [a], not ByteString -> ByteString
16:38:00 <acowley> Oh, yeah, the array-backed things usually do have that function
16:39:00 <bscode> you know what's weird? when using Parsec, with ByteString as the underlying code, I get a return result of [Char] instead of a ByteString
16:39:25 <bscode> so suppose you had a ByteString and you said: "parse up until the first :", in Parse, it's Parsec.many (Parsec.noneOf ":")
16:39:35 <bscode> and we get a [Char] back, instead of a ByteString; which I guess makes sense given the type of Parsec.many
16:39:37 <acowley> e.g. http://hackage.haskell.org/package/text-1.2.2.0/docs/Data-Text.html#v:takeEnd
16:39:48 <bscode> but if there was some optimiaztion to return a ByteString that'd be cool too
16:40:13 <bscode> acowley: noted, thanks
16:41:02 <nshepperd> you can do Int -> [a] -> [a] in O(m) time and O(n) memory using Data.Sequence :)
16:41:48 <bscode> we're going to have the world's most optimized subroutine for figuring out: "somewhere in this substring, is there a *.ttf file" ?
16:42:04 <nshepperd> where m is the length of the list, and n is the length of the suffix you want
16:45:27 <ahihi> O(m) seems suboptimal, isn't Data.Sequence.drop logarithmic?
16:47:02 <Cale> If you have a list, you can't access the nth element in any less than O(n) time.
16:47:52 <nshepperd> yes, it requires O(m) just to get to the end of the list
16:48:43 <Cale> You can skip taking the length explicitly though, by some trickery
16:49:25 <nshepperd> the Seq is just so you can start throwing away items into gc once you've got n of them
16:49:59 <Cale> > (\xs -> zipWith const (tails xs) (drop (3+1) xs)) [1..10]
16:50:01 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,9...
16:50:10 <Cale> > last . (\xs -> zipWith const (tails xs) (drop (3+1) xs)) $ [1..10]
16:50:12 <lambdabot>  [6,7,8,9,10]
16:50:20 <Cale> oh, right, heh, 3 - 1
16:50:22 <Cale> > last . (\xs -> zipWith const (tails xs) (drop (3-1) xs)) $ [1..10]
16:50:24 <lambdabot>  [8,9,10]
16:52:08 <Cale> It's not really going to be much better, but hey, whatever avoids taking lengths :)
16:53:06 <nut> can cable update tells you what has been updated ?
16:53:19 <Cale> nut: It just updates the index
16:53:36 <Cale> It doesn't actually change any of your packages
16:54:05 <nut> i know but i suppose in the new index some packages have newer versions
16:54:05 <nshepperd> is that use of tails memory efficient? supposing that the source is an enumFromTo or something
16:54:40 <Cale> nut: Yeah, I don't think it hangs on to the old index, so you can't really tell.
16:54:42 <nut> and it doesnt hurt to know what packages have newer versions
16:55:00 <nut> Cale, ok
16:55:04 <nut> Cale, thx
16:55:18 <Cale> nshepperd: It's as memory efficient as anything which forms a list of pointers to things which are already in memory
16:55:25 <Cale> (lazily)
16:55:31 <nshepperd> oh, last fuses with zipWith, i think
16:55:56 <Cale> and yeah, perhaps some fusion and stuff would improve it, but I don't know if that really happens or not here
16:56:57 <Cale> But even if it doesn't fuse, at most one element of the tails list will be live at any moment
16:58:21 <nshepperd> yeah and the rest of the tails only point to a sublist of that element so i guess it should be
16:58:26 <Cale> All of them will become garbage essentially the moment they're created, so it's not like this has much worse live memory requirement than the version that computes the length
17:01:00 <nshepperd> length forces the spine of the source list before reading anything
17:04:45 <nut> how to make sublime aware of cabal sandbox ?
17:08:20 <homovitruvius> quick question on lenses in http://dpaste.com/0X9ADQ9, shouldn't I get an instance of HasLanguageConfig for CompilerCOnfig?
17:35:08 <Lynn> Hi. I have a bunch of laws (http://hackage.haskell.org/package/these-0.6.1.0/docs/Data-Align.html), and I want to check them all for an instance I wrote with QuickCheck
17:36:15 <Lynn> I tried defining:  law1 x = (`align` nil) x == fmap This x
17:36:53 <Lynn> And then writing `quickCheck law1`? But apparently, it can't derive a whole bunch of stuff
17:37:33 <Lynn> Is there maybe a general, nice way to get QuickCheck to do what I mean? ;.;
17:51:22 <Lynn> (I think I got it to work!)
17:56:25 <Lokathor> so i'm trying to figure how MonadState works, and I think want to write a function that looks kinda like this http://lpaste.net/149763
17:56:53 <athan> Lokathor: Yeah that works
17:56:57 <Lokathor> but, ghc is telling me it's far too ambiguious
17:57:02 <athan> so long as `random` is pure
17:57:12 <athan> how?
17:57:19 <athan> like, `m a ~/~ m a1`?
17:57:36 <athan> or that `s ~/~ s1`?
17:57:55 <athan> in that `gen` and `gen'` don't necesarilly have the same type?
17:58:22 <Lokathor> i updated the lpaste with the error output
17:58:47 <glguy> Lokathor: You need to provide a type signature
17:59:07 <Lokathor> what signature should i provide? i tried, doRandom :: (Random r, RandomGen g, MonadState ms) => ms g r
17:59:16 <Lynn> https://bpaste.net/show/72d9bd69de57 I don't really understand this error
17:59:22 <athan> Lokathor: That should get it
17:59:25 <athan> oh hm
17:59:27 <Lynn> "The type variable `b0' is ambiguous" but I never mentioned b0!
17:59:33 <glguy> (Random r, RandomGen g, MonadState g m) => m r
18:00:03 <Lokathor> ohhh, the g goes into the MonadState instance?
18:00:04 <Lokathor> alright
18:00:15 <Lokathor> yeah that works
18:00:17 <athan> glguy++ good eye
18:01:00 <glguy> Lynn: It looks like you wanted the 'a' and 'b' types on 'This' to be the same as the ones in the type signature
18:01:29 <glguy> You need to use ScopedTypeVariables if that's the case and then ammend your type signature on 'lawl' to use explicitly quantified type variables
18:01:48 <fresheyeball> data Foo a where Finite :: (Num a) => a -> Foo a | PositiveInfinity :: Foo a  | NegativeInfinity :: Foo a 
18:01:49 <athan> Even then you'll still chase your tail!
18:01:53 <fresheyeball> what should I call foo?
18:01:57 <athan> fresheyeball: yoooo
18:02:09 <fresheyeball> athan: meeeroaroowowww
18:02:15 <fresheyeball> I have naming problem
18:02:18 <fresheyeball> you answer it
18:02:19 <fresheyeball> haha
18:02:19 <glguy> Lynn: but an even better solution might be to use Eq1 and Show1 instead of what you have here
18:02:52 <athan> fresheyeball: Wait so you just want two symbols for positive & negative infinity?
18:03:08 <athan> hrm
18:03:11 <athan> cardinal numbers
18:03:19 <Lynn> glguy: Could you give an example of what that would look like?
18:03:27 <fresheyeball> athan: yes basically, I need a type that can either be an Int or Infinity
18:03:59 <glguy> Lynn: what modules are you using in that paste?
18:04:40 <fresheyeball> athan: so 
18:04:43 <athan> fresheyeball: https://hackage.haskell.org/package/logfloat-0.13.3.3/docs/Data-Number-Transfinite.html?
18:05:09 <athan> hmm, it's hard to say
18:05:34 <Lynn> glguy: Right now I have this: https://bpaste.net/show/f737267fc744
18:05:38 <athan> fresheyeball: So what you're saying is, you want to represent the idea of a value being out of bounds?
18:05:51 <athan> in both past `maxBound` and `minBound`?
18:05:53 <Lynn> (Ignore the ScopedTypeVariables stuff; Eq1/Show1 looks more interesting :))
18:06:09 <athan> s.t. NegInf < minBound && PosInf > maxBound?
18:06:44 <fresheyeball> athan : no, really Infinity or unbounded
18:07:00 <athan> fresheyeball: So you want `Integer` instead of `Int`?
18:07:30 <SLi> Hey, I need to read an unboxed Vector Int32 from disk reasonably quickly (I can choose the format to store it in). Currently I use ByteStrings to read decimal numbers and bytestring-read to convert them to Int, but reading 56M ints this way takes 45 seconds. I guess reading the raw memory contents (56M 4-byte elements) would be a good way, but how do I read such a thing into an unboxed vector?
18:07:41 <fresheyeball> athan : well, if I was in Haskell I'd just use Integer, but really I'm working with an API that is not mine
18:07:47 <athan> hmm okay
18:07:51 <fresheyeball> and that api has a concept of Infinity vs Int 
18:07:59 <athan> ahhh wow okay
18:08:05 <fresheyeball> so I will marshall to what they actually want
18:08:11 <fresheyeball> but I wanted it to be type safe on my end
18:08:49 <athan> damn, I would call it something like "MaybeCountable`
18:09:23 * hackagebot happstack-authenticate 2.3.3 - Happstack Authentication Library  https://hackage.haskell.org/package/happstack-authenticate-2.3.3 (JeremyShaw)
18:10:46 <SLi> Never mind, actually bytestrings have a readInt and using it cuts the time to 10 seconds, which starts to be OKish (after all I'm reading several hundred megabytes).
18:12:36 <fresheyeball> athan : MaybeCountable or Cardinal ?
18:12:51 <athan> fresheyeball: I am actually wrong about cardinal I think
18:13:08 <athan> I was probably thinking of ordinal :\
18:13:09 <glguy> Lynn: I don't quite understand what this code is trying to do, but you can use Eq1 f instead of Eq (f (These a b))
18:13:25 <athan> fak
18:13:30 <fresheyeball> athan: so does this make sense? MaybeCountable Float 
18:13:31 <glguy> Lynn: As var as the 'b' type goes, you'll need to either pick a type for it (like () ), or specify it with a proxy argument
18:13:42 <athan> fresheyeball: Definitely makes sense to me
18:13:50 <athan> then you know it could be +/- infinity
18:14:06 <glguy> Lynn: For the Show case you'll have to keep the original Show instance, probably, since QuickCheck's === is relying on it
18:14:33 <Lynn> I really just want to test the first law mentioned for the Align typeclass: (`align` nil) == fmap This
18:14:40 <Lynn> For the instance I wrote
18:15:54 <Lynn> But hm, I suppose that's tricky; QuickCheck can't test 100 "random" choices for `f` and `g` can it...
18:15:58 <athan> fresheyeball: https://en.wikipedia.org/wiki/Cardinality#Cardinal_numbers
18:16:17 <athan> Lynn: Only if you can!
18:16:18 <athan> :P
18:16:26 <glguy> law1 :: forall f a. (Align f, Eq (f (These a ())), Show (f (These a ()))) => f a -> Property
18:16:27 <glguy> law1 x = align x (nil :: f ()) === fmap This x
18:16:44 <athan> Oh jeez I read that as "lawl"
18:17:29 <Lynn> glguy: Neat, that works!
18:17:43 <Lynn> (Now I only need to write an Arbitrary instance for Compose, grrr)
18:18:03 <glguy> Lynn: fwiw you can avoid scoped type variables like this: http://lpaste.net/149765
18:18:39 <Lynn> Eek, that's hacky
18:18:45 <Lynn> But a cool trick, I'll keep it in mind
18:19:21 <Lynn> It's weird to see just "f a" in a type signature without any constraints on `f`
18:19:52 <fresheyeball> athan : Carinal still looks right to me
18:20:01 <fresheyeball> what am I missing?
18:20:08 <Lynn> https://hackage.haskell.org/package/QuickCheck/docs/Test-QuickCheck-Arbitrary.html Uh?
18:20:31 <athan> fresheyeball: well, I _think_ cardinality is something like the "measure of how fast you're moving to infinity"
18:20:43 <athan> so you could cardinally measure the countability of some sets
18:20:56 <athan> actually wait
18:21:00 <athan> I think you're right then lol
18:21:06 <athan> I am ___not sure___ lol
18:21:49 <fresheyeball> athan: I'm going to go with Cardinal for now, so if I get smacked I can learn
18:21:59 <qmm> > :t find
18:22:01 <lambdabot>  <hint>:1:1: parse error on input â€˜:â€™
18:22:01 <cir0x> Hey! I need a middle function (just like that http://lpaste.net/149766), but when I call it with for example "nn" it should return an empty list
18:22:26 <athan> :x
18:22:40 <athan> fresheyeball: But what if it's like a smack with the cardinality of infinity or something?
18:22:52 <athan> or like a cardinality of infinity with a cardinality of infinity?
18:23:07 <geekosaur> aren't there a bunch of unsolved problems with respect to cardinality anyway? maybe confusion is inevitable >.>
18:23:13 <fresheyeball> AAAAaaaaAAAaaa.....aaaathan!
18:23:32 <qmm> find :: (a -> Bool) -> [a] -> Maybe a
18:23:44 <athan> your homework: proove that `infinity :: cardinality (infinity :: cardinality 1)` is associative
18:23:48 <qmm> filter :: (a -> Bool) -> [a] -> [a]
18:24:02 <athan> fresheyeball: :v
18:26:05 <qmm> > find (=='b') "Hello I think you might be a lion."
18:26:07 <lambdabot>  Just 'b'
18:26:15 <qmm> huh, that worked?
18:26:18 <qmm> i get No instance for (Foldable t0) arising from a use of â€˜findâ€™
18:26:27 <qmm> i thought a list was foldable
18:27:23 <qmm> maybe it's my ghci conf file
18:27:46 <qmm> http://lpaste.net/1522607181067714560
18:28:15 <pavonia> What is the code and the complete error?
18:28:27 <qmm> that's it
18:31:08 <qmm> okay, i was able to get it working by disabling everything in the ghci file
18:31:24 <qmm> which of those flags might have done it i wonder
18:31:41 <qmm> oh well, until i need those flags set, guess i'll leave them commented out :)
18:33:56 <geekosaur> qmm, OverloadedStrings
18:34:08 <geekosaur> and the real error is it couldn't figure which IsString instance you wanted
18:34:50 <geekosaur> and therefoe couldn't figure out which Foldable instance to use
18:36:52 <geekosaur> (note that the e.g. ByteString version of Foldable's find still uses a Char -> Bool)
18:37:13 <geekosaur> well, ByteString.Char8
18:39:11 <qmm> geekosaur: oh, then it's possible to use Data.List.find to find a character in a string
18:39:45 <qmm> when -XOverloadedStrings
18:39:53 <geekosaur> with OverloadedStrings off, or with (:"Hello I think you might be a lion." :: String), yes
18:40:14 <geekosaur> otherwise I think you'd need HC.OldList which is where 7.10 hides the old non-Foldable version
18:40:29 <geekosaur> Data.List in 7.10 is really Data.ListLike-Foldable
18:41:00 <geekosaur> er, GHC.OldList
18:41:34 <geekosaur> almost nothing in 7.10's Data.List actually uses a list
18:42:56 <geekosaur> and this is a known screw case with 7.10's Foldable/Traversable changes
18:49:39 <Ygg> ugh sourceTree is so slow
18:52:26 <Lynn> Is there a commonly used "binary tree" library on Hackage?
18:52:48 <Lynn> Or does everyone just roll their own `data Tree = Leaf | ...`
19:07:18 <hunteriam> Guys where is the source code for `Monad m => Monad (StateT s m)`
19:07:22 <hunteriam> Its not available from https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html
19:10:40 <pavonia> hunteriam: It's in the transformers package
19:35:10 <Lokathor> how often should one use fail when you get bad inputs in a monadic context?
19:35:36 <Lokathor> (assuming that you're assuming that inputs are good often enough that you don't want to bother with Maybe being involved)
19:36:02 <monochrom> never.
19:36:03 <Lokathor> specifically, say you're rolling a random number, 1 through X, and they pass -2. Would returning some sort of sentinal value be sensible?
19:37:25 <monochrom> I might have misunderstood your scenerio
19:37:54 <roconnor> Lokathor: That is so bad, I'd use error in that context.
19:38:01 <tcs> Was there a language extension that would automatically put a newtype constructor around simple types?
19:38:06 <monochrom> use fail the same way you would write partial functions
19:38:28 <Lokathor> monochrom, randomR (low, high) returns a number greater than or equal to low, and less than or equal to high. For rolling dice, it'd always be 1 to X (x = sides of the die)
19:38:39 <tcs> e.g. newtype Foo = Foo Int; bar :: Foo -> a; baz = bar 20
19:38:52 <roconnor> I mostly use fail when I want to be flexible between using the Maybe Monad or the Either String Monad. ... does that still work?
19:39:28 <monochrom> yes, but mzero is more suitable
19:39:34 <geekosaur> it still works, for now. it's still a bad idea
19:39:46 <glguy> roconnor: but    fail "" :: Either String ()  is error, not a Left
19:39:52 <geekosaur> mzero is better. a future ghc will forbid fail unless you have a MonadZero context
19:40:07 <Lokathor> so if the user passes in, say, -2.. then they'll get some sort of number (actually it might cause an infinite loop), but it won't be in the agreed upon range
19:40:25 <roconnor> glguy: I guess I'm too old.
19:40:51 <geekosaur> also that, Either instance used to work that way IIRC (I also recall when lookup was monad-polymorphic and used fail) but got changed
19:41:12 <Lokathor> so my function ends up being, rollOne :: (Integral i, Random i, RandomGen g, MonadState g m) => i -> m i
19:41:18 <geekosaur> and that is one reason why relying on fail is a bad idea
19:41:19 <glguy> There was an overlapping   instance Monad (Either String) ?
19:41:53 <monochrom> to see the intention of fail, look at when the Haskell standard says that it will use fail: iff pattern matching fails due to inexhaustive patterns
19:41:58 <geekosaur> not directly overlapping, instead of Either String you had to use the Error newtype
19:42:10 <glguy> Oh, OK. I'm with you now :)
19:42:12 <monochrom> this is why I say that you use fail like you write partial functions
19:42:19 <geekosaur> one did fail = Left the other did fail = error
19:42:29 <glguy> Yeah, I still like that type from transformers
19:43:08 <Lokathor> monochrom, well, this is that sort of a case. The contract of the function is impossible to satisfy given the inputs
19:43:20 <geekosaur> and that is when you want to use error
19:45:03 <geekosaur> Lokathor, so here;s the conundrum of fail.
19:45:31 <geekosaur> they added fail so that list comprehensions, which were then monad comprehensions, could use it on a failing pattern match to filter things out.
19:45:54 <geekosaur> *then* they decied to downgrade monad comprehensions to list comprehensions, and translate them using filter instead of monad fail
19:46:00 <geekosaur> so monad fail became pointless
19:46:22 <monochrom> e.g., [ x+1 | Just x <- [Nothing, Nothing, Nothing again] ] = []
19:46:28 <Lokathor> doesn't the MonadFail or some other typeclass still capture the idea of "this might not work"?
19:46:44 <geekosaur> MonadFail was how it was done before what I just described
19:46:50 <Lokathor> ah
19:46:51 <geekosaur> MonadFail was removed and fail was added to monad
19:46:56 <geekosaur> *Monad
19:47:29 <geekosaur> specifically so that do notation and monad/list comprehensions didn't need to infer an extra MonadFail constraint only when needed
19:47:35 <geekosaur> (or require one for no reason at all)
19:47:46 <Lokathor> i thought i heard someone mention that fail shouldn't be part of monad, that it should be moved out (back out?) into a differnt class that's only for things that really should allow failing
19:47:57 <geekosaur> so fail is a bit of inane, if not insane, history
19:48:09 <geekosaur> right, that is the MonadZero proposal
19:48:14 <geekosaur> it will be in a future ghc release
19:48:47 <monochrom> for example, fail does not make sense for State (what could you do anyway?), but it makes sense for [] and Maybe
19:48:56 <Lokathor> well it's mostly a MonadState in my situation. It could just give 0 as a default value when there's bad inputs I suppose.
19:49:13 <geekosaur> basically undoing the fustercluck I just described but making the MonadZero explicit
19:50:03 <Lokathor> i do like the idea of explicit declarations within the types
19:50:13 <roconnor> Lokathor: I would suggest using error, or sneaking some sort of ErrorT into your stack.  Either the illegal value ought to never happen, or you should handle it.
19:50:23 <geekosaur> oh hm, looks like 8.1 does have MonadFail; maybe I got those reversed too
19:50:48 <roconnor> Lokathor: but if you are new to haskell, then using a default value is okay if it avoids stressing you out. :)
19:50:50 <Lokathor> roconnor, the intent i started with was that it would be a utility around RandomGen, not really part of any explicit stack
19:51:10 <geekosaur> the history is so nuts it's kinda hard to keep straight all the backtracking and self-contradiction >.>
19:51:15 <roconnor> Lokathor: if randomGen is violating a post condition, I'd use error.
19:51:16 <Lokathor> sounds like it
19:51:32 <roconnor> fail early and fail often.
19:51:34 <Lokathor> roconnor, actually, in this case it would be the caller violating a pre-condition
19:51:35 <roconnor> er
19:51:38 <monochrom> haha
19:51:39 <roconnor> error early and error often.
19:51:43 <Lokathor> damn ints! so many of them
19:52:33 <Lokathor> http://lpaste.net/149768
19:52:42 <roconnor> Make a newtype around an Int, and use a smart consturctor to validate the precondition.
19:52:57 <roconnor> well, unless that would be overengeneering your problem.
19:52:57 <geekosaur> anyway yes, if you have this kind of situation you don't want fail --- not to mention the earlier arguments, how do you use fail in a pure function facing that situation? --- you want error. if only so those cases are consistent instead of the monadic one possibly doing something unexpected because fail wasn't what you thought it was
19:53:02 <monochrom> yes, error is for "it shouldn't happen, pre- and post- conditions are met. if it still happens, I want a crash so I know the bug"
19:53:46 <monochrom> fail is for "it can happen, and there is a meaningful response like [] or Nothing"
19:54:54 <Lokathor> hmm, hmm hmmm hmmmmm
19:55:54 <monochrom> > do { Just x <- [Nothing, Just 1]; return (x+1) }
19:55:56 <lambdabot>  [2]
19:57:13 <monochrom> this has one item rather than two because pattern-matching Nothing against Just is an inexhaustive pattern match, and fail is called (part of the desugaring of do), which does short-circuiting [].
19:57:56 <roconnor> Lokathor: you could even do something like foo:: Integer -> Maybe (State Foo Bar) = if not precondition then Nothing else Just do ...
19:57:57 <monochrom> this code has a legit use case
19:58:20 <monochrom> but "post-condition says 1 to 6, but you get -2" is not one of them
19:58:48 <Lokathor> to be fair, pre-conditions were violated, so post-conditions don't need to be met when that's the case
20:10:11 <plazmonii> \clear
20:26:08 <Lokathor> http://lpaste.net/149769 the full module, in its complete (for now) form
21:40:42 <MarcelineVQ> What are the more popular packages people are aware of for generating c code using haskell? Generate-C, Ivory, Copilot / Atom?
21:51:38 <preyalone> Where's the button to actually upload to Hackage? The doc doesn't seem to offer the button anymore
21:54:35 * hackagebot HGL 3.2.2 - A simple graphics library based on X11 or Win32  https://hackage.haskell.org/package/HGL-3.2.2 (AlanHawkins)
21:59:22 <preyalone> ah, `cabal update dist/....tar.gz'
21:59:35 * hackagebot terntup 0.0.1 - a ternary library  https://hackage.haskell.org/package/terntup-0.0.1 (mcandre)
22:10:08 <Kaidelong> https://www.reddit.com/r/haskell/comments/40ekfq/how_to_tell_which_mvar_we_are/ this is a pretty dreadful showing, looking at Control.Exception, none of the exceptions carry data
22:10:34 <Kaidelong> is there any way this could be implemented, or is the static information needed just not possible to replicate at runtime?
22:11:54 <Kaidelong> the only argument I can really think of for doing it this way is that you are after lightweight exceptions, but I'm not aware of "exceptions as control flow" being a normal practice in Haskell
22:15:32 <Cale> Kaidelong: hmm
22:15:42 <ggVGc> Kaidelong: it shouldn't be a normal practice anywhere.. although unfortunately sometimes it is
22:15:50 <nut_> anyone knows to to make sublime text work with cabal sandbox ?
22:16:26 <Cale> nut_: Sublime text is a text editor, it shouldn't interact at all with your cabal sandbox as far as I'm aware
22:16:45 <Cale> Maybe I don't really understand what you're asking for :P
22:18:30 <Cale> The sandbox only affects which packages are available when you have cabal build the thing, it shouldn't interfere with how you edit your source code.
22:19:24 <nut_> Cale, ive installed packages inside the sandbox
22:19:31 <Cale> nut_: sure...
22:19:34 <nut_> when i build with sublime, it should find them
22:19:43 <nut_> i dont know how to configure it
22:19:49 <Cale> nut_: can you tell sublime which command to run to build your program?
22:20:03 <Cale> Usually I just use a terminal window to build
22:20:11 <Cale> and use my text editor to edit text
22:20:21 <nut_> i do that too, but Ctrl+b is much faster
22:20:53 <Cale> If you can set the command that it runs when you do that somehow, then you'll want to set it to cabal build or something along those lines.
22:22:02 <nut_> i will dig deeper in that direction
22:22:15 <nut_> im surprised that i cant find much with Bing
22:22:23 <nut_> find much information
22:22:57 <Cale> Try Google?
22:23:38 <Cale> http://docs.sublimetext.info/en/latest/reference/build_systems/basics.html
22:26:30 <nut_> thx
22:27:25 <Cale> Kaidelong: Dan's idea would work in any case where it would be particularly useful.
22:28:07 <Cale> Kaidelong: (i.e. just wrap the relevant MVar operations in a handler which catches and annotates the exception with whatever other information you want)
22:29:22 <Cale> Kaidelong: I have a hard time really visualising what a use-case for this would be... there's not a whole lot you can do with the knowledge, apart from realise that your program is buggy.
22:32:38 <jle`> wrapping the mvar operations makes more to me than tagging the mvars themselves
22:32:43 <jle`> *makes more sense
22:32:55 <jle`> it makes perfect sense...the problem isn't the mvar, but what you're doing with it :)
22:43:38 <Lokathor> MarcelineVQ, clealy you should want to generate java code and not C code with your haskell :>
22:44:24 <MarcelineVQ> it all makes sense now
22:44:45 <Lokathor> compile with fregec.jar and go to town :3c
23:23:48 <hunteriam> I really enjoyed Brian Mckenna's Idris videos, does anyone have any more cool similar videos?
23:41:57 <Kaidelong> ggVGc: languages that implement negation by failure
23:55:40 <junglebunnys> https://www.youtube.com/watch?v=Ajr_sOZO6wM
