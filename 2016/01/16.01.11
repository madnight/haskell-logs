00:07:41 * hackagebot hero-club-five-tenets 0.3.0.1 - Remember the five tenets of hero club  https://hackage.haskell.org/package/hero-club-five-tenets-0.3.0.1 (i_amd3)
00:07:41 * hackagebot true-name 0.1.0.0 - Template Haskell hack to violate another module's abstractions  https://hackage.haskell.org/package/true-name-0.1.0.0 (LiyangHu)
01:07:37 * hackagebot HUnit 1.3.1.0 - A unit testing framework for Haskell  https://hackage.haskell.org/package/HUnit-1.3.1.0 (SimonHengel)
01:21:39 <Fuco> sigh... I wish we could do "case 'monadic action' of ..." where it would extract it automatically
01:21:57 <Fuco> or >>= into case somehow without introducing million extra useless variables
01:22:23 <ahihi2> LambdaCase?
01:22:27 <Fuco> now you have to invent at least three names for one thing :D (first the monad, then the temp., binding and then binding in the case)
01:22:34 <Ralith> sounds like you want lambda case
01:22:43 <Fuco> that sounds scary
01:23:27 <liste> it's not
01:24:06 <liste> it's just a shorthand of \x -> case x of ...
01:24:11 <Fuco> oh, looks pretty good, but it's non-standard it seems
01:24:24 <Fuco> foo >>= \case { Just x -> ...} that is indeed something I'd like yea
01:24:48 <Ralith> you can't get much done these days without using some ghc extension or other
01:24:57 <Fuco> maybe even "case _ <- foo of ..." (or even without _)
01:24:58 <liste> very few people use bare haskell2010 nowadays
01:25:19 <liste> the extensions give just so much
01:25:43 <Fuco> I use some extensions but mostly not touching syntax, as tht can make the code unreadable for some
01:41:54 <wedens> I'm trying to use hspec with quickcheck and for some reason `prop "xxx" $ \(x :: Int) -> (x > 0) ==> True` fails
01:42:08 <wedens> and looks like the reason is ==>
01:48:09 <quchen> wedens: We'll need to see your code for that, otherwise the answer is "there's an error somewhere".
01:49:04 <wedens> quchen: well, code is almost exactly like `prop "xxx" $ \(x :: Int) -> (x > 0) ==> True`
01:50:05 <wedens> "Gave up after 0 tests"
01:52:10 <wedens> hm. if expression on the left of ==> is False, test fails O_o
01:55:43 <Saizan> the test is not considered failed but rather like it never happened
01:57:51 <wedens> it should behave like this
01:59:02 <wedens> what the hell. `\x -> x < 0 ==> True` works and `\x -> x > 256 ==> True` doesn't
02:01:16 <danza> can we use Quickcheck here with Lambdabot?
02:01:23 <MarcelineVQ> wedens: ==> is for setting constraints (implications) on properties, not for doing the test itself, related: http://stackoverflow.com/questions/27171979/how-can-i-constraint-quickcheck-parameters-e-g-only-use-non-negative-ints
02:01:28 <wedens> :t property
02:01:30 <lambdabot> Not in scope: â€˜propertyâ€™
02:01:58 <quchen> ?check \n -> take n [1..] == [1..n]
02:01:59 <Saizan> @check True
02:02:00 <lambdabot>  +++ OK, passed 100 tests.
02:02:01 <lambdabot>  +++ OK, passed 100 tests.
02:02:33 <danza> ?check \x -> x < 0
02:02:34 <wedens> MarcelineVQ: it is a constraint
02:02:35 <lambdabot>  *** Failed! Falsifiable (after 1 test):
02:02:35 <lambdabot>  0
02:03:35 <wedens> ?check \x -> x > 256 ==> x > 256
02:03:35 <lambdabot>  : -1: -1:Ambiguous infix expression
02:04:12 <wedens> ?check \x -> (x > 256) ==> (x > 256)
02:04:14 <lambdabot>  *** Gave up! Passed only 0 tests.
02:04:30 <danza> ?check (\x -> x > 256) ==> (x > 256)
02:04:32 <lambdabot>  Couldn't match expected type â€˜Integer -> Boolâ€™
02:04:32 <lambdabot>  with actual type â€˜Boolâ€™ The lambda expression â€˜\ x -> x > 256â€™ has one argum...
02:05:39 <phaazon> hi
02:06:01 <wedens> ?check \x -> (c < 0 || c > 256) ==> (c < 0 || c > 256)
02:06:02 <lambdabot>  +++ OK, passed 100 tests.
02:06:07 <wedens> why?
02:06:28 <danza> :t ==>
02:06:29 <lambdabot> parse error on input â€˜==>â€™
02:06:35 <danza> :t (==>)
02:06:36 <lambdabot> STestable prop => Bool -> prop -> Test.QuickCheck.Safe.SProperty
02:07:09 <wedens> c > 256 doesn't imply that it should be positive?
02:08:17 <wedens> ?check forAll (getNonNegative <$> arbitrary) $ \x -> (x > 256) ==> (x > 256)
02:08:19 <lambdabot>  *** Gave up! Passed only 0 tests.
02:08:41 <wedens> ?check forAll (getNonNegative <$> arbitrary) $ \x -> (x > 100) ==> (x > 100)
02:08:42 <danza> wedens, as far as i know, c > 256 just implies that it is greater than 256
02:08:43 <lambdabot>  *** Gave up! Passed only 0 tests.
02:09:05 <pavonia> wedens: Note that you used c instead of x in the above example
02:09:13 <pavonia> :t c
02:09:14 <lambdabot> Expr
02:09:26 <wedens> pavonia: oh, right
02:09:40 <wedens> ?check \x -> (x < 0 || x > 256) ==> (x < 0 || x > 256)
02:09:41 <lambdabot>  +++ OK, passed 100 tests.
02:10:18 <wedens> according to quickcheck \x -> (x > 256) ==> (x > 256) is false
02:11:03 <merijn> :t (==>)
02:11:04 <lambdabot> STestable prop => Bool -> prop -> Test.QuickCheck.Safe.SProperty
02:12:10 <pavonia> Isn't "p x ==> p x" a tautology?
02:14:23 <wedens> ?check \x -> (x > 256) ==> (x < 256)
02:14:25 <lambdabot>  *** Gave up! Passed only 0 tests.
02:15:00 <wedens> "Implication for properties: The resulting property holds if the first argument is False (in which case the test case is discarded), or if the given property holds."
02:15:08 <MarcelineVQ> generators start at small numbers -1,0,1 etc
02:16:26 <merijn> wedens: So that's right
02:16:26 <quchen> QC has a size setting that is used for generating things. I suspect Int is within the bounds of that size if generated, so numbers rarely exceed 100 (or never?).
02:16:41 <quchen> ?check \x -> (x > 50) ==> True
02:16:42 <Fuco> I don't get the idea behind quickcheck... why would I trust a computer generated list of test cases?
02:16:43 <lambdabot>  *** Gave up! Passed only 71 tests.
02:16:47 <Fuco> makes little sense to me
02:16:48 <merijn> wedens: It says that the second argument is True of the first is False
02:17:01 <merijn> wedens: But clearly "(x < 256)" is always either both True or both False
02:17:06 <quchen> Fuco: It catches many falsifying cases.
02:17:07 <mauke`> Fuco: what do you mean by "trust"?
02:17:11 <cocreature> Fuco: why would you trust people to manually come up with test cases
02:17:15 <merijn> wedens: So when the first argument is False the second is never True
02:17:17 <cocreature> obviously itâ€™s not a proof
02:17:18 <Jinxit> Fuco: why would I trust a human generated list of test cases?
02:17:42 <Fuco> because the human knows the purpose of the thing and can probably more accuratly predict the failure modes
02:17:48 <merijn> Fuco: It's generating test cases for properties you know are true. The computer is far better at finding boundary cases than you are
02:17:56 <wedens> merijn: and how does it influence this specific proerty?
02:18:19 <merijn> Fuco: You're supposed to predict those failures modes by specifying properties
02:18:23 <quchen> wedens: Try running with verboseCheck, it should give you the generated cases
02:18:27 <merijn> wedens: Dunno, look at the STestable class
02:19:17 <cocreature> Fuco: the advantage of computer generated test cases is that it can also catch things the human hasnâ€™t thought about
02:19:41 <abrahm> i have created a module in file with extension .hsc how can i import that module?
02:19:41 <Jinxit> in a class I took recently we got to run our tests on other groups' code. it was pretty enlightening to see them fail on 21 of our 49 tests
02:19:46 <Jinxit> point is, humans are dumdums
02:19:56 <merijn> Jinxit: Word
02:19:59 <cocreature> also I wouldnâ€™t say that quickcheck replaces manual unit tests
02:20:05 <cocreature> use both
02:20:16 <merijn> Whenever people say "I'm not smart enough to write Haskell", I say "I'm too dumb to write anything else" :p
02:20:23 <merijn> I disagree, I find unit tests overrated
02:20:31 <Jinxit> I like that one
02:20:34 <Jinxit> I'll steal it
02:20:50 <merijn> Depends on the software you write of course, but I find integration tests much more useful
02:21:09 <Jinxit> how do haskellers usually handle finite state machines btw?
02:21:10 <mauke`> abrahm: import That.Module
02:21:27 <Jinxit> I'm in need of one (in another language) and I might as well try to find some inspiration
02:21:46 <cocreature> merijn: yeah I agree there, I just always use unit tests in a wrong context (I should stop doing that)
02:21:49 <merijn> Jinxit: goto, lots of goto :D
02:21:55 <abrahm> no thats not working it states: module not found error~~
02:22:04 <Jinxit> :(
02:22:15 <merijn> abrahm: GHC doesn't handle .hsc files, you need to generate a .hs file from them
02:22:23 <merijn> Although cabal should do that for you if you use cabal
02:22:25 <Fuco> Sometimes unit tests is all you can do, and sometimes they are impossible. So I guess you use whatever you can
02:22:28 <mauke`> abrahm: did you compile it?
02:22:41 <abrahm> how to compile .hsc file :(
02:22:59 <Jinxit> if unit tests are impossible your code is incorrectly structured
02:23:01 <Fuco> So with quickcheck I basically specify invariants right?  Why doens't it do a complete proof then :D
02:23:09 <abrahm> and is there any way to convert .hsc file to .hs
02:23:17 <Fuco> Jinxit: well that is a conlcusion which is obvious...
02:23:24 <mauke`> abrahm: where did you get a .hsc file from?
02:23:28 <mauke`> and why
02:23:29 <Fuco> Jinxit: say, have you ever worked on a 30 year old legacy bank system? :D
02:23:42 <Fuco> (written in perl)
02:23:43 <Jinxit> guess why I'm staying in academia?
02:24:06 <abrahm> i downloaded the curses.hsc file for UI 
02:24:23 <Fuco> back in the good old days people didn't care, if it did "something" it was already better than the rest
02:24:39 <merijn> Jinxit: Oh yeah? How do you unit test a concurrent streaming server?
02:24:40 <wedens> ?check forAll (arbitrary `suchThat` (> 256)) $ \x -> (x > 256)
02:24:42 <lambdabot>  +++ OK, passed 100 tests.
02:25:04 <abrahm> i am learning to program a game hetris (just like tetris) so for UI i downloaded the .hsc file
02:25:51 <mauke`> abrahm: why
02:26:06 <mauke`> downloading random files from a package is pointless
02:26:22 <abrahm> to use C libraries alongwith haskell!
02:26:30 <mauke`> wat
02:27:10 <abrahm> mauke: kind of interface to C code
02:27:17 <mauke`> ???
02:27:39 <Xandaros> alternatively, just use a package that already has the bindings you need. Like ncurses in this case (Though I don't think it's a great idea)
02:28:16 <Xandaros> Using raw bindings is unnecessarily complicated
02:29:47 <Jinxit> merijn: point taken, concurrency is a bitch
02:29:56 <abrahm> sorry i must be doing or understanding wrong :(
02:30:29 <abrahm> can u suggest how to use User interface in haskell
02:30:31 <merijn> Jinxit: Anything involving concurrency, lots of networking, disk, etc. is hard to unit test and mocking is a silly habit, imo
02:31:01 <Jinxit> in an OOP world mocking is a fine way to test units
02:31:10 <Jinxit> doesn't mean you don't need integration and system tests
02:31:52 <merijn> abrahm: If you want to write terminal UIs, look at brick: https://hackage.haskell.org/package/brick-0.2.1
02:42:10 <parsnip> argh! `Could not find module â€˜Hakyllâ€™`
02:48:28 <Ab654> how can i download UI.HSCurses.Curses ?
02:51:11 <pavonia> Ab654: Install the hcurses package (which this module belongs to)
02:51:33 <bergmark> @google UI.HSCurses.Curses hackage
02:51:34 <lambdabot> https://hackage.haskell.org/package/hscurses/docs/UI-HSCurses-Curses.html
02:52:22 <Ab654> pavonia: just did hope it works :)
02:52:49 <pavonia> Oh, *hscurses, sorry
03:04:03 <qwert> Input'.hs:5:8:     Could not find module â€˜UI.HSCurses.Cursesâ€™     Use -v to see a list of the files searched for.
03:04:10 <qwert> how to solve this?
03:12:40 * hackagebot Vulkan 0.1.0.0 - A binding for the Vulkan API  https://hackage.haskell.org/package/Vulkan-0.1.0.0 (SvenPanne)
03:13:20 <wedens> can I specify number range in attoparsec?
03:14:43 <jnes> qwert: did you try installing it? :p
03:15:35 <parsnip> hmm, so installed hakyll, with `stack install hakyll`, but i can't seem to get `ghc --make site.hs` to work. it keeps looking to import Hakyll, but i'm not sure what to tell it. 
03:16:21 <quchen> parsnip: When you install libs with Stack, you have to use Stack to use them.
03:16:38 <parsnip> however, if i do `stack ghci`, and then `import Hakyll` it works...
03:16:45 <quchen> parsnip: One way is to use "stack ghc ghc"
03:17:04 <quchen> parsnip: GHC isn't aware of Stack's package DB at all on its own.
03:17:20 <quchen> Try "stack ghc site.hs".
03:17:52 <parsnip> quchen: thank you! 
03:18:11 <parsnip> maybe i should push for that to be added to the packages tutorials? 
03:19:06 <quchen> parsnip: Maybe. But I think Stack's intended use is mostly to be used via a .cabal file.
03:20:52 <parsnip> so not `stack ghc site.hs`? here is there current tutorial: https://jaspervdj.be/hakyll/tutorials/01-installation.html
03:35:07 <quchen> parsnip: Oh, you're talking about Hakyll's tutorial, not Stack's
03:35:19 <quchen> I guess for Hackyll, mentioning Stack would be a very good idea.
03:45:33 <wedens> how can I run integration tests separately from other tests?
03:46:10 <tdammers> depends on the test framework?
03:46:46 <tdammers> I believe the usual approach is to adopt a suitable naming convention and then use the test framework's filtering feature to run just the tests you want
03:46:47 <wedens> tdammers: I use hspec.
03:46:52 <quchen> You can specify multiple testsuites in a single .cabal file, wedens.
03:46:58 <tdammers> ^ or that.
03:47:42 * hackagebot codex 0.4.0.8 - A ctags file generator for cabal project dependencies.  https://hackage.haskell.org/package/codex-0.4.0.8 (aloiscochard)
03:50:21 <wedens> quchen: I'll try it. thanks
03:51:31 <quchen> wedens: Here's an example .cabal that does it: http://hackage.haskell.org/package/binary-typed-1.0/binary-typed.cabal
03:54:31 <wedens> quchen: nice. thanks
04:00:53 <mpickering> what is the stack equivalent of "cabal exec"
04:00:58 <quchen> stack exec?
04:03:21 <quchen> What's a cool line I can enter into a fresh GHCi prompt to show off? prime generation is too long, fibo=zipWith is too convoluted if you don't know Haskell, â€¦
04:03:37 <quchen> Hello World is easy, but also not very interesting.
04:06:00 <liste> > liftA2 (/) sum genericLength $Â [1, 2, 50, 4, 17, 25, 23] -- maybe something APLish?
04:06:02 <lambdabot>  17.428571428571427
04:07:04 <jdnavarro> anyone having issues with `cabal update` in arch?
04:07:23 <zoku> i haven't been jdnavarro 
04:07:24 <quchen> liste: Way too complicated, I'd like it to be somewhat intuitive :-|
04:07:35 <quchen> liste: A nice list comprehension would be nice.
04:07:58 <jdnavarro> it just stopped working but can't figure it out why
04:08:01 <quchen> Or maybe something that shows off composition. sum of even squares up to N maybe.
04:08:31 <jdnavarro> error is `cabal: does not exist`
04:09:05 <frerich> quchen: Does your fresh ghci has 'Data.List' imported?
04:09:14 <quchen> Nope, just Prelude
04:09:24 <quchen> Fresh as in completely fresh.
04:09:33 <quchen> Install Stack, run stack repl, that's it
04:10:33 <frerich> Hm, you're missing out on a lot of stuff... let me think... I usually show a nice list comprehension (but it involves 'tails' frm Data.List) or stuff with 'maximumBy' or 'comparing' or so (because it reads very nicely)
04:11:30 <quchen> frerich: Hmmm. I guess an import of Data.List isn't out of the question if the example is good enough.
04:12:01 <quchen> frerich: I want to write a "hey if you're eager to try it out before the workshop here's something cool" and then suggest 1-3 GHCi lines.
04:12:21 <joco42> any idea on this issue ? https://github.com/nh2/call-haskell-from-anything/issues/5 
04:12:32 <joco42> i'd love to call haskell from python... 
04:12:33 <frerich> quchen: For that, I often use '[b | a:b:c:_ <- tails [1,6,7,3,4,4,3,7,8], a <= b && b <= c]' -- it compues local maxima. It shows a bit of Haskell, but not too much, and it's nice to explain.
04:12:37 <joco42> with latest ghc...
04:12:41 <joco42> 7.10.2
04:13:19 <frerich> quchen: Another thing which I sometimes show (but it's much ahrder to explain) is sorting by multiple criteria, e.g. 'sortBy (comparing head <> comparing length)'
04:13:25 * frerich afk for lunch
04:15:20 <jle`> > let powsOf2 = 1 : map (*2) powsOf2 in powsOf2
04:15:22 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
04:16:50 <jle`> i suppose you can say that `fix error` fixes your errors
04:17:32 <jle`> > let countFrom n = n : countFrom (n + 1) in countFrom 0   -- i'm drawing blanks here and i should head to bed anyways v.v
04:17:33 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
04:21:05 <lyxia> fix error is a funny one
04:21:19 <liste> > fix error
04:21:22 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
04:24:56 <quchen> jle`: Once you have fix error, you can prove anything!
04:25:21 <quchen> Eh wait, it's a [Char], not a
04:25:24 <quchen> Nevermind.
04:26:12 <liste> :t fix ids
04:26:13 <lambdabot>     Not in scope: â€˜idsâ€™
04:26:13 <lambdabot>     Perhaps you meant one of these:
04:26:13 <lambdabot>       â€˜idâ€™ (imported from Data.Function),
04:26:13 <liste> :t fix id
04:26:15 <lambdabot> a
04:27:30 <jdnavarro> I found out there is some problem with my DNS settings that's only showing up when using cabal
04:38:45 <merijn> If I have two public function that are specialisations of a more general internal function, what'd be a good suffix/prefix to indicate this on the internal function?
04:39:24 <Gurkenglas> Why should the general function not be public?
04:39:28 <tdammers> merijn: been struggling with this question for years myself
04:39:40 <tdammers> Gurkenglas: being overly general, maybe?
04:39:42 <merijn> Gurkenglas: Because it's dangerous
04:39:54 <merijn> Gurkenglas: I only wrote it two avoid writing the same code twice
04:40:11 <Gurkenglas> unsafe for the prefix, then
04:42:04 <ggVGc> ^
04:42:16 <ggVGc> good reasoning there
04:52:44 * hackagebot Bookshelf 0.6 - A simple document organizer with some wiki functionality  https://hackage.haskell.org/package/Bookshelf-0.6 (EmilAxelsson)
05:01:40 <rockfordal> Hi. Is there any solution/blog/server with support for running a simple API with PostgreSQL + JSONB?
05:03:03 <merijn> Is there a "Int -> Text" function that doesn't have me go through String first?
05:04:21 <sbrg> rockfordal: I don't know much about JSONB, but scotty and similar frameworks make it incredibly easy to set up a simple http server
05:04:53 <rockfordal> do you mean with Persistent library then?
05:05:21 <rockfordal> or postgresql-simple?
05:05:42 <liste> merijn maybe go through Builder?
05:06:28 <merijn> liste: I only build very short ones, so I'm not sure that'd be beneficial?
05:06:30 <liste> or Data.Text.Read.decimal ?
05:06:58 <merijn> liste: That's the opposite of what I want?
05:07:03 <liste> oh, sorry
05:07:35 <merijn> I basically want "T.pack (show 5075)" but without the inefficiency of going through String
05:09:51 <frerich> merijn: 'decimal' in Data.Text.Read might be what you want.
05:10:26 <merijn> frerich: That was suggested 5s up and is, like I said, the opposite of what I want?
05:14:08 <frerich> merijn: Ah, indeed.
05:16:17 <latk> Any news on when overloaded record fields might make it in to ghc?
05:17:18 <merijn> latk: GHC 8.0 or 8.2?
05:17:50 <latk> merijn: Cool, thanks.
05:21:46 <sbrg> rockfordal: I have been using persistent a bit recently and I've found it to be very pleasant to work with
05:21:57 <sbrg> certainly infinitely more pleasant than writing sql by hand
05:22:29 <sbrg> I switched from sqlite to postgres as well, and switching backends was pretty easy, except for some type-wrangling.
05:24:38 <tdammers> my database schemas tend to be thoroughly relational, persistent is not a very good fit for that
05:25:47 <bergmark> opaleye is the most flexible high-level database library
05:26:26 <tdammers> I have a little TH thing that allows me to write parametrized SQL queries as quasi-quote literals
05:26:44 <tdammers> it's not backend-agnostic, but that allows it to be very simple and straightforward to use
05:28:08 <tdammers> items <- runQuery [sql|SELECT username, email FROM users WHERE user_group = :group|] [("group", toSqlValue userGroup)]
05:33:04 <dredozubov> Is there something solid and ready to make auth simpler? I want to move work project auth to haskell and i need twitter/facebook/own options.
05:34:06 <dredozubov> bergmark: do you have an experience with it? I was overwhelmed by initial complexity, seemed like a little bit too much for a db library.
05:41:53 <funrep> OT: is there any channel on freenode for math?
05:42:03 <merijn> funrep: Depends on the kinda math
05:42:35 <merijn> funrep: Type theory, category theory and maybe a little logic gets discussed here and #haskell-blah a lot, everything else you could try ##math if you keep your expectations low :p
05:42:36 <funrep> im reading How To Prove It
05:42:54 <Pot__>  my ghc compiler doesnt have the package hscurses . how can i add this package to my compiler ??
05:43:33 <funrep> just done high school math but want to get my hands dirty, How to prove it was suggested on Reinh's blog 
05:44:26 <tdammers> Pot__: you can possibly install it through your OS'es package manager, but the way most people do this is with Cabal
05:44:40 <Pot__> cabal ??
05:44:45 <Pot__> hohow?
05:45:02 <Pot__> cabal install hscurses...
05:45:03 <Pot__> ?
05:45:17 <tdammers> https://www.haskell.org/cabal/
05:45:37 <tdammers> so, in a nutshell, yes, cabal install hscurses
05:45:40 <tdammers> *however*
05:45:59 <tdammers> your life will be nicer if you use cabal sandboxes
05:46:14 <Pot__> ohh yeaa thanks :D
05:46:20 <tdammers> and then there's stack, a newer tool that wraps around cabal and fixes many of the common pain points
05:46:35 <tdammers> http://docs.haskellstack.org/en/stable/README.html
05:48:18 * hackagebot hmk 0.9.7.4 - A make alternative based on Plan9's mk.  https://hackage.haskell.org/package/hmk-0.9.7.4 (MathieuBoespflug)
05:53:11 <dgpratt> finishing up this codensity exercise and I came up with a definition that typechecks, but I don't think it's right
05:53:12 <dgpratt> http://lpaste.net/3804585981890265088
05:53:18 * hackagebot mime-directory 0.5.2 - A library for parsing/printing the text/directory mime type.  https://hackage.haskell.org/package/mime-directory-0.5.2 (MathieuBoespflug)
05:53:58 <dgpratt> specifically, the definition for "wrap" for "Functor f => FreeLike f (Free f)"
05:54:03 <dgpratt> oh
05:54:06 <dgpratt> not that  one
05:54:21 <dgpratt> the one for "FreeLike f m => FreeLike f (C m)"
05:54:28 <dgpratt> (the last one)
05:54:39 <dgpratt> can someone confirm that it's not that simple?
05:54:54 <dgpratt> oh, duh
05:55:06 <deni> why would a haskell program work just fine when invoked manually from a bash prompt but fail when run with upstart? (segmentation fault)
05:55:08 <dgpratt> that's bottom, isn't it?
05:55:31 <dgpratt> nvm, I'll go away now
05:57:05 <mauke`> deni: I'd try strace first
05:58:18 * hackagebot bustle 0.5.3 - Draw sequence diagrams of D-Bus traffic  https://hackage.haskell.org/package/bustle-0.5.3 (WillThompson)
06:02:54 <Wizek> Can `cabal build`/`cabal run` be used in conjunction with ghcjs? I've added `compiler: ghcjs` to the *.cabal file and yet I don't find any ghcjs output in ./dist/
06:03:29 <tdammers> Wizek: in my experience, switching from plain cabal to stack is the least painful way
06:04:57 <Pot__> how to update my ghc compiler to ghc-7.10 ??
06:05:07 <Pot__> can i use cabal for that?
06:05:40 <MasseR> stack is a relatively easy way
06:05:48 <MasseR> And if only possible you should use it anywa
06:06:09 <Wizek> tdammers, Does stack work well with ghcjs? Also, then won't I be restricted to some subset of packages?
06:06:26 <MasseR> Wizek: don't know about ghcjs, but you can use any packages you want
06:06:33 <ggVGc> so, if I have a stack project and want to use a library only available as a cabal package, what do I do?
06:06:37 <MasseR> There is an external-section in stack.yaml
06:07:01 <MasseR> Mark your wanted cabal package there and stack fetches it from hackage
06:07:11 <dgpratt> Wizek, I was able to do a test project with stack/ghcjs
06:07:45 <kadoban> ggVGc: I don't think you have to do anything special in that case. If it's not in the resolver, you need to add it to extra-deps in stack.yaml
06:09:19 <Wizek> dgpratt, What did you need to do to set up that test project with stack + ghcjs?
06:09:25 <deni> mauke`: yeah but why would it work from the command line and not from upstart? I mean it's just a simple program that watches for inotify events and executes a command when a file has changed... (and prints stuff to stdout)
06:09:47 <merijn> Is there a strict hGetContents somewhere?
06:10:09 <quchen> merijn: In Pipes? :-Ã¾
06:10:37 <dgpratt> Wizek, followed this procedure http://docs.haskellstack.org/en/stable/ghcjs.html using "improved base"
06:13:17 <dgpratt> I used "improved base" because not doing so failed on my Windows machine
06:13:18 * hackagebot mfsolve 0.3.1.2 - Equation solver and calculator à la metafont  https://hackage.haskell.org/package/mfsolve-0.3.1.2 (KristofBastiaensen)
06:15:45 <merijn> quchen: Yeah, but I was hoping to hack something together quickly instead of doing it "properly" :\
06:16:03 <merijn> quchen: I could use strict Text, but half the base APIs want String, so that's a pain too
06:16:40 <quchen> merijn: I wouldn't say pipes is very heavyweight to use (quite the opposite in fact), but it's more than "adding a ' character", yeah
06:16:40 <Gurkenglas> deepseq on the string?
06:17:13 <tdammers> Wizek: yes, it works well, and no, you can add packages manually that aren't in stackage, but you'll have to add them to stack.yaml yoursel
06:17:41 <tdammers> Wizek: one of the killer features is how smoothly stack manages GHC versions for you
06:25:00 <Pot__> Setup: You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.22.4.0, now Cabal-1.22.6.0). Additionally the compiler is different (was ghc-7.10, now ghc-7.6) which is probably the cause of the problem.
06:25:28 <Pot__> this is while i run sudo runhasell Setup install 
06:25:50 <Pot__> even though i have ghc-version 7.10.1
06:25:57 <Pot__> how to solve this?
06:28:00 <Wizek> dgpratt, tdammers So, I have stack 0.1.1.0 and I have done a stack new which generated me a new-template project. I've added the ghcjs "improved base" to stack.yaml, and when I try to `stack build` it seems ghc is being used instead of ghcjs
06:28:27 <adamCS> Wizek: you need a newer version of stack
06:28:43 <dgpratt> Wizek, I don't think the template sets the compiler field correctly in the .yaml file
06:29:15 <adamCS> Wizek: >= 0.1.8, I think
06:30:38 <Wizek> adamCS, http://docs.haskellstack.org/en/stable/install_and_upgrade.html I've followed the instructions here for Ubuntu 14.04 hoping that would upgrade stack, but the version seems to be the same
06:31:24 <kadoban> Wizek: Try 'which stack' and see where the binary you're running is.
06:31:53 <Wizek> yeah, good point, seems to be shadowed -.-'
06:37:52 <deni> mauke`: I don't see anything unusual here: http://dpaste.com/1W9TT1P
06:38:06 <deni> but I'm not really sure how to read strace output so i might be missing something important
06:39:51 <deni> mauke`: it cut off there: http://dpaste.com/108940N
06:40:49 <Pot__> sudo runhaskell Setup install Setup: You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.22.4.0, now Cabal-1.22.6.0). Additionally the compiler is different (was ghc-7.10, now ghc-7.6) which is probably the cause of the problem.
06:41:02 <Pot__> why am i getting such error while installing package using cabal
06:44:51 <byorgey> Pot__: you probably shouldn't use 'sudo', though I don't know if that's what is causing the problem.
06:45:05 <byorgey> Pot__: also, there is no need to manually execute 'runhaskell Setup', cabal does that for you
06:45:07 <byorgey> just 'cabal install'
06:48:00 <andromeda-galaxy> luite (or anyone else): is there a good writeup of the state of Cloud Haskell with ghcjs anywhere?
06:50:07 <andromeda-galaxy> Luite mentioned that it wasn't ready during a talk last year, but is that still the case?
06:54:58 <Pot__> is there any way installing any package without using cabal?
06:55:53 <mpickering> Yes but why? 
06:56:40 <Pot__> ohh i m getting error like
06:56:42 <Pot__> sudo runhaskell Setup install Setup: You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.22.4.0, now Cabal-1.22.6.0). Additionally the compiler is different (was ghc-7.10, now ghc-7.6) which is probably the cause of the problem.
06:56:52 <Pot__> while using cabal
06:57:17 <mpickering> Did you read what  byorgy saod? 
06:57:30 <Pot__> what?
06:57:31 <dcoutts> Pot__: that's not you using cabal, that's you using the Setup.hs interface manually
06:57:49 <Pot__> ohh!!
06:58:05 <Pot__> but i want to suppose install hscurses package 
06:58:18 <Pot__> how can i install that?
06:58:26 <Pot__> using cabal ?
06:58:34 <dcoutts> cabal install hscurses
06:59:29 <Pot__> dcoutts: how can i install any package using cabal
07:00:37 <Pot__> dcoutts: got it hehe!!
07:00:45 <Pot__> its just cabal install package name
07:01:00 <merijn> Although I would argue you don't want to use hscurses or anything ncurses
07:01:12 <merijn> "brick" is a far nicer, higher level library for things like that
07:01:52 <Pot__> heyy
07:02:04 <Pot__> package installing using cabal gives error like
07:02:04 <merijn> @hackage brick
07:02:04 <lambdabot> http://hackage.haskell.org/package/brick
07:02:06 <Pot__>  cabal install foo
07:02:17 <Pot__> transformers-0.5.0.0 failed during the final install step. The exception was: ExitFailure 1
07:05:58 <sm> brick++
07:07:36 <dcoutts> Pot__: if you successfully installed anything earlier with sudo runhaskell, then you've likely created lots of files in your homedir owned by root. That's going to cause problems.
07:09:46 <merijn> hmmm, no fromRight function?
07:10:02 <merijn> Damn haskell and making be do safe things!
07:10:29 <Pot__> i finally installedthe package hscurses required
07:10:32 <geekosaur> unsafeCeerce# :p
07:10:34 <geekosaur> ...
07:10:45 <merijn> geekosaur: That doesn't work for fromRight
07:10:47 <Pot__> but now when i type import UI.HSCurses.Curses
07:10:49 <merijn> That'd just segfault
07:10:54 * geekosaur typed that 3 times and still got it wrong x.x
07:10:54 <Pot__> it shows error 
07:11:05 <Pot__> no modulo found!
07:18:21 <csd_> is there any way to do type-based dispatch in Haskell? I know that you can do something similar with classes, but I'm thinking more like what if I wanted to extend `++` to my custom type. That doesn't seem possible AFAICT
07:18:52 <MasseR> csd_: type classes?
07:18:52 <mnoonan> that's pretty much the problem that typelcasses are meant to solve
07:19:28 <csd_> but since ++ is already defined, i don't think type classes would let you extend it, no?
07:20:07 <bernalex> ++ is a regular TLD [a] -> [a] -> [a], how would you apply that to anything that's not [a]? that doesn't make sense.
07:20:13 <Pot__> i just installed hscurses .. but while import UI.HSCurses.Curses it gives error "could not find the module"!!! :( :(
07:20:27 <bernalex> you could OTOH make your datatype a monoid and implement <> for it. or whatever.
07:20:29 <mnoonan> I wonder if you could hide (++) in your prelude import and then make your typeclass..
07:20:35 <mnoonan> ..not that I'm saying that would be a good idea :)
07:20:42 <bam365> csd_: the general case for ++ is Monoid's mappend
07:20:58 <csd_> bernalex: that's what i'm saying. it would be nice if i could add a type check rule before the existing sig is evaluated to let me do my other type based dispatch
07:21:14 <csd_> i know this isnt in the core language but i was wondering whether an extension existed or somethign
07:21:46 <bernalex> csd_: that seems very silly rather than just using <>.
07:22:24 <bernalex> it sounds like saying "instead of implementing collision detection via a typeclass I want to just use the filter function and type-based dispatch to make it do something else", which I don't understand the point of.
07:22:51 <csd_> i previously was writing clojure :D
07:23:15 <sm> assuming the default console IO buffering, if you putStr X >> hFlush stdout, and X ends in a newline, is the hFlush completely redundant ?
07:23:21 * hackagebot airship 0.4.3.0 - A Webmachine-inspired HTTP library  https://hackage.haskell.org/package/airship-0.4.3.0 (reiddraper)
07:23:38 <csd_> i get what you're saying about mappend but that really only takes care of this specific example
07:24:04 <merijn> csd_: The point is that you can hide/redefine functions/operators anyway, so it's not a big problem
07:24:12 <bam365> csd_: well, the general idea is to use typeclasses
07:28:13 <csd_> so could i do something like, rename ++ to List++, define typeclass oncatable, and then make [] and instance of Concatable with ++ = List++, or would the solution be more involved than that?
07:28:50 <merijn> Is there a library that has Text versions of System.Process/System.IO/System.Directory?
07:29:05 <quchen> There's already a class for abstracting over (++), it's Monoid, csd_.
07:29:23 <csd_> quchen: I'm just using it as an example, I don't care specifically about ++.
07:29:29 <quchen> Oh.
07:29:32 <quchen> Sorry then.
07:29:40 <csd_> np :)
07:33:14 <statusfailed> csd_: You want to make the function (++) polymorphic (specifically the name (++))?
07:34:33 <statusfailed> csd_: oh sorry, I missed the original question
07:36:20 <statusfailed> csd_: Can you just `import Prelude hiding ((++)); import qualified Prelude as P`, then declare `class Concatable a where (++) :: a -> a -> a` and `instance Concatable [a] where (++) = Prelude.(++)` ?
07:36:31 <statusfailed> Or have I misunderstood the problem
07:36:53 <mauke`> (Prelude.++)
07:36:58 <fsvehla> join #akka
07:37:05 <statusfailed> ^ thanks
07:43:22 <jgoux> Hello
07:43:38 <csd_> statusfailed: yeah that makes sense. again, i wasn't interested in (++) so much as the general principle. thanks
07:43:54 <richardf> is this the right place for people who have questions about using Haskell
07:44:00 <jgoux> Which web framework would you recommand for a beginner with Haskell coming from node.js (expressjs) ?
07:44:01 <richardf> is this the right place to ask I should say
07:44:07 <tdammers> richardf: yes
07:45:08 <richardf> great, I was wondering if it's possible to make a data type that contains an STRef or STArray
07:45:31 <bergmark> jgoux: scotty, perhaps
07:45:53 <jgoux> bergmark: ok, I saw scotty and it's true that it seemed familiar ^^
07:46:04 <mauke`> richardf: Either STRef STArray
07:46:16 <mauke`> no, that doesn't work
07:46:22 <mauke`> kind error
07:46:43 <richardf> haha sorry I just realized I phrased that quite poorly
07:46:49 <richardf> I actually want a data type that contains both
07:47:09 <quchen> mauke`: Would be nice to have though!
07:47:33 <richardf> or maybe there's a better way to solve my problem
07:47:36 <mauke`> (STRef, STArray)
07:47:40 <mauke`> (still a kind error)
07:47:54 <richardf> I'm trying to generate a trie given a list of strings
07:51:37 <nshepperd_> it's probably best to do that without ST
07:51:53 <richardf> Hm yes it seems so
07:52:10 <richardf> is it possible to do it with mutations though?
07:52:16 <richardf> maybe IOArray and unsafePerformIO?
07:52:21 <richardf> since I know that I'm not actually doing any IO
07:52:25 <mauke`> never unsafePerformIO
07:52:35 <tdammers> despite the name, IO does a lot more than I/O
07:52:37 <mauke`> what are you going to use the array for?
07:52:37 <merijn> @quote not.a.bug
07:52:37 <lambdabot> cdsmith says: Yeah, that's weird... but it's documented, so it's not a bug. :)
07:52:40 <merijn> @quote not.a.bug
07:52:41 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
07:52:44 <merijn> That's the one
07:53:29 <richardf> I'm just using the array to reach the node's children
07:53:45 <nshepperd_> you can use STArray, though I don't see why you'd want to
07:54:01 <richardf> so basically I have each node as containing an Array Char Node and Bool
07:54:16 <mauke`> how do you embiggen the array?
07:54:30 <richardf> embiggen?
07:54:36 <tdammers> grow
07:54:41 <mauke`> it's a perfectly cromulent word
07:54:42 <tdammers> "make bigger"
07:55:09 <richardf> I was planning on iterating through the list of Strings
07:55:28 <richardf> so given a string and the node you are at, follow the children until the string is empty
07:55:35 <richardf> and when it's empty set the Bool value to True to indicate it's a word
07:55:39 <tdammers> rethink from the other side
07:55:53 <mauke`> what if you run out of nodes?
07:56:11 <tdammers> let's assume you know how to insert a string s into the sub-tree c
07:56:28 <tdammers> with this, how do you insert (x:s) into c's parent?
07:56:45 <tdammers> and also, how do you insert the empty string
07:57:05 <tdammers> and then, recursion.
07:57:17 <richardf> mauke`: I was just going to make a new node if we run out. I'm given the list of strings beforehand
07:57:30 <mauke`> richardf: how?
07:58:02 <mauke`> richardf: or rather, how do you attach the new node to your tree?
07:58:06 <nshepperd_> a mutable trie there would be something like data Node s = Node (STArray s Char (Maybe Node)) (STRef Bool)
07:58:17 <nshepperd_> assuming your alphabet is known
07:58:43 <nshepperd_> data Node s = Node (STArray s Char (Maybe Node)) (STRef s Bool)
07:58:44 <mauke`> what, with a full array in each node?
07:59:01 <mauke`> > maxBound :: Char
07:59:03 <lambdabot>  '\1114111'
07:59:18 <merijn> > length [minBound :: Char ..maxBound]
07:59:20 <lambdabot>  1114112
07:59:22 <richardf> tdammers: Well, that's similar to what I was doing, but I wanted to do it in a way I wouldn't have to copy the entire array every time I wanted to make a new node
07:59:41 <richardf> mauke`: in this problem I know that the chars are only going to in bounds ['a','z']
08:00:15 <mauke`> data Node = Node Bool (Map Char Node)
08:00:39 <richardf> nshepperd_: that's what I did but the issue is when I try to read from the arrays I get an error because s is bound 
08:01:14 <mauke`> richardf: how many runST are in your program?
08:01:31 <richardf> mauke`: yes I figured a Map could solve this problem and while it doesn't really matter, I was just wondering if it's possible to do it without the log(n) factor
08:01:49 <richardf> mauke`: one and one runSTArray
08:01:54 <richardf> mauke`: is that why?
08:01:59 <nshepperd_> richardf: ST monad data structures are temporary. the state token s exists to keep track of where they live and prevent them from escaping a runST
08:02:25 <m1dnight_> How can I view the hlint message in emacs? It has a squiggly line under it but no information.
08:02:34 <m1dnight_> s/it/a faulty expression?
08:03:02 <nshepperd_> richardf: what you must do is convert the mutable 'Node s' to an immutable format such as mauke`'s Node at the end of your runST computation
08:03:19 <mauke`> nshepperd_: or alternatively do all your querying in the same runST
08:03:29 <nshepperd_> or that yeah
08:03:45 <richardf> Hmm.. okay let me try
08:03:50 <richardf> thanks for the help everyone
08:03:53 <richardf> much appreciated
08:04:42 <richardf> Is this okay though? data STNode s = STNode (STArray s Char (STNode s)) (STRef s Bool) | STEmpty      
08:06:29 <dramforever> Perhaps STEmpty (STRef s Bool) if you want to allow the empty string. 
08:06:46 <nshepperd_> I would use (Maybe (STNode s)) for the children rather than having an STEmpty constructor
08:06:50 <dramforever> Oh sorry no no no
08:07:12 <richardf> dramforever: Well, for the empty string I was just going to have the array with all Empty
08:07:34 <nshepperd_> since the root should presumably never be STEmpty, this gives you a little more type safety
08:07:51 <richardf> nshepperd_: Ah good idea
08:07:54 <dramforever> Yeah just ignore that... I didn't really read carefully. 
08:08:05 <richardf> dramforever: it's early =]
08:08:57 <richardf> I seem to be getting a type error though.. " No instance for (MArray (STArray s) (STNode s) (ST s1))       arising from a use of `getBounds'
08:09:50 <dramforever> =]
08:10:04 <richardf> Code is here if it would help: http://pastebin.com/759zmrDt
08:11:49 <nshepperd_> richardf: stNodeToNode needs to be :: STNode s -> ST s Node
08:12:10 <nshepperd_> you can't read it outside of the ST monad
08:13:08 <richardf> nshepperd_: Ohh.. but how do I convert it back to be outside of ST?
08:13:44 <nshepperd_> you should have in your program only one call to runST and not use runSTArray at all
08:14:18 <richardf> Hmm ok I will try
08:14:45 <richardf> do I still need to make the result ST s Node?
08:14:54 <nshepperd_> something like runST $ do { stnode <- buildSTNode wordlist; purenode <- stNodeToNode stnode; return purenode }
08:15:06 <richardf> ahh ok ok
08:15:12 <richardf> thanks! I'll try it
08:16:12 <nshepperd_> yeah, stNodeToNode :: STNode s -> ST s Node
08:16:25 <richardf> if I recursively calls something that calls runST
08:16:40 <richardf> is that considered "only one call to runST" or no?
08:16:56 <nshepperd_> no, you don't want to do that
08:17:35 <richardf> Mm ok.. Oh right I don't need to because I have the stNodeToNode returning ST s Node
08:17:36 <richardf> ok ok
08:17:42 <richardf> I think I am beginning to understand better now
08:17:43 <richardf> thanks
08:18:09 <m1dnight_> I have followed the tutorial exactly as stated but my autocomplete does not look like this: https://github.com/iquiw/company-ghc/blob/master/images/doc-buffer.png. I am misssing the package information. What could I be missing?
08:18:13 <Maplicant>  Hello, I'm a previous imperative programmer and I've just read Learn you a Haskell. Does anybody have projects that are good for beginners in functional programming?
08:18:32 <Maplicant> I mean project ideas, of course
08:18:43 <tdammers> anything you used to do in imperative languages
08:19:02 <m1dnight_> (the tutorial: Ë‡)
08:19:04 <m1dnight_> https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md#haskell-mode
08:19:09 <merijn> tdammers: Plus the stuff you didn't dare attempt in imperative languages ;)
08:19:21 <tdammers> Haskell is particularly well suited for parsing and stuff that requires wrangling complex data structures into different shapes
08:19:25 <merijn> I wouldn't attempt to write a compiler or highly concurrent server in most imperative languages :p
08:19:35 <sm> I find it hard to understand why so many people ask that question
08:19:58 <sm> is it because people think functional programming is only good for a few things ?
08:20:05 <dramforever> I love implementing tree algorithms in Haskell! 
08:20:10 <Maplicant> Hmm, I did quite a lot of HTML parsing with BS4 in Python, but that doesn't seem like it would help me to learn Haskell.
08:20:20 <m1dnight_> Why not?
08:20:28 <m1dnight_> Just pick something.
08:20:53 <Maplicant> Because I would probably use a module to do it and I would just be interacting with the module, not Haskell
08:20:57 <m1dnight_> An irc bot, a pop3 client, a small webserver, a log parser,..
08:21:02 <m1dnight_> skip the module then.
08:21:03 <maerwald> dramforever: cyclic graph algorithms is less fun
08:21:14 <dramforever> Yeah
08:21:16 <Maplicant> IRC bot, good idea! 
08:21:25 <Maplicant> Thanks!
08:21:46 <dramforever> sm: sadly I'm afraid that the answer is yes. 
08:21:53 <Maplicant> I also don't think I'm advanced enough yet to be able to write my own HTML parsing module
08:21:57 <sm> and "irc bot!" is the standard answer :)
08:22:07 <dramforever> Or rather, they don't know what it's good for. 
08:22:53 <merijn> Maplicant: You'd be surprised :)
08:23:44 <dramforever> Maplicant, I'm just curious, how do you think of Haskell? 
08:23:59 <m1dnight_> Maplicant: a regex engine!
08:24:00 <Maplicant> It's because I'm used to having variables that are mutable. I don't have a lot of experience yet with languages that are based on immutable data structures, and I don't know where I would start with things I would do in imperative languages.
08:24:26 <tdammers> Maplicant: have you read any of the recommended beginner resources on Haskell?
08:24:40 <Maplicant> I've read LYAH
08:24:41 <dramforever> Oh, still not used to it yet, I see... 
08:25:06 <nshepperd_> I still don't know what I'm good for, let alone Haskell
08:25:10 <tdammers> you might enjoy Real World Haskell then, if you're having trouble figuring out how it relates to hands-on problem solving
08:25:16 <tdammers> @where rwh
08:25:16 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
08:25:16 <nshepperd_> But it sure is fun to learn things!
08:25:36 <statusfailed> This is still my favourite haskell tutorial: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
08:25:42 <statusfailed> and I will continue to plug it every chance I get
08:25:42 <tdammers> ^ that, too
08:26:08 <dramforever> Maplicant, I suggest you put away imperative things while learning Haskell, that helps you take in those functional stuff. 
08:26:14 <tdammers> (especially because the book actually delivers on the title)
08:26:24 <maerwald> it makes a lot of sense to ask what a language is good to be used for
08:26:26 <Maplicant> What I think of Haskell... I find it a very interesting language. For example currying. I do find things like monads and monoids confusing, and I don't know where I should use them yet.
08:26:28 <richardf> I've heard the book is outdated though? Is that wrong
08:26:59 <tdammers> yes, a bit
08:27:03 <Maplicant> richardf: Really? Do you have another recommended learning source?
08:27:14 <kadoban> @where learnhaskell
08:27:14 <lambdabot> https://github.com/bitemyapp/learnhaskell
08:27:17 <dramforever> *Quite* a bit
08:27:24 <kadoban> Maplicant: I like that advice ^ cis194 is pretty good
08:27:41 <richardf> I'm still learning myself but honestly I haven't found any of the books particularly helpful
08:27:43 <tdammers> as in, the libraries it uses are outdated, and many of the examples no longer work on a recent GHC
08:28:17 <dramforever> Maplicant, but really, most things shouldn't matter, and I guess googling would help with the rest. When in doubt you could always come here. :)
08:28:23 <Maplicant> I've already installed platform. Should I uninstall it?
08:28:45 <richardf> I read Programming in Haskell and LYAH and tried reading some of the papers by SJP.. I think I just Google'd and tried stuff mostly
08:28:47 <richardf> or asked on here =]
08:29:26 <kadoban> Maplicant: I would just get started with 'stack' right away. The platform was convenient for me for like a week and then it broke horribly and was a huge pain.
08:30:21 <dramforever> Maplicant, when you find yourself installing packages, it could be a burden. But the package story for Haskell is just sad in general. 
08:30:50 <sm> dramforever: I don't think that's true at all
08:31:02 <kadoban> sm: Which part?
08:31:04 <dramforever> Umm, which part? 
08:31:13 <sm> "package story for Haskell is just sad in general"
08:32:15 <kadoban> It was *by far* my least favorite part of haskell before stack was created. Now it's just vaguely annoying. So "sad" doesn't sound too far off from reality.
08:32:55 <Maplicant> What should I be prepared for with Haskell's package story?
08:33:18 <sm> I routinely get to reuse a huge number of high quality packages with almost no hassle, far less now that in other languages I've used
08:34:04 <bergmark> Maplicant: ghc is much stricter in how packages can be combined than other languages. You can for example not use version 1.0 of a library and pass it to another library that needs version 2.0
08:34:17 <sm> (now that we are in the stack era)
08:34:20 <maerwald> dramforever: I agree, and there's a lot that needs to be fixed in order to improve that, including GHC
08:34:36 <kadoban> Maplicant: If you use stack, it's quite fine.
08:34:43 <dramforever> Maplicant: prepare to have to ask for help :)
08:34:48 <Maplicant> So https://github.com/commercialhaskell/stack/blob/master/doc/install_and_upgrade.md#os-x?
08:35:53 <bergmark> people often complain about this stuff, but it turns out a lot of other language's build tools just ignore the problems and hope that it won't cause issues...
08:36:25 <sm> yes
08:36:32 <dramforever> So Maplicant can you be more specific about what imperative languages you came from? 
08:36:43 <kadoban> bergmark: There was never a language I used before haskell where reinstalling the world was a weekly activity (pre-stack).
08:37:04 <maerwald> bergmark: I'm not sure that makes sense... you are talking about build systems, not languages
08:37:35 <kadoban> Maplicant: Yeah, that
08:37:39 <Maplicant> Java, Python and little bit of C++ and JavaScript
08:37:53 <maerwald> haskell isn't particularly good when it comes to build systems
08:40:10 <nshepperd_> well, you don't reinstall the world in python because you just hope that everything is compatible
08:40:38 <geekosaur> the way ghc inlines across modules makes compatibility especially difficult
08:41:19 <nshepperd_> does ghc do cross-package inlining? that would certain make a big difference, yes
08:41:44 <hexagoxel> grrmbl: generating 1000 random floats between (-1.0, 1.0) via mkStdGen/randomRs costs ~155MB heap allocation.
08:42:52 <kadoban> nshepperd_: I never looked into the root causes, and to a large extent they're beyond the scope of the conversation â€¦ just practically things suck for a user (before I started using stack, now it's fine). If python's packaging story is more flimsy, I never noticed.
08:43:33 <geekosaur> nshepperd_, the .hi file contains significant hunks of source for cross-package inlining, yes
08:43:56 <hexagoxel> probably `fromIntegral`'s fault :/
08:44:01 <geekosaur> worse, currently compiler temporaries that can change between compiles can leak into it (I think that's still an open issue)
08:44:18 <bollu> is there a numpy like library for haskell?
08:44:19 <maerwald> yes, and so ABI compatibility is gone and dynamic linking makes no sense either
08:44:35 <bollu> I'm working on attitude determination for out nano-satellite simulation
08:44:43 <bollu> and would like to show off Haskell :)
08:45:01 <bollu> so I'd need quaternions, matrices, some multiplication sugar
08:49:24 <sm> bollu: does https://github.com/Gabriel439/post-rfc/blob/master/sotu.md#numerical-programming help ?
08:49:54 <bollu> oh yes, that does help a ton!
08:50:26 <sm> the section seems a bit short, but people discuss this a lot
08:51:20 <Th30n> and it doesn't mention 'linear'
08:52:00 <xplat|work> you're simulating one billionth of a satellite?
08:52:41 <xplat|work> i guess that would be pretty significant if the satellite in question were the moon
08:52:41 <hexagoxel> (revised measurement: it only takes ~2k heap per generated float)
08:52:48 <hexagoxel> "only"
09:04:41 <hexagoxel> why are the tabs in random-1.1:System.Random.hs ???
09:06:04 <maerwald> broken editor?
09:06:22 <maerwald> (I mean the guy who wrote it)
09:08:01 <hexagoxel> hvr: is your editor broken?
09:08:50 <hexagoxel> apart from that, (what) are the(re)
09:08:54 * hackagebot dotenv 0.1.0.9 - Loads environment variables from dotenv files  https://hackage.haskell.org/package/dotenv-0.1.0.9 (sestrella)
09:09:02 <hexagoxel> .. style conventions for core libraries?
09:09:57 <maerwald> I find it hard to come up with style conventions in haskell other than "make it look pretty"
09:10:05 <Gurkenglas> :t \m m' -> (zipWith . zipWith) (sum .: zipWith (*)) (map repeat m) (repeat $ transpose m') -- Oh hey nice short matrix multiplication
09:10:06 <lambdabot> Num c => [[c]] -> [[c]] -> [[c]]
09:11:39 <hexagoxel> when you look at http://hackage.haskell.org/package/random-1.1/docs/src/System-Random.html, stuff is indented wrong because tabs are displayed as two spaces :/
09:14:09 <xplat|work> Gurkenglas: well, short, anyway
09:14:39 <hexagoxel> hvr: ah sorry, nevermind.
09:14:50 <hexagoxel> (it is fixed in HEAD)
09:14:55 <Fuco> :t (.:)
09:14:57 <lambdabot> (b -> c) -> (t -> a -> b) -> t -> a -> c
09:15:09 <Gurkenglas> Granted, I find short nice and thus shouldnt say nice where I already say short
09:15:53 <Gurkenglas> "(f .: g) x = f . g x". Compare to "(f . g) x = f $ g x"
09:16:21 <xplat|work> ah, that's cute
09:17:40 <xplat|work> (f <.> g) x = f <*> g x?
09:19:22 * hackagebot dawg-ord 0.5.0.0 - Directed acyclic word graphs  https://hackage.haskell.org/package/dawg-ord-0.5.0.0 (JakubWaszczuk)
09:19:24 * hackagebot hoauth2 0.5.0.1 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-0.5.0.1 (HaishengWu)
09:19:40 <exio4> ap f . g looks more @pl-fy
09:19:57 <zipper> Are you guys actually able to read lhs?
09:20:22 <ackthet> sure why not?
09:34:02 <hexagoxel> ghc options: is auto-all == -fprof-auto && caf-all == -fprof-cafs ?
09:34:19 <obadz> isn't there a language extension i can use to refer to type variables that are in the function's type signature inside the function ?
09:34:29 <hexagoxel> ScopedTypeVariables
09:34:49 <obadz> hexagoxel: thx
09:36:14 <Gurkenglas> :t (\x y z -> (x L.<.> y) L.<.> z, \x y z -> x L.<.> (y L.<.> z)) -- xplat|work, not associative :(
09:36:16 <lambdabot> Applicative f => ((a -> a1 -> b) -> (t1 -> a -> a1) -> (t -> t1 -> a) -> t -> t1 -> b, f (a2 -> b1) -> f (a3 -> a2) -> (t2 -> f a3) -> t2 -> f b1)
09:38:13 <Gurkenglas> wait neither is .:
09:38:13 <obadz> f :: (Typeable a, Show a) => a -> Dynamic -> String
09:38:15 <obadz> f x d = show x ++ (show . fromMaybe undefined . (fromDynamic :: Dynamic -> Maybe a))
09:38:17 <obadz> shouldn't this typecheck?
09:38:39 <obadz> with ScopedTypeVariables
09:38:45 <Gurkenglas> I like .: whenever I use it in a line like "asd = foo .: evalStateT $ do". xplat|work, can you give an argument for why <.> should also exist, perhaps mathematical?
09:39:47 <obadz> (well and with a $ d in the right place..)
09:41:21 <dmwit> obadz: add `forall a.` at the front
09:41:30 <dmwit> obadz: and then go read the documentation for ScopedTypeVariables
09:42:17 <dmwit> (okay, not quite the front: `f :: forall a. {- ... -}`
09:42:21 <dmwit> )
09:42:37 <obadz> dmwit: thx that works
09:44:23 * hackagebot hoauth2 0.5.1 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-0.5.1 (HaishengWu)
09:50:34 <cmotoche> Hello everyone, I tried to update a package to stackage (by PR), but I had a problem. It tries to add the version 0.1.0.8, but the new package version is 0.1.0.9 (in Hackage). What should I do?
09:52:48 <bergmark> cmotoche: i'm stackage curator of the week, where is your PR?
09:54:58 <bergmark> cmotoche: ah i see it, i think this is just a syncing delay, it can take an hour for the all-cabal-files repo to update
09:55:50 <cmotoche> ohh
09:55:51 <cmotoche> I see
09:56:08 <cmotoche> Ok then, I'll wait.
09:56:14 <cmotoche> Thanks bergmark 
09:56:27 <sm> bergmark: aha! may I pester you about https://github.com/fpco/stackage/issues/938 ?
09:57:16 <meretrix> Is there an easy way to send SIGKILL to a ProcessHandle?
10:00:39 <bergmark> sm, sure i can take another look. I'll re-enable it for the next nightly so I get logs etc.
10:02:32 <sm> bergmark: thanks a lot. I've looked around on the build machine, but it's not easy to know what I can try without breaking stackage
10:04:25 <orion> Is it possible to set a class constraint in the definition of a datatype so that I don't have to set it on every function that uses that datatype?
10:06:09 <quchen> orion: Yes, but you shouldn't do that. https://github.com/quchen/articles/blob/master/fbut.md#imposing-constraints-on-data-types
10:06:17 <geekosaur> meretrix, base in 7.10 has System.Process.Internals. but the quesiton itself indicates that you should be using System.Posix.Process not System.Process
10:07:10 <geekosaur> System.Process is the subset of things that work on both Unix and Windows; as soon as you go beyond that subset, you need to use something else
10:07:42 <orion> quchen: Why not?
10:08:09 <quchen> Did you have a look at the link?
10:08:22 <ggVGc> I want to open a file and read/write to it in a loop. how would I best do this?
10:08:40 <ggVGc> the file is a device descriptor, and I want to listen to input from it, and respond by writing to it
10:09:03 <orion> quchen: No, doing that now.
10:10:44 <quchen> ggVGc: withFile file (\h -> forever (writeFile h . calculateResponse =<< readFile h)) -- Something along those lines, ggVGc 
10:10:54 <quchen> Beware of race conditions!
10:11:02 <ggVGc> thanks
10:11:08 <quchen> (e.g. reading while writing etc)
10:11:17 <ggVGc> quchen: how do I prevent that?
10:11:33 <ggVGc> and also, shouldn't it be okay to read and write at the same time? It's a device descriptor to a USB midi device
10:11:55 <quchen> I don't know. In general it's not OK, but in some special circumstances it might.
10:12:10 <ggVGc> well, it's serial I/O right?
10:12:27 <ggVGc> aren't device descriptors in linux safe to read and write to at the same time?
10:12:44 <quchen> I don't know, so I wouldn't bet on it.
10:12:57 <ggVGc> well, so how do I make sure I don't then?
10:13:18 <geekosaur> device descriptors are; the devices they refer to may not be.
10:13:54 <quchen> By ensuring you're done reading before you attempt to write, done by making your data strict. `evaluate`, `seq`, `deepseq`, `$!` and so on are helpful for doing this.
10:13:55 <ggVGc> geekosaur: right, that's up to the driver and hardware eh
10:14:08 <geekosaur> yes, usually the hardware for e.g.midi
10:14:58 <geekosaur> (n general the device protocols aren't smart enough to allow the driver to be smart; the user/programmer has to be smart instead)
10:19:24 * hackagebot crypto-classical 0.2.0 - An educational tool for studying classical cryptography schemes.  https://hackage.haskell.org/package/crypto-classical-0.2.0 (fosskers)
10:19:26 * hackagebot simple 0.11.1 - A minimalist web framework for the WAI server interface  https://hackage.haskell.org/package/simple-0.11.1 (AmitLevy)
10:24:22 <broma0> what are some ways to model physical relationships between types? For example, in a task list app, you might have 'data Task = ..' and 'data Tag = ..' where Tags can be added to Tasks. If feels archaic to make something like [TagId] part of the Task, but i also couldnt duplicate all that data by making [Tag] part of the Task. How can this be modeled?
10:25:31 <broma0> I remember reading an article recently that used type families to make a 'Rep Tag' that could be a fully relaized tag, a database call, etc. Can't find the article today :/, any bells ringing?
10:32:10 <obadz> hmmmm.. what monster did I just create? https://gist.github.com/obadz/62cc795dbc02159ff0c7
10:32:27 <obadz> I called it Freest because it's even Freer than the Free monad
10:32:36 <obadz> but then again I assume it's a common construct?
10:32:43 <obadz> does it have a name?
10:33:01 <bennofs> obadz: that doesn't satisfy the functor laws
10:33:16 <obadz> bennofs: I did call it a monster ;-)
10:33:30 <bennofs> obadz: you can tell whether I used (fmap f . fmap g) or (fmap (f . g))
10:33:42 <bennofs> -> fmap f . fmap g /= fmap (f . g)
10:34:25 * hackagebot grouped-list 0.2.1.1 - Grouped lists. Equal consecutive elements are grouped.  https://hackage.haskell.org/package/grouped-list-0.2.1.1 (DanielDiaz)
10:34:27 <bennofs> obadz: you might be looking for Codensity if you're searching for a free monad without the functor constraint (https://hackage.haskell.org/package/kan-extensions-4.2.3/docs/Control-Monad-Codensity.html)
10:34:44 <obadz> bennofs: instance Eq b => Eq (Freest b) where
10:34:46 <obadz>     y == y' = (eval y) == (eval y')
10:34:53 <obadz> then functor law holds?
10:35:47 <bennofs> obadz: you might also like http://comonad.com/reader/2011/free-monads-for-less/
10:37:05 <xplat|work> every monad is a codensity monad.  but not every monad is the codensity monad of an endofunctor.
10:38:05 <bennofs> obadz: well, it's a bit of a grey area. You could say that the Functor laws hold if you only ever export functions that don't allow you to tell apart fmap (f . g) and fmap f . fmap g. That's of course fine for practical purposes, and such "illegal" instances are also sometimes useful (even if it means that you have to take care the the "unlawfulness" never leaks outside your API)
10:38:28 <xplat|work> codensity monads of 'non-functors' are actually the codensity monads coming from, e.g., functors from the discrete category on types
10:39:45 <obadz> bennofs: there might be a way to do some reduction in the instances and make it legal ?
10:39:57 <bennofs> obadz: yes
10:40:07 <obadz> bennofs: does it have a name then ? :)
10:40:56 <obadz> the Eval monad ?
10:41:28 <bennofs> obadz: I don't know. I'm not really an expert on these topics, but I'd guess that it'd just be another representation of some free construction at that point
10:43:49 <obadz> looks a bit like https://hackage.haskell.org/package/free-functors-0.6.5/docs/Data-Functor-Free.html
10:43:53 <obadz> maybe it's the Free functor?!
10:44:25 * hackagebot hledger-ui 0.27.2 - Curses-style user interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-ui-0.27.2 (SimonMichael)
10:45:26 <bennofs> obadz: i think a free functor wouldn't be a monad as well, since free functor basically means "not anymore structure than a functor", and a monad has some "additional" structure to it
10:45:37 <bennofs> obadz: perhaps it's a Free monad of a Free functor? 
10:45:37 <obadz> agreed
10:47:41 <dgpratt> I've managed to "complete" this exercise I've been fiddling with, but the reason for the scare quotes is that I'm not confident all parts are correct -- only that it type checks
10:47:42 <dgpratt> http://lpaste.net/4486444230910148608
10:48:11 <dgpratt> how can I put these definitions through their paces or otherwise convince myself that they are correct?
10:48:33 <Fuco> hmm... how much liftint is acceptable... I have MaybeT over StateT over my own two monads which include one another... lift . liftCall . lift is pretty confusing
10:49:25 * hackagebot packdeps 0.4.2.1 - Check your cabal packages for lagging dependencies.  https://hackage.haskell.org/package/packdeps-0.4.2.1 (MichaelSnoyman)
10:49:27 * hackagebot comfort-graph 0.0.1 - Graph structure with type parameters for nodes and edges  https://hackage.haskell.org/package/comfort-graph-0.0.1 (HenningThielemann)
10:49:43 <ReinH> Fuco: use the mtl typeclasses and create your own to avoid doing any lifting at all
10:50:40 <bennofs> Fuco: if you're worried about the lifting cluttering your code, you might do it mtl-style: have a MonadXXX (where XXX stands for some kind of "feature") with members that correspond to the primitive operations for that feature and then just make instances for any monad transformer over any base monad just lifting the primitves through the transformer
10:50:49 <Fuco> I'm pretty confused about all the transformer libraries
10:50:55 <bitemyapp> mtl style is bae
10:51:05 <Fuco> there is something built-in, there is trasnformers, there is mtl... I think I depend on all of them :D
10:51:11 <Fuco> but I'm confused in which way
10:51:21 <bennofs> bitemyapp: why exactly? because of the n^2 explosion?
10:51:36 <ReinH> bae means good, as opposed to bad, which means bad
10:51:37 <Cale> bitemyapp: you misspelled "bad"
10:52:05 <Cale> Kappa
10:52:11 <ReinH> there it is
10:52:12 <bennofs> oh I thought it was a typo :)
10:52:57 <FireFly> Twitch emotes in #haskell? that's a first for me
10:53:04 <Fuco> I read a paper some years ago about some monad transformer idea where you would "encode" the stack in the type and there would be some magic picking the effects or something like that
10:53:13 <Fuco> I don't remember exactly but it seemed like a solid idea
10:53:13 <Cale> FireFly: It just seemed uniquely appropriate somehow
10:53:38 <obadz> bennofs: https://gist.github.com/obadz/62cc795dbc02159ff0c7 I think it satisfies functor laws now
10:53:46 <EvanR> transform stack hell Dx
10:54:02 <bitemyapp> Cale: :D
10:54:05 <bitemyapp> bennofs: no, bae.
10:54:21 <Cale> What mtl does for you is okay. It just starts to suck if it leaks out over your whole application.
10:54:26 <anks> hi, what is the recommended way of installing ghcjs, i wanna experiment with reflex-dom, but try-reflex.sh hasnt worked for me 
10:54:29 <bitemyapp> bennofs: I like mtl style
10:54:44 <bitemyapp> but there's a reasonable compromise available if you hate typeclasses
10:54:44 <Cale> i.e. if you care that you're using mtl a bunch, you're probably misusing it imo
10:54:47 <bennofs> obadz: you probably have a similar problem with the Applicative / Monad laws. It's quite hard to find all the reductions neccessary afaik
10:55:32 <Cale> It saves you the trouble of writing a handful of instances every now and again, and that's fine
10:55:41 <obadz> bennofs: those laws are defined in terms of values me things
10:56:02 <obadz> bennofs: so my equality trick ought to do
10:56:14 <Cale> Honestly, the mtl classes are often *the wrong classes* though.
10:56:22 <byorgey> bennofs, obadz: who cares though.  As long as 'eval' is the only way to 'observe' the values, it's OK if the Functor, etc. laws only hold up to 'eval'
10:56:40 <obadz> byorgey: I think I agree
10:56:47 <bennofs> byorgey, obadz: you should put it in a module and only export eval then though :)
10:56:53 <Cale> You'd rather have type classes which meant something a bit more application-specific than "there is a value of type s which you can modify using some operations"
10:56:58 <obadz> now the question is what's the use for this thing? :)
10:57:00 <byorgey> obadz: why is it freer than the free monad?
10:57:11 <obadz> byorgey: because you don't even need a functor to start with
10:57:34 <Cale> It depends of course on which type s is
10:57:40 <Cale> and what structure it has
10:58:06 <bennofs> obadz: hmm, looking at it more carefully, what advantage does that thing have over the Identity monad?
10:58:08 <Cale> But you can usually do a lot better in terms of presenting the users of the library you're writing (which might even just be you) a coherent and meaningful API
10:58:31 <byorgey> obadz: check out http://okmij.org/ftp/Computation/free-monad.html
10:58:48 <obadz> bennofs: it's introspectable before evaluation
10:59:23 <byorgey> obadz: there is definitely some redundancy between FMap, Apply, and Bind
10:59:50 <byorgey> see that link for a way to do it which just uses something akin to return and something akin to bind
10:59:52 <obadz> byorgey: well yes since Monad < Applicative < Functor
11:00:00 <Cale> Like, for almost any usage of MonadState s, you typically 1) care which type s is, and 2) want to do something more specific with the state than 'get' and 'put' do on their own.
11:00:29 <obadz> byorgey: probably sufficient to have pure/join/bind
11:00:40 <obadz> byorgey: or pure/join/fmap rather
11:00:54 <byorgey> obadz: yes, something like that would probably work too
11:02:07 <johnw> I think what Cale's getting that is that the mtl is great for weakening the requirements of library functions (by making them more generally applicable), but that's mostly all that it's good for; if your function has application-specific meaning, then such weakening may not be a good thing
11:03:08 <bitemyapp> johnw: the problem is people often go too far in the other direction
11:03:23 <bitemyapp> johnw: and fail to abstract the stack and associated functions they need
11:03:24 <Cale> Yeah, that's the main part of it. I also find it's very often abused to get much more polymorphism than is actually used or exploited in any way.
11:03:40 <johnw> Cale: right; unnecessary generality
11:03:45 <johnw> gratuitous, even
11:03:46 <Cale> and so the types just end up being a mess
11:03:53 <Cale> for no good reason at all
11:03:55 <bitemyapp> Probably the middle-way is best, but mtl is more fool-proof for avoiding stack churn.
11:04:10 <bitemyapp> and stack churn creates some _really_ unhappy campers FSR
11:04:20 <Cale> also, if you have to think of it as a "stack" then something is going off the rails
11:04:26 <Cale> most likely
11:04:31 <bitemyapp> cf. what I said about abstracting the type
11:05:16 <Cale> (I don't know what "stack churn" actually refers to here, but I've heard people use terms like monad transformer stack, which I think is mostly pretty unhelpful...)
11:05:45 <EvanR> what is stack churn
11:06:29 <johnw> if I'm writing a function where I don't know what the 'm' will be, then MonadState is useful; if I always know exactly what it will be, then it's typically not
11:06:51 <i_am_mahasamoot> I just signed into the SoH, and I've got a few questions
11:07:50 <Cale> ...and even if you don't know precisely what the m will be, sometimes you can make your code more comprehensible by being a bit more specific than (MonadState s m) in some way, even if you might get by with that constraint.
11:08:29 <i_am_mahasamoot> in the example code, = throws an error on GHCi Online, but works when compiled.  Why is that?
11:09:04 <Cale> i_am_mahasamoot: I don't know what GHCi Online is, but ordinary GHCi is looking for expressions, not declarations.
11:09:35 <Cale> i_am_mahasamoot: You want to put your declarations into a file and load it with ghci. Whenever you change the file, typing :r in ghci will reload the file.
11:09:40 <ReinH> bennofs: don't listen to byorgey, he's a known sympathizer for correct typeclasses instances that are only morally correct.
11:09:53 <ReinH> s/correct typeclass/typeclass
11:10:25 <EvanR> amorally correct is better
11:11:40 <i_am_mahasamoot> ahh
11:11:43 <ReinH> What I generally suggest is using a concrete monad, but providing it with instances so you don't have to, e.g., lift your gets and puts everywhere.
11:11:55 <Cale> i_am_mahasamoot: If you really want to make a declaration while using ghci without putting it into a file, you can put 'let' before it (and squish the entire declaration onto one line)
11:12:32 <i_am_mahasamoot> Cale: thanks
11:13:27 <i_am_mahasamoot> My next question on the subject of GHCi:  Doesn
11:13:29 <Cale> (but take care: there's no convenient way to get these declarations back if you end up wanting to collect them all again)
11:13:30 <andromeda-galaxy> Cale, i_am_mahasamoot: or use the :{:} multiline syntax to avoid squishing the definition
11:13:47 <Cale> yeah, that exists
11:14:12 <i_am_mahasamoot> 't it come with haskell-platform?
11:14:20 <Cale> i_am_mahasamoot: It does.
11:14:44 <Cale> It comes with ghc even
11:14:53 <Cale> and ghc comes with Haskell Platform
11:16:06 <i_am_mahasamoot> I've got Ubuntu Trusty running in a chroot on my ARM Chromebook.  I did a 'sudo apt-get install haskel-platform' and it installed all the goodies except GHCi
11:16:34 <i_am_mahasamoot> djica)tomus@localhost:~$ ghc --interactive <command line>: not built for interactive use
11:17:33 <i_am_mahasamoot> (djica)tomus@localhost:~$ ghci -su: ghci: command not found
11:17:46 <Cale> Oh, on ARM
11:18:24 <Cale> Yeah, GHCi requires more work on the part of the people porting GHC to a new platform than has been done to support ARM I think
11:18:32 <ReinH> i_am_mahasamoot: what ghc version?
11:18:34 <andromeda-galaxy> has anyone installed ghcjs before?  I'm getting this error: setup: The program 'ghcjs' version >=0.1 is required but the version of '/home/redacted/.cabal/bin/ghcjs' could not be determined, and can't find anything about it anywhere...
11:18:43 <Cale> But maybe people know more about the specifics here
11:21:05 <Kaidelong> is there a blog post or something out there explaining why we have "class (Superclass t) => Subclass t" rather than "instance (Subclass t) => Superclass t" as the general practice?
11:21:43 <Kaidelong> the latter appears to be strictly better, but this is not what people do, so I'm assuming there are subtle issues with it
11:21:46 <Cale> actually, apparently there was at least one version of GHC for ARM Linux which supported GHCi in the past...
11:22:10 <i_am_mahasamoot> That seems odd... I thought the first motivation for moving to compiled languages over assembly, was to multiple backends
11:22:24 <Ab123> mpickering : hi hows u :D
11:22:47 <ReinH> i_am_mahasamoot: whata version of ghc?
11:22:50 <i_am_mahasamoot> ReinH: ghc-7.6.3
11:22:59 <ReinH> you could at least try with a modern ghc
11:23:38 <Ab123> mpickering: hi hows u :D
11:23:54 <ReinH> 7.6.3 was released in 2013 and definitely doesn't support ghci on ARM. More recent versions, like 7.10, might.
11:24:15 <i_am_mahasamoot> ReinH: I'll do that.  I assume there's a PPA with the latest Haskel Platform
11:24:43 <Cale> https://www.haskell.org/ghc/download_ghc_7_10_2#linux_armv7
11:24:46 <ReinH> There is a PPA for ghc itself https://launchpad.net/~hvr/+archive/ubuntu/ghc 
11:24:52 <ReinH> you don't really need the platform.
11:24:58 <Cale> Oh, I guess if you want to use a PPA, you can
11:25:09 <andromeda-galaxy> Kaidelong: IIRC, that instance can cause *lots* of trouble with instance resolution
11:25:23 <Cale> (I'd usually just grab the binary GHC from GHC's website)
11:25:36 <ReinH> or that
11:26:22 <andromeda-galaxy> Kaidelong: because a type with a Subclass instance might want a special Superclass instance
11:26:45 <andromeda-galaxy> ReinH, Cale: have you ever managed to get ghcjs built?
11:27:08 <Cale> andromeda-galaxy: Uh, I didn't explicitly try to build ghcjs myself, but I use it every day for work.
11:27:09 <Kaidelong> that was the main thing I thought might get in the way, GHC doesn't have a way to deal with overloading properly
11:27:32 <Kaidelong> what might be neat is if it supported defining base class methods in the instances of superclasses
11:27:42 <andromeda-galaxy> Cale: how did you install it then?
11:27:43 <Kaidelong> subclasses*
11:27:47 <Cale> Unless you're hacking on GHC, compiling it yourself is generally a giant waste of time
11:27:53 <Gurkenglas> Kaidelong: anything may only appear once on the right side of the "=>" of an instance declaration - we don't have OR combination of conditions
11:27:56 <Kaidelong> and default methods in the definitions of subclasses that are defaults for the base class
11:28:20 <andromeda-galaxy> Cale: I can't find a decent distribution of ghcjs that is relatively recent & that I trust
11:28:33 <Gurkenglas> If you had instance Subclass t => Superclass t, then nothing else could define instances of Superclass - since Superclass t covers everything
11:28:42 <andromeda-galaxy> Kaidelong: take a look at DefaultSuperclassInstances?
11:29:04 <Cale> andromeda-galaxy: I installed binary cached versions of it through our nix stuff. I don't really know how it works.
11:29:12 <Cale> andromeda-galaxy: But try-reflex comes with it
11:29:24 <Cale> https://github.com/ryantrinkle/try-reflex
11:29:26 <andromeda-galaxy> Cale: ah, okay... I'm not on nix (yet)
11:29:39 <Cale> Yeah, I'm just using Linux Mint
11:29:44 <Cale> But with nix tools
11:30:06 <andromeda-galaxy> Cale: so try-reflex installs nix into $HOME and then uses that to build ghcjs?
11:31:15 <Cale> Yeah, something like that. But I don't think it compiles ghcjs itself, that would take far too long. It just downloads it.
11:31:30 <andromeda-galaxy> Cale: thanks for the recommendation, I'll look into trying nix again...  I was hoping that stack would remove the need for it, but not yet
11:31:45 <andromeda-galaxy> Cale: yeah, it looks like it pulls it from a ryantrinkle binary cache
11:31:48 <Cale> I honestly don't care much for nix, but it's what we're using
11:31:53 <Cale> yeah
11:32:03 <andromeda-galaxy> I'll probably try to do it locally and see what happens on my workstation, though
11:32:13 <andromeda-galaxy> I'm a bit paranoid about trusting binary downloads
11:32:41 <Cale> andromeda-galaxy: If you ever want to compile GHC yourself, you'll need a binary GHC anyway, unless you want to painstakingly bootstrap it yourself.
11:32:53 <Cale> (which requires lots of special knowledge of how the compiler works)
11:33:05 <andromeda-galaxy> Cale: indeed, I generally trust the GHC binary distributions
11:33:19 <andromeda-galaxy> it's ghcjs that I'm worried about---luite hasn't published one, as far as I can tell
11:33:49 <Cale> luite pls
11:33:50 <Cale> heh
11:34:23 <andromeda-galaxy> Cale: well, anyway, thanks for the Nix suggestion
11:34:43 <Cale> http://weblog.luite.com/wordpress/ the top thing on this blog right now seems to have some other instructions for getting a binary ghcjs
11:34:51 <adamCS> andromeda-galaxy: I missed the beginning of this but, if it helps, I've had a relatively easy time getting ghcjs and reflex working with stack.  I did build ghcjs, which took a couple of hours, but then I didn't have to learn anything about nix :)
11:35:45 <andromeda-galaxy> adamCS: I've been trying to build ghcjs locally, for improved-base
11:35:57 <andromeda-galaxy> but I'm getting a particularly weird error during setup that:
11:35:57 <Cale> Yeah, nix is a bit of a constant source of frustration for me, since I haven't yet taken much time to learn the ad-hoc programming language its configuration files are written in.
11:36:02 <andromeda-galaxy> adamCS: setup: The program 'ghcjs' version >=0.1 is required but the version of '/home/redacted/.cabal/bin/ghcjs' could not be determined.
11:36:34 <adamCS> andromeda-galaxy:  That's what I have, along with some later branches of ghcjs-dom, reflex-dom and reflex-dom-contrib.
11:36:58 <adamCS> that's during stack setup?
11:37:12 <andromeda-galaxy> Cale:  the top post on luite's blog (that I can see at least) is from 2013 and says that 'ghcjs-build repository is no longer maintained.'
11:37:16 <andromeda-galaxy> adamCS: stack?
11:37:22 <Cale> oh, that's sad
11:37:31 <andromeda-galaxy> adamCS: I did what the ghcjs repo says:
11:37:36 <andromeda-galaxy> cabal install ghcjs && ghcjs-boot
11:37:44 <Cale> Yeah I missed that
11:37:54 <adamCS> andromeda-galaxy: http://docs.haskellstack.org/en/stable/README.html
11:38:07 <adamCS> and: http://docs.haskellstack.org/en/stable/ghcjs.html
11:38:18 <andromeda-galaxy> adamCS: the ghcjs page only talks about how to get binaries from rsheppard, right?
11:38:44 <andromeda-galaxy> adamCS: I mean, nrollad
11:38:56 <andromeda-galaxy> it says to use 'url: "https://github.com/nrolland/ghcjs/releases/download/v0.2.0.20151029/ghcjs-0.2.0.20151029.tar.gz"'
11:38:58 <adamCS> I didn't get the binary, I built it.  It does take a while but then things work like a charm..
11:39:12 <adamCS> Well, as long as you can live without ghc-mod...which is annoying
11:39:17 <andromeda-galaxy> adamCS: so it builds from source, but from that source instead of the main repo source?
11:39:33 * hackagebot compose-ltr 0.1.3 - More intuitive, left-to-right function composition.  https://hackage.haskell.org/package/compose-ltr-0.1.3 (Wizek)
11:40:35 <adamCS> andromeda-galaxy:  Yes.  It builds from whatever source your stack.yaml points to.
11:40:55 <adamCS> I've been working with the 2015-10-29 branch
11:41:45 <andromeda-galaxy> adamCS: ah, okay...
11:42:09 <andromeda-galaxy> adamCS: I wasn't sure about trusting the nrolland branch of the sources, that's all
11:42:28 <adamCS> right
11:42:36 <adamCS> Let me see what I have been using...
11:42:48 <andromeda-galaxy> adamCS: thanks!
11:42:53 <adamCS> yeah, I've been using that one
11:43:43 <andromeda-galaxy> adamCS: ah well, I'll try it with ghcjs/ghcjs and see what happens, or maybe diff nrolland & ghcjs
11:44:04 <andromeda-galaxy> adamCS, Cale: thanks for looking into it, anyway
11:44:51 <adamCS> then I used github desktop to get local copies of the appropriate ghcjs-dom, reflex and reflex-dom and specify the local directories in stack.yaml under "packages"
11:45:32 <andromeda-galaxy> adamCS: right...
11:46:31 <adamCS> Also, and I'm not sure it matters, I've been using "resolver: nightly-2015-11-14"
11:47:01 <adamCS> at some point I'll figure out if that's necessary but it all works and the deps are sort of finicky...
11:47:45 <andromeda-galaxy> indeed
12:00:44 <ReinH> adamCS: I have a working stack.yml for ghcjs. It also sets up reflex-dom, but you can skip that part.
12:00:56 <ReinH> You can use lts-3.16 and similar as well
12:01:14 <ReinH> oh. andromeda-galaxy: try https://github.com/reinh/reflex-dom-stack-demo
12:01:15 <adamCS> ReinH:  I think it's andromeda-galaxy that needs that
12:01:20 <adamCS> right
12:01:24 <ReinH> adamCS: yeah I just pieced that together ;)
12:01:36 <Seblink> Hello, any suggestions how i can make the hamming method more readable using function chaining and '$'? http://lpaste.net/148835 I tried to edit it , but it won't compile.
12:01:59 <adamCS> I had a resolver issue when I first tried, got it working with that nightly, and then figured I change once more of the reflex stuff that I need is in the LTS snapshot. 
12:02:03 <andromeda-galaxy> ReinH: that's the one that uses the nrolland fork, right?
12:02:16 <ReinH> andromeda-galaxy: yes
12:02:25 <ReinH> well, it uses nrolland's ghcjs release
12:02:47 <andromeda-galaxy> ReinH: I've been trying to avoid downloading code from anyone but the main ghcjs repository
12:03:04 <andromeda-galaxy> ReinH: which is why I didn't just do that...
12:03:18 <ReinH> Ok then. Good luck.
12:03:41 <andromeda-galaxy> ReinH: thanks anyway
12:04:32 <andromeda-galaxy> ReinH: my original question was about why ghcjs-boot has decided that it can't determine the version of my ghcjs executable
12:04:45 <andromeda-galaxy> even though ghcjs --version and ghcjs --numeric-version both work
12:04:57 <hexagoxel> til haskell Floats can be 64bits
12:10:35 <hexagoxel> wait, but the storable sizeOf is 4? so peek . poke is not identity? meh
12:11:31 <hexagoxel> (and is there a Float32 like there is Int32 ?)
12:11:43 <ReinH> hexagoxel: so... sizeOf is 4 on architectures where Float happens to be 32 bits?
12:11:51 <ReinH> (which is, afaik, all of them)
12:12:12 <ReinH> do you have any evidence of sizeOf being 4 on an arch where Float is not 32 bits?
12:12:23 <hexagoxel> this system?
12:13:10 <ReinH> which system?
12:13:13 <hexagoxel> system is 64bit
12:13:18 <ReinH> So?
12:13:37 <ReinH> That doesn't mean that Float is 64 bit.
12:14:14 <hexagoxel> ReinH: i am judging by the results from using wordToFloat from Data.Binary.IEEE754
12:14:36 <hexagoxel> (and unsafeCoercing between Float and Int32, but that is.. unsafe reasoning)
12:15:11 <ReinH> uh, Word32 and Int32 are both 32 bits.
12:15:57 <ReinH> I'll bet you a nickel that Float on your system is 32bit and Double is 64bit.
12:16:16 <hpc> float is always 32 bits
12:16:20 <hpc> double is always 64
12:16:31 <hpc> (for practical values of "always")
12:17:06 <hexagoxel> ok, my observation is this: i coerce (1::Int32) to Float. that should be the smallest possible non-zero positive number, right?
12:17:07 <andromeda-galaxy> hpc: for practical values of "always" -- I'm going to start using that
12:17:29 <hexagoxel> it prints "1.0e-45" here
12:18:00 <hexagoxel> ah wait, no
12:18:17 <hexagoxel> not the smallest possible
12:18:19 <hexagoxel> meh
12:18:50 <ReinH> easiest nickel I ever almost made
12:23:24 <Jaxan> I have some type constructor X, and a map f : X a -> X b -> X (a, b), what kind of structure is that?
12:23:53 <ReinH> Jaxan: a functor.
12:24:07 <ReinH> specifically, one equipped with a strength, which all functors are.
12:24:10 <Fuco> :t liftA2 (,)
12:24:11 <lambdabot> Applicative f => f a -> f b -> f (a, b)
12:24:29 <Jaxan> ReinH: you say that I can implement fmap from f?
12:25:05 <Fuco> fmap for X?
12:25:14 <ReinH> Hmm.
12:25:19 <Ankhers> I don't understand how that can be considered a functor.
12:25:43 <Ankhers> Automatically considered a functor*
12:27:16 <Jaxan> So it might be something weaker
12:27:25 <ReinH> Yeah, strength is a -> X b -> X (a, b)
12:27:27 <ReinH> sorry
12:27:28 <roelof> Hello, I have a map with a integer. Now I want to add, let's say 2 to it. When I do map.update ( + 2)  number  numbers I see that it will not work because +2 needs to be a string 
12:27:40 <roelof> How can I solve this ?
12:28:09 <ReinH> roelof: why does (+2) need to be a string?
12:29:32 <roelof> ReinH:  I think that because of this error message : http://lpaste.net/148839
12:29:32 <Jaxan> So in the ByteString package, this class is called Monoidal: http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/src/Data.ByteString.Builder.Prim.Internal.html#Monoidal
12:29:34 * hackagebot buffer-pipe 0.0 - Read from stdin and write to stdout in large blocks  https://hackage.haskell.org/package/buffer-pipe-0.0 (HenningThielemann)
12:29:41 <ReinH> X a -> X b -> X (a, b) is one side of an isomorphism needed to have a strong monoidal functor.
12:29:55 <hexagoxel> ReinH: well i am glad you are right
12:30:05 <ReinH> roelof: you haven't included the context we need to solve your question
12:30:22 <glittershark_> roelof: what's the map itself look like?
12:30:33 <roelof> and the type definition of Map.update : adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a
12:30:44 <ReinH> Yes, we know what update is. What are *your* types?
12:30:59 <andromeda-galaxy> roelof: the first argument to Map.update is (a -> Maybe a)
12:31:05 <andromeda-galaxy> roelof: not (a -> a)
12:31:14 <ReinH> We don't know why Strings should be involved at all.
12:31:19 <glittershark_> yeah, you could just `return . (+ amountToDeposit)` there
12:31:27 <glittershark_> or `Just . (+ amountToDeposit)`
12:31:28 <andromeda-galaxy> ReinH: true
12:31:56 <andromeda-galaxy> roelof: what are the types of name and accts?
12:31:58 <ReinH> if the error is that a -> a should be a -> Maybe a then yes, you can stick a return on it.
12:32:03 <roelof> here is I think all the relevant code : http://lpaste.net/148840
12:32:19 <zipper> Can anyone tell me why my websocket server isn't sending data to the client here: https://gist.github.com/urbanslug/9afc750080003b6d440d
12:33:38 <roelof> name is Maybe Account is accts is   type AccountStore' = Map.Map String Account
12:33:45 <andromeda-galaxy> roelof: for one thing, the values of accts are Account values, not numbers
12:34:21 <ReinH> Well
12:34:25 <ReinH> There are a few problems here
12:34:29 <ReinH> amountToDeposit is not a number
12:34:33 <ReinH> accounts are not numbers
12:34:37 <andromeda-galaxy> (+2) :: Num a => a -> a
12:34:37 <roelof> andromeda-galaxy:  oke, so I have to pull out the amount to add the new integer 
12:35:00 <glittershark_> zipper: could be the /socketserver URL
12:35:03 <ReinH> you need to convert amountToDeposit into a number and you are updating an account, not a number
12:35:05 <andromeda-galaxy> roeelof: as ReinH mentioned, also amountToDeposit is a string
12:35:14 <glittershark_> zipper: also maybe that you're connecting to www.example.com
12:35:19 <andromeda-galaxy> also, name :: Maybe String needs to be name :: String
12:35:58 <roelof> Can I do amountToDeposit::Integer   ?? 
12:36:07 <ReinH> No.
12:36:09 <ReinH> Because it is a String.
12:36:17 <ReinH> :t getLine
12:36:18 <lambdabot> IO String
12:36:25 <glittershark_> you need to `read` it
12:36:46 <roelof> stupid I have to use (read amountToDeposit::Integer) 
12:36:47 <ReinH> roelof: there is a lot of logic involved in adding a transaction to an account
12:36:48 <andromeda-galaxy> glittershark_, roelof: readMaybe is better than read, thoughtpolice
12:36:54 <glittershark_> well, yeah
12:36:58 <ReinH> you have to update the amount, you have to add a Transaction to the list, etc
12:37:21 <zipper> OMG
12:37:31 <zipper> glittershark_: Such a URL
12:37:36 <zipper> How did I miss that
12:37:37 <ReinH> roelof: this would be easier if you wrote a function addTransaction :: Account -> Integer -> String -> Account that does this for you.
12:37:38 <glittershark_> zipper: :)
12:38:00 <ReinH> or s/Integer/Amount, which is the same thing
12:38:44 <glittershark_> is there a typeclass in base or a well-used package for a type that can be converted to and from booleans?
12:38:52 <ReinH> Also, if you have no intention of removing keys from your map, you do not need update. You only need adjust.
12:39:33 <ReinH> You also don't need to specifically test for the existence of the key: if it does not exist, the map will be returned unchanged.
12:39:36 * hackagebot multiset 0.3.1 - The Data.MultiSet container type  https://hackage.haskell.org/package/multiset-0.3.1 (TwanVanLaarhoven)
12:42:23 <ReinH> roelof: I would expect read to work without the type annotation, but read will also crash your program if your user enters "foobar" for the amount.
12:42:30 <roelof> ReinH:  I do the test so I can print a error message to the user 
12:42:47 <ReinH> You can print an error message, but you don't need the rest of the branches
12:43:37 <ReinH> e.g., when (isJust (Map.lookup accountToDeposit accounts)) (putStrLn "This account does not exist")
12:43:41 <ReinH> Anyway, that's beside the point
12:44:12 <uruga> Hi, why should i use type classes if i can use record types with functions as fields?
12:45:05 <ReinH> Because passing those records around is tedious.
12:45:13 <ReinH> That's what typeclasses do for you
12:46:25 <ReinH> And those records can be known statically at compile time, so why should you have to pass them yourself at runtime?
12:46:27 <hpc> polymorphic recursion can't be done with just record fields
12:47:29 <glittershark_> also typeclass instances can be defined for types which you do not directly control
12:47:31 <barrucadu> You need other type system extensions to be able to write, say, data Functor f = { fmap :: forall a b. (a -> b) -> f a -> f b }
12:47:49 <hpc> for instance, suppose you have data Show a = Show {show :: a -> String}
12:48:01 <hpc> so you have show :: Show a -> a -> String
12:48:09 <hpc> but what if you want to write a value of type Show [a]?
12:48:10 <uruga> ReinH: isn't passing a record around the same as having a class constraint?
12:48:14 <EvanR> glittershark_: but it would require orphans
12:48:43 <uruga> hpc, i see, good poitn thanks
12:48:48 <glittershark_> EvanR: orphans are not as much of an anti-pattern as -Wall would have you believe
12:48:52 <glittershark_> imo
12:49:13 <glittershark_> maybe the more experienced folks here can disagree with me
12:49:32 <hpc> uruga: (you can write Show a -> Show [a] but trying to use that is even harder)
12:49:33 <EvanR> .oO venture brothers "used an orphan"
12:49:54 <ReinH> EvanR, glittershark_: Orphans are generally fine in application code. They pose problems when created in libraries.
12:49:54 <Cale> glittershark_: It depends. In an application, orphans are 100% fine. In a library, they're obnoxious.
12:50:02 <glittershark_> yep
12:50:05 <glittershark_> that's how I feel
12:50:08 <pranz> what are orphans?
12:50:23 <ReinH> Cale: haha I beat you. ReinH: 1, Cale: some very large number.
12:50:33 <Cale> pranz: instances of type classes defined in a module which is neither the module in which the class is defined, nor the module in which the type is defined
12:50:41 <glittershark_> though you get things like Aeson defining FromJSON and ToJSON instances for a bunch of stdlib types it doesn't control, which I think is really useful
12:50:45 <ReinH> uruga: nearly, except for the things hpc and I just mentioned.
12:50:52 <glittershark_> oh, I guess instances defined alongside the class are nice
12:50:55 <ReinH> (and possibly some other things, but those are the main ones)
12:51:08 <glittershark_> does ghc not consider instances defined alongside the class orphans?
12:51:11 <ReinH> glittershark_: yes, but instances defined alongside the class are not orphans.
12:51:21 <glittershark_> bc if so my original point holds and EvanR is wrong :)
12:51:34 <EvanR> i realize that now upon rereading the claim
12:51:40 <glittershark_> but in like
12:51:42 <glittershark_> a friendly way
12:51:44 <glittershark_> :)
12:51:45 <EvanR> to clarify, if you control the class
12:51:45 <ReinH> ha
12:51:47 <Cale> glittershark_: that's right, the "parents" in this analogy here are the class and the data declaration
12:51:56 <EvanR> you can define instances for whatever types
12:51:57 <ReinH> when a class and a data declaration love each other very much
12:52:15 <glittershark_> heh
12:53:05 <roelof> Thanks, time to sleep now 
12:59:37 * hackagebot tiphys 0.1.1.0 - Navigating and editing JSON data  https://hackage.haskell.org/package/tiphys-0.1.1.0 (llhotka)
13:00:42 <uruga> thanks
13:03:19 <xplat|work> we don't want to be exclusionary here -- either a class or a type family can love any generative type declaration, and that's even without FlexibleInstances
13:04:23 <ReinH> xplat|work: <3
13:04:29 <glittershark_> xplat|work++
13:05:25 <ReinH> xplat|work: can I quote you on the twitters?
13:05:30 <xplat|work> yes
13:05:42 <ReinH> xplat|work: do you twitter?
13:05:48 <xplat|work> not really
13:05:54 <ReinH> but I want to attribute you
13:06:06 <xplat|work> just attribute me as 'xplat'
13:06:40 <xplat|work> not '@xplat' since that won't work :)
13:06:45 <ReinH> okies
13:07:26 <bitemyapp> @karma+ xplat
13:07:26 <lambdabot> xplat's karma raised to 22.
13:07:32 <ReinH> bitemyapp: jesus christ, fastest retweet in the west.
13:07:36 <ReinH> er, like
13:07:47 * bitemyapp salutes and grins
13:08:10 <sprocess> after doing "   (_, Just hout, _, _) <-       createProcess (proc "ls" []){ std_out = CreatePipe } ", how can I read from the host? do I use hGetContents? the documentation at http://hackage.haskell.org/package/base-4.8.1.0/docs/System-IO.html#v:hGetContents does not clearly specify whether it reads *ALL CONTENTS* or just "whatever that's currently generated"
13:08:34 <bitemyapp> ReinH: I'd tell you how I do it, but then I'd have to send a horde of hungry kittens after you.
13:08:54 <ReinH> that sounds fine
13:09:00 <ReinH> best death NA
13:09:37 * hackagebot graph-rewriting 0.7.7 - Monadic graph rewriting of hypergraphs with ports and multiedges  https://hackage.haskell.org/package/graph-rewriting-0.7.7 (JanRochel)
13:10:33 <xplat|work> sprocess: it will read until EOF and your program will block if you try to process (or buffer!) stuff that hasn't been generated yet
13:11:48 <pilne> can/wil a nix-based install of haskell tooling/libraries coexist alongside a stack installed setup? or is that just crazy ass silly talk?
13:11:59 <ReinH> sprocess: if streaming output is important, Conduit has its own versions of createProcess and family that do streaming IO.
13:12:12 <ReinH> pilne: yes, they should ignore each other
13:12:43 <pilne> good to know, nix seems like a better way to handle things that stack doesn't have than trying and praying with a package manager based install
13:12:50 <pilne> (systems package manager)
13:13:11 <ReinH> stack can use things it doesn't have though
13:13:15 <xplat|work> i guess you're not running NixOS then
13:13:16 <ReinH> you can add extra dependencies
13:13:35 <ReinH> you can even depend on things from github or your own filesystem.
13:13:52 <pilne> hmmm, i'm still damn new to stack and zazzy build systems in general
13:13:59 <pilne> but that is good to know
13:14:06 <xplat|work> yeah, stack.yaml is a pretty good way to handle things stackage doesn't have.  and writing stack.yaml isn't a bad way to handle things that don't have stack.yaml
13:15:04 <ReinH> stack by default uses a curated package set, "stackage". If you need things outside of it, you can add them explicitly to extra-deps. If you need things you can't find in extra-deps, you can add them to your list of projects with extra-dep: true to tell stackage that they are dependencies, e.g., https://github.com/reinh/reflex-dom-stack-demo/blob/master/stack.yaml#L15-L18
13:18:13 <Black0range> Could someone explain this error to me? http://lpaste.net/148841 
13:18:20 <pilne> sounds like stack is just as (if not more) robust than the cargo thing rust immplemented (my prefered alternative to c/c++ >.<)
13:18:32 <ReinH> cargo is pretty good
13:18:35 <ReinH> stack is also pretty good
13:20:48 <ReinH> Black0range: did you make Char an instance of Integral?
13:20:54 <Black0range> Nope :/ 
13:21:35 <ReinH> You didn't do so at Char.hs:32:10 ?
13:21:43 <ReinH> er no
13:21:44 <ReinH> sorry
13:21:58 <bitemyapp> ReinH: YOU HAD ONE JOB
13:22:02 <ReinH> bitemyapp: yeahhhhh
13:22:20 <Black0range> However i did use FlexibleInstances and UndecidableInstances but as far i understand they shouldn't do anything too weird?
13:22:33 <sprocess> xplat|work: okay, thanks!
13:22:39 <ReinH> Well, I can't explain it unless Char has an Integral instance
13:23:34 <ReinH> But I can't see your code so o_O
13:23:45 <Black0range> can paste it if you want to :)
13:24:11 <ReinH> seems like a good idea
13:24:15 <Black0range> http://lpaste.net/148842
13:24:32 <sprocess> Given a ProcessHandle, is there a an easy way to say: wait for this process for 3 seconds, if it's not done in 3 seconds, then kill it?
13:24:43 <sprocess> the "wait for process part" I see how to do, but not the "if not done in 3 seconds, then kill it" part
13:24:46 <EvilMachine> Hi. Does anyone have a GHC binary for ARM hardfloat? Preferably 7.10.3
13:24:49 <EvanR> sprocess: theres System.Timeout
13:24:49 <andromeda-galaxy> @hoogle Processhandle
13:24:51 <lambdabot> System.Process.Internals ProcessHandle :: (MVar ProcessHandle__) -> Bool -> ProcessHandle
13:24:52 <lambdabot> System.Process.Internals data ProcessHandle
13:24:52 <lambdabot> System.Process data ProcessHandle
13:25:02 <EvilMachine> (ARMv7 hard-float)
13:25:43 <EvanR> sprocess: you can also manually kill threads with async exceptions
13:25:48 <ReinH> Black0range: Oh. You claim that the result type is an instance of Integral
13:25:50 <EvanR> but timeout does it for you
13:26:03 <Black0range> ReinH: oooh i'm retarded
13:26:21 <Black0range> ReinH: Thanks and sorry :)
13:26:26 <ReinH> np and yw
13:29:13 <koz_> I have an Enum type with 5 values, and I wanna make it Hashable. What's a good and simple implementation of hashWithSalt in for such a type?
13:30:16 <EvanR> koz_: hash the fromEnum value?
13:31:44 <EvanR> it seems kind of useless to have the hash of one of 5 things
13:32:09 <ReinH> koz_: check the hashable docs
13:32:33 <ReinH> they answer your question
13:34:21 <Black0range> ReinH: Waaait i'm not retarded! 
13:35:11 <Black0range> ReinH: The return type should be an integer...
13:36:04 <ReinH> Black0range: you claim that i is Integral. You also claim that i can be Char.
13:36:16 <xplat|work> i wonder if there's some kind of way to pick 5 values so they will cause the least possible hash collisions when you use them in different circumstances
13:36:33 <xplat|work> failing that, you could just return like 0..4
13:36:35 <ReinH> You then also claim that any Integral is a HexChar, but you also separately claim that Char is a HexChar instance.
13:36:37 <Black0range> ReinH: No i only claim that the return type is of type Integer  
13:36:49 <ReinH> Black0range: You claim that both i and c are Integral.
13:37:07 <Black0range> ReinH: thus the "ord" function 
13:37:35 <xplat|work> i am not a number, i am a free character
13:38:09 <ReinH> Black0range: You claim that i must be Integral, but i can be Char, so then Char must be Integral, and if Char is Integral than its instance for Integral that you claim to exist causes an overlap with the instance Integral c => HexChar c instance.
13:39:17 <Black0range> No i claim that c is a Char and a is an Integral? 
13:39:26 <ReinH> You can argue with me, but you can't argue with GHC.
13:39:32 <xplat|work> nonono, the instance Integral c => HexChar c overlaps with HexChar Char whether there's an instance Integral Char or not
13:39:44 <ReinH> xplat|work: why?
13:39:48 <xplat|work> superclasses are not taken into account when determining overlap
13:40:04 <ReinH> Oh. Right.
13:40:09 <ReinH> Because classes are open.
13:40:11 <nkaretnikov> there's a nonempty list, but is there a nonempty map?
13:40:35 <Black0range> uh are there any way i can fix this, i'm really confused ... :)
13:40:40 <augur> is there a good way currently to define something approximately like "a type that has a 'field' foo :: A" in a way thats composable?
13:40:43 <ReinH> Black0range: ignore me, listen to xplat|work.
13:40:55 <Black0range> ReinH: sir, yes sir 
13:41:08 <augur> right now im just defining a bunch of type classes to serve that purpose but i think its probably not such a good idea to do that
13:41:15 <ReinH> Black0range: basically, Char *could* be made an instance of Integral, so it overlaps with Integral c => HexChar c.
13:41:23 <ReinH> e.g., GHC can't prove that you won't make it an instance later.
13:41:28 <ReinH> because typeclasses are open
13:41:41 <ReinH> er, make an instance for it.
13:42:06 <xplat|work> yeah, you want to make an instance HexChar c just for specific integral types
13:42:29 <xplat|work> and provide default methods to make it trivial to do so (i.e. empty instance declaration)
13:42:29 <ReinH> xplat|work: ty
13:43:12 <xplat|work> that way you can still provide nonoverlapping instances for specific types like Char
13:43:30 <Black0range> :( But i wanna be lazy 
13:43:39 <ReinH> but so does GHC and GHC wins ;)
13:44:00 <Black0range> :P
13:44:39 <augur> like, i guess in some sense what i'd like is some kind of anonymous record stuff, which i guess means i could use row polymorphism??? but im not sure how that'll work
13:44:48 <xplat|work> Black0range: it's still pretty easy, you write a few lines like 'instance HexChar Int' (that's all, no methods to provide, the defaults will do that)
13:45:34 <xplat|work> augur:  row polymorphism works pretty ok, assuming you have it
13:45:45 <Fuco> we need global variables in haskell... ioref is too annoying to pass around everywhere!
13:45:56 <augur> xplat|work: what im trying to do is genericize a bunch of dimensions to state
13:46:01 <ChristianS> Fuco: haha
13:46:14 <Fuco> or at least if IO could somehow magically summon them...
13:46:35 <ChristianS> IO can magically do anything!
13:46:40 <Fuco> right :D
13:46:59 <xplat|work> ChristianS: only things that are possible
13:47:01 <tdammers> I thought IO was mainly for launching missiles
13:47:07 <tdammers> (unsafely)
13:47:08 <augur> xplat|work: to basically factor out the different aspects of a type checker/elaborator's internal state, so that we can talk about type checkers that have defined values but also ones that dont, just by saying what kinds of state they have
13:47:15 <hpc> tdammers: magic missiles
13:47:19 <hpc> that can do anything
13:47:33 <hpc> (but mostly 1d4 damage per level)
13:47:37 <xplat|work> pure code can do the impossible, but when you try to print the result it either loops forever or raises an exception
13:47:44 <augur> xplat|work: im almost tempted to use some kind of lens, but im not sure that lenses let you talk about things generically like this
13:48:27 <xplat|work> augur: there's the field stuff and the classylens stuff, which are designed for different variants of this problem
13:49:15 <augur> xplat|work: im not sure entirely which i need. what are the criteria for deciding?
13:50:49 <hunteriam> does anyone have any guides on types and so on for ghcjs programs?
13:51:02 <hunteriam> also is `react` a good haskell lib to use to help?
13:54:10 <ReinH> hunteriam: Types for GHCJS are the same. React is not a Haskell lib.
13:54:30 <Black0range> xplat|work: When i try to add the Integral definitions as default it wants me to define class instances such as "num" for the "c" 
13:54:34 <ReinH> GHCJS programs are, for all intents and purposes, the same as other Haskell programs.
13:54:45 <ReinH> well, for almost all.
13:54:54 <xplat|work> augur: if you have groups of fields that naturally go together and you want to completely abstract over all but the last bit of the access path, you probably want classy lenses
13:55:39 <Cale> ReinH: Yeah, apart from the fact that you're allowed to FFI import arbitrary bits of Javascript code :)
13:55:49 <augur> xplat|work: what do you mean groups of fields ~ ?
13:55:50 <ReinH> Right, that. But the type system is the same type system, etc.
13:55:59 <Cale> right
13:56:31 <xplat|work> Black0range: there's a special GHC extension for default methods that require superclasses the class itself doesn't
13:56:32 <hodapp> tautological type systems are tautological, though.
13:57:39 <hunteriam> ReinH: Cale bad idea to use fromJSON instances?
13:57:45 <ReinH> No?
13:57:50 <Cale> what?
13:58:01 <hunteriam> Well I was afraid Aeson would be rather heavy weight
13:58:04 <hunteriam> for ghcjs
13:58:10 <ReinH> ghcjs is already heavy weight
13:58:13 <Black0range> xplat|work: are there somewhere i can find a list of extetions? 
13:58:14 <ReinH> it has to include a runtime
13:58:19 <Cale> No, it's an exceptionally good idea to use aeson client-side
13:58:28 <xplat|work> Black0range: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html <-- 7.6.1.4. Default method signatures
13:58:36 <ReinH> fromJSON instances are probably bad for handling XML though...
13:58:41 <hunteriam> Is it a bad idea to use GHCJS at all then? how heavy weight is the js Im going to serve?
13:58:58 <Cale> hunteriam: a few megabytes?
13:59:15 <hodapp> It's heavier than if you used, say, Fay, or Haste, or PureScript.
13:59:21 <hodapp> but really I'd say to just try it out and see.
13:59:23 <Cale> hunteriam: We're doing it in production, and it seems to work fine, anyway
13:59:26 <xplat|work> hunteriam: if you're just doing a few things and it might be a slow net connection, you might consider purescript instead
13:59:30 * geekosaur seems to get that much from google's front page any more
13:59:47 <ReinH> (most of which will be cached)
13:59:51 <luite> hunteriam: aeson is not ideal since it's a rather heavy wrapper
13:59:52 <xplat|work> it's probably the closest js thing to haskell that isn't haskell
14:00:03 <adam_> couldnt you reduce the the initial loading time by using server side rendering?
14:00:09 <kadoban> The project I'm playing with, which is â€¦ not super involved, but not trivial either, is 1.1M after closure-compiler, like 200kB gzipped
14:00:09 <Black0range> xplat|work: Thanks a lot!
14:00:19 <ReinH> luite: eh what would you know? ;)
14:00:34 <adam_> that way even if the page itself is larger you wouldnt notice it as it works almost immediately
14:00:37 <hunteriam> luite: alternatives?
14:00:52 <Cale> hunteriam: But yeah, we're using Aeson/TH generated instances for To/FromJSON in our projects and it's great.
14:01:17 <hunteriam> Cale: good support for AJAX?
14:01:25 <luite> hunteriam: well i started to work on a lib that would use native js objects internally, with a similar (or identical) API, for ghcjs-base, but I never finished it
14:01:25 <ReinH> I'm looking forward to the inevitable implementation of a "isomorphic web framework" (which is a terrible name, but I didn't choose it) using ghcjs.
14:02:30 <xplat|work> it'd be nice to have a cheaty hybrid aeson dealy for ghcjs
14:02:42 <adam_> hunteriam: You could also use websockets instead of ajax
14:02:48 <Cale> hunteriam: We're using reflex-dom and websockets and some XHR stuff
14:03:24 <ianhedoesit> ReinH: how many people typically go to those pdx func meetups?
14:03:33 <Cale> reflex-dom has some XHR stuff built-in now
14:03:44 <luite> anyway, i'm thinking of forking GHC 8.0 temporarily, to make it easier to adjust the simplifier for better JS code size, merge the changes back into GHC later on
14:03:50 <ReinH> ianhedoesit: Maybe 10-20? I haven't been in a while tbqh.
14:03:51 <Cale> We should eventually add our websockets stuff to it I think.
14:04:10 <ReinH> Cale: yes please.
14:04:11 <ianhedoesit> oh, neat. thanks
14:04:21 <ReinH> Cale: let me know if you want someone else to test it out for you
14:04:46 <hunteriam> Cale: adam_ https://github.com/mstksg/ghcjs-websockets
14:04:47 <adam_> Hey is there something akin to Falcor or Relay for Haskell?
14:04:47 <hunteriam> ?
14:05:26 <luite> ghcjs-base has websockets built in now, although it may not have all functionality
14:05:29 <adam_> Yeah I mean there are probably multiple libraries for it. I dont want to recommend one over the other because I havnt tried to many
14:05:47 <hunteriam> luite: https://hackage.haskell.org/package/ghcjs-dom-0.2.3.1/docs/GHCJS-DOM-WebSocket.html
14:05:59 <adam_> I think it shouldnt even be to hard to wrap the native javascript websocket stuff using the ffi
14:06:28 <orion> Is it considered bad form to have exceptions cross a library boundary?
14:06:38 <luite> hunteriam: ghcjs-dom is also useful since you can use the functionality with nativ apps (webkitgtk / jsaddle), but tends to be less convenient to use
14:06:38 <Cale> hunteriam: Yeah, if you're using reflex-dom, you'll probably want to build some sort of wrapper around whatever lower-level websockets library you're using, so that you can work nicely with Events or Dynamics
14:06:56 <luite> adam_: yeah, but that part of the code tends to be a bit error prone
14:07:23 <adam_> this could also be interesting https://github.com/jdnavarro/graphql-haskell
14:07:29 <Cale> ReinH: oh, right, there's already websocket stuff in the git develop branch of reflex-dom
14:07:51 <hunteriam> How do i use the JS ghcjs produces?
14:07:58 <Cale> ReinH: It's pretty basic, but it's there
14:08:17 <luite> hunteriam: you get an index.html file that runs your main action by default
14:08:26 <luite> hunteriam: or you can run all.js with node.js
14:08:32 <Cale> https://github.com/ryantrinkle/reflex-dom/blob/develop/src/Reflex/Dom/WebSocket.hs#L23
14:08:47 <adam_> If you want to minimize the amount of data fetches you do for slow mobile connections you should look into Facebooks solutions like React, Relay, Graph GL https://www.youtube.com/watch?v=9sc8Pyc51uU
14:08:56 <Fuco> how do people handle configuration files in haskell usually?
14:09:01 <ReinH> Cale: Yeah. I thought you might have abstracted that more or something.
14:09:20 <Fuco> I use xmonad and there your config is a haskell program where you call "xmonad", but I find that a bit overkill, or not?
14:09:24 <adam_> Im not saying you should actually use them, but recently facebook switched to a more functional appraoch for all their libraries and that could be a good basis for doing things in haskell
14:09:27 <Zekka|Sigfig> Fuco: The dead simple solution is to define a record type, then use â€˜readâ€™ to get its contents and Reader to expose it to your whole program 
14:09:46 <Zekka|Sigfig> er, that is, to turn its contents into a record again
14:09:50 <tdammers> Fuco: depends on the situation. If it's a CLI utility, I like to follow the dotfiles convention; for web applications, YAML is my go-to choice
14:10:05 <geekosaur> Fuco: yet there is a package that generalizes that mechanism: dyre
14:10:06 <Zekka|Sigfig> you would be using readfile to turn the file into a string
14:10:32 <Fuco> tdammers: what you mean by dotfiles?
14:10:37 <Cale> Fuco: I like xmonad's approach to configuration whenever it actually makes sense. Better to use Haskell than some complicated ad-hoc language for configuration.
14:10:38 <Fuco> tdammers: I mean, what format would you use
14:10:47 <geekosaur> I've generally done the readFile-read-ReaderT thing, yeh
14:11:17 <Fuco> I'm writing a daemon which will control media players, like fading one when you start another, then bringing it back up
14:11:24 <Cale> Fuco: If the configuration is simple, you might go with YAML or JSON or something.
14:11:25 <xplat|work> but sometimes you don't need a complicated language, and then you're better off using a simple language instead
14:11:26 <Fuco> I'm sure it exists in modern DMs but... I don't use those :D
14:11:49 <xplat|work> you ... actually might want to use dyre
14:11:55 <tdammers> sounds like the kind of thing that doesn't need to be portable
14:12:08 <Cale> Fuco: Or heck, you can just use Read and Show instances sometimes if it's really simple :P
14:12:38 <Fuco> okey, I think I will go with Read + Reader first (I already use ReaderT, the config is just in the file atm)
14:12:46 <Fuco> I was just thinking if it isn't silly :D
14:12:57 <Fuco> xmobar uses something similar but afaik they had their own parser for the "record"
14:13:09 <Cale> Fuco: ReaderT might be silly relative to just passing your config around as a function parameter
14:13:29 <hunteriam> Cale:  luite  adam_  what if I need to build a bunch of different js for a bunch of different pages on my site?
14:13:49 <tdammers> indeed... ReaderT is often more hassle than it's worth
14:14:07 <Cale> I would think hard about whether it was really going to be an improvement -- note that if you ReaderT over IO, then you have to liftIO all your IO actions, which easily is as much hassle as the function parameters would have been
14:14:18 <Fuco> well actually I use RWS... I figured having a reader there for free is no problem
14:14:19 <Cale> and it's not like ReaderT does anything to make your types any nicer either
14:14:42 <adam_> That sounds like more of an architecture decision rather then a language issue
14:14:51 <Cale> I tend to strongly question whether transforming IO is a good idea at all these days.
14:14:57 <adam_> Have you looked into how single page applications are built?
14:14:59 <Fuco> hmm
14:15:34 <Cale> Sometimes, if you're willing to make enough of an investment into building a library of actions so that you don't have to lift stuff, it's okay.
14:15:35 <Fuco> it's tempting though, these monad transformers 
14:15:47 <hunteriam> adam_: well I have designed my backend so that that should be possible..
14:15:54 <Cale> But otherwise, there are lots of other ways to do the same things which are often better
14:16:02 <Cale> Depending on what sort of aspects of it attract you
14:16:02 <hunteriam> adam_: i dont know how id transition my page layout though
14:16:08 <hunteriam> adam_: im guessing js does all the heavy lifting?
14:16:23 <xplat|work> generally ReaderT is only worth it where you're using a transformer stack anyway
14:16:29 <Fuco> MonadIO does the heavy lifting
14:16:32 <Cale> e.g. you can pass around a record of the operations for manipulating what would be your state and environment.
14:16:46 <hunteriam> Fuco: ?
14:16:54 <Fuco> nevermind, a joke
14:17:02 <Cale> and then construct a record of those operations at the top level (perhaps using IORefs) and pass it down
14:17:15 <adam_> hunteriam: Yeah I would look into a lot of different libraries for making single page applications so you can learn the best practices
14:17:32 <Fuco> Cale: what you mean record of operations manipulating your state
14:17:33 <Cale> If you like the idea that some things are abstracted over the choice of monad a bit (i.e. you can skip the MonadIO constraint in some places)
14:17:37 <adam_> but generally you have something called a router which takes the current url and allows you to render a view based off that
14:17:43 <adam_> so "/" would be your home page
14:17:56 <xplat|work> which ones are there besides angular anyway?
14:18:16 <adam_> Functional ones are poppping up everywhere these days
14:18:22 <adam_> React, Vue, Cycle
14:18:30 <adam_> Look into how Elm does it
14:18:35 <A31415> people, is there any library which saves raw data types? like save [1,2,3] will save raw list in file, just like it is in memory.
14:18:38 <adam_> Riot
14:18:48 <adam_> Clojurescript with Om Next
14:18:52 <Cale> Fuco: I mean, the very simplest thing would be something like having a record with fields like  setFoo :: Foo -> IO ()  and  getFoo :: IO Foo -- or abstracting over the choice of monad, you can replace IO there with m, and make that a type parameter to the record type
14:18:58 <adam_> all of these things would be possible with Haskell as wel
14:19:04 <adam_> just seems like it hasnt happened yet
14:19:24 <Cale> Fuco: but usually in context, you'll have something a bit more specific than a setter and getter (maybe not and that's okay, but perhaps you want to ensure validity, for instance)
14:19:26 <adam_> The basic idea is that your JS produces your view rather then having html
14:19:44 <adam_> and your view is a bunch of pure functions which produce virtual dom
14:19:44 <tdammers> adam_: I guess the main problem is that getting ghcjs working wasn't straightforward at all until quite recently
14:19:46 <Fuco> Cale: I see, and it would use for example IORef for storage
14:19:54 <Cale> Fuco: yeah
14:20:01 <Fuco> so basically I would pass around an object as in OOP 
14:20:05 <Fuco> interface + opaque data
14:20:15 <adam_> then you need a diffing algorithm which can compute the minimal change from virtual dom a to virtual dom b
14:20:25 <adam_> that diff is all you actually mutate in the real dom
14:20:33 <xplat|work> well, there are a lot of 'interesting' decisions about how to do state in these cases
14:20:41 <Cale> Yep, this is the classical FP way of encoding OO :)
14:21:19 <adam_> However, like I said almost all of this is already taken care off so idk if it is worth doing all of the hard work yourself
14:21:21 <hunteriam> adam_: sounds like a lot of work
14:21:30 <xplat|work> like, if you use State, you force your state to be single-threaded, but at the same time you don't have to worry about accessing it from multiple threads since that doesn't even come up
14:21:44 <Cale> and you get people who start using fancy terms like "van Laarhoven free monads", but really that's most of the idea :)
14:21:45 <hunteriam> adam_: in haskell its done too?
14:21:46 <adam_> instead I would look into making a simple wrapper for Cycle/Riot/Vue/React/OmNext/Elm Html/whateer
14:21:58 <Fuco> I'll think about it at work tomorrow... we're having a big loooooong meeting over some nonsense again
14:22:05 <xplat|work> if you do these objects with encapsulated IORefs you inherit all the opportunities and also problems of traditional OO
14:22:20 <Fuco> I will again say we should move to FP and they will say again no and then I can stop listening and draw my flowcharts...
14:22:26 <adam_> I honestly dont know hunteriam. I just started with Haskell recently and havnt dont to much front end work with it yet
14:22:37 <Cale> (you can then abstract things over a choice of such a record of operations and get the "van Laarhoven free monad" thing I mentioned...)
14:22:44 <tdammers> I would say that this is just plain and simple OO done in Haskell
14:22:45 <Zekka|Sigfig> Fuco: Just remember: be nice to your coworkers!
14:22:51 <tdammers> not a lot of FP about it
14:23:08 <adam_> The basic thing would be to store the current "dom representation" as a tree
14:23:13 <Zekka|Sigfig> Itâ€™s hard to trust someone whoâ€™s saying you should make a decision you donâ€™t understand yet
14:23:25 <Cale> tdammers: I mean, from one perspective, you're passing around records of functions as first class data
14:23:34 <Cale> tdammers: that's kinda FPish :)
14:24:08 <Cale> But yeah, it's not so much the style of sum types and pattern matching sort of FP
14:24:11 <Fuco> but who is van laarhoven?!
14:24:26 <Cale> http://twanvl.nl/
14:24:28 <Cale> ^^ that guy
14:24:32 <xplat|work> twanvl is van laarhoven
14:24:33 <johnw> I would also say that records of functions are more OOish, since you're parameterizing the implementation of an interface
14:24:40 * hackagebot aeson-diff 0.1.1.3 - Extract and apply patches to JSON documents.  https://hackage.haskell.org/package/aeson-diff-0.1.1.3 (ThomasSutton)
14:24:48 <Fuco> a phd student and already has a monad named after him?!
14:24:50 <Fuco> what a world...
14:24:58 <Fuco> these days they hand them out like candy
14:25:09 <Cale> But yeah, this is really the essence of OO -- designing a data type around how it is to be used, rather than how it is to be constructed.
14:25:21 <xplat|work> with a name like that he sounds like a 800 year old professor with a long white beard, but actually hangs out on irc :)
14:25:33 <Fuco> xplat|work: exactly what I expected :D
14:25:44 <kadabra> Hi, I'm trying to solve problem 9 in https://wiki.haskell.org/99_questions/1_to_10. Here is my solution: pick' xs = foldl (\acc x -> if (x==head acc) then ([x : head acc] : [tail acc]) else ([x] : acc)) [[last xs]] xs. Can anyone spot why it does compile? Unfortunately I just don't get what the compiler is telling me
14:25:45 <Fuco> dutch just have a thing for intimidating CS presence...
14:26:03 <adam_> Have you guys used https://github.com/ryantrinkle/reflex-dom because that seems likes its based off of the virtual dom project right?
14:26:16 <tdammers> "bundle state with behavior"
14:26:40 <xplat|work> the true essence of OO is 'draw UML diagrams'
14:27:06 <c_wraith> tdammers, if you twist that a tiny bit, you get "behavior is part of the state". 
14:27:21 <Cale> adam_: I use it every day at work
14:27:36 <Cale> adam_: I don't know what the virtual dom project is
14:28:02 <adam_> Like do you manually mutate the dom?
14:28:08 <Cale> no
14:28:09 <xplat|work> c_wraith: or 'state is change in behavior'
14:28:17 <adam_> Or do you just write pure functions and it takes care of all the mutation under the covers
14:28:33 <adam_> if its the latter they probably use virtual dom
14:28:37 <c_wraith> as far as I can tell, "virtual dom" is a fancy code word for "separating model and view in the Javascript" 
14:28:45 <Fuco> xplat|work: draw UML and autogenerate java out of it
14:28:49 <Cale> adam_: You declaratively specify what the DOM should be in such a way that accounts for how things will change over time all at once, and it takes care of making the updates.
14:28:50 <adam_> No virtual dom is something very specific
14:28:58 <adam_> Normally you mutate the dom directly.
14:29:13 <adam_> With virtual dom you have an in memory representation of the dom tree
14:29:34 <adam_> Then every time you produce a new tree they find the smallest change from the two trees
14:29:40 * hackagebot mfsolve 0.3.2.0 - Equation solver and calculator à la metafont  https://hackage.haskell.org/package/mfsolve-0.3.2.0 (KristofBastiaensen)
14:29:42 * hackagebot hdevtools 0.1.2.2 - Persistent GHC powered background server for FAST haskell development tools  https://hackage.haskell.org/package/hdevtools-0.1.2.2 (ch1bo)
14:29:43 <xplat|work> virtual dom is curses for web browsers
14:29:51 <adam_> Using that difference the virtual dom can mutate the real dom
14:29:53 <Cale> adam_: There's no explicit mutation involved with reflex
14:30:03 <Cale> adam_: You leave all of that to the library
14:30:13 <adam_> But from ur perspective it looks like on every change the whole dom is blown away and you "rerender" with the current state
14:30:53 <Cale> Yeah, no, you don't even transform the whole dom at once
14:31:09 <adam_> Well it does somehow otherwise nothing would ever change
14:31:10 <Cale> You just specify what the document *is*, in a way which accounts for changes over time.
14:31:12 <adam_> you just dont do it
14:31:17 <c_wraith> you've just described separating model from view/controller in one super-brittle browser only method. 
14:31:21 <xplat|work> adam_: reflex doesn't use diffing between 'current rendering dom' and 'last rendered dom', it computes which changes to make more directly
14:31:42 <Cale> There can be parts of the page which depend on dynamic values that represent things which are going to change over time.
14:32:03 <Cale> and the library makes sure that changes to those things are propagated through to the DOM
14:32:16 <adam_> yeah but all of the mutation probably happens in one update function right? with some kindof event dispatching system like FRP
14:32:28 <Cale> Yeah, reflex is an FRP system
14:32:52 <mauriziozandron> ciao
14:32:57 <adam_> So you take the event + the current state and return the new state right?
14:32:58 <xplat|work> 5:29 PM <xplat|work> virtual dom is curses for web browsers
14:33:08 <rschnck> Why does ghci throw an error why I try to load this: http://codepad.org/lBbC8an2
14:33:08 <mauriziozandron> !list
14:33:13 <mag__> What is the preferred versioning mechanism used by the Haskell community? It seems to me that nobody uses semver (http://semver.org/)
14:33:13 <Cale> adam_: No, as the user of the library, *you* don't.
14:33:43 <c_wraith> mag__, the package versioning policy(pvp) 
14:33:51 <xplat|work> adam_: no, the user of the library never sees the 'current DOM' or anything like that
14:33:52 <Clint> mag__: https://wiki.haskell.org/Package_versioning_policy
14:34:04 <mag__> c_wraith, yes
14:34:11 <geekosaur> rschnck, because args is outdented to less than the indentation of "mainWIth"
14:34:11 <c_wraith> mag__, very similar to semver, except the major version gets two digits. 
14:34:15 <Cale> adam_: An example would perhaps make it clearer...
14:34:32 <adam_> Like if I have a counter
14:34:40 <adam_> it has a default state of 0
14:34:47 <adam_> then when you click a button for example
14:34:50 <c_wraith> mag__, which turns out to be handy for differentiating technically major updates from actually major updates 
14:34:50 <mag__> humble question, why not semver?
14:34:53 <adam_> it dispatches an increment action
14:35:02 <c_wraith> mag__, it predates semver
14:35:05 <xplat|work> hm, does PVP allow versions where each of the 4 numbers is a release date?
14:35:19 <c_wraith> mag__, haskell is not a young language. 
14:35:23 <adam_> an increment action is dispatched
14:35:38 <adam_> Then you could essentially think about update like a fold from the past
14:35:41 <Cale> adam_: You would have an Event t () created when you create the button, which is a value that represents all the button clicks that happen
14:35:45 <adam_> you take the previous state of the counter
14:35:51 <rschnck> geekosaur: I don't quite understand. I was under the impression as long as it's indented more than the "where" it wouuld be fine. For the record, I don't really understand the code yet. I was just typing an example from real world haskell. 
14:35:57 <adam_> and the action "buttonCLicked" and return the state + 1
14:36:24 <adam_> https://github.com/evancz/elm-architecture-tutorial/
14:36:33 <adam_> I have trouble explaining shit but that shows what I mean
14:36:43 <mag__> c_wraith, indeed
14:36:53 <Cale> adam_: and you'd use something like foldDyn to get a Dynamic t Integer representing the current state of the counter
14:37:02 <Cale> foldDyn :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> b) -> b -> Event t a -> m (Dynamic t b)
14:37:08 <geekosaur> rschnck, layout is a bit more precise than that. you are still in the "block" defined by the where clause, but because it's less indented than the start of "mainWIdth function =" it's outside that definition
14:37:25 <mag__> Clint, nice URL, thanks
14:37:29 <xplat|work> adam_: no, you don't do that.  you take a 'buttonclicked' event stream and return a 'counter' behavior -- perhaps something like 'countDyn buttonclicked' -- and then the library worries about all the events for you
14:37:31 <Cale> takes a combining function (a -> b -> b), an initial value of type b, and an Event of values of type a, and produces a Dynamic value of type b
14:37:41 <adam_> exactly Cale
14:37:44 <adam_> thats what I wanted to say
14:37:46 <geekosaur> "do" allows some flexibility in indentation, but going outside "mainWIth"'s indentation terminates it
14:37:47 <Cale> which starts out as the initial value, and is updated whenever the Event fires
14:37:58 <rschnck> geekosaur: Hmm. I see. Thanks for the explanation. :)
14:38:06 <Cale> and then you'd use that Dynamic to construct another part of the page for displaying the counter
14:38:29 <adam_> your "state" is like a signal which and the view just represents the "current" value of the signal
14:38:47 <adam_> did you guys see the link I posted
14:40:06 <glittershark_> I realize this is a bit of an unanswerable question, but is there a reason lazy evaluation in GHC isn't clever enough to only evaluate an incremented value as deep as it's needed? ie, why doesn't `length (repeat 1) > length [1]` halt?
14:40:24 <Haksell> Hello !
14:40:40 <doomlord> you sell hacks?
14:40:44 <mag__> haha
14:41:06 <Haksell> Utterly !
14:41:10 <Zekka|Sigfig> glittershark: Haskell doesnâ€™t use unary numbers, which are how people traditionally csolve that problem afaik
14:41:21 <Cale> adam_: http://lpaste.net/148845
14:41:30 <glittershark_> by unary numbers you mean like `data Nat = Nat | Succ nat`?
14:41:38 <glittershark_> Nat*
14:41:42 <Zekka|Sigfig> Yeah. FYI it just treats numbers as opaque things
14:41:47 <Zekka|Sigfig> er, AFAIK*
14:41:55 <adam_> oh ok that looks very nice and clean
14:42:00 <glittershark_> is there a reason for that?
14:42:06 <Cale> adam_: One sec, and I'll build this with ghcjs so you can try it :)
14:42:10 <glittershark_> I guess this is probably a question for GHC core devs
14:42:12 <Zekka|Sigfig> (Iâ€™m being cautious because there might be another principled way to do induction or whatever to solve your problem)
14:42:34 <glittershark_> this is more of an academic question than a practical one
14:42:35 <glittershark_> :P
14:42:40 <adam_> how does it handle CSS though? Are you able to use Haskell to produce the style of elements?
14:42:46 <Zekka|Sigfig> I think it has more to do with the language itself than with GHC, since it probably wouldnâ€™t be right to make that sort of thing terminating if the language said it was nonterminating
14:42:48 <adam_> Like a React CssinJS type of thing
14:43:11 <Zekka|Sigfig> but afaik itâ€™s kind of an arbitrary decision, possibly because autoconverting between the unary interface and non-unary representations for the processor might have seemed scary
14:43:14 <glittershark_> it seems intrinsic to lazy evaluation to allow doing that kind of thing
14:43:16 <glittershark_> yeah
14:43:20 <Zekka|Sigfig> (e.g. Idris uses unary numbers)
14:43:23 <Cale> adam_: http://cale.yi.org/counter.jsexe/
14:43:26 <glittershark_> huh
14:43:31 <glittershark_> I should try running that line in idris
14:43:39 <glittershark_> (now to install Idris)
14:43:59 <Zekka|Sigfig> Idris isnâ€™t lazy by default afaik, of course
14:44:00 <dolio> Idris is strictly evaluated by default, so I doubt it's going to work there.
14:44:13 <glittershark_> oh
14:44:16 <glittershark_> aww, ok
14:44:25 <Cale> adam_: reflex-dom tends to treat local style as Dynamic t (Map String String) values, but most of your static CSS you'll probably just handle with something else and include
14:44:27 <Zekka|Sigfig> It wouldnâ€™t be too hard to define a lazy unary number type in Haskell, although it would perform *really badly* without support from the implementation
14:45:02 <glittershark_> they exist all over the  place in the type system
14:45:11 <icen> Unary numbers are converted to actual numbers in idris (but not in the repl, iirc), because they're so damn slow
14:45:26 <adam_> Could I do something similar to this https://github.com/adam-r-kowalski/elm-style
14:45:33 <adam_> I made a library for writing CSS in Elm
14:45:35 <glittershark_> I guess performance wins in this case, which doesn't surprise or bother me
14:45:41 <Zekka|Sigfig> glittershark: AFAIK when youâ€™re doing counting with types, youâ€™re usually doing it with small numbers in cases where it wouldnâ€™t affect the performance of the running application
14:45:45 <adam_> Its not great but it beats writing raw CSS
14:45:58 <Zekka|Sigfig> Of course, you can have a unary interface with ordinary numbers beneath, although I donâ€™t know if you can do that with a *lazy* unary interface
14:46:09 <glittershark_> yeah laziness mucks it all up
14:46:44 <adam_> here is the relevant page actually https://github.com/adam-r-kowalski/elm-style/blob/master/src/elm/Style.elm
14:47:08 <Zekka|Sigfig> If you had a stack of 1000 succs on the type level, and squared the number, it would probably perform well enough for your program to still work even though thatâ€™s 1mil operations
14:47:22 <Zekka|Sigfig> however, at runtime, thatâ€™s a million times slower than actually operating on numbers
14:47:28 <glittershark_> yep
14:47:30 <Cale> adam_: There are a few things of ours which use a library called Clay
14:47:42 <Cale> http://hackage.haskell.org/package/clay
14:47:48 <Zekka|Sigfig> (and it probably uses a million times more space)
14:47:53 <glittershark_> all this makes me wish I knew the kind of stuff that's necessary to implement programming languages
14:48:05 <Zekka|Sigfig> glittershark: Did you try doing it before? Itâ€™s not too hard
14:48:10 <glittershark_> so I could just go try to implement automatic conversion of unary to actual numbers in a language
14:48:20 <glittershark_> nope, haven't unlocked that achievement yet :)
14:48:22 <adam_> oh wow clay looks amazing
14:48:25 <glittershark_> I want to though!
14:48:28 <Zekka|Sigfig> Iâ€™m not an expert, but you donâ€™t need to be an expert to play around with programming language implementation
14:48:33 <glittershark_> yeah
14:48:36 <glittershark_> you just need to have spare time
14:48:40 <glittershark_> which, y'konw
14:48:45 <Zekka|Sigfig> Iâ€™ve mostly done dynamic language stuff though. (I implemented CHR last weekend)
14:48:46 <icen> Implementing a really small and simple language isn't too hard, but it will be pretty deprived of features and probably very slow
14:48:49 <ph88> experts have spare time ?
14:48:57 <adam_> can you make it dynamic though?
14:49:05 <adam_> like as values change over time can you update the css
14:49:38 <Cale> adam_: sure
14:50:03 <Zekka|Sigfig> s/I implemented CHR/I implemented the easy subset of CHR
14:50:12 <glittershark_> heh
14:51:41 <Cale> adam_: one of the most basic ways to do that is  elDynAttr :: MonadWidget t m => String -> Dynamic t (Map String String) -> m a -> m a
14:51:41 <adam_> alright wlel i gotta head out so ill talk to yall later
14:59:41 * hackagebot gitrev 1.2.0 - Compile git revision info into Haskell projects  https://hackage.haskell.org/package/gitrev-1.2.0 (AdamFoltzer)
15:02:31 <hunteriam> Cale:  will reflex-dom work with the 12-30 ghcjs release?
15:03:02 <mgsloan> ghcjs-improved-base-2 branch of reflex-dom will
15:03:07 <sprocess> how do I convert Char (i.e. '\n') to a Data.Word.Word8? Google tells me to use unsafeCoerce, but I don't think that's what I want
15:03:19 <hunteriam> mgsloan: can i install that with stack?
15:03:35 <Gurkenglas> http://hayoo.fh-wedel.de/?query=Char+-%3E+Word8
15:03:51 <Clint> sprocess: can you guarantee that it's an 8-bit character?
15:03:52 <mgsloan> hunteriam: Yes, either by using a git submodule of reflex-dom, or using a git package location in stack.yaml
15:04:09 <hunteriam> Gurkenglas: hayoo?
15:04:27 <hunteriam> mgsloan: submodule?
15:04:30 <Gurkenglas> What question is in there o.o?
15:04:39 <hunteriam> Gurkenglas: what is hayoo? not hoogle?
15:04:46 <Clint> correct, hayoo is not hoogle
15:06:03 <mgsloan> hunteriam: Google search git submodules to find out about em.  Probably best to just use stack's support for this - take a look at the "location:" examples here http://docs.haskellstack.org/en/stable/yaml_configuration.html#packages
15:06:55 <ReinH> mgsloan: see my example project where I configured this already
15:07:20 <ReinH> You just need to change the GHC release url.
15:07:42 <Zekka|Sigfig> sprocess: Fair warning:
15:07:56 <Zekka|Sigfig> > length ([minBound..maxBound] :: [Char])
15:07:58 <lambdabot>  1114112
15:07:58 <ReinH> er, hunteriam ^
15:08:15 <ReinH> > ord maxBound
15:08:17 <lambdabot>  1114111
15:08:17 <mgsloan> Yup, using ReinH's https://github.com/reinh/reflex-dom-stack-demo seems like a good way to skip this setup stuff
15:08:40 <ReinH> mgsloan: yes, let my hours of trying to figure this out save other people from spending hours figuring this out ;)
15:08:42 <Zekka|Sigfig> Converting char to word8 will do lots of exciting and fun stuff if your character is not in-range
15:08:55 <hunteriam> https://www.irccloud.com/pastebin/cdDWIgdL/
15:08:57 <ReinH> Fun in the dwarf fortress sense.
15:09:01 <hunteriam> >stack setup
15:09:20 <ReinH> hunteriam: do you have node installed?
15:09:39 <hunteriam> ah
15:10:14 <EvanR> Fun in the C sense
15:10:53 <EvanR> wait, i thought Word8 was implemented as a Word
15:10:54 <Zekka|Sigfig> > [maxBound] :: String
15:10:56 <lambdabot>  "\1114111"
15:11:03 <Zekka|Sigfig> Well that was underwhelming.
15:11:28 <jle`> hunteriam: just a fair warning, the ghcjs-websockets library is a bit out of date since ghcjs-base was re-organized
15:11:47 <hunteriam> jle`: thanks, not gonna use em though
15:11:56 <jle`> coo :)
15:12:37 <EvanR> ah, then zeroed out
15:14:34 <Cale> hunteriam: I don't know exactly which dates... but I think for right now you still have to use 0.1
15:14:43 <sprocess> https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Lazy.html#v:split <-- how can the possibly work ? how does haskell know to read those '\n' as a Word8 instead of a Char ?
15:16:06 <geekosaur> I think the docs were just copied from Data.List and not corrected
15:16:19 <c_wraith> sprocess, I think those docs were copied from the .Char8 module and not fixed  
15:16:27 <geekosaur> or Char8, yeh
15:17:04 <alpha123> Has anyone here gotten Yi compiling on windows? I know it should theoretically work but I can't get it to stop complaining about a few libraries (gobject, intl, something else) that I have installed
15:18:50 <ReinH> fwiw my project includes very carefully selected versions of ghcjs, reflex-dom, etc on the basis of actually working together. YMMV if you change any of these.
15:19:24 <m1dnight_> Does anyone happen to know the author of https://github.com/serras/emacs-haskell-tutorial ?
15:19:28 <ReinH> But if you make it work with a newer GHCJS or newer reflex-dom or etc, pull requests are very much welcome.
15:20:23 <ReinH> m1dnight_: no, but many of us use emacs, so you might get an answer anyway
15:25:09 <andromeda-galaxy> For anyone else trying to build ghcjs from the git repo: do not use Node.js v5.3.0!
15:25:14 <andromeda-galaxy> v5.0.0 appears to work, however
15:25:24 <ReinH> huh
15:30:25 <luite> andromeda-galaxy: ok good that it works now. i'll check the IO stuff for the base and process libraries with 5.3.0 soon
15:32:16 <andromeda-galaxy> luite: great, thanks!  I mentioned one other error that's pretty insignificant but weird in #ghcjs, because I was curious if you'd seen that one before
15:34:42 * hackagebot blatex 0.1.0.2 - Blog in LaTeX  https://hackage.haskell.org/package/blatex-0.1.0.2 (2016rshah)
15:35:18 <jle`> i'm on 0.12 so i'm good
15:35:21 <jle`> how did that even happen
15:35:39 <luite> andromeda-galaxy: did you open issue #453?
15:36:30 <Kaidelong> is there any particular reason why the mtl doesn't generalize catches from Exception?
15:37:00 <andromeda-galaxy> luite: I didn't...
15:37:24 <andromeda-galaxy> luite: I haven't opened any issues about this yet, since I was worried that i was misinterpreting the directions somehow
15:38:07 <geekosaur> Kaidelong, I think it's not really possible? see MonadBaseControl (monad-control package)
15:38:17 <geekosaur> need more machinery to get exceptions right
15:38:25 <geekosaur> need still more to get bracket right
15:39:42 * hackagebot blatex 0.1.0.3 - Blog in LaTeX  https://hackage.haskell.org/package/blatex-0.1.0.3 (2016rshah)
15:40:06 <luite> andromeda-galaxy: ok, then you probably helped someone else. anyway i'll investigate soon, probably not too hard to fix once i can reproduce it
15:40:17 <ReinH> luite: btw thanks again for ghcjs, it is truly magical.
15:40:34 <ReinH> By which I of course mean sufficiently-advanced-technology-ical.
15:40:46 <ReinH> luite: also when do you want to get on the haskellcast and talk about it? :D
15:41:44 <andromeda-galaxy> luite: thanks for looking into it, sorry I didn't see that issue earlier.  Again, thanks for creating, maintaining, and supporting ghcjs!
15:44:55 <luite> ReinH: hmm, i'm giving a talk at compose conference in feb (about the repl, ghcjsi), and the coming months are probably going to be codegen-themed, i hope i have a few interesting improvements to talk about in ~may, would that be ok?
15:47:30 <luite> also i'm going to be in the US for a bit after compose :) (does anyone happen to have a good apartment for haskell hacking near a good ski field? ;) )
15:49:13 <ReinH> luite: Whenever you want :)
15:49:43 * hackagebot blatex 0.1.0.4 - Blog in LaTeX  https://hackage.haskell.org/package/blatex-0.1.0.4 (2016rshah)
15:51:39 <mgsloan> Haskelling and snowboarding sounds good to me :D
15:52:04 <ReinH> agree
15:52:40 <ReinH> Lambdaconf is in Boulder CO...
15:53:00 <ReinH> I'm going to do my best to go to that one
15:54:04 <ReinH> wait that was 2015 :(
15:54:09 <ReinH> WHAT YEAR IS IT
15:54:25 <ReinH> Oh phew, it's in Boulder again this year.
15:55:16 <ReinH> also the new site looks great
15:56:48 <begriffs> I'm working with ByteStrings and would like to mark certain of them as "escaped" meaning safe for use in certain situations. Some of my functions will produce Escaped strings and others will consume them. What's the best way to represent this in the type system? Just `type Escaped = ByteString` or something else like phantom types?
15:57:20 <geekosaur> "ype" doesn't give you anything but an alias. I'd consider a phantom type but it depends on exact use
15:57:28 <geekosaur> there's also newtype
15:57:39 <geekosaur> which may be what you were thinking of with "type"
15:58:01 <begriffs> Yeah I thought it would be nice to be able to have all the old instances like Monoid and stuff.
15:59:23 <geekosaur> newtype with deriving may be your answer then. you could derive through the instances but the compiler would still keep you from passing an unchecked ByteString to something expecting a checked one
15:59:29 <begriffs> I wonder if there's already a library that provides the ideal thing for this. I'm doing it in the context of SQL but maybe a web framework has something they use that means safe for embedding into HTML.
16:00:15 <bitemyapp> https://twitter.com/justicefries/status/686698543340363776 Anybody that has wanted a copy of the book and hasn't got it because they can't afford it?
16:01:20 <andromeda-galaxy> next up: integrating code built with ghcjs and stack with yesod
16:01:21 <Zekka|Sigfig> bitemyapp: Iâ€™ll bug my Slovenian friend later, although he hasnâ€™t been online lately
16:01:38 <Ashy> Ooh, new haskell book?
16:01:41 <hunteriam> ghcjs is not capable of outputting multiple applications is it?
16:02:20 <bitemyapp> Zekka|Sigfig: that's a good idea, we try to do what we can to get it into the hands of people in high vat areas or that have a nasty currency exchange issue.
16:02:34 <bitemyapp> Zekka|Sigfig: have them email us at: http://haskellbook.com/support.html
16:02:40 <Ashy> How much is it?
16:02:51 <Zekka|Sigfig> Sure. I also know a guy from Bulgaria but I think he moved to NY
16:03:01 <bitemyapp> Ashy: $59
16:03:03 <Zekka|Sigfig> he probably makes more money than me
16:03:07 <Ashy> The site says it's 80% done?
16:03:08 <bitemyapp> Ashy: it's verrrryyyyy comprehensive.
16:03:14 <bitemyapp> Ashy: currently 80% done yes.
16:03:24 <Ashy> Cool
16:03:35 <Zekka|Sigfig> From the section I read (which is only the portion available for free) I would recommend the book, but you should probably read the free section too to be sure you like it, if youâ€™re interested
16:04:10 <Ashy> I'm assuming that's not programmer 80% where that's only 20% of the effort left?  :p
16:04:20 <bitemyapp> Zekka|Sigfig: We also have a _lot_ of very happy readers, but definitely check out the sample.
16:04:39 <Zekka|Sigfig> Assuming the sections listed as done are as good as the sections I read, the 80% is probably already enough to make the book worth buying
16:04:48 <Ashy> bitemyapp: Where's the purchase link?
16:04:52 <bitemyapp> Ashy: the book is completed in a fairly linear fashion. If we work with a university press, the final editing and review phase might be gnarly, but it's legit in a very readable state, huge improvement over existing resources.
16:05:01 <bitemyapp> Ashy: gumroad link here: http://haskellbook.com/
16:05:28 <Zekka|Sigfig> (conflict of interest disclaimer: the company I work for has an office on the floor above the office of the company bitemyapp is distributing his book with)
16:05:38 <Ashy> Ah cool, cheers
16:05:54 <bitemyapp> Zekka|Sigfig: that qualifies as conflict of interest?
16:06:03 <bitemyapp> Zekka|Sigfig: if they go out of business do you lose your office or something? :P
16:06:04 <Zekka|Sigfig> Shh! The lawyers will hear us.
16:06:09 <bitemyapp> LOL
16:06:29 <Zekka|Sigfig> No way. I hear a lot of dudes have actually been squatting around taking bets on when they go out of business and vanish from the face of the earth
16:06:35 <Zekka|Sigfig> (Iâ€™m not in that office so I donâ€™t know)
16:06:53 <bitemyapp> Zekka|Sigfig: well, they contracted pretty severely recently right? I've been looking at alternatives just in case.
16:06:55 <Zekka|Sigfig> We bought them pizza once so in SF terms we own them.
16:07:15 <Zekka|Sigfig> bitemyapp: I donâ€™t really know much about it, honestly
16:07:38 <Zekka|Sigfig> there was nothing obviously wrong with them when I visited, there was just the lingering question of â€œhow big is your revenue stream, actually?â€ that we never got answered
16:08:23 <ReinH> bitemyapp, Ashy: It's 80% done, so now he only needs to finish the other 80%.
16:09:28 <bitemyapp> Ashy: more seriously, there's 1156 pages and 26 chapters in the current release, there are six chapters remaining. Except for the most recent release, we've been _extremely_ regular and prompt about the releases, usually pushing out 100+ pages per month
16:15:22 <Ashy> You've sold me haha
16:15:45 <Ashy> I don't really need another learn haskell book but I'm happy to support the effort with a purchase
16:15:55 <lethjakman> bitemyapp: How can you develop this book for $60, but university texts cost over twice that?
16:16:43 <justicefries> lethjakman: university authors take very small royalties, way smaller than that.
16:16:52 <justicefries> lethjakman: publishers take the lion's share, so this is actually very beneficial to them.
16:16:58 <Ashy> On a side note, something like coronasdk for haskell would be sweet, is there an effort for haskell app framework that targets ios and Android yet?
16:17:05 <justicefries> I mean, not when they go to print, but this is almost 100% royalties to them.
16:17:13 <lethjakman> I like that
16:17:59 <lethjakman> I've got a few people who are interested in haskell that I'm trying to start a book club with, this may be my book. 
16:18:21 <bitemyapp> lethjakman: yeah I don't even have tenure. What gives.
16:18:35 <bitemyapp> Also what justicefries said.
16:19:11 <bitemyapp> lethjakman: if you do start a book club, contact us and we'll get you setup with a group coupon.
16:19:23 <lethjakman> bitemyapp: Ooooo
16:19:36 <lethjakman> I'll keep that in mind. 
16:19:50 <ReinH> bitemyapp: I might give this a suggestion at $WORK too, I know some coworkers who are secretly interested in Haskell.
16:19:56 <ReinH> s/suggestion/try
16:20:13 <bitemyapp> lethjakman: where are you located?
16:20:13 <lethjakman> ReinH: I love how you phrase that. 
16:20:17 <lethjakman> bitemyapp: Denver. 
16:20:18 <bitemyapp> if you don't mind my asking.
16:20:21 <lethjakman> Not at all. 
16:20:33 <lethjakman> I've also been considering starting a local meetup. 
16:20:34 <bitemyapp> lethjakman: cool. Yeah we've done this with the Utah Haskell meetup, they have a reading group they're doing.
16:20:53 <lethjakman> That's really good to know. Does it seem pretty successful?
16:21:01 <lethjakman> Also, are you in Utah? If you don't mind me asking
16:21:11 <lethjakman> Also, are you using Haskell professionally?
16:21:27 <bitemyapp> lethjakman: Don't know, the reading groups haven't gotten back to us but the individuals from those reading groups and our readers more generally have been _ecstatic_
16:21:38 <bitemyapp> lethjakman: yeah I was actually getting paid to Haskell it up today.
16:21:41 <lethjakman> I've heard very good things. 
16:21:45 <lethjakman> Contract work?
16:21:50 <justicefries> lethjakman: I'min Boulder.
16:21:54 <lethjakman> I have a gig I might do in haskell. 
16:21:57 <bitemyapp> lethjakman: I've used 100% Haskell for my day job stuff for ~1 year now.
16:21:57 <lethjakman> justicefries: Oh, really? 
16:22:01 <lethjakman> Are you in the haskell group out there?
16:22:02 <bitemyapp> lethjakman: yes contract atm
16:22:06 <justicefries> brb, bathing the baby. I'm not.
16:22:20 <lethjakman> justicefries: Ok, I ask because I saw there was one there, but it doesn't seem active. 
16:22:26 <lethjakman> Also, good luck. 
16:22:33 <lethjakman> bitemyapp: Is that going well for you?
16:23:21 <ryandv> hello, when building an executable in cabal with profiling enabled (+RTS -p), is it possible to specify the output <program>.prof filepath?
16:24:12 <bitemyapp> lethjakman: in what sense? I like the tools and I like the people I'm working with. This contract is via an old friend and he and his co-founder are some of the funniest, nicest people I've ever known.
16:24:31 <eitanChatav> is there a parser library that also provides auto-complete functionality?
16:24:37 <lethjakman> I guess in the sense of "Are you finding a lot of work that you can write in Haskell"
16:24:44 <lethjakman> Sorry, that was a horrible way of phrasing it. 
16:24:44 <ReinH> eitanChatav: o/
16:24:54 <eitanChatav> howdy ReinH
16:25:39 <andromeda-galaxy> I wonder what the best way to automatically get it set up so that when I build my application with ghc, it gets to know where the files that are the result of building it with ghcjs live
16:26:06 <bitemyapp> lethjakman: not a _lot_, I'd say the ideal situation isn't to attempt to find ready-made Haskell gigs but instead to carve out a Haskell project at a company you already enjoy working at.
16:26:08 <andromeda-galaxy> it's a yesod + ghcjs app with one codebase, but I'm not sure what the best way to serve the js files created by the ghcjs build is
16:26:23 <bitemyapp> lethjakman: from that point of view, a quality company should trust their programmers to evaluate tech
16:26:43 <bitemyapp> lethjakman: part of the reason for writing the book is so people introducing Haskell at work can convincingly argue that resources are available for training coworkers
16:26:55 <lethjakman> That seems brilliant. 
16:27:18 <Adeon> this is more or less what I'm doing
16:27:33 <Adeon> the company I work at doesn't have haskell programmers but I've sleazed in some haskell stuff
16:28:17 <Adeon> I still have to watch a bit
16:28:32 <Adeon> for example, I won't write haskell parts to our super important production data pipeline
16:28:45 <Adeon> because if the haskell part breaks and I'm not around, there may not be people who can fix it
16:28:46 <pilne> from my (limited and slow-going) learning, i've not run into any kind of program that can't be implemented in haskell (and now that i've found out more about things like haste/ghcjs/uhc, and inline-c, i'm pretty sure that *anything* can be done, and done well in haskell (well, ghc... kinda, but i digress?))
16:30:43 <eitanChatav> one more try: is there a parser library that also provides auto-complete functionality?
16:30:59 <ReinH> eitanChatav: Not that I know of.
16:32:06 <eitanChatav> ReinH: thanks. I should have to only write once and get parser, pretty-printer, auto-completer and documentation for free :-)
16:32:18 <eitanChatav> too much to ask?
16:32:31 <ReinH> eitanChatav: Well, bidirectional parsers are a thing, but I don't see how you get auto-completion from those.
16:32:53 <ReinH> s/bidirectional/invertible
16:33:03 <eitanChatav> yeah, i've seen those
16:33:09 <eitanChatav> is there a good lib?
16:33:11 <ReinH> I think you'd have to be pretty restrictive in what you parse to be able to generate terms.
16:33:18 <andromeda-galaxy> ReinH: do you have any single-codebase ghcjs apps? (sorry to interrupt)
16:33:45 <ReinH> eitanChatav: the two I know of are boomerang and invertible-syntax, but I haven't used either.
16:33:55 <eitanChatav> thanx
16:33:56 <ReinH> eitanChatav: there's also some relationship to digestible-functors that might possibly be explored
16:34:08 <ReinH> *digestive
16:34:10 <monochrom> I think so far people have only gone as far as parser-and-pretty-printer
16:34:13 <Zekka|Sigfig> eitanChatav: Well, autocomplete is easy â€” just start by implemeting Prolog, and then port DCGsâ€¦
16:34:27 <ReinH> but autocomplete is a whole nother level of complexity
16:34:38 <pilne> pfffft why not use forth to do it instead of prolog? :p
16:35:12 <ReinH> andromeda-galaxy: only the one I'm currently working on that is in no fit state to share with anyone
16:35:29 <ReinH> andromeda-galaxy: well, that one is split out into some libraries.
16:35:39 <Zekka|Sigfig> Iâ€™m just screwing with you d udes. DCGs get you the most trivial portion of autocomplete (generating and prettyprinting terms that unify with what you already have)
16:35:46 <Zekka|Sigfig> it doesnâ€™t generate sane terms or useful ones
16:36:46 <andromeda-galaxy> ReinH: I was just wondering whether you'd figured out a good way to have the server statically serve the ghcjs build artificats without constantly manually copying them or passing in a directory
16:37:10 <ReinH> andromeda-galaxy: maybe ask Cale
16:37:30 <andromeda-galaxy> ReinH: sure, thanks anyway
16:38:04 <andromeda-galaxy> Cale: have you figured out a good way to have the server statically serve the ghcjs build artifacts without constantly manually copying them or passing in the build directory (e.g. via envvar)?
16:39:37 <Cale> andromeda-galaxy: I think we have some internal solution to the caching/preloading of the app, but I can't really give you details on it, because I haven't really looked closely enough at what it is.
16:41:15 <hunteriam> having some errors building ghcjs
16:41:17 <hunteriam> @where paste
16:41:17 <lambdabot> Haskell pastebin: http://lpaste.net/
16:41:27 <hunteriam> http://lpaste.net/148851
16:41:47 <andromeda-galaxy> Cale: alright, thanks!  I guess for now I'll either symlink the build dir inside static/ and make setup difficult or have the location be read out of an environment variable
16:42:29 <ManGreP> heya
16:54:02 <justicefries> and back.
16:57:16 <mahasamoot> Does anyone know a maths function where f(n) = n 1s?  Id est 1=1, 2=11, 3=111, et cetera.
16:59:37 <andromeda-galaxy> anyone know what the current state of francium is?
17:00:06 * lispy waits for a chemistry joke
17:00:39 * Clint waits for a physics joke
17:01:17 <pilne> rusted and falling at 9.8m/s^2
17:01:35 <pilne> towards the same box that a famous cat was once put in
17:04:56 <Gurkenglas_> mahasamoot, (10^n-1)/9. Like, a 1 and n zeroes thats gotten by multiplying 10 with itself enough times, that -1 is as many 9s as you want 1s, then divide by 9 to convert them all.
17:05:48 <mahasamoot> Gurkenglas_: thanks!
17:06:20 <Zekka|Sigfig> mahasamoot: Itâ€™s also easy to define recursively, if you like that sort of thing
17:06:50 <Zekka|Sigfig> f 0 = 0; f 1 = 1; f n = 10 * f (n - 1) + 1
17:07:08 <mahasamoot> Zekka|Sigfig: yes recursively would interesting
17:07:54 <ReinH> And that is a maths function.
17:09:31 <Zekka|Sigfig> FWIW it occurs to me that my second case there isnâ€™t necessary
17:09:35 <Zekka|Sigfig> 10 * 0  + 1 is 1
17:10:09 <Zekka|Sigfig> I canâ€™t give you a good answer for -1, -2, etc, though
17:10:19 <Zekka|Sigfig> > (10^(-1)-n)/9
17:10:20 <lambdabot>  (*Exception: Negative exponent
17:10:28 <Zekka|Sigfig> >(10**(-1)-n)/9
17:10:46 <Zekka|Sigfig> > (10 ** (-1) - n)/9
17:10:47 <lambdabot>  (10**negate 1 - n) / 9
17:11:01 <Zekka|Sigfig> that is not an obviously useful answer lambdabot
17:11:31 <ReinH> It's what you asked for. :p
17:12:34 <Zekka|Sigfig> Wait a second! Youâ€™re right
17:12:43 <Zekka|Sigfig> I mistranscribed my specialization of Gurkenglas_â€™s equation
17:12:55 <Zekka|Sigfig> > (10**(-1)-1)/9
17:12:56 <lambdabot>  -0.1
17:13:08 <Zekka|Sigfig> There you go! Negative one 1s.
17:13:16 <Zekka|Sigfig> > (10**(-3)-1)/9
17:13:17 <lambdabot>  -0.111
17:13:21 <ReinH> :D
17:16:04 <mahasamoot> Thanks for the help, I solved my problem!
17:16:50 <Zekka|Sigfig> mahasamoot: Best of future luck!
17:17:10 <mahasamoot> Zekka|Sigfig: thanks
17:22:36 <andromeda-galaxy> ^ I was talking about the frp reactive-banana/ghcjs
17:29:20 <ReinH> andromeda-galaxy: why not use reflex?
17:39:30 <vvvrxt2> If I launch a warp server within the do block of a forkIO, then kill the thread ID, does that stop the server?
17:42:51 <ReinH> vvvrxt2: did you try it?
17:48:31 <vvvrxt2> ReiH yeah it doesn't. but i don't understand why not
17:48:46 <vvvrxt2> ReinH
17:50:06 <vvvrxt2> heres what i'm doing http://lpaste.net/148852
18:02:18 <andromeda-galaxy> ReinH: I might do that, I was wondering about Francium because I kind of like reactive-banana
18:05:54 <dzdncnfzd> I'm trying to use aeson right now and having a hell of a time with it. What I want to do seems like it should be quite simple, but the guide I've been reading (http://artyom.me/aeson) and the hackage documentation don't seem to be helping at all. What I want to do is access the value of field "data", which should be another json object, then access the "children" field inside that, which points to a list of json objects, each of 
18:06:37 <dzdncnfzd> From each of these child objects I want to do a similar recursive thing (though no lists are involved)
18:07:39 <dzdncnfzd> What's been tripping me up are a number of things: 1. making the fromJSON class instance (why do we have to map <$> our data constructor over everything?) 
18:07:56 <zachk> dzdncnfzd data is a keyword in haskell, I would remain that field if I were you 
18:08:08 <dzdncnfzd> 2. the difference between parsers and values, and how to use a parser to get a value
18:08:18 <dzdncnfzd> zachk: not my choice. It's an api
18:08:37 <erlandsona> How do you convert [1..31] to " 1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28\n\n" ???
18:08:46 <zachk> try importing the library qualified, import qualified library as L  or or something 
18:10:16 <zachk> > (" " ++) . (++ "\n\n) . concat intersperse "  " . fmap show . drop 3 $ [1..31]
18:10:17 <lambdabot>  <hint>:1:79:
18:10:18 <lambdabot>      lexical error in string/character literal at end of input
18:10:21 <dzdncnfzd> zachk: it's not a haskell library. It's a web api. This shouldn't be a problem because it's a string value.
18:10:33 <zachk> > (" " ++) . (++ "\n\n) . concat . intersperse "  " . fmap show . drop 3 $ [1..31]
18:10:33 <glittershark> with -XDataKinds, how do I explicitly use the non-promoted constructor
18:10:35 <lambdabot>  <hint>:1:81:
18:10:36 <lambdabot>      lexical error in string/character literal at end of input
18:10:59 <zachk> > (" " ++) . (++ "\n\n") . concat . intersperse "  " . fmap show . drop 3 $ [1..31]
18:11:01 <lambdabot>  " 4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  ...
18:11:19 <zachk> > (" " ++) . (++ "\n\n") . concat . intersperse "  " . fmap show . revese . drop 3 . reverse $ [1..31]
18:11:20 <lambdabot>      Not in scope: â€˜reveseâ€™
18:11:20 <lambdabot>      Perhaps you meant one of these:
18:11:20 <lambdabot>        â€˜reverseâ€™ (imported from Data.List),
18:11:27 <zachk> > (" " ++) . (++ "\n\n") . concat . intersperse "  " . fmap show . reverse . drop 3 . reverse $ [1..31]
18:11:28 <lambdabot>  " 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21 ...
18:11:41 <zachk> erlandsona something like that perhaps :D 
18:12:42 <erlandsona> Thanks zachk! Much appreciated! I'm pretty new to Haskell as of the past few weeks... I'm trying to implement the Unix cal program as a learning excercise for myself...
18:12:58 <umayahabdennabi> printer :: [Integer] -> String
18:12:58 <umayahabdennabi> printer [] = "\n\n"
18:12:59 <umayahabdennabi> printer (x:xs) = show x ++ " "  ++ printer xs
18:13:00 <dzdncnfzd> (++ "\n\n") . concatmap (\x -> ' ':x) . fmap show $ [1..31]
18:13:30 <dzdncnfzd> > (++ "\n\n") . concatmap (\x -> ' ':x) . fmap show $ [1..31]
18:13:31 <lambdabot>      Not in scope: â€˜concatmapâ€™
18:13:31 <lambdabot>      Perhaps you meant one of these:
18:13:31 <lambdabot>        â€˜concatMapâ€™ (imported from Data.List),
18:13:37 <erlandsona> It's how I learned Ruby but I'm really trying to dive deep into the FP rabbit hole!
18:13:40 <dzdncnfzd> > (++ "\n\n") . concatMap (\x -> ' ':x) . fmap show $ [1..31]
18:13:41 <lambdabot>  " 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28...
18:14:00 <glittershark> actually maybe I'm doing this wrong
18:14:03 <glittershark> I have a tuple type
18:14:20 <glittershark> containing pairs of instances of an enum of some sort
18:14:27 <glittershark> say, data Thing = Foo | Bar | Baz
18:14:48 <glittershark> and I want to, at the type level, somehow change that tuple type such that it's constrained to only particular pairs
18:15:00 <glittershark> so the only valid instances are (Foo, Bar) and (Bar, Baz)
18:15:07 <glittershark> and, for example (Foo, Baz) wouldn't compile
18:15:19 <glittershark> is that possible in haskell or is that too much like dependent types?
18:15:21 <dzdncnfzd> glittershark: I don't think you can short of hiding constructors to a custom tuple type
18:15:34 <glittershark> well, I'm not attached to doing it with a tuple
18:15:48 <dzdncnfzd> glittershark: it gives me the dependent tingles
18:15:54 <glittershark> yeah me too
18:16:01 <umayahabdennabi> what type do you use for SQL datetime field, iâ€™m using mysql-simple
18:16:17 <glittershark> I just feel like there should be a way to do it with GADTs or DataKinds or TypeFamilies or whatnot
18:16:23 <glittershark> but I can't figure it out
18:16:27 <dzdncnfzd> glittershark: above my paygrade
18:16:37 <glittershark> :/
18:16:48 <glittershark> maybe some of the more experienced people in here can help
18:17:33 <glittershark> to any log-spelunkers: the pairs are known at compile time; they're not dynamic or determined from user input. I'd be up to a major refactor to make it work
18:17:45 <glittershark> I guess I could use a multiparam type class
18:17:45 <KaneTW> i can't think of a way to make it work with tuples
18:17:54 <glittershark> again, not attached to the tuple idea
18:20:01 <dzdncnfzd> glittershark: why don't you make them separate data types then
18:20:26 <dzdncnfzd> and then make a separate data type with the appropriate constructors
18:21:53 <dzdncnfzd> glittershark: http://lpaste.net/148853
18:22:45 <glittershark> That makes sense I guess
18:23:16 <glittershark> I kinda wanted to see if I could make that happen with DataKinds but I don't know how to use those really
18:23:24 <KaneTW> data ValidPair (a :: Thing) (b :: Thing) where { FooBar :: proxy Foo -> proxy Bar -> ValidPair Foo Bar }
18:23:48 <KaneTW> and a function ValidPair a b -> (Thing, Thing)
18:24:53 <glittershark> what's proxy?
18:25:00 <dzdncnfzd> KaneTW: can you explain the where clause and the proxy?
18:26:41 <KaneTW> proxy is just a trick to pass dummy arguments
18:26:43 <KaneTW> see Data.Proxy
18:27:21 <dzdncnfzd> KaneTW: I'm reading, but I don't know what a dummy argument is and when you would ever use it
18:27:43 <KaneTW> the where clause defines a GADT since my resulting type (ValidPair Foo Bar) isn't the same as the type of my inputs (proxy Foo, proxy Bar for any proxy) 
18:28:00 <KaneTW> essentially when you have a type-level value but you want to pass it at the term-level
18:28:01 <homovitruvius> suppose you have a ParsecT stack whose inner monad is a restricted IO monad that ultimately implements some IO actions. How would you go about using such a stack as part of a larger CompilerMonad whose inner monad is the actual, unrestricted, IO monad? The IO monad has to be the innermost one, but if you stack together the compiler monad, you end up with a sandwich of unrestricted-restricted-unrestricted that I don't know ho
18:28:01 <homovitruvius> write. Suggestions?
18:28:04 <glittershark> I think the proxy is the bit I was missing
18:28:33 <glittershark> when trying to do this myself
18:28:47 <glittershark> does the compiler just decide that proxy has kind `Thing -> *`?
18:28:55 <KaneTW> yeah
18:29:01 <glittershark> because that's how it's use
18:29:03 <glittershark> used*
18:29:04 <glittershark> cool!
18:29:08 <KaneTW> and  then you can use Data.Proxy's Proxy type as a concrete instance
18:29:13 <glittershark> cool
18:29:42 <glittershark> do I just define the ValidPair a b -> (Thing, Thing) using pattern matching or is there a quicker way to do it?
18:29:53 <KaneTW> i'm trying to think whether there is
18:30:17 <glittershark> like is it possible to de-promote kind constructors back to the value level >.>
18:31:14 <zachk> glittershark proxy, maybe GHC.symbol or something, but it is older iirc 
18:32:06 <KaneTW> make a type data SingThing (t :: Thing) where SFoo :: SingThing Foo ... etc
18:32:43 <glittershark> yeah
18:32:50 <glittershark> at that point it isn't really saving any time
18:32:53 <KaneTW> yeah
18:32:59 <glittershark> that's fine
18:33:04 <glittershark> I'll just do the typing >.>
18:33:24 <glittershark> the real-life instance of the enum in question has 16 instances but whatevs
18:33:25 <KaneTW> the whole automatic type -> term would require pi-types which isn't coming soon (see DependentHaskell)
18:33:31 <glittershark> ah
18:33:31 <glittershark> yeah
18:33:34 <KaneTW> oh
18:33:35 <KaneTW> nice
18:33:41 <glittershark> I knew DependentHaskell was gonna come into this at some point
18:33:43 <KaneTW> the singletons package has some template-haskell for that
18:33:47 <glittershark> oh! hey!
18:33:48 <glittershark> nice
18:34:03 <KaneTW> singletons [d|data Thing = Foo | Bar | Baz|]
18:34:17 <glittershark> sweet
18:34:18 <KaneTW> and it generates the data type and appropriate instances
18:34:20 <Xeironis_> hi, I need a Reader and a State Monad, and it seems to me that it doesn't matter whether I use StateT and Reader or ReaderT and State. Is that correct?
18:34:39 <glittershark> Xeironis_: that's correct
18:34:45 <Xeironis_> ok, thanks
18:34:48 <glittershark> Xeironis_: keep in mind State is just StateT Identity
18:34:54 <glittershark> and Reader is just ReaderT Identity
18:35:06 <Xeironis_> yeah
18:35:11 <glittershark> so as long as you unwrap things in order and use the right mtl typeclasses it all works out
18:35:18 <Xeironis_> ok, that makes sense
18:35:24 <glittershark> :)
18:35:41 <Gurkenglas> Not all transformers compose, but those two do with each other
18:35:47 <Gurkenglas> *commute
18:36:05 <Xeironis_> because of the MonadReader and MonadState instances of both?
18:36:10 <glittershark> KaneTW: thanks for the GADT+datakind magic help. This'll be my first real use of either of those extensions, which is exciting
18:36:19 <glittershark> Xeironis_: correct again!
18:36:23 <Xeironis_> a
18:36:26 <Xeironis_> oops
18:36:28 <Gurkenglas> nope, not because of that
18:36:33 <glittershark> oh
18:36:34 <glittershark> well maybe not
18:37:11 <Gurkenglas> Because StateT s m a is s -> m (a, s) and ReaderT r m a is r -> m a and s -> r -> (a, s) is isomorphic to r -> s -> (a, s)
18:37:17 <Xeironis_> ah
18:37:20 <Xeironis_> I see
18:37:33 <Gurkenglas> MaybeT and StateT s don't commute, for example.
18:38:05 <Xeironis_> right, one throws away the State and the other doesn't if you have Nothing?
18:38:45 <shirt> I'm trying to understand MonadFix. Can something similar to it be written in Java/C++/Python ?
18:40:42 <KaneTW> glittershark: basically after you've done that you can use fromSing to convert the singleton into a value
18:40:57 <KaneTW> also, np
18:44:30 <csd_> Hi - would someone please explain what I'm doing wrong in my attempted usage of quickcheck: http://pastebin.com/i0D3iwwC
18:51:04 <zachk> is there a way to call execl() from haskell, like a library already providing that, or a similar bindings to a similar function? 
18:52:26 <geekosaur> not the -l variant
18:52:52 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/unix-2.6.0.1/System-Posix-Process.html#v:executeFile
18:56:01 <zachk> does executeFile replace my currently running binary? 
18:56:13 <geekosaur> yes
18:56:37 <zachk> sweet! ... lets see if I can get it to work 
18:56:44 <geekosaur> it's execve() with Maybe-s that let it be execv() and execvp()
18:56:56 <geekosaur> execl() being varargs is kinda difficult for Haskell
18:57:11 <zachk> yea, printf does it though 
18:58:00 <geekosaur> sure, printf has ways to pull that off, the fact that Haskell doesn't use NULL makes it a bit trickier to use typeclass hackery to emulate its varargs
18:58:15 <geekosaur> and the list version is more Haskelly anyway
19:00:54 <geekosaur> could porbably hack up a way to use a typeclass to do a String/ByteString vs. some Maybe a (probably the same type) but the error for forgetting the trailing NULL would be awful
19:01:16 <geekosaur> otoh it'd still be beter than what happens in C (which is probably a core dump)
19:01:43 <geekosaur> er, trailing Nothing
19:01:45 <zachk> I managed to get a function that takes a finite stack of (Show blah) => ..Maybe (Maybe (Maybe blah) -> String , could not figure out how to get one that takes finite stack of Maybe's though and just returns (Maybe a), though 
19:15:05 <codedmart> I am getting this error when trying to install double-conversion with stack `ld: library not found for -lc++`
19:15:12 <codedmart> On osx 10.11
19:16:02 <glguy> csd_: You've got your lambdas confused
19:16:23 <glguy> csd_: arbitrary >>= \s -> ..., not \s -> arbitrary s >>= ...
19:16:41 <nanoz> ello
19:16:41 <glguy> but it's better to use do-notation: do s <- arbitrary; v <- arbitrary; ...
19:16:58 <nanoz> i wrote a prime no generation 
19:17:11 <nanoz> can someone review and say any better way to do it
19:17:15 <nanoz> let allpri xs = [if mod xs x ==0 then 0 else 1 |x<-[((xs-xs)+2)..(xs-1)]]
19:17:21 <nanoz> let isprime x = (x==1||sum(allpri x)+2 ==x)
19:17:26 <nanoz> let pri xs = [x | x<-xs,isprime x]
19:17:31 <geekosaur> @paste
19:17:31 <lambdabot> Haskell pastebin: http://lpaste.net/
19:17:34 <nanoz> pri [1..100]
19:19:26 <nanoz> i found there is not formula as such
19:19:44 <nanoz> im haskell beginner dont know any best practise
19:20:03 <erlandsona> how would I intersperse \n into a string on every 20th Char?
19:20:27 <csd_> glguy: thanks, i eventually figured that out. i was getting confused by how the type checker was supposed to figure out what arbitrary was doing
19:20:39 <csd_> waddya know it didnt have a problem
19:22:06 <erlandsona> "                  1 \n2  3  4  5  6  7  8 \n9 10 11 12 13 14 15\n16 17 18 19 20 21 22\n23 24 25 26 27 28 29\n"
19:22:11 <erlandsona> from
19:22:24 <erlandsona> "                  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 "
19:22:42 <pavonia> > intercalate "-" $ chunksOf 4 ['a' .. 'z']
19:22:44 <lambdabot>  "abcd-efgh-ijkl-mnop-qrst-uvwx-yz"
19:22:50 <nolraiU> erlandsona: try "map (('\n' :) . take 20) $ iterate (drop 20)"
19:23:03 <nolraiU> Or..pavonia, thats better.
19:23:10 <nolraiU> *pavonia's
19:23:25 <erlandsona> Nice! thanks pavonia!
19:23:48 <pavonia> No problem
19:34:50 * hackagebot simple-templates 0.8.0.1 - A basic template language for the Simple web framework  https://hackage.haskell.org/package/simple-templates-0.8.0.1 (AmitLevy)
19:55:58 <dzdncnfzd> I'm trying to follow this guide (http://artyom.me/aeson) and I've come up with the following code: http://lpaste.net/148854 
19:56:32 <dzdncnfzd> What's weird is that I can't compile when I specify that my parser is a parser, and when I don't specify that my parser is a parser, the code compiles with a very general type signature.
19:57:23 <ReinH> dzdncnfzd: why not create a FromJSON instance?
19:58:02 <dzdncnfzd> ReinH: Because I couldn't figure out how and you, my knight in shining armor, were not here to help me :)
19:58:40 <dzdncnfzd> (by the way, the problem I had just now was dumb -- I wasn't importing the Types module accidentally)
19:58:43 <pavonia> Parser is defined in Data.Aeson.Types
19:59:01 <ReinH> dzdncnfzd: have you read http://artyom.me/aeson ?
19:59:14 <dzdncnfzd> Yes. I'm having difficulty with it
19:59:59 <hunteriam> hey guys whats going on here
20:00:02 <hunteriam> https://www.irccloud.com/pastebin/6IJ3WeGQ/
20:00:08 <ReinH> dzdncnfzd: the FromJSON instance for Article based on that tutorial seems straightforward
20:00:28 <hunteriam> why is there no IsString instance for JSSrting?
20:00:43 <hunteriam> ReinH: im using the version of ghcjs from your repo, did you have this problem too?
20:00:52 <dzdncnfzd> ReinH: I'm going to look at it a moment more so I don't waste your time
20:00:59 <ReinH> dzdncnfzd: it's basically the same as http://artyom.me/aeson#records-and-json
20:04:52 <wedens> what should I do in .cabal to use .a library for FFI?
20:05:26 <dzdncnfzd> ReinH: In the tutorial's instance FromJSON Person where ... 1. Do you understand the first argument of withObject and 2. Do you understand why Person is fmap'd over the applicative statement, rather than merely appplied?
20:05:29 <dzdncnfzd> *applied
20:05:33 <wedens> library is in project directory
20:05:34 <pavonia> hunteriam: What package is that from?
20:05:45 <hunteriam> GHCJS
20:05:49 <hunteriam> and ghcjs-base
20:06:01 <hunteriam> also im getting `SPAWN ENAMETOOLONG` now
20:06:09 <ReinH> dzdncnfzd: (1) did you read the documentation for withObject? (2) look at the monad version below and see if that makes more sense
20:06:43 <dzdncnfzd> ReinH: Yes. I don't understand what "withObject expected f value applies f to the Object when value is an Object and fails using typeMismatch expected otherwise" means
20:06:58 <dzdncnfzd> OH. It's a fuckin
20:07:01 <dzdncnfzd> It's an error message
20:07:07 <dzdncnfzd> Gah.
20:07:09 <ReinH> It describes the object.
20:07:18 <ReinH> or the thing that is expected to be an object
20:07:27 <dzdncnfzd> Yes. Okay. 
20:08:45 <dzdncnfzd> ReinH: Thank you. I still don't actually understand the code (especially the type stuff with the Parser) but I'll keep working and come back if I still can't get it.
20:09:08 <ReinH> dzdncnfzd: have you used applicative or monadic parser combinators before? (parsec, etc.)
20:09:41 <dzdncnfzd> ReinH: I've read about them extensively but this is my first time actually putting them into use and I'm not really rising to the bar.
20:09:51 * hackagebot bank-holiday-usa 0.1.0 - A library for determining US bank holidays  https://hackage.haskell.org/package/bank-holiday-usa-0.1.0 (tippenein)
20:10:10 <dzdncnfzd> I've also never used much applicative style
20:10:36 <YoshiHunter7> Guys, I have a serious problem, akin to knowing English grammar but not knowing in which direction to read a book to gain ideas and knowledge.
20:10:48 <YoshiHunter7> I know languages, but I can't read code well, like GitHub repos and such.
20:11:01 <dzdncnfzd> Also, the aeson Parser monad instance is written in CPS, which is mind poison to me
20:11:03 <YoshiHunter7> I don't know where to start; where it all begins. It's to mangled to my noob mind.
20:11:22 <YoshiHunter7> And as such, I can't learn form code and gain new insights into programming. :(
20:11:27 <dzdncnfzd> YoshiHunter7: Have you ever worked on a large code base?
20:11:36 <dzdncnfzd> At a job or in your spare time?
20:12:15 <YoshiHunter7> No, I'm self-teaching myself programming. Picking up languages is fairly easy: I know C, Haskell, Lisp (Scheme), Java, Python and C++.
20:12:17 <ReinH> dzdncnfzd: you don't need to understand the implementation of Parser to use it
20:12:21 <YoshiHunter7> I can't use them, though.
20:12:22 <ReinH> Look at (.:) :: FromJSON a => Object -> Text -> Parser a
20:12:33 <YoshiHunter7> I just know the syntax/grammar.
20:12:35 <ReinH> o .: "foo" :: FromJSON a => Parser a
20:12:49 <ReinH> o .: "foo" is an action that returns an a
20:13:01 <YoshiHunter7> It's like knowing English, but not knowing where to start with writing a book at all.
20:13:06 <dfeuer> Why can't type families evaluate to quantified types?
20:13:06 <ReinH> If we had instead:
20:13:19 <ReinH> > (,) <$> Just 1 <*> Just 2
20:13:21 <lambdabot>  Just (1,2)
20:13:27 <ReinH> or
20:13:32 <dfeuer> What's wrong with   type instance Foo Int = forall a . [a] -> [a]   ?
20:13:39 <ReinH> > do x <- Just 1; y <- Just 2; return (x, y)
20:13:40 <lambdabot>  Just (1,2)
20:13:50 <ReinH> You use a parser in basically the same way.
20:13:57 <YoshiHunter7> "How do they find out that the word 'quantify' is what they're looking for?" In regards to knowing which functions to use. I don't know what function I need to make draw Pacman or something by default.
20:15:12 <ReinH> (,) <$> o .: "foo" <*> o .: "bar" tries to read the "foo" key and the "bar" key of the object o and put them into the tuple.
20:15:32 <YoshiHunter7> Ah, no help. M'kay.
20:15:45 <ReinH> so does do x <- o .: "foo"; y <- o .: "bar"; return (x,y)
20:15:53 <ReinH> YoshiHunter7: ? It's been a minute.
20:16:27 <YoshiHunter7> How do people navigate through code repos on GitHub? I can't learn from code if I don't know where to start.
20:16:46 <dfeuer> YoshiHunter7, most people use a web browser for that.
20:17:11 <dzdncnfzd> ReinH: Here's what I don't understand: I thought that a Parser was a function that took a value in one type and gave you back another type
20:17:22 <YoshiHunter7> How do they know where to start? How do they know the codebase's tree - how it all connects?
20:17:31 <ReinH> YoshiHunter7: Try these videos of a good haskeller walking through and explaining the source code of popular libraries https://www.youtube.com/playlist?list=PLxj9UAX4Em-Lz5btngxMVZxf_B44GETVz
20:18:12 <ReinH> dzdncnfzd: There are a variety of ways that a parser might be implemented under the hood, but a value of type Parser a is not a function.
20:18:34 <dzdncnfzd> ReinH: Is it just a wrapped "a"?
20:18:53 <ReinH> dzdncnfzd: No, it isn't "just" a wrapped a, but it is a Monad instance whose actions produce an a.
20:19:03 <ReinH> For using it with do notation, that's basically all you need to knew
20:19:21 <dfeuer> ARGH.
20:19:23 <dzdncnfzd> How do you get the "a" out? 
20:19:57 <ReinH> dzdncnfzd: you don't get the a out, but you can bind functions that use the a just like other monads
20:20:26 <dzdncnfzd> But why can't you get the a out? You can normally with parsers, can't you?
20:20:36 <ReinH> Yes, but you don't need to.
20:20:40 <ReinH> Aeson handles that for you.
20:21:02 <dzdncnfzd> Hm....
20:21:24 <dzdncnfzd> ReinH: Thanks a lot for the help -- I need to run from my bus to my apartment, so I may see you in a moment or not
20:21:36 <dzdncnfzd> Thanks a lot! I'll be looking over these logs regardless!
20:22:01 <ReinH> dzdncnfzd: once you write your Parser Foo action that parses a Value into a Foo, you can use the parse, parseMaybe, etc to execute it
20:22:15 <ReinH> dzdncnfzd: yw
20:22:18 <YoshiHunter7> You fucking faggots. Fuck you all.
20:22:21 <YoshiHunter7> Die.
20:22:32 <ReinH> Ok.
20:22:41 <ReinH> @where ops
20:22:41 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
20:22:46 <ReinH> That seems bannable.
20:22:57 --- mode: ChanServ set +o shachaf
20:23:08 <shachaf> Oh, I missed it.
20:23:21 <ReinH> It came out of nowhere
20:23:24 * ReinH shrugs
20:23:32 --- mode: shachaf set +b-o *!*@*184.6.42.182 shachaf
20:23:41 <ReinH> ty
20:24:00 <hunteriam> in place of ghcjs, what would you guys reccomend?
20:24:07 <hunteriam> it doesnt appear that ghcjs is possible
20:24:36 <ReinH> hunteriam: did you try to build my project verbatim?
20:24:52 <hunteriam> yea, im getting a windows related error
20:24:56 <hunteriam> ill paste it
20:25:07 <hunteriam> https://www.irccloud.com/pastebin/fXtOQTAm/
20:25:09 <ReinH> And you haven't changed any of the versions or urls of anything?
20:25:16 <hunteriam> indeed
20:25:30 <hunteriam> the error is related to overflowing the windows path or something like that
20:25:59 <ReinH> Ah, that's a windows specific thing, yeah :/
20:26:20 <ReinH> I imagine that should be treated as a ghcjs bug by, e.g., luite
20:27:11 <ReinH> But yeah, I suppose that will prevent you from using ghcjs on windows. :/ Maybe try Haste or Fay?
20:27:52 <mgsloan> hunteriam: One solution would be to use stack's docker support, and install docker on windows
20:28:22 <ReinH> That would certainly be less intrusive than a VM
20:28:24 <mgsloan> Sure, this means the ghcjs commpile will run in a container in a VM, making something that's slow even slower, but should be quite workable
20:28:49 <ReinH> mgsloan: then again, it wouldn't produce windows binaries?
20:29:41 <mgsloan> windows JS binaries? ;)
20:29:53 <ReinH> windows GHCJS binaries? ;)
20:30:12 <ReinH> e.g., he's trying to build ghcjs iinm.
20:30:18 <mgsloan> You wouldn't run the binaries in windows
20:30:24 <ReinH> Oh right.
20:30:31 <ReinH> Of course.
20:30:42 <ReinH> You'd use the ghcjs in your image to build your js in your image
20:30:45 <ReinH> nice
20:30:53 <ReinH> well, in containers that use that image
20:31:08 <hunteriam> i havent had a good experience with docker and stack on windows in the past
20:31:38 <mgsloan> hunteriam: Feel free to log bugs about it
20:32:06 <hunteriam> if i were to try something other than ghcjs, what would be the runner up?
20:32:16 <mgsloan> While we'd like to support windows well, none of the main stack developers use windows, so if something is broken, we don't really know until someone tells us about it
20:33:17 <mgsloan> hunteriam: Probably haste, but it doesn't support compiling all of GHC haskell + doesn't support concurrency
20:36:09 <hunteriam> mgsloan: this is apparently more of a ghcjs issue
20:36:29 <mgsloan> It's actually a windows issue.  ghcjs-dom just has really really long filepaths
20:37:00 <hunteriam> mgsloan: generally docker doesnt seem very windows friendly so its no surprise Ive had a bad time with it
20:37:06 <mgsloan> I really recommend using some *nix OS for development
20:37:33 <mgsloan> (or possibly VM)
20:37:38 <hunteriam> mgsloan: i lose a lot of ease of life features by switching off windows
20:38:19 <hunteriam> mgsloan: strictly nix os or would nix be acceptable?
20:38:46 <mgsloan> I just mean any linux / OS X / etc
20:40:07 <mgsloan> If docker doesn't work, then just use the linux VM to build your JS, and script that bit
20:40:26 <mgsloan> Ah, one thing you might try is putting your project higher in the filetree
20:40:32 <mgsloan> Like C:/my-project/
20:40:56 <mgsloan> Build is likely to get further, it's probably just barely triggering MAX_PATH issues
20:41:27 <hunteriam> have done that
20:41:39 <mgsloan> Not just putting STACK_ROOT at C:/ ?
20:41:47 <mgsloan> It matters for both of them..
20:42:49 <hunteriam> i did both
20:43:05 <mgsloan> Hrmm, well darn!
20:43:11 <mgsloan> And your stack version is recent?
20:43:25 <hunteriam> Version 1.0.0, Git revision 3bc26237b5b3c387b8fd564459ea4dd88fd58b30 (2939 commits) x86_64
20:43:31 <mgsloan> Yup, that's recent enough
20:43:37 <mgsloan> Well, sorry, I dunno what to do about that
20:43:43 <hunteriam> https://bitbucket.org/scons/scons/wiki/LongCmdLinesOnWin32
20:43:49 <hunteriam> is this something stack could implement?
20:47:13 <mgsloan> Well, ENAMETOOLONG is getting thrown by node.js, while it's executing Cabal (which has been compiled to JS)
20:48:00 <mgsloan> Stack doesn't currently control your node.js version.  This could also be a node bug, but probably not, since it's happening on ghcjs-dom which has massive module names (due to code generating them from specs)  
20:49:01 <hunteriam> hm
20:49:04 <mgsloan> So, no, stack can't fix the issue
20:49:23 <mgsloan> Unless we did something crazy like built our own custom node with a workaround
20:49:40 <hunteriam> would upgrading my node version change anything?
20:49:42 <mgsloan> Not even sure a workaround is possible, this is just windows being extremely frustrating
20:50:05 * mgsloan spent DAYS last year on various things due to MAX_PATH, and doesn't even use windows
20:50:10 <hunteriam> frustrating
20:50:38 <hunteriam> if i could switch to linux without making large sacrifices i would
20:50:41 <mgsloan> It might, I've heard node 5.0 works for people on windows
20:50:49 <hunteriam> where do i get it?
20:50:50 <mgsloan> s/windows/linux/
20:51:00 <mgsloan> From the node website
20:53:11 <lethjakman> Is haskell platform on ubuntu just super out of date?
20:55:39 <hunteriam> mgsloan: how do i tell stack where node is? its got the wrong spot
21:01:07 <mgsloan> It'll use whatever is on your PATH
21:11:02 <wedens> how can I tell cabal to link some C library statically?
21:14:54 * hackagebot brick 0.4 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.4 (JonathanDaugherty)
21:19:24 <hunteriam> mgsloan: 
21:19:27 <hunteriam> https://www.irccloud.com/pastebin/KrBQf6Yu/
21:19:41 <hunteriam> nodejs is at Program Files\ not (x86)
21:19:55 <hunteriam> `node` works in cmd
21:25:16 <mgsloan> Strange! Well, here's how ghcjs's runner works: https://github.com/ghcjs/ghcjs/blob/master/src-bin/Run.hs 
21:46:32 <umayahabdennabi> Has anyone ever dealt with the following error  Could not find module â€˜Data.Text.Encodingâ€™
21:46:32 <umayahabdennabi>     It is a member of the hidden package
21:47:40 <pavonia> Many of us have, I presume
21:48:32 <umayahabdennabi> I tried to fix it by deleting ~/.cabal and ~/.ghc and reinstalling all the packages but didnâ€™t fix the issue
21:48:54 <pavonia> It means you are using a package in a cabal project but doesn't declare the package in the dependencies section
21:49:37 <umayahabdennabi> okay, iâ€™ll try putting them in thx
22:11:28 <vx___r> is there a way to pass a router function (eg getHomeR) to a yesod app dynamically instead of statically?
22:13:29 <mjrosenb> @hoogle a -> Maybe a -> a
22:13:31 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
22:13:32 <lambdabot> Prelude asTypeOf :: a -> a -> a
22:13:32 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
22:49:57 * hackagebot wai-routes 0.9.5 - Typesafe URLs for Wai applications.  https://hackage.haskell.org/package/wai-routes-0.9.5 (AnupamJain)
23:09:58 * hackagebot gtk-traymanager 0.1.6 - A wrapper around the eggtraymanager library for Linux system trays  https://hackage.haskell.org/package/gtk-traymanager-0.1.6 (TristanRavitch)
23:10:00 * hackagebot taffybar 0.4.6 - A desktop bar similar to xmobar, but with more GUI  https://hackage.haskell.org/package/taffybar-0.4.6 (TristanRavitch)
23:26:18 <hunteriam> having trouble compiling ghcjs-dom if anyone can help
23:26:21 <hunteriam> https://www.irccloud.com/pastebin/UDNvjAb3/
23:29:59 * hackagebot hasql 0.19.2 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.19.2 (NikitaVolkov)
23:30:01 * hackagebot hasql-transaction 0.4.2 - A composable abstraction over the retryable transactions for Hasql  https://hackage.haskell.org/package/hasql-transaction-0.4.2 (NikitaVolkov)
23:34:59 * hackagebot hasql-pool 0.3 - A pool of connections for Hasql  https://hackage.haskell.org/package/hasql-pool-0.3 (NikitaVolkov)
23:35:01 * hackagebot hasql-th 0.2 - Template Haskell utilities for Hasql  https://hackage.haskell.org/package/hasql-th-0.2 (NikitaVolkov)
23:37:07 <hunteriam> how do i change my stack root?
23:37:14 <hunteriam> i thought I had but it appears I hadnt
23:58:00 <ali_bush> anyone had/has experience with nvim-hs.   and is there a way to publish one stack 'project' so another can use it (locally)
