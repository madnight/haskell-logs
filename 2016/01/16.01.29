00:00:00 <dolio> Only foldMap is really sufficient for Foldable.
00:00:09 <Cale> In full generality yes
00:00:19 <Cale> But 90% of the time, you could go via toList and be fine
00:00:53 <Cale> There are certain data structures which can be more efficient for some operations
00:01:00 <dolio> But all the other folds are in Foldable because using foldMap isn't even good enough for lists.
00:01:02 <Cale> Like Set can implement sum more efficiently
00:02:25 <dolio> If want to generalize all those folds (and other stuff) to Foldable, at least. I'd be okay if it just had foldMap.
00:02:43 <dustmote> ReinH: Cale: thanks for your help!
00:05:17 <Cale> It's not so much that what Foldable does is wrong -- there are definite cases in which it's the right approach. It's just quietly sad that it will get used in cases where list operations were fine, and this nice universal property that lists have doesn't get used when it could be.
00:05:46 <dolio> Which universal property?
00:06:32 <Cale> Thinking about them as an initial F-algebra or terminal F-coalgebra
00:06:40 <Cale> Well, that's the fancy way to say it
00:06:56 <Cale> But really, that you can factor all sorts of iterative processes through them
00:07:05 <SX> Hi! Tell me please, how to force release of resources? I have a tcp server with runGeneralTCPServer, which uses 2 async threads (to read from socket to TBMChan and to write to socket from TBMChan), and a worker function, which uses this channels to read and write.
00:07:38 * hackagebot json-ast-quickcheck 0.1 - Compatibility layer for "json-ast" and "QuickCheck"  https://hackage.haskell.org/package/json-ast-quickcheck-0.1 (NikitaVolkov)
00:07:38 * hackagebot NoTrace 0.3.0.0 - Remove all the functions come from Debug.Trace after debugging  https://hackage.haskell.org/package/NoTrace-0.3.0.0 (CindyLinz)
00:08:00 <dolio> If you really want iteration, I guess.
00:08:09 <Cale> Well, iteration is pretty important!
00:08:15 <Cale> Lists are our loops
00:08:16 <SX> On start this program uses ~4mb, on connect it rises to ~7-8mb, then after some time it's more than 13mb. Disconnection does not release anything.
00:08:56 <Cale> I sort of don't like the way in which Foldable kind of obscures their importance to the way in which we think about computation in Haskell (or at least some of us do...)
00:09:10 <SX> Using Conduits, of course. And Async.Lifted lib.
00:09:47 <Cale> SX: I would help with heap profiling, but that's going to take a bit, and it's 3am and I should sleep :)
00:09:58 <SX> Disconnect terminates all threads and closes chans,
00:10:34 <SX> Cale: tell me where to look and I'll do it myself =)
00:10:38 <Cale> SX: But look in the GHC manual about heap profiling. GHC compiled programs should free memory back to the OS eventually once things are deallocated, but I don't know how soon it usually happens.
00:11:12 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
00:12:09 <Cale> SX: if the heap profiler shows the memory getting freed, I wouldn't worry so much
00:12:13 <SX> I've put performGC after disconnect, so if it really forces garbage collection, then I have a space leak or smth
00:12:22 <Cale> SX: But if not, then maybe it can give you some clues
00:12:32 <Cale> Well, even after GC happens
00:12:58 <Cale> I don't know if the memory will immediately go back to the OS or not
00:13:05 <Cale> (it will eventually, I'm sure)
00:14:03 <Cale> SX: Do you find it just continues to grow with each new connection?
00:14:16 <Cale> SX: Or does it reach some size and then basically stay there?
00:14:39 <Cale> (assuming that clients disconnect)
00:15:43 <SX> Well, maybe my receiver thread is faster, than processing, than chan is filling up to limit (or close). I have a stress-tester, that sends a packet, waits for response and again
00:15:56 <Cale> SX: ah, that's possible
00:16:10 <Cale> You may want to try replacing Chan with BoundedChan or even MVar in some cases
00:16:24 <Cale> (MVar is like BoundedChan, only max of one element)
00:16:40 <SX> TBMChan is bounded
00:17:01 <SX> I have max size of 128 elements for now
00:17:17 <SX> I'll try to reduce it and profile the program, thanks!
00:17:33 * hackagebot rebase 0.1.3 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.1.3 (NikitaVolkov)
00:22:33 * hackagebot rebase 0.1.4 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.1.4 (NikitaVolkov)
00:26:25 <domgetter> Cale: so if >>= for lists is literally concat (map f xs), what's different between that and some other language that has map?
00:26:56 <koz_> domgetter: This represents lists as nondeterministic computation results.
00:27:02 <jle`> nothing fundamentally, we can do the same thing as >>= with only using concatMap
00:27:16 <jle`> but the reason it's nice to have >>= is so that we can use it with Monad-polymorphic functions
00:27:20 <koz_> The idea is that in Haskell, lists can play multiple 'roles' in a way. In the monad sense, they're nondeterminism.
00:27:27 <koz_> Or what jle` said.
00:27:31 <jle`> utility/helper functions defined in Control.Monad that are written to work for all Monad instances
00:27:38 <jle`> so, we get a bunch of helper/utility functions for free :)
00:27:54 <domgetter> okay
00:28:15 <jle`> but yes, xs >>= \x -> g x >>= \y -> [x,y,1] is the same as concatMap (\x -> concatMap (\y -> [x,y,1]) (g x)) xs
00:28:28 <jle`> so if our language has map and concat, you can do the same thing, it's not magical
00:28:46 <jle`> but writing a Monad instance means we can use functions polymorphic over all Monads, so that's neat
00:29:00 <jle`> > replicateM 4 "01"
00:29:02 <lambdabot>  ["0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","1010...
00:29:08 <domgetter> and it's up to the monad to play nice using >>=, right?
00:29:20 <jle`> yeah, to make sure its implementation of (>>=) follows the laws
00:29:30 <jle`> otherwise we can't reason about what the monad-polymorphic functions even 'do'
00:29:41 <domgetter> and the law is its type?
00:29:54 <jle`> replicateM, sequence, forM, etc. expect >>= to behave in certain ways for them to do what they want to do
00:29:59 <domgetter> i.e. (>>=) :: M a -> (a -> M b) -> M b ?
00:30:03 <jle`> the law is, properties about >>= that instances are expected to behave
00:30:07 <jle`> oh no, the type is verified by the compiler
00:30:13 <jle`> so that part the compiler can handle for you
00:30:26 <domgetter> oh, then what "laws" are there for a >>= implementation?
00:30:31 <jle`> laws are things like, `return x >>= f` should be the same as `f x`
00:30:43 <domgetter> for all monads?
00:30:50 <jle`> yes
00:31:09 <domgetter> Is there a list of these laws somwhere?
00:31:11 <jle`> well, when you use >>= and do notation, there are a lot of things that you intuitively 'expect' to be true, and a lot of refactorings that should make sense to you
00:31:15 <domgetter> somewhere*
00:31:22 <jle`> the laws are just ways of putting these expectations into words
00:31:24 <jle`> yeah,
00:31:29 <jle`> look in the docuemntation for the Monad typeclass
00:31:50 <jle`> http://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html
00:32:27 <jle`> > [x] >>= (\y -> [y,y,y])
00:32:29 <lambdabot>  [x,x,x]
00:32:30 <jle`> oops
00:32:33 <jle`> > [1] >>= (\y -> [y,y,y])
00:32:35 <lambdabot>  [1,1,1]
00:32:42 <jle`> you really expect that to be the same as
00:32:51 <jle`> > (\y -> [1,1,1]) 1
00:32:53 <lambdabot>  [1,1,1]
00:33:01 <jle`> > (\y -> [y,y,y]) 1
00:33:03 <lambdabot>  [1,1,1]
00:33:06 <jle`> (i meant the second one)
00:33:42 <jle`> if you think of "return" as the 'no-op', the 'plain wrapper', then return x >>= f should just be (f x).  you push the x into the context and then immediately use it
00:34:14 <jle`> well, not all of the laws will make sense until you actually use a lot of different instances, and get a feel for what you sort of expect after a lot of usage
00:34:38 <domgetter> So I can implement >>= however I'd like, but at the end of the day, whatever it does needs to be the same as if I had applied f to x directly
00:34:52 <jle`> well, return x >>= f should be f x
00:35:02 <jle`> (return x) >>= f
00:35:24 <jle`> but for, say, m >>= f, you have a bit more freedom in general
00:35:24 <domgetter> wait, then why even talk about return x >>= f if it's just f x
00:35:52 <jle`> we want to assure that they're equal, so we can do program refactorings and stuff like that, and avoid wonky behavior
00:36:06 <jle`> *if* return x >>= f was different than f x, then you'd start noticing it
00:36:11 <jle`> and things would start being reallly weird
00:36:23 <jle`> if you saw return x >>= f, you should go, "oh hey, that's just f x"
00:36:26 <domgetter> but why even make >>= at all if it's literally just f x
00:36:44 <jle`> (return x) >>= f is f x, but `m >>= f` is not `f m`
00:36:57 <jle`> (that doesn't even typecheck)
00:37:04 <domgetter> and x >>= f is not f x ?
00:37:07 <jle`> it's not
00:37:10 <domgetter> okay
00:37:25 <jle`> > [1,2,3] >>= (\x -> [x, -x])
00:37:27 <lambdabot>  [1,-1,2,-2,3,-3]
00:37:36 <jle`> > (\x -> [x, -x]) [1,2,3 :: Int]
00:37:38 <lambdabot>      No instance for (Num [Int])
00:37:38 <lambdabot>        arising from a use of syntactic negation
00:37:38 <lambdabot>      In the expression: - x
00:37:39 <jle`> type error, see?
00:37:45 <jle`> doesn't even make sense
00:37:58 <jle`> m is :: m a, f is (a -> m a), you can't apply f to m
00:38:29 <jle`> but, for the specific case of (return x) >>= f, that should just be f x
00:38:39 <jle`> > return 1 >>= (\x -> [x, -x])
00:38:41 <lambdabot>  [1,-1]
00:38:46 <jle`> > (\x -> [x, -x]) 1
00:38:51 <lambdabot>  [1,-1]
00:38:51 <EvanR> domgetter: return x >>= f = f x comes from the monad laws, so its a sanity check that your are following the monad laws
00:39:07 <EvanR> why do you want to follow the monad laws? because its the law
00:39:28 <jle`> there will be times where you see "return x >>= f" and you go, 'hey, i should just be able to write that as f x, who would even write that, that's so silly"
00:39:36 <jle`> the laws let you know that you're justified in that re-writing
00:39:49 <jle`> if the laws weren't fulfilled, then you'd rewrite it, and things ended up differently, and things start getting weird
00:40:17 <domgetter> EvanR: Surely some programmers are anarchists
00:40:24 <jle`> you can't say too many things in general about (m >>= f), though, without more context
00:40:34 <EvanR> domgetter: yeah they use dynamic types
00:40:45 <EvanR> its brutal
00:40:59 <domgetter> So if I follow the laws in something I make in another programming language, I'd have a monad, correct?
00:41:25 <EvanR> you can implement the Maybe, List etc behavior in any language
00:41:39 <EvanR> but its going to be hard to see what is monadic about it without a type system
00:41:43 <jle`> if you have the operations that are the right types, and the operations follow the laws
00:42:05 <domgetter> So being a monad is defined by following those laws
00:42:21 <jle`> well, you need the operations
00:42:28 <EvanR> and having the proper types for the ops
00:42:32 <jle`> that follow the laws, yes
00:42:51 <jle`> you could implement Maybe's monad instance in a lot of languages
00:43:01 <jle`> same for lists
00:43:07 <domgetter> I'm asking about monad in general, not a specific one
00:43:24 <domgetter> does talking about them in general even make sense?
00:44:00 <EvanR> are you asking if you can make a function polymorphic over all monads in another lanugage?
00:44:33 <jle`> yeah, if you have a (parameterized) type that implements those functions in a lawful way, then that type gives you a monadic interface
00:44:41 <EvanR> you can do it by passing a dictionary of the operations around
00:44:41 <domgetter> I'm asking if following those laws and having those operations would end up being all the things that are monad
00:44:51 <jle`> not all things can be monads
00:44:58 <EvanR> but interface support in other languages probably wont cooperate with you
00:45:01 <jle`> not all types can have those operations defined on them
00:45:04 <domgetter> "all the things that are monad"
00:45:11 <domgetter> I didn't say all things could be monads
00:45:27 <EvanR> domgetter: did you understand what i meant by dictionary passing
00:45:36 <jle`> well, you can't really implement >>= generically over every single monad instance
00:45:45 <EvanR> :t sequence
00:45:46 <jle`> every type has to define its own notion of mapping, binding, etc.
00:45:47 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
00:45:52 <EvanR> :t when
00:45:54 <lambdabot> Applicative f => Bool -> f () -> f ()
00:46:03 <EvanR> :t forM
00:46:05 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
00:46:12 <jle`> every individual type has to tell you what its >>= means, in a personal case-by-case basis
00:46:14 <EvanR> what only involves Monad these days
00:46:27 <jle`> :t sequence `asAppliedTo` []   -- i guess
00:46:29 <lambdabot> Monad m => [m a] -> m [a]
00:46:30 <EvanR> :t liftM
00:46:32 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
00:47:11 <EvanR> @src liftM
00:47:12 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
00:47:13 <domgetter> Isn't a monad fundamentally defined by the behavior of its >>= ?
00:47:55 <EvanR> function liftM(monadOps, f, act){ return monadOps.bind(act, function(x1){ return monadOps.return(f(x1)); }); }
00:48:02 <jle`> yes, and its interaction with return
00:48:07 <EvanR> monads!
00:48:07 <domgetter> okay
00:48:25 <domgetter> wait, shouldn't return x >>= f always be f x for all monads?
00:48:34 <EvanR> yes
00:48:35 <domgetter> or is there another way for them to "interact"
00:48:52 <jle`> m >>= return  =  m
00:49:08 <jle`> it's not enough to consider how >>= works in isolation, you have to also understand how `return` works, and how the two work together
00:49:21 <domgetter> But the laws say that how they interact is irrelevant
00:49:46 <domgetter> return x >>= f must =f x and m >>= return must = m
00:49:46 <EvanR> no
00:49:52 <EvanR> they say that return has no effect
00:50:19 <EvanR> its the identity of the monoid object you were talking about earlier
00:50:26 <jle`> hm, i guess, are you saying that `return` is uniquely defined by the implementation of >>= ?
00:50:46 <jle`> that's an interesting question
00:50:51 <domgetter> Is there an example where the interaction >>= and return result in more than one monad?
00:51:27 <jle`> you mean, where you fix >>=, but can vary return?  and still get a monad?
00:51:36 <jle`> hm
00:51:40 <domgetter> Correct
00:51:46 <jle`> well, i know cases where you can fix return, but vary >>=
00:51:48 <EvanR> take this monad, data Traffic a = Stop a | Go a, you could implement return two ways
00:52:15 <jle`> EvanR: but does the implementation of >>= for Traffic uniquely determine the `return`?
00:52:24 <EvanR> maybe
00:52:29 <EvanR> no
00:52:36 <EvanR> try this one
00:52:46 <EvanR> data Color a = Red a | Green a | Blue a
00:53:03 <EvanR> and >>= will cause Red if Green appears, but Red and Blue both do nothing
00:53:16 <EvanR> so you could use Red or Blue as the return
00:53:51 <EvanR> id have to slog through a proof
00:54:19 <domgetter> Would that be two different monads?
00:54:24 <EvanR> yep
00:54:48 <domgetter> but if return is polymorphic, isn't it the same return?
00:54:59 <EvanR> the two are isomorphic in some way
00:55:07 <EvanR> but different
00:55:20 <dolio> Did you know: if a monoid has two candidate elements e1 and e2, it is possible to prove e1 = e2 from the monoid axioms?
00:55:32 <EvanR> yeah
00:55:36 <jle`> this is Writer
00:56:18 <EvanR> does that monoid fact apply here
00:56:26 <jle`> your type is Writer
00:56:30 <EvanR> is it?
00:56:37 <jle`> yes, it's Writer (Fin 3)
00:56:49 <EvanR> er
00:56:54 <jle`> different monoids on Fin 3 will determine the behavior of your Monad
00:57:10 <dolio> EvanR: Consider \x -> return1 x >>= return2
00:57:15 <jle`> so if you pick a (Fin 3) monoid, return should be uniquely determined
00:57:28 <jle`> (your choice of >>= determines your (Fin 3) monoid, so return will also be uniquely determined)
00:57:46 <EvanR> maybe the example i suggested isnt a valid monad then
00:58:04 <EvanR> because i dont think its a Writer (Fin 3)
00:58:13 <jle`> data Color a = C (Fin 3) a
00:58:35 <jle`> so any Monad instance on that would essentially be picking a Monoid on (Fin 3) to use
00:58:57 <EvanR> must it be assoc?
00:59:23 <jle`> yes, so that (f >=> g) >=> h is f >=> (g >=> h)
00:59:37 <EvanR> dolio: that makes sense, i dont think we were talking about multiple distinct returns existing simultaneously
01:00:01 <domgetter> So what does that mean about the claim that a fixed >>= implies some return?
01:00:11 <dolio> EvanR: But if return1 and return2 both satisfy the axioms with respect to a particular (>>=), they are equal.
01:00:26 <EvanR> how so
01:00:48 <dolio> return2 x = return1 x >>= return 2 = return1 x
01:01:29 <jle`> domgetter: that's a neat point
01:01:30 <dolio> So (\x -> return2 x) = (\x -> return1 x)
01:02:00 <EvanR> yeah so my example wasnt assoc, (Blue <> Green) <> Red = Red
01:02:10 <EvanR> Blue <> (Green <> Red) = Blue
01:02:27 <EvanR> so >>= fully determines return
01:03:33 <domgetter> And therefore a particular Monad *is* its implementation of >>=
01:03:51 <jle`> (assuming `return` exists)
01:04:31 <EvanR> interesting, also recently return was made redundant by moving to Applicative
01:04:36 <EvanR> so what does that mean
01:04:38 <domgetter> Well if return didn't exist for that >>=, then it wouldn't be a monad in the first place, no?
01:04:51 <EvanR> all Monads are Applicatie
01:04:56 <EvanR> all Monads are Applicative
01:05:03 <jle`> domgetter: mhm
01:05:21 <EvanR> which means having pure :: a -> f a (which must agree with monad return if it exists)
01:06:31 <EvanR> does return imply >>= ? 
01:06:47 <jle`> it doesn't, like in the One/Two case you showed above
01:07:07 <EvanR> ok so by implementing Applicative you arent restricting your monad options
01:07:10 <orion> Cale: I was able to make a test case.
01:07:17 <EvanR> necessarily
01:07:37 <jle`> well, i consider the all-monads-being-applicatives thing more of a happy concidence than anything fundamentally profound; they're both two 'extensions' of functors and it happens that one happens to be more powerful than the other
01:07:55 <jle`> EvanR: hm. i think (<*>) might fix your (>>=)
01:07:57 <EvanR> yeah
01:08:06 <EvanR> oh?
01:08:26 <jle`> maybe
01:08:34 <jle`> maybe not
01:08:37 <jle`> i don't know anything anymore
01:08:42 <dolio> They need to agree in a certain way.
01:08:50 <dolio> Where (<*>) = ap.
01:09:09 <jle`> but can (>>=) be implemented in two different ways such that they produce the same ap ?
01:09:55 <jle`> i know that for the specific Writer case above with One/Two or Red/Green/Blue, (<*>) fully determines (>>=)
01:10:34 <EvanR> why? because <*> = ap?
01:10:48 <jle`> because <*> for Writer uses the monoidal structure
01:10:58 <jle`> so pick a monoidal structure for <*> and it has to be the same one you use for >>=
01:11:49 <EvanR> wait, you start with the type, and start implementing Applicative
01:11:57 <EvanR> whats Writer gottta do with it
01:12:44 * EvanR looks at the Applicative laws
01:12:46 <jle`> the Color and Trafic types above are isomorphic to Writer, so statements about Writer are true about COlor/Traffic
01:13:12 <jle`> or well, Writer (Fin 3) and Writer (Fin 2), respectively
01:13:21 <EvanR> Writer is a monad... those are just types
01:13:28 <EvanR> with no laws
01:13:30 <EvanR> yet
01:13:50 <jle`> well, writing a Monad for Writer (Fin 3) would be the same as writing a Monad for Traffic
01:13:56 <jle`> and Applicative
01:14:37 <EvanR> pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
01:15:02 <EvanR> is this the source of the monoid
01:15:32 <jle`> that's the associativity part, u <*> pure y = pure ($ y) <*> u is the identity part
01:16:10 <EvanR> thats crazy how the monoids have been here all along, and explains the writer
01:16:20 <EvanR> i though it was just for convenience writer was like that ;)
01:16:49 <EvanR> so other types which are not obviously choosing a monoid still are
01:19:13 <EvanR> https://www.reddit.com/r/haskell/comments/2lompe/where_do_the_applicative_laws_come_from/
01:24:05 <jle`> nice post :)
01:27:50 <quchen> jle`: I've heard that Monad and Applicative having a connection is because Hask is special (cartesian closed).
01:29:33 <wootehfoot> Hello! Does anyone here know a good framework for playing around with hypergraphs? Or any other good graph theory visualization related tool?
01:31:09 <jle`> quchen: hm, i can see that road vaguely
01:45:33 <EvanR> https://wiki.haskell.org/Hask "2 Hask is not Cartesian closed" ;)
01:55:50 <jle`> just noticing this, but transformers is actually a pretty nice library for functor and applicative transformers, not just the famous monad transformers we know and love
01:56:30 <quchen> jle`: In what sense? Applicative transformers are quite unspectacular
01:56:32 <jle`> and Traversable and Foldable transformers, too
01:57:02 <jle`> well, they serve as a canonical place for all of those fancy Traversable/Applicative transformers we talk about in passing
01:57:13 <fr33domlover> Q: Suppose I write a git web UI, and I use 'hit' or 'gitlib' or similar to access the git repos. These libraries have a per-repo context value which all API functions take as a parameter. Should I open one context per repo and keep them for the entire run time, or open them on demand whenever a git operation is needed?
01:57:23 <jle`> if i ever did need Backwards, then I know where to find it
01:58:44 <jle`> fr33domlover: i think the way gitlib is structured, you don't ever actually access the context value, right?
01:59:34 <fr33domlover> jle`, yes, you just create it and pass around: withRepo "/home/me/proj/.git" $ \ ctx -> do ...
02:00:15 <jle`> that depends on the backend i think
02:00:18 <fr33domlover> i just wonder about resource usage and time/operations and maybe locking involved in getting these contexts
02:00:35 <fr33domlover> the docs don't explain that use case, it seems
02:02:36 * hackagebot circle-packing 0.1.0.5 - Simple heuristic for packing discs of varying radii in a circle  https://hackage.haskell.org/package/circle-packing-0.1.0.5 (JoachimBreitner)
02:04:23 <fr33domlover> jle`, is the following relevant: it seems withRepo opens some .git data files which means the number of open file descriptors will be O(n) in the number of repos I have. Does that mean I should avoid holding all contexts open all the time?
02:05:08 <fr33domlover> generally, is O(n) file descriptors a bad/dangerous thing?
02:05:43 <Xandaros> EvanR: And that's why, while you work with Hask, you pretend you are actually working with Set :P
02:05:50 <jle`> oh, i'm only familiar with gitlib
02:05:53 <EvanR> never!
02:06:03 <jle`> hm, i'd imagine this would be similar to considerations you'd take whenm writing to normal files
02:06:11 <EvanR> I pretend its platonic hask
02:06:25 <Xandaros> Is there a difference?
02:07:21 <EvanR> Xandaros: Set is clearly out given types like newtype U = U (U -> Bool)
02:08:05 <EvanR> U is the type of functions from itself to Bool
02:08:12 <Xandaros> Isn't that Void?
02:08:18 <EvanR> which should be isomorphic to the subsets of U
02:08:21 <EvanR> (if U were a set)
02:08:22 <jle`> let u1 = U (\_ -> True)
02:08:31 <Xandaros> fair enough
02:08:37 <EvanR> const True and const False exist.. at least
02:08:47 <EvanR> you can build more on top of that
02:08:55 <jle`> let u2 = U (\(U f) -> f u1)
02:10:21 <EvanR> though now im wondering how to get a contradiction
02:12:53 <jle`> > execWriter . fowards . traverse Backwards $ [tell "1", tell "2", tell "3"]
02:12:55 <lambdabot>      Not in scope: ‘fowards’
02:12:55 <lambdabot>      Perhaps you meant ‘forwards’ (imported from Control.Applicative.Backwards)
02:13:01 <jle`> > execWriter . forwards . traverse Backwards $ [tell "1", tell "2", tell "3"]
02:13:04 <lambdabot>  "321"
02:13:19 <EvanR> right a set cant be bijective with the set of its own subsets
02:16:55 <EvanR> i adapted that from an ancient looking document called "polymorphism is not set theoretic" ... and lost the actual polymorphism along the way
02:22:25 <Gurkenglas> forwards . traverse Backwards is ala Backwards traverse btw
02:22:44 * hackagebot haphviz 0.1.2.0 - Graphviz code generation with Haskell  https://hackage.haskell.org/package/haphviz-0.1.2.0 (Norfair)
02:36:00 <bollu> so I'm skimming the paper of the Active package - http://ku-fpg.github.io/files/Matlage-10-BeginningMiddleEnd.pdf
02:36:06 <bollu> how is it any different from FRP?
02:41:06 <Xandaros> bollu: Have a look at the related works chapter, he compares it to (among others) fran
02:41:57 <bollu> Xandaros: thanks! 
02:43:27 <fr33domlover> When I can use StateT s IO, or RWST-on-top-of-IO, is there a reason to prefer IORef instead other than for optimization?
02:43:45 <bollu> I have a question related to using Active:
02:43:53 <bollu> I have an inherently discrete-time process
02:44:03 <bollu> but Active only supports continuous time evaluation
02:44:13 <liste> fr33domlover atomicModifyIORef et al
02:44:15 <bollu> so what do I do? do I "chop up" my animation ?
02:44:20 <liste> ie. concurrency
02:44:45 <EvanR> fr33domlover: really.. ReaderT over IO with IORefs or MVars takes care of State, and whatever logging you would do
02:44:48 <fr33domlover> liste, suppose concurrency isn't an issue, I have a single thread touching the state and threads communicate using Chan and MVar
02:44:49 <EvanR> plus you get exceptions
02:44:53 <bollu> as in, to I do something like t_discrete = floor((t * 1000) / 200) or something to get 5 pieces (hypothetically) ?
02:45:23 <Xandaros> bollu: I guess you can create discrete time steps in your animation function - only changing after a certain threshold was reached
02:45:33 <Xandaros> I don't know if there is another way, I didn't read the whole thing
02:46:25 <fr33domlover> EvanR, I use StateT usually since it seems to be the elegant functional-style solution and IORef is somewhat like involving imperative spaghetti code
02:46:30 <bollu> Xandaros: yes, that's what I think is most likely as well
02:46:52 <EvanR> fr33domlover: well youre using IO anyway
02:46:53 <bollu> Xandaros: but the interesting thing is, my process is a countable infinite discrete time process
02:47:05 <bollu> i.e - I don't have density on R, but I do have a bijection to N
02:47:06 <EvanR> and when using many "globals" its more convenient
02:47:08 <bollu> which is just weird
02:47:12 <bollu> I really don't know how to model it
02:47:43 <fr33domlover> EvanR, but not /everything/ is IO. With StateT I get a clean elegant separation between IO and pure code
02:48:09 <EvanR> its not that clean though... youll probably find its just a bunch of typing for nothing
02:48:33 <EvanR> some transformer over IO is effectively any other language
02:48:44 <EvanR> you can do anything
02:49:02 <EvanR> made more complex by being able to do even more than anything, the other monads
02:49:23 <fr33domlover> sure, but when I use StateT over IO, I use IO only for the really external effects, and aplication internal IO uses pure code
02:49:33 <t0by> I'm very confused. I'm doing excercise 1 from http://www.seas.upenn.edu/~cis194/spring13/hw/12-monads.pdf. Basically I'm supposed to simulate a Risk battle - i.e., roll 2 series of n dice, sort them and compare them. What is eluding me is *how* do I handle randomness. I don't have a clue, and investigating types isn't helping. Any hint?
02:49:34 <fr33domlover> *application internal state
02:49:36 <EvanR> its still mixed in throughou
02:51:52 <zd234> I need to regularly run a regexp over a 40MB file. What is the fastest haskell library for this? I don't need the full power of parsec/attoparsec. I just need regular old regular expressions.
02:52:15 * t0by smiles at "regular old regular expression"
02:52:59 * t0by thinks "(regular (old|expression))* expression"
02:53:00 <bollu> > 1 % 3
02:53:01 <maerwald> why do you think regex is faster than a parser library?
02:53:02 <lambdabot>  1 % 3
02:53:14 <bollu> wait, what? I don't have (%) in GHCi. What's going on?
02:53:16 <liste> t0by are you familiar with State ?
02:53:31 <t0by> liste, not really
02:53:32 <geekosaur> bollu, lambdabot imports Data.Ratio
02:53:51 <t0by> but cis194 hasn't introduced it to me *yet*
02:53:54 <bollu> ohh, thanks
02:53:57 <t0by> so I'm not sure if I actually need it for this one
02:54:00 <bollu> geekosaur: but it's part of Prelude right?
02:54:01 <zd234> maerwald: I don't know for a fact; but i believer the fastest grep is in C, not in haskell; so thus it seems that a c-native regex (with haskell ffi) is faster than haskell parsec
02:54:12 <geekosaur> nope
02:54:35 <t0by> liste, I dare not open it, but here is a solution: https://github.com/ibebrett/Haskell-CS194/tree/master/ex12
02:54:37 <geekosaur> the type synonym Rational is, but the operator (%) isn't
02:54:40 <geekosaur> annoyingly
02:54:44 <bollu> geekosaur: how do I floor a Rational?
02:54:46 <bollu> I see
02:54:51 <bollu> that's weird library design
02:54:56 <t0by> you might want to peek :)
02:55:18 <pyon> Would it be possible to define Foldable in terms of a single method: “toList :: Foldable f => f a -> [a]” ?
02:55:29 <t0by> liste, apparently Control.Monad.Random is everything I ought to need
02:55:32 <liste> t0by in page 2 of that pdf is threeInts :: Generator -> ((Int, Int, Int), Generator)
02:55:44 <geekosaur> I think the main reason (%) isn't there is that 99% of the time (/) works
02:55:49 <bollu> pyon: technically yes, but in some sense no, because list != free monoid for reasons I don't remember
02:55:55 <t0by> stupid me
02:56:00 <t0by> liste, thanks
02:56:00 <pyon> bollu: Because it can be infinite.
02:56:02 <t0by> nextInt
02:56:03 <t0by> d'oh
02:56:09 <EvanR> zd234: you can of course simply call grep from haskell using a system commad
02:56:10 <bollu> pyon: ah yes, righ
02:56:17 <liste> t0by that's a simplified version of what Rand does
02:56:23 <bollu> pyon: you lose a way to compute a <> b <> ...
02:56:29 <t0by> ah
02:56:38 <pyon> Yeah, what I had in mind is that “toList” should always produce finite lists.
02:57:08 <liste> t0by it takes a generator state and produces three ints and the next generator state
02:57:16 <bollu> geekosaur: do you know how I can floor a Ratio?
02:57:19 <bollu> Rational*
02:57:32 <geekosaur> not off the top of my head, no
02:57:45 * hackagebot profiteur 0.3.0.0 - Treemap visualiser for GHC prof files  https://hackage.haskell.org/package/profiteur-0.3.0.0 (JasperVanDerJeugt)
02:57:46 <geekosaur> it's more annoying than for floating point
02:57:48 <t0by> but liste, how to I try that out in ghci?
02:58:08 <t0by> I can't just "show threeInts"
02:58:18 <bollu> I really wish Haskell's numeric types story was proper
02:59:01 <geekosaur> the "more annoying" has less to do with Haskell's type system and more to do with the nature of ratios
02:59:33 <maerwald> bollu: indeed
02:59:57 <bollu> > toInteger (1 % 3)
02:59:59 <lambdabot>      No instance for (Integral (Ratio a0))
02:59:59 <lambdabot>        arising from a use of ‘toInteger’
02:59:59 <lambdabot>      In the expression: toInteger (1 % 3)    No instance for (Num a0) arising...
03:00:09 <liste> t0by import Control.Monad.Random
03:00:13 <maerwald> bollu: but the problem with haskell now is that it's successful :/
03:00:19 <t0by> liste, done
03:00:26 <t0by> but what's useful in there?
03:00:29 <bollu> maerwald: xD
03:00:56 <bollu> can someone help me? IMO Rational should have a toInteger, because Rational = Ratio Integer, and an Integer has an Integral instance
03:01:01 <bollu> omg that sentence is like brain damage
03:01:04 <Xandaros> You could convert to Integral and then floor, couldn't you? :D
03:01:07 <liste> t0by StdGen is roughly equivalent to Generator on that page
03:01:32 <bollu> Xandaros: I'm trying that, but it's not able to find the instance of Integral
03:01:34 <hexagoxel> :exf "Rational -> Integer"
03:01:34 <exferenceBot> floor
03:01:35 <exferenceBot> ceiling
03:01:35 <exferenceBot> round
03:01:35 <exferenceBot> truncate
03:01:47 <pyon> So, what exactly is gained by defining Foldable in terms of foldMap and friends, rather than toList? It seems to me that the definition in terms of toList is simpler, and the inefficiency of the intermediate lazy cons cells can be eliminated using deforestation.
03:01:57 <bollu> I need to rtfm better
03:02:00 <bollu> cool, floor works
03:02:01 <bollu> thanks! :D
03:02:23 <bollu> but where are they defined?
03:02:31 <Xandaros> > floor . fromRational $ (5 % 2) -- :P
03:02:33 <lambdabot>  2
03:02:43 <liste> t0by try "let gen = mkStdGen 15" and "let (x, gen2) = next gen"
03:02:53 <t0by> liste, unDV (evalRandIO (die)) gives me mismatch between DieValue and IO DieValue
03:02:53 <bollu> oh, it's in Prelude
03:03:00 <bollu> prelude is messy :(
03:03:03 <hexagoxel> RealFrac
03:03:04 <Xandaros> I've never actually used rational
03:03:06 <Xandaros> yes, yes it is
03:03:12 <bollu> I have to use it for the Data.Active package
03:03:54 <bollu> how do map [0, 1] to N?
03:03:59 <bollu> in a linear way
03:04:08 <liste> t0by "DieValue" is the type of a value, and "IO DieValue" is the type of an IO action that *produces* a value
03:04:16 <bollu> f :: [0, 1] -> N, df/dx = 0 (is that possible?)
03:04:34 <liste> (the action happens to be a value too, but you can't do much with it)
03:04:34 <t0by> liste, fair enough, but then I would expect (evalRandIO (unDV die)) to work>
03:04:36 <t0by> ?
03:04:51 <t0by> liste, how do I manipulate that in order to coaxx an actual numerical result out of it?
03:04:53 <t0by> *coax
03:04:57 <t0by> *numeric
03:04:58 <t0by> *arf
03:06:27 <liste> t0by have you used liftM or fmap?
03:06:39 <t0by> aaah
03:06:48 <t0by> don't tell me...
03:06:50 <Wizek> Hello! Might anyone know how to get around this building issue? https://gist.github.com/Wizek/c0334800377f960e69fe I've tried to do it with stack, but no luck yet.
03:06:58 <t0by> HA
03:07:05 <t0by> evalRandIO(fmap unDV (die))
03:07:11 <t0by> trivial. in retrospect.
03:07:38 <t0by> thanks liste 
03:07:42 <liste> yw (:
03:07:53 <Axman6> @hoogle a -> Fold a b -> Fold a b
03:07:55 <lambdabot> Warning: Unknown type Fold
03:07:55 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
03:07:55 <lambdabot> Data.Graph.Inductive.NodeMap delMapNode :: (Ord a, DynGraph g) => NodeMap a -> a -> g a b -> g a b
03:08:28 <t0by> liste, any pointer to gain a more thorough understanding of the thing? I feel I'm not completely understanding it, I'm doing the exercises for this very purpouse
03:08:31 <t0by> purpose
03:08:39 <t0by> pur... something.
03:10:13 <liste> t0by about the Rand monad or monads in general?
03:10:22 <t0by> probably <=>
03:15:25 <liste> t0by how much are monads used in cis194 yet?
03:15:38 <t0by> liste, 12 is the one about monads.
03:15:50 <t0by> I can't say the introduction is exactly gentle
03:15:53 <liste> and this is the first homework about it?
03:15:57 <t0by> compared to the rest of the material
03:15:59 <t0by> yup
03:16:13 <maerwald> did you do applicatives before?
03:16:21 <t0by> yes, I'm going in strict order
03:16:34 <t0by> but I am eemingly hitting a cognitive wall here
03:16:46 <t0by> possibly too many years of boilerplate code in Java.
03:17:09 <EvanR> we have boilerplate too if you want some
03:17:10 <t0by> But let me work on it, I might be on the right track :)
03:17:33 <liste> t0by maybe playing around with some other Monads gives you some intuition
03:17:54 <Xandaros> EvanR: I thought TH was supposed to eliminate that? :D
03:18:19 <EvanR> also SYB
03:18:23 * hackagebot clash-lib 0.6.9 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.9 (ChristiaanBaaij)
03:18:25 * hackagebot clash-systemverilog 0.6.5 - CAES Language for Synchronous Hardware - SystemVerilog backend  https://hackage.haskell.org/package/clash-systemverilog-0.6.5 (ChristiaanBaaij)
03:18:27 * hackagebot clash-verilog 0.6.5 - CAES Language for Synchronous Hardware - Verilog backend  https://hackage.haskell.org/package/clash-verilog-0.6.5 (ChristiaanBaaij)
03:18:29 * hackagebot clash-vhdl 0.6.6 - CAES Language for Synchronous Hardware - VHDL backend  https://hackage.haskell.org/package/clash-vhdl-0.6.6 (ChristiaanBaaij)
03:18:31 * hackagebot clash-ghc 0.6.9 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.9 (ChristiaanBaaij)
03:18:49 <maerwald> t0by: I find this SO answer good wrt applicative vs monad https://stackoverflow.com/questions/17409260/what-advantage-does-monad-give-us-over-an-applicative (the accepted one)
03:19:47 <lisbeth> I am in ubutntu 15.04, and I accidentally installed the stack package for 14.04
03:20:34 <bollu> byorgey: ping. I've updated a 404ing link in the Active documentation - https://github.com/diagrams/active/pull/17
03:20:35 <lisbeth> and I am wondering if I need to remove the ppa and add the correct one
03:22:24 <Rouven> maerwald: That is an excellent explanation
03:22:27 <EvanR> maerwald: nice... ifA doesn't work because with Applicative you can't see whats coming up and avoid it, you have to trample through all effects, no exceptions
03:23:28 <maerwald> yeah you sort of run all effects and then decide what the actual result is
03:23:33 * hackagebot postgresql-binary 0.7.7 - Encoders and decoders for the PostgreSQL's binary format  https://hackage.haskell.org/package/postgresql-binary-0.7.7 (NikitaVolkov)
03:23:35 * hackagebot hasql 0.19.5 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.19.5 (NikitaVolkov)
03:24:57 <liste> > [1..3] >>= \x -> [1..x] >>= \y -> return (y, y+1) -- t0by Monad [] is quite nice (:
03:24:59 <lambdabot>  [(1,2),(1,2),(2,3),(1,2),(2,3),(3,4)]
03:25:21 <t0by> i don't think monads are the problem
03:25:39 <t0by> I suspect my brain is fighting with working without being able to print *some* representation of what I'm working with
03:25:49 <t0by> (unless I fmap stuff and add complexity)
03:26:00 <Xandaros> Have a look at the Debug.Trace module
03:26:20 <Xandaros> It can be quite useful at times, though I actually find myself not using it very often
03:26:27 <Xandaros> It is also deeply magical, so be careful
03:26:35 <maerwald> it's just unsafePerformIO
03:26:43 <Xandaros> As I said - magic :P
03:26:55 <Xandaros> (and noinline pragmas, I'm pretty sure)
03:29:19 <ocharles_> Hi, can anyone explain why this program using delimited continuations doesn't crash on the use of  `undefined`?
03:29:20 <ocharles_> runContT (resetT (shiftT (\k -> liftIO (k undefined) >> liftIO (k "World")))) putStrLn
03:29:33 <ocharles_> > runContT (resetT (shiftT (\k -> liftIO (k undefined) >> liftIO (k "World")))) putStrLn
03:29:35 <lambdabot>  Not in scope: ‘resetT’    Not in scope: ‘shiftT’
03:29:35 <lambdabot>      Perhaps you meant one of these:
03:29:35 <lambdabot>        ‘shiftL’ (imported from Data.Bits),
03:29:39 <ocharles_> bah.
03:33:51 <Xandaros> I don't even... What even is Cont? Looking at the name, I thought it might be similar to a coroutine... looking at the description on hackage, I think it might be similar to futures... In general, I think I have no idea what even
03:34:20 <liste> "cont" is for "continuation"
03:35:06 <liste> isn't it basically CPS packaged in a monad? I don't totally grok it either
03:35:26 <bollu> Xandaros: It's a way to represent "anyway, …" in haskell ;)
03:35:32 <bollu> Xandaros: the idea is something like this:
03:35:36 <bollu> consider the type of ($)
03:35:43 <bollu> ($) :: (a -> b) -> a -> b
03:35:46 <bollu> right?
03:35:48 <Xandaros> right.
03:35:55 <bollu> so now, consider flip ($)
03:36:04 <bollu> flip ($) :: a -> (a -> b) -> b
03:36:19 <bollu> > let (|>) = flip ($) in [1, 2, 3] |> map (+1)
03:36:21 <lambdabot>  [2,3,4]
03:36:35 <bollu> > let (|>) = flip ($) in [1, 2, 3] |> map (+1)  |> filter even
03:36:37 <lambdabot>  [2,4]
03:36:49 <bollu> so (|>) lets us form "computation pipes" in some sense
03:36:52 <bollu> that have to end with a value
03:37:20 <bollu> however, you can ask the question: what if I don't want to end the pipe? That is, I want to represent a "pipe that can still be attached to"? or a "pipeline" of values?
03:37:38 <bollu> in some sense, [1, 2, 3] |> is *exactly* that. It is waiting for a function f to operate on it
03:37:49 <bollu> a function like map (+ 1)  or filter even
03:37:58 <bollu> so, if you choose to look at the type of (|>)
03:38:04 <bollu> (|>) :: a -> (a -> b) -> b
03:38:09 <bollu> now, partially apply a on it
03:38:13 <bollu> that gives you the type
03:38:16 <bollu> (a -> b) -> b
03:38:21 <Xandaros> I see
03:38:24 * hackagebot success 0.2.5 - A version of Either specialised for encoding of success or failure  https://hackage.haskell.org/package/success-0.2.5 (NikitaVolkov)
03:38:25 <bollu> or in continuation parlance, Cont a r = (a -> r) -> r
03:38:26 * hackagebot binary-parser 0.5.1 - A highly-efficient but limited parser API specialised for bytestrings  https://hackage.haskell.org/package/binary-parser-0.5.1 (NikitaVolkov)
03:38:28 * hackagebot postgresql-binary 0.7.8 - Encoders and decoders for the PostgreSQL's binary format  https://hackage.haskell.org/package/postgresql-binary-0.7.8 (NikitaVolkov)
03:38:28 <bollu> "r" is for "return"
03:38:35 <bollu> Cont a r = (a -> r) -> r
03:38:44 <bollu> this type has functor, applicative, and monad instances
03:38:58 <bollu> but the most interesting function to implement on a continuation is callCC
03:39:10 <bollu> which lets you do weird things with control flow
03:39:59 <Xandaros> So my coroutine analogy wasn't so far off, then, I guess
03:40:01 <bollu> Xandaros: this might help - https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
03:40:19 <bollu> Xandaros: yes, you can implement coroutines with continuations AFAIK
03:40:39 <ocharles_> so now that we know what they are, what's going on with my code? :)
03:40:59 <bollu> there are also extensions to continuations called as "indexed continuations" AFAIK (https://gist.github.com/pthariensflame/5716594)
03:41:05 <bollu> I don't know anything about them
03:41:09 <Xandaros> ocharles_: sorry. I was thinking about not asking so as not to distract from your question, but decided to ask anyway
03:41:20 <ocharles_> Xandaros: don't worry, we're all here to learn!
03:41:52 <bollu> ocharles_: did I do justice to continuations? :) I'm not super confident of my callCC-foo
03:42:02 <ocharles_> callCC and friends I get fine, but it's the delimited aspect that I'm apparently not understanding very well
03:42:13 <ocharles_> bollu: i'd say so, don't disagree with anything you said
03:43:24 * hackagebot hasql 0.19.6 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.19.6 (NikitaVolkov)
03:45:28 * ocharles_ reads https://wiki.haskell.org/Library/CC-delcont#Delimited_continuations
03:53:48 * ocharles_ remains confused :)
03:54:46 <ocharles_> runContT (resetT (shiftT $ \k -> lift (k "A" ++ k "B"))) (\x -> [x,x]) at least does what I'd expect though
03:55:21 <ocharles_> yet runContT (resetT (shiftT $ \k -> lift (k "A" >> k "B"))) putStrLn doesn't (though it's equivalent to what I first pasted due to the monad transformer laws)
03:57:13 <EvanR> so contT over IO...
03:57:26 <ocharles_> runContT (resetT (shiftT $ \k -> lift (k "A" >>= k))) putStrLn and then this goes and prints A?!?
03:57:33 <ocharles_> *mind explosion*
03:57:35 <EvanR> sounds like the end of ghost busters
03:58:09 <EvanR> contT is the keymaster, IO is the gatekeeper (or perhaps the other way around)
03:58:31 <EvanR> ocharles_: for every Cont action dont you need to use specially crafted CPS routines?
03:58:37 <EvanR> maybe thats why IO isnt working?
03:59:04 <ocharles_> what specially crafted CPS routines?
03:59:38 <EvanR> like do x <- act foo bar... act foo bar has to use CPS
03:59:51 <EvanR> i.e. itll get a continuation
04:00:01 <EvanR> and should use it, or return
04:00:50 <EvanR> sorry im just guessing
04:02:09 <ocharles_> i'd still like to know, if IO is "wrong", how it is wrong
04:02:19 <ocharles_> but I don't think it is, I think I'm just misunderstanding something so my expectations are wrong
04:02:44 <EvanR> i am not clear on resetT or shiftT
04:05:05 * ocharles_ tries again with http://blog.moertel.com/posts/2005-09-13-scope-herding-with-delimited-continuations.html
04:08:54 <ocharles_> ok, this makes more sense now. k doesn't refer to the putStrLn, it refers to what comes after "shiftT" inside the "resetT" block - so basically what resetT will return
04:09:22 <ocharles_> so when I call it twice it the first return is essentially discarded because there's another call to k, which re-enters the reset block
04:09:48 <ocharles_> though I can't really explain what's going on with lift (k "A" >>= k) yet. I'll chew on that one a bit more
04:11:00 <kqr> *if* I wanted to do parsing with regexes in Haskell, which regex library would I use? note: i know this is a dumb idea and I'm not trying to do it – it's an example of what not to do for a parsing tutorial
04:12:18 <kqr> i realised I have no idea how to work with regexes in haskell because I so rarely need them for anything other than simple verification
04:13:43 <kqr> i guess regex-compat-tdfa will suffice
04:22:50 <Profpatsch> What are some practical examples of instances of Contravariant?
04:23:22 <Profpatsch> Non-trivial, I kind of get Const. :)
04:23:45 <EvanR> you can compose predicates... a -> Bool
04:25:13 <EvanR> (a -> b) -> (b -> Bool) -> (a -> Bool)
04:25:23 <EvanR> well, (contra)map predicates
04:25:32 <none_> @pl (\x -> x `mod` 7 == 0)
04:25:32 <lambdabot> (0 ==) . (`mod` 7)
04:30:39 <liste> wow, a readable outcome from @pl !
04:30:56 <EvanR> sort of
04:31:05 <liste> (btw, why did it change == 0 to 0 == ?)
04:31:26 <bergmark> because it CAN?
04:31:38 <EvanR> is `mod` or == higher
04:31:43 <EvanR> i guess mod
04:32:20 <liste> @unpl (0 ==) . (`mod` 7)
04:32:20 <lambdabot> (\ e -> 0 == (mod e 7))
04:32:24 <EvanR> did it use symmetric property?
04:34:40 <lyxia> @pl (\x -> x `mod` 7 - 0)
04:34:41 <lambdabot> subtract 0 . (`mod` 7)
04:38:51 <kqr> Module ‘Turtle.Pattern’ does not export ‘invert’
04:38:54 <kqr> what does this mean?
04:39:00 <kqr> https://hackage.haskell.org/package/turtle-1.2.5/docs/Turtle-Pattern.html
04:39:05 <kqr> it looks as though it should be exported
04:39:09 <KaneTW> EvanR: rip my dream of encoding a network protocol in the type system (some packets have the same type index but contain different data based on what state the connection is in)
04:39:36 <EvanR> fail
04:40:38 <exio4> KaneTW: add a (s :: ConnectionState) parameter
04:40:46 <KaneTW> yeah
04:40:57 <EvanR> well not ever bit of data needs to be encoded in the type
04:40:57 <kqr> oh never mind. I had a really old version of turtle
04:41:07 <KaneTW> EvanR: it's more of an exercise
04:41:08 <jle`> kqr: that was going to be my guess
04:41:14 <EvanR> just whatever properties you want to enforce
04:41:16 <jle`> but you debug too fast
04:41:51 <kqr> jle`, funny thing was I went back to older versions on hackage and I was like "pah, it can't be more than 6 months old so there has to be something else wrong". turns out my turtle version was like one month old :)
04:41:57 <kqr> one month too old*
04:42:01 <kqr> seven months old by now
04:42:03 <kqr> or something
04:42:10 <KaneTW>  https://github.com/KaneTW/knxd-native-client/blob/master/src/KNXd/Client/Internal.hs
04:42:11 <Profpatsch> EvanR: I’m still not sure how Contravariant is useful
04:42:14 <Profpatsch> getEquivalence (contramap _ $ Equivalence (==)) 5 5
04:42:23 <Profpatsch> _ :: Integere -> ()
04:42:30 <Profpatsch> *Intereg
04:42:41 <Profpatsch> Bah, Integer
04:43:48 <EvanR> thats basically part of kmett-skell ;)
04:44:01 <Profpatsch> I’d expect I can change the equivalence comparison with the contramap.
04:44:03 <jle`> Profpatsch: https://ocharles.org.uk/blog/guest-posts/2013-12-21-24-days-of-hackage-contravariant.html
04:44:16 <Profpatsch> jle`: Oh, nice.
04:44:20 <Profpatsch> This will explain $things
04:44:41 <EvanR> all that stuff seems more like brain exercises to me
04:45:17 <Profpatsch> EvanR: Well, I came from https://hackage.haskell.org/package/rebase
04:45:21 <exio4> Prop a sounds like a handy contravariant functor
04:45:39 <Profpatsch> And this makes it seam like Contravariant is used everywhere in modern Haskell.
04:46:02 <Profpatsch> But to me it seems more like Comonads, there are simply not that many instances people use.
04:46:09 <jle`> contravariant type parameters are pretty common
04:46:19 <jle`> but the Contravariant typeclass is itself not super common
04:46:46 <Profpatsch> Oh, it’s to change the *type*
04:46:48 <jle`> in fact one of the most commonly used types has a contravariant type parameter
04:46:59 <jle`> one of the ones we always introduce first in Haskell
04:47:09 <jle`> (->) is contravariant on its first parameter :O
04:47:57 <KaneTW> currwntly my boggest gripe is serializeEvidence
04:48:08 <KaneTW> biggeat/
04:48:13 <KaneTW> goddamnit mobile
04:49:34 <Profpatsch> newtype Op a b = Op { getOp :: b -> a }
04:49:41 <Profpatsch> jle`: That would explain stuff ^
04:49:57 <KaneTW> but i can't think of another way to tell the typesystem that theres an instance of those classes for every type in the data kinds
05:02:34 <Profpatsch> jle`: I’m always confused by contravariance, because the OO-tribe seems to have placed a claim on the word.
05:02:39 <Profpatsch> See also https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)
05:02:57 <Profpatsch> Is contravariance in subtyping something related, or is it completely different?
06:20:50 <jophish__> Has anyone here used clash?
06:30:45 <apsod> What is the relationship between kinds and categories?
06:32:00 <apsod> If you unsquint, the kind of a Functor (* -> *) looks an awful lot like (c -> d)
06:33:22 <apsod> but we're just lumping it all into the same category: *.   
06:36:36 <geekosaur> apsod, kind is a classification of parameters. I would not expect it to have much relationship to a category, unless that category is defined around classification of parameters
06:37:03 <geekosaur> just because they both use * doesn't mean they are talking about the same thing with it
06:37:14 <geekosaur> necessarily
06:43:10 <mnoonan> Isn't * just another name for the objects in the category Hask?
06:43:19 <mnoonan> (maybe not anymore with type-in-type?)
06:45:46 <apsod> And also morphism in the category hask (which, i guess, coincide)
06:46:03 <apsod> :k (Int -> Char)
06:46:05 <lambdabot> *
06:47:11 <fractalsea> Is there a function for swapping the “order” of nested HashMaps, i.e.: `HashMap k1 (HashMap k2 v) -> HashMap k2 (HashMap k1 v)`?
06:48:51 <apsod> geekosaur, what do you mean by classification of parameters? The type of type constructors?
06:49:17 <apsod> also, I'm not interested in _a_ category, but categories. 
06:49:32 <geekosaur> I wanted something more correct than "number of parameters", since
06:49:36 <geekosaur> :k StateT
06:49:37 <lambdabot> * -> (* -> *) -> * -> *
06:50:44 <geekosaur> so sort of the "shape" of any parameters
06:51:08 * geekosaur not really a category theory type; don;t expect correct jargon...
06:51:11 <julianleviston> fractalsea: how would that work? 
06:52:21 <geekosaur> although I'm not talking category theory here, really. I don't think this actually maps to anything, but if it does then it's at a different level (e.g. maybe specific categories or something)
06:52:22 <apsod> yes. But StateT could be seen as taking a state from category s, a Functor (s,x) -> d,  and a category x?
06:53:30 * hackagebot yesod-table 2.0.2 - HTML tables for Yesod  https://hackage.haskell.org/package/yesod-table-2.0.2 (andrewthad)
06:56:38 <puregreen> how can I set widget's cursor in gtk? I don't see any functions for that
06:58:09 <fractalsea> julianleviston, as you would expect: fromList [("a", [(1, "v1"), (2, "v2")])("b", [(1, "v3"), (2, "v2"), (3, "v4")])] -> fromList [(1, [("a", "v1"), ("b", "v3")], (2, [("a", "v2"), ("b", "v2")]), (3, [("b", "v4")]))]
06:59:11 <fractalsea> I could implement it myself, but it’s a shame that there’s nothing in a library
07:03:38 <julianleviston> fractalsea: isn’t there a potential issue with collisions, though?
07:04:44 <julianleviston> fractalsea: I guess not. 
07:04:52 <fractalsea> Not that I can think of
07:05:26 <julianleviston> fractalsea: sounds a bit lens traversal-ish
07:06:03 <julianleviston> fractalsea: or just traversal
07:06:26 <julianleviston> :t sequenceA
07:06:27 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
07:06:43 <fractalsea> julianleviston, well I’m probably going to try and do it with a folds because I’m not that experienced with lens. It will be fiddly though
07:06:47 <julianleviston> fractalsea: I’m not experienced enough in that to know it’s applicable here though
07:07:00 <fractalsea> ok
07:07:04 <fractalsea> Well thanks
07:07:08 <julianleviston> isn’t sequenceA perfect?
07:07:28 <fractalsea> um
07:08:10 <Shockk> mauke: hello, I wondered, do you still update data-default and take feature requests for it?
07:08:16 <fractalsea> But HashMap isn’t an Applicative
07:08:22 <Sornaensis> Shockk you didn't change your nick on freenode
07:08:25 <Sornaensis> are you serious
07:08:29 <Sornaensis> IS THIS REAL LIFE
07:09:14 <Shockk> maybe
07:09:35 <julianleviston> fractalsea: it has an instance of Traversable
07:09:47 <Sornaensis> :t []
07:09:48 <lambdabot> [t]
07:09:51 <Sornaensis> thanks
07:10:01 <Sornaensis> :info (:)
07:11:23 <julianleviston> fractalsea: I don’t think it’s hard to implement Applicative, is it?
07:11:40 <julianleviston> fractalsea: I dunno. I’ll be quiet :)
07:12:22 <fractalsea> julianleviston, maybe, but HashMap really isn’t an Applicative. It doesn’t satisfy any of the laws. I think sequenceA is more for building up effects as you traverse a data structure
07:12:45 <julianleviston> fractalsea: yeah, I need to study those things more.
07:12:56 <fractalsea> julianleviston, dw I’ll have a go at doing it with fold. Thanks for your help
07:15:07 <julianleviston> fractalsea: np. Sorry I wasn’t more help.
07:24:02 <Shockk> just wondering, I have a bit of code here https://gist.github.com/shockkolate/1a0ed3fe5379c93db42a and I feel like there should be a simpler way of writing it
07:24:29 <Shockk> since in both cases the result is (pure theMaybeValue)
07:29:24 <average> will my haskell learning process be faster if I grow a moustache, wear a low-cut vest, wear converse sneakers, drink organic coffee or convert to veganism ?
07:29:36 <cocreature> average: ye
07:29:38 <cocreature> s
07:29:48 <frerich> average: You should drop the sneakers and go barefoot based on what I've seen.
07:30:04 <average> frerich: what have you seen ?
07:30:16 <frerich> average: Things, which cannot be unseen.
07:30:34 <average> frerich: like.. and such as.. what ?
07:30:43 <frerich> average: I'm sorry, I'd rather not talk about it.
07:30:49 <average> frerich: please do
07:30:52 <average> I am very open
07:32:06 * hodapp stares blankly
07:32:33 * sm shuffles nervously
07:33:25 --- mode: ChanServ set +o shapr
07:33:35 <coconut1> how to get today's date in showGregorian format?
07:34:15 --- mode: ChanServ set +o johnw
07:34:46 <frerich> coconut1: You can use 'getCurrentTime >>= return . toGregorian . utctDay'
07:35:00 <Sornaensis> u gotta get some vibrams or something
07:35:11 <frerich> coconut1: That gives you an 'IO (Integer,Int,Int)' (Year/Month/Day)
07:35:16 <coconut1> frerich, thanks. how can you reply so fast ?
07:35:57 <average> coconut1: he may be on an organic coffee diet
07:35:58 <lambdafan> http://lpaste.net/151161
07:36:00 <frerich> coconut1: In one of my projects, I have a definition 'date = getCurrentTime >>= return . toGregorian . utctDay' :-)
07:36:28 <frerich> coconut1: I just remembered that I did this once
07:36:29 <lambdafan> I'm messing around with Base64.ByteString and have come up with a ToJSON instance. Wondering if it makes sense
07:36:39 <cocreature> >>= return is just fmap no?
07:36:58 <Shockk> anyone have any ideas about how to simplify that code that I linked above? I'm trying to think of ways to but I've come up empty
07:37:27 <frerich> coconut1: Yeah :-)
07:38:07 <average> Shockk: i can offer you a shorter alternative
07:38:25 <cocreature> Shockk: mapM should help
07:38:31 * hackagebot casadi-bindings 2.4.1.8 - mid-level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-2.4.1.8 (GregHorn)
07:38:31 <cocreature> eh traverse
07:38:45 <average> cocreature: I have a shorter version
07:39:08 <Shockk> hmm?
07:39:27 <average> well, I already gave it to you
07:39:36 <average> the shortest code, is no code at all
07:40:02 <average> you can't get any more haskell than that
07:40:06 <Shockk> ..
07:40:10 <cocreature> traverse (\x -> put x >> x) or something like that
07:40:23 <Shockk> cocreature: ahh I see
07:40:29 <cocreature> can’t test it right now
07:40:51 <Shockk> I'll be able to test it as soon as I finish moving code over to another file and it stops breaking things
07:41:14 <cocreature> -fdefer-type-errors is your friend
07:42:51 <vektor> Hey guys! Has anyone tried lambdacube and GPipe and can compare them briefly?
07:43:31 * hackagebot darcs 2.10.3 - a distributed, interactive, smart revision control system  https://hackage.haskell.org/package/darcs-2.10.3 (GuillaumeHoffmann)
07:44:48 <chipf0rk> cocreature: I think >>= return is fmap with a Monad constraint; but (.) has a much higher precedence than (>>=), so it's not >>= return... but >>= (return . toGregorian . utctDay)
07:45:08 <chipf0rk> I like my parens
07:45:10 <cocreature> chipf0rk: I was just being lazy :)
07:45:43 <cocreature> it's fmap (toGregorian . utctDay) in this case
07:46:11 <chipf0rk> right, sorry :)
07:49:49 <average> can I use Docker with Haskell ?
07:50:55 <benma> average: not an expert, but since stack has docker support, i would assume so
07:52:44 <hodapp> average: what sort of usage of Docker are you aiming for?
07:53:16 <maerwald> he has already trolled in the #docker channel
07:53:26 <average> maerwald: that is so not true
07:53:31 <maerwald> it is
07:53:39 <average> it is yes, it is not true
08:00:42 <Myrl-saki> Why is fix (&& False) == bottom
08:00:46 <Myrl-saki> And why is fix (0*) == bottom
08:00:50 <Myrl-saki> When fix (False &&) and fix (*0) are both not bottom?
08:02:38 <puregreen> TIL (*) is sometimes lazy
08:03:05 <puregreen> Myrl-saki: for the same reason False && undefined is False, but undefined && False is undefined
08:03:15 <cocreature> I think it’s only for integers, see https://hackage.haskell.org/package/integer-gmp-1.0.0.0/docs/src/GHC.Integer.Type.html#timesInteger
08:03:26 <cocreature> the first pattern match doesn’t evaluate the left argument
08:03:52 <Myrl-saki> puregreen: Wait, what?
08:04:01 <Myrl-saki> Really?
08:04:24 <Myrl-saki> Why is undefined && False undefined then?
08:04:28 <puregreen> Myrl-saki: equations are checked top-to-bottom, so order matters
08:04:33 <puregreen> @src (&&)
08:04:34 <lambdabot> True  && x = x
08:04:34 <lambdabot> False && _ = False
08:04:40 <Myrl-saki> Hmmm...
08:04:46 <Myrl-saki> I see.
08:05:39 <Myrl-saki> puregreen: Do the standards dictate (&&)'s behaviro to be like that?
08:05:47 <Myrl-saki> @src (*) :: Int -> Int -> Int
08:05:48 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
08:05:51 <Myrl-saki> @src (*)
08:05:52 <lambdabot> Source not found. My pet ferret can type better than you!
08:06:39 <cocreature> Myrl-saki: I already linked the source for (*)
08:07:01 <Myrl-saki> cocreature: Ah, my apologies.
08:07:13 <cocreature> np
08:07:46 <cocreature> I’m actually kinda surprised that it first pattern matches on the right argument, but I suppose there is not a good reason to first match on the left argument
08:07:59 <Myrl-saki> Hmmm...
08:08:59 <Myrl-saki> cocreature: If we change the definition.
08:09:09 <Myrl-saki> Even just switching the two.
08:09:12 <Myrl-saki> Actually, no.
08:09:28 <cocreature> Myrl-saki: if you change the first two matches fix (0*) will be 0 and fix (*0) will be bottom
08:09:44 <Myrl-saki> Right...
08:10:11 <Myrl-saki> cocreature: I wonder if there'll be another way to do this.
08:10:16 <Myrl-saki> Basically, "partial" checks or something.
08:10:35 <Myrl-saki> Or rather, do 2 checks in parallel, and use either which is defined.
08:10:51 <Myrl-saki> Hmmm, wouldn't that be possible actually?
08:11:00 <Myrl-saki> Like.
08:11:12 <Myrl-saki> f X _ = A; f _ Y = A;
08:11:34 <Myrl-saki> Since both have the same output, then test both in parallel.
08:11:57 <cocreature> ghc is not smart enough to know that this is safe :)
08:12:21 <Myrl-saki> cocreature: The question though, is it safe?
08:12:31 <Myrl-saki> cocreature: I basically don't trust myself anymore.
08:12:45 <cocreature> Myrl-saki: well in this case probably yes, but you can write code where the order matters so then it should no longer be safe
08:12:55 <Myrl-saki> Right.
08:13:08 <Myrl-saki> How about this.
08:13:16 <Myrl-saki> Adjacent cases, with the same output, are ran in parallel.
08:13:31 <cocreature> if the outputs are always the same there is no reason to write separate matches
08:13:32 * hackagebot elision 0.1.0.2 - A data structure over two functions to be linked together at a later time.  https://hackage.haskell.org/package/elision-0.1.0.2 (jacrough)
08:14:08 <Myrl-saki> cocreature: Avoiding evaluation.
08:14:34 <Myrl-saki> cocreature: One argument may be defined.
08:58:34 * hackagebot vector-space 0.10.3 - Vector & affine spaces, linear maps, and derivatives  https://hackage.haskell.org/package/vector-space-0.10.3 (ConalElliott)
08:58:36 * hackagebot aivika 4.3.2 - A multi-paradigm simulation library  https://hackage.haskell.org/package/aivika-4.3.2 (DavidSorokin)
09:00:35 <ironChicken> any comments on the function defined at <https://github.com/TransformingMusicology/HVamp/blob/master/src/HVamp.hs#L97>?
09:01:14 <ironChicken> i think i want to know whether it's necessary (or overkill) and whether it (or something like it) already exists somewhere
09:01:22 <ironChicken> couldn't find anything on hoogle
09:02:34 <tommd> ironChicken: maybeM = maybe (return def) f
09:02:44 <tommd> ironChicken: Given that, it seems unlikely a helper exists.
09:03:34 * hackagebot aivika-transformers 4.3.1 - Transformers for the Aivika simulation library  https://hackage.haskell.org/package/aivika-transformers-4.3.1 (DavidSorokin)
09:03:36 * hackagebot aivika-branches 0.1 - Branching discrete event simulation library  https://hackage.haskell.org/package/aivika-branches-0.1 (DavidSorokin)
09:05:18 <xrisk> Hello, is Data.List.Split not to be found in a standard  install of Haskell?
09:05:31 <prooftechnique> It's part of split
09:05:34 <prooftechnique> @hackage split
09:05:34 <lambdabot> http://hackage.haskell.org/package/split
09:06:03 <xrisk> If I am right, then `cabal install split` will do the needful?
09:06:17 <prooftechnique> Yes, indeed
09:06:22 <xrisk> Thank you.
09:09:59 <ironChicken> tommd: oh yes, thanks. that's a bit neater
09:18:34 * hackagebot cgrep 6.6.1 - Command line tool  https://hackage.haskell.org/package/cgrep-6.6.1 (NicolaBonelli)
09:35:20 <quchen> Weird, building text makes my CPU significantly hotter than any other package.
09:35:51 <quchen> And by hot I mean "close to 97 °C" which is my hard shutdown temperature.
09:37:23 <nitrix> Aren't CPUs and kernels designed to avoid this very problem by adjusting the clock speed?
09:40:12 <quchen> nitrix: Lenovo does a good job counteracting that
09:40:40 <nitrix> Seems like an issue with you system. You're supposed to be able to keep the CPU at 100% for long periods; but of course, it damages the chip (through a process known as electromigration).
09:41:16 <quchen> 95
09:41:37 <quchen> Man, compiling stylish-haskell is brutal
09:42:11 <nitrix> quchen: At this point, I think you'd be doing any I/O and your system would fry. I doubt it's related to each package.
09:42:25 <hiptobecubic> quchen, yeah, my wife's t420 can overheat if you really push it. It's pretty annoying.
09:42:48 <quchen> I changed the thermal paste which bought me 5 °C at the time, not really useful
09:42:53 <quchen> Now I'm downclocking and everything
09:43:26 <quchen> I mean this laptop is far from new, but this is ridiculous. I can't work on GHC on this laptop for example, because the compilation kills my laptop (or me).
09:43:38 <nitrix> Could be dust in the radiator or like I said, a damaged chip if it's been at 100% too often.
09:43:49 <koala_man> awful
09:44:04 <quchen> Wooo I made it
09:44:08 <nitrix> That's why I recommend to people to get CPUs that are slightly better than their base need, otherwise it gets damaged and worsen over time.
09:44:10 <hiptobecubic> Yeah, I replaced her fan/heatsink entirely. It helped a bit, but I feel like it's just a matter of time.
09:44:15 <Welkin> koala_man: you sound like a failed superhero
09:44:20 <quchen> stylish-haskell installed. Noooow: ghc-mod.
09:44:20 <Ongy> is there a way to use the *installed* constraints in cabal config file? I have a package that has an optional dependencie which depends on a C libaray. I would like automatically use the optional library if it is installed, but not pull it in by installing dependencies, since it relies on a library that may not be present
09:44:29 <nitrix> quchen: Compile things with the laptop in the freezer! (seriously dont)
09:44:56 <hiptobecubic> being somewhere cool does make a huge difference though.
09:44:59 <kadoban> Welkin: https://en.wikipedia.org/wiki/The_Pumaman pumaman's slightly lamer sidekick
09:45:06 <koala_man> Welkin: my superpowers are eating leaves and sleeping 22 hours a day. maybe a failure for humanity but pretty sweet for me
09:45:08 <hiptobecubic> I like to work outside in the sun but sometimes it's just not feasible
09:45:25 <sm> quchen: what's the ambient temp there ?
09:45:36 <kadoban> 92 C
09:45:40 <quchen> sm: Room temperature
09:45:56 <quchen> 21-ish
09:47:05 <Welkin> 92 C? wtf?
09:47:57 <sm> that'd be challenging :)
09:53:30 <kadoban> :)
10:08:27 <geekosaur> give it a century...
10:23:49 <cheater> hello, i have noticed there's no generic linux x86 package for haskell platform 7.10.3. i assume this is a bug? i looked in here: https://haskell.org/platform/download/7.10.3/
10:26:23 <mjhoy> wow, "meet bob the monadic lover" is... not what i expected.
10:37:02 <cocreature> cheater: I don’t think anybody actually uses the haskell platform on linux. most people just install ghc and cabal and that’s it or these days a lot of people use stack (haskellstack.org)
10:37:57 <cheater> cocreature: your statement is just a guess
10:38:26 <cocreature> cheater: a guess based on talking to people, so I think it’s justified
10:38:51 <cheater> i disagree
10:38:59 <cocreature> fair enough
10:39:11 <cheater> either way, i use haskell platform, and on a 32 bit linux, and now it's not there anymore
10:39:53 <quchen> cheater: Using Stack will give you a pretty similar experience to using the Platform.
10:40:09 <quchen> cheater: Instead of "cabal install" you use "stack install", instead of "ghc" you use "stack ghc".
10:40:46 <CodeWeaver> Anybody know if thoughtpolice managed to do anything with a potential fix to this haskell parallel performance ticket? https://ghc.haskell.org/trac/ghc/ticket/7602  I've got a snippet of code which seems to perform more poorly than I'd expect in parallel under OSX, and I'm trying to ferret out if it's my own bug or not.
10:47:35 <Guest4829> wow I was about to ask a question, but while formulating the question found the answer
10:47:40 <Guest4829> oh
10:47:58 <mag___> the question was
10:48:48 <mag___> Why   import Data.Map (insert) as M    is a parse error?
10:49:05 --- mode: ChanServ set +o dcoutts
10:49:21 <mag___> but it seems that     import Data.Map as M (insert) is the way to go
10:49:22 <shapr> mag___: did you use qualified?
10:49:29 <shapr> oh, that works too
10:49:57 <mag___> Yes I did try using qualified
10:50:05 <thoughtpolice> CodeWeaver: I haven't gotten around to it, that's a really old bug of mine. There is an old patch sitting around that basically implements the idea, though. (I think my Mac died roughly at the time I was working on it sort of)
10:54:51 <ReinH> mag___: if you use as without qualified, you probably won't get what you want
10:55:15 <ReinH> import Data.Map as M (insert) means that insert and M.insert are both in scope
10:56:39 <mag___> Oh yes! I must use qualified
10:56:43 <marchelzo> hi
10:56:53 <vlad___> has anyone gotten "There are files missing in the XXX package." errors when doing a cabal install?
10:56:55 <CodeWeaver> thoughtpolice:  How hard would it be to re-implement?  Or... tell me how to re-implement?  Call it a point of pride, but it's kind of rankling me that one of the reasons I can't get reasonable threaded performance on OSX is a bug... for which there is already a lingering fix... on a multi-year-old-ticket. ;)
10:57:10 <thoughtpolice> https://github.com/thoughtpolice/ghc/commit/88f0a0b047ff67b40eeb4de940aca16271661564
10:57:14 <vlad___> cabal suggests I do ghc-pkg check, but that doesn't turn up anything
10:57:17 <marchelzo> if I need IO and State should I use StateT with IO, or should I just use IORefs instead?
10:57:21 <thoughtpolice> You'll have to do a little digging to make sure that OS X hasn't changed much
10:57:52 <vlad___> it says "Could not find module Text.Parse", but I can import Text.Parse just fine in ghci
10:57:55 <CodeWeaver> thoughtpolice:  That's  a place for me to start.  Excellent.  It's *probably* well out of my skillset, but I can always give it a shot.
10:57:59 <thoughtpolice> CodeWeaver: Because the 'fix' is a bit sneaky and involves stealing something from WebKit Core, because OSX is all annoying. That patch is the basic idea, though.
10:58:47 <CodeWeaver> thoughtpolice:  Yes, I read that bit in the original ticket.  Its unfortunate to have to resort to this kind of sneakiness, but.... the alternative is that we go to GHC 8, 9, 10... etc and suffer a really daft performance problem.
10:58:51 <thoughtpolice> CodeWeaver: It's not that bad, it just requires some digging. :) Feel free to ask me about it... I *should* be getting a new Mac in the next two weeks, but I've got a lot of other things to do, so it's down my TODO list pretty far. So feel free to take it over.
10:59:45 <CodeWeaver> thoughtpolice:  Well, let's stop short of saying I'm 'taking it over' until I can figure out if I'm even capable of getting my head wrapped around the necessary internals.  I've not mucked in GHC's internals before, and multithreading and thread local storage and OS hacks is the deep end.  With sharks.  And the sharks are on fire.
10:59:56 <CodeWeaver> thoughtpolice:  But I *will* take a look.
11:00:02 <mjhoy> marchelzo: i was actually just reading this, maybe it will help? https://wiki.haskell.org/Simple_StateT_use
11:00:06 <thoughtpolice> CodeWeaver: Right, so double check things like the WebKit core sources. Do some searching, make sure the right TLS key we want to steal isn't used. You uh, might also want to look into the Apple libc, XNU etc source too, to make sure things behave as expected.
11:00:16 <thoughtpolice> Or maybe they've all changed and OS X doesn't suck so bad here anymore, it's possible.
11:00:38 <marchelzo> mjhoy: thanks :)
11:00:41 <thoughtpolice> CodeWeaver: You don't need to go digging that far into GHC :) The issue in principle is very simple.
11:01:11 <CodeWeaver> thoughtpolice:  Well, as I said I had a snippet of really simle code filling an array in parallel, and the performance with 4 cores running gets me barely 2x improvement.  It's possible the bug's on my side,  of course, but I'd expect something a *little* closer to 4 on something embarrassingly parallel.
11:01:53 <thoughtpolice> Whenever GHC does <stuff>, it needs to call these functions called 'setGCT' and 'getGCT' (or whatever it is). These functions are very very performance critical, and they are local to the OS thread that is executing in the Haskell process.
11:02:23 <thoughtpolice> So, GHC's runtime calls these functions to swap out some thread-local pointers and stuff. The specifics aren't really important, except this function is very, very speed critical.
11:03:15 <thoughtpolice> So, that's really about it. So the task isn't so much "dive deep into GHC", it's, "how do I make Thread-Local Storage on OS X really fast?"
11:03:49 <CodeWeaver> thoughtpolice:  Okay, good to know.  But would the overhead in those calls depend on how often they're called?  Wouldn't one mitigation be context-switching less often?  (I'm not recommending this, just getting a handle on what it does)
11:03:50 <thoughtpolice> So it's more of an OS X question than anything! You don't have to worry about any of the super crazy stuff GHC does. All of this code is relatively isolated; my original patch from a few years ago was less than 100 lines for example.
11:05:37 <thoughtpolice> CodeWeaver: Yes, but they're called by the garbage collector. Which in turn is possibly called whenever GHC allocates any memory at all, which is very often.
11:06:15 <thoughtpolice> And GHC will often do a minor GC in order to free recently allocated, but dead, objects.
11:06:32 <CodeWeaver> thoughtpolice:  And no way to make *that* happen less often, I'm guessing.
11:07:22 <CodeWeaver> thoughtpolice:  Okay, the original ticket has some comments about whether to compile GHC with gcc proper or using clang.  Recommendations there?  Its one of the first things I'm guessing I'll have to do.
11:07:50 <thoughtpolice> I mean you can (by fiddling with heap sizes or whatever probably), but in general there's a lot going on there too, so you don't need to worry about it as much. Just about making this existing path fast. (GC is also when GHC might schedule some other thread to run too, so it affects parallel performance poorly.)
11:08:32 <thoughtpolice> CodeWeaver: On modern OS X you're generally looking at Clang, which comes with XCode. So, that.
11:09:33 <CodeWeaver> thoughtpolice:  Roger  -- I'll focus on poking at performance issues in those two functions then, for starters.  That's likely to lead to a few rabbit-holes.  Expect me to pop back in here again pretty soon. :)
11:09:33 <geekosaur> on anything since 10.7 clang is your only option. apple's "gcc" is actually clang (try gcc --version)
11:09:48 <thoughtpolice> CodeWeaver: The easiest thing to do first is make sure that Clang still generates the slow code, which you can do by getting the latest version and compiling it, building some small program with '-threaded', and disassemble some code paths in GHC.
11:09:53 <CodeWeaver> geekosaur: yes, but I could build an independent version of gcc if I cared.
11:09:55 <cocreature> lol they symlink gcc to clang?
11:10:01 <geekosaur> you can build your own gcc via macports or homebrew but even that runs into optiontial issues
11:10:03 <cocreature> I mean there is nothing wrong with using clang, but that is weird
11:10:06 <geekosaur> *potential
11:10:22 <thoughtpolice> CodeWeaver: It should have a code path like mentioned in my patch, 'callq  *(%rdi)' or something, which is an indirection that's very expensive.
11:10:34 <CodeWeaver> thoughtpolice:  Got it.  I will absolutely do that test first.
11:10:34 <geekosaur> cocreature, consider that the last gcc apple shipped was an old 4.2 that was missing many upstream patches
11:11:12 <cocreature> geekosaur: I can completely understand why they don’t ship gcc, I just think it’s weird to pretend that you do by symlinking it
11:11:13 <geekosaur> and they kep[t shipping that version even before switching to clang
11:11:23 <thoughtpolice> The RTS is written in C. So just look for where those functions are called that use __thread or whatever (poke around where my patch touches in the latest GHC). You can just use gdb/lldb to disassemble the symbol directly since it's not mangled or anything.
11:11:33 <geekosaur> it's because there's too many build systems out there that know that only gcc exists
11:11:56 <thoughtpolice> I seem to have commented all this up a while back: https://github.com/ghc/ghc/blob/master/rts/sm/GCTDecl.h
11:12:00 <andromeda-galaxy> Anyone have any idea why lhs2TeX thinks that A.B.C.D.E.F as a module name is A.B.C `compose D.E.F (or how to stop it?)
11:12:01 <geekosaur> (heck, I'm contributing to one of them. nobody fixes it because the makefile makes autoconf look sane)
11:12:39 <thoughtpolice> CodeWeaver: Anyway, #ghc is also the best channel for all this. More people will be able to help.
11:13:46 <CodeWeaver> thoughtpolice:  thanks!  will hold future discussions there.
11:19:59 <monochrom> w00t haskell weekly news!
11:21:52 <sm> \o/
11:23:39 * hackagebot process-streaming 0.9.0.0 - Streaming interface to system processes.  https://hackage.haskell.org/package/process-streaming-0.9.0.0 (DanielDiazCarrete)
11:23:59 <monochrom> haha, a markov chain posted on Hacker News "$690 for an hour minimum wage for state management in haskell"
11:29:14 <vlad___> has anyone run into "Could not find module" problems with cabal?
11:29:58 <vlad___> cabal seems to think Text.Parse, System.Time and System.Locale don't exist and that there are missing files in the corresponding packages (polyparse, old-time, old-locale)
11:30:20 <vlad___> however I can import these modules just fine in ghci
11:31:46 <puregreen> vlad___: maybe you're in a sandbox?
11:32:14 <kadoban> vlad___: What commands are you running that work, what commands are you running that don't, and what exact error messages do you get?
11:32:17 <vlad___> puregreen: nope, definitely not in a sandbox
11:32:36 <vlad___> kadoban: I'm trying to cabal-install some packages
11:32:44 <kadoban> vlad___: Also, 'stack' is much nicer than cabal. It's possible your package database is just messed up, which is pretty much a weekly occurence in cabal, more often if you're not using sandboxes.
11:32:52 <vlad___> kadoban: namely, cabal install cpphs fails 
11:34:30 <kadoban> vlad___: Try 'stack'? Seems like a good time to learn.
11:34:32 <vlad___> kadoban: the error message is: Language/Preprocessor/Cpphs/CppIfdef.hs:21:8: Could not find module ‘Text.Parse’ There are files missing in the ‘polyparse-1.11@7SVweJmgKeGRg8BA4JRfq’ package, try running 'ghc-pkg check'. Use -v to see a list of the files searched for.
11:35:08 <vlad___> kadoban: is cabal deprecated now?
11:35:22 <kadoban> vlad___: Sounds like an odd one, I'm not sure what that error is. It's not deprecated, but I would never recommend it to anyone.
11:35:36 <kadoban> Unless I … I dunno, don't like them very much or something.
11:36:21 <kadoban> vlad___: It's not a drop-in replacement though, you'll have to learn a couple of new things. It's pretty easy to get going though.
11:37:11 <cheater> @tell quchen thanks
11:37:12 <lambdabot> Consider it noted.
11:38:39 * hackagebot GPipe 2.1.7 - Typesafe functional GPU graphics programming  https://hackage.haskell.org/package/GPipe-2.1.7 (TobiasBexelius)
11:48:06 <mazur> betaceti
11:59:55 <bitemyapp> ReinH: programmer unwilling to critically evaluate learning resources, news at 11.
12:01:14 <ReinH> bitemyapp: I pm'd you
12:08:40 * hackagebot process-streaming 0.9.0.1 - Streaming interface to system processes.  https://hackage.haskell.org/package/process-streaming-0.9.0.1 (DanielDiazCarrete)
12:12:15 <nineonine> hi there
12:12:30 <mmachenry> Hi
12:12:31 <nineonine> im trying to compile program with profiling
12:12:36 <nineonine> however it says
12:12:44 <nineonine> Perhaps you haven't installed the profiling libraries for package ...
12:12:54 <nineonine> Could not find module
12:13:29 <nineonine> and it doesnt allow me to run the program with +RTS
12:14:32 <monochrom> for the first problem "Perhaps you haven't installed the profiling libraries for package", see my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#config . yes, it will be a lot of work and regret to fix a wrong default.
12:15:22 <nineonine> thanks !
12:16:11 <monochrom> the second problem is easy. at compile time, use the command line "ghc -rtsopts ..." to enable +RTS for your executable
12:17:01 <nineonine> yeah I use that flag
12:17:11 <monochrom> ok good
12:17:12 <nineonine> i guess problem 1 is in charge for that
12:27:06 <hypoon> Hi guys, I'm creating a scripting engine for a game. Basically, I want to be able to specify cause/effect relationships in a text file, and have that file read by the game engine. For simplicity, I figured I would define it all in terms of Haskell data constructors, so that I can simply derive (Read,Show) to implement writing the script file and reading it back (I do not intend for the script file to be wr
12:27:12 <hypoon> itten by hand).
12:28:36 <hypoon> The problem I'm running into is this: when I have a more complex effect of an action, the target of the effect may be determined at run-time. This means that there'll need to be evaluable expressions in the data types.
12:29:42 <hypoon> Right now it's looking like there's just going to be an "Evaluable" data type with hundreds of different constructors, each representing a type of expression that can be evaluated. Is there an obvious better way to do it?
12:30:06 --- mode: shapr set -o dcoutts
12:30:09 --- mode: shapr set -o johnw
12:30:11 --- mode: shapr set -o shapr
12:33:16 <hypoon> I've also considered having a simpler constructor, "data Evaluable = Evaluable String [Arg]", where I then have the engine pattern match the string against the hundreds of different kinds of expressions. That just doesn't seem much better.
12:40:59 <thimoteus> does lambdabot not support any kind of :info ?
12:43:42 <tsahyt> thimoteus: No, it usually creates way too much output to put into the channel
12:43:55 <dmj> thimoteus: it supports @src
12:44:24 <thimoteus> ahh, ok. i always use him in a PM session anyway
12:46:51 <gromak> Suppose I have a complex data type `S` and which has some container with `Int`s inside of it. It may be `[Int]`, `Vector Int`, `Set Int`, etc. I want to have some `Reader` computation which returns some abstract container of `Int`s. That is I don't want to expose underlying type of container. Of course I can just have `Reader S (Set Int)` (assuming that container type is actually `Set`), but I find it better to hide this detail. If we consider definition li
12:46:51 <gromak> ke `f :: Traversable t => Reader Stuff (t Int)`, it means I can return any Traversable of Int, whatever you want. But I want to say I will return something which Traversable of Ints, but I won't tell you which Traversable it is, because the only thing you need to know is that it's Traversable Int. Is something like that possible?
12:51:58 <wedify> what are reasons readFile will report a file as not existing when i can take the path given to me in the error message and open it?
12:52:12 <wedify> the files are readable by everyone
12:52:45 <dmj> wedify: are you using relative paths
12:52:52 <wedify> no absolute
12:53:04 <dmj> wedify: can you paste your code
12:53:07 <dmj> @where paste
12:53:08 <lambdabot> Haskell pastebin: http://lpaste.net/
12:57:02 <hypoon> wedify: Is the path explicit? No environment variables or '~'?
13:03:50 <hnl23> hey what's up? can anyone help me with this function? thanks http://lpaste.net/151181
13:05:45 <shachaf> The error message says to look at line 23.
13:06:06 <shachaf> But you didn't post the full code, so only you have that power.
13:07:04 <bergey> hnl23: On lines 8 & 9, you call intersect with a pair as its first argument, but intersect expects a list of pairs.
13:08:18 <wedify> dmj: ok in reducing down to a test case i figured it out. the function i use to make the absolute path was being called twice on a given input
13:09:17 <dmj> wedify: did the function you were calling happen to delete the file? 
13:09:17 <wedify> once in one place and then again in another and the error message for some reason didn't show this
13:09:36 <wedify> no, it's just readFile
13:11:29 <mvr_> any type family wizards around? I'd love to be able to do this: http://lpaste.net/151183 , but I'm not sure how to convince the typechecker that "ApplyDegree (ApplyDegree n dg) df" will be the same as "ApplyDegree n (DegreeSum df dg)"
13:12:55 <luigy> swaggin' dmj 
13:13:20 <dmj> luigy: straight swaggin'
13:13:27 <luigy> lol
13:13:39 <luigy> ready to stress out those fans?
13:14:02 <dmj> heh
13:14:14 <dmj> do I have a choice? :]
13:15:22 <hnl23> bergey thanks, that did it... it's a failed idea though, scrapping it and trying again :)
13:15:31 <dolio> mvr_: What happens if you have PlusOne or MinusOne twice? Those cases aren't handled in DegreeSum.
13:16:50 <dmj> luigy: did you use homebrew or macports, or both, heh
13:18:34 <mvr_> dolio: I guess I don't know what to do other than have those cases missing...
13:19:14 <luigy> strange mix of homebrew + nixpkgs
13:19:22 <luigy> dmj but I have a version for both
13:19:39 <luigy> I just want to hear a full success story of webkitgtk working on el capitan/yosemite
13:20:00 <luigy> going to dm you
13:21:15 <dmj> luigy: nice
13:22:06 <dolio> mvr_: Well, yeah. I don't think that bodes well, though.
13:22:10 <dmj> luigy: webkitgtk3 on nixOS was pretty snappy, nice to browse ghcjs-dom in ghci too
13:22:12 <mvr_> if there were type level integers, I could use those everywhere and it might have just worked
13:22:47 <dolio> It's somewhat unrelated to how you'd fix your issue, I think. Except that you won't be able to write the proof you need without covering those cases somehow.
13:22:57 <luigy> dmj nice! I should dual boot also
13:23:09 <luigy> I can't let my osx eyecandy go, though
13:23:29 <dmj> luigy: yea, but that gnome3 eye candy is pretty good too, I was impressed.
13:24:01 <mvr_> can I fake it by coercing somewhere?
13:24:02 <dmj> all the OSX buttons just "worked" too. volume, keyboard backlight, screen, etc. 
13:25:25 <mvr_> I figure it can't ever go wrong, because the presence of (DegreeSum df dg) means that combination has to actually exist
13:31:06 <nineonine> does anyone know how to include UNIX executables in gitignore ?
13:31:25 <dmj> echo executable >> .gitignore ?
13:31:45 <dmj> or if you magit it can do it for you if you hit 'i'
13:35:26 <puregreen> dmj: I guess nineonline means “all files without extension” or something
13:35:34 <puregreen> since executables usually don't have them
13:35:40 <puregreen> *nineonine
13:35:52 <nineonine> exaclty
13:36:09 <nineonine> all files without extension
13:36:42 <nineonine> basically all i want is to have .hs and .txt in repo
13:36:56 <monochrom> I don't know git, but it's possible it recognizes the reserved word "executable" for executable files
13:37:00 <nineonine> but avoid other compiling artefacts
13:37:50 <dmj> puregreen: ah
13:38:07 <hypoon> nineonine: I generally make a separate directory called "build" or "dist", then configure my compiling command to dump all the executables and object files into that directory.
13:38:12 <jackhill> nineonine: searching on gitignore and whitelist may find what you're looking for. e.g. http://stackoverflow.com/questions/15288712/gitignore-whitelist-on-directory-and-its-contents
13:38:23 <hypoon> nineonine: Then I just tell gitignore to ignore that one directory.
13:38:27 <jackhill> but this is soft of off topic for #haskell. Maybe move to #haskell-blah ?
13:39:00 <nineonine> sorry for off topic
13:39:06 <dmj> there is a #git
13:39:14 <nineonine> will it count if i add “haskell executable” ? :)
13:39:27 <monochrom> heh
13:39:39 <nineonine> anyways, thanks for help guys
13:40:01 <hypoon> nineonine, jackhill: To bring it back to topic, my .gitignore is pretty much the same for every cabal job I use, just three lines: "dist", ".cabal-sandbox", and "cabal.sandbox.config".
13:41:44 <nineonine> hypoon, thank you !
13:53:43 * hackagebot dresdner-verkehrsbetriebe 0.1.0 - Library and program for querying DVB (Dresdner Verkehrsbetriebe AG)  https://hackage.haskell.org/package/dresdner-verkehrsbetriebe-0.1.0 (meoblast001)
13:59:15 <OverCoder> Is there anyway I can prevent loading a file in ghci from wiping my variables?
13:59:37 <monochrom> no, I don't think there is one
13:59:49 <OverCoder> :<
14:00:11 <monochrom> I deal with this by writing a separate file for my variables.
14:00:45 <Cale> OverCoder: Just put them in your source instead
14:01:00 <OverCoder> hm
14:01:10 <OverCoder> okay :|
14:01:25 <Cale> I try not to define too much at the ghci prompt
14:01:34 <Cale> it's for testing out what expressions evaluate to
14:01:36 <monochrom> it scales better because after an hour of playing around, I find myself wanting to edit my variables' definitions
14:01:53 <Cale> Note that :r will quickly reload the file
14:02:25 <ReinH> "My definitions are ephemeral" "Ok, make them persistent instead." ":|"
14:02:35 <monochrom> in other words "let me just define one-off things in the repl" plays well for only the first half hour. even if they are not lost.
14:03:13 <OverCoder> Cale, keeping variables?
14:03:20 <OverCoder> Because I am just reloading my file, but with :l
14:03:41 <monochrom> in other words, if you have a project that will last for weeks, then a feature of "don't lose repl definitions" is useful for the first half hour of those many weeks only, i.e., useful only 0.000001% of the time
14:06:35 <monochrom> not to mention that there are a ton of other ways you have to lose your repl definitions
14:07:17 <Cale> Yeah, if you accidentally run something which eats up all your memory or whatever, it's easy to be in a position where you have to kill ghci
14:07:42 <monochrom> if you quit or restart the repl, you lose them. (if you say, "why not save it in a file across repl sessions", then you have re-invented files.)
14:07:49 <Cale> OverCoder: No, it'll discard all the definitions you have
14:08:25 <Cale> OverCoder: The answer is just to always put all your declarations into the source file -- if you're going to test the same stuff repeatedly, then make a definition for it.
14:08:40 <monochrom> if you change the modules you use, you have to lose the repl definitions. (ML's repls don't. it will confuse and mislead you. the unlost repl definitions still use the old modules, not the new ones.)
14:09:15 <Cale> In the old days, GHCi wouldn't even let you make declarations
14:09:38 <xrisk> Guys, what web framework do you use? 
14:10:02 <Cale> xrisk: At work, I've been using reflex-dom along with snap for the backend
14:10:24 <Cale> It's pretty nice :D
14:10:55 <Cale> reflex-dom is definitely the nicest library for constructing web frontends that I've ever used
14:11:11 <xrisk> Taking a look :)
14:11:18 <Cale> It's a little tricky to learn at first though, we don't have enough documentation yet
14:14:30 <monochrom> Here is my evolution of a typical toy project and tests. Suppose I am writing a Turing machine emulator. (In fact, I just did a few days ago.)
14:15:15 <monochrom> During the first hour, I put my emulator in a file, I type in test cases at the repl bare-hand.
14:15:45 <frerich> Cale: Ok, you triggered my curiosity but then I opened http://hackage.haskell.org/package/reflex-dom-0.2/docs/Reflex-Dom-Class.html and slowly, oh so slowly, closed the browser tab again. :-]
14:15:58 <monochrom> This is the only stage in which I would love to preserve my "one-off" repl stuff across reloads
14:16:34 <monochrom> After the first hour, I will not mind losing them, since I will want to change them anyway.
14:16:51 <xrisk> I'm actually quite new to Haskell, but I'm loving it.
14:17:19 <monochrom> "change" means editing. This implies moving my "one-off" repl stuff into a file, because that's how you use an editor.
14:17:49 <monochrom> (and since I will be editing them every once in a while in the rest of my life, they are not so "one-off" anymore, are they?)
14:18:08 <monochrom> So during the second hour, I put my tests in the same file I put my emulator.
14:18:53 <monochrom> And this too won't scale for long. By the third hour, I will find it necessary to put the "once upon a time was one-off, but now permanent fixture" test cases in a separate file.
14:20:50 <monochrom> programmers, all of people of the world, should be the ones most aware of the phenomenon that all "one-off prototypes" always end up lasting for decades.
14:21:34 <monochrom> (and sysadmins, the second most, since their shell scripts are like this too)
14:28:23 <prooftechnique> I’m pretty sure I have some old scripts that have been on production dirks
14:28:47 <prooftechnique> Systems for half my life
14:29:16 <prooftechnique> Premature enter and bad autocorrect. 
14:29:42 * prooftechnique sighs
14:30:05 <domgetter> for implementing (>>=) :: M a -> (a -> M b) -> M b, what are all the (a -> M b) called?  Functors?
14:31:31 <monochrom> you can call it a Kleisli arrow if you don't mind
14:32:02 <monochrom> but there are other options, more general than Kleisli arrow. you can say callback or continuation
14:32:23 <domgetter> So a Kleisli arrow is a function that takes something and returns something that is monadic?
14:32:31 <monochrom> yes
14:34:22 <dmj> is there a package for the various levels of uncurrying
14:34:29 <dmj> uncurry2-10, etc
14:42:50 <domgetter> Are all Kleisli arrows also functions?
14:43:11 <mtesseract> Hi
14:43:42 <prooftechnique> Hi
14:50:01 <OverCoder> I am debugging my applicaiton why I can't do something like this? http://p.samuraimanpurse.com/oWfIt6uL.txt
14:50:05 <OverCoder> Doesn't match return type
14:50:45 <monochrom> are you saying "insert (Unknown _) tree = show tree tree"?
14:51:14 <monochrom> in other words are you doing something like "sin 0.1 0.1"?
14:51:23 <OverCoder> I am pattern matching that function, also no, each on is in a newline
14:51:26 <OverCoder> and no
14:51:31 <OverCoder> I want to show tree, and then return it
14:51:42 <monochrom> that newline becomes an ordinary space in this context
14:51:50 <OverCoder> Ow, what can I do?
14:52:05 <monochrom> look for the module Debug.Trace
14:52:47 <OverCoder> No I mean, I could, but, why I can't put any lines before the returning value? (I mean, aside from that exact case)
14:53:13 <monochrom> I don't understand the question
14:53:27 <OverCoder> someFunc a b = 
14:53:38 <OverCoder> I want to print one of the variables, and then return a
14:53:41 <OverCoder> How can I do this?
14:53:46 * hackagebot gore-and-ash-async 0.1.0.0 - Core module for Gore&Ash engine that embeds async IO actions into game loop.  https://hackage.haskell.org/package/gore-and-ash-async-0.1.0.0 (NCrashed)
14:53:48 * hackagebot gore-and-ash-async 1.0.0.0 - Core module for Gore&Ash engine that embeds async IO actions into game loop.  https://hackage.haskell.org/package/gore-and-ash-async-1.0.0.0 (NCrashed)
14:53:49 <monochrom> that's the job of Debug.Trace
14:54:09 <OverCoder> hm okay
14:55:45 <geekosaur> OverCoder, if you are not working in IO then you cannot do IO directly. (Debug.Trace provides a limited backdoor for debugging purposes. But beware of it, as it is "hiding" its IO ad therefore can do things at surprising times, and potentially interrupt normal I/O which is sequenced.)
14:56:08 <geekosaur> Haskell deals in expressions, not do this; do that commands.
14:56:46 <geekosaur> "do" notation gives you a way to pretend that you are working with commands... but only if you are working in a monad such as IO. In this case, you can't use it anyway.
14:57:21 <OverCoder> geekosaur, ooh, show is IO?
14:57:24 <geekosaur> no
14:57:31 <geekosaur> Show produces a String
14:57:42 <OverCoder> ow, ow, omg
14:57:44 <OverCoder> How stupid of me
14:57:47 <geekosaur> which, if what you were trying to do worked at all, would beignored because ther's nothing to receive it
14:58:05 <OverCoder> gotcha, many thanks
14:58:07 <geekosaur> unless the caller of inser, which is expecting a Tree, somehow knows how to deal with a weird String+Tree
14:58:23 <monochrom> show is not IO. and that makes it even worse. because it makes "show tree tree" more like "sin 1 1". no amount of newlines can change this.
14:58:26 <OverCoder> Yeah I just gotcha, I misused show just because I used it in ghci
14:58:45 <puregreen> dmj: http://hackage.haskell.org/package/tuple-0.3.0.2/docs/Data-Tuple-Curry.html
14:59:12 <geekosaur> ghci will invoke "print" ("putStrLn . show") on isolated values, or execute IO actions
14:59:50 <geekosaur> in many ways it's more a desktop calculator than an actual Haskell program... just because something works in ghci does not guarantee a program will do the same thing
15:00:13 <OverCoder> yeah I see
15:03:49 <frerich> Hm, does anybody know another name for 'return' which starts with an u?
15:04:04 <monochrom> unit
15:04:08 <frerich> Aaah...
15:06:47 <hodapp> the quicker I learn to use R, the quicker I can start using HaskellR.
15:06:54 * hodapp repeats this to himself over and over and over again
15:25:00 <sbidin> Flycheck can't handle .hsc files, e.g. reports parse error on #poke. Anyone know how to handle this?
15:26:36 <o`connor> does anyone here develop with nix? I am running ghci with -i~/.nix-profile/lib/ghc-7.10.3/ and can't load any libraries
15:26:53 <o`connor> what do I need to set so that ghci finds my libraries?
15:27:03 <o`connor> I've tried -i -I -L
15:39:01 <geekosaur> dont use ~
15:39:15 <geekosaur> the shell has to expand it and it won't expand it there because it's not at the start of a "word"
15:39:24 <geekosaur> try using $HOME instead
15:40:55 <geekosaur> (and you can't just put a space before the ~ because -i means something different all by itself. sigh)
15:43:43 <anks> https://github.com/nh2/haskell-from-python is there a wake to buiild it with ghc-7.10.3, or what should i do to get rid of '/usr/bin/ld: cannot find -lHSrts-ghc7.10.3.so' error
15:45:47 <geekosaur> that flag isn't right even for 7.4.2
15:48:41 <anks> ^^
15:48:51 <geekosaur> something like
15:48:52 <geekosaur> GHC_RUNTIME_LINKER_FLAG=$(shell ghc --print-libdir)/rts/libHSrts-ghc*.so
15:49:17 <o`connor> geekosaur: ok, it is still searching for .hs and .lhs files, even though its a compiled module
15:49:36 <geekosaur> although to be honest you should not need that at all, since you are using ghc to link ti should include the runtime automatically
15:49:39 <anks> well, that's what I've found looking for running haskell code in python
15:49:44 <geekosaur> I wonder if 7.4.2 had a bug
15:51:26 <geekosaur> o`connor, what exactly is in ~/.nix-profile/lib/ghc-7.10.3/ ?
15:52:15 <geekosaur> @paste
15:52:15 <lambdabot> Haskell pastebin: http://lpaste.net/
15:52:29 <geekosaur> dont paste it directly into the channel, use the pastebin
15:53:19 <o`connor> k
15:55:38 <anks> geekosaur: thanks :)
15:56:00 <o`connor> geekosaur: lpaste is down for me: http://pastebin.com/7FvEQz3T
16:01:38 <xrisk> Is tagsoup the only option for parsing html?
16:03:34 <geekosaur> o`connor, ok, so it's a package database and not a simple library. you need to use -package-db ~/.nix-profile/lib/ghc-7.10.3/package.conf.d
16:05:07 <geekosaur> o`connor, that said, nix should have some way to "wrap" ghc so it uses that database. I don't really know nix so I couldn't tell you how to do it though
16:06:48 <o`connor> geekosaur: Do you have any ideas on why when I run ghc-pkg list on it, it only finds the default ghc packages?
16:07:06 <o`connor> how would I build a package db that included, say, regex-tdfa-1.2.1/
16:07:17 <geekosaur> that would be my last remark...
16:07:34 <geekosaur> nix should be setting this up for you. but I am not a nix user and couldn't tell you how to do it
16:08:01 <geekosaur> there's some nix-env or something liek that that will set GHC_PACKAGE_PATH etc. as necessary
16:08:21 <geekosaur> when you tell it which of possibly multiple ghc versions to configure
16:08:57 <prooftechnique> Yeah, it should be sourcing a setup script in your shell profile that should set up paths and such for you
16:09:10 <prooftechnique> It usually writes those lines for you
16:09:49 <o`connor> hmm, I like nix in theory, but so much of it is super fragile **bash magic** 
16:09:52 <o`connor> oh well
16:09:54 <o`connor> thank you!
16:10:51 * geekosaur doesn't find that nearly as annoying as the setup instructions were, tbh >.>
16:11:00 <prooftechnique> Hahaha
16:11:13 <geekosaur> pretty sure it's just a simple call once it's set up. nix-env ghc-7.10.3 or some such
16:20:28 <mtesseract> Hi. What does the 'proxy tag' in a type signature like e.g. "runReaderT :: proxy tag -> ReaderT tag r m a -> r -> m a" mean?
16:20:59 <mtesseract> (I mean, syntactically. I have the feeling that type variables may not contain whitespaces.)
16:21:29 <hpc> is that proxy lower-case or upper-case?
16:21:30 <Hijiri> proxy is one type variable, tag is another
16:21:33 <geekosaur> proxy and tag are both type variables. proxy has the kind (* -> *)
16:21:43 <geekosaur> if it is in fact lowercase that is
16:22:14 <geekosaur> it works the same as the "m a" at the end, where m hass kind (* -> *) and a has kind *
16:22:54 <mtesseract> Oh course, it's just as in "m a". Thank you.
16:23:06 <hpc> mtesseract: is proxy lower-case?
16:23:10 <mtesseract> yes
16:23:21 <hpc> it's a fairly different answer when it's upper-case ;)
16:23:27 <geekosaur> yep
16:23:30 <hpc> but yeah, what geekosaur says
16:24:07 <mtesseract> I'm trying to become familiar with the ether package. But it's not very well documented it seems.
16:25:29 <geekosaur> http://hackage.haskell.org/package/ether-0.3.1.1/docs/Control-Monad-Ether-Reader.html#v:runReaderT indeed
16:26:55 <mtesseract> Basically using trial and error I know -- thanks to the type checker -- what I can put as 'proxy tag'. But I would like to understand how to deduce this myself.
16:27:20 <geekosaur> https://int-index.github.io/ether/
16:27:33 <geekosaur> looks like the real documentation, including links to further reading, is there
16:27:57 <geekosaur> would be nice if the package entry had more than just the homepage link to that...
16:28:07 <geekosaur> readme files aren't that expensive >.>
16:28:43 <mtesseract> I know that page. Maybe I am just being to slow here. I understand that I can use this haskell-templateish ethereal function to generate these 'proxy tags' for me.
16:29:24 * hackagebot MonadCompose 0.8.4.2 - Methods for composing monads.  https://hackage.haskell.org/package/MonadCompose-0.8.4.2 (JamesCandy)
16:29:50 <Hijiri> you can use absolutely any type constructor that's applied with "tag" as the last parameter, given the type signature
16:30:08 <mtesseract> But I don't understand the details of ethereal and what exactly, type-wise, functions like runReaderT expect me to provide.
16:30:14 <Hijiri> for example, [tag] would fit proxy tag
16:30:16 <Hijiri> since it's [] tag
16:30:32 <mtesseract> Because there are no constraints on 'proxy' I suppose.
16:30:40 <Hijiri> it's just a way to tell the type inferer/checker which "tag" you want
16:30:55 <geekosaur> yes. so ti hows you a manual way (using the standard Proxy type), or it presumably builds its own tags using TH which may or may not be based on Proxy. and the type of runReaderT is the same as the standard mtl runReaderT except with the proxy tag in front, which lets you specify *which* ReaderT
16:31:25 <geekosaur> becuase with mtl, you only get to put one into a stack (directly; you can manually "lift: to get to another one, but then you need to keep track of how deep it is yourself)
16:32:11 <geekosaur> as for proxy (or Proxy) itself, it's a "phantom type", one that is there just to distinguish something to the typechecker without actually affecting any values
16:33:13 <geekosaur> data Foo a = Int -- this has a phantom type. Foo Int and Foo Char both have Int-s in them but the typechecker won't let you mix them.
16:34:12 <mtesseract> Why doesn't the signature of runReaderT use "Proxy tag" instead of "proxy tag"?
16:34:12 <geekosaur> (if NASA had used something like this instead of Java, they could have caught at compile time the inches vs. millimeters thing that caused them to crash a Mars probe)
16:35:05 <Welkin> geekosaur: I thought they used C
16:35:08 <Hijiri> mtesseract: I think one of the reasons might be you could match on the constructor of Proxy tag
16:35:23 <Hijiri> but without that you could still do seq I guess
16:35:39 <Welkin> and they have very strict rules about it, such as no dynamic memory allocation, among other things
16:35:53 <geekosaur> it's using TH to generate the definition. IIRC at least some versions of ghc will expand a TH-generated (Proxy foo) to a *distinct* "Proxy"
16:36:16 <geekosaur> (if you use "ethereal" that is)
16:36:48 <mtesseract> I think my problem boils down to the following. Using the notes on https://int-index.github.io/ether/, writing ``ethereal "Foo" "foo"'', why can I not provide ``foo'' as first argument to runReaderT? After all, it should be of type "Proxy Foo".
16:36:55 <mtesseract> But provoding "Proxy Foo" as first argument works.
16:37:25 <mtesseract> (thanks for your helpful explanations)
16:37:45 <monochrom> @type runReaderT
16:37:47 <lambdabot> ReaderT r m a -> r -> m a
16:37:56 <geekosaur> monochrom, this is from the "ether" package
16:38:03 <geekosaur> it's tagged version of the mtl stuff
16:38:08 <monochrom> I see
16:38:17 <geekosaur> so you can for example have multiple distinct ReaderT-s in a stack and access all of them
16:38:54 <mtesseract> ah
16:39:01 <mtesseract> maybe I did a mistake
16:39:32 <mtesseract> (actually I was talking about ReaderT, not about runReaderT. Maybe this explains my confusion between foo and Foo)
16:43:32 <mtesseract> Yeah, that was the problem
16:43:36 <mtesseract> Thanks. :-)
16:43:53 <mtesseract> and good night
16:47:20 <dedgrant> Hmm puzzle for folks more clever than I: is there any way in haskell (ghc-7.10) to define or otherwise emulate type checking guarantees for a tuple type whose elements are explicitly-kinded? (i.e. some resulting kind (k,l,...) instead of *)
16:48:51 <dedgrant> New perspectives welcome.
16:51:36 <cir0x> Hey! Is it possible to write this line http://hastebin.com/ijabuqubac.coffee cleaner? I'd like something like this fibonacci n > 1 = fibonacci(n -1) + fibonacci(n-2)
16:53:09 <monochrom> this is the cleanest possible
16:54:23 <geekosaur> well, there was NPlusKPatterns...
16:56:40 <cir0x> monochrom: meh
16:57:46 <enthropy> dedgrant: can you phrase it instead as "this type/value is currently allowed but I would like it to be a compile time error"?
17:04:42 <dedgrant> enthropy: Sure let me try. Given appropriate GHC pragmas: data Label = L1 | L2 and type family F (l :: Label) :: * ; F 'L1 = ("Symbol", Int) --- I would like to match a type on the RHS that constrains "Symbol" :: Symbol and Int :: *. Specifically, an example for your phrasing, this type family permits F 'L2 = (1,2,3,4,5) (a completely nonsense example) which also satisfies *.
17:06:50 <dedgrant> My initial thought is to create a family for each element of the tuple on the RHS
17:06:50 <monochrom> dedgrant: unfortunately, tuple type (,) has kind * -> * -> *, so you can't use it as though it were Symbol -> * -> *
17:06:57 <dedgrant> Right
17:07:21 <monochrom> but can you define your own type to have that kind? I think yes.
17:07:31 <dedgrant> monochrom: I am curious about this
17:07:47 <monochrom> and can you define your own kind-polymorphic tuple type? I think yes too, turn on PolyKinds to see.
17:08:42 <enthropy> :k '(,)
17:08:44 <lambdabot> k -> k1 -> (,) k k1
17:08:52 <enthropy> :k (,)
17:08:53 <lambdabot> * -> * -> *
17:09:28 <dedgrant> monochrom: Hmm is kind polymorphism necessary and sufficient to satisfy such a kind in the RHS, that permits only the desired type inhabitants?
17:09:50 <monochrom> I don't know
17:09:55 <dedgrant> me either :)
17:10:26 <enthropy> dedgrant: type family F (l :: Label ) where F L1 = '("Symbol", Int) -- should disallow the (1,2,3,4) case being added on later
17:10:52 <dedgrant> enthropy: oh I see. is the ticked '() important?
17:12:18 <enthropy> Yep it's important. It's exactly the same thing you did with the ' to use the data constructor L1 as a type (but I left it off because ghc lets you leave it off to confuse people)
17:12:31 <monochrom> :)
17:13:05 <monochrom> for maximum confusion, "data T = T" so you have kind T, type T, type T, and value T
17:13:17 <dedgrant> enthropy: Absolutely brilliant thank you! I was working with unticked (), which of course resolved to *
17:13:34 <monochrom> no, that's only second maximum confusion. for maximum confusion, add "module T where"
17:13:45 <dedgrant> heh
17:13:53 <enthropy> T.T
17:13:57 <monochrom> hehe
17:14:10 <dedgrant> 'T' is also the first letter of 'Tears'
17:14:29 <monochrom> isn't Haskell exciting!
17:17:25 <dedgrant> It is interesting.. so I guess '() must be axactly the name for the promoted tuple constructor, rather than () which is an automatically promoted data constructor?
17:17:50 <dedgrant> pardon my poor sentence formation
17:25:57 <eacameron> I'm using GHCJS-DOM which lifts everything to MonadIO but also throws exceptions, what's the best way to catch in MonadIO?
17:26:11 <eacameron> Can I use exception-transformers somehow?
17:26:40 <mgsloan> eacameron: https://hackage.haskell.org/package/lifted-base-0.2.3.6/docs/Control-Exception-Lifted.html
17:27:00 <eacameron> I wondered if I needed to go there. Is that customary even in GHCJS?
17:27:21 <mgsloan> Yeah, I'd say so
17:27:34 * mgsloan doesn't really like MonadBaseControl, but it does get the job done
17:28:28 <eacameron> I'm actually trying to hook something into Reflex-DOM. I'm scared that MonadBaseControl will not play nice. It needs to end up as MonadWidget m a
17:28:35 <eacameron> Sorry, MonadHost m a
17:29:14 * eacameron thinks Haskell has the best story for exceptions...and yet can never figure out how to work with them :/
17:31:00 <mgsloan> What's MonadHost?
17:33:07 <eacameron> Honestly? I haven't a clue. You can but MonadIO unifies with it... ;)
17:33:24 <eacameron> s/You can/
17:35:07 <mgsloan> I'm not turning up anything in searches on github or google.  Is it defined in your code?
17:35:24 <Hijiri> isn't it from reflex?
17:35:42 <Hijiri> maybe that was MonadReflexHost
17:35:54 <mgsloan> Yeah, it sounds familiar, but it's not showing up in github searches of the reflex repos
17:36:45 <eacameron> My bad, I led you astray. It's WidgetHost
17:36:46 <eacameron> https://github.com/ryantrinkle/reflex-dom/blob/develop/src/Reflex/Dom/Class.hs#L39
17:39:01 <mgsloan> Alright, so, this is probably the concrete type you're using:  https://github.com/ryantrinkle/reflex-dom/blob/8c28c8744020a3e2a0a7c256039cef926ad326fb/src/Reflex/Dom/Internal.hs#L41  there's no reason this couldn't have a MonadBaseControl instance, and really it probably should
17:39:55 <mgsloan> Looks like it does have an instance of MonadException, though, so you can use this stuff: https://hackage.haskell.org/package/control-monad-exception-0.11.2/docs/Control-Monad-Exception-IO.html
17:46:46 <Strukks> Why does this give an error? http://lpaste.net/151191
17:48:05 <Strukks> How am I supposed to check if a list is empty?
17:49:04 <ThatTreeOverTher> https://wiki.haskell.org/How_to_work_on_lists#Testing_various_conditions
17:49:33 <Strukks> That's exactly my code
17:49:35 <Strukks> and it doesn't work
17:49:53 <eacameron> mgsloan: Awesome! Thanks for the help!
17:52:16 <mgsloan> Welcome!
17:52:39 <mgsloan> I can understand why Ryan would want to avoid MonadBaseControl.  It's a pain to work with, but it is nice to use along with utilities others have written
17:54:36 <xrisk> Guys, in this snippet, how would I write the guard? http://ix.io/o0q
17:58:27 <geekosaur> Strukks, regardless of error, null (x : xs) is always False
17:58:53 <pavonia> xrisk: What does "is an int" mean here? What's the type of l?
17:59:16 <xrisk> pavonia: r has type `Maybe Int`
17:59:20 <Strukks> geekosaur, I went on to use just "xs" instead and use "head xs" to get the first element
17:59:22 <xrisk> l is [Char]
17:59:55 <Strukks> geekosaur, but how would you check if a list represented as (x : xs) is empty? or it can't be empty?
18:00:05 <geekosaur> [] does not match (x : xs)
18:00:09 <geekosaur> [] matches []
18:00:16 <pavonia> xrisk: Are you looking for what constructor is used for r?
18:00:43 <geekosaur> by definition if you have (something : something) then the list is not empty
18:01:21 <geekosaur> (specifically by the definition of lists)
18:01:25 <ThatTreeOverTher> oh, you're trying to write left hand side statements
18:01:42 <Strukks> geekosaur, that makes sense, thanks!
18:02:40 <geekosaur> data List a = [] | (a : List a) -- if it has a : then it is not empty
18:09:25 <xrisk> pavonia: http://ix.io/o0t
18:10:02 <geekosaur> :t readMay
18:10:04 <lambdabot> Not in scope: ‘readMay’
18:10:17 <geekosaur> :t Text.Read.readMay
18:10:18 <lambdabot> Not in scope: ‘Text.Read.readMay’
18:10:23 <geekosaur> ergh
18:10:45 <pavonia> xrisk: You could use "case x of ..." or fromMaybe
18:10:50 <geekosaur> :t Text.Read.readMaybe
18:10:52 <lambdabot> Read a => String -> Maybe a
18:11:32 <geekosaur> then fromMaybe to produce a result depending on whether readMaybe :: String -> Maybe Int gave you Nothing or Just int
18:13:12 <pavonia> geekosaur: Isn't readMaybe the opposite direction?
18:13:44 <geekosaur> oh, different paste
18:13:52 <geekosaur> then just fromMaybe
18:15:17 <xrisk> oh I figured it out , I can use /= Nothing
18:15:28 <jle`> wait don't use /= Nothing
18:15:35 <jle`> pattern match
18:15:41 <geekosaur> is there some problem with fromMaybe?
18:16:03 <xrisk> no, but is fromMaybe to be preferred?
18:16:33 <geekosaur> depends, it will be lazier than a pattern match so it depends onwhether you need this to be lazy or strict
18:16:50 <geekosaur> but /= Nothing is just the wrong way to do it, regardless
18:17:21 <geekosaur> I mean, it will work but it does it the slowest way and I think reasoning about strictness gets harder?
18:17:37 <xrisk> ok
18:17:45 <geekosaur> and if you want to generlize it later, you now have a required Eq constraint that neither fromMaybe nor pattern matching has
18:18:18 <jle`>  /= Nothing is like /= []
18:18:30 <jle`> and yeah, it requires a Eq constraint
18:19:02 <jle`>  there isn't a reason to use /= Nothing or /= [] when you can pattern match :)
18:19:30 <jle`> there's also isNothing and null, when you need a higher-order-function, but doesn't require an Eq constraint on the thing inside
18:19:39 <jle`> s/need/are using
18:25:26 <Strukks> I need to write a function that takes the first element of each line until you enter an empty line and then prints the entire thing out, I got it working, but it's supposed to match a specific type ":: IO String" how do I make it match that? Am I very far off?
18:25:52 <Strukks> http://lpaste.net/151193
18:26:07 <xrisk> Very good, I figured it out, thank you.
18:27:32 <Shockk> Strukks: what do you mean by supposed to match? do you get a compiler error?
18:28:07 <Strukks> Shockk, it works without the "ristsona :: IO String" part, but it's supposed to match that, and if I add it I get an error
18:28:36 <xrisk> Oh, this source is quite illuminating: http://hackage.haskell.org/package/base-4.8.2.0/docs/src/Data.Maybe.html#isJust
18:28:51 <xrisk> I never realised I could pattern match against `Nothing`
18:28:51 <xrisk> Hah
18:29:02 <pavonia> Strukks: Do you have to print your string or return it from that function?
18:29:11 <geekosaur> that's kinda the point of data constructors ad pattern matching
18:29:15 <Shockk> Strukks: I guess the question I'd ask would be, are you actually wanting to return the string from ristsona?
18:29:24 <xrisk> Yes, it just didn't occur to me :)
18:29:44 <Strukks> pavonis: now that you mention it, it does say return
18:29:53 <jle`> Strukks: what is the type of ristsona now?
18:30:05 <Shockk> because right now you're doing one of two paths: putStrLn which has the type IO (), or sonad ... , which by type inference would also have the type IO ()
18:30:32 <Shockk> and that conflicts if you're giving it an explicit type signature of IO String
18:30:35 <Strukks> changing "putStrLn x" to "return x" seems to have fixed it
18:30:54 <jle`> you can also putStrLn x >> return x, or putStrLn x; return x
18:30:57 <jle`> if you still want to print it
18:31:19 <Strukks> it does still print it, even with just return
18:31:25 <Strukks> at least in ghci
18:31:40 <Shockk> ghci prints the result of expressions that you ask it to evaluate
18:31:43 <Strukks> but yeah, the task was to return it, good catch by pavonia
18:32:52 <Shockk> somewhat related, I was just thinking there, it'd be pretty nice to have some monads that are subsets of IO, for example one that would only allow read operations and not allow stuff like putStrLn
18:33:56 <Shockk> or I don't know, in my head I was imagining something like ristsona :: RestrictedIO '[Get] String
18:35:34 <geekosaur> Strukks: you can turn off the autoprint in ghci with :set -fno-print-bind-result
18:35:42 <geekosaur> then you see things as they work in a program
18:35:56 <geekosaur> (you have to explicitly print it yourself)
18:36:32 <Strukks> geekosaur: I'll keep that in mind, but currently I think it's easier to keep it as is for doing exercises 
18:36:59 <geekosaur> sure, but if you;re getting confused about whether something prints or not then that can be helpful
18:37:09 <geekosaur> (and to undo it, :set -fprint-bind-result)
18:37:30 <haskell399> Hello, I have a monad inside a monad (differents types), is there any trick to not have to bind two times? My issues is in the network function http://lpaste.net/151194
18:39:15 <Shockk> haskell399: do you mean to not do liftIO twice? or something else?
18:40:34 <Shockk> if that's what you mean, you could do this for only one liftIO:
18:40:53 <geekosaur> there's a comment before the code sugesting they want it to somehow be in two monads at the same time
18:41:11 <Shockk> oh I completely missed that
18:42:17 <haskell399> I wouldn't mind other feedbacks if you want lol
18:42:41 <Shockk> I was just going to say, regarding liftIO, y ou could replace that with:  liftIO $ do
18:42:55 <Shockk>   n <- compile $ do ... etc
18:42:57 <Shockk>   actuate n
18:43:34 <haskell399> nice thx
18:47:05 <ThatTreeOverTher> I'm getting the error "cannot satisfy -package-id directory-1.2.5.0-53ba6...", how can I fix this
18:47:17 <ThatTreeOverTher> I've run ghc-pkg recache
18:47:20 <Shockk> by chance is there a library like blaze-html and blaze-json, for CSS combinators?
18:48:52 <Shockk> I just found Clay which looks like it might do what I want
19:08:38 <ThatTreeOverTher> even after recaching, I still can't satisfy the -package-id. what can I do to fix this?
19:09:53 <hellertime> I'm getting the following out of http-client-tls: *** Exception: TlsExceptionHostPort (HandshakeFailed (Error_Misc "unimplemented RSA signature hash type: HashSHA384"))
19:10:37 <hellertime> definitely not what I was expecting to get as a response!
19:12:42 <nitrix> data Pair a = MkPair a a
19:12:43 <nitrix> fmap f (MkPair a b) = MkPair (f a) (f a)
19:12:51 <nitrix> Is that a valid functor instance for this type?
19:13:26 <nitrix> It feels wrong - and by wrong I mean, it feels really close to a Bifunctor.
19:15:14 <monochrom> no, the 2-tuple (,) is a bifunctor. Pair is still a functor, and also not a bifunction
19:15:28 <monochrom> err, s/ion/or/
19:15:48 <monochrom> to see this, Pair doesn't even have two type parameters
19:16:31 <nitrix> Right, it has a kind of :: * -> *
19:17:29 <nitrix> So this is the only logical functor for that type?
19:17:44 <nitrix> Hey, I'm not doing too badly then :]
19:18:07 <monochrom> yes, you've written a correct fmap
19:18:26 <monochrom> no, you have a typo, but you know how to fix it
19:18:53 <monochrom> it is why name clashes are evil
19:18:54 <mgsloan> Yeah, you could even do "data Pair a = MkPair a a deriving (Functor)" with the DeriveFunctor language extension
19:19:56 <jle`> nitrix: you can think of Pair as a list that always has two items
19:20:01 <jle`> nitrix: so the functor instance would be the same
19:20:29 <bramantio> hello all
19:20:29 <jle`> nitrix: if you want to fmap a function over a vector of Int's, the result will be the vector with the function applied to all the items :)
19:20:33 <jle`> you basically have a 2-vector here
19:20:35 <jle`> bramantio: hi!
19:21:34 <nitrix> jle`: I just didn't know it was an implication of the kind-level.
19:21:52 <nitrix> I thought it was totally arbitrary by the person implementing the instance.
19:21:56 <nitrix> It's fascinating somehow.
19:22:05 <EvanR> theres functor laws
19:22:16 <nitrix> Right. I know and understand both mind you.
19:22:34 <EvanR> but for  Pair a theres like no other possible implementation anyway
19:22:46 <EvanR> cuz parametricity
19:22:57 <nitrix> What's fascinating is the causality. It's like learning vs. understanding.
19:23:57 <EvanR> soon all we will have to do is write laws and the one true program will be automatically written!
19:24:47 <jle`> EvanR: there's another way to write it
19:24:54 <jle`> that's not lawful
19:25:05 <EvanR> oh swap
19:25:07 <jle`> fmap f (MkPair x y) = MkPair (f x) (f x)
19:25:13 <jle`> etc. :)
19:25:24 <EvanR> duh
19:25:37 <EvanR> i was thinking (,) acually
19:26:00 <EvanR> (e,)
19:28:11 <nitrix> 22:17:36           nitrix | fmap f (MkPair a b) = MkPair (f a) (f a) 
19:28:17 <nitrix> jle`: What's the difference o.o
19:28:35 <jle`> oh haha
19:28:39 <jle`> i didn't even see the typo
19:28:52 <nitrix> jle`: It's not lawful D: ?
19:29:06 <bramantio> i am a new user in a haskell greetings all
19:29:11 <jle`> that's what happens when you mix up type variables and value variables
19:29:14 <nitrix> Aww. And I thought I was doing so good.
19:29:16 <jle`> or at least, for me
19:29:26 <jle`> nitrix: read over my description of fmap for a vector
19:29:27 <jle`> or a list
19:29:45 <jle`> it applies the function to every item in the vector/list
19:29:54 <nitrix> bramantio: Welcome. Try not to feel too intimated by the discussions in here and feel free to ask any questions you may have.
19:29:58 <jle`> and returns a vector/list of the results
19:30:04 <jle`> bramantio: welcome :D
19:30:33 <jle`> nitrix: your instance fails the only functor law you need to verify, fmap id x = x
19:30:59 <nitrix> Because (2,3) will become (2,2) ?
19:30:59 <jle`> fmap id (MkPair x y) = MkPair (id x) (id x) = MkPair x x, so that's not MkPair x y, so, it fails it :'(
19:31:12 <jle`> yeah, found a counterexample
19:31:17 <jle`> but you can also just prove it using equational reasoning too
19:31:51 <nitrix> I might have mixed type variables with values :/
19:31:56 <jle`> mhm
19:32:02 <jle`> that's why i don't i use a and b for values, heh
19:32:04 <nitrix> I mean, GHC was even showing `a :: a`.
19:32:12 <EvanR> hah
19:32:22 <EvanR> :t a
19:32:24 <lambdabot> Expr
19:34:23 <nitrix> Fixed it with  MkPair (f x) (f y).
19:34:36 <nitrix> I could've sworn that didn't work the first time.
19:34:41 <acertain> instance Applicative Pair where {pure a = MkPair a a; MkPair f g <*> MkPair a b = MkPair (f a) (g b)} too
19:35:01 <jle`> now the fun part -- write a Monad instance :)
19:35:30 <jle`> join . join = join . fmap join should be your guide for that one
19:35:42 <nitrix> I'll use typed holes at that point I think ahah.
19:35:43 <jle`> there are a lot of implementations that typecheck, but that test should kill the non-typechecking ones
19:35:50 <jle`> er, the typechecking-but-not-real-monads one
19:36:12 <jle`> yeah, the typed holes will help, but (>>=) has a lot of implementaitons that will typecheck and not be correct.  so, good luck :D
19:36:20 <nitrix> newtype Tuple a b = MkTuple (a, b)
19:36:22 <nitrix> fmap f (MkTuple (x, y)) = MkTuple (x, f y)
19:36:26 <nitrix> Does that one seems good?
19:36:43 <jle`> prove the first law :)
19:36:48 <jle`> (the only law you need to prove)
19:36:56 <jle`> fmap id (MkTuple (x, y)) = ????
19:37:23 <jle`> functor laws for ADT's and plain functions are pretty straightforward/therapeutic to prove :)
19:37:37 <acertain> the functor law is free, right?
19:37:40 <jle`> and you don't even need to prove fmap f . fmap g = fmap (f . g), because fmap id x = x implies it
19:37:57 <nitrix> I'd get MkTuple (x, id y).
19:37:59 <nitrix> Which seems to work.
19:38:00 <jle`> acertain: fmap id x = x is not free, but if it's true, then fmap f . fmap g = fmap (f . g) is free from there
19:38:04 <jle`> nitrix: go on, one more step
19:38:15 <jle`> and you have a full proof
19:38:19 <nitrix> MkTuple (x, y)
19:38:24 <jle`> hooray :D
19:38:34 <EvanR> can Pair even be a monad
19:39:07 <dolio> Yes.
19:39:59 <jle`> hooray :D
19:40:11 <jle`> oh sorry, ent twice
19:40:20 <jle`> *sent
19:40:30 <jle`> Pair can be a Monad, and finding the monad is actually kinda fun
19:41:37 <EvanR> join (Pair (Pair x y) (Pair z w)) = Pair 
19:41:39 <EvanR> ...
19:41:54 <dolio> That's a start. :)
19:42:57 <EvanR> Pair x z ?
19:43:02 <nitrix> Ahah
19:43:10 <nitrix> I was wondering that. Are they going to swap?
19:43:16 <acertain> the unit law (x >>= return == x) decides it afaict
19:43:22 <EvanR> x=y, z=w
19:45:56 <EvanR> cojoin (Pair x y) = Pair (Pair x x) (Pair y y) -- the comonad "grows a pair" ;)
19:47:23 <EvanR> er does extract (Pair x _) = x even satisfy the laws :(
19:49:05 <EvanR> extract . duplicate      = id
19:49:24 <EvanR> extract . duplicate $ (1,2) = (1,1) so no
19:49:32 <EvanR> nvm
19:49:43 <dolio> You should check your monad, too.
19:51:27 <ThatTreeOverTher> ha, apparently not telling cabal which version of directory to install will install an old version
19:51:38 <julianleviston> dolio: that could be a cool t-shirt “check your monad”
19:52:27 <nitrix> julianleviston: http://rlv.zcache.ca/monad_shirt_tshirt-r740d2e3dd2454ef8ad9ffef9bf77216b_804gs_324.jpg
19:52:49 <julianleviston> lol
19:53:06 <EvanR> looking for monad law sin terms of join
19:53:08 <ThatTreeOverTher> oh hey you can buy this
19:53:37 <nitrix> I suspect there's an equivalent of rule 34 for t-shirts.
19:53:37 <EvanR> that shirt is extra obnoxious
19:54:06 <ThatTreeOverTher> it makes me uncomfortable how large the word "monoid" is
19:54:20 <ThatTreeOverTher> and the all-caps too, I think that's why it's obnoxious
19:54:33 <EvanR> isnt that how we talk in here? just write a MONOID instance
19:54:40 <nitrix> The "What about it" I hate.
19:54:54 <EvanR> what's the big deal lol
19:55:08 <ThatTreeOverTher> that totally does not sound like #haskell haha
19:55:14 <nitrix> I, personally, find it portraits the wrong message.
19:55:38 <dolio> The Enter the Monad shirts from ICFP are the superior monad shirt.
19:55:47 <EvanR> type theorist 1
19:55:49 <EvanR> type theorist 2
19:56:14 <EvanR> I'm with ST
19:57:48 <ThatTreeOverTher> http://haskell.spreadshirt.com/ there are jokes on some of these I don't get
19:58:51 <dolio> These are all pretty bad.
19:59:17 <julianleviston> is n + k because haskell used to have + k arguments?
19:59:30 <julianleviston> so the implecation is “I’m so oldschool, coz I used to use Haskell when this was the case"?
19:59:33 <julianleviston> or am I just misreading?
19:59:50 <dolio> It's clearly an n+k pattern reference.
19:59:56 <dolio> I don't know why.
20:00:01 <ThatTreeOverTher> the only thing worse than a bad haskell t-shirt is a bad hipster haskell t-shirt
20:00:06 <julianleviston> lol
20:00:15 <julianleviston> I just wonder if anyone actually wears them
20:01:01 <ThatTreeOverTher> I'd buy a shirt that read "It's a monoid in the category of endofunctors."
20:01:38 <ThatTreeOverTher> I don't think I'd wear it very often, but isn't it theorized that you wear 20% of your clothes 80% of the time anywy?
20:01:47 <julianleviston> lol 
20:01:53 <jle`> EvanR: i posted it earlier
20:02:03 <jle`> EvanR: join . join = join . fmap join
20:02:08 <julianleviston> ThatTreeOverTher: Pareto princle?
20:02:17 <jle`> that's what guided me through it the first time i tried to implement it
20:02:41 <geekosaur> Yoneda lemma
20:02:43 <jle`> thinking through what that implies kills a lot of bad implementations
20:02:55 <ThatTreeOverTher> julianleviston, I guess so! Didn't know this was a generalized rule
20:03:50 <EvanR> ThatTreeOverTher: i only have 1 outfit
20:04:14 <ThatTreeOverTher> EvanR, nice to meet you Mark Zuckerberg
20:04:19 <EvanR> lo
20:10:26 <EvanR> (((1,2),(3,4)), ((9,10),(11,12))) -> ((1,3),(9,11)) -> (1,9)  using my join twice
20:10:57 <EvanR> er, thats fmap joining first
20:11:02 <EvanR> join twice is
20:11:16 <nitrix> newtype MyFunction r a = MkMyFunction (r -> a)
20:11:17 <nitrix> fmap f (MkMyFunction g) = MkMyFunction $ \x -> f $ g x
20:11:28 <acertain> Pair a b >>= f = Pair x y where Pair x _ = f a; Pair _ y = f b
20:11:30 <EvanR> ((1,2), (9,10)) -> (1,9)
20:11:40 <nitrix> What's this? A reader functor?
20:11:56 <nitrix> I could've written f . g, but I think that was more interesting.
20:12:01 <nitrix> Is there any useful uses out of it?
20:12:07 <jle`> yeah, it's Reader
20:12:42 <jle`> EvanR: yup that's it.  you consider 1, 2, 3, 4, 9, 10, 11, 12 as variables, then there's your proof
20:13:01 <EvanR> it seems diferent from acertain's 
20:13:11 <nitrix> What's an example of using the reader functor?
20:13:50 <jle`> there are a couple of examples out there, but i think people consider it mostly an academic one
20:13:50 <benzrf> nitrix: the Reader functor/applicative/monad is (arguably) best thought of as
20:13:54 <nitrix> I mean, fmap (+1) (+2) is easy to understand a function composition but I don't see how having the capability of reading the argument (in my implementation) can be of any use.
20:14:01 <EvanR> jle`: my join is to take both lefts
20:14:12 <nitrix> benzrf: The monad makes sense, because you obtain the binding in scope.
20:14:14 <jle`> EvanR: oh
20:14:16 <nitrix> benzrf: But functor?
20:14:25 <jle`> EvanR: nvm, i misread
20:14:37 <benzrf> nitrix: think of '(r -> a)' as being a value of 'a' that is not available until it is within an environment containing r
20:14:52 <jle`> EvanR: write it out as a function, something might be fishy
20:15:17 <EvanR> join (Pair (Pair x y) (Pair z w)) = Pair x z
20:15:17 <nitrix> benzrf: Basically a lambda.
20:15:17 <benzrf> so think of, say, 'head :: [Int] -> Int' as being just an ordinary Int, that is dependent upon an environment variable to be fully evaluated
20:15:21 <benzrf> yeah :P
20:15:41 <benzrf> but then contextually the functor bit makes sense, because what you're doing is simply applying the mapped function to the value in question
20:15:59 <nitrix> Oh I see what you mean.
20:16:03 <benzrf> if you have data User = User {username :: String, ...}
20:16:14 <jle`> EvanR: oh yeah, that's not correct
20:16:20 <benzrf> then username :: User -> String; you can think of it as a String which becomes available when you have a particular User in mind
20:16:25 <jle`> @let data Pair a = P a a deriving (Show, Eq)
20:16:28 <lambdabot>  Defined.
20:16:29 <acertain> EvanR, your join doesn't obey the (x >>= return == x) law
20:16:29 <benzrf> so fmap reverse username is simply applying reverse to that string
20:16:57 <jle`> @let join1 (Pair (Pair x y) (Pair z w)) = Pair x z
20:16:58 <lambdabot>  .L.hs:196:8: Not in scope: data constructor ‘Pair’
20:16:59 <lambdabot>  
20:16:59 <lambdabot>  .L.hs:196:14: Not in scope: data constructor ‘Pair’
20:17:11 <jle`> @let join1 (P (P x y) (P z w)) = P x z
20:17:13 <lambdabot>  Defined.
20:18:07 <jle`> > join1 . join1 $ P (P (P 1 2) (P 3 4)) (P (P 5 6) (P 7 8))
20:18:09 <lambdabot>  P 1 5
20:18:14 <jle`> > join1 . fmap join1 $ P (P (P 1 2) (P 3 4)) (P (P 5 6) (P 7 8))
20:18:16 <lambdabot>  P 1 5
20:18:23 <jle`> oh huh
20:18:50 <dolio> Associativity isn't the issue.
20:18:50 <EvanR> what are the laws in terms of join
20:18:51 <acertain> $let return1 x = P x x
20:18:56 <acertain> @let return1 x = P x x
20:18:59 <lambdabot>  Defined.
20:19:11 <acertain> > join1 . fmap return1 $ P 1 2
20:19:12 <jle`> i guess it's not enough to follow that one
20:19:14 <lambdabot>  P 1 2
20:19:40 <EvanR> i thought i came up with it based on the identity
20:20:13 <dolio> > join1 . return1 $ P 1 2
20:20:14 <lambdabot>  P 1 1
20:20:20 <jle`> there ya go
20:20:28 <jle`> EvanR: here's one way to see the real intance:
20:20:37 <jle`> Pair a is equivalent to (Bool -> a)
20:20:46 <jle`> so, what's the Monad for (Bool ->) ?
20:21:22 <nitrix> benzrf: Oh wait
20:21:29 <jle`> and, what does `join` do for that one?
20:21:55 <nitrix> benzrf: Are you saying... that User has a (->) instance?
20:22:46 <nitrix> `data (->) a b  -- Define in `GHC.Prim``
20:22:51 <nitrix> OH. My. God.
20:22:52 <EvanR> p >>= f x = f (p x)
20:22:58 <nitrix> benzrf: This makes so much sense.
20:23:04 <benzrf> :)
20:23:09 <jle`> join f = \x -> f x x
20:23:12 <EvanR> join pp x = (pp x) x
20:23:13 <benzrf> nitrix: wait what
20:23:18 <benzrf> "(->) instance"?
20:23:38 <jle`> join f True = f True True; join f False = f False False
20:23:54 <EvanR> so left left, and right right
20:23:58 <nitrix> benzrf: Well, there's also the Monad, Functor, Applicative and Monoid (->) ...
20:24:03 <ThatTreeOverTher> how do I convert data of type Html to Text
20:24:10 <jle`> yeah, the "first" is the first of the first, and the "second" is the second of the second
20:24:14 <EvanR> join ((x,y),(z,w)) = (x,w)
20:24:15 <nitrix> ThatTreeOverTher: Are you using Blaze?
20:24:19 <ThatTreeOverTher> sure am
20:24:28 <jle`> yup, it's 'diagonal'
20:24:32 <EvanR> fearful symmetry ;)
20:24:53 <benzrf> nitrix: (->) isn't a typeclass, so you can't have "a (->) instance"
20:24:56 <jle`> you can extend this to find a general monad instance for fixed-length vector too
20:25:31 <EvanR> its V[i,i] for i 0 to N-1
20:25:33 <jle`> data Trip a = T a a a, which is equivalent to (Fin 3 -> a), so the first item is the first of the first, the second is the second of the second, and the third is the third of the third
20:25:54 <nitrix> benzrf: But there's a data (->) thingy.
20:26:05 <EvanR> jle`: er only two level sirght
20:26:11 <EvanR> levels 
20:26:21 <ThatTreeOverTher> nitrix, do you know?
20:26:31 <jle`> join takes 2 levels to one, but remember that two levels is (Bool -> (Bool -> (Bool -> Bool)))
20:26:36 <EvanR> its like a NxN matrix
20:26:43 <jle`> er, (Bool -> (Bool -> (Bool -> a)))
20:26:53 <jle`> oh yeah
20:26:54 <EvanR> oh
20:26:58 <jle`> wait, nvm
20:27:01 <EvanR> er
20:27:15 <EvanR> yeah two levels
20:27:18 <jle`> yeah, one level is (Bool -> a), two is Bool -> (Bool -> a), my bad
20:27:24 <EvanR> join takes the diagonal
20:27:33 <jle`> but the first item of the result is the first of the first, the second item of the result is the second of the second, etc.
20:28:06 <EvanR> this is way easier than binds ;)
20:29:14 <EvanR> that is crazy how monads have all this structure
20:29:15 <jle`> this also gives some insight to the only Applicative instnace you can write for fix-length vectors
20:29:30 <EvanR> yeah i grok the applicative one
20:29:37 <ThatTreeOverTher> what are you guys even talking about at this point
20:29:50 <EvanR> monads in terms of join
20:30:09 <EvanR> sorry for being stereotypical haskell
20:30:13 <jle`> haha
20:31:04 <ThatTreeOverTher> the chat doesn't go 20 lines without it descending into mathemagic, and I can't understand it :(
20:31:40 <EvanR> no other monad instance would work for N-length vectors (or streams) because for a different choice at some row/column, the column/row would not agree
20:31:57 <EvanR> so maybe that helps understanding other monad types
20:32:31 <ThatTreeOverTher> I'm still trying to figure out why I can't show Html, and I can't find which method to use to get text out of it
20:32:46 <nitrix> ThatTreeOverTher: I suppose it's a good way to realise where you're lacking.
20:33:13 <EvanR> ThatTreeOverTher: Html to Text? or do you want to directly serialize to ByteString
20:33:14 <jle`> EvanR: it works this way because vectors and "zippy applicatives" are isomorphic to (r -> a) for some r, so there's some underlying thing there
20:33:50 <ThatTreeOverTher> EvanR, I just want to see the output of operation, the underlying type is irrelevant to me right now :)
20:33:55 <jle`> ThatTreeOverTher: can't you use renderHtml?
20:33:59 <EvanR> jle`: ah so if its not like (Fin n -> a) or (N -> a) then it might not mean anything
20:34:27 <jle`> yeah, but you can get a lot of things to look like that
20:34:39 <EvanR> heh...
20:34:43 <EvanR> really?
20:34:57 <ThatTreeOverTher> jle`, ... thank you. Is there a way this could be found by searching, or is this just a thing you have to be "in the loop" for?
20:35:10 <EvanR> i found N embedded in newtype U = U (U -> Bool)
20:35:27 <jle`> ThatTreeOverTher: i remember learning this from a tutorial, but
20:35:33 <EvanR> and any computable functions of N
20:35:57 <jle`> i guess it's in here  http://hackage.haskell.org/package/blaze-builder-0.4.0.1/docs/Blaze-ByteString-Builder.html
20:35:58 <EvanR> ThatTreeOverTher: check the docs for your lib?
20:36:05 <jle`> the tutorial at the top
20:36:08 <jle`> has it
20:36:25 <jle`> "toLazyByteString" is the function the tutorial gives
20:36:36 <jle`> ah yeah, i'm assuming that you know how to find documentation for libraries?
20:36:59 <ThatTreeOverTher> I mean, a google query usually leads me to Hackage and that's about it
20:37:18 <ThatTreeOverTher> I'm trying to use the markdown library and it's doing all sorts of magic I guess
20:37:32 <EvanR> jle`: i am now wondering about the "indexed view" of types... but i gotta go pick up a pizza
20:37:33 <ThatTreeOverTher> Great way to find out what I don't know! Maybe not the best way to learn it though
20:37:37 <jle`> EvanR: i think that's what a representable functor is, a functor that can be expressed as (N -> a) for some N
20:37:45 <nitrix> Sometimes it's good to take a step back to understand the type system.
20:37:51 <jle`> ThatTreeOverTher: if you find the package, they usually give some sort of tutorial
20:37:55 <jle`> ThatTreeOverTher: or instructions on usage, or a demo
20:38:04 <jle`> in the package documentations; try seraching directly on hackage :)
20:38:05 <jle`> or stackage
20:38:44 <ThatTreeOverTher> oh hey, it is there, buried in a little example code block for some function
20:38:54 <EvanR> jle`: or as (Nat -> a) ?
20:38:56 <ThatTreeOverTher> alright, so I should pay more attention to all of these example blocks
20:39:26 <jle`> representable is (X -> a) for some choice of X, so it might be Nat, as in the case of infinite streams
20:39:36 <jle`> or Bool as in the case for Pair
20:40:03 <EvanR> what is an example of not representable
20:40:10 <nitrix> fmap f (x, y) = (x, f y)
20:40:12 <nitrix> fmap f (x, y) = (f x, f y)
20:40:21 <nitrix> Are they both valid functors?
20:40:30 <jle`> check your types
20:40:32 <jle`> :)
20:40:38 <EvanR> (f x, f y) isnt well typed
20:40:49 <jle`> EvanR: lists aren't reprsentable, i think
20:41:16 <jle`> so zippy lists can't be monads
20:41:21 <nitrix> EvanR: Oh, because of the type of f ?
20:41:21 <EvanR> why not, for lists of a finite type
20:41:27 <jle`> Maybe is also not reprsentable
20:41:36 <jle`> EvanR: what would the X type be?
20:41:41 <EvanR> Nat
20:41:52 <EvanR> also Maybe of a representable type
20:41:59 <jle`> how would you represent [1,2,3] as a (Nat -> Int) ?
20:42:17 <jle`> well, in a way that generalizes for all lists
20:42:41 <jle`> if you try the same scheme as for Vector/Pair, you get a partial function
20:42:44 <EvanR> lets start with Maybe
20:42:51 <EvanR> of a representable type
20:43:04 <jle`> hm?
20:43:11 <jle`> are you asking if Maybe is representable?
20:43:12 <EvanR> so its Maybe T, where T ~ (X -> T)
20:43:28 <EvanR> you can repesent this as (X + 1 -> T)
20:43:39 <EvanR> problem?
20:44:02 <jle`> what would Nothing get mapped to?
20:44:11 <EvanR> 1 gets mapped to Nothing
20:44:17 <EvanR> * : 1
20:44:25 <EvanR> () : 1
20:44:42 <EvanR> x : X gets mapped to Just x
20:44:54 <EvanR> er Just (rep x)
20:45:27 <jle`> so you're saying that Maybe (Pair a) is representable as ((Bool + 1) -> a) ?
20:45:27 <EvanR> it doesnt generalize to "any Maybe type"
20:45:45 <EvanR> is it not?
20:46:00 <jle`> if you pass in the 1, where does the `a` come from?
20:46:13 <EvanR> doesnt need one, since its Nothing
20:46:17 <jle`> assuming (Either Bool () -> a)
20:46:20 <EvanR> oh
20:46:30 <jle`> you need an a, not a Maybe a
20:46:39 <EvanR> wait wrong question
20:47:02 <EvanR> i was saying Maybe (Pair a) is representable as ((Bool + 1) -> Maybe (Pair a)), which i guess is also wrong
20:47:19 <EvanR> it should be ((Bool + 1) -> Pair a) which you cant do
20:47:22 <EvanR> nvm
20:48:12 <jle`> yeah, http://covariant.me/notes/rep-functors.html lists Maybe as the first example of a non-representable functor
21:01:07 <EvanR> jle`: ah so this concept is only for functors, so it doesnt even make sense to ask about representing Set
21:01:43 <EvanR> or... cant think of a non functor * -> *
21:01:53 <jle`> well, if Set is representable, then I'd presume it would be a Functor
21:02:00 <jle`> hm
21:02:09 <jle`> EvanR: Op is the famous one
21:02:22 <jle`> data Op a b = Op (b -> a)
21:02:42 <EvanR> so Op a is no functor
21:03:03 <jle`> yes
21:03:12 <jle`> (it's the famous contravariant functor though)
21:03:25 <dolio> Op a is actually what's called representable in category theory.
21:03:36 <dolio> Because they like contravariant functors better.
21:04:08 <dolio> Also Op is usually written y, the Yoneda embedding.
21:11:29 <jle`> category theorists are interesting
21:12:51 <dmj> jle`: heh
21:34:33 <EvanR> "the antisymmetry law, saying that x≤y and y≤x imply x=y, is evil in a certain sense"
21:34:47 <EvanR> ncatlab refers to `evil' but im not exactly sure what that is
21:36:01 <maybefbi> how can i populate a DBRef inside a Data.BSON Document?
21:36:11 <maybefbi> ive given up
21:37:27 <maybefbi> im using a Data.MongoDB driver
21:37:54 <maybefbi> i can only populate the DBRef. i cannot populate DBRef inside a DBRef
21:45:33 <haskell399> what is the best tutorial about monadstate?
21:46:01 <ThatTreeOverTher> if someone would like to help me with monad/type debugging, I have an issue here http://sprunge.us/SShG
21:46:38 <ThatTreeOverTher> at this point I am totally lost. I just want to put the output of "wikifyMany" on my console in any shape or form
21:46:42 <dmj> haskell: it's a typeclass from mtl
21:46:47 <dmj> haskell399: ^
21:47:17 <EvanR> ThatTreeOverTher: what is the type of renderHtml
21:47:39 <dmj> > return 4 :: MonadState (Int, String) m => m Int
21:47:41 <lambdabot>      No instance for (Show (m0 Int))
21:47:41 <lambdabot>        arising from a use of ‘show_M246275022695116956323004’
21:47:41 <lambdabot>      The type variable ‘m0’ is ambiguous
21:47:46 <dmj> @typ return 4 :: MonadState (Int, String) m => m Int
21:47:48 <ThatTreeOverTher> EvanR, https://hackage.haskell.org/package/blaze-html-0.4.2.1/docs/Text-Blaze-Renderer-Text.html (so, :: Html -> Text)
21:47:48 <lambdabot> MonadState (Int, String) m => m Int
21:48:07 <EvanR> what is the type of wikifyMany
21:48:23 <EvanR> put the type sig in your code, compile and paste the error
21:48:42 <ThatTreeOverTher> will do
21:50:31 <ThatTreeOverTher> EvanR, http://sprunge.us/KKjB
21:51:30 <EvanR> ThatTreeOverTher: so if you cant print an Html, you cant print a [Html]
21:51:45 <EvanR> seems like youre trying to get a [Text]
21:52:06 <EvanR> god help you if you get the types sigs wrong ;)
21:52:27 <ThatTreeOverTher> yeah, shouldn't map renderHtml wikis be :: [Html] -> [Text] ?
21:52:40 <EvanR> ah yes
21:52:41 <ThatTreeOverTher> then I foldr (++) "" that
21:52:47 <ThatTreeOverTher> and print it
21:53:00 <EvanR> you dont strictly need the foldr (++) "" == concat
21:53:01 <ThatTreeOverTher> so I should see HTML vomit in my terminal based on my markdown files
21:53:12 <ThatTreeOverTher> yeah, I got desperate :/
21:53:14 <EvanR> since you can print a list of [Text]
21:53:23 <EvanR> so the errors...
21:53:37 <EvanR> i see no line numbers
21:54:02 <EvanR> its complaining about the argument to wikifyMany
21:54:20 <EvanR> what is the type of listDirectory
21:54:48 <ThatTreeOverTher> FilePath -> IO [FilePath]
21:55:20 <EvanR> yeah thats right...
21:55:34 <EvanR> so wikifyMany is supposed to be a function returning a list
21:55:44 <EvanR> but its literally `returning' an IO list
21:56:13 <EvanR> even though its not doing IO
21:56:24 <ThatTreeOverTher> am I misunderstanding this IO thing
21:56:26 <EvanR> oh, but you meant for it to be doing IO
21:56:37 <EvanR> however wikify doesn't have an IO type
21:56:41 <ThatTreeOverTher> yeah, I got the type sig wrong but it errors still after adding it
21:56:57 <ThatTreeOverTher> want me to repost this after fixing the type sig
21:57:04 <EvanR> well fix wikify's type and wikifyMany's type
21:57:26 <ThatTreeOverTher> what's wrong with wikify's type?
21:57:58 <ThatTreeOverTher> oh, huh. it's doing IO, so there should be an IO in there somewhere... where, though?
21:58:24 <EvanR> a do block has the type m a for some m
21:58:34 <EvanR> in your case m = [], not IO
21:58:57 <EvanR> er, no its just Html, no m at all
21:59:06 <ThatTreeOverTher> oh, goody
21:59:15 <EvanR> a function like Int -> Bool or something cant do IO
22:00:25 <EvanR> so fix the type sig, then try to fix the code
22:00:35 <ThatTreeOverTher> after adding a missing IO, this is what I've got http://sprunge.us/cZAF
22:00:46 <EvanR> you didnt add the missing IO
22:00:54 <EvanR> wikify :: FilePath -> Html
22:01:01 <ThatTreeOverTher> oh, it's missing there too?
22:01:08 <ThatTreeOverTher> wait, why- oh
22:01:10 <EvanR> youre using readFile
22:01:27 <EvanR> so he do block has to have an IO type
22:01:47 <ThatTreeOverTher> so what happens to the type of wikifyMany?
22:02:02 <EvanR> thats right now, but the code is not
22:02:15 <EvanR> start by getting the types right
22:03:42 <ggVGc> ^^
22:03:48 <ggVGc> best part about haskell 
22:03:51 <ThatTreeOverTher> so I changed wikify to :: FilePath -> IO Html; wikifyMany now returns an IO [IO Html]
22:03:55 <ggVGc> you just get the types right and then it becomes pretty clear 
22:04:05 <EvanR> no, IO [IO Html] isnt right
22:04:08 <ThatTreeOverTher> even though the type should be IO [Html]
22:04:13 <EvanR> yes
22:04:15 <ThatTreeOverTher> too many return ?
22:04:20 <EvanR> no many IO
22:04:23 <EvanR> too*
22:04:35 <ThatTreeOverTher> wait, but taking out return only gives me [IO Html] not IO [Html]
22:04:53 <EvanR> a value of type IO a is a command which (might) return a value of type a
22:04:54 <ThatTreeOverTher> whoa
22:04:58 <EvanR> when its executed
22:05:02 <ThatTreeOverTher> sequence?
22:05:10 <EvanR> stop messing with returns and write the correct type signature ;)
22:05:22 <EvanR> then see whats wrong using the compiler
22:05:41 <EvanR> you want IO [Html]
22:06:08 <ThatTreeOverTher> sequence :: Monad m => [m a] -> m [a] 
22:06:11 <ThatTreeOverTher> that's what I want, right?
22:06:22 <EvanR> you probably want to replace map with mapM
22:06:35 <ThatTreeOverTher> :t mapM
22:06:36 <EvanR> or forM (they only differ in argument order)
22:06:37 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
22:07:00 <EvanR> ... Monad m => (a -> m b) -> [a] -> m [b]
22:07:13 <ThatTreeOverTher> so mapM is basically monad version of map
22:07:27 <ThatTreeOverTher> which is what I'm doing with sequence, in a weird way
22:07:32 <EvanR> @src mapM
22:07:32 <lambdabot> mapM f as = sequence (map f as)
22:07:40 <ThatTreeOverTher> oh
22:07:45 <ThatTreeOverTher> well, ok, cool
22:08:07 <ThatTreeOverTher> next time I should hoogle the entire sequence and my reduction will turn out better
22:08:21 <EvanR> well that wont work if you have the wrong types
22:09:06 <ThatTreeOverTher> true :) I've never had to deal with a hindley-milner type system before
22:09:23 <ThatTreeOverTher> it seems I survived Java by brute force
22:09:40 <ThatTreeOverTher> I only have one remaining error
22:10:05 <EvanR> when you get to point of keeping in mind what the type of each statement / expression is in your head, youll find other languages a lot easier to get right (and more infuriating for how they get in your way)
22:10:21 <ThatTreeOverTher> just kidding I have 0 errors now. how did that last error disappear
22:10:52 <ThatTreeOverTher> yeah, that makes sense
22:11:23 <ThatTreeOverTher> I was always fairly okay with having to specify every type as I defined it, but Haskell makes me a little spoiled
22:11:26 <EvanR> in haskell you kind of only need to get the top level types right
22:11:38 <EvanR> the rest will be determined by the compiler
22:11:53 <ThatTreeOverTher> for now I should probably write every type out, though
22:12:08 <EvanR> for every expression? could get dense
22:12:21 <ThatTreeOverTher> it's good practice that I apparently very much need
22:12:44 <ThatTreeOverTher> not for every line of every do block, mind you
22:12:46 <EvanR> you can replace any expr with a type hole, you can practice predicting what the compiler will say
22:12:55 <ThatTreeOverTher> how is that done?
22:13:21 <EvanR> put a _
22:13:33 <ThatTreeOverTher> _ can be in type signatures?
22:13:37 <ThatTreeOverTher> neat!
22:13:50 <EvanR> no, in the code
22:14:13 <ThatTreeOverTher> it seems I'm still misunderstanding you...
22:14:15 <EvanR> like x == y = f x _ z
22:14:28 <EvanR> f x y z = g 1 _ 'c'
22:14:44 <EvanR> the compiler will tell you what the type of the _ is
22:16:14 <ThatTreeOverTher> oh I see
22:16:49 <ThatTreeOverTher> thanks EvanR!
22:16:51 <julianleviston> typed holes are awesome
22:16:58 <kadoban> EvanR: Such an amazing little feature. I use that soooo much.
22:17:02 <julianleviston> hole-driven programming.
22:18:05 <julianleviston> https://www.youtube.com/watch?v=IRGKkiGG5CY
22:18:33 <EvanR> raichoo ++
22:20:17 <julianleviston> He’s very enthusiastic.
22:21:36 <julianleviston> “You might want to do this in C with like 50 lines of code, but I prefer to just use one” :)
22:22:16 <EvanR> lol emacs with 1 hand
22:22:27 <EvanR> ... or atom
22:22:44 <julianleviston> lol
22:22:45 <hodapp> wut
22:23:02 <julianleviston> I always have an aversity to call pattern matching deconstructing for some reason. 
22:23:13 <julianleviston> Is that wrong?
22:23:22 <julianleviston> I think it’s because it implies mutation
22:23:31 <Shockk> julianleviston: I like to cite the simple example of `data Maybe a = Just a | Nothing` when I tell people about Haskell's conciseness (concisity?)
22:23:51 <EvanR> yep thats wrong
22:23:55 <julianleviston> concision.
22:24:14 <julianleviston> I think conciseness is acceptable tho! :)
22:24:20 <dmwit> julianleviston: Did you mean... the opposite of aversity?
22:24:44 <hodapp> julianleviston: deconstructing != destructing though
22:25:06 <hodapp> the latter I consider to relate to mutation, but not the former
22:25:08 <julianleviston> hodapp: lol yeah, I know. But it implies pulling something into pieces and the original is no longer. :)
22:25:12 <dmwit> (even if you did want "aversity", you still didn't want "aversity" -- you wanted "aversion")
22:25:37 <hodapp> julianleviston: no more than 'construct' implies that the component pieces exist no longer
22:25:38 <EvanR> if you delete an object, is it really mutation ;)
22:25:38 <julianleviston> dmwit: possibly - did you understand what I meant?
22:25:51 <julianleviston> hodapp: well it kind of does :)
22:25:56 <dmwit> julianleviston: I'm honestly not sure whether I understand you. But I think it doesn't really matter.
22:25:58 <julianleviston> hodapp: but it also doesn't.
22:26:11 <julianleviston> hodapp: a photocopier constructs a new value from an existing one without mutating it
22:26:31 <julianleviston> dmwit: I meant I don’t really like it. I’m averse to it.
22:26:48 <julianleviston> dmwit: I have an aversion to it :)
22:26:59 <EvanR> you can use GADT syntax to make that code much bigger ;)
22:27:45 <dmwit> Weird. Who/what encourages you to call pattern matching "deconstructing" and thus triggers your dislike?
22:28:02 <julianleviston> EvanR: so it’s fine to call pattern matching deconstruction?
22:28:12 <MarcelineVQ> It is
22:28:30 <julianleviston> cool. I don’t like it.
22:28:49 <julianleviston> dmwit: oh, it was in the hole-driven programming video I just linked to
22:29:21 <dmwit> Oh, I see.
22:30:00 <julianleviston> MarcelineVQ: I also don’t like a bunch of the common ways we talk about values. “This function takes this value and adds one to it”… is that *really* what’s going on tho? When you apply a function to a value, it takes a reference to the value, then uses that to create a new value, right?
22:30:10 <EvanR> julianleviston: imagine iron man or dr manhattan doing to do something with a packed value, so they explode it and pick and choose the pieces to take from it
22:30:14 <julianleviston> I mean, I use them all the time… but it just seems a little imprecise is all
22:30:38 <julianleviston> EvanR: yeah, except that implies mutation.
22:30:50 <EvanR> julianleviston: talking about refernces to objects is really besides the point in haskell
22:31:03 <julianleviston> EvanR: how’s that?
22:31:05 <EvanR> pointers, secret mutations that might be happening, its not what we want to emphasize
22:31:08 <MarcelineVQ> There's a certain point in human communication where you trade precision for brevity.
22:31:22 <julianleviston> EvanR: my point is simply that there’s a subtle incorrectness in our usual language.
22:31:26 <EvanR> thats not usually relevant to how you code
22:31:29 <MarcelineVQ> It varies but context counts for a lot.
22:31:29 <EvanR> or verify correctness
22:31:34 <julianleviston> EvanR: and it makes things a bit tricky for beginners to understand things.
22:31:54 <EvanR> julianleviston: i daresay beginners are using even less precise language usually and need to feel comfortable on their own terms
22:32:13 <julianleviston> EvanR: no doubt, but that’s not really the point.
22:32:14 <EvanR> so "this function adds 1 to everything in the list" works
22:32:24 <julianleviston> EvanR: sort of.
22:32:26 <EvanR> both people agree and its right ;)
22:32:37 <julianleviston> EvanR:  it’s not harder to say “this function makes a new list with 1 added to all the elements of the first"
22:32:47 <EvanR> it doesnt "make a new list" semantically speaking
22:32:53 <EvanR> in math you dont talk like that
22:33:03 <julianleviston> EvanR: how do you talk?
22:33:05 <EvanR> when you applied a transformation nothing is being created
22:33:16 <julianleviston> EvanR: how’s that?
22:33:27 <EvanR> thats operational thinking
22:33:36 <EvanR> theres no moving parts in math
22:33:40 <julianleviston> EvanR: oh coz I said “make"
22:33:53 <julianleviston> yeah, sure. Returns a new list perhaps is better.
22:34:02 <dmwit> *is* a new list
22:34:03 <EvanR> new List(...) ;)
22:34:04 <julianleviston> or returns “the list"
22:34:12 <EvanR> i.e. envokes the memory allocation 
22:34:13 <dmwit> or even "is a list", without the "new"
22:34:22 <julianleviston> EvanR: new meaning different than the input list :)
22:34:25 <EvanR> not something you want to be emphasizing at first
22:34:32 <julianleviston> EvanR: well that’s your take away from new.
22:34:34 <EvanR> would also be subtly wrong in general
22:34:40 <julianleviston> EvanR: only if you read it that way
22:34:52 <julianleviston> EvanR: new doesn’t imply an operation necessarily. It can mean “one we haven’t seen til now"
22:35:00 <dmwit> "`map (+1) [2,3,4]` is a list with three elements, each one bigger than the ones in the input" -- is quite a mouthful, and *still* not quite precise
22:35:04 <EvanR> in FP we like to talk about what is not how it operates
22:35:21 <dmwit> So I have to agree with MarcelineVQ here. Eventually you trade precision for brevity and only drop down to the details once it matters.
22:35:21 <julianleviston> EvanR: we do
22:35:33 <julianleviston> dmwit: I’m not disagreeing with that.
22:36:01 <EvanR> Int -> Bool is functions from Ints to Bools, rather than machine code to inspect machine words and build Bool objects
22:37:19 <julianleviston> EvanR:  it is!
22:37:31 <EvanR> its interesting that map (+1) could be construed as updating any lists in place
22:37:36 <EvanR> like thats the default for computers
22:37:56 <EvanR> seems like nonsense now
22:42:27 <Cale> EvanR: You mean in the case where the original list is provably unused?
22:42:37 <Cale> (beyond the map consumer)
22:42:49 <julianleviston> Cale: I think he was talking about something like clojure or other langs, perhaps?
22:43:34 <Cale> ah, I see
22:44:01 <julianleviston> Cale: (partial map inc) for example…
22:44:23 <EvanR> Cale: no
22:44:29 <pikajude> yet again i get bitten by parsec greediness
22:44:49 <EvanR> just hypothetical misunderstanding of the explanation "this function adds 1 to each thing in the list"
22:47:28 <haskell466> What is the best way to sort list of tuples by tuple fst. Using sort not sortBy, should I create newtype and new Ord instance?
22:48:03 <haskell466> Or maybe such type already exists?
22:48:14 <kadoban> haskell466: Isn't that how lists of tuples already sort?
22:48:54 <haskell466> I thought it compare fst and then snd?
22:49:06 <thimoteus> > sort [(1,3), (2,2), (3,1)]
22:49:08 <lambdabot>  [(1,3),(2,2),(3,1)]
22:49:11 <julianleviston> :t sortOn
22:49:12 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
22:49:16 <kadoban> haskell466: Yes. What do you want it to do instead?
22:49:21 <julianleviston> :t sortOn fst
22:49:22 <lambdabot> Ord b => [(b, b1)] -> [(b, b1)]
22:49:42 <haskell466> I want to sort by compare only fst and I don't want to use sortBy
22:50:06 <kadoban> haskell466: This behaves differently in what important way for you?
22:50:08 <julianleviston> haskell399: sort by “compare only fst” <- ? not too sure what this means?
22:51:20 <EvanR> @src sortOn
22:51:21 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
22:51:41 <EvanR> :t sortBy (comparing fst)
22:51:43 <lambdabot> Ord a => [(a, b)] -> [(a, b)]
22:51:45 <haskell466> In other words I want something like tuple but Eq and Ord only use fst of tuple
22:51:47 <julianleviston> lol
22:52:26 <julianleviston> haskell399: sorry, I’m not sure what you mean. Can you give an example of input and output data you’ll like to achieve?
22:52:39 <EvanR> you can make a newtype over (,) and implement Ord using sortOn or sortBy (comparing fst)
22:52:40 <kadoban> haskell466: Are you sure you actually need this? I mean you can do it, but in basically every way it's going to function … pretty much identically.
22:52:49 <EvanR> or comparing
22:53:06 <EvanR> itll probably be more work than using sortBy
22:56:34 <mniip> hmm
22:57:15 <haskell466> Full example, I have [Person] and I have calcWeight :: Person -> Int  so I can get [(Int, Person)] and from now on in this tuple for Ord and Eq only weight should be used
22:57:55 <EvanR> you can also sort [Person] by weight... sortOn calcWeight persons
22:58:19 <haskell466> I could use sortBy, groupBy, every time, but sort and group would be better
22:58:35 <EvanR> every time?
22:58:47 <jle`> sortBy (comparing calcWeight)
22:58:58 <julianleviston> haskell466: you probably should explain more of your context to us if you want us to help you in a good way.
22:59:18 <julianleviston> haskell466: … because you’re saying a bunch of things that lead me to thin *maybe* there’s more to this than we’re assuming there is.
23:00:13 <mniip> does "data Parser t m a = Empty (m a) | Consume (t -> m (Parser t m a))" seem like a better typechecker-constrained parser than StateT over lists?
23:00:55 <mniip> where m is some Alternative or MonadPlus, I guess
23:01:47 <jle`> hm, it looks good to me, but what is better about it?
23:02:16 <mniip> well, with [t] -> ([t], a), you've got a lot of inhabitants that are "bad" parser
23:02:16 <mniip> s
23:02:26 <jle`> ah, yeah
23:02:34 <haskell466> What information do you need? I have this tuple (Int,Person) and I have many calculations with it which use Eq and Ord, so I don't want to use sortBy and other similar functions. Is newtype my only option?
23:03:01 <jle`> haskell466: you can make a data type
23:03:02 <EvanR> yes
23:03:07 <EvanR> newtype or data
23:03:09 <jle`> data MyThing = MT Int Person
23:03:12 <julianleviston> haskell466: why can’t you use sortBy? I don’t quite get that
23:03:15 <jle`> instead of using a tuple
23:03:19 <jle`> tuples are werid anyway
23:03:32 <EvanR> or use a record which has all the persons status
23:03:44 <jle`> mniip: there's also the Update monad too that's probably similar
23:03:58 <EvanR> however because there is probably more than 1 way to sort records, you probably want sortBy
23:04:24 <EvanR> instead of a fixed Ord class
23:04:33 <mniip> jle`, is there something I can look at that isn't a paper/
23:04:42 <jle`> there was edwardk's post
23:04:47 <haskell466> I have dozen of places when I use sort,group,etc so It would be not plactical to use sortBy every time
23:05:03 <mniip> newtype UpdateT p s m a = UpdateT { runUpdateT :: s -> m (p, a) }
23:05:04 <jle`> https://www.schoolofhaskell.com/user/edwardk/heap-of-successes
23:05:05 <mniip> this?
23:05:07 <jle`> yes
23:05:09 <mniip> that's just RWST?
23:05:18 <EvanR> haskell466: you can make a function mySort myGroup which factors in the standard 1 comparison function
23:05:30 <EvanR> so you dont have to type the extra term "each time"
23:05:43 <jle`> mniip: it's not State, because p is not s
23:05:48 <mniip> oh
23:05:52 <jle`> that's the magic of it
23:05:56 <mniip> ooooh
23:06:05 <jle`> instead of returning a new state, you return a way to modify the state
23:06:08 <jle`> that your interpreter then applies
23:06:20 <jle`> (>>=) and <*> are just monoidally "mappending" your modification type p
23:07:38 <mniip> that's interesting
23:07:59 <mniip> my idea is more about restricting what can happen to the input token list
23:08:19 <mniip> hmm
23:08:26 <mniip> this type doesn't allow look-aheads
23:08:42 <mniip> oh
23:08:47 <mniip> this is just parsec now isn't it
23:08:55 <mniip> if we add non-consuming parsers
23:12:10 <jle`> yeah, that's what the point is, you might have something like data TokenChanges = NoConsume | Consume Int | ... etc.
23:12:24 <jle`> and so you are only allowed to state how things change, but not directly manipulate the token list
23:12:59 <jle`> so instead of [String] -> (a, [String]), it's [String] -> (a, TokenChanges)
23:21:44 <mniip> what is it called again when we do d, Either (a, b) c ----> forall r. (a -> b -> r) -> (c -> r) -> r
23:21:54 <mniip> s/d,//
23:22:43 <jle`> that's the church encoding, and also the scott encoding too, i think
23:23:23 <mniip> there was one word that kinda covers both but is a different concept and monochrom didn't like when I mixed the two :o
23:23:44 <mniip> ah right, that was about folds
23:24:22 <mniip> yeah church encoding is probably the term
23:59:43 * hackagebot kazura-queue 0.1.0.0 - Fast concurrent queues much inspired by unagi-chan  https://hackage.haskell.org/package/kazura-queue-0.1.0.0 (asakamirai)
23:59:45 * hackagebot kazura-queue 0.1.0.1 - Fast concurrent queues much inspired by unagi-chan  https://hackage.haskell.org/package/kazura-queue-0.1.0.1 (asakamirai)
