00:08:49 <AndChat|356841> Hi, which one of framework is more easy between spock or scotty?
00:09:43 * hackagebot kazura-queue 0.1.0.2 - Fast concurrent queues much inspired by unagi-chan  https://hackage.haskell.org/package/kazura-queue-0.1.0.2 (asakamirai)
01:08:03 <jewels> Hi there. I have two different questions. 1) How can I write pretty mathematical formula in haddock? 2) How can I do to let haddock ignore quickcheck properties?
01:12:08 <mpickering> jewels: You can write mathematical formula if you use the master branch
01:12:14 <mpickering> which only builds with ghc-8
01:14:17 <jewels> mpickering: What about the second question?
01:21:50 <jewels> nobody here?
01:22:16 <tsahyt> jewels: You can tell haddock to ignore a module, see here https://www.haskell.org/haddock/doc/html/module-attributes.html
01:24:19 <jewels> tsahyt: I want that haddock doesn't write "prop>" directives. Is it possibile? 
01:24:23 <jewels> *possible
01:27:14 <tsahyt> jewels: The way I do it is that I just have all my properties in a module that doesn't get processed by haddock in the first place. You'll generally want to keep your tests/specs separate from the rest of your code anyway.
01:27:52 <tsahyt> You could just not document those with actual haddock syntax and use the prune option
01:28:07 <tsahyt> I don't know of a way to match over function names to exclude from the haddocks though
01:29:46 * hackagebot ag-pictgen 1.0.0.0 - Attribute Grammar picture generation  https://hackage.haskell.org/package/ag-pictgen-1.0.0.0 (AtzeDijkstra)
01:36:41 <jewels> tsahyt: Ok thank you :)
01:37:10 <jewels> tsahyt: Another question: Why haddock is not able to find the link to a type which is defined in the same module?
01:38:11 <jewels> tsahyt: error Warning: FuzzySet: could not find link destinations for: FuzzySet
01:38:18 <jewels> tsahyt: where FuzzySet is my module
01:38:31 <tsahyt> do you export FuzzySet?
01:39:11 <tsahyt> and does FuzzySet itself show up in the docs somewhere?
01:40:29 <jewels> tsahyt: let me try.
01:41:11 <jewels> tsahyt: thank you. It works :)
01:41:42 <tsahyt> good, I just guessed. In order to link to something, it has to have documentation.
01:44:22 <jewels> tsahyt: Do you know why after I've installed hlint I'm not able to run it. I've done: cabal install hlint; hlint "my_source"
01:44:30 <jewels> I receive "hlint command not found"
01:45:44 <cocreature> jewels: you need to have ~/.cabal/bin in your PATH
01:46:27 <tsahyt> or use stack to install it, and use stack exec hlint to run it
01:46:37 <tsahyt> (or put whatever path stack uses for binaries in your path)
01:49:12 <jewels> tsahyt: Thank you. Solved again :)
01:59:02 <qinusty> Any haskell related anything at FOSDEM this year?
01:59:56 <mchall> I am working my way through the monad challenges and have got to http://mightybyte.github.io/monad-challenges/pages/ex2-4.html I have completed the task where you implement queryGreek2 in terms of link and chain to function the same as queryGreek. I have now completed this http://lpaste.net/150894 could someone please have a look at this and make suggestions to improve it please
02:00:27 <LnL> is there some way to to this `module Foo ( module Bar ) where' while still exporting everything from Foo?
02:01:48 <dmwit> LnL: Sure, `module Foo (module Bar, module Foo) where`
02:02:50 <LnL> dmwit: ah, guess that makes sense
02:10:52 <dmwit> mchall: I have trouble seeing the same beautiful pattern that `queryGreek` has in your `queryGreek2`.
02:11:48 <dmwit> I would want to see something like: lookupMay s d `link` \val -> tailMay val `link` \tm -> maximumMay tm `link` \mm -> headMay val `link` \hm -> divMay (fromIntegral mm) (fromIntegral hm)
02:12:15 <dmwit> The idea being that the pattern is then much more clear/the translation more mechanical.
02:12:34 <KaneTW> 1400 line TH-generated case expression
02:12:36 <KaneTW> jesus christ
02:13:16 <KaneTW> there HAS to be a better way
02:13:30 <mchall> dmwit I know how can I improve it ?  when I have tried to implement it using link (not infix) I get there are too many arguments to link ?
02:13:48 <dmwit> mchall: Also, I would bet the `queryGreek [] _ = Nothing` and `queryGreek2 [] _ = Nothing` clauses are unneeded -- because `lookupMay` will already return `Nothing` if `d` is `[]`.
02:14:21 <dmwit> mchall: If you want help with an error, show the exact code you tried and the exact error you get.
02:14:30 <dmwit> I won't be able to stick around -- I turn into a pumpkin in 30 seconds.
02:14:35 <dmwit> But somebody will take a look, I'm sure.
02:19:01 <mchall> dmwit I have put the code and the error beneath it http://lpaste.net/150894
02:25:58 <jle`> i accidentally installed ghc-8.0
02:26:00 <jle`> things are weird
02:26:51 <cocreature> jle`: how did that happen? :)
02:27:09 <jle`> well i was trying to build it so i could work on haddock HEAD
02:27:15 <jle`> but i accidentally installed it to my system instead
02:27:34 <jle`> i still use `stack` now for most of my day-to-day haskell, so it doesn't affect me much
02:27:46 <jle`> but now when i just type in plain `ghci` i get a ghc-8.0 prompt
02:28:43 <jle`> typeapplication is kind of weird because it's sort of hard to know a priori what order it's expecting the type arguments in
02:29:25 <jle`> i thought i had read somewhere that it'd be smart in matching things up by kind, but this hasn't been the case from what i've seen
02:29:47 <jle`> i expected fmap @Int to specialize to (Int -> a), but instead it's a type error because it expects the 'f' first
02:30:04 <jle`> (the Functor)
02:30:17 <jle`> i can see this making it sort of hard to read code
02:35:20 <latermuse> how do I view all of a target that is nested using lens? So the first layer is not unique, but a field in the second layer is always the same for every entry. How can they be viewed all at once?
02:37:17 <jle`> latermuse: you should be able to use toListOf or (^..) and normal composition, right?
02:38:43 <latermuse> I am trying to figure out how to wild card the first layer?
02:38:57 <jle`> well, you need a traversal to describe your first layer
02:38:58 <latermuse> Im not very good at lens, not sure of the correct terminology yet
02:39:00 <jle`> what type is it?
02:39:18 <jle`> what's the specific type?
02:39:34 <latermuse> I made my own data type
02:39:37 <latermuse> using `Data`
02:39:54 <jle`> can you paste it?
02:40:05 <latermuse> okay, one moment
02:41:28 <latermuse> I want to get the "playerID" of both players on this paste: http://lpaste.net/151250
02:41:44 <latermuse> using lens
02:42:26 <latermuse> there are other things in the gamestate and player records, I removed them for the example
02:43:07 <jle`> hm, you'd need a traversal, i'm not sure if you can auto-generate them
02:43:45 <jle`> players :: Applicative f => (Player -> f Player) -> GameState -> f GameState
02:44:07 <jle`> players f (GameState p1 p2) = GameState <$> f p1 <*> f p2
02:44:30 <jle`> and then now, (players . playerID) should let you traverse over all player id's
02:44:50 <latermuse> ohh really
02:44:53 <latermuse> thats interesting!
02:45:10 <jle`> yeah, players :: Traversal' Gamestate Player
02:45:13 <latermuse> wow great thanks :)
02:45:23 <jle`> and so (players . playerID) :: Traversal' GameState Int
02:46:19 <jle`> latermuse: so, you can do anything you would do with a Traversal with it
02:46:29 <jle`> like, toListOf, or (^..), lets you view them as a list
02:46:49 <jle`> > [('h',2),('e',3),('y',5)] ^.. traverse . _1
02:46:51 <latermuse> wow great
02:46:52 <latermuse> the power of lens is limitless
02:46:52 <lambdabot>  "hey"
02:47:06 <jle`> (`traverse` traverses every item in the list, like how players traverses every player in your GameState)
02:49:21 <latermuse> got it
02:49:23 <latermuse> so its like map
02:49:42 <jle`> couple of functions here that you can use on a traversal http://hackage.haskell.org/package/lens-4.13.1/docs/Control-Lens-Fold.html
02:49:55 <jle`> yeah, it lets you do mappy stuff, and also 'lots more', too....like, accumulating the items into a list
02:50:24 <jle`> for example, over (players . playerID) (+1) gameState   is like a map over the playerID's of all your players in your state
02:50:31 <jle`> it adds 1 to every _playerID
02:51:31 <latermuse> functional!
02:52:58 <jle`> :D
02:53:26 <jle`> `traverseOf (players . playerId) print gameState` will print all of the ID's, for instance
02:53:55 <Xandaros> I should probably make more use of things like prisms and traversals in projects that use lens
02:54:08 <Xandaros> I tend to just use basic lenses
02:54:56 <jle`> they come in handy because i write a lot of traversals in normal code
02:55:34 <jle`> so lens gives me helper functions to work with the traversals i've written already, heh
02:55:55 <jle`> doesn't help with my rank-n traversals though ;_;
02:58:33 <latermuse>     No instance for (Monoid Int) arising from a use of ‚Äòtraverse‚Äô
02:59:01 <latermuse> I know int isnt a monoid, but why does it assume that it needs to be?
02:59:11 <latermuse> so it can concat them all together?
02:59:33 <dramforever> latermuse, you seem to be using (^.) when you are supposed to user (^..)
02:59:48 * hackagebot path-io 0.3.0 - Interface to directory package for users of path  https://hackage.haskell.org/package/path-io-0.3.0 (mrkkrp)
03:00:06 <dramforever> because in the former case, yes, they mappend them together
03:01:11 <latermuse> what is the non-operator name for (^..) ?
03:01:18 <latermuse> searching for operators is really difficult
03:01:31 <dramforever> @hooglt (^..)  +lens
03:01:33 <lambdabot> Could not find some databases: lens
03:01:33 <lambdabot> Searching in:
03:01:33 <lambdabot>   .
03:02:08 <latermuse> https://www.haskell.org/hoogle/?hoogle=%28^..%29
03:02:12 <latermuse> no results
03:02:38 <dramforever> latermuse, try this stackage hoogle http://www.stackage.org/lts-5.0/hoogle?q=%28^..%29
03:03:05 <latermuse> works nice!
03:05:28 <jle`> latermuse: all of the lens operators along with their normal-names are also in the docs for Control.Lens.Operators
03:08:39 <KaneTW> ok i'm pretty happy with this now
03:09:09 <KaneTW> i wrote some tmeplate haskell to only generate proof cases if i nee them
03:09:18 <KaneTW> instead of brute-forcing every combination
03:11:22 <latermuse> does this traverse twice, or is it inlined to one traversal? http://lpaste.net/151251
03:15:50 <KaneTW> can i write annotations for a closed type family
03:15:55 <KaneTW> haddock annotations/
03:16:01 <KaneTW> it's currently errorirng
03:17:05 <sunfun> hi, I have created a cabal package for a module I defined, but when I run ghci and I try to import the module from the package I it says: "Could not find module ‚ÄòFST.FuzzySet‚Äô It is a member of the hidden package ‚Äòfst-0.1.0.0@fst_B2NAGS2nbEL7SFRMhxl05E‚Äô.". Any suggestions?
03:18:50 <FUZxxl> sunfun: What is your question?
03:19:27 <sunfun> I would like to know why it says that the package is hidden
03:19:45 <dramforever> sunfun: because you haven't told ghc your program requires it
03:19:48 <KaneTW> when building with cabal it hides all packages by defaul
03:19:53 <KaneTW> you need to add it to build-depends
03:20:27 <dramforever> just add something like fst >= 0.1.0.0 < 1 to build-depends in your whatever-package-you-are-working-on.cabal
03:25:06 <sunfun> dramforever: the problem is that my cabal is fst.cabal
03:26:57 <dramforever> sunfun: Did you cabal build?
03:27:12 <sunfun> Yes dramforever, now it's solved
03:27:17 <dramforever> Hmm... I think I remember seeing packages depending on itself
03:27:26 <sunfun> thank you for your time 
03:27:27 <dramforever> you could try to add fst to build-depends anyway
03:27:42 <dramforever> you're welcome :) btw can you tell me how you fixed it?
03:28:19 <sunfun> I found that I had two versions installed
03:29:11 <sunfun> I had to use cabal-uninstall to remove the old one
03:30:04 <sunfun> so the problem wasn't the build-depends 
03:31:32 <dramforever> sunfun: oh :)
03:32:56 <sunfun> dramforever: I'm new to cabal, sorry :)
04:09:27 <Ainieco> hello human/non-human beings
04:10:22 <Ainieco> i guess "bio/tech entities" is better
04:10:29 <Ainieco> because of cats/bots
04:15:37 <ely-se> hi, the https://wiki.haskell.org/Time wiki page says "Although AbsoluteTime is appropriate for many tasks, it is rarely used in applications and you will likely never use this data type." and the Haddock documentation of the relevant module also says "most people won't need this module." However, I can't seem to find _why_ this is the case?
04:25:08 <f00f00> Hi!
04:25:26 <f00f00> is anyone of you familiar with the more recent versions of the Haskell DSL 'Feldspar'?
04:25:41 <f00f00> https://github.com/Feldspar/feldspar-language
04:25:47 <f00f00> this version is more up to date than the one on Hackage
04:26:06 <f00f00> however, the tutorial file that is floating around refers to a much earlier version
04:26:38 <f00f00> http://dsl4dsp.inf.elte.hu/feldspar/documents/FeldsparTutorial.pdf
04:26:51 <f00f00> it mentions a command "icompile" for generating C code
04:27:00 <f00f00> but this command no longer works in the most recent version
04:34:52 * hackagebot cartel 0.16.0.0 - Specify Cabal files in Haskell  https://hackage.haskell.org/package/cartel-0.16.0.0 (OmariNorman)
04:54:52 * hackagebot ether 0.4.0.0 - Monad transformers and classes  https://hackage.haskell.org/package/ether-0.4.0.0 (int_index)
05:09:00 <quchen> In the X.Extended pattern, is there a way to get an error if I import X and not X.Extended?
05:09:26 <quchen> I'd like to force programmers to use only the Extended module, making it an error to use the non-extended version.
05:14:21 <bergmark> quchen: if don't depend on the original package...
05:16:31 <bergmark> you could also have an empty X  module in the extended package, that way you'd get a module conflict if you try to import it
05:17:01 <quchen> bergmark: But the extended module depends on the module I don't want used, so I can't hide it altogether
05:17:34 <bergmark> you can still import it with PackageImports
05:17:35 <quchen> I guess if I put every Extended in an "my-extensions" package and then only use that that would work. 
05:17:56 <quchen> Ah, that extensions. Might be worth revisiting.
05:18:00 <quchen> -s
05:24:27 <Avaq> Hello! I started learning Haskell today. I hope to get some answers here to the questions that I will doubtlessly get at several occasions. My first question will follow;
05:25:45 <Avaq> I'm wondering how infix operators work under the hood.
05:25:45 <Avaq> I've noticed I can "get at" the underlying function to an infix operator (like "+") by putting it in brackets (like "(+)").
05:25:46 <Avaq> Doing so allows me to print its type signature, or to call or pass it like a normal function.
05:25:46 <Avaq> Does this mean that the "+" (or any other infix) function is just a normal function that is tagged somehow to be infix-by-default (as https://wiki.haskell.org/Infix_operator seems to suggest)?
05:25:46 <Avaq> (If so; is it possible to create my own infix-by-default functions by tagging them the same way?)
05:25:46 <Avaq> Or is the "+" actually just an operator (a predefined language construct) which uses a function that happens to have the same name to perform its operation.
05:25:46 <Avaq> (If so; I guess it's not possible to create my own infix operators.)
05:26:57 <Xandaros> Avaq: You can make your own operators by defining functions consisting only of special characters in parantheses, yes
05:27:40 <bergmark> Avaq: any special characters in identifiers can be used only in infix functions, so + and *&* are always infix, and a&b is not a valid identifier (it's parsed as a & b)
05:27:43 <ggole> Avaq: it's just a matter of parsing. You can use infix operators in infix position without parens, or in infix position without them.
05:28:14 <ggole> You can do it on either side of =,eg, a + b = "zonk" defines a two-argument function +.
05:28:50 <ggole> It's the same binding either way.
05:29:14 <Xandaros> That is true, but you can't do that in the signature
05:29:23 <quchen> > let (+) = "hello" in (+) ++ "world" -- Avaq: (+) is a normal name, nothing special.
05:29:26 <lambdabot>  "helloworld"
05:39:04 <lambdafan> http://lpaste.net/151161
05:40:03 <srhb> > let foo :: (->) a String; foo x = "Like this?" in foo 42 -- Xandaros?
05:40:04 <lambdabot>  "Like this?"
05:41:16 <Xandaros> No, I meant that you need to use the prefix form to specify the signature of an operator. (You need to include the parentheses)
05:42:19 <srhb> Oh, as in (+) :: ...
05:42:24 <Xandaros> yes
05:43:46 <Avaq> Ahhh, so the secret is that you *have* to use special characters if you want to create your own infix operators! That's cool. I think I get it:
05:44:08 <Avaq> > let (¬§) = (+); 1 ¬§ 2;
05:44:10 <lambdabot>  <hint>:1:21: parse error on input ‚Äò;‚Äô
05:44:15 <Xandaros> Yeah, it has to be special characters. I'm not exactly sure what counts as special, though
05:44:22 <Avaq> (Hm, that worked in the REPL)
05:44:28 <Xandaros> replace ; with "in"
05:44:41 <Xandaros> REPL supports do-notation syntax, so it worked there
05:44:46 <ggole> You can use regular operators infix with `foo`, as well.
05:45:02 <ggole> (Haskell's syntax is rather flexible in this regard.)
05:45:12 <Xandaros> > let (‚ÄΩ) = (+) in 1 ‚ÄΩ 2
05:45:14 <lambdabot>  3
05:45:37 <Avaq> @Xandaros I see. :)
05:45:38 <lambdabot> Unknown command, try @list
05:45:59 <Xandaros> let (≈≠) = (+) in 5 ≈≠ 6
05:46:04 <Xandaros> > let (≈≠) = (+) in 5 ≈≠ 6
05:46:07 <lambdabot>      Could not deduce (Num a0)
05:46:08 <lambdabot>      from the context (Num a, Num a2, Num ((a -> a -> a) -> a2 -> t))
05:46:08 <lambdabot>        bound by the inferred type for ‚Äòe_156‚Äô:
05:46:29 <Xandaros> How does it determine what counts as a special character?
05:46:32 <EvanR> wth... and isnt ≈≠ a letter
05:46:33 <Avaq> Yeah, so "≈≠" is not considered a special character suitable to be an opeartor.
05:46:48 <padre_angolano> let ≈≠ = (+) in 5 `≈≠` 6
05:46:50 <ggole> There, it is trying to apply 5 to the arguments ≈≠ and 6
05:46:50 <padre_angolano> > let ≈≠ = (+) in 5 `≈≠` 6
05:46:54 <lambdabot>  11
05:46:55 <EvanR> Xandaros: it has to be a "symbol"
05:47:08 <FireFly> Xandaros: it looks at the unicode category I beieve
05:47:18 <Xandaros> Oh, unicode has categories?
05:47:21 <Xandaros> interesting
05:47:22 <FireFly> Yeah
05:47:40 <EvanR> > isSymbol '≈≠'
05:47:42 <lambdabot>  False
05:47:50 <EvanR> > isSymbol '+'
05:47:50 <ggole> Hard to imagine how things would work otherwise
05:47:51 <lambdabot>  True
05:47:52 <Avaq> > let (üí©) = (+) in 1 üí© 1;
05:47:54 <lambdabot>  <hint>:1:23: parse error on input ‚Äò;‚Äô
05:48:00 <ggole> You couldn't really just enumerate them...
05:48:03 <Avaq> > let (üí©) = (+) in 1 üí© 1
05:48:04 <lambdabot>  2
05:48:11 <Avaq> Emoji work. :D
05:48:23 <Xandaros> I guess it's not supposed to be a box, then? :D
05:48:26 <EvanR> > generalCategory '≈≠'
05:48:28 <lambdabot>  LowercaseLetter
05:48:37 <Xandaros> let (‚ô•) = (+) in 5 ‚ô• 3
05:48:40 <Xandaros> > let (‚ô•) = (+) in 5 ‚ô• 3
05:48:42 <lambdabot>  8
05:48:43 <Xandaros> heh
05:48:45 <ggole> https://twitter.com/emojihaskell is an amusing application of that
05:48:53 <EvanR> > generalCategory '‚ô•'
05:48:55 <lambdabot>  OtherSymbol
05:49:08 <Xandaros> lol
05:49:18 <Xandaros> > generalCategory '‚ÄΩ'
05:49:19 <lambdabot>  OtherPunctuation
05:49:27 <Avaq> > generalCategory '≈≠'
05:49:29 <lambdabot>  LowercaseLetter
05:49:38 <Avaq> That's why! :)
05:49:43 <Xandaros> > generalCategory '·∫û'
05:49:45 <lambdabot>  UppercaseLetter
05:49:49 <Xandaros> It knows! :D
05:51:03 <FireFly> Hehe
05:51:11 <Xandaros> I guess this allows you to use all sorts of operators. Could be a problem for windows users who can't type these, though, heh
05:51:24 <EvanR>  or OSX users
05:51:27 <hodapp> usually Windows users have a lot else to worry about
05:51:28 <EvanR> or linux users
05:51:34 <Avaq> Alright, well, this answers my question as to how infix operators become "infix-by-default". They just have to be in the "OtherX" UTF8 category. :)
05:51:41 <srhb> filter isSymbol [minBound .. maxBound] -- should do the trick. probably spammy, though.
05:51:55 <EvanR> Avaq: these are known as just `operators' ... they use symbols instead of letters
05:52:12 <EvanR> non-operators need `` around it to be infix
05:52:15 <srhb> And what is ' anyway
05:52:26 <srhb> > generalCategory '\''
05:52:27 <Xandaros> excellent question
05:52:28 <lambdabot>  OtherPunctuation
05:52:39 <srhb> So there's at least one exception.
05:52:40 <tsahyt> :t generalCategory
05:52:41 <lambdabot> Char -> GeneralCategory
05:52:54 <Xandaros> > let asd‚ÄΩ = 5 in asd‚ÄΩ
05:52:56 <lambdabot>  <hint>:1:10: parse error on input ‚Äò=‚Äô
05:53:05 <srhb> Xandaros: No, ' really is a special case.
05:53:05 <Xandaros> ' is magic!
05:53:05 <EvanR> > let x'‚ÄΩ = 4 in x'‚ÄΩ
05:53:07 <lambdabot>  <hint>:1:9: parse error on input ‚Äò=‚Äô
05:53:12 <EvanR> > let x' = 4 in x'
05:53:14 <lambdabot>  4
05:53:32 <Avaq> > generalCategory '\`' --I guess this one is magic too?
05:53:34 <lambdabot>  <hint>:1:19:
05:53:34 <lambdabot>      lexical error in string/character literal at character '`'
05:53:46 <FireFly> > generalCatergory '`'
05:53:48 <lambdabot>      Not in scope: ‚ÄògeneralCatergory‚Äô
05:53:48 <lambdabot>      Perhaps you meant ‚ÄògeneralCategory‚Äô (imported from Data.Char)
05:53:51 <FireFly> > generalCategory '`'
05:53:52 <lambdabot>  ModifierSymbol
05:53:54 <Xandaros> xD
05:54:04 <FireFly> I'm not good at typing today :p
05:54:05 <EvanR> unicode how does it work
05:54:10 <EvanR> its a miracle
05:54:51 <Xandaros> > let (%`¬ß) = (+) in 5 %`$ 7
05:54:52 <lambdabot>  <hint>:1:7: parse error on input ‚Äò`‚Äô
05:54:57 <Xandaros> ` is indeed special
05:55:04 <EvanR> yes
05:55:08 <Xandaros> probably makes parsing easier
05:55:12 <EvanR> this is all in the haskell report
05:55:24 <Xandaros> It better be
05:56:03 <EvanR> screw ascii and unicode, lets use arbitrarily formatted and stylized text to write code
05:56:43 * ggole indicates the sad carcass of Fortress
05:56:45 <Xandaros> I've actually thought about developing with UnicodeSyntax before :P
05:57:11 <KaneTW> > generalCategory "„Åã"
05:57:12 <EvanR> agda seems to be surviving despite it
05:57:12 <lambdabot>      Couldn't match expected type ‚ÄòChar‚Äô with actual type ‚Äò[Char]‚Äô
05:57:12 <lambdabot>      In the first argument of ‚ÄògeneralCategory‚Äô, namely ‚Äò"\12363"‚Äô
05:57:13 <lambdabot>      In the expression: generalCategory "\12363"
05:57:18 <KaneTW> > generalCategory '„Åã'
05:57:19 <lambdabot>  OtherLetter
05:58:13 <Xandaros> Haskell code would probably look pretty awesome with UnicodeSyntax and ExplicitForAll :D
05:59:27 <ggole> Pain to type though,.
05:59:45 <EvanR> eh..
05:59:50 <EvanR> dunno if it would look awesome
06:00:00 <EvanR> agda looks awesome but its usually talking about math
06:13:04 <Avaq> Seems like the parenthesis can be left out or included at will when working with normal identifiers
06:13:04 <Avaq> > let (foo) = (+) in foo 1 1
06:13:04 <Avaq> > let foo = (+) in (foo) 2 2
06:13:07 <lambdabot>  2
06:13:07 <lambdabot>  4
06:13:12 <Avaq> But for special characters the compiler prefers to use them as operators unless they're explicitly in parenthesis
06:13:12 <Avaq> > let ¬§ = (+) in 1 ¬§ 1
06:13:16 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
06:13:48 <Avaq> (Oh, my repl gave "<interactive>:77:5: parse error on input ‚Äò¬§‚Äô" on that last line, a little more clear)
06:14:38 <ggole> Parens around normal identifiers are just grouping
06:15:19 <EvanR> Avaq: (f x) y = f x y
06:31:08 <dominik> is there any way to splice in multiple function patterns at once using Template Haskell?
06:32:22 <dominik> e.g. something like: funcWithManyArgs $([p| (varP x) | x <- someListOfNames]) = undefined ?
07:11:09 <lambdafan>   
07:11:38 <hodapp>  
07:13:48 <t0by>      .
07:18:29 <Hafydd> dominik: you can construct such a declaration using the functions `funD' and `clause' from Language.Haskell.TH.
07:22:26 <Hafydd> e.g, use this as a declaration splice: $(funD 'funcWithManyArgs [clause [varP x | x <- someListOfNames] (normalB [| undefined |]) []])
07:24:59 <Ainieco> hello,
07:26:14 <Ainieco> how can i reload my cabal project in emacs after cabal file was changed? i need it because ghc-mod/haskel-mode/flycheck/etc don't see changes and wrongly report one module as hidden
07:26:58 <hexagoxel> Ainieco: call `cabal configure` somehow?
07:28:06 <hexagoxel> (not an emacs user, so i wouldnt know if there was a shortcut)
07:28:22 <Ainieco> hexagoxel: no
07:28:30 <Ainieco> that won't affect emacs
07:29:05 <Ainieco> have to restart emacs every time i add dependency to cabal file, so annoying
07:32:55 <lambdafan> Hi I'm trying to write a FromJSON instance for a Base64 newtype wrapper. I've got the ToJSON instance, wanting to see if that makes sense before moving on
07:33:25 <lambdafan> I've posted my lpaste, can do again if someone wants to have a look
07:34:57 * hackagebot monoid-subclasses 0.4.2 - Subclasses of Monoid  https://hackage.haskell.org/package/monoid-subclasses-0.4.2 (MarioBlazevic)
07:39:09 <dominik> Hafydd: Yes, I know that. I was just wondering if I there was a more succinct way using quotes (or quasiquotes) of doing so.
07:39:11 <pavonia> lambdafan: Why B.unpack? Is there no ToJSON instance for ByteStrings?
07:42:58 <xpilot> how do I debug errors of the form "No instance nor default method for class operation"?
07:43:02 <Hafydd> dominik: I see. Good question, then. I don't know of any mysekf.
07:44:50 <dominik> Hafydd: I think, that using quasi-quotes it should actually work to convert some [varargs| x_1 ... x_n] into a TH pattern `TupP [VarP x_1, ..., VarP x_n]'.
07:44:58 * hackagebot dresdner-verkehrsbetriebe 0.1.1 - Library and program for querying DVB (Dresdner Verkehrsbetriebe AG)  https://hackage.haskell.org/package/dresdner-verkehrsbetriebe-0.1.1 (meoblast001)
07:45:04 <pavonia> xpilot: Could you provide more context?
07:48:28 <pavonia> xpilot: Oh, that just means that you haven't defined some class function (apparently called "operation"), and there also isn't a default implementation in the class defintion
07:50:00 <meoblast001> how does one blacklist a package on hackage?
07:50:08 <meoblast001> s/package/version/
07:50:15 <meoblast001> i found out that a version of one of my packages can't even build
07:50:28 <meoblast001> i screwed up testing the release
07:50:44 <Hafydd> dominik: I'm not sure if that's worth the effort. If you'd accept the uncurried version, why not just construct the tuple pattern explicitly?
07:53:46 <dominik> Hafydd: yea, that's also what I'm thinking currently.
07:56:32 <osa1> what's the closest thing in base to `readMay :: Read a => String -> Maybe a` ?
07:57:29 <Xandaros> reads, I think
07:57:31 <Xandaros> :t reads
07:57:33 <lambdabot> Read a => ReadS a
07:57:52 <osa1> how do I use it?
07:57:56 <osa1> :info ReadS
07:58:49 <supki> osa1: Text.Read.readMaybe
07:59:04 <Xandaros> It's pretty annoying, to be honest. I'd go with the safe package, or, if it has to be in base, copy the function
07:59:14 <Xandaros> supki: Not in base :P
07:59:23 <osa1> supki: thanks
07:59:28 <osa1> it's in base
07:59:40 <Xandaros> it is?
08:00:07 <osa1> http://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:readMaybe
08:00:14 <Xandaros> Ah, interesting
08:00:14 <bergmark> yeah it's just in a weird module...
08:00:46 <Xandaros> Not so weird, when you think about it. Why is it not re-exported in the Prelude?
08:02:10 <osa1> because Prelude sucks and nobody uses it except when you're stuck with it for some stupid reason
08:02:48 <Xandaros> The Prelude does indeed suck :D
08:02:59 <t0by> er
08:02:59 <t0by> why
08:03:24 <xpilot> pavonia: I think it's actually that the library I'm using isn't defining some methods
08:03:27 <Hafydd> Hysterical raisins.
08:04:00 <hpc> it doesn't suck that bad, haskellers just have high standards ;)
08:04:35 <Xandaros> t0by: It is full of partial functions and many functions are overly special (like (++) or map)
08:04:52 <Xandaros> s/many/some
08:06:52 <ChristianS> Xandaros: though some of these shortcomings have been fixed in ghc 7.10
08:07:21 <Xandaros> I'm talking about the 7.10 Prelude, though you are right. It used to be even worse
08:07:30 <Xandaros> hpc: You're probably right, though^^
08:11:40 <pavonia> xpilot: Is that an error or a warning? And when do you get that?
08:11:53 <eacameron> GHCJS helpfully lifts most of its IO stuff to MonadIO, but now I'm stuck because I need to run forkIO in MonadIO but Reflex-DOM's host monad is not an instance of MonadBaseControl. Is there another way to lift forkIO?
08:12:47 <dmj> eacameron: do you need MonadBaseControl to run forkIO? Do you mean "fork"
08:13:16 <dmj> :t liftIO . forkIO
08:13:17 <lambdabot> Not in scope: ‚ÄòforkIO‚Äô
08:13:24 <dmj> bleh
08:13:55 <Hafydd> forkIO is so unsafe that even its type can cause effects.
08:14:05 <eacameron> :t liftIO . Control.Concurrent.forkIO
08:14:07 <lambdabot> MonadIO m => IO () -> m GHC.Conc.Sync.ThreadId
08:14:28 <eacameron> I need the argument to accept MonadIO :/
08:14:47 <eacameron> Ah, yes I see "fork" now from lifted-base, but that requires MonadBaseControl
08:17:00 <eacameron> Or is there someway to "unlift" my code back into IO?
08:17:43 <Xandaros> ¬¥MonadIO a => a¬¥ could be something other than ¬¥IO¬¥, so... I doubt it :P
08:17:57 <eacameron> Yeah I figured...
08:18:01 <dmj> eacameron: paste the teh codes
08:18:15 <eacameron> unsafeStopBotheringMe :: Monad m => m a -> IO a
08:18:24 <cocreature> monadbasecontrol is great for that kind of stuff
08:18:57 <jmcarthur> stopBotheringMe :: (forall m. Monad m => m a) -> IO a
08:19:40 <jmcarthur> (possible to write. doesn't do what you want.)
08:19:58 <cocreature> > unsafeCoerce  :: m a -> IO a
08:20:00 <lambdabot>  Not in scope: ‚ÄòunsafeCoerce‚Äô
08:20:08 <eacameron> dmj: See the last line: https://gist.github.com/3noch/e6f0aded09b6aaeb8f48
08:20:32 <cocreature> eacameron: can you get a monadbasecontrol constraint?
08:21:36 <eacameron> I'm sure it's possible, but I'd rather not disrupt Reflex-DOM. So far he's done without it I think.
08:21:45 <eacameron> dmj: Sorry, second to last line. I updated.
08:22:53 <zcourts> In https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17 it says lambda abstractions, function definitions, pattern bindings, list comprehensions and do expressions get converted case expressions - I did https://gist.github.com/zcourts/d9ee1b4d53c869499602 and ran ghc -ddump-ds -dsuppress-uniques -ddump-simpl -o 4 -c ../tests/Case.hs to try and understand how those things get converted 
08:22:53 <zcourts> but the output has additional details and it's not obvious to me what the conversion to case expr looks like in its simplest form. Is there a way to get GHC to output it or can anyone offer the most basic conversion of these constructs to case expr?
08:23:05 <Xandaros> The thing you want to fork has to be in IO, I don't think you can get around it. If you have some monad that can do IO, but that does not guarantee that it can actually fork. Monads other than IO that have MonadIO are usually some kind of transformer stack, the effects of the other monads need to be considered
08:23:41 <quchen> zcourts: You have to differentiate between Haskell and GHC here.
08:24:08 <quchen> zcourts: The Haskell report defines Haskell. Haskell is a set of rules how to transform certain expressions into other expressions.
08:24:14 <eacameron> Xandaros: :/ That does make sense. I just wish now that GHCJS didn't "conveniently" lift stuff for me, since it doesn't actually need to.
08:24:16 <cocreature> MonadBaseControl is exactly for that usecase. it packages up the state in the monad and then restores it inside of the IO operation
08:24:32 <cocreature> so for a reader it would just do ask and then flip runReaderT  ask inside of the forkio
08:24:33 <quchen> zcourts: GHC is a Haskell implementation. It can do anything it likes, as long as it superficially obeys what the Haskell report demands.
08:24:37 <zcourts> quchen: I'd prefer the Haskell definition over how GHC's implemented
08:25:02 <xpilot> pavonia: it's a runtime error
08:25:07 <zcourts> It's the semantics of the conversions I'm trying to understand
08:25:15 <quchen> zcourts: Then you'll have to look at the Haskell report for answers. For example, the section "formal semantics of pattern matching" tells you exactly how 'case' is broken down into simpler things.
08:25:19 <cocreature> a monadbasecontrol instance would definitely be possible for Widget since it‚Äôs just a newtype wrapper around a readert on top of a statet
08:25:56 <quchen> zcourts: Most things GHC does are not "Haskell". There is no Core in Haskell, there is no STG, there is no Cmm, there is no optimizer.
08:26:25 <cocreature> you can also just write a helper to unwrap that newtype and then use the monadbasecontrol instance on that. that way you avoid having to add an orphan instance or modifying reflex
08:26:30 <quchen> zcourts: The Haskell report just defines a number of rules, and GHC is something that obeys those rules, and does whatever it finds useful otherwise.
08:27:02 <eacameron> Really, this is my trouble: https://github.com/ghcjs/ghcjs-dom/blob/master/src/GHCJS/DOM/JSFFI/Geolocation.hs#L27
08:27:10 <pavonia> xpilot: Yeah, if you don't define the instance yourself, it seems to be a problem with the package
08:27:12 <eacameron> There's no reason we *need* to liftIO there.
08:27:41 <dmj> eacameron: can you just make getGeopositionInfo :: IO (Either PositionException GeopositionInfo)
08:27:44 <cocreature> I don‚Äôt see the problem, just instantiate it at IO
08:27:50 <dmj> ^
08:28:18 <Xandaros> Yeah, if your m = IO, you're fine :)
08:28:35 <dmj> instance MonadIO IO, instance MonadAsyncException IO
08:28:38 <eacameron> dmj: cocreature: Hmm...you might have hit some deep misconception deep within my mind...
08:29:21 <eacameron> Wow...that does simplify things!
08:29:59 <eacameron> I didn't realize I could pull things *down* out of MonadIO like that. I thought once abstract, always abstract.
08:30:01 <Xandaros> It's an interesting choice to do liftIO on that level, though. I'm not sure whether I think it's stupid or amazing
08:31:05 <zcourts> quchen: thanks, if'd kept reading the report to 3.17.2/3 I'd have gotten my answer
08:31:56 <dmj> eacameron: what is the type of callback
08:32:07 <eacameron> IO a
08:32:54 <eacameron> Also, if anyone has a better idea than ">>= orBombOut" in 4 places, I'm all ears.
08:33:57 <dmj> void . liftIO . forkIO . liftIO $ callback (info, a)
08:35:11 <eacameron> dmj: Sorry I led you wrong. It's actually getGeopositionInfo that needs to fork
08:35:24 <eacameron> So I can just pull liftIO all the way to the top
08:35:29 <eacameron> That worked!
08:35:43 <dmj> heh
08:35:47 <dmj> eacameron: it's a tad gross
08:36:16 <eacameron> dmj: cocreature: Xandaros: thanks very much. I'll be submitting this code to reflex-dom-contrib if you ever need it ;)
08:36:47 * quchen still isn't sure what the semantics of 'where' clauses are :-|
08:37:13 <dmj> eacameron: nice, are you on OSX per chance?
08:37:20 <eacameron> Yes.
08:38:02 <dmj> eacameron: are you able to inspect the types of reflex-dom in ghci? If so, how did you get webkitgtk3 installed :]
08:38:56 <dmj> or do you just develop, compile w/ ghcjs, and run from there
08:38:56 <ocharles_> Anyone good with continuations able to tell me if   makeChoice :: Monad f => Cont [f a] a -> Cont (f a) [a]   can actually be written?
08:39:13 <eacameron> dmj: Ha...I haven't done that yet. I was hoping it would be easy... Thanks for ruining my day.
08:39:15 <eacameron> ;)
08:39:25 <ocharles_> makeChoice :: Monad f => ((a -> [f a]) -> [f a]) -> ([a] -> f a) -> f a   is the same type, I believe
08:40:31 <adamCS> webkitgtk3 on osx would be super helpful.  I miss ghc-mod! And ghci.
08:40:33 <luigy> it will be if you're on osx :P
08:41:26 * eacameron plans to fire up a Linux VM
08:41:49 <luigy> dmj the formula I sent you was not ballin' for you?
08:41:58 <ocharles_> I don't think it's possible, because makeChoice given k = _ $ given (\a -> [k [a]])  gives me a hole "[f a] -> f a"
08:42:12 <ocharles_> unless anyone can see another way to get there
08:42:49 <ocharles_> hmm actually, k should give me the   f a there, so maybe I am calling things the wrong way round
08:44:54 <ocharles_> oh, hey - makeChoice given k = traverse id (given (pure . pure)) >>= k. that wasn't so bad
08:44:58 <ocharles_> type holes ftw
08:46:19 <Xandaros> typed holes are amazing
08:46:53 <t7> im sure there is a joke in there 
08:52:32 <dmj> eacameron: didn't mean to ruin your day heh, luigy has a script... 
08:52:54 <eacameron> dmj: Oh??? Where at? It didn't work for you?
08:54:13 <dmj> eacameron: https://gist.github.com/dmjio/a8c055501ac46215415f
08:54:26 <dmj> brew install webkitgtk.rb
08:54:48 <dmj> all rights reserved to luigy :]
08:55:38 <vvvvvvv> hi
08:57:07 <eacameron> dmj: Sweet!
08:57:14 <vvvvvvv> so is template haskell out of fashion now?
08:57:42 <vvvvvvv> did everyone realize there was a fundamental problem with it? because most tutorials are like 3 or 4 years old
08:58:10 <vvvvvvv> and a lot of the new libraries seem to compete on not using it
08:58:17 <vvvvvvv> like spock and scotty...
08:59:12 <hpc> TH still has its place
08:59:15 <dmj> vvvvvvv: TH is still en vogue I believe. It just breaks modularity of your files though and isn't portable 
08:59:21 <hpc> it was never really in fashion, because it's pretty gross
08:59:26 <hpc> but it gets used anyway
09:00:00 * hackagebot jukebox 0.2 - A first-order reasoning toolbox  https://hackage.haskell.org/package/jukebox-0.2 (NickSmallbone)
09:00:02 * hackagebot jukebox 0.2.1 - A first-order reasoning toolbox  https://hackage.haskell.org/package/jukebox-0.2.1 (NickSmallbone)
09:00:06 <vvvvvvv> hpc gross how? i thought DSLs could be used for good no?
09:00:27 <hpc> vvvvvvv: what dmj said
09:00:41 <geekosaur> part of the problem is that ghc doesn;t have an abstraction layer over its internals to protect you from internal API changes
09:00:43 <vvvvvvv> dmj how so? i haven't read anything about no cross platform support
09:00:50 <hpc> particularly pathological cases of TH use its instance of MonadIO
09:01:06 <hpc> and you can construct an example that will non-deterministically fail to compile very easily
09:01:24 <vvvvvvv> yikes
09:01:29 <hpc> or you can construct an example where the order of file compilation matters
09:01:39 <vvvvvvv> i don't understand how that happens
09:02:00 <hpc> template haskell is just ridiculously powerful
09:02:07 <vvvvvvv> but i'm still deciding whether i should learn more / implement a DSL with it
09:02:12 <hpc> it's a screwdriver with a blowtorch attached
09:02:13 <vvvvvvv> or try a different approach
09:02:45 <hpc> try making your DSL work in plain haskell first
09:02:59 <hpc> until you can prove there's a feature that isn't possible
09:03:58 <vvvvvvv> hmm. what if i want to experiment with non-haskell grammars... it may be something that's used by non-haskell programmers.
09:04:38 <hpc> maybe write an interpreter for a non-embedded DSL
09:05:15 <monochrom> there is still quasiquotes before you drop down to full-blown TH
09:05:36 <monochrom> for example, yesod does this
09:06:22 <vvvvvvv> monochrom i'm confused where do quasiquotes end and TH begin?
09:06:31 <vvvvvvv> i thought quasiquotation was part of TH but i guess that's wrong
09:06:41 <monochrom> I don't know
09:08:09 <hpc> QQ is part of TH
09:09:37 <magnap> Hi all! Is there a way to import your package's dependencies in ghci if you're using stack?
09:10:00 <vvvvvvv> hpc can QQ be used without getting into the messy/dangerous parts of TH?
09:10:24 <vvvvvvv> what are some good starting points - tutorials/vids for learning how to use QQ in haskell?
09:14:14 <magnap> Ah, figured it out. Run "stack ghci", not "stack exec ghci"
09:14:15 <geekosaur> magnap, stack ghci?
09:14:22 <magnap> geekosaur: yes
09:14:27 <dmj> vvvvvvv: http://quasimal.com/posts/2012-05-25-quasitext-and-quasiquoting.html
09:14:30 <geekosaur> yeh, photo finish >.>
09:14:53 <magnap> geekosaur: Cool expression. Took me a few seconds
09:15:16 <vvvvvvv> dmj
09:15:18 <vvvvvvv> thanks
09:15:51 <geekosaur> heh, in fact I was just wondering if I needed to explain that:)
09:16:00 <vvvvvvv> one small project i was thinking of trying was to use TH to generate servant code based on a json data sample
09:16:16 <vvvvvvv> kindof like what Frames does with CSVs. Does that seem reasonable?
09:16:28 <dmj> vvvvvvv: if you wanted to start on that, that would be nice
09:17:26 <dmj> vvvvvvv: the next step for servant swagger would to be read a swagger.json file at compile time, parse it with swagger2 into Swagger (optionally validate it), then generate a servant type declaration 
09:17:26 <magnap> A question about the layout of packages: one of the packages I'm using, caffegraph ("dnngraph" on GitHub) has a module "NN" but no file "NN.hs". How does that work?
09:18:04 <dmj> vvvvvvv: it would be quite an undertaking
09:18:29 <vvvvvvv> dmj the next step, or generating servant code from a json sample?
09:18:47 <xpilot> magnap: oh interesting, I saw dnngraph but haven't done much with it
09:18:47 <kadoban> magnap: Usually it'd be in a subdirectory, and in the .cabal file it specifies what directory to look in for modules in the library.
09:19:07 <xpilot> magnap: have you used it much?
09:19:25 <magnap> xpilot: I'm trying it out, the examples work on the Haskell end (haven't tested with caffe)
09:19:26 <vvvvvvv> i'm still pretty noobish so maybe this is a bit ambitious.
09:19:41 <xpilot> magnap: ah ok that's about as far as I got
09:19:43 <bergmark> magnap: the module is there: https://github.com/ajtulloch/dnngraph/blob/master/NN.hs
09:20:10 <xpilot> magnap: I'm actually pretty close to releasing the first (rough) version of the NN lib I've been working on
09:20:14 <magnap> bergmark: Now I feel all kinds of blind. I only looked in the NN dir
09:20:34 <magnap> xpilot: Cool! Tell me more :)
09:20:36 <dmj> vvvvvvv: yea, the json file would need to be an API specification. swagger.json w/ swagger2 already gets you into the world of haskell. From there you'd need a function like Swagger -> Q Type
09:21:01 <xpilot> right now I'm trying to get the accelerate backend fully working
09:21:04 <magnap> bergmark: Forgot to say: thanks :D
09:21:19 <magnap> xpilot: GPU acceleration?
09:21:33 <xpilot> magnap: yeah using the accelerate package
09:21:52 <magnap> Ahh
09:21:55 <dmj> vvvvvvv: join #servant
09:22:38 <magnap> xpilot: Anything specific that makes it different/superior to existing solutions? Other than being in Haskell, of course ;)
09:23:24 <xpilot> magnap: good question
09:23:58 <xpilot> magnap: it may be the case that the power of the accelerate backend makes it relatively easy to construct complicated nets that run on the gpu
09:24:22 <magnap> xpilot: That'd be really cool. How well does it do distribution?
09:24:50 <xpilot> if I understood correctly, according to some of my labmates experienced with torch it is actually rather difficult to write a gpu accelerated LSTM
09:25:12 <xpilot> so they just run on cpu
09:25:23 <magnap> That is surprising to me. I'd figured that'd be "solved" by now
09:25:39 <magnap> That definitely sounds like an important hole to fill in the tool landscape!
09:25:44 <VsyachePuz> Why functional languages is so cool?
09:25:56 <xpilot> to be honest I don't know the details since I haven't used torch all that much myself
09:26:06 <VsyachePuz> there are 2 arguments: higher order functions and lasy evaluation
09:26:12 <xpilot> magnap: what do you mean by "distribution"?
09:26:27 <VsyachePuz> but both can be implemented in object oriented languages
09:26:33 <xpilot> VsyachePuz: there's also the type system
09:26:45 <magnap> xpilot: Running on multiple CPUs/GPUs/(maybe even multiple machines)
09:26:47 <vvvvvvv> dmj i think you logged out of #servant just as i joined
09:26:47 <xpilot> VsyachePuz: although that's more haskell-specific than fuctional-specific
09:27:13 <Cale> VsyachePuz: If you add all the things which make functional programming possible to an OO language, it won't typically be regarded as mainly an OO language anymore.
09:27:14 <vvvvvvv> I had something else in mind, maybe it's not realistic... but to read a sample of json data and infer types based on the data. analogous to what Frames does with CSVs
09:27:15 <VsyachePuz> xpilot: no, in original work there is no accent on type system - http://worrydream.com/refs/Hughes-WhyFunctionalProgrammingMatters.pdf
09:27:25 <magnap> xpilot: Have you read https://colah.github.io/posts/2015-09-NN-Types-FP/ ?
09:27:36 <bergmark> magnap: but to answer your question! you can generate source files in Setup.hs, which i wouldn't recommend most of the time... https://github.com/hvr/base-noprelude/blob/pre-ghc710/Setup.hs
09:27:42 <vvvvvvv> there's never an explicit schema, it's just inferred from examples.
09:27:51 <vvvvvvv> if it's not 100% foolproof that's okay as it'd be used for a lot of interactive data analysis type of work
09:27:58 <Cale> vvvvvvv: are you sure that's not one-too-many v's? :D
09:28:02 <magnap> bergmark: What question does that answer?
09:28:27 <vvvvvvv> the idea is taking the place of 100% dynamically typed language approaches (eg python or R)  but not have to spend much much longer writing boilerplate type definitions just to interact with a new service
09:28:36 <xpilot> magnap: yes I have. at the time I was hoping to find an actual implementation though :)
09:28:42 <bergmark> magnap: that is one way the NN module could have been created without having an NN.hs
09:28:51 <vvvvvvv> Cale lol it's not a reference to the game, if that's what you're getting at :-)
09:28:51 <VsyachePuz> Cale: prolog is cool, because it have inference engine. Java/C# are cool because they have Garbage Collection. Which mechanisms support "functional programming" ?
09:28:53 <magnap> xpilot: I was hoping your program would be that ;)
09:29:24 <magnap> bergmark: Ahh. Well thanks, but I was actually just looking for the source to read ;)
09:29:41 <bergmark> too bad
09:29:48 <xpilot> magnap: I haven't thought too much about the relationship between various network architectures and catamorphisms and the like
09:30:04 <Cale> VsyachePuz: First class functions, pattern matching, parametric polymorphism, somewhat more recently but no less importantly type classes
09:30:19 <xpilot> magnap: since I've been busy actually writing the library
09:30:37 <magnap> xpilot: Understandable
09:30:45 <Cale> VsyachePuz: Non-strict semantics (and lazy evaluation) are also very nice to have.
09:31:29 <VsyachePuz> Cale: functions are available through reflection in C#, pattern matching exists in Nemerle, in templates exist in C++, this is all not related to functional programming
09:31:50 <Cale> VsyachePuz: It really helps if like with Haskell, Idris and a bunch of others, functions are actually functions and not arbitrary procedures which can cause any effect at all.
09:32:02 <xpilot> magnap: but it should be easy to generate all sorts of networks with my library (which was the point of writing it in haskell)
09:32:29 <VsyachePuz> Cale: the whole purpose of computers is co cause effects. How one can program without effects?
09:32:35 <xpilot> magnap: my code is currently at https://github.com/vladfi1/hs-nn, though I will warn you that there's a lot of cleaning up to do
09:32:36 <Cale> VsyachePuz: A bit part of what makes functional programming an enjoyable process is knowing that functions only depend on their arguments and serve solely to compute their result.
09:32:45 <VsyachePuz> Computers should control other devices
09:33:00 <Cale> VsyachePuz: It's not about programming without effects, it's about getting the effects out of *functions*.
09:33:13 <Cale> VsyachePuz: You can move the descriptions of effects into another data type.
09:33:22 <nwolverson> vvvvee: re inferring json types from sample, see F# json type provider
09:33:37 <Cale> VsyachePuz: and this lets you reason about functions in the same way that you'd do in mathematics
09:34:11 <VsyachePuz> Cale: but if the functional language consists ony from functions, then there is no place to move these effects to
09:34:27 <Cale> VsyachePuz: You can think about functions as simply pairing up their inputs with their outputs -- if you test a function in isolation on some parameters, and it computes a given result, then you can be sure that it will do the same in your actual program.
09:35:04 <vvvvee> nwolverson cool thanks this is kind of what i'm imagining
09:35:12 <vvvvee> but haskell
09:35:14 <VsyachePuz> Cale: if the language allows only functions, how one can make external effects with this language?
09:35:18 <Cale> This is actually what I consider the most important benefit of functional programming -- it prevents a huge number of bugs from arising, makes testing far simpler, makes it possible to reason about what programs do in an equational way...
09:35:46 <glguy> VsyachePuz: There's no limitation in functional program that there are only functions
09:35:47 <Cale> VsyachePuz: One can't, but no language designed for practical programming is like that
09:35:58 <Cale> VsyachePuz: Haskell isn't like that, in particular.
09:36:11 <kadoban> VsyachePuz: The language allows things other than functions.
09:36:32 <nwolverson> vvvvee: yeah, different world but codegen is codegen.
09:36:48 <Cale> VsyachePuz: In Haskell, for any type t, there is a type IO t whose values are descriptions of actions which could be performed to compute a result of type t, and those actions can cause your computer to do anything that it's capable of doing.
09:37:18 <vvvvee> nwolverson do you think it would be cleaner to implement something like that as a json->haskell transpiler(?) or to use template haskell?
09:37:51 <Cale> IO actions aren't functions though -- they don't have an input parameter. If you have a function of type  a -> IO b  then given the same value of type a, it will always produce the same *action* of type IO b, but when you get around to executing that action, it might have a different result of type b each time.
09:38:51 <magnap> xpilot: One of the more important ideas from that article IMO is the ability to use existing networks the same way one would use a node
09:39:17 <Cale> So while it's sort of possible to regard functions a -> IO b as being "effectful functions", they're not really -- the function part still has no side effects, and the process of evaluating expressions still needn't have side effects.
09:39:58 <kadoban> VsyachePuz: The important part of this is that it makes explicit what parts of the program can have what effects.
09:40:01 <Cale> It's just executing these IO action values which has all the effects, and since their whole reason to be is to describe effects, it's kind of inappropriate to call them "side effects" at that point.
09:40:13 <vvvvee> Cale you're right, but we really need a better spiel for IO to the outside worldto non-haskell people (i'm assuming VsyachePuz is one), these IO monad / action explanations sound like gobbledygook.
09:40:30 <Cale> Note that I didn't use the word "monad" at all :)
09:40:37 <Cale> I think at least this is an improvement
09:40:41 <nwolverson> vvvvee: That's beyond my ken entirely, I'm a Haskell newb
09:40:59 <Cale> (IO does happen to be a monad, but the fact that it's a monad is not very interesting)
09:41:06 <xpilot> magnap: have you seen https://github.com/nshepperd/funn? I just found it now
09:41:07 <kadoban> You can also do cute stuff like have a bunch of computations that instead of being able to do arbitrary effects, which usually isn't necessary for a lot, they can have a set of shared state. And this bunch of computations has a type that explicitly defines what shared mutable state it's allowed to use.
09:41:20 <vvvvee> nwolverson fair enough :)
09:41:56 <magnap> xpilot: I haven't. But that username rings a bell
09:43:01 <xpilot> magnap: my approach is in some ways less nice than some others, since it uses mutable references
09:43:09 <Cale> VsyachePuz: A really nice thing about this approach is that we can have other types, similar to IO in that they describe effectful computations of various sorts, but where only certain effects are allowed. One example in Haskell is STM. For any type t, there's a type STM t which consists of actions that may only have certain kinds of memory effects, so that STM actions can be run in a transactional way and rolled back.
09:43:21 <xpilot> magnap: namely, I use IORefs to build a DAG
09:43:59 <magnap> xpilot: I see. You might be "excused" for performance resons
09:44:07 <xpilot> magnap: I actually tried pretty hard to encode type-safe pure DAGs but gave up
09:44:18 <magnap> Of course, it'd be better to have a pure interface for building the graph
09:44:30 <Cale> VsyachePuz: This is used for communication between concurrent threads -- STM actions can run at the same time, and there can still be the illusion that any particular STM action is run as-if-atomically with respect to all other threads in the system.
09:44:39 <haskell846> Could someone give me a link to the explanetion of why Tuple Functor use second parameter and not first?
09:44:44 <magnap> (I haven't actually read your code, and I'm probably not proficient enough in Haskell to do so)
09:44:48 <vvvvee> xpilot what was the problem?
09:45:54 <xpilot> magnap, vvvvee: I think that I'm basically facing the same problems the edwardk did when writing his ad package
09:46:08 <vvvvee> xpilot what were those?
09:46:17 <xpilot> namely that of observable sharing breaking referential transparency
09:46:25 <Cale> VsyachePuz: An STM action will produce a transaction log of reads and writes as it is run, and when it reaches the end the system will take a lock, and go through that log, checking to see that the values it read are still the same. If so, then all the things it wrote to will be written. If not, the changes don't happen, and the action retries.
09:47:14 <Cale> (which is safe to do because STM actions are not allowed to do things like launch missiles)
09:47:17 <xpilot> afaik the ad package use refs under the hood and hides them with unsafePerformIO
09:47:45 <Hrk> Can you please suggest a library that's able to parse dates from Text? I'm using "time" at the moment, but that's only working with Strings.. I'd like to parse some logs of MB size and my original String-based parsing is getting slow.
09:47:49 <kadoban> haskell846: Because of how types work it's basically required.   data (,) a b = (,) a b -- that's kind of how tuples work. A Functor has to be of kind * -> *, so the only real way to do that is have (,) a  be the Functor.
09:48:16 <haskell846> thanks
09:48:42 <kadoban> haskell846: Also it's basically arbitrary, even ignoring haskell. So you kind of just have to pick one.  By the way, you know about Bifunctor, right?
09:48:43 <Cale> Hrk: Are you already using Text for most of the parsing -- I would try to chop the dates out and only convert those to String if possible.
09:48:55 <vvvvee> xpilot huh I would have thought type safe DAGs would be very natural to implement in haskell
09:49:11 * nshepperd wakes up
09:49:22 <Cale> Hrk: But that may or may not be easy depending on your log format... it would be nice to have a Text-based time/date parser
09:49:57 <Cale> Hrk: there is this... https://hackage.haskell.org/package/strptime-1.0.10/docs/Data-Time-Parse.html
09:50:47 <Hrk> Cale looks nice. Thanks!
09:51:22 <nshepperd> xpilot: afaict it's hard to build a dag in a nice monady way
09:51:26 <xpilot> vvvvee: there are some promising looking advanced type level solutions: https://www.cs.utexas.edu/~wcook/Drafts/2012/graphs.pdf
09:51:42 <xpilot> oh hi nshepperd !
09:52:34 <Cale> Hrk: Oh, unfortunately that only does LocalTime, but I guess it's possible to work out how to get from there to most other things usually.
09:52:36 <nshepperd> xpilot: it's easy to do things pointfree (left (foo >>> bar) >>> baz)
09:52:47 <nshepperd> xpilot: which is how I do it
09:53:07 <Cale> Hrk: Kind of annoying if all you want is UTCTime though
09:53:51 <nshepperd> (also I realised recently I've been using 'left' and 'right' for the wrong things, and I should have called those combinators 'first' and 'second')
09:54:10 <xpilot> nshepperd: those look like arrow things
09:54:33 <nshepperd> arrowish, yes
09:54:42 <xpilot> nshepperd: I figured that might be a reasonable approach
09:54:43 * hpc slyly suggests _1 and _2
09:55:03 <xpilot> nshepperd: but it seemed a bit verbose
09:55:13 * hackagebot octane 0.1.0 - A Rocket League replay parser.  https://hackage.haskell.org/package/octane-0.1.0 (fozworth)
09:55:19 <xpilot> nshepperd: the node approach makes more sense to me
09:55:21 <nshepperd> you can't actually use the Arrow class because it needs constraints
09:55:22 <Cale> nshepperd: You're giving me flashbacks to manipulating typed heterogeneous graphs for our old FRP system :D
09:56:00 <xpilot> Cale: that's basically what I'm trying to do
09:56:34 <nshepperd> but yeah, if you want to make a pointy interface where you do { (x, a) <- layer1 input; y <- layer2 x; return (y, a) }
09:56:43 <Cale> We had our own Arrow class too, which was more closely modelled on the definition of a symmetric monoidal category (along with a preprocessor for the proc/do notation which used our new primitives, this sped up our game's execution by about 6x on its own)
09:56:45 <nshepperd> then you need heterogrenous graphs and things
09:56:49 <nshepperd> as far as I can tell
09:56:54 <xpilot> Cale: tbh reverse mode ad on DAGs should be way easier than FRP
09:57:00 <nshepperd> some unsafecoercing...
09:57:04 <Cale> xpilot: :)
09:57:40 <Cale> nshepperd: Yeah...
09:58:04 <xpilot> I've been constructing a lot of proofs, no unsafeCoerces in my library!
09:58:15 <haskell846>  kadoban: yes, do I remember corrent that Functor for tuple isn't really a good idea?
09:58:20 <nshepperd> although you can constrain the unsafety with tags that witness that node x is of type a
09:58:28 <Ainieco> how am i supposed to know how to implement toPersistValues? https://hackage.haskell.org/package/groundhog-0.7.0.3/docs/Database-Groundhog-Core.html#t:PersistField
09:58:30 <xpilot> except for a few times where I cop out and write partial functions :(
09:58:33 <nshepperd> that's what I was doing
09:58:56 <Cale> There was one unsafeCoerce in our library
09:59:14 <Ainieco> while i can ignore "m" in "m ([PersistValue] -> [PersistValue])" and use "return" to turn anything into "m" what is the meaning of "([PersistValue] -> [PersistValue])"?
09:59:24 <kadoban> haskell846: I think it depends what it's for or what the data you're modelling as a tuple means. I wouldn't really say it's a bad idea in general though.
09:59:37 <Ainieco> is it something every haskeller knows and there is no point in documenting it?
09:59:39 <xpilot> I actually had a whole completely type safe implementation using type-level nats for the tensor dimension and < proofs
10:00:16 <nshepperd> xpilot: another interesting thing about that, is that you need a sort of linear typing for full generality of the monady interface
10:00:40 <xpilot> nshepperd: linear typing meaning use each lambda argument at most once?
10:00:57 <Cale> Ainieco: I don't know it, and I use this library all the time :)
10:01:00 <kadoban> Ainieco: It's not clear to me from the type what that would or should be doing. Why do you ask?
10:01:14 <xpilot> nshepperd: why would that be useful?
10:01:17 <nshepperd> xpilot: you need to know about 'at-most' and 'at-least' once usage
10:01:48 <xpilot> nshepperd: why is that?
10:01:50 <nshepperd> xpilot: in { (x :: a) <- foo input; bar x}, you don't need to know how to combine two derivatives wrt a value of type a
10:02:47 <Ainieco> kadoban: i'd like to use UUID postgresql fields with groundhog and to achieve that i think i need to create instance PersistField UUID
10:03:38 <t7> whats groundhog ?
10:03:46 <nshepperd> xpilot: in { (x :: a) <- foo input; y <- f x; z <- g x; bar (y,z) }, you do
10:04:14 <Cale> t7: A¬†library which marshalls Haskell data structures into and out of SQL databases.
10:04:18 <nshepperd> xpilot: because x is used twice, you've gotta propogate derivative back from both paths and then add them together somehow
10:04:34 <t7> Cale: even recursive ones? 
10:04:56 <xpilot> nshepperd: ah ok. I have a Num constraint on all types that go through my DAG, although really it should be Additive
10:05:14 <Cale> t7: With some effort, yes
10:05:21 <nshepperd> right, that's one way to make the problem go away :)
10:05:25 <xpilot> nshepperd: I scrapped the idea of using numeric-prelude though since no one else does and I want to interface nicely with ad
10:07:01 <nshepperd> similarly, in { (x :: a) <- foo input; bar input }, x is ignored, so you need a way to invent a 'zero' derivative for x.
10:07:24 <xpilot> nshepperd: Additive to the rescue :)
10:07:31 <nshepperd> though you can solve that problem way easier by just using Maybe everywhere to represent an ignored thing
10:08:37 <nshepperd> right, this means you can't use the network on non-Additive things, which may not matter
10:08:41 <nshepperd> but it's a thing
10:09:26 <xpilot> nshepperd: I'd like to ask you more about your library, but I'm starving and need to get some food :(
10:09:27 <Cale> Ainieco: Are you using groundhog-th at all?
10:10:13 * hackagebot hleap 0.1.2.4 - Web Socket interface to Leap Motion controller  https://hackage.haskell.org/package/hleap-0.1.2.4 (BrianBush)
10:10:19 <Cale> Ainieco: I think it might be easier to just try to use that somehow rather than writing the requisite instances by hand. Unfortunately, that's even more poorly documented imo :P
10:10:50 <nshepperd> of course
10:10:56 <Cale> Ainieco: There are probably enough examples of use in the haddock for it to scrape by, but there's no really clear description of what the QuasiQuoter language being used is.
10:11:13 <Cale> https://hackage.haskell.org/package/groundhog-th-0.7.0.1/docs/Database-Groundhog-TH.html
10:11:37 <Ainieco> Cale: yup, i'm using it but it still requires me to implement that instance alas
10:11:53 <Cale> Doesn't mkPersist do it?
10:12:01 <Ainieco> Cale: nope
10:15:21 * hackagebot hleap 0.1.2.5 - Web Socket interface to Leap Motion controller  https://hackage.haskell.org/package/hleap-0.1.2.5 (BrianBush)
10:20:21 * hackagebot octane 0.1.1 - A Rocket League replay parser.  https://hackage.haskell.org/package/octane-0.1.1 (fozworth)
10:20:57 <Ainieco> Cale: by the way how do you deal with createdAt/updatedAt fields in your records?
10:21:30 <Ainieco> Cale: are you setting them manually from haskell or let db handle it?
10:35:08 <Cale> Ainieco: We don't have a lot of those, I think we'd be more likely to just have our backend capture the UTCTime of the request and add it to the data structure it's storing.
10:45:18 <kevinconnors> hi all, newbie to hexchat so apologies for the off-topic question... but how do I hide "X has joined" "X has quit" messages?"
10:45:37 <kevinconnors> nvm
10:51:31 <scshunt> Does GHC allow declaring a specific instance as potentially undecidable?
10:52:57 <Ainieco> Cale: so you're not doing web stuff with groundhog, right? otherwise createdAt/updatedAt are must + in almost all projects you'll eventually need deletedAt, heh
10:54:20 <bergmark> scshunt: i think the only way is to put it in its own module
10:54:20 <Cale> Ainieco: We're doing web applications, but the time at which the record is created or updated seems less important than the time of the thing it pertains to.
10:54:38 <kevinconnors> Is there any difference between the type signature "filter :: (a -> Bool) -> [a] -> [a]" and "filter :: a -> Bool -> [a] -> [a]", or does the former just denote that it takes a function that returns a boolean for additional clarity?
10:54:43 <Cale> Ainieco: I suppose it might be nice to have that information regardless.
10:55:15 <Cale> kevinconnors: Those are *very* different
10:55:16 <kadoban> kevinconnors: The type signatures are *much* different.
10:55:28 <Cale> kevinconnors: (->) associates to the right
10:55:39 <Cale> When you see A -> B -> C -> D, it means A -> (B -> (C -> D))
10:55:42 <kadoban> kevinconnors: The second takes an 'a', and a 'Bool' and a list and ‚Ä¶ who knows what it would even do with those.
10:56:05 <Cale> and this is how we handle functions of multiple parameters in Haskell: by making them the same thing as function which produce other functions
10:56:10 <Cale> functions*
10:57:52 <Ainieco> Cale: yeah, one day client will pop up and say "let's show on our front-end when this %whatever business entity% was created by users" and if you're already in production you'll be in unnecessary trouble
11:00:27 <eacameron> Ainieco: I can think of a lot of potential requests that would get me into trouble...Fact is, can't tell the future.
11:01:11 <Ainieco> eacameron: too bad for you then, it comes with experience :P
11:01:37 <eacameron> Ainieco: Granted, some requests are more likely than others. ;)
11:02:00 <kevinconnors> Thanks, Cale & kadoban
11:20:38 <VsyachePuz> So, is there some kind of expression calculation optimizator present in runtime (or absence of side effects allow to put it in compiler?) of functional language platform?
11:22:02 <kadoban> VsyachePuz: The compiler does have a quite advanced optimization step, sure.
11:22:09 <bergmark> VsyachePuz: the compiler does a lot of optimizations, and if there are no side effects it has a much easier job
11:23:50 <VsyachePuz> then this feature should be marketed (it's PRESENCE), instead of ABSENCE of side effects
11:24:51 <VsyachePuz> but others language compilers do optimizations too. Where I can read comparisons?
11:25:17 <kadoban> I would venture to say that most people here aren't marketers.
11:25:39 <kadoban> VsyachePuz: Also if you'll recall the earlier conversation, it's more about explicitly modelling side effects in the type system than there bon being side effects.
11:28:14 <kadoban> VsyachePuz: As to comparisons ‚Ä¶ I'm not sure that's very easy. When you're talking about languages with very different semantics and at quite different levels, it's hard to compare the optimizations they can perform usefully. I'd say the difference between haskell and most languages is more in terms of what you can express, especilaly what you can express in a useful way in the type system. The compiler being badass is just a necessary condition, 
11:28:16 <kadoban> because nobody would use it if there was no way to run the resulting thing quickly enough for it to be useful in practice.
11:45:43 <VsyachePuz> kadoban: so no comparisons mean that one can prove, that functional approach is better that object-oriented in terms of code optimization. And all modern hype is just hype
11:46:47 <VsyachePuz> * no proofs, and anyone can spread the words, that it's own approach is better then the approach of his opponent
11:47:04 <kadoban> VsyachePuz: I don't understand the statement/question I don't think. We can't *prove* much of anything about software or languages typically, at least not the stuff we'd like to. Software Engineering is in its infancy.
11:47:47 <monochrom> this is a very strange discussion. it begins with the clearly narrow-minded or even shallow-minded premise "computer's sole purpose is effects and controlling more computers" which no one challenged. accepting this premise aka staying on hostile turf, now anything that avoids effects has to be justified by extraordinary merits such as performance optimization opportunities.
11:48:27 <VsyachePuz> monochrom: controlling more external machines, not computers
11:49:58 <mazur> was the 'form' keyword from the original Arrow notation paper the same as 'do'?
11:50:34 <monochrom> in my view, computer's sole purpose is computing functions (mathematical functions) on my inputs and telling me the answers. only the receiving of my input and the telling of the answers are effects. the bulk of the time is spent on a mathematical function, which doesn't need effects. therefore, any addition of effects (beyond input and output) requires justification by extraordinary merits.
11:50:50 <EvanR> VsyachePuz: at some point people actually used computers to compute arithmetic results
11:50:58 <EvanR> hence the name
11:51:01 <EvanR> jsut another use case
11:53:15 <VsyachePuz> the term "side effect" have different meanings for different people
11:53:37 <monochrom> notice that there is no "side" in all of my sentences.
11:58:45 <monochrom> mazur: I forgot that there was a "form". but GHC's arrow notation goes like "proc x -> do { y <- f -< x; returnA -< y+1 }" which is f >>> arr (+ 1) >>> returnA
11:59:34 <mazur> monochrom: hmm yeah i was just trying to figure out why it doesn't seem to be implemented (and what its purpose was)
11:59:47 <VsyachePuz> let's divide IT-people to two camps - one which serves business processes (which are build on machines  which produce effects), and anther camp is "playing for their own joy" (because even the gathering of additional information is a side action). First cams declare, that they don't see the profits from functional programming. Second camp can't prove that such profits exist.
12:01:35 <mvr_> playing with type level nats, getting "Couldn't match type ‚Äòn‚Äô with ‚Äò(n + 1) - 1‚Äô"... should I expect ghc to accept this?
12:02:25 <kadoban> VsyachePuz: You've gone ahead and defined anything that's a pure function as wanking, which isn't true.
12:02:42 <EvanR> mvr_: you might have to apply assoc
12:03:13 <kadoban> VsyachePuz: Also people declare all kinds of things, I do in fact see profits from the ability of haskell to model things in a way that's harder to write bugs than in other languages.
12:03:57 <kadoban> VsyachePuz: And again, nobody can *prove* anything, that's not unique to functional programming. If you're looking for proofs, you're asking to be lied to, or you'll come away with no information.
12:04:23 <hodapp> VsyachePuz: That's driving a really meaningless and questionable dichotomy. No one here is talking about computations that don't "produce effects", nor advocating them.
12:04:40 <monochrom> clearly, even in a business process, there is a mathematical function to compute in order to decide what exact effects are to be performing
12:04:47 <monochrom> s/performing/performed/
12:05:15 <monochrom> it is why I call this premise shallow.
12:05:22 <mvr_> EvanR: where do I find that? doesn't seem to be in GHC.TypeLits
12:06:09 <hodapp> VsyachePuz: Also, reading back a bit, I am aware of startingly little in the way of even *attempts* at empirical data to suggest that object-oriented is actually 'better' by any metric. The attempts that I have seen (mainly Les Hatton's research thus far) are not favorable to object-oriented.
12:06:13 <EvanR> i just made that up, im not sure
12:06:31 <monochrom> it is in the same calibre as being able to only see me eating, shitting, and dying, and not being able to see me think, and therefore you conclude that my sole purpose is to eat shit and die, and I don't need a brain for that purpose.
12:07:17 <EvanR> eat shit and die with no commas, nice
12:07:30 <monochrom> oh haha
12:08:01 <hodapp> VsyachePuz: Also, I'm really not sure why "IT-people" are relevant to this discussion.
12:08:20 <monochrom> I think I know why
12:08:58 <hodapp> "IT people" are dominantly not software developers, whether incidentally chance or by any formal training.
12:09:13 <hodapp> and why is because IT is not software development, nor software engineering.
12:10:27 <monochrom> I think they first decided that functional programming is not worthwhile, and now want to generate a reason. (humans tend to decide then generate reason, not the other order.) so they first tried the "purpose" premise. when that went bunk, they had to find another premise such as IT trends.
12:11:59 <hodapp> I can go find a group of competent mechanical engineers and ask them what their opinion is on the role of version control in software development. Lots of them will declare that they can't see the benefit of it. That's a similar proximity to asking IT people about pure functional languages.
12:12:26 <monochrom> hodapp: in some countries, "IT" includes software development
12:13:25 <Ralith> why are people feeding the troll
12:16:54 <geekosaur> boredom?
12:17:21 <monochrom> well, I do have a grudge against the wrong premise "computer's purpose is effects"
12:17:31 <hodapp> because in #haskell we have a proud tradition of not assuming people are trolling
12:18:04 <EvanR> dunno if this counts
12:18:19 <EvanR> better would be not getting angry about the "not trolling"
12:18:39 <monochrom> on the bright side, you heard monochrom saying that he eats shit and die. that's some accomplishment :)
12:19:14 <EvanR> i loled
12:19:34 <hodapp> 9_9
12:20:28 <EvanR> so uh im trying to construct a set which is not finite and not infinite
12:20:37 <VsyachePuz> for Les Hatton this paper in the google's top - http://www.leshatton.org/Documents/ArtMetric.pdf
12:20:52 <EvanR> any ideas
12:21:00 <kadoban> EvanR: Wouldn't that be a contradiction?
12:21:30 <EvanR> i dont see how
12:22:00 <monochrom> you will have to change it to "a set that cannot be constructively proved to be finite, and cannot be constructively proved to be infinite"
12:22:32 <VsyachePuz> hodapp: which work to read from this list - https://www.researchgate.net/profile/Les_Hatton/publications
12:22:43 <monochrom> and then I am not sure that such a set can be constructed, as opposed to "classical logic says that this set exists"
12:23:10 <EvanR> does classical logic say it exists?
12:23:30 <monochrom> I think so, but I haven't thought it through
12:23:34 <EvanR> i would expect it to say ti is a contradiction
12:24:33 <monochrom> "cannot be classically proved finite, and cannot be classically proved infinite" is the only contradiction
12:26:42 <EvanR> im trying for exists s . (Finite s -> Void, Infinite s -> Void)
12:26:59 <EvanR> not sure if thats what youre rephrasing meant
12:27:01 <Cale> There are a couple sensible definitions of "infinite" which the Axiom of Choice makes equivalent. One is that a set A is infinite if there is a bijection between A and a proper subset of A. Another is that A is infinite if there exists an injective function N -> A (this latter sort often being called "Dedekind infinite").
12:27:18 <monochrom> oh, I see. different from what I said
12:27:42 <EvanR> im taking infinite to be injective with a proper subset, and finite to be all injections are surjective
12:27:50 <EvanR> which are opposing properties
12:28:01 <EvanR> but not opposite, constructively
12:28:29 <monochrom> I mixed up "constructively prove not finite" with "cannot constructively prove finite"
12:29:38 <EvanR> but dedekind infinite seems interesting
12:30:26 * hackagebot container 1.0.2 - Containers abstraction and utilities.  https://hackage.haskell.org/package/container-1.0.2 (danilo2)
12:31:08 <Cale> See also https://en.wikipedia.org/wiki/Finite_set#Other_concepts_of_finiteness
12:32:03 <Cale> There's a list of 8 definitions of what it might mean to be finite there which may be distinct in ZF, but are equivalent in ZFC
12:33:34 <EvanR> i see my propert is not lised ;)
12:34:33 <Cale> oh, it seems this page disagrees on the definition of Dedekind infinite :)
12:35:02 <Cale> Earlier on the page it says "A set S is called Dedekind infinite if there exists an injective, non-surjective function f: S -> S"
12:35:25 <EvanR> yeah
12:35:32 <EvanR> basically what im using
12:36:06 <Cale> and that one is the same as "There is a bijection between S and a proper subset of S"
12:36:59 <Cale> er...
12:37:29 <Cale> yes
12:37:32 <Cale> heheheh
12:37:34 <EvanR> and it attributes my finite property to dedekind too
12:38:12 <Cale> It's tricky trying not to trip over things which use AC accidentally... :)
12:38:44 <EvanR> its listed under the axiom of countable choice "bargain bin"
12:38:57 <EvanR> of finiteness properties
12:38:59 <Cale> ohhhh
12:39:06 <Cale> Sorry, I was mistaken originally
12:39:19 <Cale> Those two properties are equivalent in ZF even.
12:39:51 <EvanR> with classical logic
12:40:13 <Cale> yes
12:40:15 <Cale> heh
12:40:23 <Cale> What was it then...
12:40:44 <Cale> I know there's another definition of infinite which actually does become distinct from that notion.
12:40:48 <EvanR> which means if i succeed it will contrtradict classical
12:41:20 <Cale> Oh, right "cannot be put in bijection with a finite ordinal"
12:41:47 <EvanR> huh how is that different from substituting ordinal with N
12:41:53 <Cale> EvanR: Which logic are you using?
12:42:20 <Cale> EvanR: Yeah, "finite ordinal" could also be written "natural number" -- assuming that natural numbers are sets of appropriate size :)
12:43:49 <EvanR> since i dont think you can prove that a set is not finite XOR not infinite (constructively), i wondered about doing the opposite
12:44:22 <EvanR> construct one that is both
12:44:29 <EvanR> (not and not)
12:45:11 <EvanR> the no bijection one seems useless
12:45:39 <EvanR> not foo seems a lot more useless with contrucive
12:46:53 <Aruro> :i Monad
12:47:20 <kadoban> Aruro: lambdabot doesn't have :i
12:47:51 <Aruro> i forgot there was something no? my question is why defining monad instance without defining >> works?
12:48:08 <Aruro> like just defining return and >>= is enough
12:48:19 <Aruro> in some cases
12:48:35 <glguy> Aruro: Because a class declaration can provide default implementations of its methods
12:48:38 <kadoban> Aruro: (>>) isn't part of the definition of the class. It's implemented in terms of (>>=). If you're not sure how it's implemented, that's actually a nice little exercise.
12:48:50 <k4pod> Aruro: can define >> in terms of >>=
12:48:50 <glguy> >> is part of the declaration of the Monad class
12:48:55 <kadoban> Oh did I lie? I thought it was separate.
12:49:05 <KaneTW> it's not part of the minimal declaration
12:49:26 <Aruro> thats why i wanted info, ghci tells >> is part of class
12:49:32 <kadoban> Fair enough, thanks for the correction.
12:49:44 <Aruro> i think even haskell report tells that
12:50:11 <Cale> Yeah, it's not necessary for (>>) to be part of the class, even though it is
12:50:17 <KaneTW> every monad function is definable using >>= and return only
12:50:53 <Cale> It just means that perhaps in some cases where a more efficient implementation of (>>) is possible, it can be provided. I don't really know of concrete examples of that though.
12:51:30 <kadoban> Yeah I was kind of wondering if there are, none come to mind.
12:52:49 <Aruro> ok , then ghci should probably remove it from info block
12:53:01 <Aruro> just return and >>=
12:53:10 <glguy> No, it's part of the class, so it needs to be shown
12:53:39 <kadoban> Aruro: Well apparent it *is* in the class. It has a default definition though, so you usually don't have to explicitly write it, the default implementation works fine.
12:53:48 <glguy> "MINIMAL" implementation requirements are available in the haddock generated documentation
12:55:22 <Aruro> actually where is haddock docs on linux, usr / share ... ?
12:55:29 <Aruro> are*
12:55:52 <kadoban> Aruro: Probably depends on how you install whatever. I'd just look on hackage.
12:55:59 <Aruro> isnt >>  just a (flip const) ?
12:56:02 <glguy> The command "ghc-pkg describe base" shows where the haddock html files are stored under the "haddock-html:" section
12:56:06 <monochrom> that depends on a million factors, all different across users. first factor: how you got and installed ghc.
12:56:07 <glguy> for the base package
12:57:08 <Aruro> i got ghc on arch i think from official haskell package
12:58:02 <glguy> Aruro: While 'flip const' would have the correct type it would have the incorrect behavior
12:58:20 <Aruro> u mean it does not evaluate? :)
12:58:28 <glguy> (except for possibly the Identity type)
12:58:59 <Aruro> probably flip const also satisfies monad "laws"
12:59:15 <kadoban> > Nothing >> Just 2
12:59:16 <lambdabot>  Nothing
12:59:25 <glguy> >> only discards the "result" of the first argument, it doesn't discard the rest of the meaning
12:59:58 <kadoban> > let f = flip const in Nothing `f` Just 2
12:59:58 <glguy> putStrLn "Hello" >> putStrLn "World
12:59:59 <lambdabot>  Just 2
13:00:13 <kadoban> Aruro: Compare those two.
13:00:17 <glguy> this is an action that prints both lines and ignores the () result from the first action
13:05:08 <Aruro> so it seems >> is not pure function or?
13:05:18 <nitrix> data ITree a = Leaf (Int -> a) | Node [ITree a]
13:05:19 <nitrix> fmap f (Node (x:xs)) = Node $ fmap f x : map (fmap f) xs
13:05:22 <nitrix> Does this seems correct?
13:05:23 <KaneTW> it's pure
13:05:45 <Aruro> i think (flip const) is pure, >> seems not :)
13:05:48 <glguy> Aruro: What makes you think that >> isn't a pure function?
13:05:52 <KaneTW> evaluation of IO actions isn't pure
13:06:19 <kadoban> Aruro: Define "pure"
13:06:33 <Aruro> no i think Kane is right
13:07:05 <glguy> Aruro: Evaluation of IO actions has nothing to do with functions
13:07:11 <k1io> aren't "IO actions" just values?
13:07:21 <k1io> (therefore making >> pure)
13:07:34 <KaneTW> yes
13:07:40 <glguy> k1io: Yes, >> takes to "IO actions" and returns a new one and is a "pure function"
13:07:41 <cocreature> evaluation of IO actions is pure, execution is not
13:07:52 <glguy> takes two*
13:08:18 <k1io> yes, >> is pure, whatever the RTS does with your program is not (potentially)
13:08:33 <glguy> well, it takes two IO actions in the case of IO, at least :)
13:09:15 <Aruro> im slightly puzzled by the fact that flip const is not the same as >> , on conceptual level
13:09:33 <Aruro> even though types are similar
13:09:53 <glguy> It's similar to how  1 and 2 aren't the same but both have the same type
13:09:55 <kadoban> Aruro: This is because the type system doesn't encode *everything*. In fact it's because it doesn't encode the Monad laws.
13:10:03 <Aruro> of course looking at base hiding inside >> a >>= things become clear
13:10:03 <glguy> Each type typically has many inhabitants
13:10:38 <Aruro> i think 1 and 2 are more similar than flip const and >> :D
13:11:57 <kadoban> Aruro: Well it's just an analogy.
13:12:09 <Aruro> so probably stictly speaking >> having type m a -> m b -> m b is not same as flip const because of this m part
13:12:32 <Aruro> confusing type variables :D
13:12:58 <KaneTW> yes
13:13:21 <kadoban> Aruro: In a sense that's true, sure.  By the way, that's not the full type, the   Monad a =>    part is important.
13:13:32 <monochrom> @type flip const :: Monad m => m a -> m b -> m b
13:13:33 <KaneTW> more specifically, it's Monad m => m a -> m b -> m b 
13:13:33 <lambdabot> Monad m => m a -> m b -> m b
13:14:02 <nitrix> data ITree a = Leaf (Int -> a) | Node [ITree a]
13:14:05 <nitrix> fmap f (Node (x:xs)) = Node $ fmap f x : map (fmap f) xs
13:14:07 <nitrix> Does this seems correct?
13:14:24 <monochrom> you can give flip const that type, but the behaviour is different. far from conceptually similar, unless you have very "everything is the same as everything" concepts
13:15:00 <monochrom> "getLine >> getLine" is not going to behave as "flip const getLine getLine"
13:15:01 <kadoban> Aruro: Is it confusing to you why (+) and (-) have the same type, but different behavior? This is kind of the same thing.
13:15:19 <monochrom> "[1,2,3] >> [4]" is not going to behave as "flip const [1,2,3] [4]"
13:15:25 <monochrom> > [1,2,3] >> [4]
13:15:27 * hackagebot data-base 1.1 - Utilities for accessing and comparing types based on so called bases - representations with limited polymorphism.  https://hackage.haskell.org/package/data-base-1.1 (danilo2)
13:15:27 <lambdabot>  [4,4,4]
13:15:29 * hackagebot data-construction 1.1 - Data construction abstractions including Constructor, Destructor, Maker, Destroyer, Producer and Consumer.  https://hackage.haskell.org/package/data-construction-1.1 (danilo2)
13:15:33 <KaneTW> (flip const :: Monad m => m a -> m b -> m b) violates the monad laws, for starters
13:15:33 <monochrom> > flip const [1,2,3] [4]
13:15:35 <lambdabot>  [4]
13:15:42 <monochrom> not conceuptually similar
13:15:53 <Aruro> monochrom: good point , i was talking about generalization of m a being just a in flip cost case, what you basically showed.
13:15:55 <KaneTW> if you want to use it as (>>)
13:16:33 <Aruro> kadoban: ty, i agree with + - thing
13:18:44 <Aruro> ok we basically agreed that >> is useless since its just >>= under the hood :)
13:19:10 <Aruro> useless to be considered independent
13:19:19 <kadoban> It's not useless (well, more arguable since (*>) and the AMP, but that's a side point). It's just not usually necessary to explicitly define.
13:19:52 <Aruro> yes, ty, now clear
13:20:14 <Aruro> i came across this from functional pearl on monadic parsers
13:20:27 * hackagebot data-layer 1.0.4 - Data layering utilities. Layer is a data-type which wrapps other one, but keeping additional information. If you want to access content of simple newtype object, use Lens.Wrapper instead.  https://hackage.haskell.org/package/data-layer-1.0.4 (danilo2)
13:20:35 <Aruro> they define just return and  >>=
13:20:49 <Aruro> but then they use item parser which looks like  application of >>
13:21:42 <Aruro> lone item parser without binding
13:23:52 <Aruro> is this already in spirit of AMP  ? : https://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.Base.html#%3E%3E
13:24:10 <Aruro> i mean version 4.8.2.0
13:24:43 <confusedh> Hey, I just started looking into haskell a little while ago, and I'm trying out WAI and Warp for the first time, but I'm having trouble understanding the Middleware type
13:25:27 * hackagebot data-result 1.0 - Data types for returning results distinguishable by types.  https://hackage.haskell.org/package/data-result-1.0 (danilo2)
13:25:29 <nitrix> confusedh: Two examples of middlewares are loggin and static assets.
13:25:34 <nitrix> logging*
13:26:01 <kadoban> Aruro: I don't understand the question?
13:26:05 <k4pod> Aruro: Yep, you can see return is defined in terms of Applicative pure.
13:26:13 <nitrix> confusedh: There's a lot more, like url rewriting, vhosts, httpauth, etc.
13:26:25 <Aruro> k4pod: ty :)
13:26:30 <confusedh> Yeah, but I'm confused about the way you bind variables, this is an example middleware that I wrote by copying the structure i found in other middlewares http://lpaste.net/151274
13:26:42 <nitrix> confusedh: It's just logic that's run for each request between WAI and your handlers.
13:26:59 <confusedh> But I don't understand what the "app" argument to the function comes from? I thought an application took just two arguments?
13:27:01 <Aruro> kadoban: they use pure in monad definition
13:27:06 <kadoban> confusedh: If you haven't learned much about haskell basics before jumping into an API/project like that, I would suggest that's going to be pretty confusing in general.
13:27:26 <kadoban> Aruro: Oh that, yeah that's possible because of the AMP.
13:28:11 <confusedh> kadoban: Yeah, that might be true, I have read a good chunck of the "Learn you a haskell for great good" and done some xml parsing with the expat and HXT libraries
13:28:32 <Shockk> hmm, am I right in thinking that all monads are applicatives? or am I recalling incorrectly?
13:28:48 <nitrix> confusedh: type Middleware = Application -> Application
13:28:55 <confusedh> I mean, there are lots of things i don't understand here, but this just kind of stuck out, since I really don't get why a function which is supposed to take an application and  return an application takes 3 parameters.
13:28:59 <nitrix> confusedh: A middleware takes an application and yields an application.
13:29:07 <nitrix> confusedh: So the app argument makes perfect sense.
13:29:23 <confusedh> type Application = Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived
13:29:30 <glguy> Middleware = Application -> Application = Application -> Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived
13:29:39 <k4pod> Shockk: Yep! In prelude, Applicative m => Monad m where... means that any m monad must also be an Applicative
13:29:41 <Shockk> actually ignore that question; I just remembered that instances of Monad have an Applicative constraint now
13:29:47 <nitrix> confusedh: It's because an Application is also a function.
13:29:55 <nitrix> confusedh: type Application = Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived
13:29:55 <confusedh> OH
13:30:32 * hackagebot functor-utils 1.1 - Collection of functor utilities, providing handy operators, like generalization of (.).  https://hackage.haskell.org/package/functor-utils-1.1 (danilo2)
13:30:34 * hackagebot dependent-state 1.0.0 - Control structure similar to Control.Monad.State, allowing multiple nested states, distinguishable by provided phantom types.  https://hackage.haskell.org/package/dependent-state-1.0.0 (danilo2)
13:31:04 <kadoban> confusedh: If you have the time, I'd probably go back and do something like cis194 https://www.seas.upenn.edu/~cis194/spring13/ , though it sounds like you're kind of getting by as-is, so maybe you're past where I was assuming in your learning. But usually doesn't hurt to review the basics.
13:31:05 <Shockk> k4pod: what I was wondering ultimately is: should the definition of `return` for a Monad always be the same as `pure`, by the laws of a monad, or does the definition of a monad permit return to be different
13:31:25 <Shockk> I mean permit as in, according to what a monad is, not what's allowed when writing an instance
13:32:09 <kadoban> Shockk: I believe the laws require that they act identically.
13:32:21 <nitrix> confusedh: Your function `logz` is actually eta reduced.
13:32:22 <Shockk> okay, that's good to know, thanks
13:32:22 <confusedh> kadoban: For sure, that would be good, I just wanted to play with something that had "real" IO. 
13:32:42 <confusedh> nitrix: eta?
13:32:44 <nitrix> confusedh: Oh actually no, nvm.
13:34:39 <Shockk> following on from that, am I right in thinking then that the defining part of a monad is simply >>= ?
13:35:33 * hackagebot dependent-state 1.0.1 - Control structure similar to Control.Monad.State, allowing multiple nested states, distinguishable by provided phantom types.  https://hackage.haskell.org/package/dependent-state-1.0.1 (danilo2)
13:35:34 <dustmote> the foldable instance for (,) is unexpected seems to me to be generally not useful.. does anybody know the rational for it?
13:35:35 * hackagebot lens-utils 1.2 - Collection of missing lens utilities.  https://hackage.haskell.org/package/lens-utils-1.2 (danilo2)
13:35:37 * hackagebot prologue 1.0.7 - Better, more general Prelude exporting common utilities.  https://hackage.haskell.org/package/prologue-1.0.7 (danilo2)
13:36:08 <confusedh> nitrix: Oh, so when I do: run 8080 $ logz $ app
13:36:15 <confusedh> It is really doing partial application?
13:37:11 <nitrix> confusedh: Does your code compile?
13:37:15 <k4pod> Shockk: I think the idea is "any monad has an underlying Applicative instance." So if you have a monad instance, you know there exists an Applicative instance where pure = return.
13:37:16 <confusedh> Ah, that makes sense, I guess my functional thinking still isn't reall where it should be XD
13:37:17 <nitrix> I have a feeling it shouldn't, lol.
13:37:21 <confusedh> nitrix: it does
13:37:27 <jmcarthur> dustmote: Can't think of great uses for Foldable ((,) a), but I think it's justified even if only because Foldable is a requirement to define a Traversable instance.
13:38:21 <confusedh> nitrix: http://lpaste.net/151275
13:38:24 <Shockk> k4pod: pure = return? or return = pure?
13:38:31 <Shockk> or do you just mean the two equate?
13:38:52 <Xe> Shockk: both are identical actions, but return in Monad is usually implemented as calling pure
13:38:55 <nitrix> confusedh: AH! That's why!
13:39:01 <Shockk> ahh right
13:39:16 <nitrix> confusedh: There's a serious problem here. You're using `app` as both a variable and a function name o:
13:39:18 <dustmote> jmcarthur: thanks. i'm not familiar enough with traversable to comment, but i'll take a look and try to understand
13:39:54 <confusedh> Ah good, im such a dork. Which binding is stronger here then?
13:40:04 <k4pod> Shockk: Yeah, I just mean they equate. There could be an Applicative instance for which there does not exist a monad instance, though no examples come to mind.
13:40:33 * hackagebot type-cache 1.0 - Utilities for caching type families results. Sometimes complex type families take long time to compile, so it is proficient to cache them and use the final result without the need of re-computation.  https://hackage.haskell.org/package/type-cache-1.0 (danilo2)
13:40:34 <confusedh> nitrix: taking away the app function doesn't change anything though
13:41:10 <arkeet> there are several examples of applicatives that can't be monads 
13:41:32 <arkeet> if m is a monoid, Const m is Applicative but can't be a Monad (unless m is trivial like ())
13:41:52 <nitrix> confusedh: checking
13:41:53 <arkeet> ZipList is an Applicative but there's no Monad instance for it that's compatible with the Applicative
13:46:52 <nitrix> confusedh: I'm getting it to run on my computer and will try to make recommendations
13:47:36 <confusedh> haha, please don't take this as serious code, I read through the WAI documentation for the first time about 10 minutes before I came in here
13:50:17 <dmj> to install el capitan or not to install el capitan, that is the question
13:50:33 * hackagebot impossible 1.0.0 - Set of data and type definitions of impossible types. Impossible types are useful when declaring type classes / type families instances that should not be expanded by GHC until a specific type is provided in order to keep the types nice and...  https://hackage.haskell.org/package/impossible-1.0.0 (danilo2)
13:50:35 * hackagebot poly-control 1.0.0 - This package provides abstraction for polymorphic controls, like PolyMonads or PolyApplicatives.  https://hackage.haskell.org/package/poly-control-1.0.0 (danilo2)
13:54:20 <monochrom> dmj: buy two computers. then you can try both paths :)
13:54:44 <monochrom> ("now you have two problems")
13:58:02 * geekosaur has El Cap VMs, problem solved >.>
13:58:18 <nitrix> confusedh: I see where the confusion is.
13:58:55 <nitrix> confusedh: logz app req resp = do { ... }
13:59:10 <dmj> monochrom: heh
13:59:14 <nitrix> confusedh: vs.   logz app = \req resp -> do { ... }
13:59:29 <confusedh> yeah
13:59:32 <confusedh> Exactly
14:00:06 <confusedh> But is it partial application?
14:00:07 <nitrix> confusedh: Is it easier to see what's happening now? logz takes an application and application. An application is a function (we've used a lambda here) which takes a request and a response and yields an `IO ResponseReceived`.
14:00:26 <nitrix> Which is the `do` that you see for Monad IO.
14:00:31 <confusedh> Yeah, I understand the idea of middleware just fine, it was the syntax I didn't understand :P
14:09:14 <nitrix> Is the composition of two functors guarantee to be a functor as well?
14:09:23 <nitrix> s/ee/eed/
14:09:42 <dolio> Yes.
14:21:53 <Gurkenglas> In fact, https://hackage.haskell.org/package/transformers-0.5.1.0/docs/Data-Functor-Compose.html
14:22:24 <johnw> nitrix: composed applicatives are applicative too
14:29:02 <nitrix> I'm lost.
14:29:12 <nitrix> Doesn't Compose take 3 types?
14:29:29 <johnw> Compose f g a = f (g a), basically
14:29:50 <nitrix> Why are the instances 5, and misnamed?
14:30:16 <johnw> huh?
14:30:31 <nitrix> (Functor f, Functor g) => Functor (Compose * * f g)
14:30:34 * hackagebot call-haskell-from-anything 0.2.0.0 - Call Haskell functions from other languages via serialization and dynamic libraries  https://hackage.haskell.org/package/call-haskell-from-anything-0.2.0.0 (NiklasHambuechen)
14:30:37 <nitrix> Where does the stars comes from?
14:31:20 <johnw> I don't see that at https://hackage.haskell.org/package/transformers-0.5.1.0/docs/src/Data-Functor-Compose.html#Compose
14:31:23 <nitrix> I would've imagined Functor (Compose f g) ...
14:31:43 <exio4> nitrix: those are kind parameters
14:32:09 <nitrix> exio4: Given to what?
14:32:14 <exio4> nitrix: Compose
14:32:17 <exio4> @kind Compose
14:32:19 <lambdabot>     Not in scope: type constructor or class ‚ÄòCompose‚Äô
14:32:43 <nitrix> Composer :: * -> * -> * -> *
14:32:46 <nitrix> We agree on that?
14:32:56 <exio4> well, Compose :: (k -> *) -> (k1 -> k) -> k1 -> *
14:33:00 <exio4> nitrix: we don't.
14:33:04 <nitrix> uh?
14:33:28 <exio4> nitrix: newtype Compose f g a = Compose (f (g a)) -- right?
14:33:55 <nitrix> Call the constructor MkCompose, I think its the source of the problem :P
14:34:03 <exio4> nitrix: newtype Compose f g a = MkCompose (f (g a)) -- right?
14:34:07 <nitrix> sure.
14:35:15 <exio4> nitrix: so, if you infer Compose's parameters are 'f', 'g' and 'a', right? 
14:35:33 <exio4> nitrix: er, s/if you infer// :P 
14:35:37 <exio4> nitrix: what are their kinds?
14:36:07 <nitrix> Mhhh, a is *, g is * -> *, f is * -> * -> * maybe?
14:37:22 <mauke> how can f have 2 arguments
14:37:31 <nitrix> Oh wait
14:37:54 <nitrix> Yeah, f is * -> * as well, because it's applied to the result of g, which must be concrete.
14:38:05 <exio4> nitrix: that's without PolyKinds!
14:38:08 <nitrix> I don't know if my reasoning's proper.
14:38:28 <exio4> nitrix: it is, but PolyKinds enables kind polymorphism.
14:38:53 <exio4> nitrix: are you familiar with Proxy? 
14:39:02 <nitrix> exio4: First time hearing about both kind polymorphism and Proxy.
14:39:21 <nitrix> Although proxy I think is from pipes?
14:39:30 <exio4> @type (undefined :: Proxy (42 :: Nat))
14:39:32 <lambdabot> Not in scope: type constructor or class ‚ÄòNat‚Äô
14:39:32 <nitrix> Producer, consumer, proxy?
14:39:56 <exio4> I don't know what "proxy" does in pipes, I am thinking about data Proxy k = Proxy 
14:40:16 <nitrix> That should be illegal ._.
14:40:24 <exio4> it's normally used as a way to pass type parameters
14:40:32 <exio4> nitrix: data Proxy k = MkProxy, then? :P
14:40:36 <xrisk> I am trying to solve a problem in which a fixed length list makes sense. Should I use this https://hackage.haskell.org/package/fixed-list ?
14:41:03 <nitrix> exio4: So... that's a polymorphic constructor for any type?
14:41:04 <KaneTW> hm
14:41:29 <nitrix> exio4: I'm struggling to understand the implications / usage.
14:41:39 <exio4> nitrix: are you familiar with DataKinds?
14:41:43 <KaneTW> i need a monad class that provides read :: m ByteString and write :: ByteString -> m ()
14:41:45 <nitrix> exio4: Neither.
14:41:50 <k4pod> How can I force ghci to always enable OverloadedStrings when it starts up?
14:41:58 <nitrix> exio4: We getting far just to explain the two asterisk syntax.
14:42:53 <kadoban> k4pod: Put sometihng like :set -XOverloadedStrings in a file named .ghci in the current directory. Syntax may be wrong, I never use.
14:43:05 <exio4> nitrix: well, Compose's kind is actually not :: (* -> *) -> (* -> *) -> (* -> *), but (k -> *) -> (k1 -> k) -> (k1 -> *)
14:43:10 <exio4> nitrix: those "k, k1" are kind variables
14:43:13 <kadoban> I think you can have a "global" one, maybe, so ~/.ghci .  Or not, I dunno.
14:43:21 <nitrix> k3d3: Or just run :set -XOverloadedStrings while it's running.
14:43:28 <exio4> nitrix: so it's actually ‚àÄk, k1. (k -> *) -> (k1 -> k) -> (k1 -> *) 
14:43:37 <k3d3> Lol nitrix, close :p
14:44:06 <nitrix> :<
14:44:45 <k3d3> Did you want to highlight kadoban?
14:44:47 <monochrom> it tries to be more general
14:44:57 <k3d3> Or k4pod?
14:45:00 <nitrix> k3d3: k4pod.
14:45:01 <exio4> nitrix: those * * are explicit kind application, (k = *, k1 = *), the notation might be a bit weird if you aren't familiar with it 
14:45:04 <k3d3> Ah
14:45:05 <nitrix> exio4: I get that so far.
14:45:17 <nitrix> exio4: I'm surprised there's such thing as kind variables though.
14:45:27 <monochrom> it's fairly new
14:45:39 <k4pod> Thanks, all. going to look into .ghci's
14:45:42 <nitrix> Is that supposed to be able to allow polymorphism of # and *?
14:45:46 <nitrix> What are the other kinds?
14:45:46 <exio4> nitrix: the reasoning behind it makes sense when you enable DataKinds
14:45:54 <exio4> nitrix: no, you can't be polymorhic over #
14:46:11 <nitrix> exio4: So what else there is other than * then?
14:46:27 <exio4> nitrix: with DataKinds, you can promote arbitrary datatypes to the kind level 
14:46:35 <nitrix> Oh boy.
14:46:59 <nitrix> I see where this is going.
14:47:07 <nitrix> Is that like, some sort of dependent types?
14:47:09 <exio4> nitrix: ("arbitrary" here doesn't account for GADTs (yet), but it will with GHC8)
14:47:51 <nitrix> That's naughty. That's a _lot_ of abstraction tbh.
14:48:25 <exio4> nitrix: well, it lets you get quite far, it's really nasty in quite a lot of ways because Haskell is not dependently typed 
14:49:20 <monochrom> not just that. "Compose Fix (StateT Int)" also makes sense, Fix :: (* -> *) -> * and StateT Int :: (* -> *) -> (* -> *).
14:49:34 <monochrom> (newtype Fix f = MkFix (f (Fix f)) )
14:50:14 <monochrom> by "make sense" I just mean "legal and stands for something", not necessarily "useful"
14:50:37 <nitrix> I miss my old union and struct in C now :(
14:50:46 <nitrix> sum and products, done ;-;
14:51:11 <exio4> nitrix: here have some awful code to cry on :p https://raw.githubusercontent.com/EXio4/randomcode/master/Haskell/vfs/Main.hs
14:52:56 <nitrix> exio4: Seriously, couldn't that be written without?
14:53:09 <nitrix> exio4: I mean, I'm working on a file system too and I feel I have all the tools I need...
14:54:21 <monochrom> "exio4 is a new file system to replace ext4" ... :)
14:54:45 <exio4> nitrix: that code isn't serious, I just wrote it for fun, but you can have multiple implementations of the FS interpreters, which support only Read(s) or Read(s) and Write(s)
14:55:28 <exio4> monochrom: heh, exio5 would be a better name :P 
14:56:29 <exio4> nitrix: if you see the code, the "IO" implementation of the VFS, supports both reads and writes, while the "in-memory" version only supports reads
14:57:31 <exio4> nitrix: you can't even call the "in-memory" interpreter with an action which calls fs_write
15:05:35 * hackagebot textual 0.1.0.0 - Textual type class for data that represent text  https://hackage.haskell.org/package/textual-0.1.0.0 (marcosdumay)
15:05:37 * hackagebot nanq 2.0.0 - Performs "Wö (National Kanji Exam) level analysis on given Kanji.  https://hackage.haskell.org/package/nanq-2.0.0 (fosskers)
15:08:09 <nitrix> Is there a shortcut in haskell for a function to call itself with the same arguments again?
15:08:22 <nitrix> (recursively)
15:08:36 <notabigthreat> iterate?
15:09:36 <nitrix> Not quite, it's using IO.
15:09:53 <KaneTW> forever?
15:10:14 <nitrix> It's the main loop for a game and it's starting to have quite a lot of arguments. It's just weird that everytime I add something to it, I also have to change the last line with   unless quit $ forever itself
15:10:58 <barrucadu> A common pattern is: foo a b c x y z = go where go = ...
15:11:14 <nitrix> Oh I can do that!
15:11:14 <dmj> nitrix: can you paste some code
15:11:16 <barrucadu> Then you can just stick a "forever go" in there, and everything's still in scope
15:11:25 <nitrix> barrucadu: yup, brilliant :)
15:11:25 <KaneTW> "forever leave"
15:11:31 <KaneTW> i want to do that sometimes
15:11:38 <exio4> foo a b c = fix $ \loop -> do { ... ; ... ; loop ; }" is a kinda common pattern, too
15:14:25 <nitrix> exio4: Sold <3
15:14:45 <nitrix> Cleaner than the 3 nested levels with `where` and `go` imo.
15:14:58 <hodapp> I can't find the article that I feel like talked about this...
15:15:04 <exio4> nitrix: this is just the go pattern ... using a high order function instead, fwiw :p 
15:15:15 <exio4> nitrix: fix f = let y = f y in y 
15:15:48 <hodapp> http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html there it is
15:16:18 <hodapp> that may or may not be useful though...
15:16:28 <hodapp> haven't read it in awhile, can't recall if it explictly calls the main loop
15:16:45 <nitrix> > fix (+5)
15:16:49 <lambdabot>  mueval-core: Time limit exceeded
15:16:53 <nitrix> Muahahah.
15:17:17 <nitrix> That's so ugly.
15:17:28 <hodapp> 9_9
15:17:31 <nitrix> It's actually quite dangerous to be honest.
15:18:29 <exio4> nitrix: well, the type said it :)
15:18:37 <exio4> fix :: (a -> a) -> a
15:18:52 <exio4> fix id :: ‚àÄa. a
15:19:04 <nitrix> ouch.
15:19:08 <exio4> which is .. bottom, false!
15:19:27 <exio4> that's an easy proof of everything! 
15:19:33 <nitrix> Pfft, who need values anyway.
15:20:01 * hodapp grumbles at the Haskellers, and goes back to his R code.
15:20:33 <hiptobecubic> hodapp, why R? Just for HaskellR?
15:21:01 <hodapp> hiptobecubic: it's for a machine learning class. I've also wanted to learn R, and didn't feel like using Python or Java for this class.
15:21:08 <hodapp> though, I could have used Lisp - it was made an option.
15:21:17 <hodapp> but it comes down to what has machine learning algorithms available.
15:21:23 <hiptobecubic> sure
15:21:48 <hodapp> but I do want to use HaskellR soon.
15:22:10 <hiptobecubic> I have to say, I much prefer Python over R as a language, but there's a lot of statistical R code out there at one's disposal.
15:22:38 <hiptobecubic> And if you're planning on using haskell for the other things, then it's probably not a bad choice.
15:23:07 <hiptobecubic> Still, I'd have gone with lisp, I think :)
15:23:42 <hodapp> I was aware of Lisp being used extensively in early AI, but it didn't seem to have nearly the wealth of machine learning stuff available as R or Python or Java
15:24:06 <gganley> johnw: What are the rules on asking things that are not directly Haskell questions but Computer Science questions that relate to haskell
15:24:38 <hodapp> if they relate to Haskell it's probably okay here
15:25:23 <hexagoxel> how do i "add more information" to the exception callstack info when i am not in IO, and don't want to pass the relevant stuff down to the function that throws the exception?
15:25:52 <gganley> I'm currently studying Computer Science at uni but im thinking of picking up a double major in math because I enjoy exploring the intersection of Math and Computer Science. Also leveragging the existing knowlage in math i find interesting.
15:26:24 <gganley> I like haskell,clojure,systems programming,and networking and all those things seem like math could be useful
15:26:33 <hexagoxel> in IO i could use `onException` to add printf debugging or smthing..
15:27:08 <hiptobecubic> gganley, I think the rule comes out to something like, "If the question is interesting and not displacing more-obviously on-topic questions, it's fine."
15:29:35 <hexagoxel> there must be some solution more clever than `Reader UsefulDataOnExceptionStack` (effectively passing down the additional data).
15:30:01 <hexagoxel> do i have to Unsafe.performIO + onException?
15:30:27 <gganley> hiptobecubic: ok, thanks for the advice
15:30:28 <hodapp> gganley: and what's your question?
15:31:24 <hexagoxel> dont ask to ask, but ask. the depth of asking must be exactly one.
15:31:40 <gganley> hodapp: already asked it lol. Its about if anyone else double majored in Math and CompSci and if they found it useful for things that I'm interested in (haskell,clojure,systems programming, networks)
15:31:55 <hatds> hexagoxel: I use unsafePerfomIO to create global IORefs, then do unsafePerformIO $ writeIORef UsefulData 
15:32:12 <hodapp> gganley: you told us about what you're studying, I didn't see a question :P
15:32:13 <hatds> hexagoxel: it's ugly and unsafe, but debugging in a separate concern that the true program
15:32:19 <hatds> *than
15:32:44 <hodapp> hm, I didn't double-major in math but I did have a math minor, however, my major was electrical engineering
15:32:46 <gganley> hodapp: its what im thinking of studying and if it would be useful for what im interested in, i guess i didnt fully form the thoughtpolice
15:32:52 <hiptobecubic> gganley, I'd say take all of the statistics-related courses you can as well as abstract algebra, but that's me :)
15:33:02 <hexagoxel> hatds: true, but the crashing happens inside some multithreaded worker working..
15:34:10 <gganley> hiptobecubic: I'm only a freshman but im planning on taking abstract 2 and some stats class yes. I'm not sure what else would be useful
15:34:23 <hexagoxel> also, somewhat related: is there an `assert` whose semantics does not depend on some DEBUG compiler flag?
15:34:41 <gganley> hiptobecubic: I've actually never taken a statistics course
15:35:06 <hiptobecubic> gganley, "some stats class" is just the beginning. I'd look at what people who want to be statisticians are expected to take and try to take those. Stats is really underrated and you need it all the time. It's really valuable to be good at it.
15:35:20 <Profpatsch> I wonder why nobody uses the forward pipe in Haskell
15:35:38 <Profpatsch> e.g listop1 |> listop2 instead of listop2 . listop1
15:37:03 <hexagoxel> aka (>>>)
15:38:49 <k4pod> I think thats (&)
15:39:31 <hexagoxel> basically i think it is more common (in math) to write "f x" than "x & f"; i.e. "data flowing from right to left" (at least in a single line..)
15:39:47 <KaneTW> i'm slowly thinking encoding this much in the type system was a mistake
15:40:00 <hodapp> gganley: stats classes are useful whether you want to do anything in FP or not
15:40:10 <KaneTW> dealing with existentials is annoying as hell
15:40:15 <gganley> hiptobecubic: I'm not even familiur what stats studies, when i hear stats i hear accounting and I KNOW thats not even the bit true
15:40:46 <hexagoxel> k4pod: no, (&) is flip ($) . and ($) /= (.) .
15:42:41 <gganley> edwardk: Didnt you get degrees in both math and comp sci.
15:52:05 <Profpatsch> hexagoxel: So |> is >>> ?
15:52:18 <Profpatsch> Is that simply flip (.)?
15:52:40 <Profpatsch> (with a different fixity?)
15:53:14 <hexagoxel> Profpatsch: it is more general than flip (.), but yes.
15:53:38 <Profpatsch> Hm, okay.
15:53:56 <Profpatsch> Oh, right,
15:54:03 <Profpatsch> I see.
15:54:58 <Profpatsch> hexagoxel: Well, if you see (.) as the categorical composition, it‚Äôs exactly as general. :)
15:55:52 <Profpatsch> huh, but it binds very weakly
16:00:15 * hexagoxel wonders if there are parentheses to be saved by replacing (.) with (<<<) in his code.. but the idea feels ugly already.
16:01:40 <hodapp> saving those parentheses up to use for Lisp?
16:04:50 <Profpatsch> You can use nearly all infix operators with >>> and <<<
16:05:12 <Profpatsch> Maybe it is a nice idiom to write longer data transformations.
16:05:21 <Profpatsch> at least >>>
16:22:06 <Profpatsch> On the other hand >>> requires the Compiler to have PolyKinds
16:22:58 <Profpatsch> Hm, UHC has them.
16:24:44 <adas> im using stack. im trying to create a new module inside the src folder but I keep getting a module not found error
16:42:41 <adas> nice
16:43:47 <aarvar> adas: did you add it to the cabal file?
16:44:14 <adas> aarvar: yes. I added it to the cabal file
16:44:25 <adas> aarvar: i have a feeling my directory structure is wrong or something
16:45:28 <adas> aarvar: do the modules have to be named according to the directory structure?
16:45:56 <adas> meaning in the src folder where should I put a module called Custom.Module for instance?
16:46:11 <adas> or can I simply use a flat directory structure?
16:46:19 <aarvar> think it needs to go in src/Custom/Module.hs
17:22:44 <adas> i have enabled OverloadedStrings and inspite of that, ghci infers the type as String when the context in which it is used is working with ByteStrings
17:26:38 <adas> anyone?
17:28:46 <prooftechnique> @paste
17:28:46 <lambdabot> Haskell pastebin: http://lpaste.net/
17:28:58 <prooftechnique> adas: Paste an example. Might be something simple
17:29:29 <adas> yup. a moment please
17:29:34 <adas> thanks for the link
17:38:54 <pikajude> is there a backtracking version of parsec?
17:39:13 <adas> http://lpaste.net/151279
17:40:51 <pavonia> pikajude: Parsec does backtracking
17:40:54 <adas> is there something im missing?
17:40:55 <pikajude> does it?
17:41:37 <pavonia> pikajude: Do you use the "try" combinator?
17:41:44 <pikajude> yes
17:41:53 <pikajude> sorry, backtracking i guess is not what i'm looking for
17:41:55 <pikajude> i need laziness
17:43:01 <pavonia> Could you explain?
17:43:58 <pavonia> adas: If you define the strings in another module, the types are defaultes to String, I guess. Try adding an explicit type signature
17:44:10 <pavonia> *defaulted
17:44:59 <pikajude> pavonia: say I have token1 > innerParser < token2
17:45:39 <pikajude> afaict, even if I use try, innerParser is all-or-nothing
17:45:49 <pikajude> if it consumes input that token2 could also consume, I'm never going to get parse success
17:47:33 <pavonia> It only backtracks if innerParser fails, I think
17:47:37 <nshepperd> pikajude: ah, you don't want that
17:47:58 <pikajude> no, I don't
17:48:11 <nshepperd> pikajude: I assume innerParser is some sort of loop of things?
17:48:16 <pikajude> it uses `many`
17:48:23 <nshepperd> right
17:48:44 <prooftechnique> adas: Explicit type signatures would likely help
17:49:07 <nshepperd> you want to use a more restricted 'many' or a 'manyTill' that specifies when the token2 should happen
17:49:40 <pikajude> right
17:50:06 <nshepperd> 'manyTill token2 foo', or if you're doing some sort of escaping, 'manyTill unescapedToken2 foo'
17:50:11 <nshepperd> is the usual scenario
17:50:20 <pikajude> so i have to restructure the parser
17:50:26 <pikajude> this is for XML
17:50:39 <pikajude> so I can't just use `tag "foo" innerParser`
17:50:54 <pikajude> i'll have to do `tagStart "foo" >> manyTill (tagEnd "foo") innerParser`
17:51:02 <pikajude> sorry, that first example should read `tag "foo" (many innerParser)`
17:51:18 <aarvar> adas: try NoMonomorphismRestriction
17:51:38 <aarvar> then they won't be defaulted to String
17:54:39 <adas> aarvar: much thanks. you were correct. but why did that work.? let me google that first
17:56:00 <nshepperd> you could define `tag foo innerParser = tagStart foo *> manyTill (tagEnd foo) innerParser <* tagEnd foo`
17:56:05 <nshepperd> and use that
17:56:30 <nshepperd> (I don't think manyTill consumes the delimiter, so you need that final 'tagEnd foo')
17:56:34 <aarvar> adas: it lets it infer `IsString a => a`. The monomorphism restriction prevents types with constraints from being inferred
17:56:52 <aarvar> which then triggers the defaulting mechanism in this case, resulting in it inferring String
17:57:05 <nshepperd> I think I would actually use `manyTill anyTagEnd foo`
17:57:17 <adas> aarvar: in that case is it okay to enable this extension by default for all my haskell code i write henceforth?
17:58:10 <nshepperd> any closing tag is a cue to give up parsing this bit, right? if it's the wrong closing tag, you can verify that when you actually parse the tag
17:59:27 <aarvar> adas: Should be fine. The reason for the restriction is explained on the wiki I think. Just be aware of that, if performance is an issue.
18:00:02 <adas> and by performance you mean compile time speed, not run time performance?
18:00:14 <aarvar> no, I mean runtime
18:00:42 <adas> aarvar: so you say in some cases enabling the extension might impact runtime adversely?
18:00:49 <aarvar> not exactly
18:01:28 <aarvar> without the monomorphism restriction, you can have a function which doesn't look like it's a function, so you can have a value which gets calculated twice when it looks like the result is shared
18:03:06 <aarvar> e.g., postgresSelected compiles to a function in your example, since a => b compiles to a -> b
18:04:39 <subleq___> why does operation have 'view' and not allow pattern matching on the Program type itself?
18:05:39 <nshepperd> monomorphism restriction errors are usually a clue that you should add some documenting types
18:06:08 <nshepperd> eg. adding postgresSelected :: Text or whatever it is would also fix the error
18:06:38 <nshepperd> oh, ByteString
18:06:58 <aarvar> though if you turn the restriction off you can have the ide insert polymorphic types for you
18:07:34 <aarvar> I should say constrained types
18:15:34 <KaneTW> is there a way to give a context to a type family or  instance?
18:25:49 * hackagebot elision 0.1.1.0 - Arrows with holes.  https://hackage.haskell.org/package/elision-0.1.1.0 (jacrough)
18:28:12 <adas> thanks for the clarification. im reading about it
18:48:34 <coconut> how to use showHex to get the actual hex ? it returns a ShowS
18:51:07 <enthropy> > showHex 42 ""
18:51:09 <lambdabot>  "2a"
18:52:41 <enthropy> coconut: the idea is that you can append ShowS with function composition (.), then when you're finally done give it an empty string at the end
18:53:40 <coconut> thx
18:53:46 <coconut> how to use the append ?
18:53:54 <coconut> in what circumstances
18:57:19 <verement> > (showHex 42 . showHex 255) ""
18:57:20 <lambdabot>  "2aff"
18:57:31 <hiptobecubic> Zaff!
18:59:56 <jme_> did anyone know why Pod::Coverage keeps failing testing with `panda install Linenoise` ?
19:00:07 <coconut> ok i see. there are times we need to concat those hex numbers
19:00:08 <jme_> wrong channel... sorry
19:00:38 <coconut> i actually need to rotate some decimal numbers
19:01:03 <coconut> i want to first convert then in hex and then use bit shift operations
19:01:20 <coconut> is this what others would do ?
19:02:48 <hiptobecubic> coconut, hex / decimal / binary etc are all just representation of the same number. There isn't a "hex number" type that would be bitshifted. You just convert to the appropriate representation when you want to display.
19:03:41 <hiptobecubic> > "a" "b"
19:03:43 <lambdabot>      Couldn't match expected type ‚Äò[Char] -> t‚Äô
19:03:43 <lambdabot>                  with actual type ‚Äò[Char]‚Äô
19:03:43 <lambdabot>      The function ‚Äò"a"‚Äô is applied to one argument,
19:03:52 <hiptobecubic> Ok good. Just checking :)
19:04:12 <coconut> i mean every 4 bits in binary format correspond one digit in hex
19:04:44 <coconut> so i shift the binary 4 bits to rotate the hex representation
19:04:55 <hiptobecubic> yes, sure
19:04:58 <coconut> then i convert it back to decimal
19:05:03 <geekosaur> ...
19:05:04 <hiptobecubic> no
19:05:10 <coconut> oh no
19:05:12 <geekosaur> so you do realize tht computers don't know "decimal"?
19:05:19 <geekosaur> they use binary
19:05:32 <hiptobecubic> The number is just a number. There's no converting to decimal or to hex until you're ready to display a string.
19:05:33 <geekosaur> decimal is a display format for people.
19:05:52 <coconut> how to rotate 567 to 675 in haskell then
19:06:12 <coconut> the clever way 
19:07:23 <hiptobecubic> coconut, well the "rotate" operation is inherently about the representation.
19:07:51 <verement> > showHex (shiftL 42 4) ""
19:07:53 <lambdabot>  "2a0"
19:08:14 <hiptobecubic> So an operation like "send the first digit to the back" will cause different changes in value depending on the representation that you are working on.
19:08:40 <coconut> ok so its better to rotate not the number but the string 
19:09:15 <hiptobecubic> If you're imagining rotation as "move the first character of the string representation of the number to the back" then yes
19:09:24 <coconut> i just thought maybe there's some bit correlation to decimal number rotation
19:09:48 <prooftechnique> @let f =  read . reverse . show
19:09:49 <lambdabot>  Defined.
19:09:54 <prooftechnique> > f 264 :: Int
19:09:56 <lambdabot>      Ambiguous occurrence ‚Äòf‚Äô
19:09:56 <lambdabot>      It could refer to either ‚ÄòL.f‚Äô,
19:09:56 <lambdabot>                               defined at /tmp/mueval1600515282040332871.hs:147:1
19:10:01 <prooftechnique> > L.f 264 :: Int
19:10:03 <lambdabot>  462
19:10:13 <geekosaur> 10 isn't a multiple of 2...
19:10:17 <geekosaur> er, power
19:10:22 <prooftechnique> That's an ugly trick, but
19:10:28 <geekosaur> (wow I am having a night, sigh)
19:10:35 <hiptobecubic> coconut, 0F is 15, F0 is 240
19:10:48 <dramforever> lambdabot: that, or what?
19:11:10 <coconut> ok i get it. 10 is not power of 2
19:11:17 <coconut> that's the key point
19:11:19 <hiptobecubic> prooftechnique, reverse and rotate are different :)
19:11:32 <hiptobecubic> coconut, here, yes.
19:12:01 <prooftechnique> Oh, I was just going by the spec "567 to 675". :D Silly me. You're quite right
19:12:22 <hiptobecubic> 567 to 657 is not reverse either. :)
19:12:29 <hiptobecubic> err 675
19:12:39 <prooftechnique> Oh, duh. I misread
19:12:43 <prooftechnique> I'm also having a night, it seems
19:12:49 <coconut> :} thx everybody
19:12:54 <prooftechnique> I guess zipWith const, maybe
19:13:17 <prooftechnique> @let rotate n xs = zipWith const (drop n (cycle xs)) xs
19:13:19 <lambdabot>  Defined.
19:13:27 <prooftechnique> > rotate 2 "567"
19:13:29 <lambdabot>      Ambiguous occurrence ‚Äòrotate‚Äô
19:13:29 <lambdabot>      It could refer to either ‚ÄòL.rotate‚Äô,
19:13:29 <lambdabot>                               defined at /tmp/mueval1600515282040332871.hs:151:1
19:13:33 <prooftechnique> > L.rotate 2 "567"
19:13:35 <lambdabot>  "756"
19:13:40 <prooftechnique> > L.rotate 1 "567"
19:13:42 <lambdabot>  "675"
19:13:50 <prooftechnique> There we go
19:13:56 <hiptobecubic> sure
19:14:00 <prooftechnique> > show . L.rotate 1 "567" :: Int
19:14:02 <lambdabot>      Couldn't match expected type ‚ÄòInt‚Äô with actual type ‚Äòa0 -> String‚Äô
19:14:02 <lambdabot>      In the expression: show . L.rotate 1 "567" :: Int    Couldn't match expe...
19:14:02 <lambdabot>      Possible cause: ‚ÄòL.rotate‚Äô is applied to too many arguments
19:14:06 <prooftechnique> > show $ L.rotate 1 "567" :: Int
19:14:07 <lambdabot>      Couldn't match type ‚Äò[Char]‚Äô with ‚ÄòInt‚Äô
19:14:08 <lambdabot>      Expected type: Int
19:14:08 <lambdabot>        Actual type: String
19:14:22 <prooftechnique> Ugh. I get what I mean, why can't you, GHC? :D
19:14:38 <prooftechnique> > show (L.rotate 1 "567") :: Int
19:14:40 <lambdabot>      Couldn't match type ‚Äò[Char]‚Äô with ‚ÄòInt‚Äô
19:14:40 <lambdabot>      Expected type: Int
19:14:40 <lambdabot>        Actual type: String
19:14:48 <prooftechnique> > read (L.rotate 1 "567") :: Int
19:14:49 <lambdabot>  675
19:14:51 <prooftechnique> Because I can't read
19:14:55 <prooftechnique> Obviously
19:15:17 <coconut> > :info L
19:15:19 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
19:15:19 <prooftechnique> coconut: Anyway, that's what you could do
19:15:27 <coconut> what is L ?
19:15:28 <geekosaur> no :info in lambdabot
19:15:34 <geekosaur> L is the bot's "prelude"
19:15:37 <geekosaur> local definitions
19:15:40 <coconut> ok
19:16:05 <coconut> how to type code to lamdabot here ?
19:16:06 <geekosaur> you can add to them (with some restrictions) with @let; @undefine resets it to the standard one
19:16:29 <prooftechnique> Prefix your code with a > to evaluate it
19:16:45 <coconut> ok i thought it's like ghci
19:16:54 <geekosaur> also ote that it is a shared environmnent and every expression is independent of other expressions
19:17:03 <prooftechnique> It is recommended to /msg lambdabot instead of spamming the channel like I did :<
19:17:46 <coconut> cool trick
19:17:53 <prooftechnique> My favorite cute trick, though
19:17:56 <geekosaur> you might want to look at something like tryhaskell.org also
19:17:56 <prooftechnique> @let numDigits = (+1) . floor . log . abs
19:17:58 <lambdabot>  Defined.
19:18:08 <prooftechnique> > numToDigits 457892
19:18:10 <lambdabot>      Not in scope: ‚ÄònumToDigits‚Äô
19:18:10 <lambdabot>      Perhaps you meant ‚ÄònumDigits‚Äô (line 148)
19:18:17 <prooftechnique> > numDigits 457892
19:18:19 <lambdabot>  14
19:18:28 <geekosaur> or maybe iHaskell (a ghci-ish notebook for ipython/jupyter)
19:18:28 <prooftechnique> Derp. That's awful wrong
19:20:02 <Xnuk> > let numDigits = (+1) . floor . (/ log 10) . log . abs in numDigits 457892
19:20:03 <lambdabot>  6
19:20:09 <geekosaur> log is natural logarithm, not base-10 logarithm
19:20:32 <coconut> any haskell library that can does this ?   tell that go , going, gone ,went are all the same english word of go
19:20:38 <verement> @let numDigits = (+1) . floor . (logBase 10) . abs
19:20:39 <lambdabot>  .L.hs:149:1:
19:20:39 <lambdabot>      Multiple declarations of ‚ÄònumDigits‚Äô
19:20:39 <lambdabot>      Declared at: .L.hs:148:1
19:20:50 * hackagebot call-haskell-from-anything 1.0.0.0 - Call Haskell functions from other languages via serialization and dynamic libraries  https://hackage.haskell.org/package/call-haskell-from-anything-1.0.0.0 (NiklasHambuechen)
19:20:51 <prooftechnique> Right, I forgot the logBase 10
19:20:52 * hackagebot conduit-tokenize-attoparsec 0.1.0.0 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/conduit-tokenize-attoparsec-0.1.0.0 (newhoggy)
19:20:59 <prooftechnique> I'm having an impossible day, it seems
19:21:05 <prooftechnique> @undefine
19:21:06 <lambdabot> Undefined.
19:21:11 <prooftechnique> @undefine numDigits
19:21:11 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
19:21:19 <prooftechnique> @let numDigits = (+1) . floor . logBase 10 . abs
19:21:20 <lambdabot>  Defined.
19:21:23 <prooftechnique> > numDigits 457892
19:21:25 <lambdabot>  6
19:21:27 <prooftechnique> There
19:22:05 <geekosaur> of course now I'm trying to imagine base-e numeric representation >.>
19:22:10 <verement> > numDigits 0
19:22:12 <lambdabot>  -179769313486231590772930519078902473361797697894230657273430081157732675805...
19:22:18 <geekosaur> heee
19:22:22 <prooftechnique> :D
19:24:35 <iffraff> Hi, I have a question that I have to ask at a high level because I'm wokng in a differnt language.
19:24:50 <iffraff> anyone game? it's about chaining futures
19:25:40 <iffraff> I'll ask but don't get mad at me for not knowing what the hell I"m doing please
19:26:44 <iffraff> I have a fuction that produces a future, I want to map another function over that.  If that function may fail do I wrap another future?
19:30:15 <coconut> how to print a string in say yellow color ?
19:30:18 <verement> > numDigits 1000
19:30:20 <lambdabot>  3
19:30:59 <kadoban> coconut: In what context? ANSI terminal or something?
19:31:12 <coconut> windows console2
19:34:36 <Clint> never heard of it
19:35:28 <dramforever> It should boil down to an FFI call to SetConsoleTextAttribute or something, but it sounds too low-level
19:36:07 <tier2villian> =/j archlinux
19:36:13 <tier2villian> oops pardon me
19:43:49 <coconut> getIntArg :: IO Integer
19:43:51 <coconut> getIntArg = fmap (read . head) getArgs
19:43:58 <coconut> why is this leagal
19:44:06 <coconut> getIntArg is a function
19:44:19 <coconut> but it's type is not
19:47:10 <julianleviston> coconut: getIntArg is an IO action
19:48:32 <coconut> ok
19:48:34 <coconut> sorry
19:48:37 <julianleviston> coconut: that‚Äôs to say it‚Äôs not a function 
19:48:47 <julianleviston> coconut: at least, by my current definition it‚Äôs not :)
19:48:52 <coconut> it doesnt take an input
19:48:57 <julianleviston> coconut: no need to be sorry!
19:49:33 <dramforever> coconut: (->) values take values and produces values
19:49:53 <dramforever> that getIntArg doesn't take anything
19:49:58 <julianleviston> coconut: the word input is a little‚Ä¶ um‚Ä¶ ‚Äúfraught‚Äù here‚Ä¶ because it does obviously take input, but the function doesn‚Äôt have any arguments (which we sometimes call a function input)
19:50:40 <synergistics> Why don't the prints happen immediately in the expression: map print [1,2,3] ?
19:51:05 <julianleviston> synergistics: because you‚Äôre building a value 
19:51:23 <geekosaur> :t map print [1,2,3]
19:51:24 <lambdabot> [IO ()]
19:51:37 <geekosaur> notice the IO is *inside* the list
19:52:06 <geekosaur> it's not going to actually happen unless you can connect it in some way to `main`. for this, see
19:52:09 <geekosaur> :t sequence
19:52:10 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
19:52:29 <geekosaur> ...although the pre-FTP definition there was clearer...
19:52:45 <julianleviston> geekosaur: my suspicion is synergistics is in GHCi.
19:52:46 <geekosaur> :t sequence $ map print [1,2,3]
19:52:47 <lambdabot> IO [()]
19:52:59 <synergistics> geekosaur: Oh, ok. So IO actions are only called im main?
19:53:20 <julianleviston> http://www.happylearnhaskelltutorial.com/1/main_road.html
19:53:27 <julianleviston> synergistics: ^ that might explain.
19:53:36 <dramforever> synergistics: rather, only main, the IO action, gets called
19:53:43 <geekosaur> well, ghci has some special stuff where it recognizes that some expression produces an IO type and runs the IO action (by sequencing it into ghci's own main)
19:54:17 <synergistics> dramforever: Since it's action is a combination of actions?
19:54:21 <synergistics> Or can be
19:54:25 <Shockk> synergistics: an IO action is just a value and doesn't do anything by itself
19:54:33 <geekosaur> the point is that an IO something is just another value, and is only "executed" if it gets added to the sequence of IO actions that is the "result" of main :: IO a
19:54:34 <dramforever> synergistics: yep :)
19:55:11 <Shockk> the point of entry you have to be able to run IO actions is the fact that the runtime system computes main's IO action
19:55:15 <dramforever> :t print
19:55:17 <lambdabot> Show a => a -> IO ()
19:55:51 <Shockk> I swear that sounded coherent in my head before I typed it out
19:56:03 <geekosaur> welcome to my night >.>
19:56:05 <dramforever> i.e. takes a showable value, returns an action that results in a useless value
19:56:07 <synergistics> Haha
19:56:20 <dramforever> *an
19:56:28 <dramforever> hmm.. *a
19:56:40 <julianleviston> synergistics: this point is actually one of the most beautiful things about Haskell, IMO
19:57:08 <synergistics> julianleviston: It already seems interesting
19:57:14 <julianleviston> synergistics: :)
19:57:34 <geekosaur> anyway, consider that if IO actions just executed wheneer created, then you could never do anything conditionally
19:58:01 <geekosaur> you have to be able to choose whether to sequence it to main or not, to do them conditionally
19:58:05 <synergistics> So something of the type (IO a) is just a value that has the *potential* to make outside interactions, making it obvious which values can do that
19:58:20 <geekosaur> you can think of a value of type IO a as a little program
19:58:24 <geekosaur> it has to be run to do anything
19:58:27 <synergistics> :D
19:58:37 <dramforever> yes. well "potential" sounds strange, but basically yes
19:58:49 <Shockk> in some little projects of mine in the past for example, I've actually had functions return an IO action but my code that calls the function doesn't sequence it, it would put it in a list or something and only sequence all the actions in that list at a later time of my choosing; 
19:58:50 <julianleviston> synergistics: it‚Äôs a value, that *is* instructions on how to do input/output. 
19:59:03 <Shockk> it's fun to take full advantage of IO actions being a regular value
19:59:19 <dramforever> I think I saw this analogy on reddit: ls is not a list of files
19:59:28 <geekosaur> Shockk, in a certain sense, that is what the free monad is all about
19:59:31 <synergistics> I would have completely glossed over that detail for a while probably, thanks
19:59:41 <dramforever> IO [FilePath] to [FilePath] is like ls to a list of files
20:00:01 <geekosaur> only there it's choosing not just whether, but *how* to sequence them, at some later time
20:00:09 <synergistics> Hmmmm. That makes perfect sense to me
20:00:20 <Shockk> I think I also might have returned some priority or something, at one point, and sorted the actions by priority before sequencing them
20:00:33 <Shockk> geekosaur: I'll need to look into that when my hands aren't freezing off and it's not 4am
20:00:41 <k4pod> I highly enjoyed this paper on monadic IO in haskell: http://courses.cms.caltech.edu/cs11/material/haskell/papers/tackling_the_awkward_squad.pdf
20:01:27 <synergistics> k4pod: Thanks, I'll read that later
20:03:45 <adas> if I have multiple "Strings" is there a way to specify the type only once for all the bindings?
20:04:05 <adas> instead of having to specify the type as "String" for every binding
20:04:23 <pavonia> foo, bar, baz :: String
20:04:24 <dramforever> s,t,r,i,n,g :: String
20:05:18 <adas> oh cool. thanks. I did not know that. but is that style of type annotating okay to use?
20:05:44 <dramforever> adas: IMHO it's for exactly that purpose
20:10:39 <adas> thanks. it definitly helps
20:11:29 <pikajude> should i use parsec or polyparse?
20:14:08 <bitemyapp> pikajude: trifecta
20:14:14 <bitemyapp> pikajude: only way to fly
20:14:29 <pikajude> unless you want to parse something besides a string...
20:15:11 <bitemyapp> pikajude: what are you parsing?
20:15:17 <pikajude> XML "Event"s
20:15:32 <bitemyapp> so an AST in a datatype?
20:15:44 <pikajude> it's not really a tree
20:15:49 <pikajude> it's linear
20:15:57 <pikajude> EventBeginElement, EventEndElement, and so on
20:16:26 <bitemyapp> if it's linear you could use pipes-parse or pipes-attoparsec, or similar.
20:16:41 <exio4> the output of a lexer? 
20:16:43 <bitemyapp> although I don't know if a non-string instance of ParserInput would work or not.
20:17:00 <pikajude> exio4: yes
20:17:08 <pikajude> though given the fact that the library that produces the Events already depends on conduit
20:17:13 <pikajude> I might just rewrite the parser, and then I could use trifecta
20:17:33 <bitemyapp> I would've either used an xml library to start or written it in trifecta personally, but YMMV.
20:17:53 <bitemyapp> could also funnel xml-conduit to a streaming parser written in terms of conduit
20:20:22 <pikajude> well I definitely need to write my own parser because i'm, uh, pickling
20:20:24 <pikajude> or whatever it's called
20:20:30 <pikajude> converting an XML document to my own datatype
20:20:46 <pikajude> xml-conduit already provides a parser, but it's written in a really frustrating way
20:21:44 <ayytrlmao> in layman terms, what is the purpose of haskell's zip3 ?
20:21:50 <ayytrlmao> I mean what good can it be for
20:22:55 <kadoban> :t zip3
20:22:57 <lambdabot> [a] -> [b] -> [c] -> [(a, b, c)]
20:23:11 <kadoban> ayytrlmao: Do you understand the purpose of zip2?
20:23:18 <kadoban> Or zip I guess it is, heh.
20:23:35 <ayytrlmao> kadoban: No
20:23:55 <ayytrlmao> I don't understand any zips
20:24:15 <kadoban> ayytrlmao: Trying hard to find any explanation that's not just a restatement of the type of it ‚Ä¶
20:24:18 <kadoban> :t zip
20:24:19 <lambdabot> [a] -> [b] -> [(a, b)]
20:24:49 <kadoban> ayytrlmao: You use it when you have two separate lists that you want to combine into one conceptual list of things, piece by piece.
20:25:00 <pikajude> > zip [1,2] [3,4]
20:25:03 <lambdabot>  [(1,3),(2,4)]
20:25:21 <ayytrlmao> hmmm
20:25:27 <geekosaur> regular zips are useful for grouping things together, often with some kind of tag
20:25:28 <kadoban> I usually find zipWith more useful, generally. That probably doesn't help much though.
20:25:32 <kadoban> :t zipWith
20:25:34 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
20:25:34 <dramforever> > zip [1..] "also numbering things :)"
20:25:36 <lambdabot>  [(1,'a'),(2,'l'),(3,'s'),(4,'o'),(5,' '),(6,'n'),(7,'u'),(8,'m'),(9,'b'),(10...
20:25:50 <ayytrlmao> dramforever: Wow
20:25:55 <ayytrlmao> dramforever: that works
20:25:56 <geekosaur> so for example where in some other langiuage you'd use a for loop with an index, in Haskell you zip with [1..] and map or fold oer the result
20:26:14 <kadoban> That's a nice example.
20:26:19 <ayytrlmao> Ohh
20:26:19 <pavonia> pikajude: What feature do you need that already existing parsers don't provide?
20:26:30 <ayytrlmao> That feels just nice
20:26:37 <geekosaur> in some ways it's the more generalized version (zipWith) that is more interesting, because instead of making a tuple you apply a function to the things being "zipped"
20:26:38 <pikajude> pavonia: i don't know what library to use that would do what I want
20:27:12 <dramforever> ayytrlmao: yeah in haskell many things just somehow fall together
20:27:16 <pavonia> pikajude: Any library that parses XML into an AST would work, no?
20:27:59 <ayytrlmao> dramforever: Thanks.
20:28:41 <pikajude> pavonia: yeah, I suppose so
20:28:54 <pikajude> I just feel like writing the conversion could be easier
20:28:57 <pikajude> than pattern matching on an AST
20:29:55 <kadoban> Is there an easier algorithm to solve this other than topological sorting?: I want to reorder a list such that if (xs !! j) `isPrefixOf` (xs !! i), then i <= j, for all i,j in [0..length xs - 1]
20:30:13 <kadoban> Or not really an easier algorithm necessarily, more ‚Ä¶ what's the minimum amount of code I have to write for this?
20:33:16 <kadoban> There's no duplicates in the list of course.
20:34:11 <conal> Has anyone here played with GHC's type-level natural numbers much? I'm saying "instance Functor (Vec n) => Functor (Vec (1 + n)) where ..." and getting "Illegal type synonym family application in instance: Vec (1 + n)".
20:34:30 <conal> I haven't found any similar examples in the docs.
20:37:37 <pikajude> pavonia, do you know of a library that's good for turning an XML tree into an arbitrary datatype?
20:38:53 <julianleviston> Isn‚Äôt TagSoup relevant here?
20:38:59 <julianleviston> Sorry if noise.
20:39:42 <pikajude> it looks like tagsoup is just for parsing bad XML or bad HTML
20:39:55 <julianleviston> ok apologies.
20:40:24 <pavonia> pikajude: Hhm no, but there are a lot of packages on Hackage. You could check the number of download for some to see which is used freuqently
20:41:01 <pikajude> i've searched hackage a couple times
20:41:07 <pikajude> I guess I'll use xml-conduit, it's the closest thing I've found
20:41:18 <kadoban> Hmm, yeah I'll just topological sort I guess.
20:41:25 <pikajude> I just don't like the fact that every parser returns Maybe a
20:41:29 <julianleviston> pikajude: have you looked at http://hackage.haskell.org/package/hxt ?
20:41:29 <pikajude> because it's so tedious to unwrap
20:41:51 <pikajude> i'm not smart enough to understand hxt
20:41:52 <julianleviston> pikajude: can you use the maybe or fromMaybe function(s) to unwrap them?
20:42:22 <pikajude> oh, there's a documentation page
20:42:53 <pikajude> julianleviston: of course I can, the only reason I bring it up is because parse failure is usually something implicitly defined in the Applicative or Monad instance for the parser
20:43:05 <pikajude> and not something you have to manually do for every possible failure
20:43:38 <pikajude> hxt does seem like it could do what I want though
20:43:40 <julianleviston> pikajude: isn‚Äôt that a good thing, though?
20:43:46 <julianleviston> oh that‚Äôs good then :)
20:43:57 <pikajude> if it's a good thing, why did anybody write a parser library to begin with
20:43:58 <Cale> pikajude: What do you want to have happen when the XML isn't of the form you wanted?
20:44:02 <Encapsulation> EXCUSE ME SIR
20:44:35 <pikajude> Cale: ideally, information about what node wasn't there or what content was ill-defined
20:44:41 <pikajude> in the worst case, Nothing instead of Just myCart
20:45:12 <Cale> "<pikajude> I just don't like the fact that every parser returns Maybe a" -- did you mean rather than Either String a or something?
20:46:06 <pikajude> no, I meant that the way xml-conduit's parser is written, the "tag" parser returns `Parser (Maybe a)` where `a` is the datatype the user wants, rather than just, you know, `Parser a`
20:46:40 <pikajude> when normally the `Parser` type encapsulates failure as one of the possible outcomes
20:46:56 <julianleviston> yeah but there might be no value in there
20:47:02 <julianleviston> what should it do when there‚Äôs no value?
20:47:31 <monochrom> I don't know xml-conduit or its "tag". but I know parsec's "option" is also a "Parser (Maybe a)" and it is exactly right.
20:48:02 <pikajude> but there's no "required" version of tag
20:48:06 <pikajude> tag is the primitive
20:48:19 <Cale> pikajude: ah, okay
20:48:30 <pikajude> julianleviston: the parser should fail, lol..
20:48:58 <pikajude> I mean, when writing parsec parsers, do you all wrap every combinator in `option`?
20:49:00 <pikajude> is that a thing?
20:49:00 <julianleviston> pikajude: obviously I must have missed something. Nevermind.
20:49:09 <Cale> pikajude: another one to maybe look at is hexpat-pickle
20:49:40 <monochrom> "option" is a thing. but it's true that I don't always use it.
20:49:48 <pikajude> Cale: this looks way nicer
20:52:15 <enthropy> conal: I think you'd have to make an overlapping instance (Functor (Vec n), sn ~ (1+n)) => Functor sn
20:53:04 <conal> oh! could ghc handle the resolution, choosing between the two instances?
20:53:16 <conal> i've also written to iavor to ask.
20:56:22 <enthropy> conal: well instance Functor (Vec 0) would get chosen over instance Functor (Vec n), in the usual way
20:56:45 <enthropy> Nat doesn't get special treatment
20:57:03 <conal> enthropy: i see. thanks.
20:57:03 <monochrom> the overlapping instance extension still comes with a restriction that guarantees resolution.
20:57:43 <monochrom> the exact restriction is in the GHC user's guide
20:58:09 <monochrom> only the incoherent instance extension takes away that restriction
20:59:19 <conal> monochrom: ah. thanks. time for me to read up on overlapping instances.
21:08:12 <nitrix> With stack, how do I install one package into another package's sandbox?
21:08:24 <nitrix> Given those sandboxes are apparently abstracted now.
21:08:41 <nitrix> I never had to install a package manually before.
21:08:54 <nitrix> (not on hackage)
21:11:22 <flounders> If it's for the package, I've just changed the cabal file, put the imports in the source and just launch stack ghci.
21:11:56 <flounders> Assuming everything else is setup.
21:15:15 <flounders> Sorry the bit about it being not on hackage didn't register.
22:05:31 <saurabhnanda> hey, all the good people, any help with http://stackoverflow.com/questions/35110888/how-write-a-function-that-returns-values-of-different-types ?
22:05:56 <saurabhnanda> Question = How write a function that returns values of different types?
22:07:17 <Cale> saurabhnanda: type class?
22:07:21 <keko-2> you can use the wrapper datatype that you suggested, or a typeclass
22:08:08 <saurabhnanda> Cale: how will a typeclass work? 
22:08:12 <Cale> Is the type of the result determined by the user of rpcId2HaskellType or by that function itself?
22:08:12 <saurabhnanda> Cale: Maybe is a typeclass, right?
22:08:16 <Cale> no
22:08:17 <keko-2> no
22:08:26 <Cale> Read is a type class
22:08:29 <Cale> :t read
22:08:30 <lambdabot> Read a => String -> a
22:08:42 <Cale> > read "4" :: Integer
22:08:44 <lambdabot>  4
22:08:46 <Cale> > read "4" :: Double
22:08:48 <lambdabot>  4.0
22:08:52 <keko-2> for example, aeson (JSON library) defines this function: decode :: FromJSON a => ByteString -> Maybe a
22:08:55 <Cale> > read "[1,2,3]" :: [Integer]
22:08:55 <julianleviston> saurabhnanda: the way you have it in the SO is good.
22:08:56 <lambdabot>  [1,2,3]
22:08:58 <keko-2> where FromJSON is the typeclass
22:09:22 <saurabhnanda> okay, sorry. Tyepclass isan interface
22:10:44 <saurabhnanda> okau
22:10:58 <saurabhnanda> so thinking about the typeclass approach, how does the following signature look:
22:11:14 <saurabhnanda> rpcId2Haskell :: (FromJSON a) => String -> a
22:13:31 <glguy> That's fine as long as the user of that function gets to pick the return type
22:14:12 <saurabhnanda> how does this look? http://lpaste.net/151292
22:14:54 <glguy> That looks like it probably doesn't compile
22:15:35 <glguy> You don't get to pick the return type when you're implementing rpcId2Haskell with the type you've given above
22:15:48 <glguy> you need to support all types that are instances of FromJSON
22:15:59 <saurabhnanda> this is how  I'm thinking I'll use it: http://lpaste.net/151292
22:19:53 <saurabhnanda> any idea how I can get this to work without using algebraic data types?
22:21:20 <julianleviston> saurabhnanda: why?
22:21:47 <saurabhnanda> julianleviston: why without algebraic data types?
22:21:53 <julianleviston> saurabhnanda: yep.
22:22:33 <saurabhnanda> julianleviston: just trying to understand the different ways of structuring a solution. Also, algebraic types seem like a bit of boilerplate to me, in this particular scenario.
22:23:08 <saurabhnanda> julianleviston: I don't have any other use of that algebraic data-type in my program. 
22:23:13 <julianleviston> saurabhnanda: a function is from one (1) type to another, right?
22:23:25 <julianleviston> saurabhnanda: this is what a function is. A relation - a mapping between two types.
22:23:50 <julianleviston> saurabhnanda: so if you wanted to return something that is String or Int, then you want their Sum.
22:24:04 <scutigera> filterM (\(f1, f2) -> liftM2 (&&) (doesFileExist f2) (F.newer f1 f2)) files
22:24:06 <julianleviston> saurabhnanda: meaning you want the inclusion of those two types.
22:24:24 <julianleviston> saurabhnanda: this is exactly what algebraic datatypes offer‚Ä¶ 
22:24:42 <scutigera> while i'm proud of the fact that i could use liftM2 in a sentence- the && does not short circuit, so if file2 does not exist - the expression throws an error.
22:25:28 <scutigera> what should i be doing ?
22:28:00 <saurabhnanda> julianleviston: let me chew on that. 
22:28:24 <julianleviston> saurabhnanda: ok :)
22:29:03 <julianleviston> saurabhnanda: this might be helpful! http://www.happylearnhaskelltutorial.com/1/function_magic.html (along with the preceding chapters)
22:29:36 <julianleviston> saurabhnanda: sorry, not the preceding one, this one: http://www.happylearnhaskelltutorial.com/1/types_jigsaw.html
22:30:51 <julianleviston> Really need to get to the one that explains abstract data types tho...
22:30:59 <julianleviston> on the cards. :0
22:47:05 <scutigera> fileList <- mapM ((liftM PF.modificationTime) . PF.getFileStatus) filenames
22:47:20 <scutigera> is that a good way to write that ?
22:51:51 <mniip> you can get rid of the inner ()
22:51:54 <mniip> otherwise not too bad
22:52:00 <mniip> oh and they left
22:52:29 <nitrix> Hi, how do I specify which package to use?
22:52:38 <nitrix> This library annoyingly comes with a main too.
22:53:15 <nitrix> stack repl is giving me this beautiful error that the library's main was chosen over mine.
22:53:19 <nitrix> ghci*
23:11:09 * hackagebot rebase 0.1.5 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.1.5 (NikitaVolkov)
23:11:11 * hackagebot rebase 0.2 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.2 (NikitaVolkov)
23:11:13 * hackagebot phoityne 0.0.3.0 - ghci debug viewer with simple editor.  https://hackage.haskell.org/package/phoityne-0.0.3.0 (phoityne_hs)
23:20:23 <Hafydd> nitrix: in GHC, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#idp46760143221072
23:20:57 <Hafydd> Er... that links a bit broken. Look for "Package-qualified imports" on that page.
23:22:16 <nitrix> That isn't what I'm looking for.
23:22:48 <Hafydd> Oh. In Stack, I don't know.
23:22:52 <nitrix> "The main module to load is ambiguous. Candidates are:"
23:23:39 <nitrix> I'm looking for a config alternative to ghci --main-is app:exe:app
23:30:45 <pikajude> is PU t a (from hxt) a Bifunctor?
23:35:48 <M-Illandan> julianleviston: I saw your ANN on haskell-cafe. Good going :-)
23:36:20 <M-Illandan> julianleviston: Are you targeting programmers or absolute beginners? 
23:36:32 <MarcelineVQ> pikajude: Do you have a link? All I can find is PU a
23:36:52 <pikajude> MarcelineVQ: i meant hexpat-pickle, not hxt. my mistake!
23:36:54 <pikajude> for posterity, http://hackage.haskell.org/package/hexpat-pickle-0.6/docs/Text-XML-Expat-Pickle.html#t:PU
23:39:40 <pikajude> basically it represents a (t -> a) and (a -> t)
23:39:44 <M-Illandan> julianleviston: Never mind, I see that you have already answered that. Anyway, congratulations and good luck!
23:39:53 <pikajude> whereas I guess Bifunctor represents two separate fields
23:40:20 <pikajude> maybe it's a Profunctor
