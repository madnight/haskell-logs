00:00:26 <refreshFoo> c_wraith: is this (1) assuming that I'm using Lazy Bytestring or (2) works with plain Bytestring due to haskell's laziness ?
00:27:40 <Tene> Hey, anyone know what I can add to my stack.yaml to turn on profiling, so I don't have to always remember to pass --enable-executable-profiling --enable-library-profiling ?
00:33:40 <kadoban> Tene: There currently isn't a way to do that. I know there's current discussions towards adding that ability. https://github.com/commercialhaskell/stack/issues/1438 and https://github.com/commercialhaskell/stack/issues/846
00:41:13 <Tene> Hmm.  I'm running "stack build --trace --profile --enable-executable-profiling --enable-library-profiling --library-profiling --executable-profiling --force-dirty" and I still get a binary that complains that it wasn't built with -prof when run with +RTS -p
00:41:19 <Tene> Any ideas what I'm doing wrong here?
00:42:40 <hunteriam> what should I use to write a javascript client in haskell?
00:42:45 <Tene> Ah, I needed "stack exec -- foo +RTS -p
00:42:46 <hunteriam> like a front end application
00:43:55 * hackagebot lifted-async 0.8.0 - Run lifted IO operations asynchronously and wait for their results  https://hackage.haskell.org/package/lifted-async-0.8.0 (MitsutoshiAoe)
00:45:04 <hunteriam> also, do you guys think i should use an "Authorization" header for communicating a session token, or should i set a cookie?
00:47:24 <bollu> why are there some forms of logic without the law of excluded middle?
00:49:17 <jle`> hunteriam: try looking at `reflex` for front-end work in haskell
01:00:41 <Cale> bollu: Think about Either in Haskell.
01:01:03 <Cale> (though Haskell is not the best example, because it is Turing complete, so you can loop infinitely)
01:01:55 <Cale> bollu: anyway, ignoring infinite loops (corresponding to circular logic by which you could prove anything), the only way to get a value of type Either a b is to either apply Left to a value of type a, or apply Right to a value of type b
01:02:19 <Cale> bollu: So there will exist a value of type Either a b, if there is a value of type a, or if there is a value of type b
01:02:55 <Cale> bollu: So we can sort of interpret Either logically as "or"
01:03:05 <Cale> bollu: But now think about what LEM says
01:03:20 <Cale> oh, I should introduce negation as well, I suppose :)
01:03:30 <Cale> and probably say a bit more
01:04:12 <Cale> bollu: We might think about, in an appropriate system (like Coq or Agda as good examples, better than Haskell), types as being like propositions or statements which may or may not be provable
01:04:24 <Cale> bollu: and terms of those types as being proofs of the propositions
01:04:38 <shachaf> The reason the law of excluded middle doesn't really work with Either is that Either is making a stronger statement than classical disjunction. In fact it's a stronger statement than you really can make classically.
01:04:42 <shachaf> Well, I should just let Cale talk.
01:04:47 <Cale> yeah
01:04:51 <Cale> That's a good summary
01:05:02 <Cale> heh, depending on how quickly we want to get to the point
01:05:29 <Cale> bollu: In logic, if you want to prove A -> B (that is, "A implies B"), you start by assuming you have A, and try to derive B from there
01:06:16 <Cale> bollu: In lambda calculus, if you want to construct a function of type A -> B, you start by assuming you have a variable x of type A, and try to construct a term y of type B using it
01:06:22 <Cale> and then (\x -> y) is your function
01:06:44 <Cale> bollu: In logic, if you have that A -> B, and you have that A, then you can obtain B
01:07:12 <Cale> bollu: In lambda calculus, if you have f : A -> B, and x : A, then you have f x : B
01:08:14 <Cale> bollu: Lambda calculi mirror most of the usual properties of logic in this way, with pair types corresponding to logical conjuction (that is, AND), and sum types like Either corresponding to logical disjunction (OR)
01:08:33 <bollu> Cale: okay, right
01:09:08 <Cale> bollu: We can define the type Not A as being the type of functions from A to an "empty" type -- one with no data constructors
01:09:22 <Cale> (the type might turn out to be inhabited anyway if the logic is inconsistent)
01:09:39 <bollu> Cale: bottom? or Void? data Void <- this one?
01:09:44 <Cale> Void
01:09:59 <bollu> oh, okay
01:10:18 <Cale> (and it turns out Haskell is inconsistent, so you can get values of type Void, though it's just bottom)
01:10:36 <Cale> :t fix
01:10:38 <lambdabot> (a -> a) -> a
01:10:40 <Cale> :t fix id
01:10:41 <lambdabot> a
01:10:44 <Cale> ^^ you can prove anything
01:10:59 <Cale> So, Haskell's type system isn't so good for truth
01:11:08 <exio4> we just need to disable turing completeness! {-# LANGUAGE NoTuringComplete #-}
01:11:10 <Cale> But it's close enough for jazz :)
01:11:14 <bollu> Cale: wait, what? that's one way to think of fix I guess...
01:11:21 <bollu> Cale: that is insanely cool
01:11:25 <bollu> Cale: and go on :)
01:11:28 <exio4> @type head [] 
01:11:29 <lambdabot> a
01:11:31 <mjrosenb> isn't that just an artifact of it being turing complete?
01:11:32 <Cale> Okay, so now think about what LEM says
01:11:42 <Cale> It says  forall a. Either a (Not a)
01:11:48 <bollu> yes
01:12:01 <Cale> Now, if this is to be a defined thing
01:12:36 <Cale> then, well, we're really screwed by parametricity: we know that if it gives Left x for some type, then it'll always give Left something
01:12:54 <bollu> yes, gotcha
01:13:00 <bollu> because of the forall a. 
01:13:21 <Cale> But ignoring that problem, if we let it be a nontrivial (dependent) function from the type of types
01:13:26 <Cale> then it's an oracle
01:13:37 <bollu> Cale: what does that mean
01:13:38 <Cale> which tells us the answer to every question
01:13:53 <Cale> Okay, so in Coq and other dependently typed languages
01:14:53 <Cale> We have for any type A, and any function P: A -> Type, i.e. a function which assigns some type to each of the values of type A
01:15:20 <bollu> Cale: isn't that what (:t) does in GHCi? (in some sense?)
01:15:20 <Cale> we have the type  Pi (x:A), P(x) -- which is the type of functions which given some x in A, will produce a result of type P(x)
01:15:25 <Cale> uh
01:15:31 <Cale> no, I mean, for example
01:16:01 <Cale> We can have a type constructor Vector, which rather than depending on another type, like type constructors in Haskell do
01:16:11 <Cale> instead depends on a natural number
01:16:25 <Cale> Like, Vector n a would be vectors of length n of elements of type a
01:16:28 <Cale> perhaps
01:16:39 <hunteriam> does anyone know of something already written to parse cookie strings?
01:16:42 <Cale> and then Vector itself would have type  Natural -> Type -> Type
01:16:43 <bollu> huh, so the type constructor can take values from data as parameters?
01:16:46 <bollu> I see
01:16:47 <Cale> yep
01:16:53 <Cale> That's what dependent typing is all about
01:17:21 <Cale> So, we can construct then a type like  Pi (n: Natural), Vector n a
01:17:21 <shachaf> This is a detour from where I expected the conversation to go.
01:17:26 <Cale> yes
01:17:38 <Cale> I felt like introducing some things properly so I can actually write down LEM
01:18:00 <Cale> (I need a Pi type over the universe :)
01:18:31 <Cale> So, a function  f : Pi (n:Nat), Vector n a
01:18:35 <Cale> takes a natural number n
01:18:43 <Cale> and gives a Vector of length n of values of type a
01:18:51 <Cale> (probably should have picked an a)
01:18:57 <Cale> Or for instance, we might have
01:19:19 <Cale> replicate : Pi (n:Nat), a -> Vector n a
01:19:50 <Cale> So, it takes a natural number n, and an element of type a, and gives us a vector of length n
01:19:52 <bollu> Cale: okay, 
01:19:54 <hunteriam> Cale: could the output type of a function depend on the input value?
01:19:57 <Cale> There aren't many ways to implement that :)
01:20:07 <Cale> hunteriam: yes, that's exactly what these Pi types are
01:20:20 <Cale> Function types where the result type of the function depends on the input value
01:20:27 <Cale> Pi (x:A), B(x)
01:20:41 <hunteriam> B(x)?
01:20:49 <hunteriam> is this a type and a function together?
01:20:52 <Cale> is the type of functions which given x of type A, will produce a result of type B(x)
01:20:58 <bollu> Cale: what's the notation? Pi (n:Nat), a -> Vector n a
01:21:07 <bollu> it means that n inhabits Nat, and "a" is any type?
01:21:18 <hunteriam> Cale: aka MyType 1 = Bool, MyType 2 = String ...
01:21:33 <hunteriam> myType*
01:21:49 <Cale> It's the type of functions which given some natural number n, will produce (a function which given some value of type a, will produce a result of type Vector n a)
01:22:12 <Cale> See how the type of result of the overall function depends on the type of the input?
01:22:18 <Cale> and we might write something like
01:22:46 <hunteriam> i mean that means you have functions which return types right?
01:22:50 <Cale> append :: Pi (n:A), Pi (m:A), Vector n a -> Vector m a -> Vector (n+m) a
01:22:54 <hunteriam> that you could call in the type signature
01:22:54 <Cale> yes, you can
01:23:10 <hunteriam> haskells gonna be MESSY when this works
01:23:25 <Cale> Well, it works right now in Coq and Agda
01:23:27 <bollu> Cale: ah, so you can encode "effects" into the type-level
01:23:30 <Cale> But they were designed around it
01:23:48 <hunteriam> Theres just so many things you can do with it youd have to be very careful not to abuse it
01:23:57 <bollu> as in, you can encode compile-time invariants into the types, right?
01:24:00 <Cale> Sure, but it's really nice to have
01:24:07 <Cale> yes, you can encode all of mathematics with this
01:24:25 <Cale> Because the very next thing you can do is define a type for equality of values
01:24:34 <Cale> (of some type A)
01:24:39 <Cale> Something like
01:24:55 <Cale> (I'm inventing notation as I go along to try to make it familiar)
01:25:45 <hunteriam> Also it seems impossible to do this compile time
01:25:51 <Cale> nope, it's possible!
01:25:56 <bollu> Cale: something like equal :: (x : A, y : A) -> {True, False}? 
01:25:56 <hunteriam> how?
01:26:19 <bollu> where True and False, are types, not inhabitants of Bool
01:26:27 <hunteriam> bollu: compile time invariants?
01:27:08 <bollu> hunteriam: like, when I mappend two lists, their lengths are m + n, stuff like that. You know your "program invariants", right? or when you say tail, the length of a list reduces by 1
01:27:12 <Cale> data Id : Pi (A : Type), A -> A -> Type where Refl :: Pi (A : Type), Pi (x : A), Id A x x
01:27:19 <Cale> i.e.
01:27:39 <Cale> You have a type Id A x y of "proofs that x and y are equal values of type A"
01:27:54 <hunteriam> At some point do we want to be able to assign `types` to our types?
01:27:56 <Cale> and the only constructor for this type is a thing which gives you the proof that x is equal to itself
01:28:23 <Cale> hunteriam: Yeah, pretty much immediately, and it turns out we really secretly want an infinite sequence of things
01:28:34 <Cale> Where Type 0 : Type 1 and Type 1 : Type 2 and so on
01:28:38 <hunteriam> Cale: and why do we want that?
01:28:40 <bollu> Cale: what is Refl?
01:28:52 <Cale> It stands for Reflexivity
01:28:57 <Cale> and it's a data constructor
01:29:04 <Cale> which for any type A
01:29:08 <Cale> and any value x of type A
01:29:11 <hunteriam> Refl :: Pi (A : Type), Pi (x : A), Id A x x
01:29:14 <hunteriam> why are there commas
01:29:15 <Cale> gives you a value of type Id A x x
01:29:26 <Cale> hunteriam: traditional punctuation
01:29:34 <hunteriam> ?
01:29:34 <Cale> hunteriam: Sometimes the parens get left out
01:29:41 <bollu> okay, and we need Refl for?
01:29:42 <hunteriam> so a tuple?
01:29:52 <Cale> no, the comma might also be a dot
01:30:00 <Cale> it's about the same as the dot in forall a. ...
01:30:11 <hunteriam> wait what
01:30:15 <Cale> I'm just inventing syntax
01:30:18 <hunteriam> so what is the type of Refl
01:30:25 <hunteriam> are those constraints?
01:30:35 <Cale> So let's pick apart the type Pi (A : Type), Pi (x : A), Id A x x
01:30:44 <Cale> Remember that Pi (x:A), B x
01:30:49 <Cale> is the type of functions which
01:30:54 <Cale> when given some value x of type A
01:30:58 <Cale> produce a result of type B x
01:31:13 <hunteriam> B :: A -> Type?
01:31:14 <Cale> So Refl is a function
01:31:16 <Cale> yeah
01:31:25 <Cale> which given some type A
01:31:33 <Cale> and given some x of that same type
01:31:44 <Cale> produces a value of type Id A x x
01:31:54 <Cale> and moreover, it's a data constructor
01:32:24 <hunteriam> So this is the reflexive property
01:32:28 <Cale> so we can pattern match on a value of type Id A x y, and when we get Refl, the type checker is actually going to see that y really is x
01:32:48 <Cale> and it will start treating those two values as the same
01:32:53 <Cale> inside the case
01:32:57 <hunteriam> wait how will the compiler get Refl
01:33:02 <bollu> why will the type checker care if we pass x x or x y?
01:33:05 <bollu> when we construct Id?
01:33:15 <Cale> Well, if we write a function which accepts a value of type Id A x y
01:33:25 <Cale> say
01:33:32 <Cale> and we define it by pattern matching
01:33:41 <Cale> then when we pattern match on the Refl constructor
01:33:59 <Cale> the type checker will unify x and y, because Refl only builds values of type Id A x x
01:34:11 <Cale> So this lets us "use" equalities
01:34:12 <hunteriam> And Id is owned by Refl?
01:34:28 <Cale> Refl is a data constructor (the only data constructor) of the Id type
01:34:50 <hunteriam> i cant imagine when wed get an Id A x y
01:34:58 <Cale> Well, when we ask for one
01:35:05 <hunteriam> ?
01:35:06 <bollu> Cale: so it depends on the fact that Id only has Refl as the data constructor?
01:35:23 <Cale> hunteriam: I mean, we can write a function which takes a value of type Id A x y as an argument
01:35:37 <hunteriam> but we know thats just Id A x x
01:35:43 <hunteriam> cause you cant have Id A x y
01:35:49 <Cale> ah, we only know that once we get a *value* of that type
01:35:57 <Cale> Id A x y *might* be empty
01:36:11 <hunteriam> but there are no Id A x y where x != y
01:36:11 <bollu> Cale: what? how do we "ask for a value" of the type?
01:36:13 <Cale> But *if* there's a value of type Id A x y, then x must really be equal to y
01:36:14 <hunteriam> they cant be constructed
01:36:21 <bollu> Cale: the only constructor we have is Refl
01:36:21 <hunteriam> oh interesting
01:36:28 <Cale> bollu: By using Id A x y as the type of argument to a function
01:36:31 <bollu> so there can never be a case where x != y, right?
01:36:33 <hunteriam> so the type is still distinct from a value
01:36:42 <hunteriam> but it is dependant on a value
01:36:45 <bollu> Cale: but, if x ~ y?
01:36:58 <Cale> bollu: There can never (we hope) be a term whose type is Id A x y but x and y are not equal, because this would result in inconsistency
01:37:11 <hunteriam> i mean you literally cant construct one
01:37:14 <hunteriam> because you only have Refl
01:37:22 <bollu> hm, okay
01:37:26 <Cale> You can't construct one directly anyway
01:37:26 <bollu> continue :)
01:37:32 <hunteriam> ?
01:37:44 <Cale> If the logic/language is inconsistent, then we can construct a value of any type at all
01:37:49 <Cale> e.g. if we throw in fix
01:37:51 <Cale> :t fix
01:37:52 <lambdabot> (a -> a) -> a
01:37:57 <Cale> :t fix id
01:37:59 <lambdabot> a
01:38:03 <Cale> ^^ oops, proof of anything
01:38:12 <bollu> > fix id :: Void
01:38:15 <lambdabot>  Not in scope: type constructor or class ‘Void’
01:38:37 <bollu> > fix id :: Absurd # this is what ekmett calls it right?
01:38:39 <lambdabot>  <hint>:1:55:
01:38:39 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
01:39:05 <Cale> yeah
01:39:12 <Cale> I think?
01:39:15 <bollu> Cale: hm, okay, so as long as our system is consistent (i.e, we cannot write proofs of anything) our type will work
01:39:18 <Cale> Or he might use Void sometimes too
01:39:20 <Cale> But yeah
01:39:43 <hunteriam> fix is a proof of anything?
01:39:49 <Cale> We really really hope there's no way to get a value of type Id A x y if x and y aren't really equal, even if we can't formally prove this
01:39:55 <Cale> fix id is the proof of anything
01:40:08 <Cale> right?
01:40:09 <hunteriam> @type (fix id)
01:40:10 <lambdabot> a
01:40:12 <Cale> It's a value of any type
01:40:20 <hunteriam> if you can supply it a value
01:40:26 <hunteriam> oh
01:40:29 <Cale> Including types which represent statements which ought to be false
01:40:34 <hunteriam> nice
01:40:36 <Cale> or types with no data constructors
01:40:37 <hunteriam> types -> proofs?
01:40:43 <Cale> types -> propositions
01:40:46 <Cale> terms -> proofs
01:40:52 <hunteriam> nice
01:41:04 <Cale> Functions are implication
01:41:06 <hunteriam> but you couldnt prove negative things
01:41:11 <Cale> Sure you can!
01:41:19 <Cale> Not A = A -> Void
01:41:28 <hunteriam> ?
01:41:30 <Cale> sorry, I should parens
01:41:33 <bollu> Cale: why does that work?
01:41:35 <Cale> (Not A) = (A -> Void)
01:42:00 <hunteriam> i mean
01:42:01 <hunteriam> hm
01:42:07 <hunteriam> \x -> void?
01:42:08 <Cale> A function A -> B will give an assignment to each value x of type A, some value y of type B
01:42:15 <bollu> Cale: but how is that implemented?
01:42:20 <bollu> Cale: because Void is uninhabited
01:42:45 <hunteriam> i mean
01:42:50 <hunteriam> you could write a function to void
01:42:50 <Cale> The only way to get a function which takes a value of type A and produces a value of type B, is to somehow conclude that there's no value of type A
01:42:55 <hunteriam> nice
01:42:58 <Cale> i.e. that A is false
01:43:05 <hunteriam> e.g.?
01:43:14 <Cale> e.g.
01:43:28 <bollu> Cale: oh nice! because Void is uninhabited, A -> Void cannot happen ever
01:43:32 <bollu> right?
01:43:35 <hunteriam> unless A = void
01:43:36 <Cale> You might want to show that  Id Nat Z (S Z) -> Void
01:43:50 <ReinH> Sooo we were talking about LeM? ;)
01:43:53 <Cale> ahaha
01:43:53 <bollu> Cale: that x != x + 1?
01:43:56 <Cale> yeah, eventually
01:44:00 <Cale> right
01:44:15 <hunteriam> that 0 != 1
01:44:31 <ReinH> Cale: Or you could just talk about double negation elimination
01:44:42 <ReinH> maybe that's a more direct example of the difference?
01:44:54 <Cale> and to make that function in something like Coq or Agda, you'd start a pattern match on your value of type Id Nat Z (S Z), and then you'd just leave the pattern match empty
01:45:11 <bollu> "leave that pattern match empty" as in?
01:45:15 <bollu> = undefined?
01:45:21 <Cale> (or maybe write something that indicated there's no constructor which could possibly match)
01:45:27 <Cale> and the compiler will accept it because
01:45:32 <Cale> Refl is the only constructor
01:45:53 <hunteriam> but... how does it know it cant pattern match to Refl
01:45:54 <Cale> and Z and S Z are constructed by different constructors, and so can't be unified
01:46:33 <Cale> (there are lots of details of the implementation of the language I'm sort of introducing haphazardly, I'm aware)
01:47:21 <bollu> Cale: that sounds reasonable :) go on..
01:47:22 <hunteriam> timeline on using these things for making stuff?
01:47:46 <Cale> hunteriam: There's a C compiler written in Coq which is end-to-end verified
01:47:57 <Cale> hunteriam: But yeah, for everyday stuff...
01:48:03 <bollu> Cale: who verified the verifier? :P
01:48:08 <Cale> These languages aren't the best user experience
01:48:21 <Cale> Well, Coq itself has a very small kernel language
01:48:36 <Cale> and there are multiple informal proofs of the correctness of its implementation iirc
01:49:08 <Cale> It's designed to be as small and simple as possible so that you can convince yourself that the typechecker is correct :)
01:49:37 <ReinH> hunteriam: fyi https://www.youtube.com/watch?v=4i7KrG1Afbk
01:49:55 <bollu> Cale: alright :)
01:50:02 <Cale> okay
01:50:03 <Cale> so
01:50:05 <bollu> Cale: can you prove Coq is correct inside Coq?
01:50:05 <Cale> anyway, LEM
01:50:09 <Cale> bollu: no
01:50:10 <bollu> (sorry for the diversion)
01:50:16 <ReinH> No. You can do addition in Coq.
01:50:17 <bollu> Cale: because godel? turing?
01:50:17 <Cale> bollu: At least, we hope
01:50:19 <ReinH> So you can't.
01:50:25 <bollu> ReinH: :)
01:50:27 <bollu> Cale: okay, go on
01:50:28 <Cale> If you could, then Coq would certainly be inconsistent
01:50:37 <Cale> sadly
01:51:09 <Cale> Anyway
01:51:21 <Cale> LEM : Pi (A: Type), Either A (Not A)
01:51:26 <u-ou> thanks, godel :(
01:51:35 <Cale> imagine what you could do with such a function if it were real
01:51:43 <Cale> You can apply it to some type
01:51:54 <Cale> and it will give you either a proof that the thing is true
01:51:57 <Cale> or a refutation
01:52:09 <Cale> and all it takes to know which is a pattern match
01:52:09 <bollu> Cale: now are you going to run LEM on Not(LEM) ?
01:52:14 <Cale> Nope
01:52:24 <ReinH> bollu: (On the other hand, you can also use Coq to very Godel's incompleteness theorem http://r6.ca/Goedel/goedel1.html)
01:52:30 <Cale> LEM is logically consistent with everything else
01:52:30 <ReinH> s/very/verify
01:52:35 <Cale> You can't break the system by assuming it
01:52:44 <Cale> however, you destroy the computational interpretation
01:53:11 <bitemyapp> ReinH: well that's cute
01:53:14 <Cale> and terms with LEM in them (or other axioms that you introduce which aren't a real part of the language), will just be stuck and fail to evaluate further
01:53:47 <ReinH> bitemyapp: :)
01:53:55 <Cale> So you can introduce LEM as an axiom in Coq, but it's hard to write software that uses anything you build with it
01:54:06 <bollu> Cale: because none of it evaluates?
01:54:09 <Cale> right
01:54:32 <Cale> it just gets stuck somewhere, and you try to pattern match and your case expression doesn't reduce and then more stuff doesn't evaluate, and so on
01:54:48 <ReinH> oh it's easy to write it...
01:55:09 <ReinH> just don't try to run it
01:55:14 <Cale> right
01:55:22 <bollu> Cale: (because we had said that Id A x y = <don't compute> 
01:55:22 <bollu> ?
01:55:26 <hunteriam> ReinH: +1 video
01:55:31 <Cale> Because to really have a computational interpretation of LEM, we'd have to know the answer to every question
01:55:55 <Cale> bollu: no, you can pattern match on values of type Id A x y
01:56:02 <shachaf> There's a perfectly reasonable computational interpretation of LEM.
01:56:09 <Cale> bollu: and in the branch of the case where you match refl
01:56:14 <shachaf> It's not very useful for proving theorems, but it's useful for computation.
01:56:21 <Cale> bollu: the type checker unifies x and y
01:56:29 <ReinH> hunteriam: he's done a couple screencasts as well on the youtubes, e.g., https://www.youtube.com/watch?v=fVBck2Zngjo
01:56:32 <ReinH> I hope he does more
01:56:33 <bollu> Cale: and in the other branch?
01:56:35 <bollu> ReinH: thanks!
01:56:36 <Cale> shachaf: Oh, good point, we can technically prove LEM in Haskell ;)
01:56:43 <shachaf> Well, not in Haskell.
01:57:09 <Cale> bollu: There is no other branch, because Refl is the only data constructor :D
01:57:36 <Cale> bollu: It turns out you can write functions for the other basic properties of equality
01:57:44 <Cale> bollu: like we can write this function:
01:57:58 <Cale> symmetry : Id A x y -> Id A y x
01:58:19 <Cale> symmetry (Refl A x) = Refl A x
01:58:25 <bollu> Cale: huh, and transitivity as well?
01:58:37 <Cale> actually, that type signature needs some Pis in it :)
01:58:40 <Cale> but I'm being lazy
01:58:44 <Cale> yep
01:59:02 <Cale> When we match the Refl, then y and x unify
01:59:10 <Cale> and so we only need to produce something of type Id A x x
01:59:21 <Cale> instead of Id A y x
01:59:30 <Cale> and we can do that using Refl of course
02:00:07 <Cale> and inductive proofs of equality turn into recursive functions
02:00:19 <ReinH> (I wish I understood why mathematicians chose certain symbols for certain things. E.g., sigma for sum I can understand, but Pi?)
02:00:46 <Cale> You might pattern match on a natural number, and recursively use your proof that Id A (f n) (g n) to construct a proof of Id A (f (S n)) (g (S n)) somehow
02:01:02 <Cale> Pi for product
02:01:13 <Cale> any others? :)
02:01:38 <ReinH> but... how is... oh.
02:01:41 <bollu> Cale: Xeta
02:02:08 <ReinH> ok never mind
02:02:19 <bollu> and how is your function a product?
02:07:08 <`Guest00000> i want to compute some data at compile time and then output it as result of compilation
02:07:14 <`Guest00000> like, .wav instead of .exe
02:07:37 <`Guest00000> how to do that with GHC?
02:10:09 <ReinH> `Guest00000: You can't?
02:10:40 <ReinH> I don't know why you'd expect GHC to produce .wav files.
02:12:46 <Maxdamantus> I want to write some code that causes GHC to search the computer it's running on for credit card details and send them to me.
02:12:54 <Maxdamantus> How to do that?
02:13:08 <ReinH> o_O
02:13:34 <ReinH> Things get weird in here late at night.
02:14:11 <Axman6> `Guest00000: you can use template haskell to do that, but I don't see why you'd want to
02:14:16 <hunteriam> Cale: a funciont a -> Type is a proof that `Type` holds for a?
02:14:27 <u-ou> there's no such thing as night on irc ;o
02:14:34 <Axman6> only darkness
02:14:38 <u-ou> haha
02:14:47 <deni> ReinH: tnx for the mtl rwh explanation yesterday (I had to go afk then and just saw it now)
02:14:56 <ReinH> yw
02:15:05 <Cale> hunteriam: heh, you can think of it as a proof that if there is a value of type A, then there exists a Type
02:15:14 <Fuco> Maxdamantus: simplest way would be to simply spawn grep and look for 16 digit numbers
02:15:21 <Cale> hunteriam: however, it's probably more useful in this case to think of it as a function from values of type A to types
02:15:46 <Maxdamantus> Credit cards can have numbers of digits other than 16.
02:16:34 <hunteriam> Cale: https://youtu.be/4i7KrG1Afbk?t=996 makes it sound like (a -> Type) is what were proving?
02:16:41 <Maxdamantus> You'd probably want to make use of the one-digit checksum at the end of every valid credit card number.
02:16:59 <bollu> Cale: okay, back to excluded middle :)
02:17:24 <Cale> bollu: Oh, okay, I didn't actually have all that much more to say about LEM, but I can say something more about it in the context of HoTT
02:17:44 <bollu> go on
02:18:03 <Cale> hunteriam: I'm sorry that we ended up talking a bit about HoTT in #haskell-blah, if you're not in there :)
02:18:07 <ReinH> Man, I would love an interface for hole-driver programming in Haskell
02:18:11 <ReinH> *driven
02:18:19 <Cale> oh, you are, go maybe look a bit if you're finding this interesting
02:18:55 <Cale> bollu: anyway, in HoTT, we actually only think of *some* types as being propositions
02:20:18 <Cale> bollu: (trying to figure out the order in which to best introduce things)
02:20:31 <Cale> Okay, so maybe I'll start with the notion of truncatedness, or h-level
02:21:22 <Cale> Oh!
02:21:29 <Cale> I just realised I left out Sigma!
02:21:30 <Cale> haha
02:21:40 <Cale> Okay, so Sigma (x:A), B x
02:21:53 <Cale> is the type of pairs, whose first component is some value x of type A
02:22:00 <Cale> and whose second component is an element of B x
02:22:08 <Cale> er, a value of type B x
02:22:16 <ReinH> Cale: I had forgotten how Pi was a product. It's a sort of indexed product, I guess.
02:22:21 <Cale> yeah
02:22:32 <bollu> Cale: concrete example?
02:22:46 <ReinH> it doesn't help that Sigma is for pairs
02:23:07 <Cale> Okay, so just as a function of type Pi (x:A), B x says logically that for all x of type A, we have some proof of B x
02:23:31 <Cale> Sigma (x:A), B x, says that there exists some x of type A, together with a proof of B x
02:23:57 <bollu> oh, so it's a tuple?
02:23:59 <Cale> yeah
02:24:00 <Cale> a pair
02:24:15 <Cale> the type of the second component of the pair depends on the value of the first component
02:24:17 <bollu> okay, go on
02:24:22 <Cale> okay
02:24:43 <`Guest00000> Axman6: making music with haskell
02:24:50 <Cale> So recalling that 1) we interpret Id A x y as the space of paths from x to y in the space A
02:25:10 <Cale> and that 2) all functions are going to be regarded as *continuous* in the space interpretation of things
02:25:27 <bollu> Cale: I have a question about the topology itself - what are our open sets?
02:25:35 <Cale> This is weird topology
02:25:44 <Cale> Spaces and paths are our primitive notions
02:25:44 <`Guest00000> ReinH: i don't expect it
02:25:45 <bollu> all topology is weird topolgy :P
02:25:56 <bollu> oh, so no open sets / closed sets?
02:25:57 <`Guest00000> i'm okay with writing code that would "make  compiler do that"
02:26:22 <Cale> HoTT is to classical topology what Euclidean geometry or Hilbert-style geometry is to Cartesian geometry
02:26:49 <bollu> Cale: but.. we aready have axioms in topology (I.e, that of the topological space T over the set X) - so what are we axiomatizing?
02:26:49 <Cale> We're formulating the things we really want to talk about as fundamental notions, rather than building them up from points
02:26:57 <bollu> hm, alright
02:27:14 <Cale> bollu: and we're really only doing homotopy theory
02:27:34 <Cale> bollu: so you should think of these not as proper topological spaces, but only up to homotopy equivalence
02:28:08 <bollu> Cale: alright
02:28:13 <Cale> bollu: all contractible spaces will end up being equal
02:28:17 <bollu> Cale: so the only thing we have is the fundamental group?
02:28:25 <Cale> we have all the homotopy groups
02:28:50 <bollu> Cale: ah, alright. so we can construct paths and their homotopies, but we have no underlying structure (of the topo.)?
02:28:51 <Cale> we can talk about paths between paths after all
02:29:13 <Cale> But the paths themselves are not built out of points
02:29:21 <Cale> They have endpoints, and that's it, right?
02:29:41 <bollu> right
02:29:55 <`Guest00000> i can open a file and write to it in Q (if i understand correctly)
02:30:01 <bollu> so a path is some sort of Point -> Point -> Path, with no internal structure?
02:30:13 <Cale> bollu: a path p : Id A x y
02:30:25 <Cale> bollu: is some element of the identity type
02:30:27 <`Guest00000> but compiler demands having main, and it will produce executableanyways
02:30:30 <Cale> bollu: Now you might complain
02:30:36 <Cale> bollu: We only have the constructor Refl
02:30:39 <bollu> yes
02:30:46 <Cale> bollu: So how do we show there's anything else in there?
02:30:50 <`Guest00000> i want it to produce .wav instead of executable
02:31:00 <Cale> bollu: Well, in MLTT, we can't show there *isn't* anything else in there
02:31:44 <Cale> People tried for a long time, until it was realised there's a model of the type theory where you interpret types as groupoids and functions as functors, and identity types as arrows in the groupoids
02:31:50 <`Guest00000> something like mainData :: ByteString
02:32:01 <Cale> er, values of identity types as arrows in the groupoids
02:32:19 <bollu> Cale: so, the only paths are those between "equal" elements?
02:32:40 <bollu> (since the only constructor we have is Refl)?
02:32:43 <Cale> bollu: yeah, so, okay, if we want to talk about spaces which aren't boring
02:32:52 <ReinH> `Guest00000: you can't do that.
02:32:55 <Cale> bollu: We have to get them from somewhere
02:33:16 <bollu> Cale: right :)
02:33:30 <Cale> bollu: One thing which we do in HoTT, is introduce new data types which in addition to the usual sort of point constructors, can alsohave path constructors
02:33:50 <Cale> i.e. you can say that you want certain non-refl paths between points
02:33:52 <Cale> e.g.
02:33:56 <Cale> data Circle where
02:34:02 <Cale>   basePoint : Circle
02:34:12 <Cale>   loop : Id Circle basePoint basePoint
02:34:24 <bollu> oh, so a path between non-refl points is in bijection to some type?
02:34:57 <Cale> refl is the constant path at a point, remember
02:35:15 <Cale> here, loop represents the path which "goes around the circle"
02:35:19 <Cale> once
02:35:29 <Cale> and then from that, we can build all the other paths
02:35:43 <Cale> by applying symmetry, we go around the circle the other way
02:35:54 <Cale> by applying transitivity, we can go around multiple times
02:36:08 <Cale> and we can ask about whether two proofs of equality of basePoint with itself are equal
02:36:30 <bollu> Cale: wait, back up: why does basePoint inhabit Ciecle?
02:36:40 <Cale> bollu: I defined it as a data constructor
02:36:45 <Cale> for this "higher inductive type"
02:36:58 <Cale> Maybe should have used an uppercase letter :)
02:37:50 <bollu> wait, so given a basePoint you give a circle?
02:38:09 <Cale> So we not only have that basePoint value constructor
02:38:30 <Cale> but also a constructor  loop : Id Circle base base  (okay if I write base for short?)
02:38:58 * hackagebot Verba 0.1.1.0 - A solver for the WordBrain game  https://hackage.haskell.org/package/Verba-0.1.1.0 (Jefffrey)
02:39:01 <bollu> yes, base is alright
02:39:02 <Cale> i.e. we're explicitly putting this extra path in
02:39:23 <Cale> and it's meant to not be equal to the path that refl gives
02:39:38 <bollu> I'm not able to interpret "loop : Id Circle base base" right
02:39:54 <bollu> as in, what equality are we showing?
02:39:58 <Cale> i.e. we're sort of defining this new value loop of that type
02:39:58 <bollu> (any 2 base points?)
02:40:06 <Cale> base with itself
02:40:25 <Cale> but it helps to not necessarily think of it as just a proof of equality
02:40:34 <bollu> oh, so it's a new loop, from base to base, but *not* the same one that's given by Refl because ..?
02:40:40 <Cale> but also geometrically as a path from the basepoint to itself which loops around the circle once
02:41:16 <Cale> because when we introduce things as data constructors, we tend to require that they're not the same as anything else we introduced before that point
02:41:40 <Cale> Just as S Z isn't the same Nat as Z
02:41:57 <bollu> hm
02:41:59 <Cale> So it's sort of "just because"
02:42:04 <bollu> alright
02:42:04 <Cale> But also
02:42:18 <Cale> There's an "induction principle" for the circle
02:42:26 <Cale> and actually for all the types we've introduced thus far
02:42:34 <Cale> I've been leaving out the eliminators
02:42:58 <Cale> Like, for a simple pair type, (logical and), you have the first and second projections
02:43:42 <bollu> another question - how is the existence of projection not an axiom?
02:44:00 <Cale> It's an inference rule
02:44:19 <Cale> p : (A,B) |- fst p : A
02:44:38 <bollu> hm, I see. 
02:44:53 <bollu> so.. is it like a Coq tactic? 
02:45:26 <Cale> Coq tactics are imperative programs which build lambda terms in a sort of metaprogramming way
02:46:02 <Cale> (well, weird imperative... they have backtracking nondeterminism and can match on the set of stuff which is in scope...)
02:46:23 <Cale> (and on the goal)
02:46:39 <bollu> oh, I didn't know that :) but go on
02:47:14 <Cale> So when you build the product type
02:47:24 <Cale> You have an introduction rule
02:47:34 <Cale> x : A, y : B |- (x,y) : (A,B)
02:47:47 <Cale> and you have elimination rules
02:48:02 <Cale> p : (A,B) |- fst p : A
02:48:12 <Cale> p : (A,B) |- snd p : B
02:49:22 <Cale> and then you have some computation rules, which are equalities not in the sense of the identity type, but at some lower level which can be used directly by the type checker
02:49:35 <Cale> that fst (x,y) = x
02:49:39 <Cale> and snd (x,y) = y
02:51:17 <Cale> So we have an introduction rule  x : A |- Refl A x : Id A x x
02:52:32 <Cale> It's a bit tricky at first to say what the corresponding elimination rule ought to be
02:53:52 <Cale> I wonder if I can do this in a way which won't be hideous
02:54:44 <Cale> Okay, let's descend in level of formality
02:55:09 <Cale> (you can find a proper formal version in the Appendix of the HoTT book, but it involves substitution, and some notations I haven't introduced)
02:55:56 <Cale> Path induction (the elimination rule for the identity type)
02:56:07 <Cale> says that given a function
02:56:26 <Cale> C: Pi (x,y: A), Id A x y -> Type
02:57:00 <Cale> This is a function which for *every* path in the space A, gives a type
02:57:09 <Cale> i.e. for any two endpoints
02:57:22 <Cale> it gives a function from paths between those endpoints to types
02:57:37 <Cale> okay, and, secondly
02:58:04 <Cale> if we have a function c: Pi (x:A), C x x (Refl A x)
02:58:30 <Cale> i.e. we can, for each point in A, we can give an element of the type C x x (Refl A x)
02:58:41 <Cale> then
02:59:00 <Cale> There is a function f : Pi (x,y:A), Pi (p: Id A x y), C x y p
02:59:06 * hackagebot storable-record 0.0.3.1 - Elegant definition of Storable instances for records  https://hackage.haskell.org/package/storable-record-0.0.3.1 (HenningThielemann)
02:59:08 * hackagebot storable-tuple 0.0.3.1 - Storable instance for pairs and triples  https://hackage.haskell.org/package/storable-tuple-0.0.3.1 (HenningThielemann)
02:59:12 <Cale> such that f x x (Refl A x) = c x
02:59:40 <Cale> i.e. to define a (continuous) function on the space of all paths in a space A
02:59:55 <Cale> it suffices to define it on the constant paths
03:00:12 <Cale> This sounds weird at first
03:00:32 <Cale> But it makes sense geometrically so long as you keep in mind that everything is up to homotopy
03:01:30 <Cale> and so once you know where the constant path at x is sent, then you can determine where some path from x to y is sent
03:01:59 <Cale> I dunno, this might be very hard to picture, and you're probably a ways back
03:02:38 <Cale> But this rule basically tells us how to write functions out of identity types
03:02:51 <Cale> and pattern matching is really using this rule
03:03:05 <Cale> If you look at it *less* geometrically
03:03:06 <Cale> hah
03:04:50 <Cale> Then it's saying that in order to define a function  Pi (x,y:A), Pi(p:Id A x y), C x y p (where C x y p can be any type depending on these things), we're allowed to assume that x is equal to y, and that the path in question is refl
03:05:04 <Cale> and just give an element of C x x (Refl x)
03:34:39 <Fuco> is there something like 'head' but giving Maybe a?
03:36:11 <shachaf> Yes, but it has the unappetizing name listToMaybe.
03:36:16 <shachaf> So it might as well not be there.
03:36:34 <Fuco> ugh
03:36:53 <Fuco> I would've not guessed that name :O
03:37:11 <Fuco> ant reason why head doesn't give maybe anyway?
03:37:20 <Fuco> I guess it would be too annoying
03:37:24 <Cale> Fuco: because sometimes you know the list is nonempty
03:37:32 <Cale> similar to fromJust
03:37:47 <Cale> (a fromJust which gave Maybe would be id)
03:37:59 <shachaf> listToMaybe is terrible, though.
03:38:01 <Cale> yeah
03:38:14 <Cale> listToMaybe is a little bit too bad a name, and perhaps head is a little bit too good a name
03:38:16 <shachaf> It exists, which means that adding something with a name like safeHead is difficult to justify.
03:38:41 <Cale> But you also don't want head to be too much longer because it's in competition with (\(x:xs) -> x)
03:38:56 <Axman6> the safe package also has versions of several functions such as head which return Maybe
03:39:07 <shachaf> At least (\(x:_) -> x) will give you a more informative error message!
03:39:15 <Cale> this is true
03:39:22 <Cale> and sometimes I will replace head with that
03:39:33 <Cale> Basically head is only for certain idioms
03:39:40 <Cale> map head . group . sort
03:39:42 <Cale> for example
03:39:43 <shachaf> The safe package's names aren't especially pleasant either.
03:39:47 <Fuco> I have bunch of functions "Bus -> IO ()" where Bus is some network destination... now my function which gives me active bus is IO (Maybe Bus).  In case it's Nothing I don't want to do anything.  Would it be a good idea to introduce my own operator such that "getBus <op> action" would pass 'Just bus' into the action and do nothing on Nothing...
03:39:52 <shachaf> group should be :: [a] -> [NonEmpty a], of course.
03:39:54 <Axman6> indeed :\
03:39:56 <Fuco> or should I change my actions explicitly to Maybe Bus -> IO ()
03:40:09 <Cale> shachaf: except that's a really lovely type to work with :P
03:40:22 <shachaf> Yes, well.
03:40:53 <Fuco> the expected usage is that the user would do "current >>= action" ... but now wtih maybe in it it doesn't compose :/
03:40:56 <shachaf> Wasn't this supposed to be the great thing about type systems?
03:40:58 <shachaf> Oh well.
03:41:28 <Cale> shachaf: Yeah -- it's true. But application of the type system is something which is rarely complete anyway.
03:41:31 <Fuco> I'm not sure how to design it so it wouldn't be annoying to use, but still give the user a chance to handle failure if they care so
03:41:47 <Cale> shachaf: It's good that we don't always have to prove that our sorting functions sort
03:41:59 <shachaf> sort of good
03:42:03 <Cale> and there's a whole spectrum of convenience vs. safety
03:42:22 <shachaf> Of course.
03:42:46 <shachaf> This is half of what typed language design is about.
03:43:01 <Cale> Yeah
03:43:01 <shachaf> If only you can make it easy to express to the language what's going on in your head anyway.
03:43:27 <shachaf> Don't worry, I'll just write a "safety rule" that says that "map head . group" is type-safe.
03:43:34 <Cale> hehe
03:45:34 <ReinH> Fuco: sounds like you want MaybeT
03:46:04 <jle`> Fuco: write them Bus -> IO (), and use mapM_ or traverse_
03:46:22 <ReinH> because its bind works on IO (Maybe a) values (wrapped in the MaybeT constructor) in the way you expect
03:46:27 <jle`> mapM_ :: (Bus -> IO ()) -> (Maybe Bus -> IO ())
03:46:55 <jle`> if you write a Bus -> IO (), you get a Maybe Bus -> IO () for free
03:47:14 <jle`> *you get the Maybe Bus ... that you wanted
03:47:53 <Fuco> oh, mapM_ from Data.Foldable
03:49:07 * hackagebot Verba 0.1.2.0 - A solver for the WordBrain game  https://hackage.haskell.org/package/Verba-0.1.2.0 (Jefffrey)
03:49:48 <funrep> ReinH: did you have a list of good reads for haskell programming ? (particularly about algebra, category theory and such)
03:50:03 <jle`> Fuco: mhm.  it should be in Prelude too, I think...
03:50:12 <Fuco> but only for lists I think
03:50:13 <ReinH> funrep: http://reinh.com/notes/posts/2014-07-25-recommended-reading-material.html
03:50:25 <jle`> :t mapM_
03:50:27 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
03:50:28 <funrep> awesome thanks!
03:50:50 <jle`> it should be the generic/polymorphic one unless you're using an out of date GHC
03:51:24 <Fuco> I have "The Glorious Glasgow Haskell Compilation System, version 7.6.3"
03:51:28 <jle`> oh
03:51:31 <jle`> how did that happen?
03:51:33 <jle`>  ...
03:51:38 <Fuco> ghc --version ? :D
03:51:46 <jle`> i mean, how did you get stuck with 7.6 haha
03:51:57 <Fuco> debian stable I suppose...
03:52:21 <Fuco> so what is the current version?
03:52:22 <jle`> heh, it's quite a few releases out of date
03:52:28 <Fuco> I will probably do a manual install then
03:52:39 <ReinH> That is how debian do
03:52:41 <jle`> 7.10.3 atm
03:52:47 <ReinH> Just let stack install it for you
03:53:17 <Fuco> I don't use stack just yet, but maybe I should start with that as well
03:58:53 <Cale> Fuco: Yeah, I gave up on relying on my distribution to give me a sane Haskell-related anything quite a long time ago. Installing it yourself using the generic linux binary is an option, but yeah, stack is getting pretty popular and I've heard good things about it.
03:59:02 <Fuco> dang, mapM definitely seems like magic... or maybe I'm just lucky :D The thing is, some of the actions are queries so they have type "Bus -> IO (Maybe String)" etc... seems like it works with both Maybe and () 
03:59:25 <Cale> uh
03:59:41 <Fuco> I'm going to write the types out on paper
04:00:17 <Cale> All it does is to apply the function to all the elements of the given list, getting a list of actions, and then apply sequence to that list of actions to combine them into one action that runs each in turn, collecting the list of results.
04:00:23 <Cale> i.e.
04:00:31 <Cale> mapM f xs = sequence (map f xs)
04:01:01 <Cale> mapM :: Monad m => (a -> m b) -> [a] -> m [b]
04:01:12 <Cale> sequence :: Monad m => [m a] -> m [a]
04:01:56 <Cale> sequence [] = return [] -- if the list is empty, we construct the action which does nothing but returns the empty list as its result
04:01:57 <ReinH> Except now it's all traversable-ified
04:01:59 <jle`> Fuco: specifically for Maybe, it's (a -> IO b) -> Maybe a -> IO (Maybe b) ; run the action on the input if you can, and don't if you can't
04:02:19 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
04:02:19 <ReinH> > mapM (Just . succ) Nothing -- o_O
04:02:19 <jle`> you can ignore that it's from Foldable/Traversable for your specific use case here
04:02:21 <lambdabot>  Just Nothing
04:02:49 <Cale> if the list is nonempty, we run the first action getting some result v, then run the rest of the actions, getting a list of results vs, and return the combined list (v:vs)
04:02:56 <Fuco> oh yes, I just made a mistake when I read the type of the result
04:03:10 <Cale> ohhhh
04:03:13 <Cale> That's what he means
04:03:14 <Fuco> it wraps it in Maybe twice for the queiries which return IO (Maybe b)
04:03:32 <jle`> Fuco: i like to think of it as "fmap with effects";  you already know how to fmap a function over a Maybe, fmap :: (a -> b) -> Maybe a -> Maybe b; but you don't have an (a -> b), you have an (a -> IO b), so mapM it is
04:03:33 <Cale> Yeah, sequence and mapM have been generalised further
04:03:38 <ReinH> I mean, if the question is "how can I use bind on IO (Maybe a) so it works with both the IO and the Maybe", the answer is "someone already did that and it's called MaybeT".
04:03:43 <Cale> from lists to arbitrary Traversable data structures
04:04:23 <Fuco> yes, in the end I think I will go with MaybeT
04:04:42 <Fuco> I just want the API to be as simplest as possible for the general 99% use case
04:04:51 <jle`> MaybeT is mostly useful/worth the overhead if you have a lot of IO (Maybe a)'s, or want to use Monad-polymorphic functions over IO (Maybe a)'s
04:05:22 <ReinH> Where "a lot" is something like "more than 2"... ;)
04:05:40 <jle`> "more than 2" sounds fair, yes :o
04:05:44 <Fuco> I have two types of things: Bus -> IO () are actions, and Bus -> IO (Maybe a) are queries.  And I have a function current :: IO (Maybe Bus) which gives you the active interface you are controlling
04:06:07 <Fuco> the Maybe in the query is for various reasons like "the interface doesn't support this property" etc
04:06:35 <jle`> MaybeT IO a is useful if you're building up an IO action that supports short-circuiting failure
04:06:39 <Fuco> and most of the time the user would do "Just c <- current; action c" ... which before I made it Maybe Bus was just current >>= action
04:07:07 <jle`> if you just have an IO (Maybe a) action, and you want to handle the Nothing's as you go along, then it might not make too much sense to go into binding w/ MaybeT
04:07:38 <jle`> but it's difficult for me to give any more specific advice without more info :o
04:07:41 <jle`> and i should sleep now v.v
04:07:51 <Fuco> sleep well :)
04:08:00 <jle`> thanks! happy haskelling!
04:08:03 <Fuco> you gave me enough ideas already, I need to review it more
04:08:10 <Fuco> and learn something new out of all this :)
04:18:46 <spuz> hi, why does the following parser not work? http://lpaste.net/3250905358167703552
04:19:08 <spuz> The parser returns an error "not enough input"
04:19:31 <mauke> because many anyChar eats everything, then char ']' fails
04:24:13 <Cale> hm, don't attoparsec parsers backtrack?
04:27:46 <ReinH> mauke: not without try iirc?
04:28:01 <Cale> There's no try in attoparsec, try is id
04:28:11 <ReinH> oh right
04:28:18 <ReinH> only do
04:28:28 <Cale> I'm legitimately confused at what's going on here...
04:28:45 <mauke> ooh, attoparsec
04:31:22 <Cale> It seems like maybe it's something to do with the way that parseOnly works...
04:31:36 <Cale> But I don't know
04:31:59 <mauke> but why write .*\) when you can write [^)]*
04:33:11 <Cale> yeah, I mean, there's definitely a more efficient parser for this
04:33:14 <Cale> But still...
04:33:54 <Cale> If I run parse instead of parseOnly, I get Partial _ here
04:34:45 <mauke> well, yeah. many anyChar will keep consuming whatever you throw at it
04:35:00 <Cale> Yeah
04:35:19 <Cale> It's just... how do we trigger the failure continuation...
04:36:54 <Cale> I'm too tired
04:37:09 <Cale> But maybe when I wake up I'll think about what's going on some more
04:37:40 <Cale> Attoparsec parsers are supposed to be able to backtrack and find solutions to things like that, I thought.
04:38:35 <spuz> yeah...
04:38:41 <hexagoxel> the (>>=) of attoparsec's Parser does not seem to do backtracking (https://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/src/Data-Attoparsec-Internal-Types.html#Parser)
04:38:42 <spuz> that is why I'm confused
04:38:48 <Cale> many is initially greedy, but it should back off when the first parse fails
04:39:00 <hexagoxel> only the mplus
04:39:09 * hackagebot carray 0.1.6.3 - A C-compatible array library.  https://hackage.haskell.org/package/carray-0.1.6.3 (HenningThielemann)
04:39:59 <hexagoxel> `lose` is not modified (or is my interpretation wrong?)
04:40:05 <Cale> You might be right
04:40:49 <Cale> Yeah, there should definitely be an altered failure continuation, I'd expect...
04:40:56 <Cale> huh...
04:42:13 <Cale> I mean, that's one way to make things super-efficient
04:42:14 <Cale> hah
04:42:15 <hexagoxel> i think the "does more backtracking than parsec" just means that it backtracks even on non-non-consuming failures (exactly the case where you need `try` in parsec)
04:42:44 <Cale> just cut off all backtracking on every step
04:43:13 <mauke> a <|> _ = a
04:44:38 <spuz> so... what should i do?
04:45:10 <spuz> is there a better way to write this parser?
04:45:19 <Kaidelong> I'm not sure how to get regex-pcre to build on windows
04:45:21 <mauke> many (noneOf ")")
04:45:26 <mauke> assuming noneOf exists
04:45:30 <Kaidelong> pkg-config can find the C library, it is installed
04:45:37 <Kaidelong> but when cabal tries to build it it fails
04:46:00 <Cale> many (notChar ']')
04:46:16 <spuz> mauke, my actual pattern (as a regex) should be: /^"(.*)"$/
04:46:23 <mauke> no, it shouldn't
04:46:28 <mauke> it should be \([^)]*\)
04:46:34 <padre_angolano> what if this parser must also parse "[abcd]]"? 
04:46:35 <mauke> .* is an antipattern
04:46:42 <spuz> I simplified the example that I pasted earlier
04:47:13 <spuz> so my actualy problem requires extracting the contents of a string (i.e. the characters between two ") including escaped " characters
04:47:26 <mauke> also, that regex is better written as /^"/ && /"$/
04:47:30 <spuz> so that regex is what I want
04:47:34 <mauke> no
04:47:43 <mauke> .* is never right
04:47:46 <spuz> hmm
04:48:09 <spuz> mauke, what does && do?
04:48:30 <mauke> :t (&&)
04:48:31 <lambdabot> Bool -> Bool -> Bool
04:48:38 <mauke> logical and
04:49:11 <spuz> ok so how would I do that as a parser rather than a regex?
04:50:57 <mauke> if T.length s >= 2 && T.head s == '(' && T.last s == ')' then Just (T.tail (T.init s)) else Nothing
04:51:29 <spuz> what about attoparsec?
04:52:21 <mauke> what's the point of writing a whole parser if all you want to do is check the first and last character?
04:59:22 <hexagoxel> spuz: if that task is not trivial for you, the task is exactly the right exercise to train your parser writing skills (sorry :p)
05:00:20 <spuz> hexagoxel, yeah, that is purpose of this exercise :)
05:00:53 <hexagoxel> hint: what are the smallest sections, so that you can write `char '"' *> many someThing <* char '"'
05:01:35 <nshepper1> spuz: i think you want a way to identify the end of the string before encountering EOS
05:01:41 <Gurkenglas> :t evalStateT $ do '(' <- StateT uncons; mapStateT listToMaybe $ do content <- StateT ?inittails; ?getsT $ guard . (==")"); return content -- I like using StateT String Maybe for parsing.
05:01:43 <nshepper1> rather than relying on parse failure
05:01:43 <lambdabot> (?getsT::([Char] -> f ()) -> StateT [Char] [] a1, ?inittails::[Char] -> [(a, [Char])], Alternative f) => [Char] -> Maybe a
05:02:44 <nshepper1> for instance, in many languages a " that is not preceded by \ indicates the end of the string
05:04:44 <hexagoxel> spuz: for each "next character", what are the cases to distinguish, and how to proceed on each one?
05:05:49 <Gurkenglas> Hmm I guess inittails could be called splits
05:06:37 <mauke> the standard regex for standard strings is "(?:[^"\\]|\\.)*"
05:07:54 <spuz> hexagoxel, I'm still not sure firstly why my original solution does not work and secondly whether it should work
05:08:32 <hexagoxel> spuz: i thought you now wanted to support escaping, which your original solution surely did not.
05:09:03 <nshepper1> I think generally it seems like not good practice to try to get any information out of EOS at all, since it's not composable
05:09:19 <spuz> hexagoxel, yes but I thought I would start with a simpler problem to solve. i.e. identifying text between two delimiters
05:09:34 <Gurkenglas> (If >> taking only IO () in its first argument was adopted, a1 there would be () as makes sense. Or perhaps that ? thing should convert consumed () to consumed a2 for consistency)
05:09:42 <Gurkenglas> *only m ()
05:11:35 <nshepper1> eg. supposing spuz's initial solution did "work" by backtracking, and you used it in a program 'operandParser *> somethingElse', since operandParser only knows when to stop by encountering EOS it will eat up the entire file
05:11:43 <hexagoxel> spuz: then the question remains: for the simplified task, how do you want treat "foo"bar" ?
05:12:24 <nshepper1> and maybe not fail if there's a ] somewhere, or fail in an incomprehensible way
05:13:11 <hexagoxel> nshepper1: but spuz still wants delimiters, i.e. '"'. i thought..
05:14:06 <nshepper1> right
05:15:51 <spuz> nshepper1, if the original operandParser *did* work then I don't see why it wouldn't compose with other parsers
05:15:59 <nshepper1> "char '[' >* many anyChar <* char ']'" is really using EOS as a delimiter
05:16:25 <nshepper1> there's nothing there saying "stop when you reach ]"
05:16:30 <hexagoxel> nshepper1: ah, i see what you are getting at.. took me a moment :p
05:16:31 <Fuco> sigh, sometimes haskell modules are just plain annoying
05:16:54 <Fuco> is there some way to force circular deps?
05:17:32 <hexagoxel> spuz: consider an input such as <"abc" "def">. you parser would return, as value, <abc" "def>
05:18:27 <hexagoxel> i.e. the length of the match is as long is possible, given all of the input available (until EOF, as nshepper1 phrases it).
05:21:12 <spuz> ok here's another question. Given the attoparsec parser: "foo" *> many anyChar <* "bar" and the regular expression: /foo(.*)bar/ why does the pattern fail to match on the string "foohellobar" for the attoparsec parser but it does match the regular expression given that they both support backtracking
05:21:32 <Axman6> Fuco: there is, but it's almost always a sign that those things are closely related enough that they should be in the same module
05:22:11 <spuz> I think the attoparsec parser should be: string "foo" *> many anyChar <* "bar" but hopefully you get the idea
05:22:29 <Axman6> spuz: not directly an answer to your your question, but I think there's a manyUntil or something like that for that purpose
05:23:21 <Axman6> "manyTill"
05:24:48 <nshepper1> spuz: I think regexes have rather different design constraints there
05:25:25 <nshepper1> they are not so frequently composed.. and being regular I suppose infinite backtracking is a lot cheaper
05:26:38 <nshepper1> 'many p' in attoparsec means 'repeat p as many times until it fails'
05:27:30 <nshepper1> 'p*' in regex means 'repeat p until it or the entire rest of this regex fails'
05:27:43 <defanor> i have a bunch of types here, and using aeson to derive {from, to}JSON instances; would like to generate json schema for those. tried the `json-schema` package by now, but it only works with {from, to}JSON instances derived with Generics.Generic.Aeson (which is not critical, but what's the point of that if Aeson can do that?), and i can't figure whether it can export that schema in JSON – to share and use it from other programs. does
05:27:43 <defanor> anybody know of any libraries that are capable of deriving those schemas automatically, and exporting them into JSON/strings?
05:29:29 <spuz> nshepper1, interesting. I wish I could remember my CS lessons on grammars
05:29:42 <spuz> that might explain why backtracking behaviour is different
05:34:41 <nshepper1> anyway, the question of what to do with "abc"def" or [abc]def] or [abc][def] is a good one to think about
05:34:57 <Geraldus> hi friends!
05:35:40 <nshepper1> presumably, you only want to allow [abc\]def], not [abc]def] to qualify
05:42:16 <Geraldus> I'm playing with Attoparsec, when writing a parser in monadic way how can I check that action is succeeded or not?
05:44:36 <Geraldus> E.g. `myParser = do a1 <- string "action1"; a2 <- string "action 2"; a3 <- string "action 3"; return a3` is there a way to check that action 2 is succeeded before running action 3?  Sorry, this questions looks silly
05:45:40 <Geraldus> maybe alternative <|> could be helpful in this case
05:46:10 <anohigisavay> hi
05:46:14 <anohigisavay> http://lpaste.net/148761
05:46:36 <anohigisavay> Par monad doesn't create sparks
05:47:12 <defanor> Geraldus: yup, either alternative or something like `option` from https://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-Combinator.html
05:47:34 <Geraldus> defanor: got it, thanks (:
05:51:28 <Geraldus> is there some benefits of handling possible parse errors in Parser monad rather than using `case (parse p i) of` outside of it?
05:58:49 <defanor> Geraldus: what kind of handling are you talking about? usually using `case (parse p i) of` and performing checks in a parser serve different purposes; if you check it in a parser, you can continue with another parse tree, or could provide a good error message, but there still will be something like `case (parse p i) of` outside of parsing in most cases
05:59:55 <Geraldus> defanor: thanks for clarification
06:02:08 <nshepper1> note that in the normal case of something like a1 >> a2 >> a3 you can assume that a2 has succeeded by the time you get to a3
06:02:31 <nshepper1> because if a2 failed the whole sequence would be considered to fail
06:02:47 <sbrg> god i hate libraries that override show instances that break (read . show) = id
06:04:09 <nshepper1> you only need to 'check' whether a2 has succeeded if you intend to _allow_ it to fail, by using `option` or such things
06:14:24 * hackagebot pandoc-crossref 0.1.6.3 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.1.6.3 (lierdakil)
06:22:13 <Geraldus> nshepper1: defanor: and there is no `many` combinator (only `many'`), because there is `many` from Control.Applicative already, is it?
06:22:55 <Gurkenglas> That's a combinator! Afaik that's why they named it that in the first place.
06:24:24 * hackagebot tar 0.5.0.0 - Reading, writing and manipulating ".tar" archive files.  https://hackage.haskell.org/package/tar-0.5.0.0 (DuncanCoutts)
06:24:39 <sbrg> is there a way for me to override an instance defined in a library?
06:25:10 <Geraldus> Gurkenglas: I mean there is no `many` in Data.Attoparsec.Combinator itself, only `many'` (in contrast there are `manyTill`, and `manyTill'`, `sepBy` and `sepBy'`) 
06:27:07 <Geraldus> sbrg: it looks quite old, but have a look at reply for this question https://mail.haskell.org/pipermail/haskell-cafe/2009-July/063832.html
06:27:20 <Geraldus> it looks like you can't do thar
06:28:58 <defanor> Geraldus: looks like it is; it uses `many` from Control.Applicative internally, too
06:28:59 <Geraldus> sbrg: and also here http://stackoverflow.com/a/32286940/1749901
06:29:36 <Geraldus> ah, well
06:30:34 <sbrg> hm. yeah. I'm trying to use newtype to do this, but it naturally doesn't override the Show instance that is already defined. I guess I'll have to hack around this
06:34:16 <Gurkenglas> Geraldus, I meant you can probably use the Control.Applicative-many as you would a many from attoparsec if they'd define it - Control.Applicative-many is just a generalized version of all of the manies
06:35:54 <Geraldus> Gurkenglas: I'm already using it, that's why I asks (: so it turns that many oppose to many' does not force result to weak header normal form
06:36:59 <Geraldus> excuse me, I always have troubles with proper time forms of verbs
06:42:43 <Gurkenglas> :t runMaybeT . many . MaybeT -- http://ircbrowse.net/browse/haskell?q=Gurkenglas+MaybeT+unfoldM <- I just figured it out!
06:42:45 <lambdabot> Monad m => m (Maybe a) -> m (Maybe [a])
06:48:26 <borkdude> I'm working through LYAH and I'm stuck on understanding this: (+) <$> (+3) <*> (*100) $ 5. What does it mean when you say: (+3) <*> (*100), conceptually
06:49:20 <hpc> lambdabot has some limited symbolic expression ability which you can use to simplify some expressions
06:49:29 <hpc> > ((+3) <*> (*100)) $ x
06:49:31 <lambdabot>      Couldn't match type ‘a0 -> b’ with ‘Expr’
06:49:31 <lambdabot>      Expected type: Expr -> b
06:49:31 <lambdabot>        Actual type: (a0 -> b) -> b
06:49:41 <hpc> :t ((+3) <*> (*100)) -- erp
06:49:43 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ a -> b
06:49:43 <lambdabot>     Expected type: (a -> b) -> a
06:49:43 <lambdabot>       Actual type: a -> a
06:49:47 <Gurkenglas> Those associate to the left, so you ought to ask first "(+) <$> (+3)", then "((+) <$> (+3)) <*> (*100)"
06:49:52 <wlad> Hi guys, I'm trying to implement Read typeclass for my Graph type, but I'm completely lost at defining readsPrec. What I need is parsing a list of Nodes, but I just can' Can someone take a look: http://pastebin.com/H3SBaJyt
06:49:59 <hpc> oh right
06:50:26 <mauke> borkdude: nothing. that's not a subexpression
06:50:32 <borkdude> hm ok, I guess the text in LYAH set me on the wrong foot then
06:51:01 <borkdude> left associativity, thanks
06:52:23 <mauke> wlad: why are you defining a custom Read?
06:53:13 <Gurkenglas> Aaaand of course https://hackage.haskell.org/package/unfoldable-0.8.3/docs/Data-Unfolder.html figured it out long ago, which I could have found by reading the conversation around the fourth reply to http://ircbrowse.net/browse/haskell?q=MaybeT+unfoldM
06:53:53 <wlad> mauke: I want to be able to read a list of strings like "[Node{vertex = Vertex {name="", x=0,y=0}, edges=[]}]" into a Graph, but for whatever reason, haskell cannot read this structure into Graph
06:54:26 <wlad> I thought that it would simply read a Node on every item in the list
06:54:57 <wlad> sorry, not "structure", I meant string
06:55:35 <Gurkenglas> Then again hayoo really should have shown me "unfold :: Unfolder f => f a -> f (t a)" back then when I asked for MaybeT a -> MaybeT [a].
06:55:58 <Gurkenglas> *m
06:56:04 <Gurkenglas> Or even just many :s
06:56:44 <joko> ~~~
06:57:10 <joko> oops, sorry
06:57:27 <joko> Is anyone familiar with the XRandR bindings in Haskell?
06:59:55 <mauke> wlad: needs "Graph [ ... ]"
07:00:44 <wlad> mauke: you mean Graph[ Node...] ?
07:01:19 <wlad> mauke: you mean urrounding what I have with Graph?
07:01:49 <Gurkenglas> > show [1..3] -- As you can see, show doesn't produce spaces, so you shouldnt assume read consumes them
07:01:51 <lambdabot>  "[1,2,3]"
07:03:15 <Gurkenglas> > Test 2 3 -- Oh, that goes for lists, not for records, nvm <.<
07:03:16 <lambdabot>  Test {test1 = 2, test2 = 3}
07:06:17 <Gurkenglas> Although wlads string still doesnt seem to conform to show's format ^^. If all else fails, wlad, you can show a node of the format you want to be able to read and paste the print into your code
07:08:48 <wlad> Gurkenglas: It seems that it went over my head, that I need to provide "Graph" in a string...I think it's been a long day for me. 
07:10:37 <mauke> wlad: well, if you want read to produce a Graph. yes
07:10:44 <mauke> otherwise you need to read into [Node]
07:24:38 * hackagebot distributed-process-lifted 0.1.0.0 - monad-control style typeclass and transformer instances for Process monad.  https://hackage.haskell.org/package/distributed-process-lifted-0.1.0.0 (jeremyjh)
07:24:40 * hackagebot OpenGLRaw 3.1.0.0 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGLRaw-3.1.0.0 (SvenPanne)
07:29:38 * hackagebot yesod-bin 1.4.17.1 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.17.1 (MichaelSnoyman)
07:29:40 * hackagebot cabal-src 0.3.0.1 - Alternative install procedure to avoid the diamond dependency issue.  https://hackage.haskell.org/package/cabal-src-0.3.0.1 (MichaelSnoyman)
07:29:42 * hackagebot GLURaw 2.0.0.1 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/GLURaw-2.0.0.1 (SvenPanne)
07:31:18 <sphinxo> Hi i'm trying to do code generation, and i'm wondering how to do something: http://lpaste.net/148765
07:31:32 <sphinxo> That code won't generate correct code because:
07:32:45 <sphinxo> for example Lit 10 :+: Lit 5 will generate [Set RAX 10,Push RAX,Set RAX 5,Pop RBX,Add RAX RBX,Push RAX]
07:33:05 <sphinxo> I'm basically wondering how to do inplace literals
07:34:38 * hackagebot ide-backend-server 0.10.0.2 - An IDE backend server  https://hackage.haskell.org/package/ide-backend-server-0.10.0.2 (MichaelSnoyman)
07:34:40 * hackagebot dimensional-tf 0.3.0.3 - Statically checked physical dimensions, implemented  using type families.  https://hackage.haskell.org/package/dimensional-tf-0.3.0.3 (BjornBuckwalter)
07:37:34 <rubix> hey there
07:37:56 <sphinxo> Hi rubix 
07:38:17 <rubix> I'm trying to use Data.Graph and I don't see any function that take a graph and a vertex, and returns the adjacent vertices.
07:38:51 <sphinxo> hmm
07:39:08 <rubix> which is surprising because it's like, the most basic thing one would want to do with a graph, or am I missing something here?
07:39:25 <sphinxo> reachable?
07:39:31 <sphinxo> no
07:39:49 <rubix> unfortunately reachable is the transitive closure of what I want
07:41:07 <andromeda-galaxy> hunteriam: about that EndsIn fundep:
07:41:28 <andromeda-galaxy> hunteriam: http://lpaste.net/148767
07:41:35 <andromeda-galaxy> I think that that does what you want, with closed type families
07:43:53 <hsk3> One good thing about Haskell is that I can use "2", "3", "sin", "exp", and "pi" in my functions with only the RealFloat constraint in 99% of my code. When I do the actual computation (1% of the code), I can pick the precision I want. I can use Double, Float, or even CReal or (BigFloat Prec50).
07:43:54 <hsk3> Does any other language out there provide this same thing? (Where "2", "sin", etc. can be used in such a general way.)
07:46:37 <rubix> hsk3: do dynamically-typed languages count?
07:47:08 <hsk3> rubix: well i prefer static typing, but sure, which dynamic langs have this?
07:47:16 <KaneTW> most of them
07:50:48 <rubix> hmm I'd say it depends on what you want exactly, it works differently. maybe julia?
07:58:22 <sm> morning all
07:59:05 <sm> I've been failing to derive an aeson ToJSON instance for Decimal.. is it possible ?
08:03:54 <sm> it requires a Generic instance. Deriving that gives " No instance for (GToJSON (Rep Decimal))" which I don't quite understand
08:10:40 <t7> can haskell do a nice vector math lib now with type level nats?
08:11:12 <sm> also, why is it warning "No explicit implementation for ‘toJSON’ " every time I derive ToJSON instances for my custom data types ?
08:14:39 * hackagebot tar 0.5.0.1 - Reading, writing and manipulating ".tar" archive files.  https://hackage.haskell.org/package/tar-0.5.0.1 (DuncanCoutts)
08:30:40 <RyanGlScott> sm: Can you post your code on http://lpaste.net/? These errors are hard to diagnose with just terse descriptions.
08:31:13 <RyanGlScott> As there are several meanings to the word "derive"
08:34:52 <sm> the second seems to be a recent regression with aeson/GHC: https://github.com/bos/aeson/issues/290
08:35:50 <sm> I'll have to leave the first for now, I've implemented it as instance ToJSON Decimal where toJSON d = toJSON $ show d
08:36:02 <sm> thanks 
08:45:56 <J0hn_V4rg4s> Hi all
08:47:10 <sphinxo> Hey J0hn_V4rg4s 
09:05:20 <mick_> hi
09:05:33 <Habib> hey
09:05:35 <sphinxo> Hi mick_ 
09:05:39 <mick_> given that Java's type system is unsound
09:05:54 <mick_> and the contradictory popularity of the language
09:06:04 <mick_> how relevant is type theory then?
09:06:11 <mick_> I'm studying it at the moment
09:06:29 <mick_> I know Haskell's type system is touted to be solid
09:06:54 <dmwit> mick_: It's popular. Also, people complain a lot about the wrong parts of Java's type system, because it breaks code hard.
09:06:56 <barrucadu> It's also unsound, eg, unsafeCoerce
09:07:01 <dmwit> So yeah, getting your type system right matters.
09:08:02 <dmwit> barrucadu: Java's type system is even worse than unsound. e.g. arrays are not invariant.
09:08:03 <mick_> it's the exceptions which cause trouble when trying to formally verify the type system
09:08:16 <mick_> i wouldn't call that the wrong part of Java's type system
09:08:28 <mick_> it's a core part of it and used in everyday code
09:08:30 <dmwit> (I think they're considered covariant or something? Which is, as mentioned above, just wrong.)
09:09:38 <monochrom> I would ask an opposite question. how relevant is popularity to you?
09:10:44 <mick_> monochrom: for jobs purposes, popularity matters alot :D
09:11:10 <monochrom> ok, for job purposes, you don't need type theory either.
09:12:18 <mick_> but we're getting off topic. my point was that if they type system is no good, I would expect the language to give rise to so many problems that to render the language unuseable or unsafe at least for production purposes
09:12:24 <mick_> but we know that is not the case
09:12:37 <maerwald> popularity is important if you don't want to write tons of low-level libraries/solutions all by yourself
09:12:49 <mick_> yeah maerwald
09:13:16 <mick_> i think the wealth of Java libs has saved that language
09:13:21 <defanor> maerwald: tons of those are pretty hard to maintain all by yourself, i think it's not just about knowledge
09:14:41 * hackagebot tiphys 0.1.0.0 - Navigating and editing JSON data  https://hackage.haskell.org/package/tiphys-0.1.0.0 (llhotka)
09:15:39 <monochrom> I wouldn't say that Java's type system is no good. its limitations do not affect my use.
09:15:59 <defanor> maerwald: sorry, i've misread your message somehow (so the reply doesn't make sense)
09:16:11 * exio4 puts monochrom inside an array of objects and gets a runtime exception
09:16:46 <maerwald> haskell throws runtime exceptions too :o
09:16:55 <monochrom> I wouldn't say either that something unsafe for production purposes cannot get popularly used for production purposes either. just look at the PHP community. humans are neural networks, not logic engines.
09:17:15 <monochrom> hell, even look at the LaTeX community
09:17:40 <maerwald> "hell" is correct in that context
09:17:43 <mick_> Yeah monochrom, you have a point
09:18:02 <mick_> business decisions are not necessarily the most logical ones
09:19:42 * hackagebot blatex 0.1.0.0 - Blog in LaTeX  https://hackage.haskell.org/package/blatex-0.1.0.0 (2016rshah)
09:19:44 * hackagebot machines-io 0.2.0.8 - IO utilities for the machines library  https://hackage.haskell.org/package/machines-io-0.2.0.8 (aloiscochard)
09:22:01 <dramforever> Hmm how weird, the status page says "updated 6 months ago"... How useful... 
09:24:42 * hackagebot blatex 0.1.0.1 - Blog in LaTeX  https://hackage.haskell.org/package/blatex-0.1.0.1 (2016rshah)
09:27:31 <cir0x> Hey! is there something similar in Haskell, like TimerTask in Java? (http://stackoverflow.com/a/11361356/3014979) 
09:27:44 <codedmart> Just started messing with stack. I can't seem to find in the docs how to use a package from a github repo.
09:28:35 <sphinxo> codedmart: https://github.com/commercialhaskell/stack/issues/199
09:29:22 <codedmart> sphinxo Thanks!
09:30:51 <mehwork> what's the best resource for learning haskell if you already know other languages like ruby?
09:31:26 <sphinxo> mehwork: http://learnyouahaskell.com/chapters
09:32:37 <mehwork> sphinxo: thanks. Also on osx should i brew install it somehow?
09:32:46 <sphinxo> Haskell?
09:33:03 <sphinxo> mehwork: ?
09:33:26 <mehwork> the haskell compilter or repl or whatever it is
09:34:04 <mehwork> haskell yes
09:34:08 <sphinxo> brew install haskell-stack
09:34:25 <mehwork> thanks, the website had some other zip files and stuff so i wasn't sure
09:34:32 <mehwork> https://www.haskell.org/downloads/osx
09:35:11 <sphinxo> actually mehwork 
09:35:32 <sphinxo> This is probably a better option: https://www.haskell.org/platform/
09:36:13 <tnks> so, after trying and encoding in Free and again in finally tagless, Free seems like a lot of machinery for no interesting gain.  Am I missing something?
09:36:18 <sphinxo> also mehwork if you just want to try haskell have a go with this: https://tryhaskell.org/
09:36:42 <tnks> I've oscillated on this sentiment, a little due to misunderstanding.
09:39:01 <monochrom> I don't find Free a lot of machinery. A little, yes.
09:40:18 <monochrom> but you can say that finally tagless is almost zero machinery
09:40:40 <sm> mehwork: http://haskellformac.com is also good
09:41:28 <tnks> monochrom: yeah, it's a relative measure.
09:41:41 <tnks> and libraries can hide fiddly bits.
09:49:45 <mehwork> ok thanks i'm trying it all
09:53:53 <Kaidelong> how can I get stack to tell me where the build system is looking for C libraries?
10:05:33 <hc> hi, i'm using DSA.sign (https://hackage.haskell.org/package/crypto-pubkey-0.2.8/docs/Crypto-PubKey-DSA.html)
10:05:47 <hc> it seems to be running into a runaway loop
10:05:50 <hc> never terminates
10:05:59 <hc> any hints? is the module broken?
10:06:03 <hc> (yes, I need DSA)
10:06:19 <hc> (verify works find)
10:06:35 <mehwork> sphinxo: tryhaskell.org says not an expression: `let foo = "bar"'. My tutorial says i can do: let greeting = "Hello"
10:07:46 <tnks> monochrom: I think what may help me is a problem with a design element that encoded more nicely with Free than tagless.
10:07:57 <tnks> what I have in front of me seems to lean the other direction.
10:08:40 <zomg> mehwork: that probably works in ghci but ghci works a bit differently from haskell code you'd write in a file
10:09:29 <mehwork> ok
10:10:40 <hc> https://hackage.haskell.org/package/crypto-pubkey-0.2.8/docs/src/Crypto-PubKey-DSA.html#signWith    (The condition r == 0 || s == 0 seems to always evaluate to True)
10:13:46 <vvvv> time to do some numerical work
10:14:00 <vvvv> does repa replace vector or are they complementary?
10:34:37 <hc> ok, sorry, found the problem: when reading p, g and q I accidentally set them all to the same value ;(
10:34:54 <hc> works like a charm now :)
10:36:43 <hsk3> If you look at this code example: https://pastee.org/wytsr
10:36:44 <hsk3> How can I make it more elegant, such that 1) an if-else chain that expands to the right is avoided, 2) the need to return Right () from the function at TWO PLACES is avoided?
10:37:02 <hsk3> Are there ways to do it?
10:37:37 <hsk3> in imperative programming, 2) can be solved because there doesn't need to be an else.
10:38:07 <opqdonut> that's a pretty clear case for the Either monad
10:38:28 <opqdonut> but you can also simplify it a lot with guards
10:40:12 <hsk3> opqdonut: can you provide example?
10:40:24 <hsk3> of the Either monad particularly
10:40:52 <opqdonut> just a sec
10:42:26 <tnks> monochrom: I think the answer to my question of when tagless becomes less of a fit might be for algorithms easily expressed in terms of pattern matching
10:42:46 <tnks> I'm kind of piece together discussions and what I can see myself.
10:43:33 <tnks> (and talking out loud here to shape some opinions and see if anyone thinks I'm off track)
10:44:30 <opqdonut> hsk3: http://lpaste.net/148777
10:44:52 <opqdonut> hsk3: heh, also lpaste has some good recommendations there :P
10:45:06 <hsk3> ROFL that is succinct as hell!!!
10:45:07 <hsk3> nice!
10:45:13 <hsk3> thanks
10:45:18 <opqdonut> https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Error.html
10:45:30 <opqdonut> that's what I used, it's in the standard library
10:45:44 <opqdonut> it recommends Control.Monad.Except, which I haven't used
10:46:32 <opqdonut> oh it's a drop-in replacement
10:47:35 <opqdonut> only available with a new enough mtl though
10:47:52 <broma0> My goal is both minimalism and correctness. What are some of the best tools provided by haskell to minimize the amount of code one must write to solve an arbitrary problem without sacrificing type safety? 
10:50:02 <opqdonut> hsk3: I added a version that used pattern matching and guards, it's pretty ok too
10:50:50 <H4ns> hi.  i'm new trying to use a haskell based system (using stack on osx) and see the message "Could not find module ‘Development.Shake’".  i'm guessing that i need to install shake but i don't know how.  any pointers?
10:51:01 <opqdonut> hsk3: and also, since when actually has type "Monad m => Bool -> m () -> m ()", the "return ()" in the monad version is unnecessary
10:51:39 <kadoban> H4ns: Under what circumstances are you getting that error, and what's the rest of the message?
10:52:04 <hsk3> opqdonut: why unnecessary?
10:52:14 <frerich> broma0: Higher-order functions for the former, (polymorphic) types for the latter.
10:52:29 <H4ns> kadoban: complete output is here: http://pastebin.com/QvuKr4Uc
10:52:40 <opqdonut> hsk3: "when False" is the same as "return ()"
10:52:55 <tnks> H4ns: with stack you can pretty easily install applications, by going outside a project and typing "stack install shake"
10:53:04 <tnks> and it will typically put it in ~/.local/bin
10:53:12 <tnks> and you can put that on your PATH.
10:53:20 <sphinxo> Hi, i'm struggling to do code generation properly
10:53:30 <kadoban> H4ns: What is Shake.hs, something you wrote?
10:53:32 <H4ns> tnks: thanks, that was what i was looking for!
10:53:50 <sphinxo> specifically literal values
10:53:53 <tnks> H4ns: I know. . . it's fucking awesome. . . Stackage/Stack even caches binaries.
10:54:08 <tnks> so it's a super fast install. . .
10:54:37 <sphinxo> My codegen code so far http://lpaste.net/148778
10:54:47 <tnks> Shake is a build system in Haskell.
10:54:59 <tnks> that looks awesome from what I've seen and read. . . but I haven't used it.
10:55:23 * hackagebot OpenGL 3.0.0.1 - A binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGL-3.0.0.1 (SvenPanne)
10:55:25 * hackagebot read-editor 0.1.0.2 - Opens a temporary file on the system's EDITOR and returns the resulting edits  https://hackage.haskell.org/package/read-editor-0.1.0.2 (yamadapc)
10:55:32 <sphinxo> the problem is for example Lit 5 :+: lit 7 is generating [Set RAX 5,Push RAX,Set RAX 7,Push RAX,Pop RAX,Pop RBX,Add RAX RBX,Push RAX]
10:55:45 <Habib> Guys, I have a pretty simple question, I think, about Haskell I've been wondering about.
10:55:56 <sphinxo> and add is expecting two values to be in RAX and RBX
10:56:18 <sphinxo> whereas pushing literals just sets RAX and pushes to TOS
10:56:23 <Habib> I'm on the applicative functor chapter of “Learn You a Haskell for Great Good” and my mind keeps going back to the question of how the hell the IO monad works.
10:57:14 <mag__> haha I asked myself that question many times
10:57:26 <mag__> I still do :\
10:57:38 <uncle-j_j> ))
10:58:28 <Habib> Haha. The book talks a lot about the IO performing an “action” when it hits main, but how the hell does that work? Side-effects seem like an impossible thing in Haskell, but they exist, except the way they're spoken about, they seem to exist as values… except you can't inspect them or mess around with them like any other value.
10:58:35 <sphinxo> Any ideas?
10:59:12 <geekosaur> In IO action is a program that you feed to the runtime. something like getLine is an opcode in that program; it is itself pure but represents an impure action
10:59:28 <geekosaur> the result of main is a chain of these opcodes, run by the runtime impurely
10:59:56 <Ralith_> Habib: your code doesn't have side effects, it merely instructs the runtime to perform them
11:00:23 * hackagebot machines-binary 0.3.0.0 - Binary utilities for the machines library  https://hackage.haskell.org/package/machines-binary-0.3.0.0 (aloiscochard)
11:01:35 <Habib> Yes, I've heard that way. It sort of makes sense like that. Would I be right in likening it to listing out instructions on a piece of paper to my assistant, instead of directly instructing them?
11:02:34 <geekosaur> the only thing the monad does is ensure that opcodes execute in the correct order by threading a dummy state value through these opcodes and program fragments created by combining these opcodes; the code generator even detects that it's a dummy and strips it
11:03:25 <Habib> Hmm, you've lost me when you said, “threading a dummy state value”.
11:03:34 <geekosaur> and fmap and bind let you hook callbacks to the opcodes for the runtime to execute pure code on the result of some action
11:04:30 <Habib> The only thing that bothers me is that I can't differentiate any IO action from another. I can't tell if an IO action, when performed, will get a line of input, will print to the console, or get an environment variable, or what.
11:04:49 <Habib> And when they're represented as values, I think of them as values and expect to be able to inspect what the action is going to do.
11:05:23 * hackagebot GLUT 2.7.0.6 - A binding for the OpenGL Utility Toolkit  https://hackage.haskell.org/package/GLUT-2.7.0.6 (SvenPanne)
11:05:30 <Habib> I see what you're saying about fmap allowing to hook callbacks, because I'm on the applicative functor chapter. Haven't got to bind yet.
11:05:30 <geekosaur> so, Haskell is not, properly speaking, lazy; it evaluates based on data dependencies. something is evaluated only when something else needs it. you can therefore ensure that one thing happens before another by making the second thing depend on a result of the first. if something doesn't have a result, this is difficult... but the state monad creates such a dependency on the state value.
11:06:09 <Habib> But isn't that what lazy means? That you don't do something until you really need it?
11:06:27 <geekosaur> so now we can force IO actions to be ordered by making them use a state of some kind. the trick is that the state doesn't exist (it's what is called a "phantom type"), it's just there to ensure the ordering, it has no actual representation in the program
11:06:37 <Habib> Haskell is 100% lazy, it doesn't do anything, until main needs it. Are functions even truly defined before main is performed?
11:07:35 <geekosaur> well, not exactly. lazy means you have a chunk of code that will produce a value instead of the value itself. *some* means is needed to force those chunks of code to be executed; the on-demand one used by Haskell is by far the most common (spreadsheets operate that way as well) but there are others
11:07:44 <Habib> A “phantom type”, hmm…
11:08:11 <Habib> Ah, I see (about laziness).
11:08:17 <geekosaur> or when emulating lazy operation in a strict program you can forget to include some way to trigger evaluation of the lazy value and then wonder why the program hangs :)
11:08:26 <Habib> Haha.
11:08:50 <geekosaur> (this does happen)
11:10:02 <geekosaur> but you can for example set a spreadsheet to manual calculation mode, and that represents lazy evaluation that is not driven specifically by another expression demanding the value
11:10:05 <sphinxo> Any ideas how to do this?
11:11:08 <geekosaur> data Foo a = Foo Int -- a is a phantom type. In this case you can use it as a tag to keep from accidentally mixing different Foo-s that should be kept distinct
11:11:24 <geekosaur> (there's a number of units conversion packages on hackage based on this idea, for example)
11:12:04 <defanor> a nice explanation of IO, btw: https://wiki.haskell.org/IO_inside. also https://stackoverflow.com/questions/17002119/haskell-pre-monadic-i-o for an easier to grasp version
11:13:27 <geekosaur> at some point, although probably not in LYAH until late if ever, is ST. this is a state monad where the state is a phantom type, which lets you ensure that values in ST can't mix with other values, and additionally gives you a way to order things. We use this to implement mutable algorithms in Haskell, because it ensures the mutability can't escape and the result is pure
11:13:36 <geekosaur> IO, in GHC at least, is a specialization of ST
11:13:55 <Habib> ST?
11:14:28 <Habib> State?
11:14:50 <mniip> I wouldn't say specialization, they just happen to have similar constructors
11:15:13 <Habib> In other words, Haskell doesn't know it's a specialisation, but we know it is?
11:15:17 <geekosaur> r, I dropped some words. "at some point, although probably not in LYAH until late if ever, you will encounter a monad called ST"
11:15:44 <mniip> Habib, more or less if you disregard threads, sparks, and other magic ghc does sometimes
11:16:35 <geekosaur> it's a somewhat advanced technique so you won't run into it until later, but it's an example of using a state monad with a state that is phantom (has no way to create or use values for it, it's just a "type tag")
11:17:54 <broma0> is there a template-haskell way to derive lenses for data/type families? 
11:20:09 <Habib> geekosaur, when you say mutable algorithms, do you mean algorithms which mutate [X thing] or algorithms which actually themselves are mutable?
11:20:34 <aweinstock> algorithms that internally use mutable state
11:20:48 <Habib> Oh, I see.
11:20:54 <geekosaur> the former. most values in Haskell can't be changed. ST gives you mutable values but they are tagged with the phantom state so they can't be shared around and can't escape the ST monad
11:21:29 <aweinstock> > runST $ do { tmp <- newSTRef 0; forM_ [1..10] (\i -> modifySTRef tmp (+i)); readSTRef tmp }
11:21:32 <lambdabot>  55
11:22:04 <Habib> And am I right to believe that, had state monads not been granted to us, we would not be able to implement it ourselves in Haskell?
11:22:05 <aweinstock> ^ sums some numbers using an explicit mutable variable
11:22:14 <geekosaur> you are incorrect
11:22:20 <geekosaur> state monads are implemented in Haskell
11:22:24 <aweinstock> State isn't the same thing as ST
11:22:31 <geekosaur> a state monad is just a tuple in disguise.
11:22:44 <Habib> Oh, wow. That makes things more interesting.
11:22:49 <big_wayne> i have this type:    data Bla = Bla1 | Bla2 deriving (Eq,Ord)     and i want to change order to this (combined with Maybe)   Just Bla1 > Just Bla2 > Nothing
11:23:01 <big_wayne> how to achive this
11:23:01 <Habib> That they're implemented directly in Haskell is awesome.
11:23:02 <aweinstock> the State monad is a convenient way of handling (a -> (s, a)) functions
11:23:07 <geekosaur> ST is partially implementable in Haskell: the part that prevents stuff escaping can be done with just a phantom type, but allowing mutable values requires extra support
11:23:25 <geekosaur> because Haskell doesn't do mutable values
11:23:31 <jmcarthur> ST is somewhat magical. State is not magical.
11:23:33 <Habib> functions which take a value and return a tuple with that value in the second position and state information in the first.
11:24:01 <geekosaur> something with a type State s a is really just something with the type s -> (a,s)
11:24:03 <aweinstock> there are some primitive ST actions that need to be handled specially (by the codegenerator, I think?), but (>>=) is implemented in haskell
11:24:18 <big_wayne> anyone can help me?
11:24:44 <geekosaur> big_wayne, instead of deriving Ord you write your own Ord instance
11:24:46 <jmcarthur> I've very recently taken to calling the first type argument for ST "heap" instead of "s".
11:25:00 <aweinstock> > Just () > Nothing
11:25:02 <lambdabot>  True
11:25:33 <jmcarthur> Calling it "heap" allows you to pretend it's not a phantom type.
11:25:55 <aweinstock> big_wayne: I think the default (>) for Maybe might do what you want
11:26:00 <maerwald> state monad is just an abstraction to what you can already do explicitly and often times I do
11:26:14 <geekosaur> aweinstock, look closely. Bla1 sorts greater than Bla2
11:26:18 <aweinstock> > [Just 1 < Just 2, Nothing < Just 2, Nothing < Just 1]
11:26:18 <maerwald> unless the chain is so long, that it becomes annoying
11:26:20 <geekosaur> but Nothing sorts less than Just
11:26:22 <lambdabot>  [True,True,True]
11:26:28 <big_wayne> Bla2 is bigger than Bla1
11:26:36 <geekosaur> that said, the easiest way to do it is swap Bla1 and Bla2 in the definition
11:26:51 <jmcarthur> STRef heap Int   can be interpreted as a reference to an Int in the heap "heap"
11:26:56 <aweinstock> data Bla = Bla2 | Bla1 deriving (Eq, Ord)
11:27:04 <geekosaur> since the default Ord instance just uses the order of the constructors
11:27:08 <big_wayne> i cannot change definition
11:27:09 <geekosaur> for an ADT
11:28:29 <jmcarthur> and then   ST heap a   can be thought of as   heap -> (a, heap)   , except the run function never allows you to actually reify the heap
11:30:29 <oisdk_> big_wayne so you want it to be ordered differently when it's wrapped in maybe?
11:31:46 <geekosaur> or this is homework about writing your own Ord instance
11:32:23 <big_wayne> i think i got this
11:32:42 <big_wayne> i just make my own max function
11:33:02 <big_wayne> thank anyway
11:36:45 <hsk3> opqdonut: You said when False is the same as return ()
11:37:18 <hsk3> opqdonut: but let's say i wanted to return some specific integer on success, Either String Int
11:37:26 <opqdonut> hsk3: yeah then you'd need the return
11:37:28 <hsk3> opqdonut: couldn't i have done return 3 at the end?
11:37:31 <opqdonut> yeah
11:37:43 <hsk3> opqdonut: ok, but by what mechanism does the return () get replaced by return 3?
11:37:47 <hsk3> (if i include my own return)
11:38:16 <opqdonut> I'm not sure what you're asking now
11:38:23 <hsk3> 1sec
11:38:35 <opqdonut> yes, if you want to return something that's not () on success, you need to have a return
11:39:00 <opqdonut> however, in the case where you want to return () on success, when does it for you (by coincidence kinda)
11:40:13 <hsk3> opqdonut: that's my question, https://pastee.org/uv975
11:40:37 <opqdonut> hsk3: oh, right, now I see
11:41:02 <opqdonut> > Right () >> Right 3
11:41:04 <lambdabot>  Right 3
11:41:05 <geekosaur> return is not a control construct
11:41:16 <geekosaur> return just lifts a value into a monad
11:41:23 <maerwald> :t return
11:41:24 <lambdabot> Monad m => a -> m a
11:41:34 <opqdonut> and the Either monad keeps the last value it encounters
11:41:35 <hsk3> ah ok
11:41:36 <hsk3> i see
11:41:55 <hsk3> i get it now, thank you
11:42:00 <opqdonut> last Right value that is. if a Left value is encountered, that's the result right there
11:49:44 <Nadrieril> > return 4 :: Either Int
11:49:46 <lambdabot>      Expecting one more argument to ‘Either Int’
11:49:46 <lambdabot>      Expected a type, but ‘Either Int’ has kind ‘* -> *’
11:49:46 <lambdabot>      In an expression type signature: Either Int
11:49:55 <Nadrieril> > return 4 :: Either Int Int
11:49:57 <lambdabot>  Right 4
12:00:25 * hackagebot reflex-dom-contrib 0.4 - A playground for experimenting with infrastructure and common code for reflex applications  https://hackage.haskell.org/package/reflex-dom-contrib-0.4 (DougBeardsley)
12:05:25 * hackagebot murmur3 1.0.1 - Pure Haskell implementation of the MurmurHash3 x86_32 algorithm.  https://hackage.haskell.org/package/murmur3-1.0.1 (PhilippeLaprade)
12:06:43 <hsk3> opqdonut: could i use the Either monad to shorten this code? https://pastee.org/qu2yz I don't see a way, because I no longer have just (). I now have Int.
12:06:53 <hsk3> So I don't see away to get around duplicating Right 3
12:07:06 <hsk3> s/away/a way
12:10:29 <pdxleif> The output of ghc-mod case split is 3 1 3 10 "foo Nothing = _foo (Just x) = _"
12:11:21 <pdxleif> That string should be two lines - "foo Nothing = _" and "foo (Just x) = _". How am I supposed to know where to split these strings up when processing ghc-mod output?
12:12:04 <pdxleif> Maybe haskell-ide-engine has nicer output?
12:12:41 <liste> hsk why not just "do when (check1 l1) (Left "check1 failed"); when (check2 l1) (Left "check2 failed"); return 3"
12:12:56 <liste> hsk3*
12:13:31 <hsk3> liste: that's missing the point of my question. it's a simplification of a bigger thing :) i want to have those lets there. (in reality i have more of them)
12:13:40 <hsk3> make the code clearer
12:14:10 <hsk3> hmmm
12:14:52 <hsk3> liste: what's that |1 ?
12:15:40 <aweinstock> :t let check f s x = if f x then Right () else Left s in (\check1 check2 l1 l2 -> do { check check1 "check 1 failed" l1; check check2 "check 2 failed l2; return 3})
12:15:42 <lambdabot>     lexical error in string/character literal at end of input
12:15:47 <aweinstock> :t let check f s x = if f x then Right () else Left s in (\check1 check2 l1 l2 -> do { check check1 "check 1 failed" l1; check check2 "check 2 failed" l2; return 3})
12:15:49 <lambdabot> Num b => (t -> Bool) -> (t1 -> Bool) -> t -> t1 -> Either [Char] b
12:15:58 <aweinstock> hsk3: ^
12:17:35 <aweinstock> hsk3: does something like that work for you? (having some helper to "promote" the check functions)
12:18:40 <liste> hsk3 I meant that you don't need to have multiple Right 3's
12:18:56 <aweinstock> or you could have (promoteEither  f s x = if f x then Right () else Left s) at the toplevel, along with (check1' = promoteEither check1) and so on
12:19:30 <liste> you can still have the let's, I just left them out to make it shorter
12:21:54 <aweinstock> err, check1' = promoteEither check1 "check1 failed"
12:24:03 <hsk3> ah ok!
12:27:53 <broma0> anyone know of a recursive 'makeClassy' for the lens library? I'm looking for (and might write myself) a TH function that will not only make the classy lenses for a type, but also make the Has* instances for the type's constructor arguments 
12:29:04 <broma0> for example, with 'data User = User Name Credentials', makeRecursiveLenses would create HasName & HasCredentials, as well as making instances for them with the User type: 'HasName User' and 'HasCredentials User'
12:30:08 <Jinxit> I've just done it manually for those fields first
12:31:00 <broma0> Jinxit: seems like th-able boilerplate to me
12:35:13 <bb010g> How would I convert a correctly bounded Word16 to a Word8? I can't seem to find anything online and don't want to just jump to unsafeCoerce.
12:35:52 <roconnor> bb010g: fromIntegral?
12:36:31 <bb010g> Doesn't that have performance problems?
12:39:29 <aweinstock> bb010g: I'd expect (fromIntegral :: Word16 -> Word8) to be pretty cheap/free
12:40:09 <aweinstock> bb010g: you could write some module with (test :: Word16 -> Word8; test = fromIntegral) and checking the generated assembly
12:40:12 <bb010g> Ok. Looking around now and can't find anything. Guess the warnings I heard about it were all related to the genericWhatever family for lists and how those weren't really that great.
12:40:46 <hsk3> https://pastee.org/zzsft
12:40:46 <hsk3> See the three "when"s there. Can you tell me why this works? I thought each when was supposed to do a "return ()" on success. But here, return () doesn't work because () doesn't match Int.
12:40:49 <hsk3> So why does this code compile?
12:42:53 <aweinstock> bb010g: fromIntegral is a member of the Num typeclass, and typeclasses do have overhead similar to objects (virtual calls, indirection) _if used polymorphically_
12:43:31 <geekosaur> :t when
12:43:33 <lambdabot> Applicative f => Bool -> f () -> f ()
12:43:40 <aweinstock> but (fromIntegral :: Word16 -> Word8) is monomorphic (only used for a specific type), so there's no vtable-ish things happening
12:43:40 <geekosaur> well, no, not relevant
12:43:40 <geekosaur> the reason it works is that:
12:43:41 <geekosaur> > return () >> return 3 :: Either String Int
12:43:41 <geekosaur> hm, did we lose a bot
12:43:42 <geekosaur> the Int is the *final* result
12:43:44 <lambdabot>  Right 3
12:43:54 <geekosaur> what happens in the middle can vary
12:44:06 <geekosaur> and >> doesn't care what type it's fed
12:44:08 <hsk3> geekosaur: yes but return () is still in there right? But return () shouldn't compile.
12:44:28 <geekosaur> please read what I said again
12:44:45 <aweinstock> > (return () :: Either a ()) >> (return 3 :: Either b Int)
12:44:46 <lambdabot>  Right 3
12:44:48 <geekosaur> I have this feeling you are imputing more magic to "do" than it actually has
12:44:53 <liste> :t (>>)
12:44:55 <lambdabot> Monad m => m a -> m b -> m b
12:45:04 <liste> that one doesn't care what `a' is
12:45:41 <geekosaur> the *final* reuslt here is "return 3" which satisfies Either String Int
12:45:45 <aweinstock> hsk3: (do { a; b }) = (a >> b)
12:45:54 <geekosaur> what happens in the middle *does not have to be Int*
12:46:13 <hsk3> ok i see
12:46:16 <hsk3> that's why this compiles: https://pastee.org/br6bz
12:46:18 <hsk3> ok i get it now
12:46:32 <geekosaur> () is perfectly valid as long as you don't use it as the final value, which you don't because it's followed by "return 3"
12:46:35 <aweinstock> :t fmap (const 3) (return ())
12:46:36 <lambdabot> (Monad f, Num b) => f b
12:46:50 <aweinstock> > fmap (const 3) (return ()) :: Either a Int
12:46:52 <lambdabot>  Right 3
12:47:10 <aweinstock> ^ "computing" something via a different type in the middle
12:48:01 <t0by> Hi. Simple and terribly daunting question: is there an interactive tutorial and/or set of progressive programming exercises that will give me a firm hand with Haskell *fast*? Haskell is not my first exposure to functional programming, but I come from elisp and Mathematica. I am going to take a test that's not Haskell-specific, but *is* given in Haskell in 20 days.
12:49:27 <geekosaur> hsk3, consider:
12:49:48 <geekosaur> > ord $ chr 3 :: Int
12:49:50 <lambdabot>  3
12:50:07 <t0by> (Well, it's not my first exposure to Haskell either, but I've forgotten most of the syntax, etc)
12:50:26 <aweinstock> @where learnhaskell
12:50:26 <lambdabot> https://github.com/bitemyapp/learnhaskell
12:50:29 <geekosaur> the reasoning you were using would have this be illegal because chr :: Int -> Char so there's a Char value in the middle
12:50:46 <aweinstock> ^ I think that's becoming the "standard" set of exercises or something
12:51:24 <geekosaur> as it turns out, this is similar to what you were doing (although it is reversed). instead of $ the operator is >>, and you have something that produces IO () instead of something producing Char
12:51:28 <t0by> aweinstock, thank you so much
12:53:18 <t0by> aweinstock, cis194 *seems* particularly interesting in that it apparently includes a set of decent lectures
12:53:21 <geekosaur> and for all that when looks like a control structure and do looks like a block of commands, both are just expressions
12:57:04 <aweinstock> t0by: from bitemyapp's discussion of it, it sounded like he considers the exercises to be the important bits
12:57:20 <t0by> aweinstock, yes, basically I *did* come for excercises.
12:57:52 <t0by> aweinstock, finding things-other-than-excercises is easy with google and the various famous and less famous books around
12:58:11 <t0by> but I need to do actual programming
13:00:53 <hsk3> https://pastee.org/84f3y
13:00:53 <hsk3> Why is than an error?
13:01:19 <hsk3> no sorry wait
13:01:20 <hsk3> 1sec
13:02:16 <hsk3> https://pastee.org/wzhn7
13:02:17 <hsk3> Why is that an error?
13:05:22 <aweinstock> :t when
13:05:23 <lambdabot> Applicative f => Bool -> f () -> f ()
13:06:05 <aweinstock> :t Left "asdf" :: Either a ()
13:06:07 <lambdabot>     Couldn't match expected type ‘a1’ with actual type ‘[Char]’
13:06:07 <lambdabot>       ‘a1’ is a rigid type variable bound by
13:06:07 <lambdabot>            an expression type signature: Either a1 () at <interactive>:1:1
13:06:19 <aweinstock> :t Left "asdf" :: Either String ()
13:06:20 <lambdabot> Either String ()
13:07:04 <aweinstock> hsk3: (Either e) = f, for the purposes of "when"
13:07:25 <aweinstock> hsk3: and e = String
13:08:28 <aweinstock> hsk3: (Left "" :: Either String a) for any a, so it works for (a = ())
13:09:24 <aweinstock> hsk3: (Right 3 :: Either a Int) for any a, but there's no way to force (Int = ())
13:09:38 <aweinstock> well...
13:10:08 <aweinstock> :t Unsafe.Coerce.unsafeCoerce (Right 3 :: Either a Int) :: Either a ()
13:10:09 <lambdabot> Either a ()
13:10:49 <aweinstock> but don't do that, it'll probably segfault, and statements made about the typesystem normally ignore unsafeCoerce
13:10:59 <Gurkenglas> hsk3, the information "3" you put into the when doesn't go anywhere, and it knows that, so it doesn't allow you to give it any information in the first place
13:11:39 <Gurkenglas> If you replaced 3 with (), that whole when block does nothing and so you can remove it
13:11:58 <Gurkenglas> And then you can combine the two consecutive when conditions into one!
13:12:54 <Gurkenglas> (I've been saying that for the same reason, >> should only take m () on the left side, not m a - and forever should be m () -> m Void)
13:17:31 <ReinH> hsk3: what error do you get?
13:17:50 <hsk3> No instance for (Num ()) arising from the literal ‘3’
13:18:08 <ReinH> :t when
13:18:10 <lambdabot> Applicative f => Bool -> f () -> f ()
13:18:17 <ReinH> when is not allowed to return a f Int
13:18:20 <hsk3> this whole monad is over of my head
13:18:22 <ReinH> only a f ()
13:18:24 <Gurkenglas> Of course it's possible that you've been trying to get if-then-else syntax and are not aware of the asymmetry of Either. In that case, use "if" instead of "when", use then/else and no do blocks.
13:18:33 <hsk3> give up or carry on, i wonder sometimes
13:18:41 <hsk3> been learning for 1 year
13:18:51 <hsk3> (on and off)
13:19:10 <ReinH> so the only Right you could use is Right ()
13:19:25 <aweinstock> Gurkenglas: is your stance that any code that would be broken by redefining (>> :: m () -> m a -> m a) and (forever :: m () -> m Void) is buggy/smelly?
13:19:28 <ReinH> Any other Right value would be a type error
13:20:23 <ReinH> Gurkenglas: well, that's a silly idea. It's quite common to use a other than () on the lhs of (>>)
13:20:28 * hackagebot tagsoup 0.13.8 - Parsing and extracting information from (possibly malformed) HTML/XML documents  https://hackage.haskell.org/package/tagsoup-0.13.8 (NeilMitchell)
13:20:55 <aweinstock> :t void
13:20:56 <lambdabot> Functor f => f a -> f ()
13:20:57 <ReinH> and the type of forever is precisely the type you want to indicate its behavior
13:21:00 <Gurkenglas> aweinstock, yep, smelly. It implicitly throws away information and should make it explicit by using void
13:21:34 <aweinstock> @src void
13:21:34 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:21:48 <Gurkenglas> Anything that can take a without doing anything with it can take () and vice versa
13:21:52 <aweinstock> void = const () --?
13:22:13 <aweinstock> err, fmap (const ())
13:22:22 <aweinstock> :t fmap (const ())
13:22:23 <lambdabot> Functor f => f b -> f ()
13:22:25 <ReinH> If you redefine (>>) that way, you'll just have people using k >>= _ -> ... instead. It's silly.
13:23:05 <aweinstock> ReinH: because that's less characters than (void k >> ...) ?
13:23:45 <aweinstock> (and Gurkenglas's argument is that (void k >> ...) is more semantically correct, I'd guess)
13:24:10 <ReinH> it's semantically identical.
13:24:17 <ReinH> :t (>>)
13:24:19 <lambdabot> Monad m => m a -> m b -> m b
13:24:25 <ReinH> This already tells you that the a is not used
13:24:52 <ReinH> it's extra work for no reason
13:25:20 <ReinH> Same with forever
13:25:23 <ReinH> :t forever
13:25:24 <lambdabot> Monad m => m a -> m b
13:25:44 <ReinH> This is already the type of a computation that is executed forever
13:26:26 <ReinH> Changing the type signatures just breaks existing code and makes them harder to use for no purpose
13:27:00 <ReinH> The suggestd version of forever is actually *worse*
13:27:14 <Ferdirand> I guess the argument is that it would prevent some accidental mistakes, but i'd like to see a plausible example of such an accidental mistake
13:27:58 <ReinH> Ferdirand: for (>>), there is none
13:28:03 <hsk3> ok I think I get it. It's not the Either monad, but the Either String monad
13:28:07 <Ferdirand> i was thinking about do desugaring
13:28:09 <ReinH> hsk3: Yes.
13:28:16 <hsk3> cool
13:28:39 <Ferdirand> but writing do { a <- x ; b <- y ; something a b }
13:28:48 <Ferdirand> sorry wanting to write that
13:29:07 <Ferdirand> and mistakenly writing do { a <- x; y ; something a a }
13:29:15 <Ferdirand> that's contrived and not very plausible
13:29:21 <Ferdirand> surely there must be a better example
13:29:37 <ReinH> Is this seriously a mistake that is plaguing our haskell users?
13:29:51 <Ferdirand> i don't know, that's why i'm asking
13:30:01 <ReinH> It seems entirely contrived
13:30:08 <umayahabdennabi> Hi does anybody know how to use the return value of query from mysql-simple
13:30:39 <ReinH> umayahabdennabi: did you read the docs?
13:31:31 <umayahabdennabi> ya they only show: query conn “select …” 
13:31:42 <umayahabdennabi> but they don’t show how they use the results returned from the query
13:31:47 <ReinH> The docs provide lots of examples.
13:31:55 <ReinH> Yes they do.
13:32:08 <ReinH> There's a section titled "extracting results" even.
13:32:32 <hsk3> And is it true that in the (Either a) monad, Left always "wins"? So if we get Left once, Left gets propagated downwards, ignoring everything else.
13:32:40 <hsk3> Because that's how >>= is implemented in that monad.
13:32:52 <umayahabdennabi> okay let me check this out, thx ReinH
13:32:54 <jle`> yes; that's actually the only way it could possibly be implemented, too :)
13:33:03 <hsk3> ok cool
13:33:21 <jle`> the behavior is similar to the instance for Maybe
13:33:41 <ReinH> Ferdirand: You might as well say they are doing do { a <- x ; a' <- y; somthing a a } instead of something a a
13:33:44 <ReinH> '
13:33:48 <monochrom> Left blah >>= \x -> ...  you don't really have anything of the right type to pass to x
13:33:53 <hsk3> yeah where Nothing wins
13:33:57 <ReinH> that seems like an error that is actually common.
13:34:09 <ReinH> Forgetting to bind does not.
13:34:34 <aweinstock> jle`: err, how is that the only possible way? I don't see how, at a glance, "keeping the last Left" not typecorrect?
13:34:44 <ReinH> This proposal doesn't help with that, but something <$> x <*> y does.
13:34:46 <jle`> aweinstock: try it :O
13:35:04 <ReinH> :t (>>=)
13:35:05 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:35:21 <jle`> aweinstock: you can write an Applicative instance where you "keep the last Left", but not Monad
13:35:28 <jle`> i do encourage you to try though and see for yourself
13:35:45 <ReinH> aweinstock: in Either e a, how do you bass an a to the (a -> m b) if you have a Left? There's no a value.
13:36:32 <ReinH> The difference with Applicative is
13:36:34 <ReinH> :t (<*>)
13:36:36 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:36:38 <aweinstock> Left e >>= f = f (unsafeCoerce e) -- ;)
13:36:45 <ReinH> I can already tell whether the rhs is a Left or Right
13:36:47 <monochrom> Applicative is more symmetry, yeah
13:36:49 <ReinH> with (>>=), I can't
13:37:08 <ReinH> Not until I apply an a, but I have no a to give.
13:37:09 <aweinstock> (but I understand)
13:37:10 <monochrom> Monad inflicts a data dependency
13:37:25 <ReinH> aweinstock: that doesn't actually work, it just type checks.
13:37:39 <aweinstock> I know, I was trying to make a joke
13:38:12 <aweinstock> unsafeCoerce is never (modulo newtypes?) a law-abiding thingy
13:39:04 <jle`> btw, for coercing newtypes, we now have safeCoerce, `coerce` :o
13:39:17 <aweinstock> :t coerce
13:39:19 <lambdabot> (Functor f, Contravariant f) => f a -> f b
13:39:35 <jle`> not that one :o
13:39:37 <ReinH> heh
13:39:44 <monochrom> Left e >>= f = f (unsafePerformIO (putStrLn "I need help, please suggest a value" >> readLn))
13:39:54 <aweinstock> lol
13:39:56 <ReinH> monochrom: :)
13:40:14 <jle`> doesn't typecheck! :O
13:40:23 <monochrom> unfortunately now it has a Read constraint. now you have to go indexed monads.
13:40:26 <jle`> requires a Read constraint
13:40:28 <jle`> yeah
13:40:30 <jle`> heh
13:40:58 * hackagebot js-jquery 1.12.0 - Obtain minified jQuery code  https://hackage.haskell.org/package/js-jquery-1.12.0 (NeilMitchell)
13:41:00 * hackagebot explicit-exception 0.1.8 - Exceptions which are explicit in the type signature.  https://hackage.haskell.org/package/explicit-exception-0.1.8 (HenningThielemann)
13:41:29 <Darky_> Can you recommend me some good practice to learn monads ?
13:41:29 <ReinH> monochrom: just read a () and then unsafeCoerce it
13:41:36 <monochrom> scary
13:41:37 <ReinH> and thereby lie to your user
13:41:41 <ReinH> for profit
13:42:06 <ReinH> as opposed to the original suggestion, which was not scary?
13:42:12 <jle`> Darky_: my best advice is to forget about learning about monads in general
13:42:19 <jle`> and just learn how to use specific types
13:42:37 <jle`> like learn how ot use Maybe, List, IO, etc.
13:43:14 <Darky_> I already did.. but i have no feeling about creating new monads when needed 
13:43:34 <monochrom> https://github.com/NICTA/course contains a stage where you re-implement a lot of standard monad stuff yourself (under different names to avoid name clash)
13:46:12 <aweinstock> is the stuff about Free monads good motivation for monads in general?
13:50:58 * hackagebot cabal-helper 0.6.3.0 - Simple interface to some of Cabal's configuration state used by ghc-mod  https://hackage.haskell.org/package/cabal-helper-0.6.3.0 (DanielG)
13:56:11 * hackagebot hspec-structured-formatter 0.1.0.3 -   https://hackage.haskell.org/package/hspec-structured-formatter-0.1.0.3 (flbulgarelli)
13:58:20 <hsk3> class Foo a where
13:58:21 <hsk3>     foo :: RealFloat b => a -> b
13:58:22 <hsk3> Is this discouraged in Haskell?
13:58:32 <hsk3> (In a similar way that constraints are discouraged in data.)
14:01:11 <vvrr> hi
14:02:28 <aweinstock> vvrr: if you have a question, the convention is to ask it directly, rather than saying hi first
14:10:28 <vvrr> aweinstock just being friendly man :)
14:10:42 <Gurkenglas> ReinH, it's, how do I say it, "closer to the canonical system that can be derived from math". I'm not sure but I think I first got this idea when I realized that exferenceBot could more safely use forever and >> and the like if it couldnt use them to waste information (because it looks for expressions that use up all the information they have.) and that sounded like a generally useful language feature
14:11:36 <Gurkenglas> vvrr, you get tired of empty phrases when you hang around in this channel for years :D
14:12:43 <vvrr> gurkenglas so how's the weather?
14:13:05 <Gurkenglas> The weather's behaving kinda irrelevantly today
14:15:36 <Gurkenglas> Ferdirang, it's kinda similar to an "unused variable" warning. You did something that produced a result, don't you want to use it? If you don't that's weird; declare it.
14:15:58 <Gurkenglas> (Except of course that other languages dont complain if you dont assign the thing to a variable)
14:16:33 <ReinH> Gurkenglas: (>>) does declare it
14:16:45 <ReinH> parametricity forces you to ignore the a
14:17:32 <Gurkenglas> I'd guess that >>'s left argument is almost always m (), except for... some parser stuff and forkIO, I guess?
14:17:47 <ReinH> No?
14:17:56 <Gurkenglas> (The latter of which returns a ThreadID that is often unneeded)
14:18:04 <Gurkenglas> Example pls!
14:18:47 <sccrstud92> does anyone know if it is possible to write a type family that maps type-level Symbols to the type-level Nat that represents the length of that Symbol?
14:19:06 <Gurkenglas> Maybe I'll get good enough at this stuff at some point that I'll actually compile the type signature change against hackage and see how many lines of code wouldnt work anymore
14:19:46 <Gurkenglas> sccrstud92, manually? Sounds good.
14:20:04 <sccrstud92> how would you do that manually?
14:20:22 <sccrstud92> arent there infinitely many type-level Symbols?
14:20:59 <Gurkenglas> By manually I meant for finitely many :/ dunno for infinite
14:28:24 <big_wayne> how do i remove the edges up to the root of binary tree?
14:28:46 <big_wayne> i need some algorith
14:33:41 <aweinstock> big_wayne: what type of binary tree are you using? data BinTree a = Branch (BinTree a) (BinTree a) | Leaf a --?
14:34:40 <erisco> what is the bang pattern to look up things such as "Set" ?
14:34:52 <aweinstock> or data BinTree a = Node a (BinTree a) (BinTree a) | Empty -- or possibly something else
14:35:34 <aweinstock> erisco: BangPatterns is for strictness annotations
14:35:45 <erisco> not those bang patterns
14:35:49 <aweinstock> @hoogle Set
14:35:50 <erisco> DDG bang patterns
14:35:51 <lambdabot> Data.Set module Data.Set
14:35:51 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment Set :: LogicOp
14:35:51 <lambdabot> Data.Set data Set a
14:36:21 <hunteriam> "    `builder' is not a (visible) method of class `ToByteString'"
14:36:22 <erisco> Hoogle doesn't do it
14:36:32 <hunteriam> literally the only method in ToByteString is builder
14:36:36 <erisco> nevermind, you have to capitalise
14:36:37 <hunteriam> why is this happeninh??
14:36:57 <hunteriam> http://hackage.haskell.org/package/bytestring-conversion-0.3.1/docs/Data-ByteString-Conversion-To.html#t:ToByteString
14:37:28 <nitrix> Is there any chance that Hoogle gets updated?
14:37:28 <erisco> why does Set not have a Monoid instance?
14:38:06 <big_wayne> aweinstock i have some custom tree, its not really a binary tree it just have max 2 subtrees
14:38:28 <aweinstock> what's the declaration of it?
14:39:27 <nitrix> erisco: How would it collapse the elements?
14:39:43 <erisco> collapse?
14:40:54 <big_wayne> data BlaTree = Bl2 (Int, BlaTree) (Int, BlaTree)
14:40:56 <erisco> instance (Monoid a) => Monoid (Set a) where mempty = Set.empty; mappend = Set.unionWith mappend
14:40:59 <big_wayne>            | Bl1 (Int, BlaTree)
14:41:03 <big_wayne>            | BlaLeaf deriving Show
14:41:17 <nitrix> erisco: Yes, Monoids require an associative binary operation (with an identity).
14:41:32 <erisco> it is
14:42:16 <erisco> whoops I did not want unionWith
14:42:54 <erisco> just mappend = Set.union
14:42:59 <erisco> I was thinking of Map there
14:43:03 <aweinstock> big_wayne: and what is it that you want to do to those trees?
14:43:25 <erisco> instance Monoid (Set a) where mempty = Set.empty; mappend = Set.union
14:43:37 <erisco> set union is associative and the empty set is an identity
14:43:38 <aweinstock> @let data BlaTree = Bl2 (Int, BlaTree) (Int, BlaTree) | Bl1 (Int, BlaTree) | BlaLeaf deriving Show
14:43:42 <lambdabot>  Defined.
14:44:17 <nitrix> erisco: That'd break law #1:  x `mappend` mempty = x
14:44:29 <erisco> why?
14:44:32 <big_wayne> i have to find some edge in a "forest" the delete all edges up to the root
14:44:40 <aweinstock> erisco: isn't (universe, intersect) also a valid Monoid?
14:44:50 <erisco> intersect does not have an identity
14:45:03 <erisco> oh, you're saying to use the universe
14:45:07 <erisco> well, we don't know what that is
14:45:17 <big_wayne> also new trees may be created
14:45:18 <aweinstock> universe = set such that contains = const True
14:45:48 <erisco> the Set module does not define a universe, probably because that would be problematic for some other features
14:45:51 <erisco> such as toList
14:45:53 <aweinstock> type BlaForest = [BlaTree] -- ?
14:46:00 <big_wayne> yes
14:47:01 <aweinstock> what are edges/roots in the forest?
14:47:38 <big_wayne> edges are identified by the Int or what do you mean?
14:48:14 <glguy> erisco: union can't implement mappend because it has the wrong type
14:48:23 <glguy> It has that Ord constraint
14:48:30 <aweinstock> erisco: newtype MySet a = (a -> Bool); universe = MySet (const True); intersect (MySet f) (MySet g) = MySet (\x -> f x && g x)
14:48:38 <erisco> glguy, ah, I see
14:49:06 <erisco> glguy, instance (Ord a) => Monoid (Set a) where  though?
14:49:31 <glguy> erisco: oh, yeah :)
14:49:34 <glguy> that instance exists
14:49:37 <erisco> aweinstock, that is a good idea but it'd be a different module
14:49:42 <aweinstock> empty = MySet (const False); union (MySet f) (MySet g) = MySet (\x -> f x || g x); singleton x = MySet (x ==)
14:50:00 <mauke> > S.singleton () <> S.singleton ()
14:50:02 <lambdabot>  fromList [()]
14:50:23 <mauke> > S.singleton 'a' <> S.singleton 'b'
14:50:25 <lambdabot>  fromList "ab"
14:51:07 <aweinstock> big_wayne: I was originally thinking that the BlaTree was the tree structure, and Int's are the elements, but it seems that you're now saying that the Int's are representing another graph?
14:51:44 <hsk3> How can I fix this? https://pastee.org/utup2
14:51:45 <hsk3> Is there away to explicitly give foo a type there?
14:51:47 <erisco> mauke, odd that the docs do not mention the instance
14:51:52 <aweinstock> > () <> ()
14:51:54 <lambdabot>  ()
14:52:07 <glguy> erisco: they do
14:52:11 <glguy> http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Set.html
14:52:22 <mauke> hsk3: sure. which type do you want?
14:52:29 <erisco> wow derp, I missed it
14:52:35 <aweinstock> hsk3: let foo = f :: () in () --?
14:52:54 <hsk3> mauke, aweinstock: well, a general Eq would be a good start.
14:52:59 <hsk3> does it have to be a concrete type?
14:53:11 <mauke> hsk3: let foo :: Eq a => a; foo = f
14:53:36 <erisco> I nice feature of Data.Set is you can enumerate it, unlike a -> Bool
14:53:41 <hsk3> haha wonderful. thank you sir
14:53:57 <big_wayne> the Int is representing the edge, and my task is to find some edge then delete all other edges that lead to the root
14:55:17 <big_wayne> my func is: Int -> BlaForest -> BlaForest
15:11:13 * hackagebot protocol-buffers 2.2.0 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/protocol-buffers-2.2.0 (k_bx)
15:11:15 * hackagebot protocol-buffers-descriptor 2.2.0 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  https://hackage.haskell.org/package/protocol-buffers-descriptor-2.2.0 (k_bx)
15:11:17 * hackagebot hprotoc 2.2.0 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/hprotoc-2.2.0 (k_bx)
15:17:44 <MitchellSalad> hi all, poking aroung GHC.TypeLits I see an unexported function natSing that's part of the KnownNat typeclass. It has type KnownNat n => SNat n, and I sort of need this function. Is there any reason it's hidden, or is there some way to emulate it with the rest of the API? (I'm not seeing it)
15:19:35 <MitchellSalad> hm, looking at the source, SNat isn't even a singleton, it's a newtype
15:19:59 <athan> Is there a reason why there isn't a safe version of `(!!) :: [a] -> Int -> a` in the `safe` package?
15:21:03 <athan> MitchellSalad: Are you sure the `makeSingletons''` TemplateHaskell stuff isn't being used on it?
15:21:17 <athan> Also, why exactly do you need this function, if you can spill the beans? :)
15:21:38 <bergmark> athan: there is: atNote
15:21:43 <MitchellSalad> GHC.TypeLits is in base, so I don't think it depends on singletons
15:21:50 <athan> agh sorry bergmark!
15:21:50 <parsnip> hi, have some errors regarding cabal_macros.hs when trying to `stack ghci` in hakyll/
15:22:12 <athan> MitchellSalad: oop, wait so what do you mean by a "singleton" in your first remark, then?
15:23:20 <MitchellSalad> athan: I meant what you thought I meant; a singleton-like type. I just don't think the SNat newtype in GHC.TypeLits is being made into a singleton with TH
15:23:23 <parsnip> http://lpaste.net/148781
15:23:30 <parsnip> http://lpaste.net/148782
15:24:21 <MitchellSalad> athan: sure I can spill the beans, I'm writing the boilerplate Storable instance for a length-indexed vector
15:24:36 <MitchellSalad> and I've resorted to using unsafeCoerce
15:25:02 <MitchellSalad> seems like it should be possible with type level fanciness, but I may be using the wrong kind
15:25:15 <athan> MitchellSalad: It's been a while since I've messed with the idea. So SNat is used for demotion, then?
15:25:24 <MitchellSalad> specifically, the vector is indexed on GHC.TypeLits.Nat, as opposed to the usual promoted "data Nat = Z | S Nat"
15:25:31 <athan> for something like `SNap (Succ (Succ Nil))` or something?
15:26:15 <MitchellSalad> oh, the singleton? that would be a GADT defined like: data SNat (n :: Nat) where SZ :: SNat 0; SS :: SNat n -> SNat (n+1)
15:26:58 <athan> MitchellSalad: Ahh okay, got it. Wait so why do you need to use the function, though?
15:27:14 <athan> natSing I mean
15:27:45 <MitchellSalad> ah, if you try to write the 'peek' function, you run into trouble... peek :: (KnownNat n, Storable a) => Ptr (Vec n a) -> IO (Vec n a)
15:28:17 <MitchellSalad> I can't prove to the compiler that e.g. n ~ 0 when I compare natSing (Proxy :: Proxy n) to 0, for example
15:28:35 <MitchellSalad> the value level comparison doesn't propagate to the types, that's what singletons can help encode :)
15:28:42 <athan> ooh okay you're in the thicket then
15:28:57 <MitchellSalad> sorry, that natSing above should be natVal
15:28:58 <athan> singletons in my experience can't give that type inference, still
15:29:16 <MitchellSalad> right, I don't need to rely on type inference
15:29:27 <athan> well, it actually still is
15:30:11 <athan> MitchellSalad: So you're trying to unify `n ~ 0`, based solely on the term `natSing (Proxy :: Proxy n)`?
15:30:23 <athan> Do you get something like `cannot deduce n ~ n1` or something?
15:30:28 <MitchellSalad> that would work, yes, except natSing doesn't exist!
15:30:38 * athan should append "or something" to his signature in emails
15:30:42 <MitchellSalad> it's in the KnownNat typeclass but it's not exported
15:31:27 <MitchellSalad> if you meant natVal above, then yes, that's the type error you'd get
15:31:29 <athan> MitchellSalad: I'm not sure if anyone working on the singletons package / concepts are online right now, but you should try cloning your own local version and exposing it, just for kicks
15:31:39 <athan> I've found them to be pretty responsive on Stack Overflow, though
15:31:49 <athan> MitchellSalad: Ahh, then yes
15:32:02 <athan> for ambiguous types, it's best to constrain from the type-level down, if that makes sense
15:32:10 <MitchellSalad> ah, this is not really a deficiency of singletons, it's more like I need singletons and it doesn't appear that GHC.TypeLits has any singletons in its API
15:32:24 <athan> allowing deduction to be explicit from the type information, not necessarilly forgotten and attempted to be coerced from the value
15:32:43 <athan> oh
15:32:51 <athan> then import Singletons haha
15:33:04 <hunteriam> how do I convert a Data.Time.Clock UTCTime to GMT?
15:33:26 <mpickering> hunteriam: what have you tried? 
15:33:35 <hunteriam> nothing
15:33:36 <MitchellSalad> heh, that wouldn't work; as I said the vector is not indexed on a promoted "data Nat = S Nat | Z" but rather GHC.TypeLits.Nat
15:35:30 <athan> hunteriam: Well, `Maybe a ~/~ UTCTime`, so I don't know what you're trying to get at :P
15:35:32 <hpc> "i've tried nothing and i'm all out of ideas!"
15:35:44 <hunteriam> athan: what?
15:35:51 <shirt> where is the cheat-sheet for haddock markup?
15:35:51 <mpickering> MitchellSalad: I second what athan said about stack overflow
15:35:52 <hunteriam> hpc: this isnt really something im trying to implement on my own
15:35:58 <hunteriam> im looking for a function
15:36:06 <hunteriam> what am i supposed to try?
15:36:08 <athan> MitchellSalad: Singletons does some stuff with typelits iirc
15:36:18 <hunteriam> i have tried hoogling
15:36:20 <hunteriam> and googling
15:36:24 <athan> shirt: Their docs page :P it's just a really long cheat sheet I guess
15:36:24 <hunteriam> now are you happy hpc, mpickering 
15:36:24 <mpickering> There are some people who are very good with this stuff
15:36:38 <mpickering> I was trying to help! 
15:37:07 <athan> hunteriam: Have you looked in the `time` package?
15:37:12 <athan> @hackage time
15:37:12 <lambdabot> http://hackage.haskell.org/package/time
15:37:16 <hunteriam> i have
15:37:16 <athan> time to get hacking!
15:37:28 <hunteriam> the solution was a package time-http
15:38:44 <mpickering> What about the function utcToLocalTimeOfDay
15:39:10 <hunteriam> theres no GMT localtime defined
15:40:10 <mpickering> I think you can make a TimeZone for gmt
15:40:28 <athan> hunteriam: iirc there's no real difference between UTCTime and GMT time
15:40:43 <hunteriam> mpickering: its non trivial
15:40:55 <MitchellSalad> mpickering: good call, there's a Data.Singletons.TypeLits, this is what i needed :D
15:41:00 <athan> historically there's a lag or some kind of aliasing between the two, but nothing massive
15:41:07 <hunteriam> athan: that is correct
15:41:12 <hunteriam> athan: thanks!
15:41:29 <athan> hunteriam: I would take the specs and build your own converter :\ most of Hackage seems to only support UTC / UT1
15:41:49 <athan> np hunteriam :) good luck!
15:41:50 <mpickering> What is the non-trivial part? It seems to be quite easy looking at the docs
15:41:55 <hunteriam> athan: Data.Time.Format
15:42:10 <mpickering> Isn't that a bad idea because of daylight savings? 
15:42:36 <mpickering> I am looking at Data.Time.LocalTime btw
15:42:41 <hunteriam> mpickering: ah true
15:43:15 <liyang> Oh dear. That old chestnut again.
15:44:27 <liyang> hunteriam: do you want actual GMT (FWIW the term is discouraged for technical use; in UK colloquial usage it means not-summer-time) or British (including summer) time?
15:44:47 <hunteriam> liyang: trying to comply with https://en.wikipedia.org/wiki/HTTP_cookie#Expires_and_Max-Age
15:45:36 <hpc> i googled "utc vs gmt" and got this: https://dl.dropboxusercontent.com/u/37707/Untitled.png
15:45:41 <liyang> hunteriam: I think for that you can treat GMT as synonymous with UTC.
15:46:18 <dgpratt> alright, I am nigh unto giving up on this self-inflicted exercise, so I may as well ask for help :)
15:47:07 <dgpratt> a bit of a mess, but I can seem to get no further, at least without a clue http://lpaste.net/3142081242053214208
15:47:39 <shirt> athan: thanks
15:49:03 <dgpratt> so...any hints as to how I might turn a "a :: f (Free f (a -> b))" and a "x :: f (Free f a)" into a "Free f b" ?
15:49:27 <Cale> dgpratt: Well, it's got to be recursive, right?
15:49:45 <dgpratt> I suppose that makes sense, Cale
15:50:02 <mpickering> and fmap
15:50:14 <dgpratt> and I suppose that means I'd be referring to a base case somewhere
15:50:46 <dgpratt> or a...I don't know...recursive case
15:50:55 <dgpratt> terminology fail
15:51:10 <hpc> dgpratt: solve f (Free f b) and then solve getting out of f
15:51:34 <dgpratt> hpc, heh -- I'm pretty sure I had that at one point :/
15:51:37 <liyang> athan: most of Hackage don't mention ‘GMT’ because it has a wibbly-wobbly definition…
15:51:42 <dgpratt> lemme see if I can conjure it again
15:51:47 <chrisdotcode> @src foldr
15:51:47 <lambdabot> foldr f z []     = z
15:51:47 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:52:38 <Cale> Actually, it might be easiest to rethink the other Free case -- it actually turns out to be possible to handle the  Free fa <*> x  all at once with a single definition.
15:52:54 <hpc> dgpratt: btw, Free is Applicative
15:53:03 <Cale> Er, I should use your terms, Wrap fa <*> x
15:53:22 <dgpratt> Cale, I wondered that
15:53:44 <Cale> So what do we have here?
15:54:09 <hpc> :t Free
15:54:10 <lambdabot> Not in scope: data constructor ‘Free’
15:54:27 <Cale> Wrap a <*> x = ...
15:54:46 <Cale> here we have  a :: f (Free f (a -> b))
15:55:06 <hunteriam> a -> b -> (a,b)?
15:55:07 <Cale> and we have  x :: Free f a
15:55:17 <vikingofrock> So you know how in haskell, whenever you call a non-IO function with the same inputs you get the same output? What's that feature called?
15:55:28 <MitchellSalad> referential transparity
15:55:30 <hunteriam> vikingofrock: referential transparency
15:55:32 <vikingofrock> thank you
15:55:33 <hpc> you might be able to do \a x -> Free (a <*> x)
15:55:36 <MitchellSalad> -ency, yeah. lol
15:55:37 <vikingofrock> I couldn't remember that for the life of me
15:55:47 <Cale> vikingofrock: In fact, if you apply *any* function to the same inputs, you get the same result
15:56:01 <hunteriam> IO is just weird
15:56:03 <Cale> vikingofrock: It's just that functions which produce IO actions will always produce the same IO action
15:56:19 <Cale> and you have to execute the IO action to get *its* result, which is a separate process from evaluation
15:56:25 <hunteriam> ^^
15:56:36 <Cale> But the evaluation of which IO action you have is still deterministic
15:56:52 <hpc> dgpratt: try \a x -> Free (a <*> x) -- i don't have free installed at the moment
15:57:04 <liyang> Listen to Cale people. The distinction is important to get your head around IO. :)
15:58:06 <vikingofrock> So what you're saying is that `readFile "input.txt"` always will open "input.txt
15:58:08 <vikingofrock> "
15:58:16 <Cale> heh, yes
15:58:44 <vikingofrock> but that the result of that is different depending on the contents of "input.txt"?
15:58:57 <Cale> When we evaluate readFile "input.txt", we always get the same description of an action which could be carried out to produce a String
15:59:06 <Cale> But we don't actually read the file
15:59:29 <Cale> It's only executing the resulting action which reads the contents of the file
15:59:45 <vikingofrock> hmmm okay I think I understand
15:59:49 <Cale> The difference between a value of type IO String and a value of type String is the difference between /bin/ls and a list of files
16:00:21 <Cale> You can open up /bin/ls in a hex editor, and it won't cause the contents of your home directory to be printed to the terminal
16:00:28 <vikingofrock> that's a really elegant way to think about that
16:00:29 <vikingofrock> wow
16:00:31 <Cale> You have to actually execute the program to have that effect happen
16:00:35 <hunteriam> evaluate the action vs. describe it
16:00:58 <hpc> or if you know C, it's the difference between printf and &printf
16:01:05 <Cale> uhhhh
16:01:20 <hpc> er, printf() and &printf
16:01:23 <Cale> I don't know if I like that last analogy, but kinda :)
16:01:39 <hpc> yeah fair point
16:02:14 <Cale> But yeah, the code in memory for printf vs. the result when you actually run printf
16:02:18 <Cale> sure
16:02:45 <Cale> dgpratt: Okay, let's get back to this
16:02:53 <Cale> dgpratt: What are we trying to produce?
16:03:04 <Cale> We want to produce a value of type Free f b
16:03:20 <dgpratt> uhh... :: Free f b
16:03:22 <Cale> Can we do it using Return?
16:03:27 <Cale> probably not, right?
16:03:34 <Cale> We don't have a value of type b hanging around
16:03:38 <Cale> and it looks hard to get one
16:03:42 <dgpratt> right
16:03:45 <Cale> So, let's try Wrap
16:03:56 <Cale> Wrap a <*> x = Wrap ...
16:04:06 <Cale> so now what are we trying to produce?
16:04:12 <Cale> f (Free f b), yeah?
16:04:26 <dgpratt> GHC agrees, Cale
16:04:26 <Cale> and we have, for reference
16:04:36 <hpc> wait, is this Free a different version from the one in the 'free' package?
16:04:38 <Cale> a :: f (Free f (a -> b))
16:04:38 <dgpratt> :: Free f (a -> b)
16:04:53 <dgpratt> hold on a sec...
16:05:07 <Cale> a is the contents of the Wrap constructor
16:05:21 <Cale> hpc: It's straightforwardly isomorphic, the names are a little different
16:05:33 <dgpratt> ok, I tried to merge the last two cases, so I just did "x <*> (Return y)"
16:05:50 <dgpratt> oh, I confused myself
16:05:53 <dgpratt> hold on...
16:05:58 <Cale> okay :)
16:06:04 <dgpratt> (merged the wrong thing)
16:06:06 <Cale> Your Return case is fine
16:06:14 <Cale> (for the first argument)
16:06:24 <Cale> er, is it?
16:06:33 <Cale> yeah, it looks okay
16:06:34 <dgpratt> it type checks!
16:06:36 <dgpratt> :)
16:06:40 <Cale> all right, it's probably good
16:07:15 <Cale> So we're doing
16:07:15 <dgpratt> ok, "x :: f (Free f a)" and "a :: f (Free f (a -> b))"
16:07:20 <hpc> dgpratt: \a x -> Free (a <*> x) -- this works with the version in http://hackage.haskell.org/package/free-4.12.1/docs/Control-Monad-Free.html
16:07:24 <Cale> nope
16:07:28 <hpc> :: Applicative f => f (a1 -> Free f a) -> f a1 -> Free f a
16:07:30 <Cale> x :: Free f a
16:07:33 <hpc> er, crap
16:07:36 <Cale> hpc: pls
16:07:44 <Cale> no cheaterinoes :)
16:07:55 <hpc> it's okay, i was wrong anyway
16:08:00 <Cale> It's a good exercise working these things out from the types
16:08:23 <Cale> It just requires care thinking about what you have and what your goal is at each step
16:08:25 <dgpratt> umm, why do we disagree about x, Cale?
16:08:33 <Cale> Because I think we're writing
16:08:36 <Cale> Wrap a <*> x
16:08:39 <Cale> = ...
16:08:40 <dgpratt> oh
16:08:43 <dgpratt> ok
16:08:47 <dgpratt> we can do that :)
16:09:04 <Cale> yeah
16:09:25 <dgpratt> but if we did, the former case would be redundant, no? Or am I really confused?
16:09:28 <Cale> yes
16:09:34 <dgpratt> to which? :)
16:09:36 <Cale> That's what I was talking about with the merging
16:09:44 <dgpratt> ok, we are merging, got it
16:10:03 <Cale> all right
16:10:04 <erisco> Data.Set should be Applicative too
16:10:07 <dgpratt> "x :: Free f a" ?
16:10:11 <Cale> yep
16:10:13 <vvrr> agh kind of wish hackage packages would pick a case convention and stick with it
16:10:13 <dgpratt> ok
16:10:15 <dgpratt> phew
16:10:17 <erisco> am I blinded and missing that instance as well?
16:10:33 <erisco> > S.pure id <*> S.pure 3
16:10:35 <lambdabot>      Not in scope: ‘S.pure’
16:10:35 <lambdabot>      Perhaps you meant data constructor ‘L.Pure’ (line 198)    Not in scope: ...
16:10:35 <lambdabot>      Perhaps you meant data constructor ‘L.Pure’ (line 198)
16:10:35 <Cale> erisco: what instance? It's not an Applicative for all types
16:10:42 <erisco> whoops
16:10:53 <erisco> > S.singleton id <*> S.singleton 3
16:10:53 <Cale> erisco: you can only do nontrivial things to Sets when you have an instance of Ord
16:10:54 <lambdabot>      Could not deduce (Applicative S.Set) arising from a use of ‘<*>’
16:10:54 <lambdabot>      from the context (Num b)
16:10:54 <lambdabot>        bound by the inferred type of it :: Num b => S.Set b
16:11:08 <Cale> erisco: but when you're writing fmap, you don't have an instance of Ord
16:11:18 <Cale> because the type of fmap doesn't demand that an Ord instance exist
16:11:19 <Cale> s
16:11:43 <Cale> dgpratt: Okay
16:11:50 <erisco> Cale, ah I see
16:11:54 <erisco> darnit fmap ;)
16:12:12 <Cale> erisco: and it's not just fmap, also <*> would give you the same trouble
16:12:24 <Cale> (but not pure, because singleton can work without Ord)
16:12:51 <Cale> <*> gives you even more trouble because you'd be working with Set (a -> b)
16:12:58 <Cale> which means that you need an Ord instance for functions
16:13:05 <Cale> to build those
16:13:13 <erisco> I suppose you'd want the a -> Bool definition of Set for those instances
16:13:26 <erisco> unfortunate that there is this Ord thing
16:13:38 <Cale> Well, Set isn't quite like mathematical sets
16:13:39 <erisco> something something complexity
16:13:46 <Cale> It's something quite different
16:14:34 <Cale> erisco: Even if you reduce the Ord requirement to Eq, you run into the same issues
16:14:45 <Cale> (and have shitty complexity at that :)
16:15:08 <Cale> But you can do some things about this issue
16:16:06 <aweinstock> Cale: does (newtype MySet a = a -> Bool) run into the same issues?
16:16:09 <Cale> There's various libraries out there which provide notions of the Functor classes but restricted by an arbitrary choice of classes
16:16:40 <Cale> aweinstock: It might be hard dealing with fmap
16:17:26 <Cale> Like, you're given (a -> b) and (a -> Bool), and now you want (b -> Bool)
16:17:30 <Cale> wat do?
16:17:40 <Cale> You don't know what type a or b is
16:18:18 <Cale> You have no values of type a, so you can't use your functions a -> b or a -> Bool
16:18:30 <Cale> and you have no value of type b, so you can't use your function b -> Bool
16:19:31 <aweinstock> (b -> Bool) is the result, we don't even have one of those (without fix)
16:20:22 <Cale> oh, der, sorry
16:20:43 <Cale> yeah, you have a value of type b, and want to produce a Bool result based on it and the information from the rest
16:21:01 <Cale> but the rest of the information you have doesn't help you because you have no value of type a
16:21:03 <aweinstock> if only f were invertible ;)
16:21:07 <Cale> yeah
16:21:12 <Cale> or if you could find preimages
16:24:09 <aweinstock> fmap f (MySet s1) = MySet (\b -> any (\a -> s1 a && f a == b) [minBound..maxBound]) -- I think this is logically correct, but now it requires (Enum, Bounded, Eq) and is inefficient too
16:24:26 <aweinstock> so that doesn't quite solve the problem of constraints
16:28:07 <Nadrieril> aweinstock: wouldn't your set be more of a Contravariant functor ?
16:28:49 <Nadrieril> with contramap f (MySet s) = Myset (s . f)
16:29:26 <Nadrieril> (I didn't read what the problem was, I only noticed that)
16:30:57 <koz_> I want to write an enumerated type with one of four possible Char values. I tried doing it like this: newtype AttributeKind = 'p' | 'd' | 's' | 'a'
16:31:15 <koz_> However, Haskell's not happy with that. How would I write what I need?
16:31:47 <roconnor> all you can do is newtype AttributeKind = P | D | S | A
16:31:50 <aweinstock> @hoogle Contravariant
16:31:50 <lambdabot> package contravariant
16:32:16 <geekosaur> wouldn't tat be type, not newtype?
16:32:19 <geekosaur> er, data
16:32:21 <koz_> roconnor: Oh, ok. Well, that works.
16:32:22 <roconnor> er right
16:32:23 * geekosaur sigs
16:32:26 <roconnor> data AttributeKind = P | D | S | A
16:32:29 <geekosaur> ....
16:32:40 <roconnor> you can make a Prism Char AttributeKind
16:32:41 <geekosaur> might be naptime here >.>
16:32:43 <aweinstock> Nadrieril: that looks correct
16:32:51 <koz_> roconnor: Thanks, that actually works for me.
16:32:57 <koz_> Although I might find some more semantic names.
16:33:40 <koz_> How would I do a type that represents a natural number value in the range [1, 2, 3, 4, 5]?
16:33:41 <Nadrieril> aweinstock: i'm not sure what you can do with that though
16:34:01 <Nadrieril> is there a contravariant applicative ?
16:34:09 <aweinstock> Nadrieril: it looks like that already exists as Data.Functor.Contravariant.Predicate (what I was calling MySet)
16:34:24 <Nadrieril> well, here you go ^^
16:34:25 <geekosaur> koz_, Haskell doesn't support subtyping, so you either use constructors instead like with AttributeKind or you play games with TypeLits
16:34:28 <roconnor> data Five = One | Two | Three | Four | Five
16:34:46 <roconnor> or use a newtype over an Int and smart constructors.
16:34:49 <geekosaur> ...or you use smart constructors and check stuff at runtime
16:35:02 <koz_> roconnor and geekosaur: OK, thanks for that.
16:35:24 <Nadrieril> aweinstock: apart from the fact that their predicate doesn't have a lot of structure like your tree
16:35:35 <Nadrieril> you'd have to define the monoid instances, etc
16:36:03 <Nadrieril> although you could use the All and Any monoid newtypes of Bool
16:36:37 <aweinstock> err, what tree?
16:36:45 <Nadrieril> *set, sorry
16:37:07 <geekosaur> there's also Liquid Haskell, I guess
16:37:16 <geekosaur> http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/about/
16:37:20 <aweinstock> data MySet a = MySet (a -> Bool) -- this is exactly the same as Data.Functor.Contravariant.Predicate
16:37:55 <aweinstock> well, modulo data/newtype
16:38:09 <Nadrieril> yup
16:38:19 <aweinstock> (am I missing something?)
16:38:22 <Nadrieril> no
16:38:47 <Nadrieril> I was just saying they didn't define anything for composing "sets" like you did
16:39:04 <Nadrieril> oh, here is a contravariatn applicative: https://hackage.haskell.org/package/contravariant-1.3.3/docs/Data-Functor-Contravariant-Divisible.html#t:Divisible
16:39:43 <Cale> dgpratt: sorry, got distracted by dinner :)
16:39:53 <Cale> dgpratt: did you manage to solve it?
16:40:06 <Cale> dgpratt: or should we work through some more?
16:40:25 <dgpratt> Cale, no problem -- naw, I'm still working on it -- thought I was getting somewhere, but no such luck
16:40:44 <Cale> okay, let's go to #haskell-overflow just to avoid noise from other discussions :)
16:42:43 <aweinstock> Nadrieril: the prose in the documentation for contravariant goes way over my head
16:42:56 <Nadrieril> aweinstock: me too ^^
16:43:35 <aweinstock> what's a co-pre-sheave? what's even a sheave?
16:45:08 <Nadrieril> I have not the slightest idea
16:45:24 <Nadrieril> bu you don't need the theory to actually use the thing
16:45:40 <Nadrieril> apparently applicatives are defined similarly
16:46:53 <aweinstock> and are divide/conquer in Contravariant.Divisible related to divide and conquer algorithms, or is conquer just a pun after divide was named sanely?
16:47:47 <chrisdotcode> @src fold
16:47:48 <lambdabot> Source not found. It can only be attributed to human error.
16:47:49 <chrisdotcode> @src foldr
16:47:49 <lambdabot> foldr f z []     = z
16:47:49 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:48:50 <Nadrieril> can't help you there, sry
16:56:07 <parsnip> hmm, so regarding this .ghci created by `stack init`, i have errors re: dist/build/autogen/cabal_macros.h, i found a mailing list mention of this, that suggests using `cabal configure && cabal build` to generate this file. but then i get a series of entires listed after "cabal: At least the following dependencies are missing:", is there a way to fix this? ultimately, i was trying to do `stack ghci` in hakyll/, and wasn't su
16:56:07 <parsnip> commenting out that line in .ghci was a good idea. 
16:57:00 <parsnip> i'm also upgrading stack, hopefully i can try that soon. 
16:57:19 <geekosaur> you hit an IRC messagelength limit by the way
16:57:30 <geekosaur>  i was trying to do `stack ghci` in hakyll/, and wasn't su <-- chopped here
16:57:42 <kadoban> parsnip: 'stack init' doesn't create a .ghci file ?
16:58:48 <parsnip> kadoban: it does, but when i do `stack ghci`, i get a complaint about cabal_macros.h, unless i comment out /that/ half of .ghci
16:59:10 <luigy> lpaste the .ghci 
16:59:54 <parsnip> http://lpaste.net/148788
17:00:00 <kadoban> parsnip: I've done 'stack init' quite a bit, none of them have a .ghci file. I think you're confused, or I am.
17:00:30 <luigy> kadoban it doesn't afaik :)
17:00:47 <parsnip> oops, you're right https://github.com/jaspervdj/hakyll/blob/master/.ghci
17:00:54 <parsnip> i guess it made the stack.yaml
17:01:09 <kadoban> Right
17:03:06 <parsnip> hmm, should i bother trying to get `cabal configure && cabal build` to succeed? 
17:03:28 <parsnip> here is article where i saw this suggested: https://mail.haskell.org/pipermail/libraries/2012-September/018491.html
17:04:23 <parsnip> geekosaur: "ultimately, i was trying to do `stack ghci` in hakyll/, and wasn't sure if simply commenting out that line in .ghci was a good idea."
17:05:54 <luigy> parsnip `stack ghci` handles that for you.. no need for any of those
17:07:47 <parsnip> no need for what exactly? i get an error if i "don't do anything". 
17:10:28 <luigy> the error you're getting is from loading a file expected at a path that cabal defaults to, but not stack... in the other hand stack ghci already "configures and builds" and loads the macros file for you just by running that command
17:11:24 <vvrr> hrm repa matrix syntax is kinda verbose
17:12:14 <parsnip> so may i interpret that as it is okay too comment out that line in .ghci
17:13:03 <luigy> parsnip it is :)
17:13:46 <vvrr> wat?? toIndex (Z :.3 :. 5 :: DIM2) (Z :. 0 :. 1000) = 1000 really?
17:14:15 <parsnip> okay, thank you for taking a look at this with me haskellers
17:16:18 * hackagebot hOpenPGP 2.4 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.4 (ClintAdams)
17:42:12 <acertain> is there any way to attack info to MVars that I cat get back on a "thread blocked indefinitely in an MVar operation"?
17:42:29 <acertain> *attach
17:45:26 <Ygg> Why does gloss always take 25À of my CPU ?
17:45:48 <Ygg> 25 percent*
17:47:13 <Ygg> even gloss-examples do
17:50:58 <dgpratt> with lots of prodding from Cale, I completed my derivation of Applicative and Monad for Free
17:51:06 <dgpratt> but I noticed something curious
17:51:08 <dgpratt> http://lpaste.net/7407097660923969536
17:51:41 <dgpratt> the second case of <*> correlates quite closely to the second case of >>=
17:51:56 <dgpratt> (just substitute >>= for <*>)
17:52:10 <dgpratt> but the first case of each is not quite so correlated
17:52:19 <dgpratt> is there anything that can be said about this?
17:52:24 <hpc> dgpratt: rewrite Wrap (fmap (<*> b) a) as Wrap ((fmap . (<*>)) b a)
17:52:39 <hpc> and it'll look even cooler
17:52:57 <hpc> wait no, that's wrong
17:53:28 <hpc> Wrap ((fmap . (<*>)) a b)
17:55:07 <dgpratt> interesting
17:55:52 <Nadrieril> I don't think that's correct, it will fmap into b
17:55:53 <dgpratt> though, tbh, I'm not sure why
17:56:19 * hackagebot pandoc 1.16.0.1 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-1.16.0.1 (JohnMacFarlane)
17:57:18 <Nadrieril> (fmap (<*> b) a) = ((fmap . (flip (<*>))) b a) I think
17:58:46 <dgpratt> @pl \a b -> fmap (<*> b) a
17:58:46 <lambdabot> flip (fmap . flip (<*>))
17:59:23 <dgpratt> @pl \b a -> fmap (<*> b) a
17:59:24 <lambdabot> fmap . flip (<*>)
17:59:28 <dgpratt> right
17:59:46 <songzh> Hi, I have a question. I want to quote a data declaration in a file by using template Haskell QQ quoteFile, however, d,t,e,p are built-in quoters. How can I do this? 
18:03:22 <dgpratt> what's the language extension that makes things compile in the face of type errors?
18:03:51 <Nadrieril> python ?
18:03:53 <andromeda-galaxy> dgpratt: -fdefer-type-errors?
18:03:57 <hpc> haha
18:03:58 <andromeda-galaxy> dgpratt: https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/defer-type-errors.html
18:04:01 <dgpratt> Nadrieril, :P
18:04:14 <andromeda-galaxy> Nadrieril: typed racket!
18:04:55 <andromeda-galaxy> dgpratt: liberal application of cast [cast :: a -> b; cast = cast] will also work
18:05:00 <dgpratt> thanks, andromeda-galaxy, I just need to translate that to "stack ghci"
18:05:09 <andromeda-galaxy> dgpratt: ah, that should be interesting..
18:05:15 <dgpratt> andromeda-galaxy, not sure I seen that before
18:05:20 <dgpratt> the cast stuff
18:05:32 <andromeda-galaxy> dgpratt: that wasn't serious
18:05:37 <dgpratt> oh
18:05:42 <andromeda-galaxy> it just plays on the fact that bottom inhabits every type
18:05:45 <andromeda-galaxy> (sorry!)
18:05:47 <dgpratt> gotcha
18:06:35 <andromeda-galaxy> dgpratt: that was half a response to the "Python!" comment... sorry if I didn't make it clear
18:06:54 <dgpratt> np, got you now :)
18:21:26 <confusedLifter> hey haskellers. i'm a bit confused about a lift situation. here's some code - http://lpaste.net/148790
18:21:49 <confusedLifter> where i have my comment, i'd like to call some func that runs in some `ThingMonad` that i have
18:22:07 <confusedLifter> i'm confused how to do it
18:22:30 <confusedLifter> trying say x <- thingFunc and then operating on that as if it were my wrapped value doesn't typecheck
18:22:36 <confusedLifter> (i mean non-wrapped value)
18:22:55 <confusedLifter> it's still wrapped up in ThingMonad, because i'm in the IO monad there
18:24:09 <OutlawStar> any one used criterion before?
18:24:11 <andromeda-galaxy> confusedLifter: why does it say 'thing :: runThing $ do'?
18:24:12 <vvrr> woah weird
18:24:33 <vvrr> using repa, using $ introduces a type error that explicit parens don't
18:24:38 <vvrr> any idea why that would be?
18:24:50 <andromeda-galaxy> vvrr: maybe it's something about the precedence of $?
18:24:58 <hpc> vvrr: higher-ranked types probably
18:25:04 <andromeda-galaxy> a b $ c d = (a b) (c d), IIRC
18:25:05 <hpc> ST has the same issue
18:25:16 <andromeda-galaxy> oops, never mind, hpc probably has it...
18:25:19 <hpc> ($) should have been special-cased by ghc to work though, so someone else might have better insight
18:25:26 <vvrr> here R is repa:  putStrLn $ show $ R.computeS $ R.map (+2) foo :: Array U (R.Z :. Int) Int
18:25:30 <geekosaur> that goes the other way, no? $ is effectively special cased, . thows a type error
18:25:41 <vvrr> Couldn't match expected type ‘Array U (Z :. Int) Int’ …with actual type ‘IO ()’
18:25:53 <andromeda-galaxy> vvrr: is the :: Array supposed to be the type of R.map (+2) foo?
18:26:01 <geekosaur> oh, :: does not obey $
18:26:01 <vvrr> whereas this is fine:  putStrLn $ show (R.computeS $ R.map (+2) foo :: Array U (R.Z :. Int) Int)
18:26:09 <geekosaur> it scopes all the way through the putStrLn
18:26:20 <geekosaur> :: is syntax, not operator, precedence does not apply
18:26:26 <andromeda-galaxy> geekosaur: just what I was getting at...
18:26:38 <vvrr> andromeda-galaxy :: is supposed to be the type of foo as well as transformations on it
18:26:44 <vvrr> er the map transformation specifically
18:28:21 <andromeda-galaxy> vvrr: geekosaur beat me to the punch, but the main point is that :: isn't scoped by $
18:28:36 <confusedLifter> andromeda-galaxy: ah i didn't mean "::" i meant "="
18:28:54 <andromeda-galaxy> confusedLifter: ah, okay
18:29:23 <andromeda-galaxy> confusedLifter: what's the type of runThing?
18:29:28 <confusedLifter> andromeda-galaxy: thing is of type IO ()
18:29:40 <confusedLifter> it's of type ThingMonad a -> IO a
18:29:49 <vvrr> andromeda-galaxy geekosaur I see
18:30:19 <andromeda-galaxy> confusedLifter: ah, okay...
18:30:22 <andromeda-galaxy> @hoogle race_
18:30:23 <lambdabot> No results found
18:30:25 <andromeda-galaxy> @ty race_
18:30:27 <lambdabot> Not in scope: ‘race_’
18:30:34 <andromeda-galaxy> @hoogle race
18:30:34 <lambdabot> Debug.Trace module Debug.Trace
18:30:34 <lambdabot> Debug.Trace putTraceMsg :: String -> IO ()
18:30:34 <lambdabot> Debug.Trace trace :: String -> a -> a
18:30:40 <vvrr> does anyone use accelerate on OSX? someone was saying the other day there are some issues with OSX support.
18:30:40 <andromeda-galaxy> @ty race
18:30:42 <lambdabot> Not in scope: ‘race’
18:31:16 <confusedLifter> andromeda-galaxy: race isn't documented probably due to async not having docs on hackage
18:31:19 <confusedLifter> andromeda-galaxy: maybe
18:31:31 <andromeda-galaxy> confusedLifter: ah, okay, I just found it...
18:31:38 <andromeda-galaxy> so, what's the type of the first argument of race?
18:32:00 <confusedLifter> andromeda-galaxy: race takes IO a's
18:32:13 <confusedLifter> and gives back an IO a
18:32:35 <confusedLifter> andromeda-galaxy: my confusion is i can use a `runThing` to get an IO a from a ThingMonad a
18:32:48 <andromeda-galaxy> confusedLifter: ah, I see...
18:33:01 <confusedLifter> andromeda-galaxy: but I don't want to run another `runThing`. i want the latter operation from ThingMonad in the IO to race to be performed "up"
18:33:02 <andromeda-galaxy> so what happens with 'x <- runThing (thingFunc ...)'?
18:33:10 <dgpratt> @pl (\c -> x (c . f))
18:33:10 <lambdabot> x . (. f)
18:33:13 <confusedLifter> andromeda-galaxy: that would work
18:33:34 <andromeda-galaxy> can you do x <- thingFunc outside the race and then just use 'x' inside it?
18:33:39 <confusedLifter> andromeda-galaxy: i can't use another `runThing` in my case. i need the operation to be performed up in the original runThing
18:33:51 <confusedLifter> andromeda-galaxy: unfortunately no
18:33:54 <andromeda-galaxy> confusedLifter: without knowing what Thing is, I don't have any idea what might or might not ork
18:34:07 <andromeda-galaxy> confusedLifter: I'm not entirely sure that you can do that the way that you want...
18:34:25 <andromeda-galaxy> confusedLifter: you might be able to use IO (Thing a), I guess, but then I don't think that you could use race_
18:34:32 <confusedLifter> andromeda-galaxy: `ThingMonad` is basically FakeIO from here - http://stackoverflow.com/questions/19953612/haskell-piping-strings-into-io
18:34:59 <confusedLifter> andromeda-galaxy: "basically" because it's almost the same, with just another command aside from getline/putline
18:35:06 <andromeda-galaxy> confusedLifter: okay, I'll look at that... disclaimer: I am by no means an mtl expert
18:35:27 <confusedLifter> andromeda-galaxy: no worries
18:35:53 <confusedLifter> andromeda-galaxy: maybe thinking about IO (ThingMonad a) is what i should do ...
18:36:10 <confusedLifter> but that might not work.. hmm.
18:36:25 <andromeda-galaxy> confusedLifter: that was a quick idea, but on further reflection it might not work with race...
18:37:22 <confusedLifter> andromeda-galaxy: yeah, no, it wouldn't, because yeah i need the thingFunc to actually be "ran"
18:38:06 <andromeda-galaxy> confusedLifter: I'm not sure that there's a direct way to do what you want here
18:38:14 <confusedLifter> andromeda-galaxy: hmm.
18:38:48 <andromeda-galaxy> confusedLifter: wait, how does that lift work, actually?   is Thing a MonadIO?
18:39:00 <andromeda-galaxy> @ty lift
18:39:01 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
18:39:10 <confusedLifter> andromeda-galaxy: lift is taking an IO a to a FakeIO a
18:39:30 <confusedLifter> andromeda-galaxy: as far as i understand
18:39:53 <andromeda-galaxy> confusedLifter: do you have the appropriate instances?  (or am I misunderstanding how this works with free monads?)
18:40:57 <confusedLifter> andromeda-galaxy: yeah, there is definitely a lot happening with free monads that i don't understand.
18:41:19 <confusedLifter> andromeda-galaxy: but the `lift` on some IO a running in FakeIO a definitely works
18:41:44 <confusedLifter> andromeda-galaxy: my problem is that i want to lift AGAIN, inside the IO a up to FakeIO x "above"
18:41:49 <confusedLifter> andromeda-galaxy: maybe i just need a lift . lift ....
18:42:21 <andromeda-galaxy> confusedLifter: but the ThingMonad is "below" the IO, not "above" it
18:43:15 <andromeda-galaxy> @ty lift (a :: IO)
18:43:16 <lambdabot>     Expecting one more argument to ‘IO’
18:43:16 <lambdabot>     Expected a type, but ‘IO’ has kind ‘* -> *’
18:43:16 <lambdabot>     In an expression type signature: IO
18:43:22 <andromeda-galaxy> @ty lift (a :: IO a)
18:43:23 <lambdabot>     Couldn't match expected type ‘IO a1’ with actual type ‘Expr’
18:43:23 <lambdabot>     In the first argument of ‘lift’, namely ‘(a :: IO a)’
18:43:23 <lambdabot>     In the expression: lift (a :: IO a)
18:43:26 <confusedLifter> andromeda-galaxy: sorry, maybe my terminology is bad, but runThing takes a FakeIO (say) which then has IOs (lifted) and also this weirdness with race
18:43:43 <andromeda-galaxy> @ty lift
18:43:44 <confusedLifter> so i'm talking about making subsequent `thingFuncs` inside the race weirdness being run in the context of the "top" runThing
18:43:45 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
18:44:00 <andromeda-galaxy> confusedLifter: right, but lift says, given an IO a, give me a FakeIO a
18:44:09 <confusedLifter> andromeda-galaxy: yes
18:44:10 <andromeda-galaxy> confusedLifter: the inside IO a doesn't know anything about the outside FakeIO a
18:44:20 <confusedLifter> andromeda-galaxy: indeed
18:44:38 <nshepperd_> :t lift (undefined :: IO a)
18:44:39 <lambdabot> MonadTrans t => t IO a
18:44:52 <andromeda-galaxy> nshepperd_: thanks!
18:45:03 <andromeda-galaxy> confusedLifter: so, I don't think that there's any way to do that...
18:45:34 <andromeda-galaxy> :k FreeT
18:45:36 <lambdabot>     Not in scope: type constructor or class ‘FreeT’
18:45:36 <lambdabot>     Perhaps you meant ‘Free’ (line 198)
18:46:33 <confusedLifter> andromeda-galaxy: hmm. okay well thanks for your comments!
18:46:35 <nshepperd_> What exactly is ThingMonad?
18:46:59 <nshepperd_> oh
18:47:02 <confusedLifter> nshepperd_: it's (essentially) exactly FakeIO a from http://stackoverflow.com/questions/19953612/haskell-piping-strings-into-io
18:47:38 <andromeda-galaxy> confusedLifter: no problem...
18:47:59 <andromeda-galaxy> nshepperd_: so it sounds like ThingMonad = FreeT <some functor> IO a,
18:48:07 <andromeda-galaxy> which is why lift (undefined :: IO a) works
18:48:51 <confusedLifter> andromeda-galaxy: yes that is what it is
18:49:22 <vvrr> anyone familiar with computeP in repa? trying to understand how to implement the monad constraint in a simple case
18:49:32 <dgpratt> @pl (\c -> a (\a' -> b (c . a')))
18:49:33 <lambdabot> a . (b .) . (.)
18:49:35 <nshepperd_> ok yeah, you can lift :: IO a -> FreeT f IO a, since it has a MonadTrans instance
18:49:38 <dgpratt> bleh
18:51:13 <andromeda-galaxy> nshepperd_: there's no way to do what confusedLifter wants, is there?
18:51:17 <nshepperd_> confusedLifter: but I gather you want to 'unlift' a FakeIO into an IO?
18:52:12 <confusedLifter> andromeda-galaxy & nshepperd_: here's a compilable example - http://lpaste.net/148792
18:52:45 <confusedLifter> nshepperd_: no, not unlift, i want to run a FakeIO in the context that is "up"
18:52:55 <confusedLifter> nshepperd_: i.e. i only want to "runInOut" *once*
18:56:49 <nshepperd_> I think what you should do here is implement race_ in your DSL
18:57:34 <nshepperd_> add a Race [x] constructor and then actually do the racing in runInOut
18:57:50 <nshepperd_> that way you avoid 'lift'ing there entirely
18:58:00 <synergistics> Is there a specific trick to doing vertical alignment in haskell? In function definitions, a lot of the time I see equal signs lining up for example. Are you just using spaces manually or does your editor handle it?
18:58:32 <andromeda-galaxy> nshepperd_: that's probably the right way to do it.. I hadn't gotten to the point of suggesting other possibilities yet :-(
18:59:07 <andromeda-galaxy> confusedLifter: do you understand why what you were trying to do isn't possible?
18:59:15 <confusedLifter> nshepperd_: alright, i'll try and figure out how to do that
18:59:18 <confusedLifter> andromeda-galaxy: not exactly
19:00:43 <andromeda-galaxy> confusedLifter: once you've lifted race, you need to have an action of type IO ()
19:00:54 <andromeda-galaxy> * IO a
19:01:01 <andromeda-galaxy> confusedLifter: not FakeIO a
19:01:11 <confusedLifter> nshepperd_: i guess doing the racing in runInOut is kind of a fix, but it means i have to right a few race definitions in the different `runXy` functions i have. maybe that's the only solution
19:01:18 <andromeda-galaxy> confusedLifter: think about the desugaring of the do notation
19:02:09 <andromeda-galaxy> confusedLifter if FakeIO is opaque,
19:02:29 <andromeda-galaxy> confusedLifter: actually, scratch that
19:03:08 <andromeda-galaxy> confusedLifter: basically, the point is that, as race_ is written, the action you give it has to be an IO action, so you can only do things that depend on the IO.
19:03:55 <andromeda-galaxy> confusedLifter: the lift in lift $ race_ assumes that it can take in an IO and just add whatever state is necessary to make it into a FakeIO
19:04:09 <confusedLifter> andromeda-galaxy: yeah
19:04:22 <confusedLifter> andromeda-galaxy: and it can; it's fine - the problem is just when i try and put a FakeIO a action *inside* that IO a
19:04:27 <andromeda-galaxy> confusedLifter: so there can't be any FakeIO state left in the action to be sequenced
19:04:39 <confusedLifter> andromeda-galaxy: and i *can* do that, but only if i *runInOut* on it
19:04:41 <andromeda-galaxy> confusedLifter: the only way to do that would be if you could convert the FakeIO action to an IO
19:04:51 <andromeda-galaxy> confusedLifter: right, but you can't do that
19:04:53 <confusedLifter> andromeda-galaxy: indeed
19:05:38 <confusedLifter> andromeda-galaxy: (i mean, i *can* do it, but due to reasons, running with a different "runInOut" breaks what i'm doing here, because what i care about is the context from the outer runInOut)
19:05:46 <andromeda-galaxy> confusedLifter: so, you can't run a FakeIO action inside the lifted IO
19:05:56 <andromeda-galaxy> the lifted IO can't know *anything* about the fact that it's running in a FakeIO
19:06:11 <andromeda-galaxy> confusedLifter: think about it this way:
19:06:33 <andromeda-galaxy> confusedLifter: if the IO a action could know that it was running in a FakeIO, and use something specific to that,
19:06:37 <andromeda-galaxy> then it wouldn't work in any other context
19:06:48 <andromeda-galaxy> but there's nothing in the type IO a that says that it has to be run in a FakeIO context
19:06:58 <andromeda-galaxy> (nshepperd_: if you can think of a better way to explain this, feel free to jump in)
19:07:07 <andromeda-galaxy> confusedLifter: does that make more sense now?
19:08:30 <vvrr> is there a pretty printer function for repa matrices?
19:09:08 <confusedLifter> andromeda-galaxy: indeed, that does make sense to me. but i can't help feeling like there is some magic series of commands that would let me lift up a "deep" FakeIO a func into an outer FakeIO a context
19:09:29 <confusedLifter> andromeda-galaxy: maybe it wouldn't be pretty and it'd be bad, and maybe the Race [x] is the way to do
19:09:35 <confusedLifter> andromeda-galaxy: (go i mean) but yeah.
19:12:32 <andromeda-galaxy> confusedLifter: I don't believe that there is, certainly not while preserving type safety/soundness
19:12:43 <andromeda-galaxy> confusedLifter: I'd advise you to go with the Race [x] way of doing things
19:13:32 <confusedLifter> andromeda-galaxy: thanks, yeah, i'll give it a go.
19:14:44 <andromeda-galaxy> confusedLifter: no problem, I'm glad to be able to help, at least a little
19:17:12 <athan> Anyone here mess around with HXT? I just have a feeling lens would do it better :\
19:18:30 <andromeda-galaxy> athan: I have a little bit, but I can't guarantee that I'll remember anything
19:18:47 <athan> andromeda-galaxy: Haha, yeah same here, it's been a while
19:19:18 <athan> I have a feeling the arrow interface in HXT could just be captured with lenses
19:19:26 <athan> or really, lenses into Data.Tree
19:19:56 <andromeda-galaxy> athan: that's an interesting idea
19:20:26 <athan> andromeda-galaxy: I'm reading the thesis on HXT right now, and they're talking about getters and setters, basically
19:20:39 <andromeda-galaxy> athan: you mean basically building a Data.Tree from the parse tree of the xml,
19:20:42 <athan> and since they're using the arrow interface, I have a feeling lens would generalize this idea in the "right" way
19:20:47 <andromeda-galaxy> and then using lenses to select and update things?
19:20:53 <athan> andromeda-galaxy: Exactly
19:20:57 <athan> that's basically what HXT does
19:21:20 <andromeda-galaxy> athan: that is an interesting idea
19:21:24 <athan> :)
19:21:36 <athan> now I just need to learn lens >.>
19:22:08 <andromeda-galaxy> athan: the whole system of Prisms, etc. really might make it work,
19:22:20 <andromeda-galaxy> since we can compose lenses onto prisms for every element of a given match
19:22:45 <athan> :)
19:22:54 <athan> it would be cool to turn jQuery selectors into lenses
19:23:04 <athan> or CSS selectors I mean
19:23:17 <andromeda-galaxy> athan: it would,
19:23:19 <athan> attribute-based ones, who knows :S either way I bet it would work
19:23:44 <andromeda-galaxy> the attribute-based selectors are a good point, since, IIRC, filter is an improper lens
19:24:25 <athan> andromeda-galaxy: :o how?
19:24:29 <andromeda-galaxy> *improperr traversal
19:24:32 <broma0> does lens provide a means for converting between types like Text and String, or [(a,b)] and Map a b, etc? 
19:24:45 <andromeda-galaxy> broma0: look into Iso?
19:24:57 <andromeda-galaxy> athan: https://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Fold.html (the section on filtered)
19:24:57 <andromeda-galaxy> :
19:25:12 <andromeda-galaxy> athan: This is not a legal Traversal, unless you are very careful not to invalidate the predicate on the target
19:25:25 <andromeda-galaxy> athan: This is also not a legal Prism, unless you are very careful not to inject a value that matches the predicate
19:26:06 <andromeda-galaxy> broma0: IIRC, Iso should let you convert between any set of isomorphic types in a lensish way
19:26:15 <andromeda-galaxy> broma0: https://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Iso.html
19:26:55 <andromeda-galaxy> athan: take a look at xml-lens & hexpat-lens
19:27:27 <athan> andromeda-galaxy: So only combinators that "preserve results of the predicate" should be used? Like folded?
19:27:30 <athan> hmm okay!
19:27:51 <broma0> andromeda-galaxy: that'll do it, i've just been looking into it. thank you!
19:27:55 <andromeda-galaxy> athan: that sounds about right
19:27:59 <andromeda-galaxy> broma0: no problem, glad to help!
19:29:16 <andromeda-galaxy> athan: hexpat-lens and xml-lens both look like relatively undeveloped versions of what you're looking for
19:29:55 <athan> yeah it's a pretty simple idea anyway haha
19:30:41 <andromeda-galaxy> athan: on the other hand, I feel like there's probably some benefit to the arrow api, since it's lasted this long despite being ridiculously difficult to learn
19:30:51 <kwantam> I have a dumb stack question. Is there some stack.yaml directive that says "include the contents of this subdir in the sdist tarball"?
19:31:12 <kwantam> This seems like a really basic thing that should be supported, and yet I cannot find reference to it in the stack documentation.
19:31:45 <andromeda-galaxy> kwantam: I feel like that might be something that should be done in the cabal  file
19:32:00 <andromeda-galaxy> kwantam: (but I'm not sure)
19:32:07 <broma0> what's the general way to model invariants in types like 'newtype Username = Username Text' where the 'Text' should be a certain length, etc?
19:32:17 <hunteriam> https://hackage.haskell.org/package/cookie-0.3.0.2/docs/Web-Cookie.html#t:Cookies
19:32:25 <hunteriam> Im getting `not in scope SetCookie`
19:32:32 <hunteriam> even though ghci autocompletes SetCookie
19:32:33 <hunteriam> what???
19:32:37 <broma0> i always see things like mkUsername and not exposing the constructor, but if i have ten types like this, id like something more polymorphic
19:32:53 <andromeda-galaxy> broma0: if I understand the question correctly, you're getting into dependent types?
19:32:57 <broma0> correct.
19:32:58 <hunteriam> ^
19:33:08 <kwantam> andromeda-galaxy: thanks; I don't remember such a directive, but I will double check
19:33:10 <hunteriam> haskell doesnt have dependent types
19:33:21 <andromeda-galaxy> kwantam: does data-files or extra-source-files work for you?
19:33:36 <andromeda-galaxy> hunteriam: well, technically, it kinda sorta does if you don't mind using singletons
19:33:40 <andromeda-galaxy> (e.g. Hasochism)
19:34:36 <andromeda-galaxy> hunteriam: is something maybe up with the package path?
19:34:57 <hunteriam> andromeda-galaxy: ? i mean ghci is autocompleting SetCookie
19:35:24 <andromeda-galaxy> hunteriam: true... is it possible that ghci is caching completion and using the wrong cache or something, though?
19:35:44 <hunteriam> i dont know?
19:36:11 <andromeda-galaxy> hunteriam: I don't either, it just seemed like a possibility...
19:36:19 <andromeda-galaxy> hunteriam: how are you installing packages & running ghci?
19:36:21 <kwantam> andromeda-galaxy: Yup, I can make extra-source-files work (though I'd rather have it just include a whole directory...).  Thanks!
19:36:22 <hunteriam> stack
19:36:36 <andromeda-galaxy> kwantam: you're welcome, I'm glad to help
19:36:44 <andromeda-galaxy> hunteriam: so you used stack repl to run ghci?
19:36:54 <hunteriam> yea
19:37:03 <andromeda-galaxy> hunteriam: and 'cookie' is in the project stackfile?
19:37:07 <andromeda-galaxy> *cabal file
19:37:12 <hunteriam> yea
19:37:17 <hunteriam> it lets me import the module
19:38:10 <andromeda-galaxy> broma0: if you really want dependently typed Haskell, I'd suggest reading the Hasochism paper, the singletons library, and anything you can find about Richard Eisenberg's DependentHaskell project
19:38:13 <andromeda-galaxy> hunteriam: weird...
19:38:45 <andromeda-galaxy> hunteriam: and you get that from, e.g., :t SetCookie?
19:39:00 <hunteriam> info and :t work
19:39:55 <andromeda-galaxy> hunteriam: okay, I have no idea, sorry...
19:51:22 * hackagebot hero-club-five-tenets 0.3.0.1 - Remember the five tenets of hero club  https://hackage.haskell.org/package/hero-club-five-tenets-0.3.0.1 (i_amd3)
20:00:58 <koz_> How do you tell a GHCi session to use the NoImplicitPrelude option?
20:01:58 <andromeda-galaxy> koz_: ghci -XNoImplicitPrelude?
20:02:07 <koz_> Oh, I see, I can do that.
20:02:14 <koz_> I meant 'inside an already-ticking session'.
20:02:44 <andromeda-galaxy> koz_: I'm not sure if you can do that, but I don't know everything about GHCi...
20:03:12 <koz_> andromeda-galaxy: I'm also trying to do it via 'cabal exec', and 'cabal exec ghci -XNoImplicitPrelude' doesn't make it very happy,
20:03:25 <andromeda-galaxy> koz_: cabal exec -- ghci -XNoImplicitPrelude?
20:04:14 <koz_> andromeda-galaxy: That did it - thanks, I always forget the magic separator.
20:05:28 <koz_> Also, if I need some text parsed into Haskell types (Horn clauses, to be exact), is Parsec the best thing to use?
20:06:34 <andromeda-galaxy> koz_: no problem!
20:08:10 <andromeda-galaxy> koz_: I generally hear that parsec or attoparsec are the de facto parsing libraries
20:08:25 <andromeda-galaxy> koz_: I believe that they have fairly similar interfaces
20:09:42 <andromeda-galaxy> (attoparsec is supposed to be faster, but doesn't do as good of a job with error messages)
20:09:58 <koz_> andromeda-galaxy: OK, I figured as much. Guess I'm learning Parsec then.
20:10:09 <andromeda-galaxy> koz_: glad to be able to help
20:10:38 <vvrr> koz_ i'd suggest attoparsec. the types are similar
20:10:50 <vvrr> koz_ i mean simpler
20:11:14 <vvrr> koz_ as a beginner, Parsec types will have you scratching your head the minute you deviate from the tutorials
20:11:58 <vvrr> hey does anyone know how to print repa matrices as... you know ... matrices instead of a one-line list of numbers?
20:13:11 <andromeda-galaxy> vvrr: nope, sorry!  I haven't worked with attoparsec, but I didn't find parsec that bad, especially compared to lens
20:14:21 <vvrr> andromeda-galaxy well that's a low bar :P parsec isn't _that_ bad, but i'd still say for beginners attoparsec types are simpler
20:15:47 <andromeda-galaxy> vvrr: that's true, thanks for reminding me.  I'll try to keep that in mind next time someone asks about parsec vs attoparsec
20:16:16 <kadoban> Isn't there a Parser type synonym somewhere in parsec that makes it much easier to understand?
20:17:25 <vvrr> something like type Parsec s u = ParsecT s u Identity
20:17:42 <andromeda-galaxy> kadoban: it looks like there's one in attoparsec too, I'm guessing that vvrr is talking about what happens when you have to go beyond the type synonym
20:18:15 <kadoban> andromeda-galaxy: Newbies shouldn't have to though?
20:18:36 <andromeda-galaxy> kadoban: not sure...  vvrr, care to elaborate?
20:18:48 <kadoban> I think you only need full ParsecT when you start doing stuff like parsing with user state and whatever.
20:19:03 <kadoban> Or using IO/whatever else
20:19:15 <vvrr> i used that in some code a few weeks ago and now I've forgotten how the heck it works. perhaps a sign cognitive load required by the library is too high for my pea brain
20:19:23 <koz_> OK.
20:19:26 <vvrr> actually I rewrote the code in attoparsec and I didn't need anything like that
20:19:29 <koz_> Well, I'm only in need of something very simple.
20:19:33 <vvrr> just Parser Text or whatever everywhere
20:19:36 <koz_> Like, stuff I'm parsing looks like this:
20:19:37 <vvrr> makes much more sense
20:19:49 <koz_> (a = 5) and (b = 3) => (c = 0)
20:19:51 <geekosaur> Parsec hides the transformer, iirc Parser hides the state and the token type (and has a different instantiation for each token type --- over String, ByteString, Text)
20:20:56 <geekosaur> so Parser a from Parsec.Text is ParsecT (stream type for Text here) (user state type here) Identity a
20:21:43 <kadoban> Right, thanks. So as long as a newbie is correctly pointed to using that, they should get by okay I'd hope? Maybe some of the docs might still be a tad tough to understand unless you know what parts you can ignore though.
20:22:29 <vvrr> geez see? this stuff still makes my brain hurt at my level. whereas attoparsec's Parser WhateverType is much simpler
20:23:32 <geekosaur> ...you just haven't looked inside, I think. attoparsec does the same thing; its Parser hides a more complex actual type
20:23:57 <geekosaur> (attoparsec supports ByteString and Text so must have similar token polymorphism hidden inside)
20:24:35 <geekosaur> btu if you treat Parsec's Parser like attoparsec's Parser you can similarly pretend it's that simple
20:24:40 <vvrr> geekosaur that may be so, but attoparsec hides the abstraction pretty well from my use of it. whereas with Parsec I need to know what's going on under the hood.
20:24:57 <geekosaur> you do? I've never had to care
20:24:59 <kadoban> vvrr: In what circumstances do you?
20:25:32 <geekosaur> mind that I learned parsec back when it only supported String and didn't have either the transformer (I think) or the token stream polymorphism
20:25:45 <geekosaur> yet the same code works
20:25:49 <vvrr> kadoban was doing a fairly simple parsing task for a very simple file format, nothing fancy.
20:26:10 <vvrr> kadoban and I was struggling with the type errors until someone showed me that type alias trick
20:26:23 * hackagebot true-name 0.1.0.0 - Template Haskell hack to violate another module's abstractions  https://hackage.haskell.org/package/true-name-0.1.0.0 (LiyangHu)
20:26:25 <vvrr> (which I still don't grok to be hoenst)
20:27:07 <kadoban> vvrr: I see. I'm mostly curious because I'm not sure if pointing out something specific in that area would greatly help newbies. Parsec is nice because the errors you get back for failed parses tend to be a lot better, and I remember that being quite important especially at first (and is nice for a user anyway usually).
20:27:34 <kadoban> vvrr: Well kind of the point ideally *should* be that you don't have to grok them, the simple type alias should be enough for anyone that's doing a normal thing.
20:27:58 <vvrr> kadoban i think a bunch of the errors were around type ambiguities
20:28:16 <kadoban> Hmm, interesting. I'll have to pay attention next time I play with parsec and see.
20:29:21 <vvrr> maybe if that type alias trick was built in and used in tutorials it wouldn't have been as awkward to work with
20:30:25 <andromeda-galaxy> vvrr: I definitely didn't see 
20:30:39 <andromeda-galaxy> any type ambiguity errors when I wrote a tiny dsl perarse
20:30:41 <andromeda-galaxy> *parser
20:30:44 <andromeda-galaxy> in parsec
20:31:06 <andromeda-galaxy> vvrr: did you last work with it before the introduced the new types?
20:31:20 <vvrr> andromeda-galaxy when were the new types introduced?
20:31:33 <koz_> Also, I'm trying to do this: newtype Foo a b = [Bar a b] . Haskell doesn't like that very much. What am I missing?
20:32:00 <mauke> koz_: a constructor
20:32:06 <hunteriam> @where paste
20:32:06 <lambdabot> Haskell pastebin: http://lpaste.net/
20:32:07 <koz_> So I have to writ something like
20:32:08 <vvrr> andromeda-galaxy it was a few weeks ago and i was less haskell-knowledgeable then, so I think I've wiped most of the struggles from my memory. But I remember one thing the type ambiguity issues breaking when i tried to parseFromFile
20:32:20 <koz_> newtype Foo a b = Foo [Bar a b] or somesuch?
20:32:26 <mauke> koz_: yes
20:32:34 <koz_> mauke: Thanks - still getting the hang of this.
20:33:00 <hunteriam> http://lpaste.net/148797
20:33:06 <hunteriam> Looking for criticism of my formatting
20:33:24 <andromeda-galaxy> vvrr: I don't know, but they've been around for a while...
20:33:43 <mauke> hunteriam: scroll down on your paste :-)
20:39:07 <koz_> Am I right in thinking that Ord for pairs of the form (a, b) is implemented by comparing the first elements, and if those are equal, then comparing the second?
20:39:17 <koz_> (like, the default derived one)
20:40:57 <pavonia> I think so
20:45:57 <andromeda-galaxy> anyone know of a library for injecting key & mouse events from Haskell on Linux (e.g. using uinput)?
20:47:07 <wedens> how can I generate list (or set) of some size with unique values using quickcheck?
20:48:01 <andromeda-galaxy> wedens: sized and vectorOf?
20:48:05 <heatsink> The easiest way would be, generate a list, and skip the test if it doesn't have unique values
20:48:15 <wedens> andromeda-galaxy: it's not unique
20:48:20 <andromeda-galaxy> wedens: oops, sorry, missed that
20:49:29 <andromeda-galaxy> wedens: I think that heatsink is right about the easiest way, if you don't want to do that you'll probably need to write a custom Gen instance
20:50:12 <heatsink> forAll (vectorOf 4 int) $ \v -> (length (nub v) == length v) ==> f v
20:50:47 <heatsink> b ==> p will skip the test if b is false
20:51:12 <wedens> ok. thanks heatsink, andromeda-galaxy
20:53:46 <chrisdotcode> does anybody know the name of a monoid without the associative operator?
20:53:58 <dzdncnfzd> Hey guys! I'm trying to get the haskell download library and coming up with an error during build. Does anyone know a fix? Not in scope: ‘unsafePerformIO'
20:53:59 <chrisdotcode> basically, an identity-only category
20:54:28 <chrisdotcode> dzdncnfzd: what platform are you on, and what platform are you trying to install?
20:54:33 <chrisdotcode> the haskell platform?
20:55:15 <dzdncnfzd> chrisdotcode: I'm using stack -- what does that imply?
20:55:21 <kadoban> chrisdotcode: I thought the identity value only made sense in terms of the operator? Otherwise, in what sense is it an identity value?
20:55:34 <dzdncnfzd> chrisdotcode: aka how can I figure out the platform for you?
20:56:17 <kadoban> (this is possibly a really dumb question, I'm shit at abstract algebra and CT and math)
20:57:32 <chrisdotcode> kadoban: I can think of a few examples: IP addresses, which have no meaningful combination, but have 'localhost' as the default. file trees which might have '/' as the identity (but which might have a mappend)... actually, writing that out makes me realize that an identity only is a set with a "default" value.
20:57:58 <chrisdotcode> data-default covers my use case (I guess?), but I'm curious if there's a mathematical name for what I'm describing
20:58:06 <chrisdotcode> dzdncnfzd: stack should generally be stable; what OS are you running?
20:58:15 <heatsink> A set with a "default" value is called pointed
20:58:18 <chrisdotcode> dzdncnfzd: which package are you trying to download?
20:58:21 <dzdncnfzd> Mac OsX
20:58:25 <chrisdotcode> heatsink: excellent - thanks
20:58:31 <heatsink> Wait, that's a functor with a default value
20:58:42 <heatsink> Not quite what you're asking for
20:58:45 <dzdncnfzd> chrisdotcode: download-0.3.2
20:59:18 <chrisdotcode> heatsink: https://en.wikipedia.org/wiki/Pointed_set seems to imply it's not only for functors?
20:59:42 <chrisdotcode> dzdncnfzd: I'm not on mac, so my help might be limited. Doesn't stack have install instructions on the website/ binarys for OS X?
20:59:56 <heatsink> chrisdotcode: Hmm, I think you're right
21:00:12 <chrisdotcode> heatsink: technically, you would be right :)
21:00:16 <heatsink> In the category of pointed sets, there's an additional constraint that all functions map points to points
21:00:32 <dzdncnfzd> chrisdotcode: well, I thought I just had to put the right stuff in the build-depends / extra-dependencies fields and everything would work -- this is the first time it's failed
21:00:37 <chrisdotcode> "Maps between pointed sets (X,x_{0}) and (Y,y_{0}) (called based maps,[5] pointed maps,[4] or point-preserving maps[6]) are functions from X to Y that map one basepoint to another, i.e. a map f:X\to Y such that f(x_{0})=y_{0}. This is usually denoted"
21:00:42 <chrisdotcode> so you might be thinking of those
21:00:43 <heatsink> ...map the distinguished point in the domain to the distinguished point in the range
21:00:55 <dzdncnfzd> christdotcode: it doesn't appear to be a mac error, rather it appears to be a problem with the code
21:00:56 <doktrin> (very, very newbie question) : how can I write a lazy bytestring to a file? calling writeString "someFile" myByteString returns an 'expected type' error
21:00:56 <chrisdotcode> "Pointed sets may be regarded as a rather simple algebraic structure. In the sense of universal algebra, they are structures with a single nullary operation which picks out the basepoint.[7]"
21:01:29 <kadoban> dzdncnfzd: Is this part of your own project you're trying to use that package? What's in your stack.yaml, what command are you running, and can you lpaste the error message you get?
21:01:36 <chrisdotcode> dzdncnfzd: https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html#v:writeFile
21:01:53 <chrisdotcode> dzdncnfzd: are you trying to build/install a stack package, or stack itself?
21:02:03 <chrisdotcode> oh, you said the package was download-0.3.2?
21:02:09 <dzdncnfzd> i'm trying to use the command stack build
21:02:10 <dzdncnfzd> yes
21:02:10 <chrisdotcode> whoops, sorry
21:02:11 <heatsink> chrisdotcode: so in conclusion, I don't know
21:02:18 <chrisdotcode> that link was for dolio
21:02:25 <chrisdotcode> oh, he left
21:02:31 <chrisdotcode> * doktrin
21:02:35 <chrisdotcode> sorry guys
21:04:13 <dzdncnfzd> kadoban: http://lpaste.net/148799
21:07:19 <kadoban> dzdncnfzd: I notice that 'download' isn't in stackage, which means it's not *terribly* surprising it fails to build, though that error message is naively kind of weird. It looks like the 'download' library hasn't been updated since 2011, which is a long time ago, it's very likely not being maintained and could just be broken?
21:08:11 <dzdncnfzd> kadoban: Ah, I see. If that's the case I should just find a different one
21:08:28 <dzdncnfzd> what library do people suggest for basic http requests?
21:09:13 <Clint> http-client
21:09:14 <Adeon> I haven't really made any kind of survey but I've been using http-client
21:09:36 <Adeon> and HsOpenSSL + http-client-openssl if I need tls
21:10:00 <Clint> (i use http-client-tls)
21:10:51 <wedens> I've noticed some strange thing with postgresql-simple. I write UTCTime 1864-06-01 20:25:46.319721 and I get back 1864-06-01 20:25:46.319720568659 
21:11:52 <kadoban> wedens: That doesn't seem terribly strange. I wouldn't expect the time on that to necessarily be infinite precision.
21:12:00 <andromeda-galaxy> is there any reasonable way to use $ at the type level?
21:12:11 <andromeda-galaxy> so that I can use TyFamily $ <long type> in a minimally invasive way
21:12:59 <wedens> kadoban: it makes writing test more complicated..
21:14:26 <kadoban> wedens: I would imagine it does.
21:16:06 <wedens> I guess, I'll abandon writing tests for DB and consider experiment failed :)
21:16:55 <kadoban> wedens: That shouldn't be so hard to write a test for that you just give up I wouldn't think? It's kind of the same thing you have to do with floating point, just don't test for *exact* equality, allow a small fudge factor.
21:18:21 <magbo> Greetings. Pure functions (or a subset \mathbb{F} of those) have the following property: \exists \phi : String \rightarrow F \exists \phi^{-1}. In other words, those functions can be labeled with some function \phi. It would be extremely handy if we could, when needed, easily serialize those — for f \in \mathbb{F} we write \phi^{-1}(f) and re-build the function on runtime with \phi(\phi^{-1}(f)).
21:19:03 <methods> I'm a total haskell newbie - could someone help me parse the documentation? specifically, how to interpret : writeFile :: FilePath -> ByteString -> IO ()
21:19:11 <methods> here is a gist describing what I"m currently doing (wrong) : https://gist.github.com/anonymous/428cdb9393c6b4b6ac0a
21:19:50 <wedens> kadoban: well, it's not the only reason to give up. and to do fuzzy equality test I'll need to use newtype everywhere 
21:21:01 <magbo> A TemplateHaskell solution based on, say, type families for each arity of pure functions wrapped in a data type per function sounds like an approach that could work, but I have a hunch that I'm reinventing the wheel.
21:23:08 <magbo> What is the most transparent way to serialize and deserialize pure functions (sic! I'm not talking about the approach CloudHaskell takes, I'm talking about re-building serialized functions using GHC runtime on every deserialization of stored data. Yes, that means that the programmer has to make sure that their functions suit the bijection requirement)
21:26:06 <heatsink> I don't know of an easy way to do that without runtime support
21:26:21 <wedens> how can I trim  picoseconds from UTCTime?
21:26:28 <wedens> set to 0
21:26:35 <heatsink> Is it not sufficient to send functions between processes?
21:27:29 <magbo> heatsink: you mean CloudHaskell closures?
21:27:46 <heatsink> I was thinking of Eden
21:28:46 <magbo> I have the following very down-to-the-ground problem: acid-state as storage, AAA system which incorporates monitoring which for different user raises different flags following different algorithms.
21:29:21 <magbo> Algorithms are entirely pure and can be, well, indexed.
21:29:46 <magbo> I want to store the currently attached algorithms in acid-state along with users.
21:31:23 <magbo> Obviously, with TH we can't find out "a name of a function", no such thing exists in general.
21:31:42 <ReinH> magbo: I don't believe that function serialization has really been done outside of cloud haskell.
21:32:10 <magbo> But it sounds so doable.
21:32:13 <magbo> Ok, thanks.
21:32:25 <heatsink> It's done with TH tricks as far as I understand
21:32:43 <ReinH> You have to tell cloud haskell that you want to serialize particular functions
21:33:17 <ReinH> magbo: the proposed `static' type construct would be helpful here
21:33:32 <ReinH> magbo: cloud haskell uses https://hackage.haskell.org/package/distributed-static-0.3.2.0/docs/Control-Distributed-Static.html fwiw
21:33:59 <ReinH> but to do this properly I think you really want compiler support, which ghc doesn't (yet?) have.
21:34:04 <heatsink> magbo: You can emulate it by representing the algorithms as purely data structures, and having an interpreter that "runs" them
21:34:14 <heatsink> then the data can be serialized
21:34:16 <magbo> heatsink: exactly
21:34:21 <pavonia> wedens: So you only want to keep it up to the nanoseconds?
21:34:27 <magbo> and then rip out the underlying function
21:34:38 <magbo> and shove it into the places which wants it.
21:34:39 <wedens> pavonia: up to seconds. or even minutes
21:35:05 <magbo> ReinH: thanks for the link :) <3
21:35:17 <ReinH> magbo: I think distributed-static is the closes to an existing wheel that you are likely to find
21:35:40 <ReinH> *closest
21:36:31 <liyang> wedens: if you're using "time", you can just use 'round'.
21:36:36 <koz_> I have the following set-up: http://paste.rel4tion.org/197 . Is there any way I can make the constructor for HornClause *always* be that function I wrote? The one generated by the type allows disorderly [a].
21:36:46 <pavonia> wedens: DiffTime is treted as second, so multply with a factor representing the desired precision, round, and divide by the same factor, I guess
21:36:50 <ReinH> koz_: use a smart constructor
21:36:52 <pavonia> *treated
21:37:26 <koz_> ReinH: How do I do that?
21:37:46 <heatsink> I think he wants makeHornClause to be a smart constructor
21:37:47 <ReinH> koz_: define your own function that constructs a HornClause value respecting that invariant
21:38:16 <ReinH> you can simply not export the HornClause data constructor
21:38:38 <koz_> heatsink has it right. How would I do the smart constructor thing, for future reference?
21:38:45 <ReinH> you have a smart constructor
21:38:50 <ReinH> just don't export the usual constructor
21:39:18 <koz_> Ah, right. So a 'smart constructor' is just a function that makes whatever type instance, and you just hide the default one?
21:39:37 <ReinH> yes
21:39:45 <koz_> OK, thanks!
21:44:42 <wedens> pavonia: will timeToTimeOfDay trim DiffTime to seconds?
21:46:08 <pavonia> wedens: Probably not, both have the same precision
21:48:51 <dzdncnfzd> Hey guys! How would you recommend I print UTF8 strings?
21:49:30 <athan> dzdncnfzd: How do you mean "print"? `String` handles utf8 natively :)
21:49:37 <juri_> with a printer. http://faikvm.com/20160102_184234.jpg
21:49:57 <athan> Also Data.Text.Encoding has {de,en}codeUtf8
21:49:58 <juri_> i recommend laser cut mode, but deposition of plastic would work, too.
21:50:02 <dzdncnfzd> :) I have a bytestring and I'm trying to print it. I know it holds encoded utf8 values
21:50:09 <juri_> :)
21:50:09 <lpsmith> wedens, you should read the new Time documentation.
21:50:15 <athan> dzdncnfzd: Ah! You should use text then!
21:50:36 <lpsmith> hmm, nevermind, I misread your comment
21:50:45 <lpsmith> that is very odd :-(
21:51:28 <lpsmith> wedens, that bug should be pretty well guarded against
21:52:27 <lpsmith> On the other hand,  writing 1864-06-01 20:25:46.319720568659   and getting back 1864-06-01 20:25:46.319721 would be expected
21:52:57 <dzdncnfzd> athan: thanks! I'm trying it now
21:53:43 <lpsmith> postgresql's timestamp types have microsecond resolution, at least if you are using integer_datetimes
21:54:20 <lpsmith> wedens, run "SHOW integer_datetimes" on your database.
21:55:00 <bitemyapp> lpsmith: hi stranger
21:55:41 <lpsmith> what's up, bitemyapp?
21:57:00 <wedens> lpsmith: result is 'on'
21:57:46 <lpsmith> well, that was my best guess.
21:58:51 <lpsmith> wedens, which version of postgresql-simple are you using?
21:59:01 <wedens> lpsmith: latest
21:59:08 <codedmart> Is there any way to use ghc 7.6 with stack?
22:00:32 <MarcelineVQ> probably not, the earliest LTS repo is for 7.8.3
22:05:31 <lpsmith> wedens, are you sure you aren't putting "1864-06-01 20:25:46.319720568659Z" in, and getting "1864-06-01 20:25:46.319721" out?
22:05:49 <lpsmith> I just tried that exact timestamp,  with the latest postgresql-simple,  and postgres 9.4
22:05:59 <lpsmith> it round-tripped ok.
22:08:34 <bitemyapp> lpsmith: working on da bewk.
22:09:07 <wedens> lpsmith: no, I'm not sure. let me check
22:09:50 <wedens> lpsmith: yes, you're right
22:11:04 <lpsmith> wedens,  by the way, the test suite is actually pretty good on this count,  see https://github.com/lpsmith/postgresql-simple/blob/master/test/Time.hs
22:18:42 <wedens> what's preferred approach to deal with UTCTime equality?
22:19:10 <wedens> use newtype everywhere?
22:19:29 <lpsmith> What do you mean? 
22:20:13 <wedens> lpsmith: I want 1864-06-01 20:25:46.319720568659 and 1864-06-01 20:25:46.319721 to be considered equal
22:20:53 <lpsmith> I would write a function to round,  then check of round x == round y
22:21:12 <lpsmith> I've written it before,  UTC has a public constructor
22:21:22 <lpsmith> let me see if I can find it quick
22:21:53 <wedens> yes, but I want to compare types with UTCTime with doing field by field check manually
22:22:01 <wedens> * without doing
22:22:24 <lpsmith> wedens, alternatively,  you could subtract the two and check if the difference is strictly less than 0.000001
22:22:41 <lpsmith> not quite the same test,  but approximately the same
22:22:59 <lpsmith> wedens, well then newtypes it is.
22:23:05 <wedens> so, if I have `data Post = Post UTCTime deriving Eq` I'd prefer to just `post1 == post2`
22:23:50 <lpsmith> wedens, by the way, on every system I've ever used,  getCurrentTime is limited in resolution to microseconds
22:24:21 <lpsmith> So if that's your timesource,  you'll never get something that contains a fraction of a microsecond
22:25:15 <lpsmith> Thus, you might want to consider if this is really necessary.  If it is,  newtypes would be an option.
22:25:46 <wedens> lpsmith: yes, I use getCurrentTime
22:29:39 <wedens> lpsmith: thanks for help
22:30:21 <lpsmith> wedens, you are welcome :)
23:03:03 <koz_> Suppose I have a module that declares a typeclass Foo with one function bar. How would I write the module statement for that module such that everyone else who imported it could use the typeclass and the method it provides for whatever instances?
23:04:53 <srhb> koz_: module Module (Foo(bar)) where ... ?
23:05:27 <shachaf> i,i module Module (MODULE) where ...
23:05:40 <srhb> shachaf: Yes, that's better. :-)
23:06:13 <koz_> srhb: Ah, so typeclasses are like types in this regard.
23:06:37 <srhb> koz_: I suppose. Export lists are very homogenous in that way.
23:06:56 <Cale> koz_: Or more commonly, you'd just write Foo(..)
23:07:00 <Cale> which exports all the methods
23:08:01 <koz_> Cale: I have to hide like, one thing.
23:08:15 <Cale> ah
23:10:52 <bitemyapp> New release of haskellbook.com up by the way. Includes parser combinators, composing types, and monad transformers. It's up to 1156 pages & 26 chapters now.
23:11:26 <Skuzzzy> Immutable data structures = :( memory
23:15:30 <jle`> bitemyapp: congrats! :D :D
23:15:38 <bitemyapp> jle`: thank you :)
23:15:42 <jle`> Skuzzzy: not necessarily :O they can actually improve memory :O
23:15:56 <jle`> *improve memory usage
23:16:28 <jle`> bitemyapp: where is the afterparty?
23:17:53 <bitemyapp> jle`: actually Julie and I were discussing how to celebrate this release. This was a biggie.
23:18:13 <jle`> sounds like it
23:18:55 <bitemyapp> I am very tired
23:29:32 <umayahabdennabi> can anyone explain this error to me
23:29:32 <umayahabdennabi>  Couldn't match expected type ‘Snap User’
23:29:33 <umayahabdennabi>             with actual type ‘IO User’
23:31:02 <umayahabdennabi> in the context of userInfo <- “something that returns IO User”
23:31:04 <pavonia> You probably uses an ordinary IO action in a Snap monad context
23:31:27 <liste> :t liftIO -- you'll probably need this, umayahabdennabi
23:31:27 <pavonia> try liftIO
23:31:28 <lambdabot> MonadIO m => IO a -> m a
23:32:44 <umayahabdennabi> so there is a context with “<-“ 
23:33:27 <umayahabdennabi> i always assumed it just took some “m a” and gave back a
23:33:52 <liste> <- is just syntactic sugar for >>= (in a do block)
23:34:07 <liste> @undo do {a <- f; return a}
23:34:07 <lambdabot> f >>= \ a -> return a
23:34:33 <liste> but in this case, I think "context" just means "the relevant line of code"
23:34:35 <pavonia> The "m" has to match the surrounding "m"s which seems to be Snap in this do-block, but IO /= Snap
23:35:03 <umayahabdennabi> i see, thx
