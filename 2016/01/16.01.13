00:00:38 <shachaf> Yes, you can use the sorts of tricks in the PDF you linked to to represent it in better than just asymptotically linear space.
00:00:49 <shachaf> Anyway I'm not doing much good here.
00:00:57 <ReinH> well, there are other tricks too
00:01:30 <ReinH> but the ones in the pdf are probably pretty relevant
00:06:08 <ReinH> quchen: (the semi-index of lines would be in very small non-constant space ;) )
00:07:38 * hackagebot http2 1.4.1 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.4.1 (KazuYamamoto)
00:07:38 * hackagebot wai-logger 2.2.5 - A logging system for WAI  https://hackage.haskell.org/package/wai-logger-2.2.5 (KazuYamamoto)
00:08:05 <quchen> ReinH: Interesting paper.
00:09:44 <ReinH> quchen: it very much is :)
00:10:45 <hexagoxel> nut_: `cabal run -- -q query`
00:12:44 <ReinH> quchen: we might end up using some of this tech in the database.
00:13:08 <quchen> We? The database?
00:13:36 <ReinH> quchen: a friend and I are writing a database in haskell for a client. Well, mostly he is and I am providing moral support.
00:13:54 <quchen> Interesting.
00:17:31 <ReinH> quchen: I agree :)
00:21:06 <quchen> ReinH: So you're a freelancing Haskell consultant?
00:21:20 <ReinH> quchen: as a side gig, yeah
00:32:26 <nut_> hexagoxel, thanks
00:35:36 <ianhedoesit> ReinH: as someone who seems to be a pretty reasonably "successful" Haskell programmer, do you mind me asking what you think about Idris?
00:37:13 <absence> Either String () is isomorphic to Maybe String for representing "computations" that can fail with an error message, but otherwise don't return anything (e.g. constraints), but is it sensible to reverse Maybe that way? i guess none of the standard typeclass instances make sense if Nothing is success, or is there something buried in a library?
00:38:36 <Clint> absence: Data.EitherR
00:40:27 <absence> Clint: thanks, but i'm asking about reverse maybe, not reverse either :)
00:41:31 <absence> Clint: the normal either would do, i don't need the reverse one. just seems a bit weird to use either at all when one side is ()
00:44:50 <liste> absence so you mean that return would be const Nothing ?
00:46:42 <absence> liste: what do you mean by return? the monad function? i'm not asking about monads
00:47:25 <ReinH> ianhedoesit: I think it's really cool but I don't know what I would do with it tbh.
00:48:21 <jle`> i think the idea is that you just do whatever you'd do in haskell with it, but with extra type safety :O
00:48:39 <jle`> and the ability to throw in program verifications here and there if you feel like it
00:51:11 <liste> absence what standard typeclass instances do you mean?
00:51:53 <ianhedoesit> ReinH: hm. Is that because it's not production ready?
00:52:04 <absence> > Nothing <|> Nothing <|> Just "error"
00:52:06 <lambdabot>  Just "error"
00:52:25 <absence> liste: nm, i figured it out :)
00:52:51 <kadoban> absence: I don't think I have any objection to Either e () . It does immediately look a bit weird, but it makes sense.
00:52:59 <ianhedoesit> I'm watching a video (https://youtu.be/vkIlW797JN8) and it's kind of fascinating. I don't know enough to justify trying to use it I don't think, but it's something that is immediately jumping out as "wow, that's neat," which I think is neat.
00:54:32 <absence> kadoban: it makes sense, it's just a bit noisy to have to throw those () everywhere
00:54:42 <wedens>  how can I use ghci with some static C library? I use stack and Custom cabal build to specify path to .a and includes
00:56:24 <kadoban> wedens: It builds with stack? 'stack ghci' ?
00:56:41 <wedens> kadoban: yes, stack ghci
00:56:53 <kadoban> wedens: No, that was my answer.
00:57:47 <jle`> absence: if you have `Either e ()` that's basically the Monoid instance for `Maybe e`
00:58:03 <jle`> oh wait
00:58:10 <absence> jle`: no, it's the Alternative :)
00:58:18 <wedens> kadoban: it fails with `stack ghci`
00:58:24 <jle`> the instance for Last (Maybe e), heh
00:58:33 <kadoban> wedens: But it builds otherwise?
00:58:55 <absence> jle`: wouldn't it be First?
00:58:59 <jle`> if you're using `Either e ()` and always fixing all of the constraints, then you don't reaaaaly want the * -> * typeclasses
00:59:09 <jle`> absence: yeah, sorry :)
00:59:32 <jle`> the fact that the * -> * typeclass Alternative works for you here is a coincidence; Alternative and Monoid could have been implemented differently, heh
00:59:59 <jle`> but my point was that it wouldn't make too much sense to use it as a Monad because the result is always fixed
01:00:14 <jle`> or as an Applicative
01:00:25 <jle`> what you actually want is "a" monoid
01:00:27 <wedens> kadoban: yes
01:00:34 <jle`> it just happens to not be the Monoid instance Maybe has by default :)
01:00:41 <wedens> kadoban: problem is specific to ghci
01:00:56 <kadoban> wedens: Well, what's the error?
01:02:12 <absence> jle`: i don't quite see what's wrong with Alternative?
01:02:54 <absence> jle`: oh now i do. Applicative is base class
01:03:50 <jle`> yeah, the spirit of Alternative is related to Applicative...but here you're using Alternative but with useless Applicative/Functor; so it's not bad or wrong, i guess i was just rambling heh
01:04:58 <absence> well, it's just as "bad" as using the Either i'm trying to avoid in the first place :)
01:05:42 <wedens> kadoban: <command line>: user specified .o/.so/.DLL could not be loaded
01:06:11 <mgsloan> wedens: Yeah, it's an unfortunate issue https://github.com/commercialhaskell/stack/issues/970
01:06:13 <kadoban> wedens: What command are you running?
01:06:20 <kadoban> Oh
01:06:59 <wedens> kadoban: stack ghci
01:09:06 <mgsloan> In other words, the issue is that "stack ghci" doesn't use the info generated by the custom Setup.hs
01:09:25 <wedens> mgsloan: so, putting .so near .a won't help? :(
01:11:54 <wedens> mgsloan: is there some workaround? I've tried to set extra- parameters in stack.yaml with absolute path, no success
01:12:27 <mgsloan> Via ghc-options? That should work
01:13:23 <wedens> mgsloan: no, extra-include-dirs/extra-lib-dirs 
01:14:13 <mgsloan> Ah, yeah, not sure if that's taken into account for ghci
01:15:01 <wedens> mgsloan: can I set something in `stack ghci --ghci-options` ?
01:16:59 <mgsloan> wedens: Yeah, you can pass in "-Ldir" for extra-lib-dirs and "-Idir" for extra-include-dirs
01:22:06 <wedens> mgsloan: ghc: panic! (the 'impossible' happened) Loading archives not supported
01:23:23 * hackagebot wai-middleware-crowd 0.1.4 - Middleware and utilities for using Atlassian Crowd authentication  https://hackage.haskell.org/package/wai-middleware-crowd-0.1.4 (MichaelSnoyman)
01:27:46 <wedens> mgsloan: is it possible at all to use static libraries in ghci?
01:28:05 <jgoux> Hi
01:28:20 <jgoux> What are the steps to install a package from hackage (not on stackage) with stack ?
01:33:00 <wedens> jgoux: extra-deps in stack.yaml
01:40:43 <jgoux> wedens: ok, thank you !
01:49:43 <ggVGc> I'm using a library that has it's own parser monad, and it supplies this function. How can I make an infinite unbounded version of it? https://gist.github.com/ba6f2044045c43bae9af
01:51:50 <merijn> ggVGc: I don't see how making a bounded, finite parser into an infinite unbounded parser makes sense?
01:52:21 <merijn> If you're trying to repeatedly parse something use some/many? (Assuming ParserM has an Alternative instance)
01:53:01 <ggVGc> merijn: yeah, I realised it can't be done. The whole parser monad is strict
01:53:12 <ggVGc> and I need to process a continuous stream of data
01:53:20 <ggVGc> I guess I'll just use Binary.Get
01:53:24 * hackagebot hsdev 0.1.5.2 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.5.2 (AlexandrRuchkin)
01:59:16 <zcourts> In the 2010 report decl -> gendecl | (funlhs | pat) rhs. I can see that `funlhs rhs` an equation for a function but I don't get what `pat rhs` would be for. I've misunderstood something because it implies to me that you could have something like `MyType param1 param2 = blah` at the top level of a module.
02:01:16 <merijn> zcourts: You can! :)
02:02:00 <zcourts> oh? So that's a function? What'd be the name in that case?
02:02:03 <merijn> zcourts: "[foo, bar] = [1,2]" is a totally legal top level declaration
02:02:41 <merijn> zcourts: It's not a function, but it *is* a declaration
02:02:48 <merijn> zcourts: Like declaring "foo = 1"
02:03:04 <absence> i'm trying to tag error messages on failing bool tests. can this be written in a better way? http://lpaste.net/148912
02:05:08 <merijn> absence: map unless  and sequence?
02:05:31 <merijn> :t \b -> unless b (Left "My error")
02:05:35 <lambdabot> Bool -> Either [Char] ()
02:05:44 <merijn> > unless True (Left "My error")
02:05:45 <lambdabot>  Right ()
02:05:50 <merijn> > unless False (Left "My error")
02:05:52 <lambdabot>  Left "My error"
02:06:16 <zcourts> merijn: I see, how would I go about using something like `[foo, bar] = [1,2]` later on, I mean how does that evaluate? That's probably what I'm missing
02:06:54 <absence> :t unless
02:06:55 <lambdabot> Applicative f => Bool -> f () -> f ()
02:07:25 <absence> merijn: why does that work with the ()?
02:08:08 <merijn> zcourts: It's semantically equivalent (but not operationally) to "foo = case [1,2] of [x, _] -> x; bar = case [1,2] of [_, y] -> y", i.e. it just pattern matches "[foo, bar]" with [1,2] and either succeeds or throws an error
02:08:24 <merijn> zcourts: Which means that "foo" and "bar" are now in scope in the entire module
02:08:36 <absence> merijn: never mind, it's the Right () of course
02:08:51 <merijn> absence: Yeah, because of the Applicative of Either :)
02:09:02 <merijn> absence: The last type argument always matches the Right constructor :)
02:09:04 <zcourts> ohhhhhhh
02:09:15 <zcourts> I get it, thanks merijn
02:09:26 <merijn> zcourts: Try this in a file: "foo, bar :: Int; [foo, bar] = [1,2]"
02:09:46 <merijn> (You can provide type signatures for multiple declarations in one go too!)
02:10:06 <merijn> absence: So it's just returning "pure ()" which just happens to be "Right ()" :)
02:10:31 <zcourts> That's really neat
02:11:07 <fr33domlover> Hello! Q: I want a `bracket` generalized to RWST-on-top-of-IO. I found two such brackets: one from lifted-base and one from exceptions. Which one should I prefer? In my little understanding it seems to me that lifted-base peels the monad every time while 'exceptions' simply has a direct implementation so i should prefer the latter?
02:11:15 <merijn> absence: So, suppose the list of conditions is very long I'd make a list [(Bool, String)] where Bool is the condition and String the error and then "map (\(b, err) -> unless b (Left err)) conds"
02:11:48 <merijn> absence: And then you can use either "lefts" to obtain all failures, or you use mapM/sequence to collapse all failures
02:12:06 <merijn> fr33domlover: Personally I prefer exceptions
02:12:10 <absence> merijn: like this then? http://lpaste.net/148912
02:13:04 <fr33domlover> merijn, i've been using exceptions too but now i found lifted-base so i'm curious :P
02:13:08 <merijn> absence: Oh, I didn't notice you had a tree of conditions. Might make a tree instead then and then define a recursion over that instead. It really depends on the number of conditions
02:13:39 <absence> merijn: it's the combination of || and && that's causing me problems actually. if it was just && i'd have no problem :)
02:14:22 <absence> merijn: right, so the structure i have is the "correct/optimal" one?
02:15:07 <merijn> absence: "data Cond e = Val Bool e | And [Cond e] | Or [Cond e]" I'm guessing you can think how to implement && only and || only
02:16:02 <merijn> "collapse (Val b e) = unless b (Left e); collapse (And l) = mapM_ collapse l; collapse (Or l) = {- too lazy to think about it now -}"
02:16:53 <merijn> Or [Val p1 "p1 failed", And [Val p2 "p2 failed", Val p3 "p3 failed"]]
02:17:01 <absence> merijn: could that thing be a monad?
02:17:17 <merijn> absence: I'm not sure :)
02:17:27 <merijn> I wanna say yes
02:17:33 <merijn> But I'd have to think about it...
02:17:46 <ggVGc> when writing a parser with Binary.Get, how can I carry state while parsing?
02:18:11 <merijn> ggVGc: "StateT s Get"? :)
02:18:31 <absence> merijn: i'll do just that. thanks :)
02:18:33 <merijn> ggVGc: It's a Monad, after all :)
02:21:54 <merijn> Crap
02:22:12 <merijn> Why does the Applicative for StateT have a Monad constraint? Shouldn't an Applicative constraint be sufficient?
02:23:33 <jle`> merijn: i've tried writing one without Monad
02:23:35 <jle`> but i've struggled
02:23:45 <jle`> @let [foo,bar] = [1,2]
02:23:46 <lambdabot>  .L.hs:165:1:
02:23:47 <lambdabot>      Multiple declarations of â€˜barâ€™
02:23:47 <lambdabot>      Declared at: .L.hs:162:7
02:23:50 <jle`> :|
02:23:55 <jle`> @let [test1,test2] = [1,2]
02:23:57 <lambdabot>  Defined.
02:24:02 <jle`> > test1    -- zcourts 
02:24:03 <lambdabot>  1
02:24:24 <jle`> merijn: i'm not even sure if it's possible
02:24:32 <merijn> jle`: hmm, I suppose I could rewrite my code to use StateT over ReaderT since I don't strictly need State, I suppose
02:24:58 <jle`> for example, how would you expect `StateT s (Const c) a` to be able to to bind anything?
02:25:09 <merijn> I just want to use Concurrently as a base to traverse
02:25:12 <jle`> how would it get the "next state"?
02:25:43 <merijn> Because Because mapConcurrently only accepting IO is limiting :\
02:25:51 <jle`> that is, an `s -> Const c (a, s)`
02:26:06 <jle`> even if you give that an `s`, you won't get an `s` out of it
02:26:09 <jle`> you'll just get a c
02:26:24 <jle`> hm
02:26:31 <jle`> where was i going with this
02:26:54 <jle`> yeah, that's what i meant.
02:27:05 <jle`> you can't (*>) together two (s -> Const c (a, s))'s
02:27:27 <jle`> because the second one is going to expect another 's' (other than the original one), but you can't get it
02:28:39 <merijn> Which is all irrelevant to my actual problem of wanting a lifted mapConcurrently :p
02:28:55 <jle`> absence: try using Maybe and guard
02:29:16 <jle`> || becomes  <|>, and && becomes (*>)
02:30:58 <jle`> this sort of makes sense w.r.t. the previous suggestion of using lists
02:31:32 <jle`> because sequence_ [x,y,z] is just x *> y *> z    (modulo return value)
02:31:45 <jle`> and asum [x,y,z] = x <|> y <|> z
02:31:55 <jle`> so i think you can just straight up replace ||'s with <|> and &&'s with *>'s
02:33:01 <jle`> (the default behavior of *> will get you the 'last' error, not the first one, though)
02:33:24 <jle`> (if you are using Maybe Error as your error type)
02:33:38 <jle`> hm, did i mix something up in my head.  i should just go to sleep v.v
02:43:02 <tharper> are there any mature computational fluid dynamics libraries for haskell?
02:48:27 * hackagebot java-poker 0.1.2.0 - The etude of the Haskell programming  https://hackage.haskell.org/package/java-poker-0.1.2.0 (tobynet)
02:53:27 * hackagebot IntervalMap 0.5.0.0 - Containers for intervals, with efficient search.  https://hackage.haskell.org/package/IntervalMap-0.5.0.0 (ChristophBreitkopf)
02:55:23 <danza> tharper, i don't think so... that is the kind of applications you would implement on top of an efficient scientific computational library, right?
02:56:02 <tharper> danza: likely, yes, although I'm no expert at the maths behind it, I was just curiosu for a colleague who uses a rather awkward C framework atm
02:56:12 <danza> :)
02:56:48 <danza> already finding the suitable scientific library for the task, something similar to Scipy or Matlab, is kind of hard in Haskell
02:57:17 <danza> in the sense that i believe that there isn't a single reference used by the whole community
02:57:42 <danza> there are several libs, the scenario is a bit fragmented
02:58:00 <danza> for fluid simulations, maybe a good start would be Repa, here a demo https://www.youtube.com/watch?v=HKdCnv8rDXg
02:58:11 <danza> and this is the lib https://github.com/DDCSF/repa
03:03:40 <tharper> danza: cheers danza, yeah ben lippmeier's bachelors thesis was teh first hit for CFD and it was using repa
03:03:42 <tharper> I should ask him :)
03:04:09 <danza> cool
03:18:07 <rodlogic> How difficult would it be to read haskell Binary files from Java? Was that done before? Or is there a low level description of the Binary format?
03:18:29 <statusfailed> rodlogic: you mean a compiled haskell binary?
03:18:42 <mauke`> the module Binary, probably
03:18:47 <statusfailed> ooh XD
03:18:59 <rodlogic> statusfailed: sorry, yes, a file serialized with the Binary module
03:20:20 <liste> rodlogic the Get/Put instances already define the format
03:21:16 <liste> so you can e.g. write two bytes with Java and read them in Haskell using <,> <$> getWord8 <*> getWord8
03:21:36 <liste> s/<,>/(,)/
03:22:46 <rodlogic> liste: I am wondering if there is a way to auto generate a spec/description (or even java source) to parse a large data structure serialized with deriving Binary
03:24:58 <rodlogic> liste: instead of doing a manual, one-off translation
03:27:42 <liste> the standard Binary instances are here, maybe you could use GHC Generics and the language-java package to whip up a Java source generator to do something like that: https://hackage.haskell.org/package/binary-0.7.6.1/docs/src/Data-Binary-Class.html#gput
04:02:47 <merijn> I wonder why System.Process doesn't have a withProcess bracket...
04:03:53 <hansihe> using parsec, is there any easy way to see if sepEndBy was ended with sep or not?
04:15:23 <wlad> Hi guys, can someone consult me on one thing? Say I have a function "f" which takes b c a and I have an array of a's. What would be an idiomatic way to iterate to map through said array invoking f but supplying new b c each successive call?
04:16:25 <liste> wlad so f :: b -> c -> a -> foo ?
04:16:36 <mauke`> where do you new b's/c's come from?
04:16:40 <mauke`> *your new
04:16:51 <wlad> f::b->c->a->(b,c) yeah
04:17:02 <mauke`> oh, a fold
04:17:12 <wlad> fold would do?
04:17:24 <mauke`> foldl or foldr
04:17:37 <wlad> mauke` Thanks, I'll give it a shot
04:19:58 <wolfcub> so a function of type f: A -> A is called an endofunction
04:20:27 <merijn> :t curry (undefined :: b -> c -> a -> (b,c))
04:20:29 <lambdabot> a -> b -> c -> a1 -> ((a, b), c)
04:20:38 <wolfcub> is there a special name for those of type f: A x A -> A, or f: A x A x A -> A
04:20:42 <wolfcub> etc
04:20:43 <merijn> hmmm, wrong one, always get them mixed up
04:20:47 <merijn> :t uncurry (undefined :: b -> c -> a -> (b,c))
04:20:49 <lambdabot> (b, c) -> a -> (b, c)
04:24:38 <absence> why is there no "stack run" :/
04:30:04 <frerich> absence: What would that do? Maybe you mean 'stack exec'?
04:30:07 <fr33domlover> absence, you mean "stack exec"?
04:30:53 <obadz> would have been nice to keep the verb the same as cabal there..
04:31:14 <frerich> I always used 'cabal exec', too.
04:31:33 <fr33domlover> personally i prefer 'run'
04:31:40 <fr33domlover> simpler concept than 'execute'
04:31:45 <absence> frerich, fr33domlover: no i don't mean stack exec. i mean something similar to "cabal run"
04:32:06 <obadz> frerich: cabal exec: Give a command access to the sandbox package repository
04:32:15 <obadz> frerich: cabal run: Builds and runs an executable.
04:32:16 <ggVGc> what's wrong here? Why am I not getting anything printed? https://gist.github.com/3dd8d4d5c9e97d9a8321
04:32:16 <tdammers> "run" is also easier to type
04:32:30 <frerich> I see, I never even knew about 'cabal run'.
04:32:43 <frerich> Or rather, never made it part of my muscle memory.
04:33:20 <frerich> obadz: Ok, so 'stack exec' matches 'cabal exec'.
04:33:45 <fr33domlover> maybe there is no stack run because stack doesn't use sandboxes
04:33:50 <liste> ggVGc you never stop parsing
04:34:02 <frerich> What does 'cabal run' execute when you build multiple excecutables?
04:34:18 <fr33domlover> frerich, you can tell it what to execute
04:34:22 <liste> though I'm not sure if it's the problem
04:34:34 <ggVGc> liste: how do I write this? I am trying to parse a continuous binary stream into a lazy list of output objects
04:35:57 <merijn> ggVGc: Sounds like you want stream processing
04:36:04 <merijn> ggVGc: My recommendation: pipes/conduit
04:36:37 <anohigisavay> hi
04:36:38 <ggVGc> ah, okay, thanks
04:36:44 <merijn> ggVGc: Parse one element at a time and feed leftovers after each element to the next
04:36:57 <anohigisavay> is comments not usually part of AST structure?
04:37:17 <ggVGc> anohigisavay: an AST can not contain comments no. then it's not an AST
04:37:19 <ggVGc> afaik
04:38:07 <ggVGc> anohigisavay: if you have everything preserved, such as comments, it's no longer an abstract syntax tree. then it's a full syntax tree iirc
04:38:31 <merijn> ggVGc: So you define "parseElement :: Text -> a" and then use e.g. pipes to turn that into a "Pipe Text a m r" i.e. a pipe that consumes Text and produces a's. Then you use, say, "fromHandle :: Handle -> Producer Text m r" which streams Text from a handle to you pipe in constant space and every time it finishes one element it emits it and proceeds with the rest
04:39:02 <ggVGc> merijn: yeah that does seem like what I want
04:39:06 <ggVGc> thanks
04:39:20 <ggVGc> although, I thought this would be possible with haskells normal laziness and BInary.Get. guess not
04:39:45 <anohigisavay> ggVGc: i'm looking at language-python project. it parses python code into AST, leaving comments and line numbers in a separate data structure. i might need to traverse the AST and add custom nodes. how to keep the comments in the generated code?
04:39:49 <ggVGc> I still have no grasp whatsoever on dealing with the laziness of haskell correctl
04:40:29 <ggVGc> anohigisavay: sorry, I'm no expert on this. I am very beginner level in haskell myself
04:40:34 <liste> ggVGc it's possible, but lazy I/O can get hairy
04:40:41 <ggVGc> I'm struggling to parse a binary stream..
04:40:53 <anohigisavay> ggVGc: sure me too. thanks anyway :D
04:40:57 <liste> the problem could be that you never flush the output stream
04:41:46 <liste> and with lazy I/O, it's hard to interleave flushes with output
04:41:54 <merijn> ggVGc: Laziness and lazy IO are two different things, lazy IO is generally considered a bad thing anyway
04:43:50 <aweinstock> anohigisavay: if each AST node keeps track of span information (what lines/columns in the source correspond to the AST constructs) then you can probably match them up after-the-fact
04:44:50 <ggVGc> to be pedantic, what you guys are talking about is a CST
04:44:54 <ggVGc> concrete syntax tree
04:44:59 <ggVGc> http://eli.thegreenplace.net/2009/02/16/abstract-vs-concrete-syntax-trees
04:45:13 <ggVGc> i.e a mapping of the full source into a tree structure
04:45:44 <ggVGc> an AST is a tree structure that contains only the necessary information for generating output code
04:46:49 <frerich> I don't think I ever heard anybody using the term 'concrete syntax tree'. 'Parse tree' is familiar to me though.
04:46:56 <ggVGc> when you have an AST, you are already far away from the original source, since any superficial transformations are gone, and comments/line numbers etc. are also not there
04:47:02 <ggVGc> frerich: yeah same thing
04:48:25 <ggVGc> anyway, an AST usually doesn't, and shouldn't, map well to the original source input. And two different source inputs that express the same semantics should have essentially the same AST
04:48:31 <ggVGc> anyway, that's my understanding of it
04:53:55 <aweinstock> ggVGc: pedanticness on my part: if preserving comments is part of the requirements, then wouldn't line info and comments constitute "necessary information for generating output code"?
04:57:21 <Ygg> http://lpaste.net/5259399307508842496
04:57:54 <Ygg> why do I get an error if I run testFunc 5 in the ghci ?
04:58:00 <Ygg> or any number really
04:58:24 <Ygg> "Non type-variable argument in the constraint : Num (Maybe a)
04:58:26 <Ygg> "
04:58:30 <opqdonut> Ygg: 5 is not a Maybe
04:58:40 <Ygg> ah fug
04:58:47 <opqdonut> Ygg: try "testFunc (Just 5)"
04:58:58 <Ygg> yep, it works
04:58:58 <Ygg> thanks
04:59:15 <ggVGc> aweinstock: perhaps, also I don't know what the formal definition actually is, if any. Either way, for communication I think calling it an AST and expecting preserved comments will lead to confusion. I.e when searching online etc.
04:59:31 <ggVGc> however searching for Concrete syntax tree or Parse tree will give good results
05:00:13 <opqdonut> hmm, my view is that a CST corresponds to the grammar 1:1, whereas an AST has a nicer structure
05:00:21 <opqdonut> comments are a secondary issue
05:00:50 <tdammers> depends on the language and how it defines comments
05:00:55 <ggole_> Fun fact: there are languages in which line positions matter for semantics, and ASTs/IRs for those language must preserve line positions
05:01:08 <tdammers> in XML, comments are somewhat semantic, and not necessarily supposed to be discarded when parsing
05:01:22 <ggole_> (I'm thinking of Ruby in particular.)
05:01:35 <anohigisavay> ggVGc: for most programming languages comments can appear anywhere, even splitting tokens. for some, say XML, they have to follow rules to ensure they not intersect nodes. in that sense, it is essentially part of the grammar
05:01:45 <tdammers> Ruby just has syntax-relevant line breaks, but that doesn't mean you need to preserve line *numbers*
05:02:19 <ggole_> You need to preserve some line information in order to implement a Ruby feature
05:02:24 <ggole_> (I forget exactly which one.)
05:02:28 <tdammers> hmm
05:02:32 <ggVGc> anohigisavay: it's not about being part of the grammar or not though. It's about that an AST is the abstract representation for what you want to do with it, and on a higher level than individual tokens
05:02:48 <tdammers> I thought you only needed to treat line breaks as "not whitespace"
05:03:10 <ggole_> I remember this because I watched a presentation on JRuby's IR, which not only supported this information but even had minor optimizations for it 
05:03:41 <ggVGc> anohigisavay: so while a CST might have Expression([Ident, Plus, Ident]), an AST will just have PlusOp(a,b)
05:03:47 <tdammers> hmm, well... with the extreme amounts to which Ruby is dynamic, keeping line numbers around is probably required anyway
05:04:32 <aweinstock> __LINE__ ?
05:04:48 <ggole_> Not __LINE__, it's some debugging thing
05:08:43 <absence> is Free [] ~ []?
05:09:59 <liste> iirc, Free [] Ìƒ~ Tree
05:10:02 <liste> let's check that
05:10:34 <liste> Free [] a = Pure a |Â Free [Free []Â a]
05:10:53 <liste> (by substituting f ~ [] in Free's definition)
05:12:01 <absence> liste: ah, that makes sense
05:12:50 <absence> liste: thanks!
05:12:56 <liste> absence yw (:
05:18:19 <phaazon> hello
05:24:21 <elfeck> hey can someone tell me how I can do this correctly: sortedFiles <- sortOn getModificationTime pathList
05:24:44 <elfeck> I tried lifting sortOn but its not working
05:26:35 <puregreen> are Travis builds failing for anyone else?
05:26:44 <puregreen> (specifically the ones using hvr's repo)
05:30:52 <piezoid> elfeck: you need something like sortedFiles <- fst . sortOn snd <$> traverse (\f -> (,) f <$> getModificationTime f)) pathList
05:31:07 <puregreen> nevermind, works for me now
05:31:38 <phaazon> g
05:33:01 <elfeck> piezoid: that looks super complicated. I solved it now with that: let sortedFls = map fst (sortOn snd (zip fls modDates)) af ter getting the modDates beforehand
05:34:05 <elfeck> piezoid: but thanks anyway!
05:39:38 <TseiTsei> Hi!  I made an object stacking game in Python.  Now I should port it to Haskell.  Any ideas where to start?  http://www.sis.uta.fi/~jk66180/ObjectStackEnglish/
05:40:17 <tdammers> "port to {language X}" isn't really a thing I'd say; more like "rewrite in {language X}"
05:40:33 <TseiTsei> Ok.
05:40:44 <tdammers> anyway, first thing would be to learn Haskell if you haven't already
05:40:56 <TseiTsei> I know basics of Haskell.
05:41:38 <TseiTsei> Lists are nice in Haskell.  I can use those in rewriting my game.
05:41:42 <tdammers> and then you'd have two main tasks: one, figuring out how to express a solution idiomatically in Haskell, and two, finding suitable libraries for all the stuff you don't want to implement youself
05:42:44 <tdammers> the biggest differences between the Python and the Haskell solutions are probably going to be how they model state changes, and how Python would leverage dynamic features while Haskell would use the type system to its advantage
05:42:48 <phaazon> win 6
05:43:00 <phaazon> oops sorry
06:08:59 <jgoux> using stack, do I still have to edit manually the .cabal file ?
06:09:13 <tdammers> jgoux: yes, but not a lot
06:09:55 <tdammers> stack creates a default one for you based on the template you select when creating the project, but after that, it won't touch it for you
06:10:23 <jgoux> tdammers: ok, thanks :)
06:10:26 <tdammers> but unless you do things like add targets or change the overall setup, the only thing you'll typically do is add modules and dependencies to the relevant lists
06:10:44 <jgoux> tdammers: yes this is my exact case
06:10:50 <jgoux> adding dependencies
06:11:20 <jgoux> coming from node.js, I was able to append them automatically to the package manager file using the command-line
06:11:34 <absence> is there an algebraic structure similar to ring, but without any identities, i.e. just the operators?
06:11:39 <jgoux> like `npm install my-dependency --save`
06:11:54 <tdammers> idk, could be that there's a tool that does that for you, but the normal procedure is to add the dependency to the build-depends field
06:12:32 <tdammers> something like install --save wouldn't work anyway, because every target has its own list of dependencies, so which one would you append to?
06:13:06 <tdammers> and how would you go about version constraints?
06:13:25 <tdammers> (I'm not even sure what npm does about these, actually)
06:13:38 <aweinstock> absence: https://en.wikipedia.org/wiki/Rng_%28algebra%29
06:14:14 <jgoux> tdammers: I could easily imagine a `stack install your-dependency@version --save=target`
06:14:38 <MarcelineVQ> you have to add your own build-depends to your .cabal file. Related though, you can use stack to add the extra-deps for you if it needs to pull things from hackage, using `stack solver --modify-stack-yaml`
06:14:58 <tdammers> well, yeah, except that with stack, you don't normally install anything directly, you just add the dependency and *then* do a build, which will install packages as needed
06:15:37 <jgoux> tdammers: Yes sure, it was more about not touching the .cabal file manually, but have command-line shortcuts to do it :)
06:15:58 <tdammers> yeah, I guess it's not high enough on anyone's priority list
06:16:17 <tdammers> editing the .cabal gives you the full power already, and it's not a lot less convenient than a command-line thing
06:17:54 <jgoux> tdammers: Indeed it's not a big deal at all ^^
06:18:45 <jgoux> tdammers: I just wanted to point that I like these convenient shorcuts based on my previous experiences with package managers
06:19:03 <tdammers> well, cabal isn't a package manager
06:19:04 <jgoux> And I didn't even know what it was before stack :D
06:19:14 <tdammers> stack isn't a package manager either
06:20:04 <tdammers> they're build automation tools, and the tragedy is that in order to be that, they have to download and install packages and resolve dependencies, which makes them very very similar to package managers, and people start using them as such
06:20:39 <jgoux> tdammers: oh ok, wasn't aware of this
06:21:24 <absence> aweinstock: doesn't rng have an additive identity?
06:23:11 <`Guest00000> does the monomorphism restriction affect where-clauses?
06:23:23 <opqdonut> no
06:23:59 <aweinstock> absence: looks like it
06:24:40 <aweinstock> absence: https://en.wikipedia.org/wiki/Magma_%28algebra%29 the only law is that it's closed
06:24:57 <aweinstock> absence: so you could say "(S, +) and (S, *) are magmas"
06:41:59 <RaceCondition> is there any way to make GHCi truncate values like 40.90000000000001 to 40.9? 
06:42:24 <mauke`> why are you speaking in decimals
06:42:39 <mauke`> what type is this?
06:43:00 <opqdonut> RaceCondition: see http://stackoverflow.com/questions/1559590/haskell-force-floats-to-have-two-decimals
06:43:22 <jgoux> Does anyone ever use hdbc-odbc package ?
06:43:27 <RaceCondition> yeah, but I mean can I make GHCi just do it automatically when printing the results of computations?
06:43:35 <jgoux> or any package to be able to connect to a Oracle database ?
06:44:00 <RaceCondition> I have all sorts of data structures with doubles in them, and the output is extremely noisy thanks to values like 40.90000000000001
06:44:07 <mauke`> get better values
06:44:58 <mauke`> ghci (or Show) optimizes for accuracy rather than prettiness
06:45:36 <RaceCondition> ok, so your answer is no
06:45:36 <Maarten__> Hi! Anyone knows if there is a problem with Hackage? I submitted a new version of a package last week but it still hasn't build the docs, reporting "Docs pending Build status unknown [no reports yet]".
06:47:27 <puregreen> you can do it sort of
06:47:32 <puregreen> a sec
06:48:07 <puregreen> hm, no, wait, it won't work like I thought it could
06:49:06 <puregreen> ghci has an -interactive-print flag that lets you choose a different function to display values, but it's not going to help you much because you'd also need an instance of some class other than Show
07:04:21 <merijn> Any optparse-applicative users? Is there a way to have an option's value default to that of another option?
07:04:27 <hansihe> using parsec, is there any easy way to see if sepEndBy was ended with sep or not?
07:04:53 <merijn> hansihe: If those two are different I'd probably not use sepEndBy?
07:05:45 <hansihe> merijn: yep, probably
07:05:58 <hansihe> merijn: what should i use instead?
07:06:59 <merijn> hansihe: sepBy and then explicitly try to parse the end after that?
07:10:08 <hansihe> merijn: so that's the simplest way to do it then? alright
07:13:34 <mauke`> > sort [3, 0/0, 2, 7]
07:13:36 <lambdabot>  [2.0,7.0,NaN,3.0]
07:53:07 <wlad> Guys, has anyone encountered string concatenation issues when using "trace" from Debug.Trace extensively?
07:53:44 <wlad> Like, beginning of a string is cut
07:55:37 <tdammers> using Debug.Trace extensively sounds like a bad strategy to me
07:59:03 <xplat|work> tdammers: still might be better than using it intensively
07:59:19 <mauke`> \r in your string?
07:59:46 <tdammers> I would have guessed at other I/O activity interfering
08:00:12 <tdammers> possibly related to how `trace` is essentially unsafePerformIO . putStrLn
08:01:13 <xplat|work> more like seq . unsafePerformIO isn't it?
08:01:16 <wlad> tdammers: yeah, I just removed import and priveded dummy implementation, i.e. trace str a = a   and it seems to be working
08:01:35 <merijn> xplat|work: "seq . unsafePerformIO" doesn't do anything
08:01:44 <merijn> oh, wait, it might
08:01:51 <merijn> dark voodoo
08:01:56 <wlad> Anyway, I used it for debugging my algorithm, no essential output, just seems kinda off
08:06:16 <tazjin> Why do partially initialised records not return a partially applied version of the type's constructor? This seems unsafe? (I know there are all kinds of problems with records, but this one seems like it would have an obvious "correct" behaviour?)
08:07:50 <tdammers> that would make for some inconsistency between record-style initialization and record-style modification
08:08:18 <xplat|work> tazjin: this way you have Foo {a = b} {c = d} = Foo {a = b, c = d}
08:08:19 <tdammers> i.e., Foo { bar = "baz" } would be a partially-applied Foo, but foo { bar = "baz" } would be foo with the bar field modified to "baz"
08:09:01 <tdammers> forbidding incompletely initialized records entirely would be better though IMO
08:09:16 <xplat|work> although strictly speaking it is then still weird that Foo {} is not the same as Foo
08:09:32 <tazjin> tdammers: they are "handy" for default values
08:10:00 <exio4> nothing lenses can't solve? 
08:10:19 <exio4> and some absurd type class with a Default value
08:10:28 <xplat|work> actually lenses aren't totally great at constructing records
08:11:54 <tdammers> tazjin: default values?
08:12:25 <tdammers> not providing record fields leaves them undefined, I am unaware of a language feature that allows you to define defaults for them
08:12:49 <tdammers> there's Data.Default, but with that, you'd do def { bar = "baz" } :: Foo rather than Foo { bar = "baz" }
08:13:08 <xplat|work> tdammers: well, there's just the whole 'record smart constructor' idea
08:13:12 <tazjin> they're not "officially" defaults, you can partially initialise a record and only export a smart constructor that takes the remaining fields
08:13:36 <tazjin> but there's potential for shooting yourself in the foot
08:14:17 <tdammers> Data.Default + smart constructors sounds like a much saner idea to me then
08:15:11 <obadz> what are reasonable solutions one can use to "show" the inside of a Dynamic ?
08:16:00 <obadz> I understand that resolving the Show typeclass at runtime is just not going to happen
08:16:18 <obadz> Surely there's something that one can do at runtime? What does the REPL do ?
08:16:52 <mauke`> the REPL calls show
08:17:02 <xplat|work> it'd be kinda nice if someone did a '(* -> Constraint) -> *' version of Dyn now that constraint kinds are a thing
08:18:09 <obadz> mauke`: yeah but somehow the REPL gets to play with types and typeclasses in a way that a regular program cannot
08:18:27 <mauke`> no, it doesn't
08:23:04 <tazjin> tdammers: agreed, however my main problem with this is  how partially initialised records aren't sane :)
08:23:14 <tdammers> yeah, no, they're not
08:23:32 <tdammers> which is why I said I'd prefer for that to be a hard error
08:23:38 * hackagebot data-ref 0.0.1.1 - Unify STRef and IORef in plain Haskell 98  https://hackage.haskell.org/package/data-ref-0.0.1.1 (HenningThielemann)
08:23:40 <ggVGc> so, what would I do with this, in the simplest way, to thread the state? https://gist.github.com/ccdb6836609f42297e61 Do I have to use monad transformers?
08:24:36 <ggVGc> can I just do it with recursion or with a fold?
08:24:43 <tdammers> yes you can
08:25:06 <tdammers> State/StateT, in fact, is really just a wrapper around passing state as arguments/return values
08:25:33 <xplat|work> tdammers: you can turn it into a hard error with the help of a particular -W flag and -Werror
08:25:40 <tdammers> xplat|work: yes, I know
08:26:11 <tdammers> ggVGc: you could also use actual mutable variables (MVar/TVar/IORef), but the pure approach is generally preferred
08:26:17 <obadz> https://gist.github.com/obadz/fb94eb3b677381817e8a <= typeclass overlappable error in the comment, why am I seeing this?
08:28:39 <geekosaur> obadz, constraints are not used when selecting an instance
08:28:58 <geekosaur> as far as instance selection is concerned, both of your instances match every type
08:28:59 <obadz> geekosaur: :-(
08:29:07 <obadz> geekosaur: any recommandations?
08:33:39 * hackagebot webdriver 0.8.1 - a Haskell client for the Selenium WebDriver protocol  https://hackage.haskell.org/package/webdriver-0.8.1 (AdamCurtis)
08:33:50 <obadz> is this a job for IncoherentInstances?
08:38:59 <ggVGc> man, I'm really struggling with this... so, as before, this doesn't print anything, supposedly because of lazy I/O. Can I somehow do it without pulling in and also learning process or conduit? https://gist.github.com/8d0917f1e970083f0506
08:39:17 <ggVGc> I'm just trying to statefully parse an incoming binary stream :(
08:39:38 <ggVGc> how can I modify that to force chunks to evaluate when they are available for reading?>
08:40:26 <wlad> Guys, do we do code review here?
08:40:28 <Gurkenglas> Shouldn't telling it to force all the chunks (one after the other) have that behavior?
08:40:42 <ggVGc> Gurkenglas: how do I do that?
08:40:44 <Gurkenglas> wlad, I like doing it.
08:40:55 <phaazon> hey, is it hard to implement lambdabotâ€™s interpreter?
08:41:02 <phaazon> Iâ€™d like to embed such a thing in my own irc bot
08:41:10 <wlad> Gurkenglas: I implemented A* algorithm for Uni: http://lpaste.net/7729849910459105280
08:41:31 <obadz> ggVGc: don't you "lose" a & b if there's no rest?
08:41:35 <glguy> ggVGc: That doesn't print anything because the parse never finishes and runGet isn't lazy
08:41:50 <wlad> There's also graph.txt: http://lpaste.net/2618371003201355776
08:41:52 <Gurkenglas> Oh lawdy thats a lot of code for A*
08:42:02 <glguy> testParse expects to find an infinite sequence of bytes
08:42:04 <wlad> really? :D
08:42:38 <wlad> I'm relatively new to FP, so I tried making a prototype in Python first and use it as a reference
08:43:14 <ggVGc> glguy: well, yes, obviously this isn't correct. But I'm lost as to how to accomplish what I want without learning additional libraries and pulling in monad transformers
08:43:23 <ggVGc> I thought this would be a fairly simple thing, but turns out not :([5~
08:43:25 <wlad> There also are some 40 lines for parsing a file with a graph
08:43:49 <glguy> ggVGc: You need to runGet once per pair of bytes if you want to process pairs of bytes lazily from the file
08:44:58 <ggVGc> glguy: okay, so what I had before works, for one message, but I don't know how to recurse to make it loop, https://gist.github.com/088b22aec53a37af5564
08:45:09 <ggVGc> how would I modify that to loop and carry the state
08:45:52 <Gurkenglas> Here's how I'd do parsing: splitOneOf "[,]() " from Data.List.Split
08:46:16 <glguy> ggVGc: You can use runGetIncremental to implement a runGet that gives back the unparsed bytestring
08:46:53 <Gurkenglas> Put one line in, get a list of numbers in order. (lines turns your file into a list of lines.)
08:46:56 <glguy> and then you'll have, effectively,  let (result, newstate, remainingByteString) = yourRunGet (parseMidiMessage oldstate) oldbyteString
08:47:01 <glguy> and do that over and over
08:47:51 <glguy> ggVGc: It looks like "runGetOrFail" gives back the unused bytestring
08:48:02 <eze> hi, is there any future gsoc mentor online?
08:48:03 <ggVGc> thanks
08:48:07 <ggVGc> this is really helpful
08:48:12 <ggVGc> been struggeling with this the whole day..
08:48:14 <ggVGc> learnt a lot though
08:48:16 <Gurkenglas> (chunksOf to turn the right part into a list of pairs if you want; or perhaps split first by spaces, then by the other symbols. Splitting by spaces is "words".)
08:49:40 <Gurkenglas> "minimumBy (\a b -> (compare  (fst a)  (fst b)))" <- minimumOn fst
08:49:57 <mpickering> eze: there is #haskell-gsoc
08:50:56 <eze> mpickering: Oh, I didn't know that. Thanks for the information!
08:51:21 <Gurkenglas> :t fromMaybe (maxBound :: Int) -- line 80
08:51:22 <lambdabot> Maybe Int -> Int
08:52:23 <Gurkenglas> You should use foldr for updateValueFor 
08:55:18 <Gurkenglas> Wait nvm I thought that's foldr but it isn't; you shouldn't worry about looking through all of the list even if you already found something, if this part of the code becomes slow you can just use M.Map instead. Thus, use map for updateValueFor. (Or use M.Map immediately, that probably fits better anyway)
08:56:10 <ggVGc> glguy: hm, I can't find the docs for runGetOrFail anywhere
08:56:31 <ggVGc> oh crap, was looking at old docs
08:56:32 <wlad> Gurkenglas: as in provide a function which either leaves element untouched or updates a value if it's a hit?
08:56:34 <ggVGc> thanks google
08:56:41 <Gurkenglas> wlad, yep
08:56:41 <Gurkenglas> "comparison == EQ" <- use case comparison of instead.
08:57:01 <Gurkenglas> Oh hey you addressed that in a comment
08:57:09 <wlad> Gurkenglas: I was googling this one actually and as I understood it isn't possible?
08:57:19 <wlad> I would like to do something like LT|EQ
08:57:36 <wlad> case comparison of LT|EQ -> --code goes here
08:58:20 <nexsja> Hello guys
08:58:34 <nexsja> I have an exam on Haskell today and I'm somewhat nervous - I'm still having issues reading Haskell.
08:58:36 <Gurkenglas> Nope not possible. With guards, you can do elem comparison [LT, EQ] or comparison == LT || comparison == EQ or just put the other case first with comparison == GT
08:59:17 <nexsja> I've been in web development for around 8 years - mainly PHP and I have a good understanding of the basic OOP concepts, but Functional programming... My mind just doesn't clck.
08:59:29 <wlad> Oh right, I haven't thought about this (==GT)
08:59:31 <nexsja> Would anyone mind explaining a few... random questions?
08:59:35 <quicksilver> leq LT = True; leq EQ = True; leq GT = False; if leq comparison then ....
09:00:01 <wlad> Also, I'm trying to find splitOneOf. Does it come with ghc by default?
09:00:02 <kadoban> nexsja: Probably someone will if you ask.
09:00:05 <nexsja> Like with currying. Is there an order by which the variables are replaced within the function? Or is it done by type?
09:00:11 <Gurkenglas> decideOnUpdating should be "StateT (Costs, Parents, OpenQueue) Maybe ()". Then you could use lens oeprators for all this imperative stuff you're doing
09:00:14 <wlad> hackage returns There is no documentation for split-0.2.3. See https://hackage.haskell.org/package/split/docs/Data-List-Split.html for the latest version.
09:00:28 <nexsja> Also, what's the deal with underscores everywhere? 
09:00:34 <Gurkenglas> (Or perhaps there's a nonimperative way that we'll see once you've enlensed the code :P)
09:00:42 <wlad> Gurkeglas: any newbie stuff about lens you'd recommend reading? 
09:00:52 <wlad> I'm also not good with Monads. 
09:01:22 <Gurkenglas> If you see that, go to (in this case) https://hackage.haskell.org/package/split and select an earlier version
09:01:43 <Gurkenglas> Seeing that means the package was recently updated and the donated servers haven't yet gotten around to building the docs for that version
09:02:15 <kadoban> nexsja: Variables are applied in the order they're given.  If you have (foo :: Int -> String -> String), and you do: foo "blah", it's a type error. If you do: foo 5, the result is of type :: String -> String
09:02:43 <kadoban> nexsja: You should play with this until it starts to feel right. Haskell is not a language to read a lot about without experimenting.
09:03:10 <kadoban> nexsja: What underscores? Haskell has far fewer of them than many other languages, just because variables_aren't_named_like_this
09:04:03 <nexsja> I spent like two lectures asking the professor to explain currying, I think I finally understood it as "recursive variable replacement" and that "felt adequate" :))
09:04:12 <nexsja> With variables - I'm looking at the code. (Just a sec)
09:04:22 <nexsja> Well, like this: 
09:04:23 <kadoban> nexsja: Did you play with it between the two lectures?
09:04:27 <nexsja> getcheapest :: Vertex' -> Vertex' -> Bool
09:04:27 <nexsja> getcheapest (Vtx _ (Pt _ x) _) (Vtx _ (Pt _ y) _) = if x < y then True else False
09:04:50 <nexsja> I did, yeah. I had a problem I needed to solve - determine whether the characters in an input string are all Digits
09:04:52 <mauke`> 'if ... then True else False' better written as '...'
09:05:00 <nexsja> I failed that that, but I did play around with it a bit :)
09:05:31 <nexsja> That function I copied is really hard to read for me
09:05:34 <kadoban> nexsja: Oh. In a pattern, '_' means "there something here, I don't care what it is, I'm not going to use it"   It's essentially the same as using a letter there that you don't use at all in the body of the function (except it's better because you won't accidentally use it)
09:05:59 <nexsja> Do they get overwritten also in the process of currying?
09:06:10 <kadoban> nexsja: This has nothing to do with currying that I can tell?
09:06:11 <nexsja> Only if the types match?
09:06:33 <mag__> nexsja, well that's a bit more, compared to the kind of questions you are asking 
09:06:54 * mag__ stays out of the way 
09:07:03 <nexsja> I feel like I don't understand how haskell "works"
09:07:28 <nexsja> lemme pastebin a part of the code
09:07:46 <mauke`> nexsja: "currying" is a trick to emulate multi-parameter functions in a language that only supports single-parameter functions
09:08:29 <nexsja> Sooo that's why there's the $ symbol?
09:08:50 <nexsja> It seems that it kind of helps readability also
09:08:53 <kadoban> nexsja: You should probably try to avoid making a big deal out of currying in haskell. It's â€¦ pretty subtle because it's so ridiculously easy. There's no magic to it at all. You start with a function that takes two arguments. You apply one argument in the usual way. You now have a function that takes one argument. That's it.
09:09:19 <mauke`> nexsja: no
09:09:21 <kadoban> nexsja: ($) is used *mostly* because it's really low precedence. It's a way to avoid having to use () around things for precedence.
09:09:32 <kadoban> :t ($)
09:09:34 <lambdabot> (a -> b) -> a -> b
09:09:38 <mauke`> $ isn't even built into the language. $ is an operator defined in some library
09:09:53 <mag__> function application 
09:09:58 <nexsja> Oh.
09:10:02 <nexsja> :t ($) makes sense.
09:10:03 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
09:10:15 <mag__> hahah
09:10:17 <nexsja> Sorry, boy.
09:10:19 <mauke`> > f $ x  :: Expr
09:10:19 <nexsja> bot*
09:10:21 <lambdabot>  f x
09:10:34 <mauke`> > f $ g x  :: Expr
09:10:36 <lambdabot>      No instance for (Show r0) arising from a use of â€˜fâ€™
09:10:36 <lambdabot>      The type variable â€˜r0â€™ is ambiguous
09:10:36 <lambdabot>      Note: there are several potential instances:
09:10:38 <mauke`> aw
09:10:43 <mauke`> too unconstrained
09:11:17 <nexsja> http://pastebin.com/MgLbLa75
09:11:32 <nexsja> Apparently two pastebin services don't like apostrophes.
09:11:51 <nexsja> Wait. I think I'm understanding that.
09:12:02 <nexsja> Somewhat. 
09:12:13 <obadz> is it safe to call Data.Unique.newUnique in unsafePerformIO ?
09:13:14 <nexsja> It takes Vertex' as an argument, replaces the first "(Vtx _ (Pt _ x) _)" With a Vertex. 
09:13:22 <mauke`> nexsja: '... then True else False' makes me sad :-(
09:13:47 <nexsja> The assignment is to refactor this code, so I'm assuming that's intentional
09:14:19 <nexsja> Should probably be replaced with simply "x < y"
09:14:27 <nexsja> I'm assuming that will yield a boolean value
09:14:36 <mauke`> if it didn't, you couldn't use it in 'if'
09:14:44 <mauke`> you're missing the definition of Path
09:14:59 <mauke`> which I assume looks like 'data Path = Pt ? ?'
09:15:08 <nexsja> Oh, right. That's why it doesn't make sense 
09:15:08 <nexsja> data Path = Pt [String] Double
09:15:14 <nexsja> lemme update the pastie
09:15:36 <nexsja> http://pastebin.com/g89T8Ns0
09:15:58 <nexsja> So it takes the Double from Path, 
09:16:01 <nexsja> Oh, I get it.
09:16:14 <nexsja> It takes the double from Path that come from Vertex' and compares them.
09:16:31 <nexsja> Ignoring everything else. 
09:17:12 <nexsja> The on-the-fly assignment to x and y is kind of cool, yet initially confusing
09:17:35 <wlad> nexsja:may I ask you where are you from?
09:17:38 <kadoban> Yeah, pattern matching is really cool, once you figure out what it's doing.
09:18:07 <quchen> "Visitor pattern on steroids"
09:18:12 <nexsja> wlad, why?
09:18:21 <wlad> nexsja: Latvia by any chance?
09:18:26 <nexsja> God damn it
09:18:30 <wlad> :)
09:18:36 <wlad> Group?
09:18:47 <nexsja> There, I'm already getting in trouble.
09:19:12 <nexsja> Are you the one taking the exam?
09:19:21 <wlad> No, his name is Dmitry
09:19:24 <wlad> D. Lancovs
09:19:25 <tekkkz> Hello! I tryed to install the »libnotify« package via cabal, but this failed: http://ix.io/nnh how to get it installed?
09:19:34 <wlad> I doubt he would choose my nickname
09:19:42 <nexsja> Well, he may be hiding.
09:19:51 <wlad> Probably, but he's pretty laid back guy
09:20:03 <nexsja> He is, indeed. 
09:20:25 <dcoutts> tekacs: ExitFailure (-11) is SIGSEGV
09:20:26 <nexsja> That's why I'm really hoping he won't be making it too difficult for us. :)))
09:20:39 <dcoutts> oops, wrong nick. tekkkz ^^
09:21:02 <wlad> well, for all I know you could just explain the code he wrote
09:21:29 <dcoutts> tekkkz: ExitFailure (-11) is SIGSEGV, so your ghc died. Sometimes not enough memory and the kernel killed it, more rarely it can be bad physical memory.
09:21:41 <nexsja> He said yesterday that If you can't refactor it then you'll have to at least explain what it does
09:22:06 <nexsja> I somewhat understand what's happening just by knowing AStar, but reading the code is... Difficult.
09:22:10 <wlad> Yeah, that's what I meant. No biggie
09:22:19 <wlad> Because he made it difficult
09:22:24 <ggVGc> glittershark: thanks a lot! I finally have something working now I think thanks to you. I was reading outdated docs on Biary.Get, hence having issues, https://gist.github.com/d7eaf6515528cca2333f
09:22:30 <ggVGc> does that look alright?
09:22:35 <tekkkz> dcoutts, so what should i do?
09:22:50 <dcoutts> tekkkz: is it a low memory box? like less than a Gb?
09:23:16 <tekkkz> no, 1.8gb free
09:23:16 <nexsja> mauke`, a comparison yields a boolean value, as in 5 < 3 => false. 
09:23:22 <nexsja> How would that work in an assignment? 
09:23:35 <dcoutts> tekkkz: well make sure enough is free, and build with -j1 to avoid parallelism and try again
09:23:48 <nexsja> that example you were sad about, I tried assigning the result (asd = x < y) but that doesn't work
09:24:03 <geekosaur> that'd be your assignment not the comparison
09:24:08 <geekosaur> a Bool is a Bool
09:24:15 <geekosaur> > let foo = 5 < 3 in foo
09:24:17 <lambdabot>  False
09:24:23 <Gurkenglas> lpaste-bot doesn't work or I failed? http://lpaste.net/7729849910459105280#a148944 wlad, here's a refactoring of decideOnUpdating using lens without imports and with no testing, as an example of what it looks like to go in the direction of lens.
09:24:37 <geekosaur> lpaste bot hasn't been reporting recently
09:24:42 <mauke`> nexsja: what do you mean, assignment?
09:24:57 <nexsja> Well, I have this line: getcheapest (Vtx _ (Pt _ x) _) (Vtx _ (Pt _ y) _) = if x < y then True else False
09:25:08 <nexsja> I'm trying to do this:  getcheapest (Vtx _ (Pt _ x) _) (Vtx _ (Pt _ y) _) = x < y
09:25:22 <wlad> Gurkenglas: thanks. What would be a good intro to monads? CIS 194?
09:25:24 <tekkkz> dcoutts, also with j1 not working ;/
09:25:39 <wlad> Gurkenglas: I'm referring to State monad, because I want to understand that as well
09:25:49 <dcoutts> tekkkz: fails consistently in the same place?
09:25:49 <kadoban> nexsja: Looks good. What goes wrong?
09:25:57 <nexsja> astar.hs:174:1: parse error on input â€˜=â€™
09:26:00 <Gurkenglas> Dunno.
09:26:10 <wlad> I read header from haskell beginners with review of common resources, i.e. LYAHFGG etc
09:26:19 <nexsja> Sorry, I'm dumb.
09:26:56 <wlad> Anyway, thanks. I'll look into  refactoring you made
09:27:10 <alpha123> wlad: I feel like you just have to figure monads out for yourself. They're not complicated, and you've accidentally used them hundreds of times already. "Help me understand monads" tutorials are not that useful imo
09:27:31 <Gurkenglas> wlad, oh and lines 21 and 22 don't work that way because you can't just plug the name of the lens in there - but if updateValueFor took costs/parents as the last argument, you could use %= instead of .= to take a modifying function instead of a value to set to. The same way, line 30 can be written as "open %= (:) (heuristic, vertexName neighbourEdgeNode)" (it's "neighbor")
09:27:33 <peddie> wlad: yes, try cis194
09:27:38 <tekkkz> dcoutts, no,  i think its a different palce: http://ix.io/nnl
09:27:54 <wlad> alpha123: I kind of do. I even used a couple of times in A* implementation, but I wouldn't say I could possibly explain them to anyone
09:28:25 <alpha123> Explanations of monads in English typically tend to come out a little weird anyway
09:29:12 <Gurkenglas> One of the great projects of the future will be analyzing the human brain to figure out just how we understand monads to figure out a good explanation
09:29:57 <ggVGc> the main problem with monads is the word I reckon
09:29:58 <wlad> honestly, there's little to explain,  I mean they can be implemented in C++ and python. The difficulty comes in actual examples, e.g. (Gurkenglas provided it): StateT (Costs, Parents, OpenQueue) Maybe ()
09:30:09 <ggVGc> and also I think the do notation is a big part of why we struggle with monads
09:30:17 <wlad> Yes, this too
09:30:18 <ggVGc> do notation actually sucks for learning haskell
09:30:46 <alpha123> yeah do notation made my brain hurt, >>= everywhere is somewhat unreadable but at least quite straightforward
09:30:51 <Gurkenglas> Ah shoot that's supposed to say S instead of the triple in my line 9
09:30:54 <ggVGc> I'm in the boat currently where I conceptually understand monads and type classes fine(I think), but I'm having a lot of issues using do notation and understanding the various actual monads that are commonly used
09:31:14 <quchen> For me it was just the other way round, do notation made sense and >>= didn't
09:31:33 <ggVGc> it makes "sense" for most people, but in the wrong way
09:31:34 <dcoutts> tekkkz: ok, but same failure. If you watch top while it's running to see how much memory is being used, if it's not using that much then one would suspect either bad memory or an otherwise broken/corrupted ghc install. If it is pushing the machine to the limit in terms of memory then there's a few options: add swap, build on a different machine with more memory and deploy to the low mem one, try another linker if possible ld vs gold, rebuild ghc wi
09:31:34 <dcoutts> thout "split-objs" that makes the linker take so much ram
09:31:36 <Gurkenglas> wlad, since you only use x and y from vertex together, you should just keep them in a pair.
09:32:03 <wlad> Gurkenglas: you mean in a definition of Vertex?
09:32:19 <wlad> quchen: :t (>>=)
09:32:19 <ggVGc> I find using do notation with code I'm familiar with is fine, but if I need to use a new monadic libary, it gets pretty hard
09:32:24 <wlad> pretty straighforward I think
09:32:34 <quchen> wlad: Hah, I wish(ed).
09:32:46 <ggVGc> also, I think the haskell community has a terrible state of documentation and writing understandable code and APIs
09:32:46 <wlad> The difficulty (for me at least) is in "spotting"  this stuff in code
09:33:04 <alpha123> I find most haskell documentation somewhat better than average
09:33:08 <m1dnight_> I have copied over some unit tests from an other project (well, exactly the asme project but a fork) and for some reason the unit tests wont compile.
09:33:09 <alpha123> possibly because I came from Common Lisp
09:33:10 <ggVGc> and that coupled with the fact a lot of peopel make their libraries monadic just to get to use do notation makes it hard
09:33:43 <m1dnight_> https://www.refheap.com/113620
09:33:50 <m1dnight_> Thats my source + error. Can somebody help me with it ?
09:34:09 <Levex> ggVGc your nick is awesome
09:34:10 <ggVGc> alpha123: most haskell libraries I find don't even have a single compilable example to be found anywhere, and mostly no description for functions in hackage. Just the generated function stubs
09:34:11 <m1dnight_> Oh wait, nvm.
09:34:19 <quchen> wlad: I'm still not done understanding monads, every now and then a new interesting fact about them (or applicatives) comes up. Monads are for context-sensitive grammars, applicatives for context-free (finite) ones. Monads don't parallelize, monads are bad for static code analysis
09:34:20 <ggVGc> Levex: hah, thanks, http://ggvgc.com if you're interested
09:34:28 <wlad> Oh right, Vim masterrace
09:35:32 <Levex> ggVGc: wow
09:35:40 <nexsja> Is there an interactive debugger in haskell?
09:36:07 <nitrix> nexsja: Sure, GHCI!
09:36:13 <wlad> quchen: My colleague said that a (somewhat) good approach would be to re-implement common monads like Maybe. But right after that he went on how something called Arrows would change ubiquity of monads. Yeah, right. Stop the world, so I could learn monads first
09:36:16 <alpha123> nexsja: ghci has a built-in debugger
09:36:19 <nitrix> nexsja: :break func
09:36:19 <nexsja> :break just dumps me something 
09:36:21 <nitrix> nexsja: :step, etc.
09:36:35 <nitrix> nexsja: Well, you have to run the function too. Just putting a breakpoint isn't enough.
09:36:40 <nexsja> Oooh, :step
09:36:46 <wlad> BTW anyone here using emacs for development?
09:37:55 <Ankhers> wlad: yes.
09:38:27 <nexsja> oh, well. Time for the execution.
09:38:37 <nexsja> Thank you guys! You've been really helpful :)
09:38:46 <nexsja> I wish I'd found this channel sooner :))
09:38:53 <quchen> wlad: Using Arrows to explain Monads seems like a pretty terrible idea.
09:38:55 <wlad> Ankhers: any tips on how to get into the whole emacs + Haskell thing? I'm using Vim, but wishing to try something different. 
09:39:14 <glguy> wlad: You don't need to worry about Arrows until you run out of things to worry about
09:39:15 <Ankhers> wlad: an easier transition from vim to emacs would be to use the spacemacs config.
09:39:50 <wlad> glguy: Yeah, I don't. I was giving an example of people, who think stuff is trivial for them, so it must be trivial for everyone :P
09:40:10 <Cale> nexsja: I've been programming in Haskell for quite some time now (like 15 years), and I still can't name a time when GHC's debugger actually helped me remove a bug, but glad that you're pleased with it :)
09:40:15 <wlad> Ankhers: Does it use Evil? I'm kind of leaning towards vanialla emacs first
09:40:44 <Cale> nexsja: Usually just observing the values of things by evaluating expressions is enough to determine what's going wrong.
09:40:44 <nexsja> Cale I'm not :D It's just... there :)))
09:41:02 <nexsja> I still don't really understood what I gave me - probably because I'm still fuzzy how case works in haskell
09:41:13 <Cale> nexsja: Being able to step though code is less useful when you know that all the functions will always evaluate to the same thing when provided the same input.
09:41:15 <quchen> Cale: I'm excited about the debugging capabilities coming in 8.* anyway though. GHCi debugging isn't very enjoyable.
09:41:48 <nexsja> Cale what's being developed with Haskell anyway? Statistics stuff? Analysis? 
09:42:08 <quchen> Cale: And purity of functions doesn't tell you anything about with what parameters they're actually called in the running program. Sure, you don't need that terribly often, but sometimes it's useful. And Debug.Trace can't be the answer :-|
09:42:11 <Cale> nexsja: The company I work for does web applications of various sorts
09:42:24 <nexsja> well that's unexpected 
09:42:35 <nexsja> Haskell in web development?
09:42:40 <Cale> Shouldn't be -- there are lots of nice web frameworks for Haskell
09:43:06 <alpha123> haskell is rather nice for web development actually
09:43:18 <nexsja> Really? Huh. 
09:43:18 <Cale> We're using Snap for the backends largely (for now, we might build something using reflex eventually), and reflex-dom for the frontends
09:43:21 <wlad> Cale: So getting paid for Haskell is not a myth afterall?
09:43:25 <nexsja> Soo... Restful APIs?
09:43:28 <Cale> (Haskell compiled to Javascript)
09:43:57 <Cale> wlad: Not a myth, they pay me quite well :)
09:43:59 <Ankhers> wlad: it can use evil, but you don't have to if you don't want to.
09:44:04 <nexsja> Haskell compiled to JS sounds odd in the era of AngularJS and EmberJS
09:44:23 <wlad> Ankhers: TY, I'll give it a try then.
09:44:45 <wlad> Cale: that's nice, because the way I heard it was HR filtering CVs for haskell and make these people write Java
09:45:25 <nexsja> wlad, forcing OOP on functional people sounds like savagery 
09:45:29 <Cale> nexsja: For one, it's really nice to, for instance, use the same data structures on the frontend and backend of the web application and know that your code for creating JSON and parsing it back into data won't be out of sync, because the same library is constructing the code for doing that for you automatically.
09:45:45 <wlad> nexsja: Forcing witty people to write Java, that's all
09:46:01 <Gurkenglas> wlad, yep, in the definition. Oh and line 16 can be "guard $ costCalc > costBefore".
09:46:28 <nexsja> Gonna log out for some time, need to get to that execution sometime today ?D
09:46:29 <nexsja> :D
09:46:38 <Cale> nexsja: For another, we have some really nice systems for building the DOM in a way which depends on values that change over time, and capture values that change over time from user input, and have our library (reflex/reflex-dom) take care of making sure that everything remains updated correctly.
09:46:40 <nexsja> Thanks guys. wlad, you going?
09:46:50 <monochrom> execution? exercise?
09:47:01 <wlad> nexsja: Going where?
09:47:06 <nexsja> The exam. A.K.A. the execution.
09:47:31 <monochrom> oh, it's really an execution
09:47:46 <wlad> nexsja: I can get it done via "Distant courses". I'm on sick leave
09:47:48 <nexsja> Cale, this https://github.com/ryantrinkle/reflex-dom ?
09:47:55 <Cale> yes, that's it
09:48:12 <nexsja> That's very curious, I'll definitely take a look at it.
09:48:13 <wlad> nexsja: But man, I'm telling you, this exam is nothing compared to shit like Project Management and Applied Maths
09:48:27 <wlad> Gurkenglas: thanks for the tips, good sir
09:48:32 <nexsja> wlad, I believe you. I actually do. 
09:48:42 <Cale> nexsja: try-reflex has a nice tutorial in its readme, and there's a talk about it...
09:48:42 <nexsja> Orlov is unbelievably annoying to listen to.
09:48:45 <suppi> I like that when someone asks what haskell is used for I can say I built a blog, a programming language interpreter, an emulator and am now trying to build games
09:48:48 <Gurkenglas> (All of these last line numbers of course refered to my annotation)
09:49:00 <wlad> nexsja: Calling himself a "father of PM". Lol
09:49:10 <nexsja> Well, he did write a few good books, though.
09:49:18 <wlad> nexsja: Ambitious nothings -- that's our CS department
09:49:29 <nexsja> But, yeah, calling yourself the father of PM is kind of a stretch.
09:49:29 <wlad> Oh you mean "did write" as in "translated"?
09:49:30 <wlad> Yeah
09:49:34 <Cale> https://www.youtube.com/watch?v=dOy7zIk3IUI -- I think this is the one... :)
09:49:37 <nexsja> He didn't write anything?
09:50:04 <nexsja> Thank you, Cale! I just heard today that they pay extra in my company for knowing very rare stuff like Haskell :D
09:50:09 <nexsja> If there's a use for it.
09:50:12 <wlad> nexsja: I doubt anyone "wrote" anything of interest there.
09:50:59 <nexsja> I have a feeling that the current course is kind of... Prehistoric. 
09:51:12 <wlad> nexsja: In what sense?
09:51:32 <nexsja> They gave us a few lectures on Game Theory, which was basically "Hey, there's this stuff, I don't know anything about it, but it exists"
09:51:36 <nexsja> Kind of disappointing. 
09:51:50 <nexsja> In a sense that knowing waterfall is good in, like, general knowledge.
09:52:01 <nexsja> But today most companies are doing agile anyway
09:52:06 <nexsja> Or... Scrumban or whatever.
09:52:41 <wlad> nexsja: Or they are doing "Agile" aka "throw a bunch of shit on the board and do something when PM/PO yells at you"
09:52:43 <nexsja> Understanding the roots is cool and all but highly unlikely that the students will actually use any of the knowledge they were given.
09:53:22 <wlad> nexsja: Too little young professionals there, so it's kind of nonsensical to demand quality knowledge
09:53:41 <wlad> And I suppose that pay is... well, not good
09:54:00 <nexsja> It's like there should be an institution of some sorts that... teaches young people to become professionals?
09:54:33 <glguy> Possibly, but this channel is focused on questions and discussion about Haskell programming
09:54:45 <wlad> nexsja: I'm saying that it's good when people know shit. As in have actually done it.
09:54:49 <wlad> Yeah, sry
09:54:49 <nexsja> Sorry, we got carried away a bit :)
09:54:49 <tekkkz> dcoutts, no, only 50% memory is used ... what can i do now?
09:55:22 <monochrom> do you want to use more memory? :)
09:55:32 <tekkkz> me?
09:55:35 <monochrom> yeah
09:55:41 <tekkkz> what? why?
09:55:50 <dcoutts> tekkkz: ok, that's quite odd then. did you run with -v3 and confirm that it'd the ld process that's failing with SIGSEGV?
09:56:20 <dcoutts> tekkkz: what arch & os are you using? where did you get your ghc install from?
09:56:54 <dcoutts> tekkkz: has it worked before, is this the only thing that's failing, or is this more or less the first thing you're building on this box?
09:57:58 <Gurkenglas> wlad, http://lpaste.net/7729849910459105280#a148945
09:58:27 <tekkkz> dcoutts, have a look here: http://ix.io/nnu ; im on archlinux, got ghc from official repo. everything before worked fine ...
09:58:41 * hackagebot retry 0.7.1 - Retry combinators for monadic actions that may fail  https://hackage.haskell.org/package/retry-0.7.1 (MichaelXavier)
09:58:52 <dcoutts> tekkkz: "official repo" meaning the arch repo, not from haskell.org
09:59:06 <tekkkz> ghc from arch repo
10:00:37 <wlad> Gurkenglas: thanks, I'll try to wrap my head around lenses
10:00:45 <dcoutts> tekkkz: ah, it's not the linker
10:01:23 <dcoutts> tekkkz: see where it runs setup configure for glib-0.13.2.2? we should try that manually and reproduce, and/or get more info
10:01:48 <dcoutts> tekkkz: so cabal unpack glib-0.13.2.2, cd into it and try building the Setup.hs and then running the command from the log
10:02:11 <dcoutts> see if it produces any output, and check the exit code reported by your shell
10:02:51 <refried__> newbie question:  I'm looking at the laws for `sequenceA` near the top of https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Traversable.html
10:02:55 <dcoutts> tekkkz: it looks like the compiled setup segfaults immediately on startup, which is quite unusual
10:03:09 <refried__> could someone help me understand the order of operations for those equations?
10:03:48 <quchen> refried__: "space" function application binds tighter than anything else in those equations.
10:04:09 <quchen> refried__: ( traverse (Compose . fmap g . f) )    =   ( Compose . fmap (traverse g) . traverse f )
10:04:29 <refried__> quchen: so like:   t . sequenceA = sequenceA . (fmap t) ?
10:04:34 <quchen> refried__: Yes.
10:04:43 <quchen> traverse (Compose . fmap g . f)  ==  traverse (Compose . (fmap g) . f)
10:05:22 <refried__> quchen: what does (fmap t) mean when it looks like t is a type?
10:06:02 <quchen> refried__: "t" isn't a type, it's a value (function).
10:06:12 <refried__> ok thanks
10:06:15 <quchen> refried__: That "t" is not the same t you see in "Traversable t".
10:06:21 <refried__> i was confusing it with the type constraint above
10:06:27 <refried__> thanks again
10:06:29 <quchen> It's an arbitrary name, it could be called "teeee" if you wanted to.
10:06:32 <refried__> i will :)
10:06:41 <refried__> err, i will pretend it is ;-)
10:07:20 <quchen> refried__: Remember, Haskell has two separate namespaces: Types and values. The "t" in "Traversable t" is a type variable, but the "t" in "fmap t" is an argument to the value "fmap".
10:07:37 <quchen> And values that take arguments are usually called functions. :-)
10:07:50 <quchen> (Just wanted to stress that fmap is on the value level, not on the type level.)
10:07:50 <refried__> quchen: when they say "applicative transformation t" do they specifically mean something like a -> t a ?  or not at all
10:07:55 <refried__> right
10:08:18 <quchen> refried__: It mentions what they mean with an "applicative transformation" right below the laws
10:08:24 <quchen> "where an applicative transformation is a function
10:08:24 <quchen> t :: (Applicative f, Applicative g) => f a -> g a"
10:08:25 <refried__> sorry, i see it now
10:08:49 <refried__> thanks again
10:08:58 <quchen> The naming is a bit overloaded on that page, maybe "t" isn't such a good variable identifier in those examples.
10:09:04 <t0by> I'm sorry - haskell newbie here, why do I get "non-exaustive patterns in function nth" in the following?
10:09:06 <t0by> nth :: Int -> [a] -> [a]
10:09:06 <t0by> nth _ [] = []
10:09:06 <t0by> nth n [a] = (nth n (drop (n-1) [a]))
10:09:07 <geekosaur> someone klined the web gateway again /o\
10:09:13 <refried__> wow
10:09:19 <t0by> (geekosaur, you say it as if it were a bad thing)
10:09:28 <geekosaur> [13 18:08] * edwardk has quit (K-Lined)
10:09:33 <geekosaur> can't be seen as a good thing >.>
10:09:41 <quchen> t0by: [a] is a list of a single element, not "a list containing anything"
10:09:46 <quchen> geekosaur: Talked too much to Lambdabot maybe
10:09:47 <monochrom> someone pressed the wrong button
10:09:49 <quchen> Happened to me
10:09:52 <t0by> geekosaur, oh, sorry, this is not #math. there, it's always a good thing.
10:10:11 <t0by> quchen, I'm an idiot. thanks.
10:10:24 <Gurkenglas> wlad, in my latest annotation line 5 requires graph before poppedVertex. And of course I forgot switching around EdgeNode and Vertex in 21/22
10:10:27 <quchen> t0by: The warning even tells you what patterns are missing :-D
10:10:40 <t0by> quchen, actually no, it doesn't.
10:10:53 <t0by> quchen, I only get "*** Exception: /home/tobia/Desktop/cs194/3/Golf.hs:(6,1)-(7,36): Non-exhaustive patterns in function nth
10:11:02 <t0by> quchen, is there a way to enable "fancy warnings"?
10:11:15 <wlad> Gurkenglas: looks like this stuff is actually hard :)
10:11:35 <monochrom> -Wall enables a lot of warnings. not sure about fancy.
10:11:56 <quchen> t0by: Ooooh. Yeah, -Wall.
10:11:59 <quchen> -W will suffice.
10:12:08 <quchen> Or -fwarn-incomplete-patterns if I recall correctly.
10:12:17 <quchen> But in general it's a good idea to be -W free.
10:12:19 <quchen> At least.
10:12:49 <t0by> Oh, yeah, like the Queen song.
10:13:06 <Gurkenglas> wlad, I've found that I get a large aha effect from figuring out what sequence does on a monad. Here's sketches I did in Octobre for Maybe and State: http://sketchtoy.com/66039859 http://sketchtoy.com/66039843
10:13:41 <t0by> Gurkenglas, you mean you found yourself as a rotoscoped cartoon character in a music video?
10:13:49 <t0by> (sorry. sorry. no more, i promise)
10:15:21 <wlad> Gurkenglas: So it basically takes Maybe out of type and applies it to a list or am I missing something?
10:16:22 <wlad> Gurkenglas: Another question: is the arrow on the right "Nothing"?
10:16:22 <kadoban> > (sequence [Just 5, Just 6], sequence [Just 5, Nothing])
10:16:24 <lambdabot>  (Just [5,6],Nothing)
10:16:31 <Gurkenglas> wlad, yes
10:16:36 <kadoban> Pretty much. It turns a list of maybes into a maybe list
10:17:09 <wlad> Ha! I was thinking about this stuff just yesterday. Like I really wanted something to do this. Turns out it's sequence. Nice!
10:17:26 <kadoban> Yeah sequence turns out to be ridiculously useful
10:18:15 <tekkkz> dcoutts, i was able to make the setup, what now?
10:18:31 <dcoutts> tekkkz: run it with the args given in that log you posted
10:19:22 <wlad> Could anyone explain "State" to me? I mean I can read it, but it doesn't hurt to see how it can be explained with analogies before diving into types and stuff.
10:19:33 <tekkkz> dcoutts, idk what you mean
10:19:38 <wlad> http://sketchtoy.com/66039843
10:19:50 <wlad> These arrows from "s" to "a" -- what do they signify?
10:20:02 <dcoutts> tekkkz: you see in the log you posted, where it calls /tmp/cabal-tmp-11421/glib-0.13.2.2/dist/setup/setup configure --lots-of-flags
10:20:03 <wlad> from "s" to "a" and another "s"
10:20:15 <Gurkenglas> State s a is a wrapper for "s -> (a, s)", a function that modifies a state s and produces an a in the process
10:20:16 <dcoutts> tekkkz: you should call ./setup you built with the same set of flags
10:20:32 <monochrom> "Int -> Bool" means a function with domain Int, codomain Bool
10:21:01 <monochrom> similarly, "s -> (a,s)" means a function with domain s, codomain (a,s). (a,s) is a tuple type.
10:21:05 <alpha123> translation: it takes and integer and returns a boolean
10:21:21 <monochrom> I wouldn't say "return". it's why I have to say codomain
10:21:30 <wlad> Gurkenglas: So would it be good idea to use it in a function that "pops" something? Like it gives you a value "a" and a rest of the list?
10:21:48 * alpha123 wishes haskell didn't use return for monads
10:21:56 <Ankhers> results in?
10:22:13 <wlad> Oh, I think "rest of the list" doesn't quite describe a "state", does it?
10:22:28 <alpha123> codomain works, though i would consider it a slightly esoteric term
10:22:44 <Gurkenglas> wlad, yesss one of my favorite lines is "x <- StateT uncons" - uncons is [a] -> Maybe (a, [a]), StateT wraps that function in a State monad and x thus gets filled with the head element of the list in the state while the state loses its head element
10:23:04 <monochrom> alpha123, that is not all. "return" has a connotation of control-flow, which is correct for imperative languages, but wrong for Haskell.
10:23:27 <tekkkz> dcoutts, http://ix.io/nnx
10:23:29 <alpha123> monochrom: fair enough, that too.
10:23:29 <wlad> :t State
10:23:31 <lambdabot>     Not in scope: data constructor â€˜Stateâ€™
10:23:31 <lambdabot>     Perhaps you meant one of these:
10:23:31 <lambdabot>       â€˜StateTâ€™ (imported from Control.Monad.State),
10:23:34 <Gurkenglas> :t state
10:23:34 <tekkkz> dcoutts, Segmentation fault
10:23:35 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
10:23:42 * hackagebot dom-parser 0.0.1 - Simple monad for parsing DOM  https://hackage.haskell.org/package/dom-parser-0.0.1 (AlekseyUymanov)
10:23:44 <wlad> :t Control.Monad.State
10:23:45 <lambdabot>     Not in scope: data constructor â€˜Control.Monad.Stateâ€™
10:23:45 <lambdabot>     Perhaps you meant one of these:
10:23:45 <lambdabot>       variable â€˜Control.Monad.State.apâ€™ (imported from Control.Monad.State),
10:23:54 <wlad> :t Control.Monad.StateT
10:23:55 <lambdabot>     Not in scope: data constructor â€˜Control.Monad.StateTâ€™
10:23:55 <lambdabot>     Perhaps you meant one of these:
10:23:55 <lambdabot>       variable â€˜Control.Monad.State.apâ€™ (imported from Control.Monad.State),
10:24:01 <alpha123> :t StateT
10:24:02 <lambdabot> (s -> m (a, s)) -> StateT s m a
10:24:08 <wlad> Thanks :P
10:24:13 <dcoutts> tekkkz: ok, as we expected. And just check if it does the same on any simple call to ./setup, ie ./setup  or ./setup --help or ./setup configure
10:24:52 <Gurkenglas> There are multiple monads that incorporate the State monad somehow, so state allows you to embed "s -> (a, s)" in any of them. "MonadState s m" says "m incorporates the state monad with state s"
10:25:06 <wlad> Gurkenglas: Btw, does "<-" mean "unwrap"? I saw it being used to perform IO, but I can't quite  generalize its usage
10:25:29 <geekosaur> secretly it means >>=
10:25:50 <Gurkenglas> <- is a syntax element of do notation. do x <- foo; bar x is desugared to foo >>= bar
10:25:51 <wlad> Gurkenglas: you mean that it's common for a monad to incorporate another monad?
10:26:04 <geekosaur> whose meaning is defined by the monad, but more or less means "give an "unwrapped" value to the next thing but the next thing has to produce a value in the monad"
10:26:10 <wlad> Oh
10:26:42 <tekkkz> ./Setup --help -> SegFault
10:27:05 <tekkkz> dcoutts, ever ./Setup -> SegFault
10:27:20 <geekosaur> for IO you can't actually get an "unwrapped" value (barring evil things that will not do what you expect if you abuse them) so it kinda acts like a callback hung off an IO "program", that will be invoked if/when the value becomes available in the runtime
10:27:39 <dcoutts> tekkkz: ok, and did you say earlier if this was the only thing that failed, or if this was the first thing you'd tried
10:28:17 <dcoutts> tekkkz: on the face of it it looks like your ghc install is completely borked. You can try compiling a HelloWorld.hs and see if that also segfaults.
10:28:36 <wlad> geekosaur: do you know how does unmanagedIO and "trace" tie into this?
10:29:51 <geekosaur> wlad, see comment about "barring evil things..."
10:30:23 <geekosaur> there is a way to force IO actions to be done in pure code. but because they are in pure code, you do not control when they happen and they almost certainly will not happen when you expect them to
10:31:30 * geekosaur looks at the glib thing, suddenly wonders
10:31:45 <nexsja> Guys, is there somewhere a list of all built in functions?
10:31:46 <wlad> That's why you would use them strictly for debugging purposes? I mean, I somewhat (ab)used trace in my code and it exhibited strange interference with "normal" IO  
10:31:50 <geekosaur> so, with xmonad we found that under 7.10.3 getArgs behaves a bit inconsistently
10:31:59 <nexsja> I'm hoping I can intuitively (by name) find stuff I need :))
10:32:22 <nexsja> Or, at least, a detailed explanation on each function
10:32:37 <wlad> geekosaur: are you using xmonad?
10:32:43 <sm> nexsja: https://hackage.haskell.org/package/base is a good place to start
10:32:53 <nexsja> Thank you
10:33:01 <Gurkenglas> (And this one is for StateT s Maybe: http://sketchtoy.com/66462297 )
10:33:44 <geekosaur> wlad, yes. for trace, it happens when the valu is first demanded and then the result may be memorized if it is bound, so you can track when it is actually demanded. using it a lot, they will interfere with each other *and* with normal IO because the IO monad is what enforces sequencing and you're not using the IO monad
10:33:48 <geekosaur> wlad, I'm one of the devs...
10:34:10 <geekosaur> nexsja, you might be interested in hoogle and hayoo
10:34:18 <geekosaur> @hoogle
10:34:19 <lambdabot> No query entered
10:34:20 <lambdabot> Try --help for command line options
10:34:26 <geekosaur> whoops
10:34:27 <sm> nexsja: well, actually start with the "Prelude" module. The rest are modules you can import without installing more things
10:34:32 <geekosaur> @where hoogle
10:34:32 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle â€“ See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
10:34:43 <nexsja> I'm gonna try my luck
10:34:45 <nexsja> @filter
10:34:45 <lambdabot> Unknown command, try @list
10:34:48 <nexsja> okay
10:34:53 <nexsja> @list
10:34:53 <lambdabot> What module?  Try @listmodules for some ideas.
10:34:59 <nexsja> Damn it
10:35:24 <puregreen> @hoogle filter
10:35:25 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
10:35:25 <lambdabot> Data.List filter :: (a -> Bool) -> [a] -> [a]
10:35:25 <lambdabot> Data.ByteString.Char8 filter :: (Char -> Bool) -> ByteString -> ByteString
10:35:33 <geekosaur> there is no simple list, although if you build hoogle locally you can make a hoogle database that would be a flattish list
10:35:34 <wlad> geekosaur: wow, nice. I lurked on /r/unixporn and saw pretty nice tiled setups, but didn't know any Haskell at all. Maybe I'll give it a try one day :)
10:35:53 <nexsja> Found it in stackage
10:35:58 <nexsja> thank you puregreen, geekosaur  :)
10:36:45 <geekosaur> anyway, re getArgs, what we found was that it worked in main but produced an empty list from xmonad's startupHook. I am wondering if something is getting corrupted, such that sometimes you might even get a wild pointer
10:37:53 <geekosaur> (not consistently, someone using debian's 0.11.1 with ghc 7.10.3 said it worked in startupHook, both my xmonad 0.12 / ghc 7.10.3s have it only working in main)
10:38:31 <geekosaur> but that code in xmonad did not change, only the ghc / base version did
10:39:10 <Gurkenglas> wlad, consider returning the String you want to output (or the data needed to generate it) in place of the () currently at the end of my last annotation's line 21. (Then you'd want to use mapM (which is to sequence as foldMap is to fold) instead of mapM_ and runState instead of execState and get out an ([a], s) instead of an s out of it and print the [a] later.)
10:40:16 <nexsja> Quick question. I googled and found http://paste.ee/p/07qow that will help me validate whether a string contains integers only
10:40:35 <nexsja> What I'd like to do is for this to validate ".3" and "3." as valid also
10:40:54 <nexsja> But I'm kind of being stupid. I tried adding different cases to that, but that didn't really help
10:42:29 <wlad> Gurkenglas: I'm thinking of passing it to a call site and doing it there straight from "S" (i.e. parents and costs)
10:42:43 <Ankhers> nexsja: A single case of "." -> True should suffice.
10:43:25 <nexsja> Wow. That was a lot easier that I thought.
10:43:32 <nexsja> Thank you, Ankhers!
10:44:43 <nexsja> Huh. While isNumber works, it doesn't work in context of another function :/
10:44:46 <Ankhers> nexsja: No problem. Just make sure it comes before the ('.':ys) casae.
10:44:55 <nexsja> Yup, exactly where I put it :)
10:45:07 <Ankhers> What do you mean "in context of another function"?
10:45:22 <geekosaur> oh, the code did change. need to yell at someone...
10:50:12 <nexsja> Ankhers, http://paste.ee/p/KYmo6 From what I understand getArg will read the value from IO and return a Double (because return read line :: Double)
10:50:34 <nexsja> And it does for plain numbers, but doesn't act exactly the same for floats
10:53:41 <Ankhers> nexsja: What input are you using that fails?
10:53:55 <nexsja> .3
10:53:56 <nexsja> and 3.
10:54:02 <Cale> nexsja: while I think you might get away with that indentation, it's more usual to indent if/then/else like:
10:54:04 <Cale> if foo
10:54:07 <Cale>   then bar
10:54:09 <Cale>   else quux
10:54:58 <Ankhers> nexsja: because neither of those are technically Floats. You will want to use 0.3 or 3.0
10:55:04 <nexsja> Cale isn't that what I have?
10:55:24 <Cale> nexsja: It looks like the 'then' and 'else' are starting in the same column as the 'if'
10:55:27 <Ankhers> nexsja: You can't use read if you want to interpret those as floats. You will want to create a custom parser.
10:56:00 <Cale> I would usually indent them slightly more, just because they're part of the same if-expression, which is supposed to be all one statement of the containing do-block
10:56:37 <nexsja> Cale gotcha. in the case of getArg... why is there a "do" after else>
10:56:49 <nexsja> ? is getArg at the very bottom a part of that else block then?
10:57:06 <nexsja> Ankhers, got it. That's too complicated for me right now
10:57:11 <Cale> nexsja: Yes, (confusingly, the way that it's indented)
10:57:32 <Ankhers> nexsja: There is another do because you are returning another IO action in the else, and you do multiple things.
10:57:33 <Cale> nexsja: do-expressions serve to glue together multiple IO actions into single combined ones
10:59:18 <nexsja> Guys, you're so much help! Thank you! All I had was "learnyouahaskell.com" - navigating which in understanding certain pieces of code is unbelievably hard.
10:59:45 <Ankhers> @where learnhaskell -- nexsja this might be a little better suited for learning haskell.
10:59:45 <lambdabot> https://github.com/bitemyapp/learnhaskell
11:00:28 <Ankhers> LYAH doesn't have any excersies, which (for me at least) made it harder to learn from.
11:01:30 <mag__> LYAH is more concise 
11:01:59 <mag__> Just reproduce the examples without looking
11:02:13 <mag__> that's more than enough
11:02:16 <nexsja> I feel warm and fuzzy inside
11:02:31 <Ankhers> and that may work for some people. I personally prefer actual exercises.
11:02:49 <nexsja> When I came to C# asking these dumb questions they weren't near as helpful as all of you :)
11:02:51 <tekkkz> dcoutts, hello world works
11:02:59 <nexsja> http://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html this is actually really cool
11:03:40 <dcoutts> tekkkz: here's a suggestion, get your ghc binary from haskell.org. Or if arch makes it easy to rebuild a package from source, try that for ghc.
11:04:09 <tekkkz> hm .. what?
11:04:44 <dcoutts> tekkkz: haskel.org distribute distro-independent binaries
11:04:58 <tekkkz> okay
11:06:31 <Denommus> what is a good library for diffing and patching large files?
11:07:53 <orion> newtype F f a = F { runF :: forall r. (a -> r) -> (f r -> r) -> r } <-- How does this type signature work? If I create a value whose type is F Foo Int using do-notation, how does its type magically change to (a -> r) -> (f r -> r) -> r when runF is used?
11:09:29 <puregreen> orion: runF is a record field
11:09:37 <puregreen> and so an accessor is automatically created for it
11:09:52 <glittershark> is there an arrow-ey way to write \(f, g) (a, b) -> (f a, g b)
11:10:02 <puregreen> similarly, when you say â€œdata X = X {a :: Int}â€, an accessor of type â€œa :: X -> Intâ€ is created
11:10:06 <glittershark> @pl \(f, g) (a, b) -> (f a, g b)
11:10:06 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .))
11:10:30 <glittershark> @pl \(a, b) (f, g) -> (f a, g b)
11:10:30 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. flip id) . flip . (((.) . (,)) .) . flip id)
11:11:40 <glittershark> @hoogle (a -> a', b -> b') -> (a, b) -> (a', b')
11:11:41 <lambdabot> No results found
11:13:11 <Ankhers> @hoogle (a -> a') -> (b -> b') -> (a,b) -> (a', b')
11:13:11 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
11:13:11 <lambdabot> Data.Graph.Inductive.Graph nemap :: DynGraph gr => (a -> c) -> (b -> d) -> gr a b -> gr c d
11:13:20 <wlad> is there a difference between newtype and data?
11:13:34 <glittershark> thx Ankhers 
11:13:49 <Ankhers> weird, haskell.org/hoogle only came up with a single result.
11:13:56 <wlad> only laziness?
11:14:09 <glittershark> wlad: newtypes are free at runtime
11:14:32 <glittershark> and are restricted to only one constructor to make them so
11:14:36 <wlad> What do you mean by "free"?
11:14:43 <glittershark> unwrapped in every possible way
11:14:46 <Ferdirand> they have no runtime overhead
11:14:55 <glittershark> yeah, what Ferdirand said
11:15:03 <glittershark> not free as in free monad, sorry, that was confusing
11:15:31 <wlad> I didn't think of free monad, I'm just trying to figure out how "data" would not be free in this regard
11:15:51 <glittershark> all data types allocate a data structure
11:16:04 <glittershark> that contains either pointers to the values, or the values themselves
11:16:22 <glittershark> also constructing and deconstructing data types is a function call
11:16:28 <Ferdirand> whereas with newtype, you get the same representation as the underlying type, the difference exists only in the type system
11:16:34 <glittershark> yep
11:16:55 <Ferdirand> and construction and destruction of newtypes are no-ops at runtime
11:17:23 <wlad> Something similar to inlining?
11:17:37 <glittershark> even better
11:17:40 <glittershark> they literally go away
11:17:43 <Ferdirand> it's not just an optimization
11:17:55 <glittershark> yeah, the memory layout is literally identical
11:18:12 <orion> puregreen: Sure, but consider this code: https://gist.github.com/centromere/0c128b9d95177932d7f9 What is the relationship between msgPattern and (a -> r) -> (f r -> r) -> r ? http://hackage.haskell.org/package/free-4.12.1/docs/Control-Monad-Free-Church.html#t:F
11:18:25 <orion> How does this strange type come in to play?
11:18:35 <nexsja> What does <- mean?
11:19:09 <glittershark> nexsja: do { a <- foo; bar a } is syntactic sugar for foo >>= \a -> bar a
11:19:11 <nexsja> as in, [ something here | x <- something ]
11:19:16 <glittershark> oh
11:19:21 <glittershark> not in do notation, in list comprehensions
11:19:22 <wlad> data Animal = Cat String vs newtype Animal = Cat String. What do you mean by "underlying type" here?
11:19:39 <glittershark> wlad: in that case it'd be the String
11:19:53 <glittershark> nexsja: in lilst comprehensions, <- is "for all in"
11:20:00 <Ferdirand> well list comprehensions are semantically equivalent to do notation over the list monad, I think
11:20:06 <glittershark> yeah, that too
11:20:06 <wlad> So newtype ignores construction and just emits "String"?
11:20:11 <puregreen> orion: msgPattern has the type â€œ(Int -> r) -> (HandshakePatternF r -> r) -> râ€ wrapped in a newtype
11:20:21 <glittershark> wlad: except that the typechecker doesn't consider them equivalent the way it does for `type`
11:20:26 <nexsja> print ([(n, 2^n) | n <- [0..19]])
11:20:28 <nexsja> this explained it
11:20:32 <jewels> Hi there. I've described the problem directly in the code that you can find here: http://lpaste.net/148950  Please can you help me to solve it? I'm new to Haskell so it is really hard for me to understand how to design this kind of concept in an elegant way.
11:20:36 <puregreen> and you can use runF to unwrap it
11:20:55 <wlad> glittershark: "type" meaning "data"?
11:21:01 <wlad> or "newtype"?
11:21:22 <glittershark> no, "type" meaning the `type` keyword
11:21:25 <glittershark> which introduces type aliases
11:21:27 <wlad> Oh, righjt
11:21:30 <wlad> Yes, right
11:21:38 <wlad> Thanks
11:21:44 <glittershark> (y)
11:24:33 <orion> puregreen: When did that value become wrapped?
11:25:18 <puregreen> orion: that value is generated by functions â€œinitiatorâ€, â€œresponderâ€, and â€œsplitâ€
11:25:30 <puregreen> well, and (>>=) that composes them together
11:25:51 <MatthiasHu> What is a good symbol for "chronological" function composition, i.e. flip (.) ?
11:26:00 <puregreen> when it's generated it's already wrapped
11:26:05 <orion> According to ghci: initiator :: Control.Monad.Free.Class.MonadFree HandshakePatternF m0 => Token -> m0 ()
11:26:25 <jewels> Anyway the problem for this code: http://lpaste.net/148950 is at line 52
11:29:46 <jewels> Nobody can help me with this code?
11:31:20 <puregreen> orion: here's the code that gets generated by TH: http://lpaste.net/148951
11:32:00 <puregreen> here's the definition of liftF: â€œliftF = wrap . fmap returnâ€
11:32:25 <byorgey> jewels: what exactly is the problem?  Why can't you write  Lattice.bottom there?
11:33:35 <orion> puregreen: What instance does return belong to in that case?
11:34:05 <puregreen> orion: no idea, I think the wrapping here is done by wrap and not return
11:34:28 <puregreen> orion: in particular, wrap is a method and in this case the definition is here: http://hackage.haskell.org/package/free-4.12.1/docs/src/Control-Monad-Free-Church.html#line-138
11:34:46 <puregreen> and that's finally where we see F applied to something
11:35:04 <puregreen> so, that's the origin of value generation/wrapping
11:35:42 <orion> "wrap f = F (\kp kf -> kf (fmap (\ (F m) -> m kp kf) f))" sweet jesus
11:36:01 <puregreen> sorry, can't help with that
11:36:05 <byorgey> jewels: also, I don't understand what ZadehMembership and PAMembership have to do with the definition of mu
11:36:08 <puregreen> seeing free monads for the first time
11:36:21 <orion> puregreen: Me too. :)
11:37:26 <orion> I have an unfortunate character flaw where I hate using tools I don't sufficiently understand, which makes writing a DSL using Free Monads + Church encoding quite aggravating.
11:38:24 <orion> I have no where near the math/CS knowledge necessary to comprehend what I'm doing.
11:38:46 <capisce> everything can be learned
11:38:47 <byorgey> orion: I think that is probably false
11:39:39 <byorgey> Tree monads + church encoding take a while to grok, no matter what your background.  Conversely they don't actually require much specific background.
11:39:44 <byorgey> er, free monads.
11:40:01 <shachaf> Well, "Tree monad" is pretty descriptive too.
11:40:07 <byorgey> true!
11:40:57 <shachaf> i,i cotree comonad
11:41:58 <byorgey> the comonad of things on which you can hang your cot and hat
11:43:59 <MatthiasHu> Is there a common symbol for flip (.) that is not used otherwise by Control.Lens? :-)
11:44:31 <byorgey> MatthiasHu: Control.Arrow.>>>
11:44:33 <glittershark> @hoogle (a -> b) -> (b -> c) -> a -> c
11:44:33 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
11:44:34 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
11:44:34 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> (a -> c)
11:44:51 <glittershark> :t (>>>)
11:44:52 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
11:44:57 <byorgey> actually I guess it is from Control.Category, and re-exported from Control.Arrow
11:45:10 <byorgey> ^^^ the above type may look forbidding, just replace 'cat' with (->) everywhere
11:45:15 <glittershark> yep
11:45:22 <jewels> byorgey: I want to define a FuzzySet that has a generic Lattice as a membership value. If the mu function is applied to a FuzzySet with ZadehMembership, then it should return the Zadeh lattice's bottom, a PA lattice's bottom otherwise.
11:45:24 <glittershark> and ignore the bit between `forall` and `.`
11:45:36 <glittershark> it matters, but not as far as you're concerned
11:45:55 <nexsja> are mathematical operators considered functions in haskell?
11:46:00 <glittershark> yes
11:46:03 <glittershark> :t (+)
11:46:04 <lambdabot> Num a => a -> a -> a
11:46:23 <Denommus> uh
11:46:36 <MatthiasHu> thx all. then i'll probably settle for (>>>), though it seems a little long for such a fundamental operation ;-)
11:46:45 <Denommus> is there anything like bash's cmp in Haskell (that compares two IO String or two IO ByteString)?
11:46:54 <nexsja> thanks, was curious because you could do (+) 5 3 
11:46:55 <nexsja> and get a result
11:46:59 <glittershark> > "abc" < "bca"
11:47:01 <lambdabot>  True
11:47:23 <glittershark> "abc" `compare` "bca"
11:47:49 <byorgey> jewels: that doesn't make sense.  In Haskell you can't do things like "if such-and-such return this type, else return this other type"
11:48:09 <byorgey> jewels: however, you certainly can say "return an element of whatever lattice corresponds to this FuzzySet"
11:48:13 <glittershark> Denommus: if they're in IO, you can just `(>) <$> string1 <*> string2`
11:48:17 <byorgey> which is what the type of mu currently says.
11:48:26 <byorgey> and it should be fine to just say   Nothing -> Lattice.bottom
11:48:37 <byorgey> it will pick the right lattice based on the type of the FuzzySet.
11:49:37 <Denommus> glittershark: hm. I was talking about bash cmp, but I think that'll do
11:49:46 <glittershark> Denommus: there's also `compare`
11:49:55 <glittershark> > "abc" `compare` "bca"
11:49:57 <lambdabot>  LT
11:50:13 <byorgey> Denommus: in what sense do you want something "like" bash's cmp?
11:51:16 <jle`> nexsja: you can also define your own operators, like normal functions
11:51:18 <byorgey> a related question is, what should the type be of the thing you want?
11:51:22 <Denommus> byorgey: cmp is basically liftA2 (/=)
11:52:17 <byorgey> Denommus: OK, so is  liftA2 (/=)  not what you want?
11:52:46 <Denommus> byorgey: yes
11:55:31 <dzdncnfzd> If I have a type Foo and an instance of fromJSON Foo (:t fromJSON :: Alternative f => Value -> f a) is there a way of applying fromJSON to a Bytestring without using decode?
11:55:36 <dzdncnfzd> (this is in Aeson)
11:56:39 <drdo> dzdncnfzd: What do you want to do?
11:56:50 <Denommus> Haskell package management with Nix is so great
11:57:30 <dzdncnfzd> drdo: I'm parsing JSON and using it to construct a list of a custom datatype
11:57:51 <Ankhers> dzdncnfzd: What is your reason for not using decode?
11:57:53 <byorgey> dzdncnfzd: decode will automatically call fromJSON for you
11:57:57 <drdo> dzdncnfzd: So do you just want fromJSON . decode?
11:58:12 <byorgey> decode == fromJSON . decode !
11:58:18 <dzdncnfzd> drdo: I'm getting an error when I try to decode the JSON using eitherDecode, and google informs me that I need a type hint
11:58:32 <dzdncnfzd> decode gives a value, right?
11:58:33 <drdo> byorgey: Yeah, I thought it returned a Value since he was asking
11:58:39 <Gurkenglas> There should be MonadIO m => X -> StateT s m a -> m a for some identifier type X so you can more purely handle something like IORefs in IO callbacks
11:58:42 <Ankhers> decode someString :: Foo
11:59:07 <byorgey> dzdncnfzd: the type of decode is   FromJSON a => ByteString -> Maybe a
11:59:17 <byorgey> dzdncnfzd: it can give not just Values, but any type which is an instance of FromJSON
11:59:27 <Ankhers> You need to tell the type system what you are getting out of decode. Because decode makes values of a bunch of different types.
11:59:55 <dzdncnfzd> Ahhhh, I see!
12:00:02 <dzdncnfzd> Thanks! I hadn't caught that.
12:00:17 <Ankhers> :t Data.Aeson.decode
12:00:19 <lambdabot> aeson-0.9.0.1:Data.Aeson.Types.Class.FromJSON a => BSLC.ByteString -> Maybe a
12:00:48 <Ankhers> decode someString :: Maybe Foo
12:00:58 <Ankhers> I think that is what you are looking for.
12:03:34 <t0by> Hi, I'm doing some exercises from Homework 3 of http://www.seas.upenn.edu/~cis194/, which was suggested on this chan. I believe they are correct, however, I don't like how they turned out, they seem... ugly, especially since the title of the assignment is "Code Gold". I wouldn't know how to further improve them, though. Can anybody give me a hint or two? http://lpaste.net/148953
12:04:31 <t0by> (I see lpaste is giving me some suggestions on its own.)
12:06:17 <jle`> t0by: if you use length and !! and drop together and separately, that's usually a sign that you're doing some redundant stuff
12:06:53 <jewels> byorgey: Actually I'm not sure how to define it properly. Maybe can you help me?
12:07:02 <t0by> jle`, I don't *especially* like !!
12:07:48 <jle`> t0by: try splitAt
12:07:58 <jle`> it's like a combination of take and drop
12:08:06 <jle`> and you can pattern match instead of doing a length check
12:08:28 <jewels> byorgey: All the function defined on the fuzzy set should not depend on the specific Lattice because there are the operators defined in Algebra.BoundedLattice that I can use.
12:08:30 <t0by> jle`, how would I pattern match for a given n?
12:08:46 <jle`> t0by: pattern match on the result of `splitAt`
12:08:54 <jle`> > splitAt 5 "hello world"
12:08:55 <lambdabot>  ("hello"," world")
12:09:13 <jle`> > splitAt 20 "hello world"
12:09:15 <lambdabot>  ("hello world","")
12:09:22 <jle`> you can tell if the length is "too long" if the second list is []
12:10:42 <byorgey> jewels: you should just be able to write   case result of   Nothing -> Lattice.bottom   (Just m) -> m
12:10:45 <byorgey> jewels: does that not work?
12:10:52 <wlad> Guys, I'm doing CIS196 now and stumbled on compiling this example: http://lpaste.net/5277270314240180224
12:11:12 <wlad> There's type in function name when ivoking, but it still doesn't work
12:11:18 <wlad> Any quick tips?
12:11:45 <Ankhers> wlad: What is the error you are getting?
12:11:47 <byorgey> wlad: what is the error?
12:12:01 <wlad>  Couldn't match expected type `Integer' with actual type `[Integer]'
12:12:18 <byorgey> wlad: what is the type of 'hailstone' ?
12:12:49 <wlad> There is no such function, that's why I'm asking. Anyone went through cis 194 that knows what's up?
12:13:03 <wlad> Is this a type or is it defined elsewhere?
12:13:08 <byorgey> wlad: there must be, or else you would get an error saying that 'hailstone' is not defined
12:13:10 <wlad> http://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html
12:13:17 <Ankhers> I don't remember that when going through that course.
12:13:31 <wlad> byorgey: I must've confused you. I changed hailstone to hailstoneSeq
12:13:51 <wlad> Otherwise it's first.hs:3:36: Not in scope: `hailstone'
12:13:53 <ReinH> byorgey: a.k.a. fromMaybe Lattice.bottom :)
12:14:05 <byorgey> ReinH: sure, one thing at a time =)
12:14:10 <ReinH> byorgey: oh ok :)
12:14:11 <byorgey> wlad: aha, well, that would explain it =)
12:14:14 <jewels> byorgey: I initialize the set using: 
12:14:16 <jewels> ype of mu currently says.
12:14:17 <jewels> [20:48:03] <byorgey>
12:14:21 <wlad> Full excerpt: http://lpaste.net/5277270314240180224
12:14:24 <byorgey> wlad: hailstone is a different function
12:14:35 <byorgey> wlad: it is actually defined in the lecture notes
12:14:43 <wlad> byorgey: thanks!
12:14:56 <jewels> byorgey: Sorry. This is the code that I use to initialize the fuzzy set -> let fs = Map.fromList [(1, Z 0.2), (2, Z 0.3)]
12:15:19 <byorgey> jewels: ok
12:15:35 <jewels> byorgey: I call mu in this way -> mu fs 1 and I get mu fs 1 :: ZadehMembership
12:15:46 <byorgey> jewels: makes sense
12:15:57 <Denommus> I want a somewhat complex function that I have no idea how to start doing
12:15:59 <orion> Is there a difference in terms of performance to have a ReaderT wrapping a StateT vs. the other way around?
12:16:01 <obadz> so herm, is it ok for (>>) to "parallellize" when >>= doesn't ? I suppose it means that (>>) could succeed when >>= doesn't ?
12:16:38 <jewels> byorgey: We expect 0.2
12:17:03 <Denommus> I want to pass two directories, and to return a triple. The first element is the files that are in both directories, the second the files that are only in the first directory, and the third the files that are only in the second directory
12:17:07 <byorgey> jewels: you typed  'mu fs 1'  at a ghci prompt?
12:17:09 <Denommus> I don't care about file contents, only names
12:17:11 <byorgey> (without the quotes)
12:17:24 <jewels> byorgey: Yes
12:17:32 <Denommus> also, that should be recursive (that is, go through every child directory)
12:17:36 <byorgey> jewels: and what did it print?
12:17:43 <jewels> mu fs 1 :: ZadehMembership
12:17:51 <byorgey> jewels: it didn't also print   Z 0.2  ?
12:17:58 <jewels> No, mu fs 1 :: ZadehMembership
12:18:07 <byorgey> jewels: are you sure you didn't put  :t  at the beginning of the line?
12:18:40 <Ankhers> Denommus: Build it piece by piece. I would start by building the triple based on the two lists.
12:18:45 <byorgey> mu fs 1 :: ZadehMembership  is the output I would expect if you ask for the *type* of  mu fs 1
12:19:00 <byorgey> but if you ask for it to be *evaluated* it should say   Z 0.2
12:20:24 <Denommus> Ankhers: where can I find FilePath manipulation functions?
12:20:45 <byorgey> Denommus: System.FilePath, from http://hackage.haskell.org/package/filepath
12:20:48 <Denommus> Ankhers: since I need to get rid of the absolute part of the directories
12:20:55 <Denommus> byorgey: thanks
12:21:06 <Ankhers> Denommus: don't worry about FilePath right now. Just build a function like f :: [String] -> [String] -> ([String], [String], [String])
12:21:40 <jewels> byorgey: I've reloaded the file and now it works. Thank you!
12:21:54 <byorgey> jewels: great!
12:25:32 <jewels> byorgey: In this case: http://lpaste.net/148950, I need to match the bottom itself (see 'add' function). Is there a way in order to solve it?
12:25:34 <Denommus> Ankhers: this function is easy to do, the hard part was the makeRelative function
12:25:49 <Denommus> Ankhers: now that I have it, things got easier
12:28:15 <t0by> jle` what about:  everymth n xs = case (splitAt (n-1) xs) of
12:28:16 <t0by>                   (a,[]) -> []
12:28:16 <t0by>                   (a,(b:bs)) -> (b:(everymth n bs))
12:29:09 <t0by> jle`, however, I'm more concerned about the second function
12:40:41 <tekkkz> dcoutts, i removed .cabal / .ghc and reinstalled ghc -> now it worked
12:41:08 <dcoutts> tekkkz: interesting, ok. Perhaps there was some corruption along the way that caused programs to segfault.
12:42:00 <tekkkz> ye. but strange
12:42:07 <tekkkz> whatever, now everything is fine, byebye
12:44:32 <Welkin> whenever I start a new yesod project using stack, I always have to reinstall yesod-bin
12:44:53 <Welkin> what if there is a conflict between the different versions of yesod-bin?
12:45:15 <Welkin> it overwrites the old one, and it must be on my path
12:45:35 <Welkin> I haven't run into problems yet, but I can imagine it becoming a potential issue
12:50:17 <Ankhers> Welkin: stack installs things into its own sandbox based on the lts haskell version you tell it to use. There should never be conflicts with various versions of the same package.
12:52:14 <geekosaur> except executables, such as the one from yesod-bin, go to ~/.local/bin
12:52:23 <isu> Hi everyone! Is this the right place to ask about wai?
12:52:25 <Welkin> Ñ‹ÐµÑ
12:52:30 <Welkin> Ñ‹ÐµÑÐ¾Ð´ÑŒÐ±Ð¸Ð½ Ð¸Ñ Ð°Ð½ ÐµÑ…ÐµÑ†ÑƒÑ‚Ð±Ð°Ð»
12:52:33 <Welkin> er
12:52:34 <Welkin> yes
12:52:40 <Welkin> yesod-bin is an executable, not a library
12:53:04 <geekosaur> isu,more or less, yes. ask and if someone knows they will answer, or point you elsewhere (possibly a mailing list)
12:53:08 <Ankhers> Oh, I thought the executables were somehow versioned there...
12:53:26 <geekosaur> cabal sandboxes put executables int he sandbox. stack doesn't
12:53:33 <Ankhers> Indeed.
12:53:58 <geekosaur> ironically this means stack does what ius expected for most packages with execcutables but cabal does what's right for yesod...
12:54:42 <Welkin> I am disappointed this morning because installing a new yesod project is taking forever
12:54:49 <Welkin> big changes in the new stack lts
12:54:55 <Ankhers> I think `stack exec yesod` would run the correct version, but that is a little cumbersome.
12:54:58 <Welkin> so most packages are new versions
12:55:01 <Welkin> oh well
12:55:13 <Welkin> no Ankhers it doesn't
12:55:16 <Welkin> that is the problem
12:55:18 <Ankhers> really?
12:55:20 <Welkin> it just looks on the path for it
12:55:25 <Welkin> stack exec -- yesod devel
12:55:26 <Welkin> yeah
12:56:14 <Welkin> of course, there is also a solution using symlinks and bash scripts and weird shit
12:56:19 <Welkin> which I don't like
12:56:27 <Ankhers> yeah, that is too manual though.
12:56:43 <Ankhers> bug ticket?
12:56:54 <jewels> In this code: http://lpaste.net/148950, when I call the mu function in some cases Lattice.Bottom is called. How does the interpreter know that it should call bottom from ZadehMembership or PAMembership respectively?
12:57:29 <isu> Just started learnig haskell. Out of curiosity, why responseFile :: Status -> ResponseHeaders -> FilePath -> Maybe FilePart -> Response, but not responseFile :: Status -> ResponseHeaders -> FilePath -> Maybe FilePart -> IO Response . Isn't the responseFile goes out in the real world and asks the OS to send some data?
12:57:45 <isu> Or am i missing something&
12:58:56 <cocreature> isu: that doesnâ€™t actually perform the request, it just creates a Response object containing the data you passed in
12:59:10 <cocreature> take a look at the source here https://hackage.haskell.org/package/wai-3.0.5.0/docs/src/Network-Wai.html#responseFile and here https://hackage.haskell.org/package/wai-3.0.5.0/docs/src/Network-Wai-Internal.html#Response
12:59:28 <Gurkenglas> jewels, from the context - once it knows where the function is used (and thus what type is required), it does the same thing that, say, minBound does
12:59:38 <ReinH> isu: responseFile constructs a Response by simply passing its parameters to the ResponseFile constructor, which is not exported.
12:59:42 <Gurkenglas> > (minBound :: Int, minBound :: Bool)
12:59:43 <lambdabot>  (-9223372036854775808,False)
12:59:52 <ReinH> isu: It does not actually read any files, it just saves the filepath and other args for possible later use
13:01:05 <ReinH> isu: you can look at responseToStream to see how these arguments are used later to actually perform IO
13:02:02 <ReinH> Oh, cocreature said that.
13:02:04 <lyxia> jewels: when you call it you are expected to instantiate the type m with something, such as ZadehMembership or PAMembership
13:03:39 <jewels> lyxia: But I'm not able to do pattern matching on it in any way because the call to Lattice.bottom will be ambiguous?
13:05:30 <lyxia> jewels: You can't pattern match on a value of type m because you don't have access to its constructors, as it is an abstract type<
13:05:42 <lyxia> s/</.
13:05:43 <isu> Oh, I see, silly me) Haven't looked in sources. Thank you all!
13:05:58 <cocreature> ReinH: repeating things is supposed to be a good way to do indoctrination so it might be important for achieving world domination
13:07:43 <t0by> Hi, I'm doing some exercises from Homework 3 of http://www.seas.upenn.edu/~cis194/, which was suggested on this chan. Can anyone please suggest how to improve cleanliness-wise and make more idiomatic the function localMaxima in http://lpaste.net/148958 ? 
13:07:43 <jewels> lyxia: So I'm not able to implement the add function? Have a look here: http://lpaste.net/148959
13:08:35 <ReinH> cocreature: :)
13:08:52 <ReinH> cocreature: repeating things improves knowledge acquisition.
13:08:57 <ReinH> cocreature: so it is useful to repeat things
13:09:03 <ReinH> beacuse repeating things improves knowledge acquisition
13:09:11 <lyxia> jewels: where do you get BottomVal?
13:09:19 <cocreature> :)
13:09:44 <Ankhers> t0by: (a:b:c:xs) is the same as what you have.
13:10:16 <Ankhers> t0by: Also, you really onlt need that case, and a case that catches everything else to empty list.
13:10:44 <jewels> lyxia: I haven't it. It should be equal to Lattice.bottom.
13:11:04 <jewels> lyxia: But for the reasons that you have explained I'm not able to use it in this context!
13:11:06 <jewels> Right?
13:11:17 <jewels> lyxia: So what can I do?
13:11:50 <lyxia> jewels: I'd add an Eq constraint on m, and use (==)
13:13:45 <sk8dev> clear
13:13:50 <sk8dev> ups, sry
13:14:35 <jewels> lyxia: Thank you so much. You've saved my life :)
13:15:21 <jewels> lyxia: Can you explain to me why it works?
13:15:33 <jewels> lyxia: it seems magic :)
13:17:00 <koala_man> where in a cabal file do you specify the dependencies for your Setup.hs?
13:17:32 <dcoutts> koala_man: custom-setup, but this is a new feature in Cabal-1.24 which is going to be released RSN
13:18:04 <lyxia> jewels: Eq m simply means that values of type m can be compared for equality
13:18:23 <dcoutts> koala_man: custom-setup section, field setup-depends:
13:18:36 <koala_man> nice, too bad it's not out yet
13:18:48 <jewels> lyxia: This is clear. Why is it able to understand that it can call Lattice.bottom?
13:18:59 <jewels> lyxia: I really don't understand it. 
13:19:04 <mgsloan> Welkin: Ankhers: When you "stack build" a package, the executables get installed to the sandbox, such that it's available via "stack exec"
13:19:37 <koala_man> dcoutts: is there a current workaround? can I just specify it as a build-dependency to have it automatically installed before my package is?
13:20:06 <mgsloan> So if you want sandbox-local executables, that's the way to do it.  "stack install" is just an alias for "stack build --copy-bins" - i.e. build and then copy the binaries from the sandbox into ~/.local/bin
13:20:44 <dcoutts> koala_man: that'll often work
13:20:55 <t0by> Ankhers, d'oh. Thank you.
13:21:04 <Ankhers> mgsloan: How do you go about calling the proper executable?
13:21:07 <koala_man> when will it not? how unlikely is it that ghc is installed but 'process' is not?
13:21:08 <lyxia> jewels: the variable m has type m, and then when you write m == bottom, the type of (==) :: Eq a => a -> a -> Bool tells the compiler that bottom must have the same type.
13:21:34 <dcoutts> koala_man: oh if it's just process you're talking about then there's no problem at all
13:21:48 <koala_man> why is that? 
13:21:49 <mgsloan> Ankhers: "stack exec" modifies your PATH to include executables installed to the sandbox + snapshot
13:22:08 <mgsloan> Ankhers: "stack path --bin-path" will tell you the value it uses for PATH
13:22:25 <Ankhers> mgsloan: Interesting. Thanks!
13:22:33 <koala_man> currently I'm having a problem of depending on process-1.2.0.0+ which completely breaks on 7.6.3 (debian stable)
13:22:44 <lyxia> jewels: so bottom has type m, and using this requires that m be an element of a bounded join semi lattice, which it deduces from m being an instance of BoundedLattice.
13:22:46 <Welkin> mgsloan: really? if so, that is nice
13:22:48 <koala_man> so I want to rewrite it to work on 1.1.0.0+
13:23:02 <Welkin> mgsloan: although it also copies the latest ones to ~/.local/bin
13:23:04 <t0by> Ankhers, but "Non-exhaustive patterns in function localMaxima"
13:23:19 <t0by> Ankhers, I have localMaxima [] = []
13:23:20 <t0by> localMaxima (a:b:c:xs)
13:23:20 <t0by>     | (a <= b) && (c <= b) = b:(localMaxima(c:xs))
13:23:20 <t0by>     | otherwise               = localMaxima(b:(c:xs))
13:23:59 <kadoban> t0by: You're not handling lists that are 1 element or 2 elements long.
13:24:00 <Ankhers> mgsloan, Welkin: It appears to prepend the snapshot location to my path, which should mean using stack exec should use the sandboxed copy.
13:24:11 <mgsloan> Yep
13:24:49 <jewels> lyxia: Ok perfect. Thank you for your answer!
13:24:50 <Ankhers> t0by: You don't need the [] case, just use the catch call (_) after your 3 element case.
13:25:20 <Ankhers> mgsloan: Thanks for the tips.
13:25:23 <t0by> Ankhers, you mean localMaxima (a:b:c:xs)
13:25:23 <t0by>     | (a <= b) && (c <= b) = b:(localMaxima(c:xs))
13:25:23 <t0by>     | _ = []
13:25:36 <Ankhers> t0by: That should work, yes.
13:25:49 <Ankhers> wait no
13:25:53 <t0by> Ankhers, output needs to be e.g. localMaxima [2,9,5,6,1] == [9,6]
13:26:00 <Ankhers> I misread that. One sec. Let me create a quick paste.
13:26:21 <t0by> Ankhers, whatever element in list is greater than its left AND right neighbors
13:26:22 <t0by> Ankhers, thanks
13:27:20 <SavinaRoja> has anyone ever encountered a solid technique for mapping Unicode point -> (KeyEvent, Context)
13:27:37 <SavinaRoja> in any OS... I have come to hate keyboards
13:27:47 <Ankhers> t0by: Something like this http://lpaste.net/148961 (assuming your logic is correct, I just copied it without checking)
13:28:47 <lyxia> line 3 is localMaxima (a : xs) = localMaxima xs
13:29:00 <t0by> Ankhers, Non-exhaustive patterns in function localMaxima
13:29:18 <t0by> As kadoban said, that's not handling 1- and 2- element long lists, is it?
13:29:18 <lyxia> ah mine's actually exhaustive
13:29:19 <Ankhers> Welkin: If you don't want them copied to ~/.local/bin, just use a stack build, not stack install.
13:29:28 <Ankhers> t0by: Sorry, localMaxima _ = [] for line 4.
13:30:03 <Ankhers> lyxia: is that in regard to my paste?
13:30:14 <t0by> D'oh-oh-oh-oh.
13:30:23 <t0by> Ankhers, thank you. I should have tought of _
13:30:23 <lyxia> Ankhers: yes
13:30:26 <t0by> *though
13:30:27 <t0by> *thought
13:30:30 <t0by> *grr
13:30:37 <Ankhers> lyxia: They mean different things though.
13:30:58 <Ankhers> lyxia: While yes, it is effectively that, your version did not do the logic check to see if b is larger than a and c.
13:31:16 <lyxia> well it did because line 1 is before line 3
13:31:44 <Ankhers> lyxia: Then what are you doing if b is not larger than a and c in your check?
13:32:21 <Ankhers> lyxia: Can you paste your version?
13:33:17 <lyxia> > let f x | False = False ; f x = x in f False
13:33:19 <lambdabot>  False
13:33:21 <ReinH> SavinaRoja: Why do you want to map *from* unicode code points, what is KeyEvent, what is Context?
13:33:43 <lyxia> Ankhers: if no guard match, the next rule is still applied
13:34:12 <Ankhers> Oh, that I didn't know.
13:35:48 <Cale> Yeah, it makes the translation of guards a little less trivial than it would otherwise be.
13:35:58 <Cale> (into case expressions)
13:36:17 <lyxia> > let   lmax (a : b : xs@(c : _)) | a <= b && b >= c = b : lmax xs   ;   lmax (_ : xs) = lmax xs   ;   lmax [] = []   in lmax [2,9,5,6,1]
13:36:19 <lambdabot>  [9,6]
13:36:57 <SavinaRoja> ReinH: I used those terms broadly because it is not specific to any particular system. when keyevents occur, they are interpreted in a machine state context to map to something (like a character)
13:37:32 <Fuco> is it good idea to use MVar as a semaphore or are there better "primitives" for that?
13:37:54 <ReinH> SavinaRoja: but you said the opposite.
13:38:04 <Fuco> what I do now is: takeMVar sem; action; putMVar sem ()
13:38:04 <SavinaRoja> SavinaRoja: I've been wrestling mentally for ages to figure out a reliable way to conduct the process in reverse
13:38:19 <ReinH> ah
13:38:21 <SavinaRoja> ReinH: ^
13:38:48 * hackagebot bini 0.1.0 - A manipulation library for b(inary)ini files used in windows programms like the game Freelancer.  https://hackage.haskell.org/package/bini-0.1.0 (TWeise)
13:39:20 <monochrom> MVar is a good semaphore. it can do more, if you can think up more.
13:39:51 <Fuco> monochrom: but I don't need more, I just need my text output to not cross each other right now :D
13:39:52 <geekosaur> SavinaRoja, in general you can't
13:40:43 <geekosaur> for example, in X11 you can only do it if the codepoint corresponds to something in the loaded Xkb configuration
13:41:36 <geekosaur> and even then things get tricky if you need to switch ISO level or use modifiers to get to it, because you can't reliably reconstruct those from a string to a keysym
13:41:36 <Enigmagic> Fuco: that pattern isn't exception safe though
13:41:43 <SavinaRoja> the only way I can see working is to exhaustively compose your own tables of codes, states, and layouts. then lookup
13:42:51 <geekosaur> ...and "exhaustively compose your own" tends to lose hard as soon as someone with a different international keyoard layout tries to use your program
13:43:06 <SavinaRoja> as best I can tell, nobody in x11/xkb or windows has addressed this nightmare before
13:43:21 <geekosaur> you're not *supposed* to do it
13:43:23 <SavinaRoja> geekosaur: indeed
13:43:25 <geekosaur> why do you think you need it?
13:44:06 <chrisdotcode> you know, "cannot construct the infinite type" would be a good band name
13:44:47 <Enigmagic> Fuco: probably want to use something like `bracket (takeMVar sem) (putMVar sem) action`
13:45:00 <SavinaRoja> geekosaur: a project I work on, virtualizing user input events cross-platform
13:45:34 <Fuco> Enigmagic: right, bracket ensures I restore the mvar
13:45:54 <geekosaur> um. good luck with that, then. I think the closest thing to cross-platform there cheats by only controlling web browsers
13:45:57 <SavinaRoja> unifying the interface to just feed it unicode seems like the dream
13:46:54 <Enigmagic> Fuco: exactly... saves you a lot of trouble tracking down BlockedOnMVar exceptions later down the road ;-)
13:47:00 <t0by> Ankhers, thank you so much.
13:47:05 <SavinaRoja> yeah, I'm going to have to settle
13:47:10 <jaaket> idris
13:47:22 <jaaket> whoops, sorry
13:48:30 <geekosaur> SavinaRoja, it's support for international keyboards etc. that makes this impossible to support in the general case; any mapping you come up with *will* be incompatible with someone's keyboard layout and therefore won't map properly
13:49:48 <Welkin> you can either map to physical layout
13:49:57 <Welkin> or you can map to particular characters
13:50:03 <Welkin> keycode vs scancode
13:54:07 <gabbiel> "main :: IO"
13:54:49 <shanemikel> do y'all know any tricks for locating the distro package names of pkgconfig deps?
13:55:59 <Pamelloes> Is there a reason why %Z in parseTimeM doesn't accept a positive timezone e.g. 10:22:30+01:00 doesn't match %H:%M:%S%Z
13:56:23 <Pamelloes> But a negative timezone (10:22:30-01:00) matches without any issues
13:57:04 <geekosaur> Welkin, at least on X11 you need to do something "expected" for both, or your program will work with some things or not others (notably vmplayer and vncviewers will handle quick and dirty mappings *badly*)
13:57:19 <geekosaur> probably also rdesktop
13:58:17 <geekosaur> and vbox for that matter
13:59:07 * hackagebot clash-prelude 0.10.5 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-0.10.5 (ChristiaanBaaij)
13:59:09 * hackagebot clash-lib 0.6.8 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.8 (ChristiaanBaaij)
13:59:11 * hackagebot clash-systemverilog 0.6.4 - CAES Language for Synchronous Hardware - SystemVerilog backend  https://hackage.haskell.org/package/clash-systemverilog-0.6.4 (ChristiaanBaaij)
13:59:13 * hackagebot clash-verilog 0.6.4 - CAES Language for Synchronous Hardware - Verilog backend  https://hackage.haskell.org/package/clash-verilog-0.6.4 (ChristiaanBaaij)
13:59:15 * hackagebot clash-vhdl 0.6.5 - CAES Language for Synchronous Hardware - VHDL backend  https://hackage.haskell.org/package/clash-vhdl-0.6.5 (ChristiaanBaaij)
13:59:26 <geekosaur> also most programs look at the keysym but a few (like vmplayer/vbox) only use the keycode
13:59:46 <hpc> is there an alternate version of the clash prelude for the doors?
13:59:48 <Welkin> oh cool
13:59:58 <Welkin> the new yesod scaffolding comes with an ajax comment system example
13:59:59 <Welkin> haha
14:03:05 <glguy> Pamelloes: Prelude Data.Time> parseTimeM False defaultTimeLocale "%H:%m%Z" "10:20+0200" :: Maybe ZonedTime
14:03:06 <glguy> Just 1970-12-01 10:00:00 +0200
14:03:18 <glguy> Pamelloes: Seems like it works
14:03:28 <Pamelloes> huh
14:03:49 <glguy> (should have used %M, but same effect)
14:04:07 * hackagebot clash-ghc 0.6.8 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.8 (ChristiaanBaaij)
14:05:14 <Pamelloes> Oh. I'm an idiot. "+" needs to be escaped in a url while - doesn't
14:05:29 <Pamelloes> So the time parsing works fine :)
14:18:33 <spindas> object light level
14:19:07 * hackagebot bini 0.1.1 - A manipulation library for b(inary)ini files used in windows programms like the game Freelancer.  https://hackage.haskell.org/package/bini-0.1.1 (TWeise)
14:27:32 <argoneus> anyone had luck making a binding to a C++ library with classes and using it?
14:27:44 <argoneus> I found something called fficxx which seems like it does what I want it to but it doesn't really have a tutorial
14:29:08 * hackagebot bini 0.1.2 - A manipulation library for b(inary)ini files used in windows programms like the game Freelancer.  https://hackage.haskell.org/package/bini-0.1.2 (TWeise)
14:30:50 <testtest> Hello, sorry, but I've got a question: What the hell are monads? I mean it sounds kinda like different classes in Java or like functions, but at the same time, they sound really, really confusing. What is the actual definition for what one is? So far I've had a hard time finding a source that actually said, as bluntly as possible for unintelligent people such as myself, what a monad is. Can anyone help?
14:31:06 <Phyx-> lol, that bini package sure iterated fast
14:31:21 <Fuco> testtest: what you ask is impossible
14:31:41 <argoneus> testtest: I went through the same thing a few weeks ago
14:31:46 <argoneus> listen here
14:31:49 <testtest> Fuco: Oh, sorry then
14:31:52 <argoneus> start writing some haskell code, write things
14:32:05 <argoneus> eventually you will realize you are duplicating code or that you would like if you could represent a piece of code generally
14:32:11 <argoneus> then you realize what you need is monads
14:32:20 <argoneus> ...and that's what monads are
14:32:24 <testtest> argoneus: Isn't that just what functions are?
14:32:38 <argoneus> not really
14:32:40 <argoneus> just write stuff, trust me
14:32:41 <Fuco> well monads are functions
14:32:46 <Fuco> everything is a function in haskell
14:32:54 <frerich> Err
14:32:56 <glguy> Fuco: No, that's not the case
14:33:02 <frerich> x = 5 -- not a function
14:33:10 <Enigmagic> x = 5 could be a function
14:33:11 <Fuco> why not
14:33:30 <dzdncnfzd> This is your daily reminder to despise python.
14:33:30 <Fuco> 5 is a constant function returning 5
14:33:31 <Enigmagic> x = (5 :: Int) -- not a function
14:33:32 <frerich> A function is something you can apply to other values. In particular, to exactly one value.
14:33:33 <notdan> But it's not
14:33:36 <testtest> Sorry to have created a debate
14:33:38 <notdan> Fuco: not really
14:33:40 <argoneus> testtest: anyway, it's pointless to learn monads for the sake of learning monads
14:33:41 <glguy> Fuco: Conal wrote a nice starting point for this question http://conal.net/blog/posts/everything-is-a-function-in-haskell
14:33:43 <Gurkenglas> It's worse than that. Monads have kind *->*. All functions have kind *.
14:33:45 <frerich> Fuco: No, what you mean is 'x _ = 5'.
14:33:48 <argoneus> just write haskell stuff and eventually you will realize why you'd want them
14:33:59 <testtest> glguy: Thanks, I'll read that
14:34:09 <isu> Is there any function that checks FilePath for presence ["..","~","posibly others i don't know"]? I need to serve files from: "document_root/" ++ path. But for security reasons, path needs to be validated first. Also what about UTF8? I guess I could use some regex for it, but maybe there is a function exists for this kind of job:
14:34:10 <kadoban> testtest: That link was more for Fuco.
14:34:34 <argoneus> testtest: make sure to avoid burritos and boxes
14:34:37 <frerich> Fuco: A constant function is something which no matter what value it's applied to, always yields the same value. You cannot apply '5' to anything though. So that's not a constant function.
14:34:42 <testtest> kadoban: Woops, sorry
14:34:50 <kadoban> testtest: In terms of Monads â€¦ all there is to learn in depth is the methods in the Monad typeclass. Then use them. Don't spend forever reading tutorial after tutorial trying to explain the things, it's a waste of time.
14:35:19 <Enigmagic> unless you like burritos
14:35:29 <argoneus> testtest: if you really want to read something
14:35:31 <argoneus> read this https://wiki.haskell.org/Monads_as_computation
14:35:42 <argoneus> it doesn't try to force burritos down your throat and gives you the main points
14:35:51 <conal> Gurkenglas: worse than that. functions don't have any kind at all. they have types instead.
14:35:52 <argoneus> if you don't get it just ignore it and write haskell
14:35:57 <testtest> kadoban: Quite honestly, I am having a hard time just understanding what a monad even is. Like, in one sense it sounds like functions, but in another, I don't understand that at all
14:36:06 <argoneus> testtest: did you read my link yet
14:36:06 <testtest> *them
14:36:25 <testtest> argoneus: Woops, no, sorry, I thought it was for someone else. I will now.
14:36:54 <conal> Gurkenglas: (though their types do have kind *)
14:37:01 <argoneus> testtest: and as I said, if you don't understand what the page is trying to tell you, just give it up
14:37:08 <argoneus> write haskell code and you will see why you want monads
14:37:26 <argoneus> that's what helped me anyway
14:37:30 <argoneus> maybe it's a stupid approach
14:37:41 <kadoban> testtest: Don't even worry about it. There's *far* less there than most people think. It's a useful pattern that's abstracted as a typeclass, that's it. You'll eventually see the pattern in many ways and it'll suddenly make sense why it's there.
14:38:05 <testtest> argoneus: Thank you for your suggestion, I'm just a little hesitant about writing code that I don't understand.
14:38:07 <koala_man> I support the approach of just filing it away as "the theoretical underpinnings of 'do'" for now, until you're familiar with practical Haskell
14:38:15 <testtest> kadoban: Yay, sounds good.
14:38:28 <Denommus> @pl (foo bar) <$> (baz bar)
14:38:28 <lambdabot> foo bar <$> baz bar
14:38:39 <Denommus> @pl \bar -> (foo bar) <$> (baz bar)
14:38:39 <lambdabot> liftM2 (<$>) foo baz
14:38:40 <testtest> The problem is just that it seems like in order to use any sort of library you need to use monads
14:38:57 <Denommus> hm, not very readable
14:39:20 <Gurkenglas> :t \x -> any (`isInfixOf` x) ["..", "~"] -- isu
14:39:21 <lambdabot> [Char] -> Bool
14:39:22 <argoneus> testtest: if you want a really rough way of thinking about them think of them as a bunch of computations under a specific domain, and a convenient way to store state inbetween the function calls
14:39:27 <argoneus> inb4 I get jumped by the people here for being wrong
14:40:02 <testtest> argoneus: So then is the goal to access that inbetween state, or what is even the purpose of having the inbetween state? Sorry.
14:40:30 <kadoban> argoneus: If you'd have left off the "and" part I'd mostly agree I think.
14:40:31 <Gurkenglas> What's the difference between isInfixOf and isSubsequenceOf?
14:40:44 <argoneus> testtest: with monads you can kinda write code procedurally
14:40:47 <koala_man> Gurkenglas: infixes are contiguous, subsequences are not
14:40:51 <argoneus> or at least it looks like it
14:41:01 <argoneus> which is something you generally don't do in haskell
14:41:10 <kadoban> Gurkenglas: [1,2,3] is a subsequence of [1, 5, 20, 2, 999, 3]
14:41:15 <Gurkenglas> kthx
14:41:55 <argoneus> I still don't entirely get them myself, but it's clear they aren't some black magic
14:42:04 <argoneus> it's just a typeclass with some functions
14:42:08 <dzdncnfzd> Can I ask what the import of this conversation is? It's clearly a question of definition -- isn't it more useful to ask, "Is it consistent with established usagee to call constant values functions?" and "Is it useful..?"
14:42:44 <testtest> argoneus: Oh, so they're just ways of accessing/doing things outside of the normal stream of Haskell time-logic, which is why stuff like file input and GUI's require them?
14:42:56 <argoneus> testtest: no
14:43:06 <argoneus> what you're describing is side effects
14:43:15 <shachaf> @check \xs ys -> ((xs :: [Bool]) `isInfixOf` ys) == (xs `isSubsequenceOf` ys)
14:43:17 <lambdabot>  *** Failed! Falsifiable (after 7 tests and 1 shrink):
14:43:17 <lambdabot>  [True,True] [True,False,True,False]
14:43:27 <dzdncnfzd> testtest: monads are a type class which define two functions
14:43:44 <argoneus> testtest: the IO monad is a topic by itself
14:43:49 <dzdncnfzd> testtest: do you know what a type class is?
14:45:01 <kadoban> Since you're still asking questions, some examples: Maybe is a Monad. It models computations that can fail. [] is a Monad. It models nondeterministic computations (computations with multiple answers). Either e is a Monad, it models computations that can fail with an error. IO is a Monad, it models computations with arbitrary side-effects in the computer when executed. State is a Monad, it models computations with implicit shared state.
14:45:01 <testtest> dzdncnfzd: I'm pretty sure that they're like generic types in Java
14:45:39 <Zekka|Sigfig> testtest: Theyâ€™re more like abstract classes, but I donâ€™t think that intuition will help you very much
14:45:53 <kadoban> Monads as computational models, I'm not sure that captures everything though. Like Parsers can be Monads, and I'm not sure how to word that as a computational model â€¦
14:45:56 <dzdncnfzd> testtest: I don't program in Java... I think it might be kind of akin to an interface? It's a set of functions which more than one datatype implements
14:45:58 <argoneus> testtest: do you know what a functor or applicative is
14:46:40 <cheater> testtest: monads are a way of saying "this thing should happen first and that thing should happen second". that's all. there are lots of things where order matters, like say: IO, transactions, writing to logs, etc.
14:47:14 <zoku> haha, there are so many monad analogies
14:47:23 <dzdncnfzd> testtest: Like, I can have an Int or a Float, but I can convert both of them to strings because they're members of the Show typeclass
14:47:32 <zoku> it helped me yesterday to think of a monad as a context for computation
14:47:47 <Zekka|Sigfig> Of course, *monoids* are also about composition where order can matter!
14:47:50 <isu> Gurkenglas: thank you!
14:47:55 <testtest> cheater: Thanks, that sounds reasonable.
14:47:58 <Zekka|Sigfig> And applicatives are *also* about composition where order can matter!
14:48:06 <Zekka|Sigfig> But that is certainly the case for monads too.
14:48:10 <dzdncnfzd> which means that if I have `x :: Int` and `y :: Float`, I can write both `show x` and `show y`
14:48:13 <testtest> dzdncnfzd: Mhm
14:48:14 <Zekka|Sigfig> (I think monads say a little more than that)
14:48:25 <dzdncnfzd> testtest: which means that if I have `x :: Int` and `y :: Float`, I can write both `show x` and `show y`
14:49:45 <dzdncnfzd> testtest: Okay. So typeclasses are just lists of functions that various datatypes (Int, Float, String, whatever) implement. A monad is a typeclass with two specific functions in it, one called "bind" and the other called "return."
14:49:52 <cheater> testtest: in most common categorizations, the immediate superclass of Monad is Applicative. That means, there are some things that are Applicatives but not Monads. If a thing is Applicative, but you don't know whether it's a Monad or not, that thing does not ensure order of evaluation.
14:50:35 <argoneus> man
14:50:36 <dzdncnfzd> testtest: "bind" and "return" both have to satisfy a few equalities for them to make a monad (GHC doesn't make sure this is true -- you have to verify them as a programmer)
14:50:44 <argoneus> why are there barely any examples on calling C code with haskell :(
14:50:46 <cheater> testtest: a type of Applicative is Alternative. For example, foo = bar <|> baz. foo will be either bar or baz, depending on which one succeeds. But you don't know which one it'll be.
14:50:48 <testtest> dzdncnfzd: Shit man, that's crazy. I didn't realize how extendable Haskell really was until I thought about that.
14:51:17 <testtest> cheater: Oh, that's kind of weird. Interesting though.
14:51:27 <cheater> argoneus: there are 10 pages of results here. https://www.google.com/search?q=haskell+c+ffi
14:51:28 <dzdncnfzd> testtest: the rest of the explanations are all noise and won't get you anywhere. You'll get it as you program with them
14:51:50 <argoneus> cheater: sorry, c++**
14:51:56 <dzdncnfzd> testtest: trying to explain this is like trying to explain what it means for a negative times a negative to be positive
14:52:03 <cheater> argoneus: you can't, you have to wrap your stuff in C.
14:52:10 <dzdncnfzd> testtest: the explanations come way after your having learned it
14:52:30 <testtest> dzdncnfzd: Okay, thanks. I'm really sorry about having to ask these questions.
14:52:45 <argoneus> cheater: so I wrap the class in a struct and make functions use this struct and call the c++ functions somehow?
14:52:50 <argoneus> that's what I got when I searched
14:52:51 <geekosaur> binding directly to c++ is an utter nightmare
14:53:02 <dzdncnfzd> testtest: That's okay. We've all gone through this mess :). I actually only really got into Haskell, though, after programming a bit in Elm, which is functional but doesn't have monads
14:53:29 <geekosaur> I'm involved with another project that is trying to support that. They just got stymied by std::string.
14:53:33 <Cale> argoneus: Because C++ makes life difficult for FFI relative to C. There's a layer of name obfuscation to go through, even if you have C++ things that have C-like types.
14:53:53 <dzdncnfzd> testtest: I spent so much time trying to figure out how to use monads and then I finally started doing enough programming that the need for them became obvious. And it's obviously easier to learn when you know why you need something.
14:54:06 <Cale> (and if you don't, then you need to build more marshalling over on the C++ side)
14:54:25 <testtest> dzdncnfzd: Yeah I've got a friend who's interested in Elm. Sounds interesting though, how someone somehow thought that a functional language could work on the rediculously dynamic frontend
14:54:27 <cheater> argoneus: yes.
14:55:12 <dzdncnfzd> testtest: I've not done a lot with it, but it actually seemed like a much more maintainable idea than traditional OOP stuff
14:55:30 <Cale> argoneus: What in particular are you interested in binding to?
14:55:58 <argoneus> Cale: a C++ library
14:56:05 <argoneus> I can give you the specifics in overflow if you want to help
14:56:07 <Cale> ... I knew that much
14:56:08 <Cale> heh
14:56:16 <argoneus> don't want to spam irrelevant stuff here
14:56:37 <Cale> I don't think the name of the C++ library is too irrelevant
14:56:42 <argoneus> ah, right
14:56:43 <argoneus> BWAPI
14:56:59 <testtest> dzdncnfzd: Honestly, coming from an entirely OOP/Python/JS standpoint I can't understand that. Maybe a little, because of Node's event-based stuff but it just sounds alien to me.
14:57:06 <argoneus> it's basically a module class with a bunch of event handlers
14:57:07 <Cale> ah, cool
14:57:22 <argoneus> and then utility classes and functions for map and unit manipulation
14:57:30 <argoneus> but it's all in C++
14:57:42 <Cale> I know a guy who has won a lot of the BW AI competitions :)
14:57:51 <argoneus> name?
14:57:59 <Cale> Dave Churchill
14:58:17 <argoneus> oh, UOA
14:58:30 <testtest> Well, bye guys! Thanks a ton for your help, I'm going to go now!
14:58:39 <testtest> Sorry about asking in the first place
14:58:41 <argoneus> Cale: yeah I wanted to get into the development myself
14:58:54 <argoneus> but I don't fancy the idea of writing an AI in C++ and I don't want to use java either, so I thought of using Haskell
14:58:58 <argoneus> but there are no bindings
14:59:11 <argoneus> and I'm too dum to make my own
14:59:12 <argoneus> apparently
14:59:13 <Cale> Yeah, it's going to be an up-hill battle
14:59:25 <dzdncnfzd> testtest: enjoy yourself!
14:59:31 <dzdncnfzd> testtest: and good luck!
14:59:38 <argoneus> especially since this topic seems to be... rather unfriendly
14:59:57 <argoneus> basically when I look up sources on how to translate C++ to Haskell the general gist of it is "good luck"
15:00:27 <argoneus> there are many tools but they are bad for one reason or another
15:00:45 <geekosaur> argoneus, you would need to write in C++ something which wraps the various APIs as "foreign "C"" exports. C++ iss too nightmrish to bind to diectly, especially when namespaces and templates are involved
15:01:00 <geekosaur> (and std::string, for one very common example, uses both)
15:01:09 <Enigmagic> argoneus: eventually someone will add c++ support to language-c-inline and that'll make a lot of stuff easier
15:01:10 <kadoban> So you basically need to write a C API, and then wrap that?
15:01:30 <Cale> kadoban: Yeah, pretty much
15:02:00 <kadoban> Seems fair enough I guess. It would be kind of terrible trying to write N separate FFIs
15:02:07 <Cale> This is a pretty similar story in essentially every other language where people want to interface with C++ code, not just Haskell.
15:02:17 <geekosaur> yes :(
15:02:34 <kadoban> Right :-/
15:02:40 <geekosaur> until C++11 you couldn't even do that much because there wasn't any kind of standard for little things like name mangling
15:02:59 <geekosaur> so your code would work with some g++ versions but not others, if you did it by hand
15:03:02 <Enigmagic> Cale: SWIG makes it easier for a lot of other languages
15:03:04 <shachaf> What, there's a standard in C++11?
15:03:07 <Enigmagic> just not Haskell :P
15:03:37 <geekosaur> shachaf, C++11 says "compilers for a platform must interoperate, every platform must define its own addendum documenting its interface"
15:03:47 <argoneus> so basically, I'm SOL?
15:04:15 <kadoban> argoneus: Well, not really â€¦ you just have an extra step to do. Write a C API first.
15:04:33 <argoneus> I thought of integrating a javascript engine like V8 inside the library and using SWIG or such to translate the classes to javascript objects, and then I could use clojurescript or purescript or something
15:04:37 <argoneus> but that seems like a lot of work too
15:04:45 <argoneus> kadoban: isn't that like, difficult, though >_>
15:05:31 <argoneus> I need to basically duplicate the headers and cpp files, and then compile it twice
15:05:33 <Cale> Enigmagic: actually, that's an amusing suggestion -- can SWIG just generate an interface for C?
15:05:39 <kadoban> argoneus: Kinda, yeah. Writing good wrappers tends to be pretty hard. Especially if the semantics you want to expose don't match the semantics of what you're wrapping.
15:05:59 <Enigmagic> Cale: i don't know how it works for C++ but i'd imagine it does that
15:06:10 <argoneus> like if a function takes a std::list<someclass>, that's really tricky in C, isn't it
15:06:28 <Enigmagic> no
15:06:30 <Cale> You might at least be able to get it to do that much, and then write a Haskell binding to the C interface that it generated.
15:06:50 <argoneus> swig doesn't support C as output
15:06:51 <argoneus> only input
15:08:11 <Enigmagic> argoneus: i think the idea would be to find a swig target that generates nice-ish C apis and use those instead
15:08:14 <Cale> argoneus: Well, it has to do something when it generates interfaces to C++ libraries for, e.g. Python
15:08:33 <argoneus> Enigmagic: Cale I already looked into this, there's no official C binding generator
15:08:33 <Cale> Or any of the other languages it supports.
15:08:55 <Cale> So maybe you could basically trick it into going half-way for you
15:09:43 <Cale> You use it to generate a Python binding, then take the C interface that it would have generated as part of that, and write the Haskell FFI stuff to bind to *that*
15:10:26 <argoneus> actually
15:10:27 <argoneus> there's this
15:10:33 <argoneus> https://github.com/swig/swig/tree/gsoc2012-c
15:10:37 <argoneus> a branch
15:10:40 <argoneus> I wonder if this would work
15:10:58 <argoneus> this branch is apparently from google summer of code and it supports C as a target language
15:11:21 <argoneus> it's a bot old tho
15:11:23 <argoneus> bit*
15:11:37 <Enigmagic> C hasn't changed that much since 2012 ;-)
15:11:43 <kadoban> ^
15:12:02 <argoneus> I'll try using this then
15:12:04 <Cale> argoneus: Yeah, there's not much of an excuse for SWIG not to have C as a target, because surely it's generating halfway-decent C bindings as part of most of the other bindings to other languages that it's giving you.
15:12:21 <kadoban> Cale: That does seem kinda weird, now that you mention it.
15:12:42 <Cale> argoneus: Even if you can't get the GSOC thing to work well, try just using one of the other targets, and poke around for generated C code.
15:12:51 <Cale> Maybe it'll be reasonable
15:12:57 <argoneus> ugh, makefiles
15:13:07 <argoneus> C is like the only reason why I'd switch away from windows
15:13:52 <argoneus> Cale: I'll try the GSOC thing first, and then I should be able to just make a bunch of ccalls in haskell, right
15:14:04 <Gurkenglas> "<Cale>	If there's supposed to be an isomorphism between [a] -> r and some mystery type people were calling a -> a -> ... -> r, well, I don't know what the latter type is, but it sure looks like it's meant to be a -> X for some type X." <- If it is meant to be a -> X for some type X, then [a] -> r must instead be NonEmpty a -> r, since there's at least one argument.
15:14:37 <Cale> argoneus: Yeah, I recommend reading the FFI documentation here: http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html -- relative to the rest of the report, it's much more tutorial-like.
15:14:54 <Cale> Gurkenglas: right.
15:15:02 <argoneus> noice, thanks :)
15:15:05 <Phyx-> why would C make you switch away from Windows?
15:15:12 <argoneus> Phyx-: because GNU tools are aids on windows
15:15:15 <Cale> Gurkenglas: I was mostly pointing out that people were speaking nonsense :)
15:15:18 <argoneus> there's cygwin but blah
15:15:34 <argoneus> (then again gnu itself is aids)
15:15:55 <Cale> Gurkenglas: That was a long time ago though...
15:15:55 <dobq> does haskell have anything that can call arbitrary C functions (type known at runtime) except for libffi?
15:16:01 <Gurkenglas> The argument you used doesnt work tho because NonEmpty Void -> Void is inhabited, unlike [Void] -> Void
15:16:19 <Gurkenglas> Ya I was looking through ircbrowse for mentions of uncurryN. And now I'm adding to them.
15:16:35 <Phyx-> argoneus: I have generally found them quite ok, msys2 is particularly good
15:17:45 <Cale> Gurkenglas: Yeah, fair enough. I still don't really know what people were trying to get at with the ellipsis.
15:17:51 <argoneus> Phyx-: do you prefer it to cygwin? never used msys
15:17:59 <argoneus> also I'll stop the offtopic after this, enough about BWAPI
15:18:10 <Phyx-> argoneus: very much so, I find cygwin to be horrible
15:18:17 <argoneus> alright cheers
15:18:22 <Phyx-> also msys2 can produce native windows binaries
15:18:30 <argoneus> back to studying, I'll read all the stuff you guys suggested later
15:18:32 <Phyx-> GHC is nowadays built using msys2
15:18:33 <argoneus> thanks! :)
15:19:58 <Gurkenglas> Is there a way to view ircbrowse without all the join/part stuff?
15:20:16 <broma0> is there currently any way to try out the full OverloadedRecordFields extension yet? 
15:22:45 <augur> is it possible to sort of.. quantify .. in constraints?
15:23:18 <augur> like, suppose f :: * -> * -> * and i want to say f is functorial in its second position, can i make a constraint equivalent to the invalid   forall a. Functor (f a)   ?
15:23:43 <Gurkenglas> Cale, pretty sure they meant a function that they can apply any number of arguments to, not that there is a unique but unknown number of arguments that can be passed to the function as you seemed to think. Sounds like PrintfType from https://hackage.haskell.org/package/base-4.8.1.0/docs/Text-Printf.html
15:23:43 <jle`> augur: i don't know a way to do it directly, but i seen/i have worked with using Dict and Entailment to simulate things like this
15:23:53 <augur> jle`: gross :(
15:23:58 <jle`> ikr
15:24:34 <jle`> i'm not sure if it's a fundamental limit of how typeclasses work, or if it's just an unimplemented feature
15:24:36 <Cale> Gurkenglas: Yeah, it's a bit hard to know what is meant by such a thing in the context of Haskell's type system.
15:24:37 <augur> jle`: i know there are a bunch of convenient wrappers in Bifunctor but that forces me to use the nasty wrapped types in places where that's highly undesirable
15:24:57 <jle`> i know your pain
15:25:09 <Gurkenglas> (Which is of course also a cheat since printf is one "function from String to an n-argument function" for each n, not a function from String to the type of any-number-of-argument functions.)
15:25:14 <Cale> Gurkenglas: Yes, you can do PrintfType-style trickery, but... that didn't seem too helpful in context
15:25:24 <jle`> but i haven't put too much effort into figuring out if there is a solution or not
15:25:27 <jle`> that doesn't involve those wrappers
15:25:28 <Cale> right
15:25:38 <jle`> so don't give up hope just because i said so :)
15:27:31 <augur> jle`: i'd be tempted to write something like   instance Bifunctor f => Functor (f a)   but im certain that would fuck stuff up
15:27:57 <jle`> and some kittens will die somewhere, too
15:28:13 <augur> i guess maybe the right answer here is to abstract over the map function
15:28:25 <augur> or, well, not the map function
15:28:27 <scshunt> Hey all, is there anyway to get stackage to locally generate & install documentation for all the packages it installs?
15:28:41 <Clint> do you mean stack
15:28:47 <jle`> well, i'm not sure if (forall a. Functor (f a)) is even a meaningful thing to say
15:28:49 <augur> oh, wait right, that wont work because i specifically need Functor's. d'oh
15:29:00 <jle`> like, it might be a fundamental issue
15:29:07 <augur> jle`: sure it's meaningful!
15:29:17 <augur> it means that for any choice of a, i can give you a functor instance for `f a`
15:29:27 <jle`> yes, but how would that be implemented?
15:29:32 <jle`> meaningful might be the wrong word, heh, sorry
15:29:46 <augur> same way you'd implement anything else :)
15:29:54 <augur> remember, Functor is just a fancy hidden record type
15:30:25 <jle`> yes, but that would require that an instance Functor (Bar a) where ... is written, and exactly that, i guess
15:30:28 <augur> data FunctorMethods f = FunctorMethods { fmap :: forall a b. (a -> b) -> f a -> f b }
15:30:59 <jle`> you'd ahve to preserve the forallness of the defined instance
15:31:11 <augur> so, if you can implement    foo :: FunctorMethods (F a)    for your particular F, you're fine
15:31:48 <jle`> yes, but; i feel like distinguisihing foo :: FunctorMethods (F a) and foo :: FunctorMethods (F Int) might be weird
15:31:49 <augur> eg:   rightPairFunc :: FunctorMethods ((,) a)
15:32:18 <augur> rightPairFunc = FunctorMethods { fmap = \f (x,y) -> (x, f y) }
15:32:46 <jle`> yeah; but that normally works because rightPairFunc can unify with any desired a
15:32:51 <jle`> so it'll work when you want (,) Int
15:32:56 <jle`> i'll work when you want (,) Bool, etc.
15:33:17 <augur> right, but rightPairFunc is polymorphic in a, so it's fine :)
15:34:17 <jle`> so if GHC picks the instance it wants there, it *has* to pick the one quantified for all a
15:34:18 <augur> at least, it works in principle, and is perfectly meaningful. but it doesnt work in haskell
15:34:27 <augur> im not sure what you mean
15:35:48 <jle`> i guess the algorithm that GHC uses to pick which instance to use is already sort of mystical to me so I can't say too many things with certainty, heh
15:36:30 <augur> "which instance to use" is a none-thing, or should be. instances should be unique
15:37:26 <augur> tho, possibly having such a universally quantified instance in scope could cause problems for that, since you're basically requiring that there's not simply an instance, but a way of *generating* instances
15:38:21 <jle`> that might be what i mean; well, in this case, if you have a (forall a. FunctorMethods (Foo a)) in scope, then that one could be chosen
15:39:06 <augur> yeah, if you need   Functor (Foo Int)   you could use that tool to generate the functor table, certainly
15:39:22 <augur> but of course this is already a risk, b/c of overlapping instances
15:39:26 <augur> i guess an alternative to this would be to have some kind of use-as
15:39:56 <augur> like, if i had some way of saying "f is a bifunctor, but i want to use it as a functor, and here's how you'd do that for this particular situation"
15:40:56 <deam> Is monad a type?
15:41:09 <augur> deam: monad is a type class
15:41:54 <deam> What does it contain?
15:42:03 <augur> @hoogle Monad
15:42:03 <lambdabot> Prelude class Monad m
15:42:03 <lambdabot> Control.Monad class Monad m
15:42:03 <lambdabot> Control.Monad.Instances class Monad m
15:42:15 <augur> grr. i forget that hoogle doesnt link :(
15:42:36 <augur> https://www.haskell.org/hoogle/?hoogle=Monad
15:43:07 <augur> but, you probably want to learn what monads are, not learn simply what the definition is
15:43:32 <augur> there are lots of tutorials. not sure what the best are
15:44:18 <Gurkenglas> I like http://dev.stephendiehl.com/hask/#monads
15:44:25 <mgsloan> scshunt: "stack haddock" will install all the haddocks for your dependencies and packages
15:44:31 <scshunt> <3
15:45:18 <deam> Augur gurkenglas thanks
15:47:59 <scshunt> I hate transformer stacks
15:48:31 <dmj`> scshunt: porque?
15:48:47 <dmj`> transformers, monads in disguise
15:49:04 <scshunt> dmj`: because they make your types parameterized on more than you care to parameterize them on
15:49:12 <jle`> yeah, i often end up just make my own monads instead of using transformer stacks
15:49:25 <monochrom> you can also newtype
15:49:28 <jle`> and write generic interfaces with MonadState, MonadIO, MonadReader, etc.
15:49:49 <scshunt> I think I have to do that here
15:49:59 <scshunt> because RandT requires baking a generator into the type for no good reason
15:50:26 <scshunt> wrapping state is fun, because my state type is constant
15:50:32 <erikd> scshunt: you might like this https://www.youtube.com/watch?v=GZPup5Iuaqw
15:50:36 <jle`> don't use RandT
15:50:39 <dmj`> newtype MyMoTran a = MyMoTran { runMyMoTran :: EitherT ErrorType (ReaderT Config IO) a } deriving (MonadIO, Monad, Functor, Applicative, MonadReader Config, MonadError Errortype)
15:50:41 <jle`> use MonadRandom m =>
15:50:52 <dmj`> scshunt: if you use newtype, you only get the instances you care about
15:51:00 <scshunt> jle`: then I have to implement the random functions myself, sadly
15:51:08 <jle`> what do you mean?
15:51:08 <dzdncnfzd> Is it possible, when using parseJSON form Aeson, to fail along with a 1. descriptive error message, 2. the string which caused the failure?
15:51:14 <dzdncnfzd> *form
15:51:16 <dzdncnfzd> **from
15:51:28 <jle`> instead of foo :: RandT g m a, use foo :: MonadRandom m => m a
15:51:29 <dmj`> dzdncnfzd: use `typeMismatch` from Data.Aeson.Types
15:51:42 <jle`> you can still use getRandom, getRandomR, etc.
15:51:43 <dmj`> typeMismatch "Invalid foobar" (x :: Value)
15:51:52 <scshunt> jle`: it's in the middle of another stack
15:52:00 <jle`> why are you using stacks at all! :O
15:52:37 <Denommus> why isn't ZipList a Traversable?
15:52:40 <scshunt> I have type MyMonad a = ProgramT instr (> want RandT here< (State s)) a
15:53:26 <jle`> if you really realy want to stick with a transformer stack, ProgramT can have a MonadRandom instance
15:53:49 <jle`> then foo :: MonadRandom m => m a will work on it
15:54:26 <jle`> or, you can write your functions for MonadRandom m => ProgramT instr m a
15:54:36 <glguy> Denommus: Oversight that was fixed in the upcoming GHC 8
15:55:56 <jle`> but really, there isn't any reason why ProgramT shouldn't have a MonadRandom instance
15:56:01 <jle`> it *is* a MonadRandom
15:56:06 <Denommus> glguy: cool. For now, I should use sequence . getZipList, right?
15:56:20 <jle`> that's like providing Maybe without a Functor instance.  it's a functor whether you like it or not
15:57:33 <glguy> Denommus: sure
15:59:39 <scshunt> jle`: why is it a MonadRandom?
15:59:43 <scshunt> and what would you recommend if not a stack, here?
15:59:55 <scshunt> store the state myself?
16:00:06 <scshunt> (and provide random generation primitives myself?)
16:01:22 <augur> deam: my preferred way to think about monads is as a style of computation
16:01:34 <Welkin> well shit
16:01:38 <jle`> it's a MonadRandom because it can implement `getRandom`, `getRandomR`, etc.
16:01:40 <Welkin> dependency clash again
16:02:00 <augur> deam:   an `m a` is a means of computing an `a` in the style `m`
16:02:01 <Welkin> I am trying to use hS3, but it has too low of a restriction onf base (< 4.8)
16:02:06 <jle`> instance MonadRandom m => MonadRandom (ProgramT i m) where getRandom = ...
16:02:21 <jle`> getRandom = lift getRandom, i think
16:02:23 <Welkin> I culd try creating my own repo and compiling that, but who knows what other issues might happen
16:02:25 <augur> deam: for instance, `m` might be the style of computations that might fail without giving you an error message
16:02:39 <Welkin> I have avoided amazonka-s3 because of the insane dependencies
16:02:45 <Welkin> anyone have experience using it?
16:02:50 <Welkin> why the hell does it require lens?
16:02:54 <Welkin> for a simple web api?
16:03:02 <jle`> scshunt: it's recommend writing your functions on (MonadRandom m) => ..., instead of on MyMonad
16:03:04 <augur> deam: or it might be the style of computations that might fail w/ an error message. or it might be the style of computations that can alter some specified state
16:03:30 <pikajude> Welkin: they probably use it internally and decided it would be worth exposing simple Lenses as well
16:04:01 <augur> deam: monads in haskell are defined with two type class methods --   return :: a -> m a   and   (>>=) :: m a -> (a -> m b) -> m b
16:04:30 <glguy> Welkin: Docs say: Use of lenses is required for constructing and manipulating types. This is due to the amount of nesting of AWS types and transparency regarding de/serialisation into more palatable Haskell values.
16:04:33 <glguy> fwiw
16:04:35 <augur> deam: the way to think about return is that, if you have a value, then you can turn it into a trivial computation that sort of does nothing special at all
16:05:48 <Welkin> does anyone know about this package?
16:05:49 <Welkin> https://hackage.haskell.org/package/dataenc
16:05:53 <Welkin> that is the problem
16:05:55 <augur> deam: does that make sense? for instance, you can turn a number into a computation that might raise an error. the computation you produce is the boring such computation that doesn't in fact raise an error
16:06:04 <Welkin> why was it deprecated in favor of "sandi"?
16:06:12 <Welkin> could I use sandi as a drop-in replacement?
16:06:28 <dmj`> Welkin: it looks like it
16:06:28 <Welkin> it's a dependency of https://hackage.haskell.org/package/hS3
16:06:29 <augur> deam: (>>=) (aka bind) is a bit more complex but not too complex
16:06:34 <Welkin> haha hello dmj` 
16:06:48 <Welkin> dmj`: I noticed that s3-signer can upload too, but only via ajax?
16:06:57 <Welkin> I use it to sign URLs for get requests already
16:07:36 <dmj`> Welkin: nice! you could use it to allow other http clients (not just browsers) to upload stuff
16:07:52 <augur> deam: lemme know if i should proceed :)
16:08:00 <dmj`> Welkin: hs3 probably switched to sandi because it wanted to use a streaming library (and sandi uses conduit). 
16:08:04 <dmj`> @package aws
16:08:05 <lambdabot> http://hackage.haskell.org/package/aws
16:08:08 <Welkin> dmj`: well, it didn't switch
16:08:13 <dmj`> Welkin: has s3 support for conduits
16:08:14 <Welkin> it still requires dataenc, which is deprecated
16:08:19 <Welkin> hS3 has not been updated for a long time
16:08:22 <dmj`> hs3 is a little old yea
16:08:34 <dmj`> there's amazonka-s3 too..
16:08:38 <Welkin> I want something ightweight that just does s3 uploads
16:08:39 <Welkin> basically
16:09:21 <dmj`> yea, the s3 api sucks. The AWS signing algorithm is hairy, and the request body is xml.
16:10:12 <dmj`> Welkin: I'd use aws, or amazonka-s3
16:10:23 <orion> What's wrong with the signing algorithm?
16:10:35 <Enigmagic> amazonka is the nicest of the bunch
16:10:36 <Enigmagic> imo
16:10:54 <Enigmagic> mostly because it's complete :P
16:10:59 <Welkin> dmj`: I want to avoid any dependecy clashes if possible, since I am using yesod and already have a huge dependency list
16:11:00 <dmj`> orion: nothing, it's just very involved. I use aws-general 
16:11:26 <dmj`> @package aws-general
16:11:26 <lambdabot> http://hackage.haskell.org/package/aws-general
16:11:44 <dmj`> is a library for producing a valid signature for a request to any AWS API
16:12:17 <dmj`> Welkin: maybe use stack and either aws / amazonka-s3
16:12:52 <dmj`> orion: but dealing w/ xml sucks, so it's better to just use a library where someone has solved that problem
16:13:03 <Welkin> well, I already have all the code written using hS3
16:13:15 <Welkin> I am just migrating to use stack and the new yesod scaffolding
16:13:18 <Welkin> upgrading an older project
16:13:36 <dmj`> Welkin: maybe refactor it with a free monad, keep the hs3 stuff in the interpeter part, then swap it out
16:15:01 <pikajude> Welkin: you're using yesod and you're worried about lots of dependencies?
16:15:30 <pikajude> now, that said
16:15:31 <Axman6> I haven't used it much, but I'm really impressed with amazonka, its interface is very consistent and simple once you understand the pattern
16:15:32 <dmj`> pikajude: heh
16:15:43 <pikajude> i wrote some code a year ago or so that used the aws package to upload files
16:15:46 <dmj`> yesod > acme-everything
16:16:17 <pikajude> just found out about acme-everything. i'm a big fan of that now
16:17:07 <pikajude> Welkin: i'm trying to find my code, you might be able to basically copy it
16:17:14 <dmj`> pikajude: heh
16:17:36 <dmj`> Welkin: I have some s3 conduit code too
16:18:12 <pikajude> rats, can't find it
16:19:47 <dmj`> Welkin: https://github.com/dmjio/SolidTranslate/blob/master/packages/ST-Worker/src/Main.hs#L184
16:19:49 <dmj`> for downloading
16:19:58 <synergis1ics> j/3
16:20:04 <synergis1ics> Oops, sorry.
16:20:12 <pikajude> nope, don't have it
16:20:14 <pikajude> sorry
16:20:19 <dmj`> Welkin: for uploading, https://github.com/dmjio/SolidTranslate/blob/master/packages/ST-Worker/src/Main.hs#L311
16:23:14 <Welkin> dmj`: thanks, I'm adding it now and seeing if it compiles
16:24:37 <dmj`> Welkin: blue collar haskell baby
16:28:15 <dzdcnfzd> So, I asked this a bit back, and someone got back to me, but it wasn't actually what I asked for (I don't think)
16:28:41 <dzdcnfzd> I'm looking for a way of using the Aeson parser to tell me more than just "I failed"
16:28:52 <dzdcnfzd> More than "I was expecting a number and I got a null"
16:29:05 <dzdcnfzd> I'm looking for it to tell me the string it was parsing when it failed
16:29:10 <dzdcnfzd> or the property it was looking at
16:29:19 <dzdcnfzd> Or something of that nature 
16:31:20 <dzdcnfzd> Anyone know something like that?
16:38:10 <Axman6> dzdcnfzd: the latest Aeson tells you a lot more information about where errors occured
16:40:45 <dzdcnfzd> Axman: with the same functions?
16:43:01 <Axman6> yep
16:43:19 <Axman6> but if there's a parse error in the actual json, it might not help you
16:43:41 <Axman6> jq can sometimes give better locations for parse errors
17:14:02 <orion> Is it possible to inspect/analyze a DSL and come to the conclusion that "this particular branch will never be executed"?
17:14:18 <orion> Such as "if False then ..."
17:14:52 <dzdcnfzd> orion: not for a turing complete dsl
17:14:59 <dzdcnfzd> orion: in general, that is
17:15:08 <dzdcnfzd> orion: for particular programs it can be
17:15:28 <dzdcnfzd> orion: but, in general, you just stated the halting program
17:15:32 <orion> right, ok
17:15:35 <dzdcnfzd> *problem
17:16:03 <orion> I'm interested in doing "static code analysis" on programs written in my very small DSL.
17:16:55 <orion> And I want to report to the user (at runtime, not compile time), "Yes, this program satisfies some arbitrary rules that I set".
17:17:24 <orion> Since I don't care about compile time rule checking, I don't have to use Indexed Monads.
17:18:38 <orion> But I'm wondering in general how I could go about reporting to the user something like, "The program I'm analyzing tried to execute Bar before Foo, and that's not allowed because it's a full moon."
17:28:38 <koz_> Is there a less-hideous way to write this in attoparsec? http://paste.rel4tion.org/203
17:29:12 <johnw> (Practice <$ string "p") <|> ...
17:29:32 <johnw> or, make a data table and asum it
17:29:39 <johnw> [("p", Practice)], etc.
17:29:50 <johnw> well, not asum in that case, but fold
17:29:54 <koz_> johnw: Could you please show me the 'data table' thing?
17:30:02 <koz_> I don't quite get how I would exactly write that.
17:30:27 <Kanye> Hi, I have a question about the reader monad
17:30:37 <johnw> foldr (\(key, ctor) rest -> (ctor <$ key) <|> rest) empty dataTable
17:30:59 <johnw> just package that up into a helper function called "branch"
17:31:12 <johnw> then you can write: branch [("p", Practice), ("x", Exists), ...]
17:36:42 <koz_> johnw: Sorry, I might have missed your last message(s). My university's internet is being annoying again.
17:37:12 <shachaf> There are logs in the topic.
17:37:40 <koz_> shachaf: Thanks.
17:38:42 <koz_> Is there a way to get a list of every value of some Enum?
17:39:12 <geekosaur> also derive Bounded
17:39:14 * hackagebot uniform-io 1.1.1.0 - Uniform IO over files, network, anything.  https://hackage.haskell.org/package/uniform-io-1.1.1.0 (marcosdumay)
17:39:30 <geekosaur> > [minBound .. maxBound] :: [Bool]
17:39:32 <lambdabot>  [False,True]
17:39:39 <dolio> Even with Bounded it won't work.
17:40:04 <geekosaur> hm, if it isn't nullary, yes. but that gets you into Data.Data land
17:40:19 <koz_> geekosaur: It is nullary - it's just like, five specific values.
17:46:53 <koz_> When I combine attoparsec parsers with <|>, are they tried left-to-right?
17:49:27 <Enigmagic> yes
17:49:41 <koz_> Enigmagic: Thanks!
17:50:40 <Enigmagic> koz_: some other libs (uu-parsinglib is one example) might parse both sides concurrently
17:50:54 <koz_> Enigmagic: This is precisely why I asked.
17:51:16 <Enigmagic> aeson doesn't do anything clever, or at least it didn't used to. i haven't looked at the 0.10 changes.
18:05:35 <koz_> OK, I have the following sauce code so far: http://paste.rel4tion.org/204 , which needs to parse something like this: http://paste.rel4tion.org/205 . I don't care about the ANDs, or the stuff in the brackets at the end of each block. I know my first thing should be many (....) but I have no idea how to do the 'ignore the AND and newline if it's there' part.
18:09:15 * hackagebot tickle 0.0.6 - A port of @Data.Binary@  https://hackage.haskell.org/package/tickle-0.0.6 (TonyMorris)
18:09:40 <Enigmagic> something like this: leftPart <* (string " AND" <|> pure ())
18:10:05 <koz_> leftPart being 'the parser for the part I care about'?
18:10:09 <Enigmagic> yes
18:10:14 <koz_> OK, let me give this a shot.
18:12:34 <koz_> Enigmagic: It doesn't seem to like the 'pure ()' part. It says it can't match the expected type 'ByteString' with ().
18:13:30 <Enigmagic> koz_: ah yeah you need to change the return result of `string " AND"` to ()
18:14:01 <koz_> So something like adding ::() >
18:14:03 <koz_> ?*
18:14:04 <lambdabot> Maybe you meant: v @ ? .
18:14:04 <Enigmagic> so `(string " AND" *> pure ()) <|> pure ()` would work, dunno if there is a better way
18:14:40 <Gurkenglas> data Modular (i :: Int) = Modular Int <- How do I say this right? (Says "‘Int’ of kind ‘*’ is not promotable")
18:14:48 <Enigmagic> well, to `Parser ()` not `()` .. sorry :)
18:15:02 <geekosaur> Gurkenglas, what are you trying to say there?
18:15:26 <kadoban> koz_: I don't really understand the input format exactly. What parts are you interested in, and are the "AND\n" always there, or?
18:15:36 <Gurkenglas> Modular i for any int i is a wrapper for Int where any function taking or producing the type can make use of i
18:16:05 <koz_> kadoban: I'm interested in the d19 = 4 parts - the ANDs are separators.
18:16:14 <Gurkenglas> http://lpaste.net/148969
18:16:16 <geekosaur> um. that sounds like a dependent type? no oing that in Haskell, ot without hackery
18:16:24 <kadoban> koz_: Are they always there? You kind of made it seem like they might be optional
18:16:48 <Gurkenglas> I thought people did that all the time? Oh well global constants then.
18:16:50 <koz_> kadoban: They're separators in-between. As you can see, the last one doesn't have one (the one before the colon).
18:17:39 <geekosaur> then you didn't mean what I thought you meant. but I still am not sure what you meant the
18:17:42 <geekosaur> *then
18:17:46 <kadoban> koz_: In Parsec there's sepBy which is I think what you want. I can't rememeber if it's called that in attoparsec
18:17:54 <koz_> kadoban: I'll have a look.
18:17:54 <geekosaur> oh, I see.
18:17:58 <koz_> O
18:18:04 <koz_> I'm kinda new to parser combinators.
18:18:06 <koz_> And Haskell.
18:18:36 <geekosaur> still, ti sounds dependent to me. you are thinking of phantom type parameters (like Data.Fixed)
18:18:39 <koz_> kadoban: sepBy is a thing in attoparsec.
18:18:42 <koz_> Thanks for that.
18:18:52 <kadoban> koz_: So yeah sepBy or sepBy1, looks like they exist. Then you just need a parser for the separator, and one for the part you actually want.
18:19:20 <geekosaur> you could in theory do this with a type level natural (i :: Nat) but having to reflect that into value level all the time to use it gets "interesting", or at least annoing
18:19:37 <kadoban> You *could* use 'many' for this like it seems like you were trying, but it's kind of minorly tedious since sepBy exists already.
18:20:08 <koz_> kadoban: Yeah, I would rather use sepBy. Also, how would I make the parser discard whatever was in the brackets at the end?
18:21:10 <geekosaur> or use the same hack Data.Fixed does but that means only being able to use predefined ones (and in that case DataKinds might still be a better option)
18:22:36 <geekosaur> otherwise perhaps you just wanted data Modular = Modular {modulus :: Int, value :: Int}
18:22:48 <kadoban> koz_: Once you have something that parses the crap up to the colon, let's call it    crap :: Parser [String], then you something like: do {res <- crap; char ':'; many1 (satisfy (/= '\n')); many space; return res}   or something
18:23:01 <kadoban> koz_: Does that make any sense whatsoever?
18:24:06 <geekosaur> and in that case you can't have te typechecker verify matching modulus for you, but (a) that may not actually be what you want (b) since there are no true dependent types in Haskell, it's gonna get painful to go that route
18:24:30 <koz_> kadoban: I wrote this: http://paste.rel4tion.org/207
18:26:00 <kadoban> koz_: parseFeature parses the d15 = 4   part?
18:26:14 <kadoban> koz_: That seems to be saying that after the colon, there's another one of those, which I don't understand.
18:26:34 <koz_> kadoban: cluster0 and cluster1 etc are features too.
18:27:41 <kadoban> koz_: One piece of advice I'd give: separate parts out, name them. Test each part individually. Then combine them. Name the combinations, test the combinations, etc.
18:28:08 <kadoban> koz_: I don't really understand the code there, it doesn't appear to make sense to me, though it's possible I'm missing something.
18:28:57 <kadoban> Basically *the* best part of parser combinators like this is you can do that ^ combine really simple parts to more complicated parts with neat combinators, so the whole thing ends up readable as hell and works.
18:30:59 <geekosaur> Gurkenglas, if you really intended a type level number for your modulus, https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/GHC-TypeLits.html
18:31:22 <koz_> kadoban: Thanks, I'll keep it in mind. I've only just started with attoparsec like, today.
18:31:43 <koz_> Did I mention I hate my university's internet.
18:31:45 <koz_> A lot.
18:31:56 <scshunt> jle`: I don't really understand what you mean by writing my own functions on (MonadRandom m). I don't have any monad with a MonadRandom instance right now
18:32:01 <scshunt> I could try writing an instance on my monad
18:32:05 <kadoban> koz_: You're doing great so far then!
18:32:39 <scshunt> (Although writing an instance on a specialization of ProgramT is hard, and I'm not sure why you think ProgramT is generally an instance of MonadRandom
18:32:42 <scshunt> )
18:33:12 <koz_> kadoban: Well, I'd be a pretty lousy PhD student if this was beyond me.
18:33:39 <jle`> scshunt: I wrote one out above
18:34:21 <jle`> instance MonadRandom m => MonadRandom (ProgramT i m) where getRandom = lift getRandom
18:34:27 <scshunt> jle`: oh, sure
18:34:33 <scshunt> jle`: but then I need to stick a RandT in my stack
18:34:41 <scshunt> and you said not to use stacks
18:35:00 <jle`> don't write your logic using stacks
18:35:03 <scshunt> oh
18:35:12 <jle`> write your functions and logic polymorphically
18:35:35 <jle`> when you finally want to "run" your thing, pick a Monad to run it within, but only at the end
18:35:56 <Welkin> play with yer thing
18:36:11 <scshunt> ok
18:36:18 <scshunt> hmm
18:36:23 <scshunt> this doesn't quite work
18:36:23 <jle`> you might not even end up using RandT, but Rand is a nice way to implement a Monad Random without extra work
18:36:43 <jle`> but don't worry about it until the end :)
18:36:50 <scshunt> because some of my logic actually relies on unwrapping the inner State
18:37:08 <scshunt> ah... but I guess I can just use (MonadState ...) on that
18:38:48 <jle`> mhm
18:39:37 <scshunt> why doesn't StateT implement MonadReader?
18:42:39 <exio4> scshunt: it doesn't follow MonadReader laws, does it?
18:43:45 <geekosaur> I think the question is why ReaderT derives through MonadState when atop one, but StateT doesn't derive through MonadReader when atop one?
18:43:47 <koz_> OK, now Cabal is confusing me. It keeps giving this warning here: Warning: rules-analysis.cabal: Ignoring unknown section type: ai
18:44:01 <geekosaur> which I reclal noticing and being a little surprised about
18:44:03 <koz_> I'm not sure what's causing this, because I see no 'section type'-kind of thing anywhere in the .cabal.
18:44:46 <exio4> oh, .. nevermind then :)
18:45:06 <koz_> I wrote my .cabal based on what cabal configure gave me, and this: http://dev.stephendiehl.com/hask/#cabal
18:45:11 <scshunt> geekosaur: yeah...
18:45:15 <exio4> I am guessing the answer is "someone forgot that instance" ? 
18:45:23 <scshunt> exio4: StateT is more than capable of implementing MonadReader
18:45:50 <Cale> Yeah, the lifting instance ought to exist, if there are going to be such instances.
18:46:04 <geekosaur> @paste the cabal file, koz_?
18:46:04 <lambdabot> Haskell pastebin: http://lpaste.net/
18:46:05 <kadoban> koz_: lpaste the .cabal maybe? Might be something obvious.
18:46:15 <scshunt> I guess for consistency it makes sense for it to be the lifting instance
18:46:17 <scshunt> but it's a bit of a shame
18:46:42 <scshunt> exio4: you have to jump through a hoop to write local, but it's doable
18:47:12 <scshunt> local f a = do { s <- get; evalState a (f s) }
18:47:17 <scshunt> err, maybe + return
18:47:21 <scshunt> yeah, you need return
18:47:44 <exio4> scshunt: I thought there was some law that specified that "get" always gives back the same value within a context
18:48:14 <exio4> er, not get, ask
18:48:26 <koz_> geekosaur and kadoban: http://lpaste.net/148979
18:48:42 <scshunt> exio4: depends on what you mean by "context" I guess
18:48:55 <geekosaur> koz_, indentation
18:49:23 <geekosaur> the AI.Analysis lines need to be indented past the start of "exposed-modules"
18:49:53 <koz_> geekosaur: Oh, right. Thanks.
18:52:10 <koz_> geekosaur: Now it's unhappy with the test part's build-depends. I think I did it correctly...
18:53:14 <geekosaur> line 37 looks dodgy to me
18:53:43 <geekosaur> dropped a < perhaps?
18:53:53 <koz_> Yup, found it.
18:53:54 <geekosaur> (ahia freenode)
18:53:55 <koz_> Thanks!
18:53:58 <geekosaur> *ohai
18:57:14 <koz_> OK, so far, everything works, but it can't find Test.hs.
18:57:32 <koz_> Where do I need to place it if the main-is for Test-Suite test is 'Test.hs'?
18:57:38 <koz_> I put it in src/Test.hs
18:58:05 <kadoban> koz_: Specify hs-source-dirs for the test suite. Usually you put that somewhere seprate from the rest of the source, though that's not required.
18:58:38 <koz_> kadoban: Thanks!
18:58:49 <koz_> At least Cabal is easier than Autotools....
19:03:14 <koz_> kadoban: If I need Test.hs to read from a file, where does the relative path for its execution via 'cabal test' begin?
19:03:15 <koz_> I mean, I can hardwire a path, but obviously I'd prefer to use a relative one.
19:04:08 <kadoban> koz_: The current directory I believe? I'm not terrifically sure actually. I don't do a lot of test data in files.
19:04:32 <koz_> kadoban: I see. Well, I'll give it a shot then.
19:08:50 <koz_> kadoban: Well, it's definitely not the current directory.
19:12:11 <geekosaur> could always drop a putStrLn =<< getCurrentDirectory in main...
19:12:38 <koz_> geekosaur: I might have to resort to that actually.
19:12:43 <koz_> For now, I've hardcoded the path.
19:13:37 <koz_> Also, my university's internet is absurdly bad.
19:13:49 <koz_> For an institution that calls itself a 'university of technology', it's kinda bad at technology.
19:14:17 * hackagebot shakespeare-babel 0.1.0.0 - compile es2015  https://hackage.haskell.org/package/shakespeare-babel-0.1.0.0 (ncaq)
19:14:34 <koz_> But the good news is, my parser works!
19:14:44 <koz_> Thanks for all your help everyone, especially geekosaur and kadoban.
19:16:15 <scshunt> ugh
19:16:24 <kadoban> koz_: Nice!
19:16:30 <scshunt> why *isn't* there a local state function
19:16:33 <scshunt> this is annoying
19:16:47 <kadoban> scshunt: What do you mean?
19:18:46 <ReinH> scshunt: what is a local state function?
19:19:07 <geekosaur> think they want MonadReader's local but for state
19:19:36 <ReinH> Something like zoom?
19:19:37 <scshunt> yeah
19:20:08 <scshunt> so I wrote runLocal a = do { s <- get; b <- a; put s; return b }
19:21:00 <ReinH> but... you don't use s
19:21:16 <scshunt> ReinH: a might
19:21:28 <ReinH> how?
19:21:49 <scshunt> it's a monadic action
19:21:58 <scshunt> it could modify the state
19:22:33 <Gurkenglas> It doesn't need you to do "s <- get" and "put s" to do that. If you don't write s anywhere, the result of get doesnt get used
19:22:57 <scshunt> what if a is "put 3"?
19:23:14 <Gurkenglas> Oh, you want to make sure that a does not change s
19:23:30 <scshunt> yep
19:24:47 <Gurkenglas> runLocal = gets . evalState
19:25:52 <ReinH> not quite
19:26:18 <ReinH> since that only lets you use a State action
19:34:18 * hackagebot drifter 0.2.2 - Simple schema management for arbitrary databases.  https://hackage.haskell.org/package/drifter-0.2.2 (MichaelXavier)
19:34:20 * hackagebot drifter-postgresql 0.0.2 - PostgreSQL support for the drifter schema migration tool  https://hackage.haskell.org/package/drifter-postgresql-0.0.2 (MichaelXavier)
19:35:38 <mjrosenb> is it possible to get the repl to print the minimum complete definition for a class?
19:36:15 <kadoban> mjrosenb: Does :info give you that?
19:37:36 <geekosaur> I think that might not have been added
19:38:06 <geekosaur> 7.10.3 should have MINIMAL for Ord, but :info doesn't show it
19:39:03 <geekosaur> probably worth filing as a ghci bug/enhancement
19:39:10 <geekosaur> if it isn't already
19:39:25 <geekosaur> (someone shoudl test in the 8.1 rc)
19:44:38 <scshunt> Gurkenglas: what ReinH said. I need it to work for abitrary MonadStates
19:46:06 <scshunt> hmm
19:53:51 <mjrosenb> kadoban: nope.
19:54:46 <parrot> http://lpaste.net/149064#a149064
19:54:58 <parrot> could anyone explain why we need liftIO?
19:55:15 <parrot> but putStrLn is already in IO
19:55:27 <parrot> why do we need to lift it in IO again ?
19:55:35 <geekosaur> yes. which means it's not in ReaderT
19:55:48 <geekosaur> liftIO means "find the IO underneath the current monad and pass the action to it"
19:56:36 <geekosaur> this is not like OO composed roles; having ReaderT something IO does not mean you can do both IO and MonadReader directly, only MonadReader is directly available
19:57:38 <parrot> So the IO fetches something from the reader and then do something
19:57:48 <geekosaur> "lift" passes something to the next monad, "liftIO" passes stuff to IO (which must be at the end of the chain of monads, so could be several steps away for e.g. ReaderT Something (StateT SomethingElse IO)
19:57:55 <parrot> in my case its print the string
19:58:22 <geekosaur> you would either lift $ lift $ ioAction, or let liftIO figure out how many lifts are needed to get to the IO monad
19:58:34 <parrot> but putStrLn is already an IO
19:58:42 <geekosaur> right back to the start again
19:58:55 <parrot> liftIO putStrLn gets an IO again ?
19:58:55 <geekosaur> yes. try using putStrLn directly and note the type mismatch you get
19:59:13 <parrot> ok
19:59:15 <geekosaur> putStrLn is in IO. printReaderContent is *not* in IO
19:59:23 <geekosaur> it has an IO *somewhere else in the chain*
19:59:35 <geekosaur> liftIO means follow the chain to get to the IO and pass the putStrLn to it
20:00:11 <geekosaur> again, this is not role composition. the fact that printReaderContent has an IO somewhere in its type does not mean it can run IO actions
20:00:43 <parrot> but printREaderContent it did run an IO action
20:00:50 <geekosaur> where?
20:01:01 <parrot> putStrln 
20:01:11 <geekosaur> I see an "ask" (which is part of ReaderT), and a liftIO that can pass the IO action to the IO further along the chain
20:01:21 <geekosaur> if you try that without the liftIO, you will get a type error
20:01:22 <parrot> ok
20:01:24 <parrot> i see
20:01:27 <geekosaur> because ReaderT is not IO
20:01:44 <parrot> so printReaderContent only defines and action
20:01:50 <parrot> defines an action
20:01:56 <parrot> but doesn4t really run it
20:02:00 <geekosaur> no
20:02:02 <parrot> only runReaderT runs it
20:02:36 <geekosaur> the type (ReaderT r m a) can do "ask", "asks", and "local". it cannot run IO actions
20:02:39 <geekosaur> only IO can
20:03:10 <geekosaur> but if m, or something else "contained in" m, is IO then you can use liftIO to pass an action to that IO which knows what to do with it
20:03:51 <geekosaur> if you putStrLn directly then you will get an error that putStrLn is String -> IO () but needs to be String -> ReaderT r m a
20:04:28 <geekosaur> liftIO says "there is actually an IO available, pass the IO action to the IO"
20:05:23 <geekosaur> in theory all the things that are in IO directly could be redone to look for a MonadIO context and lift themselves; I think there's even a package that does that (lifted-base maybe?)
20:05:31 <parrot> is it because in the ReaderT definition, there is an IO there ?
20:05:43 <geekosaur> but since they're directly in IO, they can only be used when you are actually in an IO context directly. if you just have one available somewhere, you need to use liftIO to pass te action to the IO
20:06:31 <parrot> Does it mean that the Reader will be inside an IO ?
20:06:43 <geekosaur> well, this is somewhat tricky. ReaderT has the following: instance MonadIO m => MonadIO (ReaderT r m) where liftIO = lift
20:07:03 <geekosaur> IO has a the instance: instance MonadIO IO where liftIO = id
20:08:01 <geekosaur> so if you define a ReaderT over a monad that is either IO, or is itself over IO, or is over something that is over IO, etc., then it gets a MonadIO instance, which lets you use liftIO and tells liftIO how to get to the IO
20:08:35 <geekosaur> (there's another step in there called MonadTrans, which is required by MonadIO; it's where that "lift" comes from.)
20:09:07 <parrot> so who really perform the IO action ?
20:09:12 <parrot> i mean the putStrLn
20:10:04 <parrot> For me ReaderT is a sequence of action with its do structure
20:10:20 <parrot> and the sequence includes the IO action: putStrln
20:10:47 <geekosaur> if Haskell were an OO language instead of a functional language, MonadIO would be a mixin and you could just run putStrLn directly. but Haskell is functional, so you need to pass IO actions on to the IO
20:10:48 <geekosaur> and liftIO is how you pass it through the monad chain to the IO
20:11:08 <parrot> and runReader will trigger ReaderT to perform the sequences
20:11:17 <geekosaur> right, but it's not just any sequence
20:11:31 <geekosaur> runReaderT knows how to run MonadReader sequences
20:11:45 <geekosaur> things like ask, asks, local
20:12:45 <geekosaur> it doesn't know about IO actions. but ReaderT can be stacked over another monad (that's what the "T" is about; it means "transformer"). in this case, the monad is IO
20:13:30 <geekosaur> but that does not mean runReaderT can itself do IO actions, it still can only do MonadReader actions. but since IO is being passed on in the transformed-monad slot, you can use liftIO to do stuff in IO
20:14:16 <parrot> anyway, one last thing about the ReaderT definition
20:14:37 <parrot> printReaderContent :: ReaderT String IO ()
20:14:51 <geekosaur> (or in this case you could use "lift" which passes an action to the transformed monad directly. this only works if it's ReaderT something IO though, not ReaderT something (StateT somethingElse IO). liftIO handles that case) 
20:15:38 <parrot> so this means printReaderContent will fetch a string from the environment, then perform an IO action, and get () as a result
20:16:04 <parrot> get () means that printReaderContent doesnt concludes with any value
20:16:15 <geekosaur> you can stick these transformers onto things to any arbitrary depth, although more than 2 or 3 gets annoyingly unwieldy even with the helpful stuff ghc provides to simplify it. liftIO is an example of one of those things, since you don;t have to kow how far along the chain to go to get to an IO
20:16:32 <geekosaur> yes
20:16:56 <geekosaur> liftIO is getting an IO () and turning it into a ReaderT String IO ()
20:17:23 <geekosaur> similarly if you wanted to use getLine, liftIO would get the IO String and give you a ReaderT String IO String
20:17:24 <parrot> for me putStrLn is IO ()
20:17:53 <geekosaur> and then <- will do the right thing and give you a String, since ReaderT Sring IO is what it expects (not IO)
20:18:03 <parrot> lisftIO will wrap putStrLn in ReaderT
20:18:05 <parrot> ?
20:18:43 <geekosaur> your "do" is in ReaderT String IO. this is not the same as being in IO. things that give you IO something do not work directly
20:19:12 <geekosaur> liftIO lets you pass an IO action to the IO, and presents the result as (in this case) ReaderT String IO instead of just IO
20:19:56 <geekosaur> since your "do" expects ReaderT String IO, you need the liftIO to "adapt" the IO in both directions so that it will be a ReaderT String IO instead
20:20:32 <parrot> can i just return putStrLn ?
20:20:51 <parrot> return will wrap it the right way
20:20:55 <parrot> i understand
20:21:18 <Welkin> why doesn't Data.Text.Read export readsPrec anymore?
20:21:34 <Welkin> I am having a problem while upgrading an older project
20:21:53 <parrot> anyway thanks geekosaur 
20:21:56 <geekosaur> return doesn't do the same kind of thing
20:22:04 <hypoon> Hi guys, I'm trying to organize my code in an elegant Haskell-ish way. I'm using ReaderT and Chan to try to build a somewhat complex application. I spawn multiple threads which I'm calling "services", and I'm trying to abstract this concept of a "service" so that a list of services can be started or stopped elegantly. Any suggestions?
20:22:38 <geekosaur> return "wraps" (not really) a pure value. ```return $ putStrLn "something"``` has type: ReaderT String IO (IO ())
20:22:53 <Welkin> oh
20:22:55 <Welkin> Text.Read
20:23:00 <Welkin> not Data.Text.Read
20:23:16 <geekosaur> which is not especially useful
20:24:02 <geekosaur> basically, ReaderT has 3 "slots" in it: the environment type, the transformed monad type, and the current value type
20:24:21 <parrot> the current value type...
20:24:24 <geekosaur> "return" does something with the third slot. "lift" and "liftIO" do something with the "second* slot
20:24:33 <hypoon> (My most recent attempt involved defining a "Service" class where all instances implement "start" and "stop", but then I had trouble organizing my services into a list.)
20:24:38 <parrot> wow that's great tip
20:24:48 <geekosaur> return () :: ReaderT String IO ()
20:26:39 <dmj`> @typ return :: a -> ReaderT String (ReaderT Int (ReaderT (Int,String) IO)) a
20:26:40 <lambdabot> a -> ReaderT String (ReaderT Int (ReaderT (Int, String) IO)) a
20:29:17 <joash> What's the use case of monad transformers with the free monad vs. just writing another interpreter?
20:34:17 <ReinH> hypoon: read Simon Marlow's book
20:34:33 <ReinH> Parallel and Concurrent Haskell. It's available for free online.
20:35:19 <dmj`> @pacpih
20:35:20 <lambdabot> Unknown command, try @list
20:35:31 <hypoon> ReinH: Ok, will do. Thanks!
20:44:14 <acertain> does STRef cause another indirection?
20:45:42 <acertain> or, I guess it does since it's a `data`
20:45:46 <acertain> does MutVar#?
20:47:33 <student> is it possible to feign mutation via continuation monad?
20:50:28 <shachaf> Yes.
21:02:09 <diggle> I read somewhere that ghc can write out type declorations automatically for me. Is this true?
21:02:44 <Cale> diggle: You can in ghci type :t followed by an expression, and it will tell you the type of the expression
21:03:10 <diggle> Oh.
21:06:37 <geekosaur> diggle, there are editor plugins that can do that, based on ghc-mod or ide-backend etc.
21:07:32 <geekosaur> ghc itself can be put into a warning mode where it tells you about any definitions you didn't give an explicit type (IIRC the actual type is included in the warning)
21:09:29 * hackagebot pandoc 1.16.0.2 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-1.16.0.2 (JohnMacFarlane)
21:10:25 <parrot> any haskell tool to convert epub to txt ?
21:10:47 <parrot> im surprised that pandoc cant do it
21:13:31 <Clint> parrot: you could use pandoc to convert it to something texty and then strip out the markup
21:13:55 <Clint> parrot: oh, nevermind, you can output plain
21:14:58 <geekosaur> I'd probably haveiit output as markdown or something
21:15:29 <cads> hey guys, from reading the Haskell in Industry listing, I've been learning that some companies are finding haskell useful for web services - they have a backend service written in haskell and a frontend written in javascript
21:15:52 <cads> that's kinda neat!
21:16:47 <geekosaur> sometimes the front end is written in haskell or a haskell-like language too (ghcjs; elm, fay)
21:16:55 <geekosaur> (allof which output javascript)
21:17:53 <cads> I've been really wondering about ghcjs's use in that capacity, but I can't find people writing much about it
21:18:38 <geekosaur> it's new enough that people are only just getting around to doing things with it; the supporting tooling (and sane-ish installation) have been lacking
21:19:00 <Welkin> cads: I do all my web stuff in haskell
21:19:10 <Welkin> I pretty much only do web actually
21:20:01 <Welkin> cads: Cale uses ghcjs + reflex-dom
21:20:13 <cads> geekosaur, lol, I do wish ghcjs didn't require the user to be a ghc/cabal timelord
21:20:17 <Welkin> you can ask him about it some time
21:20:28 <cads> awesome
21:21:10 <Welkin> one cool combination is servant for the backend and ghcjs for the frontent
21:21:18 <mgsloan> cads: stack makes it so that you don't need to be a cabal timelord
21:21:22 <Welkin> I just use yesod for most things though, so no js frontend for me
21:21:45 <parrot> i plan to choose Haskell for the backend for my startup compnany
21:21:49 <mgsloan> But things aren't very polished atm.  Folks are developing code against both old-base and improved-base ghcjs
21:22:01 <parrot> the front end is an App on Android or iOS
21:22:38 <cads> parrot, awesome, I hope it turns out well!
21:22:50 <parrot> Welkin, do you have any suggestions on the communication between Android app and the haskell backend ?
21:22:50 <mgsloan> cads: We've been generating our javascript from Haskell for > 3 years
21:23:02 <cads> Welkin, so you do most of your work with Yesod?
21:23:06 <Welkin> parrot: use servant if you want that
21:23:12 <Welkin> cads: yes
21:23:43 <parrot> i will take a look at it
21:24:07 <parrot> my idea is to use yesod and use web service api
21:24:15 <parrot> my vague idea
21:24:43 <acertain> should (unsafeCoerce :: State# s -> State# RealWorld) work?
21:26:28 <cads> mgsloan, so the way to go now commercialhaskell's stack project?
21:26:44 * cads is thinking of giving it another shot
21:29:04 <parrot> so is http://hackage.haskell.org/api provided through servant ?
21:29:18 <parrot> Welkin, ?
21:29:44 <cads> Welkin, reflexdom looks neat
21:30:00 <cads> wow, it uses nix package manager to build itself?
21:30:18 * cads feels like he just stepped into the future
21:30:44 <cads> I didn't know nix was working
21:36:51 <mgsloan> cads: Yeah, IMHO either stack or nix is the way to go for doing ghcjs development
21:37:13 <mgsloan> Otherwise it can be a real pain to get ghcjs compiled and booted
21:38:14 <mgsloan> Nix is nice because you don't have to build and boot ghcjs (takes a while)
21:39:30 * hackagebot postgresql-schema 0.1.10 - PostgreSQL Schema Management  https://hackage.haskell.org/package/postgresql-schema-0.1.10 (markfine)
21:40:07 <cads> Has anyone run across a wiki or page that kind of documents existing successes of ghcjs? It seems like I can go through stuff like try-reflex, or find neat tutorials like this one, which uses ghcjs to build an atom addon, of all things   http://edsko.net/2015/02/14/atom-haskell/
21:40:51 <cads> so far my two best ideas are continuing to trawl google for mentions of ghcjs, and starting to trawl github for same :D
21:41:12 <johnw> cads: setup a Google Alert for it
21:41:50 <mgsloan> I've only found tiny examples or bigger projects (reflex-dom, The Incredible Proof Machine, school of haskell)
21:42:14 <cads> mgsloan, gonna start playing with nix in a VM, I'm excited to learn that they have a working system (also it appears that they have had such for quite a long time already; I'm a bit embarrassed I'm so behind)
21:42:41 <cads> mgsloan, I'm gonna add all those to my GHCJS reference list, lol
21:43:13 <mgsloan> If you run into compilation errors, it's probably a mismatch in ghcjs-base version.
21:43:45 <mgsloan> Unfortunately, what's pretty much happened is that GHCJS and related packages have never officially been released, and so version numbers haven't been bumped, so you can't write proper constraints
21:44:24 <mgsloan> So folks are releasing source distribution snapshots of ghcjs, which in some sense constitute a release 
21:45:39 <mgsloan> Not sure how the improved-base vs old-base stuff works out with nix
21:45:50 <cads> crud, lol
21:46:28 <mgsloan> Ya, but GHCJS really is great stuff, people are using it in production and such
21:46:42 <cads> I hope you guys get it worked out! I think idiot-proofing the install could be a real big boost to ghcjs
21:47:03 <Janni> Hello.
21:47:05 <mgsloan> Just warning you so that when you do run into errors, you know why it's happening rather than thinking it's all garbage :D
21:47:46 <cads> well, I'll tickle the #ghcjs channel if I have real trouble
21:48:48 <cads> mgsloan, also, the incredible proof machine is amazing!
21:49:48 <mgsloan> Yes, yes it is :D lotsa educational fun, nomeata did a great job
21:49:55 <Janni> I recently received a (GHC 7.10 compatibily) patch for one of my packages from someone working at Google. He told me that the lawyers at Google would want me to add "Google Inc." to the list of copyright holders in the BSD-license file of the package. I have no idea whether I want that, what implications it has. Is this common practise? Does anyone here have an opinion on this?
21:50:24 <acertain> does `MutableByteArray# s (MutVar# s Foo)` work as expected?
21:50:56 <acertain> sorry, `MutableArray# s (MutVar# s Foo)`
21:51:33 <johnw> Janni: I'm not sure this is a question we can answer, unless there are lawyers here
21:52:42 <Janni> Well, I was assuming that it has occurred before to other people here and that maybe they have looked into it...
21:53:06 <johnw> personally, I would decline the patch
21:53:21 <johnw> if all it does is add 7.10 compatability, you can recreate that yourself
21:55:28 <cads> mgsloan, it reminds me of an expanded version of ezyang's logitext tutorial of the sequent calculus
21:57:16 <shanemikel> anybody a leksah user?
21:59:02 <cads> Janni, so for their contribution, they've asked you to turn google into one of the copyright holders of the whole code base?
21:59:41 <Janni> It's a small package, but yes.
22:00:44 <Janni> I'm fine with `citing' (what's the proper word here?) them for their contribution, but I was thinking that this is not quite appropriate.
22:01:19 <Janni> acknowledging their contribution
22:01:21 <ianhedoesit> Janni: I don't know the context at all, but were you thinking of 'crediting?'
22:01:27 <fr33domlover> Janni, it's BSD anyway, it's not like they get extra rights for that
22:01:34 <Janni> ianhedo: Yes, exactly.
22:02:06 <shanemikel> I think that would effectively make it impossible for you to change the licence, at the very least
22:02:33 <cads> Janni, sounds like at worst the employee could be in trouble for making the contribution on company time without first securing the copyright
22:02:50 <cads> mind you I'm super not-a-lawyer...
22:04:30 <shanemikel> doubt the employee would be in any 'trouble', I hear they give many engineers 20% of their working hours for free reign, experimentation, and such open source contribution, specifically for this reason
22:05:16 <shanemikel> so they can extend ownership claims all over the place
22:08:42 <MarcelineVQ> In my limited opinion if google needs your package that bad it can commit without claims. copyright for a compatabiliy patch is just weird
22:08:54 <shanemikel> why don't you start by asking the contributor why this is necessary, what google's interests are, and say you'd be happy to incorporate the patch, giving attribution, would he be willing to accept that without the copyright ammendmant
22:09:23 <shanemikel> couldn't hurt to open a dialogue with the contributor
22:09:51 <shanemikel> it could be this is common practice for them, even though they might settle for less
22:10:14 <cads> sauvin from #linux suggests #gnu could have an answer
22:10:36 <shanemikel> they'll probably just tell him to switch to gpl :)
22:11:02 <shanemikel> but, in that case, google'd have to give you that patch without negotiation, so.. there's that
22:11:14 <cads> hmm, this is an interesting question
22:12:42 <cads> if I have a library that I've licensed with an open source license, and someone gives me a patch but does not give me permission to include it in the code base, do I commit a tortious or illegal act if I simply include the code
22:13:36 <shanemikel> I certainly wouldn't apply the patch in the public repo until you've worked this out
22:13:42 <shanemikel> don't pull yet
22:15:02 <shanemikel> cads: probably the simple answer is yes, if they've told you they're not granting you the right of distribution, unless your licence prohibits that to begin with
22:16:15 <cads> shanemikel, yeah, that's likely. I'd love to understand more of the reasoning  and basic concepts here
22:17:28 <shanemikel> but if such a licence issue was never discussed, I'd be surprized to see it go beyond anything than a friendly agreement to remove said contribution
22:18:04 <shanemikel> of course, that may not be fun with a system like git
22:19:08 <cads> that would take some interesting git wizardry
22:19:47 <Janni> I was asked (not demanded) to include "Google Inc." only after I had received the patch and uploaded an updated version. So it's not issue of `extortion'.
22:21:33 <shanemikel> If they didn't want you to patch your library, they wouldn't have given it to you to begin with.. it's a win for them, because they don't have to keep patching a diverging base
22:21:56 <shanemikel> It couldn't hurt to talk to the guy
22:22:15 <Janni> Yes I guess so. I'll ask the contributor for a different way to credit his employee.
22:23:07 <Janni> Thanks for all the feedback. I have to go now. Bye!
22:28:10 <hypoon> ReinH: I can't thank you enough. "Parallel and Concurrent Programming in Haskell" is directly relevant to what I was asking... so much so that I'm moderately embarrassed that I hadn't read it before asking.
22:28:41 <johnw> hypoon: it's quite a good book
22:28:53 <ReinH> hypoon: :)
22:29:22 <ReinH> johnw: that's a whole couple categories of tough questions I no longer have to try to answer :)
22:29:56 <vigs> Hi there! I'm just getting into Haskell, and I've gotta say, it's been a blast. Figured I'd hop in here, since I've heard good things about this channel.
22:30:04 <johnw> vigs: welcome
22:30:13 <vigs> Thanks!
22:30:13 <johnw> vigs: glad you're enjoying the experience
22:31:20 <vigs> I'm in my final year as an undergrad and I'm taking a class on algorithms. My professor doesn't care what language we use, so I figured I'd learn Haskell. It's been on my radar for a while.
22:31:51 <hypoon> johnw, ReinH: I haven't read enough to comment on its quality as a whole, but I'm liking everything I've read so far.
22:31:55 <johnw> vigs: his lectures may use imperative algorithms, be aware of that
22:32:12 <cads> wow, it's by simon marlowe, is only 2 years old, and covers a library that does GPU accelerated computing
22:32:20 <johnw> which, while you can simulate easily enough, may induce some mismatch between your language and what he wants you to learn
22:32:35 <cads> and it's available to read for free online!
22:33:33 <vigs> johnw: My professor comes from a mathematical background; she's not a programmer by any means. So far, the translation from lecture notes to haskell has been easy enough.
22:33:44 <johnw> ok, that sounds good then
22:34:15 <Axman6> yeah Marlow's book is amazing, well written, covers the basics, all the way through to implementation
22:35:29 <vigs> That said, I definitely spent a while trying to wrap my head around the syntax. 
22:35:55 <hypoon> Haskell has a few really good books out there. If only I could find equally good books for 800-level quantum statistical thermodynamics... I didn't do so well in that course.
22:36:51 <hypoon> vigs: I don't blame you. Haskell was one of the few languages where I couldn't "get the gist of" code samples before taking the time to learn it.
22:37:28 <hypoon> vigs: but it's definitely worth it in the long run, as long as you have enough time to learn it.
22:38:10 <vigs> hypoon: Depends on what "enough time" entails. I've got a project due tomorrow. ;)
22:39:08 <vigs> But definitely, it helped to get my head out of the C mindset for a lot of these concepts.
22:39:10 <shanemikel> there's also the obvious other angle.. if they seem really keen on being included in the copyright, you could offer to add them after they've continued to contribute to it.. as it stands the bsd licence isn't prohibitive to them in any way, they might as well own it now
22:39:45 <shanemikel> is he still here?
22:40:33 <hypoon> vigs: Oh. Without knowing where you're coming from, and being a somewhat green Haskell programmer myself, I'll have to defer to others in this channel about whether Haskell's a good idea for your project... :-/
22:41:39 <vigs> hypoon: Heh, no worries, I'm not here to ask for help (for now?)
22:42:57 <shanemikel> mindset is a funny figure of speech.. set of minds?
22:43:25 <shanemikel> I wonder what the morphisms would look like
22:44:15 <hypoon> vigs: I can tell you this... I started with Learn You a Haskell (learnyouahaskell.com), and I spent about a week reading through it (taking my time to maximize understanding).
22:44:55 <shanemikel> what was the original question?
22:45:12 <vigs> hypoon: I started with LYAH too, but I started bringing in other sources to supplement it. I really like LYAH, but some of the imprecise language led me down some confused googling sessions.
22:45:45 <vigs> shanemikel: as far as I know, there's no real question, we're just talking about haskell
22:46:27 <hypoon> shanemikel: I always thought of it more as "set" the verb, not the "noun". Or like changing a setting, I suppose.
22:46:32 <vigs> I liked the "Haskell for C Programmers" page on the wiki, and Real World Haskell is proving quite useful, too.
22:47:01 <rcyr> If you don't mind paying... the "haskellbook" is getting really awesome.
22:47:35 <shanemikel> it's not an easy paradigm to learn
22:47:59 <bob_v_h> pretty happy with graham huttonÂ´s book for starters
22:48:29 <shanemikel> link?
22:50:01 <hypoon> Just noticed that my productivity tanked over the past 20 minutes... time to get back to reading. Thanks again, ReinH.
22:50:33 <vigs> good luck!
22:51:09 <shanemikel> actually if you cant buy the haskellbook, the author no doubt took a lot of the material from the freely available sources he lists here https://github.com/bitemyapp/learnhaskell
22:51:11 <bob_v_h> http://www.cs.nott.ac.uk/~pszgmh/book.html
22:52:47 <travmon> Hey everyone! I am trying to install statistics with cabal and I am getting an error on line 15 of this paste. http://pastebin.com/xgf1wgzK any possible fixes? I am not sure what to do with that.
22:53:10 <shanemikel> bob_v_h: would you say this is targeted at people new to programming, functional languages, or just haskell?
22:53:43 <bob_v_h> new to haskell
22:53:55 <liste> travmon seems like you don't have GNU Scientific Library installed
22:53:59 <travmon> hstatistics*
22:54:07 <bob_v_h> think some basic knowledge of programming would help
22:54:44 <shanemikel> something I actually learned about pkg-config deps today
22:54:52 <bob_v_h> i followed an edx course largely based on the book to get started with haskell
22:55:03 <travmon> liste, thanks! I'll look into installing that on mac!
22:55:11 <shanemikel> if you take the name of the pkg-config package, the name of the metadata file describing that package is that with a .pc extension
22:55:36 <shanemikel> so, depending on your distro, you can find it if there's a way to search for which packages provide files by filename/path (that aren't yet installed)
22:55:58 <shanemikel> apt-file (debian), pkg-file (archlinux), and 'yum provides'
22:56:02 <shanemikel> (fedora/rhel)
22:56:40 <shanemikel> so you'd want to see which package provides gsl.pc
22:57:32 <liste> travmon if you're using Homebrew, "brew install gsl" should be enough
22:57:47 <travmon> liste, Yup! That just fixed it. Thank you for your help!
23:00:36 <shanemikel> teach a man to fish
23:00:53 <rcyr> And he'll smell like crap every evening?
23:00:59 <rcyr> Shit... wrong chan.
23:01:01 <rcyr> Sorry :/
23:01:08 <shanemikel> lol
23:01:22 <bernalex> that's actually rather true. I've worked at a wharf.
23:02:35 <hodapp> ...and he'll get unrealistic ideas about his own individualism?
23:05:57 <shanemikel> that stroke of pessimism is a little to broad
23:06:08 <shanemikel> (at least, for me)
23:06:35 <vigs> What's the best way to force evaluation to normal form? A cursory google search suggests seq might leave it in whnf.
23:07:29 <opqdonut> vigs: seq indeed leaves it at whnf
23:07:32 <opqdonut> vigs: look at Data.DeepSeq
23:07:43 <opqdonut> https://hackage.haskell.org/package/deepseq
23:07:43 <vigs> opqdonut: sure thing, thanks!
23:07:53 <cads> hodapp, lol, in ten years he'll think he was just a hard worker who made his own way in the world
23:12:45 <vigs> opqdonut: My buddy suggested just defining `deepseq = length . show` which might be exactly what I need for my use.
23:13:27 <vigs> Also, I had some weird permission issues trying to install packages with cabal I don't feel like debugging right now
23:15:53 <shanemikel> yeah, but considering laziness, you need to make sure and coerce the full evaluation of that function
23:18:11 <shanemikel> I'm sorry vigs, I've never tried to do such a thing, but this might be helpful https://ghc.haskell.org/trac/ghc/wiki/StrictPragma .. they refer to some 'bang pattern' that hints the compiler?
23:19:25 <vigs> shanemikel: I'm simply running some basic sort algorithms on lists of integers, so that seems slightly unnecessary
23:19:54 <shanemikel> no, you misunderstood.. the strict default is a language extension, but the bang pattern is in the language itself
23:20:13 <vigs> oh, huh
23:20:17 <shanemikel> but they refer to the 'bang pattern' on that page (and show an example)
23:21:24 <opqdonut> bang patterns only give you whnf
23:21:30 <opqdonut> they're just nicer syntax for seq basically
23:21:58 <opqdonut> vigs: if it is an integer list, I recommend sum. show is quite slow
23:22:09 <opqdonut> depending on the algorithm, just a length might be enough too
23:23:31 <vigs> oh, is it really? argh, I haven't felt the sting of being Shlemiel the painter in a while.
23:25:17 <vigs> For context in my situation: first project of an undergrad algorithms class, which is a variety of basic sorts. We've gotta graph the execution time of our sorts on large sets of data [10k..20k]
23:25:34 <Axman6> bang patterns are also no more part of the language than the strict extraction
23:25:38 <Axman6> extension*
23:25:59 <vigs> (which is why I'm trying to get the functions to fully evaluate)
23:28:31 <Axman6> if you're implementing classical sorting algorithms, you probably want to use something like the vector package (particularly the Unboxed module) and the ST monad
23:32:28 <vigs> Oh wow, cool!
23:32:46 <Axman6> so you can do actual mutation with values in C style arrays. trying to implement them using lists will give you runtimes exponentially worse than you should get for a given algorithm
23:33:28 <vigs> But for what it's worth, I already wrote my functions. I've just gotta time them now.
23:33:45 <Axman6> which algorithms did you implement?
23:34:38 <vigs> merge and selection sorts
23:35:05 <Axman6> mergesort is one that happens to work very well in Haskell =)
23:35:29 <shanemikel> posterchild of elegance, too
23:35:31 <vigs> I'm about 2 days into my Haskell excursion, but I was super excited when I understood enough to implement a selection sort by myself. :D
23:35:58 <Axman6> (Data.List.sort is implemented using merge sort, and laziness gives you the best case performance 'select k smallest elements' for free)
23:37:00 <vigs> merge wasn't too bad either, but I could definitely clean it up. E.g.â€”I'm guarding on length of the input list, rather than pattern matching for a list with 1+ elements.
23:37:57 <Axman6> yeah, you definnitely should not be computing the length of the input at all for mergesort =)
23:39:20 <vigs> I'm definitely gonna rework that one when I get the chance. But right now, I'm just trying to get the assignment done. (My professor doesn't even want to see our code, just the data points)
23:40:06 <Axman6> running length all the time could probably change it's bit-O complexity
23:41:10 <vigs> That's trueâ€¦poop. Well, one problem at a time. I'm still trying to tackle timing function execution.
23:42:34 <liste> @hackage criterion -- vigs, ofc it's important to learn to do that manually, but this may help in the future
23:42:34 <lambdabot> http://hackage.haskell.org/package/criterion -- vigs, ofc it's important to learn to do that manually, but this may help in the future
23:43:03 <liste> at least you can use that as a baseline to compare your own implementations
23:43:33 <shanemikel> apparently I'm lacking something in understanding of whnf, could someone suggest a resourse?
23:44:17 <vigs> liste: Thanks! I've been eyeing Criterion but I think there's a weird OS X bug where cabal doesn't have permissions to use /usr/bin/ar :(
23:59:03 <ReinH> vigs: that seems pretty unlikely
