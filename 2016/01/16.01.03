00:05:56 <ggVGc> given something like this, how could I do it witout the unsafe "get"? https://gist.github.com/2850aa0f71ed35ac14ce
00:06:07 <ggVGc> is there a way to embed in the type system that an array is non-empty
00:07:24 <ggVGc> like, randomSample :: NonemptyArray a -> Generator a, instead of sample :: Array a Generator (Maybe a)
00:07:42 * hackagebot pandoc 1.16 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-1.16 (JohnMacFarlane)
00:07:42 * hackagebot yst 0.5.1 - Builds a static website from templates and data in YAML or  CSV files.  https://hackage.haskell.org/package/yst-0.5.1 (JohnMacFarlane)
00:09:37 <KaneTW> you can do NonemptyList a = Cons a (NonemptyList a) | Unit a
00:14:47 <lambda-11235> Is it possible to do recursion in haskell without any named functions, not even fix, only lambda functions?
00:22:36 <ReinH> lambda-11235: only if you allow a helper newtype https://mail.haskell.org/pipermail/haskell/2006-September/018497.html
00:22:47 <ReinH> the usual y combinator won't typecheck
00:31:17 <lambda-11235> Interesting
00:33:29 <Cale> data Rec a = In { out :: Rec a -> a }
00:33:33 <Cale> y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
00:33:44 <Cale> Is the way I've usually seen it
00:33:50 <Cale> Similar in any case
00:35:34 <Hrk> Question about stack: Say I installed several packages with stack install <pkg>. If i just want to try out some of those packages I can start ghci using "stack ghci"
00:36:33 <Hrk> But what if I want to load some modules from the current dir? Like if I have two .hs files in the current directory and One imports Two?
00:37:06 <Hrk> If I do :l One i'm getting error :Could not find module 'Two’
00:42:46 <Hrk> Can someone please help with this? http://lpaste.net/148336
00:43:19 <Hrk> Is there no way to load existing module WITHOUT having to create new stack project?
00:47:43 <ianhedoesit> this doesn't help your problem at all, Hrk, but is Stack similar to python's virtualenv?
00:48:40 <Hrk> ianhedoesit: Sorry, I've no idea. I'm not python user :(
00:49:27 <ianhedoesit> hm. it basically just allows for multiple, standalone "light installs" for a minimal Haskell project, correct?
00:51:00 <Hrk> ianhedoesit: right
00:51:57 <ianhedoesit> neat.
00:52:42 <Hrk> ianhedoesit: It manages potential multiple installations of GHCI + bundles of mutually compatible packages
00:59:26 <parsnip> Hrk: i'm newber, but can you :l Two? 
00:59:48 <parsnip> oops, wrong channel
01:03:02 <Hrk> parsnip: You're right. Whe I do it like:  > :l One Two it's working fine
01:28:39 <argoneus> hello, I haven't found an answer to this
01:28:51 <argoneus> if I use a partial application of a function, does it execute as much as it safely can?
01:28:59 <argoneus> or does it always wait for the last argument before it starts doing something
01:30:07 <mniip> nothing executes until the result is demanded
01:30:09 <mniip> laziness
01:32:32 <Gurkenglas> afaik there is no way to force a function but applying it and forcing that.
01:34:04 <argoneus> ah, I see
01:34:19 * hackagebot wai-session-postgresql 0.2.0.1 - PostgreSQL backed Wai session store  https://hackage.haskell.org/package/wai-session-postgresql-0.2.0.1 (hc)
01:34:52 <haskell571> hello haskell newbie here
01:34:54 <Gurkenglas> Which is weird. Sometimes plugging undefined into a function will do some work before crashing. Shouldn't you be able to force that work?
01:35:04 <haskell571> i am trying to run gloss
01:35:09 <haskell571> but something weird is happening
01:35:18 <haskell571> i can compile and run a gloss example
01:35:23 <haskell571> but i can't run it in ghci
01:35:37 <haskell571> i get user error (unknown glut entry glutinit)
01:35:47 <haskell571> does anyone know how to fix this?
01:36:00 <haskell571> googling is only giving me library errors on windows
01:36:07 <jle`> argoneus: remember that applying functions doesn't execute anything, either
01:36:10 <haskell571> and i am on linux
01:36:16 <argoneus> jle`: right
01:36:23 <argoneus> haskell only calculates things when you want a concrete result
01:36:26 <jle`> so even fully applying functions doesn't cause any execution
01:36:28 <argoneus> else you couldn't really have infinite sets
01:36:43 <Guest45580> did usa intel supply isis with weapons like they did with al-qaeda to justify creating wars? 
01:36:43 <Guest45580> does the breakout of wars and violence in the middle east represent creative chaos usa declared to make in the middle east? 
01:36:43 <Guest45580> iraq&syria suffered too much.plz,send others my qs ,help to limit usa&israel aggression against others.
01:36:44 <jle`> even if you fully evaluate something, there is still no execution
01:36:56 <jle`> (potentially)
01:38:19 <haskell571> so no one can help with my gloss problem?
01:40:01 <Nik05> sorry o idea haskell571 
01:40:10 <Gurkenglas> You could try running it in a vm?
01:40:25 <haskell571> it works when compiled
01:40:42 <haskell571> only in ghci or with runhaskell it crashes
01:40:46 <haskell571> so what's the difference?
01:41:00 <haskell571> between compiling and running in ghci 
01:41:18 <haskell571> and it works in ghci for other people, I checked
02:30:44 <srhb> haskellbr-slack: There was a bug related to some version of GHC and Gloss. Are you on the latest?
02:46:42 <sphinxo> Hi i'm looking for some example code to show the great things in haskell to my coworker who has only really programmed in asm/c/cpp.  
02:57:47 <argoneus> sphinxo: tbh if he's only worked with those he'll be impressed with list comprehensions already
02:58:12 <sphinxo> like in pattern matching? ::
02:58:42 <sphinxo> ahh I know what you mean
02:59:21 * hackagebot yesod-dsl 0.2.1 - DSL for generating Yesod subsite to manage an RDBMS;  https://hackage.haskell.org/package/yesod-dsl-0.2.1 (TeroLaitinen)
03:09:22 * hackagebot wai-session-postgresql 0.2.0.2 - PostgreSQL backed Wai session store  https://hackage.haskell.org/package/wai-session-postgresql-0.2.0.2 (hc)
03:25:17 <srhb> sphinxo: It's so hard to point to a single good thing aside from visiting well-designed libraries, but one thing I like to show is how simple and powerful composition is in Haskell.
03:25:53 <srhb> sphinxo: For instance, explain what interact does and then show how you can compose a complex argument to it from simple functions.
03:29:23 * hackagebot buildbox 2.1.7.1 - Rehackable components for writing buildbots and test harnesses.  https://hackage.haskell.org/package/buildbox-2.1.7.1 (BenLippmeier)
03:44:37 <sphinxo> thanks srhb 
03:49:23 * hackagebot htaglib 1.0.1 - Bindings to TagLib, audio meta-data library  https://hackage.haskell.org/package/htaglib-1.0.1 (mrkkrp)
03:57:10 <argoneus> does Haskell's lazy evaluation mean that it can optimize things like fac(1000) / fac(999)?
03:57:37 <argoneus> or would that be too advanced 
03:59:11 <vektor> argoneus: that depends on your exact implementation of fac, if I'm not mistaken
03:59:28 <argoneus> vektor: assuming the regular recursive one
03:59:38 <vektor> it's not that simple.
03:59:46 <argoneus> Haskell probably doesn't see it's fac(n) * fac(n-1)... / (fac(n-1) ..., right
03:59:56 <argoneus> there's some sort of recursive call order
04:00:15 <vektor> You can design a memoized implementation of fac - i.e. you can define fac using a recursive definition, and define all facNumbers as a constant.
04:00:25 <vektor> Something like facNumbers :: [Integer]
04:00:34 <ggole> Seems tricky. An optimisation would have to be able to see that it was profitable to unfold one call but not the other.
04:00:35 <vektor> No parameters, no nothing. Haskell should be able to memoize that.
04:01:05 <lyxia> laziness doesn't seem to play a role in this anyway
04:01:29 <vektor> lyxia: Kinda does, I think. My list would be infinite, so laziness is required.
04:01:55 <vektor> I.e. when computing fac(1000) it computes the first 1000 entries of that list and leaves the rest alone. And when computing fac 999, it notizes it was already computed.
04:02:54 <argoneus> oh wow
04:03:02 <argoneus> and you can do all that in just a few lines
04:03:08 <argoneus> damn that's neat
04:04:44 <argoneus> hm
04:04:49 <vektor> argoneus: I think so... I'm not exactly confident it'll work just like that. I haven't managed to tbh. If it works, btw, that implementation would run in linear time because when computing fac 1000, it would compute fac 999 and fac 998 (the branching is the reason of exp runtime of primitive implementations)
04:05:05 <vektor> and for fac 999 it would compute fac 998 again, which was already computed, so it uses that.
04:05:15 <argoneus> https://wiki.haskell.org/Memoization#Memoization_with_recursion
04:05:22 <argoneus> could anyone explain the second line in the memoized version?
04:05:25 <argoneus> I thought !! was index
04:05:44 <vektor> You have a omitted parameter here
04:06:00 <argoneus> so it's equivalent to
04:06:19 <argoneus> memoized_fib x = map fib [0 ..] !! x ?
04:06:26 <argoneus> probably forgot parens somewhere there
04:06:32 <vektor> imagine it written like this: memoized_fib n = (map fib [0..]) !! n
04:06:34 <vektor> yeah
04:06:51 <argoneus> ohhh wait
04:06:54 <argoneus> this is actually super cool
04:06:55 <vektor> that's just "map fib over the natural numbers, and take the nth element"
04:07:02 <argoneus> it says "calculate fibonacci for all natural numbers"
04:07:07 <argoneus> which is impossible
04:07:09 <argoneus> but haskell is lazy
04:07:13 <argoneus> so it calculates it when you give it an index
04:07:16 <argoneus> daayum
04:07:23 <vektor> laziness allows you to map over an infinite list and take the nth element and it'll terminate as long as your mapped function terminates
04:07:35 <vektor> argoneus: Exactly!
04:07:42 <vektor> It's super cool like that
04:07:49 <argoneus> is there a reason why they chose to omit an argument?
04:07:54 <vektor> style
04:07:56 <argoneus> oh
04:08:01 <argoneus> so it's not wrong or anything ok
04:08:05 <vektor> No
04:08:18 <vektor> In this case it hinders readability imo
04:08:25 <vektor> But in other cases it is really neat.
04:08:26 <ggole> Isn't the point of the suggested optimisation to reduce fac x / fac (x - 1) to x, obviating runtime laziness or memosation machinery entirely? 
04:08:55 <argoneus> to fac(x) but yes
04:09:07 <argoneus> er
04:09:08 <argoneus> x, sorry
04:12:42 <ggole> Thinking about it further, the possibility of negative values or undefined make it unlikely that this could be found to be legal for the variable case
04:12:55 <ggole> (Or overflow, for Int.)
04:13:52 <ggole> Maybe with a clever range analysis and enough information about x.
04:21:13 <argoneus> oh wow, there's some cool stuff with infinite sets
04:21:26 <argoneus> [p*p, p*p+2*p..] this is actually valid?
04:23:21 <lyxia> > let p = 3 in [p*p, p*p+2*p ..]
04:23:24 <lambdabot>  [9,15,21,27,33,39,45,51,57,63,69,75,81,87,93,99,105,111,117,123,129,135,141,...
04:24:24 <argoneus> hm
04:24:24 * hackagebot free-vl 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/free-vl-0.1.0.0 (aaronlevin)
04:24:28 <ggole> argoneus: it's pretty simple, reall
04:25:45 <ggole> [a,b...] expands into enumFromThen a b, which takes a number and another number and constructs an infinite list starting at the first and increasing by the difference.
04:25:51 <vektor> argoneus: infinite sets are rather limited.
04:25:53 <ggole> Pretty low on the magic.
04:26:27 <vektor> exactly. it essentially gets reduced to a +n * delta
04:26:30 <bollu> It would be cool to have a template haskell plugin that searches OEIS or something
04:26:38 <vektor> with your first input being a and the second being a + delta
04:26:50 <argoneus> oh
04:27:01 <argoneus> so this probably won't work
04:27:02 <vektor> argoneus: however, you can expand easily: Enter list comprehensions.
04:27:37 <ggole> argoneus: were you hoping for ghci to infer the expansion of a power series or something?
04:27:38 <vektor> [formula n | n <- [0..], n /= 10] for example
04:28:00 <argoneus> let n = 2 in [(1+n), (1+n)^2]
04:28:03 <argoneus> > let n = 2 in [(1+n), (1+n)^2]
04:28:04 <lambdabot>  [3,9]
04:28:09 <argoneus> > let n = 2 in [(1+n), (1+n)^2..]
04:28:10 <lambdabot>  [3,9,15,21,27,33,39,45,51,57,63,69,75,81,87,93,99,105,111,117,123,129,135,14...
04:28:15 <argoneus> :(
04:28:23 <argoneus> so it's just a constant difference
04:28:33 <bollu> argoneus: yes
04:28:37 <vektor> I think you're doing it wrong here
04:28:49 <vektor> you're telling it to eval those two expressions and make a infinite list of them
04:28:53 <bollu> > take 10 $ [2^n | n <- [1..]]
04:28:55 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024]
04:29:06 <argoneus> $?
04:29:08 <argoneus> that's a new symbol
04:29:14 <argoneus> does it have to be there?
04:29:25 <ggole> No, it's just application
04:29:29 <bollu> no, not in this case
04:29:32 <argoneus> > take 10 [n^n | n <- [1..]]
04:29:34 <lambdabot>  [1,4,27,256,3125,46656,823543,16777216,387420489,10000000000]
04:29:42 <vektor> > let n = 2 in [(1+n)^x | x <- [1..]
04:29:44 <lambdabot>  <hint>:1:35:
04:29:44 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
04:29:48 <vektor> > let n = 2 in [(1+n)^x | x <- [1..]]
04:29:50 <lambdabot>  [3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,14348...
04:30:07 <argoneus> pretty cool
04:30:15 <argoneus> I like this language
04:30:24 <ggole> > [(1+n)^x | x <- [1..]]
04:30:27 <lambdabot>  [1 + n,(1 + n) * (1 + n),(1 + n) * (1 + n) * (1 + n),(1 + n) * (1 + n) * ((1...
04:30:34 <bollu> wait what?
04:30:43 <ggole> lambdabot's special magic
04:30:49 <bollu> how?
04:31:04 <ggole> It turns unbound variables into, uh, variables
04:31:08 <ggole> > x + y + 2 + 3
04:31:10 <lambdabot>  x + y + 2 + 3
04:31:13 <bollu> hm
04:31:36 <bollu> and because they're free it doesn't bother collapsing the (1 + n) ^ x ? 
04:31:39 <vektor_> Did it just disconnect me for writing \ for lambda in lambdabot? O.o or was that just chance
04:31:41 <hc> > take 2 [(1+n)^x | x <- [1..]]
04:31:42 <bollu> "free" in the sense of "no laws"
04:31:43 <lambdabot>  [1 + n,(1 + n) * (1 + n)]
04:31:46 <ggole> I think this works by having overloads for Num, etc, that know about this kind of symbolic expression
04:31:54 <bollu> nice
04:31:54 <hc> cool :)
04:32:07 <hc> > take m [(1+n)^x | x <- [1..]]
04:32:09 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘Expr’
04:32:09 <lambdabot>      In the first argument of ‘take’, namely ‘m’
04:32:09 <lambdabot>      In the expression: take m [(1 + n) ^ x | x <- [1 .. ]]
04:32:22 <ggole> Which you can see the type of right there.
04:32:29 <bollu> Expr
04:32:33 <vektor_> @type ($)
04:32:34 <bollu> hm, interesting
04:32:34 <lambdabot> (a -> b) -> a -> b
04:33:14 <bollu> > (1 + x) ^ 3
04:33:15 <lambdabot>  (1 + x) * (1 + x) * (1 + x)
04:33:26 <bollu> aww, too bad. I was hoping it would reduce it
04:33:35 <hc> > foldl (+) 0 [1,2,3,4]
04:33:36 <lambdabot>  10
04:33:38 <vektor_> argoneus: there you go: function $ parameter results in the function being applied to the parameter. The low priority of infix $ is what makes it neat: You can have the parameter be a more complex functionm call.
04:33:57 <hc> > foldl (\a b -> a+b) 0 [1,2,3,4]
04:33:59 <lambdabot>  10
04:33:59 <bollu> > print $ take 4 [1..] 
04:34:00 <lambdabot>  <IO ()>
04:34:02 <vektor_> > take 10 $ map (+1) [1..10]
04:34:04 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
04:34:07 <vektor_> > take 10 map (+1) [1..10]
04:34:09 <lambdabot>      Couldn't match expected type ‘(Integer -> Integer)
04:34:09 <lambdabot>                                    -> [Integer] -> t’
04:34:09 <lambdabot>                  with actual type ‘[a0]’
04:34:17 <argoneus> this is some dank spam
04:34:41 * hackagebot free-vl 0.1.1 - van Laarhoven encoded Free Monad with Extensible Effects  https://hackage.haskell.org/package/free-vl-0.1.1 (aaronlevin)
04:34:45 <vektor_> In the second case, it tries to call take (10, map, (+1), [1..10]) - to use c syntax
04:35:45 <argoneus> ah
04:35:55 <argoneus> so $ is kinda a low priority separator
04:36:27 <vektor> argoneus: yeah.
04:36:49 <Gurkenglas> What's this magic typing rule? https://www.reddit.com/r/haskell/comments/3z2xu9/difference_between_and/cyk4nj6?context=3
04:36:55 <vektor> argoneus: it's common if you chain function calls like map, fold, filter over a list - at least for me
04:37:16 <bollu> I prefer to do this:
04:37:21 <bollu> > let (|>) = flip ($)
04:37:23 <lambdabot>  <no location info>: not an expression: ‘let (|>) = flip ($)’
04:37:50 <bollu> > let (|>) = flip($) in [1..10] |> map (* 3) |> filter even
04:37:52 <lambdabot>  [6,12,18,24,30]
04:38:05 <vektor> bollu: How does it behave exactly...?
04:38:15 <vektor> what?
04:38:48 <bollu> vektor: (|>) :: a -> (a -> b) -> b
04:39:01 <bollu> so you can give it a value and a function that modifies it, which it then applies on the value
04:39:08 <bollu> it's useful because you can "chain it"
04:39:11 <vektor> > let (|>) = flip($) in [1..10] |> map (* 2) |> filter even
04:39:12 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
04:39:19 <vektor> that's a pity
04:39:29 <vektor> should've been empty....
04:39:41 * hackagebot free-vl 0.1.2 - van Laarhoven encoded Free Monad with Extensible Effects  https://hackage.haskell.org/package/free-vl-0.1.2 (aaronlevin)
04:39:45 <bollu> why?
04:40:04 <vektor> Well, intuitively, |> takes a value and a function on it.
04:40:18 <vektor> So I thought I'd chain the map and the filter.
04:40:41 <vektor> Wait...
04:40:41 <bollu> it did
04:40:45 <vektor> It didn't even filter at all
04:40:45 <bollu> it mapped first and then filtered :)
04:41:01 <bollu> you multiplied by 2, all the results were even
04:41:06 <bollu> read it from left-to-right
04:41:09 <vektor> > let (|>) = flip($) in [1..10] |> map (* 2) |> filter (not . even)
04:41:10 <lambdabot>  []
04:41:11 <vektor> I'm dumb
04:41:14 <vektor> there we go
04:41:19 <vektor> It filters correctly.
04:41:24 <vektor> > let (|>) = flip($) in [1..10] |> map (* 3) |> filter (not . even)
04:41:25 <lambdabot>  [3,9,15,21,27]
04:41:32 <vektor> yeah, works like a charm
04:41:40 <bollu> :)
04:41:49 <bollu> it's an F# operator
04:41:59 <vektor> I was thinking it was filtering *away* the even ones. :|
04:42:01 <bollu> the argument against it is that you can't "take it out of the pipeline"
04:42:31 <bollu> like, if you have f . g . h $ x, you can say phi = g . h, and then use f . phi
04:42:43 <bollu> which you can't do with (f |> g)
04:44:34 <vektor> honestly, that kinda stuff looks more like f $ g $ h x for me. So I'm not even map
04:44:41 * hackagebot free-vl 0.1.3 - van Laarhoven encoded Free Monad with Extensible Effects  https://hackage.haskell.org/package/free-vl-0.1.3 (aaronlevin)
04:44:45 <vektor> *mad - but I liked the type :D
04:46:06 <phaazon> hm
04:46:12 <phaazon> what is the DList’s cons?
04:46:14 <phaazon> cons? :D
04:46:15 <phaazon> :t cons
04:46:17 <lambdabot> Cons s s a a => a -> s -> s
04:46:20 <phaazon> dammit
04:46:24 <phaazon> :t Data.DList.cons
04:46:26 <lambdabot> a -> Data.DList.DList a -> Data.DList.DList a
04:46:30 <phaazon> ok then
04:49:43 <phaazon> :t Data.DList.append
04:49:45 <lambdabot> Data.DList.DList a -> Data.DList.DList a -> Data.DList.DList a
04:51:58 <quchen> append = <>
04:52:22 <phaazon> yeah, I know
04:52:26 <phaazon> I was actually looking for snoc
04:52:32 <ggole> Gurkenglas: http://stackoverflow.com/questions/9468963/runst-and-function-composition
04:52:53 <ggole> tldr: $ is special cased a bit
04:54:10 <vektor> So I've been thinking about whether there is a reasonable data type to represent human problem solving thought processes. I've come up with this: http://lpaste.net/148345 - what do you think, does that make sense? Could you fit even complex problems into that data type, if the three primitives support it?
04:55:04 <quchen> Gurkenglas: https://github.com/quchen/articles/blob/master/fbut.md#-has-special-powers
04:55:41 <sphinxo> Anybody got any ideas for a data type to represent a crossword puzzle (not including the clues, just the answer)
04:56:11 <vektor> sphinxo: Array maybe?
04:56:40 <quchen> I'd use Ix and Vector for that.
04:56:55 <sphinxo> Ix?
04:57:09 <vektor> Ix = Index
04:57:14 <sphinxo> Ahh ok
04:57:18 <quchen> The class Array uses to calculate the n-dimensional indices
04:57:25 <vektor> (Int, Int) is an instance of index
04:57:32 <quchen> But Array is old and has a pretty poor API
04:57:48 <quchen> Vector has great API, but no native Ix support.
04:57:58 <sphinxo> I was thinking something else to represent intersections
04:58:08 <vektor> https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector.html
05:00:17 <vektor> quchen: How would I do something like "array ((0,0),(10,10)) _ with vector?
05:01:00 <t7> did anyone read the "compiling lambda calculus" article on reddit a few days ago ?
05:01:53 <nkaretnikov> vektor: fromList?
05:02:05 <nkaretnikov> import Data.Vector as Vector
05:02:13 <nkaretnikov> Vector.fromList [...]
05:02:31 <nkaretnikov> that's supposed to be a qualified import but whatever
05:02:31 <vektor> nkaretnikov: I'm mostly concerned with the two-dim index.
05:03:21 <vektor> I'd have to use a type Vector (Vector a)?
05:04:03 * ggole cannot read "Ix" without being reminded of Dune 2
05:05:04 <quchen> vektor: You create a vector of sufficient size, and then index it via the Ix methods
05:06:18 <quchen> array (min, max) = vector (rangeSize (min, max))
05:06:52 <quchen> at i array = at (index i) vector -- where "at" is (!) for vector and for Array I don't know
05:07:39 <quchen> Eh,    array i array = at (index (min, max) i) vector
05:07:57 <quchen> One day someone will be fed up enough to write an IxVector package, but it hasn't happened yet :-)
05:08:18 <kaiyin> https://gist.github.com/kindlychung/76a2af883ac1774f77a2 Could anyone please help me with this? 
05:08:49 <kaiyin> I am having trouble finding the module Data.Text
05:09:09 <gpampara> Is there any recommended ways to handle protobuf in Haskell? I see there are a few options, all different and at different levels of completeness
05:09:16 <quchen> kaiyin: Did you mention text as a dependency in your .cabal file?
05:09:42 <kaiyin> quchen: I think I have installed text globally. 
05:09:50 <kaiyin> so that shouldn't matter?
05:09:52 <nkaretnikov> kaiyin: you could check
05:10:01 <nkaretnikov> kaiyin: ghc-pkg list
05:10:15 <quchen> It's installed globally, but your project doesn't know it depends on the text module. It knows that it depends on some "Data.Text" module without knowing what package that is in.
05:10:21 <knupfer> Why does hspec use a preprocessor and not TH?
05:10:24 <k_bx> kaiyin: you still need to list it to cabal, since any package might define Data.Text module (even your own), so it needs to know from which one to take this module
05:10:40 <nkaretnikov> knupfer: just a guess: to build on weird arches
05:11:02 <nkaretnikov> knupfer: or to reduce compilation times
05:11:08 <quchen> I mixed up "module" and "package" there a bit, but you get the idea. Anyway, solution: add text as a dependency in your .cabal
05:11:10 <knupfer> nkaretnikov: at least now, TH runs on nearly anything
05:11:22 <nkaretnikov> even on mips?
05:11:28 <knupfer> hmm
05:11:34 <nkaretnikov> last time i checked it needed ghci to run
05:11:39 <nkaretnikov> is it still the case?
05:11:47 <knupfer> I think no.
05:11:59 <knupfer> At least it works on arm where ghci doesn't worh.
05:12:00 <nkaretnikov> kn
05:12:05 <kaiyin> nkaretnikov: strange. apparently text is not installed, stack is refusing to install it? https://gist.github.com/kindlychung/76a2af883ac1774f77a2#file-list
05:12:21 <nkaretnikov> knupfer: it could be just a personal preference, really. sometimes writing th is a huge pain
05:12:39 <knupfer> Is the preprocessor run before TH code?
05:13:43 <nkaretnikov> kaiyin: no idea, try asking on #haskell-stack?
05:13:49 <nkaretnikov> knupfer: i don't know
05:14:17 <knupfer> nkaretnikov: Ok, thank you anyway.
05:27:12 <quchen> knupfer: "The preprocessor"?
05:29:23 <kaiyin> https://gist.github.com/kindlychung/c24e589911bb8f17cf95 Why doesn't {-# LANGUAGE OverloadedStrings #-} take effect here?
05:30:08 <kaiyin> It's supposed to lets us write string literals (such as "Hello, world!") and have them become Text values automatically?
05:31:16 <mauke> why do you think it's not working?
05:31:51 <lyxia> kaiyin: overloadedstrings applies to litterals
05:32:35 <lyxia> string here is a variable.
05:35:55 <kaiyin> ok
05:39:55 <ggole_> Ugh, the fromIntegral instance for Int silently truncates?
05:40:28 <Clint> ggole_: what else would it do?
05:41:06 <ggole_> Not silently truncate?
05:41:14 <ggole_> Fall over dead at the very least.
05:43:23 <srhb> ggole_: That sounds expensive.
05:45:48 <ggole_> The effect is that large literals are silently wrong, a la C.
05:47:10 <Clint> ggole_: sounds like a compiler warning would be more useful
05:49:09 <ggole_> I don't see how that could work in general
05:49:18 <ggole_> (In cases where you know the type already, yes.)
05:50:43 <nkaretnikov> ggole_: use the safeint package?
06:07:32 <nkaretnikov> can i somehow trick Template Haskell into accepting 'req' and 'handler' here? main = run port $ \req handler -> $(app req handler)
06:07:44 <nkaretnikov> even with 'dyn' it doesn't work
06:08:03 <nkaretnikov> i understand why it complains, but i still want a workaround :)
06:08:36 <nkaretnikov> by 'dyn', i mean: $(app (dyn "req") (dyn "handler"))
06:08:47 <nkaretnikov> that's pretty evil, but still fails :(
06:09:43 * hackagebot manifolds 0.1.6.3 - Coordinate-free hypersurfaces  https://hackage.haskell.org/package/manifolds-0.1.6.3 (leftaroundabout)
06:09:47 <mauke> what's app?
06:10:18 <nkaretnikov> doesn't really matter, but it's the second argument of 'run' from 'warp'
06:10:25 <nkaretnikov> err, my wrapper around that, really
06:10:26 <nkaretnikov> oh
06:10:38 <nkaretnikov> i can't get app to work either :)
06:10:44 <nkaretnikov> due to the same restriction
06:10:46 <mauke> what's its type?
06:11:17 <nkaretnikov> Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived
06:11:30 <mauke> that's not TH
06:11:37 <nkaretnikov> right: Request -> (Response -> IO ResponseReceived) -> ExpQ
06:11:48 <nkaretnikov> that's the type from the library i'm trying to wrap
06:12:00 <mauke> that type doesn't make sense to me
06:12:38 <Gurkenglas> Can you annotate the definition of app in your source with that type signature?
06:12:42 <nkaretnikov> is it better now? Request -> (Response -> ExpQ) -> ExpQ
06:13:28 <nkaretnikov> Gurkenglas: what do you mean by annotate? 
06:13:50 <nkaretnikov> i recently read about template haskell annotations (i think) on unsafeperform.io
06:13:58 <nkaretnikov> is it it?
06:14:06 <mauke> no
06:14:18 <mauke> you still have something compile time that depends on a request
06:14:22 <Gurkenglas> It's the "main :: IO ()" you put in the line above "main = ..."
06:14:24 <mauke> but requests come in at runtime
06:14:30 <nkaretnikov> mauke: right
06:14:36 <nkaretnikov> mauke: that's what i'm asking about
06:14:48 <nkaretnikov> mauke: let me ask differently
06:15:21 <nkaretnikov> mauke: do i need to reimplement all of warp to get to the point where i can define something of type ExpQ to get what i need?
06:15:30 <nkaretnikov> looks unlikely
06:15:37 <mauke> ???
06:16:01 <nkaretnikov> ugh, let me try again
06:16:17 <mauke> why do you keep changing your story?
06:16:23 <nkaretnikov> what?
06:16:58 <mauke> <nkaretnikov> Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived  <nkaretnikov> right: Request -> (Response -> IO ResponseReceived) -> ExpQ  <nkaretnikov> is it better now? Request -> (Response -> ExpQ) -> ExpQ
06:17:58 <nkaretnikov> sorry i don't have enough patience to continue, i'll try on my own
06:18:18 <mauke> <nkaretnikov> that's the type from the library i'm trying to wrap  <- what library is this?
06:19:44 * hackagebot dynamic-plot 0.1.2.0 - Interactive diagram windows  https://hackage.haskell.org/package/dynamic-plot-0.1.2.0 (leftaroundabout)
06:22:56 <Gurkenglas> mauke, https://hackage.haskell.org/package/warp
06:24:30 <mauke> I don't see app in there
06:24:59 <Gurkenglas> <nkaretnikov> err, my wrapper around that, really <- he defined app himself
06:25:22 <mauke> I don't see ExpQ in there either
06:26:22 <Gurkenglas> My guess is he is using TH to generate the code he wants in place of $(app req handler), and figured that app must return ExpQ if it is to generate something that must be wrapped in $()
06:29:44 * hackagebot hdr-histogram 0.1.0.0 - Haskell implementation of High Dynamic Range (HDR) Histograms  https://hackage.haskell.org/package/hdr-histogram-0.1.0.0 (joshbohde)
06:49:45 * hackagebot deepseq-generics 0.2.0.0 - GHC.Generics-based Control.DeepSeq.rnf implementation  https://hackage.haskell.org/package/deepseq-generics-0.2.0.0 (HerbertValerioRiedel)
06:54:45 * hackagebot stack-run 0.1.0.1 - An equivalent to cabal run for stack.  https://hackage.haskell.org/package/stack-run-0.1.0.1 (yamadapc)
07:00:10 <xplat> @unmtl StateT Text [] a
07:00:10 <lambdabot> Text -> [] (a, Text)
07:05:15 * hackagebot stack-run 0.1.0.2 - An equivalent to cabal run for stack.  https://hackage.haskell.org/package/stack-run-0.1.0.2 (yamadapc)
07:15:10 <xplat> another aeson annoyance -- it takes input in UTF8 specifically instead of Text
07:16:14 * hackagebot wavefront 0.5 - Wavefront OBJ loader  https://hackage.haskell.org/package/wavefront-0.5 (DimitriSabadie)
07:25:23 <xplat> is there any reasonable way to make an attoparsec ByteString parser parse Text instead?
07:26:19 <lynnard> some questions regarding compiler optimization: 1. if I define a big constant value, e.g., some giant list, will it be in the memory even if no function is using it? 2. if I put this big constant in a function's let/where, does each invocation of that function has to go through that list construction again?
07:28:32 <lynnard> ??
07:29:30 <srhb> lynnard: "It depends". For instance, that big constant value might never be evaluated, so it's just a thunk.
07:30:09 <lynnard> srhb: so that means it's still best to put the constant in 'global' scope so that if it gets evaluated, it's reused across functions
07:30:49 <srhb> lynnard: "It depends." Sometimes you want to recompute things, sometimes you want to spend the memory.
07:30:50 <lynnard> but I do wonder...is ghc not smart enough to evaluate a constant in a let/where only once across several invocations
07:31:00 <lynnard> okay
07:31:45 <srhb> lynnard: That doesn't sound very likely. How does it determine they're the same?
07:31:59 <srhb> There's also the question of actually delineating where to share and where not to.
07:32:58 <lynnard> mhh, layman's guess: if a definition is of kind * and it doesn't depend on any value input from the function, then we can reuse it (consider it the same in every invocation of the function)
07:34:05 <srhb> lynnard: Well, you should dive into the core and see what actually happens. My guess is no. :)
07:34:28 <srhb> I think it would be pretty hard to reason about if that kind of sharing "out of scope" happened.
07:37:42 <ggole_> What reasoning would it make difficult?
07:38:39 <aweinstock> ggole_: predicting how much space a program would use
07:39:32 <ggole_> You think it that would be easier if the constant was reconstructed each time?
07:40:00 <kaiyin> how is fmap defined for IO Monad?
07:40:10 <srhb> ggole_: I think it is, yes.
07:40:16 <srhb> ggole_: This way you can actually control it.
07:40:45 <ggole_> Hmm. I guess I can understand that argument, although I wouldn't want an implementation to actually do that.
07:41:38 <ggole_> (Manually hoisting every constant in your program would be abjectly ridiculous.)
07:42:02 <srhb> ggole_: Manually telling the compiler to not share out of scope seems even more perverse to me, but ah well. :P
07:42:40 <vx_ri> kaiyin not an expert, but I think it depends on the type of the () in IO (x)
07:42:44 <lyxia> if you want sharing you must make it explicit with a let-binding.
07:42:59 <kaiyin> vx_ri: for example, IO String?
07:43:00 <ggole_> I don't see any advantage to that.
07:43:54 <vx_ri> kaiyin playing with the repl now
07:44:17 <vx_ri> kaiyin check this out IO (Integer) toy example: (\x -> x+1) <$>  (putStrLn "hi" >> return (4 :: Integer))
07:44:58 <vx_ri> Now here is IO (String)
07:45:02 <vx_ri> (\x -> x ++ " blah") <$>  (putStrLn "hey" >> return "there")
07:45:42 <srhb> ggole_: But it certainly can float things out in some cases. I'm not quite sure which, the optimization passes are a bit complicated.
07:45:50 <vx_ri> this is good practice since I'm working through the functor chapter
07:46:04 <kaiyin> vx_ri: yeah. do you know how i can find out the implementation of <$> (or fmap)? 
07:46:21 <ggole_> I imagine it floats anything constant, because why would you reconstruct each time?
07:47:30 <vx_ri> kaiyin any particular reason? it seems to just pass control to the fmap of the x type in  IO (x) but maybe I don't get what you're trying to do here
07:48:09 <Ainieco> hello, is there something like sidekiq for reliable background job processing for haskell?
07:48:38 <vx_ri> i imagine it's like when you wrap up any type as a functor like Maybe or Either
07:49:39 <kaiyin> vx_ri: yeah, for anything to be a functor, you need to _define_ the fmap function, right?
07:51:31 <vx_ri> but in mot cases you don't do much in the definition, you just apply the function to the value you're wrapping. so the type of the wrapped value is where the meat of the implementation is.
07:52:00 <vx_ri> maybe you're looking for something deeper than my understanding.
07:53:44 <srhb> ggole_: http://research.microsoft.com/apps/pubs/default.aspx?id=74092 -- this might be of interest
07:54:05 <srhb> ggole_: Woops, here's the actual text: https://www.google.dk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwipiuX__43KAhUEEywKHd3CBRMQFggeMAA&url=http%3A%2F%2Fresearch.microsoft.com%2Fpubs%2F67060%2Ffloat.ps.gz&usg=AFQjCNFqAOOpCMtpwSMmO3eFD0GcH0PsIQ&sig2=K4hd7uLk5RnJZ1hwlURN3Q
08:01:45 * hackagebot java-poker 0.1.0.0 - The etude of the Haskell programming  https://hackage.haskell.org/package/java-poker-0.1.0.0 (tobynet)
08:07:16 <ggole_> srhb: hmm, seems quite different from scheduling strict langauges
08:07:54 <ggole_> I didn't see anything about constants, but an interesting read
08:17:18 <Big_G> Is anyone here going to compose conf?
08:19:14 <texasmynsted> weird, I have never heard of Stack https://www.haskell.org/downloads#stack
08:19:47 <texasmynsted> is it like cabal that does cross compiles for other platforms or something?
08:20:54 <jmcarthur> texasmynsted: It's relatively new. It's not 100% clear whether it should be a long term cabal-install replacement, but for now I consider it superior. It has great support for sandboxes, can install and manage multiple versions of ghc for you, and makes it easy to work with stable sets of packages.
08:21:19 <jmcarthur> texasmynsted: I don't even have a ghc system package installed anymore. I just installed stack and use it to manage everything haskell.
08:22:04 <texasmynsted> interesting
08:22:32 <texasmynsted> I wonder if, when I am somehow able to uninstall my existing Haskell install, if I should use stack rather than the macports Haskell platform.
08:23:07 <jmcarthur> You could always just try stack and see if you like it. You don't have to uninstall everything else first.
08:23:15 <c_wraith> khole: I had an implementation in mind that was more like:  wait by reading from a TVar () and then using retry.  signal by writing to a TVar ().
08:23:18 <texasmynsted> In the past I had trouble keeping package aligned with the versions that I needed…  Need one pandoc for one thing and a different one for something else.
08:23:44 <jmcarthur> Yeah, that's a problem stack tries to solve.
08:23:48 <c_wraith> khole: the contents of the TVar don't actually matter.  Only that it's been read from or written to.
08:24:12 <jmcarthur> But to be fair, cabal-install's sandboxes can kind of handle that situation too. Stack is just more convenient for that particular issue.
08:24:38 <texasmynsted> So haskell platform is more of a collection of packages and stack is a build manager or something?
08:25:05 <jmcarthur> Stack also knows how to share already-built libraries across multiple sandboxes, etc. Build times tend to be pretty low as a result.
08:25:32 <texasmynsted> um ok.  Sounds like a win.  Why would I not use it?
08:25:45 <wedens> what's the difference between classy-prelude and basic-prelude? more typeclasses?
08:26:01 <c_wraith> texasmynsted: desire to use versions of packages that stack doesn't have.
08:26:33 <jmcarthur> texasmynsted: The main reason not to use it might be that it's kind of new, though not *that* old now. Also, cabal-install might gain its functionality eventually, and stack might be deprecated then, but I haven't heard of any actual work in that direction yet.
08:26:46 * hackagebot wavefront 0.5.1 - Wavefront OBJ loader  https://hackage.haskell.org/package/wavefront-0.5.1 (DimitriSabadie)
08:26:49 <jmcarthur> c_wraith: It's a bit inconvenient, but you can just add the version you want to use in your stack.yaml
08:27:05 <c_wraith> jmcarthur: if I have to do that for every package in my project, what's the gain?
08:27:25 <jmcarthur> c_wraith: If it's all one project, just share a stack.yaml for them all.
08:27:26 <texasmynsted> hm
08:27:26 <texasmynsted> if it is uninstallable then I suppose I can just try it,
08:27:30 <aweinstock> kaiyin: IO is defined at the end of this: https://downloads.haskell.org/~ghc/7.0.4/docs/html/libraries/ghc-prim-0.2.0.0/src/GHC-Types.html
08:27:51 <texasmynsted> Looks like there are two defects on el Capitan right now . . . 
08:27:53 <aweinstock> kaiyin: it's similar to the definition of ST, whose fmap is defined here: https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.ST.html
08:29:29 <texasmynsted> Is it possible to install the "haskell platform" then install stack that way?
08:29:34 <jmcarthur> I meant to say "not *that* new now"
08:29:54 <aweinstock> kaiyin: so IO's fmap would look something like: fmap f (IO g) = IO (\oldstate -> case g oldstate of (# newstate, result #) -> (# newstate, f result #)
08:30:08 <aweinstock> )
08:30:19 <jmcarthur> texasmynsted: I would say that stack subsumes the haskell platform, and in fact upcoming/current (not sure which) haskell platform just gives you a convenient way to install stack and you go from there.
08:30:44 <texasmynsted> oh heh
08:31:13 <texasmynsted> No wonder I have not heard of this, it has been around only since June 2015.
08:31:17 <jmcarthur> texasmynsted: If the purpose of the Haskell Platform is to provide a stable set of packages known to pretty much work with each other, stack already does that with Stackage.
08:31:38 <jmcarthur> texasmynsted: That's not the only reason HP exists though.
08:32:09 <jmcarthur> texasmynsted: A primary goal of HP is also to kind of recommend some packages as "standard". Stack doesn't quite do that.
08:32:17 <texasmynsted> ok.  so then sounds like I have a plan.  1. find a way to uninstall the existing haskell that has no uninstaller 2. Install stack
08:32:38 <jmcarthur> Well, try (2) first. Worry about (1) later.
08:32:55 <jmcarthur> What if you don't like stack?
08:33:39 <vx_ri> the haskell platform claims another victim =/
08:37:34 <bergmark> HP comes with an uninstall script, doesn't it? at least on os x iirc...
08:41:34 <texasmynsted> This machine I am talking about changing the haskell install was installed by a binary tar ball or something.  There is no uninstaller
08:45:30 <texasmynsted>  Ha, or I could have both Haskell platform and stack.  Install haskell platform and use "cabal Install" to install stack
08:46:00 <texasmynsted> I wonder if that is a bad idea?
08:47:03 <luigy> texasmynsted http://docs.haskellstack.org/en/stable/README.html#how-to-install
08:47:56 <texasmynsted> yes it seems it is _a way_ but it does not say if it is a _good_ way or not.
08:48:15 <luigy> "Note: if you are using cabal-install to install stack, you may need to pass a constraint to work around a Cabal issue: cabal install --constraint 'mono-traversable >= 0.9' stack."
08:48:52 <texasmynsted> yeah, so it has a constraint, is that so bad?
08:54:45 <qmm> if Bool is an example of a nullary type constructor, is there an example of a non-nullary type constructor?
08:55:06 <mauke> Maybe
08:55:34 <qmm> why is Bool nullary and Maybe isn't?
08:55:57 <mauke> Maybe takes an argument
08:56:08 <qmm> thank you mauke 
08:59:17 <texasmynsted> sigh, available from mac brew but not macports…
08:59:20 <wedens> does it makes sense to have strict fields "by default"?
08:59:33 <texasmynsted> homebrew whatever 
09:00:08 <EvanR> use ghcformacosx
09:00:11 <bergmark> wedens: common advise is to have all fields strict by default and all functions lazy by default
09:00:37 <c_wraith> I've never understood that advice.
09:00:50 <c_wraith> It's best to have fields strict if they mean something strict.
09:00:52 <EvanR> all strict fields will blow up in your face pretty often
09:01:11 <texasmynsted> EvenR, is that a macport ghcformacosx?
09:01:17 <EvanR> texasmynsted: no
09:01:28 <bergmark> EvanR: when does it blow up?
09:01:41 <EvanR> cyclic data
09:01:42 <wedens> what's the point of lazy fields in some type that is filled from DB?
09:01:46 <texasmynsted> what is it?
09:01:51 <EvanR> possibly bottom data
09:01:54 <texasmynsted> oh this https://ghcformacosx.github.io/
09:02:11 <bergmark> texasmynsted: i advise installing ghc through stack, removes one more thing to download
09:02:26 <wedens> EvanR: I think it's specific case, where laziness should be explicit and commented ;)
09:02:28 <EvanR> doesnt it add one more too? stack?
09:02:34 <bergmark> EvanR: ok sure, but I don't agree with "pretty often"
09:02:47 <luigy> but arent there precombiled binaries?
09:03:16 <jmcarthur> I think there is no good heuristic to decide whether to make a field strict. Just take the five seconds or so to think about it.
09:03:20 <luigy> https://github.com/commercialhaskell/stack/releases
09:03:21 <EvanR> bergmark: also if the data is a lot larger than the thunk, youll waste space
09:03:22 <texasmynsted> says only tested on 10.10
09:03:38 <EvanR> so strict definitely makes sense for small fields
09:03:38 <jmcarthur> It may take more than five seconds if you're new, to be fair, but that doesn't mean you should be using a heuristic.
09:03:50 <bergmark> texasmynsted: i assumed you were going to use stack anyway for some reason...
09:04:04 <EvanR> that you will definitely need
09:04:23 <texasmynsted> I plan to
09:04:51 <texasmynsted> I just want to remove what I have and re-install in some maintainable way
09:04:56 <bergmark> i'm not sure how easy it is to use stack-installed-ghc outside of stack, but presumably it's just adding some user-level directory to PATH
09:05:15 <EvanR> or use ghcformacosx
09:05:28 <texasmynsted> that is why I was thinking haskell platform, then cabal install stack
09:05:29 <luigy> bergmark exactly it
09:05:50 <mag__> Hello
09:05:56 <mag__> Quick question
09:06:03 <bergmark> texasmynsted: you can download a stack binary
09:06:05 <mag__> :t intersperse
09:06:06 <EvanR> haskell platform was weird for me on osx, but that was a couple years ago
09:06:06 <lambdabot> a -> [a] -> [a]
09:06:15 <mag__> :t intersperse intercalate
09:06:17 <lambdabot> [[a] -> [[a]] -> [a]] -> [[a] -> [[a]] -> [a]]
09:06:26 <bergmark> http://docs.haskellstack.org/en/stable/README.html
09:06:33 <mag__> what happen there?
09:06:35 <mag__> :-|
09:06:46 <monochrom> function application happened there
09:07:04 <mag__> I see a monster, that's what I see
09:07:04 <jmcarthur> mag__: The type variable a in the type of intersperse took on the type of intercalate.
09:07:26 <mag__> mmh
09:07:45 <monochrom> how about I show you an example
09:07:49 <jmcarthur> mag__: So that created a function whose input is a list of functions and whose output is a list of functions that has been interspersed with the intercalate function
09:07:51 <monochrom> :t show ()
09:07:53 <lambdabot> String
09:08:08 <mag__> oh!
09:08:09 <texasmynsted> The only problem with a stack binary is does it have and upgrade path and or an uninstaller?
09:08:48 <texasmynsted> wow, now I have to figure out what halcyon and kronos haskell are Heh
09:09:13 <mag__> Thanks : jmcarthur and monochrom
09:09:27 <jmcarthur> texasmynsted: stack can self-upgrade, but i don't know how it works. i think it just installs the new version in ~/.local/bin and doesn't replace the global version.
09:10:43 <texasmynsted> I am really interesting in maintenance given that I have to uninstall an existing haskell that has no uninstaller.  Do not want to be in this same place again.
09:11:05 <jmcarthur> why do you have to uninstall it?
09:11:14 <jmcarthur> also, how did you install it?
09:11:24 <jmcarthur> maybe there is actually a way to uninstall
09:16:10 <texasmynsted> I tried to upgrade my cabal-install and got so many thousands of these pages that I can't even scroll back to the start…  https://gist.github.com/mmynsted/70f2f40319d65ff4f759
09:16:30 <texasmynsted> Warnings and errors.
09:16:38 <texasmynsted> Something must be broken
09:18:24 <bergmark> i know that error, but i forget why it happens...
09:19:24 <zachk_> texasmynsted: pipe it through less :D 
09:19:28 <zachk_> then you can read the first line
09:19:31 <texasmynsted> Heh
09:19:50 <texasmynsted> I can try this again and see if I get the same errors.
09:19:54 <bergmark> texasmynsted: are you on os x?
09:20:10 <jarvin> Does haskell have classes or Structs 
09:20:40 <jmcarthur> jarvin: no
09:20:42 <Xe> not in the OOP way
09:20:45 <Xe> it has typeclasses and records
09:20:57 <texasmynsted> nothing useful
09:20:58 <Xe> a typeclass is different from a java class though
09:21:05 <jmcarthur> jarvin: You can implement such things yourself, but it's usually better not to think of it that way even if you do it.
09:21:24 <zachk> jarvin, haskell has records and TypeClasses, which aren't like classes from OO much at all 
09:21:25 <texasmynsted> that machine is 10.10.4 
09:21:28 <jmcarthur> jarvin: Records are sort of like structs, at least.
09:21:43 <zachk> you have a 3 byte Ip texasmynsted ? how the... 
09:22:10 <jmcarthur> jarvin: But "struct" to me implies a lot of control over memory layout. Haskell doesn't give you as much control over memory layout as a C-like language, unless you are using the foreign function interface.
09:22:12 <bergmark> texasmynsted: this problem was fixed in... ghc 7.6 i think? I'm not sure how you are running into it now. But anyway, why not download a cabal-install binary instead?
09:22:18 <texasmynsted> zachk, mac os x 10.10.4 
09:23:11 <zachk> texasmynsted oh 
09:23:20 <texasmynsted> bergmark, I guess because it is unclear to me how I installed cabal and cabal-install originally.
09:23:30 <jarvin> Do functions have the highest priority
09:24:03 <zachk> parenthesis do
09:24:18 <jmcarthur> jarvin: I don't understand the question. Do you mean precedence?
09:24:30 <jarvin> sure
09:24:43 <jmcarthur> jarvin: Parens win, of course. Also, record syntax binds more tightly than function application, which can be a little confusing.
09:25:19 <texasmynsted> Since I am not sure how cabal and cabal-install where installed it seemed like it might be a good time to uninstall and re-install in some more maintainable way.
09:25:22 <jmcarthur> jarvin: e.g.   f foo { bar = baz }   parses as   f (foo { bar = baz })
09:25:37 <texasmynsted> If stack is that way, great.  If Haskell Platform is that way great.
09:25:47 <texasmynsted> I _do_ want to use stack, fwiw.
09:26:08 <jmcarthur> texasmynsted: you could just download a stack binary, *not* install it, use it to install stack, then delete the binary you downloaded
09:26:22 <jmcarthur> if that level of "cleanliness" is what you are after
09:26:44 <jmcarthur> but honestly, hard drives are big these days, so i don't understand why it's so important to be able to uninstall it
09:27:19 <jmcarthur> texasmynsted: I should note that when you use stack to install something, it just goes into your home dir, not a global path.
09:27:28 <texasmynsted> I just am unlikely to remember how I installed this thing so if a problem comes up I want to know how to address it
09:27:29 <EvanR> ive never bothered with being able to uninstall stuff installed via makefiles and what not
09:27:40 <EvanR> so much blood and sweat has gone into that
09:28:13 <texasmynsted> hmmm.  I wonder what that would do to my pandoc install that scrivner uses...
09:28:39 <jarvin> The haskell compiler may have nsa backdoor
09:28:49 <EvanR> doubt it
09:29:02 <texasmynsted> LOL
09:29:06 <EvanR> but theres no way to prove it
09:31:13 <jarvin> Haskell is too easy
09:33:10 <zachk> jarvin how so? 
09:33:11 <texasmynsted> ok, after reading about halcyon (halcyon.sh) I am more confused.
09:33:43 <jarvin> I was writing a  compiler for haskell that translate into java
09:34:45 <jarvin> not that hard
09:34:45 <texasmynsted> So is halcyon something so one can deploy haskell apps to DO and Heroku?
09:35:42 <EvanR> does it use exception catching style, call by exception throwing
09:37:50 <texasmynsted> LOL kronosnotebook looks interesting but the "complete demo" is a 404.
09:37:54 <texasmynsted> http://www.kronosnotebook.com/haskell
09:41:48 <jarvin> when ever I don't want to use my brain I use python
09:42:09 <monochrom> whenever I don't want to use my brain, I go to sleep
09:42:25 <Phyx-> lots of trolls in #haskell these days :)
09:42:28 <alexa_> whenever I want to use my brain I can't because I'm tired
09:42:49 <zachk> whenever I don't want to use my brain, the insomnia kicks in and the voices in my head put me under review and I hear modem sounds that aren't there, or are they? 
09:42:53 <Phyx-> whenever I don't want to use my brain I play mario
09:42:59 <Phyx-> mostly reflexes at this point
09:43:08 <zachk> one can never play too much mario 
09:43:10 <monochrom> ah, I see, Phyx- you're right
09:43:20 --- mode: ChanServ set +o monochrom
09:43:25 --- mode: monochrom set +b *!*@pool-108-19-173-17.dllstx.fios.verizon.net
09:43:25 --- kick: jarvin was kicked by monochrom (jarvin)
09:43:30 --- mode: monochrom set -o monochrom
09:43:30 <zachk> what do you mean by trolls? trolling for conversation or just being ugly? 
09:43:39 * zachk blinks 
09:44:12 <Jeanne-Kamikaze> by his definition of easy, assembly must be very easy
09:44:31 <Jeanne-Kamikaze> anyway...
09:44:35 <Phyx-> zachk: conversation I find fine, but he was clearly trying to get a rise :)
09:44:42 <zachk> oh 
09:45:12 <alexa_> Criticism of python will not be tolerated in #haskell :#
09:45:24 <hodapp> 9_9
09:46:12 <Phyx-> lol
09:46:48 <Ainieco> how to use make "cabal install -fdevelopment" but for "cabal build"?
09:46:48 * hackagebot eventloop 0.5.1.0 - A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.  https://hackage.haskell.org/package/eventloop-0.5.1.0 (sebaslafleur)
09:47:29 <monochrom> Ainieco: break it down into "cabal configure -fdevelopment" and "cabal build"
09:47:38 <Ainieco> monochrom: ah, okay, thanks
09:47:51 <monochrom> http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#install
09:48:07 <Phyx-> what's -fdevelopment? can you have in-flight/devel packages on hackage these days?
09:48:33 <Ainieco> Phyx-: -f is flag
09:48:57 <monochrom> -f passes author-defined flags. author-defined flags are defined in *.cabal files
09:49:18 <Phyx-> monochrom: ah! makes sense
09:49:21 <monochrom> they could be named "development" or "underdevelopment" or "foo"
09:49:53 <Phyx-> it's basically -D then except for cabal packages?
09:49:58 <monochrom> yeah
09:50:35 <Phyx-> interesting.. could be useful, thanks!
10:02:43 <alexv111> Can I install GHC globally using Stack?
10:04:11 <zachk> maybe if you run it as superuser
10:08:51 <aweinstock> zachk: that sounds risky
10:09:44 <aweinstock> (not about stack specifically, but general unixy "don't run things as root that don't need to be")
10:10:34 <zachk> but if you want an executable installed globally, isn't that the best/only way to do it? 
10:10:53 <monochrom> if you run as superuser, there is still a possibility of "install GHC for root's account" as opposed to globally
10:11:13 <monochrom> indeed, that's what "sudo cabal install" does
10:12:16 <monochrom> you don't need stack's help to install GHC globally
10:12:45 <aweinstock> installing things globally requires root, but installing as root doesn't automatically install things globally unless the installer takes care to do that (and maybe has an option for that)
10:13:43 <aweinstock> e.g. with makefiles/autoconf, the default prefix is /usr, which installs things globally, and hence why "make install" requires root
10:14:29 <aweinstock> but you can also use "./configure --prefix=/home/$USERNAME", and then "make install" doesn't require root
10:17:50 <monochrom> there is almost nothing as ironic as "install globally so everyone can use" vs "install to root's account so no one can use"
10:24:37 <pavolzetor> http://lpaste.net/148351
10:25:19 <pavolzetor> I am trying to understand what GHC does under the hood
10:25:46 <pavolzetor> since about half of the runtime is spent in GC
10:26:09 <pavolzetor> so my question is, why does not GHC convert the above function to something like
10:26:34 <pavolzetor> dot (AB x y) (ABC x' y' _) = x*x' + y*y'
10:26:36 <pavolzetor> ?
10:26:47 <pavolzetor> but instead it calls the ab function=
10:27:30 <aweinstock> try -funbox-strict-fields?
10:27:35 <jmcarthur> pavolzetor: This is such a quick program that I can't imagine GC statistics even matter.
10:27:57 <monochrom> how do you go from "half of the runtime is spent in GC" to "it calls ab"?
10:28:03 <pavolzetor> thanks, let me try, I am still figuring out the assembly output
10:28:17 <jmcarthur> pavolzetor: There's just not enough to measure here.
10:28:40 <pavolzetor> jmcarthur: I have identified possible wasteful allocation in the program, this is just that part isolated
10:28:52 <jmcarthur> pavolzetor: Are you building with optimizations?
10:28:57 <pavolzetor> -O2
10:29:08 <jmcarthur> pavolzetor: Also, you can dump core to see a perhaps easier to read intermediate representation.
10:29:19 <jmcarthur> pavolzetor: -ddump-simpl
10:29:50 <pavolzetor> thanks, much nicer than -ddump-ds
10:30:08 <jmcarthur> pavolzetor: If you drop the 'module Main where' at the top, I bet ab and dot get inlined.
10:30:22 <jmcarthur> pavolzetor: Surprised they don't already. You may be reading it wrong.
10:30:46 <pavolzetor> monochrom: I had to start somewhere, profiler shown that it is doing a lot allocations in transforming rays so I just modelled part of it in a simple program
10:31:34 <monochrom> sure, but I did not ask about the large program. I asked about this small program you posted.
10:32:06 <monochrom> how do you go, for http://lpaste.net/148351, from "half of the runtime is spent in GC" to "it calls ab"?
10:32:23 <pavolzetor> sorry, I meant the big progam spends half time in GC, which is not good
10:32:57 <jmcarthur> pavolzetor: You're going to have a difficult time diagnosing the big one from this small one.
10:33:08 <monochrom> it is good or not good depending on what alternatives there are
10:33:41 <aweinstock> pavolzetor: what are the AB's/ABC's stored in in the larger program?
10:33:42 <pavolzetor> jmcarthur: I just want to get some idea what GHC is doing; for example I could just manually rewrite the code so it avoid ab
10:34:34 <pavolzetor> monochrom: I am doing this because as I add more core it gets worse (I have tested various granularities using the Marlow's book)
10:34:43 <pavolzetor> *cores
10:34:56 <jmcarthur> pavolzetor: I promise you that's already being optimized away.
10:35:01 <pavolzetor> I tried the obvious thing as increasing the heap for GC
10:35:25 <pavolzetor> aweinstock: matrices
10:35:27 <jmcarthur> pavolzetor: (I just made sure in case you're reading was correct. According to the core I'm looking at, it just does all the match right after parsing.
10:35:30 <pavolzetor> they are vec of vec
10:35:31 <jmcarthur> *the math
10:35:57 <jmcarthur> *your
10:35:57 <aweinstock> as in Data.Vector.Vector?
10:36:08 <jmcarthur> I fail at proofreading before hitting enter.
10:36:11 <aweinstock> if so, try switching to Data.Vector.Unboxed
10:36:16 <pavolzetor> jmcarthur: I will rather check for myself, since I want to know when it stops optimizing away; i.e. is the function to big to not do this, what is the heuristic?
10:36:36 <jmcarthur> pavolzetor: Functions have to be pretty big or recursive for GHC not to be willing to inline.
10:37:04 <pavolzetor> aweinstock: no, more like ekmett's linear package
10:37:16 <pavolzetor> mat4 (in glsl)
10:38:07 <pavolzetor> jmcarthur: let me post my core to see if I read it correctly
10:39:14 <Th30n> A quick question in the middle of this discussion. How to dump core of a single module within a larger/multi module cabal project?
10:39:15 <jmcarthur> btw, you don't need the BangPatterns extension to define strict fields
10:40:03 <monochrom> perhaps it's easiest to dump core for all modules
10:40:13 <jmcarthur> Th30n: just use ghc on it manually or dump core for all of them
10:40:21 <pavolzetor> jmcarthur: thanks; if I want to return something strict do I have to do something like let !a = x*x'; !b = y*y'; !c = a + b in c
10:40:21 <pavolzetor> ?
10:40:32 <monochrom> because then you just need to add one thing to your *.cabal file
10:40:39 <jmcarthur> pavolzetor: Those are redundant if (*) and (+) are strict
10:40:48 <jmcarthur> pavolzetor: also, the result of a function is always strictly evaluated
10:41:00 <jmcarthur> pavolzetor: Otherwise the function was never evaluated in the first place.
10:41:18 <Th30n> monochrom, jmcarthur: Ok, thanks.
10:41:57 <pavolzetor> jmcarthur: how do I know if (+) and (*) are strict; to WHNF?
10:42:20 <jmcarthur> pavolzetor: Since they are part of the Num type class, you have to know what type they are.
10:42:39 <jmcarthur> pavolzetor: And you just have to know that for Doubles they are strict operations.
10:44:04 <pavolzetor> I see, 
10:45:14 <pavolzetor> is it possible to have a line of code marker in prof output?
10:47:25 <jmcarthur> pavolzetor: I'm not aware of one, but you can create named call centers by hand if you know the area of code you're curious about.
10:49:43 <Gurkenglas> > seq ((+) 1 undefined :: Natural) () -- You don't necessarily need to just know it, this tests it
10:49:45 <lambdabot>  ()
10:49:53 <hunteriam> whats the deal with GSOC
10:50:48 <monochrom> is it even time for GSOC?
10:50:59 <hunteriam> not sure
10:51:25 <hunteriam> do i need my own proposal?
10:51:45 <hunteriam> and does it make sense to try and do GSOC as an undergrad or is it more of a grad school thing?
10:52:33 <bergmark> hunteriam: here are a bunch of suggestions https://ghc.haskell.org/trac/summer-of-code/report/1
10:52:38 <bollu> hunteriam: I did it as an undergrad
10:52:43 <bollu> hunteriam: not with haskell :)
10:52:59 <bollu> I'd like to work on IHaskell or something this time though. Does anyone have any suggestions?
10:53:12 <hunteriam> also how do I find a mentor
10:54:13 <bergmark> bollu: there's an ihaskell suggestion there!
10:54:22 <monochrom> you can make your own proposal. you can also go with potential mentors' proposals.
10:54:49 <monochrom> or a bit of both
10:54:56 <bollu> cool, that should be fun :)
10:55:08 <bollu> monochrom: do you know any members who maybe mentors for GSoC this year?
10:55:46 <monochrom> I don't know. they haven't announced themselves. it's a bit too early
10:56:12 <hunteriam> and when they do... do I just ask to work with them?
10:56:13 <monochrom> even Australian summer has hardly begun...
10:56:37 <bollu> good point
10:56:53 <akegalj> Gurkenglas: where is this Natural defined ?
11:00:20 <Gurkenglas> akegalj, http://hackage.haskell.org/package/numbers-3000.2.0.1/docs/Data-Number-Natural.html (found it by searching hayoo.com for infinity)
11:01:07 <Gurkenglas> (ah this could have gotten you there from first principles: http://ircbrowse.net/browse/haskell?q=lambdabot+Natural )
11:01:40 <akegalj> Gurkenglas: oh thnx. Didn't know about ircbrowse
11:01:40 <Gurkenglas> "2015-10-24 16:25:51 +0200	<Gurkenglas>	Where does Lambdabot get Natural?" <- lololo
11:02:19 <akegalj> Gurkenglas: :D
11:05:12 <kaiyin> https://gist.github.com/kindlychung/3b6b99d39c540894ccdd#file-do-hs-L5 what does this line mean here? 
11:05:56 <Gurkenglas> 2015-04-28 23:09:44 +0200	<ReinH>	Is there a lazy natural or integer type in lambdabot's scope? <- see the last few lines
11:06:20 <akegalj> Gurkenglas: thnx
11:07:40 * hackagebot tar 0.4.3.0 - Reading, writing and manipulating ".tar" archive files.  https://hackage.haskell.org/package/tar-0.4.3.0 (DuncanCoutts)
11:11:16 <bollu> what does IHaskell-aeson give us?
11:14:43 <hunteriam> probably more webapps in haskell on ios
11:15:02 <hunteriam> why would you have to rewrite aeson for ios though?
11:24:17 <xplat> oh god, seriously?  Turtle.Pattern doesn't export the Pattern constructor?
11:24:33 <zachk> is it poor practice to use ($) in haskell code? does it intefer with optimizations and reasoning from the compiler? 
11:25:58 <StoneToad> zachk: it's exactly equivalent to the appropriate () ASAIK
11:26:03 <jmcarthur> zachk: It is commonly used, and it does not interfere with optimizations. It doesn't work very well with higher rank types, but if you like to use it, then you can just not use it when the type system complains, which is a minority of cases.
11:26:21 <xplat> how the fuck am i supposed to supply basic primitives like takeWhile that you *entirely neglected to supply*?
11:26:25 <jmcarthur> zachk: There is a minority of Haskell devs who avoid ($), for stylistic reasons only.
11:27:07 <bobvh> if it makes for an easier read and it´s not performance critical 
11:27:50 <zachk> I thought ($) did some weird things with inlining....read that somewhere, ok now I can go back to my .....$ chains safely :D 
11:27:56 <StoneToad> afaik*
11:28:05 <zachk> so it can impact performance? 
11:28:10 <bobvh> happy $-ing
11:28:27 <Cale> zachk: I tend to prefer f . g . h $ x over f $ g $ h $ x
11:28:33 <bobvh> (dunno about the performance, i just finished fp101x wich makes me a haskell novice)
11:28:37 <jmcarthur> xplat: You could post an issue in the issue tracker or create a pull request, instead of picking up your pitchfork.
11:28:54 <xplat> i've never heard of it impacting performance, though i suppose it's not impossible you could write just enough of them to make the inliner give up when it could have succeeded
11:28:55 <Cale> Not for performance, but just because for instance g . h is a well-typed expression there
11:28:58 <Cale> and f . g
11:29:25 <jmcarthur> I prefer (f . g . h) x over both of those.
11:29:25 <zachk> yes that what I means
11:29:26 <xplat> jmcarthur: ... and wait for it to filter down to stackage.  sure.  in the meanwhile i have to use unsafeCoerce
11:29:27 <Cale> it makes it easier to chop the expression up into pieces
11:29:39 <zachk> is that just stylistically jmcarthur  
11:29:54 <Cale> and doesn't rely on the peculiar right-associativity of $
11:30:36 <Cale> (which by all means is something which ought to have been left-associative all along)
11:30:48 <xplat> jmcarthur: which could have been entirely avoided if the constructor had been exported, or even a function that does the same thing as the constructor, if tekmo had wanted to keep the freedom to change the representation later without relying on pattern synonyms.
11:31:13 <Cale> (.) is a properly associative operation, f . (g . h) = (f . g) . h
11:31:25 <Cale> So it doesn't matter how those get associated
11:31:54 <jmcarthur> xplat: You could use your own fork until it's merged. Whining about it doesn't make anything easier. There are more constructive ways to adjust somebody else's habits, if that is your goal, like communicating with them civilly and explaining why you disagree with their decision.
11:32:00 <jmcarthur> zachk: yes
11:32:46 <xplat> jmcarthur: i'm not interested in adjusting someone's habits.  i'm interested in blowing off steam.
11:32:59 <jmcarthur> xplat: Might I suggest #haskell-blah then?
11:33:20 <jmcarthur> xplat: I actually don't mind you blowing off steam. I just don't like it being here.
11:33:23 <xplat> jmcarthur: i'm blowing off steam about haskell code.  it would be off-topic there.
11:35:21 <statusfailed> how do I parenthesize the de Bruijn term "λ. 0 1 (λ . 0 1 2)" ? 
11:35:54 <statusfailed> it's (0 1) (λ . (0 1) 2) , right ?
11:37:09 <xplat> the usual parenthesization is that lambdas extend right as far as possible and applications associate to the left, so yeah just the way you have it
11:37:19 <statusfailed> thanks :-)
11:39:00 <t7> @hoogle m a -> m b -> m a
11:39:02 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
11:39:03 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
11:39:03 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
11:39:57 <zachk> @type (flip (>>)) 
11:39:58 <lambdabot> Monad m => m b -> m a -> m b
11:40:00 <t7> @pl readLn >>= \v -> print "Hello" >> v
11:40:00 <lambdabot> (print "Hello" >>) =<< readLn
11:40:13 <t7> i will use do :)
11:40:20 <StoneToad> lol
11:40:49 <zachk> there is only no try, only do --SimonPeytonYoda 
11:40:55 <happy0> lul
11:42:20 <zachk> if I wrap a Monad in a newtype and define an instance of Category for it, how do I fit Control.Monad.forever into my category? 
11:47:28 <Cale> zachk: in what way? I'm not sure exactly what you mean about the first part. Kleisli?
11:54:27 <Big_G> Is there a way to use simple Java objects in Haskell?
11:58:22 <zachk> Frege perhaps? Ermine? 
11:59:20 <hodapp> Hmmm, Frege is the closest you'll likely get on the JVM
12:00:44 <erisco> is there a lib for creating math notation SVGs?
12:02:39 <erisco> I want to replace MathJax, and I want compiling of LaTeX $$math$$ to be precomputed… that part should be easy when using Hakyll
12:04:35 <zachk> is there a way to get Control.Monad.forever to compose with kleisi composition arrows? 
12:07:15 <bollu> :P
12:07:29 <Gurkenglas> You mean kleisli arrows a -> m b? forever :: m a -> m b is not a kleisli arrow, but you can compose it to the right of one as a function
12:07:30 <bollu> seriously, what benefit does IHaskell-aeson offer?
12:08:13 <Gurkenglas> *to the left, dammit
12:11:25 <erisco> latex to svg… has to be a way
12:11:31 <erisco> just the math stuff
12:13:21 <bergey> erisco: googling for "pandoc math svg" turns up several pandoc filters that call out to various external tools.  I can't vouch for any of them, but adding a pandoc filter too your Hakyll build isn't too hard.  I haven't seen a library that does this entirely in Haskell
12:13:53 <erisco> I haven't a clue what Pandoc is
12:14:59 <erisco> hm, well there is this thing which ostensibly uses dvisvgm https://gist.github.com/lierdakil/6a95278d02256a74a0fc
12:15:21 <erisco> that is not real documentation though so no thanks oO
12:16:53 <bergey> Pandoc is the program that Hakyll uses to convert Markdown (or other formats) to HTML.
12:17:14 <erisco> oh okay… I probably messed with it then
12:18:23 <erisco> maybe I should instead consider how to embed complete documents in HTML
12:18:27 <bergey> Pandoc has a bunch of options for math output in HTML, but I don't think plain SVG is one of them: http://pandoc.org/README.html#math
12:18:33 <erisco> that way I can easily use diagrams as well
12:19:03 <bollu> IS there a cool plotting library on top of diagrams?
12:19:13 <bollu> eg. something like matplotlib for Haskell?
12:19:22 <bergey> shameless plug: http://hackage.haskell.org/package/diagrams-pandoc for writing Diagrams code in your pandoc / hakyll markup
12:19:27 <Cale> bollu: It appears to use javascript syntax highlighting for the JSON snippets
12:19:41 <erisco> bergey, you shill :P
12:19:53 <bergey> I know of two plotting libraries
12:19:53 <bollu> Cale: what do you mean?
12:19:56 <bergey> http://hackage.haskell.org/package/Chart-diagrams
12:19:58 <bergey> https://github.com/cchalmers/plots
12:20:04 <Cale> bollu: https://hackage.haskell.org/package/ihaskell-aeson-0.3.0.0/src/IHaskell/Display/Aeson.hs
12:20:19 <bollu> oh I see, thanks :)
12:21:14 <bergey> Oh, and also: http://hackage.haskell.org/package/dynamic-plot
12:21:15 <erisco> bergey, that is interesting. Never heard of "diagrams" the package before
12:22:15 <bergey> hehe.  I just assume that on this channel when people say "diagrams" they mean the Haskell package.
12:22:22 <erisco> my beef with MathJax is it is slow and requires JavaScript
12:22:31 <ralu> I am trying to make #ifdef for arm code in library. I cant find list of macros.
12:22:42 * hackagebot wai-session-postgresql 0.2.0.3 - PostgreSQL backed Wai session store  https://hackage.haskell.org/package/wai-session-postgresql-0.2.0.3 (hc)
12:22:46 <bollu> bergey: which one is more in development?
12:22:57 <erisco> and some peculiar folk don't like JavaScript for some reason
12:23:30 <erisco> personally I'm okay with HTML5 canvas taking down my system
12:23:32 <bergey> bollu: I don't know.
12:24:02 <monochrom> erisco: do you know what you're getting into when you get into svg? it might not be the answer either.
12:24:13 <erisco> monochrom, no I don't. What are the pitfalls?
12:24:36 <erisco> what Wikipedia does is okay except it is fixed size
12:24:52 <erisco> so if you're like me and need to ctrl++++ some websites then that kinda sucks
12:25:00 <monochrom> if you don't use downloadable fonts, you are never sure of font size, therefore you are never sure of text placement coordinates
12:25:14 <monochrom> if you do use downloadable fonts, it's a rabbit hole down there
12:25:44 <erisco> I expect the font to be rendered to curves or whatever SVG does
12:26:09 <erisco> from what I read SVG can also have embedded fonts, but that is not what I want at all
12:26:12 <monochrom> I disbelieve that Wikipedia claim. go to my http://www.vex.net/~trebla/haskell/lazy.xhtml , scroll down to some diagrams, and ctrl+++++++
12:26:51 <erisco> monochrom, well out of the gate I cannot see any of them because I use a filter which strips background images :P
12:27:09 <erisco> and also forces the background colour to black and the text to green
12:27:16 <erisco> so I can't see the black stuff
12:27:26 <monochrom> "font rendered to curves" is going to mean you are down to the metafont level. that will be a lot of svg, so much so that it's likely 10x slower than mathjax
12:27:31 <erisco> but what is that using?
12:27:55 <monochrom> what background image? I use svg there. only svg.
12:28:01 <erisco> oh okay
12:28:13 <erisco> well the SVGs seem to be black then
12:28:16 <erisco> that is an interesting problem
12:28:34 <monochrom> are you trying to reproduce a 1970 monochrome monitor in your browser?
12:29:06 <erisco> black on white is harder on me eyes
12:29:09 <monochrom> oh yes, SVG also requires you to pick a foreground colour.
12:29:36 <monochrom> which means you can never pick a colour that works for the peculiar folks who also reject javascript
12:30:34 <monochrom> you will have to temporarily set your browser to black-on-white to see my svg
12:30:53 <erisco> yeah, hm
12:31:02 <monochrom> but it scales to ctrl+++++. totally.
12:31:18 <monochrom> it is the only reason I chose svg over pixel pictures
12:31:27 <erisco> but what does it have to do with Wikipedia?
12:31:55 <monochrom> oh, nevermind, I misread.
12:32:17 <erisco> they rasterise, which is probably the ultimate for portability
12:32:29 <monochrom> I thought you said Wikipedia said "svg is fixed size". but you didn't say that. 
12:32:42 <erisco> however they are PNGs with transparent backgrounds
12:32:51 <erisco> so I can't read them without going to black on white mode :(
12:33:40 <erisco> monochrom, well with your SVG page everything came in immediately for me
12:33:58 <monochrom> I went to great pain to get it done.
12:34:12 <erisco> whereas even a small MathJax example has significant latency
12:34:18 <erisco> you have to watch it slowly pop in
12:35:11 <monochrom> yes, but my svg is not doing "draw my own curves for text strokes". I'm using your native text.
12:35:12 <erisco> monochrom, yes I can appreciate the craftsmanship of that document
12:35:50 <monochrom> if you go "draw your own curves to dot the i and cross the t", it will be slower than mathjax. at least that's my bet.
12:36:24 <erisco> well there is no need that I foresee to use SVG for blocks of text
12:36:44 <erisco> but maybe you're right anyways, I don't know
12:37:11 <erisco> if I switch MathJax to SVG mode it is also slow, but I can't tell what the expense is
12:38:03 <erisco> this reminds me years ago before web fonts…
12:39:16 <erisco> I wish I could remember the name of it but there was this lib that would render any font using an available plugin such as flash
12:39:24 <erisco> and that was a big deal
12:40:13 <erisco> around the same time I wrote a PHP script that used imagemagick or something to dynamically rasterise text
12:42:21 <erisco> I don't know if MathML is the new way but my version of Chrome doesn't support it, seemingly
12:42:59 <t7> firefox does it i think
12:43:25 <t7> probably need todo some svg cleverness for a cross browser solution these days
12:43:35 <erisco> I just read the Wikipedia article and it says Google removed support because there were security concerns and it was not important enough to support
12:44:59 * erisco shrugs
12:45:03 <monochrom> MathML was the new way. by now it is pretty abandoned.
12:45:18 <erisco> MathJax it is then… will have to wait for humanity to evolve a bit more
12:45:48 <monochrom> mathjax can detect your browser then choose between mathml or pixel picture, IIRC
12:47:53 <erisco> a difficulty with math notation is there is it is not standard, necessarily
12:48:01 <erisco> is that it is not standard*
12:50:15 <erisco> though if you do standardise some notations then perhaps that sways people to use it more
12:50:27 <erisco> could be a good thing
12:50:58 <erisco> has latex done this already? I don't know
12:52:43 * hackagebot fixed-length 0.2 - Lists with statically known length based on non-empty package.  https://hackage.haskell.org/package/fixed-length-0.2 (HenningThielemann)
13:00:01 <Jinxit> latex only allows you to typeset what you consider your own standard :)
13:00:06 <Jinxit> wrt notation
13:00:47 <Th30n_> What's your opinion on these two approaches? data ItemType = Weapon | Armor | ...   data Item = Item { type :: ItemType, fields } vs data ItemFields = IF { fields }  data Item = Weapon ItemFields | Armor ItemFields | ...  ?
13:01:46 <monochrom> I don't have an opinion until I see code for producing them and code for consuming them.
13:02:25 <monochrom> or in other words use cases
13:02:43 * hackagebot midi 0.2.2 - Handling of MIDI messages and files  https://hackage.haskell.org/package/midi-0.2.2 (HenningThielemann)
13:03:27 <roconnor> Th30n_: data Item = { type :: ItemType; fields :: ItemFields } is my preference.
13:03:57 <roconnor> actually as monochrom suggests, it depends on if you ever need to pass "ItemFields" around.
13:04:02 <Th30n_> monochrom: Yeah, got you, but I was asking for a friend. Will have to look into his use case more.
13:04:29 <roconnor> otherwise you might as well just do { type :: ItemType, fields }
13:04:54 <roconnor> But this is predicated on the assumption that all items have exactly the same set of fields, which I find dobutful.
13:05:18 <roconnor> data Item = Weapon WeponFields | Armor ArmorFields | ...
13:05:33 <roconnor> seems more like what I would expect.
13:06:13 <roconnor> If you friend is new to haskell, they might not be used to making sum types like that.  It isn't common in other languages.
13:07:07 <Th30n> roconnor: Yeah, he is new. First he wanted sum of records all with same fields. So I recommended the above approaches. I'll have to look at his code, it is suspicious that all the fields are same.
13:07:16 <Th30n> I hope he's not using all the fields as Maybe smth
13:07:34 <roconnor> he probably is. :)
13:07:43 * hackagebot propellor 2.15.2 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.15.2 (JoeyHess)
13:08:49 <roconnor> Th30n: if there are common fields, they could be factored out.
13:09:59 <roconnor> data Item = Item CommonFields ItemSpecific;  data ItemSpecific = Weapon WeaponSpecific | Armor ArmorSpecifc | ...
13:15:54 <Th30n> roconnor: Thanks
13:16:18 <Th30n> But he doesn't really know what problem he is solving... so it's gonna take a while to get a proper solution :)
13:19:15 <roconnor> Th30n: don't bother factoring out common fields then :)
13:25:24 <lynnard> how can I catch an exception thrown by 'error' ?
13:26:47 <geekosaur> Control.Exception.catch and friends
13:27:01 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.6.0.1/Control-Exception.html#g:3
13:27:04 <usr> lynnard: is it pronounced Leh-Nerd? 
13:27:08 <Cale> lynnard: Generally you don't want to try to though, if it's at all possible to avoid this situation.
13:28:36 <Cale> lynnard: The reason is that the exception thrown by error is triggered by *evaluation*, while catch catches exceptions thrown during the *execution* of a given IO action. Making sure that the evaluation of the appropriate expression doesn't happen sooner or later than the execution of the action inside the catch can be tricky.
13:28:47 <Cale> (but there's Control.Exception.evaluate to help a bit)
13:29:38 <geekosaur> he asked about `error` though; it could well be pure code throwing it
13:29:42 <geekosaur> (not that that actually helps)
13:29:55 <Cale> Well, it generally is, yes
13:30:20 <lynnard> Cale: what's the difference between 'evaluation' and 'execution'..?
13:30:23 <Cale> Whatever expression it was, you have to be careful about when it gets evaluated.
13:30:36 <Cale> lynnard: Evaluation is the reduction of expressions to values.
13:30:46 <lynnard> hah okay
13:30:56 <geekosaur> in any case, (1) exceptions *must* be caught in IO; (2) non-strict evaluation means that unthrown exceptions can "leak" out of your catch/handle/etc.
13:30:59 <Cale> Execution is the process of carrying out the instructions described by IO action values.
13:31:32 <lynnard> yes I see, basically you can pass the error around without actually executing it
13:31:47 <lynnard> but if I have the catch at the very top level then I can rest assured..?
13:32:10 <lynnard> usr: I tend to imagine it as Lin-nard :) better-sounding
13:33:39 <Cale> lynnard: Yeah, if there's literally nothing else outside of your catch, then so long as the error is evaluated, you will manage to catch it, but usually that's too far up :)
13:33:47 <usr> lynnard: but they have an album called "It's pronounced Leh-Nerd Skin-Nerd" 
13:34:15 <lynnard> haha okay haven't listened to that band unfortunately
13:34:17 <Cale> lynnard: It's usually better to use error for things which you will never hope to catch
13:34:26 <usr> ah lol
13:35:41 <Cale> and use Either for exceptional conditions in pure settings that you will want to handle and Either or exceptions thrown by throwIO from IO code, depending on how likely it will be that you want to handle the error immediately.
13:35:54 <Cale> It's easy to catch exceptions which were thrown by throwIO
13:36:30 <Cale> (because you have to *execute* the IO action it gives you to throw the exception, so it's in sequence with all the other execution)
13:36:48 <Ablu> Hello, is there a way I can write large numbers like 1231321312321132321321321321321321321903210932109321092109231 into multiple lines?
13:37:48 <Cale> Ablu: perhaps with arithmetic :P
13:38:05 <mniip> read $
13:38:05 <Cale> There's no special syntax for breaking large numbers across lines
13:38:29 <Cale> Yeah, you could use something like read . concat
13:38:38 <Ablu> Cale: hm ok. yeah i can do arithmetics with it. I was just wondering
13:39:21 <mniip> if you want exact typechecking compatibility, use fromInteger . read
13:39:44 <Ablu> ok that might be a better solution.
13:39:47 <Cale> Oh, right, you could use string gaps, so you don't really need concat :)
13:39:50 <Ablu> thanks a lot!
13:43:06 <ontop> Trying to use QuickCheck to do multiple checks. But it says quickCheckAll will default all my polymorphic types to int and I don't want that. I want to define the types so it chooses an appropriate generator
13:43:31 <ontop> Is there anyway I can just have a really fat main function that does: quickCheck (func :: String -> Bool)
13:43:34 <ontop> But multiple times?
13:44:39 <ontop> http://lpaste.net/1765661098335272960
13:44:40 <ontop> Ala this.
13:45:35 <happy0> ehh
13:45:42 <happy0> i have something similar, but a bit different to that
13:46:03 <happy0> somewhere
13:46:05 <happy0> 'sec
13:46:17 <happy0> https://github.com/Happy0/haskellscrabble/blob/master/test/Tests/Properties.hs
13:46:30 <happy0> ontop: or is not what you want to achieve, ontop ? ;x
13:47:25 <ontop> Sort of?
13:47:34 <ontop> The only problem is it seems like testProperty will do whatever it wants in terms of types.
13:47:50 <ontop> Where I want to determine which types are used for the property tests.
13:47:52 <athan> @tell dmj` Crap, sorry man I've been out for a bit, what's up?
13:47:52 <lambdabot> Consider it noted.
13:48:44 <Ablu> Cale: mniip: Thanks for the help, have a nice day!
13:49:20 <happy0> ontop: glhf
13:49:25 <happy0> (good luck, have fun)
13:50:13 <ontop> I know what it means
13:50:13 <ontop> lol.
13:50:23 <ontop> So what you're saying is, it's impossible!?! :D
13:50:38 <happy0> ontop: nope. only that i don't know enough about the library =p
13:50:43 <Tuplanolla> Hey, edwardk. Do you have a moment?
13:50:43 <happy0> it's been a couple of years since i played around with it
13:50:53 <ontop> I bet if I stare at the definition of quickCheck long enough
13:51:00 <happy0> ha :D
13:51:01 <pavolzetor> monochrom: I have read some blog post and RWH chapter but I am confused a bit; http://lpaste.net/148366 I do not get why it allocs som much in apply (transforms)
13:51:02 <ontop> Maybe I can do some gross magic over it that'll let me call it multiple times.
13:51:20 <pavolzetor> I have looked at threadscope (and forced evaluation before writing to disk)
13:51:32 <pavolzetor> there massive pauses for GC
13:51:44 <pavolzetor> from -s I get 57% productivity
13:52:25 <lyxia> ontop: you could copy-paste the definition of quickcheckAll and replace "Integer" with "MyMonoid" at the appropriate place
13:52:43 <Gurkenglas> In ghci, my assertNote function was called. Can I make it tell me what parameter the calling functions was given without distributing it to every call to assertNote? Particularly since I've managed to have it pointfree thus far
13:52:57 <ontop> lyxia: That's brilliant. Where can you see the source code for quickCheckAll?
13:53:26 <ontop> "Note: the bizarre return [] in the example above is needed on GHC 7.8; without it, quickCheckAll will not be able to find any of the properties. For the curious, the return [] is a Template Haskell splice that makes GHC insert the empty list of declarations at that point in the program; GHC typechecks everything before the return [] before it starts on the rest of the module, which means that the later call to quickCheckAll 
13:53:27 <ontop> can see everything that was defined before the return []. Yikes!"
13:53:27 <pavolzetor> I understand the time spent in those cost centres, but not the massive alloc
13:53:32 <ontop> Wow, the paste was way too big sorry guys :(
13:53:36 <ontop> Look at that quote from the docs!
13:53:39 <ontop> That's ridiculous.
13:54:35 <lyxia> http://hackage.haskell.org/package/QuickCheck-2.8.1/docs/src/Test-QuickCheck-All.html#quickCheckAll ontop 
13:55:04 <ontop> Thanks :D
13:55:06 <lyxia> it depends on forAllProperties, which in turn depends on a bunch of other functions
13:55:10 <ontop> This looks very beyond me.
13:56:22 <lyxia> I think you just need to change '[t| Integer |]' to '[t| MyMonoid |]' inside 'monomorphic'.
13:56:30 <ontop> Oh.
13:56:35 <ontop> I'm an idiot, I guess you can just do this:
13:56:55 <ontop> http://lpaste.net/1765661098335272960
13:57:03 <ontop> Yay monads, whatever those are.
13:58:56 <lyxia> yeah you can call the tests by hand too
13:59:51 * ontop writes functor-law tests
14:02:02 <lyxia> ontop: http://lpaste.net/1765661098335272960 just a bit shorter
14:02:27 <ontop> Oh. I see what you've done there.
14:02:29 <ontop> Clever.
14:06:09 <pavolzetor> "Cost centres are just program annotations. When you say -fprof-auto to the compiler, it automatically inserts a cost centre annotation around every binding not marked INLINE in your program, but you are entirely free to add cost centre annotations yourself."
14:06:19 <pavolzetor> so why does inline show in the profiling then?
14:21:23 <deni_> what library would you recommend for URI parsing and constructing? (Specifically I have a case where I get a URI with get params and I want to change a specific get param in that URL)
14:22:52 <allenj12> Hey, I wanna try haskell again however last time Cabal was a pretty painful experience in general? are there any alternatives or new standards?
14:23:01 <bergmark> deni: maybe uri-bytestring? i have only barely used it
14:23:16 <mrkkrp> allenj12: stack
14:23:33 <deni> bergmark: that's like uri but bytestring vs string right?
14:23:57 <allenj12> mrkkrp: kk thank you ill look into it!
14:23:59 <bergmark> deni: i don't see how the packages are related
14:24:14 <deni> bergmark: I don't know...was asking because I found both on hackage
14:24:37 <achernyak> what is a safe way to handle a read? Specifically I am trying to read in only a single integer and on all other cases do nothing.
14:24:46 <bergmark> deni: if you mean that one uses bytestring and the other string, then yes
14:24:56 <bergmark> achernyak: Data.Maybe.readMaybe
14:25:45 <deni> bergmark: yeah I thought that was perhaps the only difference but seems not. the API is more different then just that
14:25:48 <deni> bergmark: thanks!
14:26:47 <achernyak> bergmark, I am not finding any documentation on it...
14:28:56 <achernyak> bergmark, has it been deprecated from the Data.Maybe package? 
14:30:07 <mrkkrp> I have a package that's tested on Travis CI. Build matrix includes combination Cabal 1.16 / GHC 7.6.3. Today I pushed a cosmetic change to readme file and according to logs that version of Cabal has lost its ability to resolve dependencies (it says "could not resolve dependencies: <empty space, no info>"). How is this possible? It built OK just yesterday, and now, without any change in dependency list or something, it broke. How all
14:30:07 <mrkkrp> this stuff is so unreliable? Is it possible that some change on Hackage influenced that particular version of Cabal so it cannot resolve dependencies anymore? I don't know what to do, I don't want to drop support for GHC 7.6.3 yet.
14:30:08 <allenj12> mrkkrp: so looking at there about page etc... looks many people really hated cabal
14:30:30 <bergmark> achernyak: my bad, it's Text.Read.readMaybe
14:30:52 <achernyak> bergmark, just found it too . thanks for the help! exactly what I was looking for
14:31:57 <sm> mrkkrp: maybe you find a version that changed between good and bad builds in travis logs ?
14:32:07 <bergmark> mrkkrp: it is possible... either due to a revision or a solver bug. Are you passing --reorder-goals? It has helped in the past but i think all bugs related to it have been fixed...
14:33:07 <mrkkrp> bergmark: no, I don't, I'll try.
14:33:23 <athan> deni, bergmark: For me, http-types has the best uri parsing
14:33:24 <bergmark> mrkkrp: and oh! you said Cabal 1.16, that definitely has that bug
14:33:33 <athan> http://hackage.haskell.org/package/http-types-0.9/docs/Network-HTTP-Types-URI.html#v:urlDecode
14:34:03 <deni> athan: tnx....will check that one out as well
14:34:16 <athan> np!
14:34:38 <bergmark> http-types is definitely the most popular
14:35:06 <nolrai2> @pl \v -> f v >> g v
14:35:06 <lambdabot> liftM2 (>>) f g
14:35:06 <Welkin> athan: 吃饭了吗？
14:35:17 <bergmark> for just encode/decode we use uri-encode, sounds risky to try to change to another library :_)
14:35:40 <nolrai2> @pl \v -> f v >> return v
14:35:40 <lambdabot> liftM2 (>>) f return
14:35:58 <mrkkrp> bergmark: I just don't understand how it worked so far and then broke, I don't think Cabal 1.16 has changed (I'm using multi-ghc-travis). So the only way to break it is to remove older versions of packages from Hackage, which is unlikely. Ah.
14:36:33 <exio4> is there any easy way to re-generate the documentation of every installed package? 
14:38:04 <athan> Welkin: Today, yes :)
14:38:09 <athan> Just munched on some kale!
14:38:39 <deni> athan: this is what yesod and wreq use (re http types). nice.
14:38:48 <Welkin> athan: you ate Cale?
14:39:10 <athan> deni: Yes I believe so, I think Snap uses a homebrewed one that also separates on `;` iirc
14:39:18 <athan> >:D
14:46:50 <sm> Cale has more nutrients per pound than other vegetables
14:47:46 * hackagebot OpenGLRaw 3.0.0.0 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGLRaw-3.0.0.0 (SvenPanne)
14:52:46 * hackagebot GLURaw 2.0.0.0 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/GLURaw-2.0.0.0 (SvenPanne)
14:52:48 * hackagebot OpenGL 3.0.0.0 - A binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGL-3.0.0.0 (SvenPanne)
14:54:11 <hpc> sm: not as much as chard - https://www.youtube.com/watch?v=YfblU3FbZ7M
14:54:56 <mrkkrp> bergmark: --reorder-goals has made it work. Now I can finally go to sleep. Thanks!
14:57:59 <sm> lol
14:58:08 * hackagebot GLUT 2.7.0.5 - A binding for the OpenGL Utility Toolkit  https://hackage.haskell.org/package/GLUT-2.7.0.5 (SvenPanne)
14:58:10 * hackagebot OpenAL 1.7.0.3 - A binding to the OpenAL cross-platform 3D audio API  https://hackage.haskell.org/package/OpenAL-1.7.0.3 (SvenPanne)
15:03:08 * hackagebot ALUT 2.4.0.2 - A binding for the OpenAL Utility Toolkit  https://hackage.haskell.org/package/ALUT-2.4.0.2 (SvenPanne)
15:05:46 <bergmark> @tell mrkkrp the cabal bug you ran into gets triggered in older versions when build plans get more complicated and there are cabal flags involved
15:05:46 <lambdabot> Consider it noted.
15:08:16 <Welkin> magikarp?
15:08:59 <mag__> http://cdn.bulbagarden.net/upload/0/02/129Magikarp.png
15:23:09 <hiptobecubic> There is (or was?) a tool that would watch for changes and continuously try to recompile a project (but not run it). It was useful to have open in a second terminal when working on a file. Does anyone remember what it is called?
15:23:25 <hiptobecubic> I saw that stack does something similar, but I think this was independent of stack and didn't require it
15:23:53 <Welkin> hiptobecubic: yesod-bin does this for yesod
15:27:46 <khole> c_wraith: clever. So even though we're writing the same value back, the threads are woken up?
15:29:03 <subleq__> I need a data structure to represent people sitting around a circular table. So each person always has someone to their left and to their right. I can do data Circle a = Circle a (Circle a), which ensures there's always someone to the right, but how can you represent the person to the left?
15:29:17 <hiptobecubic> Welkin, hmm. That's probably like what I want, but I've never written anything with yesod so it's probably not what I'm thinking of :)
15:29:42 <subleq__> I'd like to avoid using just a list of the people, because of the special cases to handle wraparound at the ends
15:32:04 <athan> @tell mgsloan I don't know if you are on twitter much, but this thread might be interesting to you! https://twitter.com/hdgarrood/status/683688529239666688
15:32:05 <lambdabot> Consider it noted.
15:33:25 <pavonia> subleq__: Cyclic data types are a bit tricky in Haskell. Have you seen http://wiki.haskell.org/Tying_the_Knot ?
15:33:43 <subleq__> pavonia: yes
15:34:27 <subleq__> once I have the type definition I can tie the knot to construct values of it, but I don't know what the type is in the first place
15:35:15 <pavonia> Having a Circle for the left- and right-hand person, I think
15:35:40 <pavonia> Pretty much like DList in that examples
15:35:42 <subleq__> hrm
15:36:04 <subleq__> what guarentees that the left circle loops around back to the right?
15:36:56 <pavonia> Not sure if this can be encoded in the type
15:37:08 <erisco> can you get a page on hackage that lists modules authored by an individual?
15:37:23 <erisco> for similar purpose of the GitHub page that lists your repos
15:37:42 <subleq__> and it'd be nice to have a function Circle a -> [a] that works as long as the circle is finite
15:39:09 <c_wraith> khole: yep.  There's no optimizations for "the same value", since that's not even something decidable in general.
15:39:34 <erisco> subleq__, if you need observable circularity then you probably are just as well using an indirect representation
15:40:13 <subleq__> erisco: what does that mean?
15:40:14 <Welkin> erisco: not that I know of
15:40:21 <Welkin> unless there is an advanced search feature on hackage
15:40:24 <Welkin> but yu can use hayoo
15:40:25 <Welkin> :P
15:40:26 <Welkin> http://hayoo.fh-wedel.de/?query=Aristid%20Breitkreuz
15:40:33 <Welkin> it works
15:41:27 <erisco> subleq__, by observable circularity I mean you can write an algorithm to disambiguate a circular data structure from an infinite one
15:41:42 <erisco> well, weaker than that
15:41:43 <emmanuel_erc> hello there everyone!
15:41:50 <erisco> if it is circular then it halts, and if it is infinite it may not
15:43:50 <khole> c_wraith: fantastic. I think for my particular problem I can actually remodel it so that I can watch for a change of state in my main data structure, but your solution to the event problem is dead simple and really clever, thanks!
15:43:52 <erisco> so, practically speaking, say you're working with graphs, then if the graphs may contain cycles you may need a representation with which you can detect those cycles
15:44:15 <emmanuel_erc> Would I be right in assuming that an expression like (foldr (&) (empty :: GP.Gr () Double) $ map makeContext' gctx) is more efficient than (foldr ((&) . makeContext') (empty :: GP.Gr () Double) gctx)
15:44:38 <emmanuel_erc> I hope you can see what I am getting at within this small piece of code.
15:45:21 <erisco> subleq__, maybe that doesn't make much sense :)
15:45:43 <erisco> subleq__, you can, for example, use a repeating list to represent the circularity
15:45:54 <subleq__> erisco: it kind of does. I think I'm asking for cycles to both be distinguisable and not distinguishable. So my request is invalid
15:46:28 <erisco> sorry, I mean a list zipper
15:47:03 <subleq__> a list zipper gives the operations i need, I just don't like the specials cases at the ends
15:47:08 <erisco> so you have ([a],[a])
15:47:10 <erisco> there are no ends
15:47:40 <erisco> :t repeat
15:47:41 <lambdabot> a -> [a]
15:47:47 <erisco> :t cycle
15:47:49 <lambdabot> [a] -> [a]
15:48:00 <verement> subleq__: it may be easier just to use a vector you can index ±1 mod n to reference the person to the left or right
15:48:14 <erisco> > (cycle (reverse [1,2,3]), cycle [1,2,3])
15:48:15 <lambdabot>  ([3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,...
15:48:40 <erisco> your zipper is somewhere in a list with no beginning and no end
15:48:44 <subleq__> verement: I'm trying to avoid the possibility of runtime failures you get when indexing a vector
15:48:49 <zachk> does observable circularity even exist in haskell? I can see it with cmparing ptr addresses, but not another way , like say over cycle 
15:49:01 <zachk> zipper on a list, is like two stacks with push and pop 
15:49:03 <subleq__> erisco: if there are no ends, how do you turn it back to a list?
15:49:09 <zachk> that push to a pop and pop to a push 
15:49:13 <verement> subleq__: how could it fail if you always index mod n?
15:49:23 <zachk> the zippers over other data structs are more complicated 
15:49:25 <mniip> zachk, you can't really compare pointers either
15:49:32 <zachk> why not? 
15:49:40 <mniip> the GC
15:49:42 <subleq__> verement: i'm looking for static safety
15:49:44 <mniip> can move things around
15:49:49 <erisco> subleq__, is that essential?
15:50:18 <subleq__> nothing is really essential, it's just a thought experiment
15:50:30 <jmcarthur> emmanuel_erc: I wouldn't guess it's more efficient, but I think the first is better factored. (They are probably equally efficient after ghc optimizations.)
15:50:55 <gaze__> Hey guys, if I'm wrapping a language that features single inheritance, what's probably the best way to ensure that calling superclass methods type checks on the subclasses?
15:52:04 <athan> What does `proc` from -XArrows stand for, again? :s
15:52:07 <gaze__> in other words I have some data Subclass = Subclass ptr
15:52:23 <gaze__> anyway... yeah. Maybe some sort of existential magic?
15:52:39 <gaze__> it's just kinda gross crowding up my types.
15:52:42 <dldl> A list is just a fancy recursive 'data' definition
15:52:45 <dldl> ?
15:52:47 <emmanuel_erc> Ok, I just wanted to see if my current intuitons about laziness were not leading me astray? I thought the first one would be better because the data to be included would have been computed beforehand.
15:52:55 <emmanuel_erc> If that makes sense.
15:53:11 <dldl> and `Cons` is just a constructor?
15:53:32 <johnw> gaze__: there are several approaches to a question like that, but we have to begin with whether your design really models what you want to achieve; are you coming to Haskell from an OO language?
15:53:57 <gaze__> johnw: No. I'm writing a C++ ffi wrapping utility.
15:54:03 <johnw> ahh
15:54:06 <gaze__> something like fficxx but simpler and as more of a learning experience
15:54:22 <jmcarthur> emmanuel_erc: The only difference between the two without optimizations is that the version decomposing the map from the foldr will allocate more cons nodes along the way, since map produces a new list which the foldr will consume incrementally.
15:54:46 <jmcarthur> emmanuel_erc: But GHC will, in this case, eliminate the intermediate list, so they are basically the same.
15:55:16 <gaze__> I just need to somehow encode the class hierarchy
15:55:26 <erisco> subleq__, a zipper with an indeterminate position, i.e. we cannot remember which moves have been taken… that is my guess
15:55:34 <jmcarthur> emmanuel_erc: Note that there is no general optimization in GHC that promises to always eliminate such intermediate data structures. I just happen to know that it will do so in this case.
15:55:38 <pavonia> athan: Isn't that just like "do" for monads?
15:55:44 <emmanuel_erc> jmcarthur: Ah, I see. I was worried that the latter expression would place a thunk "within the foldr" that wouldn't be evaluated until much later.
15:55:51 <gaze__> obvs I could just write each superclass method on every subclass, but that seems like it'd generate a ton of unnecessary code
15:56:00 <erisco> subleq__, if the list is finite then we can reconstruct at least one sequence of moves to get from the initial zipper to the current one
15:56:01 <johnw> gaze__: I wouldn't try to model class hierarchies using types alone
15:56:04 <gaze__> there has to be a way to encode the class hierarchy without generating a bunch of garbage
15:56:05 <emmanuel_erc> Thanks for the help jmcarthur.
15:56:12 <gaze__> johnw: oh?
15:56:15 <johnw> gaze__: objects are better approximated as records-of-function values
15:56:17 <jmcarthur> emmanuel_erc: The composition would most likely be optimized away, if that's what you mean.
15:56:31 <erisco> subleq__, if the list is infinite is it reasonable to say we may have already taken an infinite number of moves?
15:56:34 <erisco> I think it is
15:56:58 <emmanuel_erc> jmcarthur: I tested both expressions (granted there is a lot I am not telling you), and I kept getting better GC stats with the former.
15:56:58 <erisco> so, to answer "how do we reconstruct the list"… the answer is that you need infinite time
15:57:23 <jmcarthur> emmanuel_erc: Nothing I say can refute hard numbers, of course. :)
15:57:41 <gaze__> johnw: man... that doesn't sound right. I'm trying to go the other direction
15:57:50 <gaze__> I'm not implementing an object system
15:57:57 <gaze__> c++ already generates all my vtables
15:58:03 <emmanuel_erc> I may have screwed though. But I am understanding what is happening a little better.
15:58:06 <jmcarthur> emmanuel_erc: Though I'd be quite surprised if the former is more efficient than the latter, to be honest.
15:58:48 <gaze__> also that approach works for has-a not is-a
15:58:53 <gaze__> to my knowledge...
15:59:16 <aweinstock> johnw: if representing objects as structs-of-functions, how do you test for subclass-of?
15:59:53 <johnw> aweinstock: you have an ADT to represent the hierarchy, and you keep a tag in the record
16:00:08 <jmcarthur> aweinstock: That presupposes that all objects support that kind of reflection. (And anyway, that could just be one of the functions in the struct.)
16:00:13 <johnw> but the type of the record defines the class interface
16:00:30 <gaze__> johnw: Yes but then the subclass records needs entries for every superclass method
16:00:34 <gaze__> or casts have to be explicit
16:00:47 <gaze__> I guess I could have explicit upcasting?
16:00:59 <jmcarthur> gaze__: I wouldn't consider either of those properties to be downsides. :)
16:01:00 <aweinstock> gaze__: is the overall structure of this TH-that-parses-c++-at-compile-time?
16:01:07 <johnw> gaze__: check out this article: http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf
16:01:29 <johnw> it describes very nicely the difference between "objects" and "algebras", which will give you a clear picture of how one embeds into the other in a setting like Haskell
16:02:13 <gaze__> so I do need explicit upcasting.
16:03:00 <gaze__> poop.
16:03:18 <jmcarthur> There are other ways to do things like this using type classes. It may or may not be a good fit for you.
16:03:33 <gaze__> yeah I feel like typeclasses are the right thing
16:03:46 <gaze__> just ideally I don't make my type signatures look too gross
16:04:00 <erisco> type Clean = Gross
16:04:14 <Welkin> there is no hierarchy in haskell
16:04:21 <Welkin> all is equal
16:04:53 <Welkin> no class system to oppress
16:04:54 <johnw> there is a problem with typeclasses, which the essay goes into
16:14:13 <gaze__> dangit
16:14:30 <gaze__> okay so I guess in FFICXX wavewave just implements every superclass method for every subclass
16:14:46 <gaze__> I guess in a reasonably designed piece of software the nesting won't be too deep and this won't do anything too ridiculous
16:15:03 <athan> I wonder if it would be possible to prove that parallelism and concurrency are dual to each other in some design
16:15:43 <athan> maybe in an actor-model or something
16:17:25 <johnw> dual in what sense?
16:18:45 <jmcarthur> johnw: The essay rightly says that type classes don't help you hide representation. But type classes with existential quantification can do that. The paper alludes to this. Here's an encoding which I think they didn't quite have in mind at the time:   data Object interface = forall s. interface s => Object s
16:19:05 <jmcarthur> johnw: That kind of object supports subtyping and hides the representation.
16:19:33 <johnw> jmcarthur: but you'd never be able to downcast the contained value; or are you saying it's OK to keep the representation totally private?
16:20:08 <jmcarthur> johnw: You can cast the object itself to a supertype. Eg.   Object ghci
16:20:10 <jmcarthur> oops
16:20:12 <jmcarthur> lol
16:20:30 <jmcarthur> johnw: You can cast the object itself to a supertype. Eg.   Object Real  can be cast to  Object Num
16:21:06 <jmcarthur> Wait, what direction is downcasting?
16:21:07 <johnw> my comment was about downcasting
16:21:12 <johnw> Real -> Float
16:21:14 <jmcarthur> Ah, that would require reflection.
16:21:17 <johnw> yes
16:21:41 <johnw> up goes toward super, down toward sub
16:21:47 <jmcarthur> If that is considered an important enough feature, I guess you could do some Typeable stuff inside.
16:22:04 <johnw> so, nasty type hackery solves all problems in the end? :)
16:22:19 <jmcarthur> in fact, you could just put Typeable in the interface
16:22:39 <athan> johnw: Dual from an operational sense, given that locks in the concurrent world corrospond to a single parallel map, and that actors in the concurrent world corrospond to threads in the parallel one
16:22:53 <athan> maybe concurrency actually generalizes parallelism in that model o_0
16:23:04 <jmcarthur> johnw: Is downcasting ever not nasty type hackery?
16:23:06 <johnw> athan: but concurrency does not require or imply asynchronicity, though
16:23:20 <johnw> athan: https://wiki.haskell.org/Parallelism_vs._Concurrency
16:24:03 <athan> :o
16:24:05 <athan> thanks johnw 
16:24:16 <johnw> parallelism is increasing the number of instructions per clock cycle dedicated to a task, typically by running instructions on additional cores; concurrency is when you have multiple threads of execution active at one time, although they may not *execute* temporally at the same time
16:25:20 <athan> johnw: Yes exactly, that's where I think my actor model is flawed
16:25:21 <johnw> I concurrently serve 4 people breakfast by bringing each of them one part of the breakfast until I am done (rather than serving all parts to each person before moving to the next).  I cook 4 eggs in parallel by cracking all four and putting them on the stove at once.
16:25:41 <athan> parallelism guarantees that multiple actors exist, while concurrency may use them virtually
16:26:30 <allenj12> can you replace cabal install with stack install completely?
16:27:05 <jmcarthur> athan: Not really. Vectorization is another kind of parallelism. There are not necessarily other actors there.
16:27:10 <kadoban> allenj12: Probably. Is there some esoteric usage you're worried about?
16:27:57 <kadoban> allenj12: 'cabal install' does some stuff that stack does automatically, by the way, for instance all of the --dependencies-only stuff comes to mind, you no longer have to manually do that.
16:28:07 <athan> jmcarthur: Hmm, that's interesting. Thanks!
16:28:24 <allenj12> kadoban: no, just getting some error and was a little confused since stack is cabal. I think i figured out tho
16:28:43 <athan> allenj12: stack /= cabal
16:28:53 <dcoutts> kadoban: fortunately that's also going to go away with upcomming versions of cabal
16:28:57 <athan> stack is an alternative to the `cabal` command!
16:28:59 <gaze__> johnw: Then what's a term rewriting system fall under?
16:29:03 <kadoban> allenj12: Have you read a beginner guide for stack? It's used in different ways.
16:29:05 <allenj12> athan: well i ment stack is built of cabal
16:29:10 <johnw> jmcarthur: but downcasting is asking an implementation whether it also supports some other interface; so my Superclass record has a function query :: Superclass -> Maybe Subclass. The magic of making it automatically available for all possible subclasses is a nifty trick, though.
16:29:11 <gaze__> I guess just general nondeterminism
16:29:32 <allenj12> kadoban: yea reading it now, but also trying to follow https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md
16:30:04 <mjrosenb> is there a recommended way to run 'cabal build' from inside emacs? I've just been running M-x compile recently.
16:30:08 <kadoban> dcoutts: Nice.
16:30:43 <jmcarthur> johnw: I see. Downcasting isn't about the type, but the interface. That makes sense. You're right. I can't think of a way to do that with this representation of objects.
16:30:46 <allenj12> 'stack install present' seems to not find a package after i added it to my yaml
16:31:44 <kadoban> allenj12: What did you add to your stack.yaml?
16:32:18 <allenj12> what it told me to in the error 'atto-lisp-0.2.2.2'
16:32:27 <jmcarthur> johnw: There would need to be some machinery allowing   getDict :: a -> Maybe (Dict (c a))
16:33:20 <kadoban> allenj12: I'm sure you're aware that I have no idea what it told you to add, so …
16:33:40 <kadoban> allenj12: And what exact error are you getting then after that?
16:33:41 <jmcarthur> johnw: Perhaps something similar to Typeable. Just as every type has Typeable, every type class could have an instance of some specific type class that has getDict. I haven't though about whether this actually works, though.
16:33:55 <allenj12> kadoban: sorry i ment to just summarize it told me to add a package to extra deps, and told me which package
16:34:15 <jmcarthur> class TypeClassable c where getDict :: a -> Maybe (Dict (c a))
16:34:20 <johnw> jmcarthur: keep going, and you'll re-develop the virtual table dispatch mechanism from C++ and then gaze__ can sleep soundly tonight
16:34:36 <jmcarthur> heh
16:35:21 <allenj12> kadoban: i actually figured it out, its installing now! btw so all installed packages are local correct? i cant reference them in other stack packages without re-adding it to extra deps?
16:35:59 <kadoban> allenj12: Ah cool.
16:36:21 <kadoban> allenj12: I'm not sure I understand the question exactly
16:36:40 <monochrom> . o O ( message dispatch loop for the win. literally. that is, for the windows api, literally. :) )
16:40:06 <allenj12> kadoban: so if I did 'stack new proj' then went into that new project and tried to use a package installed in an old project, it would not work?
16:43:01 <kadoban> allenj12: What do you mean by a package installed in an old project? You don't manually install packages is why I ask. It figures out where to get packages from using the resolver and extra-deps, and then it compiles them when it needs to and usually shares them between sandboxes that it manages itself.
16:43:29 <allenj12> kadoban: o ok that makes sense
16:44:43 <kadoban> So really the only time you ever use 'stack install' is to install executables to ~/.local/bin (because that's all it does that's a real effect, the rest is beind the scenes)
16:48:00 <AriesClan> http://www.filedropper.com/ariesstresstester Free ddos tool
16:50:54 <pranz> @where mods
16:50:55 <lambdabot> I know nothing about mods.
16:51:03 <pranz> @where op
16:51:03 <lambdabot> I know nothing about op.
16:51:04 <pranz> @where ops
16:51:05 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
16:51:20 <Cale> pranz: what?
16:51:22 <shachaf> They're already gone.
16:51:32 <pranz> oh
16:51:41 <Cale> Yeah, AriesClan got K-Lined almost instantly :)
16:53:03 <Welkin> Cale: aw, and he left such a neat tool for use to use
16:53:15 <Welkin> he will always be remembered as a martyr
16:58:52 <shachaf> I wonder whether Henning wants Coyoneda.
17:00:53 <isd> Is there a good summary out there of the various approaches people have taken re: interfacing haskell with object-oriented systems?
17:01:21 <orion> isd: https://wiki.haskell.org/FFI_cook_book
17:01:40 <tobiasBora> Hello !
17:01:43 <EvanR> if object-oriented means java, look at java-bridge
17:02:01 <tobiasBora> I would like to use pontarius-xmpp, but I have a little problem with it :
17:02:52 <tobiasBora> the server is in https but hasn't any good certificate, so I get an error like 
17:02:53 <tobiasBora> test.hs: XmppFailure: TlsError (XmppTlsException (HandshakeFailed (Error_Protocol ("certificate rejected: [NameMismatch \"XXX.com\"]",True,CertificateUnknown)))
17:03:10 <tobiasBora> Does anyone knows how I could avoid this problem ?
17:04:06 <tobiasBora> Here is the code I'm using :http://pastebin.com/A5Uk6FCW
17:05:21 <isd> I'm actually looking at an RPC protocol. I'm thinking less in terms of specific tooling and more in terms of what the resulting exposed interface looks like.
17:06:29 <isd> e.g. how do you model inheritance and such? What does the user of the binding see?
17:10:06 <isd> The QtQuick bindings contain some interesting ideas, I was looking for other sources of inspiration.
17:10:58 <EvanR> if the OOP API has a method that accepts any subclass of C
17:11:11 <isd> (hsqml that is)
17:11:32 <EvanR> then model C as a record type with all the features of C
17:12:16 <EvanR> thats how i would model it in haskell assuming the implementatino was in haskell, but since its RPC, its all ByteStrings in the end
17:13:08 <EvanR> so you dont actually have to model inheritance just have support for all the possible ways you can use the API
17:13:10 <isd> EvanR: yeah, I'm not worried about low, level marshaling. Specifically, I'm looking at capnproto.
17:13:24 <EvanR> do you have a specific API in mind
17:14:23 <isd> So FFIs for different languages might actually be more interesting I think, since it's not really one API.
17:14:44 <EvanR> >_>
17:14:52 <isd> tobiasBora: I will look at java-bridge; that sounds like a possible source of inspiration.
17:15:08 <isd> Does anyone know of any other languages besides C and Java that people have tackled?
17:15:14 <EvanR> theres *the* ffi, and then java-bridge is a very complex control panel into all of java's details
17:15:40 <EvanR> the usual way is to make a C language glue for whatever youre trying to do
17:15:56 <isd> bleh.
17:16:06 <EvanR> which is what java-bridge is
17:17:00 <isd> hsqml has an intriguing approach; if I can't find any other sources of inspiration I may just try modeling it after that.
17:19:42 <texasmynsted> anybody happen to know the right way to get color to work on ghci under stack?  If I do "stack ghci", I see no color.  If I do "stack ghci —colour" I get an error/warning.
17:20:23 <texasmynsted> Nothing useful in docs here http://docs.haskellstack.org/en/stable/GUIDE.html#ghci-the-repl
17:20:29 <tobiasBora> isd: Your message isn't for me right ?
17:20:39 <isd> tobiasBora: not really, no.
17:20:55 <EvanR> also id recommend in your application trying to do it in a nicer hasklley way that does what it can to hide the OOP stuff
17:20:58 <isd> I mean, doesn't reqlly require  a response.
17:21:06 <EvanR> rather than trying to use haskell like java or c#
17:21:33 <isd> EvanR: yeah, that's what I was looking for advice on how to do, given an interface that is fundamentally OO under the hood
17:22:15 <EvanR> example?
17:22:20 <isd> Are most successful attemps at that just highly app-specific?
17:22:44 <isd> I guess I'm looking at something that's general enough that I'm not hopeful about that.
17:23:05 <isd> Strikes me as one level up -- this would basically be writing a binding to a new "language"
17:23:54 <EvanR> so you want to for example use code written in D from haskell
17:25:15 <EvanR> make the haskell interface you want for your app, then implement it in terms of the FFI. for D or C++ this usually means having entry points that dont involve any OO stuff
17:25:21 <isd> I guess I could just represent capnproto's "interfaces" as records, with functions to (IO something) as fields. I could just add functions for casting up where necessary
17:26:02 <EvanR> capnproto is something youre saying is inherently OO under the hood?
17:26:26 <isd> I guess what I'm dealing with is more how to design those entry points when the thing I'm calling itself has an OO interface
17:26:40 <isd> EvanR: https://capnproto.org/
17:26:54 <EvanR> i see, but do you have an example method
17:27:21 <isd> Much of it is fine, just marshalling data structures. But the interface type poses some questions. The record thing I mentioned is the only thing I've really come up with.
17:27:25 <EvanR> for serialization youre probably better off just not using this
17:28:18 <isd> EvanR: https://capnproto.org/language.html#interfaces
17:29:16 <EvanR> to use "interfaces" in your program you make record types
17:29:39 <orion> Haskell isn't supported with capnproto.
17:30:05 <EvanR> ]
17:30:07 <isd> orion: yeah, I was thinking of changing that.
17:30:14 <EvanR> yeah there are better ways to serialize your stuff in haskell
17:30:30 <texasmynsted> interesting ghci —colour does not work despite what it says here https://wiki.haskell.org/GHCi_in_colour
17:30:54 <orion> isd: You could write a C wrapper around the official capnproto C++ interface and then use the Haskell FFI to cross the language boundary.
17:31:26 <orion> EvanR: What's better than capnproto?
17:31:39 <EvanR> binary
17:32:36 <orion> Why?
17:33:29 <EvanR> because haskell isn't C++ ?
17:33:46 <EvanR> Binary instances can be autogenerated for your types
17:34:09 <EvanR> they serialize and deserialize efficiently
17:34:28 <isd> The interesting thing is the RPC protocol. And if I were only interested in interfacing haskell progroms, and only programs I've written myself, then this might be an interesting line of inquiry.
17:35:09 <isd> But, as is, this suggestion is about as useful as if I'd come in asking about how to parse HTML and you'd told me not to use the web.
17:35:40 <texasmynsted> I have a haskell study group that I am starting.  Can anybody recommend and tools that I should check that mIght be useful when examining haskell code as a group?
17:35:45 <EvanR> you're not being too clear about what youre trying to
17:37:55 <zachk> texasmynsted whats the level of the group? I really like Programming Haskell by Graham Hutton as a beginner's book 
17:38:17 <nshepperd> The best thing to do with a oo interface is figure out how to rewrite it as a non oo interface
17:39:49 <texasmynsted>  Beginner.  We will be going through Chris Allen's Haskell from first principles book
17:40:20 <zachk> haven't heard of that, until now 
17:40:22 <zachk> :D
17:40:23 <orion> Does cloud-haskell support something similar to the "time travel" feature of capnproto?
17:40:34 <zachk> time travel? 
17:40:47 <orion> https://capnproto.org/rpc.html
17:40:55 <isd> zachk: pipelining
17:41:00 <isd> but yeah, see the link
17:41:18 <Nadrieril> https://hackage.haskell.org/package/tardis-0.3.0.0/docs/Control-Monad-Tardis.html ?
17:41:21 <Nadrieril> :p
17:41:33 <EvanR> orion: no
17:44:58 <zachk> cloud haskell is message passing, not directly rpc, but I think it can do that perhaps with the mkClosure'' template, but I haven't used it that much 
17:45:35 <texasmynsted> orion.  :-)
17:45:43 <texasmynsted> Hello
17:45:43 <Ygg> Hello !
17:46:20 <Ygg> just started learning haskell yesterday and I must admit I'm having a hard time wrapping my head around some of the concepts
17:46:52 <texasmynsted> Then you must be really learning it
17:47:02 <dmj`> Ygg: cool !
17:47:26 <dmj`> athan: A-town ping
17:47:58 <Cale> Ygg: anything you have questions about?
17:49:03 <Ygg> there's one thing in particular that's been really bugging me amongst the many
17:49:16 <Ygg> I'm currently following this tutorial
17:49:16 <Ygg> http://andrew.gibiansky.com/blog/haskell/haskell-gloss/
17:49:40 <Ygg> and at one point he uses the "uncurry" function
17:49:52 <zachk> @type uncurry 
17:49:53 <lambdabot> (a -> b -> c) -> (a, b) -> c
17:50:13 <dmj`> @src uncurry
17:50:14 <lambdabot> uncurry f p = f (fst p) (snd p)
17:50:26 <zachk> do you know what tuples are? 
17:50:34 <Ygg> yes
17:50:37 <EvanR> after finding an alternative explanation of capn proto somewhere else, it seems like you could write a haskell implementation for it and not deal with any OOP anything
17:50:43 <dmj`> > uncurry (+) $ (,) 1 1
17:50:44 <lambdabot>  2
17:51:00 <Ygg> wow that bot
17:51:01 <zachk> do you know that (a -> b -> c) is the same thing as (a -> (b -> c)) ? 
17:51:26 <Cale> > uncurry (+) (1,1)
17:51:28 <lambdabot>  2
17:51:29 <Cale> heh
17:51:32 <EvanR> on the haskell side you would only be given access to raw structures similar to the aeson json value 
17:51:34 <Ygg> I do. even though I'm still keeping the page about curried function as a bookmark
17:51:59 <zachk> this is slightly wrong, uncurry takes a regular function that takes two arguments as input and produces a new function that take a 2-tuple as input instead of the two seperate arguments 
17:51:59 <Cale> So yeah, uncurry just takes a function of two arguments and a pair and applies the function to the parts of the pair.
17:52:01 <EvanR> then your application can have whatever interface it wants on top of that
17:53:01 <Cale> (zachk and I said the same thing in a different way)
17:53:16 <Ygg> I think I got what it does but I don't understand why it is useful in that case (nor do I understand how and when it can be useful
17:53:43 <Ygg> wait
17:53:52 <dmj`> Ygg: ballLoc is a tuple
17:53:54 <EvanR> uncurry is useful when trying to do pointless golf code
17:53:59 <Cale> Well, translate's first two arguments are Floats
17:53:59 <Ygg> I think I got it by myself
17:54:00 <Ygg> yeah
17:54:05 <ReinH> Ygg: you have a tuple and you want to pass it to a function that accepts two arguments.
17:54:13 <Cale> So uncurry translate :: (Float,Float) -> Picture -> Picture
17:54:22 <zachk> functions in haskell, techinically only take one argument, so a two argument function actually takaes one argument and produces another function that takes one argument and returns a value, finally 
17:54:24 <ReinH> so you need \(x,y) -> f x y
17:54:27 <ReinH> that's uncurry
17:54:34 <Ygg> Thanks.
17:54:47 <dmj`> :t \f (x,y) -> f x y 
17:54:48 <lambdabot> (t -> t1 -> r) -> (t, t1) -> r
17:54:52 <dmj`> @src uncurry
17:54:52 <lambdabot> uncurry f p = f (fst p) (snd p)
17:54:52 <EvanR> @pl \(x,y) -> f x y
17:54:52 <lambdabot> uncurry f
17:55:00 <ReinH> so what you do is take the function that takes two arguments and change it to a function that takes a tuple.
17:55:09 <Ygg> it's pretty awesome how something that appeared incredibly obscure to me just minutes ago just makes sense now
17:55:12 <Cale> We don't actually need to understand much about the way that functions are curried in order to understand uncurry here :P
17:55:35 <ReinH> then you can pass the tuple that *new* function 
17:55:44 <EvanR> :t uncurry3
17:55:45 <lambdabot>     Not in scope: ‘uncurry3’
17:55:45 <lambdabot>     Perhaps you meant ‘uncurry’ (imported from Data.Tuple)
17:55:49 <Cale> Though I suppose it *is* interesting that we're applying uncurry to a function of *three* arguments
17:55:51 <ReinH> it may help to mention that uncurry f (x,y) is (uncurru f) (x,y)
17:55:55 <Ygg> :t uncurry
17:55:56 <lambdabot> (a -> b -> c) -> (a, b) -> c
17:55:58 <ReinH> *uncurry
17:56:07 <Cale> It's just that c = Picture -> Picture here
17:56:12 <Cale> a = b = Float
17:56:14 <ReinH> that makes it more obvious that uncurry is acting on a function and returning a new function, which is then applied to the tuple
17:56:26 <EvanR> @pl \(x,y,z) -> f x y z
17:56:26 <lambdabot> (line 1, column 7):
17:56:26 <lambdabot> unexpected "z"
17:56:26 <lambdabot> ambiguous use of a non associative operator
17:56:48 <EvanR> wtf
17:57:00 <Cale> The fact that uncurry is curried doesn't matter, the fact that translate is curried is what's making a difference here :)
17:57:25 <nolrai2> EvanR: indeed.
17:57:43 <EvanR> pl doesn't know triples?
17:57:46 <dmj`> :t curry . uncurry
17:57:46 <ReinH> ok good work Team Everyone Give Their Answer At The Same Time
17:57:48 <lambdabot> (a -> b -> c) -> a -> b -> c
17:57:52 <Cale> heheh
17:57:59 <Ygg> heh.
17:58:00 <Cale> EvanR: that's right, it doesn't
17:58:09 <dmj`> high fives all around
17:58:14 <nolrai2> Oh.
17:58:20 <Ygg> :t curry
17:58:21 <lambdabot> ((a, b) -> c) -> a -> b -> c
17:58:49 <Ygg> it's just the inverse function then
17:59:26 <Ygg> ok, thanks guys. I have another question concerning that tutorial actually
17:59:35 <EvanR> curry . uncurry = ($)
17:59:50 <EvanR> ($) = id ;)
18:00:56 <dmj`> Ygg: ask away
18:01:07 <Ygg> for the pause/unpause exercice, here's what I added to the handleKeys function
18:01:15 <Ygg> handleKeys (EventKey (Char 'p') _ _ _) game
18:01:15 <Ygg>     | ngame == game =  game { paused = True}
18:01:15 <Ygg>     | otherwise = game {paused = False}
18:01:15 <Ygg>     where
18:01:15 <Ygg>     	notPaused y = y {paused = False}
18:01:15 <Ygg>         ngame = notPaused game
18:01:33 <dmj`> @where paste
18:01:33 <lambdabot> Haskell pastebin: http://lpaste.net/
18:01:50 <Ygg> thanks
18:02:24 <Ygg> but that actually causes the game to pause as long as I hold the key
18:02:30 <Ygg> and I don't understand why
18:05:03 <Cale> Ygg: I think there's a field of the EventKey constructor which says whether the event is for key up or key down?
18:05:14 <Cale> lemme check the doc
18:05:44 <zachk> if there is an event other then Char 'p' and iirc gloss.event handles keys being pressed down and being relased 
18:05:45 <Cale> ah, yeah
18:05:54 <zachk> so when it is pushed down it sets it to paused 
18:06:03 <Ygg> it seems to be but that's for the next exercise
18:06:09 <zachk> when it is anything else other then that event it unpauses 
18:06:22 <Cale> Ygg: So your handler there matches both the KeyUp and KeyDown cases
18:07:02 <Cale> So if you toggle on each, it'll pause when it's KeyDown, and then unpause again when the KeyUp happens
18:07:55 <zachk> have you tried hitting another key with that code while holding down p? it might unpause because of it's logic 
18:08:32 <Ygg> will do
18:08:56 <Ygg> no, it doesn't
18:09:22 <Ygg> I'll look up what field does what
18:13:48 <Ygg> yep, works fine. thanks.
18:18:56 <zachk> how do I construct a Reader r? 
18:19:42 <pavonia> zachk: That does what?
18:19:55 <EvanR> :t return 9
18:19:57 <lambdabot> (Monad m, Num a) => m a
18:20:35 <zachk> oh yeaaa
18:20:47 * zachk is still trying to completely wrap his head around monads
18:20:49 <EvanR> :t ask
18:20:51 <lambdabot> MonadReader r m => m r
18:21:06 <EvanR> :t (>>=)
18:21:07 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:21:12 <dmj`> zachk: monads must wrap their heads around you first
18:21:30 * EvanR sticks head in a transformer stack
18:24:06 <zachk> what about their tails? 
18:25:32 <zachk> so if I stuff monads in a Moonad m a b newtype and make a Category instance for Moonad for all monads, could that impact evaluation? cause I am trying to apply a function that uses forever to work over Moonads and ghci just sits there and I can't even Ctrl-C to break out of it 
18:25:49 <zachk> I am using return as id for Category and >=> as . for Category 
18:28:26 * hackagebot hoauth2 0.5.0 - hoauth2  https://hackage.haskell.org/package/hoauth2-0.5.0 (HaishengWu)
18:31:57 <zachk> here is my code: http://lpaste.net/148390 
18:32:15 <EvanR> zachk: theres already this Category, its called Kleisli in the arrow lib
18:33:04 <zachk> oh, I was just writing my own to figure out monads/arrows more 
18:33:11 <zachk> what about using forever with it? 
18:33:17 <EvanR> you cant
18:33:37 <zachk> what about creating my own function that uses forever over it? 
18:33:47 <EvanR> what is its type?
18:33:56 <athan> Hmm... has anyone bound GPipe to an FRP library, yet?
18:34:31 <athan> I'm just wondering how to decouple time and rendering
18:35:31 <zachk> weird, the type changed, even though I had been doing saves and reloads 
18:36:29 <EvanR> return doesn't seem to be the right type for id either
18:37:24 <zachk> isn't return the neutral element for the monoid that is monad? 
18:38:34 <EvanR> id :: Kleisli m a a
18:38:44 <EvanR> return :: a -> m a
18:40:43 <EvanR> Kleisli return, i guess
18:41:23 <zachk> everMore :: Monad m => Moonad ((->) a) t a1 -> t -> Moonad m a b
18:41:55 <zachk> I recognize the first part as analogous to the reader monad, but I am not sure how to use it
18:43:08 <dmj`> Moonad? Is this some new abstraction derived from livestock
18:44:47 <pikajude> moonads form burritos
18:45:19 <EvanR> everMore :: Monad m => Moonad m a b -> a -> m c
18:45:30 <EvanR> could work, maybe
18:45:57 <EvanR> it will go into an infinite loop and never produce anything of type c which is any type
18:46:16 <EvanR> implement using forever and runMoonad
18:46:57 <Ygg> off to bed. see you and thanks again.
18:47:34 <athan> CouldWork :: 'Maybe (Moonad m) => m ('Proxy Constraint)
18:47:38 <dmj`> when certain Moonads implement MilkEffect m e there are side effects
18:47:44 <texasmynsted> Wow, http://www.kronosnotebook.com/haskell is nice
18:47:48 <ontop> If I have a function: rofl :: f a -> Bool (the Bool isn't important) -- Is the "f a" part a "higher kinded" type?
18:48:03 <MarcelineVQ> EIEIO () Moonad
18:48:10 <dmj`> ontop: yes
18:48:12 <athan> ontop: Yezzir
18:48:23 <athan> well, the `f` more specifically
18:48:29 <athan> because it's a parametric type
18:48:43 <ontop> Rite.
18:50:24 <zachk> EvanR yea I have type signature as ever 
18:50:48 <zachk> why does it go into an infinite loop? even one that locks up ghci to the point of no ctrl-c.... 
18:51:15 <EvanR> maybe you are on windows and the correct strokes are control Z
18:51:18 <athan> ontop: Types are like functions, you can do then so much as to even look like them are doing basically
18:51:48 <ontop> I C IC.
18:51:52 <athan> zachk: Sometimes that happens when you re-reference something in a record syntax :\
18:52:08 <athan> like `let foo = foo {someField = someField foo}`
18:52:20 * zachk starts to think records are evil in haskell, all together...
18:52:24 <athan> this will make you eat itself
18:52:28 <EvanR> types are not like functions 
18:52:29 <athan> zachk: That's what I thought at first
18:52:38 <zachk> so if I madea seperate constructor/wrapper and deconstructor/unwrapper, it would work? 
18:53:08 <ontop> I have a general Haskell question, does anyone feel like Haskell is a complex language with complex tools and that it's undesirably so?
18:53:20 <EvanR> type constructors are like functions on types
18:54:27 <EvanR> ontop: relative to other systems, no
18:55:26 <athan> texasmynsted: Nice find!!
18:55:33 <ontop> What other system? :|
18:55:57 <athan> ontop: It's hard to start out, but it's cleaner than my room
18:55:58 <EvanR> C++ java 
18:56:12 <EvanR> scala
18:56:41 <ontop> I hate C++ Java and Scala.
18:56:43 <ontop> What else you got?
18:57:14 <zachk> you basically dont have subtyping, inheritance, or OO basically, with easy mutable state, but everything is quite nice 
18:57:32 <zachk> scheme? forth? 
18:57:45 <ontop> Well, I come from Ruby/Go, and that feels simple. Maybe it's because it's what I know?
18:57:59 <zachk> that everMore code is so bad, I can't even killall the ghc running the ghci 
18:58:01 <EvanR> just dont try to work on anyone's ruby code
18:58:09 <ontop> EvanR: I agree with the sentiment.
18:58:27 <zachk> whats that like?
18:59:02 <ontop> Working on someone's ruby code?
18:59:27 <EvanR> zachk: kill -s KILL
18:59:45 <zachk> yea
18:59:47 <ontop> Well, it has completely unqualified imports and monkey patching (before refinements) as a feature. Basically the worst thing ever.
19:00:59 <athan> ontop: There's no way you can modify a class/type in haskell
19:01:00 * EvanR throws PHP into that list
19:01:04 <athan> it's all static at compile time
19:01:18 <athan> (unless you're a TemplateHaskell person >.>)
19:01:19 <ontop> Is there no reflection ever?
19:01:24 <ontop> What's TemplateHaskell?
19:01:28 <EvanR> yes haskell has a lot of simplifications over normal languages
19:01:33 <athan> a reflection/reification method
19:01:40 <athan> Haskell's AST becomes a data type
19:01:50 <ontop> I mean, it's patterns (Functors, Applicatives, Monads, IO etc) doesn't seem simple.
19:01:54 <EvanR> TemplateHaskell is not for reflection
19:02:06 <EvanR> the reflection library however
19:02:12 <ontop> don't*
19:02:23 <EvanR> Functor is very simple
19:02:26 <athan> EvanR: bah, bastardized reflection maybe :p
19:02:33 <athan> reflection = types -> terms, right?
19:02:38 <EvanR> > fmap (+1) [1,2,3]
19:02:40 <lambdabot>  [2,3,4]
19:02:43 <athan> er no, that's reification, correcT?
19:02:46 <EvanR> > fmap (+1) (Just 4)
19:02:47 <lambdabot>  Just 5
19:02:48 <ontop> Functor is.
19:02:58 <athan> friggin -XDataKinds + typelits could be a reflection in that case lol
19:03:11 <ontop> Applicative is also fairly ok.
19:03:16 <ontop> I just got to Monads in my book.
19:03:28 <zachk> IO is a Monad, Monads are Applicative, and Applicative is a Functor, learn IO, Maybe, List/[] and use Data.Map for hashes, maybe some StateT over IO, and Control.Lens over records and you should be ok 
19:03:28 <EvanR> Monads? meh skip it ;)
19:03:46 <ontop> What's a Control.Lens?
19:03:51 <ontop> I've used Data.Map
19:03:52 <EvanR> zachk: StateT over IO, bleh... just IO ;)
19:04:30 <EvanR> learn records before you start getting into lens
19:04:53 <ontop> What's a record?
19:05:00 <ontop> Like Data stuff?
19:05:02 <zachk> EvanR thats what I usually do and pass the state as arguments into the next loop 
19:05:14 <zachk> its like a struct from C, but they are immutable 
19:05:15 <EvanR> ontop: a product with named fields
19:06:14 <EvanR> its not like a struct in that theres no implication about memory layout
19:06:16 <athan> holy frick shaders are Alternatives?!
19:06:17 <zachk> products are just tuples
19:06:31 <ontop> I forget record syntax.
19:06:49 <EvanR> {a = 1, b = 2}
19:06:50 <athan> ontop: It's a convenience for normal pattern matching / data constructors
19:07:02 <ontop> Yap.
19:07:11 <zachk> data Object = Object { identifier :: Int , name :: String, description :: String } deriving bla bla bla 
19:08:06 <EvanR> data EAV = EAV { entity :: String, attr :: String, value :: Dynamic } ;)
19:08:15 <EvanR> and be damned!
19:08:24 <zachk> whats Dynamic!!!
19:08:35 <EvanR> a dynamic type
19:08:51 <athan> value :: (::)
19:08:57 <athan> okay sorry x_x
19:09:16 <EvanR> zachk: do you know about Typeable
19:10:01 <EvanR> :t typeOf
19:10:02 <lambdabot> Typeable a => a -> TypeRep
19:11:03 <EvanR> you can use it for dynamic typing among other things, and suffer the same consequences as e.g. ruby
19:11:26 <athan> and be damned :|
19:11:42 <athan> like Exceptions, who needs 'em, eh?
19:11:54 * athan slowly learning the rediculous advantages
19:11:57 <EvanR> exceptions are the shit (for IO errors)
19:12:10 <athan> EvanR: Typeable is usually more performant than alternatives too, right?
19:12:15 <athan> I agree :)
19:12:34 <EvanR> performant?
19:12:52 <athan> I've seen people use crazy typed `traverse` functions that I'm guessing do some faster coercing and the like
19:13:20 <athan> EvanR: Well, without the type as a variable, you don't need to keep the two word-sized pointers to the variable
19:13:26 <athan> in the data constructor I mean
19:13:31 <EvanR> Dynamic adds runtime overhead, just as in e.g. ruby
19:13:41 <athan> I'm not sure if you can use {-# UNPACK #-} with Dynamic, though
19:13:42 <EvanR> because its doing comparisons on typereps
19:13:55 <athan> Ow wow I didn't know
19:14:12 <athan> I heard something along the lines of "all type families get erased" or something
19:14:19 <athan> or that some constraints can get erased
19:14:21 <EvanR> types are erased
19:14:26 <athan> dayum
19:14:35 <athan> okay cool so I should keep doing insane stuff
19:14:37 <EvanR> TypeReps arent types
19:14:45 <athan> herp :x
19:14:46 <EvanR> they are values
19:14:55 <EvanR> > typeOf 'x'
19:14:57 <lambdabot>  Char
19:15:32 <EvanR> Dynamic is a TypeRep paired with the value of that type
19:15:41 <athan> @type Dynamic
19:15:42 <lambdabot>     Not in scope: data constructor ‘Dynamic’
19:15:42 <lambdabot>     Perhaps you meant variable ‘_Dynamic’ (imported from Data.Dynamic.Lens)
19:15:52 <athan> hmm
19:15:54 <athan> erp
19:16:02 <athan> @type typeOf 'x'
19:16:03 <EvanR> if you try to coerce a Dynamic of the wrong type back undynamic, itll fail
19:16:03 <lambdabot> TypeRep
19:16:15 <athan> hmm
19:16:34 <athan> do those style of exceptions throw normally?
19:16:42 <athan> because I could see that being hell if you tried to catch one
19:16:49 <jdvs> i put the bmiTell function from http://learnyouahaskell.com/syntax-in-functions into a file, and the main execution block looks like this: main = do { x <- bmiTell 85 1.90; print x }
19:16:51 <EvanR> catch what?
19:17:13 <jdvs> error from execution of the file:  Couldn't match type ‘IO’ with ‘[]’
19:17:13 <athan> EvanR: A type failure from TypeRep
19:17:22 <jdvs> In a stmt of a 'do' block: print x
19:17:34 <EvanR> :t fromDyn
19:17:35 <lambdabot> Typeable a => Dynamic -> a -> a
19:17:36 <jdvs> Expected type: [()]
19:17:38 <athan> jdvs: `x` might be monadic
19:17:41 <jdvs> Actual type: IO ()
19:17:48 <EvanR> :t fromDynamic
19:17:50 <lambdabot> Typeable a => Dynamic -> Maybe a
19:17:54 <jdvs> :t print
19:17:56 <lambdabot> Show a => a -> IO ()
19:17:56 <EvanR> catch the Nothing
19:18:14 <athan> hrm
19:18:16 <athan> okay
19:18:22 <athan> thanks EvanR :)
19:18:29 <zachk> night everyone!
19:20:02 <athan> holeh crêpe, GPipe is tubular
19:21:10 <jdvs> athan: x is the result of running bmiTell 85 1.90 where bmiTell :: (RealFloat a) => a -> a -> String
19:22:01 <jdvs> print takes an A and produces an IO type (i guess that is what it is called)
19:23:14 <EvanR> print takes an a and produces an IO action
19:23:16 <jdvs> sorry for the caps, it takes type a
19:23:22 <jdvs> thanks EvanR 
19:23:33 <EvanR> > print "fruit"
19:23:35 <lambdabot>  <IO ()>
19:24:12 <EvanR> you can pass IO actions around, put them in containers, hide them in closures
19:24:14 <athan> jdvs: No your wording is correct! Or a "type that's inside IO", something like that usually works
19:24:31 <athan> I'm guessing you're either trying to call a `print (print x)` then, or something like that :\
19:25:47 <athan> man, GPipe is so cool
19:26:33 <jdvs> print $ print x -- produces the same error
19:26:38 <jdvs> and it feels weird :)
19:26:47 <EvanR> why are you trying to print an IO action
19:27:07 <jdvs> i was told i might need something along those lines just now
19:27:17 <athan> Now, once I can learn how to VSync, and tie it to an FRP library, then I'll have something pretty shnazzy :)
19:27:38 <khole> c_wraith: so I tried your suggestion, but couldn't get it to work? http://lpaste.net/148391. Any ideas?
19:27:40 <athan> jdvs: No sorry! I meant to say that you _could_ be doing that, while it's the wrong thing to do
19:27:47 <khole> It only prints "hello" once
19:28:49 <EvanR> jdvs: bmiTell isn't an IO action so you can't use it with <- notation
19:29:33 <EvanR> x <- act means execute act and have the result (once complete) in x
19:30:04 <EvanR> use
19:30:18 <EvanR> let x = bmiTell foo bar
19:31:08 <jdvs> ah, thank you EvanR 
19:31:24 <EvanR> that might trip you up a lot until you get used to it
19:31:59 <EvanR> <- connects "monad actions" together, and let x = ... just assigns a name to the ...
19:33:55 <johnnymo87> @djinn ((a -> r) -> r) -> r
19:33:55 <lambdabot> -- f cannot be realized.
19:34:34 <johnnymo87> @djinn ((a -> a) -> r) -> r
19:34:34 <lambdabot> f a = a (\ b -> b)
19:36:38 <athan> Are FRP libraries often used to /manage/ a computation over time? Like managed lazyness?
19:36:48 <athan> where you only force WHNF as fast as time goes?
19:37:50 <c_wraith> khole: oh.  I had a slightly different use case in mind.  that doesn't work because the thing that's woken retries the action that waits, instead of doing something else when it's woken.  I was imagining the case when you actually include the logic in the STM transaction.
19:38:13 <EvanR> athan: ... manage?
19:39:55 <conal> A FRP behavior (possibly a complex, composite one) captures a flow of values over continuous time (uncountably many values). As with lazy (countable) infinite representations, the run-time decides what finite subset to actually evaluate/sample.
19:41:58 <khole> c_wraith: ah, I see, thanks
19:42:02 <khole> no worries
19:42:17 <c_wraith> khole: do you intend for Events to be re-usable, or only fire once?
19:42:27 <khole> multiple times
19:45:02 <pavolzetor> I managed to remove some bits and get relatively decent speedup (close to 2)
19:45:13 <pavolzetor> I will test tomorrow on more cores
19:45:22 <pavolzetor> anyhow, I have few questions
19:45:32 <athan> conal: Thank you :)
19:46:05 <pavolzetor> first, profiling shows that the cost centre of 45% of all allocs is fmap
19:46:28 <pavolzetor> https://github.com/pavolzetor/currypath/blob/master/src/Lin/V3.hs
19:46:39 <pavolzetor> line 30
19:47:04 <pavolzetor> I do not understand why. I understand the time spent there (because it is doing most work) but not the allocs
19:47:46 <pavolzetor> second, is it worth creating V3D with unboxed doubles?
19:48:23 <pavolzetor> third, suppose I am doing splitting of geometry and I want to filter rays, what should I use for this? should I write it in ST monad?
19:48:48 <jdvs> :t getLine
19:48:49 <lambdabot> IO String
19:49:06 <jdvs> iirc there's a way to unwrap this and extract the String value
19:49:29 <jdvs> functors, monoids, one of those
19:50:56 <jdvs> i think it's the arrows in the do block, and i probably need a function to convert the String to a RealFloat
19:52:38 <jdvs> or String -> Integer since RealFloat isn't a type it seems
19:53:33 <EvanR> jdvs: no, theres no wrapping to unwrap
19:53:59 <EvanR> IO String is an IO action, you might get a String if you execute the action
19:54:19 <EvanR> > read "3.1415" :: Double
19:54:21 <lambdabot>  3.1415
19:54:53 <conal> athan: you bet.
19:56:30 <Cale> jdvs: Unwrapping is the wrong way to think of it
19:56:50 <Cale> jdvs: getLine isn't a String with some stuff around it, any more than /bin/ls is a list of files in a box
19:57:02 <conal> athan: that discreteness thwarts modularity just as strictness does (see "Why Functional Programming Matters") seems to be under-appreciated.
19:57:05 <Cale> It's a program, which could be run to produce a String
19:58:21 <Cale> So, yeah, inside a do-block, you can write  xs <- getLine  which means "execute the action getLine, and call its (String) result xs". The do-block as a whole will then itself be an IO action, with the same type as the action on its last line (whose result will be the result of the whole action)
20:00:36 <jdvs> is there a coalition between Cale, EvanR, mauke, monochrom, and a few others to help build this community? you've all been helpful for ages 
20:00:44 <jdvs> i love all of you :)
20:01:30 <Cale> jdvs: thanks, and you're quite welcome to the help! :)
20:01:40 <EvanR> were all roommates on a really bad reality show
20:07:34 <jdvs> main = do { putStrLn "What is your weight?" ; weight < getLine ; {-...-}; let bmi = bmiTell (read weight) (read height) ; putStrLn bmi } 
20:07:39 <jdvs> it works!
20:08:13 <jdvs> um, <-, not <
20:08:48 <EvanR> nice
20:10:44 <pavolzetor> one last, is it possible to have an instance of foldable for data type which is not parametrized?
20:10:45 <pavonia> jdvs: Note that this will crash if the entered numbers can't be parsed correctly
20:11:20 <kadoban> pavonia: No. There's mono-traversable though, which may be what you're trying to do. (though it's less pervasive than Foldable)
20:13:21 <pavolzetor> kadoban: thanks, what are the other options?
20:13:45 <pavolzetor> I want to have an unpacked specialized type (vec3f) and have all the neat instances
20:13:54 <EvanR> just write a fold specifically for your type
20:14:26 <pavolzetor> But how? If I try do instance Foldable Vec3F where ...
20:14:34 <EvanR> you wont be able to use it in a generic way, but thats not possible anyway
20:14:36 <pavolzetor> it complains about it having king *
20:14:38 <pavolzetor> kind
20:14:53 <EvanR> just write a fold function for Vec3F
20:14:59 <EvanR> no classes
20:15:45 <pavolzetor> I see, I will have to weight the pros/cons then and profile if that is a problem
20:16:16 <kadoban> ? that seems like a weird response. Having Foldable wouldn't change the performance of it.
20:16:45 <pavolzetor> kadoban: I am thinking of having the type unboxed
20:16:59 <pavolzetor> and afaik it cant be polymorphic
20:17:07 <EvanR> right
20:17:16 <athan> wtf reactive-banana's MonadIO type? :s
20:17:25 <athan> er MomentIO**
20:18:04 <pavolzetor> I want to do some profiling first before I start on that work, but I just wanted to know what the options are
20:18:13 <kadoban> Oh I see
20:18:31 <pavolzetor> I think the biggest bottleneck now is how to do partitioning in functional way without to much overhead
20:20:36 <pavolzetor> I will start studying sorting algorithms; it is actually quite fun
20:20:46 <pavolzetor> and the performance is okay
20:46:52 <ReinH> \
21:28:30 * hackagebot pandoc-crossref 0.1.6.2 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.1.6.2 (lierdakil)
22:22:00 <echo-area> http://lpaste.net/148397  What do I do wrong in this translation?
22:22:14 <echo-area> It doesn't compile
22:24:34 <echo-area> Should the lambda calculus definition be translated directly?
22:28:31 * hackagebot wsdl 0.1.0.0 - WSDL parsing in Haskell  https://hackage.haskell.org/package/wsdl-0.1.0.0 (pikajude)
22:33:05 <pavonia> echo-area: What is the error message?
22:38:43 <Lokathor> ghc.exe: warning: _tzset from msvcrt is linked instead of __imp__tzset
22:38:48 <Lokathor> i can ignore that right?
22:39:04 <ReinH> Lokathor: I always ignore warnings. YOLO.
22:39:23 <ReinH> echo-area: I don't know. What is the error?
22:52:44 <owi> Hi. I'm having trouble with linking an precompiled archive into executables in Cabal. The library declares "ghc-options: -fPIC -Wall dist/go-lib/importer.a" and the executable depends on the library as I understand is the correct way to do this. However, on Linux it seems that when linking the exectuable Cabal does not include the archive and so I get an "undefined reference" error from ld. The full .cabal file: https://github.com/oden-lan
22:54:07 <owi> Note that it works on OSX. I'm using, on both OSX and Linux: cabal-install version 1.22.6.0 using version 1.22.4.0 of the Cabal library
22:55:09 <owi> Oops, link got cut off. here: http://bit.ly/1UpJUtT
22:55:59 <gamegoblin> Would it be possible to make an OverloadedMaybe extension that would insert Just’s for you. So if I had a function foo :: Maybe Int -> Int I could either call it like "foo Nothing" or "foo 5" and the extension would quietly change 5 to Just 5.
22:56:44 <gamegoblin> Or is there some subtely that makes that impossible?
23:03:03 <ReinH> gamegoblin: btw do you make games and do they involve goblins? I always wanted to ask.
23:03:20 <gamegoblin> ReinH: No, hahahahahahaha
23:03:32 <ReinH> I am somehow disappointed
23:03:42 <gamegoblin> ReinH: picked it pretty randomly, sorry :(
23:04:08 <ReinH> that is very unsatisfying
23:04:36 <ReinH> gamegoblin: anyway, in an ideal world `return 5` would always be what you mean.
23:04:48 <ReinH> Well. in an ideal world, `return` would not be called return.
23:07:43 <deadpigeon> return 3 cubits and 1 span, but the world is not ideal.
23:08:20 <echo-area> pavonia, ReinH: I've updated the link, http://lpaste.net/148397 The error is obvious though
23:08:37 <echo-area> It says `n` accepts only two arguments while providing three
23:08:50 <echo-area> https://en.wikipedia.org/wiki/Church_encoding
23:09:07 <echo-area> The lambda calculus definition is from here
23:09:19 <echo-area> (By obvious I mean clear)
23:10:52 <gamegoblin> ReinH: In an ideal world, would everything live in some sort of monad (even if that were the Identity monad)?
23:11:10 <gamegoblin> Or what do you mean exactly?
23:13:21 <gamegoblin> Hm. I guess what I want is a generic way to define a coercion from 
23:13:34 <gamegoblin> a -> x a
23:13:51 <gamegoblin> for some * -> * x
23:14:02 <ReinH> echo-area: I'm not sure what Church is but why do you expect that fuction to involve an Integer at any point?
23:14:26 <gamegoblin> Which is kind of like return, but I guess it’s more like pure. But I don’t want it to be tied to a sequence operation like in Applicative
23:15:06 <ReinH> gamegoblin: Pointed, which would have your putative a -> f a, is otherwise pretty useless
23:15:36 <gamegoblin> ReinH: I’d only want it if I had a language extension which did the coercion for me
23:16:13 <gamegoblin> So any particular literal could be `a` or `f a` depending on the inferred context
23:16:58 <gamegoblin> LIke how OverloadedStrings or OverloadedLists work
23:17:15 <ReinH> gamegoblin: I am dubious of any mechanism for coersion per se
23:17:23 <ReinH> we already have some, e.g.:
23:17:25 <ReinH> :t 1
23:17:26 <lambdabot> Num a => a
23:17:32 <ReinH> and they are already confusing enough
23:17:45 <gamegoblin> The other Overloaded* extensions can be confusing
23:17:48 <gamegoblin> Use at your own risk ;)
23:20:15 <gamegoblin> Anyone got any good programming music recommendations? Looking to add to my playlist.
23:22:31 <wei2912> gamegoblin: anything without lyrics will do
23:22:47 <gamegoblin> wei2912: I disagree, but I accept your opinion ;)
23:22:47 <wei2912> gamegoblin: you could try the inception OST when you need to meet deadlines :P
23:22:55 <gamegoblin> I’ll turn it on
23:23:11 <wei2912> familiar game soundtracks will work too
23:24:12 <gamegoblin> Listening to inception ost now
23:27:31 <gamegoblin> wei2912: this is great
23:29:34 <wei2912> gamegoblin: :P
23:29:41 <wei2912> gtg now, bye. have fun
23:48:34 * hackagebot gitHUD 1.1.0 - More efficient replacement to the great git-radar  https://hackage.haskell.org/package/gitHUD-1.1.0 (gbataille)
23:49:01 <bollu> I wanted to be added on the diagrams trello page
23:49:04 <bollu> who should I contact?
23:49:16 <bollu> Also, how much is the IHaskell notebook support for diagrams "done"?
23:49:19 <bollu> is it complete?
