00:01:45 <nitrix> How do I disable flags from packages using stack? (-example)
00:07:29 <zipper> Has anyone used cicrcle-ci with haskell?
00:07:41 * hackagebot rebase 0.2 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.2 (NikitaVolkov)
00:07:41 * hackagebot phoityne 0.0.3.0 - ghci debug viewer with simple editor.  https://hackage.haskell.org/package/phoityne-0.0.3.0 (phoityne_hs)
00:07:53 <zipper> My project requires base of 4.7 onwards but it hept saying it only provided 4.6
00:08:08 <zipper> So I changed to that for it to build but it broke other deps.
00:08:26 <zipper> Here they are: One with base 4.6 https://circleci.com/gh/urbanslug/urbanslug.github.io/10
00:08:56 <zipper> One with base 4.7 onwards https://circleci.com/gh/urbanslug/urbanslug.github.io/9
00:09:16 <zipper> How can I specify version of base in for my package except for in my cabal file?
00:24:52 <Ainieco> i hate orphan instances and the feeling of helplessness they bring because you can't do anything about them
00:27:38 <MarcelineVQ> hmm, there's two things you can do about them that come to mind
00:28:33 <Clint> depends whether you're the one perpetrating them on others or not
00:43:02 <Ainieco> most of the time i'm creating instances of types from library A for classes from library B, this is frustrating
00:44:31 <Ainieco> why is that even a bad thing(i know instances mutating context but why i need to be reminded of that every time...) if it's so common pattern
00:51:11 <Ainieco> geez, watching https://www.youtube.com/watch?v=ywOvfjpbYR4 now and they're having "src/Orphans" dir in their "enterprise" haskell project layout, oh my gawd
00:51:54 <phadej> Ainieco: yes, we do to, in our "enterprisy" apps
00:52:01 <phadej> *too
00:52:01 * Ainieco falls into orphan instances induced depression
00:52:24 <phadej> Ainieco: why so?
00:53:02 <Ainieco> phadej: because orphan instances considered to be a bad thing and you can't do anything about it.
00:53:06 <phadej> for some common data/classes there are packages providing them, eg. vector-instances of quickcheck-instances
00:55:15 <phadej> Ainieco: well, if you use those orphans providing packages, then you can care a bit less :)
00:56:20 <EvanR> aiui orphans arent that bad when youre writing an application
00:56:59 <phadej> Orphan instances are bad when they come from totally unexpected place; eg. library doing X depending on Y and Z, and definiting orphan instance for class in X for type in Y
00:57:31 <phadej> (which could be avoided with newtype, if X & Y cannot depend on each other)
00:58:09 <Ainieco> it's like with more or less mature surgeons - they have their personal graveyards, and every more or less mature haskeller have their own "orphanage"
00:58:14 * Ainieco cries
00:59:12 <EvanR> and orphans should be avoided when writing a library for other people to use
01:05:07 <Ainieco> people from video(above) have created their own prelude which includes their orphanage with all orphan instances they have for instance coherence
01:07:28 <obadz> In pipes, runEffects doesn't seem to require IO. Is pipes really implemented under the hood without IO/threads/MVars/STM/etc. ?
01:09:53 <Ainieco> there are two things which make me sick in haskell: first is lack of OverloadedRecordFields which is finally fixed, 
01:09:56 <Ainieco> and the second one is a really weak(compared to ML) module system with these freaking orphans, hope they'll fix that as well, i think backpack tries to solve thit but i feel i have to wait another 5 years like with ORF
01:15:00 <mniip> if we lift a Category with an Applicative, will it still be a category?
01:15:33 <mniip> instance (Applicative f, Category c) => Category (f c) where id = pure id; (>>>) = liftA2 (>>>)
01:15:35 <mniip> if that makes sense
01:17:59 <ClaudiusMaximus> mniip: kind error at Categeory (f c) ?? (not tried to compile it, and i'n n00b at kinds)
01:18:31 <mniip> uh yeah you're right
01:18:54 <mniip> well imagine data Wrap f c a b = Wrap (f (c a b))
01:19:07 <mniip> newtype, even
01:22:12 <TommyC> Hello. I'm getting some odd results trying to build ghc for Fedora and Gentoo (manually, from source). On both systems I passed the same configure flags and such but they're churning out different results (one errors out, something about hscolour and ghc-cabal). The other builds fine.
01:24:54 <TommyC> I was wondering if anyone's run into something similar and a possible solution.
01:36:38 <diggle> Hi. Is it possible to do games in haskell?
01:37:07 <Adeon> technically yes
01:37:39 <Adeon> but the question of if it's practical depends on how ambitious your game idea is technologically
01:37:55 <mniip> diggle, might wanna look at #haskell-game
01:39:07 <EvanR> i found out the other day that you can write this type
01:39:16 <EvanR> foo :: Ord a => Enum a -> a -> a
01:39:18 <EvanR> er
01:39:21 <EvanR> foo :: Ord a => Enum a => a -> a
01:39:25 <EvanR> two =>
01:39:41 <EvanR> but also, i just figured out you can write this one
01:39:51 <EvanR> foo :: Ord a => Enum a => a -> Integral a => a
01:40:05 <mniip> that's more interesting
01:40:22 <mniip> all without the kitchen sink?
01:40:30 <EvanR> this => notation makes way more sense now, in that whatever comes before a => is an argument that you dont pass in, but the system figures out for you
01:40:53 <EvanR> in this case... a Constraint
01:41:57 <mniip> I want to say "well duh" but I've never realized it's /this/ consistent before
01:44:36 <EvanR> if it were explicit, you would have to produce these constraint values yourself, the primitives are the bare instances, and you can derive other constraints from primitives using instances of the form Functor a => Monad a
01:44:42 <EvanR> brilliant
01:45:54 <EvanR> for any Functor (for a) you can produce a Monad (for a)
01:46:04 <EvanR> hmm, tha doesnt sounds right
01:46:30 <srhb> What? Isn't that the Free promise?
01:47:09 <mniip> hmm, does the 'data Data s a = Foo a | Bar (s -> Data s a)' have a name?
01:47:19 <EvanR> it seems more like for any Monad a you can construct a Functor... but i guess only with a funcional dependency?
01:47:55 <EvanR> for uniqueness
01:48:08 <phadej> mniip: looks like FreeT Reader a
01:48:14 <phadej> (Reader s)
01:48:14 <mniip> EvanR, no, we're constructing a Monad instance using implicit Functor
01:49:15 <mniip> hmm
01:49:52 <EvanR> back to the drawing board, to understand what Functor a => Monad a would be saying, and how its used
01:51:08 <mniip> phadej, hmm, now how do I fit a kleisli-but-not-quite into this...
01:52:20 <phadej> mniip: I don't understand? you want make Data a 'Category' ?
01:52:31 <mniip> @unmtl FreeT (ReaderT Maybe s) a
01:52:31 <lambdabot> FreeT (ReaderT Maybe s) a
01:52:32 <phadej> i.e. chain Data a b with Data b c ?
01:53:27 <mniip> phadej, no, I started with data Data m s a = Data (m (Either a (s -> Data m s a)))
01:54:04 <mniip> now if the first thing simplifies to FreeT then this one must be something too?
01:56:39 <mniip> duh
01:56:52 <mniip> FreeT m ((->) s)
01:58:25 <mniip> no wait the other way around
01:58:40 <mniip> FreeT ((->) s) m
02:01:46 <dramforever> Looks like a consumer
02:02:04 <mniip> now the trick question
02:02:31 <mniip> data Thing m s a = Thing (FreeT ((->) s) m a)
02:02:42 <mniip> does Thing m make a Category, or even better, an Arrow?
02:05:50 <dramforever> Category, perhaps, id = take one value, return that, f . g = take values and feed to g, take values from g and feed to f
02:06:06 <mniip> an even better question is
02:06:13 <mniip> does an edwardk package that does this exist?
02:06:53 <Lokathor> so
02:07:13 <Lokathor> would Functional Reactive Programming be one way that you could build a clicker game / idle game in haskell?
02:07:28 <Lokathor> you know, if a person wanted to actually build an idle game
02:17:47 <mniip> instance (Functor f, Monad m) => Functor (FreeT f m)
02:17:53 <mniip> but why, we only need Functor m
02:18:05 <Myrl-saki> Hi guys.
02:18:14 <Myrl-saki> mniip: HA I HAAAAAII
02:18:35 <mniip> pls
02:19:26 <Myrl-saki> mniip: pls halp.
02:19:31 <Myrl-saki> mniip: For project management
02:19:34 <Myrl-saki> stack or cabal?
02:19:49 <Myrl-saki> not package
02:19:51 <mniip> I have no idea
02:20:12 <Myrl-saki> Hmmmm
02:20:20 <Myrl-saki> Cabal and sandboxing is a pain to set up, IIRC
02:20:29 <Myrl-saki> I always messed it up when I tried.
02:22:10 <ches> Myrl-saki: Recently finding when introducing new people to Haskell (I'm not that experienced myself), stack is much smoother for them
02:22:22 <ches> cabal hell is not a nice early impression
02:22:27 <Myrl-saki> ches: Right.
02:22:41 <Myrl-saki> ches: Also, should I even use stack along with NixOS?
02:22:50 <Myrl-saki> Hmmm
02:23:00 <Myrl-saki> I guess that's a clear yes.
02:23:13 <ches> Well it does support the nix integration, I haven't tried yet
02:23:21 <Myrl-saki> Wait, it does?
02:23:29 <Myrl-saki> Interesting.
02:23:31 <Lokathor> Myrl-saki, stack >>>>>>>>> cabal
02:23:38 <Myrl-saki> Lokathor: lol
02:23:49 <Myrl-saki> I've had my share of problems with stack though. :)
02:23:54 <ches> Yup, http://docs.haskellstack.org/en/stable/nix_integration.html
02:24:10 <Myrl-saki> ches: So interested! Thanks!
02:26:49 <Myrl-saki> "By default, stack will run the build in a pure Nix build environment (or shell), which means the build should fail if you haven‚Äôt specified all the dependencies "... This sounds good.
02:27:17 <Rizy> it does, but take a look on this
02:27:18 <Rizy> https://github.com/NixOS/nixpkgs/issues/12564#issuecomment-174297130
02:27:42 <Rizy> i think we have to use nix-shell, cmiiw but yeah i am still learning also
02:28:12 <Myrl-saki> Rizy: Nice! A fellow NixOS user. :)
02:29:41 <Myrl-saki> http://blog.felipe.lessa.nom.br/?p=146
02:30:01 <Myrl-saki> Mmm
02:33:32 <Myrl-saki> Rizy: Hey.
02:33:57 <mniip> phadej, dramforever, I like how with FreeT I can basically throw out all the code I wrote because everything happens automagically, but
02:34:02 <mniip> item = Parser $ FreeT $ pure $ Free $ \t -> FreeT $ pure $ Pure t
02:35:48 <phadej> mniip: create some smart constructors?
02:37:19 <mniip> oooh
02:37:20 <mniip> damn
02:37:26 <mniip> there is quite literally no code to write
02:37:40 * hackagebot scalpel 0.3.0 - A high level web scraping library for Haskell.  https://hackage.haskell.org/package/scalpel-0.3.0 (fimad)
02:37:50 <mniip> man, this is amazing
02:39:07 <dramforever> mniip: yeah indeed (replying to the FreeT thing)
02:39:34 <dramforever> bet a cent free is by ekmett
02:40:01 <ocharles_> I'm blanking, but is there a solution to  foo :: Monad m => (a -> m b) -> m (a -> b)  ?
02:40:12 <lpaste> mniip pasted ‚Äúmonadic parser‚Äù at http://lpaste.net/151296
02:40:18 <ocharles_> It's almost like the opposite of distribute, which would be sequence - but sequence doesn't fit here
02:40:48 <dramforever> ocharles_: sounds impossible, what do you expect it to do?
02:41:24 <phadej> ocharles_: the other direction is possible, so I'd guess: no
02:41:34 <dramforever> mniip: :) I literally yelled out (quietly so that no one else hears), "Parser??!"
02:42:26 <ocharles_> hmm yes, I can see that it doesn't really make sense
02:42:29 <mniip> you don't need a 'char' combinator because that's just
02:42:35 <mniip> \x -> mfilter (==x) item
02:43:33 <Myrl-saki> flip mfilter item . (==)
02:43:38 <Myrl-saki> Pointfre.
02:43:54 <ocharles_> :t mfilter
02:43:55 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
02:44:04 <ocharles_> I always forget this handy little combinator
02:44:37 <Myrl-saki>  Wait...
02:44:59 <Myrl-saki> Oh.
02:45:03 <Myrl-saki> It's MonadPlus.
02:48:04 <mniip> dammit
02:48:16 <mniip> I can't use the thing in lambdabot's letlpaste
02:48:42 <mniip> but anyway, using just the item combinator you can define stuff like
02:48:46 <Myrl-saki> how about begpaste?
02:48:47 <mniip> (fmap (foldl ((+) . (* 10)) 0) $ some $ fmap (subtract 48 . fromEnum) $ mfilter isDigit item) 
02:49:05 <Myrl-saki> GET IT? LETL? BEG?
02:49:09 <mniip> :: MonadPlus b => Parser b Char Int
02:49:15 <mauke> digitToInt
02:49:22 <Myrl-saki> mauke: LOL
02:49:23 <mniip> oh damn
02:49:42 <mniip> I'll see myself in the corner of shame
02:52:07 <mniip> dramforever, isn't this the greatest thing ever
02:52:15 <Myrl-saki> mniip: Oh my God.
02:52:47 <Myrl-saki> mniip: That fmap foldl too.... why would you do that?
02:52:51 <Myrl-saki> :t some
02:52:53 <lambdabot> Alternative f => f a -> f [a]
02:53:02 <mniip> what's wrong with fmap foldl?
02:53:12 <guest12345> hello
02:53:15 <mniip> fmap just operates on the parsed value
02:53:26 <mniip> *lets us operate
02:53:26 <Myrl-saki> Hmmm... the fmap foldl is not that bad, I guess.
02:53:36 <guest12345> I get xmonad-arm-linux: schedule: re-entered unsafely.    Perhaps a 'foreign import unsafe' should be 'safe'?
02:53:55 <guest12345> with ghc 7.10.3
02:53:57 <Myrl-saki> mniip: Wait for a while.
02:54:04 <mniip> mauke, I've written too much perl recently I guess :(
02:54:22 <guest12345> 7.6.3 worked
02:54:58 <Myrl-saki> Also, I'm quite curious as to how `some` works.
02:56:42 <Myrl-saki> Oh okay.
03:11:41 <dramforever> mniip: indeed :) (Sorry for being mostly AFK)
03:54:25 <Rizy> Myrl-saki: yeah i've read that too.. but i think the nix-integration seems more compelling. Have you tried the zlib stuff?
04:05:00 <darthdeus_> Selling bulk regs, 10k each for 250k (2.5/4.5)
04:08:25 <EvanR> ill take six
04:09:52 <darthdeus> six 10k each?
04:10:13 <EvanR> doge right
04:10:17 <darthdeus> oh sorry, wrong chat room
04:10:18 <darthdeus> lol
04:10:19 <darthdeus> :D
04:10:28 <Myrl-saki> Rizy: Nope.
04:10:44 <Myrl-saki> EvanR: Lol.
04:11:36 <Myrl-saki> Now I'm quite curious what darthdeus is selling.
04:17:29 <mauke> regexes
04:17:57 <darthdeus> it's an ultima online thing, hehe
04:29:25 * hackagebot phoityne 0.0.3.0 - ghci debug viewer with simple editor.  https://hackage.haskell.org/package/phoityne-0.0.3.0 (phoityne_hs)
04:29:25 * hackagebot scalpel 0.3.0 - A high level web scraping library for Haskell.  https://hackage.haskell.org/package/scalpel-0.3.0 (fimad)
04:50:47 <Joost123> Can someone help with an exercise from the monad challenges (http://mightybyte.github.io/monad-challenges/pages/ex2-5.html). My implementation of the yLink involves pattern matches, but the implementation should use link. But I can't figure out how?
04:51:56 <mauke> what's link?
04:52:22 <Joost123> chain :: (a -> Maybe b) -> Maybe a -> Maybe b
04:52:22 <Joost123> chain _ Nothing = Nothing
04:52:22 <Joost123> chain f (Just a) = f a
04:52:22 <Joost123> link :: Maybe a -> (a -> Maybe b) -> Maybe b
04:52:22 <Joost123> link = flip chain
04:53:53 <mauke> ok, and what does your yLink look like?
04:54:01 <Ainieco> i'm trying to download a web page with https://hackage.haskell.org/package/download-curl and B.putStrLn into terminal but encoding is broken, what to do?
04:54:16 <mauke> define "encoding is broken"
04:54:28 <Joost123> Well, the one that works uses pattern matches: yLink' :: (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c
04:54:28 <Joost123> yLink' f Nothing _ = Nothing
04:54:28 <Joost123> yLink' f _ Nothing = Nothing
04:54:28 <Joost123> yLink' f (Just a) (Just b) = Just (f a b)
04:54:45 <Joost123> And what i tried : yLink f  b  =  link (link b (\x -> Just (\y -> (f x y))))
04:54:50 <Joost123> But that doesn't work
04:55:10 <mauke> that outer link makes no sense. link takes two args, not one
04:55:29 <mauke> also, yLink takes three args, not two
04:55:57 <Joost123> o, oops, there should be an a like: yLink f a b  =  link a (link b (\x -> Just (\y -> (f x y))))
04:56:22 <mauke> link _ (link _ _) is a type error
04:56:34 <mauke> link's second argument must be a function. (link _ _) is not a function
04:56:35 <Ainieco> mauke: ASCII symbols looks fine but others are broken
04:57:10 <mauke> so I'd start with link a (\x -> ...
04:58:50 <Joost123> Ok, I will try that.
05:12:05 <Joost123> Thanks! I got it to work :)
05:13:44 <Arguggi> Ainieco, is LANG set to something like en_US.UTF-8? 
05:14:44 <Nadri> @pl \f g x y -> f (g x) (g y)
05:14:44 <lambdabot> join . ((flip . ((.) .)) .) . (.)
05:15:02 <Nadri> :3
05:17:00 <Arguggi> Ainieco, btw Data.ByteString.putStrLn seems to be deprecated: https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html#v:putStrLn
05:19:04 <dramforever> Nadri: check out Data.Function.on
05:19:28 <dramforever> > ((==) `on` abs) (-1) 1
05:19:30 <lambdabot>  True
05:19:55 <Nadri> ooh thanks :D
05:25:23 <Ainieco> Arguggi: thanks, solved this with "encoding" package
05:26:30 <Ainieco> how do you deal with libraries where author seriously mess up types?
05:26:44 <EvanR> dont use the library
05:26:57 <maerwald> those will be a lot
05:27:03 <maerwald> fix it instead
05:27:06 <Ainieco> e.g https://hackage.haskell.org/package/encoding-0.8/docs/Data-Encoding.html i'd like to have list of encodings, but author made each encoding a separate type + useless typeclass Encoding, what to do?
05:27:32 <Ainieco> iirc i can do Encoding enc => [enc]
05:28:18 <EvanR> you will need another type to act like your list of selectors, and write a translation
05:28:25 <Ainieco> mauke: i have a life
05:29:03 <EvanR> another way to deal with this is to create a list of [(String, <function type to do the encoding>)] and close over the various types in the function
05:29:19 <EvanR> now you can show a list and use the choice
05:29:38 <maerwald> the library maintainer probably has a life too
05:29:55 <Ainieco> EvanR: thanks!
05:31:06 <mauke> Ainieco: huh?
05:31:19 <maerwald> he meant me probably
05:32:12 <Ainieco> yeah
05:32:28 <mauke> Ainieco: DynEncoding
05:33:01 <Ainieco> mauke: god bless you
05:33:45 <deepfire> nkaretnikov: any questions on ruin?
05:34:07 <nkaretnikov> deepfire: nah, haven't got time to look into it
05:34:15 <deepfire> : -)
05:34:21 * hackagebot rebase 0.2.1 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.2.1 (NikitaVolkov)
05:34:44 * deepfire fights against language-c-quote not allowing emission of macro calls..
05:35:42 <Ainieco> mauke: hm, how can i use it? There is no DynEncoding constructor to wrap arbitrary encoding
05:35:53 <mauke> encodingFromString
05:36:29 <deepfire> nkaretnikov: do you know when the next Moscow haskell meetup is scheduled?
05:36:32 <Ainieco> mauke: oh, okay, thanks
05:36:59 <Ainieco> mauke: just got confused by type definition "data DynEncoding = forall enc. (Encoding enc,Eq enc,Typeable enc,Show enc) => DynEncoding enc"
05:37:31 <Ainieco> they actually use DynEncoding constructor in show instance https://hackage.haskell.org/package/encoding-0.8/docs/src/Data-Encoding-Base.html#DynEncoding but i don't understand why it's not available to me
05:37:34 <nkaretnikov> deepfire: nope
05:37:43 <mauke> because it's not exported
05:38:29 <Ainieco> mauke: got it, thanks for explanation
05:39:01 <Ainieco> weird, why didn't they export it tho
05:39:33 <EvanR> to stop you from using it ;)
05:42:40 * mniip wonders where edwardk is
05:44:22 * hackagebot profiteur 0.3.0.1 - Treemap visualiser for GHC prof files  https://hackage.haskell.org/package/profiteur-0.3.0.1 (JasperVanDerJeugt)
06:00:16 <Ainieco> i'm using https://github.com/chrisdone/ghci-ng but it looks like "GHCi, version 7.10.3" doesn't support ":set +c", did they rename it somehow?
06:06:44 <deepfire> Ainieco: hmm, IIRC someone (hvr?) was porting the ghci-ng coolness into GHC 8
06:06:45 <dasboot> does haskell support database inquiries?
06:06:51 <dasboot> or querries
06:07:04 <deepfire> dasboot: quite, there's a number of database interface libraries
06:07:29 <dasboot> cool!
06:07:41 <deepfire> dasboot: https://hackage.haskell.org/packages/#cat:Database
06:08:56 <Ainieco> deepfire: but what about ghc 7.10 ? did the replace :set +c with something?
06:09:26 <dasboot> so hsql would be my way into querring a db, looks like the standard one.
06:10:12 <deepfire> Ainieco: it's not unlikely that :set +c is a ghci-ng extension, too
06:10:40 <deepfire> actually, the darkest pits of my memories suggest something to this end..
06:10:50 <dasboot> is it easy to download and install a package? like R?
06:11:10 <deepfire> dasboot, people use "stack" for it, nowadays
06:11:18 <gameer> Hey guys. I want to learn the Functor Typeclass. I read the chapter at learnyouahaskell. Is the only thing about it, that it maps about s.th.? 
06:11:36 <mauke> yes
06:11:52 <gameer> sehr gut
06:11:54 <gameer> well
06:12:04 <gameer> Then I can go on with monads now
06:12:08 <Ainieco> deepfire: ahh, indeed, works now
06:19:59 * hackagebot fltkhs-demos 0.0.0.3 - FLTKHS demos. Please scroll to the bottom for more information.  https://hackage.haskell.org/package/fltkhs-demos-0.0.0.3 (deech)
06:20:01 * hackagebot fltkhs 0.4.0.1 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.4.0.1 (deech)
06:22:04 <gameer> in learnyouahaskell they use "do" but did not explained it yet
06:22:17 <gameer> Is it just to applay a few lines?
06:22:21 <gameer> apply
06:23:57 <EvanR> no its called "do notation" (for your future googling reference)
06:24:11 <EvanR> its syntactic sugar for the operations 
06:24:15 <EvanR> :t return
06:24:16 <lambdabot> Monad m => a -> m a
06:24:23 <EvanR> :t (>>=)
06:24:25 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:24:34 <gameer> Okay, I am not at the monad chapter yet
06:24:48 <gameer> ThI think I just have to read further until it will be explained?
06:24:49 <EvanR> right
06:24:57 <gameer> I*
06:25:05 <EvanR> you can instead think of it like this
06:25:16 <EvanR> return :: a -> IO a
06:25:27 <EvanR> (>>=) :: IO a -> (a -> IO b) -> IO b
06:25:43 <EvanR> other m's can work, but I'm guessing LYAH is using IO
06:26:01 <gameer> Yeah I am at the IO Chapter :D
06:26:03 <EvanR> this is how you string together IO actions
06:26:21 <gameer> okay, thanks :)
06:27:30 <EvanR> if you write do
06:27:37 <EvanR>   x <- myAction
06:27:41 <EvanR>   ... x ...
06:27:45 <EvanR> its the same as writing
06:27:56 <EvanR> myAction >>= (\x -> ... x ...)
06:28:19 <Stratege> gameer you can skip to the monad chapter to read about how it works, if you want and then skip back to IO. That's what I did when I read it, because I got rather annoyed at there suddenly being "magic" ^^
06:28:36 <gameer> Okay^^
06:28:40 <EvanR> a lot of people complain about LYAH
06:29:20 <notabigthreat> ... because a lot of people learn from this source
06:29:26 <gameer> I started with the monad chapter and they mentioned applicative functors. So I thought I should read that first..
06:29:27 <Stratege> mhm, I like the book but I'd also recommend leaving the IO chapter for later unless someone really wants to do IO first for some reason (like printing "Hello World" ^^)
06:29:29 <srhb> Mostly experienced Haskellers, I think.
06:30:17 <srhb> Beginners tend to like it a lot.
06:32:09 <gameer> It is explained in a good way i think
06:34:30 <gameer> But now I skipped the chapter and this looks crazy: (*) <$> Just 2 <*> Just 8    :D
06:34:50 <Stratege> ^^
06:34:59 <EvanR> well skipping chapters, i would be surprised if things worked out ;)
06:35:01 <Stratege> okay maybe my recommendation wasn't the best ^^
06:35:19 <EvanR> whether its written well or not
06:35:48 <gameer> Okay, I jump back a chapter :D
06:36:28 <EvanR> and what you wrote is the same as liftA2 (*) (Just 2) (Just 8)
06:37:39 <EvanR> > (*) <$> Just 2 <*> Just 8
06:37:41 <lambdabot>  Just 16
06:37:46 <EvanR> > liftA2 (*) (Just 2) (Just 8)
06:37:48 <lambdabot>  Just 16
06:37:50 <gameer_> My connection was away :d
06:37:58 <EvanR> -_
06:38:30 <gameer_> dont make me crazy
06:38:37 <gameer_> liftA2 is a monad i think
06:38:53 <mauke> liftA2 is a function, not a type
06:38:53 <EvanR> 18:36 < EvanR> and what you wrote is the same as liftA2 (*) (Just 2) (Just 8)
06:38:55 <mauke> it can't be a monad
06:39:02 <EvanR> :t liftA2
06:39:04 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
06:42:18 <Stratege> gameer maybe my recommendation to skip wasn't necessarily the best, sorry ^^
06:42:29 <gameer> no problem
06:42:37 <gameer> I am reading both now :)
06:42:47 <EvanR> one eye on each chapter
06:42:55 <notabigthreat> :type <*>
06:42:57 <Stratege> parallelism!
06:43:03 <notabigthreat> :t <*>
06:43:03 <EvanR> :t (<*>)
06:43:04 <lambdabot> parse error on input ‚Äò<*>‚Äô
06:43:04 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:43:11 <notabigthreat> :t (<*>)
06:43:12 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:43:35 <gameer> I mean I read at first one chapter and after that the second
07:10:01 * hackagebot tttool 1.6 - Working with files for the TiptoiÆ pen  https://hackage.haskell.org/package/tttool-1.6 (JoachimBreitner)
07:30:02 * hackagebot textual 0.2.0.0 - Textual type class for data that represent text  https://hackage.haskell.org/package/textual-0.2.0.0 (marcosdumay)
07:35:02 * hackagebot direct-sqlite 2.3.17 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  https://hackage.haskell.org/package/direct-sqlite-2.3.17 (JanneHellsten)
07:45:02 * hackagebot octane 0.2.0 - A Rocket League replay parser.  https://hackage.haskell.org/package/octane-0.2.0 (fozworth)
07:50:02 * hackagebot convert 1.0.1 - Safe and unsafe data conversion utilities with strong type-level operation. checking.  https://hackage.haskell.org/package/convert-1.0.1 (danilo2)
08:15:06 * hackagebot haskell-gi-base 0.12 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.12 (inaki)
08:17:38 <jamesfordummies> if I have 1 thread at `atomically $ readTChan`, blocking because because it‚Äôs empty, does this mean that another thread can‚Äôt write to the chan? or does readTChan lock, attempt a read, unlock then retry?
08:19:07 <EvanR> theres no lock
08:20:07 <geekosaur> it does a retry when the TChan has contents, as I understand it?
08:20:09 <EvanR> it will retry if there is nothing to read
08:20:16 <EvanR> thereby blocking
08:20:29 <geekosaur> well, that. (not sure if it's optimized or if it's in a retry spin)
08:20:33 <jamesfordummies> so the other thread will never be able to write?
08:20:41 <EvanR> its not spinning, its using STM rery
08:20:43 <mauke> ENONSEQ
08:21:05 <EvanR> jamesfordummies: yes, it will wake up to retry as soon as something writes to the shan
08:21:07 <geekosaur> no, STM is lock-free. when the other thread does its write, anything dependent on that TChan does a retry
08:21:17 <mauke> EvanR: how is that a "yes"?
08:21:35 <jamesfordummies> EvanR: you mean ‚Äúno"?
08:21:37 <geekosaur> sigh, what I get for thinking of it in terms of db transactions >.>
08:21:44 <EvanR> i meant no, i think i was trying to respond to two people at once
08:21:58 <jamesfordummies> hm ok
08:22:01 <jamesfordummies> well thanks!
08:22:04 <jamesfordummies> everyone :)
08:22:05 <EvanR> geekosaur: bad terminology, its not doing a retry after it wakes up, the retry auses it to go to sleep
08:22:42 <geekosaur> yeh, I realized that from your response (ence my commentabout thinking of it in terms of db transactions, which don't block)
08:22:59 <EvanR> its like postgres db transactions
08:23:06 <jmcarthur> what's this about db transactions not blocking?
08:23:08 <EvanR> innodb is locked to all hell
08:23:43 <EvanR> yeah certain things block (or timeout, like innodb)
08:23:46 <geekosaur> well, they block waiting on locks, but theres no locks here. the transaction *itself* does not block on retry
08:24:20 <jmcarthur> I suspect there is some subtle variation of "block" you are talking about here that I/we don't understand.
08:25:16 <jmcarthur> I would consider "blocking" to mean that the current thread is not able to make forward progress until another thread does something.
08:25:17 <EvanR> in mysql, your statements might block (on the console at least) if there is some transaction in progress
08:25:48 <EvanR> later it ight continue, or crash
08:26:20 <jmcarthur> s/forward progress/any progress/
08:30:06 * hackagebot path-io 0.3.1 - Interface to directory package for users of path  https://hackage.haskell.org/package/path-io-0.3.1 (mrkkrp)
08:35:06 * hackagebot gi-atk 0.2.16.12 - Atk bindings  https://hackage.haskell.org/package/gi-atk-0.2.16.12 (inaki)
08:35:08 * hackagebot gi-cairo 0.1.14.12 - cairo bindings  https://hackage.haskell.org/package/gi-cairo-0.1.14.12 (inaki)
08:35:10 * hackagebot gi-gdk 0.3.16.12 - Gdk bindings  https://hackage.haskell.org/package/gi-gdk-0.3.16.12 (inaki)
08:35:12 * hackagebot gi-gdkpixbuf 0.2.31.12 - GdkPixbuf bindings  https://hackage.haskell.org/package/gi-gdkpixbuf-0.2.31.12 (inaki)
08:35:14 * hackagebot gi-gio 0.2.44.12 - Gio bindings  https://hackage.haskell.org/package/gi-gio-0.2.44.12 (inaki)
08:35:32 <the_2nd> Can I define an empty class, without a function definition?
08:35:39 <KaneTW> yes
08:35:41 <geekosaur> class Foo where
08:35:55 <the_2nd> like class (Eq, Ord a) => EqOrd a
08:36:00 <geekosaur> it's even a useful thing to do occasionally
08:36:12 <geekosaur> that one seems kinda pointless though
08:36:16 <the_2nd> sure
08:36:30 <geekosaur> you need the "where". the following block can be empty
08:36:31 <jmcarthur> I think that would be better expressing using ConstraintKinds
08:36:41 <jmcarthur> type EqOrd a = (Eq a, Ord a)
08:36:50 <the_2nd> class (Clickable, Dynamic, Renderable) => GameEngine a
08:36:51 <KaneTW> i'm thinking of using a empty typeclass with an associated type instead of type families so i can ensure every instance of the type family fulfills some conditions
08:36:53 <jmcarthur> *expressed
08:37:04 <KaneTW> but the syntax is kinda ugly
08:37:38 <the_2nd> I just want to define a combination of several classes I gonna use often
08:37:57 <KaneTW> class (bunch of constraints) => PacketC (d :: PacketDirection) (s :: ConnectionState) (t :: PacketType) where type PacketArgs d s t :: *
08:37:58 <jmcarthur> type GameEngine a = (Clickable a, Dynamic a, Renderable a)
08:38:08 <geekosaur> the_2nd, ConstraintKinds does that
08:38:22 <geekosaur> cleaner than empty classes
08:38:30 <KaneTW> right now i have this: https://github.com/KaneTW/knxd-native-client/blob/master/src/KNXd/Client/Internal/PacketArgs.hs
08:38:36 <the_2nd> I like jmcarthur s solution
08:39:00 <the_2nd> or will this be a tuple? not what I want
08:39:04 <jmcarthur> the_2nd: My solution uses ConstraintKinds, which is what geekosaur and I have both been saying.
08:39:10 <geekosaur> tuples are fine
08:39:20 <jmcarthur> the_2nd: It's not a tuple. It's a constraint.
08:39:24 <KaneTW> but then i have to write explicit proofs (or, rather, use some TH to generate them) a lot and it's annoying
08:39:26 <geekosaur> ever notice multiple constraints are (Foo a, Bar a) => ...?
08:39:32 <geekosaur> think ofit as a type level tuple
08:39:52 <geekosaur> or don't worry about it since this is what ConstraintKinds is for and it does what you'd expect
08:40:20 <jmcarthur> Constraints can be implicitly reordered and converted between curried and uncurried form, which is why the tuple syntax just doesn't matter.
08:41:08 <geekosaur> alos, whoever it was who was confused by Foo a => Bar a => ... working the other day, *this* is why
08:45:25 * hackagebot gi-girepository 0.1.44.12 - GIRepository bindings  https://hackage.haskell.org/package/gi-girepository-0.1.44.12 (inaki)
08:45:27 * hackagebot gi-glib 0.2.44.12 - GLib bindings  https://hackage.haskell.org/package/gi-glib-0.2.44.12 (inaki)
08:45:29 * hackagebot gi-gobject 0.2.44.12 - GObject bindings  https://hackage.haskell.org/package/gi-gobject-0.2.44.12 (inaki)
08:45:31 * hackagebot gi-gtk 0.3.16.12 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-0.3.16.12 (inaki)
08:47:21 <Joost123> I have another (two) question about the monad challenges ( http://mightybyte.github.io/monad-challenges/pages/ex4-4.html )
08:48:12 <Joost123> 1. What should i do with lists, because now I have instance Monad [] where
08:48:12 <Joost123>     bind [] _ = []
08:48:12 <Joost123>     bind (x:xs) f = f x
08:48:12 <Joost123>     
08:48:12 <Joost123>     return a = [a]
08:48:20 <Joost123> which seems wrong
08:49:42 <mauke> that doesn't seem to follow the laws
08:49:50 <Joost123> and my other question: how should I define a newtype (in this case Gen, which had the type :  Gen a = Seed -> (a, Seed)). Now I have newtype Gen a = Gen {gen :: Seed -> (a, Seed)}
08:50:08 <Joost123> Ehm, there weren't any laws discussed (yet)
08:50:32 * hackagebot gi-javascriptcore 0.2.4.12 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-0.2.4.12 (inaki)
08:50:34 * hackagebot gi-javascriptcore 0.2.8.12 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-0.2.8.12 (inaki)
08:50:36 * hackagebot gi-notify 0.2.31.12 - Notify bindings  https://hackage.haskell.org/package/gi-notify-0.2.31.12 (inaki)
08:52:42 <Joost123> Skip the question about the newtype btw, it is on the page
08:52:58 <mauke> ok, here's one: 'bind x return' should be equal to x
08:53:46 <mauke> your Maybe instance probably already obeys this rule
08:55:32 * hackagebot gi-pango 0.1.36.12 - Pango bindings  https://hackage.haskell.org/package/gi-pango-0.1.36.12 (inaki)
08:55:34 * hackagebot gi-poppler 0.0.30.12 - Poppler bindings  https://hackage.haskell.org/package/gi-poppler-0.0.30.12 (inaki)
08:55:36 * hackagebot gi-soup 0.2.50.12 - Soup bindings  https://hackage.haskell.org/package/gi-soup-0.2.50.12 (inaki)
08:56:36 <Joost123> I think it should be this?  bind (x:xs) f = (f x) ++ bind xs f
08:57:29 <mauke> that looks ok
09:00:13 <codedmart> What is the best way to go from Aeson Value -> HashMap. I want to go from something like {"a": 1, "b": 2} -> [{"field": "a", "value": 1}, {"field": "b", "value": 2}]
09:00:32 * hackagebot gi-vte 0.0.40.12 - Vte bindings  https://hackage.haskell.org/package/gi-vte-0.0.40.12 (inaki)
09:00:34 * hackagebot gi-webkit 0.2.4.12 - WebKit bindings  https://hackage.haskell.org/package/gi-webkit-0.2.4.12 (inaki)
09:00:36 * hackagebot gi-webkit2 0.2.8.12 - WebKit2 bindings  https://hackage.haskell.org/package/gi-webkit2-0.2.8.12 (inaki)
09:00:39 * hackagebot gi-webkit2webextension 0.2.8.12 - WebKit2WebExtension bindings  https://hackage.haskell.org/package/gi-webkit2webextension-0.2.8.12 (inaki)
09:07:52 <KaneTW> hm
09:12:40 <seishun> I'm reading learnyouahaskell and this paragraph doesn't seem right to me: "One big difference is that right folds work on infinite lists, whereas left ones don't! To put it plainly, if you take an infinite list at some point and you fold it up from the right, you'll eventually reach the beginning of the list. However, if you take an infinite list at a point and you try to fold it up from the left, you'll never reach an end! "
09:13:06 <seishun> if you pass an infinite list to a right fold, it would start from "some point", it would start from the end, which doesn't exist
09:13:23 <KaneTW> @src foldr
09:13:23 <lambdabot> foldr f z []     = z
09:13:23 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:13:27 <KaneTW> @src foldl
09:13:28 <lambdabot> foldl f z []     = z
09:13:28 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:13:35 <seishun> *it wouldn't start at "some point"
09:13:42 * geekosaur knows what that paragraph is reaching for... but yes, it's kinda missing it
09:14:19 <KaneTW> before foldl can reduce to a value, it needs to tail-recurse over every element until it reaches the end
09:14:42 <geekosaur> it always starts from the outside ("left") and works inward. foldl always has to go all the way in before it can produce results. foldr can produce results lazily from the start, if the thing you're folding can produce anything before evaluating the rest of the list
09:15:04 <geekosaur> s/thing/function/
09:15:30 <KaneTW> @let data Nat = Z | S Nat deriving Show
09:15:32 <lambdabot>  Defined.
09:15:37 <KaneTW> > foldr S Z [1..]
09:15:38 <lambdabot>      Couldn't match type ‚ÄòNat‚Äô with ‚ÄòNat -> Nat‚Äô
09:15:38 <lambdabot>      Expected type: Nat -> Nat -> Nat
09:15:38 <lambdabot>        Actual type: Nat -> Nat
09:15:50 <KaneTW> well not quite
09:16:31 <Gurkenglas> What should I call "Alternative f => (a -> Bool) -> f a -> f a", instead of guard?
09:17:04 <KaneTW> @let plus Z n = n; plus (S n) m = S (plus n m)
09:17:05 <lambdabot>  Defined.
09:17:08 <KaneTW> > foldr plus Z [1..]
09:17:10 <lambdabot>      No instance for (Enum Nat)
09:17:10 <lambdabot>        arising from the arithmetic sequence ‚Äò1 .. ‚Äô
09:17:10 <lambdabot>      In the third argument of ‚Äòfoldr‚Äô, namely ‚Äò[1 .. ]‚Äô
09:17:13 <geekosaur> guardA, and hope they generalize guard in a later ghc?
09:17:13 <KaneTW> huh
09:17:15 <KaneTW> oh
09:17:30 <geekosaur> Num ftl...
09:17:52 <monochrom> Gurkenglas: how is it implemented?
09:18:25 <KaneTW> > foldr (const S) Z [1..]
09:18:27 <lambdabot>  S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S...
09:18:44 <KaneTW> > foldl (flip $ const S) Z [1..]
09:18:49 <lambdabot>  mueval-core: Time limit exceeded
09:18:49 <lambdabot>  mueval: ExitFailure 1
09:19:07 <KaneTW> this took longer than i wanted, stupid Num
09:19:25 <Gurkenglas> :t mfilter -- Oh right, thanks, mfilter it is then.
09:19:28 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
09:20:03 <monochrom> that's MonadPlus, not Alternative
09:20:29 <Gurkenglas> Yes, because you're correct that Alternative isn't enough
09:24:57 <KaneTW> i'm designing a client API and i'm wondering whether i should just use something like conduit from the start  (that'd simplify things a lot) or try to write independent of stream choice
09:25:39 * hackagebot hsdev 0.1.5.5 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.5.5 (AlexandrRuchkin)
09:25:41 * hackagebot xml-conduit 1.3.3.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  https://hackage.haskell.org/package/xml-conduit-1.3.3.1 (MichaelSnoyman)
09:31:03 * hackagebot haskell-gi 0.12 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.12 (inaki)
09:31:58 <KaneTW> seems like a fair amount of packages depend on conduit directly
09:31:58 <OpenSSLHatesMe> Hello?
09:32:01 <KaneTW> so i'll just do that
09:33:41 <OpenSSLHatesMe> How does one get HsOpenSSL to work on windows?
09:34:19 <OpenSSLHatesMe> I've tried installing openssl with libraries in the system directory, and its own \bin directory, and cabal never finds them
09:34:36 <OpenSSLHatesMe> Even when including with --extra
09:40:46 <OpenSSLHatesMe> Wow, someone's method on stackoverflow that wouldn't work for them, worked for me...
09:46:39 <ThatTreeOverTher> why is liftM
09:46:48 <ThatTreeOverTher> it looks like it makes code less readable
09:54:39 <ahihi> ThatTreeOverTher: mapping a function over a monadic action is a very common thing to do, so rather than writing `x <- act; return (f x)' over and over we extract the pattern into liftM
09:54:50 <ahihi> (or perhaps more commonly, fmap)
10:03:00 <quchen> ThatTreeOverTher: It's called "lift" because it takes a function on ordinary values, (a -> b), and gives you a function "lifted to monads", (m a -> m b). The concept of raising something to a higher context is quite common.
10:03:43 <quchen> ThatTreeOverTher: If you're already familiar with `fmap`, `liftM` does the same thing.
10:04:26 <ThatTreeOverTher> oh. okay, that kinda makes sense. thanks ahihi and quchen 
10:04:51 <geekosaur> (exactly the same thing, in fact. liftM "rederives" fmap via Monad, for historical reasons)
10:05:06 <quchen> For some value of "exactly".
10:06:24 <quchen> liftM may be less efficient than fmap, for example, because it's operationally different.
10:06:59 <ThatTreeOverTher> I assume it'd compile down to something similar, though..?
10:07:01 <quchen> Denotationally it should be identical to fmap, unless the Functor/Monad laws are broken by the instances, and the laws are recommendations.
10:07:19 <geekosaur> ThatTreeOverTher, not yet :/
10:07:23 <quchen> Very strong recommendations, but recommendations nonetheless.
10:07:39 <quchen> geekosaur: I don't think it's possible to achieve this.
10:08:12 <geekosaur> ghc 7.10 finally fixed the Functor-Applicative-Monad relationship; at least in theory that should make liftM unnecessary. in practice... operational behavior is annoying sometimes
10:08:26 <geekosaur> ("the difference between theory and practice...")
10:08:46 <quchen> liftM is still useful as a default definition of fmap, it won't become unnecessary because of the AMP.
10:09:06 <quchen> Similarly, ap will never be defined as (<*>).
10:09:47 <geekosaur> sigh, right, backward compat\
10:09:59 <quchen> No, not compat. It's a useful definition to have "fmap without using fmap".
10:10:00 <monochrom> the difference can be made arbitrarily small by choosing better theories
10:10:14 <codedmart> Sorry I went offline. How can I go from Aeson Value (Object) like this {"a": 1, "b": 2} to [{"field": "a", "value": 1}, {"field": "b", "value": 2}]
10:10:18 <geekosaur> or rather, allowing old pre-AMP stuff to become compatible with AMP while remaining compaitble iwth pre-AMP
10:10:29 <quchen> You can't write "instance Functor foo where fmap = liftM" if you have "liftM = fmap".
10:10:56 <quchen> All other uses of liftM are obsolete now, but in order to have a "fmapDefault" it'll remain in Control.Monad forever.
10:11:21 <ThatTreeOverTher> so should I be using fmap instead?
10:11:24 <quchen> Yes.
10:11:35 <geekosaur> fmap has been the recommendation for a long time, yes
10:11:44 <Clint> someone should yell at hlint
10:11:48 <ThatTreeOverTher> okay, so whenever Syntastic complains about not using liftM, see if I can use fmap instead
10:11:49 <ThatTreeOverTher> got it
10:12:21 <quchen> Clint: Well, HLint works for all common versions of GHC. Suggesting to replace liftM with fmap is wrong in code written for GHC 7.8.
10:13:02 <monochrom> in soviet russia, hlint yells at you
10:13:06 <Clint> quchen: it suggests to replace "blah >>= return . grah" with "liftM grah blah"
10:13:14 <quchen> Oh. Well that's correct.
10:14:23 <quchen> If you use `fmap` in GHC 7.8 here and have a Monad-without-Functor then you'll get an error if you write `fmap grah blah`.
10:16:15 * hackagebot gi-atk 0.2.18.12 - Atk bindings  https://hackage.haskell.org/package/gi-atk-0.2.18.12 (inaki)
10:16:17 * hackagebot gi-gdk 0.3.18.12 - Gdk bindings  https://hackage.haskell.org/package/gi-gdk-0.3.18.12 (inaki)
10:16:19 * hackagebot gi-gdkpixbuf 0.2.32.12 - GdkPixbuf bindings  https://hackage.haskell.org/package/gi-gdkpixbuf-0.2.32.12 (inaki)
10:16:21 * hackagebot gi-gio 0.2.46.12 - Gio bindings  https://hackage.haskell.org/package/gi-gio-0.2.46.12 (inaki)
10:16:23 * hackagebot gi-glib 0.2.46.12 - GLib bindings  https://hackage.haskell.org/package/gi-glib-0.2.46.12 (inaki)
10:17:20 <timthelion> So I have been writing in Python for a while now, and I finally came across a case where I said "gosh, this would be SOOO much easier in Haskell"... Writing a simple undo ring :P Man that's hard in an OOP language :D
10:18:24 <maerwald> timthelion: you'll experience the opposite too
10:19:00 <quchen> Interesting, I always thought ring buffers were more easily implemented in mutable languages.
10:19:34 <quchen> If that's what an "undo ring" comes down to.
10:19:36 <timthelion> quchen: yes, but since in haskell you have imutability, you don't have any problems with deepcopy failing...
10:20:27 <maerwald> you can have immutability in OOP too
10:20:28 <quchen> Oh, you were talking about how to undo things in general, not how to implement a ring structure. If so: yessss
10:20:37 <quchen> maerwald: But you can't rely on third party code having it
10:20:43 <maerwald> indeed
10:20:59 <timthelion> maerwald: yes, but if you are writing classic traditional OOP, then you won't...
10:21:15 * hackagebot gi-gobject 0.2.46.12 - GObject bindings  https://hackage.haskell.org/package/gi-gobject-0.2.46.12 (inaki)
10:21:16 <quchen> And we've all been at the "I'm going to write a pure wrapper around this"-and-failed stage ;-)
10:21:17 * hackagebot gi-gtk 0.3.18.12 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-0.3.18.12 (inaki)
10:21:19 * hackagebot gi-javascriptcore 0.2.10.12 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-0.2.10.12 (inaki)
10:21:29 <maerwald> good luck when you want to implement your first graph-like data structure or just a simple doubly linked list ;)
10:21:37 <maerwald> then you wish imperative languages back
10:22:11 <quchen> Nobody needs a doubly linked list. Body needs things where you can insert/delete/... easily.
10:22:13 <Clint> maerwald: what's wrong with fgl?
10:22:31 <maerwald> Clint: I say "when you want to implement"
10:22:33 <quchen> A doubly linked list is one way to solve this problem. There are many others.
10:23:07 <monochrom> I can see that I would want graphs in any language, immutable or mutable. I can't see that I would want mutable doubly linked list in an immutable language.
10:23:16 <timthelion> maerwald: I don't think that graphs are terribly hard in haskell, they just cannot be easilly implemented in a way that is intuitive to recursion. If you implement a graph as a list of nodes each recording its connections than it is no harder than with an imperitive language, but it is tempting to implement a graph as some kind of recursive lazy data structure and that is a non-starter.
10:23:43 <maerwald> quchen: a more concrecte example maybe http://www.flipcode.com/archives/The_Half-Edge_Data_Structure.shtml I implemented this in both C and haskell. It's like ~5min in C and a lot of research, thinking and indirection in haskell (if you do it yourself)
10:25:10 <quchen> maerwald: I agree that there are more solutions using mutability than are known using immutability/persistence and friends, yes.
10:25:38 <quchen> maerwald: If it takes you 5 minutes to come up with a solution in C you might as well spend the rest of the time implementing it via the FFI, or ST
10:25:56 <maerwald> FFI with structs is not fun, is it?
10:26:32 <quchen> It's been some time that I've done this. It wasn't terrible, but certainly not what I'd consider fun.
10:26:47 * hackagebot gi-pango 0.1.38.12 - Pango bindings  https://hackage.haskell.org/package/gi-pango-0.1.38.12 (inaki)
10:26:49 * hackagebot gi-poppler 0.0.34.12 - Poppler bindings  https://hackage.haskell.org/package/gi-poppler-0.0.34.12 (inaki)
10:27:00 <Phyx-> OpenSSLHatesMe which GHC?
10:27:05 <Phyx-> oh.. he left
10:27:08 <maerwald> and I agree that inter-language communication is more important than trying to figure out how to solve everything in one language
10:27:09 <quchen> maerwald: Haven't used inline-c yet, but it looked really awesome in Francesco's talk
10:27:18 <quchen> (At the Haskell Exchange 2015)
10:28:01 <monochrom> perhaps solve "how to do mesh in Haskell" instead of "how to do mesh by half-edge data structure in Haskell"
10:28:20 <maerwald> monochrom: and you might never solve it...
10:28:25 <cocreature> maerwald: I did ffi with structs using c2hs a while back and it wasn‚Äôt too bad
10:28:36 <quchen> Unless youI're Okasakmett.
10:28:56 <maerwald> if there's a solution that has been used since decades and is proven to work well in practice... why try from scratch?
10:29:11 <maerwald> use the algorithms smarter ppl have come up before you
10:29:11 <mauke> I bet you can just translate the C code to haskell
10:29:35 <monochrom> proven to work well for mutable languages in practice.
10:29:40 <maerwald> mauke: well, I've implemented, I'd love to see your solution
10:29:44 <monochrom> but you're using an immutable language
10:29:50 <stephen_> Anyone aware of any work on implementing tensor algebra?
10:30:35 <stephen_> Oh, just found this code.haskell.org/~thielema/numeric-quest/Tensor.lhs
10:30:37 <stephen_> Anyone know of anything else?
10:30:47 <maerwald> monochrom: if you go that route for every problem you encounter, you either need to be edwardk or never finish the actual program ;)
10:30:48 <mauke> data HE_edge = Mk_HE_edge{ vert :: Ptr HE_vert, pair :: Ptr HE_edge, face :: Ptr HE_face, next :: Ptr HE_edge }
10:31:40 <maerwald> doesn't look like a haskell API, doh
10:31:47 * hackagebot gi-soup 0.2.52.12 - Soup bindings  https://hackage.haskell.org/package/gi-soup-0.2.52.12 (inaki)
10:31:49 * hackagebot gi-vte 0.0.42.12 - Vte bindings  https://hackage.haskell.org/package/gi-vte-0.0.42.12 (inaki)
10:31:51 * hackagebot gi-webkit2 0.2.10.12 - WebKit2 bindings  https://hackage.haskell.org/package/gi-webkit2-0.2.10.12 (inaki)
10:31:53 * hackagebot gi-webkit2webextension 0.2.10.12 - WebKit2WebExtension bindings  https://hackage.haskell.org/package/gi-webkit2webextension-0.2.10.12 (inaki)
10:32:47 <maerwald> and I was actually talking about constructing the thing, not just the data structure itself
10:37:59 <Xandaros> I love edward's reputation. He is almost like some kind of god. (He probably deserves it, too)
10:38:32 <maerwald> well, look at his code...
10:49:17 <Gurkenglas> :t untilM_ (return ()) -- nitrix, https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:untilM_
10:49:19 <lambdabot> Monad m => m Bool -> m ()
10:49:32 <hnl23> hey can anyone confirm if these functions are/do the same? http://lpaste.net/151358
10:49:34 <hnl23> thanks
10:51:28 <scshunt> hnl23: no, they are not. where did this come up?
10:51:50 <nitrix> Gurkenglas: I think you're scrolled up by like, a day.
10:52:45 <ThatTreeOverTher> "no_fun_allowed"
10:52:54 <hnl23> scshunt I need to define     fun f l = product (map f (filter (>0) l))   without using map and filter, recursively
10:53:10 <hnl23> thatTreeOverTher that was just out of boredom
10:53:23 <ThatTreeOverTher> I know, it's amusing
10:53:52 <hnl23> so, why are they not doing the same thing?
10:54:14 <ThatTreeOverTher> why not use map and filter?
10:54:16 <scshunt> hnl23: What does your function do when you give it an empty list?
10:54:20 <scshunt> ThatTreeOverTher: homework, most likely
10:54:45 <ThatTreeOverTher> I wish I went somewhere that taught haskell
10:54:51 <dustmote> ditto
10:54:55 <hnl23> ThatTreeOverThere studying for an exam
10:55:30 <hnl23> ThatTreeOverTher I was taught how to make Sokoban in haskell in 4 months
10:55:34 <hnl23> was fun
10:56:09 <ThatTreeOverTher> oh that's really neat
10:56:22 <scshunt> ThatTreeOverTher: where are you?
10:56:41 <ThatTreeOverTher> University of Hartford
10:56:52 <hnl23> scshunt fixed it, what about now? :b http://lpaste.net/151358
10:57:05 <ThatTreeOverTher> I think eventually we learn Scheme and OCaml?
10:57:15 <scshunt> hnl23: pretty sure that doesn't compile
10:57:20 <ThatTreeOverTher> but Java is the thing we get the most detail on, with a sprinkle of Python
10:57:29 <scshunt> ah
10:57:32 <scshunt> I know nothing of the school
10:57:37 <ThatTreeOverTher> most people don't
10:57:39 <hnl23> scshunt I'm tired, fixed it now I think
10:57:54 <scshunt> looks about right to me
10:57:57 <scshunt> you should run some tests thogh
10:57:59 <scshunt> *though
11:00:10 <Gurkenglas> :t liftM (maybe () absurd) . under (_Wrapping MaybeT) forever . liftM (bool Nothing (Just ())) -- nitrix, indeed, and it looked on ircbrowse how the conversation had ended without that suggestion so I added it. Also this one.
11:00:13 <lambdabot> Monad n => n Bool -> n ()
11:00:30 <lisbeth> www.hastebin.com/yocidesefo.cmake
11:00:31 <Gurkenglas> -how+like
11:02:29 <frerich> hnl23: Try installing the 'quickcheck' package, and then -- e.g. in ghci -- do 'import Test.QuickCheck' and then 'quickCheck $ \xs -> fun (*2) xs == no_fun_allowed (*2) xs'
11:02:54 <frerich> hnl23: I wonder whether that homework rather tried to make you use a feature of Haskell called 'list comprehensions', seeing that you should only replace 'map' and 'filter' but not 'product'.
11:03:05 <hnl23> frerich that sounds really useful, thanks
11:03:32 <tesrty> 'atom-text-editor[data-grammar~="haskell"]': '': 'haskell-ghc-mod:check-file' '': 'haskell-ghc-mod:lint-file' 'ctrl-alt-t': 'haskell-ghc-mod:show-type' #this is an example binding  'ctrl-alt-i': 'haskell-ghc-mod:show-info' #this is an example binding  'ctrl-alt-T': 'haskell-ghc-mod:insert-type' #this is an example binding  '': 'haskell-ghc-mod:show-info-fallback-to-type'
11:03:38 <tesrty> sorry!
11:03:44 <codedmart> How can I accomplish this more succinctly? https://gist.github.com/codedmart/97ead1d6797bc9dc682e#file-main-hs-L4-L6
11:03:57 <tesrty> Can I do: data Tree a = Leaf a | Bin (Tree a) (Tree a). But force it to only store Integers?
11:04:25 <hnl23> frerich they want an alternative for the smaller function, so I think that as long as they do the same thing it's fair game
11:05:41 <Gurkenglas> :t iso (maybe () absurd) (bool Nothing (Just ())) :: Iso (Maybe Void) (Maybe ()) () Bool -- Should this be in some library?
11:05:42 <lambdabot> (Functor f, Profunctor p) => p () (f Bool) -> p (Maybe Void) (f (Maybe ()))
11:06:53 <chip2n> Sup lovelies. I would like to compile a module residing inside my cabal project into GHC Core to get access to the syntax tree and all that good stuff. I tried using the ghc-simple module (compileWith function), but it complained that I was trying to compile a package module. According to the documentation, you should be able to pass either a module name or a file name. Anyone have any idea why this didn't work? I can compile by file n
11:07:32 <Ongy> hm, I tried the example from nvim-hs with neovim, but when i want to call Fibonacci I get a weird error about expecting Integer but getting ObjectUInt, does anyone know how to fix that?
11:07:53 <lisbeth> lol like 12 issues in a row
11:08:33 <Gurkenglas> (the from version of that, of course.)
11:08:45 <ThatTreeOverTher> apparently hlint does indeed suggest fmap... time to do some hacking to figure out why something told me to use liftM https://github.com/ndmitchell/hlint/issues/132
11:10:07 <Gurkenglas> codedmart, 'if elem k ["open_notes", "updated_at", "created_at"] then Null else object ["field_name" .= k, "value" .= v]'?
11:10:35 <ThatTreeOverTher> aha, ghc-mod suggests liftM but hlint should suggest fmap
11:11:39 <codedmart> Gurkenglas ah right, thanks!
11:12:06 <Gurkenglas> codedmart, also consider 'guard (notElem k ["open_notes", "updated_at", "created_at"]) >> object ["field_name" .= k, "value" .= v]' and then mapMaybe above instead of "filter (\v -> v /= Null) $ fmap"
11:13:03 <frerich> codedmart: If you made 'keyValuePair' yield a 'Maybe Value' then you define 'valueToPersistParams (Object o) = mapMaybe keyValuePair (HM.toList o)'
11:13:15 <Gurkenglas> *">> Just (object". Hmm maybe there's something better for "Alternative f => Bool -> a -> f a".
11:14:03 <Gurkenglas> http://hackage.haskell.org/package/control-bool-0.2.1/docs/Control-Bool.html#v:aguard-39- there
11:15:56 <codedmart> Thanks guys
11:16:50 * hackagebot typed-wire 0.3.0.0 - Language idependent type-safe communication  https://hackage.haskell.org/package/typed-wire-0.3.0.0 (AlexanderThiemann)
11:31:39 <tesrty> Can I do: data Tree a = Leaf a | Bin (Tree a) (Tree a). But force it to only store Integers instead of 'a's?
11:31:56 <mauke> no
11:32:21 <tsahyt> data IntTree = Leaf Int | Bin IntTree IntTree?
11:32:34 <tsahyt> although what you probably want is just to use Tree Int
11:32:38 <mauke> type IntTree = Tree Int
11:32:41 <tsahyt> exactly
11:32:52 <ARM9> a is a type variable, you could perhaps put some constraints in implementation but that would be odd
11:33:53 <tesrty> I see! That makes a lot of sense. I need to read the chapter on datatypes again.
11:34:05 <tesrty> Thanks guys.
11:42:46 <quchen> ARM9: Don't constrain your data types, https://github.com/quchen/articles/blob/master/fbut.md#imposing-constraints-on-data-types
11:43:05 <quchen> (Making the "odd" more concrete)
11:48:32 <monochrom> odd? ord? :)
12:01:11 <deepfire> is ChasingBottoms author here, per chance?
12:01:30 <deepfire> upper bounds vs. GHC 8..
12:10:15 <hsk3> Is there a way in Haskell to prevent usage of unsafe (incomplete) functions like head and tail that can throw exceptions?
12:10:23 <hsk3> To get error (or warning) at compile time about them
12:10:46 <hsk3> (In case I accidentally use them)
12:12:23 <saunamees> Hi everyone, I request help. I have here: https://codeshare.io/e5EnB 2 working codes, but My question is: Are they good solutions (read Assymptotically optional) or is there a much better way to do these tasks ?? 
12:18:43 <bergmark> hsk3: you can make your own base-like package that doesn't expose partial functions, then you just need to make sure you don't depend on base
12:20:04 <ARM9> or you can hide them if you only want it in some module
12:21:00 <ARM9> import Prelude hiding (head,tail)
12:26:41 <hsk3> ok thanks
12:28:12 <ireaderrorcodes> hello 
12:28:37 <ireaderrorcodes> I'm learning haskell atm and I'm trying to use the function takewhile
12:28:53 <ireaderrorcodes> I would like to take while the sum of a field of a custom data is less than n
12:29:36 <ireaderrorcodes> e.g. takeWhile ((<= strenght) . (sum . (item_grams))) [items....]
12:29:44 <ireaderrorcodes> am I doing something wrong here?
12:30:30 <ARM9> define custom data, as in a custom data structure? the prelude takeWhile is only defined for lists
12:30:40 <hpc> ireaderrorcodes: you want some kind of rolling sum
12:31:03 <ireaderrorcodes> yeah by costum data i mean
12:31:10 <hpc> takeWhile (\(v, sum) -> sum <= strength) (rollingSum [whatever ..])
12:31:12 <ireaderrorcodes> some data type i made that has an Integer 
12:31:37 <ireaderrorcodes> what is a rollingsum?
12:31:45 <hpc> you'll need to write rollingSum :: [Whatever] -> [(Whatever, Double)]
12:33:46 <hpc> hopefully that makes sense
12:34:01 <hpc> make a new list that includes the computed value you want to inspect
12:34:47 <hsk3> Can Enum really represent infinite sequences?
12:34:48 <hsk3> I ask because toEnum and fromEnum are in terms of Int, which is limited
12:35:19 <hpc> there's an instance right there in Prelude, even!
12:35:30 <hpc> > enumFrom 1 :: [Integer]
12:35:32 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
12:35:39 <hpc> :t enumFrom
12:35:41 <lambdabot> Enum a => a -> [a]
12:36:16 <hpc> > fromEnum (2 ** 123456789123456789 :: Integer)
12:36:17 <lambdabot>      No instance for (Floating Integer) arising from a use of ‚Äò**‚Äô
12:36:17 <lambdabot>      In the first argument of ‚ÄòfromEnum‚Äô, namely
12:36:17 <lambdabot>        ‚Äò(2 ** 123456789123456789 :: Integer)‚Äô
12:36:22 <hpc> > fromEnum (2 ^ 123456789123456789 :: Integer)
12:36:28 <lambdabot>  mueval: ExitFailure 1
12:36:28 <ireaderrorcodes> #hpc is something like this rollingSum  wuteverses = sum (map grams wuteverses)?
12:36:41 <geekosaur> :t (^)
12:36:42 <lambdabot> (Integral b, Num a) => a -> b -> a
12:36:52 <ireaderrorcodes> but I would like to keep the list of [wutever]
12:36:54 <geekosaur> hm
12:36:58 <hpc> ireaderrorcodes: the sum function reduces the list, so you'll need something that traverses it
12:36:58 <notabigthreat> > fromEnum (2^1000 :: Integer)
12:37:00 <lambdabot>  0
12:37:17 <hpc> notabigthreat: heh
12:37:28 <hsk3> > :t toEnum
12:37:29 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
12:37:38 <hsk3> :t toEnum
12:37:39 <lambdabot> Enum a => Int -> a
12:37:43 <hsk3> :t fromEnum
12:37:44 <lambdabot> Enum a => a -> Int
12:37:46 <hsk3> That's what I mean.
12:37:47 <hsk3> Int.
12:37:49 <ireaderrorcodes> #hpc like this? rollingSum  wuteverses = (wuteverses, sum (map grams wuteverses)) 
12:37:52 <ireaderrorcodes> man this is hard XD
12:37:58 <hpc> hsk3: yeah, Integer is an enum too
12:38:00 <hpc> and it's infinite
12:38:18 <hpc> hsk3: those two functions don't have to be total
12:38:23 <ireaderrorcodes> its so tempting to just code everything in python XD
12:38:56 <hpc> ireaderrorcodes: let's start with an easier function
12:39:36 <hpc> ireaderrorcodes: rollingSumHelper 0 [1,2,3,4] = [(1,1),(2,3),(3,6),(4,10)]
12:39:41 <hsk3> hpc: is it possible to define enumFromTo without using toEnum and fromEnum?
12:39:54 <hsk3> those two functions seem to be important...
12:40:05 <hsk3> but they're Int
12:40:08 <hsk3> :S
12:40:21 <hpc> hsk3: do your best to make it make sense for your type
12:40:31 <hpc> obey any laws that are in Enum's docs
12:40:43 <hpc> but i guarantee you they say nothing about toEnum and fromEnum being total
12:40:54 <hpc> so you don't have to worry about not meeting the size of Int with your type
12:40:59 <hpc> or Int not meeting the size of your type
12:41:37 <hpc> ireaderrorcodes: it'll be recursive, the first parameter being your accumulator
12:42:01 <ireaderrorcodes> I'm trying to make some sense out of it 
12:43:24 <chaosmasttter> > let swaps [] = []; swaps (_ : []) = []; swaps (x : x' : xs) = (x' : x : xs) : map (x :) (swaps $ x' : xs) in swaps [1,2,3,4] -- saunamees
12:43:25 <lambdabot>  [[2,1,3,4],[1,3,2,4],[1,2,4,3]]
12:44:16 <hpc> ireaderrorcodes: btw, there's a really really short solution that uses built-in functions, but the build-up to it will teach you far more
12:44:41 <hpc> i'll try and lead you to it, because it's quite nice
12:44:49 <ireaderrorcodes> yeah thanks for guiding me through it
12:44:54 <ireaderrorcodes> I'm trying to figure this out
12:45:50 <mrlase> is there any trivial way to represent a Month with Data.Time?
12:46:04 <mrlase> I was going to use Data.Thyme, but it doesn't appear to work with Database.Persist
12:46:52 <saunamees> Thanks chaosmasttter. 
12:47:47 <hpc> mrlase: write the instances yourself?
12:47:55 <ireaderrorcodes> hpc: if I had to computer the sum of [:n] at the nth element in the list, then wouldn't it be super redundant to use takewhile?
12:48:39 <ireaderrorcodes> when the goal was to take until sum of grams <= max of this list of [wutever]
12:49:06 <hpc> ireaderrorcodes: you're solving one piece at a time
12:49:24 <hpc> ireaderrorcodes: first you solve "i don't know the rolling sum of this list", then you solve "i only need this many values"
12:49:51 <hpc> ireaderrorcodes: and then ill show you how miraculously non-redundant it is ;)
12:49:52 <ireaderrorcodes> ohhhhhh hpc: damn your way of problem solving is really unique 
12:50:28 <hpc> it's a method i picked up here
12:51:06 <ireaderrorcodes> is there a way to start a private conversation?
12:51:20 <hpc> there is, but we're not off-topic here
12:51:22 <ireaderrorcodes> i'm still not used to this irc thing XD
12:51:41 <vxkr> hello
12:51:47 <hpc> and others can chime in if i am forgetting anything
12:52:08 <ireaderrorcodes> alright, good idea
12:53:19 <hpc> ireaderrorcodes: if you need any hints, i can paste part of the code
12:53:57 <ireaderrorcodes> still working at it, this way of thinking is pretty new for me
13:02:14 <Joost123> I'm doing the monad challenges tutorial http://mightybyte.github.io/monad-challenges/pages/ex4-4.html. And I'm trying to define an instance for: Gen a = Gen {runGen :: Seed -> (a, Seed)}. But I can't get it to work
13:03:00 <Joost123> Right now I have this: 
13:03:00 <Joost123> instance Monad Gen where
13:03:00 <Joost123>     --bind = undefined
13:03:00 <Joost123>     -- Gen a -> ( a -> Gen b ) -> Gen b
13:03:00 <Joost123>     bind gen f  = (\s -> f' (runGen gen s))
13:03:00 <Joost123>             where f' (a,s') = f a
13:03:00 <Joost123>     return a  = Gen (\s -> ( a, s))
13:03:32 <Joost123> What am I doing wrong?
13:03:37 <ireaderrorcodes> hpc: something like this? http://pastebin.com/X8v9NGnB
13:04:20 <ireaderrorcodes> actually ignore that I just found typos XD
13:04:32 <hpc> ireaderrorcodes: you're moving in the right direction
13:05:18 <ireaderrorcodes> so now with
13:05:19 <ireaderrorcodes>  rollingSum :: Integer -> [wutever] -> [(Integer, wutever)] rollingSum c_sum [] = []   rollingSum :: Integer -> [wutever] -> [(Integer, wutever)] rollingSum c_sum, [wut:xwuts] = ((gram wut) + c_sum, wut) ++ rollingSum((c_sum + (gram wut)), xwuts)
13:05:57 <mauke> Joost123: bind needs to return a Gen
13:05:58 <ireaderrorcodes> i get this weird [wut] -> [(sum1, wut1) .... (sumn, wutn)]
13:06:04 <mniip> hmm I wonder
13:06:07 <mauke> Joost123: currently you're returning a function
13:06:08 <mniip> does this thing have a name
13:06:10 <mniip> :t Control.Monad.Trans.Free.FreeT . pure . Control.Monad.Trans.Free.Free $ Control.Monad.Trans.Free.FreeT . pure . Control.Monad.Trans.Free.Pure
13:06:12 <lambdabot> Applicative m => Control.Monad.Trans.Free.FreeT ((->) a) m a
13:07:33 <hpc> ireaderrorcodes: you pretty much have it, except for some syntactic things like using foo(a,b) instead of (foo a b)
13:07:36 <hpc> ireaderrorcodes: http://lpaste.net/7531621342794219520
13:07:43 <ireaderrorcodes> hpc: (map v (takeWhile (\(c_sum, v) -> c_sum <= strength))
13:07:57 <ireaderrorcodes> i think that will get the the final list that I want
13:08:16 <hpc> ireaderrorcodes: indeed
13:08:22 <ireaderrorcodes> thank you so much for the tips! XD
13:08:31 <ireaderrorcodes> what would be the ez way built-in function out?
13:08:38 <ireaderrorcodes> if you don't mind telling me :p
13:08:41 <hpc> yeah
13:09:13 <hpc> so, stripping out much of the specifics of your problem, we get something like [/me types]
13:12:16 <hpc> http://lpaste.net/7640011572722532352
13:13:10 <hpc> ireaderrorcodes: specific to your example, f = \accum x -> accum + gram x
13:13:34 <hpc> ireaderrorcodes: and in the type signature, b = Int, a = (your type)
13:13:57 <ireaderrorcodes> accum looks like a pretty useful function XD
13:14:14 <scshunt> it's not a function
13:14:25 <hpc> accum is the parameter
13:14:33 <scshunt> \ is the lambda introducer; it is used to create an anonymous parameter
13:14:39 <scshunt> err
13:14:41 <scshunt> anonymous function
13:15:15 <deepfire> is there some kind of a trick for efficient communication with DarcsDen people?
13:15:17 <hpc> don't get in the habit of translating between languages, but it's lambda(accum, x): accum + gram(x)
13:15:56 <hpc> ireaderrorcodes: anyhoo, it turns out there's an extremely similar function already defined
13:15:59 <hpc> scanl :: (b -> a -> b) -> b -> [a] -> [b]
13:16:39 <ireaderrorcodes> hpc: thanks! I will definitely read what it does
13:17:53 <hpc> ireaderrorcodes: it's not quite the same, but with the right initial parameters it can be made the same
13:18:19 <ireaderrorcodes> yeah I think it will make computing the sum a lot easier 
13:18:22 <ireaderrorcodes> with + 
13:18:41 <hpc> > scanl (+) 0 [a, b, c] -- here's a short example of it in action
13:18:43 <lambdabot>  [0,0 + a,0 + a + b,0 + a + b + c]
13:18:48 <Xandaros> Is it possible to write type classes for dependent types? In particular, I want it to contain a function similar to ¬¥X u a -> X v b -> X w c¬¥, where u and v are some non-*-kinded types and w gets decided by the instance (so is not actually polymorphic as my signature suggests)
13:19:04 <Xandaros> I tried using type families for this, but they dislike being used for non-* kinds
13:19:22 <hpc> you'll need to replace (+) with a function that works on a tuple of the rolling sum and the initial value
13:19:33 <hpc> and replace 0 with some more sensible initial value
13:19:35 <Joost123> mauke: I still can;t figure it out. I am supposed to apply f to an a, right? But the only way to get an a is to runGen. But now I need a Seed. Which I don't have.
13:19:42 <hpc> and you'll have your helper rolling sum function
13:20:06 <ireaderrorcodes> can't I just calculate the rolling sums first then zip it to make the tuple?
13:20:07 <hpc> then write rollingSum = rollingSumHelper f z -- fill in f and z appropriately
13:20:16 <hpc> oh yes, or that
13:20:26 <ireaderrorcodes> or is that a bit too lazy
13:20:32 <hpc> no that's actually much better
13:20:50 <hpc> so it'd be something like
13:21:04 <hpc> > let list = [1, 2, 3, 4, 5] in zip (scanl (+) 0 list) list
13:21:07 <lambdabot>  [(0,1),(1,2),(3,3),(6,4),(10,5)]
13:21:25 <saunamees> Our uni teaches Haskell, but it is quite bad. Can you recommend any learning materials ? I learned mostly from learnyouahaskell, thinking of doing hackerrank exercises next. 
13:21:26 <ireaderrorcodes> is something like this correct?  [x:xs] = scanl (+) (gram x)(map gram xs)
13:21:27 <hpc> > let list = [1, 2, 3, 4, 5] in zip (scanl1 (+) list) list -- there's also a scanl1 function
13:21:29 <lambdabot>  [(1,1),(3,2),(6,3),(10,4),(15,5)]
13:21:51 <ireaderrorcodes> man this is sooooo neat 
13:22:00 <mauke> Joost123: what do you need a Seed for?
13:22:18 <hpc> and then you can (map fst) . takeWhile (...)
13:22:21 <hpc> and you're done!
13:22:25 <ireaderrorcodes> hpc: yep scanl1 is definitely a lot better 
13:22:27 <Xandaros> saunamees: LYAH is good, real world haskell is also nice. There's a great article called "What I wish I knew when learning Haskell", which contains a few insights. I can also recomment looking at the typeclassopedia once you get to functors, applicatives and monads
13:22:30 <ireaderrorcodes> thank you so much! 
13:22:40 <ireaderrorcodes> It would have taken days for me to figure this out
13:22:49 <hpc> np
13:22:52 <Joost123> If you don't have a seed, you can't get out the a right?
13:23:16 <mauke> Joost123: from where?
13:23:32 <mauke> Joost123: also, what a?
13:23:32 <Joost123> newtype Gen a = Gen {runGen :: Seed -> (a, Seed)}
13:23:53 <Joost123> http://lpaste.net/151374
13:24:38 <mauke> bind gen f = \... -> ... is wrong
13:24:41 <mauke> that's a type error
13:26:51 <Joost123> Yeah, I can see it doesn't work. The problem is that I don't know what I should do
13:27:12 * hackagebot language-ecmascript-analysis 0.9.2 - JavaScript static analysis library.  https://hackage.haskell.org/package/language-ecmascript-analysis-0.9.2 (AndreyChudnov)
13:27:23 <mauke> well, you need to return a Gen b
13:27:28 <nshepperd_> Xandaros: that should be possible to work with type families, given the right kind signatures
13:27:51 <mauke> Joost123: so the skeleton you should start with is: bind gen f = Gen (\s -> ...)
13:28:10 <nshepperd_> Xandaros: but you can also express that with a typeclass with FunctionalDependencies
13:29:34 <nshepperd_> Xandaros: say, if your kind is T, something like class Foo (u :: T) (v :: T) (w :: T) | u v -> w where { ... }
13:32:10 <Xandaros> That's about what it looked like, minus the fundeps
13:32:13 * hackagebot cabal-install 1.22.8.0 - The command-line interface for Cabal and Hackage.  https://hackage.haskell.org/package/cabal-install-1.22.8.0 (ryant)
13:32:15 <Xandaros> I'll try that once I get gome, thanks
13:32:52 <saunamees> Thanks Xandaros for the resources, they look good. 
13:32:55 <Xandaros> I guess it still won't work for w not depending on u and v, but I can live with that for now :D
13:35:19 <Joost123> Thank you! I got it to work. the problem was that I got confused with the runGen part of the Gen. I actually tried a solution starting with Gen (\s -> ...) But I couldn't figure out what to do next. But htanks agian!
13:41:35 <Xandaros> nshepperd_: in the instance declaration, can I then just use an instancesig to force the type of w?
13:42:25 <scutigera> files' <- filterM (\(f1, f2) -> liftM2 (&&) (doesFileExist f2) (F.newer f1 f2)) files
13:43:23 <scutigera> hello. that breaks because the (&&) doesn't short-circuit.  How should i be implementing the desired behavior ?
13:43:31 <nshepperd_> Xandaros: you just write 'instance Foo A B C' or whatever as normal
13:44:11 <Gurkenglas> scutigera, https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:andM
13:45:08 <monochrom> scutigera: && short-circuits. but liftM2 doesn't.
13:45:21 <monochrom> evidence:
13:45:24 <scutigera> yes. i do understand why it doesn't work (much too my surprise).
13:45:27 <monochrom> > False && undefined
13:45:29 <lambdabot>  False
13:45:55 <Xandaros> nshepperd_: Hmmm, I'm not sure I understand completely, but I'll play around with it later (I'll be home in like 2 hours)
13:45:59 <scutigera> i was just sort of wondering if i should be changing my approach.
13:46:12 <monochrom> yes, you should abandon liftM2
13:46:20 <scutigera> lol. ok then.
13:46:36 <scutigera> and i was so proud of the fact that i actually thought of using liftM2
13:47:21 <Gurkenglas> > runState (andM [modify (+1) >> return False, modify (+1) >> return True]) 1
13:47:23 <lambdabot>  (False,2)
13:47:38 <Gurkenglas> > runState (andM [modify (+1) >> return True, modify (+1) >> return True]) 1
13:47:39 <lambdabot>  (True,3)
13:48:17 <monochrom> @type f
13:48:19 <lambdabot> FromExpr a => a
13:50:11 <scutigera> should Control.Monad.Loops be part of GHC install ?
13:50:41 <pikajude> hi, is there a library that represents something like a bidirectional fmap?
13:50:44 <monochrom> it isn't now. don't know about "should". organize a committee to find out.
13:51:13 <pikajude> like fmap2 :: (b -> c) -> (c -> b) -> f a b -> f a c
13:51:17 <scutigera> ok. so it is cabal - installed. just making sure nothing was wrong with my ghc install.
13:51:38 <Gurkenglas> imo it's haxxy and we should get MaybeT into a state where we can get people to use it for monadic looping
13:52:09 <Gurkenglas> pikajude, what's the a for?
13:52:33 <pikajude> Gurkenglas: in my case, the "f" is a datatype that has an `a -> b` field and a `b -> a` one
13:52:51 <Gurkenglas> I don't want your case I want the explanation for the a in the line you pasted :P
13:52:59 <pikajude> so fmap2 f g (Foo in out) = Foo (f . in) (out . g), i think
13:53:21 <pikajude> dunno, i guess it's not needed
13:53:33 <noteventime> pikajude: Profunctor?
13:54:30 <pikajude> hmm, i don't think so
13:54:38 <pikajude> profunctor operates on two type variables and I only need to change one
13:54:58 <noteventime> Sorry, misread your type signature
13:55:15 <pikajude> i know, my type signature was a calamity
13:55:21 <pikajude> it should just be (b -> c) -> (c -> b) -> f b -> f c
13:55:34 <Gurkenglas> Is fmap 2 f g . fmap 2 f g == id?
13:55:47 <Gurkenglas> without the spaces between fmap and 2 ._.
13:56:37 <pikajude> i don't think so
13:56:40 <pikajude> but i don't really understand the question
13:56:45 <pikajude> why would it be?
13:56:53 <Gurkenglas> Oh right, "fmap2 f g . fmap2 g f"
13:57:14 <pikajude> yes, i think that makes sense
13:57:17 * hackagebot cabal-install 1.20.2.0 - The command-line interface for Cabal and Hackage.  https://hackage.haskell.org/package/cabal-install-1.20.2.0 (ryant)
14:04:41 <tesrty> I'm trying to solve a simple assignment. http://lpaste.net/4637690576525852672
14:04:59 <tesrty> the exercise is here: https://github.com/ruudkoot/functional-programming/tree/master/3-TypeClasses
14:05:23 <tesrty> It's very unclear on exercise 3. Writing the Foldable instance
14:05:54 <tesrty> Basically I'm asked to write a foldable instance for 'data Rose a = a :> [Rose a]'
14:06:32 <tesrty> after having writter a functor instance: 'fmap f (a :> rs) = f a :> map (fmap f) rs'
14:06:47 <tesrty> and getting explained what a monoid is. A tiny bit.
14:06:52 <tesrty> and I'm completely lost.
14:07:16 <tesrty> Maybe one of you can just point me in the direction of some text that would explain how to write foldables or monoids in the first place.
14:08:18 <monochrom> tesrty: should I read the pdf? should I read Assignment3.hs?
14:08:32 <tesrty> the pdf exercise 3
14:08:37 <tesrty> the hs is the file we start with.
14:08:50 <tesrty> the lpaste is that file but with exercise 1 and 2 completed by me.
14:08:56 <tesrty> thanks monochrom !
14:09:19 <tesrty> Just understanding what the creator wants me to understand or do would be a great help.
14:10:50 <monochrom> I wonder if I could simply provide you a few test cases, and that would be enough for you to see the intended meaning of "fold" for Rose and therefore what you need to do.
14:11:23 <tesrty> perhaps.
14:11:36 <tesrty> I understand how foldr reduces a list.
14:11:51 <Bruuuuno> Hi, I don't get the MonadReader definition (class Monad m => MonadReader r m | m -> r where), what does "m -> r" means in that context?
14:12:16 <tesrty> at least I think when I: "foldr (+) 0 [1,2,3]" I really know whats going on.
14:12:18 * hackagebot purescript 0.8.0.0 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.8.0.0 (PhilFreeman)
14:12:20 * hackagebot cabal-install 1.18.2.0 - The command-line interface for Cabal and Hackage.  https://hackage.haskell.org/package/cabal-install-1.18.2.0 (ryant)
14:12:43 <noteventime> Bruuuuno: The keyword you're after is functional dependency 
14:13:35 <Bruuuuno> In relational database theory, a functional dependency is a constraint between two sets of attributes in a relation from a database. In other words, functional dependency is a constraint that describes the relationship between attributes in a relation.
14:13:36 <Bruuuuno> ?
14:13:54 <noteventime> Bruuuuno: https://wiki.haskell.org/Functional_dependencies :)
14:14:16 <noteventime> I forgot it was a thing in database systems as well 
14:14:39 <Bruuuuno> Thanks noteventime, I'm glad I don't have to do some sql to get that hahaha
14:14:48 <noteventime> Bruuuuno: Agreed :P
14:15:28 <lpaste> monochrom annotated ‚ÄúHaskell Exercises‚Äù with ‚ÄúHaskell Exercises: some test cases‚Äù at http://lpaste.net/4637690576525852672#a151377
14:15:52 <monochrom> tesrty: that
14:16:16 <monochrom> I hope I don't have a typo or syntax error
14:16:29 <x77686d> I'm curious: Does anybody have any idea as to how widely (or not) the debugging stuff in ghci is used by programmers who work with Haskell on a daily basis?
14:16:54 <tesrty> Thank you very much monochrom ! I'll see what I can make of that.
14:17:14 <tesrty> Well ghc is mad anyway because of ambiguous occurences
14:17:28 <tesrty> Problem in one screen: http://i.imgur.com/Y7O1LQ3.png
14:18:02 <tesrty> But no worries. I'll try some things first.
14:18:43 <noteventime> tesrty: A monoid is any binary operator, say #, that's associative (meaning a # b # c ... is unambiguous, i.e. ((a # b) # c)... must be the same as a # (b # c ...) and has a unit (that is to say an element, say e, such that a # e = a and e # a = a), the reason you want operations that you fold to be monoids is that the first one means you're free to choose between left/right folds (or, indeed, any * fold) without affecting the result
14:18:44 <noteventime> and the latter means you have a well defined value for empty structures 
14:19:04 <monochrom> tesrty: Prelude already has Monoid. so it doesn't like you defining another copy.
14:19:22 <noteventime> the monoid type class is there for when a type has a natural monoid operator 
14:20:12 <monochrom> there are ways you can say "don't import Prelude's Monoid"
14:20:44 <monochrom> but in a homework setting, it is the responsibility of the teacher to tell you "this is already in the Prelude, don't enter it again"
14:21:37 <tesrty> Hmhm. I read part of that in my textbook noteventime. At least about associative binary operator and identity element, but it remains unclear how that and my created functor will help me fold.
14:21:51 <tesrty> Give me a sec to try and work with what monochrom wrote me ;]
14:22:04 <monochrom> a lot of profs only care about "my handouts look so nice on paper" and do not think about what happens when you actually try to reproduce an experiment scientifically.
14:22:25 <tesrty> Yea, that's what I wanted to try and look for after I got something useful written down monochrom. How to disable prelude.
14:22:41 <monochrom> import Prelude hiding (Monoid(..))
14:23:22 <tesrty> Oh I didn't write all that monochrom. Just the line with the fmap for Rose and the monoid for Product. The rest is all the TA.
14:23:32 <monochrom> or delete your own "class Monoid a where ..."
14:23:34 <koz_> I need to present some data in a document in nicely-tabular form. Is there a Haskell package which can do that for me into a format I can then compile/whatever into a PDF or something?
14:24:07 <tesrty> And I would ask him most of this, but this course I failed last period, still I love haskell, it intrigues me a lot so here's me doing exercises that were deemed fit to teach me :]
14:24:17 <tesrty> Okay, thanks, I'll try that.
14:24:57 <monochrom> actually, preserve your own, hide Prelude's. because Prelude's has "mappend" rather than the nicer "<>"
14:25:14 <mniip> @. pl undo \f -> do t:ts <- get; put ts; f t
14:25:14 <lambdabot> (line 1, column 33):
14:25:14 <lambdabot> unexpected '{'
14:25:14 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
14:25:18 <mniip> oops
14:25:25 <monochrom> but either way the teacher is supposed to tell you this.
14:25:38 <mniip> hrmpf
14:25:56 <mniip> there's no good way to fold this is there
14:25:59 <monochrom> you know what, profs (and TAs) not only are careless about this in teaching. they are equally careless about this in research publication too
14:26:25 <mniip> oh actually
14:26:49 <mniip> that's not even right, it needs MonadPlus, not 'fail'
14:27:00 <monochrom> they usually publish research results that don't come with the code they ran to obtain their results so you can reproduce the experiment yourself.
14:27:09 <monochrom> and that's already the best case
14:27:23 <monochrom> the worst case is they publish code different from what they used
14:27:48 <monochrom> somehow CS academic people are completely unscientific about this
14:28:08 <mniip> so uh
14:28:17 <mniip> what would be a good way to write this
14:28:51 <ThatTreeOverTher> science currently has no idea what to do with code
14:28:52 <mniip> \f -> get >>= \r -> case r of [] -> mzero; t:ts -> put ts >> f t
14:29:03 <scutigera> monochrom: sadly they are not the only ones to not do that. as you probably know reproducibility of results is a hot topic. and making analysis code available is one part of the puzzle. i'll stop being off-topic now.
14:29:41 <koz_> Also, do I need to specify what type this will spit out (as it has no way of knowing otherwise): https://hackage.haskell.org/package/cassava-0.4.5.0/docs/Data-Csv.html#v:decode ?
14:30:07 <ThatTreeOverTher> you do
14:30:08 <tesrty> Hmm. Sounds tricky. Do you work in academics monochrom ?
14:30:16 <monochrom> yes
14:30:18 <mniip> \f -> get >>= \r -> guard (not $ null r) >> put (tail r) >> f (head r)
14:30:21 <mniip> this looks just awful
14:31:04 <Prokopenko> guys how can i be able to get monad enlightenment?
14:31:20 <tesrty> Well to be fair, the TA would've readily helped me out in the workgroups. But I failed to.
14:31:24 <geekosaur> it's a bit like zen. don't chase the monad, or you will neer catch it
14:31:25 <ThatTreeOverTher> Prokopenko, use them
14:31:28 <scutigera> Prokopenko: write Monad code. Seriously.  it's been helping me.
14:31:35 <ThatTreeOverTher> don't try to understand monads, use monads
14:31:39 <scutigera> i'm knee deep in it right now.
14:31:42 <geekosaur> use them, the understading will gradually develop
14:31:53 <scutigera> and learned more in the last hour than reading about them for a week.
14:31:57 <ThatTreeOverTher> unless you're experienced in math, you will never understand them from a description 
14:32:12 <geekosaur> even that is not clear
14:32:15 <ThatTreeOverTher> "monoid in the category of endofunctors" if that doesn't do anything for you, just write the code
14:32:31 <geekosaur> math is about pure concepts. application does not necessarily follow from pure concepts
14:33:03 <ThatTreeOverTher> just write codes and monads will follow
14:35:40 <monochrom> finding applications is still one of those intelligent mental processes that aren't mechanized yet
14:36:26 <ThatTreeOverTher> how do you mean?
14:36:49 <mniip> hmm, if only there was a function to tear down *one* element of a list
14:36:58 <ThatTreeOverTher> define tear down
14:37:35 <monochrom> pattern matching tears down one element of a non-empty list
14:37:45 <mniip> :: r -> (a -> [a] -> r) -> [a] -> r
14:38:13 <mniip> yeah but pattern matching is syntactically verbose
14:38:38 <monochrom> a call site of that function is not substantially shorter than a case-of
14:38:42 <mniip> monochrom, 1454279305 [01:28:25] <mniip> \f -> get >>= \r -> case r of [] -> mzero; t:ts -> put ts >> f t
14:39:34 <tesrty> So I've written something down monochrom, wanted to test but ghc complains about class Functor. Hiding that however I lose fmap :[
14:39:44 <monochrom> "case x of [] -> y; b:bs -> blahblah" vs "your_function y (\b bs -> blahblah)". marginally shorter.
14:40:00 <mniip> hmm
14:40:00 <mniip> ok
14:40:30 <monochrom> tesrty: I think you should use Prelude's Functor, while sticking with your own Monoid
14:41:51 <monochrom> mniip: basically, "b:bs -> blah" and "\b bs -> blah" are not different enough. this is a main factor why the function is a little better than case-of, and only a little better
14:42:35 <monochrom> the function can win, but only when it's like "your_function xxx yyy" i.e. you don't need a lambda there
14:43:25 <tesrty> Now I lose fmap :[
14:43:39 <mniip> @pl \t ts -> put ts >> f t
14:43:39 <lambdabot> flip ((>>) . put) . f
14:43:41 <mniip> \o/
14:43:41 <barrucadu> Is there a program to extract info from a cabal file? I've just skimmed the hackage results for "cabal", but I'd be kinda surprised if this hadn't been written before...
14:43:53 <tesrty> clarification: http://i.imgur.com/7enwMRc.png
14:44:47 <tesrty> Nevermind. I'm being silly. Let me clean up first.
14:46:15 <geekosaur> barrucadu, there "should be" but probably isn't. I'd imagine most of it could be cribbed from ghc-pkg since cabal files are pretty close to package db files
14:46:27 <geekosaur> (in fact they're both managed by the same Cabal library)
14:46:53 <barrucadu> geekosaur: Yeah, I'm just going to write a little tool which can print fields of a cabal file, using Cabal-the-library
14:47:15 <mniip> so uh
14:47:25 <mniip> here comes the shortest monadic parser library ever
14:47:36 <lpaste> mniip pasted ‚Äúmonadic parser‚Äù at http://lpaste.net/151381
14:47:37 <monochrom> haha
14:47:38 <barrucadu> If I polish it up I guess I'll stick it on hackage then, if there really isn't such a tool already
14:48:12 <monochrom> "FreeT . pure . Free $ FreeT . pure . Pure" looks funny
14:48:26 <barrucadu> mniip: Nice
14:48:26 <Bruuuuno> Any clue on how to implement a function such as (Monad m) => (r -> m a) -> a -> ReaderT r m a?
14:50:20 <monochrom> solution f _ = ReaderT f
14:50:38 <mniip> solution _ x = return x
14:51:37 <Bruuuuno> why does your solution works? monochrom
14:51:52 <monochrom> because it is legal
14:51:56 <int-e> :t ReaderT
14:51:57 <lambdabot> (r -> m a) -> ReaderT r m a
14:52:01 <Bruuuuno> oooooh
14:52:06 <Bruuuuno> thanks!
14:52:06 <mniip> Bruuuuno, you have an extra 'a' methinks
14:52:11 <mniip> where did that signature come from
14:53:01 <int-e> yeah the extra a is a bit strange.
14:53:18 <Bruuuuno> I'm trying to implement reactive banana on the socket-io librairy and I figured that I need that function
14:53:59 <mniip> :t Control.Monad.Trans.Free.hoistFreeT
14:54:01 <lambdabot> (Monad m, Functor f) => (forall a. m a -> n a) -> Control.Monad.Trans.Free.FreeT f m b -> Control.Monad.Trans.Free.FreeT f n b
14:54:18 <mniip> hoistFreeT can be used to change the backtracking monad :o
14:54:29 <monochrom> nice
14:54:35 <mniip> hostFreeT listToMaybe , and the like
14:54:47 <koz_> Also, do I need to specify what type this will spit out (as it has no way of knowing otherwise): https://hackage.haskell.org/package/cassava-0.4.5.0/docs/Data-Csv.html#v:decode ?
14:54:49 <Bruuuuno> basically, the on need (a -> ReaderT Socket IO a), and if I put the reactive banana handler in that function, everything will work
14:55:24 <mniip> which means we can introduce temporary hidden state in parsers :o
14:55:36 <mniip> damn
14:55:44 <mniip> this is so nice and perfectly matching up
14:55:46 <monochrom> koz_: yes
14:55:51 <ThatTreeOverTher> koz_, you need to specify the type, yes
15:00:59 <mniip> monochrom, one thing gets in the way though,
15:01:11 <mniip> 'Parser b' makes up a Category
15:01:16 <mniip> but without a newtype I can't define an instance
15:01:54 <TommyC> Hello, I'm wondering if there's a way to bootstrap ghc? I'm passing the --enable-unregistered flag to the configure script but despite the effort, the configure script still checks for a GHC.
15:02:20 * hackagebot typelevel 1.0.4 - Useful type level operations (type families and related operators).  https://hackage.haskell.org/package/typelevel-1.0.4 (danilo2)
15:03:26 <geekosaur> unregisterised expects to be built/run on a supported platform. you use the unregisterised version to compile ghc again, and the output is ANSI C you can put on the target
15:04:08 <geekosaur> ...if your target supports llvm, it's a bit easier to use the llvm backend and capture the LLVM IR instead; this is how ARM cross-compile is done
15:05:26 <TommyC> Ah, I see.
15:05:35 <TommyC> Interesting way of bootstrapping.
15:10:35 <dgpratt> is the following plain lambda calculus or something else (presumably related to LC)?: Lfix X. 1 + A*X
15:12:47 <monochrom> it is sum type, product type, and least fixed point for data
15:13:07 <monochrom> it is not in plain lambda calculus
15:13:34 <dgpratt> monochrom, what is the underlying representation called?
15:13:42 <dgpratt> I mean the syntax, I think
15:13:57 <monochrom> it is just math notation
15:14:06 <dgpratt> ok
15:14:26 <dgpratt> is Lfix being defined or referenced here?
15:15:07 <monochrom> the author is supposed to say "it means least fixed point for recursive data". and that's all the author needs to say.
15:15:29 <monochrom> it is referenced
15:15:38 <dgpratt> ah, ok
15:16:32 <monochrom> you are looking at a math notation for "data You_Name_It = U | P A You_Name_It"
15:16:59 <dgpratt> that's what I guessed
15:17:25 <dgpratt> same as the Haskell list type, yeah?
15:17:28 <monochrom> yes
15:17:33 <dgpratt> isomorphic to
15:17:45 <monochrom> or maybe ML list
15:18:09 <monochrom> it is very probable that the author wants just finite lists
15:18:09 <dgpratt> so X. is the type var?
15:18:18 <dgpratt> right
15:18:27 <monochrom> X is a dummy variable for anonymous recursion
15:18:37 <dgpratt> hm
15:18:49 <dgpratt> oh
15:19:23 <monochrom> if I have to write recursive code, without giving it a name, I may write like: fix (\x -> 4 : x)
15:19:28 <dgpratt> 1 is equivalent to [] ?
15:19:33 <dgpratt> right
15:19:34 <monochrom> now imagine doing that to types.
15:19:52 <dgpratt> gotcha
15:21:16 <dgpratt> so is A the element type (so to speak)?
15:21:21 <monochrom> yes
15:21:30 <dgpratt> ah
15:21:37 <dgpratt> very helpful, thanks monochrom
15:21:43 <monochrom> you're welcome
15:27:21 * hackagebot scalpel 0.3.0.1 - A high level web scraping library for Haskell.  https://hackage.haskell.org/package/scalpel-0.3.0.1 (fimad)
15:41:04 <adas> im writing a csv parsing application for work and I need a way to gracefully handle the situation where a certain header may not be present or the CSV file itself might be non-parsable. What is the most canonical way to handle such situations?
15:42:05 <adas> I have the Either type to make the type system aware of different failure cases. Maybe is also available. And there is also just throwing exceptions.
15:42:17 <adas> But is there a recommended way to handle such errors?
15:43:32 <Cale> adas: You listed the main things. Which to use depends on whether you want to make sure that the exceptional case is handled (or whether you'd expect that to be more common).
15:44:17 <Cale> adas: The main difference with throwing an exception is that it's easy to neglect to catch it if you'd prefer the program just to end.
15:46:19 <adas> the code I'm writing for work, might eventually replace what we have at the moment if all goes smoothly, so I'm conscious of writing a professional haskell application from the very beginning. That's why I wasn't sure which method to use. 
15:47:27 <adas> but I agree, i guess it depends on what I want the application to do in such situations
15:48:32 <StoneToad> note to keep in mind about maybe: nothing can't carry any extra data, so you can't easily return an error with information like line numbers or such in the simple use cases
15:48:32 <dmj> adas: using exceptions to model program flow is probably a bad idea. Catching them and converting them to a pure representation (i.e. Either) is probably more sane. But tossing around "undefined"s and "error" here and there is not a good idea. It's ok to use "error" as long as that code never gets called, heh
15:50:56 <adas> dmj: thanks for the clarification. this was also helpful -> https://programmers.stackexchange.com/questions/252977/cleanest-way-to-report-errors-in-haskell
15:58:51 <exio4> basically error is meant to a situation that should never happen and if it ever happened, the best you can do is to throw an exception, because something is really wrong
16:02:34 <exio4> s/throw an exception/crash the whole program/
16:05:36 <exio4> ohh! I think I know!
16:05:40 <nshepperd_> for a general csv parsing application, I would not use exceptions/error
16:05:54 <exio4> oops, wrong channel, sowwy <_>
16:06:29 <nshepperd_> since 'the file is unparseable' is sort of within the anticipated scenarios
16:07:09 <nshepperd_> Either is probably the best here
16:07:49 <hodapp> https://izbicki.me/blog/fast-nearest-neighbor-queries-in-haskell.html well that's interesting to note
16:07:53 <nshepperd_> although you could argue for using IOExceptions on the grounds that you already need to handle 'the file doesn't exist' and such there...
16:07:56 <hodapp> ...after I already chose to do my machine learning work in R :P
16:11:20 <nshepperd_> whoa, there a magic function that does inlining
16:11:40 <nshepperd_> that's surprising but obvious in hindsight
16:13:05 <hpc> nshepperd_: eh?
16:13:31 <nshepperd_> mentioned from that page https://hackage.haskell.org/package/base-4.8.0.0/docs/GHC-Exts.html#v:inline
16:14:20 <nshepperd_> 'inline f' hints ghc to expand out f at that call site
16:15:41 <hpc> funny that there's no source for inline
16:16:10 <hpc> not even something like {-# GHC defineInlineHere #-} or whatever
16:17:23 * hackagebot octane 0.2.1 - A Rocket League replay parser.  https://hackage.haskell.org/package/octane-0.2.1 (fozworth)
16:17:37 <MarcelineVQ> hpc: https://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/GHC-Magic.html
16:17:47 <hpc> oh sweet
16:17:53 <dustmote> can i write a function that does division on Num a ?
16:18:01 <dustmote> I guess not because it doesn't have (/)
16:18:28 <Cale> dustmote: that's right, there are things which can be made instances of Num, such as square matrices, for which division doesn't make much sense
16:18:33 <Cale> You want Fractional
16:18:40 <dustmote> hmm..
16:20:36 <tesrty> I'm trying to solve exercise 3... I'm fairly sure I'm going bananas. How for off am I?: http://i.imgur.com/Gb3K31q.png
16:20:46 <tesrty> ...am I bananas?
16:20:56 <MarcelineVQ> we're all mad, here
16:20:57 <dustmote> i was trying to write something like (a -> (a, b)) where `a` was Num and `b` was the result of a division.. i guess this isn't possible, and i have to put a Fractional constraint on a...
16:20:59 * tesrty is bananas and going to bed.
16:21:19 <tesrty> I hope to get to your collective level some day MarcelineVQ 
16:21:56 <tesrty> oh and 'data Rose a = a :> [Rose a]'
16:22:23 <tesrty> I'm not sure if that's a known thing.
16:23:21 <tesrty> Oh yes, rose tree is a thing. I am definitely bananas now.
16:23:57 <nshepperd_> madness is a gift
16:24:16 <tesrty> hey, nshepperd_ ! I remember you.
16:24:29 <tesrty> You know lots of things. How bananas is my foldable rose?
16:25:24 <nshepperd_> if your instance had foldr there instead of fmap, it would be golden
16:25:39 <ThatTreeOverTher> https://www.google.com/search?tbm=isch&q=foldable+rose
16:25:48 <Cale> tesrty: uh, it looks like you're leaving out indentation in places where it looks like you'd want it
16:25:52 <nshepperd_> except of course that won't work because foldr is the function you are trying to write
16:25:57 <nshepperd_> sorta
16:26:02 <Cale> tesrty: The body of an instance should be indented.
16:26:32 <nshepperd_> tesrty: you're going to have to deconstruct the rose tree there
16:27:13 <tesrty> How did I miss that..
16:27:15 <nshepperd_> fold (m :> ms) = {-# wheee #-}
16:27:19 <tesrty> Its definetly too late!
16:27:34 <tesrty> let me get on those indents though. See what ghc spits out.
16:29:49 <jlddklj> hello
16:30:34 <dmj> jlddklj: hey!
16:31:30 <tesrty> No ThatTreeOverTher, it's an exercise for learning. Thanks though.
16:32:31 <ThatTreeOverTher> hahaha
16:34:02 <tesrty> So nshepperd_ the point of the 'fold' the creator of my exercise for 'Foldable []' is not to demonstrate how to write a 'fold' because he cheats and uses 'foldr'. No, it's so I can fold a '[]'?
16:39:28 <nshepperd_> oh, I see
16:40:01 <tesrty> Sorry. That was meant to be written as a question.
16:40:34 <tesrty> I do not know. But I understand your remark about not using foldr when writing and instance of Foldable, yet the TA did it for '[]'
16:41:18 <nshepperd_> well, he might have been using the monomorphic List foldr there
16:41:24 <monochrom> I don't think it is useful to guess the TA's intention
16:41:25 <tesrty> So I'm asking if perhaps my rhetoric seems plausible
16:41:44 <tesrty> hey! monochrom, you're back.
16:41:55 <nshepperd_> 'foldr :: (a -> b -> b) -> b -> [a] -> b' what used to be in the Prelude until 7.10
16:42:04 <monochrom> instead, if you expand the definition of []'s foldr, you may or may not get inspired for how to do it for Rose.
16:42:07 <acertain> say I have `data Foo = Foo {-# UNPACK #-} !Int` and `f :: Int# -> r`, does `g (Foo a) = f a` cause allocation?
16:42:25 <nshepperd_> but of course there isn't an existing foldr to lean on for Rose, because it's a new data type
16:42:49 <monochrom> but one thing is for sure. []'s fold will help you finish Rose's fold, i.e., you can simply call []'s fold and some point
16:44:24 <tesrty> I understand your intention with the Sum test. But still fail to understand how I could apply its binary operation to combine with the next Rose value.
16:44:36 <tesrty> Okay. I'll go look there for inspiration.
16:46:01 <monochrom> there will be recursion
16:46:28 <monochrom> there will be blood, too, but this is already implied by recursion
16:46:33 <proxical> ohk
16:46:40 <tesrty> haha alright. Maybe it's too late for recursion though.
16:46:44 <tesrty> right haha.
16:51:29 <RandomUser42> I have a quick question about names for things: You'd call ‚ÄúInteger -> String‚Äù a type. But what kind of thing would you say this is: ‚ÄúEq a => a -> [a] -> a‚Äù. The quantification means it isn't a type, it's more than that. I have some ideas about the best name, but I wondered if other people have a good name, especially for beginners who may need to have help leaning where they can and can't put ‚ÄúEq a =>‚Äù.
16:53:21 <geekosaur> (Eq a) is a type constraint, and ‚ÄúEq a => a -> [a] -> a‚Äù could be called a constrained type. you can actually use those in most places, but in data declarations you may need an existential type to "hold" the constraint
16:54:55 <montanonic> RandomUser42: You can put `Eq a =>` anywhere you want, but you've constrained the type of that function to require that all `a` values have instances of the `Eq` typeclass
16:55:25 <montanonic> RandomUser42: the reason you would constrain the type in the first place is so that you can use the equality method in your function definition
16:55:30 <montanonic> @ty (==)
16:55:31 <lambdabot> Eq a => a -> a -> Bool
16:56:21 <montanonic> RandomUser42: some type `a` might not be a member of the equality typeclass, and if it wasn't, using `==` would make no sense; hence you need to add that constraint when you use an operation like `==`
16:58:54 <tesrty> Alright. I give up. Bedtime.
16:59:18 <tesrty> I get the feeling I'm stuck because my monoid is bad. How true is it monochrom? http://i.imgur.com/XaMwcwK.png
16:59:28 <jle`> RandomUser42: i would call `Eq a => a -> [a] -> a` a type.  call (a -> [a] -> a) a type, too
16:59:35 <jle`> maybe you can think about it as, you can add a constraint to a type to make a new type
16:59:41 <Bruuuuno> http://lpaste.net/151389 is there any situation that trace will not output?
17:00:00 <jle`> for example, if i had (a -> [a] -> a), i can add an Eq a constraint, to yield Eq a => (a -> [a] -> a)
17:00:05 <jle`> and i can also add another constriant, say, Num
17:00:17 <jle`> and i can have: Num a => (Eq a => (a -> [a] -> a))
17:00:34 <jle`> and if i wanted Show too, Show a => (Num a => (Eq a => (a -> [a] -> a)))
17:00:41 <RandomUser42> My point is that I want beginners to understand that you can say [Integer] and [Int -> Double] but not [Num a => a], for example.
17:02:00 <johnw> RandomUser42: with ImpredicativeTypes, you could have such a list btw
17:02:11 <montanonic> RandomUser42: oh I misread "especially for beginners" as "especially for *a* beginner"
17:02:27 <jle`> RandomUser42: ah...maybe the essential thing here is how to constrain type variables
17:02:41 <snhmib> hello, i'm writing a ffi binding for a library. the library has to be called with open, and returns an int handle, then you do stuff with the handle and it returns data, then you call close on this handle
17:02:55 <jle`> maybe you can say that constraints have to all appear at the "top"?
17:03:01 <jle`> when using type variables
17:03:03 <snhmib> but in order to put a finalizer on this int, do i have to put it in a ptr?
17:03:33 <jle`> there's a subtle thing because i think that when you say [Num a => a], you really want to mean Num a => [a], and not [forall a. Num a => a]
17:03:38 <snhmib> and then peek at this pointer everytime i call the library to get the handle?
17:03:42 <jle`> (which is what ImpredicativeTypes would give you)
17:04:13 <jle`> the distinction is that for [a], the `a` type variable is scoped to the top level, so the constraint has to be specified at the top level, too
17:05:12 <jle`> if you want to give a true formal description, you can use explicit qualification
17:05:25 <jle`> but for 'beginners' you can probaly just say that constraints ahve to be at hte front
17:06:24 <RandomUser42> jle: For now I'm saying constraints have to be on ‚Äúfunction signatures‚Äù; I'm just wondering how bad/distasteful a simplification that is.
17:06:40 <jle`> what about forall a. Num a => [a] ?
17:06:58 <jle`> :t [1,2,3]
17:06:59 <lambdabot> Num t => [t]
17:07:04 <jle`> that's not a function, but it has a constraint
17:07:14 <dgpratt> trying to interpret the following: Lfix X. F X  =  All X. (F X -> X) -> X.
17:07:38 <jle`> i'd probably say that all constraints have to appear at the top level, which is pretty much true until you talk about RankN types
17:07:42 <RandomUser42> These are people who are on day one of Haskell, where is's like, this is a list, this is a pattern.  ‚ÄúNo, you can't put 1 + n in a pattern‚Äù, etc.
17:07:48 <dgpratt> I *think* this is a definition for Lfix, but not certain of that
17:08:14 <dgpratt> I also would guess that this may have some relation to a Fix type that I've seen before
17:08:15 <jle`> what syntax is that?
17:08:28 <jle`> it's not quite Haskell
17:08:40 <dgpratt> jle`, addressed to me? math, apparently
17:09:03 <RandomUser42> I can't help having them see typeclasses, but I want a simple story so that they have a place to hang the things they see.
17:09:08 <dgpratt> it also reminds me of something I came across a while ago about...algebras
17:09:09 <jle`> RandomUser42: i think "move constraints to the top level" is good enough
17:09:28 <jle`> well, that would be the road i'd take, at least
17:09:46 <dgpratt> monochrom, can you help me interpret that definition?
17:09:51 <RandomUser42> BTW, the strange pattern I gave would be valid in Miranda (a functional language that was a precursor of Haskell).
17:10:13 <jle`> interesting; would it be interpreted as [forall a. Num a => a], or forall a. Num a => [a] 
17:10:15 <jle`> ?
17:10:18 <geekosaur> dgpratt, where did you find that?
17:10:37 <dgpratt> geekosaur, http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt
17:11:44 <geekosaur> ok, that's what I thought. it's an ASCII representationof lambda calculus notation
17:12:34 * hackagebot existential 0.1.0.0 - A library for existential types  https://hackage.haskell.org/package/existential-0.1.0.0 (SimonHudon)
17:13:03 <geekosaur> it's not the one that I usually see, but I think I get this variant
17:13:05 <andrewhc> hi, anyone else having issues with stack atm? 
17:14:18 <dgpratt> geekosaur, is "X." akin to "\X ->" ?
17:14:47 <geekosaur> that'ss standard lambda calculus notation, yes
17:14:57 <dgpratt> ok
17:15:00 <geekosaur> well, somewhat compressed.
17:15:08 <dgpratt> so what of "F X"?
17:15:19 <dgpratt> what are F and X?
17:15:31 <geekosaur> foo = Œªx. ...
17:15:53 <geekosaur> equivalent to Haskell foo = \x -> ...
17:17:29 <dgpratt> maybe I should be interpreting "=" in this context as "is the same as" ?
17:18:09 * geekosaur not actually sure what the (Lfix X.) is. feels almost like a type constraint, but that can't be right
17:18:33 <geekosaur> would have to go see what polymorphic lambda calculus notation looks like, as compared to STLC or untyped LC
17:18:43 <dgpratt> hmm
17:19:20 <dgpratt> maybe #math would know? but even if, their explanations tend to go way over my head
17:19:51 <geekosaur> (polymorphic lambda calculus is called out in the second paragraph "Adding recursive types...")
17:20:47 <geekosaur> cs stackexchange maybe
17:22:27 <nshepperd_> dgpratt: this seems to be a theorem about Lfix
17:22:46 <RandomUser42> To answer my own question, the Haskell report calls the lhs part of the => syntax a "context".
17:23:07 <geekosaur> yes. ghc calls it a constraint, and expands it a bit
17:23:18 <geekosaur> with, for example, type equality x ~ y
17:23:47 <nshepperd_> dgpratt: or, yes, I guess it could be a definition
17:23:51 <RandomUser42> (And it isn't part of the definition's idea of what a type is, syntactically, which is where I was coming from originally.  It explicitly spells out the specific places you can add a context to a type.)
17:25:25 <geekosaur> this may actually get you in trouble if you hew too closely to the Report, since ghc diverges from it in a number of ways ad in fact ghc 7.10 and 8.1rc are not entirely compatible with the Report
17:26:27 <geekosaur> (technically, the Report describes a language based on a Hindley-Milner type system augmented with type classes; ghc implements the System Fc type system
17:26:57 <nshepperd_> dgpratt: it's saying that the least fix point of F (which is Lfix X. F X), is equivalent to 'forall x. (F x -> x) -> x'
17:27:21 <dgpratt> nshepperd_, ah, ok
17:27:34 * hackagebot publicsuffix 0.20160201 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20160201 (wereHamster)
17:27:39 <koz_> If I wanna 'modify and rewrap' an Either, is there a neater way than this? either (Left . fromString . show) (Right . map (map fromString))
17:28:35 <RandomUser42> geekosaur: I suspect we won't get deep enough into the weeds for that to be a problem (?).
17:29:09 <RandomUser42> (We'll be _using_ Haskell, but not to huge depth.)
17:29:12 <geekosaur> well, aside from the fact that a lot of Haskellers you run into will talk about constraints instead of contexts, and such
17:29:24 <RandomUser42> Yeah, I've changed my terminology.
17:30:05 <RandomUser42> (I have a footnote to the report's terminology now, but maybe that's just whining at this point.)
17:30:42 <RandomUser42> The footnote reads: The term ‚Äúconstraint‚Äù is common usage in the Haskell community and used by our compiler, GHC, but the Haskell standard actually uses different terminology, using the word ‚Äúcontext‚Äù instead of ‚Äúconstraint‚Äù.
17:31:07 <geekosaur> I think it's worth noting, ertainly
17:31:28 <geekosaur> hopefully nobody then runs off to see what;s going on and runs into ConstraintKinds or something >.>
17:32:12 <nshepperd_> it's always good to have footnotes clarifying terminology
17:32:20 <koz_> If I wanna 'modify and rewrap' an Either, is there a neater way than this? either (Left . fromString . show) (Right . map (map fromString))
17:33:20 <geekosaur> koz_, I don't think so. ifthe modifications were the same on both sides, there might be something Bimap-ish, but as is, no
17:33:49 <koz_> geekosaur: Figures. Oh well.
17:34:24 <nshepperd_> no, bimap would do that
17:34:29 <Gurkenglas> :t bimap (fromString . show) ((map . map) fromString) -- koz_
17:34:30 <lambdabot> (Show a, IsString b, IsString b1, Bifunctor p) => p a [[String]] -> p b [[b1]]
17:35:23 <koz_> nshepperd_: Oh, kewl!
17:35:43 <nshepperd_> there's also the arrow combinator but those are uncool now
17:35:46 <Gurkenglas> That's what I get for making sure on hackage that Either has a bimap instance
17:36:09 <koz_> That is *incredibly* awesome.
17:36:13 <koz_> Haskell just continues to impress.
17:37:31 <koz_> And Bimap stuff is wired into classy-prelude, even better.
17:39:39 <naudiz> what's the easiest way to get an Arbitrary instance of a simple data type like data Foo = Foo | Bar | Baz
17:43:37 <Shockk> naudiz: I just looked up Arbitrary and stuff and it looks like you could easily write an instance like:
17:44:11 <Shockk> naudiz: instance Arbitrary Foo where arbitrary = arbitraryBoundedEnum
17:44:48 <Shockk> for that Foo would need an instance of Bounded and Enum which can both be derived I believe
17:45:10 <naudiz> Shockk: I don't want Foo to be an instance of Enum, in this case.
17:45:37 <demize> Then something like `instance Arbitrary Foo where arbitrary = choose (Foo, Bar, Baz)` should work.
17:45:37 <naudiz> thing is, that there will be more constructors later on and having to add them by hand might be a problem
17:45:42 <KaneTW> is there a (simple) way to get a Show instance for singletons?
17:45:59 <naudiz> demize: ^
17:46:17 <demize> naudiz: I mean, if it's not enumerable, and you don't want to add them manually.. What do you expect it to do?
17:46:48 <Shockk> arbitraryBoundedEnum doesn't require you to add each constructor by hand, arbitraryBoundedEnum :: (Bounded a, Enum a) => Gen a
17:46:59 <Shockk> and the minimal complete definition of Arbitrary is arbitrary :: Gen a
17:47:11 <demize> Shockk: He's was talking about the alternative.
17:47:16 <Shockk> ohh
17:47:35 <naudiz> demize: I just want to check against it, but there is no order in it. Like, for example data Colour = Red | Blue | Green
17:47:44 <Shockk> oh, I understand
17:47:57 <Shockk> there's also arbitraryBoundedRandom :: (Bounded a, Random a) => Gen a
17:48:34 <adas> does a newtype only have to have a single constructor with a single field? is it possible to have a newtype with a single constructor and no field?
17:48:40 <Shockk> ermm, I'm unsure if Random is the right or wrong thing to use, I've not used it before
17:49:15 <pavonia> adas: Yes. No.
17:49:19 <naudiz> I don't really think it is.
17:49:21 <demize> Shockk: It should work, but then he'd have to implement random for it instead.
17:49:27 <geekosaur> I don't see a generics mechanism for quickcheck
17:49:38 <adas> thanks for the cllarification
17:49:40 <naudiz> demize: that's what I was thinking, too.
17:50:20 <naudiz> Looks like I really have to add them by hand. Damn... but thank you.
17:50:33 <geekosaur> adas, not sure what you're asking there tbh. a newtype wraps another type and expects to wrap and unwrap values; as such, you'd be expected to provide somewhere to put a value
17:51:25 <geekosaur> it might be arguable that newtype should work for `data A` with no values; that probably should be brought up in haskell-cafe or maybe glasgow-haskell-users
17:52:01 <adas> thanks for teh reasoning. that makes sense. the "why" of it makes a lot of sense.
17:52:28 <koz_> OK, I need some advice. I have two Either Foo [Bar]. I need to return an Either Foo [Bar], where I wanna zip together the [Bar]s, then flatten them, but only if both Eithers are 'Right [Bar]'. I am ... not sure how to write this.
17:52:45 <koz_> If one of them is a Left Foo, then I just wanna return it as-is.
17:52:58 <KaneTW> goldfire: is singletons supposed to generate Show instances for each Sing data instance? a "deriving instance Show (Sing (s :: MyType))" seems to work well, so I'm not sure why it doesn't do it automatically
17:53:23 <Shockk> koz_: Either has a Monad instance, so you can chain the two expressions together like for example:
17:54:10 <Shockk> expression which might result in (Left Foo) >> additional stuff
17:54:19 <Shockk> not accurate haskell code ^
17:54:31 <RandomUser42> Thanks folks. I'm outta here.
17:54:35 <koz_> Shockk: Does the Monad instance for Either just propagate Lefts on failure?
17:54:45 <Shockk> it does
17:54:47 <koz_> Kinda how the Maybe one propagates Nothing?
17:54:51 <koz_> OK, that's pretty cool.
17:54:52 <Shockk> yep
17:54:56 <Shockk> it is, I like it
17:55:05 <koz_> I guess I'm just not sure how I would do the 'zipping' part.
17:55:14 <barrucadu> Use applicatives!
17:55:20 <barrucadu> > zip <$> Right [1,2,3] <*> Right [4,5,6]
17:55:21 <Shockk> Left x >>= _ = Left x
17:55:21 <lambdabot>  Right [(1,4),(2,5),(3,6)]
17:55:27 <barrucadu> > zip <$> Right [1,2,3] <*> Left "Oops!"
17:55:28 <lambdabot>  Left "Oops!"
17:55:36 <koz_> Wow that's awesome.
17:55:52 <koz_> Please tell me what <$> and <*> here mean?
17:56:00 <Shockk> :t (<$>)
17:56:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:56:01 <KaneTW> <$> is fmap
17:56:01 <barrucadu> <$> is just an infux version of fmap
17:56:04 <KaneTW> <*> is ap
17:56:10 <KaneTW> well, not the monadic ap
17:56:11 <barrucadu> :t (<*>)
17:56:12 <koz_> :t (<*>)
17:56:12 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:56:13 <KaneTW> :t (<*>)
17:56:13 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:56:14 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:56:15 <KaneTW> lol
17:56:15 <Shockk> lol
17:56:16 <barrucadu> heh
17:56:17 <koz_> lol
17:56:26 <Shockk> that's hilarious
17:56:38 <koz_> It is. barrucadu: Thank you for the suggestion, that's excellent.
17:59:14 <KaneTW> yay! show works! WireKnxPacket (KnxPacket SToServer SFresh SResetConnection H[])
18:00:29 <scshunt> I need to learn more category theory
18:01:10 <Shockk> scshunt: don't we all
18:03:30 <koz_> OK, I'm not sure what I'm missing in this case: http://paste.rel4tion.org/230
18:04:18 <scshunt> koz_: <$> lifts it through IO, but then you're still working on Eithers
18:04:39 <koz_> scshunt: So I have to do it again?
18:04:50 <koz_> I guess I'm not sure how to do that.
18:05:25 <pavonia> You can liftA2, I guess
18:05:37 <scshunt> yeah
18:05:45 <scshunt> using non-infix operators may end up being best here
18:05:50 <koz_> scshunt: OK.
18:06:10 <koz_> liftA2 is perfect, thanks pavonia!
18:07:55 <pavonia> No problem
18:09:08 <koz_> crossOver = liftA2 (liftA2 (zipWith (++)))
18:09:16 <koz_> That was ... much easier than expected.
18:09:29 <koz_> Now to rewrite it without so many parens.
18:25:48 <lachrimae> hey folks, do you have advice on how to go about making sense of library documentation?
18:25:56 <lachrimae> It's hard for me to know where to start
18:27:56 <koz_> My code is now littered with 'map $ bimap'.
18:28:31 <Bruuuuno> koz_ zipWith and liftA2 are actually the same thing
18:28:41 <Shockk> @ty (map $ bimap)
18:28:42 <lambdabot> Bifunctor p => [a -> b] -> [(c -> d) -> p a c -> p b d]
18:28:47 <Majiir> koz_, write an alias for it and call it bibimbap
18:28:52 <Cale> lachrimae: Generally start by figuring out what types of things seem like they should be good to have. Then figure out how to obtain values of those types.
18:28:57 <koz_> Majiir: I was thinking that very same thing.
18:29:15 <Cale> lachrimae: and just follow the trail of which types of arguments you need to fill in
18:35:19 <koz_> OK, Majiir, I apparently suck at refactoring. Could you suggest how I would write the bibimbap function here? http://paste.rel4tion.org/231
18:35:34 <koz_> Other code improvement suggestions are warmly welcome as well.
18:38:54 <koz_> I apologise in advance if my code is horrendous.
18:39:28 <Majiir> I'm probably much better at coming up with silly Korean-food-inspired names than actually writing the code, but I'm taking a look to see if I can understand what you're doing :-)
18:40:00 <koz_> Majiir: Thanks - I approve of the Korean-food-inspired name as well, which is why I wanted help writing it so that the compiler won't kneecap me.
18:40:04 <dramforever> koz_: You seem to be using IO (Either Text _) much more often, consider using EitherT?
18:41:23 <koz_> dramforever: What's EitherT?
18:41:30 <lachrimae> \leave
18:41:36 <koz_> Oh wait, monad transformer?
18:42:35 <Majiir> I agree with that suggestion, but I'm also wondering why you're using IO everywhere
18:43:04 <koz_> Majiir: Mostly because I suck at monads, and this made more sense to me.
18:43:12 <koz_> s/monads/IO
18:44:02 <Majiir> koz_ I think that would clean things up a *lot*, since you won't have to be mapping over IO all the time; you extract the values from the IO monad, then work with them all you want, and the whole computation is wrapped up in an IO monad you can use as main
18:44:07 <dramforever> koz_: yeah, you should avoid IO, exactly because you suck at IO
18:44:19 <dramforever> s/you/we all/ , if you wish
18:44:26 <koz_> dramforever: Nah, I'm fine taking criticism.
18:44:40 <koz_> Because frankly, I'm new to Haskell, and ego doesn't mix well with programming well.
18:45:02 <Majiir> I think 'flatten' is a perfect example to work through, since fixing that will fix a lot. It really shouldn't have the type it has...it should just be a [[Text]] -> Text
18:45:28 <Majiir> You're not doing any IO, so it shouldn't have IO in the type, and you're neither generating nor handling errors, so it shouldn't have Either in the type
18:46:01 <koz_> So basically, only the first function should have Either, main should have IO, and everything else shouldn't do either of those things?
18:46:17 <dramforever> koz_: no, that was some horrible joking... Majiir's points are much better
18:46:36 <koz_> dramforever: Nah, it's cool. I don't mind being told I suck - it's a sign I can do better. :)
18:46:49 <Majiir> koz_, more or less, yeah. Ideally you can isolate your IO and error-handling in as few places as possible, and let the bulk of your program be pure, error-free computations.
18:46:57 <dramforever> koz_: no no no, you don't suck, IO sucks
18:47:03 <dramforever> just... disregard that
18:47:11 <koz_> Majiir: OK, that makes sense.
18:47:15 <koz_> dramforever: Disregard what? :P
18:47:29 <dramforever> my messages about IO
18:47:38 * hackagebot hOpenPGP 2.4.2 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.4.2 (ClintAdams)
18:47:45 <koz_> Majiir: I guess I have trouble getting the IO part (especially in main) to do what I want.
18:48:01 <koz_> But I'll try and rewrite it in a less silly manner.
18:48:03 <Majiir> koz_, are you familiar with do-notation, and how it translates to let and bind expressions?
18:48:30 <koz_> Majiir: Sorta? It's something I've read and read and read about, and nothing ever seems to translate to actually doing it. Every time I try, I get tangled in the type system.
18:48:40 <koz_> I mean, I got *Maybe* down, and I was damn proud there already...
18:49:19 <Majiir> Okay, so let's work through it. Let me know if this is correct: It looks like your program is reading a couple CSV files, doing some computations on the data, and then outputting either a string or an error message?
18:49:35 <koz_> Correct.
18:50:12 <Majiir> So that means your main function (or *any* function involving IO) should be no more complex than my previous message, since I was able to describe in totality the way your program interacts with the real world.
18:51:19 <koz_> Majiir: I *get* that point from a theoretical standpoint. It's just whenever I try to translate anything IO into code, it stops making sense extremely quickly.
18:51:41 <koz_> And here it's even worse, because I'm dealing with an IO containing an Either.
18:53:30 <Majiir> I think using EitherT would help, but I suggest solving the IO problems first and leaving error handling a bit messy for a moment
18:53:44 <koz_> Majiir: Alrighty, I'll give it a try and post the results.
18:53:59 <dramforever> koz_: You seem to have done a satisfactory job doing IO, judging from the paste you gave us. The problem is not putting things into IO. It's getting things out of it
18:54:25 <Majiir> A quick start is something like this: http://lpaste.net/151395
18:54:45 <Majiir> (Disclaimer: This isn't "good" code)
18:55:08 <Majiir> If you can rewrite your program to fit *that* main method, you'll be most of the way there
18:55:49 <Majiir> It will force your 'something' to *not* have IO in the type, since 'orig' and 'addl' will be non-IO types, and you can't putStrLn an IO
18:56:50 <koz_> I was thinking of doing exactly this.
19:00:08 <Majiir> koz_: You could also translate your existing main method directly, and then fix the types of your other functions
19:01:02 <Majiir> http://lpaste.net/151396
19:01:31 <Majiir> Looks basically the same :-)
19:02:13 <Majiir> D'oh, I forgot the 'do'
19:03:28 <koz_> OK, new and improved: http://paste.rel4tion.org/232
19:04:16 <koz_> It's much nicer without all that IO.
19:04:23 <koz_> But now, I need to do the same without all the Either.
19:04:33 <Majiir> Awesome. Now we get to figure out the Eithers, which is starting to get to the edge of my abilities :D
19:05:03 <koz_> I mean, ideally, we wanna just do all the either stuff in one shot and end up with a Text.
19:05:10 <koz_> The last op in the do-block is kinda a hint.
19:05:20 <koz_> I'm just ... unsure how.
19:05:28 <Majiir> Yep, but we also have errors from two sources, since you load two different files
19:05:35 <koz_> Yeah.
19:05:52 <pavonia> koz_: Btw, bimap id f == fmap f
19:06:11 <koz_> pavonia: Thanks - that simplifies things.
19:06:54 <Majiir> I think using EitherT is the right idea, so we would have an EitherT Text (IO ()) Text ... I think?
19:07:34 <dramforever> @unmtl EitherT Text IO Text
19:07:35 <lambdabot> EitherT Text IO Text
19:07:37 <Majiir> Sorry, no parens after IO
19:07:39 <Shockk> wouldn't it just be EitherT Text IO Text?
19:07:45 <Majiir> Yes, thanks
19:07:46 <dramforever> @unmtl ExceptT Text IO Text
19:07:46 <lambdabot> ExceptT Text IO Text
19:08:10 <dramforever> no... just Majiir I thought we were supposed to use ExceptT these days, got any idea?
19:08:29 <Majiir> dramforever, no idea, I'm a newb
19:09:01 <koz_> I need to read up on these, because I have no clue how to use them... :(
19:09:33 <Majiir> Ah yes, ExceptT is what we want
19:10:00 <Majiir> koz_, the transformers let you stack monads, in this case stacking ExceptT over an IO computation, so we get the convenience of error handling along with our IO actions
19:10:56 <koz_> I have no clue how to use one of those...
19:11:09 <Majiir> Me neither! Let's look at the types https://hackage.haskell.org/package/transformers-0.4.3.0/docs/Control-Monad-Trans-Except.html
19:11:40 <koz_> Well, the inner monad in this case is IO, I assume?
19:11:43 <Majiir> except and runExcept are inverses, so it looks like we want to bottle up a bunch of Eithers in order to form an Except, and then run our Except in order to get one Either out in the end
19:11:52 <Majiir> IO is generally the inner monad, yes
19:12:03 <koz_> And the exception type is Text.
19:13:35 <Majiir> Yep, and your 'success' type is Text as well, so we'll have an ExceptT Text IO Text, so let's just pretend we've already written that and figure out what main looks like
19:14:43 <Majiir> Looking at runExceptT and substituting our type, it looks like it would be an "ExceptT Text IO Text -> IO (Either Text Text)"
19:15:15 <Majiir> So basically turning a bunch of possibly-erroring IO actions into an IO action which makes us handle errors just once
19:15:28 <koz_> Which is exactly what we want, OK.
19:15:45 <Majiir> So maybe we're here: http://lpaste.net/151401
19:16:11 <koz_> I assume bibimbap does all our processing which could error out?
19:17:08 <Majiir> Yes, and as long as we use it right, it will take care of all our cascading error handling. It still has IO in the type, though, so we need to take care of that there and have yet another function for our pure computations
19:18:35 <Majiir> ExceptT is itself a monad, so we can use do-notation. Every expression needs to involve an ExceptT, so we should look again at the docs to find the type we want
19:19:21 <Majiir> ...or just use liftIO.
19:19:26 <Majiir> :t liftIO
19:19:27 <lambdabot> MonadIO m => IO a -> m a
19:20:14 <koz_> OK... I'm sorry, but I'm really not following.
19:20:39 <Majiir> Sorry :D I'm trying to piece this together myself since I've read about it but not done it yet. Let me see if I can explain this.
19:20:55 <koz_> Alrighty. Thanks very much for doing this, by the way!
19:21:26 <Majiir> So, we would LIKE to do something like this, but it won't quite work: http://lpaste.net/151402
19:22:20 <Majiir> main is going to let us handle all our errors in one way, and japchae is going to do our actual text processing. bibimbap is going to let us perform some actions that might error, *AND* it will take care of cascading the errors should something go wrong.
19:22:52 <Majiir> To make the types more clear, and to show why this current code doesn't work, let's look at 'additional' and 'original'
19:23:29 <Majiir> The type of bibimbap is ExceptT Text IO Text, so we can look at how do-notation would translate and what it means for our types
19:23:51 <Majiir> @undo do addl <- additional; orig <- original; return (japchae addl orig)
19:23:51 <lambdabot> additional >>= \ addl -> original >>= \ orig -> return (japchae addl orig)
19:24:03 <Majiir> :t (>>=)
19:24:04 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:24:34 <mniip> looks like liftM2 japchae
19:24:42 * mniip hides
19:24:47 <Majiir> 'additional' MUST be a 'm a', which in this case is ExceptT Text IO Text
19:25:07 <Majiir> But before, we had 'additional' reading a file, and it had the type: IO (Either Text Text)
19:25:21 <koz_> Yup, I follow.
19:25:30 <Majiir> So we want some way of performing an IO action which could error, and converting that into an erroring action which happens to be IO...if that makes sense
19:25:50 <koz_> It *does* make sense.
19:26:25 <Majiir> So what we're looking for in the docs is: m (Either e a) -> ExceptT e m a
19:27:01 <Shockk> that's actually the type that the ExceptT constructor takes, Majiir 
19:27:03 <koz_> Majiir: Isn't that just the constructor?
19:27:06 <koz_> Goddamn ninjas.
19:27:09 <Shockk> :D
19:27:27 <Majiir> It.....is! :D
19:27:38 <Majiir> I was missing that, thank you
19:27:43 <koz_> It's well-hidden.
19:27:45 <Majiir> I wonder if lambdabot has it
19:27:48 <Majiir> :t ExceptT
19:27:50 <lambdabot> m (Either e a) -> ExceptT e m a
19:27:54 <Majiir> Perfect
19:28:33 <koz_> So... now what?
19:28:43 <Majiir> We use it: http://lpaste.net/151402
19:28:54 <Majiir> But 'additional' and 'original' are undefined, so let's copy in your code
19:28:59 <koz_> What is that seriously it?
19:29:03 <koz_> OK, *that* I get.
19:29:35 <Majiir> http://lpaste.net/151402
19:29:41 <Shockk> I may be incorrect with this explanationon this but I'm going to guess based on having used ExceptT and StateT and others before:
19:29:44 <Shockk> explanation*
19:30:47 <Majiir> Note that 'return' in this case is wrapping up an ordinary, non-monadic result (Text) into a monadic type, as a successful computation.
19:31:06 <Shockk> a monad transformer, take this example with ExceptT and IO as the inner monad, is under the IO monad but it's basically doing what you were doing by using Either to convey an error context
19:32:20 <Majiir> koz_, you should now be able to get rid of all the bimaps and liftA2s and implement japchae (which you should really rename along with bibimbap, much as I love them....)
19:32:21 <Shockk> any IO actions that you want to do within this new monad, it has the additional context from Either, so you would need to wrap that IO action in Either as well
19:32:25 <Shockk> that's what liftIO does
19:32:40 <Shockk> I might have used incorrect terminology there but I hope that gets the idea across
19:32:52 <koz_> Majiir: I'm doing this right now.
19:32:59 <Majiir> Yep, so that's where I was going with liftIO and that might be more clear to other readers of the code, but it's a bit harder to see *why* liftIO works
19:33:17 <Majiir> I'll wait for the completed paste for that
19:34:28 <koz_> Majiir: OK, apparently, I can't import Control.Monad.Except, because it's hidden behind mtl.
19:34:35 <Shockk> Majiir: let's say you want to putStrLn "hello world" within ExceptT ErrMsg IO
19:34:55 <Shockk> er, let me re-say that
19:35:29 <Shockk> let's say you want to print that in an action of type: IO (Either ErrMsg ())
19:35:46 <Majiir> Shockk, I just meant that I can see why it would be hard to follow the MonadIO instance and find out that liftIO is the type you'd want after all
19:36:01 <Majiir> You sort of have to 'know' that liftIO is how you do stuff inside monad transformers
19:36:09 <jle`> liftIO isn't restricted to just monad tranformers
19:36:10 <Shockk> ohh I see
19:36:19 <jle`> so maybe restricting the idea to monad transformers is what makes ti confusing
19:36:27 <jle`> liftIO itself has nothing to do with transformers :O
19:36:43 <jle`> but i guess that only proves your point, Majiir 
19:36:51 <Shockk> liftIO is just part of the.. I forgot the name, MonadIO typeclass?
19:37:12 <Shockk> :i liftIO
19:37:19 <Majiir> jle`, it's just very useful for transformers involving IO, and in this case would make the code more generic
19:38:04 <Majiir> The ExceptT constructor *does* have the right type, but so does liftIO, and the latter is more commonly seen in that role
19:38:14 <jle`> yeah, liftIO makes more sense when you want to lift an IO action
19:38:59 <koz_> OK, why can't I actually import the module with the ExceptT constructor in it? Apparently, it's hidden by mtl.
19:39:24 <Clint> koz_: do you have mtl as one of your build-depends?
19:39:28 <jle`> koz_: import Control.Monad.Trans.Except
19:39:47 <koz_> Clint: It's part of classy-prelude I think, so yes. jle`: Thanks.
19:40:11 <koz_> jle`: Hidden by transformers...
19:40:32 <koz_> Maybe classy-prelude has its own way of doing this.
19:40:32 <Shockk> koz_: I don't think classy-prelude re-exports the module though
19:40:53 <Shockk> it might make use of mtl itself but mtl would still be hidden to you
19:41:08 <koz_> Well, it suggests classy-prelude does this some other way.
19:41:23 <koz_> I get the suspicion this is involved: http://hackage.haskell.org/package/classy-prelude-0.12.5/docs/ClassyPrelude.html#g:26
19:41:51 <jle`> koz_: it's actually unrelated
19:41:59 <koz_> jle`: OK, my bad then.
19:42:02 <jle`> Except/ExceptT is unrelated to exceptions in haskell, so that's kind of weird
19:42:05 <jle`> unfortunate naming, heh
19:42:16 <jle`> i think classy-prelude exports the typeclasses for doing these things polymorphically
19:42:23 <jle`> but for finding the specific instances, you're on your own
19:42:40 <jle`> it's like Prelude/base offers the Functor typeclass, so you can use fmap
19:42:42 <koz_> jle`: I still need some way to construct the damn thing though. I guess it's likely hidden in mono-traversable someplace?
19:42:58 <jle`> but if you want to use it on X data type, then you have to find the package that offers X data type
19:43:20 <jle`> for example, MyObscureFunctorInMyPackage has a Functor instance, but requiring 'base' doesn't mean MyObscureFunctor is in scope
19:43:42 <Majiir> koz_, I expect you'll be able to make the code more polymorphic after a few iterations, so you might be able to use regular Prelude for a while and switch back?
19:43:53 <Majiir> More....generic, I should say
19:43:58 <jle`> classy-prelude offers the typeclasses, but finding the instances that you want to use is something separate
19:44:04 <koz_> Does this have anything to do with it? http://hackage.haskell.org/package/basic-prelude-0.5.0/docs/CorePrelude.html#g:20
19:44:22 <jle`> just because you defined a typeclass instance doesn't mean every instance on hackage is available
19:44:54 <jle`> *import a typeclass
19:45:07 <jle`> just becuase i imported Data.Functor doen't mean i can now use every Functor instance on hackage :)
19:45:11 <koz_> jle`: That makes sense, but I'm still a bit high-and-dry. Majiir: I really wanna learn how to do this in classy-prelude, because I really like classy-prelude. If that takes me a bit longer, that's OK.
19:45:24 <jle`> classy-prelude gives you the typeclasses, but you need import the packages that provide the instances
19:45:25 <Shockk> could the Primitive typeclass be related?
19:45:28 <johnathangrey> hello
19:45:29 <jle`> so, transformers offer an instance
19:45:30 <jle`> and so does mtl
19:45:31 <Shockk> "Class of monads which can perform primitive state-transformer actions"
19:46:25 <jle`> hm, classy-prelude doesn't even export MonadError, i guess
19:46:49 <jle`> just use mtl or transformers :)
19:47:19 <johnathangrey> so how is everyone this fine evening
19:47:29 <jle`> johnathangrey: hi! doing well, thanks :)
19:47:32 <koz_> I think I'll ask the maintainer about this as well - I'm sure there's something obvious I'm missing.
19:47:44 <johnathangrey> thats good !
19:47:52 <Shockk> oh it does have a section "Transformers" in the docs actually but only includes Identity and the MonadReader class from the looks of it
19:49:12 <johnathangrey> exit
19:49:13 <jle`> koz_: classy-prelude doesn't export MonadError or ExceptT, but, it isn't meant to export everything useful
19:49:23 <jle`> koz_: it' okay to use other packages if those other packages are useful
19:49:41 <jle`> i think the point of classy-prelude is to provide the things that are already in Prelude, but more polymorphic/based on typeclasses
19:49:43 <koz_> jle`: Oh, I understand that. I'm just curious if this is because I'm not using something, or because I'm not *seeing* something.
19:49:59 <jle`> what's your original problem?
19:50:25 <koz_> Let me just link you: http://paste.rel4tion.org/233
19:50:42 <jle`> what's the error?
19:50:48 <koz_> Essentially, Majiir told me that I should localize my Either usage, and ExceptT was the suggested method.
19:51:09 <koz_> The error is that I get a 'hiding' error if I try to import anywhere where ExceptT lives.
19:51:23 <Majiir> jle`, the error comes from reading a file
19:51:24 <koz_> Since Majiir's suggestion for my code involved calling ExceptT's constructor.
19:51:49 <Majiir> (which we shall replace with liftIO because reasons)
19:51:58 <Majiir> If getting the ExceptT constructor is an issue, we could go ahead with that now
19:52:09 <koz_> Well, if we can use liftIO, then that's fine - I have *that* wired in.
19:52:20 <jle`> if you want to use ExceptT, then you have add the package into your includes
19:52:36 <koz_> Well, I'd like to see the liftIO method too.
19:52:41 <jle`> if you want to use a type that a packge offers, you have to include that package in your includes :)
19:52:45 <jle`> liftIO, too
19:53:14 <koz_> jle`: liftIO I already have via classy-prelude, since it's in core-prelude.
19:53:30 <jle`> mk.  so, add transformers or mtl into your build-includes
19:53:48 <jle`> but, i think ExceptT might be a bit overkill here
19:53:48 <koz_> Majiir: Could you show me the liftIO version of what you just told me about?
19:53:55 <koz_> jle`: What would you suggest?
19:54:05 <jle`> the problem is this, right?
19:54:07 <jle`> crossOver x y = (zipWith (++)) <$> x <*> y
19:54:22 <jle`> you can just do crossOver x y = liftA2 (zipWith (++)) <$> x <*> y
19:54:34 <jle`> or liftA2 (liftA2 (zipWith (++)) x y
19:54:46 <jle`> (liftA2 . liftA2) (zipWith (++)) x y
19:54:47 <jle`> etc.
19:55:09 <koz_> jle`: I used multi-lifts of this form before. I was told that it's better not to have IO and Either everywhere in my functions unless they were actually doing IO or had failure states.
19:55:35 <Majiir> jle`, koz_ is reading from two files -- each is an IO (Either a b) -- and wants to handle those errors elegantly while also doing some pure computations on the b
19:56:08 <Majiir> The toy code I've been working with looks like http://lpaste.net/151407
19:56:27 <Majiir> It's a little overkill but it's a learning experience as well
19:56:52 <Majiir> koz_, the code is pretty simple, just using liftIO instead of ExceptT, but it helps to know why that works
19:57:23 <jle`> koz_: in that case, you can write crossOver :: Applicative f => f [a] -> f [a] -> f [a], if you want to abstract that way
19:57:25 <jle`> *away
19:57:33 <jle`> and then yeah, use ExcepT to give the right Applicative instance
19:57:55 <jle`> if you want maximum abtractness, that is
19:58:06 <Majiir> jle`, you've lost me, but I think we'll work up to there heh
19:58:07 <jle`> (which isn't always necessary in practice)
19:58:35 <Majiir> koz_: Recall we wanted a way to perform those parseCSVIntoText actions within the context of our ExceptT, and for that we needed something of type: IO (Either Text Text) -> ExceptT Text IO Text
19:58:42 <koz_> Also, Majiir, parseCSVIntoText returns Either Text [[Text]], but from what I can tell, your code seems to believe it's Either Text Text.
19:58:47 <jle`> koz_: ignoreFirst n = fmap (drop n), so it might not even be worth writing out as a function
19:58:50 <Majiir> Ah, my bad, I'll correct that
19:59:10 <koz_> jle`: This is an artifact of earlier iterations which were more complicated.
19:59:24 <Majiir> koz_ http://lpaste.net/151407
19:59:26 <jle`> ah okay.
19:59:44 <koz_> Majiir: OK, *that* makes more sense. I was wondering if I was missing something...
19:59:50 <Majiir> koz_ we used ExceptT's constructor before, but it turns out that liftIO can assume the same type.
19:59:54 <Majiir> :t ExceptT
19:59:55 <lambdabot> m (Either e a) -> ExceptT e m a
19:59:58 <Majiir> :t liftIO
19:59:59 <lambdabot> MonadIO m => IO a -> m a
20:00:23 <Majiir> They don't look the same, but filling in the variables, it works. If you look at the ExceptT documentation, you'll see there's a MonadIO instance
20:00:44 <Majiir> The instance is: MonadIO m => MonadIO (ExceptT e m)
20:01:09 <jle`> you could even make bibimbap :: (MonadError Text m, MonadIO m) => m Text
20:01:16 <jle`> hm
20:01:21 <jle`> nvm
20:03:34 <koz_> Majiir: Yup, I see it.
20:03:37 <Majiir> IO itself is a MonadIO, which is what that 'm' becomes: IO (ExceptT e IO a) -> ExceptT e IO a
20:03:42 <koz_> :t runExceptT
20:03:44 <lambdabot> ExceptT e m a -> m (Either e a)
20:04:34 <koz_> OK, apparently I don't have that thing either.
20:04:38 <Majiir> Conceptually, we're wrapping up some erroring IO operations, performing some computations, and then unwrapping them again. The wrapping lets us deal with errors without manually bimapping as you were.
20:05:11 <Majiir> You'll need *some* function which does this for you, and I don't know if ClassyPrelude has one
20:05:46 <koz_> Majiir: Probably - if it has liftIO, it's gotta have something similar to runExceptT surely...
20:06:01 <Majiir> Yep, because it has to know somehow what it's *doing* with all this lifted IO
20:07:37 <jle`> classy-prelude doesn't re-export runExceptT, becuase it doesn't export ExceptT
20:07:50 <jle`> liftIO is in general useful, and not just for ExceptT, so that makes sense
20:08:05 <jle`> it's like, classy-prelude exports fmap, but it doesn't export all Functor instances on hackage :)
20:08:44 <koz_> :t runExceptT
20:08:45 <lambdabot> ExceptT e m a -> m (Either e a)
20:09:03 <jle`> require a pcakage that exports runExceptT
20:09:11 <jle`> there are two canonical ones -- mtl, and transformers
20:09:28 <jle`> they both export ExceptT
20:10:06 <koz_> jle`: Where in mtl can I find runExceptT?
20:10:25 <Majiir> koz_, it should be in Control.Monad.Trans.Except which we were looking at earlier
20:10:34 <jle`> in mtl, it's in Control.Monad.Except
20:10:39 <jle`> in transformers, it's in Control.Monad.Trans.Except
20:10:44 <Majiir> Ah there you go
20:11:20 <koz_> OK, both times, GHC complains that it's hidden by its respective parent package.
20:11:43 <jle`> you have to add them to your build-depends
20:11:45 <jle`> in your cabal file
20:11:49 <koz_> jle`: OK.
20:13:30 <dustmote> where should one start debugging the memory use of a haskell program? threadscope?
20:13:46 <dustmote> passing the optimization flag?
20:13:50 <ReinH> dustmote: GHC's profiling tools
20:15:10 <dustmote> ReinH: ty! https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
20:15:29 <Majiir> koz_, I'll note that parseCSVIntoText is still mixing your computations with error handling and IO; you can extract that into a CSV -> [[Text]], I think, although you're also modifying the error type.....may want to let the ParseError type propogate all the way down!
20:16:00 <Majiir> Specifically it's textify which is mixing things
20:16:58 <dmj> @def somestring' :: String = "some string"
20:16:59 <lambdabot>  Defined.
20:17:09 <dmj> ^ never knew that syntax existed
20:17:51 <geekosaur> it's actually @let
20:17:57 <geekosaur> editcorrection ftw?
20:18:06 <dmj> geekosaur: but it can be used top level
20:18:21 <jle`> hm, well, you can do let (x :: String) = "string" using ScopedTypeVariables
20:18:33 <jle`> i would think that just that at the top level would be ok too
20:18:37 <Majiir> It's actually just a lambdabot thing...
20:18:38 <geekosaur> o, I see. that's ScopedTypeVariables yes
20:18:39 <MarcelineVQ> @define foo' = "butts"
20:18:40 <lambdabot>  Defined.
20:18:52 <Majiir> @let doesn't actually put 'let' in the source file
20:18:52 <lambdabot>  Parse failed: TemplateHaskell is not enabled
20:19:01 <geekosaur> no, @define/@let is LB, wasn;t clear the meant the :: String = part
20:19:09 <nitrix> Is there a way to specify a GHCI main-is in a project' cabal file?
20:19:11 <Majiir> See here: https://github.com/lambdabot/lambdabot/blob/master/lambdabot-haskell-plugins/src/Lambdabot/Plugin/Haskell/Eval.hs#L33
20:19:13 <dmj> works w/o STV too I think
20:19:14 <nitrix> Instead of --main-is name ?
20:19:49 <geekosaur> nitrix: I don't think so as such, need a ghci-options: --main-is ...
20:19:58 <dmj> geekosaur: think it works w/o STV too
20:20:06 <geekosaur> interesting
20:20:33 <geekosaur> not sure that should... at least per the Report. of course ghc has pretty well trashed the Report of late >.>
20:21:17 <MarcelineVQ> geekosaur, dmj: I had to turn on sct to reproduce in ghci
20:21:27 <MarcelineVQ> *stv
20:22:36 <dmj> MarcelineVQ: works w/o STV for me, under stack ghci. The pragma isn't on
20:22:59 <Majiir> koz_, something else worth noting is that a 'CSV' is already a [[String]]! https://hackage.haskell.org/package/csv-0.1.2/docs/Text-CSV.html
20:23:13 <dmj> MarcelineVQ: oh nevermind, it was on
20:23:21 <dmj> had to :unset
20:23:54 <jle`> yeah, it's more commonly seen for things like
20:24:00 <jle`> x :: Double <- getRandomIO
20:24:10 <jle`> instead of x <- randomIO :: IO Double
20:24:56 <koz_> OK, I have no idea wtf is going on now: http://paste.rel4tion.org/234
20:24:59 <jle`> that's the typical usage i think
20:25:13 <dmj> guess I was just surprised to see someone use it at the top level of a module
20:25:53 <dmj> @def Just zz = Just 6
20:25:54 <lambdabot>  Defined.
20:25:58 <dmj> > zz
20:25:59 <jle`> koz_: try, import Control.Monad.Except(ExceptT(..)) ?
20:25:59 <lambdabot>  6
20:26:30 <koz_> jle`: That removes the errors.
20:26:44 <koz_> I really only need runExceptT though.
20:30:27 <koz_> Majiir: The code you gave me is distinctly unhappy with the last line of bibimbap.
20:30:42 <koz_> Because apparently orig and addl are Eithers, and it expects [[Text]]s.
20:31:11 <Majiir> I should get this up and running on my end, I probably made some stupid mistake
20:31:28 <jle`> hm
20:31:37 <Majiir> It shouldn't complain about return changing the type; monads are good at that
20:31:41 <koz_> Shouldn't I be doing something monad-related to orig and addl instead of just passing-them as-are?
20:31:41 <jle`> i think, the way you have it written, you should write ExceptT instad of liftIO
20:32:12 <Majiir> The '<-' syntax extracts plain values from monads
20:32:24 <jle`> koz_: ExceptT :: IO (Either e a) -> ExceptT e IO a
20:32:28 <Majiir> @undo do x <- foo; return x
20:32:28 <lambdabot> foo >>= \ x -> return x
20:32:29 <koz_> Majiir: TO any level of depth?
20:32:32 <jle`> liftIO :: IO a -> ExceptT e IO a
20:32:42 <Majiir> koz_, not to any level, which is what lifting is for
20:32:44 <jle`> you dont have an IO a, you have an IO (Either e a)
20:32:49 <jle`> so ExceptT is appropriate here, not liftIO
20:33:01 <koz_> OK.
20:33:04 <Majiir> Ahhhhh okay duh.
20:34:01 <jle`> liftIO :: IO a -> ExceptT a IO a, and ExceptT :: IO (Either e a) -> ExceptT e IO a...oh, and also handy, return :: a -> ExceptT e IO a
20:34:13 <jle`> three different natural transformations for every occasion :D
20:34:27 <Majiir> Yep, already using return here as well
20:34:55 <Majiir> koz_ I hope you saved the original, this is going to be a fun before-and-after once you go through a few more iterations
20:35:10 <jle`> those are the three main natural transformations you work with when using monad transformers in general, w/ io and stuff
20:38:16 <Majiir> I'll keep that in mind. I need to get around to a non-trivial project to get more practice with this stuff.
20:44:35 <koz_> OK, I am *utterly* baffled now, and nothing makes any sense anymore.
20:44:40 <koz_> I think I'll take a break for now.
20:45:35 <Majiir> koz_, I suspect some of that is my fault :D Toss me the latest sometime, and I'll have something to play with. majiir@nabaal.net
20:45:49 <koz_> Majiir: I'm basically going back to 'last sane iteration'.
20:45:54 <Majiir> (or PM and my bouncer will catch it)
20:46:00 <koz_> It has Eithers all over the place, but it's easier than IO Eithers...
20:46:55 <koz_> Majiir: Alrighty, I'll send it your way.
20:51:41 <koz_> What do you need to add to your Cabal file to tell 'cabal clean' to remove some specified additional files?
20:56:45 <pavonia> koz_: extra-tmp-files
20:56:55 <koz_> pavonia: Thanks!
20:58:00 <k3r9> getting an error in my Maybe / Foldable implementation http://lpaste.net/151411
20:58:10 <k3r9> not sure why though
20:58:20 <radens> I want a guard which says 'my string does not begin with one of these five letters'
20:58:33 <k3r9> I know foldr/foldl/foldMap is redundant this is just for practice..
20:58:45 <radens> like func l in "abcde" = ...
20:58:53 <k3r9> any ideas?
20:59:33 <pavonia> k3r9: You have to define all equations for one function in a single block
21:00:18 <pavonia> i.e. first define foldl, then foldr (or vice versa), but not interspersed
21:00:24 <k3r9> pavonia oh i had no idea the order mattered thanks
21:00:31 <koz_> pavonia: Do you know of a library that can output tables into some form I could compile into a nice PDF?
21:00:33 <k3r9> pavanoia any particular reason or is that just a quirk?
21:00:41 <koz_> I have a whole bunch of data I wanna tabulate, but I don't wanna do it by hand.
21:01:03 <k3r9> koz_ what do you mean by hand, defining types?
21:01:11 <pavonia> k3r9: Order matters when evaluating the defintion
21:01:28 <pavonia> koz_: HaTeX maybe
21:01:32 <koz_> k3r9: What I mean is that I don't wanna have to retype all my results so that I can tabulate them.
21:01:37 <koz_> pavonia: Oooh, interesting. Thanks!
21:04:02 <pavonia> radens: Do you want to check that only for the first letter?
21:04:58 <radens> pavonia: yes
21:05:18 <pavonia> You can use elem then
21:05:21 <pavonia> :t elem
21:05:22 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
21:05:37 <radens> Actually I basically want to match it against the regex [\w\d_]
21:05:57 <radens> which is a little unwieldy if I use elem
21:06:20 <pavonia> \d is digit, \w is whitespace?
21:06:29 <pavonia> :t isDigit
21:06:30 <lambdabot> Char -> Bool
21:06:35 <pavonia> :t isSpace
21:06:36 <lambdabot> Char -> Bool
21:07:00 <c_wraith> pavonia: in pcre? \w is word, \s is space
21:07:20 <pavonia> What means "word" here?
21:07:24 <radens> pavonia: \w is word
21:07:28 <radens> a-zA-Z
21:07:36 <pavonia> Oh
21:09:37 <pavonia> > filter (\c -> c == '_' || (isAscii c && isAlphaNum c))  ['\0' .. '\255']
21:09:38 <lambdabot>  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"
21:09:46 <pavonia> radens: ^
21:10:22 <lisbeth> I messed up my path for stack somehow
21:10:23 <radens> pavonia: so I should use a case statement instead of a guard?
21:10:37 <pavonia> No, why?
21:11:33 <pavonia> You can make the right-hand side of that lambda function your guard
21:12:32 <radens> how do you do that and only use c once? Or can you use a single element many times in a guard?
21:12:59 <pavonia> Sure, you can use it as many times as you want
21:13:36 <radens> oh okay
21:13:36 <pavonia> It just has to occur only once in the pattern
21:14:56 <k3r9> trying to implement my own sum. the type signature is sum :: (Num a, Foldable t) => t a -> a
21:15:10 <k3r9> why doesn't "a" also have to be monoid?
21:15:55 <k3r9> nevermind got it to work  now
21:16:11 <dmj> k3r9: why would it be in this case
21:16:27 <dmj> there answer is no, but it could be
21:16:45 <k3r9> dmj nevermind I guess using Num it's okay to just use 0 in place of mempty
21:17:40 <k3r9> I think there's a typo in bitemyapp s book though. his type signature for the exercise is sum :: Num a => t a -> a
21:17:47 * hackagebot metadata 0.3.0.0 - metadata library for semantic web  https://hackage.haskell.org/package/metadata-0.3.0.0 (KatsutoshiItoh)
21:17:55 <k3r9> need to also add the Foldable constraint on t
21:21:35 <k3r9> dmj for a foldMap impelementation of Sum, you would need a monoid constraint right?
21:22:29 <dmj> yes, Sum is a monoid
21:22:47 * hackagebot json-ast 0.2 - Universal JSON AST datastructure  https://hackage.haskell.org/package/json-ast-0.2 (NikitaVolkov)
21:23:18 <dmj> > mconcat [ Sum 1, Sum 1 ]
21:23:19 <lambdabot>  Sum {getSum = 2}
21:24:22 <c_wraith> Does Sum have a Num instance?
21:24:31 <c_wraith> > mconcat [Sum 1, 2]
21:24:32 <lambdabot>  Sum {getSum = 3}
21:24:36 <c_wraith> Hey, it does
21:24:38 <dmj> yea
21:26:29 <shachaf> [Sum 1, 2, watch / me]
21:33:38 <k3r9> dmj sorry i was imprecise.
21:33:57 <k3r9> dmj to say if I want to implement sum, the function, in terms of a foldMap
21:34:23 <k3r9> dmj I would need to add a monoid constraint, right?
21:47:50 * hackagebot Gifcurry 0.1.0.2 - Create animated GIFs, overlaid with optional text, from movies.  https://hackage.haskell.org/package/Gifcurry-0.1.0.2 (lettier)
21:55:19 <radens> Is there a better way to do ["a
21:55:22 <radens> oops
21:55:39 <radens> Is there a better way to do ["a", "b", "c"] ++ ["d"]?
21:56:30 <pavonia> Other than writing is a s single list?
21:56:50 <pavonia> > map pure "abcd"
21:56:52 <lambdabot>      No instance for (Show (f0 Char))
21:56:52 <lambdabot>        arising from a use of ‚Äòshow_M192133058339583568810540‚Äô
21:56:52 <lambdabot>      The type variable ‚Äòf0‚Äô is ambiguous
21:57:04 <pavonia> > map pure "abcd" :: [String]
21:57:05 <lambdabot>  ["a","b","c","d"]
21:57:44 <radens> pavonia: I actually have: newState (tkns++[[s]]) ss
21:57:52 <mniip> build your list from the other end?
21:58:18 <radens> mniip: thought of that, but then I would have to reverse it.
21:58:37 <pavonia> Maybe you want to use Seq instead?
22:01:45 <radens> pavonia: this? I don't get how that could help me. https://wiki.haskell.org/Seq
22:02:50 <pavonia> Err no, I meant https://hackage.haskell.org/package/containers-0.4.0.0/docs/Data-Sequence.html
22:03:07 <pavonia> It provides a data structure for efficient appening elements
22:04:28 <radens> oh so it's a deque and not a singly linked list under the hood.
22:04:50 <radens> err a deque not a stack
22:19:32 <dfeuer> Anyone seen copumpkin around here recently?
22:28:17 <Bruuuuno> does someone use reactive banana here?
22:32:46 <jle`> Bruuuuno: if you have a question, ask it :D
22:33:32 <Bruuuuno> okay, so I come from elm, which have a pretty good built-in frp implementation
22:33:51 <Bruuuuno> it have a foldp function, that is defined like the haskell fold
22:34:21 <Bruuuuno> I was wondering how to have that in reactive-banana since it have no fold and is not foldable
22:35:50 <Cale> Bruuuuno: accumE :: MonadMoment m => a -> Event (a -> a) -> m (Event a) is pretty close
22:38:01 <Bruuuuno> I don't really get how it's close, let's say you have an Event (or behaviour) that output a number, how would you get the sum with accumE?
22:38:38 <Cale> foldp f z e = accumE z (fmap f e)
22:39:20 <Cale> It has to be an Event of course
22:39:29 <Cale> A behaviour, you can't tell when it changes
22:40:46 <Bruuuuno> that's nice, thanks :)
22:42:52 <Cale> In Reflex, there's  foldDyn :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> b) -> b -> Event t a -> m (Dynamic t b)
22:45:23 <Bruuuuno> why isn't the return type an Event too?
22:45:30 <Cale> A Dynamic is a combination of a discretely-changing behaviour and an event which lets you know precisely when the behaviour is changing (firing with the new value), so you could just project out the event from that if that's all you wanted.
22:46:21 <Cale> The reason I suppose is that the implementation basically needs to make that behaviour as well anyway, so it might as well produce a Dynamic.
22:50:07 <jle`> wish there was an unpromoted version of Nat we could use
22:50:10 <Cale> In Reflex, if you only ever work with Events, working your way up from the primitives, then your system will be essentially stateless -- the values in the output events will have to be computed as some pure function from the values in the input events. Behaviours are what allows memory to persist through time. Of course, it's easy to implement  foldEvent :: (a -> b -> b) -> b -> Event t a -> m (Event t b)  but internal
22:50:10 <Cale> ly it'll look much like foldDyn.
22:50:12 <jle`> that would be the bomb
22:50:19 <exio4> jle`: Natural?
22:50:24 <exio4> jle`: or what do you mean?
22:50:26 <jle`> yes, but that worked with Nat
22:50:32 <jle`> right now i have data Foo = F Nat
22:50:44 <jle`> using DataKinds to get F :: Nat -> Foo at the type level
22:50:49 <jle`> but it'd be cool to be able to use it at the value level too
22:52:11 <jle`> i don't see any practical benefit
22:52:18 <jle`> but it would still be the bomb dot com
22:52:53 * hackagebot psc-ide 0.6.0 - Language support for the PureScript programming language  https://hackage.haskell.org/package/psc-ide-0.6.0 (kritzcreek)
22:54:41 <Bruuuuno> so Behaviours are like Elm's signal?
22:59:49 <naudiz> where should I implement Arbitrary instances? In the file where I define my type or in the file where my tests take place?
23:01:13 <kadoban> naudiz: I usually implement them in the testing code, mostly because I find it kind of odd that my library would otherwise have to depend on quickcheck
23:02:03 <naudiz> kadoban: makes sense, thanks
23:04:38 <phadej> otoh, your library users might like them as well
23:05:14 <kadoban> A good point
23:08:59 <naudiz> well, it's an executable, so users might not want them at all
23:12:54 <iamboris> 8.4^2  + 8.4 + 7
23:14:00 <iamboris> why when i declare a function  p x = x^2 + x + 7 and call it with 8.4 it results 85.96000000000001?
23:14:33 <liste> > 8.4^2 + 8.4 + 7
23:14:35 <lambdabot>  85.96000000000001
23:14:52 <thimoteus> > 0.3 - 0.2
23:14:54 <lambdabot>  9.999999999999998e-2
23:15:02 <thimoteus> https://en.wikipedia.org/wiki/Floating_point
23:15:04 <liste> welcome to the world of floating point numbers
23:15:37 <pavonia> > 8.4^2 + 8.4 + 7 :: Rational
23:15:39 <lambdabot>  2149 % 25
23:15:43 <thimoteus> dammit pavonia stole my idea
23:15:54 <iamboris> so  i cant tell you explain me everything but could send me a link to learn this?
23:16:04 <thimoteus> i just did ...
23:16:11 <iamboris> oh sorry
23:16:12 <iamboris> :(
23:16:17 <iamboris> could you forgive me? 
23:16:29 <thimoteus> maybe you want the #Accuracy problems section
23:17:39 <iamboris> toRational 8.4
23:17:52 <iamboris> 4728779608739021 % 562949953421312 getting interesting :D
23:23:17 <pavonia> When I start GHCi, it loads the parsec and network packages. Any ideas what could be causing this?
23:23:44 <liste> pavonia is your .ghci empty ?
23:23:49 <liste> (or non-existing)
23:23:59 <pavonia> Hhm no
23:24:00 <echo-area> How are orders of types defined?
23:24:54 <pavonia> liste: Ah, that's it!
23:25:31 <quchen> echo-area: Types don't have orders. What do you mean with "orders"?
23:25:38 <pavonia> And network depends on parsec, so makes all sense
23:28:19 <dfeuer> Is there any decent library of indexed functor stuff around? I found the indexed package, but it's pretty small, and since it doesn't use PolyKinds it's no direct good for my current playing.
23:28:47 <Bruuuuno> earlier, Cale told me that foldp f z e = accumE z (fmap f e). It's been 30 min I'm trying to figure out how this compile haha, any tips?
23:29:03 <Bruuuuno> :t accumE
23:29:04 <lambdabot>     Not in scope: ‚ÄòaccumE‚Äô
23:29:05 <lambdabot>     Perhaps you meant ‚Äòaccum‚Äô (imported from Data.Array)
23:29:16 <Bruuuuno> accumE :: MonadMoment m => a -> Event (a -> a) -> m (Event a)
23:29:26 <echo-area> quchen: Quoting /Unfolding Abstract Datatypes/: "Given a suitable operation F on types, the least fixpoint Œº(F) of F is the smallest type X such that F(X) ~ X."  "Smallest" here seems to imply orders of types
23:36:32 <jle`> dfeuer: type-combinators has Functor1, Functor2, Functor3, etc.
23:37:17 <jle`> oh nvm it just has Functor1
23:37:34 <jle`> oh, and it only lifts natural transformations
23:37:35 <jle`> nvm
23:39:09 <dfeuer> jle`, yeah, that looks potentially useful but not relevant.
23:54:04 <dfeuer> jle`, I'm thinking about ideas like  newtype IxBackwards f i j a = IxBackwards (f j i a), and mapping, folding, and traversing classes for type-aligned sequences. See http://stackoverflow.com/questions/35123930/how-should-i-traverse-type-aligned-sequences
