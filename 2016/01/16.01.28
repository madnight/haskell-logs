00:02:43 <portu> thank you for links, not so far I find project Immutable data structures for python  https://pypi.python.org/pypi/pyrsistent/ is here anyone who use it?
00:06:06 <newlifer> immutable in python? 0_o
00:07:02 <shanemikel> portu: you probably don't want to go that route.. python's support for important fp features shines in closures, and functions as values, other than that, python is acually one of the better OOP languages out there
00:08:24 <shanemikel> but you're never going to have efficient recursion.. so don't fight the paradigm.. with those features it's probably possible to achieve clean and terse currying though
00:08:42 <newlifer> availability  of classes isn't yet OOP...
00:08:44 <shanemikel> (and decorators)
00:10:06 <shanemikel> newlifer: python's not OOP?
00:10:22 <newlifer> i think so
00:10:42 <EvanR> arent tuples immutable in python
00:11:02 <shanemikel> yes EvanR
00:11:14 <EvanR> no true OOP language _
00:11:19 <newlifer> ...there not encapsulation
00:11:43 <EvanR> that would make ruby not OOP
00:11:49 <newlifer> Yep
00:11:51 <EvanR> which proves False
00:11:56 <newlifer> And C++ as well
00:12:14 <newlifer> Nope, this does not proves
00:12:44 <EvanR> the problem with dropping the subscript on the at least 19 different OOPs
00:14:46 <adam___> hey is there a way to clean this up http://lpaste.net/151062
00:14:54 <shanemikel> so, what's the most important defining trait of fp, then (similarly OOP)
00:15:18 <adam___> shanemikel: you could argue its working with immutable data structures and managed effects I guess
00:17:39 <shanemikel> adam___: more simply?
00:17:42 <fr33domlover> EvanR, the FromJSON instance is an orphan instance, I get a warning :P not sure what's better: live with the warning (or make GHC not warn), or use a newtype
00:18:13 <adam___> shanemikel: yeah I wanna rewrite the function in a simpler way
00:18:14 <shanemikel> adam___: yeah, are  you sure you're not looking for guard?
00:18:14 <EvanR> shanemikel: FP is kind of not any more well defined than OOP
00:18:53 <EvanR> fr33domlover: orphan schmorphan ;)
00:19:52 <adam___> like this? http://lpaste.net/151062
00:20:04 <adam___> not sure how you could use a guard
00:20:16 <EvanR> shanemikel: you can be like "declarative language" is the defining aspect
00:20:25 <adam___> its not really a conditional is it?
00:20:35 <EvanR> and argue about it
00:21:14 <monadc> I am trying to complete the monad challenges I have got to http://mightybyte.github.io/monad-challenges/pages/ex2-4.html where it asks you to complete queryGreek2 like the previous queryGreek but only using link and chain. My attempt so far is http://lpaste.net/150894 I don't understand how to nest lambdas so that val is in scope to two lambdas ?
00:22:53 <adam___> monadc look into these two operators
00:22:56 <adam___> :t (>>=)
00:22:57 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:23:00 <adam___> :t (>=>)
00:23:01 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
00:23:16 <adam___> or I guess I should back up
00:23:28 <adam___> how well do you understand monads?
00:23:44 <monadc> the challenge uses a custom prelude where these are not available
00:23:56 <shanemikel> where's EitherT coming from.. is it yours, std, or a lib?  It looks like you're trying to abstract over monads
00:24:19 <adam___> shanemikel: thats mine, I guess I should provide the full context
00:25:03 <adam___> http://lpaste.net/151062
00:25:14 <adam___> monadc: this line doesnt make any sense :(
00:25:15 <adam___> queryGreek2 d s  =  link  (lookupMay s d) (\val ->link val headMay)(\val ->  link val tailMay) (\tm -> link tm maximumMay) 
00:25:32 <adam___> link takes two arguments (Maybe a, and (a -> Maybe b))
00:25:39 <adam___> you provide it with 4
00:26:19 <monadc> I know I can't get it to work the way I want to, I don't understand how to nest the lambdas to achieve the previous function
00:27:18 <monadc> how do I get the result from lookupMay to two lambdas ?
00:28:01 <EvanR> with a let
00:28:07 <adam___> lookupMay seems to take a -> [(a,b)] -> Maybe b
00:28:10 <adam___> it doenst take lambdas
00:28:40 <adam___> you can bind the result of a function call with a let
00:29:01 <adam___> and then somehow combine multiple variables together using another function
00:29:05 <EvanR> if it takes a -> [(a,b)] -> Maybe b, one way to make one is with a lambda ;)
00:29:35 <mjrosenb> so, is it possible to export a type synonym for a datatype such that I can pattern match on the bound type, without exporting the full type?
00:29:41 <monadc> ok I'll try that then I'll try that
00:30:02 <mjrosenb> ugh, I bet this goes back to something I know haskell can't do, which is allow deconstruction without construction
00:30:16 * mjrosenb gives up, and exports the full datatype :-(
00:30:21 <EvanR> mjrosenb: so pattern synonyms
00:30:37 <EvanR> https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms
00:33:50 <mjrosenb> strange.. I've used those before, for FFI things; I don't remember them being that powerful.
00:35:49 <fr33domlover> I'd like to parse a JSON object field using one of 2 parsers, i.e. try one and if it fails try the other. The naive way I know is like this: Left <$> o .: "name" <|> Right <%> o .: "name"
00:36:04 <fr33domlover> But that has duplication which I'm not sure how or whether I can avoid
00:36:24 <fr33domlover> i meab <$> there, not <%> :P
00:36:27 <fr33domlover> *mean
00:37:15 <fr33domlover> aeson already provides a FromJSON instance of Either but it does something entirely different
00:37:57 <EvanR> mjrosenb: you might be able to export just the pattern synonym, and the type synonym
00:42:56 <shanemikel> adam___: so you're trying to achieve a ternary composition?
00:43:06 <shanemikel> stream processing stuff
00:43:21 <mjrosenb> EvanR: it looks like I can't create a pattern that will look like a record, correct?
00:44:13 <coconut> how to tidy up the imports ? i think i have some unnecessary imports but cant target them.
00:44:25 <adam___> shanemikel: i got it already thanks :)
00:44:32 <adam___> eitherT f g ea = runEitherT ea >>= either f g 
00:45:17 <shanemikel> yeah, I'm a newbie as you suspected
00:45:55 <shanemikel> but I'm pretending to "fake it 'till you make it"
00:45:59 <EvanR> mjrosenb: didnt see that in the examples
00:46:01 <shanemikel> as it were
00:46:43 <frerich> coconut: If you compile with -W (or just -fwarn-unused-imports, ghc will tell you which imports are unused.
00:46:45 <shanemikel> adam___: out of curiosity, was I even on the right track?
00:47:09 <coconut> frerich, wow nice
00:47:49 <adam___> im not exactly sure. I struggle with Monad Transformers too so im not the best person to ask haha
00:47:58 <coconut> frerich, does -Wall suffice ?
00:48:36 <frerich> coconut: It's more than sufficient.
00:48:56 <frerich> coconut: You might appreciate https://downloads.haskell.org/~ghc/7.0-latest/docs/html/users_guide/options-sanity.html
00:59:27 * hackagebot amqp 0.13.1 - Client library for AMQP servers (currently only RabbitMQ)  https://hackage.haskell.org/package/amqp-0.13.1 (HolgerReinhardt)
01:00:41 <mjrosenb> EvanR: I think all of my examples used records.
01:02:41 <chipf0rk> Hi there! I'm having trouble understanding why `Enum a` is not defined with an `Eq` constraint, if it is a problem of expressing this in Haskell (I wouldn't know how), or if there's a different reason behind it. I mean, the enumerated "objects" can logically be checked for equality by use of `fromEnum`, right?
01:03:28 <EvanR> i mean i didnt see record pattern support .... but i didnt try it
01:04:00 <phadej> chipf0rk: Enum doesn't say that Eq instance have to agree with fromEnum
01:04:35 <phadej> or that Enum have to actually enumerate the whole set of values of the type
01:05:50 <EvanR> mjrosenb: if youre trying to destruct some record... seems like you need to export that record
01:06:03 <EvanR> not sure why not
01:06:08 <chipf0rk> yes, but in the context of an enumeration, you can compare the elements for equality by their index in the enumeration (completely ignoring what's actually being enumerated), no?
01:06:16 <chipf0rk> oops @phadej
01:06:46 <EvanR> Enum and most standard classes dont really have any laws associated with them
01:07:03 <EvanR> its more like a "spirit" of the law
01:08:04 <chipf0rk> I mean Ord does; but that's a different beast. I thought about doing this myself, but I can't think of any way to, as `(Eq a) => Enum a` would place a constraint on the contained `a` type, not the Enum...
01:08:18 <EvanR> chipf0rk: basically you outlined a way to make any Enum an Eq, yeah it would work
01:08:28 <EvanR> Ord doesnt even
01:09:00 <chipf0rk> Sorry, got carried away - what do you mean by "laws"?
01:09:03 <EvanR> you mean instance (Enum a) => Eq a
01:09:29 <EvanR> chipf0rk: like functor laws, monad laws, etc
01:09:53 <chipf0rk> right, sorry, I was thinking about the Eq constraint on Ord
01:14:18 <chipf0rk> Still can't think of any possible way to write this instance; is that a question more suited for #haskell-beginners?
01:14:27 <EvanR> i just tried it
01:14:54 <chipf0rk> With what results? ;)
01:14:55 <EvanR> the problem is that the instance head must be smaller than the constraint
01:15:45 <EvanR> unless you turn on undeciable instances
01:17:31 <chipf0rk> isn't the problem that I can't make a class an instance of another class?
01:17:54 <EvanR> http://lpaste.net/151067
01:18:06 <EvanR> youre not trying to do that
01:18:09 <tdammers> chipf0rk: classes aren't types, only types can be instances of classes
01:18:49 <chipf0rk> tdammers: that's what I meant :)
01:19:12 <EvanR> youre trying to implement Eq for all Enum types
01:19:31 <chipf0rk> @EvanR: Now I see with the pastebin, thanks
01:19:31 <lambdabot> Unknown command, try @list
01:19:53 <chipf0rk> I should lose that @ habit
01:19:59 <EvanR> indeed
01:21:48 <chipf0rk> sorry, haven't been on IRC in a while ;)
01:23:10 <chipf0rk> with UndecidableInstances and FlexibleInstances, it still runs into trouble because it creates overlapping instances for Eq Int (and presumably more)
01:23:23 <chipf0rk> guess this isn't gonna work out
01:24:01 <tdammers> it's very possible that typeclasses aren't the right hammer for your nail
01:24:38 <chipf0rk> The nail is more of an experiment, luckily I don't have any place where I actually need this, so that's fine :)
01:25:17 <chipf0rk> Thanks everyone
01:28:41 <EvanR> chipf0rk: yeah many types already have Enum and Eq and youd be stomping on them, you can only have 1 of each per type
01:29:18 <EvanR> you can write eqEnum :: Enum a => a -> a -> Bool
01:33:08 <chipf0rk> I will do that!
01:45:49 <Timothy888> btw what is the mode modifer -o and +o?
02:04:43 <jle`> best way to remove a trailing newline from a string?
02:08:07 <tdammers> dropWhileEnd (`elem` "\r\n") -- a bit brutal though
02:09:29 * hackagebot monad-control 1.0.0.5 - Lift control operations, like exception catching, through monad transformers  https://hackage.haskell.org/package/monad-control-1.0.0.5 (BasVanDijk)
02:12:16 <EvanR> init ;)
02:12:53 <tdammers> haha
02:13:11 <tdammers> unlines . lines -- might also work
02:13:22 <tdammers> > unlines . lines $ "Hello, world!\n"
02:13:24 <lambdabot>  "Hello, world!\n"
02:13:27 <tdammers> shame
02:13:34 <tdammers> > lines $ "Hello, world!\n"
02:13:36 <lambdabot>  ["Hello, world!"]
02:13:45 <EvanR> unlines puts such a trailng newline at the end
02:13:49 <tdammers> yeah, figured
02:14:39 <tdammers> > intercalate "\n" . lines $ "Hello, world!\n"
02:14:40 <lambdabot>  "Hello, world!"
02:14:47 <tdammers> > intercalate "\n" . lines $ "Hello,\nworld!\n"
02:14:49 <lambdabot>  "Hello,\nworld!"
02:14:53 <tdammers> \o/
02:15:51 <EvanR> > intercalate "\n" . lines $ "Hello, world!\r\n"
02:15:53 <lambdabot>  "Hello, world!\r"
02:15:57 <EvanR> > intercalate "\n" . lines $ "Hello, world!"
02:15:59 <lambdabot>  "Hello, world!"
02:16:04 <EvanR> > intercalate "\n" . lines $ ""
02:16:06 <lambdabot>  ""
02:16:32 <EvanR> soclose.jpg
02:17:56 <EvanR> wonder why lines didnt take out that \r
02:19:36 <tdammers> probably because it's a unix snob
02:20:27 <EvanR> email, http, etc were invented on DOS? :)
02:20:39 <merijn> EvanR: Aren't those \n\r?
02:20:47 <merijn> > intercalate "\n" . lines $ "Hello, world!\n\r"
02:20:47 <EvanR> CRLF
02:20:49 <lambdabot>  "Hello, world!\n\r"
02:20:51 <merijn> hmmm
02:21:16 <merijn> Maybe it's platform dependent
02:21:16 <EvanR> no one in history of mankind has ever used \n\r
02:21:21 <merijn> Someone on windows should check
02:21:47 <chipf0rk> EvanR: "LF+CR: Acorn BBC and RISC OS spooled text output." apparently _someone_ has!
02:22:00 <EvanR> wtf
02:22:13 <tdammers> people have used EBCDIC
02:22:19 <tdammers> \n\r is benign in comparison
02:22:42 <chipf0rk> merijn: it's definitely \r\n
02:23:03 * EvanR creates an OS just to be able to use NEL
02:24:11 <Gurkenglas> > maximum [i | i <- [0..2] :: [Integer], a <- filter ((==1) . gcd 221) [0..220] :: [Integer], (a^((2^i) * 55)) `mod` 221 == -1] -- have I made any obvious mistakes in computing j from https://i.gyazo.com/79bc6f697a587f3daf38d186a3864916.png ?
02:24:13 <lambdabot>  *Exception: Prelude.maximum: empty list
02:24:20 * tdammers creates an opinionated OS that assumes that staring at a computer screen is bad for you and shuts down as soon as it's finished booting
02:26:04 <merijn> Does mod ever return a negative value?
02:26:09 <merijn> I don't think so?
02:26:15 <EvanR> no
02:26:16 <merijn> > -112 `mod` 5
02:26:18 <lambdabot>  -2
02:26:21 <EvanR> yes
02:26:22 <merijn> Oh, it does
02:26:33 <EvanR> > -112 `rem` 5
02:26:33 <merijn> But a to the power anything is never negative, I'm sure
02:26:35 <lambdabot>  -2
02:26:37 <Gurkenglas> Where would the negative value come from? Nonnegativity of all values passed around here is an invariant
02:27:03 <merijn> Gurkenglas: -1 mod 221 is simply 220, afaict?
02:27:11 <Gurkenglas> Ah shoot
02:27:33 <EvanR> what wise guy extended remainders into the negative
02:27:33 <Gurkenglas> That woulda taken me a while, thanks
02:27:43 <pyrtsa> https://en.wikipedia.org/wiki/Modulo_operation
02:27:54 <merijn> Gurkenglas: And in math you can simply call those two the same when computing in ℤ mod 221
02:27:58 <pyrtsa> ^ There are a few ways to define mod in terms of negative values.
02:28:12 <merijn> EvanR: Why would you not have negative remainders/
02:28:22 <EvanR> because its confusing
02:28:28 <merijn> EvanR: The remainder of dividing a negative number is obviously negative?
02:28:40 <EvanR> not obviously
02:28:46 <merijn> EvanR: What else could it possible do? Throw an exception, that's even more confusing
02:29:15 <EvanR> > (-1) `mod` 221
02:29:17 <lambdabot>  220
02:29:21 <EvanR> good enough for me
02:30:00 <Gurkenglas> congruence modulo 221 separates Z into 221 equivalence classes that ought to have one representative each
02:30:02 <merijn> EvanR: "n `rem` x" subtracts 'x' from 'n' some number of times and the remainder is whatever is left over after doing that a whole number of times. Modulo has very different semantics
02:30:26 <EvanR> i was talking about mod/rem in general as "remainders" 
02:30:36 <EvanR> they are the same for non negative
02:31:08 <merijn> But modulo is not the same as remainder, and I don't see any way you can sensibly define remainder without mandating negative remainders?
02:31:16 <EvanR> the only difference for negatives is with slightly different wording of the definition
02:31:17 <SailorR> what does => mean
02:31:34 <pyrtsa> Wait, does GHC parse "-112 `mod` 5" as "-(112 `mod` 5)"?
02:31:38 <EvanR> regarding a = q*b + r
02:31:54 <EvanR> > -1 `mod` 221
02:31:57 <lambdabot>  -1
02:31:59 <EvanR> yep
02:32:03 <pyrtsa> :(
02:32:06 <EvanR> lol
02:32:10 <chipf0rk> merijn: Euclidean division I guess, it's in the article
02:32:11 <pyrtsa> > negate 112 `mod` 5
02:32:13 <lambdabot>  3
02:32:16 <pyrtsa> Better.
02:32:25 <merijn> pyrtsa: - is an ugly parser wart :\
02:32:29 <pyrtsa> Very.
02:32:35 <merijn> But I wouldn't know how to do it better
02:32:40 <pyrtsa> So it wasn't mod's fault after all then
02:32:41 <EvanR> > (-1) `rem` 221
02:32:43 <lambdabot>  -1
02:32:48 <EvanR> jeebus
02:33:12 <merijn> > (-1) `div` 221
02:33:14 <lambdabot>  -1
02:33:38 <EvanR> yeah rem moves 1 whole into the quotient and shifts the remainder by b
02:33:40 <EvanR> into the negative
02:33:42 <merijn> Shouldn't that be 0?
02:33:43 <EvanR> just for giggles
02:34:16 <EvanR> > (-1) `quotRem` 221
02:34:18 <lambdabot>  (0,-1)
02:34:23 <merijn> See, the div one confuses me
02:34:35 <merijn> I would expect div to correspond to the 0 in quotRem
02:34:52 <merijn> oh
02:34:59 <merijn> div is truncated to negative infinity
02:35:00 <EvanR> divMod is the true quotRem
02:35:03 <pyrtsa> merijn: No, I think `div` co-operates with `mod`, where the latter returns 220.
02:35:05 <merijn> I want `quot`
02:35:17 <chipf0rk> SailorR: it's used to put class constraints on (polymorphic) types, see here https://www.haskell.org/tutorial/classes.html
02:35:50 <EvanR> its two incompatible and pointlessly different ways to solve a = q*b + r
02:36:00 <merijn> chipf0rk: Not just class constraints! :D *hides in the pedant corner*
02:36:22 <EvanR> and the cpu implements only one
02:36:35 <pyrtsa> ...And -1 == 221 * ((-1) `div` 221) + ((-1) `mod` 221), i.e. 221 * (-1) + 220.
02:37:10 <merijn> Clearly we should just give up on integers and simply always use Ratio Integer :D
02:37:20 <merijn> Float and Doubles can also go to hell :p
02:37:32 <pyrtsa> And finite memory likewise.
02:37:48 <EvanR> my number type is the 9-digit calculator screen adjoin ERROR
02:37:57 <EvanR> and upside down hello
02:38:15 <merijn> pyrtsa: Ratio Int is acceptable if you think memory is important :p
02:38:51 <chipf0rk> merijn: but then you have limited precision again, like with the dreaded floating types ;)
02:39:13 <EvanR> at least in the domain of validity is follows laws
02:39:16 <EvanR> it
02:40:17 <merijn> chipf0rk: But infinite precision with fixed boundaries, as opposed to limited precision within fixed boundaries
02:41:33 <pyrtsa> Nah, we know the best physical constants up to around 13 decimal digits of precision. `Ratio Int` is more than enough enough. :)
02:42:21 <diggle> I want a function that when passed a number returns true if it's a multiple of 3 and false when it isn't. I tried "let func = (`mod` 3)==0" n the repl, but it didn't work. Help?
02:43:05 <EvanR> pyrtsa: heh... not if you want to have the proper relative magnitudes
02:43:15 <pyrtsa> =)
02:43:20 <Gurkenglas> :t [(==0) . (`mod` 3), \n -> mod 3 n == 0]
02:43:22 <lambdabot> Integral a => [a -> Bool]
02:43:23 <pyrtsa> diggle: `(0 ==) . ($ 3)` if you want to be clever.
02:43:23 <EvanR> like have c and hbar in the same program
02:43:37 <EvanR> (just set them all = 1)
02:43:53 <pyrtsa> (Oops.)
02:44:05 <Gurkenglas> pyrtsa, pretty sure he's working on fizzbuzz
02:44:18 <pyrtsa> Haha, guess so.
02:44:33 <merijn> Or just "let func x = x `mod` 3 == 0"
02:44:37 <pyrtsa> (And I failed at operator precedence of `mod` above.)
02:44:41 <merijn> What's up with the pointfree obsession?
02:44:46 <Gurkenglas> *mod n 3 not mod 3 n ._.
02:45:15 <Gurkenglas> People keep saying I'll grow out of the pointfree obsession, but it hasn't happened yet after ~21 months
02:46:34 <merijn> I find the "(==0) . (`mod`3)" version is "ok", but I don't see why people would recommend it to someone who's just starting
02:46:42 <Gurkenglas> When @pl returns gibberish, make more combinators (we need (f .: g) x = f . g x) or adjust your type signature because it was wrong in the first place if it's ugly in pointfree :P
02:47:27 <Gurkenglas> merijn, he seemed to be trying to think in a pointfree way, and I did give him your alternative (wrong) solution
02:47:30 <Gurkenglas> argh
02:47:35 <Gurkenglas> your alternative solution, but incorrectly
02:48:38 <EvanR> we need the combinator aviary
02:49:12 <EvanR> the obsession can go as far as concatenative programming
02:49:18 <diggle> What's the difference between . and $?
02:49:30 <tdammers> :t (.)
02:49:31 <lambdabot> (b -> c) -> (a -> b) -> a -> c
02:49:32 <tdammers> :t ($)
02:49:32 <EvanR> :t ($)
02:49:34 <lambdabot> (a -> b) -> a -> b
02:49:34 <lambdabot> (a -> b) -> a -> b
02:50:08 <diggle> Oh.
02:50:30 <tdammers> . is function composition, $ is function application (but with an alternative fixity)
02:50:40 <statusfailed> What does -fobject-code do ?
02:51:00 <EvanR> > (map (+1) . filter even) [1,2,3,4]
02:51:01 <lambdabot>  [3,5]
02:51:04 <Gurkenglas> diggle, . composes functions and $ (associating to the right) applies them. One says "the resulting function is what happens when you do first that one, then this one", the other "the resulting value is what happens if to that value you apply this function"
02:51:08 <EvanR> > (map (+1) `id` filter even) [1,2,3,4]
02:51:10 <lambdabot>      Couldn't match expected type ‘[Integer] -> t’
02:51:10 <lambdabot>                  with actual type ‘[Integer]’
02:51:10 <lambdabot>      The function ‘map (+ 1) `id` filter even’
02:51:24 <EvanR> hyuk
02:51:36 <EvanR> wrong one
02:51:52 <liste> > negate `id` 27
02:51:54 <lambdabot>  -27
02:52:06 <diggle> Gurkenglas: Oh. You generally use . for functions that take one argument, right?
02:52:24 <Gurkenglas> Thus, (and because . binds more strongly than $ and $ is right-associative) "f . g $ x" is equivalent to "f $ g $ x", but they can be used in different other situations
02:52:24 <merijn> diggle: You can use . with anyt function
02:52:31 <EvanR> all functions take 1 argument
02:53:58 <geekosaur> [28 10:20] <EvanR> email, http, etc were invented on DOS? :)
02:54:01 <Gurkenglas> diggle, yes, but you can view two-argument functions as a one-argument function that returns a one-argument function. (0 ==), which desugars to (==) 0 is one such, turning the two-argument function (==) into a one-argument function by applying 0
02:54:02 <geekosaur> tenex, mostly
02:54:34 <geekosaur> well, not http, but the standard was set by then
02:54:39 <diggle> Gurkenglas: Oh, nod.
02:54:44 <Gurkenglas> And by putting a two-argument function directly into a chain of .s ("compositions"), the function to the left of it will get a one-argument function as an argument
02:55:51 <Gurkenglas> > (\f -> f 2) . (==) $ 5 -- 5 gets plugged into (==)'s first argument, then (5 ==) is plugged into f's place
02:55:53 <lambdabot>  False
02:56:38 <EvanR> geekosaur: and \r\n was the norm?
02:57:34 <geekosaur> DEC pretty considtently used \r\n across its whole line of computers / OSes. DOS got it from CP/M which got it from DEC minicomputer OSes; the Internet got it from Tenex (Carnegie Mellon patches to DEC's TOPS-10 mainframe OS)
02:59:14 <geekosaur> (Tenex having included one of the first TCP/IP implementations) 
02:59:50 <geekosaur> s/first/earliest/
03:14:32 * hackagebot link-relations 0.1.1.0 - Use web link relation types (RFC 5988) in Haskell  https://hackage.haskell.org/package/link-relations-0.1.1.0 (akrasner)
03:41:48 <f-a> I am putting this in ghci λ> let a = sum [1..10^6] `mod` 2
03:42:06 <f-a> I thought: the first time it should take some seconds to calculate (as it does) and then the result will be memoised
03:42:32 <f-a> but apparently every time I run it (Ghci> a) it takes some second
03:42:39 <f-a> does that mean that ghci doesn't memoise?
03:43:29 <merijn> f-a: I think ghci has monomorphism restriction turned off by default nowadays?
03:44:06 <merijn> f-a: Try "let a :: Int; a = sum [1..10^6] `mod` 2" and see if that's faster
03:44:12 <f-a> 7.10.3, merijn 
03:47:54 <mchall> I am trying to complete the monad challenges and have got to http://mightybyte.github.io/monad-challenges/pages/ex2-4.html I have got the queryGreek2 function http://lpaste.net/150894 working when the result is a Just value but my function causes an error instead of a Nothing value. How do I surface the Nothing value ?
03:48:36 <statusfailed> weird, I've started getting "<stdin>: hGetChar: hardware fault (Input/output error)" in GHCi
03:48:41 <statusfailed> what's that aboot :\
03:48:58 <statusfailed> oh nvm, forgot to google first :p
03:58:42 <frerich> mchall: It seems to me that 'Just xx = mm' is problematic if you consider that 'mm' can be Nothing (because 'link tm maximumMay' may yield Nothing).
03:59:22 <frerich> mchall: I.e. your 'chain' of 'link' calls (there's a nice alternative way to write that, by the way) seems sane but the final extraction of xx and yy doesn't seem to take into account that 'mm' and 'hm' can be Nothing.
04:01:36 <mchall> frerich: how do I return a Nothing if one is encountered earlier ?
04:02:11 <mchall> frerich: what is the better alternative ?
04:03:03 <mchall> frerich: is there a way of using link to feed the two values to divMay ?
04:04:31 <frerich> mchall: Have you seen 'lambda expressions' yet, i.e. expressions of the form '\x -> x + 1' or so which can be applied to some value?
04:05:11 * frerich afk for a few moments
04:06:00 <mchall> frerich: yes the challenge gives the hint to use lambdas to make the code better
04:06:18 <mchall> I am still working to make it run correctly
04:06:25 <EvanR> earlier i suggested a le
04:06:31 <EvanR> earlier i suggested a let 
04:06:47 <EvanR> but if you cant use let, a lambda can be used as a let like this
04:07:07 <EvanR> let x = foo in bar x ===> (\x -> bar x) foo
04:08:06 <mchall> EvanR: I have used lets, it just is throwing an error instead of a Nothing value
04:24:34 * hackagebot postgresql-binary 0.7.6 - Encoders and decoders for the PostgreSQL's binary format  https://hackage.haskell.org/package/postgresql-binary-0.7.6 (NikitaVolkov)
04:24:36 * hackagebot hasql 0.19.4 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.19.4 (NikitaVolkov)
04:29:34 * hackagebot webfinger-client 0.2.0.0 - WebFinger client library  https://hackage.haskell.org/package/webfinger-client-0.2.0.0 (akrasner)
04:35:09 <jophish> I'm calling into some external code with the ffi and I'd like to profile that code
04:35:18 <jophish> I'm on linux, what tools can people suggest for this?
04:35:54 <merijn> jophish: Open source or commercial/for-profit?
04:37:06 <jophish> merijn: I'm generating the external code from source, but it's terra code, so I'm not sure how easy it'll be to modify the object file it generates
04:37:26 <jophish> for the profiler, I'm not bothered. Although ideally I'd like not to have to pay :)
04:39:07 <merijn> jophish: No, I meant your code :p Intel VTune Amplifier has (iirc) a free license for open source developers and it's by far the best profiler I've used (assuming intel architecture) although sometimes the GUI is a bit terribly slow. However it's use for for-profit development requires an expensive license
04:39:34 * hackagebot nested-routes 7.0.0 - Declarative, compositional Wai responses  https://hackage.haskell.org/package/nested-routes-7.0.0 (athanclark)
04:40:23 <jophish> merijn: This is for work. I'll ask if we can open source it. Failing that do you think callgrind would work?
04:40:48 <merijn> jophish: I think if you get paid for coding, even if OS, it's considered for profit according to their license
04:41:26 <merijn> jophish: At any rate, if you're doing high-performance stuff I would probably tell your boss to get a copy anyway :p
04:41:26 <jophish> ah, that's a shame :/
04:41:45 <merijn> You could try gprof, but I've found it lacking
04:42:13 <jophish> I'll make a request :D
04:42:17 <mrlase> depending on what your doing, Allinea MAP is also pretty awesome
04:42:34 <merijn> Allinea stuff is generally also not cheap :p
04:42:44 <mrlase> yeah, there is that :S
04:42:59 <merijn> I got our boss to buy Allinea's debugger during my internship. Great experience
04:43:30 <merijn> But I think that runs like several thousand dollar per machine for the license :p
04:43:50 <jophish> Essentially we're generating an object file with an image processing function in from some Darkroom code, and running that over a movie, but getting much slower results than are advertised in the paper
04:44:28 <jophish> I'm pretty sure I know what's wrong, but it would be nice to profile things to confirm.
04:44:55 <jophish> (every frame we process it's making a bunch of calls to mmap and munmap)
04:45:19 <merijn> jophish: Basically VTune uses the Intel performance counters for profiling, you can run it on just binaries (if you compile with DWARF debug symbols you can have it map assembly to source lines) and it does stuff like show cache-misses, pipeline load, etc.
04:45:33 <merijn> jophish: Actually, which OS? Linux specifically or is it portable?
04:45:42 <jophish> merijn: oh that sounds very nice
04:45:55 <jophish> merijn: I could probably put it onto OSX
04:45:56 <merijn> jophish: Only has about 10-20% runtime overhead too
04:46:12 <merijn> jophish: on OSX/BSD/Solaris you could use DTrace to trace/log syscalls like mmap
04:46:15 <jophish> The profiler on osx was ok when I used it last
04:46:26 <merijn> I suppose linux has something similar, but I don't know it
04:52:05 <bernalex> dtrace is for linux, but linux users tend to use systemtap.
04:52:47 <bernalex> dtrace is cddl which is gpl-incompatible, so you won't find it distributed with linux.
05:01:45 <son_of_dawn> oldnemo
05:01:50 <jophish> Thanks for the info merijn, mrlase and bernalex! I'll see what I can do :)
05:03:22 <AcuZZio> oie guys... is there a way to print something in the SAME LINE as the last IO() action did? Something like putStrLn, but that UPDATES the output line instead of appending it? Pretty much like the output of bash command "echo -ne 'message'\\r" ??
05:04:06 <liste> AcuZZio putStrLn "hello\rworld"
05:04:11 <merijn> AcuZZio: Do you maybe want putStr instead of putStrLn?
05:04:41 <merijn> Basically I think this requires switching the terminal to a different mode
05:04:54 <merijn> i.e. do raw terminal output as opposed to using stdout
05:05:02 <merijn> Well, I guess that does use stdout
05:05:09 <merijn> But...yeah...
05:05:21 <merijn> AcuZZio: Basically, it depends on what your end goal is?
05:05:39 <liste> putStrLn "hello\rworld" prints "world" at least on my GHCi
05:06:16 <AcuZZio> oki, using  '\r' instead of '\n' does the trick in ghc, I will try to use it in the program now :  )
05:07:10 <AcuZZio> I am processing multiple files with a function, I just want to output a simple command line "loader"
05:14:40 * hackagebot hardware-edsl 0.1.0.1 - Deep embedding of hardware descriptions with code generation.  https://hackage.haskell.org/package/hardware-edsl-0.1.0.1 (mararon)
05:14:42 * hackagebot language-vhdl 0.1.2.6 - VHDL AST and pretty printer in Haskell.  https://hackage.haskell.org/package/language-vhdl-0.1.2.6 (mararon)
05:14:44 * hackagebot json-ast 0.1 - Universal JSON AST datastructure  https://hackage.haskell.org/package/json-ast-0.1 (NikitaVolkov)
05:16:30 <AcuZZio> <merijn> I have a function that is mapped to different files  [FilePath] -> IO()       . For each element of [filePath] (each file) there is a PutStrLn that basically says "File foo0001 is DONE". So I get as output thousands of lines. I would like to get these outputs in a single line. You see what I mean?
05:16:59 <barrucadu> AcuZZio: Don't use putStrLn. Use putStr.
05:17:09 <barrucadu> putStrLn adds a newline, putStr doesn't
05:17:15 <AcuZZio> liste: Using "\r" just prints "world" without printing "Hello", unfortunately. Doing it in the whole program is printing only the last line (the last file processed). 
05:20:20 <liste> AcuZZio then you'll want putStr
05:21:21 <bergmark> AcuZZio: inspiration: https://hackage.haskell.org/package/concurrent-output
05:22:45 <knupfer> What would be the best way to aggregate a csv into bins?
05:22:47 <AcuZZio> barracadu, liste: I used both : ( . They do not work. putStr outputs a single concatenated line. I am now reading the inspiration
05:22:53 <knupfer> With groupBy?
05:23:50 <liste> AcuZZio: what do you exactly want? update the text as your program is progressing?
05:23:53 <liste> like a progress bar?
05:25:32 <liste> so that multiple lines are updated at ounce?
05:28:10 <AcuZZio> liste if you have a bash shell, run this command, I want to do this:     echo -ne "FIRST LINE\r";sleep 2;echo -ne "SECOND LINE\n"
05:28:42 <liste> AcuZZio "\r" does exactly that (you may need to flush the buffer after that)
05:29:47 <knupfer> try the package ansi-terminal
05:31:02 <AcuZZio> oki... I will go to lunch now. THANKS for now. really. (I will also try ansi-terminal)
05:32:53 <frerich> mchall: Did you get any further yet? I'm back now. :-]
05:34:05 <mchall> EvanR: I have used lets, it just is throwing an error instead of a Nothing value instead of trying to access the Just values in divMay
05:35:13 <mchall> frerich I don't understand how to  return a Nothing value instead of trying to access the Just values in divMay
05:37:04 <frerich> mchall: Your 'link' method takes a value of type 'Maybe a' and a function of type 'a -> Maybe b' and produces a value of type 'Maybe b'. At least that's what I see in your 'link' type declaration.
05:38:23 <mchall> frerich yes but divMay takes two a values which I have to get from Just values
05:38:24 <frerich> mchall: This means that, by making use of lambda expressions, you could do something like 'link x (\y -> Just (y+2))'. The second thing is a lambda expression which takes one argument ("y") and yields "Just (y+2)".
05:38:53 <frerich> mchall: ...and if 'x' was Nothing, then your function is not used, but if 'x' was "Just 14" then you would get "Just (14+2)". Good so far?
05:39:14 <mchall> frerich yes
05:40:49 <frerich> mchall: Now, you can "chain" those link calls by nesting them. For instance, assuming you have two 'Maybe Int' values and you want to yield their sum or Nothing (in case either of the two is Nothing), such that e.g. "f (Just 3) (Just 41)" is "Just 44" but "f Nothing x = Nothing" and "f x Nothing = Nothing"
05:41:19 <frerich> mchall: You could use your 'link' function like 'f a b = link a (\x -> link b (\y -> Just (x+y)))'.
05:41:51 <frerich> mchall: And you need the same kind of chaining in your queryGreek2 calls such that you can unwrap both mm and hm and get their quotient.
05:42:28 <frerich> mchall: Now, because earlier you asked " what is the better alternative ?", there's a little syntax trick
05:43:14 <frerich> mchall: Did you encounter "infix" applications yet? The interesting thing is that any function application like "f x y" can also be written as "x `f` y", i.e. the function name can be written between the two arguments, but in backticks.
05:44:13 <frerich> mchall: Your "link" function lends itself to being used infix. The "f" function I mentioned earlier could also be written as "f a b = a `link` \x -> b `link` \y -> Just (x+y)"
05:44:32 <frerich> mchall: And if you now put a newline after every "->" then it actually looks somewhat sane :-)
05:45:00 <frerich> a `link` \x ->
05:45:03 <frerich> b `link` \y ->
05:45:05 <frerich> Just (x+y)
05:45:06 <frerich> Links that.
05:45:09 <aleator_> Is it possible to have a Pipes Pipe that does work concurrently?
05:45:11 <frerich> Like that, sorry.
05:45:52 <mchall> frerich I have seen that used, I'm still working how to nest my code so that the divMay Nothing values don't get accessed ) 
05:46:32 <mchall> frerich thanks for all the help
05:46:46 <frerich> mchall: Yeah, that's what "link" takes care of. You can use it to "safely unwrap" your Maybe values - the given function either gets the "Just" value, or it won't get called at all.
05:48:35 <mchall> frerich yes but divMay has two a's and I have to call fromIntegral first how do I not call divMay before If I already have a Nothing ?
05:49:28 <frerich> mchall: That's what the 'nesting' is for. Reconsider 'link a (\x -> link b (\y -> Just (x+y))'. Notice how 'Just (x+y)' is never evaluated in case either 'a' or 'b' is Nothing.
05:49:41 <frerich> mchall: In case either of the two is Nothing, the 'link' call won't even call the function.
05:50:52 <brapaport> @pl \f g x y -> f (x ++ g x) (g y)
05:50:52 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
06:06:01 <kqr> it's not often I come here for questions like this, but here we go: I'm going to write a tutorial on parser combinators aimed at some sort of haskell beginner. in this tutorial, I want to have several examples which build on each other and eventually parse some simple format – not too complicated and not too simple. the IRC protocol is just on the edge of "too complicated". the problem is that I'd like to
06:06:03 <kqr> use a format which doesn't yet have a parser (because otherwise the obvious response to "how to parse format X" is "just download the X parser library"). any suggestions?
06:06:43 <kqr> so what I'm saying is something about as "complicated" as the IRC protocol or slightly simpler. the reason I don't go with the IRC protocol is that a parser exists. I might use it anyway in a pinch but ideally something a bit more obscure!
06:06:55 <kqr> (preferably text-based and not binary, for obvious reasons)
06:10:39 <brapaport> @pl exactMatches actual guess = length (filter (uncurry (==)) (zip actual guess))
06:10:40 <lambdabot> exactMatches = ((length . filter (uncurry (==))) .) . zip
06:14:15 <frerich> kqr: Maybe weather data from the US national weather service. See http://www.nws.noaa.gov/tg/txtfiles.php -- they provide a ton of freely available text files with a simple but  custom format. See e.g. ftp://tgftp.nws.noaa.gov/SL.us008001/DF.an/DC.sfmar/DS.ships/sn.0002.txt
06:17:01 <knupfer> @pl \x -> a $ (b (c x) d * e) / f
06:17:01 <lambdabot> a . (/ f) . (e *) . flip b d . c
06:20:10 * hackagebot mulang 0.1.0.0 - The Mu Language, a non-computable extended Lambda Calculus  https://hackage.haskell.org/package/mulang-0.1.0.0 (flbulgarelli)
06:25:13 <kqr> brapaport, sum (map fromEnum (zipWith (==) actual guess)) perhaps
06:26:12 <kqr> frerich, let me see
06:28:06 <frerich> kqr: I don't remember what all those fields stood for (depending on the file it can be air pressure or humidity per region or so). It's "real world" data though which is non-trivial to parse, but still not too complex. And there's few existing libraries for that already, I think.
06:28:18 <frerich> It's also freely available, i.e. there's a large corpus of data to test with.
06:29:15 <kqr> yeah it looks perfect – I just have to see if I can understand what's going on haha
06:29:54 <kqr> the only problem is if it contains index numbers or somesuch other identifier that needs to be looked up on an internal service
06:31:05 <brapaport> @pl exactMatches actual guess = sum (map fromEnum (zipWith (==) actual guess))
06:31:06 <lambdabot> exactMatches = ((sum . map fromEnum) .) . zipWith (==)
06:31:10 <frerich> kqr: I suppose there's an explanation of the format (or various formats?) somewhere, but yeah - you may have to read up on it. I just have very distant memories of using that data for a Python exercise or so.
06:45:10 * hackagebot rebase 0.1.1 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.1.1 (NikitaVolkov)
07:16:20 <gaurav> hello , I am new to this community and I am interested in developing.
07:16:49 <gaurav> I would like to start with some bugs
07:17:17 <gaurav> If anyone would direct me towards a bug, I'd be thankful
07:17:40 <mauke`> bug in what?
07:18:40 <gaurav> I thought there must be some unsolved bugs I could look at .
07:18:52 <mniip> bugs in what
07:19:07 <gaurav> in the code
07:19:10 <mauke`> in what code?
07:19:11 <mniip> code of what
07:19:23 <gaurav> haskell library
07:19:25 <gaurav> ?
07:19:30 <mniip> which haskell library?
07:20:44 <hatds> if you want to pitch in, ghc has a pretty big bug list and everyone would love to it see shorter
07:26:34 <kqr> frerich, I may go with the METAR data instead (ftp://tgftp.nws.noaa.gov/data/observations/metar/stations/ESSA.TXT). once I've figured out how it works. seems to be slightly more information on that though (or maybe it's just easier to find on google)
07:32:45 <frerich> kqr: Sounds good. I guess 'No existing parsers' and 'Plenty of available information' are somewhat conflicting requirements. :-)
07:33:19 <jophish> hatds: ghc isn't exactly the easiest codebase to jump into
07:33:31 <kqr> frerich, ah, the dilemma!
07:42:20 <ner0x652> Hi!
07:42:26 <statusfailed> hmmmm. anyone got a good solution for removing terminal escape sequences from a string?
07:42:45 <kqr> statusfailed, depends on which terminal
07:42:56 <ner0x652> I was working on a function that adds members of tuples in a list
07:43:27 <statusfailed> kqr: it's for strings produced by ansi-wl-pprint
07:43:32 <ner0x652> the function definition is this: addTups xs = [a + b | (a,b) <- xs]
07:43:57 <statusfailed> kqr: I'm not outputting my resulting string to terminal either
07:44:50 <ironChicken> when you do cabal update, is "00-index.tar" the thing that gets downloaded?
07:44:50 <ner0x652> before this I wrote the function type like this: addTups :: (Num a, Num b, Num c) => [(a,b)] -> [c]
07:45:06 <kqr> statusfailed, but at least for VT100 i'm fairly sure you'll have to specifically include support for various escape sequences. i.e. there's no good general method
07:45:12 * hackagebot haste-compiler 0.5.4 - Haskell To ECMAScript compiler  https://hackage.haskell.org/package/haste-compiler-0.5.4 (AntonEkblad)
07:45:38 <ner0x652> the compiler 'says' it is an ambiguous definition, why is that? (a is a Num, b and c, too)
07:45:59 <statusfailed> kqr: ok, thanks.. I might just use a library that doesn't output such colourful strings :-)
07:46:44 <kqr> statusfailed, from what I understand, the ansi-wl-pprint package is the same thing as the wl-pprint package *except* the former is more colourful
07:47:14 <statusfailed> kqr: my real problem is trifecta's output actually - and trifecta uses the ansi library
07:47:25 <kqr> ah
07:47:28 <statusfailed> I don't think there's a way to get it to output non-colourful strings without lots of patches, heh
07:48:33 <mauke`> statusfailed: my first attempt: remove everything between "\ESC[" and "m"
07:49:02 <mauke`> make that everything between "\ESC[" and any letter
07:49:19 <mauke`> ner0x652: what's the actual error message?
07:49:57 <statusfailed> mauke`: notsureifserious
07:50:10 <bryanvick> how can I associate info with a constructor?  data Fruit = Apple ... | Orange ...; foo :: Fruit -> String, but I don't want to require fully created instances of Fruit, as each constructor might have many fields 'foo' doesn't care about.
07:50:17 <mauke`> statusfailed: why?
07:50:23 <kqr> mauke`, http://www.termsys.demon.co.uk/vtansi.htm
07:50:32 <kqr> mauke`, some escape sequences end on a number
07:50:36 <ner0x652> mauke`: could not deduce (c ~ a) from the context (Num a, Num b)
07:50:45 <statusfailed> mauke`: between ESC[ and any letter... isn't that the whole string?
07:50:52 <statusfailed> (at least, the rest of the string after \ESC[)
07:51:01 <kqr> mauke`, and some on a symbol (!)
07:51:12 <mauke`> statusfailed: ... the first letter after \ESC[
07:51:31 <mauke`> kqr: those don't start with \ESC[
07:51:45 <kqr> that's true
07:51:48 <kqr> nicely spotted
07:52:37 <mauke`> ner0x652: that doesn't say ambiguous
07:53:06 <ner0x652> mauke`: sorry
07:54:13 <statusfailed> mauke`: insufficient coffee error
07:54:45 <statusfailed> thanks ^^
07:54:51 <kqr> bryanvick, it sounds like you're trying to solve the wrong problem. Data.Typeable might let you do what you are trying to do, but I am unconvinced it is the right thing to do
07:56:24 <mauke`> > let stripSomeAnsi ('\ESC' : '[' : xs) = case dropWhile (\c -> not (isAsciiLower c || isAsciiUpper c)) xs of { [] -> []; _ : xs -> stripSomeAnsi xs }; stripSomeAnsi (x : xs) = x : stripSomeAnsi xs; stripSomeAnsi [] = [] in stripSomeAnsi "hello \27[1mworld!\27[m"
07:56:25 <lambdabot>  "hello world!"
07:57:28 <mauke`> ner0x652: anyway, the problem is the type of (+)
07:57:35 <mauke`> :t (+)
07:57:37 <lambdabot> Num a => a -> a -> a
07:57:47 <mauke`> it requires both operands and the result to have the same type
07:58:01 <nkhodyunya> Can i use REPL with ghcjs with browser as an evaluation environment?
08:00:16 <akegalj> nkhodyunya: I think that is not quite ready yet. There was one youtube video where someone did use that.
08:01:12 <bryanvick> kqr: Yeah the way I'm structuring it feels wrong
08:04:16 <bryanvick> kqr: I thought about having data FruitType = Apple | Orange deriving Enum;   foo :: FruitType -> String.  But I was hoping I could use the constructor as a sort of enum of possible fruit types
08:06:28 <kqr> bryanvick, you can with Data.Typeable, but it might be better to not have a bunch of fields in the Apple constructor
08:06:55 <kqr> bryanvick, and instead do something like data FullFruit = FullFruit FruitType Weight Size Colour
08:07:07 <kqr> bryanvick, and then leave data FruitType = Apple | Orange | Pear without any fields
08:07:35 <kqr> bryanvick, that way your foo :: FruitType -> String doesn't need to bother with the FullFruit
08:08:37 <bryanvick> kqr: I see.  What if each fruit type requires different fields?  data Fruit = Apple Text Int | Orange [Text] Bool
08:10:54 <kqr> bryanvick, you could have data Fruit = Apple StringInfo AppleFields | Orange StringInfo OrangeFields
08:11:13 <kqr> bryanvick, data AppleFields = AppleFields Text Int and so on
08:11:40 <kqr> bryanvick, but at that poit Data.Typeable might be better/easier
08:12:24 <bryanvick> kqr: Thanks a bunch.  I'm going to look into pattern matching using Data.Typeable so I can do foo :: Fruit -> String
08:14:18 <mrlase> does anyone know how to get a list [Foo] out of [Entity Foo] in persistent? 
08:14:30 <mrlase> i.e., I selectList but then need to just get [Foo] somehow
08:15:02 <tero-> mrlase: map entityVal 
08:17:09 <dave23> If I am using stack, is there any point in having version constraints in my cabal file?
08:17:49 <mrlase> tero-: so getFoos has type `IO [Entity Foo]`, so then I could do something like liftM getFoos >>= map entityVal to get the [Foo]?
08:18:13 <dcoutts> dave23: if you intend to share your code with anyone else, yes.
08:20:02 <dave23> dcoutts, but only if my package might be a dependency?
08:20:23 <dcoutts> dave23: or if it's an app that you expect other people to build
08:21:08 <Ygg> hi. I already asked this in haskell-game, but it seems it's a bit dead. I'm trying to make a djikstra map; it works but the calculation is very slow ( >2s, even compiled). i believe my implementation is bad. Here is my code : http://lpaste.net/5633891464690794496 and here is a description of the algorithm : http://www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps
08:21:17 <dave23> dcoutts: oh. I dont understand how stackage works then, I thought if I specify an lts it will use packages that are always compatible
08:21:45 <dcoutts> dave23: sure, it will when you build it using lts, but if you want to share it with other people...
08:21:49 <tero-> mrlase: entityVal is a pure function
08:22:19 <mrlase> yeah, but I need some way to avoid the IO from getFoos
08:22:25 <dave23> dcoutts: wont those other people use lts as well?
08:22:32 <dcoutts> dave23: if you're sharing it with other team members and you're all using the same repo with a stack file, it's fine
08:22:51 <dave23> dcoutts: yes the stack.yaml is part of the project
08:22:58 <dcoutts> dave23: but if you just give me the tarball of your app (e.g. uploaded to hackage) then it's not enough
08:23:10 <tero-> mrlase: foos <- fmap (map entityVal) $ selectList [] []
08:23:12 <dave23> dcoutts: i see. Thanks a lot m8
08:23:50 <mrlase> tero-: thanks so much!
08:24:38 <tero-> mrlase: I can't test it with the cell phone but it should be quite close :)
08:24:51 <mrlase> tero-: it worked :) I got foo :: [Foo]
08:25:09 <tero-> great
08:29:28 <jacereda> Is there some way to specify that some modules in a project are only useful for template haskell, so that they don't get linked in the final executable?
08:31:45 <Wizek> Anyone knows if lambdabot can be asked to simplify an expression? E.g. from `(\a-> case a of; Nothing -> Nothing; Just b -> Just b)` to `id`?
08:34:32 <Clint> Wizek: you can ask it, but it will fail
08:35:20 <ggole>  @pl does some simplifications, but I would guess not that one
08:39:08 <jacereda> alternative question, is there some way to ensure a source module will only be used for template-haskell expansion and will never be linked?
08:41:38 <Wizek> jacereda, That would interest me too.
08:43:44 <Wizek> jacereda, A wild guess: Maybe if you use the `-split-obj` flag GHC/the linker might notice that some functions are not called after the TH expansion and might dead-code-eliminate them.
08:44:17 <jacereda> Wizek: good idea, let me try
08:46:00 <glguy> jacereda: One thing that might work (I just tried it) is that you can omit the TH module from both exposed-modules and other-modules
08:46:14 <glguy> the module won't be included in the library, but it will be available during build time
08:48:04 <Wizek> glguy, Would that only work for modules within the same library? Or would it work across libraries too?
08:48:27 <glguy> same library
08:50:27 <jacereda> glguy: thanks, will try that too
08:50:32 <magbo> Hey, people! I need to use an HTML templater like Hastache but the one that's on stackage.
08:50:35 <jacereda> hmmm, no --enable-split-objs in stack...
08:50:41 <magbo> Do you know about something like that?
08:51:04 <magbo> Also, a stupid question — how do I tell stackage to use a hackage resolver?
08:52:33 <glguy> magbo: I don't think there is a hackage resolver. I think what you do is specify something like resolver: ghc-7.10, and then list all the packages you want in extra-deps:
08:53:41 <magbo> glguy: aha, thanks!
08:56:17 <cocreature> there is "stack solver"
08:57:25 <jacereda> Wizek: -split-objs didn't help, but maybe it's due to the fact that I have profiling enabled...
09:15:45 <mrlase> another persistent question - I have a getFoosForBar function that is :: BarId -> IO [Foo], and I'd like to just pass in the int for BarId for testing purposes in ghci, any thoughts for how to do that?
09:17:15 <crough> make BarId an instance of Num?
09:25:05 <Gurkenglas> withState and withStateT are currently both specialized ((>>) . modify). withState should be generalized to this, while withStateT should be ((>>) . modifyT).
09:32:22 <kurt11> How do I add unit tests to a stack.yaml project?
09:32:27 <kurt11> And how do I run them?
09:37:24 <mrlase> how might I avoid using IO in the signature for `calculateBalance` in here: https://gist.github.com/acrognale/8e36497cdb1f5a38f77a?
09:37:53 <crough> kurt11 - add a test suite to your cabal file, not stack
09:38:59 <glguy> mrlase: IO isn't being used in calculateBalance's type signature in that paste
09:39:27 <mrlase> glguy: yeah, but if I try to compile it with `calculateBalance txs`, it complains about IO not being in the signature for calculateBalance
09:39:42 <mrlase> *with calculateBalance txs in the calculateAccountBalance
09:39:45 <glguy> mrlase: That's because calculateAccountBalance is wrong
09:39:56 <bennofs> Does `ask >>= \ !_ -> ...` make sure that the reader state is evaluated before ... is evaluated?
09:40:18 <glguy> mrlase: each line of the do-notation needs to be an IO action
09:40:24 <glguy> you can make a trivial IO action with return
09:40:25 <Shockk> is anyone here familiar with the web-routes package by any chance?
09:41:20 <mrlase> glguy: something like calculateAccountBalance acc = fmap (map entityVal) $ getTransactionsForAccount acc >>= return . calculateBalance?
09:41:30 <mauke`> >>= return .
09:41:31 <mauke`> that's fmap
09:41:42 <glguy> yeah, but you don't need to bring >>= or fmap into the picture
09:41:46 <glguy> this is what do notation is for
09:42:03 <django_> anyone need a remote intern :)
09:42:06 <glguy> do tx <- getTransactionsForAccount acc; return (map entityVal tx)
09:42:38 <glguy> do tx <- getTransactionsForAccount acc; return (calculateBalance (map entityVal tx))
09:43:27 <mrlase> glguy: awesome, thanks!
10:07:53 <pikajude> if i'm using DuplicateRecordFields, is it only possible to use the field names as record selectors (i.e. inside {})?
10:08:21 <mpickering> have you tried?
10:08:27 <pikajude> that's why i'm asking
10:08:34 <pikajude> "Ambiguous occurrence"
10:08:45 <mpickering> paste your code pls
10:08:49 <pikajude> sec
10:12:03 <Shockk> okay I solved my issue with web-routes; I defined an instance PathInfo a => PathInfo [a] where toPathSegments = mconcat . fmap toPathSegments  ;  fromPathSegments = many fromPathSegments
10:12:41 <Shockk> (allowing me to match routes like /view/1/2/53 to View [Integer] )
10:15:59 <pikajude> mpickering: http://lpaste.net/2384086073417400320
10:20:04 <mpickering> from the user manual
10:20:05 <mpickering> "Fields may be used as selector functions only if they are unambiguous"
10:20:09 <glguy> pikajude: You can't use the record selector when it's ambiguous
10:20:15 <pikajude> well, there you go
10:20:41 * hackagebot happstack-server 7.4.6 - Web related tools and services.  https://hackage.haskell.org/package/happstack-server-7.4.6 (JeremyShaw)
10:21:36 <mpickering> only part 1&2 here is implemented 
10:21:37 <mpickering> https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Redesign
10:25:41 * hackagebot json-state 0.1.0.1 - Keep program state in JSON files.  https://hackage.haskell.org/package/json-state-0.1.0.1 (akrasner)
10:27:00 <saurabhnanda> okay, I seem to be missing something very basic here: http://lpaste.net/151092 vs http://lpaste.net/151091 Firstly why is neither compiling and secondly how can one fmap change the error message so drastically?
10:28:32 <glguy> saurabhnanda: What's the type of decode?
10:28:56 <barrucadu> And the type of msg
10:29:26 <saurabhnanda> glguy: decode :: FromJSON a => ByteString -> Maybe a
10:29:57 <saurabhnanda> glguy: I'm trying to follow the example given under "Working with the AST" in the Aeson haddock
10:30:11 <glguy> Each line of the do-notation needs to be an IO action
10:30:20 <glguy> assuming that msg :: ByteString
10:30:27 <glguy> then decode msg :: Maybe a
10:30:49 <glguy> so you don't need to "execute" that by putting it on the right of the <-
10:30:50 <saurabhnanda> barrucadu: receiveData :: WebSocketsData a => Connection -> IO a
10:31:10 <glguy> You can name that value, however, with a let binding like you did below
10:31:45 <saurabhnanda> why does the example on the Haddock use <- to assign the result of decode, in that case?
10:32:30 <saurabhnanda> glguy: do I need to "fmap decode msg" or should just "decode msg" work
10:32:51 <saurabhnanda> glguy: what's the type of 'msg' in my program? is it ByteString or is it IO (ByteString)
10:32:54 <glguy> saurabhnanda: Because that example is using do-notation with the Maybe type
10:32:57 <glguy> You're using it with the IO type
10:33:10 <shachaf> fmap in Haskell is like PLEASE in INTERCAL.
10:33:19 <saurabhnanda> glguy: and how do I inspect types during runtime (or even compile time) is there a tool that can help me understand how types are flowing in my code?
10:33:26 <glguy> It's ByteString. WS.receiveData conn :: IO ByteString
10:33:53 <glguy> so when you write msg <- WS.receiveData conn, you're assigning the name msg to the result, and that result is a ByteString
10:34:17 <saurabhnanda> in that case, why does this not work: do {x <- (Just 1); putStrLn (show x)}
10:35:21 <glguy> Because you've got a Maybe Integer on one line, and an IO () on the other
10:35:26 <glguy> Maybe and IO aren't the same
10:35:55 * hackagebot cgrep 6.6 - Command line tool  https://hackage.haskell.org/package/cgrep-6.6 (NicolaBonelli)
10:36:14 <saurabhnanda> still not working: http://lpaste.net/151093
10:36:34 <saurabhnanda> hang on hang on hang on
10:36:36 <glguy> do-notation means something different for every type you use it at, so you can't mix types
10:36:45 <glguy> Maybe vs IO vs any other type
10:36:46 <saurabhnanda> will it make more sense if I read it in de-sugared form
10:36:47 <saurabhnanda> ?
10:36:49 <sm> http://awgn.github.io/cgrep .. interesting
10:37:03 <glguy> saurabhnanda: That depends if you understand the desugared form
10:37:04 <saurabhnanda> basically everything in do should be dealing with the same Monad?
10:37:06 <saurabhnanda> something like that?
10:37:20 <glguy> yeah, all the lines in a single do notation use the same Monad instance
10:37:39 <kadoban> saurabhnanda: That's a little strong, but something like that.
10:38:26 <gaurav>  hello , I am new to this community and I am interested in developing.
10:39:04 <saurabhnanda> is this the de-sugared form: (Just 1) >>= (\x -> putStrLn $ show x)
10:39:11 <koz_> gaurav: Hi and welcome!
10:39:36 <ski> @undo do x <- Just 1; putStrLn (show x)
10:39:37 <lambdabot> Just 1 >>= \ x -> putStrLn (show x)
10:39:58 <gaurav> koz_: how and where can I start ?
10:39:58 <ski> saurabhnanda : yes, and both are type incorrect
10:40:05 <OverCoder> Okay I've been really really stuck with making a binary tree, is there any guide or tutorial for that? I know it's a homework but I've been stuck in it for some long time, I don't want to waste that much of time
10:40:28 <frerich> OverCoder: What have you tried so far? Maybe you have some code written already and it's just a matter of fixing it up?
10:40:32 <kadoban> OverCoder: What have you tried? Where are you stuck?
10:40:42 <koz_> gaurav: I'm not sure I understand your question.
10:41:23 <OverCoder> ..what I am stuck in.. well I am stuck at the part of /how/ do I started generating this tree?, I mean, I thought I would need some sort of a special ordering function, but then no
10:41:44 <nitrix> Hi.
10:41:53 <OverCoder> I don't know, the homework sheet provides the data type for the tree, I just don't seem to think of anyway to genrate it
10:42:12 <kadoban> OverCoder: So you're trying to write the 'insert' function, right? Have you written any code for it, does any of it make sense, or?
10:42:22 <gaurav> koz_: My question is : How do I start developing (as I'm just starting open-source developing) ?
10:42:30 <Shockk> koz_: if you're wanting to learn to develop with Haskell, the #haskell-beginners channel might be better suited to you
10:42:34 <nitrix> How do I import Either without its instances? I'm trying to implement instances as an exercise and the Prelude one is getting in the way.
10:42:37 <Gurkenglas> OverCoder, are you allowed to used libraries? (You could look at the source of a library too.)
10:42:41 <Gurkenglas> -used+use
10:42:42 <nitrix> Does it means I need to use a phantom type?
10:42:48 <Shockk> er, I meant to ping gaurav 
10:42:58 <OverCoder> kadoban, no, actually I have a list of objects, the homework wants me to sort them using a binary tree
10:43:00 <kadoban> nitrix: You generally can't. There's no way to say "I don't want the instances"
10:43:09 <nitrix> kadoban: So newtype Either?
10:43:12 <OverCoder> Gurkenglas, I guess no, they don't actually specify
10:43:38 <kadoban> nitrix: That'd probably work I guess, or just write your own data MyEither a b = whatever
10:43:40 <frerich> OverCoder: What data types and possibly function types (i.e. the types of function(s) you're supposed to define) were you given?
10:43:43 <Gurkenglas> Well, could you implement a list type instead of a binary tree type, Overcoder?
10:43:48 <saurabhnanda_> my previous IRC window froze
10:43:55 <kadoban> OverCoder: Okay, well … start with writing 'insert' with the type it tells you.
10:44:01 <gaurav> Shockk: Develop not as in a sense of developing an App rather developing for haskell
10:44:04 <Gurkenglas> Binary tree is just list with two recursive slots instead of one.
10:44:04 <OverCoder> Gurkenglas, no
10:44:16 <OverCoder> data MessageTree = Leaf | Node MessageTree LogMessage MessageTree
10:44:19 <OverCoder> This is the data type
10:44:26 <saurabhnanda_> so, why is (Just 1) >>= (\x -> putStrLn $ show x) type incorrect?
10:44:40 <OverCoder> How would I make an insert function where I just don't have a tree already
10:44:48 <OverCoder> insert function is the next thing I should do
10:45:06 <nitrix> newtype NewEither a b = Either a b
10:45:06 <saurabhnanda_> if foo x = putStrLn $ show x // then foo :: a -> IO (), right?
10:45:18 <frerich> OverCoder: That looks remarkably similiar to http://www.cis.upenn.edu/~cis194/spring13/hw/02-ADTs.pdf
10:45:19 <nitrix> "The constructor of a newtype must have exactly one field"
10:45:20 <kadoban> OverCoder: What type does it tell you to use for the insert function?
10:45:22 <nitrix> what?
10:45:28 <OverCoder> frerich, it's it
10:45:42 <Gurkenglas> Overcoder, Node (Node Leaf "" Leaf) "" Leaf is an object of your type assuming LogMessage is String. What is the type signature of this insert function you want?
10:45:48 <OverCoder> kadoban, data MessageTree = Leaf | Node MessageTree LogMessage MessageTree
10:46:31 <kadoban> OverCoder: That's not the type of the 'insert' function. It also tells you that. Look down.
10:46:40 <OverCoder> Gurkenglas, um, /me thinks, um, genTree :: [LogMessage] -> MessageTree
10:46:49 <geoffreyiy> @pl (\(x,y) -> [x,y])
10:46:50 <lambdabot> uncurry ((. return) . (:))
10:47:00 * OverCoder reads down
10:47:01 <kadoban> OverCoder: I think the problem is that you're skipping insert and trying to go right for the part after that.
10:47:18 <geoffreyiy> @pl (\[x:y:_] -> (x,y))
10:47:18 <lambdabot> (line 1, column 3):
10:47:19 <lambdabot> unexpected "["
10:47:19 <lambdabot> expecting pattern
10:47:22 <nitrix> kadoban: Why can't I newtype NewEither a b = Either a b ?
10:47:31 <Gurkenglas> genTree (x:xs) = Node Leaf x (genTree xs) will make a degenerated tree, Overcoder
10:47:35 <OverCoder> kadoban, well no, insert is exercise 2, I am still in 1
10:47:46 <geoffreyiy> @pl (\(x:y:_) -> (x,y))
10:47:46 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . (,) . head) tail
10:48:00 <frerich> OverCoder: If you are in exercise 1, you don't need to build a tree at all. In fact, that tree type isn't even introduced yet.
10:48:34 <OverCoder> frerich, ?, what?, it's in the 'Putting the logs in order' section
10:48:40 <kadoban> OverCoder: You're misreading it. The part you're looking at is like the prelude to exercise 2, it's describing what you're going to be doing next.
10:48:53 <frerich> OverCoder: Yeah, but that is not part of the exercise 1. It's the introduction leading to exercise 2. :-)
10:48:56 <kadoban> OverCoder: 'insert' *is* how you build the tree. Do that part.
10:49:07 <OverCoder> awww
10:49:09 * OverCoder slaps himself
10:49:18 <OverCoder> Man, I was thinking and thinking all the time, ugh, thank you all :)
10:49:49 <kadoban> nitrix: You probably can I guess? I'm not sure what it really gains you though.
10:50:17 <nitrix> kadoban: I want to be able to re-implement the Functor Either e instance.
10:51:03 <nitrix> kadoban: Oh I forgot the constructor
10:53:31 <kadoban> nitrix: Sure, I just mean … it's probably going to be just as easy to make your own MyEither from the first. I dunno.
11:11:03 <Shockk> hmm was mconcat not in Prelude before 7.10?
11:12:54 <crough> Shockk: yeah, I think it was part of FTP
11:13:06 <Shockk> ahhh I see
11:13:11 <Shockk> thanks
11:13:14 <crough> of course
11:17:06 <conal> why do we still have mconcat, given fold. (perhaps already talked to death.)
11:19:27 <crough> conal- probably legacy compatibility
11:19:50 <conal> crough: perhaps so. maybe a compromise.
11:19:57 <glguy> conal: Maybe because mconcat can use information about the Monoid to be efficient
11:20:04 <glguy> while fold can use information about the container?
11:20:10 <crough> conal- we also have `>>` when `*>` does the same thing, concat when we have fold, etc etc
11:20:12 <crough> Who knows
11:20:53 <geekosaur> that is in fact my recollection, an experiment during the FTP stuff suggested that mconcat was faster as is and can;t be optimized at the level of Foldable
11:21:07 <conal> seems a shame, since these choices seem to be patching over symptoms rather than fixing a general problem.
11:21:38 <conal> in that the same desire for optimization applies to containers other than [].
11:21:43 <geekosaur> and in fact there's a few outstanding questions in that area with what *was* moved to Foldable
11:21:53 <augur> conal: there's lots of stuff that exists solely for implementation details rather than meaning. all of Foldable and Traversable, for instance
11:23:31 <conal> since i shifted my focus to parallel-friendly functional programming, i'm more sensitive to the harm of encouraging the list/[] type. it's maybe an old habit from Lisp.
11:27:45 <geekosaur> one of the issues here btw is that in many ways yu can only find out the real impact by deploying the change. because there's a core unsolvable social issue in that you can never test something like FTP sufficiently ahead of time; too many code bases are not going to be accessible for politica or legal reasons
11:30:07 <vkt> are the following two types are equivalent: '[[a]] -> a' and 'List a => [a] -> a'?
11:30:50 <geekosaur> uh. what is List?
11:31:29 <geekosaur> there is no standard typeclass... and a typeclass could well mean the latter is different, in fact that's the *point* of typeclasses
11:32:15 <hatds> If equivalent means that 'List a => a' is essentially the same as [a], then why wouldn't the two function types also be equivalent?
11:32:59 <hatds> or I guess not, because then it would be [[a]] -> [a]?
11:33:16 <augur> hatds: thats more correct, yes
11:33:40 <dedgrant> vkt: The word equivalent is not quite right, because it implies reflexivity. You could write a typeclass List a such that [a] can be an isntance, you you might say that the List a can satisfy [a], but not the other way around.
11:35:36 <vkt> I interpreted semantics into List that were wrong it seems :P
11:36:29 <vkt> i thought it would be a predefined typeclass with [] as its represenation
11:36:30 <dedgrant> .. or sorry I got that backwards. [a] can satisfy List a (conversely, it might be said that List a permits [a])
11:36:44 <Peaker> hey, would using case ByteString.uncons .. of ..   be as fast as manual branching on ByteString.null, and then using ugly ByteString.head,tail ?
11:37:03 <dedgrant> vkt: There is Traversable and Foldable now.
11:37:55 <augur> vkt: fwiw what you're describing is sometimes called a tagless final coding
11:39:02 <augur> class List l where {  nil :: l a  ;  cons :: a -> l a -> l a  }   plus some laws maybe
11:39:47 <augur> the type   forall l. List l => l a    is provably equivalent to  [a]
11:41:34 <augur> theres a more general statement that says    forall r. c r => (a -> r) -> r    is equivalent to the free c of a's
11:41:51 <vkt> thx for the input guys
11:41:53 <augur> eg   forall r. Monoid r. (a -> r) -> r   is the free monoid on a's (equivalent to [a] as well)
11:42:05 <augur> Monoid r =>   not Monoid r.
11:42:48 <vkt> you lost me there :P gotta continue reading my tutorial and hope to understand it one day :P
11:42:53 <augur> :)
11:42:56 <augur> what tutorial?
11:42:57 <augur> link us!
11:43:17 <vkt> Yet another haskell tutorial
11:44:27 <vkt> https://www.umiacs.umd.edu/~hal/docs/daume02yaht.pdf
11:46:46 <shachaf> Peaker: In a simple test case they generate almost identical code.
11:47:41 <Peaker> shachaf: thanks :)
11:48:20 <shachaf> Peaker: http://slbkbs.org/be.hs.txt
11:49:03 <Peaker> shachaf: weird that the I# 0 is differently located
11:55:19 <augur> vkt: ahhh hals tutorial
11:55:30 <augur> i dont know how good it is, so i cant comment
11:55:56 <lisbeth> I've got stack succesfully installed but I am having trouble with the "stack setup" command
11:55:59 <Gurkenglas> Yea, why doesn't it inline foo1?
11:57:07 <kadoban> lisbeth: How much RAM does the machine you're using have?
11:58:30 <ksj> lisbeth can you make post a pastebin with the output?
11:59:56 <vkt> augur: im not so much concerned about the quality. I'm just trying to work through as many books and tutorials possible. It seemed like a good place to start
12:00:04 <lisbeth> I can run "stack --version" successfully
12:00:46 <augur> vkt: keep in mind that that tutorial is also 10 years out of date
12:01:05 <vkt> augur: ye already noticed that here and there
12:01:45 <vkt> im so extremely haskell illiterate that it probably doesn't matter much though :P
12:03:29 <augur> :)
12:05:32 <lisbeth> sprumge.us/MFVJ
12:05:39 <lisbeth> sprunge.us/MFVJ
12:05:48 <mchall> could someone please help a noob , I'm trying to complete the monad challenges I've got to http://mightybyte.github.io/monad-challenges/pages/ex2-4.html and am trying to convert queryGreek to queryGreek2 using the link chain my code http://lpaste.net/150894 works except when the result should be a nothing, it returns an error.
12:06:14 <ReinH> mchall: please include the error message
12:06:43 <mchall> *** Exception: C:\emacs\haskell\emacstest.hs:67:8-19: Irrefutable pattern failed for pattern Just yy
12:06:59 <mchall> these challenges use a custom prelude
12:07:26 <ReinH> mchall: Well, mm isn't necessarily a Just
12:07:38 <ReinH> neither is hm
12:08:25 <ReinH> You should be using link there
12:08:30 <django_> anyone need a remote intern :D
12:08:36 <mchall> I know, how do I change the code to use lambdas and for it to return a Nothing when it first meets one ?
12:09:26 <mchall> where should I be using link ?
12:10:29 <Gurkenglas> Try to use link (you shall not write "Just" to do it) to implement "Maybe a -> Maybe b -> (a -> b -> Maybe c) -> Maybe c", then you should be able to use that for divMay. (And then you could inline it so you don't have an extra definition ^^)
12:11:55 <ReinH> link returns Nothing when it meets a Nothing
12:12:42 <lisbeth> The guys in haskell-blah think my issue is with low ram
12:13:14 <mchall> Gurkenglas thats what I don't understand how to use divMay without implementing that ?
12:14:28 <koala_man> lisbeth: "Killed" is a typical sign of that, yes
12:14:36 <mchall> ReinH how can I get the link to return that nothing instead of passing it on? the hint for the task is to use lambdas
12:14:51 <ReinH> what do you mean? link already does that.
12:15:11 <ReinH> there's no "passing on" unless you pass it on by using the result in something else
12:20:05 <ReinH> Start out with simpler things like link (lookupMay s d) (\val -> Just val)
12:21:03 <ReinH> If you're been shown infix syntax, that's lookupMay s d `link` \val -> Just val
12:22:09 <ReinH> *you've
12:24:15 <mchall> ReinH the error I get for that is C:\emacs\haskell\emacstest.hs:65:54-56: Couldn't match expected type `Double' with actual type `[Integer]' …     In the first argument of `Just', namely `val'     In the expression: Just val Compilation failed.
12:27:01 <mchall> ReinH how do I add the next link? this is what I am having trouble understanding
12:27:09 <norfair> Does anyone here feel like helping me with FunctionalDependencies? I thought I understood it but I'm still getting an error.
12:27:43 <ReinH> That couldn't happen unless you have an incorrect type annotation.
12:28:40 <johnw> norfair: can you paste what you have?
12:28:50 <norfair> -- | A class of datatypes representable as a graph with a given config.
12:28:50 <norfair> class Graph g c | c -> g where
12:28:51 <norfair>     -- | The most general way to draw a @g@.
12:28:51 <norfair>     renderGraph :: c -> g -> DotGen ()
12:28:51 <norfair>     -- | The default config for rendering a @g@.
12:28:51 <norfair>     defaultRenderConfig :: c
12:29:01 <ReinH> norfair: for future reference, please use a paste service
12:29:06 <norfair> right!
12:29:09 <norfair> good point.
12:29:17 <ReinH> Well, johnw did tell you to paste it. :)
12:29:23 <johnw> sorry, ambiguous
12:29:31 <ReinH> I blame everyone.
12:29:41 <johnw> norfair: you need g -> c for defaultRenderConfig to work right
12:30:09 <norfair> Right
12:30:11 <johnw> alternatively, you can not use FunctionalDependencies at all and use defaultRenderConfig :: Proxy g -> c
12:30:19 <norfair> but I also want this: renderDefault :: Graph g c => g -> DotGen ()
12:30:29 <norfair> so ideally I'd have the arrow go both ways
12:30:42 <johnw> you just need a way to know what g is for any given c
12:30:54 <norfair> yes. And the other way around
12:30:58 <johnw> right
12:31:38 <norfair> You made me figure out that I was getting a different arrow when I switch around the arrow. Thanks!
12:31:52 <norfair> GHC errors can be noisy
12:32:24 <ReinH> t let link = (>>=) in lookup 1 [] `link` \k -> lookup k [] `link` \v -> Just v -- mchall
12:32:35 <ReinH> :t let link = (>>=) in lookup 1 [] `link` \k -> lookup k [] `link` \v -> Just v -- mchall
12:32:37 <lambdabot> Maybe b
12:33:31 <norfair> Aha, figured it out: Graph g c | c -> g, g -> c
12:33:39 <johnw> yep
12:33:47 <mchall> ReinH it uses a custom Prelude those functions aren't available
12:33:58 <mchall> ReinH yes I've just tried it in the repl and that works, where do I add the next link. When I 've tried adding in links before I either end up with too many arguments or the variables I want not being in scope
12:34:06 <ReinH> mchall: yes, but they are the same shape as your functions
12:34:11 <ReinH> so they work by analogy
12:34:12 <norfair> Thanks @Johnw and @ReinH
12:34:35 <ReinH> mchall: I just showed you multiple links
12:35:17 <ReinH> :t let link = (>>=) in lookup 1 [] `link` \v1 -> lookup 2 [] `link` \v2 -> Just (v1 + v2) -- another example of multiple links
12:35:18 <lambdabot> Num b => Maybe b
12:36:46 <mchall> ReinH thank you very much for your help
12:36:52 <ReinH> yw
12:47:29 <mpickering> is there a dlist type in base?
12:54:33 <ChristianS> mpickering: no, but there's the dlist package
13:06:06 * hackagebot nbt 0.6 - A parser/serializer for Minecraft's Named Binary Tag (NBT)  data format.  https://hackage.haskell.org/package/nbt-0.6 (AdamFoltzer)
13:10:09 <dwn> can't foldr and map be used for the same thing?
13:10:18 <dwn> like foldr/l just seems like a more complex map
13:10:49 <dolio> There's also `Endo [a]`.
13:11:18 <Ankhers> dwn: They can. But folds can do things that a map cannot.
13:11:35 <Ankhers> > foldl' (+) [1,2,3]
13:11:36 <lambdabot>      No instance for (Typeable t0)
13:11:37 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
13:11:37 <lambdabot>        arising from a use of ‘show_M678775967858074909418971’
13:11:46 <Ankhers> :t foldl
13:11:47 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
13:11:49 <mniip> map f = foldr ((:) . f) []
13:11:49 <Ankhers> :t foldl'
13:11:51 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
13:12:01 <Ankhers> > foldl' (+) 0 [1,2,3]
13:12:04 <lambdabot>  6
13:12:40 <Ankhers> dwn: You can't accumulate to a single value like that with map.
13:12:42 <dwn> o
13:12:57 <dwn> yeah for some reason I was thinking you could 
13:16:52 <ReinH> dwn: map f = foldr ((:) . f) []
13:17:06 <ReinH> oh, mniip said that
13:17:15 <mniip> :}
13:17:53 <dwn> ty <3
13:18:35 <ReinH> mpickering: sure, String -> String is a dlist type ;)
13:19:30 <ReinH> > foldr (.) id [("Hello "++), ("World" ++)] ""
13:19:32 <lambdabot>  "Hello World"
13:19:53 <ski> @type showString
13:19:54 <lambdabot> String -> ShowS
13:20:06 <ReinH> ShowS is in base
13:20:25 <ReinH> @src ShowS
13:20:26 <lambdabot> type ShowS = String -> String
13:21:07 * hackagebot strict-base-types 0.5.0 - Strict variants of the types provided in base.  https://hackage.haskell.org/package/strict-base-types-0.5.0 (SimonMeier)
13:22:59 <reconmaster> anyone here have experience with diagrams-latex and thoughts regarding tikz, asymptote, etc?
13:23:57 <byorgey> reconmaster: feel free to also ask in #diagrams.  I use diagrams-latex a lot, though I don't really have much experience with tikz or asymptote to compare it to
13:24:22 <reconmaster> byorgey: ok, thanks. i'm mainly in need of something that can easily handle 3D transformations
13:24:42 <byorgey> reconmaster: 3D transformations of what?
13:26:38 <reconmaster> byorgey: really just need an environment i can easily handle homogeneous coordinate/object transforms and then subsequently incorporate those as vectorized images in my tex file
13:27:50 <byorgey> reconmaster: well, the reason I ask specifically is that diagrams has support for 3D transformations of paths, and for projecting paths into 2D and then drawing them
13:28:03 <byorgey> so as long as you just want to draw wireframe sorts of things it works
13:28:23 <byorgey> but more general 3D stuff is not well supported yet
13:32:08 <reconmaster> i see, i really like the philosophy behind it. i'm just not sure of the best way to get my diagrams into tex yet
13:32:46 <byorgey> reconmaster: do you have any examples of the kind of diagrams you want to make?
13:36:07 * hackagebot remote-monad 0.1.0.0 - An parametrizable Remote Monad, and parametrizable Applicative Functor  https://hackage.haskell.org/package/remote-monad-0.1.0.0 (AndyGill)
13:40:40 <valentine-bot> bye fam
13:42:54 <reconmaster> byorgey: i am generally showing some geometry transforms that are handled by a paramaterized modelling thing I wrote in python
13:43:30 <reconmaster> i have no problem learning haskell if diagrams is the way i want to go about generating the tex figures
13:43:52 <reconmaster> was dumping eps files out of python before, but i am not sure that is the best way
13:45:42 <byorgey> reconmaster: I'd have to see some examples of the kind of things you want to draw in order to be able to tell you whether I think diagrams would work well for you
13:46:08 * hackagebot language-ecmascript 0.17.0.2 - JavaScript parser and pretty-printer library  https://hackage.haskell.org/package/language-ecmascript-0.17.0.2 (AndreyChudnov)
13:46:11 <byorgey> I don't really understand what you mean by "geometry transforms handled by a parameterized modelling thing"
13:47:15 <reconmaster> it models an projective x-ray imaging system
13:47:38 <reconmaster> i need to show volumetric patient projections after undergoing a treatmetn transform
13:48:07 <reconmaster> that is all done in python, i want a way to create simple schematics in the tex file to illustrate the concept
13:48:40 <reconmaster> simple 3 ellipsoid object will suffice for a "patient"
13:49:16 <reconmaster> the transforms are the complicated part i want something like haskells approach with diagrams to model
13:50:01 <byorgey> well, diagrams doesn't yet have a way to directly draw 2d projections of 3d solids like ellipsoids.  But you can fake it by e.g. creating two perpendicular ellipses in 3D and then projecting those into 2D
13:50:26 <byorgey> sure, that makes sense
13:50:51 <byorgey> I think diagrams could work well for what you are trying to do
13:51:20 <reconmaster> that is my impression as well from reading the documentation, i just dont want to model it all and end up with something i can't use in latex
13:52:01 <dfeuer> What's the story behind Control.Categorical.Functor.Functor? What are f, r, and t supposed to represent?
13:52:14 <ReinH> dfeuer: o/
13:52:18 <reconmaster> but thanks for the feedback, i'll do some simple tests to see if that works for me
13:53:33 <ReinH> dfeuer: r and t are categories. C.C.F.Functor f r t represents a functor f from r to t
13:54:27 <ReinH> i.e., f is the object mapping part and fmap is the arrow mapping part
13:54:45 <dfeuer> ReinH, hrrr..... okay, I think I sort of see.
13:54:59 <ReinH> All normal Functor instances f are C.C.F.Functor f (->) (->)
13:55:05 <ReinH> i.e., functors from Hask to Hask
13:55:16 <ReinH> dfeuer: iow it's the usual notion of a functor
13:55:30 <ReinH> not one restricted to endofunctors on Hask
13:55:32 <dfeuer> ReinH, OK, I think I see.
13:56:02 <begriffs> Heads up to haskellers in the bay area - we'll be having a hack night next month. http://www.meetup.com/Bay-Area-Haskell-Users-Group/events/228137734/
13:56:10 <ReinH> begriffs: o/
13:56:30 <dfeuer> ReinH, but it's restricted to bijective ones, right?
13:56:39 <ReinH> dfeuer: what do you mean by bijective?
13:56:41 <dfeuer> Or injective anyway?
13:56:51 <dfeuer> ReinH, sorry, I know I'm being unclear.
13:57:09 <ReinH> f is necessarily injective, being a type constructor
13:57:13 <dfeuer> Yeah.
13:57:16 <dfeuer> That's what I meant.
13:57:30 <ReinH> so yes
13:57:31 <begriffs> ReinH: I can't tell if that's a joyous symbol or if it's scolding me for posting links to IRC. :)
13:57:38 <ReinH> begriffs: it's a wave :)
13:57:48 <ReinH> _o/ <- a little man waving
14:01:08 * hackagebot pipes-transduce 0.3.3.0 - Interfacing pipes with foldl folds.  https://hackage.haskell.org/package/pipes-transduce-0.3.3.0 (DanielDiazCarrete)
14:01:43 <dedgrant> ReinH: If an endofunctor is a functor that maps a category to itself, wouldn't the functors from Hask to Hask be endofunctors on Hask as well?
14:01:44 <dmj> ReinH: could be a lightsaber dual too, o/ \o 
14:01:54 <ReinH> dedgrant: yes.
14:02:29 <geekosaur> o7         scratching my head...
14:02:45 <ReinH> geekosaur: I thought that was a salute
14:04:33 <dedgrant> ReinH: Oh I see. You're saying C.C.F.Functor is *not* restricted to Hask. I totally glazed over the 'all normal Functor instances' part.
14:07:03 <ReinH> dedgrant: Right. C.C.F.Functor f r t is a functor from category r to category t with object mapping f and arrow mapping fmap
14:07:13 <ReinH> i.e., the usual definition of a functor, embedded into Haskell
14:07:30 <geppettodivacin> Is there a way to have a function return a value of a particular type, but not be explicit about that type in the signature?
14:07:41 <geppettodivacin> For example, something like http://lpaste.net/151107
14:07:49 <geppettodivacin> Except that doesn't work.
14:07:54 <ReinH> geppettodivacin: No.
14:08:11 <ReinH> a there is universally quantified, which means your function must work for *all* a and you can't make a specific choice.
14:08:36 <Gurkenglas> "Num a => String -> a" is desugared to "forall a. Num a => String -> a". Why do you want this anyway?
14:09:08 <ReinH> The answer is really "Instead of wanting to do this, try not wanting to do this instead."
14:09:09 <geppettodivacin> I'm trying to select between a couple of different data structures that all act like a stack/queue based on a command line argument.
14:09:39 <geppettodivacin> I could put it all in the main as a switch, but I thought it would be nice to have a selector function that could just return the one I wanted.
14:10:22 <Gurkenglas> Won't you need to handle the stack and the queue differently anyway?
14:10:56 <ReinH> > case True of True -> show (1 + 1 :: Int); False -> show (1 + 1 :: Integer)
14:10:58 <lambdabot>  "2"
14:11:05 <Gurkenglas> You could do 'String -> Either Int Integer; test "a" = Left 1; test "b" = Right 2'
14:11:15 <geppettodivacin> I've defined a class, and push / pop are defined differently for each.
14:11:22 <ReinH> So use the class everywhere
14:11:26 <geppettodivacin> I do.
14:11:27 <ReinH> and then select an instance in main
14:11:37 <geppettodivacin> *sigh* OK.
14:11:45 <geppettodivacin> Thanks, though!
14:11:50 <Cale> Or pass a record of the push/pop
14:12:00 <ThatTreeOverTher> I find it particularly amusing Syntastic for Haskell for Vim notes "The 'license' is AllRightsReserved. Is that really what you want?"
14:12:33 <ReinH> Just part of Haskell's well known liberal bias.
14:13:10 <ThatTreeOverTher> Oh, of course. I just found it amusing that they'd warn me about it, as if I accidentally mashed the string "AllRightsReserved" into the keyboard with my forhead :)
14:13:21 <glguy> geppettodivacin: You can do this using the existential quantification extension, or by having the function not return a value of the unknown type, but calling your function on that value directly
14:13:39 <glguy> giving you that runtime choice of which type to use from command line arguments
14:13:40 <Cale> geppettodivacin: data StackOps a = SOps { push :: a -> StackOps a, pop :: (a, StackOps a) }
14:14:01 <glguy> or you can wrap up your type in a new dictionary record instead of using typeclasses
14:14:05 <Gurkenglas> This sounds like a case for Cont.
14:15:14 <geppettodivacin> I've looked at Cont but haven't been able to understand it.
14:15:30 <geppettodivacin> Gurkenglas: How would you recommend using it here?
14:15:32 <glguy> you don't need to fuss with Cont
14:15:46 <glguy> It's a bit beside the point
14:16:15 <Cale> fromStack :: Stack a -> StackOps a; fromStack s = SOps { push = \v -> fromStack (pushStack v s), pop = let (v,s') = popStack s in (v, fromStack s') }
14:16:42 <Cale> and you can of course do a similar thing for your queue
14:16:42 <Gurkenglas> Dunno, haven't used it yet either, it just seems like it applies because you can't do foo :: Num a => String -> a, but if you were going to use it to produce an Int, you *can* do foo :: Num a => (a -> Int) -> String -> Int
14:17:43 <Gurkenglas> (Or how'd you write that? "foo :: (forall a. Num a => a -> Int) -> String -> Int"?)
14:18:19 <jophish> How often do you name a type variable with a multicharacter name?
14:18:34 <jophish> I don't do it very often at all.
14:21:18 <glguy> geppettodivacin: You can do this http://lpaste.net/151111
14:21:35 <Gurkenglas> (And that's just "Num a => String -> Cont Int a". And I guess that Int should be generalized to r in your case.)
14:25:39 <Gurkenglas> (Although I'm not sure whether putting it as Cont rather than that nested forall thing puts us back on square one.)
14:27:01 <geppettodivacin> glguy: I have no idea how that works.
14:27:17 <glguy> how what works?
14:27:32 <geppettodivacin> stack_dispatch doesn't actually return anything.
14:27:58 <geppettodivacin> Is it basically just a dummy function?
14:27:59 <glguy> you'd change the return type
14:28:15 <glguy> make it an Int, or IO () or whatever
14:28:20 <geppettodivacin> Oh.
14:28:36 <geppettodivacin> Wow, that's weird, but I guess it works.
14:29:09 <geppettodivacin> I'm looking into existential types right now to see if that would work.
14:50:41 <Shockk> I'm starting to recognize names when I find packages on hackage, athan I just found your rose-trees package lol
14:50:56 <athan> :D
14:51:16 <athan> Shockk: I wish it was more formal :\ I kinda just duck-taped it together
14:51:31 <athan> I never even use the syntax I built with it. Really it was a formalization for the tries package
14:51:34 <athan> @hackage tries
14:51:36 <lambdabot> http://hackage.haskell.org/package/tries
14:53:07 <Shockk> athan: ahh
14:54:10 <Shockk> athan: is it useful, say if I wanted a tree where each node can have an theoretically infinite number of children, and where I can look up the children by some integer id, in constant time? or am I being too specific here?
14:54:41 <athan> Shockk: I'd say you need to think about the depth and width
14:54:57 <athan> if you're using a `Data.Map` for the width, you'll have O(log n) time _per_ depth
14:55:19 <athan> where if you're just nesting `Data.Map`s to form your trie (like `Data.Trie.Map`), then you get O(n * log n)
14:55:24 * athan is pretty sure anyway :(
14:55:34 <Shockk> if I used Data.IntMap, would that be O(n) time?
14:55:50 <athan> Shockk: No, you'll still only get O(log n) for width
14:55:57 <Shockk> ahh
14:56:00 <athan> generally, I'm just making depth isomorphisc to lists
14:56:16 <athan> Shockk: It would take some creativity for O(n) width*depth :)
14:58:56 <Shockk> hmm I don't know enough about tries and rose trees to know the difference between each of them
15:01:14 <geppettodivacin> glguy, ReinH, Cale, Gurkenglas: It looks like existential types actually worked perfectly. Thanks for all the suggestions, though!
15:06:56 <Lokathor> sepBy1 :: Alternative m => m a -> m sep -> m [a]
15:06:58 <Lokathor> sepBy1 p sep = (:) <$> p <*> many (sep *> p)
15:07:22 <Lokathor> this is the normal sepBy1, but I want a variant that keeps everything parsed, including the separators
15:07:38 <Lokathor> does (sep <*> p) do that? I'm a little fuzzy on the applicative operators
15:08:57 <crough> you probably want `(,) <$> p <*> sep`
15:10:42 <crough> if you do `(,) <$> p <*> many ((,) <$> sep <*> p)` youll get a `Parser (a, [(sep,a)])` back
15:10:46 <statusfailed> Lokathor: so your separators are the same type as the parser? 
15:10:56 <statusfailed> or what crough said :D
15:11:11 <Lokathor> yeah, baically attoparsec has a "match" combinator
15:11:17 <Lokathor> and parsers doesn't
15:11:30 <Lokathor> so as i make this polymorphic, i have to replace what the person was doing with match
15:11:33 <Lokathor> which means keeping all the seperators
15:12:44 <statusfailed> Lokathor: you could probably build a match combinator yourself by reading a byte at a time, and feeding it into the parser
15:12:48 <statusfailed> that might not be a good solution though
15:13:17 <Lokathor> i thought abotu that and figured itd be a lot of trouble as soon as i looked at attoparsec's definition
15:13:48 <statusfailed> Why do you need it at all? Maybe there's an easier way?
15:15:30 <statusfailed> anybody have an example of a cabal project with a test suite?
15:15:54 <TimWolla> Hi! I have a bunch of functions with signature a -> b -> a that I want to combine into another function a -> b -> a where the second argument is the same for each of the inner functions. While I can write it like in line 7 of this paste: http://lpaste.net/7463475806832951296#line7 it will get messy real quick and I am pretty sure that there is a function for that. Can someone help me out?
15:16:10 <TimWolla> I am probably looking for some [(a -> b -> a)] -> a -> b -> a
15:16:51 <hexagoxel> statusfailed: stack
15:17:05 <Lokathor> statusfailed, https://github.com/Porges/email-validate-hs/blob/master/src/Text/Domain/Parser.hs#L16 that line, but using (CharParsing m) from Text.Parser.Char of the parsers package
15:17:17 <statusfailed> hexagoxel: really? don't I still need to set it up in cabal?
15:17:20 <Lokathor> instead of being Data.Attoparsec.BytrString.Char8
15:17:43 <dcoutts> statusfailed: there's loads of them on hackage
15:18:04 <hexagoxel> statusfailed: "stack is a cabal project that has a test-suite component" i meant to say.
15:18:44 <dcoutts> statusfailed: zlib and tar are simple little packages with test suites, reasonable example
15:19:06 <statusfailed> hexagoxel: ah! heh
15:19:12 <dcoutts> statusfailed: tar also has a benchmark
15:19:24 <statusfailed> dcoutts: oh nice, that's lovely 'n small
15:19:26 <statusfailed> thanks!
15:19:29 <dcoutts> np
15:21:18 <lingxiao_> hey all
15:21:28 <lingxiao_> could someone help me with a coq problem overa t #coq
15:23:07 <Gurkenglas> :t (.) (ala Endo foldMap) . sequenceA -- TimWolla, although I'm using way too complicated stuff here and the parameters are flipped (as I think they mathematically ought to be for this case?)
15:23:09 <lambdabot> Traversable t => t (a -> a1 -> a1) -> a -> a1 -> a1
15:23:50 <TimWolla> Gurkenglas, I can switch the parameter order.
15:24:20 <Gurkenglas> sequenceA turns [a -> b] into a -> [b] using the reader applicative
15:24:42 <Gurkenglas> (.) lifts (ala Endo foldMap) to operate on the [b] instead of the (a -> [b])
15:25:15 <Gurkenglas> "ala Endo foldMap" is "runEndo . foldMap Endo" (that's what ala does).
15:25:36 <lingxi___> ok back.
15:26:11 <lingxi___> any takers on #coq?
15:26:59 <TimWolla> Gurkenglas, thanks, I gonna Google around a bit, as I never heard about those.
15:27:01 <Gurkenglas> Endo gives (a -> a) the monoid instance of composition. ala "bestows the powers of a wrapper" onto what is passed to its second argument - in this case it makes foldMap combine the [a1 -> a1] by composition.
15:27:21 <Gurkenglas> > ala Sum foldMap [1..10]
15:27:24 <lambdabot>  55
15:28:05 <Gurkenglas> Actually you could use "foldr (.) id" instead of "ala Endo foldMap" there.
15:28:24 <Gurkenglas> Although there's never enough ala in my opinion
15:28:25 <TimWolla> That looks more familiar :-)
15:28:58 <statusfailed> TimWolla: You can apply the first argument to each function just using map: "map (\f -> f x) [a, b, c]"
15:29:13 <statusfailed> TimWolla: then use fold to do the rest
15:36:29 <TimWolla> statusfailed, sound good. I went for "combined x y = foldr ($) x $ map ($ y) [ a, b, c ]". Thanks both of you for the advice :-)
15:41:33 <boojinks> Evenin' all
15:43:41 <kurt11> What is the best way to get HUnit working in a cabal project?
15:45:24 <boojinks> I'm coming to the end of the CIS194 course and was wondering, can anyone recommend any 'general' books that I could buy to move on from there? Just fancy having something physical to pick up
15:46:13 <m1dnight_> kurt11: I can show you my repo. I spent a while on getting it working
15:46:26 <m1dnight_> Or copy the relevant parts
15:47:31 <pavonia> boojinks: By general you mean CS beyond Haskell?
15:48:17 <kurt11> m1dnight_: please do. There seem so many configuration steps and mismatched online docs.
15:48:42 <m1dnight_> Hold on, grabbing lap computing devicd
15:48:45 <boojinks> pavonia: I mean still Haskell related, just something to move on to and get my teeth stuck into without it being too narrow in nature e.g. using Haskell for x
15:49:03 <Lokathor> boojinks, http://chimera.labs.oreilly.com/books/1230000000929/index.html is free on the site, or you could buy a print copy if you want a physical book
15:50:01 <Lokathor> kurt11, https://github.com/Lokathor/roguelike-hs this has some tests using hspec, if that's close enough for you
15:50:10 <pavonia> boojinks: Types and Programming Languages by Pierce maybe
15:50:19 <kurt11> Lokathor: thanks
15:51:07 <boojinks> Thanks guys, will take a look
15:51:51 <Lokathor> i should write my next haskell article on how to get testing setup i guess
15:52:04 <Lokathor> that's two asks about the subject just this afternoon
15:52:31 <marchelzo> tapl isn't really haskell-related
15:52:51 <m1dnight_> MainTest.hs: https://www.refheap.com/114200 Types.hs (tests): https://www.refheap.com/114201 Cabal file: https://www.refheap.com/114202
15:52:56 <m1dnight_> kurt11: ^
15:53:11 <m1dnight_> I can not include the source because its an academic artefact, not sure if I can share it.
15:53:21 <m1dnight_> But you have all my code that is in ./test and the cabal file.
15:53:23 <m1dnight_> That should do it.
15:53:27 <kurt11> m1dnight_: thank you
15:54:12 <m1dnight_> And this is the tree https://www.refheap.com/114203
15:54:43 <kurt11> m1dnight_ is using a Cabal Test-Suite with exitcode-stdio-1.0 to invoke a HUnit test module
15:55:20 <Lokathor> same, but with hspec
15:55:25 <kurt11> The HUnit docs recommend something else: they recommend using a runTestTT which I don't seem to have installed with the standard HUnit package
15:55:42 <m1dnight_> All the dependencies in the cabal file work fine here if I do a clean install with cabal
15:55:45 <m1dnight_> So they should all be there..
15:55:53 <m1dnight_> Are you using a sandbox?
15:56:13 <kurt11> Also, the cabal docs encourage use of detailed-0.9 and that exitcode-stdio-1.0 is strictly for backwards compatibility with older test tool setups.
15:56:30 <m1dnight_> Yes, but it was the one that worked. I have tried several things.
15:56:36 <dcoutts> kurt11: oh, ignore that, detailed isn't ready for prime time
15:56:44 <kurt11> sandbox? no idea. I'm using stack and cabal. I am very new to Haskell build + test tools
15:56:57 <m1dnight_> oh. I use cabal `cabal sandbox init` in your project root folder.
15:57:04 <m1dnight_> But if you are using stack, i cant help you, sorry.
15:57:19 <kurt11> I thought stack basically is cabal.
15:57:36 <m1dnight_> Afaik stack uses the ghc packages and cabal .
15:57:40 <m1dnight_> Cabal*
15:57:50 <kurt11> Lokathor's project is using stack+cabal
15:57:51 <m1dnight_> and I use cabal-install, which is another abstraction that uses Cabal.
15:58:03 <kurt11> wow, this is complicated
15:58:13 <m1dnight_> https://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/ <- this may shed some light on the difference between Cabal and cabal-install
15:58:14 <kurt11> thank you for the help though everyone
15:58:21 <m1dnight_> I highly recommend the read :)
15:58:26 <kurt11> I'll read it
15:58:42 <Lokathor> kurt11, sadly, stack is "almost cabal", but some things people do with cabal don't have obvious direct versions in stack
15:58:48 <dcoutts> though some of us are trying to make it not true, so that cabal will be a package manager :-)
15:58:54 <m1dnight_> .oO(Is glad he could help somebody out for a change)
15:59:14 <Lokathor> and yes, Cabal (the library) is not the same as cabal (the binary, aka 'cabal-install')
16:00:53 <mgsloan> Lokathor: Hmm, what are these things?  As far as I know we just need split objs support.  Probably the remaining things will be covered by adding "--configure-options"
16:01:32 <mgsloan> Otherwise, there's just some issues with "stack ghci" not paying attention to configure results (but it gains the power to load multiple packages, which cabal repl cannot do)
16:01:45 <Lokathor> mgsloan, i don't recall any details, but i can tell you that i've seen older guides from time to time saying how to do some weird thing with cabal and had no idea how to approach it with stack
16:01:46 <mgsloan> Oh, and supporting compilers other than ghc
16:02:03 <mgsloan> I see, right, you will need to learn how stack works in order to adapt older guides
16:02:06 <Lokathor> i don't think stack is literally missing any features, but i think that's it's not always *obvious* what the difference is
16:02:12 <scshunt> is there a library anywhere for things which are identifiable?
16:02:21 <scshunt> like, a class which has an associated unique identifier?
16:02:27 <Lokathor> Data.Unique
16:02:29 <Lokathor> in base
16:02:42 <dcoutts> mgsloan: ah yes, the cheating multi-packages thing :-)
16:02:55 <mgsloan> Lokathor: True!  It can get confusing, since in some spots we maintian CLI consistency with cabal and elsewhere it is different
16:03:46 <Lokathor> mgsloan, i wish there was a stack version of "cabal run" that did the right thing and was also as short, just "stack run" not "stack build $$ stack exec binname" or whatever
16:03:48 <mgsloan> dcoutts: Hah yeah, not sure what to do about that.  I've considered using GHC's options parser on the stuff stored in the configure results, and then attempting to intelligently merge the flags
16:04:15 <Lokathor> scshunt, does Data.Unique do what you want?
16:04:21 <mgsloan> Lokathor: There's a stack plugin for that https://github.com/yamadapc/stack-run
16:04:22 <dcoutts> mgsloan: I think one just has to accept it can't be done in general, and identify when it's not possible and fall back to doing packages independently
16:04:41 <mgsloan> That said, not sure why yamadapc didn't make a PR to add something like "stack run", but hey
16:05:17 <Lokathor> hmm, not directly in hackage. i'll have to fiddle with that later, but thanks
16:05:18 <mgsloan> dcoutts: Right, it can't be done in general.  However, we can give the user guidance as to why the thing they're asking for might not work (mismatched -XNoImplicitPrelude)
16:05:38 <mgsloan> This is the strategy that "stack ghci" takes - it tells the user all the things that might be causing them issues
16:05:42 <dcoutts> mgsloan: or overlapping module names or .. or ..., lots of things to check unfortunately
16:06:35 <mgsloan> Yeah, but it's easy for the developer to fix these things
16:06:35 <mgsloan> Sure it doesn't work in general, but it works in practice
16:06:35 <mgsloan> and it's extremely convenient to be able to load multiple packages into ghci
16:07:38 <mgsloan> dcoutts: I do believe we were all at the same table when ezyang opened this ticket for making this feasible in general :D https://ghc.haskell.org/trac/ghc/ticket/10827
16:07:52 <dcoutts> mgsloan: sounds familiar
16:09:09 <mgsloan> Good point, we should warn about overlapping module names.  Should be easy since we're already generating an invocation of :load
16:09:40 <mgsloan> I've considered making "stack repl" invoke "cabal repl" and keeping our "stack ghci" magic
16:10:16 <mgsloan> Would resolve those cases where people are doing something fancy in their Setup.hs, and we get to keep the multipackage awesomesauce
16:10:30 <dcoutts> mgsloan: how do you decide which packages to include in the repl as bytecode, vs as object code ?
16:10:33 <luigy> mgsloan :O
16:12:39 <mgsloan> dcoutts: If you have pkgA, pkgB, pkgC in your project, and you run "stack ghci pkgA pkgB", then they will be loaded as byte-code.  If they depend on pkgC, it will be loaded as object code
16:12:59 <fizruk> @djinn (x -> y -> m) -> ((x -> m) -> m) -> ((y -> m) -> m) -> m
16:12:59 <lambdabot> f a b c = c (\ d -> b (\ e -> a e d))
16:13:04 <fizruk> nice
16:13:25 <fizruk> @djinn (a -> (b, c)) -> (x -> y -> z) -> ((x -> m) -> b -> m) -> ((y -> m) -> c -> m) -> (z -> m) -> a -> m
16:13:25 <lambdabot> f a b c d e f =
16:13:26 <lambdabot>     case a f of
16:13:26 <lambdabot>     (g, h) -> d (\ i -> c (\ j -> e (b j i)) g) h
16:13:29 <dcoutts> mgsloan: oh I see, so explicitly, simple enough. And so if you were in the pkgB dir, and did just stack ghci, it'll just load pkgB as bytecode and the others as object code?
16:13:32 <mgsloan> One bit of fanciness is that if we have "(pkgA `dependsOn` pkgB, pkgB `dependsOn` pkgC), then `stack ghci pkgA pkgC` also automatically loads pkgB, since it's an intermediate dependency of the packages being interpreted
16:13:32 <fizruk> supernice
16:13:48 <dcoutts> mgsloan: of course, has to for correctness
16:13:49 <sm> \
16:14:56 <mgsloan> dcoutts: You'd have to do "stack ghci ." in the pkgB dir.  By default "stack ghci" loads up all library components, consistent with "stack build" building them all
16:15:14 <dcoutts> mgsloan: oh, everything in the project?
16:15:19 <mgsloan> Yup
16:15:22 <dcoutts> I see
16:15:31 <mgsloan> It used to try to load all components, which was a bit nightmareish
16:15:52 <mgsloan> Meant a lot of people thought "stack ghci" was really broken, and it kinda was
16:15:59 <mgsloan> Much better now, still could use some work
16:41:23 <xzhao> How can I update every nth element in a list?
16:41:42 <xzhao> I found an example here: http://stackoverflow.com/questions/17383169/haskell-double-every-2nd-element-in-list But I want to generalize to nth element 
16:45:22 <ThatTreeOverTher> xzhao, did you see this answer http://stackoverflow.com/a/17383354/1376005
16:45:34 <ThatTreeOverTher> add more functions to the list to perform different modifications
16:45:43 <glguy> update the first element, split the rest on the ones that stay the same and the remainder of the list, repeat until the list is exhausted
16:46:22 <glguy> zipping with the list of functions is fun ,too
16:48:16 <xzhao> ThatTreeOverTher Yes but I would like to generalize to nth where n is dynamic at runtime
16:48:50 <glguy> xzhao: That's fine, the list of functions you construct can be dynamic at runtime, too
16:48:52 <ThatTreeOverTher> construct a list of functions at runtime, then?
16:50:26 <xzhao> ThatTreeOverTher hmm that should work... sry I don't have any ideas how to do that in haskell, just learn it several days ago
16:52:09 <xzhao> Do I need some helper function like "Int -> [(Int -> Int)]" ?
16:52:12 <ThatTreeOverTher> xzhao, so you could create a list of n elements where all are the identity function except for the last one, and then feed it to cycle 
16:53:01 <xzhao> I c. I will try it, thanks!
16:53:07 <ThatTreeOverTher> no problem!
16:55:10 <finlay> aaronm04 ?
17:03:12 <KaneTW> is there a way to tell ghc that a type class is defined for every member of a kind
17:03:38 <ThatTreeOverTher> how do I index a list returning a Maybe? I tried Hoogling "[a] -> b -> Maybe a" but that didn't give me anything
17:11:49 <EvanR> ThatTreeOverTher: try looking in the package `safe'
17:12:14 <EvanR> ex. atMay :: [a] -> Int -> Maybe a
17:13:44 <ThatTreeOverTher> EvanR, thank you! Next time I need to find a function like this, how can I find it?
17:15:29 <KaneTW> hayoo, hoogle
17:16:45 <geekosaur> the problem with hoogle is that by default it searches only the libraries that come with ghc. fpcomplete has one that searches stackage.
17:16:51 <scshunt> Lokathor: Thank you, that's not quite what I meant though :)
17:16:54 <geekosaur> hoogle cannot as yet handle all of hackage, though
17:17:24 <scshunt> something like id :: a -> Id a
17:17:32 <EvanR> ThatTreeOverTher: note that searching for [a] -> b -> Maybe a, wasnt exactly right
17:17:38 <geekosaur> (hayoo does search all of hackage. it is however not as good at "guessing" types)
17:17:55 <EvanR> ThatTreeOverTher: there is no way that your function could have had that type
17:18:15 <EvanR> (for all b)
17:18:31 <ThatTreeOverTher> I did try changing b to Int but that didn't help so I didn't mention it
17:18:41 <ThatTreeOverTher> I realize that was an error now, though
17:18:52 <EvanR> right, because hoogle doesnt search hackage
17:19:08 <ThatTreeOverTher> is there a way to change that?
17:19:18 <EvanR> i hate to say it, but stack overflow or this channel is the best way to figure stuff out ;)
17:19:23 <geekosaur> [29 01:16] <geekosaur> hoogle cannot as yet handle all of hackage, though
17:19:54 <ThatTreeOverTher> you say that, but what prevents it?
17:20:06 <geekosaur> memory, I think
17:20:12 <ThatTreeOverTher> simply curious, I know it's not just a checkbox- ah, okay
17:20:39 <geekosaur> hayy isn;t as thorough so uses less memory to index, but that also means it isn;t quite as good at finding "nearby" types
17:20:51 <geekosaur> *hayoo
17:20:53 <ThatTreeOverTher> do they not use databases?
17:21:40 <ThatTreeOverTher> or rather, is the entire DB in-memory?
17:21:57 <geekosaur> I think hoogle currently does it in memory
17:22:05 <geekosaur> it predates the persistent database stuff
17:22:55 <ThatTreeOverTher> hm. maybe I'll try and fix that once I've learned enough haskell
17:23:26 <geekosaur> hoogle would definitely benefit from more people working on it. I think currently it's one person who has other things they have to work on as well
17:23:54 <geekosaur> of course, that's more or less the story of open source projects >.>
17:24:01 <EvanR> need an AI to review the community and identify which libraries are considered good enough to be included in the results
17:24:39 <ThatTreeOverTher> why not include them all, but score "popular" ones/Prelude above less popular ones
17:24:54 <EvanR> ah popularity
17:25:04 * EvanR switches to PHP immediately
17:25:11 <ThatTreeOverTher> rofl
17:25:38 <ThatTreeOverTher> what do you propose? teaching a machine-learning program to identify idiomatic and pleasing Haskell code?
17:25:46 <luigy> interesting the top one would change everyday with js frameworks/libs
17:25:51 <ThatTreeOverTher> (I mean, it sounds like a lot of fun, but practicality...?)
17:26:04 <ThatTreeOverTher> hahaha that's precisely why I stopped using JS
17:27:19 <ThatTreeOverTher> I think it'd be easy enough to trawl all the GitHub projects, reading all their cabal/stack package list files, figuring out who uses what
17:27:30 <ThatTreeOverTher> the only issue would be keeping such an index up to date
17:28:11 <EvanR> theres just a whole lot of them
17:28:25 <EvanR> theres no review process on hackage
17:29:04 <ThatTreeOverTher> so we analyze github and sort by most used libraries?
17:29:18 <ThatTreeOverTher> as an aside, what is the best way to interface with a database in Haskell?
17:29:29 <dcoutts> ThatTreeOverTher: or analyse the hackage index. People have done that already.
17:29:36 <dcoutts> graph popularity measures
17:30:05 <ThatTreeOverTher> oh, which libraries use which other libraries? that works too, and doesn't depend on GitHub
17:30:12 <ThatTreeOverTher> (you may be able to tell that I'm new here)
17:30:19 <EvanR> downloads probably
17:30:47 <ThatTreeOverTher> even better!
17:36:07 <geekosaur> also see packdeps.haskellers.com
17:36:23 <EvanR> ThatTreeOverTher: food for thought http://stackoverflow.com/questions/24462070/reconciling-lens-usage-with-database-access
17:37:47 <ThatTreeOverTher> SQL-like DSL for Haskell
17:37:48 <ThatTreeOverTher> interesting
17:38:35 <EvanR> the DSL pattern is very common
17:38:40 <scshunt> yeah
17:39:41 <scshunt> I want a dependently typed system that automatically determines what queries you want, optimizes them, and compiles the sprocs for you
17:40:36 <EvanR> i have a plan for that
17:40:44 <scshunt> :O
17:40:45 <ThatTreeOverTher> theoretically all you would need to do is generate SQL with your new fancy language thing, the rest could be done by a DB
17:41:15 <EvanR> yes using existing RDBMS backends would be nice
17:41:22 <EvanR> some projects dont though
17:41:32 <ThatTreeOverTher> what do they do instead?
17:41:34 <EvanR> either way whatever works
17:41:52 <ThatTreeOverTher> oh, in-memory stuff
17:41:53 <ThatTreeOverTher> gotcha
17:42:03 <EvanR> theres in memory, and doing persistence yourself
17:42:24 <EvanR> note that acid-state, which is in memory, in persistent
17:42:27 <EvanR> is persistent
17:42:54 <EvanR> however its not that easy to use, as far as utilities go, which is a huge plus for RDBMS workflows
17:43:59 <EvanR> getting things to work is one thing, but adhoc messing around, inspection, fixing errors, backups is something existing platforms should help with
17:44:24 <EvanR> datomic (clojure) is a great example of where that stuff is missing, so the database is almost useless no matter how awesome
17:44:37 <ThatTreeOverTher> yeah, I remember looking at datomic
17:44:45 <ThatTreeOverTher> good idea, but no tooling
17:44:57 <EvanR> "all you need is a repl" is not true
17:45:13 <ThatTreeOverTher> repls are my least favorite way to do just about anything
17:45:16 <Shockk> speaking of acid-state actually, I have a quick question
17:46:22 <Shockk> if I want to store a tree in acid-state defined something like data Node = Node NodeData (Map NodeID Node),
17:46:36 <ThatTreeOverTher> EvanR, so you're planning to write this SQL-DSL thing?
17:46:48 <Shockk> if I want to insert a node into one node a few levels deep, do I have to reconstruct that entire data structure or will any sharing be done and stuff?
17:46:51 <ThatTreeOverTher> or is your plan something else
17:47:00 <EvanR> i had a bike shedding project like that in mind
17:47:34 <EvanR> but better look at existing projects like haskelldb, ive also heard about persistent and opaleye
17:47:34 <ThatTreeOverTher> what made it "bike shedding"? being able to speak haskell to a database would be pretty neat
17:47:58 <EvanR> theres already lots of projects like that, with the bonus that they exist
17:48:18 <ThatTreeOverTher> oh, existence is usually one of the first things I look for in a project, so that's a plus
17:48:29 <EvanR> Shockk: so your value is in memory and is updated like any map would be normally
17:48:42 <EvanR> that is, with as much sharing as possible
17:49:01 <EvanR> when you update the database only the update action is recorded to the log
17:49:13 <EvanR> a full snapshot isnt stored until a checkpoint
17:49:23 <Shockk> ohhhh right
17:49:40 <Shockk> I forgot that acid-state works in that regard
17:50:32 <Shockk> thanks
17:52:51 <KaneTW> i have this http://lpaste.net/3069794361186189312 and i basically need to do something like the 'case toSing t -> ...' does here, except for the ConvertWire context
17:53:55 <KaneTW> but i'm not sure how to do this without making a huge case statement for each type in PacketType (around 60)
17:55:05 <KaneTW> ideally i'd like something case f sb of { Evidence -> <do stuff with proper context>; _ -> error "no proper context exists, programmer error" }
17:59:57 <KaneTW> i put the code on github https://github.com/KaneTW/knxd-native-client
18:08:22 <EvanR> KaneTW: heh, if you put the language pragmas on separate lines.. i would be able to more easily tell that this code is over my head
18:10:27 <KaneTW> EvanR: it might be a bit more pragmas than needed :v
18:10:43 <KaneTW> i haven't reduced them yet from when i was trying different approaches
18:13:59 <KaneTW> i think i found a workaround
18:14:09 <KaneTW> singletons has a sCases function and it seems to do just what i want
18:17:30 <KaneTW> it's really ugly but it kind of works i think
18:23:34 <onur_> Hey
18:23:45 <onur_> I want to ask a question
18:24:08 <Axman6> hello!
18:24:15 <onur_> Prelude Data.Ratio> toRational 1.2 5404319552844595 % 4503599627370496 Prelude Data.Ratio>
18:24:37 <onur_> when i check equality for this output and 6/5 it returns false
18:24:58 <onur_> but when i type it on calculator they are same
18:25:21 <onur_> also toRational 1.25 returns normally 5/4
18:25:29 <onur_> 5 % 4 *
18:25:50 <onur_> anyone can explain why? please :)
18:25:57 <ThatTreeOverTher> > toRational 1.2 5404319552844595 % 4503599627370496
18:25:59 <lambdabot>      Couldn't match expected type ‘Integer -> a’
18:25:59 <lambdabot>                  with actual type ‘Ratio Integer’
18:26:00 <lambdabot>      The function ‘toRational’ is applied to two arguments,
18:26:01 <KaneTW> 1.2 is floating point
18:26:06 <KaneTW> > toRational 1.2
18:26:08 <lambdabot>  5404319552844595 % 4503599627370496
18:26:16 <KaneTW> 6 % 5 has no exact floating point representation
18:26:36 <ThatTreeOverTher> floating point and equality don't mix
18:27:16 <KaneTW> > toRational 1.2 - (6 % 5)
18:27:18 <lambdabot>  (-1) % 22517998136852480
18:27:50 <tsani> The recursion-schemes package doesn't define any monadic recursion schemes (I'm looking for a monadic catamorphism, specifically). What's the reason that it's missing? Is there another package that provides something like cataM ?
18:28:14 <KaneTW> > log (toRational 1.2 - (6 % 5)) / log 2
18:28:16 <lambdabot>      No instance for (Floating Rational) arising from a use of ‘log’
18:28:16 <lambdabot>      In the first argument of ‘(/)’, namely
18:28:16 <lambdabot>        ‘log (toRational 1.2 - (6 % 5))’
18:28:22 <EvanR> ThatTreeOverTher: floating point has equality, which should work. but floating point and decimal dont mix
18:28:25 <tsani> I noticed data-fix provides cataM, but overall the recursion-schemes package seems better.
18:28:29 <KaneTW> > log (fromRational $ toRational 1.2 - (6 % 5)) / log 2
18:28:31 <lambdabot>  NaN
18:28:37 <KaneTW> well, ok
18:29:00 <EvanR> computable reals and equality dont mix
18:30:43 <EvanR> 1 and 0.999... are equal, but good luck writing a general algorithm that knows that
18:32:15 <uikkusu> vhosts /Cloaks
18:32:24 <EvanR> KaneTW: log of a negative i guess
18:32:34 <KaneTW> EvanR: yeah, i wanted the bottom part of the ratio
18:33:36 <onur_> well, may be i am missing something but why toRational 1.25 is so normal and 5 % 4?  and  5 % 4 == 5/4 = True? 
18:33:55 <ReinH> onur_: because of floating point numbers
18:33:56 <onur_> what is difference between 1.2 and 1.25 in this situation
18:34:02 <KaneTW> their representation in base 2
18:35:42 <ReinH> On the other hand,
18:35:46 <ReinH> > 1.2 :: Rational
18:35:48 <lambdabot>  6 % 5
18:35:48 <EvanR> 5/4 and 6/5 one has terminating expansion in base 2, the other dont
18:36:13 <ReinH> :t 1.2
18:36:15 <lambdabot> Fractional a => a
18:39:27 <onur_> thanks but i can't get it now, i need to think about it in toilet wait :p
18:41:44 <EvanR> basically floats dont have enough bits to store an infinite sequence of 1.2 = 1.00110011...
18:42:14 <EvanR> and decimal fixed point wouldnt be able to store 1/3 = 0.333333...
18:42:30 <EvanR> (neither would decimal floating point)
18:42:40 <ReinH> Meanwhile, 1.25 is 1.01 in base 2
18:42:42 <EvanR> which is a ridiculous technology
18:58:30 <magnap> Hey all! Can anyone here help me with a type problem in my xmonad config?
19:08:48 <EvanR> hrm, vinyl seems pretty cool but its using undecidable instances
19:09:09 <EvanR> so either theres a way to screw up using it, or this is a case where undecidable instances is useful
19:09:55 <Cale> EvanR: Undecidable instances tend to be needed whenever you're (ab)using multiparameter type classes and fundeps to do type level computation.
19:10:36 <onur_> i am back, let's check if i understand it true, toRational working at binary and converting binary result to decimal? 
19:11:11 <EvanR> i see
19:11:20 <ThatTreeOverTher> what are undecidable instances?
19:12:00 <EvanR> as i understand it, when you write an instance with a constraint, the instance head must be smaller than the constraint, which ensures the constraint solver terminates
19:12:13 <EvanR> which is good
19:12:36 <EvanR> undecidable instances turns that requirement off
19:12:50 <EvanR> which allows arbitrary computation using instance declarations
19:13:18 <maybefbi> has anyone used Data.Bson and Data.MongoDB? i need to recursively populate all DBRefs with documents from other collections. I have some code but it only populates everything upto the first level. Not sure why. can anyone help?
19:14:08 <ThatTreeOverTher> yeah population in MongoDB is only at the first level, you usually have to ask a library to do it for you
19:14:24 <ThatTreeOverTher> (in order to make it recursive, at least)
19:14:42 <maybefbi> ThatTreeOverTher, yes im writing a few functions to do that
19:14:50 <maybefbi> it works for the first level of dbrefs
19:14:58 <maybefbi> but not the dbrefs within dbrefs
19:15:12 <ThatTreeOverTher> have you tried running the function recursively?
19:15:14 <maybefbi> even though im recursing through the inards
19:15:32 <maybefbi> yes my function is recursive
19:16:15 <maybefbi> im worried if laziness is prevent inards from being populated
19:16:20 <maybefbi> *preventing
19:16:34 <maybefbi> *innards 
19:16:34 <EvanR> Cale: i feel like something like vinyl shouldnt need general recursion?
19:17:42 <EvanR> maybefbi: as long as youre using IO, laziness can't stop your commands from executing
19:17:49 <EvanR> (unless clojure)
19:17:52 <EvanR> (unlike)
19:18:13 <ThatTreeOverTher> isn't vinyl that gl library
19:18:15 <maybefbi> hmm ok im inside Action IO Document. so i guess that means i just need to liftIO or something
19:18:40 <EvanR> ThatTreeOverTher: i see vinyl-gl which is something for GLSL
19:19:57 <EvanR> but the dep lib vinyl is for "extensible records"
19:22:06 <domgetter> I hope you don't mind me asking a Monad question.  I know that the natural numbers with addition form a monoid, so if a monad is a monoid, what are the elements of the set, and what is the binary operator?
19:23:02 <Cale> domgetter: A monad is not a monoid in the usual sense at all
19:23:07 <domgetter> Would it be correct to say that each monad has its own identity element and its own binary operator?  And if all this is correct, is a monad a set of functions and a binary operator which composes functions in some way?
19:23:33 <domgetter> Cale: so it's not a set which has the properties of closure, identity, and associativity?
19:23:41 <Cale> It's not a set at all
19:24:07 <Cale> It's an endofunctor which has properties which are analogous to the properties of a monad if you look at them in just the right way
19:24:17 <Cale> It's an endofunctor which has properties which are analogous to the properties of a monoid* if you look at them in just the right way
19:24:30 <domgetter> if I replace the word "set" with "class", will my statements be more accurate?
19:24:33 <Cale> no
19:25:24 <EvanR> the classic assertion is its a "monoid in a category of..."
19:25:25 <Cale> You need to replace "set" with "endofunctor", and "Cartesian product" (inside the definition of the multiplication) with "composition of functors", and "function" with "natural transformation"
19:25:30 <EvanR> so this is different from monoid
19:26:09 <Cale> and you have to take the identity element, which is normally just an element of the monoid's set, and think of it instead as a function from a one-element set
19:26:26 <Cale> and then in the translation to the definition of a monad, that one element set becomes the identity functor
19:27:00 <Cale> (note that the one element set behaves in a similar way with respect to Cartesian product as the identity functor behaves with respect to composition of functors)
19:27:03 <domgetter> Cale: are you speaking in terms of category theory or computer programming?
19:27:07 <Cale> Category theory
19:27:33 <magnap> Sorry to interrupt you, but can anyone of you help me with a type problem in my xmonad config?
19:27:38 <Cale> Because these concepts are needed if you want to think of monads and monoids as being at all very similar.
19:27:59 <Cale> They're both examples of what's called a "monoid object"
19:28:24 <ThatTreeOverTher> feel free to ask your question magnap!
19:28:34 <ThatTreeOverTher> (not that I know anything about xmonad)
19:29:08 <Cale> Note also that #xmonad exists
19:29:09 <domgetter> Is it false to say that functions with composition form a monoid? In the same way that matrices with matrix multiplication do and the natural numbers with addition do?
19:29:33 <Cale> domgetter: Functions from a particular set to itself form a monoid.
19:29:39 <Axman6> iirc, endomorphisms with composition do, hence why we have Endo
19:29:42 <magnap> Cale: Noone responds there
19:29:44 <EvanR> also #categorytheory exists ;)
19:29:49 <Axman6> :t Endo
19:29:51 <lambdabot> (a -> a) -> Endo a
19:29:52 <Cale> EvanR: fair enough!
19:30:55 <domgetter> EvanR: would it be more appropriate to ask my monad questions over there?
19:31:05 <EvanR> probably not
19:31:20 <domgetter> Cale: thank you, btw for trying to help me come to an understanding
19:31:56 <magnap> What it comes down to is that I can't unify "Layout" with "Choose Tall (Choose (Mirror Tall) Full)", despite http://xmonad.org/xmonad-docs/xmonad/XMonad-Core.html#t:Layout claiming that Layout holds any object in Read and LayoutClass, and both Choose a, Tall, Mirror a, and Full being in both typeclasses
19:32:14 <EvanR> domgetter: re your question about function composition monoids, note that a category with 1 object is a monoid (with composition as the operation), just an example
19:32:15 <Cale> domgetter: anyway, the very vague gist of it is that
19:32:18 <Cale> :t return
19:32:20 <lambdabot> Monad m => a -> m a
19:32:43 <EvanR> analogous to the Endo monoid
19:32:56 <Cale> looks a little bit like the map from the one element set to the monoid which picks out the identity element
19:32:58 <Cale> and
19:33:01 <Cale> :t join
19:33:03 <lambdabot> Monad m => m (m a) -> m a
19:33:13 <Cale> looks a little bit like the multiplication map
19:33:41 <Cale> and if you make the connection precise, you find that the laws for a monad are indeed analogous to the laws for a monoid
19:33:43 <domgetter> I don't know what you mean by "multiplication map"
19:33:51 <Cale> I mean the function M x M -> M
19:33:53 <Cale> for the monoid M
19:34:08 <Cale> which is part of the definition of a monoid
19:34:13 <domgetter> what is x in that context?
19:34:19 <domgetter> the cartesian product?
19:34:19 <Cale> Cartesian product
19:34:20 <Cale> yeah
19:34:33 <domgetter> so M must be a set of things, no?
19:34:36 <Cale> yeah
19:34:38 <domgetter> to have a cartesian product
19:34:49 <dolio> EvanR: Also, Set is a 2-category with one object, and the monads in that category are monoids.
19:34:53 <Cale> Yeah, here I mean an ordinary monoid in the category of sets
19:34:59 <EvanR> or you could be in a cartesian closed category
19:35:05 <dolio> In that 2-category, even.
19:35:15 <domgetter> So a monad is a set.  what is it a set of?
19:35:19 <Cale> domgetter: Category theorists will sometimes use the word "monoid" and mean something more general than what an average mathematician would mean by "monoid"
19:35:24 <domgetter> the set of natural numbers has numbers in it
19:35:28 <Cale> no
19:35:30 <domgetter> what does the set that is a monad have in it?
19:35:31 <Cale> A monad is not a set
19:35:40 <domgetter> you said it was just a few statements ago
19:35:45 <Cale> Where?
19:35:45 <EvanR> dolio: ah, 2-categories
19:35:50 <domgetter> domgetter
19:35:50 <domgetter> so M must be a set of things, no? 
19:35:51 <domgetter> 19:34:08Cale
19:35:51 <domgetter> yeah
19:36:04 <Cale> A *monoid* is a set
19:36:11 <Cale> A monad is not.
19:36:23 <domgetter> if it's not a set, what is it?
19:36:41 <Cale> Both monoids and monads are examples of what are called "monoid objects" in different categories
19:36:58 <Cale> Ordinary monoids being monoid objects for the category of sets
19:37:11 <Cale> Monads being monoid objects for the category of endofunctors on some category C
19:37:47 <Cale> If your goal is to understand monads for programming btw, this is not a reasonable approach to take unless you already know a lot of mathematics.
19:38:30 <EvanR> in both cases, Set and C are also equipped with a cartesian product
19:38:33 <EvanR> right
19:38:55 <EvanR> or is that implied by the monoid object
19:39:22 <KaneTW> i got it to work
19:39:31 <KaneTW> but the solution is hacky as hell
19:39:40 <Cale> C may not have a product
19:39:43 <domgetter> whats the difference between being a monoid and being a monoid object?
19:39:59 <KaneTW> essentially made a giant function using TH that creates an evidence object
19:40:32 <Cale> domgetter: Plain "monoid" is usually reserved for the ordinary notion of monoids which are sets equipped with an associative binary operation with an identity element.
19:40:38 <Axman6> So I'm still trying to figure out what the state of the art is for error handling in Haskell. currently working with a library which uses IO (Either LibError a) a lot, occasionally just using Maybe. I started using ExceptT yesterday, but should probably be using EitherT afaict... any good blog posts about this anyone can recommend?
19:40:46 <zd234> what tool should I use for *.hs -> html file, where the html file has headings generated, so I can link to particular lines of the html file? [in fact, the tool that hackage uses for displaying source would be nice]
19:40:48 <Cale> domgetter: "Monoid object" refers to a vast generalisation of that concept.
19:41:12 <domgetter> sort of like "monoidal thingy-type thing"
19:41:18 <Cale> domgetter: See https://en.wikipedia.org/wiki/Monoid_(category_theory) for the definition of a monoid object.
19:41:52 <domgetter> "a monoid (or monoid object)"
19:42:00 <Cale> domgetter: In the context of a book or article about category theory, sometimes authors will say simply "monoid" when they mean this generalised notion of monoid object and it's understood what's meant.
19:42:04 <domgetter> does that not imply that there's no difference?
19:42:29 <Cale> domgetter: The traditional definition of a monoid is a special case of a monoid object.
19:42:40 <Shockk> zd- oh they left
19:43:28 <Cale> domgetter: When most people say "monoid" out of context, most of the time they won't be referring to the generalisation.
19:44:27 <tremon> magnap: the data constructor for Tall takes multiple arguments
19:45:08 <wedens> I have .so and .a files in extra-lib-dirs. if .so is present, binary is dynamically linked. if only .a is present, statically. how can I tell ghc/cabal/stack to always link library from extra-libraries  statically?
19:45:35 <Cale> domgetter: See also https://en.wikipedia.org/wiki/Monoidal_category#Formal_definition
19:46:36 <magnap> tremon: I think it was an error of polymorphism, in the end. Solved it anyway
19:46:49 <tremon> good :)
19:47:17 <KaneTW> poor ghci
19:47:30 <KaneTW> <interactive>:25:6: My brain just exploded
19:47:41 <ThatTreeOverTher> lol how do you do that?
19:47:49 <KaneTW> "I can't handle pattern bindings for existential or GADT data constructors."
19:48:00 <Cale> domgetter: The thing which makes this connection work is that the category of sets, with a one-element set taken as I, and the Cartesian product taken as ⊗, is one example of a monoidal category, and for any category C, the category of functors C -> C (and natural transformations between them), with the identity functor taken as I, and composition of functors taken as ⊗ is another
19:48:08 <KaneTW> let (KnxPacket p)  = r where r is an GADT
19:48:21 <ThatTreeOverTher> found it... http://stackoverflow.com/questions/23531566/odd-ghc-error-message-my-brain-just-exploded
19:48:29 <Ziltrum> Hi! I'm Crystal Robinson, public relations coordinator for Kidde. For product support, please visit our Knowledgebase on Kidde.com:... show more
19:48:32 <Ziltrum> ? · 6 years ago
19:48:34 <Ziltrum> Comment  0   0
19:48:45 <domgetter> Cale: what would an unnatural transformation be?
19:48:50 <Cale> heh
19:49:01 <Cale> "natural transformation" is another technical term
19:49:15 <Cale> https://en.wikipedia.org/wiki/Natural_transformation#Definition
19:49:16 <domgetter> are there transformations between categories that are not natural?
19:49:32 <Cale> "transformation" isn't a technical term here
19:49:47 <EvanR> so in haskell, the monoid object associated with a monad is the `m' (in the endofunctor category * -> *), the product is functor composition of m, and the identity is a mapping from the identity functor (a -> a) to m, ... also via composition?
19:49:49 <dolio> They're also not between categories.
19:50:25 <domgetter> It's not really different than my notion of a function is it?  That is, it's just a correspondence between members of a collection of some type into some other big collection, no?
19:50:26 <Cale> If F and G are both functors C -> D, then "natural transformation from F to G" is a single defined concept, it's not like there are transformations and then some happen to be natural ones.
19:50:44 <EvanR> er.. Identity would be the identity functor
19:51:30 <EvanR> domgetter: no natural transformations have more laws than just functions
19:51:37 <Cale> domgetter: It is vaguely related to polymorphic functions, in that if you have (endo)functors F and G in Haskell, then the polymorphic functions F a -> G a will correspond to natural transformations.
19:51:46 <ThatTreeOverTher> I imported System.Directory but ghc says listDirectory isn't in scope
19:51:51 <ThatTreeOverTher> how is that
19:52:00 <Cale> domgetter: however, that gives a somewhat weird and not quite correct picture of them
19:52:07 <domgetter> how much of this is applicable to using monads while programming?
19:52:14 <Cale> domgetter: basically none of it
19:52:19 <Cale> This is all enrichment
19:52:31 <domgetter> thats fair
19:52:48 <EvanR> this is all haskell "fluff"
19:52:49 <Cale> You only care about any of this if you're interested in mathematics in a more general way and might like to try applying these concepts in settings which have nothing to do with programming.
19:52:54 <domgetter> so if none of this has anything to do with monads in programming, how do I learn about programming monads?
19:53:11 <EvanR> of course if you find a way to apply the math to programming, you could write a paper on it
19:53:20 <Cale> domgetter: Mostly by starting out using libraries which happen to define instances of Monad.
19:53:24 <domgetter> My goal is to write a monad in Ruby and know that I have done so.  I have no way of knowing if I've succeeded
19:53:39 <domgetter> I'm a monkey on a typewriter at this point
19:53:41 <ThatTreeOverTher> why write a monad if you don't know how to use it
19:53:43 <dolio> There are ways to apply it. It just isn't required for programming.
19:53:48 <Cale> domgetter: Oh, it'll turn out *horrible* in Ruby if you do it at all correctly, to the point that it won't be useful.
19:53:50 <EvanR> Ruby, js, clojure etc have no way of doing monads because they dont have static type systems
19:54:14 <EvanR> or nice ways to modify syntax
19:54:21 <EvanR> to get do notation
19:54:42 <domgetter> EvanR: they have type systems though, no?
19:54:43 <ThatTreeOverTher> ruby has some nice things, like bareword support and rescue
19:54:46 <Cale> domgetter: The reason for this is that we get a lot of mileage out of Haskell's typeclass system with respect to making the abstraction work without forcing the programmer to put in lots of extra parameters by hand (the implementation of the monad operations)
19:54:47 <EvanR> domgetter: not really
19:54:55 <ThatTreeOverTher> not enough though
19:54:58 <domgetter> EvanR: are runtime types not types?
19:55:00 <EvanR> they only have runtime environments
19:55:10 <Cale> domgetter: and dynamically typed languages can't really do the same kind of dispatch on type that's going on here
19:55:10 <domgetter> I mean, they aren't static types, but they are types, am I wrong?
19:55:13 <EvanR> where you can juggle runtime objects, like strings
19:55:13 <ThatTreeOverTher> runtime types aren't type enough, because you often get duck types
19:55:31 <dolio> I would say they aren't types.
19:55:44 <dolio> In that when I say 'types' I'm talking about type theory.
19:55:47 <domgetter> dolio: I agree they aren't static types
19:55:51 <Cale> domgetter: Okay, so have you used Haskell much yet?
19:56:02 <Cale> domgetter: Do you know many examples of monads?
19:56:04 <EvanR> alternatiely you can say they have 1 type, the type of js values, or ruby objects
19:56:09 <ThatTreeOverTher> what are you trying to do with ruby in this case
19:56:12 <EvanR> and theres no way to make another
19:56:30 <domgetter> Cale: I don't even know how to form a sentence "a monad is ..."
19:56:39 <ThatTreeOverTher> you will not be able to define monad for a long time
19:56:46 <ThatTreeOverTher> you will be able to use one fairly quickly
19:56:49 <Cale> domgetter: okay, in that case, let's have a look at some examples
19:56:49 <domgetter> is it an adt? is it an isntance of a class? is it a function? is it a collection of functions?
19:56:53 <ThatTreeOverTher> counter-productive, but it works
19:56:58 <EvanR> domgetter: a type class
19:57:07 <ThatTreeOverTher> it taints a type
19:57:17 <domgetter> EvanR: what's the difference between a type and a typeclass?
19:57:31 <EvanR> a type class is an interface that types can implement
19:57:33 <ThatTreeOverTher> so an Integer could become Maybe Integer or IO Integer
19:57:35 <Cale> domgetter: Monad is a type class (in Haskell), and the type constructors which are instances of that type class are called monads.
19:57:38 <ThatTreeOverTher> Maybe and IO are types
19:57:47 <ThatTreeOverTher> *monads oops
19:58:05 <domgetter> So do you instantiate a type class or do you implement it?
19:58:21 <ThatTreeOverTher> http://stackoverflow.com/questions/1779431/creating-monads-in-haskell
19:58:28 <EvanR> synonymous
19:59:14 <Cale> domgetter: Okay, let's do an example
19:59:25 <ThatTreeOverTher> :t Monad
19:59:26 <lambdabot> Not in scope: data constructor ‘Monad’
19:59:34 <ThatTreeOverTher> ignore me, please
19:59:34 <Cale> domgetter: I feel it's very important to have a few good examples of monads under your belt before you try to understand the type class.
19:59:49 <EvanR> ThatTreeOverTher: in ghci, :i Monad
20:00:22 <codebje> @pt \a -> a * a `div` 10
20:00:22 <lambdabot> ap (*) (`div` 10)
20:00:40 <Cale> domgetter: So, let's see, I need to know that you're okay with the idea of a type constructor -- have you seen how data types are defined in Haskell, and know how type parameters work?
20:01:26 <codebje> @pt \a b -> a * a `div` b
20:01:27 <lambdabot> liftM2 (.) (*) div
20:02:02 <Cale> domgetter: hello?
20:02:08 <domgetter> I'm here, Cale
20:02:15 <domgetter> My brain is redlining
20:02:34 <Cale> domgetter: haha, okay, just follow along with me, I'm going to do examples of monads
20:02:52 <domgetter> Cale: I know how to define arbirary classes in Ruby
20:02:52 <Cale> domgetter: But first, I need to know that you're comfortable with how data types work in Haskell
20:02:59 <Cale> domgetter: Yeah, that doesn't help
20:03:04 <domgetter> and I know how to instantiate objects from those classes
20:03:15 <ThatTreeOverTher> data types are... different
20:03:18 <domgetter> Does it help to know how to implement Java interfaces?
20:03:38 <Cale> domgetter: No, I'm going to talk in terms of Haskell, because to do anything else would be madness.
20:03:49 <ThatTreeOverTher> Haskell doesn't play nice with the other kids
20:03:59 <domgetter> I know the lack of algebraic data types won't help, but is there an analogy to draw there?
20:04:02 <Cale> If I tried to translate this abstracting into Ruby in a way which was at all correct, it would turn out useless.
20:04:12 <Cale> abstraction*
20:04:12 <domgetter> that is, is a type class something you write the implementation for?
20:04:35 <Cale> Monads don't occur naturally in Ruby code, and so there's little point in abstracting over them.
20:04:50 <EvanR> IO ;)
20:04:54 <Cale> If you did it, the manner in which you'd have to write your programs would become horrid
20:05:15 <Cale> EvanR: No, I'm thinking in a way that you could get mileage out of the existence of polymorphic sequence and liftM2 etc.
20:05:25 <ThatTreeOverTher> data Color = Red | Green | Blue
20:05:51 <Cale> The whole point of talking about monads is to be able to just define return and (>>=) for your library, and get a library of things defined in terms of those two operations.
20:06:14 <Cale> For free, without having to type in all the code over and over.
20:06:47 <Cale> Things like sequence :: (Monad m) => [m a] -> m [a], and liftM2 :: (Monad m) => (a -> b -> c) -> m a -> m b -> m c
20:07:02 <Cale> and mapM :: (a -> m b) -> [a] -> m [b]
20:07:03 <Cale> and so on
20:07:07 <ThatTreeOverTher> Maybe, for example, allows you to perform operations on values regardless of their existence
20:07:36 <ThatTreeOverTher> If the object inside the Maybe is Just 2, and you add 2, you get Just 4. But if it was actually Nothing, you get a Nothing back (without a crash!)
20:07:54 <Cale> Maybe is nice, but if all we had was Maybe, there would be no point in talking about Monad
20:07:55 <EvanR> that would be the Functor behavior
20:08:09 <Cale> None whatsoever.
20:08:11 <domgetter> I know that there are different Monads
20:08:20 <domgetter> theres maybe, and list, and IO, etc
20:08:33 <domgetter> is it wrong to say there are an arbitrary number of different monads?
20:08:48 <ThatTreeOverTher> you can write your own monads, so sure?
20:09:00 <domgetter> what does it take to be one?
20:09:09 <domgetter> defining return and bind?
20:09:10 <Cale> domgetter: You need:
20:09:13 <Cale> 1) A type constructor
20:09:18 <Cale> (say M)
20:09:38 <Cale> 2) A polymorphic function:   return :: a -> M a
20:09:55 <Cale> 3) Another polymorphic function:   (>>=) :: M a -> (a -> M b) -> M b
20:10:00 <domgetter> I'm confused on the syntax of 2)
20:10:05 <Cale> and then additionally, these need to satisfy some properties
20:10:06 <domgetter> what does the double colon mean?
20:10:16 <Shockk> it means return is of type (a -> M a)
20:10:17 <ThatTreeOverTher> :: is the type assignment operator
20:10:17 <Cale> ah, okay, so you're *really* a beginner to Haskell :)
20:10:37 <ThatTreeOverTher> :t getArgs
20:10:39 <Cale> v :: t means "v has type t"
20:10:39 <lambdabot> Not in scope: ‘getArgs’
20:10:53 <domgetter> so "return is a function that takes anything of type a and returns something of type M a"
20:10:58 <domgetter> is that the way to read that/
20:10:59 <Cale> yes
20:11:13 <Cale> domgetter: Here, note that M itself is a sort of function on types
20:11:37 <domgetter> so it's a metatype
20:11:42 <domgetter> a higher order type, if you will
20:11:44 <Cale> It takes a type as an argument, and produces a type
20:11:48 <domgetter> it takes a type and returns a type
20:12:07 <domgetter> and the identity monad takes a type and returns the same type?
20:12:25 <Cale> Yeah, though in Haskell, we can't make that thing exactly
20:12:37 <domgetter> okay that's fine
20:12:45 <domgetter> so I think I understand return now
20:12:55 <Cale> Instead, we define an Identity type constructor which simply produces a trivial wrapper, which is treated as a new distinct type by the type system
20:13:03 <Cale> A really good example of a monad
20:13:06 <Cale> is Parser
20:13:06 <EvanR> @src Identity
20:13:06 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
20:13:18 <Cale> There are various libraries available
20:14:28 <Cale> which define a type constructor Parser such that a value of type Parser t represents a program which will try to eat the beginning of some input string, and, if it is successful, will produce a value of type t, along with a depleted input string, (and it may actually do so in a bunch of different ways, for the purposes of backtracking)
20:14:31 <domgetter> so wait, whats the difference between the type constructor and return?
20:14:38 <domgetter> dont they both take a type and make a new type?
20:14:49 <Cale> This will become apparent immediately if you follow along with this example :)
20:14:54 <Cale> So, in this case
20:14:57 <Cale> we have a function:
20:15:02 <Cale> return :: a -> Parser a
20:15:20 <Cale> which given a value of any type whatsoever, will produce a Parser having results of that type
20:15:45 <Cale> and that parser will be the one which doesn't consume any input, but simply succeeds with the given value as its result
20:16:02 <Cale> i.e.  return v  is the parser which does nothing except to, well, return v
20:16:58 <domgetter> Is it true that Parser :: a -> Parser a
20:17:00 <Cale> (after we've gone through this in vague terms, perhaps I'll flesh this example out with real (if inefficient) code
20:17:03 <Cale> no
20:17:04 <domgetter> it can't be, since that's return
20:17:07 <Cale> Parser is a type level thing only
20:17:16 <Cale> It doesn't exist at the level of values
20:17:16 <nshepperd> return takes a value and makes a new value
20:17:20 <domgetter> When I see Parser a
20:17:38 <Cale> Parser a is the type of parsers whose results have type a
20:17:48 <nshepperd> 'return 3' is a value, 3 is a value
20:17:56 <Cale> i.e. internally, they might be functions  String -> [(a, String)]
20:17:58 <nshepperd> 'Parser Int' is a type, Int is a type
20:18:05 <ThatTreeOverTher> when you write a function using >>=, it takes Parser a and gives it to a function that takes a
20:18:14 <Cale> That is, a parser for things, is a function from Strings to lists of pairs of things and strings
20:18:18 <domgetter> so Parser is not a function
20:18:30 <EvanR> Parser :: * -> *
20:18:38 <EvanR> where * is the kind of haskell types
20:18:47 <ThatTreeOverTher> you use >>= to operate on the underlying value of a Monad, and then return to bring it back up to that level
20:18:48 <Cale> domgetter: It's kind of like a function which only exists in the world of types
20:19:00 <Cale> domgetter: Types and values in Haskell live in distinct namespaces
20:19:08 <EvanR> Int :: *
20:19:12 <EvanR> Parser Int :: *
20:19:16 <Cale> domgetter: Types only exist at compile time
20:19:17 <domgetter> Int is the type of the value 3
20:19:32 <Cale> domgetter: values persist through compilation and have run-time representations
20:19:46 <domgetter> if Parser :: * -> * then Parser is a function from types to types
20:19:58 <EvanR> yep
20:19:58 <nshepperd> you know any conversation is exciting once * is mentioned
20:20:21 <domgetter> So Parser Int is Parser Int
20:20:23 <domgetter> got it
20:20:25 <Cale> domgetter: Yeah, what EvanR is giving you here is what's called the kind of the type constructor parser
20:20:36 <Cale> domgetter: Just as values have types, type-level things have kinds
20:20:43 <Shockk> nshepperd: I saw * -> * in my chanmon and tuned in again
20:21:03 <Cale> domgetter: * is the kind of all type-level things which actually have ordinary values belonging to them
20:21:17 <domgetter> so you can't Parser Parser
20:21:24 <Cale> right, that will be a kind error
20:21:25 <EvanR> also Void
20:21:45 <lispy> domgetter: correct, types have to be well-formed and kinds help with checking that
20:21:55 <Cale> But you *can* have things like  Parser (Parser Integer)
20:22:15 <domgetter> because Parser Int has ordinary values belonging to it
20:22:19 <Cale> yeah
20:22:24 <Shockk> Parser is of kind (* -> *), so it takes any type and produces a type; if you do (Parser Parser), you're trying to give Parser a (* -> *) where it's expecting any type (*)
20:22:48 <Cale> and a value of that type will be a parser whose result will be another parser whose result will be an integer :)
20:23:07 <Cale> Monads will always have kind * -> *
20:24:30 <domgetter> okay this makes a lot more sense
20:24:53 <Cale> (though some monads themselves have additional type parameters -- for example, there is a monad State s of computations which manipulate a state parameter of type s, so that values of type  State s a  are basically the same thing as functions of type  s -> (s,a)  (i.e. they take some initial state, and produce a final state along with their result)
20:24:57 <Cale> )
20:25:21 <Cale> For each type s, we have that  State s  is a monad
20:25:23 <EvanR> :k State
20:25:24 <lambdabot> * -> * -> *
20:25:41 <Cale> That's  * -> (* -> *)  by convention
20:26:01 <domgetter> is -> left associative or right associative?
20:26:06 <Cale> domgetter: right associative
20:26:14 <Cale> (both in types and in kinds)
20:26:29 <Cale> Function application is left associative to go along with it
20:26:38 <domgetter> 3) Another polymorphic function:   (>>=) :: M a -> (a -> M b) -> M b
20:26:50 <Cale> Right, so in our Parser case...
20:26:56 <Cale> If we have some parser
20:27:00 <Cale> p :: Parser a
20:27:01 <domgetter> since -> is right associative, that's the same as  (>>=) :: M a -> ((a -> M b) -> M b) correct?
20:27:08 <Cale> yes
20:27:17 <domgetter> okay I'm following
20:27:23 <Cale> Actually, let's say this first:
20:27:27 <Cale> Whenever you see
20:27:30 <Cale> A -> B -> C
20:27:31 <Cale> in Haskell
20:27:41 <Cale> which really means A -> (B -> C)
20:27:59 <Cale> You can think of this as the type of functions of two parameters (of types A and B) which produce a result of type C
20:28:24 <domgetter> instead of a function that takes A and returns a function that takes B and returns C?
20:28:29 <Cale> Or, if you want, you can think of it as what it really is, the type of functions which take a value of type A, and produce a function of type B -> C
20:28:33 <Cale> yeah
20:28:47 <Cale> Function application associates to the left
20:28:48 <Cale> So
20:28:50 <Cale> f x y
20:28:51 <Cale> means
20:28:53 <Cale> (f x) y
20:28:59 <Cale> and
20:29:08 <Cale> f x y z  really means  ((f x) y) z
20:29:10 <Cale> and so on :)
20:29:32 <Cale> So the line between functions which produce other functions and functions of multiple parameters is blurred completely
20:29:58 <EvanR> unless you uncurry... (a,b,c) -> d
20:30:07 <EvanR> which is unconvenient
20:30:13 <Cale> yeah
20:30:43 <Cale> Okay, so back to our story about this operation on parsers
20:30:53 <Cale> (if that's all good)
20:31:27 <domgetter> I'm with you
20:31:29 <Cale> okay
20:31:35 <Cale> So suppose we have
20:31:41 <Cale> p :: Parser a
20:31:43 <ThatTreeOverTher> how did cabal install give me an old version of the directory library
20:32:12 <Cale> i.e. p is some parser whose result has type a when it succeeds
20:32:19 <Cale> and we have some function
20:32:20 <Shockk> ThatTreeOverTher: did you run cabal update or did you install something that depends on an older version?
20:32:23 <Cale> f :: a -> Parser b
20:32:43 <Cale> i.e. f takes a value of type a, and produces a parser whose result has type b
20:33:32 <Cale> The parser p >>= f will be the one which parses the beginning of its input using p, and then applies f to the result(s) of p in order to get parsers with which to parse the remainder of its input
20:33:44 <ThatTreeOverTher> Shockk, I guess I had an old version of directory installed globally already and just never updated it
20:33:53 <Shockk> oh, lol
20:34:09 <Cale> and its result will be the result of this latter parser
20:34:17 <Cale> i.e. it will produce a result of type b
20:34:25 <domgetter> Cale: and the return of the >>= wll be of type Parser b
20:34:43 <Cale> (or potentially many, in the case where we need to backtrack, or none in the case where the parse fails)
20:35:31 <Cale> so yeah, (>>=) is a two argument function which takes a parser of type (Parser a) and a function of type (a -> Parser b), and combines them into a parser of type (Parser b)
20:35:33 <domgetter> Cale: (>>=) :: Parser a -> (a -> Parser b) -> Parser b
20:35:36 <Cale> yep
20:35:47 <domgetter> wouldn't the >>= have to return something of type Parser b ?
20:36:00 <ThatTreeOverTher> it does
20:36:20 <domgetter> then what did you mean by "or potentially many, in the case where we need to backtrack, or none in the case where the parse fails"
20:36:28 <domgetter> if it can only return something of type Parser B
20:36:34 <domgetter> b*
20:36:41 <Cale> That's right, (>>=) itself does that. The parser which (>>=) is constructing will have zero or more results of type b when we run it on some input.
20:36:50 <EvanR> type Parse a = String -> [(a,String)], in this case
20:36:54 <EvanR> Parser*
20:37:01 <Cale> Yeah, so we might want to actually implement this
20:37:09 <ThatTreeOverTher> a failed parse returns [()] instead of [(a,String)]
20:37:14 <Cale> So, let's introduce some real Haskell syntax
20:37:15 <EvanR> no []
20:37:19 <Cale> for types
20:37:22 <ThatTreeOverTher> oops, yeah
20:37:34 <EvanR> it cant return [()] since its the wrong type
20:37:35 <Cale> I only need newtype here and not data, and it's simpler, so I'll go with newtype :)
20:37:42 <domgetter> wait, a isn't a string?
20:37:52 <Cale> that's right, a is any type at all
20:37:57 <Cale> and so is b
20:38:30 <Cale> Our type of parsers is parameterised over which type of results the parsers have
20:38:37 <domgetter> okay I'm a little lost
20:38:41 <Cale> okay
20:38:42 <domgetter> Parsers parse strings, no?
20:38:48 <Cale> They parse strings
20:38:57 <domgetter> so what would it mean if a weren't a string/
20:38:58 <Cale> But they tend to produce complicated data structures as their results
20:39:03 <Cale> Things like tree structures
20:39:08 <EvanR> a is the output of the parser not the input
20:39:09 <domgetter> a is the type of the output of the parsing?
20:39:10 <Cale> Or even just simple integers
20:39:17 <Cale> yes
20:39:20 <domgetter> i.e. some AST
20:39:22 <Cale> yeah
20:39:25 <domgetter> okay okay
20:39:30 <EvanR> it could be an AST or something else
20:39:37 <Cale> It might even be another parser!
20:39:49 <Shockk> Cale: mind blown
20:40:11 <domgetter> wouldnt that be the ParserFactory Monad?
20:40:32 <Cale> Parser (Parser AST)  would be the type of parsers which consume the beginning of their input in order to try to produce a parser for values of type AST
20:40:58 <EvanR> "{\"abc\": 123}" ====> fromList [("abc", 123)]
20:41:03 <Cale> It might be, for instance, reading some sort of grammar, and constructing a parser from it as it goes
20:41:04 <EvanR> ex
20:41:43 <EvanR> a = Map String Int
20:42:10 <domgetter> okay so
20:42:47 <domgetter> (>>=) :: Maybe Int -> (Int -> Maybe String) -> Maybe String
20:43:09 <Cale> yeah
20:43:09 <domgetter> if I've defined >>= to do that, I can't make it make a Maybe Int, can I?
20:43:22 <Cale> sorry?
20:43:23 <EvanR> > Just 3 >>= (\x -> Just (show x))
20:43:24 <lambdabot>  Just "3"
20:43:31 <EvanR> > Nothing >>= (\x -> Just (show x))
20:43:33 <lambdabot>  Nothing
20:44:09 <Cale> domgetter: So, yeah, I've been defining the operations return and (>>=) in terms of what they do for Parser, but operations of a similar shape show up across many libraries
20:44:42 <domgetter> ah, when you said >>= was polymorphic, we just have to make sure the a are the same thing and the b are the same thing
20:44:51 <EvanR> and m is the same thing
20:45:06 <domgetter> mmk
20:45:23 <EvanR> polymorphic means you have variables at all
20:45:37 <EvanR> which you can substitude for any type, or any type satisfying the constraing (Monad m)
20:45:42 <Cale> domgetter: The whole point of capturing this pattern which appears in many libraries is that there's a really decent handful of code (actually, that's downplaying it a little, there's actually quite a lot), which can operate using  return :: a -> m a  and  (>>=) :: m a -> (a -> m b) -> m b  without knowing which m is in use
20:45:43 <EvanR> constraint
20:45:53 <domgetter> EvanR: I don't understand that statement "polymorphic means you have variables at all"
20:45:59 <Cale> domgetter: These are mostly control-structure-like operations
20:46:07 <Cale> domgetter: For example, we have
20:46:11 <EvanR> a type is polymorphic if you have type variables, not that it has multiple variables that must be the same
20:46:19 <Cale> sequence :: (Monad m) => [m a] -> m [a]
20:46:27 <Cale> In the case where we pick m = Parser
20:46:44 <Cale> this is a function which takes a list of parsers, each of which produces a result of type a
20:46:56 <Cale> and produces a parser having as its result a list of values of type a
20:47:01 <domgetter> and what does => mean?
20:47:23 <Cale> ah, it's a bit of punctuation to separate the constraints on type variables from the rest of the type
20:47:27 <nitrix> Hi, how can I reimplement the Functor ((->) e) instance without GHC.Base getting in the way?
20:47:32 <EvanR> Constraints(x,y,z) => MyTypeExpr(x,y,z)
20:47:33 <nitrix> (It's an exercise)
20:47:50 <Cale> (Monad m) => ...  says "you can choose whichever m you like as long as there is an instance of the type class Monad for m"
20:48:15 <Cale> The Monad type class defines the operations return and (>>=)
20:48:33 <Cale> and then instances of that type class provide the implementations of those two operations for specific m
20:48:42 <Cale> class Monad m where
20:48:45 <Cale>   return :: a -> m a
20:48:53 <Cale>   (>>=) :: m a -> (a -> m b) -> m b
20:48:59 <Cale> instance Monad Parser where
20:49:09 <Cale>   return v = ... build the parser somehow ...
20:49:22 <Cale>   p >>= f = ... more actual implementation code here ...
20:50:21 <domgetter> Okay I'll have to go chew on this
20:50:24 <Cale> domgetter: Classes in Haskell are kind of sort of like what Java calls interfaces, except as you can see here, we can abstract over parametric types -- and there are lots of other ways in which type classes are way more general.
20:50:36 <Cale> Note also
20:50:50 <Cale> return is polymorphic in its result type
20:50:58 <Cale> in a way which can't be determined from its input
20:51:36 <Cale> Instead, usually type inference determines which m is used from context, and then the appropriate instance of the class is looked up in order to provide the implementation to use.
20:51:38 <domgetter> since the way to build a parser may depend on things at runtime?
20:51:55 <Cale> Well, the fact that you need to build a parser might not be easy to determine
20:51:56 <EvanR> no this is a compile time thing
20:51:59 <Cale> If I write
20:52:00 <Cale> return 5
20:52:05 <Cale> with no other information
20:52:13 <Cale> You don't know that I mean to construct a Parser
20:52:37 <Cale> Perhaps I want the instance of Monad for Maybe, or for IO, or for State Integer, ...
20:52:58 <domgetter> You're saying it's hard for the compiler to determine, not the programmer necessarily?
20:53:13 <Cale> I'm saying it's hard for a compiler which isn't doing type checking to determine
20:53:22 <EvanR> return 5, theres not enough info, so the compiler cant know what m =
20:53:40 <Cale> This will be a hurdle to implementing Monad well in Ruby or any other dynamically typed language.
20:53:50 <nitrix> Is there a way to not import the functor instances?
20:53:57 <nitrix> I'd like to rewrite them.
20:54:04 <EvanR> but embedded in more code the compiler can probably infer it
20:54:17 <Cale> You'll need to force the programmer to provide more information, and you'll want to do it in such a way that they don't have to pick which monad immediately
20:54:37 <Cale> Because the whole point of talking about monads is that there are a bunch of things which can be written to work *with any monad*
20:54:54 <Cale> i.e. if you realise that there's some sensible definition of return and (>>=) for your new library
20:55:01 <Cale> you can write the implementations of those two operations
20:55:14 <Cale> and pull in all the stuff in Control.Monad for free
20:55:24 <Cale> (and elsewhere out in the wild)
20:56:04 <Cale> So if I were to try to implement the Monad abstraction in Ruby, return and (>>=) would both need an additional parameter: which monad to use.
20:56:32 <EvanR> dictionary passing basically
20:56:37 <Cale> i.e. probably some record containing the implementations of return and (>>=), and then return and (>>=) themselves would extract the appropriate field
20:57:23 <EvanR> in ruby you would probably be writing this program as a method of a class thats inheriting or mixing in the monad support
20:57:26 <Cale> So, all your code will look a bit more shitty with all the explicit parameter passing...
20:57:37 <EvanR> then return (have to rename it) and bind will work without telling it
20:58:07 <Cale> and once you see what it looks like... nobody can really stand to write code like that for very long
20:58:37 <Cale> It really really helps to have the type checker working things out, and the type class mechanism doing all this extra parameter passing for us
20:58:50 <EvanR> theres a lot of freedom to mess up the runtime system in ruby so you might be able to get it to not be that hard to write
20:58:59 <EvanR> but no one will want to read the code
20:58:59 <Cale> I don't know...
20:59:38 <ThatTreeOverTher> in that case, you'd essentially be writing a new language
20:59:41 <Cale> Yeah, there might be something rather heroic you could do, but I bet it would flake out in most cases where you happened to be working with two things which happened to be monads.
20:59:45 <EvanR> you can intercept everything
21:00:33 <EvanR> yeah probably, unless you manually checked the classes as a second layer of dynamic typing
21:00:49 <Cale> domgetter: The type constructor for lists is also a monad
21:00:55 <Cale> domgetter: With  return v = [v]
21:01:04 <Cale> and  xs >>= f = concat (map f xs)
21:01:06 <EvanR> ThatTreeOverTher: we like to do that ;)
21:01:17 <Cale> i.e. apply the function f to all the elements of xs and then concatenate the results
21:01:27 <domgetter> from what I gather that monads are/are supposed to be, the enumerable module in ruby feels "monad-y"
21:01:41 <EvanR> not really
21:02:09 <EvanR> something more like Enumerable is Foldable
21:02:19 <domgetter> in the sense that I can compose any of the methods that themselves return an enumerable
21:02:38 <Cale> Yeah, well, it's a sensible abstraction in that way
21:02:50 <EvanR> domgetter: thats a special case of the more general "combinator pattern"
21:03:03 <EvanR> you have primitive constructors for T, and ways of combining Ts to get new Ts
21:03:21 <EvanR> in a way that doesnt blow up in your face
21:03:23 <Cale> > [1,2,3] >>= (\x -> [4,5] >>= (\y -> return (x,y)))
21:03:25 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
21:04:26 <Cale> domgetter: The monad instance for lists means that when you have a >>= you're basically picking an element of the list in all possible ways to supply to the function, and then producing a list of outcomes from there, and it works out all the things which could happen
21:04:34 <EvanR> do monads can be seen as an instance of that pattern, but there are many things like that that arent monads
21:04:37 <Cale> domgetter: So here it's like x is selected from [1,2,3] in all possible ways
21:04:41 <EvanR> s/do/so/
21:04:43 <Cale> and y is selected from [4,5]
21:05:15 <Cale> Just as  sequence :: (Monad m) => [m a] -> m [a]  could be applied to parsers to "run a list of parsers one after the next and collect a list of the results"
21:05:20 <Cale> we can also apply it to a list of lists
21:05:41 <Cale> and since in the list monad, the thing analogous to "running" is "picking an element in all possible ways"
21:05:52 <Cale> we end up with a list of all the ways to pick one element from each of the lists:
21:05:59 <Cale> > sequence [[1,2,3],[4,5],[6,7]]
21:06:00 <lambdabot>  [[1,4,6],[1,4,7],[1,5,6],[1,5,7],[2,4,6],[2,4,7],[2,5,6],[2,5,7],[3,4,6],[3,...
21:06:25 <Cale> We didn't have to write this function specially for lists
21:06:34 <Cale> We got it for free when we defined return and (>>=)
21:06:59 <Cale> Each new instance of Monad will result in some new way to use this polymorphic sequence function
21:07:13 <Cale> and there are many such functions which are polymorphic in the choice of monad
21:07:53 <Cale> (and people write new ones and/or come up with new techniques which abstract over a choice of monad all the time)
21:09:18 <Cale> https://hackage.haskell.org/package/astar-0.2.1/docs/Data-Graph-AStar.html -- for example, here's a small library I wrote a long time ago for an A* search -- first the plain version, and then a generalisation which does the computation using an arbitrary monad.
21:10:02 <Cale> So, for instance, if you need to make network queries in order to determine which vertices are adjacent in your graph, you might pick m = IO
21:11:10 <EvanR> that is an interesting pattern, if you use Monad to parameterize your lib, then it is like "you can use IO if you want"
21:11:14 <EvanR> "or not"
21:11:37 <Cale> Or of course, you could use lists -- it might be a bit unusual here
21:11:50 <EvanR> or Identity if monad makes no sense
21:11:58 <Cale> yeah
21:12:29 <Cale> You could use a monad of probability distributions and get a probability distribution of paths, with information about the probability that any given path was taken.
21:12:36 <Shockk> I really love it when you write some weird code and spend ages trying to do it right, and then you compile it for the first time and it works
21:13:35 <Cale> Parser would be rough though here, because the input would need to come in just the right order, so it probably makes no sense.
21:15:13 <EvanR> kind of goofy
21:15:33 <Cale> You could use the STM monad for concurrent memory transactions which accessed some shared mutable graph structure
21:16:28 <Cale> Or indeed, ST for single threaded mutable state with only memory effects
21:16:54 <Cale> (That one might even be useful if you have a fancy heuristic...)
21:17:41 <EvanR> annoying that to abstract over that stuff, IO vs STM vs ST vs RNG you are stuck with monads
21:17:48 <EvanR> in that way
21:17:57 <Cale> I dunno
21:17:59 <Cale> Is it?
21:18:15 <EvanR> i mean if it also makes sense (more often than not) to be using pure code
21:18:32 <Cale> also, not just RNG, but also computations which keep track of the probability of all possibilities
21:18:57 <EvanR> i mean if the interface you are thinking of is some pure code... and you use this monad thing, if you use it for many things youre basically opening the door for anything to be IOified
21:19:25 <EvanR> which is fine but it doesnt seem like a targeted interface to me
21:19:44 <EvanR> the basic "monad is too powerful" problem
21:19:46 <Cale> Well, it's important to realise that when you do this generalisation of sorts
21:19:58 <Cale> you're putting in more information which wasn't present in the pure code
21:20:12 <Cale> about the order in which things will be executed
21:20:56 <Cale> When you generalise from map to mapM, you have the choice about the order in which effects ought to occur, with at least two obvious ones.
21:21:06 <Cale> (one more obvious than the other, for sure)
21:21:07 <EvanR> but youre not just putting in that information
21:21:35 <Cale> oh?
21:21:40 <Cale> What else are we putting in?
21:21:58 <EvanR> you are also saying "it is ok for arbitrary IO to be happening between steps"
21:22:02 <EvanR> so thats extra
21:22:04 <Cale> uhhh
21:22:11 <Cale> I mean, kinda...
21:22:12 <EvanR> not just i/o but any runtime shenanigans you want
21:22:43 <EvanR> theres nothing between Applicative and Monad
21:22:59 <Cale> You're *sort* of saying it's okay. It really will be well-defined which IO action you mean in the end.
21:23:12 <Cale> and it's up to your user to commit to saying that's the IO action they wanted
21:24:19 <EvanR> as a library writer you have to basically keep that in mind
21:24:27 <EvanR> you lose a some reasoning ability
21:24:34 <Cale> It might not always in all cases be a useful IO action... but that has nothing to do with IO or monads or anything, but the general fact that it's possible to get stupid results if you put in stupid function arguments.
21:25:12 <EvanR> stupid results is one thing, but stupid results with the side effect of launching missiles, or some other IRL irreversible, irreproducible thing
21:25:33 <Cale> Well, yeah... that's kind of what the IO monad does :)
21:25:38 <saurabhnanda> I've been struggling with this since last night. Can anyone help me understand why the following function won't compile? http://lpaste.net/151133
21:25:45 <EvanR> IO can out-of-band mess up what your library is doing
21:25:53 <Cale> EvanR: but not really
21:26:06 <Cale> EvanR: I mean, short of destroying your computer, or the program's memory at least.
21:26:22 * hackagebot elision 0.1.0.0 - A data structure over two functions to be linked together at a later time.  https://hackage.haskell.org/package/elision-0.1.0.0 (jacrough)
21:27:05 <Cale> EvanR: You could maybe write non-portable horrible things which used low-level FFI stuff and fiddled around with GHC's memory representation of values while the algorithm ran, and it would cause it to run differently and possibly break.
21:27:08 <EvanR> which makes sense if its an IO lib, but i keep thinking "any monad" libs are making different sorts of functional assumptions
21:27:38 <Cale> EvanR: If it's definable in such a way that it works for any monad, then it works for IO
21:27:57 <EvanR> where "works" is heavily modified for IO
21:28:17 <EvanR> FFI or GHC internals is one example
21:28:25 <Cale> I mean, you'll get a valid action which does exactly what you expect it to.
21:28:46 <EvanR> where "you" is a combination of the user and the library writer ;)
21:28:50 <Cale> Provided you understand what the thing would do with respect to an arbitrary monad
21:29:00 <EvanR> will both agree that it makes sense
21:29:02 <Cale> and you understand the IO action parts you're filling in
21:29:27 <Cale> Given those two things, it will do what you expect
21:29:36 <EvanR> yes, that understanding seems like the kind of understanding you have when writing ML style side effecting code
21:29:49 <EvanR> it makes total sense
21:30:01 <EvanR> just not functional sense
21:30:13 <EvanR> and most monads make functional sense
21:30:14 <Cale> If you're writing IO actions, then you *have* to understand which effects they cause to occur when executed, if you want your program to behave correctly.
21:30:36 <EvanR> yeah but the lib is not using IO specifically
21:30:38 <Cale> It's totally sensible to complain about the fact that we don't have nice mathematical models which explain this behaviour
21:31:06 <Cale> The library isn't using IO specifically, but if you're going to give it IO things, you need to understand the order in which it executes the actions you give it.
21:31:19 <Cale> But that's true of most monads.
21:31:30 <EvanR> yeah the user is in better shape here
21:32:00 <EvanR> i was thinking this trick is nice for something thats like "I will leave a backdoor for IO" and knows it
21:32:16 <Cale> It's not really a backdoor for IO
21:32:24 <Cale> It's a front door :)
21:32:29 <EvanR> but when thinking of monads as a pure interface then you might not want IO allowed
21:32:42 <Cale> I mean, it's still pure
21:32:44 <EvanR> and cant
21:32:51 <Cale> with respect to which action you end up with
21:33:04 <saurabhnanda> hey, what's a good place for haskell newbies to hang out and ask stupid questions?
21:33:10 <Cale> saurabhnanda: here
21:33:22 <Cale> saurabhnanda: sorry for missing your question!
21:33:40 <saurabhnanda> Cale: it's okay. It's not like this is paid customer support or anything.
21:33:50 <EvanR> in my mind IO monad is not on the same level, whether or not you end up with "actions that obey all the laws" somehow
21:34:02 <saurabhnanda> I'm just frustrated with not being able to get that code to work
21:34:13 <Cale> saurabhnanda: So, the first error is the compiler saying that it can't figure out which type of value you want to decode from the JSON
21:34:34 <Cale> saurabhnanda: Normally if it could determine this from the rest of the code, you'd be fine
21:35:03 <saurabhnanda> Cale: why doesn't the example at https://hackage.haskell.org/package/aeson-0.10.0.0/docs/Data-Aeson.html need to specify a type, in that case?
21:35:10 <saurabhnanda> Cale: btw, the example doesn't work for me in GHCI
21:35:21 <Cale> doesn't it?
21:35:33 <Cale> they explicitly write:  decode "{\"name\":\"Joe\",\"age\":12}" :: Maybe Person
21:35:42 <saurabhnanda> Cale: that's the example I'm talking about -- λ> do result <- decode "{\"name\":\"Dave\",\"age\":2}"       flip parseMaybe result $ \obj -> do         age <- obj .: "age"         name <- obj .: "name"         return (name ++ ": " ++ show (age*2))  Just "Dave: 4"
21:35:45 <saurabhnanda> sorry
21:35:46 <Cale> with the type annotation on the expression to say which type to decode
21:35:56 <saurabhnanda> Cale: here's a link - http://lpaste.net/151134
21:36:17 <saurabhnanda> Cale: working with the AST section
21:37:29 <Cale> saurabhnanda: Yeah, looks like whoever wrote the documentation didn't typecheck it... in the previous blue box though, you'll see they explicitly write ":: Maybe Object"
21:38:09 <Cale> OH!
21:38:10 <saurabhnanda> Cale: awesome -- I'll issue a pull-request :)
21:38:16 <Cale> saurabhnanda: right, no, they don't have to
21:38:30 <saurabhnanda> Cale: is it being inferred later?
21:38:33 <Cale> yeah
21:38:38 <Cale> when they use .:
21:38:49 <saurabhnanda> right, so isn't that I'm basically doing?
21:39:01 <saurabhnanda> It's just that my JSON source is not ByteString, it's IO ByteString
21:39:13 <saurabhnanda> msg <- WS.receiveData conn
21:39:26 <Cale> oh
21:39:36 <Cale> The second error indicates why the unification doesn't happen
21:39:39 <saurabhnanda> it's coming over a websocket
21:40:12 <saurabhnanda> why should it matter?
21:40:12 <Cale> hm, one sec
21:41:32 <Cale> flip parseMaybe :: a -> (a -> Parser b) -> Maybe b
21:42:09 <Cale> you're writing  flip parseMaybe res  where res is the result of decode, which is a Maybe something
21:42:22 <Cale> Look at their code carefully
21:42:42 <Cale> in their code, result is not simply equal to decode applied to some string
21:42:55 <Cale> It's the result of executing that (in the Maybe monad)
21:43:08 <Cale> So it has type Object in their case
21:43:18 <saurabhnanda> Cale: hmm
21:43:24 <saurabhnanda> can I uses <- <- twice?
21:43:32 <saurabhnanda> or should I be fmap-ing decode into Maybe?
21:43:40 <Cale> You can use it once :)
21:43:51 <Cale> let v = do res <- decode msg
21:44:02 <Cale>            flip parseMaybe res $ \o -> ...
21:44:14 <EvanR> heh boggling at <- <-
21:44:28 <dmj> <- -> <-
21:44:29 <EvanR> very interesting
21:44:40 <saurabhnanda> okay, still doesn't work
21:44:50 <Cale> What's the new code and error?
21:45:21 <saurabhnanda> http://lpaste.net/151135
21:45:25 <saurabhnanda> completely different error now
21:45:32 <saurabhnanda> although I did something slightly different
21:45:36 <saurabhnanda> this was the v1 of my code last night
21:45:38 <Cale> nope, that's not what I said to do
21:45:45 <Cale> Do what I said to do
21:45:49 <Cale> and it will work
21:45:54 <saurabhnanda> when someone told me about how IO() and Maybe() monads can't really be mixed in a do-block
21:46:00 <Cale> v will have type Maybe String
21:46:04 <Cale> errr
21:46:13 <EvanR> all the m in a do block must match
21:46:18 <EvanR> :t (>>=)
21:46:19 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:46:26 <Cale> yeah, that's right
21:46:41 <Cale> (I was just checking a detail to be sure)
21:47:14 <saurabhnanda> Cale: slightly confused
21:47:24 <saurabhnanda> did you mean this: res <- do decode msg 
21:47:28 <saurabhnanda> let v = flip parseMaybe res $ \o -> do
21:47:36 <Cale> saurabhnanda: You want to write v using do notation for the Maybe instance of Monad
21:47:57 <Cale> saurabhnanda: You want to write aria2WebsocketReceiver using do notation for the IO instance of Monad
21:48:07 <Cale> There should be a separate "do" for the definition of v
21:48:20 <Cale> on the right hand side of its = sign
21:48:30 <saurabhnanda> so, in that case it's going to be: let v = do flip parseMaybe res ...
21:48:43 <Cale> let v = do res <- decode msg
21:48:47 <Cale>            flip parseMaybe res $ \o -> ...
21:48:57 <Cale> exactly like that
21:49:25 <Cale> res <- decode msg
21:49:35 <Cale> means that when decode msg is Nothing, the entire do-block is Nothing
21:49:48 <Cale> and if decode msg is Just x, then res = x
21:50:42 <Cale> saurabhnanda: So this do-block is an expression for a Maybe String
21:50:47 <Cale> (that is, for v)
21:50:49 <saurabhnanda> still doesn't work
21:50:51 <saurabhnanda> let me lpaste it
21:50:54 <Cale> okay
21:51:28 <saurabhnanda> http://lpaste.net/151136
21:53:43 <Cale> uhhh, that's odd
21:54:21 <saurabhnanda> I deleted some lines of code to reduce the compiler noise
21:54:23 <Cale> Do you have OverloadedStrings on?
21:54:27 <saurabhnanda> and reduced it down to one thing
21:54:31 <Cale> Can you try turning it off?
21:54:41 <saurabhnanda> the compiler can't figure out the type of r in ==> r <- o .: "result"
21:54:46 <Cale> I'm not sure it's actually the problem, but it is making these type errors more confusing
21:55:25 <saurabhnanda> shorter version : http://lpaste.net/151137
21:56:00 <saurabhnanda> I was actually doing two things in the previous code, which might be contributing to more errors. I was taking the result of .: and piping it into another .:
21:56:06 <saurabhnanda> in this version I'm doing nothing like that
21:56:15 <Cale> I mean, that should be okay
21:56:17 <saurabhnanda> it's pretty straighforward: http://lpaste.net/151137
21:56:28 <saurabhnanda> now there's just one type error
21:56:43 <Cale> But this is complaining about the type of your thing which is obviously a String
21:56:47 <saurabhnanda> Cale: and yes, I have OverloadedStrings on
21:56:58 <Cale> Can you turn that off conveniently, or no?
21:57:04 <saurabhnanda> Cale: should I pack/unpack it?
21:57:09 <saurabhnanda> Cale: other parts depend no overloadedstrins
21:57:17 <Cale> oh, right, Aeson uses Text everywhere
21:57:40 <Cale> Try packing the string result
21:57:44 <Cale> should help it infer the type
21:57:46 <saurabhnanda> actually in http://lpaste.net/151137 I'm not really using 'r' anywhere. Why should the compiler even care what type it is?
21:57:53 <Cale> Or just specify that the result has type String if you like
21:58:15 <Cale> because it matters in order to determine what .: is
21:58:33 <saurabhnanda> r <- o .: "result" :: String
21:58:38 <Cale> oh, yeah, that's the other problem now
21:58:40 <saurabhnanda> Couldn't match type ‘Parser a0’ with ‘[Char]’
21:58:42 <Cale> You're not using r
21:58:50 <Cale> So r's type is *obviously* ambiguous
21:58:56 <saurabhnanda> Cale: in the modified version. Trying to reduce the problem set to it's minimum.
21:59:06 <Cale> Yeah, don't reduce it like that
21:59:11 <Cale> Just specify the types of more things
21:59:21 <Cale> and the compiler errors will get easier to understand
21:59:26 <Cale> or go away
21:59:36 <saurabhnanda> So, here's the original version, which I suspect might have another type error --  r <- o .: "result" ; version <- r .: "version"
21:59:41 <saurabhnanda> see how 'r' is being used?
21:59:47 <Cale> yeah, you want to do that
21:59:53 <Cale> Because it determines the type of r
21:59:58 <saurabhnanda> that's the lpaste for the original version: http://lpaste.net/151136
22:00:05 <Cale> yeah
22:00:10 <Cale> specify the type of the String result
22:00:23 <Cale> It's complaining that it doesn't know what type version is
22:00:44 <Cale> No instance for (FromJSON a0) arising from a use of ‘.:’
22:00:47 <Cale> ... junk ...
22:00:50 <Cale> In a stmt of a 'do' block: version <- r .: "version"
22:01:03 <Cale> Normally, it would know this
22:01:12 <Cale> if you didn't have OverloadedStrings on
22:01:33 <Cale> because you have  ("version=" ++ version)  at the end of your do-block there
22:01:53 <saurabhnanda> Is this the right way to do it? version <- r .: "version" :: String
22:02:03 <Cale> But because OverloadedStrings is on, it knows that's some sort of list because of the (++), but it doesn't know precisely the type of the string literal "version="
22:02:13 <saurabhnanda> because it's complaining with that as well -- Couldn't match type ‘[Char]’ with ‘Parser [a]’ In a stmt of a 'do' block: version <- r .: "version" :: String
22:02:31 <Cale> return ("version" ++ version :: String)
22:02:35 <Cale> try that
22:02:48 <Cale> er, sorry, dropped your '='
22:03:01 <saurabhnanda> nope
22:03:03 <saurabhnanda> still not working
22:03:09 <Cale> What does it tell you now?
22:03:18 <Cale> Oh, obviously
22:03:27 <Cale> It will complain about the type of enabledFeatures
22:03:29 <Cale> and of id_
22:03:33 <Cale> because you don't use those things
22:03:44 <Cale> so it doesn't know what type of thing it needs to parse out of the structure
22:03:52 <Cale> and so it has no idea what code to generate
22:03:57 <saurabhnanda> actually the error has changed
22:04:15 <saurabhnanda> it's now complaining about the other two uses of .: where the variable binding wasn't really being used
22:04:18 <Cale> yep
22:04:23 <Cale> I just said it would, if you look :)
22:04:42 <Cale> Because you don't use the results of those operations, so it doesn't know what you want to do
22:04:51 <saurabhnanda> so basically it doesn't know what type they are. Although I'm not sure why would the compiler care about them. It should just optimize that away if it's not being used.
22:05:07 <Cale> What  r .: "id"  does is dependent on its type
22:05:17 <Cale> It can't just ignore it
22:05:25 <saurabhnanda> HALLELUJAH! IT COMPILES!
22:05:43 <Cale> Because it might e.g. be a parse failure
22:05:43 <EvanR> then it must be good, try running it to determine if its perfect
22:06:17 <Cale> saurabhnanda: But it can't know whether or not that computation would produce a parse failure if it doesn't know which parser to use
22:06:46 <Cale> saurabhnanda: So, it complains at you to specify the type, and then the type class machinery determines which parser to apply for that type of thing.
22:07:12 <Cale> saurabhnanda: Does that make sense?
22:07:17 <syncopy> join #diagrams
22:08:19 <saurabhnanda> Cale: partially. Probably it depends on when the compiler starts throwing away dead code. If it needs to figure out, beforehand, which fn to call (which requires type info), then yes, it makes sense.
22:08:30 <Cale> saurabhnanda: The code is *not* dead
22:08:32 <Cale> not at all
22:08:56 <Cale> saurabhnanda: It's still got to run the parser even if you throw the result away in order to check that the parse succeeds
22:09:04 <saurabhnanda> MIRACLE! IT RUNS!
22:09:42 <saurabhnanda> so, moral of the story is two things: I need to understand what exactly the 'do' block does AND OverloadedStrings complicate lives.
22:09:43 <Cale> saurabhnanda: i.e. not only are you extracting that field when it exists, you're also making sure that the field contains a JSON value of the appropriate structure
22:10:08 <Cale> (and if not, then the whole thing fails and v = Nothing)
22:10:36 <saurabhnanda> so, another way to approach let v = do res <- decode msg was to NOT use the do block and pattern-match between (Nothing) and (Just x) upon res?
22:10:42 <Cale> yep
22:10:53 <Cale> you could just   case decode msg of ...
22:11:24 * hackagebot elision 0.1.0.1 - A data structure over two functions to be linked together at a later time.  https://hackage.haskell.org/package/elision-0.1.0.1 (jacrough)
22:11:29 <saurabhnanda> so the outermost do block is making life easier working inside the IO monad and the inner do block is making life easier inside the Maybe monad and the do block inside the lambda is making life easier working inside the Parser (??) monad?
22:11:39 <Cale> yep
22:11:50 <dmj> life is good
22:11:52 <saurabhnanda> Oh my Monad!
22:13:08 <saurabhnanda> thanks a lot Cale
22:13:11 <saurabhnanda> Cale: thanks
22:13:12 <EvanR> ermagawnad
22:14:57 <saurabhnanda> Cale: do you share your real life coords? Not that I want to stalk you, I'm more interested in seeing where you work and whether you use Haskell at work. I'm basically evaluating Haskell for my startup. We've hit a point in terms of LoC in Ruby where I'm wishing for some type-safety and making it harder for Junior Devs to screw up.
22:15:31 <Cale> saurabhnanda: I live in Brantford, Ontario, and I work as a Haskell developer for Obsidian Systems, which is in NYC.
22:16:08 <Cale> We develop web applications in Haskell for various clients
22:16:32 <saurabhnanda> Cale: obsidian.co.za?
22:16:38 <Cale> obsidian.systems
22:16:45 <saurabhnanda> Cale: checking it out.
22:17:47 <dmj> those junior devs, always screwing things up
22:18:39 <Cale> The client project I'm working on isn't listed on the recent developments page because we leave it up to them.
22:19:05 <Cale> But all of our projects tend to have frontends developed using reflex-dom
22:19:16 <Cale> (compiling Haskell to Javascript)
22:20:54 <Cale> and the backends tend to be Snap and usually Groundhog right now
22:21:46 <Cale> saurabhnanda: Dealing with HTML and CSS still kinda sucks, but it's a lot nicer to be writing this stuff in Haskell than Javascript :D
22:23:02 <Cale> saurabhnanda: It's also really nice to be able to use Aeson not only on the backend, but also the frontend -- mostly we don't write custom JSON parsers, we just use the derived instances on both the front and backend of the web app and so of course they'll always match.
22:23:11 <Cale> (Unless you half-bake your compile)
22:24:39 <Cale> saurabhnanda: still here?
22:25:52 <ThatTreeOverTher> how willing are junior devs to learn haskell, is the only issue
22:26:06 <dmj> Cale: just curious, do your front end projects tend to share libraries with your backend code? (i.e. one cabal file, two executables (web-server, front-end) -- one compiled to x86 the other js)
22:26:07 <ThatTreeOverTher> everything else in haskell is basically paradise
22:26:17 <ThatTreeOverTher> it's just that you need to work to achieve salvation
22:26:30 <dmj> Cale: or two separate projects (two cabal files)
22:26:35 <Cale> dmj: There's a fair amount of code in common...
22:26:56 <Cale> We have it split into frontend, backend, and common directories
22:27:09 <Cale> (and then a library we share between many projects)
22:27:39 <Cale> But yeah, the stuff in the common directory as the name would suggest, becomes part of both builds
22:28:15 <dmj> Cale: very cool, is ghcjs good about removing javascript that was produced by unused modules, or is there dead code detection w/ google's closure compiler for that
22:28:15 <Cale> Stuff like the types corresponding to our database schema and API
22:28:28 <Cale> I have no idea
22:28:46 <dmj> Cale: so the generated javascript file is never an issue though?
22:28:48 <Cale> It produces incomprehensible javascript programs which are a few megabytes
22:29:12 <Cale> I treat javascript the same way most programmers treat machine code here :D
22:29:27 <dmj> heh :]
22:30:42 <dmj> Cale: do the clients care the js is ~1MB?
22:31:01 <zd234> https://gist.github.com/anonymous/0d7c012f7d189946771a <-- how am I misusing haddock? do I need to do something for it to handle preprocessing stuff ?
22:31:05 <Cale> dmj: I haven't heard any complaints
22:31:20 <EvanR> the browser is downloading 1MB of js?
22:31:48 <EvanR> i hope they never refresh ;)
22:31:56 <dmj> EvanR: heh, I'm sure it's cached
22:32:02 <EvanR> orly
22:32:20 <Cale> You're off by about an order of magnitude there ;)
22:32:30 <EvanR> 10MB?
22:32:33 <Cale> At least for the project I'm working on, the all.js file is 14MB
22:32:41 <dmj> what...
22:32:44 <Cale> But that's the whole application
22:32:47 <EvanR> bejeebus
22:32:51 <Cale> And hey, people watch YouTube videos
22:32:57 <EvanR> i know but
22:33:23 <EvanR> they slowly download your app over the course of 30 seconds? ;)
22:33:27 <Cale> oh, this might not be what we send over the wire...
22:33:41 <ThatTreeOverTher> compression / Closure Compiler does wonders
22:33:46 <Cale> I'm looking at my build which didn't go through all the deployment nonsense which might involve compression
22:34:01 <Cale> (which certainly does involve compression, but I don't know about for the .js)
22:34:05 <dmj> Cale: I'd imagine you have rts.js, (lib.js?), and others on a CDN somewhere
22:34:23 <Cale> dmj: Uh, maybe if we need to at some point.
22:34:41 <EvanR> what is rts.js
22:34:44 <ThatTreeOverTher> it's also fun to send gzip/deflate payloads
22:34:49 <ThatTreeOverTher> especially prezipped ones
22:34:55 <dmj> EvanR: runtime system for front end
22:35:13 <EvanR> ThatTreeOverTher: luckily thats built into HTTP. or is that broken most of the time too (like caching)
22:35:26 <Cale> yeah, plain gzip gets this down to 1.4MB
22:35:33 <ThatTreeOverTher> plenty of people disable/forget/entirely break it
22:35:41 <ThatTreeOverTher> exactly like caching
22:35:55 <saurabhnanda> Cale: I'm back. Sorry, got pulled into a discussion
22:37:51 <saurabhnanda> Cale: why Snap? I thought Yesod was the killer web-framework for Haskell?
22:38:06 <saurabhnanda> Cale: also, do you use any ORM or something to write type-safe SQL?
22:38:19 * dmj waits his turn in line to ask Cale questions
22:38:19 <Cale> saurabhnanda: Snap is mostly still too complicated for what we need on the backend.
22:38:41 <Cale> saurabhnanda: The backend is just a webserver which serves API requests and manages a database.
22:39:15 <saurabhnanda> Cale: how would you solve the following problem -- pulling out a report from SQL? The JOINs, simple column transformations, etc. should not be done in the Haskell layer, SQL is better suited for that. HOWEVER, if a model's schema changes, a report depending on that schema should fail to compile till it's fixed.
22:39:23 <Cale> heh, okay zopfli (which is the compression I know we're at least using elsewhere, if not for the javascript) gets it to 1.2MB :)
22:39:40 <dmj> Cale: that's workable
22:40:00 <ThatTreeOverTher> isn't there some library that lets you run SQL from a file comfortably
22:40:05 <dmj> jQuery is ~252kb
22:40:19 <saurabhnanda> Cale: What is the Om for the Haskell world? (Om allows one to write React code in Clojure, I believe).
22:40:31 <ThatTreeOverTher> Cale, have you looked at modularizing the payload?
22:40:49 <Cale> saurabhnanda: Presently for the most part we ship the relevant portion of the database to the client over a websocket where it appears to the code that I'm writing as a bunch of Haskell datastructures (reflex Dynamics containing Data.Maps, mostly) which are automatically kept up to date
22:41:11 <Cale> saurabhnanda: and then the code I write just works with it as Haskell datastructures
22:41:35 <ThatTreeOverTher> oh, I assume the Haskell JS compiler makes modularization impossible
22:41:37 <saurabhnanda> Cale: wouldn't that be inefficient when you're dealing with large data-set (which tends to happen with reports) and not individual objects?
22:42:03 <ThatTreeOverTher> stream parts of the dataset!
22:42:05 <Cale> saurabhnanda: Certainly for sufficiently large datasets
22:42:21 <Cale> saurabhnanda: We can of course always add new APIs to the backend
22:42:28 <Cale> saurabhnanda: and just do SQL queries
22:42:46 <Cale> But most of the time, it's really nice to have the liveness
22:43:43 <saurabhnanda> Cale: right, how do you keep these SQL queries type-safe. I was looking at Persistent (from Yesod), which tries to do that, but not sure how mature it is. For example, have you looked at Arel in Ruby/Rails?
22:43:44 <Cale> So, e.g. if another client bids on an item in an auction, for example, the Dynamic t (Map (Id Bid) Bid)  in the frontend sees this change, and everything computed from it is efficiently updated
22:43:58 <dmj> Cale: what OS do you run?
22:44:04 <Cale> dmj: Linux
22:44:25 <zd234> how does hackage generate docs?
22:44:29 <zd234> I want to generate hackage like docs on my own
22:44:37 <zd234> for a series of haskell *.tar.gzs that I have downloaded
22:44:48 <Cale> saurabhnanda: Our backend is using Groundhog, but we're looking to replace that with what Ryan's referring to as a "category theory to SQL compiler" -- I don't know much about that, I haven't touched it yet :)
22:44:49 <saurabhnanda> Cale: how do you deal with immutable data structures in the JS world? Does Haskell aim for memory efficiency in immutable DS or does it assume that the RTS is going to take care of garbage collection. In which case the assumption might not be a very good one for transpiled JS.
22:45:16 <Cale> saurabhnanda: Javascript is my machine code, I don't think about the javascript
22:45:17 <dmj> Cale: do you use the new ghcjsi repl? Or do you develop using webkitgtk3
22:45:30 <EvanR> saurabhnanda: js data is as immutable as haskell data ;)
22:45:32 <Cale> saurabhnanda: I write Haskell programs, and they dynamically generate the DOM
22:45:39 <EvanR> luckily the RTS doesnt mutate it
22:45:51 <EvanR> i meant to say its as *mutable*
22:46:13 <Cale> saurabhnanda: and Javascript I only ever see if I'm doing some FFI stuff to some JS API like building out the Google Maps interface or something...
22:46:33 <ThatTreeOverTher> hahaha FFI glue for JS
22:46:37 <ThatTreeOverTher> what a world we live in
22:46:46 <dmj> Cale: do you end up doing a lot of FFI stuff, since there aren't too many bindings to other libs
22:46:46 <xinming> s
22:46:57 <Cale> saurabhnanda: But yeah, for example of what we've already done with that, I have  geolocating :: (...) => Event t a -> m (Event t (Coordinates, a))
22:47:18 <Cale> Event t a represents something which occurs at particular points in time, and at those times, has a value of type a
22:48:02 <Cale> this geolocating thing adds a widget to the DOM which will make a request to the Google Maps API whenever the input event fires, and locate the user's computer, tagging the value which occurred with the coordinates
22:48:31 <Cale> I use this to automatically add geolocation data to requests that drivers make via their phones, for example.
22:49:29 <ThatTreeOverTher> what is Data.Text.Internal.Lazy.Text, and why isn't it a String
22:49:37 <saurabhnanda> Cale: you might want to optimize the bg image on your home page. It's ~700kb for no good reason.
22:49:38 <ThatTreeOverTher> why do I have to use it to use the markdown lib
22:50:03 <saurabhnanda> Cale: what did you use to generate https://obsidian.systems/1qq4f2l537cy8v4jgyrnnrjqjdkcgyrrddvwfbshk2nlj655k92j-all.js
22:50:19 <EvanR> ThatTreeOverTher: so Data.Text should be good enough
22:50:46 <EvanR> unless that lib is screwing up royally
22:51:01 <dmj> ThatTreeOverTher: String is a linked list, and has a space inflation of 24 times that of Text, which has an efficient packed representation
22:51:13 <EvanR> only 24?
22:51:23 <dmj> that's what I read on the wiki
22:51:29 <ThatTreeOverTher> okay, so I'm trying to use readFile to put data into the markdown lib
22:51:33 <ThatTreeOverTher> what is the best way to do this
22:51:46 <EvanR> use readFile from Data.Text
22:52:03 <ThatTreeOverTher> oh, okay
22:52:08 <dmj> EvanR: "however when it comes to dealing with bytewise data, String involves a space-inflation of about 24x and a large reduction in speed."
22:52:29 <ThatTreeOverTher> there are so many hurdles here, lol
22:52:46 <Cale> saurabhnanda: That'd be ghcjs
22:52:51 <EvanR> hmmm https://wiki.haskell.org/GHC/Memory_Footprint
22:53:11 <EvanR> ThatTreeOverTher: an early pitfall is to try to use String for large amounts of text
22:53:25 <dmj> function ys(){var c=m,d=b[e-2],g=b[e-1]; heh
22:53:32 <EvanR> its not only slow, but it can exhaust your stack depending on what you try to do with the text
22:54:02 <EvanR> solution use Text instead
22:54:10 <ThatTreeOverTher> why is that default behavior, and why are there so many different string types?
22:54:15 <EvanR> theres only 2
22:54:28 <EvanR> arguably Text should be String, but hysterical raisins
22:54:38 <ThatTreeOverTher> okay that's after you find out how to turn on OverloadedStrings though
22:55:02 <EvanR> ByteString doesn't count
22:55:07 <saurabhnanda> Cale: http://stackoverflow.com/questions/35077554/how-to-parse-json-with-aeson-without-declaring-individual-types/35078554#35078554
22:55:31 <EvanR> OverloadedStrings notwithstanding
22:56:20 <EvanR> ThatTreeOverTher: would you rather there be several string types magically swapped behind the scenes for you? or countless alternative string libs like c++ :)
22:56:43 <EvanR> or no string types at all! only bytestrings (C, PHP)
22:56:44 <ThatTreeOverTher> Node.js does the swapping magically thing
22:57:00 <Cale> saurabhnanda: I know it's just how you wrote it, but just to be clear, it's not so much that enabledFeatures e.g. was being bound, so much as the parser (r .: "enabledFeatures") was supposed to be run, but since its result was unused, it was impossible to determine which parser exactly that expression refers to.
22:57:01 <ThatTreeOverTher> wait, no it doesn't
22:57:02 <ThatTreeOverTher> huh
22:57:04 <EvanR> JS is actually better, they have only 1 string
22:57:12 <ThatTreeOverTher> no, they have a Buffer type
22:57:16 <ThatTreeOverTher> (in Node)
22:57:20 <EvanR> ... which isnt a string !
22:57:23 <ThatTreeOverTher> yeah, huh
22:57:28 <ThatTreeOverTher> how did I figure that one out
22:57:49 <ThatTreeOverTher> I'm going to take the easy way out here and blame the documentation instead of admitting my mistake
22:57:55 <ThatTreeOverTher> hopefully that's alright with everyone!
22:58:03 <EvanR> what markdown lib anyway
22:58:25 <ThatTreeOverTher> https://hackage.haskell.org/package/markdown
22:58:40 <ThatTreeOverTher> usually whatever comes up on Google first is the best one to use
22:58:48 <saurabhnanda> Cale: how big is the team at Obsidian? And how would you rate Haskell for typical web-apps? 
22:59:03 <EvanR> ThatTreeOverTher: well it says right there, markdown :: MarkdownSettings -> Text -> Html ;)
22:59:35 <ThatTreeOverTher> I know it says "Text" but finding all these libraries and putting them on the path is work
22:59:51 <ThatTreeOverTher> in Node, to get a String from a Buffer it's just "new String("
23:00:27 <EvanR> Text is a standard library
23:00:47 <dmj> ThatTreeOverTher: hunting down type errors in node is far more work than haskell module imports
23:00:55 <EvanR> you basically need to know about it to use haskell
23:01:04 <ThatTreeOverTher> why did I have to add it to the buildpath to import Data.Text
23:01:09 <ThatTreeOverTher> or am I still doin it rong
23:01:26 <ThatTreeOverTher> dmj, ...which is the exact reason I stopped using Node!
23:01:38 <Cale> saurabhnanda: It's like, I think ~8 people? There are some people who I don't interact with on a regular basis because they're working for a different client, and I'm working remote.
23:01:43 <ThatTreeOverTher> (that and the JS cataclysm that happens every week when a new framework comes out)
23:01:45 <EvanR> i guess you didnt have it installed yet
23:01:59 <Cale> saurabhnanda: and it's better than any other way I know of writing web apps
23:02:02 <ThatTreeOverTher> so standard, it doesn't come installed ;)
23:02:12 <ThatTreeOverTher> how should my readFile invocation look
23:02:12 <EvanR> theres a few libs like that
23:02:17 <Cale> saurabhnanda: Reflex is presently harder to learn than it ought to be
23:02:31 <EvanR> :t Data.Text.readFile
23:02:33 <lambdabot> Not in scope: ‘Data.Text.readFile’
23:02:47 <ThatTreeOverTher> naw, like I know the args
23:02:49 <Cale> saurabhnanda: But at some point we do intend to fix that... it's just paid work for clients tends to get prioritized...
23:02:58 <ThatTreeOverTher> but I can call it by saying "readFile" right
23:03:18 <ThatTreeOverTher> after I import Data.Text I can just say "readFile" and Haskell gets what I mean
23:03:36 <EvanR> :t Data.Text.IO.readFile
23:03:38 <lambdabot> FilePath -> IO Data.Text.Internal.Text
23:03:40 <ThatTreeOverTher> if that's the case, then why is there still type error
23:03:45 <ThatTreeOverTher> oh, .IO
23:04:19 <Cale> saurabhnanda: But if you want to try it, the way to do it is to get https://github.com/ryantrinkle/try-reflex
23:04:22 <dmj> Cale: what are your thoughts on servant
23:04:40 <ThatTreeOverTher> EvanR, ambiguous reference: what's the best way to fix that
23:04:46 <dmj> Cale: just curious
23:04:54 <Cale> dmj: I haven't used it, but it looks like it would be better off written in Idris
23:05:08 <EvanR> ThatTreeOverTher: i guess its talking about Prelude readFile
23:05:26 <Cale> dmj: Just because you *can* do something with Haskell's type system...
23:05:31 <Cale> heh
23:05:37 <EvanR> so sometimes you see people import Text qualified and then use the prefix T or TL (for lazy text)
23:06:38 <ThatTreeOverTher> lol I just prelude's definition instead
23:06:43 <ThatTreeOverTher> *hid
23:06:48 <EvanR> possible
23:06:53 <dmj> Cale: heh :] yea. That would be cool. It's definitely an interesting technique. 
23:06:56 <EvanR> readFile sucks anyway
23:07:03 <EvanR> because lazy IO
23:07:38 <Cale> I dunno, lazy IO doesn't *completely* suck
23:07:52 <EvanR> almost completely
23:07:59 <ThatTreeOverTher> EvanR, still an issue, though: couldn't match Data.Text.Internal.Lazy.Text with Data.Text.Internal.Text
23:08:10 <ThatTreeOverTher> this is at my markdown call
23:08:15 <Cale> Sometimes when you're reading one big file, the fact that readFile is lazy means that you don't have to think very hard and your program works, and you're fine.
23:08:35 <EvanR> ThatTreeOverTher: so markdown lib is wanting lazy text... so import Data.Text.Lazy.IO
23:08:47 <EvanR> also read the Text documentation because its important
23:08:54 <cocreature> Cale: and then you’ll run out of file handles and start debugging
23:08:55 <Cale> (if you're doing some kind of stream operation)
23:09:08 <ThatTreeOverTher> holy hell it worked
23:09:10 <Cale> cocreature: But you won't run out of file handles because you have one big file
23:09:19 <cocreature> fair enough
23:09:23 <Cale> cocreature: Unless you only have 0 file handles remaining
23:09:32 <Cale> in which case you're pretty screwed
23:09:36 <cocreature> in that case strict io won’t help you :)
23:09:50 <EvanR> at least strict IO will cause the error to happen sooner
23:10:18 <cocreature> I mostly just use pipes as soon as I do some file io
23:10:40 <domgetter> Cale: You said the type constructor for lists is also a monad, with return v = [v] and xs >>= f = concat (map f xs)
23:10:53 <domgetter> But don't you also have to define the type constructor?
23:10:53 <Cale> domgetter: That I did
23:11:04 <Cale> The type constructor is built in, it's written []
23:11:13 <cocreature> domgetter: the type constructor is [], it takes an a and gives you [a]
23:11:17 <dmj> :t flip concatMap
23:11:19 <lambdabot> Foldable t => t a -> (a -> [b]) -> [b]
23:11:21 <Cale> You can even use it prefix if you like, and write [] Integer  instead of [Integer]
23:11:44 <Cale> dmj: Sigh, Foldable
23:11:59 <domgetter> :t [] 3
23:12:01 <lambdabot>     Couldn't match expected type ‘Integer -> t’ with actual type ‘[t0]’
23:12:01 <lambdabot>     The function ‘[]’ is applied to one argument,
23:12:01 <lambdabot>     but its type ‘[t0]’ has none
23:12:08 <Cale> :k [] Integer
23:12:09 <lambdabot> *
23:12:11 <Cale> :k []
23:12:13 <lambdabot> * -> *
23:12:18 <Cale> This is the type level []
23:12:21 <dmj> Cale: yea, that's unfortunate. At least it's only on 'a', and not on 'b' too 
23:12:26 <Cale> Not the value level [] which is the notation for the empty list
23:12:44 <EvanR> dmj: since it returns a list
23:13:29 <dmj> EvanR: ah I see
23:13:51 <domgetter> so then how would I make a "new" monad?  For lists it's built in, but what would it look like if we did it ourselves?
23:14:05 <EvanR> does list comprehension work with Foldable yet
23:14:25 <dmj> EvanR: you can use overloaded lists
23:14:38 <domgetter> ListyTypeThing = Monad ?
23:14:40 <dmj> but that's cheating
23:16:29 <jle`> domgetter: you can make your own List type
23:16:37 <jle`> data List a = Nil | Cons a (List a)
23:16:56 <Cale> instance Monad MyTypeConstructor where
23:17:00 <Cale>   return v = ...
23:17:05 <Cale>   x >>= f = ...
23:19:14 <domgetter> and then later I might have MyTypeConstructor x  = return 3 ?
23:19:55 <domgetter> And that will have made something of type MyTypeConstructor Int, right?
23:20:13 <EvanR> your data constructor maybe
23:20:26 <EvanR> > let Just x = return 3 in x
23:20:28 <lambdabot>  3
23:20:54 <EvanR> or
23:21:06 <EvanR> > let x = return 3 in x :: Maybe Int
23:21:06 <Cale> domgetter: You're confusing types and values a lot
23:21:07 <lambdabot>  Just 3
23:21:08 <jle`> domgetter: `return 3` is a value, and its type will by MyConstructor Int
23:21:24 <jle`> you can name it 'x', maybe
23:21:33 <Cale> domgetter: Types and values live in completely separate worlds in Haskell, they can never be equal to each other
23:22:00 <EvanR> a type cant be equal to a value anyway ;)
23:22:08 <domgetter> does "MyTypeConstructor x = return 3" not make something called x which has type MyTypeConstructor Int ?
23:22:18 <Cale> EvanR: Well, in some languages types are values.
23:22:31 <athan> So....... InjectiveTypeFamilies will give us... easily deconstructable GADTs with complicated proof objects? :D
23:23:15 <dmj> > sum (1,1)
23:23:17 <lambdabot>  1
23:23:18 <Cale> domgetter: If MyTypeConstructor lives up to its name of being a type constructor, then it doesn't make sense to say that it's equal to a value.
23:23:29 <athan> @type sum
23:23:32 <lambdabot> (Num a, Foldable t) => t a -> a
23:23:32 <Cale> (or that an application of it is, for that matter)
23:23:33 <EvanR> dmj: haskell is broken!
23:23:47 <athan> oh dohs
23:23:52 <dmj> EvanR: :]
23:24:36 <domgetter> Cale: but I can't just have "x = return 3".  it wouldn't know which return to use
23:24:45 <Cale> domgetter: oh, but you can!
23:24:59 <ThatTreeOverTher> return isn't like in other languages
23:25:02 <Axman6> it means ALL returns!
23:25:10 <Cale> domgetter: If it's not determined further, then x will have a polymorphic type, like  x :: Monad m => m Integer
23:25:18 <Cale> Actually, it will probably be more polymorphic still
23:25:27 <Cale> x :: (Monad m, Num n) => m n
23:25:36 <domgetter> so it's ambiguous until it isn't?
23:25:56 <EvanR> there will enough context problemly to know, IRL
23:26:09 <domgetter> and if I do something that looks like I'm using it two ways, *then* the compiler will yell at me?
23:26:22 <EvanR> or infinite ways
23:26:32 <domgetter> "more than allowed"
23:26:47 <domgetter> I assumed any more than one way was unallowed
23:27:04 <Cale> domgetter: Well, if you define x like that at the top level
23:27:15 <EvanR> its not really about ways, its about not knowing which instance to pick
23:27:18 <Cale> domgetter: Then you can use it at as many types as you like, and it'll use the correct return
23:27:33 <Cale> @let returnFive = return 5
23:27:34 <lambdabot>  Defined.
23:27:40 <Cale> :t returnFive
23:27:41 <lambdabot> (Monad m, Num a) => m a
23:27:54 <Cale> > returnFive :: [Integer]
23:27:56 <lambdabot>  [5]
23:28:02 <Cale> > returnFive :: Maybe (Complex Double)
23:28:04 <lambdabot>  Just (5.0 :+ 0.0)
23:28:26 <Cale> What code to use gets determined by context at the usage site
23:28:36 <Cale> Of course, that usage might itself again be polymorphic...
23:28:59 <domgetter> okay but it's always determined at compile time, correct?
23:29:02 <Cale> @let computeTen = liftM2 (+) returnFive returnFive
23:29:04 <lambdabot>  Defined.
23:29:08 <domgetter> Haskell is statically typed after all, no?
23:29:25 <Cale> domgetter: Eventually, you'll have to pick if you want code to actually run
23:29:34 <EvanR> domgetter: its determined, then completely erased at compile time. no more types after that
23:29:47 <Cale> domgetter: But there might be infinitely many concrete types at which you use a polymorphic thing like that
23:31:06 <Cale> :t computeTen
23:31:08 <lambdabot> (Monad m, Num r) => m r
23:31:08 <Axman6> the choice of syntax for classes, the =>, is not an accxident that it looks similar to the function arrow, type classes definitely are "arguments" to polymorphic values, which are hopefully inlined at compile time
23:31:36 <Cale> Hopefully, but also thankfully don't always have to be
23:31:42 <ThatTreeOverTher> it's neither static nor dynamic exactly, just the right mix to fit the program
23:31:43 * hackagebot rebase 0.1.2 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.1.2 (NikitaVolkov)
23:31:56 <Axman6> (this can cause performance issues if you're unlucky, but it's often easy to remedie)
23:31:56 <Cale> Well, the type checking part of it is static
23:33:14 <Cale> domgetter: So one of the basic classes we have is Show
23:33:17 <Cale> :t show
23:33:19 <lambdabot> Show a => a -> String
23:33:36 <Cale> The Show class defines some operations to help turn things into String values
23:34:58 <Cale> > let f :: (Show a) => a -> Integer -> String; f x 0 = show x; f x n = f (x,x) (n-1) in map (f 0) [0..]
23:34:59 <lambdabot>  ["0","(0,0)","((0,0),(0,0))","(((0,0),(0,0)),((0,0),(0,0)))","((((0,0),(0,0)...
23:35:32 <Cale> Computing this infinite list will use the Show instance for Integer, and for (Integer, Integer), and for ((Integer, Integer),(Integer, Integer)) and so on
23:35:46 <Cale> There's really just two instances though
23:35:49 <Cale> The one for Integer
23:35:57 <Cale> and
23:36:08 <Cale> instance (Show a, Show b) => Show (a,b) where
23:36:31 <Cale>   show (x,y) = concat ["(", show x, ",", show y, ")"]
23:36:35 <Cale> something like that :)
23:37:16 <Cale> Plain instances get compiled into records of implementations of the class methods
23:38:22 <Cale> Instances like this one for pairs which depend on some other instances (in this case, the Show a and Show b instances), get compiled into functions which take those records and use them in order to compute the implementation for the combined type
23:38:59 <domgetter> I have nearly no idea what any of that means
23:39:10 <Cale> that's okay, it's touching on a pretty subtle point
23:39:51 <Cale> That basically, there are cases where the set of types on which you need an instance of a class at runtime is infinite, and that's okay
23:42:04 <Cale> (but this doesn't really come up terribly often... usually it's finite, and you could imagine that the compiler just generates all the instance code statically and maybe even inlines it in a lot of cases)
23:43:09 <dustmote> does anyone know of a typeclass which implements something like the dual of foldable?
23:43:35 <t0by> um, what would the dual of foldable be?
23:43:35 <dustmote> i'm thinking of a "class for producing different kinds of summary values"
23:43:45 <t0by> i'm thinking of iterate?
23:43:49 <Cale> dustmote: Isn't that Foldable?
23:43:57 <dustmote> foldable is the "class of data structures which can be foldable"
23:44:03 <dustmote> err
23:44:06 <dustmote> folded to a summary
23:44:10 * t0by scratches head
23:44:15 <dustmote> i'm looking to implement several different summaries
23:44:19 <Cale> dustmote: err... what would the operations be?
23:44:22 * t0by \-o-/
23:44:28 <Axman6> you can almost implement type classes yourself if you use records; data Show a = Show { show :: a -> String, shows :: a -> ShowS} (or whatever else exists in Show), then you can pass around particular implementations for each type (or even different implementations for the same type, if you want). Type classes basically do that for you automatically, but only allow one version per type a
23:44:36 <dustmote> `foldr :: (a -> b -> b) -> b -> t a -> b`
23:44:49 <EvanR> :t unfoldr
23:44:50 <Cale> Axman6: Right... I probably should have said that earlier
23:44:50 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
23:45:07 <EvanR> :t toList
23:45:08 <lambdabot>     Ambiguous occurrence ‘toList’
23:45:09 <lambdabot>     It could refer to either ‘Data.Foldable.toList’,
23:45:09 <lambdabot>                              imported from ‘Data.Foldable’ at /home/lambda/.lambdabot/State/L.hs:86:1-20
23:45:12 <ReinH> dustmote: no, the operatinos of your typeclass
23:45:15 <Axman6> Cale: I'm just glad you agree with me, I'm not often right about these things :P
23:45:45 <EvanR> :t foldMap
23:45:47 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
23:46:02 <dustmote> ReinH: Cale: the operations would be `base :: b`, `combine :: a -> b -> b`, and `compute :: b -> c`
23:46:10 <dustmote> I've tried implementing such a class
23:46:13 <EvanR> (t a -> m) -> (a -> m) ;)
23:46:26 <orion> Hi. I have a very strange problem. I have a QuickCheck application, and when I specify 1 test (--quickcheck-tests), everything passes. When I specify 100 tests, all tests pass, and the last one hangs. When I inspected the application with truss, I got the following output: https://gist.github.com/centromere/408eb3e83c3328c2a11f <-- Basically it's a bunch of SIGALRMs.
23:46:39 <dustmote> b is the accumulator, a is the elements being folded over, and c is the summary value
23:46:43 <Cale> dustmote: Do you know about Monoid at least?
23:46:44 * hackagebot json-ast-quickcheck 0.1 - Compatibility layer for "json-ast" and "QuickCheck"  https://hackage.haskell.org/package/json-ast-quickcheck-0.1 (NikitaVolkov)
23:46:48 <dustmote> Yes
23:46:54 <orion> I am using GHC 7.10.3 on FreeBSD, and the problem happens on Ubuntu too.
23:46:56 <athan> EvanR: So you could write a `StateT b (MaybeT Identity) a` to unfold?
23:46:57 <dustmote> Cale: so I used the monoid impl of sum and product
23:47:06 <Cale> So like, if you can write a function a -> b, where you have Monoid b
23:47:08 <ReinH> How does combine work?
23:47:11 <EvanR> athan: nope
23:47:23 <dustmote> ReinH: it's the combiner function you'd pass to foldr
23:47:28 <Cale> Then you can combine all the b values using the Monoid instance
23:47:29 <dustmote> right associative binary op
23:47:39 <orion> Additionally, the problem is reproducible 100% of the time.
23:47:42 <EvanR> athan: er, i guess so, runState inside the unfold
23:47:43 <Cale> and then the compute :: b -> c is just another unrelated function?
23:47:46 <Axman6> dustmote: seems similar to the foldl package's Fold type: https://hackage.haskell.org/package/foldl-1.1.4/docs/Control-Foldl.html
23:48:05 <dustmote> Cale: but what if the elemnts you're summarizing over aren't the same as the type of the summary's intermediate values?
23:48:09 <Axman6> Fold a b = forall x . Fold (x -> a -> x) x (x -> b)
23:48:18 <dustmote> Cale: no, compute is how you extract the summary value from the accumulator
23:48:19 <athan> EvanR: Why would you need to runState in the fold?
23:48:44 <athan> er derp
23:48:44 <EvanR> athan: since the argument to unfold isnt of type StateT...
23:48:52 <athan> yeah I'm not sleeping well sorry
23:48:53 <athan> thank you
23:48:54 <ReinH> So the typeclass packages up the arguments to foldr and ... something else?
23:49:03 <dustmote> Cale: ReinH: eg. for mean you'd want to accumulate a tuple containing sum and count.. compute is /
23:49:09 <Cale> dustmote: I have a hard time imagining what laws it could ever satisfy, which makes it seem like it doesn't belong. I can imagine a multiparameter type class for base and combine though
23:49:25 <Cale> dustmote: Actually it's usually more useful just to have that as a record
23:49:40 <dustmote> Cale: howso?
23:49:42 <Cale> dustmote: However, there is a free such construction
23:49:50 <Cale> Just pick b = [a]
23:49:54 <Cale> base = []
23:49:58 <Cale> and combine = (:)
23:50:13 <ReinH> dustmote: so something like this? http://www.haskellforall.com/2013/08/composable-streaming-folds.html
23:50:42 <ReinH> @hackage foldl
23:50:42 <lambdabot> http://hackage.haskell.org/package/foldl
23:50:43 <Cale> and then foldr combine base will do computation using any other combine and base...
23:50:52 <dustmote> ReinH: that loosk promising
23:50:54 <ReinH> Or perhaps something like
23:50:58 <ReinH> @hackage folds
23:50:58 <lambdabot> http://hackage.haskell.org/package/folds
23:51:01 <dustmote> ReinH: the gonzales link
23:51:18 <dustmote> Cale: i'm not following your example
23:51:27 <dustmote> Cale: base and combine are clear.. 
23:51:27 <ReinH> That link became the foldl package
23:52:24 <Cale> dustmote: I'm basically just saying that anything you could do using that interface can be factored into constructing a list and applying foldr to the resulting list
23:53:00 <Cale> Which might not always be the best idea in terms of performance, if for some reason you don't get fusion to happen
23:53:05 <ReinH> The folds package is another interesting version
23:53:37 <Cale> but a large part of the point of having laziness is so that data structures such as lists can do jobs like that
23:53:47 <ReinH> What you're talking about sounds like Data.Fold.R
23:54:28 <Cale> For left folds it's a bit trickier to get the composability you might want, which is why you have things like that foldl package
23:54:45 <orion> I think I found a bug in GHC.
23:54:51 <ReinH> Except it's data rather than a typeclass
23:55:22 <Cale> orion: Make sure to mention it in #ghc -- some of the GHC devs watch there a bit more closely than here
23:55:34 <dustmote> Cale: ReinH: yeah, package folds or foldl are basically what i want
23:56:36 <orion> Cale: Thanks
23:56:44 <Cale> Foldable actually kind of makes me sad because it's a kind of admission of defeat in most usages
23:56:50 * hackagebot NoTrace 0.3.0.0 - Remove all the functions come from Debug.Trace after debugging  https://hackage.haskell.org/package/NoTrace-0.3.0.0 (CindyLinz)
23:56:52 <ReinH> heh
23:56:59 <dustmote> Cale: why is that?
23:57:38 <Cale> Like "we couldn't figure out how to efficiently compile these largely iterative operations when they went via a list, so here's a handcrafted version of each"
23:59:00 <dustmote> Cale: ah, you mean doing a convetional fold on the `toList` of a data structure was slow, so that's why foldable was made?
23:59:22 <Cale> Yeah, well "slow" -- usually it's actually fast and space efficient enough.
23:59:29 <Cale> But everything's relative
23:59:43 <dustmote> Cale: hmm.. weird
23:59:48 <dolio> You can't go via toList, anyway. It's inadequate.
23:59:55 <Cale> Well, not in all cases
23:59:57 <Cale> sure
