00:02:13 <opqdonut> Lokathor: the Monad is correct
00:02:24 <opqdonut> Lokathor: and the applicative instance looks ok too
00:02:29 <Lokathor> coo
00:05:17 <jle`> Lokathor: looks good to me.  good call on checking though, there are actually several ways you can implement Applicative and Monad that give either incorrect or unexpected results
00:05:38 <Lokathor> i talk about one of those in my article
00:05:42 <Lokathor> well, an incorrect Functor
00:05:45 <jle`> it's one of the more common "let the type system do the work for you!" examples people throw out, but it's deceptively tricky
00:06:56 <jle`> one of my fav things though that's cute is how easy it is to directly make the instances work for StateT s m a
00:07:39 * hackagebot hkdf 0.0.1.1 - Implementation of HKDF (RFC 5869)  https://hackage.haskell.org/package/hkdf-0.0.1.1 (JiriMarsicek)
00:07:39 * hackagebot language-thrift 0.6.2.0 - Parser and pretty printer for the Thrift IDL format.  https://hackage.haskell.org/package/language-thrift-0.6.2.0 (abhinav)
00:07:40 <Lokathor> yeah i wanted to step through State as its own newtype, and then step through StateT and so on
00:12:26 <Lokathor> https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html on this page, the Functor definition doesn't include the "forall a b." part
00:12:31 <Lokathor> but the Monad definition does
00:12:38 <Lokathor> is there some reason for that?
00:19:38 <jle`> Lokathor: that's interesting
00:19:56 <jle`> it has to do with the instance declaration itself, which uses a redundant forall
00:20:12 <Lokathor> ah
00:20:38 <Lokathor> well i suppose i won't concern myself much with it, if it's not doing anything special
00:20:40 <jle`> i personally think that the leaking of forall's which exist only to help the typechecker with ScopedTypeVariables is a big problem with hackage docs
00:20:49 <jle`> but in this case the forall's are 100% redundant
00:21:11 <jle`> might just be an inconsistent coding style
00:21:34 <jle`> a bit unfortunate
00:22:24 <jle`> it's not there for Applicative, either
00:23:06 <jle`> it's sorta unfortunate because it makes the documentation for Monad a bit more inaccessible to new users
00:23:17 <jle`> which isn't something Monad particularly needs at the moment
00:23:35 <jle`> but there's been a recent push for new/fresh documentation for GHC 8.0, maybe now is the time to fix this?
00:26:42 <Lokathor> java is scrambling to implement value types
00:26:53 <Lokathor> and we're so high on the horse we wonder if we shoudl adjust the docs :3c
00:27:00 <Lokathor> *evil villian laugh and such*
00:27:32 <z16> Not cool bro
00:27:37 <z16> Don't laugh at the handicapped
00:28:47 <MarcelineVQ> There's new user-guide docs, dunno about source doc status
00:32:54 <Skuzzzy> Functional programming is cool, but not cool enough to warrant using functional languages
00:33:05 <Skuzzzy> just port functional capabilities to imperative 
00:33:14 <Lokathor> Skuzzzy, that is not possible
00:33:29 <MarcelineVQ> why not
00:33:48 <echo-area> ReinH: You were right, `pred` should have polymorphic type `Church a -> Church a`.  I just figured that I wasn't able to define it because the Haskell definition was fundamentally different from the lambda calculus one on their types: Church a ~ (a -> a) -> a -> a, while the lambda calculus version would be Church a ~ ((a -> a) -> (a -> a)) -> (a -> a) -> a -> a
00:35:12 <Lokathor> MarcelineVQ, why, that's as silly as saying that you want to build a chapai but you refuse to use naqahdah because it's too hard to mine and that you're just going to use steel instead!
00:36:01 <Lokathor> chappa'ai*
00:36:52 <MarcelineVQ> https://s-media-cache-ak0.pinimg.com/736x/73/79/b9/7379b983dbaa1cfda59849269a1aec92.jpg
00:37:06 <Lokathor> ;3c
00:37:35 * hackagebot open-browser 0.2.1.0 - Open a web browser from Haskell.  https://hackage.haskell.org/package/open-browser-0.2.1.0 (rightfold)
00:37:37 * hackagebot base-prelude 0.1.21 - The most complete prelude formed from only the "base" package  https://hackage.haskell.org/package/base-prelude-0.1.21 (NikitaVolkov)
00:37:53 <Lokathor> Skuzzzy, to respond to you more seriously, functional purity is what enables the top level techniques of functional programming. Without functional purity it's just not as good
00:38:40 <Lokathor> and specifically, *compiler enforced* functional purity.
00:38:59 <Skuzzzy> Yeah, not as good. But you can do it yourself somewhat, see const correctness in C++
00:39:25 <bartavelle> Skuzzzy, this is already being done all over the place though
00:39:42 <bartavelle> ideas from functional programming are being ported "mainstream"
00:39:55 <bartavelle> but this is just not as good as when you have all the features working together
00:39:57 <bartavelle> IMO
00:40:00 <Lokathor> Skuzzzy, no matter how const you make your c++, if a function to filter a list can also *sometimes* fire a missile, you can't safely perform is lazily, or have the compiler safely run it in parallel
00:40:46 <Lokathor> worse, maybe it didn't yesterday, but you rebuild today and someone else changed the code base and you can't tell
00:40:58 <Skuzzzy> Ye, it would be nice to have a more pure imperative language. I know haskell you have to declare things that produce side affects, correct?
00:41:21 <Lokathor> yes, side effects get declared within a function's type
00:41:23 <Skuzzzy> That would be a nice language feature, could be some function modifier 
00:41:33 <merijn> Skuzzzy: To be fair, my favourite imperative language is Haskell. No joke.
00:41:47 <bartavelle> Skuzzzy, but why not just use Haskell then? It already is an awesome imperative language
00:41:57 <Lokathor> why not use haskell? Haskell is the best imperative language! We even have STM. C# doesn't have STM
00:41:58 <bartavelle> much better than anything I used anyway
00:42:01 <merijn> And I know I'm not alone :)
00:42:11 <Skuzzzy> I won't get bullied for using haskell imperatively will I?
00:42:19 <Skuzzzy> All the kids at school won't think I am a loser?
00:42:20 <Lokathor> nope
00:42:31 <Lokathor> but you might realize that you don't need to be as imperative as you think
00:42:40 <suppi> you might get bullied by the compiler though
00:42:50 <suppi> and then language
00:42:53 <Skuzzzy> Any resources youall would suggest?
00:43:00 <Skuzzzy> I played around with learn you a haskell a while back
00:43:05 <Skuzzzy> But havnt touched in much since
00:43:12 <Lokathor> to begin tinkering right away, this is a good course: http://www.seas.upenn.edu/~cis194/spring13/lectures.html
00:43:12 <merijn> Skuzzzy: A lot of haskell I write is multi-threaded/networking stuff, so basically IO all over the place. In my experience writing IO heavy haskell is pretty pleasant, since you still get all the type niceties and algebraic data types :)
00:43:41 <merijn> Skuzzzy: I've also heard good things about http://haskellbook.com/ (but as usual opinions differ)
00:43:42 <Lokathor> your best bet to install haskell is to setup stack, https://github.com/commercialhaskell/stack/releases
00:43:54 <merijn> Skuzzzy: It also depends on how many/which languages you know already
00:44:08 <Lokathor> HaskellBook.com is a very very good source, but it's not free (worth the price though)
00:44:25 <Skuzzzy> Stack?
00:44:32 <suppi> www.haskellstack.org
00:44:32 <Lokathor> stack is a project management tool
00:44:39 <Lokathor> it can also get GHC (the compiler) for you
00:44:41 <Skuzzzy> Oh neat, I'll check it out
00:44:56 <Skuzzzy> I think I have ghc from when I played around with it before
00:45:33 <Lokathor> you might want to get a newer version if you have ghc from "a while back".
00:46:06 <Lokathor> it improves in leaps, and frequently enough
00:46:09 <merijn> GHC is one of the few projects where every release makes me go "oh god, look at the fancy new stuff!"
00:46:30 <Lokathor> oh silly me, i already wrote an starter's guide page https://lokathor.gitbooks.io/haskell-stuff/content/
00:47:07 <merijn> Lokathor: :p
00:47:14 <z16> Lokathor: http://vignette4.wikia.nocookie.net/stargate/images/d/d8/MiniStargate1.jpg/revision/latest?cb=20150615033535
00:47:32 <Skuzzzy> Eh, I'm on debian so it was probably upgraded from apt-get update
00:47:36 <Skuzzzy> upgrade*
00:47:40 <Lokathor> yeah and how well did that work out for him? and considering he was a lantian scientist as well or something
00:48:00 <Lokathor> really they need to meet more aliens that aren't scientists and stuff. Like, just an alien barista
00:48:05 <z16> Exactly, the pros don't need Naquadah
00:48:06 <z16> ;p
00:48:28 <bartavelle> Skuzzzy, AFAIK the debian port is very old
00:48:39 <merijn> Skuzzzy: If you know C++ you might also wanna just dive into the Haskell2010 Report 
00:48:45 <z16> There are very few purely functional programming languages in the first place
00:48:47 <Lokathor> Skuzzzy, yes, debian's upgrade speed will leave you several significnat versions behind with GHC
00:49:04 <z16> And you can employ functional programming techniques in most languages these days
00:49:05 <Lokathor> merijn, i'm not sure... that i would go that far
00:49:15 <merijn> Since it's one of the most readable language specs in existence
00:49:28 <z16> merijn: Tbf, the bar is not set very high :)
00:49:35 <merijn> z16: True :p
00:49:46 <bartavelle> Lokathor, turns out it's 70.10.3! https://packages.debian.org/unstable/haskell/ghc
00:49:52 <bartavelle> erm, 7.10.3
00:49:59 <Lokathor> oh my!!
00:50:04 <merijn> Lokathor: After trying to look up things in the C and/or C++ standard the report is like a breath of fresh air :)
00:50:06 <Skuzzzy> is that good or bad?
00:50:12 <merijn> Skuzzzy: Good
00:50:12 <Lokathor> 7.10 is good
00:50:23 <bartavelle> it's the latest release
00:50:26 <Lokathor> but, that's in the unstable repo, so you'll have to enable that
00:50:31 <z16> Have you ever had to find something in the C++ standard? Good luck
00:50:44 <z16> And even if you did, it's usually five pages with thirty special cases
00:50:53 <Lokathor> merijn, i'd never suggest a language's standard as a way to learn a language. not even for Esperanto
00:51:00 <z16> 20 of which are considered "undefined behavior", and they work differently in every compiler
00:51:15 <merijn> z16: Work differently in *the same compiler*
00:51:22 <z16> Hah
00:51:27 <Gurkenglas> @letlpaste 3641474600140800000
00:51:28 <lambdabot>  Parse failed: Parse error: ;
00:51:29 <Lokathor> depends on how full the moon is
00:51:34 <Gurkenglas> But there isn't even a ; in http://lpaste.net/3641474600140800000
00:51:40 <merijn> Lokathor: I dunno, I frequently see people not knowing details of the grammar that are easily explained in the Report that no one reads :)
00:52:22 <merijn> Lokathor: I think everyone should read most of the report at least once. And my experience with introducing C++ programmers to Haskell is that they appreciate the brevity of the report as a starting point. YMMV, of course
00:52:39 <Lokathor> i can think of a particular such individual who i often wish would just read a better book than the one he's been learning haskell from
00:52:40 <Lokathor> ah well
00:52:41 <frerich> z16: To be fair, given how portable C(++) aims to be, there's not a whole lot of things you can define and rely on.
00:52:55 <Gurkenglas> Oh, unbalanced brackets. Probably that parse error because letlpaste injects into L.hs or something
00:53:11 <bartavelle> frerich, portable *and*
00:53:11 <z16> frerich: Which some consider a strength (and it certainly helps with portability), but for reliability it's a horrible nightmare
00:53:13 <bartavelle> * performant
00:55:01 <Lokathor> can someone name a functor that isn't an applicative. and also an applicative that is not a monad
00:55:07 <Lokathor> just as an example
00:55:29 <ggole_> Lokathor: see http://blog.functorial.com/posts/2015-12-06-Counterexamples.html
00:55:31 <merijn> Lokathor: Yes, Const is not Applicative
00:55:45 <merijn> Lokathor: And Const with a monoid constraint is Applicative, but not a Monad
00:55:51 <Lokathor> ah ha, perfect
00:56:13 <ggole_> (It is for PureScript, but I believe it will serve the purpose.)
00:56:14 <Lokathor> ah yes, the "monoidal structure of applicative"
00:56:54 <merijn> I always recommend people try to implement Functor/Applicative/Monad for "data Const k a = Const k" and see how far they get :)
00:57:07 <Lokathor> did that the other day in fact
00:57:45 <Lokathor> embarassingly, i said "fmap f cons = cons" at first and moved on without typing it in
00:57:52 <Clint> same with (a,)
00:57:54 <Lokathor> lead to all sorts of troubles
00:58:20 <KaneTW> talking about types
00:58:25 <merijn> Clint: Yeah, I guess that one's better because "Const is useless" for many beginners :)
00:58:33 <suppi> Lokathor, http://blog.functorial.com/posts/2015-12-06-Counterexamples.html
00:58:42 <Clint> heh
00:58:48 <suppi> oh, I should read comments first -_-
00:59:22 <Fuco> what is the point of the 'a' in that Const definition if it isn't used on the other side?
00:59:33 <merijn> Fuco: It's a phantom parameter
00:59:41 <Fuco> not really helping :D
01:00:02 <Fuco> but I'll google that up, I'm sure lot has been said
01:00:06 <Fuco> thanks for the pointer
01:00:09 <merijn> Fuco: They're called phantom's because they don't "have a body", i.e. they only appear in the type, not in the body
01:00:51 <KaneTW> let's say i have a type `data Connection (a :: ConnMode) = Conn` with `data ConnMode = A | B | C`. is there any way to write a function `f :: Connection a -> Connection B` where a /= B?
01:00:52 <merijn> Fuco: To see a usecase of Const you can look at edwardk's lens talk. Const is used there to build getters (I think?)
01:01:27 <merijn> KaneTW: Yes, no, maybe :p It depends, how much voodoo are you willing to use for this? :)
01:01:29 <edwardk> it is used to read from a getter at any rate
01:01:30 <suppi> merijn, i was about to point that also, link to spj's talk: https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation
01:01:32 <suppi> :)
01:01:40 <merijn> @where lens
01:01:40 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
01:01:46 <merijn> Fuco: See that youtube link :)
01:01:54 <KaneTW> i'm open for voodoo but i don't want to pass around explicit proofs that a /~ B
01:01:57 <Fuco> I found this https://wiki.haskell.org/Phantom_type that seems to be a succint overview
01:02:01 <ggole_> Fuco: much the same use as const, except at the type level
01:02:04 <Fuco> I'm unfortunately in the office so no youtube
01:02:21 <merijn> KaneTW: Witness this amazing closed type family abuse! https://gist.github.com/merijn/6130082 :)
01:02:56 <KaneTW> cool
01:03:20 <KaneTW> it'd probably be even prettier with TypeError in GHC8
01:03:24 <merijn> KaneTW: It turns any unifying types into a failing constraint
01:03:27 <merijn> KaneTW: Yeah
01:03:57 <merijn> KaneTW: I actually asked for something like TypeError when I first wrote this and it got shot down on ghc-devs, but apparently I somehow managed to inception it into some devs brain :p
01:04:04 <KaneTW> haha
01:04:12 <Fuco> so the phantom types can be used to encode some runtime invariants in the type... that's neat
01:05:06 <merijn> Fuco: Is a fun exercise mentioned earlier, try to write down Functor, Applicative and Monad instances for "data Const k a = Const k" and see how far you get and when/why the laws fail :)
01:05:40 <suppi> Fuco, https://en.wikibooks.org/wiki/Haskell/Phantom_types :)
01:06:02 <bartavelle> Fuco, a canonical example would be something like `newtype Money a = Money Int`, and you use it like `credit : Account c -> Money c -> Account c`
01:06:17 <bartavelle> that way even though money is just an int, you can't mix currencies
01:06:50 <Fuco> yea, that's a nice example!  Similar to that validation thing on the wiki
01:07:36 * hackagebot Michelangelo 0.2.4.0 - OpenGL for dummies  https://hackage.haskell.org/package/Michelangelo-0.2.4.0 (SwiftsNamesake)
01:07:56 <bartavelle> It is used in libraries like "persistent" to annotate the type of the primary keys too
01:08:08 <bartavelle> or any key really
01:08:10 <Fuco> that 2d/3d vector example is also nice 
01:09:56 <ggole_> They're a good counterexample to the common suggestion that types are sets of values, too
01:12:37 * hackagebot Cartesian 0.2.1.0 - Coordinate systems  https://hackage.haskell.org/package/Cartesian-0.2.1.0 (SwiftsNamesake)
01:18:29 <suppi> damn it
01:18:42 <suppi> I hate that upgrading software breaks features
01:19:03 <suppi> any reason upgrading spacemacs should break flycheck messages?
01:28:10 <suppi> ok, back to business
01:31:55 <Fuco> merijn: so for the Functor it has to do nothing, because I can't reasonably apply the function to the inner value, since the function operates on the "variable" type which I don't know.   I verified the laws and it holds so that must be the only instance possible
01:32:16 <Fuco> merijn: for applicative (and also monad) I have a problem with pure/return... what to put there if the type is pure :: a -> Const x a ...
01:32:23 <Fuco> I can't conjure x from nowhere
01:33:21 <merijn> Fuco: Fun fact: "the only instance possible" is always true for lawful functors :)
01:33:37 <merijn> Fuco: It is impossible for a type to have more than 1 lawful Functor instance :)
01:33:40 <Fuco> that's what I'm counting on :D
01:33:56 <Fuco> I could make x a monoid and use mzero
01:34:02 <Fuco> that would fix pure at least
01:34:16 <merijn> You mean mempty, mzero is from MonadPlus, but yes :)
01:34:29 <Fuco> oh yes 
01:34:46 <merijn> Fuco: Next question is if you add a Monoid constraint, do you need to do anything special for <*> to be lawful? :)
01:42:27 <Fuco> man this is confusing :D
01:46:43 <Fuco> from the first three laws it would work if I just let it copy the last argument... but then the exchange law breaks
01:47:06 <Fuco> those pures make zeroes basically, so I need to preserve the non-zero value...
01:47:22 <Fuco> which I could do with mappend, as mempty acts as nothing
01:49:06 <Fuco> but applicative instances aren't unique as far as I know, so is there some other way too?
01:51:30 <merijn> Fuco: Applicative instances aren't unique, but I think the one for Const is
01:52:11 <Fuco> hey, since when do we have "class Applicative m => Monad m where" ?
01:52:17 <wowdog> Hi, anyone know how to log all the history in Predule?
01:52:17 <merijn> 7.10 :)
01:52:25 <Fuco> sweet
01:53:31 <Fuco> now for the monad I could use return = pure, so let's see where it fails with bind
01:54:15 <srhb> wowdog: Log the history? What history?
01:55:18 <srhb> wowdog: If you're talking about ghci history, it's in ~/.ghc/ghci_history
01:55:36 <wowdog> in Predule, if I use let x = [1..10], and print x, I want   all my code in a file, 
01:55:58 <Fuco> right, so already x >>= return = x fails because return will always give me back Const mempty
01:56:32 <merijn> Fuco: A hint, can you write out the type of >>= with 'm' instantiated by "Const k"? :)
01:56:36 <merijn> :t (>>=)
01:56:36 <srhb> wowdog: Prelude is the default always-imported module in Haskell land. I think you're talking about your ghci history.
01:56:37 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:57:32 <srhb> wowdog: Mind, that's the command history, not valid Haskell code. You could replay it in another ghci session, though, with :script
01:57:38 <Fuco> well, Const k a -> (a -> Const k b) -> Const k b
01:58:01 <merijn> Fuco: And to get a Const out of "a -> Const k b", what do you need? :)
01:58:44 <Fuco> I need a value of type 'a'
01:58:48 <wowdog> ok. thx.. I just check the ~/.ghci/ghci_history, I think this is what I need 
01:59:13 <Fuco> right, and Const k a doesn't give me that
01:59:25 <merijn> Fuco: Right, which is something you can never get :)
01:59:38 <merijn> Fuco: Which is why Const can't be a Monad :)
01:59:48 <srhb> wowdog: I'm not quite sure why you want it, usually people write a haskell source file and load it with ghci file.hs or :l file.hs in ghci
02:02:06 <quchen> merijn: I don't think so. Proxy is a Monad as well, even though you can't get an "a" out of it. The reason Const isn't a Monad is because you can't construct the "k", not because (a -> Const k b) has an "a" argument.
02:02:28 <quchen> … unless that's what you meant, in that case I read it wrong. :-)
02:02:28 <merijn> quchen: No, the reason Proxy is that Proxy has a unique element
02:02:39 <merijn> quchen: And purity means that you can ignore the input argument
02:03:11 <merijn> quchen: "x >>= f = Proxy" is safe, because 'f' can never return anything other than Proxy, regardless of the 'a' you give it
02:03:16 <Fuco> quchen: if I had 'Const x >>= f' = how would I use f
02:03:20 <merijn> So you can skip calling 'f' without violating the law
02:03:45 <merijn> Whereas for Const 'f' can potentially generate any number of "Const k b" values and you don't know which without running 'f'
02:03:55 <Fuco> what if I made a, b into monoids as well...
02:04:02 <quchen> Ah right, bind has to work for all (a -> m b).
02:04:03 <wowdog> yep, sometimes I just want to test some function in my ghci
02:04:04 <Fuco> then I could throw it mempty again :P
02:04:11 <quchen> Nevermind, and thanks for the pointer.
02:04:16 <merijn> Fuco: That wouldn't be lawful, though :)
02:04:57 <Fuco> hm
02:06:36 <Fuco> instead of doing work I spent an hour checking stupid homomorphism laws... time well spent
02:06:47 <Fuco> I'll file it under "employee education" task :D
02:07:33 <sternenseemann> does anyone know if it is documented how ghc does represent signed integer types?
02:07:53 <merijn> sternenseemann: What do you mean by that?
02:08:05 <sternenseemann> i am trying to split a Integer into Words and fail on negative integers
02:08:20 <merijn> sternenseemann: Integer uses libgmp
02:08:55 <sternenseemann> e. g. I currently have this code: http://lpaste.net/148479
02:09:11 <sternenseemann> it is an invinite loop on negative numbers
02:09:54 <sternenseemann> it seems like the the first bit is 1 then until bit 7 0s and then an infinite number of 1s
02:10:14 <sternenseemann> 100000001111111111111111111111111111…
02:10:41 <Fuco> Your computer might have infinite memory.  Have you been visited by aliens lately?
02:10:46 <Fuco> sitting on a goldmine!
02:11:43 <Fuco> sternenseemann: the problem is that shift does bit extension
02:11:51 <Fuco> so for a negative number it will prefix with 111111111111111
02:12:03 <sternenseemann> Fuco: integers are (virtually) infinitely big :p
02:13:27 <merijn> > shift (-1 :: Integer) (-64)
02:13:29 <lambdabot>  -1
02:13:32 <merijn> See
02:13:57 <sternenseemann> > shift (-1 :: Integer) (-128)
02:14:00 <lambdabot>  -1
02:14:14 <sternenseemann> the question is what I am going to do about that
02:14:25 <sternenseemann> > complement (-1)
02:14:26 <lambdabot>  0
02:14:54 <Fuco> maybe shift the mask, & shift back
02:15:07 <Fuco> it's a bit clumsier thouhg
02:16:21 <Fuco> or you could do a complement on a negative, use your algorithm and then map complement over the result
02:16:25 <Fuco> that should work I guess?
02:16:53 <sternenseemann> tried that just now
02:17:24 <sternenseemann> http://lpaste.net/148481
02:17:35 <sternenseemann> split (-0xff)
02:17:35 <sternenseemann> [18446744073709551361]
02:17:42 <sternenseemann> split 18446744073709551361
02:17:42 <sternenseemann> [18446744073709551361]
02:17:42 <sternenseemann> split 18446744073709551361
02:17:43 <sternenseemann> [18446744073709551361]
02:18:07 <sternenseemann> the problem now is that the generated list is not unique anymore
02:19:13 <bollu> where does "stack haddock" dump docs to?
02:19:22 <Fuco> sternenseemann: I don't think it was before either
02:19:42 <Fuco> imagine you had Integer using up just 64 bits, you would never know if the top bit means negative or simply last positive bit
02:19:49 <bollu> (I have an executable whose docs I want)
02:19:54 <sternenseemann> hm
02:20:15 <Fuco> you would need to prefix the whole thing with another extra word signifying sign I think
02:20:35 <Fuco> which could be just 0 or complement 0 (= all 1s)
02:20:37 <bollu> I'm sorry but haskell tooling is frustrating :/
02:21:17 <Fuco> still not so frustrating as python... I have yet to come along a library where pip install actually worked :D
02:21:27 <bollu> Fuco: virtualenv :)
02:21:39 <srhb> bollu: Somewhere in ~/.stack or proj/.stack
02:21:40 <Fuco> I only know cabal and that dumps docs into dist
02:21:55 <Fuco> granted my python-fu is minimal 
02:21:59 * Ab123 slaps Cale around a bit with a large fishbot
02:22:14 <bollu> srhb: oh, so if I want to check the docs I have to go look there?
02:22:20 <srhb> bollu: I suppose so.
02:23:03 <srhb> Oh, it will be .stack-work for projects I think.
02:23:10 <srhb> (I don't use Stack much.)
02:23:14 <bollu> also, stack as a name is un-googleable
02:23:22 <bollu> srhb: stack has been a godsend after dealing with cabal
02:23:29 <bollu> makes it, at least 2x easier for newbies
02:24:36 <Fuco> 2016 year of industry haskell!
02:24:50 <bollu> Fuco: I wish I could get summer haskell internships :P
02:25:03 <KaneTW> i wish i could get part-time remote haskell work
02:25:55 <Ab123> i just need summer internship in haskell can anyone help ?
02:26:40 <bollu> Ab123: same boat
02:26:59 <Ab123> bollu: yeah :P
02:27:36 <Fuco> you need to come up with a good argument of "what can haskell do that php can't" to land a haskell job :D
02:27:43 <bollu> any stack people here? there's no documentation about what `stack haddock` does in the User guide
02:27:51 <bollu> Fuco: but, but, type safe routing :P
02:28:16 <bollu> Fuco: I spent the last month re-writing servers in Python in better Python. was not fun dealing with python magic and type errors
02:28:18 <srhb> bollu: I usually just use Nix. :) I might switch when stack can use it to grab all its binaries from.
02:28:25 <Fuco> I write php at work and I used haskell once for some minor number crunching, but that wasn't enough to convince my boss to "let's rewrite the entire system in haskell" :D
02:28:56 <bollu> Fuco: it's frustrating to write server code in a dynamically typed language because of the "oops I broke and the only way to test me is to run me"
02:29:04 <Fuco> yea indeed
02:29:15 <Fuco> even more so when it is highly coupled and incomprehensible
02:29:21 <Fuco> and no tests :D
02:29:27 <sternenseemann> Fuco: thanks, prefixing a 0 makes sense
02:29:32 <bollu> Fuco: story of my life with web servers I'm pulled into >_>
02:30:10 <bollu> Is it considered "bad manners" to upload a package onto Hackage when it is incomplete?
02:30:22 <bollu> I want to push a package (just to see what it looks like on Hackage)
02:30:29 <Fuco> under 1.0 everything goes I guess
02:30:38 <merijn> bollu: There's a candidate function
02:30:43 <bollu> merijn: meaning?
02:30:55 <Fuco> oh yes... meaning it isn't published but you see it 
02:30:59 <Fuco> to check for errors etc
02:31:01 <merijn> bollu: It does basically that, upload to hackage to check what it looks like, but don't publish it
02:31:02 <bollu> oh cool
02:31:06 <bollu> thanks
02:31:29 <merijn> "Package candidates are a way to preview the package page, view any warnings or possible errors you might encounter, and let others install it before publishing it to the main index. (Note: you can view these warnings with 'cabal check'.) You can have multiple candidates for each package at the same time so long as they each have different versions. Finally, you can publish a candidate to the main index if
02:31:35 <merijn>  it's not there already."
02:31:41 <bollu> um wait, you need to upload a single file?
02:31:56 <merijn> bollu: Use "cabal sdist" to pack up everything into a single tar file
02:32:01 <bollu> oh cool
02:32:23 <merijn> Well, everything specified in your cabal file, anyway :p
02:33:12 <merijn> @hoogle (a -> Bool) -> [a] -> ([a], [a])
02:33:14 <bollu> um, wait, you login to Hackage using your name and not your email?
02:33:16 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
02:33:16 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
02:33:17 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
02:33:20 <bollu> my name is kinda long
02:33:27 <bollu> why not e-mail?
02:33:46 <bollu> byorgey: ping
02:33:48 <merijn> Is there something like filter that returns both the kept and removed elements?
02:33:59 <puregreen> bollu: you can put it into .cabal/config and then you won't have to enter it
02:34:07 <bollu> puregreen: cool
02:34:13 <verement> :t partition
02:34:15 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
02:35:07 <verement> > partition even [1..10]
02:35:09 <lambdabot>  ([2,4,6,8,10],[1,3,5,7,9])
02:37:18 <bollu> who curates stackage?
02:37:26 <merijn> No one
02:37:33 <merijn> oh, stackage
02:37:37 <merijn> I need to learn to read
02:39:05 <bollu> Finder doesn't show hidden packages without a terminal switch flip. And stack saves the .tar.gz in a hidden folder. Do I report this as a "bug" ?
02:39:12 <bollu> like, usability bug
02:40:23 <merijn> bollu: You can enter hidden packages in Finder using Cmd+Shift+G
02:40:23 <kaiyin> https://gist.github.com/kindlychung/11318f21855d365f9b7e What does this error mean here?
02:40:31 <merijn> bollu: Eh, hidden folders
02:40:37 <bollu> merijn: oh, thanks!
02:41:21 <verement> bollu: another useful terminal command is 'open'
02:41:42 <merijn> verement: The problem was that he wasn't using the Terminal, I think :)
02:42:01 <bollu> verement: yeah, but that doesn't help - the hackage "upload file" option opens up its own file picker
02:42:02 <merijn> kaiyin: Since 7.10 Applicative is a superclass of Monad, so you must define an instance of Applicative to make something a Monad
02:42:23 <kaiyin> ok
02:42:44 <verement> bollu: I meant 'open $hidden_folder'
02:42:56 <merijn> kaiyin: So it's saying "on line 37 where you define the Monad instance I can't find an Applicative instance for this type!"
02:43:04 <verement> that should open the folder in the Finder
02:43:22 <merijn> verement: Which doesn't help in his browser's file selector ;)
02:43:28 <bollu> verement: yeah, that would pop up a finder instance :) But the problem is that I'm using the "upload file" on hackage that opens up *another* Finder instance for me to select the package
02:43:57 <verement> bollu: so then drag the file from the Finder window to the file selection panel
02:44:00 <kaiyin> merijn: ok. and for something to be an Applicative, it has to be a Functor, which means i also have to define the Functor instance?
02:44:09 <bollu> verement: would that work?
02:44:12 <verement> yes
02:44:22 <bollu> also, how does haskell version numbering work? it's not SemVer
02:44:24 <merijn> kaiyin: Yes, although you can define your Functor instance using the monad implementation :)
02:44:27 <bollu> verement: TIL :) thanks for the tip
02:45:09 <kaiyin> merijn: wait a minute,  isn't that circular dependency?
02:45:38 <Fuco> haskell doesn't care much, so long as you implement *some* part of it it will be resolved
02:45:38 <bollu> kaiyin: nope
02:45:48 <merijn> kaiyin: No, because while Monad requires it is an instance of Functor the implementation of Monad doesn't care about the implementation of functor
02:46:12 <kaiyin> merijn: ah, ok.
02:46:21 <merijn> kaiyin: write "fmap f x = x >>= return . f" is a perfectly legal way to implement Functor, as long as your monad doesn't use fmap to implement >>= or return :p
02:46:33 <merijn> Because then your implementation infinite loops :p
02:46:41 <Fuco> aren't those, in fact, the default implementations?
02:46:51 <merijn> Fuco: I don't think so
02:47:11 <merijn> fmap doesn't have a default implementation
02:47:18 <Fuco> or was it for applicative where it just did <*> = ap
02:47:23 <bollu> merijn: but you can have mutually recursive definitions right? So that if you implement one of them the other gets implemented
02:47:31 <Fuco> bollu: yep
02:47:32 <bollu> merijn: IIRC Traversable does that?
02:47:39 <merijn> bollu: Yes
02:47:42 <bollu> I found that *so* elegant when I first saw it
02:47:58 <Fuco> you can implement monad using join or bind and the other you get "for free"
02:48:20 <bollu> :t liftA2 (&&)
02:48:21 <lambdabot> Applicative f => f Bool -> f Bool -> f Bool
02:48:32 <bollu> :t liftAt (&&) not
02:48:33 <lambdabot>     Not in scope: ‘liftAt’
02:48:33 <lambdabot>     Perhaps you meant one of these:
02:48:33 <lambdabot>       ‘liftA’ (imported from Control.Applicative),
02:48:34 <merijn> Why is naming things so hard? :(
02:48:44 <bollu> :t liftA2 (&&) not
02:48:45 <lambdabot> (Bool -> Bool) -> Bool -> Bool
02:48:54 <Fuco> not that hard, use greek alphabet, starting from alpha
02:49:00 <bollu> I can see the way the types fit, but I don't believe it
02:49:00 <Fuco> worked quite well for phisicists...
02:49:02 <quicksilver> merijn: http://www.poetrybyheart.org.uk/poems/naming-of-parts/ :)
02:49:25 <bollu> like, how the hell does liftA2 work so well in this case? (as in, what is the Applicative structure of (->) actually *doing*)?
02:49:37 <merijn> bollu: It's Reader :)
02:49:38 <quicksilver> passing the same argument to two things
02:49:46 <quicksilver> and then applying the operator to the result
02:49:50 <bollu> merijn: expand on the Reader bit?
02:49:50 <merijn> bollu: "(->) r" is equivalent to "Reader r"
02:50:00 <bollu> quicksilver: yeah, I've always seen it as equivalent to the S combinator
02:50:01 <kaiyin> do you always check the laws when you write a applicative or monad definition?
02:50:12 <merijn> :t (<*>)
02:50:13 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
02:50:34 <merijn> "(a -> b) -> (r -> a) -> r -> b"
02:50:54 <merijn> oh, wait, my bad
02:50:58 <bollu> meretrix: ehh no?
02:51:00 <merijn> "(r -> a -> b) -> (r -> a) -> r -> b"
02:51:01 <Fuco> r -> a -> b
02:51:03 <bollu> meryes
02:51:05 <bollu> yes*
02:51:12 <frerich> kaiyin: I bet there's a "I don't always..." meme somewhere in there.
02:51:29 <merijn> kaiyin: Depends on how obvious it is :)
02:51:55 <frerich> kaiyin: Go think of something funny to add to https://imgflip.com/i/wui76 !
02:52:02 <Fuco> anarchist haskellers have hard time :/
02:52:27 <kaiyin> :D
02:53:06 <bollu> is 0.0.0.1 an acceptable "alpha" package number/
02:53:07 <bollu> ?
02:53:16 <merijn> quicksilver: I had a "concurrentMap" function and a "addElementToState", but then I realised I only ever used those two together, so I figured I'd write a singly "[a] -> (a -> IO b) -> StateT MyState IO ()" style thing, but no clue wtf to name it?
02:54:06 <bollu> how do I add a link to an "official page" in the cabal file?
02:54:09 <puregreen> bollu: I think yep
02:54:15 <bollu> puregreen: cool, thanks
02:54:31 <bollu> puregreen: uploading a package to Hackage is daunting. I think I'll list all the steps so that someone doesn't have to go through the same pain
02:54:36 <frerich> merijn: I think 'addElementToState' sounds like something which maybe should be called just 'add :: Element -> State -> State' or so, i.e. the readability emerges from the context.
02:54:42 <puregreen> to add a link, fill the “homepage” field
02:55:18 <frerich> merijn: ...and if you can indeed shorten the name, then maybe using 'concurrentMap' and 'add' together is actually not so bad and clearer than a single word.
02:55:19 <bollu> puregreen: ty
02:55:52 <puregreen> you should also fill the bug-reports field if your package is on Github or something
02:56:18 <bollu> where do "description" and "synopsis" fir in?
02:56:39 <bollu> fit * in
02:56:59 <puregreen> “description” will show on your package's page
02:57:04 <bollu> puregreen: yeah it is on github
02:57:20 <puregreen> “synopsis” is a one-line description that pops up here and there
02:57:28 <puregreen> e.g. list of all packages on Hackage, etc
02:57:42 <puregreen> just in case: are you using cabal init?
02:58:03 <Fuco> so customer files a bug to "check why this data entry is incorrectly handled", then deletes the entry... thanks that makes the debugging so much easier :/
02:58:17 <bollu> oh cool, ty
02:58:24 <bollu> puregreen: I'm using stack
02:59:50 <puregreen> hm
03:00:05 <puregreen> does stack have a package creation wizard like cabal-install's?
03:00:11 <puregreen> or what is the recommended workflow
03:00:14 <cocreature> not quite
03:00:17 <cocreature> there is stack new
03:00:24 <cocreature> but that isn’t an interactive wizard
03:00:30 <cocreature> instead it uses the template you supply
03:00:35 <bollu> puregreen: I'm not sure. you `stack new` and it creates a default folder with a lot of the cabal file filled in
03:00:45 <bollu> puregreen: right now I'm just editing the fields of the cabal file
03:00:51 <bollu> puregreen: it's exciting :P 
03:01:08 <puregreen> okay, I see
03:02:18 * puregreen has just written a script to create a repository on Github, .cabal file, set up Travis correctly, add badges to README, etc
03:02:38 <bollu> puregreen: ooh, show?
03:02:57 <puregreen> it doesn't support stack yet so it won't be of much use for you, I guess
03:03:02 <puregreen> https://github.com/aelve/new-hs
03:03:31 <bollu> puregreen: I could adapt it :)
03:03:51 <puregreen> you'd have to rewrite pretty much everything
03:04:03 <bollu> puregreen: I'd maybe rewrite it using Turtle as well.
03:04:07 <puregreen> e.g. Travis scripts for cabal and stack are rather different
03:04:14 <bollu> puregreen: oh, hm
03:04:19 <bollu> puregreen: still, would be a fun project!
03:04:27 <puregreen> I don't use Turtle because I want it to have no dependencies apart from ones shipped with GHC
03:07:16 <bollu> puregreen: that's fair :)
03:07:46 <bollu> wait what, stack doesn't live on hackage?
03:07:53 <bollu> is it wrong to upload executables onto hackage?
03:07:58 <bollu> but.. ghc-mod is present right?
03:08:19 <puregreen> it's okay to upload executables on Hackage
03:08:34 <puregreen> pandoc and cabal-install live there, for instance
03:09:00 <puregreen> actually, stack does too
03:09:01 <puregreen> http://hackage.haskell.org/package/stack
03:09:08 <bollu> is the name warp already taken?
03:09:15 <puregreen> yep
03:09:32 <bollu> crao
03:09:33 <bollu> crap*
03:09:35 <bollu> hm
03:10:00 <puregreen> “twist” and “distort” are free
03:10:06 <bollu> is "teleport" too long a name for command line tools?
03:10:14 <bollu> puregreen: it's something to move around your filesystem quickly
03:10:33 <puregreen> the package and the binary can have different names
03:10:36 <bollu> "tp" may not be so bad..?
03:10:47 <bollu> puregreen: yeah, which was what I was thinking
03:11:36 <puregreen> “tp” isn't so bad, I just checked and no binary in Arch Linux repos is named “tp”
03:11:41 <bollu> puregreen: is there a list of all the fields that I can have in a cabal file?
03:11:50 <bollu> puregreen: cool :D
03:12:21 <puregreen> https://www.haskell.org/cabal/users-guide/developing-packages.html#package-properties
03:12:28 <bollu> oh, ty
03:12:40 * hackagebot WaveFront 0.1.2.0 - Parsers and utilities for the OBJ WaveFront 3D model format  https://hackage.haskell.org/package/WaveFront-0.1.2.0 (SwiftsNamesake)
03:34:02 <bollu> does hackage accept some UI related PR's?
03:34:08 <bollu> or is there a RFC procedure?
03:34:20 <bollu> oh crap, I uploaded the package
03:34:27 <bollu> welp
03:35:10 <bollu> hm, that's weird - how do other packages have the whole description thing at the bottom of their hackage link?
03:35:40 <puregreen> because they have README.md included in the package
03:35:41 <bollu> https://hackage.haskell.org/package/stack
03:35:50 <bollu> but I have a readme too.
03:36:04 <bollu> what exactly does "stack sbin" do?
03:36:52 <puregreen> https://github.com/haskell/hackage-server/pull/392 – as you can see, Hackage does accept UI-related PRs
03:37:41 * hackagebot teleport 0.0.0.9 - A tool to quickly switch between directories  https://hackage.haskell.org/package/teleport-0.0.0.9 (bollu)
03:37:43 * hackagebot hero-club-five-tenets 0.3.0.0 - Remember the five tenets of hero club  https://hackage.haskell.org/package/hero-club-five-tenets-0.3.0.0 (i_amd3)
03:37:51 <bollu> puregreen: coool, thanks
03:37:57 <fjordrunner> please,..I have one scotty related question: does it support any queue logic?
03:38:09 <bollu> and yayy, hackagebot registered my package 
03:38:12 <bollu> omg it feels so weird
03:38:16 <bollu> that I have a package on hackage
03:38:26 <bollu> can't believe I didn't even know what a Functor was ~ a year back
03:38:42 <puregreen> bollu: your readme isn't included in the package
03:38:55 <M2tias> bollu: congrats
03:39:04 <bollu> puregreen: yep, I noticed. I think `stack sbin` only pulls in certain files. I'll have to see
03:39:06 <bollu> M2tias: thanks :D
03:39:26 <puregreen> to include it, you need to add it to the extra-source-files field
03:39:35 <fjordrunner> for example if I have sqlite as DB (supports only 1 insert at time) and I send to scotty 2 concurrent inserts. What will happen?  
03:39:49 <puregreen> (and while you're at it, add CHANGELOG.md as well)
03:40:19 <puregreen> (and probably stack.yaml, at least that's what stack's .cabal file lists)
03:40:34 <puregreen> (see http://hackage.haskell.org/package/stack-1.0.0/stack.cabal)
03:42:19 <merijn> fjordrunner: sqlite uses locking, so that should be fine
03:42:47 <merijn> fjordrunner: Basically sqlite sequences your concurrent accesses to the database to be sequential
03:42:55 <M-davidar> is there a reason the non-exhaustive pattern match warning isn't enabled by default?
03:43:20 <quicksilver> yes
03:43:21 <fjordrunner> merijn: thank you very much, so basically after a while I should see both inserts in the DB
03:43:31 <quicksilver> it is very common for correct programs to have inexhaustive pattern matches.
03:43:57 <fjordrunner> merijn: and the sequencing is done in sqlite,..right? Scotty has nothing to do with that..
03:44:12 <M-davidar> (apparently rust does so)
03:45:27 <merijn> fjordrunner: Yes
03:45:37 <merijn> M-davidar: I would say a lot of sane warnings are off by default
03:45:52 <merijn> M-davidar: I would recommend always compiling using -Wall and only selectively disabling warnings
03:46:04 <fjordrunner> merijn: many thanks! ;)
03:46:10 <bollu> puregreen: thanks for the hell
03:46:32 <bollu> puregreen: help*
03:47:17 <statusfailed> Is "bisimulation" used to prove turing-completeness of computational models ?
03:47:35 <merijn> statusfailed: It can be
03:47:41 * hackagebot uulib 0.9.22 - Haskell Utrecht Tools Library  https://hackage.haskell.org/package/uulib-0.9.22 (AtzeDijkstra)
03:48:24 <Ongy> Hi, is there a good way to check whether a pid is still alive? I am on linux, the C code uses: '(pid == -1 || kill (pid, 0) != 0)'
03:48:54 <statusfailed> merijn: thanks!
03:50:25 <statusfailed> Followup: Let's say I've implemented "big integer" arithmetic on a simple CPU- how would I prove it's equivalent to peano-style arithmetic ?
03:50:32 <bollu> does anyone have a shell script or something to upload to hackage?
03:50:58 <Fuco> statusfailed: you can check the axioms
03:51:09 <merijn> statusfailed: Depends on your implementation, but if you wanna learn more about proofs I would recommend the Software Foundations book
03:51:12 <merijn> @sf
03:51:12 <lambdabot>  Done.
03:51:13 <merijn> eh
03:51:16 <merijn> @where sf
03:51:16 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
03:51:17 <lambdabot> assistant."
03:51:33 <puregreen> bollu: “stack upload”
03:51:39 <puregreen> (or I misunderstood you)
03:51:40 <bollu> puregreen: ooh, thanks!
03:51:47 <ggole__> @help sf
03:51:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:51:55 <ggole__> Hmph.
03:52:02 <ggole__> @help @sf
03:52:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:52:13 <puregreen> ggole__: “sf” isn't a command
03:52:24 <puregreen> it's one of many shortcuts
03:52:27 <puregreen> @where lyah
03:52:27 <lambdabot> http://www.learnyouahaskell.com/
03:52:30 <puregreen> @where lens
03:52:30 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
03:52:33 <ggole__> Seems like an odd response
03:52:33 <bollu> puregreen: can my changelog fie be markdown as well? (what's the convention)
03:52:38 <bollu> @where free
03:52:39 <lambdabot> http://andrew.bromage.org/darcs/freetheorems
03:52:43 <bollu> ooh
03:52:54 <puregreen> bollu: there's no convention, I think, but if you use Markdown it'll be rendered nicely by Hackage
03:52:59 <bollu> cool
03:52:59 <puregreen> so I recommend using Markdown
03:53:14 <puregreen> (does Hackage render any other markup languages, by the way?)
03:53:17 <quicksilver> Ongy: call signalProcess nullSignal and catch the exception?
03:53:23 <statusfailed> merijn: ooh, thanks! :-)
03:53:44 <statusfailed> merijn: I'm working through TAPL at the moment, does it cover similar material?
03:53:51 <statusfailed> oh same author
03:53:55 <statusfailed> probably not then
03:54:02 <Fuco> probably yes then
03:54:10 <merijn> statusfailed: Not really, but TaPL covers a lot of proofs too
03:54:16 <Fuco> academia is all about reuse!
03:54:18 <statusfailed> haha
03:54:21 <merijn> statusfailed: SF is more about proving properties about programs
03:54:37 <statusfailed> Right
03:54:48 <statusfailed> OK that sounds perfect! thanks!
03:54:49 <bollu> oh what, I need to bump up the version number for even the smallest change?
03:54:53 <bollu> makes sense I guess, but still
03:55:04 <merijn> The techniques taught in SF can be used to, say, formalise the correctness proofs of your type checkers/system
03:55:32 <statusfailed> formalise? Are proofs in TAPL not formalised? 
03:55:36 <statusfailed> or you mean "in a proof checker"?
03:55:49 <bollu> stack is AWESOME. Many, *many* thanks to the people who decided to write it
03:55:51 <merijn> statusfailed: In Coq :)
03:56:05 <statusfailed> ok this gets put right on top of the reading list :D
03:56:13 <statusfailed> that's exactly what i'm looking for, thanks!
03:56:34 <Fuco> somewhat tangential, but coq has to be the worst name for a programming language ever...
03:56:51 <bollu> merijn: link to book?
03:56:58 <bollu> also, I want to learn Agda but don't know where to start
03:57:08 <merijn> I'm pretty sure 80% of the reason they selected Coq was to annoy English speakers
03:57:17 <merijn> @where sf -- bollu
03:57:17 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
03:57:17 <lambdabot> assistant."
03:57:41 * hackagebot teleport 0.0.0.10 - A tool to quickly switch between directories  https://hackage.haskell.org/package/teleport-0.0.0.10 (bollu)
03:58:07 <bollu> yes, readme renders :D
03:58:12 <bollu> now I gotta figure out travis
04:00:54 <bollu> oh, why AppVeyour and not travis?
04:04:29 <bollu> what CI tools do most haskell projects use?
04:04:35 <puregreen> Appveyor is for Windows
04:04:38 <puregreen> most projects use Travis
04:04:52 <bollu> cool, thanks
04:04:58 <bollu> anything like CodeClimate for haskell?
04:06:10 <statusfailed> I think "circle CI" has some haskell-specific support like caching sandboxes btw
04:06:58 <statusfailed> and the setup looks easier (haven't used it though)
04:07:02 <bollu> I'll check it out
04:14:46 <merijn> Are there any statistics functions for list somewhere computing stuff like stddev?
04:17:39 <merijn> Is there a strict foldMap somewhere?
04:18:58 <cocreature> merijn: iirc statisics has stdDev for vector, so if you are ok with a fromList this should do the trick
04:19:51 <merijn> cocreature: I figured I'd just roll my own using foldMap, but I just realised there's no strict foldMap and, apparently, no Min/Max newtypes
04:20:24 <cocreature> iirc Min & Max are in semigroups
04:20:26 <merijn> (with corresponding Monoid instance
04:21:28 <merijn> I guess that doesn't work for me anyway, since the monoid instance would be wrong for my needs...
04:22:17 <cocreature> how so? do you need a different mempty?
04:22:38 <merijn> I need something like 0 as minimum instead of negative value
04:24:05 <exio4> Min Word :p
04:24:17 <cocreature> you could probably use a Max Word for that
04:24:21 <merijn> exio4: Doesn't work for floating point
04:24:37 <exio4> oh, damn
04:26:08 <cocreature> yeah you probably have to roll your own newtype in that case
04:30:54 <exio4> is there any standard-ish way to deal with the inner guts of Data.Vector(s)? I basically want to break the abstraction and there's no .Internal module :p 
04:34:57 <cocreature> exio4: isn’t that what Data.Vector.Primitive is for? or what kind of abstractions do you want to break
04:36:54 <M-davidar> merijn: are there any plans to change this? someone has just been complaining to me about the lack of sane defaults
04:37:34 <exio4> cocreature: Data.Vector.Primitive are specialized unboxed vectors
04:38:02 <merijn> M-davidar: I think -Wall is a sane default, but people are probably not gonna make that "default" because a lot of code compiling with -Werror would stop working
04:38:17 <merijn> Now of course distributing code with -Werror is not a good idea, but...
04:39:03 <exio4> cocreature: I am just trying to reduce allocations to the min, I found 65% of the allocations come from I# (it's 65%, and those happen to be garbage collected quite fast)
04:39:19 <exio4> er, s/it's 65%/it's used right away/
04:39:28 <merijn> hmm, there's no "minOn"?
04:40:26 <bollu> this is a stupid question
04:40:39 <bollu> but how do I check if my tool installs correctly with a "cabal install .."
04:40:45 <bollu> short of spinning up a VM
04:44:24 <puregreen> what do you mean by “installs correctly”? and why would you need a VM at all?
04:44:54 <bollu> puregreen: does using "cabal install" put the executable in the "right location" / "expected location"
04:45:21 <puregreen> by default it puts the executable into .cabal/bin, unless you're in a sandbox
04:45:39 <puregreen> so, you can do cabal install and then check whether the executable is where it should be
04:45:53 <bollu> cool, ty
04:48:07 <bollu> https://travis-ci.org
04:48:16 <bollu> https://travis-ci.org/bollu/teleport*
04:48:26 <bollu> it's been in "progress" for 10 solid minutes
04:55:28 <demize> Mmm, building aeson & co.
04:55:33 <Fuco> that's a lot of dependencies you have there
04:55:39 <bollu> Fuco: me?
04:55:46 <bollu> Fuco: yeah, I was playing around with some librarie
04:55:49 <bollu> libraries*
04:55:57 <bollu> I settled on using aeson for JSON parsing
04:56:07 <bollu> demize: is aeson known to be large
04:56:51 <puregreen> if caching is set up correctly, later builds should be much faster
04:57:08 <Fuco> you can have that on travis? :O
04:57:24 <Fuco> I solved this problem by bundling stuff in my repo in the past...
04:57:57 <puregreen> hvr's Travis script is pretty clever about this
04:58:17 <puregreen> it explicitly checks whether the build plan is the same as the one stored in the cache
04:58:44 <puregreen> one tool of mine uses GTK and aeson and Travis builds it in 3m
04:58:55 <puregreen> something like this should exist for stack, too
04:59:43 <Fuco> I thought it gives you a new VM every time
05:00:03 <puregreen> it does, but you still can create/retrieve caches
05:00:13 <Fuco> aha, I see
05:00:18 <puregreen> https://docs.travis-ci.com/user/caching/
05:05:15 <hvr> puregreen: fwiw, next-gen cabal is going to make this even easier
05:05:59 <puregreen> tell, tell
05:06:09 * puregreen loves hearing about cool upcoming features
05:06:10 <hvr> puregreen: the nix-local-store takes care of that
05:06:26 <hvr> puregreen: then you just need to cache the store folder
05:06:43 <hvr> w/o any fear of caching some non-released package artifact
05:07:08 * hvr is experimenting with that already
05:07:49 <hvr> and it also makes it easier to handle unreleased build-dependencies 
05:07:59 <hvr> it's quite nieat
05:08:28 <hseg> Question: Who's in charge of HWN nowadays? Was looking through the logs for lulz, and found an excellent nugget I'd like to submit.
05:11:02 <puregreen> Kim-Ee Yeoh
05:12:21 <hseg> Is he on IRC?
05:12:53 <ahihi> I'm trying to build some basic yesod/sqlite code, but getting this link error: http://sprunge.us/KSFc — any ideas on how to debug the situation?
05:13:59 <_Abhi1> how can i contact any mentor for gsoc 2016 ?
05:30:38 <Nadrieril> hvr: cabal is gonna integrate a bit of nix ?
05:34:00 <hvr> Nadrieril: ja, just as little as needed to fix the 'reinstall'-hell problem
05:34:21 <Nadrieril> ooh nice :)
06:01:56 <akegalj> ahihi: Hm, I never saw that one. You can try asking the same question in #yesod channel
06:13:00 <ahihi> akegalj: thanks, I'll do that
06:23:08 <cdupont> Hi guys
06:23:28 <cdupont> Q: What IDE are you using?
06:23:34 <MasseR> vim
06:24:03 <cdupont> MasserR: I'm also a vimer... How did you configure it?
06:24:56 <MasseR> cdupont:not too much actually. Mostly indenting
06:24:59 <mauke> cdupont: linux
06:25:06 <cdupont> MasserR: especially how do you navigate files/errors in vim?
06:25:40 <MasseR> cdupont: CtrlP for finding files
06:25:50 <MasseR> For errors, I find the file and G123
06:25:57 <MasseR> ... no wait, was it 123G
06:26:02 <cdupont> I'm pondering if I should learn emacs, it looks more integrated for Haskell
06:26:07 <frerich> cdupont: I use vim; Ctrl+P for navigating files (or a custom shortcut which does 'git grep' for the word under the cursor) and hdevtools for linting Haskell code specifically and finding issues. I also use something (also hdevtools? not sure) which let's me press <leader>t to get the type of the expression under the cursor.
06:26:23 <MasseR> cdupont: Partially yes, but the indenting rules on it are .. weird
06:27:07 <suppi> cdupont, this might help https://github.com/neovimhaskell
06:27:38 <suppi> and this: https://github.com/eagletmt/ghcmod-vim
06:27:51 <cdupont> is neovim mature enough?
06:28:01 <MasseR> ghc-mod and the like are a bit iffy with fast moving haskell ecosystem
06:28:15 <MasseR> I set up them once in may and in october they're broken 
06:28:33 <suppi> cdupont, perhaps try spacemacs.org ? I moved to using it from vim not too long ago and it's pretty good
06:28:40 <cdupont> MasserR: lol
06:28:50 <suppi> cdupont, I meant this specifically https://github.com/neovimhaskell/haskell-vim
06:30:59 <cdupont> Ctrl-P does nothing in my vim
06:31:11 <merijn> cdupont: It's an extension
06:31:31 <merijn> cdupont: https://github.com/ctrlpvim/ctrlp.vim
06:31:31 <MasseR> cdupont: I'm serious :). Set up ghc-mod. Out comes virthualenv, ghc-mod breaks. Fix ghc-mod to work with virthualenv, cabal sandboxes deprecate virthualenv and ghc-mod breaks. Couldn't figure out how to fix ghc-mod by myself, and no official support for many months. End up using nixos, got ghc-mod working there. My laptop breaks, no more nixos. Set up cabal sandbox, stack makes its appearance
06:31:46 <merijn> MasseR: What do you use virtualenv for?
06:31:58 <frerich> cdupont: You don't know what you're missing out on! :-)
06:32:26 <MasseR> merijn: I don't. Anymore
06:32:41 <MasseR> When I did, for sandboxing
06:33:04 <cdupont> MasserR: I can feel the pain, thinks breaking often are quite endemic in Haskell :(
06:33:05 <merijn> I've heard that before, but I'm never quite sure how virtualenv's "sandboxing" is helpful/useful for haskell
06:33:28 <MasseR> merijn: it was specifically for haskell
06:33:43 <MasseR> "Virtual haskell environment builder"
06:35:01 <Ab123> hello can any1 tell me difference between $ ghci -fprint-explicit-foralls and $ghci
06:35:03 <Ab123> ?
06:36:22 <c_wraith> Ab123: Well, the first one activates printing explicit foralls
06:36:29 <c_wraith> :t id
06:36:31 <lambdabot> a -> a
06:36:47 <c_wraith> lambdabot used to have that option enabled, but appears not to now.
06:37:24 <Ankhers> id :: forall a. a -> a
06:37:35 <Ankhers> Is what would be printed using -fprint-explicit-foralls
06:38:00 <cdupont> Ctrl-P looks great
06:38:04 <cdupont> just installed :)
06:38:05 * hackagebot EntrezHTTP 1.0.1 - Libary to interface with the NCBI Entrez REST service.  https://hackage.haskell.org/package/EntrezHTTP-1.0.1 (FlorianEggenhofer)
06:38:28 <cdupont> that was the missing piece ahah
06:39:11 <MasseR> cdupont: the best part? It's not haskell specific :)
06:39:46 <cdupont> eheh
06:40:15 <troydm> how can I force certain function that takes ByteString be always evaluated whenever called and not left as just a thunk?
06:40:52 <troydm> a function for example that has a signature ByteString -> Maybe Int
06:40:59 <troydm> and called f
06:41:11 <cdupont> MasserR: for finding line number isn't it ":123" ?
06:41:28 <MasseR> cdupont: 123G is easier for fingers
06:41:37 <Ankhers> vim?
06:41:53 <MasseR> Yeah
06:41:54 <cdupont> Ankhers: yes
06:42:05 <MasseR> cdupont: and one less keypress, no need to press return
06:42:13 <Ankhers> I didn't know about 123G... Learn something new everyday.
06:42:46 <cdupont> other Q: do you launch compilation without leaving vim?
06:43:08 <MasseR> cdupont: I usually have tmux running, vim on 'master pane' and ghci on the right hand side
06:43:20 <MasseR> :r there
06:43:20 <cdupont> what is tmux?
06:43:27 <MasseR> like screen, but better
06:43:28 <merijn> cdupont: Do you know screen?
06:43:35 <cdupont> yup
06:43:50 <merijn> cdupont: What MasseR said, screen, but better/more flexible
06:44:01 <mag__> cdupont, nvim has a terminal emulator build in
06:44:19 <cdupont> neovim?
06:44:23 <mag__> yep
06:44:29 <MasseR> mag__: and if it's even near as bad as emacs, completely useless :)
06:44:40 <mag__> works like flawlessly 
06:44:44 <cdupont> so you swap virtual terminal between code and error list?
06:44:47 <Ankhers> emacs at least has a compile command.
06:44:52 <mag__> MasseR,  indeed :(
06:44:58 <Ankhers> and you can configure it to do whatever you want.
06:45:00 <MasseR> Ankhers: so does vim
06:45:10 <MasseR> Ankhers: :help makeprg
06:45:12 <Ankhers> MasseR: a generic compile command?
06:45:19 <Ankhers> ugg... I haven't used vim in forever.
06:45:33 <cdupont> didn't wanted to launch emacs/vim war :(
06:45:49 <mag__> hahaha
06:45:52 <MasseR> cdupont: :D
06:45:54 <MasseR> Too late
06:45:59 <Ankhers> cdupont: I haven't seen a "war" break out within #haskell before.
06:46:19 <cdupont> just joking
06:46:34 <cdupont> and poor English ;)
06:46:46 <mag__> vivivi vs EmacOS
06:46:48 <mag__> cool
06:47:04 <MasseR> Ankhers: actually, makeprg can interact with quickfix list, so that you can jump to errors
06:47:13 <MasseR> I'm sure someone has made a haskell error parser for that
06:47:25 <cdupont> that woul be cool
06:47:42 <MasseR> And you can integrate that with 'signs', which shows white or red ">>" symbols left of your problematic line
06:47:48 <MasseR> I think ghc-mod utilizes that
06:48:34 <cdupont> I use stack to compile, not sure is I can use ghc-mod too
06:49:03 <MasseR> cdupont: google stack ghc-mod
06:49:07 <MasseR> You probably can
06:49:09 <MasseR> By now
06:49:10 <merijn> MasseR: Syntastic has support for ghc-mod/hdevtools
06:49:16 <MasseR> merijn: ah thanks
06:49:28 <merijn> And basically every other language ever
06:49:32 <ggVGc> How would I do this in Haskell? https://gist.github.com/01a370b2b8ab75028f6f
06:50:06 <MasseR> merijn: Actually I do have syntastic installed, quite useless for me atm. ghc-mod doesn't work reliably for me, and day to day coding has its own extension
06:50:52 <ggVGc> That is in Elm, but the question is theoretical. How do I replace items in a List based on a predicate, with new items which are generated on the fly from a seed
06:50:59 <ggVGc> and keep the new seeds for the next replacement
06:51:54 <mnoonan> ggVGc: looks like sequence to me, over the state monad
06:52:47 <lyxia> or mapAccumL
06:53:49 <ggVGc> hm, yeah mapAccumL seems like what I want
06:53:56 <ggVGc> cool
06:54:04 <ggVGc> I was going to write something like it myself
06:54:08 <Abrahm> anyone can mentor me for gsoc16
06:54:43 <ggVGc> thanks lyxia, mnoonan 
06:55:11 <ggVGc> oh... mapAccumL is implemented with the state monad
06:55:34 <quicksilver> mapAccumL is just an 'unrolled' sequence in the state monad yes.
06:55:42 <quicksilver> types unrolled
06:56:36 <kaiyin> Why am I getting this error? https://gist.github.com/kindlychung/46109b9ed39062a7ea75
06:56:57 <jophish> edwardk: Would it be possible to release ad-4.3.2 on hackage?
06:58:50 <lyxia> kaiyin: there is no Writer data constructor.
06:59:15 <merijn> jophish: Rookie mistake...before you know it you'll be maintaining it ;)
06:59:27 <kaiyin> lyxia. ok, this code is from learn you a haskell.
06:59:44 <kaiyin> lyxia: what is the correct constructor?
06:59:57 <lyxia> kaiyin: there is a "writer" function
07:00:07 <lyxia> which seems to fit
07:01:01 <merijn> kaiyin: Oh, this is because Writer changed after LYAH was written
07:01:19 <jophish> merijn: uh oh, I've submitted pull requests too, my fate is sealed!
07:01:35 <merijn> kaiyin: Previously there was a Writer constructor and separate Writer monad and WriterT monad transformer. After LYAH they were generalised to function the same
07:01:54 <kaiyin> merijn: ok, thanks.
07:01:55 <merijn> kaiyin: The Writer constructor no longer exists, but the "writer" function does the same thing
07:02:42 <kaiyin> merijn: how can i correct this line? https://gist.github.com/kindlychung/46109b9ed39062a7ea75#file-lognumber-hs-L44
07:03:36 <merijn> kaiyin: Lowercase the 'W' on line 30
07:04:09 <kaiyin> merijn: yeah, that's done.
07:04:31 <merijn> kaiyin: That should be all :)
07:05:55 <kaiyin> merijn: https://gist.github.com/kindlychung/46109b9ed39062a7ea75#file-err1
07:07:28 <merijn> kaiyin: Change line 7 to "import Control.Monad.Trans.Writer"
07:07:59 <mauke> whoa
07:09:46 <merijn> mauke: What?
07:10:06 <kaiyin> merijn: now it's complaining about not finding Sum.
07:10:23 <merijn> kaiyin: Did you define/import it?
07:10:25 <kaiyin> Control.Monad.Trans.Writer is from a different package? 
07:11:12 <merijn> kaiyin: Yes, Control.Monad.Writer is from the "monad transformer library" which provides a bunch of convenience typeclasses for dealing with the transformers from transformers. But they add a lot of confusing noise for beginners, imo
07:11:22 <mauke> ah
07:11:51 <kaiyin> ok, now it's working.
07:12:12 <kaiyin> need to install the transformers library 
07:15:45 <saml> > fmap (++ "foo") ""  -- how can I do this?  given f :: String -> String   and x :: String,  I want to apply f x iff x is not empty. Otherwise, x is returned
07:15:46 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
07:15:47 <lambdabot>      Expected type: [[Char]]
07:15:47 <lambdabot>        Actual type: [Char]
07:18:57 <Ankhers> f g s = if (null s) then s else g s -- saml 
07:19:00 <frerich> saml: Like, '\f xs -> if null xs then xs else f xs'?
07:19:12 <saml> yah .. so it's not monoid or monad right?
07:19:22 <saml> mempty :: String is ""
07:19:49 <saml> 0 * anyNumber  = 0.     I want this for String
07:20:09 <saml> "" +*+ anyString = ""
07:21:15 <Ankhers> saml: You could create your own monoid instance for String that behaves that way.
07:21:30 <wolfcub> how does m >>= f == join (fmap f m)
07:21:35 <wolfcub> the types dont seem to match
07:22:20 <merijn> wolfcub: No? Try writing them out :)
07:22:57 <wolfcub> f a -> m b
07:23:06 <wolfcub> f :: a -> m b
07:23:13 <wolfcub> so how can i apply it to m a
07:23:21 <merijn> :t fmap
07:23:23 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:23:49 <merijn> :t fmap (undefined :: a -> m b)
07:23:50 <lambdabot> forall (k :: BOX) (f :: * -> *) a (m :: k -> *) (b :: k). Functor f => f a -> f (m b)
07:23:54 <merijn> hmmm
07:24:02 <merijn> That was scarier then intended :p
07:24:07 <wolfcub> lol
07:24:09 <merijn> :t fmap `asAppliedTo` (undefined :: a -> m b)
07:24:11 <lambdabot> forall (k :: BOX) (f :: * -> *) a (m :: k -> *) (b :: k). Functor f => (a -> m b) -> f a -> f (m b)
07:24:22 <merijn> Ignore everything before ".Functor" :)
07:24:24 <saml> is default Monoid String instance wrong then?
07:24:33 <saml> mappend "" "a"  == "a",  not  ""
07:24:36 <frerich> saml: If you have multiple operations which you want to perform only if the list is non-empty, then it might be worthwhile to first convert the list to a 'Maybe [a]' and then work with the functor instance for Maybe
07:24:38 <Ankhers> saml: No.
07:24:43 <merijn> saml: Which is right
07:24:49 <merijn> "mappend mempty x == x"
07:24:55 <saml> ah right
07:24:57 <merijn> That's one of the laws of Monoid
07:25:09 <saml> so what i'm trying to implement isn't monoid
07:25:17 <merijn> saml: It might be
07:25:27 <merijn> saml: There's like a bazillion possible monoids :p
07:25:42 <Ankhers> merijn: a bazillion?
07:25:47 <saml> ok now i'm hungry for monoid
07:26:02 <saml> is cardniality of all monoids countably many infinite?
07:27:01 <merijn> wolfcub: Anyway, in this context "x :: m a", "f :: a -> m b" and "fmap :: (x -> y) -> m x -> m y"
07:27:21 <merijn> wolfcub: Then "fmap f" gives "x = a" and "y = m b"
07:27:31 <Fuco> saml: that depends on the underlying sets
07:27:38 <merijn> in other words "fmap :: (a -> m b) -> m a -> m (m b)"
07:27:49 <merijn> wolfcub: And since "join :: m (m a) -> m a"
07:28:23 <Fuco> saml: if you think all monoids, then no, because you can do a trivial operation on any set and there is more sets than countable
07:29:12 <saml> so monoid is continuous and you can take derivative of monoids
07:29:28 <Fuco> I don't see how you conclude that
07:29:29 <saml> dm/dx = monad
07:29:33 <wolfcub> i see o:
07:29:36 <Cale> wat
07:29:40 <wolfcub> thanks merijn
07:30:19 <Cale> saml: The class of all monoids is a proper class (i.e. too large to be a set)
07:30:29 <Cale> As such it doesn't have a cardinality
07:30:42 <Cale> There are monoids of every cardinality
07:33:10 <Fuco> isn't it funny that something is "so big" it's not even a set
07:33:13 <orion> Hi all. It's possible that I might go down a ML/AI path in Haskell. I've been told that the algorithms I implement will not be production-ready in terms of speed/optimization. Are there any production-ready, performant AI/ML libraries in Haskell? I looked at HLearn but I'm not sure how mature it is.
07:33:20 <saml> hrm i don't think i can comprehend these things
07:33:25 <Fuco> that language is hilarious to me :D
07:34:30 <Fuco> monoid is simply too weak structure to limit your options too much
07:34:59 <Fuco> if you take something like finite fields which have much more constrains you can show there is only that much of them...
07:40:59 <Cale> Fuco: Well, it's sort of funny, I suppose, but it makes sense.
07:45:43 <Fuco> ultrafinitism has its perks...
07:52:42 <aweinstock> :t mzero
07:52:44 <lambdabot> MonadPlus m => m a
07:53:19 <aweinstock> > "" `mplus` "hello"
07:53:21 <lambdabot>  "hello"
08:21:15 <argoneus> Cale~
08:21:40 <Cale> argoneus: what's up?
08:21:49 <argoneus> you told me to try asking when I have time 
08:22:08 <argoneus> about the parser thing
08:23:32 <Cale> Oh, sure
08:24:44 <breadmonster> Cale: Hi.
08:25:29 <Cale> argoneus: (just a moment, I'm in the middle of a discussion in ##math)
08:25:37 <argoneus> sure of course
08:28:10 <mikek> @run [i | i<-[0,2], not ([True,False,True] !! i)]
08:28:12 <lambdabot>  []
08:31:19 <Rembane> Good morning, I lost a link to a blog post on how to replace IO with free monads in Haskell, do you have the link?
08:34:30 <geppettodivacin> Rembane: http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
08:34:35 <geppettodivacin> ^That one?
08:34:38 <S11001001> Rembane: http://degoes.net/articles/modern-fp/ lazyweb
08:34:42 <S11001001> That one?
08:35:01 <S11001001> Not a fresh topic :)
08:35:04 <Rembane> geppettodivacin: Nope, not that one, but it is a good article.
08:35:09 <Rembane> S11001001: Yes, that's the one. Thank you.
08:35:34 <Rembane> S11001001: Indeed, but I haven't encountered it before, so it's quite exotic for me. :)
08:39:10 <Cale> argoneus: all right :)
08:40:23 <Cale> argoneus: Perhaps let's go to #haskell-overflow so there won't be any intervening noise when people start to wake up :)
08:44:39 <puregreen> hvr: I've got a GTK app. To install gtk3, I first need to install gtk2hs-buildtools if it isn't installed already, and gtk2hs-buildtools is an executable-only dependency and so isn't tracked by cabal. Where should I add it to .travis.yml so that it would play well with caching?
08:48:09 * hackagebot async 2.1.0 - Run IO operations asynchronously and wait for their results  https://hackage.haskell.org/package/async-2.1.0 (SimonMarlow)
09:04:35 <kaiyin> where does stack put the executable built from a project? 
09:04:46 <cocreature> ~/.local/bin/
09:05:23 <pikajude> hey, anyone know how to make stylish-haskell preserve {-# SOURCE #-}?
09:06:05 <kadoban> kaiyin: If you do 'stack install' they go in ~/.local/bin . Otherwise they're in … `stack path --local-install-root`/bin
09:06:07 <kaiyin> cocreature: I meant the result of `stack build`
09:07:18 <bollu> how do I grok the defintions of functor and monad for the free monad ?
09:07:25 <bollu> "use the types, Luke"?
09:09:35 <cocreature> kaiyin: ah sorry, somewhere in .stack-work. take a look at the stack path output, specifically dist-dir, then from there go to build/projectname iirc
09:09:41 <bollu> if I have a monad instance for a type, can I use it to write the applicative instance?
09:09:53 <puregreen> yep
09:09:58 <puregreen> (<*>) = ap
09:10:05 <ggVGc> I made an attempt at implementing an array mutation with randomness in Elm(without type classes), and came up with this, https://gist.github.com/386808bf7ac4cb56db8d
09:10:05 <puregreen> pure = return
09:10:14 <ggVGc> woudl appreciate some comments
09:10:41 <bollu> cool
09:14:24 <bollu> I don't understand how this works:
09:14:50 <bollu> fmap fn (Free a) = Free $ (fmap . fmap) a
09:15:07 <bollu> like, I understand the first fmap to "enter" inside the f of fhe Free f a
09:15:14 <bollu> but why do I need a (fmap . fmap)
09:15:23 <bollu> as in, what is the "second layer" that i'm acessing?
09:15:31 <quicksilver> are you missing a 'fn' ?
09:15:31 <bollu> wow that's incomprehensible
09:15:41 <bollu> fmap fn (Free a) = Free $ (fmap . fmap) fn a
09:15:46 <bollu> sorry for the typo
09:16:03 <quicksilver> anyhow, one 'fmap' is the fmap of f
09:16:10 <quicksilver> and the other 'fmap' is hte fmap of Free
09:16:18 <quicksilver> (because Free occurs recurisvely inside the f)
09:16:27 <quicksilver> Free (f (Free f a))
09:16:41 <joko> Hello, could anyone make an example for me on Graphics.X11.Xrandr?
09:16:42 <bollu> quicksilver: https://gist.github.com/bollu/f5a8e4c779a1e039d80b#file-free-monads-hs-L9
09:17:02 <bollu> quicksilver: could you explain it in this context? (I renamed the data Free to Branch beacuse it's super confusing to talk about)
09:17:08 <quicksilver> bollu: ok well my answer still applies :)
09:17:25 <quicksilver> one `fmap` for `f`, another `fmap` for the `Free` which is inside the `f`
09:17:37 <quicksilver> because Branch (f (Free f a)) has another free inside.
09:17:41 <mniip> :k Free
09:17:43 <lambdabot>     Not in scope: type constructor or class ‘Free’
09:17:43 <lambdabot>     Perhaps you meant ‘Tree’ (imported from Data.Tree)
09:17:54 <bollu> quicksilver: exactly! how cam we `fmap` inside the `Free` when we are still *defining* the functor instance for Free?
09:18:09 <bollu> quicksilver: like, I'm trying to prove to the compiler that Free f admits a functor instance
09:18:11 <monochrom> bollu: "fmap (fmap fn) a" may help
09:18:14 <hvr> puregreen: good question; I'm actually considering packaging gtk2hs-buildtools
09:18:21 <bollu> I can't just *use* the functor instance that I'm trying to prove
09:18:22 <quicksilver> bollu: well, when you define fact n = n * fact (n-1) 
09:18:32 <bollu> monochrom: it was written that way. but (fmap .fmap) makes more sense to me
09:18:36 <quicksilver> bollu: how can you *call* fact when you're still *defining* fact?
09:18:37 <hvr> puregreen: assuming it generates code compatible across multiple GHC versions
09:18:44 <quicksilver> this is called recursion :)
09:18:49 <monochrom> do you understand (fmap . fmap) better?
09:18:50 <bollu> quicksilver: that's different, that's a function call. a typeclass is a *contract*
09:18:54 <bollu> monochrom: yep!
09:18:56 <quicksilver> the fact it is a method we are writing makes no difference.
09:19:01 <monochrom> ok, problem solved.
09:19:01 <quicksilver> bollu: no, it's exactly the same.
09:19:01 <bollu> monochrom: (fmap . fmap) makes sense
09:19:16 <bollu> quicksilver: how is it the same?
09:19:20 <quicksilver> when you implement Functor, you define 'fmap' as a function
09:19:29 <bollu> quicksilver: in the first case (fib), my *type* is the contract
09:19:31 <quicksilver> you are quite entitled to use fmap recursively in its own definition.
09:19:33 <bollu> oh
09:19:33 <bollu> oh wow
09:19:33 <bollu> okay
09:19:45 <bollu> omg I hate you haskellers for your awesomeness sometimes :P understood
09:20:00 <bollu> quicksilver: but wait
09:20:03 <quicksilver> the contract for 'fact' is that it represents the factorial function
09:20:14 <monochrom> even []'s fmap is recursive
09:20:15 <quicksilver> using it recurisvely in its own definition is (arguably) subtle
09:20:18 <quicksilver> and the fact that it works
09:20:22 <bollu> monochrom: really?
09:20:22 <quicksilver> is the principle of induction.
09:20:35 <puregreen> hvr: and meanwhile I just added it to the “cabal build-cache MISS” branch, because “well, if there was a hit it would definitely be installed, and if there was a miss I don't care about spending some time to reinstall it”
09:20:36 <monochrom> um, you didn't know?
09:20:41 <bollu> monochrom: is it because [] ~= Free ((,) a) a?
09:20:47 <mauke> you could also do: fmap = my_recursive_helper where my_recursive_helper = ...
09:20:53 <monochrom> I am not that sophisticated
09:20:54 <Zekka|Sigfig> The idea is that if you believe fact (n - 1) is correct, then it would make sense that fact n = n * fact (n - 1)
09:20:58 <mauke> that way fmap itself is non-recursive
09:21:06 <bollu> mauke: slick
09:21:09 <bollu> monochrom: then why so?
09:21:25 <monochrom> fmap f (x:xs) = f x : fmap f xs
09:21:36 <bollu> monochrom: ohh, and fmap [] = []?
09:21:36 <bollu> nice
09:21:37 <quicksilver> OMG ITS TURTLES ALL THE WAY DOWN
09:21:43 <bollu> xD
09:21:47 <bollu> fmap f [] = []*
09:22:12 <bollu> cool, ty for the explanation people ^_^
09:23:05 <mauke> fmap = helper where { helper _ [] = []; helper f (x : xs) = f x : helper f xs }
09:23:38 <mauke> that transformation may actually make the original definition easier to understand because it distinguishes the different fmaps better
09:24:04 <bollu> mauke: yeah, I can see what the original does "better" now
09:24:43 <bollu> also, kinda weird, but there used to be a lot more newbies asking questions before winter break? or am I just imagining things?
09:25:03 <quicksilver> probably still lots of people on holiday
09:25:09 <quicksilver> lots of universities won't be back in courses yet
09:25:14 <bollu> oh yeah, good point
09:25:16 <puregreen> a-a-and my solution was wrong
09:25:39 <puregreen> or not
09:26:07 <puregreen> for some reason it can't find gtk2hsC2hs even tho $HOME/.cabal/bin is in PATH
09:27:00 <puregreen> right, because it didn't find alex
09:27:03 <puregreen> nevermind
09:29:02 <bollu> is there any way I can deriving(Show) for the Free? I have: data (Show (f a), Show a) => Free f a = Pure a | Branch (f (Free f a)) deriving(Show)
09:29:14 <bollu> No instance for (Show (f (Free f a)))
09:29:16 <bollu> why not?
09:30:58 <quicksilver> you can derive Show for it, yes
09:31:05 <quicksilver> dunno why there isn't one if there isn't
09:31:12 <quicksilver> I meant, you can *write* Show for it
09:31:18 <quicksilver> you can't derive it because GHC isn't smart enough
09:31:29 <quicksilver> although, ironically, the default instance it writes is the correct one
09:31:35 <quicksilver> it's just not prepared to write it :)
09:31:51 <quicksilver> is that ironic? probably not.
09:31:53 <quicksilver> just annoying.
09:32:00 <bollu> lo
09:32:01 <bollu> lol*
09:32:02 <c_wraith> you should be able to have ghc derive it standalone 
09:32:06 <bollu> why isn't it okay with writing it?
09:32:10 <bollu> c_wraith: how do I do that?
09:32:58 <c_wraith> look at the StandaloneDeriving extension 
09:33:10 * hackagebot type-level-sets 0.6 - Type-level sets and finite maps (with value-level counterparts and various operations)  https://hackage.haskell.org/package/type-level-sets-0.6 (DominicOrchard)
09:33:21 <c_wraith> it allows you to tell ghc what constraints to use in the instance 
09:33:30 <c_wraith> which is all it needs to work. 
09:34:03 <bollu> also, what exactly does do notation in the context of the Free monad *do*?
09:36:20 <bollu> as in, what is the "binding strategy" of Free?
09:37:34 <c_wraith> if you see Free as a kind of tree with values at the leaves, it grafts trees together 
09:38:11 <bollu> c_wraith: meaning?
09:38:27 <c_wraith> that's all it means. 
09:38:43 <bollu> also, compiler error: https://gist.github.com/bollu/f5a8e4c779a1e039d80b
09:38:52 <c_wraith> Free is just a data structure. it has no intrinsic meaning. 
09:38:53 <bollu> c_wraith: help? I'm not sure how to use StandaloneDeriving
09:39:19 <c_wraith> in fact, lack of intrinsic meaning is why Free is useful at all. 
09:40:19 <c_wraith> the second constraint should be Show (f (Free f a)) 
09:40:37 <bollu> ahh, thanks :)
09:41:32 <bollu>     Non type-variable argument in the constraint: Show (f (Free f a))
09:41:33 <bollu>     (Use FlexibleContexts to permit this)
09:41:35 <bollu> :/
09:41:42 <kaiyin> how do i solve this scoping problem?
09:41:43 <kaiyin> https://gist.github.com/kindlychung/e400ba8512d15968ba81
09:42:25 <c_wraith> bollu, follow the compiler's advice. you might need to turn on a couple more extensions 
09:42:35 <bollu> c_wraith: oh. I see
09:42:41 <puregreen> kaiyin: move it into a let
09:43:17 <puregreen> http://lpaste.net/148488
09:43:33 <puregreen> alternatively, pass args to toStrip
09:44:10 <puregreen> http://lpaste.net/148489
09:44:47 <c_wraith> kaiyin, as a follow up to puregreen's advice, the reason it's necessary is because the where is attached to main, and args is a binding inside of main 
09:45:24 <bollu> c_w*Main> do a <- Branch [Pure 10, Pure 20]; b <- Branch [Pure 20, Pure 40]; return $ (a + b)
09:45:24 <bollu> Branch [Branch [Pure 30,Pure 50],Branch [Pure 40,Pure 60]]
09:45:30 <bollu> how do I explain the way Free is acting here?
09:45:36 <puregreen> and by the way, you don't need the if here – you can write “toStrip = Just $ args `notPresent` (longOption "nostrip")”
09:45:39 <bollu> given two "branches", it creates a larger branch?
09:45:48 <bollu> so what happens when I give it a "pure" and a "branch"?
09:46:05 <c_wraith> kaiyin, where blocks can only see things at higher scopes, or bound by the thing it is attached to. 
09:46:51 <kaiyin> puregreen: did you miss a `in` somewhere?
09:47:08 <puregreen> I don't think I did
09:47:17 <c_wraith> there is special let syntax in do blocks
09:47:39 <c_wraith> it makes the binding available for the rest of the do block without an in
09:47:52 <kaiyin> ok. 
09:48:10 * hackagebot type-level-sets 0.6.1 - Type-level sets and finite maps (with value-level counterparts)  https://hackage.haskell.org/package/type-level-sets-0.6.1 (DominicOrchard)
09:48:46 <josephle> that threw me off when I was learning do-notation
09:49:11 <c_wraith> bollu, it gets more complex when you have multiple binds. the behavior depends on the shape of each thing bound. 
09:49:56 <bollu> c_wraith: damn, that's confusing
09:50:02 <kaiyin> another error: https://gist.github.com/kindlychung/f5d8cebd3e3e54f3474c
09:50:04 <bollu> c_wraith: any rule-of-the-thumb?
09:50:52 <bollu> josephle: I don't think your args is an IO action. just let args = … should wok
09:50:54 <bollu> work*
09:50:58 <c_wraith> bollu, but the basic idea is that each Pure is rewritten as the result of applying the rest of the block. 
09:51:09 <bollu> wait ignore me
09:51:19 <puregreen> kaiyin: getArg doesn't need IO
09:51:24 <puregreen> use let instead of “<-”
09:51:27 <bollu> c_wraith: can you expand on "expand the rest of the block"
09:51:56 <puregreen> “let delimiter = args `getArg` (argument "delimiter")”
09:52:37 <c_wraith> bollu, are you comfortable with rewriting do notation as explicit calls to (>>=) and lambdas? 
09:53:11 * hackagebot wai-middleware-verbs 0.2.0 - Route different middleware responses based on the incoming HTTP verb.  https://hackage.haskell.org/package/wai-middleware-verbs-0.2.0 (athanclark)
09:53:13 * hackagebot gitHUD 1.2.0 - More efficient replacement to the great git-radar  https://hackage.haskell.org/package/gitHUD-1.2.0 (gbataille)
09:53:43 <ggVGc> fwiw, writing Elm for a while has really made me understand why laziness is good in haskell
09:53:53 <bollu> c_wraith: yep
09:53:54 <bollu> c_wraith: so you want me do that?
09:54:19 <bollu> c_wraith: in a lot of cases, I find that knowing the "binding strategy" is way less messy that rewriting everything in terms of (>>=)
09:54:25 <bollu> c_wraith: but I'll try that as well :)
09:56:03 <c_wraith> bollu, well. just think of it as every (>>=) replaces any Pure constructors in its left argument with the result of calling its right argument with the value contained in the Pure constructor. 
09:56:24 <c_wraith> bollu, that might be clear as mud.. but it's exactly what is going on 
09:57:05 <bollu> c_wraith: you just defined >>= :)
09:57:21 <bollu> c_wraith: but considering the structure is "free"
09:57:31 <c_wraith> the code is the ultimate authority. :) 
09:57:34 <bollu> xD
09:57:36 <bollu> fair enough
09:57:44 <bollu> I'll go grab a coffee and sit down with this
09:58:03 <bollu> I seem to spend most of my time with haskell playing around with types and a piece of paper :P
09:58:09 <c_wraith> it doesn't really have any intrinsic meaning beyond combining the trees 
09:58:30 <MarcelineVQ> bollu: that's often a productive thing to do
09:58:58 <kaiyin> nice, it's successfully built. :-)
09:59:18 <bollu> MarcelineVQ: yeah, agreed :) but sometimes I feel guilty - it feels more like "playing" than "programming"
09:59:31 <t7> how does statet work with (Either a)
09:59:39 <kaiyin> "\s\w\d", these are not supported in Text.Regex?
10:00:56 <c_wraith> > "\s\w\d" 
10:00:58 <lambdabot>  <hint>:1:3:
10:00:58 <lambdabot>      lexical error in string/character literal at character 's'
10:01:20 <c_wraith> huh. ghc handles that better than I anticipated 
10:01:46 <c_wraith> an error message is way better than silently saying "sure" :) 
10:02:59 <geekosaur> it's posix, not pcre
10:04:28 <t7> @hoogle Either a b -> StateT c (Either a) d
10:04:30 <lambdabot> Did you mean: Either a b -> StateT c (Either a a) d
10:04:30 <lambdabot> No results found
10:04:59 <c_wraith> t7: d? 
10:05:10 <t7> d = ()
10:05:55 <t7> lift
10:05:58 <t7> there we go
10:05:58 <c_wraith> isn't that mostly just lift? 
10:07:06 <bollu> c_wraith: oh cool, it makes sense now
10:07:15 <bollu> so you basically unpack a tree down to the Pure a
10:07:23 <bollu> pass each Pure a through the bind function
10:07:32 <bollu> and then "replace" the tree node with theoutput
10:07:33 <bollu> correct?
10:07:51 <c_wraith> yes
10:07:58 <bollu> cool ^_^
10:08:15 <bollu> c_wraith: so in some sense, you go down to the Pure a, and then "inflate" each a with a Free a, right?
10:09:01 <c_wraith> I suppose that works. it's valid to say that binds will never make the tree smaller. 
10:10:25 <bollu> c_wraith: okay, now I don't see how this cool monad we built helps to write an interpreter
10:10:58 <t7> monad transformers are dreamy :)
10:12:50 <c_wraith> bollu, it sort of doesn't. the interpreter still had to do everything it would. it just makes it transparent to represent programs as expression trees. 
10:13:23 * hackagebot concurrent-output 1.7.3 - Ungarble output from several threads or commands  https://hackage.haskell.org/package/concurrent-output-1.7.3 (JoeyHess)
10:13:26 <c_wraith> bollu, I guess that means you get to skip lexing and parsing! 
10:14:28 <suppi> are you talking about free?
10:15:00 <bollu> c_wraith: wait, what do you mean I get to skip lexing and parsing? I still need to build the Free tree right?
10:15:01 <bollu> suppi: yep :)
10:15:32 <suppi> one day I'll understand how to use free. I like the idea :)
10:15:35 <c_wraith> bollu, Oh. the general use case is for an embedded DSL 
10:15:57 <c_wraith> bollu, in which case the programmer creates the expression tree directly. 
10:16:11 <suppi> bollu, this might be interesting on the subject http://begriffs.com/posts/2015-12-26-what-code-means.html
10:16:14 <bollu> c_wraith: um, okay. I have more questions >_<. 1: usually, which version of "f" do we use? (as in, is there a particular Free we use?)
10:16:17 <punkcoder> hi
10:16:27 <bollu> c_wraith: a simple example would be..?
10:17:14 <c_wraith> bollu, http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
10:17:21 <bollu> c_wraith: thanks
10:17:26 <c_wraith> that's probably the best intro 
10:18:18 <t7> @hoogle Bool -> a -> Either a ()
10:18:19 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
10:18:19 <lambdabot> Text.Parsec runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
10:18:19 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
10:18:33 <haskell275> hi
10:18:38 <haskell275> hello
10:18:47 <haskell275> some one to chat
10:18:48 <haskell275> ?
10:18:49 <bollu> haskell275: hey :)
10:18:52 <broma0> haskell275: hello there
10:19:01 <volhovm> haskell275: sup
10:19:09 <haskell275> ok this is the channel of haskell?
10:19:31 <bollu> haskell275: yep
10:19:31 <broma0> haskell275: this and haskell-beginners
10:20:09 <haskell275> ok
10:20:12 <haskell275> im reading a book
10:20:18 <haskell275> named
10:20:32 <haskell275> learning a hasjkell for great good
10:20:38 <haskell275> im starting only
10:20:54 <broma0> haskell275: that's a good one. it doesn't cover much of the moderate/advanced stuff, but its a great introduction
10:21:08 <broma0> be sure to follow along in ghci and write some examples of your own
10:21:18 <punkcoder> are you experienced programmers?
10:21:20 <kadoban> haskell275: LYAH isn't really recommended much anymore. There's better ones … if you come back because you just left apparently.
10:21:32 <punkcoder> i re enter with other name, i said before i was reading a book
10:21:40 <volhovm> broma0: which book would you recommend related to moderate-advanced topics?
10:21:58 <broma0> volhovm: the haskell wiki :D
10:22:09 <broma0> im sure others can give oyu advice on that, but sadly i cannot :/ 
10:22:15 <volhovm> sure, but it's not that structured as LYAH
10:22:16 <bollu> c_wraith: output :: a -> Free (Toy a) ()
10:22:24 <kadoban> punkcoder: https://github.com/bitemyapp/learnhaskell has some good advice if you want free stuff only. http://haskellbook.com/ would be the way I'd go if you're serious.
10:22:28 <bollu> c_wraith: what is going on there? why is (Toy a) a functor?
10:22:30 <broma0> i stareted with LYAH, then read through parts of Real World Haskell but got turned off by its age
10:22:59 <volhovm> RealWordHaskell is begginer-middle as for me
10:23:10 <kadoban> punkcoder: LYAH isn't very good on its own. It has no exercises and thus doesn't really teach you to do much of anything. Reading it is mostly easy, but nothing sticks.
10:23:13 <volhovm> It covers only some libraries over LYAH
10:23:46 <punkcoder> oks
10:23:47 <c_wraith> bollu, for now, I'd just keep reading. then come back and see if your questions were answered later. 
10:23:50 <punkcoder> then you recommend more
10:23:55 <punkcoder> haskellbook
10:24:10 <broma0> LYAH can be very useful if you try to functions/small programs that illustrate what's being talked about in the book
10:24:21 <broma0> haskell is very "learn by doing" (at least for me)
10:24:24 <kadoban> punkcoder: Yeah, though it's not free.
10:25:16 <punkcoder> i wnat to understand the functional programming im coming from oop
10:25:23 <bollu> c_wraith: alright
10:25:28 <punkcoder> but i dont really think i will work with funtional programmimng
10:25:32 <bollu> c_wraith: I'm not a huge fan of that style :( It feels weird
10:25:36 <kadoban> broma0: Except it gives you no guidance on what exercises are useful or possible at any steps, so you're either figuring it out on your own or just wild-guessing. Exercises aren't something the student should really have to add using their expertise, because they … don't have expertise or they wouldn't be reading an introductory text.
10:25:42 <punkcoder> only if it is necessaryu
10:26:29 <broma0> kadoban: that's an interesting point - and i mostly agree with it. thanks for that
10:26:40 <potatoe> does anyone know how to start a connection pool with PostgreSQL.Simple
10:26:41 <potatoe> ?
10:26:45 <potatoe> maybe I should be using HDBC
10:28:24 * hackagebot feed 0.3.10.4 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.  https://hackage.haskell.org/package/feed-0.3.10.4 (AdamBergmark)
10:28:51 <bergmark> potatoe: postgresql-simple is better, and pooling in HDBC is slightly broken :-o
10:29:16 <potatoe> bergmark but I don't see anything in the Documentation on how to start a pool :(
10:29:26 <bergmark> i'll dig up an example
10:29:30 <potatoe> thanks!
10:30:12 <bergmark> potatoe: not copy-pasteable but the code is there https://github.com/silkapp/silk-opaleye/blob/master/src/Silk/Opaleye/Transaction.hs#L120
10:30:21 <broma0> I'm looking to try out an alternative way (not transformers) to add layers of effects. anyone know of some reading or buzz words to look up?
10:30:40 <bergmark> broma0: extensible effects
10:31:11 <potatoe> bergmark that is kind of scary to someone new to haskell
10:31:14 <broma0> bergmark: is that what the cool kids are using these days?
10:31:16 <Zekka|Sigfig> http://www.cl.cam.ac.uk/~dao29/publ/haskell14-effects.pdf <- here’s an essay describing an approach that’s closely related. At least one guy implemented i tbut I can’t remember what hte library is called
10:31:30 <Zekka|Sigfig> oh here it is: https://github.com/dorchard/type-level-sets
10:32:43 <bergmark> potatoe: in essence, withResource myPool (\connection -> PG.withTransaction connection aQuery) where myPool is a pool from resource-pool
10:34:04 <bergmark> broma0: the downsides i've heard about it is that you often lose type inference, and using free monads to implement it is very slow (not sure if there are alternative implementation strategies out there)
10:34:31 <potatoe> bergmark sorry for the dumb question but right now I've the defaultConnectInfo object and I just pass it into ReaderT to pass into my application
10:35:05 <potatoe> but how would I implement connectionPool instead of that? because I see connectionPool in the example but Ive no idea where its coming from
10:35:20 <suppi> standford's cs240h is starting again for those who haven't heard: http://www.scs.stanford.edu/16wi-cs240h/
10:35:49 <bergmark> potatoe: https://github.com/silkapp/silk-opaleye/blob/master/src/Silk/Opaleye/Config.hs#L59
10:36:20 <potatoe> cheers!
10:36:21 <bergmark> that *is* copy-pasteable :-)
10:36:45 <potatoe> I usually find copy pasting bad for my memory so i'm gonna write it and deal with all the compiler errors 
10:36:55 <potatoe> i'll get it in my head after a few hours 
10:36:57 <bollu> c_wraith: I'm sort of lost on how creating a functor for the DSL / Toy type "automagically" lets us encode it using Free
10:37:00 <bollu> c_wraith: like..
10:37:03 <bollu> c_wraith: what the hell is going on?
10:38:11 <c_wraith> I'm not the best one to answer that right now. too much other stuff going on. 
10:38:42 <bollu> c_wraith: alright. Thanks for all the help until now :)
10:39:01 <broma0> bergmark: ever mess around with free monad transformers to layer effects? e.g. write a free monad for effects A and B, and then write one for effect C such that I can call a function addEffectC on some effectAB code and be given effect C as well? i know that's hard to read.. i can't quite figure out how to work my real question
10:39:30 <t7> whats the inverse of borrowing?
10:39:32 <t7> lend?
10:40:47 <bergmark> broma0: no i haven't. i'm not knowledgeable in this, just going on hearsay
10:41:54 <broma0> bergmark: that's alright, thanks 
10:42:03 <broma0> anyone familiar with layering free monads ?
10:42:54 <bollu> suppi: how do you register for the Stanford course?
10:43:12 <troydm> there is this ridiculous idea that came to me today, related to Types in Haskell
10:43:20 <suppi> bollu, I don't think you can
10:43:24 * hackagebot random-variates 0.1.1.0 - "Uniform RNG => Non-Uniform RNGs"  https://hackage.haskell.org/package/random-variates-0.1.1.0 (kpratt)
10:43:26 <bollu> suppi: :(
10:43:35 <suppi> bollu, yup.
10:43:57 <troydm> why don't we consider ADT constructors as separate types? 
10:44:16 <troydm> for example data Maybe a = Just a | Nothing 
10:44:26 <troydm> I can see three types here
10:44:28 <troydm> Just a 
10:44:30 <troydm> Nothing
10:44:39 <troydm> and compound type of either of those two above
10:44:41 <bollu> troydm: you can, they're called refinement types IIRC
10:45:14 <bollu> troydm: I wished we had them when I used to write Rust code as well. Someone told me what they're called and why they're hard to implement
10:45:21 <bollu> troydm: may have been huonw
10:46:04 <troydm> Rust has them?
10:46:08 <broma0> troydm: data family Maybe a; data instance Maybe a = Just a; wubalubadubdub. that's what popped into my head
10:46:15 <potatoe> bergmark just out of curiously, why did you say that HDBC connection pooling is broken?
10:46:24 <bollu> troydm: nope, but I had wanted them when I was first learning rust.
10:46:54 <ReinH> refinement types are a type of structural subtyping that allows predicates. e.g., I can have a type for natural numbers greater than 5.
10:46:56 <troydm> more like:
10:47:05 <troydm> data Just a = Just a
10:47:09 <troydm> data Nothing = Nothing
10:47:17 <troydm> compound Maybe a = Just a | Nothing
10:47:24 <bollu> ReinH: so that's not what they're called?
10:48:09 <bollu> troydm: yes, so the pattern that I used to follow was something like: Data Just a = Just a. Data Nothing = Nothing Maybe a = CompoundJust (Just a) | CompoundNothing(Nothing) which is nice in rare ocacsions
10:48:12 <ReinH> er, s/structural subtyping/behavioral subtyping
10:48:51 <bollu> ReinH: as you can see, I'm still going over the Free monad / cofree comonad thing :)
10:49:03 <troydm> I don't think that compound type needs constructor because it can be easily converted
10:49:25 <troydm> like types that are part of compound type are all can be casted to Compound type
10:49:48 <troydm> but to destruct compound u need to use case statement 
10:50:11 <troydm> that's what popped in my mind when I was reading Real World Haskell third time 
10:50:40 <troydm> the type system remains both complete and sound
10:50:54 <troydm> and there is no need for GADT whatsoever 
10:51:04 <koshmar> about NICTA course, I've finished normal exercises in Nicta, and I am thinking to start nicta projects, should I start with networkserver or ticktak game? or maybe you would advise to do something different?
10:51:42 <joko> I have a type IO (Maybe [XRRScreenSize]), is it possible to return IO Nothing?
10:51:57 <bollu> joko: yes
10:52:11 <shachaf> There's no such thing as IO Nothing.
10:52:31 <bollu> shachaf: as a value?
10:52:39 <joko> bollu: I'm getting Not in scope: data constructor ‘IO’, should I import something?
10:52:41 <troydm> u can just return IO ()
10:52:43 <shachaf> There's return Nothing :: IO (Maybe a)
10:53:09 <shachaf> But you should make sure you aren't confusing the type-level IO with the value level.
10:53:17 <bollu> shachaf: ah, right
10:53:24 * hackagebot telegram-api 0.1.0.0 - Telegram Bot API bindings  https://hackage.haskell.org/package/telegram-api-0.1.0.0 (klappvisor)
10:56:42 <joko> I'm getting this warning here: https://ptpb.pw/XHNw
10:57:36 <t7> is ghc core language simply typed?
10:58:07 <MarcelineVQ> very simply https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType
10:58:46 <t7> why is Type a constructor for Expr
10:59:27 <t7> ah type constructors 
11:00:22 <ggole> System-F isn't simply typed
11:01:30 <Xandaros> Btw, do we have a release date for 8.0 yet?
11:05:06 <gameer> hey guys
11:05:32 <gameer> If I have a tree and I have to go bottom-up. Do I start at the root or not?
11:06:27 <Xandaros> gameer: In computer science, trees usually grow from top to bottom
11:06:44 <gameer> yes I am a bit confused
11:06:48 <gameer> I have an existing tree
11:07:14 <gameer> I have to write an algorithm like the minimax-algorithm
11:07:15 <broma0> what do you mean by "go bottom up"
11:07:48 <ReinH> bottom-up means whatever bottom-up means. It would be defined in terms of the root of the tree.
11:08:20 <ReinH> minmax starts at the root, fwiw
11:08:43 <kadoban> bottom-up usually means you start at the "leaves" I guess
11:09:07 <ReinH> how do you start at the leaves?
11:09:14 <ARM9> bottom up usually means you start at a leaf and ascend the tree to do whatever you're doing, you forgot to explain that part.
11:09:21 <ARM9> you start at a leaf by finding it first
11:09:24 <gameer> ah ReinH u know my oroblem from yesterday. Where I had to create a tree of a game?
11:09:35 <gameer> problem*
11:09:38 <ReinH> ARM9: which means you start at the root
11:10:25 <ARM9> you start the algorithm from the leaf
11:10:30 <ARM9> to find it you need to know the root usually, yes
11:10:34 <Freundlich> ReinH: What do you mean by start at? With a bottomup approach you calculate the value at the root last.
11:10:45 <ReinH> ARM9: I guess we don't agree on what it means to start an algorithm
11:10:50 <ARM9> sure
11:10:58 <ARM9> tell that to the people who invented LR parsing
11:11:08 <ARM9> I'm sure they'd be thrilled to get a lecture on semantics
11:11:13 <ReinH> In Haskell, pattern matching starts at the root.
11:14:25 <Xandaros> You probably do a depth-first kind of approach, calculating the value of the current node last
11:15:29 <Xandaros> Although, will probably work with breadth-first, too. Nvm
11:16:30 <ReinH> saying that bottom up starts at the leaves is like saying last starts at the end of a list.
11:17:34 <Xandaros> Pretty much
11:18:46 <gameer> I have to eat now a bit, I will explain my problem specier after that 
11:24:56 <zachk> aren't tree's usually constructed intially from the bottom? 
11:26:33 <Gurkenglas> I think by bottom-up and top-down he means catamorphisms and anamorphisms, as described here http://blog.sumtypeofway.com/recursion-schemes-part-2/
11:28:44 <beepbeep_> The type of h is (Num a, Num b) => a -> b -> b. What is the type of h 1.0 2? I expected it to be Integer but it actually is Num b => b. Can anyone point me in the right direction?
11:29:02 <Gurkenglas> (Oh wait I guess the post before that one already explains bottom-up and top-down traversals)
11:29:21 <Gurkenglas> :t 1.0
11:29:23 <lambdabot> Fractional a => a
11:29:25 <Gurkenglas> :t 2
11:29:26 <lambdabot> Num a => a
11:29:41 <zachk> ghc is very general on num types these days, it isn't specific unless it needs to be
11:29:44 <Gurkenglas> The first argument doesnt have anything to do with the result type, but the result type is equal to the second arguemtn
11:30:07 <beepbeep_> oic
11:30:11 <beepbeep_> it goes for the most general class
11:30:12 <zachk> so Num b might be fine for you, if it isn't, use a specific type signature on b 
11:30:45 <zachk> if the first element has nothing to do with the result, then it doesn't even need to have the Num a constraint 
11:30:49 <zachk> :t const 
11:30:50 <lambdabot> a -> b -> a
11:31:00 <zachk> :t (flip const) 
11:31:02 <lambdabot> b -> c -> c
11:31:23 <zachk> does your original b even need to be a number? 
11:31:46 <erisco> what are FRP or event stream or reactive or related libraries which have been ported to C# or which are inspired by a Haskell package?
11:31:57 <erisco> I need a paddle here =\
11:32:01 <pranz> zachk: it may have something to do with the result, but it has nothing to do with the result _type_
11:34:10 <zachk> the a or the b? 
11:34:33 <pranz> zachk: the a
11:42:13 <Gurkenglas> Is there a language extension that treats "1 + $ 2" as "(1 +) $ 2"?
11:43:31 <edwardk> > 2 * do 3 + 4
11:43:33 <lambdabot>  14
11:43:38 <edwardk> Gurkenglas: use do ;)
11:44:30 <edwardk> e.g. 1 + do 2
11:46:06 <Gurkenglas> I love it! Except that it doesn't work for "+ 1 $ 2"/"+ 1 do 2". I was hoping for something that resolves operator clashes by turning the highest-fixity operator into a section.
11:46:15 <mnoonan> huh, a do expression doesn't have to have a monadic type?
11:46:26 <edwardk> Gurkenglas: ah no nothing that magic exists
11:46:35 <Cale> mnoonan: right, the base case is do { x } -> x
11:46:38 <edwardk> mnoonan: that is why i trotted out that example as it breaks most people's brains
11:46:50 <Cale> mnoonan: and since that doesn't use (>>=), you don't end up with a Monad constraint
11:57:34 <broma0> edwardk: hello, if you have a moment - is there a *nice* way to stack your free monads? i'd like to model the layers of effects in a system using individual free monads, and be able to add and remove the layers as needed
12:05:25 <ReinH> broma0: You can't create a transformer with Free.
12:05:56 <ReinH> There is a FreeT construction, but I'm not sure if it is useful to you
12:06:29 <ReinH> perhaps you want something like extensible effects instead
12:13:33 <bitemyapp> @pl g f x = fromMaybe x (f x)
12:13:33 <lambdabot> g = ap fromMaybe
12:14:31 <ReinH> bitemyapp: :D
12:15:41 <edwardk> broma0: i'm not an advocate for the 'free monads for everything' school of thought
12:15:55 <edwardk> extensible effects tend to not extend very well ;)
12:16:17 <ReinH> broma0: practically speaking, you may prefer to write / use typeclasses which isolate your effects
12:16:55 <edwardk> like ReinH hinted at, writing your own MonadFoo that describes the operations you want tends to work pretty well
12:17:05 <edwardk> thenyou accumulate the set of constraints you need on your code
12:17:31 <edwardk> and write one monad that instantiates all your various MonadFoo and MonadBar classes with the semantic you desire when you're done
12:18:11 <edwardk> this is pretty compositional, and that final thing may be stitched out of transformers of build out of whole cloth, whatever.
12:19:13 <bitemyapp> mtl is bae
12:19:36 <bitemyapp> mtl-_style_ is bae
12:19:54 <MarcelineVQ> what is bae
12:21:13 <ReinH> it's a word bitemyapp likes to use instead of 'good' that means 'good'
12:22:24 <bitemyapp> ReinH - bear translator
12:27:00 <ReinH> the bitemyapp whisperer
12:27:51 <broma0> wow, i look a way for a few minutes and come back to some great points. thanks edwardk and ReinH 
12:28:26 <broma0> edwardk: ive fallen into that school of thought, but it's been getting rather frustrating
12:28:44 <broma0> ReinH: i'm refactoring some code to use the MonadFoo idea.. we'll see how it goes
12:29:07 <edwardk> broma0: my issue is that there are many 'effects' you want that don't compose no matter how much you try. and the handler model lets you lie to yourself thinking they can
12:31:14 <roelof> one small question : when I want to update a variable and add something to a list. Do I need to use a do statement or can I just do command_1; command_2 
12:34:09 <broma0> roelof: do you have some code to show that doesnt work? based on your question, i have a feeling you're new to functional programming, is this true? if so, you may want to read about immutability and what "pure" means as it pertains to haskell
12:34:37 <vl174> roelof do is syntactic sugare for monads… generally speaking haskell “variables” are just names for things so they cannot be updated. adding to a list creates new list
12:35:27 <vl174> probably you’re a novice in functional programming. What you’re trying to achieve is doable but this is probably is not what you want to do in haskell
12:36:25 <tdammers> roelof: that's imperative thinking ("I want to do X, then do Y"). Try to state your requirements in terms of "I have A, and I want B"
12:36:47 <roelof> I have this code : http://lpaste.net/148493
12:37:15 <augur> grr
12:37:20 <augur> pattern synonyms are being annoying :|
12:37:21 <roelof> what I want is this : now applyTransactions is returning a new Account 
12:37:42 <Zekka|Sigfig> (FWIW, that code looks fine to me, and even idiomatic.)
12:38:04 <augur> apparently GHC treats pattern synonyms different from the un-synonymed version, so -Wall doesn't see totality of a pattern match
12:38:23 <roelof> What I need is that the new Account is returned and the AccountTransactions is updated with the Transaction 
12:40:17 <vl174> roelof it’s possible, but going against haskell (functional programming in general) idioms. You generally create new updated thing.
12:40:55 <vl174> for what you’re asking for you have to use one of monads (IO, State, ST…)… but I suggest looking through some tutorial first
12:41:14 <tdammers> roelof: http://lpaste.net/148493
12:41:19 <tdammers> like that?
12:41:21 <roelof> hmm, I was hoping it was possible :( 
12:42:01 <vl174> roelof it is indeed possible
12:43:10 <roelof> tdammers : I see what you mean : I take the transaction and add it with : to what I have 
12:43:18 <roelof> Thanks for the idea 
12:43:58 <tdammers> it's basically the same thing as with the account balance, only you're "updating" a list instead of a number
12:44:26 <tdammers> ++ [transaction] would have worked too, but would be less efficient as your list grows longer
12:44:29 <roelof> oke, I have no thought to do it this way: Thanks 
12:44:42 <roelof> I know that already 
12:44:55 <roelof> I was again overthinking things 
12:46:06 <vl174> import Data.IORef 
12:46:06 <vl174> ……………
12:46:08 <vl174> updatableAccount :: IO ()
12:46:09 <vl174> updatableAccount = do
12:46:10 <vl174>    accRef <- newIORef $ Account "my account" 0 []
12:46:11 <vl174>    modifyIORef accRef $ deposit 100 "The first deposit"
12:46:39 <vl174> It’s just not the way things are generally done in haskell. In the above example we use IO monad
12:47:11 <roelof> vl174:  thanks, Monads is something I still have to learn 
12:48:47 <vl174> roelof: this is how the “effects” are structured in haskell (which is pure language). Good luck :) Learning monads will pay :)
12:50:59 <roelof> vl174:  and with effects you mean updating a list or a integer which represent something ? 
12:53:05 <vl174> “updating” something, writing to files, throwing exception all sorts of thing :) 
12:55:25 <roelof> oke, thanks all for the lessons. 
12:55:35 <roelof> and have a good evening 
13:07:23 <suppi> What is a good way to go on designing a model for gamedev?
13:07:53 <suppi> in purescript for example i'd use row polymorphism to create objects that have a component (say, location)
13:08:02 <kaiyin> how do you control the executable name for a stack project? I want to remove the -exe part
13:08:15 <Jinxit> suppi: you mean like a gameobject?
13:08:22 <suppi> Jinxit, yes
13:08:29 * hackagebot eventstore 0.10.0.1 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.10.0.1 (YorickLaupa)
13:08:33 <zachk> kaiyin it is in projectname.cabal 
13:09:01 <Jinxit> I use lenses to allow for records with the same name
13:09:26 <suppi> I can go with typeclasses, like class HasPosition a where getPosition :: a -> Point
13:09:36 <Jinxit> exactly
13:09:52 <suppi> or even better: position :: ALens' a Point
13:10:19 <suppi> but I'm not sure if using typeclasses for all this is good or not
13:10:39 <kaiyin> zachk: cool. thanks.
13:11:00 <suppi> any thoughts?
13:11:12 <zachk> kaiyin you are welcome :D
13:12:36 <acertain> what's the difference between `newtype ContT m a = ContT { forall r. (a -> m r) -> m r }` and `newtype ContT = ContT { forall r. (m a -> r) -> r }`?
13:14:43 <Jinxit> suppi: hardly a reference, but you can check out my https://github.com/Jinxit/firestone to see the problems and benefits I had from using lens
13:14:53 <Jinxit> (still new to haskell to expect some oddities)
13:15:19 <Jinxit> as a non-trivial example
13:15:58 <akfp> I'm looking for an isomorphic web framework for Haskell, but "isomorphic" is too overloaded to be a useful term when combined with Haskell.. does such a thing exist?
13:16:03 <johnw> acertain: try to write a bijection between them, and it should become clear
13:16:23 <johnw> acertain: that usually what I do when I'm trying to learn exactly how two things differ
13:20:04 <vxr1> anyone use wreq?
13:20:37 <vxr1> going through the wreq tutorial and it mostly works
13:20:41 <vxr1> but when i get to the post example
13:20:41 <vxr1> r <- post "http://httpbin.org/post" ["num" := 3, "str" := "wat"]
13:21:02 <vxr1> I get an error about an ambiguous type variable
13:21:09 <vxr1> weirdly it works just fine in ghci
13:22:02 <suppi> Jinxit, where do you define, for example, HasUuid?
13:22:21 <suppi> suppi, what are the problems and benefits you had?
13:23:28 <ReinH> akfp: well, what is an isomorphic web framework?
13:23:34 <Jinxit> suppi: makeFields creates the typeclasses for me
13:23:46 <puregreen> vxr1: can you paste the error somewhere?
13:23:55 <ReinH> I don't see how to apply the mathematical definition of isomorphic to web frameworks.
13:24:16 <ReinH> and specifically, to *a* web framework
13:25:06 <suppi> O_O
13:25:08 <Jinxit> suppi: one "downside" is that I can't store multiple things that have an UUID in the same list (since I have no sum type for them)
13:25:16 <vxr1> puregreen pasted here http://lpaste.net/148495
13:25:26 <suppi> Jinxit, when you said you were new to Haskell, what did you mean?
13:25:48 <suppi> Jinxit, yes, expected that much
13:25:50 <Jinxit> been at it for 1-2 months or something maybe?
13:26:02 <vxr1> puregreen any ideas?
13:26:13 <suppi> Jinxit, I see
13:26:26 <josephle> ReinH: iirc, an isomorphic web framework is one where the code run on client and server are the same
13:26:34 <Jinxit> there are probably plenty of places where I'm more verbose than I have to be because I don't know the functions off-hand
13:26:49 <suppi> Jinxit, I've been learning Haskell for about two years now, always discouraging someone like you :)
13:26:50 <vxr1> oh i omitted the numerical value to narrow it down so the line in question is simply
13:26:50 <vxr1> r <- post "http://httpbin.org/post" (["str" := "wat"] :: [FormParam])
13:26:54 <suppi> that's a compliment
13:27:01 <Jinxit> hehe, thanks
13:27:05 <puregreen> vxr1: if you have OverloadedStrings enabled, you have to give type annotations to strings, I think
13:27:32 <suppi> Jinxit, how long have you been programming?
13:27:38 <ReinH> josephle: Ah, so not isomorphic. "Isomorphic".
13:27:40 <vxr1> hmm it is enabled (as per tutorial instructions)
13:27:44 <josephle> ReinH: exactly
13:27:51 <ReinH> akfp: You can do that with ghcjs.
13:27:58 <puregreen> vxr1: it works in GHCi because GHCi has different defaulting rules
13:28:01 <vxr1> puregreen do you know what wreq expects. also, why would this work in ghci, since overloaded strings is enabled there too
13:28:04 <suppi> if you don't mind me asking.
13:28:06 <Jinxit> if you count visual block programming, probably since I was 10 or so (LEGO)
13:28:10 <vxr1> puregreen i see
13:28:18 <vxr1> puregreen acht that was confusing
13:28:43 <Jinxit> not sure when I progressed to normal coding
13:28:55 <ReinH> akfp: I am doing so right now. I have a few libraries that supply types, JSON encodings, state machines, etc, and then I use them in both the server and, via ghcjs, the client.
13:29:01 <vxr1> puregreen do you know what type annotation wreq is expecting? and i assume it has to be on both sides of the := operator... right?
13:29:26 <ReinH> vxr1: why not just use "1" instead of 1?
13:29:36 <ReinH> parameters are strings anyway
13:30:00 <puregreen> vxr1: probably «"str" := ("wat" :: String)»
13:30:13 <puregreen> since "str" is fixed to be ByteString
13:30:21 <vxr1> ReinH what "1" are you referring to?
13:30:28 <aweinstock> Jinxit: existential types let you store a bunch of things that implement HasUUID in a list, but that'll only let you access whatever function HasUUID provides on each of them
13:30:31 <Gurkenglas> Jinxit, why do you need UUIDs?
13:30:49 <aweinstock> (so it's the same thing as storing a list of UUIDs, unless there's more than 1 method there)
13:31:19 <vxr1> puregreen THANK YOU. damn i was scratching my head on that for way too long ...
13:31:21 <Jinxit> Gurkenglas: the API came from another project
13:31:39 <Jinxit> the justification was the ability to send them on the wire
13:31:43 <ReinH> vxr1: er, sorry, "3" instead of 3
13:31:44 <vxr1> ghci's different defaulting rules were throwing me off
13:31:56 <Jinxit> and some day I will add a lens to get minions using that UUID
13:32:05 <Jinxit> just haven't done it yet
13:32:15 <vxr1> ReinH eh i think that's just what they picked in the wreq tutorial...
13:32:29 <Jinxit> or rather, the API came from the same project but done in java
13:32:43 <vxr1> now lets see if the numeric form parameter works
13:33:08 <ReinH> vxr1: huh.
13:33:37 <Jinxit> and aweinstock: that's neat, but yeah, in this case they only allow me to access the data
13:33:49 <Jinxit> could be useful for storing Characters though
13:34:04 <vxr1> ok the numeric value has the same issue
13:34:25 <vxr1> I guess there's slightly different ghc/ghci defaulting rules for the number in thsi context too?
13:34:39 <vxr1> this compiles (finally!): r <- post "http://httpbin.org/post" (["num" := (3 :: Integer),"str" := ("wat" :: String)] :: [FormParam])
13:35:21 <vxr1> actually I don't need the :: [FormParam] annotation
13:37:37 <vxr1> damn that was a wat moment :(
13:39:21 <akfp> Isomorphic in a web framework typically means that the server can serve pre-rendered html that the client can continue manipulating as a single page app.  The server can run the client side and thus serve pages to crawlers, and the initial load time is fast.  Subsequent manipulation is fast because it is a single page app.
13:39:33 <Gurkenglas> Jinxit, Show and Read (or FromJSON and ToJSON) can do the sending over the wire thing and you can derive those automatically
13:39:46 <johnw> akfp: how does that fit the meaning of the word "isomorphic"?
13:39:54 <ReinH> akfp: Ah, right, that has nothing to do with isomorphic, but I understand the idea
13:39:55 <vxr1> thanks again puregreen, back to work now ...
13:40:03 <Jinxit> Gurkenglas: you would trust the client to send the correct data?
13:40:08 <ReinH> There isn't a framework that can do that yet, but GHCJS makes it very possible.
13:40:24 <ReinH> johnw: It doesn't, someone just coopted the word because they liked it I guess.
13:40:38 <johnw> I'd think "Monomorphic" would at least be somewhat closer
13:40:49 <johnw> or just avoid the morphism implication entirely
13:40:56 <Gurkenglas> Jinxit, oh you mean that you cryptographically generate a uuid for each piece of virtual property someone has?
13:41:12 <ReinH> isomorphic isn't an overloaded term except when people use it incorrectly as they do here
13:41:14 <johnw> ReinH: people should not be allowed to coopt terminology by law
13:41:15 <Jinxit> it's just an identifier
13:41:24 <Jinxit> "minion 2 attacked minion 5"
13:41:28 <ReinH> otherwise, in Haskell, isomorphism is a very useful term that means isomorphism.
13:41:53 <Gurkenglas> Jinxit, would you trust the client to send the correct data?
13:42:16 <Jinxit> nope, but only receiving the IDs and verifying those is simpler than receiving the new state and verifying that
13:42:39 <Jinxit> and it would be pointless to send the entire thing since it has to be done serverside anyways
13:43:05 <Gurkenglas> Simpler loses some of its meaning when everything can be derived automatically
13:43:19 <Jinxit> pointless then
13:43:24 <Jinxit> why send stuff I will disregard?
13:43:30 * hackagebot numeric-ranges 0.1.0.0 - A framework for numeric ranges.  https://hackage.haskell.org/package/numeric-ranges-0.1.0.0 (NicolasDelPiano)
13:43:37 <Gurkenglas> And checking that everything the user can see is equal to the server's copy of that takes negligible extra time
13:43:50 <Gurkenglas> If you don't disregard it, you need no UUID
13:44:23 <Jinxit> so you would let the client send you a new state, and then verify that it was a correct transition?
13:44:39 <Gurkenglas> More like let them send you the transition, but yes
13:44:59 <Jinxit> and how would you represent an attack transition?
13:45:30 <Jinxit> because I would do it as "Attack uuid uuid"
13:46:24 <Gurkenglas> Whereas I would do it as "Attack <JSON string of minion1> <JSON string of minion2>" or with Read/Show
13:46:47 <Jinxit> and then I would have to, on the server, find the minion that matches the entire thing
13:46:48 <Gurkenglas> (Or more like "<JSON string of (Attack minion1 minion2)>"
13:46:56 <Jinxit> or I could just search for the uuid
13:47:17 <Gurkenglas> Both are a lookup of one operator in terms of code length
13:47:34 <Jinxit> of course
13:48:00 <Jinxit> but there are a ton of state changes in hearthstone, keeping track of minions by value gets out of hand fast
13:48:34 <Gurkenglas> What is there to get out of hand? There's nothing that a human couldn't verify, and therefore a computer can do all of it in the sort of time that optimizing for is madness
13:48:52 <Jinxit> a single turn might summon 5 minions, destroy 3, and have 5 attacks + 3 spells
13:49:08 <Gurkenglas> Right, and a computer could handle hundred times that no problem
13:49:20 <koala_man> when are you supposed to use cabal and when are you supposed to use runhaskell Setup.hs ?
13:49:28 <Jinxit> not out of hand in terms of CPU time
13:49:51 <ReinH> koala_man: always the former, unless you have a specific reason for doing the latter, in which case you would know that you need to do the latter.
13:49:53 <zachk> use cabal most of the time, modify setup.hs when you have very bad  build issues, rarely use setup.hs
13:50:57 <Jinxit> just that a single action might lead to 10 state changes, and sending the entire thing just feels needlessly complicated
13:51:04 <koala_man> ReinH: ok. I have a Setup.hs with a presdist hook that only runs when I do runhaskell Setup.hs. why is that?
13:51:55 <Gurkenglas> That's like saying that the laws of physics are needlessly complicated for postulating more than one planet in the universe; it's about code length, not resulting numbers
13:52:35 <Jinxit> and I doubt you get a shorter code length by sending the entire thing
13:53:23 <ReinH> koala_man: change build-type: Simple to build-type: Custom
13:54:45 <aweinstock> if the UUID is part of the minion, you can just get the UUID out of the minion to look it up in the server state without worrying about trusting the rest of the minion data from the client
13:55:37 <aweinstock> (and it's probably a good habit to not trust the client/assume the client input is actively malicious and trying to corrupt server state)
13:55:56 <aweinstock> (w.r.t. error handling/verification)
13:56:06 <Jinxit> both me and Gurkenglas agree on that, I think
13:56:16 <Jinxit> just that he wants to search for the entire Minion instead of the UUID
13:56:17 <Gurkenglas> Jinxit, by the way, in the definition of Game, if you replace turn :: Int by turns :: [Player], you could initialize it with cycle [p1, p2] instead of doing modular arithmetic and handle multiplayer games with players being eliminated and stuff like extra turn cards no problem
13:56:59 <Jinxit> but then the p1 and p2 lenses don't work
13:57:02 <koala_man> ReinH: ah, so simple. thanks!
13:57:07 <Jinxit> I know turn can be a sum type
13:57:11 <Jinxit> or should be, rather
13:57:20 <aweinstock> not search by minion, just send entire minion from the client, rather than just UUID
13:57:48 <aweinstock> (since it's barely any more code/runtime to do so, and lets you do a sanity check against legitimate client bugs)
13:58:15 <Jinxit> ..and then you find the corresponding minion in the server's Game, no?
14:00:54 <aweinstock> something like (\input serverGameState -> do { untrustedMinion <- someAccessor <$> deserializeGameState input; trustedMinion <- lookupMinionByUUID serverGameState (getUUID untrustedMinion); verifyEquality untrustedMinion trustedMinion})
14:01:38 <Jinxit> I mean sure that would let you find bugs and/or cheaters
14:03:29 <Jinxit> or I could just "canAttack incomingUuid1 incomingUuid2" and if it's false then either do nothing or kick them out
14:04:31 <aweinstock> you still need to do the canAttack check, the verifyEquality only checks that minion's other attributes are correct client-side
14:05:13 <ReinH> koala_man: it isn't well documented :/
14:05:39 <aweinstock> (of course, you could just verify & log mismatches on the entire deserialized state and the server's copy as soon as the input is received, to catch any synching errors)
14:05:53 <Gurkenglas> Right, (turns :: [Lens' Game Player]) = cycle [p1, p2], then. (Or was there a problem with storing lenses in data structures? You could replace p1 and p2 by players :: M.Map Int Player and make it turns :: [Int].)
14:06:43 <Gurkenglas> (I didn't intend for the name clash initially, but of course you have to store the lenses, not the players, since the Players change over the course of a game)
14:07:25 <Jinxit> Gurkenglas: I use them like playMinionCard (p1.hand.ix 0) 0
14:08:09 <Jinxit> which is pretty handy in tests
14:08:22 <zachk> is this a multiuser networked card game in haskell? 
14:08:35 <Jinxit> only networked in theory :)
14:09:38 <Gurkenglas> Yes and if [Lens' Game Player] works you could do "p <- zoom turns $ state $ fromJustNote "Out of turns" . uncons" and later "playMinionCard (p.hand.ix 0) 0"
14:10:31 <Gurkenglas> (Or use an infinite stream type instead of [] for turns if you don't like fromJustNote)
14:10:44 <Jinxit> yes, I could exchange the simple code for more complex code
14:11:17 <suppi> youtube messed up my video :O https://www.youtube.com/watch?v=scmHayBvdHw
14:11:30 <suppi> why are the lines disappearing
14:12:04 <Jinxit> suppi: low resolution
14:12:10 <Jinxit> with thin lines
14:12:37 <suppi> it doesn't look like that in my video :\
14:15:55 <Jinxit> (oh and afaik you have to store ALens' Game Player and then run cloneLens before using them as a Lens', Gurkenglas, but that's not as important)
14:16:49 <suppi> Jinxit, I'm using that approach in the thing in the video
14:17:07 <suppi> Jinxit, but am unsure about using typeclasses for the "HasSomething" thing
14:18:12 <Jinxit> in my case it's useful for things like finding the owner of anything that has an UUID
14:18:18 <Jinxit> then I can use that on cards, players and minions
14:18:26 <Jinxit> or heroes
14:19:45 <Jinxit> as well as IsCharacter which is only short for HasUuid, HasHealth, HasAttack etc
14:20:03 <Jinxit> but if you don't have several game objects with shared properties it's not very useful
14:20:31 -linux-lover(~linuxlove@138.128.180.138)- Now listen here yall bunch of freaks and geeks and nerds Theres a new channel called #pltclub its for programming Language theories so join up
14:20:55 <Excedrin> thanks for the notice
14:21:10 <suppi> nice ...
14:22:21 <Lokathor> so i've got a type that depends on bit-width
14:22:41 <Lokathor> there's a PCGen32 and PCGen64. I'd like a type that picks one or the other depending on the machine's size
14:22:52 <Lokathor> i take it this is CPP territory?
14:23:05 <mauke> could probably be done with TH
14:23:19 <Lokathor> hmm, how would that work?
14:23:21 <mniip> or you could intersperse your code with Word# and Int#
14:23:48 <Lokathor> I'm looking for a setup where there's PCGen32, PCGen64, and PCGen; similar to how there's Int32, Int64, and Int
14:23:52 <mauke> use TH to emit 'type PCGenX = ...'
14:24:00 <mauke> where ... depends on your word size
14:24:43 <Lokathor> mniip, i'm not sure that Word# is quite suited to this case
14:24:54 <mniip> I wasn't quite serious about that
14:24:58 <Lokathor> oh
14:24:59 <mauke> > (maxBound :: Int) == 0x7ffffff
14:25:01 <lambdabot>  False
14:25:06 <mauke> > maxBound :: Int
14:25:07 <lambdabot>  9223372036854775807
14:25:14 <Lokathor> mauke, is there perhaps a starter's guide on Template Haskell?
14:25:16 <mauke> well, that's an easy ad-hoc check
14:26:02 <mauke> https://wiki.haskell.org/Template_Haskell no idea if it's any good
14:26:10 <Lokathor> https://github.com/Lokathor/haskellstuff-code/blob/master/src/Data/PCGen.hs this is what i have so far. As you can see, the 32-bit and 640bit versions actually hold rather different values inside of them
14:26:25 <maerwald> I found most pages on wiki.haskell.org confusing instead of helpful
14:26:30 <Lokathor> same
14:26:57 <Lokathor> too many cooks, also too many of them aren't targeting a beginner's audience often enough
14:28:01 <mauke> Lokathor: type PCGen = $( if fromIntegral (maxBound :: Int) == fromIntegral (maxBound :: Int32) then [t| PCGen32 |] else [t| PCGen64 |] )
14:28:04 <Lokathor> so i wanted an Int -> PCGen and a "type PCGen = ...", both of which would use the CPP to pick the right definition depending on archetecture
14:28:05 <mauke> I *think* that's how it works
14:28:39 <mniip> why not just use ''PCGen32
14:28:41 <mniip> or was it '
14:29:13 <Lokathor> mniip, what do the '' indicate?
14:29:21 <mniip> it's a TH thing
14:29:51 <Lokathor> ah. I'm going to cook tater tots and then get back this subject in a bit
14:29:54 <Lokathor> but this has been helpful\
14:30:08 <mauke> mniip: manual says ''foo has type Name
14:30:22 <mauke> [t| ... |] is a Q Type
14:30:23 <mniip> ah yes
14:30:25 <mniip> sorry
14:30:36 * mniip hides
14:33:46 * hackagebot zeromq4-haskell 0.6.4 - Bindings to ZeroMQ 4.x  https://hackage.haskell.org/package/zeromq4-haskell-0.6.4 (ToralfWittner)
14:33:48 * hackagebot wavefront 0.6 - Wavefront OBJ loader  https://hackage.haskell.org/package/wavefront-0.6 (DimitriSabadie)
14:42:12 <t7> @haskell m a -> Int -> [a]
14:42:12 <lambdabot> http://www.haskellers.com/
14:42:18 <t7> @hoogle m a -> Int -> [a]
14:42:19 <lambdabot> Prelude drop :: Int -> [a] -> [a]
14:42:19 <lambdabot> Data.List drop :: Int -> [a] -> [a]
14:42:19 <lambdabot> Prelude take :: Int -> [a] -> [a]
14:42:42 <t7> @hoogle Int -> m a -> m [a]
14:42:43 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
14:42:43 <lambdabot> Test.QuickCheck.Gen vectorOf :: Int -> Gen a -> Gen [a]
14:42:43 <lambdabot> Test.QuickCheck vectorOf :: Int -> Gen a -> Gen [a]
14:48:35 <t7> "pl (\t lv -> (t, (Move, Set.singleton lv)))
14:48:38 <t7> @pl (\t lv -> (t, (Move, Set.singleton lv)))
14:48:38 <lambdabot> (. ((,) Move . Set.singleton)) . (,)
14:48:43 <t7> gross
14:54:22 <ReinH> t7: please msg lambdabot to test things
15:02:56 <hunteriam> are all functors foldable?
15:03:10 <Fuco> check the foldable definition :P
15:03:13 <hunteriam> if not, I don't understand why we have a function called foldFree for free monads
15:03:20 <net4all> I just got started with haskell, trying to implement show for a custom type and I'm stuck.
15:03:23 <net4all> http://lpaste.net/148497
15:03:39 <net4all> Feeling like I am missing something very obvious
15:03:47 * hackagebot cql-io 0.15.2 - Cassandra CQL client.  https://hackage.haskell.org/package/cql-io-0.15.2 (ToralfWittner)
15:04:03 <ianhedoesit> net4all: what if n isn't an instance of Show?
15:04:20 <hunteriam> Fuco: theyre Monoids but not necesarrily functors?
15:04:23 <kadoban> net4all: instance Show n => Show (Vector n) where …
15:05:13 <Fuco> hunteriam: are you asking about the 't' in "Class Foldable t where" ?
15:05:26 <Fuco> because the monoid is the "inside" of the functor
15:05:28 <hunteriam> sure
15:05:31 <Fuco> well, the type
15:05:37 <Fuco> we don't know if it is a functor yet :P
15:05:42 <ReinH> hunteriam: no, not all Functors are Foldable.
15:05:45 <net4all> ianhedoesit: kadoban: thx
15:05:50 <net4all> ianhedoesit++
15:06:26 <hunteriam> ReinH: can you explain why we use "fold" in the function foldFree for free monads?
15:06:41 <hunteriam> ReinH: it looks like a fold on the functor since youre unwrapping it, but how do you know you can fold it?
15:07:28 <ReinH> Look again. What parameters does it take and what type does it return?
15:08:05 <ReinH> Specifically, what is m?
15:08:53 <ReinH> It is a fold, but it does not operate on the level that Foldable does.
15:09:04 <hunteriam> Functor f => (f r -> r) -> Free f r -> r
15:09:15 <hunteriam> It appears to be extracting r from f r
15:09:19 <ReinH> What? No. Where did you get that from?
15:09:20 <hunteriam> which is similar to a fold
15:09:25 <hunteriam> http://stackoverflow.com/questions/13352205/what-are-free-monads
15:09:51 <ReinH> Ok, that's a different foldFree from the one in the free package
15:10:11 <ReinH> It says: *given a folding function f r -> r*, you can apply it to a Free f r to get an r.
15:10:21 <ReinH> You supply the fold.
15:10:26 <hunteriam> Alright
15:13:35 <Fuco> ReinH: what would be an example of a functor which isn't foldable?
15:14:39 <ReinH> Anything Foldable which uses its parameter in negatiev position, e.g. data Foo a = Foo a (a -> a) with instance Foldable Foo where foldMap f (Foo a g) = f (g a)
15:14:44 <ReinH> *negative
15:15:06 <StoneToad> um, isnt' that a foldable that's not a functor?
15:15:17 <ReinH> Oh. Yes.
15:15:43 <c_wraith> the function functor isn't foldable 
15:15:57 <c_wraith> it contains no values to extract 
15:17:04 <ReinH> IO is also not Foldable, but perhaps not as satisfying an answer as ((->) r)
15:17:37 <shachaf> (r ->) can be Foldable when r is, I don't know, enumerable?
15:17:54 <shachaf> But of course Foldable has no laws, so every functor can be Foldable.
15:17:59 <ReinH> heh
15:18:01 <shachaf> foldMap _ _ = mempty
15:18:41 <StoneToad> you'll get a lot of nasty bug reports if you post a library with that instance to hackage I expect though
15:19:19 <c_wraith> is Proxy Foldable with that instance? 
15:19:38 <shachaf> Yes, justifiably so.
15:19:52 <c_wraith> err. I mean does it have that instance already 
15:20:09 <c_wraith> and yes, it's very easy to justify 
15:20:29 <shachaf> Yes.
15:20:59 <c_wraith> since it's consistent with Traversable for Proxy. :) 
15:33:48 * hackagebot redis-io 0.5.2 - Yet another redis client.  https://hackage.haskell.org/package/redis-io-0.5.2 (ToralfWittner)
15:44:12 <repodev> hellp
15:44:17 <repodev> hello
15:44:34 <kaiyin> Is there anything like this in any libs? https://mail.haskell.org/pipermail/haskell/2005-March/015517.html
15:44:39 <c_wraith> Oh, I thought that was a request for assistance. hi! 
15:50:03 <kaiyin> nevermind, i found something:               infinity = (read "Infinity") :: Double
15:50:23 <kaiyin> why am i getting this error?
15:50:40 <ReinH> What error?
15:50:45 <kaiyin> https://gist.github.com/kindlychung/a6d021f5fbc7558c3ff6
15:50:47 <kaiyin> sorry. 
15:51:10 <ReinH> your if statement is invalid
15:51:12 <ReinH> there is no "then"
15:51:44 <ReinH> it also appears taht your indentation on like 9 is invalid
15:51:53 <ReinH> It also appears that your where on line 12 is invalid
15:51:58 <ReinH> s/like/line
15:52:25 <ReinH> I'm not sure how you managed to get this far with this many syntax errors, but you should check with the compiler more frequently
15:52:48 <ReinH> also the do on line 6 is unnecessary and makes no sense
15:53:04 <ReinH> also filter takes a predicate, not a list
15:53:11 <ReinH> basically nearly everything you have written is wrong
15:53:13 <ReinH> somehow
15:53:32 <ReinH> I would recommend scrapping it and starting over, checking with the compiler frequently to make sure you are writing something sensible
15:53:49 * hackagebot shake-persist 0.1.0.0 - Shake build system on-disk caching  https://hackage.haskell.org/package/shake-persist-0.1.0.0 (KAction)
15:54:06 <ReinH> Also you should use explicit type annotations
15:54:17 <ReinH> They will help you write sensible functions
15:55:49 <ReinH> I also don't understand why you are using a list of three elements instead of a tuple, fst and snd instead of pattern matching, or infinity instead of a Maybe
16:01:07 <Lokathor> is there a name for (<*>) that i should use when talking about it?
16:01:15 <Lokathor> i've heard "apply" and i've heard "TIE"
16:01:19 <kadoban> Lokathor: ap
16:01:38 <kadoban> :t ap
16:01:39 <lambdabot> Monad m => m (a -> b) -> m a -> m b
16:02:53 <Lokathor> so even though ap is technically for monad it's cool to call it ap?
16:03:00 <ReinH> Yes.
16:03:19 <ReinH> That type signature for ap is only a historical accident
16:03:30 <ReinH> Properly it only requires an Applicative constraint.
16:09:16 <kaiyin> ReinH: thanks. :)  finally got it to work: https://gist.github.com/
16:09:38 <ReinH> Er.
16:09:43 <Gurkenglas> There should be a class instead of (Enum a, Bounded a) that says "'fold :: Monoid m => (a -> m) -> m' makes sense for a"
16:09:57 <kaiyin> ReinH: ah, there https://gist.github.com/kindlychung/a52f766f781b217e0ab8
16:09:58 <ReinH> :t foldMap
16:09:59 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
16:10:06 <ReinH> Gurkenglas: so you want something else?
16:10:22 <ReinH> That fold definition can only be satisfied by fold _ = mempty
16:10:32 <ReinH> (or fold = undefined)
16:10:43 <ReinH> s/definition/type
16:11:08 <ReinH> Ah, you mean with the additional info provided by the typeclass for a
16:11:19 <Gurkenglas> yep
16:11:49 <Gurkenglas> For the same reason that [] isn't the free monoid
16:12:03 <ReinH> How is it the same reason?
16:13:16 <Gurkenglas> "instance (Enum a, Bounded a) => Foldable ((->) a)" would mean that finite types are foldable - but actually all types that can be arranged on a free monoid are foldable
16:16:04 <Gurkenglas> ((->) Natural) should be Foldable, because folding across the infinite naturals makes sense, but writing the instance from start of last line would make this one impossible, so there should be a class for it, and it sounds better than (Enum a, Bounded a) anyway
16:18:51 <return> How should I do a conditional print? if test a then print "Yup" else return ()
16:20:20 <koala_man> return: when True $ print "Yup"
16:21:32 <Gurkenglas> Hmm, what should the name of the class for "its elements can be arranged on a free monoid" be?
16:22:30 <return> koala_man: thanks
16:24:56 <ReinH> kadoban: I'd use Maybe Double with Nothing instead of infinity
16:25:05 <ReinH> Infinity isn't an easy value to work with
16:26:33 <ReinH> @hoogle minimumBy
16:26:33 <lambdabot> Data.List minimumBy :: (a -> a -> Ordering) -> [a] -> a
16:26:34 <lambdabot> Data.Foldable minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
16:26:47 <ReinH> kadoban: sorry
16:27:03 <kadoban> No worries
16:29:57 <lamefun> How to export associated data?
16:30:18 <lamefun> (ie. implementations of 'class XYZ a where; data Data a')?
16:31:46 <Gurkenglas> Maybe it shouldn't have a name? But then a library I write for it would just have a lot of orphan instances of the form "instance Foldable ((->) Bool) where foldMap atom btoa = foldMap (atom.btoa) [False..True]"...
16:32:31 <ReinH> Why not just write a function foldBounded :: (Enum a, Bounded a, Monoid m) => (a -> m) -> m?
16:32:35 <ReinH> Why do you need a typeclass?
16:34:10 <Gurkenglas> Because I don't like that so many functions are restricted to working on (Enum a, Bounded a) when more would make sense
16:34:37 <ReinH> What else would make sense?
16:34:48 <Gurkenglas> Natural, for example.
16:35:35 <pavonia> lamefun: module Foo (Data (..))
16:37:46 <ReinH> Gurkenglas: how would Natural make sense?
16:38:27 <ReinH> Hmm, I suppose for some Monoids it makes sense
16:38:33 <ReinH> but then all you need is Enum
16:39:03 <Gurkenglas> foldMap atom ntoa = foldMap (atom . ntoa) [0..]
16:43:46 <Gurkenglas> Enum is not enough. Consider http://sketchtoy.com/66423737 - No Enum instance agrees with the Ord obtained by projecting to the x coordinate, and for some monoids, foldMap makes sense
16:58:44 <zachk> > fmap (drop 1) . break (==':') $ "Look:I:Split:Only:Once"
16:58:46 <lambdabot>  ("Look","I:Split:Only:Once")
17:01:10 <Gurkenglas> Data.List.Split should just have another module copying all it does into onlyonce stuff
17:01:53 <Gurkenglas> Factoring out the unfoldr, as it were
17:02:35 <clm> hi good evening
17:03:19 <clm> had a quick question, maybe silly.. while trying to understand arrows and comparing to monads..
17:03:26 <benzrf> clm: don't bother
17:03:28 <benzrf> nobody uses arrows
17:03:33 <benzrf> they're the red headed stepchild of haskell
17:03:35 <zachk> good evening 
17:03:51 * hackagebot not-gloss 0.7.6.2 - Painless 3D graphics, no affiliation with gloss  https://hackage.haskell.org/package/not-gloss-0.7.6.2 (GregHorn)
17:03:54 <clm> what is the relation between Arr u v and Monad (a->v) ?if such thing exists
17:04:02 <zachk> clm, have you tried Control.Category?  
17:04:37 <zachk> you mean a -> m v ? 
17:05:30 <benzrf> clm: a -> v cannot be a monad
17:05:33 <benzrf> it's not the right kind
17:05:36 <zachk> because I don't even think you can make a Monad of (a->v) because it's kind is * 
17:05:52 <clm> no i really meant m (a->v) is it possible? I can have a list of functions for ex no?\
17:05:52 <zachk> where things like Just and IO are *->* 
17:06:28 <zachk> like: [(+1),(*3),(+44)] ? 
17:06:41 <clm> yes
17:06:45 <zachk> how come no one uses arrows?
17:06:49 <zachk> yea that is fine 
17:07:01 <zachk> :t (<*>) 
17:07:02 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:07:22 <zachk> all Monads are applicative, so you could use it like that 
17:08:08 <zachk> > [(+1),id,(*5),(+44)] <*> [1..5] 
17:08:10 <lambdabot>  [2,3,4,5,6,1,2,3,4,5,5,10,15,20,25,45,46,47,48,49]
17:08:33 <zachk> > length $ [(+1),id,(*5),(+44)] <*> [1..5] 
17:08:35 <lambdabot>  20
17:09:29 <kadoban> If I use blaze-html to build up some Html … can I inspect the Html tree itself, like say I have an Html and I want to inspect the children of the element that's at the top … that's not really possible, huh?
17:09:30 <clm> let me stepback perhaps: i was giving this statement to a colleague. a monad is a special kind of arrow where instead of abstracting computations on functions a -> v we do so on values v (which could be considered as function from nothing to v) does it make sense?
17:09:42 <ReinH> clm: No.
17:10:11 <ReinH> That doesn't make sense as a characterization of monads.
17:10:48 <ReinH> The closest thing to a characterization of monads as arrows (not Arrows) might be
17:10:50 <clm> and in the other way as an intuitive definition of arrow from the monad?
17:10:55 <ReinH> :t (=<<)
17:10:57 <lambdabot> Monad m => (a -> m b) -> m a -> m b
17:11:02 <exio4> @type (<=<) 
17:11:03 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
17:11:05 <exio4> @type return
17:11:05 <ReinH> is a particular sort of generalization of ($)
17:11:06 <lambdabot> Monad m => a -> m a
17:11:07 <exio4> forms a category 
17:11:14 <exio4> another definition 
17:11:19 <zachk> :t (>>>) 
17:11:20 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
17:11:27 <exio4> that's too polymorphic :p
17:12:01 <zachk> what's BOX? 
17:12:38 <ReinH> clm: you might get something from http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
17:13:15 <ReinH> it's an explanation of the relationship between applicative, arrow, and monad
17:14:05 <ReinH> Categorically speaking, Monads are monoids in the category of endofunctors. Arrows are monoids in the category of profunctors.
17:14:12 <clm> thanks ReinH will take a look.
17:14:34 <clm> what is a profunctor?
17:14:51 <ReinH> If you don't know those terms, don't worry about it.
17:15:21 <clm> think i know all the others except this one
17:15:25 <ReinH> The TL;DR is that applicatives embed into arrows and arrows embed into monads, but neither in a trivial way.
17:15:26 * clm googling
17:15:31 <exio4> zachk: BOX is basically "kind" there :P 
17:16:26 <ReinH> clm: another relationship is that monads are exactly equivalent to Arrows that are also instances of ArrowApply, as witnessed by the types Kleisli and ArrowMonad
17:18:40 <ReinH> more intuitively, an Arrow is a Category equipped with some additional structure for working with products.
17:18:52 * hackagebot web-routes-wai 0.24.3 - Library for maintaining correctness of URLs within an application.  https://hackage.haskell.org/package/web-routes-wai-0.24.3 (JeremyShaw)
17:19:14 <ReinH> as exio4 mentioned, every monad gives rise to a Kleisli Category and this construction gives you the instances of ArrowApply.
17:20:59 <clm> ReinH. I think your explanation with endofunctor -> profunctor, matches what i was trying to express when i was comparing values and functions. 
17:21:13 <clm> but in a very clumsy way.
17:21:25 <ReinH> clm: One way to look at it is that Functor/Applicative/Monad are generalizations of objects, while Category/Arrow are generalizations of morphisms.
17:22:03 <clm> yes that makes perfect sense. except i called object values and morphisms functions
17:22:05 <ianhedoesit> this might be a silly question, but I'm slightly confused by one aspect of Haskell, currently. Is _everything_ a function? with a definition like `foo :: Int foo = 5", is foo a function that takes no arguments and returns 5? I thought every function took one argument and returned a function or a value
17:22:10 <ReinH> clm: ok :)
17:22:41 <ReinH> ianhedoesit: It depends on your definition of function, but the one I prefer is:
17:22:46 <ReinH> a function is a value of type a -> b for some a and b
17:22:56 <ianhedoesit> right, I agree so far.
17:23:06 <ReinH> So in that sense, no, not every value is a function.
17:23:27 <ianhedoesit> so then `foo` is just defined to be 5, not a function that returns 5?
17:23:54 <ReinH> ianhedoesit: This is important because some people are fond of using "5 is a nullary function' and "getLine :: IO String is a function that returns a string" as if they were similar statements.
17:24:11 <ReinH>  And this equivocation is very confusing and frustrating
17:24:29 <ReinH> Under my definition, the situation is simple:
17:24:36 <ReinH> 5 is not a function, and neither is getLine
17:24:56 <ReinH> I should say 5 :: Int is not a function.
17:25:13 <ianhedoesit> right
17:25:33 <ReinH> ianhedoesit: Conal talks about this a bit more here: http://conal.net/blog/posts/everything-is-a-function-in-haskell
17:25:49 <ReinH> ianhedoesit: in algebra it's sometimes useful to consider elements to be nullary operations
17:26:12 <ReinH> it's consistent to do so in Haskell (as long as you use the definition of function consistently), but I would argue that it is not useful.
17:26:18 <clm> thanks ReinH and ZachK for your help. au revoir.
17:26:25 <ianhedoesit> so would you say getLine is a value (and the value is hGetLine stdin)?
17:26:53 <athan> Anyone here use GPipe often? I'm wondering how I could work-out v-syncing or a variable FPS rate. I was thinking about making an async thread to call `swapContextBuffers`, but I'm not sure what's going on.
17:26:55 <ReinH> ianhedoesit: well, every expression represents a value
17:27:07 <ReinH> functions are also values
17:27:24 <ReinH> (every function is a value, but not all values are functions is the distinction I am making)
17:27:25 <ianhedoesit> right, and I know that it's confusing for me to use those terms which is why I was asking
17:27:34 <ianhedoesit> hm, okay.
17:27:53 <ReinH> If every value were a function then we wouldn't need the term function any more
17:28:13 <ianhedoesit> but - and of course it depends on who I talk to - in the case of foo :: Int, foo could be described as a value?
17:28:16 <ReinH> The connotation of a function is "a thing that can be applied to a value"
17:28:20 <ReinH> it's nice when its denotation agrees
17:29:08 <ianhedoesit> (I mean, calling it a value isn't very useful but I don't know what else I would call it)
17:29:35 <Gurkenglas> byorgey, can you add a module to split that factors chop out of all the splitting functions?
17:29:37 <ReinH> Yes. Sometimes it's clear from context that you mean "a value that is not a function", and sometimes people will be more specific.
17:29:54 <conal> ianhedoesit: you could call it "an Int" if you want to say something more specific than "a function".
17:29:54 <ianhedoesit> I guess I'm asking, if I have a constant variable foo which is 5, I would call it a constant (or a constant variable), but I don't know how to translate that to Haskellese.
17:30:14 <ianhedoesit> conal: I suppose that would be true.
17:30:21 <zachk> foo = (5::Int) ? 
17:30:22 <conal> ianhedoesit: every value in haskell is constant, so calling something "a constant" isn't saying anything.
17:30:28 <ReinH> conal: o/
17:30:41 <ianhedoesit> conal: right, which is why I wasn't sure what I would say :)
17:30:51 <ReinH> ianhedoesit: just say "a value" and let god sort it out
17:31:01 <conal> ianhedoesit: in what context (or for what purpose) are you looking for a word?
17:31:06 <ReinH> if it isn't clear from context, context will also provide a way to clarify
17:31:21 <ianhedoesit> lol
17:31:27 <conal> ReinH: \o
17:32:06 <ianhedoesit> conal: I don't actually know - I was just thinking more about what f :: Int -> Int means compared to f' :: Int
17:32:56 <conal> ianhedoesit: ah. they both state types: f is a function from Int to Int, and f' is an Int.
17:33:00 <zachk> I always though of getLine as a function, though 
17:33:03 <ianhedoesit> right
17:33:05 <zachk> thought
17:33:12 <puregreen> ianhedoesit: just curious: does “constant” mean for you “something that doesn't have to be evaluated”? like, something like “foo = factorial 100” doesn't feel like a constant, but “foo = 5+5” is more constant-ish?
17:33:12 <ReinH> ianhedoesit: f is a value and a function, f' is a value but not a function.
17:33:43 <ReinH> zachk: well, you should stop doing that.
17:33:55 <ReinH> you can't apply getLine to anything.
17:35:03 <ianhedoesit> I understand the difference between Int and Int -> Int - I understand type signatures, I was actually reading lecture notes and it mentions that f x y z = ... is sugar for f = (\x -> (\y -> (\z -> ...) - this lead me to think "what if I have f' :: Int? is f' = 5 sugar for something like f = (\_ -> 5)?"
17:35:24 <ianhedoesit> (obviously it isn't, because that would be a function like f' :: a -> Int)
17:36:02 <ReinH> ianhedoesit: no, it is not.
17:36:19 <hi_there> Hi, I have a question. Why can "foo a = bar b a" be generaly written as "foo = bar b"?
17:36:19 <ianhedoesit> what is not
17:36:29 <ReinH> ianhedoesit: f = 5 is not sugar for anything else
17:36:43 <ianhedoesit> oh, right, I figured as much but wanted to check here
17:36:52 <ReinH> hi_there: because the rules of Haskell evaluation allow it. It is known as "eta reduction".
17:36:58 <ianhedoesit> I didn't know where to look to answer that question
17:37:43 <ReinH> hi_there: specifically: foo a = bar b a ==> foo = \a -> bar b a ==> foo = bar a
17:38:12 <ReinH> hi_there: the first step is due to f a = b == f = \a -> b
17:38:16 <ReinH> the second step is the eta reduction
17:39:48 <hi_there> ReinH: Okay, thank you!
17:40:13 <ReinH> hi_there: np
17:42:02 <ReinH> puregreen: ofc this distinction becomes even less meaningless with constant folding optimizations
17:42:14 <ReinH> even less meaningful or even more meaningless.
17:42:34 <ReinH> both of which look strange now.
17:43:16 <puregreen> ReinH: it's just that I have a pet theory that the “constant function” concept came from imperative languages where there's a difference between “const foo = 3” and “foo() {return 3;}”
17:43:29 <puregreen> the former feels like a declaration and the latter feels like an actual thing-that-is-executed
17:44:22 <ReinH> puregreen: there's another algebraic interpretation
17:44:22 <ianhedoesit> puregreen: I didn't mean to ignore you, I just didn't know how to respond. If I think about it, they are (at first sight) equally constant in that their results can be (should be/are/whatever) determined at compile-time.
17:44:35 <ReinH> puregreen: but I see what you mean
17:45:35 <ReinH> puregreen: e.g. a constant is a nullary operation is a function f : X^0 -> X for some X
17:45:37 <ianhedoesit> puregreen: but I more meant that `const f = 5` and `var f' = 5` are not the same because f' is mutable.
17:45:49 <ReinH> s/function/operation
17:46:35 <ReinH> which by extension gives a consistent definition of n-ary operators for all n \in N, including 0
17:47:49 <dedgrant> ianhedoesit: I got tripped up by the value/function distinction when learning Haskell as well. The similarity in syntax, and functions as values, makes it very tempting to assume that values are functions. ;)  But there are no nullary (0-parameter functions) in Haskell.. in fact it is useful to remember that every function in Haskell takes exactly one parameter.
17:49:04 <ianhedoesit> dedgrant: I think I got tripped up in the opposite direction - I knew that all functions in Haskell take exactly one parameter, which is why I couldn't understand how a value such as f :: Int could be a function - there's no way for it to take one parameter (as far as the explicit type goes)
17:49:46 <ReinH> ianhedoesit: the argument goes: Int is isomorphic to () -> Int so wave your hands really fast and f = 5 is a function in the same way that f () = 5 is a function.
17:49:52 <ReinH> It is not a compelling argument, but there it is.
17:50:32 <conal> people often confuse "function" with "definition". neither f=5 nor f () = 5 is a function. they're both definitions.
17:50:39 <ianhedoesit> ReinH: hm, that is the argument for "everything is a function," correct? but it's not true, right? It doesn't make sense to me.
17:50:50 <conal> function is semantics, while definition is syntax.
17:50:51 <ReinH> conal: good point. I mean f in f = 5 and f in f () = 5, respectively.
17:51:12 <ReinH> ianhedoesit: yes, I don't think it's a good argument.
17:51:16 <ianhedoesit> conal: right, and I continue to actively catch myself using the wrong terminology, but I simply don't know the correct terminology.
17:51:18 <ReinH> But you might hear it from time to time.
17:51:25 <bitemyapp> ReinH: if you wave your hands fast enough you can fly
17:51:32 <ReinH> bitemyapp: indeed.
17:51:36 <bitemyapp> ReinH: but the energy density required isn't possible for humans :(
17:51:42 <ReinH> shame really
17:51:56 <ReinH> Wait is that actually true? I have a doubt.
17:52:01 <ianhedoesit> ReinH: I don't think so either - however my experience with OCaml also makes that distinction a bit confusing.
17:52:05 <conal> ianhedoesit: i'm glad you're inquiring! a lot of confusion can be cleared up by using terminology carefully.
17:52:06 <ReinH> (that it's theoretically possible at all)
17:52:22 <ReinH> ianhedoesit: It's even less compelling in an eager language.
17:52:33 <zachk> if you wave your hands fast, I mean really fast, you could sever your wrists, instanenously and have your hands go flying off and have blood squirting everywhere 
17:52:58 <MarcelineVQ> zachk: that sounds dangerous, ban hands
17:53:01 <zachk> is ocaml even worth looking into if one is into haskell? 
17:53:45 <ReinH> zachk: yes, ML as a family of languages has some interesting features that Haskell lacks.
17:53:54 <ReinH> Modules, mostly.
17:54:10 <ReinH> I mean, I still prefer Haskell.
17:54:29 <Spaceghost> What is ML?
17:54:57 <ReinH> The langauge ocaml is a derivative of https://en.wikipedia.org/wiki/ML_(programming_language)
17:55:46 <ReinH> which is interesting because it was originally designed as a Meta Language for the LCF theorem prover, to be used to develop proof tactics.
17:55:56 <ReinH> but now people are perversely using it for real world problems
17:56:19 <ianhedoesit> conal: I appreciate the blog post that ReinH linked me to (I'm assuming you're the same conal). I have no formal education and have been consuming information about functional programming from free resources.
17:56:32 <ReinH> ianhedoesit: same.
17:56:44 <ianhedoesit> it can, at times, make understanding some things very difficult in Haskell (especially when a bunch of logical or mathematical symbols join the party)
17:57:35 <conal> ianhedoesit: wonderful! i hope you keep asking questions whenever something isn't clear to you (even if others seem satisfied).
17:58:15 <ianhedoesit> ReinH: I asked somebody else this question recently (I believe it was Cale) - how did you get involved with Haskell? How long have you been using it, what did you do before, stuff like that
17:58:18 <dedgrant> bitemyapp: Never give up hope! https://www.youtube.com/watch?v=iMhdksPFhCM&feature=youtu.be&t=38s
17:59:51 <ianhedoesit> conal: :) thank you for being so kind. It's very encouraging.
18:00:11 <conal> ianhedoesit: :) my pleasure.
18:00:31 <exio4> you should have something like ∀α∈κ.∀β∈κ⇒χ. α(β) ∈ χ in your clipboard
18:03:15 <ianhedoesit> I understand a bit of that now, I think. which is pretty awesome. Some coworkers (I work at a pizza place haha) saw me reading John Backus' essay on functional style programming (http://worrydream.com/refs/Backus-CanProgrammingBeLiberated.pdf) and they were surprised I could make sense of any of the definitions there
18:04:31 <benzrf> exio4: shouldnt that be 𝛽(𝛼)
18:04:44 <benzrf> not 𝛼(𝛽)
18:05:39 <ReinH> ianhedoesit: being kind is sort of conal's thing :)
18:06:07 <ReinH> ianhedoesit: I started Haskell maybe 5 years ago beacuse I wanted to know what this "pure functional programming" thing was about. Before that I was mostly using dynamic langauges and crying.
18:07:28 <zachk> I grew tired of the lack of syntax and the infinite parentheses in Scheme, and wanted something that compiles to decently fast code, and was cross platform 
18:08:17 <ianhedoesit> ReinH: neat. I just recently started really looking at Haskell after taking a MOOC which was about OCaml and really enjoyed it. Before OCaml I did some stuff with Clojure (which I still enjoy). Before that the typical group of languages (C#, Java, Python, etc.) with varying interest. I actually started with PascalScript, a subset of Pascal, about 10 years ago now. I did have several years of not doing
18:08:23 <ianhedoesit>  any programming though.
18:09:41 <lambdanon> Hi #haskell, got a quick question about project structure and importing/exporting modules, I have one folder with source files, I gave each of them a module name and Subname (same as folder) like this: "module A.Source1", then "module "A.Source2", how do I make so that I can now simply "import A" in my mainfile, instead of having to write an import for every single File? I hope I dont sound too confusing.
18:11:33 <mauke> lambdanon: you write a module A.hs that imports/exports everything manually
18:11:56 <ReinH> module A where (module A.Source1) import A.Source1
18:12:03 <ReinH> er
18:12:07 <ReinH> where is in the wrong place
18:12:14 <lambdanon> Ah I see, thank you
18:12:17 <ReinH> I know how to Haskell I swear
18:13:15 <lambdanon> no problem, this is what I thought of at first, but I didn't know what the best practice or norm of handling this is
18:13:28 <exio4> benzrf: shush
18:13:55 <lambdanon> What do I do if several of my modules I'd like to export in "A" have functions with the same name in them?
18:16:34 <lambdanon> Oh it seems importing them qualified solves this
18:16:52 <ianhedoesit> I'm actually still confused about something in Haskell. I don't think I fully understand how Haskell can be purely functional if I have stuff like IO and Random?
18:17:51 <geekosaur> Random is a PRNG; the seed for it may come out of IO, but after that it's just State (which is a way of carrying around a value without having to do so explicitly, more or less)
18:18:01 <geekosaur> IO... there's a trick involved.
18:18:37 <geekosaur> something in IO is not actually an impure value. it is a pure value representing an instruction to the runtime, which itself is allowed both impurity and mutation
18:19:10 <benzrf> ianhedoesit: imagine that an 'IO Foo' is, under the covers, an array of machine instructions
18:19:27 <benzrf> ianhedoesit: then when you use functions to put together your IO stuff, you're shuffling around the instructions to calculate a new program
18:19:38 <benzrf> ianhedoesit: deriving a program, then, doesn't require anything impure
18:19:49 <benzrf> ianhedoesit: but you do need to step outside of haskell to then take that calculated program and execute it
18:20:09 <geekosaur> and (main :: IO a) essentially purely computes and returns to the runtime a program which does the actual impure operations
18:20:34 <ReinH> ianhedoesit: I keep having to answer this question so I copied an answer down from an email recently: https://gist.github.com/reinh/52b90fa33e55f4ca701f
18:20:36 <ReinH> Maybe it will help
18:20:47 <geekosaur> when you use fmap or (>>=) (o do notation which turns into (>>=) you are effectively attaching callbacks to these programs
18:22:03 <ReinH> I originally sent it to the haskell beginners mailing list, but I think it's general enough to be helpful
18:22:40 <ianhedoesit> I think I get confused by things like hGetLine - if I call hGetLine with the parameter stdin, I'm not guaranteed to always get the same value
18:22:58 <ReinH> ianhedoesit: Yes it is
18:23:06 <ReinH> hGetLine stdin is always the same value
18:23:08 <ReinH> every time it is evaluated
18:23:19 <ReinH> ianhedoesit: The thing I linked talks about this specifically
18:23:20 <ianhedoesit> hm, but not when it's executed
18:23:27 <ReinH> ianhedoesit: No one expects execution to be pure
18:23:31 <ReinH> If it were, we couldn't run programs at all
18:23:31 <ianhedoesit> okay, I'll read that :)
18:23:43 <ianhedoesit> ReinH: well, I do. which is why it's confusing to me
18:23:51 <dedgrant> ReinH: That's a wonderful resource
18:23:51 <geekosaur> it evaluates to an instruction to the runtime, the same instruction each time. execution by the runtime is impure (and mutable!)
18:24:01 <ReinH> ianhedoesit: if execution were demanded to be pure then any attempt to run your program would be illegal
18:24:09 <ReinH> since it would change the state of the universe
18:24:26 <geekosaur> this is somewhat necessary because it runs on actual hardware, and things like hardware failure have no place in a pure environment >.>
18:24:31 <ianhedoesit> ReinH: I agree, which is why it is confusing to think of Haskell as a "pure language"
18:24:32 <geekosaur> or out of disk space
18:24:39 <ReinH> ianhedoesit: It is. Evaluation is pure.
18:24:49 * hackagebot sbv 5.9 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-5.9 (LeventErkok)
18:24:49 <ReinH> That is the only claim being made.
18:25:22 <ianhedoesit> right, but the distinction between evaluation and execution being pure or impure isn't explicit in anything I've read.
18:25:50 <ReinH> Then you haven't read the right things, which is why I had to write my thing.
18:26:16 <ianhedoesit> and since I have a reasonable idea of how the program is executed, I know that the execution is impure, but that seems conflicting with claims made about Haskell (although I know it's not)
18:26:27 <ianhedoesit> anyway, back to reading your gist.
18:26:34 <geekosaur> it's a bit like monad tutorials, sadly. there's a lot of stuff out there written by people who *think* they uderstand it, and all they do is muddy the water.
18:27:05 <ianhedoesit> ReinH: oh, hey, we live in the same area.
18:27:13 <ReinH> ianhedoesit: Portland?
18:27:15 <ianhedoesit> mhmm.
18:27:22 <ReinH> you should go to the pdxfunc meetup
18:28:12 <ianhedoesit> I get notifications for it but it's not very likely I can make it with my school and work schedule, last time I checked.
18:28:20 <ReinH> wah wah
18:30:21 <ReinH> ianhedoesit: perhaps one reason that this is confusing is that many langauges do not make such a plain distinction between evaluation and execution
18:30:26 <pothepanda> ReinH, so the state of the universe is affected by executing one program ?
18:30:34 <ReinH> pothepanda: Of course.
18:30:51 <ianhedoesit> hm, this actually looks like a different one. I might try to make it to the upcoming meetup.
18:30:52 <ReinH> If it is executed in a material way, it materially changes the universe.
18:31:05 <pothepanda> oh the universe is a 3d structure?
18:31:15 <ReinH> pothepanda: Not sure what you're getting at.
18:31:30 <pothepanda> nothing :) just thinking over what you said
18:31:40 <csd_> how do i make a data Foo = [Bar] ?
18:31:58 <ReinH> Well, I'm not sure if it is a *3d* structure. Maybe it is a 4d structure or a 10d structure.
18:32:13 <geekosaur> `data` requires at least one data constructor. did you want `type`?
18:32:43 <csd_> geekosaur: i had it as type but i couldnt create an instance with type so decided to try to make it a type constructor instead
18:32:56 <pothepanda> ReinH, well ok.. so how is state defined then? is it dimension-agnostic or not ? im actually asking that :D
18:33:03 <ReinH> csd_: if you want to create a new instance, you would want a newtype
18:33:23 <geekosaur> you still need a data constructor tag though
18:33:27 <ReinH> yes
18:33:38 <csd_> so data Hand = Hand [Card] is ok?
18:34:05 <ReinH> pothepanda: Well, this gets hairy when you consider quantum mechanics, but it's almost tautologically true that executing a program in the real world will change the real world somehow.
18:34:08 <monochrom> pothepanda, that is either philosophy or physics, but not haskell.
18:34:11 <ReinH> If it did not, how can you say it was executed?
18:34:20 <ReinH> But yes, either way it is not haskell.
18:34:24 <geekosaur> with type Foo = [Bar], the compiler *cannot see a difference* between something that is a Foo and something that is a [Bar]; you can't treat them differently because it can't treat them differently
18:34:55 <ReinH> csd_: data is ok, newtype is probably better
18:34:59 <geekosaur> pedantically running the program must increase entropy (thanks thermodynamics...) even if it does nothing else >.>
18:35:10 <ReinH> geekosaur: yes, that's the sort of pedantic point I'm getting at exactly.
18:35:21 <csd_> i'm trying to avoid using newtype because of the restrictions that exist on it
18:35:26 <geekosaur> ?
18:35:28 <ReinH> what restrictions?
18:35:36 <geekosaur> maybe you need to explain what end result you are trying to achieve
18:35:40 <pothepanda> why its not haskell.. haskell.. runs on top of a philosophy or physics layer
18:35:42 <csd_> that you can only have one free parameter
18:35:48 <pothepanda> but anyway i understand what you mean :D
18:35:51 <csd_> not that that concerns the program right now
18:35:55 <ReinH> csd_: That's not a restriction of newtypes
18:36:03 <exio4> one free parameter?
18:36:10 <exio4> one phantom type?
18:36:23 <ReinH> csd_: but since your type meets the restrictions of newtype, that's like saying "I don't want to put my bread in a bread basket because my car will not also fit in a bread basket"
18:36:28 <monochrom> at the level of haskell programming, I'm going to just stick to "I run my program, and it erases a ton of my files. oops. but I'm not going to ponder 'are the files real? is this universe real? even if so, is there state?'"
18:36:34 <csd_> ReinH: :)
18:36:52 <ReinH> Do people actually use bread baskets?
18:36:58 <csd_> exio4: i'm getting my terminology mixed up but the example i remember was how you make a monad out of Either
18:37:09 <monochrom> I still see bread baskets in restaurants :)
18:37:18 <ReinH> csd_: that's a restriction of the Monad typeclass
18:37:24 <geekosaur> ReinH, also in places where you get your bread fresh each day
18:37:29 <ReinH> csd_: the restriction for newtypes is that they can only have one constructor.
18:37:35 <ReinH> And your type only requires one constructor.
18:37:40 <pothepanda> we have bread baskets here too
18:37:45 <csd_> ah
18:37:52 <ReinH> Ok, thank you, that is overwhelming evidence that bread baskets are still in use.
18:37:57 <exio4> newtype C f g a = C (f (g a)) is a perfecly fine newtype
18:38:07 <exio4> @let newtype C f g a = C (f (g a))
18:38:09 <lambdabot>  Defined.
18:38:09 <pothepanda> monochrom, why not?
18:38:14 <Nadrieril> the files are merely an illusion created by the Universe monad
18:38:20 <Nadrieril> or whatever structure it has
18:38:30 <monochrom> why not what?
18:38:35 <ReinH> monochrom: what even is the universe, monochrom?
18:38:40 <Nadrieril> probably a category on Hopf bialgebras
18:38:44 <pothepanda> monochrom, why not ponder that thing :/
18:38:49 <geekosaur> this is definitely getting into philosophy
18:39:04 <pothepanda> Nadrieril, an illusion or an approach is it ?
18:39:08 <geekosaur> but haskell isn't much help with untangling philosophy >.>
18:39:09 <monochrom> you completely misread and misquote me.
18:39:26 <Nadrieril> can we know ?
18:39:36 <monochrom> at the level of haskell programming, I am not going to ponder philosophy issues
18:39:50 <pothepanda> monochrom, sorry for that. 
18:40:03 <monochrom> if you're logical, you understand that this does not implies that I never ponder philosophy issues.
18:40:24 <monochrom> if you don't understand that, you don't have the minimum requirement to go philosophical.
18:41:10 <ReinH> So... does anyone have any haskell questions?
18:41:44 <Jinxit> why isn't python more like haskell?
18:41:47 <Jinxit> wait, shit
18:42:02 <monochrom> python was invented earlier, IIRC
18:42:03 <orion> exio4: Can you give a concrete example of C?
18:42:04 <ReinH> because then it would be less like python
18:43:43 <exio4> orion: ocncrete example of what? 
18:44:03 <pothepanda> monochrom, i never said that you never ponder philosophical. i will do my thinking on my own
18:44:08 <divVerent> monochrom: Wikipedia says Python 1991, Haskell 1990
18:44:36 <exio4> orion: some place where that C could be used? functor composition maybe :p
18:45:22 <ReinH> :t C (Right (Just 1))
18:45:24 <lambdabot> Num a => C (Either a1) Maybe a
18:45:31 <ReinH> orion: ^
18:46:07 <ReinH> C is Data.Functor.Conpose
18:46:18 <orion> 19:37:45 < exio4> @let newtype C f g a = C (f (g a))
18:46:30 <ReinH> ... Yes.
18:46:34 <orion> `f' must be a data constructor, not a type constructor, yes?
18:46:38 <ReinH> No.
18:46:42 <ReinH> I just gave an example.
18:46:48 <ReinH> If it compiles, it must be correct.
18:47:05 <ReinH> f and g are type constructors if kind * -> *
18:47:10 <ReinH> s/if/of
18:47:22 <orion> Oh, that makes sense. I forgot about kinds.
18:47:22 <ReinH> The only data constructor is C
18:47:25 <monochrom> are you confusing C with C?
18:47:29 <ReinH> Yes :)
18:47:34 <ReinH> punning :(
18:47:45 <ReinH> the source of a non-zero number of problems.
18:47:52 <geekosaur> this C won't dump core at least >.>
18:47:59 <ReinH> and probably not a negative number of problems.
18:48:16 <orion> have the minimum requirement to go philosophical.
18:48:20 <orion> erm
18:49:22 <orion> 19:40:48 < ReinH> So... does anyone have any haskell questions? <-- Yes. Does evaluation happen at runtime? If so, why can't it happen at compile time?
18:49:40 <ianhedoesit> ReinH: this is almost certainly a silly question/assumption, but in the case of IO, for example, the data being "wrapped" (excuse my terminology) in the IO monad is important for the evaluation of getLine to be pure, correct?
18:50:25 <ianhedoesit> is there any way to keep evaluation pure if getLine had the type String rather than IO String?
18:50:32 <monochrom> there are two ways to answer this. one way is "evaluation is defined to be some of those things during run time"
18:50:53 <monochrom> another ways is "the optimizer does some evaluation at compile time"
18:51:29 <ReinH> ianhedoesit: what data?
18:51:47 <ianhedoesit> ohh
18:51:58 <ReinH> @quote bin/ls
18:51:58 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
18:53:23 <ianhedoesit> so is the only (well, probably not only, but for simplicity's sake) reason that getLine can't have type String rather than IO String due to Haskell's type system? It could still be a pure function but not belong to the IO monad while retaining it's functionality?
18:53:43 <ReinH> ianhedoesit: getLine is not a String, so it shouldn't have type String.
18:54:09 <ianhedoesit> hm, yeah. so the only type it could have is IO String
18:54:12 <geekosaur> if it is pure then by definition it always produces the same value
18:54:14 <ReinH> It is not an IO that "contains" or "wraps" a String either.
18:54:19 <geekosaur> thus it cannot keep its function
18:54:42 <monochrom> you should read my http://www.vex.net/~trebla/haskell/IO.xhtml
18:54:46 <ReinH> Yes.
18:54:53 <ReinH> read that
18:55:00 <ianhedoesit> I will! :) thanks again
19:05:18 * austinerlandson
19:08:32 <emmanuel_erc> Hello there... I was just reading some source code for Prelude (http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Foldable.html#all). I don't really understand the last part on the page about function coercion (the operator #., which is just coerce in disguise); what is going on there?
19:13:47 <c_wraith> emmanuel_erc: it's about eliminating even the id operation that newtypes have
19:15:23 <c_wraith> emmanuel_erc: the note a bit further down the page actually describes it pretty well
19:15:31 <emmanuel_erc> Thank you for responding. I sort of understand that. Not quite though. 
19:15:42 <c_wraith> emmanuel_erc: All is an identity operation.
19:15:57 <c_wraith> emmanuel_erc: But GHC is never sure that All . p is the same thing as p
19:16:15 <c_wraith> emmanuel_erc: so it generates code that performs some extra work
19:16:50 <emmanuel_erc> I gotcha know!
19:16:51 <c_wraith> emmanuel_erc: using #. eliminates that extra work, because it doesn't actually compose any functions.  It just coerces the function in its second argument
19:18:19 <emmanuel_erc> The explanation on the page makes more sense after what you have just said.
19:18:24 <emmanuel_erc> Thanks c_wraith!
19:18:38 <c_wraith> you're welcome
19:18:50 <emmanuel_erc> I really want to wrap my head around the runtime aspects of Haskell.
19:18:54 <emmanuel_erc> So this helps!
19:19:09 <erlandsona> Anyone here want to help me implement recursive function to build a simple string? https://github.com/erlandsona/cal_haskell.git
19:20:27 <erlandsona> I'm learning Haskell by implementing the unix cal program and it would be really helpful if I could get a couple people to throw in some ideas to learn better FP concepts for approaching string building....
19:20:43 <glguy> erlandsona: FYI you can use (year `div` 100) instead of  floor (year % 100)
19:21:28 <arahael> erlandsona: So, what does your cal program show for September 1752?
19:21:37 <erlandsona> Hmmm... Thanks glguy!
19:21:51 <erlandsona> arahael: it should show...
19:21:59 <ReinH> emmanuel_erc: string building is actually a very interesting topic with some interesting and accessible research that has made its way into haskell packages
19:22:17 <ReinH> emmanuel_erc: for example, http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf
19:22:28 <ReinH> and the implementation https://hackage.haskell.org/package/wl-pprint-1.2/docs/Text-PrettyPrint-Leijen.html
19:22:29 <erlandsona> Wait how do I add a terminal call in irssi?
19:23:21 <arahael> erlandsona: What's the day after 2nd Sept 1752?
19:23:33 <ReinH> erlandsona: Richard Bird's excellent book Thinking Functionally with Haskell has a whole chapter on implementing a pretty printer. It would be very instructive.
19:23:49 <erlandsona> Also I haven't figured out how to scroll with irssi inside TMUX?
19:24:10 <arahael> erlandsona: shift pgUp/pgDn, usually.
19:24:13 <erlandsona> ReinH: I'll check that out, thanks!
19:24:21 <arahael> erlandsona: Or without the shift, possibly.
19:24:31 <erlandsona> Yeah pgup and down mess with TMUX
19:24:50 * hackagebot nanq 1.0.0 - Performs "W (National Kanji Exam) level analysis on given Kanji.  https://hackage.haskell.org/package/nanq-1.0.0 (fosskers)
19:25:05 <arahael> erlandsona: On my system pgup and pgdn work perfectly in tmux without shift, but I have to use Fn as it's a laptop keyboard.
19:25:09 * arahael shrugs.
19:25:23 <erlandsona> Tried them all for some reason it's not working in iTerm2? Or I don't know?
19:25:34 <ReinH> erlandsona: well, this isn't an irssi support channel.
19:25:51 <arahael> erlandsona: Ah, I'm using Terminal.App, which is far better in El Capitan.
19:25:54 <erlandsona> Yeah sorry ReinH no worries...
19:26:18 <erlandsona> I'll figure it out...
19:26:22 <arahael> ReinH: Thanks for the reminder, I was getting distracted.
19:26:37 <dolio> c_wraith, emmanuel_erc: The id operation for newtypes always disappears.
19:27:02 <c_wraith> dolio: not always.
19:27:02 <dolio> However, when you compose with identity, instead of `f` you get `\x -> f x`.
19:27:08 <c_wraith> Right.
19:27:10 <dolio> And `\x -> f x` is not free.
19:27:17 <c_wraith> You can't get f back because of seq
19:35:05 * hackagebot BlogLiterately 0.8.1.4 - A tool for posting Haskelly articles to blogs  https://hackage.haskell.org/package/BlogLiterately-0.8.1.4 (BrentYorgey)
19:40:05 * hackagebot BlogLiterately-diagrams 0.2.0.2 - Include images in blog posts with inline diagrams code  https://hackage.haskell.org/package/BlogLiterately-diagrams-0.2.0.2 (BrentYorgey)
19:43:49 <ReinH> BlogLiterally. Interesting.
19:44:30 * arahael wonders how literal such images must be.
19:44:43 <ReinH> They can be either literal or figurative
19:44:48 <ReinH> since literal now means both literal and figurative
19:45:12 * hackagebot tar 0.4.5.0 - Reading, writing and manipulating ".tar" archive files.  https://hackage.haskell.org/package/tar-0.4.5.0 (DuncanCoutts)
19:45:35 <pothepanda> ReinH, can i ask a haskell question ?
19:46:05 <mniip> don't as to ask
19:46:07 <ReinH> pothepanda: I don't know, can you?
19:46:23 <gfixler> pothepanda: haskell questions are best asked in #haskell
19:46:31 <ianhedoesit> http://i.qkme.me/3qt516.jpg
19:46:55 <ReinH> We don't condone comic book character on comic book character violence here.
19:47:00 <arahael> ianhedoesit: Is that image to be interpreted literaly, figuratively, or otherwise?
19:47:00 <ReinH> But yes, that.
19:47:02 <ianhedoesit> oh sorry
19:47:09 <ReinH> ianhedoesit: I'm joking.
19:47:14 <ianhedoesit> me too
19:47:15 <ianhedoesit> :)
19:47:30 <ReinH> arahael: yes.
19:47:30 <Gurkenglas> Poeeeeeeee
19:48:03 <pothepanda> haha :D well i can. when we say a function is pure? when given the same input produces the same output, right ?
19:48:12 <ReinH> This again? :)
19:48:15 <ReinH> pothepanda: sure.
19:48:25 <monochrom> yes
19:48:26 <pothepanda> return is not pure is it ?
19:48:30 <ReinH> yes it is.
19:48:43 <pothepanda> but the IO state "returned" is the same?
19:48:58 <monochrom> I don't understand that question
19:49:08 <ReinH> What is an "IO state"?
19:49:12 <monochrom> perhaps revisit your assumptions
19:49:14 <arahael> pothepanda: "return" is a function, "returned" must be something entirely different.
19:49:26 <pothepanda> wait, please, let me explain, my misunderstanding
19:49:40 <ReinH> If I say return 1 :: IO Int, I am describing the same value every time.
19:50:58 <pothepanda> return :: Monad m => a -> m a --- so given a String will always product a IO String, so its pure ?
19:51:19 <pothepanda> *produce
19:51:41 <arahael> It only produces IO String if m is IO.
19:52:14 <arahael> Think of the return function as "wrapping up" the provided value.
19:52:34 <geekosaur> wrapping it in a program that will always produce the same value when executed
19:52:43 <geekosaur> and that can be composed with other programs that may not
19:52:57 <geekosaur> but the type system can't tell the difference between them
19:54:48 <ReinH> pothepanda: on what do you base your belief that return x might produce different outputs?
19:54:58 <geekosaur> and the execution context neither knows nor cares
19:55:18 <ReinH> I would like to know specifically in which way you think return is impure, because we may be answering a question you haven't actually asked.
19:55:33 <arahael> One thing that confused me in my early questions about purity, was that some people reason about purity rather differently.
19:55:47 <arahael> Some people regard "pure" functions as those that do not use IO.
19:56:05 <monochrom> that too.
19:56:07 <arahael> Some people regard "pure" functions as any function, even if it returns a value that happens to be a function that must be evaluated in the IO context.
19:57:01 <ReinH> Before we can decide if a term is pure, we must first fix a definition of pure.
19:57:15 <arahael> ReinH: What's "fix"? ;)
19:57:20 <ReinH> make constant
19:57:25 <mauke> nail down
19:57:29 <gfixler> unbreak
19:57:31 <pothepanda> ReinH, yea sure, can we do that about State ?
19:57:41 <ReinH> about "state" or "State"?
19:57:57 <pothepanda> State is a monad, while state is the common english word ?
19:58:11 <gfixler> there is something kind of funny about getting a different definition for purity every time I ask for one
20:01:21 <pothepanda> ReinH, to make things clear. i was reading this: https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State which states that n order to "keep track of state in a functionally pure way. We do so by passing the state information from one function to the next, thus making the hidden dependencies explicit.". So i assumed IO is such a thing
20:01:47 <c_wraith> :t state
20:01:49 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
20:02:28 <pothepanda> arahael, also, id like to understand how return knows what Monad m to output
20:02:36 <monochrom> IO is very fundamentally different from State
20:02:56 <monochrom> or at least, IO operations are very fundamentally different from State
20:03:04 <monochrom> err, from State operations
20:03:52 <monochrom> for example, if you say putStrLn "hello", that hello will not be around for long
20:03:57 <ReinH> pothepanda: IO is not such a thing.
20:04:09 <monochrom> but if you say put "hello", that hello will be around for long, until the next put.
20:04:34 <monochrom> if you say getLine, the computer hangs forever, until someone enters something
20:04:42 <ReinH> pothepanda: return knows what m is because you either declare its type or GHC infers its type.
20:04:51 <geekosaur> re return, unlike many languages, Haskell typeclasses can select an instance based on the type expected at the use site. so if you use return in something that produces an IO a, (return :: a -> IO a) is used.
20:04:53 <monochrom> if you say get, the computer resumes immediately, there is nothing to wait for
20:05:03 <ReinH> or you use it in a polymoprhic way and resolving what m is is deferred until later
20:05:29 <ReinH> :t let return1 = return 1 in return1
20:05:31 <lambdabot> (Monad m, Num a) => m a
20:05:35 <geekosaur> > (return 'a') ++ "b"
20:05:36 <lambdabot>  "ab"
20:05:39 <ReinH> :t let return1 = return 1 in return1 :: Maybe Int
20:05:40 <lambdabot> Maybe Int
20:05:53 <ReinH> in the first case, the use of return is polymorphic. In the second case, it has been specialized to Maybe.
20:07:18 <ReinH> pothepanda: State is a way of passing around parameters and ensuring that they are threaded properly between calls. It happens entirely during evaluation.
20:07:46 <ReinH> pothepanda: IO is a way of constructing, via evaluation, a value that the runtime system *executes* to perform IO.
20:08:06 <monochrom> State operations read some readily available data and write new data for the next read. it's all internal. in fact it's all monologue. it's navel gazing.
20:08:12 <pothepanda> i see :/
20:08:13 <ReinH> essentialy an IO action is constructed during evaluation and then handed off to the runtime system to be executed.
20:08:32 <monochrom> IO operations read something that doesn't even exist yet. it's all external.
20:09:15 <monochrom> there is no way one can be in their right mind and say "IO is like State"
20:09:47 <ReinH> monochrom: It doesn't at all help that the word State is used in the definition of IO, and I see this sometimes as a justification.
20:09:53 <monochrom> IO is like totally the opposite of State. as opposite as talkative vs reclusive.
20:10:09 <ReinH> Ofc you can explain that State# RealWorld is nothing like State Int or w/e, but it's still annoying
20:11:06 <geekosaur> the point of the State there, happening at evaluation time, is just to ensure IO actions happen in the correct order. in fact the state disappears before any code is generated!
20:11:28 <ReinH> geekosaur: Yes, I know, it's just annoyingly named.
20:11:45 <ReinH> State# RealWorld is entirely a phantom type.
20:12:56 <nshepperd_> State# RealWorld is irrelevant unless you're implementing ghc
20:13:05 <nshepperd_> No reason to know about it
20:13:14 <ReinH> yes, but it offers a nice red herring for people to bite on.
20:13:21 <ReinH> Hmm... Am I mixing metaphors?
20:13:44 <monochrom> it's one of those times when knowing half of it is more dangerous than knowing none of it.
20:13:44 <geekosaur> to chase, perhaps
20:13:46 <nshepperd_> Hah
20:13:51 <ReinH> nshepperd_: I have already had multiple conversations with people who have claimed that IO is like State because of State# in this week alone.
20:14:00 <ReinH> and it's only Tuesday
20:14:16 <ReinH> monochrom: yes exactly
20:14:22 <nshepperd_> My condolences
20:14:27 <ReinH> nshepperd_: I appreciate it :)
20:15:01 <erisco> why does Hakyll freak out if I use quotes in my markdown…
20:15:13 <erisco> commitBuffer: invalid argument (invalid character)
20:15:30 <monochrom> to be fair, a person who reads "State# RealWorld" and goes on to ask "but what does it store? how much can it possibly store?" has hope.
20:15:56 <ReinH> right
20:16:30 <haskell285> can ReaderT be turned into a comonad if we require the inner type constructor to be a comonad?
20:17:27 <geekosaur> erisco, you're using smart quotes (or your editor is converting them for you) and the locale in the editor differs from the locale that hakyll is expecting?
20:18:59 <erisco> apparently I have to run 'chcp 65001' on Windows in the shell first
20:18:59 <ReinH> haskell285: Perhaps you are asking about TracedT https://hackage.haskell.org/package/comonad-4.2.7.2/docs/Control-Comonad-Trans-Traced.html
20:19:04 <erisco> I don't get wtf is going on
20:19:10 <geekosaur> (hakyll will usually expect some utf8 locale. editors... certain Mac editors have the annoying tendency to assume the old Mac OS (pre-X) Roman-8 encoding, and "smarten" quotes automatically, with hilarious results
20:19:17 <ReinH> co-reader also requires a monoid constraint, dual to writer requiring a monoid constaint.
20:19:17 <monochrom> I wonder if this is a good wake-up call to the state or extraction people: if getLine stored a string to be extracted, does it mean that it stores the string that I will enter tomorrow?
20:19:21 <geekosaur> oh
20:19:39 <erisco> um…
20:19:50 <erisco> and if I do that, it compiles, but my entire page disappears after the first quote
20:19:51 <geekosaur> 65001 is how windows identifies utf-8, it's like setting LANG=en_US.UTF-8 or some other .UTF-8 locale on unix
20:20:07 <geekosaur> wiothout that, it may assume something like code page 437, the old PC encoding
20:20:17 <monochrom> erisco: 65001 is the utf-8 code page, and not the default
20:20:24 <erisco> what does some Windows code page thing have to do at all with site.exe?
20:20:28 <ReinH> wait, traced is cowriter
20:20:41 <geekosaur> because windows doesn;t have a locale system; code pages act as a proxy for locales
20:20:46 <ReinH> so s/coreader/cowriter above
20:20:51 <erisco> what?
20:21:03 <monochrom> I don't know about site.exe. but every console program suffers code pages
20:21:10 <erisco> it seems markdown is converting to smart quotes
20:21:22 <erisco> is it an error writing the file? how could that possibly be?
20:21:47 <erisco> what does a code page have to do with writing a utf-8 encoded file
20:22:07 <monochrom> you are asking too fast. do you mind reading a bit of the following?
20:22:47 <monochrom> GHC's I/O library defaults to an encoding based on the computer's locale.
20:23:07 <haskell285> ReinH:  considering TracedT has a different structure than ReaderT, I'm thinking probably not
20:23:08 <monochrom> in the case of Windows, this means based on the code page of the console.
20:23:53 <monochrom> the default code page is not utf-8. it's some windows convention. it also varies according to what "language" the account holder chooses.
20:23:54 <pothepanda> monochrom, if the evaluation is deferred you couldnt say the difference, right ?
20:25:10 <erisco> monochrom, that seems all manner of "wtf"
20:25:31 <erisco> why would it defer to some global encoding setting…
20:25:43 <monochrom> to some extent, this does not matter. for example, you run your program under a code page to write a file. fingers crossed, next time you run that program to read that file, it's still the same code page. then you probably won't notice any problem, assuming the code page has all the characters you happen to use.
20:26:14 <geekosaur> erisco: files, on unix or windows, do not have encoding information associated with them
20:26:27 <monochrom> do you have a better suggestion?
20:26:59 <ReinH> haskell285: Well, I'm not sure how you intend to "turn" ReaderT into a comonad, but I can guess you mean either the coreader or cowriter comonad transformers.
20:27:10 <geekosaur> life would be *much* easier oif they did; as it stands, locale issues often crop up specifically because the only locale information available to the program is some "global" locale setting
20:27:11 <ReinH> If not, you'll have to define "ReaderT turned into a comonad" for me.
20:27:11 <monochrom> do you have a better suggestion that you are sure you can inflict on other users and they will agree?
20:27:20 <geekosaur> and not just in haskell
20:27:56 <monochrom> you know what, I think we can blame that on the unix philosophy
20:28:00 <geekosaur> python 3 took a longish time to get through its teething pains on this issue
20:28:01 <haskell285> ReinH: something akin to 'instance (Monoid r, Comonad w) => Comonad (ReaderT r w)
20:28:06 <erisco> when you read and write any other binary format it isn't as confusing as this
20:28:37 <erisco> why there has to be some magic setting in the mix for text files is bizarre
20:29:08 <monochrom> there is a youtube video in which Kernighan proudly says "in other OSes, a file has a lot of complicating metadata. in unix, a file is just a sequence of bytes"
20:29:26 <geekosaur> windows tried to push everyone to switch to utf16 for all data, but that hasn't happened at all consistently
20:29:35 <monochrom> well, today, it turns out that we need that complicating metadata afterall, namely "is this ASCII or is it UTF-16??!!"
20:29:50 <codebje> stat(2) says kernighan was not quite accurate :-)
20:29:58 <geekosaur> sadly the metadata Kernighan was talking about wouldn't help here
20:30:17 <geekosaur> he was comparing to things like VMS'S RMS --- essentially, you did not have data files, you had *databases*
20:30:20 <codebje> monochrom, UTF-16 should have a BOM to help distinguish it, fwiw
20:30:35 <monochrom> yeah ok, bad example.
20:30:44 <geekosaur> with fixed formats
20:30:51 <monochrom> how about "is it windows-1251 or is it windows-1252??!!"
20:31:14 <haskell285> doesn't the fact that unixes store less data about files mean that utilities like 'file' need to do more work?
20:31:24 <monochrom> yes absolutely
20:31:32 <codebje> 'file' is guessing
20:31:51 <monochrom> well it already does a lot more work to just guess
20:32:09 <haskell285> i realize, but the guessing is partly because of the lack of information about a file
20:32:35 <codebje> entirely because of it, file systems which store the type of the file don't need a program to guess the type
20:33:26 <geekosaur> in reality, the old world of file metadata would deal with the current situation even less well because re-encoding something amounts to ALTER DATABASE commands as well as rewriting every record. win some, lose some
20:33:35 <monochrom> OTOH once you accept "the metadata contains a type field", people will bikeshed-colour themselves to death on how refined that type system is.
20:34:03 <monochrom> perhaps it's really simpler --- socially simpler --- to just store no type.
20:34:19 <codebje> well, it certainly makes documents a lot more portable across systems :-)
20:34:46 <codebje> the world has done reasonably well inferring type by extension and allowing the user to apply contextual information to resolve ambiguities
20:36:22 <codebje> and where would cryptanalysis be if magic marker bytes weren't common?
20:40:23 <ReinH> haskellbr-slack: right, that sounds like TraceT
20:40:55 <ReinH> Sorry, TracedT
20:41:12 <ReinH> newtype TracedT m w a = TracedT w (m -> a)
20:41:51 <ReinH> (Comonad w, Monoid m) => Comonad (TracedT m w)
20:42:25 <ReinH> er
20:42:30 <ReinH> Oh, they left
20:42:34 * ReinH sighs
20:45:27 * hackagebot ide-backend 0.10.0.1 - An IDE backend library  https://hackage.haskell.org/package/ide-backend-0.10.0.1 (MichaelSnoyman)
20:45:29 * hackagebot ide-backend-common 0.10.1.2 - Shared library used be ide-backend and ide-backend-server  https://hackage.haskell.org/package/ide-backend-common-0.10.1.2 (MichaelSnoyman)
20:50:27 * hackagebot ide-backend-server 0.10.0.1 - An IDE backend server  https://hackage.haskell.org/package/ide-backend-server-0.10.0.1 (MichaelSnoyman)
20:58:35 <nitrix> Does Haskell has a mechanism for removing a binding from a `do` block?
20:58:52 <monochrom> no
20:59:08 <nitrix> I'm using a C library that's doing a destructive operation and I'd rather prevent people accidently re-using the bogus pointer.
20:59:40 <nitrix> Mhhh, I think I'll go with a lambda abstraction then.
21:00:05 <monochrom> yeah, do a callback thing. take inspiration from "withFile" etc
21:00:37 <kadoban> If I use blaze-html to build up some Html … can I inspect the Html tree itself, like say I have an Html and I want to inspect the children of the element that's at the top … that's not really possible, huh?
21:02:23 <nitrix> kadoban: To be honest, the final HTML is pretty much as representable as your tree could possible be.
21:04:23 <kadoban> nitrix: I'm not sure what you mean exactly :-/ You mean that basically outputting it as a String (or whatever) is as good as it gets?
21:04:48 <nitrix> Well, the structure it provides already kind of shows parents and childs very well.
21:05:14 <nitrix> Maybe you'd like some pretty formatting, but HTML is easy to read on its own.
21:05:52 <monochrom> no, correctly indented HTML is easy to read :)
21:06:15 <kadoban> nitrix: Well I'm not really looking for formatting, I'm looking to answer questions such as, Html -> Bool, where my function should answer "does this element have a child with the class "empty", for instance, stuff like that.
21:07:59 <nitrix> Oh hey!
21:08:02 <nitrix> Text.Blaze.Html.Renderer.Pretty :P
21:08:18 <kadoban> :-/
21:10:41 <MarcelineVQ> kadoban: some uses cases may be found within this https://github.com/jaspervdj/blaze-html/blob/master/src/Util/BlazeFromHtml.hs but it sounds like you're working backwards, wouldn't you determine those details befor rendering them?
21:11:36 <kadoban> MarcelineVQ: Well that's kind of what I'm asking … isn't blaze-html basically building a DOM tree? Except it doesn't seem to work like that, unless I'm missing something. So is there something else that does perhaps?
21:12:03 <nitrix> It assembles it, it doesn't parse it.
21:13:42 <nitrix> The only querying operation they let you do is `null :: MarkupM a -> Bool`.
21:14:47 <kadoban> So is there a better tool to build up HTML from parts that allows more inspecting of the result, perhaps?
21:15:35 <nitrix> I'm confused as to why you need to inspect it if you're the one that built it.
21:15:45 <nitrix> It didn't just magically generate itself :P
21:16:44 <geekosaur> so am I. you are feeding blaze-html a DOM, in the form of an EDSL. if you want to introspect the DOM, you need to do it in the stuff you're feeding to blaze-html, not its output
21:17:26 <kadoban> Well there's some things that are annoying to check due to how I've structured my code, but would be pretty trivial to check if I could just peek at the result. I guess I'll have to refactor some stuff then.
21:18:05 <nitrix> If you _ever_ need to, you can probably deconstruct the MarkupM datatype.
21:18:26 <nitrix> But I you're trading one problem for another I feel.
21:20:18 <geekosaur> I would suspect that type has more of a focus on formatting than on content
21:20:51 <kadoban> Seems like it, it didn't look particularly friendly to pattern match and mess with manually. Thanks.
21:22:16 <nitrix> I wonder how that'd be named. Parts of the application communicating via HTML... HTML-passing style?
21:22:57 <nitrix> Good luck. I'm off to bed.
21:25:53 <ianhedoesit> monochrom: thakn you for your site! I read what you linked and a few others.
21:27:08 <ianhedoesit> I constantly see Philip Wadler's name come up but every time I try to read things he has written I get lost and can't understand the basic symbols and terminology he uses (not that that is a bad thing - I'm sure he writes exactly as he needs to to convey the information being presented, but I can't understand it)
21:30:47 <geekosaur> type theory has its own distinctive "language"
21:31:25 <ianhedoesit> which makes it difficult for me, a layperson, to understand much of the seemingly more accurate descriptions of what goes on in Haskell.
21:32:02 * geekosaur doesn't understand that language very well either, for what it's worth
21:44:35 <ianhedoesit> @pl \f g x y -> f (x ++ g x) (g y)
21:44:35 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
21:45:25 <geekosaur> ianhedoesit, http://siek.blogspot.se/2012/07/crash-course-on-notation-in-programming.html
21:45:46 * geekosaur is having Very Bad Network and finally gae up and loaded that on the phone to verify it was the right link...
21:50:41 <ianhedoesit> geekosaur: looks useful. thanks!
21:51:04 <ianhedoesit> I've just been using wikipedia and googling for greek characters.
22:07:54 <ontop> Hey guys. Trying to understand Foldable type class. My book says I can define foldr or foldMap, I don't understand why. The Typeclass has 2 functions (fold, foldMap) so why is this the case?
22:09:58 <srhb> ontop: https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Foldable.html#Foldable
22:10:23 <srhb> ontop: So foldr has a default implementation in terms of foldMap and vice versa
22:10:58 <kadoban> ontop: It actually has a bunch of methods, but defining either foldMap or foldr is enough because there are default implementations in terms of those.
22:11:24 <hunteriam> How do I authorize users for actions in my servant Api? Do I track their session, do I send their name and password with every request? I'm lost here
22:11:59 <ontop> Are the default implementations defined for each type as an instance somewhere?
22:12:07 <ontop> Like syntactically I just don't "get" that.
22:12:19 <ontop> I thought type classes just defined the functions they wanted implemented
22:12:24 <kadoban> ontop: It's a slightly more complicated version of why you can define either (==) or (/=) for the Eq typeclass and the other one works anyway. https://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html#t:Eq
22:13:20 <hunteriam> This is seriously not a question I know how to answer
22:13:48 <ontop> kadoban: Yeah, but how is that actually declared. Like I looked at the source for prelude, all I see is: Eq((==), (/=))
22:13:54 <ontop> How does haskell know what to do with that?
22:14:25 <kadoban> ontop: Something like class Eq a where \n a == b = not $ a /= b \n a /= b = not $ a == b
22:14:33 <hunteriam> @src Eq
22:14:34 <lambdabot> class Eq a where
22:14:34 <lambdabot>     (==), (/=) :: a -> a -> Bool
22:14:51 <hunteriam> @src (==)
22:14:51 <lambdabot> x == y = not (x /= y)
22:14:56 <hunteriam> There ya go
22:15:01 <hunteriam> They're defined in terms of each other
22:15:04 <ontop> @src (/=)
22:15:04 <lambdabot> x /= y = not (x == y)
22:15:26 <ontop> That's some careful evaluation not to ruin yourself during interpretation.
22:15:31 <ontop> Or compilation.
22:15:37 <hunteriam> not really
22:15:44 <hunteriam> As long as either is defined there's no threat
22:15:48 <ontop> Right.
22:16:07 <ontop> It's odd to me that you can do that :D
22:16:11 <ontop> But that's cool.
22:16:31 <ontop> So
22:16:40 <ontop> If I define foldr, I get foldMap and also fold it looks like.
22:17:03 <ontop> fold seems to give you nothing though.
22:17:04 <ontop> How sad.
22:17:16 <ontop> That almost ruined me. Thanks kadoban.
22:17:23 <kadoban> 'welcome
22:17:43 <ontop> I'm learning all these things. And I have no idea when I'd ever use them.
22:17:54 <hunteriam> Such as?
22:18:05 <ontop> Functors, Applicatives, Foldable, etc.
22:18:22 <hunteriam> Any plans to write something in Haskell?
22:18:24 <M-Quora> you'll end up using them all the time
22:18:30 <ontop> Well
22:18:36 <ontop> I purchased and read most of a 900 page book.
22:18:42 <ontop> I feel like I should write something some time.
22:18:42 <ontop> lol.
22:18:48 <kadoban> And by the way, in case you're wondering why the rest of the methods are in the class then (instead of just normal functions), it's so you can override them with better (somehow) definitions for a specific instance. Like if there's a really performant way to do 'sum' directly instead of with foldr
22:18:54 <hunteriam> Well when/if you do, you will use them
22:19:02 <hunteriam> Those are very common type classes
22:19:17 <ontop> Right, but I feel like I won't recognize when I need them
22:19:21 <ontop> Brain doesn't work this way yet.
22:19:29 <ontop> I'm fine with recursion, pattern matching. That stuff just makes sense.
22:19:34 <ontop> But this stuff is like... when... what... why.
22:19:54 <kadoban> ontop: You get used to it pretty quick with practice.
22:19:59 <hunteriam> You'll know when to use them when you discover what you get for free for using them
22:20:05 <ontop> Also, const needs to go to hell. I hate that function!
22:20:08 <hunteriam> And what things count as them
22:20:31 <Cale> ontop: why?
22:20:54 <ontop> I just dislike it.
22:21:00 <Cale> ontop: It makes constant functions, those are useful a lot of the time when you're working with functions that take other functions as arguments.
22:21:28 <ontop> It makes constant functions. I've only ever seen it discard values.
22:21:31 <ontop> Maybe I'm confused though.
22:21:42 <hunteriam> You could plug it in to fold I think
22:21:53 <hunteriam> It's something for plugging in to things
22:22:14 <hunteriam> Foldr const = last?
22:22:19 <hunteriam> Or first..
22:22:22 <ontop> First I think?
22:22:57 <ontop> Can't even get that to compile :D
22:23:56 <hunteriam> :t (foldr const)
22:23:57 <lambdabot> Foldable t => b -> t b -> b
22:24:34 <hunteriam> :t (foldr (flip const))
22:24:35 <lambdabot> Foldable t => a -> t b -> a
22:26:13 <hunteriam> So can someone help me with a servant issue
22:26:41 <hunteriam> I want to authorize users for certain api operations but I've got no clue what a good approach to doing that with servant is
22:26:42 <ontop> Cale: What's a constant function help me with?
22:26:46 <ontop> Can you give a sick example?
22:30:09 <Cale> Hmm, most of them are pretty boring (but useful), if you want something fun though, consider:
22:30:22 <Cale> > filterM (const [True, False]) [1..4]
22:30:26 <lambdabot>  [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4]...
22:30:30 <Cale> > filterM (const [True, False]) [1..3]
22:30:33 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
22:30:49 <ontop> filterM = filterMap?
22:30:56 <Cale> "For each element of the list, regardless of what it is, take it or leave it"
22:31:05 <Cale> filterM = monadic generalisation of filter
22:31:17 <Cale> In this case, we're using it with the list monad
22:31:21 <ontop> Right.
22:31:49 <Cale> With the monad instance for lists, "running" a list means picking an element from it in all possible ways.
22:32:03 <ontop> That's neat.
22:32:05 <ontop> Didn't know that.
22:32:22 <Cale> So we give filterM a constant function which, no matter what the element of the list is, gives the list of options [True, False]
22:32:32 <Cale> i.e. either keep the element, or drop it
22:32:43 <Cale> and it does this in all possible ways
22:33:04 <Cale> We could pass a non-constant function here, if we wanted to make the options depend on what the element was
22:33:22 <Cale> > filterM (\x -> if even x then [True, False] else [True]) [1..4]
22:33:23 <lambdabot>  [[1,2,3,4],[1,2,3],[1,3,4],[1,3]]
22:33:27 <hunteriam> @src filterM
22:33:28 <lambdabot> Source not found. Whoa.
22:33:33 <ontop> lol.
22:34:06 <ontop> Cale: I learned Go and was writing useful code in it in a month. I think this language's gonna take me 6 :|
22:34:17 <hunteriam> Definitely not
22:34:20 <Cale> Well, what other languages did you already know?
22:34:22 <hunteriam> I did the same for Haskell
22:34:30 <hunteriam> You don't have to learn it in depth to use it
22:34:31 <ontop> Cale: Lots of imperative languages.
22:34:37 <hunteriam> But learning it in depth is very useful
22:34:43 <Cale> Yeah, so Go probably should have taken you like a week :)
22:34:53 <ontop> Cale: I'm talking production quality code. Not just toys.
22:34:55 <ianhedoesit> @pl \a -> fst a == snd a
22:34:55 <lambdabot> uncurry (==)
22:34:58 <Cale> Yeah, fair enough :)
22:35:12 <ianhedoesit> neato burrito
22:35:14 <ontop> But yeah, 6 months.
22:35:17 <ontop> :(
22:35:20 <pharaun> eh
22:35:21 <Cale> But I mean, it's pretty similar to most other imperative languages and has very few new ideas in it, if any
22:35:25 <pharaun> ^
22:35:33 <Cale> It's just a reskinning of the languages you already know
22:35:34 <ontop> It has no new ideas in it. That's why it's so good.
22:35:37 <hunteriam> I think you could do it pretty well in a month tbh
22:35:43 <pharaun> ontop: disagreed
22:36:04 <Cale> I gave up on Go after about 5 minutes when I discovered that I couldn't write a polymorphic map function.
22:36:05 <hunteriam> You can write pretty dull Haskell code without delving into the depths of the language
22:36:16 <pharaun> i certainly did ^
22:36:28 <Cale> Any language which doesn't let me do that is clearly intent on wasting my time.
22:36:33 <pharaun> i'm still digging into the depth and there's lots, but i could be productive in haskell pretty quickly
22:36:40 <hunteriam> ^^^
22:36:45 <hunteriam> Same for me
22:36:46 <ontop> Cale: There's many benefits past those weeds.
22:36:48 <pharaun> even if the code wasn't the best in the world and a bit dull but they were solid enough
22:36:51 <Cale> But yeah, Haskell does take a decent initial investment.
22:37:05 <hunteriam> Digging into the depths is very worth while but wholly optional
22:37:10 <ontop> Well
22:37:14 <ontop> What would you consider "digging into the depths"
22:37:16 <tangled_z> what qualifies as digging into the depths?
22:37:16 <hunteriam> Once you're familiar with the weird bits IMO you're good to go
22:37:22 <Cale> However, that time isn't wasted, you actually learn to break problems down in new ways, and avoid various pitfalls which Haskell forces you to avoid
22:37:30 <hunteriam> Understanding the many generalizations that people like to do
22:37:40 <pharaun> i have actually benefited at my day job with python at work
22:37:42 <pharaun> from learning haskell
22:37:48 <Cale> (rather than taking 40 years programming in imperative languages to possibly learn not to use excessive state everywhere)
22:37:59 <pharaun> even tho i don't use it there. I was able to like Cale said, reformulate and break down problems and figure out new approaches
22:38:06 <ontop> Yeah.
22:38:10 <ontop> I agree, it's very awesome.
22:38:14 <ontop> That's why I needed a funcitonal language.
22:38:17 <ontop> And so I chose Haskell.
22:38:23 <ontop> But.
22:38:30 <pharaun> but?
22:38:34 <hunteriam> And there are so many things that will make things better and let you write more general code but that are hard to understand
22:38:37 <pharaun> (not being snarky here)
22:38:39 <ontop> The one thing I think so far that's unforgivable
22:38:46 <hunteriam> But you don't need to understand them to write performing and useful code
22:38:54 <hunteriam> Performant *
22:39:02 <ontop> Is how horribly convoluted you can make a single line.
22:39:14 <hunteriam> ?
22:39:18 <ontop> I saw some examples from like xmonad and stuff.
22:39:18 <Jinxit> it's not convoluted once you know the language
22:39:30 <ontop> Good god, just like <*> <> <> <$> over and over.
22:39:35 <tangled_z> what's everyones take on how to best represent semantics btw? 
22:39:42 <ontop> It'd take you like days to figure out what it was actually doing.
22:39:43 <tangled_z> do you guys write a spec before you start coding? 
22:39:55 <Cale> ontop: Well, what was the line? You can write some horribly complicated lines of any language.
22:40:01 <pharaun> amen ^
22:40:16 <pharaun> also i feel tempted to bring up mel the programmer
22:40:30 <pharaun> i would not ever want to try to read his code
22:40:36 <Jinxit> just like thing.doStuff([](auto& otherThing) { return otherThing.foo; }, *zot); is perfectly normal in C++
22:40:57 <hunteriam> I think what's great about Haskell is that you know that what you're learning isn't just a fad
22:41:03 <Dtgr> it's okay in haskell to use weird infix operators though
22:41:10 <Jinxit> which might be expressed as "doStuff thing foo zot" in haskell
22:41:11 <Dtgr> that you just absolutely won't understand as they have no meaning
22:41:20 <hunteriam> Learning functors and monads gives you some security that the knowledge is stable and always useful
22:41:26 <pharaun> i tend to be a fan of avoiding weird operators (ie lens)
22:41:34 <hunteriam> It's so much nicer than in investing in APIs in other languages
22:41:37 <pharaun> and use text versions myself and `fmap` *shrugs*
22:41:39 <ontop> Also, can I aske a question about GHC 7.10
22:41:43 <pharaun> but there's hoogle, which is fantastic
22:41:50 <ontop> This book makes it feel like Monads, Applicatives, Functors etc
22:41:51 <pharaun> for looking up infix ops
22:41:52 <Jinxit> pharaun: you ever do deeply nested data?
22:41:53 <ontop> Were only recently generalized.
22:42:02 <hunteriam> They were
22:42:03 <pharaun> Jinxit: not a ton yet so that probably contributes :)
22:42:06 <ontop> How long ago?
22:42:07 <hunteriam> Or well
22:42:08 <Cale> uh, generalised?
22:42:18 <ontop> Cale: Included in prelude? Turned into type classes?
22:42:19 <hunteriam> There was the applicative monad proposal recently
22:42:20 <ontop> That sort of thing?
22:42:24 <hunteriam> That's probably what they're talking about
22:42:27 <Cale> Functor and Monad have been around since Haskell 1.2? 1.3?
22:42:31 <pharaun> Jinxit: when i start to touch up on that i might change my tune tbh :)
22:42:37 <Cale> Like, before Haskell 98 anyway
22:42:40 <ontop> Applicative though?
22:42:43 <ontop> Foldable?
22:42:47 <Jinxit> I like lens, but it's daunting at first
22:42:52 <Cale> Applicative came along maybe around 2004-ish?
22:42:56 <Cale> I want to say
22:42:58 <hunteriam> What's new is making monad depend on applicative
22:43:01 <ontop> Aha. So not that new.
22:43:08 <Cale> Getting Applicative into the Prelude is recent
22:43:20 <Cale> But it's been in the standard library since then
22:43:36 <hunteriam> Also foldable is in prelude right?
22:43:43 <Cale> Yeah, and that's very new too
22:43:56 <Cale> I'm still not used to Foldable and Traversable being in the Prelude
22:43:59 <ontop> Did these changes have big impacts?
22:44:03 <pharaun> the amp proposal and the fmp .... burning bridge? proposal
22:44:04 <ontop> Or were they available elsewhere
22:44:06 <ontop> And they just moved around?
22:44:14 <Cale> ontop: They were available elsewhere
22:44:17 <hunteriam> Foldable traversable are reasonably controversial
22:44:17 <ontop> Ah.
22:44:20 <pharaun> they were avilable else where, just made default/in prelude (re fmp) and etc
22:44:23 <Cale> A bunch of code probably had to be fixed up slightly
22:44:24 <ontop> Why hunteriam?
22:44:27 <hunteriam> And I kind of think rightfully so
22:44:37 <ontop> I'm reading about Traversable now.
22:44:44 <hunteriam> They're kind of weird
22:44:54 <Cale> Foldable isn't very pretty. Traversable I can get behind, because it has a clear specification. Foldable is more arbitrary about what it does.
22:44:55 <pharaun> hunteriam: referring to the tuple case?
22:44:55 <ontop> I thought everything after Functors was weird.
22:44:56 <ontop> lol.
22:45:14 <hunteriam> Also To me they don't feel as fundamental as things like applicative and functor
22:45:26 <hunteriam> Kind of pharaun
22:45:35 <pharaun> i saw lots of furor on the reddit bout tuple cases on foldable/traversable
22:45:50 <Cale> The tuple case of Traversable agrees with all the other instances for tuples
22:45:56 <pharaun> but *shrugs* i don't feel like i have a particularly strong thought on it either way, i was happy about the AMP one tho
22:46:11 <hunteriam> I'm just not convinced why foldable is a good generalization
22:46:17 <ontop> Because we can fold!
22:46:19 <ontop> Isn't that good?
22:46:21 <ontop> I'm not sure yet.
22:46:23 * pharaun folds hunteriam up
22:46:24 <hunteriam> It's nicer than forcing people to use lists but that seems to be the limit
22:46:27 <Cale> and in fact, there have been times recently where my life has been made concretely better because of the pair instance for Traversable
22:46:34 <Cale> I can be more specific actually
22:46:39 <pharaun> oh?
22:46:53 <ontop> I have another question. "Lifting" a function is what?
22:46:54 <pharaun> i haven't ran into those cases yet myself, probably just haven't done much generic traversal/folding over tuples
22:47:02 <pharaun> ontop: lifting something into the monad
22:47:13 <ontop> Meaning adding the structure around it?
22:47:15 <jle`> ontop: it's a bit of a generic word that doesn't have much meaning
22:47:20 <ontop> Like: 5 turns into Just 5?
22:47:33 <jle`> it's vague enough that it means whatever you want it to mean, heh
22:47:37 <pharaun> heh
22:47:38 <Cale> So, reflex-dom has some XHR stuff for sending XMLHttpRequests and getting back responses asyncronously
22:47:38 <ontop> Awful :D
22:47:47 <jle`> ontop: most words are like that, though :O
22:47:51 <jle`> we use `map` the same way
22:47:52 <Cale> among the stuff it provides are
22:47:53 <pharaun> blame english :D
22:47:56 <jle`> it has specific meanings in specific cases
22:47:57 <Cale> performRequestAsync :: MonadWidget t m => Event t XhrRequest -> m (Event t XhrResponse)
22:48:03 <jle`> but it has a very perfectly good meaning when we use `map` over lists
22:48:11 <hunteriam> MonadWidget..
22:48:17 <ontop> Okay. Next question, who here has written something meaningful in Haskell and where is it?
22:48:20 <Cale> Ignore the MonadWidget bit
22:48:27 <pharaun> :P
22:48:29 <hunteriam> I have written some of my projects for school in Haskel
22:48:32 <Cale> The important thing is that it takes an Event of XhrRequests
22:48:36 <hunteriam> I wrote a small graphics engine
22:48:46 <hunteriam> There are better examples thou
22:48:50 <Cale> i.e. a thing which represents a sequence of requests occurring at particular points in time
22:48:50 <jle`> i've written a lot in haskell... i use it for work and resaerch and web and network
22:48:52 <hunteriam> There are some large scale products
22:48:56 <jle`> most of it is still running today
22:48:57 <Dtgr> ontop: I've written an irc bot but I'm not sure if my code qualifies as a good learning material ;)
22:49:01 <ontop> Haha
22:49:04 <pharaun> i run a couple small projects in haskell at my work place :)
22:49:06 <ontop> Well, I'm probably going to write a dumb irc bot too.
22:49:12 <ontop> It's sort of my goto project.
22:49:12 <jle`> all of the things i've done in haskell, i can't imagine doing it in anything else
22:49:15 <Cale> and produces (as the result of the action), an Event of XhrResponses, which are the asynchronous responses coming back
22:49:17 <pharaun> i have an irc bot that i hack on once in a while to learn new concept/goto project
22:49:19 <jle`> and ever maintaining it
22:49:26 <pharaun> and i also have a couple other services at work (for devs)
22:49:30 <ontop> jle`: Have you ever had a project where you looked at Haskell and thought: "You are not the right thing for the job"
22:49:36 <pharaun> not yet
22:49:37 <hunteriam> For me Haskell is my love, but I don't think if I ever became a software engineer I could get away with using it
22:49:48 <Dtgr> ontop: https://github.com/Detegr/HBot there it is anyway if you want to take a look
22:49:50 <ontop> hunteriam: That's sad, why?
22:49:55 <jle`> ontop: well i wrote a bash script to change my $PATH
22:50:04 <Cale> But what if we want to tag the requests with values (maybe something to do with the request itself), and get back the same tags on the corresponding responses?
22:50:05 <jle`> to add a new directory on it whenever it was run
22:50:07 <pharaun> https://github.com/pharaun/Karmator <- is mine (ircbot)
22:50:18 <jle`> i wouldn't do that in haskell becuase i don't expect to maintain it
22:50:22 <Cale> As it happens reflex-dom doesn't explicitly provide this, but it does provide:
22:50:22 <hunteriam> Haskells unpopular mainly, and too divergent to expect my peers to learn for a product
22:50:27 <Cale> performRequestsAsync :: (Traversable f, MonadWidget t m) => Event t (f XhrRequest) -> m (Event t (f XhrResponse))
22:50:31 <ontop> Dtgr: Can this load/unload modules dynamically?
22:50:39 <hunteriam> It's a language for people who really like writing useful/general code IMO
22:50:40 <pharaun> so many conv at once
22:50:44 * pharaun rereads what Cale is saying
22:50:49 <ReinH> Cale: clever girl
22:50:58 <jle`> haskell's a good language for someone who wants to write maintainable code
22:51:09 <jle`> and cares about correctness
22:51:15 <Cale> By using the pair instance of Traversable here, you can pair up the requests with whatever tags you like, and those same tags come back on the corresponding responses
22:51:16 <Dtgr> ontop: yeah. although it's not working anymore if I remember correctly :D but it used to work
22:51:20 <pharaun> Cale: AH yes, i have ran into this before yes
22:51:23 <Cale> You actually don't need anything else
22:51:24 * hunteriam blinks
22:51:29 <ontop> Dtgr: Ruined by newer GHC?
22:51:30 <hunteriam> I've got no idea what you're doing Cale
22:51:33 <pharaun> wanting to tag my requests with a value to do something with it when i get it back
22:51:56 <hunteriam> Or really, I've got no idea how you thought to do it
22:51:57 <Cale> hunteriam: Well, perhaps I should introduce the surrounding ideas a little better.
22:52:07 <hunteriam> No sorry it makes sense
22:52:13 <hunteriam> I just can't imagine how you came up with it
22:52:14 <pharaun> Cale: OH!
22:52:19 <pharaun> Cale: so (tag, event)
22:52:28 <Cale> yeah, (tag, request)
22:52:32 <pharaun> and the fact that it runs on over traversable and it returns the 2nd bits
22:52:32 <ontop> jle`: I understand that, I don't always see how in Haskell though. I love QuickCheck and the basics. But monad-spam and imperative-like code (IO specifically) seems awful.
22:52:33 <Cale> and (tag, response)
22:52:36 <pharaun> to the code, and etc
22:52:47 <Dtgr> ontop: yeah, I used hotswap earlier and had to change it to ghc-api and messed up somehow. I actually didn't realize that very quickly and then haven't had the interest to fix it
22:52:58 <pharaun> Dtgr: oh you got hotswap in? nice
22:53:03 <pharaun> i haven't bothered to implement that on mine
22:53:06 <jle`> ontop: quickcheck isn't what i'm talking about; i'm talking about the type system
22:53:07 <Cale> A pair is a container which holds one element, and additionally has a tag which goes along with the container
22:53:08 <hunteriam> Ontop personally never had to deal with monad spam so it may be more of a nightmare than a reality
22:53:29 <jle`> you get a lot of maintainability and correctness and safe refactorability out of just the type system alone
22:53:38 <pharaun> Cale: that's an excellent example, i like that
22:53:40 <jle`> refactor without fear of introducing new bugs
22:53:43 <Dtgr> pharaun: yeah. hotswap was nice and easy
22:53:45 <Cale> If you have something that'll work for any container, it'll also work for labelled boxes :)
22:53:53 <pharaun> Dtgr: nice, its busted atm ?
22:53:57 <pharaun> cos i wouldn't mind digging into how you did it
22:54:04 <hunteriam> I only wish Haskell could evolve faster
22:54:22 <jle`> also there's nothing wrong with imperative code when the problem naturally is imperative
22:54:31 <Dtgr> pharaun: yeah. it got broken somehow IIRC
22:54:34 <Cale> ontop: IO is pretty great actually
22:54:37 <ontop> jle`: Most modern compiled languages do that? The type system in Haskell is great, but there are other nice ones.
22:54:37 <jle`> it's just that people apply imperative approaches where it doesn't make sense, in other languages, when they're forced to
22:54:44 <Cale> ontop: Haskell is my favourite imperative language
22:54:53 <jle`> ontop: not most, actually; i've worked with most modern compiled languages
22:55:02 <jle`> the type system in haskell is stronger than is immediately obvious
22:55:06 <pharaun> ^
22:55:08 <jle`> especially with parametric polymorphism
22:55:20 <pharaun> Dtgr: ok, still should give me some basis of stuff to poke at, thanks :)
22:55:20 <ontop> I think Haskell's type system is the best I've seen personally.
22:55:25 <jle`> parametric polymorphism in haskell brings safety that no other type systems can achieve
22:55:33 <Cale> jle`: Well, "no other"
22:55:35 <pharaun> there's supposedly dependent types which are supposedly more powerful
22:55:37 <pharaun> but *shrugs*
22:55:41 <jle`> Cale: heh, yeah
22:55:43 <pharaun> those comes with their own kettle of ... problems
22:55:47 <ReinH> Well, except those that also have it
22:55:51 <jle`> compared to Java, C++, C#, etc.
22:55:57 <hunteriam> I think Haskell also just makes you a better programmer
22:56:04 <hunteriam> Understanding the ideas is so damned valuable
22:56:14 <ontop> I think I get most of them.
22:56:15 <jle`> parametric polymorphism is great, and its usefulness is not immediately obvious
22:56:20 <Cale> Haskell's type system is pretty weak in the grand s... uh, the overall picture
22:56:26 <ontop> I think I need to run through the gauntlet now.
22:56:31 <ontop> Cale: says who!?
22:56:33 <reactormonk> hunteriam, might also be the other way round - bad programmers don't understand haskell?
22:56:34 <jle`> and also using `Maybe` instead of nullable values, etc.
22:56:35 <ontop> I thought it was really good :(
22:56:43 <ReinH> pharaun: I'm pretty confident that dependent types exist.
22:56:49 <hunteriam> reactormonk: everyone starts bad
22:56:49 <Cale> ontop: Well, when you consider what type systems like Coq's and Agda's can express
22:56:58 <jle`> ontop: it's really hard to appreciate until you've been in the trenches and tried to maintain projects for more than a few months
22:57:08 <pharaun> ReinH: nah they exists, and there's stuff like iris, etc... just that they have different tradeoffs
22:57:17 <reactormonk> hunteriam, and at a certain point, you get good enough to understand haskell. Like a rite of passage.
22:57:20 <ontop> jle`: I have, but I haven't got a comparison with Haskell.
22:57:22 <pharaun> at least for me right now haskell is in that sweet spot for typesystem/etc for me
22:57:25 <Cale> ontop: You can reasonably formalise all of mathematics in Coq's type system, and your programs become computer-checked proofs of the theorems which your types represent.
22:57:36 <pharaun> when i get better at various stuff, i probably will pick up on ie Coq, etc
22:57:43 <hunteriam> reactormonk: I mean it's not so 1dimensional, Haskell type skills aren't the mark of a good programmer
22:57:45 <jle`> also, Haskell can express higher-kinded types, which also lets you state a lot stronger things
22:57:46 <ontop> That's interesting.
22:58:00 <reactormonk> hunteriam, I agree. Just trolling a bit.
22:58:06 <hunteriam> Cale all of mathematics?
22:58:12 <pharaun> heh
22:58:13 <Cale> hunteriam: yeah
22:58:19 <pharaun> P == NP!
22:58:34 <pharaun> or whatever was it... femat's last theorm (the proof was a bit long)
22:58:36 <jle`> ontop: but yeah, imperative programming is a blast in haskell, too :3
22:58:57 <jle`> haskell can make your imperative programs more correct, as well
22:59:31 <ontop> It all looks so awful when I look at it. I guess I have to try more of it to get a handle on it.
22:59:33 <Cale> ontop: You can think of Haskell's type system in a similar way, but it's an inconsistent logic because of general recursion, and you can't express a whole lot of interesting things because it's not dependently typed: your quantifiers only range over types, and not values
22:59:49 <jle`> maybe we're looking at different code
23:00:06 <hunteriam> Is there a combinator I could write for servant to require an other
23:00:13 <ReinH> You can write bad code in any language
23:00:46 <hunteriam> To prepend a field to every route and act on the data?
23:00:48 <ReinH> And unfamiliar things will look unfamiliar
23:00:49 <jle`> the way i see it, you can use Haskell where you'd use any other language, except get more type safety, correctness, maintainability, expressiveness, etc.
23:01:08 <jle`> just pop it in and get instant benefits :D
23:01:31 <Cale> ontop: But yeah, as far as languages in which it's easy to get everyday work done today, Haskell's type system is top notch
23:01:41 <ontop> Cale: When are we going to see Haskell with dependent types!?
23:01:54 <pharaun> there's bits n' pieces *shrugs*
23:01:59 <pharaun> some folks are trying to drag in more
23:02:15 <pharaun> i'm not very familiar with those bits so i don't know what to say about them
23:02:29 <Cale> ontop: It's a bit of a research problem, from what I understand, how dependent types should interact with non-strict semantics
23:02:42 <ontop> Hm.
23:02:58 <Cale> Of course, it's a bit of an issue that I don't think anyone's really trying too hard at that directly.
23:03:17 <Cale> Haskell is sort of edging closer to being a dependently typed language through its extensions
23:03:35 <hunteriam> Also don't dependant types require a lot more runtime type checking?
23:03:39 <hunteriam> Or something to that effect
23:03:44 <Cale> But at some point, a lazy dependently typed language really needs to be a thing
23:03:50 <Cale> It'll probably not be Haskell
23:04:01 <Cale> Because there would be enough syntactic changes you'd want to make
23:04:07 <Cale> I dunno, maybe it could be...
23:04:45 <MarcelineVQ> Let's invent it right now, I wanna call it Henry
23:04:58 <Cale> If you don't care about nonstrict semantics / laziness, then Idris is a valiant effort to make a dependently typed language which is useful for practical tasks
23:05:09 <hunteriam> I'd like it if Haskell could reduce the variety of syntax it has
23:05:26 <ontop> I can't read this book in detail anymore
23:05:35 <ontop> It's going on too long about Traversables etc.
23:05:38 <Cale> heh, maybe we should call it Elba, just so the same wrong links show up whenever you try to google it
23:05:39 <ontop> I think I have to skim to the end :(
23:05:44 <jle`> ~!.
23:06:04 <Cale> ontop: What book are you reading?
23:06:05 <ianhedoesit> Cale: lol
23:06:18 <ontop> Cale: Haskell Programming - From first principles
23:06:21 <ontop> bitemyapp's
23:06:31 <Cale> ontop: ah, cool, I haven't read it yet
23:06:41 <ontop> It's good.
23:06:43 <Cale> Well, I read bits of some unfinished chapters
23:06:45 <ontop> But super super dry.
23:06:54 <hunteriam> Cale what do you gain from reading a book on something you understand?
23:06:55 <ontop> I'm dying trying to finish it.
23:07:05 <ontop> Good book tho.
23:07:11 <Cale> hunteriam: I get to provide bitemyapp with the feedback he asked for
23:07:18 <hunteriam> Ah
23:08:08 <hunteriam> Cale how did you come to learn so much about Haskell and these things anyways
23:08:23 <Cale> I started learning Haskell in 2001
23:08:36 <Cale> and I have a degree in pure mathematics
23:08:45 <hunteriam> A graduate degree?
23:08:50 <Cale> No, just a BMath
23:08:57 <Cale> from Waterloo
23:09:02 <hunteriam> Neat
23:09:05 <hunteriam> Currently doing the same
23:09:06 <Cale> I took a lot of cross-listed grad courses
23:09:20 <hunteriam> Definitely at least partly inspired by this community
23:09:21 <ontop> Canadian? :D
23:09:23 <Cale> (4 year degree)
23:09:24 <Cale> yeah
23:09:28 <ontop> Hooray me2
23:09:39 <hunteriam> Cross listed grad courses intimidate the hell out of me
23:09:41 <Cale> Brantford, Ontario here
23:09:47 <ontop> Vancouver
23:09:51 <ontop> we had snow today :(
23:09:51 <hunteriam> Which ones did you pick if any stood out
23:11:37 <hunteriam> .
23:11:52 <hunteriam> Ignore that
23:12:23 <mgsloan> I'd recommend sitting in on grad courses, worked well for me.  Certainly dispelled some of the intimidation factor with taking them
23:12:39 <hunteriam> Which ones did you pick
23:12:43 <Cale> I took Algebraic Graph Theory, Algebraic Topology, Algebraic Combinatorics, Algebraic Number Theory, Algebraic Geometry, Functional Analysis, Measure Theory and Integration, Fields and Galois Theory, Noncommutative Algebra
23:12:58 <hunteriam> Keyword algebra
23:12:59 <Cale> I think that's all of them...
23:13:09 <hunteriam> That certainly is a lot
23:13:10 <ontop> Man.
23:13:15 <hunteriam> Seems like 4 semesters worth
23:13:16 <ontop> I have none of those
23:13:18 <ontop> Can I do Haskell!?
23:13:23 <Cale> Algebraic Graph Theory I took in 2nd year
23:13:23 <hunteriam> Nope! Bye!
23:13:24 <Cale> lol
23:13:26 <MarcelineVQ> ontop: easily
23:13:42 <hunteriam> How'd you find the time for all that Cale
23:13:58 <Cale> Well, I didn't take many electives, and instead did more math courses
23:14:25 <hunteriam> You must've started quite early in college though?
23:14:27 <Cale> I often bit off more than I could chew, but I learned a lot
23:14:31 <Cale> hm?
23:14:41 <hunteriam> To fit all those courses in
23:14:46 <hunteriam> We are talking about college right?
23:14:49 <ontop> hunteriam: lol.
23:14:51 <ontop> Now I'm sad :(
23:14:57 <hunteriam> Why?
23:15:08 <hunteriam> Oh sorry I was kidding
23:15:10 <Cale> I did 5 courses per term, terms are 4 months, and I'd usually be at uni for two of them per year
23:15:14 <hunteriam> You'll be absolutely fine
23:15:33 <Cale> and I did pick up an extra summer term at one point with a few courses
23:15:47 <hunteriam> I mean but surely the majority of your courses had to be actual undergrad courses
23:16:30 <ontop> Alright. I looked at Reader and almost died.
23:16:34 <ontop> Time to give up for tonight.
23:16:50 <MarcelineVQ> don't skip stuff :>
23:16:50 <hunteriam> I don't know a thing about reader
23:16:52 <Cale> hunteriam: Well, these were 400/600 cross-listed, so most of them I took in 4th year
23:17:16 <Cale> There's only 9 courses there, and I took 10 courses in 4th year
23:17:17 <hunteriam> In which case you must have taken nothing but grad courses that year?
23:17:17 * python476 just enrolled an approximation / graph algorithm MOOC .. 
23:17:23 <Cale> But I didn't take all of those in 4th year
23:17:46 <Cale> Yeah, most of the 4th year courses were cross listed
23:17:50 <hunteriam> I'm envious because I don't think I could possibly fit all that learning into my undergrad degree
23:18:03 <ontop> MarcelineVQ: I understand Monads I think now. But Traversable and Reader are beyond me atm.
23:18:06 <ontop> I think I got Foldable.
23:18:17 <Cale> I didn't take any CS courses past 2nd year though
23:18:31 <Cale> and like only 3 physics courses
23:18:44 <python476> what does cross listed means ?
23:18:46 <jle`> ontop: i think for any typeclass, it's probably easiest to ignore the typeclass and just look at specific instances
23:19:00 <Cale> python476: Both undergraduates and graduate students take the course
23:19:15 <Cale> Heh, algebraic combinatorics was funny
23:19:21 <python476> Cale: thanks
23:19:31 <Cale> The undergrads were way better prepared than most of the graduate students coming from elsewhere
23:19:41 <hunteriam> I won't say it's good to skip stuff but I don't think it's all essential
23:19:42 <ontop> jle`: Interesting advice.
23:19:43 <Cale> because Waterloo's combinatorics in undergrad is strong
23:19:58 <jle`> ontop: what do you think [IO a] -> IO [a] would do?  it'd potentially take a list of IO actions and return a new one that executes all of the IO actions and collects their results in a list
23:20:28 <jle`> `sequence [getLine, readFile "hello", getLine]` would be an IO action that executes getLine, readFile "hello", and getLine, and the result would be a list of all of their results
23:20:38 <jle`> that's what sequence does for lists
23:21:07 <jle`> what do you think a `Maybe (IO a) -> IO (Maybe a)` would do?
23:21:19 <ontop> That's... a good question.
23:21:24 <jle`> maybe, if the Maybe is a `Just` with an IO action, it would execute that action
23:21:32 <ontop> That's what I thought
23:21:33 <ontop> But
23:21:34 <jle`> and, if it's nothing, it'd just be a no-op, `return Nothing`
23:21:40 <ontop> Why would it give me IO Back?
23:21:43 <ontop> That's one thing I struggle with
23:21:46 <ontop> When does IO -end-
23:22:00 <jle`> an `IO a` is an IO action that produces an `a` when executed
23:22:13 <jle`> so an `IO (Maybe a)` is an IO action that produces a `Maybe a` when executed
23:22:42 <jle`> a `Maybe (IO a)` is a value that might contain an IO action...or it might not
23:22:52 <jle`> so maybe you'd write something like
23:23:18 <jle`> :t \mio -> case mio of Just act -> do x <- act; return (Just x)
23:23:19 <lambdabot> Monad m => Maybe (m a) -> m (Maybe a)
23:23:39 <jle`> if there *is* an action in there, then execute it!
23:23:40 <ontop> Yeah.
23:23:42 <ontop> But
23:23:47 <jle`> if there isn't, then `return Nothing`, no-op
23:23:47 <ontop> You return (Just x)
23:23:51 <ontop> Which is IO (Just x)
23:23:52 <ontop> Rite?
23:24:00 <ontop> Or rather
23:24:04 <ontop> It's whatever Monad that is
23:24:07 <ontop> It just happens to be IO
23:24:08 <jle`> return (Just x) is a no-op that returns `Just x`
23:24:10 <jle`> yeah
23:24:16 <ontop> But it's still wrapped in IO
23:24:23 <ontop> When can I stop using IO? And just have happy beautiful values again?
23:24:32 <jle`> IO *is* a value
23:24:53 <Cale> er
23:24:56 <Cale> IO is a type constructor
23:24:58 <jle`> heh
23:25:08 <jle`> a value of type `IO a` *is* a value
23:25:11 <ontop> So can I unpack it with a function like: rofl (IO x) = x
23:25:13 <Cale> yes, haah
23:25:14 <ontop> ?
23:25:15 <jle`> just like a value of that type `a` would be
23:25:29 <jle`> ontop: no, an `IO Int` doesn't contain an Int
23:25:32 * hackagebot yaml-union 0.0.1 - Read multiple yaml-files and override fields recursively  https://hackage.haskell.org/package/yaml-union-0.0.1 (michelk)
23:25:37 <Cale> ontop: Unfortunately, it's an abstract type, so you don't have access to the constructors
23:26:02 <jle`> @quote ls
23:26:02 <lambdabot> ReinH says: <ReinH> You know what would also be nice? <ReinH> A channel where we talk about Haskell.
23:26:05 <jle`> oops
23:26:09 <Cale> ontop: But you can imagine that a value of type IO String is like a syntax tree for actions to be performed that would result in a String if you carried them out
23:26:09 <jle`> @quote /bin/ls
23:26:09 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
23:26:22 <jle`> ontop: an `IO a` isn't a "wrapped up a"
23:26:39 <Cale> It's a program which produces a value of type a if executed.
23:26:45 <jle`> it's just a description of an actio that, when executed by an interpreter, produces an `a`
23:27:25 <ontop> Right.
23:27:31 <ontop> So I guess my question is.
23:27:42 <ontop> Hmm.
23:27:48 <ontop> I think I answered it in my own brain with an example.
23:27:53 <MarcelineVQ> `How do I use my String -> String function on an IO String` ?
23:28:04 <Cale> Like, you probably shouldn't think of getLine as containing a String
23:28:04 <ontop> That's kind of what I was getting at MarcelineVQ.
23:28:14 <jle`> you *can* use an `IO a` if you had an `a -> b`
23:28:14 <Cale> It's going to ask the user for a String, and produce that when it's run
23:28:23 <jle`> fmap :: (a -> b) -> IO a -> IO b
23:28:33 <Cale> ontop: Okay, so inside a do-block, you can write
23:28:36 <Cale> v <- x
23:28:39 <Cale> where x :: IO t
23:28:42 <Cale> and then v :: t
23:28:47 <ontop> Yea.
23:28:52 <jle`> it takes an `IO a`, a description of an IO action that produces an a, and returns a new IO action, of type `IO b`, that describes an IO action that produces a b
23:29:01 <Cale> which means "execute the IO action x, and name whatever its result is v"
23:29:14 <Cale> The do-block as a whole will then itself be an IO action
23:29:19 <jle`> and it does that by creating an action that executes the original action and applies the given function to the result
23:29:28 <ontop> Where does the IO action end though??
23:29:28 <Cale> and its result will be the result of whatever was the last action in the block
23:29:41 <jle`> ontop: well, most useful programs are IO actions, aren't they?
23:29:41 <Cale> Eventually, you define main to be an IO action
23:29:44 <ontop> Yeah, but all the do block stuff returns an IO ()
23:29:51 <jle`> the whole point of writing a program is to describe an IO action
23:29:54 <jle`> and then let the computer execute it
23:29:56 <Cale> and in a compiled program, main is executed
23:29:57 <ontop> jle`: That... kinda makes sense lol.
23:29:59 <jle`> right?
23:30:10 <Cale> and in turn, it will be built up in terms of simpler IO actions
23:30:16 <ontop> It's just like sort of prolific throughout the code and it makes me sad :(
23:30:16 <Cale> (generally)
23:30:17 <jle`> the entire point of writing most haskell programs is to describe the actual IO action that you want
23:30:20 <ontop> Maybe it's good though?
23:30:34 <hunteriam> ontop: you can separate your IO code from your pure code
23:30:40 <jle`> for example, let's say I wanted to write a program that read in files and processed them and spit them out to a stream
23:30:42 <Cale> ontop: Throughout what code? There are techniques for reducing the amount of code which uses IO directly.
23:30:51 <jle`> my goal: write an IO action that reads in files, processes them, and spits them out to a stream
23:31:12 <Cale> ontop: But if the program actually concerns itself with mostly stuff which is about input and output, with very little processing, maybe a lot of it belongs in IO
23:31:14 <jle`> and then in the end, write `main = thatIOActionThatI'mDescribing`
23:31:40 <Cale> ontop: If you're familiar with OOP, it may be helpful to think of it in terms of MVC
23:32:11 <ontop> I think I get it honestly.
23:32:20 <Cale> The pure part of your program is like the model (and often parts of the view and controller), but the view and controller are going to contain real IO code
23:32:21 <ontop> I need to actually write some of this stuff.
23:32:29 <ontop> The only Haskell I've ever written is pure.
23:32:49 <jle`> well, all haskell is pure, so ;)
23:32:55 <python476> Cale: write an article about the Monad / MVC relationship, and enjoy the web fire
23:33:05 <Cale> Oh, but I said nothing about monads
23:33:07 <jle`> but yeah, most of my haskell work deals with things not in IO actions
23:33:17 <Cale> I said stuff about IO, which only happens to be a monad
23:33:36 <python476> true, I was mistaken
23:33:37 <Cale> The fact that IO is a monad is pretty unimportant, it just saves us from writing some combining functions
23:33:45 <jle`> yeah, none of this has anything to do with monad :O
23:34:01 * python476 ducks back into the shadows
23:34:04 <Cale> Well, it's important to know that IO is a monad when you're using it of course
23:34:09 <ontop> Cale: Because we could just use fmap and join rite!?
23:34:14 <Cale> Because we do rely on that to provide a bunch of stuff
23:34:28 <Cale> ontop: No, I mean, we could use non-generic versions of those
23:34:33 <ontop> Oh :(
23:34:34 <Cale> specialised to IO
23:34:34 <jle`> ontop: more like, so we can re-use functions like `replicateM`, `sequence`, etc.
23:35:01 <jle`> the fact that IO has a Monad instance means that we can use `sequence` and `forM_` and fun stuff like that with IO
23:35:07 <Cale> Yeah, the fact that IO is a monad just means we get to use the stuff from Control.Monad and elsewhere which works with all monads, rather than being forced to write it again
23:35:11 <Cale> specifically for IO
23:35:17 <jle`> but if it didn't have a Monad instance, it'd be just as useful
23:35:25 <koz_> If I wanna use classy-prelude with numeric-prelude, am I gonna have incompatibilities or collisions?
23:35:30 <Cale> But if we didn't have the Monad abstraction, we'd have just written that stuff specially for IO and that would be it
23:36:11 <ontop> So
23:36:26 <ontop> I don't get Foldable (mostly when to use it), Traversable
23:36:33 <ontop> Can I write an irc bot!?
23:36:40 <koz_> ontop: Foldable is 'things which know how to fold themselves'.
23:36:55 <jle`> you can write an IRC bot
23:37:01 <MarcelineVQ> ontop: sure, in fact it's a great exercise! https://wiki.haskell.org/Roll_your_own_IRC_bot
23:37:04 <jle`> Foldable isn't necessary to 'get' in order to use its methods
23:37:11 <jle`> neither is Traversable
23:37:21 <jle`> what's important isn't the typeclasses
23:37:23 <jle`> what's important is the types
23:37:30 <python476> these a FT in FTP
23:37:32 <jle`> you're going to be working with actual types for the most part
23:37:35 <python476> what's the P again ?
23:37:46 <MarcelineVQ> proposal
23:37:47 <jle`> ignore Foldable and Traversable.  worry about the types you're using
23:37:56 <ontop> K.
23:37:58 <ontop> I'll try it.
23:38:01 <ontop> Later.
23:38:03 <jle`> if you're using lists, just know that you have a very handy sequence :: [IO a] -> IO [a] you can use
23:38:12 <jle`> for the most part, the methods are basically bags of utility functions
23:38:18 <MarcelineVQ> python476: or 'prelude' https://wiki.haskell.org/Foldable_Traversable_In_Prelude
23:38:27 <python476> ha ! right
23:38:33 <jle`> if you're using Maybe, know that you have a very handy Maybe (IO a) -> IO () you can use
23:38:41 <jle`> "execute it if it's there, don't execute anything if there isn't anything!"
23:39:01 <jle`> you also have a very handy Maybe a -> (a -> IO ()) -> IO () you can use
23:39:03 <python476> And Prelude is to sequence ludeables in prefix order... 
23:39:22 <jle`> if you're using lists, you have a handy (a -> IO b) -> [a] -> IO () you can use
23:39:28 <jle`> etc.
23:39:34 <MarcelineVQ> python476: sounds legit
23:39:38 <jle`> but they're not useful because they're in FOldable, Traversable
23:39:44 <jle`> they're useful because lists are useful
23:39:50 <jle`> they're useful because IO, the type, is useful
23:39:55 <jle`> they're useful because Maybe is useful, etc.
23:41:17 <ontop> jle`: Well, I'll try to reason about the typeclasses via their instances.
23:41:21 <ontop> It's good advice really.
23:43:13 <potatoe> hello, I've the following code for working with Servant
23:43:14 <potatoe> http://lpaste.net/148511
23:43:35 <potatoe> but I want to store a connection pool in Config
23:44:05 <potatoe> but connection pool using Data.Pool gives IO (Connection a) while I need it to store Connection
23:52:56 <hunteriam> I have a type Authorize t = SomeServantThing :> t, how can I recursively distribute this over large servant apis?
23:53:28 <hunteriam> i.e., I want Authorize ( Servant1 :<|> Servant2) = Authorize Servant1 :<|> Authorize Servant2
23:53:32 <jle`> they're useful because Maybe is useful, 
23:53:45 <jle`> oops, sorry
23:54:15 <jle`> ontop: what i'm saying is, ignore the typeclasses altogether as a red herring :)
23:54:32 <jle`> as in, don't try to directly look for a grand unified understanding of the typeclass
23:54:56 <jle`> it'll come over time, using the specific types.  after a certain point, you won't need to ask anymore :)
23:54:58 <ontop> jle`: But why not? My book basically wants me to understand their cores.
23:55:21 <jle`> because they're often not relevant for practical usage
23:56:19 <ontop> I c.
23:56:31 <ontop> I guess I should just read the chapter on Reader
23:56:36 <ontop> And then put the book down.
23:57:03 <jle`> what book is this, btw?
23:57:24 <potatoe> hi does anyone know how to pass an IO (Connection a) pool into my Config object?
23:57:25 <potatoe> http://lpaste.net/148511
23:57:30 <ontop> bitemyapp's, Haskell Programming (from first principles)
23:57:31 <MarcelineVQ> bitemyapp's book
23:57:54 <potatoe> the issue is Data.Pool creation gives an IO Connection a while I need a Connection a pool to pass into connect later.
23:58:01 <jle`> oh neat
