00:00:01 * hackagebot opencog-atomspace 0.1.0.3 - Haskell Bindings for the AtomSpace.  https://hackage.haskell.org/package/opencog-atomspace-0.1.0.3 (romanT)
00:00:27 <vigs> ReinH: That there's a bug, or that cabal doesn't have permission?
00:00:47 <ReinH> both
00:01:11 <vigs> FWIW, I found this thread by googling the error, so it's not exclusive to me: https://github.com/haskell/cabal/issues/2653
00:02:57 <ReinH> vigs: ah, that stupid 10.11 stuff. Did you try the solution in that issue?
00:03:14 <ReinH> leave it to OS X to break *nix
00:03:57 <pikajude> yeah, haskell's implementation of the access checker incorrectly reports that executable files are not executable
00:05:52 <vigs> ReinH: Not yet, I went down a rabbit hole reading stuff on hoogle :P
00:08:10 <ali_bush> how do you lift a function (Either Object (Int64, Int64)) -> (Int64, Int64) into Neovim r st (Either Object (Int64, Int64))
00:08:34 <ali_bush> basically i want to go from Neovim r st (Either Object (Int64, Int64)) ro Neovim r st (Int64, Int64)
00:08:48 <ali_bush> s/ro/->/
00:10:33 <liste> ali_bush what are you exactly trying to do?
00:10:43 <liste> @paste
00:10:43 <lambdabot> Haskell pastebin: http://lpaste.net/
00:11:27 <ReinH> ali_bush: well, can you fmap it?
00:13:40 <liste> ali_bush if "f :: Neovim r st (Either Object (Int64, Int64))", then you could "do (Right x) <- f; return x"
00:13:53 <liste> note that it may call `fail'
00:14:50 <ali_bush> http://lpaste.net/149083
00:15:58 <ali_bush> ah wait..   my positionM is wrong,  im creating a nested Neovim
00:16:29 <frerich> Something like 'data List a = Empty | Cons a (List a)' would be called a 'regular' recursive type, right?
00:17:18 <frerich> If so, then 'data List a = Empty | Cons a (List (a,a))' would be a non-regular recursive type?
00:18:05 <shachaf> Yes, those types would be called those things.
00:18:07 <frerich> I hit the problem (again) of how to define a fold for the latter. The former is straightforward, but for the latter I'm unsure what the type of the fold should be.
00:19:06 <frerich> I.e. for the former I could define 'foldList :: b -> (a -> b -> b) -> List a -> b'. For the latter, it's unclear to me what to do about the recursive part, i.e. 'foldList :: b -> ??? -> List a -> b'.
00:19:32 <liste> ali_bush is window_get_position a Neovim action?
00:19:51 <liste> or a regular function
00:20:06 <ali_bush> window_get_position :: Window -> Neovim r st (Either Object (Int64, Int64))
00:20:15 <liste> then you need to use bind instead of fmap
00:20:38 <liste> positionM = vim_get_current_window >>= window_get_position
00:20:54 <aleator> I've got a creepy problem. I have a shared lib (.so) which uses basler pylon5 usb-camera library. If I load that so from python, it works nicely, but it just hangs when called from ghc compiled code (either linking or dlopening it). strace shows a lot of SIGVTALRMs..
00:20:54 <wedens> why does hpc say that some guard is always True when all cases are covered by test?
00:20:55 <ali_bush> yeah thanks....
00:21:26 <liste> ali_bush that is the same as "do win <- vim_get_current_window; window_get_position win"
00:21:26 <ali_bush> im so close to having another **dance around the room** moments :)
00:21:36 <wedens> hm. it always happens on `otherwise` guards
00:21:52 <liste> @undo do win <- vim_get_current_window; window_get_position win
00:21:53 <lambdabot> vim_get_current_window >>= \ win -> window_get_position win
00:30:01 <jle`> is it safe to install packages globally with stack
00:30:03 <jle`> becaus ei just did
00:30:12 <jle`> it's supposed to just work itself out, right .....
00:31:35 <aleator> Hmm.. How can I stop ghc-runtime from emitting SIGVTALRM during a foreign function call?
00:41:01 <pavonia> aleator: The mysql package uses a C wrapper to disable these signals on the foreign function calls, see https://hackage.haskell.org/package/mysql-0.1.1.8/src/cbits/mysql_signals.c
01:19:03 * hackagebot postgresql-schema 0.1.10 - PostgreSQL Schema Management  https://hackage.haskell.org/package/postgresql-schema-0.1.10 (markfine)
01:19:03 * hackagebot opencog-atomspace 0.1.0.3 - Haskell Bindings for the AtomSpace.  https://hackage.haskell.org/package/opencog-atomspace-0.1.0.3 (romanT)
01:24:05 * hackagebot cayley-client 0.1.5.0 - A Haskell client for the Cayley graph database  https://hackage.haskell.org/package/cayley-client-0.1.5.0 (MichelBoucey)
01:31:22 <aleator> pavonia: Thanks! I'll take a look
01:41:34 <aleator> pavonia: It works! Thank you so much!
01:41:52 <jgoux> Hello
01:41:57 <jgoux> Any user of stack + spacemacs ?
01:42:23 <boj> jgoux: i am
01:42:37 <jgoux> I try to set up the haskell layer for spacemacs, and it needs some dependencies to be installed (stylish-haskell hlint hasktags ghc-mod)
01:42:38 <pavonia> aleator: No problem
01:43:00 <jgoux> Do I have to install these dependencies per project, or globally by executing "stack install stylish-haskell hlint hasktags ghc-mod" in my home directory ?
01:43:20 <boj> jgoux: globally is idea, they will go in ~/.local/bin
01:43:28 <jgoux> boj: ok thank you :D
02:05:06 <ruzzz> hi
02:19:21 * hackagebot atrans 0.1.0.0 - A small collection of monad (transformer) instances.  https://hackage.haskell.org/package/atrans-0.1.0.0 (apho)
02:26:10 <bernalex> I'm in a meeting where it's claimed that haskell will lead to spaghetti code if you scale it, whilst PHP scales properly since it's OOP, pls send halp
02:26:25 <merijn> bernalex: Abandon ship
02:26:38 <merijn> bernalex: Smile and nod politely while slowly backtracking :p
02:26:48 <bernalex> merijn: do you know a job where I can work from Trondheim with free software? srs question!
02:27:04 <merijn> bernalex: I'm a phd student, do I look like I know about getting paid? :p
02:27:25 <bernalex> merijn: lol I'm hopefully starting a phd this year, so I need a part-time gig to fund it
02:29:18 <Gurkenglas> Tell them to tell you a problem to solve and after solving it to tell you a way to extend it in order to observe spaghettification?
02:30:25 <Gurkenglas> Of course the ulterior motive is to have them see that the problem they gave you to solve is a one-liner :P
02:30:38 <mauke`> hit them with the expression problem
02:31:00 <Gurkenglas> Nah any language can give an example of some problem where it scales well right
02:31:01 <liste> bernalex wtf, is that for your company?
02:31:15 <liste> are the clients claiming that? or competitors?
02:31:53 <Gurkenglas> Your coworkers, while you're choosing a programming language to use, right?
02:32:09 <mauke`> http://thedailywtf.com/articles/the-flasher
02:32:15 <mauke`> can't do that with haskell!
02:33:29 <liste> bernalex tell them about "Haskell's overlooked object system" to make them shut up (:
02:33:31 <Gurkenglas> Looks like... memoization?
02:33:33 <earthy> bernalex: both PHP and Haskell will lead to shitty tangled messes if scaled *improperly*. *if* the team doing the scaling understands PHP but not Haskell, the statement as such is no direct reason to retreat.
02:33:59 <liste> and, PHP isn't exclusively OOP either
02:34:00 <bernalex> liste: it's not my company, the new MD made very clear, lol. it's a new guy he's hired who's saying it.
02:34:24 <earthy> bernalex: However, most probably the person making the statement does not have the level of understanding required to make that statement
02:34:50 <bernalex> earthy: he did ask if haskell was OOP immediately before that statement
02:35:51 * earthy laughs
02:36:00 <earthy> that is a *stupid* question
02:36:20 <earthy> (you can write object oriented programs in assembly)
02:36:48 <earthy> as I stated, 'probably does not have the level of understanding required'
02:36:50 <Gurkenglas> Hearing that, I would think he means to ask "Will my experience with object oriented languages help me in Haskell"
02:38:34 <tdammers> asking whether a language "is an OOP language" hints at a relatively limited understanding of programming paradigms in general
02:39:00 <earthy> Gurkenglas: that might be the positive spin on it. given the hubris implied in 'programmer' I'd venture a guess that he does not mean that consciously at the very least
02:39:05 * earthy agrees with tdammers
02:40:29 <tdammers> if the question were coming from a programmer, I would assume that they're relatively new to the game, and offer to take them under my wing; otherwise, I would assume that the person in question is trying to talk about stuff that they have absolutley no business talking about
02:41:08 <bernalex> tdammers: he has been a programmer for years and years, exclusively in php apparently
02:41:20 <earthy> bernalex: ah. one to be trained. :)
02:41:38 <earthy> (but 'programmer for years and years' implies that he doesn't necessarily see it that way)
02:41:40 <bernalex> earthy: he's the new hire who's effectively in charge of me. don't you just love authority.
02:41:41 <tdammers> I get the impression though that this comes from a person whose world view encompasses "shitty non-OOP imperative PHP" and "less shitty OOP PHP"
02:41:51 <frerich> bernalex: http://4.bp.blogspot.com/-9G4nrHC53N8/UT9IHiIArXI/AAAAAAAABY0/dhSUFXEVilI/s1600/debugger.gif
02:42:11 <bernalex> frerich: yeah
02:42:27 <Gurkenglas> (Oh hey that atrans thing hackagebot just posted looks like what i was talking about with "MonadIO m => Identifier -> StateT s m a -> m a")
02:42:49 <earthy> bernalex: I do. that's why I'm the boss. :)
02:43:01 <tdammers> i.e., said person has learned that OOP is a weapon that can be used to fight complexity, but it is the *only* weapon they know, so their world is divided into "OOP === good" and "Not OOP === spaghetti code === bad"
02:43:24 <tdammers> also, blub programmer paradox
02:43:27 <earthy> he probably hasn't seen the light of types either
02:43:32 <earthy> given PHP
02:43:48 <bernalex> tdammers: yep. add unwillingness to learn and the expert beginner problem, and you've got a great CTO in the making.
02:43:57 <frerich> bernalex: Trolltech (aka Nokia aka the Qt company) is based in Oslo and very open source friendly (a lot of ex KDE folks there). It's not Haskell (mostly C++) but still a nice play to work.
02:44:14 <bernalex> frerich: I wonder if they'd be into remote work
02:44:28 <bernalex> worth a shot
02:44:31 <bernalex> thanks for the idea
02:44:49 <earthy> they have offices in berlin as well
02:44:54 <earthy> and cross-office teams
02:44:54 <frerich> bernalex: That I don't know, maybe. They also shared a building with the Opera people for a long time.
02:44:58 <earthy> so they might well be.
02:46:59 <tdammers> bernalex: for some reason, people like that seem to align with PHP a lot
02:47:22 <bernalex> tdammers: PHP is very popular and simple to get going with.
02:47:35 <tdammers> yes, I know
02:47:51 <tdammers> PHP also has an addictive early learning curve
02:48:00 <bernalex> also it scales beautifully unlike that spaghetti code language haskell
02:48:14 <tdammers> when you pick up the language, it rewards you very quickly, and it keeps rewarding you for a good while
02:48:29 <tdammers> all your naive approaches to how you'd build a web application will mostly Just Work
02:48:51 <earthy> until the point where it Breaks Down Badly
02:48:52 <tdammers> until they don't, because what you've been doing all along turns out to be a very very stupid way of doing things
02:48:57 <frerich> bernalex: Also, Facebook uses PHP so it must be good (have heard that argument, too)
02:49:11 <bernalex> frerich: facebook came to their senses and had to write their own compiler and rewrite a bunch of it tho
02:49:21 <tdammers> by that time, however, you will have invested hundreds if not thousands of hours into your one precious codebase, and it'll be a horrible mess
02:49:34 <diggle> So yeah just randomly chipping in for some reason, but as a newbie haskell programmer as a newbie programmer generally i've found that I can't really build anything substancial yet, compared to not-haskell language x. Do I just keep learning more or is there something to shortcut that temporarily?
02:49:48 <bernalex> tdammers: not to mention a lot of the same people have a lot of annoying pride in things. "I spent so much time on it! I can't just change it!"
02:49:53 <tdammers> it will also be full of SQLi, XSS, Remote Code Execution, and other similar vulnerabilities, but you'll have absolutely no clue
02:50:02 <tdammers> Sunk Cost Fallacy
02:50:06 <earthy> diggle: what do you consider 'substantial'?
02:50:16 <bernalex> tdammers: yeah except its personal rather than economical
02:50:22 <frerich> bernalex: In The Industry(tm) that's commonly called "Protecting prior investment" (AKA "Throwing good money after bad").
02:50:23 <bernalex> diggle: depends on what you want to make
02:50:25 <MarcelineVQ> diggle: just keep learning, and dig into little projects that'll bring the concepts together https://wiki.haskell.org/Roll_your_own_IRC_bot
02:50:27 <tdammers> bernalex: yeah, but it still applies
02:50:50 <bernalex> MarcelineVQ: I found that really annoying :p too much outdated info etc
02:51:07 <bernalex> writing a CLI calculator with a REPL was fun tho.
02:51:10 <tdammers> diggle: Haskell's culture is somewhat hostile towards shortcuts, i.e., we don't like doing things wrong just to Get Stuff Done; we don't, in fact, consider a wrong solution "Done" usually
02:51:18 <diggle> Idk. A web app. A gui that acutlaly does something. I tried writing guess the number, but I finally had to look up how it was done (mostly because I didn't know about the relevant functions, but,)
02:51:30 <kqr> hi! imagine there's a Car type, and you have predefined the constructors Ford, Mercedes and Toyota. now you want your users to be able to define their own constructors for other makes – how would you go about this (reformulating the problem allowed) in Haskell?
02:52:03 <tdammers> diggle: which, combined with Haskell's unusual approach to programming in general and I/O in particular, means that there's a significant up-front effort before you can reach the same level of productivity as you have in you current comfort zone languages
02:52:23 <diggle> I actually came into haskell because it looked fun, but i'd like something concrete I could use and stuff
02:52:31 <tdammers> well
02:52:39 <bernalex> diggle: making a REST server is very trivial for instance. try scotty.
02:52:42 <tdammers> GUI programming is a bit of a minefield currently
02:52:48 <tdammers> web is easier, especially server-side
02:53:15 <tdammers> I second Scotty; it's easy to get started with and you'll have a simple server-side web application, or a REST-style API, in no time
02:53:30 <diggle> Nod. I think I honestly still need to study more (I still haven't looked at monads. Weird, right?) anyhow...
02:53:59 <tdammers> monads are less important and much less magical than they're made out to be
02:54:29 <tdammers> in fact, there is no magic at all, apart from do notation, which is just syntax sugar
02:55:07 <diggle> Oh. Huh. I've generally been told monads are kind of pretty hard to grasp.
02:55:28 <tdammers> monad is a rather abstract thing, so it's hard to form a suitable intuition
02:55:44 <tdammers> I think it's best to start with some concrete examples and learn how monadic operations work for each of them individually
02:56:07 <tdammers> e.g., for IO, >>= means "run the action on the left, and feed its output to the action on the right"
02:56:24 <tdammers> and >> means, run the thing on the left first, then run the thing on the right
02:56:57 <tdammers> for Maybe, >>= means "if the value on the left is Nothing, evaluate to Nothing, if it's Just something, feed that something to the function on the right"
02:57:20 <tdammers> and >> means "if the thing on the left is Nothing, ignore the thing on the right, otherwise get me the thing on the right"
02:57:34 <diggle> Huh. These all seem to follow a consistent pattern thing.
02:57:40 <tdammers> yes, they do
02:57:58 <tdammers> that's why they all use the same typeclass, namely Monad, to express these operations
02:58:06 <diggle> Nods.
02:58:26 <merijn> diggle: The problem with monads is that they're just a bunch of operations/laws, and people want "a concrete description" of what a Monad is. Which is like asking what a "group" or "field" "is" in algebra
02:58:29 <tdammers> that's why I'd suggest learning the concrete meanings for a few monad instances separately, and then at some point you'll develop an intuition
02:58:57 <tdammers> then go back to the formal definitions and see how they relate to your intuition
02:59:38 <merijn> diggle: Also, imo people gloss over/skip the details of learning to read types and how typeclasses work, which makes things needlessly hard. Just staring at the types of the Monad class is already very instructive
02:59:46 <merijn> Take
02:59:49 <merijn> :t (>>=)
02:59:50 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:59:59 * tdammers nods
03:00:07 <merijn> If we fill that in with "m = Maybe" we get
03:00:22 <merijn> :t (>>=) `asAppliedTo` (Just undefined)
03:00:25 <lambdabot> Maybe a -> (a -> Maybe b) -> Maybe b
03:00:39 <merijn> diggle: Which clearly has very limited options in what it can do
03:00:47 <merijn> Same goes for
03:00:52 <merijn> :t return
03:00:53 <lambdabot> Monad m => a -> m a
03:01:10 <diggle> Oh, huh, nod
03:01:47 <merijn> diggle: And people noticed "Hey...this pattern happens to occur a lot in different places. I wonder if we can generalise/abstract it"
03:02:26 <merijn> diggle: "You Could Have Invented Monads (And Maybe You Already Have!)" is a good tutorial, and tbh Wadler's "Monads for Functional Programming" is very easily readable too
03:02:53 <diggle> Nods, thanks.
03:03:03 <tdammers> the longer I stick with this stuff, the more I am convinced that it is beneficial to approach the typeclass hierarchy from the simple end, i.e., Functor
03:03:18 <merijn> tdammers: Sure
03:03:54 <Gurkenglas> http://dev.stephendiehl.com/hask/#monads seems to recommend likewise
03:03:55 <merijn> And, from a pedagogical point of view, it's a shame that >>= is in Monad instead of >=>, I prefer teaching the laws with >=> as it's simpler, imo
03:04:18 <tdammers> yeah
03:04:25 <tdammers> >>= is the pragmatic choice
03:04:38 <tdammers> (from a programmer's point of view, that is)
03:04:43 <tdammers> :t (>=>)
03:04:44 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
03:05:02 <merijn> "return >=> f = f = f >=> return" is a much simpler way to formulate the laws :)
03:05:24 <tdammers> (>=>) also clears up the monad/monoid confusion
03:05:35 <tdammers> ("Why are they named similarly, their definitions look nothing alike!")
03:05:59 <tdammers> :t (<>)
03:06:00 <lambdabot> Monoid m => m -> m -> m
03:07:04 <tdammers> s/m/(a -> m a)/, and you have >=>
03:07:12 <tdammers> or at least a special case of it
03:07:36 <Gurkenglas> Why isn't (>=>) a minimal complete definition of Monad?
03:08:18 <liste> can you define "return" with it?
03:08:31 <Gurkenglas> We have Applicative as a superclass anyway
03:08:37 <jophish> Gurkenglas: return is in there because Applicative didn't used to be a superclass of Monad
03:08:48 <Gurkenglas> return isn't in the minimal complete definition anymore
03:08:53 <jophish> you might be interested in the "Monad of no return" proposal
03:09:16 <jophish> the reason is purely historical
03:09:19 <jophish> (ho ho)
03:09:25 <Gurkenglas> Which is already implemented! https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html
03:09:49 <Gurkenglas> "Minimal complete definition" "(>>=)" <- why not "(>>=) | (>=>)"?
03:10:25 <jophish> oh sorry, I misread your question as (>>=) instead of (>=>)
03:11:19 <jophish> Gurkenglas: it can't include (>=>) because (>=>) isn't a member of Monad
03:12:07 <jophish> lambdabot @src (>=>)
03:12:14 <jophish> @src (>=>)
03:12:14 <lambdabot> Source not found. You untyped fool!
03:12:22 <jophish> f >=> g     = \x -> f x >>= g
03:12:23 <bernalex> that seems like an arbritrary argument.
03:12:44 <jophish> bernalex: in that case: because >=> can be defined in terms of >>= as above
03:13:04 <bernalex> you can define bind in terms of the kleisli arrow as well.
03:13:11 <MarcelineVQ> lots of things can be defined in terms of each other, that's why you only need minimal definitions :>
03:13:55 <jophish> oh dear, I should stop talking I think, I didn't see '|' in Gurkenglas's question
03:14:06 * jophish sees himself out
03:14:18 <bernalex> just define everything in terms of join -_o_-
03:15:10 <bernalex> or: join x = x >>= id; x >>= f = join (fmap f x); -- implement whichever you want.
03:15:22 <Kaidelong> so I am trying to use lts-4.1
03:15:31 <Kaidelong> stack setup installs GHC 7.10.2
03:15:37 <bernalex> what is lts-4.1
03:15:48 <MarcelineVQ> it's a snapshot repo for stack
03:15:48 <Kaidelong> then when I try to do anything, it complains that GHC 7.10.3 isn't installed
03:16:01 <Kaidelong> and I should run stack setup
03:16:30 <Kaidelong> is it possible a typo got into the release somehow?
03:16:44 <Gurkenglas> hah ppl woulda noticed that
03:17:03 <bernalex> Gurkenglas: this would qualify as noticing.
03:17:11 <MarcelineVQ> well you never know, are you running these commands in a project or globally?
03:17:21 <Kaidelong> No GHC found, expected version 7.10.3 (x86_64) (based on resolver setting in C:\Users\kaide\AppData\Roaming\stack\global\stack.yaml). Try running stack setup
03:17:22 <Kaidelong> globally
03:17:30 <Kaidelong> I want to make "stack exec atom" work with latest GHC
03:17:56 <Gurkenglas> bernalex, but it's been out for four days, you'd expect the first notice sooner
03:18:18 <bernalex> software is difficult :p
03:18:49 <MarcelineVQ> What did stack setup say?
03:19:14 <Kaidelong> GHC installed to C:\Users\kaide\AppData\Local\Programs\stack\x86_64-windows\ghc-7.10.2\
03:19:16 <Kaidelong> and
03:19:20 <Kaidelong> Everything is Ok
03:19:47 <Kaidelong> alongside a whole bunch of extractions of Tars
03:19:56 <MarcelineVQ> stragne, I jsut set my resolver to `resolver: lts-4.1` and stack setup pulled in 7.10.3
03:20:37 <Kaidelong> my global stack.yaml looks like this
03:20:41 <Kaidelong> flags: {}
03:20:44 <Kaidelong> packages: []
03:20:47 <Kaidelong> extra-deps: []
03:20:51 <Kaidelong> resolver: lts-4.1
03:20:54 <Kaidelong> and that's it
03:21:45 <MarcelineVQ> Which makes sense, since the error you got was "No GHC found, expected version 7.10.3" so it knows what it's supposed to grab, sounds like a bug that it's grabbing 7.10.2 instead
03:21:51 <Kaidelong> so what's happening is that stack setup is for some reason pulling GHC 7.10.2 but it's supposed to be pulling GHC 7.10.3
03:22:39 <MarcelineVQ> can you lpaste the output of stack build
03:22:45 <MarcelineVQ> er
03:22:47 <MarcelineVQ> stack setup
03:23:50 <Kaidelong> should I do stack -v setup?
03:24:11 <MarcelineVQ> if you like, either way
03:24:28 <MarcelineVQ> actually both
03:24:37 <Kaidelong> alright, I need to look up how to redirect output in windows, but I'll do that
03:25:06 <SX> Hi. Could you please help me a little? Need some good and fast cross-lang binary serializer/deserializer for RPC. Looked into thrift, protocol-buffers, msgpack, but there're no benchs of them. More than that, protobuf and thrift require conversions from my internal data types to generated ones.
03:25:21 <MarcelineVQ> You should be able to just copy text from a cmd
03:25:33 <Kaidelong> too much text, it doesn't fit in the buffer
03:25:41 <Kaidelong> unless you want some specific part
03:27:05 <MarcelineVQ> ah, I wasn't expecting it to have that much to say. just plain `stack setup` output is probably fine then when you sort out how to copy it
03:27:56 <cheater> hello
03:27:57 <nomeata> On planet.haskell.org, there is a job advert by a company Elevence in Zürich. Has anyone heared of them before? Do they employ any community-visible people? And why did they not sponsor the last ZuriHac hackathon?
03:28:16 <cheater> could one write an applicative with the same functionality as Control.Monad.Reader?
03:29:26 <nomeata> cheater: no, as with the Reader monad, you can make decisions based on the read value.
03:29:39 <frerich> nomeata: It was founded in July 2015 only, not surprising that it's not known.
03:29:48 <bernalex> nomeata: zurihac is generally sponsored by big actors like google.
03:30:04 <cheater> nomeata: why can't you make decisions based on a value that comes from an applicative?
03:30:07 <bernalex> startups generally can't afford to give away their non-existing money
03:30:12 <frerich> nomeata: Seems they raised some venture capital, and now they go hire people.
03:31:12 <bernalex> is it these guys http://elevence.in/ ?
03:31:14 <nomeata> cheater: not decisions in terms of how the computation should proceed. That’s the whole point of applicative: The structure of the computation is known statically.
03:31:35 <cheater> nomeata: how does Monad allow this?
03:31:44 <lpaste> Kaidelong pasted “stack setup STDOUT” at http://lpaste.net/149264
03:31:55 <nomeata> bernalex: no, different logo, and different city
03:32:01 <bollu> can someone help me grok the Store comonad?
03:32:02 <Kaidelong> MarcelineVQ ^
03:32:06 <bernalex> yeah found https://functionaljobs.com/jobs/8879-haskell-engineer-at-elevence-digital-finance
03:32:08 <vegai> hey, do you guys know if the location for CUFP 2016 has already been decided?
03:32:08 <bollu> I understand what extract does
03:32:14 <bollu> *in fact, extract writes itself
03:32:20 <Kaidelong> I'm not sure how this might be helpful
03:32:26 <MarcelineVQ> this is just 7zip output, stack doesn't say anything before it starts doing this?
03:32:27 <bollu> I have no idea how to implement Store s a -> Store s (Store s a ) though
03:32:35 <bollu> I mean, what does duplicate even *mean* in this case for the Store?
03:32:35 <Kaidelong> it prints some stuff to stderr
03:32:42 <Kaidelong> lemme paste that too
03:32:42 <nomeata> cheater: because of (>>=) : m a -> (a -> m b) -> m b: The second argument gets to look at the result of th frist, and only then it needs to determine how to continue.
03:33:04 <bollu> :t duplicate
03:33:05 <lambdabot>     Not in scope: ‘duplicate’
03:33:05 <lambdabot>     Perhaps you meant one of these:
03:33:05 <lambdabot>       ‘replicate’ (imported from Data.List),
03:33:13 <bollu> hm, it's not here..?
03:33:36 <liste> what's its type sig?
03:33:57 <Kaidelong> http://lpaste.net/149271
03:33:58 <bollu> Store s a -> Store s (Store s a)
03:34:09 <Kaidelong> MarcelineVQ^
03:34:12 <bollu> where Store s a = Store { get :: s -> a, pos :: s} 
03:34:14 <Kaidelong> none of this looks helpful
03:34:16 <cheater> nomeata: but in Applicative you have   (<*>) :: f (a -> b) -> f a -> f b
03:34:30 <Kaidelong> I am going to try running it in verbose mode and I'll redirect both STDERR and STDOUT this time
03:34:48 <merijn> cheater: But at no point do you have to give an actual 'a' to anything
03:35:16 <nomeata> cheater: Right, and see how the first argument gets the result of the second  (the a), but only after the shape is determined (the a-> is inside f, not outside)
03:35:22 <merijn> cheater: Imagine "data Const k a = Const k" which gives "Const k1 <*> Const k2 = Const (mappend k1 k2)" <- this is fine
03:35:40 <bollu> guys, any help with understanding how the Store comonad works?
03:35:45 <merijn> cheater: But "Const k >>= f = Const ???" you need to give an 'a' to 'f' to get a new Const, but you can't
03:36:06 <MarcelineVQ> windows stack is so weird :X I was hoping at least it would spit out the filename of the config it was using, instead of just claiming it's using the global config
03:36:57 <SX> anyone?
03:37:01 <cheater> merijn: i didn't understand that
03:37:12 <MarcelineVQ> Kaidelong: What version of stack are you using, come to think of it
03:37:22 <jgoux> did anyone ever use a haskell library to query a Oracle database ?
03:37:30 <Kaidelong> Version 0.1.3.1, Git revision 908b04205e6f436d4a5f420b1c6c646ed2b804d7
03:37:32 <cheater> nomeata: huh, hm, but what type does an "if" have inside a monad then?
03:37:33 <merijn> cheater: "f :: a -> Const k b" but since "Const k a" doesn't have an 'a', how can you apply that function?
03:37:34 <jgoux> I'm unable to complete the installation of takusen-oracle library :(
03:37:36 <Kaidelong> mmm, maybe I should update stack
03:38:20 <quchen> Kaidelong: Good idea :-D
03:38:25 <cheater> merijn: i don't know, why do i care whether Const k is a Monad?
03:39:01 <bollu> here is my code, I'm trying to understand how to implement the Store comonad: https://gist.github.com/bollu/d38ece5b7091fe093453#file-store-hs-L22
03:39:09 <bollu> and I'm not able to come up with a duplicate function
03:39:21 <quchen> Kaidelong: Stack is supported by many package managers so you can have it update automatically even.
03:39:33 <Kaidelong> stack can upgrade itself, that is what I am going to do
03:39:56 <Kaidelong> I guess if stack is on chocolatey or another package manager for windows, I can use that, but I've found that package managers on windows aren't that amazing
03:39:58 <merijn> cheater: I'm saying that Const *can* be applicative, because you *can* implement "<*> :: f (a -> b) -> f a -> f b" for it, but it cannot be a Monad
03:40:16 <quchen> Kaidelong: Oh, you're on Windows. Then use stack upgrade, yes.
03:40:17 <merijn> cheater: You were asking for what the difference is between <*> and >>=
03:40:26 <cheater> merijn: no, i know the difference.
03:40:48 <merijn> cheater: Then I don't understand the question :)
03:41:25 <cheater> i was asking why Reader can't be defined as an Applicative, and later on we started talking about how >>= allows you to make decisions during the computation whereas <*> doesn't. I didn't understand why >>= has this ability that <*> doesn't.
03:42:08 <liste> > pure 5 :: Reader Int Int
03:42:09 <lambdabot>      No instance for (Show (Reader Int Int))
03:42:09 <lambdabot>        arising from a use of ‘show_M14646558851336300317809’
03:42:09 <lambdabot>      In the expression:
03:42:16 <liste> :t pure 5 :: Reader Int Int
03:42:17 <lambdabot> Reader Int Int
03:42:40 <liste> it's Applicative (all Monads are)
03:42:41 <nomeata> cheater: when I say „make decisions“, I was vague, but I have a hard time to phrase it better. I mean something like „Choose the the "f a" to continue with“.
03:43:34 <Kaidelong> oh I see stack actually has an installer now
03:43:44 <Kaidelong> I threw a stack.exe in a folder on my path at the time
03:44:00 <cheater> nomeata: can you give me an example of this happening inside a monad?
03:44:05 <Kaidelong> maybe I should just delete it and start over installing stack with the installer
03:45:54 <nomeata> cheater: In the IO monad, something like “readLine >>= (\l -> if null l then putStrLn "Empty line" else putStrLn "Ok")”
03:46:01 <nomeata> You could not implement that using <*>.
03:46:45 <nomeata> With the reader monad there might not be any good example, because there are no side effects (in the wider sense) observable.
03:47:24 <bollu> I
03:47:54 <bollu> I'm trying to implement the Store comonad, and I'm not sure how to implement duplicate :: Store s a -> Store s (Store s a). Here's the code: https://gist.github.com/bollu/d38ece5b7091fe093453. I was hoping someone would have some insight
03:49:08 <Kaidelong> storeEnv is in scope
03:49:29 <jle`> bollu: think about the fact that extract (duplicate x) = x
03:49:40 <jle`> and that fmap extract (duplicate x) = x
03:49:55 <Kaidelong> oh, storeEnv isn't even defined correctly, I don't think, wouldn't storeEnv = s be a type error?
03:50:01 <voo______> help
03:50:05 <jle`> what would need to be true for extract (duplicate x) to leave things unchanged?
03:50:16 <jle`> extract . duplicate = fmap extract . duplicate = id
03:50:17 <voo______> i'm doing 2nd chapter in learn haskell for great...
03:50:35 <voo______> Prelude> removeNonUppercase :: [Char] -> [Char] 
03:50:36 <voo______>  <interactive>:5:1: Not in scope: `removeNonUppercase'
03:50:37 <jle`> thinking about these two properties should be enough to help you reason through it :)
03:50:40 <cheater> nomeata: right yeah
03:50:45 <voo______> why cant i declare
03:51:01 <liste> voo try typing that in a .hs file
03:51:03 <jle`> voo______: it's in GHCi, so you have to squish it into one line, unfortunately
03:51:09 <jle`> best way would be, yeah, to type it into a .hs file
03:51:11 <jle`> and :load it
03:51:34 <cheater> nomeata: hmm could i not?
03:51:47 <bollu> jle`: hm, thanks. Those laws will help 
03:51:48 <bollu> :)
03:52:04 <quchen> The Reader Applicative should be exactly as powerful as the Monad, no?
03:52:08 <Kaidelong> let removeNonUppercase = (filterBy isLower :: [Char -> Char])
03:52:16 <Kaidelong> is how you'd have to do it in ghci
03:52:18 <jle`> bollu: you already have `extract` implemented correctly ... so write a duplicate that makes sense with it :)
03:52:35 <bollu> jle`: hm, alright!
03:52:38 <jle`> or let removeNonUppercase :: [Char] -> [Char]; removeNonUppercase = filterBy isLower
03:52:46 <bollu> jle`: also, lens == costate comonad coalgebra is freaking crazy
03:52:47 <jle`> idk either way is kinda silly
03:52:54 <jle`> haha yeah don't worry about that
03:52:56 <bollu> jle`: though I don't understand why state and store are duals
03:53:08 <bollu> jle`: I understand the s -> (a, s) versus (s -> a, s)
03:53:25 <bollu> jle`: but that's some sort of (,) and (->) composition difference, right? so how are they duals?
03:53:48 <cheater> nomeata: say i had a newtype like newtype S a = S a, i could just go: (>*<) = flip (<*>); l >*< (\a -> if null a then "null" else "ok")
03:54:02 <Kaidelong> they're adjoint
03:54:07 <danilo2> Hello guys! What is the convention in Haskell / GHC to "include" CPP Header files with macros? Lets say  create a library installable by cabal and it contain CPP header that I want to include in other files, how can I import or handle it? Right now I'm  using the #include pragma with full path and it works, but this is for dev purpose only
03:54:12 <cheater> nomeata: it wouldn't print (because that's not what applicatives do) but the computation is still similar, right?
03:54:17 <voo______> i didnt get it jle` give 1 example
03:54:27 <bollu> Kaidelong: adjoint in what sense? Cat. theory? (I don't know what adjoint is in cat. theory)
03:54:33 <jle`> let removeNonUppercase :: [Char] -> [Char]; removeNonUppercase = filterBy isLower
03:54:36 <Kaidelong> cat theory, yes
03:54:37 <jle`> is how you could write it in ghci
03:54:42 <jle`> but, the better way would be to make a new file
03:54:46 <jle`> with your function declaration
03:54:51 <jle`> name it something like myfile.hs
03:54:55 <quchen> :t let joinReader f = (f <*> id) in joinReader
03:54:56 <lambdabot> (a -> a -> b) -> a -> b
03:54:57 <jle`> and then, in ghci, `:load myfile.hs`
03:55:07 <Axman6> danilo2: thats not something ive ever heard of anyone doing
03:55:15 <nomeata> cheater: well, but the not-printing is precisely the point
03:55:17 <bollu> jle`: while we're on the topic. is it possible to have ghci keep the "old sane state" when you reload a file?
03:55:22 <danilo2> Axman6: Does it imply its impossible?
03:55:27 <bollu> as in, if there's a compiler error, I want it to keep the old state
03:55:29 <nomeata> cheater: IO models (among other things) printing
03:55:32 <jle`> bollu: i wish i knew how ;_;
03:55:40 <nomeata> oh, but my example was still bad
03:55:55 <Axman6> danilo2: sure, but just making a module is the usual way to share definitions of things
03:55:57 <voo______> in oracle sql we have a file called temp file to open it we have this ed command same like this cant we have in haskell (curious)
03:56:06 <nomeata> Try “readLine >>= (\l -> if null l then putStrLn "Empty line"; readLine else reaturn l)”
03:56:26 <nomeata> The point is that the branches do something differently on the IO level (and differ not just in the values therein)
03:56:26 <jle`> :t \f -> f <*> (id `asTypeOf` _)
03:56:27 <lambdabot>     Found hole ‘_’ with type: a -> a
03:56:27 <lambdabot>     Where: ‘a’ is a rigid type variable bound by
03:56:27 <lambdabot>                the inferred type of it :: (a -> a -> b) -> a -> b
03:56:45 <danilo2> Ok so another way around - I've got few TemplaeHaskell calls. They HAVE TO be evaluated one after another, but I cannot use just one, because I'm reifying the results of previous ones, so GHC stage restriction forbids me from merging them in one call. So I've created a simple CPP macro that pastes these calls one after another
03:56:50 <danilo2> Axman6: ^
03:56:53 <nomeata> But I’m sure there are explanations on the difference between Applicative and Monad out there that are better than what I can cook up here.
03:57:20 <danilo2> Is there any other way to handle it or just with CPP macros ?
03:57:30 <liste> voo______: not in ghci. you must create and edit the file yourself, and `:load' it in ghci
03:57:59 <jle`> quchen: i'm not sure if "X applicative is as powerful as X monad" makes too much sense, because if you know X, you can already examine the internal structure of that specific X to get a suitable bind/join
03:58:07 <danilo2> Axman6: hmm, I want to create a module, but the include pragma takes full path, so I'm looking for a general solution here
03:58:31 <cheater> nomeata: no... the fact that the applicative doesn't do something the monad can't isn't the point... we're talking about whether the applicative can do decisions like the monad can, not whether it can do IO
03:58:37 <SX> Could you please help me a little? Need some good and fast cross-lang binary serializer/deserializer for RPC. Looked into thrift, protocol-buffers, msgpack, but there're no benchs of them. More than that, protobuf and thrift require conversions from my internal data types to generated ones.
03:58:59 <jle`> quchen: so if you mean, "X if I only use Applicative combinators on it is the same as X if i can only use monad combinators on it" ... in this case, you used `id`, which isn't a part of the Applicative interface
04:00:03 <jle`> or maybe it is...
04:00:15 <nomeata> cheater: the IO is just a generic example for “the side effect modeled by an applicative (or monad)”. Replace IO with f and its the same.
04:01:44 <cheater> but we're not talking about whether Applicative can model "side effects"
04:01:54 <jle`> yeah, I can't think of a way to implement `id` using only Applicative combinators/interface
04:02:27 <nomeata> cheater: hmm. Maybe I should rephrase my answer to “try it, and tell us how it went” :-)
04:02:30 <cheater> we're talking about whether Applicative can model Reader, which as you said has no side effects. So you brought up another argument, which is "applicative cannot make decisions". we're trying to understand that.
04:02:51 <cheater> nomeata: i tried. I came here to talk about it, because I don't know how it might work.
04:03:16 <Kaidelong> alright, I tried running stack upgrade
04:03:18 <Kaidelong> that failed
04:03:26 <Kaidelong> so I deleted stack, and installed it using the new installer
04:03:38 <Kaidelong> then ran stack setup
04:03:45 <Kaidelong> it's fetching ghc 7.10.3 now
04:03:46 <nomeata> cheater: You can have an Applicative instance for Reader (but you have an Applicative instance for every Monad), so you need to refine your questoin.
04:04:09 <nomeata> what precisely do you mean by “to model Reader”?
04:04:13 <cheater> that Applicative instance is defined retroactively from a Monad
04:04:21 <cheater> i'm talking about defining Reader without Monad
04:04:43 <nomeata> cheater: the definition of Reader itself has nothing to do with Monads. It’s just newtype R a b = R (a -> b).
04:04:53 <cheater> yes, but all the keywords etc
04:05:02 <cheater> that is, functions that make use of Reader
04:05:37 <nomeata> Functions that make use of Reader can either use R directly, or they can use the Monad interface, or they can use the Applicative interface.
04:05:58 <wedens> I'm pretty sure the answer is "no", but can I do blacklisting export? "export all from module except ..."
04:06:23 <nomeata> Is your question maybe „Given a function of type "R a" that does not use the R constructor, but only the monad methods + "read :: R a a", can the same be implemented using only the applicative methods + "read"?“
04:06:51 <nomeata> wedens: you can do it via an intermediate module that imports the module with a hiding clause, and then exports all of that module.
04:07:34 <cheater> i believe you mean "ask" not "read"
04:07:38 <cheater> but yes, something like that
04:07:48 <nomeata> yes, whatever the name is :-)
04:08:13 <nomeata> I never can remember which is ask, read, get. Ok, now that I think about it: It cannot be read :-)
04:08:47 <wedens> nomeata: sounds like a plan. thanks
04:09:17 <jle`> it's kind of like asking, "let's say State has only an Applicative instance, oh, and i can also use `foo :: State s (State s a) -> State s a`.  that's the same as monad, right?"
04:09:22 <nomeata> cheater: the answer is “yes”: Replace the function foo :: Read a with "foo' <$> ask", where foo' is a translation of foo to replace every occurence of "R a b" with "a -> b", passing that extra argument around explicitly.
04:09:49 <cheater> i didn't quite understand that last one
04:10:05 <nomeata> (oh, and simply replacing (>>=) by something alike to "flip (.)".
04:10:32 <nomeata> The point is: If you pass around the value in the reader explicitly, you don’t need any of the Monad methods.
04:10:56 <bollu> jle`: I think I got the right instance of the Store Comonad. Could you please take a look? https://gist.github.com/bollu/d38ece5b7091fe093453
04:11:04 <jle`> cheater: when people say "applicative can't depend on the result", they don't mean that Applicative instances are never allowed to chain and base on the results.  it means that functions written polymorphically over *all Applicatives* can't chain 'depending on the result'
04:11:08 <bollu> (also, what's a natural store example?)
04:11:15 <bollu> I need some store to play around with that feels "real"
04:11:28 <jle`> cheater: for example, some people say, "functors can't change structure"
04:11:33 <jle`> that doesn't mean that you can't change the structure of a list
04:11:46 <jle`> take 3 [1,2,3,4]  => [1,2,3]
04:11:54 <jle`> there, i changed the structure of my list :O
04:12:10 <jle`> but list is a Functor ... does that mean you *can* change the structure of Functors?
04:12:29 <jle`> when people say that fmap doesn't change structure, they mean that functions written polymorphically over *all* functors can't change structures
04:12:34 <jle`> functions like fmap f, for example
04:12:54 <jle`> if you *only* use fmap, (<$), ($>), etc., if you *only* use functions polymorphic over *all* Functors
04:13:19 <bollu> what's a natural example of a Store? (as in, can someone give me a store to play around with)
04:13:21 <jle`> saying "Applicatives can't depend on the result" is like saying "you can't change the structure of functors"  --- both are obviously not true
04:13:56 <jle`> bollu: edwardk has that cellular automata example, but one of my favorites has always been mm_freak's digital image processing example
04:14:03 <bollu> jle`: linky?
04:14:18 <cheater> jle`: exactly that's what i'm asking about.
04:14:21 <jle`> http://hub.darcs.net/ertes/articles/raw-file/media-processing.lhs
04:14:39 <cheater> i know if you have an Applicative that has a Monad instance you can decide at runtime "what to do"
04:14:43 <jle`> cheater: but, functions polymorphic over all Applicative --- functions using only pure, (*>), (<*>), fmap, etc;, they can't chain based on the results
04:15:02 <cheater> why not?
04:15:08 <cheater> after all <*> can take a function
04:15:22 <cheater> it takes the inside of the old applicative and gives you a new result
04:15:26 <jle`> you can't write it polymorphically over *all* Applicative's
04:15:37 <jle`> can you implement (>>=) using (<*>) ?
04:15:43 <jle`> that works for *all* Applicatives?
04:16:05 <jle`> you definitely will be able to implement trivially for any *specific* type
04:16:45 <jle`> x >>= f = pure id <*> (case x of Just x -> f x; Nothing -> Nothing)
04:16:57 <jle`> there, i "implemented bind for Maybe using <*>" :P
04:17:36 <cheater> no, i can't write it polymorphically over all Applicatives, but I can't also do the same in Monad either
04:17:42 <jle`> but that doesn't work if i want to implement it for *every* Applicative uniformly, not just Maybe
04:17:45 <jle`> yes, you can
04:17:57 <jle`> with Monad, you can write depend-on-next-result computations polymorphic over *all* Monads
04:17:57 <cheater> i mean show me something that makes a decision in a Monad polymorphically that isn't possible in Applicative
04:18:16 <jle`> well, (>>=) is a trivial example :P
04:18:21 <cheater> no, it is not
04:18:24 <cheater> it does not make a decision
04:18:29 <mauke`> foo ma mb = do a <- ma; if a then mb else return ()
04:18:30 <cheater> the right argument makes the decision
04:18:45 <cheater> that's not polymorphic, because ma has to be m Bool
04:18:45 <jle`> yes, that's what we're talking about
04:18:46 <mauke`> there, monadic code
04:18:55 <mauke`> cheater: it's polymorphic over all monads
04:18:57 <jle`> cheater: polymorphic over the *m*
04:19:01 <jle`> not the Bool...
04:19:06 <cheater> i can write the same using Applicative
04:19:09 <mauke`> show me
04:19:17 <jle`> you can't write (>>=) using Applicative that's polymorphic over all `f`
04:20:05 <jle`> :t \x f -> x >>= \y -> if even y then return () else f x
04:20:06 <lambdabot> (Integral a, Monad m) => m a -> (m a -> m ()) -> m ()
04:20:26 <jle`> :t \x -> x >>= \y -> if even y then return () else return x
04:20:27 <lambdabot>     Couldn't match expected type ‘()’ with actual type ‘m a’
04:20:27 <lambdabot>     Relevant bindings include
04:20:27 <lambdabot>       y :: a (bound at <interactive>:1:14)
04:20:30 <jle`> oops
04:20:39 <jle`> :t \x -> x >>= \y -> if even y then return 100 else return x
04:20:40 <lambdabot> (Integral a, Monad m, Num (m a)) => m a -> m (m a)
04:20:52 <jle`> sorry v.v
04:20:53 <mauke`> m (m a)?
04:20:58 <jle`> :t \x -> x >>= \y -> if even y then return 100 else return y
04:21:00 <lambdabot> (Integral b, Monad m) => m b -> m b
04:21:17 <jle`> you can't implement something like that using only (<*>) that's polymorphical over all Applicative f's
04:21:22 <mauke`> :t fmap (\x -> if even x then 100 else x)
04:21:23 <lambdabot> (Integral b, Functor f) => f b -> f b
04:21:27 <jle`> oh yeah .v
04:21:28 <jle`> v.v
04:21:41 <jle`> my first example had to do, then
04:21:48 <jle`> :t \x f -> x >>= \y -> if even y then return () else f x
04:21:49 <lambdabot> (Integral a, Monad m) => m a -> (m a -> m ()) -> m ()
04:22:02 <jle`> dangit
04:22:05 <jle`> :t \x f -> x >>= \y -> if even y then return () else f y
04:22:06 <lambdabot> (Integral a, Monad m) => m a -> (a -> m ()) -> m ()
04:22:09 <jle`> that's the one v.v
04:22:31 <jle`> you can't write that using only Applicative and Functor functions in a way that it's polymorphic over all Applicative f
04:22:37 <jle`> you can trivially write it for specific Applicatives
04:22:58 <bollu> :t guard
04:22:59 <lambdabot> Alternative f => Bool -> f ()
04:23:09 <bollu> wait, I thought guard used MonadFail
04:23:10 <bollu> huh
04:23:17 <mauke`> welcome to the future
04:23:32 <mauke`> :t when
04:23:33 <lambdabot> Applicative f => Bool -> f () -> f ()
04:23:36 <bollu> mauke`: did it ever use MonadFail? or am I mis-remembering?
04:23:47 <jle`> it's used MonadPlus for as long as I can remember
04:23:51 <jle`> until recently
04:24:07 <bollu> hmm, I see
04:24:09 <fractalsea> I’m trying to use stack as a script interpreter (http://docs.haskellstack.org/en/stable/GUIDE.html#ghc-runghc). Is there a reason why I get this error: http://lpaste.net/7192681327160721408
04:24:15 <jle`> cheater: also, try implementing findM :: (a -> m Bool) -> [a] -> m (Maybe a)
04:24:18 <fractalsea> It works with a single line comment, but not multi line
04:24:20 <bollu> anyway, I gotta go. Ty for the help jle`!
04:24:27 <fractalsea> It’s with stack 1.10.1
04:24:38 <jle`> cheater: it's supposed to stop searching the list as soon as it it finds a success
04:24:43 <cheater> mauke`: S (\a ab -> (if a then ab else ())) <*> S True <*> S ()
04:24:54 <mauke`> cheater: what's S?
04:25:02 <cheater> newtype S a = S a
04:25:19 <jle`> that works for S, but write one in a way that's polymorphic over all Applicative f's
04:25:24 <cheater> i could have just written this
04:25:29 <cheater> pure (\a ab -> (if a then ab else ())) <*> S True <*> S ()
04:25:35 <mauke`> cheater: that only works for S
04:25:44 <cheater> how so
04:25:48 <mauke`> 'S True'
04:25:50 <Fuco> you are using S :D
04:25:57 <cheater> if i have this code "pure (\a ab -> (if a then ab else ()))"
04:26:01 <cheater> that doesn't mention S at all
04:26:09 <cheater> it's polymorphic over all applicatives as you wanted
04:26:11 <Fuco> but the <*> uses the S definition
04:26:18 <jle`> cheater: it's actaully type-inferred to be S
04:26:25 <jle`> it's not polymorphic, its type is fully determined
04:26:29 <cheater> in exactly the same way as this is foo ma mb = do a <- ma; if a then mb else return ()
04:26:31 <mauke`> cheater: foo (return False) exitFailure
04:26:40 <mauke`> cheater: that should do nothing. your code makes it exit
04:26:40 <jle`> cheater: note the type of mb
04:27:10 <cheater> jle`: there's only a polymorphic type
04:27:12 <jle`> but `foo` is different in that it can work for any m.  it can work for Maybe, it can work for S, it can work for Reader, for State
04:27:15 <jle`> but yours can only work for S
04:27:34 <jle`> cheater: try writing findM :: (a -> m Bool) -> [a] -> m (Maybe a)
04:27:36 <mauke`> :t \ma mb -> pure (\a ab -> (if a then ab else ())) <*> ma <*> mb
04:27:37 <lambdabot> Applicative f => f Bool -> f () -> f ()
04:27:43 <mauke`> the type is fine
04:27:46 <mauke`> it just doesn't work
04:27:53 <jle`> cheater: it runs the function on every item in the list, and stops as soon as it finds a success
04:28:38 <jle`> :t let findM f [] = return Nothing; findM f (x:xs) = do y <- f x; if y then return (Just x) else findM f xs
04:28:39 <lambdabot> <no location info>:
04:28:39 <lambdabot>     not an expression: ‘let findM f [] = return Nothing; findM f (x:xs) = do y <- f x; if y then return (Just x) else findM f xs’
04:28:42 <jle`> :t let findM f [] = return Nothing; findM f (x:xs) = do y <- f x; if y then return (Just x) else findM f xs in findM
04:28:44 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m (Maybe a)
04:28:44 <cheater> foo2 aa ab = pure (\a ab -> (if a then ab else ())) <*> aa <*> ab
04:28:50 <cheater> foo2 :: Applicative f => f Bool -> f () -> f ()
04:28:53 <cheater> doesn't say S anywhere
04:29:05 <cheater> and just for reference :t foo
04:29:05 <cheater> foo :: Monad m => m Bool -> m () -> m ()
04:29:12 <jle`> cheater: try writing findM using only Applicative combinators in a way that's polymorphic over all `f`
04:29:28 <cheater> we're talking about mauke's example now
04:29:33 <jle`> sure
04:29:35 <mauke`> cheater: <mauke`> the type is fine  <mauke`> it just doesn't work
04:29:45 <cheater> it doesn't work in what way?
04:29:49 <quchen> jle`: I = S K K
04:29:50 <mauke`> <mauke`> cheater: foo (return False) exitFailure  <mauke`> cheater: that should do nothing. your code makes it exit
04:29:55 <quchen> :t const <*> const
04:29:56 <lambdabot> b -> b
04:30:36 <jle`> note that in mauke's example, `mb :: f a`, but in your example, `mb :: a`
04:30:49 <quchen> :t let joinReader f = (f <*> (const <*> const)) in joinReader -- jle` 
04:30:50 <lambdabot> (a -> a -> b) -> a -> b
04:30:51 <mauke`> jle`: what
04:31:03 <jle`> mauke`: in the donotation example you gave
04:31:07 <cheater> exitFailure is of type IO a, so it's not "fair" to use it with an Applicative
04:31:10 <jle`> if it's being quoted correctly
04:31:17 <mauke`> jle`: there's no mb in cheater's example
04:31:29 <mauke`> cheater: why not?
04:32:04 <cheater> let's use undefined instead
04:32:11 <mauke`> it's fully polymorphic, so it should work with all Applicatives, including all Monads, including IO
04:32:15 <mauke`> no, let's not
04:32:25 <cheater> ok
04:32:51 <jle`> cheater: here's another one you can't do using Applicaitve only: while :: m Bool -> m (); while act = do res <- act; if res then while act else return ()
04:32:52 <mauke`> basically, the problem is that your version performs the effects of both arguments first, then merely selects a return value
04:33:09 <cheater> yes, it does
04:33:12 <mauke`> whereas my monadic version only performs the effects of the second argument if the first argument returns True
04:33:25 <cheater> so in fact, as you say, applicative can select based on results
04:33:25 <anohigisavay> any haskell equivalent of python's "{0},{0}".format(123)?
04:33:38 <cheater> but it can't not-perform things based on results
04:33:40 <liste> @hackage formatting -- anohigisavay
04:33:41 <lambdabot> http://hackage.haskell.org/package/formatting -- anohigisavay
04:33:41 <mauke`> anohigisavay: is that an owl?
04:33:45 <quchen> ?hackage formatting -- anohigisavay 
04:33:45 <lambdabot> http://hackage.haskell.org/package/formatting -- anohigisavay
04:33:45 <liste> also, printf
04:33:53 <quchen> Heh, too late
04:34:06 <anohigisavay> thank you guys :)
04:34:10 <jle`> cheater: saying "applicative can return answers based on the results" is not that big of a deal, becuase Functor can also do this
04:34:11 <liste> no cute owls tho :(
04:34:26 <jle`> Functor can also let you choose what result to give, based on the result of the last
04:34:29 <mauke`> (0,0)
04:34:37 <jle`> what it can't do is let you chose what (f a) computation to perform 'next'
04:35:06 <cheater> yes
04:35:21 <cheater> Applicative is always going to perform everything
04:35:38 <cheater> so in fact it would seem that Reader could be defined as Applicative as well, doesn't need to be a Monad
04:35:55 <cheater> an auto-derived Monad instance would be equivalent to the current Monad instance, right?
04:35:56 <jle`> it doesn't need to be an Applicative instance, either
04:35:59 <mauke`> that seems backwards
04:36:07 <mauke`> how do you auto-derive a Monad instance?
04:36:09 <jle`> um, what is the "auto-derived Monad instance" ?
04:36:16 <cheater> oh hm right
04:36:23 <jle`> do you mean, 'the hand-picked Monad instance that you write specifically for Reader, is equivalent to the current Monad isntance'?
04:36:27 <jle`> because that's trivially true
04:36:38 <cheater> hmm you can derive Applicative from Monad but not the other way, right?
04:36:43 <mauke`> yeah
04:36:50 <mauke`> pure = return; (<*>) = ap
04:37:04 <mauke`> what you can't get from Applicative is join
04:37:15 <mauke`> (fmap + join = (>>=))
04:37:58 <jle`> Reader doesn't need to be an Applicative instance or a Monad instance.  it's just that having them is useful
04:38:35 <liste> is there a better way to say \f a -> f a a ?
04:38:37 <jle`> so you could cludge together a (Reader r (Reader r a) -> Reader r a) for Reader, using specific constructors specific to Reader
04:38:53 <jle`> liste: people say join normally
04:38:57 <anohigisavay> guys i want to interpolate the params MULTIPLE times in the string template
04:39:17 <anohigisavay> i don't think `formatting` does what i intended to do. or did i miss something
04:39:49 <liste> anohigisavay you can use join for that
04:40:10 <quchen> That's hardly more readable though
04:40:43 <quchen> String interpolation is not something Haskell excels at
04:42:10 <anohigisavay> thanks guys :)
04:50:39 <itsu> :t (->)
04:50:40 <lambdabot> parse error on input ‘->’
04:50:53 <knupfer> Where can I read which chars are allowed for naming a function (excluding operators)?
04:51:11 <jle`> the report :)
04:51:38 <quchen_> ?where report
04:51:38 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
04:52:24 <jle`> specifically section 2.4 https://www.haskell.org/onlinereport/haskell2010/haskellch2.html
04:52:54 <knupfer> Thank you
04:53:06 <quchen_> … where <symbol> is any Unicode symbol
04:53:30 <quchen_> map isSymbol ['e', '+', 'ä']
04:53:34 <quchen_> > map isSymbol ['e', '+', 'ä']
04:53:36 <lambdabot>  [False,True,False]
04:54:30 <quchen_> > let (☃) = (+) in 1 ☃ 2
04:54:31 <lambdabot>  3
04:55:16 <Walther> quchen_: :D
04:56:48 <knupfer> So to check that a string is a correct function name, I could basically check the first with Data.Char.isLower and the rest with Data.Char.isAlphaNum or ' or _
05:00:30 <quchen_> (>>><<++++) is a valid function name as well.
05:00:48 <knupfer> I know, but I specifically excluded operators.
05:01:26 <frerich> quchen_: Hm, that makes me think that you could maybe create a  nice EDSL for Brainf*ck programs...
05:01:28 <quchen_> `foo` is an operator just like +. (+) is a name just like foo.
05:01:44 <quchen_> frerich: You can't map Brainfuck's [] unfortunately
05:02:06 <knupfer> Well, I know. So let's be more specific: any function which contains at least one letter.
05:02:55 <frerich> quchen_: There must be a funky Unicode character which is usually rendered exactly the same and which constitutes a legal character :-)
05:03:48 <obadz> why don't we create a Num instance for all (Num a, Applicative f) => f a? https://gist.github.com/obadz/808275b5ad716fadb01c
05:04:11 <quchen_> obadz: It's not useful.
05:04:16 <Steve__> Hi - I downloaded Haskell sometime last year and so have 7.8.4 on my system - I would like to install the latest version using apt-get install haskell-platform, do I need to delete previous version first and if so what is the best way to do it please? Thanks to anyone who will help! Steve.
05:04:25 <quchen_> It's been done before, Lambdabot even had it at some point.
05:04:45 <obadz> quchen_: Just 2 + Just 3 rathern than (+) <$> Just 2 <*> Just 3 ?
05:04:53 <obadz> quchen_: seems useful to me..
05:05:26 <fr33domlover> Steve__, are you using hvr's PPA?
05:05:38 <fr33domlover> you can choose the GHC version you want there
05:06:12 <fr33domlover> iirc you can have several in parallel, no need to uninstall anything
05:06:23 <fr33domlover> Just change your PATH to point to the new version
05:06:35 <fr33domlover> in .bachrc or wherever you set it
05:06:59 <Steve__> fr33domlover, - I'm not sure what you mean - but good news I can have more than one version - but I don't actually need the old one and would prefer to get rid of it.
05:07:23 <mauke`> obadz: you can simplify your definitions: (+) = liftA2 (+); (-) = liftA2 (-); abs = fmap abs; etc
05:07:37 <obadz> mauke`: already did :) (reload)
05:07:48 <mauke`> obadz: no, that still has Num.
05:07:54 <fr33domlover> Steve__, which distro are you using?
05:07:57 <mauke`> for no reason
05:08:12 <Steve__> Ubuntu 14.04
05:08:48 <obadz> mauke`: fair enough, fixed.
05:08:52 <fr33domlover> Steve__, if the distro has the GHC version you want, just install. If not, there is a PPA
05:09:11 <mauke`> obadz: the problem with that instance is that it overlaps everything
05:09:35 <Steve__> OK - thanks very much - I'll  just install the new one - distro has ghc that I want. Thanks for all your help, much appreciated.
05:10:32 <obadz> mauke`: when I write (+) = liftA2 (+), what guarantees do I have that doesn't end up in some sort of infinite recursion?
05:10:48 <fr33domlover> obadz, not literally
05:10:59 <fr33domlover> use liftA2 (+) instead of (+) there
05:11:20 <obadz> if the + on the right is the same as on the lift, then + = liftA2 + = liftA2 (liftA2 +) = ...
05:11:32 <fr33domlover> > liftA (+) (Just 2) (Just 3)
05:11:34 <lambdabot>      Couldn't match expected type ‘Maybe Integer -> t’
05:11:34 <lambdabot>                  with actual type ‘Maybe (Integer -> Integer)’
05:11:34 <lambdabot>      The function ‘liftA’ is applied to three arguments,
05:11:42 <fr33domlover> or not :P
05:11:45 <fr33domlover> > liftA2 (+) (Just 2) (Just 3)
05:11:46 <lambdabot>  Just 5
05:11:50 <fr33domlover> ah there
05:12:04 <fr33domlover> obadz, ^
05:12:18 <mauke`> obadz: it can't be direct recursion because the types don't match up
05:12:20 <obadz> yes I understand that
05:12:34 <mauke`> obadz: the (+) on the right is resolved by type, as normal
05:12:45 <Haris> hello all
05:12:51 <Haris> I'm having problem with cabal on centos 6. cabal update is failing. its saying, multiple base versions are available, but its selected one (4.3.1), and not installing any other(4.4.0.0). How do I deal with it ? I need at least 4.4.x to have cabale install postgrest
05:13:29 <mauke`> Haris: 'base' isn't a real library; it comes with ghc
05:13:34 <liste> Haris base version is determined by ghc version
05:13:44 <liste> so you need to either update ghc or use older package versions
05:13:50 <Haris> ok. so is it possibel for me to install 4.4.x or above ?
05:14:00 <fr33domlover> Haris, https://github.com/bitemyapp/learnhaskell/blob/master/install.md
05:14:26 <liste> no CentOS there though :(
05:14:55 <liste> Haris I'd give stack a try, or compile the binaries on some other OS
05:15:07 <fr33domlover> if you don't have to use centos, it's time to change distro them
05:15:13 <mauke`> base 4.4.0.0 came with ghc 7.2.1
05:15:15 <Haris> I'v installed stack. but don't know what to use about it
05:15:27 <fr33domlover> anyway having GHC on a server etc. may not be a good idea
05:15:40 <Haris> ?
05:15:53 <Haris> this is all to install catarse on centos
05:15:54 <fr33domlover> Haris, is that a server or your personal computer?
05:16:02 <Haris> https://github.com/catarse/catarse/blob/master/README.md
05:16:06 <Haris> server
05:16:18 <fr33domlover> Haris, why not build on your laptop and upload the binary
05:16:22 <fr33domlover> it's safer and easier
05:16:29 <Haris> I don't know what that means
05:16:35 <Haris> build what locally and then upload
05:16:45 <liste> Haris stack can choose the correct GHC versions automatically
05:16:48 <fr33domlover> Haris, the program
05:16:51 <liste> if you run GHC thru it
05:17:27 <knupfer> Perhaps the programm is ghc?
05:17:34 <knupfer> Ghc as a service, sounds like money
05:17:55 <tdammers> knupfer: if haskell were more mainstream, it'd definitely be a money-making opportunity
05:17:57 <liste> Haris: which catarse?
05:18:06 <liste> oh, that one
05:18:06 <Haris> https://github.com/catarse/catarse
05:18:08 <tdammers> knupfer: in a way, Travis is in almost that business
05:18:17 <liste> I see no mention of GHC
05:18:20 <liste> or Haskell
05:18:25 <mauke`> postgrest is in haskell
05:18:33 <liste> oh
05:18:46 <Haris> catarse requires postgrest. postgrest is installed through cabal. cabal requires .. what it requires
05:19:00 <RaceCondition> is it by-design that such a simple thing as `foldl 0 (+) [1,2,3,4]` yields an obscure compilation error on GHCi out of the box?
05:19:05 <liste> Haris postgrest has a stack.yaml file
05:19:12 <mauke`> RaceCondition: what error?
05:19:16 <RaceCondition> I understand why it happens, but I'm asking — is it by design that newbies need to know such stuff?
05:19:27 <liste> Haris so stack should do everything for you
05:19:36 <Haris> ok. great
05:19:36 <Haris> how ?
05:19:40 <tdammers> if there's a stack.yaml, the procedure is: 1. install stack; 2. cd into the project; 3. stack install
05:19:41 <RaceCondition> Non type-variable argument \n in the constraint: Num ((a -> a -> a) -> a -> a -> a -> a) \n (Use FlexibleContexts to permit this)
05:19:49 <Haris> hmm
05:20:03 <RaceCondition> if oh shit... my bad.
05:20:06 <fr33domlover> Haris, the README says it's written in ruby
05:20:11 <Haris> running stack install in project dir
05:20:11 <mauke`> RaceCondition: ah, yes. that error message was specifically designed for newbies using foldl wrong
05:20:16 <tdammers> yes
05:20:19 <RaceCondition> I assumed the first two arguments on foldl were flipped in comparison to foldr, but they aren't
05:20:28 <tdammers> alternatively, stack build, and then find the binary (somewhere under .stack-work
05:20:31 <tdammers> )
05:20:36 <liste> fr33domlover catarse is, postgrest isn't
05:20:36 <RaceCondition> how embarrasing.
05:20:53 <RaceCondition> please kickban me for 5 minutes to make me feel forgiven...
05:21:15 <fr33domlover> RaceCondition, forgiveness => not banning you :)
05:21:19 * mauke` kicks RaceCondition
05:21:25 <frerich> RaceCondition: The arguments to the function passed to foldl are flipped in comparison to foldr though (the accumulator is at the 'left')
05:21:37 <frerich> RaceCondition: Maybe that's what you were thinking of.
05:21:56 <RaceCondition> foldr (+) 0 [1,2,3,4] == foldl (+) 0 [1,2,3,4]
05:21:59 <RaceCondition> so what do you mean?
05:22:27 <mauke`> ...
05:22:47 <liste> RaceCondition consider (:) instead of (+)
05:22:49 <RaceCondition> frerich, oh, again, yes you're right. I need to go back to sleep.
05:23:01 <RaceCondition> I told you guys you need to ban me; you didn't listen.
05:23:12 <tdammers> :t foldr
05:23:13 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
05:23:14 <tdammers> :t foldl
05:23:15 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
05:23:34 <tdammers> but in your example, a ~ b, so both signatures align exactly
05:23:43 <mauke`> and (+) commutes
05:23:56 <knupfer> try (-)
05:24:11 <liste> :t (-)
05:24:12 <lambdabot> Num a => a -> a -> a
05:24:34 <knupfer> > foldr (-) 0 [1..4] == foldl (-) 0 [1..4]
05:24:36 <lambdabot>  False
05:24:56 <mauke`> > foldl (-) 0 [1..4] :: Expr
05:24:58 <lambdabot>  0 - 1 - 2 - 3 - 4
05:25:00 <mauke`> > foldr (-) 0 [1..4] :: Expr
05:25:02 <lambdabot>  1 - (2 - (3 - (4 - 0)))
05:25:17 <knupfer> Oh, that :: Expr is nice!
05:25:21 <knupfer> Is that new?
05:25:24 <mauke`> no
05:28:31 <SX> Could you please help me a little? Need some good and fast cross-lang binary serializer/deserializer for RPC. Looked into thrift, protocol-buffers, msgpack, but there're no benchs of them. More than that, protobuf and thrift require conversions from my internal data types to generated ones.
05:28:59 <frerich> SX: Maybe ZeroMQ works for you?
05:29:42 * hackagebot atrans 0.1.0.1 - A small collection of monad (transformer) instances.  https://hackage.haskell.org/package/atrans-0.1.0.1 (apho)
05:30:31 <SX> afaik ZeroMQ is more of a transport mech, not ser/deser.
05:37:29 <Haris> ok. stack is installed. It installed ghc-gmp4-7.10.3.
05:46:15 <Haris> --  Failure when adding dependencies:
05:46:15 <Haris>       postgresql-binary: needed (==0.5.*), 0.7.4.1 found (latest applicable is 0.5.2.1)
05:46:15 <Haris>     needed for package: hasql-postgres-0.10.6
05:46:26 <Haris> this is on centos 6
05:46:33 <Haris> 6.4
05:46:48 <Haris> postgresql client is 8.x. postgresql server is 9.4.5
05:48:16 <huhu_> cool
05:48:25 <huhu_> how does this work?
05:49:15 <srhb> huhu_: You ask a question :-)
05:50:38 <frerich> huhu huhu_
05:56:17 <bollu> so duplicate :: Store s a -> Store s (Store s a) returns a "collections of stores", one for each value of "s" ? so when we choose to sample from the Store s (Store s a), we will get a store that is centered at the point s'?
05:58:15 <jeeger> Greetings! I'm messing around with Parsec/ConfigFile and the Control.Monad.Except monad, and I'm wondering how to unify the two different error monads returned by Parsec (ParseError) and ConfigFile. I have some simpler example code here http://lpaste.net/149365 which tries to illustrate what I'm trying to do.
05:59:33 <opqdonut> jeeger: withExcept
06:01:17 <jeeger> opqdonut: Ah, thanks, that looks correct. Although I should use withExceptT here, right?
06:02:03 <opqdonut> jeeger: yeah
06:03:12 <jeeger> opqdonut: Cool, it works. Thanks for your help, I don't know how I missed that.
06:03:18 <joash> Is it possible to compose free monad interpreters?
06:06:47 <danilo2> Hello guys! Is there in haskell any library for pretty-printing types? I dont want something like (show ∘ typeOf) because it oftens contains some kind signatures (when any related module uses PolyKinds) and it doesnt print types like type level lists nicely (instead it prints a lot of nested applied constructors)
06:14:44 * hackagebot nettle 0.2.0 - safe nettle binding  https://hackage.haskell.org/package/nettle-0.2.0 (stbuehler)
06:18:49 <StrawberryFields> Hi, does anybody want to point a Haskell newbie in the right direction for a recursion problem?
06:19:02 <cheater> what problem have you got?
06:19:42 <bollu> what  does DataKinds do?
06:19:53 <StrawberryFields> I've got a list of strings (So like, ["ABC", "DEF", "GHI"]) and a list of indexes (So, [1, 2])
06:19:59 <bollu> StrawberryFields: a lot of the time, you don't need recursion with haskell :) list comprehensions and the like help a lot
06:20:06 <byorgey> bollu: it enables data types to be promoted to kinds
06:20:44 <bollu> byorgey: so something like True can have kind *?
06:20:58 <StrawberryFields> I want to create a new list only containing the strings that the indexes match. I thought there'd be a function that already did this and have given a look but can't find anything suitable.
06:21:12 <byorgey> bollu: no, True can be used as a type which has kind Bool
06:21:26 <byorgey> bollu: see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/promotion.html
06:21:31 <bollu> byorgey: so I can write a function like f :: True -> Int or something? (where I'm using True as a type)?
06:21:31 <bollu> thanks
06:21:54 <byorgey> bollu: yes, that would be a valid type signature
06:22:02 <bollu> hm, slick
06:22:03 <cheater> StrawberryFields: do you want to do this the easiest way, or do you want to do all the work yourself?
06:22:08 <byorgey> bollu: although that would not be a very interesting type for a function since there are no values of type True
06:22:16 <StrawberryFields> Haha, what's the easiest way?
06:22:26 <bollu> byorgey: what's a "lifted" type of which there are values?
06:22:35 <byorgey> bollu: there aren't any
06:22:37 <StrawberryFields> I want to learn as much as possible regardless of which way I do it
06:22:43 <byorgey> lifted types never have values
06:22:47 <cheater> well i'd first start by making a list of pairs like [(0, "abc"), (1, "def"), ...]
06:23:05 <bollu> > zip [1..] ["a", "b", "c", "d"]
06:23:07 <lambdabot>  [(1,"a"),(2,"b"),(3,"c"),(4,"d")]
06:23:17 <cheater> he was supposed to figure it out himself bollu
06:23:21 <bollu> ahh, sorry
06:23:34 <cheater> anyways as bollu said you could do zip
06:23:38 <cheater> have you ever used it?
06:23:40 <bollu> cheater: I thought the lazy [1..] is kind of obtuse until you see it yourself :)
06:24:04 <StrawberryFields> Yeah, I knew about zip and have used it when following tutorials
06:24:25 <byorgey> bollu: perhaps, but even so there's still value in floundering around for a while *before* someone shows you the solution =)
06:24:27 <cheater> ok so now you can filter that list
06:24:46 <byorgey> because you will appreciate/remember the solution better that way
06:24:57 <ggVGc> I want to define an operator for forward piping, such as |> in F#. Is .> an okay operator name? |> is used by Sequence, but is .> used anywhere?
06:25:00 <bollu> byorgey: right :) I'll keep that in mind (very recently do I feel comfortable in "teaching" people haskell, since I feel like a noob)
06:25:12 <cheater> StrawberryFields: you can use the filter function
06:25:14 <cheater> :t filter
06:25:15 <lambdabot> (a -> Bool) -> [a] -> [a]
06:25:19 <cheater> do you understand the type?
06:25:46 <frerich> Does anybody remember the tutorial (I think it was parse of a Haskell course) which -- to a large degree -- asked all exercises to be implemented for an infinite stream 'data Stream a = Stream a (Stream a)'? I just wanted to pass that on to a colleague (because it was kind of cool to force people into dealing with infinite structures right away) but cannot find it anymore. :-/
06:25:54 <byorgey> bollu: yes, that's a great feeling =)  and of course we don't mean to discourage you from teaching others, it's a great way to learn more yourself
06:26:31 <StrawberryFields> I've seen filter before too, so you can say for example 'filter odd [1..50]' right?
06:26:37 <cheater> yes
06:26:49 <cheater> now you need to find a function that will fit your problem, rather than "odd"
06:27:05 <byorgey> frerich: maybe this?  http://www.seas.upenn.edu/~cis194/spring13/hw/06-laziness.pdf
06:27:19 <StrawberryFields> That's excellent advice, thank you.
06:27:31 <cheater> how would you write that function?
06:28:15 <StrawberryFields> You would check if the number exists in my list of indexes
06:28:21 <frerich> byorgey: Ah, that looks like it, thanks!
06:28:24 <cheater> wait a second
06:28:28 <cheater> what are you filtering?
06:28:38 <cheater> you're filtering a list of the type [(Int, String)]
06:28:57 <cheater> so in fact, you want a function which takes such a pair, and checks if its first element is in that list of indices
06:28:58 <bollu> so, what's the point of DataKinds if all of the lifted values-to-types have no inhabitants?
06:29:00 <jgoux> Does anyone having this issue with ghc-mod ? https://github.com/DanielG/ghc-mod/issues/660
06:29:09 <frerich> byorgey: Hm yes, I think that's it (I thought I saw it it some NICTA course, but it appears I was mistaken). Thanks!
06:29:25 <StrawberryFields> Yeah, I'm sure I've seen and written something similar before in a tutorial.
06:29:25 <jgoux> each time I save a .hs file in spacemacs, I have this error relative to ghc-mod
06:29:29 <cheater> how would you write that StrawberryFields?
06:29:48 <StrawberryFields> Give me a second, I'll give it a shot
06:29:57 <dibblego> frerich: there is nothing like that in the NICTA course
06:30:08 <cheater> open up ghci and enter this code:        filter (...) (zip [1..] ["abc", "def", "ghi"])
06:30:24 <frerich> dibblego: *nod*
06:30:29 <cheater> of course you'll need to enter something for "...".
06:31:20 <Ankhers> ggVGc: is |> the same as flip (.)? 
06:32:44 <bollu> Ankhers: flip ($) actually
06:33:05 <Ankhers> bollu: Thanks.
06:34:38 <ggVGc> Ankhers: no, flip ($)
06:35:15 * frerich always writes '$' upside down to denote the flipped version.
06:36:09 <hrnz> ok.
06:37:54 <StrawberryFields> I can get specific indexes I want using 'filter ((2).fst) (zip [1..] ["abc", "def", "ghi"])'
06:38:47 <hiptobecubic> StrawberryFields, (2) is not a function
06:38:54 <hiptobecubic> you might be thinking of (==2)
06:38:55 <StrawberryFields> Sorry, I meant to type '==2'
06:39:07 <StrawberryFields> That's what I get for retyping instead of copying from terminal
06:39:12 <hiptobecubic> :)
06:39:12 <cheater> ok so
06:39:15 <cheater> what about something like this
06:39:38 <cheater> filter (\(f, s) -> ...) (zip [1..] ["abc", "def", "ghi"])
06:44:49 <StrawberryFields> Ahhh, so something like...
06:44:56 <StrawberryFields> filter (\(f, s) -> f `elem` [2, 3]) (zip [1..] ["abc", "def", "ghi"]) [(2,"def"),(3,"ghi")]
06:45:01 <StrawberryFields> May be a way to do that shorter
06:46:31 <zachk> does the ghci in ghc head run on ARM? 
06:47:39 <StrawberryFields> Thank you very much for your help Cheater (And Bollu)
06:47:59 <mnoonan> StrawberryFields: you could also write "(`elem` [2,3]) . fst" instead of your lambda, and read it like "the first value is an element of [2,3]"
06:48:16 <codedmart> I am trying to figure out how to use modifyResonse https://gist.github.com/codedmart/d938f70c4d7e1c674686
06:49:47 <StrawberryFields> Yeah I did .fst in an earlier example I showed but I think Cheater wanted to show me how to use Lambda's in this example for future use
06:50:43 <frerich> StrawberryFields: Two other ideas for fun - you could devise a function with gets the n'th element of some list, e.g. 'nthElem :: [a] -> Int -> a' (this function exists already with adifferent name but you may want to define it yourself for the fun of it). Then you could apply 'nthElement ["abc", "def", "ghi"]' to each number in your list.
06:51:14 <StrawberryFields> Yeah, that's how I was going to implement it in my software. Thank you all very much!
06:51:17 <StrawberryFields> I need to be off now, cheers
06:51:38 <frerich> StrawberryFields: Or, you could sort your list of indices and then compute the differences between subsequent numbers (e.g. '[1,2,5,8]' becomes '[1,1,3,3]') and then consider it as 'drop 1, take head, drop 1, take head, drop 3, take head, drop 3, take head'.
06:51:51 <frerich> I.e. you drop some, then take the head of the reminder. You repeat that until the list of indices is empty.
06:52:00 <StrawberryFields> That was how I was going to do it originally
06:52:05 <StrawberryFields> Before I came in here
06:52:22 <StrawberryFields> I was having trouble with the recursion element
06:52:35 <frerich> They all have different advantages, especially when you try it with very very long lists
06:53:14 <StrawberryFields> It was my instinctive thought to try it like that, probably coming from a background purely in imperative languages
06:53:50 <StrawberryFields> Thanks all, see you later
06:57:47 <Ankhers> codedmart: From your error message, it looks like you forgot to include the `r' in `responseStatus r'. Are you sure it was there when you tried compiling?
06:58:45 <codedmart> Ankhers Yeah I tried `if responseStatus r ==`
06:59:05 <Ankhers> codedmart: Same error, or different?
06:59:47 * hackagebot CPL 0.0.8 - An interpreter of Hagino's Categorical Programming Language (CPL).  https://hackage.haskell.org/package/CPL-0.0.8 (MasahiroSakai)
07:00:35 <codedmart> Ankhers same, this is exactly what I am trying now -> https://gist.github.com/codedmart/4592dc9db286ad1f3664
07:03:03 <codedmart> Ankhers Also if I wanted to inspect `r` such as print it or debug it somehow. How can I do that?
07:07:22 <jgoux> where does ghci look for shared object file ?
07:07:50 <jgoux> I can't load my project inside ghci because it can't load a shared object file (*.so)
07:08:14 <jgoux> I added the directory in which the object is in my stack.yaml file
07:08:23 <jgoux> so stack build works, but not ghci
07:09:10 <scshunt> jle`: thanks a lot for your help yesterday
07:10:17 <geekosaur> jgoux, did you try stack ghci?
07:10:43 <scshunt> blargh, ghc-mod is broken again
07:11:03 <Ankhers> codedmart: I don't think you are allowed to use do syntax there.
07:11:29 <codedmart> Ankhers You are right but I still get the same error removing it.
07:11:33 <jgoux> geekosaur: I'll try (atm it's spacemacs default ghci so I don't know which one :p )
07:11:33 <geekosaur> you can use do syntax there, it's just not doing anytihing useful
07:11:54 <geekosaur> you need to findout how to configure spacemacs to run stack ghci
07:11:59 <Ankhers> codedmart: You should get a slightly different error.
07:12:09 <geekosaur> which will run ghci pointing tot he stack stuff
07:12:16 <jgoux> geekosaur: same result with stack ghci manually
07:12:39 <geekosaur> hm, that sounds wrong :(
07:12:50 <jgoux> stack build works fine
07:12:58 <geekosaur> Ankhers, "do" is not affecting the error there
07:13:02 <geekosaur> > do do do do 5
07:13:03 <lambdabot>  5
07:13:11 <jgoux> geekosaur: here is the complete error : https://gist.github.com/jgoux/251d047d743af5f7ec71
07:13:18 <Ankhers> geekosaur: Right. I fogor you could do that.
07:13:27 <Ankhers> s/forgor/forgot
07:13:40 <geekosaur> you ccan't use <- there but "do" by itself isn't going to affect anything
07:13:42 <codedmart> Ankhers looks the same to me: https://gist.github.com/codedmart/1ecca4c153960a532202
07:14:37 <geekosaur> oh, ugh
07:14:47 <jgoux> What's weird is taht the Additional directories searched is empty
07:14:49 <geekosaur> (a) that;s aruntime issue, stack build will not show it
07:15:08 <geekosaur> (b) the real problem is oracle's client libs need extra runtime glue to work 
07:15:33 <jgoux> runtime issue ? But my project build and is executed fine :o
07:15:36 <KaneTW> > do the robot
07:15:38 <lambdabot>  https://en.wikipedia.org/wiki/Robot_(dance)
07:16:01 <jgoux> (just did a Hello world query to test)
07:16:24 <Ankhers> codedmart: I think it is because your customErrorMessages expects an Application, but the modifyResponse expects a request.
07:16:24 <geekosaur> yes, because the link stuff passes the extra glue. ghci (including "stack ghci") is not normally passed that stuff
07:17:18 <jgoux> geekosaur: I added my stack.yaml in the gist
07:17:24 <sm_> what's your stack version ?
07:17:30 <geekosaur> I am not sure how you'd do this with ghci, aside from possibly putting LF_LIBRARY_PATH in the environment
07:17:39 <geekosaur> *LD_LIBRARY_PATH
07:18:09 <jgoux> sm: stack 1.0.0
07:18:17 <geekosaur> you're supposed to embed the rpath, in a way that is not normal for build tools
07:18:19 <sm> good
07:18:23 <jgoux> geekosaur: I'll try to put it in LD_LIBRARY_PATH then
07:18:23 <oggy> is there a way to get a version of the prelude with the pre-foldable/traversable change type signatures in ghc 7.10?
07:18:40 <geekosaur> oggy, no
07:19:13 <geekosaur> in fact ghc 7.10 officially no longer supports either haskell98 nor haskell2010 because they can't be reconciled with foldable/traversable
07:19:30 <luigy> jgoux `stack ghci --ghci-options="-I/home/jgx/Downloads/instantclient_11_2"`
07:19:46 <oggy> geekosaur: thanks. that'll make teaching interesting...
07:19:50 <geekosaur> yep
07:20:08 <apriori> jgoux, stupid question, but how was ghci invoked? using "stack exec ghci"?
07:20:16 <geekosaur> foldable/traversable was being called "burning bridges proposal" originally because of this
07:20:44 <jgoux> apriori: I tried invoking it with spacemacs's haskell mode first, so I don't know the default, then "stack ghci" manually
07:20:56 <oggy> yup, i've seen that, but i hoped that there would be a workaround of some sort
07:21:14 <apriori> jgoux, yeah, I meant stack ghci, sry. hm, thats should actually work.
07:21:18 <oggy> but i guess it wouldn't be "burning bridges" then ;)
07:21:55 <apriori> jgoux, does the proper lib dir appear in the output of "stack path"?
07:22:26 <jgoux> apriori: which key do I have to look ?
07:22:35 <apriori> I'd assume extra-lib-dirs
07:22:35 <jgoux> yes
07:22:40 <apriori> *library-dirs
07:22:41 <sm> jgoux: what about luigy's suggestion
07:22:41 <jgoux> it is in stack path
07:22:53 <jgoux> sm: I try right now
07:23:39 <apriori> luigy, shouldn't that be -"L" instead? or doesn't it follow the C/C++ compiler naming?
07:24:03 <luigy> apriori yes :)
07:24:14 <jgoux> luigy: copy/pasting your solution, same error
07:24:15 <dobq> what's the main reason for using "lens" rather than "lens-simple"?
07:24:20 <jgoux> trying with "L" :p
07:24:26 <luigy> jgoux what apriori said :P
07:24:32 <apriori> "-L ..."
07:24:41 <luigy> I thinks it is a bug in Cabal and relative dirs
07:24:43 <apriori> oh yeah, better without space
07:25:08 <luigy> wait but that shouldn't affect stack
07:25:09 <codedmart> Ankhers hmm... still not getting something.
07:25:12 <luigy> hmm
07:25:13 <jgoux> great, no the error is on another *.so file
07:25:16 <jgoux> getting better ! lol
07:25:34 <apriori> jgoux, so at least that worked
07:25:41 <apriori> now find the other remainings dirs ^^
07:25:43 <sm> luigy/apriori: nice, I was wondering about that
07:25:47 <sm> The error message really needs to be improved in such cases
07:26:10 <jgoux> now the "libnnz11.so" isn't found
07:26:11 <luigy> jgoux curious can you try using an absolute dir for extra dirs in the yaml file
07:26:16 <jgoux> I don't even know what it is
07:26:22 <luigy> and not using the ghci-options
07:26:43 <jgoux> luigy: isn't what I did already ?
07:26:45 <apriori> sm, I currently had even funnier errors. Could not find module  - did you mean ? (or similar)
07:26:48 <jgoux> https://gist.github.com/jgoux/251d047d743af5f7ec71
07:26:51 <apriori> that was with ghcjs, though
07:26:58 <jgoux> extra-lib-dirs key ?
07:26:59 <luigy> oh true
07:27:12 <jgoux> it works great with "stack build"
07:27:19 <luigy> this is not the first time I see this come up
07:27:27 <luigy> I wonder if there is an open issue yet
07:27:51 <jgoux> shoudn't stack ghci be started with the same argument as "stack build" ?
07:27:59 <jgoux> this is what I would expect
07:28:42 <apriori> provide -v 
07:28:54 <apriori> like stack build -v, maybe even stack ghci -v
07:28:56 <jgoux> luigy: even with your "stack ghci --ghci-options="-L/home/jgx/Downloads/instantclient_11_2"" I have a new *.so library not found (never seen this one ^^)
07:29:01 <jgoux> ok
07:29:21 <quchen_> Hm, I can't think of a Foldable that's not also Traversable off the top of my head.
07:29:36 <apriori> jgoux, what is your exact output of stack path, if I may ask?
07:29:51 <jgoux> I'll paste it all in the gist, one minute please
07:29:53 <apriori> maybe you could just script the construction of the arguments to ghc--options
07:32:25 <jgoux> apriori: It's all in the gist
07:32:37 <jgoux> oh I forgot stack path
07:32:39 <apriori> jgoux, I think nothing was build in your invocation of stack build -v
07:32:46 <apriori> could you clean and rebuild?
07:32:54 <jgoux> lol my bad, sorry
07:34:39 <apriori> jgoux, also add an "ldd" on the resulting executable, please
07:34:50 * hackagebot geniplate-mirror 0.7.2 - Use Template Haskell to generate Uniplate-like functions.  https://hackage.haskell.org/package/geniplate-mirror-0.7.2 (DanRosen)
07:35:01 <jgoux> ldd ?
07:35:09 <jgoux> in the cabal file ?
07:35:09 <apriori> jgoux, linkage info
07:35:12 <apriori> on the executable
07:35:22 <apriori> assuming you build an executable at all
07:35:35 <jgoux> apriori: Where do I have to add ldd ?
07:35:40 <apriori> to gist
07:35:56 <jgoux> sorry, I meant what the exact command do you want me to do ?
07:36:03 <apriori> its a command to just showlinked libs for an exutable 
07:36:15 <apriori> ldd ./dist/build/someWeirdExecutableName
07:36:21 <jgoux> oh ok :)
07:36:23 <sm> jgoux: ldd `stack exec which EXE`
07:36:34 <apriori> sm that works?
07:36:35 <codedmart> Ankhers How can I inspect `r`, such as print or debug it?
07:36:46 <apriori> ah yeah, it should
07:38:45 <quchen_> codedmart: You can't inspect much about an arbitrary `r`, really.
07:38:57 <quchen_> You can force the value of type `r` and see whether it's not bottom.
07:39:02 <quchen_> But that's it
07:39:16 <jgoux> sm: apriori gist updated
07:39:17 <quchen_> Unless you have a Show constraint for your `r`, then you can print it out.
07:39:37 <codedmart> quchen_ I am just trying to figure out how to debug things in haskell and in this case `r` has a show instance I believe.
07:39:59 <quchen_> codedmart: Then have a look at Debug.Trace
07:40:35 <apriori> jgoux, so apparently, both your libs should be in the given lib dir.
07:40:38 <quchen_> codedmart: http://hackage.haskell.org/package/base-4.8.1.0/docs/Debug-Trace.html
07:41:26 <codedmart> quchen_ Thanks!
07:41:43 <jgoux> apriori: so doing "stack ghci" with ghci-options pointing to the right folder should works right ?
07:42:01 <jgoux> if it can find one .so it should also find the other, they're in the same folder xD
07:42:01 <apriori> jgoux, I think so, yes
07:42:35 <apriori> I mean, it aparently loaded the one lib, but complained for libnnz11.so 
07:42:49 <jgoux> hmm
07:42:56 <jgoux> now it complains again about the first one
07:43:12 <apriori> jgoux, exact invocation plz
07:43:29 <apriori> relative paths will cause issues if you navigate around
07:43:30 <geekosaur> fo course it could be that one is loaded by ghci directly and the other is loaded indirectly via one of the linked packages; the latter probably doesn't get to see ghci's -L
07:44:51 <sm> move everything to /usr/lib ? :)
07:44:51 * hackagebot diagrams-canvas 1.3.0.3 - HTML5 canvas backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-canvas-1.3.0.3 (jeffreyrosenbluth)
07:45:07 <jgoux> apriori: no it's complaining about hte second one
07:45:55 <jgoux> apriori: I put the invocation + result in the gist, see "stack ghci" file
07:46:49 <apriori> uff.
07:46:53 <jgoux> sm: I think it will end like this :p
07:47:00 <apriori> well, update the information with these:
07:47:04 <jgoux> sm: but would be great to find why this isn't working
07:47:15 <apriori> stack ghci --ghc-options="-v"
07:47:18 <apriori> same for stack build
07:47:25 <apriori> note "ghc-options" not ghci
07:47:37 <jgoux> ok
07:47:48 <jgoux> apriori: without the path ?
07:47:54 <apriori> yup
07:47:57 <jgoux> just "stack ghci --ghc-options="-v"" ? ok
07:48:10 <apriori> and same for stack build
07:48:19 <apriori> trying to find, where that info "gets lost"
07:48:21 <maerwald> you should never manually move stuff to /usr/lib, unless you are ready to break your system
07:48:43 <sm> it was a joke, but I might temporarily symlink problem libs there to see if it is indeed a path issue
07:49:41 <apriori> jgoux, again you did it on already built projects :P
07:50:02 <jgoux> apriori: what ?
07:50:20 <apriori> jgoux, e.g. stack ghci --ghc-options="-v"
07:50:27 <apriori> it didnt build anything
07:50:28 * sm wishes for a better way to troubleshoot than parsing laborious, error-prone pastes
07:50:38 <jgoux> xD
07:50:39 <apriori> so for both, clean before the invocation
07:50:53 <jgoux> sorry, it's my second day with Haskell, I have no idea what I'm doing :D
07:51:01 <apriori> jgoux, oh, ok
07:51:03 * geekosaur wishes oracle's client libs weren't an utter PITA to work with
07:51:41 <geekosaur> in my experience it's ALWAYS a pain to get the instant client stuff to be found
07:51:58 <apriori> I'm tempted to suggest LD_LIBRARY_PATH
07:52:05 <sm> ghc/cabal/stack should make this easier though
07:52:11 <geekosaur> I mentioned that early on
07:52:13 <jgoux> geekosaur: I've been on it since yesterday lol
07:52:21 <jgoux> geekosaur: just to build the project xD
07:52:45 <jgoux> apriori: the stack ghci --ghc-options="-v" should be fine now
07:53:03 <codedmart> Ankhers It had to do with import :|, thanks!
07:53:35 <apriori>  setup: The program 'sqlplus' is required but it could not be found.
07:54:17 <Ankhers> codedmart: Glad you got it working.
07:54:27 <jgoux> Yes, the library won't compile without it, but I added it in my PATH and it was fine without the ghc-options="-v" xD
07:54:50 <apriori> jgoux, so, I idk, smells like a stack bug so far
07:55:31 <jgoux> wow wow wow
07:55:41 <jgoux> I didn't sourced my ~/.profile for sqlplus
07:55:53 <apriori> facepalm -.-
07:55:53 <jgoux> I changed my terminal between the tests, ok wait :p
07:55:54 <apriori> :)
07:56:07 <apriori> still, that won't solve the lib issue, I think
07:56:38 <jgoux> yes still the issue
07:56:42 <jgoux> I update the gist
07:57:13 <jgoux> updated stack ghci --ghc-options="-v" result
07:57:46 <jgoux> running stack build --ghc-options="-v"
07:57:47 <hexagoxel> what should i replace Writer monad with (DList payload), for some mildly performance-sensitive code?
07:57:59 <hexagoxel> is there something prettier than simply State?
07:58:05 <sm> you should try to find out the exact command being run by stack build and stack ghci
07:58:17 <apriori> sm, that's what we are on
07:58:22 <apriori> but I guess, we need a bit more "-v"
07:59:02 <apriori> jgoux, change to "stack build --ghc-options="-v" -v" and same for ghci
07:59:17 <jgoux> apriori: ok
08:00:34 <jgoux> stack build --ghc-options="-v" -v is here
08:00:37 <sm> stack build -v, stack ghci -v seems enough here
08:02:04 <jgoux> and stack build --ghc-options="-v" -v is here too
08:03:13 <apriori> jgoux, manually invoke that huge ghc line with "-L $libdir" plz
08:03:30 <apriori> something like "stack exec -- ghc --interactive ......"
08:04:10 <jgoux> apriori: not sure I get the exact syntax, which line ?
08:04:33 <apriori> 67
08:04:38 <apriori> everything after "run process:"
08:04:44 <apriori> but add "stack exec --" before it
08:04:58 <apriori> and "-L/home/jgx/Downloads/instantclient_11_2" after it
08:05:44 <jgoux> line 67 from which output please ?
08:05:51 <jgoux> there is a lot of them now ^^
08:06:13 <apriori> my bad, of stack ghci --ghc-options="-v" -v
08:07:00 <sm> ghci is not being run with --extra-lib-dirs
08:07:33 <apriori> sm does it have that command line option?
08:07:43 <apriori> or is there only "--ghc-options=-L..."?
08:08:41 <sm> hm, true
08:08:55 <jgoux> apriori: just "-L/home/jgx/Downloads/instantclient_11_2" after the whole line ?
08:09:03 <jgoux> without option ?
08:09:17 <apriori> jgoux, yes
08:10:35 <jgoux> apriori: https://gist.github.com/jgoux/251d047d743af5f7ec71#file-stack-exec-huge-line
08:11:44 <apriori> jgoux, plz change it to:
08:11:44 <jgoux> maybe I should remove the last "@stack" part ?
08:11:49 <apriori> stack exec -v -- ....
08:11:53 <jgoux> ok
08:12:00 <apriori> jgoux, and yes
08:12:11 <apriori> get rid of the @stack and src/Stack ...
08:14:00 <jgoux> apriori: https://gist.github.com/jgoux/251d047d743af5f7ec71#file-stack-exec-huge-verbose
08:15:10 <apriori> jgoux, it actually shows it looked in the directory and failed
08:16:16 <jgoux> apriori: which line ?
08:16:24 <apriori> 18, 19
08:17:02 <apriori> jgoux, can you maybe upload your project?
08:17:20 <apriori> I'd be interested in debugging it further. who knows, might result in a pull request to stack.
08:17:44 <apriori> alternatively I could of course build my own, which would take a bit
08:18:13 <apriori> actually, lemme see whether I can reproduce it with a simple project
08:18:19 <jgoux> the project is really just the hello world from takusen-oracle
08:18:28 <jgoux> do you want my .cabal ?
08:18:55 <apriori> jgoux, nah, lemme try to setup a simple project.
08:18:58 <jgoux> ok :)
08:19:04 <apriori> stack could later use a test case for this crap
08:19:30 <apriori> or well, copy your cabal
08:19:31 <jgoux> for the instantclient, I took both basic + sdk + sqlplus, all extract in the same folder
08:19:37 <apriori> I forgot how to add dynamic libs :P
08:19:39 <apriori> barely ever do it
08:19:44 <sm> maybe #haskell-stack knows more
08:21:14 <jgoux> apriori: https://gist.github.com/jgoux/251d047d743af5f7ec71#file-test-oracle-cabal
08:21:22 <apriori> jgoux, ty
08:21:50 <jgoux> apriori: so did you ever use haskell to query an oracle database ?
08:22:07 <apriori> jgoux, ohm, the lib dir is not mentioned anywhere there
08:22:07 <jgoux> I had a hard time finding a lib do to it without ODBC
08:22:22 <jgoux> apriori: maybe it's the issue ? :D
08:22:34 <jgoux> but why does it works for stack build ?
08:22:45 <apriori> because stack build might only use your stack.yaml
08:22:49 <apriori> but that is a assumption
08:23:05 <jgoux> what do I have to add to the cabal ?
08:23:46 <apriori> jgoux, gimme a sec, quite some time ago, that I did that
08:24:20 <jgoux> for the Main.hs, I took the one from takusen-oracle : https://github.com/paulrzcz/takusen-oracle#using-ie-writing-data-access-code
08:25:03 <apriori> there it is
08:25:09 <apriori> https://github.com/paulrzcz/takusen-oracle/blob/master/takusen-oracle.cabal
08:25:13 <apriori> 95-98
08:26:59 <jgoux> but it does find the right library name
08:27:03 <jgoux> because it's named in the error
08:27:27 <apriori> jgoux, gimme a minute, please. trying to reproduce it here.
08:27:34 <jgoux> sure :)
08:27:46 <jgoux> Thanks for your help
08:30:03 <jgoux> apriori: I'm sorry I need to leave a moment, could you continue the discussion on my gist until I get back ?
08:30:48 <jgoux> In ~1 hour
08:30:48 <jacereda> looks like "ghc --make" only rebuilds altered modules if the exported functions remain the same, is there some way to tell "stack build" to do the same?
08:31:55 <jgoux> apriori: sm see ya and thanks again for the help !
08:32:13 <sm> np, don't forget #haskell-stack. "stack ghci fails to find lib where stack build succeeds"...
08:32:18 <jacereda> what I mean is that if I change Foo.hs without altering function signatures it won't compile modules depending on Foo
08:32:29 <apriori> jgoux, yup
08:32:32 <jgoux> sm: will ask there as well if apriori reproduce
08:32:38 <jgoux> bye ;)
08:33:07 <apriori> sm I've the impression the issue is here, that a dependent project requires a runtime lib. and that info might get lost for the current project
08:34:19 <geekosaur> jacereda, that maynot actually be safe
08:34:48 <geekosaur> itwould have to determine if anything in the.hi file would change, and the only way to do that safely si to generate the new .hi file, which means compiling it
08:35:30 <geekosaur> (note that the .hi file contains source code for cross-module inlining, ad that can change even if the things most people consider part of the signature remain the same)
08:35:54 <geekosaur> in effect, the function signature potentially includes the entire source of the function
08:36:03 <jacereda> geekosaur: but looks like that's what "ghc --make" is doing... am I wrong?
08:36:13 <geekosaur> ghc --make may be wrong
08:36:22 <geekosaur> theyre still sorting out issues related to this
08:36:30 <geekosaur> soem of the intended fixes did not even make 8.1
08:37:15 <geekosaur> or, documentation may say function signature and you;re not considering that the function signature can include the entire function source >.>
08:37:35 <geekosaur> so ghc --make could notice that the .hi stuff changed and force a recompile of dependents anyway; stack would have to do extra work to verify it
08:38:31 <geekosaur> probably easier fot stack to assume that it changed and rebuild the dependents anyway, especially given the known issues with this when not doing it all in the same ghc process
08:39:09 <geekosaur> (this is also biting cabal-install and nixpkgs)
08:39:45 <jacereda> geekosaur: I guess at some point they will come up with some good heuristic to discern safe/unsafe changes...
08:40:09 <jacereda> geekosaur: but now that I know the downsides, is there any way to ask stack to do the same?
08:40:09 <glguy> You 
08:40:22 <geekosaur> well, one of the issues is that there are compiler temporaries whose names change between runs
08:40:56 <geekosaur> ghc itself can tell it's the same, stack or any other external tool could only do so with great difficulty
08:43:37 <jacereda> geekosaur: thanks, understood
08:44:12 <geekosaur> (not just great difficulty but stack would probably break with every new ghc release)
08:48:58 <logzet> Hi, is Fruit == Grapefruit? https://www.haskell.org/fruit seems to be dead, but there is Grapefruit that looks like what I expected to find there ( https://wiki.haskell.org/Grapefruit )
08:54:31 <fractalsea> If one thread is receiving from a Handle (tcp socket), and another thread calls close, should the receiving thread read an empty string?
08:55:05 <fractalsea> Or could the receiving thread hang?
08:56:41 <dzdcnfzd> I'm parsing a JSON thing using Aeson, and I have a problem: There's a field with a key called "children", whose value type can either be 1. an object or 2. an empty string
08:57:04 <dzdcnfzd> I'm trying to figure out how to make a parser that will figure out which one it is and switch on the result
08:58:20 <dzdcnfzd> My idea -- and I may just be getting caught up in the execution, is to decode it as a Value and then figure out whether it's a String or an Object
08:58:40 <Cale> fractalsea: I think it'll cause the reading thread to get an exception next time it tries to read from the closed handle. If that exception isn't caught, it'll kill the thread.
08:59:21 <dirkdiiggler> g'day
08:59:22 <dzdcnfzd> I just can't figure out how to express that in the do notation for the parseJSON implementation
08:59:30 <fractalsea> Cale, hmm I see. But isn’t a handle wrapped in an MVar? I’m basically worried that the closing thread won’t actually be able to call close on the Handle
08:59:57 <Cale> fractalsea: Not to the best of my knowledge.
09:00:17 <Cale> fractalsea: I don't think hClose can ever block...
09:02:40 <Cale> dzdcnfzd: Well, that's sort of always the approach with Aeson -- it's pretty much what writing a FromJSON instance consists of
09:03:20 <geekosaur> close() can certainly block, but only under certain cirumstances. I do't kno offhand if the IO subsystem in the runtime deals with this
09:04:00 <Ankhers> `data MyType = MyType { ... } | String' appears to be valid, but how would I create a String that has a type of MyType?
09:04:29 <Cale> Ankhers: That String data constructor you just defined has nothing to do with the type String
09:04:32 <geekosaur> Ankhers, it's valid but doesn't do what you think
09:04:32 <jgoux> apriori: I'm back ^^
09:04:50 <Cale> You might as well have written Aardvark there, and the type would mean about the same thing
09:05:05 <fractalsea> Cale, OK thanks. Unfortauntely the docs are very unclear
09:05:10 <jgoux> apriori: were you able to reproduce the issue ?
09:05:10 <Ankhers> Cale, geekosaur: Understood, thanks!
09:06:39 <apriori> jgoux, was busy cooking and now eating
09:06:42 <apriori> but I do continue
09:06:47 <Ankhers> dzdcnfzd: Instead of creating a complex parser, would you be able to make that field an `Either Foo String', or `Either String Foo', not sure if it makes too much of a difference.
09:06:57 <jgoux> apriori: take your time, bon appétit :D
09:07:07 <apriori> ty
09:07:31 <dzdcnfzd> Ankhers: Well, the issue is that I want it to be just a list of things
09:07:56 <dzdcnfzd> Ankhers: and unfortunately, the way that this JSON decides to encode the empty list
09:07:57 <Cale> Ankhers: The syntax of data declarations consists of the keyword 'data' followed by the name of a new type constructor, followed by a sequence of zero or more distinct type variables, and then '=' and then a '|'-separated list of cases, each of which consists of the name of a new data constructor followed by a sequence of types for its arguments.
09:08:04 <dzdcnfzd> Ankhers: is with an empty string. 
09:08:37 <Cale> dzdcnfzd: Aeson's Parser type is an instance of Alternative
09:08:55 <monochrom> Parser (Maybe Object). use Nothing to stand for "I saw an empty string"
09:08:57 <Cale> dzdcnfzd: So you can use <|> to try different parsers
09:09:14 <Ankhers> Cale: So I essentially created a `String' constructor for MyType?
09:09:20 <Cale> Ankhers: yeah
09:09:29 <Ankhers> Cale: Thanks for the info.
09:09:35 <dzdcnfzd> Cale: I keep reading this but I've never actually understood what it means. If it's the right rabbit hole to go down I can start reading now
09:09:39 <Cale> Ankhers: Which has nothing to do with the String type -- they live in completely separate namespaces
09:09:47 <Ankhers> Indeed.
09:09:49 <dzdcnfzd> Cale: this meaning "Alternative"
09:10:30 <Cale> dzdcnfzd: Oh, well, it's basically just:
09:10:38 <Cale> class Applicative f => Alternative f where
09:10:41 <Cale>   empty :: f a
09:10:48 <Cale>   (<|>) :: f a -> f a -> f a
09:10:52 <Ankhers> > Nothing <|> Just 5
09:10:54 <lambdabot>  Just 5
09:11:03 <dzdcnfzd> I see
09:11:15 <dzdcnfzd> and 
09:11:16 <Cale> (and there are some and many methods, but they have default implementations which will rarely be overridden)
09:11:21 <dzdcnfzd> Just 5 <|> Just 6
09:11:29 <Cale> > Just 5 <|> Just 6
09:11:31 <lambdabot>  Just 5
09:11:34 <dzdcnfzd> > Just 5 <|> Just 6
09:11:36 <lambdabot>  Just 5
09:12:12 <dzdcnfzd> Yeah. The one thing I worry about is the fact that if I'm wrong with my first parser, I don't think I'll get a Nothing. I think I'll get a parse error
09:12:35 <Ankhers> I was just showing with Maybe.
09:13:22 <Ankhers> Basically, if the first argument in `<|>' is `empty' for that applicative, it will try the second argument. You can also chain these as long as you want.
09:13:31 <Ankhers> > empty :: Maybe Int
09:13:34 <lambdabot>  Nothing
09:13:44 <Cale> dzdcnfzd: The point is that Parser can also take the place of f in these types, not just Maybe
09:14:10 <Cale> dzdcnfzd: and Parsers are combined by constructing a Parser which tries the first, and if it fails, tries the second
09:14:30 <dzdcnfzd> I see. Do you have any sort of code example?
09:15:01 <dzdcnfzd> In the aeson tutorial I'm reading, he gives:     age  <- o .: "age" <|> o .: "AGE"
09:15:12 <dzdcnfzd> But that isn't actually the sort of thing I'm interested in
09:15:34 <dzdcnfzd> because the field will always exist -- it just might be one of two types
09:17:23 <dzdcnfzd> brb
09:18:05 <Cale> dzdcnfzd: Well, so long as you can include the results of either case in the same Haskell type, you can match either result -- note that there's an implicit choice here of what the type of the resulting field is
09:20:45 <Cale> You can write  age <- fmap Left (o .: "age") <|> fmap Right (o .: "age")   for example, and then have  age :: Either A B  for any types A and B which are instances of FromJSON
09:23:25 <Cale> dzdncnfzd: back?
09:23:41 <monochrom> dzdcnfzd: http://lpaste.net/149425
09:23:45 <dzdcnfzd> Cale: yeah
09:24:38 <Cale> Yeah, see monochrom's example, it's pretty much exactly what you need
09:24:51 <dzdcnfzd> monochrom: mmm that's cool
09:24:52 <dzdcnfzd> thanks
09:24:58 <Cale> dzdcnfzd: But just in case you missed what I said,
09:24:58 <ReinH> Cale: Either a b already has a FromJSON instance with a and b do
09:25:02 <Cale> You can write  age <- fmap Left (o .: "age") <|> fmap Right (o .: "age")   for example, and then have  age :: Either A B  for any types A and B which are instances of FromJSON
09:25:09 <ReinH> Not sure if that helos
09:25:12 <ReinH> helps
09:25:21 <ReinH> s/whith/when
09:25:26 <ReinH> sorry I can't type today jesus
09:25:31 <Cale> ReinH: I'm pretty sure that instance will actually encode the tag somehow
09:25:45 <Cale> (or decode it)
09:26:05 <dzdcnfzd> Cale: but the type of age would be B right?
09:26:07 <dzdcnfzd> Like
09:26:17 <ReinH> Cale: oh right
09:26:21 <Cale> dzdcnfzd: nope, it'd be Either A B
09:26:26 <dzdcnfzd> I see
09:26:35 <dzdcnfzd> I'm confusing the parser bind with the either bind
09:26:49 <Cale> Yeah, that's the Parser bind
09:28:44 <apriori> jgoux, what it comes down to, is the typical shared libs issue
09:29:49 <jgoux> apriori: so you have exactly the same error ?
09:30:14 <apriori> jgoux, well, I currently got it even more severe, but it has nothing to do with stack (so far)
09:30:24 <jgoux> ok
09:30:25 <apriori> you got (cabal) library A, linking to a shared library. the linking is dynamic, the (exact) path information is lost.
09:30:52 <apriori> then you say, you got a project B that depends on A, which is dynamically linked. 
09:31:29 <apriori> it will be build, because A was built successfully, because of the proper path information at build time.
09:32:07 <apriori> ghci goes one step further and actually cares about doing the linking on in its own. which will fail, because path information to the libs is not provided
09:32:25 <apriori> TL;DR: use LD_LIBRARY_PATH
09:33:13 <jgoux> apriori: so it's not stack related but ghci related ?
09:33:24 <apriori> neither, its compile time vs runtime
09:33:32 <jgoux> ok
09:33:40 <apriori> if you link shared, you say your environment provides the libs. 
09:33:58 <apriori> and that even across libraries (which might depend on their own set of shared libs)
09:34:15 <apriori> "solution" to this would be using rpaths or static linking
09:34:31 <jgoux> I'm fine with LD_LIBRARY_PATH :D
09:34:37 <apriori> yeah
09:35:13 <jgoux> apriori: is there anything better than takusen-oracle in Haskell for querying Oracle ?
09:35:23 <apriori> I don't have the slightest idea :)
09:35:25 <jgoux> I only saw ODBC based solutions
09:35:29 <jgoux> ok :p
09:35:37 <jgoux> Anyway, thanks for all these investigations ^^
09:35:59 <apriori> jgoux, still, poke stack about this.
09:36:35 <apriori> because ghci should get a solution for this. because your expectation is not wrong. you can build it, why shouldn't you be able to also ghci it?
09:37:04 <jgoux> ok, I'll ask on #haskell-stack
09:37:33 <dobq> (STM) "atomically inside unsafePerformIO isn't possible." why not?
09:39:29 <apriori> dobq, how would that work?
09:39:41 <dobq> like i'd expect it to work?
09:39:51 <apriori> dobq, what does unsafePerformIO again?
09:40:26 <dobq> apriori: i don't know what you're getting at. note: i don't know GHC internals.
09:40:29 <geekosaur> how do you expect something that is not sequenceable or lockable against other IO to sequence itself against oter IO or make sure some other IO action doesn't change stuff out from under it?
09:40:52 <dobq> geekosaur: i'm not expecting this to work safely
09:41:05 <dobq> i'm expecting it to do something
09:41:18 <dobq> e.g. create a TVar with newTVar
09:41:34 <dobq> e.g. for a global that i need for whatever evil reason
09:41:45 <barrucadu> There's `newTVarIO` if you need that
09:41:51 <dobq> yes. i'm wondering why i need that
09:42:00 <dobq> why is newTVar not sufficient
09:42:22 <dobq> what is the difference between newTVarIO and atomically . newTVar
09:42:31 <geekosaur> "okay STM, u=if you are done inside unsafePerformIO pretend you're not STM"?
09:42:51 <geekosaur> I mean, the whole point of STM is gone if you unsafePerformIO it
09:43:01 <dobq> geekosaur: i know. i'm not asking for safety.
09:43:04 <dobq> the claim is "atomically inside unsafePerformIO isn't possible."
09:43:12 <geekosaur> I think it is reasonable for STM to not become not-STM
09:43:19 <geekosaur> you're missing the point
09:43:19 <dobq> to justify that newTVarIO is *crucial* to have
09:43:35 <dobq> "IO version of newTVar. This is useful for creating top-level TVars using unsafePerformIO, because using atomically inside unsafePerformIO isn't possible."
09:43:54 <dobq> so in the context of that docstring, what is the difference between newTVarIO and newTVar
09:44:00 <dobq> atomically . newTVar
09:44:04 <geekosaur> "I'm not asking for safety" *by definition* means you do not want STM
09:44:08 <dobq> :-/
09:44:23 <dolio> newTVarIO doesn't use atomically, presumably.
09:44:23 <geekosaur> if STM is to provide safety *at all* then it must do things that are not compatible with unsafePerformIO
09:44:25 <fryguybob> dobq: Atomically under unsafePerformIO opens the possiblilty of atomically.
09:44:35 <fryguybob> dobq: Atomically under unsafePerformIO opens the possiblilty of atomically under atomically.
09:44:37 <dobq> dolio: ah, so how does it go around that?
09:44:53 <dolio> Hard-wired magic.
09:44:58 <fryguybob> dobq: A directly implementation in the runtime system.
09:45:08 <dobq> dolio: is "magic" the best we can say?
09:45:32 <dobq> fryguybob: yes i understand. but the entire premise of this docstring is that one wants to use unsafePerformIO, so that is *always* unsafe
09:45:32 <dolio> No. You can probably go read the RTS implementation in C or something.
09:45:43 <dobq> the STM lib is implemented in C?
09:46:02 <fryguybob> dobq: It is a mix of C, Cmm and Haskell
09:46:14 <quchen> STM is part of the GHC runtime, "the STM lib" uses that part of the runtime.
09:46:47 <fryguybob> dobq: The consequences are different from the usual unsafety from unsafePerformIO
09:47:14 <dobq> fryguybob: right. how and why.
09:47:39 <dobq> fryguybob: in which sense is one of the two "impossible"
09:47:46 <dobq> does the universe explode if i try?
09:47:54 <fryguybob> dobq: There is context set up when you do atomically, if you do atomically again, no one has written the code to expect the context a second time.
09:48:03 <geekosaur> atomicity is not a wrapper that you can discard when it becomes inconvenient
09:48:04 <fryguybob> dobq: The desired semantics are not at all clear.
09:48:09 <dolio> So, the answer is that newTVar# is a primop that has a type that will work for both STM and IO. newTVarIO uses it directly for IO.
09:48:10 <geekosaur> atomicity is fundamental
09:48:20 <sm> has anybody got any currently-working haskell-based twitter tools ?
09:48:30 <dobq> geekosaur: you are ignoring the fact that i understand this already
09:48:36 <Clint> sm: twidge used to work
09:48:44 <dolio> But, newTVar is in STM, and the only way you have to get it into IO is to call atomically.
09:48:50 <geekosaur> yet you do not understand something about this, or you would not be asking
09:48:55 <dolio> Unless you unsafeCoerce it to IO.
09:49:12 <dobq> geekosaur: the documentation says that under the *unsafe* premise of using unsafePerformIO, one is better off using newTVarIO rather than atomically.newTVar. i'm asking for the difference.
09:49:17 <sm> Clint: thanks, I'll check it. I'd like eg a reliable client to archive a twitter feed
09:49:58 <Clint> sm: it needs to be updated to work with newer libraries but maybe you can build it with old ones
09:50:04 <dobq> fryguybob: so this is some kind of run-time context STM uses to make an STM action into an IO action?
09:50:04 <fryguybob> dobq: The difference is with newTVarIO it simply makes the TVar structure and returns it.
09:50:26 <geekosaur> the difference is that newTVarIO is using a backdoor so it doesn't need to be forced atomic
09:50:33 <fryguybob> dobq: With atomically . newTVar you set up a transaction environment, make a new TVar, then commit the environment.
09:50:34 <dzdcnfzd> So, I've implemented some of the Aeson stuff, and I'll find out whether it works soon. Question first, though: I have two seemingly identical places in the code where I map over an array. In one place, I'm able to save the result as a list (how!?) and in the other place I'm not. Any ideas on the difference?  http://lpaste.net/149426 
09:50:48 <dobq> geekosaur: right, and do you have any idea what this backdoor is about?
09:50:58 <quchen> fryguybob: So it's just an optimization to cut out the atomically middle man?
09:51:06 <geekosaur> you can't force atomicity under unsafePerformIO because unsafePerformIO prevents verifying that it is truly atomic
09:51:07 <dobq> fryguybob: ah that's getting somewhere, thanks :)
09:51:22 <ggVGc> how can I turn a [IO ()] into an IO?
09:51:24 <Cale> dobq: well, the implementation of newTVarIO is identical to that of newTVar except that it replaces the STM data constructor with an IO data constructor. Whereas, atomically (STM m) = IO (\s -> (atomically# m) s )
09:51:36 <ggVGc> i.e can I make one IO action that is a sequence of others
09:51:36 <quchen> ggVGc: You nean into an "IO ()"? sequence_ does that.
09:51:36 <Cale> dobq: So the difference is an application of atomically#
09:51:43 <ggVGc> thanks
09:51:59 <dobq> Cale: thanks, that is very helpful
09:52:08 <Cale> dobq: Whether this means anything to you depends on whether you know how atomically# is defined.
09:52:13 <quchen> ggVGc: https://github.com/quchen/articles/blob/master/functions_comprehensible.md#sequencemapm
09:52:30 <Cale> But it's a compiler primitive, so you'll need to dig into GHC's source now to find out exactly how it's implemented.
09:52:55 <dobq> Cale: i suppose atomically# would be the thing that sets up the contexts that fryguybob was talking about?
09:53:11 <dobq> (and then runs some code, rolls back if necessary, etc etc)
09:54:27 <Cale> yeah, presumably
09:55:59 <dobq> Cale: okay, and now unsafePerformIO (atomically (STM m)) would be... lazy (case (\s -> (atomically# m) s ) realWorld# of (# _, r #) -> r)
09:57:24 <Cale> Yeah, I don't even really want to think about what happens there -- if you find yourself wanting to use unsafePerformIO and STM together, it's probably better just to reconsider your life choices.
09:57:33 <geekosaur> so, atomically# relies on IO enforcing that IO actions occur in sequence, so nothing can intervene. but unsafePerformIO violates that
09:57:54 <dobq> yeah no i don't *want* to. but the docs say that it is "impossible", so htat sounds like a very hard and interesting claim
09:57:55 <geekosaur> so now you could nest one atmically inside another, or have two of them run at the same time and change things out from each oter
09:58:22 <geekosaur> "impossible" may mean that unsafePerformIO sets something in its faked-up IO that tells atomically that it cannot happen safely
09:58:29 <Cale> dobq: It's probably easier just to try it and see how broken it is
09:58:50 <geekosaur> (or possibly does *not* set up something that atomiclly needs to have present...)
09:58:51 <Cale> I'm not sure what happens, but it's not like there's likely to be some nice algebraic reason that it's like that
09:59:26 <Geff22> Hello! Can you get me advice? I want to use OpenAL in my own app, but I am stuck on OGG Vorbis loading. What best way to decode Vorbis in Haskell?
09:59:35 <Cale> But regardless, concurrency inherently makes it extra hard to ensure that unsafePerformIO is really going to be okay to use in the first place, so mixing the two is a great way to lose all your hair.
10:00:00 * hackagebot inline-c 0.5.5.2 - Write Haskell source files including C code inline. No FFI required.  https://hackage.haskell.org/package/inline-c-0.5.5.2 (FrancescoMazzoli)
10:00:02 <dobq> Cale: i'm willing to believe that :)
10:00:53 <umib0zu> hi all. is the wikibook for haskell still considered up to date and a good resource for someone after reading LYAH?
10:00:54 <Cale> Geff22: I'm not sure. You said that the libvorbis library wasn't working for you in the other channel?
10:01:55 <Cale> umib0zu: Good question, I have no idea.
10:02:11 <Cale> Last I looked at it, it was of pretty variable quality...
10:02:27 <Cale> But hey, it's a wikibook, people might've improved it
10:02:58 <dobq> umib0zu: i think that after reading LYAH you should go off and write some code and learn more as you go...
10:03:34 <EvilMachine> Hi. What does this error (during the configure to build GHC) mean? http://lpaste.net/149429
10:03:34 <Geff22> Cale: Yes, it's not working. read return sequence of \null
10:03:44 <umib0zu> you’re right. I’m currently still learning state monads and monad transformers.
10:04:00 <umib0zu> the wiki is helpful, but I’m looking for a LYAH 2
10:04:13 <EvilMachine> (It appears while trying to configure GHC 7.10.3 on ARM)
10:04:22 <dolio> dobq: I think by 'impossible' they mean the implementation is not set up so that all uses of atomically inside unsafePerformIO will do the right thing and not crash, so you'd better not use it.
10:04:30 <dobq> umib0zu: i don't think such a document exists unfortunately. but "what i wish i knew when learning haskell" is a good reference
10:04:52 <dobq> dolio: yeah it seems that that's what it is :)
10:04:58 <dolio> You basically get undefined behavior.
10:05:27 <dolio> And I'd expect that the main difficulty is in supporting nested transactions.
10:05:44 <dolio> Which STM doesn't do, but unsafePerformIO could easily set up.
10:05:55 <dobq> dolio: well yes, but when you're using unsafePerformIO you're already in dangerous waters
10:06:03 <dobq> this docstring phrases it as if there is an extra cause for worry
10:06:15 <exio4> it is an extra cause for worry
10:07:54 <sm> Clint: twidge sounds great, thanks for the pointer. Not trivially updateable, I'll look at it (or hs-twitterarchiver or twhs) again later
10:09:09 <fryguybob> dobq: There is an extra cause for worry because using  unsafePerformIO  with the  IO varients of STM primitives is the *only* way to do certain things (like global variables).
10:10:11 <fryguybob> dobq: So some particular uses of unsafePerformIO are being declared safe which leads to the emphasis that something that appears to be equivalent really is not.
10:10:21 <dolio> Right. Some things _will work_ with unsafePerformIO, even though it's dangerous waters. This _won't work_. :)
10:10:44 <quchen> Evasdropping on this conversation was pretty useful, thanks everyone :-D
10:10:57 <dobq> yes, and so the reason that this doesn't work is because it uses this atomically# which does all kinds of magic which might break in certain contexts, whereas newTVarIO uses less fancy mechanisms and works more often
10:10:59 <fryguybob> The scary part is that some of the won't work things won't work in quite non-trivial ways.
10:11:01 <quchen> I had no idea unsafePerformIO . atomically had these unsafeties.
10:11:26 <quchen> GHC's unsafe functions really live up to their name.
10:11:28 <fryguybob> dobq: Right.
10:11:33 <dobq> fryguybob: thanks :)
10:12:02 <dobq> dolio, Cale: thanks to you too :)
10:12:12 <Clint> sm: if you find anything that's maintained and works, let me know
10:12:57 <fryguybob> The other side scary one is unsafe within STM.  This is quite difficult to reason about even when it looks ok.
10:13:24 * fryguybob can't type today.
10:13:26 <dobq> fryguybob: yes, that part makes sense :)
10:13:55 <dobq> and imo really boils down to the core reason why there's no runIO :: IO a -> STM a
10:14:06 <fryguybob> There are almost no safe ways to use  unsafeRead from a TArray, for instance.
10:14:39 <fryguybob> dobq: That one is more straight forward in its danger :D
10:15:13 <exio4> dobq: there is one, do you really want it? ;)
10:15:26 <dobq> exio4: return.unsafePerfomIO doesn't count
10:15:35 <exio4> unsafeCoerce doesn't, either? :D 
10:16:23 <dolio> fryguybob: unsafeRead does more than skipping bounds checks?
10:16:36 <dobq> (what's unsafeRead? )
10:16:45 <dobq> (ah, in the MArray class)
10:17:02 <kassav> Hello, i'm starting a big project and i need an intelligence software part
10:17:20 <kassav> what do you think of haskell usage
10:17:48 <dobq> kassav: here's a piece of advice: start a small project instead. tackle the small bits, rather than everything at once
10:18:22 <kassav> of course yes
10:18:37 <kassav> the main part is related to AI
10:18:40 <fryguybob> dolio: No, but you are asserting that you know the bounds when you might know an inconsistent bounds due to a concurrent write.
10:19:00 <Cale> Geff22: ah, that's a more annoying kind of "not working" than I expected...
10:19:11 <kassav> and i have to choose python/prolog/haskell
10:19:49 <dobq> fryguybob: considering tehre are "almost no safe ways to use unsafeRead", Data.Array.MArray sure uses it a lot
10:19:59 <dobq> ;-)
10:20:08 <fryguybob> dobq: On TArray specificially only.
10:20:42 <dobq> fryguybob: getElems
10:20:44 <fryguybob> TArray really shouldn't be a think in its current form though.
10:21:03 <exio4> dobq: https://hackage.haskell.org/package/base-4.4.1.0/docs/GHC-Conc.html here is unsafeIOToSTM
10:21:05 <Cale> Geff22: but at least the entire library itself isn't that much code: https://hackage.haskell.org/package/libvorbis-0.1.0.1/docs/src/Codec-Audio-Vorbis-File.html
10:21:19 <dobq> http://hackage.haskell.org/package/array-0.5.1.0/docs/src/Data.Array.Base.html#MArray , search for "unsafeRead "
10:21:31 <Cale> Geff22: Perhaps you can have a look at what calls it's making through FFI and sort out what the newer versions of libvorbis expect.
10:22:05 <dobq> exio4: well that looks suspicious. but the list of dangers is finite.
10:22:10 <dobq> exio4: thanks
10:22:21 <exio4> is there any actual "use-case" for unsafeIOToSTM? 
10:22:45 <fryguybob> dobq: I will have to think about  getElems  but it might very well be unsafe on TArray.
10:23:05 <dobq> exio4: a use-case or a sane use-case?
10:23:17 <dobq> exio4: a quick google search yields https://github.com/aartamonau/lazyfoo/blob/master/16/yampa/Timer.hs for example
10:23:19 <dolio> fryguybob: Oh. Like you have a TVar (TArray ...), and separately a TVar Int that is related to the size of the TArray, and you got an inconsistent view of those?
10:23:40 <fryguybob> dolio: Yes
10:23:49 <exio4> dolio: sane :)
10:24:13 <dobq> exio4: this example just uses unsafeIOToSTM to do a foreign call
10:24:19 <fryguybob> dolio: The sad thing is consistency is the very reason for using STM, but also the place where you have to be careful about it (if you use unsafe).
10:24:19 <dobq> which i suppose could be safe because it doesn't touch haskell at all
10:24:49 <fryguybob> dolio: You can pick a different STM implementation that avoids the problem by shifting some costs.
10:25:50 <Cale> dobq: A reasonable way to look at it is that if you don't mind how frequently that foreign call is made, and you expect it to produce the same result every time, then it's probably fine.
10:25:59 <fryguybob> dobq: I think  getElems  is ok, it will always have a consistent bounds.
10:26:18 <dobq> Cale: well that's not quite sufficient if you read the warnings for unsafeIOToSTM
10:28:20 <exio4> Cale: '' if you could use unsafePerformIO on it "sanely" .. '' :P 
10:28:34 <Cale> exio4: pretty much
10:29:12 <Cale> Though yeah, there is an extra point there, that the code may be terminated in the middle of its execution
10:29:26 <Cale> So you need every prefix of the code to be okay to unsafePerformIO, pretty much :)
10:29:36 <Geff22> Cale: Okay, I'll try. But i am afraid that this task too complicated for me.
10:29:37 <dobq> exio4: well, and if it can be aborted at random points
10:29:38 <dobq> safely
10:29:54 <dobq> ah, exactly what Cale just said :)
10:30:32 <Cale> Geff22: Yeah, I don't know, you might just want to try getting things to work first with simple PCM encoded audio, and worry about compression later.
10:31:13 <Cale> Geff22: I believe that the SDL binding can decompress a bunch of formats too, but I don't know if it'll let you have access to the result in a way which would be useful to use with OpenAL
10:32:07 <Cale> The OpenAL binding itself looks pretty low-level, and it would be worth someone's time likely to build something a little nicer on top of it.
10:33:46 <fryguybob> dobq: There is a danger in the use of unsafeIOToSTM where you make a foreign call like that yampa example.  If you use the information from that call to decide to `retry` you might hang that thread.
10:34:23 <dobq> fryguybob: ah but in this case i don't think it does
10:34:31 <dobq> it's just a sneaky way to get some debug data out
10:34:38 <fryguybob> dobq: I don't think so, but it is hard to reason about these things...
10:34:45 <dobq> it probably doesn't even allocate anything on the C side
10:35:07 <fryguybob> And if you are not careful you can leak the ability to hang out of your library.
10:36:10 <fryguybob> For instance the use of writeTVar on line 90 is leaking that foreign data out.
10:40:05 <Geff22> Cale: I alredy tried load the a simple WAV via ALUT. It's work great. I have not tried SDL yet, because before I work only with GLFW.
10:48:56 <Denommus> how can I compress a file to 7zip in Haskell? Is there a package for that?
10:49:14 <Denommus> is 7zip lzma?
10:53:53 <dobq> Denommus: 7z is a file format
10:53:53 <dobq> it might be lzma, but needn't be
10:54:33 <cocreature> can I receive async exceptions while doing a readTChan inside of atomically? something is eating my UserInterrupt’s and I’m not sure what
10:58:29 <ReinH> cocreature: aren't atomically's masked?
10:58:45 <cocreature> ReinH: I don’t know, that’s why I’m asking :)
10:59:12 <ReinH> I think they have to be to preserve, you know, atomicity.
11:00:02 <cocreature> makes sense
11:02:37 <dobq> cocreature: so probably it's not your STM :)
11:05:11 <cocreature> dobq: wait why not? if I’m waiting in stm and exceptions are masked won’t they be blocked until it’s unmasked again?
11:05:32 <dobq> cocreature: yeah so if they're blocked, they can't be eating them, right?
11:06:16 <cocreature> dobq: I suppose eating wasn’t the right word, my program just doesn’t exit, that’s what I meant by "something eats them"
11:06:36 <dobq> cocreature: do you have any threads alive that can accept them?
11:07:06 <cocreature> afaik UserInterrupt always goes to the main thread and that one is blocked on an stm in this case
11:08:46 <dobq> cocreature: hm, but STM actions should usually be quick
11:09:07 <cocreature> dobq: well a readTChan can block quite some time no?
11:09:24 <dobq> cocreature: yeah true :)
11:09:36 <dobq> cocreature: is it reasonable to move your STM stuff to a different thread then?
11:09:51 <cocreature> yeah that’s what I’m planning to do
11:10:03 <ReinH> cocreature: this is one reason it's good to make your stm actions as short as possible :)
11:10:20 <cocreature> ReinH: yeah I suppose we really shouldn’t be using TChans in this case
11:13:44 <Cale> readTChan doesn't block though iirc
11:14:23 <Cale> yeah, no, it just retries if the TChan is empty
11:15:27 <Cale> The entire transaction is then run again from the beginning if the TChan gets written to by another thread.
11:15:56 <Cale> (or if anything else that was read on the way to the retry is written to)
11:20:40 <cocreature> it seems to be something else
11:25:04 * hackagebot luminance 0.9.1.1 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.9.1.1 (DimitriSabadie)
11:27:22 <cocreature> ah it might be the ghc api installing it’s own singal handlers
11:28:38 <cocreature> yep https://ghc.haskell.org/trac/ghc/ticket/4162
11:30:22 <lf94> When is Haskell getting better performance
11:31:32 <capisce> all the time
11:34:07 <Cale> lf94: Did you mean to ask something like "when are GHC-compiled Haskell programs getting better performance"? Or perhaps "when is GHC itself getting better performance"?
11:34:21 <lf94> Former
11:34:29 <lf94> But why not both? :)
11:34:45 <Amnez777> hello all, i am haskell enthusiast, any bulletproof debug free apps written in haskell?
11:34:52 <Cale> Well, certainly as the former happens, the latter happens as well because GHC is written in GHC Haskell.
11:35:06 * hackagebot git-annex 6.20160114 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20160114 (JoeyHess)
11:35:08 * hackagebot hashable 1.2.4.0 - A class for types that can be converted to a hash value  https://hackage.haskell.org/package/hashable-1.2.4.0 (JohanTibell)
11:35:40 <Cale> lf94: But yeah, almost every release of GHC makes some improvements to simplification and code generation.
11:35:46 <lf94> Cale: I was just reading a OCaml vs Haskell Quora thread last night and everyone was complaining about performance
11:36:07 <lf94> (I myself have been using Haskell for about a year and a half)
11:36:08 <Jello_Raptor> are haskell datatypes that correspond to "positive integers + 0" and "positive reals/Floats + 0" 
11:36:10 <Jello_Raptor> ? 
11:37:53 <sm> Amnez777: how do you mean ? many haskell apps are pretty solid
11:38:09 <Cale> Jello_Raptor: There are various libraries which provide natural number types, but I don't know about the latter.
11:38:10 <Amnez777> sm, examples of those apps please
11:38:10 <Jello_Raptor> it would be nice if I could just use the literals without extra cruft to boot. Such that "1.03 :: PositiveFloat" would typecheck and "-3.4 :: PositiveFloat" would not, but I can't see a nice way to do that without a language extension at some sort. 
11:38:51 <sm> ghc, darcs, pandoc, hledger, git-annex..
11:39:04 <Amnez777> sm, i dont know what are those, never used them 
11:39:18 <Cale> Jello_Raptor: Well, negation is defined by Num, so if you want a Num instance, you need to define it somehow.
11:39:26 <Cale> :t negate
11:39:27 <lambdabot> Num a => a -> a
11:39:47 <Cale> This function is applied whenever you use unary negation like that.
11:39:50 <Cale> :t fromRational
11:39:52 <lambdabot> Fractional a => Rational -> a
11:40:16 <Cale> is what gets used to translate from the expression 3.4 to whatever type of numbers you have
11:40:44 <Hijiri> Amnez777: not even ghc?
11:40:46 <Cale> (i.e. it will apply fromRational to the Rational number 34/10)
11:40:51 <Amnez777> nope
11:41:12 <sm> Amnez777: you can find more by searching for "program" at http://hackage.haskell.org/packages
11:41:15 <Hijiri> so haskell enthusiast doesn't necessarily mean you've run haskell code?
11:41:25 <Hijiri> or maybe you used a different compiler
11:41:45 <dmj> Amnez777: xmonad I hear is pretty solid
11:41:46 <Amnez777> Hijiri, i am inspired by one of my friends from irc, he keep sending me math stuff, so i decided to get familiar with haskell 
11:41:51 <lf94> Are there any small Haskell compilers someone could study?
11:42:10 <dmj> Amnez777: it's moreso the libraries that are rock solid
11:42:33 <Amnez777> dmj, what do you code on haskell mostly? what kind of applications/servers?
11:42:36 <wlad> Does anybody know a reason why Functors are not Monads?
11:42:52 <Ankhers> wlad: They can be.
11:43:04 <Ankhers> wlad: but not always.
11:43:09 <Cale> wlad: Every monad is a functor
11:43:17 <dmj> Amnez777: web servers right now and background workers for one-off things, my code base is ~10k lines. It's pretty solid
11:44:00 <rschnck> I feel super stupid, but I can't wrap my head around how to do this functionally: http://codepad.org/FCl3SlW2. I put pseudocode of what I'm trying to accompilsh along with the start of my coding attempt
11:44:11 <Amnez777> webservers? hmmmm first time i hear someome writing webservers
11:45:05 <dmj> Amnez777: well, sorry, I don't write the web server. The application I write uses a haskell web server (warp)
11:45:07 <wlad> Cale: I just feel that >>= and fmap are very similar and that liftM and fmap are essentially the same thing. I read somewhere that sometimes it *can* be that monad is not a functor
11:45:11 * hackagebot unordered-containers 0.2.6.0 - Efficient hashing-based container types  https://hackage.haskell.org/package/unordered-containers-0.2.6.0 (JohanTibell)
11:45:14 <capisce> webservers don't write themselves
11:45:17 <Cale> Amnez777: Yeah, there are a few big and well-supported Haskell web frameworks. Where I work, we use Snap to write our backends, and reflex-dom along with ghcjs to write our frontends.
11:45:18 <wlad> I mean in terms of typeclasses
11:45:42 <Cale> wlad: (>>=) can do things which fmap can't
11:46:10 <Amnez777> wow so many new terms for me lol
11:46:13 <wlad> :t (>>=)
11:46:14 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:46:17 <Cale> wlad: If you have some structure of type f (f a), there's no way to get from that to a structure of type f a using fmap alone -- it doesn't change the number of occurrences of f
11:46:41 <Ankhers> wlad: That cannot happen anymore. Functor is a superclass of Applicative, which is a superclass of Monad. Which means every Monad has to have an Applicative and Functor instance now.
11:46:41 <Cale> wlad: however if x :: m (m a), then x >>= id :: m a
11:47:36 <wlad> Cale: I think I understood that
11:47:39 <Cale> wlad: this also goes by the name of join
11:47:41 <Cale> :t join
11:47:42 <lambdabot> Monad m => m (m a) -> m a
11:47:43 <wlad> Ankhers: got it
11:48:42 <Cale> wlad: Similarly, if you have a functor f, there might not be a function of type a -> f a, as fmap certainly won't help you pull something of type f a from thin air
11:49:55 <Cale> wlad: If you have fmap, join and return, and those satisfy some corresponding laws, it turns out to be the same thing as defining (>>=) and return (and having those satisfy the appropriate laws)
11:50:49 <wlad> :t return
11:50:50 <lambdabot> Monad m => a -> m a
11:51:07 <Ankhers> > return 1 :: Maybe Int
11:51:09 <lambdabot>  Just 1
11:51:55 <gabbiel> is yesod installation also not working for you guys?
11:51:59 <shachaf> i,i or defining retract :: Monad m => Free m a -> m a
11:52:21 <Ankhers> gabbiel: What are you doing to install what error(s) are you getting?
11:52:32 <Cale> gabbiel: I suspect it's working for many people. How are you trying to install it? The by far most recommended way is to use stack
11:52:42 <gabbiel> I used stack
11:53:03 <Ankhers> gabbiel: What is the exact command you used, and what error(s) did you get?
11:53:30 <gabbiel> at first, it was giving me ghc version error so I used the flag for not checking it, but then during the 70 package, it just failed
11:53:44 <gabbiel> give me a sec
11:54:10 <gabbiel> exactly "stack install yesod-bin cabal-install  --skip-ghc-check"
11:54:51 <Cale> Why did you have to skip ghc check? What did it tell you before that?
11:55:41 <ushfnuk> Could anyone tell me which meaning of a word "warp" is used in a "package warp"? (I'm not native English speaker).
11:56:11 <gabbiel> just ran the command without --skip-ghc-check and it gave me this 
11:56:12 <gabbiel> Compiler version mismatched, found ghc-7.8.4 (x86_64), but expected minor version match with ghc-7.10.3 (x86_64) (based on resolver setting in /home/gabbiel/.stack/global-project/stack.yaml).
11:56:15 <sm> ushfnuk: it's the name of the package - http://hackage.haskell.org/package/warp
11:56:16 <gabbiel> Try running "stack setup" to install the correct GHC into /home/gabbiel/.stack/programs/x86_64-linux/
11:56:17 <Cale> ushfnuk: There is a package named "warp". Maybe that's what's being referred to?
11:56:35 <Cale> ushfnuk: that is, http://hackage.haskell.org/package/warp
11:57:05 <sm> gabbiel: do stack setup
11:57:10 <ushfnuk> I mean what does this name mean :)?
11:57:11 <gabbiel> doing it right now
11:58:00 <sm> ushfnuk: oh.. it means "bend", in science fiction it's used for "bending spacetime" to travel fast, so it also means "fast" :)
11:58:46 <gabbiel> now this
11:58:53 <gabbiel> ghc.mk:918: recipe for target 'install_packages' failed
11:58:53 <gabbiel> Makefile:24: recipe for target 'install' failed
11:58:53 <gabbiel> /home/gabbiel/.stack/programs/x86_64-linux/ghc-7.10.3/lib/ghc-7.10.3/bin/ghc-pkg: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory
11:58:57 <gabbiel> gmake[1]: *** [install_packages] Error 127
11:58:59 <gabbiel> gmake: *** [install] Error 2
11:59:22 <Cale> gabbiel: What linux distribution?
11:59:25 <gabbiel> gentoo
12:00:07 <gabbiel> ill actually try on my arch one, and see how it goes
12:00:13 <Ankhers> I think libtinfo is from ncurses.
12:00:18 <sm> gabbiel: interesting, it sounds like you need some terminfo lib first and should maybe report it on #haskell-stack
12:00:23 <raichoo> usr/local/lib/libtinfo.so.5 -> /usr/lib/libncursesw.so.6*
12:00:32 <raichoo> That should work
12:00:56 <raichoo> also set LD_LIBRARY_PATH to /usr/local
12:01:06 <raichoo> /usr/local/lib 
12:01:08 <raichoo> sorry ^^
12:01:43 <gabbiel> there's nothing in my local lib
12:02:41 <Cale> gabbiel: If you do   ls -l /usr/lib | grep libtinfo   what does it say?
12:02:49 <raichoo> create a link e.g. /usr/local/lib/libtinfo.so.5 to /usr/lib/libncursesw.so.6
12:03:18 <Cale> Yeah, it might say nothing, if the library is named something else for some reason
12:03:35 <gabbiel> cale: nothing
12:03:43 <ushfnuk> sm: Thanks a lot! There' re so many meanings of that word. I pazzled my brains to find the right answer. :)
12:03:46 <raichoo> If libtinfo is not there it's backed into libncursesw
12:04:05 <raichoo> That's what the link is for
12:04:32 <raichoo> also if you do sth like export LD_LIBRARY_PATH=/usr/local/lib ld.so will search for libtinfo in /usr/local/lib
12:05:21 <raichoo> well, additionally search. To be precise.
12:05:41 <sm> the internet says: "..the cleaner solution is probably to enable ncurses' "tinfo" USE flag, either globally or with "echo sys-libs/ncurses tinfo >> /etc/portage/package.use".."
12:05:56 <gabbiel> only libcurses I see is in url/local and its not libcursesw.so
12:06:08 <raichoo> I assume gabbiel is using ghc binaries from stack?
12:06:16 <shapr> Is there a Haskell library/binary that will me edit a wireshark packet capture (pcap) and fix up all the CRCs after editing?
12:06:29 <lingxiao> hey all
12:06:35 <lingxiao> has anyone used coq with sublime?
12:06:38 <ReinH> gabbiel: do you have sys-libs/ncurses with the tinfo USE flag?
12:06:56 <lingxiao> i see this:
12:06:57 <lingxiao> https://github.com/mkolosick/Sublime-Coq
12:07:06 <gabbiel> let me check
12:07:08 <lingxiao> i'm wondering if anyone has any experience with it
12:07:21 <Cale> lingxiao: I wouldn't bother trying.
12:07:30 <lingxiao> Cale so you think it won't work?
12:07:33 <raichoo> Ah, ok. I'm using Arch didn't know that gentoo had a useflag for that. That's handy.
12:07:47 <lingxiao> i'm not too good with emacs i'm afraid :(
12:07:53 <gabbiel> i didn't set any use flags for it, let me check the defaults
12:07:57 <Cale> lingxiao: I mean, it might work to some extent, but you *really* want the interactive stuff that coqide/proofgeneral provide
12:08:06 <lingxiao> oh boy haha
12:08:08 <Cale> lingxiao: Use coqide :)
12:08:13 <lingxiao> tried installing coqide and it was a mess
12:08:19 <Cale> oh, hmm
12:08:30 <rschnck> I want to use sortBy, but instead of (a -> a -> Ordering) -> [a] -> [a] I need (a -> a -> a -> Ordering) -> [a] -> [a], since the way I sort the list is by comparing each element to a "base" element and sorting on that.
12:08:31 <lingxiao> on mac os X 
12:08:44 <rschnck> Is there any other function I should consider? Or should I write my own sorting function?
12:08:56 <lingxiao> i folowed this: https://coq.inria.fr/cocorico/Installation%20of%20Coq%20on%20Mac
12:09:03 <lingxiao> Cale you have coqide i take it?
12:09:09 <Cale> yeah
12:09:23 <Cale> lingxiao: It's pretty much impossible to read coq proofs without having an interactive display of the context and goal
12:09:39 <Cale> (and watching how these change as you step through)
12:09:49 <Cale> and it's even harder to imagine trying to write them
12:10:08 <lingxiao> Cale uh ok i'll try againg with coqide then
12:10:15 <lingxiao> do you havea  mac X?
12:10:18 <Cale> no
12:10:35 <geekosaur> rschnck, where does this "base" element come from?
12:10:53 <Cale> https://coq.inria.fr/distrib/V8.4pl5/files/coqide-8.4pl5.dmg -- did you try this package?
12:11:05 <Cale> It's apparently for 10.9
12:11:59 <Cale> (but also, this discussion is probably better off in #coq -- there are likely people there who know more about this than me)
12:12:20 <lingxiao> ahh thanks for that channel
12:12:31 <rschnck> geekosaur: I'm trying to sort a list of points based on the angle they make with the first point in the list.
12:12:36 <lingxiao> didnt know there was one
12:13:51 <rschnck> geekosaur: So I imagined my sorting function as first computing the angle that a given point makes with the first point, and then comparing that to another such computation.
12:13:53 <rschnck> If that makes sense.
12:18:01 <ReinH> luite: ping
12:18:20 <shapr> I can't find any pcap editing tools in Haskell :-(
12:20:48 <johnw> shapr: http://hackage.haskell.org/packages/search?terms=pcap
12:21:56 <gabbiel> is the ncurses package from hackage working for any of you?
12:23:40 <ReinH> rschnck: write a helper that does: sortByAngle [] = []; sortByAngle [x] = [x]; sortByAngle (x:xs) = sortBy (compareAngle x) xs
12:24:02 <ReinH> oh, I mean x : sortBy (compareAngle x) xs
12:25:12 * hackagebot esqueleto 2.4.2 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-2.4.2 (FelipeLessa)
12:25:28 <ReinH> where compareAngle x is your a -> a -> a -> Ordering
12:25:47 <ReinH> er, compareAngle is that, and compareAngle x is then the a -> a -> Ordering that sortBy needs.
12:25:57 <t0by> hi, is there a more haskell like way to write the following? fun1' xs = foldr (\x -> if (even x) then (*(x-2)) else id) 1 xs
12:27:17 <t0by> pardon
12:27:21 <t0by> let me rephrase that
12:27:23 <Ankhers> t0by: You could "eta reduce". Which means you can remove the two instances of `xs' from your function. You can do this because `xs' is the very last thing in your function definition.
12:27:29 <t0by> is there a more haskell-like way to write fun1' xs = foldr (\x->(*(x-2))) 1 (filter even xs)
12:27:44 <dolio> ReinH: Second case is redundant. :)
12:27:44 <Ankhers> Not anymore.
12:27:47 <t0by> Ankhers, let me google eta reduce.
12:27:57 <t0by> (well, it's good to know)
12:27:59 <ReinH> dolio: ?
12:28:05 <ReinH> oh, it sure it
12:28:08 <ReinH> *is
12:28:18 <t0by> thing is, I bet there is a better way to write  (\x->(*(x-2))), isn't there?
12:28:33 <ReinH> @pl \x -> * (x - 2)
12:28:33 <lambdabot> (line 1, column 7):
12:28:33 <lambdabot> unexpected "*"
12:28:33 <lambdabot> expecting lambda abstraction or expression
12:28:39 <ReinH> @pl \x -> (* (x - 2))
12:28:39 <lambdabot> (*) . subtract 2
12:28:45 <t0by> what is this sorcery
12:28:52 <ReinH> but you still need to check for even
12:28:59 <t0by> whoah
12:29:02 <ReinH> What you have seems fine.
12:29:18 <t0by> this is awesome.
12:29:23 <t0by> thanks ReinH
12:29:51 <t0by> hate to be *that* guy, but is there an offline version of this script? could turn out useful when I'm on a plane and/or don't feel like spamming all of #haskell
12:29:58 <ReinH> or maybe just: \x y -> if even x then y * (x - 2) else y
12:30:13 <ReinH> Yes, stack install pointfree (or cabal)
12:30:25 <ReinH> and you can always /msg lambdabot to spam it in private
12:31:13 <t0by> thanks ReinH 
12:31:40 <ReinH> Or perhaps \x y -> y * if even x then x - 2 else 1
12:31:55 <ReinH> plenty of colors look good on this bikeshed
12:34:33 <Anon7k_> hey al
12:34:39 <Anon7k_> *all
12:35:05 <Anon7k_> Need help
12:35:07 <t0by> ReinH, after all aren't all programming languages since algol 60 attempts to build a better bikeshed? :)
12:35:11 <dmj> Anon7k_: yes
12:35:26 <Anon7k_> its in python
12:35:36 <t0by> Anon7k_, ##python? :)
12:35:40 <dmj> ^
12:36:02 <Anon7k_> was getting this error
12:36:06 <Anon7k_> twait
12:37:12 <Anon7k_> sorry cant find it but;
12:37:23 <ReinH> Anon7k_: this is not a python channel
12:37:30 <Anon7k_> it had something like traceback
12:37:36 <t0by> rly
12:37:45 <t0by> Anon7k_, you may want to join ##python
12:37:52 <t0by> Like this: /join ##python
12:38:03 <t0by> They actually know something about python over there
12:38:11 <Anon7k_> need to register...how...new to irc
12:38:22 <t0by> Anon7k_, just type /join ##python in your client
12:38:41 <Anon7k_> thanks
12:38:58 <t0by> I mean, you do it just like you got here, except you use ##python instead of #haskell. Notice the two "#"
12:39:14 <Anon7k_> btw is haskell a programming language
12:39:16 <Ankhers> That doesn't register you though. /msg nickserv help should give instructions on how to register.
12:39:22 <Ankhers> Anon7k_: yes.
12:39:27 <Anon7k_> yeah noticed:)
12:39:41 <Anon7k_> is it high level
12:39:44 <t0by> Anon7k_, actually just #python. I just learned that ##python (with two ##) is inactive these days
12:39:58 <Anon7k_> oh
12:40:04 <Ankhers> You can do both high and low level stuff in Haskell.
12:40:51 <Anon7k_> which one is easier python or haskell            
12:40:59 <Anon7k_> e.g hello world
12:41:03 <Ankhers> That depends on your definition of easier.
12:41:05 <gabbiel> haskell
12:41:56 <Anon7k_> python its    print('Hello world')      how is Haskell
12:42:01 <sk8dev> hi, can someone pls tell me how I can find all android related channels?
12:42:05 <dmj> > putStrLn "Hello world"
12:42:07 <lambdabot>  <IO ()>
12:42:45 <Anon7k_> Well not difficult like java
12:42:56 <Ankhers> sk8dev: /msg alis help
12:43:21 <gabbiel> i hate that I have to learn java for my cs degree
12:43:29 <t0by> Anon7k_, head over to wikipedia.
12:43:30 <sk8dev> Ankhers: thanks :)
12:43:48 <kaictl_work> Not sure if this is the right place, but here goes. So I've got a weird thing going on with my own install of lambdabot: mueval-core: GhcException "cannot satisfy -package lambdabot-trusted\n    (use -v for more information)"
12:43:56 <Anon7k_> then???????????????????
12:44:08 <maerwald> gabbiel: it usually confuses people new to programming and gives them tools they shouldn't be learning at that stage
12:44:32 <Anon7k_> <t0by> what on wiki
12:44:38 <t0by> Anon7k_, then read the "Python" and "Haskell" pages, as well as "Functional programming", "Lazy evaluation" and "Lambda calculus"
12:45:33 <dmj> Anon7k_: why do you want to learn to program? What's your end goal?
12:45:35 <t0by> gabbiel, why so. Java is a very interesting case study IMHO. Would you rather learn about ALGOL 60?
12:45:43 <Anon7k_> will do but might take some time,,, I am using Cyborg Hawk
12:45:47 <gabbiel> i seriously can't do anything else after learning haskell
12:45:56 <gabbiel> *do any other programming lang
12:46:17 <maerwald> well, for some things haskell can get rather boring if you are stuck to imperative style C bindings for example...
12:46:20 <suppi> gabbiel, you can do purescript ;)
12:46:28 <t0by> or prolog.
12:46:34 <Anon7k_> <dmj> My goal is to write programmes for now
12:46:35 <gabbiel> prolog?
12:46:35 <capisce> gabbiel: write Haskell programs to generate the Java
12:47:01 <dolio> Nah, prolog's no good. Lambda prolog is where it's at.
12:47:05 <Ankhers> capisce: Frege
12:47:19 <spuz_> Anon7k_, i highly recommend you start programming with python. Feel free to read about haskell but start programming in something else
12:47:26 <maerwald> prolog doesn't scale well... huge programs are utterly complicated... pretty much unlike haskell
12:47:43 <suppi> Anon7k_, I'd recommend Racket :)
12:47:48 <gabbiel> purescript?
12:48:35 <fr33domlover> scheme/racket is a great start but it needs a but of theory in parallel to learn about type systems imho
12:48:38 <t0by> I agree with spuz_. I find Python makes for a very nice and clean "toy" language.
12:48:40 <Shade_> hi, can someone clue on when to use data, type, and newtype? 
12:49:09 <dmj> spuz_: python is great, but it's difficult to refactor since there's no static types nor equational reasoning. Equational reasoning gives you the freedom to refactor. Code in dynamic languages are great to write stuff in quickly, but not to change / maintain things
12:49:22 <Shade_> for example, I want a data type that's essentially boolean, but I want the 2 constructors to be On | Off
12:49:35 <t0by> dmj, of course. But if you are learning to program do you really need to refactor giant clusters of code? :)
12:49:38 <suppi> fr33domlover, do things in your head a little, then watch the compiler do that for you :)
12:49:42 <fr33domlover> Shade_, you can define your own type for that actually
12:49:48 <ReinH> Shade_: then you should use data
12:50:22 <ReinH> Shade_: data is generally what you should use. newtype is useful specifically when you type has exactly one constructor. type does not introduce a new data declaration, it introduces a synonym for an existing type.
12:50:38 <dmj> Shade_: type is just a synonym, it has 0 runtime overhead, newtype gives you static checking and no runtime overhead, but you're limited to a single constructor. data is when you need multiple constructors and compile time checking, but there will be heap allocation
12:50:48 <ReinH> @google haskell wiki newtype
12:50:49 <lambdabot> https://wiki.haskell.org/Newtype
12:50:52 <ReinH> ^ for more info on newtypes
12:50:57 <geekosaur> newtype is specifically useful when working with typeclasses
12:51:02 <gabbiel> newtype is just to save some mem?
12:51:09 <t0by>  I'm confused-ish. In ex1 from www.seas.upenn.edu/~cis194/spring13/hw/04-higher-order.pdf, what exactly do you think I'm supposed to do with `iterate` and `takeWhile`? I can't see how they would help me in the second case. `iterate` looks nice, but it gives me an *infinite* list, not a fixpoint which I guess is what would come in handy.
12:51:11 <maerwald> don't use type, unless you have a complicated monad burrito, but even then it's debatable
12:51:23 <t0by> lol @ monad burrito
12:51:26 <gabbiel> ^
12:51:32 <dmj> I'd use newtype over type everyday
12:51:32 <maerwald> mh?
12:52:13 <fr33domlover> the problem with type is type safety, I used it all lot for IRC and then passed nicknames as channel names and vice versa... and no type errors
12:52:14 <dmj> t0bi: re:learning to code, that's why I asked him what his goal is
12:52:20 <fr33domlover> then I moved to newtypes
12:52:31 <gabbiel> i just wanna know how advanced u guys are? ex: what are some software you've done
12:52:53 <fr33domlover> gabbiel, you'll fine all kinds of people here
12:52:57 <fr33domlover> experts and beginners
12:52:59 <gabbiel> in haskell of course
12:53:05 <t0by> what is he, a tax officer?
12:53:08 <ReinH> And probably some non-guys as well.
12:53:22 <maerwald> I think sometimes people use "type" where they could just have proper function argument documentation
12:53:29 <gabbiel> gabbiel :: TaxOfficer
12:54:03 <Jello_Raptor> hmm, is it possible to specialize a monad tranformer so that it uses one implementation when it's wrapping a MonadIO and a different implementation otherwise? (simply because mutable references would be great for efficiency if available) 
12:54:11 <rschnck> ReinH: I see. Thanks for the help. :)
12:54:45 <fr33domlover> Jello_Raptor, there is a GHC extension for that, dunno if there are tricks to do this without extension
12:54:48 <maerwald> e.g.: type Point = (Double, Double) -- which I find horrible
12:55:15 <maerwald> unfortunately even popular libraries do that (see gloss)
12:55:25 <t0by> maerwald, what's wrong with Double, Double?
12:55:44 <maerwald> type Point = (Float, Float) ... type Vector = Point ... type Path = [Point] -- oh dear
12:55:53 <Jello_Raptor> fr33domlover: I think it needs ConstraintKinds and TypeFamilies, but i'm not clear exactly how to get that to happen.  
12:55:57 <fr33domlover> t0by, you can by mistake pass `type Dimensions = (Double, Double)`
12:56:03 <fr33domlover> and there will be no type errors
12:56:06 <maerwald> at some point you might pass in (Float, Float) describing something which is not a point... and the function will not complain 
12:56:39 <fr33domlover> Jello_Raptor, there is an extension for specialized instances
12:56:49 <fr33domlover> see the GHC manual
12:56:52 <t0by> maerwald, wait. I'm a total haskell newbie. Can you elaborate a bit? I believe there is a valuable lesson in there, but I'm not understanding it.
12:56:55 * fr33domlover goes there too to check
12:58:00 <fr33domlover> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html#ftn.idp46686526090608
12:58:03 <fr33domlover> Jello_Raptor, ^
12:58:27 <Jello_Raptor> oh huh, didn't know about that pragma
12:58:33 <mnoonan> t0by: think of something like type Dollars = Int, type UserID = Int, and a function addMoney :: UserID -> Dollars -> IO ()
12:58:49 <fr33domlover> Jello_Raptor, some libs use it to provide efficient specialized implementations :)
12:59:00 <fr33domlover> it's probably the reason it exists
12:59:01 <t0by> mnoonan, thinking ot it. What happens?
12:59:05 <mnoonan> so giving 10 dollars to user 20 looks like "addMoney 20 10"
12:59:19 <t0by> Oh okay, I see.
12:59:25 <t0by> It's confusing, isn't it.
12:59:32 <t0by> What would the sane way to do it be?
12:59:37 <mnoonan> easy to accidentally give 20 dollars to user 10 by writing addMoney 10 20, right?
13:00:06 <mnoonan> if you used newtypes instead, you would need something more explict like "addMoney (Dollars 20) (UserID 10)"
13:00:25 <mnoonan> and if you wrote "addMoney (UserID 20) (Dollars 10)" accidentally, it would fail to compile
13:00:28 <maerwald> t0by: if you have "data Vector = Vec { vx :: Double, vy :: Double }" vs "type Vector = (Double, Double)"... it's harder to screw up a function that takes the former, because you construct it explicitly via Vec... while Vector is just a synonym for _anything_ that is of type (Double, Double)
13:00:37 <t0by> mnoonan, very clear, thanks
13:00:40 <fr33domlover> mnoonan, unless you use "instance [..] Num" which defeats the point of the newtype :P
13:00:53 <fr33domlover> also a good point to note
13:01:08 <fr33domlover> I mean Instance Num [..] :P
13:01:17 <dolio> It doesn't necessarily defeat the point.
13:01:28 <dolio> Just the example.
13:01:28 <fr33domlover> dolio, well, it does partially
13:01:35 <fr33domlover> depends on the case
13:01:57 <t0by> speaking of sane ways, can anybody give me a tiny little hint re: Excercise 1.2 from http://www.seas.upenn.edu/~cis194/spring13/hw/04-higher-order.pdf? It asks me to rewrite a function in a cleaner style, but I can't understand where to start.
13:01:58 <maerwald> however, I sometimes use "type something = something" to make refactoring easier... e.g. if I play with GTK+ data types and might change them a lot... I'd have to go over a lot of files and search/replace stuff
13:02:05 <maerwald> a central type synonym can make that easier
13:02:08 <t0by> Were it a list, I would have some idea.
13:02:46 <exio4> maerwald: well, I wouldn't allow UserIDs to be created so easily :p
13:03:13 <t0by> I have
13:03:15 <t0by> fun2 1 = 0
13:03:15 <t0by> fun2 n | even n    = n + fun2 (n `div` 2)
13:03:15 <t0by>        | otherwise = fun2 (3 * n + 1)
13:03:28 <t0by> Any little hint to improve it?
13:03:47 <shachaf> Improve it by making fun2 1 = 4
13:03:57 <shachaf> Oh, this isn't that function.
13:04:02 <t0by> shachaf, I mean style-wise.
13:04:07 <dmj> is this collatz?
13:04:18 <t0by> dmj, it's cs194
13:04:29 * t0by is very confused
13:04:57 <dmj> t0by: https://en.wikipedia.org/wiki/Collatz_conjecture
13:05:04 <exio4> collatz :: Int -> [Int] ; collatz 1 = [1] ; collatz n | even n = n : collatz (n `div` 2) | otherwise = n : collatz (3 * n + 1)
13:05:12 <exio4> then I'd do sum . filter even . collatz
13:05:15 <t0by> oh, very much, then
13:05:23 <exio4> oh wait
13:05:27 <exio4> it's homework, ignore me
13:05:43 * hackagebot email-validate 2.2.0 - Validating an email address string against RFC 5322  https://hackage.haskell.org/package/email-validate-2.2.0 (GeorgePollard)
13:05:45 * hackagebot pipes-websockets 0.1.0.0 - WebSockets in the Pipes framework.  https://hackage.haskell.org/package/pipes-websockets-0.1.0.0 (NoonSilk)
13:06:11 <t0by> exio4, it's not actually homework for me, but I did ask for a hint and not a solution :)
13:06:30 <exio4> <_< I need a place to hide now
13:06:33 <t0by> exio4, luckily I managed not to read that yet. wanna try a hint? :)
13:07:35 <exio4> t0by: let's go with this, what's fun2 doing? 
13:07:48 <Anon7k_> bye bros
13:08:38 <BlackCap> Why does lambdabot have a brainfuck interpreter again?
13:09:02 <dolio> Because someone wrote it.
13:09:16 <t0by> exio4, well, things, apparently. I can't see anything "special" about it.
13:09:35 <t0by> (which checks out since people are apparently still trying to prove stuff about that functions)
13:09:39 <t0by> *function
13:09:55 <t0by> exio4, is there any special place I should direct my eye?
13:10:05 <tekkkz> hello! im trying to make a function working from inside c code. i did this some time ago - worked. now, at this time, it wont work (ofc im trying an otherfunction now). Have a look: https://bpaste.net/show/26605e90b12b errors at compiling with: https://bpaste.net/show/fe48e6562a4e
13:10:11 <tekkkz> any ideas how to fix that?
13:10:13 <exio4> t0by: if you had to explain what your current function is doing (btw, it's not exactly collatz, it's doing some extra things with the sequence!)
13:11:03 <BlackCap> @bf +[]
13:11:08 <lambdabot>  Done.
13:11:11 <BlackCap> clever.
13:11:38 <t0by> exio4, it's summing even n's to f(n/2), which means f(3*n+1) if n is not even.
13:12:03 <t0by> exio4, the output must be always even.
13:13:11 <exio4> t0by: I mean at a higher level, given a number N, you have some sequence there, right?
13:13:22 <t0by> exio4, absolutely.
13:13:27 <t0by> and they are always even.
13:13:49 <maerwald> the function is fine (style-wise)
13:13:53 <maerwald> not really much to do there
13:14:10 <maerwald> only nitpicking...
13:14:27 <exio4> you're actually right :P 
13:15:11 <t0by> exio4, hum.
13:15:19 <exio4> t0by: I don't really know how to explain this without giving out the function in english instead of code, I'll let someone else here or in #haskell-beginners to help you, sorry :( 
13:15:25 <t0by> exio4, wait, wait.
13:15:39 <exio4> alright, you were warned! 
13:16:11 <t0by> no, sorry.
13:16:27 <t0by> I'll head over to haskell-beginners and troll that channel as well
13:20:14 <maerwald> hope the "troll" part was a joke :P
13:21:59 <crossroads1112> I am trying to define a simple function that takes two arguments and returns the first argument, adding one. I tried to do (+1) . const but  I get an error that there is a "Non type-variable argument in the constraing : Num (b->a)" What does this mean and what can I do do solve this?
13:23:13 <mnoonan> crossroads1112: you almost had it, but you want const . (+1)
13:23:57 <mnoonan> :t const
13:23:58 <lambdabot> a -> b -> a
13:24:00 <mnoonan> :t (+1)
13:24:02 <lambdabot> Num a => a -> a
13:24:28 <mnoonan> think of const  as :: a -> (b -> a) and you can see why they only fit together in one way
13:25:20 <crossroads1112> mnoonan, ah yes that works. Why exactly is this?
13:26:03 <sphinxo> How would you store something that for example given 16 returns AX, BX, CX and so on?
13:26:20 <sphinxo> and say given 64 would return RAX, RBX etc
13:26:32 <mnoonan> you read the composition right-to-left, so const . (+1) means "take my input, add one to it, then create a function that ignores the next input and gives this value back"
13:27:34 <crossroads1112> Ah okay, I was thinking "I want to take the output of const and feed it into (+1)", but that makes more sense
13:28:35 <crossroads1112> sphinxo: What do you mean by "store"
13:32:11 <sphinxo> crossroads1112: Some kind of mapping?
13:32:13 <jle_> crossroads1112: might be easier to write it as: foo x y = x + 1
13:32:28 <t0by> @pl \n ->  (3 * n + 1)
13:32:28 <lambdabot> (1 +) . (3 *)
13:32:53 <BlackCap> @let f 16 = map (:"X") ['A'..'Z']
13:32:55 <lambdabot>  Defined.
13:32:58 <BlackCap> > f 16
13:33:00 <lambdabot>      Ambiguous occurrence ‘f’
13:33:00 <lambdabot>      It could refer to either ‘L.f’,
13:33:00 <lambdabot>                               defined at /tmp/mueval2694553061703964683.hs:150:1
13:33:17 <BlackCap> sphinxo: Like that?
13:33:36 <BlackCap> > map (:"X") ['A'..'Z']
13:33:38 <lambdabot>  ["AX","BX","CX","DX","EX","FX","GX","HX","IX","JX","KX","LX","MX","NX","OX",...
13:34:21 <sphinxo> I want to link register sizes to registers
13:34:25 <crossroads1112> sphinxo: It kind of depends on what you plan on doing with them. Obviously, you are trying to represent registers, maybe you could define an enum?
13:34:37 <jle_> sphinxo: foo 16 = map (:"X") ['A'..'Z']; foo 64 = blah?
13:34:40 <sphinxo> I have an enum like B64 | B32 | B16 | BH8 | BL8
13:34:55 <sphinxo> and then another enum containing RAX | EAX  | AX | AH |  AL ..etc
13:36:58 <sphinxo> Any ideas?
13:37:10 <crossroads1112> sphinxo, Yeah give me a second
13:38:05 <dredozubov> you can probably express it with GADTs
13:38:19 <sphinxo> dredozubov: How?
13:39:47 <dredozubov> i don't quite get what you're trying to do
13:39:56 <dredozubov> i may be even easier that than
13:40:00 <dredozubov> it may*
13:40:28 <sphinxo> hmm ok
13:40:40 <dredozubov> it seems like a [(A,B)] mapping
13:40:48 <dredozubov> from what you're saying
13:41:02 <dmj> type instance ToRegisterSize EAX B64
13:41:11 <sphinxo> wouldn't it be more [(A,[B])} ?
13:41:20 <dredozubov> yeah, you're right
13:42:02 <dredozubov> but you can imagine that type B = [C]
13:42:43 <dredozubov> dmj: isn't B64 dictates the size by itself?
13:44:36 <dredozubov> sphinxo: http://www.stephendiehl.com/posts/monads_machine_code.html to get your creative juices going
13:44:59 <sphinxo> ooh
13:48:14 <BlackCap> There's also this: http://wall.org/~lewis/2013/10/15/asm-monad.html
13:57:08 <sphinxo> I'm getting the error 'Not in scope: ‘lift’'?
13:58:41 <sphinxo> well i'm an idiot, dw
14:01:28 * hackagebot pipes-websockets 0.1.0.0 - WebSockets in the Pipes framework.  https://hackage.haskell.org/package/pipes-websockets-0.1.0.0 (NoonSilk)
14:01:28 * hackagebot exp-extended 0.1.1 - floating point with extended exponent range  https://hackage.haskell.org/package/exp-extended-0.1.1 (ClaudeHeilandAllen)
14:03:52 <sphinxo> How can I go from integer to Word8?
14:04:27 <sphinxo> or something like bytes :: Integral a => a -> [Word8]
14:04:28 <ReinH> fromIntegral
14:04:32 <coeus> fromIntegral
14:04:43 <johnw> fromIntegral
14:04:58 <dmj> fromIntegral
14:05:00 <dmj> :t (fromIntegral (2 :: Integer) :: Word8)
14:05:01 <lambdabot> Word8
14:05:11 <sphinxo> Great thanks
14:05:16 <coeus> do it multiple times, 4x on 32bit systems.
14:05:18 <ReinH> Just want to point out that the function you asked for is called fromIntegral
14:05:29 <ReinH> coeus: o_O what?
14:05:40 <coeus> (joke)
14:05:57 <crossroads1112> what is the purpose of "id" in the following list-reversing fold? foldr (\x f e -> f (x :  e)) id [1,2,3] []
14:05:57 <sphinxo> What's it called again?
14:06:51 <ReinH> crossroads1112: it's the function to apply to the empty list
14:07:41 <sphinxo> I want to return [Word8] not Word8
14:07:50 <ReinH> @google foldl as foldr
14:07:51 <lambdabot> https://wiki.haskell.org/Foldl_as_foldr
14:07:54 <ReinH> crossroads1112: ^
14:07:58 <sphinxo> And some numbers won't fit in Word8?
14:08:17 <crossroads1112> ReinH, thank you very much
14:08:25 <ReinH> sphinxo: well, we answered the question you asked and then you asked a different question
14:08:34 <coeus> sphinxo, you want to serialize that? in that case you might want to use a lib like cereal.
14:09:00 <sphinxo> no, i'm trying to encode immediate values
14:09:15 <ReinH> sphinxo: what specifically are you trying to do?
14:09:33 <sphinxo> Given an integer return [Word8] equivelent
14:10:12 <sphinxo> So it would spill over into second element of list if needed
14:12:23 <ReinH> @hackage digits
14:12:23 <lambdabot> http://hackage.haskell.org/package/digits
14:12:26 <ReinH> sphinxo: ^
14:13:32 <ReinH> then you need to decide on an endianness
14:13:52 <sphinxo> I don't think that does what I need
14:14:51 <coeus> unpack . toLazyByteString . int64BE :: Int64 -> [Word8] -- https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Builder.html#v:int64BE
14:15:37 <sphinxo> Thank you !
14:17:10 <sphinxo> I probably want the little endien equivalent 
14:18:35 <ReinH> sphinxo: why not?
14:18:47 <ReinH> it does what you asked for, modulo an fmap fromIntegral
14:19:10 <ReinH> round-tripping through ByteString is a lot more complicated than divmod.
14:19:45 <sphinxo> How would I do it using divmod?
14:19:58 <ReinH> the way that that package I linked does
14:20:03 <sphinxo> ahh ok
14:20:18 <ReinH> or quoteRem, rather, w/e
14:21:34 <coeus> be aware that there exist serialization libs that can handle Int, [], Maybe etc. too -- but they fail(ed) in compatibility between 32bit and 64bit systems.
14:22:50 <zachk> can't you force your Int's to Int32 all around? 
14:24:12 <coeus> zachk, are you asking me?
14:25:04 <zachk> just specify Int32 or manually coerce Int -> Int32 and you should be fine with serialization 
14:25:30 <coeus> serialization of [] begins with an Int that encodes the length.
14:25:58 <coeus> the instance was already in that lib i used. but that was >2 years ago.
14:26:59 <coeus> not beeing able to define own serialization strategies sucks.
14:27:37 <ReinH> > let go 0 = Nothing; go n = Just (swap (quotRem n 256)) in reverse (unfoldr go 256)
14:27:38 <lambdabot>  [1,0]
14:27:41 <sleblanc> What is a convenient way to combine two vectors? (assuming they are of the same length) I would like to return a vector that includes the greatest value of the two elements
14:28:11 <ReinH> sleblanc: I believe Vector provides a zipWith
14:28:23 <sleblanc> ReinH, perfect!
14:28:50 <coeus> gaah... now it is obvious to me how to customize serialization using a simple (newtype Foo a = Foo a) to wrap everything.
14:31:07 <zachk> you can make your instances of get from Binary, and I forget the other function, which serialization lib do you use? 
14:31:12 <SiGe> Hey guys, have you guys faced a case where a conscious use of category theory, e.g., use of monoids, monads, etc. led to a better design in your program?  By conscious I mean that you looked at your problem and have that gotcha moment that "Aha! a monad is what I need here"
14:31:27 <ReinH> SiGe: yes, all the time
14:31:32 <johnw> SiGe: edwardk has especially had that experience
14:31:33 <sleblanc> SiGe, yes
14:31:55 <johnw> and Tekmo has written an article about it
14:32:46 <SiGe> Care to share a few examples?  my experience is mostly with imperative languages, and to me, terms like Monad/Monoid, etc. look like design patterns such as Factory, etc.  Is this a correct mapping?
14:32:51 <fr33domlover> SiGe, i think once you know the concepts they are just tools like in any language
14:33:03 <fr33domlover> except in haskell they are very rich :)
14:33:03 <zachk> sort of, but not really 
14:33:06 <johnw> SiGe: http://www.haskellforall.com/2012/08/the-category-design-pattern.html
14:33:23 <SiGe> @johnw thanks for the link!
14:33:23 <lambdabot> Not enough privileges
14:34:03 <SiGe> @fr33domlover I am reading through this: http://bartoszmilewski.com/2014/12/05/categories-great-and-small/ where the guy is explaining monoids and the concept is so basic that I can't fathom how it can be useful while I am writing code.
14:34:03 <lambdabot> Unknown command, try @list
14:35:07 <zachk> have you ever had to do a lookup in a hash and it might fail with a null? and you have to chain those together with abunch of conditionals, and it's messy? 
14:35:14 <sleblanc> SiGe, think of the categories as a way to express things that a compiler can prove
14:35:54 <sleblanc> within the allowed semantics of your language
14:36:05 <coeus> SiGe, edwardk has especially that experience in syringes... that fly like arrows.
14:36:07 <SiGe> zachk: yes, I am thinking that's going to be a monad?
14:36:11 <zachk> in haskell you would use a Maybe a and it's a Functor that is also a Monad, and you can just chain the lookups using do notation, which looks like imperative code, and at the end you only need to check if the entire chain has suceeded or failed and there a function for doing that called maybe
14:36:15 <zachk> @src maybe 
14:36:15 <lambdabot> Source not found. :(
14:36:19 <zachk> :(
14:36:55 <SiGe> zachk: but that's not conscious use of a Monad, you just use it without thinking, right?  You didn't come up with a new Monad.
14:37:11 <sleblanc> For example, a Maybe monad rids you of the burden of checking for "null" references, a thing that C++/.NET/Java compilers can hardly verify at compile time without a doubt
14:37:23 <jle_> base features a particularly silly usage of CPP
14:37:25 <jle_> http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Control.Concurrent.Chan.html#Chan
14:37:49 <zachk> well that is a conscious use to a monad to me, a few years ago I used to pipe around and case match on the Just a and Nothing constructors, and I got really nasty spaghetti code from it 
14:38:23 <shanemikel> i'm having some trouble installing the requisites for this hello world glade example
14:38:57 <shanemikel> i haven't spent much time with cabal, but I think I have a sandbox properly setup
14:39:13 <shanemikel> is there a pastebin preferred here?
14:39:28 <SiGe> @sleblanc that makes a lot of sense to me: "think of the categories as a way to express things that a compiler can prove" so it's basically using known mathematical terms to help the compiler prove the correctness of the program? At least in the type sense?
14:39:28 <lambdabot> Unknown command, try @list
14:39:58 <shanemikel> http://susepaste.org/10911203
14:40:18 <SiGe> zachk: That's a well known Monad, no?  The Maybe monad, I mean.  But have you ever needed to define your own monad specific to your problem?
14:41:04 <zachk> shanemikel lpaste.net 
14:41:19 <SiGe> Hmm, maybe rephrasing my question, does knowing category theory make you a better programmer? does it help you write cleaner code?
14:41:21 <zachk> not yet, usually it turns out to be a monad someone already has discovered! 
14:41:32 <shanemikel> is there a script to use lpaste from shell?
14:41:56 <zachk> you can start connecting haskell functions like legos and see familar patterns between disparate things 
14:41:57 <SiGe> @zachk right, that's how I feel, too.  There are a few well known monads and most problems can be solved through them, so what's the point of reading up on category theory.
14:41:58 <lambdabot> Unknown command, try @list
14:42:09 <glguy> SiGe: @ is for bot commands
14:42:15 <SiGe> Ow, crap.
14:42:25 <zachk> sige, then don't and just use the one's already invented 
14:42:45 <zachk> the hash in haskell would be Data.Map 
14:42:56 <SiGe> Thanks for the heads up, glguy.
14:43:16 <coeus> SiGe, there is that Control.Arrow lib, too.
14:43:19 <zachk> the list monad lets you easily brute force combinatorial problems if you use things like guard from Control.Monad 
14:43:19 <shanemikel> http://lpaste.net/2354473966128594944
14:43:27 <sleblanc> Day to day, you will usually end up writing class instances for your types
14:43:47 <zachk> if you want better search of infinite space and back tracking I think you need the Logic monad with some adapters 
14:44:12 <zachk> if you want pointer's into deeply nested data structures, cabal install lens and look into those 
14:44:38 <zachk> erlang/elixir style actors with message passing? cloud haskell 
14:45:30 <sleblanc> SiGe, monads are just a part of the brilliant features that languages like Haskell bring; there's algebraic types too
14:45:50 <zachk> and they just shove all that goodness in cloud haskell into a Process monad which works almost just like IO, you just have to liftIO the IO monad's into the Process Monad, and I just alias like this io = liftIO , then do like io $ putStrLn "lifted string output" 
14:46:39 <zachk> you can make your own datatypes and make them instances of various typeclasses, and with a few LANGUAGE pragmas at the top of your source for GHC you can autoderive some of those instances 
14:47:10 <zachk> IO is very special and magical though, check out fmap over IO for starters 
14:47:21 <zachk> @src (>=>) 
14:47:21 <lambdabot> Source not found. stty: unknown mode: doofus
14:47:28 * zachk frowns 
14:47:59 <exio4> @type \f g x -> f x >>= g
14:48:01 <lambdabot> Monad m => (r -> m a) -> (a -> m b) -> r -> m b
14:48:17 <zachk> if you use that operator for monad composition, it work's almost just like (.) and the return becomes the id (identity) function 
14:48:26 <coeus> SiGe, you should at least read up on cat theory until you understand that a Monad is a Monoid on EndoFunctors.
14:48:36 <SiGe> sleblanc: do you have any suggestions on where can I read up on the theory of these stuff?  I am mostly interested in learning how to think in a functional manner, and be able to defend my reasoning on why I chose to go a specific path when writing the code.
14:48:37 <zachk> which to me, makes the monad law's easier to understand, in how a monad is a monoid 
14:49:13 <zachk> are you use to mapping anonymous functions over lists? and how about not mutating state to make a working program? 
14:49:27 <coeus> use google... or i could just write a small introduction....
14:49:35 <zachk> or use lambdabot 
14:50:10 <zachk> > fmap (\(x,y)->x+y) [(1,2),(3,4),(5,6)] 
14:50:12 <lambdabot>  [3,7,11]
14:50:19 <zachk> there is also #haskell-beginners 
14:50:25 <coeus> imagine a white board with named small circles as Sets and named arrows between them as Functions.
14:50:31 <zachk> but this channel is also a great place for beginners 
14:51:01 <zachk> shouldn't the Sets be Types ? 
14:51:01 <coeus> the small circles are called Objects and the arrows Arrows.
14:51:23 <sleblanc> Sige, it's kind of a hard read at first, but Steve Awodey's Category Theory is a good read
14:51:28 <coeus> could be Types, like in haskell, but could be apples, too.
14:51:34 <zachk> look into folding on lists, and then make your own tree data type, and make it an instance of Functor, and make a fold for the tree 
14:51:42 <zachk> well agda use's Set 
14:51:49 <coeus> let's call them Objects because they could be anything.
14:51:53 <sleblanc> SiGe, you might get more insight at first, simply by loading the GHC REPL (ghci) and inspecting various types and values (:t)
14:52:03 <zachk> then you confuse the object oriented programmers! 
14:52:10 <SiGe> coeus: I see, ok.  So objects themselves can contain elements? like sets?
14:52:27 <monochrom> SiGe: Richard Bird's "Thinking Functionally with Haskell" teaches how to think functionally.
14:52:53 <shanemikel> Set is a specific kind of Object
14:52:55 <sleblanc> SiGe, basic syntax includes "data" and "class". Once you understand algebraic types, you'll understand various examples of class instances. Little by little
14:53:01 <coeus> could, depending on what category we are talking about. the category of HaskellTypes and HaskellFunctions or the Sets and Functions.
14:53:16 <SiGe> sleblanc, monochrom: thanks!  I'll take a look at those books!
14:54:17 <coeus> ...or states of an apple and the actions to transform them.
14:54:29 <zachk> if you want Set's of Set you have to move to a higher Set_1 from Set_0 or we call them kind's in haskell 
14:54:34 <coeus> or locations and routes.
14:54:47 <coeus> yep.
14:54:54 <SiGe> location == Object, routes == arrows?
14:55:01 <zachk> try to think of a set that contains all set's that do not contain themselves... does it contain itself? 
14:55:07 <coeus> yep.
14:55:14 <zachk> they are like graph's from graph theory, sort of 
14:55:19 <zachk> but usually simpler 
14:56:19 <coeus> objects= those named points on the white board, arrows= those arrows that go from object to object.
14:56:47 <coeus> it is called a cathegory iff you have an operator to combine the arrows.
14:57:00 <SiGe> @coeus makes sense.  So in a sense, we are not interested in the definition of the objects or arrows, but rather in the way they are connected.  Hmmm
14:57:04 <lambdabot>  Sequence not found.
14:57:08 <coeus> (that is an if with two f)
14:57:12 <zachk> you also need the associative law to hold and a right and left identity, iirc 
14:57:36 <coeus> exactly.
14:58:40 <coeus> now consider the Functor: it is a transformation from one category to another.
14:59:15 <coeus> that is: it maps each object to an object in the new category, and each arrow to an arrow in the new.
15:00:12 <shanemikel> anybody take a look at that paste?
15:00:14 <coeus> it is called a functor iff the arrows and objects keep their relative connections.
15:00:25 <shanemikel> http://lpaste.net/2354473966128594944
15:00:57 <coeus> it is still o.k. when multiple objects map to the same new object.
15:01:03 <SiGe> I see, ok, so um, the topologies look the same?  But isn't that also a category by itself?  with the arrow being the functor and the objects being the two categories?
15:01:22 <coeus> YES!! :)
15:01:57 <sleblanc> shanemikel, seems like SetupWrapper.hs in Glib imports two functions that clash
15:02:22 <sleblanc> shanemikel, unless you are willing to build from a fork, you can't really fix this yourself.
15:02:28 <coeus> a transformation from one functor to another is called a "natural transformation".
15:02:54 <shanemikel> yeah,  okay that's what I thought.. thanks
15:03:02 <shanemikel> off to file a bug, then
15:03:09 <shanemikel> or maybe I'll try the stack version
15:03:30 <sleblanc> shanemikel, that's a consequence of not importing modules as qualified, or not specifying a list of things you wish to include from the module; if one of the modules adds a function that clashes with another module, your module will not compile anymore
15:03:34 <coeus> "endo-" is the prefix for something that maps from one thing into itself, like "type EndoFunction a = a->a"
15:04:17 <SiGe> coeus: Ah, I see! so like the transformations of a rubic(k?) cube?
15:04:26 <sleblanc> shanemikel, you can possibly restrict the version of the package that provides Distribution.Simple.Utils to the most recent that does not have the "die" version
15:04:45 <sleblanc> it's a hackish workaround but if that version is not too old it might work ok for you
15:05:04 <coeus> now, there are endofunctors. the haskell type class "Functor" is an EndoFunctor, because it maps from arrows between haskell types  to arrows between a subset of haskell types.
15:06:24 * hackagebot haskell-updater 1.2.10 - Rebuild Haskell dependencies in Gentoo  https://hackage.haskell.org/package/haskell-updater-1.2.10 (SergeiTrofimovich)
15:06:35 <coeus> no.. or maybe. it is just called "natural transformation", which is a (functor on (the category of (categories and functors)))
15:07:05 <SiGe> I see.
15:08:25 <coeus> assuming you have a function f, and you can write y=f(x). assuming f is an endofunction, you can write
15:08:26 <SiGe> I can't think of an immediate example where a functor would be useful.  The definition should say how the objects are mapped and how the arrows are mapped, correct?
15:08:46 <coeus> y=f(f(f(x))) = (f . f . f)(x)
15:09:01 <codedmart> Can I use lts stack but have one or two packages from nightly/newer?
15:09:25 <coeus> do you know the Functor in haskell?
15:09:29 <coeus> fmap?
15:09:57 <shanemikel> okay, well It looks like the package providing that is the Cabal package..
15:10:05 <SiGe> coeus: unfortunately, no.  That's part of the definition of Monad, but I am familiar with haskell just enough to barely read it.  Haven't done any actual programming in it, yet.
15:10:28 <shanemikel> so I think it that isn't gonna work
15:10:29 <coeus> do you know data Maybe?
15:10:31 <sleblanc> shanemikel, yeah, scratch that, it seems that since the oldest version on hackage cabal has always exported a function named "die"
15:10:49 <SiGe> Yes.
15:11:17 <shanemikel> so, it took a function named "die" to tell me that glade is dead
15:11:18 <shanemikel> :)
15:11:46 <shanemikel> maybe I'm looking for something else.. is there another package that provides Graphics.UI.Gtk.Glade ?
15:11:52 <coeus> the type of fmap :: (Functor f) => (a->b) -> (f a -> f b)
15:11:56 <mgsloan> codedmart: Yeah, add the package versions as "extra-deps"
15:12:31 <coeus> where Maybe is a Functor, so...  fmap :: (a->b) -> (Maybe a->Maybe b)
15:13:11 <sleblanc> shanemikel, the gtk3 should provide this
15:14:02 <sleblanc> shanemikel, but it's in Graphics.UI.Gtk.Builder
15:14:04 <sleblanc> https://hackage.haskell.org/package/gtk3-0.14.2/docs/Graphics-UI-Gtk-Builder.html
15:14:14 <coeus> the part before the "=>" is some sort of implicit parameter (derived by the compiler) that contains the correct fmap function that will be used. (the instance of that class)
15:15:18 <SiGe> coeus: I see, but isn't this case just mapping the arrows?  a "function" from a -> b is mapped to a function from "Maybe a" -> "Maybe b", am I reading it correctly?  What about mapping the objects?
15:15:41 <shanemikel> okay, I see.. so I'm just using a really old tutorial
15:15:49 <coeus> so, you can read on all the given instances of the Functor class in ghci like this:  ":i Functor"
15:15:55 <shanemikel> thanks a bunch
15:16:14 <SiGe> Thanks.  That's very useful!
15:16:16 <coeus> SiGe, you are right.
15:16:18 <sleblanc> shanemikel, welcome!
15:16:28 <shanemikel> Hackage deprecation feature? +1
15:16:40 <coeus> the objects are the Types, not the values.
15:17:18 <maerwald> shanemikel: are you using the glade package?
15:17:31 <sleblanc> shanemikel, the glade package on hackage says to use gtk instead ;-) https://hackage.haskell.org/package/glade
15:17:37 <maerwald> exactly
15:17:52 <coeus> so, they match all types "a" and "b" in the left category, and they are mapped to "f a" and "f b" in the right category.
15:18:40 <sleblanc> Although I have no idea why there is a gtk and a gtk3 package; they look identical
15:19:03 <SiGe> I see.  Do we need another function to map the types?  I can't see an implicit way of doing it, i.e., going from type (a) to (f a)
15:19:48 <ReinH> SiGe: f maps objects to objects
15:19:53 <ReinH> :k Maybe
15:19:55 <lambdabot> * -> *
15:20:00 <ReinH> Maybe maps types to types
15:21:26 <ReinH> iow, f maps a to f a
15:21:42 <shanemikel> okay, so I'm pretty confused
15:21:52 <shanemikel> what's the difference between gtk and gtk2hs?
15:21:56 <coeus> SiGe, there is the tricky part where your usual view of functions can confuse you: fmap needs to map all types and all functions, not the values of types nor a few functions.
15:22:03 <coeus> the types are the objects.
15:22:11 <ReinH> fmap does not map types
15:22:16 <ReinH> the type constructor maps types
15:22:19 <ReinH> fmap maps functions
15:22:53 <zachk> gtk is a widget/gui library and cabal install gtk2hs-build-tools will give you the build tools for gtk 
15:23:07 <coeus> ReinH, i think you misunderstood something.
15:23:14 <zachk> for haskell at least, you still need the gtk-dev dependency libraries for your OS 
15:23:19 <ReinH> coeus: I'm just reading what you wrote.
15:23:26 <ReinH> "fmap needs to map all types"
15:23:28 <ReinH> fmap does not map types
15:23:47 <coeus> ReinH, you read out of context.
15:24:02 <ReinH> There is no context in which fmap maps types.
15:24:05 <sleblanc> shanemikel, I am not 100% confident, but I think gtk2hs is the project. A Haskell program that generates many bindings to Gtk. "gtk" (and gtk3) are Hackage modules generated with gtk2hs
15:25:15 <coeus> ReinH, that context is called category theory, or the context in the sense of the toppic of our current chat.
15:25:26 <shanemikel> okay, so unless I'm hacking on the bindings, I should only need the "gtk" or "gkt3" packages.. so gtk2hs is a metaprogramming project
15:25:34 <sleblanc> shanemikel, in your case you should ignore gtk2hs
15:25:39 <sleblanc> shanemikel, yup, exactly
15:25:42 <ReinH> coeus: I know what category theory is. It remains true that fmap does not map types
15:25:47 <ReinH> fmap does not operate on types at all
15:25:51 <ReinH> fmap operates on values
15:26:25 <sleblanc> shanemikel, it's also the name of their GitHub group: https://github.com/gtk2hs
15:26:47 <coeus> ReinH, read the type of fmap. that type does not operate on values but types in the sense of a functor.
15:27:21 <coeus> maybe i should say maps instead of operates?
15:27:41 <ReinH> I know what the type of fmap is.
15:27:51 <ReinH> fmap maps functions to functions, e.g., arrows to arrows.
15:28:05 <ReinH> It is the arrow mapping part of a functor, it is not also the object mapping part.
15:28:20 <ReinH> the object mapping is the type constructor f
15:28:25 <coeus> ReinH, if you do not understand what i'm talking about, then please do not assume that i'm wrong.
15:29:50 <coeus> that's what you did mean with type constructor...
15:30:11 <coeus> that's the part of the fmap i meant.
15:30:34 <shanemikel> well, that's disheartening.. one of my biggest motivations for learning haskell was my frustration that other languages don't seem to be expressive enough to obsolete the practice of metaprogramming
15:31:31 <SiGe> coeus: can you elaborate a bit on how fmap does "map all types and all functions, not the values of types nor a few functions" please?
15:31:55 <coeus> anyway, to me f is not a type constructor but a type variable that contains a type constructor.
15:31:55 <Zekka|Sigfig> shanemikel: What would you expect Haskell to do in this case?
15:32:01 <MarcelineVQ> shanemikel: Unless you're writing assembly for a specific processor, it's all metaprogramming :>
15:32:09 <zachk> @type fmap id
15:32:10 <lambdabot> Functor f => f b -> f b
15:32:17 <zachk> :-/ 
15:32:23 <shanemikel> I mean metaprogramming a language within itself
15:32:30 <ReinH> SiGe: your question is about how the Functor typeclass is a functor in the category theoretical sense, right?
15:32:44 <shanemikel> but maybe that's unfair, i've never written bindings, so I don't know what they look like
15:32:56 <shanemikel> may very well be the exception
15:33:08 <coeus> SiGe, fmap as a haskell function maps functions. in the type of fmap there is that little f, which maps from the type (a) to the type (f a).
15:33:43 <shanemikel> to elaborate further.. I mean specifically code generation (not the more flexible definition)
15:34:38 <SiGe> ReinH: coeus was helping me get a quick head start on category theory up until Monads and Endo-functors.  Maybe came up as an example of a functor.
15:35:51 <coeus> so, in that sense, you have all things you need to be defined for your Functor with a proper implementation of fmap.
15:36:26 <Zekka|Sigfig> shanemikel: Haskell doesn’t do anything *that* exciting to avoid code generation, although it can often infer how an operation should work using typeclass instances
15:36:59 <Zekka|Sigfig> (e.g. if you have a stack of monad transformers, each one says “if you already have the monad operations for everyone under me, here is how you get the monad operations for each one *including* me”)
15:37:15 <SiGe> coeus: Aaaaa! I think I get it now! (hopefully), so fmap is the arrow, f is the object transformer?  So everything is defined.
15:37:24 <coeus> and because you can write i.e. (fmap . fmap . fmap)(g::a->b)::[[[a]]]->[[[b]]] , fmap is actually an endo-functor.
15:37:35 <coeus> yes.
15:37:37 <ReinH> SiGe: yes, each instance of Functor is a type constructor, e.g., Maybe, that maps types to types
15:37:43 <zachk> all Monads in ghc are also Functor's 
15:37:44 <Zekka|Sigfig> Haskell doesn’t try very hard to enable stuff like introspecting over existing code to generate new code — there are constructions like free monads designed to enable that sort of thing, but they’re *not* part of the language, nor particularly Haskell-specific
15:38:23 <ReinH> SiGe: so Maybe is a functor from Hask to Hask where the object mapping is the Maybe type constructor itself and the arrow mapping is fmap.
15:38:43 <Zekka|Sigfig> shanemikel: Other than that Haskell provides compile-time ast-generation support similar to that in lisp, etc — except that Haskell’s ast representation is much more complicated to try to eliminate some obvious invalid ASTs
15:38:47 <Zekka|Sigfig> (it’s notj ust a list of lists)
15:38:57 <Zekka|Sigfig> Rather, *GHC* provides that. Haskell itself does not.
15:39:20 <zachk> wasn't the simple untyped lambda-calculus proved to be inconsistent and have an error in it? 
15:39:31 <SiGe> coeus: fmap is a (special) endo-functor because it maps anything to anything, i.e., I can compose it with itself as many times as possible, since it understands all objects and arrows.
15:39:39 <wswiss> is the rule declarations correct in this snippet: http://lpaste.net/149497 
15:39:53 <SiGe> ReinH: makes sense!
15:40:00 <ReinH> SiGe: no, fmap is a bunch of different functions
15:40:05 <ReinH> that happen to share the same name
15:40:15 <ReinH> each of those forms the arrow mapping for its respective type
15:41:01 <Zekka|Sigfig> shanemikel: Most of the time when you’re getting Haskell to infer what it needs to do to complete your program, you’re just giving it a stack of types where each is associated with a group of functions provided in a typeclass, after which Haskell slurps everything together and composes them
15:41:17 <coeus> yeah... i'd say it is an endo- because the right category is a subset of the left category.
15:41:19 <Zekka|Sigfig> a lot of the simpler cases of this are not too hard to just do at runtime in an untricky way in languages other than Haskell
15:41:48 <ReinH> No, it's endo because they are the same category.
15:42:26 <ReinH> If we want, we can define it as a mapping between Hask and a (full) subcategory of Hask defined as the image of Maybe. Under this definition, it is not an endofunctor.
15:42:27 <Zekka|Sigfig> shanemikel: I think most of the “you won’t have to write nearly as much code!” and “you won’t have to do anything ugly!” promises people make about Haskell are pretty inaccurate, especially when they’re talking about things-that-would-be-macroing-in-languages-other-than-Haskell
15:42:41 <coeus> ReinH, no, you confuse auto- with endo-. it is not the same category. [a] is the category of all haskell-list-types.
15:42:53 <ReinH> coeus: No, I do not.
15:43:07 <coeus> gaah
15:43:36 <zachk> the built in laziness get's rid of the need for alot of macros, that are required in other languages, cause they eagerly evaluate the arugments to functions
15:43:46 <wswiss> [a] is a subcategory of Hask for the type a
15:43:51 <ReinH> "subset of a category" is ill-posed. I assumed that you meant subcategory.
15:44:05 <ReinH> And a subcategory of C is not C
15:44:12 <Zekka|Sigfig> zachk: That’s true, but imho it doesn’t have a big effect on program structure — you’re effectively writing the same thing except calling it a function instead of a macro
15:44:16 <ReinH> so a functor from C to a subcategory of C is not an endofunctor.
15:44:29 <Zekka|Sigfig> or in other cases you’re writing the same thing except you don’t need a \()-> in the source code and a () -> in the type
15:44:47 <zachk> so what do you need a macro system for other then autogenerating things such as lens for records? 
15:45:22 <Zekka|Sigfig> zachk: You don’t think that’s a big enough case on its own?
15:46:03 <ReinH> When we say that Functor in Haskell is an endofunctor, it is because we mean that it is a mapping from Hask to *itself*.
15:46:22 <ReinH> Not to some subcategory of Hask, which is a different category.
15:46:29 <coeus> ReinH, do you try to be correct by all means? if you say subcategory, then you miss that subcategories are still not defined. this is a beginners course and fast introduction. "subset of category" is something one can understand without mathematical definition.
15:47:02 <ReinH> It is understandable, and incorrect.
15:47:06 <coeus> where "subset" is not to be interpreted in the mathematical sense. 
15:47:29 <coeus> i try to maximize the understandable part.
15:47:29 <ReinH> what
15:47:45 <ReinH> It is possible to be both understandable and correct.
15:48:01 <Zekka|Sigfig> I write a lot of Prolog, where I frequently map over “all the things of a certain kind” — in Prolog it’s irrelevant because there is no user-visible compilation step, but in Haskell it would probably be useful to know about all the things in that kind at compile time
15:48:09 <ReinH> There is no excuse for using mathematical terms incorrectly when trying to explain mathematics.
15:48:17 <ReinH> It would be better to not use them at all.
15:48:22 <coeus> yeah, well, i don't see anyone of us to be both.
15:48:33 <coeus> anyway...
15:48:36 <Zekka|Sigfig> To do this stuff in Haskell you either need to throw out type safety and use a runtime data structure to talk about things of that kind, or you need to split functionality between compile-time and runtime, then use language extensions to inspect the things defined at compile-time
15:48:53 <coeus> SiGe, back to cat theory.
15:48:59 <ReinH> You wouldn't say "If you add 2 and 3, you get blue. I of course don't mean 'add' in the mathematical sense."
15:49:52 <SiGe> coeus: I am listening.  ReinH: I won't fully understand the category theory in one go, using incorrect terms, just to add understandability helps a lot when someone doesn't have the rigorous mathematical background that you guys do :-)
15:50:03 <Zekka|Sigfig> Of course, tehre’s also the argument that you shouldn’t write programs like what I’m describing in Haskell (or at least you shouldn’t do it *that* way) and I’d agree (I don’t, usually)
15:50:23 <SiGe> ReinH: I'll mostly remember the high level terms, and then read through the book that you guys suggested earlier and fix the errors.
15:50:56 <coeus> do you know Monoids?
15:51:18 <SiGe> coeus: that was my initial question, that I do not understand how a concept so simple can be useful.
15:51:31 <coeus> lol
15:51:34 <coeus> ok...
15:52:11 <coeus> the (.) operator in haskell is a (partial) monoid.
15:52:24 <ReinH> And yes, if you are going to use mathematical terms to explain mathematical concepts, I will to the best of my ability insist that they are used correctly.
15:52:27 <coeus> it is a monoid on endofunctions.
15:52:34 <ReinH> I think it's irresponsible to do otherwise.
15:53:00 <wswiss> SiGe: having an operation associated with the type itself then allows you to carry the operation to constructs like the Writer monad (the output is monoidal)
15:53:00 <coeus> ReinH, i think that's ok with me.
15:53:22 <ReinH> And when I use terms incorrectly, I appreciate it when people correct me, as they often do in here.
15:53:37 <zachk> do I need gmake to build ghc? 
15:54:27 <coeus> wswiss, (this is about monoids of endofunctors)
15:54:29 <Zekka|Sigfig> coeus: My personal experience: when people have used terminology in a fuzzy way because it made sense to *them* when they used it that way, I’ve learned much less and been much more confused
15:54:54 <coeus> ok
15:56:21 <coeus> Zekka|Sigfig, to me fuzzy is ok iff i know it is fuzzy. (otherwise i switch personalities.)
15:56:29 <Zekka|Sigfig> Using terminology in a fuzzy way, to me, seems like it usually amounts to “the gap between my understanding and your understanding is hard enough to cross that I will only do it partway” — because before I as a learner can start understanding the concept I have to understand the analogy
15:56:30 <coeus> anyway.
15:57:55 <coeus> SiGe, if f is an endo-functor, then you can imagine an operator * that is the monoid on the f type.
15:57:58 <ReinH> It's weird to say that "(.) is ... a monoid." A monoid is an algebraic structure. (.) is one of the operations in such a structure, bit it is not by itself "a monoid".
15:58:32 <johnw> also, it's not (.), but (.) confined to functions who domain = codomain
15:58:34 <ReinH> * is not a monoid. {Int, 1, *} is a monoid. (.) is not a monoid. for all a, {a, id, (.)} is a monoid.
15:58:54 <ReinH> er
15:59:03 <zachk> a monoid is a triple consisting of: a 1. binary operator that is algerbraically closed over a 2. set and 3. neutral element (correct me if I am wrong) 
15:59:08 <johnw> {a->a,id,(.)} :)
15:59:12 <ReinH> rather: {a -> a, id, (.) :: (a -> a) -> (a -> a) -> a ->  a} is a monoid
15:59:35 <zachk> but what about...
15:59:41 <zachk> @type (.) 
15:59:42 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:59:53 <coeus> a monoid is a tuple of a set and an operator, in the case of (.) that set is that of endo-functions, and in the case of (*) it is that of type constructors (of kind *->*).
15:59:54 <ReinH> zachk: you must restrict (.) to operate only on a's.
16:00:08 <ReinH> A set and two operators.
16:00:13 <johnw> coeus: a set, an operator, and a unit
16:00:27 <zachk> so what is our (.) in Hask then? is it even a Cat? 
16:00:32 <ReinH> (unit is a nullary operator)
16:00:40 <ReinH> zachk: (.) is a category
16:00:46 <ReinH> when restricted to a single type, it is a monoid
16:00:52 <zachk> aren't categories monoids? 
16:00:57 <zachk> oh wait...
16:00:58 <ReinH> A monoid is exactly that: a single object category.
16:01:07 * zachk small light bulb goes on 
16:01:09 <zachk> ty :D 
16:01:13 <ReinH> I shouldn't make the same mistake
16:01:23 <ReinH> (.) is composition in a category
16:01:50 <coeus> the tuple is a monoid iff that operator is associative and has a neutral element in that set.
16:02:18 <ReinH> It's a 3-tuple, not a 2-tuple. You have to identify the neutral element.
16:03:46 <coeus> ReinH, not that i know of... it is given by law and it is unique. can you have two monoids that differ only by their neutral element?
16:04:12 <ReinH> coeus: Every definition of a monoid that I have ever seen is a triple.
16:04:58 <ReinH> It has to be identified because there is no other way to produce it for all monoids
16:05:26 <ReinH> You can't just say "and there is an identity element, go find it"
16:05:27 <SiGe> ReinH: but can't you prove that it is unique for a specific operator?  if so, the operator uniquely identifies the identity element (?) I can be wrong.
16:05:29 <ReinH> because you can't find it
16:05:33 <ReinH> generally speaking
16:05:36 <coeus> if there are two neutral elements... hm. it is the same structure but different perspective, so yes ok, triple it is.
16:05:45 <ReinH> no, there is only one neutral element
16:05:50 <coeus> thx.
16:05:55 <ReinH> but you can't figure out which one it is
16:05:57 <ReinH> so you have to mention it
16:06:41 <ReinH> SiGe: say you have two neutral elements, m and n, then you have m * n = n and m * n = m
16:07:15 <SiGe> ReinH: Right, that's exatly why it is unique (and what I wast thinking).  But I guess you have to specify it in case it does not exist.
16:07:23 <coeus> anyway, the function join is a monoid operator:  join::Monad m=> ((m * m) a) -> ((m) a) where * is pseudocode.
16:07:32 <ReinH> You have to specify it because otherwise there is no way to produce it from the information you have
16:09:06 <SiGe> coeus: I see.
16:09:19 <coeus> ReinH, if you have the operator * defined, and m and n are elements of the given set, and both are neutral elements... than both are the same.
16:09:52 <coeus> argh... you got me. there is no monoid with two neutral elements.
16:09:58 <SiGe> ReinH: Why does knowing which element is neutral matters?  It only matters if it exists or not.  What additional information would I have if I dont' know which element is identity but I know an identity element exists?  Asking from mathematical point of view.
16:10:06 <ReinH> coeus: Yes, that's what I just said.
16:10:36 <coeus> so, given the set and the operator, the neutral element is already unique.
16:10:37 <SiGe> I can always use the simple id or w/e to represent that element without losing information, correct?
16:10:59 <ReinH> To identify a monoid, you need to specify the set and its operations
16:11:24 <zachk> is the neutral element uniquely determinted by the set and the operator? 
16:11:29 <ReinH> Yes.
16:11:32 <Nadrieril> @pl \f g a b -> f (g b $ a)
16:11:32 <lambdabot> (. flip) . (.) . (.)
16:12:00 <coeus> which means that the minimal complete definition of a monoid is a 2-tuple, but only if you can derive the neutral element from that tuple.
16:12:11 * ReinH sighs
16:12:42 <ReinH> Read any textbook and they will define a monoid as a triple
16:12:56 <Zekka|Sigfig> What do you mean “derive it from that tuple”?
16:13:11 <ReinH> Zekka|Sigfig: presumably if it is computable or w/e, I don't know, but this is a silly argument
16:13:13 <Zekka|Sigfig> I don’t think there’s a systematic way to take + and Int and say — oh, I know! It’s 0
16:13:31 <coeus> i had a math prof who always used the minimal definitions. even when it became harder to understand.
16:13:56 <ReinH> That isn't a minimal definition. It's an incomplete definition.
16:14:53 <SiGe> I think the point of adding the identity element to the tuple is to "prove" that it exists.
16:15:05 <ReinH> Let's just give the usual definition as a triple that is used by literally everyone and move on
16:15:20 <coeus> SiGe, yes, i think so too.
16:15:42 <shachaf> I suggest taking the whole conversation out of #haskell.
16:15:47 <ReinH> That too.
16:15:48 <linman32> hi, what is a good haskell ide that uses stack?
16:16:15 <coeus> well, the conversation will be over in a few minutes anyway.
16:16:37 <shanemikel> thanks Zekka|Sigfig .. sorry I wasn't participating, I've gone an read all that stuff just now (I was requisitioning a sandwich)
16:16:51 <Zekka|Sigfig> shanemikel: Don’t worry about it!
16:17:11 <Zekka|Sigfig> Also, heads up — I’m a little opinionated. The rest of the channel is too but I’m opinionated in a different direction
16:17:46 <shanemikel> I think I've noticed that
16:18:30 <shachaf> I propose that it be over now.
16:18:41 <coeus> SiGe, if you combine those "f"s with the operator like (f^2 -> f^1), you need that neutral element to prove it is a monoid. (so, yeah triple.)
16:18:55 <SiGe> Sure, shachaf.  I can message you coeus, if you don't mind.
16:18:57 <shachaf> At the very least take it to #haskell-overflow, because it's been going on for way too long.
16:19:46 <coeus> ok, lets' do that.
16:20:10 <SiGe> Thanks to all the people that contributed, it's been very helpful for me, coeus, ReinH, Zekka|Sigfig, zachk, and anyone that I missed.
16:21:08 <shanemikel> And I'll be visiting the transcript later for my own digestion
16:24:07 <linman32> > map (liftA2 (*) (\t->t-1) (+1)) [1..10]
16:24:08 <lambdabot>  [0,3,8,15,24,35,48,63,80,99]
16:24:30 <dzdncnfzd> @pl \f g -> g f
16:24:31 <lambdabot> flip id
16:25:00 <dzdncnfzd> @pl . . . 
16:25:00 <lambdabot> (line 1, column 1):
16:25:00 <lambdabot> unexpected "."
16:25:00 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
16:25:12 <glguy> You can play with lambdabot in /msg
16:25:25 <dzdncnfzd> :) thanks for the tip
16:25:37 <zachk> you can also cabal install lambdabot :D 
16:25:58 <Zekka|Sigfig> Fair warning, if you want to compile lambdabot you will probably want a sandbox 
16:26:04 <Zekka|Sigfig> lambdabot has a lot of dependencies
16:28:28 <dzdncnfzd> If I want to install just an executable 
16:28:30 <shanemikel> linman32: uses stack how?
16:28:32 <dzdncnfzd> do I use cabal
16:28:36 <dzdncnfzd> or do I use stack
16:28:40 <dzdncnfzd> or does it not matter
16:28:45 <glguy> dzdncnfzd: both work
16:29:07 <zachk> sandboxes are for kids, real men and women break everything, and do --force-reinstalls!
16:29:11 <dzdncnfzd> glguy: how do I get the stack executable to be, well, globally evailable
16:29:16 <dzdncnfzd> *available
16:29:28 <zachk> stack is kinda auto-sandboxed by default, isn't it? 
16:29:29 <linman32> shanemikel: uses stack for the project.
16:29:53 <linman32> shanemikel: so a team of people could use stack even if one person is using an ide
16:30:00 <Zekka|Sigfig> zachk: I did that, actually
16:31:05 <Zekka|Sigfig> I learned a lot about how to configure Cabal by doing that!
16:31:19 <Zekka|Sigfig> For about a year I didn’t use sandboxes because you shouldn’t have to use sandboxes
16:32:21 <dzdncnfzd> given that every stack project is tied to an individual copy of ghci
16:32:32 <dzdncnfzd> how does one install a global executable
16:33:14 <linman32> shanemikel: does that make sense?
16:34:12 <shanemikel> dzdncnfzd: I don't think tied to ghci.. I think (could be wrong) stack gives the option of using global OR sandboxed versions of ghc
16:34:44 <shanemikel> not ghci.. in either case (even if I'm wrong).. the compiled executable wouldn't be dependent on the sandbox
16:35:22 <Zekka|Sigfig> Yeah, most Haskell executables are super duper statically linked
16:35:22 <dzdncnfzd> shanemikel: but shouldn't it be, given that it depends on a bunch of libraries compiled inside a particular sandbox?
16:35:24 <shanemikel> it'll probably just do something similar to cabal (putting the final exe in ~/.cabal/bin).. at which point you can move it any where you like that's on your path
16:35:49 <shanemikel> the sandbox is only to isolate deps for the compilation process
16:35:49 <ReinH> linman32: the closest thing to a haskell ide might be leksah
16:35:58 <shanemikel> afterwards, no necessito
16:36:02 <ReinH> I'm not sure where it's stack support is at
16:36:06 <ReinH> most people just use text editors
16:36:19 <ReinH> *its
16:36:33 <bergey`> dzdncnfzd: Are you asking how to make the program `stack` globally available, or a program built using stack?
16:36:43 <dzdncnfzd> build using
16:36:47 <dzdncnfzd> *built 
16:36:48 <shanemikel> the only thing that you might be concerned with, is linked libraries
16:36:53 <dzdncnfzd> yes
16:36:59 <Zekka|Sigfig> Does fpcomplete’s ide interoperate well with stack?
16:37:07 <dzdncnfzd> But I am concerned with those, because aren't there a lot of them?
16:37:09 <Zekka|Sigfig> I know at one point they were pitching an editor they wrote
16:37:16 <bergey> `stack install` will put the executable in ~/.local/bin
16:37:26 <dzdncnfzd> I tried to set up Stephen Diehl's haskell vim workflow
16:37:42 <dzdncnfzd> and I remember smoething totally failed due to using stack
16:37:49 <kadoban> Zekka|Sigfig: Wasn't it a web ide that they then discontinued once stack was created?
16:37:58 <dzdncnfzd> and there being no globally available ghc instance
16:37:59 <linman32> ReinH: thx :)
16:38:00 <Zekka|Sigfig> kadoban: I didn’t know they discontinued it!
16:38:01 <simony> Say I have a type that I'd like to write a Show instance for, but would like to have two different implementations I'd like to invoke in different situations. How does one go about achieving this in the right way?
16:38:24 <Zekka|Sigfig> simony: You could use a newtype to distinguish the two cases
16:38:38 <shanemikel> if there remains any problem with linked libraries if you move the resulting executable.. that can be remedied with LD_LIBRARY_PATH or whatever that env var is called
16:38:53 <Zekka|Sigfig> newtype Show1 = Show1 OtherType; instance Show1 OtherType where...; newtype Show2 = Show2 OtherType; instance Show2 OtherType where…
16:39:09 <exio4> kadoban: did they opensource whatever they had before?
16:39:23 <kadoban> I think so. I don't know much about it though.
16:39:28 <shanemikel> but I'm not quide sure how LDD paths are built
16:39:29 <exio4> Zekka|Sigfig: instance Show1 OtherType ? 
16:39:43 <exio4> Zekka|Sigfig: don't you mean instance Show Show1 or so?
16:39:44 <Zekka|Sigfig> exio4: Whoops! Show*
16:39:49 <Zekka|Sigfig> Er, Show Show1*
16:39:55 <Zekka|Sigfig> You are totally right. My name is mud.
16:41:13 <shanemikel> if you build something, and have problems after relocating the exe foobar, on *nix try `ldd foobar` and somebody here that knows more than I will help you sort it out.
16:42:48 <simony> Zekka|Sigfig: Ahh, cool thanks. So it'd still be SOP with OtherType, and just wrap it in the right Show# I want when showing needs to be done?
16:43:05 <shanemikel> does `stack install` build locally, or pull a pre-built binary?
16:43:29 <Zekka|Sigfig> simony: Yeah, you got it.
16:43:55 <Zekka|Sigfig> You could even define a different Show instance for just the bare type, so you have a default
16:44:24 <simony> Neat. Thanks! :)
16:44:47 <bergey> `stack install` builds locally.  It may download prebuilt copies of some dependencies, if possible.
16:45:25 <shanemikel> but not in the case of applications?
16:46:27 * hackagebot warp 3.2.2 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.2.2 (KazuYamamoto)
16:47:04 <bergey> Hmm.  I usually use it from a directory with source code.  I'm not sure if there are prebuilt executables for applications on Stackage.  Good question.
16:54:10 <sm> stack builds everything locally. It'll probably download binaries before too long
17:06:30 * hackagebot diagrams-lib 1.3.0.9 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.3.0.9 (bergey)
17:06:32 * hackagebot diagrams-core 1.3.0.5 - Core libraries for diagrams EDSL  https://hackage.haskell.org/package/diagrams-core-1.3.0.5 (bergey)
17:08:29 <shanemikel> dzdncnfzd: are you *trying* to end up with an executable that has all it's dependencies in it's build tree? if so, you're looking for something called a chroot which is a whole different story than a sandbox
17:09:29 <shanemikel> sandboxes are only about build dependencies
18:12:46 <mag__> Hello
18:13:10 <mag__> > head $ [(x*2, x**2) | x<-[1..]]
18:13:13 <lambdabot>  (2.0,1.0)
18:13:22 <mag__> why ?
18:13:35 <mag__> Why not (2, 1.0) ?
18:14:46 <yd> :t (*)
18:14:47 <lambdabot> Num a => a -> a -> a
18:14:54 <yd> :t (**)
18:14:55 <lambdabot> Floating a => a -> a -> a
18:15:24 <yd> :t (_*_)
18:15:26 <lambdabot>     Found hole ‘_’ with type: a
18:15:26 <lambdabot>     Where: ‘a’ is a rigid type variable bound by
18:15:26 <lambdabot>                the inferred type of it :: a at <interactive>:1:1
18:16:15 <mag__> .-.
18:17:08 <mag__> oh!
18:17:15 <mag__> uhm
18:21:47 <mag__> but why, why it gets promoted ? :( 
18:21:57 <mag__> :t head $ [(x*2, x**2) | x<-[1..]]
18:21:58 <lambdabot> (Enum t, Floating t) => (t, t)
18:23:02 <mag__> I was expecting:   (Enum a, Floating b) => (a, b)
18:23:55 <yd> :t [1..]
18:23:56 <lambdabot> (Enum t, Num t) => [t]
18:24:30 <geekosaur> haskell doesn't "promote"/. it infers a type for x based onwhat you did with it
18:24:39 <geekosaur> that type applies to x everywhere
18:25:25 <geekosaur> since (**) requires an instance of Floating, the type of x is fixed via defaulting to Double
18:25:58 <shanemikel> anybody using gtk know how to manually emit a signal?
18:26:20 <shanemikel> so I can use something like:
18:26:57 <shanemikel> myButton `on` buttonActivated {do emit myWindow deleteEvent}
18:27:02 <mag__> > :t [1, 2, 3, 4]
18:27:04 <lambdabot>  <hint>:1:1: parse error on input ‘:’
18:27:12 <mag__> :t [1, 2, 3, 4]
18:27:14 <lambdabot> Num t => [t]
18:27:27 <mag__> :t [1..20]
18:27:28 <lambdabot> (Enum t, Num t) => [t]
18:29:29 <mag__> Ok, thank you guys
18:29:32 <geekosaur> the other thing you may be missing is the monomorphism restriction. when you bound to "x", since "x" has no parameters it is forced to be monomorphic
18:29:54 <geekosaur> (always the same type, unlikea numeric literal whose type will be whatever Num instance is needed)
18:32:10 <mag__> one more question
18:32:19 <mag__> :t (..)
18:32:20 <lambdabot> parse error on input ‘..’
18:33:22 <geekosaur> hm ctually I don't think MMR is in play there
18:33:44 <mag__> :grin: never mind
18:33:52 <geekosaur> that is syntax, not an operator. [x..y] is a special form that turns into enumFromTo x y
18:34:03 <geekosaur> :t enumFromTo
18:34:05 <lambdabot> Enum a => a -> a -> [a]
18:34:52 <mag__> syntactic sugar?
18:34:56 <codedmart> Anyone using warp with http2? I have an example running and I tried curl --http2 but it seems it sends and Upgrade which fails then it just uses http1
18:34:58 <geekosaur> yes
18:35:22 <mag__> :) nice 
18:35:50 <geekosaur> specifically the forms [x..], [x..y], [x,y..z] (and only those forms; can't use .. in the middle of a list) are recognized
18:36:02 <geekosaur> oh and [x,y..]
18:36:21 <geekosaur> enumFrom, enumFromThen, enumFromTo, enumFromThenTo are the corresponding functions
18:38:16 <mag__> I see
18:40:00 <mag__> yd, you too, thanks
18:46:55 * hackagebot base-orphans 0.5.0 - Backwards-compatible orphan instances for base  https://hackage.haskell.org/package/base-orphans-0.5.0 (ryanglscott)
18:46:57 * hackagebot base-compat 0.9.0 - A compatibility layer for base  https://hackage.haskell.org/package/base-compat-0.9.0 (ryanglscott)
18:53:51 <codedmart> Anyone have an example of using Network.Wai.Middleware.RequestLogger writing to file?
18:56:55 * hackagebot ShellCheck 0.4.3 - Shell script analysis tool  https://hackage.haskell.org/package/ShellCheck-0.4.3 (vidarhol)
19:01:11 <shanemikel> is there an irc channel for gtk2hs?
19:01:19 <carter_cloud> Howdy all.  It's been a while !
19:01:22 <shanemikel> or gtk, or haskell gui in general?
19:06:09 <ReinH> shanemikel: not afaik
19:06:13 <ReinH> carter_cloud: hey stranger
19:06:35 <ReinH> shanemikel: people don't do a lot of gui work in haskell because haskell doesn't have good libraries for it
19:07:00 <ReinH> unless it's a web(kit) gui, in which case haskell is pretty good and getting better.
19:07:51 <shanemikel> if anything, that's an argument *for* having an irc channel, not against it
19:08:53 <shanemikel> is there a cabal cmd I have to run if I move a cabal sandbox?
19:11:53 <ReinH> shanemikel: I'm not making an argument for or against. :)
19:15:29 <geekosaur> shanemikel, I don't think there's a built in command for it
19:15:37 <ReinH> It's possible that there is an option you can put in the cabal.config file for your project, but really why move it in the first place?
19:15:47 <geekosaur> edit the paths in the sandbox's package database and run cabal sandbox hc-pkg recacge
19:15:51 <geekosaur> *recache
19:16:04 <geekosaur> it'd be nice if something did that first part though
19:16:54 <shanemikel> the paths.. like in the cabal.sandbox.config?
19:17:34 <shanemikel> also ReinH I'm not moving .cabal-sandbox relative to the sandbox's source tree, I'm moving the whole sandbox
19:17:55 <geekosaur> ,.cabal-sandbox/<platform>-packages.conf.d
19:18:16 <ReinH> Ok. Why are you doing that though?
19:18:21 <geekosaur> it's a directory with package files for each package installed in the sandbox. ghc uses full paths in the package db
19:18:27 <ReinH> monochrom: it looks like vex.net is down?
19:18:54 <geekosaur> so you have to fix the paths for the new sandbox location and then run that recache command to rebuild ghc's package cache
19:19:08 <ReinH> Seems much easier to just not move the sandbox.
19:19:09 <geekosaur> I imagine someting similar is needed for stack sandboxes unless they have a built-in "move"
19:19:22 <shanemikel> oh, wow.. that's inconvenient
19:19:31 <ReinH> shanemikel: *Why* do you want to move it in the first place?
19:19:33 <shanemikel> lot's of files here
19:19:36 <ReinH> This sounds like an XY Problem
19:20:20 <shanemikel> uh.. why shouldn't I be able to move it?
19:20:33 <geekosaur> (the reason ghc uses full paths is they can end up baked into a program or library if you use shared objects, and relative paths there would mean you could only run an executable from inside the sandbox, not from outside it)
19:20:35 <ReinH> I think you can move the sandbox, destroy your existing sandbox config, and then cabal sandbox init --sandbox /path/to/new/location
19:20:58 <geekosaur> except it explicitly leaves the package db unchanged (and with the old paths)
19:21:02 <ReinH> But really, unless you have a specific reason (like using a shared sandbox), you shouldn't care where it's located.
19:21:10 <ReinH> its location is meant to be an implementation detail
19:21:39 <sm> shanemikel: a haskell-gui channel is a great idea
19:22:24 <shanemikel> it's just a projects working directory.. in my homedir.. moving from ~/my-project-name to ~/my-new-project-name isn't a desired capability you can sympathize with ReinH?
19:22:46 <ReinH> shanemikel: Ah. I didn't know that that's what you were doing.
19:22:54 <ReinH> I thought you were just moving the sandbox for some reason
19:23:03 <ReinH> that's why I kept asking why
19:23:49 <ReinH> If you had said "I am moving the project's working directory and the sandbox dir appears to be hard coded", I would have said, "Oh ok that makes sense."
19:24:25 <shanemikel> yeah, that's why I said I wasn't moving relative paths inside the sandbox
19:24:37 <ReinH> shanemikel: Ok, well we're on the same page now.
19:24:47 <ReinH> I wonder if stack has this problem.
19:24:51 <Pryde> So, I'm looking to start learning Haskell. Can anyone point me to a really good online resource?
19:25:27 <shanemikel> geekosaur: I actually think the relative paths would be more desirable for the case of shared objects too
19:25:58 <geekosaur> only if you maintain their relationship to *your current directory*
19:26:12 <geekosaur> note, NOT the location of the program. the location of the directory you are in when you run the program
19:26:39 <shanemikel> oh, I see
19:27:34 <ReinH> Yes, stack also hard codes absolute paths, although the result is a rebuild rather than a misconfigured project.
19:28:14 <ReinH> (and that rebuild takes advantage of shared compilation of deps so it's relatively fast)
19:28:52 <sm> Pryde: https://www.haskell.org/documentation , http://haskellformac.com, http://haskellbook.com
19:29:08 <sm> http://tryhaskell.org
19:29:09 <ReinH> geekosaur: it seems like this should be solvable though, that paths can be calculated relative to the project root.
19:29:47 <shanemikel> https://github.com/bitemyapp/learnhaskell http://learnyouahaskell.com/
19:29:48 <geekosaur> not without some way to get ld.so to obey it
19:30:10 <geekosaur> OS X has a way to do that (@rpath), Linux / Solaris / *BSD ld.so doesn't
19:31:10 <shanemikel> great, another reason to be annoyed with linux
19:32:01 <adam__> Pryde I can second that the haskell book is a fantastic resource
19:32:30 <geekosaur> (and even then Solaris lets you use crle to create ld.so configuration for a program that can do that kind of thing)
19:32:50 <shanemikel> some of the authors preferred materials are listed in that github repo
19:33:01 <Pryde> Thanks everyone, I'll check those out!
19:33:03 <shanemikel> where he'd refer people before he started writing haskellbook
19:33:09 <shanemikel> and those I listed are freely available
19:33:42 <shanemikel> are you forgetting environment variables?
19:33:47 <shanemikel> LD_LIBRARY_PATH
19:34:25 <geekosaur> LD_LIBRARY_PATH is a blunt tool. you can make it do that but you can also break its ability to use shared objects from outside the package/sandbox
19:34:27 <shanemikel> besides, thats linker stuff, it's not as if my problem couldn't be remedied with some scripting.. or cabal maintaining the abs paths with a single var instead of littering them all around
19:35:19 <shanemikel> oh, you can't use that the same way as PATH?
19:35:22 <shanemikel> colon delimited list
19:35:31 <geekosaur> such breakage is less common than it is with OS X's equivalent, but it certainly happens and "get rid of any LD_LIBRARY_PA" is often one of the first tings someone is told when they get odd behavior from a program
19:35:34 <geekosaur> *LD_LIBRARY_PATH
19:36:16 <sm> Pryde: oh, https://www.schoolofhaskell.com
19:36:49 <shanemikel> so, how do we get @rpath in linux?
19:37:04 <shanemikel> who should I bug besides my local congressman
19:37:27 <shanemikel> and stallman
19:40:48 <shanemikel> that's it, I'm off to #gnu
19:41:00 * geekosaur wonders if he's going to keep losing hs connection to the bouncer every 5 minutes for the rest of the night :(
19:41:25 <geekosaur> ot sure #gnu is the right place, it'd be a linux specific thing
19:41:31 <geekosaur> it's ld-linux.so on linux, after all
19:41:35 <shanemikel> gcc
19:41:43 <geekosaur> glibc
19:41:57 * hackagebot TypeCompose 0.9.11 - Type composition classes & instances  https://hackage.haskell.org/package/TypeCompose-0.9.11 (ConalElliott)
19:41:58 <geekosaur> (probably)
19:42:22 <shanemikel> right, that's what the g stands for
19:42:54 <geekosaur> glibc itself is a gnu project but it needs custom OS stuff for linux, hurd, etc.
19:43:07 <geekosaur> which may be maintained separately
20:05:07 <Pryde> Is there a way to change the font size in the ghci?
20:07:52 <shanemikel> you need to change the font in your terminal itself
20:11:10 <Pryde> Oh, ok, thanks!
20:14:25 <lingxiao> hey all
20:14:33 <lingxiao> anyone familiar with coq can answer a couple of qeustions?
20:14:41 <lingxiao> no one seems to be overa t #coq
20:26:58 * hackagebot http2 1.4.2 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.4.2 (KazuYamamoto)
20:30:36 <Pamelloes> If I don't explicitly specify a compiler with -w, how does cabal determine which compiler to use?
20:31:01 <Pamelloes> Does it check an environment variable, or does it just use the first ghc on the path?
20:32:51 <geekosaur> the latter
20:33:18 <geekosaur> (while it is incomplete, you may be interested in https://github.com/geekosaur/ghc-wrapper)
20:34:02 <TerNit> :-D
20:34:41 <Pamelloes> Is there any way in a .cabal file or the like to specify which GHC to use so I don't need to specify everytime I configure?
20:36:12 <geekosaur> there is but I don;t recall it off the top of my head
20:36:56 <Pamelloes> Alright. I'll consult the cabal manual
20:38:18 <geekosaur> well I thought there was but am not seeing it. there's also a cabal sandbox setting (it's in stack.yaml for stack)
20:45:41 <acertain> does anyone know of performance comparisons between `data TermA = App Var [TermA] | ..` and `data TermB = App TermB TermB | Var Var`?
20:46:30 <acertain> and hash consing and explicit substitutions on each
20:46:43 <acertain> and what is TermA called?
20:49:11 <codedmart> Is unsafePerformIO dangerous?
20:49:18 <pikajude> it's unsafe
20:49:27 <pavonia> acertain: If you have to traverse the complete term, both shoud have the same complexity
20:49:48 <codedmart> pikajude Right but I see it used here: https://hackage.haskell.org/package/wai-extra-3.0.14/docs/src/Network-Wai-Middleware-RequestLogger.html#logStdout
20:50:21 <codedmart> Is there another way to get that from IO without unsafePerformIO?
20:50:27 <acertain> pavonia, sure, but often you need to get Apps in the form as shown in the first term, and you need to normalize more always if you use the first
20:50:42 <acertain> pavonia, usually you need to traverse more than once :)
20:50:57 <dramforever> codedmart: it could have been logStdout :: IO Middleware, you know
20:51:28 <acertain> and the second might do better with sharing, etc etc
20:52:15 <pavonia> acertain: Hhm, I don't see how several traversals or sharing would makea difference here
20:52:35 <codedmart> dramforever Right I get that.
20:52:50 <codedmart> I am just wondering if it is unsafe why use it?
20:52:57 <codedmart> What is the benefit in this code.
20:53:20 <dramforever> codedmart: a bit more convienent, I guess
20:53:38 <acertain> there are usecases (typechecking dependent types) where not sharing will blow up in memory usage
20:54:38 <codedmart> dramforever Yeah because when using middleware it expects Middleware not IO Middleware so how would you return just the Middleware without IO and not using unsafePerformIO?
20:56:37 <dramforever> codedmart: What about just have IO Middleware and get a logger as you initialize your app?
20:57:21 <dramforever> It seems that loggers need to do some stuff in IO for initialization, but I'm not really familiar with how wai works
20:57:54 <acertain> there's lots of stuff in Agda that takes lots of memory (Hier.agda takes ~30GB afaik)
20:57:57 <dramforever> codedmart: on the other hand, it seems that the library author is confident with the safety of the logger, so you could complain if it breaks, and it
20:58:05 <dramforever> it's not your fault ;P
20:59:03 <codedmart> Your right I can just initial in my app. That was kinda a dumb question :)
20:59:20 <vigs> Hey folks! Quick question (I hope) — how do I pattern match for a list with a single element? My gut says something along the lines of (x:[]), but that's not working.
20:59:49 <dramforever> vigs: that should works, if it's not working it's some other problem.
20:59:54 <vigs> (Aside: I literally pulled myself out of bed to write this function cleaner because it's been bugging me)
20:59:58 <dramforever> *should work
21:00:09 <vigs> dramforever: Ah. Well, that's good! Thanks!
21:00:15 <dramforever> [x] could be more readable, you know
21:00:17 <vigs> Well, it's kinda good.
21:00:23 <vigs> Ahh, I like that
21:20:50 <twopoint718> @pl \x y b -> if b then x else y
21:20:50 <lambdabot> flip . flip if'
21:22:14 <twopoint718> @ty if'
21:22:15 <lambdabot>     Not in scope: ‘if'’
21:22:15 <lambdabot>     Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
21:22:23 <jle_> twopoint718: that's bool y x
21:22:35 <jle_> also, you can use lambdabot in private message, too :)
21:22:43 <jle_> instead of always asking it on the main channel
21:22:52 <twopoint718> jle_: heh, thanks. I hadn't kicked the tires on it yet :)
21:23:24 <jle_> bool f t b = if b then t else f
21:23:44 <jle_> if' only exists in @pl, though you could define your own locally
21:24:15 <twopoint718> I know I've seen that in the HaskellWiki, I was just curious if there was some lib that defined it.
21:24:52 <twopoint718> But, 'bool' is new to me. I don't know how I've missed that all this time
21:25:05 <jle_> it's in Data.Bool :o
21:25:14 <jle_> it's relatively new, i think; it's only since ghc 7.8 ?
21:27:33 <twopoint718> `bool` makes sense as a kind of analog to the `maybe` function. 
21:30:20 <jle_> yeah, that's also the reason for the order :)
21:30:23 <jle_> also `either`
21:46:18 <twopoint718> jle_: yeah, I just noticed that `bool` was flipped from what I'd first guessed
21:57:01 * hackagebot sbv 5.10 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-5.10 (LeventErkok)
22:22:29 <nut> stack seems to store the packages on s3.amazonaws.com
22:22:49 <nut> I got the "FailedConnectionException "s3.amazonaws.com" 443
22:22:49 <nut> "
22:23:13 <nut> can I choose another of their server maybe ?
22:33:39 <Haris> hello all
22:33:43 <liste> hello
22:33:50 <Haris> on running stack install postgrest, I'm getting the msg --> postgresql-binary: needed (==0.5.*), 0.7.4.1 found (latest applicable is 0.5.2.1)
22:34:31 <Haris> this is centos 6 .. web for catarse .. catarse needs postgrest
22:34:38 <Axman6> Haris: keep read the error from stack, it tells you exactly what to add to your stack.yaml
22:34:40 <Haris> I ran stack setup yesterday evening
22:34:45 <Haris> hmm
22:34:57 <Haris> ok. I need to add something
22:35:21 <Axman6> there'll be a ling like "- postgresql-binary-0.7.4.1" which you need to add
22:35:33 <Haris> I don't have stack.yaml under catarse's dir hierarchy
22:35:59 <Axman6> add it to your project's stack.yaml
22:38:59 <Haris> that's the file I can't find. searching entire fs to find for existence of this file
22:39:18 <Haris> I have /root/.stack/global-project/stack.yaml
22:39:37 <liste> Haris the file should be in postgrest's directory
22:39:47 <Haris> ok. I have it under the linux user account, for my project, as well
22:40:01 <Haris> --> /home/donationpk/.stack/global-project/stack.yaml
22:40:46 <liste> that file is not used when inside a project directory
22:41:27 <Haris> my project is under /home/donationpk/public_html/
22:41:41 <Haris> and the above is the stack.yaml file I have under that linux user account
22:41:45 <Haris> that will work ?
22:43:09 <liste> I mean the postgrest project directory
22:43:59 <Haris> catarse's project dir is /home/donationpk/public_html/ . it needs postgrest. postgrest is not installed yet. Where would the stack.yaml be ? donationpk is the linux user account. /home/donationpk is its $HOME
22:44:17 <Haris> all of this is to install postgrest
22:44:31 <Haris> for catarse
22:45:01 <liste> Haris clone postgrest to a directory, (optional: switch to a release tag), cd into that directory, run stack install
22:45:15 <Haris> :o
22:46:01 <liste> OR just download the binary
22:46:05 <liste> there's one for centos to
22:46:08 <Haris> hmm
22:46:28 <Haris> after git clone; cd postgrest dir; stack install; I can remove the cloned dir ?
22:46:32 <liste> yes
22:46:39 <Haris> please mention the binary name/version
22:46:49 <liste> https://github.com/begriffs/postgrest/releases/tag/v0.3.0.3
22:46:59 <liste> there's binaries for other releases too
22:47:03 * hackagebot react-flux 1.0.3 - A binding to React based on the Flux application architecture for GHCJS  https://hackage.haskell.org/package/react-flux-1.0.3 (JohnLenz)
22:49:55 <Haris> http://pastebin.ca/3333119
22:50:24 <liste> run stack setup first
22:50:38 <Heather> what is good way to avoid The import of ‘Control.Applicative’ is redundantwarning if module doesn't import Prelude, should Prelude be imported anyways manually or is it better to guard it with CPP?
22:50:40 <liste> in that directory
22:51:09 <Haris> hmm
22:51:43 <liste> Heather are you targeting GHC 7.8 ?
22:51:43 <Haris> its going to download different version of ghc everytime a dep or the project changes ? lol
22:51:45 <Axman6> Heather: I just use CPP because it's easy
22:51:58 <Heather> liste both 7.8 and recent one
22:52:07 <liste> Heather https://ghc.haskell.org/trac/ghc/wiki/Migration/7.10 here's some more tips
22:52:19 <nocturne777> how do you guys achieve source code reload with Warp server ?
22:52:30 <nocturne777> do you simply use wai-handler-devel ?
22:52:52 <nocturne777> wai-handler-devel seems to be deprecated
22:53:10 <nocturne777> but since I am not using yesod, I do not want to install yesod-bin
22:53:13 <Haris> how do I install the file ( https://github.com/begriffs/postgrest/releases/download/v0.3.0.3/postgrest-0.3.0.3-centos.tar.xz ) ?
22:53:58 <Haris> I know of rpm installs. installs from source. not experienced with .xz files
22:54:09 <Heather> liste, Axman6 I think explicit Prelude import looks better 
22:54:46 <liste> Haris just copy the file inside to /usr/local/bin or somewhere
22:54:53 <liste> else in your path
22:55:24 <liste> and make sure the permissions are correct
23:02:03 * hackagebot dbus 0.10.12 - A client library for the D-Bus IPC system.  https://hackage.haskell.org/package/dbus-0.10.12 (JohnMillikin)
23:02:59 <Haris> downloaded postgrest-0.3.0.3-centos.tar.xz; moved to /usr/local/bin; chmod +x postgrest-0.3.0.3-centos.tar.xz . this should be good ?
23:04:54 <liste> Haris no, extract it first
23:06:12 <Haris> o i c. the file just provides one binary. lol
23:11:20 <kadoban> So am I correct that it's a bad idea to use [a] as the Monoid type in a Writer, if I'm going to have a bunch of log items? That's going to be using (++) in the bad way for performance, right?
23:14:20 <jle_> kadoban: Writer as it's implemented in transformers is fundamentally broken, so I wouldn't use it anyway; but using [a] makes even that a lot worse, heh
23:14:37 <kadoban> jle_: Uh oh … what's broken about it?
23:14:47 <jle_> use `Endo [a]` if you must
23:14:54 <jle_> it has efficient <>'s
23:15:20 <jle_> well, by that i mean, it has non-as-inefficient-<>'s-when-associated-badly
23:15:41 <kadoban> jle_: I appear to be using the mtl one … does that have similar issues?
23:15:48 <kadoban> Oh
23:15:58 <liste> mtl uses transformers under the hood
23:16:10 <kadoban> Oh right, thanks.
23:16:22 <jle_> mtl exports transformer's writer
23:16:46 <jle_> it's just a re-export heh
23:16:49 <jle_> kadoban: try this one http://hackage.haskell.org/package/stateWriter
23:17:47 <jle_> hm it doesn't have an actual 'writer' drop-in, but its types are instances of MonadWriter, so you should be able to keep your polymorphic functions
23:18:17 <kadoban> Hmm, thanks I'll see if I can use that. This is old code, I think it's written in a way I wouldn't anymore so it might be harder than it should be, heh.
23:18:43 <jle_> but yeah, the `dlist` package offers a nice interface over `Endo [a]` so you can use it like a list
23:18:45 <jle_> @hackage dlist
23:18:46 <lambdabot> http://hackage.haskell.org/package/dlist
23:19:02 <kadoban> Nice, thanks much.
23:19:29 <jle_> it offers fromList, toList, singleton, etc.
23:19:47 <Haris> app is up
23:19:50 <Haris> work done
23:19:57 <Haris> thank you all
23:19:58 <kadoban> Yeah that should be perfect. Even if I use stateWriter, I'd still want to use that, correct?
23:20:07 <jle_> congrats Haris !
23:20:22 <jle_> kadoban: i'm not sure, but if you're doing a lot of ++'s, i would just use it by default, heh
23:20:22 <haskman> hello all
23:20:28 <jle_> but that might be me cargo culting
23:20:37 <jle_> it's just very easy to accidentally associate ++'s the wrong direction
23:20:50 <kadoban> Makes sense to me
23:21:13 <jle_> it's actually how `show`'s mechanisms are implemented
23:21:25 <haskman> Given a (Typeable (a,b)) is there any way to derive Typeable a, and Typeable b?
23:25:16 <bollu> is there a relationship between Zipper and Store?
23:25:20 <bollu> They feel like the same object to me
23:25:30 <bollu> (have a "cursor", and a way to move the cursor)
23:27:33 <haskman> bollu, how do you move the cursor in a store?
23:28:26 <bollu> haskman: use duplicate :: Store s a -> Store s (Store s a) (you get this from the comonad structure on store), and then use peek on the duplicated store to give yourself a new positioned store
23:28:41 <bollu> where peek :: Store s a -> s -> a
23:28:59 <bollu> (so if a = Store s a, peek :: Store s (Store s a) -> s -> Store s a)
23:29:14 <bollu> (i.e, given a "store of stores", and an s, give me a store centered at s)
23:29:15 <jle_> alternatively, you can just use seek :p
23:29:34 <bollu> jle_: xD yeah I guess? but that's how seek is implemented right? :)
23:29:38 <haskman> ah interesting
23:29:41 <kadoban> Hmm, sweet. I should be able to use RSS. I'll have to change some code, but … looks like for the better.
23:30:03 <jle_> bollu: that's a default implementation for ComonadStore, but there's definitely a more efficient seek possible for `Store`
23:30:16 <bollu> jle_: ohh, I didn't know that. links?
23:30:20 <jle_> seek s' (Store s f) = Store s' f
23:30:52 <bollu> jle_: oh you're just replacing it >_< which is what my code does as well come to think of it
23:31:03 <bollu> jle_: I guess you can go from mine -> yours by equational reasoning right?
23:31:07 <jle_> mhm
23:31:32 <bollu> jle_: now I need to learn how to use "store" to memoize
23:31:43 <bollu> I'm planning to do a simple water simulation with diagrams + store for a CA
23:31:46 <bollu> just for funsies
23:31:57 <bollu> fluid* simulation
23:32:59 <bollu> jle_: does that sound reasonable?
23:33:42 <jle_> have you looked at edwardk's store for CA thing?
23:34:10 <jle_> i think in that tutorial, store doesn't actually memoize anything; a separate memoization library was used to add memoization abilities to the function(s)
23:35:29 <nocturne777> jle_: are you using warp ?
23:35:47 <jle_> some of my stuff uses it under the hood
23:35:52 <jle_> but i'm not a warp expert :o
23:36:05 <nocturne777> jle_: I want to move my project to servant
23:36:17 <jle_> congrats!
23:36:30 <nocturne777> but it appears I will have to give up auto-code reloading
23:36:50 <jle_> :(
23:37:17 <nocturne777> wai-devel-handler is deprecated
23:37:33 <nocturne777> I do not want to pull in yesod dependency on my entire project either
23:37:59 <jle_> yea don't do that
23:42:44 * hackagebot sbv 5.11 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-5.11 (LeventErkok)
