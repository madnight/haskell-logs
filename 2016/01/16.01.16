00:00:58 <geekosaur> or languages designed around their types being like Haskell's Maybe
00:02:55 <geekosaur> (Perl's undef, Icon's &fail, Swift's optionals)
00:03:45 <geekosaur> should probably mention SNOBOL as the progenitor of that style...
00:03:52 <hunteriam> (*>) =/= (>>)?
00:10:58 <diggle> Heh, haskell is fun. Whenever I learn something new my brain goes "analogy! analogy now!" and haskell is like..."nope."
00:15:21 <Cale> diggle: The best analogies are examples
00:16:46 <hunteriam> What does it take to get hired as an Intern at Jane Street?
00:18:23 <Abrahm> Hello,
00:20:59 <Abrahm> I am new to open source and m interested in participating in GSoC16 by contributing to haskell community I have learned haskell just designed a hetris game using haskell can anyone guide me?
00:21:18 <Abrahm> any beginner project in which i can contribute?
00:24:25 <nut_> cabal sandbox init --sandbox /path/to/share/sandbox
00:24:33 <nut_> will this affect the shared sandbox ?
00:26:01 <Cale> Abrahm: I'm not sure... there is a #haskell-gsoc which if you don't mind idling on IRC for a while might help your question get seen by people who are interested in mentoring a project. I'm not sure if there's a list or something yet this year, but there have been in years past.
00:28:31 <Cale> Abrahm: there are a bunch of project ideas here... I don't know how up to date they all are (but the dates might be some indication) https://ghc.haskell.org/trac/summer-of-code/report/1
00:30:11 <Cale> Abrahm: Of course, there are probably many more things out there
00:32:09 <Abrahm> join #haskell-gsoc 
00:36:53 --- mode: ChanServ set +o Cale
00:37:02 --- mode: Cale set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.206.190.141.229
00:37:02 --- kick: junglebunnys was kicked by Cale (junglebunnys)
00:37:09 --- mode: Cale set -o Cale
00:52:15 <Xnuk> exit
00:52:42 <unK_> hey. does anyone know of an existing project that aims to guide you with code indentation while writing haskell? something like haskell-indentation-mode for emacs, but editor-agnostic. I recently realized that even though haskell-indentation-mode improved a lot recently, its two main problems are that it benefits only emacs users and it's hard to contribute to because of elisp.
00:59:14 <cocreature> unK_: there is hindent if you want completely automatic indentation
00:59:37 <cocreature> @where hindent
00:59:37 <lambdabot> https://github.com/chrisdone/hindent/
00:59:41 * hackagebot HTTP 4000.3.2 - A library for client-side HTTP  https://hackage.haskell.org/package/HTTP-4000.3.2 (GaneshSittampalam)
01:00:50 <unK_> cocreature: yes, I've seen hindent. but it's function is reindenting existing code, not guiding you while writing it :)
01:01:04 <cocreature> yeah, I don’t know of something editor agnostic for that
01:03:54 <JamesJRH> Hi.
01:04:53 <wedens> unK_: https://github.com/chrisdone/structured-haskell-mode
01:05:29 <cocreature> that’s also only for emacs no?
01:05:52 <JamesJRH> How do I convert base 64 from something in the standard library?
01:06:17 <wedens> I suppose it is
01:06:44 <cocreature> there is an editor agnostic backend but that’s basically ghc-dump-tree based on haskell-src-exts
01:07:00 <cocreature> JamesJRH: https://hackage.haskell.org/package/base64-bytestring-1.0.0.1/docs/Data-ByteString-Base64.html converts bytestrings, not sure what exactly you want
01:07:19 <unK_> yeah, it forces one style of indentation because of this
01:07:36 <JamesJRH> cocreature: I've tried that but can't get it to work.
01:09:40 <JamesJRH> cocreature: Also, I'm not sure what ByteStrings are compared to normal strings / lists of characters.
01:10:11 <JamesJRH> Hmm, maybe it's obvious, actually.
01:10:22 <JamesJRH> When I put it like that.
01:10:38 <cocreature> JamesJRH: a list of bytes (well not exatctly a list, but some sequence). strings are lists of characters each of which can consist of multiple bytes
01:10:41 <JamesJRH> Characters are not necessarily a byte.
01:10:53 <JamesJRH> Right, yes.
01:11:19 <JamesJRH> Okay, so how do I deal with that?
01:11:53 <cocreature> maybe you should first explain what exactly you are trying to accomplish
01:12:01 <JamesJRH> That bring character encoding into it so I thus have to declare that it's UTF-8.
01:12:08 <JamesJRH> brings*
01:13:11 <JamesJRH> cocreature: I just want to encode and decode strings to and from base 64.
01:13:55 <hunteriam> "Used the Servant framework on top of the Wai/Warp server."
01:14:02 <hunteriam> is it wrong to say the  `Wai/Warp server`
01:14:48 <cocreature> JamesJRH: use https://hackage.haskell.org/package/utf8-string-1.0.1.1/docs/Data-ByteString-Lazy-UTF8.html#v:fromString to get a bytestring and then encode from base64-bytestring
01:16:32 <JamesJRH> For example, in Python: >>> import base64
01:16:32 <JamesJRH> >>> base64.b64encode('I want to do this in Haskell.')
01:16:32 <JamesJRH> 'SSB3YW50IHRvIGRvIHRoaXMgaW4gSGFza2VsbC4='
01:16:45 <JamesJRH> >>> base64.b64decode('SSB3YW50IHRvIGRvIHRoaXMgaW4gSGFza2VsbC4=')
01:16:45 <JamesJRH> 'I want to do this in Haskell.'
01:20:25 <liste> JamesJRH in ghci:
01:20:33 <liste> :set -XOverloadedStrings
01:20:40 <liste> import Data.Bytestring.Base64
01:20:49 <liste> encode "I want to do this in Haskell"
01:21:13 <liste> (if you have base64-bytestring installed)
01:22:27 <JamesJRH> Oh, so that /is/ how you import it.
01:23:01 <JamesJRH> liste: Thanks, but I have another problem. My system doesn't seem to have the module:     Could not find module ‘Data.Bytestring.Base64’
01:24:27 <JamesJRH> Any ideas what system package this is typically in? Specifically for NixOS.
01:25:04 <liste> JamesJRH nixpkgs.haskellPackages.base64Bytestring in my (very old) nix
01:25:25 <JamesJRH> Hmmm…
01:25:36 <JamesJRH> What version?
01:25:50 <demize> JamesJRH: https://nixos.org/nixpkgs/manual/#users-guide-to-the-haskell-infrastructure
01:26:32 <liste> so it's just haskellPackages.base64Bytestring now
01:26:41 <JamesJRH> liste: I'm also running an old version (1 behind), but I have a way of installing from any Git commit pretty effortlessly.
01:27:17 <JamesJRH> demize: Excellent! Thanks! :-D
01:28:44 <JamesJRH> Lol!: “The Haskell package set is not registered in the top-level namespace because it is /huge/.”
01:34:49 <JamesJRH> Ah, this reminds me. And is definitely relevant… :-] When I updated from 14.04 to 14.12 a couple of weeks ago, the package nixos.pkgs.haskellPackages.haskellPlatform had a problem, and I commented it out of my NixOS configuration:
01:34:53 <JamesJRH> 		#haskellPackages.haskellPlatform  # FIXME: Disappeared?
01:35:11 <JamesJRH> It wouldn't update for some reason.
01:35:38 <JamesJRH> nixos.pkgs.haskellPackages.ghc was fine though.
01:54:44 <m1dnight_> Can I write unit tests with HUnit that require a functioncall to fail? (A monadic function)
01:55:34 <m1dnight_> Well, the actual function I call uses `runState` and its type signature is `String -> Type` where Type is my own data type.
02:19:01 <mtesseract> hi
02:19:34 <plazmonii> o/
02:19:52 <jle`> where is documentation for globally installed stack packages installed?
02:22:47 <m1dnight_> Huh, isnt `instance Exception MyDataType` supposed to wokr?
02:22:51 <hunteriam> is there anyone here who feels like giving me feedback on my CV?
02:22:54 <m1dnight_> For some reason it doesn't compile on ghc 7.10
02:24:42 <jle`> what's the error?
02:26:06 <m1dnight_> src/Scribble.hs:11:2: parse error on input ‘instance’
02:26:12 <m1dnight_> and ths is the code:
02:27:40 <m1dnight_> Oh wait.
02:27:50 <m1dnight_> It seemed like I have to loose contraints on the base in my .cabal.
02:27:52 <m1dnight_> I think I got it
02:29:12 <m1dnight_> Kweet het eerlijk gezegd niet
02:29:15 <m1dnight_> ma ik zou gokken van wel.
02:30:40 <m1dnight_> Oh, that last part was the wrong window, excuse me..
02:45:03 <nut_> anyone knows a good yesod+mongodb example site with code ?
02:46:31 <cocreature> jle`: what do you mean by “globally installed stack packages”? packages in a snapshot? in that case look at the output of stack path in particular snapshot-doc-root
02:47:05 <jle`> oh yes true, they're installed in snapshots
02:47:27 <jle`> found them! thanks :)
02:47:31 <cocreature> yw
02:51:17 <sanotehu> r = a + if condition then b else 0
02:51:33 <sanotehu> is that the cleanest way to write that in one line?
02:51:48 <sanotehu> or is there nicer syntax that accomplishes the same thing?
02:52:58 <jle`> r | condition = a + b
02:53:01 <jle`>   | otherwise = a
02:53:03 <jle`> maybe?
02:58:51 <JamesJRH> liste: What version of NixOS do you have?
03:04:16 <sanotehu> jle`: yeah that's probably more readable, thanks
03:05:22 <jle`> sanotehu: np.  you can also use 'bool' as a nice function to replace 'if' if you don't need layouting; bool f t b = if b then t else f
03:05:31 <jle`> but that can probably lead to unreadable code pretty fast
03:13:12 <lyxia> if-then-else wastes three potential function names :(
03:23:01 <JamesJRH> What is Data.Bytestring versus Data.Bytestring.Base64?
03:23:23 <JamesJRH> Is at least one of them a ‘module’?
03:24:08 <JamesJRH> How does it work that I can have Data.Bytestring without Data.Bytestring.Base64?
03:24:57 <jle`> JamesJRH: they're modules, but they're from different packages
03:26:21 <JamesJRH> jle`: How is that possible/allowed?
03:26:31 <JamesJRH> That's such a crazy idea.
03:26:36 <jle`> packages export modules
03:26:46 <jle`> modules sort of all exist on a global namespace
03:26:58 <jle`> for example, i might make a package "foo", and provide my things in a module Data.Foo
03:27:21 <jle`> that doesn't mean that i had to talk to anyone to allow me to use "Data"
03:27:38 <jle`> the `bytestring` package provides a module called Data.ByteString
03:28:01 <JamesJRH> What's wrong with each package having its own module name and not mixing with other packages?
03:28:03 <jle`> the `base64-bytestring` package provides a module called Data.ByteString.Base64
03:28:23 <JamesJRH> What is the advantage of mixing the namespace?
03:28:33 <sanotehu> is there strong preference for (-10) or (negate 10)?
03:29:04 <sanotehu> I'd assume negate is better used with results from functions like (negate $ f 10) ?
03:29:39 <jle`> JamesJRH: i'm not sure if there is a particular exceptional advantage, but it's sort of convenient in a lot of things
03:30:23 <jle`> you can think of module hierarchies as categories of functionality
03:30:27 <jle`> not inherent to any packages
03:30:41 <JamesJRH> I suppose so.
03:30:55 <JamesJRH> Hmmm.
03:31:11 <jle`> for exmaple i might make a package for parsing yaml files, call it "yaml", and export a module Data.Yaml
03:31:18 <jle`> "Data" is like a category, here
03:31:24 <jle`> it doesn't mean that it's realted to some package called 'data'
03:31:26 <jle`> *related
03:31:56 <JamesJRH> Now I have ideas that relate back to packaging specifics again and NixOS again.
03:32:30 <JamesJRH> This topic straddles packaging and Haskell's module system.
03:36:43 <JamesJRH> jle`: What has come to mind is that, yes, I see the advantage – it's nice to be able to split-up the namespace into separate small packages that don't clump together – but the problem that I see is solvable in another way. There can be 2 packages that provide each module: 1 that provides just that part; and 1 that depends on that as well as /everything/ below it.
03:39:58 <quchen> sanotehu: it doesn't really matter, use whatever works for you.
03:41:04 <quchen> sanotehu: There is a subtlety with negative literals in your code though, see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#negative-literals
03:59:46 * hackagebot resolve-trivial-conflicts 0.3.2.2 - Remove trivial conflict markers in a git repository  https://hackage.haskell.org/package/resolve-trivial-conflicts-0.3.2.2 (EyalLotem)
04:09:26 <roelof> A off-topic question : I try to make a layout for a web app. Does anyone know a good free  html5 editor ? 
04:22:24 <EvilMachine> Yaay! I am actually building GHC 7.10.3 on an ARMv7hf box with only 1GB of RAM! (currently in stage 2) :D
04:22:48 <roelof> EvilMachine:  congrats
04:24:26 <EvilMachine> It only works with LLVM ≤3.3, and normal swap, because that one compile just took ~1.1GB of RAM alone. (All the others were are far from 1GB though.)
04:36:24 <haskell886> can someone help me with a problem on haskell
04:39:39 <haskell886> anyone here?
04:39:48 * hackagebot sexp-grammar 1.1.0 - Invertible parsers for S-expressions  https://hackage.haskell.org/package/sexp-grammar-1.1.0 (EugeneSmolanka)
04:41:10 <lyxia> haskell886: what is it?
04:56:56 <haskell886> hey
04:56:59 <haskell886> i need to write a function named maxDuplicate, which works with list of lists of Int. It has to find the biggest of the numbers in the list they are, which are duplicates. An example should be - maxDuplicate [[1,2,3,2],[-4,-4],[5]] -> 2
04:57:17 <haskell886> i'm a begginer
05:00:04 <dramforever> haskell886: I didn't quite understand what you are trying to do. Can you explain what "find", "biggest" and "duplicate" mean?
05:01:56 <haskell886> the biggest number means like in the example 
05:02:02 <haskell886> i have duplicates of 2s and -4s
05:02:13 <haskell886> and the 2 > -4 so it returns the 2
05:02:28 <haskell886> by find i mean return
05:03:31 <dramforever> haskell886: what about maxDuplicate [[1, 1], [2], [2]] ? Is 2 a duplicate?
05:04:32 <haskell886> no
05:04:37 <haskell886> it each seperate list
05:04:58 <John[Lisbeth]> I am trying to find the cube root of x assuming x is an integer and the answer is always going to be an integer
05:05:18 <dramforever> haskell886: corner cases: what about maxDuplicate [] ? maxDuplicate [[1,2,3]] ?
05:06:11 <haskell886> it returns 0
05:06:55 <haskell886> i think
05:09:58 <dramforever> So far so good. You said you are working on "each separate list", so first let's find the largest duplicate number in one list of numbers. Do you have any idea on that? Like, say, how would you do it by hand?
05:11:00 <haskell886> i have an idea but i'm not sure how to write it on haskell
05:11:08 <dramforever> you know, computers are not smart, so you'd better make it simple :P
05:11:46 <dramforever> haskell886: Yep, that's what I mean by a simple idea about how you would do it by hand
05:12:05 <John[Lisbeth]> basically I need to do something similar to "cube_root y = [ x | x <- [1..], (x * x * x) == y]"
05:12:36 <haskell886> can you write the code and explain it to me or is that too much?
05:13:47 <dramforever> haskell886: oh you want that kind of learning, okay
05:13:57 <John[Lisbeth]> The reason I am having trouble is that if I use division to uncube the cube, then I have to divide
05:14:18 <John[Lisbeth]> I can't preserve the int type even though I know for sure that the answer will always be an int in this set
05:28:55 <dramforever> haskell886: http://lpaste.net/149773 I put in the explainations as comments
05:50:35 <tremon> John[Lisbeth]: use div instead of (/) ?
05:51:32 <haskell886> hey everyone, I need some help with this problem : If a "book" is a tuple with components ("Title", "Year of release") and a "library" is a list of "books", I need to write two functions. findUniques returns a list of all the "books" released in a unique year. longestTitleYear returns the year of the book with the longest title. I'm a begginer in Haskell so any help is welcome.
05:52:04 <tremon> :t 27 `div` 3
05:52:06 <lambdabot> Integral a => a
06:02:25 <haskell886> anyone?
06:06:50 <pavonia> haskell886: What do you have so far?
06:08:02 <haskell886> nothing is you are asking me :/
06:08:25 <jdnavarro> haskell886: are you aware of `nub`? https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-List.html#g:20
06:09:03 <jdnavarro> for short lists should be fine
06:10:46 <maerwald> I wouldn't even start with a tuple, but with my own ADT
06:11:01 <maerwald> (String, String) is somewhat random IMO
06:11:40 <jdnavarro> with a `Map` should be straightforward
06:12:24 <haskell886> can someone write the code with explanations or is it too much to ask?
06:12:57 <jdnavarro> for the longest year I'd look into `sortBy` `on`
06:13:06 <jdnavarro> https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-List.html#g:20
06:13:29 <jdnavarro> sorry, this link: https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Function.html#v:on
06:14:17 <jdnavarro> or with `comparing` https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Ord.html#v:comparing
06:19:09 <jdnavarro> off the top of my head: `findUnique year = map fst $ filter ((year ==) . snd) $ library`
06:19:29 <maerwald> haskell886: if you pay me
06:23:01 <jdnavarro> haskell886: `longestTitleYear = fst $ maximumBy (\x y -> fst x > fst y) library`
06:23:27 <jdnavarro> not sure it's correct but it should be something along those lines
06:32:51 <t0by> idiotic question of the day: why are monoids called "monoids"?
06:38:45 <apriori> t0by, no real knowledge, but how about separating the name in "mono" (aka a single) and "id"
06:39:14 <t0by> apriori, please go on
06:39:27 <T0BI> yo t0by
06:39:32 <T0BI> same nick
06:39:47 <apriori> in the sense there is only one element fulfilling the role of "id" 
06:39:53 <t0by> WE MEET AT LAST
06:39:58 <apriori> idk, just a random thought
06:40:02 <t0by> YOU ARE THE BASTARD WHO STOLE THE GOOD NICK FROM ME.
06:40:04 <t0by> sorry
06:40:11 <T0BI> haha
06:40:12 <t0by> still with you apriori.
06:40:12 <T0BI> ok
06:40:14 <t0by> :P
06:40:16 <T0BI> sorry for that
06:40:22 <t0by> T0BI, just kidding :)
06:40:27 <T0BI> np
06:40:32 <t0by> it is in fact amusing
06:40:42 <T0BI> why
06:40:48 <t0by> that we have the same nick.
06:40:52 <t0by> (also my real beef is with `toby`, whoever he may be :P)
06:40:57 <T0BI> nice
06:41:15 <t0by> apriori, I'm very confused
06:41:32 <t0by> you may very well have a point, but I'm not understanding what it is :)
06:44:06 <absence> what's the rule of thumb for when newtype wrappers start costing performance?
06:45:49 <absence> i have a case where wrapping my numbers in newtype causes the computation to take almost twice as long
06:47:15 <exio4> absence: care to show that? sounds like it's not the newtype but optimizations not firing or something like that :P
06:48:05 <absence> exio4: hmm, it's big and messy, so i'd rather not
06:48:30 <absence> exio4: what would cause optimisations to not fire though?
06:49:30 <absence> i have littered the code with "coerce" where necessary, so i can switch the newtype wrapper on or off by commenting out the newtype definition and use a type alias instead
06:49:39 <absence> so it should be the same code
06:50:10 <exio4> absence: I don't really know, I'd profile and see if the hot spots change, etc
06:50:26 <absence> unless coerce or the derived instances for the newtype somehow don't realise they shouldn't be doing work
06:51:09 <exio4> absence: if you can reduce this to a smaller test case, it'd be really nice (because you could fill an issue, etc)
06:53:46 <absence> exio4: yeah, not so easy with 200 lines of numeric computation, but i'll see what i can do
06:54:27 <exio4> absence: I understand :/
06:54:32 <absence> exio4: just enabling profiling changes the performance because of the added profiling code :p
06:55:10 <Dfhddz> Sorry, I have a quick question. What is the simplest web framework in Haskell for quick p
06:55:11 <exio4> absence: indeed, but it's more that it'd tell you where optimizations might have stopped firing, or so :P 
06:55:41 <hunteriam> i love learning about the various techniques for reducing program complexity that people come up with
06:55:47 <hunteriam> or generalizing things or so on
06:55:51 <Dfhddz> Sorry, I have a question. What is the simplest web framework for stupid people like me?
06:55:53 <hunteriam> basically the topic of haskell discussion
06:56:10 <hunteriam> is there a job or summer research opportunity or intenrship that would be along those lines?
06:56:21 <hunteriam> Dfhddz: Have you looked at scotty?
06:57:03 <Dfhddz> No
06:57:05 <hunteriam> Dfhddz: Servant is lovely if you want to write an api
06:57:56 <Dfhddz> I'm really just interested in handling basic get/post requests that's simple enough for me to use
06:58:05 <Dfhddz> Okay I'll look it up
07:00:30 <hunteriam> You may also be interested in `Spock`
07:04:52 * hackagebot MonadRandom 0.4.2 - Random-number generation monad.  https://hackage.haskell.org/package/MonadRandom-0.4.2 (BrentYorgey)
07:19:52 * hackagebot sign 0.4.3 - Arithmetic over signs and sets of signs  https://hackage.haskell.org/package/sign-0.4.3 (MasahiroSakai)
07:23:09 <saurabhnanda> hi guys, I'm in the middle of a hackathon and the project that I'm working on is available at https://github.com/vacationlabs/nightwatch/blob/master/nightwatch.hs
07:23:20 <saurabhnanda> I'm stuck with handling exceptions
07:23:34 <saurabhnanda> the typechecker doesn't seem to to be pleased
07:24:34 <saurabhnanda> that's the error I'm getting: http://lpaste.net/149779
07:24:40 <saurabhnanda> any help would be really appreciated
07:24:57 <saurabhnanda> I've tried all sorts of syntax to handle errors, but all of them end up with the same core issue
07:25:12 <saurabhnanda> IO () does not go well with IO (Response Data.ByteString.Lazy.Internal.ByteString
07:25:41 <eikke> anyone around who has a full-fledged GHC/CC toolchain for ARM available (and an ARM device, preferably) and would be willing to test something?
07:26:52 <quchen> saurabhnanda: That error is unrelated to exception handling. I think you're missing a "pure ()" after line 123.
07:28:08 <quchen> Hm, that can't be it, because it's a non-terminating recursive function, so IO () should be fine, or (IO r) even.
07:28:31 <saurabhnanda> quchen: could you please elaborate?
07:28:41 <saurabhnanda> quchen: how exactly should I be using pure at the end of that function?
07:29:12 <quchen> You're getting a type error, so the compiler complains. Exceptions are a runtime thing, which does not apply here.
07:29:26 <saurabhnanda> quchen: is the overarching concept that the main function call and the error handler need to have the same data-type?
07:29:47 <saurabhnanda> quchen: main function = function which is being guarded for errors
07:30:32 <saurabhnanda> quchen: sendMessage internally calls wref get/post functions, so it's dealing with IO (Response Data.ByteString.Lazy.Internal.ByteString)
07:31:14 <saurabhnanda> quchen: whereas the handler simply prints a string with putStrLn, which has type IO ()
07:31:21 <saurabhnanda> is that the reason the compiler is complaining?
07:32:05 <quchen> Oooh. I found the location of the type error, it's in column 1244323.
07:32:19 <quchen> Maybe shorten that line to 80 chars.
07:33:47 <saurabhnanda> quchen: was that for me?
07:34:00 <quchen> Yes.
07:34:34 <quchen> That line is almost 400 characters long, which is a no-go. The type error code was hidden in the very end of it.
07:34:55 <quchen> saurabhnanda: How about formatting it like this? http://lpaste.net/149781
07:35:14 <quchen> (by the way,   \e -> putStrLn (show e)   is equivalent to "print".
07:35:16 <quchen> )
07:35:26 <saurabhnanda> okay
07:36:07 <saurabhnanda> quchen: changed the code
07:36:10 <saurabhnanda> quchen: still the same error
07:36:16 <saurabhnanda> quchen: updated github as wel
07:37:40 <lynn> :t catch
07:37:41 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
07:37:48 <quchen> Top-level type signatures for all definitions are also a best practice. It helps a reader (for example me) to see types without actually loading your program in the compiler.
07:37:51 <lynn> what is `a` in your case?
07:38:06 <quchen> lynn: ().
07:38:18 <quchen> Oh, you mean from sendMessage
07:38:23 <saurabhnanda> quchen: I'm not sure what you mean. If you could point me to a wiki which explains this, it'd be great.
07:38:47 <lynn> Yeah, I'm pointing out where saurabhnanda's type error is coming from
07:39:24 <saurabhnanda> lynn: do you need sendmessage's type signature?
07:39:24 <quchen> saurabhnanda: "foo :: a -> a" is a type signature. All top-level declarations should have one.
07:39:33 <saurabhnanda> quchen: got it, thanks
07:39:48 <quchen> So your code should say "getUpdates :: XXXX" right before defining getUpdates.
07:40:09 <lynn> saurabhnanda: Yeah. Its eventual result is `IO (Response ByteString)`, right?
07:40:11 <quchen> saurabhnanda: Your `sendMessage` probably has a type "-> IO ByteString" or something.
07:40:35 <quchen> And that's where the type error probably comes from.
07:40:41 <saurabhnanda> it is internally calling wref library's post function
07:40:47 <saurabhnanda> I can get :t post easily
07:41:08 <quchen> You need to :t sendMessage and paste that above "sendMessage ... = ".
07:41:14 <saurabhnanda> post :: wreq-0.4.1.0:Network.Wreq.Internal.Types.Postable a => String -> a -> IO (Response Data.ByteString.Lazy.Internal.ByteString)
07:41:19 <quchen> You can also compile with -W to get warnings about htis.
07:41:29 <lynn>  sendMessage update msg             :: IO (Response ByteString)
07:41:29 <lynn> (sendMessage update msg >> pure ()) :: IO ()
07:41:53 <quchen> Try:    void (sendMessage update "test") `catch` print
07:41:58 <quchen> Void is from Data.Functor
07:42:04 <quchen> "void", that is
07:42:21 <saurabhnanda> request you to please explain the concept along with the fix
07:42:28 <lynn> Ooh, `void` is the thing I was thinking of!
07:42:36 <saurabhnanda> it is that both the branches (error and non-error) shouls have same data-type
07:42:43 <lynn> Yep, basically that
07:43:01 <saurabhnanda> so void conversts IO (blah) to IO ()
07:43:11 <saurabhnanda> is there a way to do the reverse, in case I need to do it in the future?
07:43:23 <lynn> Both branches of `catch` should give back the same `IO a`, but in your case, one has a response, and the other doesn't
07:43:39 <jas1211> hi i know this is not qa question about haskell but its about monad and functional hopefully I can ask here
07:43:42 <lynn> Hmm, well, you could do `someAction >> pure someValue`
07:43:49 <jas1211> i'm reading http://techblog.realestate.com.au/how-we-used-category-theory-to-solve-a-problem-in-java/
07:44:08 <Hafydd> saurabhnanda: you can use <$ from Control.Applicative for that, too.
07:44:14 <jas1211> in the composing with input he has this:
07:44:26 <jas1211> Results apply(S source, Results results);
07:44:35 <jas1211> what should be the implementation of that funtion?
07:44:49 <jas1211> does he store the source and results as "members"? what does he do with them in apply?
07:45:00 <saurabhnanda> tried that, now 'catch' and 'show' are turning out to be ambiguous
07:45:07 <jas1211> he said that the apply is a monoid
07:45:26 <jas1211> so it should apply something to the results and return again a results but what does he apply to the results?
07:45:30 <Hafydd> jas1211: do you really think we'll be able to help without knowing what language it's written in?
07:45:41 <jas1211> its java
07:46:04 <quchen> Hafydd: Well, Java is in the article's title.
07:46:10 <jas1211> here is the code:
07:46:12 <jas1211> interface Extension<S> {       Results apply(S source, Results results);       final default Extension<S> compose(Extension<S> e) {         return (src, results) -> e.apply(src, Extension.this.apply(src, results));     }       static final Extension IDENTITY = (s, r) -> r;       static <S> Extension<S> composeAll(Extension<S>... extensions) {         return Stream.of(extensions).reduce(IDENTITY, Extension::compose);     }       defau
07:46:15 <Hafydd> Oh, I missed that.
07:46:19 <jas1211> oh did not get formatted
07:46:25 <quchen> jas1211: Please paste your code online, not in the channel
07:46:26 <quchen> ?where paste
07:46:27 <lambdabot> Haskell pastebin: http://lpaste.net/
07:46:51 <quchen> saurabhnanda: Paste the error please
07:46:56 <saurabhnanda> No instance for (Show a0) arising from a use of ‘print’
07:47:01 <jas1211> pasted code:
07:47:02 <jas1211> http://lpaste.net/149783
07:47:20 <quchen> saurabhnanda: Paste the complete source code and the complete error somewhere please
07:47:24 <saurabhnanda> No instance for (GHC.Exception.Exception a0) arising from a use of ‘catch’. The type variable ‘a0’ is ambiguous. Note: there are several potential instances:
07:47:28 <jas1211> so the `apply` has no implementation which is ok because its an interface
07:47:30 <saurabhnanda> quchen: 2mins
07:47:31 <lynn> jas1211: I'm no Java expert, but doesn't `interface` mean there is no implementation?
07:47:33 <lynn> Right
07:47:34 <jas1211> but what do you think should be its implementation?
07:47:44 <jas1211> yes
07:47:49 <quchen> lynn: Java 8 changed that, but yeah
07:47:51 <jas1211> i just wonder what should the implementation of apply be
07:47:55 <jas1211> i mean
07:47:57 <quchen> s/changed/relaxed/
07:48:05 <jas1211> some of the functions have default implementation
07:48:07 <lynn> Oh right, `default`
07:48:10 <jas1211> this one seems not to have
07:48:31 <saurabhnanda> http://lpaste.net/149784 and https://github.com/vacationlabs/nightwatch/blob/master/nightwatch.hs
07:48:54 <saurabhnanda> quchen: http://lpaste.net/149784 and https://github.com/vacationlabs/nightwatch/blob/master/nightwatch.hs
07:48:56 <saurabhnanda> lynn: http://lpaste.net/149784 and https://github.com/vacationlabs/nightwatch/blob/master/nightwatch.hs
07:49:15 <jas1211> so apply in monoid doesnt it supposed to apply something to the input and generate the same type?
07:50:24 <lynn> I don't see what the "source parameter" is used for. :<
07:50:43 <saurabhnanda> lynn: is that for me?
07:50:51 <voxr> what's the consensus on aeson 0.10? don't use it?
07:50:55 <lynn> No, for jas1211 (I'll look at your paste in a bit!)
07:51:54 <lynn> jas1211: I think the "source parameter" can just do whatever. It contains some extra info for `apply` to perform work on the Results
07:52:07 <jas1211> yeah
07:52:08 <lynn> And it just gets threaded through when you compose a bunch of Extensions
07:52:10 <jas1211> yeah exactly
07:52:29 <jas1211> hmm let me see
07:52:44 <jas1211> how is it being threaded through?
07:53:04 <quchen> saurabhnanda: It doesn't know what you're catching, so the "e" in "\e -> print e" has ambiguous type. You'll need to spefify that type, for example like this. http://lpaste.net/149785
07:53:11 <lynn> return (src, results) -> e.apply(src, Extension.this.apply(src, results));
07:53:13 <jas1211> it makes sense that the purpose of source is to be threaded through but as there is no implemnetation i miss how is it being threaded through?
07:53:26 <jas1211> or at least what was the meaning how would he mean to thread it through
07:53:33 <jas1211> the only function which receives this source is the apply
07:53:36 <lynn> The same `src` is passed to both extensions, if you compose two of them
07:54:06 <jas1211> unless i miss anything
07:54:10 <quchen> saurabhnanda: The thing you're applying "catch" to has type "IO ()". And you're saying "catch it with a function e -> IO (), printing the thing of type "e". Printing requires a Show instance. But since "e" is fully polymorphic, GHC doesn't know which "print" function you want.
07:54:15 <quchen> Is it "print an integer"?
07:54:19 <quchen> Is it "print a String"?
07:54:30 <quchen> What you want is "print a SomeException". So that's what you need to annotate.
07:54:32 <lynn> (`e` is the next one, `this` is this one)
07:54:43 <jas1211> @lynn yes
07:54:43 <lambdabot> Unknown command, try @list
07:54:53 <jas1211> but how does he pass the same src i mean
07:55:00 <jas1211> the src is passed firstly in apply function
07:55:02 <quchen> saurabhnanda: You could also write \(e :: SomeException) -> print e, but that would require a (harmless) language extension.
07:55:04 <jas1211> does he store it?
07:55:14 <lynn> It's a lambda argument
07:55:15 <jas1211> i'm not sure which function is called first and how the src is passed at first
07:55:19 <lynn> return (src results) -> ...
07:55:44 <saurabhnanda> quchen: I'm royally confused with the syntax now
07:55:57 <quchen> saurabhnanda: Which part?
07:55:58 <jas1211> @lynn in `return (src, results)` how does he have access to this `src` where did it come from?
07:55:58 <lambdabot> Unknown command, try @list
07:56:18 <lynn> If I have to Extension<S>'s, `a` and `b`,  `a.compose(B)` will be a new anonymous function that you can pass a source and results.
07:56:25 <lynn> * `a.compose(b)`
07:56:35 <saurabhnanda> quchen: does this seem right -- void (sendMessage update "test") `catch` (\e -> do putStrLn (show (e :: SomeException)))
07:56:36 <Hafydd> jas1211: that article doesn't have anything to do with monads. I think you misread it.
07:56:38 <lynn> So it uses whatever source you pass to the composition
07:57:29 <quchen> saurabhnanda: If it compiles then yes.
07:57:38 <saurabhnanda> quchen: ha ha
07:57:42 <quchen> saurabhnanda: "do x" is equivalent to "x".
07:57:51 <quchen> putStrLn (show x) is equivalent to print x.
07:58:04 <saurabhnanda> quchen: I'm trying random permutations now just to get the damn thing to compile
07:58:17 <saurabhnanda> quchen: compiled. Let me run
07:58:32 <lynn> jas1211: I don't know if it will help, but, imagine `Results` is just `int`, or something, and `S` is a file stream.
07:58:51 <jas1211> yes i can imagine thi
07:58:53 <jas1211> s
07:58:53 <lynn> I could have two Extension<S>'s, which implement `apply` as follows:
07:59:00 <jas1211> yes...
07:59:23 <lynn> `a` will take (fileStream, x), print the int to the stream, and return x+1.
07:59:30 <lynn> `b` will take (fileStream, x), print the int to the stream, and return x*2.
07:59:49 <Hafydd> It looks like the author implemented some notion of functors in Java, then tried to impress all of their colleagues by describing it in unnecessarily abstract terms.
08:00:27 <lynn> So what would happen if I do `a.apply(System.out, 3)`? And `b.apply(System.out, 3)`?
08:01:04 <jas1211> a.apply(System.out, 3) --> print 3 to System.out and return 4
08:01:32 <jas1211> b.apply(System.out, 3) --> print 3 to steam and return 6
08:01:43 <jas1211> (to System.out)
08:02:11 <lynn> Yeah. So now, I'll define a new `Extension<S> c = a.compose(b)`
08:02:36 <lynn> The implementation of `compose` is `return (src, results) -> e.apply(src, Extension.this.apply(src, results));`
08:03:51 <lynn> Which defines `c`'s `apply`. (The lambda anonymously overriding the only unimplemented member of Extension<S>, and all.)
08:04:09 <jas1211> aha
08:04:27 <jas1211> i'm beggining to grasp it
08:04:28 <jas1211> thanks
08:04:45 <lynn> So `c` will do what `a` did, and *then* do what `b` did with the same source, but `a`'s result.
08:05:33 <lynn> So basically, you're chaining together the steps of some process, each of which relies on some common source (in my example, a file stream)
08:06:09 <jas1211> perfect thanks i get the picture i need to sit a few minutes alone with the details
08:06:16 <jas1211> :)
08:06:31 <jas1211> I guess i misunderstood the apply
08:06:38 <lynn> Haha, yeah, that's the best way to wrap your head around these things
08:06:38 <jas1211> i get now its for the lamda
08:07:23 <lynn> And Java lambdas are weird! Like, full disclosure: I only remembered how they worked halfway through my explanation. ^^
08:08:04 <jas1211> really :)
08:08:49 <jas1211> well if there was haskell on jvm which is well maintained i would seriously think of it, right now for me only java or scala as i have to work with jvm
08:08:53 <the_2nd> the OpenGL lib has a Vertex2 data type : Vertex2 a
08:09:15 <the_2nd> how can I define an own type of e.g. : IntVertex2 = Vertex2 Int
08:10:24 <voxr> lynn how is java dev these days? i haven't touched java in like 15 years
08:10:40 <lynn> True story: I programmed some Java at a summer vacation job, which is the only reason I know the language. I picked up the basics, and then immediately started writing code that used lambdas and fancy Java 8 stuff, because I'm more of a Haskell person!
08:10:51 <voxr> from what i remember it looked like what bad c++ looks like today
08:11:01 <lynn> And everyone there thought: "wow, you must have lots of Java experience" :D
08:12:36 <voxr> oof added yesod to my cabal file  and ghc-mod/haskell mode is taking like 10 minutes to open a Main.hs with nothing in it...
08:13:22 <lynn> (It was a small, local company, owned by a distant family member. I got to work for them, but sorta bluffed my way into it -- in reality, I'd only messed with Java for, like, a week. They thought I had years of experience, because wow, lambdas mean you're on top of things.)
08:13:25 <the_2nd> type P = Vertex2 GLfloat
08:13:43 <the_2nd> how can I make this to work? I want my own type which is a Vertex2 for GLfloats
08:14:01 <the_2nd> so I can call P 0.0 0.5 
08:14:07 <voxr> lynn there are many isolated C++ and java shops are stuck in the stone ages
08:14:13 <the_2nd> instead of Vertex2 0.0 0.5 :: GLfloat
08:14:56 <lynn> voxr: Haha, yeah
08:15:16 <absence> what does "functionname.(...)" mean in .prof files?
08:15:26 <lynn> Thankfully, the project I worked on was new. Lots of the code I saw *other* people work on looked... unpleasant :<
08:15:56 <voxr> green field ftw
08:16:35 <the_2nd> Is my question stupid or does noone know?
08:16:38 <lynn> the_2nd: maybe just define a function, `point :: GLfloat -> GLfloat -> Vertex2 GLfloat`
08:16:54 <quchen> Green field means nothing. You can perfectly put Java on a green field.
08:17:22 <quchen> You can also offload heaps of mud onto a green field.
08:17:27 <the_2nd> lynn, but then I cant define my function signatures with it, right?
08:17:54 <lynn> And you can make a type alias for `type Point = Vertex2 GLfloat`, sure. I don't think you can "add" an all-capsy constructor to a type, sadly
08:18:21 <wz1000> Is it possible to wake a threadDelayed thread using a signal?
08:19:03 <quchen> wz1000: You can race threadDelayed against reading an empty MVar. It terminates when the delay is over, or when you fill the MVar.
08:19:14 <quchen> Either cancels the other thread.
08:19:33 <wz1000> quchen: Clever. I'll try that out.
08:20:41 <the_2nd> lynn, the combination is nice
08:30:10 * hackagebot haskellscrabble 1.4.3 - A scrabble library capturing the core game logic of scrabble.  https://hackage.haskell.org/package/haskellscrabble-1.4.3 (happy0)
08:32:48 <saurabhnanda> quchen: thanks for the help. it worked
08:32:54 <saurabhnanda> lynn: thanks for the help. it worked.
08:35:49 <wz1000> quchen: It worked perfectly! Thanks!
08:36:17 <quchen> wz1000: :-)
08:36:45 <quchen> wz1000: Keep in mind that this requires 2 additional threads, so you can't make millions of these
08:36:56 <quchen> Well, millions maybe, but not billions. :-D
08:42:40 <wz1000> Luckily, I just need two :P
08:50:13 * hackagebot hackage-diff 0.1.0.1 - Compare the public API of different versions of a Hackage library  https://hackage.haskell.org/package/hackage-diff-0.1.0.1 (blitzcode)
09:01:06 <quchen> wz1000: race is a pretty useful function, you can also use it for implementing general timeouts for example
09:01:26 <quchen> But you have to be careful to handle the ThreadKilled exceptions it generates properly
09:01:48 * hodapp ponders whether he's masochistic enough to try this Machine Learning course for his MSCS in Haskell instead of Python or R...
09:03:46 <t0by> stupid question, why arent' the following equivalent?
09:03:47 <t0by> 1.
09:03:53 <t0by> dropJ :: (Sized b, Monoid b) => Int -> JoinList b a -> JoinList b a
09:03:53 <t0by> dropJ 0 = id
09:03:54 <t0by> 2.
09:03:59 <t0by> dropJ :: (Sized b, Monoid b) => Int -> JoinList b a -> JoinList b a
09:03:59 <t0by> dropJ 0 a = a
09:04:24 <t0by> oh wait, probably #haskell-beginners
09:04:25 <t0by> sorry
09:04:37 <glguy> t0by: Beginner questions are just fine here
09:04:41 <glguy> those should be the same
09:05:13 * hackagebot binary-enum 0.1.2.0 - Simple wrappers around enum types  https://hackage.haskell.org/package/binary-enum-0.1.2.0 (tolysz)
09:05:39 <t0by> glguy, but I can't mix dropJ 0 = id with a definition in the form dropJ n a?
09:05:47 <t0by> (for n != 0 in which I have to do some actual work)
09:05:50 <glguy> t0by: However if you have other clauses they all have to have the same number of arguments
09:06:02 <t0by> glguy, I get it. Thanks.
09:06:07 <t0by> So is there a way around it?
09:06:13 <t0by> I kind of like writing "id" explicitly
09:06:53 <t0by> Assuming it is "good" haskell (is it?) I like writing "id" for a function that /is/ id.
09:07:22 <glguy> No, it's not better to try to use id there than the other version as far as "good haskell" goes
09:07:32 <glguy> but if you just wanted to explore what's possible you could try something like:
09:07:44 <glguy> dropJ n = \xs -> case xs of ....
09:07:49 <glguy> for the non-zero case
09:08:27 <nut_> what is the name of a website that people can train programming skills and keep gaining levels as if in a role-playing game and it supports haskell?
09:09:06 <puregreen> nut_: codewars.com
09:09:10 <t0by> "a bad idea"
09:09:11 <t0by> (sorry)
09:09:22 <hpc> idle rpg :P
09:09:50 <wz1000> quchen: Yeah, all of asyn is pretty awesome
09:15:27 <nut_> thx
09:27:47 <deni> anybody using sqlite-simple?
09:28:12 <deni> I'm having an issue where it's saying that No instance for (FromRow T.Text) arising from a use of ‘query_’
09:28:19 <deni> and I do in fact import the instance
09:28:49 <codedmart> How do I go from aeson Value to my custom data type?
09:29:46 <puregreen> codedmart: usually you write a FromJSON instance and then it happens automatically
09:30:14 * hackagebot process-extras 0.3.3.6 - Process extras  https://hackage.haskell.org/package/process-extras-0.3.3.6 (DavidFox)
09:30:47 <puregreen> codedmart: you can also do case analysis by yourself, or you can use the Parser type and then parseEither if you don't want an instance for some reason
09:30:57 <Pamelloes> Is there a way to insert a monad transfer within a stack? For instance if I had MonadReader r (MonadWriter s) a, could I somehow go to MonadReader r (MonadWriter s (MonadError e)) a [these are arbitrary transformers, I'm not sure if this combination is actually viable]
09:31:36 <deni> I was following the tutorial here but I'm not sure what I'm going wrong : https://hackage.haskell.org/package/sqlite-simple-0.4.9.0/docs/Database-SQLite-Simple.html
09:34:22 <puregreen> deni: what's the error message/problem?
09:35:50 <deni> puregreen: http://dpaste.com/1K2N6Q3
09:36:15 <deni> puregreen: I can fetch an entire row just fine...but if i try to fetch just one field from the row it fails with the message in the paste
09:37:00 <puregreen> query_ always returns a list of rows
09:37:12 <puregreen> if you want a field, it would simply be a row with one field
09:37:48 <puregreen> on the other hand, I think you can write “map fromOnly <$> query_ conn "SELECT url FROM links"” and it would return a list of fields
09:37:48 <hexagoxel> Pamelloes: you mean `ReaderT r (StateT s m) a`, i guess. there is `mapReaderT` and `mapStateT`.
09:38:13 <puregreen> (because Only is like a row with one element)
09:38:53 <Pamelloes> hexagoxel: Perfect! That's what I was looking for :)
09:40:02 <hexagoxel> i am not sure if there is a typeclass somewhere that abstracts over the different mapStateT/mapReaderT/.. .
09:40:21 <deni> puregreen: this might be obvious but the tutorial examples need to get updated then. Perhaps I can submit a PR once done with this
09:43:30 <deni> puregreen: worked!
09:43:32 <deni> tnx
09:44:06 <codedmart> puregreen OK,  I am trying to think how to do this properly. I am using wreq and can get a body like `{"exception": ...}` or `{"result": ...}` So I would like to handle those differently.
09:46:31 <absence> do newtype wrappers mess with ghc's ability to inline stuff? i get 2x performance difference for numerical computations with or without newtype wrapper in a normal optimised build, but when profiling with -fprof-auto and all INLINE pragmas removed, there is virtually no difference
09:46:37 <Pamelloes> hexagoxel: mmorph's MFunctor class appears to be that generalization.
09:48:26 <puregreen> codedmart: http://lpaste.net/149789
09:48:58 <puregreen> you write something like this and then you use asJSON and it gets converted automatically to Result something
09:48:59 <puregreen> https://hackage.haskell.org/package/wreq-0.4.1.0/docs/Network-Wreq.html#v:asJSON
09:49:10 <hexagoxel> ah, indeed. MFunctor + Functor gives you the mapFooT power.
09:52:01 <codedmart> puregreen Awesome, Thanks!
10:02:15 <nocturne777> in new projects, should we be using transforms or mtl?
10:02:27 <nocturne777> I found some answers online but they seem to be old
10:03:21 <quchen> nocturne777: Depends on who you ask. mtl is built ontop of transformers, and monad transformery by themselves are fine. The question is whether you should use the MTL library.
10:03:37 <absence> nocturne777: i read somewhere that transformers is good for libraries and mtl for applications, but i can't remember where :p
10:03:57 <quchen> It was probably just the other way round. :-)
10:04:30 <quchen> (Maybe not, who knows.)
10:04:52 <nocturne777> quchen: what benefits do I get from using mtl compared to transformers?
10:06:29 <quchen> You get the zoo of lifting functions from MTL, mostly.
10:06:52 <quchen> nocturne777: So you can't say "get" in *the StateT monad* but also in any stack that contains one
10:07:27 <quchen> Some people advocate that you should write your own transformer stacks, wrap them in a newtype, and implement the desired functions (such as get, ask, ...) yourself for your custom type
10:07:57 <quchen> This makes things more explicit.
10:08:19 <quchen> I like that approach, but decide on a case-by-case basis.
10:09:05 <quchen> Most of the time I use whatever I think is most convenient by asking my gut ;-) But I think kosmikus had a more educated opinion on this topic. I remember him talking about transformer stacks some time ago.
10:11:41 <fr33domlover> nocturne777, personally I use transformers for concrete cases (e.g. for a program I write which carries some State) and only use mtl when I need the abstraction and generality
10:12:01 <fr33domlover> e.g. in some library with classes and polymorphic types etc.
10:12:08 <absence> nocturne777: mtl abstracts away the nesting ordering. it may be good or bad, you get shorter code that is more reusable, but it's also less explicit and clear. mtl doesn't work so well if you nest two of the same types in the stack
10:13:23 <fr33domlover> Lke quchen mentioned I like the wrap-with-newtype thing for specific cases, like in the program example
10:14:09 <fr33domlover> but when you need a lot of that, mtl is there to get things done quicker
10:14:52 <fr33domlover> (however relatively I'm a Haskell beginner so this is limited advice :P)
10:15:47 <nocturne777> hmm, I think I will stick with transformers for now
10:16:05 <quchen> I think one of the main problems with MTL is that it's hard to make libraries that work together in the MTL sense. If you write your own new transformer along with its class, you need to write instances for all N monads defined by MTL. So far so good. But now someone else writes another library like that. He would have to write N instances for MTL, plus one for your transformer. But now Library1 and Library2 don't define instances
10:16:05 <quchen>  of each other.
10:16:23 <quchen> So MTL isn't very extensible.
10:16:47 <quchen> It's great for using the standard monads though.
10:17:44 <wlad> Kind of OT, but has anyone worked through SICP?
10:27:25 <absence> i have a newtype wrapped Double that derives Storable, but when i make a storable vector with it, the performance is lower than for a vector with Double. anyone know why?
10:28:06 <bergmark> are you using GeneralizedNewtypeDeriving?
10:30:35 <absence> bergmark: yes
10:32:50 <absence> maybe it doesn't work too well with Storable?
10:36:56 <bddy> Hi. (Pseudocode comes next) we can say concat(x:xs, y:ys) = x : concat(xs, y:ys) and that concat([], other) = other. Is it possible to do it with tail recursion and accumulating parameter? We can do it like this: concat(x:xs, y:ys) = concat(xs, x:y:ys) but this will reverse the first list. 
10:37:41 <bddy> of course we can do it like concat(a,b) = concat_helper(reverse(a), b) but maybe it can be done simpler
10:40:46 <fr33domlover> bddy, you can always use tail rec. and an accumulator
10:40:52 <fr33domlover> or you can use CPS
10:41:01 <fr33domlover> i.e. pass a continuation
10:42:57 <bddy> but is it possible to concat two lists with tail recursion and accumulator and without reversing first list at the beginning?
10:51:17 <Gurkenglas> In quadratic time, "f xs ys -> case unsnoc xs of Just (xss, x) of f xss (x + ys); Nothing -> ys", but why?
10:51:33 <Gurkenglas> -++:
10:52:28 <Gurkenglas> *bddy
10:54:01 <bddy> Gurkenglas: Why do you say "in quadratic time" if it's linear, just concats the first list in reverse
10:54:25 <Gurkenglas> > unsnoc "abc" -- bddy
10:54:27 <lambdabot>  Just ("ab",'c')
10:55:14 <bddy> ah, here what unsnoc does, no, I thought there was something linear time
10:56:13 <Gurkenglas> But whyy?
10:58:20 <fr33domlover> anyone ever say these errors? http://paste.rel4tion.org/214
10:58:39 <fr33domlover> I built my package with ghc 7.10.3 (just moved from 7.8.4)
10:58:44 <Gurkenglas> (bddy, how about using difference lists to accumulate on the first parameter?)
10:58:54 <fr33domlover> and suddenly i get this link errors i never saw before
10:59:17 <bddy> Gurkenglas: that would be just incorporating reverse call into third parameter, I guess
11:03:32 <fr33domlover> ah, looks like i solved it: just had to delete the dist/ folder
11:03:43 <fr33domlover> likely had some cache from the 7.8.4 builds
11:04:44 <jesyspa> bddy: http://ideone.com/HISHF5
11:05:10 <jesyspa> bddy: It is, of course, a cheat
11:10:22 <jmcarthur> bddy: What is your goal?
11:11:23 <deni> how do I convert from String (or Text) to Word16? 
11:11:56 <deni> basically I need to create a PortNumber from here: https://hackage.haskell.org/package/network-2.4.1.2/docs/Network-Socket-Internal.html#t:PortNumber
11:11:57 <jmcarthur> deni: You mean you want to convert, for example, ("123" :: String) to (123 :: Word16)?
11:12:26 <deni> jmcarthur: see above link...I want to create a PortNumber but just doing PortNum "25" doesn't really do it
11:12:39 <deni>     Couldn't match expected type ‘GHC.Word.Word16’
11:12:40 <jmcarthur> deni: Ah. Is it that you must convert from a String or just that that is how you are expecting to have to do it?
11:12:41 <deni>                 with actual type ‘T.Text’
11:13:17 <jmcarthur> deni: Are you taking a string as input from somewhere or just trying to create a literal?
11:13:27 <voxr> is there a refreshed alternative to Frame? Frame looking a bit abandon-y
11:13:33 <deni> jmcarthur: a library that I'm using for sending emails... smtp-mail is expeting a PortNumber
11:13:51 <deni> jmcarthur: I'm taking a string with getEnv from the environment
11:14:28 <jmcarthur> deni: To convert from a String I'd probably do something like (fromInteger . read), but I'm a little sad to be using read this way. I just don't know what the preferred method for parsing the number would be.
11:14:46 <jmcarthur> deni: To just write in a literal you can just write the number.
11:15:12 <jmcarthur> deni: Note that neither requires you to use the PortNumber constructor, thanks to some type classes.
11:15:20 <deni> jmcarthur: I can't just hardcode it....it need to be somehow configurable...I though using env vars was the easiest 
11:16:04 <jmcarthur> deni: Well, then I would parse the string as an Integer or something, the way I used read above, and then convert to PortNumber via fromInteger or fromIntegral or something.
11:16:57 <deni> jmcarthur: yeah seems okay to do it that way.... thanks. I wasn't aware that I didn't need the PortNumber constructor
11:17:12 <jmcarthur> deni: Not only do you not need the PortNumber constructor, but using it is deprecated.
11:17:36 <jmcarthur> deni: As documented here: https://hackage.haskell.org/package/network-2.6.2.1/docs/Network-Socket.html#t:PortNumber
11:18:44 <deni> jmcarthur: I don't know what I was looking at but I swear that red text wasn't there before....perhaps I was looking at a way older version
11:19:17 <deni> ah yes the smpt-mail package links to this: https://hackage.haskell.org/package/network-2.4.1.2/docs/Network-Socket-Internal.html#t:PortNumber
11:19:19 <jmcarthur> deni: Yes, you were looking at something older. When you scroll to the top of your link you'll see a link to see the documentation for the latest version.
11:20:16 <deni> jmcarthur: thanks for your help. Just one more thing...can you explain why you said "but I'm a little sad to be using read this way" ?
11:20:38 <deni> I'm sure it has something to do with proper use of types so I'd like to learn
11:22:31 <bddy> jmcarthur: I'm  just playing with c++ templates - and while writing concat utility I understood that forgot how to write tail recursive concat
11:22:55 <rcyr> Yeah... Haskell's the key to C++ template metaprogramming mastery.
11:22:58 <jmcarthur> deni: I normally consider Read to be complementary to Show. I normally consider Show to be just for debugging or playing around in GHCi; Show instances normally generate strings that look like Haskell code. So, I think using Read for parsing in a real program to be an abuse. That doesn't mean it doesn't do what you want in specific cases; it just feels wrong.
11:25:18 * hackagebot diagrams-builder 0.7.2.2 - hint-based build service for the diagrams graphics EDSL.  https://hackage.haskell.org/package/diagrams-builder-0.7.2.2 (BrentYorgey)
11:25:29 <jmcarthur> bddy: I think that if you are going to write a strict, tail recursive version of (++), it's going to have to be two-pass (e.g. with a reversal somewhere). Some methods will obfuscate this fact more than others.
11:26:11 <jmcarthur> bddy: In fact, even a non tail recursive, strict implementation will be two-pass; the reversal just uses data from the stack instead of from the heap.
11:27:01 <exio4> you could use diff lists
11:27:13 <jmcarthur> exio4: There's still an implicit reversal somewhere in there.
11:27:53 <jmcarthur> exio4: If I have an accumulator that I'm snoccing elements onto, then at the end to get the first element I have to push all those elements onto my stack.
11:30:17 <exio4> jmcarthur: do you? 
11:30:33 <bddy> jmcarthur: Yeah, I just did an extra reverse - that worked nice
11:31:32 <exio4> jmcarthur: you build the list in ram, sure, you could say "you have to build it before you can use it" but I don't see how that's meaningful on its own 
11:31:41 <exio4> s/ram/the heap or whatever
11:33:33 <jmcarthur> exio4: No, actually, you don't have to build the list before you can start consuming it. That's one of the nice things about diff lists is that they don't force that on you. What I'm saying is that a diff list is just a chain of closures. If you'd been snoccing to the end repeatedly, the chain is in reverse order. To get the first element from the list, you have to enter each closure until you reach the
11:33:35 <jmcarthur> front. Each of these results in a stack frame. As you consume the rest of the list, you pop a stack frame for each element.
11:35:02 <exio4> jmcarthur: you have to build the whole diff list before using it, though
11:35:23 <pointed_> Hello! Is there any lens combinator that is equivalent to 'flip has'? I'd like to do "object `contains` bla" thing.
11:35:27 <exio4> well, "build" = "go through the first list"
11:35:31 <ph88> anyone know how i can get this derive to work?  http://lpaste.net/388805651091947520
11:36:23 <cocreature> ph88: where is Out coming from?
11:36:26 <jmcarthur> exio4: Yes. I think all you're saying is that the extra pass doesn't affect the asymptotic cost. That's true of the reversal in the plain tail recursive (++) though.
11:36:27 <pointed_> ph88 you should fix the kind mismach
11:36:45 <exio4> alright
11:36:52 <cocreature> nvm found it https://hackage.haskell.org/package/GenericPretty-1.2.1/docs/Text-PrettyPrint-GenericPretty.html#t:Out
11:36:55 <ph88> cocreature, Out is coming from here   https://hackage.haskell.org/package/GenericPretty-1.2.1/docs/Text-PrettyPrint-GenericPretty.html
11:37:02 <ph88> pointed_, yes i know, but i don't know how
11:37:12 <cocreature> ph88: you are trying to derive something for a class instance
11:37:16 <cocreature> that doesn’t make sense
11:37:27 <exio4> this is Haskell though, we can write it naively 
11:37:32 <cocreature> you could just remove Out but I’m not sure if this is what you want to do
11:37:40 <pointed_> ph88 try to 'parseModule' into distinct toplevel decl
11:38:09 <ph88> cocreature, the original goal is to fix the error on line 26-30 if what i do doesn't make sense, perhaps you can propose an alternative solution ?
11:38:42 <ph88> pointed_, i don't understand into distinct toplevel decl
11:38:55 <pointed_> looks like result of parseModule is not Generic and automatic deriver isn't able to do the thing.
11:39:17 <pointed_> add "bla = parseModule str" to the file
11:39:32 <ph88> ok
11:40:33 <pointed_> it won't fix the problem, but you can at least check the type the compiler tries to make Generic
11:41:27 <volhovm> How to force IO function to evaluate lazy? I have foo :: IO a, that generates some kind of object, and I'd like to have `take N $ many foo`, but even `take 0` loop forever
11:42:56 <ph88> pointed_, you mean if i check type of bla in ghci ?
11:43:15 <jmcarthur> volhovm: You might have better luck with  replicateM N foo  . If N is going to be very large, there are yet better ways, though.
11:43:39 <ph88> pointed_, it just says:   bla :: ParseResult HsModule
11:43:58 <jmcarthur> volhovm: I have strategically avoided your actual question.
11:44:09 <jmcarthur> volhovm: Because this is much easier to explain.
11:44:37 <jmcarthur> volhovm: But if it doesn't sufficiently help, just say so, and we can get into the dirty truth.
11:44:56 <volhovm> jmcarthur: the problem is actually these a's should be filtered too, so I'm doing `take N $ filterM_ pred $ many foo`
11:45:22 <jmcarthur> volhovm: Okay, so I can't cheat my way out of this one. :)
11:45:46 <volhovm> Where can I read more about it?
11:45:56 <jmcarthur> volhovm: I mean, I still could, if it's okay to make your code a bit less modular.
11:46:32 <nshepperd> many doesn't work on IO
11:46:57 <nshepperd> there's probably something in monad-loops to do this though
11:47:02 <volhovm> Is the whole idea is so tricky? :| Seems like IO is lazy all the time by default
11:47:15 <volhovm> What's my problem here?
11:47:20 <jmcarthur> volhovm: Ah, IO is not lazy by default.
11:48:05 <volhovm> Ok, still, what can I do?
11:48:32 <volhovm> Writing my own monadic loop will help with this one?
11:48:44 <jmcarthur> volhovm: So, nshepperd's suggestion to look at monad-loops is a good one. There may be a solution there. There's also unsafeInterleaveIO, which would not be my first recommendation, but it can be useful for quick and dirty hacks. There's also variations on ListT; the most popular are pipeline oriented libraries, like pipes and conduit.
11:49:06 <jmcarthur> volhovm: Yeah, or you could just write your own loop instead of using many and filter and take.
11:50:07 <shirt> how do i mapM_ over a Data.Vector.Unboxed but also get the index of each element?
11:50:22 <volhovm> Ok, I got it. What about unsafeInterleaveIO, how to apply it in my case?
11:50:53 <jmcarthur> shirt: If there's no imapM_ sort of thing, you could first zip the vector with a vector from 0 to (len-1).
11:51:13 <aweinstock> > runState 0 (take 10 (replicateM 20 (modify (+1) >> get)))
11:51:15 <lambdabot>      No instance for (Show a0)
11:51:15 <lambdabot>        arising from a use of ‘show_M1448236678285775034587’
11:51:15 <lambdabot>      The type variable ‘a0’ is ambiguous
11:52:56 <aweinstock> > flip runState 0 (sequence $ take 10 (replicate 20 (modify (+1) >> get)))
11:52:57 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10],10)
11:53:16 <aweinstock> volhovm: sequence after filtering/replicating the IO actions, maybe?
11:54:32 <jmcarthur> volhovm: Using the pipes library, you could write something like this:   Pipes.toList (Pipes.repeatM foo >-> Pipes.filter pred >-> Pipes.take n)
11:54:33 <shirt> jmcarthur: thanks, imapM_ is in the latest version of vector package! google search took me to the docs for an older version
11:54:43 <jmcarthur> shirt: Ah, great!
11:55:09 <Welkin> shirt: don't use google
11:55:14 <Welkin> use hoogle or hayoo
11:55:49 <lyxia> volhovm: replicateM n $ iterateUntil pred foo
11:55:59 <nshepperd> volhovm: writing your own loop is the best thing here. the type you want is 'replicateMSuchThat :: (Monad m) => Int -> (a -> Bool) -> m a -> m [a]'
11:56:08 <volhovm> jmcarthur: I'll take a look on pipes, not familiar with it. 
11:56:12 <volhovm> jmcarthur: thanks
11:56:27 <jmcarthur> volhovm: It's a bit of a rabbit hole, so if you are just trying to solve this one problem, I'd just write my own loop.
11:56:37 <nshepperd> oh, lyxia's solution is excellent
11:57:01 <volhovm> lyxia: that looks good indeed, I'll try it now
11:57:36 <nshepperd> instead of filtering, just produce the right value in the first place ^_^
11:58:33 <volhovm> nshepperd: I've got it, yes. But I still don't understand what is the problem with many. How exactly does it spoil the laziness?
11:58:57 <jmcarthur> volhovm: There is no laziness to spoil in the first place. many requires some laziness that IO doesn't have.
11:59:46 <volhovm> Will remember that, thank you
11:59:47 <volhovm> :)
12:02:04 <volhovm> Oh, wait. I've forgotten one more thing. Because of my filter predicate uses MArray, it has type a -> IO Bool, and I don't see appropriate function in monadic-loops
12:03:00 <volhovm> Maybe writing my own loops isn't a bad solution.
12:03:58 <Rembane> volhovm: So it doesn't exist even if you use the signature a -> m Bool?
12:04:09 <Rembane> volhovm: Where m is any monad.
12:04:36 <nshepperd> oh, you need a modified iterateUntil :: Monad m => (a -> m Bool) -> m a -> m a
12:04:48 <nshepperd> huh, wonder why that's not in monad-loops
12:04:49 <volhovm> I've searched through the documentation, didn't find anything
12:06:03 <jmcarthur> This is easy to fix with my pipes version. Just use Pipes.filterM instead of Pipes.filter.
12:08:10 <nshepperd> iterateUntilBetter p m = do { x <- m; bit <- p; if bit then return x else iterateUntilBetter p m }
12:08:40 <volhovm> jmcarthur: BTW, it seems like pipes are somewhat similar to conduit, is it true?
12:08:49 <volhovm> They're both about streaming data and stuff
12:09:06 <volhovm> nshepperd: Yeah, i've already used that solution, though I don't like it at all :|
12:11:43 <jmcarthur> volhovm: Yes, I mentioned them both together earlier.
12:13:30 <hexagoxel> profiling question: has anyone seen (>>=) turn up in profiling with strangely high time/alloc numbers? is this some artefact of lacking SCCs (in libraries?)?
12:13:32 <volhovm> jmcarthur: are there any critical distinctions, if I'm choosing to use one in my project?
12:14:16 <Gurkenglas> :t liftM fromJust . runMaybeT . asum . repeat . MaybeT -- For your iterating needs
12:14:17 <lambdabot> Monad m => m (Maybe r) -> m r
12:15:16 <nshepperd> :O
12:16:17 <Gurkenglas> :t liftM fromJust . runMaybeT . many . MaybeT -- nshepperd, found this one a few days ago!
12:16:18 <lambdabot> Monad m => m (Maybe a) -> m [a]
12:17:45 <lyxia> hexagoxel: I have. not sure where it comes from either
12:18:14 <nshepperd> intriguing. that works for parsers?
12:18:33 <Gurkenglas> Parsers is where many came from originally, it just happens to only require Applicative
12:20:05 <nshepperd> oh wait, this is using the MaybeT Alternative instance?
12:20:17 <nshepperd> I have no idea what that does
12:20:27 <Gurkenglas> *Alternative right
12:20:58 <jmcarthur> volhovm: Most of the distinctions are philosophical in nature. Conduit has more built-in functionality and is intended to be a kind of "useful defaults" and "easy to use" sort of thing. Many of Pipes's features are separate libraries, all built on a simple core; it's intended to be a kind of "simple defaults" and "easy to reason about" sort of thing. The extent to which either library achieves its goals is
12:21:00 <jmcarthur> unclear. I also may have misrepresented something.
12:21:05 <Gurkenglas> It does the same thing the Maybe Alternative instance does, only monadically
12:23:21 <nshepperd> right but what does many do then
12:23:44 <lyxia> probably runs the action until it gets Nothing
12:25:20 * hackagebot transformers-compat 0.5.0.4 - A small compatibility shim exposing the new types from transformers 0.3 and 0.4 to older Haskell platforms.  https://hackage.haskell.org/package/transformers-compat-0.5.0.4 (EdwardKmett)
12:25:22 * hackagebot transformers-compat 0.5.0.2 - A small compatibility shim exposing the new types from transformers 0.3 and 0.4 to older Haskell platforms.  https://hackage.haskell.org/package/transformers-compat-0.5.0.2 (EdwardKmett)
12:25:22 <Gurkenglas> > evalState (liftM fromJust . runMaybeT . many . MaybeT $ state paddeduncons) [1..3] -- nshepperd
12:25:24 * hackagebot transformers-compat 0.5.0.3 - A small compatibility shim exposing the new types from transformers 0.3 and 0.4 to older Haskell platforms.  https://hackage.haskell.org/package/transformers-compat-0.5.0.3 (EdwardKmett)
12:25:25 <lambdabot>  [1,2,3]
12:27:16 <codedmart> puregreen Are you still around by chance?
12:27:21 <puregreen> codedmart: sure
12:28:05 <codedmart> puregreen in your paste, withObject "result"? Is the string representing the data Result a?
12:28:24 <Gurkenglas> Hmm many doesn't seem to be lazy. Why?
12:28:53 <codedmart> As in withObject <- this should be if Result data type?
12:29:23 <puregreen> codedmart: “result” it's only used in error messages – if, for instance, the data being parsed isn't even an object, Aeson will say “expected a result but got an Array” or something
12:29:54 <codedmart> puregreen Awe I see. OK cool, Thanks again!
12:30:27 <puregreen> codedmart: this code is (almost) equivalent to the following (which you can see more often): http://lpaste.net/149805
12:31:11 <codedmart> puregreen Oh ok that looks more familiar. Great to know. I really appreciate it.
12:44:06 <Darwin226> So let's say I have an MVector of MVector. How do I actually mutate a value in one of the inner vectors?
12:44:33 <benzrf> Darwin226: do you mean mutate one of the inner vectors?
12:44:55 <Darwin226> benzrf: Sure. Is there a semantical difference to what I've said?
12:45:02 <benzrf> i'd say so
12:45:19 <benzrf> if you have [[a, b, c], [d, e, f]], then "mutating a value in one of the inner vectors" would mean mutating a or c
12:45:20 * hackagebot distributive 0.5 - Distributive functors -- Dual to Traversable  https://hackage.haskell.org/package/distributive-0.5 (EdwardKmett)
12:45:28 <Darwin226> benzrf: Yeah, ok. You're right.
12:45:29 <benzrf> as opposed to, say, replacing a with x
12:45:48 <Darwin226> benzrf: Anyways, how do I mutate the inner vector? Seems there's no modifyM in the Data.Vector.Mutable module
12:46:09 <benzrf> i dont know much about mvectors =p
12:47:50 <monochrom> similar to java. from the outer vector, read the desired inner vector. upon that inner vector, read or write a cell.
12:48:27 <Darwin226> monochrom: Right, right, right... Don't know why I was thinking it's more complex than that
12:50:41 * hackagebot kan-extensions 5 - Kan extensions, Kan lifts, various forms of the Yoneda lemma, and (co)density (co)monads  https://hackage.haskell.org/package/kan-extensions-5 (EdwardKmett)
12:56:14 <umayahabdennabi> What is the best way to handle video upload.  I want a user to be able to upload a video to  my server via haskell
13:20:42 * hackagebot exceptions 0.8.2.1 - Extensible optionally-pure exceptions  https://hackage.haskell.org/package/exceptions-0.8.2.1 (EdwardKmett)
13:35:26 <jophish> edwardk: How is the layout parser in trifecta these days? It seemed to go through a rough patch a while ago, but the last I heard you were working on it. http://stackoverflow.com/questions/12372150/using-trifectas-layout-parser
13:35:40 <edwardk> jophish: i haven't touched it in a long time
13:35:54 <jophish> ah ok, I notice it's been removed in recent versions of trifecta
13:36:36 <edwardk> michael adams at u. utah sent me a replacement at one point but it was a bit different and i didnt have a time to coordinate how to massage it into a form i'd like
13:37:09 <edwardk> i need to port the fixes to the one i have from the scala ermine implementation or incorporate something like michael adams
13:38:43 <jophish> ah ok. I'm guessing that there's no near term roadmap for those changes though
13:42:31 <jophish> edwardk: is modifying the token stream to insert virtual semicolons and braces something that can be done with trifecta? The idris developers seemed to think not two years ago, but things might have changed since then: https://github.com/idris-lang/Idris-dev/issues/729
13:43:16 <edwardk> the way i do it isn't quite the same. you modify the whitespace parser and use a slightly different layout combinator
13:43:32 <edwardk> with that you can get indentation in trifecta, but it requires a parser transformer
13:44:00 <jophish> Is there a neat example of this somewhere in ermine you could point me to?
13:45:55 <edwardk> the scala ermine code gets it correct but ugly
13:46:06 <edwardk> i had a prettier version i started in haskell
13:46:15 <edwardk> but i'm not sure if its in a branch or bitrotted or on my old machine
13:47:45 <jophish> ok, I might try and puzzle things out then. Thanks
13:55:43 * hackagebot comonad 4.3 - Comonads  https://hackage.haskell.org/package/comonad-4.3 (EdwardKmett)
13:55:45 * hackagebot set-cover 0.0.5.1 - Solve exact set cover problems like Sudoku, 8 Queens, Soma Cube, Tetris Cube  https://hackage.haskell.org/package/set-cover-0.0.5.1 (HenningThielemann)
14:00:43 * hackagebot contravariant 1.4 - Contravariant functors  https://hackage.haskell.org/package/contravariant-1.4 (EdwardKmett)
14:01:07 * bergmark is trying to add stackage upper bounds faster than edwardk releases packages
14:08:17 <edwardk> bergmark good luck
14:08:20 <edwardk> it'll be a long night for you
14:10:43 * hackagebot semigroupoids 5.0.1 - Semigroupoids: Category sans id  https://hackage.haskell.org/package/semigroupoids-5.0.1 (EdwardKmett)
14:11:03 <bergmark> :-)
14:11:18 <bergmark> the bottleneck is clearly the hackage CDN
14:11:27 <edwardk> it is
14:12:28 <edwardk> trying to get my big in-flight changes to bifunctors merged and releaseable or i can't finish the hierarchy of all this stuff
14:13:59 <puregreen> I've got bindings to some API and I have a method like “getNewEvents :: IO [Event]”; I want to provide a “setHandler :: (Event -> IO ()) -> IO ()” method to my users. What's the preferred way to do it? (In particular, would simply running a separate thread with forkIO be an acceptable solution, or is there something better?)
14:15:44 * hackagebot errors 2.1.1 - Simplified error-handling  https://hackage.haskell.org/package/errors-2.1.1 (GabrielGonzalez)
14:16:00 <puregreen> I haven't ever implemented any API bindings before so I'm wondering what the state of the art is.
14:17:11 <dmj`> puregreen: is this an http api?
14:17:24 <puregreen> dmj`: yep
14:17:31 <dmj`> @package servant-client
14:17:31 <lambdabot> http://hackage.haskell.org/package/servant-client
14:17:40 <dmj`> state of the art right there
14:18:38 <dmj`> puregreen: run `cabal unpack google-translate` for some example usage
14:18:50 <dmj`> puregreen: is this a json API?
14:20:22 <puregreen> dmj`: yep
14:20:33 <puregreen> I'm looking at servant-client right now and I don't see anything about handlers there, tho
14:20:42 <danilo2> Hello guys! I'm fighting against very long compilation times in GHC. I would love to ask you what I'm doing wrong. In the file A.hs I've got a typeclass Foo with method foo. When I create a function foo_cache = foo and give it explicit type signature, the file compiles long (it should compile long, becasuue the tpye computations inside are complex) and when I use foo_cache in file B.hs it compiles very fast. But when I use foo inste
14:21:14 <geekosaur> chopped at "use foo inste"
14:21:26 <geekosaur> remember IRC has a short message size liit
14:21:29 <geekosaur> *limit
14:21:33 <dmj`> puregreen: you model the API w/ types, and then it gets reified as 'handlers'.
14:21:35 <danilo2> it compiles again very long. Why GHC doesnt remember somehow that I used exactly these types already and do not uses cached resolved typeclass ? Specialize pragma does not change anything. Is this a bug or am I missing something from GHC behavior ?
14:22:03 <danilo2> geekosaur: ouch - the rest was "But when I use foo instead of foo_cache in file B.hs " and my second message
14:22:35 <dmj`> puregreen: where 'handlers' = functions that submit http requests and return json (i.e. (ToJSON b, FromJSON a) => b -> EitherT ServantErr IO a)
14:23:03 <puregreen> dmj`: sorry, I guess I wasn't clear enough
14:23:18 <puregreen> I already have a function that submits a request and returns JSON
14:23:23 <danilo2> geekosaur: to sum this up - when I manually specialize function it compiles fast in other modules. But if I use just the typeclass function name with rguments of types already used in other files it compiles as long as in those other files
14:23:28 <geekosaur> I don;t think it "cahces" the way you think
14:23:34 <geekosaur> *caches
14:23:58 <puregreen> I want a function that would let me turn *that* into a handler that would submit the request endlessly and handle all new results
14:24:06 <geekosaur> if you define foo_cache, which is not a typeclass method, information about it goes into A.hi and can be used directly in B.hs
14:24:29 <danilo2> geekosaur: Ok, so is there any way to tell GHC - just specialize this "foo" for signature " foo :: Int -> Int" ? I've tried specialize pragma, but as I said, it doesnt change anything unless I create foo' :: Int -> Int; foo' = foo
14:24:30 <geekosaur> if you use the typeclass method directly then it has to go through the whole derivation
14:24:37 <dmj`> puregreen: you can turn it into a producer w/ pipes/conduits
14:24:59 <geekosaur> that I don't know offhand
14:25:04 <danilo2> geekosaur: yep, but can I achive this without declaring ton of such manually cached methods?
14:25:23 <voxr> anyone use the Frames library?
14:25:44 * hackagebot comonad 5 - Comonads  https://hackage.haskell.org/package/comonad-5 (EdwardKmett)
14:26:07 <dmj`> puregreen: or, you could create a Chan where one thread writes to it in a loop, and a second thread blocks on the read end and handles all new incoming messages
14:27:32 <geekosaur> hm. so in looking at the ghc manual re SPECIALIZE, I'm not sure it would ever be applicable to a method. The specialization would be instance selection, and that is likely where your problem is
14:28:23 <geekosaur> (thatis, where the slowdown occurs is in resolving the instance it needs)
14:29:05 <geekosaur> however you'd probably needs to ask someone better knowledgeable about ghc internals --- except they're busy whacking bugs in ghc8.1rc
14:30:26 <danilo2> geekosaur: but as I stated above, foo is a typeclass method, so specialize pragma should work as expected. Do I missinterpret it somehow?
14:30:41 <geekosaur> I guess I was not clear there
14:30:44 * hackagebot bifunctors 5.2 - Bifunctors  https://hackage.haskell.org/package/bifunctors-5.2 (EdwardKmett)
14:30:52 <geekosaur> I cannot see SPECIALIZE applying to a typeclass method
14:31:18 <geekosaur> the reason is that *selecting a typeclass instance* is specialization
14:32:23 <catern> dear #haskell, do you know of a function with type (a,b) -> (a,c) that takes a long time to compute? a function that you might pass to something with type ((a,b) -> (a,c)) -> ([b], a) -> [c]?
14:33:14 <danilo2> geekosaur: hmm, If I understand that correctly - it should solve the problem. So when I compile the A.hs, it compiles lets say 8s, because it looks for instance of the right instance of Foo, whoch looks for right instance of other typeclass and so on - and the type deps are so complex it takes time. So If I say "secialize the usage of foo to Int -> Int" it should "cache" which isntances to use, isnt it?
14:33:26 <geekosaur> no
14:33:39 <geekosaur> because it can't select that specialized version until it has computed which instance to use
14:33:54 <geekosaur> and it sounds like computing that instance is what's costing you
14:34:04 <geekosaur> which is why you can have one outside the typeclass and it's fast
14:35:31 <geekosaur> well, something like that. instance selection is somewhat complex and can have both compile time and run time complexity (it will try to do it at compile time if it can prove that it's safe; dunno how much *that* costs)
14:36:11 <geekosaur> but resolving the types, *in a typeclass method*, is different from in a standalone function, because much of it depends on which instance is selected
14:36:25 <geekosaur> andbecause that selection may need to happen at runtime, things are more complex
14:37:09 <geekosaur> for the standalone one (a) it's all compile time (b) you can tell it to specialize the implementation
14:37:17 <danilo2> geekosaur: hmm, I'm sorry, I dont get it. Maybe I'm just blind here. I don't want to take your time, but I would be very thankful if you clarify that a little bit more. lets say I've got class Foo a b | a -> b where foo :: a -> b. and a lot of overlapping isntances like instance {-# OVERLAPPABLE #-} Bar (X a b) => a b Foo a b where foo = bar (Proxy :: Proxy (X a b)) and so on. The time neededd for compilation is used mainly by TF re
14:37:34 <geekosaur> "manly by TF re"
14:37:37 <geekosaur> *mainly
14:37:48 <danilo2> geekosaur: So If GHC knows that it compiels foo :: Int -> Int it HAS to resolve all the TF's to see if the types match, so it has to resolve all the TF's and select instances
14:37:49 <geekosaur> I'm not entirely clear on what you are trying to specialize, though
14:37:56 <danilo2> "mainly by TF resolution like X a b"
14:38:21 <geekosaur> if you try to specialize in the "class" declaration, it wouldn't do anything; the way you specialize that is by selecting an instance
14:38:25 <danilo2> I'm trying to specialize foo: {-# SPECIALIZE foo :: Int -> Int #-}
14:38:55 <danilo2> I'm not trying to specialize IN the clas declaration - I'm using the specialize pragam in top-level of the module
14:38:56 <geekosaur> afaik if you try to specialize the definition in the instance, something similar happens: it's already as specialized as it can get because it was selected
14:39:32 <geekosaur> also note the way SPECIALIZE is implemented: it's a rewrite rule
14:39:35 <codedmart> I am not sure what is going on here: https://gist.github.com/codedmart/522d140c5c815288f1ea#file-main-hs-L9-L16
14:39:45 <geekosaur> you can't apply a rewrite rule to the dictionary of instances
14:39:51 <codedmart> I am trying to use Aeson Lens
14:40:30 <glguy> codedmart: you forgot the . between 0 and key
14:40:57 <danilo2> geekosaur: oh, heh I didnt know it. Anyway If I understand correctly - If I have a typeclass like class TC a where tc :: a -> String and I use somewhere method "tc" provided with Int, Haskell doesnt cache anywhere the resolution, so when I use "tc" with Int somewhere else it has to recompute everything to search for right instance?
14:41:04 <glguy> and then you'll need to use ^? instead of ^.
14:41:18 <ytuyr> does haskell memoize function calls
14:41:33 <glguy> that'll return a Maybe Value instead of a Value
14:41:43 <ytuyr> say, if I have "f 1" twice, will it compute it twice or just once?
14:41:56 <glguy> ytuyr: generally twice
14:42:38 <geekosaur> danilo2, pretty sure it does not cache at all beyond stuff in the .hi file. but also suspect the problem is in a different place here.
14:42:49 <Ferdirand> if it did it would be hard to prevent some space leaks, i believe
14:42:55 <geekosaur> but you proabbly need to ask ghc devs who know about the typechecker, and they;'re kinda busy right now
14:43:10 <Ferdirand> but you can ensure sharing by using a let binding on the common subexpression
14:43:20 <geekosaur> (I do find myself wondering if caching could be added, and how hard it would be; I suspect "pretty hard" though)
14:43:53 <geekosaur> ytuyr, automatic memoization tends to waste a lot of memory to no purpose
14:44:39 <geekosaur> so you need to use something like let-binding to tell the compiler where memoization makes sense
14:44:56 <danilo2> geekosaur: ok, thank you very mych for all your help! I'll try to speak with them :)
14:45:10 <Pamelloes> Is there a function that's a combination of foldr and filter? I need to filter a list and compute a value based off every value within the lasts. The two functions are intimately related so it seems a shame not to be able to do them at the same time.
14:45:52 * hackagebot set-cover 0.0.6 - Solve exact set cover problems like Sudoku, 8 Queens, Soma Cube, Tetris Cube  https://hackage.haskell.org/package/set-cover-0.0.6 (HenningThielemann)
14:48:21 <edwardk> Pamelloes: fwiw- foldr f z . filter p -- isn't as inefficient as it might seem
14:49:57 <mauke> Pamelloes: filter is a foldr, so the combination would just be foldr
14:50:48 <glguy> foldr f z . filter p  fuses (at least verified in GHC 7.10.3)
14:51:13 <Pamelloes> Huh. That's pretty cool.
14:51:42 <codedmart> glguy Thanks! That led me to this? https://gist.github.com/codedmart/522d140c5c815288f1ea#file-main-hs-L9-L18
14:52:05 <glguy> codedmart: Drop the _Array
14:52:30 <codedmart> glguy Sweet thanks!
14:52:43 <mauke> :t \p -> foldr (\x z -> if p x then x : z else z) []
14:52:44 <lambdabot> Foldable t => (a -> Bool) -> t a -> [a]
14:56:08 <ytuyr> Do lenses provide a better way to call the constructor too? Passing everything in one line is prone to errors if you have parameters of the same type, and explicitely using accessors with underscores is kinda ugly
14:56:24 <ytuyr> like here, for instance https://github.com/ekmett/lens/blob/master/examples/Pong.hs#L64
14:57:31 <ytuyr> What if you use lenses and need to construct an initial state with nested structure?
14:59:28 <ytuyr> geekosaur: is there anything good to read on when automatic memoization works and when not?
15:00:52 * hackagebot distributive 0.5.0.1 - Distributive functors -- Dual to Traversable  https://hackage.haskell.org/package/distributive-0.5.0.1 (EdwardKmett)
15:01:27 <geekosaur> ytuyr, there's some discussion here http://stackoverflow.com/questions/3951012/when-is-memoization-automatic-in-ghc-haskell
15:02:07 <ytuyr> geekosaur: will read. Thank you!
15:02:37 <glguy> ytuyr: You just construct it normally
15:04:28 <ytuyr> glguy: normally as in "atom = Atom { _element = "C", _point = Point { _x = 1.0, _y = 2.0 } }" ?
15:06:05 <ph88> anyone know how i can get this derive to work?  http://lpaste.net/388805651091947520
15:06:05 * hackagebot profunctors 5.2 - Profunctors  https://hackage.haskell.org/package/profunctors-5.2 (EdwardKmett)
15:07:45 <ytuyr> glguy: it seems like there is a certain tradeoff, where lenses make constructing code less nice after you add underscores for lenses
15:08:27 <ytuyr> glguy: so, I was wondering, maybe there is something to avoid this
15:10:28 <glguy> You just have underscores. The alternative is that you use an alternate lens naming rule instead of the standard underscore one
15:12:17 <ytuyr> okay
15:41:06 * hackagebot foldl 1.1.3 - Composable, streaming, and efficient left folds  https://hackage.haskell.org/package/foldl-1.1.3 (GabrielGonzalez)
15:46:06 * hackagebot MonadRandom 0.4.2.1 - Random-number generation monad.  https://hackage.haskell.org/package/MonadRandom-0.4.2.1 (BrentYorgey)
15:48:04 <statusfailed> Is there a way to get a GHC.TypeLits.Symbol as an argument to a type alias? I want to do this with servant: "type Foo sym a = sym :> GET '[JSON] a" 
15:48:53 <platz> if there a way to tell stack some kind of shorthand for common operations like "stack exec my-project"
15:49:41 <platz> or do people use Makefiles and put "stack exec my-project" in that?
15:56:07 * hackagebot luminance 0.9.1.2 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.9.1.2 (DimitriSabadie)
16:05:11 <pamplemousse> exit
16:11:07 * hackagebot distributive 0.5.0.2 - Distributive functors -- Dual to Traversable  https://hackage.haskell.org/package/distributive-0.5.0.2 (EdwardKmett)
16:11:09 * hackagebot luminance-samples 0.9.1 - Luminance samples  https://hackage.haskell.org/package/luminance-samples-0.9.1 (DimitriSabadie)
16:16:07 * hackagebot tellbot 0.6.0.11 - IRC tellbot  https://hackage.haskell.org/package/tellbot-0.6.0.11 (DimitriSabadie)
16:16:21 <thomasd> hey guys, quick question. Can "Unit" be thought of as a literal? Or are literals simply instances of a particular primitive type. 
16:16:57 <codedmart> How do you do gaurds with an anonymouse function>?
16:17:23 <thomasd> e.g. 6 is an integer literal because it is a value that is an instance of the integer primitive type
16:17:40 <geekosaur> codedmart, you use case
16:17:56 <thomasd> but since there is only a single instance of the Unit type, Unit can't really be considered a literal
16:18:47 <codedmart> geekosaur Hmm... is there a simple example?
16:18:57 <thomasd> (\
16:19:26 <thomasd> (\x -> case x of ... )
16:19:31 <thomasd> @codedmart
16:19:31 <lambdabot> Unknown command, try @list
16:19:42 <geekosaur> \x -> case () of () | x > 5 -> ... | otherwise -> ...
16:19:46 <codedmart> thomasd Duh :| Thanks!
16:19:59 <geekosaur> if you also want pattern mathcing then you could use x in the case; it's kinda pointless otherwise
16:20:46 <geekosaur> remember that patterns and guards turn into case; you have to do it manually for lambdas
16:23:39 <geekosaur> (you can compile something with -ddump-ds to see what various things desugar to)
16:24:02 <nitrix> Is it possible to have a lambda call itself?
16:24:24 <geekosaur> only if you're clever; this is what fix is generally used for in real programs
16:24:41 <nitrix> It's very convenient that it can borrow the environment, but I need a recursive function. Otherwise, I have to name it and pass a whooole bunch of things explicitly.
16:25:36 <geekosaur> also consider something like worker-wrapper where you have an outer part that takes parameters and an inner part that can use the ones passed to the outer part
16:26:01 <nitrix> geekosaur: Is this directed to me?
16:26:38 <geekosaur> f x y z w = go <thing to recurse on> where go a = ...
16:26:40 <geekosaur> yes
16:26:43 <nitrix> :t fix
16:26:44 <lambdabot> (a -> a) -> a
16:26:53 <nitrix> Mhhh, not very explanatory.
16:27:10 <geekosaur> go can use x, y, z, and w but only needs the thing you recurse on as an actual paramter. go is the worker, f is the wrapper
16:28:06 <geekosaur> there's something in the haskell wiki about using fix. the idea is you pass the lambda to fix, and it repeatedly applies the lambda to its own output until it converges (or diverges)
16:29:04 <geekosaur> so you get "recursion" without having to name the lambda
16:36:18 * hackagebot concurrent-supply 0.1.8 - A fast concurrent unique identifier supply with a pure API  https://hackage.haskell.org/package/concurrent-supply-0.1.8 (EdwardKmett)
16:36:20 * hackagebot free 4.12.3 - Monads for free  https://hackage.haskell.org/package/free-4.12.3 (EdwardKmett)
16:36:22 * hackagebot StateVar 1.1.0.3 - State variables  https://hackage.haskell.org/package/StateVar-1.1.0.3 (EdwardKmett)
16:36:33 <edwardk> codedmart: with newer GHCs you can also use MultiWayIf
16:36:44 <edwardk> if | x <= 12 -> ...     etc
16:36:50 <codedmart> edwardk Thanks I did see that :)
16:37:43 <codedmart> I am just toying with different syntaxes and such. Whenever I feel reasonably comfortable in Haskell I hit a wall again.
16:38:22 <codedmart> Man lens are cool though.
16:41:24 * hackagebot half 0.2.2.3 - Half-precision floating-point  https://hackage.haskell.org/package/half-0.2.2.3 (EdwardKmett)
16:41:27 <edwardk> lenses are a bit of a double edged sword. you can do a lot with them but the type errors are god awful
16:42:03 <edwardk> so you really need to be comfortable in your own ability to reason through where you made a typo without recourse to the error message you get from GHC
16:55:23 <platz> lenses themselves are quite simple but I frequently get confused about how different combinators work  "each" vs "toListOf . each" vs "traversed" 
17:01:19 <danilo2> Hello guys! Can I ask GHC to write me all the rewrite rules generated out of specialized pragmas?
17:11:41 * hackagebot gl 0.7.8 - Complete OpenGL raw bindings  https://hackage.haskell.org/package/gl-0.7.8 (EdwardKmett)
17:12:13 <geekosaur> -ddump-spec?
17:13:56 <danilo2> geekosaur: oh, thanks!
17:14:40 <danilo2> geekosaur: by the way, we were talking today about specialize pragma. I've done just a small example, that shows the problem. In fact in this minimal example we can see that specialize pragma just does not work (unles I really dont get something): http://lpaste.net/149819
17:16:01 <danilo2> geekosaur: If you've got a minute and want to look at it, I would be very happy and thankful! :)
17:17:19 <geekosaur> somewhere you seem to have picked up the idea that I'm a ghc guru. I know a few things, but ...
17:19:58 <danilo2> geekosaur: no, I was just talking with you several times and you have replied to my questions sometimes. Also sometimes it is just easier to think about problems when you aren ot alone. The perfect answer you can give me is that you just dont have any time now, dont want to bother with it or just dont know how to solve it. (You've told me I should speak with GHC devs, but I sometimes like to ask folks here, because on the ghc 
17:20:06 <danilo2> channel is hard to grasp anybody nowadays) :)
17:20:11 <danilo2> geekosaur: :)
17:22:15 <mpickering> danilo2: tbh, I don't think anyone knows the answers to your questions
17:22:27 <jakeehrlich> So I managed to write a program that is very slow in ghci. I knew this program would VERY slow so that is not the issue. Eventully small inputs return results, say after a minute or two. However after I I see the result ghci starts running VERY VERY VERY slugishlly. It starts taking many many second to display characters that I have typed. Additionally it appears that my CPU useage from ghci spikes only when characters are being typed
17:22:28 <jakeehrlich> What on earth is happening?
17:22:35 <geekosaur> mostly what I'm saying is that I can gie some general answers, but specifics need to go to someone who knows ghc internals
17:22:57 <mpickering> You might be better getting one of your team to work on ghc some of the time to figure it out
17:22:59 <geekosaur> jakeehrlich, did you spawn any threads?
17:23:21 <geekosaur> if you did, they keep running when the prompt comes back
17:23:22 <jakeehrlich> geekosaur: no and I did nothing funny with strictness. I’ll post the whole program if you’d like
17:23:40 <geekosaur> othrwise, ... what ghc version? I think someone pointed out a bug recently
17:23:41 <jakeehrlich> it is big right now because I havn’t narrowed down the issue
17:23:50 <jakeehrlich> ghc version 7.10 using stack
17:26:37 <danilo2> mpickering: :D
17:26:48 <jakeehrlich> http://lpaste.net/149822
17:27:42 <jakeehrlich> if you run “(3.6 :: BishopReal[]) * 3.6 * 3.6 * 3.6” in ghci it causes some serious issues
17:28:29 <jakeehrlich> it will take about 2 minutes to compute and then ghci will just stop being functional
17:30:58 <jakeehrlich> oh and if you are wanting some context for the code: this is a nearly direct translation of Bishop’s constructive analysis
17:31:09 <jakeehrlich> not that that really matters
17:33:18 <kadoban> jakeehrlich: Does it ever speed back up? That could be behavior you'd maybe see if you did something like consume all available RAM and stuff starts thrashing pretty badly, that can take a bit of time to clear itself up and for programs to behave normally. Or is it only ghci that's slow?
17:34:00 <jakeehrlich> ghci is what is slow. The result of my computation comes back and then ghci becomes very very slugish
17:34:54 <dedgrant_> jakeehrlich: How much memory is ghci taking at the end of this computation?
17:35:05 <jakeehrlich> let me check
17:37:06 <jakeehrlich> haha SOOOO much. it used up almost all avliables non-virtual memory. for some reason it didn’t go into virtual memory
17:37:46 <jakeehrlich> to be exact ghci used 10.59 GB and is holding on to it
17:38:03 <dedgrant_> jakeehrlich: Well that probably explains your sluggishness :)
17:38:25 <dedgrant_> I wonder what it is hanging onto?
17:38:32 <jakeehrlich> well there is “it”
17:39:02 <jakeehrlich> but I typed in “3” and pressed enter so now “it” is “3 :: Integer” so it has no reason to hold on to the memeory as far as I can tell
17:42:42 <dedgrant_> jakeehrlich: That's quite surprising to me. I'd have to defer to somneone more familiar with the inner workings.. maybe on #ghc?
17:42:58 <dedgrant_> Which version of ghc are you on?
17:43:05 <jakeehrlich> 7.10.2
17:43:11 <MarcelineVQ> I'd suspect the genericIndex usage
17:44:54 <dedgrant_> Allocating a rather large integer and not releasing it?
17:45:36 <dedgrant_> I'm not sure I see how ..
17:45:37 <jakeehrlich> so this is most certinally a list centric issue because if I use functions instead of lists to perform the same computation it all works fine
17:45:38 <asfdk> question - I want to add my own elisp functionality to haskell mode how do i get the process or buffer name of the interactive haskell window associated with the active source file buffer?
17:47:13 <dedgrant_> jakeehrlich: I wonder if ghci lets you profile the call sites for allocations 8-)
17:54:58 <dedgrant_> at ghci prompt, ':show bindings'. I doid not know I could do this thing. https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/ghci-commands.html
18:01:43 * hackagebot prelude-extras 0.4.0.3 - Higher order versions of Prelude classes  https://hackage.haskell.org/package/prelude-extras-0.4.0.3 (EdwardKmett)
18:02:47 <jakeehrlich> yea “it” is the only binding and I can overwrite it and still nothing
18:11:45 * hackagebot constraints 0.8 - Constraint manipulation  https://hackage.haskell.org/package/constraints-0.8 (EdwardKmett)
18:16:45 * hackagebot free 4.12.4 - Monads for free  https://hackage.haskell.org/package/free-4.12.4 (EdwardKmett)
18:24:22 <srhb> jakeehrlich: Can't reproduce on 7.10.2
18:25:06 <srhb> jakeehrlich: Looks like things get cleared properly once the number is returned. :)
18:26:02 <srhb> Scary memory usage though. :P
18:26:46 * hackagebot adjunctions 4.3 - Adjunctions and representable functors  https://hackage.haskell.org/package/adjunctions-4.3 (EdwardKmett)
18:30:02 <srhb> jakeehrlich: How big is the type itself I wonder?
18:31:46 * hackagebot transformers 0.5.0.1 - Concrete functor and monad transformers  https://hackage.haskell.org/package/transformers-0.5.0.1 (RossPaterson)
18:36:47 * hackagebot keys 3.11 - Keyed functors and containers  https://hackage.haskell.org/package/keys-3.11 (EdwardKmett)
18:36:49 <jakeehrlich> the type itself? also it may be because I am using stack as well
18:36:49 * hackagebot kan-extensions 5.0.1 - Kan extensions, Kan lifts, various forms of the Yoneda lemma, and (co)density (co)monads  https://hackage.haskell.org/package/kan-extensions-5.0.1 (EdwardKmett)
18:38:23 <jakeehrlich> srhb: what do you mean by the size of the type?
18:38:41 <jakeehrlich> BishopReal [] should just be the size of a list
18:39:06 <srhb> jakeehrlich: Nevermind me, I skimmed the example wrong. Yeah, indeed.
18:41:31 <jakeehrlich> so after some further inspection my system appears to be flinging off other instances of ghc
18:41:42 <jakeehrlich> how the heck…
18:41:58 * hackagebot pointed 5 - Pointed and copointed data  https://hackage.haskell.org/package/pointed-5 (EdwardKmett)
18:43:47 <srhb> jakeehrlich: Interestingly, I can reproduce it in ghci by running it again and again, and performMajorGC doesn't get rid of it, but if I do the same in a compiled and optimized version, there is no problem.
18:44:10 <jakeehrlich> this is uite strange
18:44:11 <srhb> Some reference must be lingering, as others suggested.
18:44:59 <jakeehrlich> I was thinking about it too and I don’t really see why there should be this much memory
18:45:25 <srhb> I can't even begin to fathom the consequences of using Ratio in that way..
18:46:58 * hackagebot transformers 0.5.0.2 - Concrete functor and monad transformers  https://hackage.haskell.org/package/transformers-0.5.0.2 (RossPaterson)
18:50:06 <srhb> I think it's somehow getting too large for the GC to actually handle it without being killed.
18:50:16 <srhb> Suggesting that it needs to do some copying, perhaps.
18:51:09 <jgornick> Hey folks, if I have a list of a type that has a name and rank field, how could I filter the list to remove duplicates where the rank is < the maximum with the same name?
18:51:59 * hackagebot mmorph 1.0.5 - Monad morphisms  https://hackage.haskell.org/package/mmorph-1.0.5 (GabrielGonzalez)
18:52:23 <dzdncnfzd> I've been using the Either monad for error handling, and now I need to go to a monad transformer stack. What's the natural thing to use?
18:52:50 <dzdncnfzd> I see that EitherT isn't in mtl or Transformers
18:53:04 <srhb> dzdncnfzd: PErhaps you want ExceptT
18:53:04 <dzdncnfzd> *Control.Monad.Trans
18:53:31 <kadoban> jgornick: Throw them in a Data.Map or something keyed by the name, and on duplicate keep the one with the better rank?
18:55:09 <dzdncnfzd> srhb: is there any substantive difference between that and Either?
18:55:30 <dzdncnfzd> I'm trying to figure out why there's no EitherT -- whether it's historical accident or something deeper Im' missing
18:56:09 <srhb> dzdncnfzd: You can go mailing list spelunking. I don't actually remember what the reason was. Hysterical, mostly, I think.
18:56:34 <dmj`> dzdncnfzd: ExceptT is equivalent. 
18:56:38 <dzdncnfzd> srhb: haha -- alright, thanks
18:57:02 <srhb> dzdncnfzd: https://mail.haskell.org/pipermail/libraries/2013-August/020565.html -- hours of fun! :-)
19:10:32 <dzdncnfzd> srhb: Wow. I didn't believe you when you said "Hysterical, mostly"
19:11:01 <srhb> dzdncnfzd: It was more or less only a play on the typical "hysterical raisins" ~ "historical reasons"
19:12:00 * hackagebot graphs 0.7 - A simple monadic graph library  https://hackage.haskell.org/package/graphs-0.7 (EdwardKmett)
19:13:02 <edwardk> dzdncnfzd: short version. i wrote EitherT in my either package, ross backported it to transformers but bikeshedded the name/api enough that it was painful for many users to switch
19:13:09 <edwardk> and before transformers-compat it was hard for folks to adopt
19:13:29 <edwardk> now its probably easier to use transformers + transformers-compat and use ExceptT and my either package's EitherT can probably die
19:14:42 <dzdcnfzd> edwardk: When you say "bikeshedding" you mean "putting in the bikeshed and forgetting about"
19:15:06 * kadoban is still using ErrorT because I haven't looked into if changing to ExceptT would change the meaning of my code
19:15:18 <edwardk> dzdcnfzd: bikeshedding is an old analogy for arguing about the color of the bikeshed next to the nuclear reactor
19:15:34 <edwardk> people tend to sit down and shut up when folks talk about the inner workings of the reactor
19:15:40 <edwardk> lest they sound ignorant
19:15:52 <asfdk> wrote my first elisp function to pass current line trimming indentation to the ghci repl in emacs. small victory but this should be a good productivity bump for playing with monadic code blocks interactively...
19:15:55 <dzdcnfzd> This is beautiful!
19:16:04 <edwardk> but when it comes to the color of the bikeshed outside? well after that long reactor discussion by gods will they take the time to be heard now!
19:16:16 <dzdcnfzd> Yes. Oh jeez yes. 
19:16:44 <dzdcnfzd> Okay. That's not what I would have expected but that is a very nice, common analogy
19:16:56 <dzdcnfzd> *analogy for a common experience, I mean
19:17:07 <edwardk> it basically has to do with all the sort of fiddly 'it doesn't really matter' changes people like to make
19:18:01 <dzdcnfzd> "You misnamed your counter variable"
19:18:06 <dzdcnfzd> sort of deals
19:18:37 <edwardk> well, there one can make a correctness argumment
19:18:57 <edwardk> but 'hey should we curry this function or not?'
19:19:30 <edwardk> use ExistentialQuantification or GADT syntax for that definition
19:19:43 <edwardk> maybe we should use a newtype around Either rather than make our own sum type...
19:20:46 <edwardk> or "let's make 140+ reverse dependencies on the either package completely rewrite their code because someone would rather EitherT be named ExceptT" http://packdeps.haskellers.com/reverse/either
19:20:57 <edwardk> vs. just copying the module over as is
19:21:21 <dzdcnfzd> I'm just frustrated because I'm working with aeson 
19:21:33 <dmj`> edwardk: don't mean to kick a dead horse, but what was the justification for not just calling it EitherT in transformers?
19:21:34 <dzdcnfzd> and aeson has a decodeEither function which I've been using everywhere
19:22:12 <edwardk> dmj`: Ross made the call since it is his package but the general idea was that we now have State s = StateT s IdentityT, etc.
19:22:20 <edwardk> but Maybe isn't MaybeT Identity
19:22:30 <dzdcnfzd> and now I have to change some stuff to use transformers (for the first time! wish me luck!) and it's going to be pretty unclear why half my code uses EIther and the other half uses ExceptT
19:22:30 <edwardk> so the MaybeT transformer bucks the trend
19:22:37 <edwardk> and he didn't want to perpetuate that
19:23:02 <edwardk> as it was Error e wasn't ErrorT e Identity -- it was the class of stuff that was used by the ErrorT class
19:23:10 <edwardk> and that i think really bugged him
19:23:22 <edwardk> so i think he hyper-corrected a bit on the EitherT front
19:23:41 <dzdcnfzd> Why couldn't Either s = EitherT s Identity?
19:24:12 <edwardk> dzdcnfzd: because Either is in the Prelude, Identity isn't and its a hell of a lot harder to use that way
19:24:39 <edwardk> in general we don't like to make people use definitions that are defined in terms of more complicated definitions
19:24:44 <edwardk> because it makes them harder to learn
19:25:10 <edwardk> with mtl 2 we switched from having a separate simple State data type to using StateT s Identity
19:25:41 <dzdcnfzd> I see. I think I remember running into this at some point when I was very new and having the type errors confuse the hell out of me.
19:25:44 <edwardk> because the maintainer argued that it reduced maintenance effort by a factor of 2 on the library itself
19:25:46 <edwardk> and to be honest, users suffered for it
19:26:40 <edwardk> because it made it that much harder to climb the ladder to mtl proficiency
19:27:17 <geekosaur> well, part of that was that every mtl tutorial out there had them doing State $ ...
19:27:32 <edwardk> the cynic in me blames this in some way for the rise of interest in all these effect systems
19:27:35 <edwardk> geekosaur: yeah
19:27:49 <geekosaur> and, because of the way search enines work, those will come up with higher rank because they've collected more links to them
19:28:26 <edwardk> slowly getting towards having lens building on ghc 8
19:30:19 <geekosaur> (personally I think any time you need to use one of those constructors directly, it indicates a shortcoming in the interface)
19:31:34 <geekosaur> theonly time I should need to talk about the data constructor for an mtl/transformers class is when implementing it or deliberately poking at innards.
19:33:04 <geekosaur> s/class/instance/ I guess
19:33:21 <dzdcnfzd> Is there any standard way people usually get from, say, Either s a to (Monad m) => EitherT s m a?
19:33:34 <dzdcnfzd> * Either s a to (Monad m) => ExceptT s m a?
19:34:17 <dzdcnfzd> I heard about a hoist function but it doesn't seem to exist in the ExceptT package
19:34:36 <dzdcnfzd> I could write my own without any trouble -- just wondering what the standard solution is
19:34:56 <edwardk> dzdcnfzd: in the either package it is http://hackage.haskell.org/package/either-4.4.1/docs/src/Control-Monad-Trans-Either.html#hoistEither but i don't think that survived the bikeshedding
19:35:11 <mag__> Hello
19:35:18 <edwardk> :t either fail return
19:35:20 <lambdabot> Monad m => Either String a -> m a
19:35:31 <mag__> Sorry, I'm going to imprudently ask the following question:  Does Haskell have to know the size/length of a tuple at compile time?
19:35:38 <edwardk> :t either throwError return
19:35:39 <lambdabot> MonadError e m => Either e a -> m a
19:35:48 <dzdcnfzd> mag__ yes
19:36:03 <edwardk> mag__: yes, tuple of different sizes are types that aren't related
19:36:19 <dzdcnfzd> edwardk: thanks
19:36:50 <mag__> Thank you
19:37:04 <kadoban> mag__: If you want a tuple that you don't know the size of at compile time, you often want a list instead I suspect.
19:38:21 <mag__> as a novice, tuples are attractive to me
19:38:36 <mag__> I can, for instance, store different types
19:41:06 <mag__> but again, tuples have one type
19:42:09 <mag__> mmh I think I understand now why Haskell needs to know the size of the tuple
19:42:53 * mag__ sigh
19:42:59 <mag__> thank you again :)
19:43:05 <srhb> mag__: There are heterogenous lists (variable sized list, different typed elements) -- but in general you won't be needing them. Also consider: If you don't know the type of a thing, you can't do much with it. :-)
19:45:34 <mag__> heterogenous lists [interesting],  "Also consider: If you don't know the type of a thing, you can't do much with it"  makes sense 
19:45:58 <hodapp> (and is a fun question to pose to people who insist on dynamic typing)
19:47:00 <hodapp> (though parametricity relies precisely on that 'not much' in the latter half)
19:52:05 * hackagebot transformers-compat 0.5.1.4 - A small compatibility shim exposing the new types from transformers 0.3 and 0.4 to older Haskell platforms.  https://hackage.haskell.org/package/transformers-compat-0.5.1.4 (EdwardKmett)
19:52:07 * hackagebot transformers-compat 0.5.1.2 - A small compatibility shim exposing the new types from transformers 0.3 and 0.4 to older Haskell platforms.  https://hackage.haskell.org/package/transformers-compat-0.5.1.2 (EdwardKmett)
19:52:09 * hackagebot transformers-compat 0.5.1.3 - A small compatibility shim exposing the new types from transformers 0.3 and 0.4 to older Haskell platforms.  https://hackage.haskell.org/package/transformers-compat-0.5.1.3 (EdwardKmett)
19:53:30 <dzdcnfzd> what's the equivalent of liftIO for a general monad transformer?
19:54:36 <kadoban> I forget how much building is necessary to setup a haskell installation for the first time on a different machine. I've basically spent the afternoon waiting for stack to build enough stuff that I can work on my project, heh.
19:55:02 <kadoban> It's always so quick once you get a base of built stuff cached :-/
20:04:14 * Clint eyes int-e
20:07:06 * hackagebot bytes 0.15.2 - Sharing code for serialization between binary and cereal  https://hackage.haskell.org/package/bytes-0.15.2 (EdwardKmett)
20:12:57 <geekosaur> dzdcnfzd, not sure what you're asking there?
20:13:22 <geekosaur> Control.Monad.Trans.lift is how you lift an operation into the next monad in the stack
20:15:03 <geekosaur> liftIO and the various transformer classes (e.g. MonadState) use lift to do the actual work
20:21:13 <dzdcnfzd> geekosaur: I'm not quite sure what I'm asking. This is my first time using any of this stuff and my mind is confused. I'm really excited though, cause I've just transformed (heh) a bunch of my code to use ExceptT instead of IO (Except ...) and it's compiling!
20:21:55 <dzdcnfzd> kind of a classic example of running into a problem and trying to solve it being the best way to learn a new library
20:22:12 <dzdcnfzd> You just run into the same pattern a bunch of times until the need for a solution becomes obvious
20:25:30 <tsani> What's up with many docs not being available on Hackage these days ?
20:26:52 <edwardk> tsani: they get built every 12 hours or so or by a maintainer who uploads them
20:27:03 <edwardk> so if you're looking at anything just uploaded that is why
20:27:22 * hackagebot monadic-arrays 0.2.2 - Boxed and unboxed arrays for monad transformers  https://hackage.haskell.org/package/monadic-arrays-0.2.2 (EdwardKmett)
20:27:24 * hackagebot monad-products 4.0.1 - Monad products  https://hackage.haskell.org/package/monad-products-4.0.1 (EdwardKmett)
20:27:40 <tsani> Right. It just seemed to me as though on average when I would browse to a package, the docs would be unavailable (or rather "pending")
20:27:52 <tsani> Maybe I'm just tremendously unlucky these days ;-)
20:29:28 <dzdcnfzd> Does anyone see a way of inlining line 3 as it's inlined on line 9?
20:29:28 <dzdcnfzd> http://lpaste.net/149840
20:30:37 <dzdcnfzd> That is, to leave the result of runExceptT listing anonymous?
20:30:41 <dzdcnfzd> Or is this a pipe dream
20:31:39 <scshunt> dzdcnfzd: Use -XLambdaCase and then exceptT listing >>= \case { ... }
20:33:00 <dzdcnfzd> scshunt: oooh, cool. Thanks
20:41:36 <nut> how to write lamba without any argument?
20:43:10 <kadoban> nut: A lambda without any argument doesn't sound like it makes any sense. A lambda is an expression for a function. Functions *always* have arguments, or they're not functions.
20:44:31 <asfdk> R / python - esque send line to repl, works with those pesky monad blocks : https://github.com/HVic/haskell-mode-extra
20:46:38 <lambda-11235> kadoban: It makes sense in a strict language, but not in Haskell. In Haskell we only have one argument functions.
20:47:26 <kadoban> In an imperative language you mean? Yeah.
20:58:50 <jle`> mniip: any plans on putting finite-typelits onto stackage? :)
20:59:03 <mniip> I'd need to catch up on what that is
20:59:29 <jle`> you can just consider it as a separate package db -- adding it is just adding a line on a text file, heh
20:59:32 <jle`> https://www.stackage.org/
20:59:51 <jle`> of course, only if you wanted!
21:00:44 <jle`> main advantage is that people manage packages/executables completely with stack now and packages not on stackage have to be explicitly added
21:01:22 <jle`> well, that's not the main advantage, heh
21:09:37 <hypoon> Hi guys. I have an implementation decision that I'm trying to resolve. Context is a networked game using a client/server model. The question is about handling game's changing state: FRP (Yampa?) or MVars/TVars?
21:10:16 <asfdk> why is there both a global and global-project with separate yaml files in .stack?
21:13:22 <jle`> hypoon: netwire/yampa-style FRP is good for continuous changes, not discrete ones, so they might.  if you have discrete changes then something like sodium/reactive-banana or auto would be nice for that
21:14:01 <kadoban> asfdk: .stack/global-project/stack.yaml is the stack.yaml that's used for project-specific config when you're not in a project context (when you run stack just wherever, not in a project)
21:14:21 <kadoban> asfdk: I believe ~/.stack/global/ is deprecated, that sounds like the old organization.
21:14:26 <hypoon> jle`: all the examples I see are for arcade-style games, but this won't really be an arcade or platformer style. This will be more of an RPG style, but "MMORPG" would give people the wrong idea. Continuous time, but discrete space.
21:15:01 <kadoban> asfdk: non-project config now goes in ~/.stack/config.yaml
21:15:28 <asfdk> kadoban hrm stack install ghc-mod is still trying to reference it
21:15:52 <kadoban> asfdk: What version of stack do you have? It may only be deprecated, I think it warns about it or something in newer stack?
21:16:03 <hypoon> jle`: I haven't played any of the recent incarnations, but the old 90s-era handheld Pokemon games are sorta the feel I'd like to achieve.
21:16:08 <asfdk> 0.1.2.0
21:16:23 <asfdk> i just ran stack update , does that not actually update the version?
21:16:24 <kadoban> asfdk: That's like, super old
21:16:52 <asfdk> arr dammit
21:17:06 <kadoban> asfdk: I think 'stack upgrade' is supposed to. I'd probably just install stack via your distro's package manager though, that works better for me.
21:17:24 * hackagebot intervals 0.7.2 - Interval Arithmetic  https://hackage.haskell.org/package/intervals-0.7.2 (EdwardKmett)
21:17:24 <kadoban> I don't like program's auto-update functionality, they're too adhoc for me.
21:17:26 * hackagebot hashable-extras 0.2.3 - Higher-rank Hashable  https://hackage.haskell.org/package/hashable-extras-0.2.3 (EdwardKmett)
21:17:50 <jle`> hypoon: ah i had misread you, i thought you were talking about the game's state w.r.t. networking stuff
21:18:27 <asfdk> too late already did stack upgrade. oh this is going to take a while..
21:18:35 <jle`> hypoon: but yeah, something like an old school Pokemon might work well with sodium/reactive-banana, etc
21:19:06 <hypoon> jle`: But Yampa would be less of a good fit, then, correct?
21:19:12 <jle`> MVars/TVars would be a bit unrelated to the idea of progrmaming game logic
21:19:17 <kadoban> asfdk: Yeah it takes a bit. You can just cancel it if you want and install via package manager. It's up to you. I guess nothing really wrong with stack's upgrade thing. When you're done, make sure the 'stack' on your path is the right one.
21:19:23 <jle`> hypoon: yes, not yampa
21:19:41 <jle`> also btw, yampa is slightly dated; netwire is its more modern counterpart
21:19:41 <hypoon> jle`: (I'm just getting into FRP, so I'd rather not shoehorn the application into the wrong framework)
21:20:02 <jle`> netwire, or pull-based FRP, would be good for real-time arcade games
21:20:08 <jle`> or real-time games in general
21:20:23 <hypoon> jle`: Interesting, that's good to know.
21:20:40 <hypoon> jle`: What is the relationship between sodium and reactive-banana?
21:20:59 <hypoon> jle`: Are they alternatives, or are they typically used together?
21:21:10 <jle`> hm.  well, there might be some aspects of a game like pokemon that could be considered real-time, because things happen when the player isn't sending any input
21:21:12 <jle`> people walking around, etc.
21:21:31 <jle`> they are both implementations of "push-pull FRP"
21:21:54 <jle`> which is well suited for things like GUI's, where action is "driven" by discrete events
21:22:04 <hypoon> jle`: That's very true. There will definitely be stuff happening that's not user-initiated, and there will also be a lot happening off-screen.
21:23:36 <jle`> for pull-based FRP like netwire/yampa, the entire game state is recomputed at every frame
21:23:44 <asfdk> is there a way to get the haskell-mode ghci to be "stack ghci"
21:23:54 <jle`> so it's suitable for things where this makes sense, like a real time arcade game or RTS
21:24:14 <asfdk> or for that matter, everything haskell-mode to be stack-based
21:24:32 <hypoon> jle`: my current design has three systems: a server who's only job is to manage a self-consistent state of the world, a client who's only job is to collect user input and display the current state of the "world", and an intermediate server who's job is to validate client interactions and handle client communications.
21:24:39 <jle`> in push/pull frp implementations, discrete events drive updates/recalculations and game logic
21:25:49 <hypoon> jle`: I intend for the world to be quite large... I don't think it's sensible to reprocess the entire world several times a second.
21:26:24 <jle`> yeah, because it's the server, and not the client, it'd make more sense with a pushy pully system
21:28:14 <hypoon> jle`: Ok, so sodium vs. reactive-banana, is one more popular than the other?
21:28:40 <jle`> i haven't actually be in in the scene for a while
21:28:48 <asfdk> reflex is the most performant i've heard
21:28:50 <jle`> but you might find people more up to date in #haskell-game :)
21:29:31 <hypoon> asfdk: I've seen reflex mentioned. Is that also in the push/pull FRP category?
21:29:50 <hypoon> jle`: wasn't aware of #haskell-game, I'll have to check that out.
21:30:08 <hypoon> jle`: you also mentioned "auto"?
21:30:24 <jle`> yeah, it uses a hybrid of push/pull that's unique from what i heard, but it's not a pull-only like yampa/netwire
21:30:33 <jle`> auto is for completely discrete systems
21:30:46 <jle`> but for a game server like yours you might be running with combinations of discret and continuous events interacting with eachother
21:31:11 <jle`> also, i thought that reflex was only client-side, meant for usage with GHCJS for js clients?
21:31:18 <jle`> maybe i'm mistaken
21:31:35 <hypoon> I think of it as discrete in space, but continuous in time. I'd like to avoid having the world update in "ticks", if possible.
21:31:51 <asfdk> jle` some demos have been with ghcjs but i think it's more general
21:32:41 <jle`> hypoon: yeah, updating the world in ticks is sort of the "opposite" of the point of FRP
21:33:00 <jle`> you can think of traditional game programming as drawing with bitmaps like photoshop, and FRP as vector graphics
21:33:15 <asfdk> jle` hypoon some discussion https://www.reddit.com/r/haskell/comments/3qsz16/why_is_this_reactivebanana_code_slow/
21:33:38 <jle`> push-pull FRP lets you specify your game's logic in terms of discrete events and continuous behaviors triggered by them, etc
21:33:39 <asfdk> time 4 sleep
21:33:43 <synergistics> Is "Write Yourself a Scheme in 48 hours" a bad choice for someone with no prior haskell knowledge?
21:34:03 <asfdk> synergistics haskellbook.com
21:34:10 <hypoon> jle`: What did you mean when you described auto as being for "completely discrete systems"?
21:34:40 <hypoon> asfdk: Thanks for the link, I'm checking it out.
21:35:18 <jle`> hypoon: w.r.t. games, games that are completely turned based, like chess or tic tac toe, roguelikes
21:35:28 <jle`> s/roguelikes/rogue
21:36:16 <hypoon> jle`: Ok, definitely not my goal. So I'm back to sodium, reactive-banana, or reflex, correct?
21:36:51 <hypoon> jle`: You said MVars/TVars is a bad idea? (That would be the most obvious way to do it in an imperative form)
21:37:25 * hackagebot promises 0.3 - Lazy demand-driven promises  https://hackage.haskell.org/package/promises-0.3 (EdwardKmett)
21:37:26 <jle`> yeah; well, the best i can say is "push-pull frp", and not pull-only frp like yampa/netwire; but, for the best solution today in 2016, i wouldn't be able to give you too good of an answer
21:38:13 <jle`> yeah, i would discourage it because it might be hard to scale.  the point of FRP is to give you a sort of higher-level "language" to state your game logic as
21:38:32 <jle`> working down that low would obscure the meaning of what you're programming and might make things tricky to maintain
21:39:39 <jle`> but yeah, hopefuly some people in #haskell-game can give you more specific advice for which framework to use in 2016
21:39:48 <jle`> ther's also a haskell game dev subreddit, as well
21:40:36 <hypoon> jle`: I see, ok. I'll poke around to see how things are maintained on hackage, then I'll head to #haskell-game to try to seek additional wisdom.
21:42:25 * hackagebot discrimination 0.2.1 - Fast generic linear-time sorting, joins and container construction.  https://hackage.haskell.org/package/discrimination-0.2.1 (EdwardKmett)
21:43:18 <hypoon> Is hackagebot notifying us of package updates?
21:43:28 <hypoon> (or new packages, maybe?)
21:43:34 <kadoban> Both, yeah.
21:44:04 <kadoban> That's all it does that I know of, so you can ignore if it you don't care. (I usually ignore it ... it gets spammy sometimes)
21:44:20 <hypoon> Ok, so I shouldn't be trying to figure out how its relevant to current discussion, lol.
21:44:23 <edwardk> hypoon: busy day as i'm going through updating everything i maintain for ghc 8, so it'll be noisy =)
21:44:33 * qmmm can't decide between yesod and spock
21:44:41 <qmmm> leaning toward spock
21:46:12 <hypoon> edwardk: Totally ok, was just confused because I didn't understand the immediate relevance to the discussion, that's all. :-)
21:47:29 * hackagebot speculation 1.5.0.3 - A framework for safe, programmable, speculative parallelism  https://hackage.haskell.org/package/speculation-1.5.0.3 (EdwardKmett)
21:47:31 * hackagebot hspec-meta 2.2.1 - A version of Hspec which is used to test Hspec itself  https://hackage.haskell.org/package/hspec-meta-2.2.1 (SimonHengel)
21:48:26 <Adeon> eh, already ghc 8 rc1
21:48:59 <hypoon> Looks like reactive-banana's been updated within the past two weeks, while sodium was last updated a year and two-weeks ago (which implies it's either very stable or unmaintained, right?).
21:49:00 <Adeon> I wonder what new features it'll have
21:49:55 <Adeon> -XStrict seems interesting but I'm not sure if I'd ever use it
21:50:25 <kadoban> Adeon: https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.0.1 is the page I've been checking, though I don't know if there's a better one now that there's an RC
21:50:37 <Adeon> since the major version hopped from 7 to 8 something amazing must have happened, right?
21:51:57 <Adeon> some backpack stuff is in ghc 8
21:53:09 <hypoon> Regarding new versions of GHC, I haven't been following too closely, but I remember ARM support was limited the last time I checked (but that they were actively working on it). I'd love to see ARM fully supported, because I'm looking at Linux on ARM for my next laptop.
21:54:54 <edwardk> hypoon: sodium was pretty stable at last check
21:55:39 <edwardk> ryantrinkle's reflex borrowed a lot from sodium's design
21:56:21 <Adeon> the user's guide is prettier :-) https://downloads.haskell.org/~ghc/8.0.1-rc1/docs/html/users_guide/index.html
21:56:41 <hypoon> edwardk: So don't rule it out based on stale packages? Even the Sodium git repo hasn't had much activity regarding haskell updates.
21:57:07 <edwardk> at last check the author largely considered it 'finished'
21:57:24 <edwardk> and started implementing it in a ton of other languages to bring FRP to the masses
21:59:45 <kadoban> Adeon: The most exciting stuff for me is Applicative Do, Monad Fail (the start anyway), and the stuff about stack traces. Also overloaded record stuff, but IIUC that's not 100% there yet.
22:00:06 <mniip> jle`, so how does one push to stackage
22:01:08 <jle`> mniip: https://github.com/fpco/stackage/edit/master/build-constraints.yaml
22:01:23 <kadoban> mniip: On the mainpage for stackage there's the really simple instructions, using the github interface essentially.
22:02:17 <hypoon> edwardk: I see, interesting. I mean, I guess that's the programmer's ideal. I've always told my business-minded friends to drop the mindset that you can pay someone to complete a software project and walk away... instead, software is never "done" (even excluding new features), and will always require bug-fixes and updates for new platforms.
22:02:53 <mniip> ech
22:02:53 <hypoon> edwardk: but I can imagine haskell libraries not really working that way, lol. I can totally imagine something being written elegantly enough in Haskell that it lasts a very long time.
22:03:02 <mniip> using github to create commits ehh
22:03:30 <edwardk> maybe 10% of my code goes into a sort of immortal status where i don't wind up having to update it for new GHC releases
22:03:47 <edwardk> most of it uses every brittle trick I can to get performance
22:03:55 <edwardk> or uses advanced features that change a lot
22:04:26 <kadoban> mniip: Well if you know git you can of course do that, heh. I figure they just don't want to walk people through the CLI.
22:06:52 <hypoon> edwardk: It's very cool how portable Haskell ends up being. The only thing I anticipate having to rewrite is the user interface.
22:07:11 <edwardk> i dodge that by sticking to the backend =)
22:07:30 * hackagebot heaps 0.3.3 - Asymptotically optimal Brodal/Okasaki heaps.  https://hackage.haskell.org/package/heaps-0.3.3 (EdwardKmett)
22:07:42 <mniip> I wish haskell had a usable dynamic loading interface :(
22:08:02 <mniip> the ghc one is awful
22:08:30 <hypoon> edwardk: Sounds wise, lol.
22:10:46 <nocturne777> why do Control.Monad.Trans.Reader and Control.Monad.Trans.State not implement MonadReader and MonadState classes?
22:11:15 <scshunt> nocturne777: use the newer versions of the MTL
22:11:33 <scshunt> where Reader = ReaderT Identity
22:11:45 <mniip> so, what does stackage use for testing?
22:13:33 <koz_> Can I get my Cabal project to (for instance) build an HTML file from a Markdown file? I wanna include a design document in my project, but obviously, writing it in Haddock makes little sense.
22:15:18 <nocturne777> scshunt: I am looking at some of the libraries and they keep using  Control.Monad.Trans instead of MTL
22:15:43 <edwardk> nocturne777: transformers provides the data types. mtl provides the classes and instances for them
22:15:49 <movedx> Does Haskell compile down to a binary, native to the platform it's compiled on/for?
22:16:04 <edwardk> nocturne777: if you incur a dependency on mtl you can import and uses the classes on those data types just fine
22:16:31 <kadoban> mniip: I'm a bit fuzzy on the details, but IIUC it's mostly (completely?) based on "does this build with our other crap?" They have most of the system open sourced IIUC, though I haven't really looked at it.
22:16:35 <edwardk> nocturne777: some library authors write against just 'transformers' unless they use the classes themselves, as it can save them a dependency
22:16:52 <mniip> kadoban, I see references to tests in the yml file
22:16:52 <edwardk> but mtl has the dependency on transformers and provides the instances
22:16:58 <mniip> and one of my packages has a testsuite
22:17:03 <mniip> and I was wondering how is it set up
22:17:23 <edwardk> transformers by dint of not offering the classes avoids extensions and winds up being haskell 98
22:17:27 <kadoban> mniip: Oh. I'm not sure then, sorry.
22:18:42 <nocturne777> edwardk: I am beginning to  think that since I am not writing a library, I should be OK with using mtl 
22:19:12 <edwardk> nocturne777: as the maintainer of the mtl i generally think it is fine to use ;)
22:19:39 <Adeon> mtl doesn't even have any other dependencies, IIRC
22:19:41 <scshunt> is anyone here an expert with ghc-mod?
22:20:43 <edwardk> Adeon: the concerns were more about needing fundeps/MPTCs
22:21:18 <edwardk> back when folks believed fundeps were imminently going to go away or that other language implementations might somehow gain traction without them
22:21:19 <scshunt> ghc-mod isn't reporting any errors, even blatant syntax errors
22:21:43 <scshunt> edwardk: fwiw I prefer type families
22:21:52 <mniip> type families are pretty weak
22:21:54 <Adeon> are the concerns about needing functional dependencies or multi-params justifiable
22:22:01 <Adeon> at least jhc supports them, no?
22:22:10 <edwardk> i use whichever one of them is most appropriate and least verbose in the situation in question
22:22:10 <scshunt> mniip: "weak" in what sense?
22:22:14 <edwardk> that splits about 50/50
22:22:28 <mniip> scshunt, sometimes type families don't let you do things MPTCs can
22:22:38 <hypoon> movedx: Yes, you end up with a binary.
22:22:40 <scshunt> mniip: you need both
22:22:44 <mniip> right
22:22:48 <hypoon> movedx: and that binary does not need an interpreter.
22:22:50 <edwardk> Adeon: it was mostly a product of the time when it was done, back in 2010 it looked a lot more like fundeps were going to be totally eradicated
22:23:04 <scshunt> mniip: I prefer type families to fundeps, specifically
22:23:04 <Adeon> ah I see
22:23:12 <scshunt> fundeps don't make sense without MPTCs, but type families do, which is one advantage to them ;)
22:23:36 <Adeon> there should be haskell a history book I could look up all this stuff nicely organized
22:23:52 <movedx> hypoon: Is the Haskell runtime embedded into the binary, or is all coded invoked statically linked in and that's it?
22:24:01 <mniip> scshunt, https://github.com/AbstractBeliefs/BadBuzz/blob/master/Haskell/mniip.hs
22:24:43 <scshunt> I think that anything that people can use to make their programs more type safe is likely to stay in the long run
22:24:44 <hypoon> movedx: I was just halfway through typing to address that, lol. I have no idea, but someone else here will.
22:24:48 <scshunt> just look at TH
22:24:56 <movedx> hypoon: HA
22:24:59 <movedx> hypoon: Thanks :)
22:25:02 <jle`> oops i accidentally deleted my local copy of ghcjs
22:25:09 <jle`> v.v
22:25:28 <jle`> the compiled version that took an hour or two to build ;_;
22:26:09 <kadoban> jle`: :( I just finally finished waiting for stack to build mine. I feel your pain.
22:26:30 <jle`> heh
22:26:37 <jle`> it's okay i'm rebuilding with stack
22:26:53 <jle`> learning how to use it
22:26:57 <hypoon> movedx: The resulting binary certainly ISN'T just a copy of your code wrapped in a haskell interpreter, that's for sure. Haskell is definitely a compiled language.
22:26:59 <movedx> I remember someone once told me that functional programming, and Haskell, helped them really understand how to solve computer problems. It gave them a new way of thinking.
22:27:22 <movedx> So now I'm interested to see what this functional programming is all about.
22:27:26 <scshunt> mniip: why can't you do that with type families?
22:27:30 * hackagebot hspec-core 2.2.2 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-core-2.2.2 (SimonHengel)
22:27:33 * hackagebot hspec-discover 2.2.2 - Automatically discover and run Hspec tests  https://hackage.haskell.org/package/hspec-discover-2.2.2 (SimonHengel)
22:27:34 * hackagebot hspec 2.2.2 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-2.2.2 (SimonHengel)
22:28:11 <kadoban> movedx: Nice, should be fun :) haskell is really interesting (and practical as a bonus). Need any learning material recommendations?
22:28:36 <movedx> kadoban: I'm working my way through Learn You a Haskell.
22:28:46 <hypoon> movedx: it's really cool. I'm fairly new to Haskell, but it didn't take long for it to become my language-of-choice for most of my work.
22:29:24 <kadoban> movedx: Just to warn you, LYAH I don't really like. It's kind of a fun read, but I wouldn't expect to come out the other end knowing how to program in haskell.
22:30:29 <movedx> kadoban: In that case, what are your recommendations?
22:31:16 <hypoon> kadoban, movedx: I loved LYAH, but I somewhat agree with kadoban's statement: it won't make you proficient, really. I loved it because I didn't have the patience for a more serious text at the time.
22:31:38 <kadoban> movedx: http://haskellbook.com/ if you're serious enough to buy something, otherwise https://github.com/bitemyapp/learnhaskell has some good advice, like cis194 is pretty decent, though not perfect.
22:31:57 <edwardk> -fno-warn-trustworthy-safe  -- wtf when did that come around?
22:32:00 <hypoon> What does everyone think of Real World Haskell?
22:32:33 <edwardk> LYAH + RWH taken together were for the longest time the one decent way to learn haskell
22:32:41 <kadoban> For me it's less that it won't make you proficient and more that ... you won't really be able to do anything, unless you work hard on your own afterwards. LYAH doesn't have any exercises, it doesn't really teach you to program in haskell at all. It just kind of introduces some things.
22:33:06 <edwardk> LYAH didn't have enough rigor / go far enough. RWH was a little 'too' pragmatic and not enough filled with wonder.
22:33:25 <u-ou> edwardk: what would you recommend nowadays?
22:33:41 <edwardk> and each one sort of did things out of order in places, so having both handy was a good way to combat those weaknesses
22:34:02 <edwardk> u-ou: RWH is still a pretty solid introduction
22:34:28 <mniip> jle`, why such interest in finite-typelits though :o
22:34:43 <edwardk> bitemyapp has been working on some sort of mammoth tome, but i haven't read it yet so i can't make a case for/against.
22:34:44 <mniip> is the package actually used somewhere?
22:35:02 <u-ou> edwardk: i was just about to ask about that :P
22:35:33 <jle`> mniip: oh, i use it :O
22:35:35 <kadoban> (bitemyapp's mammoth tome would be the haskellbook.com one I linked above)
22:35:37 <jle`> for indexing into my vectors
22:35:53 <mniip> ooh, and the typesystem doesn't fall apart?
22:35:58 <jle`> my vectors-with-types-in-their-size
22:36:08 <jle`> nah type system has been good to me so far
22:36:09 <edwardk> u-ou: https://www.quora.com/Reviews-of-Learn-You-a-Haskell-2011-book/review/Edward-Kmett?share=1 has my old review of LYAH w/ "where to go next" pointers
22:36:20 <mniip> huh
22:36:27 <jle`> when things go wrong i whip out my https://github.com/mstksg/typelits-witnesses and things seem to be ok
22:36:42 <movedx> kadoban: I'll start here http://www.seas.upenn.edu/%7Ecis194/spring13/lectures/01-intro.html 
22:36:57 <jle`> i haven't run into too many road blocks
22:37:03 <mniip> whenever I try to do something fancy with GHC.TypeLits it ends up with me ragequitting because GHC is too dumb
22:37:15 <waressearcher2> every time I join that channel I'm thinking like: "I go there and will get smarter" and then after a few minutes I like: "no, I can't even understand what they are talking about", why is that ?
22:37:26 <kadoban> movedx: Sounds good. Remember to take it slow, and make sure you notice the suggested readings (one of which is LYAH, so your already spent time won't be wasted, which is nice)
22:37:33 <u-ou> ty
22:37:42 <jle`> mniip: maybe i just do simple things, heh
22:37:51 <nut> how to run a IO function every 10 secs
22:38:12 <nut> i mean when the IO function returns, wait 10 secs
22:38:19 <nut> before run it again
22:38:24 <mniip> https://github.com/mstksg/typelits-witnesses
22:38:24 <mniip> :O
22:38:44 <scshunt> man, everybody wants dependent types in their haskell
22:38:46 <mniip> yeah this one probably helps a lot
22:38:53 <nocturne777> edwardk: why is there no class for EitherT ?
22:39:03 <edwardk> it is called ExceptT
22:39:04 <hypoon> kadoban: I just checked out haskellbook.com. I came back to the same thing that always makes me uneasy: Stuff changes, and books on the shelf don't (not automagically, anyway). Maintaining a library of current technical literature is expensive. Flipside is I don't like paying for things I can't touch (ebooks).
22:39:07 <edwardk> oh class
22:39:10 <edwardk> the class is MonadError
22:39:14 <edwardk> same class as ErrorT
22:39:57 <hypoon> nut: threadDelay in a loop?
22:40:02 <edwardk> nocturne777: there was nothing wrong with the MonadError class, just the ErrorT data type
22:40:07 <movedx> hypoon: That's why I like books from leanpub.com - they're updated by the authors as the tech changes and evolves. 
22:40:27 <mniip> jle`, do "your vectors" have a package/repo
22:40:37 <nut> how to use a loop?
22:40:42 <movedx> hypoon: And it can act as a kind of Kickstarter for new books too, in the form of you buying a book before it's finished.
22:40:44 <nut> hypoon, 
22:40:46 <kadoban> hypoon: Well, that is true, but ... I can't imagine it'd be too hard to learn current haskell if you already knew haskell from a few years ago well, so practically I don't know that it matters? IIUC bitemyapp isn't focusing on stuff that's likely to change in drastic ways either.
22:40:55 <hypoon> movedx: looks interesting, I'll have to check it out in detail.
22:41:08 <jle`> mniip: it can't do induction and also no commutativity but it's been good for practical usage
22:41:14 <jle`> nut: you can sue `forever`
22:41:16 <Cale> scshunt: Yeah, we're pretty envious of what's expressible in dependent type theories like Coq
22:41:18 <movedx> hypoon: And if you write your own book on there, you get about 90% in royalties.
22:41:25 <jle`> forever (do myAction; threadDelay 10000)
22:41:28 <jle`> nut: ^
22:41:38 <scshunt> Cale: "we"? I've seen you enough in #idris ;)
22:41:47 <mniip> jle`, yeah I was thinking about making a package with inductive witnesses for nats
22:41:48 <jle`> mniip: um, i was using V from the linear package, but now i'm using hmatrix package's typed vectors
22:41:48 <nut> jle`, so forever with threadDelay ?
22:41:54 <mniip> but never got around to do it
22:42:26 <scshunt> I'll probably get back to dependent types in a few years, once they're more usable
22:42:29 <jle`> finite-typelits was a situation where i would have had to use induction and stuff but i ended up being able to bypass it with finite
22:42:35 <edwardk> scshunt: idris isn't the only game in town that isn't coq ;)
22:42:37 <scshunt> for now, doing nontrivial things with them is still a pain
22:42:50 <mniip> mhm
22:42:52 <scshunt> edwardk: I know! I believe I've seen Cale in #agda too
22:42:58 <scshunt> less sure on that one though
22:43:01 <jle`> hmatrix's size-typed vectors are amazin
22:43:03 <scshunt> and I don't idle in those channels all the time
22:43:14 <Cale> Yeah, I hang out there too
22:43:20 <edwardk> i heard a vicious rumor that he might actually show up at compose
22:43:39 <Cale> I spend a lot more of my time programming in Haskell though. I also am pretty greedy and don't just want dependent types, but also lazy evaluation / non-strict semantics.
22:43:43 <scshunt> since I'm just an occasional hobbyist, those channels are all noise to me atm
22:43:49 <edwardk> cale++
22:43:51 <mniip> jle`, I was actually looking for an example of usage
22:43:51 <Cale> also, Haskell-like type classes
22:43:57 <hypoon> nut: "forever" is the more elegant way of looping. I often just call the same function again as the last step in a do-block, instead.
22:44:02 <scshunt> I really like dependent types, but they're just so slow to write real code in
22:44:09 <jle`> hm, i have an old code sample
22:44:11 <edwardk> its the lack of real haskell typeclasses that kill the others for me
22:44:15 <jle`> (of finite, you mean, right?)
22:44:18 <mniip> yes
22:44:21 <Cale> scshunt: Well, like anything, you probably have to control yourself
22:44:22 <scshunt> I suppose I could just put believe_me everywhere
22:44:36 <scshunt> Cale: yeah
22:44:42 <nut> hypoon, thx
22:45:38 <jle`> mniip: here's an old one but it might be convoluted, i'm using it to index into nodes of my recurrent neural network to delete nodes
22:45:40 <jle`> https://github.com/mstksg/neural/blob/master/src/Data/Neural/Recurrent/Modify.hs
22:46:05 <hypoon> nut: np, happy coding :-)
22:46:36 <jle`> oh wait the actual usage isn't there
22:47:02 <scshunt> Cale: I think the problem is my personality
22:47:08 <jle`> https://github.com/mstksg/neural/blob/master/src/Data/Neural/Utility.hs#L124-L125
22:47:14 <scshunt> the last thing I was trying to do with it I was trying to prove correct, and that was really hard
22:47:25 <jle`> and the reason it's viable is because of typelits-witnesses to give a KnownNat instance for (n - 1)
22:47:32 <scshunt> made harder by the language, though; felt like I was constantly fighting it
22:47:32 <jle`> when i *do* use deleteV
22:47:55 <mniip> mhm
22:48:04 <Cale> scshunt: It's kind of like how type classes make it possible to abstract lots of things, but if you do that at every opportunity possible, you end up pulling your hair out
22:48:21 <jle`> there's nothing particularly dependely typed about this though, heh
22:48:27 <nut> any quick and simple way to generate dates for a whole year in the format of 2014-02-16 ?
22:48:36 <nut> into a list
22:48:47 <nut> taking only the year as an argument
22:49:41 <mniip> jle`, Finite is Integral though
22:50:03 <mniip> https://github.com/mniip/finite-typelits/blob/master/src/Data/Finite.hs#L116-L118
22:50:13 <hypoon> nut: You're going to need a date or calendar package to get the right number of days in each month.
22:50:27 <jle`> mniip: oh thanks, didn't even realize
22:50:52 <hypoon> nut: Because, for example, deciding how many days belong in February is non-trivial.
22:51:06 <Adeon> I think I would parse '2014-01-01' and '2015-01-01', take the UTCTime of first and addings days until I hit first day of 2015 and formatting each day as %Y-%m-%d
22:51:13 <waressearcher2> is there bitmasks in haskel like you use in WinApi to send parameters to function like "WinApi32Function(Var1 | Var2 | Var2)" ?
22:51:19 <Adeon> you can look inside UTCTime and see that is days + time of day
22:51:57 <Adeon> if you are comfortable looking inside UTCTime
22:52:06 <Adeon> I think it's not in any internal module so it's probably meant to be stable
22:52:11 <mniip> jle`, for some reason haddock swallowed all instances
22:52:17 <jle`> huh
22:52:21 <hypoon> nut, Adeon: I have to defer to others here, I'm very unfamiliar with date/time packages.
22:53:16 <Adeon> ah you can formattime Day directly, no need to go to UTCTime
22:53:24 <Adeon> and parse it as well
22:53:46 <hypoon> nut, Adeon: maybe Data.Time.Calendar?
22:53:53 <Adeon> parse '2014-01-01' as day with functions from 'time' package, Data.Time.Format, use `addDays` and then format as you want
22:53:58 <Adeon> yeah
22:55:33 <nocturne777> why do docs of recent versions of some libraries appear missing on hackage ?
22:55:58 <Adeon> there's a delay before docs are built although I don't know how long that delay is
22:56:05 <Adeon> you might want to check the older version docs meanwhile
22:56:11 <Adeon> some package authors upload docs themselves
22:56:20 <verement> nut: \year -> map showGregorian $ takeWhile ((\(y, _, _) -> y == year) . toGregorian) $ [fromGregorian year 1 1 ..]  -- import Data.Time.Calendar
22:56:42 <nocturne777> Adeon: the delay appears to be long :)
22:57:52 <Adeon> you could try sending angry e-mail to hackage admins saying that you think their armpits smell
22:58:04 <Adeon> shaken by this awful accusation, they might hurry it up
22:58:35 <Adeon> if you install packages locally with cabal and you have the documentation setting turned on you get documentation locally I think
22:58:44 <verement> waressearcher2: see Data.Bits
22:58:46 <Adeon> if you absolutely need the latest docs, that is
22:59:23 <scshunt> which of the various packages providing MonadRandom should I use?
23:00:05 <hypoon> Hey guys, regarding the discussion of sodium earlier for FRP: http://blog.reactiveprogramming.org/?p=258
23:00:22 <hypoon> Tl,dr; author has deprecated it in favor of reactive-banana.
23:00:47 <koz_> hypoon: I think the two libraries are exactly the same sans naming anyway.
23:00:56 <koz_> At least I recall that author's book saying as much.
23:01:19 <hypoon> Seems to be the general idea, yeah.
23:01:39 <koz_> Also: I have a Markdown document, which I wanna process into HTML which I wanna distribute along with my Cabal package. Is there a way I can do that using Cabal as part of the build process?
23:01:50 <koz_> I'm gonna use Cheapskate to do it - I'm just not sure how to tell Cabal this.
23:01:53 <hypoon> koz_: I don't know if the implementations are identical, but the API seems to be the same.
23:02:14 <koz_> hypoon: Well, the functionality should be. Not sure about the naming.
23:02:38 <koz_> I'm actually working through said book, and it's pretty good, aside from the Java examples.
23:02:55 <koz_> (if they were in Haskell and didn't try hard to fellate non-functional programmers, it'd be perfect :))
23:03:12 <nut> thanks a lot everyone
23:03:52 <hypoon> nut: np, good luck!
23:11:23 <koz_> Is there an option for GHC like -Os for GCC (i.e. optimize for smaller binaries)?
23:23:22 <scshunt> is it bad form for a transformer lifting instance to do anything special with the lift?
23:23:26 <scshunt> even if documented?
23:25:12 <edwardk> scshunt: it should be a monad homomorphism
23:25:51 <edwardk> scshunt: lift m >>= lift . f = lift (m >>= f); lift . return = return
23:26:23 <edwardk> scshunt: so if those don't pass, it isn't a proper MonadTrans instances
23:26:40 <scshunt> edwardk: it's not the MonadTrans instance
23:27:01 <edwardk> " transformer lifting instance " ?
23:27:09 <scshunt> in this case, it's a MonadRandom instance, where I want the outer monad to always be aware of someone calling a random generation function so that it can prevent them from having a bug
23:27:33 * hackagebot lens 4.13.1 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-4.13.1 (EdwardKmett)
23:27:43 <hypoon> Goodnight all! Thanks for the discussion :-)
23:27:44 <scshunt> I need a wrapper function somewhere; easiest place is right in the MonadRandom instance
23:28:04 <edwardk> MonadRandom doesn't exactly provide guarantees that you don't record the numbers it gives or that it called things
23:28:18 <edwardk> finally got to lens on ghc 8
23:28:39 <edwardk> that marks a good half-way point
23:29:08 <scshunt> edwardk: I know. But I don't know if it's bad form for a MonadTrans instance, when implementing a monad class in a way that lifts into a parent monad, to do anything other than lifting
23:29:31 <scshunt> s/MonadTrans instance/class with a MonadTrans instance/
23:29:48 <edwardk> you can do whatever you want to the instances you transform
23:29:56 <edwardk> MonadTrans just says that you are a monad homomorphism
23:30:02 <edwardk> not a MonadRandom homomorphism
23:30:13 <edwardk> er that you have a canonical monad homomorphism
23:30:37 <edwardk> just because you preserve the structure of the monad doesn't mean you preserve the structure of refinements of that concept
23:30:56 <edwardk> Reader e is a MonadTrans, but it sure doesn't preserve MonadReader effects!
23:31:24 <edwardk> similarly in my parsers library i have several 'parser transformers' that change the handling of whitespace
23:31:30 <edwardk> that are all monad transformers
23:31:43 <edwardk> but which modify the TokenParsing classes
23:32:24 <edwardk> the downside, if you provide MonadTrans, is that users can just call lift random rather than random and you'll be blind to their call
23:33:10 <scshunt> right
23:35:29 <sleblanc> No docs on this page, is this normal? https://hackage.haskell.org/package/transformers-0.5.0.2
23:36:03 <sleblanc> 0.5.0.0 has docs
23:36:04 <kadoban> sleblanc: It was updated just a while ago. Look at the older docs for now, or wait a bit and they should get updated.
23:36:20 <scshunt> hmm
23:37:20 <scshunt> I think that's probably not worth it, since I'm currently getting my lift definition from Operational and I am ok with people doing that
23:37:55 <scshunt> the design allows enough wiggle room in other places
23:39:22 <scshunt> huh, my instance is fully coherent and decidable. neat
23:39:30 <scshunt> that's... surprising
23:49:20 <scshunt> hah, haddock is bad at documenting instances
