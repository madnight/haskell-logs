00:05:47 <htstckqz> Is there a canonical name for: (.) . fmap :: Functor f => (b -> c) -> (a -> f b) -> (a -> f c) ? (It's the functor version of: (<=<) . (return .))
00:06:43 <shachaf> It's probably reasonable to generalize it to (fmap . fmap) :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
00:07:37 <htstckqz> shachaf: it is indeed :)
00:11:46 <htstckqz> And since those two fmaps don't have the same type we can't make (fmap . fmap) anymore pointlessy pointless, can we?
00:12:18 <wz1000> When is lts 5.0 coming out?
00:12:53 <shachaf> htstckqz: It's already completely point-free.
00:13:10 <shachaf> You can write it as (fmap fmap fmap) if it makes you happier.
00:13:30 <htstckqz> Don't we mention all points of (.)?
00:14:03 <jle`> fmap . fmap already has no points
00:15:17 <radens> Are there any MLs which allow you to control the layout of memory? Say they allow me to write to the address 0xb8000?
00:16:56 <radens> Or maybe create a struct 64 bits wide with two 8 bit fields, a 16 bit field and a 32 bit field, packed>
00:16:58 <radens> ?
00:21:14 <liujingtu> hi all
00:22:14 <liujingtu> I am learning Haskell. I want to know the differences between ':' and '++
00:22:47 <tsahyt> :t (:)
00:22:48 <lambdabot> a -> [a] -> [a]
00:22:50 <tsahyt> :t (++)
00:22:51 <lambdabot> [a] -> [a] -> [a]
00:23:11 <liujingtu> I understand. Thank you :)
00:23:16 <tsahyt> That's the difference. (:) prepends just one element, (++) concatenates two lists
00:23:17 <Walther> liujingtu: : adds single element to beginning of list, ++ concatenates two lists together
00:23:35 <tsahyt> liujingtu: When in doubt, check the types first, they usually tell you a lot about what's going on
00:24:52 * hackagebot gore-and-ash-sync 1.1.0.0 - Gore&Ash module for high level network synchronization  https://hackage.haskell.org/package/gore-and-ash-sync-1.1.0.0 (NCrashed)
00:29:28 <liujingtu> Hi. Is functions in Haskell own only 1 argument?
00:29:35 <liujingtu> Hi. Are functions in Haskell own only 1 argument?
00:30:45 <liujingtu> I want to write a logical AND function, I think it should be: "and2 :: Bool, Bool -> Bool", but actually it is "and2 :: Bool -> Bool -> Bool"
00:31:24 <gfixler> liujingtu: yes, all functions in Haskell take only one argument
00:31:30 <liujingtu> I thought this means "and2 x y" will be translated to "(and2 x)(y)"
00:31:40 <gfixler> it does
00:31:48 <liujingtu> But why it is not "and2(x,y)" ?
00:31:50 <gfixler> the function constructor arrow (->) is right-associative
00:32:08 <gfixler> so Bool -> Bool -> Bool is the same as Bool -> (Bool -> Bool)
00:32:12 <jle`> and2 :: Bool -> (Bool -> Bool)
00:32:19 <jle`> give it a bool, x, and you get a Bool -> Bool
00:32:27 <jle`> give that another bool, y, and you get a Bool, the answer
00:32:52 <liujingtu> yes
00:33:11 <gfixler> and because function application is right associative, f x y is the same as (f x) y
00:33:18 <gfixler> sorry, left-associative
00:33:37 <gfixler> liujingtu: this is called currying
00:34:05 <gfixler> it's quite useful
00:34:19 <liujingtu> Why it is useful?
00:34:23 <gfixler> if you don't pass all the arguments, you get a function that wants the rest
00:34:30 <gfixler> so add x y is useful on its own
00:34:37 <gfixler> but add x can be useful, too
00:34:48 <gfixler> > map (+ 3) [1,2,3,4]
00:34:50 <lambdabot>  [4,5,6,7]
00:35:03 <gfixler> I just made a new function by partially applying the arguments to the (+) operator
00:35:03 <liujingtu> oh I got it. (+ 3) return a function add-3
00:35:07 <gfixler> yep
00:35:09 <gfixler> :)
00:35:48 <jle`> > let add3 = (+ 3) in add3 10
00:35:50 <lambdabot>  13
00:35:50 <gfixler> higher order functions make it very useful - you can specialize a function with some of its arguments, then use it wherever
00:36:03 <liujingtu> Thanks you. It is great. :)
00:36:17 <gfixler> I think it all desugars to lambdas underneath
00:36:53 <gfixler> f x y is really f = \x -> \y -> etc...
00:37:05 <gfixler> each one bringing a new name into scope
00:41:22 <liujingtu> Can I convert a value into a function that return this value ?
00:41:54 <wz1000> Is there any function that creates a pipe between two handles, i.e. reads from one and writes into the other?
00:41:54 <liujingtu> Like "convert True ---> function(_) { True }"
00:42:25 <wz1000> :t const
00:42:26 <lambdabot> a -> b -> a
00:42:42 <wz1000> :t (const 3)
00:42:43 <lambdabot> Num a => b -> a
00:42:54 <wz1000> liujingtu: ^
00:43:06 <wz1000> :t const True
00:43:08 <lambdabot> b -> Bool
00:43:33 <boj> wz1000: library like pipes/conduit/io-streams?
00:44:38 <liujingtu> wz10000: Thanks. const is what I meant 'convert. :)
00:45:50 <gfixler> I'm always impressed with often I need id and const when I'm chaining things together at work
00:46:07 <wz1000> boj: No, just simple Handle -> Handle -> IO ()
00:48:22 <liujingtu> gfixler: When I should use 'id'? It looks useless.
00:49:02 <gfixler> wz1000: readFile "foo" >>= writeFile "bar"
00:49:10 <gfixler> liujingtu: when you need it, you'll know :)
00:49:56 <gfixler> liujingtu: one example is when working with higher-order functions that expect some kind of (a -> b) function, but you don't actually want to change anything at that point
00:51:03 <gfixler> > bimap reverse succ ("foo",3)
00:51:06 <lambdabot>  ("oof",4)
00:51:19 <gfixler> bimap id succ ("foo",3)
00:51:25 <gfixler> > bimap id succ ("foo",3)
00:51:27 <lambdabot>  ("foo",4)
00:51:39 <gfixler> :t bimap
00:51:41 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
00:52:01 <gfixler> liujingtu: bimap wants to (a -> b) functions, but I only wanted the second to have an effect, so I used id for the first
00:52:11 <gfixler> wants two*
00:55:19 <liujingtu> gfixler: 'bimap(x, y,  (a, b)  )' means '( x(a), y(b) )' ?
00:55:47 <gfixler> yes
00:55:51 <gfixler> you can see it in the type
00:55:56 <gfixler> :t bimap
00:55:58 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
00:56:02 <gfixler> think from right to left
00:56:16 <gfixler> you're going to get out a Bifunctor p of a b and a d
00:56:21 <gfixler> where can you get a b and a d?
00:56:32 <gfixler> from those two functions, but they need an a and a c
00:56:37 <gfixler> where can they get those?
00:56:43 <gfixler> from the input Bifunctor p
00:57:12 <liujingtu> Thank you. I understand. :)
00:57:21 <gfixler> :)
00:57:23 <tsahyt> Before I start conjuring up my own, does anyone know a library providing a data structure which lends itself to storing timed events (having a start time and an end time) which lets me find overlapping events quickly and provides quick insertion and deletion (log(n)-ish at worst)?
01:00:10 * hackagebot gore-and-ash-demo 1.0.0.0 - Demonstration game for Gore&Ash game engine  https://hackage.haskell.org/package/gore-and-ash-demo-1.0.0.0 (NCrashed)
01:04:59 <nut> is it possible in ghci to check whether something is a Monoid or any other type class?
01:05:17 <tsahyt> nut: :info lists all the type classes a type belongs to
01:05:18 <shachaf> Yes, with :i
01:05:28 <nut> :t "hello" only tells me that it is [Char]
01:05:30 <lambdabot>     Not in scope: ‘tells’
01:05:30 <lambdabot>     Perhaps you meant ‘tell’ (imported from Control.Monad.Writer)
01:05:30 <lambdabot>     Not in scope: ‘me’
01:05:59 <tsahyt> :i String
01:06:04 <tsahyt> but lambdabot doesn't support that
01:06:20 <tsahyt> for good reason too, because the output can be quite long
01:07:12 <nut> tsahyt, :info String
01:07:20 <nut> doesnt say that
01:07:50 <nut> String is Monoid, but I can not find this information without checking the doc in hackage
01:09:23 <cocreature> nut: :info []
01:09:27 <cocreature> String is only a type synonym
01:09:38 <cocreature> you might need to import Data.Monoid first
01:09:58 <tsahyt> Ah right you need to expand the type synonym first apparently.
01:11:26 <nut> ok
01:23:43 <nut> there's a  m a where m is monad and a is string, how do i print a in ghci?
01:27:26 <shachaf> Print a type?
01:27:51 <zomg> nut: I think the important question is what type is m :)
01:28:09 <nut> the type didn't define itself to be printable
01:28:25 <shachaf> What do you mean by print a?
01:28:25 <nut> doesn't derive from Show
01:29:09 <zomg> Usually if you want to print a string that's within some monad, you would have to get the value from the monad first (unless it's IO)
01:29:09 <nut> shachaf, I have ContentAPI String, and for debugging , i wnat to see the String inside the result
01:29:32 <shachaf> Vocabulary: "derive" is used in the sense of "figure out" in Haskell. Types don't "derive from" classes. They can be instances of classes.
01:29:46 <shachaf> Well, I don't know what ContentAPI is, but for most monads that doesn't make sense.
01:29:53 <nut> type ContentApi a = ReaderT ApiConfig (ResourceT IO) a
01:29:57 <shachaf> A value of type "m a" doesn't contain a value of type "a".
01:30:10 <shachaf> Yes, it definitely doesn't make sense in that case.
01:30:27 <shachaf> @quote /bin/ls
01:30:27 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
01:35:13 <saurabhnanda> I'm back :)
01:35:25 <saurabhnanda> can anyone help me with this code-golfish question: https://github.com/vacationlabs/nightwatch/blob/master/nightwatch.hs#L211-L213
01:35:55 <saurabhnanda> if the file does not exist I want the function to return (Left PIDFileNotFoundError)
01:36:12 <saurabhnanda> if there is an error in parsing the file, I want the function to return (Left PIDFileParseError)
01:36:31 <saurabhnanda> for anything else, it can raise an error which will need to be handled by a higher level function
01:36:47 <saurabhnanda> however, right now, I'm unable to "trap" the parse error.
01:37:23 <saurabhnanda> don't know how I can fmap the following -- try (\e -> Just PIDFileParseError) (read :: Integer) into it
01:37:58 <nut> ReaderT env Action result, so in ReaderT ,   it reader from environment and perform action and return a result. how can we check the result in ghci, that means the IO monad ?
01:40:55 <saurabhnanda> hmm, no one?
01:41:14 <A8444-Guest> i am
01:43:10 <dsub> saurabhnanda: the type of read  is "Read a => String -> a" so I guess that (read :: Integer) isn't correct
01:44:08 <dsub> saurabhnanda: Maybe this instead: "\a -> read a :: Int"
01:44:29 <nut> when do people use the blaze builder package?
01:44:41 <saurabhnanda> dsub: let me try that, but how do I fmap it with a wrapping tryJust call?
01:46:20 <A8444-Guest> guys how to get into oracle finance
01:46:25 <A8444-Guest> like job
01:47:13 <A8444-Guest> consultant
01:47:37 <dsub> Haven't used it, but from its type it will result in an Either, which should be fine to fmap (\a -> read a :: Int) over. Perhaps you're trying to fmap over tryJust partially applied?
01:48:05 <A8444-Guest> guys anyone
01:48:15 <srhb> A8444-Guest: This channel is about the Haskell programming language.
01:48:33 <A8444-Guest> but if u know
01:48:41 <A8444-Guest> it might be helpfu
01:48:44 <A8444-Guest> helpful
01:48:45 <srhb> Then it would still be off topic for this channel. :)
01:57:05 <liujingtu> Hi. I want to get the multiples of 3 or 5 below 100, so I write this code (just 5 lines): http://paste.ubuntu.com/14629096/
01:57:30 <liujingtu> But it is wrong. How to correct it?
02:00:13 <dsub> liujingtu: this should work "takeWhile (< 100) [x * y | x <- [3,6..] , y <- [5,10..]]"
02:00:43 <tsahyt> solving fizzbuzz I assume?
02:01:13 <liujingtu> dsub: It works, thank you. :)
02:01:34 <liujingtu> dsub: Can't I assign after '|' ?
02:01:50 <liujingtu> tsahyt: Yes
02:02:49 <dsub> liujingtu: In your example you have a "n = x * y", which I belive is causing you problems. 
02:03:10 <liujingtu> Yes. Is it invalid?
02:03:43 <dsub> Yes, unless you use the keyword "let". But at that point I would consider do-notation over a list-comprehension.
02:08:32 <dsub> liujingtu: And for the most idiomic solution to the problem I think it's better to use "takeWhile (< 100) $ map (*3) [5,10..]"
02:08:52 <tsahyt> I've got a vector which is conceptually a Vector Bool, but that seems wasteful in terms of space usage. How would I represent a bit vector in Haskell?
02:09:11 <liujingtu> dsub: I think it would lost *6, *9, etc.
02:09:54 <dsub> liujingtu: but 6 * 5 == 3 * 10.
02:10:59 <liujingtu> dsub: Yes. I should think deeply. :)
02:11:34 <srhb> tsahyt: As long as they are unpacked, that doesn't sound wasteful?
02:11:40 <Reshi> How can I make a cabal sandbox use the package installed in the user package database (~/.cabal) instead of trying to download the same package from hackage? I have a working patched version of llvm-general-3.5.1.0 in ~/.cabal, but it is not available inside the sandbox.
02:12:02 <tsahyt> srhb: Why, does that acutally compile to 1 bit per entry?
02:12:16 <tsahyt> I'd have imagined a Bool takes at least a byte of space
02:15:27 <puregreen> tsahyt: an unboxed Vector might pack Bools efficiently, or it might not
02:15:45 <puregreen> it may turn out that the bit-packing is slow, for instance
02:15:49 <liujingtu> I am puzzled: Why '[ n | n <- [ 1 .. 100  ], n <- [ 1 .. 1000 ] ]' is infinity?
02:15:58 <srhb> tsahyt: Oh, right. Not sure.
02:16:34 <srhb> liujingtu: It's not
02:17:14 <srhb> > length [ n | n <- [ 1 .. 100  ], n <- [ 1 .. 1000 ] ]
02:17:16 <lambdabot>  100000
02:17:23 <puregreen> tsahyt: I looked at the source and it uses a byte for each Bool
02:17:57 <liujingtu> srhb: Yes. But my WinHugs kept outputing after I entered it.
02:18:07 <srhb> liujingtu: Well, it is a long list.
02:18:40 <srhb> liujingtu: But it's certainly not infinitely long. It's 100 lists of [1..1000]
02:19:31 <liujingtu> srhb: Why it was not [ 1 .. 100 ] ? n<- 1..100 && n<- 1..1000
02:19:48 <srhb> liujingtu: Because that's not how list comprehensions work.
02:20:13 <srhb> Consider this instead
02:20:43 <puregreen> tsahyt: for bit-vectors, look at https://hackage.haskell.org/package/bitvec-0.1.0.1
02:20:45 <srhb> > [ (i,j) | i <- [1..10], j <- [1..10]]
02:20:47 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(2...
02:20:56 <srhb> liujingtu: Do you see what's going on now?
02:20:59 <srhb> In fact, let's make it shorter
02:21:11 <srhb> > [ (i,j) | i <- [1..3], j <- ['a'..'c']]
02:21:12 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
02:21:15 <tsahyt> puregreen: Thanks. I guess I'll stick with the Vector Bool for now and look into bit vectors when space becomes an issue. That way I can use the API that I know for a proof of concept first.
02:21:32 <puregreen> bitvec gives you the same API
02:21:35 <liujingtu> srhb: I understand this list.
02:21:44 <puregreen> it doesn't define a separate Vector type
02:21:48 <srhb> liujingtu: Same thing is happening in your example, you're just shadowing the 'n' name
02:21:52 <srhb> liujingtu: Which might be confusing
02:21:55 <puregreen> you can use vector to operate on Vector Bits
02:21:59 <srhb> > [ (i,i) | i <- [1..3], j <- ['a'..'c']]
02:22:01 <lambdabot>  [(1,1),(1,1),(1,1),(2,2),(2,2),(2,2),(3,3),(3,3),(3,3)]
02:22:03 <srhb> See?
02:22:13 <srhb> > [ (i,i) | i <- [1..3], i <- ['a'..'c']]
02:22:15 <lambdabot>  [('a','a'),('b','b'),('c','c'),('a','a'),('b','b'),('c','c'),('a','a'),('b',...
02:22:21 <puregreen> it just defines an instance of Vector for Bit that is more densely packed than an instance of Vector for Bool
02:22:24 <liujingtu> srhb: Wow.
02:22:50 <liujingtu> srhb: I understand how it works now. Thank you. ;)
02:22:58 <srhb> liujingtu: So nothing strange is going on. The combination will still happen, even if you can no longer access the other name because it's shadowed.
02:23:01 <srhb> liujingtu: You're welcome.
02:23:14 <puregreen> but yep, switching from one to another is easy so you can use Bool first
02:29:05 <yetanothernewbie> 	can anyone with attoparsec experience help me debug my code?
02:29:44 <srhb> yetanothernewbie: If your lpaste.net your problem, I'm sure someone can look at it.
02:31:01 <yetanothernewbie> srhb: http://lpaste.net/7552649013049163776
02:31:27 <yetanothernewbie> I'm sure I'm doing something very wrong somewhere
02:32:24 <yetanothernewbie> it's supposed to writeout "true" if the input is 4 different numbers
02:33:26 <srhb> yetanothernewbie: Well, what do you think is causing the compile error?
02:33:54 <yetanothernewbie> a type mismatch?
02:34:10 <yetanothernewbie> I can't quite put my finger on it
02:35:09 <srhb> yetanothernewbie: I think it would help you if you put type signatures on all your top level declarations :)
02:36:31 <Gurkenglas> "ghc groupBy.hs -ddump-inlinings -dsuppress-all -ddump-to-file ./dump.txt" what do I have to change about this line to get inlining info on Ubuntu 14.04?
02:40:03 <cocreature> is there something nice for dropping the last n elements of a list?
02:40:55 <cocreature> so nicer than reverse . drop n . reverse
02:44:34 <Gurkenglas> Might be a code smell. Is there a reason not to keep the list reversed in the first place? Or are you parsing a string and know that the last n characters are irrelevant?
02:45:04 <cocreature> Gurkenglas: I have a shake rule that matches *_1.c and I need to drop the last four characters and replacet hem
02:45:07 <cocreature> *replace
02:45:17 <cocreature> so I know that there are four characters at the end
02:45:44 <Gurkenglas> I don't know what a shake rule is, but if it matches "_1.c", it should remove that string while matching it
02:47:00 <cocreature> well it doesn’t and if there are more complicated patterns (think of some disjunction) it wouldn’t make sense to remove it.
02:47:02 <ClaudiusMaximus> cocreature: dropFromEnd n xs = zipWith const xs (drop n xs)
02:47:41 <cocreature> ClaudiusMaximus: ah that’s nice thanks
02:50:38 <saurabhnanda> okay, back again after a power outage
02:50:47 <jle`> cocreature: i have been reverse . drop 4 . dereverse
02:50:52 <jle`> *have been using
02:50:59 <jle`> er, s/dereverse/reverse
02:51:18 <jle`> but...that's much better, ClaudiusMaximus  >_>
02:51:48 <cocreature> jle`: yeah I have too so far, but after writing it another time I’ve gotten so annoyed that I asked here :)
02:55:02 <ClaudiusMaximus> jle`: i picked it up from this channel some time
02:55:41 <liujingtu> Hi. I want to find all the multiples of 1, 3 or 5 below 10, and I wrote the code below.
02:55:46 <liujingtu> > takeWhile (< 10) [ x*y | x <- (1:[3, 6  .. ]), y <- (1:[5, 10 .. ]) ]
02:55:48 <lambdabot>  [1,5]
02:55:56 <liujingtu> But where is 3, 6, 9 ?
02:56:19 <jle`> liujingtu: look at what order the list comprehension gives its results as
02:56:54 <jle`> > [(x,y) | x <- (1:[3,6 ..]), y <- (1:[5, 10 .. ]) ]
02:56:56 <lambdabot>  [(1,1),(1,5),(1,10),(1,15),(1,20),(1,25),(1,30),(1,35),(1,40),(1,45),(1,50),...
02:57:37 <liujingtu> jle`: Thank you. :)
02:58:15 <fr33domlover> Is there a nice way to write "case x of Nothing -> return (); Just s -> putStrLn "hello " ++ s"    ?
02:58:26 <fr33domlover> i.e. get rid of the return ()
02:58:39 <fr33domlover> I usually write a function whenJust for that :P
02:58:41 <jle`> fr33domlover: mapM_
02:58:44 <puregreen> fr33domlover: “for_ x $ \s -> putStrLn "hello " ++ s”
02:58:52 <Rembane> fr33domlover: Also checkout the functions in Data.Maybe.
02:58:58 <jle`> or traverse_, or forM_, for_
02:59:14 <jle`> fr33domlover: yours would be forM_ x $ \s -> putStrLn "hello" ++ s
02:59:18 <puregreen> I wish we had a whenJust, tho
02:59:42 <jle`> or mapM_ (putStrLn . ("hello" ++)) x
03:00:02 <saurabhnanda> okay, now I'm officially struggling with error handling
03:00:07 <jle`> puregreen: why not forM_/mapM_/for_/traverse_ with const?
03:00:15 <fr33domlover> jle`, puregreen, Rembane : thanks!
03:00:47 <puregreen> jle`: with const?
03:01:01 <jle`> mapM_ (const (blah blah blah)) x
03:01:08 <jle`> whenJust
03:01:27 <jle`> or forM_ x $ \_ -> blah blah blah
03:01:57 <puregreen> no, I mean, my whenJust would be the same as for_, no const needed
03:01:59 <puregreen> whenJust :: Applicative m => Maybe a -> (a -> m ()) -> m () 
03:02:05 <fr33domlover> jle`, whenJust could be nice much like 'map' for lists is nice
03:02:22 <puregreen> yep, what fr33domlover said
03:02:47 <jle`> hm, i guess; but the main reason map is nice is because everyone immediately recognizes map
03:03:00 <jle`> whenJust would be just a specialized obscure version that people would have to look up to know what it means
03:03:09 <jle`> wheras, everyone immediately recognizes forM_, etc.
03:03:14 <puregreen> hm
03:03:23 <jle`> fairnbain threshold or something like that
03:03:31 <fr33domlover> jle`, but forM_ makes people think about list/set/etc. traversal
03:03:39 <fr33domlover> while here's it an optional single value
03:03:41 <saurabhnanda> how do I get this to compile: (tryJust (\e -> Just PIDFileParseError)fmap $ (fmap (tryJust (\e -> Just PIDFileParseError) read)) (tryJust (\e -> if isDoesNotExistError e then (Just PIDFileNotFoundError) else Nothing) $ readFile fname)
03:03:51 <fr33domlover> so it can be confusing when reasing someone's code
03:03:53 <saurabhnanda> sorry: fmap $ (fmap (tryJust (\e -> Just PIDFileParseError) read)) (tryJust (\e -> if isDoesNotExistError e then (Just PIDFileNotFoundError) else Nothing) $ readFile fname)
03:04:04 <jle`> fr33domlover: people use forM, mapM on Maybe's all the time?
03:04:21 <jle`> Maybe is like everyone's second Traversable/Foldable instance people learn
03:04:36 <jle`> it's like the most common usage of traversable/foldable stuff, after [], heh
03:04:41 <fr33domlover> jle`, if that's the case it's ok :P
03:05:00 <jle`> it's the most common usage of mapM_/forM_ after [], i think
03:05:05 <fr33domlover> i somehow never used Foldable and Traversable over Maybe until now
03:05:17 <fr33domlover> (but i did use Functor a lot)
03:05:33 <jle`> you can think of Maybe's Foldable instance as treating Maybe as a list of 0 or 1 elements
03:05:51 <jle`> saurabhnanda: why don't you try using pattern matching and do notation, instead of a bunch of fmaps
03:05:55 <jle`> it just makes everything less readable, heh
03:06:20 <fr33domlover> reaching 2025 as i predicted! when fmap conquers the world
03:06:26 <jle`> especially as a huge one-liner
03:06:27 <fr33domlover> s/world/The Fmap/
03:06:29 <saurabhnanda> jle`: I'm trying to incease my Haskell-fu
03:06:30 <puregreen> I have used for_ for Maybe but I haven't ever seen anybody else do it, and I only learned about it after reading some thread on haskell-cafe about whenJust. Also, at least for me it's intuitively obvious what whenJust does
03:06:43 <saurabhnanda> jle`: I want to feel the power of monads running through my veins
03:07:07 <jle`> using do notation would definitely be considered harnessing the power of monads :P
03:07:10 <puregreen> so I guess I'll keep using case until I see evidence that people are comfortable with for_
03:07:21 <jle`> puregreen: well, at least one person got the wrong impression of what whenJust is supposed to do :)
03:07:34 <saurabhnanda> jle`: in the Either monad/functor world, does everything operate on the Right value? Does anything operate on the Left value, ever?
03:07:45 <Gurkenglas> saurabhnanda, why all those tries? What do you do with those Left values except crashing the program?
03:07:47 <jle`> hm, i see mapM_ forM_ pretty often for Maybe
03:07:51 <jle`> but ymmv
03:08:04 <jle`> saurabhnanda: it can't, because of the way the instances are
03:08:13 <jle`> note that the Functor/Monad is (Either e)
03:08:22 <jle`> so any Functor/Monad instance methods must leave the e unchanged
03:08:32 <saurabhnanda> Gurkenglas: basically, I want to ensure that the calling function handles these two particular Left values. Type-checked at compile-time. Other errors can crash -- doesn't matter.
03:08:34 <jle`> fmap :: (a -> b) -> (Either e) a -> (Either e) b
03:08:36 <jle`> etc.
03:09:05 <jle`> (>>=) :: (Either e) a -> (a -> (Either e) b) -> (Either e) b
03:09:18 <jle`> the (Either e) part must remain unchanged/untouched
03:09:30 <saurabhnanda> jle`: doesn it need the type of 'e' to remain unchanged or the value of 'e'
03:10:01 <jle`> well, all of the instances work for *all* e
03:10:17 <jle`> so, there's no way to change the value of any e in a way that works for all e's, polymorphically
03:10:21 <saurabhnanda> so, if the inner tryJust returns (Right "x") the outer tryJust SHOULD return (Left PIDFileParseError)
03:10:43 <jle`> if we had instance Functor (Either String) where ... , then we could have fmap _ (Left x) = Left "i changed the string"
03:10:47 <jle`> but, we don't have that
03:11:00 <jle`> we have instance Functor (Either e) where ..., so whatever we implement has to work for *all* e's
03:11:12 <jle`> so we don't have any way to modify any e values we have
03:11:13 <saurabhnanda> jle`: is there any function worked with the (Either e) that inverts Left to Right or vice versa?
03:11:17 <jle`> (this is called parametric polymorphism)
03:11:22 <jle`> saurabhnanda: yes
03:11:37 <jle`> swapEither :: Either e a -> Either a e; swap (Left x) = Right x; swap (Right x) = Left x
03:11:43 <jle`> or
03:11:46 <jle`> :t either Right Left
03:11:48 <lambdabot> Either b a -> Either a b
03:11:54 <jle`> there are bunches of them! :D
03:12:09 <saurabhnanda> no, I mean conditionally
03:12:18 <jle`> this is conditionally...
03:12:33 <jle`> there's also bimap, that maps over left's and right's
03:12:43 <jle`> > bimap (+2) (+3) (Left 10)
03:12:45 <lambdabot>  Left 12
03:12:45 <saurabhnanda> so, conceptually, the problem I'm dealing with is (Right "x") should result in (Left PIDFileParseError) 
03:12:56 <jle`> sounds like a job for pattern matching! :D
03:12:58 <mniip> :t (&&&)
03:13:00 <saurabhnanda> and... (Left PIDFileNotFoundError) should result in (Left PIDFileNotFoundError)
03:13:00 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
03:13:05 <mniip> :t (+++)
03:13:08 <lambdabot>     Ambiguous occurrence ‘+++’
03:13:08 <lambdabot>     It could refer to either ‘Control.Arrow.+++’,
03:13:08 <lambdabot>                              imported from ‘Control.Arrow’ at /home/lambda/.lambdabot/State/L.hs:43:1-20
03:13:11 <mniip> dammit
03:13:17 <saurabhnanda> and... (Right "1") should result in (Right 1)
03:13:29 <jle`> saurabhnanda: you could write something using `either`, but pattern matching is likely a more readable solution here
03:13:32 <saurabhnanda> :t tryJust
03:13:34 <lambdabot> Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
03:13:42 <saurabhnanda> ooh, lambdabot is good
03:13:46 <mniip> :t (Control.Arrow.+++)
03:13:48 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
03:13:48 <mniip> this one
03:13:49 <jle`> case foo of Left e -> blah blah; Right x -> blah blah
03:14:18 <jle`> :t either
03:14:20 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
03:14:37 <saurabhnanda> jle`: I know, I know. But that's feeling too imperative to me. As I said, I want to feel the power of monads and monad-transformers :)
03:14:50 <jle`> hm, i'm not sure what's imperative about this
03:14:55 <jle`> this is as "functional" as it gets
03:14:58 <jle`> if that even means a thing
03:15:09 <saurabhnanda> as in, it feels like a big if-elseif block
03:15:17 <Jinxit> either can't change a Right into a Left, can it?
03:15:20 <jle`> you can use `either`
03:15:22 <mniip> what does that have to do with imperativity
03:15:27 <jle`> Jinxit: yes, it can -- either Right Left
03:15:42 <jle`> > (either Right Left) (Left 10)
03:15:43 <Jinxit> oh okay
03:15:45 <lambdabot>  Right 10
03:16:07 <saurabhnanda> ?
03:16:29 <jle`> saurabhnanda: i suppose you can use (>>=) to "continue" from a Right result and choose to fail from the reuslt or not
03:16:44 <jle`> (>>=) :: Either e a -> (a -> Either e b) -> Either e b
03:17:07 <jle`> > Right 1 >>= \x -> if even x then Left ":(" else Right (x*2)
03:17:12 <lambdabot>  Right 2
03:17:18 <jle`> > Right 2 >>= \x -> if even x then Left ":(" else Right (x*2)
03:17:21 <lambdabot>  Left ":("
03:17:28 <jle`> > Left ":)" >>= \x -> if even x then Left ":(" else Right (x*2)
03:17:30 <lambdabot>  Left ":)"
03:17:44 * mniip . o O ( (Bifunctor p, Arrow a) => a b d -> a c e -> a (p b c) (p d e) )
03:17:58 * jle` . o O ( i wish type inference never worked ever )
03:18:19 <jle`> :)
03:18:36 <Gurkenglas> jle`, but then who would have noticed that Lens' s a can be expanded to Lens s t a b?
03:18:58 <jle`> hm?
03:19:24 <jle`> oh i was making a sort of dumb joke that such a function a b c -> a c e -> a (p b c) (p d e) would be a nightmare for type inference
03:19:54 <jle`> *a b d
03:20:10 <nut> jle`,  when do people use the blaze builder package?
03:20:32 <mniip> hmm
03:20:39 <mniip> it looks like a bifunctor is not enough
03:20:48 <mniip> needs to be a bitraversable if anything
03:21:10 <nut> data ApiConfig = ApiConfig {...}, one of the field is defined as a Builder
03:21:17 <nut> but I can't understand why
03:29:04 <ruf> anyone here who can help me out with some of the challenges at http://mightybyte.github.io/monad-challenges/ ?
03:36:17 <vektor> What's the name of the haskell gamedev IRC channel again?
03:37:04 <vektor> nevermind, trial and error got me there eventually.
03:42:37 <nut> [] and (:) defines each other, is this logic ?
03:42:58 <mniip> what
03:43:02 <nut> defines each other using each other
03:43:25 <mniip> [] and (:) are constructors
03:43:42 <mniip> they have no implementation, they are declared by simply saying that they are
03:45:02 <nut> data [] a = [] | a : [a]
03:45:09 <nut> i can see that [] is a constructor
03:45:23 <nut> but a : [a] ?
03:45:40 <mniip> that's the infix constructor definition
03:45:46 <mniip> it could say
03:45:52 <mniip> data [] a = [] | (:) a [a]
03:46:45 <nut> what is [a] then
03:46:50 <mniip> ([] a)
03:46:54 <nut> [a] = [] a
03:46:55 <nut> ?
03:47:00 <mniip> yes
03:47:18 <mniip> this is slightly more confusing because [] and : are built-in syntax, and [] is the type while [] is the constructor
03:47:18 <dlight> Does anyone here use the ArchHaskell repository? Is appears to be offline.. is there a mirror somewhere?
03:47:19 <nut> but [] doesnt take any argument
03:47:22 <mniip> consider instead:
03:47:23 <mpickering> nut: there two things going on
03:47:30 <mniip> data List a = Nil | Cons a (List a)
03:48:05 <mpickering> [] is defined as both a type constructor and a data constructor 
03:48:41 <nut> as a data constructor it doesn't take any paramter right ?
03:49:15 <mniip> yes, it is nullary
03:49:39 <nut> so (:) a [a] = (:) a ([] a)
03:49:54 <nut> which isnt correct
03:50:47 <nut> because ([] a) is not a data
03:51:06 <mniip> you're mixing data constructors with type constructors
03:51:14 <mniip> once again, consider this definition instead
03:51:17 <mniip> [14:47:07] <mniip> data List a = Nil | Cons a (List a)
03:51:21 <nut> ok
03:57:27 <mpickering> So what he means to say is that "List"  is a type constructor,  Nil and Cons are data constructors
03:57:57 <mpickering> Because they live in different name spaces, you can use the same names for type and data constructors
04:00:50 <nut> [] means List the type constructor and Nil the data constructor
04:01:01 <nut> thats why its confusing
04:01:08 <mniip> yes
04:02:33 <vektor> nut: In usual haskell though, you only see [a] as the type constructor. The prefix version isn't usually seen (unless you're defining the list type, I think)
04:02:33 <nut> how does ghc tell the difference ? according to the context ? 
04:03:06 <vektor> nut: Yeah. They're in different namespaces. In a program, there's never any ambiguity about whether to expect a type or data constructor
04:03:29 <vektor> * expect a type constructor or data constructor (just to be clear)
04:04:21 <nut> ok
04:05:03 <Gurkenglas> How do I make ghc dump inlining info? "ghc groupBy.hs -ddump-inlinings -dsuppress-all" doesnt seem to do anything except compiling.
04:06:34 <nut> so all these abstraction in Haskell are supposed to bring flexibility in programming ?
04:06:47 <nut> i feel like doing algebras
04:09:47 <srhb> nut: Yes, and better tools for analyzing your programs. :)
04:10:21 <Rembane> nut: It also lets you find the bugs at compile time rather than the user at runtime.
04:12:03 <k0ral> Hello
04:12:11 <Black0range> Hello from the other side!
04:12:30 <k0ral> it looks like "DEPRECATED" pragma doesn't work correctly on type synonyms
04:13:31 <k0ral> {-# DEPRECATED T "blah blah #-} will deprecate the *data constructor* T, but not the *type synonym* T
04:14:21 <k0ral> is that a known issue ?
04:14:58 <Black0range> k0ral: Hmmm, Not really sure it's an issue
04:15:17 <k0ral> Black0range: how should I deprecate the type synonym then ?
04:15:30 <Maxdamantus> What about the non-synonym type constructor T?
04:15:48 <Maxdamantus> ie, `data T = U`
04:17:15 <k0ral> there is an ambiguity if such type constructor exists, as a matter of fact
04:17:21 <k0ral> is it possible to lift it ?
04:18:23 <Black0range> k0ral: In my opinion, theres no need to do it. If type A = B if you DEPRECATE B then A is DEPRECATED too? 
04:18:42 <k0ral> Black0range: that's not exactly my situation
04:19:21 <k0ral> I have `type A = B; data B = A | B`
04:19:36 <k0ral> I want to deprecate `type A`
04:22:47 <Black0range> Hmm I can't help you there 
04:33:49 <k0ral> I'll settle with the fact that this is not possible
04:42:35 <puregreen> I need a Binary instance for my type, but I can't derive a Generic instance for it because it's a GADT; is there some example of writing a Binary instance for a GADT manually?
04:43:52 <puregreen> (or writing a Generic instance for a GADT, but I'm not sure it's possible)
04:44:11 <phadej> puregreen: in the docs: http://hackage.haskell.org/package/binary-0.8.0.0/docs/Data-Binary.html#g:2
04:44:35 <puregreen> how come I haven't noticed it
04:44:36 <puregreen> okay, thanks
04:44:54 <phadej> puregreen: you're welcome
04:45:30 * hackagebot yesod-core 1.4.19 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.19 (MichaelSnoyman)
04:56:01 <liujingtu> Hi. I'm creating Fibonacii sequence. Here are two pieces of codes: http://paste.ubuntu.com/14630350/
04:56:12 <liujingtu> Why program A is much faster than program B?
04:57:52 <puregreen> phadej: can you add an instance of Binary for AbsoluteTime in binary-orphans, or would it be better if I made a pull request? (AbsoluteTime is simply a newtype for DiffTime)
04:59:23 <puregreen> (asking because e.g. for me it's often easier to do something by myself than to bother with merging pull requests, but others often have different preferences)
04:59:28 <saurabhnanda> back again :-)
04:59:39 <saurabhnanda> are there any restrictions in currying tryJust?
05:01:05 <saurabhnanda> is there any way to search functions by function signature?
05:01:26 <puregreen> yep
05:01:27 <puregreen> @hoogle
05:01:29 <lambdabot> No query entered
05:01:29 <lambdabot> Try --help for command line options
05:01:33 <saurabhnanda> thanks, got it
05:01:35 <puregreen> @where hoogle
05:01:35 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
05:03:13 <liujingtu> I found why it's faster. :)
05:05:15 <saurabhnanda> :t tryJust (\e -> (Just PIDFileParseError)) read
05:05:17 <lambdabot>     Not in scope: data constructor ‘PIDFileParseError’
05:06:24 <saurabhnanda> :t tryJust (\e -> Nothing) read
05:06:26 <lambdabot>     Couldn't match expected type ‘IO a’ with actual type ‘String -> a0’
05:06:26 <lambdabot>     Probable cause: ‘read’ is applied to too few arguments
05:06:26 <lambdabot>     In the second argument of ‘tryJust’, namely ‘read’
05:06:40 <saurabhnanda> can anyone tell me what's wrong with -- :t tryJust (\e -> Nothing) read
05:06:46 <saurabhnanda> why is it not being curried?
05:08:04 <hodapp> :t tryJust
05:08:05 <lambdabot> Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
05:08:17 <hodapp> :t read
05:08:19 <lambdabot> Read a => String -> a
05:09:32 <hodapp> that doesn't look like it's going to fit for 'IO a'
05:10:03 <mniip> you can't catch exceptions outside of the IO monad
05:10:13 <mniip> are you trying to supply a default value in case read fails?
05:10:51 <phadej> puregreen: please make a PR
05:12:09 <saurabhnanda> ah okay
05:13:11 <saurabhnanda> :t tryJust (\_ -> Nothing) (return read)
05:13:12 <lambdabot>     Could not deduce (Exception e0) arising from a use of ‘tryJust’
05:13:12 <lambdabot>     from the context (Read a)
05:13:12 <lambdabot>       bound by the inferred type of
05:13:49 <saurabhnanda> okay, what's the problem now? Why does tryJust care what the type of the caught exception is? I don't care -- I want to catch any and every exception that is thrown by read
05:14:19 <mniip> you're doing it wrong
05:14:24 <mniip> :)
05:14:35 <mniip> I think you want reads instead
05:14:36 <mniip> :t reads
05:14:38 <lambdabot> Read a => ReadS a
05:14:59 <mniip> = String -> [(a, String)]
05:15:03 <puregreen> or readMaybe
05:15:06 <puregreen> :t readMaybe
05:15:07 <lambdabot> Not in scope: ‘readMaybe’
05:15:14 <puregreen> aw c'mon
05:15:21 <puregreen> anyway, readMaybe :: Read a => String -> Maybe a
05:15:42 <saurabhnanda> puregreen: don't need readMaybe because stringing it to my next function would be tougher
05:15:52 <saurabhnanda> aargh
05:15:57 <saurabhnanda> I give up
05:16:08 <saurabhnanda> does anyone know what error does this throw -- read "a" :: Integer
05:16:44 <saurabhnanda> for example, to check for a file-not-found-error I can use isDoesNotExistError
05:16:55 <saurabhnanda> how to I check for parse error? what's the predicate? where is this documented?
05:17:26 <int-e> :t GHC.Read.readMaybe -- not standard Haskell?
05:17:27 <lambdabot> Not in scope: ‘GHC.Read.readMaybe’
05:17:33 * int-e shrugs
05:18:04 <puregreen> int-e: well, it's in Text.Read actually
05:18:25 <int-e> puregreen: thanks, I should've known.
05:19:23 <saurabhnanda> anyone knows what error "read" throws?
05:19:36 <saurabhnanda> is there a way to figure out what errors a function can throw in the ghci?
05:20:58 <int-e> @src read
05:20:58 <lambdabot> read s = either error id (readEither s)
05:21:12 <int-e> hmm, not helpful.
05:23:16 <puregreen> saurabhnanda: the error type is ErrorCall; i.e. the error is generic and you can't test it for being a parse error or whatever
05:23:37 <puregreen> you have several options now
05:24:38 <puregreen> option 1: when catching exceptions, just print ErrorCalls as “generic error happened, here's error message”. This will catch the exception during “read”
05:25:06 <int-e> saurabhnanda: the basic function is reads (or readsPrec): read a = case [x | (x,y) <- reads a, all isSpace y] of [x] -> x | [] -> error "no parse" | _ -> error "ambiguous parse"  should reflect read's actual behavior.
05:25:57 <puregreen> option 2: detect the fact that error happened during read (by using readEither and then throwing an error of your own custom type) and then handle it as you wish later
05:27:25 <puregreen> as for your other question: you can't figure out what kinds of exceptions a function *can* throw in GHCi, but you can find out what is the type of an exception if you can cause that exception to happen
05:27:49 <puregreen> by doing something like this:
05:27:51 <puregreen> handle (\(SomeException e) -> print (typeOf e) >> undefined) (evaluate (read "a" :: Integer))
05:28:35 <puregreen> this module has a list of predefined types of exceptions that you can detect: http://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html
05:29:09 <puregreen> (e.g. division by zero would be an ArithException, not a generic ErrorCall)
05:29:55 <puregreen> most exceptions thrown by pure functions (like head, read, etc) are going to be ErrorCalls; there isn't some fine-grained hierarchy of exceptions for those functions
05:31:32 <nut_> i'm in a sandbox, how do i cabal repl with ghci already loaded with :set -XOverloadedStrings
05:31:52 <nut_> i dont want to do it over and over
05:32:49 <puregreen> saurabhnanda: if you post some pseudocode (even if very crude) that uses read and handles exception the way you want to handle them, we'd be able to help you better
05:34:19 <puregreen> nut_: create a .ghci file in your sandbox folder
05:34:56 <saurabhnanda> puregreen: https://github.com/vacationlabs/nightwatch/blob/master/nightwatch.hs#L211-L213
05:35:12 <puregreen> nut_: containing a single line “:set -XOverloadedStrings”
05:35:19 <puregreen> might work
05:35:38 <saurabhnanda> puregreen: that function can return one of the three things: IO (Right 1231231) -- successful case.
05:35:56 <saurabhnanda> puregreen: error case 1, when fname doesn't exist -- IO (Left PIDFileNotFoundError)
05:36:14 <saurabhnanda> puregreen: error case 2, when fname exists, but there's a parse error -- IO (Left PIDFileParseError)
05:36:38 <saurabhnanda> saurabhnanda: in the current code, the read error is not being trapped and converted to (Left PIDFileParseError)
05:39:59 <Gurkenglas> How do I make ghc dump inlining info? "ghc groupBy.hs -ddump-inlinings -dsuppress-all" doesnt seem to do anything except compiling.
05:42:05 <saurabhnanda> puregreen: any way?
05:43:41 <MarcelineVQ> Gurkenglas: if it's already built you probably need to -fforce-recomp as one of the flags, afaik it's a bug though I haven't made a report for it
05:44:03 <puregreen> saurabhnanda: a sec
05:45:58 <MarcelineVQ> Gurkenglas: -dsuppress-all is for core dumps though and I dn't think you're asking for a core dump?
05:46:07 <Gurkenglas> That worked, thanks. Hmm that doesn't look like I wanted. I wanted the code after ghc is done inlining. I'll try this ghc-core thing google gave
05:48:04 <MarcelineVQ> -ddump-simpl may be what you're after, or the other simpl flag, I think inlining is done by the simplifier
05:48:33 <MarcelineVQ> not sure though :>
05:50:19 <saurabhnanda> how do I pattern match on IO (Either a b) -- I want to pattern match on the Either part, but inside the IO monad
05:50:51 <fr33domlover> saurabhnanda, you can use do notation
05:50:52 <Gurkenglas> ohh nice thanks. What do I put after an ending | to redirect stdout into a .txt?
05:51:46 <fr33domlover> Gurkenglas, in a shell you do: somecommandhere param1 param2 param3 > lol.txt
05:53:52 <MarcelineVQ> ​> redirects from stdout to a file &> redirects from stderr to a file, but you can use -ddump-to-file to make your life easier, especially if you've requested multiple dumps
05:54:20 <puregreen> saurabhnanda: you can do something like this; it's ugly
05:54:21 <puregreen> http://lpaste.net/150770
05:55:24 <puregreen> you can also use ExceptT and wrapping Eithers and what-not and it's going to be cleaner but still overblown for a function that consists of a composition of only 2 error-throwing functions
05:55:30 <saurabhnanda> puregreen: that's exactly what I don't want to do. Using a bunch of cases, I had this code working in last night. But it didn't feel like it was Haskell-y enough. Where's the power of stringing together operations without having to write boilerplate error-handling code?
05:55:50 <srhb> MarcelineVQ: 2> for stderr, &> is stdout + stderr
05:55:55 <srhb> At least in bash.
05:55:59 <MarcelineVQ> good to know
05:57:24 <puregreen> saurabhnanda: Haskell has a sort of a duplication/simplicity tradeoff. For instance, when I was writing a Telegram bot I was using a monad stack that included error chaining, etc and I didn't have to chain any errors manually but the code had liftIO all over the place; but if all functions in the standard library used MonadIO instead of IO, it'd be less simple, so there's a compromise
05:59:02 <saurabhnanda> puregreen: I didn't understand what you said :)
05:59:31 <puregreen> (by the way, you should probably change bot's token after you write it and don't put it on Github in plaintext)
05:59:47 <saurabhnanda> puregreen: ya, I know :) let me get it working first!!
05:59:53 <puregreen> okay, I'll rephrase the thing I said
06:00:04 <Rouven> saurabhnanda: http://book.realworldhaskell.org/read/error-handling.html Have you read the section "Monadic use of Either" ?
06:02:57 <puregreen> saurabhnanda: for instance, let's say “type Except e a = IO (Either e a)” (since using Either for handling errors is a common pattern). In your case, for instance, it'd be ideal to break your function into “tryReadFile :: Filename -> Except PIDFileError String” and “tryRead :: String -> Except PIDFileError Integer”
06:03:36 <puregreen> saurabhnanda: the nice thing about Except is that it's easy to combine several actions that use Except automatically, and you don't have to handle Left/Right manually
06:04:21 <saurabhnanda> I tried this approach earlier
06:04:41 <puregreen> the not-nice thing about Except is that in order to be able to use do notation (and other nice things) for it you have to make it a newtype
06:04:49 <puregreen> http://hackage.haskell.org/package/transformers-0.5.1.0/docs/Control-Monad-Trans-Except.html#t:ExceptT
06:05:29 <saurabhnanda> I got stuck at the following point  -- I needed a function which looked like this: myFunc :: (Either e String) -> (Either e Integer) BUT BUT BUT it should be allowed to change the value of 'e' as well
06:06:30 <puregreen> once it's a newtype, you suddenly can't use ordinary IO functions (like readFile or print) in it – you have to wrap them to return Right values. That's what liftIO does. You wouldn't have to use liftIO if all functions in standard libraries were *already* wrapped with liftIO, but they aren't
06:07:24 <puregreen> as for changing the value of ‘e’, that's what catchE does
06:07:25 <puregreen> http://hackage.haskell.org/package/transformers-0.5.1.0/docs/Control-Monad-Trans-Except.html#v:catchE
06:09:14 <puregreen> by the way
06:09:21 <puregreen> https://github.com/vacationlabs/nightwatch/blob/master/nightwatch.hs#L220
06:09:33 <puregreen> no, it'll work just fine
06:09:52 <puregreen> their API won't return messages that are already confirmed by you
06:10:12 <puregreen> so in fact you don't even have to save last update id anywhere
06:12:31 <t0by> I'm sorry - what do people mean with "lifting functions over something"?
06:21:03 * hackagebot hsdev 0.1.5.4 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.5.4 (AlexandrRuchkin)
06:39:16 <vektor> Does anyone know what's up with hackage? https://hackage.haskell.org/package/bullet-0.2.4 - there's no module documentation in this version. It exists for 0.2.3 though. I've seen this a lot recently.
06:45:03 <aweinstock> t0by: things like liftA2 "lift" functions into an applicative context, and things like liftIO "lift" an IO action into a generic (forall m. MonadIO m) action
06:47:28 <xkami> so
06:47:31 <xkami> what are monads?
06:47:47 <xkami> can't I just ignore them?
06:49:02 <srhb> xkami: You mostly can, yes. You lose some generality of thinking, though.
06:50:20 <xkami> srhb: I should probably learn some more
06:50:43 <srhb> xkami: You can just learn how to work with specific monads, and you'll be fine.
06:51:32 <xkami> srhb: I see, thank you
06:53:30 <adamCS> xkami: I think there's a good middle ground as well.  Where you understand something about the mechanics of monadic composition (bind and do-syntax), and some about applicative composition as well.  But you don't necessarily need to understand how each monad works.
06:53:48 <aweinstock> @where report
06:53:49 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
06:54:01 <xkami> adamCS: so there are different kinds..
06:54:11 <adamCS> xkami:  Though I think once you start to "get" it, you will end up wanting to understand more about the details.
06:54:12 <ggVGc> xkami: it's a generalization, which is useful when you get to it, but not in any way necessary for writing software. Most software in the world is written without much generalization and it's fine
06:54:47 <ggVGc> xkami: so short story is, you use the monads for specific things, without caring about that they are monads. And at some point you'll see the connection and how they are similar, and then you understand monads and can benefit from that
06:55:01 <adamCS> xkami: Well, mostly different ones. That is different types which are monadic.  There are also different kinds of monads but that goes other, weirder, places.
06:55:15 <aweinstock> here's the documentation on do-notation desugaring: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
06:55:20 <ggVGc> xkami: kind of like you can use STL in C++ without actually knowing much about templates, but at some point you start seeing the use of templates
06:55:24 <adamCS> xkami:  what ggVGc said!
06:55:57 <adamCS> adamCS: (but much more fun than C++ templates!)
06:56:12 <xkami> I see, thank you
06:56:20 <adamCS> talking to myself again...
06:56:28 <ggVGc> xkami: or that you can use numbers and letters for writing, but at some point you might realise that "character" is a generalisation over those terms that might be useful, but not necessary to be able to use numbers and letters
06:56:32 <ggVGc> anyway, I shoyuld stop now
06:56:41 <xkami> XD
06:56:58 <xkami> I just need to learn some more, it'll come eventually
06:57:03 <ggVGc> anyway, monads really aren't special. It's just a term for a group of things that are similar in some ways
06:57:18 <xkami> okay :D
07:00:28 <ggVGc> xkami: personally I think it's way more beneficial to understand Functor than Monad. Functor practially means "A thing that you can call map on", but that is actually something very very useful when you start embracing it
07:01:13 <aweinstock> :t fmap fmap fmap fmap fmap
07:01:15 <lambdabot> Functor f => (a1 -> b) -> (a -> a1) -> f a -> f b
07:01:15 <ggVGc> calling `map` on a list does somethign very different from calling map on a Maybe instance, but it's a very useful general concept
07:01:20 <Xandaros> Especially since a Monad is just a special case of a functor, it is a good idea to start there, I think
07:01:57 <ggVGc> Xandaros: yeah, that too, but in my experience Functor is the most useful generalisation
07:02:03 <ggVGc> as in useful in the most cases
07:02:39 <Xandaros> Well, I'd say applicative, but functor is definitely the easiest to understand. I didn't understand monads until I understood functor
07:03:00 <Xandaros> then it suddenly all made sense
07:03:18 <xkami> ggVGc: can't I call map on all functions
07:03:30 <ggVGc> hm, maybe, I'm not that into using Applicative yet, but I'm also fairly new to using Haskell seriously. While Functor is something I've been in contact with for a longer time in other contexts than haskell
07:03:46 <ggVGc> xkami: well, you always map a function over something, but that something is a functor
07:04:11 <xkami> ggVGc: I see, so a list is a functor?
07:04:19 <ggVGc> xkami: so you can call `map f myList` and `map f myMaybe` and it works in the general case, because bot Maybe and List are functors
07:04:21 <Xandaros> xkami: You got it!
07:04:22 <ggVGc> yes
07:04:28 <ggVGc> and this is very useful
07:04:32 <ggVGc> more useful than monads
07:05:03 <Rouven> I found http://learnyouahaskell.com to be excellent. It goes from Functors to Applicatives to Monads, and it's really really well explained. 
07:05:27 <nut_> how to cabal repl with main loaded ?
07:05:45 <Xandaros> My personal favourite is the typeclassopedia
07:05:49 <Xandaros> @where typeclassopedia
07:05:49 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
07:05:49 <xkami> Rouven: yeah, it has just been a lot to work through so I eventually stopped and slacked..
07:05:53 <srhb> nut_: What do you mean "with main loaded" ?
07:05:58 <srhb> nut_: The Main module?
07:06:05 <nut_> yes
07:06:09 <nut_> main module
07:06:13 <aweinstock> :t (\f -> (>>= (return . f))) `asTypeOf` fmap
07:06:14 <srhb> nut_: :load path/to/Main.hs
07:06:15 <lambdabot> Monad m => (a -> b) -> m a -> m b
07:06:27 <nut_> by default it loads all my libraries
07:06:30 <aweinstock> @pl  (\f -> (>>= (return . f)))
07:06:30 <lambdabot> fmap
07:08:15 <ggVGc> xkami: to be precise a functor is something you can call `fmap` on, while the function `map` is the special case of fmap for lists
07:08:42 <xkami> ggVGc: oh I see :D
07:08:45 <ggVGc> xkami: so `map` is "fmap for list" and `mapMaybe` is "fmap for Maybe"
07:09:01 <xkami> yeah awesome
07:09:37 <ggVGc> xkami: the difference is only that `map` takes a specialised type, in this case List, while `fmap` takes the general Functor type. But if you pass a list to fmap in the end the function `map` will be called
07:10:27 <ggVGc> xkami: but this lets you write a function that "maps over a thing and does something with the result" without caring about what the concrete implementation of "mapping" is
07:10:31 <ggVGc> and that's great
07:10:46 <nwolverson> ggVGc: surely mapMaybe isn't fmap? it relates Maybe and lists
07:11:01 <ggVGc> nwolverson: yeah, sorry, that was me usibng the wrong name
07:11:08 <Xandaros> :t mapMaybe
07:11:10 <lambdabot> (a -> Maybe b) -> [a] -> [b]
07:11:13 <ggVGc> yeah sorry
07:11:24 <xkami> so..
07:11:26 <xkami> what
07:11:30 <xkami> I don't get it
07:11:35 <xkami> is mapMaybe not fmap?
07:12:03 <Xandaros> mapMaybe is actually something different, but you can just use fmap for Maybe values
07:12:12 <xkami> oh okay
07:12:18 <ggVGc> xkami: I used the wrong term. I meant that you have one function that "maps over list" and one that "maps over Maybe" and `fmap` is the general form of those
07:12:26 <ggVGc> but yeah, the name mapMaybe was wrong
07:12:35 <xkami> ggVGc: okay I see :-)
07:12:37 <ggVGc> I'm still new to haskell and the standard library, but not to functors :)
07:12:37 <nwolverson> so for Maybe fmap would be   (a -> b) -> (Maybe a) -> (Maybe b)
07:12:57 <Xandaros> > fmap (+5) (Just 7)
07:12:59 <lambdabot>  Just 12
07:13:07 <Xandaros> Gotta have some examples :)
07:13:26 <ggVGc> xkami: the point is that the functor generalisation is  very often useful, because "mapping over something" is something you do a lot in functional languages, and by making the function take a Functor instance, you don't have to constrain it to i.e only Lists, but to anything that can be "mapped over"
07:13:26 <Xandaros> > fmap (+5) [7,8,9]
07:13:29 <lambdabot>  [12,13,14]
07:13:38 <xkami> > fmap (+5) (Nothing)
07:13:40 <lambdabot>  Nothing
07:13:44 <ggVGc> yep
07:13:44 <ggVGc> see
07:13:47 <ggVGc> pretty nice
07:14:01 <ggVGc> fmap (+5) (Just 10)
07:14:03 <Ankhers> Would anyone be able to show an example of how to use `min_' in an esqueleto query?
07:14:04 <ggVGc> eh
07:14:08 <ggVGc> > fmap (+5) (Just 10)
07:14:10 <lambdabot>  Just 15
07:14:10 <Xandaros> It allows you to "blindly" work with Maybe values, without knowing whether they are Just or Nothing
07:14:34 <ggVGc> Xandaros: well, it also lets you write a function that can take both a list and a maybe and do the right thing
07:14:34 <xkami> ggVGc: but is there a function for maybe? just like map is only for lists
07:14:37 <ggVGc> without caring
07:15:08 <ggVGc> xkami: I don't know, since I don't know the haskell standard library well enough. But also you would never want to use that, since the general form of fmap is way more useful
07:15:22 <ggVGc> you don't gain anything by specialising
07:15:33 <xkami> I see
07:15:39 <ggVGc> xkami: the reason `map` exists for lists is because it predates Functor I think
07:15:50 <Xandaros> There is not. The existance of map is just a bit of a historical accident and they decided to leave it in for "noob friendliness" or something like that
07:16:17 <ggVGc> afaik the concept of generalising "mapping" is newer than "mapping over lists"
07:16:18 <ggVGc> so that's why
07:16:31 <xkami> so
07:16:38 <xkami> fmap is used a lot?
07:16:42 <ggVGc> yes
07:16:44 <ggVGc> very much
07:16:49 <Xandaros> everywhere
07:16:54 <xkami> okay, that's nice then
07:17:14 <ggVGc> imo it's a very fundamental thing of functional programming, and why I said it's worthwhile understanding the Functor generalisation, while understanding Monad isn't that useful initially
07:17:18 <ggVGc> xkami: ^
07:17:49 <xkami> ggVGc: awesome
07:18:19 <Xandaros> A monad is just a more powerful functor. You can do more with it and haskell has built-in support for them (do-notation), but I do think you should familiarise yorself with functors first. Then go to applicatives (monads are also special cases of applicatives)
07:19:36 <mniip> questionable
07:21:02 <xkami> so
07:21:04 <mniip> oh wait hm
07:21:09 <xkami> what are applicatives
07:21:10 <mniip> yeah that's kinda inverted yes
07:22:01 <xkami> applicatives and monads are related?
07:22:34 <Xandaros> Every monad is an applicative and every applicative is a functor. (applicative is short for "applicative functor")
07:22:36 <mniip> xkami, applicative functors are functors that can perform n-ary function application
07:22:59 <nut_> xkami, im a newbie myself, this site gives the most helpful tip about learning Monad: http://www.stephendiehl.com/what/
07:23:21 <nut_> xkami, its called what i wish i knew when learning haskell
07:23:23 <Xandaros> That is an amazing website that is just missing some navigation :D
07:24:37 <nut_> Here's the tip about Monad learning: Don't read the monad tutorials.
07:24:37 <nut_> No really, don't read the monad tutorials.
07:24:38 <nut_> Learn about Haskell types.
07:24:38 <nut_> Learn what a typeclass is.
07:24:38 <nut_> Read the Typeclassopedia.
07:24:38 <nut_> Read the monad definitions.
07:24:40 <nut_> Use monads in real code.
07:24:42 <nut_> Don't write monad-analogy tutorials.
07:24:54 <tsahyt> mostly use monads in real code though. Intuition will follow
07:25:18 <xkami> yes
07:25:25 <nut_> personally i suffered a lot in "real world haskell"
07:25:37 <mniip> what tsahyt said
07:25:37 <nut_> the book
07:26:00 <Xandaros> Avoiding monad tutorials is also a good tip. They all suck
07:26:01 <mniip> monads are kinda simple in that there is not much to understand other than having an intuition
07:26:06 <mniip> but you can't "explain" intuition
07:26:11 <xkami> is cabal still something everyone uss?
07:26:13 <xkami> uses
07:26:15 <mniip> which is the monad tutorial fallacy
07:26:16 <Xandaros> yes
07:26:26 <xkami> what is stackage compared to cabal?
07:27:01 <adamCS> xkami:  stack/stackage is an easier way to get started.  And might be enough for everything you do.
07:27:10 <nut_> with cabal you can not guarantee that same code builds all the time
07:27:25 <quchen> xkami: stack uses a snapshot of compatible packages, Cabal is a dependency resolver. Snapshots never change, dependencies do.
07:27:40 <xkami> I see
07:27:42 <xkami> thank you
07:27:44 <quchen> (e.g. via minor version bumps, new compiler versions, ...)
07:27:50 <Taneb> xkami: cabal is a more naive tool but I think it lets you do some things stack doesn't
07:27:58 <Taneb> (although I don't know stack very well at all)
07:28:16 <xkami> quchen: you can lock the versions though?
07:28:21 <tsahyt> I use stack mostly because I want to stay out of cabal hell and because it's really nice to have several different GHC versions managed for you
07:29:19 <quchen> xkami: If you use Cabal to lock down all versions of packages and the compiler to a specific version, you'll probably end up with an awkward version of Stack.
07:29:28 <nitrix> https://hackage.haskell.org/packages/top
07:29:38 <nitrix> Hi guys; those numbers seems off a little.
07:29:42 <quchen> If you use Stack's dependency resolution features excessively, you end up with an awkward version of Cabal.
07:29:45 <Xandaros> Between all the stack priests, I'm just gonna say that I think stack is not worth the hassle and prefer sandboxing everything. You'll have to decide for yourself what you want
07:29:56 <tsahyt> yay, my parser works on first try!
07:30:29 <xkami> I see
07:31:02 <quchen> xkami: My advice would be to use Stack as a beginner. When the time comes to use more advanced features only available in Cabal you might dive into that. But as a Haskell beginner, you don't want to worry about your build system, for example.
07:31:06 <nut_> Xandaros, with sandbox do you still run cabal update sometimes ?
07:31:24 <nut_> Xandaros, it seems if you do then your sandbox can break
07:31:37 <quchen> Xandaros: My use case for Stack is mostly sharing Shake and lens installations :-D
07:31:53 <Xandaros> nut_: Never had that issue
07:33:07 <xkami> quchen: hmm okay
07:35:34 <Xandaros> I can't wait till cabal supports multiple versions of the same package. That will probably solve almost all problems labeled "cabal hell".
07:36:06 <quchen> Xandaros: Won't it allow a program to depend on ten times text?
07:36:34 <Xandaros> What?
07:37:31 <quchen> If you have N dependencies that all require a specific version of Text, won't you have to compile all N versions of Text?
07:38:47 <Xandaros> I don't think you can actually use multiple versions in the same project, but yes, you would have to
07:39:54 <Xandaros> The thing is, I don't really run into these issues, since I have a sandbox for every single project. The compile times are atrocious, though. If I can use the central repository for all my projects that would be great, but that's where you run into cabal hell, since once you install a package, it is locked to that version
07:40:34 <Xandaros> I've been told that ghc can work with different versions of a single package now, so cabal just needs to adjust accordingly
08:09:36 <wolfcub> http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern
08:09:40 <wolfcub> shits so dense
08:09:53 <wolfcub> am i ever gonna 'just get' this stuff -.-
08:10:25 <tsahyt> there are reports of people who have indeed achieved enlightenment, yes
08:10:31 <wolfcub> lol
08:10:53 <wolfcub> thats an apt term for it
08:12:15 <hpc> wolfcub: eventually you see enough things enough times that most of that explanation is things you have already learned
08:12:30 <Xandaros> Are there any papers talking about free monads? Especially in the context of interpreters?
08:13:22 <wolfcub> i dont know about a paper but i got a bunch of tabs opened here on just that topic
08:13:42 <wolfcub> open*?
08:13:42 <tsahyt> I'm still trying to wrap my head around the usefulness of comonads
08:13:58 <tsahyt> I know kind *what* it is, but I don't know why I would want it
08:14:02 <Xandaros> wolfcub: Since I want to use them as a source, that won't do, I'm afraid :)
08:14:04 <tsahyt> kind of*
08:14:13 <wolfcub> oh
08:15:01 <mazur> is there a way to make stack solver generate a new .cabal file?
08:15:17 <zcx> hi, running through the Writer logNumber example in LYAH
08:15:21 <zcx> http://learnyouahaskell.com/for-a-few-monads-more#writer
08:15:35 <zcx> i'm wondering how you can return (a*b)
08:15:54 <zcx> i.e. how does 'a <- logNumber 3' give a the type Int?
08:16:05 <zcx> same for 'b <- logNumber 5'
08:16:06 * hackagebot hero-club-five-tenets 0.3.0.3 - Think back of the five tenets of hero club  https://hackage.haskell.org/package/hero-club-five-tenets-0.3.0.3 (i_amd3)
08:16:22 <tsahyt> what's the type of logNumber?
08:16:30 <zcx> logNumber :: Int -> Writer [String] Int  
08:16:46 <tsahyt> What do you think a should be?
08:16:53 <zcx> probably Int
08:16:59 <zcx> so we can a*b
08:17:12 <tsahyt> it is. The trick is hidden in the <-
08:17:24 <zcx> so i know a -> m b
08:17:38 <zcx> and <- automatically pulls something out of the 'box'
08:17:54 <zcx> but it's a tuple...so how does <- know which value to get, the [String] or Int?
08:18:31 <tsahyt> <- is just syntactic sugar. a <- fubar desugars to fubar >>= \a -> ...
08:18:41 <tsahyt> so what you want to look at is the implementation of >>=
08:18:48 <Xandaros> It's not a tuple, though it does have multiple type parameters. (Don't mix it up with the actual implementation. That could be anything)
08:18:58 <zcx> oh right
08:19:00 <zcx> i did mix that up
08:19:01 <Xandaros> The definition of (>>=) dictates that the last type parameter is the one you're working on
08:19:10 <Xandaros> :t (>>=)
08:19:12 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:19:16 <zcx> okay and that explains the ordering of [String] Int
08:19:26 <zcx> i'll go over that impl, thanks!
08:19:30 <Xandaros> So the Monad is actually "Writer [String]", not just "Writer"
08:19:34 <tsahyt> I wish there was a way to specialize type signatures with lambdabot
08:19:37 <zcx> ah got it
08:19:40 <zcx> yeah that makes a lot of sense
08:19:48 <tsahyt> or ghci for that matter
08:19:57 <zcx> partially applied type constructors aren't familiar to me yet
08:20:06 <zcx> thanks Xandaros and tsahyt that was very helpful
08:20:12 <tsahyt> zcx: It's the same concept as with ordinary functions
08:20:33 <zcx> yeah i'm just not used to seeing them and didn't make the connection that monads can only accept one type parameter
08:20:41 <zcx> but that makes the naming make more sense
08:21:06 * hackagebot hzaif 0.1.0.0 - This package is Zaif Exchange Api wrapper  https://hackage.haskell.org/package/hzaif-0.1.0.0 (i_amd3)
08:21:07 <tsahyt> You can think of Writer as a family of monads if that helps you, there's one for each type you can assign to the first type parameter
08:21:09 * hackagebot eventloop 0.7.0.1 - A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.  https://hackage.haskell.org/package/eventloop-0.7.0.1 (sebaslafleur)
08:21:24 <tsahyt> So there's a Writer Int monad, there's a Writer String monad, and so on and so forth
08:22:30 <Xandaros> Well, Writer Int won't work, since it needs to be a monoid, but yes... basically :D
08:22:55 <Xandaros> (The "state" needs to be a monoid)
08:23:19 <tsahyt> Ah right, instance (Monoid w, Monad m) => Monad (WriterT w m)
08:23:25 <tsahyt> never saw that
08:27:25 <c_wraith> beware that WriterT is basically broken.  There's no way to make accumulation in the monoid strict.
08:28:31 <mazur> anybody know why stack new --force fails because "directory already exists"? i would think --force was intended for that situation
08:29:35 <makalu> I use stack and ghc 7.10. I add -eventlog to .cabal ghc-options field. I use "+RTS -N4 -ls" when running the program but I get an error saying -eventlog is required for -ls but I enabled it?
08:42:25 <quchen> makalu: Did you compile with -rtsops?
08:42:29 <quchen> -rtsopts*
08:42:47 <makalu> where do I put -rtsopts? If I put it in ghc-options, nothing changes.
08:42:53 <quchen> Hm. 
08:45:59 <makalu> interesting, I got it working when I added -with-rtsopts=-ls instead of using +RTS -ls on the command line
08:47:52 <quchen> Is there a 'bracket' function that works for MonadIO and not just IO?
08:48:16 <quchen> lifted-base is too general, I'd have to thread the MonadBaseControlIO constraint through my entire app
08:48:18 <monochrom> there is one in monad-control. MonadIO is too weak.
08:48:55 <quchen> Too weak? So I can't write it at all like that?
08:48:59 <monochrom> indeed, MonadIO is even more general than MonadBaseControlIO
08:49:04 <monochrom> right
08:49:23 <quchen> Arr.
08:56:08 * hackagebot hasql 0.19.3.3 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.19.3.3 (NikitaVolkov)
08:58:15 <JonReed> How do I use haddock? Let's say I have one file which I don't even have a cabal file for and I just want to use haddock on. How can I do it? It says that it can't find a bunch of modules (of dependencies).
08:59:02 <monochrom> you can ignore that. it just means, for example, "Int" doesn't get a hyperlink to base's doc
09:00:11 <monochrom> it is too hard for humans to add enough command line options to get that hyperlink.
09:00:29 <monochrom> at least it is too hard for me
09:06:08 * hackagebot hspec-megaparsec 0.1.0 - Utility functions for testing Megaparsec parsers with Hspec  https://hackage.haskell.org/package/hspec-megaparsec-0.1.0 (mrkkrp)
09:07:42 <OverCoder> What are functors
09:07:55 <OverCoder> Horrible, I don't understand anything around them
09:08:29 <OverCoder> I've actually skipped them once, but this time seems this part of the tutorial highly depends on Functors, pfft
09:08:47 <JonReed> monochrom: I can't find where does it generate documentation. E.g., I run `haddock TestModule.hs -o ./` and no files appear
09:09:25 <Chobbes> Anybody work with Accelerate? I'm confused about whether or not you're supposed to make instances of Elt, and if so what the methods are... https://hackage.haskell.org/package/accelerate-0.15.0.0/docs/Data-Array-Accelerate.html#t:Elt
09:10:35 <monochrom> you have to add -h or --html to get output
09:11:04 <monochrom> because there are other output formats e.g. microsoft CHM
09:11:15 <Xandaros> OverCoder: Do you know what typeclasses are?
09:11:21 <OverCoder> Yes
09:11:30 <Xandaros> A functor is just a typeclass that defines "fmap"
09:11:32 <Xandaros> :t fmap
09:11:33 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:11:42 <OverCoder> Yeah I see, and what does that fmap do?
09:11:47 <JonReed> monochrom: Thx, it generates it now. That makes sense.
09:11:56 <Xandaros> It allows you to apply a function to a value "inside" the functor (this is called "mapping over" it)
09:12:11 <Xandaros> For example, mapping over lists means you apply the function to every value in the list
09:12:17 <Xandaros> > fmap (+5) [4,5,6]
09:12:20 <lambdabot>  [9,10,11]
09:12:22 <Xandaros> > fmap (+5) []
09:12:25 <lambdabot>  []
09:12:30 <OverCoder> How's that different from the normal 'map' ?
09:12:42 <Xandaros> It isn't. "map" is a specialised version of fmap for lists
09:12:57 <k3d3> > (+5) <$> [4,5,6]
09:12:59 <lambdabot>  [9,10,11]
09:13:01 <Xandaros> Mapping over a maybe value for example, just applies the function to it
09:13:07 <Xandaros> > fmap (+5) (Just 7)
09:13:09 <lambdabot>  Just 12
09:13:10 <Xandaros> > fmap (+5) Nothing
09:13:12 <lambdabot>  Nothing
09:13:27 <OverCoder> ah
09:13:27 <OverCoder> hm
09:13:38 * OverCoder thinks
09:14:00 <OverCoder> ah, now I got it, many thanks
09:14:05 <Xandaros> k3d3: I think it is best to wait with that till people ask about applicative. No need to confuse them with synonyms :)
09:14:20 <OverCoder> haha well I think I am learning about that applicative thing lol
09:14:38 <k3d3> I'm still learning that stuff myself :p
09:14:49 <OverCoder> (I mean this part of the tutorial talks about it, so I think Functors are a requirement in that part :))
09:14:57 <aweinstock> @quote zip`ap`tail
09:14:57 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
09:15:03 <Xandaros> Well, Applicatives are special cases of functors, so it would seem a good idea to have a firm grasp on functors :)
09:15:43 <OverCoder> hmm, awesome, thanks
09:16:26 <Xandaros> OverCoder: I suggest you just play around with a few Functors. Think what else could be a functor, you'd be surprised how common it is. (Functions are functors, too! :D)
09:16:55 <aweinstock> Xandaros: the zip`ap`tail trick depends on functions being applicatives
09:17:09 <aweinstock> :t zip <*> tail
09:17:11 <lambdabot> [a] -> [(a, a)]
09:17:27 <OverCoder> Xandaros, hm, good idea, I will just do now hahahahha
09:17:29 <OverCoder> :p
09:17:42 <Xandaros> :t zip
09:17:43 <lambdabot> [a] -> [b] -> [(a, b)]
09:18:04 <Xandaros> ah, lol
09:18:34 <quchen> It's a bit obfuscated by using <*> there, but (zip <*> tail) = \xs -> zip xs (tail xs)
09:19:34 <Xandaros> yup. I'd never actually use that, though
09:24:01 <wolfcub> does anyone have a nice pdf cheatsheet with the typeclasses definitions and the axioms?
09:24:37 <Xandaros> Not a pdf, but there is the typeclassopedia
09:24:41 <Xandaros> @where typeclassopedia
09:24:41 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
09:25:01 <wolfcub> i mean, just the signatures and the axioms
09:25:32 <Xandaros> That might be useful for OverCoder, too, actually (ping)
09:25:51 <Th30n> Does bytestring package have a function for representing bs as a text string of hex numbers?
09:26:05 <JonReed> Hm, I still can't use haddock, it says that "Could not find Module ...` even through ghc compiles the file fine.
09:26:27 <OverCoder> Xandaros, hm, nice, gonna look at it
09:26:43 <JonReed> And haddock does not generate any files because of it.
09:26:51 <OverCoder> Th30n, unpack ?
09:26:52 <JonReed> without any imports it works fine
09:27:01 <OverCoder> ah wait, hex numbers
09:27:04 <OverCoder> hm, idk
09:29:39 <rephex> what's the go-to html templating library these days, lucid or blaze-html?
09:32:14 <Xandaros> Th30n: Something like: 'concat . fmap (flip showHex "") . unpack' ?
09:32:40 <Xandaros> :t concat . fmap (flip showHex "") . Data.ByteString.unpack
09:32:42 <lambdabot> BSC.ByteString -> [Char]
09:34:22 <Th30n> Xandaros: Yep, but where is showHex from?
09:34:48 <Th30n> ok, found it
09:34:50 <Xandaros> Numeric
09:34:50 <Th30n> thanks!
09:34:55 <Xandaros> :)
09:35:36 <Xandaros> (I think I'm abusing ShowS a bit there. I need to figure out how it actually works at some point)
09:36:54 <synergistics> How would I map read as Int over a list of strings?
09:37:45 <synergistics> something like map (read :: Int) ["1","2","3"], but I know that's wrong
09:39:01 <ggVGc> synergistics: you'd need to parse the strings, and the result should probably be a Maybe Int rather than Int
09:39:08 <ggVGc> otherwise what do you get from invalid strings
09:39:36 <synergistics> Ah, ok
09:40:25 <Clint> win 23
09:40:28 * Clint sighs.
09:40:36 <synergistics> I could even wrap read in a lambda then
09:40:39 <ggVGc> there is definitely a function in the standard lib for this but I don't remember off hand what it is
09:41:07 <ggVGc> but logically you can't parse strings into numbers without handling the case where the string isn't a number
09:41:12 <aweinstock> :t foldr (.) "" . map showHex
09:41:13 <lambdabot>     Couldn't match expected type ‘a -> String’
09:41:14 <lambdabot>                 with actual type ‘[Char]’
09:41:14 <lambdabot>     In the second argument of ‘foldr’, namely ‘""’
09:43:24 <aweinstock> > (flip (foldr (.) id . map showHex) "") [0, 1, 2, 15]
09:43:26 <lambdabot>  "012f"
09:43:55 <Xandaros> aweinstock: Yeah, I did have something like that in mind :)
09:44:26 <aweinstock> (flip (foldr (.) id . fmap showHex) "") should be more efficient than (concat . fmap (flip showHex ""))
09:44:50 <monochrom> Text.Read has readMaybe
09:45:50 <Xandaros> There's also Safe.readMay, if you want to use string (though you need the safe package)
09:46:09 * hackagebot logic-TPTP 0.4.4.0 - Import, export etc. for TPTP, a syntax for first-order logic  https://hackage.haskell.org/package/logic-TPTP-0.4.4.0 (DanielSchuessler)
09:46:22 <Xandaros> It is something I think should be in the Prelude. We can kick read out instead
09:47:34 <Xandaros> Actually, let's just blindly remove all partial functions from the Prelude. While we're at it, get rid of map and rename fmap to map. Also remove return, it's useless anyway.
09:47:42 <Xandaros> I'm afraid people won't be too happy with that, though xD
09:48:01 <k4pod> w-whats wrong with return?
09:48:25 <Xandaros> pure is more powerful and does the same thing. Similar to fmap and map
09:48:37 <Xandaros> It also has a less misleading name
09:53:27 <Xandaros> I should make it a point to use classy for my next project. It seems a lot better than the default Prelude, but for some reason I am hesitant
09:54:37 <monochrom> it's probably too classy
09:58:06 <joshkirklin> We have Functor that provides fmap :: (a->b) -> f a -> f b, and Contravariant that provides contramap :: (a->b) -> f b -> f a. Is there a common typeclass that provides some function (a->b) -> (b->a) -> f a -> f b? 
10:00:25 <joshkirklin> as an additional question: is data Insert t = Done t | Insert (t -> Insert t) a commonly used thing?
10:00:29 <Xandaros> joshkirklin: I'm not sure what you're trying to do... Are you looking for profunctors, maybe?
10:00:53 <aweinstock> that Insert thing looks kind of Free-shaped
10:02:20 <joshkirklin> Xandaros, I don't think so, but I might be wrong. I started off trying to derive an instance of functor for Insert above, but realised quickly I wouldn't be able to define a "map" with just a->b
10:03:06 <aweinstock> data Free f a = Pure a | Free (f (Free f a))
10:03:07 <Xandaros> Oh, I see
10:03:39 <joshkirklin> aweinstock, that looks right, so Insert t = Free (t->) t?
10:03:52 <aweinstock> joshkirklin: type Insert a = Free ((->) a) a -- I think
10:04:02 <aweinstock> yup
10:04:20 <joshkirklin> except ((->) t) isn't a functor here,it's a contravariant yes?
10:04:23 <joshkirklin> so not quite free
10:04:35 <aweinstock> (sections aren't supported at the type level, as far as I know, so you need ((->) t) instead of (t ->)
10:04:36 <Xandaros> It's a functor
10:04:38 <aweinstock> )
10:05:00 <joshkirklin> ah you're right, the other way round is what I was thinking of
10:05:14 <joshkirklin> ok, thanks guys
10:05:32 <Xandaros> Is there a flip on the type level?
10:05:38 <aweinstock> contramap :: (a -> b) -> (r -> b) -> (r -> a) -- how would you implement this?
10:06:25 <joshkirklin> yeah I was getting confused and thinking contramap :: (a -> b) -> (b -> r) -> (a -> r) = (.)
10:06:38 <joshkirklin> or flip (.)
10:06:39 <Xandaros> ...guess you could define a type family for that. I should try that at some point
11:02:21 <kurt111> If I'm looking at DateTime libraries on Haskell, how do I know which ones are "standard" or at least widely adopted and supported vs libraries that are experimental or unsupported?
11:02:30 <kurt111> (on haskell.org)
11:02:58 <glguy> This is the standard time library: http://hackage.haskell.org/package/time
11:03:09 <kurt111> (or hackage)
11:04:01 <nanoz> hello i'm newbie , how to make my list behave like queue
11:04:24 <nanoz> since haskell cant hold down to state
11:05:22 <aweinstock> nanoz: try Data.Sequence ?
11:06:08 <aweinstock> (there's also Control.Monad.Queue.Allison, but that's a tad specialized, Data.Sequence is a more general-purpose datastructure)
11:06:44 <tommd> nanoz: Don't try to make lists behave like X. Instead, make a datatype for X that supports the operations properly.
11:07:22 <tommd> Or find one that someone else made, such as one of the many queue like implementations out there.
11:09:07 <aweinstock> tommd: lists can be made to act like queues through a clever trick involving continuations; Control.Monad.Queue.Allison provides a newtype and convenient combinators for that
11:10:30 <tommd> aweinstock: Hadn't thought of that, thanks.  Still, I think a good rule of thumb is not to over-use a structure just because you already have it.
11:11:12 <glguy> Using one datatype to implement another isn't exactly a "clever trick" on its own
11:13:36 <tsahyt> Is it possible for two top level declarations to share a where clause?
11:13:41 <glguy> no
11:13:55 <glguy> unless you do something like:   (x,y) = .... where
11:14:10 <aweinstock> glguy: I guess not, but this looks pretty magical/clever to me: https://hackage.haskell.org/package/control-monad-queue-0.2.0.1/docs/src/Control-Monad-Queue-Allison.html
11:14:28 <tommd> Or consider x = ... where (a,b,c) = foo ; y = ... where (a,b,c) = foo and define `foo` top level.
11:14:38 <tsahyt> I mean two declarations for the same function which just differ in pattern matching
11:14:50 <tsahyt> say foo True = ...; foo False = ...; where bar = ...
11:15:24 <srhb> tsahyt: No, but you could float the equations into a case expression
11:15:30 <aweinstock> tsahyt: foo = tmp where tmp True = ...; tmp False = ...; bar = ...
11:16:29 * hackagebot agda-snippets 2.4.2.5 - Render just the Agda snippets of a literate Agda file to HTML  https://hackage.haskell.org/package/agda-snippets-2.4.2.5 (LiamOConnorDavis)
11:19:07 <kurt111> why does this trigger an exception rather than return Left? `fail "xyz" :: Either String Int`
11:19:14 <hellertime> the fpcomplete jessie deb archive seems to have gone away today: http://download.fpcomplete.com/debian/jessie
11:19:17 <hellertime> :(
11:19:28 <hellertime> and me trying to go an rebuild an image 
11:20:36 <aweinstock> :t fai
11:20:38 <lambdabot>     Not in scope: ‘fai’
11:20:38 <lambdabot>     Perhaps you meant ‘fail’ (imported from Control.Monad.Writer)
11:20:38 <aweinstock> :t fail
11:20:40 <lambdabot> Monad m => String -> m a
11:21:13 <aweinstock> kurt111: fail has to work for any type e (m ~ Either e)
11:21:20 <glguy> kurt111: The Monad instance for Either doesn't know either of the type arguments to Either are
11:21:30 <glguy> so it doesn't use the fact that it's a String to change the implementation of fail
11:21:41 <aweinstock> you can't implement (fail :: String -> Either e a) for other e than String
11:22:36 <kurt111> aweinstock, glguy. that makes perfect sense. It won't work for left types other than String. Then why does https://wiki.haskell.org/Failure say that Either failure == Left?
11:22:48 <geekosaur> it used to be
11:22:53 <aweinstock> :t mzero
11:22:55 <geekosaur> nobody updated that entry
11:22:55 <lambdabot> MonadPlus m => m a
11:23:11 <kurt111> ah, that is failure not Monad fail
11:23:17 <aweinstock> > mzero :: Either String Int
11:23:18 <geekosaur> the problem is that having Either force that behavior on Left distinguishes it in an odd way
11:23:19 <lambdabot>  Left ""
11:23:24 <glguy> geekosaur: I dont think that the Either instance ever behaved like that
11:23:38 <glguy> It's just saying that Left represents generic failure, not Monad's fail
11:23:39 <geekosaur> I thought it did? that was part of the whole Error newtype thing
11:23:40 <aweinstock> kurt111: MonadPlus failure is mzero
11:24:00 <glguy> geekosaur: No, Error specifically had that behavior and then ExceptT was made
11:24:02 <glguy> but Either never did
11:24:39 <kurt111> I want to parse a date. It returns Monad fail on failure. Which Monad will do something like Either String DateTime so I can get either the parse error or the successful DateTime? 
11:24:45 <glguy> But maybe it's just so long ago that I wasn't Haskelling hten
11:25:32 <tommd> No, I don't think so.
11:25:56 <tommd> Or... we can ask John and SPJ. ;-)
11:26:15 <tsahyt> > replicateM 2 [0,1]
11:26:17 <lambdabot>  [[0,0],[0,1],[1,0],[1,1]]
11:26:30 <tsahyt> sometimes the list monad looks like magic to me
11:26:35 <aweinstock> kurt111: which library?
11:26:53 <glguy> Old versions of base don't appear to have a Monad instance for Either at all
11:27:19 <bollu> in a cartesian closed category, *any* two objects should have an exponential between them right? so in that case, in Hask, someone give me an instance of f :: (Int -> Char) ?
11:27:37 <aweinstock> bollu: const 'A'
11:27:52 <glguy> So perhaps some other package was providing an orphan instance with that behavior?
11:27:53 <bollu> aweinstock: okay, F :: Int -> Void?
11:28:02 <kurt111> aweinstock: parseTimeM in Data.Time.Format. That is a standard lib, AFAIK
11:28:04 <bollu> (where Void is the uninhabited type)
11:28:06 <aweinstock> bollu: const undefined
11:28:12 <aweinstock> ;)
11:28:22 <bollu> aweinstock: but you're invoking _|_. cheating :P :)
11:28:30 <bollu> aweinstock: so Hask is a CCC?
11:28:40 <glguy> base-4.3 seems to have added the Monad instance for Either e
11:29:14 <aweinstock> kurt111: parseTime (without the M) returns a Maybe
11:29:18 <bollu> one more question: Other than Hask and *actual* lambda calculus, what else is a CCC?
11:29:27 <glguy> Ah ha, and old versions of transformers defined the Error behavior for Either
11:29:36 <glguy> e.g. transformers-0.2.0.0
11:29:43 <tommd> And many a person were mad when it changed.
11:29:52 <tommd> I recall that, Garrett was pissed.
11:30:07 <aweinstock> kurt111: or is parseTimeM's fail message informative?
11:30:12 <tommd> Suddenly lots of code needed a newtype and custom instance.
11:31:04 <aweinstock> kurt111: is parseTimeM fail's with an informative message, there's probably some hackery you could do involving catching fail's exception in IO, using unsafePerformIO and wrapping it in Left
11:31:07 <noteventime> bollu: Isn't Set and a lot of things built on top of it (various (Pre)Sheaf categories)?
11:32:04 <bollu> noteventime: I don't know algebraic geometry, so I don't know what Sheafs are :(. I don't think you can ELIUndergrad-comp-sci-who-knows-pure-maths?
11:32:17 <glguy> Prelude Data.Time> parseTimeM True defaultTimeLocale "%H" "120" :: IO UTCTime
11:32:18 <glguy> *** Exception: user error (parseTimeM: no parse of "120")
11:32:25 <bollu> noteventime: Set is a CCC because you have "regular" functions, right? but that's sort of a "common" example
11:32:52 <joash> Hi! I know there's all :: (a -> Bool) -> [a] -> Bool, but Hoogle didn't return anything for something like allPass :: [(a -> Bool)] -> a -> Bool. I must be missing an obvious way of doing this...
11:33:10 <bollu> noteventime: I was looking for more exotic ones (eg. how the elliptic curves form a group isn't obvious. Or how SO(n) is a group since two rotations need not give another "proper" rotation) stuff like that
11:33:12 <aweinstock> glguy: so basically, no information other than the arguments?
11:33:13 <noteventime> bollu: A presheaf is a functor from a category to Set
11:33:19 <glguy> :t \ps x -> all ($ x) ps
11:33:20 <lambdabot> Foldable t => t (a -> Bool) -> a -> Bool
11:33:25 <bollu> noteventime: huh, I see
11:33:29 <joash> AH thanks!
11:33:34 <glguy> aweinstock: Not that I saw
11:33:35 <noteventime> bollu: If you collect them into a category you get a sort of completion of the category
11:33:50 <aweinstock> kurt111: use parseTime, since glguy demonstrated that the error message doesn't have useful information in it
11:33:50 <noteventime> I.e. you get a lot of things that "look like" things that should have been in the original category 
11:34:19 <mpickering> Bollu, search for models of the untyped lambda calculus. They are cccs with some additional structure
11:34:30 <glguy> aweinstock: using parseTime gets you a deprecation warning, though
11:34:33 <bollu> mpickering: cool, thanks. Will they be accessible?
11:34:34 <bollu> noteventime: and I will :)
11:34:52 <glguy> (though I don't know how quickly it will actually be removed from the module)
11:35:03 <mpickering> Depends on your background, but you asked for more interesting examples
11:35:11 <bollu> mpickering: fair enough :)
11:35:14 <aweinstock> glguy: which is worse: deprecation warnings, or unsafePerformIO hackery?
11:35:22 <aweinstock> (or bottom)
11:35:36 <noteventime> bollu: For any actual object X you can take take the Hom (with one argument fixed to be X)
11:35:49 <glguy> aweinstock: I don't understand. Why does using parseTimeM involve hackery?
11:36:12 <noteventime> and it turns out that, generally, any functor into Set looks "sufficiently much" like such a specialised Hom functor to get a sensible theory :)
11:36:19 <aweinstock> glguy: nevermind, parseTimeM with (m ~ Maybe) should do the right thing
11:36:52 <aweinstock> glguy: (I was assuming (fail _ ~ bottom) since the original question was about (Either String))
11:37:53 <aweinstock> glguy: (and my proposed workaround was extracting s from (fail s :: IO a) via exception machinery, then using unsafePerformIO and Left)
11:38:01 <bollu> noteventime: I don't "see", but I'll think about that. Thanks :)
11:38:25 <Guest95142> somebody said haskell is a failure because of reasons is in this post "https://0x0.st/H0w.txt
11:38:48 <Guest95142> what do you guys thing
11:39:03 <glguy> aweinstock: If the error message was important a local type like data Failable a = Failure String | Success a  would probably be better than unsafePerformIO
11:40:15 <noteventime> bollu: I takes some puzzling to get a feeling for it, and for it to really become interesting you need to put a notion of topology on the category (which gives you a notion of gluing and takes you from presheaves to sheaves). 
11:40:57 <bollu> noteventime: topology is something I really don't have an intuition. I can define all of it (eg. compact, separable, what-have-you), but I can't visualize any of it
11:41:07 <aweinstock> glguy: that'd require modifying the time library, which the unsafePerformIO solution doesn't (agreed though, an (Either String a) would be the "right" way to handle an important error message)
11:41:07 <bollu> noteventime: it is quite literally a bunch of axioms to me
11:41:15 <bollu> noteventime: maybe bourbakists will be happy :/
11:41:17 <glguy> aweinstock: No, the type would be local to your program
11:41:45 <aweinstock> glguy: how would you extract the error message from parseTimeM then?
11:42:00 <glguy> by providing an instance of Monad that keeps the error message
11:42:09 <aweinstock> oh, I see
11:42:34 <noteventime> bollu: And topology in the sense used here is Grothendieckian, so even worse ;)
11:43:11 <Guest95142> http://0x0.st/H0w.txt
11:43:21 <bollu> noteventime: let me get to grothendiek first :P I'm climbing the ivory tower of Galois theory right now. While beautiful, it sure is hard to grasp as well sometimes
11:43:46 <aweinstock> newtype Failable a = Failable { unFailable :: Either String a }; instance Monad Failable where fail s = Failable (Left s); return = Failable . return; ...
11:44:29 <fooBard> what book would you guys recommend for learning category theory
11:44:45 <noteventime> Depends on what you want to learn it for and what your background is
11:44:52 <fooBard> i did 3 years of an undergraduate course of pure math, if that would affect the answer
11:45:01 <bollu> fooBard: as a programmer more than math person, I'd recommend this web series: http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
11:45:17 <fooBard> and i want to learn it to be 'a better programmer'
11:45:30 <bollu> fooBard: oh, in that case, then probably awodey? or MacLane? I'm not really sure. 
11:46:25 <noteventime> I doubt learning category theory is a particularly good way to become a better programmer 
11:46:52 <noteventime> not a particularly efficient one in any case
11:47:09 <fooBard> well at least i would hope it would help me better understand the haskell lingo anyways XD
11:48:13 <bollu> I still don't understand how an algerbra is f a -> a. Like, consider a monoid. It has *two* rules (id :: a, assoc_operator :: a -> a -> a), but the "algebra" just has (algebra:: f a -> a)
11:48:20 <bollu> so how do the two ideas relate?
11:48:45 <bollu> I have read this post: http://bartoszmilewski.com/2013/06/10/understanding-f-algebras/ but it goes on tangents and I keep losing the point :( 
11:49:08 <bollu> can someone give me a succinct way to get from the familiar Algebra to the cat. theory algebra?
11:54:49 <noteventime> bollu: You just encode all the things in one functor
11:55:02 <noteventime> you can encode a pair of functions as a function out of the coproduct
11:55:09 <bollu> noteventime: can I have a concrete example for the monoid?
11:55:13 <bollu> noteventime: so, Either?
11:55:28 <noteventime> that it so say, a function Either a b -> c is the same as having a pair of function a -> c, b -> c
11:56:03 <bollu> noteventime: I.. guess, yeah. I can write the isomorphism, yeah
11:56:15 <noteventime> So for something monoid-like you want a morphism a * a -> a (multiplication) and a morphism 1 -> a (the unit)
11:56:31 <noteventime> but that's the same as having a morphism (a * a + 1) -> a
11:56:32 <bollu> noteventime: so, monoid :: Either (a * a) () -> a ?
11:56:41 <noteventime> exactly 
11:56:59 <noteventime> so the functor is a -> (Either (a, a) ())
11:57:05 <bollu> noteventime: okay, now how does this generalise "naturally" to arbitrary functors? that seems like a trick :/
11:57:43 <bollu> noteventime: but you're not guaranteed that the lift from "a" to Monoid will exist, right?
11:57:46 <noteventime> bollu: It depends on what structure the category it has 
11:58:03 <bollu> eg: liftMonoid Char (not possible, because you can't have <> on Char)
11:58:09 <noteventime> It general the idea is that an endofunctor defines some sort of "structured" thing in a category 
11:58:17 <noteventime> In general *
11:58:45 <noteventime> and algebras define ways to fold such structured things 
11:59:02 <bollu> noteventime: wait, first, consider the functor liftMonoid :: a -> (Either (a, a) ()). Now, liftMonoid Char is invalid, right?
11:59:08 <noteventime> be right back, need to go get my laundry 
11:59:14 <bollu> noteventime: alright :)
12:00:47 <bollu> noteventime: or will you give me a "trivial" monoid like a left-absorbing monoid? (a <> _ = a, and s <> id = id <> s = s?)
12:03:41 <t0by> noteventime noteventime 
12:03:57 <t0by> what are you doing here? :^)
12:07:18 <Guest79924> Hi everyone
12:07:19 <noteventime> bollu: Why should it be invalid?
12:07:33 <noteventime> t0by: Why shouldn't I be here? :)
12:07:46 <bollu> noteventime: I'm not saying it will be invalid, I'm saying that there is no "natural" monoid like one on [a]
12:07:58 <Guest79924> I've been for a while trying to understand the last line of the giveItem function in Real world Haskell's chapter on STM
12:08:06 <bollu> noteventime: a monoid you give me for Char will be something like the left-absorbing one I wrote down, right?
12:08:10 <Guest79924> readTVar toInv >>= writeTVar toInv . (item :)
12:08:19 <Guest79924> can someone walk me through it?
12:08:20 <bollu> noteventime: because you can't inherently smash together two characters
12:08:22 <noteventime> bollu: Well, arguably char is Z_{2^32} or something like that :)
12:08:41 <bollu> noteventime: oh c'mon :)
12:09:15 <noteventime> bollu: :), in any case, liftMonoid Char itself is no problem 
12:09:16 <bollu> noteventime: okay, give me a Group, on, like State Int Char
12:09:29 <noteventime> You won't find a natural liftMonoid-algebra though 
12:09:50 <noteventime> liftMonoid-algebra *on char*
12:09:58 <bollu> noteventime: right, so isn't the algebra definition "wrong" ? because the lifting of monoid doesn't work for any  a
12:10:20 <geekosaur> Guest79924, what problem are you having with it?
12:10:22 <bollu> so we cannot say liftMonoid :: a -> (Either (a, a) () -> a)
12:10:39 <nolrai2> :t ( (either pure (recurse f)) >>=)
12:10:41 <lambdabot>     Not in scope: ‘recurse’
12:10:41 <lambdabot>     Perhaps you meant one of these:
12:10:41 <lambdabot>       ‘reverse’ (imported from Data.List),
12:10:42 <bollu> it would have to be something like liftMonoid :: monoidable a => a -> (Either (a, a) () -> a)
12:10:46 <noteventime> bollu: You aren't interested in finding a construction that constructs monoids for you automagically 
12:10:48 <bollu> Monoidable*
12:10:52 <Guest79924> readTVar takes the toInnv :: TVar [a] and returns STM [a] 
12:10:56 <bollu> right?
12:11:06 <noteventime> What functor algebras allow you to do is study certain types of equations in terms of categories 
12:11:09 <bollu> noteventime: oh, so I have misunderstood what the algebra is/
12:11:10 <nolrai2> :t fix \r -> ( (either pure (r f)) >>=)
12:11:12 <lambdabot> parse error on input ‘\’
12:11:18 <bollu> noteventime: so, well, "which part" is the algebra?
12:11:38 <noteventime> bollu: You're formally right about what it is (in the sense of how it's defined)
12:11:55 <kenV> can Spock be used to write a client?
12:11:56 <noteventime> bollu: Where they tend to become interesting, though, is when you try to find fixed points for them
12:11:57 <Guest79924> >>= takes the STM [a] and a function that is supposed to take [a] and return STM b
12:12:04 <bollu> noteventime: but..?
12:12:09 <nolrai2> :t let recourse f = ( (either pure (recourse f)) >>=) in recourse 
12:12:10 <geekosaur> correct so far
12:12:11 <lambdabot>     Occurs check: cannot construct the infinite type:
12:12:11 <lambdabot>       f1 ~ (->) (Either a1 (f1 a1 -> f1 a1))
12:12:11 <lambdabot>     Expected type: f1 (f1 a1)
12:12:30 <bollu> noteventime: fixed points in what sense? (how do you find a fixed point of a functor? are you looking for a type x such that f x ~ x?)
12:12:31 <noteventime> bollu: So the traditional example is, say f(a) = (String, a)
12:12:44 <noteventime> bollu: In the isomorphism sense 
12:12:49 <bollu> noteventime: f :: a -> (String, a)?
12:13:09 <Guest79924> but the function provided writeTVar takes a TVar [a] instead of [a]
12:13:10 <bollu> noteventime: okay,
12:13:11 <noteventime> bollu: type F a = (String, a)
12:13:21 <bollu> oh, okay
12:13:31 <Guest79924> and it also is alerady give na param
12:13:46 <Guest79924> item : toInv
12:13:52 <geekosaur> :t writeTVar
12:13:54 <lambdabot> Not in scope: ‘writeTVar’
12:13:56 <noteventime> bollu: So a natural fixed point of F is the type of infinite streams of strings
12:14:00 <Guest79924> sorry
12:14:07 <Guest79924> was looking at wrong sig
12:14:12 <Guest79924> for writeTVar
12:14:26 <Guest79924> still, thanks though
12:14:41 <bollu> noteventime: I'm lost, do you mean fixed point in the f(x) = x sense? or in the Haskell Fix f = Fix( f (Fix f)) ?
12:15:05 <noteventime> bollu: In the former sense, though the latter turns out to be a way to find solutions to the former 
12:15:10 <Guest79924> second time I chose to interact with the Haskell community and again I found people wanting to help
12:15:49 <bollu> noteventime: okay, go on now:) I was lost at the sentence "So a natural fixed point of F is the type of infinite streams of strings"
12:15:54 <bollu> can you break it down for me?
12:16:26 <noteventime> bollu: Say you have a haskell type for infinite streams, data Stream = Stream String Stream
12:16:33 <Guest79924> also it seems like just trying to communicate a problem with an actual person once can be more effective than going through it alone 10x
12:16:43 <noteventime> bollu: Can you find the obvious isomorphism F Stream ~ Stream
12:16:43 <noteventime> ?
12:17:11 <bollu> noteventime: Stream = the coalgebra structure? Stream a = a :< Stream a?
12:17:16 <Guest79924> idk how I kept not reading theright line again and again lol
12:17:37 <noteventime> bollu: I just specialised it to String
12:18:27 <bollu> noteventime: I can write the isomorphism for Monoid x => F a = (x, a) where (F a ~ a)
12:18:38 <bollu> noteventime: (that is, use the id to construct a (x, a) from an a
12:18:45 <bollu> and project the (x, a) to a to unlift it
12:18:47 <bollu> makes sense?
12:19:27 <bollu> I'm not sure if what I said was clear :
12:19:42 <noteventime> bollu: Why monoid?
12:20:03 <bollu> noteventime: to be able to lift a to (x, a), I need a value of "x" to fill, right?
12:20:11 <bollu> so I picked monoid for the id
12:20:21 <bollu> any type that has an identity works I guess
12:20:22 <noteventime> bollu: The type of the isomorphism here is F Stream ~~ Stream though
12:21:00 <noteventime> iso (string, stream) = Stream string stream, iso^-1 (Stream string stream) = (string, stream)
12:21:14 <noteventime> but perhaps that's what you meant 
12:21:30 <bollu> noteventime: ah no, that is not what I meant :) but now it makes sense
12:22:04 <bollu> noteventime: why does this feels very much like comonad?
12:22:40 <bollu> noteventime: but go on :)
12:22:51 <noteventime> bollu: the functor that sends a type B to some choice of fixed point of F_B(A) = (B, A) is a comonad
12:23:32 <noteventime> (well, sensible choice of fixed point anyway)
12:23:44 <bollu> noteventime: ah, I see. I'm glad I'm able to pick up on Haskell patterns ^_^ feels nice
12:23:48 <bollu> noteventime: but do go on
12:24:10 <noteventime> bollu: So this idea of encoding data types as fixed points of equations is reasonably old
12:24:56 <noteventime> Though the traditional approach (before early 80s or something like that I think) was to work with partially ordered sets 
12:25:05 <noteventime> (or lattices)
12:25:11 <bollu> noteventime: right
12:25:23 <noteventime> That's what a lot of domain theory is about
12:25:54 <bollu> domains in the sense of..?
12:25:55 <nolrai2> Where is 'second' defined?
12:26:08 <noteventime> nolrai2: Arrow?
12:26:11 <nolrai2> bollu: partial functions, I think.
12:26:39 <noteventime> bollu: What nolrai2 said, though you can do it more abstractly in terms of lattices with certain structure 
12:26:41 <bollu> oh, hm
12:27:06 <bollu> stupid question - what makes partial functions so special other than being able to have points on the domain that don't map to anything?
12:27:26 <bollu> (we haven't formally done theory of computation in college yet, so..)
12:27:34 <nolrai2> So you can describe computations that diverge.
12:27:34 <noteventime> Approximation 
12:27:43 <bollu> how so?
12:28:04 <dolio> Haskell can have not just partial functions, but partially defined values.
12:28:24 <bollu> like, how do partial functions help with divergent values?
12:28:31 <bollu> divergent computations*
12:28:35 <noteventime> Arguably partial functions are morphisms in the kleisli category of the +1 functor :P
12:29:13 <dolio> The values on which the functions diverge don't map to anything.
12:29:16 <noteventime> As in analysis it is often convenient to describe things as limits 
12:29:34 <bollu> dolio: oh I see.
12:29:36 <k4pod> noteventime: is that another "are monoids in the category of endofunctors"? :D
12:29:39 <noteventime> but then you need a space to take the limits in 
12:29:52 <k4pod> "monads are monoids"*
12:30:02 <noteventime> k4pod: Indeed
12:30:08 <noteventime> Or, it is now, perhaps :P
12:30:12 <bollu> so that's the only reason for it?
12:30:19 <noteventime> Well, that's the reason here
12:30:42 <bollu> haha, okau
12:30:45 <noteventime> From a software engineering perspective it's basically the same as having placeholder values for things that can fail 
12:30:46 <bollu> okay*
12:30:50 <bollu> so going back to the discussion of algebra :: f a -> a
12:31:01 <noteventime> So the situation is similar here
12:31:13 <noteventime> You're not so much interested in individual algebras f a -> a
12:31:16 <noteventime> but the category of such algebras 
12:31:36 <noteventime> In particular, whether the category has an initial object
12:31:36 <bollu> noteventime: and some of the algebras may not exist for certain choices of "f" and "a", right?
12:32:00 <noteventime> bollu: You can generally find some algebras f a -> a for a in any sufficiently rich category 
12:32:28 <noteventime> if the category has a zero object you can always go f a -> 0 -> a
12:33:27 <noteventime> And if the category has at least a terminal object 1 you can always find a unique algebra f 1 -> 1
12:33:38 <noteventime> which will also turn out to be a terminal object in the category of f-algebras 
12:34:09 <bollu> hm, okay
12:34:37 <noteventime> You're generally not particularly interested in whether you can find algebras f a -> a for any particular a
12:35:13 <bollu> noteventime: in the category of all algebras, what are the objects and the arrows? the objects are Obj :: f a -> a, and the arrows (f a -> a) -> (g a -> a) ?
12:35:28 <noteventime> bollu: commutative squares 
12:35:54 <noteventime> bollu: Not the category of all algebras (generally)
12:36:01 <noteventime> but the category of algebras for some particular functor 
12:36:34 <bollu> noteventime: oh, so objects are f a -> a, f b -> b, .. ?
12:36:40 <noteventime> yes
12:36:46 <noteventime> and morphisms will be morphisms m : a -> b in the underlying category such that
12:36:56 <noteventime> f a --f m-> f b
12:37:13 <noteventime>  |            |
12:37:24 <nolrai2> My spell check doesn't like "recurse" :(
12:37:27 <noteventime>  a     --m->   b
12:37:27 <sinelaw> hey, is alloca expensive to call?
12:37:28 <noteventime> commutes 
12:37:35 <noteventime> sorry for the multiline text :)
12:37:37 <sinelaw> what does it do? 
12:37:40 <sinelaw> does it malloc?
12:37:44 <bollu> noteventime: aren't you describing fmap? doesn't fmap commute that way? :)
12:37:47 <sinelaw> does it alloca? :)
12:38:17 <noteventime> sinelaw: https://hackage.haskell.org/package/base-4.8.2.0/docs/src/Foreign.Marshal.Alloc.html#alloca
12:38:24 <noteventime> did you check the source :)
12:38:41 <noteventime> bollu: fmap is jut the upper part of that square
12:38:51 <noteventime> f m == fmap m 
12:39:06 <nolrai2> Whats a good name for 'type X a = Either a a'?
12:39:38 <nolrai2> Maybe 'ShortCircuit'?
12:39:54 <k4pod> why not (a, a)?
12:40:40 <bollu> oh right. But yes, I can see how it needs to commute, I think
12:40:58 <bollu> noteventime: right, so we have the category for some "f" of all f-algebras (is that how it is called?)
12:41:07 <bollu> with the morphisms being arrows that commute correctly
12:41:12 <noteventime> nolrai2: Double?
12:41:58 <noteventime> bollu: We can think of this category as a sort of category of partial or potential solutions to f a ~ a
12:42:29 <noteventime> nolrai2: Too bad it's taken X-E
12:42:41 <bollu> noteventime: how ~ ? (as in, how do you know a -> f a is a given? because f is a functor, correct? and f a -> a is what your category will have objects of, right?)
12:42:46 <nolrai2> k4pod: uh, Either a a, and (a,a) are rather different. Either a a ~ (Bool, a) but has a nice monad instance.
12:43:15 <noteventime> bollu: If you have f a -> a you're "half way there", you just need there to exist an inverse :)
12:43:31 <nolrai2> Left a = We are done. Right a = keep doing steps.
12:43:32 <bollu> noteventime: right, understood :)
12:43:35 <bollu> noteventime: okay, go on.
12:44:23 <noteventime> bollu: Now, it's a good exercise (not very hard) to show that one way to find a solution to f a ~ a is to find an initial object in this category 
12:44:55 <bollu> noteventime: okay
12:45:30 <noteventime> bollu: The morphism f a -> a corresponds then, roughly speaking, to a constructor 
12:45:43 <noteventime> and the morphism a -> f a corresponds to pattern matching 
12:46:45 <bollu> noteventime: wait what, isn't it the reverse?
12:46:50 <noteventime> The really nice thing about solutions constructed this way is that you also get a notion of recursive computation on such structures 
12:47:01 <bollu> a -> f a is "giving me more" and f a -> a is "extracting out"
12:47:16 <noteventime> bollu: a is the object that contains all values of your data type 
12:47:34 <noteventime> so f a -> a builds a value of a
12:47:38 <bollu> noteventime: corrrect
12:47:41 <noteventime> given a specification f a
12:47:52 <bollu> noteventime: I.. guess?
12:48:03 <bollu> and a -> fa?
12:48:03 <bollu> a - f a?
12:48:03 <noteventime> while a -> f a takes it apart into various pieces again
12:48:04 <bollu> a -> f a**
12:48:19 <noteventime> so if f a = (String, a)
12:48:28 <bollu> noteventime: I don't understand how you choose to view an "enriched" structure f a as "less information than" a
12:48:50 <noteventime> bollu: We have an isomorphism, so none of them have less information 
12:49:00 <bollu> like, (f a) is a *and more* in some sense, right? (unless you say Const a b I guess)
12:49:09 <bollu> noteventime: right, so how do you choose to view it that way?
12:49:17 <bollu> noteventime: I mean, it doesn't seem right. But do go on
12:49:27 <noteventime> bolly: Take f a = (String a)
12:49:31 <bollu> okay
12:49:34 <noteventime> and say A is a fixed point 
12:50:05 <noteventime> (I've made a little mistake here, because we're going to be interested in coalgebras rather than algebras of this particular functor, but the theory is much the same)
12:50:11 <bollu> of f, correct?
12:50:16 <noteventime> indeed
12:50:22 <bollu> alright
12:50:31 <noteventime> so f A -> A
12:50:38 <noteventime> is actually (String, A) -> A
12:50:45 <noteventime> or in curried form
12:50:49 <noteventime> String -> A -> A
12:51:01 <noteventime> You might recognise this as cons
12:51:24 <noteventime> while A -> (String, A) is uncons (i.e. a -> (head a, tail a))
12:51:48 <bollu> okay
12:51:57 <bollu> so you're bringing back streams for this, correct?
12:52:33 <noteventime> bollu: Fixed points of this particular functor will look like streams, yes
12:53:28 <bollu> noteventime: alright, what next? :)
12:53:29 <OverCoder> <3 Haskell
12:53:43 <OverCoder> Lots and LOTS! of stuff can be done in a line
12:54:05 <noteventime> <3 Awk, for the same reason (not!)
12:54:16 <OverCoder> hm
12:54:24 <noteventime> :P
12:54:48 <noteventime> bollu: Well, what makes an initial object initial?
12:55:09 <bollu> noteventime: unique arrows from the initial object to every other object
12:55:18 <bollu> one arrow / unique arrow
12:55:22 <noteventime> bollu: So what does this mean for an f-algebra 
12:55:34 <radens> Are there any MLs which allow you to control the layout of memory? Say they allow me to write to the address 0xb8000?
12:55:38 <radens> Or maybe create a struct 64 bits wide with two 8 bit fields, a 16 bit field and a 32 bit field, packed?
12:55:53 <noteventime> radens: Binary?
12:55:53 <joko> Hello, is anyone familiar with Haskell's X11 bindings?
12:56:05 <radens> noteventime: huh?
12:56:55 <noteventime> radens: Data.Binary 
12:56:57 <noteventime> for the latter
12:56:58 <bollu> noteventime: you have a unique type X such that there is one morphism from (f X -> X) to any (f a -> a) right?
12:57:23 <radens> hm thanks
12:57:27 <noteventime> bollu: Yes, so say you have A from before, which was an initial object
12:58:25 <noteventime> bollu: The fact that it's initial means you get for any other f-algebra on, say, B, a morphism A -> B
12:58:42 <noteventime> that satisfies the commutative square from before
12:58:45 <bollu> right
12:59:08 <noteventime> so because it's initial you get a way to specify functions 
12:59:43 <noteventime> bollu: The cool thing is that, this turns out to be the natural way to give semantics to recursively defined functions 
13:00:11 <bollu> noteventime: this is getting a little too much to absorb in one go
13:00:16 <bollu> noteventime: can we continue this tomorrow?
13:00:25 <bollu> noteventime: so I get some time to play around with the ideas
13:00:27 <bollu> ?
13:00:35 <noteventime> bollu: I can't promise anything, but try pinging me to see if I'm around 
13:00:56 <noteventime> bollu: Otherwise all this is pretty standard stuff 
13:00:56 <nitrix> "noteventime", "get some time". The irony.
13:01:06 <noteventime> :)
13:01:10 <bollu> I shall :)
13:01:13 <bollu> thanks a lot!
13:01:17 <noteventime> no worries 
13:01:24 <bollu> I really appreciate all the time you took to explain this stuff ^_^
13:01:45 <bollu> night, everyone
13:21:38 <tibbe> .
13:28:05 <dalastboss> Does using overloaded strings incur runtime penalty?
13:29:36 <noteventime> dalastboss: Compared to?
13:29:40 <hpc> dalastboss: it inserts fromString everywhere you use string literals
13:33:12 <andromeda-galaxy> does anyone know of a way to make it possible to define a default instance (e.g. Eq a => X a) and some other instances for types that are (currently, at least, not eq) when the class has an associated type family?  Denoting the Eq a => X a instance with {-# OVERLAPPABLE #-} doesn't work since the type family overlaps...
13:33:41 <andromeda-galaxy> (and using a separte closed type family doesn't work because ghc can't probably deduce that the output of the type family is correct)
13:34:03 <andromeda-galaxy> (I imagine that I could do a horrible template haskell hack to autogenerate a bunch of instances, but it would be annoying..)
13:36:33 * hackagebot Cabal 1.22.7.0 - A framework for packaging Haskell software  https://hackage.haskell.org/package/Cabal-1.22.7.0 (ryant)
13:37:23 <enthropy> andromeda-galaxy: you could use FunctionalDependencies instead
13:37:51 <andromeda-galaxy> enthropy: FunctionalDependencies don't play nicely with {-# OVERLAPPABLE #-} either, though, do they?
13:38:22 <andromeda-galaxy> (maybe I did something wrong, but I tried using them in this use case before the associated type families, and still got problems)
13:39:38 <enthropy> andromeda-galaxy: http://lpaste.net/150791
13:40:04 <puregreen> is there some way to simplify this Binary instance? http://lpaste.net/150790
13:40:19 <puregreen> I can't derive an instance automatically because it's a GADT
13:40:35 <andromeda-galaxy> enthropy: hmm...
13:41:42 <andromeda-galaxy> enthropy: the "general" instance is using a class constraint though, and since classes are open, ghc won't believe that the "Special" type won't get an instance
13:41:45 <andromeda-galaxy> (which is reasonable)
13:42:14 <andromeda-galaxy> but unfortunately, making the main instance be '(Class a, IsSpecial a ~ False) => X a Bool' doesn't work either
13:42:42 <andromeda-galaxy> (where IsSPecial is a closed type family with IsSpecial (Special a) = True and IsSpecial a = False)
13:43:40 <enthropy> andromeda-galaxy: you're saying you get an error like "Functional dependencies conflict between instance declarations"?
13:44:07 <RyanGlScott> puregreen: Probably not, given that the GHC codebase itself has to write Binary instances like that for its GADTs: http://git.haskell.org/ghc.git/blob/fd6dd41c67f3bd23bbf074357219cfd251eb53d6:/libraries/ghci/GHCi/Message.hs#l309
13:44:13 <andromeda-galaxy> enthropy: "Functional dependencies conflict between instance declarations:"
13:44:58 <enthropy> andromeda-galaxy:    instance (Class a, IsSpecial a ~ False, b ~ Bool) => X a b -- change it to that?
13:45:10 <pavonia> Why can't you derive Binary for GADTs?
13:45:16 <andromeda-galaxy> enthropy: oh that's awesome
13:45:24 <andromeda-galaxy> I was just reading about that trick the other day, why didn't I think of it?
13:45:30 <geekosaur> pavonia, you can;t derive anything for GADTs
13:45:32 <andromeda-galaxy> thank you!
13:45:47 <RyanGlScott> pavonia: There's no known good way of representing existential constraints generically.
13:45:53 <puregreen> RyanGlScott: thanks!
13:46:20 <pavonia> RyanGlScott: Ah, okay
13:46:24 <andromeda-galaxy> enthropy: I didn't realized that that would work with fundeps, thanks for the suggestion, it works!
13:46:33 <RyanGlScott> pavonia: At least, José Pedro Magalhães found a way to represent phantom constraints, but that's about it
13:47:02 <RyanGlScott> pavonia: http://dreixel.net/research/pdf/gpid.pdf
13:47:19 <enthropy> andromeda-galaxy: no problem. I don't really see why that change should make it work but it apparently does
13:47:50 <andromeda-galaxy> enthropy: now that ou mentioned it, I remember seeing a good explanation a while ago:
13:47:57 <andromeda-galaxy> enthropy: http://chrisdone.com/posts/haskell-constraint-trick
13:48:35 <andromeda-galaxy> though actually, that doesn't explain why it works with fundeps in this particular case, neve rmind.
13:48:43 * Guest92559 Hi everyone, I'm new to both IRC and Haskell... can someone help me out?
13:48:46 <andromeda-galaxy> anyway it works!
13:48:50 <andromeda-galaxy> Guest92559: probably.
13:49:38 <puregreen> Guest92559: yep, ask your question
13:51:18 * Guest92559 cool; I'm trying to use the Criterion benchmarking package, but I'm having some issues
13:51:40 <Guest92559> specifically, I'm having trouble understanding how laziness interacts and messes up the benchmarking.
13:52:01 <OverCoder> does writing to a handle automatically flushes to the socket?
13:52:12 <OverCoder> Note that I have hSetBuffering to NoBuffering
13:53:50 <Guest92559> \me according to the tutorials, I need to use nf to force evaluation to normal form (the result is a record with computed fields)
13:54:06 <puregreen> that's right
13:54:08 <Guest92559> \me but the record needs to derive NFData, which I'm not sure how to do
13:54:28 <dmj> Guest92559: there is a function called 'nf' in Criterion
13:54:42 <dmj> meaning normal form, that will take care of it for you
13:55:22 <puregreen> Guest92559: you can derive NFData automatically in most cases
13:55:45 <puregreen> Guest92559: see an example here: http://hackage.haskell.org/package/deepseq-1.4.1.2/docs/Control-DeepSeq.html
13:55:46 <dmj> Guest92559: yea, using generics
13:55:46 <Guest92559> I'm not sure why, but my simple record doesn't seem to derive NFData automagically
13:56:11 <puregreen> Guest92559: can you show your code?
13:56:14 <puregreen> @where lpaste
13:56:14 <lambdabot> http://lpaste.net/
13:56:40 <puregreen> note that it won't be completely automagical – you still need to enable DeriveGeneric and derive Generic and NFData
13:56:56 <Cale> Guest92559: Typically all you have the instance do is  rnf (MyRecord x y z) = rnf x `seq` rnf y `seq` rnf z
13:57:03 <Cale> Guest92559: something like that
13:57:11 <Guest92559> http://lpaste.net/150792
13:57:21 <Cale> But yeah, there are TH macros which can write it for you
13:57:35 <Cale> Usually not really necessary because it's like one line :P
13:57:48 <Guest92559> I pasted a lot of code, only the bottom portion has the benchmarking code.
13:58:18 <puregreen> Guest92559: okay, step one: enable the DeriveGeneric extension. Do you know how to do that?
13:58:24 <Cale> That's a pretty crazy record type :)
13:58:49 <Cale> But yeah, the same idea applies
13:59:01 <Guest92559> is that bad design, btw? I'm a newbie haskeller, lol
13:59:14 <Cale> I'd probably try to factor it...
13:59:49 <Guest92559> I believe you set a flag between curly brackets?
14:00:06 <Cale> It seems like it's a combination of 4 records, two of which are the same type
14:00:06 <Guest92559> \msg Cale factor it?
14:00:24 <Cale> I mean, pull it apart into smaller record types
14:00:30 <Guest92559> I see
14:00:54 <Cale> the latter two could also be covered by the same definition perhaps
14:01:06 <Guest92559> well, first I just want it to work, then I'll make it pretty lol
14:01:07 <Cale> with a type parameter
14:01:09 <Guest92559> but you're right
14:01:42 <Guest92559> so does it suffice to derive from Generic?
14:08:46 <andromeda-galaxy> also: suppose I have a class 'a b c | a b -> c'; is there any way to get a constraint synonym that is effictely  Class' a = exists b. Class a a b?
14:10:36 <Strukks> I have a simple recursion where it returns the list until the first repeating character, but it always eats the last one, http://pastebin.com/3U3cGunr , how do I add the final character?
14:12:06 <Strukks> nvm, got it!
14:15:04 <OverCoder> Um, say I have parse :: (String line) => line -> ...
14:15:34 <OverCoder> the ... should actually be a list, containing few [Char], and sometimes another list of [Char]
14:15:38 <OverCoder> What should I put there?
14:18:18 <pavonia> OverCoder: What is "String line" supposed to mean?
14:18:36 <OverCoder> um, the raw IRC line
14:18:37 <OverCoder> :>
14:19:32 <pavonia> Have you defined a type class String?
14:19:53 <pavonia> Hhm, does that even work
14:21:06 <OverCoder> pavonia, String is a synonym for [Char]
14:21:10 <OverCoder> It's already defined in Haskell
14:21:25 <pavonia> Right, but you're using it as a type class
14:22:04 * hackagebot pipes-transduce 0.3.1.0 - Interfacing pipes with foldl folds.  https://hackage.haskell.org/package/pipes-transduce-0.3.1.0 (DanielDiazCarrete)
14:22:06 * hackagebot inline-r 0.8.0.0 - Seamlessly call R from Haskell and vice versa. No FFI required.  https://hackage.haskell.org/package/inline-r-0.8.0.0 (MathieuBoespflug)
14:22:08 * hackagebot H 0.8.0.0 - The Haskell/R mixed programming environment.  https://hackage.haskell.org/package/H-0.8.0.0 (MathieuBoespflug)
14:22:14 <pavonia> OverCoder: Or did you mean (String ~ line)?
14:27:05 * hackagebot ihaskell-inline-r 0.1.1.0 - Embed R quasiquotes and plots in IHaskell notebooks.  https://hackage.haskell.org/package/ihaskell-inline-r-0.1.1.0 (MathieuBoespflug)
14:27:33 <Guest92559> I have a question about Criterion and laziness... any takers?
14:27:45 <bsmt> it's best to just ask
14:27:56 <Guest92559> ok
14:28:26 <Guest92559> I have this benchmarking code, which returns abnormally low times: http://lpaste.net/150793
14:28:40 <Guest92559> I'd like to know why this is the case and how to fix it
14:34:12 <Guest92559> can someone help me with understand why this benchmarking code fails to actually run: http://lpaste.net/150793
14:36:08 <OverCoder> pavonia, ooh, yeah sorry I misused it, and for some reason I haven't got a notificaiton upon ping, but yeah I eventually fixed it
14:36:15 <OverCoder> but, now I have http://p.samuraimanpurse.com/XePqwAGr.txt if anyone can help me with it
14:37:21 <pavonia> OverCoder: You're missing a "do"
14:37:33 <OverCoder> awwww
14:37:38 <OverCoder> Bunch of thanks
14:38:06 <pavonia> Guest92559: With what error?
14:47:05 * hackagebot temporary 1.2.0.4 - Portable temporary file and directory support for Windows and Unix, based on code from Cabal  https://hackage.haskell.org/package/temporary-1.2.0.4 (RomanCheplyaka)
14:47:07 * hackagebot Cabal 1.20.0.4 - A framework for packaging Haskell software  https://hackage.haskell.org/package/Cabal-1.20.0.4 (ryant)
14:57:02 <OverCoder> Um, how do I return an empty IO, again?
14:57:05 <OverCoder> return IO?
14:57:07 <OverCoder> return IO ()?
14:57:10 <OverCoder> What was it?
14:57:12 <barrucadu> An empty IO?
14:57:26 <barrucadu> If you want a value of type IO (), it's return ()
14:57:28 <OverCoder> Yeah something that represents a placeholder in else cluse
14:57:31 <OverCoder> clause*
14:57:32 <dmj> > () <$ return () :: IO ()
14:57:34 <lambdabot>  <IO ()>
14:57:37 <OverCoder> ah okay, thanks
14:57:48 <Strukks> How do I avoid writing that useless "| otherwise" part? http://pastebin.com/xt9G0Psj
14:58:00 <barrucadu> "when" is probably more suitable if you have no meaningful else
14:58:02 <barrucadu> :t when
14:58:03 <lambdabot> Applicative f => Bool -> f () -> f ()
14:58:47 <geekosaur> Strukks, it's not useless since you're guaranteed to hit it
14:59:21 <Strukks> Yeah, but other languages just let you skip the else part if you don't want it to do anything
14:59:35 <geekosaur> so it's supposed to crash when n-1 == 0?
14:59:39 <Axman6> those are poor languages
14:59:48 <geekosaur> since currently that otherwise is the only way you even notice that case
15:00:02 <Strukks> You got a point
15:00:44 <Strukks> but what should I write in the "| otherwise" part?
15:00:52 <Strukks> that takes up the least space
15:02:34 <Strukks> Since it doesn't allow me to leave it empty
15:03:54 <Axman6> Strukks: when (m > 0) $ do {putStrLn sx; grammar (n-1,sx);}
15:05:32 <geekosaur> Strukks, given that it's in IO, return ()
15:05:47 <geekosaur> you might also want to look at Control.Monad.when as something more like "other languages"
15:06:21 <Strukks> http://pastebin.com/2GFUSXAL
15:06:29 <Strukks> this gives me a parse error, if I use "return ()"
15:06:40 <geekosaur> you need the =
15:06:41 <geekosaur> er
15:06:50 <Axman6> just use when >_<
15:06:58 <Axman6> you are literally reimplementing when
15:07:01 <Axman6> @src when
15:07:02 <lambdabot> when p s = if p then s else return ()
15:07:13 <Strukks> Hahaha, I'm not ready for that fancy when stuff yet :D
15:07:36 <geekosaur> why? it's what you were evoking with that "other languages" remark
15:08:10 <Strukks> Yeah, I'll keep it in mind
15:08:12 <Axman6> when is literally the equivalent to an if statement without an else clause
15:08:34 <Axman6> I even gave you the exact code you need
15:09:02 <Strukks> Yeah, I saved it, I was just still curious about the "| otherwise" part
15:10:38 <k3d3> How does when work? Wouldn't that require returning a unit?
15:10:54 <Axman6> yes, the source is shown above
15:11:03 <Axman6> when p s = if p then s else return ()
15:11:27 <Strukks> Is that code "curried"?
15:11:29 <Axman6> (actually, the current implementation would use pure instead of return, but that doesn't really matter)
15:11:43 <Axman6> Strukks: yes
15:12:03 <Strukks> Axman6, I'm having difficulty understanding what "curried" means, even after reading the haskell wiki entry
15:12:05 <k3d3> So doesn't that mean you have the option of returning unit... or else returning unit?
15:12:34 <Axman6> the returned type will be the same, but the effects from the given monad will still happen
15:12:35 <k3d3> Oh, is that meant for side effects?
15:12:42 <k3d3> Ah, I get it now
15:13:12 <Strukks> Axman6, what does an uncurried function look like? How would "grammar"  look like uncurried?
15:13:49 <Axman6> grammer as you've written it is already uncurried
15:14:04 <Axman6> you can't pass in arguments to grammer one at a time
15:14:15 <Axman6> normally we're write it as grammer n sx = ...
15:14:50 <Axman6> (or probably grammar sx n because it seems like you're more likely to change n than sx
15:15:21 <Strukks> How would grammar look like "curried"?
15:15:55 <Axman6> grammar sx n = when (n > 0) $ putStrLn sx >> grammar sx (n-1)
15:16:12 <Axman6> (removing the do because it's annoying on a single line)
15:17:44 <Strukks> so "grammar sx n" is curried, but "grammar (n, sx)" is not? It's just the beginning that matters? 
15:18:00 <Axman6> "the beginning"?
15:18:10 <Strukks> the "first line"
15:18:12 <Strukks> :D
15:18:50 <Axman6> writting grammar curried means you can write let printHello = grammar "Hello" in printHello 7 to have Hello printed 7 times
15:24:14 <Strukks> http://pastebin.com/MssPGuJm this is or isn't curried?
15:25:55 <Axman6> "Pastebin.com is under heavy load right now :("
15:26:05 <andromeda-galaxy> Axman6: lpaste.ne
15:26:08 <Strukks> http://puu.sh/mIosd/a084e198c4.png
15:26:11 <andromeda-galaxy> lpaste.net
15:26:23 * Axman6 isn't the one using pastebin...
15:26:30 <andromeda-galaxy> oops, sorry. meant to say:
15:26:32 <andromeda-galaxy> Strukks: ^
15:26:55 <Axman6> Strukks: yes, that is curried
15:27:13 <Strukks> Axman6, ok, that's good
15:32:07 * hackagebot extensible-effects 1.11.0.2 - An Alternative to Monad Transformers  https://hackage.haskell.org/package/extensible-effects-1.11.0.2 (shergill)
15:32:12 <mrlase> is there a way to define multiple possible types for a field in a new data type? i.e. `data Fiz = Fiz { message :: String | Bar }`?
15:32:22 <mrlase> so message could be either String or Bar?
15:32:33 <barrucadu> mrlase: If you only have two, use the Either type
15:33:14 <mrlase> thanks!
15:35:18 <milena> Does anybody have an example on trees with more than 2 children? P.S.: I can't use de Data.Tree package...
15:37:13 <pavonia> milena: Why can't you?
15:38:23 <milena> pavonia it's for an exercise, to learn functional programming better :P
15:39:06 <pavonia> Well, you could take a tree with two chilrdren and add a third one
15:39:40 <pavonia> or a fourth, or replace the fixed number of children with a list
15:40:16 <milena> I guess that a list would work better 
15:40:32 <milena> I'll try this. Thanks, pavonia 
15:40:40 <mrlase> barrucadu: not sure I understand how to apply the Either type, i.e. `Fiz { message :: Either String Bar }`?
15:41:01 <barrucadu> mrlase: Yes. You can then pattern match on it to get the values out, the constructors are Left and Right
15:41:59 <kaizoku> hmm, oddly my main function instantly returns on this shell server
15:42:01 <kaizoku> works fine on my laptop
15:47:24 <andromeda-galaxy> why can't GADTs by GADT-like in kind arugments?
15:48:58 <RyanGlScott> andromeda-galaxy: GHC's kind system wasn't sufficiently powerful enough to support it (until GHC 8.0, that is)
15:49:08 <andromeda-galaxy> ah, okay.  8.0 will allow it though?
15:49:11 <RyanGlScott> Yep
15:49:32 <RyanGlScott> (With -XTypeInType on, that is)
15:49:35 <andromeda-galaxy> that's nice.  7.12 has all kinds of annoying barriers to really fun type-level trickery without singletons
15:50:01 <andromeda-galaxy> thanks for the explanation!
15:50:02 <hpc> jeez haskell moves fast
15:50:18 <hpc> it seems like yesterday 7.4.1 was the best thing since sliced bread
15:54:57 <Strukks> Is there anything in prelude that lets me do "x = 0, x = x +1"?
15:55:34 <andromeda-galaxy> Strukks: you mean having mutable variables?
15:56:28 <Strukks> I basically want to do "list = []" and then "list = x : list"
15:56:28 <Strukks> in a cycle
15:57:40 <andromeda-galaxy> Strukks: if I'm understanding you right, one way to do that would be to define a little recursive function and start it off with a call to 'f []'
15:57:51 <kaizoku> Strukks: variables in haskell are immutable
15:57:57 <kaizoku> you cannot change them after they're defined
15:58:19 <andromeda-galaxy> kaizoku: I was attempting to ascertain whether or not Strukks knew that yet
15:58:29 <CodeWeaver> Greetings.
15:58:29 <Strukks> ugh, ok
15:58:29 <Strukks> I did not
15:58:40 <andromeda-galaxy> ah, that explains the confusion
15:59:07 <CodeWeaver> Anybody here knowledgable enough about GHC primitives to answer an obscure question?
15:59:25 <andromeda-galaxy> Strukks: yeah, Haskell wouldn't really be *pure* if we had mutable variables, since any assignment would modify a value somewhere (destroying the old one) and destroy the old value, producing a side effect
15:59:52 <adas> on ghci when I do `parseTimeM False defaultTimeLocale  "%F" "2015-12-18" :: IO Day` it works .. but when I run it in a program I get `parse error (Failed reading: conversion error: parseTimeM: no parse of \"\\\"2015-12-18\\\"\") at \r\n2015(truncated)`. Could someone please tell me what I migth be overlooking?
16:00:02 <begriffs> Anyone know what --reorder-goals does in cabal? I just had a situation where cabal could not figure out how to install dependencies without it. (And yes, I normally just use Stack, but I wanted to know how cabal works below the surface.)
16:00:06 <CodeWeaver> I'm kind of curious if there's a language pragma or GHC specific package to expose the W8# constructor.
16:01:33 <andromeda-galaxy> hmmm.. is there any way to make a partially applied type synonym a type class instance?
16:01:37 <geekosaur> adas: you are parsing a string value that contains quotes
16:01:51 <glguy> CodeWeaver: You'll need the MagicHash extension and then W8# is exported by GHC.Word
16:02:06 <geekosaur> compare: parseTimeM False defaultTimeLocale  "%F" "\"2015-12-18\"" :: IO Day
16:02:14 <CodeWeaver> glguy:  I've got GHC.Word being imported as far as I know, and magichash is already on.
16:02:32 <CodeWeaver> Oh wait, no, I only have Data.Word.  Let me try that.
16:02:32 <glguy> Cool, then you're all set
16:02:40 <andromeda-galaxy> (the idea here is that I want 'instance Class m => Class (Wrapper m)', but that doesn't work directly because class Class (m :: Nat -> Nat -> * -> *))
16:02:59 <adas> geekosaur: if that is the case where do all those extra forward slashes come from? \"\\\"2015-12-18\\\"\"
16:03:08 <CodeWeaver> glguy that's brilliant.  Thank you.
16:03:15 <pikajude> are hackage load times in the 30s+ range for anyone else
16:03:40 <geekosaur> adas: probably an extra `show` somewhere
16:03:56 <geekosaur> > show "foo"
16:03:57 <lambdabot>  "\"foo\""
16:04:04 <geekosaur> > show "\"foo\""
16:04:05 <lambdabot>  "\"\\\"foo\\\"\""
16:04:11 <adas> ah yes. I am using a show
16:04:12 <andromeda-galaxy> oh wait, I forgot, no type synonym partial application
16:04:21 <andromeda-galaxy> is there any plan for getting around the lack of it?
16:04:26 <kaizoku> Strukks: you can still do what you're looking for, just with one assignment
16:05:19 <geekosaur> note that the parse error is also invoking show on the input string
16:05:36 <geekosaur> so yes, you end up with a bunch of nested quotes and each additional nesting inserts \s
16:07:02 <adas> geekosaur: thanks that worked
16:07:38 * hackagebot wsdl 0.1.0.1 - WSDL parsing in Haskell  https://hackage.haskell.org/package/wsdl-0.1.0.1 (pikajude)
16:07:40 <adas> i had to use a show because the library Im using works in bytestrings and parseTime only works on Strings
16:09:19 <CodeWeaver> glguy:  If I might impose on you again, I'm curious if there's a master list of the GHC modules around somewhere... hackage doesn't list GHC.Word, even in the ghc-prim package.  (Though granted, I haven't looked in the cabal files)
16:09:37 <glguy> http://hackage.haskell.org/package/base
16:09:58 <glguy> CodeWeaver: and you can use tab-completion on the :m command in GHCi or you can use ghc-pkg describe <pkgname> to list modules
16:10:04 <CodeWeaver> I'm in your debt.  Didn't occur to me to look in there.
16:10:18 <glguy> Cool, debt! I could use a Coke.
16:10:33 <CodeWeaver> When my teleporter is out of the shop I'll totally do that. ;)
16:11:33 <Strukks> What am I doing wrong? = http://lpaste.net/150800
16:12:18 <andromeda-galaxy> Strukks: okay, what type do you want countSymbols to have?
16:12:43 <Strukks> andromeda-galaxy: umm, int?
16:13:11 <andromeda-galaxy> Strukks: okay, then, let's look at what the types of some individual parts are.
16:13:31 <andromeda-galaxy> @ty getLne
16:13:33 <lambdabot>     Not in scope: ‘getLne’
16:13:33 <lambdabot>     Perhaps you meant one of these:
16:13:33 <lambdabot>       ‘getLine’ (imported from Prelude),
16:13:40 <andromeda-galaxy> @ty getLine
16:13:42 <lambdabot> IO String
16:13:44 <andromeda-galaxy> @ty show
16:13:45 <lambdabot> Show a => a -> String
16:14:19 <Strukks> @ty length
16:14:20 <lambdabot> Foldable t => t a -> Int
16:14:39 <andromeda-galaxy> (replace that t with a [] if you don't know what Foldable is)
16:15:06 <adas> geekosaur: thanks for that info. i was able to  understand why showing something like "\"2015-10-18\"" would print "\"\\\"2015-10-18\\\"\""
16:15:10 <Strukks> @ty length []
16:15:12 <lambdabot> Int
16:15:36 <adas> so i was doing one show and that include the characters '\' and '"' into the string.
16:16:03 <ReinH> begriffs: ping
16:16:08 <adas> when show(n) again, the '\' and '"' end up being escaped again.
16:16:20 <Strukks> andromeda-galaxy: So are you saying I need to do type signatures for it to work? or?
16:16:34 <begriffs> ReinH: pong
16:16:44 <andromeda-galaxy> nope, think about what some of those rignatures mean (and also, desugar the do notation)
16:17:05 <ReinH> begriffs: hey! Are there instructions for installing haskell-vim-now for neovim? I see a script but I'm not sure when to run it and what else needs to be run in what order.
16:17:38 <begriffs> Let me check, I don't use neovim myself but I know there was a pull request about it.
16:17:53 <ReinH> begriffs: Oh it looks like it tells me to run it after I run the main install script
16:18:24 <geekosaur> adas, so my guess is (a) show on the original string (b) the parse error message did show on the string being parsed (c) then you used show on the parse error (possibly implicitly via `print`)?
16:18:26 <andromeda-galaxy> Strukks: okay, what's the desugaring of the do notation there?
16:18:31 <ReinH> begriffs: Also, if I may, how is the stack support?
16:18:41 <geekosaur> (leaning toothpick syndrome: hours of debugging \"fun\")
16:18:43 <Strukks> andromeda-galaxy: I googled :D
16:18:44 <ReinH> Do I need to do anything special to configure ghc-mod and etc to use stack?
16:19:02 <Strukks> andromeda-galaxy: I don't need "do" because it's a single statement or something, right?
16:19:04 <glguy> Strukks: the type error was because you used the expression   show (length (x:xs))    which has type [Char]   in a place where  something of type   IO a was expected
16:19:15 <begriffs> ReinH: after running the normal haskell-vim-now installer I think you just run ~/.config/haskell-vim-now/scripts/neovim.sh which will be there.
16:19:36 <ReinH> Yeah, the installer told me to run that and I did. Your software answered my question for me. :)
16:19:50 <andromeda-galaxy> Strukks: okay, bad timing---I've got to leave for something.. there are lots of other people here to help, but read up a little bit more on the IO monad & what Haskell's purity means
16:20:08 <Strukks> andromeda-galaxy: alright
16:20:14 <glguy> Strukks: what did you expect your code to do exactly?
16:20:24 <glguy> in English
16:20:24 <begriffs> And it works with Stack just fine. (I had to switch from ghc-mod to hdevtools for some things but I think I may be able to switch back to ghc-mod now that one of its vim/stack compatibility was fixed)
16:20:55 <Strukks> glguy: You enter lines until you enter a empty line and then it gives you the sum of all the symbols you've entered
16:21:12 <glguy> Strukks: "gives you"? that means prints to screen? returns?
16:21:24 <Strukks> glguy: prints
16:21:36 <glguy> OK, show doesn't print, it turns (in this case) numbers into strings
16:21:44 <glguy> print prints, though
16:22:05 <adas> geekosaur: I think a and b. not c
16:22:15 <ReinH> begriffs: Excellent. Thanks :)
16:22:29 <adas> if c had happened then that would cross a whole new level of escaping
16:22:37 <adas> > print "hi"
16:22:39 <lambdabot>  <IO ()>
16:22:42 <glguy> print x = putStrLn (show x)
16:22:55 <glguy> putStrLn writes Strings to the stdout followed by a newline
16:23:02 <glguy> and the show portion turns your number into a string
16:23:19 <mgsloan> ReinH: It works fairly alright.. ghc-mod isn't all that reliable for me, I spent a few hours a week or so ago figuring out what makes it break.  The main things are that it doesn't work with docker / nix stack configurations, and the error messages when there's a GHC mismatch are terrible
16:24:04 <Strukks> glguy, okay now it compiles, but I get an error right away :D
16:24:08 <ReinH> mgsloan: yeah, atm emacs support for the stack ecosystem seems to be lagging behind. :/
16:24:11 <luigy> I think there is also a case for multipackage + CPP that breaks ghc-mod
16:24:12 <mgsloan> Basically, instead of telling you that you built ghc-mod with the wrong GHC version, it just gives package satisfy errors https://github.com/DanielG/ghc-mod/pull/687
16:24:20 <glguy> Strukks: that's because you pattern matched [] against (x:xs)
16:24:59 <glguy> Your count function only works on non-empty lists as written and you first called it on an empty list
16:25:19 <glguy> so just use the pattern   "xs" instead of "x:xs"
16:25:27 <mgsloan> ReinH: Problem is that I that the intersection of "people who understand ghc-mod and can efficiently make changes to it" and "people who understand all the details of stack" is small if not nonexistent
16:26:15 <ReinH> heh
16:26:29 <ReinH> mgsloan: maybe one day that stack ide project will turn into something usable.
16:26:32 <Strukks> glguy: thanks!
16:27:00 <mgsloan> ReinH: Yeah, hopefully haskell-ide-engine pans out
16:27:06 <luigy> hie \o/
16:27:19 <mgsloan> It's based on ghc-mod right now, though, so any problems ghc-mod has with session initialization will also be shared by HIE
16:28:17 <mgsloan> The old stack-ide project is no longer being worked on, in favor of combinging efforts towards something hopefully excellent
16:28:41 <mgsloan> Also because adding new features to ide-backend was unnecessarily inconvenient.  Too many layers
16:31:47 <ReinH> begriffs: btw for <leader>e, :e %:h will also open the current path. You don't need to detect it.
16:32:12 <ReinH> begriffs: (:help filename-modifiers for more info)
16:33:08 <begriffs> Meaning I should probably remove the <leader>e binding because there's a standard vim command for it?
16:33:24 <ReinH> You can bind it to :e %:h instead of calculating the path
16:34:11 <ReinH> Personally I bind <leader>e to e **, which lets me do glob-based tab completion from the vim current directory. Most people don't know that you can use globs in paths in vim, it seems.
16:34:15 <ReinH> er, :e **
16:34:32 <ReinH> That's less useful when you are already using a fuzzy finder though
16:34:46 <ReinH> anyway, this is off-topic at this point, sorry
16:54:30 <Fylwind> Has anyone else run into the problem where Cabal leaves behind a bunch of /tmp/ccXXXXXX files?
16:55:15 <koz_> I'm a bit confused by the type of ordNubBy: http://hackage.haskell.org/package/classy-prelude-0.12.5/docs/ClassyPrelude.html#v:ordNubBy
16:55:23 <koz_> I get the first functional argument, but what's the second one all about?
17:00:29 <kenV> what are non-character characters besides underscore that can be used for a field name?
17:00:45 <Axman6> '
17:00:54 <kenV> Axman6 only at the end right?
17:00:59 <Axman6> anywhere
17:01:04 <kenV> I can't do foo'asdf' ?
17:01:19 <Axman6> > let can't = True in can't
17:01:19 <pavonia> Non-character characters O.o
17:01:21 <lambdabot>  True
17:01:36 <kenV> oh looks like i can
17:01:40 <kenV> what else?
17:01:48 <kenV> besides _ and '
17:01:57 <sm> unicode characters
17:03:14 <Bor0> digits, by assumption that you meant "non-letter characters"
17:04:08 <kenV> Bor0 non-alphanumeric ..
17:04:21 <kenV> the application is that i'm defining types for a JSON rest api
17:04:39 <kenV> need to find substitutes for json field names with crap like space, paren, dash
17:05:19 <kenV> and then use the generics with fieldLabelModifier
17:05:44 <koz_> I'm a bit confused by the type of ordNubBy: http://hackage.haskell.org/package/classy-prelude-0.12.5/docs/ClassyPrelude.html#v:ordNubBy
17:05:47 <koz_> I get the first functional argument, but what's the second one all about?
17:05:56 <jle`> koz_: the haskell report gives a pretty thorough and easy-to-read answer
17:06:03 <sm> hmm, trouble entering unicode characters in ghci here. Aren't they allowed in identifiers ?
17:06:05 <jle`> * kenV , sorry
17:06:57 <koz_> jle`: The Haskell Report deals with classy-prelude?
17:07:07 <jle`> it was supposed to be for kenV , heh, sorry
17:07:09 <jle`> k<tab>
17:07:19 <koz_> jle`: Ah, OK. I was wondering...
17:07:21 <pavonia> sm: Letters are
17:07:47 <pavonia> > let π = pi in π
17:07:50 <lambdabot>  3.141592653589793
17:08:02 <jle`> sm: use isSymbol to check
17:08:11 <jle`> > isSymbol 'π'
17:08:13 <lambdabot>  False
17:09:01 <sm> > isSymbol 'Р'
17:09:03 <lambdabot>  False
17:10:11 <sm> urghh.. I was forgetting the let. This ain't python
17:11:17 <pavonia> For the first charcater it's isLower, for all other it's isAlphaNum
17:11:35 <pavonia> (plus _ and ')
17:12:08 <andromeda-galaxy> is there any way to, with OverlappingInstances, make it legal for the choice of instance to depend on the instantiation of various type parameters?
17:13:54 <hpc> andromeda-galaxy: you mean like
17:14:03 <hpc> instance C (T a Int)
17:14:08 <hpc> instance C (T a String)?
17:14:17 <kenV> why does aeson spit out warnings when I use generics for ToJSON? Is that a bug?
17:14:44 <andromeda-galaxy> hpc: not exactly..
17:15:04 <andromeda-galaxy> hpc: I have instance {-# OVERLAPPABLE #-} (Class1 a, IsSpecial a ~ False, b ~ Bool) => NewClass a a b
17:15:24 <andromeda-galaxy> and also instance (Class1 a) => NewClass (Special a) (Special a) (Special Bool)
17:16:03 <andromeda-galaxy> the class is 'class Class a b res | a b -> res where op :: a -> b -> res'
17:16:11 <adas> The Day type in Data.Time.Calendar does not have an instance of Show. But when I create a custom type with one of the fields having type Day and deriving (Show), why is that not an error?
17:16:34 <andromeda-galaxy> now, I want to be able to use op :: f a -> f b -> <something>
17:17:11 <andromeda-galaxy> hpc: where the above class instances mean that <something> is a 'Special Bool' if f == Special, and is a Bool otherwise
17:17:22 <andromeda-galaxy> The instances compile fine, but using them like that erulst sin:
17:17:34 <pavonia> adas: It has a Show instance
17:17:40 <andromeda-galaxy> Overlapping instances for Class (f a) (f a) cond0
17:17:40 <andromeda-galaxy> ...
17:17:53 <andromeda-galaxy> (The choice depends on the instantation of 'a, f, cond0'...)
17:18:21 <adas> the documentation in Data.Time.Calendar says otherwise
17:18:32 <adas> pavonia: there is only an instance for FormatTime
17:19:25 <pavonia> Huh, https://hackage.haskell.org/package/time-1.1.4/docs/Data-Time-Calendar.html
17:20:17 <pavonia> Oh wait, the newer version don't have one
17:20:27 <adas> pavonia: i was using this one https://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-Calendar.html
17:20:32 <adas> pavonia: yup. newer version
17:21:16 <pavonia> But the time package uses orphan instances anyway, so maybe there's still one hidden in some module
17:21:29 <adas> orphan instances?
17:22:23 <andromeda-galaxy> hpc: did that make sens?
17:22:32 <pavonia> adas: An instance not defined in either the module the data type or the class is defined
17:26:58 <Sonarpulse> is there any way to use attoparsec and get the text parsed instead of the parsed result?
17:27:08 <kenV> is use of MissingH frowned upon?
17:27:09 <Sonarpulse> that seems much easier than using scan
17:32:24 <andromeda-galaxy> hpc: oh, it turns out that I missed an f in an instance requirement (and an OVERLAPPABLE somewhere else), now it seems to be working
17:40:28 <pavonia> Sonarpulse: Unfortunately no. What do you need that for?
17:43:48 <Sonarpulse> pavonia: oh just trying to parse an exscaped string for now
17:43:55 <Sonarpulse> without getting a bunch of chars and concatting them back
17:44:07 <Sonarpulse> do you know why this is the case?
17:44:37 <Sonarpulse> I can't think of a performance issue with what I propose
17:44:43 <Sonarpulse> (granted that doesn't mean much)
17:45:09 <pavonia> I don't know why, I just remember I was told it isn't possible when I wanted something similar once
17:46:10 <Sonarpulse> did you open an issue, or ask ephemerally?
17:48:58 <pavonia> Sonarpulse: No, I used another approach (which I can't remember atm :S)
17:50:04 <Sonarpulse> pavonia: I think i might open another issue again
17:50:07 <Sonarpulse> just in case :)
17:50:09 <Sonarpulse> but thanks a lot
17:50:15 <glguy> match :: Parser a -> Parser (ByteString, a)
17:50:19 <glguy> Return both the result of a parse and the portion of the input that was consumed while it was being parsed.
17:50:28 <glguy> Sonarpulse: Yes, you can get the input text that matched
17:50:39 <Sonarpulse> oh thanks
17:50:43 <Sonarpulse> just in the nick of time :)
17:50:48 <glguy> pavonia: In the past it wasn't possible, it is now
17:51:30 <glguy> Bryan changed things in May of 2014 to make that possible
17:51:45 <Sonarpulse> was scan introduced earlier>
17:51:47 <Sonarpulse> *?
17:52:55 <pavonia> glguy: Ah, good to know
17:53:25 <kenV> could i get some feedback on my first servant client?
17:53:30 <kenV> http://lpaste.net/150788
17:53:53 <kenV> anything i could improve style/correctness wise...?
17:55:05 <dmj> kenV: you can drop "queries ensID" entirely, "exacQuery ensID" is the same thing
17:55:28 <glguy> Sonarpulse: I don't know, I just remembered reading this http://www.serpentine.com/blog/2014/05/31/attoparsec/ when it changed
17:56:08 <kenV> dmj thanks
17:56:25 <Welkin> dmj: darth jar jar, lol
17:56:38 <Welkin> dmj: how disappointed were you when you found out?
17:56:38 <Sonarpulse> glguy: thanks
17:56:46 <Sonarpulse> I suppose i can compare that date to versions
17:57:03 <Welkin> dmj: did you hold out hope until the very last moment of the film?
17:57:15 <dmj> kenV: might want to replace String for Text
17:57:21 <Welkin> then after the credits began to rool, you thought "maybe he is in the post-credits scene!"
17:57:26 <Welkin> roll*
17:57:34 <dmj> Welking: let's talk in #blah
17:57:40 <dmj> Welkin:*
17:57:40 <Welkin> Welking? lol
17:57:55 <dmj> heh
18:02:14 <kenV> ok cleaned up and now everything is text http://lpaste.net/150788
18:03:53 <dmj> kenV: I recommend newtyping every field and Capture
18:04:50 <kenV> dmj you mean custom types instead of Text?
18:05:02 <dmj> kenV: yes, but specifically newtyping
18:05:35 <dmj> kenV: also, most haskell style guides favor camel case on field names as opposed to underscores
18:05:36 <kenV> seems like it'd be pretty verbose, nearly doubling LOC. what's the benefit?
18:06:03 <dmj> kenV: safety, you have many Text's you might accidentally confuse them. Text is unessentially still untyped data
18:06:11 <kenV> dmj the underscores were for the benefit of generic instances
18:06:14 <dmj> essentially* 
18:06:44 <pdxleif> I can think of "deleteFirstsBy" as "diffBy"?
18:06:50 <kenV> dmj I guess I could have slightly more complicated fieldLabelModifier that would do the camelcase conversion.
18:06:52 <dmj> kenV: sure, but in aeson you can convert a camelCase field to an underscored json field name
18:07:41 <dmj> kenV: use camelTo2 '_'
18:07:57 <dmj> https://hackage.haskell.org/package/aeson-0.10.0.0/docs/Data-Aeson-Types.html#v:camelTo2
18:08:05 <dmj> er... maybe not aeson-0.10...
18:08:12 <Welkin> camelToe
18:08:18 <kenV> dmj ah nice
18:08:47 <kenV> dmj oh wait, except that the server field names are insanely inconsistent
18:09:14 <dmj> kenV: server field names?
18:09:29 <dmj> kenV: how so
18:09:30 <kenV> well the field names chosen by the REST server
18:09:50 <kenV> some fields are snake case, some fields are camelcase, some are snake with capital letters, some fields are even all caps
18:10:03 <kenV> within the same json even
18:10:11 <Welkin> kenV: so the api you are accessing is garbage then
18:10:18 <dmj> kenV: can you rewrite the server?
18:10:20 <sbrg> where are you getting that json? 9th circle of hell?
18:10:51 <Welkin> sbrg: it came from apple?
18:11:00 <kenV> dmj no i'm consuming from some public servers
18:11:20 <Welkin> kenV: you can always write your own parsers for each piece of data
18:11:22 <Welkin> it is very easy
18:11:26 <Welkin> I almost always do that
18:11:27 <kenV> Welkin unfortunately I'm stuck with these... I'm sure it'll be this bad for other servers as well. this is academia-made infrastructure
18:11:44 <Welkin> just write a FromJSON instance
18:11:59 <kenV> Welkin yeah, but it's so beautifully concise with generics :(
18:12:07 <Welkin> oh, or you could use servant-client
18:12:25 <kenV> wait servant-client??
18:12:37 <Strukks> I'm trying to rewrite the "Data.List" function "tails" but that the list is reversed, and it eats my first element, http://lpaste.net/150810, I saw one solution as using the given list instead of an empty list, but idk why it gives me an error then
18:12:38 <Welkin> it's for writing a client to consume an api
18:13:00 <kenV> Welkin oh isn't that  what i'm using now?
18:13:23 <Welkin> kenV: I don't know what you are using 
18:13:36 <kenV> sbrg well if hell = academic code ...
18:13:46 <kenV> academics' code
18:13:48 <Welkin> servant is for writing an api, servant-client is for consuming an api
18:13:50 <Welkin> if that is what you mean
18:14:03 <kenV> Welkin: i think that's already what i'm using http://lpaste.net/150788
18:14:04 <dmj> Welkin: yea, he's using that
18:14:11 <Welkin> aeson is just a json parser/marshal service
18:14:24 <geekosaur> that hell isn't usually so much academics' code as code that an academic handed off to their stdents to write for them wihout supervision >.>
18:14:25 <Welkin> okay
18:14:57 <geekosaur> (and yes, there are worse hells. the company that faffs up something in house to solve a problem and then decides to sell it. exhibit A: Cadence)
18:15:10 <kenV> geekosaur these aren't CS academics though. these are like half biologist half computer engineer people
18:15:45 <Welkin> geekosaur: there are worse things: apple, google, microsoft
18:15:45 <dmj> geekosaur: Cadence software?
18:16:03 <dmj> geekosaur: like healthcare
18:16:04 <kenV> hmm maybe the conciseness isn't worth the ugly variable names... perhaps i should ditch the generics.
18:16:13 <Welkin> in particular, apple is in the deepest pit of hell
18:16:21 <koz_> Could someone ELI5 the whole 'Generic' thing in Haskell?
18:16:25 <kenV> Apple code cannot be worse than code written by academics
18:16:29 <Welkin> I would never wish it upon my worst enemy
18:17:17 <Welkin> kenV: correctness and readability trumps conciseness any day
18:17:27 <Welkin> being concise is not a good thing
18:17:32 <Welkin> it could be confusing and wrong
18:17:38 <kenV> i know i know
18:18:42 <kenV> this code is very boilerplate-ish though
18:18:56 <Strukks> I got it working how I want, but I still don't understand why it would work with "tailz (xs:[]) xs" but not with "tailz xs xs", http://lpaste.net/150811
18:19:03 <kenV> it's already boilerplate-ish with the use of generics
18:20:06 <Welkin> Strukks: those are matching two different things
18:20:09 <kenV> I'll bet if I was clever with TH I could probably do something similar to Frames and guess types from an example json query
18:20:33 <Welkin> Strukks: the first pattern matches a list with one element and then anything, while the second pattern matches anything for both
18:22:43 <Strukks> Welking, do you mean "tailz bs (z : zs)" matches a list with one element and then anything?
18:22:50 <dmj> Welking: :)
18:25:54 <Welkin> Strukks: no, `tailz (x:[]) xs` matches a one-lement list and anything
18:26:01 <Welkin> x:[] is the same as [x]
18:26:16 <Welkin> xs can match anything at all
18:27:17 <Strukks> Now I get it
18:28:28 <kenV> is there a way to use the generic show in defining an instance of show?
18:28:30 <kenV> for example
18:29:08 <kenV> something like show x = P.map Data.Char.toLower (show x)
18:29:15 <kenV> where the RHS show right is the default show?
18:31:31 <Strukks> Welkin: it fails because "[x,y] : [z,n]" is an illegal move?
18:32:06 <Strukks> Welking: and it needs to be [x,y] : [[z,n]]
18:32:20 <dmj> kenV: if you use a newtype yea
18:32:31 <Welkin> Strukks: that is equivalent to matching [[x,y],[z,n]], where x, y z and n can be anything
18:33:28 <kenV> dmj in this case i have a new sum type
18:33:28 <Welkin> Strukks: x:y:z is equivalent to [x,y,z]
18:33:45 <kenV> dmj i want the show function to be the same as the "default" show function, but make it lowercase
18:34:16 <Welkin> kenV: yeah, you can do that
18:34:20 <Welkin> just define your own show instance
18:34:22 <kenV> i don't think newtypes apply in this case
18:34:36 <kenV> Welkin can I do it without explicitly pattern matching each constructor in the sum type?
18:34:48 <Strukks> Welkin, yeah, but "[x,y] : [z,n]" is illegal, but "[x,y] : [[z,n]]" isn't, is that why my code failed, or are you pointing at something else? Because I can't tell :D
18:34:51 <Welkin> kenV: yes
18:35:04 <kenV> Welkin how do i refer to the default "show"?
18:35:14 <Welkin> show = toLower . show
18:35:15 <kenV> I want something like show x = P.map Data.Char.toLower default_show x
18:35:38 <kenV> Welkin I think that freezes
18:35:40 <Welkin> oh, wait
18:35:43 <Welkin> you have a newtype?
18:35:50 <kenV> no it's just a sum type
18:36:10 <kenV> I guess I could wrap it in a newtype if that's the best way to do it
18:36:16 <pdxleif> I thought there was some Control.Arrrow thing for doing (a -> b) -> (a, a) -> (b, b)
18:36:18 <kenV> but it's not like i'm using the sum type for anything else
18:36:57 <Welkin> yeah, just match on each constructor
18:37:15 <kenV> aw man :P
18:37:18 <Welkin> either that, or define your own show function
18:37:27 <Welkin> myShow = toLower . show
18:38:24 <kenV> Welkin but I'm going to use this type as an argument to Capture in Servant
18:38:44 <kenV> doesn't servant invoke show to come up with the routing string?
18:40:56 <kenV> or otherwise how does Servant come up with the url string?
18:41:50 <Welkin> kenV: ToText
18:42:11 <Welkin> FromText/ToText
18:42:29 <roboguy`> :t join bimap
18:42:30 <lambdabot> Bifunctor p => (a -> b) -> p a a -> p b b
18:42:39 <pdxleif> @type join (***)
18:42:40 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
18:42:50 <pdxleif> @type join (***) (+1)
18:42:52 <lambdabot> Num a => (a, a) -> (a, a)
18:43:22 <pdxleif> I guess either way
18:43:25 <nitrix> Out of curiosity, what's a bifunctor?
18:43:41 <Welkin> nitrix: exactly what it counds like
18:43:44 <nitrix> BifunctorFoo a = MkFoo a a ?
18:43:48 <pdxleif> Like a functor but w/ two type params instead of one
18:43:49 <Welkin> look at the type
18:43:50 <Welkin> lol
18:43:51 <roboguy`> nitrix: it's something that is a covariant functor in two arguments
18:43:57 <pdxleif> @type bimap
18:43:58 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
18:44:22 <nitrix> Mhhh....
18:44:26 <pdxleif> > bimap (1+, "foo" ++) (5, "blah")
18:44:27 <lambdabot>      A section must be enclosed in parentheses thus: (1 +)    A section must ...
18:44:34 <nitrix> Can't you just have a product type instead and achieve the same thing?
18:44:45 <roboguy`> nitrix: Either is a bifunctor
18:44:52 <roboguy`> along with (,)
18:44:56 <nitrix> I see.
18:45:11 <pdxleif> >  bimap (1+) ("foo" ++) (5, "blah")
18:45:12 <lambdabot>  (6,"fooblah")
18:45:17 <Welkin> what about a dodecafunctor?
18:45:18 <nitrix> @instances Bifunctor
18:45:21 <lambdabot> on the commandline: Warning:
18:45:22 <lambdabot>     -fglasgow-exts is deprecated: Use individual extensions instead
18:45:22 <lambdabot>  
18:45:22 <lambdabot> <no location info>: Warning:
18:45:22 <lambdabot>     -XGeneralizedNewtypeDeriving is not allowed in Safe Haskell; ignoring -XGeneralizedNewtypeDeriving
18:45:23 <lambdabot> [4 @more lines]
18:45:45 <nitrix> Oh-oh. Broke lambdabot.
18:45:50 <pdxleif> > bimap (1+) ("foo" ++) (Left 5)
18:45:52 <lambdabot>  Left 6
18:46:22 <Welkin> a myriafunctor!
18:46:28 <nitrix> That's actually cool.
18:46:42 <nitrix> Are there BiApplicatives too?
18:47:09 <roboguy`> yep!
18:47:22 <nitrix> I'd assume the two functions are just composed.
18:48:02 <RyanGlScott> http://hackage.haskell.org/package/bifunctors-5.1/docs/Data-Biapplicative.html
18:48:06 <Strukks> Ugh, http://lpaste.net/150813, first works, second doesn't, why does "if c == d" work, but "if c=='1' && d=='0'" not work?
18:48:21 <Strukks> It says parse error on input 'if'
18:48:47 <nitrix> <<$>> and <<**>>, that's confusing.
18:48:50 <nitrix> Why not <<*>> ?
18:50:07 <nitrix> Oh it's two functions, okay as expected.
18:51:05 <roboguy`> Strukks: the indentation is wrong. It needs to line up. I'd suggest not using tabs
18:51:17 <Welkin> Strukks: oh yes, avoid tabs at all costs
18:51:27 <Welkin> have your text editor convert tabs to spaces
18:51:33 <Welkin> and use haskell-mode
18:51:45 <RyanGlScott> And if you use GHC 7.10+ with -Wall, it will even warn you about tabs :)
18:52:59 <Strukks> It usually does warn me about tabs, so it's bizarre it didn't this time, but thanks!, it works now
18:53:46 <Welkin> Strukks: generally avoid using if-then-else
18:53:54 <RyanGlScott> Well, if you get a parse error, it can't very well give you warnings, since it can't figure out what to warn about :)
18:53:57 <Welkin> use pattern matching and guards instead
18:54:35 <Strukks> Welking: I'm following our textbook and doing exercises similarly to the examples, but sometimes I get stuck :D 
18:55:23 <roboguy`> RyanGlScott: I still need to get rid of those tabs in Lava. How's it going Ryan? It's David from Dr. Gill's lab
19:07:18 <tommd> Tell Andy hello from Portland!
19:07:31 <benzrf> i'm in portland
19:07:33 <benzrf> ...maine
19:07:44 <tommd> Oh no, wait.  That hasn't been special since the telegraph became a thing.
19:08:05 <tommd> benzrf: I'm in the bigger little sibling city of Portland, ME.
19:08:20 <benzrf> i assumed so, hence the joke
19:08:26 <cschneid_> I have a weird hang in some copy/pasted code, stolen from the Quicklift app that went around recently.  https://gist.github.com/cschneid/634e39c4bf00f74fd0bc -- When it runs, I see the print of Auth, and an sql statement in the logs, but then it never returns.  Does the runMaybeT block hide the liftIOs until the end? 
19:09:13 <cschneid_> the code starts executing, but servant just never returns a response
19:09:29 <ThatTreeOverTher> I'm just starting out with Haskell.. can anyone give me any tips for comprehending code? (I've done some JS/Lua/C stuff, which just makes the issue worse I think)
19:09:58 <EvanR> write a lot of your own code first
19:10:25 <EvanR> check the style guide for how to format it
19:10:49 <roboguy`> tommd: can do! I should see him either tomorrow or the next day
19:11:21 <kenV> how do I get the underlying Vector from an aeson Array of type Value ?
19:11:36 <EvanR> you can pattern match to deconstruct the value
19:12:39 <dmj> ThatTreeOverTher: sure
19:12:46 <tommd> benzrf: Yeah, I just figured I should clarify incase you were hoping we could talk Haskell over a beer.
19:12:46 <ThatTreeOverTher> EvanR, that makes sense. Although I'm not quite sure what to write. I tried playing with Warp and managed to get a "hello world" on port 3000... what else can I do?
19:13:09 <benzrf> tommd: im not drinking age yet, sorry
19:13:22 <ThatTreeOverTher> (also I use some auto-indenting vim thing to stylize my code so at least I don't currently have to worry about it, I'll learn that after I stop getting syntax errors)
19:13:23 <dmj> cschneid_: what is the body of getUser
19:13:24 <EvanR> ThatTreeOverTher: well, as interesting among all alternatives as web programming is, i would suggest something else
19:13:54 <EvanR> ThatTreeOverTher: well learning how indentation matters is important to write the code and understanding other peoples code
19:14:00 <exio4> benzrf: you can still drink! pepsi or coca cola though :p 
19:14:11 <EvanR> autoindent cant always tell what youre trying to do
19:14:40 <benzrf> exio4: not a cola fan
19:14:42 <benzrf> i prefer root beer
19:14:55 <cschneid_> @dmj I updated the gist with getUser. Calls several more Web.User.Types lines. 
19:14:55 <lambdabot> <unknown>.hs: 1: 75:Parse error in expression: I updated the gist with getUser .
19:14:55 <lambdabot>   Calls several more Web.User.Types lines .
19:15:02 <EvanR> kenV: let (Array v) = myJson in ... v ...
19:15:32 <EvanR> kenV: apparently its not a Vector, its an Array
19:15:47 <ThatTreeOverTher> EvanR, that's true. I'll take that out for now, until I've learned how to do it myself. Is there a particular kind of project that best espouses the values of Haskell?
19:16:04 <EvanR> urg yeah its a Vector... typedefed to "Array" >_<
19:16:36 <EvanR> ThatTreeOverTher: its a general purpose language, so you come up with what you want to do and try it in haskell
19:16:48 <coconut> How to stack repl with the Main module loaded ? the default only loads the libraries
19:16:49 <cschneid_> @dmj this is exactly the code borrowed from https://github.com/parsonsmatt/QuickLift/blob/master/src/Api.hs#L89-L97 -- which makes me thing that I've done something weird in my copy/pastes
19:16:49 <lambdabot> : -1: -1:Ambiguous infix expression
19:17:21 <EvanR> ThatTreeOverTher: if you want to get sucked into the math and CS of it all, then youd want to try to write a programming language implementation... theres "write yourself a scheme in 24 hours"
19:17:25 <EvanR> for instance
19:18:03 <ThatTreeOverTher> Huh. That sounds pretty nifty. I'll try that.
19:21:45 <coconut> can WinGhci be used inside a stack sandbox ?
19:22:02 <coconut> and find all those packages installed?
19:22:43 <geekosaur> stack exec WinGhci
19:22:44 <geekosaur> ?
19:22:59 <RyanGlScott> Do you even need to do that? Wouldn't stack ghci be sufficient?
19:23:17 <coconut> the terminal in windows really sucks
19:23:24 <RyanGlScott> No kidding :)
19:23:25 <coconut> the bash terminal
19:23:28 <geekosaur> I don't think WinGhci replaces the normal ghci
19:23:35 <EvanR> well you can putty
19:23:39 <EvanR> to localhost
19:23:41 <coconut> i use the bash terminal from git
19:23:43 <RyanGlScott> It's slightly better if you use it in cmd.exe/PowerShell as opposed to MSYS/Cygwin
19:23:53 <coconut> with unix environment already set up
19:24:08 <RyanGlScott> Because then you have command history/tab-completion/the ability to Ctrl+C without crashing your shell
19:24:45 <coconut> but how does powershell or cmd find the unix tools ?
19:24:56 <coconut> add path ?
19:25:44 <RyanGlScott> Well, I would hope that as long as stack is on your path, it could figure out the rest
19:26:12 <coconut> ok thanks
19:26:16 <RyanGlScott> But if you're invoking ghci directly, then yes, you do need to add %GHC_HOME%/bin and %GHC_HOME%/mingw/bin to your %PATH%
19:27:04 <EvanR> uh, cmd.exe is better than something? o_O
19:27:22 <RyanGlScott> EvanR: The word "better" is a very nuanced one...
19:27:39 <RyanGlScott> But in terms of using GHCi on Windows, yes. Using it on mintty will result in a bad time.
19:27:53 <EvanR> to use the one program ghci... i still am skeptical
19:28:00 <coconut> cant find where stack is installed on windows ...
19:28:02 <coconut> silly me
19:28:13 <EvanR> ah mintty
19:28:23 <RyanGlScott> *mintty on Windows, I should clarify
19:28:31 <coconut> mintty is really weird
19:28:36 <RyanGlScott> I'm sure it's just fine on other OSes
19:29:20 <RyanGlScott> OTOH, if you want to use Unicode characters in Haskell
19:29:30 <RyanGlScott> I've found that MSYS works way better than cmd.exe
19:29:39 <RyanGlScott> So you can't win ;)
19:29:50 <RyanGlScott> (Pun intended)
19:30:12 <geekosaur> coconut: where stack
19:30:22 <EvanR> putty
19:30:24 <coconut> geekosaur, i got
19:30:25 <coconut> it
19:30:26 <geekosaur> (this at least works on win10, I think it's back through win8 at least)
19:30:28 <coconut> thanks
19:31:33 <monochrom> nice, windows cmd.exe has where too
19:32:31 <geekosaur> yes, cmd is where I tested that
19:33:12 <geekosaur> (I don't do unix simulations on windows. should probably learn some powershell someday, but cmd has quite a lot of useful stuff in it these days)
19:43:06 <EyeJoy> how to works on primitive?   aFunc :: Int# -> Int#;    aFunc a = a +# 1#  ;  aFunc 1#   <-- not working
19:43:34 <RyanGlScott> EyeJoy; Can you be more specific than "not working"? What's the error message?
19:43:59 <EyeJoy> Couldn't match kind ‘*’ with ‘#’
19:44:29 <RyanGlScott> EyeJoy: Chances are, you're using aFunc in a place that can't accept unlifted types
19:45:00 <RyanGlScott> They have their own kind # to distinguish them from lifted types (kind *)
19:45:37 <RyanGlScott> e.g., if you type only aFunc #1 into GHCi, it won't work
19:45:45 <RyanGlScott> er, aFunc 1#
19:46:04 <EyeJoy> yes I try it at winGHCi
19:46:11 <RyanGlScott> You could do I# (aFunc 1#) to get it to show something in GHCi, though
19:46:20 <EvanR> you cant even type 1# in ghci
19:46:32 <RyanGlScott> (Not without -XMagicHash, anyway)
19:46:51 <EvanR> even without
19:46:51 <EyeJoy> with -XMagicHash option and imported GHC.Prim
19:46:52 <nitrix> What's the idiomatic solution if you're working with multiple states?
19:46:54 <EvanR> er with
19:46:56 <nitrix> State and a record?
19:47:07 <nitrix> lenses maybe?
19:47:19 <EvanR> its expecting apparently kind * in ghci
19:47:39 <RyanGlScott> Works for me (you have to import Int(I#) from GHC.Exts)
19:47:53 <RyanGlScott> I# 1# == 1
19:47:59 <EvanR> ah I#
19:49:31 <EvanR> is I# the constructor of Ints?
19:49:54 <RyanGlScott> Yep: http://haddock.stackage.org/lts-4.2/base-4.8.2.0/GHC-Exts.html#v:I-35-
19:50:32 <EyeJoy> ic, ty RyanG1Scott and EvanR
19:51:02 <EvanR> I# is the box
19:53:15 <nitrix> Wait what.
19:53:23 <nitrix> How can #Int have instances?
19:53:25 <EvanR> do boxed floats ever experience the 80-bit intermediate precision ?
19:53:35 <nitrix> Int# *
19:53:40 <roboguy`> nitrix: it can't
19:53:51 <nitrix> Stackage lists them.
19:53:53 <roboguy`> I'm pretty sure,
19:54:04 <roboguy`> nitrix: for Int#?
19:54:18 <nitrix> For Int, but how does it finds any relation between the two?
19:54:46 <EvanR> Int is a boxed type
19:54:58 <EvanR> the instance is implemented in terms of primitives
19:55:18 <nitrix> Isn't everything a BOX anyway in Haskell?
19:55:29 <nitrix> I thought that was the only sort available.
19:55:33 <roboguy`> nitrix: BOX is a different concept
19:55:39 <EvanR> BOX seems unrelated to boxing
19:55:43 <Cale> all kinds are of sort BOX
19:55:53 <nitrix> Oh. So they aren't related?
19:55:59 <Cale> but it's only named BOX because the paper used a white square to name it
19:56:04 <RyanGlScott> (Up until GHC 7.10, anyway...)
19:56:04 <roboguy`> nitrix: nope. unboxed stuff like Int# is literally a raw word size integer
19:56:31 <nitrix> I see. What's the benefit of having a constructor?
19:56:32 <EvanR> Int# has kind #
19:56:38 <nitrix> Convert from Haskell to primitive?
19:56:55 <nitrix> Or the opposite maybe?
19:57:13 <roboguy`> nitrix: you can't have an unevaluated Int#
19:57:15 <Cale> The constructor at the Haskell level represents an actual data structure in memory
19:57:23 <EyeJoy> when you want work on stack, boxed type is work on heap
19:57:30 <roboguy`> without a box around it
19:57:37 <Cale> I assume you're talking about the I# data constructor
19:57:45 * hackagebot diagrams-gtk 1.3.0.1 - Backend for rendering diagrams directly to GTK windows  https://hackage.haskell.org/package/diagrams-gtk-1.3.0.1 (BrentYorgey)
19:58:03 <Cale> It's very much like all other data constructors, except it happens to have an unboxed int sitting in one of its fields
19:58:07 <nitrix> Cale: I think things are starting to connect. I# is the constructor for Int. It takes an Int#.
19:58:28 <nitrix> :t (+#)
19:58:29 <lambdabot>     Not in scope: ‘+#’
19:58:29 <lambdabot>     Perhaps you meant one of these:
19:58:29 <lambdabot>       ‘++’ (imported from Data.List), ‘+’ (imported from Prelude),
19:59:21 <nitrix> GHC.Prim I see.
19:59:37 <nitrix> So that's basically a giant wrapper over C :P
20:00:07 <EvanR> no!
20:00:36 <nitrix> Or LLVM I should say, since -fvia=C isn't a thing anymore.
20:01:01 <EvanR> ghc is using llvm now?
20:01:14 <EvanR> i thought it generated its own code
20:01:46 <RyanGlScott> It has an LLVM backend, anyway (-fllvm)
20:01:58 <nitrix> Maybe I'm misinformed.
20:02:08 <roboguy`> EvanR: it can do both
20:02:22 <RyanGlScott> But the default backend is -fasm (Cmm to native code)
20:04:48 <EvanR> so yeah ghc prims are as much of a wrapper around something as C is
20:05:42 <cschneid_> has anybody used Web.Users.Types here?  It's hanging inside the library. 
20:05:58 <nitrix> I guess my point is that traces the boundary between the Haskell language and actual target translation for the compiler?
20:17:39 <roboguy`> nitrix: that sounds accurate
20:19:58 <lethjakman-l> Hey, I'm having issues understanding an error: https://gist.github.com/lethjakman/255668b099b59af2ce2b
20:20:17 <lethjakman-l> It's having issues deducing (RenderMessage Auth FormMessage)"
20:20:36 <lethjakman-l> Is it because I need to write some other function for the type class maybe?
20:22:56 <exio4> nitrix: having Int# ; +# ; etc defined within the language makes it "easier" to do quite a lot of optimizations
20:23:26 <exio4> nitrix: (not actually 'within', I think "available from" fits better, actually :P)
20:27:10 <lethjakman-l> Maybe someone knows what it's called when a monad implicitely passes variables through?
20:28:02 <EvanR> Reader ?
20:28:11 <lethjakman-l> Is that just because it's a function? 
20:28:21 <lethjakman-l> So in the end it all gets passed. 
20:28:47 <lethjakman-l> Reader might be right....
20:28:47 <EvanR> what are you asking?
20:28:55 <lethjakman-l> Ummm
20:29:02 <lethjakman-l> So it's a bit complicated. 
20:29:14 <EvanR> Reader is a pretty simple (and useful) monad
20:29:26 <lethjakman-l> If you look at that gist I posted I'm having an issue with "Could not deduce (RenderMessage Auth FormMessage)"
20:29:30 <haskell387> I'm trying to parse a csv-like file (http://lpaste.net/150820). it's very repetitive -- how might i improve this?
20:29:34 <lethjakman-l> And I think it's coming from here: https://hackage.haskell.org/package/yesod-form-1.4.6/docs/Yesod-Form-Functions.html
20:29:47 <lethjakman-l> mreq has a type signature with "(RenderMessage site FormMessage, HandlerSite m ~ site, MonadHandler m)"
20:30:23 <geekosaur> @unmtl ReaderT r (StateT s IO) a
20:30:23 <lambdabot> r -> s -> IO (a, s)
20:30:36 <lethjakman-l> And I guess I just don't understand what it means by deducing. I think it's getting the RenderMessage stuff from the first part of that type signature though. 
20:31:06 <EvanR> lethjakman-l: this error happens when you use type class-generic functions on something and it cant figure how whether the thing in question has the proper instance
20:31:21 <lethjakman-l> Hmmmm. 
20:31:42 <Guest00000> hm, lambdabot can't @mtl back?
20:31:43 <EvanR> and your lib is using some complex classes, and i havent used it
20:31:58 <Guest00000> would that be difficult to implement..
20:32:09 <lethjakman-l> Ok, I'm glad it's not just me then. 
20:32:34 <lethjakman-l> Do you think I just need to declare a type class? 
20:33:00 <EvanR> no
20:33:19 <geekosaur> I haven't used that either, but I suspect that you used auth credentials where a site was expected
20:33:20 <EvanR> lethjakman-l: so what is mreq's type 
20:34:16 <lethjakman-l> EvanR: It's that complicated type in that link: :: (RenderMessage site FormMessage, HandlerSite m ~ site, MonadHandler m) => Field m a -> FieldSettings site -> Maybe a -> MForm m (FormResult a, FieldView site)
20:34:38 <EvanR> o
20:34:44 <EvanR> ok
20:35:08 <lethjakman-l> Thank you for looking at this. I'm a bit lost...
20:35:37 <EvanR> lethjakman-l: well you pass in "", in the position of a FieldSettings site
20:36:36 <lethjakman-l> Yeah...I'm a bit confused as well, because example usage looks like this:
20:36:38 <lethjakman-l>     (nameRes, nameView) <- mreq textField "this is not used" Nothing
20:37:46 * hackagebot extensible-effects 1.11.0.3 - An Alternative to Monad Transformers  https://hackage.haskell.org/package/extensible-effects-1.11.0.3 (shergill)
20:38:08 <EvanR> that is silly :(
20:38:22 <EvanR> but ok. the settings are supposed to be specified in a string
20:38:32 <EvanR> a string constant, that is
20:39:10 <EvanR> FieldSettings a might be an IsString, which lets you use string literals
20:39:19 <lethjakman-l> I think it's normally the label (It builds an html input field)
20:39:29 <EvanR> what is the type of textField
20:40:16 <lethjakman-l> textField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text
20:41:03 <EvanR> ok that doesnt seem to match the type of first param... Field m a?
20:41:11 <EvanR> at first glance anyway
20:41:31 <EvanR> if your usage is disagreeing with examples, it might be because of version differences
20:41:42 <EvanR> oh two =>
20:41:49 <EvanR> wtf
20:42:20 <lethjakman-l> Yeah...
20:42:24 <lethjakman-l> I saw that too. 
20:43:55 <EvanR> anyway then it at least makes that much sense. so then its trying to find a multi-parameter typeclass instance for m
20:44:11 <EvanR> RenderMessage (HandlerSite m) FormMessage
20:45:25 <lethjakman-l> Oh, so I'm missing a typeclass?
20:45:31 <EvanR> do you know what m is, and HandlerSite m ?
20:45:40 <lethjakman-l> I'm trying to do this in an instance of YesodAuthEmail instead of...App 
20:45:44 <lethjakman-l> I think that's what it normally is...
20:45:51 <lethjakman-l> It's normally in Handler functions that get passed to the router. 
20:46:00 <lethjakman-l> Ummm. 
20:46:22 <EvanR> Could not deduce (RenderMessage Auth FormMessage)
20:46:54 <lethjakman-l> I THINK it's Auth. I could very well be wrong though
20:47:04 <geekosaur> btw that double => syntax has been around for a while and x => y => z i the same as (x, y) => z
20:47:10 <EvanR> ok
20:47:28 <geekosaur> apparently it's easier to support that than not, and considered useful
20:47:41 <lethjakman-l> I did not know that. 
20:47:46 <lethjakman-l> Personally I think the , is clearer. 
20:47:50 <glguy> the one case to remember is that it's not the same when you're doing pattern synonyms
20:47:53 <lethjakman-l> Is that what most people think?
20:48:03 <lethjakman-l> Good to know. 
20:48:09 <geekosaur> I think most people don't realize it works >.>
20:48:18 <lethjakman-l> Ahh. 
20:48:23 <lethjakman-l> Well, thank you for the tip!
20:48:24 <geekosaur> (and yes, this came up when pattern synonyms were being worked on)
20:48:49 <EvanR> so multiple => makes some sense in the case of pattern synonyms?
20:49:01 <EvanR> otherwise i cant see the sense
20:49:13 <geekosaur> in that specific case, one set applies to the synonym itself and the other to the resulting context, IIRC
20:49:47 <julianleviston> I’m all excited… because of this: http://www.happylearnhaskelltutorial.com
20:49:54 <geekosaur> that is, a pattern synonym can require its own constraints, and can contribute other constraints
20:50:09 <julianleviston> I need peoples to give me destructor criticism
20:53:14 <lethjakman-l> What does the ~ mean?
20:53:21 <lethjakman-l> ":: (RenderMessage site FormMessage, HandlerSite m ~ site, MonadHandler m)"
20:54:43 <Axman6> it's type equality, in this case it's just being used to give a name to HandlerSite m
20:54:59 <Axman6> everywhere you see 'site' you can replace it with HanderSite m
20:55:12 <lethjakman-l> Ahhh. 
20:56:02 <gfixler> what are ADTs that feature sum and product elements called?
20:56:20 <gfixler> data Foo = Bar String Int | Baz | Quux Bool
20:56:24 <gfixler> Sum Product Type?
20:59:02 <Guest00000> julianleviston: are you author of that?
20:59:16 <julianleviston> Guest00000: pretty much
20:59:20 <Guest00000> okay
21:00:16 <julianleviston> gfixler: why can’t you just call them algebraic types? 
21:00:34 <julianleviston> gfixler: really sum types are just ADTs that only use sum, and same for product, right?
21:00:35 <gfixler> julianleviston: I can and do, just wondering if they had a name when they weren't exclusively one or the other
21:00:43 <gfixler> julianleviston: that's my understanding
21:00:54 <EvanR> so ADTs
21:01:00 <Guest00000> in section 3... i think, maybe, it might be too early to break down IO ()
21:01:01 <julianleviston> yeah.
21:01:01 <gfixler> julianleviston: if I spend much time on this site, the world is going to look green :)
21:01:06 <julianleviston> they’re all ADTs.
21:01:15 <julianleviston> Guest00000: reasons?
21:01:31 <julianleviston> Guest00000: I should have asked this in haskell-blah actually… talk to me about it in there.
21:01:58 <julianleviston> gfixler: LOL!
21:15:59 <cschneid> I have a hang inside of Web.Users.Types library - how do I figure out what is hanging? https://gist.github.com/cschneid/634e39c4bf00f74fd0bc I can manually call verifyPassword on my hashed password, so I know bcrypt lib is setup right
21:16:14 <cschneid> beyond that, I'm sorta baffled at a hang like this. No error, no response, just.. hangs
21:17:47 * hackagebot Cabal 1.18.1.7 - A framework for packaging Haskell software  https://hackage.haskell.org/package/Cabal-1.18.1.7 (ryant)
21:18:00 <cschneid> this is the source for authUser - https://github.com/agrafix/users/blob/master/users-persistent/src/Web/Users/Persistent.hs#L169-L171
21:32:33 <cschneid> hah, I ended up looking at closed issues, which got me https://github.com/agrafix/users/issues/5 - which was my exact problem, fixed. Just not released on hackage or stackage.  So git clone & vendor - fixed my issue
22:17:49 * hackagebot cassava-conduit 0.2.2 - Conduit interface for cassava package  https://hackage.haskell.org/package/cassava-conduit-0.2.2 (domdere)
22:32:50 * hackagebot binary-orphans 0.1.4.0 - Orphan instances for binary  https://hackage.haskell.org/package/binary-orphans-0.1.4.0 (phadej)
22:34:49 <jle`> gfixler: i guess they *are* sum-of-products, but that necessarily mean that that's a "name"
22:39:18 <EvanR> i.e. is there a name for the thing named `name`
22:42:11 <julianleviston> EvanR: no
22:42:21 <julianleviston> EvanR: oh wait.. yes
22:42:24 <EvanR> lol
22:42:24 <julianleviston> EvanR:  “word".
22:42:38 <EvanR> no "name"
22:42:41 <julianleviston> or do you mean the specific word name?
22:43:00 <EvanR> literally the name name ;)
22:43:13 <julianleviston> EvanR: ah… you want a name for its own content?
22:43:19 <EvanR> probably a bad placeholder name
22:43:23 <julianleviston> EvanR: that question appears syntactically broken.
22:43:25 <EvanR> no
22:43:32 <julianleviston> EvanR: semantically* sorry.
22:43:45 <EvanR> trivial maybe
22:43:55 <julianleviston> EvanR: I don’t think so
22:44:05 <EvanR> i was referring to question if ADTs have a name
22:44:17 <ibid> if I understand the question correctly, the correct term is "algebraic data type" and that *is* the name for sum-of-products data types in haskell (named so because there's a really simple connection to the algebras of universal algebra)
22:44:19 <julianleviston> The only name that a thing can have if it’s its own content is itself.
22:44:27 <EvanR> o_O
22:44:36 <julianleviston> ibid:  yeah, I think we arrived at that conclusion a while back actually.
22:44:39 <EvanR> ibid: yes
22:44:56 <EvanR> julianleviston: i expanded the question to include all questions of the form
22:44:58 <julianleviston> ibid: “sum type” and “product type” are subsets of “algebraic data type”
22:44:59 <EvanR> as a generalizaion
22:45:04 <ibid> julianleviston: yes
22:45:20 <ibid> julianleviston: seemed to be still open, reading the backlog
22:45:24 <julianleviston> EvanR: for all names such that name = “name”, then “name” = “name” ?
22:45:27 <julianleviston> ibid:  apologies!
22:45:28 <ibid> julianleviston: i guess i read it badly
22:45:38 <julianleviston> ibid: no, I think I wrote it badly! :)
22:45:40 <EvanR> julianleviston: no, then name = "name"
22:45:54 <julianleviston> EvanR: well both
22:45:56 <ibid> julianleviston: (hence the qualifier "if i understand the question correctly":)
22:46:05 <EvanR> lol
22:46:27 <julianleviston> ibid: identity isn’t equivalence… so you might need to determine what “=“ means here too :)
22:46:34 <EvanR> julianleviston: yeah ones proof is const, the other is id
22:46:41 <julianleviston> oops… not that was for evan
22:47:19 <EvanR> determine what = means, youve been reading too much HoTT
22:47:25 <ibid> actually, it took me about ten years of writing haskell and reading maths to get why algebraic data types are called that
22:47:43 <ibid> I refuse to call them ADTs because that acronym has a well established different meaning :)
22:47:53 <EvanR> yeah its a huge collision
22:48:00 <shachaf> Ambiguous Data Types
22:48:29 <ibid> that actually mislead me a bit in  reading the backlog :)
22:48:31 <zhkirill> Does anyone has experience with machine learning using Haskell?
22:48:44 <ibid> i was wondering what abstract data types have to do with the issue ::)
22:49:20 <ibid> zhkirill: a colleague of mine may have, depending on what sort you meam
22:49:43 <zhkirill> I am just curious how is it comparing to Python or R.
22:49:54 <ibid> zhkirill: different :)
22:49:56 <gfixler> jle`: good to know, thanks!
22:50:14 <zhkirill> ibid well, of course it's different :)
22:51:00 <srhb> ibid: What is that other well-established different meaning?
22:51:10 <gfixler> julianleviston: you're touching on a thought I had about git re: names for things
22:51:39 <EvanR> names vs addresses, go
22:51:42 <julianleviston> gfixler: ah?
22:51:45 <julianleviston> LOL
22:51:48 <julianleviston> names are SO hard. :)
22:51:51 <gfixler> we don't actually have to have names for files
22:51:52 <julianleviston> But they’re also SO easy 
22:51:58 <gfixler> we could just stored delimited contents
22:52:01 <gfixler> that's how we do it in the real world
22:52:04 <ibid> srhb: abstract data types is the only well-established meaning i know
22:52:06 <gfixler> I don't look up the name of the phone bill
22:52:13 <julianleviston> gfixler: yeah, everything is literal?
22:52:14 <gfixler> I just leaf through the stack of mail until I recognize it by its contents
22:52:19 <julianleviston> gfixler: then syntax becomes important :)
22:52:30 <srhb> ibid: Oh, I misunderstood you then.
22:52:34 <julianleviston> gfixler: yeah I’ve seen things that do that before.
22:52:34 <gfixler> things just become slower
22:52:34 <EvanR> i search the index for the month of the bill
22:52:52 <EvanR> and filter by the type of bill
22:52:54 <ibid> srhb: my point was calling algebraic DT ADT is misleading :)
22:52:58 <gfixler> sure, you can key off of parts of the contents, like the date in the top corner
22:52:58 <ThatTreeOverTher> I remember when someone tried to make a database-based-filesystem
22:53:02 <gfixler> but that's just some of the contents themselves
22:53:07 <gfixler> not the name or any particular identifier
22:53:09 <ThatTreeOverTher> It was called WinFS and it delayed Windows Vista by a year
22:53:10 <julianleviston> ibid: because of algebraic / abstract?
22:53:20 <srhb> ibid: Oh.
22:53:38 <gfixler> git doesn't need hashes - the names of everything can just be the actual contents
22:53:42 <gfixler> no conflicts possible
22:53:43 <srhb> ibid: I misread your first abstract as algebraic because that's the only established meaning I know :P
22:54:02 <EvanR> gfixler: well, the bill is a view of a bunch of relational data, and the indexes can be generated from that data as well
22:54:16 <gfixler> EvanR: true - you can always regex search contents and whatever else
22:54:16 <EvanR> so bills are kind of the surface of the data iceberg
22:54:20 <ibid> julianleviston: exactly
22:54:21 <gfixler> I do that with grep
22:54:23 <gfixler> and find
22:54:26 <gfixler> and etc
22:54:49 <EvanR> gfixler: i mean theres more structure there, in the case of bills real, in the case of source code imaginary (until parsing)
22:54:53 <gfixler> EvanR: do you mean a bill is just a view on part of the info surrounding your account?
22:55:03 <EvanR> its a repor
22:55:09 <EvanR> report
22:55:11 <gfixler> ah, but I just mean the bill itself
22:55:13 <gfixler> the paper
22:55:19 <gfixler> it's a 'file' in my house
22:55:24 <gfixler> and I find it by scanning its contents
22:55:34 <EvanR> just the paper? not the ink?
22:55:36 <gfixler> just as artists often find images by looking through thumbnails on their computers
22:55:46 <gfixler> EvanR: you know what I mean (I think) :)
22:55:55 <EvanR> no ive been on IRC too long
22:55:59 <gfixler> I've used images of docs to find the docs
22:56:04 <gfixler> especially when I had a mac in college
22:56:08 <gfixler> big thumbnail with text on it
22:56:08 <julianleviston> haha OS/X has that built in.
22:56:18 <gfixler> and I could pick out the document by site, and where I left it on my desktop
22:56:21 <gfixler> sight*
22:56:31 <gfixler> by sight, and by site :)
22:56:55 <EvanR> talking about the location of the paper bill
22:56:58 <gfixler> of course, refering an object in git would be a pain
22:57:00 <EvanR> now thats an address!
22:57:05 <gfixler> referencing*
22:57:55 <gfixler> git cherry-pick "Final Report - Spending\n2015 Q4\n\n..."
22:58:21 <EvanR> reports should be regeneratable from the original data :(
22:58:30 <gfixler> you'd have to type a lot in before it became unambiguous, because of minor changes to the document over time
22:58:38 <EvanR> instead of managed like word docs
22:58:57 <ThatTreeOverTher> eventually you'd consider using a relational database for something like this
22:58:57 <gfixler> that doesn't sound very businessy
22:59:07 <gfixler> or hashes
22:59:23 <EvanR> "just hash it" :(
22:59:48 <ThatTreeOverTher> I mean, grepping across every file to find the string "Profit" and awking out the value might work
23:00:11 <EvanR> thats an inside-out database
23:00:41 <ThatTreeOverTher> at that point why not actually just use a database, asking it for the value of the column "Profit"
23:01:10 <EvanR> where the report with profit column is a view of something, perhaps materialized!
23:01:38 <ThatTreeOverTher> oh heck yeah, the report could just be a view of the data, with timestamps as arguments
23:02:33 <ThatTreeOverTher> I think there was an application that tried that, FileMaker
23:02:52 <EvanR> FileMakerPro, best cracktro music
23:02:56 <ThatTreeOverTher> you'd set up record sheets and put your data into them, and then you'd build your own views of those record sheets
23:03:20 <ThatTreeOverTher> searching was so easy, 8th grade me could do it (our school was big on FileMaker)
23:03:54 <ThatTreeOverTher> haha I always just used some portable copy that abstracted away the whole crack thin
23:05:53 <ThatTreeOverTher> oh by the way EvanR I tried the tutorial you were talking about, and I got pretty far into it, but I stopped at the exercise parsing a string using >>=
23:06:36 <jarandaf> hi fellas, we are going to create the first haskell users group in barcelona (spain), if you know of someone who might be interested in collaborating please PM me
23:06:43 <ThatTreeOverTher> I don't get the whole bind/monadic thing, thankfully I found the RealWorldHaskell book and that's ending up pretty helpful
23:10:22 <EvanR> ThatTreeOverTher: yeah the parsing phase is kind of the boring part now
23:10:29 <EvanR> because of monads ;)
23:11:19 <EvanR> ThatTreeOverTher: http://www.willamette.edu/~fruehr/haskell/seuss.html
23:12:46 <ThatTreeOverTher> That makes sense! But then what do monads have to do with anythign
23:12:51 <julianleviston> Oh…. that’s in a wadler book
23:12:53 <EvanR> right
23:13:27 <ThatTreeOverTher> right what? Was that the conclusion I was supposed to find? :)
23:13:58 <EvanR> ThatTreeOverTher: the Parser a type can be equipped with a monad instance so you can sequence multiple Parsers to one object from the text, then objects from the rest of the text, and combine them into a third object
23:13:58 <julianleviston> ThatTreeOverTher: monads are just useful for composing things that take go a -> Blah a when you have a lot of Blah a's.
23:14:28 <julianleviston> ThatTreeOverTher: AFAICS, monads are way over-worried-about.
23:14:35 <EvanR> ThatTreeOverTher: also it lets you extract objects recursively, and backtrack.
23:14:53 <EvanR> you kind of have to work through itself yourself and see example in do-notation to see it
23:14:58 <EvanR> through it*
23:15:05 <julianleviston> the parser type happens to fit that pattern, so you can use a monad instance on them
23:15:23 <gfixler> I wrote about monads in a comment on reddit yesterday
23:15:25 <gfixler> https://www.reddit.com/r/haskell/comments/42bt6c/help_with_reader_monad/cza1qx2
23:15:27 <julianleviston> I think one of the best examples I ever saw was chaining a bunch of Maybe values together to get a single result.
23:15:34 <gfixler> I'll accept any criticisms anyone wants to lob at me
23:15:37 <gfixler> for the learning
23:16:04 <ThatTreeOverTher> julianleviston, oh, I understand Maybe monads (to a degree?) so how did that work exactly?
23:16:51 <julianleviston> ThatTreeOverTher:  well… if you have a Just “hey”, and you want to do something to the “hey” part, and return another Just, unless that thing didn’t work in which case you want to return a Nothing… you can easily do that right?
23:17:41 <julianleviston> Like for example you can imagine a function String -> Maybe String that will return Nothing if the string starts with “james”, but Just the string otherwise.
23:17:57 <ThatTreeOverTher> sure, yeah
23:18:10 <julianleviston> and you can imagine a bunch of functions that do similar things with different conditions
23:18:16 <julianleviston> now… try to join them together
23:18:23 <ThatTreeOverTher> so how does that look syntactically with >>= ?
23:18:25 <julianleviston> like… do those bunch of functions…
23:18:38 <julianleviston> that “join them together” *IS* >>=
23:18:43 <julianleviston> :t (>>=)
23:18:45 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:18:53 <julianleviston> pretend m is Maybe, and a is String
23:18:58 <EvanR> ThatTreeOverTher: see if this code makes sense
23:19:03 <EvanR> ThatTreeOverTher: http://lpaste.net/150821
23:19:38 <EvanR> of course, that would be more concise with Applicative, but... worry about that later
23:19:49 <ThatTreeOverTher> ...yeah, you lost me EvanR haha
23:19:55 <ThatTreeOverTher> I think julianleviston was onto something?
23:20:17 <EvanR> hes talking about Maybe which is a different kind of behavior
23:20:23 <julianleviston> ThatTreeOverTher: >>= just binds functions like String -> Maybe String together with values of Maybe String.
23:20:44 <julianleviston> ThatTreeOverTher: general Maybe to Monad, and String to a, and you have (>>=)
23:20:49 <julianleviston> generalize*
23:21:00 <ThatTreeOverTher> okay that makes some sense
23:21:11 <julianleviston> ThatTreeOverTher: parsers are *like* that but work differently
23:21:21 <ThatTreeOverTher> but EvanR you're saying Parser works with a - yeah, differently. how so?
23:21:36 <julianleviston> do you know the list monad?
23:21:56 <EvanR> hold on lets do parsers
23:22:05 <julianleviston> well list is the same isn’t it? pretty much
23:22:09 <EvanR> no
23:22:21 <julianleviston> hm
23:22:32 <julianleviston> why because [] or [x] ?
23:22:52 <julianleviston> EvanR: because it’s only using the response as a singleton or empy? because of the convention?
23:22:57 <EvanR> list monad is about [], where as the Parser type is a function
23:22:58 <julianleviston> empty*
23:23:22 <EvanR> which returns a list (of tuples)
23:23:23 <ThatTreeOverTher> wait but I thought Parser was a Monad
23:23:26 <EvanR> so
23:23:27 <ThatTreeOverTher> but it's a function?
23:23:35 <EvanR> look at dr seuss
23:23:37 <julianleviston> ThatTreeOverTher: yeah, but the function is the monad. It’s all good Let him explain
23:23:53 <EvanR> String -> [(a, String)]
23:23:55 <julianleviston> EvanR: apologies. of course that’s right.
23:23:56 <EvanR> not [a]
23:24:38 <ThatTreeOverTher> so a Parser a looks for objects of type a in a string, and returns them in that type signature?
23:25:35 <EvanR> ThatTreeOverTher: i was just going to explain how the paste code is to be comprehended... imagine you have text stream youre trying to parse, and you do this by taking prefixes and trying to parse them into values with a more primitive parser (like the integer parser)
23:25:58 <EvanR> ThatTreeOverTher: it could either work, and youre left with the value and the rest of the stream, or it could fail and you have to either bail out or backtrack
23:26:16 <ThatTreeOverTher> wait if it fails it doesn't crash
23:26:31 <EvanR> it might be able to try another previous branch of the parsing
23:26:39 <EvanR> for example if the next token could be one of two things
23:26:46 <EvanR> try one parser, if it fails, try another
23:27:14 <EvanR> that could be a valid strategy at some point in the language
23:28:05 <ThatTreeOverTher> okay, that makes sense
23:28:19 <EvanR> ThatTreeOverTher: so in the paste, think about each statement as trying to read a value by parsing some prefix of the current input stream
23:28:47 <EvanR> char '(' :: Parser (), means try to read a (, if it succeeds return () 
23:28:58 <ThatTreeOverTher> what happens if it fails
23:29:06 <EvanR> that will be a parse failure
23:29:22 <EvanR> in parsec it will say "expecting ("
23:29:27 <ThatTreeOverTher> oh, is that how <|> works?
23:29:46 <gfixler> :t (<|>)
23:29:47 <lambdabot> Alternative f => f a -> f a -> f a
23:30:00 <EvanR> well if you did char '(' <|> char '[', and neither ( or [ appears next, itll fail and say "expecting ( or ["
23:30:28 <EvanR> if it passes itll return some Char
23:30:38 <EvanR> er no
23:31:04 <EvanR> itll still return (), so if you care which one it is you need to use another combinator
23:31:33 <EvanR> ThatTreeOverTher: char '(' doesn't give you any info, just (), so the next step is more interesting since its a Parser Char
23:31:39 <EvanR> if it passes, you get a Char back
23:31:39 <ThatTreeOverTher> right, char is just for matching
23:32:01 <EvanR> later the Char will be put into the (c,n) as the return value
23:32:11 <EvanR> and in this way you can parse complex data structures incrementally
23:32:30 <ThatTreeOverTher> so where does >>= fit into all of this?
23:32:47 <EvanR> the sequence of statements in do notation is syntactic sugar for >>=
23:33:09 <ThatTreeOverTher> so what would charLitParser become?
23:33:36 <EvanR> it would be char '(' >>= \_ -> charLitParser >>= \c -> ...
23:33:55 <EvanR> _ because its ignoring the () result from char '('
23:34:06 <ThatTreeOverTher> what's this \variable notation
23:34:09 <EvanR> which can also be written char '(' >> charLitParser ==> \c -> ...
23:34:16 <Cale> If p :: Parser a, and f :: a -> Parser b, then (p >>= f) :: Parser b is the parser which parses the beginning of its input with p, and then if it obtains the result v, it then parses the remainder of the input with f v, producing the result of that parser as its own.
23:34:24 <EvanR> (\x -> x + 1) is lambda abstraction
23:34:33 <Cale> > (\x -> x*x) 5
23:34:35 <lambdabot>  25
23:34:46 <Cale> > map (\x -> x*x) [1..10]
23:34:48 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
23:34:59 <ThatTreeOverTher> oh, \variable is the input to a lambda, okay
23:35:17 <EvanR> yeah lambda contains the rest of the statements, and takes the result of the previous action
23:35:21 <Cale> \ is meant to look a bit like λ
23:35:31 <ThatTreeOverTher> ohhhhh
23:35:44 <Cale> (but it's much easier to type)
23:35:47 <EvanR> but >>= can override what happens between the statements, which is where the failure and backtrack occur for parsers
23:36:07 <EvanR> if >>= just passes the result on without doing anything, its the Identity monad
23:37:28 <EvanR> ThatTreeOverTher: in the String -> [(a,String)] type, then a parser that returns empty list is considered to have failed to parse anything
23:37:43 <EvanR> so >>= will not go on
23:37:49 <EvanR> wont use the lambda
23:38:09 <ThatTreeOverTher> what if you parse whitespace and don't return anything in your list?
23:38:09 <EvanR> it cant even if it wanted to, since it has nothing to pass into them
23:38:23 <EvanR> you return () if its no info
23:38:35 <EvanR> [((), restOfStream))]
23:39:00 <Cale> Producing an empty list would mean parse failure
23:39:11 <ThatTreeOverTher> oh, so [] means failure but [((), ... means it was empty but successful
23:39:21 <Cale> yeah
23:39:25 <EvanR> yeah
23:39:31 <EvanR> whiteSpace :: Parser ()
23:41:06 <ThatTreeOverTher> so a function that takes a string and returns Parser Atom can be bound to another Parser Atom
23:41:23 <EvanR> well it doesnt have to be the same type Atom
23:41:34 <EvanR> it can be (), then Char, then (), then Int, then ()
23:41:49 <EvanR> and then you can use the Char and Int for the "final" synthesis
23:43:09 <EvanR> you can also make "higher order parsers" which are functions that turn old parsers into new ones
23:43:59 <EvanR> like, if you want to optionally parse something, or parse a sequence of the same pattern separated by another pattern
23:44:00 <ThatTreeOverTher> so Parser SQLStatement could be sqlStatement = selectStatement <|> insertStatement ...
23:44:13 <ThatTreeOverTher> oh, you're talking about something else?
23:44:21 <EvanR> <|> is an example
23:44:37 <EvanR> it takes two parsers and only succeeds if one of them does
23:44:51 <EvanR> it fails if all fail
23:45:03 <ThatTreeOverTher> what's an example of a parser that can optionally provide more data?
23:45:19 <ThatTreeOverTher> like 0.5 compared to 0.5f, how would you write that
23:45:35 <EvanR> decimal >> optional (char 'f')
23:45:41 <ThatTreeOverTher> :t optional
23:45:43 <lambdabot> Alternative f => f a -> f (Maybe a)
23:45:46 <ThatTreeOverTher> aha
23:46:11 <EvanR> it turns out that these parsers are easier to read and maintain than regex ;) imo
23:46:34 <ThatTreeOverTher> this is really nifty
23:47:11 <ThatTreeOverTher> it's especially neat because it's made of logic and math, so you can actually see all the steps that were taken to express something
23:47:31 <ThatTreeOverTher> and then you can take those expressions and repurpose them always
23:48:11 <ThatTreeOverTher> it's funny, I logged onto this IRC channel and xchat read back a log... from 2014
23:48:22 <EvanR> wb
23:48:57 <ThatTreeOverTher> hahaha nah I came in with no idea how to do anything
23:49:01 <ThatTreeOverTher> but this time I began to understand monads!
23:49:31 <EvanR> right, Maybe and List do something else, but the combining with >>= or do is the same
23:50:07 <EvanR> > Just 3 >> Just 2
23:50:08 <lambdabot>  Just 2
23:50:10 <ThatTreeOverTher> just like with fmap how you can apply a function regardless of the monad's presence
23:50:13 <EvanR> > Nothing >> Just 2
23:50:15 <lambdabot>  Nothing
23:50:54 <ThatTreeOverTher> while I'm here and it's still before 3am, what's with the whole "stack" thing?
23:51:18 <EvanR> I've never used it but apparently it solves cabal hell ;)
23:51:44 <ThatTreeOverTher> maybe on Windows, but installing it on Unix was its own brand of hell :/
23:52:11 <EvanR> installing anything on unix is easy! just configure, make, make install ;)
23:52:36 <ThatTreeOverTher> and when you're too lazy to even do that, ask your package manager nicely ;)
23:52:53 <EvanR> im surprised when package managers work
23:53:07 <ThatTreeOverTher> Arch Linux's pacman is very good imo
23:53:25 <ThatTreeOverTher> never had a problem with it
23:53:30 <EvanR> yeah just use --force
23:53:45 <EvanR> solves anything
23:53:48 <ThatTreeOverTher> oh, I don't usually have to haha
23:54:10 <ThatTreeOverTher> if I've ended up installing something that could be provided by a package, I just manually delete the stuff instead of forcing it through
23:54:38 <ThatTreeOverTher> I try to write PKGBUILDs for any libraries I install that aren't in a repo so I can uninstall/upgrade them comfortably
23:54:53 <ThatTreeOverTher> usually it's just boilerplate with one or two changes anyway
23:55:17 <EvanR> the bureaucrats dream ;)
23:55:57 <EvanR> its easy just fill out form PKGBUILD
23:56:06 <ThatTreeOverTher> hahaha
23:56:47 <ThatTreeOverTher> usually all you put in there is "./configure && make" then "make install" anyway
23:57:00 <ThatTreeOverTher> other times it's not unlike filing a tax return actually
23:57:34 <ThatTreeOverTher> you want to patch a file before compiling? add it to the PKGBUILD! hope you guessed your cwd right lol
23:57:52 * hackagebot github 0.14.0 - Access to the GitHub API, v3.  https://hackage.haskell.org/package/github-0.14.0 (phadej)
23:58:01 <ThatTreeOverTher> well it's late 
23:58:03 <ThatTreeOverTher> or early
23:58:20 <liste> OS package managers don't play well with concurrent versions, though
23:58:28 <ThatTreeOverTher> oh no they do not
23:58:48 <ThatTreeOverTher> anything LLVM I do, I have to do it far away from pacman
23:58:59 <liste> if you're using something like Stackage or LTS, they're OK
23:59:32 <ThatTreeOverTher> oh is that cabal hell, when you have to concurrent deps of incompatible versions?
