00:00:08 <quchen> ontop_: You can also get rid of the "(Config n u c s p)" business with record syntax
00:00:13 <ReinH> And now it is obvious that maybeNick and maybeUser do the same thing, so that can be turned into a helper function.
00:00:45 <ontop_> quchen: I thought I was using record syntax.
00:01:01 <ontop_> ReinH: That paste just blew my mind.
00:01:05 <ontop_> I've got to stare at this for a sec.
00:01:08 <quchen> http://lpaste.net/148597 ontop_ 
00:01:14 <ReinH> ontop_: remember:
00:01:22 <ReinH> > (,) <$> Just 1 <*> Just 2
00:01:24 <lambdabot>  Just (1,2)
00:01:25 <quchen> ontop_: You're defining a record data type, but you're not using record syntax for updating
00:01:29 <ReinH> > (,) <$> Just 1 <*> Nothing
00:01:31 <lambdabot>  Nothing
00:01:34 <ontop_> quchen: Didn't know I could, very nice thanks!
00:01:54 <ontop_> <$> is fmap, <*> is...
00:02:00 * ontop_ tries hard to remember
00:02:07 <ontop_> <*> = applicative?
00:02:09 <mniip> it's called 'ap'
00:02:11 <jle`> "ap"
00:02:14 <ReinH> The applicative thing
00:02:20 <ontop_> Yay. I remembered.
00:02:23 <ReinH> ontop_: you can also do it like this:
00:02:35 <jle`> to me i just sort of perceive them as whitespaces
00:02:43 <ReinH> do nick <- maybeNick; user <- maybeUser; ...; return Config nick user ...
00:02:51 <jle`> `(,) <$> Just 1 <*> Just 2` sort of fuzzes in my brain to be `(,) 1 2`
00:02:51 <ReinH> using the Maybe Monad instance
00:02:52 <mniip> using the monad thing!
00:02:56 <ontop_> jle`: To me I percieve them as incredible complexity and toughness haha.
00:03:12 <jle`> if i see `f <$> x <*> y` i usually just read it as `f x y`
00:03:19 <ReinH> > do x <- Just 1; y <- Just 2; return (x,y)
00:03:19 <ontop_> ReinH: Yea! That's what I was thinking to do initially.
00:03:20 <lambdabot>  Just (1,2)
00:03:25 <ReinH> > do x <- Just 1; y <- Nothing; return (x,y)
00:03:26 <lambdabot>  Nothing
00:03:30 <ReinH> same thing
00:03:32 <ontop_> Since I had that [Maybe Node]
00:03:34 <ontop_> Thing going on.
00:03:41 <ontop_> It sort of reminded me of the Maybe instance for Monad.
00:03:41 <mniip> jle`, I perceive them as ugly typechecker markup that requires me adding more parentheses ;)
00:03:58 <jle`> heh
00:04:09 <ReinH> banana brackets would be nice maybe
00:04:24 <jle`> i really just do read f <$> x <*> y <*> z as `f x y z` these days
00:04:25 <ReinH> Especially if they support operators and tuples.
00:04:58 <ReinH> iirc ocharles made a quasiquoter for them that was pretty complete?
00:05:06 <ReinH> er apparently he goes by ocharles__ now
00:05:13 <jle`> ocharles__ where art thou
00:05:14 <quchen> jle`: I wish! To me it's "f NOISE x y NOOOOOISE z" :-|
00:05:20 <quchen> ♥ Idris' idiom brackets
00:05:21 <jle`>  :=|
00:05:34 <ReinH> quchen: heh
00:06:00 <ReinH> ontop_: anyway, perhaps something to ponder as you decide on what mistake to make next (and I mean that in a good way)
00:06:24 <ontop_> Well, I wanna try to rewrite this using the Maybe monad.
00:06:28 <ReinH> seems good
00:06:29 <ontop_> And that original fmap I had
00:06:46 <ReinH> ontop_: suggest trying some simpler uses of the Maybe monad first to get a feel for it.
00:06:57 <ontop_> Yeah. I read about it in my book.
00:07:02 <ontop_> This'll have to wait till tomorrow.
00:07:05 <ontop_> Itt's bedtime
00:07:14 <ontop_> Thanks very much quchen, ReinH. Really helpful feedback.
00:07:25 <ontop_> Gnight.
00:07:39 * hackagebot pipes-concurrency 2.0.5 - Concurrency for the pipes ecosystem  https://hackage.haskell.org/package/pipes-concurrency-2.0.5 (GabrielGonzalez)
00:07:39 * hackagebot ini 0.3.3 - Quick and easy configuration files in the INI format.  https://hackage.haskell.org/package/ini-0.3.3 (ChrisDone)
00:07:44 <srhb> quchen: Yes please. Did that ever become a proposal?
00:08:01 <quchen> srhb: I don't think so.
00:08:06 <srhb> Aw.
00:12:29 <Gurkenglas> What if you had Num b => Num (a -> b)? "(+1) + (+1)" would overlap (even if the overlaps do the same)
00:13:46 <hunteriam> overlap?
00:14:10 <mniip> Gurkenglas, been there done that
00:15:22 <Gurkenglas> I mean it would overlap with jles proposal proposal
00:15:35 <Gurkenglas> I've been here one time it happened ._.
00:16:19 <mniip> just @undefine and hope they weren't using it :)
00:17:31 <ocharles__> ReinH: his irc client decides he goes by ocharles_ but he really should go by ocharles
00:18:00 <ocharles> ReinH, jle`: I have a quasiquoter... somewhere, and a proposal on the wiki to make this a GHC extension
00:18:31 <jle`> what was my proposal proposal?
00:18:48 <ocharles> that's about as far as I got. I think you can write a magic 'lift' function though that does the right thing, which is ok if you don't have to nest a bunch computations
00:18:50 <ocharles> eh?
00:20:00 <Gurkenglas> I like the num instance, the "._." was because of the misunderstanding, and by overlap I meant that "(+1) + (+1)" would be resolved to the num instance definition one way and to "(+) <$> (+1) <*> (+1)" as per "<jle`> i really just do read f <$> x <*> y <*> z as `f x y z` these days"
00:20:44 <jle`> oh ah
00:20:56 <jle`> yeah it's just how i parse it in my head
00:21:04 <jle`> i wouldn't want them to actually be implicitly that way, heh
00:37:07 <hunteriam> auth :: (a -> Serv b) -> Maybe SigninToken -> a -> Serv b
00:37:14 <hunteriam> can a be Int -> Int -> Int for example
00:37:51 <liste> hunteriam sure
00:38:53 <hunteriam> so then in auth f token (a :: Int -> Int -> Int) is a necesarilly a function from 2 ints to int
00:39:09 <hunteriam> what if f was meant to be a function from 3 ints to serv b?
00:41:41 <Gurkenglas> Then you can set a to (Int, Int, Int)
00:41:53 <hunteriam> i cant
00:42:29 <liste> why not?
00:42:40 <hunteriam> my goal is to take a function (a0 -> a1 -> ... -> Serv b) and make it a (Maybe SigninToken -> a0 -> ... -> Serv b)
00:42:45 <hunteriam> liste: api restrictions
00:43:18 <hunteriam> and to automatically do some stuff with the maybe signintoken
00:43:25 <hunteriam> and then just be the original function
00:44:05 <liste> so you want to combine a "Maybe SigninToken -> Serv ()" and "foo -> bar -> Serv b" ?
00:44:25 <hunteriam> i suppose
00:45:04 <hunteriam> actually its a Maybe SigninToken -> Serv b
00:45:34 <liste> how can it return any type?
00:45:44 <hunteriam> Serv is EitherT
00:45:48 <liste> ok
00:46:07 <liste> your "auth" type signature looks fine to me
00:46:11 <Gurkenglas> More generally, m () and an any-number-of-arguments monadic function, by >> the first and the end result of the second
00:46:42 <hunteriam> i dont want to run the second depending on the first
00:47:03 <Gurkenglas> Choosing the correct m does that implicitly :D
00:47:24 <hunteriam> >> would run it no?
00:47:56 <Gurkenglas> >> would monadically combine the two. If the monad is Maybe, (Nothing >>) is const Nothing
00:48:15 <suppi> <|> ?
00:49:41 <Gurkenglas> For what I said, you could do "\munit -> curryN . fmap (munit >>) . uncurryN", using http://hackage.haskell.org/package/tuple-0.3.0.2/docs/Data-Tuple-Curry.html
00:50:23 <hunteriam> interesting solution
00:55:12 <Gurkenglas> (I love how http://hackage.haskell.org/package/tuple-0.3.0.2/docs/src/Data-Tuple-Curry.html#Curry looks when you look at it from far away.)
01:05:01 <hunteriam> so i want `auth :: (a0 -> a1 -> ... -> EitherT ServantErr IO b) -> (Maybe SigninToken -> a0 -> ... -> EitherT ServantErr IO b)
01:05:35 <hunteriam> pretty stuck
01:06:18 <Gurkenglas> If the SigninToken is wrong you just want to left out of the monad, right?
01:06:23 <hunteriam> yea
01:06:29 <hunteriam> but if its right i need to be that function
01:07:38 <Gurkenglas> "flip $ \maybesignintoken -> curryN . fmap (unless (isJust maybesigntoken) $ left "SigninToken was Nothing") . uncurryN", as I said
01:07:42 <Gurkenglas> Whoops I mean
01:07:53 <Gurkenglas> "flip $ \maybesignintoken -> curryN . fmap (unless (isJust maybesigntoken) (left "SigninToken was Nothing") >>) . uncurryN"
01:07:56 <hunteriam> I dont understand what that says
01:08:43 <Gurkenglas> afaik left turns e into EitherT e a, if it doesnt use something else that does
01:08:56 <hunteriam> curryN?
01:09:05 <hunteriam> @src curryN
01:09:05 <lambdabot> Source not found. :(
01:09:10 <hunteriam> not on hoogle
01:09:19 <Gurkenglas> The thing you said "interesting solution" at back when I said it together with the link http://hackage.haskell.org/package/tuple-0.3.0.2/docs/Data-Tuple-Curry.html
01:10:04 <Gurkenglas> First I do flip because I like implementing "Maybe SigninToken -> (a0 -> a1 -> ... -> EitherT ServantErr IO b) -> (a0 -> ... -> EitherT ServantErr IO b)" more
01:10:52 <hunteriam> curry is extremely useful
01:11:13 <Gurkenglas> "maybesignintoken" is transformed into "unless (isJust maybesigntoken) (left "SigninToken was Nothing")" so I get an EitherT ServantErr IO (), which I wanted because that leads to the case I already solved when I first posted that link
01:11:32 <Gurkenglas> And the rest is just directly that solution.
01:32:59 <synthmeat> /close/close
01:33:11 <synthmeat> sorry 'bout that
01:35:44 <cem__> i dont like haskell
01:35:56 <cem__> all my assumption goes wrong
01:36:12 <cem__> hi darf
01:36:18 <tdammers> is that haskell's fault, or are your assumptions to blame?
01:36:18 <cem__> darkf
01:36:35 <cem__> haskell fault 
01:36:37 <cem__> http://learnyouahaskell.com/starting-out#an-intro-to-lists
01:36:57 <cem__> head [1,2,3] gives 1
01:37:03 <cem__> tail gives list
01:37:04 <tdammers> yes
01:37:14 <tdammers> what did you expect? that's exactly what their documentation says
01:37:20 <cem__> why the heck it gives list
01:37:26 <cem__> and why we have last function
01:37:39 <tdammers> ancient FP tradition
01:37:50 <tdammers> cons lists: a list is defined as the current value and a reference to the rest of the list
01:37:50 <cem__> joking?
01:37:57 <tdammers> not at all
01:38:16 <darkf> cem__: well what would you expect, it's a linked list :)
01:38:27 <tdammers> having a "head" and "tail" this way is very natural for a single-linked list data structure
01:38:37 <darkf> 1 : 2 : [] means "a pair of 1 and (a pair of 2 and empty list)"
01:38:43 <dutchie> yeah, linked lists exist in oo/procedural langs too
01:38:46 <tdammers> in fact, you can implement an equivalent of Haskell's built-in list as a data type that works exactly like that:
01:38:47 <cem__> logically names are not right
01:38:58 <cem__> if head gives head element
01:39:04 <cem__> tail must give tail element
01:39:17 <tdammers> they're called head and tail, not headElem and tailElem
01:39:17 <Xnuk> >> last [1,2,3]
01:39:22 <Xnuk> > last [1,2,3]
01:39:24 <lambdabot>  3
01:39:40 <cem__> >> tail [7,8,9]
01:39:45 <cem__> > tail [7,8,9]
01:39:47 <lambdabot>  [8,9]
01:39:51 <darkf> cem__: i like the image from LYAH: http://s3.amazonaws.com/lyah/listmonster.png the head of the pair is the first element, the tail (the second element of the pair) is the rest
01:39:53 <cem__> why!
01:40:23 <tdammers> data List a = Nil | Cons a (List a)
01:40:33 <darkf> just because that's what they chose to name it, I find it nicer than car/cdr by far ;)
01:40:36 <tdammers> do you understand why and how this implements a linked list data structure?
01:40:49 <cem__> a language must be friendly
01:41:00 <tdammers> define "friendly"
01:41:21 <darkf> it is really well explained, and it makes sense once you learn it, so I find it quite friendly
01:41:27 <tdammers> exactly
01:41:43 <tdammers> and since people come with varying assumptions, it is impossible for a language to meet all of them
01:41:45 <yfeldblum> cem__: the way you're thinking about this works well in other languages, but not in haskell ... once you start thinking about haskell lists the haskell way, `head` and `tail` make a lot more sense
01:41:53 <cem__> good question, a common  way of thinking
01:42:14 <tdammers> one might even argue that "list" is not a very suitable name for Haskell's lists
01:42:28 <hunteriam> so are you sayimg anythim >> left a in an eithert io ignores the io actions in the anythimg?
01:42:44 <hunteriam> Gurkenglas: 
01:42:46 <Gurkenglas> hunteriam, no, left a >> anythim
01:43:10 <tdammers> >> throws away the result value, but it still short-circuits on monadic fail
01:43:30 <tdammers> > Just 1 >> Just 2
01:43:32 <lambdabot>  Just 2
01:43:33 <tdammers> > Nothing >> Just 2
01:43:34 <yfeldblum> tdammers: "list" is a decently suitable name - it maps well to the concept of "singly linked list", and data structures named "list" in some languages (like c++), except it's lazy
01:43:34 <lambdabot>  Nothing
01:43:52 <Gurkenglas> > execState (mzero >> modify (+1)) 1
01:43:54 <lambdabot>      Could not deduce (MonadPlus Identity) arising from a use of ‘mzero’
01:43:54 <lambdabot>      from the context (Num s)
01:43:54 <lambdabot>        bound by the inferred type of it :: Num s => s at <interactive>:1:1
01:44:24 <tdammers> yfeldblum: yes, of course; but the lazy part is kind of important, because it means the list is also a (current value, continuation) pair
01:45:11 <cem__> 1 more question 1:[6,7,8,9]  adds fast why not [8,9,......10000] :[1] takes slow time isnt list should be O(1) for adding at last ?
01:45:29 <yfeldblum> tdammers: it's important, yes, but not in a way that means we ought to use a different word than the one we already know for the concept and its implementation in various languages
01:46:05 <tdammers> yfeldblum: it's not a 100% serious suggestion; just drawing some attention to the fact that lists don't necessarily behave like a non-programmer's intuition would suggest
01:46:11 <yfeldblum> cem__: the second example is not legal, and no, computing the second example takes time O(n)
01:46:12 <suppi> cem__, perhaps you meant ++ instead of :
01:46:24 <tdammers> cem__: no, single linked lists have O(1) insertion on the front only, anything else is O(n)
01:46:33 <suppi> ^
01:46:34 <yfeldblum> cem__: because it's a haskell list (singly-linked list, like in c++) and not an array
01:46:38 <tdammers> cem__: this holds regardless of programming language btw
01:47:35 <cem__> is 1:[1,2,3] creates a new list ?
01:47:36 <Gurkenglas> > execState (runMaybeT $ mzero >> modify (+1)) 1 -- I mean this, as opposed to:
01:47:38 <lambdabot>  1
01:47:41 <Gurkenglas> > execState (runMaybeT $ return () >> modify (+1)) 1 -- I mean this, as opposed to:
01:47:43 <lambdabot>  2
01:47:54 <Gurkenglas> Minus the last comment ._.
01:48:02 <suppi> cem__, yes
01:48:05 <tdammers> cem__: yes. the : operator takes an element and a list and returns a list that consists of the original list with the new element prepended
01:51:11 <cem__> > last [1,2,3,4,5,6-6]
01:51:13 <lambdabot>  0
01:52:26 <cem__> is it last [6,7,8,9,8,0-0,(- 9 9)]
01:52:34 <cem__> is it last [6,7,8,9,8,0-0,(-) 9 9]
01:52:40 <cem__> >last [6,7,8,9,8,0-0,(-) 9 9]
01:52:46 <cem__> > last [6,7,8,9,8,0-0,(-) 9 9]
01:52:47 <lambdabot>  0
01:53:17 <Gurkenglas> (Do not confuse "creates a new list" with "allocates new memory and copies the contents" - It's just a new pointer pointing at the old list. (If the entire list isn't optimized away anyway depending on the usage.))
02:02:36 * hackagebot hackage-security 0.5.0.1 - Hackage security library  https://hackage.haskell.org/package/hackage-security-0.5.0.1 (EdskoDeVries)
02:06:46 <cem__> haskell is weird but nice
02:07:03 <cem__> is there no bugs in haskell ?
02:07:36 <srhb> cem__: Sure.
02:07:57 <srhb> cem__: People make bugs all the time. It's just easier to eliminate or avoid some classes of bugs.
02:08:09 <cem__> yeppy! i like it
02:08:23 <cem__> hopefully its not like js :)
02:08:48 <quchen> > let twice x = x*3 in twice 10 -- Here, a bug in Haskell that's not caught by the typechecker
02:08:49 <lambdabot>  30
02:08:56 <yfeldblum> it's also easy to run into other classes of bugs, like doing `myLongList ++ [3]`
02:12:30 <Fuco> quchen: how is that a bug? 10*3 is 30
02:13:06 <dutchie> Fuco: it's either a bug or a very misleadingly named function
02:13:22 <Fuco> but that's not a bug in haskell
02:13:26 <Fuco> that's user error
02:13:59 <dutchie> agreed. but "are there bugs in haskell" is an ambiguous question imo
02:14:20 <quchen> Haskell has no bugs. Software has bugs, and Haskell is not software.
02:14:32 <quchen> GHC is a Haskell implementation. GHC can have bugs.
02:14:38 <Fuco> quchen: well I interpreted it as "haskell = ghc" :D
02:14:48 <Fuco> it's mostly true for practical purposes
02:14:56 <quchen> Bugs written in GHC are written by its authors. All bugs are user errors.
02:15:40 <Fuco> true, but when we say 'bug in $proglang' we usually mean that it doesn't do what the spec is saying it should
02:16:32 <quchen> … unexpectedly so. GHC doesn't abide the Haskell Report in a couple of details, but those are deliberate, and not bugs.
02:16:49 <quchen> Applicative => Monad, Num not having Eq/Show superclasses for example.
02:22:45 <cem__> waiiiiiiiiiiiiiiiiiit!
02:22:49 <cem__> null []
02:22:54 <cem__> True
02:23:09 <cem__> null is something different 
02:23:20 <liste> :t null
02:23:21 <lambdabot> Foldable t => t a -> Bool
02:23:24 <cem__> is null is empty in haskell
02:23:36 <liste> @src null
02:23:36 <lambdabot> null []     = True
02:23:36 <lambdabot> null (_:_)  = False
02:24:00 <cem__> well i'm newbie wont understand the src code
02:24:16 <Gurkenglas> :t Nothing -- What you think null is Nothing for us (It's only usable if you use the Maybe type - Maybe a is either Just a or Nothing
02:24:18 <lambdabot> Maybe a
02:25:04 <Gurkenglas> Yep, our null is pretty much your empty
02:36:35 <srhb> cem__: null is a function that is true if its argument is the empty list. 
02:36:39 <srhb> cem__: That's all.
02:37:10 <MarcelineVQ> for starters :>
02:37:44 <srhb> cem__: Conceptually, the source code says if argument == [] then True else False. It's a bit more clever than that in avoiding constraints and some pitfalls, but that's less important.
02:38:38 <dutchie> (it also works for certain things that aren't lists but which are still sort of list-like)
02:41:18 <Gurkenglas> (But that's just because @src lied.)
02:41:20 <suppi> interesting how the type signature and source for null does not match
02:42:21 <MarcelineVQ> suppi: here you go http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.List.html#null
02:42:41 <liste> well, @src is a lie anyway
02:44:39 <suppi> MarcelineVQ, sure you didn't meant this? http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Foldable.html#null
02:44:49 <suppi> mean*
02:45:03 <sphinxo> Is this a reasonable use of WriterArrow? http://lpaste.net/148600
02:45:28 <MarcelineVQ> suppi: Correct, I was linking the one that matched the @src
02:45:58 <suppi> MarcelineVQ, yeah, still the @src and :t does not match :)
02:46:24 <suppi> :t GHC.List.null
02:46:26 <lambdabot> [a] -> Bool
02:46:43 <suppi> @src Data.Foldable.null
02:46:43 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
02:47:37 <puregreen> eh, Data.Foldable.null is a method, there's no source to show anyway
02:47:51 <suppi> method?
02:48:00 <puregreen> it's a method of the Foldable class
02:48:21 <sphinxo> Could someone also give me some general code review of  http://lpaste.net/148600 ?
02:48:28 <puregreen> hm, on the other hand it's got a default implementation so @src could show that, I guess
02:48:35 <puregreen> null = foldr (\_ _ -> False) True
02:49:28 <suppi> oh, I see
02:49:34 <suppi> that's a pretty big class
02:50:16 <liste> sphinxo what does Stmt do?
02:50:50 <sphinxo> Stmt does nothing for the moment
02:51:41 <sphinxo> it might have things like If Expr Stmt Stmt
02:52:02 <sphinxo> or While Expr Stmt
02:52:16 <cem__> > ['A' ... 'Z']
02:52:17 <lambdabot>      Couldn't match type ‘Char’ with ‘(c0 -> f c0) -> s -> f t’
02:52:17 <lambdabot>      Expected type: LensLike f s t c0 c0
02:52:17 <lambdabot>        Actual type: Char
02:52:37 <cem__> wow! i understand ur formulae :D
02:52:55 <Gurkenglas> > ['A' .. 'Z']
02:52:57 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
02:53:18 <suppi> two dots instead of three for what you want :)
02:53:43 <liste> what does (...) do anyway?
02:54:03 <sphinxo> Any other feedback liste?
02:54:11 <srhb> :t (...)
02:54:12 <lambdabot> (Applicative f, Plated c) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
02:55:14 <frerich> It's hideous how misleading the error message given for ['A' ... 'Z'] is :-/
02:56:21 <Gurkenglas> Do you want it to find a typechecking program within small edit distance?
02:58:08 <Gurkenglas> (It only happens if you import Control.Lens.Plated though, and who does that)
02:58:14 <quicksilver> me!
02:58:21 <quicksilver> xml-lens ftw.
02:58:57 <puregreen> Gurkenglas: Control.Lens reexports Control.Lens.Plated
02:59:23 <quicksilver> ... is just .plated. isn't it?
02:59:51 <puregreen> yep
02:59:57 <puregreen> l ... m = l . plate . m
03:00:52 <liste> sphinxo not atm at least
03:02:56 <sphinxo> ok thanks
03:03:34 <quicksilver> puregreen: it's kind of obvious from the type.
03:03:43 <quicksilver> after I spent 6 minutes reading the type.
03:03:48 <quicksilver> 6-minute-obvious
03:04:22 <dutchie> the best kind of obvious
03:06:18 <cem__> > [20..1]
03:06:20 <lambdabot>  []
03:06:23 <cem__> ?
03:06:39 <pavonia> > [20, 19 .. 1]
03:06:41 <lambdabot>  [20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]
03:06:52 <cem__> >[1..20]
03:07:01 <cem__> > [1..20]
03:07:02 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
03:07:08 <cem__> > [20..1]
03:07:10 <lambdabot>  []
03:07:30 <pavonia> The default increment is +1
03:13:15 <liste> > [20,19..1]
03:13:17 <lambdabot>  [20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]
03:25:03 <anagha> hello people.Is there any beginners channel for haskell?
03:25:17 <zachk> you are in it! :D wait wait let me check
03:25:20 <bernalex> anagha: beginner questions are welcome in here.
03:25:36 <suppi> #haskell-beginners is another channel, but you can definitely ask here as well :)
03:25:43 <zachk> there is a populated #haskell-beginners but this one is usually fine 
03:26:29 <anagha> ok
03:27:51 <cem__> haskell is weird language
03:28:02 <zachk> how so? hehe
03:28:16 <cem__> its so not what you thought of
03:28:35 <zachk> thought of what? programming in general? I rather like it 
03:28:36 <cem__> you will be beginner no matter what
03:29:08 <zachk> some people seem to pick it up rather quick
03:29:26 <cem__> i'm not the person
03:29:29 <Cale> If you already know another typed functional programming language, it's perhaps a fair amount less strange
03:29:53 <Cale> But most people don't know another language which is similar to Haskell
03:30:13 <cem__> yes
03:30:16 <suppi> Cale, I know I didn't :)
03:30:16 <Cale> Since Haskell is probably the most popular language which is similar to Haskell.
03:30:38 <cem__> what about lisp ?
03:31:01 <Cale> lisp is not very similar, but perhaps some ideas will carry over
03:31:06 <cem__> this is my first FP language
03:31:23 <Cale> Most lisps don't have a static type system
03:31:31 <suppi> I have trouble learning lisps after using Haskell
03:31:57 <zachk> I did the lisp thing first with scheme awhile ago 
03:32:08 <zachk> couldn't seem to find a real compiler with graphics for it though 
03:32:27 <suppi> Cale, someone posted on the Elm mailing list yesterday about try Elm first as a jump board to Haskell
03:32:47 <suppi> zachk, what do you mean a real compiler with graphics for it?
03:33:42 <zachk> scheme is usually interpreted, and there was nice fancy graphic libraries for it, as far as I could tell, and it would bog down doing garbage collector with line vector graphics 
03:34:40 <suppi> well, chicken, guile and racket can be compiled as well
03:35:05 <suppi> there's also a game jam right now for lisp languages where people do graphics stuff
03:35:06 <zachk> try that on windows and get opengl working too
03:35:17 <suppi> oh, I don't use windows.
03:35:35 <suppi> things mostly work on linux i suspect
03:40:18 <statusfailed> What's a good parser combinator library these days?
03:40:28 <statusfailed> Ideally one with nice error messages
03:41:28 <suppi> statusfailed, I hear good things about trifecta
03:41:38 <suppi> but i never used it
03:41:50 <suppi> alternatively, megaparsec perhaps?
03:43:19 <statusfailed> suppi: hmm, megaparsec seems to have more docs
03:43:31 <cem__> how to print prime no from 1 ..117
03:43:37 <cem__> i like prime
03:44:24 <ironChicken> cem__: that's a fun exercise which you should try yourself ;-)
03:44:31 <suppi> cem__ there are a few approaches :)
03:44:47 <liste> cem__ a hint: use takeWhile and filter
03:45:00 <liste> for one solution
03:45:07 <liste> there are others of course too (:
03:45:37 <cem__> hmm challenge
03:50:28 <cem__> i guess the chapter 1 will take a long long long time
03:50:32 <suppi> statusfailed, so you are going with megaparsec? :)
03:50:49 <merijn> statusfailed: trifecta has nice errors, but can be a bit confusing to get started with
03:51:27 <statusfailed> suppi, merijn: Yeah trifecta looks a bit fiddly, megaparsec looks quite nice and self contained
03:51:43 <Fuco> parsec is not cool anymore?
03:51:44 <merijn> statusfailed: Most of the "interface" of trifecta is in parsers
03:52:15 <merijn> statusfailed: I have an example trifecta parser here: https://github.com/merijn/lambda-except see Lexer.hs and Parser.hs
03:52:21 <suppi> merijn, would you recommend trifecta in general? and in contrast to megaparsec?
03:52:34 <merijn> I haven't used/looked at megaparsec
03:53:15 <merijn> trifecta is certainly more modern than, e.g. parsec, but I don't think it matters very much most of them are very similar in how you write parsers
03:53:26 <statusfailed> Here's a megaparsec example: https://mrkkrp.github.io/megaparsec/tutorials/parsing-simple-imperative-language.html
03:54:48 <suppi> merijn, this interpreter looks really interesting! I'm going to explore it :)
03:55:02 <suppi> merijn, is it explicitly typed?
03:55:10 <Fuco> there's also attoparsec :D
03:55:29 <Fuco> reading the readme megaparsec basically seems to be "bug fixes for parsec" and tests
03:55:30 <merijn> suppi: Yes, the type checker is currently buggy, though :p
03:55:42 <suppi> merijn, ok, i'll be careful :)
03:55:45 <statusfailed> Fuco: attoparsec doesn't really do good error messages iirc
03:55:45 <Fuco> I wonder if this warrants a fork, but well
03:55:46 <merijn> Fuco: attoparsec has a different usecase than parsec/trifecta/etc.
03:55:52 <statusfailed> Fuco: this is for a programming language
03:56:00 <statusfailed> but I've used it before, it's good
03:56:24 <merijn> Fuco: attoparsec's goal is speed at any cost, including good errors, so don't expect anything more than "doesn't parse"
03:56:39 <suppi> merijn, I've made a subreddit on experimental langs, still looking for content. if you are interested maybe post there? :) /r/ExperimentalLangs
03:56:42 <Fuco> right
03:56:53 <merijn> Fuco: Whereas trifecta/parsec want to provide useful errors (think programming languages) where you don't care too much about speed
03:57:10 <Fuco> oh megaparsec is written by mark karpov... he did some nice PRs on my emacs packages :)
03:57:22 <suppi> well, you care, but you care about errors more :)
03:57:47 <tdammers> you don't generally care much about linear speed penalties when it comes to compilers
03:58:10 <statusfailed> merijn: What's the motivation for your lambda-except language? 
03:58:17 <statusfailed> just curious :-)
03:58:21 <merijn> suppi: parsing time for source files (i.e. max like several thousand lines) is usually so small that even order of magnitude isn't something to worry about it
03:58:34 <merijn> statusfailed: Experimenting with checked exceptions in lazy System F_omega
03:58:45 <statusfailed> F_omega is top right of the lambda cube?
03:58:48 <statusfailed> always forget
03:58:56 <merijn> statusfailed: But I haven't had time to get the typechecker for System F_omega finished yet :p
03:59:03 <tdammers> well, I wouldn't want a compiler with O(e^n) parsing if I could avoid it
03:59:12 <merijn> statusfailed: It's the one that's one step away from dependent types :)
03:59:23 <merijn> Which I think is the top of the cube, yeah
03:59:27 <statusfailed> ah yeah, top left
03:59:33 <statusfailed> top.. back left? whatever :D
03:59:40 <merijn> You could make it CoC, but then you're type checking becomes undecidable :p
03:59:41 <suppi> there's also earley, btw ( http://conscientiousprogrammer.com/blog/2015/12/14/24-days-of-hackage-2015-day-14-earley-a-promising-newer-parser-library-for-haskell/ )
03:59:48 <statusfailed> tdammers: just generate all the strings in the language and see if the source file is in there, what's the problem!?
03:59:57 <tdammers> lol
04:00:15 <tdammers> bogopile: generate random strings until the correct output is found
04:00:25 <statusfailed> This is interesting too: http://tanakh.github.io/Peggy/
04:00:31 <tdammers> didn't someone here write something like that a while ago?
04:00:51 <statusfailed> I did the "Generate all strings" thing yesterday for a dumb arithmetic language
04:00:57 <statusfailed> it starts getting slow after 5 iterations, heheh
04:01:12 <Fuco> wouldn't it simply go 1 + 1 + 1 + 1 ..... and never terminate?
04:01:22 <statusfailed> no it goes
04:01:29 <Fuco> or rather ((((((((((( :D
04:01:47 <zachk> cem__ you can use factorial to generate primes for fun 
04:01:58 <statusfailed> <number> ; ( <expr> ); <expr> + <expr>; ( <number> ); <number> + ......
04:02:01 <tdammers> depends on whether you go depth-first
04:02:24 <Fuco> tdammers: okey, but generating *all* the strings it doesn't really matter how you do it
04:02:37 <tdammers> you generate all of them until you find the right one
04:03:00 <tdammers> given that the right one is going to be finite, depth-first is unlikely to succeed, because there is no upper bound to how deep you can search
04:03:18 <tdammers> i.e., you're not guaranteed to find the right one ever
04:03:36 <tdammers> but if you go breadth-first, i.e., first all the single-character strings, then all the two-character ones, etc.
04:03:45 <Fuco> yes, that's of course true.  I guess my nitpicking went unnoticed.
04:04:13 <Fuco> let's complain about svn instead
04:04:30 <tdammers> that's like beating up a retarded baby though
04:04:49 <tdammers> plus, unlike PHP, svn is rapidly losing popularity
04:04:59 <tdammers> -blah material anyway
04:05:30 <Fuco> tdammers: at my dayjob we develop PHP with svn 
04:05:36 <Fuco> best of both worlds
04:05:49 <tdammers> RUN!
04:05:58 <Fuco> I've been fixing merge conflicts entire day today
04:06:09 <Fuco> that's why I'm a bit bitter :D
04:10:38 <anohigisavay> hi. i'm trying to add Python 3 annotations support to Python 2.7
04:10:56 <anohigisavay> and used a modified python parser based on happy/alex
04:11:23 <cem__> 1 more question, why applied mathematics people use R instead of haskell ?
04:11:29 <anohigisavay> which takes the customized python source code and generates ordinary python code
04:12:03 <hpc> cem__: ask the R people
04:12:05 <anohigisavay> however the error backtrack has nothing to do with the customized version of code
04:12:11 <Fuco> cem__: because R is better for the task
04:12:21 <hpc> cem__: i haven't used R much but it definitely has more built-ins for statistical purposes
04:12:21 <Fuco> haskell mathematics is stupidly stupid
04:12:24 <anohigisavay> thus losing location info
04:12:30 <anohigisavay> *position
04:14:14 <Fuco> anohigisavay: this is #haskell not #python, maybe you are in the wrong window? :O
04:14:19 <tdammers> cem__: because R kicks haskell around the room when it comes to multi-dimensional number crunching
04:14:32 <anohigisavay> Fuco: no. the parser is implemented with haskell
04:14:48 <Fuco> anohigisavay: ah, I missed the happy part :) sorry
04:15:36 <anohigisavay> i believe haskell people know better at language parsing stuff :D
04:16:25 <statusfailed> merijn: "the formalism
04:16:25 <statusfailed> remains an unaccommodating object of study, without true structure, a piece of
04:16:27 <statusfailed> soft camembert"
04:16:40 <statusfailed> this is a great book
04:17:12 <hpc> anohigisavay: there's an old joke that only perl can parse perl
04:17:25 <hpc> anohigisavay: but the interpreter for perl6, pugs, was written in haskell first
04:17:43 <hpc> so for a few glorious years, even perl couldn't parse perl and they needed to resort to ghc
04:17:52 <anohigisavay> xD
04:18:22 <quicksilver> although actually the point of 'only perl can parse perl' was that parsing perl requires executing it
04:18:26 <anohigisavay> they can still turn to the old yacc and bison maybe 
04:18:41 <hpc> quicksilver: yeah, but that's not important for the joke ;)
04:19:10 <quicksilver> 'only TeX can parse TeX'
04:19:23 <hpc> plus perl is really hard to parse anyway even when you don't have screwy BEGIN antics
04:19:24 <mauke> hpc: that's like saying perl5 can't parse perl and they needed to resort to yacc and C
04:19:39 <hpc> and perl is specified by the behavior of the interpreter
04:20:37 <hpc> 'only sendmail can parse m4'
04:20:53 <Fuco> not even sendmail can parse it correctly though
04:21:13 <hpc> my desktop background at work is the generated output of a default sendmail configuration
04:21:19 <suppi> tdammers, I wonder how http://tweag.github.io/HaskellR/ is in comparison to R :)
04:21:19 <hpc> it's hideous
04:22:08 <mauke> anohigisavay: so your problem is that error messages refer to the generated code, not the locations in the original source?
04:22:20 <anohigisavay> mauke: yes
04:22:23 <Fuco> hpc: that's madly awesome
04:23:13 <mauke> all I know is that you wouldn't have this problem with perl :-)
04:23:26 <anohigisavay> _(:з」∠)_
04:23:53 <hpc> sometimes i switch it to a piece of joke javascript that assigned the '=' prototype to $.post("UPDATE foo set foo='foo'")
04:25:08 <zachk> Fuco how is haskell math stupid? D: 
04:25:11 <mauke> does python have anything like #line?
04:25:27 <zachk> anohigisavay you had some sort of question about happy/alex right? ask away 
04:25:33 <Fuco> zachk: fromIntegral
04:25:49 <merijn> Fuco: I disagree that fromIntegral is stupid
04:26:03 <zachk> schemes full numeric tower was nice, I heard the haskell choices were made so it could compile to efficient code 
04:26:11 <anohigisavay> mauke: i don't think it's that advanced xD
04:26:20 <merijn> Fuco: Sure, it's annoying having to use it everywhere. But then I think back to the 5 or so times I had to debug silent coercion errors in C and then I decide "it's not that bad.."
04:26:24 <Fuco> you don't care about any of that when doing stuff you normally use R for...
04:26:49 <Fuco> most R code is "load, call one fucntion from a library, print"
04:26:53 <mauke> zachk: numeric types don't form a "tower" (simple hierarchy)
04:27:02 <zachk> just force everything to be a real, double or float and make your own functions, hide the regular ones in prelude 
04:27:27 <mauke> I shudder every time I read "full numeric tower"
04:27:34 <anohigisavay> zachk: i'm implementing a modified version of python parser that adds annotation support
04:27:40 <zachk> you could do, unit -> int -> float -> double -> complex 
04:27:48 <zachk> anohigisavay cool 
04:27:55 * hackagebot ad 4.3.2 - Automatic Differentiation  https://hackage.haskell.org/package/ad-4.3.2 (EdwardKmett)
04:28:03 * zachk has next to no idea about parsing
04:28:04 <anohigisavay> zachk: and i generate valid python code from the customized syntax
04:28:16 <zachk> what it annotate the code with? 
04:28:28 <zachk> what does it
04:28:32 <anohigisavay> but then i lost the location info
04:28:49 <anohigisavay> the Python 3 annotation style: def (a: int, b: str) -> dict: pass
04:28:52 <zachk> for errors reporting?
04:29:02 <zachk> haven't used python in a while 
04:29:16 <mauke> anohigisavay: what code does that turn into?
04:29:31 <tdammers> suppi: I have no idea, I've never used R in my life, I'm basically just repeating what the R crowd is saying
04:29:36 <merijn> zachk: Where do Fractional values fall into there?
04:29:56 <zachk> like a true Rational? 
04:30:05 <zachk> you could put that between the int and the float 
04:30:11 <anohigisavay> mauke: i haven't implement code generation yet. now i can only get the AST
04:30:18 <suppi> tdammers, I see :)
04:30:25 <mauke> anohigisavay: then where's the problem?
04:30:30 <zachk> have it spit out llvm or something 
04:30:54 <zachk> oh, you are losing the location of your annotations? or just the line numbers?
04:30:56 <mauke> zachk: ints can't be represented faithfully in a float
04:31:04 <anohigisavay> mauke: i'm doing it now, and i have no clue 
04:31:10 <merijn> > (1%5) + (3%20) -- like these
04:31:11 <lambdabot>  7 % 20
04:32:13 <zachk> > (6 % 7) ^ 5
04:32:14 <lambdabot>  7776 % 16807
04:32:25 <zachk> don't think I have seen those before
04:32:27 <anohigisavay> zachk: the line numbers
04:32:32 <anohigisavay> zachk: i can get the annotation info from the AST, the user can determine whether he wants to typecheck with that info
04:32:50 <merijn> :t (6%7)
04:32:51 <lambdabot> Integral a => Ratio a
04:32:53 <zachk> what do you need the line numbers for 
04:33:09 <zachk> > fmap (1%) [1..3] 
04:33:09 <merijn> zachk: They're proper rationals, so none of those pesky rounding nonsense issues :)
04:33:11 <lambdabot>  [1 % 1,1 % 2,1 % 3]
04:33:32 <anohigisavay> k my modified version of python is called pyn, so basically:
04:33:33 <zachk> yea I have made proper rationals before myself in haskell
04:33:44 <anohigisavay> user writes pyn -> generate py -> python interpreter runs
04:34:00 <anohigisavay> and lost the info to the original pyn source code
04:34:15 <mauke> what is "the info"?
04:34:28 <zachk> the type annotations and the line numbers? 
04:34:36 <mauke> what line numbers
04:34:45 <mauke> why would line numbers be lost
04:34:54 <zachk> I think he wants error reporting on his original source from the python interpreter
04:34:58 <zachk> is this #blah? 
04:39:24 <zachk> ok so if I use a filter for valid Dyck statements over an infinite list, I can theorectically compute all valid Dyck language statements....
04:40:18 <zachk> but if I attempt to construct an infinite AST (rosetree'ish) of the dyck language, how could I sensible generate a list from that would theoretically generate all values 
04:42:15 <wedens> does "saturated" mean the same as "fully applied type constructor"?
04:42:18 <Nadrieril> zachk: you can do breadth-first bruteforcing of all possible trees
04:42:55 <Nadrieril> By simply iterating through possible constructors
04:45:15 <Nadrieril> Like asts= map Literal [0..] + Plus asts asts + Mult asts asts
04:45:34 <Nadrieril> Where "+" interleaves its arguments
04:47:55 * hackagebot reflection 2.1.1 - Reifies arbitrary terms into types that can be reflected back into terms  https://hackage.haskell.org/package/reflection-2.1.1 (EdwardKmett)
04:49:09 <zachk> Nadrieril, but what if each node has a list of tree's> 
04:50:04 <zachk> meh maybe I am trying to fit the entire language into one big infinite tree, and I have my structure slightly off
04:51:01 <Nadrieril> Oh you want an infinite tree? You would like to have all possible asts as subtrees ? 
04:51:15 <zachk> yes
04:51:40 <zachk> so it would have infinite depth, and infinite breadth at each node, where each node would be a list of lists of oh gosh
04:53:02 <Nadrieril> Why would you need infinite breadth? 
04:54:24 <Nadrieril> Actually, I have a simple albeit less elegant solution : you can generate the list of all possible finite asts like I did, and turn it into a tree (since you have rosetrees) 
04:57:16 <Nadrieril> :t replicate
04:57:18 <lambdabot> Int -> a -> [a]
04:57:47 <Nadrieril> You would have to add something like + map (\n->replicate n asts) [0..], but I'm not sure if this approach is sensible
04:58:29 <Nadrieril> Sry, map (\n->Node (replicate n asts)) [0..]
04:59:25 <Nadrieril> But I'm conceptually using an infinite family of constructors 
04:59:28 <Fuco> zachk: at each node you only have finite number of rules to derive further nodes, so the breadth would be quite finite
04:59:33 <Fuco> and typically rather small
05:06:04 <masida> Hi! I'm trying to use cryptonite 0.10 to encrypt a lazy ByteString using AES in CBC mode, but I'm stuck on how to do it, probably because I haven't used ByteArray's before. Does anybody have an example or pointer? The tests don't help be much.
05:17:44 <argoneus> is there a way to simply parse a line, split it by spaces, get a certain index onwards etc.?
05:17:52 <argoneus> i found something called parsec but that seems too advanced
05:19:08 <maerwald> parsec/attoparsec is actually pretty simple too
05:19:24 <zachk> is trifecta faster? 
05:19:28 <argoneus> then I guess I need to step it up
05:19:29 <argoneus> :<
05:20:23 <exio4> zachk: if you need high-performance, writing optimized parsers with attoparsec is probably your best bet
05:20:36 <tdammers> zachk: I don't know, but I would expect attoparsec to be a lot faster than trifecta, and parsec to be in about the same league
05:20:40 <akegalj> argoneus: you can split line by spaces by using `words`
05:20:47 <akegalj> > words "hey there"
05:20:49 <lambdabot>  ["hey","there"]
05:21:07 <tdammers> parsec is certainly the easiest to get started with
05:21:22 <exio4> tdammers: wouldn't that be attoparsec? :p
05:21:37 <argoneus> I was more thinking a log or the irc message format
05:21:46 <tdammers> exio4: not if you count error messages
05:22:57 * hackagebot reflection 2.1.1.1 - Reifies arbitrary terms into types that can be reflected back into terms  https://hackage.haskell.org/package/reflection-2.1.1.1 (EdwardKmett)
05:24:12 <hammerlocke> guys, i am trying to understand monads, i have a question. if i have a list in monadic context , what is the ideal way to sort it? 
05:24:46 <exio4> fmap sort?
05:24:58 <hammerlocke> for example. somelist :: (Num a , MonadRandom m) => m [a]
05:25:51 <hammerlocke> thanks. i am just learning new, so still stuggling with mapping concepts
05:26:07 <exio4> @type fmap 
05:26:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:27:30 <hammerlocke> I keep forgetting that monad is also functor. 
05:27:57 * hackagebot Spintax 0.1.0.0 - Random text generation based on spintax  https://hackage.haskell.org/package/Spintax-0.1.0.0 (MichelBoucey)
05:28:16 <argoneus> something like this, to parse it into components ":shiplu!shiplu@example.com PRIVMSG &channel :bot: Poor baby!\r\n", should I use parsec for that?
05:28:30 <argoneus> I didn't find any split/strip, guess that's not functional
05:29:05 <exio4> argoneus: the "easiest" way is to base yourself on the RFC spec, and parsing that into some "IRCCommand" datatype
05:29:15 <frerich> argoneus: In that particular case, I'd go for an existing IRC protocol parser library, e.g. https://hackage.haskell.org/package/irc 
05:29:42 <exio4> (well, actually, yes, but if you are doing this for learning.. using a library might defeat the point)
05:30:04 <argoneus> I'm not looking for existing solutions
05:30:18 <argoneus> I'm trying to learn
05:30:34 <argoneus> I don't like taking things for granted :<
05:30:38 <akegalj> argoneus: Data.Text splitOn :: Text -> Text -> [Text]
05:30:47 <zachk> whats :bot: mean? 
05:30:49 <maerwald> argoneus: for a normal irc msg like "user: some text" you could do: parser = (,) <$> many1 letter <* (char ':') <* space <*> many' letter
05:31:05 <akegalj> > splitOn '\n' "hey\nthere"
05:31:07 <lambdabot>      Couldn't match expected type ‘[Char]’ with actual type ‘Char’
05:31:07 <lambdabot>      In the first argument of ‘splitOn’, namely ‘'\n'’
05:31:07 <lambdabot>      In the expression:
05:31:13 <tdammers> split and strip do exist for Text
05:31:14 <maerwald> then you get a (username, message) tuple when you run the parser on text
05:31:35 <argoneus> when exio4 mentioned the RFC
05:31:40 <argoneus> there is a specific format in the RFC
05:31:47 <argoneus> but I'm not sure how to translate that to haskell
05:31:51 <zachk> > splitOn "\n" "hey\nhey\nyou\nwhats\nthat sound\neveryone looks whats going down" 
05:31:53 <lambdabot>  ["hey","hey","you","whats","that sound","everyone looks whats going down"]
05:31:59 <tdammers> the API for String / [Char] is a bit limited, but I think people aren't keen on fixing that because String isn't the recommended string type anyway
05:32:07 <frerich> argoneus: For the record, 'split/join' also exist for plain String values (in fact, the Prelude contains a variant called 'words' and 'unwords')
05:32:45 <exio4> zachk: the first ":" means "everything until \r\n" is a single parameter to the command"
05:32:54 <exio4> zachk: the message is then, "bot: blabla"
05:33:03 <exio4> argoneus: the pseudo BNF on the spec?
05:33:09 <argoneus> yeah
05:33:11 <argoneus> there is a BNF
05:33:18 <argoneus> but I don't know how to work with it
05:34:12 <zachk> you could probably just break on ':' and do a pattern match on the first part 
05:34:14 <frerich> argoneus: With a parser combinator (aka "building brick") library, you can almost translate the BNF literally.
05:34:26 <exio4> zachk: it's optional.
05:35:20 <statusfailed> argoneus: For network protocols, "attoparsec" is probably a suitable choice
05:35:23 <zachk> I actually have something, almost for this, except it wouldn't handle the ending message correctly 
05:35:25 <frerich> argoneus: E.g. the line '<message>  ::= [':' <prefix> <SPACE> ] <command> <params> <crlf> ' would become 'message = optional (char ':' >> prefix >> space) >> command >> params >> crlf' or so
05:35:25 <statusfailed> (of parser combinator)
05:36:33 <argoneus> hm
05:36:40 <argoneus> so parsec/attoparsec isn't overkill for this kind of thing then
05:36:47 <frerich> argoneus: Not at all
05:36:56 <argoneus> I've only ever done grammars on paper, it'll take me a while to figure this out
05:37:08 <argoneus> I'll look into it thanks
05:37:34 <exio4> frerich: well, considering that just _matches_ the IRC message.. but nearly :p
05:37:39 <exio4> more <$> <*>
05:37:45 <zachk> attoparsec is that simple?  what does it generate from that line? 
05:37:59 <frerich> exio4: Of course, but so does the BNF. :-)
05:38:10 <statusfailed> zachk: you construct a monadic term like "myParser :: Parser MyIRCType" 
05:38:24 <frerich> exio4: I didn't want to obscure the similarity between the Haskell program and the BNF with such mundane details ;-)
05:38:24 <statusfailed> and then you can run it on a string using a library function something like "String -> Parser Foo -> Maybe FOo"
05:38:28 <exio4> frerich: duh, sure :p 
05:38:35 <statusfailed> (I made up those types, but you get the gist)
05:39:08 * zachk hasn't even begun to fully wrap his head around parsers
05:39:32 <argoneus> do you think it would be a stupid idea to try and write my own parser combinator?
05:39:36 <argoneus> just a basic one to figure it out
05:39:51 <exio4> argoneus: it wouldn't be
05:39:57 <statusfailed> zachk: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
05:39:59 <frerich> argoneus: It wouldn't be stupid at all, in fact I'd very much recommend it because it's a lot of fun in Haskell and it makes you appreciate it a lot :-)
05:40:00 <merijn> argoneus: No, writing a (stupidly slow) parser combinator library is a pretty good way to understand what's going on
05:40:01 <exio4> argoneus: it's actually pretty common =)
05:40:11 <statusfailed> zachk: that's a really great tutorial
05:40:45 <maerwald> argoneus: https://www.seas.upenn.edu/~cis194/spring13/hw/10-applicative.pdf do that
05:40:54 <merijn> argoneus: Here's an example parser datatype you could start with "data Parser e a = Parser (String -> Either e (a, String))"
05:41:22 <merijn> argoneus: i.e. a function that takes a String and returns an error 'e' or a result 'a' and remaining String
05:43:23 <argoneus> oki
05:43:25 <argoneus> I'll read the tutorials
05:43:27 <argoneus> thanks <3
05:53:33 <frerich> argoneus: I very much recommend the book 'Programming in Haskell' by Graham Hutton, it builds a parser combinator library from scratch.
05:53:47 <frerich> argoneus: It's not a big book either.
05:54:04 <frerich> big? thick? long? I don't even sure how to call it...
05:54:12 <frerich> s/don't/am not/
05:57:02 <beepbeep_> frerich, I read that book and was stuck at parser chapter.
05:57:16 <beepbeep_> I felt that entire chapter was really .. weird
05:57:28 <beepbeep_> includes a bunch of code that doesn't work
05:57:56 <beepbeep_> and suddenly he's like "oh all this stuff that doesn't actually work. It's the same as the "do" syntax".
05:58:26 <frerich> beepbeep_: IIRC I repeated most of it myself and I cannot recall something not working.
05:58:51 <frerich> beepbeep_: Well yeah, he doesn't mix explaining monads with explaining parser combinators but joins the two topics lateron, which made sense to me.
05:59:14 <beepbeep_> mmm..
05:59:23 <beepbeep_> maybe because you already knew about monads?
05:59:38 <beepbeep_> that chapter really broke my brain :D
05:59:53 <beepbeep_> I'm actually reading haskellbook right now
06:00:00 <beepbeep_> so I can continue the "Programming in Haskell" book
06:02:56 <argoneus> so should I get that or prefer a different book?
06:03:18 <beepbeep_> argoneus, it's good .. I don't get the parser chapter but up until that chapter it was very good
06:03:23 <argoneus> I wish there was some recommended literature in the topic
06:03:51 <argoneus> beepbeep_: I just want to figure out how to write parsers/combinators
06:04:04 <beepbeep_> ah well
06:04:12 <beepbeep_> go for it :P
06:07:08 <argoneus> beepbeep_: didn't you just say that chapter is bad though?
06:07:11 <argoneus> and / or has broken examples
06:07:49 <beepbeep_> argoneus theres a chance I simply totally didn't get it
06:11:02 <maerwald> argoneus: did you open the link I gave you?
06:11:14 <argoneus> maerwald: yes
06:11:24 <argoneus> I was referring to the book frerich recommended
06:13:41 <zachk> that book by graham hutton is very nice
06:13:58 <zachk> was kinda pricey though for it's size, around $50 a few years ago
06:19:15 <haskell616> hi there! can someone explain to me why f is non strict in data X = X Integer; f::X ->Integer; f (X x) = 42 ?
06:19:50 <osa1> does anyone here have any experience with the gnuplot library? I can't find a way to color my lines, LineAttr doesn't seem to have colors: http://hackage.haskell.org/package/gnuplot-0.5.4/docs/Graphics-Gnuplot-Simple.html#t:LineAttr
06:19:53 <osa1> am I doing it wrong?
06:20:43 <lyxia> haskell616: it is strict but doesn't force the field of X.
06:22:09 <haskell616> it doesnt force X because on the right-hand side there is no use of X, am i right?
06:22:32 <lyxia> It does force the outer constructor because the clause matches on it
06:22:33 <srhb> haskell616: Do you mean force x?
06:23:28 <haskell616> yes i meant small x
06:25:06 <lyxia> then you are right
06:25:49 <haskell616> thank you!
06:27:00 <srhb> haskell616: Mind that the opposite is not necessarily true.
06:27:19 <srhb> haskell616: ie. let y = x in 42 -- still won't evaluate x
06:27:59 * hackagebot extra 1.4.3 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.4.3 (NeilMitchell)
06:33:01 * hackagebot hruby 0.3.2 - Embed a Ruby intepreter in your Haskell program !  https://hackage.haskell.org/package/hruby-0.3.2 (SimonMarechal)
06:35:36 <jnes> hello, does this not compile??? https://gist.github.com/sktt/23ae3a280afdfd8581dd
06:36:05 <tdammers> no, it doesn't
06:36:26 <tdammers> your definitions for that function have 2 and 3 arguments respectively
06:36:37 <tdammers> parenthesize the Just (b, c) part
06:36:57 <jnes> oh but why is it parsed as two arguments? Just (b, c)
06:37:09 <jnes> it should be tuple
06:37:13 <tdammers> no
06:37:20 <tdammers> a Just (a, b) is three arguments
06:37:26 <tdammers> a (Just (a, b)) is two arguments
06:37:53 <tdammers> as far as counting arguments goes, the parser doesn't care what the kind of each argument type is
06:38:10 <tdammers> foo bar baz always gets parsed as 3 arguments, even if bar is * -> *
06:38:30 <tdammers> if you want baz to bind to bar, you have to make it explicit as foo (bar baz)
06:38:54 <tdammers> the same pitfall applies to deconstructing list this way
06:39:32 <tdammers> > let f x:xs = x in f [a, b, c]
06:39:34 <lambdabot>  <hint>:1:5: Parse error in pattern: f
06:39:41 <jnes> understanding the order the compiler reads arguments is giving me so much headache -_- .. spending hours with composition parenthesis and dollar$ 
06:39:45 <tdammers> > let f (x:xs) = x in f [ a, b, c ]
06:39:47 <lambdabot>  a
06:40:24 <jnes> but thanks, many appreciations, tdammers 
06:40:28 <tdammers> it's not complex, it's just that the simple rules sometimes produce unexpected results
06:40:39 <tdammers> np
06:40:44 <argoneus> wait
06:40:48 <tdammers> btw., you can write that function more elegantly using fmap
06:40:50 <argoneus> Just is a valid value?
06:41:05 <tdammers> Just is a valid token here
06:41:13 <tdammers> it's also a function
06:41:17 <tdammers> :t Just
06:41:18 <lambdabot> a -> Maybe a
06:41:21 <tdammers> see?
06:41:29 <tdammers> > map Just [1,2,3]
06:41:31 <lambdabot>  [Just 1,Just 2,Just 3]
06:41:31 <exio4> @type let f Just = 42 in f
06:41:33 <lambdabot>     Constructor ‘Just’ should have 1 argument, but has been given none
06:41:33 <lambdabot>     In the pattern: Just
06:41:33 <lambdabot>     In an equation for ‘f’: f Just = 42
06:41:50 <exio4> tdammers: also, *->*? :P 
06:42:03 <exio4> tdammers: Just is a value, it's in *! :P 
06:42:05 <tdammers> wait, yeah, I was being confused between types and values here
06:42:11 <mniip> technically speaking the parser should always be able to infer the arity of a constructor
06:42:43 <tdammers> so basically s/kind/arity/, and s/* -> */unary/ or sth
06:42:46 <geekosaur> but the decision was made to parse patterns the same way as expressions
06:43:12 <tdammers> I believe things would be more confusing and less predictable if the parser were to respect arity
06:43:12 <geekosaur> and Just is a perfectly valid expression (e.g. map Just myList)
06:43:12 <exio4> tdammers: ∀α,β.α→β
06:45:43 <SoupEvil> how much is the output size of ghcjs a problem for mobile js engines, even if local like in a hybrid application?
06:50:17 <srhb> SoupEvil: Not very, in my experience.
06:50:29 <srhb> SoupEvil: It's the download, not the execution time.
06:51:36 <SoupEvil> srhb: thx, as I hoped, sounds great
07:33:02 * hackagebot haiji 0.1.0.0 - A typed template engine, subset of jinja2  https://hackage.haskell.org/package/haiji-0.1.0.0 (NoriyukiOhkawa)
07:34:41 <zennist> Is there a type already defined like Fix a = Fix (Fix a) ?
07:36:05 <phadej> zennist: that one is unhabitated
07:36:26 <phadej> zennist: but there is http://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html#t:Fix
07:36:28 <aweinstock> https://hackage.haskell.org/package/category-extras-0.52.3/docs/Control-Functor-Fix.html
07:36:30 <frerich> Just $ do it :: Maybe (Slogan Nike)
07:37:06 <aweinstock> :t do 42
07:37:08 <lambdabot> Num a => a
07:37:21 <aweinstock> :t do do do do do do ()
07:37:22 <lambdabot> ()
07:37:53 <argoneus> is there even a list of some "core" haskell datatypes?
07:38:19 <argoneus> like a string is a list of chars, so it's not required as core
07:38:21 <zennist> aweinstock: ah cool, thanks
07:38:33 <liste> argoneus https://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html maybe?
07:38:52 <liste> and Haskell Report has the 'official' ones
07:39:12 <srhb> argoneus: Or perhaps you're referring to primitives.
07:39:30 <liste> argoneus https://www.haskell.org/onlinereport/standard-prelude.html#sect8
07:41:32 <haskell819> why is my parallel merge sort so slow ? http://lpaste.net/148607 
07:41:36 <haskell819> 8x slower on 2 cores vs 1
07:41:46 <haskell819> 2 threads*
07:43:09 <osa1> so if I want to use a hacked version of some Hackage package, I can't do that with stack, right? does it have something like cabal's "add-source" ?
07:44:23 <arw> haskell819: because you have a very large overhead for all the threads you create. try to sort sublists smaller than maybe 10 elements without forking.
07:44:28 <liste> osa1 http://docs.haskellstack.org/en/stable/faq.html#i-need-to-use-a-package-or-version-of-a-package-that-is-not-available-on-hackage-what-should-i-do
07:46:28 <arw> haskell819: and generally, you will only see a speedup for sufficiently large lists, because for short ones the overhead in doing things in parallel is too large.
07:47:49 <osa1> liste: omg it worked. thanks.
07:48:34 <liste> osa1 yw (:
07:49:40 <arw> haskell819: usually, a far better approach than the recursive forking you are trying is to fork exactly once, sort each half in a single thread, then merge. 
07:50:15 <haskell338> arw: why don't i see any sparks in threadscope?
07:50:30 <arw> haskell819: your approach maximises the number of forks, but you really want to minimize them, they are cheap but not free by far.
07:50:51 <arw> haskell819: don't know?
07:50:52 <haskell338> arw: forks don't induce sparks?
07:51:00 <haskell338> okay
07:52:16 <osa1> friends, does anayone know how to show possible values in optparse-applicative arguments?
07:52:39 <osa1> I tried `complete` but that didn't make any effect on help msgs
07:52:51 <wolfik> Hi guys. Does using arrows in your application automaticly make it FRP?
07:53:22 <osa1> so, instead of metavar, I'd like to show something like `[foo|bar|yadayada]`
08:08:58 <arw> haskell338: after reading a bit through the code i'm not sure how many sparks you should see. Control.Monad.Par creates 2 threads (or whatever N is) and distributes the work via queues between those threads.
08:11:06 <zennist> how is type composition done? If I have a environment e.g., f (g a), how can I express f . g as a new f'?
08:11:16 <zennist> do I have to make a newtype ?
08:11:20 <arw> haskell338: as sparks are items in a workqueue, it could be that you would see them. but it could also be, that those workqueue items are separate from what threadscope shows you as sparks, i don't know.
08:12:09 <haskell338> arw: okay cool. thanks for all the help!
08:18:22 <lyxia> zennist: let f' = f . g -- define f' as f . g
08:18:55 <zennist> lyxia: I was talking about a type level composition, f , g are types e.g., Maybe
08:19:17 <zennist> seems to find what I want in Control.Compose
08:19:19 <lyxia> ah I didn't see "type" nvm
08:19:21 <quicksilver> zennist: yes
08:19:30 <quicksilver> you need a newtype and yes there is one there :)
08:21:28 <haskell338> arw: i tried doing mergesort in a different way (ie splitting into chunks, sorting independently, then merging) -> much better!
08:21:43 <haskell338> arw: i was just using a very ineffective approach
08:23:05 <arw> haskell338: yes. just try to sketch a tree of forks and joins in your original approach :)
08:37:29 <glittershark> is there a function or combination of functions in the stdlib that returns consecutive pairs in a list, ie `pairs [1,2,3,4,5] == [(1,2),(2,3),(3,4),(4,5)]`
08:38:40 <glittershark> ?
08:39:04 <kadoban> > zip [1..5] (tail [1..5])
08:39:06 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
08:39:12 <kadoban> That's an option
08:39:13 <glittershark> I mean
08:39:21 <glittershark> I want to parametrize it
08:39:25 <glittershark> but yes
08:39:42 <puregreen> pairs = ap zip tail
08:39:44 <glittershark> @pl \xs -> zip xs (tail xs)
08:39:44 <lambdabot> ap zip tail
08:39:55 <kadoban> @quote zip`ap`tail
08:39:56 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
08:40:10 <kadoban> I don't think I'd actualy seriously use that one though, but it depends on your style.
08:40:40 <quicksilver> quite often you don't actually want the list of pairs
08:40:44 <glittershark> :t ap
08:40:45 <quicksilver> you just want to do something with it
08:40:46 <lambdabot> Monad m => m (a -> b) -> m a -> m b
08:40:47 <quicksilver> so you do
08:40:48 <puregreen> “zip <$> id <*> tail” is somewhat more understandable but still meh
08:41:05 <quicksilver> zipWith(foo`ap`tail)
08:41:10 <quicksilver> erm
08:41:17 <quicksilver> (zipWith foo)`ap`tail
08:41:32 <glittershark> :t (<*>)
08:41:33 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:41:53 <glittershark> thought that signature looked familiar
08:42:08 <glittershark> yeah actually I'm doing a `forM` over this list
08:42:16 <glittershark> well, `forM_`
08:43:50 <aweinstock> :t forM_ . (zip`ap`tail)
08:43:51 <lambdabot> Monad m => [a] -> ((a, a) -> m b) -> m ()
08:44:19 <glittershark> christ
08:44:37 <glittershark> I never cease to be amazed at the power of randos on #haskell to write obscenely concise code
08:44:42 <Nadrieril> :t ap
08:44:43 <lambdabot> Monad m => m (a -> b) -> m a -> m b
08:45:28 <kadoban> Haha, ((->) r) is really good for amusing/confusing code golf
08:45:50 <quicksilver> yes, it is the monad for using things twice
08:45:56 <quicksilver> at least in code golf it is
08:45:59 <Nadrieril> indeed
08:46:02 <Nadrieril> nice
08:46:11 <quicksilver> @pl \x -> f x + g x
08:46:12 <lambdabot> liftM2 (+) f g
08:46:16 <quicksilver> another example.
08:46:29 <aweinstock> :t on
08:46:31 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
08:46:51 <aweinstock> @src on
08:46:51 <lambdabot> (*) `on` f = \x y -> f x * f y
08:47:38 <cocreature> is there a nice way to suppress unused warnings for specific type synonyms?
08:47:48 <kadoban> That's kinda funny, it's like…   liftA2 (flip ($))
08:47:58 <aweinstock> @do liftA2 (>>) f g
08:47:58 <lambdabot> liftA2 (>>) f g
08:48:00 <cocreature> they are generated by a lib (singletons) using template haskell but I don’t need them
08:48:26 <kadoban> Oh except not at all.
08:49:02 <bevolumee> https://soundcloud.com/bevolume/bevolume-positive-dreams   Listen and  Enyoj my music !!!
08:49:31 <Zekka|Sigfig> bevolumee: Whoa! Tkanhs for the link !!!
08:49:42 <Zekka|Sigfig> Is it made with Haskell?
08:50:45 <wedens> opaleye question: can I have different read and write types? (not just column types)
08:57:32 <quicksilver> @pl \f x y -> f x * f y
08:57:32 <lambdabot> flip =<< (((.) . (*)) .)
08:57:38 <quicksilver> obviously.
08:57:43 <Nadrieril> x)
08:57:58 <kadoban> XD
08:58:21 <glittershark> I swear there's gotta be an arrow-ey way to do that
08:58:31 <glittershark> with some `uncurry` magic
08:58:33 <Zekka|Sigfig> quicksilver: You forgot something!
08:58:43 <Zekka|Sigfig> @pl \g f x y -> g (f x) (f y)
08:58:43 <lambdabot> join . ((flip . ((.) .)) .) . (.)
08:58:48 <Zekka|Sigfig> I think that’s much clearer
08:58:52 <Nadrieril> I agree
08:59:04 <cluzz> Needs more dots
08:59:04 <glittershark> hoo boy
08:59:12 <Nadrieril> moar dots
08:59:26 <cluzz> -50DKP for you
08:59:35 <glguy> ?src on
08:59:35 <lambdabot> (*) `on` f = \x y -> f x * f y
08:59:55 <glguy> Oh, aweinstock did that earlier
09:00:53 <Nadrieril> we just learned that point-free actually means dot-full
09:02:01 <narendraj9> And that's not pointless. 
09:02:04 <narendraj9> :-D
09:02:04 <cluzz> My uni professor made a joke about that. In dutch `point' and `dot' have the same word, for the extra confusion
09:03:12 <kadoban> cluzz: Nice
09:03:54 <Nadrieril> same in French
09:04:38 <statusfailed> hmmmm. can Trifecta parse "Text"? I only see parseString and parseByteString functions
09:04:58 <bartavelle> statusfailed, no the function is missing
09:05:11 <statusfailed> oh
09:05:15 <puregreen> where's that nice chart of packages shipped with various versions of GHC?
09:05:48 <narendraj9> Nadrieril: I convinced myself about this by saying to myself: In mathematics, we represent a point in the domain of a function on the x-axis and compute the value of the expression that defines the function for the point on x-axis to get a point on y-axis and then (x,y) gives you a point that lies on the graph of the function. Doing this, we are actually not thinking about the function as a computational
09:05:50 <narendraj9> idea in itself but are only doing evaluation of an expression that defines how to carry out that computation. But if you try to explain the idea of that function to someone more informally, you may say that it's just the log of a square without mentioning the whole process of the computation of the result from a point on the x-axis. So, when using the point-free style, you are give the computation an
09:05:52 <narendraj9> explanation. :-)
09:06:56 <Nadrieril> oooh :)
09:07:02 <kaiyin> why am i getting this error? https://gist.github.com/kindlychung/8ab0a738482eecaa583b
09:07:12 <Nadrieril> very nide narendraj9 ^^
09:07:44 <lyxia> kaiyin: the signature says push returns an Int, and you returned a unit
09:09:06 <bartavelle> kaiyin, also you could use "modify" instead of state for the push case
09:09:27 <argoneus> I just found in my pdfs I have Real World Haskell, is that worth reading?
09:09:35 <argoneus> it's 700 pages so should probably know beforehand
09:09:44 <glittershark> argoneus: it's an excellent reference
09:09:55 <glittershark> argoneus: and almost definitely worth skimming, maybe not *studying*
09:10:16 <argoneus> so I just look at parts that I want to work with
09:14:14 <kaiyin> lyxia: bartavelle: thanks.
09:14:41 <kaiyin> how can i convert this to the pointed style? https://gist.github.com/kindlychung/ab2ad8ceffccac764f8f#file-stack-hs-L14-L17
09:16:07 <bartavelle> what is "pointed style" ? Google seems to think it's a synonym to gothic
09:16:15 <kadoban> kaiyin: It already is? You mean point-free?
09:16:43 <Zekka|Sigfig> There’s no arguments involved, are there?
09:17:12 <Zekka|Sigfig> There is a hidden lambda on line 16, but the lambda isn’t important
09:18:13 * hackagebot unexceptionalio 0.3.0 - IO without any non-error, synchronous exceptions  https://hackage.haskell.org/package/unexceptionalio-0.3.0 (StephenWeber)
09:18:26 <kaiyin> I mean the form with args (opposite of pointfree). 
09:19:01 <kadoban> There already are args.
09:19:18 <kadoban> kaiyin: Do you mean without State ?
09:19:20 <bartavelle> or perhaps you mean unrolling without the state monad ?
09:19:30 <bartavelle> err what kadoban said, my sentence doesn't make sense
09:19:34 <Zekka|Sigfig> You could write it as just a plain function that has the State constructor in front of it
09:19:38 <Zekka|Sigfig> @src State
09:19:39 <lambdabot> Source not found. Just try something else.
09:20:04 <Zekka|Sigfig> darn! I can’t remember if it’s State s a = State (s -> (a, s)) or State s a = State (s -> (s, a))
09:20:12 <Zekka|Sigfig> But I suspect it’s the first one
09:20:14 <kaiyin> @src state
09:20:14 <lambdabot> Source not found. There are some things that I just don't know.
09:20:25 <puregreen> @src StateT
09:20:25 <lambdabot> Source not found. My brain just exploded
09:20:29 <puregreen> hm
09:20:30 <Nadrieril> x)
09:20:31 <argoneus> @src Bool
09:20:31 <lambdabot> data Bool = False | True deriving (Eq, Ord)
09:20:36 <geekosaur> @unmtl State s a
09:20:37 <lambdabot> s -> (a, s)
09:20:38 <argoneus> ...Ord?
09:20:44 <argoneus> why does bool derive ord
09:20:51 <quchen> > True < False
09:20:53 <lambdabot>  False
09:20:53 <kadoban> argoneus: Why not?
09:20:55 <Zekka|Sigfig> It looks like that’s how you wrote e.g. pop 
09:21:02 <Zekka|Sigfig> geekosaur: Thank you!
09:21:15 <argoneus> so "true" is stronger than "false"
09:21:16 <Nadrieril> wtf is that command
09:21:17 <argoneus> mmh
09:21:29 <quchen> a `implies` b = a <= b    :-)
09:21:31 <Zekka|Sigfig> argoneus: Yeah, although it also enables you to do some nice stuff like using ‘sort’ to group the list
09:21:44 <platz> how do i avoid this warning when static linking? http://lpaste.net/148611
09:21:46 <Zekka|Sigfig> > sort [False, True, False, True, False, False, True]
09:21:48 <lambdabot>  [False,False,False,False,True,True,True]
09:21:51 <Taneb> quchen: that works out to be amusingly backwards
09:22:12 <quchen> a `xor` b = a /= b
09:22:14 <kadoban> argoneus: In particular, Ord is useful for stuff like using as a key in a Data.Map. A Map with Bool as a key would be a bit weird, but a Map with a type built up of several things, one of which is Bool, wouldn't be. If Bool wasn't an instance of Ord, that'd be annoying.
09:22:28 <Zekka|Sigfig> I don’t know what the sorting characteristics of Haskell’s algorithm are for lists with a lot of duplicate values (iirc it’s mergesort, so not that great), but it’s O(log n) instead of O(n^2)w hich is what you get if all you assume is Eq
09:22:34 <statusfailed> hm, where do you get a Trifecta "Delta" from to use with "parseString"? 
09:22:35 <argoneus> I see
09:23:02 <quchen> Complexity of Data.Sort doesn't matter, because we don't have arbitrarily sized lists in practice.
09:23:04 <bartavelle> Zekka|Sigfig, well you can't really "sort" with just Eq, just "group" ;)
09:23:20 <Zekka|Sigfig> bartavelle: Yeah, I’m talking about sort as a grouping operation, not sort as a sorting operation
09:23:23 <quchen> It could be O(n!) for all I care if it was fast enough.
09:23:26 <geekosaur> platz: you don't, on a system with glibc
09:23:38 <geekosaur> glibc *really* wants to be linked dynamically
09:23:42 <merijn> statusfailed: See the DeltaParsing class in Trifecta.Combinators
09:23:56 <Zekka|Sigfig> quchen: You don’t have arbitrarily-sized lists in practice, but it’s not unusual to have a list containing as many as 100000 elements
09:24:09 <quchen> Zekka|Sigfig: Still has nothing to do with complexity.
09:24:11 <statusfailed> merijn: ah, thanks!
09:24:21 <Zekka|Sigfig> And at that scale asymptotic complexity does matter — although since almost all seriously-used sorts are O(n log n), constant factors are typically more important
09:24:48 <quchen> If you have a list of length 100000 in practice and you want to sort it, it's probably time to reevaluate whether a singly linked list is a good data structure.
09:24:57 <Zekka|Sigfig> Between O(n^2) and O(n log n) assuming constant factor difference < 10, you’re looking at a difference of about ~1000
09:25:27 <platz> geekosaur: does this mean as long as glibc is available dynamically, i can safely ignore the warning?
09:25:28 <quchen> Sorting lists that fit in our universe is O(1). Complexity is completely useless "in practice".
09:25:31 <ReinH> statusfailed: if you don't need a specific delta, use mempty
09:25:56 <argoneus> quchen: and so PHP was born
09:26:05 <quchen> Turing completeness also falls into this "useless" region, but somehow everyone talks about it all the time.
09:26:15 <kadoban> quchen: … so the entire field of algorithm analysis is useless?
09:26:26 <quchen> No, why would you say that?
09:26:35 <statusfailed> ReinH: ah, thanks :-)
09:26:45 <argoneus> quchen: so bubblesort is completely valid in the real world?
09:26:45 <geekosaur> platz: only if it's the same version. I think if you want to make ghc link static versions of haskell libraries, you just use ghc -static; if you want to link foreign libs statically except for libc, that's harder (linux kinda doesn't want you to do that)
09:26:56 <quchen> argoneus: No, it's slow.
09:27:02 <argoneus> what do you mean slow?
09:27:03 <kadoban> quchen: Well, what tool do you use for abstracting away the confusing details of the cost of algorithms, if not asymptotic analysis?
09:27:22 <argoneus> "sorting lists that fit in our universe is O(1)"
09:27:28 <argoneus> so bubblesort in the real world is O(1)
09:27:30 <argoneus> quoting you
09:27:31 <ReinH> argoneus: so?
09:27:31 <argoneus> no?
09:27:40 <argoneus> O(1) is pretty fast
09:27:43 <quchen> argoneus: You're not quoting me by putting wrong facts in my mouth.
09:27:43 <mniip> no
09:27:44 <platz> geekosaur: many thanks
09:27:45 <ReinH> No
09:27:46 <geekosaur> I think you might need to specify the *.a files explicitly instead of using -llib
09:27:50 <Zekka|Sigfig> Well, O(1) is not necessarily fast or slow
09:27:51 <quchen> No, O(1) is not fast.
09:27:54 <mniip> O(f(n)) tells us nothing about speed
09:28:04 <quchen> O(1) says something about scaling, not about how fast something is.
09:28:16 <argoneus> yeah
09:28:19 <argoneus> try bubblesort with 2 items
09:28:21 <mniip> it only tells us how 2 algorithms compare at an infinitely large input
09:28:22 <ReinH> constant factors can't be ignored in the real world
09:28:22 <quchen> Breaking AES-256 by brute force is O(1), but it's hardly fast.
09:28:22 <argoneus> and bubblesort with 500 items
09:28:25 <argoneus> look at that scaling))
09:29:01 <glittershark> take all this and add things like cache-adjacency and branch prediction
09:29:04 <quchen> O(1) also doesn't say "scaling", it says "something about scaling", namely that at some unspecified point there's an upper bound.
09:29:17 <Zekka|Sigfig> What quchen’s saying afaict is that the asymptotic complexity of *sorting* doesn’t usually matter because sorting usually doesn’t make sense for non-small datasets
09:29:27 <quchen> Sure it does.
09:29:39 <Nadrieril> he is only trolling
09:29:45 <bartavelle> this is just pedantic time
09:29:50 <Nadrieril> he as a valid point though
09:29:56 <quchen> I'm correcting you because what you say about complexity is wrong.
09:29:57 <Nadrieril> +1 bartavelle
09:30:08 <Nadrieril> quchen: you could have phrased it that way
09:30:16 <mniip> not really no
09:30:18 <mniip> that's completely wrong
09:30:23 <Zekka|Sigfig> quchen: What did I say about complexity that’s wrong?
09:30:36 <argoneus> all you can say is that you can't tell if O(n^2) or O(n) is faster, because you don't know the constants or the size... but assuming similar space complexity, why would you use O(n^2)?
09:30:46 <argoneus> shrug
09:31:20 <johnw> 'Complexity is completely useless "in practice".'  wut?
09:31:21 <ReinH> because it's faster
09:31:22 <Zekka|Sigfig> I don’t think it’s true under your assumption, which seems to be that there’s a maximum data set size where an explicit sorting step makes sense
09:31:25 <ReinH> that's why I would use it
09:31:28 <kadoban> quchen: I'm still curious about my question above, if you have a chance.
09:31:40 <Zekka|Sigfig> argoneus: A lot of sorting algorithms use insertion sort at a certain dataset size because it’s faster
09:31:40 <puregreen> to be honest, it's actually kinda disappointing to see quchen provoking people like that when a while ago ne said “[...] Some questions require a certain degree of empathy to answer well.”
09:31:54 <quchen> kadoban: Let me find it.
09:31:57 <bartavelle> haha
09:31:59 <kadoban> quchen: Well, what tool do you use for abstracting away the confusing details of the cost of algorithms, if not asymptotic analysis?
09:32:11 <argoneus> Zekka|Sigfig: as I said, it depends on the constants and the sample size
09:32:16 <Zekka|Sigfig> e.g. you have mergesort variants which will partition your dataset until it’s ~8 elements in size, then do insertion sort because in testing, due to characteristics of the hardware, that’s apparently faster
09:32:40 <argoneus> tbh it's 2016 and people tell you to buy a faster cpu instead
09:32:41 <ReinH> argoneus: yes, and then you said "why would you use O(n^2)?"
09:32:43 <bartavelle> it should be written in the topic that one should not use O notation, because it spawns this argument
09:32:44 <Zekka|Sigfig> On arbitrarily large data sets, which you’re not always using, I don’t think there’s a justification for using O(n^2)
09:33:02 <johnw> bartavelle: this argument is O(n), where n is the number of participants
09:33:10 <bartavelle> johnw, :)
09:33:12 <Zekka|Sigfig> (beyond the pedantic point that all O(n log n) algorithms are technically O(n^2) because I’m too lazy to use the also-pedantically wrong Theta(n^2))
09:33:15 <sbrg> it grows O(2^n)
09:33:18 <sbrg> the argument
09:33:33 <quchen> kadoban: When we say "complexity" it's using a very precisely defined mathematical term. When we want to talk about scaling in practice, we should not use such terms lightly. "This thing scales quadratically in that region" is a much better thing to say: it talks about a fit of a function to the measured performance of something.
09:34:02 <argoneus> side question: how do engines like postgres order by in a dataset of a million?
09:34:05 <quchen> kadoban: Saying "it's O(n^2)" means that there's some n such that for all N>n there is a constant so that yadda yadda.
09:34:09 <argoneus> is that some pre-calculated magic
09:34:17 <quchen> I don't think that's very helpful when evaluating the speed of an algorithm.
09:34:31 <puregreen> johnw: this argument is O(1), with the constant of “about 2 hours before channel mods start kicking people”
09:34:33 <geekosaur> usually you add indexes on fields that you know will be ordered or searched a lot
09:34:38 <bartavelle> argoneus, depends on the details, and especially if you already have an index on the thing you are sorting
09:34:50 <Zekka|Sigfig> quchen: Well, part of this is a language thing, I think: people who talk about time complexity with sorting algorithms are talking about time complexity as it applies to them
09:35:10 <ggVGc> quick, what's the time complexity of GHC's optimization step
09:35:13 <Zekka|Sigfig> most sorting algorithms scale in a pretty predictable way because they either divide-and-conquer the input dataset or they compare every element to every other element
09:35:19 <bartavelle> argoneus, but there are specialized algorithms for when you can't have all the data in "fast storage" (ie. RAM) at the same time
09:35:32 <sbrg> quchen: surely if you measured the time complexity of the other algorithm in the same context, then you have 'concrete approximations' for the scaling of the algorithms, which basically tells you about the speed. 
09:35:37 <Freundlich> quchen: Although you are right about the mathematics, the O-notation is actually used like that, even in a lot of papers.
09:35:41 <Zekka|Sigfig> It’s a pretty easy case of time complexity and it lends itself to calculating difference in time pretty easily
09:35:42 <kadoban> quchen: Yeah I'm pretty familiar with what big-O means technically. Part of that is simply that … what you seem to be saying, there isn't really notation for (is there?)
09:35:59 <Freundlich> quchen: I don't like it much either but that's the reality.
09:36:21 <quchen> kadoban: Well, we can handwavily talk about scaling behaviour.
09:36:22 <glittershark> there are too many variables for there to be unified notation for how fast something runs
09:36:34 <Zekka|Sigfig> The constant factor differences are going to be non-negligible for small data sets, but they’re still not too bad — the most difference in performance I’ve ever seen from Stupid Hardware Problems like cache friendliness and branch prediction is about 8x, which is still smaller than the non-constant factor
09:36:47 <quchen> Using big-O to mean "the graph looks like" is pretty strange.
09:37:04 <sbrg> kadoban: Well, you can do complexity analysis on more 'fine-grained' operations. Like when dealing with distributed algorithms, then the algorithmic complexity of the algorithm is useless if you do not also look at the time complexity of the communication operations
09:37:14 <sbrg> because it's such a vital part to designing an efficient algorithm *in that context*
09:37:26 <Zekka|Sigfig> And bear in mind that I certainly wasn’t using big-O as my only instrument — I explicitly brought up that merge sort is not particularly performant for data sets containing large numbers of duplicates!
09:37:52 <Zekka|Sigfig> (it’s not particularly slow either, of course)
09:37:59 <glittershark> wow lol this whole discussion started with "why does Bool instantiate Ord"
09:38:14 <ReinH> Which I already answered on stackoverflow
09:38:16 <Zekka|Sigfig> Yeah, and then I just had to bring up sorting as a grouping operation
09:38:16 <kadoban> sbrg: Indeed. I'd strongly agree that asymptotic analysis isn't the *only* tool that should be used. But it does seem like a useful tool to me.
09:38:23 <jetpacmonkey> you know, I was wondering what this had to do with haskell
09:38:43 <sbrg> the only question that remains is: who's going to be the first one to mention hitler? Godwin's law, etc.
09:38:47 <sbrg> oops.
09:39:00 <sbrg> Complexity analysis is literally Hitler.
09:39:15 <ReinH> In fact if one googled "haskell bool ord", my answer will be on the first page.
09:39:29 <ReinH> (Well, probably, different people get different results)
09:39:37 <jetpacmonkey> Hitler's favorite sorting algorithm is clearly Sleep Sort
09:39:40 <kadoban> quchen: Well, it does kind of mean that though (the graph, if you zoom out enough, is bounded above by something that looks like …)
09:39:42 <sbrg> ouch
09:39:43 <ReinH> I really feel like googling for things is an underutilized skill
09:40:09 <glittershark> @remember sbrg Complexity analysis is literally Hitler.
09:40:10 <lambdabot> I will remember.
09:40:10 <platz> big-O notation gives only an asymptotic upper bound, and not an asymptotically tight bound
09:40:12 <kadoban> quchen: But yeah I think you have a point that I mostly agree with to at least some extent. Thanks for answering.
09:40:32 <johnw> kadoban: can you summarize the point?
09:41:06 <glittershark> @quote sbrg
09:41:06 <lambdabot> sbrg says: Complexity analysis is literally Hitler.
09:41:21 <glittershark> there, a summary
09:41:27 <kadoban> johnw: That big-O is sometimes too theoretically murky when used to describe problems that are by nature bounded in size ?
09:41:51 <aweinstock> @quote complexity analysis
09:41:52 <lambdabot> No quotes for this person. And you call yourself a Rocket Scientist!
09:43:05 <jetpacmonkey> I vote for XKCD's StackSort
09:43:14 * hackagebot HXQ 0.20.0 - A Compiler from XQuery to Haskell  https://hackage.haskell.org/package/HXQ-0.20.0 (LeonidasFegaras)
09:43:20 <quchen> johnw: Complexity says that "somewhere out there" some law holds, without saying much more. It doesn't say "this is fast".
09:43:31 <aweinstock> jetpacmonkey: but that would involve IO
09:43:34 <Zekka|Sigfig> quchen: It says a whole lot more though when you know what you’re talking about are sorts
09:44:03 <Zekka|Sigfig> IMHO “O(n log n) sort” and “O(n^2) sort” are names for kinds of algorithm whose performance is pretty well-understood
09:44:34 <jetpacmonkey> aweinstock: oh right, we talk about Haskell in here
09:44:45 <johnw> quchen: I use complexity analysis to weigh two algorithms in terms of known constraints; is that bad?
09:44:47 <platz> it's effective when talking about divide and conquer algorithms, yeah. https://en.wikipedia.org/wiki/Master_theorem
09:44:49 <Zekka|Sigfig> you could call them “divide-and-conquer sorts” and “compare-all-to-all sorts” if you wanted to
09:45:42 <Zekka|Sigfig> (with an honorable mention for QuickSort which is nominally the first, but sometimes does it so badly it turns out to be the second)
09:46:09 <bartavelle> johnw, it's ok as long as you don't say that on #haskell ;)
09:46:22 <kadoban> heapsort isn't a divide-and-conquer or compare-all-to-all
09:46:23 <aweinstock> jetpacmonkey: implementing XKCD's stacksort is a security vulnerability in any language; Haskell just makes it slightly more obvious
09:46:37 <quchen> johnw: Half the world does, so it's probably not bad. But it may be a misuse of the term "complexity".
09:46:43 <Zekka|Sigfig> kadoban: Isn’t heapsort about building a balanced tree?
09:46:56 <Zekka|Sigfig> Genuine question, I don’t remember the details of how it works
09:47:05 <kadoban> Zekka|Sigfig: A specialized balanced tree, but yes.
09:47:06 <quchen> Heapsort is about building a heap ;-)
09:47:10 <jetpacmonkey> aweinstock: wait, I can't tell anymore. Are we having a serious discussion here?
09:47:45 <aweinstock> heapsort builds up a balanced binary heap, and then pops all the elements in sorted order
09:47:51 <Zekka|Sigfig> That’s what I thought it did!
09:48:01 <quchen> Zekka|Sigfig: Heaps are fairly interesting, and if you want to read something really nice look up skew-binary heaps. It's what's the basis of the heaps package.
09:48:10 <Zekka|Sigfig> I always thought of “build a balanced x” as a kind of divide and conquer, but maybe that’s a poor intuition.
09:48:13 <aweinstock> jetpacmonkey: I'm not sure either, I think I'm being kind of serious?
09:48:28 <Zekka|Sigfig> I use nonserious language but I’d say I’m being fairly serious
09:48:38 <aweinstock> StackSort is the joke sort involving running arbitrary code from the internet until the input is sorted, right?
09:48:48 <jetpacmonkey> yup
09:49:00 <johnw> quchen: so, are you saying that basically everything said on the first page of http://discrete.gr/complexity/ is wrong?
09:49:11 <glittershark> just do it with unsafePerformIO and you're fine
09:49:16 <glittershark> StackSort, that is
09:49:30 <aweinstock> it's a joke algorithm, but it's seriously a security vulnerability (arbitrary code from the internet), and in haskell, you'd need either IO or unsafePerformIO to access the internet
09:49:31 <johnw> quchen: I guess I'm still not seeing the point you're trying to make
09:49:35 <glittershark> {-# NOINLINE stupidJokes #-}
09:49:58 <jetpacmonkey> I... of course it's not a good idea to run... what are we even *talking* about here?
09:50:20 <aweinstock> haskell!!!
09:50:27 <quchen> johnw: I can't read it thaaat fast, but it doesn't look wrong.
09:50:30 <jetpacmonkey> I keep on forgetting
09:50:53 <johnw> quchen: even where he calls it totally practical and useful for measuring how fast algorithms are?
09:50:58 <quchen> johnw: Nevermind, it mentions PHP. It's *evil*.
09:51:34 <sbrg> jetpacmonkey: .. what he wrote down, the whole crowd goes so loud 
09:51:35 <quchen> johnw: That sounds pretty wrong indeed.
09:51:40 <kadoban> Zekka|Sigfig: Well, divide-and-conquer means "solve a smaller instance of the problem (or several smaller instances) and then combine those answers into an answer for the big one". There's a divide-and-conquer solution to building a heap I guess, for some heap implementations at least, but I don't really consider that part of heapsort's specification. heapsort is like … selection sort, except you use a better data structure than an unsorted list.
09:51:43 <sbrg> he opens his mouth, but the words don't come out
09:51:52 <jetpacmonkey> sbrg: Mom's spaghetti?
09:51:57 <jetpacmonkey> I know how to internet
09:51:58 <quchen> johnw: Unless "complexity" means "I measured it and fit a function to it" in the article.
09:52:02 <sbrg> it's in there somewhere
09:52:04 <quchen> johnw: Then he's shadowing the name ;-)
09:52:18 <Zekka|Sigfig> kadoban: I think I should be using a more general world than “divide-and-conquer” because I think my characterization of O(n log n) sorts still applies even though it sounds like this isn’t divide-and-conquer in spirit
09:52:44 <Zekka|Sigfig> Of course, my gut’s telling me it might be making very similar comparisons to a divide-and-conquer algorithm, but in a different order! (kind of like how iirc QuickSort makes the same group of comparisons it would take to build a BST)
09:53:08 <Zekka|Sigfig> But you shouldn’t trust me, I’m not an algorithms expert
09:53:18 <kadoban> I'd say *many* Θ(n lg n) algorithms come from divide-and-conquer, just because that's the solution to T(n) = 2T(n/2) + Θ(n) , but they don't *all* come from that.
09:53:33 <platz> it's not so much about divide-and-conquer but the relation between recursion and the function's recurrence relation
09:53:36 <ReinH> quchen: I do think it's interesting that this coloquial but technically incorrect use of O-notation has become so ubiquitous.
09:53:39 <quchen> johnw: My point is that claiming "this is O(n*log(n))" tells me nothing about whether I should use an algorithm. Knowing for example that the time it takes looks like c*n*log(n) even for small n with a small constant c is fairly useful, and that's what people usually mean when they say "it's O(n*log(n))".
09:53:52 <kadoban> You can very well just do n operations, each of which takes Θ(lg n) time
09:54:02 <quchen> ReinH: Probably for the lack of a good notation for the actual thing.
09:54:32 <ReinH> quchen: if I continue to say "asymptotic complexity", am I in the clear? ;)
09:54:48 <Zekka|Sigfig> kadoban: I think “divide-and-conquer” is probably the wrong word, although I’m tempted to say that the ’log n’ usually comes from successively partitioning your dataset, even if you haven’t done it yet!
09:54:53 <quchen> ReinH: :-D
09:55:04 <Zekka|Sigfig> that’s no longer talking about algorithmic steps, that’s talking about the nuance of why your algorithm works
09:55:32 <Zekka|Sigfig> That’s not really true for a heap, though, is it?
09:55:36 <ReinH> Zekka|Sigfig: the most common way of achieving log n is surely with a binary tree of some sort
09:55:52 <kadoban> Zekka|Sigfig: I don't think so, if I understand you correctly.
09:55:55 <johnw> quchen: do you have links to any articles that would clarify this debate?
09:56:12 <glittershark> so last weekend my project was some Vim bindings to the HaRe haskell refactoring tool, if there are any vimmers here: https://github.com/glittershark/vim-hare
09:56:27 <glittershark> totally unrelated but there's never a bad time for self-promotion
09:56:30 <ReinH> kadoban: how is the heap structured?
09:56:37 <ReinH> could it be with a binary tree?
09:56:56 <Zekka|Sigfig> ReinH: Well, a binary tree is a data structure of course — but you can have binary tree-like structure without having the data structure
09:57:01 <Zekka|Sigfig> I’ve got to go to a meeting, but I’ll kvetch later
09:57:06 <ReinH> Zekka|Sigfig: a binary tree is a shape
09:57:10 <ReinH> computation can have that shape
09:57:12 <kadoban> ReinH: Yes, it's usually (always?) a binary tree. If I disagreed with that, I didn't mean to.
09:57:17 <aweinstock> Zekka|Sigfig: in which case the binary tree is implicit in the call graph?
09:57:18 <Zekka|Sigfig> ReinH: OK, sure — we’re on the same page
09:57:28 <ReinH> kadoban: no, I'm just pointing out how it comports with what I said :)
09:57:33 <kadoban> Ah
09:58:00 <Zekka|Sigfig> In this case I think the shape that most of these sorts are using is like this: whether the division into halves is arbitrary (heapsort, if I remember it right) or predefined (BST-sort), the intermediate structure is designed around successively placing each element into a half and saying “you don’t need to be directly compared to the other half"
09:58:26 <Zekka|Sigfig> Which afaik is dataset partitioning even if you don’t have an algorithmic stage dedicated to partitioning the data set (like you do in e.g. sorts where you build a BST first)
09:58:33 <Zekka|Sigfig> I’ll be back in like 15 minutes to find out what I didn’t think of
10:00:00 <zubair> gfl
10:02:11 <quchen> johnw: The mathematical (and pretty far from programming) definition is under "landau symbols" on Wikipedia, I think. It's this "g(n) in O(f(n)) is when there's an N such that for all n>N there is a constant …" business. I think CLRS ("introduction to algorithms") had a few nice pictures about what O, ϑ and Ω mean, if you have that book around.
10:02:39 <johnw> I traded my CLRS for a copy of the dragon book in 1998
10:02:56 <quchen> CLRS calls it "asymptotic notation".
10:03:16 <ReinH> johnw: I guess that's why you're had a career writing compilers instead of algorithms...
10:03:31 <ReinH> *you've
10:03:37 <johnw> that Wikipedia page says: "In computer science, big O notation is used to classify algorithms by how they respond (e.g., in their processing time or working space requirements) to changes in input size."
10:03:48 <johnw> which describes exactly what I mentioned above about comparing algorithms
10:04:08 <quchen> CLRS: "We sometimes find it convenient, however, to abuse asymptotic notation in a variety of ways. For example, we might extend the notation to the domain of real numbers or, alternatively, restrict it to a subset of the natural numbers. We should make sure, however, to understand the precise meaning of the notation so that when we abuse, we do not misuse it. This section defines the basic asymptotic notations and also introduces
10:04:08 <quchen>  some common abuses."
10:04:34 <platz> it is not incorrect to say that quicksort is O(948^n^n)
10:05:03 <platz> i.e. any upper bound suffices
10:05:04 <kadoban> quchen: What point did you hope to make by quoting that section?
10:05:25 <sbrg> sure, you can abuse it and be handwavy. what abuse are you referring to specifically?
10:05:26 <platz> not the least upper bound
10:05:26 <kadoban> platz: Indeed, though many people use O() to mean Θ(), which is … annoyingly confusing.
10:05:46 <ReinH> I
10:05:53 <sbrg> You.
10:06:02 <quchen> I don't even have a \vartheta here :-(
10:06:08 <ReinH> I'm trying to imagine a univere where someone was corrected every time they used O-notation in the way that has become common-place.
10:06:37 <ReinH> I guess we'd find a new term to mean the same thing pretty quickly
10:06:57 <Jinxit> is it not just an upper bound?
10:07:05 <johnw> so, we have O-notation, and QuchenO-notation.  works for me
10:07:06 <sbrg> maybe I should develop the habit of demanding that every time someone uses O-notation, I demand that it be in a reference frame where they take into the account the movement of subatomic particles and the energy costs involved
10:07:12 <ReinH> hmm, commonplace doesn't need hyphenation.
10:07:20 <kadoban> Jinxit: It depends who you learned from, and how correctly you learned.
10:08:38 <quchen> ReinH: It helps if you imagine Dr. Evil making the quote gesture every time some says "O(something)".
10:08:45 <quchen> ;-}
10:12:10 <ReinH> quchen: lol
10:12:37 <ReinH> All I wanted was sharks with O(n) lazer beams attached to their heads
10:12:52 <johnw> where n is the number of sharks, or the number of lazers?
10:13:05 <ReinH> But my cycloptic colleague here informs me that that can't be done
10:13:07 <johnw> and remember, we're in a world with a finite number of sharks
10:13:15 * hackagebot hpygments 0.2.0 - Highlight source code using Pygments  https://hackage.haskell.org/package/hpygments-0.2.0 (DavidLazar)
10:13:21 <quchen> 1 is O(n) so you get one laser.
10:13:33 <quchen> Enjoy.
10:13:56 <ReinH> That's not... I don't think... I have decided not to pursue this line of inquiry.
10:14:21 <platz> you need Ω(n) lasers
10:14:33 <quchen> That's more like it!
10:14:46 <ReinH> quchen: just imagine the quote gesture
10:14:59 <argoneus> > sum [1,2,3]
10:15:00 <lambdabot>  6
10:15:05 <argoneus> > sum [1..]
10:15:08 <ReinH> quchen: in fact I think I'll do that from now on.
10:15:10 <lambdabot>  mueval-core: Time limit exceeded
10:15:13 <argoneus> mhm
10:15:21 <argoneus> I expected an error or something
10:15:38 <ReinH> Merge sort is "O(n log n)". etc. I like it.
10:15:54 <argoneus> ReinH: do you like heapsort
10:16:03 <ReinH> sure
10:16:10 <quchen> argoneus: You can test it locally and you'll get a different error.
10:16:26 <argoneus> quchen: it won't hang??
10:16:29 <argoneus> -?
10:16:41 <argoneus> ReinH: do you like shor's algorithm?
10:17:01 <quchen> argoneus: I don't know what it will do. It could keep going forever, or blow up the heap, or the stack, or something I don't anticipate.
10:17:02 <ReinH> argoneus: is that one of those quantum thingys?
10:17:12 <argoneus> ReinH: yeah, prime factorization on quantum computers
10:17:16 <ReinH> ah right
10:17:17 <argoneus> apparently it's blazing fast and I have no idea how it works
10:17:21 <argoneus> but seems cool
10:17:36 <kadoban> shor's algorithm is black magic
10:17:38 <sbrg> don't let quchen catch you using 'fast' again
10:17:48 <ReinH> We don't know if it's fast.
10:17:55 <quchen> argoneus: sum [1..] defaults to using Integer, so it can't really terminate. But note that the type of that expression is not "Integer" but arbitary "Num a",
10:17:57 <quchen> :t sum [1..]
10:17:59 <lambdabot> (Enum a, Num a) => a
10:18:06 <nitrix> How would I implement a function :: [IO (Maybe x)] -> IO (Maybe x), with the semantic that it stops at the first Just or produce Nothing? Has to execute the actions lazyly though.
10:18:13 <quchen> So there are "a" for which that expression makes sense. Lazy nats for example.
10:18:13 <argoneus> well, fast
10:18:20 <aweinstock> > sum [1..] :: Word8
10:18:22 <lambdabot>  128
10:18:23 <argoneus> they are speculating that you can break RSA in reasonable time with it
10:18:26 <argoneus> that's pretty damn fast))
10:18:31 <ReinH> nitrix: getFirst . sequence . map First
10:18:40 <quchen> argoneus: You could ask whether  100 < sum [1..]   and you'd get True back in that case.
10:18:46 <aweinstock> ala First sequence
10:18:55 <ReinH> nitrix: er, you need probably two sequences or something
10:18:57 <ReinH> or two maps
10:18:57 <argoneus> quchen: oh, it stops evaluating the moment it goes over 100?
10:19:03 <ReinH> or something to deal with both [] and IO
10:19:04 <aweinstock> :t ala First sequence
10:19:05 <lambdabot>     Couldn't match type ‘Maybe b -> First b’ with ‘First (e -> b1)’
10:19:06 <lambdabot>     Expected type: (Unwrapped (First b) -> First b) -> e -> First b1
10:19:06 <lambdabot>       Actual type: First (e -> b1) -> e -> First b1
10:19:18 <aweinstock> :t ala First mapM
10:19:19 <lambdabot> Traversable t => t (Maybe b) -> Maybe (t b)
10:19:25 <nitrix> ReinH: I'll figure the types out, but that's the general idea? Leverage monoids to shortcircuit sequence?
10:19:31 <ReinH> nitrix: yes
10:19:34 <quchen> argoneus: Yup. Well, if your "number type" works that way. If you sum up an infinite list of Int you'll hang no matter what.
10:19:39 <ReinH> First does what you want
10:19:39 <nitrix> ReinH: Okay, will try. thanks
10:20:00 <argoneus> time to write a haskell program to find the largest integer
10:20:28 <suppi> argoneus, good luck!
10:20:44 <aweinstock> :t sum
10:20:46 <lambdabot> (Num a, Foldable t) => t a -> a
10:20:49 <argoneus> tbh, it wouldn't be difficult to write
10:20:52 <argoneus> but it'd take a while to finish
10:20:56 <quchen> argoneus: But you can define "newtype Nat = Nat [()]" and define "(+) = (++)", "fromInteger = \n -> replicate n ()" and so on.
10:21:02 <aweinstock> > length [1..] :: Int
10:21:06 <lambdabot>  mueval-core: Time limit exceeded
10:21:10 <aweinstock> > length [1..] :: Int32
10:21:12 <lambdabot>      Couldn't match expected type ‘Int32’ with actual type ‘Int’
10:21:13 <lambdabot>      In the expression: length [1 .. ] :: Int32
10:21:13 <quchen> argoneus: If you do that, you'll be able to do "1 < sum [1..]". :-)
10:21:24 <argoneus> > 1 < sum [1..]
10:21:28 <lambdabot>  mueval-core: Time limit exceeded
10:21:31 <aweinstock> > length [1 :: Int32..]
10:21:31 <ReinH> quchen: or any lazy nat
10:21:34 <lambdabot>  <hint>:1:14: parse error on input ‘Int32..’
10:21:40 <quchen> Do we have lazy nats here?
10:21:42 <aweinstock> > length [(1 :: Int32)..]
10:21:46 <lambdabot>  mueval-core: Time limit exceeded
10:21:55 <johnw> I have lazy gnats
10:21:59 <sbrg> :t (mconcat . map First) `fmap` sequence
10:22:03 <lambdabot> Maybe [a] -> First a
10:23:58 <fr33domlover> Hello! Q: I'd like to search of a strict Text inside another strict Text, case insensitively. I'd also like to take the word right after the occurence of the "needle", but I need its original case and not the case-folded one. Without the last requirment, I could use T.toCaseFold on both haystack and needle, simple. But in my case it's not straight-forward - what would be good practice here, an efficient
10:23:59 <fr33domlover> implementation?
10:24:04 <kadoban> > length [(244::Word8)..]
10:24:06 <lambdabot>  12
10:25:08 <fr33domlover> should I show you a paste to clarify?
10:26:42 <johnw> clarifying pastes are always welcome
10:28:15 * hackagebot diversity 0.8.0.0 - Quantify the diversity of a population  https://hackage.haskell.org/package/diversity-0.8.0.0 (GregorySchwartz)
10:29:12 <fr33domlover> http://paste.rel4tion.org/192
10:29:22 <fr33domlover> this is more or less the idea ^
10:29:47 <fr33domlover> but in searchCI i want to get the result in a non-casefolded form
10:31:16 <fr33domlover> I suppose one way is to hold 2 Text values, and do the same things on both
10:31:35 <fr33domlover> but I wonder if a more elegant option exists
10:31:54 <fr33domlover> ideally Text would offer a case-insensitive stripPrefix etc. but here is no such thing
10:32:10 <johnw> (h, aystack) <-- very clever, I like that :)
10:32:57 <fr33domlover> johnw, that idea isn't mine but i like it too :)
10:33:09 <johnw> fr33domlover: T.inits might help
10:33:26 * hackagebot microlens 0.4.1.0 - A tiny part of the lens library with no dependencies  https://hackage.haskell.org/package/microlens-0.4.1.0 (Artyom)
10:37:44 <fr33domlover> johnw, in which way? i just spent a few minutes thinking :P i was thinking about using T.drop on the copy or something
10:37:45 <glittershark> fr33domlover: that's how I'd do it
10:37:55 <johnw> fr33domlover: one sec, writing it
10:38:27 * hackagebot microlens-ghc 0.4.1.0 - microlens + array, bytestring, containers, transformers  https://hackage.haskell.org/package/microlens-ghc-0.4.1.0 (Artyom)
10:38:29 * hackagebot microlens-platform 0.2.1.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.2.1.0 (Artyom)
10:39:13 <Tuplanolla> Just how many lens libraries are there?
10:39:43 <hunteriam> do I need FlexibleContexts for a type signature like` auth :: Curry (a -> Serv b) f => f -> Maybe SigninToken -> f`
10:40:46 <glittershark> don't think so
10:40:54 <glittershark> all your type parameters are concrete
10:41:12 <hunteriam> it says "non-type variable param in the contraint"
10:41:19 <glittershark> oh
10:41:21 <glittershark> yeah
10:41:35 <glittershark> it wrapped weird on my screen so I got the grouping wrong
10:41:36 <glittershark> yes, you do
10:41:42 <glittershark> for the `a -> Serv b` type
10:41:44 <puregreen> Tuplanolla: several for van Laarhoven lenses (lens, microlens, lens-family/lens-simple), several exploring alternative approaches (fclabels, something else but don't remember what)
10:41:52 <hunteriam> ok
10:42:01 <johnw> fr33domlover: https://gist.github.com/fd4f592064bf2460d375
10:42:10 <johnw> assumes leader is already lowercased
10:42:53 <Tuplanolla> Also data-lens and data-lens-light, puregreen.
10:43:02 <emmanuel_erc> I just uploaded some code to lpaste.net. Did any of guys see it? I am not seeing the notification on my end. 
10:44:02 <lyxia> emmanuel_erc: nope
10:44:06 <puregreen> Tuplanolla: I wanted to mention data-lens but given that it's by the author of lens *and* it precedes lens, I couldn't bring myself to say that it “explores alternative approaches”
10:44:24 <puregreen> but yeah, it's still used
10:44:50 <fr33domlover> johnw, thanks. Doesn't it mean lots of T.toLower applications though?
10:44:53 <emmanuel_erc> That is strange... I'll just put it here, and then provide the necessary explanation.
10:45:00 <emmanuel_erc> http://lpaste.net/148614
10:45:20 <puregreen> emmanuel_erc: what did you put in the Author field?
10:45:38 <puregreen> I think you have to put your IRC nick there in order for it to be announced
10:45:45 <johnw> fr33domlover: laziness will ensure that it happens as much as needed, but yes, for a leader of N characters, it's possible that there are some letters in the input string that will be lowered up to N times
10:45:46 <emmanuel_erc> I put emmanuel_erc
10:45:49 <hunteriam> any insight into this error? http://lpaste.net/148615
10:46:04 <hunteriam> I use Data.Tuple.Curry so why wouyldnt it build?
10:46:05 <Tuplanolla> Actually data-lens-light is by Cheplyaka, puregreen.
10:46:18 <puregreen> Tuplanolla: data-lens-light is a fork of data-lens
10:46:26 <puregreen> https://github.com/feuerbach/data-lens-light/blob/master/README.md
10:46:33 <johnw> fr33domlover: are you searching extremely long input strings?  is this in a performance critical area?
10:46:37 <Tuplanolla> Right, right.
10:48:01 <fr33domlover> johnw, the needle is probably at most 5 chars and haystack at most 400 chars, basically the search happens 2-3 times on each IRC message received in an IRC channel. So far no performance issue, but I'm just curious about the elegant solution :)
10:48:03 <johnw> fr33domlover: the alternative (lowering exactly once) will come at a memory cost instead of a CPU cost
10:49:09 <puregreen> Tuplanolla: aha, I remembered
10:49:22 <puregreen> there's also roconnor's mezzolens
10:49:46 <emmanuel_erc> @ puregreen or lyxia: I want to build up an inductive graph efficiently, and I think I managed to do so with the function buildGr'''. (I realized that I could take up less heap space by getting rid of unnecssary lists). Is there I could have written this (here is the code again: http://lpaste.net/148614) with conventional list functions with the same or better efficiency?
10:50:09 <puregreen> (with pure profunctor lenses)
10:50:29 <johnw> fr33domlover: let me think
10:50:44 <wedify> when using renderWithDrawable is that sufficient for a target surface? or do i need to initialize one somehow?
10:50:49 <Tuplanolla> Choosing which one to use is quite confusing. I'm quite happy with data-lens-light, but I keep questioning myself.
10:51:03 <wedify> i'm trying to figure out why i can load a png and display it but not draw rectangles or text
10:54:13 <spuz> I'm using stack to run a suite of tests. how can I run just a single test?
10:55:09 <fr33domlover> johnw, how about this: http://paste.rel4tion.org/192
10:55:10 <johnw> fr33domlover: https://gist.github.com/7363c4124327a5c1bfca
10:55:36 <johnw> fr33domlover: the second version i just pasted keep two copies of the input string in memory
10:55:57 <fr33domlover> johnw, mine uses 2 texts too, take a look :P
10:56:21 <nitrix> getRandomProvider s = head <$> (shuffleM . elems . M.keysSet . roots $ s)
10:56:27 <nitrix> Isn't there a better way to write this?
10:56:28 <johnw> can't, meeting time now
10:56:57 <nitrix> I can't eta reduce it because <$> has higher precedence, and with $, I'm forced to used a parenthesis still.
10:57:01 <glittershark> nitrix: looks pretty simple to me
10:57:10 <glittershark> \pl getRandomProvider s = head <$> (shuffleM . elems . M.keysSet . roots $ s)
10:57:15 <glittershark> @pl getRandomProvider s = head <$> (shuffleM . elems . M.keysSet . roots $ s)
10:57:15 <lambdabot> getRandomProvider = (head <$>) . shuffleM . elems . M.keysSet . roots
10:57:20 <glittershark> could do that
10:57:27 <johnw> nitrix: I'd use fmap in that case
10:57:33 <johnw> getRandomProvider = fmap head . shuffleM . elems . M.keysSet . roots
10:57:40 <nitrix> Brilliant
10:57:44 <nitrix> I keep forgetting that
10:57:55 <glittershark> not that "point-free" does not always mean "better" :)
10:58:20 <maerwald> if you have to use pl, then it is probably worse
10:58:48 <nitrix> It's borderline here. It's one of those cases where it's a set in a map while an IO...
10:58:51 <nitrix> From a record.
10:58:58 <nitrix> Lenses would be great but oh well.
10:59:18 <aweinstock> :t shuffleM
10:59:19 <lambdabot>     Not in scope: ‘shuffleM’
10:59:20 <lambdabot>     Perhaps you meant ‘shuffle’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
10:59:46 <aweinstock> MonadRandom m => [a] -> m [a] -- something like this?
10:59:54 <nitrix> shuffleM :: MonadRandom m => [a] -> m [a]
11:08:01 <ReinH> glittershark: it's not so bad if you use fmap head instead of (head <$>)
11:08:11 <ReinH> usual caveats about head notwithstanding
11:08:55 <ReinH> catMaybes . map listToMaybe . ... may be better
11:09:43 <aweinstock> :t ala First foldMap
11:09:44 <lambdabot> Foldable t => t (Maybe b) -> Maybe b
11:10:06 <aweinstock> :t catMaybes . fmap listToMaybe
11:10:08 <lambdabot> [[a]] -> [a]
11:10:20 <statusfailed> I have a Trifecta parser "term = parens expr <|> number"; and another "topLevel = expr <|> term". I'd expect "topLevel" to be equivalent to "expr <|> parens expr <|> number", but it's not- why?
11:10:31 <statusfailed> (the behaviour of the latter hangs forever)
11:10:34 <aweinstock> :t alaf First foldMap Just
11:10:37 <lambdabot> Foldable t => t b -> Maybe b
11:11:14 <statusfailed> (my actual problem is that I want to parse simple arithmetic, allowing the top level expression to have no parens around it)
11:12:38 <ReinH> statusfailed: (<|>) is infixl
11:12:54 <ReinH> (a <|> b) <|> c /= a <|> (b <|> c)
11:13:46 <ReinH> wait, <|> is supposed to be associative
11:13:49 <ReinH> Is it in this case?
11:13:56 <statusfailed> I bracketed both ways and get the same results anyway hehe
11:14:04 <ReinH> Then that isn't it
11:14:05 <Tuplanolla> It should be. The problem is that your parser doesn't consume anything, statusfailed.
11:14:17 <Tuplanolla> It just jumps between two productions.
11:14:18 <statusfailed> Tuplanolla: that's what I figured, but I can't see how the two versions are different
11:14:40 <statusfailed> Should I gist this?
11:14:41 <hunteriam> class Curry a b | a -> b where
11:14:44 <hunteriam> | a -> b?
11:14:57 <statusfailed> hunteriam: "Functional dependencies"
11:15:00 <ReinH> hunteriam: it's called a functional dependency. It says that the choice of b is unique for each a.
11:15:16 <ReinH> i.e., for each a there is only one choice of b
11:15:18 <dgpratt> alright, I'm stumped
11:15:53 <dgpratt> I'm going through an exercise that requires me to define an Applicative instance for a certain type and I can't seem to figure it out
11:15:55 <dgpratt> http://lpaste.net/4431363036275539968
11:16:08 <dgpratt> <*> for CTree, that is where I'm stuck
11:16:14 <dgpratt> hopefully I included enough context
11:16:17 <Tuplanolla> If you're planning to get things done instead of studying parsing, consider Megaparsec, statusfailed.
11:16:17 <Tuplanolla> https://hackage.haskell.org/package/megaparsec-4.2.0/docs/Text-Megaparsec-Expr.html
11:16:18 <dgpratt> any hints?
11:16:31 <statusfailed> Tuplanolla: I did, I wrote the same program in it
11:16:34 <ReinH> Tuplanolla: what?
11:16:44 <statusfailed> but it has "error" buried in it somewhere, which crashed my code
11:16:45 <ReinH> parsers and trifecta is a perfectly reasonable choice
11:16:49 <statusfailed> so i'm looking at other options as well
11:17:07 <gerald> Hey, I'm trying to understand what I think is probably a really basic error with a CIS194 exercise I'm working on. Could anyone have a look? I included the error message here: http://pastebin.com/WAFMUJaB
11:17:12 <Tuplanolla> Yes, but there are easier solutions, ReinH.
11:17:19 <ReinH> "easier"?
11:17:28 <ReinH> parsers is very easy to work with imo
11:17:41 <ReinH> trifecta provides the best error messages in its class
11:17:49 <statusfailed> This is irrelevant to me because I'm using both :p
11:18:05 <ReinH> It's not accurate to imply that trifecta is a toy
11:18:21 <bitemyapp> trifecta is bae
11:18:45 <statusfailed> hahah
11:18:54 <statusfailed> Anyway I'll gist this
11:19:52 <statusfailed> oh I think I found the problem actually
11:20:03 <bitemyapp> statusfailed: gist it anyway
11:20:06 <bitemyapp> statusfailed: then explain the problem
11:20:15 <statusfailed> expr = buildExpressionParser table term <?> "expression"
11:20:16 <statusfailed> term = parens expr <|> number
11:20:17 <andromeda-galaxy> dgpratt: I'll take a look at it, and see if I see anything obvious
11:20:39 <blub> gerald: errorStr is indented too much, it should be the same level as list
11:20:55 <gerald> blub thank you!
11:21:35 <dgpratt> thanks andromeda-galaxy -- I assume it would be obvious to anyone proficient in Haskell
11:22:07 <aweinstock> dgpratt: if treeabs and treerep are already correct, you can "cheat" by saying: f <*> x = treerep $ treeabs f <*> treeabs x
11:22:09 <bitemyapp> statusfailed: what was wrong?
11:22:31 <dgpratt> aweinstock, they type check, so they must be correct :D
11:22:37 <aweinstock> :D
11:22:40 <ReinH> dgpratt: What is the type of (<*>) specialized to CTree?
11:22:51 <glittershark> :i CTree
11:23:01 <glittershark> aww, no :i :(
11:23:07 <aweinstock> glittershark: http://lpaste.net/4431363036275539968
11:23:08 <glittershark> @src CTree
11:23:08 <lambdabot> Source not found. Take a stress pill and think things over.
11:23:12 <glittershark> oh
11:23:19 <glittershark> it's not even a thing
11:23:20 <glittershark> lol
11:23:23 <aweinstock> (also, lambdabot doesn't have :i, even if CTree were defined)
11:23:27 * glittershark should pay attention
11:23:28 * hackagebot HXQ 0.20.1 - A Compiler from XQuery to Haskell  https://hackage.haskell.org/package/HXQ-0.20.1 (LeonidasFegaras)
11:23:57 <dgpratt> ReinH, :: CTree (a -> b) -> CTree a -> CTree b, no?
11:24:07 <aweinstock> dgpratt: once you have the cheating definition, you can inline treerep/treeabs and do equation-y stuff to them
11:24:22 <dgpratt> aweinstock, yeah, I was thinking along those lines
11:24:24 <ReinH> dgpratt: Now unwrap that
11:24:25 <dgpratt> thanks
11:24:33 <dgpratt> ReinH, unwrap?
11:24:42 <ReinH> what is the type of <*> applied to (a -> Tree r) -> Tree r ?
11:25:11 <dgpratt> oh, gotcha
11:25:16 <dgpratt> umm...
11:25:22 <ReinH> you replace a with some things
11:25:25 <ReinH> what things?
11:26:10 <aweinstock> (((a -> b) -> Tree r) -> Tree r) -> ((a -> Tree r) -> Tree r) -> ((b -> Tree r) -> Tree r)
11:26:31 <ReinH> aweinstock: it isn't helpful if other people give the answer
11:26:40 <ReinH> the point is for dgpratt to give the answer
11:26:43 <aweinstock> ah
11:26:55 <dgpratt> ReinH, so far correct? :: (((a -> b) -> Tree r) -> Tree r) -> ((a -> Tree r) -> Tree r) -> ((b -> Tree r) -> Tree r)
11:26:59 <dgpratt> oh
11:27:13 <dgpratt> checking aweinstock's answer :)
11:27:18 <ReinH> Yes.
11:27:21 <dgpratt> cool
11:27:35 <ReinH> Now ignore that you have a tree and solve this:
11:27:58 <ReinH> (((a -> b) -> r) -> r) -> ((a -> r) -> r) -> ((b -> r) -> r)
11:28:40 <dgpratt> ReinH, I bet lambdabot could do it for me :)
11:28:44 <ReinH> I bet it could.
11:28:50 <ReinH> But that wouldn't teach you how to do it.
11:29:05 <dgpratt> right
11:29:25 <dgpratt> hmm, ok I'm gonna start at this a bit -- my head is swimming with arrows
11:29:35 <ReinH> dgpratt: it helps to use a lot of scratch paper to write things down
11:29:43 <ReinH> and hole-based programming might help too
11:29:47 * dgpratt grabs some paper
11:30:00 <ReinH> what is your goal and what things do you have to use?
11:30:04 <dgpratt> yeah, I've actually gotten this far with liberal use of holes
11:30:10 <hunteriam> http://lpaste.net/148620
11:30:12 <hunteriam> ??
11:30:21 <Fuco> I have pre-printed paper with arrows where I just fill parens and letters
11:30:28 <Fuco> it's pretty useful when learning haskell
11:30:41 <dgpratt> ReinH, my goal is to understand the Codensity transformation (and many related things)
11:31:00 <ReinH> Fuco: really? neat.
11:31:15 <Fuco> used it a lot during my uni courses, also for matlogic and types
11:31:19 <aweinstock> hunteriam: missing "where"
11:31:29 <hunteriam> oh...
11:32:06 <Fuco> I got inspired by one of the exams where we had just that and had to fill in stuff, it was for mathematical logic class
11:32:15 <ReinH> dgpratt: have you seen http://www.cs.ox.ac.uk/ralf.hinze/Kan.pdf ?
11:32:20 <Fuco> the prof had all sorts of clever things like that :D
11:32:37 <ReinH> dgpratt: not sure if it will be helpful, but it is *an* explanation.
11:32:43 <dgpratt> :)
11:32:49 <dgpratt> thanks ReinH
11:32:53 <ReinH> It requires a fair amount of category theory equipment
11:32:53 <Fuco> kan extensions, not exactly beginner friendly 
11:33:04 <Fuco> (assuming from the file name)
11:33:15 <dgpratt> I need an "Advanced Math Notation for Dummies"
11:33:51 <Fuco> ReinH: hm, for a moment I thought you're Ralf Hinze, based on the nick... are you? :D
11:33:51 <ReinH> Fuco: the paper actually builds up *to* Kan extensions, requiring only basic CT knowledge.
11:34:07 <ReinH> Fuco: Reading that paper is actually a great way to learn Kan extensions
11:34:09 <ReinH> nope
11:34:22 <ReinH> So "a fair amount" is overstating things, perhaps
11:34:27 <Fuco> I read a lot of his stuff when writing my thesis
11:34:34 <ReinH> You can do well with knowledge of functors and natural transformations
11:34:47 <ReinH> Fuco: I'm a fan of his writing.
11:34:59 <Fuco> yea
11:35:05 <Fuco> and gibbons too
11:35:11 <Fuco> oxford has good staff
11:35:43 <ReinH> dgpratt: Well: http://www.amazon.com/dp/1466230525/?tag=stackoverfl08-20
11:36:06 <dgpratt> it exists! :)
11:36:10 <ReinH> Fuco: yes.
11:36:22 <hunteriam> http://lpaste.net/148622
11:36:36 <hunteriam> why is it trying to deduce something for a0?
11:37:02 <statusfailed> here's my gist: https://gist.github.com/statusfailed/25a7d3d05394dc11ef2d
11:37:19 <andromeda-galaxy> dgpratt: looks like ReinH got everything figured out...
11:37:21 <Fuco> I also like http://detexify.kirelabs.org/classify.html, you can draw the character and it tells you latex for it, which yuo can in turn google
11:37:35 <Fuco> bonus points, the classifier is written in haskell :)
11:37:36 <dgpratt> ReinH is da man
11:37:58 <dgpratt> or...well I suppose ReinH might not be a man
11:38:04 <ReinH> hunteriam: I'm not sure, but your instances don't appear valid. Specifically, EndsIn a (b -> a) overlaps with EndsIn a c. So you'll always get some error.
11:38:04 <dgpratt> da person
11:38:50 <ReinH> and with EndsIn a a, for that matter
11:39:28 <hunteriam> ReinH: how could it overlap with a a?
11:39:39 <hunteriam> ReinH: a a => same type, a != b -> a
11:39:41 <ReinH> How could c overlap with a? Set c to a.
11:40:00 <ReinH> How could c overlat with (b -> a)? Set c to (b -> a)
11:40:01 <hunteriam> i dont have an instance EndsIn a c
11:41:21 <ReinH> hunteriam: But you have a (b -> a) and a (b -> C)
11:41:43 <ReinH> s/C/s
11:41:46 <ReinH> er, c. :(
11:41:47 <hunteriam> If i delete a (b->a) are we good?
11:42:38 <ReinH> I couldn't say.
11:42:58 <ReinH> I'm also not sure if inference will work here.
11:43:08 <hunteriam> I dont see why not
11:43:49 <hunteriam> either way
11:43:56 <hunteriam> anyone have insight on the original error?
11:45:08 <ReinH> hunteriam: Well, you don't use a anywhere in the signature, so nothing forces it to be the same a.
11:45:15 <joco42> i think i made a mistake here somewhere, i was hoping to achieve that this code prints all sub directories, recursively , but it does not, it only prints the immediate subdirectories but not recursively, any idea what is the problem here ? why this program not executes recursively ?
11:45:15 <joco42> https://github.com/jhegedus42/idris-py-examples/blob/master/equivalent-haskell-code/src/Main.hs
11:46:19 <joshkirklin> How would I go about making a pattern synonym for a non-empty list? I tried `pattern NE l = l@(_,_)` but was complained at about as-patterns.
11:46:22 <ReinH> joco42: catMaypes, not map fromJust . filter isJust
11:46:25 <ReinH> *catMaybes
11:46:55 <ReinH> joco42: sequence will give Nothing if anything is Nothing.
11:47:06 <ReinH> So if your directories contain any non-directories, they will be excluded
11:47:16 <ReinH> I think you mean catMaybes there again.
11:47:42 <ReinH> Wait, no. I'm mixing up the instances.
11:47:45 <ReinH> sequence is IO, not Maybe.
11:50:00 <verement> joshkirklin: (_,_) matches a tuple, not a list. maybe you meant (_:_)?
11:50:10 <hunteriam> wait ReinH , where do you see a0 pop up?
11:50:39 <ReinH> hunteriam: each use of f can have a different a
11:50:45 <ReinH> GHC is generating names for them
11:51:07 <hunteriam> Why does that matter though?
11:51:15 <lyxia> joco42: you forgot to either move into the directories, or append the filename to the "current" directory.
11:51:42 <joshkirklin> verement: yeah, that's what I meant, was a typo. Still doesn't compile
11:52:17 <hunteriam> throwError err401 is Serv a
11:52:26 <hunteriam> f.a. a
11:52:38 <ReinH> hunteriam: Wait. You just use f in the wrong place in the second definition.
11:52:45 * ReinH sighs
11:52:55 <lyxia> joco42: as for style, sequence $ map f x   is   mapM f x
11:53:10 <hunteriam> ?
11:53:20 <hunteriam> true
11:53:21 <ReinH> hunteriam: you have auth f (Just token) and auth _ f
11:54:48 <Nadrieril> joshkirklin: can you try "pattern NE l <- l@(_:_)" ?
11:55:26 <hunteriam> same error
11:55:46 <joshkirklin> Nadrieril: yeah I tried that as well. GHC seems to not like as-patterns in pattern synonyms though, so I think it has to be done without an `@`
11:55:56 <Nadrieril>  ah :/
11:56:16 <hunteriam> are you saying the f at the start and end could have different Serv a's in GHC's eyes?
11:57:02 <ReinH> hunteriam: Yes, I believe so.
11:57:28 <ReinH> hunteriam: These instances are so generic that I forsee lots of problems convincing GHC to infer types for their use sites.
11:57:31 <Nadrieril> joshkirklin: actually, you don't need the parameter: "pattern NE <- (_:_)" ?
11:57:33 <hunteriam> Frustrating... I dont want f to have polymorphic EndsIn
11:57:44 <hunteriam> I'm just trying to use a type variable
11:57:53 <Nadrieril> you can then do "f l@NE = ..." I think
11:57:56 <ReinH> hunteriam: This would be a use case for fundeps.
11:58:09 <ReinH> e.f., | b -> a would imply that f can only have one Serv a
11:58:17 <ReinH> but I'm not sure that they would work with your class
11:58:17 <hunteriam> thanks
11:58:20 <ReinH> because of its generality
11:58:31 <ReinH> and the likelihood of overlaps
11:59:00 <ReinH> hunteriam: I sort of wonder what it is you're trying to do, because I don't think you should have to add all this machinery to get auth to work.
11:59:37 <joshkirklin> Nadrieril: aha! that works wonders. Thanks very much
11:59:37 <hunteriam> Im writing a function `(a0 -> ... -> Serv a) -> (Maybe SigninToken -> a0 -> ... -> Serv a)`
11:59:42 <hunteriam> for use in servant
11:59:44 <ReinH> hunteriam: why are you doing that?
11:59:59 <Nadrieril> joshkirklin: no problem, I learned something too :)
11:59:59 <ReinH> I'm trying to get at the X that underlies all the Ys you are trying to solve.
12:00:16 <hunteriam> I have some api routes in servant that I toss a Header SIgninToken on the front of the route
12:00:26 <hunteriam> and I want a corresponding function to automatically deal with the header
12:00:40 <ReinH> So you want to be able to add a singin token header to any route?
12:00:45 <joco42> thanks lyxia
12:00:49 <hunteriam> yes and then deal with it automatically
12:00:53 <joco42> true...
12:00:53 <ReinH> Right.
12:02:29 <joco42> it think that code should be ok
12:02:30 <joco42> actually
12:02:51 <ReinH> hunteriam: do you want something similar to https://github.com/haskell-servant/HaskellSGMeetup2015/blob/master/examples/authentication-combinator/AuthenticationCombinator.hs ?
12:03:31 <ReinH> That's generally the pattern for adding authentication to routes in servant
12:03:44 <ReinH> Or at least, one good pattern.
12:03:49 <hunteriam> Seems useful
12:03:57 <Nadrieril> joshkirklin: if you want, here is a nice blog post about pattern synonyms: https://www.schoolofhaskell.com/user/icelandj/Pattern%20synonyms
12:04:17 <ReinH> hunteriam: you would replace the cookie-bvased impl with your token-header-based impl ofc
12:05:11 <ReinH> (well, both use headers, so it isn't even that different)
12:09:09 <orion> Is having a generic "My.Library.Util" module considered bad form?
12:10:48 <ReinH> orion: Yes, although people tend to do it anyway
12:11:07 <ReinH> Util is short for ThingsIDon'tKnowWhereToPutOrWhatToName
12:12:49 <orion> ReinH: In my case, I have a type from a package which I use extensively, along with helper functions that operate on those types: https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/Types.hs
12:13:00 <orion> What do you think is the best way to refactor this?
12:14:40 <ReinH> orion: one pattern that is somewhat better than a Util module is, if you are writing extra functions for the types in some module Foo, that you write your own Foo.Ext module in your project.
12:14:45 <ReinH> e.g. Crypto.Noise.Ext
12:14:57 <ReinH> At leat that way you have some idea of what you might find there
12:14:59 <ReinH> *least
12:15:04 <ReinH> I really can't type today
12:15:17 <orion> What if the module I'm writing extensions for is not located in my library?
12:15:24 <orion> In this case, ScrubbedBytes is part of memory.
12:15:30 <ReinH> Yes, that's why you use the Ext postfix
12:15:31 <orion> s/memory/the memory package.
12:15:34 <orion> Ah.
12:15:36 <puregreen> orion: see https://jaspervdj.be/posts/2015-01-20-haskell-design-patterns-extended-modules.html
12:15:47 <ReinH> you are "extending" their module with your own definitions
12:15:57 <ReinH> puregreen: thanks I couldn't find the link
12:16:15 <ReinH> And he uses .Extended, which is better.
12:16:51 <joco42> lyxia: i see your point now, you were right
12:16:56 <orion> So it'd be Data.ByteArray.Extended, not Crypto.Noise.Ext, right ReinH?
12:18:11 <ReinH> orion: I guess that's up to you.
12:18:34 <joco42> and i think ReinH  was right too :)
12:18:55 <ReinH> joco42: I think only by accident in your case
12:19:47 <lifter> :r
12:19:51 <ReinH> joco42: I do know that walking directories is a non-trivial thing to get right, e.g., https://hackage.haskell.org/package/pathwalk
12:20:15 <ReinH> Well, it's not too bad, really.
12:20:21 <ReinH> The lazy one is a bit hairy
12:20:52 <ReinH> joco42: the use of MaybeT might be instructive there.
12:21:08 <joco42> too tired... off to sleep, try to fix this tomorrow...
12:21:59 <Geraldus> hi friends!
12:23:01 <joshkirklin> Nadrieril: cheers, I'll take a look
12:23:19 <lifter> o
12:23:52 <Geraldus> I'm learning attoparsec.  I have to parse some JSON code, I know that there is Aeson package, but in my case I want to terminate connection earsy as needed data reached.
12:24:15 <joco42> thanks
12:24:53 <joco42> maybe :)
12:25:05 <blub> hi geraldus
12:25:14 <Geraldus> So, the question is what is the best way to skip uninterested part of data from beggining, currently I use `manyTill anyWord8 (string "targetProperty")`
12:25:32 <joco42> finally a place to try it.. 
12:26:00 <Geraldus> I guess there is some better and performant way.
12:26:05 <joco42> but that subdirs function seems to work ok in the repl
12:26:08 <Geraldus> blub: o/ how do you do?
12:26:29 <joco42> almost ok
12:26:38 <joco42> it only works for "."
12:26:42 <kadoban> Geraldus: Is your parser supposed to be always correct, or are you okay with slightly lying? That doesn't sound like it's going to correctly handle some bad inputs.
12:26:49 <joco42> not for anything else
12:27:11 <ReinH> Geraldus: are you using Attoparsec.Lazy?
12:27:40 <ReinH> How are you interleaving reads from a socket with parsing?
12:27:46 <kadoban> Geraldus: Most obviously, you're going to have no idea if whatever comes before that is even close to valid, or the context of where you're starting.
12:28:57 <Geraldus> Oh, got it.  If there is no "targetProperty" it will consume all input, won't it?
12:29:16 <ReinH> You could use pipes to do stream parsing, for example, but it isn't trivial to write a streaming parser, especially when using a parser that is strict by default.
12:29:46 <ReinH> Especially for JSON, which is not a stream-friendly format.
12:30:33 <ReinH> You can do some clever things, like keeping track of the position of structure-changing tokens so you can quickly walk back to the beginning of an object containing the string "targetProperty", but this too is not at all trivial.
12:30:46 <blub> im ok how about you
12:30:49 <ReinH> So TL;DR: Are you sure aeson isn't a better solution in practice?
12:31:19 <Geraldus> ReinH: no, for now I'm using strict parser.  The idea to read data from HTTP connection as lazy bytestring chucks, convert them to strict one and parse on the fly.  I want to close connection when interested data is reached
12:32:07 <Geraldus> blub: so do I
12:32:10 <ReinH> "convert them to strict ... and parse on the fly"? Those seem like mutually incompatible goals.
12:32:21 <ReinH> Attoparsec.Lazy can be fed incrementally with lazy bytestring chunks iirc
12:32:30 <ReinH> but again interleaving properly is not at all trivial
12:33:05 <puregreen> I don't think Aeson can solve this even in principle, since it won't give you any output until it reaches the last closing brace/bracket/whatever
12:33:08 <ReinH> And then you still have to deal with kadoban's question of "how do you correctly detect and parser interesting data in a stream?"
12:33:09 <Geraldus> ReinH: well, this is first time I'm using attoparsec, there is some notice about strict and lazy input, I should reread it.  
12:33:28 <ReinH> puregreen: I am suggesting that aeson can solve a different problem, and that the solution to that different problem might be more effective in practice.
12:34:13 <ReinH> If you're determined to write a streaming parser, there is no need to reinvent the wheel. Both pipes and conduit have streaming parse abilities iirc.
12:35:04 <Geraldus> My task is quite trivial.  Read data and look for some interested pieces, if I found it I can close connection early, if not just read all response body and close connection
12:35:33 <ReinH> Geraldus: I am trying to suggest that it is not at all as trivial as you think it is.
12:35:37 <spuz> in the context of a parser, what is the difference between: choice [parserFoo, parserBar] and: parserFoo <|> parserBar ?
12:36:34 <ReinH> Geraldus: there are a lot of non-trivial challenges ahead of you.
12:36:43 <puregreen> spuz: I don't think there's a difference (at least there's none for Parsec/Attoparsec)
12:36:52 <ReinH> Starting with proper interleaving of socket reads and incremental parsing
12:37:06 <ReinH> Continuing on to "useful detection of interesting pieces"
12:37:10 <Geraldus> ReinH: well, in imperative language I can solve this using simple for loop, in Haskell I can write some recursive string scan.  But in sake of learning and practice I want to use attoparsec.  
12:37:16 <spuz> puregreen, ok i'm using attoparsec thanks
12:37:28 <ReinH> Geraldus: A "recursive string scan" does not have the properties you are asking for.
12:37:35 <andromeda-galaxy> I was just looking at the Haste paper on seamless client-centric webapps, and it seems interesting, but I like the amount of code reuse that GHCjs will provide.  I can't find anything similar about an elegant structure for ghcjs applications, does anyone know of one?
12:37:51 <ReinH> Geraldus: You are specifically asking for streaming IO
12:37:54 <ReinH> This is not an easy problem.
12:38:05 <ReinH> A lot of work has gone into the various solutions for this
12:38:35 <Geraldus> ReinH: you confused me (: 
12:38:39 <ReinH> If you want to do it yourself from scractch, you will need to use unsafeInterleaveIO in a proper way, for example.
12:39:10 <Geraldus> ReinH: I plan to use http-client for reading data
12:39:18 <ReinH> andromeda-galaxy: that's still an area of active development
12:39:19 <Geraldus> and Attoparsec to parse it
12:39:28 <puregreen> Geraldus: can you say what do you mean by “interesting data”? for instance, is it “whatever object assigned to key "foo" anywhere in the object”, or something more complicated?
12:39:30 <ReinH> Geraldus: Yes, I understand that. Neither solve the "streaming IO" problem out of the box.
12:40:13 <ReinH> You can't just combine them in the obvious way and get something that behaves the way you want it to behave.
12:40:36 <statusfailed> ReinH: It's possible that Geraldus just wants to read chunks of bytes, push them into a parser, and terminate as soon as something successfully parses
12:40:40 <statusfailed> without dealing with streaming IO abstractions
12:40:57 <ReinH> statusfailed: and how will they do this without dealing with streaming IO?
12:40:57 <statusfailed> in which case something like "foo = do { feed parser; foo" would work fine, right?
12:41:41 <ReinH> I think a look at the implementation of hGetContents might help clarify what I mean.
12:41:50 <ReinH> interleaving won't happen automatically.
12:42:03 <statusfailed> What you can't do is treat a lazy list of bytes :: IO [Bytes] as streaming I/O
12:42:12 <statusfailed> at least, not without unsafeInterleaveIO as you mentioned
12:42:16 <statusfailed> yeah
12:42:26 <statusfailed> But you can still just recurse, right?
12:42:46 <ReinH> Then you could just recurse in hGetContents
12:42:46 <andromeda-galaxy> ReinH: okay, thanks for the information.  Has anyone tried to write a Haste.App style library for GHCjs?
12:42:56 <Geraldus> puregreen: there are two lists of objects called, say "items", each object have some set of properties and I need only one of them, say "name".  So this could be an example: `{ ... some uninterested data, "data": { "items": [{"name":"GMAN", ... other stuff}, {"name":"JMAN", ...}]}, ... "another data": { "items": [ .. etc ..] }`
12:43:09 <Geraldus> I need only names from each item.  Nothing more
12:43:46 <Geraldus> statusfailed: yes, that is
12:43:49 <ReinH> Geraldus: I would recommend using either pipes or conduit for their streaming parser implementations.
12:43:56 <statusfailed> or machines! :D
12:44:06 <hunteriam> http://lpaste.net/148631
12:44:18 <hunteriam> b->c doesnt determine a but c does
12:44:23 <hunteriam> Solution??
12:46:20 <ReinH> Geraldus: in your attempt to find an interesting problem to tackle with attoparsec you have stumbled into http://xkcd.com/1425/
12:46:46 <puregreen> I don't see anything hard about it, but maybe I'm mistaken
12:47:04 <ReinH> puregreen: The original ask was for a streaming parser
12:47:24 <ReinH> puregreen: that would interleave with socket reads and terminate promptly
12:47:31 <statusfailed> ReinH: I think the real problem is just to extract those "items/names" values
12:47:41 <ReinH> Yeah, that would be a better problem to focus on.
12:50:02 <Geraldus> ReinH: ok, in my case I can read all response first and then put all data to parser.  Anyway, I got an answer for my initial question (:
12:50:14 <hunteriam> instance (EndsIn a c) => EndsIn a (b->c) where
12:50:15 <hunteriam> fails the fundep (b->c) -> a, but it shouldnt because were given c -> a... solution anyone?
12:50:22 <ReinH> Geraldus: good news!
12:50:28 <hunteriam> seems like haskell just doesnt realize theres no problem
12:51:34 <Geraldus> thank you pals, I have to go!
12:51:37 <Geraldus> o/
12:51:37 <statusfailed> hunteriam: hmm. if c -> a, and (b -> c) -> a in the fundep, then surely the second argument doesn't uniquely determine the first?
12:51:39 <ReinH> hunteriam: that sounds like an accurate characterization. Maybe someone with more understanding can explain why that is.
12:52:09 <ReinH> Where's Cale when you need him
12:52:11 <hunteriam> statusfailed: due to b?
12:52:14 <statusfailed> I don't really know fundeps, but doesn't "instance (EndsIn a c) => EndsIn a (b->c)" mean "c uniquely determines a" and also "(b -> c) uniquely determines a"
12:52:30 <hunteriam> yes
12:52:37 <statusfailed> isn't that a contradiction?
12:52:55 <ReinH> statusfailed: I think you flipped an implication around in your reasoning there.
12:53:05 <statusfailed> maybe :D
12:53:11 <hunteriam> class EndsIn a b | b -> a where
12:53:31 <hunteriam> this is true for functions anyways..
12:53:34 <hunteriam> a->b is not true
12:53:41 <statusfailed> I'm not actually sure what the "| b -> a" means- is it "there exists only one b for a given a"?
12:53:47 <hunteriam> yes
12:53:51 <hunteriam> no sorry
12:53:54 <hunteriam> one a for a given b
12:53:54 <ReinH> statusfailed: no, the opposite
12:53:59 <statusfailed> oh right ok
12:54:01 <ReinH> thus the flipping
12:54:16 <mniip> I always read it as "it is possible to derive a from b"
12:55:11 <statusfailed> mniip: wouldn't that be equivalent to what I said?
12:55:13 <hunteriam> anyway to tell haskell whats up?
12:55:24 <mniip> it is
12:55:32 <ReinH> mniip: Yes, I think it's usually stated "b determines a", or that any two instances that agree on b must agree on a.
12:55:33 <mniip> but it's clearer
12:55:53 <statusfailed> now I'm not sure which one is correct :D
12:56:25 <ReinH> statusfailed: by "it is", mniip actually meant "it is not".
12:56:29 <ReinH> :D
12:56:32 <andromeda-galaxy> statusfailed: "b -> a"  means that b determines a, i.e. there can only be one a for any given b
12:56:45 <statusfailed> ReinH: ah! another flip :p
12:56:58 <mniip> I meant "it is the same as what you said if you take ReinH's correction into account"
12:56:58 <ReinH> I hope that at this point all parties are sufficiently confused.
12:57:04 <statusfailed> hahah
12:57:09 <statusfailed> mniip: ok I get you now :D
12:57:35 <ReinH> mniip: or, equivalently, "the opposite of what you said" :D
12:57:57 <statusfailed> oh god
12:58:09 <ReinH> Anyway, https://prime.haskell.org/wiki/FunctionalDependencies
12:58:31 * hackagebot concurrent-utilities 0.2.0.0 - More utilities and broad-used datastructures for concurrency.  https://hackage.haskell.org/package/concurrent-utilities-0.2.0.0 (sebaslafleur)
12:58:33 * hackagebot eventloop 0.6.0.0 - A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.  https://hackage.haskell.org/package/eventloop-0.6.0.0 (sebaslafleur)
12:58:35 * hackagebot twentefp-eventloop-trees 0.1.2.1 - Tree type and show functions for lab assignment of University of Twente. Contains RoseTree and RedBlackTree  https://hackage.haskell.org/package/twentefp-eventloop-trees-0.1.2.1 (sebaslafleur)
12:58:44 <andromeda-galaxy> ReinH: I am a little rusty on the coverage restrictions, but is there a chance that this actually needs UndecidableInstances?
12:59:11 <ReinH> andromeda-galaxy: I'm not sure. I am pretty confident that this will not work, but I don't think I can explain why.
12:59:22 <statusfailed> Could hunteriam use type families instead? (don't really know about either extension, but I found this: https://wiki.haskell.org/Functional_dependencies_vs._type_families)
12:59:30 <andromeda-galaxy> ReinH: with -XUndecidableInstances it compiles...
12:59:38 <statusfailed> hunteriam: ^ see above
12:59:50 <ReinH> andromeda-galaxy: which doesn't necessarily mean that it will work ;) but it is progress
12:59:50 <pranz> I think type families is a clearer way to express things like this
13:00:35 <andromeda-galaxy> ReinH: of course
13:00:45 <byorgey> ReinH: heresy!
13:02:55 <ReinH> byorgey: So there's this thing about "undecideable" things...
13:03:28 <andromeda-galaxy> ReinH, byorgey: UndecidableInstances is just about the typechecker not terminating, right?
13:03:31 <ReinH> Well, actually there isn't. If it compiled it was decided.
13:03:47 <byorgey> ReinH, andromeda-galaxy  exactly! =D
13:04:17 <andromeda-galaxy> so, excluding bugs in the typechecker, it probably works with UndecidableInstances
13:04:25 <statusfailed> what's the smallest program that will cause nontermination with UndecidableInstances?
13:04:37 <statusfailed> aaaaaaaaand...... go!
13:05:16 <andromeda-galaxy> what's the right way to do a typefamily for something like this, though?  I'm not sure how to do the base case well...
13:06:13 <hunteriam> ^
13:08:55 <byorgey> statusfailed:  http://lpaste.net/148633   -- there's my entry
13:09:34 <byorgey> though technically no programs cause nontermination with UndecidableInstances, they cause a context stack overflow
13:09:50 <statusfailed> haha
13:10:57 <statusfailed> it's beautifulll
13:12:45 <andromeda-galaxy> hunteriam, byorgey, ReinH: UndecidableInstances doesn't work after all, I forgot to add test code using the class.  I think that the might actually be ambiguous:
13:13:07 <andromeda-galaxy> for function any type (a->b), there's an instance for 'EndsIn (a->b) (a->b)' because of the first declaration
13:13:17 <andromeda-galaxy> but there's also one fore 'EndsIn b (a->b)' because of the second
13:13:31 <hunteriam> ah
13:13:35 <hunteriam> so it doesnt determine it
13:13:36 <hunteriam> ?
13:13:47 <andromeda-galaxy> hunteriam: I think so
13:14:47 <andromeda-galaxy> the problem is that you want something like 'instance NotFunction a => EnsIn a a where', but I'm not sure how to write NotFunction
13:17:12 <ReinH> you can't
13:18:37 <hunteriam> we can delete the first instance
13:18:48 <hunteriam> we need a new instance
13:19:20 <hunteriam> http://lpaste.net/148634
13:19:26 <hunteriam> still doesnt work though
13:19:57 <statusfailed> hunteriam: what's this for?
13:20:05 <hunteriam> servant
13:21:16 <andromeda-galaxy> ReinH: why not?
13:22:27 <ReinH> andromeda-galaxy: you can't write negative constraints. You can't say "not Ord a" or w/e.
13:22:45 <ReinH> or "a that is not a -> b"
13:23:18 <ReinH> hunteriam: so the solution for adding auth to routes didn't work for you?
13:23:29 <danilo2> Hello guys! I've got a funny notice for you. I've got a file here that compiles TWICE as fast if I replace type alias with closed type family (with just one member). the alias is pretty simple: type XQ1 m a = Targets (Match m a)  and the file uses it extensively and compiles about 15 seconds. After changing to type family XQ1 m a where XQ1 m a = Targets (Match m a) the comp time drops to 7
13:23:31 <andromeda-galaxy> ReinH: ah, that makes sense
13:23:33 <danilo2> just to let you know
13:23:33 <hunteriam> ReinH: doing that later
13:23:39 <andromeda-galaxy> I was hoping that there was some way to do it that I just didn't know...
13:23:48 <danilo2> I think it is connected to the famous slow type families resolution bug
13:24:23 <ReinH> danilo2: but you said type families were faster?
13:24:36 <danilo2> ReinH: yes, I'm also surprised
13:25:07 <danilo2> ReinH: I noticed a BIG performance loss when using type aliases and big win when replacing them with just closed TFs 
13:25:17 <glittershark> is there a typeclass like Semigroup for types with a commutative (and associative) operator?
13:25:51 <glittershark> conversely, is it possible to write rewrite rules that will try commutativity during the simplifier?
13:25:55 <bitemyapp> glittershark: I've only seen abelian groups.
13:26:01 <bitemyapp> glittershark: you'd be rolling your own.
13:26:03 <andromeda-galaxy> ReinH: Just out of curiosity, is there any way to do that operation?
13:26:18 <glittershark> bitemyapp: no identity, just a commutative operator
13:26:22 <glittershark> thus semigroup rather than monoid
13:26:30 <bitemyapp> glittershark: I understood that. What I said stands.
13:26:30 <byorgey> glittershark: yes, there is a Semigroup typeclass in the semigroups package
13:26:35 <glittershark> no, I mean
13:26:35 <exio4> ReinH: well, you kind can for some constraints...
13:26:40 <byorgey> soon it will be moving into base
13:26:40 <ReinH> bitemyapp, glittershark: not so fast! https://hackage.haskell.org/package/algebra-4.2/docs/Numeric-Algebra.html#t:Abelian
13:26:42 <bitemyapp> byorgey: they're asking for something that specifies commutativity.
13:26:51 <glittershark> like semigroup, but commutative in addition to associative
13:26:59 <bitemyapp> ReinH: I'll be goddamned. Good find.
13:26:59 <glittershark> yeah
13:27:05 <byorgey> oh, sorry, I should read more carefully =)
13:27:22 <ReinH> bitemyapp: it's the most ridiculous tower ever but o_O
13:27:24 <bitemyapp> ReinH: nice instance list, but how does it know which to do for stuff like Int?
13:27:37 <ReinH> bitemyapp: I don't claim to know anything about it :D
13:27:42 <glittershark> ReinH: is there a version without the Monoid superclass? I don't have an identity function
13:27:51 <bitemyapp> ReinH: given it builds on Additive, I can guess.
13:27:52 <exio4> ReinH: type family Not (x :: k) (xs :: [k]) :: Constraint where Not x (x ': xs) = "A" ~ "B" ; Not x (y ': ys) = Not x ys ; Not x '[] = ()  :p
13:27:58 <ReinH> glittershark: what Monoid superclass?
13:28:00 <bitemyapp> ReinH: must be doing a split tower.
13:28:07 <ReinH> bitemyapp: lattice, really
13:28:15 <glittershark> https://hackage.haskell.org/package/groups-0.4.0.0/docs/Data-Group.html
13:28:15 <dmwit> bitemyapp: I would guess there's a separate class for the multiplicative semigroup.
13:28:23 <glittershark> @src Group
13:28:23 <lambdabot> Source not found. Sorry.
13:28:24 <bitemyapp> dmwit: that's what I mean by split, yes.
13:28:33 <glittershark> `class Monoid m => Group m`
13:28:38 <ReinH> glittershark: what Group?
13:28:41 <dmwit> bitemyapp: ...and then a Ring class or similar that demands both an additive and multiplicative semigroup with appropriate laws.
13:28:50 <ReinH> glittershark: look at my link again...
13:28:59 <bitemyapp> dmwit: you seen Izbicki's stuff?
13:29:13 <glittershark> oh, lol, that's a different package
13:29:15 <dmwit> Not sure. Can you say a bit about the content of this stuff?
13:29:32 <ReinH> dmwit: it has stufflike qualities.
13:30:47 <ReinH> bitemyapp: oh. Yeah. It distinguishes additive from multiplicative, but you figured that out.
13:31:05 <glittershark> @quote ReinH dmwit: it has stufflike qualities
13:31:05 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
13:31:16 <ReinH> Not really worth quoting
13:31:20 <glittershark> @remember ReinH dmwit: it has stufflike qualities
13:31:20 <lambdabot> Done.
13:31:23 <ReinH> :(
13:31:25 <glittershark> hee
13:31:28 <glittershark> I giggled
13:31:38 <glittershark> worth quoting in my book
13:31:47 <ReinH> Probably should have included context then...
13:31:48 <bitemyapp> glittershark: book?
13:31:50 <ReinH> anyway
13:31:52 <sphinxo> Recommend pretty print lib?
13:31:59 <ReinH> bitemyapp: literal book, by which I mean figurative.
13:32:04 <ReinH> @hackage pretty
13:32:04 <lambdabot> http://hackage.haskell.org/package/pretty
13:32:33 <glittershark> I find it funnier out of context
13:32:36 <bitemyapp> ReinH: are you glittershark?
13:32:43 <ReinH> bitemyapp: I am surmising from context.
13:32:49 <bitemyapp> I am bad at that
13:32:53 <glittershark> yes, by book I mean opinion
13:32:58 <ReinH> 'in my book' is an idiom
13:33:06 <bitemyapp> I can deal with that.
13:33:10 <ReinH> "he's ok in my book"
13:33:10 <bitemyapp> thankee
13:33:12 <glittershark> basically means "according to me"
13:33:19 <bitemyapp> I've never seen it used for a quote sorta thing before
13:33:23 <ReinH> wherein neither he nor his ok-ness are in an actual book.
13:33:24 <bitemyapp> or WRT "recording"
13:33:30 <glittershark> I mean
13:33:37 <bitemyapp> I've heard the "ok in my book" instance before
13:33:38 <glittershark> in this case it's basically "this thing is true in my book"
13:33:41 <bitemyapp> sorry for derailing :)
13:33:54 <frerich> ReinH: You mean, neither one nor the other are actual books, in your book.
13:33:54 <glittershark> np
13:33:59 <ReinH> bitemyapp: happy to be of service
13:34:08 <ReinH> frerich: ok sure
13:34:12 <glittershark> idioms are weird; english is weird
13:34:56 <puregreen> @remember ReinH: Not really worth quoting
13:34:56 <lambdabot> Nice!
13:35:15 <Tuplanolla> Are there up-to-date versions of Hackage diagrams?
13:35:19 <puregreen> maybe one day someone would do “@quote ReinH” and that would pop up
13:35:30 <Tobisl> Hey fellas, i am new to Haskell. Which source do you recommend me to get a good introduction to haskell?
13:35:34 <dmwit> ?forget ReinH: Not really worth quoting
13:35:34 <lambdabot> Done.
13:35:56 <dmwit> If you do want to remember that, at least use `ReinH` instead of `ReinH:`...
13:36:19 * ReinH sighs
13:36:19 <dmwit> But, also: please don't want to remember that.
13:36:25 <ReinH> +1
13:36:28 * puregreen exhales
13:36:31 <puregreen> 'kay, 'kay, sorry
13:36:38 <puregreen> won't want to remember that
13:36:49 <glittershark> Tobisl: Learn You A Haskell is fantastic
13:36:59 <dmwit> Tobisl: I prefer the Gentle Introduction.
13:37:01 <dmwit> ?where gentle
13:37:01 <lambdabot> http://www.haskell.org/tutorial/
13:37:08 <ReinH> glittershark: Strongly disagree.
13:37:13 <glittershark> why's that?
13:37:16 <bitemyapp> @where guide
13:37:16 <lambdabot> https://github.com/bitemyapp/learnhaskell
13:37:19 <byorgey> Tuplanolla: what do you mean by Hackage diagrams?
13:37:20 <bitemyapp> @where book
13:37:20 <lambdabot> http://haskellbook.com/
13:37:27 <bitemyapp> Tobisl: ^^ pick one. Free or $$$.
13:37:41 <bitemyapp> Tobisl: run a lot of people through learning Haskell. Haven't found what most people will recommend to work very well.
13:37:42 <frerich> Tobisl: I liked http://www.cs.nott.ac.uk/~pszgmh/book.html a lot
13:37:44 <Tuplanolla> A directed graph of dependencies, byorgey.
13:37:54 <ReinH> It is not fantastic. It is not even good. It is superficial and it contains no exercises. People that use it tend to be disappointed that they don't actually know any Haskell when they finish, and either quit or have to use something else to progress.
13:38:11 <dmwit> byorgey: heh, you get notified when "diagrams" appears, huh? =)
13:38:12 <byorgey> Tuplanolla: you mean for all of Hackage? Or for individual packages?
13:38:23 <glittershark> that's just, like, your opinion, man
13:38:23 <Tuplanolla> All of it.
13:38:26 <byorgey> dmwit: ...MAYBE
13:38:36 <glittershark> I like it because it's really good at getting people *interested* in writing haskell
13:38:40 <glittershark> because it's really approachable
13:38:41 <ReinH> We get plenty of people with questions of the form "I finished LYAH now how do I actually do anything?"
13:38:41 <glittershark> but like
13:38:45 <Tobisl> Thanks guys i'll take a look at Learn you A Haskell and the Gentle Introduction!
13:38:45 <glittershark> ha
13:38:54 <bitemyapp> wasting peoples' time is not a way to get them to want to learn more Haskell
13:38:57 <glittershark> yeah I guess I don't run the support-line on #haskell nearly enough to have strong opinions
13:39:05 <bitemyapp> Tobisl: they aren't going to help much...
13:39:09 <bitemyapp> Tobisl: I tried :\
13:39:16 <frerich> ReinH: To be fair, I imagine people for whom LYAH worked won't come here as much asking how to actually do anything.
13:39:19 <Tobisl> bitemyapp: what do you recommend
13:39:24 <bitemyapp> @where guide
13:39:24 <lambdabot> https://github.com/bitemyapp/learnhaskell
13:39:25 <bitemyapp> @where book
13:39:26 <lambdabot> http://haskellbook.com/
13:39:29 <bitemyapp> Tobisl: ^^ one of those two.
13:39:39 <ReinH> frerich: that's a good point, but it doesn't invalidate the frequency with which we *do* get such people.
13:39:42 <glittershark> for the record, I started out with LYAH
13:39:45 <bitemyapp> Tobisl: first one if you won't pay for anything, second if you will (it's my book, I'm biased)
13:39:51 <bitemyapp> glittershark: that means little.
13:39:54 <glittershark> I know
13:40:03 <glittershark> I'm not claiming to be objectively right here :)
13:40:13 <bitemyapp> glittershark: I've spent years doing damage control on people set adrift by bad resources. Please.
13:40:21 <glittershark> christ
13:40:25 <bitemyapp> I'm serious.
13:40:26 <bitemyapp> It's bad.
13:40:27 <Tuplanolla> I know my experience is quite unusual, but I read LYaH at work during breaks and only started writing Haskell later.
13:40:33 <frerich> ReinH: Sure, just saying that I suspect the book is probably less worse than it may seem if you usually are in touch with people for whom it did not work :-)
13:40:41 <glittershark> I mean like
13:40:46 <bitemyapp> frerich: PiH is has a lot of problems too.
13:40:49 <ReinH> frerich: understood.
13:40:53 <Tuplanolla> It was quite good for that.
13:41:00 <bitemyapp> frerich: http://bitemyapp.com/posts/2014-12-31-functional-education.html
13:41:03 <dmwit> Well. If that's the kind of evidence we're using... I never hear people saying "I just finished the Gentle Intro and how do I write anything now?". =D
13:41:10 <glittershark> it's all well and good to say "a lot of people who ask me questions were lead astray by LYAH" but bringing emotions + anger into it isn't really constructive
13:41:18 <frerich> bitemyapp: Well *all* documentation about Haskell tends to have problems, you know :-)
13:41:25 <bitemyapp> glittershark: I'm not bring emotions or anger into it, I'm bringing experience.
13:41:26 <dmwit> glittershark++
13:41:39 <ReinH> dmwit: I never hear people saying "I read the gentle intro", full stop.
13:41:49 <bitemyapp> frerich: that doesn't excuse recommending worse-than-necessary options.
13:41:59 <glittershark> tone is difficult to read over the internet; some of the onus is on the person saying things to do so in a kind and friendly way
13:42:51 <bitemyapp> that's true up to a point, but people can read things through the lens of their own emotional state too.
13:42:54 <frerich> bitemyapp: Hm? I think people are just saying that various resources were helpful to them. Whether they are 'worse-than-necessary' (???) is a different thing.
13:43:04 <bitemyapp> emoji mostly doesn't work over IRC or I'd slap happy bear faces all over everything
13:43:05 <frerich> I liked 'Programming in Haskell', 'tis all I'm saying :-)
13:43:15 <bitemyapp> frerich: it's not about what I like or not
13:43:26 <bitemyapp> frerich: it's about what has worked better or worse for learners and PiH hasn't rated well.
13:43:33 * hackagebot HaRe 0.8.2.2 - the Haskell Refactorer.  https://hackage.haskell.org/package/HaRe-0.8.2.2 (AlanZimmerman)
13:43:34 <bitemyapp> frerich: this isn't about one personal experience learning Haskell
13:43:37 <frerich> It's "timeless" in a sense because it doesn't talk about libraries a lot, but it does talk about reasoning and proving things.
13:43:44 <frerich> bitemyapp: Puhleeeze.
13:43:49 <dmwit> [citation needed]
13:44:16 <glittershark> eh
13:44:26 <glittershark> kinda want to say this conversation has run its course
13:44:49 <glittershark> Tobisl is gone
13:44:55 <Tobisl> glittershark: so true :)
13:45:02 <frerich> Tobisl: One thing which is generally true is that the Haskell ecosystem (the language as well as the libraries) tend to move rather quickly. So *any* documentation may end up being a bit outdated in how it uses tools or libraries.
13:45:19 <bitemyapp> I realize it's easy to shrug off the differences between resources when you're already comfortable in Haskell
13:45:38 <bitemyapp> but Haskell is currently _notorious_ for being difficult to learn and most of this isn't because of how the language is designed
13:45:52 <glittershark> bitemyapp: I'm all for improving that situation
13:45:54 <bitemyapp> I would beseech you to take this seriously and think carefully about why so many people burnout and fail to learn Haskell
13:46:09 <bartavelle> I agree, I "learned" with RWH, and I think that with other resources I could have learned a lot faster
13:46:30 <Tuplanolla> I have a somewhat related question: what would you recommend for someone who is already familiar with math and functional programming, but not Haskell or any ML?
13:46:30 <glittershark> Haskell also has a bit of a reputation for having a toxic and difficult-to-approach community...
13:46:34 <bitemyapp> glittershark: I am improving the situation and have been for years now, but people are very "stuck" on recommending their pet book without having really compared or tested other resources.
13:46:41 <Tobisl> btw do you know adventofcode? i did the problems inhaskell, but after a while i didnt learn very much
13:46:51 <puregreen> bitemyapp: just wondering: is Haskell “more notorious” for being difficult to learn than e.g. Ocaml?
13:46:51 <dmwit> This is not a shrug. The Gentle Intro literally changed my life. For other folks who are like me, I would happily wish my experience on them.
13:47:02 <frerich> bartavelle: RWH to me is (was?) more of a cookbook recipe. 'How do I do JSON' or 'How do I parse binary formats' or so.
13:47:11 <bitemyapp> puregreen: Real World OCaml is alright. Most people just haven't heard of OCaml period.
13:47:14 <Tobisl> i really want to understand the whole monoid, monad, applicative stuff
13:47:49 <bartavelle> Tobisl, if gamification works for you I would recommend "codewars", it even has fun exercises on advanced topics
13:48:04 <dmwit> Tuplanolla: RWH might be good if you like to learn by example; I will still recommend Gentle Intro (over bitemyapp's objections) to theory-friendly folks.
13:48:11 <dmwit> Tobisl: You might like the Typeclassopedia.
13:48:20 <pavolzetor> hi, I am trying to represent a tree in haskell where I need fast reverse lookup (i.e. from node to branch in a tree)
13:48:22 <frerich> Oh yes, the Typeclassopedia is nice!
13:48:37 <pavolzetor> I am using IntMap currently with set of branches
13:48:49 <pavolzetor> and another intmap with lookup from vertices to those branches
13:49:02 <pavolzetor> but this feel very imperative
13:49:06 <bartavelle> the worst thing about the typeclassopedia when I was learning was not that I didn't understand what it meant, it was that I couldn't figure why I would want to use "Applicative" or "Arrow"
13:49:10 <Guest17919> In Philip Wadler's paper on Theorems for Free he states in Section 2 on Parametricity that there are no naive set-theoretic models of polymorphic lambda calculus
13:49:22 <Tobisl> bartavelle: thanks :)
13:49:22 <Guest17919> In the naive set-theoretic model types are sets and functions are set-theoretic functions which is seems reasonable. So why does he say there are no naive set-theoretic models of polymorphic lambda calculus?
13:49:36 <ReinH> pavolzetor: there is a library for bidirectional maps, fwiw
13:49:36 <Tobisl> dmwit: also thanks
13:49:53 <ReinH> I'm not sure there is a better representation for general use.
13:49:55 <dmwit> Guest17919: Well, what is the model of `forall a. a`?
13:50:12 <pavolzetor> ReinH: thanks, is it bimap?
13:50:26 <ReinH> pavolzetor: yep
13:50:31 <ReinH> it keeps track of the accounting for you
13:51:01 <dmwit> Guest17919: Or, okay, I understand that's maybe an objectionable choice; how about `forall a. a -> a` instead? You want a model which can contain the set of functions no matter what set those functions operate on.
13:51:16 <dmwit> Guest17919: Which gives a pretty direct paradox.
13:51:28 <pavolzetor> ReinH: it says it is a bijection
13:51:33 <pavolzetor> but I need many to one map
13:51:56 <glittershark> bitemyapp: I'm curious actually (not antagonistically, or rhetorically, just genuinely) what your problems are with LYAH. I'm also reasonably dedicated to encouraging haskell education as someone who wants to write more Haskell from day-to-day
13:52:23 <bitemyapp> glittershark: ReinH described a lot of the basic problem already.
13:52:27 <glittershark> and I'm totally ready to stop recommending LYAH if it's really a bad starting point for historically imprerative programmers
13:52:33 <glittershark> namely that it doesn't have exercises?
13:52:34 <bitemyapp> glittershark: my post talks about the problem more broadly: http://bitemyapp.com/posts/2014-12-31-functional-education.html
13:52:45 <bitemyapp> glittershark: yes but that's not some small thing
13:52:58 <ReinH> Guest17919: See John C. Reynolds, _Polymoprhism is Not Set-Theoretic_ and Andrew M. Pitts, _Polymorphism is Set Theoretic, Constructively_
13:52:59 <dmwit> glittershark: For what it's worth, I also rarely recommend LYAH. It's style rubbed me the wrong way when I tried it. However I have no objection to other folks finding it useful the way bitemyapp appears to.
13:53:27 <glittershark> basically my situation is I'm the only haskell programmer at my job and want all my coworkers to learn haskell so they can help me work on the haskell service I've been writing
13:53:42 <ReinH> Guest17919: They should contain the anwers you seek.
13:53:45 <bitemyapp> glittershark: there are other problems with it, but it comes down to LYAH not explaining anything, not providing you exercises for figuring it out, not examples substantive enough to stimulate understanding nor counter-examples to excise misunderstandings.
13:53:46 <ReinH> or the answers
13:53:48 <glittershark> I already had success with one of my coworkers (hi jetpacmonkey) sending him LYAH
13:53:52 <bitemyapp> glittershark: LYAH is a pedogogical black hole.
13:53:53 <jetpacmonkey> hi!
13:54:09 <bitemyapp> glittershark: it's a brief tour through some simple Haskell code. That's really it.
13:54:12 <bitemyapp> glittershark: and cartoons.
13:54:14 <bitemyapp> it has cartoons.
13:54:21 <glittershark> but there are other coworkers who are moving more slowly, so if there are better books I'm all ears
13:54:23 <ReinH> I mean, let's not underestimate the pedagogic value of cartoons.
13:54:33 <bartavelle> bitemyapp, cartoons *might* be enticing to some
13:54:35 <bitemyapp> the hermeneutics of cartoons.
13:54:45 <bitemyapp> glittershark: I'm writing a book. People like it a lot.
13:55:02 <glittershark> do you have a problem with the cartoons or are you just being reductionist?
13:55:10 <bitemyapp> glittershark: it's comprehensive, targets beginners, and aims to get people as far as they need to go to use real Haskell that is actually needed to understand modern Haskell libraries.
13:55:21 <glittershark> that's a pretty solid value proposition
13:55:32 <bitemyapp> @where book
13:55:32 <lambdabot> http://haskellbook.com/
13:55:40 <dmwit> (I couldn't handle the Poignant Guide to ruby for the same reasons. I'm a professional. I don't need or want cutesy nonsense, just give me the high points first and delve into the details as soon as possible.)
13:55:40 <blub> bitemyapp: i just finished doing cis194 on your recommendation, i was really pleased with it :)
13:55:41 <bitemyapp> glittershark: ^^ check the reviews and progress pages.
13:55:51 <bitemyapp> blub: glad you liked it, byorgey is here if you want to thank him :)
13:55:59 <bitemyapp> blub: since it was byorgey that wrote it :D
13:56:00 <glittershark> I for one *like* cutesy nonsense
13:56:03 <ReinH> dmwit: _why's guide taught an entire generation to write frankly awful Ruby.
13:56:06 <glittershark> it makes me happy, and emotions are important
13:56:14 <byorgey> glad you liked it blub =)
13:56:18 <ReinH> His obsession with metaprogramming is not useful for beginners.
13:56:27 <blub> thank you !
13:56:33 <jetpacmonkey> I really enjoyed the cutesy nonsense in LYAH, and couldn't finish _why's guide
13:56:48 <jetpacmonkey> it's not at the same level, even if it might be in the same general category
13:56:53 <dmwit> glittershark: I would not claim to speak for other people, of course. There are clearly many who like that style.
13:57:19 <bitemyapp> aesthetics aren't the issue here
13:57:24 <bitemyapp> or at least, not the objection.
13:57:29 <glittershark> that's what I'm trying to point out
13:57:32 <dmwit> not *your* objection =)
13:57:33 * frerich thinks it's pretty obvious that different books work differently well for different people, so now that we enumerated a few of them, maybe we can move on?
13:57:46 <bitemyapp> frerich: it's not that rosy.
13:57:58 <bitemyapp> frerich: you talk about it as if most resources are close enough to ideal and that it's a mere matter of taste.
13:58:02 <frerich> bitemyapp: Probably not. Can we move on anyway?
13:58:05 <frerich> :-]
13:58:07 <bitemyapp> frerich: the situation is far more dire than that.
13:58:09 <ReinH> I think this horse is well dead by now.
13:58:10 <glittershark> yeah, bitemyapp, if I'm understanding you correctly, the issue is that LYAH teaches the what rather than the why and the how?
13:58:11 <Guest17919> <dmwit> thanks
13:58:16 <bitemyapp> glittershark: it's worse than that.
13:58:25 <bitemyapp> glittershark: I've said my piece.
13:58:37 <ReinH> Guest17919: did you see my reply?
13:58:38 <glittershark> I'm not convinced yet but I really want to be
13:58:46 <Guest17919> no
13:58:47 <ReinH> Maybe move it to -blah?
13:58:49 <Guest17919> let me go back
13:58:52 <bitemyapp> glittershark: if you have questions about the why/what/how/etc. of the book I am working on with my co-author Julie, ping me in another channel.
13:59:00 <ReinH> Guest17919:  See John C. Reynolds, _Polymoprhism is Not Set-Theoretic_ and Andrew M. Pitts, _Polymorphism is Set Theoretic, Constructively_
13:59:15 <Guest17919> thanks mate
13:59:19 <Guest17919> i will check it
13:59:24 <ReinH> Guest17919: np
13:59:31 <ReinH> should answer all your questinos
13:59:35 <ReinH> or your questions
13:59:37 <bitemyapp> ReinH: /query?
13:59:43 <Guest17919> yep you hit the nail on the head
14:02:00 <jetpacmonkey> glittershark: if you do continue that discussion in another channel, let me know. I dropped into this discussion late.
14:04:52 <dmwit> After stewing a bit, I think the book I want my past self to have read to learn Haskell was TAPL.
14:05:53 <beepbeep_> dmwit, https://www.cis.upenn.edu/~bcpierce/tapl/ ?
14:06:09 <dmwit> yes
14:06:17 <dmwit> I admit it does not appear to be about Haskell.
14:08:00 <bartavelle> I wish I had started trying to do an actual project sooner instead of reading books for learning Haskell ;)
14:08:39 <dmwit> actually executing code is for the weak
14:08:55 <bartavelle> if I wasn't weak I would only write asm
14:09:00 <bartavelle> :p
14:09:19 <ReinH> dmwit: http://www.waterfall2006.com/martin.html
14:10:16 <dmwit> I'm cracking up over here
14:10:23 <glittershark> I'm with bartavelle here, the one thing that got me really learning haskell was writing haskell
14:10:38 <ReinH> dmwit: all the proceedings are pretty awesome.
14:10:45 <bartavelle> I think it's the same for every one, and that's why exercises are nice
14:11:18 <glittershark> yeah
14:11:33 <glittershark> the more I read bitemyapp's review of LYAH on http://bitemyapp.com/posts/2014-12-31-functional-education.html the more I agree
14:12:35 <kaiyin> How do you convert this into the bind form? https://gist.github.com/kindlychung/ab2ad8ceffccac764f8f#file-stack-hs-L14-L17
14:13:05 <dmwit> kaiyin: stackManip = push 3 >> pop >> pop
14:13:40 <dmwit> ?undo do { push 3; _ <- pop; pop }
14:13:40 <lambdabot> push 3 >> pop >>= \ _ -> pop
14:13:52 <dmwit> ?src (>>)
14:13:52 <lambdabot> m >> k = m >>= \_ -> k
14:15:53 <kaiyin> ok, i see. thanks!
14:16:06 <ReinH> Which should be equivalent to... pop.
14:16:51 <kaiyin> ReinH: yeah. :-)
14:17:01 <kaiyin> it's from learn you a haskell.
14:17:03 <dolio> If you want exercises, you don't need a Haskell book.
14:17:08 <dolio> AIMA has exercises.
14:17:12 <dolio> That's what I used.
14:17:34 <dmwit> ReinH: That doesn't make my box hot enough! Do you want my kittens to suffer?
14:19:09 <beepbeep_> AIMA? http://aima.cs.berkeley.edu/
14:20:45 <dolio> Yes, that's the one.
14:20:56 <beepbeep_> sweet
14:21:03 <beepbeep_> gotta read that one :)
14:21:08 <beepbeep_> thx!
14:21:14 <Majiir> glittershark, I just gave that a read, and I might even agree... but I found LYAH to be helpful myself. I know there's a lot of disdain for it, but for some people it works.
14:21:22 <glittershark> I also did
14:21:33 <glittershark> but that doesn't mean that I wouldn't've found something else even *more* helpful
14:21:39 <dolio> It won't teach you anything about Haskell, but you can write any programs in the exercises in Haskell.
14:22:15 <lamda_sage> How large can my Data.Map get before I start to see performance degredation? I am storing a mapping of IDs to URLs where I expect over 100k mappings.
14:22:42 <dmwit> ?djinn ((a -> Identity b) -> s -> Identity t) -> (a -> b) -> s -> t
14:22:43 <lambdabot> f a b c =
14:22:43 <lambdabot>     case a (\ d -> Identity (b d)) c of
14:22:43 <lambdabot>     Identity e -> e
14:22:55 <hpc> what is the ID type?
14:23:07 <lamda_sage> A ByteString
14:23:22 <Majiir> glittershark, the biggest gap I still have is how the underlying 'machine' works. It's easy to see how conventional languages map to CPU instructions, but less easy (for me, anyway) to infer how GHC works under the hood. Do you know of any good resources for this?
14:23:28 <dolio> Degradation in what sense?
14:23:40 <dmwit> lamda_sage: You might like to use bytestring-trie
14:23:41 * hackagebot imagemagick 0.0.3.7 - bindings to imagemagick library  https://hackage.haskell.org/package/imagemagick-0.0.3.7 (AlexanderVershilov)
14:23:45 <glittershark> Majiir: -fdump-simpl is what I do
14:23:58 <glittershark> Majiir: but that can be a little daunting (it certainly was for me)
14:24:11 <glittershark> Majiir: -ddump-simple, rather. My mistake
14:24:16 <glittershark> -ddump-simpl. dammit
14:24:21 <lamda_sage> dolio: Slowness or crashes (even though RAM is still available)
14:24:41 <glittershark> https://youtu.be/McFNkLPTOSY this was a pretty good talk that I stumbled on
14:24:42 <lamda_sage> dmwit: Thanks, a trie does make sense here
14:24:48 <dmwit> Majiir: The spineless-tagless G-machine paper is good for this.
14:25:18 <dmwit> http://twister.43foldrs.com/spineless-tagless-gmachine.pdf
14:25:19 <frerich> glittershark: Ah, that seems interesting, thanks for pointing that out!
14:25:50 <glittershark> in general GHC provides a *ton* of options for telling you what it's doing under the hood, if you're comfortable with Core/STG
14:25:56 <glittershark> which, admittedly, I am not.
14:26:46 * frerich blushes as he notices that that youtube link already *is* part of his 'Haskell stuff to look at when I have some time' list...
14:27:01 <Majiir> Thanks and thanks. I'm more interested in a general view so I can at least have some idea of how stuff is stored in memory, how evaluation proceeds, etc
14:27:13 <glittershark> hee
14:27:17 <dmwit> frerich: youtube link?
14:27:21 <bitemyapp> glittershark: ghc-core package gives you a way to get some prettier output, I think
14:27:30 <dmwit> frerich: never mind, I'm blind
14:27:31 <glittershark> yeah? I'll take a look at that, thanks
14:27:36 <bitemyapp> glittershark: failing that, the suppression flags help a lot too
14:27:44 <frerich> dmwit: I guess 'youtu.be link' would've been more accurate :-)
14:27:53 <bitemyapp> glittershark: http://hackage.haskell.org/package/ghc-core yeah so this has colorized output and the like
14:27:53 <Majiir> I read through the Reduceron paper and that was at least interesting
14:27:59 <glittershark> bitemyapp: I've had good luck with opening it in vim and doing :set ft=haskell.
14:28:05 <dmwit> frerich: Somehow my vgrep completely missed it. Not your fault for being imprecise.
14:28:10 <glittershark> -ddump-to-file already indents pretty well
14:28:30 <bitemyapp> glittershark: then -dsuppress-all makes the usual output a lot more readable.
14:28:38 <bitemyapp> glittershark: try it, if you haven't before. Way less noisy.
14:28:46 <dmwit> Majiir: The STG-machine paper is exactly about how stuff is stored in memory and how evaluation proceeds...
14:29:08 <Majiir> dmwit, I will give it a read :-)
14:29:15 <glittershark> I'll do that, bitemyapp, thanks
14:29:34 <bitemyapp> glittershark: I had a really hard time reading GHC Core before finding -dsuppress-all :)
14:29:44 <frerich> Majiir: Alas, I'd *really* like to avoid bitemyapp going ballistic again, so I'll refrain from mentioning that 'Programming in Haskell' (the book) has a nice chapter on evaluation strategies (innermost, outermost and whatnot). You can see the slides at http://www.cs.nott.ac.uk/~pszgmh/chapter12.pdf
14:29:45 <bitemyapp> glittershark: I think it was carter_cloud that told me about it.
14:29:50 <bitemyapp> glittershark: cheers :)
14:29:52 <frerich> Majiir: So again, I won't mention that.
14:30:11 <dmwit> bitemyapp: Cool, didn't know about -dsuppress-*
14:30:22 <bitemyapp> see! they're awesome flags.
14:30:32 <bitemyapp> GHC Core is a freakin' mess if you don't shut at least some of it off.
14:30:45 <ReinH> Majiir: you might also enjoy Thinking Functionally with Haskell for that.
14:33:20 <sphinxo> How would I turn this into a GADT? http://lpaste.net/148637
14:33:41 * hackagebot telegram-api 0.1.0.1 - Telegram Bot API bindings  https://hackage.haskell.org/package/telegram-api-0.1.0.1 (klappvisor)
14:34:18 <dmwit> sphinxo: It wouldn't be terribly to turn this into a GADT yet, but:
14:35:23 <dmwit> data Expr a where Lit :: Lit -> Expr Lit; (:+:) :: Expr a -> Expr a -> Expr a; (:*:) :: Expr a -> Expr a -> Expr a
14:35:27 <dmwit> would be one way
14:35:58 <dmwit> s/terribly/terribly useful/
14:36:39 <sphinxo> hmm ok
14:37:04 <srpx> Is it impossible to have list functions such as cons, nil, reverse on the simply typed lc?
14:37:17 <andromeda-galaxy> also, about ghcjs: Luite talked about using Cloud Haskell with ghcjs last May (https://yow.eventer.com/yow-lambda-jam-2015-1305/heterogeneous-computation-with-cloud-haskell-and-ghcjs-by-luite-stegeman-1899), but said that it wasn't possible to use it yet; does anyone know what the hcurrent status is?
14:37:33 <srpx> I would think it is since those need polymorphic functions, but, when I think about it, if you just don't annotate types and use inference, then you'll have proper solid types such as List Int, so that should work?
14:38:33 <sbrg> If I have a project that uses lts-3.10 and I'd like to convert to 4.0, how would I go about doing this? I would like the newer versions of the packages in the snapshot.
14:38:47 <srpx> i.e., you can't write "cons :: ∀ a . a -> List a -> List a", but you can leave the type later and allow the inferencer to see that, in "cons 1 []", "cons : Int -> List Int -> List Int"
14:39:00 <srpx> makes sense?
14:39:22 <dmwit> You can have `consInt :: Int -> List Int -> List Int`, yes.
14:39:38 <Tuplanolla> Yes, but where does that definition live before you specialize the type?
14:39:41 <dmwit> Provided your STLC has provision for data types at all, of course.
14:40:22 <dolio> Parameterized data types, too. Very advanced.
14:40:52 <dmwit> Oh, yes, it might have to be `consInt :: Int -> IntList -> IntList`. Good point.
14:41:13 <carter_cloud> bitemyapp: yeah was me.  Though I think Dolio then popularized it
14:41:54 <dolio> I'd be surprised. I was writing a vim mode to make ghc core less noisy because I didn't know about the suppress stuff when I gave a presentation on it.
14:42:11 <sphinxo> Could this be simplified? snd $ runIdentity $ runKleisli (elimWriter program) initial
14:42:20 <sphinxo> where initial = undefined :: n
14:42:52 <sphinxo> What am I doing: http://lpaste.net/148638
14:43:03 <sphinxo> have an lpaste
14:44:05 <sphinxo> X86_64 is type X86_64 a b = WriterArrow [Instr] (Kleisli Identity) a b
14:44:43 <srpx> dmwit: I see, but do you need a new definition of `cons` for each new specialized list type, or is it possible to have a single definition of cons?
14:45:08 <dmwit> I doubt you could have a single definition.
14:45:10 <srpx> dmwit: (I asked this on SO as I need to go, in case anyone is interested.)
14:45:34 <dmwit> Having a single definition is sort of the motivation for polymorphism in the first place.
14:46:28 <dmwit> In fact, let me strengthen from "I doubt" to just saying it: you can not have a single term with two different types in STLC.
14:47:17 <glittershark> how necessary is it to put in {-# INLINE #-} pragmas for nullary (basically constant) functions
14:47:20 <glittershark> ?
14:48:11 <bitemyapp> glittershark: what's a nullary function?
14:48:17 <bitemyapp> glittershark: you mean a constant function?
14:48:26 <dmwit> I think he means a constant.
14:48:31 <dmwit> As in, not a function at all.
14:48:34 <bitemyapp> oh
14:48:38 <glittershark> yeah
14:48:43 <glittershark> nullary meaning 0-arity
14:48:43 * hackagebot airship 0.4.2.0 - A Webmachine-inspired HTTP library  https://hackage.haskell.org/package/airship-0.4.2.0 (reiddraper)
14:48:44 <glittershark> sorry
14:48:46 <glittershark> words
14:48:50 <bitemyapp> if it's not a function, I don't think it's necessary.
14:48:55 <bitemyapp> there's no "body" to inline.
14:49:00 <glittershark> well, the body is a value
14:49:06 <glittershark> a string literal, in this case
14:49:11 <dmwit> It is likely a time/space tradeoff as usual. Bigger code size vs. only evaluating the stupid thing once.
14:49:31 <bitemyapp> I think dmwit has it.
14:49:36 <glittershark> does it make a difference that the annotated return value of the function is polymorphic?
14:49:36 <srpx> dmwit: ah, okay, thank you. So the whole point of system F is that it works kinda like a well behaved macro system, allowings you to write only one definition, but, after compilation, everything becomes a solid type...?
14:49:47 <bitemyapp> glittershark: This is like let-floating something out vs. having the literal mentioned multiple times.
14:49:50 <glittershark> `myFun :: IsString a => a; myFun = "some_value"`
14:50:00 <dmwit> srpx: Well, System F adds more than just polymorphism.
14:50:02 <dmwit> srpx: But yes.
14:50:04 <bitemyapp> glittershark: if it's polymorphic, it can't get shared anyway.
14:50:19 <glittershark> well, not unless I specialise it
14:50:24 <glittershark> which I will
14:50:32 <bitemyapp> you are good at adding wrinkles here
14:50:35 <srpx> What else does it add?
14:50:36 <glittershark> heh
14:50:52 <glittershark> this probably doesn't matter, I'm just curious about what GHC will do as a learning experience
14:51:20 <zoku> I want to parse a really basic string, building an entire parsec thing for it seems like overkill
14:51:20 <srpx> System F (...) is a typed lambda calculus that differs from the simply typed lambda calculus by the introduction of a mechanism of universal quantification over types. (from wikipedia) - you mean that universal quantification allows more than polymorphism? I thought they were synonymous.
14:51:25 <zoku> if I have "!connect hostname port"
14:51:33 <zoku> how can i just extract the hostname and poart
14:51:35 <dmwit> srpx: I was imprecise. What I meant was that it is in some sense the "maximally polymorphic" system you could have. You could imagine (and there are many extant) systems with less powerful polymorphism.
14:51:38 <zoku> there's no regex method/
14:51:49 <srpx> ah, makes a lot of sense, thank you :)
14:52:21 <dolio> I think it's also imprecise to say that the "same term" can't have different types in the simply typed lambda calculus.
14:52:24 <dmwit> srpx: System F includes higher-kinded polymorphism and quantification in arbitrary locations.
14:52:33 <c_wraith> zoku, turns out you don't need a regex to split on spaces
14:52:46 <dolio> In fact, one point is exactly that there are many types for the same term, and no one best type.
14:52:48 <dmwit> srpx: Compare Haskell 2010 which allows quantification only at the top level, or Scala which allows only *-kinded polymorphism.
14:53:16 <c_wraith> > words "!connect host port" -- zoku
14:53:18 <lambdabot>  ["!connect","host","port"]
14:53:22 <dolio> Although it may depend on whether you're Church or Curry style.
14:53:28 <dmwit> dolio: Yes, I was imprecise there, too. Thanks for the corrections.
14:53:37 <srpx> So Haskell 2010 is a little less powerful than system F, that's what you said.
14:53:51 <dmwit> Sure.
14:54:24 <dmwit> And there's lots of other little languages out there with other restrictions that you might also reasonably call "polymorphic" languages.
14:55:29 <zoku> ah, thank you c_wraith 
14:56:05 <srpx> The STLC has a lot of interesting properties. Is there any simple extension of it that allows for scott style lists without losing most of those properties (i.e., fix)?
14:56:43 <dmwit> What properties are you interested in?
14:56:57 <dmwit> (I almost certainly won't know the answer, though. =P)
14:58:47 <c_wraith> well, if fix is being objected to, I bet normalization is one of those properties 
14:59:07 <srpx> Strong normalization, having a decidable high order unification algorithm, etc
15:01:07 <srpx> I'm also interested in understanding the complexity boundaries of STLC programs. I think they are much smaller than other calculi, but I'm not sure they are well defined. 
15:01:22 <srpx> Actually the STLC looks really weird in what it can express and what it can not.
15:02:30 <dmwit> ...there's a decidable unification algorithm for STLC?
15:03:16 <dmwit> (Wikipedia disagrees.)
15:06:21 * srpx is trying to remember that paper
15:07:54 <dmwit> Anyway. I wouldn't be surprised if you could add polymorphic lists and a polymorphic fold operation as language primitives without breaking strong normalization.
15:08:12 <dmwit> unfold might be a problem, though.
15:08:49 <dmwit> The usual trick there is to annotate unfold operations with some strictly decreasing measure.
15:09:00 <dmwit> (So push the proof burden onto the programmer.)
15:09:01 * srpx gives up
15:10:05 <glittershark> is there some way to "get past" functional dependencies the way I can with overlapping/overlappable instances?
15:10:45 <glittershark> I have a library I'm depending on that defines an instance of MonadError for a monad transformer that I don't want to use for my type that's a specialization of that monad transformer
15:10:57 <jle`> hm i'm not sure what you mean by "get past".  but a lot of problems that are solved by FunDeps can also be solved in an alternative way using type families
15:10:59 <glittershark> this may make no sense at all, in which case ignore me
15:11:02 <dmwit> glittershark: newtype?
15:11:21 <glittershark> newtype could do it, yeah
15:11:45 <glittershark> if I controlled the library I depended on I'd refactor it to use type families, but I don't
15:11:48 <glittershark> wish I did
15:12:10 <srpx> dmwit: no, but I'd not like to extend the type system with ADTs, but use lambda encodings. I was looking for a type system that can express both church and scott style lists that is as simple as the stlc
15:12:18 <dmwit> I doubt that would help anyway if I'm understanding your problem correctly.
15:12:22 <xplat|work> but you can't spell FunDeps without Fun
15:12:29 <srpx> In an unrelated note, any idea how the lambda cube relates with light/linear type system? I can't make the connection
15:12:40 <srpx> I know both things exist but I don't see how they relate
15:13:31 <glittershark> looks like what I want to do isn't possible
15:13:32 <glittershark> dang
15:13:37 <xplat|work> srpx: the only type systems i know that handles church/scott encodings of 'interesting types' well are System F and i guess System Fw
15:13:44 <kaiyin> how do you from what package you are importing when you import something?
15:13:50 <kaiyin> how do you know.
15:13:50 <xplat|work> but they definitely aren't as simple as the stlc
15:13:59 <srpx> xplat|work: system F doesn't handle scott encodings, does it?
15:14:11 <glittershark> kaiyin: :i in ghci will tell you what file something is defined in
15:14:13 <srpx> even CC can't express them 
15:14:43 <kaiyin> glittershark: only if I have already imported it. 
15:15:24 <kaiyin> glittershark: when you read someone else's code, how do you which module is from which package?
15:15:32 <kaiyin> know.
15:15:36 <glittershark> heh
15:15:44 <glittershark> you clone the code
15:15:46 <xplat|work> oh, right, you need recursively typed System F for Scott encodings and that isn't nice like System F
15:15:52 <glittershark> and launch ghci on it :)
15:16:17 <kaiyin> ok. sounds tedious. 
15:16:37 <xplat|work> srpx: well, when it comes to encodings of ADTs as pure functions the usual notion of 'more expressive' sometimes doesn't hold
15:16:44 <frerich> kaiyin: You can also just stick a module name into e.g. Hayoo and see if it finds it in any package.
15:16:50 <Tuplanolla> Packages are specified in *.cabal files or with PackageImports, kaiyin.
15:16:54 <frerich> kaiyin: Like http://hayoo.fh-wedel.de/?query=Text.Parsec
15:17:13 <xplat|work> at least if you want a total language, i guess it works if you just blindly throw in impredicativity
15:17:44 <kaiyin> ok, thanks, guys. 
15:18:02 <sphinxo> I have these data structures http://lpaste.net/148639
15:18:05 <srpx> what is troubling me is that scott encodings look very total, well behaved. there is nothing recursive or wild about them
15:18:34 <srpx> looks unfair to remove them from a language, they can do useful things that you can't do without them
15:18:38 <sphinxo> how would I remove push r, pop r from a list of instr?
15:18:44 * hackagebot not-gloss-examples 0.5.1.1 - examples for not-gloss  https://hackage.haskell.org/package/not-gloss-examples-0.5.1.1 (GregHorn)
15:19:08 <lyxia> sphinxo: filter
15:19:33 <sphinxo> I kind of came up with something like this http://lpaste.net/148640
15:19:59 <lyxia> ah I misread you
15:20:20 <Tuplanolla> You can pattern match on x : y : zs or try this fun thing: zip <*> tail
15:20:45 <sphinxo> Could you explain zip <*> tail ?
15:21:04 <Tuplanolla> Try it and see.
15:21:37 <lyxia> I don't think it will be useful here
15:21:38 <sphinxo> hmm [a] -> [(a, a)]
15:21:56 <lyxia> But I agree with the suggestion of pattern matching
15:22:30 <xplat|work> srpx: 'you can do useful things with them that you can't do without them' is one of the two best reasons to remove something from a language
15:22:40 <sphinxo> How would I match for cases when they are both the same, instead of implemeting it for RAX, RBX ?
15:22:52 <xplat|work> srpx: the other being 'you can't do useful things with them that you can't do without them'
15:24:02 <lyxia> sphinxo: use guards: optimize (Push r : Pop r' : instrs) | r == r' = ...
15:24:50 <frerich> Where '...' would be just 'instrs' :-)
15:25:14 <sphinxo> oh my god, never seen that syntax before :)
15:25:21 <sphinxo> That is awesome
15:25:40 <sphinxo> Haskell why u gotta keep blowin my mind
15:25:41 <lyxia> hah
15:26:06 <lyxia> frerich: you might want to optimize them too :)
15:26:11 <srpx> xplat|work: I'm not sure I understand what you mean
15:26:28 <frerich> lyxia: True!
15:26:36 <exio4> sphinxo: one thing, you should keep the (x : xs) = x : optimize xs clause at the end
15:26:52 <kaiyin> how do you expose all modules in src/ with stack?
15:27:14 <xplat|work> srpx: one of the things you learn after some time is that very often the only way to be able to do one thing is to be unable to do something else
15:27:34 <sphinxo> Thanks, exio4 
15:27:43 <Tuplanolla> Test case to consider, sphinxo: Push x : Push y : Pop y : Pop x : zs.
15:27:59 <mgsloan> kaiyin: Add them to your "exposed-modules" list in your .cabal file
15:28:15 <kaiyin> mgsloan: do i have to add them individually?
15:28:16 <xplat|work> e.g. the only way to have general recursion is to be unable to determine whether code is reachable
15:28:22 <srpx> xplat|work: I think I see what you mean, but I feel like scott encoded adts are very inoffensive in that sense. Is that incorrect?
15:28:34 <sphinxo> Thanks Tuplanolla 
15:28:42 <jle`> i'm offended
15:29:08 <xplat|work> or the only way to have functional extensionality is to be unable to analyze the syntactic form of functions
15:29:17 <kaiyin> mgsloan: I would like to specify all of them without listing single filenames. Like * in linux shell.
15:29:32 <Tuplanolla> You'll see that a single pass with mere pattern matching won't work, sphinxo.
15:30:18 <sphinxo> Hows this? http://lpaste.net/148641
15:31:01 <sphinxo> Any other optimizations I could do?
15:31:13 <mgsloan> kaiyin: You might like https://github.com/sol/hpack .  It generates .cabal files, and allows a more concise specification, including inferring lists like exposed-modules / other-modules
15:31:13 <Tuplanolla> How's this: Push x : Push y : Push z : Pop z' : Pop y' : Pop x' : zs?
15:31:25 <mgsloan> kaiyin: It's pretty new, and still WIP.  Looks promising, though.
15:31:41 <frerich> sphinxo: *Any* sequence of Push,Push,Push..Pop,Pop,Pop which is symmetric can probably be dropped.
15:31:43 <exio4> Tuplanolla: let's just keep optimizing until there's no remaining optimization to apply
15:31:51 <sphinxo> Thanks
15:31:53 <Tuplanolla> Very good.
15:32:00 <exio4> Tuplanolla: I hacked it that way >:D 
15:32:10 <kaiyin> ok. thanks.
15:32:15 <sphinxo> frerich: Is there any neat way of doing that?
15:32:16 <exio4> sphinxo: which language are you optimizing?
15:32:18 <frerich> sphinxo: What does your 'Instr' type look like? Just push and pop?
15:32:29 <exio4> brainfuck?
15:32:42 <frerich> exio4: I think brainfuck has no push and pop
15:32:46 <sphinxo> and set, add and mul 
15:33:04 <Tuplanolla> This problem is especially nice when your optimizations aren't always reductions.
15:33:27 <sphinxo> I'm writing (trying to at least) a little stack based compiler
15:33:28 <Tuplanolla> It becomes rewriting problem and the existence of a fixed point must be proven by hand.
15:33:45 <lyxia> compiledPrg = fix optimize -- bad idea
15:33:52 <frerich> sphinxo: You could optimize subsequent 'set' to the same variable to just use the same variable. Or 'add 0 x' and 'mul 1 x' being dropped. but it can get trick: e.g. 'mul 0 x' could be a 'set' command and then the first optimization may be applicable.
15:34:45 <frerich> If you have no I/O, you could just evaluate the program and end with a single 'set' or so :-)
15:34:51 <sphinxo> :)
15:35:05 <sphinxo> I'm going to lower to asm :) 
15:35:14 <sphinxo> I'll have some IO
15:35:45 <Tuplanolla> This is useful if your rules have no structure, but definitely terminate: fixUntil :: (a -> a -> Bool) -> (a -> a) -> a -> a.
15:37:16 <srpx> dmwit: so high order unification is decidable on the pattern fragment, and there are 80680 papers about that, but I really remember a guy on reddit pmed me pretty excited about something about a new result on unification on the stlc, and that he was trying to implement it
15:37:23 <srpx> I hate when I can't remember cool things
15:37:41 <sphinxo> Tuplanolla: What do you mean by rules?
15:37:48 <ReinH> lyxia: but almost a good idea
15:38:01 <xplat|work> 'higher order matching is decidable' is a newish result (like 2 or 3 years i think?)
15:38:24 <ReinH> (btw these optimizations are also used for optimizing brainfuck compilers)
15:38:35 <ReinH> including the one written in sed
15:38:58 <hpc> ReinH: i don't like any part of what you just said :P
15:38:59 <Tuplanolla> I mentioned rewriting, which refers to a system determined by rules, sphinxo. In this case your rule is that [Push x, Pop x] reduces to [] for all x.
15:39:05 <sphinxo> ahh ok
15:39:07 <ReinH> as well as optimizations like replacing [-] with Set 0
15:39:09 <kadoban> optimizing brainfuck compiler, in sed. That sentence (fragment) just goes right to hell.
15:39:16 <srpx> Why is the λ-calculus regarded as more interesting than interaction nets as the underlying system?
15:39:18 <ReinH> it's a fun story :)
15:39:52 <xplat|work> it isn't, or rather, that depends on the person?
15:40:01 <ReinH> kadoban: it outputs an ELF binary!
15:40:12 <sphinxo> ReinH: wut
15:40:13 <kadoban> ReinH: Lol … jesus.
15:40:15 <srpx> xplat|work: ah that was the term i was looking for, thanks. That was the dissertation: http://homepages.inf.ed.ac.uk/cps/journal.pdf cool!
15:40:16 <ReinH> kadoban: it is very easy to read.
15:40:19 <ReinH> https://github.com/stedolan/bf.sed
15:40:26 <hunteriam> can i do `m <- Just y` in a MaybeT?
15:40:35 <sphinxo> Some people just want to watch the world burn
15:40:54 <ReinH> Once you read it you'll think "Oh, that's obvious"
15:41:08 <srpx> now I have to read it and undersatnd what it means and how it is different from the previous result about "the pattern fragment"
15:41:09 <kadoban> ReinH: "If you have an urge to see the assembly produced by this script, I recommend [seeking professional help]"
15:41:12 <xplat|work> ReinH: the necronomicon is also easy to read.  it's *un*reading it that's the hard part.
15:41:28 <frerich> ReinH: Tsk, it obviously neglects to cover [[-]] being Set 0, too!
15:41:46 <hunteriam> can i do `m <- Just y` in a MaybeT?
15:41:53 <ReinH> frerich: Yes it does https://github.com/stedolan/bf.sed/blob/master/bf.sed#L46
15:41:56 <sphinxo> Any improvements on this? http://lpaste.net/148642
15:41:56 <xplat|work> srpx: you could treat 'matching' as the fragment of unification where one of the terms is closed already
15:42:09 <ReinH> it's the first optimization made
15:42:12 <frerich> ReinH: Yes but only [-], not [[-]]
15:42:14 <kadoban> ReinH: That is a pretty amazing project. I wonder what inspired that …
15:42:18 <frerich> Or [[[-]]]
15:42:19 <xplat|work> which is both more and less restrictive than forcing both to be patterns
15:42:21 <ReinH> frerich: Oh. Yes.
15:42:27 <ReinH> frerich: you should submit a bug report.
15:42:40 <frerich> ReinH: Of course, I immediately saw it from the code without looking at the comments at all. They are misleading at best.
15:42:46 <ReinH> :)
15:43:03 <srpx> so, something like: closed_term = term_with_free_variables is unifiable? How is that not awesome? Why isn't everyone talking about that?
15:43:46 <xplat|work> srpx: it is awesome and everyone i knew was talking about it when it first came out
15:44:16 <srpx> And if that was true couldn't I do something like (f 1, f 2, f 3) = (2, 4, 6) and then it would automatically program the "double" function by example?
15:45:00 <xplat|work> srpx: no, the fragment of functions it handles doesn't include 'case'
15:45:09 <srpx> xplat|work: and what came from that? What kind of people you know that talk about this? My friends talk about soccer and beer :(
15:45:24 <StoneToad> srpx: isnt' that why you're in #haskell?
15:45:38 <xplat|work> srpx: i guess i should say 'all the CS people i know'
15:45:54 <xplat|work> i also know people who don't really know CS
15:46:10 <srpx> xplat|work: so, what came from it? What is that place people talking about it and that kind of stuff?
15:46:33 <xplat|work> srpx: er, wait, that's wrong.  you still can't do that but for a different reason
15:46:43 <srpx> xplat|work: hm
15:46:58 <sphinxo> Thank you everyone who helped me. Goodnight IRC
15:47:27 <xplat|work> srpx: or maybe it was.  i'm trying to remember.  maybe you should just read the dissertation and see what it claims directly instead of using my lousy memory :)
15:48:36 <xplat|work> srpx: i think people were excited about it, only nobody who read it understood how to implement that algorithm in a real compiler, it's not exactly straightforward ...
15:48:36 <suppi> does Data.Label (from fclabels) compose in the opposite direction of Control.Lens (from lens)?
15:49:04 <ReinH> frerich: at least [[-]] and etc are pathological :)
15:49:13 <frerich> ReinH: Still, https://github.com/stedolan/bf.sed/issues/1
15:49:17 <ReinH> as in, the only reason to write them would be to frustrate an optimizing compiler
15:49:43 <ReinH> I love that you made an issue. I love that it is the first issue.
15:49:45 <srpx> I'm reading xplat|work - but please let me in that cool kids club that talks about that kind of stuff, I promise I won't ask stupid questions (a lot)
15:50:00 <frerich> ReinH: In principle, that construct can happen as a result of other optimizations, e.g. '[>><><<[-]><<>]'
15:50:09 <ReinH> frerich: ah.
15:50:11 <xplat|work> srpx: in a real compiler ideally you'd want to take some kind of union of the matching fragment and pattern fragment by doing dynamic unification, and the algorithms are completely different
15:50:13 <srpx> The places I read don't talk about that, is there some blog or something?
15:50:41 <ReinH> frerich: except that they don't optimize brainfuck into brainfuck
15:51:09 <xplat|work> srpx: maybe hang out on #agda?  i also used to be on #epigram in the past but it's dead now.
15:51:24 <ReinH> i.e., they wouldn't replace that with [[-]] in the first place.
15:51:25 <srpx> also, that paper is clearly about the simply typed lambda calculus, so that's what I remembered, dmwit . I wonder why it doesn't work on system f & such, though
15:51:36 <frerich> ReinH: That's what they get for translating and optimizing in one go!
15:51:38 <srpx> xplat|work: :( okay i'll idle there
15:51:42 <ReinH> frerich: :)
15:53:20 <frerich> ReinH: https://github.com/frerich/brainfuck/blob/master/samples/dbfi.b <-- a BF interpreter, in BF.
15:55:01 <srpx> xplat|work: also, provided someone implements it (I still don't understand why aren't we all crowdfounding that, if it is so nice), what kind of cool uses would that have?
15:55:21 <ReinH> frerich: o_O
15:56:30 <ReinH> frerich: you and your finite tape
15:56:30 <xplat|work> srpx: we weren't all crowdfunding it because of some combination of 'we po'' and 'there ain't too many of us' and 'but why should i fund you to do it?  you should fund me!'
16:01:47 <srpx> xplat|work: but what about the cool uses
16:01:59 * srpx can't think in anything other than automatic programming
16:04:26 <srpx> oh wait, I just had an insight, system-f programs can easily be translated to STLC programs, no? So if that algorithm works for the STLC, it is the same as saying it works for system-f too
16:05:20 <srpx> I mean, non-polymorphic system-f programs. You can find solid types for everything, so you can just create a STLC version from it by duplicating a lot of code (no?)
16:07:21 <srpx> i.e., if you use a polymorphic `cons` definition with 2 different types, you just split it into 2 different functions, `consInt`, `consBool`. Then you have a STLC program! 
16:07:55 <srpx> (with 2 different types = that is instantialized with two different types later on)
16:16:49 <hunteriam> anyone know a function `m a -> a -> m (Maybe a) -> m a`?
16:17:29 <exio4> what'd it do? 
16:17:44 <osa1> what is the simplest template libarary on hackage? I just need to replace {{foo}}s in a file with some strings and dump the output.
16:17:58 <hunteriam> or really `m a -> m (Maybe a) -> m a`
16:18:09 <hunteriam> take Maybe a if Just a, m a otherwise
16:22:17 <verement> :t liftM2 fromMaybe
16:22:18 <lambdabot> Monad m => m r -> m (Maybe r) -> m r
16:23:47 * hackagebot ieee754 0.7.8 - Utilities for dealing with IEEE floating point numbers  https://hackage.haskell.org/package/ieee754-0.7.8 (PatrickPerry)
16:24:04 <hunteriam> ty
16:31:02 <dmwit> hunteriam: beware that `liftM2 fromMaybe` will perform the side effects of both actions even if the second produces a `Just`.
16:31:17 <dmwit> hunteriam: As for your earlier question, you wouldn't be allowed to do `v <- Just y`, but you could do `v <- return y`.
16:31:46 <dmwit> hunteriam: You would also me able to do `v <- hoist (Just y)`, using the mmorph package.
16:32:01 <hunteriam> should I use ErrorT to avoid the extra side effects?
16:32:06 <hunteriam> EitherT*
16:32:35 <dmwit> ExceptT is nice in many cases, yes.
16:33:24 <sea``> !seen SamanthaD
16:33:40 <sea``> There's no !seen bot in here, either? Has anyone seen SamanthaD?
16:34:32 <dmwit> Oh, I guess `hoist` actually wouldn't work in this case.
16:35:10 <dmwit> :t maybe empty return :: Maybe a -> MaybeT m a
16:35:12 <lambdabot>     No instance for (Monad m1) arising from a use of ‘empty’
16:35:12 <lambdabot>     Possible fix:
16:35:12 <lambdabot>       add (Monad m1) to the context of
16:35:20 <dmwit> :t maybe empty return :: Monad m => Maybe a -> MaybeT m a
16:35:21 <lambdabot> Monad m => Maybe a -> MaybeT m a
16:35:27 <shachaf> sea``: Not for a long time.
16:36:32 <sea``> shachaf: Yeah, same thing here. I thought that was odd. Worse, I need to get a book from them.
16:37:57 <hunteriam> :t MaybeT . return
16:37:59 <lambdabot> Monad m => Maybe a -> MaybeT m a
16:38:24 <ReinH> dmwit: how do you propose that such a function not execute the action of the m (Maybe a) while still determining whether it is a Just or a Nothing?
16:38:36 <hunteriam> thats not the problem ReinH 
16:38:42 <hunteriam> you determine if the second is just or nothing
16:38:45 <dmwit> ReinH: I propose that it only execute the action of the `m a` if the `m (Maybe a)` is `Just`.
16:38:47 * hackagebot gdo 0.1.0 - recursive atomic build system  https://hackage.haskell.org/package/gdo-0.1.0 (seppeljordan)
16:38:50 <hunteriam> dmwit says it executes the first either way
16:39:07 <ReinH> dmwit: Ah.
16:39:08 <dmwit> It's easy to fix if it's something you care about.
16:39:15 <dmwit> But first you should decide if you care. =)
16:39:18 <hunteriam> i do
16:39:22 <dmwit> Okay, then:
16:39:45 <dmwit> :t \def possible -> do { v <- possible; maybe m return v }
16:39:46 <lambdabot>     Couldn't match expected type ‘m b’ with actual type ‘Expr’
16:39:46 <lambdabot>     Relevant bindings include
16:39:46 <lambdabot>       v :: Maybe b (bound at <interactive>:1:23)
16:39:55 <dmwit> :t \def possible -> do { v <- possible; maybe def return v }
16:39:56 <lambdabot> Monad m => m b -> m (Maybe b) -> m b
16:40:10 <dmwit> :t \def possible -> possible >>= maybe def return
16:40:11 <lambdabot> Monad m => m b -> m (Maybe b) -> m b
16:41:23 <hunteriam> :t (>>=)
16:41:24 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:46:51 <dgpratt> ReinH, I had to go do something productive for a bit, but I came back to my problem and did eventually figure it out
16:46:56 <dgpratt> thanks to your help
16:48:11 <dgpratt> although the process I followed was definitely closer to trial-and-error than...well I was going to say "than scientific", but it occurrs to me that trial-and-error is pretty scientific
16:50:37 <dgpratt> is there a name for the algorithm that @djinn uses to figure stuff out?
16:54:37 <johnw> dgpratt: here's a more complex form of djinn: http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi
16:54:46 <johnw> not sure about a single name for the algorithm, though
16:55:22 <johnw> funny that djinn doesn't use the free-theorems package
16:55:54 <dgpratt> thanks, johnw, I'll check that out
16:58:08 <orion> Just by looking at a data type, how can you tell that it has a monadic structure?
16:58:34 <johnw> by asking yourself what a -> f a, and f (f a) -> f a would mean
16:59:57 <hpc> sometimes it's not obvious
17:00:16 <hpc> it often is though, to the trained eye
17:00:35 <hpc> there's a few patterns that happen a lot, like Reader, Writer, Cont, etc
17:01:12 <shergill> is there a way to ensure that haddock code blocks get verified by the compiler?
17:01:55 <peddie> shergill: you could use doctest to turn your code examples into unit tests
17:03:43 <orion> johnw: Why "f (f a) -> f a" and not "m a -> (a -> m b) -> m b" ?
17:04:08 <ReinH> orion: or that.
17:04:18 <ReinH> Sometimes join is easier, sometimes bind.
17:04:41 <orion> But if bind doesn't make sense, then it's not a monad, right?
17:04:54 <johnw> I'm one of those that finds it much easier to think in terms of join, even if it's easier to implement in terms of bind
17:04:55 <ReinH> Either way
17:07:01 <ReinH> you can either use return and bind or return, join, and fmap. Both are equivalent and either can be recovered from the other.
17:07:25 <ReinH> Haskell prefers the return and bind formulation while category theory uses return, join, and fmap
17:09:55 <shergill> peddie: thanks for doctest :)
17:10:47 <peddie> shergill: you're welcome -- note that in addition to ordinary expressions, you can put quickcheck properties in your comments and have doctest check them
17:11:20 <shergill> peddie: that is awesome
17:12:27 <dmwit> dgpratt: Not an algorithm name, but that field of research is generally called "proof search".
17:13:02 <dmwit> I don't think it's particularly related to free theorems, though I've been wrong about this kind of thing before.
17:14:09 <hunteriam> having servant troubles
17:14:13 <dgpratt> I see, thanks  dmwit
17:47:00 <lamefun> http://hackage.haskell.org/package/free-4.12.1/docs/Control-Monad-Trans-Free-Church.html - why doesn't it implement MonadMask?
17:50:16 <RyanGlScott> lamefun: Probably because Ed forgot to write it. Write a pull request!
18:13:23 <Ygg> Hello 
18:13:27 <Ygg> I found this tutorial
18:13:33 <Ygg> http://roy-t.nl/index.php/2014/01/16/building-sdl-on-windows-for-use-with-haskell-cabal/
18:14:01 <Ygg> but for some reason cabal yells at me
18:14:03 <Ygg> at the last step
18:14:59 <pavonia> With what error?
18:15:43 <Ygg> unrecognized target '?extra-include-dirs=C:\SDL\include'
18:15:49 <Ygg> and the same for lib
18:16:07 <greg> if two types have the same algebra are they isomorphic?
18:16:22 <greg> am i just talking nonsense?
18:16:40 <RyanGlScott> Ygg: That website renders "--" as "–" mistakenly
18:16:52 <RyanGlScott> The command should actually be
18:16:59 <RyanGlScott> cabal install SDL --extra-include-dirs=C:\SDL\include --extra-lib-dirs=C:\SDL\lib
18:18:29 <Ygg> ah well, that's what I thought at first but when I tried that
18:18:45 <Ygg> unrecognized cabal install option '--blahblahblah'
18:19:38 <RyanGlScott> Ygg: Uh, it's not actually printing out "blahblahblah", right? Because I don't know what that means.
18:20:04 <Ygg> ofc not, I'm just too lazy to type the full thing
18:20:42 <RyanGlScott> Well then copy-paste it to http://lpaste.net/, because I can't read your mind
18:20:46 <Ygg>  '-?extra-include-dirs=C:\SDL\include'
18:21:33 <RyanGlScott> Are you sure you typed "--" (two hypens) and not "-–" (a hyphen followed by an en dash)?
18:21:47 <RyanGlScott> The fact that something rendered as a question mark leads me to believe it's the latter
18:22:09 <Ygg> I am pretty sure I did it correctly but I'll doublecheck I guess
18:23:20 <Ygg> ...
18:23:36 <Ygg> Apparently the copied hyphens from the site don't work
18:24:39 <Ygg> I had to retype the whole thing. Weird. 
18:25:26 <RyanGlScott> BTW, when I use Windows, I prefer to use MSYS2 rather than MSYS—it comes with its own package manager, and you can install SDL directly
18:25:52 <RyanGlScott> Also, it installs everything in standard locations, so you can define LIBRARY_PATH and C_INCLUDE_PATH to encompass them
18:26:04 <RyanGlScott> So you don't have to type --extra-whatever-dirs every time you install a C package
18:27:22 <Ygg> I should look into that, thanks
18:28:07 <RyanGlScott> No problem—I've spent too many hours trying to get things working on Windows, so I've acquired lots of obscure knowledge on the topic :)
18:28:31 <dedgrant> RyanGlScott: Represent :)
18:29:43 <karchnu>     Un format assurant la confidentialité du texte JSON par chiffrement, JWE (JSON Web Encryption),
18:29:45 <karchnu>     Un format assurant l'intégrité et l'authenticité du texte JSON par signature numérique, JWS (JSON Web Signature),
18:29:47 <karchnu>     Un format pour représenter les clés cryptographiques utilisées, JWK (JSON Web Key).
18:29:56 <orion> It's wild to me that List is a Free Monad.
18:29:58 <karchnu> sorry, the mouse just fall off :D
18:30:19 <Ygg> How do I use MSYS2 over Mingw32 ? do I just put it in the PATH instead once it's installed ?
18:30:49 <RyanGlScott> Ygg: OK, terminology time
18:31:23 <Ygg> sure
18:31:25 <RyanGlScott> MinGW is a development environment for making native Windows apps
18:31:43 <RyanGlScott> MSYS (and it's spiritual successor, MSYS2) is a shell for developing with MinGW
18:32:15 <RyanGlScott> So installing MSYS2 comes with MinGW/MinGW-w64 (depending on your architecture)
18:32:20 <Ygg> Ok.
18:32:34 <RyanGlScott> None of these should be confused with Cygwin, BTW — that's a completely separate thing
18:32:40 <shanemikel> hmm, I'm new, haven't got around to learning module management, so can somebody help me figure out why Data.Natural isn't availiable
18:32:46 <shanemikel> (installed)
18:33:47 <shanemikel> or how to find/install it with cabal
18:33:53 <boj> shanemikel: you need to install the naturals package
18:34:16 <boj> shanemikel: should simply be "cabal install naturals"
18:34:45 <Ygg> I see.
18:34:46 <shanemikel> oh yeah, i see that now, at the top of the haddock documentation I'm reading (natural-numbers-0.1.2.0)
18:34:59 <boj> :)
18:35:44 <shanemikel> I was confused by the fact it's part of the Data module, I assumed that everything under there was part of the standard library
18:36:09 <shanemikel> (and I didn't realize I was on the hackage subdomain)
18:36:17 <boj> it's more like a shared community namespace
18:38:33 <boj> shanemikel: this is the bundled stuff in the Prelude https://hackage.haskell.org/package/base
18:38:51 * hackagebot postgresql-connector 0.2.3 - Initial project postgresql-connector from stack  https://hackage.haskell.org/package/postgresql-connector-0.2.3 (markfine)
18:39:32 <shanemikel> I'd like a natural number data type that doesn't use an internal representation equivalent to linked lists (Like the Peano type), and offers different types for constituents of the set N0 and N1
18:39:54 <shanemikel> s/set/sets
18:40:11 <shanemikel> that is, the set of natural numbers including 0, and natural numbers excluding 0
18:41:38 <shanemikel> Or, perhaps a better solution, a way to bring domain/codomain definition/typechecking into any numeric types, that way I could use Integer
18:43:47 <Ygg> How can I install SDL directly using MSYS2 ?
18:43:56 <shanemikel> The way to do this in mathematics, introducing predicates into set definition, is there a way to do this with types?
18:44:36 <pikajude> if my library, which contains most of the code, is built with -O0, then my executable, which imports the library, is built with -O2, what kind of performance will i get?
18:44:45 <RyanGlScott> Ygg: Use pacman (PACkage MANager)
18:44:56 <RyanGlScott> I can never remember what things are named, so search for it by using
18:44:59 <RyanGlScott> pacman -Ss sdl
18:45:14 <Ygg> I can get pacman on Windows
18:45:15 <Ygg> wow
18:45:31 <RyanGlScott> MSYS2 is one of the only things I like about Windows :)
18:45:50 <RyanGlScott> Any, I think the package you want is something like mingw-w64-x86_64-SDL
18:46:15 <shanemikel> pikajude: don't really know the answer to that, but it seems like algorithms defined within your library will exhibit the performance characterstics of the optimizations they were compiled with
18:46:16 <RyanGlScott> (Make sure it has the mingw-w64-x86_64- prefix, so you know it's a native package and not an MSYS2-specific thing)
18:46:59 <Ygg> Yep, it's that
18:47:24 <Ygg> I was very close to just installing manjaro on the side and tinkering with haskell on it
18:47:52 <Ygg> Never even knew about MingW, Cygwin or Msys2 before
18:47:53 <RyanGlScott> Ygg: Well, don't get cocky yet — it's Windows, there's still many ways for things to go horribly awry
18:48:31 <RyanGlScott> And if I can't figure it out, I'll have to swallow my pride and ask Phyx- :)
18:48:55 <RyanGlScott> So if you want to avoid having to type --extra-lib-dirs/--extra-include-dirs, you can define the following environmental variables
18:49:30 <RyanGlScott> C_INCLUDE_PATH=/mingw64/include
18:49:36 <shanemikel> is mysys2 an analog to cygwin?
18:49:45 <RyanGlScott> shanemikel: I'll get to that in a second
18:49:56 <RyanGlScott> LIBRARY_PATH=/mingw64/lib
18:50:20 <Ygg> Do I just create those environmental variables ?
18:50:31 <RyanGlScott> And put /mingw64/bin on your PATH (so that stuff will run correctly if you invoke an executable in, say, cmd.exe instead of MSYS2)
18:51:04 <Pamelloes> in a MonadPlus, are empty and mzero the same thing?
18:51:06 <Ygg> that I did already because I actually ran the first install attempt from cmd
18:51:11 <shanemikel> you should put it in your shells .profile
18:51:46 <RyanGlScott> There's lots of ways of doing it — Windows has its own little settings menu for it, which is where I do it
18:51:54 <RyanGlScott> (environmental variables, that is)
18:52:31 <shanemikel> oh, srry got that reversed
18:52:53 <Ygg> Yep, that's where I am
18:53:24 <RyanGlScott> OK. In theory, all you need to do now is run cabal install SDL
18:53:43 <Ygg> Okay then
18:53:51 <RyanGlScott> Disclaimer: I've never installed SDL on Windows before, so fingers crossed
18:54:54 <Ygg> guh
18:55:03 <RyanGlScott> shanemikel: BTW, Cygwin is a POSIX emulation layer for Windows. Unlike MinGW, Cygwin libraries aren't Windows-native and require Cygwin to run.
18:55:13 <RyanGlScott> Ygg: Bad news?
18:55:36 <Ygg> Nah nah
18:55:54 <Ygg> It's just that I forgot to actually run pacman -S mingw-w64-x86_64-SDL
18:56:05 <Ygg> worked like a charm
18:56:33 <hunteriam> http://lpaste.net/148644
18:56:33 <hunteriam> why is subserver type `Server _` and not `Int -> Server a`
18:56:33 <hunteriam> *`Int -> ServerT a`
18:56:46 <RyanGlScott> Nice! But again, don't count your eggs just yet.
18:56:57 <RyanGlScott> The real test is to try running an SDL Haskell program.
18:57:12 <shanemikel> afaik (may be irrelevant, or specific to archlinux), when using pacman to install (sync) it's always recommended to pass the y flag
18:57:25 <RyanGlScott> GHC's linker has been known to have... interesting behavior when interacting with certain C libraries
18:57:44 <mnrk> Just started messing around with Haskell, feels like my brain's turning inside-out
18:58:21 <Ygg> IKr
18:58:35 <mnrk> Anyone know anything about I and what the fuck it does?
18:58:40 <Ygg> AAAH RYAN IT WORKS IT JUST WORKS
18:58:47 <Ygg> Thanks a billion
18:58:49 <mnrk> I'm following a tutorial that uses it
18:59:15 <shanemikel> know anything about It and what the fuck it does? is the 'It' in that question Haskell?
18:59:25 <RyanGlScott> Ygg: np
18:59:32 <mnrk> No, no, "I", in the following context
18:59:49 <RyanGlScott> Is there a Haskell SDL example program on the Internet, BTW?
18:59:57 <mnrk> trapezoidalRule fs (I (a,b) n) = ...
19:00:18 <ReinH> These are some strange questions.
19:00:28 <Ygg> I think there might be, I needed SDL for helm actually
19:00:34 <RyanGlScott> Ah, try this for a demo: https://github.com/snkkid/LazyFooHaskell/blob/master/lesson01/lesson01.hs
19:00:38 <mnrk> best kind of questions
19:00:41 <shanemikel> well, first of all, I is pattern matching a data constructor
19:00:55 <ReinH> Is you?
19:01:00 <RyanGlScott> lolwut
19:01:05 <mnrk> Okay, that makes a lot more sense
19:01:24 <mnrk> The code block just didn't run, so I couldn't figure out what it was meant to do
19:01:37 <mnrk> Super beginnering over here
19:02:12 <mnrk> I've probably missed a chunk that's meant to go before it
19:05:10 <shanemikel> and the (a, b) is pattern matching a pair (tuple) (in order to extract the first and second members without using accessor functions)
19:05:11 <mnrk> Maybe this tutorial is just shithouse
19:05:14 <shanemikel> or projections
19:05:34 <rvxi> arr "ordeal" is a really unfortunate name for a haskell package..
19:05:37 <mnrk> Yeah, the (a,b) made sense to me
19:05:48 <mnrk> I'm getting a Not in scope: data constructor 'I'
19:05:52 <mnrk> so something's exploding there
19:06:13 <shanemikel> well, it'd be helpful to know what I is supposed to be
19:06:25 <mnrk> You're telling me
19:06:33 <mnrk> this is the whole thing, as far as I can tell
19:06:34 <shanemikel> the tutorial should mention it
19:07:13 <mnrk> I checked before I got on here, but I'll double check so that I don't look like a total asshole
19:07:38 <mnrk> I'm following this thing
19:07:40 <mnrk> https://www.schoolofhaskell.com/user/Sam567/computational-physics/beginner-s-tools/simple-integration#why-bother-with-integraloflist---first-reason-
19:08:02 <orion> If I wrote "f x = x + 1" could I call f a monomorphism?
19:08:30 <mnrk> Trying to just make the code snippet for the trapezoidal rule run
19:09:11 <shanemikel> I'm not personally offended, but I believe it's better to avoid certain language in this particular channel
19:09:28 <shanemikel> just FYI
19:09:50 <bramantio> hello all
19:09:55 <mnrk> Oh, sorry, my bad. Everyone throws it around like it's nothing here, so I forget that it's a thing elsewhere.
19:10:30 <rvxi> hi bramantio
19:11:23 <bramantio> i goes to learn haskell in book.realworldhaskell.org
19:11:25 <shanemikel> I don't know, I may be able to help better if I was familiar with the physics, it could be that the author of the tutorial believed the data type was obvious enough (given the domain, or particular function) that it didn't need to be explained
19:12:15 <shanemikel> oh, nvm that's calculus
19:12:17 <shanemikel> not physics
19:12:17 <mnrk> It's just a thing for approximating the area under the function using trapezoids
19:12:18 <mnrk> yeah
19:12:43 <mnrk> I'm probably just biting off more than I can chew by trying to use this
19:13:07 <bramantio> and i haved to setup my xmonad desktop, and got wrong coded.
19:13:17 <bramantio> These errors come from trying to write expressions that don't make sense, such as using an integer as a function. For instance, if a function expects to work with integers, and we pass it a string, a Haskell compiler will reject this.
19:14:03 <shanemikel> so here they're defining the data type `Interval` represented by an individual data constructor I (Double, Double) Int
19:14:04 <anohigisavay> hi
19:14:07 <Pamelloes> How do I export an associated data instance?
19:14:20 <shanemikel> in the line `data Interval = I (Double, Double) Int`
19:14:25 <mnrk> Oh, fuck, that's right, the definition goes both ways
19:14:32 <mnrk> Ah, sorry, swore again
19:14:33 <mnrk> sorry
19:14:34 <bramantio> is builded my sense to be enjoyfuly for summoning my system
19:14:39 <mnrk> It's seriously automatic
19:15:13 <anohigisavay> in a `par` b `pseq` (a+b), if b must be evaluated before a+b, how does ghc get to evaluate a in parallel with b?
19:15:40 <mnrk> Hmm, interesting
19:15:52 <mnrk> Well, that clears up a lot about Haskell's syntax for me
19:16:07 <ReinH> orion: in what sense?
19:16:42 <shanemikel> well, it may be helpful to read a thourough explanation of the type system (I'm rather new, myself), but it's important to remember, at this point, that pattern matching can only happen on data constructors (like I), where types are only used in type declarations (occurring after ::, and they're not important during program execution, but during the typechecking process)
19:17:03 <bramantio> sense to run system monitoring in xmonad
19:17:09 <ReinH> orion: it is both injective and monic in the category theory sense
19:17:20 <mnrk> Yeah, I read through some stuff yesterday and was hoping to grab some working code to make it all stick in my head
19:17:25 <mnrk> and just got stuck on this
19:17:32 <RyanGlScott> Pamelloes: Try exporting DataFam(FamInstanceConstructor))
19:17:43 <RyanGlScott> Or just DataFam(..)
19:18:06 <mnrk> Looks like I forgot most of it already
19:18:06 <Pamelloes> RyanGlScott: Yep! Just found that in the GHC docs :)
19:18:25 <bramantio> http://book.realworldhaskell.org/read/types-and-functions.html
19:18:40 <bramantio> these helped me fully ;)
19:18:54 <shanemikel> I'm personally using the http://haskellbook.com/ (but it's a work in progress, and not freely available, not to mention long), and I've enjoyed reading learnyouahaskell.com (which is freely available)
19:19:02 <ReinH> orion: one way to tell is that all left invertible morphisms are monic and subtract 1 . f = id
19:19:26 <ReinH> At least, it is so for Integer.
19:19:57 <mnrk> Yeah, I've been using learnyouahaskell, which reads really nicely
19:20:24 <mnrk> I'm just actually trying to implement this specific calculus stuff for the sake of other learning exercises which is why I went for this
19:20:31 <bramantio> i haved read it about mathematic and calculator program using ghci
19:20:49 <ReinH> (and since generally fixed-size numbers wrap, it's true for those too)
19:21:42 <Welkin> ／wc
19:21:47 <mnrk> Thanks for the various tips
19:21:49 <shanemikel> mnrk: something I seriously appreciated about haskellbook.com, is that they went to great lenghts to solidify my understanding of specialization, namely, when it happens, which can be really helpful to undeerstand certain type failures
19:21:54 <mnrk> I think I would have been stuck a lot longer
19:21:55 <Welkin> lol, chinese unicode
19:23:19 <shanemikel> typechecking failures.. like when using the Num methods, or enjoying the syntactic sugar of numeric literals, while understanding the type inference comes at a cost (namely there are default data types for Integral and Floating)
19:27:18 <anohigisavay> http://lpaste.net/148645
19:27:26 <orion> ReinH: I see.
19:27:37 <rvxi> shanemikel damn i swear everyone suddenly jumped on haskelbook all of a sudden
19:28:53 <orion> ReinH: Can all endomorphisms be considered identity morphisms too?
19:35:07 <shanemikel> rvxi: Yeah, the interesting thing is most people have suggested for me to start with either lyah, or haskellbook, both havning been written by students, very young students
19:36:06 <benzrf> dont start with lyah!
19:36:14 <benzrf> it's Pedagogically Problematic™
19:36:57 <shanemikel> rvxi: they both have their own weaknesses, but I have spent too little time with the language, functional programming, and programming in general to have a comprehensive familiarity with available materials
19:38:06 <pavonia> benzrf: In what way?
19:38:16 <benzrf> uhh
19:38:24 <benzrf> it's complicated & im about to play video gains
19:38:37 <benzrf> i'll yammer about it maybe tomorrow if you're legitimately interested
19:38:40 <benzrf> :>
19:39:20 * nshepperd started with lyah. but now we have cis194 and I've heard that's better
19:39:21 <pavonia> Okay
19:40:24 <shanemikel> benzrf: I had some trouble with lyah's explanation of haskell types, and more fundamental language concepts, but the material on breadcrumbs, zippers, readers, etc was pretty good 
19:40:28 <shanemikel> the last couple chapters
19:40:43 <verement> pavonia: http://bitemyapp.com/posts/2014-12-31-functional-education.html#learn-you-a-haskell
19:41:16 <shanemikel> also, chapter 2 has a friendly overview of the list functions, that I read at a time I may have found the docs a bit scary
19:41:48 <nitrix> Hi, I'm looking for a complete downloadable HTML version of the report for offline uses.
19:44:04 <pavonia> verement: Thanks
19:44:28 <orion> type (a ~> b) c = c a b 
19:44:37 <orion> What is this "~>" syntax?
19:44:52 <verement> nitrix: darcs get http://darcs.haskell.org/haskell2010-report
19:46:00 <RyanGlScott> orion: It's not syntax. It's an infix type synonym. You could have just as easily said type (a $$$ b) c = c a b
19:46:04 <nitrix> So, question; what's happening with the 2014 report?
19:46:30 <nitrix> Is it a thing?
19:46:37 <Cale> nitrix: I don't think there's anything newer than 2010
19:46:53 <orion> RyanGlScott: ah ok
19:47:01 <orion> I didn't know you could do that.
19:47:04 <nitrix> http://darcs.haskell.org/haskell2014-report/
19:47:09 <nitrix> I don't know, it's listed there.
19:47:33 <Cale> nitrix: There have been attempts since then to make progress on reporting on new developments
19:47:43 <Cale> But nothing that's been finished as far as I know
19:48:47 <orion> RyanGlScott: What about type Hask = (->) ?
19:49:08 <orion> That's not an infix type synonym, right?
19:49:42 <RyanGlScott> It's defined as prefix, yes. But you can use it as infix with backticks: Int `Hask` Int
19:50:00 <RyanGlScott> Analogously, (~>) Int Int Int
19:50:04 <nitrix> What's the point of the Hask type?
19:50:17 <nitrix> If it's just basic currying?
19:50:23 <RyanGlScott> Er, (~>) Int Int Either
19:52:13 <shanemikel> Is there a way to introduce set predicates (or some similar notion) into types, to get something like [n, n <- Integer, n>0] as a type?
19:52:57 <shanemikel> to define a subset of another type, using the same underlying representation?
19:53:08 <jle`> shanemikel: refinement types offer something similar
19:53:46 <geekosaur> "not in Haskell"
19:54:12 <nshepperd> nitrix: presumably just because people sometimes refer to the 'category Hask' (of types and functions)
19:54:46 <jle`> shanemikel: refinement types work by having a runtime "gateway" that only allows you to create objects of the type if they satisfy a predicate
19:55:02 <jle`> they don't work at compile-time like true subsets of types
19:55:08 <jle`> but, they work well practically
19:55:26 <jle`> actually i don't think i'm talking about refinement types at all, but about a particular implementation of them
19:56:09 <shanemikel> nitrix: I was reading an introduction to category theory, where the author explains Hask, as being a special case of Set, that includes bottom
19:56:42 <nitrix> Doesn't haskell types all include bottom?
19:56:42 <shanemikel> http://bartoszmilewski.com/2014/11/24/types-and-functions/
19:56:45 <nshepperd> shanemikel: isn't that what liquid haskell does? things like {n : Int, n > 0}
19:57:01 <shanemikel> I don't know nshepperd, I'm know familiar with liquid haskell
19:57:06 <shanemikel> err, not
19:57:21 <nshepperd> well, maybe you should check it out!
19:57:56 <shanemikel> that's right nitrix, and that's what the author explains to be Hask's only deviation from Set
19:58:15 <jle`> shanemikel: http://hackage.haskell.org/package/refined works well in practice
19:59:12 <shanemikel> really appreciate it jle` and nshepperd, always helpful :)
20:01:05 <nshepperd> nitrix: Set (as in category theory) is the category of sets and functions between sets. Hask is the category of haskell types and haskell functions between types, which involves bottoms.
20:02:11 <nshepperd> 'type Hask = (->)' is just a convenient synonym so you can write 'instance Category Hask' with a straight face
20:02:36 <shachaf> There's also the category "Haskell but when you pretend there are no bottoms", which people also call Hask.
20:02:57 <shachaf> "Haskell functions", that is.
20:03:38 <nshepperd> (except you also need TypeSynonymInstances to write 'instance Category Hask' so you'd never really do that)
20:03:53 * hackagebot pipes-wai 3.2.0 - A port of wai-conduit for the pipes ecosystem  https://hackage.haskell.org/package/pipes-wai-3.2.0 (IanDuncan)
20:09:31 <shanemikel> or Hask, where you acknowledge that there are bottoms, but make the judgement that it's either safe to, or you'd simply prefer to ignore them
20:09:59 <shanemikel> shachaf: that's the definition of Hask according to http://bartoszmilewski.com/2014/11/24/types-and-functions/
20:10:16 <shachaf> Well, if you want to call () terminal or Void initial you'd better not have bottoms.
20:10:50 <shachaf> That's his definition in that article, according to that article.
20:11:27 <shanemikel> yeah, I'm still trying (painfully I might add) to get comfortable with the base concepts behind category theory
20:12:12 <shanemikel> it's really abstract
20:12:26 <shachaf> The free online version of http://www.maths.ed.ac.uk/~tl/bct/ should be released this month.
20:13:14 <mniip> whoa
20:13:21 <shanemikel> awesome, thansk
20:13:48 <orion> If Maybe is a functor, what is the category theory equivalent of Just and Nothing?
20:15:19 <geekosaur> I thought category theory didn;t sully itself with little things like values
20:15:47 <shanemikel> the values would be necessary for the definition of composition, though
20:16:21 <mniip> Maybe adds a unique value into every set, in haskell we refer to that value as Nothing
20:16:24 <mniip> that's about it
20:22:09 <shanemikel> So far, I'm not getting that it's illegal to consider values, but that it's not required, nor imposed by category theory that objects have any specific structure
20:22:21 <rvxi> shanemikel lyah isn't good imo. bitemyapp is a 'very young student'?
20:22:36 <shanemikel> srry, no
20:22:47 <shanemikel> I guess he is a very young teacher
20:23:30 <shanemikel> lyah author was (IIRC) still an undergrad or recent graduate
20:23:45 <rvxi> how old is he? i don't even know...
20:23:58 <shanemikel> I don't know, I was judging by his picture
20:24:24 <rvxi> hah some people just have a young face :D
20:25:55 <shachaf> geekosaur: Category theory certainly has values that are functions.
20:26:14 <shachaf> geekosaur: Often a value :: T is represented as a function :: () -> T
20:26:23 <rvxi> shanemikel kind of envious of some of the young 'uns in the game.
20:26:35 <shanemikel> yeah, me too
20:26:46 <rvxi> like phaazon is super young
20:27:20 <rvxi> when i was at those ages everyone was still  wasting their time with fucking zen of OOP bullshit
20:27:58 <rvxi> talk about a waste of a generation or two of developers
20:28:06 <shanemikel> I'm pretty young, still undergrad, and I'm required to spend most of my time learning that paradigm
20:28:51 <rvxi> oh what are you jealous about then =P
20:28:59 <shanemikel> I thought you meant envious in the sense that you are seeing others at your age making more impresssive contributions than you can imagine yourself making (the form of my envy)
20:29:12 <rvxi> oh no its worse than that
20:29:38 <rvxi> it's more like that... except others like 15 years younger than me
20:30:05 <mfitton> I'm an undergrad trying to learn Haskell now
20:30:14 <rvxi> so count your blessings. that's just the human condition
20:30:21 <mfitton> though it's frustrating cuz I won't be able to use it on any school projects while I'm in school
20:30:42 <mfitton> Likely not when I go to industry either. I suppose it's just for fun
20:30:47 <rvxi> what would be unfortunate is if python takes over and it's another generation in a wilderness of bullshit.
20:31:18 <mfitton> That's what I do most of my coding in. I'm getting really sick of dynamic typing though
20:31:32 <rvxi> mfitton shanemikel just be glad you didn't waste 20 years of your life doing java design patterns
20:32:20 <rvxi> mfitton me too. have to do some R right now and oh god it's somehow less bad when you don't realize you're wasting time.
20:32:56 <rvxi> with the curse of knowledge you start to feel like sisyphus
20:32:58 <mfitton> I spent a semester writing a compiler in java given a really shoddily written AST library
20:33:03 <shanemikel> I think it's realistic to acknowledge that OOP, and python, along with comparable scripting languages have their place, not attack the proponents of those languages or paradigms, but express the dissatisfaction that there is such strong resistance to accepting the fact that necessarily one approach can't be a best fit for all problems, as the state of the art is too immature
20:33:21 <mfitton> many thousands of lines of java later I never want to work in it again
20:33:35 <mfitton> yet it's become the language whose syntax and libraries I know best ._.
20:33:44 <rvxi> shanemikel the problem is so many python devs _only_ know python, or python and java
20:33:46 <shanemikel> I have serious sympathy for your situation rvxi
20:33:52 <shanemikel> you have no idea
20:34:14 <shanemikel> I'm just saying we need to be political about it, or we'll exacerbate the problem
20:34:18 <rvxi> and revel in the mediocre homogeneity of everyone writing glue code for the same damn scikit learn packages or whatever
20:34:30 <rvxi> shanemikel yeah don't worry i only whine like this to haskellers
20:34:34 <mfitton> I'm glad I started with OOP
20:34:48 <mfitton> I think I wouldn't have continued with CS if I started with something like haskell
20:35:08 <rvxi> shanemikel thankfully i sidestepped the java drone part of my career by being an academic researcher
20:35:30 <shanemikel> I'm thinking I may need to make such a step, at some poitn
20:35:34 <mfitton> rvxi lucky you
20:36:08 <mfitton> well, lucky is an odd way of putting it I suppose. Getting into a research position is difficult
20:36:09 <rvxi> well i did waste time with matlab. R wasn't such a waste of time, but for other reasons, the language itself is terrible.
20:36:29 <rvxi> well it has its pros and cons. lot of opportunity cost salary and career ladder wise
20:36:54 <rvxi> but taken together i don't regret it
20:36:58 <mfitton> It's also a lot more difficult
20:37:01 <shanemikel> depending on the level of instability and responsibility I'm willing to accept professionally
20:37:19 <mfitton> I consider trying to get a PhD and research sometimes, but I really don't think I'm smart enough or have it in me
20:37:25 <rvxi> in fact i probably work on much more interesting problems in industry now as a result of previously being ana cademic
20:37:47 <mfitton> Undergraduate classes are already pushing me to my breaking point; I don't know if I could go into research even if I wanted to
20:37:49 <shanemikel> I'm still trying to determine whether I'm smart or interested enough to go into research
20:37:54 <shanemikel> too
20:37:55 <rvxi> mfitton academic research is not about smarts. in good ways and bad.
20:38:49 <mfitton> what is it about?
20:38:50 <rvxi> mfitton the good: passion is >> smarts. the bad: there are a lot of dumb as dirt professors out there
20:39:51 <rvxi> 5-7 years is a marathon. unless you're pure theory, it's not like making a brilliant chess move.
20:39:58 <Ashy> There are some very interesting problems in industry to work on
20:40:16 <mfitton> rvxi interesting, thanks for your perspective
20:40:24 <rvxi> you have to be willing to keep punishing yourself to be better and know more than the day before
20:40:24 <Ashy> But it's about having the discipline to leave any role that gets boring
20:41:15 <mfitton> Ashy I suppose in that way it requires structuring one's life around the pursuit of interesting problems
20:41:17 <shanemikel> lol punishing or pushing
20:41:18 <Ashy> Otherwise you end up like me and my gf, sitting on a train in Asia after uprooting our lives out of boredom with first world living
20:41:21 <rvxi> that's the good side of smartness not being related to success. the bad side is that a lot of people with stupid ideas are really good at gaming the metrics and "productivity"
20:41:32 <rvxi> but really have no business trying to be public intellectuals
20:41:38 <rvxi> shanemikel mostly punishing.
20:42:10 <hunteriam> http://lpaste.net/148644
20:42:11 <hunteriam> why is subserver type `Server _` and not `Int -> Server a`
20:42:11 <hunteriam> *`Int -> ServerT a`
20:46:11 <rvxi> as an older person... please get your fellow students into haskell. don't want to be writing damn python code when i have to retire
20:46:57 <mniip> as a younger person, I <3 haskell but no one understands me :(
20:48:08 <zomg> mniip: I'm not sure if age has anything to do with it, haskell is like a secret club for cool coders
20:48:27 <shanemikel> I'm still new in the language, but I feel, intuitively, that the functional paradigm has a lot to offer, and I similarly feel haskell will be it's primary vessel
20:48:30 <zomg> which doesn't have a rule like fight club, but even though we talk about it, people don't get it
20:48:33 <zomg> lol
20:48:47 <Adeon> I'm trying to indoctrinate some of my coworkers to at least look at the direction of haskell positively
20:49:29 <Adeon> it's a bit difficult
20:49:35 <shanemikel> So, assuming that intuition sustains itself, I will, most certainly, hede your request
20:49:41 <Adeon> I'm almost succeeding with quickcheck
20:49:44 * geekosaur 's coworkers keep asking him to do an intro Haskell class at the annual company meeting
20:50:08 <zomg> I don't know if I'd necessarily talk about quickcheck that much
20:50:13 <hypoon> Hi all, I'm writing a program which will use an encrypted socket between a client and a server. I also need username/password authentication, but I don't know whether it should be handled with the socket encryption, or handled independently. Either way, are there any particular haskell packages I should be investigating?
20:50:16 <zomg> Automated testing is black art for many devs to begin with
20:50:19 <geekosaur> but (a) a 2-hour slot ain't nowhere near long enough (b) asking me to do training is a bit like asking a mouse to program
20:50:22 <Adeon> I've shown off automatic differentiation as well although that's not entirely haskell specific
20:50:37 <Adeon> it just works well in haskell because some off the shelf libraries work out-of-box with 'ad' package
20:51:43 <zomg> If I tell devs about how haskell gives them less bugs and errors
20:51:50 <zomg> that tends to be something they find quite interesting
20:52:06 <zomg> especially for devs who use dynamic langs where everything is a runtime error and you can't trust anything
20:52:11 <Adeon> I'd probably prefer to see concrete examples of solving problems
20:52:25 <Adeon> which is why I go for showing off amazing haskell packages
20:52:47 <Adeon> it's very difficult to show how haskell gives less bugs and errors if the listeners have no background in functional programming
20:52:49 <zomg> yeah depends on what stage their interest is in
20:53:02 <Adeon> unless you have lots and lots of time
20:53:20 <zomg> if they've not expressed interest in learning the language yet, then code examples may be a bit useless :)
20:54:15 * hackagebot conduit-audio-lame 0.1.1 - conduit-audio interface to the LAME MP3 library  https://hackage.haskell.org/package/conduit-audio-lame-0.1.1 (mtolly)
20:54:17 * hackagebot conduit-audio-sndfile 0.1.1 - conduit-audio interface to the libsndfile audio file library  https://hackage.haskell.org/package/conduit-audio-sndfile-0.1.1 (mtolly)
20:55:19 <jle`> is there a better way to truncate a Double than (fromInteger . truncate) ?
20:58:22 <hypoon> zomg: Many programmers get to a point where they can get the gist of code written in almost any language, regardless of familiarity. Granted that, Haskell was virtually unreadable for me before I spent some time learning it. So yeah, I agree... code examples might not be so helpful if they aren't interested enough to try to decipher them. :-)
20:58:24 <shanemikel> jle`: can you use a modulo?
20:59:06 <mniip> hypoon, unless the code was written to be specifically unreadable
20:59:14 <shanemikel> is there no rem version for fractional?
20:59:18 <zomg> hypoon: yep
21:00:04 <geekosaur> shanemikel, there's a binding to C's fmod in Data.Fixed
21:00:25 <geekosaur> beyond that... one of the questions that nobody has managed to answer :/
21:00:44 <jle`> shanemikel: oh that's neat
21:00:47 <jle`> thanks
21:00:59 <glguy> https://hackage.haskell.org/package/numeric-extras-0.1/docs/Numeric-Extras.html
21:01:05 <jle`> wait modulo only works for Integrals
21:01:11 <glguy> bindings through to libm
21:01:17 <jle`> glguy: thanks :)
21:01:23 <jle`> perfect :O
21:01:37 <hunteriam> http://lpaste.net/148644
21:01:37 <hunteriam> why is subserver type `Server _` and not `Int -> Server a`
21:01:37 <hunteriam> *`Int -> ServerT a`
21:01:59 <lamefun> http://lpaste.net/3940621752366792704 - overlapping instances... How does Haskell show does this? Witchcraft?
21:02:01 <shanemikel> so I guess it's up to you to determine what's more efficient, calling a c lib, or converting between types
21:02:41 <hypoon> mniip: Very true. When trying to show off Haskell's elegance, I'd hope nobody reaches for deliberately unreadable code though. :-P
21:03:35 <geekosaur> lamefun, showList
21:04:04 <geekosaur> (having not yet loaded your paste because my local notwork has decided it's not doing things like SYN packets)
21:04:16 <lpsmith> Is there a way of catching any exception *except* those that were raised asynchronously?
21:05:24 <lpsmith> i.e. I want to catch SomeException but ignore those raised by throwTo
21:05:58 <shanemikel> yeah, jle` you can just do:
21:05:59 <geekosaur> anyway instead of an instance Show [a] there is a showList method in Show, and instance Show Char where ... showList = <display a String here>
21:06:07 <shanemikel> d - (d `mod'` 1)
21:06:15 <shanemikel> where Data.Fixed provides mod'
21:06:50 <geekosaur> and every other Show instance inherits the default showList
21:07:05 <shanemikel> unfortunately the div' it provides is (Real a, Integral b) => a -> a -> b
21:07:45 <verement> lpsmith: catchJust ?
21:07:51 <jle`> shanemikel: it looks like mod' goes through Integer though
21:07:56 <jle`> http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Fixed.html#mod%27
21:08:09 <shanemikel> oh, oops
21:08:15 <geekosaur> oh did they change that?
21:08:16 <geekosaur> sigh
21:08:35 <jle`> :'(
21:08:40 <geekosaur> yep, changed :/
21:08:45 <jle`> thanks though :O
21:08:45 <lpsmith> verement:  two problems with that.   First,  strictly speaking,  you can't tell whether or not a SomeException was raised synchronously or asynchronously from the Type.
21:08:50 <geekosaur> used to just FFI to fmod
21:09:13 <jle`> but, it looks like some benchmarking is in order eventually
21:09:18 <jle`> if this ends up being a bottleneck
21:09:25 <lpsmith> Second,  although most exception types tend to be used only one way or the other,  that's not really a solution.
21:09:51 <lpsmith> Because now you have to enumerate all the exceptions and know whether or not they tend to be raised synchronously or asynchronously
21:11:04 <verement> lpsmith: well, there is SomeAsyncException
21:11:19 <lpsmith> aha,  yeah I just saw that.  That's new to GHC 7.8
21:11:27 <lpsmith> (I'm still using 7.6 quite a bit)
21:11:51 <lpsmith> But that's as good a reason as any to work on upgrading GHC.
21:12:12 <lpsmith> thank you, verement 
21:24:23 <shanemikel> lamefun: some way to determine specificity?
21:26:34 <shanemikel> lamefun: it'd be interesting to change the order of the instance definitions and see if it still works
21:27:17 <shanemikel> but, I'd hope the language extension allows for determining which instance to used based on which is the most constrained
21:27:28 <shanemikel> or, least polymorphic
21:28:42 <shanemikel> I could see it being problematic with higher kinded types
21:29:42 <geekosaur> shanemikel, it tries to do that but can't always
21:30:02 <geekosaur> since instances can be in scope at runtime that didn't exist when it was compiled, among other things
21:30:23 <geekosaur> anyway I already answered the question although I don't know if anyone noticed :/
21:31:02 <geekosaur> [08 05:03] <geekosaur> lamefun, showList
21:31:02 <geekosaur> [08 05:05] <geekosaur> anyway instead of an instance Show [a] there is a showList method in Show, and instance Show Char where ... showList = <display a String here>
21:31:41 <geekosaur> this is necessary because Show is Haskell 98, which doesn't have any mechanism for overlapping instances
21:32:15 <kadoban> Can hlint be made to understand somehow that "foreign import javascript" isn't a parse error?
21:39:47 <shanemikel> and instead report it as a judjement error?
21:39:48 <shanemikel> jk
21:39:57 <shanemikel> :)
21:39:57 <kadoban> haha
21:54:17 <ontop> I have a Data Constructor (record syntax), is there any way to assign to it's "fields" with some sort of dynamic code. In Javascript: obj["field"] = thing, In Ruby: obj.send(:@field=, thing)
21:54:27 <ontop> I doubt it very much, but I'm just curious.
21:55:00 <Cale> myRecord { theField = newValue }
21:55:14 <Cale> will construct a record with all the other fields the same as myRecord
21:55:21 <Cale> but with theField replaced with newValue
21:55:35 <Cale> and you can list as many updates there as you like
21:55:37 <ontop> theField is the name of the field as an identifier though. What I'm getting at is having theField be a string that names the field to set.
21:55:44 <Cale> oh, then no
21:55:49 <ontop> Ok, thought as much.
21:55:52 <ontop> Thx ^_^
21:56:07 <Cale> The field names don't even necessarily exist at runtime
21:56:25 <Cale> The fields are just pointer offsets from the beginning of the data structure
21:56:40 <kadoban> ontop: If you need that, you probably should be using something like a Data.Map, perhaps? Though that behaves quite differently.
21:57:57 <ontop> Cale: Some languages support reflection things.
21:58:04 <ontop> I was just trying to get a feel for if Haskell could/did or not.
21:58:06 <geekosaur> they behave closer to the things in javascript and ruby
21:58:13 <ontop> kadoban: Yeah, it's coming out of a map.
21:58:24 <ontop> But I was putting it into the Data thing.
21:58:39 <ontop> I just wanted to do it without having to name the field with the identifier.
21:58:40 <geekosaur> haskell behaves like C; in particular records are not maps, they are like C structs and the field name in the source becomes a binary offset in the compiled program
21:58:44 <Cale> ontop: There are a bunch of schemes for that kind of reflection in Haskell. There's Data.Data, but I'm not sure if you can refer to things by field name...
21:58:45 <Cale> hmm
21:59:10 <ontop> geekosaur: Structs aren't maps in Go but you can use reflection to assign to them.
21:59:25 <ontop> They're laid out in memory almost exactly like their C equivalents.
21:59:32 <Cale> constrFields :: Constr -> [String] Source
21:59:32 <Cale> Gets the field labels of a constructor. The list of labels is returned in the same order as they were given in the original constructor declaration.
21:59:42 <geekosaur> also I suspect the fact that fields are not first class in Haskell plays into this
21:59:47 <Cale> It *is* barely possible using the stuff in Data.Data
21:59:48 <glguy> GHC.Generics could generate a name based setter (has access to record field names)
21:59:51 <ontop> Right, I heard they were a bolt-on.
21:59:57 <Cale> yeah, and probably GHC.Generics too
22:00:05 <geekosaur> no, not a bolt-on, just not designed for that
22:00:27 <geekosaur> ghc 8.1 will have some of the machinery needed to change that, but the rest isn't coming until some future release
22:00:50 <Cale> I mean, there's a limit to how much of that is even desirable
22:01:07 <geekosaur> and without that machinery, fields simply do not provide enough information to do it dynamically at runtime
22:01:13 <Cale> Referring to record fields by name at runtime seems really brittle and not subject to typechecking
22:01:31 <Cale> Usually the answer is "you don't really want to do that"
22:01:43 <Cale> So you don't want it to be too easy for beginners to stumble into doing it
22:02:12 <catsup> i'm wondering, why is the commented out definition not used in the following code from transformers?
22:02:16 <catsup> -- * @'evalStateT' m s = 'liftM' 'fst' ('runStateT' m s)@
22:02:18 <catsup> evalStateT :: (Monad m) => StateT s m a -> s -> m a
22:02:21 <catsup> evalStateT m s = do
22:02:23 <catsup>     ~(a, _) <- runStateT m s
22:02:26 <catsup>     return a
22:02:48 <geekosaur> at a guess, it's too strict
22:03:44 <catsup> well i don't even get how it would be more strict :/
22:04:05 <geekosaur> I think you;d have to look at the generated ghc-core for both versions to see what;s up
22:05:02 <catsup> maybe some day :)
22:05:10 <geekosaur> but if fst is strict, which it would be by default. then the first version would be too strict
22:05:20 <geekosaur> that is, fst would need to use that ~(a,_) pattern
22:05:30 <geekosaur> but it probably uses (a,_) which would make it too strict
22:09:21 <ontop> Cale: Makes sense.
22:09:39 <ontop> It's more curiosity. I mean I feel like I know all of Haskell (minus language extensions) already with the exception of libraries.
22:09:47 <ontop> It seems syntactically like a very small language.
22:10:07 <ontop> Any surprises awaiting me?
22:24:22 <kadoban> ontop: Probably :) It's hard to say really. Haskell isn't super heavy on syntax though I guess.
22:25:25 <ontop> Cool
22:25:25 <ontop> :D
22:49:25 <ggVGc> I've got a list :: [a], and a fuction :: (a,a,a)->Bool. How do I easiest find all the unique sets of 3 items that the function returns true for
22:50:30 <ggVGc> I was thinking taking the cartesian product of a, twice, to get [(a, (a,a))], then flatten that into [(a,a,a)], then somehow filter the duplicates
22:50:35 <ggVGc> but it seems very wasteful
22:50:38 <hexagoxel> you cannot make `fst` less strict than it is. if you are evaluating `fst`, you already are forcing the returned value anyways.
22:51:57 <mniip> ggVGc, filter f $ join (join $ liftA3 (,,)) xs
22:52:07 <mniip> does that work
22:52:08 <nilg> I'm surprised ghc doesn't seem to support multiple jobs (-j) like gcc. Any knowledge about that (googling just returns stuff about multithread programming in Haskell, I can't get any info)?
22:52:19 <mniip> oh, you want the components of the tuple to be nonequal?
22:52:20 <hexagoxel> catsup: my guess would be that it is some "make this run a bit faster even with -O0"
22:54:42 <hunteriam> I have got a really really nasty error
22:54:47 <hunteriam> https://www.irccloud.com/pastebin/8pLrgdF5/
22:55:10 <exio4> we need a function like :: [a] -> [(a, [a])] 
22:55:12 <hunteriam> help is extremely appreciated
22:55:17 <hunteriam> exio4: does what?
22:55:31 <mniip> exio4, there is a mechanism in lens that does this
22:55:39 <mniip> but I don't quite know how to make use of it
22:55:50 <mniip> holesOf and contextsOf, I believe
22:55:53 <exio4> for ggVGc's problem, it'd give a list of every element and .. well, the list without that element
22:56:26 <hexagoxel> nilg: my `man ghc` mentions -j. your does not?
22:56:58 <hunteriam> surely some of you guys have encountered nasty linker errors before
22:56:59 <exio4> then it's just [(x,y,z) | (x,xs) <- f list , (y,ys) <- f xs, z <- ys, f x y z] or something like that :P 
22:57:07 <hunteriam> It seems to happen to me regularly with stack build
22:57:11 <hunteriam> whereas stack ghci seems alright
22:57:21 <hunteriam> or semi regularly
22:57:34 <hunteriam> no clue how to solve it
22:58:01 <mniip> :t \xs -> zip xs (zipWith (++) (inits xs) (tail $ tails xs))
22:58:03 <lambdabot> [a] -> [(a, [a])]
22:59:27 <hexagoxel> hunteriam: the most common cause of linker errors are unexposed modules in your cabal file. no idea how stack handles the issue in general, though; this might be cabal-specific.
23:00:01 <kadoban> They're still supposed to be in exposed-modules or other-modules, though I've never noticed a linker error from not doing it.
23:00:34 <kadoban> Maybe it behaves differently on windows, or I've just been lucky.
23:02:18 <exio4> > (\xs -> zip xs (zipWith (++) (inits xs) (tail (tails xs))) [1,2,3]
23:02:20 <lambdabot>  <hint>:1:67:
23:02:20 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
23:02:30 <exio4> > (\xs -> zip xs (zipWith (++) (inits xs) (tail (tails xs)))) [1,2,3]
23:02:32 <lambdabot>  [(1,[2,3]),(2,[1,3]),(3,[1,2])]
23:02:54 <exio4> nice, wasn't there a simpler implementation too? 
23:03:24 <hexagoxel> (you can be lucky because if you ghci, it searches for the modules in the right paths. you generally only notice when you package/do certain out-of-source builds)
23:06:32 <nilg> hexagoxel: excellent (I searched jobs not -j)
23:10:16 <bollu> guys, free monad question: https://gist.github.com/bollu/f5a8e4c779a1e039d80b#file-free-monads-hs-L48
23:10:25 <bollu> I don't know how to "lift" a DSL into the Free monad
23:10:39 <bollu> I'm not able to write the lifting function that I need
23:10:55 <bollu> can someone help me ?
23:13:38 <bollu> anyone? >_<
23:18:45 <bollu> okay, so I got a formulation, but I'm not sure how correct it is
23:18:46 <bollu> https://gist.github.com/bollu/f5a8e4c779a1e039d80b#file-free-monads-hs-L50
23:18:58 <bollu> could someone just look at it and tell me if I found the right solution?
23:21:26 <Xnuk> :t tails
23:21:27 <lambdabot> [a] -> [[a]]
23:43:32 <hunteriam> my project built successfully
23:43:50 <radens> I'm defining the natural numbers in haskell like this: data Nat = Zero | Succ Nat deriving (Eq,Show) Given the numbers one = Succ Zero and two = Succ one is there a way to add them without recursively unwinding them? Can I use the Succ data constructor to add them?
23:44:02 <hunteriam> but I get "the application was unable to start correctly (0xc000007b)
23:44:15 <hunteriam> what do i do???
23:47:06 <hunteriam> how do i tell stack to rebuild the linked libs?
23:56:54 <bollu> so, I fugured it out: https://gist.github.com/bollu/f5a8e4c779a1e039d80b
23:57:02 <bollu> building the DSL interpreter  using Free 
23:57:12 <bollu> now I have a vague understanding of why this works, but not concret
23:57:15 <bollu> concrete*
23:57:28 <bollu> could someone explain to me from their point of view as to why this construction works?
23:58:46 <bollu> is there any way to get a Show instance for functions?
23:58:51 <bollu> that just shows their internal code?
23:59:30 <phaazon> 05:35 < rvxi> like phaazon is super young
23:59:36 <phaazon> huh? :D
23:59:41 <phaazon> HOW DID HE KNOW
23:59:42 <phaazon> :D
23:59:53 <bollu> phaazon: how old are you? -_^
23:59:54 <suppi> bollu, probably not, because a function is not only code but also has an environment
23:59:57 <phaazon> 23
