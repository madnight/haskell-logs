00:00:56 <julianleviston> Also, is there such a thing as a library in haskell that lets you check data constraints at runtime like the type checker checks types at compile time? I’m guessing not because of the way types are deleted after typechecking, but… yeah.
00:01:23 <lisbeth> How do I write the newline character by it's self?
00:01:44 <MarcelineVQ> '\n' is the escape code for newlines
00:01:54 <MarcelineVQ> julianleviston: there's some reflection libraries, I don't know them by name
00:02:06 <MarcelineVQ> Not sure if that's quite what you need though
00:04:11 <julianleviston> MarcelineVQ: something similar… it’s so I can check to see if a user has put the right data into a Map. Some data shouldn’t go with other data… a (completely arbitrary example) is if there is a GreyDot then it should not precede a RedDot… 
00:07:41 * hackagebot HTTP 4000.3.0 - A library for client-side HTTP  https://hackage.haskell.org/package/HTTP-4000.3.0 (GaneshSittampalam)
00:07:41 * hackagebot phoityne 0.0.2.0 - ghci debug viewer with simple editor.  https://hackage.haskell.org/package/phoityne-0.0.2.0 (phoityne_hs)
00:10:09 <julianleviston> MarcelineVQ: E.Kmett’s http://hackage.haskell.org/package/reflection
00:10:20 <julianleviston> MarcelineVQ: that what you meant?
00:12:22 <julianleviston> MarcelineVQ: OMG thank you so much for this!
00:12:24 <MarcelineVQ> Unfortunately I've not used any myself so I don't know
00:12:26 <MarcelineVQ> oh good
00:19:42 <julianleviston> MarcelineVQ: ah, I wish I understood more.
00:25:02 <julianleviston> MarcelineVQ: like, for example, this: reify :: forall a r. a -> (forall (s :: *). Reifies s a => Proxy s -> r) -> r
00:25:37 <julianleviston> does forall a r mean “for any a at all, and also for any r at all”?
00:27:19 <julianleviston> I wish I understood how things like “Reifies s a“ worked… is that a many-kinded type?
00:27:49 <julianleviston> It’s pretty much just like Either a b I guess?
00:29:09 <julianleviston> Also, what does it mean when it’s a constraint like that? Reifies s a => Proxy s -> r ?
00:29:12 <julianleviston> That’s so confusing.
00:30:49 <MarcelineVQ> I guess start by looking into forall and RankNTypes here's a bit about it https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html
00:31:25 <julianleviston> MarcelineVQ: will that help me understand the Reifies s a => constraint?
00:32:27 <MarcelineVQ> No
00:32:36 <julianleviston> ok
00:33:16 <MarcelineVQ> I am trying to remember the resource I used that would help with that though
00:33:20 <julianleviston> What does the constraint constrain, given there are no “s a”’s in the “body” of the type ?
00:33:24 <julianleviston> k thanks
00:38:27 <MarcelineVQ> oh okay it was page 21 of https://wiki.haskell.org/wikiupload/d/dd/TMR-Issue8.pdf which won't help with your immediate issue there but will help slightly when you look at the Reifies class and wonder what the heck `class Reifies s a | s -> a where` means
00:38:46 <MarcelineVQ> So not especially helpful, but interesting reading still
00:40:18 <MarcelineVQ> Sorry for the piecemeal, if I understood the subjects better I'd just explain them but it wouldn't be fair to you to give a vague explanation
00:41:48 <julianleviston> MarcelineVQ: it’s more than fine!
00:42:02 <julianleviston> MarcelineVQ: I feel like I *should* know this, having gone through haskell book.
00:42:58 <julianleviston> I just haven’t been exposed to enough examples and tried to use it myself for it to sink in, obviously. I don’t actually even know the name for it..
00:43:00 <MarcelineVQ> Oh this is a fair ways beyond that, the only exposure to forall in there (so far) is a passing reference in a type signature in the Foldable class
00:43:26 <MarcelineVQ> "fair ways beyond" being my own completely subjective opinion
00:44:14 <julianleviston> MarcelineVQ: oh I’m not talking about Rank n types. I’m not terribly unfamiliar with that.
00:44:40 <julianleviston> MarcelineVQ: the part that I’m talking about it the (more basic) types that have more than 1 variable, and constraints of that type.
00:44:47 <julianleviston> This happens in lens, too.
00:45:55 <julianleviston> MarcelineVQ: like this signature is pretty straightforward: type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
00:46:10 <julianleviston> MarcelineVQ: f is obviously a Functor instance there.
00:47:55 <julianleviston> MarcelineVQ: but take this one: type IndexedLens i s t a b = forall f p. (Indexable i p, Functor f) => p a (f b) -> s -> f t
00:48:45 <ggole> "I stab FP". Nice.
00:48:49 <julianleviston> MarcelineVQ: Indexable i p is one of the constraints. I have no idea what that means given that “i” is not even present in the rest: (ie in p a (f b) -> s -> f t)
00:49:38 <julianleviston> so I guess it’s just like a phantom type variable or something...
00:49:41 <julianleviston> (if I got the name right)
00:50:05 <julianleviston> … but what does that mean for p?
00:50:32 <MarcelineVQ> You'd have to ask the Indexable class
00:50:33 <julianleviston> because p *is* in the type signature (p a (f b) -> s -> f t) … so is there a constraint on it or not? I guess so? but I don’t know so.
00:50:51 <julianleviston> really? shouldn’t you know from the signature?
00:51:18 <julianleviston> why bother putting the constraint in there at all if it has no bearing on the function’s type?
00:52:00 <ggole> You know from the signature that p is bounded by being the second argument of Indexable
00:52:04 <MarcelineVQ> To constrain the type's use, though I'm not sure that's what happening here
00:52:12 <ggole> But nothing more
00:52:43 <ggole> (In particular, you don't know what Indexable does with that argument. It could just ignore it, although that would be a bit strange.)
00:52:49 <julianleviston> or here’s another example that confuses: (%%=) :: MonadState s m => Over p ((,) r) s s a b -> p a (r, b) -> m r
00:53:04 <julianleviston> ggole: sure, but I don’t know what that means. 
00:53:25 <julianleviston> ggole: “p is bounded by being the second argument of Indexable”
00:53:57 <ggole> OK, start from a simpler example, say Num
00:54:04 <julianleviston> ggole: Num I understand
00:54:09 <ggole> You are comfortable with (+) :: Num a -> a -> a -> a?
00:54:09 <wedens> if I have a function `f :: a -> b -> c -> d -> e` and I want to call it multiple times as ` f x y;  f p q;...` and I want to pass parameters `c` and `d` to all this functions simultaneously. is it possible? probably some applicative composition?
00:54:10 <julianleviston> :t (+)
00:54:11 <lambdabot> Num a => a -> a -> a
00:54:15 <julianleviston> that’s fine.
00:54:21 <julianleviston> ggole: yep.
00:54:24 <ggole> (Please assume I typed the right arrow there -_-)
00:54:33 <ggole> OK, now what does the a in Num a mean?
00:54:58 <julianleviston> ggole:  for all a where a is an instance of Num.
00:55:00 <julianleviston> (I think).
00:55:08 <julianleviston> has* an instance of Num.
00:55:40 <ggole> The p is pretty much like that.
00:56:47 <julianleviston> ggole: so it’s like Either Int then?
00:57:11 <julianleviston> if you said Either Int p => p -> Bool or something
00:57:12 <ggole> Much like there will exist instances of Num where a ~ Int, etc, there will be instances of Indexable where p ~ some type
00:57:23 <julianleviston> sweet.
00:57:31 <julianleviston> I head-grok that.
00:57:32 <ggole> Well, Either isn't a constraint 
00:57:38 <ggole> It's a type constructor
00:57:47 <julianleviston> Either Int a =>  can’t be a constraint?
00:57:56 <julianleviston> Ok then maybe I don’t understand at all 
00:58:45 <ggole> Hmm.
00:58:55 <ggole> Do you understand that Num a is not a type, but a constraint on a type?
00:59:03 <julianleviston> I think I understand that.
00:59:21 <julianleviston> Either Int a is not a type either, right?
00:59:45 <ggole> It is
00:59:50 <julianleviston> oh? ok
00:59:53 <julianleviston> I don’t understand how.
00:59:59 <julianleviston> Either Int String is a type.
01:00:05 <julianleviston> isn’t it?
01:00:08 <nitrix> They're all types.
01:00:08 <ggole> Either is a type constructor of kind * -> * -> *: when you apply it to two arguments, you get a type
01:00:24 <julianleviston> Oh… Num is a typeclass gadoi.
01:00:25 <julianleviston> sorry.
01:00:35 <julianleviston> So Indexable is a type class?
01:00:41 <MarcelineVQ> Yes
01:00:41 <ggole> Yep
01:00:45 <nitrix> `Either` is a type constructor. `Either Int a` is a polymorphic type, `Either Int Int` is a specialized type.
01:00:52 <julianleviston> yes, because that’s what constraints ARE ok.
01:01:14 <julianleviston> I guess the problem is I’ve never seen a typeclass that takes more than 1 variable.
01:01:17 <julianleviston> What does that even mean?
01:01:23 <julianleviston> Is there a simple example I can look at ?
01:01:27 <ggole> It's an extension
01:01:54 <julianleviston> I should clarify… I’ve SEEN them, I’ve just never really understood them
01:02:19 <julianleviston> Is it GADT's?
01:02:24 <MarcelineVQ> MultiParamTypeClasses iirc
01:02:28 <julianleviston> oh ok.
01:02:33 <julianleviston> yes. MultiParamTypeClasses
01:02:48 <nitrix> Kinds alone explain them.
01:02:55 <julianleviston> Kinds alone?
01:03:10 <MarcelineVQ> Type constructors.
01:03:26 <nitrix> If you knwo about kinds, you can easily reason about typeclasses, regardless of the number of type variables they have.
01:03:27 <julianleviston> but aren’t we talking about multi param type classes?
01:03:47 <julianleviston> nitrix: oh that’s not true for me.
01:03:56 <julianleviston> nitrix: unless I actually don’t understand about kinds. Still.
01:04:11 <julianleviston> It’s all very confusing.
01:05:27 <ggole> Perhaps start with that then, and become comfortable with the idea before tackling stuff like multi argument type classes
01:05:45 <julianleviston> ggole: I thought I was comfortable with it.
01:06:09 <julianleviston> ggole: FSDO “comfortable”, I suppose.
01:06:17 <ggole> Let's begin with the obvious: say you have the value 'a', which is described by the type Char.
01:06:21 <julianleviston> ggole: how could I tell if I was comfortable / not comfortable according to your definition.
01:06:44 <ggole> You don't have to apply any arguments or anything to Char: it's suitable for describing values as is.
01:06:45 <julianleviston> ggole: ok
01:06:59 <nitrix> Aka, called a concrete type.
01:07:00 <julianleviston> ggole: I don’t know what that means.
01:07:05 <julianleviston> ggole: oh ok.
01:07:06 <ggole> This is more or less what having kind * is: types of kind * describe values.
01:07:09 <julianleviston> ggole:  it’s not a type tho.
01:07:10 <julianleviston> it’s a value.
01:07:16 <julianleviston> ‘a’ is a value.
01:07:17 <ggole> 'a' is the value
01:07:19 <julianleviston> its type is Char.
01:07:24 <nitrix> `*` is a concrete type.
01:07:25 <julianleviston> Char is a concrete type.
01:07:33 <ggole> And the kind of Char is *
01:07:34 <julianleviston> no * is the KIND of concrete types.
01:07:38 <julianleviston> yes.
01:07:42 <ggole> Right.
01:07:43 <nitrix> Correct.
01:07:56 <ggole> Now consider Maybe.
01:08:02 <julianleviston> * -> * I think.
01:08:06 <julianleviston> (not looking it up)
01:08:15 <julianleviston> its a polymorphic type, right?
01:08:22 <nitrix> Also correct. It takes a concrete type and produces another concrete type.
01:08:28 <ggole> That's right, in order to describe values you have to apply it to a (ground) type.
01:08:29 <julianleviston> yep.
01:08:33 <nitrix> e.g Int -> Maybe Int
01:08:36 <julianleviston> yep.
01:08:46 <ggole> So it has kind * -> *, eg, when applied to a value, it produces a type of kind *
01:08:49 <nitrix> Maybe is called a type constructor.
01:08:52 <ggole> Er, when applied to a type. Sorry.
01:08:53 <julianleviston> yep.
01:08:54 <julianleviston> it is.
01:09:02 <julianleviston> types are values.
01:09:06 <julianleviston> aren’t they?
01:09:14 <julianleviston> I guess not.
01:09:28 <ggole> Types describe values.
01:09:35 <nitrix> I wouldn't say that much. Haskell isn't really that advanced towards dependent typing.
01:09:45 <julianleviston> not yet. ok.
01:09:59 <nitrix> Types are set of values.
01:10:08 <julianleviston> ok let’s not (get) distracted.
01:10:14 <julianleviston> types are not values. Noted.
01:10:20 <ggole> So, let's now consider Either Int a
01:10:20 <nitrix> I think it's a general (good enough) abstraction.
01:10:30 <julianleviston> Type constrauctor. same as Maybe. * -> *
01:10:37 <nitrix> Careful.
01:10:41 <julianleviston> with what?
01:10:48 <julianleviston> Either Int a has kind * -> *
01:10:51 <julianleviston> Maybe also.
01:10:52 <nitrix> `Either` and `Either Int` are type constructors.
01:10:54 <julianleviston> no?
01:10:57 <julianleviston> yes.
01:11:01 <ggole> OK, you get most of it
01:11:03 <julianleviston> but Either has kind * -> * -> * I think
01:11:06 <ggole> The question is where a comes from
01:11:30 <julianleviston> ggole: which a ?
01:11:41 <julianleviston> ggole: oh… in Either Int a.
01:11:46 <julianleviston> oops.
01:11:46 <julianleviston> ok.
01:11:51 <ggole> If you just write a function definition like foo :: Either Int a -> Int
01:12:03 <julianleviston> I have no idea what that means right this second.
01:12:11 <julianleviston> My brain has dumped all of its knowledge.
01:12:14 <julianleviston> Oh wait
01:12:19 <ggole> It's as if you had written foo : forall a. Either Int a -> Int
01:12:27 <julianleviston> it means “any Either type whose first value is an int, and second can be any type)
01:12:49 <ggole> That's... not a really accurate way to think about it
01:12:51 <julianleviston> So x :: Either Int String would be fine, and so would y :: Either Int Int
01:12:57 <julianleviston> ggole: oh?
01:13:10 <ggole> Because a is a type variable, and variables are (sometimes implicitly) bound somewhere
01:13:30 <julianleviston> ggole: no idea what that means.
01:13:42 <julianleviston> ggole: ok so how would you define what Either Int a means? (Your question)
01:13:55 <ggole> You would explain where a is bound
01:13:59 <julianleviston> ggole: given that it was completely decontextually.
01:14:05 <nitrix> Often Haskell does it by inference.
01:14:06 <julianleviston> ggole:  in THAT context (that you gave me)
01:14:06 <ggole> Usually by introducing explicit foralls
01:14:23 <julianleviston> Ok so Either Int a has kind *
01:14:35 <julianleviston> Either Int a is a polymorphic Either Int.
01:14:35 <ggole> julianleviston: right, this is why discussion of the polymorphism of things containing type variables can become confusing
01:14:53 <nitrix> Correc. It's a concrete type, it just isn't specialized yet.
01:14:58 <julianleviston> Yep.
01:15:05 <julianleviston> forall a. Either Int a ?
01:15:28 <ggole> This also has kind *
01:15:31 <julianleviston> yep.
01:16:18 <nitrix> 08:58:59  julianleviston | Either Int a is not a type either, right? 
01:16:23 <ggole> And when you write type variables without an explicit forall, the scope is taken to start at the beginning of the entire type
01:16:26 <nitrix> We've made progress already.
01:16:48 <julianleviston> nitrix:  head-grokking styles. It’ll probably be gone until I practically use it. :(
01:16:51 <julianleviston> ggole: so… I *kind of* have a handle on kinds then?
01:16:59 <ggole> So if you have foo :: Maybe a -> Either Int a, the a is the same variable - that is, foo :: forall a. Maybe a -> Either Int a
01:17:15 <julianleviston> yep.
01:17:24 <ggole> julianleviston: that's the basics of kinds
01:17:28 <julianleviston> sweet.
01:17:42 * hackagebot pkcs10 0.1.0.5 - PKCS#10 library  https://hackage.haskell.org/package/pkcs10-0.1.0.5 (ktimothy)
01:17:49 <julianleviston> and higher-kinded types are ones like Either ?
01:17:51 <julianleviston> right?
01:18:16 <ggole> No, they are types which take type constructors like Either as an argument
01:18:29 <julianleviston> hm ok.
01:18:33 <ggole> Recall that Either has kind * -> * -> *
01:18:38 <julianleviston> yep.
01:18:55 <julianleviston> ohhh
01:18:55 <ggole> Imagine a type that takes type constructors of that kind as an argument, and returns a ground type. It would then have kind (* -> * -> *) -> *
01:19:01 <ggole> This would be a higher kinded type.
01:19:04 <julianleviston> so something (* -> * -> *) -> *
01:19:11 <julianleviston> haha jinx :) cool
01:19:21 <julianleviston> ok.
01:19:33 <julianleviston> I’ve never needed them so they won’t stick with me most likely. Thanks tho.
01:19:36 <jle`> yeah, that's an example of one
01:19:46 <jle`> they come up pretty often, though
01:19:53 <jle`> you've probably used the Functor typeclass before
01:19:58 <julianleviston> sure.
01:20:01 <jle`> or the Monad one
01:20:05 <julianleviston> and monad and monoid and (etc)
01:20:05 <jle`> :k Functor
01:20:07 <lambdabot> (* -> *) -> Constraint
01:20:14 <julianleviston> but it’s a typeclass...
01:20:21 <julianleviston> in my brain that’s separate… no/
01:20:24 <julianleviston> no?
01:20:25 <ggole> The part of kinds I didn't cover is constraints
01:20:35 <julianleviston> ggole: right… which is what I was asking about. 
01:20:39 <ggole> * is the kind of types that describe values
01:20:48 <jle`> you can consider it a higher-kinded typeclass.  it doesn't work with *'s, it works with (* -> *)...it works with type *functions*
01:20:48 <julianleviston> :k Num
01:20:49 <julianleviston> like this.
01:20:50 <lambdabot> * -> Constraint
01:21:05 <ggole> Constraint is the kind of things that constrain types
01:21:19 <julianleviston> ggole: yeah, someone explained this to me once before. I rememeber it.
01:21:32 <julianleviston> makes no practical sense to me, but I can just take it on faith.
01:21:36 <julianleviston> “it is what it is"
01:21:37 <jle`> in other languages, you have something like interfaces
01:21:41 <julianleviston> sure.
01:21:46 <jle`> like, in Java, List can be a member of the iterator interface
01:21:54 <jle`> or C++, i'm not sure exactly
01:22:08 <jle`> but the thing about interfaces is, only "concrete" "*-kinded" types can be members of the interface
01:22:20 <jle`> List<a> is a member, for all a
01:22:46 <jle`> because List can't implement the interface.  List isn't a class.  List<a> is a class
01:22:59 <jle`> haskell's typeclasses can be higher-kinded
01:23:10 <jle`> note that `Maybe a` isn't the instance of Functor.  `Maybe` is.
01:23:10 <julianleviston> jle`: Thanks but I’m not interested in java or C# at this point :)
01:23:20 <julianleviston> jle`: I still love you tho. :)
01:23:22 <jle`> i'm just demonstrating the power of higher-kinded typeclasses
01:23:24 <jle`> heh
01:23:26 <ggole> :k Indexable
01:23:28 <lambdabot> * -> (* -> * -> *) -> Constraint
01:23:28 <jle`> over non-higher-kindedness
01:23:34 <jle`> and why higher-kindedness is a big deal
01:23:39 <ggole> julianleviston: and now we come to multi argument type classes
01:23:47 <julianleviston> ggole: cools :)
01:23:48 <ggole> As you can see, it's a higher kinded type that takes *two* arguments
01:23:55 <jle`> the lack of higher-kindedness in other languages is very limiting, and prohibits sensible implementations of a lot of Haskell things we take for granted
01:24:00 <ggole> And returns the kind of things that constraint types.
01:24:23 <julianleviston> ggole: I don’t really know how to process that!
01:24:26 <ggole> Consider the difference with Either (which you seemed uncertain about before)
01:24:28 <jle`> in other words, we love higher kindedness! :D
01:24:28 <ggole> :k Either
01:24:30 <lambdabot> * -> * -> *
01:24:56 <julianleviston> ggole: we’re talking about Indexable right now right? 
01:24:59 <ggole> Either also takes two arguments, and returns the kind of ground types (that describe values)
01:25:13 <ggole> Sort of, we're talking about the type of things like Indexable.
01:25:22 <julianleviston> ggole: sure. But none of the arguments are type functions (? is that the right term)
01:25:39 <ggole> You mean, none of the arguments of Either?
01:25:40 <julianleviston> ggole: ( type, or kind ) of these things?
01:25:51 <julianleviston> ggole: yeah.
01:26:01 <ggole> That's right. You would say the Either is not of higher kind.
01:26:06 <ggole> *that
01:26:59 <rcyr> I think that for "mainstream languages", only C++ can represent higher-kinded types
01:27:34 <julianleviston> ggole: so Indexable is a type constructing constraint?
01:27:43 <julianleviston> ggole: or rather it’s a constraint constructor?
01:27:59 <julianleviston> ggole: but it’s a higher-kinded type constraint constructor?
01:28:01 <jle`> a common example of a higher kinded types that aren't constraints is monad transformers, like MaybeT :: (* -> *) -> * -> *
01:28:25 <jle`> you can think of MaybeT as a type function that takes a (* -> *) Monad, and yields a new one (* -> *)
01:28:40 <jle`> MaybeT :: (* -> *) -> (* -> *)    -- input is a Monad, output is a new Monad
01:28:46 <julianleviston> jle`: what does “you can think of” mean?
01:28:47 <ggole> julianleviston: it's much like Num, just with a different number (and kind) of arguments
01:28:50 <julianleviston> jle`: does that mean it’s NOT that?
01:29:01 <julianleviston> ggole: careful with the word KIND! :)
01:29:02 <jle`> it means that that's one interpretation of it that gives insight in this way
01:29:12 <jle`> insight relating to this topic, at least
01:29:17 <jle`> there are other ways you can interpret that kind signature
01:29:18 <julianleviston> jle`: it implies it’s inaccurate, or false to me.
01:29:32 <jle`> i guess i mean that, it's one interpretation/perspective :)
01:29:35 <ggole> I meant it in the sense that the kind of the second arguments to Indexable is not the same as the kind of Num
01:29:37 <ggole> :k Num
01:29:38 <jle`> that are all equally valid
01:29:39 <lambdabot> * -> Constraint
01:29:44 <julianleviston> jle`: “You can think of a dog as a cat that woofs” <- like this?
01:30:04 <julianleviston> :k Indexable
01:30:06 <lambdabot> * -> (* -> * -> *) -> Constraint
01:30:35 <julianleviston> ggole: so Indexable is a higher-ordered type constraint constructor?
01:30:38 <jle`> i mean, "you can think of a square as a rectangle with four equal sides" -- or, "you can also think of a square as a rectangle whose diagonal has a ratio of 1:sqrt(2) to the sides"
01:30:58 <julianleviston> jle`: that’s not quite “true". A square IS a rectangle with four equal sides”
01:31:05 <ggole> Something like that, yeah
01:31:19 <jle`> yes, but there are other perspectives to describing a square or defining a square that are more useful in certain contexts
01:31:29 <julianleviston> ggole: ok. I might have a handle on this… for now… which will possibly disspate until I get a practical understanding of it through usage.
01:32:00 <julianleviston> jle`: that’s an immutably implicit fact of reality and the fact that we’re subjective beings. Need not be stated.
01:32:31 <julianleviston> jle`: I guess I should cut “you can think of it as” some slack … it’s really just trying to be “one description of it is..."
01:32:33 <jle`> but yeah, the point is that MaybeT is a higher-kinded type, because it takes a (* -> *) and yields another (* -> *)
01:32:52 <jle`> or, it takes a (* -> *) and a * and yields a *
01:33:04 <jle`> and it's put to use in a lot of contexts
01:33:08 <julianleviston> jle`: this makes MaybeT much more confusing to me than it was.
01:33:12 <julianleviston> jle`: but that’s ok.
01:33:31 <jle`> yeah, that's probably what i meant by "you can think of it as,"; as in, it's not a helpful way of thinking about it to *use* it
01:33:31 <julianleviston> jle`: yeah, it it :)
01:33:41 <jle`> just one perspective that is relevant in this specific isolated context
01:33:44 <julianleviston> jle`: oh ok.
01:33:48 <jle`> not a perspective that would be helpful in its usage :p
01:34:04 <julianleviston> jle`: maybe. I like to know what things are before I use them.
01:34:12 <julianleviston> jle`: less surprises that way.
01:34:16 <jle`> sometimes you think "i have a Monad m.  but I want a new Monad that has the same effects, but also has short-circuiting"
01:34:22 <julianleviston> jle`: where possible :)
01:34:38 <julianleviston> jle`: wow that’s really inaccurate isn’t it?
01:34:42 <jle`> so, MaybeT is exactly that type function.  It takes a (* -> *)  -- your original monad -- and yields another (* -> *)  -- a new monad, with the same effects, but short circuiting
01:34:55 <julianleviston> jle`: given that MonadTs are basically layered monads… no?
01:34:56 <jle`> *but with short-circuiting
01:35:05 <jle`> i wouldn't think of them as layered monads
01:35:11 <jle`> it's not even clear what it means to be a layered monad
01:35:19 <jle`> MaybeT is a type function that takes a monad and yields a new monad
01:35:21 <sanket_> where to start for developing??
01:35:22 <julianleviston> jle`: lol… but how else do you explain that you need to use lift on functions?
01:35:24 <jle`> it's a (* -> *) -> (* -> *)
01:35:39 <jle`>        ^ the input monad, ^ the output monad
01:35:41 <julianleviston> jle`: I suppose because those functions aren’t designed to be used in a context such as that.
01:35:51 <julianleviston> sanket_:  what do you mean?
01:36:31 <sanket_> i want to start developing for haskell
01:36:43 <sanket_> and i am new to developing
01:36:44 <jle`> you can't write something like MaybeT in another language that doesn't have higher-kinded types.  MaybeT itself is a function that acts on * -> *'s, so you need to be able to have higher-kinded types to even come close to the idea
01:36:51 <u-ou> jle`: why do the (* -> *)'s have to be monads?
01:37:10 <jle`> well, the resulting (* -> *) is only a Monad if the input (* -> *) is a Monad
01:37:25 <jle`> you can also think of it as a Functor transformer too...it takes a Functor and yields a new Functor
01:37:34 <u-ou> ok
01:37:42 <pdxleif> Install GHC - that gives you a repl to play around with (ghci)
01:37:52 <julianleviston> jle`: (often wondered) if you have a stacked monad in one order and then flip the order will the same do blocks work?
01:37:53 <julianleviston> sanket_: yeah…?
01:37:53 <julianleviston> sanket_: do you mean “How can I start learning haskell"?
01:37:53 <pdxleif> and cabal-install gives you a tool for installing libraries
01:38:08 <sanket_> no
01:38:20 <sanket_> i want to contribute for haskell
01:38:21 <jle`> sanket_: do you mean, you want to contribute to GHC, the compiler?
01:38:35 <sanket_> yup
01:38:38 <julianleviston> sanket_: can you paraphrase your question? Use more words.
01:38:39 <jle`> julianleviston: i think that depends on specific circumstances
01:38:44 <julianleviston> sanket_: oh ok.
01:38:50 <julianleviston> sanket_: so what’s your questions?
01:38:56 <jle`> can't really make generalized statements like that
01:39:13 <julianleviston> jle`: in that case “order” does matter (sometimes).
01:39:30 <julianleviston> jle`: that’s good,because it is in harmony with what I thought :)
01:39:37 <pdxleif> https://ghc.haskell.org/trac/ghc/wiki/Building
01:39:49 <julianleviston> jle`: so thinking of them as a stack is not that improper.
01:40:00 <julianleviston> jle`: monad transformers, I mean.
01:40:10 <julianleviston> jle`: or, rather, monads built from transformers
01:40:52 <sanket_> i am new to open source and i want to start contributing for haskell
01:41:14 <pdxleif> There's libraries that could use contributions, too.
01:42:39 <jle`> sanket_: you can ask in #ghc , too :)
01:42:47 <jle`> most people who hack on or contribute to GHC are on there
01:42:52 <sanket_> so from where can i start
01:42:54 <jle`> so you can get concrete/solid advice
01:43:00 <jle`> on practical steps
01:43:12 <sanket_> ok thanks
01:50:18 <julianleviston> ggole: thanks!
01:50:21 <julianleviston> jle`: thanks also!
01:50:28 <jle`> np!
01:50:39 <julianleviston> and everyone else too! :)
02:03:31 <ReinH> happy new year everyone or whatever
02:12:17 <ggole> julianleviston: my pleasure
02:27:38 <u-ou> which haskell book should i read? im thinking bite-my-apps's book...
02:29:44 <u-ou> jle`: ^
02:30:01 <jle`> i've heard a lot of good things about that one :)
02:37:45 * hackagebot webapi 0.1.0.0 - WAI based library for web api  https://hackage.haskell.org/package/webapi-0.1.0.0 (ersran9)
03:12:46 * hackagebot HTTP 4000.3.1 - A library for client-side HTTP  https://hackage.haskell.org/package/HTTP-4000.3.1 (GaneshSittampalam)
03:27:03 <bollu> if I want to learn arrows, what do I do?
03:27:12 <bollu> Are there arrow instances that I can play around with?
03:27:18 <bollu> Also, the special arrow syntax, how do I learn it?
03:36:07 <wedens> bollu: what does it mean "to learn arrows"? just start using them
03:36:39 <wedens> bollu: opaleye or hxt
03:37:30 <wedens> also there is a good article  on wikibooks https://en.wikibooks.org/wiki/Haskell/Understanding_arrows
03:38:27 <wedens> (btw, some people think that arrows are subsumed by strong profunctors)
03:43:43 <bollu> wedens: sorry, I DC'd
03:43:51 <bollu> wedens: in that case, where can I learn about strong profunctors?
03:47:57 <wedens> bollu: I don't know. maybe start with just profunctors?
03:49:40 <bollu> wedens: hm, alright. So what's a profunctor? :)
03:51:57 <wedens> bollu: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/profunctors
03:53:05 <ggole> :t (.)
03:53:06 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:53:09 <ggole> Hmm.
03:53:31 <wedens> bollu: there is a paper about arrows as profunctors: http://www-mmm.is.s.u-tokyo.ac.jp/~ichiro/papers/fromComptoComp.pdf
03:54:04 <bollu> wedens: thank you
03:56:32 <bollu> I'm sorry, I'm confused. It's "just" a type that's contra with respect to the first argument and covariant with respect to the second?
03:56:41 <bollu> isn't that a little… arbitrary?
03:57:47 * hackagebot sdl2 2.1.1 - Both high- and low-level bindings to the SDL library (version 2.0.3).  https://hackage.haskell.org/package/sdl2-2.1.1 (OliverCharles)
04:07:47 * hackagebot wai-session-postgresql 0.1.1.1 - PostgreSQL backed Wai session store  https://hackage.haskell.org/package/wai-session-postgresql-0.1.1.1 (hc)
04:21:38 <bollu> is there a function that returns me the first hit of a predicate from a list, and Nothing otherwise?
04:22:46 <Freundlich> find in Data.List or the more general find in Data.Foldable.
04:23:05 <bollu> ooh, thanks!
04:24:42 <bollu> is there an isNothing or something of the sort?
04:25:38 <Freundlich> There is (and it's called exactly that) but that's probably not what you want to use.
04:26:20 <bollu> :t isNothing
04:26:22 <lambdabot> Maybe a -> Bool
04:26:27 <Freundlich> Unless you want to ignore the Just-case...
04:27:01 <bollu> Freundlich: yes, I want to error out if the value is Nothing, so I'm plannning on doing something like when (isNothing value) errorout
04:27:48 * hackagebot data-embed 0.1.0.0 - Embed files and other binary blobs inside executables without Template Haskell.  https://hackage.haskell.org/package/data-embed-0.1.0.0 (AntonEkblad)
04:37:36 <bollu> how do I comfortably use Maybe values inside an IO context?
04:37:52 <bollu> I have a Maybe Filepath and I want to run it against something of the type Filepath -> IO ()
04:37:59 <bollu> but I can't >>= it obviously
04:38:02 <bollu> so what's the right solution?
04:47:27 <pavonia> bollu: Wrap everything into MaybeT is an option
04:49:13 <cocreature> you can also go for traverse which will give you a Maybe FilePath -> IO (Maybe ())
04:49:25 <bollu> cocreature: slick
04:49:40 <bollu> cocreature: I'd never thought of using traversable likt that
04:50:15 <bollu> pavonia: can you tell me how that will help? I'm operating in a global context of IO () (since I'm using turtleP
04:50:39 <bollu> )*
04:53:13 * hackagebot gi-atk 0.2.18.10 - Atk bindings  https://hackage.haskell.org/package/gi-atk-0.2.18.10 (inaki)
04:53:15 * hackagebot gi-gdk 0.3.18.10 - Gdk bindings  https://hackage.haskell.org/package/gi-gdk-0.3.18.10 (inaki)
04:54:35 <athan> Could anyone here provide an example of a /useful/ Rank >2 type?
04:55:15 <osa1> athan: ST monad
04:55:22 <osa1> athan: see runST
04:57:10 <osa1> oh, you said >2
04:57:43 <osa1> I read it as >=2. I don't know any >2
04:58:17 * hackagebot gi-gdkpixbuf 0.2.32.10 - GdkPixbuf bindings  https://hackage.haskell.org/package/gi-gdkpixbuf-0.2.32.10 (inaki)
04:58:19 * hackagebot gi-gio 0.2.46.10 - Gio bindings  https://hackage.haskell.org/package/gi-gio-0.2.46.10 (inaki)
04:58:21 * hackagebot gi-glib 0.2.46.10 - GLib bindings  https://hackage.haskell.org/package/gi-glib-0.2.46.10 (inaki)
04:58:23 * hackagebot gi-gobject 0.2.46.10 - GObject bindings  https://hackage.haskell.org/package/gi-gobject-0.2.46.10 (inaki)
04:58:25 * hackagebot gi-gtk 0.3.18.10 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-0.3.18.10 (inaki)
04:59:04 <athan> osa1: For some reason, I knew that was going to happen :P
04:59:06 <potatoe`> Hi, I'm trying to use the library Network.Wreq to do a POST request and I have the following code
04:59:14 <potatoe`> can someone advice me on the type errors here?
04:59:32 <osa1> heh
04:59:42 <athan> osa1: I guess just higher-order polymorphism, like a natural transformation between polymorphic continuations lol
04:59:51 <potatoe`> http://lpaste.net/148185
05:00:21 <potatoe`> firstly, statusCode seems to be an Int, and I'm focussing on it with the lens, but I can't return it
05:00:52 <athan> forall b. (forall a. ((forall r1. a -> r1) -> b) -> ((forall r2. a -> r2) -> b))
05:00:52 <potatoe`> it says couldn't match IO Int with Int, but since Wreq is a library that does IO shouldnt it be in the IO monad?
05:01:30 <pavonia> potatoe`: Could you add the complete error message to that paste?
05:01:37 <potatoe`> pavonia okay, sec
05:03:24 <potatoe`> pavonia http://lpaste.net/148185
05:03:27 * hackagebot gi-javascriptcore 0.2.10.10 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-0.2.10.10 (inaki)
05:03:29 * hackagebot gi-notify 0.2.32.10 - Notify bindings  https://hackage.haskell.org/package/gi-notify-0.2.32.10 (inaki)
05:03:31 * hackagebot gi-pango 0.1.38.10 - Pango bindings  https://hackage.haskell.org/package/gi-pango-0.1.38.10 (inaki)
05:03:33 * hackagebot gi-soup 0.2.52.10 - Soup bindings  https://hackage.haskell.org/package/gi-soup-0.2.52.10 (inaki)
05:03:35 * hackagebot gi-vte 0.0.42.10 - Vte bindings  https://hackage.haskell.org/package/gi-vte-0.0.42.10 (inaki)
05:08:20 <pavonia> potatoe`: I don't know what's wrong, sorry. The lens operators are confusing me
05:08:37 * hackagebot gi-webkit2 0.2.10.10 - WebKit2 bindings  https://hackage.haskell.org/package/gi-webkit2-0.2.10.10 (inaki)
05:08:42 <potatoe`> no problem, I will wait till someone comes along, thank you for looking anyway
05:14:42 <roelof> How can I make this work : http://lpaste.net/148184 ?
05:19:19 <pavonia> roelof: What would you like to match on the empty list in line 2?
05:20:54 <roelof> pavonia:  if a user enters a empty list ? 
05:21:50 <pavonia> So if l is empty?
05:22:07 <roelof> pavonia:  yep 
05:22:54 <pavonia> So you could use "makeTotal2 [] = []" and add another definition for the non-empty case
05:24:09 <pavonia> or "case l of { [] -> []; ... }"
05:24:15 <roelof> I could do that. So you mean make several small functions instead of 1 big one
05:24:25 <roelof> So no guards only pattern matching 
05:25:01 <pavonia> You could also check that by guards but that's not the way you usually do that
05:25:11 <julianleviston> roelof: I’m really confused about the intent of your code.
05:25:15 <pavonia> i.e. " | l == [] 0 []"
05:25:27 <pavonia> " | l == [] = []"*
05:25:35 <roelof> but then the function with the acc  is public and I want to hide that one 
05:25:47 <julianleviston> roelof: a suggestion I’d have is to not do anything fancy at first, but write out all the cases first, repeating yourself, THEN get rid of repetition.
05:26:30 <roelof> julianleviston:  oke, so make some 4 seperate functions 
05:26:41 <julianleviston> roelof:  no.
05:26:45 <roelof> I can do that , moment 
05:26:50 <julianleviston> roelof:  depending on what you mean by it.
05:27:18 <julianleviston> Also, how does the guard | [] = [] work?
05:27:34 <pavonia> roelof: Not that you can't match on patterns in a guard, you only can have expressions of type Bool there
05:27:45 <julianleviston> oh phew :)
05:27:54 <roelof> one for a empty input , one for the rest. one for the case that the second list is empty and the acc has a value and for the second list is not empty and the acc has a value 
05:27:54 <julianleviston> I thought I was going nuts :)
05:28:28 <roelof> oke, that is my problem 
05:28:43 <julianleviston> roelof:  it’d be best if you actually explained what you want your code to do… there may be a simpler way to do it.
05:29:09 <julianleviston> is this just a total function?
05:29:10 <pavonia> And then your l's are never used, which is extra confusing
05:29:14 <julianleviston> on a list?
05:29:28 <julianleviston> roelof: there are a lot of better ways to do that if that’s all it is.
05:29:30 <roelof> yes, I know there a simpler ways to do it. I did solved it already with a list comprehension 
05:29:36 <julianleviston> roelof:  depending on what your constraints are
05:29:40 <julianleviston> roelof:  ok.
05:29:52 <julianleviston> roelof: so you want to use a helper function and recursion right?
05:30:31 <roelof> but I like to experiment if there are more then 1 solution  , and because I have learned recursion. I thought I try it on that way 
05:30:34 <julianleviston> you seem to be returning sometimes a list ([]) and sometimes a number 
05:30:38 <julianleviston> roelof:  sure.
05:30:43 <julianleviston> roelof:  excellent idea!
05:30:43 <roelof> yes 
05:30:52 <julianleviston> roelof:  a function can only return ONE type, though, so that’s a problem
05:31:00 <julianleviston> total [] = 0 would be bett
05:31:02 <julianleviston> better*
05:32:00 <secox9o> pavonia apparently I just needed to bracket the lens getters 
05:32:07 <secox9o> for example return $ r ^. ..
05:32:09 <julianleviston> then total xs = go 0 xs where go acc [] = acc; go acc (y:ys) = go (acc + y) ys
05:32:11 <julianleviston> something like that.
05:32:55 <roelof> oke, I have now this : http://lpaste.net/148187 
05:33:03 <secox9o> how do I perform implicit String -> Text conversions?
05:33:06 <julianleviston> roelof:  I suggest you write that out, get it compiling, then set that solution aside, don’t look at it, and create it again.
05:33:15 <julianleviston> secox9o: do you mean explicit?
05:33:30 <secox9o> julianleviston well its just that I do not want to keep writing pack myString
05:33:51 <roelof> how can I make the helper function work on the case  that acc has a value and the list the user enters is empty so we processed all the list 
05:34:13 <julianleviston> roelof:  BillType = [] ?
05:34:25 <julianleviston> roelof:  BillType is just Num a => [a] ?
05:34:46 <pavonia> potatoe: You can only convert string literals implicitly, AFAIK
05:34:58 <roelof> julianleviston:  type BillType = [(Name,Price)]  
05:35:05 <potatoe> pavonia but ghc screams at me that it can't
05:35:09 <julianleviston> roelof:  ah ok… one sec.
05:35:31 <pavonia> potatoe: Have you enabled OverloadedStrings?
05:35:34 <potatoe> yep
05:35:36 <roelof> and only the price is interressed here 
05:37:01 <julianleviston> roelof:  yep gotcha. Give me a sec.
05:37:17 <pavonia> potatoe: Could you paste the code?
05:37:33 <roelof> julianleviston:  take all the time you need, im not in a hurry 
05:37:47 <julianleviston> pavonia: pretty sure they’re not literals
05:38:40 <potatoe> pavonia http://lpaste.net/148188
05:38:50 <potatoe> does lambdabot no longer grab pastes automatically?
05:39:35 <pavonia> potatoe: julianleviston is right, "from email" is not a literal
05:39:57 <potatoe> ah, so I have no choice but to pack it myself
05:40:00 <julianleviston> pavonia: ok I’m wrong :) soz :)
05:40:12 <julianleviston> potatoe: s/he was being sarcastic :)
05:40:29 <pavonia> ?
05:41:17 <julianleviston> oh… maybe not?
05:41:47 <pavonia> Ah, I get it, ‘from email’ is not a literal but a function application :)
05:42:02 <pavonia> I shouldn't have used string quotes
05:43:15 <AndriusBartulis> What would happen if we had an imperative programming language like lets say PHP and we change the scope system to work as follows: variables and objects can only be accessed in the scope level context they are defined in. In other words, if you create an object MyDatabase and wanted to act upon it in any way in other contexts besides the current context of where it was defined, you would have to explicitly pass 
05:43:15 <AndriusBartulis> the MyDatabase object to the function/method that wants to use it in any way. Wouldn't this make all functions within such a language much more pure as everything that a function will modify will be explicitly stated in the function arguments? I am just thinking of whether I missed some obvious problem of why this would not work, and why we could not force an imperative language to have this kind of limited scope
05:43:16 <AndriusBartulis>  system.
05:44:39 <julianleviston> roelof: http://lpaste.net/148187
05:45:00 <julianleviston> roelof: Have a read and let me know if it makes sense or not.
05:45:15 <roelof> IM reading it now 
05:45:15 <julianleviston> roelof: I tried to be very explicit and not skip steps
05:47:25 <julianleviston> roelof: just adjusted a couple of (silly) names.
05:48:01 <roelof> yes, I saw it, So I have to use a let in  to make it work 
05:48:13 <julianleviston> roelof: no, not necessarily
05:48:29 <julianleviston> you could say go (acc + p) ps
05:48:41 <roelof> oke, thanks 
05:48:45 <julianleviston> roelof: and by the way, that’s a verbatim fold there. 
05:48:57 <roelof> I will try the idea on my own code 
05:48:58 <julianleviston> roelof: lpaste is even suggesting it to you.
05:49:09 <roelof> bu first a late lunch 
05:49:12 <roelof> thanks 
05:51:00 <julianleviston> roelof: but the easiest is total = sum . map snd
05:51:17 <julianleviston> roelof:  sorry, “briefest”
05:52:06 <roelof> julianleviston:  oke, thanks, In the craft book map is not explained so I do not want to use it. I want to use what I have learned so far 
05:52:51 <julianleviston> roelof: ah ok… map is just function application across a list, recursively.
05:53:29 <julianleviston> roelof: I’ll add a version that doesn’t use map (I’m using it to extract the numbers at the moment)
05:53:58 <roelof> I have seen map on other functional languages like clojure which I tried for some days 
05:55:08 <julianleviston> roelof: there you go.
05:55:35 <julianleviston> roelof: it’s not hard. It just makes a new list with a function applied to every element.
05:55:50 <julianleviston> > map (+1) [1,2,3]
05:55:52 <lambdabot>  [2,3,4]
05:56:33 <julianleviston> roelof: (+1) means increment a number… then map (+1) means “give me a list of numbers and I’ll increment them all"
05:57:50 <roelof> yes, I know that part 
05:57:55 <julianleviston> roelof:  sorry :)
05:58:38 <roelof> and now I see why someone said first higher functions, then list comprehension and then recursion 
05:58:55 <roelof> recursion is very hard to do on more complex problems 
05:58:58 <julianleviston> roelof: recursion is best to learn first.
06:00:09 <julianleviston> roelof: higher order functions, folds and list comprehensions are easier to understand once you understand how recursion works, in my opinion.
06:00:42 <julianleviston> roelof: because most of them use recursion to do their work.
06:01:02 <julianleviston> roelof: even though list comprehensions are often taught fairly early on, I don’t think they should be, personally.
06:02:20 <roelof> oke, the list comprehension I had working in less then 1 hour. This one costs me more then 2 hours 
06:02:34 <julianleviston> roelof: yes, but you don’t understand list comprehensions.
06:02:53 <julianleviston> roelof: because they’re actually special syntax on something far more deep.
06:03:05 <roelof> nope , I just learned them. This are exercises on that chapter 
06:03:07 <julianleviston> roelof: but you’re right, they’re easy to use.
06:03:23 <julianleviston> roelof: that doesn’t mean you understand what’s going on though...
06:03:47 <julianleviston> roelof: (not trying to be rude or confrontational here)
06:05:07 <roelof> you are not rudy , You tell me your oponion based on my remarks 
06:05:39 <julianleviston> good o
06:06:25 <mjburgess> "far more deep" ?
06:06:26 <julianleviston> roelof: it’s very important to understand recursion… because they’re one of the most basic things in haskell, and a good understanding of them will make learning folds and other things much easier.
06:06:35 <mjburgess> you mean maps, filters, etc?
06:06:49 <julianleviston> mjburgess: no
06:07:22 <mjburgess> what are you refering to then?
06:07:24 <julianleviston> mjburgess: it’s a syntax for the List monad.
06:07:39 <mjburgess> oh, right, yeah np
06:07:42 <julianleviston> mjburgess: as far as my understanding goes.
06:09:00 <julianleviston> mjburgess: apparently, all Monads had comprehension syntax originally, according to the wiki..
06:09:06 <roelof> I have to leave for some minutes , some internet problems here 
06:09:11 <mjburgess> they do in scala
06:09:54 <AndriusBartulis> My friend who got me into Haskell is a liar. He convinced me that its not hard.
06:09:58 * AndriusBartulis shakes his head
06:10:12 <julianleviston> AndriusBartulis:  programming is hard.
06:10:55 <julianleviston> AndriusBartulis: and Haskell doesn’t hide the nuts and bolts as much as other languages, it also adds some additional constraints (which turn out to be very useful a lot of the time).
06:11:28 <julianleviston> AndriusBartulis: anyone who tells you otherwise is trying to sell you something :)
06:12:21 <julianleviston> AndriusBartulis: though, that comment about nuts and bolts hiding may or may not be accurate, depending on how you’re viewing things when you read it :)
06:12:23 <AndriusBartulis> I think most programming languages (modern high level) are designed to be very productive and support the pragmatic programmers
06:12:38 <AndriusBartulis> Haskell is more academic and idealistic.
06:12:49 <julianleviston> AndriusBartulis: it’s easy to get into a mess with most common languages.
06:12:57 <julianleviston> AndriusBartulis: I disagree with that.
06:12:59 <julianleviston> AndriusBartulis: what are you finding difficult?
06:14:18 <AndriusBartulis> I am not complaining about Haskell. So far it has been the most interesting language I have been learning. All I am saying is that the learning curve to reach productivity is significantly steeper then say, Python or even Java.
06:14:35 <julianleviston> AndriusBartulis: I don’t agree with that.
06:14:35 <AndriusBartulis> I think the main difficulty is relearning programming from scratch.
06:14:55 <julianleviston> AndriusBartulis: Ok that’s something different, isn’t it?
06:15:14 <julianleviston> AndriusBartulis: if you said “the learning curve after having learnt a different language is about the same as learning programming again” I’d agree with you.
06:15:23 <julianleviston> AndriusBartulis: because you ARE learning programming again.
06:15:49 <julianleviston> AndriusBartulis: but I don’t think that’s a problem with Haksell.
06:16:05 <julianleviston> AndriusBartulis: it’s not Haskell’s fault people have to learn it from scratch :)
06:16:24 <julianleviston> AndriusBartulis: any more than it’s C++’s fault people have to learn THAT from scratch :)
06:17:02 <julianleviston> AndriusBartulis: Also, there *are* less easy and more easy paths...
06:17:42 <AndriusBartulis> I agree with you :) Once again, not bashing Haskell. It beautiful. Hence I am here. Just saying its difficult to reach productive level from my specific position, as I have been thinking, dreaming and working on imperative languages for the last 10 years (C, C++, Java, PHP). Which is where most programmers are. 
06:17:43 <julianleviston> AndriusBartulis: Haskell suffers from a very few excellent learning materials problem… we have at most about 10 very good books… whereas other languages usually have a minimum of 10 very good books.
06:18:20 <AndriusBartulis> Yeah fully agree with you on that too.
06:18:30 <julianleviston> AndriusBartulis: oh, please don’t think I’m being defensive :) I’m very much in agreement with you. It’s not a trivial task to pick up the language and build a very big app in the first month of using it.
06:18:44 <AndriusBartulis> My first intro to Haskell was with Erik Meijers FP101 MOOC course
06:18:48 <julianleviston> (something I did in Ruby the first time I used it)
06:18:51 <AndriusBartulis> Which was quite good.
06:20:21 <julianleviston> AndriusBartulis: how long have you been learning it?
06:20:30 <julianleviston> AndriusBartulis: (if you don’t mind me asking)
06:20:41 <AndriusBartulis> But after doing it I was like... Ok, so I know what types are, what type classes are, kind of get the idea of monads and monoids, kind of get higher order functions and function composition etc.... Yet how do I combine all that and build something functional.
06:20:52 <julianleviston> Ah yeah, that’s a big gap.
06:20:56 <AndriusBartulis> julianleviston: only about a few months.
06:21:47 <AndriusBartulis> I wrote a simple IRC bot by following that irc bot tutorial on the haskell wiki page. Which was the best thing so far that I found to give me an idea of how to use all the constructs of the language together.
06:21:58 <julianleviston> AndriusBartulis: my approach (I’d like to build some materials) is to set up a bunch of exercises, and show the person how they work, and then say “ok now build this, and this and this” (examples of things which are similar) and build on that.
06:22:06 <julianleviston> because that’d bridge the gap for real code.
06:23:07 <AndriusBartulis> Yeah... So haskell needs more good learning material for beginners. I know there is a Haskell Book project thats about to be completed soon... Looks promissing.
06:23:15 <AndriusBartulis> People say good things about it.
06:23:31 <julianleviston> I think it’s very important for beginners to see many real code examples of a certain thing, and then to be asked to do a simple version of that thing.
06:23:54 <julianleviston> AndriusBartulis: actually, I don’t think that will help you too much. It *is* very good, but it’s not project based… 
06:24:07 <julianleviston> AndriusBartulis: the CIS course sounds like it’d be best for you
06:24:12 <julianleviston> @where CIS194
06:24:12 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
06:24:20 <AndriusBartulis> Sure. But I would say those examples should not just be single snippets of code but a functional program. Something simple but a complete working program.
06:24:26 <julianleviston> yep.
06:24:29 <julianleviston> seriously. Check that out.
06:24:44 <AndriusBartulis> OK thanks.
06:25:00 <julianleviston> AndriusBartulis: also I’ll give you my incomplete exercises, which may or may not help. They don’t explain anything though.
06:25:15 <julianleviston> AndriusBartulis: http://www.genericoverlords.com/haskell_exercises
06:25:26 <AndriusBartulis> Almost bought that Haskell Book yesterday but when I saw that its 70USD in UK, I was going to first check out a few more reviews before buying it to make sure its worth it.
06:25:28 <julianleviston> AndriusBartulis: they get to real programs as it goes on… 
06:25:41 <sphinxo> How can I get rid of all these newlines? http://lpaste.net/148198
06:25:55 <julianleviston> AndriusBartulis: I’m the guy who wrote the top review here: http://haskellbook.com/feedback.html
06:27:31 <Gurkenglas> Is there something like minimumOn, to complete the rectangle of minimumBy, sortBy and sortOn?
06:27:54 <AndriusBartulis> So maybe its worth it after all. Might fill the gaps in my understanding of the foundational concepts. For example, until a few days ago I didn't even know what Eta conversion was in function composition even though most people who write Haskell do Eta reduction automatically without even thinking about it.
06:28:20 <AndriusBartulis> Its maths stuff :)
06:28:20 <julianleviston> AndriusBartulis: I don’t know what that is.
06:28:23 <Gurkenglas> Oh wait searching by type signature wtfbrain.
06:28:25 <julianleviston> AndriusBartulis: what’s eta conversion?
06:28:35 <julianleviston> Gurkenglas: lol
06:29:34 <AndriusBartulis> julianleviston: Maybe you do and think you dont :) Its converting a function composition into Point-free style. For example:
06:29:49 <julianleviston> Gurkenglas: oh… I was about to ask if it was point-free conversion. right.
06:30:14 <julianleviston> eta reduction, eta abstraction.
06:31:23 <julianleviston> I always forget the name… also beta reduction and alpha conversion
06:31:37 <AndriusBartulis> So instead of writing      f x = ((+) 10) .  ( ((/) 20) ) x       you can Eta reduce it to     f = ((+) 10) . ( (/) 20 )
06:31:41 <AndriusBartulis> So yea
06:32:15 <julianleviston> erm
06:32:19 <AndriusBartulis> Or actually just f = (10+) . (20/)
06:32:37 <julianleviston> cool
06:33:07 <julianleviston> lambdabot has an eta reduction thing in it. I can’t ever remember the name/syntax for calling it tho
06:33:47 <ggole> @pl \x -> ((+) 10) .  ( ((/) 20) ) x
06:33:47 <lambdabot> ((10 +) .) . (20 /)
06:34:34 <julianleviston> that’s it.
06:34:34 <AndriusBartulis> But yeah... what I mean, is that before I would have written it in non free point style. Simple little detai.
06:35:20 <julianleviston> ok
06:35:45 <julianleviston> is that because you didn’t know about currying?
06:35:49 <sphinxo> Say I have a list of strings and I want to filter out the strings which contain a certain sequence of chars
06:35:53 <sphinxo> How would I do this?>
06:35:55 <julianleviston> I assume if you did a meijer course you’d know all about currying
06:36:11 <julianleviston> sphinxo: you know filter, right?
06:36:30 <sphinxo> yes julianleviston can I do it with a sequence?
06:36:44 <AndriusBartulis> Yes Erik did a good job on clarifying currying
06:36:45 <julianleviston> sphinxo: what’s a sequence?
06:36:59 <sphinxo> ok another string
06:37:06 <julianleviston> sphinxo: yeah
06:37:40 <julianleviston> sphinxo: you want a function whose type is Char -> [Char] -> Bool
06:37:59 <julianleviston> sphinxo: https://www.haskell.org/hoogle/?hoogle=Char+-%3E+%5BChar%5D+-%3E+Bool
06:38:11 <julianleviston> sphinxo: there’s one in Data.List called elem
06:38:12 <julianleviston> :t elem
06:38:13 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
06:38:44 <julianleviston> You can think of t a as [a] if you’d like.
06:38:53 <sphinxo> ahh ok
06:39:00 <julianleviston> sphinxo: so anyway
06:39:02 <ggole> "Contain a sequence of characters", so (I think) it would be [Char] -> [Char] -> Bool
06:39:10 <ggole> @hoogle [Char] -> [Char] -> Bool
06:39:12 <lambdabot> System.FilePath.Windows equalFilePath :: FilePath -> FilePath -> Bool
06:39:12 <lambdabot> System.FilePath.Posix equalFilePath :: FilePath -> FilePath -> Bool
06:39:12 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
06:39:30 <julianleviston> ggole:  I’m showing him how to build it himself.
06:39:44 <julianleviston> ggole: but all good - you go ahead :)
06:39:53 <ggole> How is elem useful for that?
06:40:08 <Neomex> so my friends dad gave me this program to write, its pretty much silver items collection, I've made a tree with all the categories he wanted. He wants to first make a collection in the program and then put it all in the website, so my first thought was database, but maybe I can just come up with some folder structures where all the data is saved and then someone who will be making website will just have to write custom script that reads from 
06:40:17 <Neomex> the file structure
06:40:18 <julianleviston> any mixed with elem
06:40:27 <AndriusBartulis> julianleviston: My goal now is to use Haskell in production by the end of 2016. A bit ambitious but I think I can do it.
06:40:36 <Neomex> thats what i have so far http://i.imgur.com/aO1R8x6.png i thought of iterating through the nodes and find out which one doesnt have children and then add the on click event to display data that is under its category, but im not sure if this will work out and am worried that i might have to add event by hand to each category without children
06:40:41 <julianleviston> AndriusBartulis: I did it within 6 months, so you probably can.
06:40:42 <sphinxo> Ahh ok thanks julianleviston and ggole 
06:41:05 <julianleviston> ggole: but isInfixOf is much better!
06:41:13 <Neomex> It is C# though, but I've hear you guys are super friendly here :D
06:41:20 <Neomex> heard*
06:41:21 <ggole> julianleviston: a sequence of chars implies order, which elem will ignore
06:41:41 <julianleviston> ggole: he wanted to filter … that doesn’t imply order does it?
06:41:57 <Neomex> also, do you know any web development irc channels?
06:42:00 <julianleviston> ohhhh
06:42:06 <julianleviston> ggole: I misunderstood completely.
06:42:13 <julianleviston> ggole: thank god you’re here!
06:42:14 <ggole> My understanding is that there is a list of strings, from which we want to reject the ones containing a sequence of chars
06:42:25 <AndriusBartulis> Neomex: there is a great c sharp channel #csharp
06:42:42 <sphinxo> Ok, I thought of using a list of strings to simplify the problem
06:42:43 <Neomex> they didnt reply to me there, ive tried it earlier
06:42:54 <julianleviston> ggole: yeah, depending on what he means by sequence… in either case, I would have led him up the wrong path because I thought he meant “hello there how are you” , want to filter “aeio” or something like that.
06:43:02 <Neomex> its more of a general question so i thought i could post it here aswell
06:43:09 <sphinxo> http://lpaste.net/148199
06:43:25 <julianleviston> sphinxo: what exactly do you want to do? We’re a bit unsure (or I am)
06:43:44 <AndriusBartulis> Neomex: Maybe because C Sharp guys usually take their holidays seriously and would never spend their January 1 on IRC talking about code? Jokes.
06:44:01 <sphinxo> I have a list of sequences and I want to filter out the ones which don't contain bases in a certain order
06:44:22 <AndriusBartulis> Neomex: so let me re read your question again... Don't quite fully get the issue...
06:44:26 <julianleviston> sphinxo: ok.. .so isInfixOf is correct.
06:44:52 <sphinxo> so given something like TCGATTT it'll only return sequences which have bases in that order
06:45:33 <julianleviston> :t not . isInFixOf 
06:45:34 <lambdabot>     Not in scope: ‘isInFixOf’
06:45:35 <lambdabot>     Perhaps you meant one of these:
06:45:35 <lambdabot>       ‘BSC.isInfixOf’ (imported from Data.ByteString.Char8),
06:45:39 <julianleviston> hm
06:45:52 <julianleviston> oh stupid 
06:45:56 <julianleviston> :t isInfixOf
06:45:58 <lambdabot> Eq a => [a] -> [a] -> Bool
06:46:04 <julianleviston> :t not . isInfixOf
06:46:06 <lambdabot>     Couldn't match type ‘[a] -> Bool’ with ‘Bool’
06:46:06 <lambdabot>     Expected type: [a] -> Bool
06:46:06 <lambdabot>       Actual type: [a] -> [a] -> Bool
06:46:43 <AndriusBartulis> Neomex: ok I think I get your question. You want to build a web application for you friends Silver items collection. And before you build a website for it, you want to first build a tool that your friend can use to populate the collection that will later be imported into the website?
06:47:48 <julianleviston> :t testCharSeq -> not . isInfixOf testCharSeq
06:47:49 <Neomex> yes, he wants the app first so he can populate it and later me or someone else will build a website
06:47:50 <lambdabot> parse error on input ‘->’
06:47:55 <ggole> > filter (not . (isInfixOf "abc")) ["watabc","wat","ab","abc"]
06:47:56 <Neomex> my first thought was to use database
06:47:56 <julianleviston> guh. I fail.
06:47:57 <lambdabot>  ["wat","ab"]
06:48:15 <julianleviston> Oh he doesn’t want not then.
06:48:16 <Neomex> but maybe just some folder structure will be enough if later someone writes a script that reads it on the website
06:48:30 <julianleviston> Neomex: sorry, but does this have anything to do with Haskell?
06:48:32 <AndriusBartulis> Neomex: So define the data type for an item in the collection. What properties does a silver item have? Title? Description? Pictures?
06:49:25 <Neomex> pictures of any count and few textfields for persons name, sign number, location, and some notes
06:49:49 <julianleviston> Neomex: are you talking about Haskell?
06:50:11 <sphinxo> Neomex: Maybe just try #programming ?
06:50:12 <Neomex> julianleviston, nop, more of a general programming/design question
06:50:21 <AndriusBartulis> Neomex: And julianleviston is right, this is not a haskell question so probably best if we move this discussion somewhere else
06:50:34 <julianleviston> Neomex: try #haskell-blah
06:50:44 <Neomex> should we jump into #programming AndriusBartulis ?
06:50:51 <AndriusBartulis> ok
06:51:42 <julianleviston> sphinxo: so do you have enough to go on?
06:52:17 <sphinxo> I think so
06:52:53 <sphinxo> I'll give you a more detailed example
06:53:20 <julianleviston> sweet.
06:54:12 <sphinxo> http://lpaste.net/148199 Something that given ACG only returns 'meh'
06:54:20 <sphinxo> the 'sequence' meh
06:56:10 <sphinxo> I've also seen filter (/=<something>)
06:57:16 <julianleviston> sphinxo: (/=<something) means not equal to <something>
06:57:24 <julianleviston> > 1 /= 3
06:57:25 <lambdabot>  True
06:57:32 <julianleviston> > (/= 3) 1
06:57:35 <lambdabot>  True
06:57:53 <sphinxo>  filter (/='!') "!!some!!_!!string!!"
06:57:58 <sphinxo> "some_string"
07:01:39 <NightRa> > show ("hello" :: ByteString)
07:01:42 <lambdabot>      Not in scope: type constructor or class ‘ByteString’
07:01:42 <lambdabot>      Perhaps you meant one of these:
07:01:42 <lambdabot>        ‘BSC.ByteString’ (imported from Data.ByteString.Char8),
07:01:55 <NightRa> > show ("hello" :: Data.ByteString.ByteString)
07:01:57 <lambdabot>      Not in scope:
07:01:58 <lambdabot>        type constructor or class ‘Data.ByteString.ByteString’
07:01:58 <lambdabot>      Perhaps you meant ‘Data.ByteString.Lens.IsByteString’ (imported from Dat...
07:04:51 <NightRa> Anyhow, it seems that ByteString's Read instance is broken
07:05:15 <NightRa> fromString behaves properly, but the read instance doesn't
07:05:28 <NightRa> Even though it seems it should
07:05:28 <NightRa> https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/src/Data.ByteString.Internal.html#line-213
07:05:58 <NightRa> > read "hello" :: BS.ByteString
07:06:00 <lambdabot>  "*Exception: Prelude.read: no parse
07:06:01 <mauke> > read "\"foo\"" :: BSC.ByteString
07:06:03 <lambdabot>  "foo"
07:06:05 <mauke> works fine
07:06:45 <julianleviston> sphinxo: http://lpaste.net/148199
07:07:02 <happy0> i was wondering if anyone fancied giving me a hand trying to connect a persist selectSource to a websocket sink in yesod. here's my attempt: http://lpaste.net/3730281295322808320 , and here's the compile error i get: http://lpaste.net/148201
07:07:26 <sphinxo> Awesome julianleviston :)
07:07:26 <NightRa> mauke: Hmm. read . show != id
07:07:27 <julianleviston> sphinxo: ooh it’s a bit inefficient, though. Should pull out that map quality bases so as not to repeat it.
07:07:46 <sphinxo> and then pass it as param?
07:07:52 <mauke> > show (fromString "foo" :: BS.ByteString)
07:07:54 <lambdabot>  "\"foo\""
07:08:01 <mauke> > (read . show) (fromString "foo" :: BS.ByteString) :: BS.ByteString
07:08:03 <lambdabot>  "foo"
07:08:20 <NightRa> Hmm
07:08:33 <julianleviston> sphinxo: actually that’s wrong. It’s fine.
07:08:55 <julianleviston> sphinxo: I’ve no idea if it does what you want tho
07:09:14 * hackagebot cabal-macosx 0.2.3.4 - Cabal support for creating Mac OSX application bundles.  https://hackage.haskell.org/package/cabal-macosx-0.2.3.4 (dfrancesconi)
07:09:16 <sphinxo> Yeah it's not quite
07:09:43 <sphinxo> It should be taking a Nucleobases as  a param
07:10:00 <julianleviston> sphinxo: if you have a chain of bases that is a b c d in your sequences and you pass keep “abcd” sequences, it’ll spit those sequences out that match in that order.
07:10:08 <julianleviston> Ohhhh
07:10:26 <sphinxo> yes
07:10:50 <NightRa> mauke: I found my issue. it was somewhere else. thanks
07:11:19 <julianleviston> sphinxo:  that’s an easy fix.
07:11:47 <julianleviston> sphinxo: updated (http://lpaste.net/148202)
07:13:30 <julianleviston> sphinxo: oh you could simplify that too one sec
07:14:31 <julianleviston> sphinxo: actually it’s ok the way it is
07:14:39 <sphinxo> awesome, that works great
07:14:47 <julianleviston> sweet.
07:15:48 <sphinxo> Yeah you can do toKeep `isInfixOf` map key bases
07:27:01 <andriusbartulis> Why would the following code: "putStrLn $ show 5" be considered cleaner or better then "putStrLn (show 5)"
07:27:19 <mauke> it isn't
07:27:25 <mauke> also, print 5
07:28:16 <andriusbartulis> I am just seeing a lot of use for $ in code like I wrote above. And I don't understand why people prefer that.
07:28:56 <potatoe> does anyone know how the Value type for aeson behaves?
07:29:20 <mauke> parens are hard to read if there are many of them or of the pairs are far away from each other
07:29:20 <potatoe> because I'm trying to go from a JSON object to ClaimsMap which is a Map Text Value object
07:29:21 <potatoe> http://hackage.haskell.org/package/jwt-0.6.0/docs/Web-JWT.html#t:ClaimsMap
07:30:08 <andriusbartulis> mauke: so would you say its a good convention to use the function application operator $ instead of parens in most cases?
07:30:14 <mauke> no
07:30:22 <mauke> I tend to avoid $ where I can
07:31:00 <exio4> I prefer $ for things like lambdas or so
07:31:04 <hpc> if a line of code becomes hard to read, the first thing to try is almost always splitting parts out and giving them names
07:31:12 <mauke> but sometimes instead of f (g (h x)) or f $ g $ h $ x, I write (f . g . h) x
07:31:13 <exio4> forM_ something $ \v -> ... 
07:34:13 <mac10688> for stack, I want to load my test-suite in ghci. What is the trick to do this? my test suite is called spec from the franklinchen template. (i.e. test-suite spec).
07:34:22 <mac10688> I have tried stack ghci spec
07:34:28 <mac10688> stack ghci --main-is spec
07:34:31 <mac10688> but nothing is working
07:35:42 <EvanR> $ is good for removing a lisp-like trailing parens many lines down
07:35:54 <EvanR> and thats about it
07:39:00 <andriusbartulis> EvanR: That's what I thought...
07:39:47 <EvanR> for some reason you cant write this code
07:39:56 <EvanR> don't do
07:39:59 <EvanR>   ...
07:40:06 <EvanR> so instead of parents
07:40:11 <EvanR> don't $ do
07:40:13 <EvanR>   ...
07:51:25 <potatoe> im really stumped here
07:51:43 <potatoe> Data.JWT needs a Map Text Value but I have no idea how to get Value from a JSON object
07:52:31 <sphinxo> How can I print the contents of an Either without caring whether left/right
07:54:33 <KaneTW> :t either
07:54:34 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
07:54:45 <KaneTW> > either show show (Left 1)
07:54:47 <lambdabot>  "1"
07:54:57 <KaneTW> > either show show (Right 'b')
07:54:59 <lambdabot>  "'b'"
07:55:14 <KaneTW> :t either show show
07:55:15 <lambdabot> (Show a, Show a1) => Either a a1 -> String
07:55:16 <KaneTW> ^
07:55:21 <sphinxo> sweet
07:57:13 <cocreature> is there something like Tagged with the arguments flipped?
07:58:20 <supki> cocreature: Const
07:58:40 <ggole> Hmm, is there type-level flip?
07:58:42 <ggole> :k Flip
07:58:44 <lambdabot> Not in scope: type constructor or class ‘Flip’
07:58:44 <cocreature> supki: ah ofc, thanks
08:00:08 <cocreature> gnah, it’s not polykinded in 7.10
08:00:15 <cocreature> but looks like vinyl has a polykinded one
08:01:56 <cocreature> seems to be polykinded starting from 8.0
08:08:55 <ralu> does type :: IO a -> a makes sense in safe context
08:09:45 <KaneTW> depends on what the IO action does
08:09:59 <KaneTW> in general that's unsafeperformio
08:10:17 <ralu> that is what i am asking
08:10:18 <roelof> Any feedback on this solutions. I try to solve it by using list comprehension and recursion because that I have learned so far : http://lpaste.net/148206
08:10:59 <monochrom> it does not make sense in safe context, unless some human vet a particular usage and judge it safe
08:12:18 <ralu> i am asking this, because i find lot of this from book -> Haskell Design Patterns
08:12:39 <ralu> it is in book
08:15:24 <roelof> ralu:  is this a nice book for a beginner which has finished some books ? 
08:15:38 <ralu> it is uber crap
08:15:43 <ralu> i found sample
08:15:48 <monochrom> I disbelieve it. a book on design patterns is unlikely to bring up "IO a -> a" at all.
08:16:02 <ralu> http://cdn.oreillystatic.com/oreilly/booksamplers/packt/9781783988723_Sample.pdf
08:16:15 <monochrom> to be sure, I am too lazy to pay $5 to check.
08:16:43 <ralu> page 14
08:18:40 <monochrom> that one looks like pseudocode, and moreover pseudocode for OOP, not even pseudocode for Haskell
08:18:56 <ralu> check chapter about monads
08:19:15 <ralu> it sais what is sais
08:19:16 * hackagebot haskell-gi-base 0.11 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.11 (inaki)
08:19:18 * hackagebot haskell-gi 0.11 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.11 (inaki)
08:19:20 * hackagebot gi-atk 0.2.16.11 - Atk bindings  https://hackage.haskell.org/package/gi-atk-0.2.16.11 (inaki)
08:19:22 * hackagebot gi-cairo 0.1.14.11 - cairo bindings  https://hackage.haskell.org/package/gi-cairo-0.1.14.11 (inaki)
08:19:28 <ralu> it is at the end of book
08:20:29 <ralu> it introduce Monad withou even mentioning Functor
08:21:12 <maerwald> wat
08:21:19 <monochrom> ok, I see
08:21:28 <maerwald> find another book then :P
08:22:05 <monochrom> to be sure "class TemplateAlgorithm where" is not even legal Haskell. lacks a type variable.
08:22:22 <lieven> it might be a tad unfair to judge a book by its publisher but every packt text I've looked at was utter crap
08:22:23 <hc> isn't there a language extension to support that? ;)
08:22:53 <ralu> this book is listed #1 at https://wiki.haskell.org/Books
08:23:14 <monochrom> but you know the drill about most wikis
08:23:39 <hc> probably added by the author himself?
08:23:56 <lieven> and the wiki seems to list books by reverse publication date within each subsection
08:24:06 <maerwald> the monad chapter doesn't even provide the bind type signature O.o
08:24:26 <roelof> Any feedback on this solutions. I try to solve it by using list comprehension and recursion because that I have learned so far : http://lpaste.net/148206
08:24:29 * hackagebot gi-gdk 0.3.16.11 - Gdk bindings  https://hackage.haskell.org/package/gi-gdk-0.3.16.11 (inaki)
08:24:31 * hackagebot gi-gdkpixbuf 0.2.31.11 - GdkPixbuf bindings  https://hackage.haskell.org/package/gi-gdkpixbuf-0.2.31.11 (inaki)
08:24:41 <ralu> this clames to be advance haskell book
08:25:03 <monochrom> sure. where it is correct, it is advanced.
08:26:52 <ralu> sum = foldr (+) 0
08:30:05 <monochrom> what is the relation between Packt and O'Reilly, such that a sample of a Packt book is hosted at an O'Reilly URL?
08:32:16 <ralu> I thek that orilley sells book in shop http://shop.oreilly.com/product/9781783988723.do
08:32:56 <monochrom> interesting
08:33:35 <cheater> happy 0x10 everyone
08:34:20 <monochrom> yeah, except that 2016 `mod` 0x100 is not going to be 0x16. 
08:35:01 <monochrom> err, 0x10
08:35:01 <ralu> you should take 0x2016
08:35:11 * hackagebot gi-gio 0.2.44.11 - Gio bindings  https://hackage.haskell.org/package/gi-gio-0.2.44.11 (inaki)
08:35:13 * hackagebot gi-glib 0.2.44.11 - GLib bindings  https://hackage.haskell.org/package/gi-glib-0.2.44.11 (inaki)
08:35:15 * hackagebot gi-gobject 0.2.44.11 - GObject bindings  https://hackage.haskell.org/package/gi-gobject-0.2.44.11 (inaki)
08:35:17 * hackagebot gi-gtk 0.3.16.11 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-0.3.16.11 (inaki)
08:35:19 * hackagebot gi-javascriptcore 0.2.8.11 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-0.2.8.11 (inaki)
08:35:25 <monochrom> yeah, except that the year after 0x2019 is not going to be 0x201a
08:35:46 <monochrom> err, that sentence is messed up. nevermind.
08:38:40 <wedify> is there a way to have an io action defined at toplevel be evaluated once when needed and remain the result forever after?
08:39:21 <monochrom> yes, but it uses unsafePerformIO
08:40:21 * hackagebot gi-notify 0.2.31.11 - Notify bindings  https://hackage.haskell.org/package/gi-notify-0.2.31.11 (inaki)
08:40:23 * hackagebot gi-pango 0.1.36.11 - Pango bindings  https://hackage.haskell.org/package/gi-pango-0.1.36.11 (inaki)
08:40:25 * hackagebot gi-vte 0.0.40.11 - Vte bindings  https://hackage.haskell.org/package/gi-vte-0.0.40.11 (inaki)
08:40:27 * hackagebot gi-webkit 0.2.4.11 - WebKit bindings  https://hackage.haskell.org/package/gi-webkit-0.2.4.11 (inaki)
08:40:29 * hackagebot gi-webkit2 0.2.8.11 - WebKit2 bindings  https://hackage.haskell.org/package/gi-webkit2-0.2.8.11 (inaki)
08:41:08 <wedify> oh ok. i think i might prefer that to having to pass it around
08:42:22 <wedify> i suppose template haskell would have some way but that seems pretty heavyweight
08:42:45 <monochrom> template haskell do things at compile time, not program start time
08:43:00 <cheater> wedify: you could also memoize in the IO monad, you still have an IO type but you don't have to re-do the computation every time.
08:43:16 <cheater> depending on what you want compile time might be the right way to go.
08:43:40 <cheater> like, say, importing some data or whatnot.
08:44:35 <anohigisavay> hi
08:44:46 <anohigisavay> how can i select N random elements from a list?
08:44:56 <anohigisavay> N unique elements
08:45:24 <monochrom> is the list long enough to have at least N elements?
08:45:31 * hackagebot gi-soup 0.2.50.11 - Soup bindings  https://hackage.haskell.org/package/gi-soup-0.2.50.11 (inaki)
08:45:34 <anohigisavay> monochrom: 
08:45:36 <anohigisavay> yes
08:45:44 <wedify> cheater: would the binding be scoped over the module?
08:45:45 <magr> that's not random, if you what uniq elements
08:45:51 <magr> *want
08:46:01 <cheater> i don't know much about TH.
08:46:15 <anohigisavay> magr: sorry. why not?
08:47:07 <wedify> cheater: i have a constant i want available to multiple toplevels. 
08:47:16 <magr> random means, that you may get the same elements always
08:47:26 <monochrom> generate N distinct random numbers in the range [0 .. length list - 1]
08:47:33 <wedify> it seems upio is the way to go
08:49:12 <anohigisavay> magr: k basically i want something like random.sample in Python (can accept a second argument 
08:49:14 <anohigisavay> sample(self, population, k) method of random.Random instance
08:49:15 <anohigisavay>     Chooses k unique random elements from a population sequence.
08:49:24 <anohigisavay> help doc of Python random.sample function
08:49:35 <anohigisavay> i just want something like this
08:51:13 <monochrom> I have a cunning plan. shuffle the list. then take N.
08:51:54 <anohigisavay> monochrom: kool 
08:52:07 <anohigisavay> :D
08:52:19 <monochrom> to shuffle the list: use https://hackage.haskell.org/package/random-shuffle . (there are others.)
08:52:39 <magr> nice approach 
08:53:13 <anohigisavay> monochrom: thanks i love you :D
08:53:14 <monochrom> https://hackage.haskell.org/packages/search?terms=random has a lot of random stuff you can shop around in
08:53:24 <anohigisavay> magr: thank you too :D
08:54:00 <magr> anohigisavay, hahah that made me LoL,  cool
08:54:30 <wedify> i was going to suggest a set, initialize it to the first n elements and then as you iterate over the sequence have some probability of "flipping" an old value for a new one
08:54:41 <wedify> but what monochrom said seems easier
08:57:07 <anohigisavay> wedify: hmm. sounds a bit hard to tell if all elements are of equal probability
09:24:22 <cheater> wedify: i don't know what toplevels are.
09:25:15 <cheater> anohigisavay: if you want random unique elements, you should probably start with a set, not a list.
09:26:36 <xplat> urrrrrgh, why doesn't tagsoup match up tags?
09:27:21 <xplat> i thought the whole point of the html5 parsing algorithm was it's supposed to tell you how to take in a bunch of random bullshit and spit out a DOM in a specified way
09:29:48 <wedify> cheater: they are bindings excluding those defined in lets or where's
09:29:52 <xplat> so if it's not giving you matching tags tagsoup is only doing half the job it claims
09:31:08 <wedify> anohigsavay: i think you're right. the more often an individual occurs in the population the more likely it is to be in the sample
09:31:43 <wedify> but i think the same will happen if you just shuffle the list. you'll want a library that does statistical stuff if you're concerned about that 
09:33:16 <wedify> you could use fromList to get a set and then pick n elements from that
09:33:52 <wedify> that will have each element be equal probability because all the elements in the set will be unique
09:34:16 <vxri> anyone working through bitemyapp 's monoid chapter? running into some issues with exercises and i'm not sure if it's a book bug or user error...
09:35:13 * hackagebot engine-io-wai 1.0.5 -   https://hackage.haskell.org/package/engine-io-wai-1.0.5 (codedmart)
09:56:35 <pavolzetor> are there some settings to make GHC allocate less heap and keep it more concant? sort of compile flags, I do not want to have bang patterns everywere
09:56:51 <pavolzetor> after profiling GC is taking 50% of time
09:57:40 <pavolzetor> which is strange since it is simple program, generate sample -> generate ray -> intersect -> shade -> write image
09:58:26 <pavolzetor> I woul expect sort of a constant heap usage, but what I am getting is massive alloc at the start and then it goes linearly down
10:00:45 <pavolzetor> is there some simple way declare the whole program as strict? I.e. switch to strict evaluation for all the code; so I can see what that does
10:05:24 <maerwald> https://ghc.haskell.org/trac/ghc/wiki/StrictPragma
10:07:22 <pavolzetor> thanks, but that is per module
10:07:26 <maerwald> yes
10:07:32 <maerwald> there's no other such thing afaik
10:07:35 <pavolzetor> so I have to add it as compile flag and it will do for all
10:07:41 <maerwald> you have to use a different language then
10:08:01 <Ankhers> pavolzetor: You can add that pragma to your cabal file.
10:08:02 <pavolzetor> I will see, I want to use haskell
10:08:12 <Ankhers> and it will apply to everything.
10:08:22 <pavolzetor> great, I am going to build new ghc then
10:08:22 <maerwald> to his own modules
10:08:42 <Ankhers> right.
10:09:04 <pavolzetor> I was reading and trying to understand the logic behind GHC, but I fail to comprehend why it would do such non-sensical thing
10:09:19 <maerwald> ?
10:09:29 <pavolzetor> the progam is simple one to one map
10:09:43 <pavolzetor> why allocate so much at the start?
10:10:01 <pavolzetor> you would expect on single thread it will have exactly same allocation time all the time
10:10:14 <pavolzetor> that sort of makes logical sense
10:12:31 <pavolzetor> http://sci.utah.edu/~klacansky/img/currypath.pdf
10:12:34 <pavolzetor> this is the profile
10:12:54 <pavolzetor> not something I expected
10:13:34 <Ankhers> pavolzetor: It may be helpful to see your code.
10:14:00 <pavolzetor> https://github.com/pavolzetor/currypath/blob/master/src/Main.hs
10:14:01 <pavolzetor> :)
10:15:14 * hackagebot gi-javascriptcore 0.2.4.11 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-0.2.4.11 (inaki)
10:15:56 <pavolzetor> I tried to deepseq each pixel, but that does not help
10:16:07 <pavolzetor> i.e. the inner "trace r" function
10:21:24 <bennofs> pavolzetor: actually, your problem description sounds to me more like you've got too much strictness, rather than too much laziness
10:22:53 <pavolzetor> bennofs: how come, if it were all strict it would use less than 1 MB of memory
10:23:09 <pavolzetor> the scene is small and image can be written byte by byte
10:24:07 <pavolzetor> I was also looking at this pdf
10:24:07 <pavolzetor> https://vlebb.leeds.ac.uk/bbcswebdav/orgs/SCH_Computing/FYProj/reports/0910/Tsenov.pdf
10:24:16 <pavolzetor> and he seems to have almost everything strict
10:26:56 <pavolzetor> I will wait until the GHC 8 builds and test the strict flag
10:27:29 <pavolzetor> Ankhers: did you spot anything obvious?
10:28:31 <bennofs> pavolzetor: can you re-run memory profling with -hy ?
10:28:37 <pavolzetor> sure
10:28:54 <Ankhers> pavolzetor: No, but I am still fairly new to Haskell.
10:29:05 <pavolzetor> mew too
10:29:41 <pavolzetor> and not going to give up easily this time
10:30:27 <pavolzetor> bennofs: http://sci.utah.edu/~klacansky/img/currypath_hy.pdf
10:30:47 <Guest30940> pavolzetor: I'm looking at trace. Will V.fromList create a Vector with a bunch of thunks for each ray to be traced?
10:31:52 <Guest30940> pavolzetor: I would have thought that creating a vector from a list wouldn't operate in the "streaming" style you intend
10:32:11 <pavolzetor> Guest30940: I think so, because before that I had ST monad and writing it directly and memory usage was like 8 MB
10:32:50 <pavolzetor> Guest30940: streaming until written to framebuffer
10:33:05 <pavolzetor> now it is simple, but in future there will be many samples per pixel
10:33:17 <pavolzetor> and probably multiple framebuffers for each thread
10:33:29 <pavolzetor> so it sort of can stream up until it writes the pixel (I think)
10:33:56 <Guest30940> pavolzetor: monads force sequential-ness though, so the thunks wouldn't be created until needed?
10:34:03 <bennofs> pavolzetor: oh, that shadowing of 'trace' is really confusing btw
10:35:21 <pavolzetor> yes, but I wanted to not have that ST monad
10:35:52 <pavolzetor> bennofs: I am planning refactoring, after I have done adaptive splitting and batch tracing
10:36:06 <Guest30940> pavolzetor: I'm still not great at reasoning about these things though...just trying to help for my own education admist doing a few other things
10:36:44 <pavolzetor> no worries, me neither; I figured it out by trying different permutations
10:36:48 <bennofs> pavolzetor: ok, so looking at the -hy profile, the black area is probably the ByteString that holds the contents of the json file
10:37:39 <pavolzetor> I appreciate the help, anyhow I tried to use deepseq (not sure if properly) on trace function but it did not help
10:37:46 <Ankhers> http://lpaste.net/148216 -- I'm getting that error on https://github.com/ankhers/transit/blob/master/src/Api.hs#L91. Would anyone be able to help me fix it?
10:37:54 <bennofs> pavolzetor: now, the peak seems to be at the same place for the bytestring as for the rest. so I'm guessing that you're accidently forcing the whole structure to be parsed and hold in memory, by accessing too much of it too early (thus defeating streaming)
10:38:41 <pavolzetor> bennofs: wouldn't that be grabage collected (as not used after parsing)?
10:39:43 <pavolzetor> bennofs: the json file is < 2kB
10:40:01 <Guest30940> pavolzetor: yeah deepseq wouldn't help i dont think. I think bennofs is right in that you need more laziness, rather than less
10:40:14 <bennofs> pavolzetor: I'll have to go now, I'll be back later
10:40:21 <bennofs> hope you can figure it out :)
10:40:33 <pavolzetor> thanks, I will work on it today
10:40:49 <pavolzetor> it is different model than I used before, so getting used to it will take time
10:41:32 <pavolzetor> Guest30940: maybe in future if the scene is very large, but now it is below 2kB (one sphere)
10:41:42 <pavolzetor> so you sort of want it read in L1 cache
10:42:22 <Guest30940> pavolzetor: wouldn't like to say for certain. Have you tried just generating the list of traces, without making it into a vector etc and seeing how that performs?
10:42:28 <JonReed> Does anybody what the symbol `~` means here: `performEvent :: (MonadWidget t m, Ref m ~ Ref IO) => Event t (WidgetHost m a) -> m (Event t a).`
10:42:36 <pavolzetor> my hypothesis is that for some very weird reason, in trace function, it builds all the thunks for each pixels and then when writing to disk it starts evaluating
10:42:51 <Guest30940> pavolzetor: Yeah, that's what I think too
10:43:38 <pavolzetor> give me sec, I can try that easily
10:46:31 <pavolzetor> yeah, same as when I used ST monad
10:46:50 <pavolzetor> so that part V.fromList or writing the image is the problem
10:46:59 <Guest30940> pavolzetor: as in, computing the list performs as expected?
10:47:08 <roelof> Can someone help me here (http://lpaste.net/148218) . Haskell is no fun anymore this way. I fight the whole day with the types 
10:47:39 <pavolzetor> roelof: name, price is not type
10:48:05 <pavolzetor> look :: Database -> BarCode -> [(Name, Price)] 
10:48:13 <JonReed> roelof: You have "name" as type 
10:48:18 <roelof> no, I try to desctruct that array in a variable barcode,name, price  
10:48:18 <Guest30940> pavolzetor: I think V.fromList needs to know the length of the list to create the vector
10:48:32 <pavolzetor> Guest30940: yes, it streams
10:48:38 <dmj`> roelof: look :: Database -> BarCode -> [(name, price)] 
10:48:47 <dmj`> should be [(Name, Price)]
10:49:08 <roelof> dmj`:  oke, Now I understand it 
10:49:14 <Guest30940> pavolzetor: since length is an O(1) operation on Vectors. That forces fromList to traverse the list seq-ing, and hence generating thunks
10:49:33 <Guest30940> pavolzetor: "i think"
10:49:57 <roelof> I get confused because ghci mentioned the next line as the line with a error 
10:50:01 <pavolzetor> Guest30940: interesting, would that not just create the thunk for the top-level 
10:50:08 <average> ladies  & gentlemen
10:50:16 <average> Happy New Year to everyone in the channel
10:50:18 <greg`> should foldr1 on an empty list throw an exception, im a bit surprised byt this
10:50:18 <pavolzetor> Guest30940: it could be doing something like push_back
10:50:23 <dmj`> roelof: type defs always have to start with an uppercase letter
10:50:23 <average> I wrote a blogpost about projects where Perl is being used http://blog.garage-coding.com/2015/12/20/overview-perl-opensource-projects.html
10:50:30 <average> If anyone here feels like writing an equivalent for Haskell, that would be cool, I'd read it
10:50:32 <Guest30940> roelof: It interprets name, price as type variables, and then it appears your function is using type variables, rather than type instances
10:50:34 <quchen> greg`: It can't do anything else
10:50:39 <average> I currently don't have a good understanding of where Haskell is being used
10:50:57 <quchen> greg`: The real question is "should there be foldr1 on lists at all", and I'd say "no"
10:51:11 <durant> The haskell docs are hard to read
10:51:17 <dmj`> average: it's being used where programming is needed
10:51:26 <pavolzetor> Guest30940: I looked at the source of vector but it is very cryptic
10:51:29 <average> dmj`: have you skimmed through my blogpost ?
10:51:34 <greg`> quchen : i see what you mean.....it has tor return a type b
10:51:38 <average> dmj`: your answer is not very close to what I'm looking for
10:51:45 <pavolzetor> I think I will go back to ST monad, as eventually I will need to write the samples randomly
10:51:48 <greg`> but with an empty list theres no way to create it
10:51:48 <average> dmj`: have you read my question above ?
10:51:57 <average> dmj`: please re-read my question and what I'm looking for
10:52:04 <greg`> i guess the question is shouldnt it just return the zero value?
10:52:14 <roelof> next problem : http://lpaste.net/148219
10:52:15 <pavolzetor> Guest30940: could I somehow force the evaluation of inner trace?
10:53:06 <pavolzetor> reolef BarCode is Int
10:53:17 <JonReed> average: There are things like: https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
10:53:23 <roelof> pavolzetor:  yep and 4719 is also a int 
10:53:29 <pavolzetor> look 4719
10:53:42 <Guest30940> pavolzetor: maybe have trace return the list (or use an intermeidary function), then try and create the list lazily, then create the vector once it's built
10:53:52 <Guest30940> pavolzetor: just trying to think how to do that
10:54:34 <durant> calculus is easier than haskell
10:54:38 <roelof> pavolzetor:  I tried and see the first error message : http://lpaste.net/148219
10:54:40 <quchen> greg`: There is no "zero value" in foldr1
10:55:24 <pavolzetor> reolef: you need to pass database in
10:55:44 <average> JonReed: thanks, that's close to what I'm looking for
10:56:29 <pavolzetor> Guest30940: I will try, also, think about how to do random writing; for some pixels you can generate much more rays if the variance is high
10:57:01 <pavolzetor> so you sort of dynamically need to adjust based on the output from trace for next rays
10:57:37 <JonReed> average: There is also https://wiki.haskell.org/Haskell_in_industry . But if you want to know about where it's used to deduce what haskell is most useful for, then that github post is probably more clear 
10:58:05 <pavolzetor> reolef: try "look [] 911"
10:58:21 <roelof> Stupid mistake: this is working : look db code = [ (name,price) | (barcode, name , price) <- db, code == barcode ] 
10:59:08 <Zekka> Reminds me: company I work at uses Haskell internally but even though it's not really a secret, management would probably be sad if it appeared on a webpage
10:59:28 <roelof> one question; when the item is not in the database . a empty [] is returned. Can I change it so this is returned ; -("Unknown Item", 0)
10:59:36 <Zekka> Maybe I'll add it once I've switched jobs
10:59:55 <roelof> or do I have to wrap everything in a case of if then clause for this ? 
11:00:15 <Guest30940> pavolzetor: I'm not really sure precisely what the code is doing, I just have a rough idea, and otherwise I'm just trying to reason from the structure
11:00:17 <pavolzetor> just write wrapper function
11:00:28 <pavolzetor> look' =
11:00:42 <pavolzetor> look' db barcode 
11:01:00 <pavolzetor> where item = look db barcode
11:01:08 <Guest30940> pavolzetor: so i'm not really sure what you mean by random writing. Would it make sense to use a fold or something with the accumulator keeping state?
11:01:10 <pavolzetor> | item == [] = your string
11:01:21 <pavolzetor> | otherwise = item
11:01:52 <quchen> pavolzetor: Use lpaste for multiline code examples, it's much easier to read
11:02:10 <quchen> And don't use (== []), use null. Does the same thing, but without an Eq constraint.
11:02:12 <quchen> :t null
11:02:14 <lambdabot> Foldable t => t a -> Bool
11:02:16 <quchen> :t (== [])
11:02:18 <lambdabot> Eq t => [t] -> Bool
11:02:53 <pavolzetor> Guest30940: so the code is doing sequential ray tracing, i.e. evaluating some function for each pixel. In future what you want to do is based on your current estimate of the function integral value sample more in some regions
11:02:56 <magr> Zekka, out of curiosity why they don't want that information to be publicly available?
11:03:28 <Zekka> magr: It's not that they specifically don't want that info to be out, but they want to control most publicly-posted information about our infrastructure
11:03:36 <Guest30940> pavolzetor: so i think what you want, is the list to be computed lazily, but passed to V.fromList fully evaluated
11:03:42 <Zekka> This isn't one of the things they specifically said we can post publicly
11:04:01 <geekosaur> that's fairly common at large companies; don't talk about your infrastructure
11:04:15 <Zekka> (they don't really care what you discuss if it's not going to be permanently visible somewhere)
11:04:37 <pavolzetor> Guest30940: possibly, but how would you do accumulation?
11:05:32 <Guest30940> pavolzetor: gotcha. sounds like it could be done with a fold. accumulate a pair, one part the list (so far, backwards for efficiency), and the second the number of samples?
11:06:36 <magr> Zekka, Makes sense, if we are talking about a military entity or something of the like
11:06:54 <Zekka> magr: Small finance company, but yeah.
11:06:59 <Guest30940> pavolzetor: or something like that. you could use State also, but I think that's "the same" as folding (meaning, something-morphic)
11:07:31 <geekosaur> magr, it's far from just military
11:07:37 <Zekka> There aren't any regulations that affect this specifically, but there are so many things we're not allowed to say that management thinks it's very ordinary to come up with things you're not allowed to say
11:07:44 <Guest30940> pavolzetor: trying to figure out this strictness laziness problem though
11:07:47 <pavolzetor> quchen: thanks for tips
11:07:53 <Zekka> This is otherwise a pretty startuppy, image-concerned company
11:08:07 <pavolzetor> Guest30940: give me sec, I am going to  reread one chapter in PBRT
11:09:20 <pavolzetor> if I understand correctly, adding let !a = expensive in a, will force evaluation of expensive?
11:09:54 <magr> geekosaur, can you elaborate more on that.
11:11:04 <Guest30940> pavolzetor: perhaps a let clause...beat me to it...yeah, is ! a full evaluation, or just to weak head normal form though?
11:11:12 <pavolzetor> Guest30940: I tried the fold idea, not as 0.2% with ST monad but it keeps it very low
11:11:38 <pavolzetor> I will post the heap profile
11:11:42 <Guest30940> ok
11:11:42 <pavolzetor> I replaced V.fromList to
11:11:56 <pavolzetor> foldl' V.snoc V.empty
11:12:21 <Welkin> SNOC
11:12:24 <geekosaur> I'm not sure what there is to elaborate on. above a certain size --- and often below it if the company principals came from companies above that size --- the convention is that public mention of any internal details of the company must be cleared by legal, and legal will say no unless you can prove there is a benefit to the mention. this also applies to contractors
11:12:24 <Guest30940> that was faster?
11:13:37 <pavolzetor> Guest30940: well, it is running still (I am building GHC too)
11:13:45 <Guest30940> foldl' ing V.snoc is pretty expensive on big lists though (O(n^2))? I would have though fromList would be faster ultimately, its just figuring out how to make it evaluate
11:13:53 <pavolzetor> docs say snoc in O(n)
11:13:56 <geekosaur> it's not my place to say whether that is justifiable; I don't get to set the rules for them
11:14:15 <Guest30940> yeah, but you do it once for every list element
11:14:32 <pavolzetor> well, vector append should be O(2)
11:14:36 <pavolzetor> not O
11:14:36 <Guest30940> so its "O(sum 1 to n)"
11:14:39 <pavolzetor> just 2
11:14:51 <pavolzetor> at least from my C days
11:14:57 <pavolzetor> it is amortized
11:14:58 <Zekka> We're a fairly small company that has the same imposition, partially because in our industry it's a convention to keep everything totally secret
11:15:00 <pavolzetor> constant time
11:15:08 <Guest30940> I see what you mean
11:15:17 <pavolzetor> but it really seems to be O(n)
11:15:40 <Guest30940> actually nno
11:15:41 <Zekka> We're a little bit more free about that than most companies in our niche but we still tend to default towards keeping things secret
11:15:52 <Guest30940> because of purity, Haskell needs to duplicate the old copy
11:15:54 <pavolzetor> can somebody elaborate why it is O(n)
11:16:11 <pavolzetor> oh, makes sense
11:16:17 <pavolzetor> I forgot
11:16:53 <Guest30940> unlike with lists or w.e. where you can just "add a pointer to the new bit"
11:17:22 <Welkin> Zekka: so, uh, you work in defense contracting? Or are you talking about a bullshit "stealth mode" startup?
11:17:33 <Guest30940> in some sense fromList should be more efficient, because you allocate one vector
11:17:42 <pavolzetor> you are right, I used to have list as representation of the image, but that was using so much memory
11:17:46 <Zekka> Welkin: I thought I mentioned, we're a finance company
11:17:54 <magr> Zekka, I'm just looking the logic behind keeping into secret the use of a particular language 
11:17:57 <Welkin> Zekka: I see
11:18:08 <Zekka> We're not really new, the branch of the company I work in has been around for at least five years
11:18:08 <Guest30940> "in some sense" is completely redundant in what i said :D
11:18:30 <Zekka> magr: Well, there are some technologies we would be ashamed of if we used
11:18:32 <Welkin> Guest30940: get a real nick!
11:18:33 <pavolzetor> Guest30940: have you figured out how to make the streaming?
11:18:42 <Zekka> if all our infrastructure was in COBOL people might suspect our product is bad
11:19:03 <Zekka> I don't think we would be ashamed if it became common knowledge that we used Haskell, but it could be that stodgy COBOL advocates might not like it
11:19:12 <pavolzetor> btw, the memory profile so far seems to be exactly oposite
11:19:16 <Guest30940> Welkin: yeah yeah, i will get a nick sometime :P
11:19:21 <pavolzetor> the memory is pilling up
11:19:44 <Guest30940> pavolzetor: no net yet
11:20:41 <pavolzetor> I am going to continue with that chapter to see what operations will be necessary
11:21:21 <magr> Zekka, ahh, it's not only about secrecy, I see
11:21:42 <zigschots20> Welkin: there
11:21:44 <magr> makes sense
11:21:51 <pavolzetor> and when I finish the book I want to test the parallel execution; I need to incorporate it early on because it is vital
11:22:01 <Zekka> We don't really expect that situation to happen, but if I were to question the policy that's probably the response legal would give me
11:22:54 <zigschots20> pavolzetor: sure. This article is pretty good: https://donsbot.wordpress.com/2008/05/06/write-haskell-as-fast-as-c-exploiting-strictness-laziness-and-recursion/
11:23:01 <Zekka> (broad version: it's hard to know in advance what information is likely to be dangerous to release, and releasing info withotu permission usually has negligible advantages)
11:23:12 <zigschots20> pavolzetor: not immediately useful for what we need though
11:23:43 <pavolzetor> zigschots20: thanks, btw this is the output http://sci.utah.edu/~klacansky/img/teapot.exr
11:24:09 <pavolzetor> and this inspiration https://www.youtube.com/watch?v=rydLFAdhseo
11:29:08 <zigschots20> pavolzetor: Cool! Have you tried "let !x = map deepseq your_list in rest_of_trace"?
11:30:25 <zigschots20> pavolzetor: not sure if that works as required, or if there is some redundancy in there.....
11:31:31 <zigschots20> pavolzetor: I would have thought fromList would take the length first, so as it does this, it touches (in a streaming way) each element, and then forces the full evaluation
11:32:56 <pavolzetor> zigschots20: but that should just leave a massive list of thunks
11:33:12 <pavolzetor> hmm, I suspect each thunk must store quite a bit of information
11:33:26 <pavolzetor> i.e. probably scene + all the data
11:33:47 <pavolzetor> sort of like closure
11:35:07 <pavolzetor> I am not sure I understand that deepseq piece of code
11:35:32 <pavolzetor> suppose I have a list x, and do x deepseq x
11:35:36 <zigschots20> pavolzetor: the individual thunks aren't generated though until they're touched though?
11:35:37 <pavolzetor> would that evaluate whole list?
11:35:58 <zigschots20> :t deepseq
11:36:00 <lambdabot> Not in scope: ‘deepseq’
11:36:37 <zigschots20> yeah, i think i messed up the type of deepseq
11:36:52 <pavolzetor> then I do not get it, why would it allocate so much memory
11:36:57 <zigschots20> i might have meant to map (\x -> x `deepseq` x)
11:37:07 <pavolzetor> I even tried to deepseq the each pixel
11:37:09 <zigschots20> i think it would, but im not sure how it does it
11:37:09 <pavolzetor> but did not help
11:37:17 <zigschots20> hmm ok
11:38:59 <pavolzetor> the deepseq did not hep
11:39:01 <pavolzetor> help
11:39:24 <pavolzetor> I did V.fromList . map (\x -> x `deepseq` x) . map trace $ (rays s ren)
11:40:04 <pavolzetor> but hold on
11:40:14 <pavolzetor> I would assume that if you have lets say
11:40:23 <zigschots20> hmm ok
11:40:28 <pavolzetor> [x | x <- [0..largenumber]]
11:40:32 <pavolzetor> and you do length
11:40:38 <pavolzetor> then it does not evaluate x
11:40:46 <zigschots20> sure
11:40:53 <puregreen> pavolzetor: “x `deepseq` x” means that x would be fully evaluated whenever x is, well, “even slightly evaluated”
11:40:53 <pavolzetor> but, it must store the passed parameters to x somewhere right?
11:41:12 <zigschots20> you can see it if using :sprint in ghci
11:42:21 <pavolzetor> puregreen: so if x does not get evaluated than it does nothing?
11:42:24 <puregreen> yep
11:42:45 <puregreen> if you want the list to be evaluated, you have to deepseq the list, not its elements
11:43:22 <puregreen> (by the way, “x `deepseq` x” is the same as “force x”)
11:43:32 <zigschots20> puregreen: will fromList not force each element to be "a little bit evaluated" though?
11:43:50 <puregreen> unless the vector is unboxed, no it wouldn't
11:44:39 <puregreen> by “a little bit evaluated” I meant WHNF, you can read more about it here: http://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form
11:44:51 <zigschots20> yeah, that's what i meant
11:45:40 <pavolzetor> thanks, even if the Vector type is strict?
11:47:04 <Jinxit> I have a circular dependency, but when I try to resolve it with a hs-boot I need to include things which then re-create the circular dependency. What am I missing?
11:47:32 <puregreen> pavolzetor: Data.Vector is strict in spine and lazy in values (i.e. you can't have an infinite Vector or something, but you can have a finite Vector holding an “undefined” and it would be okay)
11:47:41 <pavolzetor> adding force helped, still not close to the ST monad because I guess it must keep the whole list in memory before passing to V.fromList right?
11:47:59 <pavolzetor> puregreen: but my pixel type inside vector is strict
11:48:11 <pavolzetor> why would that not force the evaluation?
11:48:41 <monochrom> is the vector type also strict?
11:48:45 <zigschots20> ok, so mapping deepseq over the list doens't help (verified in GHCI :))
11:48:55 <puregreen> pavolzetor: what do you mean by “pixel type is strict”?
11:49:14 <puregreen> data Pixel = Pixel !Int !Int !Int or something?
11:49:26 <pavolzetor> yes
11:49:40 <geekosaur> so you stricted the things inside the Pixel
11:49:49 <pavolzetor> monochrom: I do not understand
11:49:50 <geekosaur> the Pixel constructor *itself* is not strict though
11:50:09 <puregreen> for your Pixel, “Pixel a b c” would be undefined whenever a, b, or c is undefined
11:50:15 <pavolzetor> oh
11:50:22 <geekosaur> that would be determined by the thing "containing" the Pixel, which would be vector in your case, and vector is lazy in its values
11:50:26 <puregreen> but this doesn't mean that Pixel *can't* be undefined
11:50:54 <Welkin> puregreen: indiagreen?
11:50:58 <zigschots20> ok, i think im following
11:51:03 <puregreen> Welkin: shhhh
11:51:16 <puregreen> it's my disguise
11:51:32 * puregreen doesn't explicitly confirm or deny anything, tho
11:53:17 <Jinxit> (Welkin: don't tell anyone, but I saw him change his nick)
11:53:27 <monochrom> here is a simple experiment that challenges many people's mental model: "case Just (Pixel undefined undefined undefined) of Just _ -> ()" does not diverge.
11:53:29 <pavolzetor> So if I get this correctly, there will be a thunk Pixel a b c ?
11:53:38 <pavolzetor> http://sci.utah.edu/~klacansky/img/currypath2.pdf
11:53:58 <monochrom> similarly if you replace Just by a list, a vector, etc
11:54:01 <StoneToad> monochrom: um, isn't that fairly obvious?
11:54:17 <StoneToad> or does that just mean I've graduated from beginner haskell
11:54:30 <monochrom> tautologically, it's obvious to those who know, non-obvious to those who don't know
11:54:42 <pavolzetor> okay, I understand now
11:54:44 <geekosaur> StoneToad, the latter. this is more or less the mistake pavolzetor is making here
11:54:51 <geekosaur> and it's not uncommon for beginners
11:56:32 <pavolzetor> so now the program will build the whole image as list and then write
11:58:06 <pavolzetor> I think I will make everything strict by default and then carefully selecting parts which can be lazy
11:58:35 <pavolzetor> adding the deepseq made it run much faster
11:58:45 <zigschots20> so to check i was thinking correctly in the first place
11:59:06 <zigschots20> let a = Pixel 1 2 3, binds a to a thunk
11:59:17 <zigschots20> let !a = Pixel 1 2 3 will not
11:59:20 <zigschots20> for example
12:00:28 <monochrom> that is an unfalsifiable statement unless you read GHC-generated low level code
12:00:54 <pavolzetor> without force it takes almost 3x more time
12:01:17 <pavolzetor> not surprised given how memory is expensive nowadays
12:01:24 <monochrom> because there are at least two ways of implementing Haskell such that my example expression does not diverge
12:02:22 <monochrom> one is: in "Just (Pixel blah blah blah)", the whole "Pixel blah blah blah" is made a thunk initially
12:02:55 <monochrom> another is: only the 3 blahs are made thunks initially, but "Pixel blah blah blah" is not a thunk
12:03:45 <monochrom> both ways are legal ways to satisfy Haskell language requirements. no external observation distinguishes them.
12:04:51 <pavolzetor> monochrom: I tried that Pixel undefined and pattern matched Pixel _
12:04:55 <pavolzetor> and it gave undefined
12:05:02 <pavolzetor> so then Pixel is not thunk right?
12:05:04 <monochrom> if you read GHC-generated code under -O, you are going to find the 2nd way, not the 1st way
12:05:08 <xplat> yes, but a strict Pixel type will distinguish them as general strategies
12:05:18 * hackagebot distributed-process-monad-control 0.5.1.1 - Orphan instances for MonadBase and MonadBaseControl.  https://hackage.haskell.org/package/distributed-process-monad-control-0.5.1.1 (jeremyjh)
12:05:26 <xplat> (that is, Pixel with strict fields)
12:05:50 <monochrom> xplat, I am already talking about "data Pixel = Pixel !Int !int !Int"
12:06:11 <xplat> hm, wat
12:06:28 <monochrom> read Core and Cmm and asm code to see
12:06:39 <xplat> then how can -funbox-strict-fields be a valid optimization?
12:07:28 <pavolzetor> so if I understand this correctly I need to use ST monad and write each pixel separately to avoid building up the massive list at first place
12:07:31 <monochrom> I don't know. I don't need to know yet. I only need to state empirical observations for now.
12:07:36 <pavolzetor> (if I do not want O(n) complexity)
12:07:51 <Jinxit> I have a circular dependency, but when I try to resolve it with a hs-boot some functions require me to import things which then re-create the circular dependency. What am I missing?
12:08:08 <xplat> a .Types module
12:08:35 <pavolzetor> but is there some pure way to represent framebuffer without using ST monad?
12:08:39 <xplat> circular dependencies are never worth it
12:08:39 <Jinxit> as in a single file with all types, or Types.SomeType?
12:09:46 <xplat> whichever you need to not have a circular dependency
12:09:50 <Jinxit> because the data itself is circular as it is right now
12:11:13 <xplat> sometimes you can escape circularity of mutually recursive types by parameterizing one of them, but if that's too awkward you should just put them in the same module
12:11:32 <Jinxit> alright, thanks
12:12:47 <durant> I guess made a shell using haskell
12:13:00 <Welkin> durant: turtle?
12:13:16 <xplat> xmonad?
12:16:30 <zigschots20> actually, I thought about how I would define length, and its clear why it doesn't evaluate each element to WHNF - essentially becasue you only need to pattern match ont the constructors, and can ignore the values
12:19:30 <zigschots20> pavolzetor: I should think you can avoid the ST monad.
12:20:23 <pavolzetor> yes, now i understand it will never call deepseq
12:24:24 <zigschots20> pavolzetor: do you know in advance how big the vector will be?
12:24:46 <pavolzetor> zigschots20: I need to think
12:25:04 <pavolzetor> especially how multiple importance smapling works
12:25:25 <zigschots20> pavolzetor: also, had an idea to use the Identity monad, to force sequential computation, i.e. compute the list, then compute the vector
12:25:33 <pavolzetor> because if I am going to render constant number of samples per pixel I might just switch back to lists
12:26:25 <pavolzetor> thanks, I will read about it :)
12:26:35 <zigschots20> monochrom: case in core does evaluation right? (as opposed to let). Is the behaviour distinct from case in Haskell? I'm trying to understand your two examples, and have some idea but I'm not totally clear...
12:26:46 <pavolzetor> I just need to do some sort of planning
12:27:01 <zigschots20> pavolzetor: seems a bit of a hack though. There should be a nicer way.
12:27:13 <zigschots20> pavolzetor: if it works at all...
12:27:17 <pavolzetor> well, I need to figure out what exactly I need ;)
12:27:33 <zigschots20> haha yeah :) is computing the list sufficiently performant?
12:27:51 <pavolzetor> if it is written to the disk on fly yes
12:28:14 <monochrom> yes, zigschots20
12:28:16 <pavolzetor> of course that is that cache miss thing, but the most of computation is intersection and later in shading
12:28:20 <pavolzetor> so not a bottleneck
12:29:01 <pavolzetor> this was just a memory bottleneck on medium resolution, like 4k x 4k it would run out of memory ;)
12:29:31 <zigschots20> monochrom: actually thats fairly clear I suppose...your example even demonstrated it
12:29:37 <zigschots20> ok
12:29:41 <pavolzetor> what I want to do is parallelize it, I got the book now so that is primary objective
12:29:48 <monochrom> no, my example was Haskell not Core
12:30:26 <zigschots20> monochrom: I know - if it evaluated it (as in Core), it wouldn't work?
12:31:48 <monochrom> you know what, I don't understand the question.
12:32:19 <zigschots20> e.g. case (Just undefined) of Just _ -> 0
12:32:24 <zigschots20> doesn't cause an exception
12:32:38 <zigschots20> because it doesn't evaluate (Just undefined)
12:32:41 <monochrom> is that Haskell? is that Core?
12:32:45 <zigschots20> Haskell
12:32:51 <monochrom> then correct.
12:33:03 <monochrom> but also correct if that were Core.
12:33:20 <zigschots20> huh, ok
12:33:29 <zigschots20> i dont know enough about core
12:33:41 <zigschots20> but i thought case did some evaluation?
12:33:43 <monochrom> err, correct conclusion, different reason: Core evaluates Just whocares to Just
12:34:12 <zigschots20> ohhh ok
12:34:24 <zigschots20> so to WHNF?
12:34:26 <monochrom> this is a piece of code that distinguishes Haskell from Core: case blahblah of _ -> ().
12:35:04 <monochrom> Haskell says "do nothing". Core says "evaluate blahblah to WHNF"
12:35:43 <monochrom> but as soon as you use a non-trivial pattern, Haskell and Core begin to agree
12:36:18 <zigschots20> ok, cool, got it, thanks
12:36:56 <zigschots20> right, there must be a good way to solve pavolzetor's problem, but this was good along the way :)
12:37:33 <monochrom> Vector.Storable is pretty strict in values, IIRC
12:37:54 <monochrom> but now you have to write a Storable instance for Pixel
12:38:26 <monochrom> or you can use the ordinary Vector and deepseq your life out of it
12:39:01 <pavolzetor> I will decide after I read the first half of the parallel book
12:39:03 <monochrom> there are many solutions and many non-solutions
12:39:16 <pavolzetor> because I want to render in parallel
12:39:24 <zigschots20> Marlow's book?
12:39:25 <monochrom> solutions are those that pass empirical tests
12:39:32 <pavolzetor> yes
12:39:39 <monochrom> non-solutions are those that look good in an essay
12:39:45 <pavolzetor> :)
12:39:47 <maerwald> huh?
12:39:51 <maerwald> how does that make sense
12:40:03 <zigschots20> its a great book :) I'm just rereading the concurrent bit to get exception handling dialled
12:40:32 <zigschots20> monchrom: well ultimately one wants the understanding to distinguish the two
12:40:33 <pavolzetor> I read some bits, but then I got discarded old code 
12:40:41 <pavolzetor> so I have to go back to the book
12:41:02 <pavolzetor> and also look how other renderers solve this problem
12:41:19 <pavolzetor> unfortunately there is non in haskell that is sufficiently advanced to inspire from
12:41:31 <zigschots20> might be able to use REPA or accelerate if there is not too much interdependence between pixels :)
12:42:11 <pavolzetor> GPU's are off the table currently, then do not have enough VRAM
12:42:28 <zigschots20> sure ok
12:42:57 <pavolzetor> REPA I will have a look
12:44:54 <pavolzetor> at least this is fun, feels more like research than coding
12:45:37 <zigschots20> so does deepseqing your list still use memory? I guess writing out the list to a file means rather than putting values in memory, you just chuck them in the file then GC
12:45:53 <zigschots20> so storing the list in memory might be a bit heavy
12:46:37 <monochrom> a list uses a lot of memory.
12:46:41 <pavolzetor> http://sci.utah.edu/~klacansky/img/currypath2.pdf
12:46:43 <pavolzetor> :)
12:47:26 <monochrom> in the case of 64-bit GHC, each cons cell takes 8*3 bytes already. this only counts cons cells, not even items.
12:47:34 <zigschots20> aye, yikes
12:47:42 <pavolzetor> I need to design the way of solving this, if you were to render fixed number of samples per pixel that would be simple even using lists
12:47:58 <monochrom> a lazy list that hasn't been evaluated yet can take much less memory
12:48:35 <zigschots20> fml; but still thats better than before :)
12:48:40 <monochrom> "I want to completely evaluated a long list to save memory" is one of those non-solutions that look good in essays.
12:48:42 <pavolzetor> monochrom: 1 pointer to next element, 1 pointer to item, what is the last 8 bytes?
12:48:53 <zigschots20> could you write it out to a file, then read it back in to vectorise it?
12:49:03 <monochrom> a represnetation of "I am :"
12:49:11 <monochrom> or rather, "I am (:)"
12:49:56 <zigschots20> monochrom: yeah, that's what we're aiming for, but somewhere in converting a list to an image, the laziness gets lost
12:50:26 <zigschots20> im actually less sure its fromList now...
12:50:50 <monochrom> a fully evaluated list that gets "every time a cell is produced, that cell is almost immediately consumed and then forgotten" also takes very little memory
12:51:16 <monochrom> the trick is, of course, to be sure that you really forget it
12:52:03 <monochrom> Vector's fromList?
12:52:22 <monochrom> things like "Vector.fromList [1..1000000]" satisfies that requirement
12:52:48 <zigschots20> yeah
12:52:56 <monochrom> the vector will be huge and will stay, but the intermediate list does not take up much memory
12:53:29 <zigschots20> monochrom: yeah that seems to be the issue, for some structure doesn't seem to be being forgotten
12:54:25 <pavolzetor> monochrom: wouldn't fromList query length and thus allocate whole list?
12:54:38 <monochrom> ah, I don't know.
12:55:32 * hackagebot mongoDB 2.0.10 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  https://hackage.haskell.org/package/mongoDB-2.0.10 (VictorDenisov)
12:55:34 * hackagebot sbv 5.8 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-5.8 (LeventErkok)
12:56:49 <zigschots20> pavolzetor: yeah, i wonder whether it creates all the thunks, im not sure....
12:59:11 <zigschots20> pavolzetor: here is a test: first allocate a sufficiently large vector, and then build your image by using (//) - vector update
12:59:28 <zigschots20> you could use  a vector of Maybe Pixels
12:59:33 <zigschots20> start with everything Nothing
12:59:43 <monochrom> no, Vector's fromList does not ask about list length
12:59:53 <zigschots20> and then just take the Just px values in the end
13:00:03 <zigschots20> not a solution, but see if it is faster?
13:00:22 <zigschots20> monochrom: how does it know what to allocate then? (strictness in spine
13:02:31 <pavolzetor> zigshots20: I am doing some profiling now
13:02:59 <zigschots20> kk
13:03:08 <pavolzetor> I need to do more background reading, then actually do what I need
13:03:31 <monochrom> I don't know yet. the production chain first converts list to a stream type, then converts the stream to an array. both the stream and the array can disappear if fusion occurs.
13:03:42 <pavolzetor> but I preferably want to write the image to disk in one go and not in bits and pieces
13:04:09 <pavolzetor> (because of compression I want to add)
13:04:18 <monochrom> but in case the array cannot disappear, I still don't know how its allocation occurs
13:05:04 <zigschots20> monochrom: yeah. unstream looks interesting. Will check through later...
13:05:07 <vxri> exercises so on semigroups/monoids http://lpaste.net/148232  - any feedback/suggestions?
13:06:29 <pavolzetor> because it is quite likely the image will be split into tiles and each tile rendered in a thread
13:06:42 <pavolzetor> than all of them collected to final image
13:10:32 * hackagebot sbvPlugin 0.6 - Formally prove properties of Haskell programs using SBV/SMT  https://hackage.haskell.org/package/sbvPlugin-0.6 (LeventErkok)
13:11:42 <kahiru> hello, I'm trying to write a function typed as Int -> WriterT [String] (Either String) Int and I'm failing to produce a Left result. How could this be done?
13:17:54 <puregreen> kahiru: I think “lift (Left str)” should work
13:18:26 <puregreen> or “throwError str”
13:19:05 <kahiru> puregreen++
13:19:37 <kahiru> the lift one works, although it doesn't yield the result i expected (the logs still get lost)
13:21:54 <puregreen> then you need to reverse the order of transformers
13:22:03 <puregreen> ExceptT (Writer [String])
13:23:33 <kahiru> oh, I see
13:48:19 <dalastboss> if i have two variables with type maybe, is there a nice way to return the 1st only if its a Just and otherwise return the second?
13:48:29 <dalastboss> aside from writing out the condition
13:49:09 <suppi> @hoogle (<|>)
13:49:10 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
13:49:10 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
13:49:10 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
13:49:28 <suppi> dalastboss, ^
13:49:59 <dalastboss> Oh nice
13:50:02 <dalastboss> thanks
13:59:57 <pavolzetor> I compiled latest GHC from source but stack complaings about failing adding dependencies
14:00:15 <pavolzetor> is it solvable or just need to wait for stack snapshot with new ghc?
14:27:10 <wowdog> hi
14:27:24 <RedNifre> hey
14:28:03 <RedNifre> I've got a question about mutable state and singletons.
14:28:38 <wowdog> Hi, I have many my own functions in a file.hs and I want to use it as library like  in C/C++  header file in my other project, how can I do it in Haskell?
14:29:06 <RedNifre> While I'm not writing much Haskell these days it still influences how I write code in other languages. But there is this one case where I'm not sure how one would do that in Haskell, conceptionally.
14:30:24 <RedNifre> See, if you have an app on a phone then you have exactly one internet connection and exactly one file system. So having one thing that handles a mutable download queue seems like a perfect fit. Not only having only one mutable queue but also preventing other queues from being accidentally created. How would that work in Haskell?
14:31:31 <RedNifre> Or, to ask it differently: If you have only one internet connection and want to have one download queue for it, how would you do that in Haskell in principle?
14:35:02 <Lokathor> wowdog, you can import your other module
14:50:31 <moredhel> hi, I'm trying to figure out how to construct types in the scotty framework, and have been trying to restructure the example code: https://gist.github.com/hamhut1066/ddd740396e57fdbb1972
14:50:36 * hackagebot opml-conduit 0.4.0.0 - Streaming parser/renderer for the OPML 2.0 format.  https://hackage.haskell.org/package/opml-conduit-0.4.0.0 (koral)
14:50:57 <moredhel> can someone please explain to me what I'm doing wrong, and why
14:53:45 <RedNifre> moredhel hm, why does index return ActionM? Wouldn't it be easier to have it return a string and change line 10 to "html $ index beam"?
14:54:12 <dmj`> html =<< (\beam -> mconcat ["<h1>Scotty", beam, " me up!</h1>"]) <$> param "word"
14:54:30 <moredhel> okay, and try and keep all scotty types out of the logic of the program?
14:54:37 <dmj`> moredhel: I don't think param returns a String, think it's Maybe Text
14:55:10 <RedNifre> yeah. Also, (not sure about this) but doesn't "result <-" bind individual characters of the string to result?
14:55:31 <dmj`> also, result <- mconcat ["<h1>Scotty", beam, " me up!</h1>"], won't work in the ActionM monad
14:55:36 <dmj`> let bind it
14:55:42 <dmj`> let result = mconcat ...
14:55:58 <moredhel> ah, alright.
14:56:09 <moredhel> actually, I should have clarified, I'm getting a weird error:
14:56:10 <moredhel> Couldn't match type ‘[Char]’ with ‘Data.Text.Internal.Lazy.Text’
14:56:14 <RedNifre> why do you use mconcat there? why isn't it just html $ "scotty" ++ beam ++ "..."
14:56:31 <moredhel> err, the example does it, no particular reason.
14:56:45 <RedNifre> can you link the example?
14:57:07 <moredhel> https://github.com/scotty-web/scotty
14:57:10 <moredhel> it's the top example
14:58:23 <pikajude> can template haskell generate pattern synonyms?
14:59:07 <maerwald> not sure I like the idea :D
14:59:21 <dmj`> moredhel: enable OverloadedStrings
14:59:47 <RedNifre> moredhel do you understand the difference between "result <- ..." and "html $ ..."? Specifically between "<-" and "$"?
14:59:57 <Welkin> dmj`: how was jarjar?
15:00:32 <dmj`> Welkin: join me in blah
15:01:02 <moredhel> RedNifre, I believe "result <- ..." is 'draw the the value into "result", and "$" is an operator that forces a sequence of evaluation
15:01:16 <AbelianGrape> Are the automatically generated Serialize instances using DeriveGeneric as efficient as a hand-crafted instance?
15:01:55 <dmj`> AbelianGrape: you should benchmark it, but I doubt it. Aeson generics instances are a lot slower than aeson TH instances
15:02:39 <AbelianGrape> dmj`: Yeah, I figured that was probably the case. Too bad. I like generics as an idea a lot more than TH
15:02:40 <moredhel> okay, <- apparently runs the IO action on the RHS, and binds the result to the LHS
15:03:15 <AbelianGrape> moredhel: Are you talking about how <- works in a do block? haskell do block
15:03:26 <AbelianGrape> *https://en.wikibooks.org/wiki/Haskell/do_notation
15:03:47 <AbelianGrape> a <- b gets desugared to "b >>= \a -> ..."
15:03:54 <dmj`> AbelianGrape: me too
15:04:29 <moredhel> djm`, I believe I have already enable overloaded strings? "{-# LANGUAGE OverloadedStrings #-}"
15:04:35 <AbelianGrape> moredhel: It's not just for IO. Works for any monad. Also doesn't force evaluation order unless the monad is implemented that way.
15:05:55 <moredhel> ah, okay, thanks for the link, having a read now
15:11:35 <dmj`> moredhel: oh, then yea, "param" gives you a Text, not a String
15:15:33 <moredhel> how would I type the following function then?
15:15:40 <moredhel> index beam = "<h1>Scotty, " ++ beam ++ " me up!</h1>"
15:16:05 <moredhel> because if I comment it out, it's fine, but I'm getting "    Non type-variable argument"
15:16:16 <moredhel> a quick google search starts telling me about GHC versions
15:16:35 <AbelianGrape> I think ++ is only for strings, but if it's not and you're trying to use OverloadedStrings, it would be
15:16:43 <AbelianGrape> index :: IsString a => a -> a
15:16:56 <RedNifre> moredhel what's the error? What happens when you combine the last two lines of your code to html $ mconcat [...?
15:17:02 <AbelianGrape> You can also type "index :: _" and GHC will tell you the most general inferred type
15:17:45 <moredhel> https://gist.github.com/hamhut1066/d8f8874bdb5cfb1373ea
15:18:44 <JamesJRH> 00:42:27 < JamesJRH> Happy new U+‖!!! :-]  ← joco42: It's a bit late, but I thought that I'd add that character to the Lambda party hat text art that I did yesterday… :-)
15:18:54 <RedNifre> you could also remove line 12 and let GHC figure out the type (String is wrong if param returns some monadic Text)
15:18:58 <JamesJRH> +---------------------------+
15:18:59 <JamesJRH> | Λ  Λ  Λ  Λ  Λ  Λ  Λ  Λ  Λ |
15:18:59 <JamesJRH> | o_ a/\o  g  @ \o/ 6/\o \o/|
15:18:59 <JamesJRH> |∠| /|  |\/(\<|> | /|  |\ | |
15:18:59 <JamesJRH> | ‖ / \ ‖ / \ ‖ / \ ‖ / \ ‖ |
15:19:01 <JamesJRH> +---------------------------+
15:19:05 <JamesJRH> :-D
15:19:31 <Welkin> a dancing cat?
15:19:37 <JamesJRH> However, I realise that it's a misinterpretation of the base – really, it's happy new 7E0… and the character with that Unicode number is: ߠ
15:19:52 <RedNifre> Ah, did I use the word correctly? Is ["Hey"] a "monadic String" or is Just 3 a monadic Integer? 
15:20:12 <Welkin> RedNifre: what is "monadic"?
15:20:15 <ReinH> RedNifre: No. Not really.
15:20:18 <Welkin> that word is unnecessary
15:20:23 <Welkin> and meaningless in this context
15:20:47 <Welkin> ["Hey"] is a List of String
15:21:06 <Welkin> Just 3 :: Num a => Maybe a
15:21:06 <RedNifre> Okay, so what's the right word to describe what's on the right side in "someString <- hmmm" and what would "monadic x" mean?
15:21:37 <Welkin> RedNifre: a <- ma is just syntactic sugar for `ma >>= \a -> ...`
15:22:18 <RedNifre> sure, but would you call "hmm" a "monadic String"? Calling it a "Monad m => m String" seems a bit unweildy.
15:22:24 <AbelianGrape> RedNifre: That's a good question. I haven't heard a term for that. "Monadic x" usually means "x with a monad instance", but that's not what you're describing
15:22:24 <Welkin> if ma :: Maybe Integer, then you can call ma a Maybe Integer
15:22:29 <AbelianGrape> people never really call it anything
15:22:34 <moredhel> thanks for the help :), I'll pop by tomorrow if I get stuck trying to figure this out. seems I'm missing something here.
15:22:35 <ReinH> RedNifre: You wouldn't call it a monadic String because it is not a String.
15:23:23 <Welkin> RedNifre: don't worry about the terminology
15:23:25 <ReinH> You can call it an action that produces a String. Usually you don't need to call it anything.
15:23:41 <RedNifre> Okay, so "monadic x" means "an x that has a Monad instance".
15:23:54 <ReinH> "monadic x" isn't a term in common usage.
15:24:47 <RedNifre> Okay, so in the example code `result <- param "word"` you would say that "param is an action that produces a String"?
15:25:03 <RedNifre> (Assuming we know that "result" is of type String)
15:25:21 <ReinH> I would say ``param "word"'' is an action that produces a String if it is of type m String for some Monad m.
15:26:33 <ReinH> But obsessing over the terminology isn't really productive. If it's on the right hand side of a <- then we know what it must be.
15:27:26 <RedNifre> ReinH do we? I don't see it in this code (String is wrong, people speculate it should be Text): https://gist.github.com/hamhut1066/ddd740396e57fdbb1972
15:27:44 <ReinH> Yes. We know it must be a value of type m a for some Monad m and some a.
15:28:09 <RedNifre> Alright.
15:42:15 <Jinxit> http://lpaste.net/7935831241985622016 <- I can't seem to use a lens in a monad, any ideas?
15:47:44 <puregreen> Jinxit: you forgot a “do”
15:48:07 <bennofs> puregreen: oh, very nice catch!
15:48:56 <bennofs> I'm surprised a bit though, does that code need extensions? Because I thought RankN as type parameter to [] wouldn't work so well... 
15:49:20 <puregreen> it needs RankNTypes and ImpredicativeTypes
15:49:50 <bennofs> ah yes, ImpredicativeTypes was what I was looking for. Probably better to use an ALens in this case
15:49:56 <bennofs> ATraversal*
15:51:23 <Jinxit> puregreen: adding a 'do' doesn't help
15:51:57 <puregreen> just to make sure: you added it to the “trigger actions m” line, right?
15:52:01 <geekosaur> I don't see what a "do" would do there...
15:53:05 <Jinxit> oh sorry, yeah that do got lost in the paste
15:53:10 <Jinxit> thought you meant at the end
15:53:42 <geekosaur> oh, right, didn;t even read that line, sigh
16:00:10 <Jinxit> ALens seems to work, but how do I turn a normal Lens into an ALens?
16:01:05 <puregreen> a normal lens is an ALens, you don't have to turn anything
16:01:05 <puregreen> to turn an ALens into a normal lens, use cloneLens
16:01:50 <Jinxit> oh ok
16:05:38 * hackagebot bv 0.4.0 - Bit-vector arithmetic library  https://hackage.haskell.org/package/bv-0.4.0 (IagoAbal)
16:18:54 <exio4> https://www.reddit.com/r/haskell/comments/3yvmv3/boilerplate_in_data_type_definitions/cyh64m2 this is a nice trick, but it'd need a ! on extra types, is anything else needed?
16:29:33 <RedNifre> exio4 how does that one work?
16:31:06 <exio4> RedNifre: x :: Void ; x = _|_ is the only possible value (in Haskell, which is nonsensical)
16:31:52 <RedNifre> is _|_ the same as undefined?
16:32:13 <Jinxit> can I make a polymorphic function behave differently for different types?
16:33:04 <jmcarthur> Jinxit: Yes, with type classes.
16:33:22 <Jinxit> ah true
16:33:37 <exio4> RedNifre: undefined is bottom, error "whatever" is bottom, let x = x in x is bottom, basically any computation that doesn't produce any meaningful value
16:33:40 <jmcarthur> Jinxit: Also GADTs, sort of.
16:42:48 <Zemyla> https://hackage.haskell.org/package/checkers Why isn't this package about playing checkers?
16:43:50 <MarcelineVQ> tragic isn't it?
17:11:56 <Ankhers> http://lpaste.net/148216 -- I'm getting that error on https://github.com/ankhers/transit/blob/master/src/Api.hs#L91. Would anyone be able to help me fix it?
17:14:18 <geekosaur> ```return $ mapM_``` looks wrong, for two reasons:
17:14:40 <geekosaur> (1) what follows the `return $` is not running in IO
17:15:07 <geekosaur> (2) mapM_ always produces m (), making the `return` looks a bit dubious in any circumstance
17:15:45 <geekosaur> I think you just want to lose the `return $`
17:16:30 <Ankhers> geekosaur: http://lpaste.net/148237 is what I get when I remove `return $'
17:18:03 <geekosaur> ok, guess that makes sense, but that return $ is in the wrong place to fix it (at best)
17:20:30 <geekosaur> hm. for starters, you're not dealing with the Either
17:22:32 <geekosaur> once you deal with that, I think you need either a ghc whose mapM_ uses Traversable (and a V.Vector which is Traversable), or you need a V.Vector-specific mapM_, or you need to turn the V.Vector into a llist so you can mapM_ over it
17:23:53 <geekosaur> that is, with ghc 7.10.x, once you deal with the EIther then you do not need the V.map
17:24:44 <geekosaur> and with any version of ghc I think you want V.mapM_ instead of mapM_ (V.map ...)
17:25:01 <Ankhers> geekosaur: What do you mean by "deal with the Either"?
17:25:12 <geekosaur> (that is, with ghc 7.10 you can use mapM_, with earlier versions but also with 7.10 V.mapM_ would work)
17:25:39 <geekosaur> IO (Either SomeException (V.Vector Agency))
17:25:43 <Ankhers> I'm using 7.10.2
17:26:01 <geekosaur> so "agencies" has type Either SomeException (V.Vector Agency)
17:26:09 <Ankhers> Yes.
17:26:14 <geekosaur> but you use it as if its type is V.Vector Agency
17:27:17 <geekosaur> and I suspect that is leading to the MonadIO complaint because mapM_ is assuming the monad in question is Either String
17:27:57 <geekosaur> hm, no, not quite. thinks it's the Traersable instance, maybe?
17:28:20 <geekosaur> in any case it's all confused. you want an fmap if you just want to operate on the Right of it
17:29:40 <geekosaur> hm, not sure an fmap will work there either. I think you need to patternmatch the Either away to make the types line up
17:31:13 <geekosaur> or: either (const V.empty) id agencies
17:32:27 <geekosaur> V.mapM_ (\a -> runDb $ upsert a []) (either (const V.empty) id agencies) -- something like. I think
17:34:00 <Ankhers> geekosaur: http://lpaste.net/148238
17:34:57 <geekosaur> that sounds like something else is missing, then, but I don't know what offhand
17:36:03 <Ankhers> geekosaur: I appreciate the help.
17:37:06 <geekosaur> guh, my local network does not like loading stuf right now...
17:40:53 <geekosaur> can't even find the right runDb, sigh
17:41:04 <Ankhers> geekosaur: Models.hs
17:41:42 <Ankhers> I basically followed https://github.com/parsonsmatt/servant-persistent.
17:42:33 <geekosaur> ok, so as far as I can see you are using runDb in IO but it expects to be somewhere that `asks getPool` is valid
17:43:11 <geekosaur> becaue extractAndParseFiles is in IO, not in an AppM context
17:43:23 <Ankhers> geekosaur: Makes sense.
17:44:47 <geekosaur> and that'll b a pain to fix because you're running that under liftIO . forkIO
17:45:16 <geekosaur> (reload invoking downloadFile invoking extractAndParseFiles)
17:45:52 <geekosaur> so you need to find a way to do that in the AppM context, and I don't know Servant so don't know how you multithread that keeping the AppM valid in each thread
17:49:55 <Ankhers> I appreciate the help. I think I am just going to create a separate script to reload the data.
18:16:36 <jaarod> will foldl' be renamed foldl at some point (and old foldl removed)?
18:50:06 <potatoe> anyone who has used servant here before? I've an API that doesnt return any data but I want it to return 200
18:50:08 <potatoe> code: https://gist.github.com/spaghetti-/458dae1033f67a78cac6
18:50:13 <potatoe> any idea how to send 200?
19:07:17 <Lokathor> StateT in transformers has Monad and Functor instances declared, but it doesn't have an Applicative instance declared. Does giving it Monad also just give it a defualt Applicative with return=pure and <*>=ap ?
19:09:17 <c_wraith> Lokathor: that seems unlikely if it compiles on recent GHC
19:09:42 <c_wraith> Oh, I see.  Yeah, I think Applicative has a default definition now, in terms of ap and return
19:10:33 <Lokathor> it also has, (Functor m, Monad m) => Applicative (StateT s m)
19:10:36 <c_wraith> Huh.  Doesn't look like it does have those default definitions.
19:11:12 <Lokathor> but that declaration strikes me as old, because any Monad m would inevitably be a Functor m these days
19:11:31 <c_wraith> Lokathor: I think you're looking at an old version of StateT
19:11:36 <c_wraith> https://hackage.haskell.org/package/transformers-0.5.0.0/docs/src/Control-Monad-Trans-State-Lazy.html#line-190
19:11:59 <c_wraith> or https://hackage.haskell.org/package/transformers-0.5.0.0/docs/src/Control-Monad-Trans-State-Strict.html#line-187
19:12:09 <Lokathor> that's what i said
19:12:18 <Lokathor> i was looking at the same 0.5
19:12:48 <c_wraith> Remember, it needs to build on multiple versions of ghc
19:12:52 <c_wraith> Including pre-AMP
19:13:38 <Lokathor> well, right
19:13:50 <c_wraith> So it needs both constraints.
19:13:58 <c_wraith> And it is declared right there.  So it's not missing.
19:14:08 <c_wraith> I'm not sure what you're asking, at this point.
19:14:48 <ga2arch> damn i deleted the work's remote master branch by mistake, i'm panicking, is it enough to repush the local copy ?  
19:15:07 <Lokathor> to clarify, i missed that at first, and then my question changed to, "why not just have instance (Applicative m) => Applicative (StateT s m) where"
19:15:22 <c_wraith> ga2arch: this doesn't seem to be a haskell question.  But probably.
19:15:29 <Cale> Lokathor: Try writing the instance :)
19:15:55 <ga2arch> c_wraith: yeah sorry, like i said, i'm panicking :S
19:16:16 <Lokathor> Cale i wouldn't have the foggiest
19:16:35 <c_wraith> ga2arch: I'd push your copy to a new branch, actually, then send your coworkers an email explaining what happened.  It's ok.  It's hardly the worst thing a developer's ever done.
19:17:48 <ga2arch> c_wraith: thanks, i'll write it right now. 
19:22:03 <Lokathor> i still don't know what the difference between transformers and mtl really is
19:22:07 <Lokathor> i'm starting to think i never will
19:23:20 <MarcelineVQ> seen this? http://blog.jle.im/entry/mtl-is-not-a-monad-transformer-library
19:23:47 <c_wraith> Lokathor: transformers contains the actual data types, the MonadTrans class, and instances.
19:24:02 <c_wraith> Lokathor: mtl contains classes like MonadReader, MonadWriter, MonadState, etc, and instances
19:24:19 <c_wraith> Lokathor: and re-exports the types from transformers
19:24:30 <Lokathor> so the answer is... you use both?
19:24:49 <c_wraith> you can use transformers only, if you like.  But using mtl necessitates using both.
19:25:33 <c_wraith> though mtl exports enough that you don't need to directly import anything from transformers
19:25:51 <Lokathor> yes it seems i've been using mtl on my project
19:26:03 <Lokathor> and mtl and transformers just keep things along different import paths
19:26:14 <Lokathor> how troublesome
19:27:21 <c_wraith> well, mtl re-exports the transformers types.  They can be used interchangeably
19:28:31 <Lokathor> but you import them differently
19:28:39 <Lokathor> Control.Monad.State vs Control.Monad.Trans.State
19:28:52 <Lokathor> even if they're ultimately the same data type re-exported
19:30:51 <c_wraith> yes
19:32:11 <Lokathor> it also seems unfortunate that it's hard to build things on top of State that are agnostic about if it's a lazy or strict version
19:32:28 <c_wraith> It's..  Not.
19:32:35 <c_wraith> That's what the MonadState class does
19:33:20 <Lokathor> hmm
19:33:39 <c_wraith> Well, one of many things.
19:33:50 <Lokathor> i didn't know how to read the "| m -> s" part of the declaration
19:33:57 <Lokathor> so i ignored the whole thing >_>
19:34:05 <c_wraith> Lokathor: that's called a "Functional Dependency"
19:34:17 <c_wraith> Lokathor: it means that for any choice of m, s must always be the same.
19:34:43 <Lokathor> so say i've got a function, rollxdy :: (RandomGen g) => Int -> Int -> State g Int
19:35:02 <Lokathor> i should re-write it to use MonadState instead if i want it to not be choosy about Strict or Lazy?
19:35:49 <c_wraith> yes.  It'd be like  rollxdy :: (MonadState m g, RandomGen g) => Int -> Int -> m Int
19:36:16 <Lokathor> this i will look in to
19:37:32 <Lokathor> MarcelineVQ, i have not read that article, but i will do so right now
19:46:19 <hunteriam> libs for servant/sql?
19:56:15 <hunteriam> what does this data declaration mean? `data QueryParam (sym :: Symbol) a`
19:57:50 <geekosaur> hunteriam, looks like a kind signature to me
19:58:42 <geekosaur> sym has kind Symbol (which is likely https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/GHC-TypeLits.html#t:Symbol)
19:59:07 <geekosaur> would have DataKinds and KindSignatures extensions enabled
20:00:38 <geekosaur> (I think the latter...)
20:00:48 * hackagebot streaming-utils 0.1.4.1 - http, attoparsec, pipes and conduit utilities for the streaming libraries  https://hackage.haskell.org/package/streaming-utils-0.1.4.1 (MichaelThompson)
20:01:52 <geekosaur> hm, no, I giess kind sigs are not separate extension
20:02:23 <geekosaur> oh wait, found it, yes
20:06:06 <geekosaur> so, "sym" there must be a type level value whose kind is Symbol (a type-level string)
20:22:56 <hunteriam> what lib should i use for sql
20:23:09 <no-n> what is some good introductory reading on lambda calculus?
20:27:07 <vxri> no-n haskellbook.com
20:27:13 <Welkin> hunteriam: what are you doing?
20:27:17 <Welkin> which sql?
20:27:19 <Welkin> postgres?
20:27:27 <Welkin> I always use Persistent
20:27:28 <hunteriam> it pretty much doesnt matter
20:27:34 <Welkin> it supports all sql languages
20:28:03 <Welkin> for postgres specifically, you can try opaleye
20:28:36 <vxri> welkin heard good things about opaleye wrt to correctness and composability
20:29:21 <vxri> welkin if i'm starting green field (and using postgres) would you recommend that over persistent?
20:29:39 <Welkin> vxri: not in particular
20:29:53 <Welkin> opaleye is more complex to get working and lacks nice features that persistent has
20:29:59 <xplat> why is aeson in stackage-LTS so ancient?
20:30:07 <Welkin> persistent uses template haskell so you type a lot less
20:30:17 <Welkin> it also does automatic migrations
20:30:31 <xplat> like, i think it literally has mold on it
20:30:37 <Welkin> if you are going to be using standard sql features, go with persistent
20:30:50 <Welkin> if you are going to write crazy complex queries, opaleye might be worth using
20:30:57 <xplat> also, you have to go through all kinds of gymnastics to get it to decode a bare string or numeric value, like other crusty json parsers
20:31:38 <vxri> most of my stuff is pretty basic atm
20:31:56 <vxri> is there a way to use servant to query postgres?
20:31:57 <Welkin> I prefer persistent because I can make changes to it rapidly
20:32:08 <Welkin> vxri: you can use anything you want
20:32:13 <Welkin> I have used persistent with servant
20:33:31 <vxri> is there an example? i thought out of the box servant is mostly for serving/consuming http
20:33:37 <xplat> seriously, who ever thought that was a good idea?
20:33:52 <Welkin> xplat: aeson is super easy to use
20:33:54 <Welkin> not sure what you mean
20:33:57 <vxri> xplat: you mean opaleye?
20:34:16 <xplat> Welkin: decode "\"hi\"" -> Nothing
20:34:20 <xplat> not easy to use
20:35:37 <Welkin> vxri: https://github.com/parsonsmatt/servant-persistent
20:36:05 <Welkin> xplat: if you use it to actually decode json into a type you constructed, it works flawlessly
20:36:48 <xplat> Welkin: import Data.Aeson.Types (parseMaybe); import Data.Aeson.Parsers (value); parseMaybe value "\"hi\"" -- actually works, not easy to use
20:37:12 <xplat> Welkin: i'm using it for a parser, not a pickler
20:37:41 <xplat> i don't construct everything the way i like it on a green field here, i'm web scraping
20:38:30 <Welkin> xplat: then why complain if you are not using it as intended?
20:38:58 <xplat> Welkin: it wasn't intended to be used *exclusively* as a pickler
20:39:12 <Welkin> aeson is for json (de)serialization
20:39:29 <xplat> Welkin: working with the Value type is supported
20:40:02 <Welkin> write your own parser using parsec
20:40:11 <xplat> Welkin: also, if aeson is not the library for parsing json in haskell, pls point me to the library that is
20:40:12 <Welkin> aeson uses attoparsec
20:41:30 <xplat> and no, it completely defeats the point of reuse for me to write my own json string parser when i am parsing json strings
20:42:34 <Welkin> xplat: then I don't know what you are complaining about
20:42:43 <Welkin> you don't like the existing solution, which works just fine
20:42:48 <Welkin> and you don't want to write your own
20:43:03 <xplat> Welkin: also, newer versions of aeson make this easy as pie, only if i want to use them i have to do freaking gymnastics with stack instead, so gymnastics either way
20:44:04 <xplat> Welkin: fortunately i don't need you to know what i am complaining about
20:54:15 <xplat> actually to do this with older versions of aeson i need to use things from Data.Aeson.Parser.Internal?  what?!?!
20:57:56 <xplat> hm, i guess i should use attoparsec functions directly with parsers from Data.Aeson.Parsers
21:51:54 <hunteriam> is there a Persistant tutorial?
22:03:16 <julianleviston> hunteriam: I think there’s one in the Yesod book.
22:03:18 <zaquest> hunteriam, http://www.yesodweb.com/book/persistent ?
22:03:25 <julianleviston> haha jinx
22:07:52 <Jinxit> sup?
22:21:14 <julianleviston> lol…
22:21:38 <julianleviston> sorry
22:46:05 <bollu> which libraries have an Arrow interface so I can use it / get used to it?
22:47:09 <dmj`> netwire, opaleye
22:50:58 <bollu> opaleye is for databases right? 
22:51:08 <bollu> cool, I've been meaning to write a web server for a while now :)
22:52:17 <dmj`> bollu: yea, it's for postgresql
22:52:41 <bollu> dmj`: along the same lines, any cool libraries for server side webdev?
22:52:53 <dmj`> bollu: servant
22:53:16 <dmj`> bollu: there's also snap, scotty, spock, yesod, happstack
22:53:27 <dmj`> and just plain wai/warp
22:53:47 <bollu> which one would you recommend for a "first time" experiencE?
22:53:56 <bollu> I mostly come from python/node for webdev
22:54:10 <bollu> so I'm used to having routing and sessions and whatnot baked in :)
22:57:23 <dmj`> bollu: servants routes are described as types, which are then reified as actual routes in a wai Application. There are alternative packages for sessions to use (clientsession). Yesod is more all-in-one, but it's big. Snap can be all-in-one, same w/ happstack. You can make your own with wai/warp too. 
22:57:27 <dmj`> @package clientsession
22:57:27 <lambdabot> http://hackage.haskell.org/package/clientsession
22:57:50 <dmj`> bollu: depends in you're building a single page app, or a traditional forms based app
22:58:15 <dmj`> with a traditional request / response model (not everything AJAX)
22:58:21 <dmj`> s/in/on
22:58:32 <dmj`> depends on if *
22:58:59 <parsnip> hmm, so cabal-dev can be used to for example run pandoc in ghci? 
22:59:50 <parsnip> but i ran into cabal hell, so i thought i'd try stack, but now i've realized i'm not sure it can do a similar thing to run pandoc in an interactive. 
23:01:06 <KaneTW> if i have a FFI (opaque but probably lightweight) resource that's opened by a c call and closed by a c call, should i use ForeignPtr with a finalizer or use something like ResourceT?
23:02:50 <bollu> dmj`: assuming mostly single page with some form stuff?
23:03:08 <bollu> Like, a highly dynamic "main page" with some traditional stuff for login/register/what have you
23:06:00 <dmj`> bollu: If you want to do single page stuff I'd go with servant and ghcjs
23:06:31 <bollu> dmj`: and if I want to have some forms as well in it? does servant help with that as well?
23:07:13 <dmj`> servant can handle forms, but servant is better suited for APIs IME
23:08:11 <dmj`> bollu: you could create the register / login pages w/ reflex-dom (ghcjs lib)
23:08:35 <bollu> dmj`: what's that?
23:08:42 <dmj`> @package ghcjs-dom
23:08:42 <lambdabot> http://hackage.haskell.org/package/ghcjs-dom
23:08:50 <dmj`> woops
23:09:33 <dmj`> @package reflex-dom
23:09:33 <lambdabot> http://hackage.haskell.org/package/reflex-dom
23:11:57 <dmj`> bollu: reflex is an FRP library, reflex-dom is a web framework based on reflex
23:16:46 <dmj`> bollu: maybe you can make the register / login pages on the front end
23:16:57 <dmj`> bollu: write the styles and such first
23:18:19 <hunteriam> i feel like servant uses the type systems for thngs that arent really types
23:18:27 <KaneTW> that's not a bad thing
23:18:34 <hunteriam> its very useful but semantically kind of nonsense 
23:18:39 <KaneTW> not really
23:18:41 <KaneTW> dependent types are a thing
23:19:16 <hunteriam> i just dont conceptually understand what makes a route a valid type
23:19:28 <dmj`> hunteriam: using constraint kinds you get assurance that a link will exist at compile time.
23:20:06 <hunteriam> i get that it works, but i dont think it makes sense to call it a typs
23:20:10 <hunteriam> type
23:22:28 <dmj`> hunteriam: so the type exists at compile time, but gets reified as a value in a wai Application at runtime. The type gets resolved as a value via a typeclass `HasServer`
23:25:51 <hunteriam> @src (->)
23:25:52 <lambdabot> Source not found. The more you drive -- the dumber you get.
23:26:32 <user7001> "The more you drive -- the dumber you get." what is this?
23:28:22 <kadoban> user7001: Some "funny" quotes lambdabot includes with errors for some reason.
23:28:48 <ggVGc> bollu: have you looked at Elm? SO far it's the nicest way I've tried for making web content with Haskell. Elm is only a basic subset of Haskell though, with some minor differences. I am really liking it though
23:29:04 <ggVGc> ah, also it's FRP from the core, so if you don't want that it's no use
23:29:33 <ggVGc> ghcjs is more powerful but pretty heavyweight
23:29:51 <dmj`> ggVGc: you can't share types though
23:30:00 <ggVGc> yeah, that's true
23:30:09 <ggVGc> dmj`: I thought he was just making a single page thing
23:30:15 <ggVGc> i.e a web app in haskell
23:30:21 <ggVGc> and for that Elm is real nice I reckon
23:31:06 <hunteriam> what if  wanf to mixin acfual js
23:31:18 <hunteriam> like i want to ise googles api for signing in 
23:31:50 <ggVGc> hunteriam: with Elm you'd do it through a port. Not sure about ghcjs, I think it doesn't have very good FFI yet
23:31:51 <dmj`> ggVGc: true, but sharing types for encoding / decoding things is nice, plus free monads can let you interpret grammar as front end or backend logic
23:32:20 <ggVGc> dmj`: sure, ghcjs is more powerful, but also carries other tradeoffs
23:32:47 <ggVGc> from what I did wit ghcjs, it's pretty much all or nothing Haskell. Interoping with JS is a bit of a pain
23:33:34 <ggVGc> Haste apparently has good JS interop
23:33:42 <ggVGc> and compiles most of Haskell
23:34:30 <dmj`> Haste doesn't givey you full haskell though
23:34:34 <dmj`> give you*
23:34:41 <dmj`> afaict
23:35:12 <ggVGc> yeah but enough for most people
23:35:37 <dmj`> ggVGc: I don't see why most of the google login stuff couldn't be handled on the server side. You'd just need to open a page to perform the 3 legged flow
23:37:58 <user7001> test...
23:39:43 <dmj`> ggVGc: ghcjs apps are a little big, but maybe the rts.js and other things can be hosted on a CDN
23:39:55 <`Guest00000> :t ()
23:39:56 <lambdabot> ()
23:43:04 <KaneTW> hm
23:43:21 <KaneTW> EIBConnection and then have stuff like eIBClose or EibConnection and eibClose?
23:45:30 <Svarog> when category-extras was split up and deprecated, what happened to HFunctor?
23:46:42 <Svarog> was it removed because it wasn't perceived as particularly useful or because there was a better way to express the same concept?
23:49:15 <Svarog> type :~> f g = forall a. f a -> g a
23:49:21 <Svarog> class HFunctor f where hfmap :: (g :~> h) -> f g :~> f h
