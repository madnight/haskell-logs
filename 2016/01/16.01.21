00:01:06 <koz_> How would I use the Array constructor here if I want an array of 27 Foos? http://hackage.haskell.org/package/array-0.5.1.0/docs/Data-Array-IArray.html#g:2
00:01:50 <liste> koz_ Array's constructor is not exported, use the `array' function
00:01:59 <koz_> liste: Thanks.
00:02:17 <opqdonut> koz_: "listArray (replicate 27 (makeFoo 1 2 3))" or so
00:02:23 <koz_> liste: The thing is, I wanna define a type that has an Array inside it.
00:02:44 <opqdonut> oh then you just say "data MyData = MyData Int (Array Int Foo)" or so
00:02:51 <koz_> Like 'data Bar = Bar <whatever that array type would be> Int'
00:03:03 <liste> yeah, the type constructor IS exported
00:03:03 <koz_> Oh, so the length is not burned into the type?
00:03:08 <opqdonut> no, it's not
00:03:10 <liste> data constructor is not
00:03:31 <opqdonut> (and my listArray example was wrong, you need "listArray (0,26) (replicate 27 (makeFoo 1 2 3))")
00:03:52 <koz_> opqdonut: Is there any sequential collection library which *does* have length burned into its type?
00:03:59 <opqdonut> well there are tuples
00:04:00 <liste> @hackage fixed-vector -- this does
00:04:00 <lambdabot> http://hackage.haskell.org/package/fixed-vector -- this does
00:04:02 <movedx> Is Yesod the go to framework for anything web related? Such as REST APIs?
00:04:03 <liste> also
00:04:09 <opqdonut> and there are some packages on hackage, thanks liste
00:04:09 <koz_> liste: Thanks!
00:04:18 <liste> but it's deep in the hasochism territory
00:04:31 <koz_> liste: Hasochism?
00:04:48 <liste> koz_ http://homepages.inf.ed.ac.uk/slindley/papers/hasochism.pdf
00:05:02 <anohigisavay> liste:  let v = mkName "T" in [| data $v = $v |]
00:05:05 <liste> "the pain and pleasure of dependently-typed haskell programming"
00:05:08 <anohigisavay> liste: http://hackage.haskell.org/package/template-haskell-2.5.0.0/docs/Language-Haskell-TH.html
00:05:17 <opqdonut> if the length is constant it's not that painful
00:05:27 <anohigisavay> liste: but i don't see how this should work. (played that in GHCi and parse error)
00:05:31 <JamesJRH> liste: The funny thing was, initially it wasn't installed and had an error that it couldn't be found, but when I had installed it I still had the same error that it couldn't be found which looked very similar, this time due to the typo that was copied/pasted.
00:06:44 <JamesJRH> liste: They both gave 3 suggestions beginning in ‘Data.…’ and had the same overall shape, only that Data.ByteString.Base64 was hidden amongst the latter 3 and I didn't notice the difference for over 3 hours! I thought that I was doing something wrong in NixOS for ages. :-]
00:07:41 * hackagebot http-client 0.4.27 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.27 (MichaelSnoyman)
00:07:41 * hackagebot werewolf 0.3.1.2 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.3.1.2 (hjwylde)
00:11:24 <hvr> this werewolf package is going through some fast paced development =)
00:11:28 <pikajude> so GHC 8 has OverloadedRecordFields. i have a whole bunch of models that I need to define for my API. how good of an idea is it to put each model in a separate file and #include them?
00:11:36 <pikajude> since separate modules cannot share record field names
00:15:52 <pikajude> seems like a very fragile workaround right now
00:17:48 <JamesJRH> 2016-01-16Sat09:24:42 < liste> JamesJRH nixpkgs.haskellPackages.base64Bytestring in my (very old) nix  ← How old? What version is/was that?
00:18:18 <platz> anyone have ghcmod-vim working under ghc-mod 5.5.0.0 ?
00:18:20 <JamesJRH> s/version/release/
00:19:25 <radens> I've defined: data Expr = String... and I'm getting this error: Couldn't match expected type ‘Expr’ with actual type ‘[Char]’
00:19:31 <radens> Why would this be?
00:19:34 <JamesJRH> liste: Also, I still don't particularly understand how the types work for that.
00:20:00 <liste> JamesJRH nix-env at least says 1.8
00:20:42 <JamesJRH> liste: Oh, is it not NixOS? Standalone Nix?
00:20:49 <liste> yes, standalone nix
00:22:06 <JamesJRH> liste: Then nixpkgs version/release is perhaps more relevant. What does ‘nix-channel --list’ give you?
00:22:24 <JamesJRH> Or ‘sudo -i nix-channel --list’ if applicable.
00:23:39 <liste> JamesJRH nixpkgs https://nixos.org/channels/nixpkgs-unstable
00:23:46 <liste> (+ some package overrides)
00:23:53 <JamesJRH> Oh.
00:24:12 <liste> so I guess that's where the nixpkgs.<stuff> comes from
00:24:57 <JamesJRH> Well Nix 1.8 corresponds to NixOS 14.12 according to the release notes: https://nixos.org/nixos/manual/release-notes.html#sec-release-14.12
00:26:38 <JamesJRH> I have NixOS 14.12 and Nix 1.8, though I think I saw Nix 1.8 in 14.04 before I upgraded, even though those release notes say it started on Nix 1.7.
00:27:55 <liste> JamesJRH and about the types, -XOverloadedStrings makes `"I want to do this in Haskell"' really be `fromString "I want to do this in Haskell"'
00:28:15 <JamesJRH> liste: But anyway, what I was getting to is that your Nix installation roughly corresponds to 14.12 which is the last release to have the old naming conventions for Haskell packages.
00:28:46 <liste> and then the correct instance is chosen using the type signature of "encode"
00:29:28 <JamesJRH> After that, camelCase is converted to hyphenated naming in 15.09: https://nixos.org/nixos/manual/release-notes.html#sec-release-15.09
00:31:36 <JamesJRH> So I'll have to change ‘base64Bytestring’ to ‘base64-bytestring’ in my declaration of packages for haskellPackages.ghcWithPackages when I update to NixOS 15.09.
00:32:30 <JamesJRH> liste: Ah, I see. So I can use ‘fromString’ to do it properly then.
00:32:36 * hackagebot stackage-curator 0.13.0 - Tools for curating Stackage bundles  https://hackage.haskell.org/package/stackage-curator-0.13.0 (MichaelSnoyman)
00:32:51 <liste> JamesJRH fromString is in Data.String
00:33:09 <liste> a method of IsString class
00:33:40 <JamesJRH> Hmm, but then does fromString have a notion of character encoding?
00:34:15 <liste> JamesJRH it's supposed to be used with encoding-aware types, with ByteString it's ASCII only AFAIK
00:34:18 <movedx> This I don't get: intListLength (x:xs) = 1 + intListLength xs
00:34:25 <movedx> What is (x:xs) saying, exactly?
00:34:27 <JamesJRH> String is a character string, to convert to a bytestring, one must … Oh.
00:35:27 <liste> so it's better to use something like `pack' or utf8-string
00:36:00 <JamesJRH> liste: How can I convert UTF-8 string "naïve" to base 64, then?
00:36:05 <frerich> movedx: You know how '(:)' is a data constructor to build lists? I.e. you can say '1 : [2,3]' to get '[1,2,3]'?
00:36:27 <movedx> Yep!
00:36:33 <movedx> Or [1,2] : [3,4]
00:36:44 <frerich> movedx: Alas, no -- that won't work. :-)
00:37:01 <movedx> Ah, just tried that. Quite right!
00:37:16 <frerich> Consider the type of (:) --
00:37:19 <frerich> :t (:)
00:37:21 <lambdabot> a -> [a] -> [a]
00:37:37 <frerich> The first argument (i.e. the left one when using '(:)' infix) is a single element, the second argument is a list.
00:37:38 <movedx> Right, the type on the left must match that of the elements in the list on the right.
00:37:52 <frerich> movedx: Anyway, turns out that you can also use the data constructors to 'deconstruct' (do not confuse this with 'destroy') a value.
00:38:11 <frerich> movedx: This is called 'pattern matching'.
00:38:16 <liste> @hackage utf8-string -- JamesJRH
00:38:17 <lambdabot> http://hackage.haskell.org/package/utf8-string -- JamesJRH
00:39:12 <liste> and note that there's a *different* fromString function
00:39:21 <frerich> movedx: E.g. for a function like 'myLength :: [a] -> Int', you can define 'myLength xs = if null xs then 0 else 1 + myLength (tail xs)'. Or you can do 'myLength [] = 0; myLength (x:xs) = 1 + myLength xs'. Note how the two data constructors '[]' and ':' are used to 'deconstruct' the list such that you can access the individual arguments. 
00:39:55 <frerich> movedx: I.e. the pattern 'x:xs' only matches non-empty lists, and 'x' is the head of that list and 'xs' is the (possibly empty) tail.
00:41:52 <JamesJRH> So with ‘fromString’, I can now do it on 1 line:
00:41:53 <JamesJRH> > Data.ByteString.Base64.encode $ Data.String.fromString "I want to do this in Haskell."
00:42:18 <JamesJRH> Which beats Python. :-)
00:42:50 <JamesJRH> > 1 + 1
00:43:01 <frerich> JamesJRH: In Python, that would be: "I want to do this in Haskell.".encode("base64")
00:43:04 <JamesJRH> Hmm, lambdabot's still having trouble.
00:43:56 <JamesJRH> frerich: Don't you need to ‘import base64’?
00:44:02 <JamesJRH> Hmm.
00:44:18 <JamesJRH> Apparently not.
00:44:22 <JamesJRH> Meh.
00:44:30 <JamesJRH> Anyway.
00:44:35 <frerich> JamesJRH: No. Note that the encoding to use is passed as a string.
00:45:47 <JamesJRH> This also works: Prelude> Data.ByteString.Base64.encode $ Data.String.fromString "naïve"
00:45:50 <JamesJRH> "bmHvdmU="
00:46:06 <liste> no idea what encoding that is
00:46:16 <liste> and if it's even portable (?)
00:47:14 <JamesJRH> >>> "naïve".encode("base64")
00:47:14 <JamesJRH> 'bmHDr3Zl\n'
00:47:41 <liste> seems it truncates code points >255 to 255
00:48:11 <JamesJRH> Hmm.
00:48:35 <phadej> the ByteStrings's IsString instance does that
00:49:03 <m1dnight_> I have to upgrade cabal on my linux machine. I need `base >=4.8.1.0 && <4.9` but I cant satisfy it on my linux machine.
00:49:11 <JamesJRH> Okay, so utf8-string…
00:49:28 <liste> m1dnight_ base version depends on ghc version'
00:49:30 <m1dnight_> I have cabal 1.22.6 and ghc 7.8.4 on my linux machine.
00:49:45 <m1dnight_> So I should upgrade ghc then? cool, thats what Ineeded to know.
00:49:45 <potatoe> anyone knows why postgresql-simple throws this exception even though I've set my field type to Data.Text?
00:49:46 <potatoe> Incompatible {errSQLType = "text", errSQLTableOid = Just (Oid 24831), errSQLField = "email", errHaskellType = "Char", errMessage = ""}
00:49:48 <phadej> JamesJRH: or Data.Text.Encoding.encodeUtf8 
00:49:58 <potatoe> errHaskellType says Char but I have set it to text
00:51:02 <m1dnight_> So, before I break stuff, can I just remove ghc and then reinstall using this ppa: deb http://ppa.launchpad.net/hvr/ghc/ubuntu vivid main 
00:51:43 <phadej> JamesJRH: > encode $ encodeUtf8 "naïve"
00:51:43 <phadej> "bmHDr3Zl"
00:52:11 <m1dnight_> Oh, there seems to be a package named `ghc-7.10.2` :)
00:52:13 <potatoe> maybe Im casting it wrongly
00:52:37 * hackagebot imports 0.2.0.0 - Generate code for importing directories automatically  https://hackage.haskell.org/package/imports-0.2.0.0 (CindyLinz)
00:52:43 <liste> m1dnight_ you may need to rebuild stuff after that
00:53:01 <JamesJRH> Prelude> Data.ByteString.Base64.encode $ Data.String.UTF8.fromString "naïve"
00:53:02 <JamesJRH> <interactive>:6:33: Not in scope: ‘Data.String.UTF8.fromString’
00:53:22 <JamesJRH> I don't have the utf8-string package.
00:53:28 <liste> Data.ByteString.UTF8
00:53:41 <liste> it's a different type
00:53:59 <liste> Data.String.UTF8 has a type named "UTF8"
00:55:01 <m1dnight_> Sorry for nagging, but would it suffice then to relink `ghc` to `/opt/ghc/7.10.0/bin/ghc` ? 
00:55:11 <m1dnight_> And just reinstall cabal or something
00:56:00 <lpsmith> potatoe, that's the Haskell Type.   You are attempting to convert a postgresql "text" type  (see errSQLtype) to Haskell's "Char" type.
00:56:21 <JamesJRH> I could install it, but seeing as phadej has provided another option using Data.Text, I'll try that first.
00:56:54 <JamesJRH> phadej:     Couldn't match expected type ‘Data.Text.Internal.Text’
00:56:54 <JamesJRH>                 with actual type ‘[Char]’
00:57:06 <liste> JamesJRH -XOverloadedStrings
00:57:11 <lpsmith> The FromField instance for Char is only compatible with postgresql's "char" type.   (Which, incidentally,  must be written as a quoted identifier)
00:58:01 <potatoe> lpsmith do you know what postgres' text type maps to in haskell land?
00:58:01 <potatoe> (acc to postgresql-simple)
00:58:15 <JamesJRH> liste: Can I do it without that though?
00:58:25 <lpsmith> potatoe, ByteString or Text.
00:58:32 <lpsmith> Preferably,  Text.
00:59:03 <liste> JamesJRH yes, e.g. by using `Text.pack'
00:59:24 <lpsmith> Arguably,  the ByteString instance's compatibility with text should be deprecated.
01:00:00 <potatoe> lpsmith sorry my connection dropped, did you mention it was ByteString?
01:00:28 <lpsmith> potatoe,  ByteString or Text,  preferably Text.
01:00:31 <JamesJRH> 08:47:18 < liste> seems it truncates code points >255 to 255  ← ‘ï’ is codepoint 0xEF (239). Do you mean s/255/127/g ?
01:00:44 <potatoe> lpsmith I tried Data.Text, I still have the same problem
01:01:06 <EyeJoy> I'm installing haskell platform for windows, everything works fine, I try use command:  cabal install yesod-bin, its work fine too everything downloaded and configured, but when I try to import Yesod in winGHCi it said 'Could not find module ‘Yesod', what happen ?
01:01:28 <lpsmith> potatoe, are you relying on inference to set the return type?
01:01:37 <lpsmith> Because it's being converted to Char,  for sure.
01:01:40 <liste> JamesJRH no, 255: https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/src/Data.ByteString.Internal.html#c2w
01:01:48 <lpsmith> if that's the exception you are getting.
01:01:51 <potatoe> lpsmith yes I am by starmap field etc
01:02:11 <lpsmith> starmap field?
01:02:13 <liste> JamesJRH that's why the IsString instance for ByteString shouldn't be used in production code
01:02:23 <JamesJRH> Prelude> Data.ByteString.Base64.encode $ Data.Text.Encoding.encodeUtf8 $ Data.Text.pack "naïve"
01:02:25 <potatoe> sorry, I meant like table <$> field <*> field ..
01:02:26 <JamesJRH> Loading package text-1.2.0.0 ... linking ... done.
01:02:29 <JamesJRH> "bmHDr3Zl"
01:02:57 <JamesJRH> Okay, that matches with the Python result.
01:04:40 <lpsmith> potatoe, well I can't say exactly what's wrong (though you are welcome to lpaste something if you are willing to do that),  but it would seem that the "table" function is still expecting a Char instead of a Text.
01:04:52 <potatoe> lpsmith sure gimme a sec
01:06:02 <lpsmith> Also,  are you sure what you are looking at in your text editor actually corresponds to the code that is generating the error?
01:06:18 <potatoe> lpsmith heres my table definition
01:06:19 <potatoe> http://lpaste.net/150379
01:06:33 <potatoe> I'm kinda wondering why lambdabot doesn't post links here automatically anymore
01:06:39 <potatoe> besides the point but yeah
01:07:19 <JamesJRH> liste: Then why would it affect ‘ï’?
01:07:41 <lpsmith> potatoe, well,  String should also be compatible with postgresql's "text" type.
01:07:52 <lpsmith> Looks ok to me
01:08:52 <lpsmith> potatoe, also this is an option as of postgresql-simple-0.5.1
01:08:57 <lpsmith> http://lpaste.net/150379
01:10:33 <potatoe> lpsmith I'm getting the same error even with deriving Generic
01:10:34 <potatoe> Incompatible {errSQLType = "text", errSQLTableOid = Just (Oid 24831), errSQLField = "email", errHaskellType = "Char", errMessage = ""}
01:11:46 <lpsmith> yeah, it should be the same thing...
01:12:06 <lpsmith> potatoe:   try replacing the fromRow definition with fromRow = undefined
01:12:35 <lpsmith> just to see if the exception does indeed change
01:13:16 <lpsmith> I'm suspicious that your code you think you are editing doesn't quite correspond to the code you are actually running.
01:16:17 <lpsmith> potatoe, or,  do you have a different table that also has a field called "email"?
01:16:17 <potatoe> lpsmith me too, changing it to undefined doesn't do anything, so I'm going to paste the code that calls the first snippet
01:17:07 <lpsmith> It's also possible the exception isn't being raised by the code you think it is.   You can lookup the table oid that's in your exception
01:17:14 <potatoe> http://lpaste.net/150382 lpsmith 
01:18:08 <JamesJRH> So what's the point in the utf8-string package, then, if there's Data.Text.Encoding.encodeUtf8?
01:19:11 <ChristianS> JamesJRH: they are just two different solutions for the same problem
01:19:32 <potatoe> lpsmith looked up the id in postgres, the exception is being thrown for the correct table
01:19:39 <ChristianS> JamesJRH: though utf8-string is much less powerful than Text
01:20:32 <potatoe> lpsmith https://gist.github.com/anonymous/1e49ab5fab646f433e0b
01:20:41 <lpsmith> ok,  yeah,  the issue is there's perhaps a few too many instances for FromRow and FromField
01:20:44 <JamesJRH> ChristianS: I gather that Text is very powerful indeed.
01:21:44 <lpsmith> potatoe, http://lpaste.net/150382
01:22:08 <lpsmith> So you are actually trying to convert all the fields to Char
01:22:40 <lpsmith> there's an instance FromField a => FromRow [a]
01:22:50 <potatoe> oh damn lpsmith I'm sorry, I had changed my select from select * to select status
01:22:58 <potatoe> i mayve reverted it at some point
01:23:19 <lpsmith> ok, well,  then change IO [String] to  IO [Only String]
01:23:51 <JamesJRH> And seeing as the text package is listed under Additional Platform Libraries of the Haskell Platform (https://haskell.org/platform/contents.html ), whereas utf8-string is not listed on that page, I definitely prefer the Data.Text choice.
01:24:05 <lpsmith> (Also, Haskell's very unfortunate decision to have string be a type synonym for [Char] is partially at fault here)
01:25:03 <lpsmith> Anyway,  the confluence of type String = [Char],  instance FromField a => FromRow [a],  and instance FromField Char have all combined to make a rather unfortunate user experience on this count.
01:26:34 <potatoe> lpsmith, how do I go from Only String to String though
01:26:42 <potatoe> No instance for (Data.String.IsString (Only String))
01:27:01 <lpsmith> you can (map fromOnly <$> ...)
01:27:20 <ScoobySnacks> Is there any online tutorials or youtube videos to learn Haskell for someone who doesn't know any programming languages. Every tutorial I've came across just assumes I already know how to program, it's pissing me off... 
01:28:02 <lpsmith> potatoe, https://hackage.haskell.org/package/postgresql-simple-0.5.1.2/docs/Database-PostgreSQL-Simple-Types.html#t:Only
01:30:14 <ScoobySnacks> Well?
01:31:00 <lieven> ScoobySnacks: learn you a haskell
01:31:26 <jle`> LYAH is specifically for people who already know how to program
01:32:02 <ScoobySnacks> tutorial is aimed at people who have experience in imperative programming languages (C, C++, Java
01:32:07 <lieven> really? My impression was it didn't require much previous knowledge.
01:32:52 <jle`> it doesn't require much previous knowledge of functional programming
01:32:56 <ScoobySnacks> Hmm thanks anyway Lieven
01:35:16 <ScoobySnacks> Would it cost allot to hire someone to teach me Haskell as a first lang?
01:36:58 <ggVGc> ScoobySnacks: I think it's pretty instersting to see someone learning haskell as their first language, so if I was better at it I would have offered to tutor you for free
01:37:09 <ggVGc> but my haskell isn't strong enough for that  yet
01:37:36 <Rembane> ScoobySnacks: There are quite good course material online. Lets see if I can find it.
01:38:00 <GK__> hi
01:39:11 <JamesJRH> ScoobySnacks: This is an excellent online resource: https://en.wikibooks.org/wiki/Haskell
01:39:17 <ggVGc> Rembane: a bit different when he doesn't have prior programming experience though
01:40:59 <Rembane> ggVGc: Oh. Hm... that makes things more interesting.
01:41:26 <JamesJRH> ScoobySnacks: Oh, and this is a good place to start: https://tryhaskell.org/
01:41:31 <Rembane> ScoobySnacks: https://github.com/bitemyapp/learnhaskell here's a guide to how to learn Haskell.
01:42:55 * hackagebot werewolf 0.3.0.5 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.3.0.5 (hjwylde)
01:43:28 <JamesJRH> What I remember of Try Haskell definitely doesn't assume prior programming experience.
01:43:46 <ScoobySnacks> Thanks everyone, I'll do my best. I figured I'd learn a functional lang first since I liked the idea of less side effects ect.
01:44:05 <Rembane> ScoobySnacks: And this channel is a quite good place to ask questions in. :)
01:44:07 <Rembane> ScoobySnacks: Good luck!
01:44:25 <ScoobySnacks> Thanks
01:46:59 <JamesJRH> ScoobySnacks: Heh, you may like step 8 of Try Haskell. :-D
01:47:55 * hackagebot werewolf 0.3.1.3 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.3.1.3 (hjwylde)
01:58:09 <JamesJRH> ScoobySnacks: Where are you from roughly? What country/continent.
01:58:32 <ScoobySnacks> US Texas
01:59:09 <JamesJRH> 09:34:53 < ScoobySnacks> Would it cost allot to hire someone to teach me Haskell as a first lang?  ← Probably, but there may be courses that are cheaper than one-to-one tutorship.
01:59:27 <JamesJRH> Okay, I don't know about US.
02:00:37 <ScoobySnacks> Well if not I'll figure it out, it will just take longer and more tinkering.
02:03:03 <ScoobySnacks> I know learning as a first lang will be more difficult but that's irrelevant to me anyway.
02:04:05 <JamesJRH> ScoobySnacks: One other thing is that some university professors are quite interested about how learning declarative/functional languages is different/easier if one has not seen imperative programming first. They may like someone in your situation to volunteer to be part of a study, but I have no idea whether there are actually any such opportunities near you. Just a thought.
02:04:35 <JamesJRH> ScoobySnacks: More difficult? Apparently the contrary.
02:06:09 <JamesJRH> ScoobySnacks: Have a go at Try Haskell and ask me anything that you get stuck on. It doesn't take very long to finish it.
02:06:11 <ScoobySnacks> I'll look into that, thanks for the tip
02:08:38 <liste> > (fromIntegral . ord 'ï') :: Word8
02:08:39 <lambdabot>      Couldn't match expected type ‘Word8’
02:08:40 <lambdabot>                  with actual type ‘a0 -> Integer’
02:08:40 <lambdabot>      In the expression: (fromIntegral . ord '\239') :: Word8    Couldn't matc...
02:08:46 <ScoobySnacks> JamesJRH: If you're on freenode around the same time, I'll take you up on it, I've got to run for now.
02:08:51 <liste> > (fromIntegral (ord 'ï')) :: Word8
02:08:53 <lambdabot>  239
02:09:43 <dsub> ScoobySnacks: Among the online reasorces available, Learn You A Haslkell For Greater Good is frienndly to newcomers and doesn't assume that you know other languages. I recommend it as a start.
02:09:59 <liste> JamesJRH maybe it uses the "i +  ̈" code point pair?
02:10:10 <JamesJRH> ScoobySnacks: My client is always online so I will see anything that you ping me; I'm usually on IRC daily.
02:10:18 <liste> (i + U+0308)
02:11:23 <ScoobySnacks> Awsome, and thanks everyone.
02:15:07 <JamesJRH> liste: My deadkey definitely inserts it as codepoint 239.
02:16:42 <JamesJRH> Note that 255 is ÿ, so where would that be seen?
02:16:46 <JamesJRH> U+FF
02:17:21 <liste> then it's a mystery
02:17:37 <liste> > "ï" :: ByteString
02:17:38 <lambdabot>      Not in scope: type constructor or class ‘ByteString’
02:17:38 <lambdabot>      Perhaps you meant one of these:
02:17:38 <lambdabot>        ‘BSC.ByteString’ (imported from Data.ByteString.Char8),
02:18:01 * hackagebot werewolf 0.3.2.0 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.3.2.0 (hjwylde)
02:18:19 <liste> Prelude Data.ByteString> "ï" :: ByteString
02:18:29 <liste> that resulted in "\239"
02:18:34 <JamesJRH> > 1 + 1
02:19:17 <JamesJRH> Seriously, why?!
02:19:42 <liste> works in privmsg
02:19:54 <JamesJRH> Doesn't for me.
02:22:58 <fr33domlover> Q: Suppose I have 2 functions of type "a -> Maybe b" and I'd like to say "try the first one, if returns Nothing then try the second one". Is there an idiom/function to do this other than using 'case' or 'maybe' or 'fromMaybe' etc.?
02:23:28 <JamesJRH> fr33domlover: Yes.
02:23:30 <fr33domlover> perhaps f <|> g?
02:23:38 <fr33domlover> oh right, i didn't try <|>
02:23:47 <fr33domlover> lol @ myself
02:24:00 <JamesJRH> :-)
02:25:03 <frerich> fr33domlover: I think a good solution would be to just define 'Nothing' because a function of type 'a -> Maybe b' can always only yield 'Nothing'. So trying Nothing and then Nothing would be... Nothing. :o)
02:25:48 <JamesJRH> ggVGc: Hi, btw.. :-) Nice to see you in here.
02:27:04 <fr33domlover> frerich, not sure what you mean
02:27:31 <fr33domlover> anyway looks like <|> is exactly what I need
02:27:41 <JamesJRH> ggVGc: Not sure whether I mentioned it to you while I was in #vim a while ago that I intend to install and start exploring Yi Editor but at the time it was failing to build for me on NixOS… I now have it installed! :-)
02:27:46 <fr33domlover> > Nothing <|> Just 4
02:27:47 <lambdabot>  Just 4
02:28:10 <JamesJRH> ggVGc: I haven't looked at it much yet though.
02:28:21 <jle`> fr33domlover: there's also asum [x,y,z] = x <|> y <|> z
02:28:31 <jle`> but yeah, if you just have two, that works
02:29:39 <JamesJRH> Nice. :-)
02:29:56 <fr33domlover> jle`, thanks
02:30:04 <fr33domlover> indeed i have just 2 this time
02:32:52 <JamesJRH> liste: So remind me, what was it that you expected to happen re. the 255 truncation? Can you give an example that would demonstrate it?
02:33:39 <JamesJRH> Hmm, I have an idea…
02:34:51 <liste> JamesJRH "怩" :: ByteString yields ")"
02:35:04 <liste> Prelude Data.Text Data.ByteString> "怩" :: ByteString
02:35:04 <liste> ")"
02:35:17 <liste> that gets even more weird :D
02:35:56 <liste> maybe the behaviour is different between versions
02:35:58 <JamesJRH> Prelude> Data.ByteString.Base64.decode $ Data.ByteString.Base64.encode $ Data.String.fromString "naïve"
02:36:01 <JamesJRH> Right "na\239ve"
02:36:04 <JamesJRH> Prelude> Data.ByteString.Base64.decode $ Data.ByteString.Base64.encode $ Data.Text.Encoding.encodeUtf8 $ Data.Text.pack "naïve"
02:36:07 <JamesJRH> Right "na\195\175ve"
02:36:31 <JamesJRH> Decoding it again helps to see what has actually happened.
02:37:26 <liste> so encodeUtf8 produces NFD?
02:38:54 <JamesJRH> Or just not encoding it:
02:38:54 <JamesJRH> Prelude> Data.String.fromString "naïve" :: Data.ByteString.Internal.ByteString
02:38:54 <JamesJRH> "na\239ve"
02:38:54 <JamesJRH> Prelude> Data.Text.Encoding.encodeUtf8 $ Data.Text.pack "naïve"
02:38:54 <JamesJRH> "na\195\175ve"
02:39:11 <liste> but "怩" -> ")" boggles the mind
02:39:24 <JamesJRH> Lol!
02:39:35 <liste> > (fromIntegral (ord '怩')) :: Word8
02:39:37 <lambdabot>  41
02:39:42 <liste> that explains it
02:39:50 <liste> it takes the least significant 8 bits
02:40:39 <JamesJRH> Right, I was going to suggest that.
02:40:47 <liste> now I get it
02:41:07 <liste> the result Python gives is actually base64 of NFD form of the string
02:41:30 <JamesJRH> As in: Prelude> mod 24617 256
02:41:30 <JamesJRH> 41
02:41:31 <frerich> fr33domlover: I was just being cheeky - you wrote that 'I have 2 functions of type "a -> Maybe b"'. If you ignore bottm, there is only one possible definition for that function: 'const Nothing'. So you would end up with 'Nothing <|> Nothing'. So you always get 'Nothing'. :-]
02:41:46 <JamesJRH> NFD?
02:42:07 <liste> Unicode canonical decomposition
02:42:16 <liste> so both base64's were correct
02:42:33 <liste> the one Python and Text give is for NFD
02:42:45 <JamesJRH> What does ‘NFD’ stand for?
02:43:13 <liste> nfd = normalization form d = unicode canonical decomposition normal form
02:43:34 <JamesJRH> Oh, never heard of that.
02:43:41 <liste> and the one using just ByteString and Base64.encode is for NFC
02:43:52 <JamesJRH> Oh.
02:44:00 <Gurkenglas> How would f <|> g work? Wouldn't you need liftA2 (<|>) f g?
02:44:18 <liste> (nfc = canonical decomposition followed by canonical composition)
02:44:33 <liste> http://www.unicode.org/reports/tr15/#Norm_Forms
02:45:08 <liste> which one is usually used in base64?
02:45:29 <liste> (or hashing, for example)
02:48:31 <liste> though it only worked in this case because ï happens to be < '\255'
02:55:42 <JamesJRH> liste: I'm not sure why you think that normal form is relevant here.
02:56:59 <JamesJRH> 10:41:54 < liste> so both base64's were correct  ← Also, I don't agree. ‘Data.String.fromString’ is wrong beyond 255.
02:57:08 <fr33domlover> frerich, hmm really? Let's see, maybe I'm just missing the obvious :) Suppose we have this: let f n = if n == 5 then Just (show n) else Nothing
02:57:27 <fr33domlover> and then we have function g which is the same buw tih 4 instead of 4
02:57:30 <liste> JamesJRH I just mean that "na\239ve" and "na\195\175ve" are both just as correct
02:57:50 <liste> and they both convert to base64 correctly (in this case)
02:57:50 <fr33domlover> frerich, then "h n = g n <|> f n
02:57:55 <fr33domlover> is not const Nothing
02:58:08 <JamesJRH> The latter is only correct as a UTF-8 bytestring.
02:58:39 <Geraldus__> hi friends!
02:58:42 <JamesJRH> liste: They convert to different base 64.
02:59:11 <orb> Is anyone familiar with session types?
03:00:39 <liste> JamesJRH yes, both convert to different, but correct, base64's (when converted to UTF-8 properly)
03:00:51 <ggVGc> JamesJRH: hey :) Yeah, I've been meaning to check out yi too, but haven't yet
03:01:04 <ggVGc> think I'm pretty stuck with vim for the forseeable future
03:01:10 <liste> fromString "naïve" doesn't produce UTF-8 though
03:01:12 <fr33domlover> > let { mk m n = if n == m then Just (show n) else Nothing; f = mk 4; g = mk 5, h n = g n <|> f n; } ; h 5
03:01:13 <lambdabot>  <hint>:1:77: parse error on input ‘,’
03:01:19 <fr33domlover> > let { mk m n = if n == m then Just (show n) else Nothing; f = mk 4; g = mk 5; h n = g n <|> f n; } ; h 5
03:01:21 <lambdabot>  <hint>:1:100: parse error on input ‘;’
03:01:39 <fr33domlover> > let { mk m n = if n == m then Just (show n) else Nothing; f = mk 4; g = mk 5; h n = g n <|> f n } ; h 5
03:01:41 <lambdabot>  <hint>:1:99: parse error on input ‘;’
03:01:48 <fr33domlover> ok i'll stop spamming :P
03:02:07 <fr33domlover> > let { mk m n = if n == m then Just (show n) else Nothing; f = mk 4; g = mk 5; h n = g n <|> f n ; } in h 5
03:02:09 <lambdabot>  Just "5"
03:02:15 <fr33domlover> frerich, ^
03:02:25 <fr33domlover> it doesn't always return Nothing
03:02:48 <JamesJRH> liste: This may help: https://en.wikipedia.org/wiki/UTF-8#Description
03:03:32 <liste> JamesJRH yep, and that's why using the IsString instance of ByteString doesn't work
03:04:33 <JamesJRH> Character from U+0080 onwards are not represented by a single byte, so ‘\239’ (as a byte) is not a valid UTF-8 character.
03:04:40 <JamesJRH> Characters*
03:04:49 <liste> but as an Unicode character it is
03:05:06 <JamesJRH> But they are *bytestring*. ;-)
03:05:13 <JamesJRH> bytestrings*
03:05:48 <liste> is it ok to /q?
03:05:49 <JamesJRH> "na\239ve" as a bytestring is not valid Unicode.
03:06:29 <JamesJRH> liste: What? Quit IRC?
03:06:36 <liste>  /query
03:06:48 <liste> aka privmsg
03:07:05 <JamesJRH> Oh, that's /msg.
03:07:14 <liste> or /q
03:07:37 <JamesJRH> Query is a slightly different thing. It doesn't create a new window.
03:07:38 <zv> you just zählen vertauschen
03:07:46 <zv> oops, sorry about that, wrong channel
03:07:54 <JamesJRH> I think that it uses the status window or somthing.
03:09:00 <Gurkenglas> http://lpaste.net/1137723792894722048 <- Does someone see a way to express phi probably using Cofree?
03:09:53 <jophish> I can't help but feel that this is a clumsy and there's a much neater way of doing things: http://lpaste.net/150391
03:10:05 <jophish> It smells a little but of unfoldM
03:10:20 <jophish> I should probably be using pipes or conduit
03:10:20 <JamesJRH> liste: Yes, it is okay to PM, but for something public it is better here so that others can learn the outcome too.
03:10:31 <liste> ok, I'll do it here then
03:13:00 <Gurkenglas> jophish, http://lpaste.net/150391
03:13:31 <Heather> can I create something alike do but with custom rules, I need simple example
03:14:25 <Gurkenglas> :t iterateWhile -- jophish
03:14:26 <lambdabot> Monad m => (a -> Bool) -> m a -> m a
03:15:57 <Gurkenglas> :exf "Monad m => (a -> m ()) -> (a -> m a)" -- Although you'd also need this
03:16:00 <exferenceBot> \ f1 b -> f1 b >> pure b
03:17:50 <Gurkenglas> Oh wait you're checking for justice already my annotation is stupid :D
03:18:17 <JamesJRH> liste: ASCII characters are the only codepoints that are the same as either a normal character String or a UTF-8 -encoded ByteString.
03:18:19 <Gurkenglas> http://lpaste.net/150392
03:19:05 <Gurkenglas> Although that does terminate half a step early; is it important that the last frame put is Nothing, jophish?
03:21:12 <liste> JamesJRH, yeah, you're correct. I confused it with "mot\x308orhead" <-> "motörhead"
03:21:35 <liste> which are two strings which mean the same thing but result in different utf8
03:21:47 <liste> and different base64
03:22:15 <liste> they look different on my terminal, though"
03:31:10 <Gurkenglas> lyxia, managed to replace the anonymous recursion scheme with a function that ought to be in the Cofree library anyway :D http://lpaste.net/1137723792894722048
03:37:15 <JamesJRH> liste: Indeed, the normal forms are an independent factor. To summarise:
03:37:17 <JamesJRH> Prelude> Data.Text.Encoding.encodeUtf8 $ Data.Text.pack "naïve"  -- Correct (Normalisation Form C) UTF-8 -encoded ByteString.
03:37:21 <JamesJRH> "na\195\175ve"
03:37:23 <JamesJRH> Prelude> Data.String.fromString "naïve" :: Data.ByteString.Internal.ByteString  -- "na\239ve" is correct as a (Normalisation Form C) Unicode character String but, as a ByteString, is not valid UTF-8.
03:37:27 <JamesJRH> "na\239ve"
03:37:30 <JamesJRH> Prelude> Data.Text.Encoding.encodeUtf8 $ Data.Text.pack "naïve"  -- Correct (Normalisation Form D) UTF-8 -encoded ByteString.
03:37:33 <JamesJRH> "nai\204\136ve"
03:37:35 <JamesJRH> Prelude> Data.String.fromString "naïve" :: Data.ByteString.Internal.ByteString  -- The U+0308 COMBINING DIAERESIS character (as used in Normalisation Form D) is incorrectly truncated to the BACKSPACE control character (U+0008 <control>).
03:37:39 <JamesJRH> "nai\bve"
03:38:59 <kstt> is there a function to map and filter in one definition ? I want to filter a single constructor and map to extract its associated value. Thx
03:39:04 <JamesJRH> Note that due to the ‘\b’, printing "nai\bve" should appear as: nave
03:39:59 <liste> kstt that's quite convenient with list comprehensions
03:40:18 <jophish> Gurkenglas: Thanks! It is important that the last frame put is Nothing, but I can always do that after the loop myself
03:40:42 <liste> > [x | y <- [Just 4, Just 8, Nothing, Just 4, Just 12], x <- Just y]
03:40:44 <lambdabot>      Couldn't match expected type ‘[t]’
03:40:44 <lambdabot>                  with actual type ‘Maybe (Maybe Integer)’
03:40:44 <lambdabot>      In the expression: Just y
03:40:56 <liste> > [x | y <- [Just 4, Just 8, Nothing, Just 4, Just 12], Just x <- y]
03:40:57 <lambdabot>      Couldn't match expected type ‘[Maybe t]’
03:40:57 <lambdabot>                  with actual type ‘Maybe Integer’
03:40:57 <lambdabot>      In the expression: y
03:41:04 <liste> that way
03:41:27 <kstt> liste: ah, yes. I don't use them anymore, don't know why.
03:41:45 <kstt> thank you
03:42:51 <kstt> Ah yes I remember, I'm uneasy with the notion of failure, need to check that.
03:43:05 <liste> "[x | (Just x) <- [Just 4, Just 8, Nothing, Just 4, Just 12]]" is the right way
03:43:51 <liste> yeah, Monad's `fail' is controversial
03:45:56 <kstt> Okay, I have no opinion, but just can't figure clearly how it works in my head.
03:51:56 <JamesJRH> Is there a toString or a fromByteString function? I can't find one.
03:52:47 <kstt> JamesJRH: which bytestring flavor ?
03:53:01 <JamesJRH> Data.ByteString.Internal.ByteString
03:53:38 <kstt> Internal really ?
03:53:43 <JamesJRH> It seems to me that it should be the other way around – there should be a toString there but not a fromString: http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-String.html#v:fromString
03:53:44 <kstt> What do you import ?
03:55:26 <JamesJRH> Because fromString is a badly-defined function whereas going the other way should be okay for some things.
03:55:44 <JamesJRH> kstt: Data.ByteString
03:56:26 <kstt> If you map to/from strings, use the  Char8 variant.
03:56:50 <kstt> Use the pack/unpack functions
03:56:50 <dramforever> the fromString is the same iirc
03:56:51 <merijn> JamesJRH: You want Data.Text.Encoding to decode ByteString to Text and then use Text.unpack to go from Text to String
03:57:25 <JamesJRH> merijn: I see. Okay…
03:57:49 <kstt> Note that ByteString is not "an alternative data type for String".
03:58:03 <Wizek> What options do I have to share values between do blocks? I've tried this, and it fails to compile: https://gist.github.com/Wizek/06961965837b1d5bdca4 :12:9: Not in scope: ‘a’. The one thing I can think of is making `handler` a function of `a`. But unfortunately that is not quite an option for me, because I don't think I can modify those APIs of the library that I am using. Any other options?
03:58:36 <JamesJRH> kstt: Indeed. Just as bytes are not an alternative data type for characters.
03:58:51 <kstt> Wizek: function parameters are the way to share values
04:02:38 <JamesJRH> merijn: I basically just wanted to print the last expression that I listed above, but putStrLn takes a String.
04:04:07 <merijn> JamesJRH: ByteString has a putStrLn for ByteString, afaik?
04:04:37 <merijn> Data.ByteString.putStrLn :p
04:04:43 <JamesJRH> I'm not sure that decoding is the right thing as it requires a choice of encoding. I literally want to print "nai\bve" :: Data.ByteString.Internal.ByteString to demonstrate the above point.
04:04:51 <JamesJRH> Oh!
04:04:53 <JamesJRH> Haha!
04:05:47 <marrrk> Can you help me get ghc-mod to work. Right now I am getting: cannot satisfy -package-id HTTP-4000.2.22-abbb2efaa16aa63b4db5f093a8874946 
04:06:16 <dsub> What parser library are you peaple using? In Real World Haskell they seem to put emphasis on Parsec. The book is 8 years old thou...
04:07:15 <frerich> dsub: It's still a pretty good choice for many things!
04:08:03 <merijn> dsub: Parsec is still reasonable, there's megaparsec (which focuses on being a new/improved parsec), attoparsec (efficiency over helpful errors, probably what you want for parsing network protocols/binary files), and trifecta (nice errors, but tricky to get going with)
04:08:13 <JamesJRH> merijn: So yeah, here's what I wanted to demonstrate:
04:08:13 <JamesJRH> Prelude> Data.String.fromString "naïve" :: Data.ByteString.Internal.ByteString  -- The U+0308 COMBINING DIAERESIS character (as used in Normalisation Form D) is incorrectly truncated to the BACKSPACE control character (U+0008 <control>).
04:08:18 <JamesJRH> "nai\bve"
04:08:18 <frerich> dsub: There is also attoparsec (fast, nice for binary formats), trifecta (nice error messages) and megaparsec (parsec++ basically)
04:08:20 <JamesJRH> Prelude> Data.ByteString.putStrLn $ Data.String.fromString "naïve"
04:08:23 <JamesJRH> nave
04:08:26 <JamesJRH> :-)
04:08:57 <merijn> dsub: Note that parsec has been updated a bit since the book, so not every single code sample still works. However, reading the RWH chapter should get you understanding the general idea enough to be able to use it from just the docs
04:08:59 <geekosaur> we do expect that megaparsec will be merged back into parsec, though. Note that parsec has had a major rev since RWH
04:09:27 <pavonia> In what way is megaparsec an improvment?
04:09:29 <merijn> JamesJRH: It's not
04:09:46 <fr33domlover> JamesJRH, bytestring is byte-based, if anyone wans utf8 there's a utf8-string package or some similar name, i don't remember but i use it often :P
04:09:48 <merijn> JamesJRH: The OverloadedStrings instance for ByteString explicitly truncates every character
04:10:17 <movedx> http://begriffs.com/posts/2016-01-20-ihaskell-notebook.html
04:10:29 <merijn> JamesJRH: This is why it's hidden away in Data.ByteString.Char8 and why you're doing everything completely wrong if you ever use ByteString.Char8
04:10:33 <JamesJRH> fr33domlover: I'm sorted, see above.
04:10:44 <merijn> JamesJRH: https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
04:10:45 <dsub> Hmm... Binary formats is not an issue for me as all i'm parsing are utf/ascii. I find Parsec to be very powerful (from what I understand) but quite "over the top" for me as i'm not doing any complicated parsing. I end up writing my own parsers, but thats kind of an ugly work around I feel...
04:10:52 <JamesJRH> 11:36:54 < JamesJRH> Prelude> Data.Text.Encoding.encodeUtf8 $ Data.Text.pack "naïve"  -- Correct (Normalisation Form C) UTF-8 -encoded ByteString.
04:10:56 <JamesJRH> 11:36:54 < JamesJRH> "na\195\175ve"
04:11:35 <merijn> pavonia: Modernising interface, better errors, stripping out the custom operators that have been superceded by Applicative
04:11:58 <merijn> pavonia: Parsec exports it's own versions of the Applicative/Alternative operators because it predates Applicative and those collide with the real ones
04:12:17 <merijn> dsub: What do you mean "I end up writing my own parsers"?
04:12:25 <quchen> And Parsec is unmaintained so that won't ever change.
04:12:53 <JamesJRH> fr33domlover: Also, package text is more likely installed than package utf8-string. I'm using text elsewhere anyway and it is listed as part of the Haskell Platform: https://haskell.org/platform/contents.html
04:13:04 <JamesJRH> 12:09:06 < merijn> JamesJRH: It's not  ← What's not?
04:13:14 <merijn> JamesJRH: It's not "wrongly truncated"
04:13:40 <JamesJRH> It is if what you're after is UTF-8.
04:13:43 <merijn> JamesJRH: See my earlier link
04:13:44 <dsub> merijn: I write some ErrorT (State st) transformer for parsing, but thats mainly because I'be never really learned Parsec (or any other lib), hence I want to get pointed in a good direction for what library to study.
04:14:18 <merijn> JamesJRH: OverloadedStrings for ByteString is *not* utf8, but since quchen helpfull has summarised my rant on this on github, you canr ead it there :D
04:15:01 <merijn> dsub: Parsec has it's own state and error types, but most of the other libraries (e.g. attoparsec/trifecta) explicitly rely on you using StateT/ErrorT like that :)
04:15:12 <tdammers> I'll join your rant, because it's totally and utterly wrong
04:15:27 <merijn> dsub: As for "how it works" parsec basically has a state monad builtin to it
04:16:06 <merijn> dsub: Looks like megaparsec comes with MonadState, MonadReader, and MonadError instances
04:16:10 <JamesJRH> merijn: I don't know what Char8 is about and seems like a crazy idea to me. Also, fromString is a crazy idea seeing as it just silently truncates, as liste pointed-out earlier: https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/src/Data.ByteString.Internal.html#c2w
04:16:23 <merijn> JamesJRH: DId you read the link I posted?
04:16:55 <dsub> Aah, sounds like going to attoparsec might be a good choice then, thx. Trifecta? How many different general parser are there?? 
04:17:15 <JamesJRH> The truncation is effectively a trivial encoding which is usually not the right thing.
04:17:17 <merijn> dsub: The only one with significant usage I'm aware of are parsec/attoparsec/trifecta
04:17:19 <tdammers> Char8 is about supporting the Unix illusion that says "a byte and a character are the same thing" as far as possible while keeping the breakage to an arguable minimum
04:17:30 <merijn> I disagree
04:17:33 <merijn> Char8 is about one thing
04:17:45 <merijn> Making it easy to write literals for ASCII network protocols in your code
04:17:51 <JamesJRH> merijn: It's about Char8.
04:17:58 <tdammers> should be named Char7 then
04:18:14 <merijn> i.e. SMTP wants me to send "HELO" as command and I don't want to write that in numerics
04:18:31 <ChristianS> tdammers: strictly speaking, char8 is latin1
04:18:38 <merijn> Any other use case of Char8 is wrong, use Data.Text.Encoding
04:19:59 <merijn> 'encodeUtf8 "Naïve"' works perfectly fine with OverloadedStrings
04:20:23 <JamesJRH> 12:13:55 < merijn> JamesJRH: OverloadedStrings for ByteString is *not* utf8, but since quchen helpfull has summarised my rant on this on github, you canr ead it there :D  ← I'm not using OverloadedStrings; I specifically wanted to avoid the ‘-XOverloadedStrings’ option.
04:20:42 <dsub> merijn: ok, thx. 
04:21:04 <merijn> JamesJRH: You're using Data.String.fromString, that's literally identical to OverloadedStrings
04:21:19 <merijn> JamesJRH: OverloadedStrings replaces string literals with 'fromString "literal"'
04:21:26 <JamesJRH> I'm *not* using Data.String.fromString.
04:21:47 <JamesJRH> I was talking about it.
04:22:12 <merijn> ok, I just saw "Prelude> Data.String.fromString "naïve" :: Data.ByteString.Internal.ByteString"
04:24:04 <merijn> Then I'm unsure what the problem is?
04:24:18 <JamesJRH> Yes, that was demonstrating 1 of 2 different ways to get from Unicode to a ByteString (and 4 because of NFC/NFD). This is what I'm actually using:
04:24:21 <JamesJRH> 11:36:54 < JamesJRH> Prelude> Data.Text.Encoding.encodeUtf8 $ Data.Text.pack "naïve"  -- Correct (Normalisation Form C) UTF-8 -encoded ByteString.
04:24:24 <JamesJRH> 11:36:54 < JamesJRH> "na\195\175ve"
04:24:47 <JamesJRH> 12:23:41 < merijn> Then I'm unsure what the problem is?  ← You arrived at the summary; there is nolonger any problem. ;-)
04:26:00 <JamesJRH> I've now got the hang of the base 64 and ByteString thing I think. So to go back to that…
04:32:15 <JamesJRH> Okay, found them in the scrollback. To summarise:
04:32:17 <JamesJRH> 08:45:24 < JamesJRH> This also works: Prelude> Data.ByteString.Base64.encode $ Data.String.fromString "naïve"  -- This one is incorrect.
04:32:20 <JamesJRH> 08:45:24 < JamesJRH> "bmHvdmU="
04:32:23 <JamesJRH> 09:02:00 < JamesJRH> Prelude> Data.ByteString.Base64.encode $ Data.Text.Encoding.encodeUtf8 $ Data.Text.pack "naïve"  -- Whereas this is the correct one.
04:32:26 <JamesJRH> 09:02:00 < JamesJRH> "bmHDr3Zl"
04:33:42 <JamesJRH> And ‘bmHDr3Zl’ is the one that agrees with Python:
04:33:42 <JamesJRH> 08:46:50 < JamesJRH> >>> "naïve".encode("base64")
04:33:43 <JamesJRH> 08:46:50 < JamesJRH> 'bmHDr3Zl\n'
04:35:02 <liste> yeah. bytestring-base64 + utf-8-string or text: good. bytestring-base64 + plain bytestring: bad
04:35:18 <liste> utf8-string*
04:35:41 <JamesJRH> That's for NFC, there is also a correct answer for other Unicode Normalisation Forms, but "bmHvdmU=" is not correct in any Normalisation Form.
04:36:30 <bartavelle> yeah, this is the latin1 encoding I think
04:37:27 <bartavelle> it is
04:37:46 <JamesJRH> Okay, now to play around more with System.Random…
04:41:23 <JamesJRH> So far I've only done: System.Random.randomIO :: IO Int
04:42:32 <JamesJRH> So I guess if I wanted a random ByteString of a given length I'd have to pack a list of random word8's…
04:51:43 <bartavelle> JamesJRH, yes
04:52:19 <bartavelle> you can get an arbitrary [Word8] with QuickCheck though
04:52:44 <Xandaros> There is a "Nat" kind in GHC.TypeLiterals, which, as the module name suggests, allows you to use literals in type expressions. However, the Nat kind in type-natural seems like it has more infrastructure around it, provides proofs you can use and has its implementation exposed. Is it in any way possible to get literals like that for a custom kind? (Without ridiculous quasiquotes)
04:53:50 <merijn> Xandaros: What does "literals like that" mean?
04:54:05 <merijn> Xandaros: You mean can I write "2" and get the power of "type-natural"?
04:54:13 <Xandaros> basically, yes
04:54:42 <merijn> Xandaros: No, note that people are working on hacking that kind of proofs/infrastructure for Nat into GHC, though
04:54:52 <merijn> Xandaros: It's just not finished yet
04:55:49 <JamesJRH> bartavelle: So far I have this: Prelude> sequence $ replicate 16 (System.Random.randomIO :: IO Data.Word.Word8)
04:55:52 <JamesJRH> [53,69,154,14,185,147,11,185,201,56,74,35,161,20,59,177]
04:56:02 <Xandaros> Hmm, I see. But even if they provide lots of proofs, I somehow doubt they can provide a proof for any property you can think of. The fact that the Nat in base does not expose its constructors is troubling me
04:56:05 <diggle> I want to set stack to get packages off hackage, instead of stackage, so I can play around with packages in a playground project thing. help?
04:56:08 <Xandaros> s/its/any
04:56:20 <JamesJRH> And am now trying to determine how to Data.ByteString.pack that.
04:57:33 <pavonia> JamesJRH: Maybe you're looking for fmap?
04:58:28 <exio4> Xandaros: it's quite hard to prove things on your own when you don't get minimal properties guaranteed by the compiler
04:59:35 <exio4> Xandaros: like, given (a + b) = (b + a) ; (a + b) + c = a + (b + c) ; you could prove (a + b + c) = (c + b + a)
05:00:23 <exio4> or things like the injectivity of type S x = 1 + x
05:00:23 <potatoe> sorry I know this is a really beginner question but to generate tables in Blaze.Html you have to do this http://lpaste.net/150404
05:00:28 <potatoe> how do I do this the functional way
05:01:01 <aweinstock> :t [(sequence .) . replicate, replicateM]
05:01:01 <JamesJRH> pavonia: Maybe. I was trying with (=<<) which is an fmap and a join, so I'm close…
05:01:02 <lambdabot> Monad m => [Int -> m a -> m [a]]
05:01:12 <dramforever> :t mapM_
05:01:13 <aweinstock> JamesJRH: ^ replicateM is simpler
05:01:13 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
05:01:46 <aweinstock> :t replicateM 16 System.Random.randomIO
05:01:47 <lambdabot> Random a => IO [a]
05:01:54 <merijn> Xandaros: Nat in base doesn't expose constructors because it will map to proper integers instead of peano naturals
05:01:57 <pavonia> JamesJRH: But pack doesn't return an IO action, so no join is needed
05:01:58 <frerich> JamesJRH: Instead of 'sequence $ replicate' you can say 'replicateM'. And Data.ByteString has a 'pack' function. So you could use 'pack <$> replicateM 16 (randomIO :: IO Data.Word.Word8)
05:02:07 <Xandaros> exio4: Hmm, I see. If you have enough properties at your disposal, you might not need constructors
05:02:20 <merijn> Xandaros: The long term plan is to basically integrate a SAT solver with GHC and solve numeric constraints that way
05:02:30 <dramforever> potatoe: try something like table $ table $ mapM_ td [".foo", ".bar", ".baz"]
05:02:42 <potatoe> okay thanks!
05:02:48 <dramforever> higher order functions are your friend :)
05:02:59 <Xandaros> merijn: That is interesting. If I ever have the time I might get involved in that :D
05:03:13 <frerich> JamesJRH: In fact, once you use 'pack', you don't need to explicitely say 'IO Data.Word.Word8' anymore. The compiler can infer that you want Word8 because that's what pack wants.
05:03:25 <merijn> Xandaros: Might wanna lurk on the ghc-devs/#ghc to keep in touch with this sorta discussion :)
05:03:56 <Xandaros> I'm actually subscribed to ghc-devs - just never read it :D
05:04:01 <merijn> Xandaros: I just scan the email traffic there to see if any subject catch my fancy :)
05:04:31 <Xandaros> But I just joined #ghc. Can't hurt to lurk there, I guess :D
05:04:34 <merijn> JamesJRH: You could also use "randoms" together with "pack . take 100" to create a BS :)
05:05:29 <merijn> randoms just produce a lazy infinite sequence of values
05:05:52 <merijn> But yeah, "pack <$> replicateM 16 randomIO" should work too
05:05:55 <JamesJRH> pavonia: Lol!, not quite right here:
05:05:56 <JamesJRH> Prelude> fmap (Data.ByteString.pack . replicate 16) (System.Random.randomIO :: IO Data.Word.Word8)
05:05:59 <JamesJRH> "4444444444444444"
05:05:59 <JamesJRH> :-]
05:06:23 <merijn> JamesJRH: That generates one random number and replicates that :p
05:06:28 <merijn> You need replicateM
05:07:02 <JamesJRH> Unless RFC 1149.5, that is. :-P
05:07:23 <JamesJRH> https://xkcd.com/221/
05:07:43 <merijn> λ Data.ByteString.pack <$> replicateM 16 System.Random.randomIO
05:07:43 <merijn> "\217#\168v\CANz\206\245\154\191\193\NAK e\137\179"
05:07:44 <frerich> You could also be fancy and define 'times = replicateM' and then write '100 `times` randomIO' :o)
05:08:13 <dramforever> frerich: welcome, to Ruby :)
05:08:20 <exio4> merijn: have you played with GHC8's TypeInType?
05:08:28 <merijn> exio4: Nope, haven't had time
05:08:39 <Xandaros> exio4: Have you?
05:08:40 <merijn> In fact, I should really quit irssi and start writing :p
05:08:57 <exio4> I haven't, waiting a little bit more =)
05:09:52 <Xandaros> I'm going to wait till its release. Deadline for my bachelor's thesis is the 15.2., which, afaik, is the release date of 8.0, isn't it? :D
05:11:14 <badmash> hello there
05:11:21 <exio4> Xandaros: heh, just in time!
05:11:24 <liste> hello badmash
05:12:29 <badmash> i have a piece of quicksort code where i tried using 2 different split functions, and thhey seem to differ in how fast the quicksort runs
05:12:45 <badmash> the code is at http://lpaste.net/150403
05:14:03 <badmash> i would like to know why using split' gets the sort done in ~ 1.7 secs vs ~ 16 secs if i used split instead
05:14:25 <JamesJRH> Oh, I got so close when I first tried fmap, but I'd dropped the sequence. Now I understand:
05:14:27 <badmash> split and split' seem almost identical
05:14:28 <JamesJRH> Prelude> fmap Data.ByteString.pack (sequence $ replicate 16 (System.Random.randomIO :: IO Data.Word.Word8))
05:14:31 <JamesJRH> "\150=h\145\&0\231\136\236\240\244$A\251\243\164\DLE"
05:14:36 <JamesJRH> Now to simplify…
05:14:48 <badmash> appreciate any help
05:15:30 <JamesJRH>     Not in scope: ‘replicateM’
05:16:33 <mauke`> badmash: one difference is that split' is tail recursive, i.e. it can't produce results lazily
05:17:28 <badmash> mauke: i ran split and split' outside qsort, and they give identical run times
05:17:32 <JamesJRH> 13:01:36 < frerich> JamesJRH: Instead of 'sequence $ replicate' you can say 'replicateM'. And Data.ByteString has a 'pack' function. So you could use 'pack <$> replicateM 16 (randomIO :: IO Data.Word.Word8)  ← Is replicateM like (sequence . replicate)? Also, I already mentioned Data.ByteString.pack.
05:17:42 <frerich> JamesJRH: Right.
05:17:54 <JamesJRH> And <$> is `fmap`, right.
05:18:11 <mauke`> badmash: doesn't split' reverse the lists each time?
05:18:14 <aweinstock> replicateM = (sequence .) . replicate
05:18:30 <JamesJRH> Oh.
05:18:41 <JamesJRH> Where do I import it from though?
05:18:44 <badmash> mauke`: no, it just uses an accumulator
05:18:55 <frerich> JamesJRH: I'm sure Hoogle or Hayoo can tell you :-)
05:19:01 <geekosaur> @index replicateM
05:19:01 <lambdabot> Control.Monad, Data.Sequence
05:19:29 <badmash> mauke`: plus, i thought tail recursion matters little in GHC
05:19:42 <mauke`> > let split' p xs = sep xs [] [] where sep [] ps qs = (ps, qs); sep (o:os) ps qs | o < p = sep os (o:ps) qs | otherwise = sep os ps (o:qs) in split' 3 [1 .. 10]
05:19:43 <badmash> mauke`: i thought GHC doesn't do TCO
05:19:44 <lambdabot>  ([2,1],[10,9,8,7,6,5,4,3])
05:19:51 <mauke`> badmash: it reverses the lists
05:19:54 <JamesJRH> aweinstock: Indeed Prelude> fmap Data.ByteString.pack (((sequence .) . replicate) 16 (System.Random.randomIO :: IO Data.Word.Word8))
05:19:57 <JamesJRH> "\195\213Q\180\FS\149\SUB\227\247K*pl\147G\DC2"
05:20:07 <JamesJRH> Oops.
05:20:39 <badmash> mauke`: ok, but how does that relate to the performance of qsort?
05:20:41 <JamesJRH> aweinstock: Indeed (sequence . replicate) does not work but this does:
05:20:42 <JamesJRH> Prelude> fmap Data.ByteString.pack (((sequence .) . replicate) 16 (System.Random.randomIO :: IO Data.Word.Word8))
05:20:45 <JamesJRH> "\195\213Q\180\FS\149\SUB\227\247K*pl\147G\DC2"
05:21:27 <mauke`> badmash: qsort hits its worst case if the pivot leads to an uneven split, especially if one side is empty
05:21:41 <mauke`> you're sorting a descending list
05:21:50 <mauke`> you always choose the first element as the pivot
05:21:53 <JamesJRH> 13:18:32 < frerich> JamesJRH: I'm sure Hoogle or Hayoo can tell you :-)  ← I use Hoogle a lot but I'd like to know if there's a similar offline method of discovering things that I'd normally use Hoogle for for when I have poor Internet access.
05:22:10 <mauke`> with split, you keep the original order of elements
05:22:11 <liste> JamesJRH you can download the Hoogle database
05:22:16 <badmash> mauke`: correct, but we are testing qsort with the same input, both for split and split'
05:22:19 <mauke`> that means you're guaranteed to hit the worst case at each step
05:22:35 <liste> JamesJRH run "hoogle data --help"
05:22:43 <JamesJRH> Hoogle says Control.Monad or Data.Sequence.
05:22:45 <mauke`> hmm
05:23:06 <badmash> mauke`: so my question is, why does the *worst case time* differ when we use split' instead of split?
05:23:06 <aweinstock> JamesJRH: that's sort of a general idiom for composing multiple-argument functions: ((f . g) x = f (g  x)), and (((f .) . g) x y = f (g x y)
05:23:07 <potatoe> has anyone obtained the keys from Aesons internal representation of Value?
05:23:14 <JamesJRH> liste: Yes, that's the thing that I was thinking of. I was vaguely aware of it and it sounds awesome!
05:23:16 <potatoe> it seems like it is a hashmap inside but I can't access it
05:23:51 <mauke`> no, I can't actually explain it. I'd have to visualize the steps somehow
05:24:00 <OverCoder> Say I had this function http://p.samuraimanpurse.com/jNjhxYSb.txt , what is $ doing here?
05:24:05 <badmash> mauke`: ok, thanks :)
05:24:14 <OverCoder> (i.e., how can I replace it with parenthesis)
05:24:39 <frerich> OverCoder: You can wrap everything between the '=' and '$' in parenthesis.
05:24:48 <potatoe> but yeah I'm just trying to get a list of keys
05:24:50 <potatoe> from inside the object
05:25:01 <badmash> any body else who can help here to diagnose this performance difference in quicksort?
05:25:02 <OverCoder> frerich, ooh, many thanks
05:25:20 <badmash> code is at http://lpaste.net/150403
05:25:29 <mauke`> badmash: ooh. it might be ++
05:25:30 <badmash> appreciate any help
05:25:39 <JamesJRH> liste: Ah, so it's haskellPackages.hoogle on NixOS then.
05:25:52 * JamesJRH installs Hoogle…
05:26:12 <mauke`> badmash: xs ++ ys is O(length(xs))
05:26:22 <badmash> mauke`: it can't be, because ++ is in qsort, so it is there when we use either split or split'
05:26:32 <mauke`> but the xs are different
05:27:01 <mauke`> with split, you're guaranteed that ls = xs, gs = []
05:27:06 <badmash> mauke`: could you explain?
05:27:32 <mauke`> because the pivot is always the first element, which is always greatest, because your input list is strictly descending
05:27:48 <badmash> mauke`: yes
05:28:05 <mauke`> on the other hand, split' reverses its result lists, so half of the time you'll have ls = [], gs = xs
05:28:16 <mauke`> which is the best case for (++)
05:28:47 <JamesJRH> Or perhaps haskellPackages.hoogleLocal: $ nix-env -qaP --description -f '<nixpkgs>' -A haskellPackages | egrep -i 'Hoogle' | sed -r "$(echo 's/  +/ \x1b[34m•\x1b[0m /;'{,})"
05:28:50 <JamesJRH> …
05:28:53 <JamesJRH> haskellPackages.hoogleLocal • hoogle-local-0.1 • A local Hoogle database
05:30:58 <badmash> mauke`: i see ... i overlooked that!
05:31:09 <badmash> mauke`: you are correct
05:33:20 <mauke`> badmash: you could compare the two qsorts on ([100000, 99998 .. 90000] ++ [90001, 90003 .. 99999])
05:33:51 <mauke`> if I've guessed right, this should slow down qsort/split'
05:35:43 <cata666> where do I find a good tutorial for arrows, anyone?
05:36:01 <mauke`> AFAIK no one uses arrows
05:36:19 <Fuco> my impression too
05:36:26 <cata666> why is that?
05:36:41 <Fuco> they just probide abstraction that isn't needed much I guess
05:36:50 <Fuco> the fanout on functions is the only thing I used with some success
05:37:15 <quchen> Arrow used to be a tuple library, but now we have Bifunctor.
05:37:51 <bergmark> we use arrows quite a bit... with opaleye and for handling xml
05:38:59 <badmash> mauke`: i tested your input
05:39:12 <badmash> still split' is way faster than split
05:39:19 <Xandaros> Arrows seem like an awesome thing, but in practice I find them a bit... unwieldy
05:39:40 <Xandaros> And most of the time an Applicative interface is all you need
05:39:47 <badmash> split' -- ~2.8 secs, split -- ~6.3 secs
05:40:12 <mauke`> so there's probably more to it
05:40:23 <bergmark> there aren't that many things that are arrows but not monads
05:42:15 <badmash> any else can help here
05:42:17 <badmash> ?
05:42:43 <exio4> I am sure split' gets inlined vs split
05:44:20 <badmash> exio4: why is that?
05:45:29 <cata666> what is your opnion on haste, I'm asking this as a javascript hater
05:46:03 <exio4> badmash: split' isn't recursive, an inner function is
05:47:19 <exio4> badmash: I get similar times here, btw (1.x seconds vs 18.x seconds)
05:48:30 <DaniG2k> hello all,
05:48:47 <DaniG2k> I'm using a Mac and trying to get a decent editor for Haskell
05:49:02 <DaniG2k> Sublime doesn't cut it since it keeps erring on incorrect spaces/tabs/indentation
05:49:30 <DaniG2k> I saw that Atom is popular but i keep getting errors with various packages missing/not loading (even though i installed like 6 or 7 packages!)
05:49:42 <DaniG2k> I'm wondering if there's an editor that just works for Haskell
05:49:49 <DaniG2k> without too much hassle
05:49:54 <frerich> DaniG2k: I guess if you're looking at Sublime or Atom, then vim would be out of the question? :-]
05:50:07 <DaniG2k> frerich: vim is fine but it seems I need to do a lot of configuration?
05:50:08 <Rouven> Using TextMate here
05:50:44 <Xandaros> DaniG2k: I second the vim recommendation. It does require a bit of configuring, but at the end of it, it is your editor. Just the way you like it :)
05:50:46 <frerich> DaniG2k: Not really. For Haskell, if you have vim-hdevtools and syntastic then you are pretty good.
05:51:20 <frerich> DaniG2k: I.e. I get warnings and hints about my code, and when I save it shows me type errors. And I can type <leader>t above an expression and vim shows me the type of the expression under the cursor (pressing it repeatedly shows the types of the parent expressions).
05:51:29 <Xandaros> and a colour scheme. Let's be honest, the default vim colours look horrid
05:51:49 <frerich> DaniG2k: It's not a grand IDE of course, but for things like file navigation or so, I use the standard stuff (ctrl+p in my case), nothing Haskell-specific.
05:52:15 <puregreen> what RPC library would you recommend? I've got 2 apps and I want one to be able to a) find out whether the other is running, and b) send commands to that other app
05:52:22 <JamesJRH> frerich: How do you decide between Control.Monad.replicateM or Data.Sequence.replicateM?
05:52:28 <puregreen> something like dbus but without dbus
05:52:46 <frerich> JamesJRH: I look at their types :-)
05:53:23 <anohigisavay>  anyone used groundhog? how to construct a Key value besides using extractUnique :: uKey ~ Key v u => v -> uKey
05:53:28 <frerich> JamesJRH: The one from Control.Monad gives me a list of values. The one from Data.Sequence gives me a sequence (a "Seq") of values.
05:53:33 <badmash> exio4: sorry, i had got disconnected.  did you say something?
05:53:45 <JamesJRH> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
05:53:47 <frerich> JamesJRH: Since you want to use the result with 'pack', which expects a list of values, I go for the one in Control.Monad.
05:53:56 <JamesJRH> Data.Sequence.replicateM :: Monad m => Int -> m a -> m (Seq a)
05:54:11 <exio4> badmash: just that I get similar times
05:54:33 <badmash> exio4: so you don't see a difference between split & split'?
05:54:42 <JamesJRH> frerich: But a list is a sequence too, right? So isn't the latter more generic?
05:54:55 <exio4> no, no! similar results to yours :) 
05:55:04 <badmash> exio4: :)
05:55:43 <frerich> JamesJRH: I'm not sure what you mean by 'A list is a sequence, too' -- In Haskell, the types '[a]' and 'Seq a' are two separate types.
05:55:44 <badmash> exio4: you mentioned about inlining ... i suppose something like that may be the reason
05:55:44 <exio4> badmash: by the way, the problem seems to be too much lazyness
05:56:10 <badmash> exio4: yeah, both split ans split' are lazy, right?
05:56:13 <frerich> JamesJRH: And even if they were somehow related, I'd still not necessarily choose the most generic version. In fact, I usually choose functions to be as generic as necessary (instead of as generic as possible).
05:56:27 <JamesJRH> frerich: Oh, indeed, the latter doesn't work.
05:56:34 <exio4> badmash: {-# LANGUAGE BangPatterns #-} ; in split repliace (less,greater) = split f xs with !(less,greater) = split f xs
05:56:36 <JamesJRH> I was thinking of something else.
05:58:07 <JamesJRH> But it would be with a class anyway, something like ‘Sequencable’.
05:58:07 <badmash> exio4: but my question is, if laziness is an issue, it should affect split' as well, correct?
05:59:01 <frerich> JamesJRH: There are a couple of classes which are both instantiated by [] as well as Seq (e.g. 'Traversable', which may be what you meant). Howevr, 'pack' doesn't work with any type which instantiates a given class. It wants a plain old list, i.e. [] :-)
05:59:02 <badmash> exio4: the central issue is -- why is split' making qsort faster?
05:59:04 <JamesJRH> frerich: I see. Is that for efficiency reasons or for making better use of the type system to catch errors?
05:59:30 <frerich> JamesJRH: What do you refer to with "that"?
05:59:40 <JamesJRH> frerich: Yes, Traversable is what I was thinking of!
05:59:44 <exio4> badmash: split is basically the worker function of qsort :P 
05:59:55 <badmash> exio4: yes
06:00:08 <badmash> exio4: so is split'
06:00:22 <JamesJRH> frerich: “that” was re.: 13:55:50 < frerich> JamesJRH: And even if they were somehow related, I'd still not necessarily choose the most generic version. In fact, I usually choose functions to be as generic as necessary (instead of as generic as possible).
06:01:21 <badmash> exio4: by the way, split and split' have nearly identical speeds if used outside qsort
06:01:56 <frerich> JamesJRH: Oh, well - that's a tribute to my brain. I just have a much easier time reading e.g. 'map length . lines <$> readFile "ChangeLog"' than 'fmap (fmap (fmap length) lines) (readFile "ChangeLog")'
06:02:02 <badmash> exio4: only when used *within* qsort do they seem to show up a difference in speed
06:02:02 <exio4> badmash: I don't think that is true, did you use criterion?
06:02:19 <badmash> no, i just ran with unix time
06:02:52 <frerich> JamesJRH: All of (.), map or <$> can be replaced with just 'fmap'. So fmap is 'more generic'. The price is that you have to closely read the context to figure out what 'fmap' does exactly in each case.
06:03:09 <frerich> JamesJRH: That's the reason for what I wrote earlier. Not so much type safety or so.
06:03:20 <badmash> exio4: i have also put that observation as a comment in the code i put at lpaste
06:03:42 <exio4> badmash: split vs split + strictness annotations, the code is much smaller and direct in the fast version (and it's on the same-ish time range compared to split' (+ reverses so their behavior matches)
06:07:50 <JamesJRH> frerich: Well anyway, this is what I have now: Prelude> fmap Data.ByteString.pack (Control.Monad.replicateM 16 System.Random.randomIO)
06:07:53 <JamesJRH> "\238v;\185\214\160q\DLE\148\195\176\fl\215Hf"
06:07:58 <badmash`> any ideas why there is this performance difference? appreciate any help
06:08:29 <JamesJRH> And reading on to what I hadn't read yet, I see that others had already said variants of that.
06:09:22 <JamesJRH> Also, merijn quit.
06:09:56 <badmash`> code is at http://lpaste.net/150403
06:11:38 <badmash`> bewildering stuff
06:11:38 <aweinstock> badmash`: my first guess is that GHC isn't optimizing away the use of tuples in split, so there's memory allocation for every recursive call
06:11:47 <aweinstock> (which is expensive)
06:12:14 <badmash`> aweinstock: ok, but why isn't this a problem in split'?
06:12:25 <exio4> split' doesn't generate tuples until the last step
06:12:28 <aweinstock> you could do -ddump-core or -ddump-asm to get core/assembly, which will tell you exactly what's happening, but they're very detailed
06:12:45 <exio4> http://dpaste.com/2DRWJB3
06:13:00 <exio4> I haven't included tco version, but it's still the same problem
06:13:14 <badmash`> aweinstock: also, how does it affect speed? which is what i want to understand
06:13:19 <aweinstock> badmash`: split' uses function parameters for all the recursive calls, and presumably GHC can optimize those better
06:13:40 <aweinstock> badmash`: are you familiar with C?
06:13:56 <badmash`> aweinstock: more java than c
06:14:12 <exio4> the core of split (tco, function parameters, all that) http://dpaste.com/134GK79
06:14:33 <badmash`> aweinstock: but go ahead
06:14:36 <exio4> (this version is actually slower because a NOINLINE .. well, didn't let the optimizer do much, but it's still "fast")
06:14:57 <aweinstock> I'm not as familiar with java's performance model as I am with C
06:15:22 <badmash`> aweinstock: please explain in terms of c ... i will see if i can follow you
06:15:37 <frerich> aweinstock: A particularly grumpy colleague keeps telling me that there's not much to know about the 'performance model' of Java...
06:15:44 <MarcelineVQ> aweinstock: the combo for core atm is -ddump-prep -fforce-recomp
06:15:51 <aweinstock> but memory allocation (either via malloc or "new"ing an object) has some overhead, which split is doing the equivalent of for every recursive call
06:16:20 <badmash`> aweinstock: and that impacts qsort sepped?
06:16:21 <aweinstock> while split' is only allocating memory for the result at the end
06:16:22 <exio4> MarcelineVQ: I just use ghc-core :P
06:16:22 <JamesJRH> I can't get this idea to work: 13:04:11 < merijn> JamesJRH: You could also use "randoms" together with "pack . take 100" to create a BS :)
06:16:26 <MarcelineVQ> :>
06:16:56 <badmash`> aweinstock: and that impacts speed as well?  split' faster than split?
06:17:10 <aweinstock> yes
06:17:22 <exio4> badmash`: if you want to see this differently, one can be compiled to a loop which "just mutates variables", while the other one actually has to allocate an object on every iteration
06:17:26 <aweinstock> memory allocation takes time
06:17:26 <MarcelineVQ> exio4: as of 7.10.2 the prep output is pretty readable, have a look and see if it compares if you're interested
06:17:41 <exio4> MarcelineVQ: haven't upgraded to GHC 7.10 :( 
06:18:10 <MarcelineVQ> specifically I don't know when it changed, I only mention that version because I'm using it
06:18:20 <frerich> JamesJRH: 'randoms' yields an infinite list of random values given some generator. E.g. 'randoms (mkStdGen 1)' (where '1' is the 'seed value'). You can then take as many of those as you need via 'take' and then pass that list of numbers you took to 'pack'.
06:18:52 <aweinstock> frerich: more details regarding java's performance model (or lack thereof)?
06:19:12 <frerich> JamesJRH: Note that 'randoms' doesn't return a plain list but rather an IO action which in turn promises to produce a list. So you'll need to fmap 'pack' and 'take' (or a composition of those) over that IO action.
06:19:15 <JamesJRH> frerich: Do you know how to use System.Random.randoms and (Data.ByteString.pack . take 16) to do the same as?: fmap Data.ByteString.pack (Control.Monad.replicateM 16 System.Random.randomIO)
06:19:36 <JamesJRH> Oh, let me read what you've said…
06:19:56 <exio4> frerich: wait, does it?
06:20:01 <exio4> @type System.Random.randoms
06:20:03 <lambdabot> (RandomGen g, Random a) => g -> [a]
06:21:02 <exio4> http://dpaste.com/2DRWJB3 line 56 and line 61/67 & 74/77
06:21:03 <frerich> JamesJRH: Yes, I do know how to replace that, but I sense it would spoil the fun if I give it away :-)
06:22:05 <exio4> allocation happens in 56 just to pattern match "inside" the return values
06:22:37 <JamesJRH> frerich: Yep, thanks for the clues, let me work through this…
06:22:40 <frerich> exio4:Oh, yeah, that was silly. Especially given that right before that sentence I explained that you actually pass in a generator yourself. :-)
06:23:13 <JamesJRH> This is what I now have (doesn't work): Prelude> fmap (Data.ByteString.pack . take 16) System.Random.randoms
06:23:26 <JamesJRH> I think I need to look at what the generator thing is…
06:23:27 <badmash> aweinstock: by the way, if you run split and split' *outside* qsort, they seem to have the same speed
06:23:36 <exio4> badmash: which speeds?
06:23:49 <badmash> time in unix
06:23:57 <exio4> badmash: s/speed/timing
06:23:59 <MarcelineVQ> badmash: This has probably been asked by now but are your timing comparions with -O2?
06:24:08 <frerich> JamesJRH: I'm sorry, as exio4 correctly pointed out I explained one part wrongly: 'randoms' doesn't yield an IO action (have a look at its type). It yields a plain list. So you don't need 'fmap'.
06:24:15 <badmash> MarcelineVQ: yes, absolutely
06:24:21 <MarcelineVQ> :D
06:25:32 <badmash> exio4: i am not sure what you said there
06:25:39 <OverCoder> \u0090 doesn't work, how can I input Unicode there?
06:25:45 <aweinstock> badmash: consider using Criterion for benchmarking (it does some statistics and graphs for you)
06:25:50 <frerich> JamesJRH: However, you need a generator of random numbers which 'randoms' can repeatedly fetch from. You can create one given a seed value via 'mkStdGen'. Or you use 'getStdGen' (but that's an IO action).
06:26:03 <badmash> i just timed direct calls to split and split' using time command in unix
06:26:15 <aweinstock> badmash: https://github.com/aweinstock314/haskell-stuff/blob/master/Quicksort.hs
06:27:29 <badmash> aweinstock: thanks ... you have a full-blown work there on quicksort
06:27:41 <badmash> :)
06:28:03 <exio4> badmash: I would like to see how you are benchmarking this, as the timings are quite .. small here, and I need to give split/split' really big outputs
06:28:13 <exio4> badmash: (and actually, the bottleneck is IO, the print) 
06:28:21 <badmash> aweinstock: i see that you have also used criterion ... i will check it out
06:28:24 <exio4> badmash: so I am forcing things differently
06:28:38 <badmash> exio4: how so? 
06:29:14 <badmash> exio4: yeah, i gave them big inputs
06:29:46 <exio4> badmash: printing things on console is REALLY expensive, so for pretty much any "serious benchmark", you should avoid printing things
06:30:22 <badmash> exio4: moreover, when i run qsort with list of randomly generated Ints, i see not much performance difference between spli and split'
06:31:10 <badmash> aweinstock: split and split' start to differ quite a bit when i run qsort with worst case inputs
06:31:25 <exio4> badmash: are you sure?
06:31:35 <badmash> exio4: yes
06:31:35 <exio4> badmash: (also, you changed the reverse stuff, right?)
06:32:07 <badmash> exio4: i am sorry, i didn't understand what you said there? which reverse?
06:32:16 <exio4> so, now the functions are doing the same? (you were comparing two different functions before)
06:32:52 <JamesJRH> frerich: Got it!
06:32:53 <JamesJRH> Prelude> fmap (Data.ByteString.pack . take 16 . System.Random.randoms) System.Random.getStdGen
06:32:53 <badmash> exio4: ah i see what you are saying
06:32:56 <JamesJRH> "\162\239\196\140\254\150\247\137\203\223\213\211&\132\235Z"
06:33:14 <frerich> JamesJRH: :-)
06:33:22 <badmash> exio4: whether you use split or split', qsort gives the same output
06:33:36 <exio4> badmash: yes, yet split and split' behave completely different
06:33:54 <jophish> I have a 256x256x3 array in repa, and I'd like to reorder the elements so it's a 3x256x256 array. Essentially take the three slices of the array and concatenate them.
06:33:55 <badmash> exio4: you mean one reverses the list?
06:34:12 <jophish> Would it be faster to use backPermute or to concatenate three slices?
06:34:17 <jophish> or something else
06:34:18 <exio4> badmash: even if you fix the lazyness issue, the asymptotic complexity of the algorithm can't be changed magically :) 
06:34:22 <jophish> This is essentially a transposition
06:34:34 <jophish> but the transpose function is fixed to two dimensions
06:34:36 <badmash> exio4: i know
06:34:36 <exio4> badmash: yes, which in turns leads to better/worse performance, the way the algorithm works
06:34:43 <JamesJRH> So it's that versus: Prelude> fmap Data.ByteString.pack (Control.Monad.replicateM 16 System.Random.randomIO)
06:34:47 <JamesJRH> "\162\239\196\140\254\150\247\137\203\223\213\211&\132\235Z"
06:34:53 <badmash> exio4: i am not trying to change the complexity of qsort
06:35:35 <badmash> i am only asking why is there a difference in speed in qsort when we use 2 different implementations of the partitioning
06:36:13 <badmash> exio4: in this case, to be more precise, we are talking about usage of split or split' in qsort
06:36:27 <JamesJRH> merijn's suggestion with System.Random.randoms is more interesting because it exposes this clever generator machinery to me. :-)
06:37:07 <badmash> exio4: i want to know what is going on in haskell that gives this difference, because i can't infer fromn the code
06:37:47 <exio4> badmash: that difference isn't within Haskell (well, it makes the problem worse because ++ is awful), it's in the algorithm
06:38:01 <cordawyn> import FST.Automaton
06:39:12 <exio4> badmash: try to do quicksort on your on with small inputs, try sorting [1,7,4,8,9,20,3], following the algorithm (and the way split works), you'll see, when you "pick" the next case in the recursive steps, you'll be picking completely different values as pivots, which will in turn lead to different partitions
06:39:53 <Eduard_Munteanu> Any suggestion of an alternative to acid-state's Data.Acid.Log for crash-safe binary logging?
06:40:16 <Eduard_Munteanu> I'm hoping for a nicer streaming API, say based on conduit.
06:40:25 <badmash> exio4: you mean different partitions with split ans split'?
06:40:50 <exio4> badmash: see with [5,4,3,2,1] ; we pick 5 as pivot, so we have to traverse the whole list to see we have "two" sides, [4,3,2,1] and []; which split the list in non-even "parts"
06:40:54 <exio4> badmash: yes
06:41:45 <exio4> badmash: [5,4,3,2,1] , let (as, bs) = split 5 [4,3,2,1] in qsort as ++ [x] ++ qsort bs ; right?
06:41:50 <JamesJRH> frerich: System.Random.getStdGen is of type ‘IO StdGen’, StdGen is an instance of class RandomGen, and class RandomGen is very interesting to me indeed because it allows writing of one's own drop-in replacement random number generators.
06:42:21 <exio4> badmash: if we evaluate split there, preserving the list order, we'd get as = [4,3,2,1] and bs = []
06:42:32 <badmash> exio4: yes
06:43:00 <badmash> whereas in split' you would get the reverse order
06:43:54 <exio4> badmash: if you follow the tree completely, you'd see you have to traverse a 5-element list in the "first" step, a 4-element list in the "second" step, .. until the base case on the first call, if you split the list evenly, you would be traversing smaller bits of the list as you recurse
06:44:34 <badmash> exio4: i see what you are saying, but i am looking at the worst case of quicksort
06:45:12 <badmash> exio4: you are correct ... in this worst-case input, the complexity is O(n^2)
06:45:40 <badmash> i meant time cmplexity
06:46:10 <JamesJRH> frerich: I could write an instance of System.Random.RandomGen which is not a /pseudo/random number generator, but rather one that takes e.g. coin flips or dice rolls as input to produce ‘real’ random data, albeit at a much slower rate.
06:46:24 <exio4> hm, right, this seems to be bouncing either way :/
06:47:19 <JamesJRH> But not /too/ slow a rate for generating high-randomness passphrases and encryption keys.
06:47:26 <badmash> aweinstock: i think i will checkout what you said ... you mentioned getting a dump of the assembly to see what is going on?
06:47:31 <exio4> badmash: without look further, my guess is the difference comes from the associativity of (++)
06:47:41 <exio4> badmash: GHC Core, ASM is last resort!
06:48:18 <frerich> JamesJRH: If you could devise a RandomGen instance which does not yield pseudo random numbers, but truly random numbers, I'm sure that would be quite interesting. :^) In particular, verifying that your newly devised generator actually generates random data (as opposed to numbers which are just very hard to predict) would be interesting. ;-)
06:48:38 <tdammers> JamesJRH: with some unsafePerformIO black magic, you could actually do that
06:48:51 <exio4> what's the difference between truly random numbers and numbers which are hard to predict anyway?
06:49:03 * frerich knew somebody would bite
06:49:11 <bartavelle> :)
06:49:21 <tdammers> something like read numbers from a socket or FIFO, and then write another program that prompts the user to roll a dice in front of the webcam and then uses image recognition to see what you rolled, and feed that into the FIFO
06:49:54 <JamesJRH> Furthermore, I could XOR it with the standard pseudorandom source to ensure that the result is only better than either source.
06:50:34 <frerich> JamesJRH: You could also multiply two numbers, that might make it.... twice as random!
06:50:35 <badmash> tdammers: plus, you could add a random component -- the residual error -- to all that :)
06:50:48 <JamesJRH> tdammers: Why unsafePerformIO?
06:51:57 <frerich> JamesJRH: On a more serious note, randomness is a very very difficult problem and the only thing I know about it for sure is that if possible, I should try to roll my own thing but use the code which people who actually know their stuff. ;-)
06:52:10 <JamesJRH> frerich: I wrote a dice passphrase generator in Haskell several months ago. I'm wondering whether I can adapt it to use the System.Random interfaces.
06:52:39 <tdammers> JamesJRH: you're right, you can offload the impure calls to the code that creates the RNG
06:52:46 <tdammers> lazy I/O if you must
06:53:00 <JamesJRH> frerich: I'm aware of the problems with randomness but I'm also aware of some of the solutions.
06:53:11 <bartavelle> JamesJRH, you will need to seed your generator with enough random values if you want to use them directly
06:53:21 <bartavelle> you can't "add entropy" on the go, as "next" is pure
06:53:37 <bartavelle> except with cheating with unsafePerformIO
06:54:02 <JamesJRH> frerich: So XOR'ing the normal generator and the generator that I make from the dice rolls is only better than either source individually.
06:54:03 <tdammers> bartavelle: or lazy IO
06:54:28 <exio4> that's unsafeInterleaveIO, not unsafePerformIO!
06:54:29 <bartavelle> tdammers, true
06:54:46 <bartavelle> ah sorry, never used these unsafe things :/
06:55:10 <exio4> it's just a joke, there are so many unsafe ways of doing everything, it's a bit fun sometimes
06:55:19 <bartavelle> hhe
06:55:49 <exio4> you can also just pattern match on IO and work with unboxed tuples yourself and you won't need either! 
06:56:51 <JamesJRH> 14:52:58 < bartavelle> you can't "add entropy" on the go, as "next" is pure  ← Hmmm, maybe this isn't going to work-out how I was thinking then. :-/
06:57:03 <tdammers> exio4: that sounds repulsive
06:57:30 <exio4> tdammers: it is, that's the fun part!
06:57:55 * Eduard_Munteanu really can't believe there isn't a standard binary log format yet
06:58:00 <Eduard_Munteanu> I'll just roll my own.
06:58:02 <exio4> tdammers: soon enough you'll be writing code like http://dpaste.com/2EFHNPR#line-20 
06:58:43 <jophish> :( Getting segfaults
06:58:54 <exio4> code?
06:59:12 <tdammers> exio4: that looks a lot like Perl
06:59:14 <jophish> I wonder how tricky it is to get a stack trace in haskell
06:59:23 <jophish> exio4: some ffmpeg-light stuff
06:59:34 <exio4> oh jophish 
06:59:55 <tsahyt> jophish: Like a trace of the actual stack? That's gonna be quite horrible, but you can of course get one with gdb. Using trace in ghci is probably your better option though
06:59:56 <exio4> jophish: stack trace? in case of .. exceptions/"bottoms you can catch"? 
07:00:00 <Eduard_Munteanu> jophish, ghci can do it
07:00:15 <Eduard_Munteanu> @faq Can Haskell provide stack traces?
07:00:15 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
07:00:24 <Eduard_Munteanu> :(
07:00:25 <geekosaur> jophish, it's as easy as installing the ghc 8.1 prerelease, if you can handle its bugs
07:00:36 <jophish> sorry, I mean the stack after things leave haskell-land
07:00:52 <geekosaur> oh, that's going to need gdb/lldb
07:01:20 <exio4> there's minimal support in GHC 7.8 already (minimal? I don't know :P)
07:02:06 <jophish> yeah, I suppose if I compile ffmpeg with -g then lldb will give me a stack trace without a problem
07:02:09 <geekosaur> I think you meant 7.10 (actually only 7.10.2/3)
07:02:19 <badmash> so how do you get a stacktrace in production at all? right now is this feasible?
07:02:19 <jophish> I assume it'll be garbage above the C level though
07:02:50 <geekosaur> and pieces are missing from the 7.10 version
07:03:54 <JamesJRH> 14:52:16 < tdammers> JamesJRH: you're right, you can offload the impure calls to the code that creates the RNG  14:52:23 < tdammers> lazy I/O if you must  ← Ah, missed that. Yes, that's what I was thinking along the lines of. (I'm also thinking about a way to compose generators with XOR.) But as for lazy IO I know very little about that.
07:04:39 <JamesJRH> tdammers: Lazy IO sounds like it's what I want.
07:05:22 <exio4> geekosaur: hmm, maybe, I don't remember the GHC version on my laptop
07:06:06 <JamesJRH> Imagine that the dice-source generator is deterministic given an infinite number of dice rolls, but they just haven't been inputted yet.
07:06:08 <geekosaur> ?CallStack snuck into 7.10.2 (I know this for certain because they had to patch things so ghc 8.1 could be built on 7.10.1...)
07:06:08 <lambdabot> Unknown command, try @list
07:06:27 <Franciman> Hello
07:06:38 <cordawyn> @list
07:06:38 <lambdabot> What module?  Try @listmodules for some ideas.
07:06:57 * geekosaur forgot to escape te ?, forgot it's an alternate command char. feh
07:08:09 <byorgey> hi Franciman 
07:08:22 <aphorisme> Hello! In the websockets package, there is `runServer` but also the recommendation to rather use wai/warp or such. Why?
07:08:51 <Franciman> If I have a list let's say [1, 2, 3, 4, 5] and I want to calculate di minimum of every n elements, which is if n = 2 I wanna get this: [ minimum [1, 2], minimum [3, 4] , minimum [5] ], if n = 3, I group elements by 3 and to the same. What's the best way to achieve this?
07:08:54 <ner0x652> Hi! I've read that an empty tuple "()" is also a type, is an empty list a type?
07:09:04 <exio4> geekosaur: sounds like so, I didn't know
07:09:15 <byorgey> ner0x652: yes
07:09:21 <byorgey> @kind []
07:09:22 <lambdabot> * -> *
07:09:27 <exio4> Franciman: \n -> map minimum . splitAt n ? 
07:09:43 <byorgey> ner0x652: it is a prefix way to write the list type constructor, that is,  [] a === [a]
07:09:53 <byorgey> > [3,4,5] :: [] Int
07:09:55 <lambdabot>  [3,4,5]
07:09:58 <exio4> er, wait, nvm :)
07:09:58 <tsahyt> :t splitAt
07:10:00 <lambdabot> Int -> [a] -> ([a], [a])
07:10:02 <byorgey> [] Int   is the same as  [Int]
07:10:08 <DaniG2k> is anyone here using atom editor on Mac?
07:10:18 <aphorisme> DaniG2k I do.
07:10:32 <DaniG2k> aphorisme: do you remember what packages you installed to get it working?
07:10:32 <ner0x652> byorgey: understood, thank you
07:10:36 <tsahyt> Franciman: There's a chunksOf function in the split package if I remember correctly, so you could do \n -> map minimum . chunksOf n
07:10:41 <tsahyt> :t chunksOf
07:10:42 <lambdabot> Int -> [e] -> [[e]]
07:10:50 <aphorisme> DaniG2k to get what working?
07:10:52 <tsahyt> :t \n -> map minimum . chunksOf n
07:10:54 <lambdabot> Ord b => Int -> [b] -> [b]
07:11:49 <Franciman> ok great, thanks exio4 and tsahyt 
07:11:52 <DaniG2k> aphorisme: sorry, I meant to get Haskell support for Atom working properly
07:12:58 <aphorisme> DaniG2k: language-haskell, autocomplete, autocomplete-haskell, haskell-ghc-mod, ide-haskell.
07:13:12 * hackagebot fail 4.9.0.0 - Forward-compatible MonadFail class  https://hackage.haskell.org/package/fail-4.9.0.0 (HerbertValerioRiedel)
07:13:17 <Eduard_Munteanu> ner0x652, ordinary lists do not distinguish between empty and non-empty cases in the type.
07:13:31 <Eduard_Munteanu> :t []
07:13:33 <lambdabot> [t]
07:14:08 <Eduard_Munteanu> :t [?a, ?b, ?c]
07:14:10 <lambdabot> (?a::t, ?b::t, ?c::t) => [t]
07:14:25 <DaniG2k> aphorisme: thanks :) once I do that is there anythign else that needs doing? just restart?
07:15:31 <DaniG2k> aphorisme: I get the error message Haskell-ghc-mod: ghc-mod failed to launch. It is probably missing or misconfigured. ENOENT
07:15:37 <marrrk> How can I switch ghc-mod to use stack?
07:15:54 <tsahyt> marrrk: It should do that automatically in newer versions
07:16:16 <marrrk> I have this: ghc-mod version 5.4.0.0 compiled by GHC 7.10.3
07:16:16 <aphorisme> DaniG2k: in fact, you will encounter some issues from time to time. It works upon *.cabal or stack.yaml files; I've made good experience with stack. You need your ghc-mod be compiled against the same ghc version as you use to compile your projects.
07:16:23 <aphorisme> DaniG2k: do you have ghc-mod?
07:16:33 <potatoe> hi, does anyone know how I can get a Value -> HashMap from an aeson represented object
07:16:49 <aphorisme> Eduard_Munteanu: what is this ?a notation?
07:16:52 <DaniG2k> aphorisme: I'm not sure. How can I check?
07:16:58 <aphorisme> do you have stack?
07:17:07 <Eduard_Munteanu> aphorisme, implicit parameters
07:17:31 <Eduard_Munteanu> Often abused with lambdabot to introduce variables into the context.
07:17:51 <Eduard_Munteanu> :t ?a + ?b
07:17:53 <lambdabot> (Num a, ?a::a, ?b::a) => a
07:17:58 <marrrk> I always get this: ghc-mod: <command line>: cannot satisfy -package-id HTTP-4000.2.22-abbb2efaa16aa63b4db5f093a8874946
07:18:13 * hackagebot PUH-Project 0.1.0.1 - This is a package which includes Assignments, Email, User and Reviews modules for Programming in Haskell course.  https://hackage.haskell.org/package/PUH-Project-0.1.0.1 (att)
07:19:28 <aphorisme> marrrk: probably HTTP-4000 was compiled with ghc 7.10.2?
07:19:55 <marrrk> maybe, I don't know
07:20:31 <aphorisme> Eduard_Munteanu: Ah! Like { ... } in agda?
07:20:35 <marrrk> How can I find that out, aphorisme ?
07:20:37 <aphorisme> marrrk where do you encounter this problem?
07:20:55 <Eduard_Munteanu> aphorisme, yeah, sort of
07:20:56 <marrrk> In Emacs and when I simply do ghc-mod check stack.yaml
07:21:21 <Eduard_Munteanu> They're kinda obscure in Haskell though.
07:21:42 <Eduard_Munteanu> (well, it's a GHC extension, not standard anything)
07:22:21 <marrrk> I get this: ghc-pkg describe --ipid HTTP-4000.2.22-abbb2efaa16aa63b4db5f093a8874946
07:22:21 <marrrk> ghc-pkg: cannot find package HTTP-4000.2.22-abbb2efaa16aa63b4db5f093a8874946
07:22:36 <tobiasBora> Hello,
07:22:38 <aphorisme> marrrk: and you have some project structure? I guess you've recently updated ghc-mod; try to select a newer resolver in your stack.yaml, lts-4.2 for example and run "stack build" in your project directory.
07:23:19 <marrrk> I had to install ghc-mod like this: stack --resolver nightly install stylish-haskell hlint hasktags ghc-mod but the project uses some LTS. Is that the problem?
07:23:50 <aphorisme> shouldn't be; at least lts-4.2 has ghc7.10.3
07:24:00 <marrrk> It was LTS-3.19
07:24:05 <marrrk> in the project that is
07:24:15 <marrrk> And I think there was no ghc-mod
07:24:24 <aphorisme> so lts-4.2 will be fine.
07:25:10 <tobiasBora> I would like to implement an algorithm that browse a graph. In order to avoid loop, I would use in imperative languages an array that contains the alreadx visited edges. How would you provide the same result with functionnal programs in haskell in an efficient solution ?
07:25:18 <marrrk> can/should/do I have to remove the other ghc-mod now?
07:25:40 <aphorisme> no, stack keeps track of all these stuff.
07:26:13 <marrrk> okay
07:26:20 <marrrk> let's see now
07:26:26 <byorgey> tobiasBora: take a look at http://hackage.haskell.org/package/fgl
07:26:50 <marrrk> oh now it is looking very good
07:27:04 <aphorisme> : )
07:27:26 <byorgey> tobiasBora: you can use a mutable array for this in Haskell too
07:28:59 <JamesJRH> frerich: So a neat little oneliner random* base 64 ByteString generator…: Prelude> Data.ByteString.putStrLn =<< fmap (Data.ByteString.Base64.encode . Data.ByteString.pack . take 24 . System.Random.randoms) System.Random.getStdGen
07:29:03 <JamesJRH> vdEKg7TTybPZS2AyKJrtJpfnGApaELj6
07:29:24 <mauke`> Data.ByteString.putStrLn . Data.ByteString.Base64.encode . Data.ByteString.pack . take 24 . ittle oneliner random* base 64 ByteString generator…: Prelude> Data.ByteString.putStrLn =<< fmap (Data.ByteString.Base64.encode . Data.ByteString.pack . take 24 . S
07:29:26 <JamesJRH> frerich: *Only trouble is that it gives the same result everytime.
07:29:32 <mauke`> wtf
07:30:02 <tobiasBora> byorgey: I would like to implement it, I do not want to use a library. So I don't have a good purely functionnal solution ? And if I use mutable array, which lib is the best one to use ?
07:30:03 <JamesJRH> mauke`: What?
07:30:08 <mauke`> copy/paste failure
07:30:14 <JamesJRH> Oh.
07:30:27 <mauke`> 'f =<< fmap g x' can be written as 'f . g =<< x'
07:31:09 <byorgey> tobiasBora: well, if you want to stick to purely functional, you can maintain a Set of already visited nodes.  Then checking whether a node has already been visited is O(lg n).
07:32:01 <tobiasBora> byorgey: Ok thank you. So here mutable are quite nice…
07:32:22 <byorgey> tobiasBora: if you want to look into mutable arrays in Haskell, look at the standard array package: http://hackage.haskell.org/package/array
07:32:40 <JamesJRH> And with the System.Random.randomIO formulation: Prelude> Data.ByteString.putStrLn =<< fmap (Data.ByteString.Base64.encode . Data.ByteString.pack) (Control.Monad.replicateM 24 System.Random.randomIO)
07:32:45 <JamesJRH> vdEKg7TTybPZS2AyKJrtJpfnGApaELj6
07:32:47 <tobiasBora> fgl use mutable arrays ?
07:32:51 <byorgey> look at  Data.Array.MArray  and  Data.Array.IO  to start
07:32:57 <tobiasBora> uses*
07:33:28 <byorgey> tobiasBora: I don't know how it is implemented under the hood
07:34:04 <JamesJRH> Ah, now although that's the same as the other one, subsequent tries do actually progress the generator:
07:34:07 <JamesJRH> Prelude> Data.ByteString.putStrLn =<< fmap (Data.ByteString.Base64.encode . Data.ByteString.pack) (Control.Monad.replicateM 24 System.Random.randomIO)
07:34:10 <JamesJRH> lxmTWV0CxcJrf4VIQkH6vVJSPJtbcObH
07:34:13 <JamesJRH> Prelude> Data.ByteString.putStrLn =<< fmap (Data.ByteString.Base64.encode . Data.ByteString.pack) (Control.Monad.replicateM 24 System.Random.randomIO)
07:34:16 <JamesJRH> HHZYxfb19mCSAwPMi0JS3ccnCKKsqurD
07:34:18 <JamesJRH> Excellent.
07:34:31 <puregreen> potatoe: there isn't a function for that but you can just pattern-match
07:34:45 <JamesJRH> So why didn't it for System.Random.randoms?
07:35:18 <puregreen> potatoe: fromObject (Object o) = o; fromObject _ = error "not an object"
07:35:52 <tobiasBora> byorgey: Ok thank you !
07:37:10 <KaneTW> note that using "error" for stuff like that might be a bad idea
07:37:29 <KaneTW> fromObject (Object o) = Just o; fromObject _ = Nothing is safer
07:38:14 * hackagebot binary-search 1.0.0.2 - Binary and exponential searches  https://hackage.haskell.org/package/binary-search-1.0.0.2 (TakayukiMuranushi)
07:39:27 <jophish> In case anyone is interested, the bug wasn't in ffmpeg at all. It was in juicypixels-repa
07:39:41 <jophish> and I'm using unsafeCoerce to workaround it, how exciting!
07:39:53 <bergmark> wee
07:40:56 <potatoe> puregreen, but I have a value which is represented as Object (fromList [(" right?
07:41:03 <Lokathor> >> Cannot decode byte '\xbf': Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream
07:41:05 <Lokathor> is what it told me
07:41:09 <potatoe> i want to expose the HashMap inside
07:41:54 <Lokathor> should i make the decoding be wrapped in try i guess and convert possible decode errors?
07:42:33 <puregreen> potatoe: the Value data type is defined like data Value = Object (HashMap Text Value) | Array (Vector Value) | ...
07:42:52 <puregreen> once you've pattern-matched it, you've got access to the HashMap
07:43:22 <puregreen> note that aeson also defines a type synonym: type Object = HashMap Text Value
07:43:31 <puregreen> which makes it somewhat confusing
07:43:59 <puregreen> anyway, when you see Object as a type it's HashMap, when you see Object as a constructor/pattern it's Value
07:44:38 <potatoe> puregreen I see, thank you
07:58:15 * hackagebot range-set-list 0.1.2.0 - Memory efficient sets with ranges of elements.  https://hackage.haskell.org/package/range-set-list-0.1.2.0 (phadej)
08:10:12 <fractalsea> Is there a way of making a Program from the operational library an instance of Arbitrary? It would be really cool to get arbitrary programs that I could interpret and check invariants on
08:14:02 <cipher__> Does f :: a -> b -> c say a returns a function b -> c, or that a function a -> b maps to c? Neither?
08:15:26 <geekosaur> the former
08:15:35 <geekosaur> which is how pa\rtial application works
08:16:10 <KaneTW> cipher__: f :: a -> b -> c is parsed as f :: a -> (b -> c)
08:17:04 <byorgey> fractalsea: not really, since it involves a function from an existentially quantified type
08:18:27 <cipher__> KaneTW, so f A B would first apply A such that f returns (b -> c), then applies B to that function?
08:18:56 <cipher__> I'm assuming it's left associative I guess. 
08:19:01 <athan> Is a Scott encoding something like the nature of continuation passing style?
08:19:21 * OverCoder stares at Haskell
08:19:31 <KaneTW> cipher__: yes
08:19:35 <OverCoder> what is Data.Map.fromList is diong
08:19:36 <byorgey> fractalsea: however, this kind of thing (generating random programs and testing them) can certainly be done for certain languages.  You might be interested in http://arxiv.org/pdf/1409.0393.pdf to see one approach.
08:19:36 <OverCoder> doing*
08:19:39 <athan> Or really just unfinished definitions definitions or something
08:19:43 <KaneTW> application goes like (f a) b
08:19:46 <cipher__> KaneTW, thanks. 
08:19:48 <OverCoder> The return is exactly same as the input
08:19:54 <byorgey> fractalsea: that is a rather long version of the paper, if you google around you can probably find a video of a talk given by one of the authors
08:20:19 <fractalsea> byorgey, ah OK. That does sound interesting. I’ll look into it. Thanks :)
08:20:56 <athan> OverCoder: It's like a singleton or something - a _single_ value (...embedded in the structure)
08:21:13 <athan> also notice that this is the same as `pure` from Applicative!
08:21:26 <OverCoder> What does that even mean?
08:21:40 <athan> OverCoder: You were talking about `return`, right?
08:21:41 <geekosaur> OverCoder, the internal structure of a Map is hidden, so the show instance for Map generates a call to fromList
08:21:48 <athan> > return 1 :: [1]
08:21:50 <lambdabot>      Expected kind ‘*’, but ‘1’ has kind ‘GHC.TypeLits.Nat’
08:21:50 <lambdabot>      In an expression type signature: [1]
08:21:50 <lambdabot>      In the expression: return 1 :: [1]
08:21:50 <OverCoder> athan, no, I am talking about the fromList
08:21:59 <athan> > return 1 :: [Int]
08:22:01 <lambdabot>  [1]
08:22:03 <athan> :P
08:22:07 <OverCoder> geekosaur, aw, hm, thanks
08:22:08 <athan> > return :: Maybe Int
08:22:10 <lambdabot>      Couldn't match expected type ‘Maybe Int’
08:22:10 <lambdabot>                  with actual type ‘a0 -> m0 a0’
08:22:10 <lambdabot>      Probable cause: ‘return’ is applied to too few arguments
08:22:19 <athan> OverCoder: D: crud, sorry
08:22:26 <OverCoder> athan, haha it's okay
08:22:47 <athan> > fix (\c -> (fix c))
08:22:49 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ a -> a
08:22:49 <lambdabot>      Relevant bindings include c :: a (bound at <interactive>:1:7)
08:22:49 <lambdabot>      In the first argument of ‘fix’, namely ‘c’
08:23:02 <cipher__> so a monad is defined by two functions, unit and bind(?), unit: a -> f(a), bind: ((f(a) -> a) -> f(b)) -> f(b)? I tended to think of bind as f(a) -> (a -> f(b)) -> f(b).
08:23:43 <dsub> cipher__: looks correct, that's how I think of bind as well
08:24:11 <badmash> hello there 
08:24:21 <badmash> question on lazy evaluation
08:24:40 <cipher__> dsub, okay. thanks
08:25:31 <barrucadu> badmash: Don't ask to ask, just ask
08:25:41 <cipher__> well, I understand the absolute basics of monads, but I don't really understand them. fmap is bind, right?
08:25:43 <badmash> if i have something like this f . g . h $ x, where f, g, h are functions.  then when f is called, do h & g immediately return thunks?
08:26:05 <dsub> cipher__: fmap isn't bind, but liftM which is in Control.Monad is equivalent to fmap
08:26:39 <cipher__> dsub, oh right. for basic monads (like Optional / Maybe) it is equivalent though?
08:26:42 <badmash> barrucadu: yes, i have already asked
08:26:49 <cipher__> basic is a bad term
08:27:18 <dsub> cipher__: You can start by comparing the types of fmap and bind in ghci, that should give you some glimps of how they operate. They are somewhat similar, so I understand your confusion.
08:27:33 <dsub> cipher__: No not really.
08:28:19 <cipher__> dsub, okay. Maybe / optional is basically a one element list? but, okay. 
08:28:27 <dsub> when you fmap something you fmap a function that has the type (a -> b) whereas if you bind some thing you bind a function of type (a -> m b)
08:28:31 <KaneTW> badmash: f is evaluated first
08:28:59 <KaneTW> everything else depends on what f evaluate to
08:29:10 <cipher__> well, alright. that makes sense. 
08:54:25 <JamesJRH> > 1 + 1
08:57:18 <FreeFull> > 1 + 1
08:57:20 <lambdabot>  2
08:58:07 <huylv> >1+1
09:23:17 <zq> @pl \x y -> [x, y]
09:23:17 <lambdabot> (. return) . (:)
09:23:40 <liste> if I saw that in the wild...
09:24:42 <ggVGc> what do you mean, (. return) . (:) is super readable
09:24:49 <ggVGc> right?
09:26:39 <kazagistar> :t (. return) . (:)
09:26:40 <lambdabot> a -> a -> [a]
09:27:40 <kazagistar> oh, derp, I didn't see the @pl
09:46:33 <obadz> if I have a Map k (v1, v2), how do I get the lens over v1? at k . _1 doesn't seem to work.
09:48:18 <pdxleif__> Anyone know the default -O value of cabal configure; build?
09:48:26 <dcoutts> -O1
09:48:40 <dcoutts> or rather -O
09:48:50 <pdxleif__> The cabal docs says --enable-optimization is on by default I think, I just don't know if that means -O or -O1 or -O2 or whatever...
09:48:54 <pdxleif__> Ah, thanks
09:49:00 <dcoutts> since that is by definition ghc's default
09:49:05 <`Guest00000> why can't i browse modules of a package online?
09:49:33 <pdxleif__> You should be able to, on hackage.
09:50:20 <pdxleif__> Are there some that aren't links on the hackage page?
09:51:31 <`Guest00000> pdxleif__: all: https://hackage.haskell.org/package/constraints
09:51:32 <nshepperd> obadz: `at` gives a Lens' to a Maybe rather than just the value itself
09:51:43 <nshepperd> obadz: since that key might not be in the map
09:51:44 <obadz> nshepperd: can I lens through the Maybe?
09:51:53 <obadz> nshepperd: or through an arbitrary functor for that matter?
09:51:58 <nshepperd> you can use _Just and get a Traversal
09:52:13 <`Guest00000> also it was updated 5 days ago
09:52:44 <pdxleif__> `Guest00000: They're links on the 0.6 release, but that's maybe not what you want. I remember fp complete saying they had a mirror for this reason - lemme check
09:53:04 <obadz> nshepperd: works. traversals and lenses compose seemlessly right?
09:53:10 <nshepperd> at 3 . _Just . _1 :: Traversal' (Map Int (a, b)) a
09:53:25 <nshepperd> yeah, you compose it with a lens to get a bigger traversal
09:53:32 <nshepperd> or with another traversal etc
09:53:37 <obadz> cool
09:53:41 <obadz> thx nshepperd 
09:54:07 <`Guest00000> pdxleif__: i found github mirror
09:54:11 <`Guest00000> updated
09:54:19 <`Guest00000> but why can't i browse directly?
09:54:56 <`Guest00000> worked around, but it is mystery still
09:54:57 <pdxleif__> `Guest00000: You can browse those module docs on stackage https://www.stackage.org/nightly-2016-01-19
09:55:26 <pdxleif__> Stackage said that hackage's generation of those was unreliable for some reason, which is why they made their own to host...
09:55:36 <pdxleif__> I don't know the reason, though.
09:56:32 <kadoban> For a long time there was some bug or something where a bunch of them wouldn't get built, which I had understood had been fixed for a long time. I dunno.
09:57:20 <geoffreyiy> @pl (\x -> x == f x)
09:57:21 <lambdabot> ap (==) f
09:57:44 <pdxleif__> https://hackage.haskell.org/package/constraints is from a few days ago, and it still doesn't have the module docs. You see them on stackage, though.
09:57:49 <obadz> nshepperd: is there generic traversal over functors that fmaps?
10:00:33 <obadz> looks like that's mapped
10:01:59 <tommd> jophish: What's the problem exactly?
10:05:36 <gameer> good evening
10:06:12 <gameer> I am learning haskell and now I reched the Monads. Can somebody maybe explain, what Monads are? I have a bit problems with it :/
10:06:55 <obadz> gameer: http://stackoverflow.com/a/194207
10:07:03 <`Guest00000> (==) <*> f... hella obscured
10:07:09 <obadz> gameer: let us know if you have specific questions
10:07:18 <gameer> wooow cool
10:07:20 <gameer> thanks
10:07:23 <gameer> I read it :)
10:09:03 <`Guest00000> i would write (==) <$> f <*> id
10:09:32 <koala_man> gameer: the recent advice on this channel has been to just gloss over it as the theory backing 'do' until you're very comfortable with practical IO and do-notation
10:09:32 <`Guest00000> wait
10:09:36 <`Guest00000> i understood this...
10:09:42 <`Guest00000> suddenly
10:10:11 <ggVGc> good
10:10:25 <ggVGc> the first lesson is that monads are way less of a deal then you might think they are
10:10:31 <ggVGc> and talked about way too much
10:10:47 <vikingofrock> So I'm writing a parser for a binary format (currently using attoparsec), and I would like to limit a parse to the next 80 bytes. What's the best way to do that?
10:11:27 <vikingofrock> optimally I'd like to be able to write a function lengthLimit :: Int -> Parser a -> Parser a
10:11:38 <ggVGc> vikingofrock: you might want to use Binary.Get instead
10:11:44 <ggVGc> but I haven't used attoparsec
10:11:57 <ggVGc> but I did some binary parsing the other day with Binary.Get and it was a piece of cake actually
10:12:56 <koala_man> vikingofrock: you mean you have a parser that can parse arbitrary lengths and you want it to fail if it tries to parse more than 80 bytes?
10:13:59 <nshepperd> obadz: right, mapped is a "Setter", which means all you can do with it is fmap (although you can compose it with lenses and traversal and so on to make bigger Setters)
10:14:25 <vikingofrock> koala_man: yeah that's the idea
10:14:45 <obadz> nshepperd: Setter have functor like behavior? can apply a function (a->b) ?
10:15:01 <vikingofrock> ggVGc: Binary.Get also looks like it would work. I already have a lot written in attoparsec though so I'd rather not switch if I can avoid it
10:15:09 <nshepperd> obadz: yeah exactly
10:15:44 <obadz> nshepperd: cool thx. this world of lenses can lead to very concise expressions but the type signatures aren't always obvious..
10:16:07 <ggVGc> vikingofrock: yeah, of course. I just figured binary.get is probably easier for this kind of thing.
10:16:12 <ggVGc> sorry, can't help with attoparsec though
10:16:46 <vikingofrock> ggVGc: no worries. Thanks for the alternative library recommendation
10:16:51 <m1dnight_> Not sure if this is a proper question, but could somebody give me some pointers in reducing this nesting: https://www.refheap.com/113917
10:17:12 <vikingofrock> ggVGc: if I can't figure out how to do it in attoparsec I'll definitely switch over
10:17:16 <koala_man> in Parsec you could read up to 80 bytes, run your parser on just that, and then setInput on whatever remains
10:17:34 <ggVGc> koala_man: that doesn't really achieve the same thing though, I think?
10:17:43 <ggVGc> since the parser should probably decide when it's done
10:17:47 <ggVGc> and decide how much it wants to read
10:17:58 <thimoteus> m1dnight_: you could break it up into smaller top-level functions
10:18:17 <ggVGc> or where clauses
10:18:23 <vikingofrock> ggVGc: the parser should always read exactly 80 bytes (or fail if there aren't 80 bytes left to read)
10:18:35 <m1dnight_> Ive tried those, but most of the stuff in inside the cases/ifs so thats not scoped to the where clause
10:18:39 <koala_man> ggVGc: yes. you give the parser 80 characters to work with, and if it reads 60 of those you should be able to set the remaining 20 as input for the rest of your code
10:19:01 <ggVGc> vikingofrock: oh, that changes it. Then I would do something along what koala_man suggested. I.e you do the reading of 80 bytes first, and if you got it, you send it to the parser
10:19:05 <ggVGc> I think that makes sense
10:19:36 <vikingofrock> ggVGc: yeah I guess implementing it as a sub-parser works
10:19:39 <koala_man> not sure how to do that in attoparsec though
10:19:45 <vikingofrock> ggVGc: seems a little less clean to me
10:19:54 <vikingofrock> thanks guys
10:20:00 <ggVGc> m1dnight_:it will work out if you parameterize the expressions in the where clauses more
10:20:25 <ggVGc> vikingofrock: maybe, but it's probably what I would have done. I'm not very experienced in haskell at all though
10:21:02 <koala_man> I think I would write the relevant functions in such a way that they don't parse more than what's valid
10:21:53 <ggVGc> my personal method is to do it right from the beginning and finish with big time margins
10:21:56 <koala_man> but I don't know the use case or file format
10:22:01 <ggVGc> I can't seem to quite do it mostly though
10:22:26 <koala_man> given your nick I guess your solution is "start over!!" 
10:22:38 <ggVGc> koala_man: with the lessons from previous attempts!
10:23:03 <jophish> tommd: this: https://github.com/TomMD/JuicyPixels-repa/issues/4
10:28:13 <jophish> Could someone familiar with repa give me a little guidance: I have an image, where the pixels are stored left to right, top to bottom, so the data looks like RGBRGBRGBRGB (the extents of the array are (Z :. height :. width :. 3)). I have an algorithm in C which requires the data as RRRRGGGGBBBB, so I thought that `backpermute (ix3 3 height width) (\(Z :. c :. y :. x) -> Z :. y :. x :. c)` Would transpose 
10:28:20 <jophish> this the way I want, but I just can't seem to get that to work
10:30:30 <robin`> Is there any regex library in haskell that I can use on my custom containers? (Maybe I need to implement some typeclass or so)
10:31:46 <dsub> robin`: take a look at http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html
10:31:49 <statusfailed> When the file-embed library runs, what does it take as the root directory?
10:32:25 <dsub> robin`: There are multiple regex libs. However, I haven't used any, so cannot help.
10:38:37 <makalu> a Data.Vector is not strict in the elements is it? If I use 'generate' for example, I get a vector of thunks, right?
10:46:42 <dolio> makalu: Right.
10:47:40 <makalu> interesting. I used the parallel library, added parTraversable rdeepseq to vector map and the program is slower...
10:48:25 <makalu> then I used vector mapM and 'rparWith rdeepseq' in the mapper and now it's even slower :)
10:48:39 <ReinH> makalu: that doesn't seem like a good thing to do
10:48:45 <ReinH> deepseq isn't usually something you want
10:48:57 <ReinH> why are you trying to do that?
10:49:15 <makalu> I want to parallelise the computation
10:49:25 <ReinH> Have you read Simon Marlow's book?
10:49:37 <makalu> only small bits of it
10:49:42 <ReinH> Well, you should read it
10:49:52 <ReinH> since it's about your problem
10:50:43 <makalu> rseq isn't any better
10:51:24 <ReinH> Read the book dude
10:52:28 <obadz> Can I compose a traversal that returns a maybe with a lens that takes a value with certainty?
10:52:55 <gameer> I dont get it
10:52:56 <obadz> so like "at k . _Just . _1"
10:53:07 <gameer> Is the Magic of Monads only the ">>=" ? :D
10:53:11 <obadz> but where the values of the Map are not monoids
10:53:21 <obadz> gameer: s/magic/definition/
10:53:37 <gameer> hm?
10:53:56 <obadz> gameer: the definition of monad is pretty much something that has a >>= function
10:54:02 <obadz> (and that's also applicative)
10:54:19 <mniip> you're forgetting the monad laws
10:54:24 <obadz> yes yes..
10:54:32 <mniip> that's pretty important stuff
10:55:12 <gameer> monad laws?
10:56:28 <obadz> gameer: https://wiki.haskell.org/Monad_laws
10:58:36 <dsub> gameer: Understanding "return" and (>>=) is a better start than reading up on the monad laws. Once you understand the functions, understanding the laws will be a piece of cake - but not so much the other way around.
10:59:00 <gameer> okay
10:59:17 <gameer> Would you recommend the chapter about monads in learnyouahaskell?
10:59:23 <gameer> Then I would read that first
10:59:24 <Zekka> I mean, there's a particular kind of person who hears the word "associativity" and they know exactly what it means in any context
10:59:44 <Zekka> But I think most of the people who already know how to think that way probably had to wrestle with something worse than monads to get to that point
11:00:10 <dsub> gameer: Yes, learnyouahaskell is a good start. And, of course, start with functors before going to monads.
11:00:15 <obadz> gameer: are you comfortable with "IO" before monad?
11:00:23 <gameer> IO D:
11:00:30 <gameer> I read the first 8 chapters yet
11:00:36 <obadz> gameer: yes, the Haskell IO objects
11:00:47 <obadz> or datatypes rather
11:00:57 <gameer> datatypes i know
11:01:15 <gameer> Chapter 8 was about that
11:01:16 <obadz> no I mean the specific datatype called IO
11:01:33 <gameer> hm i dont know it
11:01:41 <aweinstock> @where typeclassopedia
11:01:42 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
11:02:06 <gameer> hey aweinstock 
11:02:23 <obadz> gameer: I would start by learning how that works. Then move on to monads which are one way to generalize IO
11:02:33 <gameer> Have to say thank you again, the task with the trees was good :s
11:02:46 <gameer> Okay obadz , thanks :)
11:03:37 <dsub> obadz: I disagree, I must say. The IO monad is pretty much the only monad that you can study that teach you nothing about monads and is the only one that really seems "magic"
11:04:21 <gameer> :s
11:04:32 <ggVGc> dsub: because it very much is magic..
11:04:49 <ggVGc> and also compeltely "wrong" in the context of haskell
11:04:57 <obadz> dsub: right but tbh you can get by without monads for a long while. Except for IO. IO is the first reason people learn what monads are in Haskell.. 
11:05:01 <Cale> The IO monad can teach you as much about monads as any other monad can.
11:05:05 <ggVGc> or rather the context of referentially transparent programs
11:05:15 <aweinstock> gameer: typeclassopedia is a good way to understand functor/applicative/monad in general
11:05:16 <Cale> But it's hard to learn about an abstraction from any one example
11:05:38 <ggVGc> Cale: I think the issue is that most people don't approach the term "Monad" as the name for an abstraction
11:05:43 <ggVGc> but rather a language feature
11:05:46 <ggVGc> or something like that
11:05:48 <dsub> Well, it is kind of an obscure State-monad. Yes, you can do alot without monads, everything if you dont mind a lot of boiler-plate. But if one wants to learn monad, I think the IO monad should be avoided.
11:05:53 <ggVGc> which leads to a lot of issues
11:06:04 <obadz> How do I fix this expression: view (Control.Lens.at 2 . _1) (M.fromList [ (2, (3, 4)) ]) ?
11:06:11 <maerwald> Cale: the IO Monad is awkward and not really nice for any kind of teaching
11:06:12 <obadz> I'd ideally want it to be :: Maybe Int
11:06:19 <dolio> It's not a state monad.
11:06:24 <dsub> No
11:06:29 <ggVGc> dsub: it's not really a state monad since the State can be randomly changed without you changing it
11:06:52 <Cale> Yeah, IO isn't a state monad, it's a monad of descriptions of actions to be performed.
11:07:23 <obadz> dsub: if one specifically wants to learn monads I agree. But mostly beginners want to learn monads because they need IO for basic things.. We can encourage them to learn IO without monads at first 
11:07:38 <maerwald> when you teach about Monads, you don't want to introduce additional confusion about IO
11:07:41 <Cale> obadz: I agree about that
11:07:50 <dsub> I know it isn't a state monad, hence the word "obscure". But one can think of it as "data IO a = OutsideWorld -> (a, OutsideWorld)" once one understand state monad. Its actually a good text about the IO monad that dives in to that specific topic.
11:07:59 <ggVGc> it also is very weird/wrong/magic in the sense that IO actions execute the moment they are scheduled
11:08:12 <dolio> No, you can't think about it that way. That isn't a proper model.
11:08:15 <Cale> ggVGc: what?
11:08:29 <obadz> ggVGc: hmmmm what do you mean?
11:08:30 <ggVGc> well, yeah. that statement was maybe not very correct
11:08:36 <ggVGc> I retract it
11:08:40 <obadz> ok :)
11:08:42 <ggVGc> I was thinking a bit strange I guess
11:08:45 <Cale> ggVGc: The time at which IO actions are executed is very different from the time at which the monad operations on IO are doing anything.
11:08:45 <dsub> https://wiki.haskell.org/IO_inside
11:09:06 <aweinstock> obadz: try (^?)
11:09:20 <maerwald> dsub: that metaphor/data type doesn't fly for concurrency and other stuff
11:09:29 <ggVGc> Cale: yeah, what I was getting at is that you have to think in a quite special way while in the IO monad compared to the rest of any code, using monads or not
11:09:39 <dolio> You don't even need concurrency to mess it up.
11:09:47 <dolio> Just infinite loops.
11:09:48 <Cale> ggVGc: I'm not sure I really agree about that even...
11:09:53 <maerwald> I know SPJ introduced it, but it's often discouraged to use
11:10:00 <Cale> ggVGc: IO has the property that it's an abstract data type
11:10:12 <Cale> ggVGc: Which makes it a little harder to grasp what's taking place
11:11:43 <Cale> ggVGc: But you can imagine that IO action values are physical descriptions of stuff that your computer ought to do, and the monad operations glue these descriptions together in various ways.
11:11:58 <obadz> aweinstock: that works for at alone, but not for at k . _1 ?
11:12:20 <Cale> ggVGc: An approach via free monads is way more realistic than one via State.
11:13:39 <Cale> ggVGc: During evaluation, none of the effects of IO actions are carried out. Execution is a separate process which picks apart the description and actually does what it says to do.
11:14:30 <ggVGc> Cale: yeah, that was a misunderstanding on my part
11:14:35 <ggVGc> thanks for clearing it up :)
11:17:07 <obadz> Cale: well the effects of IO monads are only evaluated by the runtime outside of the language right? Simlarly to runState evaluating the statemonad actions, except runIO does not exist (well it's unsafePerformIO)
11:17:15 <obadz> not sure why Free monads are a more appropriate analogy..
11:18:02 <Cale> obadz: Because IO might be a free monad -- there exists a free monad which could actually do exactly the job that IO does, and it could be implemented that way.
11:18:08 <dolio> Because free monads (in Haskell, at least) are rich enough types to represent infinitely large computations.
11:18:34 <Cale> However, there's no type s for which IO = State s could really work as an implementation.
11:18:35 <dolio> And W -> (a, W) is not.
11:19:14 <Cale> If you look at GHC's implementation you could be given the mistaken idea that State RealWorld would do, but in order to make that work, you have to cheat lots using unsafePerformIO and impure functions.
11:19:40 <dolio> In a language where free monads are finite, they also wouldn't be good enough for IO.
11:19:51 <Cale> Basically what GHC is doing is using a trivial State monad on a 0-bit-wide token state type to cajole the evaluator into not evaluating impure functions in the wrong order.
11:19:51 <dolio> Like, Agda uses codata.
11:20:03 <Cale> However, that's a *terrible* mental model of IO
11:20:29 <obadz> I fail to see why State RealWorld is a wrong mental model. Could you expand?
11:20:57 <Cale> obadz: Because RealWorld in GHC is 0 bits of data? :)
11:21:04 <aweinstock> > fmap (view _1) ((M.fromList [ (2, (3, 4)) ]) ^. Control.Lens.at 2) -- obadz
11:21:07 <lambdabot>  Just 3
11:21:28 <Cale> obadz: and even if you imagine that it's something really complicated, it doesn't manage to explain concurrency
11:21:35 <aweinstock> although that doesn't feel very lens-y to me (it doesn't provide a composed lens that you can also set through)
11:21:57 <obadz> Cale: the fact that the RealWorld type is a theoretical construction does not shatter the mental model. What functor would you use as the base for the free monad version?
11:22:46 <Cale> obadz: Something involving constructors for a large number of IO primitives (and/or perhaps some very general ones containing the data necessary to make an FFI call)
11:22:54 <obadz> aweinstock: yep exactly, looking for a lens version...
11:23:21 <dolio> obadz: Consider `putChar :: Char -> World -> World` and `putForever w = putForever (putChar 'a' w)`. What makes `putForever` a different function, semantically, than `nothingForever w = nothingForever w`?
11:23:43 <Cale> dolio: good point too :)
11:23:52 <dolio> The answer is: one has side effects.
11:24:10 <dolio> So this model has failed to remove side effects from the language semantics.
11:24:39 <Cale> It's easier to write down the description of the free monad you'd use for IO using a van Laarhoven style encoding.
11:24:44 <Cale> Something like
11:26:00 <Cale> data Effect m = E { getCharEff :: m Char, putCharEff :: Char -> m (), forkIOEff :: m a -> m ThreadId, ... many other things ... }
11:26:30 <Cale> newtype Free effect a = Free { runFree :: forall m. Monad m => effect m -> m a }
11:26:44 <Cale> And then you'd use  Free Effect = IO
11:27:17 <obadz> dolio: I'm afraid I'm not quite at the point where I get it
11:27:32 <johnw> did something happen recently to make van Laarhoven free monads popular?
11:27:46 <Cale> johnw: I dunno, I've been recommending them to people
11:27:50 <Cale> heh
11:27:54 <johnw> Cale: why do you recommend them?
11:28:36 <obadz> dolio: is there an example that doesn't involve comparing two functions that are both bottom? (I think?)
11:29:13 <dolio> obadz: The point is that they're both bottom, according to a pure semantics. Or `\w -> bottom` if that can be distinguished.
11:29:16 <Cale> johnw: Well, it's easier than for other models of free monads to see directly what your operations are.
11:29:26 <dolio> But they are expected to behave differently.
11:29:37 <Cale> johnw: and it tends to be easy to implement evaluators for them
11:29:58 <johnw> ah, true, your data Effect maps very closely to the types of the expected methods
11:30:04 <dolio> One should print 'a' forever, and the other shouldn't.
11:30:10 <Cale> (all you have to do is make a record of the implementations of the operations)
11:30:17 <obadz> dolio: why would they be expected to behave differently. They'll both not terminate and do nothing along the way?
11:30:22 <johnw> I wonder how van Laarhoven happened upon this encoding
11:30:37 <obadz> dolio: oh, misread the definition
11:31:16 <Cale> johnw: I'm not even 100% sure it's due to him tbh, though I figure his name is as good as any :)
11:31:24 <dolio> obadz: One is the equivalent of writing `forever (putChar 'a')`, which I expect to put stuff on the screen. :)
11:32:00 <johnw> Cale: I'm not finding it mentioned on his blog or in his publications, which is odd given the excitement around algebraic effects lately
11:32:06 <Cale> yeah
11:32:09 <obadz> dolio: you're saying putForever will not print stuff on the screen using a State World definition?
11:32:46 <dolio> No. I'm saying it has to. But that means the semantics of functions has to include side effects.
11:33:00 <dolio> Because otherwise it is equal to a function that doesn't print stuff to the screen.
11:33:13 <dolio> According to the expected domain semantics.
11:33:14 <meoblast001> https://gist.github.com/meoblast001/38811ff1f4647c33e9e2
11:33:16 <Cale> I mean, this thing needs a name, and Russell O'Connor named it after him here http://r6.ca/blog/20140210T181244Z.html and then Aaron Levin wrote a tutorial here http://aaronlevin.ca/post/136494428283/extensible-effects-in-the-van-laarhoven-free-monad
11:33:19 <meoblast001> does anyone know why it is this hangs?
11:33:24 <meoblast001> it hangs at line 15
11:33:28 <Cale> and I've been suggesting similar things for a long long time on IRC :)
11:33:30 <meoblast001> i'm not sure if i'm using System.Process correctly
11:33:50 <obadz> dolio: you're saying functions can't be pure anymore for this to work? what does it mean "semantics has to include side effects" ?
11:33:50 <Cale> and I figure I might as well run with the name people are using for this, which I didn't previously have a name for
11:33:59 <dolio> obadz: Right.
11:34:41 <dolio> obadz: It means there's no way to look at it other than what Cale said. That IO is just a wrapper to ensure that side-effectful functions happen in the right order. Which is undesirable.
11:35:36 <Cale> johnw: As for the monad itself, it's sort of the obvious next thing to do in a series of steps starting from doing OO design in Haskell by making records of methods
11:35:59 <dolio> Cale: It's Ran U 1, where U is the forgetful functor from Monads to type constructors.
11:36:00 <obadz> dolio: I actually think I'm getting there
11:36:25 <Cale> dolio: Well, heh, there's also the highbrow way of looking at it :D
11:36:29 <johnw> Cale: yeah, true, from that perspective it's more natural
11:36:45 <dolio> Cale: Works for lots of stuff, too. :)
11:36:48 <Cale> But I like the lowbrow "anyone could have come up with this without knowing much mathematics" way
11:37:18 <Cale> You start out making monomorphic records of methods
11:37:19 <johnw> Cale: have you tried using that Free representation in Coq yet?
11:37:20 <dolio> And people should learn the highbrow way, because then they can test for the existence of lots of similar stuff by rote. :)
11:37:26 <Cale> whose results are in, say, IO or something
11:37:49 <Cale> and then hey, it would be nice if I could guarantee that some things didn't use arbitrary IO operations
11:38:03 <Cale> but just the things in the record(s) I give them
11:38:13 <obadz> dolio: I'm there!
11:38:21 <Cale> So I'll abstract IO to an arbitrary monad m, and give my record type a monad type parameter
11:38:23 <dolio> obadz: Cool.
11:38:36 <Cale> and write functions with types like  Effect m -> m t
11:38:42 <JamesJRH> > 1 + 1
11:38:56 <dolio> Cale: It's a little dicier in Coq. You'd have to turn on impredicative Set.
11:38:57 <obadz> yeah the analogy with an interpreter is more direct than that with a stateful variable
11:39:14 <Cale> and then it just becomes a convenience thing: I don't want to pass around these Effect m things manually, let's just define a monad which does that
11:39:31 <obadz> ok so now, my lens issue? :) > view (at 2 . _1) (M.fromList [ (2, (3, 4)) ] -- surely there is a way?
11:43:51 * hackagebot NTRU 1.0.0.1 - NTRU Cryptography  https://hackage.haskell.org/package/NTRU-1.0.0.1 (mikewest)
11:44:20 <dolio> Oh, maybe my last statement should have been aimed at johnw.
11:44:37 <johnw> dolio: https://gist.github.com/a21e92897d426998d818
11:44:46 <johnw> have to run to lunch now, will look further later
11:45:34 <cocreature> obadz: what are you trying to do?
11:46:31 <obadz> cocreature: trying to get an element out of a map, and then apply a record accessor. If the element isn't there, I'd be fine getting a Nothing
11:46:39 <obadz> cocreature: wondering if I can do that fully within lens
11:46:41 <dolio> johnw: I suppose that works, as long as you don't care about having an infinite number of levels of monads.
11:46:44 <obadz> or do I have to fmap it
11:47:26 <johnw> dolio: ah: Definition foo : IO nat := fun m H e => @getCharEff m e.
11:47:37 <johnw> it was the implicit context biting me
11:47:49 <johnw> so, I'll need syntax magic to make this a bit nicer
11:48:10 <dolio> In general you'd run into the problems with Church numerals, though.
11:48:21 <cocreature> obadz: you can compose it with a prism, so _Just in this case
11:48:26 <johnw> dolio: how do you mean?
11:48:52 <obadz> > view (at 2 . _Just . _1) (M.fromList [ (2, (3, 4)) ]
11:48:53 <cocreature> > M.fromList [(2,(3,4)] & at 2 . _Just . _1 %~ (+1)
11:48:55 <lambdabot>  <hint>:1:53:
11:48:55 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:48:56 <dolio> Predicative numerals can't have certain functions defined on them, because you need to instantiate the quantifier to the type of numerals.
11:48:57 <lambdabot>  <h
11:49:04 <cocreature> > M.fromList [(2,(3,4))] & at 2 . _Just . _1 %~ (+1)
11:49:06 <lambdabot>      Ambiguous occurrence ‘at’
11:49:06 <lambdabot>      It could refer to either ‘Control.Lens.at’,
11:49:06 <lambdabot>                               imported from ‘Control.Lens’ at /tmp/mueval2694...
11:49:14 <cocreature> > M.fromList [(2,(3,4))] & Control.Lens.at 2 . _Just . _1 %~ (+1)
11:49:17 <lambdabot>  fromList [(2,(4,4))]
11:49:28 <obadz> I don't want to apply (+ 1), I'd like to get the value
11:49:28 <dolio> But the type of numerals is bigger than the types that the numerals quantify over.
11:49:36 <obadz> applying (+ 1) works
11:49:54 <cocreature> obadz: you can’t view a prism, because it might contain nothing but there is (^?) which gives you a maybe
11:50:23 <cocreature> > M.fromList [(2,(3,4))] ^? Control.Lens.at 2 . _Just . _1 
11:50:26 <obadz> cocreature: of that works now
11:50:27 <lambdabot>  Just 3
11:50:32 <obadz> cocreature: for some reason I couldn't get it to work before
11:50:34 <obadz> cocreature: thanks!!!
11:50:39 <cocreature> yw
11:50:39 <obadz> s/of/oh/
11:51:04 <dolio> johnw: You can't define the Ackermann function on predicative numerals for instance, I think.
11:52:45 <obadz> ok last one, view is to use as previous is to XXX ?
11:54:13 <obadz> preuse!
11:54:27 <obadz> so much stuff to memorize with lenses :(
11:54:44 <dolio> johnw: So, I think technically 'Free' defined that way is not free, because there might be 'big' monads that you cannot eliminate into from Free.
11:55:33 <dolio> You have to pick a level for your Free to live at, and it is only free with respect to monads below that level.
11:55:47 <cocreature> obadz: preview?
11:56:26 <obadz> cocreature: preview = ^?
11:56:41 <cocreature> oh wait preuse was the answer to your question. I was confused because you wrote previous and I thought you corrected that to preuse
11:57:05 <obadz> use preuse was the answer
11:57:20 <obadz> sorry first day in lens here.. in over my head.
11:57:27 <dolio> I'm unsure if the fixed point version has the same issue.
11:59:28 <dolio> johnw: The other way to look at it is that if you fix monads up to a certain size, then Free is not the free monad of that size, because it is necessarily bigger.
12:00:56 <meoblast001> in System.Process do i need to send some kind of EOF character?
12:01:31 <cocreature> meoblast001: to accomplish what?
12:01:51 <meoblast001> if i am using a pipe and i am trying to send data to a process that appears to never be ending
12:02:16 <cocreature> depends on the process, but often an EOF is the right thing to send
12:02:37 <meoblast001> how do i get the EOF character?
12:02:47 <meoblast001> is there some constant defined already in Prelude?
12:02:50 <Cale> > '\EOF'
12:02:51 <lambdabot>  <hint>:1:3:
12:02:51 <lambdabot>      lexical error in string/character literal at character 'E'
12:02:56 <Cale> er, hm
12:03:06 <shachaf> What is the EOF character?
12:03:21 <meoblast001> apparently simultaneously 0x03 and non-existent
12:03:24 <meoblast001> that is what stack overflow tells me
12:03:53 <Cale> Yeah, I was thinking you wanted to send some ASCII control code, but probably all you're really looking to do is close the handle
12:04:23 <Cale> There is
12:04:27 <Cale> > '\ETX'
12:04:29 <lambdabot>  '\ETX'
12:04:39 <Cale> for end-of-text, but I don't know how many things use that
12:05:44 <cocreature> we use that in hie :)
12:06:28 <meoblast001> ugh.. no matter what i do it does not want to end :X
12:06:41 <Cale> meoblast001: Try closing the handle you're using to give the program input
12:06:45 <cocreature> meoblast001: closing the handle doesn’t work?
12:06:48 <meoblast001> i did close it
12:06:52 <Cale> hm
12:06:55 <meoblast001> current status: https://gist.github.com/meoblast001/80b00206731f718e3e14
12:07:23 <meoblast001> over the command line if i do: coffee -cs < js/places.coffee, it spits out junk
12:08:15 <Hafydd> meoblast001: you're waiting for it to close before you read the output. That's probably causing a deadlock.
12:08:37 <Hafydd> You may need to do that in a separate thread.
12:09:04 <meoblast001> hmmm
12:09:33 <meoblast001> or instead of doing that i could keep reading until i get an EOF
12:09:48 <Hafydd> Or... just don't wait for it, I suppose.
12:10:28 <Hafydd> Or wait for it after reading!
12:10:32 <kadoban> Has anyone used blaze-ghcjs , the renderer for blaze-html using ghcjs-dom I guess? Wondering if it's even like a working thing, all I see is a tiny github repo with nothing recent.
12:13:04 <mjhoy> i'm getting an unexpected result with System.Posix.Files.isSymbolicLink ... false for something that is definitely a symbolic link! what might i be missing?
12:13:51 * hackagebot bini 0.1.4 - A collection of various methods for reading and writing bini files.  https://hackage.haskell.org/package/bini-0.1.4 (TWeise)
12:14:47 <meoblast001> hm wtf
12:14:56 <meoblast001> when i don't wait.. it finishes doing everything, then the program hangs afterwards
12:16:07 <meoblast001> let's see what happens if i sprinkle terminateProcess in there
12:16:15 <meoblast001> okay then it works lol
12:16:55 <Hafydd> meoblast001: do you mean the subprocess hangs (keeping the terminal open), while the main process exits?
12:17:06 <meoblast001> no, Hakyll hangs
12:17:23 <meoblast001> it says "updated js/places.js" and then does nothing
12:17:41 <Hafydd> What operation is is hanging on? The read?
12:18:14 <Hafydd> Is stderr also directed to a pipe? If so, is that perhaps getting blocked?
12:19:14 <mjhoy> ghci> liftM isSymbolicLink $ getFileStatus "/home/mjhoy/.vim"  -- => false
12:19:33 <mjhoy> ghci> readSymbolicLink "/home/mjhoy/.vim" -- => "/home/mjhoy/.dotfiles/vim"
12:19:48 <mjhoy> i don't understand...
12:20:10 <meoblast001> https://hackage.haskell.org/package/process-1.4.1.0/docs/src/System-Process.html#readCreateProcess
12:20:11 <meoblast001> hmmm
12:20:24 <meoblast001> Hafydd: it's hard to tell.. it tells me it completes everything
12:20:26 <meoblast001> then Hakyll hangs
12:20:35 <meoblast001> but Hakyll does not hang if i comment out the compiler
12:20:35 <geekosaur> mjhoy, need to use getSymbolicLinkStatus
12:20:43 <Hafydd> Hmm.
12:21:00 <geekosaur> it mirors POSIX, stat() follows the symlink and will never give you S_ISLNK, lstat() doesn't follow it
12:21:12 <mjhoy> geekosaur: ooooh.
12:21:22 <mjhoy> geekosaur: so how do i tell if a particular filepath is a symlink?
12:21:24 <meoblast001> i might want to use readCreateProcess
12:21:50 <geekosaur> I just told you, getSymbolicLinkStatus (which is what the unix package calls lstat())
12:22:11 <mjhoy> i see, that will work for normal filepaths too.
12:22:28 <geekosaur> yeh, it ought to be nnamed getFileStatusNoFollow
12:22:30 <geekosaur> or something
12:23:00 <meoblast001> wooo
12:23:01 <meoblast001> this works :)
12:23:45 <Hafydd> meoblast001: I suppose it's because of lazy I/O, or something like that.
12:24:22 <aphorisme> can anyone provide a good paper on the functional part of c++ meta programming?
12:24:23 <Hafydd> (I remember almost the same thing happening to me a few months ago, but I can't remember the details - I also looked at readCreateProcess's implementation for inspiration.)
12:25:08 <juanpablo_> is there a library that exports something like (fmap.fmap) or (fmap.fmap.fmap)? At least fmap.fmap is so useful it must be defined somewhere
12:25:21 <bitemyapp> juanpablo_: yes there is
12:25:29 <juanpablo_> Lens?
12:25:34 <Welkin> fmap2?
12:25:50 <bitemyapp> Welkin: it's prettier than that.
12:25:59 <Welkin> <$$>
12:26:13 <bitemyapp> juanpablo_: athan's library I think
12:26:26 <juanpablo_> bitemyapp: is it in Hackage?
12:27:40 <syver> Hello
12:27:53 <bitemyapp> juanpablo_: yes
12:28:16 <juanpablo_> bitemyapp: what's the name? My google-fu is weak today
12:28:49 <juanpablo_> I call it dmap, but it's too easily confused with dimap
12:29:25 <bitemyapp> juanpablo_: https://www.google.com/search?q=data+functor+athan&oq=data+functor+athan&aqs=chrome..69i57j69i64l2.4159j0j7&client=ubuntu&sourceid=chrome&es_sm=93&ie=UTF-8
12:29:42 <syver> I'm working my way through the haskell programming from basic principles book, and I'm stuck on one of the excercises, where I'm supposed to rewrite the function "roundTrip = read . show" so it fits the type roundTrip :: (Show a, Read b) => a -> b 
12:30:16 <juanpablo_> bitemyapp: thanks
12:30:22 <meoblast001> issue solved :) https://github.com/meoblast001/meosite/commit/33212addf4409b593893c2c3352ff7a9413d5259
12:33:29 <bitemyapp> juanpablo_: cheers :)
12:44:15 * hackagebot herf-time 0.1.0 - haskell time manipulation in a 'kerf like' style.  https://hackage.haskell.org/package/herf-time-0.1.0 (scottmurphy09)
12:46:37 <kadoban> Shocking, blaze-ghcjs is totally outdated :-/ I wonder how hard it'll be to fix up.
12:49:15 * hackagebot herf-time 0.2.0 - haskell time manipulation in a 'kerf like' style.  https://hackage.haskell.org/package/herf-time-0.2.0 (scottmurphy09)
12:55:27 <cocreature> is there some nice package for managing some sort of threadpool where the number of threads should never get higher than a set number n or does everybody just build it quickly themselves when they need it?
12:57:02 <geekosaur> http://hackage.haskell.org/package/async-pool ?
12:57:59 <cocreature> geekosaur: perfect, thanks
13:06:59 <nxtr> part
13:19:23 <gameer> I am still reading in lyah about instance of Functor: IO   and dont understand anything -.-
13:20:47 <Cale> gameer: Okay, so values of type IO t are basically descriptions of things which could be carried out in order to produce a result of type t (provided they terminate normally, and don't run forever, or throw an exception)
13:21:58 <Cale> gameer: You should think of the difference between a value of type IO String, and a value of type String as being a lot like the difference between /bin/ls and a list of files in your home directory. The former is a program which will give you the list of files whenever you run it, the latter is a bunch of text.
13:22:05 <Cale> gameer: Good with that?
13:22:21 <gameer> need a moment, I am not so fast with english
13:22:24 <Cale> okay
13:22:59 <Cale> For example, we have
13:23:02 <Cale> getLine :: IO String
13:23:17 <Cale> which describes the action of getting a line of text from the user on the terminal
13:23:28 <Cale> as well as
13:23:34 <Cale> putStrLn :: String -> IO ()
13:23:40 <mauke> if there's something you don't understand, I can try to translate it to German
13:23:52 <Cale> which is a function that given some string, will produce the action that will print that string to the terminal
13:24:02 <tsahyt> Cale: Are IO actions actually just interpreted at runtime or does GHC compile them to their corresponding calls directly?
13:24:18 <mauke> the ghc implementation cheats :-)
13:24:19 <Cale> tsahyt: GHC compiles them to something more direct
13:24:20 <athan> Are state morphisms mainstream yet? Like `mapStateT :: (s1 -> s) -> (s -> s1) -> StateT s m a -> StateT s1 m a`
13:24:28 <tsahyt> Okay, thanks!
13:25:06 <Cale> tsahyt: (but it's perfectly okay to think of it as running an interpreter that is lazily evaluating the IO actions, and carrying out the steps they describe as it goes)
13:25:28 <Cale> (actually executing the steps isn't lazy, just the evaluation of which action it is that you have)
13:27:04 <Cale> So when you run your program, it will evaluate enough of main to determine what the first thing to do is, and then do that, and carry on with the rest (often what to do next will depend on the result of that first action)
13:28:04 <Cale> athan: I don't know what counts as mainstream -- mapStateT has been in the library a long time if I recall correctly
13:28:23 <Cale> athan: as for whether people actually use it very much, I suspect the answer is probably not
13:28:39 <Cale> (not for any special reason, just that it's an unusual thing to really need)
13:28:41 <gameer> On what page I can insert haskell code?
13:28:57 <mauke> for us to look at?
13:28:58 <gameer> to show it to you
13:28:59 <mauke> @where lpaste
13:28:59 <lambdabot> http://lpaste.net/
13:29:00 <gameer> yes
13:29:06 <gameer> thanks
13:29:16 <Cale> gameer: So, anyway, you asked about Functor
13:29:27 <gameer> yes, wait a minute
13:29:44 <gameer> In lyah there is this: http://lpaste.net/150412
13:29:54 <Cale> gameer: fmap :: (a -> b) -> IO a -> IO b  is a function which takes a function from values of type a, to values of type b, and it takes one of these IO action values, whose result will have type a when it is run
13:30:15 <Cale> and it produces an IO action whose result will have type b when it is run
13:30:24 <gameer> I dont understand these "actions"
13:30:39 <gameer> Are the actions for example putStrLn?
13:30:51 <Cale> putStrLn "hello"  is an IO action
13:30:52 <mauke> actions are values of type IO Something
13:30:58 <Cale> yeah
13:31:05 <mauke> what programming languages do you know?
13:31:35 <gameer> mauke: Yre u from germany?
13:31:39 <gameer> Are*
13:31:42 <mauke> ja
13:31:58 <gameer> Darf ich kurz im Query schreiben?
13:33:31 <monsieurp> du darfst
13:34:07 <athan> Cale: I don't think that one is a state morphism though :\ it's actually just embedding a state endomorphism and a value mapping
13:34:45 <athan> I'm looking for one where the value us untouched, but I'm able to (invariantly) map the state to a new type
13:34:51 <Cale> athan: I don't really know what you mean by "state morphism"
13:35:19 <athan> Cale: It's where you change the state :|
13:35:28 <athan> State s a -> State s1 a
13:35:58 <Cale> There definitely exists a map  (s -> s1) -> (s1 -> s) -> State s a -> State s1 a
13:36:06 <mauke> no revolution!
13:36:41 <athan> Cale: But why isn't it defined for use currently?
13:36:43 <athan> :(
13:36:46 <Cale> Isn't it?
13:36:54 <athan> I haven't seen it
13:37:03 <athan> that's what I'm asking haha
13:37:09 <athan> if it exists yet :x
13:37:59 <zd234> with leveldb, I can store key-value where (key :: ByteString) and (value :: ByteString). I'd also like a nice way to store Haskell Lists and Haskell Maps. Is there a nice way to do this? is leveldb even the right db to use?
13:38:36 <athan> zd234: Are you just looking for a key-value cache?
13:38:44 <Cale> athan: I could have sworn that already existed somewhere.
13:38:53 <Cale> (like in mtl or something)
13:39:00 <Cale> but I'm not finding it now either
13:39:07 <athan> Cale: I asked on reddit ~6 months ago, everyone was like "shit, why don't we have this?" lol
13:39:16 <johnw> that sounds like something a lens Iso would do
13:39:24 <athan> :(
13:39:29 <zd234> athan: more than "cache"; I want it to be persistent, to exist through different runs of the program; I definitely want a DB of some sort
13:39:44 <athan> zd234: Have you looked into STM?
13:39:55 <zd234> athan: software transactional memory?
13:39:57 <athan> That's a non-persistent one
13:39:59 <athan> yeah
13:40:05 <zd234> I want persistence
13:40:12 <zd234> I need a DB of some sort.
13:40:15 <athan> zd234: Check out vcache
13:40:17 <Cale> zd234: Maybe try the persistent library?
13:40:29 <athan> it uses leveldb as its backend iirc :)
13:40:30 <Cale> Or groundhog
13:40:56 <wraithm> zd234: There's also acid-state.
13:41:11 <zd234> athan: from vcache page: he virtual address space is modeled above a memory mapped file via LMDB ... sounds like it uses LMDB, not levelDB
13:41:18 <athan> herp
13:41:20 <athan> sorry :x
13:41:41 <Cale> acid-state is cool whenever you don't need a more traditional database backend, and your DB will fit into memory
13:42:53 <Cale> zd234: If you're set on using leveldb, I guess you'd want to use something like binary with it to encode your Haskell datastructures as ByteStrings
13:43:10 <wraithm> Yeah, it just sounded like zd234 wanted to store Haskell data types. Idk if it makes sense for zd234's use-case.
13:43:46 <wraithm> *easily store
13:46:14 <wraithm> Also, opaleye is a pretty awesome way to write queries for postgresql. That is a nice alternative to groundhog/persistent's quasi-ORM model.
13:49:35 <WarzoneCommand> Can anyone explain to me why I get this compile error: http://lpaste.net/150413 ? 
13:50:49 <WarzoneCommand> (where V and MV are Data.Vector and Data.Vector.Mutable). 
13:51:46 <zd234> Data.Binary
13:52:05 <Phyx-> hmm given a GHC.IO.Handle, is there a way to get an FD or the underlying OS Handle from it? There is an "fdToHandle" but I can't find a "handleToFd"
13:52:06 <WarzoneCommand> GHC seems not able to match the state types, even if I explicitly annotate the result of MV.replicate by : forall s. ST s (MVector s [VertexID])
13:54:46 <geekosaur> Phyx-, https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/unix-2.7.1.0/System-Posix-IO.html#v:handleToFd note caveat
13:55:51 <geekosaur> (You cannot in general mix buffered and unbuffered I/O; the IO manager enforces this. If you are certain that you will not be mixing I/O operations, you can round-trip through handleToFd and fdToHandle to get both.)
13:57:43 <Phyx-> geekosaur: ah thanks! hmm unfortunately it's defined in the unix package. But maybe I can just copy parts of the code since I'm on Windows
13:57:56 <geekosaur> oh. Windows will definitely be harder
13:58:12 <nineonine> hi there ! I would like to ask for an advice in choosing best data structure. So i have 1 000 000 elements in a list of type ( (Int, Int), Bool). I have to update this structure around 300 times - each time updating the bool value 250 - 300 000 on average. Right now im simulating the state by passing it through the recursive function. This is super inefficient and the program eats all memory. Could someone siggest a better data 
13:58:13 <nineonine> structure / algorithm for solving this task ? THanks !
13:58:14 <geekosaur> like, sockets won't even hae an fd
13:58:29 <geekosaur> (winsock is weird)
13:58:58 <geekosaur> which is why it only allows you to go one way
13:59:16 <Phyx-> geekosaur: I know it'll always be a pipe/file fd though
13:59:39 <frerich> nineonine: How many of those 1000000 elements are 'True' on average?
13:59:49 <kadoban> nineonine: What is the meaning of it? Is it basically a set of (Int, Int) ? Is it a mapping of (Int, Int) to Bool? Something else?
13:59:58 <nineonine> everything starts from false
14:00:08 <Phyx-> geekosaur: the problem I have is with inheritance. Handle inheritance seems well defined. but I can't find anything on Fd inheritance. Though it seems not to be working.
14:00:24 <Phyx-> the POSIX implementation on Windows is very underdocumented.
14:01:00 <nineonine> and you update a certain ammount of elements ( from 250 to 300 000 elements on average ) for around 300 times
14:01:15 <nineonine> so its difficult to answer 
14:01:24 <frerich> nineonine: What's the peak number of 'True' values you expect on average?
14:01:29 <kadoban> nineonine: What do the updates look like?
14:01:46 <geekosaur> so you have to import GHC.IO.Handle, and your handles will be the FileHandle constructor (https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO-Handle-Types.html#Handle)
14:02:38 <nineonine> i basically traverse all the structure and and return the element with changed Bool
14:03:03 <geekosaur> I think you have to get the Handle__ from the MVar and use its `dev` field? it's been a while
14:03:21 <kadoban> nineonine: I'm not really asking how you're implementing it. I'm more interested in the meaning of the abstract data structure itself. What is it being used for? What operations do you conceptually do on it?
14:03:34 <tremon> nineonine: are the (Int,Int) values predictable? e.g. a square 1000x1000 grid?
14:03:37 <frerich> nineonine: You could consider da Data.Set (Int, Int) which only holds the 'True' values (i.e. if some (Int, Int) is not in the set, it counts as 'False'). You can insert/remove groups of elements using `union` and `difference`.
14:03:48 <nineonine> yes
14:03:52 <nineonine> its 2d
14:03:55 <frerich> nineonine: This is basically a sparse matrix
14:04:05 <kadoban> That's the obvious way ^  If the updates are of a certain form there could be better structures.
14:04:12 <Phyx-> geekosaur: I've looked at that before but couldn't figure out what actual OS handle is. But this seems a bit fragile. I suppose my current approach is less so?
14:04:15 <Phyx-> well, as long as it's still an Fd I can just use _get_osfhandle and _open_osfhandle to convert between the two. and later call fdToHandle when I'm done.
14:05:10 <nineonine> so i have 
14:05:19 <nineonine> type Coords = (Int, Int)
14:05:20 <geekosaur> probably less so, yes. the internals of GHC's Handles are pretty ugly
14:05:30 <nineonine> data Status = On | Off
14:05:43 <geekosaur> (blame having to deal with all the weird corner cases of both POSIX and Windows)
14:05:53 <nineonine> data Elem = Elem Coords Status
14:05:54 <davean> geekosaur: God they are
14:06:05 <davean> geekosaur: GHC's handles are terrible
14:06:17 <davean> geekosaur: and thank you for reminding me, I have a new place to look for a bug
14:06:21 <geekosaur> they were simpler before encoding support went in
14:06:44 <Phyx-> yeah.. It's especially confusing since there seems to be two Handle types?
14:06:50 <geekosaur> but it's nice not to have to manually utf8-encode
14:06:59 <Phyx-> unless I got confused somewhere. which is very possible
14:08:12 <geekosaur> a Handle can either be a stream (socket, which won't have an fd on Windows) or a filehandle; both of those have somewhere in them an MVar (to avoid 2 things doing encoding or buffer manipulation at the same time) pointing to the internal Handle__ which has the actual information in it
14:09:03 <frerich> nineonine: If you always toggle 'rectangular' areas of your 2d matrix, you could also consider not storing each individual element but rather store the enabled rectangles by their topleft/bottomright coordinates.
14:09:20 <Phyx-> geekosaur: ah ok, makes sense
14:09:50 <frerich> nineonine: E.g. with [((0,0),(100,200))] you would represent that all coordinates from 0/0 -> 100/200 are 'On' or so.
14:10:22 <nineonine> hmm thats a great idea actually !
14:12:30 <kadoban> nineonine: This is why I was trying to ask what kind of queries you're doing …
14:12:49 <nineonine> :))
14:12:55 <nineonine> sorry you are too fast
14:13:07 <nineonine> yeah basicalyl i have 1000 X 1000 Off things
14:13:10 <nineonine> i have 3 operations
14:13:16 <nineonine> on | off | toggle
14:14:29 <kadoban> And you mostly either set all on, all off or toggle all in a fairly substantial rectangle at once?
14:15:29 <nshepperd> @tell athan zoom :: Lens' t s -> State s a -> State t a
14:15:29 <lambdabot> Consider it noted.
14:21:36 <johnw> ahh, zoom, of course
14:22:50 <nineonine> I start with a structure will all Off
14:23:09 <nineonine> then i have to apply transformation around 300 times
14:23:21 <nineonine> every time i toggle 250 - 300 000 elements
14:23:39 <nineonine> each step relies on the state of the previous mutation
14:24:23 <nineonine> when i have 1 million elements - this is straight forward but inefficient
14:24:29 <kadoban> nineonine: This sounds a *lot* like an interval tree, which is a pretty interesting data structure. If it's not too many, 300 doesn't sound bad, you can cobble something together that'll work based on frerich's idea without too much work really.
14:25:46 <nineonine> yeah, probably i will try to save it in rectangles
14:25:57 <nineonine> thanks !
14:26:55 <kadoban> Good luck, sounds fun :)
14:27:26 <nineonine> :)
14:29:02 <crossroads1112> I just found an alternative definition for inits using foldr that looks like this: inits = foldr ((([] :) .) . map .(:)) [[]]
14:29:02 <SrPx> How can I program in a system that slightly mismatches Haskell's system F (in particular, I want type-level fixed points)? Without creating a whole new programming language from scratch, that is.
14:29:08 <crossroads1112> Can anyone help explain that a little bit
14:29:53 <nshepperd> O_O
14:29:55 <nshepperd> @unpl ((([] :) .) . map .(:))
14:29:55 <lambdabot> (\ e k -> [] : (map (((:)) e) k))
14:30:16 <crossroads1112> What does thr @unpl command do?
14:31:07 <kadoban> crossroads1112: Converts to the pointy version, as opposed to the point-free version.
14:31:16 <crossroads1112> I see
14:31:32 <kadoban> @pl \ e k -> [] : (map (((:)) e) k)
14:31:32 <lambdabot> (([] :) .) . map . (:)
14:32:26 <nshepperd> well it doesn't clean it up fully seemingly
14:32:58 <nshepperd> foldr (\e k -> [] : map (e:) k) [[]]
14:33:38 <crossroads1112> That's really impressive that lambdabot can do that conversion
14:34:23 <OverCoder> Can I think of Parameterized type classes as Generics in Java or something?
14:34:42 <OverCoder> I am really finding it hard to understand that
14:34:43 <nshepperd> I guess the principle is that the inits of a list (e:xs) are the empty list [] plus the inits of xs with e attached
14:34:55 <johnw> I wouldn't use Java as a direct analogy for anything you'll find in Haskell
14:35:42 <OverCoder> Well um, well yeah but I mean just trying to make the idea closer to my mind
14:35:58 <johnw> if anything, it would make it "speciously closer" :)
14:36:09 <OverCoder> hm :p
14:36:12 <johnw> close enough to feel like you understand it, not close enough to actually understand it
14:37:03 <OverCoder> ..hm
14:37:30 <johnw> do you have a code example you're trying to understand?
14:38:08 <OverCoder> hm.. k hold on a sec
14:39:56 <OverCoder> johnw, this http://p.samuraimanpurse.com/8LNwZFty.txt
14:40:33 <Zekka|Sigfig> OverCoder: Those aren’t typeclasses: those are data types!
14:40:47 * OverCoder checks again
14:41:06 <OverCoder> ugh I've even clashed some names
14:41:12 <Zekka|Sigfig> I would say they work pretty similarly to generics in Java, except for some edge cases in how they play with type inference
14:41:36 <Zekka|Sigfig> you don’t need to know what those are
14:41:37 <OverCoder> Ah, hm
14:42:01 <OverCoder> Well, thanks, because I was just like, lost, and I was gonna skip this part
14:42:17 <Zekka|Sigfig> A typeclass has a definition that starts with ‘class’
14:42:28 <tremon> Zekka|Sigfig: "they" being data type variables, not type classes I guess?
14:42:28 <Zekka|Sigfig> a data type’s definition starts with ‘data’ and a type alias’s definition starts with ‘type'
14:42:44 <OverCoder> ooh
14:42:46 <Zekka|Sigfig> tremon: Yeah, a parametric type in Haskell is similar imho to a generic type in Java
14:42:55 <Zekka|Sigfig> type variables work similarly to generic type parameters
14:43:49 <OverCoder> awesome, so that ^ plus that the keyword really means what I am defining, 'data' defines 'data types', 'type' defines type aliases, and so on
14:43:53 <OverCoder> Awesome, thanks
14:43:54 <Zekka|Sigfig> Except that Haskell can infer how to make your type work in a lot of cases where Java can only check if it does (because Haskell just unifies your types to make stuff work, where it seems like Java uses large quantities of special cases and hope instead)
14:44:19 <OverCoder> ayy ayyy leave that for a later experience I am just trying to grasp the basics hahaha
14:44:32 <OverCoder> Well I know bunch of imperative languages, but none of functional ones
14:45:35 <tremon> I'd say the last point is not a difference of imperative vs functional, but strong static typing vs type inference
14:46:15 <OverCoder> hm
14:46:19 * OverCoder shrugs
14:46:27 <scaroo_> hi there. Seems like haskellnews.org is down. Is chrisdone around by any chance ? :)
14:46:40 <kadoban> tremon: haskell has both strong statit typing and type inference
14:48:07 <tremon> erm yes :)
14:50:39 <pikajude> hi, with aeson-0.10, if I `encode` a datatype containing a UTCTime, the time doesn't get quotes
14:50:43 <pikajude> around it
14:50:51 <pikajude> has anybody else seen this? anyone know what the fix is?
14:52:08 <bergmark> pikajude: aeson 0.10 is buggy, 0.11 is coming soon, stay with 0.9 until then
14:52:16 <pikajude> oh heavens
14:52:16 <pikajude> ok
15:03:08 <kadoban> Hmm, blaze-ghcjs is actually … kind of close to working. Yay for 3 year old random code.
15:09:11 <pikajude> doh. aeson 0.11 has the same bug
15:12:06 <pikajude> how do I get this to :print? t = (_t3::Encoding)
15:12:10 <monochrom> oh haha, and I demoed aeson-0.10 just last night at Toronto haskell meetup
15:12:14 <pikajude> :force just prints "t = _"
15:12:30 <monochrom> (didn't have to be 0.10, it just happened to be the version I downloaded)
15:14:05 <Ankhers> If I use `liftIO . forkIO $ do ...' is there some way for me to get "back into" the original monad while still doing processing on the new thread?
15:15:12 <scshunt> Ankhers: No
15:15:52 <scshunt> Most monads are pure anyway; sharing computations between threads would be impossible.
15:15:56 <scshunt> What exactly are you trying to do?
15:17:49 <Ankhers> I'm using servant to feed my application JSON. The JSON is actually coming from a CSV data source that I am reading and parsing then placing into my database.
15:19:38 <Ankhers> While I currently have it working, I do not like the implementation. I am currently forking and passing the database pool around to various functions, which I would rather not do if possible.
15:19:46 <Ankhers> It just feels a little hacky / dirty to me.
15:20:12 <xaimus> '
15:21:02 <`Guest00000> ghci should execute inner action when expression of type IO (IO Type) is input
15:22:24 <kadoban> `Guest00000: ghci is already magic enough.
15:22:39 <`Guest00000> kadoban: what does that mean?
15:22:50 <`Guest00000> what does 'enough' mean
15:23:42 <kadoban> `Guest00000: I mean that increasing the ways it behaves confusingly is probably not a good idea.
15:25:05 <`Guest00000> is my proposition = more confusion?
15:25:29 <kadoban> I would think so, yes.
15:25:36 <Ankhers> Does it differ from the way GHC would execute it?
15:26:37 <`Guest00000> it would be more handy
15:27:26 <Cale> `Guest00000: actually, usually not
15:27:57 <Cale> `Guest00000: Often when you have something of type IO (IO t), it's an IO action which allocates some resource, and gives you back the IO action for deallocating it
15:28:12 <Cale> So automatically running the deallocator would be extremely unhelpful
15:28:50 <`Guest00000> okay
15:30:23 <`Guest00000> but do you frequently throw away that returned action
15:30:42 <Cale> Sometimes you might if you were just using GHCi interactively
15:31:08 <Cale> because you wouldn't necessarily be interested in cleaning up after yourself if you're just messing around
15:31:16 <`Guest00000> i as well could write _ <- ...
15:31:37 <Cale> Yeah, I think GHCi should try to be as close as possible to behaving like the inside of a do-block
15:31:48 <Cale> it already bothers me that it defaults to printing the results of IO actions
15:31:54 <nshepperd> oh, that's weird, normally it prints out the value produced by any IO a action, for some a with a show instance
15:32:10 <Cale> Yeah, it does do that.
15:32:22 <`Guest00000> but the () it doesn't print..
15:32:27 <Cale> right
15:32:29 <nshepperd> but if it can't find the Show instance it just does nothing rather than throwing an error
15:32:37 <Cale> nshepperd: That's correct
15:32:38 <`Guest00000> hm
15:32:46 <nshepperd> all these weird cases
15:32:49 <monochrom> in "enough magic", the part that you need to understand not "enough", but is "magic".
15:32:59 <Cale> Yeah, it's already kind of obnoxious imo
15:33:11 <Cale> Well, sometimes printing the result is fine and convenient
15:33:20 <`Guest00000> monochrom: i just misunderstood initially
15:33:23 <monochrom> once you know what "magic" means here, you will agree that it is tautological "more than enough", because you would rather none to happen in the first place
15:33:41 <monochrom> and "magic" here means blatant deviation from standard behaviour
15:34:22 <`Guest00000> what is standard behaivior in this case?
15:34:26 <`Guest00000> behavior *
15:34:32 <monochrom> for example, what Haskell 2010 says
15:34:49 <`Guest00000> it says nothing for interpreters
15:34:56 <kadoban> `Guest00000: Behavior you'd see using it in real code in GHC.
15:35:12 <Cale> `Guest00000: GHCi is sort of trying to emulate the inside of a do-block that you're writing live.
15:35:30 <Cale> `Guest00000: It deviates from that already in a bunch of ways
15:35:33 <monochrom> it doesn't matter whether Haskell 2010 constrains interpreters or not.
15:35:33 <kadoban> `Guest00000: Beginners are already confused by how ghci works and why code written in it looks so different from code written in an actual text file. I know when I was a beginner it seemed really obnoxiously weird.
15:35:55 <monochrom> what matters is whether an interpreter is consistent or inconsistent with compiled code
15:36:11 <monochrom> any tiny difference is bound to mislead you and trick you
15:36:19 <`Guest00000> okay
15:36:26 <Cale> Anyway, trying to execute the result of an IO action immediately is usually going to be super annoying
15:36:31 <`Guest00000> a "handy mode" for interpreter
15:36:32 <monochrom> in other words it is about you, whether you can trust the interpreter in the first place
15:36:34 <Cale> and you could just write join if you wanted that
15:36:48 <`Guest00000> in this mode, interpreter would "deviate" more, but would be more handy
15:37:02 <Cale> Like, if you have x :: IO (IO ()), and you want to run the action x and then run its result in ghci
15:37:06 <Cale> you can just type  join x
15:37:13 <monochrom> yeah that sounds very nice. until you realize that "handy" is subjective
15:37:46 <kadoban> You're kind of asking for "just do what I mean … you know, guess!" mode, which is … not really in the spirit of haskell.
15:38:10 <monochrom> DWIM does not exist. there is only WDYM (what do you mean?)
15:38:13 <Cale> But if GHCi were to automatically run the results of IO actions, it might be quite frustrating and surprising.
15:38:22 <Cale> and harder to sidestep
15:39:02 <Cale> Values of type IO (IO t) already show up very infrequently
15:39:22 <Cale> and usually when they do, it's for a reason: you won't want to run the resulting IO action immediately
15:39:51 <Cale> (otherwise, the author of the action would have written it to have type IO t)
15:40:58 <Cale> Having to remember that GHCi does this magic thing where it's going to execute not only the action, but its result, (recursively?) would be extra cognitive overhead, and usually be a hassle.
15:41:45 <monochrom> did you know: by default, ghci evaluates each expression you enter in a new forkIO thread
15:42:04 <Cale> hah, I actually didn't know that
15:42:51 <monochrom> this is now the well-known #1 cause of why playing with a typical GUI library in ghci complete breaks.
15:43:08 <monochrom> because a typical GUI library expects every command to be issued from the same thread
15:43:22 <Cale> Well, it's the #2 cause. The #1 cause is that C programmers are mostly terrible.
15:43:27 <kadoban> Hah wow, that actually does sound kinda bad.
15:43:47 <monochrom> Cale, could we agree to use "#0" for that? :)
15:43:51 <Cale> sure
15:43:53 <Cale> haha
15:44:32 <monochrom> it goes on and on
15:44:51 <monochrom> textbook example of "the road to hell is paved with well intentions"
15:44:55 <hodapp> Cale: that's all those OTHER programmers, not me.
15:45:21 <hodapp> also, I told the user not to enter a string longer than 200 characters, so don't look at me.
15:45:39 <Cale> haha
15:46:04 <Cale> It's so frustrating that every big GUI library is so bad at dealing with being interacted with concurrently, when concurrency is such a natural abstraction to want to use in programming GUIs.
15:46:19 <hodapp> Cale: Are you aware of any GUI libraries that handle concurrency nicely?
15:46:24 <Cale> no
15:46:48 <hodapp> I thought agocorona was doing something with that but I don't know
15:47:15 <johnw> Cale: I don't see what makes this twanvl Free monad "free"
15:47:53 <csd__> How can I type alias the function with type signature S -> (a, S) ?
15:48:14 <johnw> Cale: it seems that it just restricts what functions you can use in the base monad
15:48:17 <Zekka|Sigfig> csd__: I have intersting news for you!
15:48:21 <Zekka|Sigfig> @src State
15:48:22 <lambdabot> Source not found. Wrong!  You cheating scum!
15:48:28 <Zekka|Sigfig> oh, phooey!
15:48:33 <Cale> johnw: You mean in a formal way? Are you trying to write some Coq proof of left-adjointness?
15:48:47 <johnw> Cale: I'm writing Coq proofs of the monad laws, and realizing that there's nothing to prove
15:48:47 <Zekka|Sigfig> I was going to tell you that the stdlib type State is a newtype over that
15:48:48 <csd__> Zekka|Sigfig: specifically i have this in mind: http://mightybyte.github.io/monad-challenges/pages/ex1-3.html
15:48:50 <Cale> johnw: Or just informally why it has "freeness"?
15:49:06 <johnw> Cale: yeah, why freeness
15:49:25 <Cale> johnw: It's a monad which has no properties other than the monad laws and the availability of specific operations 
15:49:31 <johnw> Cale: if anything, TFree (effect m) forgets everything m can do outside of what effect specifies
15:49:37 <csd__> ghc is rejecting my `type` ... do i need to use newtype instead for some reason?
15:49:46 <Zekka|Sigfig> csd__: Post your code
15:49:52 <Cale> johnw: You mean TFree effect, right?
15:50:08 <Cale> but yes
15:50:15 <csd__> Zekka|Sigfig: type Gen = Seed -> (a, Seed)
15:50:16 <Cale> m isn't a specific monad here
15:50:24 <johnw> effect has Type -> Type, so I just mean whichever 'm' gets instantiated when you finally run the action
15:50:32 <johnw> sorry, (Type -> Type) -> TYpe
15:50:35 <Zekka|Sigfig> csd__: You’re not quanitfying ‘a’ so it doesn’t know where a comes from
15:50:47 <Zekka|Sigfig> You probably want to make it a parameter of Gen: type Gen a = Seed -> (a, Seed)
15:50:52 <monochrom> type Gen a = Seed -> (a,Seed)
15:51:04 <Zekka|Sigfig> You could use language extensions to write type Gen = forall a. Seed -> (a, Seed), but that means something different
15:51:05 <monochrom> depending on ther rest of your code, you may have other problems
15:51:07 <csd__> oh i see. i didnt know i could have the leading `Gen a`
15:51:10 <johnw> so we're defining an algebra over "some" base monad, and using Free to turn the monad chosen into an existential so that we can't know anything about it while defining the action
15:51:12 <Cale> johnw: Yeah, you don't want all the stuff in the large monad that you're going to interpret into
15:51:18 <csd__> thanks
15:51:28 <Zekka|Sigfig> Basically, the problem is that if someone uses your type alias in their typesig, Haskell might not know what to do
15:51:31 <ecognium> Hello everyone, i have  a question regarding `wreq`.  the default get and getWith through an HttpException. I would prefer to catch this exception and return the statusMesasge back to the caller inside Either. 
15:51:40 <johnw> sorry, "monad chosen" is the wrong words
15:51:44 <ecognium> `r <- getWith opts url  `E.catch` handler ` 
15:51:45 <Zekka|Sigfig> if someone wrote f :: a -> Gen, is your a different is your a the same?
15:52:04 <johnw> Free effect has the benefit that I can *only* do what effect allows, and nothing more no matter how tricky I might be
15:52:11 <johnw> only the user who executes the action can choose 'm'
15:52:20 <Cale> johnw: So a free group is a group which has a set of elements (generators) such that if you specify where those generating elements go, then you can extend that map to a unique group homomorphism
15:52:27 <Zekka|Sigfig> If you parameterize Gen over Gen’s a, then you can distinguish the two cases: f :: a -> Gen a, f :: a -> Gen b
15:52:29 <ecognium> when things go well `r` is Response ByteString.  I am trying to return Either String (Response ByteString). 
15:52:35 <johnw> but how is this making 'm' more free?  it seems like the opposite
15:52:43 <Zekka|Sigfig> in the first one, gen’s a is the same as f’s a — in the second one, gen’s a is a second variable which f calls b
15:53:00 <johnw> Cale: oh, this is the "monad generated by the effect signature"?
15:53:05 <Cale> yeah
15:53:08 <johnw> ahh, ok
15:53:14 <ecognium> What should my handler be? It seems like I need to create a default (Response ByteString) in the handler and then look to see if it is default by inspecting the value of `r` and then send Left or Right? 
15:53:18 <johnw> funny how flexible a term free is
15:54:51 <Cale> johnw: Which is sort of kind of the same thing as the free monad on a functor usually is... 
15:55:27 <johnw> well, except that "freeness" there is giving you a monad from a functor, and freeness here is giving you a free monad (in the sense of  free group) from a monad
15:55:45 <johnw> I guess they're both free monad, yeah
15:56:04 <Cale> There's almost certainly a connection between the two
15:56:13 <Cale> I don't know how to write it down formally
15:56:19 <ecognium> I know this is not right coz the handler is returning Left but `r` is (Response ByteString). http://pastebin.com/3Z1WxWxN. How do I change my handler or my logic to catch exception and return Left (if an exception was thrown) or (Right response)
15:56:40 <johnw> Cale: please write it down formally :)
15:57:22 <Cale> johnw: Have you read this? http://aaronlevin.ca/post/136494428283/extensible-effects-in-the-van-laarhoven-free-monad
15:57:33 <johnw> and https://www.reddit.com/r/haskell/comments/35zks5/which_free_monad/
15:57:36 <Cale> Nice little coverage of how to practically use the technique
15:57:45 <johnw> I'll read aaron's
15:57:51 <Cale> So in the first example here, he shows freeIOInterp
15:57:59 <Cale> :: Free YeOldeHttp a -> IO a
15:58:19 <Cale> which is *pretty much* just mapping the constructors of the functor YeOldeHttp to IO actions
15:59:36 <Cale> johnw: So probably at least for functors of a particular form
16:00:09 <csd__> Zekka|Sigfig: what might be wrong with this http://pastebin.com/j1ZEkq5g ?
16:00:19 <Cale> There will be something you can do to go back and forth between the effect-record-style and the functor-style
16:00:47 <Zekka|Sigfig> csd__: I don’t know how are rand, mkSeed and Gen defined?
16:00:53 <Zekka|Sigfig> know, how*
16:01:05 <johnw> Cale: by "functor style", you mean HttpF r vs Http (where Http is an "effect")?
16:01:13 <Cale> yeah
16:01:19 <johnw> yeah, I can see that link
16:01:54 <Cale> You'd have to formalise what that connection is precisely before you could really show that it's appropriate to call this "free" in the sense of being generated by a functor.
16:02:27 <Cale> (but it seems clear at least for specific effect record types what the corresponding functor ought to be)
16:04:35 * hackagebot werewolf 0.3.3.0 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.3.3.0 (hjwylde)
16:11:06 <johnw> Cale: https://gist.github.com/e420888b9551a4207eb3
16:14:19 <`Guest00000> is there something like Dynamic but with a restricted type?
16:14:42 <hpc> Either
16:14:56 <mniip> restricted in what way
16:15:24 <`Guest00000> for example, Dynamic [a]  would store [Int] or [[Char]], but not Int
16:15:33 <`Guest00000> Dynamic'   *
16:15:36 <mniip> why not [Dynamic]
16:15:42 <mniip> oh wait, hm
16:19:26 <Cale> `Guest00000: You can pull that off using an existential type and Typeable
16:20:48 <Cale> Something like data Dynamic' f where Dynamic' :: Typeable a => f a -> Dynamic' f
16:21:33 <`Guest00000> Cale: Typeable (f a) ?
16:22:15 <Cale> `Guest00000: You shouldn't need that...
16:22:43 <Cale> `Guest00000: the important thing is being able to branch on the type parameter to the functor
16:22:50 <hpc> Cale: could f be a GADT?
16:23:16 <Cale> hpc: I guess so
16:23:24 <Cale> Shouldn't matter much
16:23:28 <johnw> Cale: from TermF -> Free TermF in that example I pasted, the free monad is generated from the functor pretty clearly; in Term -> TFree Term, we're getting a new monad by generating from a monad that need have no other capability than return and bind
16:23:46 <hpc> Cale: it seems like that could obviate the need for Typeable, but maybe i am missing something
16:24:03 <Cale> hpc: Oh, well, they were asking for something analogous to Dynamic
16:24:14 <Cale> hpc: Dynamic is just an existential over Typeable
16:24:28 <hpc> oh wait, i see
16:24:57 <hpc> having something like (Dynamic []) instead of writing some kind of enum
16:25:03 <Cale> johnw: Cool, I'll take a closer look in a sec, dinner is ready :)
16:25:15 <`Guest00000> Cale: if i have it, i can call toDyn
16:25:20 <hpc> yeah, that makes sense
16:25:28 <wanderer_> which is more beginner friendly scala or haskell?
16:25:56 <wanderer_> i am interested in learning functional programming "paradigms" to make sure that i am ready for my programming languages class
16:26:39 <`Guest00000> hm... i tried to learn scala, but tutorials i found seemed to depend on Java knowledge
16:26:47 <johnw> Cale: I haven't implemented the Monad instance, or the projection that let you use "putChar" as an action of type TFree Term (), but those are pretty trivial
16:26:49 <`Guest00000> maybe I can't search...
16:27:13 <Zekka|Sigfig> wanderer_: IMHO Scala has a few features specifically designed to make it more pitchable to beginners, but it’s more complicated than haskell overall imho, and the builtin libraries are a pain
16:27:53 <Zekka|Sigfig> I have an incredibly low opinion of Scala so maybe you should ask someone more neutral though
16:28:17 <Zekka|Sigfig> Haskell is overcomplicated in different ways, but I think it’s still simpler than Scala
16:28:35 <Zekka|Sigfig> neither is particularly representative of “FP the entity” because when people say FP it’s really just a grab bag
16:29:26 <puregreen> what's the simplest network library there is? I need just 2 things: “serve :: Port -> (Request -> Response) -> IO ()” and “send :: Address -> Request -> IO Response”, nothing else
16:29:28 <Zekka|Sigfig> If you want a language that’s like haskell but somewhat more representative of other FP languages, you might learn an ML like SML — that’s a less ideological typed lambda calculus language
16:30:07 <Zekka|Sigfig> if you want a representative for the untyped lambda calculus, maybe learn Scheme — if you want a logic language, try Mercury or Prolog
16:30:53 <Zekka|Sigfig> wanderer_: That doesn’t really cover all the variation in functional programming languages but it might give you a more broad picture
16:31:22 <shanemikel> remind me, what do you call ()?
16:31:33 <kaizoku> parens? :p
16:31:36 <puregreen> “unit”
16:31:38 <shanemikel> right
16:31:39 <monochrom> unit
16:31:39 <puregreen> or “void”
16:31:46 <shanemikel> well Void is it's own type I thought
16:31:50 <puregreen> it is
16:31:56 <`Guest00000> in one sense, void is different
16:31:57 <puregreen> which is why “unit” is better
16:31:58 <shanemikel> so, I'll go with unit
16:32:11 <shanemikel> thanks
16:32:20 <Zekka|Sigfig> wanderer_: A lot of the things you have to learn to use Haskell will only really be useful while using haskell and the same is true of Scala imho — the same’s probably not as true of SML or Scheme
16:32:25 <wanderer_> From what i heard from my friends is that monads are simply too complicated and I have to learn to many things even for simple i/o
16:33:13 <kadoban> wanderer_: Monads are just some pattern used in a lot of libraries, essentially. People build up too much fuss about it, it's not as complicated as people would have you believe.
16:33:20 <Zekka|Sigfig> wanderer_: I don’t think monads should be necessary for the common case of control flow. In Haskell the designers didn’t really have a choice: the other options were worse after all the other decisions they made
16:33:37 <Zekka|Sigfig> they’re not that complicated but they’re kind of a hack imho
16:33:50 <nineonine> Q: what is the most efficient / elegant way of subtracting sublist from list ? basically i need remove the ( list1 `union list2) from list1
16:34:14 <nineonine> sorry not union
16:34:23 <nineonine> l1 `intersect` l2
16:34:25 <shanemikel> monads themselves are starting to appear very simple.. now the use of monads isn't always so much.. keeping track of the implicit state passing, and wiring monadic functions up, thinking in an imperative style without mixing different monads together is harder
16:34:36 * hackagebot werewolf 0.3.3.1 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.3.3.1 (hjwylde)
16:34:48 <Zekka|Sigfig> My opinion is that state management is a pain and most of the existing solutions to it in Haskell are complicated
16:35:06 <Zekka|Sigfig> Those things are not as complicated in Scala, but my issue with scala is that it has an incredible number of features, and a lot of them don’t play well with each otehr
16:35:12 <monochrom> @type (//)
16:35:14 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
16:35:14 <`Guest00000> nineonine: Data.List has \\
16:35:27 <monochrom> @type (\\)
16:35:28 <lambdabot> Eq a => [a] -> [a] -> [a]
16:35:35 <monochrom> yeah, I think \\ will help
16:35:44 <Zekka|Sigfig> it has a lot more “do what I mean” than Haskell, which made it difficult for my coworkers to learn. They would see some code, copy paste it, and it would no longer compile and they wouldn’t know why
16:35:49 <shanemikel> that is, sometimes once I get caught in imperative procedure, I'll revert to imperative thinking where I don't need to limit my monadic types to one within the same procedure
16:36:11 <nineonine> exactly !
16:36:11 <nineonine> thanks
16:36:32 <Zekka|Sigfig> Have you worked in Perl? Scala reminds me a lot of Perl.
16:36:36 <wanderer_> Yeah
16:36:39 <wanderer_> Perl sucks
16:37:13 <wanderer_> I am pretty comfortable with Java though, it is the first language we learned in college
16:37:29 <wanderer_> And both Java and Scala are JVM languages
16:38:25 <Zekka|Sigfig> I wouldn’t recommend writing Scala because you like Java —you can write Java in Scala if you choose to, but you aren’t learning much. You can mix the wto (heads up: it’s easier to call into Java from Scala than Scala from Java) although Scala doesn’t use Java’s libraries by default
16:38:29 <kadoban> wanderer_: https://mitpress.mit.edu/sicp/full-text/book/book.html <-- you could just read that, which uses scheme. It's a really neat book. It kind of sounds a bit like what you're looking for, from what you said above. Haskell is probably a bigger time investment, though a good one IMO too.
16:38:52 <wanderer_> Is powered by phd thing true about haskell?
16:39:06 <kadoban> wanderer_: Not sure what that means.
16:39:13 <Zekka|Sigfig> Scala has worse built-in support for some bread-and-butter FP stuff like recursion imho
16:39:23 <kadoban> wanderer_: It's not an academic language, if that's what you're asking.
16:39:30 <Zekka|Sigfig> the JVM environment did not help the language and it made e.g. the type system much more confusing
16:39:58 <Zekka|Sigfig> There are other people I know who say the Scala type system isn’t confusing at all, but I don’t believe them.
16:41:02 <wanderer_> @kadoban this is sort of what i was looking for actually
16:41:02 <lambdabot> Unknown command, try @list
16:41:35 <Zekka|Sigfig> FWIW out of the languages listed so far I think Scheme is the easiest to get to work with
16:41:47 <kadoban> SICP is a really nice book, if it's at all what you're interested in, I can highly recommend it.
16:41:55 <Zekka|Sigfig> Prolog can be fiddly at times, Haskell has some conceptual overhead that even other FP languages don’t have, and Scala has a lot of cruft imho
16:42:02 <Zekka|Sigfig> SML might work for you but I’m really not very experienced with it
16:42:14 <shanemikel> how do derived class instances work without overloading?
16:42:28 <biocage> Zekka|Sigfig: Do you think it's easier to find a Haskell job or a Scala job?
16:42:44 <Zekka|Sigfig> biocage: It’s probably easier to find a Scala job but I’m not certain
16:43:03 <johnw> I'd say Scala for certain, but the landscape is always changing
16:43:06 <Zekka|Sigfig> I work with a lot of Scala people and I get the impression that Scala is better-marketed and easier for dudes to fit into their existing infrastructure
16:43:42 <Zekka|Sigfig> I happen to like Haskell more but if someone came to me with a bunch of Java code and said “port this to Scala or Haskell”I  would pick Scala
16:43:44 <biocage> What makes Scala draw better salaries?
16:43:49 <Zekka|Sigfig> But I would probably ask them if I could leave it in Java
16:43:56 <biocage> heh
16:44:05 <johnw> biocage: did anyone say anything about salaries?
16:44:06 <shanemikel> and if you're writing apps you have Swing or JavaFX which is still one of the best GUI frameworks, while reactive and FRP gui programming patterns are still getting worked out
16:44:11 <shanemikel> err.. applications
16:44:18 <Zekka|Sigfig> biocage: I’m not an expert on the sociopolitical factors that lead to Scala being popular — but a big part of it is probably that it interops pretty well with Java
16:44:30 <biocage> johnw: ok, i'm presuming because I know Scala folks making obscene salaries
16:44:41 <Zekka|Sigfig> imho the quality of the interop is overstated and most of the Scala guys I hang out with (like four people) seem to think that interopping with Java from Scala is a massive imposition that they shouldn’t have to tolerate
16:44:50 <johnw> i don't think there's any reason to make salary assumptions based on language
16:44:57 <Zekka|Sigfig> it almost feelsl ike they’re just saying it interops with Java so they acn get it in the door, with no intent to actually do that
16:45:03 <shanemikel> but clojure also runs on JVM.. so anybody have experience which is better lang.. and more specifically, which is easier FFI with java (vice-versa)
16:45:51 <Zekka|Sigfig> IIRC clojure is about as easy to call Java from, hard to call into — it uses even fewer builtin Java things and has fewer builtins than Scala to convert between though
16:45:56 <Zekka|Sigfig> (disclaimer: I only used clojure for one project)
16:46:31 <Zekka|Sigfig> Clojure doesn’t act like it’s a Java substitute afaik, while Scala at least claims to be viable as a vehicle for producing Java
16:46:45 <Zekka|Sigfig> It’s way more puristic than scala imho
16:47:06 <shanemikel> and IIRC there's two different standard libraries for scala, one being the "official" one which uses OOP and more java apis, where the other is more idiomatic FP
16:47:41 <Zekka|Sigfig> shanemikel: You thinking of the scala stdlib vs scalaz? Because afaik that’s true, but they’re designed to be usable in tandem
16:48:05 <shanemikel> yeah, that's it scalaz.. so they aren't conflicting, that's good to know
16:48:10 <Zekka|Sigfig> I have a little prejudice against scalaz because I hung out with one of the maintainers a while back and he was a massive jerk
16:48:35 <dibblego> Zekka|Sigfig: how?
16:48:57 <Zekka|Sigfig> dibblego: Oh never mind! I’ll go whistle on a park bench or something
16:49:04 <shanemikel> linus is a jerk, too
16:49:17 <shanemikel> doesn't keep me from appreciating the merits of linux
16:49:25 <Zekka|Sigfig> (dibblego worked on Scalaz and he can probably tell you a little about it)
16:49:37 * hackagebot werewolf 0.3.3.2 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.3.3.2 (hjwylde)
16:50:06 <dibblego> yes, name-calling happens a lot, which is weird, tragic, hilarious and uninteresting. The technical points are interesting.
16:51:07 <Zekka|Sigfig> It’s a little unfortunate but when someone tries to sell me on a technology, their personal attitude has a *really big impression* on how I’m going to perceive what they’re selling me
16:52:08 <Zekka|Sigfig> a lot of techs that I have a lingering dislike towards were originally pitched to me by someone who brought up all the flaws and started explaining why they’re not as bad as everyone thinks
16:52:18 <dibblego> I seriously doubt that a scalaz maintainer was trying to sell it to you. Maybe there's a misunderstanding there.
16:53:04 <shanemikel> so, where can I read the default implementations of Show and Eq? and how do these work without overloading class instances?
16:53:12 <Zekka|Sigfig> dibblego: If I remember, I mentioned to you that someone else I know was using it and I asked how similar it was to things Haskell had already done, and you reamed me because the way i’d phrased it insinuated that you had made direct, intentional borrowings from Haskell
16:53:39 <dibblego> sure mate
16:55:36 <Cale> johnw: Yeah, that's pretty much exactly what I was thinking -- trickier to do it in a way which works for an arbitrary functor or an arbitrary effect record
16:56:25 <dibblego> shanemikel: in scalaz?
16:57:02 <shanemikel> oh, no.. I'd go to scalaz irc for that
16:57:04 <shanemikel> in haskell
16:58:07 <shanemikel> I mean, when you make a `type Something = Something deriving Show`
16:58:54 <monochrom> "type" cannot possibly be there
16:59:02 <dibblego> shanemikel: maybe you mean newtype not type
16:59:02 <Cale> shanemikel: The Report has a section called "Specification of derived instances"
16:59:03 <shanemikel> are the default class instances done with the class system, or at another level with some magic and introspec
16:59:10 <shanemikel> err.. I mean't data
16:59:15 <Cale> https://www.haskell.org/onlinereport/derived.html
16:59:52 <shanemikel> okay, thanks Cale 
17:00:01 <Cale> shanemikel: Kinda both...
17:00:29 <monochrom> "default" is also probably not the right word
17:00:57 <shanemikel> yeah, I'll use derived
17:01:01 <Cale> shanemikel: The things which are constructed for the instances are constructed automatically by the compiler and the resulting records of methods don't look any different from the ones which would have resulted from writing the instances by hand
17:01:30 <Cale> It doesn't do anything magical to actually implement the methods.
17:01:52 <shanemikel> I see.. so code generation similar to generics in other langs
17:02:09 <biocage> where is the secret decoder ring for ghc error messages?
17:02:21 <Cale> biocage: Reading slowly and carefully
17:02:27 <monochrom> they died
17:03:03 <Cale> biocage: and/or only looking at the line number, and then staring at your code until you understand why it doesn't make sense
17:03:37 <Cale> and then reading the message and seeing why it tells you exactly what you just figured out (but maybe using terminology you didn't know yet)
17:03:56 <sssilver> What's the point of Haskell in a world that already has beer?
17:04:12 <SrPx> Wow this file couldn't have ended with a truer name. http://i.imgur.com/CSjrhsX.jpg ~ "this is what happens to you when are a Computer Science junior doing Haskell experiments"
17:06:16 <monochrom> "numbers with low Kolmogorov complexity has short representation" nice
17:06:48 <monochrom> except that it should be a tautology, shouldn't it?
17:07:29 <monochrom> it should also be true of lambda calculus. the author confused lambda calculus with church numeral.
17:08:11 <monochrom> church numeral is the one that doesn't guarantee short representations when low Kolmogorov complexity.
17:08:46 <monochrom> but nothing says you cannot write a short program that evaluates to a huge church numeral
17:09:17 <dolio> ack 5 5 isn't that big a program.
17:09:24 <mirari> Is something like the following possible: Assume I have two type classes Foo and Bar, and I want to create a third type class Qux, and in this type class I am interested in function types a -> b where A must be a member of Foo and b a member of Bar.
17:10:46 <dolio> Even when written to work with Church numbers.
17:11:06 <monochrom> the most tragic thing that can happen to a student learning proofs is that a 100-line proof is written to prove a definitional tautology
17:11:24 <monochrom> no, that's only the 2nd most tragic.
17:11:42 <monochrom> the #1 most tragic is when that 100-line proof is also on Kolmogorov complexity
17:12:17 <monochrom> because, like, theorems have Kolmogorov complexities, too, by way of "what is the length of the shortest proof"
17:19:49 <Gurkenglas> Note that a program that generates a proof along with a proof that the program works correctly also counts
17:30:29 * hackagebot binary-search 1.0.0.3 - Binary and exponential searches  https://hackage.haskell.org/package/binary-search-1.0.0.3 (TakayukiMuranushi)
17:30:45 <synergistics> Is it a bad practice to always use qualified imports?
17:34:15 <geekosaur> synergistics, some consider it good practice, some consider it neutral, I don't think anyone considers it bad
17:35:31 <geekosaur> (unless carried to extremes; there's some examples of that on hackage)
17:36:11 <geekosaur> (there is a Haskell programmer who infamously names every type T and every class C and expects you to use fully qualified names to disambiguate)
17:37:43 <geekosaur> (it makes the API documentation utterly unreadable)
17:38:16 <hodapp> that's almost as silly as making every statement a parenthetical!
17:39:06 <geekosaur> (just channeling (my (inner (lisper))))
17:39:40 <dolio> I consider it bad to _always_ use qualified imports. Like, _only_.
17:40:14 <geekosaur> importing Prelude qualified without a good reason is setting the hurt-me bit, certainly.
17:40:28 <geekosaur> but there are modules that can only be used sanely when imported qualified, such as Data.Map
17:40:37 <shachaf> Take it farther and name every module M.
17:40:38 <synergistics> geekosaur: (I (get (ya)))
17:41:29 <synergistics> Until I really know what's in what modules, aliased qualified imports make things clearer
17:41:56 <hodapp> I made a habit of doing 'import qualified' a lot
17:42:07 <hodapp> but with Ivory this became unruly because of how many 'little' operators Ivory used
17:42:50 <hodapp> e.g. Def ('[Uint32, Sint16, Uint32, Sint16] :-> ()) - a lot of that is imported symbols
17:43:11 <hodapp> Def, :->, Uint32, Sint16...
17:43:18 <synergistics> Oh
17:43:51 <hodapp> so if I imported anything unqualified it was particular bits of Ivory that I used when defining C procedures
17:44:11 <hodapp> ...that and monad stuff >_>
17:55:43 <nineonine> Q: is foldM strict in its acc ?
17:55:52 <monochrom> @type foldM
17:55:53 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
17:57:30 <monochrom> that depends on m
17:58:50 <monochrom> maybe not. it's non-strict.
18:05:58 <Lokathor> unexpected end of input
18:05:58 <Lokathor> expecting end of input or "\n"
18:06:01 <Lokathor> parsec, you so silly
18:06:27 <bill_> Hello. Can anyone help me with this? I'm looking to do a simple batch or vbs that generates a messagebox with a random message from a list. I know it's not haskell but I could really use the help
18:07:42 <haskell830> Hi! I'm trying to install structured haskell mode. When I run "stack install structured-haskell-mode", I get the following error
18:07:43 <haskell830>  --  Failure when adding dependencies:           haskell-src-exts: needed (==1.16.*), 1.17.1 found (latest version available)     needed for package: structured-haskell-mode-1.0.20
18:08:41 <mgsloan> haskell830: You are probably using your global stack.yaml project, which specifies a particular snapshot to use
18:09:08 <mgsloan> Looks like structured-haskell-mode hasn't been updated to that snapshot
18:09:24 <haskell830> mgsloan: It said its using resolver lts-4.2 from implicit global project config
18:09:43 <haskell830> mgsloan: can I downgrade to that snapshot?
18:09:56 <csd__> why is this not typechecking? http://pastebin.com/BMYJqbEd
18:11:19 <mgsloan> haskell830: You can actually just do "stack install --resolver lts-3.22 structured-haskell-mode"
18:11:37 <johnw> csd__: pass s' to f
18:11:44 <johnw> csd__: as in, f a' s'
18:11:46 <haskell830> mgsloan: do I change the stack.yaml file's reslover to lts-3.22 as well?
18:12:05 <mgsloan> If you want to, but "--resolver lts-3.22" on the commandline overrides it
18:12:24 <csd__> johnw: oh, right, i'm forgetting to include the seed, which is also part of 'a'
18:12:25 <csd__> thanks
18:12:46 <haskell830> mgsloan: ITS WORKING
18:12:52 <haskell830> mgsloan: THANK YOU SO MUCH
18:13:39 <csd__> johnw: why can't i simply set genTwo = f a s ?
18:14:15 <csd__> also, what's the name for when your function definition has more parameters than what's in the type signature, and is that acceptable practice
18:16:03 <mgsloan> haskell830: Welcome :D
18:46:20 <nineonine> how to run main in ghci and pass there argument ?
18:47:38 <coconut> cabal run -- argument1 argument2 
18:47:55 <coconut> nineonine, you need those two dashes
18:48:12 <coconut> sorry
18:48:16 <nineonine> in ghci ?
18:48:16 <coconut> not correct
18:48:42 <geekosaur> fhci
18:48:44 <geekosaur> er, ghci
18:48:49 <geekosaur> and you use :main
18:49:00 <geekosaur> or you use System.Environment.withArgs
18:52:11 <`Guest00000> for a proxy type in a function, what do you use: Proxy a or a?
18:52:45 <`Guest00000> Proxy a guarantees that function doesn't depend on a value of type a, but a is simpler
18:57:37 <geekosaur> a is simpler but most usages would pass (undefined :: SomeType) which is a bomb looking for a chance to go off if someone forgets that it's only supposed to be used for its type
18:58:14 <`Guest00000> geekosaur: so?
18:58:49 <`Guest00000> if only Proxy would be in Prelude...
18:59:02 <`Guest00000> i'd use Proxy then.
18:59:25 <`Guest00000> but having to import it adds to its "complexity" perceived by me...
19:00:31 <Cale> `Guest00000: For anything "real", if Proxy would be right, then use Proxy. One import isn't a big deal.
19:00:52 <`Guest00000> but what if someone doesn't know about Proxy...
19:00:55 <Cale> (and you can re-export Proxy from your module to prevent clients from needing it)
19:01:09 <Cale> Well, they'll learn about it when they read the types of your functions
19:01:43 <`Guest00000> again, if Prelude had Proxy, more people had known
19:07:35 <`Guest00000> is it possible to construct a program which can save and load TypeReps to/from a file?
19:08:11 <haskell830> mgsloan: thanks again, I'm using SHM and its pretty awesome
19:08:14 <`Guest00000> the TypeReps will be only of those types already "existing" in the program
19:10:49 <pavonia> `Guest00000: You mean existing in a specific Haskell module?
19:11:17 <`Guest00000> uh...
19:11:34 <`Guest00000> types which are constructed in that program
19:12:16 <pavonia> Maybe I'm missing context, but what do you mean by "constructed"?
19:12:30 <pavonia> Types don't exist at runtime
19:22:05 <zd234> Is there a survey article anywhere of the various options for serialization/persistent/storing-things-to-DBs in haskell? I don't need full SQL; I just need (1) easy ways to serialize entire haskell structures and (2) something more scalable than "use Data.Binary and write to local files"
19:25:19 <dmj> zd234: check out acid-state
19:25:23 <dmj> @package acid-state
19:25:23 <lambdabot> http://hackage.haskell.org/package/acid-state
19:27:50 <mgsloan> haskell830: I've opened an issue about having stack automatically suggest overriding the global project: https://github.com/commercialhaskell/stack/issues/1693
19:29:12 <haskell830> mgsloan: oh cool, thanks!
19:30:58 <Guest00000> hm...
19:31:19 <Guest00000> so what if i do want to have types at runtime?
19:31:26 <Guest00000> i'll have to code that myself..
19:32:49 <exio4> Guest00000: what do you -exactly- want? you can do magic tricks with the types at runtime if you -really- need to, but it should be the last resort :) 
19:33:34 <Guest00000> so
19:33:42 <Guest00000> i kinda want to have a types language
19:33:53 <Guest00000> whose types are tied to Haskell's
19:34:02 <Guest00000> "types language" typed *
19:34:33 <Guest00000> uh
19:34:35 <Guest00000> i mean that
19:34:40 <Guest00000> my program is interpreter of that language
19:37:22 <pavonia> You can define a new type with each value representing a type
19:37:48 <Guest00000> pavonia: i want my set of types to be extensible
19:38:12 <pavonia> Uh, that's more tricky
19:38:23 <Guest00000> maybe just use String, as a name...
19:39:38 <pavonia> It depends on your use case. What doy ou want to do with these types?
19:43:04 <Guest00000> hm
19:43:25 <Guest00000> i realise that i also want to be able to define new types 
19:43:47 <Guest00000> so i'll have to implement a type system..
19:48:50 <geekosaur> I'mm trying to figure out if we should be pointing you to ghc-api (granted, that'd probably count as punishment) or to how to roll your own interpreter with type unification
19:50:42 <Lokathor> can i somehow force ghc to not use curly quotes in error message output?
19:51:12 <geekosaur> maybe try running it with LANG=C
19:53:57 <Lokathor> didn't seem to help
19:54:06 <Lokathor> but also i'm on windows so many it doesn't even look at LANG on windows?
19:55:06 <geekosaur> oh. try chcp 437
19:55:20 <geekosaur> (don't ask.)
19:56:24 <geekosaur> you may want to swith it back when you'e done to work with other programs: chcp 65001
19:56:43 <Lokathor> oh stack sets and unsets the code page *most* of the time on its own
19:57:04 <Lokathor> sometimes it doesn't though, and it seems like GHC should have an option to force ascii only output
20:20:25 <orion> Is a lazy ByteString a fine choice for a network packet buffer?
20:23:57 <pikajude> is there a library that can turn an aeson Value into blaze HTML?
20:38:51 <mjrosenb> how do I ask cabal which version of a package is installed?
20:39:17 <geppettodivacin> mjrosenb: cabal info <pkg-name> should do it, I think.
20:39:18 <Clint> you ask ghc-pkg instead
20:40:00 <Guest00000> on other hand
20:40:20 <John[Lisbeth]> I have a friend running ubuntu vanilla 14.04 64 bit, and he's installed the package ghc, but he does not have a ghci command
20:40:34 <Guest00000> i can emulate custom datatypes with Either (T1, ..., Tn) (Either (T'1, ..., T'n) (...))
20:40:51 <ReinH> Guest00000: You might be interested in https://web.cecs.pdx.edu/~mpj/thih/thih.pdf
20:41:03 <ReinH> And also TaPL
20:41:41 <Clint> John[Lisbeth]: http://packages.ubuntu.com/trusty/amd64/ghc/filelist
20:43:02 <mjrosenb> Clint: it knows about sandboxes?
20:44:11 <dalastboss> if I'm writing a do that ends with a "Just x", can I use guard to short-circuit and return Nothing?
20:44:18 <dalastboss> or is that not how guard works
20:46:58 <spindas> What's the default output directory for "cabal haddock"?
20:50:53 <Guest00000> dalastboss: do you mean your do has type Maybe T? then yes, that is how guard works
20:50:57 <JamesJRH> > 1 + 1
20:51:10 <Guest00000> JamesJRH: 2...
20:51:27 <dalastboss> ah perfect
20:52:02 <JamesJRH> @help
20:52:37 <JamesJRH> Who is the admin for lambdabot?
20:53:03 <JamesJRH> It's been about a day now that it's not working properly.
20:53:21 <JamesJRH> !help
20:54:04 <numun> Hi all
20:54:42 <Cale> JamesJRH: int-e
20:55:17 <Cale> > map head . group . sort $ "mississippi"
20:55:19 <lambdabot>  "imps"
20:55:23 <Cale> > 1 + 1
20:55:24 <lambdabot>  2
20:55:31 <Cale> JamesJRH: ^^ seems to be working for me
20:55:44 <Guest00000> numun: hello
20:55:48 <JamesJRH> Also, it appears to be selective and only not work for some people. Guest00000, dalastboss, numun: Might you try giving lambdabot an expression to evaluate?
20:56:26 <JamesJRH> Cale: I know, it has been selective to people ever since about 24 hours ago.
20:56:41 <dalastboss> > foldl (+) 0 [1,2,3]
20:56:42 <lambdabot>  6
20:58:36 <numun> Can anyone recommend a good/cheap VPS that I can run a full bitcoin node and openVPN on?
21:00:25 <ReinH> numun: that isn't on topic for this channel
21:00:47 <Guest00000> > (++ (map chr $ [32, 71,117,101,115,116] ++ replicate 5 48)) $ head $ words $ "hi lambdabot"
21:00:48 <lambdabot>  "hi Guest00000"
21:01:11 <numun> ok, cheers
21:01:22 <JamesJRH> 25 hours actually – it last worked for me at 03:34:30 yesterday, and 03:36:04 was the first time since that I gave an expression that it didn't reply too. Then it hasn't worked ever since, I kept testing it throughout yesterday with ‘> 1 + 1’.
21:01:46 <Lokathor> parsec just WILL NOT cooperate here
21:02:10 <MarcelineVQ> ​> 1 + 1
21:02:49 <Lokathor> http://lpaste.net/150472
21:02:52 <Guest00000> lambdabot likes some people more than others...
21:02:57 <JamesJRH> See. Not just me.
21:03:02 <MarcelineVQ> :>
21:03:20 <JamesJRH> It's really weird.
21:03:57 <JamesJRH> It also doesn't work for me by PM.
21:04:58 <JamesJRH> int-e: Please can you fix lambdabot. Also, I'm curious as to how exactly it is having such strange behaviour.
21:05:08 <geppettodivacin> MarcelineVQ: I see an extra character before the > on your command.
21:05:25 <geppettodivacin> I'm not sure if that's throwing it off.
21:05:35 <John[Lisbeth]> It says ghci should be installed from the package ghc in that link
21:05:49 <geppettodivacin> Hmm.
21:05:53 <geppettodivacin> > 1 + 1
21:05:55 <lambdabot>  2
21:05:55 <John[Lisbeth]> however my friend has no ghci command
21:06:13 <nshepperd> zero width space O_O
21:07:06 <John[Lisbeth]> nvm
21:07:34 <nshepperd> ah, it's a trick
21:07:41 <Guest00000> that ":>"
21:07:58 <nshepperd> ⁠> print "ignore me"
21:08:22 <JamesJRH> Guest00000: Nice expression, btw., it reminds me of the puzzle on the goody bag of EuroPython 2009 which had numerically hidden characters just like that (and ROT-13 and a couple of other interesting quirks). :-)
21:08:58 <JamesJRH> Cale: Lol at ‘imps’. :-D
21:10:44 <JamesJRH> geppettodivacin: What character do you see? I only see a space, but that's not part of the IRC message but of how my TUI client (Irssi) displays it.
21:10:55 <JamesJRH> geppettodivacin: And it's the same for yours.
21:11:19 <JamesJRH> And everyone else's, as far as I can see.
21:11:35 <MarcelineVQ> I'm just messing with you JamesJRH, lambdabot works fine for me, the only issues I​ have with it are when too many people are using it at once because it throttles so the network won't boot it.
21:11:41 <geppettodivacin> JamesJRH: It's a ? character, although on this channel it's just a stand-in for a unicode character that my current terminal font doesn't do right.
21:12:20 <JamesJRH> Oh, lol, let me see…
21:13:01 <geekosaur> I did grab one of your tests yesterday and do a byte dump of it to check for odd utf8, didn't see any
21:13:35 <geppettodivacin> JamesJRH: I didn't see any on your commands earlier.
21:13:43 <geppettodivacin> Could you try it again?
21:15:21 <geekosaur> also just checked with your earlier one. it's clean
21:17:45 <JamesJRH> Ah, yes, it shows in GVim as ‘<200b>> 1 + 1’ – U+200B ZERO WIDTH SPACE. Very funny MarcelineVQ. :-P
21:18:43 <ReinH> heh
21:18:47 <ReinH> naughty naughty
21:19:25 <JamesJRH> geppettodivacin: Clearly my client (Irssi) doesn't scrub it and my terminal emulator (Gnome Terminal) displays it correctly.
21:19:45 <bitemyapp> ReinH: notty
21:20:27 <ReinH> bitemyapp: hi!
21:20:30 <bitemyapp> ReinH: hi
21:20:37 <ReinH> bitemyapp: how's the book?
21:20:45 <bitemyapp> ReinH: I'm writing about CAFs. It's going well. How are you?
21:20:48 <ReinH> fun
21:20:50 <ReinH> not bad
21:21:04 <ReinH> drinking whiskey and playing a roguelike
21:21:06 <bitemyapp> think we'll be done by end of March.
21:21:10 <bitemyapp> I'm drinking scotch
21:21:12 <ReinH> oh nice
21:21:13 <bitemyapp> ReinH: what roguelike?
21:21:14 <ReinH> seems good
21:21:20 <ReinH> dungeon crawl stone soup
21:21:25 <bitemyapp> oh yeah that's my fav
21:21:29 <bitemyapp> well designed
21:21:48 <ReinH> yeah, I'm a fan. I'm also giving Sil a go, but not atm.
21:22:38 <bitemyapp> I don't think I was able to enjoy Angband-likes as well
21:23:43 <JamesJRH> geekosaur, geppettodivacin: Indeed, the only characters that I sent were U+003E GREATER-THAN SIGN, U+0020 SPACE, U+0031 DIGIT ONE, and U+002B PLUS SIGN, all less than 7F, i.e. ASCII characters.
21:23:53 <JamesJRH> > 1 + 1
21:35:47 <johnw> ReinH: Brogue is fun
21:40:42 <ReinH> johnw: yeah, I like brogue.
21:40:51 <ReinH> I appreciate the simplicity
21:41:08 <ReinH> johnw: (I have moved my roguelike discussion to -blah, feel free to join me :)
21:41:13 <Guest00000> okay
21:41:35 <Guest00000> i have a closed (not extensible) set of built-in types
21:41:50 <Guest00000> for them, i can use an enumeration
21:42:15 <Guest00000> for new types, i will use sum of products representation
21:44:43 <Guest00000> hm..
21:44:55 <Guest00000> i want
21:45:14 <Guest00000> something like type synonyms but different type synonyms wouldn't unify
21:45:27 <Guest00000> i can use newtypes...
21:45:43 <Guest00000> but with them i always have to wrap/unwrap
21:46:41 <Guest00000> i might phrase that better: something like newtypes but without wrapping/unwrapping?
21:47:07 <Guest00000> which brings, why do we have to wrap/unwrap newtypes?
21:48:37 <Guest00000> when we need to specify a Sum Int instead of Int, we would just write (5 :: Sum Int)
21:49:55 <kadoban> Guest00000: Sum is a newtype.   5 :: Sum Int  works because numeric literals in haskell are kind of magic, they're of type   Num a => a
21:50:09 <kadoban> Guest00000: And since Sum Int   is an instance of Num, that works.
21:51:06 <Guest00000> kadoban: no, i'm not talking about that
21:51:16 <ReinH> > 5 :: Sum Int
21:51:18 <lambdabot>  Sum {getSum = 5}
21:51:39 <Guest00000> okay, my example is wrong because that already works?
21:51:41 <Guest00000> hm
21:51:50 <kadoban> Oh, heh. I thought you realized it did.
21:52:05 <ReinH> Well, it is an exception that proves the rule
21:53:28 <Guest00000> we wouldn't be able to write (5 :: Sum Int) and have instance Num (Sum Int) where fromIntegral ≠ Sum
21:53:31 <Guest00000> okay
21:53:45 <Guest00000> my proposition is bad.
21:54:04 <Guest00000> fromInteger *
21:54:32 <kadoban> What?
21:54:45 <Guest00000> :p
21:55:46 <Guest00000> i was asking, why do we need wrap/unwrap newtypes and not just use plain values?
21:56:02 <Guest00000> need to wrap/unwrap newtype values *
21:56:12 <kadoban> Because that's most of the point of them, to make a *new* type. It's an actual separate type.
21:56:35 <kadoban> And in haskell separate types aren't convertable to each other unless you … use whatever function converts them.
21:57:07 <ReinH> Guest00000: Haskell's types are tagged. It's a design decision.
21:57:17 <lethjakman-l> https://gist.github.com/lethjakman/69be3783f85084e86c9c
21:57:24 <lethjakman-l> I'm getting an error that my field is mismatched. 
21:57:32 <kadoban> One issue though is that sometimes newtypes are used essentially just to pick an instance of some typeclass, like Sum or Product pick a Monoid. Then the wrapping/unwrapping is kind of a tedious necessity. It's because we don't have a better way to say "okay, use this instance:"
21:57:37 <lethjakman-l> Is there some special rule that I'm breaking?
21:57:44 <Guest00000> kadoban: i understand the point of them
21:57:51 <Guest00000> i propose
21:57:56 <ReinH> lethjakman-l: show the error you're getting
21:58:00 <ReinH> in your gist
21:58:21 <lethjakman-l> ReinH: https://gist.github.com/lethjakman/69be3783f85084e86c9c
21:58:23 <lethjakman-l> I added it. 
21:58:37 <lethjakman-l> It's not very exciting. 
21:58:49 <ReinH> That's not an error that your "field is mismatched"?
21:59:09 <lethjakman-l> That's all I'm getting?
21:59:10 <nshepperd_> Adding automatic conversions to newtypes would defeat the point. You don't want to be able to add a Distance to a Money
21:59:11 <kadoban> lethjakman-l: Which line is the error on?
21:59:19 <dmj> lethjakman-l: what is the type of email
21:59:29 <lethjakman-l> I'll add more code
21:59:35 <ReinH> but your indentation is rather strange and you're getting a syntax error, so you should probably fix that
22:00:10 <lethjakman-l> I added more. 
22:00:24 <lethjakman-l> ReinH: What should my indentation look like? I'm still having issues figuring that out. 
22:00:31 <lethjakman-l> Line 152 is the last )
22:00:46 <Guest00000> i propose that we can specify other type by writing not just (expr) where expr :: Type, but (expr :: Wrapper Type), where newtype W = Wrapper Type
22:01:03 <Guest00000> ahhh not
22:01:09 <Guest00000> (expr :: W)
22:02:15 <lethjakman-l> Ohhh
22:02:16 <lethjakman-l> It's that return
22:02:23 <lethjakman-l> It has to be on the same line as the |])?
22:02:28 <Guest00000> hm
22:02:50 <Guest00000> i thought about that, and understood that it wouln't be very useful either.
22:03:03 <Guest00000> so, ignore my proposition.
22:03:17 <dmj> lethjakman-l: email is ambiguous there
22:03:24 <Guest00000> i should think more before writing.
22:03:47 <dmj> lethjakman-l: the one from stringField will probably take precedence
22:05:22 <lethjakman-l> dmj: I fixed that. 
22:05:26 <lethjakman-l> Thank you though!
22:05:32 <lethjakman-l> It was the )
22:05:38 * hackagebot foldl 1.1.5 - Composable, streaming, and efficient left folds  https://hackage.haskell.org/package/foldl-1.1.5 (GabrielGonzalez)
22:32:07 <bitemyapp> jle`: websites down homie
22:32:14 <bitemyapp> jle`: http://blog.jle.im/entry/io-monad-considered-harmful
22:34:05 <kadoban> When IO monads strike back, *dun dun dun*
22:34:30 <johnw> "IO monads equated with processed meat and tobacco"
22:36:02 <JamesJRH> How do I show a number as hexadecimal?
22:36:05 <jle`> ty bitemyapp 
22:36:37 <jle`> JamesJRH: showHex
22:36:42 <jle`> > showHex 123 ""
22:36:44 <lambdabot>  "7b"
22:37:03 <kadoban> So, my first serious GHCJS project is now performant enough to actually use, yay. This is pretty cool.
22:37:25 <JamesJRH> Brilliant. Thanks jle`.
22:37:32 <jle`> JamesJRH: if you have lens you can also use 'review hex'
22:37:36 <jle`> > review hex 123
22:37:37 <lambdabot>  "7b"
22:37:44 <jle`> kadoban: congrats :)
22:38:00 <kadoban> Thanks :)
22:42:52 <mniip> > preview hex "moo"
22:42:53 <lambdabot>  Nothing
22:42:57 <mniip> > preview hex "7b"
22:42:58 <lambdabot>  Just 123
22:43:06 <mniip> nod
22:44:56 <ReinH> kadoban: what are you doing with ghcjs?
22:46:31 <JamesJRH> Is there a ‘concatWith’ or ‘joinWith’ function that inserts a specified element between each concatenated list?
22:46:48 <jle`> intercalate or intersperse
22:47:19 <kadoban> ReinH: A long time ago I made a … well it's like a bitcoin script "debugger", it decodes and executes bitcoin scripts and shows you all the steps. I originally did it as a CGI application just kind of as a toy, and it was okay but I never released it because it … didn't really have any way to prevent people from spamming my server and using a crapton of CPU. So I'm reusing the code to have it run it JS client-side instead, so they can do whatever 
22:47:20 <kadoban> they want and it won't hurt me.
22:48:09 <JamesJRH> jle`: Thank you, there're just it.
22:49:08 <kadoban> It was one of the first things I ever wrote in haskell quite a while back, so it needed lots of cleaning up. It was doing lots of bad stuff which I got away with because haskell is fast enough, but when run in JS the problems were apparent, heh.
22:49:18 <mniip> kadoban, bitcoin scripts are designed to always terminate though
22:49:31 <mniip> it's the memory abuse that is the problem (think repeated concats)
22:49:37 <jle`> over the break i was working on neural networks using Vector
22:49:50 <jle`> imagine my delight when i found out i could compile them to GHCJS
22:49:57 <jle`> and run my NN's on pure javascript
22:50:03 <JamesJRH> Particularly intercalate, in-general, though in specific cases, intersperse can also be used…
22:50:07 <kadoban> mniip: Yes, but you can still do a lot of crap that would use CPU, like run a bunch of hashes that would be annoying.
22:50:18 <bitemyapp> jle`: >delight
22:50:22 * mniip . o O ( a miner in bitcoin script )
22:50:28 <bitemyapp> jle`: we share different definitions of delight
22:50:51 <kadoban> mniip: Yes, that was what I was expecting to happen if I released it. It wouldn't net anyone any coins, but I doubt that'd stop anyone.
22:51:35 <ReinH> kadoban: cool. Shame about bitcoin though.
22:51:58 <kadoban> ReinH: Haha, yeah XD
22:52:21 <jle`> bitemyapp: :p
22:52:24 <jle`> site should be back up
22:52:27 <jle`> i've been working on rewriting
22:56:10 <bitemyapp> jle`: :)
23:02:23 <Guest00000> hm, lens...
23:04:47 <Guest00000> are they nice?
23:06:45 <Guest00000> heh, that image is funny... https://ro-che.info/ccc/images/lens.png
23:09:13 <kadoban> That's pretty cute.
23:10:09 <Guest00000> i'm sorry...
23:10:40 * hackagebot Gifcurry 0.1.0.0 - Create animated GIFs, overlaid with optional text, from movies.  https://hackage.haskell.org/package/Gifcurry-0.1.0.0 (lettier)
23:16:03 <thimoteus> haha that lens comic
23:16:49 <JamesJRH> s/there're/they're/
23:16:49 <MarcelineVQ> :X
23:16:57 <JamesJRH> Okay, I have it not…
23:16:59 <JamesJRH> now*
23:17:17 <JamesJRH> MarcelineVQ, geppettodivacin, geekosaur, jle`: $ ghc -ignore-dot-ghci -e 'putStrLn =<< fmap (Data.List.intercalate ", " . map ((flip Numeric.showHex "") . Data.Char.ord)) getLine' < <(printf %s '​​​> 1 + 1')
23:17:21 <JamesJRH> 200b, 3e, 20, 31, 20, 2b, 20, 31
23:17:23 <JamesJRH> :-D
23:17:46 <JamesJRH> Re.: 05:01:47 < MarcelineVQ> ​> 1 + 1
23:18:28 <JamesJRH> Before I just looked at it in GVim, now I did it in Haskell. :-)
23:22:45 <JamesJRH> Of course, also just: putStrLn =<< fmap (Data.List.intercalate ", " . map ((flip Numeric.showHex "") . Data.Char.ord)) getLine  -- Paste and press enter.
23:24:34 <JamesJRH> Prelude> putStrLn =<< fmap (Data.List.intercalate ", " . map ((flip Numeric.showHex "") . Data.Char.ord)) getLine
23:24:37 <JamesJRH> > 1 + 1
23:24:39 <JamesJRH> 200b, 3e, 20, 31, 20, 2b, 20, 31
23:24:53 <mniip> ah, ZWS
23:28:15 <JamesJRH> mniip: MarcelineVQ's trick to fake lambdabot not working earlier, which worked for me because my client + terminal emulator displays it correctly, thus invisible to me. :-)
23:28:30 <mniip> I figure
23:28:38 <jle`> i always liked `f . g =<< x` over `f =<< fmap g x`
23:28:50 <mniip> there's also this
23:28:54 <mniip> > 1 + 1
23:28:57 <JamesJRH> Oh.
23:29:20 <nyon> What database client library offers the most compile-time safety guarantees? I'm using PostgreSQL.
23:30:31 <JamesJRH> jle`: That does seem nicer. Let me try that on whatever it was that mniip just wrote…
23:33:25 <zomg> nyon: I think acid-state is probably the most typesafe option
23:33:47 <zomg> but it might not be the easiest to get started, at least the last time I looked it wasn't at all obvious how to deal with it in a production type environment
23:34:16 <JamesJRH> $ ghc -ignore-dot-ghci -e 'putStrLn . Data.List.intercalate ", " . map ((flip Numeric.showHex "") . Data.Char.ord) =<< getLine'
23:34:19 <JamesJRH> 07:28:31 < mniip> > 1 + 1
23:34:22 <JamesJRH> 30, 37, 3a, 32, 38, 3a, 33, 31, 20, 3c, 20, 6d, 6e, 69, 69, 70, 3e, 20, 3e, a0, 31, 20, 2b, 20, 31
23:34:47 <JamesJRH> mniip: I can't see anything weird there, nor when pasted into GVim.
23:34:55 <mniip> it's right there
23:34:56 <JamesJRH> What's the trick?
23:34:56 <nyon> zomg: Ah, thanks! Will have a look.
23:35:03 <mniip> :)
23:35:25 <JamesJRH> a0
23:35:35 <johnw> zomg: acid-state isn't a database client library
23:35:57 <johnw> zomg: it's a persistence library that writes out its state to disk; it's not a way to talk to external databases
23:36:24 <JamesJRH> Ah, U+00A0 NO-BREAK SPACE on the /other/ side of the ‘>’.
23:36:28 <liste> it can act in client-server mode though, where multiple computers can share a state
23:36:32 <johnw> nyon: the 'persistent' library (and 'esqueleto') aren't bad; they type check your code as an enconding of the schema
23:36:36 <JamesJRH> mniip: I wasn't looking there. :-P
23:37:00 <johnw> liste: true, but it's still not talking to a external database like PostgreSQL or MySQL; acid-state is its own thing
23:37:21 <johnw> s/as an enconding/using an encoding
23:37:40 <nyon> johnw: Also checking. Thanks!
23:41:36 <zomg> johnw: yeah I guess that's true, but he wasn't asking for any specific db
23:41:48 <johnw> zomg: fair point
23:41:51 <zomg> but yeah persistent should be pretty good if you want to work with an SQL db (which may be a more realistic choice anyway)
23:42:36 <JamesJRH> How do I make ‘putStrLn =<< getLine’ repeat continuously until EOF? (I.e. when I press ^D twice or ^D on a newline.)
23:43:04 <adam_> I think that Control.Monad had forever
23:43:11 <adam_> :t forever
23:43:12 <lambdabot> Monad m => m a -> m b
23:43:45 <liste> not sure what it does with EOF though
23:43:57 <mniip> ^D will make getLine throw
23:45:20 <shanemikel_> my math teacher actually tried to convice me tonight that the triangle given by 3 points in R3 doesn't need it's constituent angles to add up to pi by bending her fingers.. essentially that triangles are different in 3d
23:46:07 <mniip> w h a t
23:46:10 <liste> non-euclidean geometry?
23:46:40 <mniip> they might be referring to triangles on a sphere, but that's not what triangles in R^3 usually means
23:47:09 <nyon> The sphere is usually called S^2, not R^3, anyway. :-p
23:47:16 <shanemikel_> no, because the problem was supposed to be solved with vectors
23:49:23 <shanemikel_> and the cos(theta)|v||u|=v.u relation
23:49:56 <adam_> http://uncyclopedia.wikia.com/wiki/Proof_that_the_angles_of_a_triangle_sum_to_360_degrees
23:51:04 <adam_> looks like your teacher was right 
23:52:07 <ReinH> there are no 3d triangles
23:53:17 <shanemikel_> sure, well it was clear which angles we were talking about.. and she was trying to convice me that each line/vector constituent of the triangle given by 3 points in R3 need not share in common with each other line/vector exactly one and the same plane
23:54:01 <ReinH> What
23:54:26 <adam_> in case you didnt read it, the article is bullshit
23:54:41 <ReinH> three points uniquely determine a plane
23:54:45 <adam_> I just found the first thing that looked vaguely pluasable
23:54:49 <ReinH> so of course they are on the same plane
23:54:59 <shanemikel_> well, she didn't seem to realize that
23:55:07 <ReinH> ...
23:55:30 <adam_> ReinH, what if you have 3 points that you draw on a piece of paper, then curl the paper!!!
23:55:34 <ReinH> (This is the reason that a three-legged table is always balanced.)
23:55:43 <ReinH> adam_: yes, what if
23:56:11 <adam_> Then by the curled paper theorem you actual have a portion of a sphere
23:56:17 <mniip> [10:54:18] <ReinH> three points uniquely determine a plane
23:56:17 <ReinH> ok
23:56:18 <mniip> that's like
23:56:21 <mniip> one of the axioms
23:56:24 <adam_> so clearly the agnels must be greaterr then 200
23:56:33 <JamesJRH> adam_: ‘Control.Monad.forever (putStrLn =<< getLine)’ /sort/ of does what I want, except that backspace inserts ‘^?’ rather than deleting the previous character and ^D just inserts ‘^D’. ^C has to be used to keyboard interrupt.
23:56:34 <shanemikel_> puzzled the shit out of me.. like somebody was trying to convice me that the 3 dimensions I know and love (that I happen to reside in) were really some N-dimensional alternate universe..
23:56:54 <mniip> well ^? is due to the stty hackery I think
23:56:57 <adam_> shanemikel_ you wanna know a real mind fuck
23:57:01 <ReinH> shanemikel_: sounds wacky
23:57:04 <adam_> what is the dimensions of a shadow
23:57:06 <adam_> 2d
23:57:15 <adam_> that means when you take the shadow of something you drop a dimension
23:57:25 <adam_> so us 3d things are really just the shadow of a 4d world
23:57:35 <shanemikel_> lol
23:58:20 <puregreen> JamesJRH: hSetBuffering stdin LineBuffering
23:58:38 <puregreen> JamesJRH: do this before running the loop and backspace will start working
23:58:45 <JamesJRH> adam_, liste, mniip: What I'm thinking of should resemble the ‘cat’ shell utility.
23:59:10 <adam_> honestly I am not the right person to ask, but puregreen seems to know what he is talking about
23:59:24 <mniip> uhh
23:59:28 <shanemikel_> looks like this semester is gonna be wacky.. I wonder what the tests are gonna be like if my prof has a special definition of common shapes and geometries themselves, yet neglects to share those definitions with the class
23:59:30 <mniip> advanced IO in haskell
23:59:32 <puregreen> adam_: I googled “haskell getline backspace” and took the 1st result
23:59:32 * mniip bails out
