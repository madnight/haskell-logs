00:21:27 <hc> hi
00:21:54 <hc> my last upload to hackage still hasn't built yet... it's been a few hours now... it there a problem with the build system?
00:24:21 <geekosaur> hc, try asking in #hackage?
00:26:05 <nocturne777> I want to use fast-logger, but I don't see full-fledged file rotation functionality
00:26:20 <nocturne777> do you guys rotate your files with a script or something ?
00:26:54 <KaneTW> usually logrotate does that
00:27:03 <hc> geekosaur: thanks
00:29:08 <nocturne777> figured as much
00:33:05 <nocturne777> KaneTW: do you use monad-logger on top of fast-logger?
00:35:19 <KaneTW> usually
00:36:33 <nocturne777> I hear that monad-logger prints line numbers as well
00:38:35 * hackagebot stable-marriage 0.1.1.0 - algorithms around stable marriage  https://hackage.haskell.org/package/stable-marriage-0.1.1.0 (KatsutoshiItoh)
00:41:25 <bollu> when someone "cabal install"'s my package from Hackage, is it possible to do things like create directories / run a shell script?
00:41:36 <bollu> I'm writing a haskell command line tool that needs some setup for it to run
00:41:43 <bollu> it needs a folder creation and a symlink
00:41:50 <bollu> and an install into /usr/local/bin as well
00:41:57 <bollu> so, well, how do I do this at install time?
00:42:00 <hc> why not do this the first time your command is run?
00:42:14 <bollu> hc: hm, I suppose. but it's neater if it just happens, right?
00:42:43 <hc> why do you need a global directory? shouldn't each user have their own working directory?
00:42:52 <hc> like ~/.yourtool
00:42:52 <athan> bollu: I think stack / cabal have their own idea of build directories and install directories
00:43:04 <bollu> hc: yes the config file lives there. 
00:43:17 <bollu> hc: I need the install script for a slightly different purpose
00:43:35 <athan> if I were you, I would tell your users to add it to the PATH
00:43:39 <bollu> hc: I need the user to source a shell script (since my haskell script is exposed through a few lines of shell code)
00:44:02 <bollu> hc: since I mess with the working directory, I can't do it inside the haskell script. It *has* to be a bash script
00:44:14 <bollu> athan: how so? I ask users to add my tool to their $PATH after install?
00:44:33 <bollu> athan: but that's sorta.. icky? :)
00:44:38 <athan> bollu: Yeah, like `~/.local/bin` I think is the default for stack :)
00:44:43 <athan> ehh, yeah...
00:44:46 <athan> but it's more maintainable
00:45:03 <athan> and less invasive
00:45:11 <hc> i kinda like the idea of 'cabal install' not messing with my system configuration ;-)
00:45:12 <athan> for instance, I might not have a /usr/local/bin
00:45:16 <bollu> athan: yeah I suppose you're right.
00:45:22 <bollu> hc: fair enough :)
00:45:38 <bollu> lemme look at how ghc-mod does it and model my tool after that?
00:45:41 <athan> bollu: I am no pro on this, but cabal / stack are meant to be build tools than install / management tools, iirc
00:45:47 <hc> what's the name of your tool btw?
00:46:02 <bollu> hc: warp
00:46:06 <bollu> hc: I'm really new to haskell
00:46:16 <bollu> hc: well, doing useful things with haskell :P
00:46:36 <athan> bollu: :) that's a great way to start!
00:46:39 <bollu> hc: https://github.com/bollu/warp-haskell
00:47:00 <hc> thanks
00:47:12 <bollu> athan: hahaha, yeah I suppose so :) I've learnt a decent amount of haskell for the "ideas". I decided to actually build something small end-to-end
00:47:32 <bollu> and maybe blog-post stuff I learnt as a result of it
00:48:24 <athan> :) get at it!!
00:48:48 <bollu> athan: :D your enthusiasm is infectious
00:48:50 <bollu> will do!
00:49:20 <bollu> question: Right now all my code is in App.hs. I'm not using Lib.hs at all. Is this correct?
00:49:29 <bollu> I'm using stack's default folder configuration
00:50:34 <bollu> hc: if you go through the code, I would kill for comments :)
00:51:16 <hc> bollu: have you tried running hlint on your code yet?
00:51:29 <athan> bollu: condescending answer: oh, maybe you should check the docs!
00:51:29 <hc> it has some good advices usually... also in your case ;)
00:51:35 <bollu> hc: nope I haven't. will that point out a lot of obcious things?
00:51:39 <hc> yeah
00:51:39 <bollu> obvious*
00:51:41 * athan has been playing too much Knights of the old Republic
00:51:43 <bollu> hc: cool ty :)
00:51:54 <bollu> athan: :P I shall. Sometimes it's faster to ask people
00:51:56 <athan> bollu: I'd suggest getting used to making your own modules and stuff :)
00:52:03 <athan> oooooohhhhh trust me I know
00:52:11 <athan> I'm pretty abusive of this channel ._.
00:52:21 <bollu> athan: the thing is, for something like this, I don't see the point of making it modular
00:52:26 <bollu> the entire thing is < 300 LOC
00:52:32 <athan> bollu: I wouldn't, then!
00:52:40 <athan> I usually keep my files around that size :)
00:53:01 <bollu> athan: so in that case, I need to change stack's default build settings from building a "lib" and an "exe" to just building an "exe" I guess
00:53:03 <bollu> that should be fun
00:53:22 <bollu> athan: yeah, I like sticking to between 400-500 LOC
00:53:33 <athan> I don't think I've actually ever done that o_O
00:54:01 <bollu> athan: changing stack's build settings?
00:54:04 <bollu> or sticking to file sizes?
00:55:28 <bollu> oh wait hackage and stackage are different?
00:56:50 <bollu> also, does Hackage support CSS improvements of any sort?
00:57:08 <bollu> I think I could maybe polish up some bits (eg. the registration form looks messed up)
00:57:48 <hc> hackage source is in a github repository iirc
00:58:02 <hc> 09:49 -!- goto-bus-stop [renekooi@gateway/vpn/mullvad/x-vetgcxqmowkxsfpg] has joined #haskell
00:58:05 <bollu> cool, I'll check it out
00:58:08 <hc> oops
00:58:10 <hc> https://github.com/haskell/hackage-server
00:58:58 <bollu> I fork so much >_< I have so many plans. IDK if I'll actually do anything with it P
01:00:31 <bollu> how do I generate documentation for a tool?
01:00:44 <bollu> I'm confused, hackage only talks about libraries
01:03:23 <athan> stack haddock :)
01:03:29 <athan> or `cabal haddock`, which ever
01:03:35 <athan> they usually build to `dist/docs`
01:03:43 <bollu> no, I mean, how do I tell it where to get the docs from?
01:03:49 <bollu> I don't understand the documentation story of haskell
01:03:55 <bollu> is it like Python (docstrings)?
01:04:24 <athan> o.o
01:04:30 <bollu> ?
01:04:36 <athan> bollu: cabal/stack checks all the modules you have listed in your .cabal
01:05:01 <athan> if it finds the right comment syntax, like the haddock syntax, then you're super good to a-okay super fun-time wow
01:05:05 <athan> but if not, you're borked
01:05:21 <bollu> ah okay :) So I want to know where I can read about the comment synta
01:05:38 <athan> Well... there's the documentation, but it can be hard to read
01:05:44 <athan> I'd suggest looking at other people's code!
01:05:51 <athan> I actually learned from the text pacakge
01:05:54 <athan> @hackage text
01:05:54 <lambdabot> http://hackage.haskell.org/package/text
01:06:05 <athan> like /italics/, __bold__
01:06:06 <bollu> thanks :)
01:06:09 <athan> np :)
01:25:28 <zaquest> http://lpaste.net/148412 why doesnt this program print "the end"?
01:26:21 <athan> zaquest: You should threadDelay /before/ you kill the thread
01:26:31 <athan> because otherwise you immediately kill it
01:26:41 <athan> you might run into a race condition, too
01:26:57 <nocturne777> does monad-logger actually print timestamps as well?
01:27:12 <zaquest> athan, for how long should i threadDelay?
01:27:16 <nocturne777> I looked at the source code and I have not noticed a place where it does that
01:28:05 <athan> nocturne777: I haven't seen it do so, but you could probably make your own version that did!
01:28:18 <ReinH> zaquest: as long as it takes and no longer.
01:28:24 <zaquest> athan, it seems weird, does it really depends on some time constant...
01:28:34 <athan> by augmenting the `runStderrLoggerT` or which ever
01:28:59 <athan> zaquest: well, you'd be immediately killing the thread otherwise, then waiting for a while needlessly
01:29:17 <ReinH> zaquest: if you want to wait for the other thread to finish, you shoud use something like race from the async package
01:29:19 <athan> you would be waiting _after_ you killed the thread that should print "the end"
01:29:24 <ReinH> In fact, you should use the async package anyway.
01:29:51 <zaquest> oh, no, this threadDelay at the end is there to make sure that the program has enough time to print "the end", ReinH, athan 
01:30:11 <ReinH> zaquest: Ok. You should use the async package.
01:30:18 <nocturne777> athan: I am currently using tinylog, which does that
01:30:19 <athan> :|
01:30:48 <nocturne777> but ability to see source code line numbers in logs is tempting me to switch to monad-logger
01:31:08 <ReinH> zaquest: you should also read Simon Marlowe's free book.
01:31:15 <ReinH> *Marlow
01:32:33 <zaquest> ReinH, i dont understand, is that that i put the question incorrectly or it's just `finally` is unreliable and i should use async package?
01:33:22 <ReinH> zaquest: it doesn't matter what you do in a thread that you fork if the main thread terminates it.
01:33:34 <ReinH> So yes, finally is unreliable in this case.
01:34:05 <ReinH> When the main thread terminates, it terminates all child threads with extreme prejudice.
01:34:11 <ReinH> If you want more control over such things, use async
01:34:21 <ReinH> To understand all of this better, read Simon's book.
01:34:23 <zaquest> ReinH, that is why there's threadDelay at the end
01:41:11 <gamer> hello
01:41:40 <ReinH> gameer: o/
01:42:38 <gameer> I have problems with a task, which is about Trees, can someone maybe help a bit?
01:46:36 <ReinH> Only if you ask a question.
01:47:02 <gameer> Yeah, i try to explain, what it is about, as short as possible
01:48:27 <gameer> It is about sequential two player games with full information. So no player knows more than the other and they play by turns
01:48:52 <gameer> There are two functions given:
01:50:05 <gameer> findPossibleMoves :: Player -> state -> [(strategy,state)]   This calculates all possible Moves that one player can do in a move
01:52:29 <gameer> identifyWinner :: state -> Player -> Maybe Player    This calculates a winner for an move and an actual player. If remi or nobody won yet, it gives Nothing out
01:53:20 <gameer> uhm so many text..
01:53:47 <ReinH> gameer: is this related to this question? http://stackoverflow.com/questions/34511943/a-do-nothing-guard-for-a-recursive-function
01:54:30 <gameer> wow
01:55:05 <gameer> yes
01:55:15 <gameer> How u found it?
01:56:06 <ReinH> gameer: I answered it.
01:56:15 <gameer> :D
01:56:37 <gameer> I sit so long on this task and thought, maybe someone can help here
01:56:49 <gameer> (and sorry, if my english is bad, its not my mother language)
01:56:55 <ReinH> it's fine
01:57:03 <ReinH> what's the question?
01:58:24 <gameer> I need a bit help to get into the theme, i don't know how to get an solution :s
01:58:34 <ReinH> So you want to generate a game tree?
01:59:20 <gameer> Yes
02:00:13 <ReinH> Imagine that you have a data structure called GameState
02:00:36 <zaquest> http://lpaste.net/148414 here is my attempt with async package, same behaviour, i didnt found anything similar to `finally` in async so it uses `finally`. i'll try to describe my problem again: i want to clean up ("the end") when forked thread finishes/dies, it might be required to kill the thread from outside, but how to make sure that second argument to `finally` will be exectued?
02:00:38 <ReinH> This contains all the information necessary to determine a game state. Board position, which player is to act, etc.
02:01:03 <ReinH> Now imagine that you have a function nextMoves :: GameState -> [GameState]
02:01:19 <ReinH> that takes a given game state and generates every possible move that can be made.
02:01:57 <ReinH> gameer: are you following me so far?
02:02:04 <bollu> if I have a shell script that needs to be "installed" along with my package
02:02:57 <bollu> what's the correct way to do this? and where should the shell script be in the repo?
02:02:57 <bollu> code in question: https://github.com/bollu/haskell-warp
02:03:15 <bollu> I should allow the package to be installed as it is, that much athan explained :) But then what about the shell script
02:03:20 <quchen> zaquest: have a look at waitCatch
02:03:31 <bollu> how do I package the shell script so that it too goes into the default install folder? (~/.cabal/bin) or wherever the default is?
02:03:57 <gameer> ReinH: yes
02:04:21 <ReinH> gameer: now you want to generate a game tree. The logical thing to do is to start at the root, some GameTree x, and generate the next positions.
02:04:22 <quchen> zaquest: Although that's not the same as what "forkFinally" does (which is a better "forkIO (x `finally` y)")
02:04:29 <ReinH> Then, for each next position, generate more next positions.
02:04:42 <ReinH> Then do this either forever or until all the leaves contain terminal positions (won/lost/drawn)
02:05:04 <ReinH> gameer: that's a game tree, right?
02:05:18 <gameer> yes
02:06:06 <gameer> I have an example for rock,paper,scissors
02:06:53 <gameer> http://i.imgur.com/fzcODRZ.png
02:07:11 <ReinH> gameer: this is exactly what `coiter nextMoves startPosition` gives you.
02:07:32 <zaquest> quchen, thank you for forkFinally. missed it.
02:07:59 <bollu> also, does anyone have a boilerplate travis.yml that I can use for CI?
02:08:09 <ReinH> a tree generated by taking the nextMoves  of each leaf until you run out of leaves
02:08:41 <bollu> ReinH: whoa, you can use a comonad to do this?
02:09:22 <gameer> hmm
02:10:14 <frerich> gameer: I think if your 'findPossibleMoves' function would take into account that the game is over (i.e. there are no further possible moves), then you're done already, no? That'll yield tree nodes with no descendants.
02:10:31 <bollu> ReinH: the docs read "Cofree comonads are dual to free monads". So are there "Cofree monads" and "free Comonads" as well?
02:10:52 <ReinH> There are free monads and cofree comonads
02:10:54 <ReinH> but ignore that
02:10:58 <ReinH> and let's work with Data.Tree
02:12:12 <ReinH> :t let coiter next a = Data.Tree.Node a (coiter next <$> next a) in coiter (undefined :: gameTree -> [gameTree]) (undefined :: gameTree)
02:12:14 <lambdabot> Tree a
02:12:35 <gameer> This is very complex :'D
02:12:56 <ReinH> There's some line noise
02:13:20 <ReinH> coiter next a = Node a (fmap (coiter next) (next a))
02:13:26 <ReinH> genenerates a tree from ``a''
02:13:31 <gameer> Wait a minute
02:13:38 * hackagebot tar 0.4.4.0 - Reading, writing and manipulating ".tar" archive files.  https://hackage.haskell.org/package/tar-0.4.4.0 (DuncanCoutts)
02:13:52 <ReinH> ok
02:14:05 <bollu> which testing package should I use? QuickCheck / HSpec / something else?
02:14:20 <ReinH> bollu: I like hspec. You can use quickcheck with hspec.
02:14:33 <gameer> I am allowed to use functions from  Prelude  and from Data.List. Not allowed to use other (external) Modules
02:14:52 <ReinH> gameer: then how do you represent your game tree?
02:15:08 <ReinH> Neither Prelude nor Data.List export a tree.
02:15:19 <gameer> With this limitation ur Solution is not possible or?
02:15:32 <ReinH> Well, if you don't have a tree then you can't construct a tree
02:15:46 <bollu> ReinH: so quickcheck is more higher level than hspec?
02:15:47 <ReinH> so how are you supposed to represent a game tree?
02:16:03 <ReinH> bollu: hspec lets you do both usual unit tests and property tests via quickcheck.
02:16:20 <bollu> ReinH: oh, nice! thanks :)
02:16:29 <gameer> I have this: data Tree v e = Node v [(e,Tree v e)]
02:16:36 <ReinH> bollu: if you're using stack you can use the hspec template that I wrote
02:16:51 <ReinH> gameer: what are e and v?
02:17:16 * frerich guesses 'vertices' and 'edges'
02:17:17 <bollu> ReinH: yes I'm using stack
02:17:24 <ReinH> if you change it to data Tree a = Node a [Tree a] then you can use my solution.
02:17:25 <bollu> ReinH: can I have a link to the template?
02:17:41 <ReinH> bollu: just `stack new foo hspec`, it's already in the official templates
02:18:11 <ReinH> I don't see why you would need your data type versus mine.
02:18:24 <ReinH> but I do want to explain *how* it works.
02:18:28 <bollu> ReinH: but my project is already around with the simple template. I don't want to recreate all of that :(
02:18:36 <ReinH> bollu: ok.
02:18:46 <ReinH> then go write all the files and edit the cabal file yourself
02:18:48 <bollu> ReinH: can I still see what your template does?
02:18:49 * ReinH shrugs
02:18:54 <bollu> ReinH: so I can get an idea
02:18:55 <ReinH> sure, there isn't much to it
02:18:56 <bollu> ReinH: :)
02:19:05 <ReinH> it basically just follows the directions on the hspec site
02:19:25 <ReinH> bollu: https://github.com/commercialhaskell/stack-templates/blob/master/hspec.hsfiles
02:19:29 <athan> https://github.com/athanclark/hi-quickcheck-lib !
02:19:50 <bollu> thanks :D
02:20:05 <bollu> you guys are awesome ^_^
02:20:15 <frerich> gameer: It looks like each vertex in your tree is a game state and each edge is a move? If so, note that you can represent the same thing by dropping the concept of edges completely (i.e. go with ReinH's suggestion) and rather have each vertex be a tuple of move + gamestate.
02:20:31 <ReinH> yep
02:20:39 <ReinH> Or you can adapt my solution to your structure
02:21:12 <ReinH> But the basic idea is the same as defining map for lists
02:21:21 <gameer> With vertex u mean the nodes?
02:21:47 <frerich> gameer: Yes (I thought 'v' stood for vertex and 'e' for edge)
02:21:59 <ReinH> constructing the game tree is: construct the node where the element is the starting element and the children are (construct all the nodes where the element is that next move and the children are (construct all the nodes where the element is that next move and the children are (construct all the nodes where...
02:22:18 <gameer> Each node (g,p) represents a GameState g and  the actual player p
02:22:27 <ReinH> gameer: merge the player in to the gamestate.
02:22:39 <gameer> Sorry guys, I need always a bit to understand all u wrote :d
02:22:40 <frerich> gameer: The current player could be considered part of the game state, I gues.
02:23:42 <frerich> gameer: One thing I often did for such games was to have a list of players part of the game state (i.e. I had a function 'players :: Game -> [Player]' somewhere) and the 'current' player is the first element of the list - and when it's the next players turn, I rotate the list (and for a game of Uno, you might want to reverse the list :-)
02:24:25 <bollu> does stack have a `stack test` or some such?
02:24:34 <bollu> also, ReinH: the default template comes with a Spec.hs !
02:24:41 <ReinH> bollu: well yes
02:24:56 <ReinH> here's a silly gametree example where each level has n children labeled n:
02:24:58 <ReinH> > let coiter next a = Data.Tree.Node a (coiter next <$> next a) in coiter (\x -> replicate x (succ x)) 1
02:25:00 <lambdabot>  Node {rootLabel = 1, subForest = [Node {rootLabel = 2, subForest = [Node {ro...
02:25:12 <ReinH> or maybe I got that wrong and it's n - 1 children labeled n.
02:25:18 <ReinH> anyway, you can see that it works.
02:25:36 <ReinH> bollu: and yes, there is stack test
02:25:45 <bollu> ReinH: yeah, I just checked :) ty
02:26:20 <ReinH> yeah I guess I meant (\x -> let x' = x + 1 in replicate x' x') but anyway
02:26:29 <bollu> I'm getting a syntastic error - "ghc_mod: can't pass version string(abnormal termination)"
02:26:39 <bollu> can't parse*
02:26:40 <ReinH> bollu: you should probably fix that then
02:27:01 <bollu> ReinH: yes I'm working on it, but ghc_mod seems to be correctly installed
02:27:12 <ReinH> Well, the error says otherwise *shrug*
02:27:25 <ReinH> it could be your editor isn't configured properly
02:27:52 <bollu> ReinH: yep, probably
02:28:37 <ReinH> gameer: anyway, this idea that you are constructing a potentially infinite structure by applying a "generate the next level" function to all elements at each level is captured by this "Cofree f" idea, where f represents the positions at each level
02:28:54 <ReinH> iow, Cofree [] means "each child generates a list of children"
02:29:22 <ReinH> I stripped away the Cofree stuff and just ported the definition of coiter to work with standard rose trees.
02:29:32 <ReinH> Since that's what you care about for a game tree.
02:29:43 <gameer> aah
02:29:57 <gameer> I never heard from Cofree before 
02:29:57 <ReinH> But to extend the analogy, Cofree Maybe represents "each child has zero or one children"
02:29:59 <ReinH> iow it's a list
02:30:14 <ReinH> Cofree Identity represents "each child has exactly one child"
02:30:17 <ReinH> iow it's an infinite stream
02:30:37 <ReinH> and you get other, more esoteric, structures for other choices of f
02:30:50 <ReinH> data Pair a = Pair a a generates an infinite, balanced, binary tree.
02:31:23 <ReinH> you only care about the version for rose trees but I thought I might present the general version as well.
02:31:46 <Fuco> isn't Free Maybe a list?
02:31:46 <ReinH> the version for trees is just a specialization of that general unfolding.
02:31:47 <bollu> ReinH: where can I read more about cofree?
02:31:57 <ReinH> bollu: Well.
02:33:03 <ReinH> Free Identity is a list where Pure gives the terminal element.
02:33:51 <ReinH> Free Maybe is something else.
02:34:32 <ReinH> Apparently it's a "partiality monad".
02:34:42 <ReinH> Fuco: ^
02:34:50 <Fuco> yea, reading :)
02:35:12 <bollu> ReinH: references for cofree? :)
02:35:23 <ReinH> Fuco: https://www.schoolofhaskell.com/user/jwiegley/free-monad-notes
02:35:28 <ReinH> thanks johnw
02:35:30 <Fuco> I need to study these more, I know the theory but I don't see the isomorphism very well :D
02:35:43 <Fuco> well... I knew the theory, I forgot most of it anyway
02:36:14 <ReinH> bollu: Uh. Category Theory in general, http://blog.sigfpe.com/2014/05/cofree-meets-free.html, http://dlaing.org/cofun/posts/free_and_cofree.html
02:36:15 <bollu> Fuco: is the theory all category theory?
02:36:38 <Fuco> well you can reframe it in other frameworks but mostly 
02:37:16 <ReinH> Fuco: Free Identity a = Pure a | Free (Identity (Free Identity a))
02:37:50 <ReinH> If you squint hard enough, you can see that this is equivalent to a list.
02:38:17 <gameer> ReinH: I have to say, I am very confused now
02:38:25 <ReinH> Wait, no, that's not right, is it.
02:38:28 <Fuco> how do you make an empty list out of that though?
02:39:48 <chrisbarrett> I think that's isomorphic to NonEmpty
02:40:05 <gameer> U write about so many Stuff, I never heard :D
02:43:14 <chrisbarrett> gameer: `Free Identity a` is, by its definition, structurally similar to a non-empty list. because there is a way to freely translate between these two types, we say they are *isomorphic*
02:43:36 <bollu> ReinH: ohh, so free is a sum type while cofree is a product type?
02:44:13 <gameer> If I understood it right, the base idea is, to check with identifyWinner, if there is a winner yet. If it is so, I do nothing. Else i built up the tree
02:44:15 <ReinH> bollu: Yes, as Free and Cofree are dual, so are products and coproducts
02:44:16 <gameer> So correct?
02:44:23 <chrisbarrett> gameer: cf `data NonEmpty a = a :| [a]`
02:44:29 <bollu> and the "branches" hold the values?
02:44:38 <ReinH> gameer: The idea is: collapse identifyWinner into a function that generates a list of next positions from a given position
02:44:53 <ReinH> gameer: if the position is winning, the list of next positions will be empty
02:44:58 <bollu> ReinH: okay, so, what exactly does "duplicate" do in the cofree comonad?
02:45:00 <chrisbarrett> (oops, I may have dropped into this conversation late and completely missed the context)
02:45:01 <ReinH> this is how you know when your tree generation terminates
02:45:08 <ReinH> bollu: the only thing it can do
02:45:38 * chrisbarrett returns to the shadows
02:45:45 <ReinH> chrisbarrett: no, you're right
02:46:15 <gameer> ReinH: if the position is winning, the list of next positions will be empty
02:46:31 <gameer> U mean if I have a winner, the tree ends?
02:47:01 <ReinH> gameer: yes, if you have a function nextPositions :: GameState -> [GameState]
02:47:07 <bollu> duplicate c@(_ :< fs) = Cofree c (fmap duplicate fs). I don't see how that's even doing anything!
02:47:18 <ReinH> if the game state x is winning or losing or otherwise terminal, nextPositions x = []
02:47:24 <bollu> oh wait, we wrap it another Cofree c, and then call duplicate on the inside?
02:48:03 <Fuco> chrisbarrett: what do you mean by "freely translate"
02:48:39 <gameer> ReinH: The tree will not be contunued if there is a winner, or the game finished with a draw, correct?
02:48:48 <bollu> what the hell is the Pairing magic? this is nuts / awesome
02:49:14 <ReinH> bollu: duplicate w = let (_ :< w)s = w in w :< fmap duplicate
02:49:19 <bollu> so we literally pair the Free DSL and the Cofree interpreter?
02:49:21 <ReinH> gameer: right
02:49:31 <ReinH> er, let (_ :< ws) = w
02:49:33 <ReinH> ofc
02:49:41 <ReinH> and w :< fmap duplicate ws
02:50:08 <gameer> okay
02:50:55 <ReinH> bollu: rather, duplicate w = w :< fmap duplicate (unwrap w) where unwrap (_ :< as) = as
02:50:55 <bollu> ReinH: I'm going to explore this with ghci. Thanks for the pointer
02:51:25 <bollu> ReinH: see that's my question. We "paste" the unwrapped w to the original
02:51:35 <bollu> ReinH: so we didn't "really" add another layer right?
02:51:52 <ReinH> bollu: of a comonad is a thing with an environment, you it by replacing the thing with (the thing with its environment) and its environment with (duplicating the thing at all points in the environment)
02:51:58 <gameer> ReinH: IdentifyWinner returns "Nothing", if the Game is not finished or the result is a draw. Do i have to differentiate this or can I see otherwise, if it is finished with a draw
02:51:59 <ReinH> s/of/if
02:52:35 <ReinH> er, s/you it/you duplicate it
02:52:35 <bollu> oh, that helped a ton as a descrption
02:52:41 <bollu> yeah
02:52:47 <bollu> oh, now I see what's going on
02:53:33 <ReinH> bollu: yeah, the cofree construction means that you literally apply the definition of a comonad.
02:53:42 <ReinH> that's the only thing you can do
02:54:39 <chrisbarrett> Fuco: NonEmpty and the Free monad are structurally similar in that you can put a thing in them and then sequence them with a monadic binding operation
02:55:40 <chrisbarrett> they're freely translatable in the sense that there exists a function mapping non-empty lists to a free identity monad, and vice-versa
02:56:24 <chrisbarrett> making them equivalent (up to isomorphism)
02:56:25 <Fuco> so by that you simply mean there is an isomorphism
02:56:30 <chrisbarrett> yes
02:56:38 <Fuco> right
02:56:38 <ReinH> chrisbarrett: wait, is that true?
02:56:51 <chrisbarrett> maybe? It's 12am here :p
02:56:53 <ReinH> chrisbarrett: were does Free Identit a store its a's aside from in the terminal Pure a?
02:56:57 <ReinH> *Identity
02:57:23 <ReinH> the Free (f (Free f a)) constructor doesn't contain any a's
02:57:27 <Taneb> Free Identity and Cofree Maybe are both non-empty lists, I believe
02:57:37 <Taneb> No, ReinH is right
02:57:47 <ReinH> It's a delayed a
02:57:51 <ReinH> it isn't a list.
02:58:09 <ReinH> Taneb: to be fair, I was wrong before too.
02:58:57 <Taneb> It's a bit confusing subject to think about when I'm still in bed and have an exam in 2 hours
02:59:00 <ReinH> Free Identity a is an "eventual a", where either you eventually unwrap Free constructors to get to a Pure a or you have an infinite number of Free constructors and never reach a Pure a.
02:59:11 <ReinH> It's an "you can have an a if you solve the halting problem" ;)
02:59:34 <ReinH> Cofree Maybe a is a list though
02:59:51 <chrisbarrett> thanks, that clears that up for me :)
02:59:57 <ReinH> er, Cofree Maybe is a nonempty list
02:59:59 <ReinH> it always stores an a
03:00:07 <ReinH> and then either a Nothing or another Cofree Maybe a
03:00:19 <ReinH> er
03:00:26 <ReinH> either a Nothing or a Just (Cofree Maybe a)
03:00:29 <ReinH> well
03:00:36 <ReinH> I'm mixing up type and value levels
03:00:48 <ReinH> it's an a :> Maybe (Cofree Maybe a)
03:00:50 <Fuco> so Cofree Identity is an infinite stream then
03:00:57 <ReinH> Yes. Exactly.
03:01:00 <Fuco> since you can't stop and just attach 'a's
03:01:13 <shachaf> I think that usually Free is data and Cofree is codata.
03:01:23 <ReinH> shachaf: I think so too.
03:01:38 <gameer> Hey guys, thanks for the help. I have to go now. 
03:01:48 <gameer> Maybe im back in a few hours :)
03:03:15 <ReinH> Fuco: so, the relevance to gameer's question is that coiter can construct "f-shaped" game "trees" (that might be trees or some other shape).
03:03:51 <Fuco> yea I got that, somehow Cofree [] was pretty clear right away :D
03:05:28 <Fuco> fun to think about this :P
03:05:41 <ReinH> If f is a functor that permits the notion of "indexing" then you get something that looks more like a tree. e.g., [] is a rose tree, data Bin a = Empty | Bin a a is a binary tree.
03:06:11 <ReinH> So Cofree f gives an "f-shaped" coinductive structure. Fun stuff.
03:06:24 <ReinH> or one with "f-shaped" children. Or something.
03:06:37 <Fuco> it reminds me a bit of Data.Fix which I had some exposure to before
03:07:24 <ReinH> Cofree Identity is the degenerate tree were the indexing goes "there is exactly one thing and here it is" ;)
03:07:29 <ReinH> so lists are degenerate trees :)
03:07:48 <Fuco> right
03:09:17 <phaazon> Cofree
03:09:24 <ReinH> Fuco: and for a functor representable by a, you get an infinite tree with |a| branches for each child. Etc.
03:09:27 <phaazon> I don’t know much about it :)
03:09:43 <phaazon> I also need to inquire about Representable
03:09:50 <phaazon> sounds cryptic to me for now
03:09:53 <ReinH> e.g., ((->) Bool) gives an infinite, balanced binary tree.
03:10:01 <ReinH> phaazon: (a,a) is represented by Bool
03:10:13 <ReinH> because I can use Bool to pick the fst or snd member of (a,a)
03:10:25 <phaazon> yeah but you cannot represent all (a,a)
03:10:39 <ReinH> Yes I can.
03:10:40 <phaazon> and I guess then (a,a) is representable by Maybe ()
03:11:02 <ReinH> No, it's representable by Bool. (a,a) is isomorphic to Bool -> a up to bottoms.
03:11:04 <phaazon> Just () = snd and Nothing = fst
03:11:15 <phaazon> ReinH: so hm
03:11:27 <phaazon> if I have, for instance, (3,5)
03:11:40 <phaazon> how do you handle that with Bool?
03:11:50 <phaazon> like, how do you change (3,5) to (1,5) with Bool only?
03:12:03 <Fuco> ah, that's not what representation is
03:12:10 <phaazon> so what it is for?
03:12:15 <Fuco> you are simply changing the type to a function into another set
03:12:21 <Fuco> (a,a) into Bool -> a
03:12:23 <phaazon> oh
03:12:25 <phaazon> I see
03:12:30 <Fuco> True gives fst, False gives snd
03:12:47 <Taneb> (or equivalently vice versa)
03:12:51 <phaazon> like representing an array (Array a) with a function (Int -> Maybe a) for instance
03:12:51 <Fuco> so any pair, like (1,5) is equivalent to a function f True = 1, f False = 5
03:13:23 <ReinH> phaazon: index (3,5) True = 3; index (3,5) False = 5
03:13:23 <phaazon> Fuco: well I guess it works for any types which accept exactly two inhabitants
03:13:24 <phaazon> like Maybe ()
03:13:31 <Fuco> right
03:13:39 * hackagebot board-games 0.1.0.2 - Three games for inclusion in a web server  https://hackage.haskell.org/package/board-games-0.1.0.2 (HenningThielemann)
03:13:43 <phaazon> or Either () ()
03:14:01 <phaazon> but hm, what is is used for?
03:14:06 <phaazon> s/is/it
03:14:30 <cocreature> do we have type level sets somewhere?
03:14:33 <hpc> morphisms, HUH! what are they good for?
03:14:43 <ReinH> phaazon: representable Functors are isomorphic to Reader and gain its properties for free.
03:14:59 <phaazon> yeah, looks like we can only read things with representations
03:15:00 <ReinH> hpc: absolutely nothing
03:15:20 <phaazon> hpc: I was more asking a true and concrete example, you know
03:15:34 <hpc> the joke was irresistable
03:15:39 <quicksilver> ReinH: aren't they isomorphic to subsets of reader's capabilities?
03:15:41 <Fuco> in CT you can use representable functors to "map" (represent) various categories with Set
03:15:46 <Fuco> and we know lots of things about Set
03:15:57 <Fuco> so you can use theorems "for free" on other sturctures
03:16:02 <phaazon> btw, why functors?
03:16:05 <ReinH> phaazon: e.g., https://www.schoolofhaskell.com/user/edwardk/moore/for-less
03:16:14 <phaazon> representing (a,a) with a Bool is not representing a “functor”
03:16:15 <Fuco> because they take a category C into Set
03:16:23 <Fuco> the functor is the representation
03:16:25 <phaazon> or I guess you mean Pair
03:16:37 <Fuco> F :: Pair a -> (Bool -> a)
03:16:55 <phaazon> Fuco: hm, ok
03:16:58 <ReinH> phaazon: (a,a) is a functor, it's just not the ((,)e) functor.
03:17:01 <phaazon> so it’s more a math functor then
03:17:12 <ReinH> fmap f (x,y) = (f x, f y) satisfies the laws
03:17:26 <phaazon> ReinH: yeah, but you cannot have that in Haskell
03:17:33 <ReinH> Sure you can.
03:17:39 <phaazon> well you have to use a newtype 
03:17:40 <ReinH> instance Functor (a,a) where
03:17:41 <quchen> data Tuple a = Tuple a a; instance Functor Tuple
03:17:44 <ReinH> No, you don't.
03:17:53 <phaazon> > fmap (*3) (1,2)
03:17:55 <lambdabot>  (1,6)
03:17:56 <ReinH> You just have to prevent it from conflicting with the ((,) e) instance.
03:18:02 <phaazon> ReinH: that’s nasty
03:18:10 <ReinH> It's a thought experiment.
03:18:16 <phaazon> yeah, ok
03:18:28 <phaazon> because otherwise, dealing with overlapping instances is not a very good thing
03:18:30 <ReinH> data Pair a = Pair a a deriving Functor
03:18:36 <ReinH> same thing
03:18:47 <quicksilver> they're not the same
03:18:49 <phaazon> well, at least we don’t have overlapping instances :P
03:18:59 <Fuco> hm, I must be missing something because there were Homs involved and I don't have that anywhere
03:19:01 <ReinH> quicksilver: ?
03:19:03 <quicksilver> (a,a) and Pair a would have different fmaps
03:19:07 <phaazon> @let data Pair a = Pair !a !a deriving (Functor)
03:19:08 <lambdabot>  Defined.
03:19:14 <phaazon> > fmap (*3) $ Pair 3 1
03:19:16 <lambdabot>      No instance for (Show (Pair b0))
03:19:16 <lambdabot>        arising from a use of ‘show_M784149854918385825219543’
03:19:16 <lambdabot>      In the expression:
03:19:18 <ReinH> quicksilver: no?
03:19:18 <quicksilver> (a,a) will have fmap :: (a -> b) -> (a,a) -> (a,b)
03:19:21 <phaazon> fuck
03:19:28 <ReinH> quicksilver: no
03:19:34 <ReinH> quicksilver: only with the instance defined in the Prelude
03:19:38 <phaazon> > let Pair a b = fmap (*3) $ Pair 3 1 in (a,b)
03:19:40 <lambdabot>  (9,3)
03:19:40 <quicksilver> ReinH: no, with any instance
03:19:45 <ReinH> No.
03:19:49 <quicksilver> ReinH: Functor is a type class for kind * -> *
03:19:57 <quicksilver> there is only one way that (a,a) has kind * -> *
03:20:05 <ReinH> quicksilver: Ah. Touche.
03:20:08 <haskell983> @pl id
03:20:09 <lambdabot> id
03:20:14 <ReinH> Ok, so not for (a,a). For Pair a.
03:20:21 <haskell983> \msg lambdabot @pl id
03:20:44 <Taneb> ReinH: I believe every data type has either one or zero valid instances for functor
03:20:54 <ReinH> Taneb: that's true.
03:20:59 <ReinH> quicksilver is right.
03:21:21 <ReinH> Replace all references to (a,a) above with data Pair a = Pair a a and reevaluate.
03:21:26 <phaazon> oh
03:21:30 <Taneb> I'm still annoyed there isn't a Monoid e => Monad ((,) e) instance in base
03:21:33 <phaazon> so that’s where tabulate comes from :D
03:21:46 <ReinH> phaazon: yes
03:22:01 <phaazon> @hoogle tabulate
03:22:03 <lambdabot> No results found
03:22:14 <phaazon> :t tabulate
03:22:15 <lambdabot> Not in scope: ‘tabulate’
03:22:16 <quchen> Taneb: That's a yearly bikeshedding discussion
03:22:24 <phaazon> hm, what’s its official package?
03:22:27 <phaazon> representable-functors?
03:22:49 <ReinH> phaazon: and it lets you build the machinery he uses in that SoH post.
03:22:55 <Taneb> quchen: it's less "what colour should we paint the bikeshed?" and more "should we have this bikeshed?"
03:22:58 <jophish> Hi everyone, happy new year :)
03:23:19 <Taneb> quchen: the corresponding Applicative instance exists
03:23:33 <ReinH> Taneb: and I'm still annoyed that the instance for Maybe is instance Monoid m => Monoid (Maybe m)
03:23:51 <quchen> Taneb: Oh. In that case, why not simply submit a patch?
03:24:08 <jophish> ReinH: what's the history of that?
03:24:11 <quchen> ReinH: Changing instances is hard, adding them is trivial
03:24:17 <ReinH> jophish: what quchen said.
03:24:29 <ReinH> jophish: Monoid entered base, Semigroup didn't.
03:24:44 <ReinH> So you can't very well have a Monoid instance depending on Semigroup if Semigroup isn't in base.
03:25:01 <jophish> I mean, is there a reason for that, or was not includind semigroup an oversight?
03:25:06 <jophish> including*
03:25:13 <ReinH> jophish: An oversight, I suppose.
03:25:19 <quchen> Wasn't regarded as useful enough
03:25:22 <jophish> ;(
03:25:26 <quchen> Just like we don't have Plus or Bind in Base
03:25:42 <ReinH> "We're going to take your monoid instance and throw away its mempty and replace it with our own for almost no reason"
03:25:46 <ReinH> It irks me.
03:25:55 <phaazon> quchen: Plus, isn’t the thing that brings return?
03:26:06 <Taneb> jophish: Semigroup wasn't inolder versions of base
03:26:15 <quchen> phaazon: That's Pointed.
03:26:16 <ReinH> It's also a broken instance.
03:26:26 <phaazon> I think I haven’t used return for, like, a year :D
03:26:29 <phaazon> since we have pure
03:26:31 <ReinH> Well, no, it isn't broken
03:26:33 <phaazon> oh right, Pointed
03:26:51 <ReinH> but it makes the original mempty no longer mempty
03:27:05 <quchen> phaazon: Plus brings mzero/empty
03:27:15 <ReinH> Anyway, it's past my bedtime. ttfn.
03:27:18 <phaazon> yeah, I think that doesn’t make any sense
03:27:45 <jophish> https://hackage.haskell.org/package/semigroups-0.18.0.1/docs/Data-Semigroup.html#t:Option
03:27:59 <phaazon> empty/mempty/whatever comes in monoidal structures, so wanting them alone is not really interesting I guess
03:28:53 <ReinH> Pointed is Data.Default without even a useful connotation.
03:29:03 <Fuco> (oh by the way, the Hom I realier said I'm missing is actually the (Bool -> a) which represents any function... so there :P)
03:29:04 <phaazon> and Data.Default is very wrong
03:29:27 <ReinH> It's not necessarily wrong. I just doesn't denote anything.
03:29:35 <ReinH> Its connotation is frequently useful.
03:29:56 <phaazon> Fuco: that reminds me that any value can be rewritten as a function :)
03:29:59 <jophish> I think default has it's uses (for people who like overloaded names) but using it for strings or floats is gross
03:30:08 <jophish> its*
03:30:19 <Taneb> Oh, huh, the Monad instance for ((,) a) is there now
03:30:31 <ReinH> Pointed: Here's an element of your a. Which one? Who cares!
03:30:37 <Fuco> phaazon: well, 1 -> X :D not that interesting
03:30:47 <phaazon> Fuco: yeah
03:30:49 <phaazon> () -> a
03:30:50 <Taneb> Not been released that to the best of my knowledge
03:31:06 <Fuco> but that is also super useful when you do CT
03:31:18 <ReinH> 1 -> X is super interesting.
03:31:28 <quchen> Oh?
03:31:50 <ReinH> X^n is super interesting, but only if it is well behaved for all n.
03:32:07 <quchen> I don't see how 1->X would be interesting.
03:32:09 <ReinH> (in this case we take n \in N)
03:32:26 <jophish> Data.Default seems to stop ReinH getting to sleep
03:32:30 <ReinH> yes
03:32:31 <quchen> ∈ ℕ   ←  Quchen's copypaste service :-)
03:32:33 <ReinH> bad Data.Default
03:32:34 <Fuco> it allows you to treat elements as functors
03:32:37 <ReinH> quchen: :) I was lazy
03:33:47 <quicksilver> I think it would OK to say "this is Data.Pointed, and the laws say that if the type is *also* Semigroup, then it must act as an identity"
03:33:51 <quicksilver> and then it would denote something.
03:34:05 <quicksilver> but, I don't see any advantage to that over having Semigroup > Monoid
03:34:12 <ReinH> Algebraically, we have X^n = X -> X -> X ... -> X, n times. This is more useful when it works for n = 1 too.
03:34:34 <ReinH> Er, I got that wrong.
03:34:42 <ReinH> X^n = (X,X,X,...,X)
03:34:47 <quchen> That's a pretty high power you've got on the RHS there :-þ
03:34:49 <ReinH> I guess I should sleep.
03:35:06 <quchen> CA time?
03:35:11 <quchen> What's that, 3 am?
03:35:31 <ReinH> So we have X^0 = (), X^1 = X, X^2 = (X,X), and so on. This ties back into representables, ofc.
03:36:07 <quchen> Hm. I guess the next question is why representables are interesting then.
03:36:29 <ReinH> quchen: Well, it's interesting because we want exponentiation to be coherent.
03:36:40 <ReinH> which we would expect if Hask is a CCC
03:37:20 <quchen> Sounds like not having it violates lots of properties.
03:37:28 <ReinH> quchen: that's why it's interesting :)
03:37:57 <pranz> the X^0 = 1 trips me up
03:38:00 <ReinH> quchen: it means that products are coherent, basically.
03:38:13 <pranz> you can construct more than one function from Void to say, Int that typechecks
03:38:22 <quchen> Hm. I'm not intrigued. Sounds desirable, but not really interesting, to me. But maybe if I went back to category land that would change.
03:38:33 <ReinH> quchen: well, interesting is pretty subjective.
03:38:48 <Taneb> pranz: they all behave the same on all inputs
03:39:15 <ReinH> pranz: you can construct as many functions as you want as long as they are the one funtion you can construct.
03:39:40 <Taneb> That is, if you give me two functions :: Void -> Int, and you also give me a Void, we're living in a world of fantasy where we can say whatever we want and have it be true
03:39:58 <ReinH> (something something extensional equality something something leibnitz)
03:40:09 <pranz> Taneb: I guess that makes sense
03:40:25 <ReinH> pranz: how many ways can I select zero X's?
03:40:39 <ReinH> There is only one empty set.
03:40:44 <quchen> ReinH: That's absurd.
03:40:48 <ReinH> quchen: :p
03:40:49 <jophish> ho ho
03:40:56 <ReinH> quchen: your face is absurd
03:42:02 <quchen> Well that's not very friendly.
03:42:20 <ReinH> quchen: just joking ofc
03:45:13 <ReinH> it's actually difficult to convince someone that x^0 = 1 unless you accept fractional exponents.
03:45:38 <quchen> Is it?
03:46:01 <opqdonut> ReinH: the combinatorial explanation is best
03:46:04 <quchen> If 0 = Void, I don't see how fractional exponents would help. If 0 : Nat, then it's often by definition.
03:46:09 <hpc> i would use distribution over exponentiation
03:46:19 <opqdonut> also, x^(a+b)=x^a*x^b can be used
03:46:21 <opqdonut> so what hpc said
03:46:23 <hpc> x**n * x**m = x ** (n + m)
03:46:36 <hpc> x**0 * x ** n = x ** n
03:46:40 <hpc> x**0 = 1
03:47:33 <hpc> that law is way too handy to leave with an "except at zero" wart, and that ripples to a ton of other properties
03:48:07 <quchen> What law?
03:48:17 <hpc> x**0 * x ** n = x ** n
03:48:21 <hpc> x**n * x**m = x ** (n + m)
03:48:47 <ReinH> Yeah, I didn't actually mean fractional exponents, I meant x^n / x^m = x^(n-m). I should sleep.
03:48:54 <quchen> x^0 = 1 still has an "except at zero" wart
03:49:12 <ReinH> Anyway, in Haskell you want the same equality that hpc mentioned to hold.
03:49:13 <quchen> It's a small wart that rarely matters
03:52:19 <ReinH> ok 'night
03:55:32 <Ab123> Prelude> let x= 1 Prelude> let y= x -: (\_ -> 2)  <interactive>:4:10:     Not in scope: ‘-:’     Perhaps you meant ‘-’ (imported from Prelude)
03:55:50 <Ab123> why m i getting error??
03:56:12 <hpc> what is (-:)?
03:57:04 <Ab123> oh got it
03:57:13 <Ab123> i must have defined x -: f =f x
03:57:34 <Cale> or something like that :)
03:58:40 * hackagebot microlens 0.4.0.1 - A tiny part of the lens library with no dependencies  https://hackage.haskell.org/package/microlens-0.4.0.1 (Artyom)
04:14:30 <pavonia> Is there a recommended way to handle records with identical fields names for some (but not all) constructors? Using different prefixes or is there something else?
04:15:25 <quicksilver> you are in fact allowed to share field names between constructors
04:15:32 <quicksilver> or maybe you know that, but were asking something else?
04:15:55 <pavonia> Oh, no I didn't
04:16:05 <quicksilver> as long as the type matches
04:16:30 <quicksilver> as for `recommended`; I'd recommend using the lens package and Lenses+Prisms to keep yourself sane :)
04:17:40 <merijn> quicksilver: Not sure whether learning lens keeps you sane...
04:17:47 <merijn> It seems to turn people into cackling maniacs...
04:18:22 <Taneb> merijn: oh no, we're all perfectly sane, despite what anyone else says
04:18:44 <pavonia> That works indeed. I thought this would be a feature for future GHC releases
04:19:57 <quicksilver> merijn: learning lens itself is entirely orthogonal to sanity.
04:20:12 <quicksilver> but dealing with fields which exist in some-but-not-all constructors
04:20:30 <quicksilver> is crying out to be abstracted via something like `preview`
04:20:52 <quicksilver> otherwise you end up reinventing a lot of small wheels
04:23:12 <Fuco> pranz: re void function, it is maybe helpful to realize that a function f : A -> B is a relation on AxB... if we have A an empty set then AxB is empty set as well and that means there is only one such function
04:25:07 <pranz> Fuco: yeah, I don't have any trouble grasping the more abstracted version of (A -> B) but I got confused specifically when it came to constructing haskell functions
04:25:08 <Fuco> (is empty, not empty set..., a unique element)
04:25:26 <pranz> Fuco: but Taneb provided a good explanation for me
04:43:41 * hackagebot rest-client 0.5.1.0 - Utility library for use in generated API client libraries.  https://hackage.haskell.org/package/rest-client-0.5.1.0 (AdamBergmark)
04:46:12 <Fuco> o
04:48:23 <RedNifre> heya. Silly question: How do you describe the right side of [1..] ?
04:48:39 <Fuco> closing bracket
04:49:10 <RedNifre> I mean it would be wrong to call it a range from one to infinity (inclusive) since the list doesn't include infinity. It's also not a list from one to the largest number since there isn't a largest number...
04:49:19 <RedNifre> I meant what's between .. and ]
04:49:26 <Fuco> aha, I thought you are asking about the symbols :D
04:49:34 <merijn> RedNifre: eh, nothing? :p
04:49:34 <Fuco> sometmies people don't know how to call those :P
04:49:40 <RedNifre> :)
04:49:47 <RedNifre> Maybe "range from one to arbitrary large number"?
04:50:11 <merijn> RedNifre: It desugars to "enumFrom"
04:50:14 <merijn> :t enumFrom
04:50:16 <lambdabot> Enum a => a -> [a]
04:50:23 <Fuco> calling it a range from one to infinity is 'normal' in maths
04:50:51 <Fuco> but of course you can't have it inclusive in real numbers
04:50:57 <Fuco> it's always right-open
04:50:59 <RedNifre> but it produces a list that doesn't include infinity? Some languages have ... to mean "range up to excluding", which would sound slightly better to me.
04:51:15 <Fuco> right-open set from zero to infinity
04:51:18 <Fuco> or one
04:51:46 <Fuco> open set is such that it excludes the boundary
04:51:54 <RedNifre> ah, makes sense.
04:51:59 <Fuco> and you can have left/right open intervals (in 1D case)
04:52:23 <RedNifre> can you have a left open range in haskell? I would have thought it doesn't work since the linked lists start on the left?
04:52:23 <Fuco> in 2D case you can't have left/right as that makes little sense... you can have e.g. "inside of a circle except the circumference"
04:52:51 <Fuco> well, Real is approximation of that
04:53:04 <Fuco> you can go from -infinity to +infinity excluding those boundaries
04:53:20 <Fuco> or even [-5..] is an open set from 6 to whatever in natural numbers :P
04:53:31 <Fuco> from -6
04:53:44 <RedNifre> huh?
04:53:46 <Fuco> in haskell I don't know if there is a syntax for that, like [..1]
04:54:08 <lyxia> undefined
04:54:25 <RedNifre> well, I can't do negatives = [..0] :: [Real]
04:54:50 <aweinstock> > [-5.0, -4.9 ..]
04:54:51 <RedNifre> ah, you meant [-5..] as natural numbers.
04:54:52 <lambdabot>  [-5.0,-4.9,-4.800000000000001,-4.700000000000001,-4.600000000000001,-4.50000...
04:54:54 <Fuco> because those aren't enumerable, sure... but suppose you define negative naturals
04:55:04 <merijn> The Enum instance for Float/Double is awful and vile
04:55:06 <Fuco> i.e. whole numbers
04:55:33 <aweinstock> Fuco: data Nat = Z | S Nat | Negate Nat -- ?
04:55:38 <Fuco> but you can't really print a set [..1] because where would you start :P
04:55:48 <Fuco> so indeedin some sense it makes no sense as haskell list
04:56:04 <RedNifre> well, you could print it in theory if you did takeLast 10 negs
04:56:16 <Fuco> that would never terminate
04:56:18 <aweinstock> > [0, -1, ..]
04:56:19 <RedNifre> I thought it didn't work because those lists are linked from left to right.
04:56:19 <lambdabot>  <hint>:1:9: parse error on input ‘..’
04:56:23 <silver> there're some libs doing this stuff
04:56:23 <aweinstock> > [0, -1 ..]
04:56:27 <lambdabot>  [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-2...
04:56:32 <silver> left-infinite lists
04:56:48 <aweinstock> RedNifre: reverse . reverse /= id -- for infinite lists
04:56:52 <aweinstock> @src []
04:56:53 <lambdabot> data [] a = [] | a : [a]
04:56:56 <RedNifre> no, left infinite natural numbers. The list is right infinite :)
04:57:07 <RedNifre> > reverse [0, -1 ..]
04:57:13 <lambdabot>  mueval-core: Time limit exceeded
04:57:20 <aweinstock> @src reverse
04:57:20 <lambdabot> reverse = foldl (flip (:)) []
04:57:26 <aweinstock> @src foldl
04:57:26 <lambdabot> foldl f z []     = z
04:57:27 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:57:28 <silver> https://hackage.haskell.org/package/fmlist-0.9/docs/Data-FMList.html
04:57:56 <Fuco> I feel this will quickly get out of hands :D
04:58:04 <Fuco> anyway gtg, meeting :/
04:58:11 <RedNifre> hf ;)
04:58:26 <aweinstock> foldl doesn't terminate until recursion reaches an empty list, which it never will for infinite lists
04:58:56 <RedNifre> thanks for the link, silver. It it possible to have [..0] produce those lists or is "[x..y]" a special syntax that can't be modified?
04:59:26 <aweinstock> I seem to remember reading a paper about foldMap being a primitive that can express both left and right infinite lists
04:59:31 <silver> maybe with template haskell :P
04:59:44 <aweinstock> [x..y] means (enumFromTo x y)
04:59:51 <aweinstock> > enumFromTo 1 5
04:59:53 <lambdabot>  [1,2,3,4,5]
05:00:33 <Xandaros> [..0] is not a thing
05:00:35 <RedNifre> yeah, but [..y] has no meaning and I was asking if it was possible to have it produce those left infinite FMLists from silver's link.
05:00:38 <aweinstock> ah
05:01:03 <quicksilver> it would be weird for [..y] to produce something not of type [a] in my opinion
05:01:18 <RedNifre> fair point.
05:01:22 <aweinstock> where's the link for FMLists?
05:01:31 <quicksilver> 12:57 < silver> https://hackage.haskell.org/package/fmlist-0.9/docs/Data-FMList.html
05:01:31 <RedNifre> https://hackage.haskell.org/package/fmlist-0.9/docs/Data-FMList.html
05:02:01 <theorbtwo> Yeah, things like this make me wonder if solving *some* of the halting problem is a reasonable thing to want.
05:02:39 <theorbtwo> (So that errors like reverse [0..] give useful messages, rather then eating cpu forever.)
05:02:41 <merijn> theorbtwo: The more sane approach is to throw Turing completeness out and see if you can accomplish your goal without it
05:03:19 <Xandaros> I kinda like Idris' approach to totality. The only issue I have is that it gets very verbose sometimes
05:03:22 <merijn> theorbtwo: Which is certainly a reasonable thing to try since Coq and Agda default to not being Turing complete and I believe Idris has a termination checker too
05:03:27 * RedNifre wonders if "zip" should be renamed to "velcro" since that's not how zippers work.
05:03:42 * hackagebot microlens 0.3.5.1 - A tiny part of the lens library with no dependencies  https://hackage.haskell.org/package/microlens-0.3.5.1 (Artyom)
05:03:46 <mauke> > reverse [0 ..] :: [Int8]
05:03:46 <aweinstock> :t zipWith7
05:03:48 <lambdabot>  [127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,109...
05:03:48 <lambdabot> (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
05:05:29 <RedNifre> The person who came up with zipWith7 must have funny clothes.
05:07:54 <Cale> zipWith3 is already extraordinarily rare
05:08:20 <RedNifre> True, I never ever saw anybody wearing something with a zipper3.
05:08:41 <merijn> zipWith above 2 usually just has me using ZipList :)
05:09:25 <Cale> Well, and then, how often do you even use ZipList?
05:09:51 <merijn> > getZipList $ (,,,) <$> ZipList [1,2,3] <*> ZipList [4,5,6] <*> ZipList [7,8,9] <*> ZipList [10,11,12]
05:09:53 <lambdabot>  [(1,4,7,10),(2,5,8,11),(3,6,9,12)]
05:09:55 <merijn> Cale: Rarely :p
05:10:31 <RedNifre> After monads, the next big thing people scare newbies with seems to be "lenses". I accidentally had a quick look at those, are they just things to read or "modify" deeply nested structures easily? You know, like OOP? I heard they are a bit controversial, how would you handle complex structures without them though?
05:11:17 <merijn> RedNifre: I wouldn't call them controversial
05:11:50 <merijn> RedNifre: They start out as, essentially, accessors for deeply nested things. But it turns out you can generalise and abstract them a lot to become something that's...a bit hard to explain :p
05:12:23 <quicksilver> I think they are much less scary than monads
05:12:30 <quicksilver> or at least scary in entirely different ways
05:12:37 <Nadrieril> ^
05:12:44 <quicksilver> monads are unfamiliar and it's not clear what they are for (to a newcomer)
05:12:45 <liste> maybe lenses have that reputation because some abuse the lens library?
05:12:55 <quicksilver> lenses have a very easy to explain and understand use case
05:13:00 <M2tias> I don't know anything about haskell yet and I'm sure I like to learn about lenses much more than about monads
05:13:08 <merijn> RedNifre: edwardk has a nice talk on the design of Lens and Traversals, but I'm not sure whether it's a good beginner intro
05:13:20 <quicksilver> the worst things about them are the type errors, the hundreds of function names and operator names to learn, and the types
05:14:03 <merijn> lenses are conceptually elegant and very functional (in both the theoretic and the "they work" sense), but the type errors are jargon are a bit tricky, yeah :)
05:14:12 <quicksilver> it's obvious what they are for - but it's not obvious why they have the strange types they have
05:17:07 <RedNifre> Well, in Clojure you have `update-in` which works like (def isThisALense (update-in [2 :firstName] reverse)) and then (isThisALense listOfPersons). Is isThisALense a lense?
05:17:35 <quicksilver> can you use it to 'fetch' as well as update?
05:17:38 <quicksilver> and is it composable?
05:17:45 <quicksilver> I suspect the answers are no, no and therefore no.
05:18:29 <quicksilver> lenses are composable combined setter-getters.
05:18:41 <RedNifre> Well, there is one for fetch, or you could just turn it into fetch. Not sure if it's composable.
05:18:42 * hackagebot pontarius-xmpp 0.5.1 - An XMPP client library  https://hackage.haskell.org/package/pontarius-xmpp-0.5.1 (PhilippBalzarek)
05:19:26 <RedNifre> How can it be a combined getter-setter? I would have expected that a getter returns only the deeply nested value while a setter returns the whole structure with the deeply nested valua changed? Don't they have different types?
05:19:42 <mauke> see, this is where the crazy begins
05:20:04 <liste> RedNifre some lens libraries define lens as something isomorphic to (a -> b, b -> a -> a)
05:20:05 <merijn> RedNifre: You basically have "get :: Lens a b -> a -> b" and "set :: Lens a b -> a -> b -> a"
05:20:09 <RedNifre> Sounds like it. Oh well, guess I'll have to read about it after all ;)
05:20:15 <merijn> @where lens
05:20:16 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
05:20:24 <quicksilver> RedNifre: http://www.twanvl.nl/blog/haskell/overloading-functional-references
05:20:26 <merijn> RedNifre: That youtube talk is pretty good, although long :)
05:20:33 <quicksilver> RedNifre: is an early post which gives plenty of motivatio
05:20:43 <quicksilver> but doesn't resemble the implementatio in the lens library
05:21:00 <roelof> some one seen julian leviston today  ? 
05:21:16 <RedNifre> thanks, I'll have a look at it.
05:23:59 <RedNifre> Another thing, I haven't looked at exceptions yet (except for rewriting my code to not produce any). Why are they a thing in Haskell? I mean, in other languages their point is to move the error handling away from the relevant code (So that instead of writing nested if(everythingIsFine) { doNextStuff() } all the time you first write the ideal execution and append the error handling). Given that Haskell has do-notation which also allows wri
05:24:05 <RedNifre> ting down the ideal path, why are exceptions needed?
05:24:08 <Nadrieril> very nice introduction quicksilver :)
05:24:42 <merijn> RedNifre: Because sometimes you don't want to clutter all your code with dealing with conditions you don't plan to handle
05:24:49 <mauke> RedNifre: we have asynchronous exceptions
05:24:50 <EvanR> RedNifre: exceptions greatly simplify the interface to IO stuff
05:24:58 <merijn> RedNifre: My personal belief is: Maybe/Either/etc. for libraries/APIs
05:24:59 <mauke> merijn: do-notation already handles that
05:25:19 <RedNifre> merijn right, but doesn't do-notation unclutter your code the same way that exception do? what's an asynchronous exception?
05:25:19 <merijn> RedNifre: exceptions for internal to your API/application only
05:25:42 <quicksilver> people mean slightly different things by 'exceptions'
05:25:43 <Nadrieril> it would be annoying to have (/) :: Num a => a -> a -> Maybe a
05:25:53 <EvanR> async exceptions is an orthogonal topic
05:25:59 <merijn> RedNifre: In my server loop I often find it easier to just throw an exception on a disconnect/premature condition and then letting it kill the thread while handling cleanup
05:25:59 <quicksilver> some people would say that using do-notation to handle exceptional cases like that counts as using exceptions.
05:26:18 <quicksilver> i.e. 'Either' and similar approaches are a kind of exception handling
05:26:44 <merijn> mauke: Not really. If you expect to recieve some Foo and you don't and the rest of your code uses that Foo, do notation can't often help...
05:26:53 <quicksilver> certainly they handle exceptional cases and have primitives like 'catchError' which is a suggestive name.
05:27:06 <merijn> mauke: I could lift my entire application into EitherT/ExceptT, but that's just unnecessary clutter if I don't plan to ever "handle" the error
05:27:16 <merijn> mauke: Easier to just throw and kill the loop for that client
05:27:24 <quicksilver> "IO exceptions" are something specific and so are "Asynchronous Exceptions" though.
05:27:27 <EvanR> RedNifre: anyway without some kind of exceptions you would be dealing with errors like in C, which sucks
05:27:34 <RedNifre> Nadrieril oh, right, I guess it's not possible to use do-notation to write `result <- x + (<- y / z)`, huh?
05:27:51 <Nadrieril> nope
05:28:05 <merijn> I dislike the fact that IO exceptions are unchecked, hence why I'm still working on my prototype System F_omega with checked exceptions
05:28:12 <quicksilver> RedNifre: that would be result <- (x+) <$> (y/z)
05:28:24 <Nadrieril> pwnd
05:28:33 <quicksilver> assuming you worked in a parallel universe where (/) was in a monad and raised exceptions.
05:28:46 <RedNifre> (Though I guess calculate x y z = x + (<- y / z) would make more sense)
05:28:48 <quicksilver> clearly you can redefine (/) to create that universe if you wish :)
05:29:27 <roelof> How can I check if a user is present or when he/she was the last present ? 
05:29:44 <quicksilver> search the online logs I think roelof 
05:29:44 <Nadrieril> roelof: in IRC ?
05:29:48 <RedNifre> quicksilver don't you mean "was in a monad and DIDN'T rase exceptions"?
05:29:59 <RedNifre> *raise
05:30:05 <roelof> yep, in this channel  
05:30:15 <EvanR> RedNifre: meaning in this case raise an internal-to-the-monad exception
05:30:23 <Nadrieril> roelof: /whois and /whowas
05:30:34 <EvanR> like Nothing or Left
05:31:08 <quicksilver> as I said the word 'exception' is a bit ambiguous
05:31:18 <RedNifre> What's an "internal to the monad exception"? Is that the regular fail, e.g. Nothing for the Maybe monad?
05:31:22 <quicksilver> but that could have been the IO monad in which IO exceptions are 'internal'
05:31:51 <EvanR> er
05:31:54 <mauke> RedNifre: see also chapter 5 in http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf
05:31:56 <roelof> Nadrieril:  thanks. 
05:32:02 <Nadrieril> np :)
05:32:08 <quicksilver> I think the intended meaning is 'something which doesn't necessarily generate _|_, but can be handled by the facilities of that monad'
05:32:22 <quicksilver> IO exceptions won't generate _|_s for you if you handle them in IO.
05:32:36 <quicksilver> Either/Maybe style exceptions never generate _|_
05:32:58 <quicksilver> unhandled IO exceptions do generate _|_s though, that's the fallback.
05:33:04 <EvanR> quicksilver: are IO exceptions that happen in IO really different from a random undefined encountered while running IO
05:33:18 <quicksilver> unfortunately not
05:33:25 <quicksilver> some people would like them to be different
05:33:30 <merijn> EvanR: If you use throwIO, then yes
05:33:40 <quicksilver> but random undefineds can indeed be caught 
05:33:43 <quicksilver> in IO.
05:33:48 <merijn> EvanR: throwIO ensures sequencing of when they're raised so they can't "leak" due to laziness
05:34:02 <merijn> EvanR: Which is why you should always throwIO and never throw
05:34:09 <EvanR> the top level exceptions / async stuff seems like a genuiunely different thing conceptually than an exception monad
05:34:36 <EvanR> merijn: sure but you will be "an exception" for a variety of reasons not just throwIOs
05:34:41 <quicksilver> there are key conceptual differences, yes.
05:34:42 <EvanR> in IO
05:34:46 <quicksilver> async is a very big difference.
05:35:00 <quicksilver> generated-by-evaluation (error "foo") things are also conceptually different
05:35:09 <quicksilver> but there is a unifying framework
05:35:17 <RedNifre> Well, what I mean is that if (/) were to return a Maybe instead of throwing an exception then `calculate x y z = (x +) <$> (y / z)` would be ugly but `calculate x y z = x + (<- y / z)` would be... hm... still too ugly...
05:35:19 <quicksilver> they can all be caught in a monad using combinators of the same shape.
05:35:41 <quicksilver> RedNifre: yes, that has been pretty well discussed.
05:35:57 <quicksilver> RedNifre: there is indeed an 'ugliness cost' for making the monad explicit.
05:36:15 <quicksilver> rather than having an implicit monad hanging over every single expression evaluation.
05:37:01 <EvanR> RedNifre: for pure code, you can indeed do pretty well without using "real" exceptions, use Maybe or Eithers or something else
05:37:14 <EvanR> exceptions in IO are always lurking and could happen all the time
05:38:23 <EvanR> and using exceptions in IO will let you have that without having error handling all the time
05:38:40 <EvanR> (without transformer stacking)
05:40:05 <unit73e> hey
05:40:15 <RedNifre> hi
05:42:33 <RedNifre> I'm now at the point where I get frustrated when I can't express something in Java's type system that would be trivial in Haskell. Do you people get frustrated when you can't do something in Haskell that would be easy in Idris (or any other "more than Haskell" language)?
05:43:20 <merijn> RedNifre: Idris and things have a far smaller library landscape than haskell
05:43:53 <merijn> RedNifre: I think haskell is currently at a sweetspot of "most of the stuff you want" combined with "most of the libraries you need"
05:43:55 <unit73e> RedNifre: No but I do get frustrated when I can't easily express something in Scala that I can easily in Haskell
05:44:24 <EvanR> RedNifre: welcome to hell
05:44:48 <unit73e> I didn't even know Idris existed
05:44:54 <EvanR> youve tasted nirvana, and will shortly be sent back to the java sweatshop
05:45:14 <merijn> Just write a haskell program that generates Java for you...
05:46:19 <EvanR> not very much thats easy in idris is easy in haskell, and vice versa ;)
05:46:30 <RedNifre> EvanR yeah, though it's still worth it: Playing with Haskell improved my Java more than conventional Java books have (purity, avoiding mutability etc.).
05:46:51 <EvanR> books on OOP are like white noise to me
05:47:12 <unit73e> Well Scala book helped me
05:47:23 <unit73e> The "official" one
05:47:34 <unit73e> and it is OOP, sort off
05:48:20 <RedNifre> merijn oh, I currently agree that it's in the sweet spot, it's just that if all languages are lined up on the "Blub" spectrum it would mean unless you are using the language at the top you'll get frustrated with what's missing in your language eventually (assuming that you try to improve).
05:48:22 <EvanR> RedNifre: i have made a few ADT-like generators for ruby, but not really something you would inflict on fellow ruby programmers
05:49:02 <EvanR> Haskell is the start of climbing out of blub
05:49:18 <RedNifre> I did the opposite, I wrote a ruby script that generated some Haskell code to deal with differently sized tuples because I wasn't in the mood to look at template Haskell yet ;)
05:49:36 <RedNifre> Nah, if it's a spectrum you are continually climbing out of blub.
05:49:53 <EvanR> you really do want a different language for different things, its just that all blubs are more or less the same and that doesnt matter
05:50:08 <EvanR> with haskell youll begin to see how language could be for task X
05:50:26 <EvanR> the DSL pattern
05:50:44 <unit73e> Personally I've found that I program much more efficiently than any other language I've used
05:51:16 <unit73e> But I have to use Java/C++ at my current job
05:51:23 <RedNifre> unit73e in Haskell or Scala?
05:51:32 <RedNifre> or in general?
05:51:45 <unit73e> unit73e: Haskell, I only use Scala when I can't use Haskell lol
05:53:24 <unit73e> Scala type system is clunky imo
05:53:43 * hackagebot sandi 0.3.6 - Data encoding library  https://hackage.haskell.org/package/sandi-0.3.6 (MagnusTherning)
05:54:21 <unit73e> but like they say in my country, when you can't hunt with a dog you hunt with your cat
05:54:37 <EvanR> haha
05:57:18 <mag__> naive question ... Scala excels at?
05:57:37 <RedNifre> unit73e where can you use scala but not haskell? I mean, on Android you can use neither and on the server you can use whatever you want, right?
05:57:45 <mag__> why would I choose Scala over any other language?
05:58:00 <EvanR> RedNifre: "we need to be compatible with java"
05:58:20 <achernyak> mag__, if you have to use the JVM but want to use some of the nice features of a functional language
05:58:28 <EvanR> haskell is probably not the most convenient for that scenario
05:58:43 * hackagebot creatur 5.9.9 - Framework for artificial life experiments.  https://hackage.haskell.org/package/creatur-5.9.9 (AmyDeBuitleir)
05:59:02 <unit73e> RedNifre: when you need to use anything JVM related like use jars or create jars or your company says no haskell :p
05:59:47 <mag__> Scala is good for employees then
05:59:48 <RedNifre> have you tried frege? ;)
05:59:51 <mag__> I see
06:00:22 <unit73e> No but I've heard about it
06:00:25 <liste> I thought frege was very immature?
06:00:27 <unit73e> Maybe I'll try one day
06:00:33 <RedNifre> it probably is
06:01:21 <RedNifre> "Scala is good for employees then" Not sure about that. There was this article where a manager described how they moved away from Scala and replaced it with Go.
06:01:37 <EvanR> the more realistic alternative to scala is clojure which is "mature"
06:01:52 <RedNifre> The argument was that his team was split into two camps: one half used Scala as a "better Java", while the other half "loved applicative functors" and used it as a worse Haskell.
06:02:02 <unit73e> The other day I was thinking about a "new web" and one problem is that it would be a good thing to have bytecode but haskell doesn't use that
06:02:22 <RedNifre> The "better java" part didn't want to understand any functional programming so they switched to Go.
06:02:27 <EvanR> bytecode??
06:02:31 <EvanR> why
06:03:00 <unit73e> yes because you can pass your bytecode to another machine and run magically, seems like a good idea for a "new web"
06:03:04 <unit73e> sort off
06:03:13 <unit73e> but I'm not sure
06:03:22 <EvanR> write once run anywhere 2.0 ?
06:03:28 <unit73e> yeah that kind of thing
06:03:33 <EvanR> if thats the goal, then use javascript
06:03:37 <Heranort> portability
06:03:39 <unit73e> javascript sucks
06:03:48 <EvanR> who cares, its the "bytecode"
06:03:57 <EvanR> you dont program in bytecode
06:04:02 <danilo2> Hello guys! :) Is it sufficient to put INLINE pragma in the type class definition or I have to write it in every single instance? I'm sure that I want all the instances to be inlined by GHC.
06:04:02 <unit73e> I care
06:04:08 <RedNifre> use coffeescript with ramda or purescript or ghcjs then :)
06:04:19 <EvanR> its just an intermediate representation technology
06:04:30 <unit73e> If you put it that way
06:04:33 * hackagebot hakyll 4.7.5.1 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.7.5.1 (JasperVanDerJeugt)
06:04:38 <unit73e> but imo browsers are evil
06:04:40 <RedNifre> also, people are working on web bytecode, it's called webassembly.
06:04:54 <EvanR> yes you can reinvent the whole browser / web thing
06:04:58 <EvanR> like this guy
06:05:00 <mag__> hahah
06:05:06 <EvanR> http://www.impredicative.com/ur/
06:05:20 <unit73e> yeah that's the idea
06:05:36 <merijn> I still need to learn Ur
06:05:40 <unit73e> I see someone thought of it already
06:05:47 <merijn> Too bad it copied ocaml's ungodly syntax
06:06:08 <merijn> EvanR: To be fair, he didn't reinvent the browser, just the entire backend :p
06:06:19 <unit73e> imo html/js/css are just crappy for web applications
06:06:28 <EvanR> if were going to reinvent the web, why not rethink the entire point of it all
06:06:38 <EvanR> why is the next thing even identifable as "web"
06:06:40 <RedNifre> Urbit?
06:06:57 <unit73e> That's the point. why not something like android? its almost the same thing as the web
06:06:58 <merijn> unit73e: Ur is pretty cool, it borrows heavily from ocaml/haskell + extensions, and uses a lot of fancy DSL stuff internally
06:06:59 <EvanR> "web" done right, thats gotta be the wrong thing
06:07:11 <merijn> RedNifre: Never heard of that?
06:07:39 <RedNifre> merijn it's computing rewritten from the ground up, but it'll make your brain commit suicide when you read about it.
06:07:40 <unit73e> except android (google play) it doesn't download on demand or have a good search engine
06:07:53 <merijn> unit73e: It has a DSL for JS, XML and database transactions, so that it can statically check that you're writing sane/typed JS and valid html documents :)
06:07:58 <RedNifre> it's kinda like web done right. or computing done right. or insanity, not sure.
06:08:07 <unit73e> merijn: sounds good to me
06:08:10 <merijn> RedNifre: Oh, actually I have read about that
06:08:17 <merijn> RedNifre: But not what we were talking about :)
06:08:28 <RedNifre> ...though they made operators pronouncable by giving every ascii scribble a one syllable name.
06:08:33 <unit73e> Anyway haskell needs a decent graphical toolkit first
06:08:37 <merijn> unit73e: You know and things like static validation against SQL injection/XSS :)
06:08:42 <unit73e> what we have is not good enough
06:08:57 <RedNifre> e.g. "<" is "gal" as in "left angle bracket", "=" is "tis" as in "it is", so >>= is "gargartis" ;)
06:09:07 <EvanR> the web was and is "computing / UI / etc" all ignoring preexisting technology and reinventing it. how about we reinvent it to use preexisting nice stuff, which is easy now because the web already exists ;)
06:09:35 <merijn> EvanR: I've always claimed that "webapps" is "X11 reinvented poorly with links"
06:09:46 <unit73e> I agree
06:09:55 <merijn> EvanR: Not that X11 was amazing, but at least it had a consistent and semi-sane spec with multiple implementations
06:10:02 <EvanR> yeah
06:10:28 <merijn> "I can update the application on the server and all clients are upgraded too!", 'oh...like X11?'
06:10:34 <Xandaros> Well, web has a few benefits. I don't really like how everything is web-based now, though. Mainly because I don't like developing for it
06:10:43 <merijn> Xandaros: Name one :p
06:10:55 <EvanR> X's graphical network transparency isn't that great though
06:10:57 <Xandaros> Easy access from consumers
06:11:11 <unit73e> I have antoher, download only what you need on demand
06:11:29 <merijn> Xandaros: That's a historical accident, any other technology could've been made/replaced the browser and achieve the same
06:11:37 <unit73e> and many decent search engines
06:11:40 <EvanR> the benefit is that it has been installed on consumers
06:11:48 <unit73e> That too
06:11:51 <Xandaros> merijn: Yes. A benefit nonetheless
06:12:13 <unit73e> I still get what merijn is saying and I agree
06:12:21 <Xandaros> And I suspect it's the main reason people do web now. Same with developing for windows
06:12:40 <unit73e> windows is a toy OS
06:12:42 <RedNifre> I find it interesting how regular people don't use bookmarks: Instead they use google like a shell, "starting" their facebook "program" by typing it in instead of clicking on an icon (like stereotypical casual users would).
06:13:09 <EvanR> because typing is faster than finding the icon to click on
06:13:17 <mag__> indeed
06:13:27 <EvanR> and regular uses unknowingly realized it
06:13:31 <unit73e> If I owned a company nobody would be allowed to use windows
06:13:41 <unit73e> OS nazi
06:13:44 <RedNifre> Right, but that argument is usually given by people who use a shell on linux and the backlash is usually "that's too technical, we need icons."
06:14:22 <EvanR> RedNifre: the art of persuasion may demand that you simply dont say anything if they are already doing it right and dont realize why
06:15:00 <unit73e> My argument is that those who use windows end up not really knowing how to be efficient
06:15:15 <unit73e> You can tell who uses linux or not
06:15:16 <mag__> unit73e, not entirely true
06:15:23 <RedNifre> Though it is a bit concerning that google owns the shell you use for your internet OS.
06:15:36 <EvanR> heh
06:15:42 <merijn> unit73e: Holding up linux is the pinnacle of design and efficiency is pretty sad...
06:15:57 <EvanR> when you start typing in that little bar in chrome, you can notice a ton of ancillary http requests happening invisibly
06:16:19 <EvanR> it will do GETs on all the suggested sites
06:16:29 <unit73e> Linux may not be but it pisses me off when someone asks where's the graphical tool for X
06:16:30 <EvanR> which can mess up testing
06:16:54 <EvanR> and analytics
06:17:34 <unit73e> Also I'm probably frustrated I have to use Windows at work :p
06:17:41 <unit73e> So yeah I'm biased
06:17:44 <RedNifre> Hey, does anybody here use Haskell in the office? Could you get every new hire to learn Haskell enough to be productive or did you have to let people go that would have been productive in, say, Java but couldn't grok Haskell at all?
06:18:27 <unit73e> I imagine it would be really hard to teach a Java guy Haskell
06:18:34 <mag__> unit73e, "My argument is that those who use windows end up not really knowing how to be efficient " .... "Also I'm probably frustrated I have to use Windows at work"
06:18:49 <RedNifre> (This might be a slightly inflamatory question, I think the politically correct answer would be that programming isn't a talent you are born with so everyone can learn every language.)
06:18:58 <Ankhers> RedNifre: I don't use Haskell in the office right now, but on a similar note. My last job was using golang, someone had to be let go because he didn't want to learn the language.
06:19:32 <unit73e> mag__: yeah I think many times how I could be more efficient if I was using Linux instead of the toy OS that is windows
06:19:34 <liste> I don't think it'd be any harder to teach a Java guy Haskell than a PHP/Python/C# guy
06:19:44 <RedNifre> Ankhers that's surprising, given that the whole point of golang is that it's easy to pick up and that beginner programmers can be productive with it quicklyi.
06:20:06 <unit73e> We have many Java => C# and we don't teach, you just do it
06:20:09 <Ankhers> RedNifre: He wasn't a beginner. He is a C# guy. I think he wanted to stay a C# guy.
06:20:22 <RedNifre> Ankhers did he resist because it was too primitive for his taste or because he didn't want to learn a new language?
06:20:37 <unit73e> Java => Python I learned in a few days
06:20:49 <merijn> The hard part about programming is the programming, not the language
06:20:54 <unit73e> true
06:20:59 <Ankhers> RedNifre: I'm not entirely sure. He seemed to push back on the technology for whatever reason. Just kept stating that C# could do what Go does.
06:21:18 <RedNifre> Well, if you are used to C#'s generics, not having them in golang can be frustrating I guess.
06:21:25 <Ankhers> And the product at the time was C#, so why not stay with C#?
06:21:57 <merijn> Although it's hard to learn "programming" properly without branching out beyond one or so language
06:22:06 <EvanR> C# is the future. 2016 is the year of C#
06:22:07 <unit73e> You just need decent tutorials for a language. I'm not sure haskell is there yet.
06:22:18 <Ankhers> Either way, I tried to convince them to use Haskell. My prototype was ~6x faster than the Go prototype. My CTO went with Go because it was "easier to understand".
06:22:26 <EvanR> unit73e: eh?
06:22:41 <EvanR> i learned from haskell tutorials in 2008
06:22:51 <EvanR> they were there yet
06:22:56 <unit73e> EvanR: so did I but there are us and those
06:23:07 <unit73e> and many those don't care
06:23:11 <liste> I think Haskell takes more time for new guys to be productive in, and it's up to management if it's OK or not
06:23:13 <EvanR> huh
06:23:38 <unit73e> some people need "Haskell for dummies"
06:23:44 <aweinstock> Ankhers: 6x faster at runtime, or written in 1/6th of the time it took to write the Go version?
06:23:45 <RedNifre> unit73e see, that's basically my question, is there "us and those" or is it just "us", meaning that everyone can learn haskell.
06:23:46 <EvanR> thats what i used
06:24:11 <Ankhers> aweinstock: runtime. We were both completing features in roughly the same time.
06:24:32 <merijn> RedNifre: I tend to alternate between those two opinions
06:24:36 <aweinstock> RedNifre: I think unit73e meant that the distinction isn't a matter of ability, but of caring
06:24:46 <EvanR> it seems odd that a programmer would suggest that theres a class of programmers who are unable to learn programming ;)
06:24:49 <unit73e>  pretty much
06:25:16 <selckin> because there are people with 10 years experience who can't configure their IDe
06:25:18 <Fuco> EvanR: why, pretty much in any profession there are people who like to think they are better than the rest
06:25:19 <selckin> and i have to do it for them
06:25:22 <Fuco> programmers are no exception 
06:25:29 <merijn> RedNifre: I'm not 100% convinced "everyone" can learn to program, but then I think a lot of the people currently held up as good programmers aren't either. The same time I've had friends with no exact science background or computers who seem to grasp things just fine
06:25:39 <EvanR> Fuco: well "odd" was my way of being polite
06:25:49 <merijn> RedNifre: In other words, IF there is a group that can't learn to program, we're selecting for it pretty poorly
06:25:55 <aweinstock> Ankhers: do you know if the C# guy who didn't want to learn Go would've been ok with learning Haskell?
06:26:04 <unit73e> It took me a lot of time to convince some people that formatting code = good for VCS, let alone learn another language
06:26:05 <merijn> Because I see a lot of people coming into CS who don't do well and a lot of people avoiding it who would
06:26:15 <Ankhers> aweinstock: I don't have the slightest.
06:26:33 <Ankhers> aweinstock: Would have been interesting to ask.
06:26:34 <merijn> EvanR: I'm not a programmer, I'm a mad scientist!
06:26:55 <EvanR> man science has very little to do with madness?
06:27:03 <unit73e> aren't we all scientists?
06:27:14 <quicksilver> on the topic of people who can't learn to program
06:27:15 <unit73e> computer science anyone?
06:27:18 <quicksilver> http://retractionwatch.com/2014/07/18/the-camel-doesnt-have-two-humps-programming-aptitude-test-canned-for-overzealous-conclusion/
06:27:24 <liste> is CS even science?
06:27:27 <quicksilver> but, this is offtopic (but interesting)
06:27:28 <unit73e> yes
06:27:33 <EvanR> an undergrad in CS doesn't make you a computer scientist
06:27:33 <RedNifre> Well, if every programmer can learn every programming language, shouldn't all companies slowly drift towards higher languages like Haskell?
06:27:35 <Ankhers> liste: It has the word science in it. It has to?
06:27:35 <unit73e> If you learned it the right way
06:27:45 <merijn> liste: Yes, there was a nice argument made for that on the XKCD forum, but I've never been able to find it again
06:27:50 <Fuco> I don't think it's science
06:28:02 <Fuco> you're not testing anything, everything you conclude is true by definition :D
06:28:13 <Fuco> same way math isn't science
06:28:27 <RedNifre> well, the "make it easier to handle for humans" is sort of psychology, which is a science.
06:28:31 <aweinstock> "Theoretical Computer Science" is a branch of mathemeatics?
06:28:45 <EvanR> programming job market is very little science, engineering, or math
06:28:46 <Fuco> aweinstock: in my book certainly
06:28:47 <dsop> I am writing a protobuf/thrift service nad have to do a lot of conversations between Int and Data.Int.Int32 as well as Data.Map to Data.HashMap.Strict. Is there a good overview of how expensive that is in general.
06:28:55 <EvanR> its like a trade skill at this point
06:29:03 <dsop> Data.Map to Data.HashMap.Strict should be O(n) but not sure how expensive overall int conversations are
06:29:08 <dsop> if they are optimized correctly by ghc
06:29:14 <RedNifre> Ah, gotta go. Bye.
06:29:27 <quicksilver> dsop: I don't think there is a good overview for that quesiton, no.
06:29:36 <unit73e> At this point you're just selling but if you're testing and creating something new than can be reused, that's science
06:29:44 <aweinstock> dsop: on a 32-bit architecture, Int and Int32 should be exactly the same (and the conversion should be a no-op)
06:29:45 <unit73e> I think :p
06:30:02 <merijn> aweinstock: On 64bit they will almost certainly be the same too :p
06:30:04 <unit73e> at least engineering
06:30:05 <dsop> aweinstock: yeah was hoping that. HashMAp conversion is a bit sad, but i guess I have to deal with it :/
06:30:32 <merijn> aweinstock: Note that even Word8 is implemented using Word# internally :)
06:30:34 <aweinstock> merijn: is sign-extension free, or just really really cheap? (1 assembly instruction)
06:30:36 <quicksilver> in some sense the same, as in, both represented by one machine word
06:30:53 <quicksilver> but the conversion isn't free, and won't use mutation
06:31:11 <merijn> aweinstock: Neither, the underlying interpretation of Int32 is just represented using machine words :)
06:31:14 <quicksilver> so more like 20 cycles than 2 cycles, for sure.
06:31:45 <quicksilver> I think the real question is how well multiple conversions get aggregated and how efficiently your memory bandwidth is used
06:31:53 <quicksilver> but that's a pretty subtle question. Do some tests and find out :)
06:33:14 <dsop> true true, i gotta do it
06:34:12 <danilo2>  Hello guys! :) Is it sufficient to put INLINE pragma in the type class definition or I have to write it in every single instance? I'm sure that I want all the instances to be inlined by GHC.
06:35:15 <unit73e> shows over, time for real questions :p
06:37:24 <merijn> hmmm, is there a monadic iterate somewhere?
06:37:58 <Gurkenglas> merijn, https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:iterateM_
06:38:01 <liste> @hackage monad-loops -- merijn iterateM_ ther e ?
06:38:01 <lambdabot> http://hackage.haskell.org/package/monad-loops -- merijn iterateM_ ther e ?
06:38:36 <merijn> hmmm, that repeats forever. I need finite repetition, but maybe monad-loops has that
06:39:56 <pikajude> replicateM n e?
06:40:11 <EvanR> iterateM_
06:40:22 <EvanR> Monad m => (a -> m a) -> a -> m b
06:41:06 <merijn> pikajude: replicateM does something very different :)
06:41:12 <pikajude> whoops
06:41:42 <quicksilver> danilo2: I suspect you need it on every instance but I'm no expert. On the other hand I suspect you dont' actually need it at all, ever - the inliner is aggressive and it loves to inline methods.
06:42:11 <merijn> Actually
06:42:22 <merijn> Maybe I just want replicateM in StateT IO
06:43:14 <quicksilver> replicateM in StateT is called mapAccum without StateT
06:43:31 <quicksilver> although I'm not sure if it's L or R
06:44:11 <merijn> quicksilver: no, mapAccumL doesn't let you do IO...
06:44:17 <EvanR> Propositional equality. If a :~: b is inhabited by some terminating value ... interesting language of "terminating values" and "nonterminating values" ;)
06:44:19 <quicksilver> :t mapAccumL
06:44:21 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
06:44:30 <quicksilver> oh hmm
06:44:34 * hackagebot java-poker 0.1.1.0 - The etude of the Haskell programming  https://hackage.haskell.org/package/java-poker-0.1.1.0 (tobynet)
06:44:45 <quicksilver> isn't there a version which does?
06:45:22 <merijn> Odd that there's no "modifyM :: Monad m => (s -> s m) -> StateT s m ()"
06:45:46 <quicksilver> it is isn't it?
06:45:57 <quicksilver> I think it exists in one of the generalised monad libraries
06:45:58 <merijn> I keep wanting that all the time...
06:46:10 <Xandaros>  `s m`?
06:46:27 <merijn> eh
06:46:28 <merijn> m s
06:46:31 <merijn> obviously :)
06:46:38 <Xandaros> Ok, good. Thought I was stupid for a second :D
06:47:09 <Xandaros> But yes, that is odd.
06:47:37 <quicksilver> I think you can build it with the combinators from mmorph
06:47:38 <quicksilver> https://hackage.haskell.org/package/mmorph-1.0.4/docs/Control-Monad-Morph.html
06:47:46 <quicksilver> in quite a general way
06:47:48 <merijn> quicksilver: Why would you need that?
06:47:58 <merijn> "modifyM f = get >>= f >=> put"
06:48:25 <mniip> :t \f -> get >>= f >=> put
06:48:26 <lambdabot>     Precedence parsing error
06:48:27 <lambdabot>         cannot mix ‘>>=’ [infixl 1] and ‘>=>’ [infixr 1] in the same infix expression
06:49:12 <merijn> :t \f f >=> put =<< get --whoo confusion, but no parentheses!
06:49:13 <lambdabot> parse error on input ‘>=>’
06:49:17 <merijn> :t \f -> f >=> put =<< get --whoo confusion, but no parentheses!
06:49:18 <lambdabot>     Couldn't match type ‘()’ with ‘m c’
06:49:18 <lambdabot>     Expected type: b -> m c
06:49:18 <lambdabot>       Actual type: b -> ()
06:49:31 <merijn> hmmm
06:49:51 <merijn> ok, maybe not
06:50:22 <merijn> :t \f -> get >>= (f >=> put)
06:50:24 <lambdabot> MonadState s m => (s -> m s) -> m ()
06:50:25 <quicksilver> last time this was mentioned it was suggested to call it modifyT
06:50:50 <kaiyin> I have this dependency problem: https://gist.github.com/kindlychung/87b328fda72fe0b3c002
06:50:58 <quicksilver> I think you're missing some lifts, merijn
06:50:58 <kaiyin> Could anyone help?
06:51:17 <merijn> quicksilver: No, because I don't bother with mtl
06:51:31 <merijn> quicksilver: oh, wait...
06:51:32 <merijn> hmmm
06:51:35 <quicksilver> you don't bother with mtl but you have StateT?
06:51:45 <merijn> quicksilver: StateT is transformers
06:51:57 <quicksilver> still your type wasn't what you asked for.
06:52:10 <merijn> :t \f -> get >>= (lift . f >=> put)
06:52:12 <lambdabot> (Monad m, MonadTrans t, MonadState s (t m)) => (s -> m s) -> t m ()
06:52:27 <merijn> It typechecked because lambdabot has the wrong get/put
06:52:34 <liste> kaiyin have you installed anything without stack?
06:52:34 <quicksilver> or StateT . f
06:52:41 <quicksilver> if you want to be quite monomorphic about your lift.
06:53:27 <Gurkenglas> http://ircbrowse.net/browse/haskell?q=modifyT :D
06:53:27 <kaiyin> liste: I installed stack itself with homebrew, didn't install anything with cabal or anything. 
06:53:35 <Gurkenglas> Also getsT
06:53:42 <quicksilver> yes
06:53:49 <quicksilver> I was just about to link the conversation Gurkenglas 
06:53:53 <kaiyin> liste: i also did rm -rf .cabal and .ghc before hand. 
06:54:00 <quicksilver> although I'm amused to see merijn was an active participant in it :)
06:54:09 <quicksilver> http://ircbrowse.net/browse/haskell?events_page=617350 and following
06:54:24 <quicksilver> it was rather a long conversation, took me an extraordinarily long time ot understand what Gurkenglas meant.
06:54:48 <Gurkenglas> I never did get around to that list mail. Damn trivial inconveniences.
06:56:05 <Gurkenglas> We should have a collaborative way to do these. Writing it into the channel doesn't make my brain go ughhhh homework
06:56:30 <danilo2> quicksilver: thanks! Unfortunatelly I want to be sure the methods are inlined, because I'm using type classes very extensively to encode some type-level computations. If something would not be inlined it will habve huge impact on the performance, but I've never seen any Haskell code with inline pragma in the type class declaration. Placing it in every instance is ugly as hell :/
06:56:50 <quicksilver> having actaully understood what Gurkenglas meant, I then saw an application for it in my own code the following week
06:56:54 <quicksilver> which is often how it works.
06:57:12 <rydgel> Is there some Yampa's guru here?
06:57:38 <rydgel> I would like to know the obvious way to launch an IO action from an Event
06:57:53 <rydgel> (basically a sound for my game)
06:57:55 <liste> kaiyin can we see /Users/kaiyin/.stack/global-project/stack.yaml ?
06:58:22 <Gurkenglas> And I repeat that I found that concept in the first place by noticing the inverse relationship between modify and execState/gets and evalState, and QuickSpec really needs to be made able to be automatically applied to a module so we can have all these trivial laws figured out for us.
06:58:48 <Cale> rydgel: I wouldn't call myself a guru, but I've used it, quite a long time ago. The way you'd do that is from outside the arrow computation itself, in the function you'll pass to reactimate
06:59:05 <kaiyin> liste: sure, here it is: https://gist.github.com/kindlychung/87b328fda72fe0b3c002#file-stack-yaml
06:59:15 <unit73e> btw regarding Idris, won't eager evaluation make things less composable?
06:59:55 <unit73e> I'm not sure lazy evaluation is a problem
07:00:04 <Cale> rydgel: i.e. you arrange for part of the result of your SF computation to describe which sound effect(s) to play
07:01:05 <Gurkenglas> merijn, if you want to go the monad transformer way, try "forever :: StateT s (MaybeT IO) () -> StateT s (MaybeT IO) Void"
07:01:32 <Cale> (or, you might not be using reactimate, but the idea is the same regardless -- you make the *actual* I/O code be part of the driver which provides input to the SF computation and interprets the output)
07:01:51 <liste> kaiyin did you add the src-exts there yourself?
07:02:15 <merijn> Gurkenglas: How does that improve anything?
07:02:41 <Cale> unit73e: Yes, but incorporating non-strict semantics into a dependently typed setting is an additional complication which Edwin didn't want to take on.
07:02:52 <Gurkenglas> The argument can call mzero to end the whole loop
07:02:59 <rydgel> Cale: So I should store somehow the sounds to be played in my game state?
07:03:49 <Gurkenglas> If you want a return value for the loop, use EitherT YourReturnType IO instead of MaybeT IO
07:03:59 <kaiyin> liste: yes, after one of the errors, i thought since it requires this version, maybe i should just specify it. 
07:04:09 <argoneus> can someone explain this line to me? (*) <$> Just 5 <*> Just 3
07:04:17 <Cale> rydgel: Well, you don't necessarily have a "game state" type with Yampa -- most of your game state will be captured by various parts of the SF computation.
07:04:17 <argoneus> first I fmap the * operator to Just 5, and then.. what?
07:04:35 <rydgel> Cale: I'm basically playing sound by analyzing the game state, but some tests are also done in Yampa. So that's why I think I do wrong
07:04:40 <unit73e> Cale: I see. I think lazy evaluation is the way to go but some gurus don't think so. Didn't think much about it yet though.
07:04:42 <Fuco> argoneus: then it creates a (Just (a -> a)) which you "apply" over Just 3 to produce Just 15
07:04:44 <Cale> argoneus: Well, the result is  Just (* 5) <*> Just 3,  right?
07:04:50 <kaiyin> argoneus: then you get fmap (* 5) Just 3
07:04:50 <Gurkenglas> merijn, unless of course you already know beforehand how many repetitions you want, then replicateM_ is right ._.
07:05:04 <argoneus> ohh, I see
07:05:11 <argoneus> so it packs the Just 5 into Just (*5)
07:05:12 <merijn> Gurkenglas: I just need a fixed number of iterations
07:05:23 <argoneus> and then I need to use <*> to unpack a function
07:05:24 <Fuco> f <$> a is 'short' for pure f <*> a
07:05:41 <Fuco> pure moves the function into the "functor", so in our case into Just
07:05:48 <Cale> unit73e: I think there are still some open questions about how non-strict semantics should interact with evaluation of terms with free variables in them.
07:06:04 <Fuco> and <*> unpacks it, correct (or rather, unpacks the arguments, apply, pack them back)
07:06:14 <Cale> unit73e: But yeah, I agree with you that lazy evaluation (or something close to it) is the way to go.
07:06:30 <liste> kaiyin pointfree 1.1.1.1 isn't compatible with src-exts 1.16, try using pointfree 1.1
07:06:39 <argoneus> so I can fmap * onto Just 5, because Just 5 is a functor while * is just a normal function
07:06:42 <argoneus> but then I end up with two functors
07:06:45 <argoneus> so I need to use <*>
07:06:48 <argoneus> okay
07:06:51 <Cale> argoneus: Just 5 is not a functor
07:06:54 <Cale> Maybe is a functor
07:06:59 <argoneus> er, right
07:07:02 <kaiyin> liste: so I should add pointfree 1.1 into the yaml file?
07:07:04 <Fuco> argoneus: write down the types as they change, that should make it cleaner
07:07:09 <argoneus> Just 5 is f a, where f = Maybe
07:07:12 <argoneus> right
07:07:17 <liste> kaiyin yes
07:07:29 <Fuco> fmap is (a -> b) -> f a -> f b, and <*> is f (a -> b) -> f a -> f b
07:07:40 <Fuco> yes f = Maybe
07:07:56 <Cale> Just f <*> Just x = Just (f x)
07:08:02 <Fuco> and * is a -> a -> b so in the above b becaomes a -> b
07:08:07 <Fuco> a -> a -> a*
07:08:08 <Cale> and in all other cases, the result is Nothing
07:08:35 <argoneus> I'm still trying to understand the usage of functors in general, is the end result so that I write clean code without guarding for "what if", like "what if this value is null", it's just a Maybe, maybe it's a value maybe it's null, and the functions I use on it can work with it and return things as appropriate?
07:08:38 <kaiyin> liste: thanks. I think stack could have taken care of this, though.
07:09:01 <Cale> argoneus: Well, you're talking about Maybe rather than functors in general
07:09:01 <liste> kaiyin the problem is that pointfree isn't part of lts
07:09:11 <argoneus> Maybe is the only functor I've used so far
07:09:17 <Fuco> argoneus: kind of, the Maybe thing automatically handles the "null" cases for you, but that's just Maybe 
07:09:26 <Fuco> list is a functor too :)
07:09:26 <Cale> argoneus: Functors are just type constructors which have an appropriate definition of fmap, there are a lot of them and they have very little else in common.
07:09:41 <rydgel> Cale: Concret example: I made a flappy bird in SDL. I use Yampa and space bar makes the bird fly up. It's working nice, I just add some velocity to my bird and it's done. But now I want to add sound for this action. So for now I'm checking the state in the IO part or reactimate and if I detect the velocity going up I play a sound. But it seems weird to me. I think it should be easier.
07:10:11 <Cale> rydgel: Well, what's the type of your overall SF computation?
07:10:42 <argoneus> I'm still lost in the whole terminology, need to read more
07:10:50 <argoneus> I already forgot what the Ord, Show etc are called, type classes?
07:10:58 <Cale> yes
07:11:06 <Cale> Functor is also a type class
07:11:10 <argoneus> ohh
07:11:12 <Cale> Specifically:
07:11:17 <Cale> class Functor f where
07:11:23 <Cale>   fmap :: (a -> b) -> f a -> f b
07:11:38 <argoneus> so I give it a function and a functor+value
07:11:39 <rydgel> Cale: game :: RandomGen g => g -> SF AppInput Game
07:11:47 <argoneus> wait
07:11:53 <Cale> Each type constructor which is an instance of this class is called a functor
07:12:01 <argoneus> why isn't it something like :: Functor f => (a -> b) ... ?
07:12:06 <argoneus> I thought this was the purpose
07:12:27 <Cale> rydgel: Okay, so you might make that SF AppInput (Game, Event SoundEffect)
07:12:33 <argoneus> to make sure you know what "f" is supposed to be
07:12:48 <kaiyin> ,:t ($)
07:12:51 <Cale> argoneus: Because it's inside the class declaration where I wrote the type there
07:12:57 <argoneus> ohhh
07:13:00 <argoneus> class Functor f where
07:13:02 <argoneus> riiight
07:13:20 <exio4> http://dpaste.com/0F7AT39 ; is there any obvious problem with this? my current problem is that after folding over the picture, the output only has Water 2 with my current input, (output: http://dpaste.com/3ETQXX2)
07:13:26 <Cale> Everywhere else, you're right, it would have that constraint on it :)
07:13:26 <argoneus> okay this is cool, thanks :)
07:13:28 <kaiyin> how do you do that in the channel? I mean like in ghci. :t ($)
07:13:30 <Cale> :t fmap
07:13:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:13:34 <Gurkenglas> (I used both getsT and modifyT in the data extractor I happened to write last night. http://lpaste.net/148381 it turns the GM's courier-font stuff from a forum RPG into some statistics. Style suggestions welcome!)
07:13:37 <kaiyin> :t ($)
07:13:39 <lambdabot> (a -> b) -> a -> b
07:13:44 <rydgel> Cale: hum. Can I put a list of Event if there are multiple sounds playing at the same time?
07:13:46 <argoneus> um, what is the <*> called?
07:13:46 <kaiyin> :t ($ 2) (+)
07:13:48 <lambdabot> Num a => a -> a
07:13:51 <Gurkenglas> I didn't know how to use those parser libraries so I just used StateT.
07:13:53 <argoneus> <$> is fmap
07:13:56 <Cale> rydgel: Or an Event of lists
07:14:09 <kadoban> argoneus: ap
07:14:10 <Fuco> I think it's called application ?
07:14:13 <argoneus> :t ap
07:14:15 <lambdabot> Monad m => m (a -> b) -> m a -> m b
07:14:16 <Cale> argoneus: Usually it's pronounced "ap" for application
07:14:20 <argoneus> oh
07:14:21 <rydgel> Cale: which can be empty.. I will try that.
07:14:24 <argoneus> monad...
07:14:26 <liste> argoneus <*> and ap do the same thing
07:14:26 <argoneus> there's that word again
07:14:36 <Fuco> it's not a monad, but every monad supports it :P
07:14:41 <Fuco> it's weaker than monads
07:14:41 <liste> one is for Applicative, the other is for Monad
07:14:47 <Cale> It's interesting that you're learning about applicative functors and you don't know about Monad yet.
07:14:48 <rydgel> Cale: code is here if curious: https://github.com/Rydgel/flappy-haskell/
07:15:09 <argoneus> Cale: tis194 talks about monads last
07:15:09 <Fuco> Cale: why? 
07:15:16 <argoneus> it talks about IO, then functors, then applicative functors and then monads
07:15:26 <argoneus> I still have no idea how IO works though
07:15:28 <argoneus> lel
07:15:49 <argoneus> I'll just read on some more it'll come together I'm sure
07:16:02 <Fuco> I understood IO only when I made the somwhat loose connection to Ruby's blocks
07:16:13 <Fuco> it's basically "piece of code" which does something producing a result
07:16:16 <Cale> Even though in some sense, it's natural that you'd go with the order  Functor -> Applicative -> Monad, because each is a superclass of the next, in practice, I think it's easier if you maybe go Functor -> Monad -> Applicative or Monad -> Functor -> Applicative
07:17:02 <Fuco> now that I think back, we covered monads first in my FP course
07:17:05 <Fuco> because of IO
07:17:15 <Fuco> and I had no clue about wht is going on :D good times
07:17:16 <argoneus> no FP course at my uni ;_;
07:17:23 <argoneus> well, maybe at masters
07:17:32 <Fuco> they cancelled it 2 years ago here as well :/
07:17:36 <Cale> Applicative is less frequent in usage than Functor and Monad, and there are few good examples of Applicatives which are not Monads (though they exist)
07:17:38 <Fuco> it was right in 1st frehsmen semester
07:17:54 <Fuco> yea that's true
07:18:05 <Cale> It's much easier to first understand (<*>) in the case where the functor happens to be a monad
07:18:13 <exio4> Cale: is it? if you are writing parsers.. :p 
07:18:38 <Fuco> isn't parsers basically why applicative was invented?
07:18:44 <Fuco> which would make the one good example for it :D
07:18:53 <Cale> You can read  x <*> y  as  do f <- x; v <- y; return (f v)
07:19:03 <Taneb> ZipList and Concurrently are two good Applicatives that are not Monads
07:19:12 <Cale> (but only when it's actually a monad)
07:19:53 <Cale> Taneb: yeah... but how many others can you list? Compare with how easy it is to come up with examples of instances of Monad
07:20:35 <Taneb> Fair :)
07:20:49 <Cale> You can put off learning about Applicative for quite a while. We didn't even have it for the first several years that I was using Haskell.
07:22:34 <Fuco> I learned about monoidal functors way before I learned about Applicative too :P
07:22:49 <Fuco> in fact until quite recently I never mead the connection about them being the same thing
07:22:58 <Fuco> such is the deal with learning lots of theory for no particular reason
07:23:14 <argoneus> ohhhh
07:23:17 <argoneus> IO is a monad just like Maybe?
07:23:21 <Fuco> yep
07:23:23 <argoneus> it just wraps values
07:23:33 <Fuco> yes
07:23:36 <geekosaur> not exactly
07:23:44 <liste> it's also a functor
07:23:52 <liste> (which is implied by Monad)
07:23:53 <argoneus> isn't every monad a functor?
07:23:56 <liste> yep
07:24:07 <argoneus> and is every monad an applicative too?
07:24:09 <Fuco> well wraps values with the side-clause that the value can change between calls to the same piece of code
07:24:09 <rydgel> A monad don't wrap values.
07:24:14 <merijn> argoneus: Yes
07:24:22 <Hafydd> What does this constructor represent? https://downloads.haskell.org/~ghc/latest/docs/html/libraries/template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#v:StaticE
07:24:24 <argoneus> so Monad > Applicative > Functor?
07:24:36 <Taneb> argoneus:
07:24:37 <Taneb> yes
07:24:46 <argoneus> neat
07:24:49 <Fuco> rydgel: what does it do then?
07:24:51 <rydgel> It describes a set a action that will eventually makes a value
07:24:54 <rydgel> of*
07:24:55 <Cale> argoneus: A value of type IO String is not very much like a String at all, just like /bin/ls is not very much like a list of files
07:25:17 <rydgel> it's like a recipe
07:25:18 <Cale> argoneus: Instead, it's a program whose result, when executed, will be a String (provided that it terminates normally)
07:25:28 <puregreen> Hafydd: https://ghc.haskell.org/trac/ghc/wiki/StaticPointers
07:25:42 <Fuco> that's a better explanation indeed
07:26:02 <Fuco> still can be understood in terms of wrapping but that's a lot more handwawing
07:26:27 <argoneus> oh, I see
07:26:31 <rydgel> No because people then asks "how to unwrap"
07:26:35 <Fuco> right
07:26:35 <argoneus> I thought an IO String was a string that has some monad overhead
07:26:36 <Cale> argoneus: If you have an IO action, e.g. getLine :: IO String, you may execute it multiple times (and potentially get different results each time), or you might choose not to execute it at all.
07:26:36 <Hafydd> puregreen: Ah. Thank you.
07:27:03 <Fuco> performUnsafeIO :D
07:27:09 <Fuco> or whatever it is called
07:27:19 <Fuco> I an never remember the word order
07:27:20 <Cale> argoneus: Each time you execute it, it will request a String from the user, so it's hard to imagine that the String is somehow packaged up inside getLine itself.
07:27:39 <argoneus> right
07:27:40 <Cale> argoneus: (though with enough mental gymnastics, anything is possible ;)
07:27:44 <Taneb> (don't use unsafePerformIO unless you REALLY know what you are doing. 99.99% of the time it is not what you want)
07:27:59 <argoneus> but I can bind getLine to something like parseInput, no?
07:28:19 <Taneb> Yes, with somethng like fmap
07:28:23 <Cale> What's the type of parseInput?
07:28:46 <merijn> @quote not.a.bug
07:28:46 <lambdabot> SPJ says: [This is] clearly not a bug in GHC; but it would be more felicitous if it gave you a warning...
07:28:49 <merijn> eh
07:28:49 <liste> argoneus that way you're describing a new action that runs getLine and does something with the results
07:28:50 <merijn> @quote not.a.bug
07:28:51 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
07:29:04 <Fuco> Taneb: the 99.99% is exactly the reason why I don't remember the name :P
07:29:10 <argoneus> Cale: could it be IO String -> String or something like that?
07:29:32 <Fuco> argoneus: nono, you would typically make it String -> String and then "map it over IO"
07:29:37 <Fuco> just like you "map" * over Maybe
07:29:37 <kaiyin> how do you derive this from the 4 applicative functor laws? fmap f x = pure f <*> x
07:29:52 <Taneb> argoneus: that's saying "If you give me a way to access a String using IO, I will give you a String while using no IO at all!"
07:30:04 <argoneus> hmm
07:30:22 <Cale> I've used unsafePerformIO very few times in real code in the 15 years or so that I've been writing Haskell. I think I've used unsafeCoerce a bit more.
07:30:38 <byorgey> kaiyin: you can't, because the applicative functor laws don't say anything about fmap.
07:30:46 <Cale> (but still both probably less than 5 times, I'm not sure exactly)
07:30:47 <puregreen> I want to do something exactly N seconds from now (where “N seconds” can potentially be years); what are the right types to use? I'm not sure whether NominalDiffTime would work, since it ignores leap seconds
07:30:58 <Taneb> Cale: I've used unsafePerformIO for one thing, which I later changed to use ST
07:31:06 <byorgey> kaiyin: you have to take that as an axiom specifying the relationship between Functor and Applicative.
07:31:36 <kaiyin> puregreen: i thought so, too. but here it says this is derived from the laws: https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Applicative.html
07:31:59 <Cale> argoneus: You usually don't want the argument to a function to be an IO String, unless that function is going to be something control-structure like and wants to decide when and how many times to execute the action.
07:32:33 <Cale> argoneus: Instead, you'd want to just take a String which will be the result of your previously-executed action
07:32:35 <Taneb> byorgey: no you don't. It behaves like fmap which means that it must do the same thing as fmap
07:33:00 <kaiyin> byorgey: plz see the link above. 
07:33:03 <byorgey> Taneb: aha, right, good point
07:33:13 <quicksilver> kaiyin: I don't think it follows only from those laws, as such.
07:33:16 <byorgey> kaiyin: Taneb is right.  One can prove (via parametricity) that fmap is unique
07:33:19 <argoneus> this stuff hurts to think about
07:33:23 <quicksilver> I think it follows from those laws + parametricity
07:33:37 <byorgey> that is, if there is a function with the type of fmap and which satisfies the functor laws, then it must actually be fmap
07:33:48 <Cale> argoneus: Okay, so the important thing to know is how to put together multiple IO actions to form larger ones
07:33:59 <quicksilver> in fact it follows from parametricity plus the 'id' law
07:34:05 <byorgey> using the Applicative laws you can show that  foo f x = pure f <*> x  satisfies the functor laws
07:34:09 <Cale> argoneus: You can write a do-block, like  do v <- getLine; putStrLn (reverse v)
07:34:17 <dgpratt> this link appears to be dead http://comonad.com/reader/2011/free-monads-for-less-2/
07:34:38 <pantsman-> all of comonad.com seems to have disappeared
07:34:39 <Cale> Here, v :: String is the result of executing getLine. The first line of the do-block "v <- getLine" means "execute the action getLine, and name its result v"
07:34:50 <dgpratt> indeed, pantsman- 
07:35:18 <Cale> The do-block as a whole will have the same type as the last action in it (and return whatever the result of that action is as its own result)
07:35:50 <Cale> In this case,  putStrLn :: String -> IO ()  produces an action having an empty tuple as its result, so our whole do-block will as well
07:36:46 <Cale> Notice how the function 'reverse' doesn't need to know or care that the String it's operating on came from getLine
07:37:08 <Cale> its type, [a] -> [a] doesn't involve IO in any way
07:37:30 <byorgey> puregreen: right, if you care about leap seconds then you want to use  DiffTime
07:38:11 <dgpratt> I've come across a few discussions of free monads and effects recently and I was trying to remind myself about something I read about regarding free monads and bind leading to poor asymptotics and what might be done about it
07:39:34 <dgpratt> edwardk, is comonad.com your property? do you know where I might be able to find that resource elsewhere?
07:39:48 <byorgey> dgpratt: http://www.janis-voigtlaender.eu/papers/AsymptoticImprovementOfComputationsOverFreeMonads.pdf
07:40:22 <dgpratt> somehow I find papers scary, but I'll give it a go, thanks byorgey :)
07:40:24 <byorgey> dgpratt: the short version is that with a free monad, every time you do a bind you have to traverse the whole tree down to the leaves
07:40:32 <argoneus> Cale: do blocks are still 2spoopy4me
07:40:38 <Cale> dgpratt: One thing you can do about it is just to pass around records of the operations instead (i.e. the actual operations, rather than symbolic placeholders for them)
07:40:40 <argoneus> using monads in general is
07:40:55 <puregreen> byorgey: how is DiffTime used, tho?
07:41:08 <Cale> argoneus: Well, okay, so it might help to understand the way in which do-notation is syntax sugar for using (>>=)
07:41:18 <dgpratt> very interesting, Cale -- more fodder for googling :)
07:41:42 <byorgey> dgpratt: but if you replace it with a Codensity monad (which basically amounts to storing continuations), you can reassociate the binds
07:41:43 <puregreen> I guess the time package doesn't have a database of leap seconds, so if I want to get the difference between 2 moments in time as DiffTime, I have to use some package that contains a database of leap seconds? or not?
07:41:52 <argoneus> yeah, thing is I still don't quite get what >>= does, other than "it takes a monadic function and a monadic parameter and returns a monad"
07:41:55 <byorgey> puregreen: see e.g. http://hackage.haskell.org/package/time-1.6/docs/Data-Time-Clock-TAI.html
07:41:59 <argoneus> which is.. cool I guess
07:42:10 <Cale> argoneus: You're using the word "monad" incorrectly :)
07:42:16 <argoneus> that's possible too :<
07:42:23 <Cale> argoneus: It refers to the type constructor
07:42:24 <puregreen> byorgey: ouch, I never noticed this module before
07:42:25 <puregreen> thanks
07:42:29 <Cale> Maybe is a monad, but Just 5 is not.
07:42:35 <Cale> IO is a monad, but getLine is not
07:42:39 <dgpratt> It amazes me how facile many of you folks are with this CT stuff
07:42:46 <argoneus> what is Just 5 then called, properly?
07:42:50 <argoneus> a context?
07:42:54 <argoneus> a context of a monad
07:42:54 <byorgey> argoneus: >>= does something different for each monad.  trying to figure out "what >>= does" is probably fruitless. =)  just learn what it does for each specific monad.
07:43:02 <Cale> Well, it's a Maybe Integer
07:43:22 <dgpratt> it also amazes me how much CT has relevance for CS via Haskell
07:43:23 <argoneus> so Monad m => m a?
07:43:28 <byorgey> dgpratt: as with anything, it all comes from lots of practice.
07:43:37 <nshepperd> if you care about leap seconds, you probably want to run screaming into the night from all computers
07:43:48 <quicksilver> argoneus: it's called an "action" sometimes
07:43:49 <Cale> If you want to refer to something of type m a where m is a monad, you might say m-action, or m-computation, or you can leave the "m-" off if it's clear which monad
07:43:59 <byorgey> nshepperd: hahaha
07:44:13 <argoneus> I feel like it would help me understand if I had concrete examples
07:44:17 <Cale> It's a bit funny to refer to Just 5 as a Maybe-action
07:44:24 <argoneus> Maybe is a monad, IO is a monad, but I still don't get why
07:44:36 * hackagebot opaleye-trans 0.3.1 - A monad transformer for Opaleye  https://hackage.haskell.org/package/opaleye-trans-0.3.1 (wraithm)
07:44:39 <argoneus> so I can wrap something in a super-package and give it side effects?
07:44:52 <Cale> argoneus: The reason why is just that there are suitable implementations of  return :: a -> m a, and (>>=) :: m a -> (a -> m b) -> m b
07:44:55 <argoneus> I thought IO String was a regular string with the ability to print/read it
07:44:59 <Cale> which satisfy some laws
07:45:00 <quicksilver> Cale: but it is helpful to have a consistent noun to use, even if Maybe-action sounds odd.
07:45:02 <argoneus> but apparently it's just a "recipe", whatever that is :(
07:45:06 <Cale> quicksilver: yeah
07:45:06 <Xandaros> argoneus: A monad is just a type that implements the Monad typeclass. There is nothing that special about it
07:45:15 <quicksilver> argoneus: IO String is like a chunk of code which, when executed, will provide a String
07:45:28 <Xandaros> (Except IO. IO is very special)
07:45:33 <quicksilver> argoneus: you can execute it many times, or none, and it may produce different results each time.
07:45:44 <Cale> argoneus: The difference between a value of type IO String, and a value of type String is exactly like the difference between /bin/ls and a list of files
07:45:52 <quicksilver> that's just another analogy for 'recipe'
07:45:58 <quicksilver> but you weren't finding recipe helpful :)
07:46:04 <argoneus> well
07:46:19 <argoneus> I found some explanation-for-noobs where they had a value and they put it into a gift package and called the gift package a monad
07:46:23 <argoneus> but apparently that's misleading
07:46:25 <Cale> Yeah, it is.
07:46:35 <Cale> There are a lot of really horrible tutorials on monads on the web
07:46:36 <quicksilver> I don't find the gift package analogy helpful, personally.
07:46:42 <quicksilver> If you find it useful for something, then great :)
07:46:48 <argoneus> it's not useful if it's wrong
07:46:51 <Cale> I might recommend my own tutorial https://wiki.haskell.org/Monads_as_computation
07:46:52 <argoneus> it's the opposite of helpful :<
07:46:54 <merijn> It might be useful, but not for IO :)
07:47:19 <argoneus> Cale: I'll read that right now thanks
07:47:29 <merijn> argoneus: The problem is that "monads" are just an abstract interface that happens to fit lots of different problems which are not all alike
07:47:35 <argoneus> by the way, one quick question
07:47:48 <merijn> argoneus: For example, "Maybe" is a monad too, and the box/gift package/etc. fits Maybe reasonably well
07:47:51 <quicksilver> I quite like 'you could have invented monads' as motivation.
07:47:56 <argoneus> do other FPLs share the idea of monads and haskell ideas in general? like if I wanted to learn Clojure, would there be any totally new concepts or is it comparable?
07:48:00 <liste> Maybe is a gift package that may be empty. that'd be quite sad in Christmas though :(
07:48:00 <Cale> argoneus: If you want to think of an IO String action as a fancy sort of box with a bunch of machinery in it that can do some stuff to eventually emit a String whenever it's done, then that's not too bad an analogy
07:48:01 <merijn> It's just a pretty poor description for IO
07:48:27 <Cale> (and which can be activated multiple times, or never)
07:48:42 <mnoonan> Cale: the box is called a "computer", I think :)
07:48:45 <Cale> yes
07:48:49 <Cale> hahaha
07:49:05 <nshepperd> monad is an interface, more than anything else
07:49:28 <argoneus> not the java kind of interface I guess
07:49:47 <mauke> it's not that far off
07:49:50 <Xandaros> Actually, it kinda is
07:49:52 <argoneus> huh?
07:49:55 <Cale> argoneus: It would be hard to encode in Java, but kinda, yes
07:49:56 <argoneus> so I have something like
07:50:05 <argoneus> class IOString implements Monad_IO?
07:50:06 <argoneus> or what
07:50:15 <Cale> not as such
07:50:16 <Cale> heh
07:50:28 <liste> argoneus more like class IODict implements Monad<IO>
07:50:38 <Fuco> more like IO<String> implements Monad<String>
07:50:48 <mauke> argoneus: class IO<T> { ... }; IO implements Monad { ... };
07:50:49 <argoneus> okay let's go away from this analogy
07:50:51 <argoneus> :D
07:50:52 <Xandaros> Let's drop these anologies...
07:50:52 <Cale> Fuco: whaaa
07:51:04 <argoneus> I just got
07:51:07 <Cale> oh, maybe, heh, Java is weird
07:51:08 <argoneus> 4 different ideas
07:51:15 <Xandaros> argoneus: Do you know about typeclasses in haskell?
07:51:19 <Cale> But yeah, that wouldn't really work
07:51:36 <quicksilver> typeclasses are structurally like interfaces
07:51:38 <Cale> argoneus: It's hard to express in Java because Java doesn't let you abstract over type constructors
07:51:38 <Zekka|Sigfig> argoneus: AFAIK Clojure is untyped by default, so I’d be surprised if it expressed most of the funky type-related tricks the same way
07:51:43 <argoneus> Xandaros: "know"... the way I see it I just have some super types like Int, String etc and then some typeclasses that give me a closer idea of what they represent
07:51:52 <Fuco> Cale: well first you have m String -> (String -> m _) -> m _ and then you swap m for IO
07:51:52 <argoneus> so the answer is probably no
07:51:53 <quicksilver> but I don't know java generics well enough to know if it ca support the type-changing methods like fmap?
07:51:58 <Fuco> and it would need the 'b' argument too
07:52:06 <Zekka|Sigfig> It probably has something like monads for comopsing asynchronous actions but I doubt it calls them that
07:52:07 <nshepperd> Monad is like java interfaces in the very abstract sense that it's a set of operations that some types either support or do not support
07:52:16 <quicksilver> as a programming principle tho, any programming problem which you solved in java with an interface you shoulud probably *not* solve in haskell with a typeclass :)
07:52:41 <Xandaros> argoneus: A typeclass is more like the interface from Java. You have a set of functions (or any values, really), which belong to a type. So "Int" is an instance of the typeclass "Num", which contains functions like (+)
07:52:45 <Cale> quicksilver: hahahaha
07:52:56 <Cale> quicksilver: so unfortunate
07:53:04 <dgpratt> do you think it is fair to say that a big part of the point of Monads is to model a statement-based programming model?
07:53:10 <quicksilver> Cale: ?
07:53:15 <merijn> dgpratt: not in my opinion
07:53:25 <Cale> quicksilver: Well, type classes are indeed a lot like interfaces
07:53:26 <quicksilver> dgpratt: I would not say that is fair, now.
07:53:43 <argoneus> so uh, when I have a String, it's just a string like "hello", but if I have an IO string, it's a magic box that can return strings, print them, read them, etc.?
07:53:45 <arw> dgpratt: its one possible use, not more.
07:53:57 <Xandaros> argoneus: A Monad is an a typeclass, containing the function (>>=). I suggest you have a look at functors first, what (>>=) does should then become apparent from the type alonge. (In my opinion, anyway)
07:54:10 <Zekka|Sigfig> argoneus: AFAIK the languages other than Haskell that contain the biggest amount of wacky Haskell stuff are Scala and Idris
07:54:13 <quicksilver> Cale: yes.
07:54:21 <Cale> argoneus: It's a magic box which when you turn it on, might cause your computer to do anything that your computer is capable of, before producing a String when and if it's done.
07:54:27 <Fuco> Scala is so confusing
07:54:39 <argoneus> hm
07:54:39 <Cale> argoneus: That is, it's a program which when executed, produces a String.
07:54:45 <dgpratt> by that I mean such things as: 1) statements 'compose' to make more statements; 2) the sequence of statements probably matters (i.e. X;Y; is probably a different program than Y;X;) and 3) variables bound in one statement are available to subsequent statements
07:54:47 <argoneus> I'll just read that thing you linked
07:55:01 <Xandaros> argoneus: May I also suggest the
07:55:05 <Xandaros> @where typeclassopedia
07:55:05 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
07:55:06 <Cale> argoneus: Note that we're talking about IO in particular here, rather than monads in general.
07:55:28 <argoneus> is IO some black sheep or something?
07:55:38 <Cale> argoneus: IO is a pretty complicated example of a monad, and it's a bit hard to discuss, because its implementation is hidden (it's an abstract type)
07:55:41 <Zekka|Sigfig> argoneus: Going into some FP history since you asked earlier: Haskell’s considered an ML-family language, meaning it has ML-style syntax and a type system that feels like ML’s, so it shares a lot with Scala, Idris, Agda, SML, Ocaml, etc.
07:55:48 <Xandaros> IO is a bit of a special snowflake. I suggest you ignore it for now ;)
07:55:59 <argoneus> aight
07:56:11 <mauke> argoneus: the most important point is that you can understand IO and monads separately
07:56:11 <argoneus> well, the only monads I've come across so far are Either, Maybe and IO "<
07:56:13 <argoneus> :<
07:56:16 <Cale> argoneus: In principle, you could imagine that IO actions were syntax trees of programs, and that (>>=) was gluing the syntax trees together somehow.
07:56:18 <Zekka|Sigfig> ML family languages like Haskell and Lisp-family languages like Clojure are both based on the lambda calculus, but most lisp-family languages either don’t have a type system or have a less elaborate one
07:56:22 <Xandaros> Maybe is a perfect example of a Monad
07:56:28 <Zekka|Sigfig> (there are some exceptions, like Shen)
07:56:32 <mauke> argoneus: that is, you can "grok" IO without learning about monads
07:56:36 <Xandaros> State is also nice to see the "computation" aspect
07:56:42 <Cale> Maybe is an okay example of a Monad, but it might be a little too simple to get the point across.
07:56:54 <Zekka|Sigfig> There are also non-lambda calculus functional languages, like Prolog, Mercury, and arguably CHR.
07:57:02 <Cale> The real example which really made it click for me was Parser
07:57:12 <Zekka|Sigfig> although a lot of guys claim those aren’t *real* functional programming languages (it’s kind of a nebulous term)
07:57:13 <Fuco> Cale: that's exactly they way I understood it, as said, via Ruby blocks
07:57:19 <dgpratt> what sort of Monadic concepts would not fit in my "statement-based model" -- ideally concepts that don't themselves fit in something smaller than Monads (i.e. Applicative)?
07:57:25 <Fuco> you are just gluing syntax, or "parts" of programs
07:57:47 <Cale> dgpratt: Well, you're not exactly wrong -- do-notation is built up in terms of things we call statements.
07:58:10 <Fuco> Xandaros: State is about as confusing as IO I would say... since they are basically the same thing philosophically
07:58:11 <nshepperd> dgpratt: you'd have to stretch to describe trees as having anything to do with statements
07:58:12 <Cale> dgpratt: But I don't know if that's a helpful description, because you need to know very precisely what "statement" means.
07:58:40 <Zekka|Sigfig> argoneus: Actually, if you like programming history/taxonomy, you should probably stop by #yfl or something and ask the guys in there to compare Haskell to other FP languages (be warned, that channel has a strong logic programming bias)
07:58:47 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (10*x + y)
07:58:48 <argoneus> by the way thanks guys, you're one of the friendliest freenode chanels :p
07:58:49 <lambdabot>  [14,15,24,25,34,35]
07:59:00 <Cale> ^^ an example of using the Monad instance for lists
08:00:10 <Xandaros> Fuco: Well, State is pretty comlicated, but that's exactly the point. And in contrast to IO, you can actually see its implementation and get an understanding about how it works "under the hood"
08:00:28 <nshepperd> it seems a little backward to me to say 'monads are like gift boxes' (even though they are in a way) or 'monads are like trees' (even though they are in a way) or 'monads are like recipes'
08:00:28 <Xandaros> That said, I think working with Maybe first is a good idea
08:00:44 <Zekka|Sigfig> FWIW, be very careful about saying State and IO are similar philosophically in the presence of bitemyapp!
08:00:50 <mauke> monads are like type constructors
08:00:56 <nshepperd> it's more accurate that, Maybe is a monad, and Tree is a monad, and recipes are a monad
08:01:00 <dgpratt> argoneus, I found it useful to meditate on a simple monadic function like "madd mx my = do { x <- mx; y <- my; return (x + y); }" and what it means in various monadic contexts
08:01:29 <nshepperd> if you study all those together, you get an idea of the intersection of those things, which is the interface Monad
08:01:46 <Cale> argoneus: There are libraries you can get (and there are ways to implement a toy version of such a library simple enough that we might just do it in the channel in a little bit) which help you build parsers, and where you have some type constructor Parser, such that a value of type Parser t is something which will consume some initial fragment of a String and give you a bunch of parses (perhaps the parse is ambiguous),
08:01:46 <Cale>  each of which consists of a value of type t, and the remainder of the String which was left over in that case.
08:01:51 <mpiechotka> @pl \x -> f (g >>= h x)
08:01:52 <lambdabot> f . (g >>=) . h
08:02:15 <mpiechotka> @pl \x -> f (h x =<< g)
08:02:16 <lambdabot> f . (g >>=) . h
08:02:31 <argoneus> wait
08:02:35 <Zekka|Sigfig> mpiechotka: Whoa! Lambdabot is smarter than I thought.
08:02:37 <argoneus> so in haskell, instead of making solutions
08:02:45 <argoneus> you define the problem and get back a solution space?
08:02:46 <argoneus> ideally
08:03:02 <Zekka|Sigfig> argoneus: Hm, where did you get that? Sounds more like Prolog to me!
08:03:08 <mauke> argoneus: I don't
08:03:13 <argoneus> well
08:03:23 <argoneus> there seems to be a popular thing in haskell
08:03:27 <Cale> argoneus: Ideally we want to design libraries which describe a space of problems, and construct the solutions to those problems from the description of the problem (recursively)
08:03:27 <argoneus> "this value is either this, this or this"
08:03:38 <quicksilver> in haskell I take more care to define data types which model my problem properly at front
08:03:40 <mpiechotka> Zekka|Sigfig: If by 'smarter' you mean mixing left-to-right with right-to-left operators for extra clarity of pointless style ;)
08:03:47 <quicksilver> and that certainly makes solving problems faster IME.
08:03:52 <pantsman-> types certainly help to constrain the solution space
08:04:14 <nshepperd> that's a very abstract question
08:04:21 <argoneus> slightly OT question: what's the most fun/interesting thing you guys have done in haskell personally?
08:04:23 <Zekka|Sigfig> The type inference system can do a lot of work for you, and laziness lets you ask Haskell for solutions you don’t intend to explore fully, I guess
08:04:30 <argoneus> like a project or something
08:04:38 <nshepperd> there is for sure a general ethos of starting by understanding what you're talking about first
08:04:41 <Cale> actually, here's a talk you should probably watch before everything else http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/
08:04:46 <Zekka|Sigfig> (if you’re a huge fan of the type inference system, I recommend Prolog a second time!)
08:05:19 <Cale> (and I actually highly recommend it to anyone who is interested in the large scale question of what sorts of things we think about when designing functional solutions to problems)
08:05:32 <mauke> argoneus: wrote some xmonad extensions, like simple mouse gestures
08:05:50 <Zekka|Sigfig> I designed/implemented a programming language, but I wouldn’t stand by the design decisions I made now
08:05:58 <Zekka|Sigfig> and I *really* wouldn’t stand behind the implementation decisions
08:06:23 <argoneus> Zekka|Sigfig: I guess with Haskell you can define grammars quite naturally?
08:06:29 <Zekka|Sigfig> er, argoneus  — this is in reference to your question
08:06:31 <mauke> argoneus: I wrote code that behaves differently under different language pragmas, thus "detecting" which language extensions are enabled
08:06:35 <pranz> argoneus: well, parsing and interpreting is just a joy to work with when it comes to haskell
08:06:44 <Zekka|Sigfig> argoneus: Parsing was one of my initial considerations, although it turned out to be a small part of the problem
08:07:08 <pranz> argoneus: but the most fun I've had is when I'm doing more theoretical stuff trying to experiment with the typesystem (and it's extensions)
08:07:26 <Cale> argoneus: Well, I worked on an action roleplaying game which was sadly not released, but we got pretty far with it. It had pretty fun combat against melee and ranged AIs and a big (but still mostly empty) open world that dynamically loaded, and it ran reasonably well on desktop machines, but we still had a ways to go before it would probably run well on all the phones we wanted to eventually target
08:07:28 <Zekka|Sigfig> My reason *should* have been backtracking, (because things are backtrackable by default in Haskell) but I didn’t end up doing anything interesting with backtracking for that project
08:07:51 <Zekka|Sigfig> I’m currently working on a new iteration of hte design that’s very suitable for Haskell’s strengths, but I’m doing it in Java because I want to interoperate with some specific software on the JVM.
08:08:32 <Zekka|Sigfig> (those strengths being laziness, usually being able to avoid stack overflows, and having good inbuilt persistent data structures)
08:08:49 <argoneus> hm
08:09:09 <Cale> argoneus: Our game engine was a functional reactive programming system that we worked on -- a lot of the ideas and things we learned in building that have now been incorporated into Reflex. These days, I'm working for Obsidian Systems using Reflex and Reflex-dom to build web applications in Haskell.
08:09:55 <argoneus> Cale: Reflex?
08:10:23 <argoneus> oh, an interface
08:10:24 <argoneus> not a game
08:10:34 <Cale> Yeah, it's an FRP system
08:10:42 <pranz> Cale: is the game source available?
08:11:10 <Cale> pranz: It's not, but we'd always meant to chop it up and open source parts of it.
08:11:32 <argoneus> Cale: why did it not get released?
08:11:43 <argoneus> inb4 it was a game I was looking forward to
08:11:49 <pranz> Cale: Ah, well I'll be on the lookout if it's eventually released
08:11:57 <Cale> argoneus: Company founders just ran out of money before it was done enough to sell anything.
08:12:44 <Cale> But it was fun, and it convinced me that eventually, writing games in Haskell will be quite nice -- we just have to cut a path through the jungle :)
08:13:40 <Cale> I think if I was to try to resuscitate it now, I would be very tempted to try to replace the FRP system with Reflex, which would involve rewriting large swathes of stuff
08:14:02 <dgpratt> nshepperd, I've been pondering what you said about statements vs. trees -- it occurs to me that statement-based programs *are* trees in some sense (hence why ASTs are endemic to compilers/interpreters), but perhaps I missed the point?
08:14:14 <Ankhers> Aside from people not having put the time in, is there any reason there is no Unreal or Unity quality game engine build in Haskell?
08:14:15 <Xandaros> It's going to be interesting to see some proper games in Haskell. I've only made a snake clone, so for. One using lens, which feels very imperative and one using FRP which is really dodgy
08:14:23 <Xandaros> *One version
08:14:25 <Cale> We were using an Arrow-ish FRP system (though we had our own Arrow classes, and our own preprocessor for the proc/do-notation)
08:14:28 <argoneus> do you think fp in general is "the future" so to speak? there will probably always be domains where it's unviable (embedded programming) but in general maybe for job opportunities?
08:14:32 <quicksilver> lens doesn't make code imperative
08:14:46 <quicksilver> it's just a convenient notation for data structure update and retrieval
08:14:47 <argoneus> or is it just something different
08:14:54 <argoneus> just another option
08:14:59 <quicksilver> it's still composable functions
08:15:19 <the_2nd> how can I compile for windows on linux? (cabal installed)
08:15:24 <Cale> argoneus: I think it's the present, and people just haven't caught up.
08:15:29 <Cale> (largely)
08:15:33 <Xandaros> quicksilver: I didn't say it is lens' fault. But the code of that version feels very imperative. (Probably because I have a global state in a state monad)
08:15:34 <Zekka|Sigfig> argoneus: I think FP-the-term is getting broad enough that some of the things you can apply it to are in domains people didn’t ever think it was suitable for, to
08:15:45 <bergmark> argoneus: just wait for the embedded lisp machine
08:15:54 <Fuco> fp in embedded programming is just a question of compilers being smart enough :P
08:16:08 <mauke> the_2nd: that's called cross compilation and I don't know if it works at all :-/
08:16:11 <Zekka|Sigfig> I mentioned CHR earlier, that’s a really terse FP programming language with a very direct conversion to C (google “CCHR paper")
08:16:27 <EvanR> Fuco: and using data structures that dont suck for being able to predict memory requirements
08:16:33 <quicksilver> Xandaros: ah, sorry, I falsely connected two parts of that sentence then :)
08:16:35 <EvanR> like List
08:16:58 <Xandaros> quicksilver: To be fair, my sentence does seem to imply that, although that was not my intention
08:17:09 <unit73e> Fuco: don't you need libraries to work?
08:17:26 <Zekka|Sigfig> You should ask Boney about fast FP programming languages, he’s into programming language implementation
08:18:05 <Cale> Actually, I think that a really interesting approach to embedded programming is to write programs which are essentially one-shot compilers in high level languages like Haskell, and which when run, compute and emit the program which will be run on the embedded device.
08:18:11 <argoneus> hm
08:18:19 <argoneus> then what kind of applications is lisp/haskell -really- bad for, then?
08:18:21 <Zekka|Sigfig> Not that I think FP will be popular in this space, but I think the domain where “FP” the abstract entity is viable is pretty big, if you accept that “FP” the abstract entity and “embedded programming” the abstract entity probably include lots of things you don’t mean.
08:18:23 <argoneus> it can't be universal
08:18:34 <Cale> argoneus: It's not really *terrible* at anything.
08:18:39 <Zekka|Sigfig> argoneus: Well, I wouldn’t do anything space-intensive in Haskell, although I might do it in a Lisp
08:19:02 <Cale> I'm crazy enough to do something space-intensive in Haskell. You just need to pick good datastructures.
08:19:08 <EvanR> space-intensive as in you have to do most work in the filesystem? ;)
08:19:15 <Zekka|Sigfig> Cale: I have a friend who works on 8kb chips.
08:19:17 <Xandaros> In a pinch, there is always ST :P
08:19:18 <Zekka|Sigfig> You should sell him on Haskell.
08:19:22 <quicksilver> haskell is not good for hard real-time
08:19:25 <unit73e> I work in the embedded space and some hardware doesn't even support C correctly, let alone haskell
08:19:40 <quicksilver> because you don't have enough control over when GC wil happen or how long it will take
08:19:41 <kaiyin> anyone has experience with this? https://github.com/begriffs/haskell-vim-now
08:19:44 <Zekka|Sigfig> (There’s some other languages  I think you could get primitive implementations of onto an 8kb chip, but at some point you will be asking yourself the question of why.)
08:19:46 <Cale> Yeah, if you have hard real-time constraints, you might want to use Haskell not-directly, but as a metalanguage.
08:19:47 <quicksilver> I should say - GHC is not good for these things.
08:19:58 <quicksilver> you can imagine a haskell runtime system with better control.
08:19:59 <argoneus> so you probably can't make something like neural networks or games in haskell?
08:20:03 <argoneus> or is that well within its domain as well
08:20:09 <Cale> argoneus: sure, you can
08:20:14 <Zekka|Sigfig> quicksilver: Yeah, there’s GC schemes that can guarantee cleanup occurs via constant-time incremental operations
08:20:26 <Hamstak> There's a ANN lib for haskell even
08:20:32 <Hamstak> Not that it's incredibly flushed out
08:20:34 <Hamstak> but it's there
08:20:36 <EvanR> argoneus: video games, haskell should be really good at
08:20:37 <Zekka|Sigfig> which iirc usually guarantees that you only do gcing while you’re allocating and it’s proportional to how much allocating oyu’re doing
08:20:41 <EvanR> we just dont have any examples
08:20:44 <Zekka|Sigfig> But on 8kb chips you statically allocate a lot of things too
08:21:07 <argoneus> EvanR: don't games have a lot of low level details?
08:21:10 <Xandaros> argoneus: People have built small games already. There's even a quake clone iirc. It's just that the libraries are not quite there yet, so you don't see too many of them
08:21:12 <Zekka|Sigfig> (Another FP language designed for weird constraints! Inform is a logic programming language for text adventures that IIRC statically-allocates almost everyhting.)
08:21:12 <Cale> http://hackage.haskell.org/package/atom -- this library was used to program microcontrollers for hybrid hydraulic vehicles (things like garbage trucks which you really don't want their control software screwing up)
08:21:14 <the_2nd> mauke, so shall I go get a windows machine or a vm on linux?
08:21:18 <EvanR> argoneus: so?
08:21:47 <argoneus> I don't see how you'd make calls to your GPU through haskell or render sprites or such
08:21:50 <the_2nd> mauke, or use wine?
08:22:00 <EvanR> the point is to avoid dealing with low level details in 100% of the code base
08:22:06 <quicksilver> argoneus: you use OpenGL or OpenCl
08:22:14 <EvanR> argoneus: i use the library gl
08:22:15 <quicksilver> or a library based on them.
08:22:16 <mauke> the_2nd: I have no experience in this but I suspect a VM would be the easiest solution
08:22:18 <Zekka|Sigfig> argoneus: I don’t know how gpu code is usually implemented on the C level, but you probably talk to a C program like argoneus said.
08:22:24 <Zekka|Sigfig> er, like quicksilver said
08:22:28 <argoneus> oh, there are OGL haskell bindings?
08:22:29 <argoneus> I see
08:22:34 <Cale> https://hackage.haskell.org/package/accelerate
08:22:37 <EvanR> Zekka|Sigfig: nah.
08:22:38 <quicksilver> there are loads of OpenGL programs written in haskell
08:22:41 <Cale> Oh, and yeah, there are OpenGL bindings
08:22:51 <Zekka|Sigfig> Haskell is pretty good at talking to C (I don’t know how you would do it if you didn’t want to talk to C)
08:22:58 <quicksilver> a commercial quality game is just a lot of work - in any language.
08:23:07 <EvanR> hobby games are a lot of work
08:23:12 <merijn> Zekka|Sigfig: Most languages only know how to talk to C :p
08:23:14 <quicksilver> there are quite a few hobby-standard games in haskell
08:23:17 <Cale> (the library I linked is related to exploiting GPUs for computation)
08:23:17 <argoneus> so when someone takes the time and makes a SDL or XNA for haskell then it will be just fine?
08:23:26 <quicksilver> there are SDL bindings, too, argoneus 
08:23:39 <Zekka|Sigfig> I’m suspicious of people who think programming is the biggest part of writing a game! (art people need money and food too!)
08:23:39 <Cale> But yeah, there could be more
08:23:48 <EvanR> SDL exists but is not nearly enough to really output a game just like that
08:24:02 <Zekka|Sigfig> argoneus: Some of the guys from Chucklefish were talking about releasing a ton of tooling for gamedev in Haskell a while ago, but I don’t know that it materialized
08:24:10 <argoneus> oh, wow
08:24:13 <argoneus> that's cool
08:24:23 <EvanR> #haskell-game
08:24:25 <merijn> I wouldn't use haskell for, say, a twitch FPS
08:24:26 <Cale> It's really the game engines which you'd build on top of that stuff which are missing
08:24:34 <argoneus> merijn: why not?
08:24:35 <merijn> But for stuff like RTS I don't see any problems
08:24:38 <argoneus> performance stuff?
08:24:40 <Cale> If you were planning on writing your own engine anyway, then Haskell is fine.
08:24:50 <merijn> argoneus: Garbage collection can result in unpredictable delays
08:25:05 <EvanR> haskell should be comparable to java in FPS land
08:25:05 <argoneus> that never stopped java :<
08:25:08 <Zekka|Sigfig> I think the tricky bits of Haskell for gamedev probably come from state management — Cale probably has more refined opinions on that than me though since he likes Haskell state management and he’s actually done gamedev in Haskell
08:25:17 <Zekka|Sigfig> Yeah, Haskell and Java both use concurrent world-stopping GCs, right?
08:25:21 <Cale> There are things you can do about the garbage collector
08:25:25 <Cale> (but yeah)
08:25:41 <EvanR> at least its generational
08:25:43 <merijn> Zekka|Sigfig: Haskell has minor GCs (per capability heap) and major GC (stop the world)
08:25:51 <unit73e> Java has a trick to avoid world stopping GC, sort off
08:26:00 <merijn> Zekka|Sigfig: Were a capability roughly corresponds to an OS thread
08:26:07 <argoneus> um
08:26:10 <unit73e> If you choose the right collector
08:26:10 <argoneus> you can't hack haskell?
08:26:14 <bartavelle> (also not all games require perfect interactivity, mostly action games do)
08:26:16 <argoneus> to disable or tweak GC or such
08:26:19 <Zekka|Sigfig> How’s the minor GC implemented?
08:26:24 <argoneus> even manage memory manually maybe
08:26:37 <Cale> On the desktop, I don't think you'd usually even feel major GCs, but they were something to worry about on the older iPhones we wanted to target.
08:26:37 <Zekka|Sigfig> argoneus: I’ve never worked on the runtime system! I don’t know how hard it would be to replace the GC with another one
08:26:46 <merijn> Zekka|Sigfig: Copy surviving data from nursery/local heap to long term heap, then reset heap to be empty :)
08:26:59 <Cale> Even on iPhones several years ago, you couldn't notice the minor GCs
08:26:59 <merijn> Zekka|Sigfig: Hard? Not very. Lots of work/engineering? Yes.
08:27:04 <mpiechotka> @pl \x -> f (g x =<< h =<< i)
08:27:04 <lambdabot> f . ((h =<< i) >>=) . g
08:27:08 <Zekka|Sigfig> merijn: That doesn’t stop the world?
08:27:30 <merijn> Zekka|Sigfig: That just stops the one thread running on that heap
08:27:31 <Zekka|Sigfig> What happens if the running code keeps a pointer to the local heap? Are all pointers double pointers?
08:27:38 <Cale> But the major GCs could take as much as a few hundred milliseconds on like an iPhone 3
08:27:41 <Zekka|Sigfig> Oh, wait, we’re on the same page: that’s what I thought it did!
08:27:43 <pranz> on the topic of memory management, would it be possible to incorporate linear types intohaskell without too much modification? (like a language extension)
08:27:54 <Fuco> simple, give infinite memory, disable GC
08:28:04 <merijn> Zekka|Sigfig: Stop the world refers to stopping EVERY thread simultaneously :)
08:28:06 <Xandaros> Fuco: Ingenious!
08:28:18 <merijn> Zekka|Sigfig: Instead of just one you're GCing for
08:28:30 <Zekka|Sigfig> merijn: OK, I will try to use more respectful terminology — apparently “concurrent stop-the-world” does not mean what I think it means
08:28:33 <Fuco> we're getting there, Moore's law never disapoints!
08:28:38 <mauke> Fuco: that's easy, just use RAM as a service over the internet
08:28:44 <Zekka|Sigfig> (I only know anything about GC implementation because a friend of mine is super into allocators)
08:28:45 <mauke> URLs instead of pointers
08:28:47 <Cale> (and major GCs were about once every 5 minutes)
08:28:53 <Fuco> mauke: that's even better!
08:29:04 <Fuco> I can even rent a bit of my own RAM for the RAM cloud!
08:29:06 <Cale> So our plan there was to have a very simple C++ program which would take instructions about which animations and stuff to put on the screen and continue taking input and rendering stuff through the time that the GC had stopped the Haskell code
08:29:31 <EvanR> pranz: low level management of memory doesn't sound like my favorite way to deal with writing a video game
08:29:35 <mpiechotka> @pl \x -> withForeignPtr x $ \x' -> mask $ init x' >> addForeignPtrFinalizer clear x
08:29:35 <lambdabot> ap withForeignPtr ((mask .) . flip ((>>) . init) . addForeignPtrFinalizer clear)
08:29:40 <Cale> Which would be significantly less noticeable -- that actually worked reasonably well, but toward the end of the project we started to question if it was necessary
08:29:55 <Xandaros> Well, but if you don't target older platforms or weaker platforms like that, it should be fine. Would it help to decrease the time between major GCs?
08:30:03 <bartavelle> Cale, wow, sounds like a lot of work!
08:30:06 <pranz> EvanR: not for writing the game, but the engine perhaps
08:30:39 <unit73e> what kind of GC does Haskell have compared to Java? Java has serial, parallel and CMS
08:31:08 <Cale> The Haskell implementation which we ran on the desktop, you wouldn't really notice the GCs -- though admittedly the game wasn't done, and I'm sure we'd have run into more memory intensive scenarios than we'd tested that far.
08:31:15 <joneshf-laptop> Are there any cassava examples for sum types?
08:31:43 <Cale> unit73e: It's a hybrid generational collector that uses mark and sweep and copy collectors.
08:31:45 <arw>  /win 58
08:31:46 <Zekka|Sigfig> unit73e: Can you clarify what you mean by “serial”, “parallel”, and “CMS”? Serial and parallel sound like guarantees a GC can make, not GC implementation styles. (I don’t know what CMS means)
08:31:46 <joneshf-laptop> preferably with a generic derivation
08:31:51 <arw> sorry.
08:32:04 <mauke> content management system
08:32:05 <EvanR> content management system
08:32:08 <mauke> ayy lmao
08:32:23 <Zekka|Sigfig> Well, I can guarantee you GHC’s garbage collector is not a content management system
08:32:35 <EvanR> or is it
08:32:39 <Zekka|Sigfig> but I assumed unit73e meant something else
08:32:43 <Cale> https://ghc.haskell.org/trac/ghc/wiki/GarbageCollectorNotes
08:32:57 <pantsman-> concurrent mark sweep
08:33:03 <unit73e> Zekka|Sigfig: serial and parallel are dumb, you fill everything until FullGC. CMS = Concurrent Mark & Sweep, apparently it is what Haskell uses
08:33:08 <Cale> GHC's garbage collector is concurrent, but it stops the world
08:33:24 <Cale> Versions which didn't stop all threads at once were tried
08:33:34 <Cale> but they had worse overall performance than just stopping everything
08:33:46 <the_2nd> how can I compile my haskell programm for windows on linux>
08:33:58 <Zekka|Sigfig> unit73e: Serial meaning “create garbage until something stupid happens, then freeze the whole program” and parallel meaning “create garbage till something stupid happens, then freeze certain threads”?
08:34:06 <Cale> the_2nd: You install windows
08:34:09 <EvanR> the_2nd: run windows in a VM
08:34:13 <unit73e> Zekka|Sigfig: exactly
08:34:35 <EvanR> the garbage collector doesn't create garbage
08:34:45 <EvanR> that would be a garbage creator
08:34:48 <Zekka|Sigfig> Oh yeah, forgive me. “let the program create garbage until […]"
08:35:04 <unit73e> I understood that was it
08:35:11 <unit73e> or assumed
08:36:06 <unit73e> serial and parallel aren't very smart but work ok if you want throughput instead of low pauses
08:36:52 <unit73e> There's a new GC in Java but I know nothing about it
08:37:03 <Zekka|Sigfig> If we’re saying the GC is concurrent, we don’t mean “it has multiple threads” but that “it runs while the program is running,” right?
08:39:59 <unit73e> Zekka|Sigfig: yes
08:40:57 <unit73e> Zekka|Sigfig: or to be more specific it runs concurrently when it is possible
08:41:29 <unit73e> Zekka|Sigfig: the point is to do more minor GC in order to avoid a FullGC
08:44:22 <unit73e> Zekka|Sigfig: you do have less throughput but you win shorter pauses making programs more responsive
08:45:02 <Zekka|Sigfig> unit73e: Yeah, I think we’re on the same page. I know at least one GC strategy designed around accomplishing that but I didn’t know that was the term for it
08:45:40 <Zekka|Sigfig> (it’s just another implementation technique for mark and sweep, nothing too exciting)
08:46:23 <Zekka|Sigfig> Cale: Thank you for waving Reflex around by the way — this looks like a fun toy!
08:47:48 <unit73e> there's another one G1 something that's supposed to replace CMS but I know nothing about
08:49:12 <unit73e> something do to with large memory I guess
08:52:59 <byorgey> x
08:53:14 <byorgey> heh, whoops
08:59:39 * hackagebot ViennaRNAParser 1.2.7 - Libary for parsing ViennaRNA package output  https://hackage.haskell.org/package/ViennaRNAParser-1.2.7 (FlorianEggenhofer)
09:02:00 <jophish> Hlint has a parse error when parsing quasiquotes in types :(
09:02:09 <jophish> well, hse is to blame I suppose
09:06:01 <jophish> mpickering: What was the conclusion of this https://github.com/haskell-suite/haskell-src-exts/pull/208
09:07:54 <mpickering> It got merged
09:11:33 <jophish> ah, I was using an old version of hlint by mistake, things are working well now I've compiled things from HEAD, thanks!
09:16:22 <the_2nd> I need to keep applying a function for each [A] to B
09:17:03 <the_2nd> so that newB =  (f a2 b) $ (f a1 b) ...
09:17:44 <the_2nd> newB = ... $ (f a2 )$ (f a1 ) b
09:18:02 <the_2nd> where f :: A -> B -> B
09:18:25 <the_2nd> is there a named higher function for this?
09:19:01 <byorgey> the_2nd: if I understand correctly, I think you are looking for foldr
09:19:19 <byorgey> > foldr f z [a,b,c,d,e]
09:19:21 <lambdabot>  f a (f b (f c (f d (f e z))))
09:19:25 <byorgey> like that?
09:19:37 <the_2nd> byorgey, looks good
09:20:21 <breadmonster> Hi byorgey 
09:31:17 <Gurkenglas> How do I turn a http://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Internal-Context.html#t:Context into a lens? The clone doesnt seem to work right
09:31:21 <Gurkenglas> *clone link
09:32:12 <cmotoche> Hi everyone, do you know how to execute a program and redirect the output using shelly (http://hackage.haskell.org/package/shelly-1.6.5/docs/Shelly.html)?
09:33:05 <Zekka|Sigfig> cmotoche: Looks like ‘run’ and ‘run_’ do what oyu want
09:34:44 <cmotoche> Yeah, they execute the command, but I don't know how to redirect its output.
09:36:30 <Zekka|Sigfig> Oh, you mean redirect it in a streaming fashion, not just capturing it?
09:36:40 <Gurkenglas> cmotoche, this will run command1 and command2 and pass the result two texts to command3
09:36:46 <Gurkenglas> (which is returned by the whole thing)
09:37:22 <Zekka|Sigfig> You could probably do it with runHandle, but there might be a higher-level way to do it (with runFoldLines, perhaps?)
09:37:33 <cmotoche> Yes, for example, redirect the output to /dev/null, to avoid the output on the screen.
09:38:11 <argoneus> does >>= do some sort of magic? like if I return a Maybe Int and bind it to a myfunc :: Int -> Bool, then it somehow needs to internally convert the Maybe Int to an Int, no?
09:38:25 <Zekka|Sigfig> cmotoche: Doesn’t run_ do that already? I don’t think you should need to use redirection to /dev/null for that
09:38:50 <Gurkenglas> argoneus, every typeclass that allows >>= has to define how to pass wrapped values to a function
09:38:57 <Zekka|Sigfig> argoneus: I think you mean Int -> Maybe Bool. And the “magic” is specified in the Monad instance for Maybe — but the magic actually has the form Maybe (Maybe Int) -> Maybe Int
09:39:07 <Hafydd> I have written this function, parseTxt, but I feel like the implementation is redundant, as if I'm extracting the value from its TH.Q context, only to pack it back in:
09:39:09 <Gurkenglas> Maybe, for example, only passes values wrapped in Just to the function, and returns Nothing otherwise
09:39:11 <cmotoche> I'm using run_.
09:39:23 <Zekka|Sigfig> (It also has the form (Maybe a) -> (a -> Maybe b) -> (Maybe b))
09:39:29 <Hafydd> http://lpaste.net/148436
09:39:42 <argoneus> so if Maybe returns Just 5, then it knows that the 5 in Just 5 is an int and passes that to my function?
09:39:51 <argoneus> or is it a different process
09:39:53 <Hafydd> I wonder if there's a shorter way to write that.
09:40:20 <Zekka|Sigfig> If you have Just 5, then (>>=) will pattern match on that, see the 5, and pass it to your function, because that’s what the Maybe intsance says
09:40:33 <Zekka|Sigfig> If you have Nothing then (>>=) will skip that)
09:40:35 <Zekka|Sigfig> @src >>= Maybe
09:40:36 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
09:40:40 <Zekka|Sigfig> @src Maybe >>=
09:40:41 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
09:40:51 <Zekka|Sigfig> Oh phooey! I can’t remember how to get it to tell me.
09:40:52 <argoneus> ohhh, I see
09:40:54 <argoneus> it's that
09:40:57 <Fuco> in other words, >>= is like function application only it extracts the result of the monad for you.  The type says it all
09:41:00 <argoneus> (>>=) m g = case m of ...
09:41:02 <argoneus> this, right?
09:41:10 <argoneus> if "m" is "Just x" then pass x to the function
09:41:14 <Fuco> yes
09:41:14 <argoneus> if it's nothing, then return nothing
09:41:17 <Zekka|Sigfig> (Just x) >>= f = f x    ;     Nothing >>= f = Nothing
09:41:54 <argoneus> this is probably a bad way to put it
09:42:05 <Fuco> from the second equation it is clear that f has to return the same monadic type too
09:42:08 <Fuco> that is important
09:42:17 <Fuco> in our case Maybe
09:42:46 <argoneus> right, that makes sense
09:42:56 <Fuco> so your function takes a normal value and has to return a monad
09:43:15 <argoneus> probably a dumb question, but isn't this an extra step?
09:43:26 <argoneus> shouldn't you pass the monadic value directly since you know it has to return the same monad?
09:43:49 <Fuco> no because then you would need to manually "extract" it
09:43:52 <argoneus> ah
09:43:53 <Zekka|Sigfig> argoneus: Can you give an example of the type you think it should have?
09:44:02 <Zekka|Sigfig> It sounds like you’re thinking (m a) -> (m a -> m b) -> (m b)
09:44:06 <argoneus> yes
09:44:10 <Fuco> if you mean f :: m a -> m b, you can turn a -> b into that with fmap
09:44:28 <Fuco> fmap :: (a -> b) -> (m a -> m b)
09:44:29 <argoneus> oh
09:44:36 <Zekka|Sigfig> That’s just function application, which is also useful, but you use it for different things
09:44:46 <argoneus> btw, do I get this right
09:44:49 <argoneus> lists are also monads?
09:44:53 <Fuco> yea
09:44:58 <argoneus> [1,2,3] is a monad that may happen to be 1 or 2 or 3
09:45:00 <Zekka|Sigfig> Yeah, lists are monads with (>>=) = concatMap
09:45:07 <Fuco> they represent "indeterministic computation"
09:45:08 <argoneus> just like Maybe may happen to be Just x or Nothing
09:45:14 <Zekka|Sigfig> argoneus: Yeah.
09:45:17 <argoneus> that kinda blew my mind
09:45:21 <argoneus> a list in haskell isn't a sequence of values
09:45:29 <argoneus> it's a value that happens to have multiple... contexts?
09:45:41 <Zekka|Sigfig> > [1, 2, 3] >>= (\x -> [(‘a’, x), (‘b’, x)])
09:45:43 <lambdabot>  <hint>:1:24: lexical error at character '\8216'
09:45:50 <Zekka|Sigfig> Oh screw my client, always smart quoting
09:45:57 <Fuco> argoneus: it is a sequence, but you can interpret the monad implementation as nondeterminism
09:46:03 <argoneus> so if I get this right
09:46:05 <Zekka|Sigfig> argoneus: You can claim it’s a value in the context of being multiple
09:46:11 <argoneus> the !! operator is m a -> a ?
09:46:11 <Hafydd> argoneus: that analogy isn't accurate. Just 1 is a value that can only happen to be 1; Nothing is a value that can't happen to be anything.
09:46:16 <Zekka|Sigfig> [] is a ‘type constructor’, and sometimes Haskell programmers call a type constructor a context
09:46:19 <Hafydd> (They're analogous to [1] and [], respectively.)
09:46:22 <kadoban> argoneus: In the meaning used for the list Monad, it's a value in the context of nondeterministic (multiple answers to one question) computation.
09:46:54 <Zekka|Sigfig> (a type constructor is a mapping from types to types that can be pattern-matched over — but that might be too abstract!)
09:46:56 <argoneus> meh
09:47:05 <argoneus> I feel like it'd be easier for me to understand monads if they all weren't super different
09:47:10 <Hafydd> Heh.
09:47:10 <argoneus> or at least they seem different to a noob like me
09:47:18 <Hafydd> What would be the point, then?
09:47:37 <argoneus> yeah but just as I started understanding Maybe
09:47:40 <argoneus> there's still lists and IO haunting me
09:48:02 <argoneus> I'm starting to think of monads as the equivalent of libraries in other languages
09:48:05 <argoneus> but that's probably dumb
09:48:05 <Zekka|Sigfig> argoneus: The idea is that once you understand more than one you will see what’s similar about them
09:48:29 <Zekka|Sigfig> They’re a little more specific than that — a monad is a particular kind of interface
09:48:30 <Hafydd> They'd certainly be hard to understand (to the same extent) if they didn't have their Monadic structure explicitly in common.
09:48:35 <Hafydd> *harder
09:48:55 <Zekka|Sigfig> So a lot of people will think “I have this feature and I want to expose it to people” and they think about it and decide that they like the monad interface
09:49:26 <Zekka|Sigfig> There are lots of libraries that don’t introduce any new monads
09:49:55 <kadoban> argoneus: They are all pretty different. All they really share is Monad, which is just kind of a pattern that can be encoded in the language itself using typeclasses.
09:49:56 <Fuco> I think list monad isn't super useful... I don't think I ever saw a use of that :O
09:50:20 <Zekka|Sigfig> (fwiw, “monad” is occasionally used to refer to a value like [1, 2, 3] or Just 1, but in the more pedantic usage, the monad is the mapping from types to types, plus the operations ‘return’ and (>>=))
09:50:49 <kadoban> If it helps, I think of them as "computation in a context". Maybe is computations that can fail. Either e is computations that can fail with an error. IO is computations that can do arbitrary I/O. [] is nondeterministic computations, etc.
09:51:19 <argoneus> one thing I don't get, Monads are typeclasses, so they are always bound to a data type, no?
09:51:38 <argoneus> I don't get why an interface, or behaviour should be restricted to a datatype
09:51:43 <Zekka|Sigfig> Yeah, so a monad is a certain context (a certain type constructor — a type-to-type mapping that you can pattern match over on the type level) and because you can pattern match over the type, you can see the value inside
09:52:12 <kadoban> argoneus: I'm not sure what you mean by "always bound to a data type" exactly. You use the typeclass by using instances of it, if that's what you mean.
09:52:15 <Zekka|Sigfig> argoneus: Being clear, Monad is a typeclass, but each Monad is a parametric type
09:52:29 <Zekka|Sigfig> So functions that just say “I want a Monad” are very polymorphic
09:52:31 <Zekka|Sigfig> :t mapM
09:52:32 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
09:52:44 <argoneus> hm
09:52:53 <Zekka|Sigfig> That function will work with any Monad and any Traversable you can think of. (for now, think of a Traversable as a thing that acts like a list)
09:53:21 <Zekka|Sigfig> :t mapM `asAppliedTo` (Just)
09:53:22 <pilne> so... if my brain is working right.... if inline-c is "posssible" it should be relatively easy to make an "inline-rust" type package given that rust seems to be a "more inherently compatible" with haskell language?
09:53:23 <lambdabot> Traversable t => (b -> Maybe b) -> t b -> Maybe (t b)
09:53:23 <argoneus> oh, like that
09:53:28 <argoneus> so it can be a string monad, or IO monad, or anything
09:53:30 <argoneus> and it will work
09:53:34 <Zekka|Sigfig> :t mapM `asAppliedTo` (:[])
09:53:36 <lambdabot> Traversable t => (b -> [b]) -> t b -> [t b]
09:53:51 <kadoban> Zekka|Sigfig: Out of curiosity, any idea why weird characters appear in your text sometimes? It looks like a clock and appears apparently randomly in the middle of words.
09:53:52 <argoneus> er, I may have combined two things there
09:54:05 <argoneus> an IO monad or a monad ... applied to a string?
09:54:13 <Zekka|Sigfig> kadoban: I’m using a Mac client that likes using unicode characters to represent quotes and stuff
09:54:38 <Zekka|Sigfig> argoneus: String is [Char], so a string is a particular case of the list monad
09:54:46 <argoneus> oh
09:54:51 <argoneus> right
09:55:07 <argoneus> so just like I have IO Int
09:55:10 <argoneus> I have [] Char
09:55:12 <argoneus> same thing
09:55:13 <Fuco> seems to me it automatically wraps long lines 
09:55:14 <kadoban> Zekka|Sigfig: Well I don't think it's that, my client understands UTF-8 fine (and also they don't appear to be places you'd be actually using quotes or anything … like there's 3 of them in the word "think" above). But doesn't really matter.
09:55:16 <Zekka|Sigfig> Yeah.
09:55:41 <Zekka|Sigfig> kadoban: I really have no idea why that is, then. This client is screwy and I don’t like it
09:55:42 <argoneus> I'm trying to find examples of monads that people use to figure out the use
09:55:48 <argoneus> but I keep finding academic examples :(
09:55:56 <kadoban> Ah okay, yeah no worries I was just wondering if you knew.
09:56:05 <Zekka|Sigfig> argoneus: Using Either or Maybe for error-handling is really common
09:56:14 <pilne> looks like what shows up when someone types emojis and i'm not on a browser that supports them, but i'm guessing emojis are just unicode as well really.
09:56:15 <argoneus> I already kinda figured out Maybe
09:56:21 <Fuco> argoneus: oh there's plenty real monads... look at mpd package, or pulseaudio, or anything which communicates over the network
09:56:23 <argoneus> but that doesn't tell me what to use monads for
09:56:25 <Fuco> they are all implemented as monads
09:56:28 <kadoban> argoneus: Maybe, IO, Either e and [] are pretty good examples.
09:56:32 <Zekka|Sigfig> IO gets used a lot out of necessity
09:56:40 <argoneus> is there some sort of "Network" monad?
09:56:43 <argoneus> though how would that work
09:56:56 <argoneus> network isn't attached to any type
09:57:09 <Fuco> it's all wrappers around IO doing some additional behind-the-scenes work
09:57:24 <Fuco> the "type attachement" you are talking about is simply return value
09:57:34 <argoneus> how much of haskell programming is using monads anyway?
09:57:35 <Fuco> a hypothetical monad "Network Int" would read an integer from the network
09:57:37 <Zekka|Sigfig> argoneus: A lot of people define *really specific* monads that do exactly one thing, which you can then interpret to other monad types
09:57:50 <Fuco> pretty much all of real haskell programming is monads
09:57:54 <argoneus> hm
09:57:57 <Fuco> because IO is a monad and you can't have a program without IO :P
09:57:59 <kadoban> argoneus: Quite a bit uses Monads in at least some part of it.
09:57:59 <Zekka|Sigfig> So you might have a Network monad that guarantees ‘read’ and ‘write’ operations, and then a function Network a -> IO a that interprets it to IO
09:58:11 <pilne> i love programming with burritos! although i often crave nachos too (:
09:58:25 <Fuco> pilne: oh you!
09:58:34 <Fuco> pilne: everyone knows monads are like banana
09:58:35 <Zekka|Sigfig> And another one Network a -> String -> a which simulates network IO
09:58:44 <pilne> sorry... i'm admitting sleep deprivation... as a disclaimer
09:58:45 <Zekka|Sigfig> argoneus: This gets into free monads, though, which is a tricky topic
09:58:54 <kadoban> argoneus: Don't … panic if you're not getting it though, it will make sense eventually (sooner than you think). And it'll probably be … a bit of a let-down when you do, it was for me anyway. There's a lot less there than I was originally looking for, I kept looking for some magic thing I wasn't understanding.
09:59:10 <Zekka|Sigfig> argoneus: Oh, some other common monads are State, Reader, and Writer — imho out of those Writer is easiest to understand
09:59:29 <johnw> free monads + burritoes reminds me of that funny Taco Time video
09:59:44 <Fuco> argoneus: doesn't help that 20 people try to bash their own interpretation of what a monad is into you :D
09:59:49 <johnw> https://vimeo.com/90127834
09:59:53 <Fuco> everyone tries to be super helpful but that ends up being confusing as hell
10:00:01 <argoneus> no no I'm grateful for it
10:00:08 <Fuco> I know but it is still confusing
10:00:13 <Fuco> lot to process
10:00:21 <pilne> from what i'm starting to grok, monads are just a way to handle "impure" things in a "pure" environment... like a... ffi within the language of sorts
10:00:30 <Fuco> sleep on it, re-read the logs :P
10:00:58 <argoneus> so far the only thing I'm confident to say is "a monad is a computation that returns a value eventually"
10:01:45 <the_2nd> I need to keep applying for all parameters [p] on a
10:01:52 <johnw> pilne: that's somewhat true of IO, but it's not a statement about monads in general
10:02:04 <tromp> [] doesn't return a value:(
10:02:04 <the_2nd> foldr seems to be off, since I have to define a -> a -> a for the fold
10:02:11 <the_2nd> but I only want to transform a -> a
10:02:23 <argoneus> isn't [] a value in its own sense?
10:02:24 <kadoban> pilne: I don't think that's really true. I /think/ they were originally researched in this usage to model IO in a pure setting, but otherwise it doesn't apply all that well.
10:02:29 <Ankhers> :t map -- the_2nd 
10:02:30 <lambdabot> (a -> b) -> [a] -> [b]
10:02:31 <pilne> hmm, fair enough johnw, more using/reading.
10:02:44 <the_2nd> Ankhers, I need a as result, not [a]
10:02:45 <pilne> i think i'm going to try and implement a little parser just to get my hands dirty
10:03:23 <the_2nd> my function might for example move the a in space depending on some conditions
10:03:24 <Ankhers> :t foldr
10:03:25 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
10:04:01 <Ankhers> the_2nd: the first argument of the function is the current item in your Traversable. The second argument is the current accumulated value.
10:04:09 <pilne> MyParser:: [What My Girlfriend Says] -> [What She Wants Me To Understand] sounds like a good project no? (:
10:04:11 <the_2nd> ah, I misread the function def as ( a -> a -> a)
10:04:17 <the_2nd> I'll give it another try
10:04:48 <gabbiel> hello
10:05:58 <gabbiel> anyone know how "fibs = 0 : 1 : zipWith (+) fibs (tail fibs)" works?
10:06:09 <Fuco> pilne: no need to mix girlfriends into the discussion
10:06:40 <Nadrieril> gabbiel: it works quite well ^^
10:06:52 <Nadrieril> gabbiel: do youknow about lazy evaluation ?
10:06:53 <gabbiel> but how, I can't figure it out
10:07:11 <gabbiel> yeah, a little bit
10:07:20 <mnoonan> try plugging the left-hand side of that equation into itself wherever you see fibs, then simplify zipWith and tail. That'll show how the next number is generated. Then repeat until enlightenment :)
10:07:22 <pilne> fair enough, although her desire to make some awesome video games is what got me back into programming, and lead to me finding haskell (: although lisps still tempt me a lot.
10:07:54 <gabbiel> ok, give me a sec
10:08:01 <pikajude> is there a tables-like library that isn't deprecated and supports auto-incrementing keys?
10:08:17 <Gurkenglas> How do I turn a context into a lens?
10:08:17 <Nadrieril> gabbiel: the thing is that the whole list is never computed, instead, when you try to access its elements, it will evaluate one by one their value
10:09:05 <Nadrieril> so you get 0, then 1, then you have to compute the first value of "zipWith ...", which happens to be fib[0] + fib[1], and we just saw what their value was !
10:09:16 <Nadrieril> so we get 2, and we continue
10:10:16 <mnoonan> > 0 + 1
10:10:18 <lambdabot>  1
10:10:21 <mnoonan> ^^ Nadrieril :)
10:10:35 <Nadrieril> whops x)
10:10:43 <nitrix> Hi. What's the point of the second type in `State` if `modify` enforces `()` ?
10:10:48 <Nadrieril> I am used to the usual 1,1,2,3,5,... fibonacci sequence
10:11:05 <Nadrieril> *so we get 1, and continue
10:11:11 <nitrix> I tried declaring a function with type :: State Int String, but then I cannot use `modify`.
10:11:43 <nitrix> It just seems contradictory to me to have that mechanism in place if all the methods of the State class doesn't preserve the value.
10:11:59 <mnoonan> nitrix: think of "State Int" as one part that means "a computation using a state of type Int"
10:12:18 <mnoonan> so "State Int t" is a computation that uses an Int state, and produces a value of type t
10:12:23 <Nadrieril> gabbiel: for example "thing = 0 : zipWith (+) thing (tail thing)" would only produce a 0, and then hang, because it needs thing[1] to calculate thing[1], so it cannot work
10:12:28 <Zekka|Sigfig> argoneus: Well, there doesn’t actually have to be a value in the end
10:12:39 <Zekka|Sigfig> data HalfMaybe a = Nothing
10:12:43 <Zekka|Sigfig> This is a monad too
10:12:44 <mnoonan> modify just would change the Int, not convert it to a String
10:12:49 <argoneus> ._.
10:12:59 <geekosaur> nitrix: modify theState >> return ""
10:13:12 <geekosaur> sorry
10:13:26 <Zekka|Sigfig> The operations look about the same way they do for Maybe, minus one case
10:13:31 <geekosaur> modify (+1) >> return "" -- a valid implementation of State Int String that uses modify
10:14:10 <argoneus> I just realized that map is the same as fmap, except you replace f with []
10:14:13 <argoneus> damn
10:14:20 <Zekka|Sigfig> argoneus: To be totally accurate, a monad is just a parametric type that supports (>>=) :: m a -> (a -> m b) -> m b and return :: a -> m a
10:14:34 <bergmark> nitrix: to actually run the State computation you call runState, which gives you the end state
10:14:45 <Zekka|Sigfig> (and as a caveat, there are some laws that look like the functor laws)
10:14:57 <argoneus> Zekka|Sigfig: yeah I got this but ... yeah
10:14:59 <Zekka|Sigfig> People usually think of (>>=) as a flavor of fmap
10:15:08 <argoneus> monads seem like the sort of think that's super easy once you know it
10:15:11 <argoneus> but explaining it is hard?
10:15:13 <Nadrieril> ^
10:15:14 <argoneus> thing*
10:15:15 <Zekka|Sigfig> Yeah
10:15:33 <Zekka|Sigfig> Do you think you understand functors? This might help: x >>= f = join (fmap f x)
10:15:38 <Nadrieril> like most abstract things, I would say
10:15:46 <gabbiel> still can't figure how the process goes
10:15:50 <Zekka|Sigfig> So monads are a type that support fmap plus a funcion called join, which looks like this: join :: m (m a) -> m a
10:16:00 <Zekka|Sigfig> ‘join’ is a way of generalizing ‘concat’
10:16:15 <nitrix> I see. The >> return "" was enough to make it clear to me. Thanks geeosaur. My error wasnt due to modify but no return.
10:16:25 <argoneus> um
10:16:25 <Zekka|Sigfig> er, monads are parametric types that support*
10:16:41 <c_wraith> explaining monads is easy. the problem is believing the simple explanation. 
10:16:49 <argoneus> that just maps a function to x and joins the two lists or values or whatever?
10:17:00 <Zekka|Sigfig> argoneus: Well, it joins the *n* lists for lists
10:17:13 <argoneus> n?
10:17:16 <Zekka|Sigfig> For Maybe join looks like this: join (Just (Just x)) = Just x; join _ = Nothing
10:17:17 <Fuco> for lists join = concat, yes
10:17:18 <Zekka|Sigfig> :t concat
10:17:19 <lambdabot> Foldable t => t [a] -> [a]
10:17:38 <mnoonan> > join [[1,2,3],[4,5],[6,7,8]]
10:17:40 <lambdabot>  [1,2,3,4,5,6,7,8]
10:18:09 <gabbiel> i don't get the fuzz about monads
10:18:40 <Gurkenglas> Can you zoom into a context?
10:18:51 <gabbiel> take something out of a box, do something in it, and put it back in
10:19:13 <argoneus> gabbiel: that's wrong apparently
10:19:24 <Gurkenglas> The doing something with it usually makes it come out already in a box again
10:19:32 <c_wraith> that's accurate enough when there is a box. 
10:19:51 <c_wraith> many monad instances are for types that aren't any kind of box. 
10:19:54 * hackagebot servant 0.4.4.6 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.4.4.6 (jkarni)
10:19:56 * hackagebot servant-cassava 0.4.4.6 - Servant CSV content-type for cassava  https://hackage.haskell.org/package/servant-cassava-0.4.4.6 (jkarni)
10:19:58 * hackagebot servant-client 0.4.4.6 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-client-0.4.4.6 (jkarni)
10:20:30 <c_wraith> for instance, State isn't a box. it contains no value to remove. 
10:21:06 <gabbiel> gurkenglas : well, technically, but still, its simpler
10:21:19 <Zekka|Sigfig> I mean, you can have a monad where there’s not only not a box, but not even a value
10:21:23 <geppettodivacin> State feels like one of the more obvious box analogies to me.
10:21:29 <Zekka|Sigfig> data MaybeMinusHalf a = Nothing
10:21:40 <gabbiel> I've never worked with the State type
10:21:42 <c_wraith> geppettodivacin, then you don't understand State 
10:21:46 <geppettodivacin> You pass a box with the state along from one function to the next until something needs to use it.
10:21:48 <Zekka|Sigfig> data MaybeMinusTwoHalves a = {- left blank for artistic purposes -}
10:22:06 <geppettodivacin> Internally, it works differently, but on the surface level it makes sense.
10:22:28 <Gurkenglas> c_wraith, if [] is a box, then so is Reader, and if Either is a box, then so is Writer, and then State is also one :D
10:22:55 <Zekka|Sigfig> I mean, they’re all boxes if you redefine box to mean “monad"
10:23:11 <c_wraith> Gurkenglas, that first part doesn't follow. [] has nothing to do with reader
10:23:14 <argoneus> monad to me just seems like a series of computations that can have different results between steps
10:23:21 <argoneus> >_>
10:23:40 <argoneus> and depending on the monad the computations do different things
10:23:42 <mnoonan> It seems like the box analogy is fairly legit when you have a function unbox :: M t -> t
10:23:44 <c_wraith> Gurkenglas, also, writer is (,), not Either
10:23:45 <Zekka|Sigfig> argoneus: A lot of people like to talk about monads as a way of composing computations
10:23:50 <Gurkenglas> c_wraith, [] is pretty much Reader Int, if you remove the Nil part - and if [] is a box, then so is [] restricted to infinite streams
10:23:55 <Zekka|Sigfig> (>>=) is usually considered a sequencing operation
10:24:18 <argoneus> question
10:24:39 <gabbiel> what have you guys programmed in haskell?
10:24:45 <argoneus> if in python I do something like mystring.strip().split().join(" ").print().lowercase()
10:24:46 <Gurkenglas> Either e "just adds some extra values" and so does Writer w :D
10:24:48 <argoneus> could this be a monad?
10:24:50 <Zekka|Sigfig> using the flipped >>=: f =<< g =<< x is a lot like f g x without monads
10:24:57 <argoneus> or rather
10:24:59 <argoneus> an application of one
10:25:11 <Zekka|Sigfig> argoneus: You could intersperse monads into that a couple ways
10:25:27 <Gurkenglas> Because it says join?
10:25:46 <Zekka|Sigfig> You could make each of those a monadic operation and turn it into s >>= strip >>= split >>= join “” >>= print >>= lowercase
10:26:36 <argoneus> yeah that's what I meant
10:26:38 <c_wraith> Gurkenglas, you described how functions form a monad there, not how [] does. and yes, Reader is the function monad. 
10:26:41 <argoneus> doesn't IO do that kind of stuff?
10:26:57 <Gurkenglas> Huh you're right.
10:26:58 <argoneus> readline >>= putstrln
10:27:12 <Zekka|Sigfig> argoneus: Yeah, if you were to make e.g. strip an IO operation, then that’d be the usage
10:27:28 <Zekka|Sigfig> s >>= askUser >>= putStrLn
10:27:44 <Zekka|Sigfig> askUser might print s and then get a new string from the user
10:27:50 <Ankhers> print . lowercase . join "" . split $ strip myString
10:28:08 <gabbiel> zekka|sigfig: print returns ()
10:28:08 <Zekka|Sigfig> Another common usage would be to make it possible for one of those intermittent functions to throw an error
10:28:26 <Zekka|Sigfig> gabbiel: Yeah, and?
10:28:40 <gabbiel> hpw can you lowercase a ()
10:29:05 <Zekka|Sigfig> gabbiel: Oh, whoops. I directly translated his code, forgetting that there’s already a Haskell operation by that name
10:29:30 <argoneus> gabbiel: askuser print s and get a new string?
10:29:33 <argoneus> isn't that a sideeffect?
10:29:35 <argoneus> er, Zekka|Sigfig sorry
10:29:47 <Zekka|Sigfig> I just wanted to show him how his sequence of operations, if you assume they all result in a monadic type and return a useful value, could be written with >>=
10:30:01 <Zekka|Sigfig> argoneus: Yeah, askUser probably has this type: String -> IO String
10:30:28 <argoneus> but askuser can only do one thing, no?
10:30:32 <Zekka|Sigfig> The IO type is a marker indicating that we needed to consult the outside world
10:30:55 <Zekka|Sigfig> argoneus: Well, it can do whatever it wants with the outside world, because it results in a value in context IO
10:31:10 <argoneus> hmm
10:31:14 <Zekka|Sigfig> Because Haskell provides primitives with types like IO String that represent talking to the outside world
10:31:39 <Zekka|Sigfig> The only reason IO is allowed to talk to the outside world is because Haskell provides functions that talk to the outside world and have IO in their type
10:31:50 <gabbiel> ok, what next after reading "learn you a haskell for the greater good"
10:32:12 <peddie> @where cis194
10:32:12 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
10:32:15 <Zekka|Sigfig> :t getLine
10:32:16 <lambdabot> IO String
10:32:18 <peddie> gabbiel: ^^
10:32:24 <Ankhers> @where learnhaskell -- gabbiel 
10:32:24 <Zekka|Sigfig> :t putStrLn
10:32:24 <lambdabot> https://github.com/bitemyapp/learnhaskell
10:32:26 <lambdabot> String -> IO ()
10:32:45 <peddie> thAnkhers
10:32:57 <gabbiel> introduction?
10:33:09 <Zekka|Sigfig> So, IO has runtime system magic that lets you talk to the outside world — ops like (>>=) just let you interoperate with the values like “getLine” which have weird types
10:33:28 <EvanR> ops like getChar
10:33:50 <gabbiel> i'll still check it out
10:33:51 <nitrix> It may appear magical but it really isn't.
10:34:11 <Ankhers> gabbiel: The problem with LYAH is that there are no exercises. cis194 allows you to practice what you have learned.
10:34:17 <gabbiel> ohh
10:34:26 <nitrix> Not until you reach the compiler intrinsics. From the language's perspective, purity is preserved.
10:35:02 <Zekka|Sigfig> I’m just trying to say, it’s not important how getLine is implemented — IO only lets you do clever stuff that talks to the outside world because Haskell provides clever primitives that talk to the outside world, and it uses Monad as an interface to operate on those primitives
10:35:51 <EvanR> accursedUnutterablePerformIO, magic?
10:36:02 <gabbiel> do I need to learn C if I wanna make any useful software alongside haskell?
10:36:04 <Zekka|Sigfig> If Haskell wanted it could define getLine :: String instead, but that would break Haskell’s expectation that if you say “this name is this value”, looking at that name will always get you that value
10:36:12 <Nadrieril> gabbiel: definitely not
10:36:17 <Zekka|Sigfig> gabbiel: It wouldn’t hurt to learn C but I never needed to write my own C to use Haskell
10:36:37 <Nadrieril> you can make lots of useful software using Haskell
10:36:46 <Nadrieril> an by "lots of", I mean "any"
10:37:16 <monochrom> see my IO tutorial: http://www.vex.net/~trebla/haskell/IO.xhtml
10:37:42 <pilne> my "way over my head" / "long term goal" is to make a nice 3D game engine in haskell (: with awesome support for blender and other open-source tools.
10:37:52 <volhovm> hi guys, please remind me what notation `let ~(a, b) = fs` means
10:38:10 <Zekka|Sigfig> Some things you don’t need to write your own C for, where you might expect you would: networking, file IO, most image processing, a lot of audio processing, 3D rendering, GPU-accelerated math
10:38:11 <monochrom> the ~ there marks an irrefutable pattern
10:38:20 <EvanR> Zekka|Sigfig: im not sure what "if haskell wanted it could define getLine :: String" is trying to say ;)
10:38:32 <monochrom> however, "let" itself already has an implicit ~. you have a redundancy.
10:38:59 <Zekka|Sigfig> EvanR: I just mean that IO being a monad is kind of arbitrary — you could give it another type marker, or no type marker at all, and the language will still support those operations
10:39:00 <monochrom> an irrefutable pattern delays the pattern matching
10:39:16 <volhovm> I've found this code in base sources
10:39:20 <Zekka|Sigfig> the monad interface doesn’t have anything to do with what actual IO operations are available
10:39:27 <EvanR> Zekka|Sigfig: what operation is getLine :: String supporting?
10:39:50 <ReinH> EvanR: one that has nothing to do with monads
10:39:56 <Zekka|Sigfig> EvanR: It’s a version of getLine that also supports evil with a capital E.
10:40:07 <monochrom> base is written by fallible humans, too
10:40:09 <EvanR> ReinH: i was trying not to say that since ... String is a monad
10:40:10 <ReinH> oh, getLine :: String. I don't see how that's relevant.
10:40:18 <volhovm> ok, thanks
10:40:19 <EvanR> right
10:40:24 * hackagebot servant-docs 0.4.4.6 - generate API docs for your servant webservice  https://hackage.haskell.org/package/servant-docs-0.4.4.6 (jkarni)
10:40:26 * hackagebot servant-jquery 0.4.4.6 - Automatically derive (jquery) javascript functions to query servant webservices  https://hackage.haskell.org/package/servant-jquery-0.4.4.6 (jkarni)
10:40:27 <Zekka|Sigfig> You could implement it almost exactly the same way getLine :: IO String is impemented, except you don’t have a type marker
10:40:28 * hackagebot servant-server 0.4.4.6 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.4.4.6 (jkarni)
10:40:30 * hackagebot servant-examples 0.4.4.6 - Example programs for servant  https://hackage.haskell.org/package/servant-examples-0.4.4.6 (jkarni)
10:40:32 * hackagebot servant-blaze 0.4.4.6 - Blaze-html support for servant  https://hackage.haskell.org/package/servant-blaze-0.4.4.6 (jkarni)
10:40:40 <EvanR> Zekka|Sigfig: so back to "if haskell wanted it could define that" ... 
10:40:42 <gabbiel> where'd you guys learn networking?
10:40:50 <EvanR> with what, unsafePerformIO ?
10:41:01 <EvanR> it wouldnt even work
10:41:06 <monochrom> I learned networking near network cables
10:41:09 <Zekka|Sigfig> I’m just trying to dispel the assumption that “oh, the IOness must come from being a monad!”
10:41:09 <ReinH> EvanR: Why do you think the alternative to IO being a monad is getLine :: String?
10:41:16 <Zekka|Sigfig> ReinH: He doesn’t think that
10:41:27 <EvanR> ReinH: i was responding to Zekka|Sigfig's theory
10:41:54 <monochrom> I have a feeling that all of you are violently agreeing
10:42:30 <volhovm> @monochrom: one more time, is ~ the opposite of !? it seems like pattern matching is lazy by default so i'm not really getting the idea
10:42:30 <lambdabot> Unknown command, try @list
10:42:37 <monochrom> yes
10:42:50 <monochrom> I mean yes to the first question.
10:43:08 <monochrom> "case" is eager by default. "let" is lazy by default.
10:43:12 <Zekka> Whoa, my computer just pitched a massive fit
10:43:17 <Zekka> I'll be back on my other alias in a sec
10:43:31 <monochrom> "f (x:xs) = ..." is a special case of "case"
10:43:37 <Zekka> Being clear, I'm not saying that's a good way to define it -- it's horrible and compiler optimizations would run roughshod over it -- and that's the least of its problems
10:43:50 <EvanR> im not sure you COULD define it like that
10:44:00 <EvanR> as satisfy the expectations
10:44:02 <EvanR> and*
10:44:05 <Zekka|Sigfig> If you control the runtime system you can define it however you want
10:44:14 <Zekka|Sigfig> I’m just saying, the actual IO does not come from it being a monad
10:44:22 <Zekka|Sigfig> there is not a part of Monad that addresses the problem of IO
10:44:35 <volhovm> ok, got it
10:44:48 <monochrom> :)
10:44:55 <gabbiel> explain why "f (n + 2)" even works, + is not even a constructor
10:45:08 <ReinH> gabbiel: It doesn't work.
10:45:15 <ReinH> Not unless you enable a deprecated extension
10:45:31 <ReinH> And then it works because it is a specific addition to the syntax of pattern matches.
10:45:34 * hackagebot servant-lucid 0.4.4.6 - Servant support for lucid  https://hackage.haskell.org/package/servant-lucid-0.4.4.6 (jkarni)
10:45:36 * hackagebot servant-mock 0.4.4.6 - Derive a mock server for free from your servant API types  https://hackage.haskell.org/package/servant-mock-0.4.4.6 (jkarni)
10:45:44 <javjarfer> hi there! Anyone knows how to use the function "fdToHandle"? Everytime i use it throws the following exception "*** Exception: fdType: unsupported operation (unknown file type)"
10:46:17 <EvanR> the fd might be invalid
10:46:49 <ReinH> pun not indented.
10:47:19 <Nadrieril> :D
10:47:27 <monochrom> hehehe
10:47:34 <EvanR> what
10:47:39 <monochrom> "addition"
10:47:47 <EvanR> oh
10:48:26 <Zekka|Sigfig> If you miss n+2 patterns, there’s always room to define data Number = Zero | Succ Number
10:48:35 <Zekka|Sigfig> Don’t worry, it’ll perform fine. You know what you’re doing. You’re an expert.
10:49:05 <csd_> how could i use quickcheck to test a function that, given a poker hand, scores it for you?
10:49:27 <ReinH> csd_: you could compare it against some other implementation as a specification
10:50:09 <javjarfer> EvanR, is a file descriptor directly returned by "inotify_init"
10:50:11 <Zekka|Sigfig> I wrote a program that does that a long time ago! I’d let you test against mine but I don’t think I have it around right now
10:50:32 <ReinH> This is often done when, e.g., you have an implementation that is correct but not perfmant enough and you want to test an optimized version.
10:50:37 <ReinH> *performant
10:51:02 <Zekka|Sigfig> I did what ReinH is describing when I ported spj’s prettyprinter to Java
10:51:06 <csd_> ReinH: yeah i was more wondering whether there might be some testable invariants i'm not seeing
10:51:22 <javjarfer> EvanR, also if you open it using fdToHandle' works in a certain way.
10:51:28 <ReinH> csd_: well, you could test that a hand is scored the same regardless of card order
10:51:37 <ReinH> unless you are already using an unordered structure
10:51:41 <ReinH> but I don't see many.
10:51:48 <csd_> yeah, ok
10:51:51 <csd_> thanks
10:52:02 <ReinH> csd_: you could construct specific hands like one pair and then test that they are scored correctly
10:52:16 <Zekka|Sigfig> I remember when I was exposed to the poker hand exercise — the teacher’s mission was to demonstrate to us that all programs contain bugs
10:52:19 <csd_> but that wouldn't require quickcheck
10:52:26 <csd_> thats how i'm going to test i think
10:52:35 <ReinH> property $\(OnePairOnly hand) -> score hand == OnePair or w/e
10:52:36 <Zekka|Sigfig> he said that he would not score it on correctness because no matter what we would all get at least one answer wrong
10:52:49 <javjarfer> EvanR, there are 3 functions that should do the same, "mkHandleFromFD", "fdToHandle", "fdToHandle' " but they have an important lack of documentation
10:52:49 <Zekka|Sigfig> I was so smug when mine worked perfectly.
10:52:50 <ReinH> csd_: I mean construct specific restricted arbitrary  hands
10:53:22 <ReinH> javjarfer: what operating system?
10:53:35 <csd_> ReinH: I see. I dont know the QC DSL that well so that might be a good option after i look into things further
10:53:47 <javjarfer> ReinH, linux.
10:54:01 <EvanR> javjarfer: im reading the stat man page, theres like 7 kinds of FDs on linux, and inotify might not be of a kind recognized by the standard lib
10:54:01 <ReinH> csd_: look at https://hackage.haskell.org/package/QuickCheck-2.8.1/docs/Test-QuickCheck-Modifiers.html
10:54:22 <EvanR> inotify might not return one of a recognized kind
10:54:26 <csd_> ok
10:54:48 <EvanR> you can use C to check 
10:55:12 <javjarfer> EvanR, oh i see so the other function mkHandleFromFD stands for the other that aren't directly recognized?
10:56:02 <EvanR> no, i dunno
10:56:09 <monochrom> I would not be dumb enough to try to demonstrate that all programs have bugs.
10:56:21 <monochrom> because at least my programs don't. :)
10:56:44 <EvanR> check the base source code for those operations
10:57:51 <EvanR> javjarfer: i see https://hackage.haskell.org/package/base-4.5.0.0/docs/src/System-Posix-Internals.html (might be out of date though) knows about 4 FD types
10:58:20 <Zekka|Sigfig> monochrom: Yes, and unlike my coworkers, I write code that’s both elegant and performant!
10:58:29 <Zekka|Sigfig> That’s why I don’t need to write comments or unit tests
10:58:41 <Zekka|Sigfig> (replace unit tests with “sanity checks” if you don’t like unit tests)
10:58:58 <EvanR> wastes of time ;)
10:59:08 <EvanR> if it compiles its good, if it boots up its perfect
10:59:51 <javjarfer> EvanR, thanks I will read about that, and also try to improve that doc with what I found.
10:59:53 <monochrom> more wastes of time. don't even compile or run. just hang it on the wall for looking :)
11:00:16 <Zekka|Sigfig> When someone tells me their code is “elegant” I take it as a bit of a warning sign — several of the guys I know who take that stance have communication issues that they don’t know about yet
11:00:56 <EvanR> dunning-kruger
11:01:22 <Zekka|Sigfig> a lot of the time it seems like “elegant” means that they weren’t interested in solving the problem as stated, or that they think their design is so easy to understand they don’t need to document it
11:01:58 <ReinH> monochrom: http://www.waterfall2006.com/martin.html
11:02:47 <ReinH> Zekka|Sigfig: or that they failed to account for edge cases
11:03:09 <Zekka|Sigfig> ReinH: That’s usually what I mean by the first one
11:03:14 <ReinH> ah yes
11:03:37 <Zekka|Sigfig> It’s admirable to greatly simplify the problem, but often that means throwing out important details
11:03:57 <Zekka|Sigfig> if I was writing a board game and wanted to make people write AI, I’d probably be pleased if they came up with Dijkstra’s as a way to optimize around what the AI did
11:04:25 <Zekka|Sigfig> If I came up with a situation where the AI can get a massive bonus by taking an unintuitive route (negative edge weights) I would get pissed if they refused to implement it because it meant they couldn’t use dijkstra’s any more
11:04:27 <dgpratt> whenever someone makes a critical comment about what that other guy does, I can't help but try to imagine what it looks like from the perspective of that other guy -- this is doubly so when I'm the one making the critical comment :)
11:04:35 <Zekka|Sigfig> dgpratt: Well *my* code is fine.
11:04:42 <dgpratt> :)
11:04:43 <Zekka|Sigfig> It’s the other guy’s fault.
11:05:13 <EvanR> my code is even more pure and elegant, there is none
11:05:29 <dgpratt> lol
11:05:35 * hackagebot casadi-bindings 2.4.1.6 - mid-level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-2.4.1.6 (GregHorn)
11:05:37 <Zekka|Sigfig> I don’t think it’s a secret that the guy I’m complaining about who writes elegant and clever code is me about a year ago
11:06:00 <Zekka|Sigfig> About a year ago I was complaining about another guy who hardcoded all his special cases and didn’t care about abstraction until it was actually wrecking his program
11:06:03 <Zekka|Sigfig> That guy was also me
11:06:12 <koala_man> haha
11:06:44 <EvanR> next year the day you realize all the mistakes and get serious, they will promote you to middle management and replace you with an unskilled entry level
11:06:44 <ReinH> Zekka|Sigfig: <3
11:06:58 <Zekka|Sigfig> As of late I’ve been writing my projects in Java with the hope that all the other dudes I know who are interested in the stuff I work on will be able to understand it
11:07:06 <koala_man> as an irrelevant tangent, elegant and optimal is often not what you want in a board game AI. personas and carefully calculated errors can make games more fun for humans
11:07:11 <josephle> EvanR: does it count as a replacement if you're managing your replacement?
11:07:12 <Zekka|Sigfig> So in a year I’ll be mad at the guy who picks technologies based on popularity instead of design quality
11:07:20 <dgpratt> Zekka|Sigfig, funny that I was just thinking that I've come to the point in my career where I think that maybe...just maybe...it's possible to have too much abstraction
11:07:58 <dgpratt> but I'm not sure
11:08:22 <Zekka|Sigfig> dgpratt: When I was really into Haskell I wrote projects very elaborately using a lot of clever library features and abstractions
11:08:40 <Zekka|Sigfig> I reached a turning point when I was returning to an old project and realized that since I hadn’t worked on it for about three months I had no idea what I’d been doing
11:08:55 <EvanR> josephle: of course the role of this manager is to give the coders enough breathing room to realize their creative talents
11:09:11 <EvanR> "we know you can do it, good luck"
11:09:36 <EvanR> "lets see youre awesome design skills as per your resume and interview results"
11:09:37 <josephle> EvanR: not enough vision. You have to take away breathing room from other managers' coders
11:09:44 <dgpratt> when it comes to Haskell, the good thing is I'm pretty sure I don't know it well enough to over use its abstractive power
11:09:45 <josephle> how else will you move up in this cutthroat environment
11:09:53 <Zekka|Sigfig> So lately I’ve been taking a luddite route and defaulting to things I can phrase in a very conventional OOP way
11:10:01 <dedgrant> Abstraction always has a cost. Rather, if looking to minimize certain holistic costs, pinning abstraction constraints can be incredibly limiting. Be adaptable. :)
11:10:12 <Zekka|Sigfig> I haven’t screwed myself over by doing this quite yet, but I think I will soon
11:10:45 <EvanR> never underestimate the cost of continuing your meaningless existence
11:11:26 <monochrom> in a meaningless universe, too.
11:12:12 <monochrom> a meaningless consumer runs into a meaningless producer...
11:12:36 <ReinH> continuing or not continuing is arbitrary and meaningless so you may as well continue
11:13:17 <EvanR> but at what cost
11:13:26 <monochrom> at a meaningless cost :)
11:13:42 <ReinH> indeed
11:13:53 <EvanR> wow this form of argument is so powerful
11:14:05 <kaiyin> how do you import just a typeclass?
11:14:08 <ReinH> Not really.
11:14:17 <kaiyin> for example, Monoid typeclass from Data.Monoid
11:14:29 <monochrom> "import ModuleName()" imports just the type classes. but all of them.
11:14:30 <ReinH> kaiyin: you can import all typeclasses with import Foo () but you can't choose which to import.
11:14:48 <ReinH> kaiyin: if you import a module, you always import all typeclasses.
11:14:49 <kaiyin> ok, thanks.
11:15:24 <EvanR> and instances
11:15:39 <monochrom> ah, yeah, forgot that one
11:15:47 <Zekka|Sigfig> FWIW I’m still guilty of getting too clever — I reinvented Pipes pretty faithfully afaict in Java
11:16:03 <ReinH> If an instance is defined for a type that is not in scope, is that instance technically imported?
11:16:34 <monochrom> actually we have it all wrong. "import Module.Name()" imports just all instances.
11:16:38 <Zekka|Sigfig> I don’t know for sure that it’s Pipes, but it’s a monad thingy that’s got your fancy yielding and your fancy suspending and your fancy trampolining and your fancy codensitying all in one go
11:16:45 <Zekka|Sigfig> I think I’m smart *now*, but boy am I going to hate me later!
11:17:19 <ReinH> Zekka|Sigfig: and all this in a language without kinds
11:17:29 <frontendloader> There's a good quote out there about when you feel clever while programming. You can't write code that is also clever and correct, but you can write code that is below your skill level and correct.
11:17:35 <Zekka|Sigfig> ReinH: Yeah, I don’t have like a “Monad” class or anything
11:17:40 <frontendloader> So if you feel you're being clever, you may need to re-evaluate.
11:17:51 <ReinH> frontendloader: do you know who this quote is from?
11:18:04 <frontendloader> I bet it gets mis-attributed to Dennis Ritchie
11:18:12 <Zekka|Sigfig> That would be an appropriate person to misattribute it to!
11:18:13 <frontendloader> but I'm not sure who
11:18:33 <Zekka|Sigfig> I’ve been going through one of my old projects lately and ripping out all the stuff I don’t understand now, in the spirit of that
11:18:41 <kadoban> There's one about code being twice as hard to debug as it is to write, so if you're writing code as cleverly as you can, you'll have no chance to debug it when it breaks.
11:18:53 <frontendloader> Thats it I think kadoban 
11:19:30 <EvanR> in ruby i always had to build in debugging scaffolding
11:19:40 <ReinH> frontendloader: because there's actually an interesting effect: you have so much capability for solving problems, and the people using your software will be so forgiving of errors. If you want to solve harder problems without becoming more competent, you have to find less discerning customers. And vice versa.
11:20:17 <ReinH> alternatively, you can release software that is less useful but which more people will like.
11:20:27 <Ab123> can anyone mentor me for Gsoc2016?
11:21:08 <Zekka|Sigfig> Ab123: What kind of project do you have? I wouldn’t trust me to mentor anyone but there are probably other people here who can
11:22:37 <Ab123> i would like to work for the project proposed by organisation
11:23:05 <Zekka|Sigfig> Oh, so ideally someone would say “you sound cool, work on what we’re working on”?
11:23:28 <Ab123> yupp!
11:24:47 <Ab123> <Zekka|Sigfig>can you please guide me through?
11:25:23 <Zekka|Sigfig> Ab123: I can list some of the people I know who currently have Haskell jobs if you want — maybe they’ll be able to refer you to someone better
11:25:47 <Ab123> okay that would be great 
11:25:50 <Zekka|Sigfig> The company I work for currently has Haskell but I’m not on that team and I don’t know that we would recruit someone just for the summer
11:26:04 <mpickering> Ab123, I did it the last two years
11:26:21 <Ab123> ohh thats nic @ mpickerking
11:26:28 <mpickering> the best way by far is to find a project you are interested in and start writing patches now
11:26:30 <Ab123> can you help me out?
11:26:31 <Zekka|Sigfig> Oh, ask him! I was going to suggest bugging Cale, since he likes helping people and he’s active here and works in Haskell at the moment
11:26:47 <mpickering> build up a good relationship with the maintainers of whichever project you choose
11:26:49 <ReinH> I think there's a GSoC mailing list or similar?
11:26:53 <mpickering> and then write a good proposal
11:27:05 <mpickering> ReinH: There is but no one has ever posted anything to it
11:27:14 <Ab123> where do i get the list of mentors and projects?
11:28:16 <mpickering> There isn't really one, but there are some here of varying quality
11:28:18 <mpickering> https://ghc.haskell.org/trac/summer-of-code/report/1
11:29:12 <Ab123> okay ty..
11:29:22 <gabbiel> :t id
11:29:24 <lambdabot> a -> a
11:29:30 <mpickering> there's also #haskell-gsoc
11:30:02 <gabbiel> whats that
11:30:40 <zachk> is there something like <php> tags for haskell? so I can just include haskell inside a document in certain parts? 
11:30:50 <Ankhers> > id 12 -- gabbiel 
11:30:52 <lambdabot>  12
11:31:12 <Zekka|Sigfig> zachk: Yesod provides a family of templating languages that might do what you want
11:31:19 <maerwald> zachk: you want to write haskell inside a html document?
11:31:22 <gabbiel> > return ()
11:31:24 <lambdabot>      No instance for (Show (m0 ()))
11:31:24 <lambdabot>        arising from a use of ‘show_M38919150506501169727788’
11:31:24 <lambdabot>      The type variable ‘m0’ is ambiguous
11:31:40 <byorgey> zachk: what kind of document?  Maybe literate Haskell (.lhs) is what you are looking for?
11:31:48 <Zekka|Sigfig> https://hackage.haskell.org/package/shakespeare <- here is their package
11:32:20 <gabbiel> > id id
11:32:22 <lambdabot>      No instance for (Typeable a0)
11:32:23 <lambdabot>        arising from a use of ‘show_M690078864081624337427813’
11:32:23 <lambdabot>      In the expression:
11:32:36 <Zekka|Sigfig> http://www.yesodweb.com/book/shakespearean-templates <- a guide to using it. (Note: it’s more restricted than just “arbitrary haskell in arbitrary html”)
11:32:57 <gabbiel> > 4
11:32:59 <lambdabot>  4
11:33:54 <gabbiel> > if length "I keep doing this" > 0 then "will I get banned" else "will I not"
11:33:56 <lambdabot>  "will I get banned"
11:34:29 <byorgey> gabbiel: you won't get banned.  you might be politely asked to talk to lambdabot in a private message
11:34:58 <zachk> maerwald, latex atm, but any text document in general 
11:35:04 <EvanR> gabbiel: return () :: [()]
11:35:24 <gabbiel> > return () :: IO
11:35:27 <lambdabot>      Expecting one more argument to ‘IO’
11:35:27 <lambdabot>      Expected a type, but ‘IO’ has kind ‘* -> *’
11:35:27 <lambdabot>      In an expression type signature: IO
11:35:30 <zachk> gabbiel: /msg lamdabot > 2 + 2 
11:35:33 <EvanR> IO ()
11:35:56 <argoneus> can you think of monads as a bunch of functions that work with an encapsulation of some sort of state or such?
11:36:19 <gabbiel> > return "a"  :: [Char]
11:36:20 <Zekka|Sigfig> argoneus: I’d say it’s closer to how they work in practice, but it’s not an accurate definition
11:36:21 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘[Char]’
11:36:21 <lambdabot>      In the first argument of ‘return’, namely ‘"a"’
11:36:21 <lambdabot>      In the expression: return "a" :: [Char]
11:36:37 <Zekka|Sigfig> there are monads you can’t describe that way, although a lot of common monads can be written using the State monad, which does work that way
11:36:39 <EvanR> return 'a'
11:36:45 <zachk> there is alot of ways to think of monads 
11:36:49 <argoneus> meh
11:36:49 <gabbiel> but its a list of chars
11:36:56 <argoneus> I kinda understand different kinds of monads and how to use them
11:37:00 <argoneus> but I don't understand the generalized idea
11:37:06 <EvanR> gabbiel: return 'a' returns a list of Chars
11:37:12 <Zekka|Sigfig> argoneus: How confident are you about functors?
11:37:14 <ReinH> the generalized idea is
11:37:17 <zachk> a way to sequence computations that are minature languages is one way 
11:37:19 <ReinH> :t (>>=)
11:37:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:37:22 <ReinH> :t return
11:37:23 <lambdabot> Monad m => a -> m a
11:37:23 <ReinH> and their laws
11:37:25 <monochrom> argoneus: not always some sort of state
11:37:28 <maerwald> :t join
11:37:30 <lambdabot> Monad m => m (m a) -> m a
11:37:32 <argoneus> Zekka|Sigfig: I can tell you the definition
11:37:32 <Ankhers> gabbiel: "a" is a [Char]. return 'a' will wrap the Char into a [Char].
11:37:37 <argoneus> that's about it
11:37:48 <Zekka|Sigfig> Monad is Functor plus some extra rules
11:38:06 <monochrom> I don't think there is much more to know than the definition
11:38:06 <byorgey> argoneus: the best way to get a better intuitive understanding is to just work with them a lot.  Try examples, try exercises, use them, etc.
11:38:16 <gabbiel> so for "return "a"" to work, it would be :: [[Char]]?
11:38:27 <EvanR> yes
11:38:27 <monochrom> or rather, the definition and a reportoire of examples
11:38:29 <byorgey> you're not going to get a better intuitive understanding by asking about it in #haskell.
11:38:37 <argoneus> right
11:38:46 <Zekka|Sigfig> argoneus: This is something I did when learning that I think helped
11:38:49 <Ankhers> gabbiel: Yes.
11:38:51 <gabbiel> yeah argoneus, every guide on moands say to work with them
11:38:57 <EvanR> byorgey: one of the few things #haskell can't answer!
11:38:59 <Zekka|Sigfig> Try writing explanations for how a lot of common types work as monads
11:39:08 <johnw> byorgey: one might even say that #haskell could make it worse
11:39:20 <Zekka|Sigfig> So write your own instance Monad Maybe, instance Monad [], instance Monad (Either a), instance Monad State, etc.
11:39:42 <ReinH> johnw: so I shouldn't explain how tortillas are monads in the category of FUD?
11:39:49 <EvanR> write your own Writer and then do performance tests on it
11:39:54 <johnw> byorgey: a person looking to understand what love is should not go to a dating site and ask for a definition
11:40:07 <argoneus> hm, yeah that's probably right
11:40:14 <argoneus> I've read a lot about haskell but barely wrote anything myself
11:40:22 <Jinxit> write a bunch
11:40:26 <Jinxit> come up with a project
11:40:30 <gabbiel> right, there's nothing to write with our little expertise
11:40:34 <ReinH> ♬ ♬ I want to know what monad is... I want you to show me... ♬ ♬
11:40:44 <Jinxit> that's the best education since you have to look up how to actually use things
11:41:04 <GLM> Is there a command option to guarantee that all errors and Exceptions are caught?
11:41:15 <gabbiel> umm, where keyword only works with guards?
11:41:28 <geekosaur> with definitions
11:42:07 <Ankhers> :t bracket -- GLM ?
11:42:08 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:42:19 <monochrom> love is not in the same ballpark as monad
11:42:27 <johnw> ReinH: lol
11:42:32 <EvanR> GLM: catch all exceptions is probably not right
11:42:36 <maerwald> ReinH: I like the teaching sequence functor -> applicative functor -> monad, because applicative lacks "join" and then it becomes obvious what monads add to the world
11:42:53 <johnw> monochrom: that just means you have more to learn about monads ;)
11:43:01 <monochrom> but of course, asking stackoverflow for the definition of, say, discrete valuation rings, still doesn't help you understand them.
11:43:05 <ReinH> maerwald: agree
11:43:06 <Zekka|Sigfig> argoneus: FWIW I was surprised when I was learning Haskell how not-hard it was to start writing programs once I started experimenting’
11:43:18 <monochrom> err, s/stackoverflow/mathoverflow/
11:43:21 <Zekka|Sigfig> I would definitely recommend trying it
11:43:24 <argoneus> just to make sure
11:43:26 <ReinH> maerwald: and parsers are good example because join lets you immediately do things you wanted to do before but couldn't.
11:43:31 <argoneus> can you chain monads? like IO Maybe Int
11:43:32 <johnw> maerwald: funny how that sequence work for Haskell, but wouldn't for math
11:43:34 <maerwald> yeah
11:43:47 <dolio> Asking mathoverflow what monads are used for might help.
11:43:57 <Zekka|Sigfig> argoneus: Yeah, but IO (Maybe _) can’t automatically be derived
11:44:07 <Zekka|Sigfig> some monads compose, but they don’t automatically compose
11:44:07 <monochrom> is that "IO (Maybe Int)"? is that "(IO Maybe) Int"?
11:44:12 <Zekka|Sigfig> I’ll be back later, probably — see you
11:44:17 <EvanR> argoneus: IO has one parameter not two
11:45:14 <lpsmith> javjarfer, have you taken a look at this?  https://hackage.haskell.org/package/linux-inotify
11:45:30 <Ankhers> What is the difference between `IO (Maybe Int)' and `MaybeT IO Int'?
11:45:46 <johnw> I think he meant Compose IO Maybe Int, which ≅ MaybeT IO Int
11:45:47 <monochrom> IIRC they are isomorphic
11:45:52 <argoneus> oh, right
11:45:58 <argoneus> IO (Maybe Int)
11:46:05 <lpsmith> it's a very thin binding to inotify,  though I ended up bypassing the handle infrastructure.
11:46:06 * hackagebot Lambdaya 0.2.0.0 - Library for RedPitaya  https://hackage.haskell.org/package/Lambdaya-0.2.0.0 (ralu)
11:46:20 <GLM> EvanR:What do you mean? I just want to make sure that if an exception is thrown in my code, it doesn't compile until it is properly handled
11:46:43 <monochrom> maybe not. they are only newtype-isomorphic. they have different >>= semantics
11:46:47 <EvanR> GLM: normally thats not how you use exceptions. however you might want to make sure you catch all of YOUR exceptions
11:46:48 <maerwald> lpsmith: there is als hinitofy
11:46:53 <maerwald> which I am using
11:46:54 <maerwald> it's fine
11:47:03 <javjarfer> lpsmith, yes, thanks you, i'm making a new version of the wrapper that use polling instead of callbacks
11:47:09 <EvanR> the runtime catches everything else that you didnt know or care about
11:47:47 <EvanR> GLM: for pure code if you use Maybe and Either then the type system will check that you handled them
11:48:30 <lpsmith> javjarfer, that binding doesn't use callbacks.   It uses the IO manager,  so it uses epoll.
11:48:41 <GLM> EvanR: I definitely want to catch my exceptions
11:48:42 <lpsmith> No polling either.
11:49:07 <GLM> EvanR:What if the library I'm using throws an error or a programmer in my codebase did the same
11:49:33 <maerwald> GLM: I think GHC cannot tell you that you didn't handle an exception of a particular type
11:49:36 <EvanR> for IO exceptions, you better hope its documented
11:49:51 <maerwald> yes, document all your exceptions!
11:49:55 <javjarfer> lpsmith, when I say callback is that the API that they exposes let you inject a function, that is going to be executed at the moment a event occurs
11:50:00 <lpsmith> Though I've been meaning to write waitReadInotify and waitReadInotifySTM operators to enable a usage patterns.
11:50:01 <EvanR> if its a library thats not about IO, better hope they didnt use IO exceptions
11:50:07 <ReinH> monochrom: this is the sort of thing you get at mathoverflow if you ask for a monad explanation http://math.stackexchange.com/questions/405/simple-explanation-of-a-monad
11:50:15 <ReinH> ymmv on whether the answers are useful
11:50:15 <lpsmith> javjarfer, right,  https://hackage.haskell.org/package/linux-inotify doesn't support callbacks
11:51:00 <ReinH> The accepted answer is a slight elaboration on "monads are monoids in the category of endofunctors, what's the problem?"
11:51:13 <gabbiel> whatever that means
11:51:19 <EvanR> "representations" of the trivial monoidal category
11:51:21 <ReinH> it means what it says
11:52:06 <gabbiel> "have you ever been even as decided to look more want even look for more?"
11:52:16 <ReinH> no, it isn't gibberish.
11:52:29 <EvanR> maybe if they named Monads something like Transfusers, and said.. this is related to monads in category theory dont worry about it
11:52:30 <johnw> http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem
11:52:40 <ReinH> if you know what a monoid in a category is and what a category of endofunctors is, you will know what a monad is.
11:52:43 <lamda_sage> Can someone help me understand how monads allow for side effects? I get how they carry around a context that forces an execution order, but I don't understand how a pure function that gets input from the user can be considered pure when It's output always differs on each call?
11:52:57 <ReinH> lamda_sage: they don't.
11:53:19 <ReinH> lamda_sage: can you give me an example of a pure function whose output differs on each call?
11:53:21 <javjarfer> lpsmith, oook, sorry I my bad, I didn't read the link correctly
11:53:23 <johnw> lamda_sage: have you ever written a function s -> (a, s)?  That is, a function that taken a input state, and while producing an output value, also produces a possibly modified output state?
11:53:49 <monochrom> "deep and satisfying"
11:53:54 <johnw> this is how purely functional languages implement the idea of "effects upon state" in addition to computing a value
11:53:55 <dolio> ReinH: 'What is a monad?' isn't a very good question. Hence the answers not being very good.
11:54:12 <javjarfer> lpsmith, I thought you were refering this https://hackage.haskell.org/package/hinotify-0.3.8.1/docs/System-INotify.html
11:55:08 <javjarfer> lpsmith, that API you were pointing is in fact what I wanted.
11:55:18 <gabbiel> tfw no networking with haskell for the beginner book
11:55:26 <ReinH> gabbiel: which beginner book?
11:55:50 <lamda_sage> So how do you implement getChar? If getChar takes the same state, won't it produce different results depending on the side effect?
11:55:55 <gabbiel> no, im saying that there isn't a "networking with haskell for the beginner" book
11:55:57 <ReinH> lamda_sage: getChar is not a function.
11:56:03 <EvanR> :t getChar
11:56:04 <lambdabot> IO Char
11:56:15 <ReinH> It does not produce different results each time it is evaluated.
11:56:17 <benzrf> lamda_sage: if someone has been telling you stuff about how IO is implemented
11:56:27 <benzrf> lamda_sage: they have been either lying or being tremendously unhelpful
11:56:37 <monochrom> lamda_sage: see my http://www.vex.net/~trebla/haskell/IO.xhtml
11:56:37 <ReinH> lambdabot: I'm going to copy an answer I gave in the beginner haskell mailing list: https://gist.github.com/reinh/52b90fa33e55f4ca701f
11:56:42 <ReinH> lambdabot: maybe it will be useful for you
11:56:44 <ReinH> also read monochrom's
11:56:54 <lamda_sage> thanks
11:57:10 <gabbiel> thanks fame
11:57:12 <johnw> getChar can be *thought of* as RealWorld -> (Char, RealWorld), where the world has been observed (and changed by observation) in order to yield your character
11:57:12 <gabbiel> *fam
11:57:21 <EvanR> ;_;
11:57:21 <ralu> if installing haskell-platform for windows bad idea?
11:57:28 <ralu> *is
11:57:28 <monochrom> a runtime system, outside Haskell, implements getChar
11:57:34 <gabbiel> just get linux
11:57:39 <dmj`> ralu: windows is a bad idea
11:57:43 <benzrf> lamda_sage: the correct way to think of it is, a value of 'IO Foo' is some kind of abstract representation of a program that computes a Foo using side effects. one way to think of this would be to imagine that an 'IO Foo' is a piece of code in shell or something, which you could hypothetically run from outside of haskell
11:57:52 <ralu> i know, i know i am just testing
11:58:01 <ralu> :D
11:58:04 <benzrf> lamda_sage: you purely compute your hypothetical program, then ghc takes it and runs it
11:58:11 <benzrf> from outside of haskell's purity
11:58:38 <EvanR> getChar is not a function of the real world, its a command, and the real world is a bad way to explain IO as a functional concept
11:58:40 <monochrom> its representation in Haskell has abstract type "IO Char". this has to be an abstract type because the implementation is ultimately outside Haskell
11:59:01 <benzrf> lamda_sage: anything that involves 'RealWorld' is going to be confusing to you, and definitely doesn't explain anything about purity
11:59:15 <benzrf> lamda_sage: the only way that RealWorld explains how haskell is pure, is if you imagine an omnipotent computer simulating the universe
11:59:18 <ReinH> lamda_sage: er, that link was for you, not lambdabot
11:59:41 <lamda_sage> Ok, I think I see that I might have been misled by an earlier tutorial I read
11:59:48 <benzrf> lamda_sage: monads are not some kind of key trick for ensuring purity at all
11:59:54 <benzrf> lamda_sage: they are just a useful interface to the IO type
11:59:57 <johnw> many questions about 'monads' seem to be about a particular type that implements Monad; it was actually a really long time before I needed the Monad concept in its full generality
12:00:37 <lamda_sage> I understand monads as a catagory theory construct, but not in terms of computational contexts
12:00:37 <ReinH> lamda_sage: the keys are: (1) A value of type IO a for some a is not a function. (2) *Evaluation* of such an IO action does not perform any IO or cause any effects.
12:00:59 <johnw> EvanR: I didn't invent that explanation.  See https://wiki.haskell.org/IO_inside#Welcome_to_the_RealWorld.2C_baby
12:01:04 <EvanR> lamda_sage: do you understand haskell's type system in terms of category theory?
12:01:09 <EvanR> johnw: i know
12:01:27 <benzrf> lamda_sage: saying that monads allow impurity is like saying that steering wheels allow you to run faster
12:01:27 <lamda_sage> Sort of, Hask is a catagory and types are sub catagories of hask correct?
12:01:29 <monochrom> one day I'm going to drink two shots of whiskey and then go completely delete that page
12:01:32 <benzrf> lamda_sage: not at all
12:01:39 <ReinH> benzrf: I don't see how that's helpful
12:01:42 <benzrf> lamda_sage: don't worry about category theory unless you already know a ton of math
12:01:46 <gabbiel> > if "not discussing monads" then "discuss about monads" else "keep discussing forever"
12:01:48 <lambdabot>      Couldn't match expected type ‘Bool’ with actual type ‘[Char]’
12:01:48 <lambdabot>      In the expression: "not discussing monads"
12:01:48 <lambdabot>      In the expression:
12:01:54 <EvanR> but the RealWorld thing is even talking about a universal omnipotent computer, its just some weird thing in GHC
12:01:58 <EvanR> isnt*
12:02:01 <johnw> EvanR: it's actually not a terrible way to think about it; I use the same mental model when modeling runtime behavior of programs in Coq
12:02:17 <monochrom> gabbiel: the question "are we discussing monads?" is undecidable :)
12:02:18 <Ankhers> gabbiel: Haskell does not have "truthy" values.
12:02:23 <EvanR> does Coq have concurrency and timers and stuff?
12:02:28 <maerwald> I think IO stuff in haskell wasn't even "monadic" in the beginning, I forgot how it was implemented before
12:02:31 <EvanR> or IO at all
12:02:33 <johnw> that is, since Coq has no runtime, the best way to theorize a runtime is as state machine from world -> world
12:02:35 <benzrf> lamda_sage: first of all, you mean cars, not steering wheels; steering wheels are just a means of using cars. furthermore, cars do not in fact let you run faster; they let you accomplish the same kind of thing
12:02:53 <maerwald> but you don't need Monads to do IO in haskell, there are other ways, Monads just made it easier
12:02:53 <monochrom> maerwald: look for "Haskell 1.4" IIRC
12:03:03 <ReinH> lamda_sage: Hask is the category of Haskell types and functions. Each type constructor can be viewed as an injection into a full subcategory of Hask if that is useful.
12:03:09 <johnw> EvanR: concurrency can be modelled that way; I think you mean to say asynchronous behavior, which requires a branch tree of states
12:03:10 <gabbiel> truthy values are handy though, just syaing
12:03:32 <monochrom> oops, 1.4 already goes with monad
12:03:39 <benzrf> lamda_sage: are you a math person who already knew category theory for other reasons, or are you a programming person who started learning category theory because you heard it had something to do with haskell?
12:03:58 <Ankhers> gabbiel: You can always define a function t -> Bool.
12:04:10 <lamda_sage> I just started learning catagory theory for haskell
12:04:18 <EvanR> johnw: it fails to capture not only practical reality of the IO behavior, but physics
12:04:49 <monochrom> Haskell 1.2 is the one. 1.3 goes with monad.
12:04:56 <ReinH> lamda_sage: Generally we ignore the subcategories bit because it isn't very useful. We just say that, e.g., a Functor instance is an endofunctor [Hask,Hask]
12:05:10 <gabbiel> ankhers: it just needs to be there, no need for implementation
12:05:47 <lamda_sage> ReinH: A monad is just a specialized endofunctor yes?
12:05:48 <Ankhers> gabbiel: Do you consider an empty string to be True or False? How about 0? Does it encapsulate every scenario?
12:06:07 <ReinH> lamda_sage: A monad is an endofunctor with some particular extra structure.
12:06:25 <EvanR> gabbiel: truthyness can be implemented for things in haskell, as was done in pure script. The BoolLike typeclass
12:06:38 <benzrf> lamda_sage: doooooooooooooooooooon't do that don't don't don't
12:06:40 <EvanR> just because javascript has this concept
12:06:46 <benzrf> lamda_sage: seriously!!!!
12:07:04 <ReinH> lamda_sage: specifically a monoidal product join : M * M -> M and identity return : 1 -> M
12:07:04 <benzrf> lamda_sage: learn type theory if you want, but category theory IS NOT A GOOD USE OF YOUR TIME
12:07:14 <EvanR> class Monad < EndoFunctor
12:07:21 <benzrf> lamda_sage: i've learned some elementary category theory and i can't say it's ever helped me in haskell
12:07:23 <gabbiel> ankhers: true, also true, no. i just need it for specific scenarios for less typing
12:07:38 <lpsmith> javjarfer, oh no problem, I hope the package is useful.   And as I said, I've been meaning to implement waitReadInotify and waitReadInotifySTM operators so that you can wait for the descriptor to become readable,  sleep for a short while,  then start processing events.
12:07:42 <johnw> category theory is just fun to learn if you are looking for fun; practically, maybe not so much (depending on what you intend to do with Haskell, really)
12:07:44 <paf31> EvanR: actually BoolLike (now called BooleanAlgebra) only overloads &&, || and not
12:07:50 <aweinstock> why do people consider (IO = State RealWorld) to be just a metaphor, when the GHC implementation is actually that? (newtype IO a = State# RealWorld -> (# State# RealWorld, a #))
12:08:07 <EvanR> paf31: oh i thought it was for using stuff in an if then else
12:08:22 <ReinH> aweinstock: because RealWorld is just a magic number. It's an implementation detail.
12:08:41 <paf31> I used to have a truthy values example in a very early talk i would give to js groups
12:08:49 <paf31> but it was never in the standard library
12:08:55 <maerwald> yeah, SPJ used it to explain monadic IO, but people argued it may confuse people wrt concurrency and other things
12:09:03 <monochrom> the GHC implementation uses that as a coding trick only. it fools the optimizer into not re-ordering code. recall that the optimizer loves to re-order pure code because purity.
12:09:18 <EvanR> RealWorld will make sense as soon as I can store some in a container, and pass one two several different IO actions without worrying about them interacting
12:09:24 <benzrf> bbl
12:09:26 <gabbiel> i should be studying, but i'm here, trying to find out the type of id
12:09:34 <ReinH> RealWorld is a misnamed magic number, it is not some putative state of the universe.
12:09:50 <Ankhers> :t id -- gabbiel 
12:09:50 <ReinH> or, rather, sequence of magic numbers
12:09:51 <aweinstock> id :: forall a. a -> a
12:09:51 <lambdabot> a -> a
12:10:18 <monochrom> and you know that it is only a coding trick, not an implementation, because by the time you see asm code, nothing represents State# RealWorld. it's a phantom type.
12:10:26 <maerwald> Although the idea is pretty nice... thinking that IO has an "implicit" parameter, namely the universe. But yeah, the metaphor doesn't work consistently.
12:10:35 <gabbiel> 4 :: a
12:10:41 <monochrom> and the tuple (# State# RealWorld, a #) becomes simply a.
12:11:07 * hackagebot microlens-aeson 2.1.0 - Law-abiding lenses for Aeson, using microlens.  https://hackage.haskell.org/package/microlens-aeson-2.1.0 (fosskers)
12:11:40 <monochrom> Phatom -> (Phatom, a) when used wisely adds a fictional data dependency to prevent the optimizer from re-ordering.
12:11:40 <weox> I am having hard time with mathematics, So as hobby I want start coding in haskell , because I have heard a lot haskell makes you better thinker and improve your mathematical thinking ability  . is it true ? or I am just wrong ? please careful I am not claiming I want to be mathematicin by just learning haskell , I want as hobby learn a programming language
12:11:40 <weox> , and I have heard haskell reallly makes me better thinker in mathematical terms. 
12:12:12 <dolio> aweinstock: It doesn't make sense as a semantics of I/O. It's an implementation hack that happens to do the right thing.
12:12:34 <kadoban> weox: I doubt pretty strongly that learning haskell will make you a better mathematician. It'll probably be fun and it could make you a better programmer though.
12:12:35 <ReinH> weox: well, it's got a better shot than most languages
12:12:37 <maerwald> weox: I don't see why it would, honestly. There are similarities, but maths is still fundamentally a different thing.
12:12:49 <javjarfer> lpsmith, ok I see what you mean, well my API now only works as a non-blocking reader, but I wanted to have a a non-blocking and blocking reading
12:12:54 <ReinH> but I'm not sure how good it is per se
12:13:08 <mauke> maerwald: there are indirect benefits
12:13:09 <lamda_sage> Does IO inside on the wiki give a good view of how IO actually works or is it just another abstaction that falls through at some point?
12:13:10 <EvanR> maerwald: its not to think about programs as syntax where substitution works
12:13:11 <mauke> I think
12:13:17 <EvanR> maerwald: er... its nice
12:13:32 <ReinH> lamda_sage: did you read monochrom's thing?
12:13:51 <weox> kadoban: ReinH  maerwald  thanks guys .
12:13:51 <maerwald> well, doing hardcore C programming may also improve your maths skills in some indirect way, but...
12:14:16 <lamda_sage> ReinH: Is that the thing on vex.net?
12:14:35 <mauke> maerwald: I think learning Haskell improves your formal thinking skills
12:14:37 <maerwald> if you want to improve your maths, do maths.
12:14:39 <bennofs> weox: I think it helps more if you're a programmer willing to learn some math. Haskell
12:14:43 <johnw> dolio: exceptions especially don't fit into that picture
12:14:45 <dolio> aweinstock: A detailed analysis will reveal that the `World -> (a, World)` things are 'functions' with side effects, and the `World` just makes the side effects happen in the right order.
12:14:50 <mauke> maerwald: knowing about types also helps
12:15:01 <maerwald> for maths?
12:15:07 <mauke> yes
12:15:09 <EvanR> maerwald: when you say let x = foo + bar, this means what it means in math rather than in C
12:15:16 <ReinH> lamda_sage: That IO Inside wiki page is bad and imo should be deleted.
12:15:20 <monochrom> I first read this coding trick from D. Hugh Redelmeier's PhD thesis. unfortunately it is one of those 1980s theses that only exist on real paper in a university's library. I happen to be from the same university, so I could go and read it.
12:15:20 <maerwald> not sure I agree there
12:15:41 <dolio> So then your semantics for the entire language has to account for side effects, and the whole point of IO was to avoid that.
12:15:53 <mauke> maerwald: I've met fellow students who were confused about things like ℕ ∈ ℝ or 0 ⊂ ℕ
12:15:53 <javjarfer> lpsmith, it shoul be really easy to get the blocking one, I should only replace hGetBufNonBlocking with hGetBufSome 
12:16:00 <weox> maerwald: yes c can improve you mathematics if you are doing some thing related to scientific computing ., but in math you have rigorousness  which you don't have in any other fields (and this is the problem with math for most people like me , I perfectly capable of absorbing very diffucalt ideas in math , but when it comes to details , then it is messed up
12:16:00 <weox> ) . for example take python .. how rigorous is it ?
12:16:16 <johnw> one thing #haskell will teach you: every explanation is deficient in the end and shouldn't be used to avoid confusion. You are left with the sound of one hand clapping.
12:16:37 <monochrom> at any rate Phatom->(Phatom,a) can help you create a fictional data dependency that forces the compiler to preserve chronological order, which is what you want for I/O
12:16:43 <weox> mauke: exactly . I desperately wanting something for this . "Formal Thinking"
12:16:46 <phaazon> @hoogle e -> Maybe a -> Either e a
12:16:49 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
12:16:49 <lambdabot> Text.Parsec runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
12:16:49 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
12:16:56 <phaazon> what is the common name for that?
12:17:00 <johnw> phaazon: that's in the 'errors' library I think
12:17:00 <phaazon> note, or something like that
12:17:10 <phaazon> yeah but I don’t want to bring that library just for that
12:17:10 <EvanR> weox: check out types and programming languages
12:17:12 <phaazon> I can write the function
12:17:19 <phaazon> I guess it’s note
12:17:30 <phaazon> and the reverse is hugh
12:17:33 <phaazon> hush*
12:17:40 <phaazon> hush :: Either e a -> Maybe a
12:17:46 <mauke> weox: Haskell worked for me, but I can't tell you whether that's because of Haskell itself or because it simply triggered something in me I already had
12:17:53 <monochrom> but Redelmeier is more crazy than GHC. GHC auto-generates the dependency by a strict discipline. Redelmeier actually says that you should hand-code it and you should do cunning things.
12:18:25 <weox> EvanR: do you mean books ? or fields ? 
12:18:30 <EvanR> the book
12:18:39 <weox> EvanR: I looked at it , its is kinda heavy for me 
12:18:40 <mauke> @where tapl
12:18:40 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
12:18:54 <EvanR> well it has formal thinking ;)
12:19:07 <weox> EvanR: I was looking at it the other days in our university library .
12:19:12 <EvanR> and refers to a lot of stuff that you might crash into while doing haskell
12:19:27 <csd_> what is :-> ? specifically w.r.t quickcheck?
12:19:28 <EvanR> or get sucked into
12:19:33 <mauke> I'd just learn basic haskell first
12:19:39 <maerwald> mauke: that's really very basic and easier to understand directly in maths instead of diving into the complexity of the haskell type-system, uhm
12:19:55 <javjarfer> lpsmith, I see they have already a blocking function, getEvent, so you want to implement those function not for reading, but to wait for the creation of the filedescriptor true?
12:19:58 <EvanR> i wish maths had type annotations
12:20:12 <mauke> maerwald: that's backwards. haskell is much easier than math
12:20:12 <monochrom> anyway this is one of those cases where "knowing half of it is more dangerous than knowing none of it" is true. you saw State# RealWorld. but you didn't see how it's a phantom type. that leads to a lot of wrong conclusions.
12:21:02 <weox> EvanR: I think starting haskell and the going after this book is better approach ? don't you think so ? it was little heavy for me . and BTW I am not going to stop after finding the "THING" which I can improve this is by it. So starting book after haskell I would say is better 
12:21:07 <maerwald> mauke: I am pretty sure people who have problems with ℕ ∈ ℝ or 0 ⊂ ℕ will not have less trouble getting into haskell types.
12:21:18 <EvanR> weox: i was not suggesting you stop doing haskell
12:21:33 <EvanR> who cares about the ordering i just pointed the book out
12:21:46 <mauke> maerwald: I disagree
12:21:57 <weox> EvanR: oh cool , Then it was perfect suggestion ! I am scheduling , that book definitely will be in my schedule . 
12:22:15 <EvanR> N elemnt of R O_o
12:22:18 <dolio> mauke: Were they confused in that they thought it was a sensible idea for those to be well formed propositions? Like most mathematicians?
12:22:56 <mauke> dolio: that was a homework exercise. "are the following true or false? ..."
12:23:08 <dolio> Wow.
12:23:12 <mauke> I was like "this is obviously a type error; false"
12:23:28 <mauke> some of the others thought it might be true
12:23:29 <dolio> Those are pretty bad homework questions.
12:23:31 <EvanR> lol, did you lose points
12:23:34 <lamda_sage> So putStrLn is a function, but getLine is just a value?
12:23:44 <mauke> lamda_sage: yes (also putStrLn is a pure function)
12:23:45 <lamda_sage> a value of type IO ()
12:23:47 <lamda_sage> ?
12:23:56 <mauke> IO String
12:24:14 <monochrom> to some extent, statements containing type errors are not even wrong
12:24:49 <mauke> EvanR: why?
12:25:08 <dolio> Yeah, those are like the go-to examples of, 'well-formed sentences that show ZF is a bad formal system.'
12:25:23 <EvanR> i was curious
12:25:38 <mauke> but for what?
12:25:53 <EvanR> "this is obviously a type error; false"
12:26:08 <mauke> I didn't write that
12:26:10 <EvanR> oh
12:26:18 <mauke> I just ticked the "false" box
12:26:27 <EvanR> oh multiple choice
12:26:46 <dolio> mauke: Well, 0 \subset BN is true for most ways of specifying those two things.
12:26:54 <EvanR> right N element of R would be false in the classic sense
12:27:04 <EvanR> since whatever you want could be in R
12:27:20 <dolio> The most common, at least.
12:27:23 <lpsmith> javjarfer, right,  waitReadInotify and waitReadInotifySTM would not actually read from the descriptor after it becomes readable.   Rather, you'd have to use getEvent or one of it's relatives to actually issue a read syscall.
12:29:08 <athan> ReinH: Yo!
12:29:10 <weox> are
12:29:18 <EvanR> and 0 subset N is a type mismatch
12:29:20 <weox> sorry ,wrong channel
12:29:24 <javjarfer> lpsmith, one thing I don't like about the API is that it let the freeing of resources to the user.
12:29:25 <athan> Please inform me what you mean by "RealWorld isn't real world"?
12:29:27 <EvanR> with extreme prejudice
12:29:41 <ReinH> athan: yo
12:29:46 <ReinH> athan: you missed a big discussion.
12:29:51 <athan> shoot
12:29:55 <athan> I'll check the logs
12:30:05 <ReinH> athan: RealWorld doesn't have any runtime representation at all. It has no value, let alone a value of "the real world".
12:30:28 <ReinH> It's a compiler trick to prevent optimizations from reordering things incorrectly, nothing more.
12:30:28 <athan> woah, wow I didn't know that
12:30:32 <athan> I thought it punctuated time
12:30:39 <athan> oh wow
12:30:47 <EvanR> time flows like a river
12:30:49 <ReinH> State# RealWorld is a phantom
12:30:49 <lpsmith> javjarfer, what do you mean?
12:31:17 <lamda_sage> I don't understand why stripIO :: IO String -> String does not work, but >>= does work. Whenever I see implementation of >>= it seems to do the same sort of extraction. Does the implementation of bind for the IO monad do some sort of magic to get back a unique string?
12:31:34 <athan> EvanR: So does space! :P
12:31:48 <ReinH> athan: so explanations of IO that equate it to a State monad, presumably because the word State appears in IO.hs, are at best missing the point entirely.
12:31:55 <javjarfer> lpsmith, "init" and "close" are used to initialize and to free resources
12:32:42 <EvanR> lamda_sage: stripIO ? any function of the form m a -> a might not actually work. because having an m a doesn't guarantee you can produce any value of type a
12:32:43 <lpsmith> javjarfer, calling close isn't strictly necessary;  there is a finalizer that will eventually close the descriptor if it's garbage collected.
12:32:44 <ReinH> lamda_sage: >>= does no extraction. To prove this, note that ((->) r) is a Monad instance.
12:32:45 <athan> ReinH: What is that point, specifically? How would IO not convolute itself without that state thread?
12:32:46 <mniip> lamda_sage, you're not supposed to look at the implementation of >>=
12:32:50 <EvanR> lamda_sage: example Nothing :: Maybe a
12:33:06 <dolio> ReinH: Some languages have you do IO directly like it. Like Clean.
12:33:09 <dolio> Also Mercury.
12:33:12 <ReinH> athan: the point is that explanations of IO in terms of a state monad are wrong and misleading.
12:33:44 <ReinH> And any explanation of IO that begins with ``putStrLn "foo" is a function'' has nowhere to go but down
12:34:11 <athan> ReinH: how is it not a function?! arg
12:34:15 <ReinH> you can't recover from that mistake, since the rest of your argument is based on a false premise.
12:34:15 <mauke> lamda_sage: >>= pushes the function into IO, not the String out of IO
12:34:19 <shachaf> The Haskell Report calls getLine a function
12:34:21 <EvanR> :t putStrLn "foo"
12:34:23 <lambdabot> IO ()
12:34:36 <ReinH> shachaf: well, that's a shame.
12:34:37 <mauke> shachaf: time to file a bug
12:34:49 <shachaf> Oh, maybe you mean that that's a high point of explanations.
12:34:56 <shachaf> Since it has nowhere to go but down.
12:35:17 <athan> ReinH: So an `IO a` is a... what? What would you call it in your own words? How would you describe it?
12:35:29 <ReinH> athan: a value. Sometimes people call it an IO action.
12:35:30 <shachaf> mauke: Where do I file a bug?
12:35:33 <EvanR> what is Nothing?
12:35:34 <athan> :|
12:35:37 <EvanR> a Maybe a
12:35:40 <mauke> shachaf: this is a directed graph; it's not necessarily a local maximum
12:35:42 <dolio> shachaf: Haskell prime trac.
12:35:43 <shachaf> I'll just file it in #haskell.
12:35:44 <javjarfer> lpsmith, that is great, I didn't hear before about those finalizers
12:35:47 <ReinH> athan: The problem is that this is a false equivalence.
12:35:54 <shachaf> https://www.haskell.org/onlinereport/haskell2010/haskellch7.html#x14-1430007.1 -- bug, yo
12:36:03 <ReinH> If getLine is a function then it is only because you are using a different meaning of function from when you say "id is a function".
12:36:30 <athan> ReinH: I think I see, there's no referrential transparency for IO actions?
12:36:31 <shachaf> mauke: What's a directed graph?
12:36:31 <ReinH> functions in haskell are values which can be applied to other values, not values which must be executed by the RTS.
12:36:32 <monochrom> I want a word to replace "function" when it comes to things I import from a module, too.
12:36:43 <athan> Ah!
12:37:06 <javjarfer> lpsmith, I suppose I need to read a bit more until I get a more educated opinion. 
12:37:13 <ReinH> athan: A function is a value of type a -> b for some a and b. It can be applied to a value of type a to produce a value of type b. That's how you can tell that it's a function.
12:37:14 <mauke> shachaf: a thing where the connections have arrow tips
12:37:19 <monochrom> more precisely, things I import from a module, but not a type, not a class, not an instance, and not a data constructor.
12:37:20 <lpsmith> javjarfer, it's all good :)
12:37:22 <EvanR> unless you are also using that kind of function (who knows what it is) with `id`
12:37:32 <ReinH> getLine is not a function, and calling it a function means equivocating between function application as evaluation and some other form of function application as execution.
12:37:46 <monochrom> more positively, values except data constructors. but "value" is too bland.
12:37:50 <athan> ReinH: However, we don't know nothing of the certainty of IO, outside of the potential `a` value inside?
12:38:04 <athan> hmm
12:38:10 <ReinH> athan: We know everything we need to know: that getLine is the same value every time.
12:38:18 <augur> athan: the way i prefer to explain IO is in terms of data
12:38:26 <ReinH> Its execution may differ, but no one expects execution to be pure. We like to be able to actually run our programs.
12:38:42 <EvanR> monochrom: but nullary constructors are arrows from the initial object!
12:38:57 <EvanR> therefore functions
12:39:00 <monochrom> here is the usage: sometimes I want to say "System.IO has a lot of useful functions". but they are not all functions. "System.IO has a lot of useful values" is correct but alienating.
12:39:12 <ReinH> EvanR: yes, but here's the crucial distinction
12:39:14 <lamda_sage> Can I replace putStrLn "Enter a line:" >>= \_ -> getLine with >> getLine?
12:39:21 <athan> ReinH: I've always known this, but haven't been strict enough to consider it the "dead zone". That's an interesting concept
12:39:30 <ReinH> EvanR: even under that interpretation, applying getLine does not give you a String.
12:39:44 <monochrom> maybe I could say "System.IO has a lot of useful combinators"?
12:39:51 <athan> I feel like the State <-> IO corrospondance in the wiki page is just to help explain how GHC _can_ evaluate monads, too
12:39:59 <cocreature> monochrom: System.IO has a lot of useful stuff :)
12:40:01 <augur> athan: as a minimal example:   data IO a where {  PutLn :: String -> IO ()  ;  GetLn :: (String -> IO a) -> IO a  ;  Return :: a -> IO a  ;  Bind :: IO a -> (a -> IO b) -> IO b  }
12:40:05 <monochrom> that is also correct, but beyond alienating
12:40:07 <athan> before I read it, I had no idea that monads weren't necessarilly imperative
12:40:16 <monochrom> yeah, so far I am doing "stuff" and "things"
12:40:33 <monochrom> and "tools"
12:40:40 <Ankhers> lamda_sage: yes.
12:40:48 <augur> athan: so a program of type  IO a  is a piece of data that represents instructions to the executor/runtime
12:40:57 <athan> augur: Hmm, that's an interesting concept, you can't understand IO outside of the values that interact with it
12:41:11 <athan> hmm
12:41:25 <EvanR> its not about what stuff is but how it interacts with other stuff
12:41:29 <ReinH> athan: "values that can't be applied are still nullary functions" doesn't buy you "getLine is a function that you can apply to produce a String", which is how function is being (mis)used there.
12:41:33 <athan> I'm going to hm a lot more :) thank you augur!
12:41:34 <augur> athan: when you write    GetLn (\x -> PutLn ("Hello, " ++ x ++ "!"))   you're really just writing a piece of data
12:42:07 <athan> ReinH: I think I understand
12:42:15 <ReinH> It's a dangerous false equivalence.
12:42:21 <athan> the concept that IO could ever be pure is wrong
12:42:26 <Cale> hm?
12:42:29 <Cale> No it is!
12:42:38 <Cale> It's important to realise that *evaluating* an expression for an IO action does nothing really visible.
12:42:38 <augur> and then the executer runs it appropriately. this is obviously not an *efficient* thing to do, but it's the right way to think about it for an intuition, i feel
12:42:43 <athan> augur: That makes a lot of sense :)
12:42:43 <jophish> bikeshedding a name: I have a function which takes an Orbit and a Time and calculates the Mean Anomaly of the orbit at that time. Which name do you guys prefer: meanAnomalyAtTime, meanAnomalyFromTime, timetoMeanAnomaly, or something else?
12:43:00 <ReinH> athan: IO is pure under evaluation, which is where we are making the claim of purity in the first place.
12:43:04 <Ab123> @Cale can you mentor me for Gsoc 2016 in haskell or suggest me some mentors who would do the same?
12:43:04 <lambdabot> Unknown command, try @list
12:43:23 <Cale> athan: The IO action is just a (pure) piece of data which *describes* some effects which may be caused to occur at some later point, and evaluation doesn't cause those effects to occur.
12:43:23 <athan> Cale: Ahh okay, that makes sense, internally there may be purity, but it's unevaluated until execution by the RTS?
12:43:25 <mauke> monochrom: "operations"?
12:43:46 <Cale> athan: Right, execution is the word we use for the carrying out of the effects described by an IO action
12:43:48 <javjarfer> lpsmith, ok I have readed about finalizers, it could be possible that if you don't close the INotify the resource would be busy until it get garbage collected?
12:43:50 <monochrom> mauke: is "stdin :: Handle" an operation?
12:43:58 <ReinH> athan: maybe this will help you https://gist.github.com/reinh/52b90fa33e55f4ca701f
12:44:05 <athan> Ahh wow, okay
12:44:07 <mauke> monochrom: no
12:44:07 <Cale> and main gets executed when your program gets run, and then in turn, it causes other IO actions to be executed
12:44:10 <athan> vernacular :)
12:44:14 <mauke> monochrom: is it useful? :-)
12:44:24 <i_am_neuron> Hi folks, newbie here. I'm now reading on the basic typeclasses from the standard library and need help understanding Applicative. I have some background in math and most types seem easy, but I just can't get Applicative. Could someone help please?
12:44:31 <monochrom> right, that's a tiny technicality there that I want to avoid
12:44:36 <i_am_neuron> I have no trouble understanding Functor and Monoid classes. For me, functor is a structure-preserving mapping from one category to another, and monoid is something I'm familiar with from math (along with rings and groups).
12:44:37 <mauke> i_am_neuron: do you understand Functor?
12:44:38 <lpsmith> javjarfer, well, it can take some time for the descriptor to be noticed as garbage,  and after that it can take some time for the finalizer to actually be run.
12:44:39 <mauke> ok
12:44:44 <athan> That's a fundamental concept, but I think it's over the heads of beginners
12:44:47 <athan> thanks everyone
12:44:51 <i_am_neuron> This is the example I'm trying to understand (it's an answer to a quesion of how to make a zipWith padded with default value): http://stackoverflow.com/a/21350096.
12:44:51 <Cale> But *evaluation* is separate and doesn't cause any execution. However, you can imagine that the executor is pattern matching on the IO actions and that pattern matching causes them to be evaluated.
12:44:54 <athan> I still believe in state threads, though! :x
12:45:02 <athan> (to describe IO's internals, I mean)
12:45:06 <monochrom> stdin is sometimes useful because you will find yourself saying "hSetBuffering stdin ..."
12:45:11 <mauke> i_am_neuron: wait, doesn't haskell Functor stay in the same category?
12:45:11 <athan> (without being anything related to correct)
12:45:22 <i_am_neuron> mauke: Hmm, I can't see how
12:45:23 <Cale> and all evaluation is ultimately caused by pattern matching at some level
12:45:30 <monochrom> then again, stdin is not a combinator either
12:45:34 <nitrix> What the idiomatic approach of handling multiple states with Haskell? Group them into a record and abuse lens Prisms?
12:45:39 <lpsmith> Finalizers also aren't guaranteed to be run at all;  for example if the process is terminated before the finalizer is run.   But that doesn't really matter in this case,  as the resources will be cleaned up after the process terminates by the kernel itself.
12:45:41 <monochrom> wait, maybe it is. this is confusing.
12:45:42 <athan> Wow, that's profound Cale / augur
12:45:46 <i_am_neuron> mauke: Could you do some hand-holding with me?
12:45:51 <mauke> i_am_neuron: a functor maps a type to another type
12:45:53 <nitrix> It's a game and there's many things to keep track of (and needed by multiple functions). I can try to split the functions respectively for what they do, but eventually, the main loop will have this big state record I fear.
12:45:54 <i_am_neuron> mauke: So Functor is a mapping, right?
12:46:00 <ReinH> i_am_neuron: the mathematical interpretation of Applicative isn't very useful in understanding its Haskell incarnation.
12:46:01 <nitrix> i_am_neuron: A functor is a container.
12:46:01 <i_am_neuron> mauke: Yeah
12:46:08 <Cale> Ab123: I don't know whether I'll have the time to devote to it once I get back to work
12:46:11 <i_am_neuron> mauke: But what Applicative adds to that?
12:46:18 <nitrix> i_am_neuron: Which lets you apply a function to members inside of the container.
12:46:23 <augur> athan: that's an alternative way of viewing it (state threads), but it's kind of too grungy
12:46:23 <Cale> Ab123: However, I'd be happy to answer questions you might have about Haskell when I'm around.
12:46:30 <EvanR> not necessarily a container
12:46:39 <Ab123> okay f9
12:46:39 <Cale> Ab123: I don't know who the people who are signed up to be gsoc mentors are
12:46:42 <mauke> i_am_neuron: the <*> operator, basically  :-)
12:46:42 <i_am_neuron> mauke: I can't see what Applicative adds to that
12:46:45 <mauke> i_am_neuron: and pure
12:46:54 <lamda_sage> I don't get the IO as a program concept. Is it like, main is a program that can actually do IO, and you're just describing what that program looks like?
12:46:54 <Cale> Ab123: But I'm sure there must be some?
12:46:58 <i_am_neuron> mauke: What do those mean?
12:47:00 <nitrix> > (+1) <$> Just 5
12:47:01 <lambdabot>  Just 6
12:47:02 <nitrix> i_am_neuron: ^ functor
12:47:04 <Ab123> how could i get the list of mentor?
12:47:15 <i_am_neuron> mauke: Seriously, I'm reading tutorial all day long today and still can't
12:47:28 <i_am_neuron> mauke: I'm failing to see how a list of padded strings is a functor, leave alone Applicative. What is `pure`? Documentation I read says "it wraps a value into a minimal context of Applicative". What is this context in the example I gave?
12:47:38 <mauke> i_am_neuron: given an applicative functor T, pure :: a -> T a
12:47:41 <nitrix> i_am_neuron: Applicatives are similar to functors, but the functions applied is also in a container.
12:47:42 <Cale> lamda_sage: yeah, evaluation just puts the program into some sort of internal standard form, and then execution carries it out and causes the effects described to take place
12:47:46 <i_am_neuron> mauke: Here's the link once again: http://stackoverflow.com/a/21350096
12:47:51 <nitrix> > Just (+1) <*> Just 5
12:47:52 <monochrom> i_am_neuron: read my http://article.gmane.org/gmane.comp.lang.haskell.cafe/119137/
12:47:53 <lambdabot>  Just 6
12:47:55 <nitrix> i_am_neuron: ^
12:48:01 <i_am_neuron> mauke: Alright, that's the signature of `pure`
12:48:13 <mauke> i_am_neuron: list-of-string is not a functor. list is
12:48:22 <Cale> lamda_sage: The difference between a value of type IO String and a value of type String is exactly like the difference between /bin/ls and a list of files
12:48:24 <mauke> similarly for Padme
12:48:32 <i_am_neuron> nitrix: Examples with Just are sort of not helpful for me :(
12:48:44 <i_am_neuron> nitrix: They are used in all tutorial out there and are way to trivial for me
12:48:51 <nitrix> i_am_neuron: `Maybe` is probably the easiest functor to understand.
12:48:58 <Cale> lamda_sage: Every time you run it, /bin/ls might give a different list of files, and if I give you that program, you can choose not to run it, or run it as many times as you like
12:49:05 <i_am_neuron> nitrix: That one I understand :)
12:49:12 <ReinH> i_am_neuron: Applicative is a claim about a type constructor f, that it can implement the functions (<*>) and pure. What that implementation means depends on which particular f you are talking about. The only unifying things are the types and the laws.
12:49:32 <nitrix> i_am_neuron: I can provide a different example if you tell me what you're looking for.
12:49:44 <i_am_neuron> nitrix: I just can't understand in this link (http://stackoverflow.com/a/21350096) how a person *sees* that a padded list is an Applicative
12:49:44 <ReinH> i_am_neuron: For an example, data Identity a = Identity a is an instance of Applicative: Identity f <*> Identity x = Identity (f x); pure x = Identity x
12:49:58 <javjarfer> lpsmith, in that case don't you think that maybe could be more positive to hide that from the user?
12:50:10 <lamda_sage> Cale: Oh my gosh I think I sort of get it, thanks!
12:50:15 <Cale> lamda_sage: Similarly, if I hand you getLine or getDirectoryContents or what have you, you have the option of executing it zero or more times (as part of describing another IO action), and each time you execute it, it might produce a different result or cause different effects to occur
12:50:27 <mauke> i_am_neuron: well, normal lists are Applicative
12:50:36 <mauke> i_am_neuron: why wouldn't padded lists be?
12:50:48 <i_am_neuron> nitrix: What I'm looking for is this: if functor is a mapping, then what does applicative adds to that mapping with `pure` and `<*>`?
12:50:51 <Cale> lamda_sage: But *evaluating* it won't cause the effects to occur, any more than opening /bin/ls in a hex editor would cause a list of files to be printed to the terminal
12:51:01 <monochrom> n-ary mapping, i_am_neuron
12:51:03 <i_am_neuron> mauke: I also can't see how normal lists are applicative :)
12:51:04 <lpsmith> javjarfer, hide "close" from the user?
12:51:10 <monochrom> see my article
12:51:10 <EvanR> i_am_neuron: to get a feel for this you need to try a bunch of applicative types yourself
12:51:16 <i_am_neuron> mauke: I CAN see why they are functors though
12:51:19 <mauke> i_am_neuron: pure x = [x]
12:51:20 <Cale> lamda_sage: and it's evaluation which we're referring to when we say that Haskell is pure
12:51:20 <EvanR> and then implement a couple yourself
12:51:40 <i_am_neuron> EvanR: the example in this link: http://stackoverflow.com/a/21350096 -- is it a good one?
12:51:40 <Cale> lamda_sage: (or referentially transparent, or terms like this)
12:51:41 <deni> when using http-types what's the proper way to parse the URI with get params...because i I do parseQuery "http://example.com/?bla=bla&bla2=bla2" I get  [("http://example.com/?bla",Just "bla"),("bla2",Just "bla2")]
12:51:51 <EvanR> i_am_neuron: here is an example type you can try, data Two a = Two a a
12:51:52 <deni> which is wrong because the frist arguemnt is the url
12:51:53 <ReinH> i_am_neuron: That answer isn't an explanation of Applicative in general, it's a demonstration that a particular structure is an Applicative. It's intended for people who already understand Applicative.
12:51:55 <i_am_neuron> EvanR: I was deconstructing it in GHCi all day today
12:52:04 <Cale> lamda_sage: Evaluation being the process of turning expressions into values
12:52:06 <EvanR> you can see how its a functor probably
12:52:12 <EvanR> but you can also write an applicative instance
12:52:22 <maerwald> > (,) <$> Just 3 <*> Just 5
12:52:23 <lambdabot>  Just (3,5)
12:52:24 <maerwald> > (,) <$> Just 3 <*> Nothing
12:52:26 <lambdabot>  Nothing
12:52:34 <ReinH> i_am_neuron: Try to define Applicative instances for Identity, Maybe, and ((->) e)
12:52:36 <EvanR> if you have Two f g and Two x y, you can make a Two (f x) (g y)
12:52:42 <i_am_neuron> ReinH: Sure. I was just trying to use it as an example of something that is not `Maybe`
12:52:47 <lpsmith> javjarfer, I think having "close" is a good thing,  because it's the one way you can guarantee prompt resource cleanup
12:53:00 <EvanR> i_am_neuron: does my example make sense?
12:53:16 <ReinH> i_am_neuron: Then try to define an instance for [a]. Then consider whether the instance you defined is the only possible instance and, if not, what another one would be.
12:53:23 <lpsmith> not many people will need it,  but if somebody does need it,  it's kinda indispensable.
12:53:29 <i_am_neuron> ReinH: Good idea. `Maybe` I absolutely can, Identity and function may be harder, but seems doable
12:53:31 <ReinH> i_am_neuron: If, once you have done these things, you still don't feel like you understand Applicative, come ask us more questions.
12:53:42 <ReinH> (Or if you have questions while doing these things)
12:54:20 <Cale> Ab123: hey, there is #haskell-gsoc on this network
12:54:27 <lamda_sage> Cale: So does the monad concept fit it's composing IO description into one IO  description for main, and without it you can't compose action?
12:54:31 <Cale> Ab123: maybe put some messages in there and wait around
12:54:32 <i_am_neuron> EvanR: in your example, what's `pure` for `Two`?
12:54:37 <Cale> Ab123: (there are a bunch of people there)
12:54:50 <Ab123> okay ty :)
12:54:52 <EvanR> i_am_neuron: well, what type does pure have?
12:54:56 <ReinH> i_am_neuron: at this point I don't think our explanations will help as much as doing things on your own.
12:55:15 <i_am_neuron> ReinH: Yeah, maybe you're right
12:55:20 <Cale> lamda_sage: Well, even if we didn't recognise the fact that IO was a monad, we'd definitely provide you with enough ways to combine together IO actions to build the programs you want.
12:55:26 <nitrix> > pure (,) Just 3 5
12:55:29 <lambdabot>  (3,5)
12:55:36 <Ab123> Cale: i just questioned the same but no answer :(
12:55:54 <i_am_neuron> EvanR: pure :: a -> f a
12:56:00 <nitrix> i_am_neuron: pure (,) Just, lifts Just into f.
12:56:03 <EvanR> you mean a -> Two a
12:56:11 <Cale> lamda_sage: The fact that IO's combining operations happen to include some operations of the right shape to make it a monad is nice, but not really the essential thing about the way IO is handled differently in Haskell
12:56:12 <i_am_neuron> EvanR: Yes
12:56:15 <EvanR> ok so
12:56:16 <nitrix> :t Just
12:56:18 <lambdabot> a -> Maybe a
12:56:21 <nitrix> :t pure (,) Just
12:56:22 * hackagebot reactive-banana 1.1.0.0 - Library for functional reactive programming (FRP).  https://hackage.haskell.org/package/reactive-banana-1.1.0.0 (HeinrichApfelmus)
12:56:23 <lambdabot> a -> b -> (a, b)
12:56:23 <i_am_neuron> EvanR: But what's the meaning of it?
12:56:23 <Cale> lamda_sage: The essential part is that IO actions *are values* in the first place
12:56:35 <EvanR> i_am_neuron: you need to write a function that takes an a and produces a Two a
12:56:49 <Cale> lamda_sage: and Monad just means that we save writing a bunch of code for common control-structure-like stuff.
12:57:04 <lpsmith> javjarfer, also,  with 0.3,  you can safely use "close" in another thread to safely raise an synchronous exception in another thread that's watching the inotify descriptor.
12:57:04 <Cale> lamda_sage: because it's already written in a way that works for anything that happens to be a monad
12:57:10 <ReinH> lamda_sage: If we had no Monad, we would end up writing a function then :: IO a -> (a -> IO b) -> IO b for composing IO actions together. Monad just says "Oh, that's a pretty commonly shaped function, let's write a typeclass to generalize it."
12:57:32 <lamefun> Is there this operator? (+>) :: Monad m => (e -> m ()) -> (e -> m ()) -> (e -> m ())
12:57:37 <ReinH> lamda_sage: the main benefit of which is now we can just say (>>=) rather than thenIO and thenMaybe and thenList and ...
12:57:50 <i_am_neuron> EvanR: I think fundamental problem here is that I don't understand what would I do this for. If I'm making anything an instance of Functor I'm generalizing a structure-preserving mapping
12:58:03 <i_am_neuron> EvanR: what do I define when I implement `pure`?
12:58:07 <EvanR> well, what is Functor's implementation for Two
12:58:09 <ReinH> and since we can do that, we can now define do notation generally rather than only for IO or only for Maybe or only for etc.
12:58:12 <lamda_sage> I see, this has really cleared up my confusion. There are a lot of bad tutorials out there.
12:58:17 <i_am_neuron> EvanR: One moment
12:58:17 <ReinH> lamda_sage: there isn't much more to the "IO is a Monad" story.
12:58:49 <Cale> lamefun: That's liftM2 (>>)
12:59:03 <Cale> lamefun: where you're using the (->) e monad
12:59:16 <lamefun> Yeah, but I want a short name for that.
12:59:24 <Cale> I don't know of anything shorter still
12:59:35 <ReinH> lamda_sage: "IO is a Monad" means "There's a thing you want to do with IO values that is similar in some way to a thing you want to do with a lot of other values, so let's write a typeclass to generalize it. Furthermore, let's give that typeclass some laws so that, e.g., the usual refactorings you want to do are correct."
12:59:41 <i_am_neuron> EvanR: fmap :: (a -> b) -> Two a a -> Two b b
12:59:49 <lamefun> Cale, oh
12:59:51 <EvanR> thats the type, what does fmap equal
13:00:07 <javjarfer> lpsmith, yes, I saw that, it offers many possibilities, in my case I made a function with this signature Int -> (INBuffer -> IO a) -> IO a
13:00:24 <EvanR> i_am_neuron: er, Two a -> Two b
13:00:35 <lamefun> I'm trying to get rid of JS bits in my Dialog library, Reflex-DOM is too intellectualist for me and doesn't build, GHCJS-DOM is horrendous.
13:00:39 <ReinH> lamda_sage: the laws ensure that, e.g., do { x <- getLine; return x } is the same as just getLine.
13:00:58 <i_am_neuron> EvanR: Something like fmap f t = Two (f a) (f a), where I need to extract `a` from `t`
13:01:00 <javjarfer> lpsmith, the point is that you inject your function inside and resources are freed once the computation ends
13:01:16 <EvanR> i_am_neuron: fmap f (Two x1 x2) = 
13:01:22 * hackagebot reactive-banana-wx 1.1.0.0 - Examples for the reactive-banana library, using wxHaskell.  https://hackage.haskell.org/package/reactive-banana-wx-1.1.0.0 (HeinrichApfelmus)
13:01:24 <i_am_neuron> Yes
13:01:24 <Cale> i_am_neuron: fmap f (Two x y) = Two (f x) (f y)
13:01:46 <EvanR> so that's strictly speaking harder than the exercise for pure
13:01:49 <Cale> i_am_neuron: pure :: a -> Two a
13:01:50 <i_am_neuron> Cale: Ah, right, they are different values, just the type is same
13:01:57 <Cale> i_am_neuron: right.
13:02:21 <benzrf> has anyone managed to convince lamda_sage not to study category theory
13:02:22 <lamefun> I want to be able to do eg. (elem "p" >>= addClass "important" +> setText "This is important!!!") - like in JQuery.
13:02:29 <i_am_neuron> Cale: But what does `pure` mean? I can explain what `fmap` mean, but what about `pure`?
13:02:35 <Cale> benzrf: heh
13:02:41 <i_am_neuron> Cale: But what does `pure` mean? I can explain what `fmap` mean, but what about `pure`?
13:02:42 <lamefun> Is there some existing JQuery library for GHCJS-DOM?
13:02:55 <i_am_neuron> I understand that `Two` is something that binds two values together. It has structure
13:03:02 <Cale> i_am_neuron: Well, most of what it means is contained in its type
13:03:06 <EvanR> i_am_neuron: pure creates a value of the data structure from a single value
13:03:17 <lpsmith> javjarfer, yeah that can be useful,  of course the final action of a "with"-style operator isn't guaranteed to run either,  in cases such as process termination,  but since initializing and closing an inotify descriptor doesn't really have much of an observable effect outside the process, this doesn't matter in this cas.
13:03:19 <i_am_neuron> fmap takes a `Two` and creates it with the same structure, but values are results of function application
13:03:21 <EvanR> similar to monad's return
13:03:29 <EvanR> in fact they have to be the same
13:03:35 <EvanR> but thats irrelevant
13:03:46 <monochrom> you know what, I never found "structure preserving" to be meaningful, either.
13:03:47 <Cale> i_am_neuron: It's a canonical way to turn a value of any type into a container/computation of your type somehow related to that given value
13:04:00 <benzrf> i_am_neuron: intuitively speaking, if you think of 'F A' as meaning some kind of "an A, but with bonus stuff", and you think of (<*>) as combining the bonus stuff, then 'pure' encodes some "bonus stuff" that adds nothing when combined
13:04:02 <benzrf> the identity element of the monoid, as it were
13:04:05 <monochrom> then again, I have long defined "meaningful" to be "falsifiable".
13:04:20 <Cale> i_am_neuron: It's hard to speak in total generality here, because different functors can have quite different qualities to them
13:04:21 <Zekka|Sigfig> benzrf: You said what I was thinking, but didn’t want to be pretentious!
13:04:40 <EvanR> i_am_neuron: well the more interesting thing here is <*>
13:04:43 <monochrom> as opposed to "the wording makes me feel good"
13:05:02 <EvanR> once you have that you can see a use case for pure
13:05:04 <benzrf> Zekka|Sigfig: which thing i said?
13:05:16 <Zekka|Sigfig> benzrf: “the identity element of the monoid, as it were”
13:05:20 <Cale> i_am_neuron: But if you think of values of type f a as being "computations having results of type a", then pure v is the computation which "does nothing" and produces v as its result, whatever it means to "do nothing" in context.
13:05:20 <benzrf> :^)
13:05:32 <Zekka|Sigfig> Thank you for making me feel right.
13:05:40 <Jinxit> it's a good statement
13:05:53 <Cale> i_am_neuron: If you think of values of type f a as "containers holding values of type a", then pure v is something like a "singleton" container holding only v.
13:06:09 <Zekka|Sigfig> Here’s an example of a case where pure v makes sense
13:06:17 <Cale> (as close to a singleton as makes sense for your container)
13:06:21 <Zekka|Sigfig> pure (f x) should equal fmap f (pure x)
13:06:24 <benzrf> Zekka|Sigfig: i don't think it's quite as strong as the actual applicative laws, but you can note that the laws imply that 'liftA2 mappend' should be a monoid operation in which 'pure mempty' is the identity
13:06:28 <Cale> In the case of Two, we have no choice but to duplicate v
13:06:30 <Cale> right?
13:06:39 <Zekka|Sigfig> benzrf: They totally do!
13:06:44 <Cale> But there's really not much choice involved in the implementation
13:06:57 <EvanR> pure 3 evaluates to Two 3 3
13:06:59 <Cale> The type checker will prevent us from doing almost anything else, short of spinning into an infinite loop
13:07:19 <i_am_neuron> EvanR: Let me ask something different. I looked at the implementation of `<*>` for a list today. Why does it do what it does (it applies every function in the functions list to every value in the values list)? Why not do something like zipWith? Was it arbitrary choice or does it reflect what Applicative *is*?
13:07:33 <Zekka|Sigfig> Nontermination is *always* allowed.
13:07:46 <EvanR> i_am_neuron: well, with <*> you can chain them to apply a function of many args to many lists
13:07:46 <Zekka|Sigfig> i_am_neuron: It comes from how pure is defined
13:07:47 <Ainieco> > sum [j,o,h,n,x,x,x,c,e,n,a] -- typechecker can't prevent JOGN CENA
13:07:49 <lambdabot>  0 + j + o + h + n + x + x + x + c + e + n + a
13:07:56 <benzrf> i_am_neuron: well, you can do either... almost
13:08:09 <Cale> Zekka|Sigfig: It's always allowed, but you'd probably be quite unhappy with it!
13:08:10 <benzrf> i_am_neuron: but there's no Monad instance for lists that extends the zip applicative instance
13:08:11 <i_am_neuron> benzrf: There's ZipList also :)
13:08:18 <oisdk_> i_am_neuron It's an arbitrary choice. There exists a wrapper to make <*> use zipWith - ZipList
13:08:27 <ReinH> i_am_neuron: remember when I said to implement Applicative for [a] and ask whether there was an alternative impl?
13:08:28 <Zekka|Sigfig> Cale: Am I unhappy? That depends on whether I’m unhappy.
13:08:36 <benzrf> i_am_neuron: so the instance they went with is the one that agrees with the monad instance
13:08:47 <benzrf> so that you get the same behavior from monad and applicative on lists
13:08:51 <EvanR> i_am_neuron: also once you know this is the behavior you want you can generalize it and ask for any application instead of requiring a list
13:08:58 <EvanR> applicative
13:09:01 <Cale> i_am_neuron: When you get to the Monad instance though, it's not arbitrary any more though -- the zipping version doesn't get you a law-abiding monad.
13:09:04 <ReinH> i_am_neuron: The given implementation is consistent with the "lists as the results of non-deterministic computation" that we have taken to be the canonical interpretation.
13:09:20 <ReinH> i_am_neuron: We could have picked the other one and made this one a newtype. In some sense, it is arbitrary.
13:09:46 <i_am_neuron> ReinH: non-deterministic as in random? I see this term a lot in LYAH and it baffles me
13:09:49 <ReinH> And, like Cale said, it's the version that is consistent with the Monad implementation.
13:09:50 <Cale> i_am_neuron: So in order to have the Applicative instance coincide with the Monad instance, you kind of need to take this one. (Unless you can come up with another instance of Monad for lists, which is probably possible)
13:09:58 <ReinH> i_am_neuron: non-deterministic as in a computation which can produce more than one result.
13:10:01 <Zekka|Sigfig> i_am_neuron: Nah, just in the snense of “more than one outcome"
13:10:07 <javjarfer> lpsmith, yes I was taking more into account the memory buffer used to read from the descriptor than the descriptor itself.
13:10:21 <ReinH> > (,) <$> [1..6] <*> [1..6]
13:10:23 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(3,...
13:10:29 <Cale> But the given instance of Monad for lists is probably the simplest possible and most important one.
13:10:30 <ReinH> i_am_neuron: dice roles are non-deterministic
13:10:53 <Zekka|Sigfig> They’re nondeterministic,but you can always pick a specific one
13:10:53 <Cale> yeah, this computes the list of all possible outcomes from rolling two dice
13:10:55 <ReinH> I have just rolled 2d6 and given you all the possible results using the [a] applicative.
13:10:57 <EvanR> i_am_neuron: so did you complete the implementation of Two and try it out 
13:10:59 <Cale> I like the do-notation here:
13:11:08 <Cale> > do x <- [1..6]; y <- [1..6]; return (x,y)
13:11:10 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(3,...
13:11:14 <Zekka|Sigfig> So for instance you can count how many sum up to seven for the sake of probability
13:11:16 <Ainieco> > (,) <$> [j,o,h,n] <*> [c,e,n,a]
13:11:18 <lambdabot>  [(j,c),(j,e),(j,n),(j,a),(o,c),(o,e),(o,n),(o,a),(h,c),(h,e),(h,n),(h,a),(n,...
13:11:22 * hackagebot blaze-svg 0.3.5 - SVG combinator library  https://hackage.haskell.org/package/blaze-svg-0.3.5 (BrentYorgey)
13:11:30 <Cale> You can read "x <- [1..6]" as "let x be selected (in all possible ways) from [1..6]"
13:11:32 <Zekka|Sigfig> (You can do the silly crap I did a while ago and define a whole *probability monad*)
13:11:37 <i_am_neuron> Alright. So `<*>` in lists is chosen semi-arbitrarily to obey the monadic laws when lists are made into a monad, right?
13:11:38 <jle`> > do x <- [1..6]; y <- [1..6]; return (x + y)
13:11:39 <lambdabot>  [2,3,4,5,6,7,3,4,5,6,7,8,4,5,6,7,8,9,5,6,7,8,9,10,6,7,8,9,10,11,7,8,9,10,11,12]
13:11:43 <Zekka|Sigfig> (pretty sure there’s a library that does this on on hackage)
13:11:47 <csd_> what is :-> ? specifically w.r.t quickcheck?
13:12:20 <Cale> Zekka|Sigfig: sure! I actually do that all the time, since I forget which packages are worth the trouble of using. WriterT (Product Rational) [] works nicely
13:13:00 <Zekka|Sigfig> Cale: Sure, although that one doesn’t guarantee your probabilities all actually add up to 1, and it doesn’t hold up well with respect to filtering, etc
13:13:12 <i_am_neuron> EvanR: let me try implementing Two as an Applicative and come back
13:13:20 <ReinH> i_am_neuron: We have two arbitrary options, but a hard requirement that the Applicative must agree with the Monad instance forces our choice.
13:13:28 * i_am_neuron left implementing...
13:13:30 <Zekka|Sigfig> IIRC I used a little bit of additiona hackery to get a shonky but technically lawful MonadPlus instance for mine
13:13:48 <Zekka|Sigfig> (one that actually worked and guaranteed probabilities would add up to 1)
13:14:38 <jle`> what would mzero be?
13:14:46 <Cale> http://lpaste.net/148442
13:15:01 <osense> hello, I have a question about the Either type: why is it sufficient to only write (Either a) here, rather than (Either a b) https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Either.html#line-128
13:15:13 <EvanR> i_am_neuron: and then run the test (+) <$> Two 1 2 <*> Two 3 4
13:15:17 <jle`> osense: the Functor is (Either a), not (Either a b)
13:15:19 <Ainieco> haven't read whole chat log but JFYI everyone having trouble with typclasses M-word/Applicative/etc should read https://wiki.haskell.org/Typeclassopedia if haven't already
13:15:20 <jle`> consider the type of fmap:
13:15:22 <jle`> :t fmap
13:15:23 <Ainieco> it's greate
13:15:25 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:15:29 <Ainieco> :t fmap fmap fmap
13:15:32 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
13:15:34 <jle`> fmap :: (a -> b) -> Either e a -> Either e b
13:15:37 <Cale> csd_: http://hackage.haskell.org/package/QuickCheck-2.8.1/docs/Test-QuickCheck-Function.html#t::-45--62-
13:15:43 <jle`> osense: the `f` is (Either e), not `Either e a`
13:15:59 <jle`> look at where the `f` is, and see what `f` is in the specialized type signature
13:16:05 <kadoban> osense: It's not only sufficient, it's required.   (Either a b) wouldn't work, (Either a b) isn't the correct kind to be a Functor. Neither is Either.  (Either a) is though.
13:16:09 <jle`> fmap :: (a -> b) -> (Either e) a -> (Either e) b
13:16:23 <jle`> (Either a b) wouldn't make any "sense" to put in there for `f`
13:17:00 <jle`> if i wrote a Functor instance for (Either e k), then i'd have fmap :: (a -> b) -> Either e k a -> Either e k b ... which doesn't make any sense
13:17:19 <csd_> Cale: I saw that and didn't understand what it meant
13:17:25 <jle`> if I wrote a Functor instance for `Either`, i'd have fmap :: (a -> b) -> Either a -> Either b, which also makes no sense
13:17:25 <Cale> csd_: It's basically a type which you're meant to think of as a function type, but which has more internal structural representation so that a pretty Show instance can be written
13:17:37 <Cale> csd_: If you look at the source code for the module, it might make more sense...
13:18:00 <Cale> csd_: scroll up a little from here: http://hackage.haskell.org/package/QuickCheck-2.8.1/docs/src/Test-QuickCheck-Function.html#showFunction
13:18:17 <jle`> osense: it's the same deal for, say, the Functor instance for Maybe
13:18:35 <jle`> osense: you don't write a Functor instance for (Maybe a), becuase (Maybe a) isn't the Functor
13:18:38 <jle`> Maybe is the Functor
13:18:42 <Cale> and yeah, look at the definition of 'table'
13:18:48 <jle`> osense: fmap :: (a -> b) -> Maybe a -> Maybe b
13:18:55 <Cale> csd_: ^^
13:19:02 <jle`> fmap :: (a -> b) -> f a -> f b    -- here, the `f` is Maybe
13:19:17 * i_am_neuron implements Applicative like a robot
13:19:20 <csd_> Cale: what does it mean to have a symbol like that in a `data` definition? i haven't seen that before
13:19:26 <i_am_neuron> EvanR: Here: http://lpaste.net/148443
13:19:33 <EvanR> i_am_neuron: its pretty straightforward really... for almost all types
13:19:35 <Cale> csd_: :-> is the name of the type constructor we're defining
13:19:47 <i_am_neuron> EvanR: the result of your test is Two 4 6
13:19:55 <jle`> csd_: it's not particularly special, it's kind of like how you can have functions have letter names or operator names
13:19:57 <csd_> Cale: so it's an infix definition ?
13:20:01 <EvanR> i_am_neuron: great. now understand the test
13:20:02 <Cale> csd_: It's like if we'd written something like  TabulatingFunction a c
13:20:03 <i_am_neuron> EvanR: BUT! I don't understand what I've just done -- it was super mechanical
13:20:03 <Cale> yeah
13:20:05 <jle`> csd_: (+) isn't particularly special compared to `plus`
13:20:20 <csd_> i was confused by it's infixity
13:20:29 <osense> jle`: I see, thanks :)
13:20:38 <EvanR> i_am_neuron: <$> = fmap
13:21:01 <i_am_neuron> EvanR: Yes
13:21:30 <EvanR> you applied two functions of two arguments two two twos
13:21:38 <Cale> i_am_neuron: The mechanical stuff that you've already done is the vast majority of what there is to understand about it.
13:21:52 <i_am_neuron> Cale: Hmmmm...
13:22:05 <Cale> i_am_neuron: It's possible to write down lots of nice properties that these functions end up satisfying, and maybe that counts as more understanding
13:22:06 <monochrom> I don't think being mechanical is an opposite of understanding.
13:22:31 <i_am_neuron> Cale: I sorta see why I would need to implement Functor... But what kind of a real world need would require implementing Applicative?
13:22:32 <monochrom> in fact, there is an authority that backs me up, if you're the seek-authority kind.
13:22:38 <deni> why does haskell have so many text types. There's String....there's Text...ByteString.... (and then the lazy counterparts) ... can I just pick one and stick with it? can someone explain in "big picture" terms what's the difference between all of these?
13:22:48 <EvanR> i_am_neuron: so when you have a functor, if it makes sense to apply a container of functions to a container of arguments, its applicative
13:22:51 <Cale> i_am_neuron: but trying to express vague interpretations of what's going on in English will ultimately be less satisfying than just reading the very short and easy code
13:22:58 <maerwald> deni: String can be slow if you deal with a lot of data
13:23:03 <i_am_neuron> Cale: This is the question that I'm after
13:23:05 <maerwald> Text is faster there
13:23:13 <Cale> i_am_neuron: Okay, well, first, do you understand Monad?
13:23:19 <maerwald> ByteString can be used for more than just human-readable text
13:23:57 <jle`> deni: bytestring isn't a text type
13:24:06 <Cale> It's hard to motivate Applicative properly if you don't already grasp Monad, and that's sort of why I think it shouldn't be taught before Monad, even if it does sort of logically fit in between Functor and Monad.
13:24:08 <jle`> that's like saying Byte is an integer type
13:24:11 <kadoban> deni: Well for starters ByteString is different, it's just plain bytes. You'd need to pick an encoding and then decode it to get a String or something similar. String is the naive way you'd implement character strings in terms of Char, which are unicode codepoints.
13:24:12 <deni> maerwald: then there's a plethora of functions in various libraries that work with one but not the other.... 
13:24:16 <pilne> a langauge that attempts to handle all possible abstractions of "string" the same can create some really akward corner-cases (see major blowup on python2 to python3 handling of strings... (un?)CIVIL WAR!!!)
13:24:27 <i_am_neuron> Cale: Yes. Monad is a set with a zero element and one operation that obeys associative laws
13:24:29 <kadoban> deni: Text is a more performant way to model text compared to String.
13:24:34 <EvanR> deni: String is the way it is for historical / teaching purposes. Text would be a better default string type
13:24:36 <Cale> i_am_neuron: no, you're thinking of a monoid
13:24:39 <monochrom> deni: String was there first, and it was made [Char] in a vision to reuse all Data.List utilities
13:24:45 <i_am_neuron> Cale: Oh, sorry, yes
13:24:47 <hodapp> well, I for one like Python 3's approach to bytestrings vs. Unicode strings
13:24:55 <EvanR> ByteString is something else entirely
13:24:58 <jle`> deni: String doesn't have too much purpose other than for teaching and convenience; text is the only actual text type of the ones you list
13:25:01 <javjarfer> lpsmith, is anything you don't like about my approach?
13:25:06 <deni> pilne: agreed on python2/3
13:25:09 <i_am_neuron> Cale: No, I don't know it yet then
13:25:20 <pilne> i do too hodapp, i like python3 a helluva lot more than python2, but it caused major major turmoil in the land of shrubberies....
13:25:23 <monochrom> but that was also a time of not being too aware of memory costs etc. Text had to be created later for that.
13:25:24 <maerwald> jle`: String is used a lot in real-world code
13:25:25 <Cale> i_am_neuron: (there *is* a way to look at monad like that, but it's *wayyyyy* off course, like a few hours' worth of category theory definitions)
13:25:30 <maerwald> but not fore large chunks of data
13:25:30 <kadoban> hodapp: Isn't that basically the same as ByteString vs. Text ?
13:26:01 <Cale> i_am_neuron: It's easier to understand monads just in terms of Haskell and not worry about how they're abstractly similar to monoids.
13:26:03 <maerwald> because String is very easy to work with and convenient for small things (e.g. argument parsing or whatever)
13:26:12 <jle`> maerwald: in most real-world cases, it's for convenience.  in others it's for treating things as character streams
13:26:25 <jle`> yeah, mostly for convenience
13:26:34 <jle`> doesn't make it a smart idea for a text type
13:26:38 <i_am_neuron> Cale: OK, let's pause monads for now -- is there a way to understand Applicative as an algebraic structure or smth from category theory?
13:26:42 <EvanR> well Text would be more convenient if that was what the args were given as ;)
13:26:42 <monochrom> Bytestring was originally created in a mistake of confusing a byte with a character because the creators knew ASCII only. now we have corrected its mission statement to "for bytes".
13:26:45 <i_am_neuron> Cale: I did math in the university
13:26:54 <i_am_neuron> Cale: I sort know rings, fields, groups, etc
13:27:05 <i_am_neuron> Cale: But this bloody Applicative!!
13:27:08 <Cale> i_am_neuron: It is roughly a monoidal functor
13:27:12 <EvanR> Applicative was discovered as a cool thing you can do in haskell, i think
13:27:19 <Cale> From the monoidal category (Hask,(,),()) to itself
13:27:30 <jle`> i_am_neuron: you can think of it a way of "squishing" two Functor's together in a way that behaves nicely
13:27:32 <EvanR> backported to category theory for the sake of it
13:27:32 <Cale> however, (<*>) obscures this
13:27:35 <hodapp> kadoban: Perhaps.
13:27:44 <jle`> i_am_neuron: i have an `IO a` and an `IO b`, is there any way I can combine it into one IO action?
13:27:48 <jle`> you can't do it with Functor
13:27:56 <jle`> but Applicative gives you (a -> b -> c) -> IO a -> IO b -> IO c
13:28:05 <Cale> liftA2 (,) is the usual natural transformation which you'd provide in CT
13:28:06 <dolio> Applicatives are lax closed monoidal functors.
13:28:07 <jle`> give a combining function, and it combines two IO's
13:28:19 <Cale> liftA2 (,) :: (f a, f b) -> f (a,b)
13:28:33 <i_am_neuron> jle`: But this all makes sense when your function is also within IO, like this: `IO (a -> b)` -- maybe arrived via network?
13:28:44 <i_am_neuron> Cale: monoidal functor... hmmm...
13:28:45 <Cale> https://en.wikipedia.org/wiki/Monoidal_functor
13:28:52 <jle`> if i had a `Maybe Int` and a `Maybe Int`, how can I "add them together"?  you can't do it wiht Functor alone
13:28:59 <jle`> but you can "squish" two Maybe's together with Applicative
13:29:03 <deni> I understand that I can represent string literal as text by using OverloadedStrings.....but how do I convert a String to Text if a functions spits out a String and how do I convert Text to Bytestring if one function outputs Text and the other requires bytestring?
13:29:03 <jle`> > liftA2 (+) (Just 3) (Just 10)
13:29:05 <lambdabot>  Just 13
13:29:24 <EvanR> i_am_neuron: liftA2 _ _ _ = _ <$> _ <*> _
13:29:30 <i_am_neuron> Cale: OK, will need time to digest the link
13:29:51 <jle`> i_am_neuron: you can combine an IO (a -> b) with an IO a with liftA2 ($)
13:29:54 <jle`> :t liftA2 ($)
13:29:55 <lambdabot> Applicative f => f (a -> c) -> f a -> f c
13:29:56 <i_am_neuron> One more thing: Functors clearly predate Applicatives, right?
13:29:57 <Cale> i_am_neuron: Yeah, it's not exactly something you're likely to have seen unless you're a category theorist
13:30:00 <deni> monochrom: jle`  maerwald kadoban EvanR also should I then just stick with Text for everything and just convert when I need to?
13:30:02 <lamefun> Are there typed quasiquoters like TExp?
13:30:12 <i_am_neuron> But does Monad/Monoid predate Applicative too or is it the other way around?
13:30:13 <maerwald> deni: depends on what you do
13:30:17 <Cale> i_am_neuron: Yeah, in terms of Haskell, Functor and Monad came in before Applicative
13:30:27 <kadoban> deni: Text should probably be your default, for anything that's going to be handling actual decent amounts of data.
13:30:28 <Cale> Monad and Functor were introduced at the same time
13:30:30 <jle`> if I have an `f a` and `f b`, there isn't any way to "combine" them into one giant `f c` with just Functor.  Applicative gives us a way
13:30:34 <monochrom> I take it that "everything" just means "every text-for-humans thing". then yes.
13:30:46 <Cale> (though really it's Monad that motivated this way of looking at the world)
13:30:52 <maerwald> if you are dealing with filenames, no one is going to convert them to Text
13:31:01 <monochrom> ah, true that
13:31:10 <jle`> well, it depends on what library gives you your filenames
13:31:17 <EvanR> deni: String comes up a lot, but its not that hard to pack a String into Text at the boundaries
13:31:19 <jle`> in an ideal world you'd get them as Text
13:31:21 <deni> maerwald: filenames are going to be string is what you're saying?
13:31:27 <i_am_neuron> Cale: when you're saying that Applicative is a monoidal functor, are there any important elements there?
13:31:27 <maerwald> yes
13:31:35 <monochrom> filenames are a really thorny and OS-dependent story. Windows says it's Text. Linux says it's Bytestring.
13:31:38 <Cale> i_am_neuron: Probably it makes more sense to understand just Monad first, and worry about Applicative later, since the number of practical examples of Applicatives which are not also Monads is *really* small
13:31:41 <Cale> (like maybe 2)
13:31:48 <i_am_neuron> Cale: I.e. in Monoid, you have a single element that always maps to itself (I think)
13:32:08 <EvanR> no
13:32:08 <pilne> windows should just standardize to linux standards wherever possible... can i get an amen? :p
13:32:10 <Cale> i_am_neuron: okay, so we're collapsing the definition as you'll see it on Wikipedia a bunch
13:32:22 <deni> EvanR: maerwald for instance...I get a --url URL passed as a string..I then convert it to text...but then http-types requires ByteString for parsing the query params
13:32:30 <shachaf> monochrom: ByteString without \0s, in particular.
13:32:40 <monochrom> and System.IO says "let's go with String but I will do an unknown conversion"
13:32:43 <Cale> i_am_neuron: both of the categories C and D are the category whose objects are Haskell types and whose arrows are Haskell-definable functions between them
13:32:53 <EvanR> deni: raw IO will always want a ByteString, in which case you need to utf8 encode. this is not haskell-specific
13:33:13 <i_am_neuron> Cale: Alright, I'll go through Monads first then
13:33:26 <Cale> i_am_neuron: the "tensor product" and "bullet" operations on objects (the bifunctors from the monoidal structure) are chosen to be the pair type constructor (,)
13:33:32 <deni> EvanR: my problem is that I never actually learned this stuff properly....the actual representations of strings in other languages...coming from python :/
13:33:38 <EvanR> deni: indeed
13:33:42 <EvanR> time to learn
13:33:55 <Cale> i_am_neuron: and the I's, the "tensor units" are the empty tuple type ()
13:33:58 <deni> EvanR: are there any resources that concisely explains this?
13:33:58 <monochrom> you can find out what python does, too
13:34:11 <EvanR> deni: try "what every programmer should know about unicode" or something
13:34:23 <deni> ah i know that one :D never read through it though
13:34:29 <i_am_neuron> Cale: OK, this is helpful, will keep in mind when reading
13:34:30 <kadoban> deni: http://nedbatchelder.com/text/unipain/unipain.html , it's in python but has the right concepts for this too.
13:34:31 <deni> (if we're talking about the same article)
13:34:34 <EvanR> i just made that up
13:34:37 <Cale> i_am_neuron: So, the definition of a monoidal functor says there's a specified arrow I_D -> F I_C, well, that would be  () -> f ()
13:34:37 <StoneToad> lol
13:34:50 <zachk> string = a sequence of character, where what a sequence is and what a character actually varies from language to language, and library to library 
13:34:54 <deni> EvanR: no but there's actually an article with a title that something like that
13:34:57 <monochrom> I think it's going to be an interesting story of transitioning from "a character has 8 bits" to "a character is a unicode codepoint" if you look at its history
13:35:09 <deni> EvanR: i vaugely remember it...I might be confusing it with something will re-check
13:35:13 <zachk> how big can a unicode point be? 
13:35:14 <EvanR> deni: hmm. well let me try to find a good one i remember from the old days
13:35:22 <deni> kadoban: will check that out tnx.
13:35:23 <StoneToad> monochrom: shame that that makes it so much harder to process things
13:35:31 <StoneToad> zachk: unbounded theoretically
13:35:33 <monochrom> the notion of "8-bit chararacter" is still in the processing of dying a century-long death
13:35:40 <monochrom> s/processing/process/
13:35:49 <Cale> i_am_neuron: okay, but if we have one of those, i.e.  one :: () -> f ()  then we can write a function pure :: a -> f a by   pure v = fmap (const v) one
13:36:13 <monochrom> and that century begun only at about 2000
13:36:15 <deni> EvanR: kadoban maerwald so let's say a rule of thumb is use Text for anything human readable. Raw IO will be ByteString...and then just convert between those when needed for various libraries.
13:36:18 <StoneToad> zachk: the longest i've heard of in utf8 I think is 8 bytes or something?
13:36:23 <Cale> er,  pure v = fmap (const v) (one ()) rather
13:36:27 <monochrom> we still have some 84 years to go!
13:36:27 <i_am_neuron> Cale: what is `const`?
13:36:33 <Cale> const x y = x
13:36:38 <Cale> it makes constant functions
13:36:48 <deni> also does that mean that optparse-applicative should get stuff from the CLI as bytestring? 
13:36:55 <deni> currently i model that as String
13:36:56 <EvanR> deni: well. here https://www.cl.cam.ac.uk/~mgk25/unicode.html
13:37:01 <kadoban> deni: The linked site has advice on that.
13:37:07 <i_am_neuron> OK
13:37:09 <Cale> i.e. you should read that as (const x) y = x
13:37:12 <ReinH> pilne: I mean, they changed Windows 9 to Windows 10 because of absolutely idiotic backwards compatibility issues. Can you imagine trying to change the semantics of the filesystem?
13:37:16 <monochrom> oh heh, what does optparse-applicative give you at present?
13:37:25 <deni> kadoban: I see......Okay time to read then...will come back if I have more questions....
13:37:31 <kadoban> deni: But basically, convert to a type like Text as soon as you can, encode into an encoding like UTF-8, possibly in a ByteString as late as you can.
13:37:32 <i_am_neuron> Thanks for the explanation everyone -- I'll stick with Monads for now then
13:37:37 <StoneToad> zachk: apparently I'm wrong, stackoverflow says the current RFC lists 4 bytes for the max char, older spec gave 6 for max
13:37:42 <i_am_neuron> I.e. with learning Monads
13:37:50 <Cale> i_am_neuron: Understanding this theory is *entirely* unnecessary and probably unhelpful, btw
13:37:58 <pilne> the struggle it would present them makes me laugh ReinH :p
13:38:00 <Cale> i_am_neuron: I'm just doing it for enrichment's sake
13:38:00 <i_am_neuron> Cale: hmmm, really?
13:38:01 <deni> EvanR: tnx for the link. Will read that one as well.
13:38:12 <EvanR> deni: *burns utf-8 encoding into deni's heart*
13:38:13 <Cale> i_am_neuron: since you said you were interested in the mathematics
13:38:16 <i_am_neuron> Cale: So we're back to square one
13:38:24 <i_am_neuron> :(
13:38:26 <Cale> i_am_neuron: It's better to just understand these classes by looking at examples
13:38:32 <ReinH> i_am_neuron: Another option is to learn the Monad typeclass and then learn Applicative as a particular subset of Monad (the one given by return and ap).
13:38:38 <Cale> By the time you've seen 10 examples of each, you'll get it
13:38:43 <deni> EvanR: utf8 all the way :D
13:39:02 <deni> tnx everyone for your help.
13:39:04 <Cale> They're patterns which show up in code
13:39:16 <Cale> in the style of libraries we tend to write
13:39:18 <jle`> i_am_neuron: the point is that none of this exploration will probably be useful to your actual day-to-day coding.  it's just questions for the sake of curiosity alone
13:39:24 <ReinH> i_am_neuron: you will miss out on Applicatives which are not also Monads, but there are relatively few of these and it is instructive to examine them on their own in the context of why they can't be made monads.
13:39:34 <i_am_neuron> Cale: what are the 10 examples? `Maybe` is trivial (just like `Two`, I can implement it mechanically), `Either` too, `[]` contains some arbitrarily-chosen implementation, `IO` is way too complex... :(
13:39:39 <Cale> and they abstract over things which were already frequently occurring before we ever had these names for them
13:39:42 <jle`> if you're expecting that learning this will help you with coding haskell, then you will be disappointed
13:39:50 <jle`> if you're learning it just for the sake of learning, then go ahead!
13:39:57 <Cale> i_am_neuron: I think the example which made everything click for me was Parser
13:39:58 <monochrom> I think optparse-applicative gives you whatever getArgs gives you at present, which is String. getArgs does an unknown conversion. actually, it can be known, it's whatever your locale says.
13:39:58 <ReinH> i_am_neuron: it's always fun and instructive to write your own parser combinator library.
13:40:08 <Cale> But if you haven't been looking at the Monad implementations for all those things, please do
13:40:10 <ReinH> Cale: ugh you beat me by 0.5 seconds
13:40:17 <i_am_neuron> jle`: No, I hope this will help me program better
13:40:22 <jle`> oh
13:40:27 <i_am_neuron> jle`: In any language
13:40:30 <jle`> then, this might not be a useful fork to go down
13:40:34 <i_am_neuron> jle`: Oh
13:40:36 <jle`> this might not be a good path to go down
13:40:46 <pilne> most languages don't tend to implement things with monads....
13:40:49 <adamCS> i_am_neuron:  Reader and State can be helpful for understanding as well...
13:40:50 <Cale> i_am_neuron: Unfortunately, Monad is almost useless as a concept in most languages which are not Haskell
13:40:51 <ReinH> i_am_neuron: if you write an applicative Parser, it will be quite clear why you want the additional power of Monad.
13:40:53 <pilne> because they are DIIRRRRRRRRTYYYYYYY
13:41:01 <Cale> i_am_neuron: You pretty much *need* type classes to make it not horrible
13:41:10 <ReinH> And higher kinded types
13:41:11 <monochrom> an easy way to generate 10 examples: data One a = MkOne a; data Two a = MkTwo a a; data Three a = MkThree a a a; ...
13:41:12 <Cale> yes
13:41:15 <jle`> i_am_neuron: a more practical thing to do would be to use *data*, pure data, and functions on data
13:41:19 <i_am_neuron> Well, let's put it like this: I'm on a big hunt for something that will make me a better programmer
13:41:32 <Edina> Hi
13:41:35 <i_am_neuron> Because everywhere I look I see leaking abstractions
13:41:35 <pilne> although apparantly clojure has monads availiable for some odd reason... (being a lisp dialect with macros... i'm not really sure why it would use them)
13:41:42 <EvanR> i_am_neuron: the IO applicative is basically as simple as the one for Two
13:41:46 <jle`> Monad, Applicative, and Functor, etc. are only common interfaces to helping you work with data, but the fact that tehy're monads, functors, applicatives isn't the important part to how they are useful
13:41:49 <ReinH> i_am_neuron: I think understanding how Haskell uses monads will give you an appreciation for side effects in other languages, and how you can control them.
13:41:51 <jle`> they're useful because the data itself is useful
13:41:55 <EvanR> i_am_neuron: however i heard that it violates the applicative laws somehow
13:41:59 <Cale> i_am_neuron: Well, fair enough, learning Haskell will teach you to think a certain way, which will make you more cautious in languages which are less safe.
13:42:06 <jle`> IO isn't useful because of Monad.  IO is useful because of how it's constructed.
13:42:11 <jle`> because of properties of the IO type
13:42:21 <i_am_neuron> Cale: I'm not so much after safety as after composability and extensibility
13:42:24 <jle`> Monad doesn't give IO any extra power.  IO itself has all the power
13:42:29 <ReinH> jle`: among which are the monad properties ;)
13:42:30 <EvanR> heh IO is constructive?
13:42:34 <EvanR> i took it as axiomatic
13:42:40 <i_am_neuron> Cale: In OOP code abstractions leak left and right
13:42:46 <monochrom> an easy way to generate another 12 new examples: data FirstDay a = One a; data SecondDay a = Two a a | One a; data ThirdDay a = Three a a a | Two a a | One a a; ...
13:42:51 <jle`> that's like saying integers are useful because they're rings
13:42:52 <ReinH> instance Monad IO is a claim that IO abides the monad laws.
13:42:59 <jle`> integers are useful because integers are useful
13:43:07 <jle`> we use them every day
13:43:09 <Cale> i_am_neuron: Yeah, you'll get a lot of that too, but mostly you'll realise that all the nice composable and extensible solutions won't work out in many other languages, and you'll be frustrated about it.
13:43:20 <ReinH> jle`: Often under the assumption that they are rings.
13:43:21 <jle`> the fact that they have a nice ring structure gives you some properties to analyze in a generic way, cool
13:43:54 <pavolzetor> stack exec does not allow to pass +RTS, is this by design or should I report bug?
13:43:56 <i_am_neuron> Cale: Currently I'm frustrated and get very little composability :) So it could be a win!
13:44:02 <Cale> haha!
13:44:03 <ReinH> pavolzetor: you probably need a --
13:44:18 <ReinH> pavolzetor: stack exec foo -- +RTS ... perhaps
13:44:36 <ReinH> I believe the answer is some number of -- greater than zero.
13:44:43 <ReinH> and probably less than, say, 10
13:44:59 <dolio> Less than Graham's number.
13:45:11 <geekosaur> it may need a --RTS
13:45:14 <adamCS> ReinH:  Yes.  One "--" shold do it.
13:45:26 <adamCS> ReinH: s/shold/should/
13:45:31 <ReinH> dolio: that seems likely.
13:45:33 <geekosaur> one --RTS to stop stack from reding it, then +RTS applies to what stack exec runs
13:45:59 <Cale> i_am_neuron: Okay, so let's look at Monad and Parser...
13:46:05 <Cale> (in some order!)
13:46:06 <ReinH> (In fact, I believe that there are answers using an arbitrary number of --.)
13:46:10 <i_am_neuron> Monad first
13:46:13 <monochrom> Parser first
13:46:19 <ReinH> At the same time!
13:46:20 <adamCS> ReinH: fair enough
13:46:29 <Cale> I think Parser first is probably right :)
13:46:37 <Cale> It's good to have a concrete example
13:46:43 <i_am_neuron> Question: is Parser a Functor?
13:46:50 <Cale> and then you'll have a handle on *what* we're generalising
13:46:52 <Cale> it will be
13:46:58 <ReinH> i_am_neuron: let's start with the question: what is Parser?
13:46:59 <i_am_neuron> Will it be Applicative?
13:47:03 <Cale> Every instance of Monad will be an instance of Functor and Applicative
13:47:06 <EvanR> ContT over a RandomT over IO
13:47:11 <EvanR> should be pretty simple
13:47:15 <i_am_neuron> ReinH: OK, let me think
13:47:15 <Cale> and every instance of Applicative will be an instance of Functor
13:47:16 <pavolzetor> thanks, I will file a bug so docs are updated
13:47:24 <monochrom> I love ContT
13:47:28 <Cale> i_am_neuron: You don't have to think, I have to define :)
13:47:30 <ReinH> i_am_neuron: I think we will allow Cale to do the thinking on that one.
13:47:38 <i_am_neuron> Oh
13:47:57 <ReinH> But which Parser do we use? Hmm.
13:47:57 <EvanR> ContT is cool for doing something IO cant
13:48:08 <i_am_neuron> Parser maps [Char]s to Maybe [Token]s, no?
13:48:17 <i_am_neuron> (from the top of my head)
13:48:26 <ReinH> Close.
13:48:35 <monochrom> Cale is telling the story, so it's Cale's Parser.
13:48:44 <ReinH> Gather round children.
13:48:48 <i_am_neuron> Ooooh
13:48:57 <Cale> i_am_neuron: So, Parser will be a type constructor such that values of type  Parser t  will represent programs that when given some input String, will attempt to consume some characters from the beginning of the input, and produce a list of possible parses, each of which will consist of a successfully parsed value of type t, and the remainder of the input
13:49:05 <ReinH> In a land where functions can return other functions, one man...
13:49:21 <i_am_neuron> Cale: OK
13:49:21 <Cale> This list will usually have one element in the successful case, but it may be empty if the parse fails, and it may have multiple elements if the parse is ambiguous
13:49:38 <Cale> So let's write the declaration:
13:49:40 <pilne> does this tale involve a war between the dragons Vim and Emacs?
13:49:41 <pilne> :p
13:49:41 <i_am_neuron> So it's a list of all possible ASTs
13:49:59 <Cale> newtype Parser a = P (String -> [(a, String)])
13:50:18 <Cale> i.e. a parser for things is a function from strings to lists of pairs of things and strings.
13:50:35 <Cale> (to channel Dr. Seuss)
13:50:41 <i_am_neuron> What is `a` in some real-world applications?
13:50:47 <mniip> anything
13:50:51 <pilne> a can be anything
13:51:05 <Cale> A parser which tried to read a number might have type Parser Integer
13:51:07 <i_am_neuron> Alright
13:51:08 <EvanR> you parse ConfigFile by using parsers for String or Int or whatever
13:51:24 <monochrom> ReinH: one man can return another man?
13:51:26 <mniip> P reads :: Read a => Parser a
13:51:30 <Cale> A parser which parses an entire source file might have type Parser Module where Module is some complicated abstract syntax tree type
13:51:46 <i_am_neuron> Cale: OK, with you
13:52:18 <Cale> We might even have a parser which consumes some initial portion of its input and results in yet another parser of some sort, being of type Parser (Parser a)
13:52:22 <pilne> the constraint is that the a on the LHS has to be the same as the a on the RHS of the definition
13:52:32 <pilne> same type
13:52:47 <Cale> (that's a little funny, but it may come back to us later)
13:53:04 <pilne> a curried parser?
13:53:10 <ReinH> monochrom: what two consenting men return is none of my business.
13:53:26 <Cale> So first on the agenda, let's write
13:53:38 <Cale> runParser :: Parser a -> String -> [(a,String)]
13:53:51 <Cale> I've optimised our representation of parsers for making this function trivial to write
13:54:03 <i_am_neuron> OK, cool
13:54:11 <Cale> All we do is unpack the P data constructor and apply the function:
13:54:16 <Cale> runParser (P f) s = f s
13:54:21 <Cale> or indeed:
13:54:25 <Cale> runParser (P f) = f
13:54:58 <i_am_neuron> All good, but we gotta make sure that the `f` iwthin Parser is a proper parsing function
13:55:09 <Cale> sure
13:55:25 <Cale> So now the plan is to write a bunch of basic primitive parsers, and then ways to combine and build up more complex parsers from simpler ones
13:55:28 <nitrix> I had to use a library (linear) that defines a type Point with a data constructor P and it made me angry.
13:55:37 <nitrix> `P` is a little too common.
13:56:12 <Cale> nitrix: fair enough, but I didn't want to use Parser for this discussion, because I want to make it clear when I'm talking about the data constructor vs. the type constructor
13:56:13 <EvanR> EdK.P ;)
13:56:29 <ReinH> nitrix: It's much nicer to use a pattern synonym anyway: pattern Point x y = P (V2 x y)
13:56:41 <nitrix> Cale: Oh oh, I wasn't bashing you or anything. Just a running thought.
13:56:45 <monochrom> short names in IRC examples are ok.
13:56:49 <nitrix> ReinH: That exists!?
13:56:59 <ReinH> nitrix: it does immediately after you define it.
13:57:01 <monochrom> short unexported names are also ok.
13:57:27 <ReinH> pattern synonyms are a largely unappreciated way to declutter newtype wrappings
13:57:43 <nitrix> ReinH: Is pattern restricted to pattern matching? Does it shadow types?
13:57:46 <Cale> i_am_neuron: Okay, so the first thing I think I want to do is to write a parser which will look at the first character of the input, apply some predicate to it, and if that predicate succeeds, it simply results in the character it read, and otherwise, the parse fails
13:57:54 <ReinH> nitrix: it is both a pattern and a constructor.
13:57:57 <Cale> satisfy :: (Char -> Bool) -> Parser Char
13:57:59 <i_am_neuron> Cale: good idea
13:58:14 <ReinH> e.g. swap (Point x y) = Point y x
13:58:34 <nitrix> That is absolutly brilliant.
13:58:40 <nitrix> ReinH: You made my day <3
13:58:44 <ReinH> Cale: Do you think it would help you and i_am_neuron to move the parser discussion to #haskell-overflow or similar? I don't mind it here at all, but it might be easier for you two.
13:58:45 <Cale> satisfy p = P ... -- so we know we want to produce a Parser, we have no way to do that yet but to apply the data constructor P
13:58:54 <Cale> oh, yes, that's a good plan
13:58:59 <Cale> I usually do that :)
13:59:27 <pavolzetor> I did some profiling (I am using parListChunk) for the ray tracer; -N1, 365s, productivity 85%; -N2, 192s, productivity 82%; -N4, 115s, productivity 73%; -N8, 74s, productivity 60%; -N16, 60s, productivity 40%; -N32, 54s, productivity 25%
13:59:29 <i_am_neuron> ReinH: Thanks
13:59:35 <ReinH> nitrix: I am representing a hex grid with various coordinate systems so I have newtype Axial a = MkAxial (V2 a) and pattern Axial x y = MkAxial (V2 x y) and similar for Cubic, Offset, etc.
13:59:39 <ReinH> nitrix: it's really nice
13:59:59 <pavolzetor> why does the garbage collection time increases so much with respect to the core count?
14:00:12 <pavolzetor> the number of sparks is fixed
14:00:38 <ReinH> pavolzetor: I recommend Simon's book for help analyzing RTS behavior, including GC.
14:00:50 <pavolzetor> ReinH: I read first 4 chapters ;)
14:00:54 <pavolzetor> and paper
14:01:03 <ReinH> pavolzetor: ok :)
14:01:18 <pavolzetor> it seems that it pauses on GC
14:01:21 <ReinH> pavolzetor: I'm not sure that the correlation with core size is causative.
14:02:09 <ReinH> pavolzetor: Oh
14:02:17 <ReinH> You mean cores as in processor cores
14:02:19 * ReinH sighs
14:02:38 <pavolzetor> yes, the -Nx flag
14:03:07 <pavolzetor> let me do run with -N64
14:03:20 <monochrom> you have 64 cores?!
14:03:47 <pavolzetor> it seems I need to do different work partitioning, maybe tiles
14:04:15 <monochrom> . o O ( "no no, -N64 means running on a Nintendo 64" )
14:04:18 <pavolzetor> but even in the paper, there was one problem, I think minmax where GC was taking almost half of the time; I would be interested how to reduce the GC
14:04:27 <pavolzetor> monochrom :)
14:04:58 <pavolzetor> actually with -N64, produtivity 13% and 63 sec time; so it is slower than 32 cores
14:05:13 <pavolzetor> I do not understand that
14:05:42 <pavolzetor> monochrom: the machine has 72 cores (144 HW threads)
14:05:53 <monochrom> scary
14:06:17 <dedgrant> pavolzetor: Amdahl's law rearing its head at some level. Does the amount of garbage track with the GC time?
14:06:19 <ReinH> monochrom: implement a VR4300 emulation and then compile your program to VR4300 machine code then execute your program in your program.
14:06:43 <pavolzetor> monochrom: good for testing scaling, also has quite a bit of ram (3 TB)
14:06:45 <ReinH> [YO DAWGING INTENSIFIES]
14:07:34 <pilne> holy shit i want
14:08:21 <pavolzetor> dedrant: almost forgot, I will check in threadscope
14:08:37 <pavolzetor> I had this problem with sphere scene, where the work was just too small
14:08:43 <pavolzetor> let me crank up the complexity
14:10:33 <pavolzetor> I just increased the complexity by factor of 64
14:11:08 <pavolzetor> dedgrant: what do you mean amount of garbage track with GC time?
14:12:32 <ReinH> pavolzetor: look at the performance and analysis sections of http://chimera.labs.oreilly.com/books/1230000000929/ch03.html
14:12:59 <ReinH> pavolzetor: plenty of relevant stuff in there
14:13:10 <pavolzetor> ReinH: I do not understand the english sentence ;)
14:13:24 <ReinH> pavolzetor: which sentence?
14:13:33 <pavolzetor> "Does the amount of garbage track with the GC time?"
14:13:44 <ReinH> pavolzetor: Oh, that wasn't a response to that question.
14:13:49 <ReinH> It's just a general suggestion
14:14:09 <pavolzetor> thanks, it does a lot of GC at the end (image writing)
14:14:10 <ReinH> pavolzetor: but the meaning is is the amount of garbage correlated with the GC time?"
14:14:16 <ReinH> s/is is/is "is
14:14:29 <pavolzetor> I see, thanks, let me check
14:16:58 <dedgrant> pavolzetor: ie. garbage collector throughput vs number of threads -- what is the characteristic curve of (ratio of bytes allocated / seconds spent in gc) vs number of threads for the same scene?
14:17:56 <pavolzetor> dedgrant: the bytes allocated in the heap are samish for 16 and 32 threads
14:18:12 <pavolzetor> but GC time is doubled
14:18:27 <pavolzetor> (almost trippled)
14:18:31 <ReinH> pavolzetor: recommend using threadscope at this point to try to visualize the gc behavior
14:19:02 <ReinH> Simon's book has some advice for analyzing threadscope results
14:20:07 <pavolzetor> give me a sec; I am curious how can the time go up, given same number of tasks but just increasing number of cores, will be interesting
14:20:25 <dolio> Major collections stop all threads, no?
14:20:51 <dolio> And have all capabilities participate in collection?
14:22:04 <suppi> what makes `type X a = Either a Int` legal but `type X a = Lens' a Int` illegal?
14:22:31 <monochrom> what is the definition of Lens' again?
14:22:44 <suppi> type Lens' = Lens s s a a 
14:22:46 <suppi> I think
14:22:47 <ReinH> monochrom: aside from type Lens' s a = Lens s s a a ?
14:22:48 <johnw> Lens' does hide a RankNType
14:23:08 <suppi> oh yeah, s a.
14:23:25 <johnw> ah, didn't see the obvious!
14:23:36 <suppi> johnw, so if I add {-# LANGUAGE RankNTypes #-} it should work?
14:23:43 <suppi> (right now i get: Illegal polymorphic or qualified type: Lens' a Int)
14:24:26 <johnw> can't hurt to try
14:25:35 <dedgrant> pavolzetor: Seconding ReinH's suggestion re: threadscope and Simon's book. Also, if you like, you can experiment with the RTS GC settings: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime-control.html [4.17.3. RTS options to control the garbage collector]
14:26:28 <suppi> johnw, ok, thanks.
14:26:42 <ReinH> suppi: Just use {-# LANGUAGE KitchenSink #-} (I wish)
14:26:54 <suppi> what I actually wanted to do is this: data MovementComponent s = MovementComponent { _position :: Lens' s Point, _size :: Lens' s Size }
14:27:03 <suppi> and then makeLenses ''MovementComponent
14:27:25 <suppi> but for the makeLenses part I needed to add ImpredicativeTypes? what are those?
14:30:14 <quchen> ReinH: {-# LANGUAGE Idris #-}
14:30:20 <pilne> man... what *hasn't* haskell/ghc thought of? everything is tune-able!
14:30:44 <ReinH> pilne: GHC is some sufficiently advanced technology, for sure.
14:30:48 <dedgrant> pavolzetor: (The flat GC commission strongly suggests unwanted serialization, but who is waiting for what and where?)
14:31:18 <pilne> could haskell be the lisp of the 21st century? :p maybe i should ask that dude who runs y-combinator >.<
14:31:26 <hodapp> Paul Graham?
14:32:06 <suppi> pilne, what do you mean?
14:32:57 <ReinH> pilne: I'm not even sure if lisp was the lisp of the 20th century.
14:33:36 <t7> @hoogle m n a -> m n a
14:33:38 <pilne> lisp just felt like (to me, after having java and c++ shoved down my throat in academia) a breath of fresh air where the abstractions were on my side
14:33:39 <lambdabot> Data.Graph.Inductive.Basic grev :: DynGraph gr => gr a b -> gr a b
14:33:39 <lambdabot> Data.Map.Lazy deleteMax :: Map k a -> Map k a
14:33:39 <lambdabot> Data.Map.Strict deleteMax :: Map k a -> Map k a
14:33:47 <pilne> i get that same feeling learning haskell
14:33:49 <ReinH> pilne: what follows is a comprehensive list of the topics on which I value Paul Graham's input:
14:34:01 <ReinH> So anyway.
14:34:04 <johnw> pilne: http://newartisans.com/2009/03/hello-haskell-goodbye-lisp/
14:34:52 <pilne> i like this one too johnw: http://axisofeval.blogspot.com/2011/01/why-lisp-is-big-hack-and-haskell-is.html
14:35:34 <puregreen> suppi: an impredicative type is a type like “F a” where “a” contains a forall
14:36:21 <puregreen> e.g. “x :: Maybe (a -> a); x = Just id” is the simplest example
14:37:08 <johnw>  is it "impredicative" because given forall a. F a, you could instantiate F (F ...)?
14:37:24 <suppi> puregreen, oh, I see. but I don't need a language extension for that don't I?
14:37:31 <puregreen> you do
14:37:37 <puregreen> even for the Just id example
14:37:48 <mauke> > let x :: Maybe (a -> a); x = Just id in ()
14:37:50 <lambdabot>  ()
14:37:56 <mauke> no, I don't
14:38:09 <puregreen> hm, wait
14:38:11 <suppi> > :t Just id
14:38:12 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:38:20 <suppi> > Just id
14:38:22 <lambdabot>      No instance for (Typeable a0)
14:38:22 <lambdabot>        arising from a use of ‘show_M427715600411878248931204’
14:38:22 <lambdabot>      In the expression:
14:38:26 <puregreen> ah
14:38:31 <puregreen> the forall gets floated out
14:38:36 <suppi> (how to i query the type?)
14:38:42 <puregreen> > let x :: Maybe (forall a. a -> a); x = Just id in ()
14:38:43 <lambdabot>      Illegal polymorphic or qualified type: forall a. a -> a
14:38:43 <lambdabot>      Perhaps you intended to use ImpredicativeTypes
14:38:43 <lambdabot>      In the type signature for ‘x’: x :: Maybe (forall a. a -> a)
14:39:24 <suppi> ok, I see.
14:39:59 <puregreen> the type signature for generated lenses contains stuff like “f (Lens' s Size)”, and Lens' itself contains a forall, so it doesn't work
14:40:16 <mauke> :t Just id
14:40:17 <lambdabot> Maybe (a -> a)
14:40:25 <puregreen> (I wonder whether it'd be possible to write a lens anyway by expanding the signature manually and floating out everything)
14:40:31 <jle`> anyone know a good example of a language with dynamic and strong types
14:40:38 <johnw> don't use Lens'
14:40:41 <lpsmith> javjarfer, I'm entirely sure what you are suggesting,  so I don't have much of an opinion on it.
14:40:41 <johnw> use ALens'
14:40:48 <suppi> what are the consequences for using ImpredicativeTypes? I read it might make trouble for type inference
14:40:55 <lpsmith> Err, I'm not entirely sure what you are suggesting*
14:40:56 <johnw> it exists in order to not need the rank-2 type
14:41:08 <dmj`> jle`: python
14:41:10 <puregreen> don't use ImpredicativeTypes, use ALens' as johnw suggested
14:41:14 <javjarfer> lpsmith, you are *not*?
14:41:42 <lpsmith> Right,  all the resources can be reclaimed by the GC.
14:41:45 <suppi> johnw, puregreen, alright. thanks :)
14:41:47 <hodapp> jle`: Erlang
14:42:02 <jle`> i guess strong/weak is a continuum of sorts
14:42:31 <dedgrant> suppi: Relatively recent: http://jozefg.bitbucket.org/posts/2014-12-23-impredicative.html
14:42:47 <suppi> dedgrant, thanks!
14:43:26 <lpsmith> javjarfer, so what is your approach that you spoke of?
14:43:38 <jle`> erlang sounds like a good textbook example
14:44:09 <suppi> I am using the microlens package, and there doesn't seem to be ALens type.
14:44:15 <suppi> guess it's time to move to lens
14:44:20 <puregreen> hey
14:44:36 <puregreen> I'll add it
14:44:41 * puregreen looks
14:44:42 <puregreen> no I won't
14:44:47 <puregreen> yeah, time to move to lens
14:44:55 <monochrom> haha
14:45:06 <suppi> puregreen, you're the author? heh :)
14:45:36 <johnw> time for picolenses
14:45:47 <zachk> what's picolenses? 
14:45:55 <johnw> just joking
14:45:56 <EvanR> yoctolens
14:46:01 <johnw> since there has been minilens and microlens
14:46:02 <monochrom> no, wrong direction. you add more things, it's bigger. milllens.
14:46:03 <zachk> femto! 
14:46:16 <ReinH> picolens is the id function and various spurious type synonyms
14:46:22 <johnw> lol
14:46:29 <kadoban> Haha
14:46:38 <zachk> are they composable with (.) though? 
14:46:53 <puregreen> fun fact: picolens would have almost all dependencies of lens
14:46:56 <EvanR> :t id . id . id . id
14:46:58 <lambdabot> c -> c
14:47:08 <EvanR> id . id . id . id . ...
14:47:32 <ReinH> One of my favorite properties of the lens library is that you can define compatible optics in your libraries without incurring a dependency on lens.
14:48:29 <zachk> I was thinking earlier today if you had f : a -> b and g : a -> b and you wanted something that transforms f into g or g into f, doesn't that imply that all values of are being embedded(imbedded ?) into b, and wouldn't that also imply that inverses for f and g exist ? 
14:49:27 <puregreen> why don't we have anything bigger than lens, actually
14:49:32 <puregreen> say, “gigalens”
14:49:49 <puregreen> prisms and lenses and traversals for all data types from all Hackage packages
14:49:49 <monochrom> kilolens first :)
14:49:58 <icen1> zachk: what about const 1 :: Void -> Int and const 2 :: Void -> Int; I can turn f into g, but I don't want inverses to exist
14:50:43 <zachk> doesn't that imply that the inverse could still be constructed though ? 
14:50:46 <ReinH> icen1: for any two known functions f and g, you can turn f into g trivially: f `turnedInto` g = g
14:50:54 <puregreen> okay, given that Hackage has several thousand packages, “kilo”lens would be better, yeah
14:51:32 <ReinH> (if f and g are the same type, ofc)
14:51:49 <dedgrant> suppi: Oh, for an brief summary of impredicativity (mathematics/logic), perhaps see: https://en.wikipedia.org/wiki/Impredicativity
14:51:54 <Fuco> I bet there is a homotopy package :D
14:52:11 <johnw> Fuco: funny you assume there'd be just one
14:52:17 <Fuco> haha
14:52:52 <johnw> there is https://hackage.haskell.org/package/hoq, but i don't see 'homotopy'
14:52:55 <johnw> quick, reserve it!
14:53:16 * zachk will be back latter
14:53:35 <Fuco> I was thinking more about topology but I suppose this also counts
14:53:40 <Fuco> I know nothing about HTT
14:53:51 <ReinH> Fuco: it's so hot right now
14:54:17 <ReinH> Get it? Hot? It's funny, Fuco.
14:54:17 <Fuco> does it have anything to do with topological homologies?
14:55:12 <Fuco> once I looked into it and it sounded just like kTheory... magical mumbo-jumbo bound do solve humanity's deepest problems
14:56:27 <johnw> Fuco: I'd start here: http://www.sandiego.edu/~shulman/papers/synhott.pdf
15:00:24 <ReinH> johnw: ooh added to my list as well
15:00:26 <ReinH> thanks
15:00:34 <ReinH> Fuco does not appreciate my humor. :(
15:00:56 <ReinH> Maybe if I keep trying to explain the joke.
15:01:22 <johnw> explanation always makes them funnier, sure
15:02:45 <Fuco> well if Awodey likes it then I'll read the paper... you got me on this one
15:04:17 <ReinH> johnw: if it isn't funny then you haven't explained it right and you have to try again
15:04:30 <javjarfer> lpsmith, what I have is a function like this "fun :: INotify -> (INotifyBuffer -> IO a) -> IO a", so, when you are using the function, you pass the info about how you want the Inotify to be instantiated as first parameter, and in the second one you pass a function that is going to use the INotifyBuffer in a clean way, when you exit this computation, INotifyBuffer is cleaned.
15:04:49 <Fuco> ReinH: I'm too tired for humor now :/
15:05:03 <Fuco> plus I'm pretty humorless anyway
15:06:06 <tonykaku>  /quit
15:07:43 <ReinH> Fuco: I'm just joking anyway :)
15:07:57 <Fuco> well that's the point of humor :D
15:08:11 <magbo> Beautiful people, I wrote this implementation by acceident and I don't understand why it works
15:08:22 <Fuco> magbo: that happens to me all the time
15:08:24 <magbo> (<%~) l h y = l (\x -> (h x, h x)) y 
15:08:44 <Fuco> does it typecheck? meh, probably correct
15:08:44 <magbo> Fuco: I know that feeling, but this one puzzles me.
15:08:50 <magbo> Works on every lens.
15:09:16 <magbo> Returns (b, t) -- updated focused value and updated source
15:09:40 <puregreen> magbo: do you know how the Functor instance for (,) works?
15:09:49 <magbo> (,) is the outer functor, that was my intention when I was writing it
15:10:24 <magbo> puregreen: oh snap, it answers my question!
15:10:46 <magbo> I remember it was rather assymetrical and coincidentally behaving just as I need here.
15:10:52 <Nadrieril> (,) is not a functor. ((,) e) is
15:11:00 <t7> how2fix this monstrosity: http://lpaste.net/148444 ?
15:11:02 <jle`> it's Writer! :O
15:11:10 <magbo> Ritht-right, thank you people.
15:11:28 <Fuco> answering my own questions, that also happens to me a lot
15:11:38 <Fuco> we might be family!
15:11:40 <jle`> magbo: `(\x -> tell (h x) >> return (h x))` would get you the Writer translation of what you wrote
15:11:44 <magbo> Fuco: no-no, I was silly.
15:12:05 <Fuco> sometimes just writing it out makes it clearer to you :P
15:12:13 <t7> is   State n (Either _ _)  a code smell?
15:12:13 <magbo> puregreen and jle` were most helpful
15:12:14 <Fuco> which means there is no downside in asking
15:12:19 <puregreen> jle`: ooh, I like this one
15:12:20 <t7> should i be using stateT?
15:12:24 <puregreen> gotta steal it for lens over tea
15:12:33 <jle`> it's technically wrong because it requires a Monoid instance i think
15:12:43 <magbo> Wait a minute, puregreen, are you behind LoT?
15:12:55 <puregreen> yep
15:12:58 <jle`> t7: not necessarily
15:13:02 <Nadrieril> ooh *.*
15:13:04 <magbo> I wrote you an email recently thanking you for the series.
15:13:06 <jle`> puregreen: appreciate the series a lot, btw :)
15:13:13 <Nadrieril> it is very nice indeed puregreen
15:13:32 <jle`> t7: StateT n (Either e) is for when your computation interleaves state mutation and short-circuiting error
15:13:44 <ReinH> puregreen: LoT?
15:13:57 <magbo> I use it to explain lens to people. I have lens over tea solved and now I'm going through it once again, not looking into prior implementations.
15:14:00 <jle`> t7: State s (Either e a) would teoo me that it's a stateful computation that returns Either e a, or, it can error or not error
15:14:03 <ReinH> ahhhh
15:14:05 <ReinH> puregreen: yes thanks for that
15:14:14 <ReinH> very needed
15:14:19 * puregreen is grinning all around
15:14:29 <ReinH> puregreen: also thanks for not titling it "You could have written lens"
15:14:33 <jle`> t7: StateT s (Either e) a would be if you intend on sequencing several short-circuiting-error-and-state-interleaved actions
15:15:00 <johnw> ReinH: just skip to, "You could have been edwardk", it answer all other questions
15:15:19 <Nadrieril> isn't it pointless to do "return x >> f" ?
15:15:22 <ReinH> johnw: yes, he does so love initial objects in the category of solutions, of which he is one.
15:15:25 <johnw> totally pointless
15:15:56 <t7> jle` thats sounds about right
15:16:01 <ReinH> johnw: the universal property is, of course, "if there is a solution, an equivalent solution up to unique isomorphism can be gotten by asking Kmett".
15:16:22 <jle`> puregreen: oh, you can get a working version of what i wrote with tell (h x) $> h x, because while it's equivalent to tell (h x) *> return (h x), it doesn't require a Monoid constraint
15:16:28 <t7> jle` do i have to lift stuff or something?
15:16:34 <jle`> to do what?
15:16:37 <Nadrieril> t7: "return x; something" is the same as just "something"
15:17:18 <t7> Nadrieril: its not gonna catch the error? :|
15:17:22 <t7> crap i need stateT
15:17:30 <jle`> t7: oh, i didn't look at your code
15:17:41 <jle`> yeah, it looks like you interleave short circuiting error with state modifying actions
15:17:46 <jle`> so yes, StateT would be beneficial in this case
15:18:07 <jle`> but `return` isn't short-circuit-return-with-success in Either
15:18:21 <jle`> i'm talking about using StateT to make the nested case statements look nicer, that's all
15:18:45 <t7> im not trying to short circuit on success 
15:18:48 <jle`> "return" doesn't let you "jump out" like in other languages
15:18:48 <t7> only on error
15:18:53 <t7> :/
15:19:00 <t7> i do see the problem
15:19:09 <EvanR> why the hell not, i say
15:19:11 <jle`> yeah, StateT s (Either e) lets you get rid of the nested case statements
15:19:21 <EvanR> call it pure then
15:19:50 <t7> awesome, thankyou. will sort that out tomorrow
15:20:26 <EvanR> then return can be properly implemented with Cont
15:27:46 <pilne> if a rust library can expose a proper c api, does that mean the haskell ffi should be able to call a rust library?
15:28:13 <ReinH> pilne: yes, Haskell can FFI with Rust.
15:28:15 <ARM9> yes
15:28:19 <ReinH> e.g., https://github.com/aisamanra/rust-haskell-ffi
15:28:29 <pilne> sweet
15:31:36 <pilne> now to get good enough at haskell to make an equivalent of inline-c >.<
15:56:07 <ethanpailes> I have a question about using the IsString a => a constraint that -XOverloadedStrings imposes to convert my codebase from Strings to Text
15:57:05 <ethanpailes> It would be really nice if I could convert my datastructures to have the type (IsString a => a) anywhere a String used to be
15:57:36 <ethanpailes> so that I can incrementally convert my old code to work with Text instead of Strings
15:57:45 <ethanpailes> and everything will still work
15:58:48 <puregreen> ethanpailes: this will fail on the first function that returns a String
15:58:58 <puregreen> because we have fromString but not toString
15:59:41 <ethanpailes> Yeah, I noticed that. Is there any additional constraint I could impose that would give me a toString method as well?
15:59:53 <puregreen> not that I know of
16:00:04 <Lokathor> I'll ask the bigger crowd: doesn't `fmap id = id` end up implying `fmap (f . g) = fmap f . fmap g`? Are they essentially the same law twice?
16:00:08 <ethanpailes> If one does not exist I suppose I could hack one together myself pretty quickly
16:00:16 <Lokathor> or can you make an example that breaks one but not the other?
16:00:23 <ethanpailes> thanks puregreen
16:00:24 <puregreen> other than that, yeah, you can convert your datatypes from “data X = X String” to “data X a = X a” and then add constraints to functions that accept your types
16:00:43 <puregreen> I don't remember right now whether you can use a GADT instead, let me check
16:00:44 <johnw> Lokathor: fmap id = id, plus the free parametricity theorem for fmap
16:01:00 <johnw> see https://www.schoolofhaskell.com/user/edwardk/snippets/fmap
16:01:00 <Lokathor> ..."free parametricity theorem"?
16:01:01 <Nadrieril> pilne: it's not even Haskell anymore, I believe you would need to get pretty deep into GHC
16:01:01 <Lokathor> hmm
16:01:35 <mauke> @free gmap :: (a -> b) -> T a -> T b
16:01:35 <lambdabot> g . h = k . f => $map_T g . gmap h = gmap k . $map_T f
16:01:50 <Lokathor> i've never heard of this free thing
16:01:55 <Lokathor> but i'll try to investigate
16:03:01 <pilne> good point Nadrieril, it is a distinction like "common lisp" (the standard) and various implementations. I'll try and remember that in the future.
16:03:19 <Nadrieril> indeed
16:04:01 <Nadrieril> I also mean that you would have to dig into the compiler itself, not only the variant of Haskell that is implemented by GHC
16:05:15 <pilne> hopefully i'll be able to grok it all someday (: i'm moderately persistant at things I enjoy (:
16:05:34 <puregreen> ethanpailes: there's a class in another package
16:05:38 <Nadrieril> :)
16:05:39 <puregreen> (not base)
16:05:40 <puregreen> http://hackage.haskell.org/package/tostring-0.2.1.1/docs/Data-String-ToString.html
16:06:03 <Nadrieril> pilne: I would be interested to see how that goes
16:09:29 <pilne> i'm just glad my learning curve will probably allow me to see if rust sinks or swims (:
16:10:23 <pilne> i feel this image has been accurate so far: https://raw.githubusercontent.com/Dobiasd/articles/master/programming_language_learning_curves/haskell.png
16:13:07 <Nadrieril> ^^
16:22:06 <EvanR> pilne: nice
16:22:41 <dedgrant> pilne: Do you know about https://github.com/fpco/inline-c ?
16:23:08 <geekosaur> I think they meant they want to do inline-rust
16:23:33 <pavolzetor> the eventlog is 500MB, threadscope uses whopping 18GB of RAM
16:23:55 <dedgrant> pilne: Or if you are intending auditable embedded systems: http://ivorylang.org/ivory-introduction.html
16:24:14 <pilne> i knew about the first dedgrant, but the second is new info, ty (:
16:24:48 <mzabani> Hi everyone! As a beginner, can anyone point out what would idiomatic Haskell look like to apply a function to the value inside a *Maybe a* if it is a *Just a* and get its result or to return a default value if it is a *Nothing*. I've done it with *fromMaybe* and >>= or *fromMaybe* and <*> but it looks a little cryptic to me.
16:24:51 <pavolzetor> can i somehow prefilter that log before opening threadscope?
16:25:06 <pavolzetor> :i maybe
16:25:15 <mzabani> So I'm wondering if there is a better way
16:25:24 <puregreen> :t maybe
16:25:26 <lambdabot> b -> (a -> b) -> Maybe a -> b
16:25:28 <puregreen> @src maybe
16:25:28 <lambdabot> maybe n _ Nothing  = n
16:25:28 <lambdabot> maybe _ f (Just x) = f x
16:25:35 <puregreen> @index maybe
16:25:35 <lambdabot> Data.Maybe, Prelude
16:25:54 <puregreen> mzabani: this is the function you're looking for
16:26:18 <pilne> and yes, i've got a dream of doing inline-rust (if rust manages to get a decent hold, just because i like it a lot more than c (however heretical that might be lol))
16:26:30 <mzabani> oh wow, right on..
16:26:43 <mzabani> I was just browsing through Data.Maybe and didn't see this
16:27:12 <dedgrant> pilne: Cool.
16:27:32 <mzabani> must be going blind or something.. I was doing fromMaybe defaultValue (maybeValue >>= Just . func), but it did look terrible to me
16:28:01 <mauke> >>= Just . is fmap
16:28:35 <mzabani> mauke: the other way I had it was with <*>, but it still looked kind of ugly
16:28:48 <pavolzetor> but when the file is open it is fast
16:28:49 <mauke> fromMaybe defaultValue (fmap func maybeValue)
16:30:42 <mzabani> mauke: fmap does make it look much better than with <*>
16:31:15 <mzabani> thanks a lot, everyone
16:31:30 <pavolzetor> http://sci.utah.edu/~klacansky/img/threadscope16_currypath.png
16:31:49 <pavolzetor> I sort of understand the end, writting to disc
16:32:02 <pavolzetor> and start is parsing of the scene
16:33:49 <dedgrant> pavolzetor: I never did publish it, but there is a simple solution to managing a live profiling session that would require some retooling of the profile log parser to stream effectively: tail the log as it grows, and pipe the result somewhere (like using ncat to submit to a socket that some web client reads).
16:34:16 <pavolzetor> http://sci.utah.edu/~klacansky/img/threadscope16_spark_currypath.png
16:36:06 <pavolzetor> dedgrant: I see, so you would build always last N MB of the log?
16:37:22 <pavolzetor> is it better to create ton of sparks or use something like parBuffer?
16:38:48 <hackriledge> Does this need instances of Monad to be clear, or is the Free monad sufficient for this to be communicative; http://lpaste.net/148450
16:38:56 <dedgrant> pavolzetor: Yea it's just an opportunity for folks to revisit the UX in a more interactive way. (Note there is also another take on the problem with https://github.com/tibbe/ekg, which expects a small bit of instrumentation of your program)
16:40:10 <pavolzetor> thanks, I am going to have a look
16:40:35 <dedgrant> pavolzetor: ekg will give you more application-level control of telemtry
16:40:59 <pavolzetor> I need that, because I want to eliminate some stages fro mprofiling
16:41:08 <hackriledge> I guess it's not clear how such a structure should be traversed... But the intuitive terms free and graph should be sufficient. Can anybody talk to me about this structure? Is there any documentation relevant? Has it been seen before? Is it redundant? http://lpaste.net/148450
16:41:20 <pavolzetor> btw, do you see those pauses in threadsope image I posted?
16:42:10 <pavolzetor> I am not sure what that means, it looks similar to marlows book when he was printing out stuff
16:43:44 <Hijiri> 'disconnect
16:46:11 <Nadrieril> hackriledge: I'm not sure how you make this a monad
16:47:21 <hackriledge> Join contracts the Node to a Base
16:47:47 <hackriledge> I think...
16:48:33 <Nadrieril> actually, I'm not sure what your structure is ^^'
16:48:49 <nolrai2> hackriledge: err..what? What is a node and what is a base, semanticly. And I have very little idea what a "free graph" would be.
16:49:37 <hackriledge> Rather , FreeGraph (FreeGraph a) -> FreeGraph a
16:50:07 <hackriledge> http://lpaste.net/148450 that's what I thought a free graph should be
16:50:26 <nolrai2> I mean there are the clique of n nodes and n disconnected nodes, or the full Cartesian product...but none of those things look like your structure.
16:50:45 <hackriledge> It's like a graph, which contains a graph at each node, until a base case when each graph contains elements
16:51:30 <Nadrieril> it contains a graph a each node ??
16:51:48 <Nadrieril> you are nesting graphs ?
16:51:54 <hackriledge> Maybe the last FreeGraph on the left should be Base...
16:52:01 <hackriledge> On the right sorry
16:52:06 <nolrai2> Its not a graph though...
16:52:30 <Majiir> It sounds like you want two different structures here
16:52:32 <hackriledge> I am nesting graphs infinity in ala Free
16:52:34 <nolrai2> And in what sense is it "free".
16:52:55 <hackriledge> It should be a Free Monad
16:53:14 <nolrai2> Yess..but what you have is nested rose trees. (sort of).
16:53:27 <hackriledge> Is that bad?
16:53:41 <nolrai2> It's strange.
16:53:56 <hackriledge> I'm trying to expand out Free Graph a
16:54:10 <nolrai2> The fact that you aren't naming it right makes me think you probably don't need something that strange.
16:54:11 <Nadrieril> also, it would not be a free monad, even if it is a monad
16:54:14 <hackriledge> Or, Free RoseTree a
16:55:03 <nshepperd> i can imagine a join with the right type signature that turns Base into a Node, no idea if it follows the laws
16:55:06 <hackriledge> Nadrieril, even if it were a valid expansion of Free Graph a?
16:55:35 <hackriledge> Return I think would have that type rather than join
16:55:57 <nolrai2> Why don't you seperate what you are doing into two steps. What should a Graph look like?
16:56:09 <nolrai2> Or rather..what problem are you trying to solve?
16:56:28 <hackriledge> Atm, it's a singely linked tree
16:56:49 <hackriledge> Free Map a could do
16:57:04 <hackriledge> If you wanted indexes
16:57:21 <johnw> I believe that in a free graph, each node could be either an 'a', or another free graph
16:57:28 <Nadrieril> the free monad is in a way "the most general monad", so if you make it graph-shaped, it's not the most general anymore
16:57:41 <hackriledge> Perhaps Free [] a would be easier to consider
16:57:49 <Nadrieril> it could be a free monadic graph or something like that
16:58:00 <Nadrieril> if that makes sense
16:58:13 <nolrai2> johnw: I think you are wrong, unless you mean the Free monad ontop of the Graph functor?
16:58:20 <johnw> nolrai2: that's what I meant
16:59:06 <hackriledge> Johnw, as in, FreeGraph a = Node (Either a (FreeGraph a))
16:59:11 <hackriledge> ?
16:59:31 <nolrai2> Why...not just use "Free"?
16:59:52 <johnw> hackriledge: somehow that doesn't seem right
16:59:55 <hackriledge> I just want to make sure my expansion of it is valid and informative
17:00:09 <johnw> hackriledge: i have a feeling we're crossing terminologies here
17:00:25 <nolrai2> Expansion?
17:00:25 <hackriledge> Ok, yeh that one is bad.. No neighbors
17:00:42 <nshepperd> FreeGraph a = Pure a | Roll (FreeGraph (Graph a))
17:00:44 <nolrai2> You have a definition, not an expansion.
17:00:45 <ReinH> johnw: a free graph in what sense?
17:00:48 <hackriledge> writing out Free Graph a As a synonym
17:00:49 <Nadrieril> @src Free
17:00:49 <lambdabot> Source not found. :(
17:00:57 <Nadrieril> I tried ^^
17:01:10 <hackriledge> I'll get it 1 sec
17:01:22 <nshepperd> oh wait, other way around?
17:01:33 <johnw> ReinH: I'm not sure anymore; I thought the question was about Free Graph a
17:01:44 <johnw> now I don't know which kind of "free" is meant, and which kind of "graph"
17:01:48 <nshepperd> FreeGraph a = Pure a | Roll (Graph (FreeGraph a))
17:01:51 <nshepperd> ah yes
17:01:56 <ReinH> Right, a Free Graph a is determined by whatever Graph is.
17:02:05 <nolrai2> IIRC: Free f a = Pure a | Roll (f (Free f a))
17:02:21 <nolrai2> johnw: Yes that is what was confusing us.
17:02:25 <hackriledge> Yeh that's it
17:03:14 <johnw> I wonder where 'Roll' came from
17:03:31 <johnw> I've seen other uses of that constructor, but I'm not sure what it intends to convey
17:03:51 <hackriledge> But the Graph has a bar in it's definition, can we best those?
17:03:53 <nolrai2> "Roll up" and "on a roll" i think?
17:04:04 <hackriledge> Nest*
17:04:20 <hackriledge> Keep rolling
17:04:26 <nolrai2> What is the definition of Graph?
17:04:38 <hackriledge> I'm using a rosetree
17:04:40 <Nadrieril> 11♪♫♪ They see me rollin' 11♪♫♪
17:04:51 <nshepperd> i hope hackriledge realises by now though that a graph made by tying the knot with pointers between haskell adts is not actually a graph, but an infinite treea
17:05:09 <ReinH> You might ask dolio or edwardk since both have used it, although edwardk later used Free instead of Roll as the constructor in the free package.
17:05:30 <johnw> nshepperd: a tree where every branch level may also have edges between them
17:05:32 <hackriledge> data Graph a = Node a [Graph a]
17:05:44 <johnw> some a bit more structured than Free [] a, or a rose tree
17:05:47 <johnw> s/some/so
17:05:48 <hackriledge> Probably not a rose tree in fact
17:06:11 <johnw> ReinH: I like Pure/Free, or Pure/Join myself
17:06:11 <nolrai2> No that is a rose tree.
17:06:19 <ReinH> hackriledge: well, that' a rose tree, not a graph
17:06:22 <ReinH> that's
17:06:28 <johnw> hackriledge: a graph needs both nodes and edges between nodes
17:06:31 <ReinH> johnw: right, the free package uses Pure/Free
17:06:55 <hackriledge> The neighbors list is singly linked providing edges
17:06:59 <dolio> I don't remember where it came from.
17:07:26 <dolio> I don't like naming one constructor of a multi-constructor type after the type, though.
17:07:37 <nolrai2> Hmm.
17:07:43 <hackriledge> Induction and Base Case seem fitting
17:07:55 <hackriledge> BaseCase*
17:08:01 <johnw> dolio: yeah, that is often confusing
17:08:03 <nolrai2> hackriledge: what are you trying to do with these Graphs?
17:08:08 <ReinH> hackriledge: that's a tree. There is no induction on a graph.
17:08:16 <dolio> I don't really like punning at all, to be honest.
17:08:20 <nolrai2> dolio: I also agree.
17:08:28 <dolio> But it's easier than thinking up new names.
17:08:34 <nolrai2> dolio: I am okay with it for newtypes.
17:08:36 <ReinH> It's a Free Data.Tree.Tree a
17:08:39 <hackriledge> Huh, no that was for Free
17:09:06 <johnw> nolrai2: he did say "multi-constructor type"...
17:09:21 <shirt> "My brain just exploded" -- GHC
17:09:39 <nolrai2> johnw: dolio> I don't really like punning at all, to be honest.
17:09:40 <ReinH> Well, you can do induction on a graph, but not in the same way that you can do induction on a tree.
17:10:10 <nolrai2> ReinH: What would induction on a graph look like?
17:10:21 <viliami> haskells for noobs, i like to use brainfuk
17:10:36 <hackriledge> Requires a spanning tree no?
17:10:38 <nolrai2> shirt: what were you compileing?
17:11:03 <ReinH> nolrai2: there's an example here http://www.sfu.ca/~mdevos/notes/graph/induction.pdf
17:11:19 <shirt> nolrai2: really simple program of mine with an existential type
17:11:44 <hackriledge> ReinH, my paste is a valid synonym of Free Data.Tree.Tree a
17:11:45 <hackriledge> ?
17:12:10 <ReinH> hackriledge: Graph is the same structure.
17:12:17 <pavolzetor> I did force the loading and the saving
17:12:19 <ReinH> I'm not sure what FreeGraph is, or in what sense it is free.
17:12:26 <pavolzetor> so everything is evaluated before tracing
17:12:45 <pavolzetor> and it seems at start the productivity is around 80%
17:12:55 <nolrai2> shirt: mind pasting the full error, not sure I can help, but I can try.
17:13:12 <pavolzetor> but after  few seconds it drops to 40%
17:13:48 <shirt> nolrai2: i think i can figure it out... i'm getting the same full error as this reddit post: https://www.reddit.com/r/haskell/comments/1k04d5/this_makes_me_grin_every_time/
17:14:21 <dedgrant> pavolzetor: They look suspicious yes. Orange marks are spark gc events, right? There is definitely serial contention with the gc, but that's a broadly uninspired observation. ;)
17:14:23 <hackriledge> FreeTree a = Pure a | Roll (a [FreeTree a])
17:15:30 <hackriledge> So that has an intuitive monad definition c.f. Free
17:15:41 <pavolzetor> dedgrant: yes, GC events. Well, so I guess I can't go wrong with trying to reduce GC load right?
17:15:47 <nshepperd> you can turn a graph into a tree by traversing it, but that throws away the essential graph-ness
17:15:52 <johnw> hackriledge: why encode it that way, instead of just saying Free [] a?
17:15:56 <ReinH> hackriledge: well, that's Free [] a, but what does that have to do with FreeGraph?
17:16:00 <dedgrant> pavolzetor: Well, so long as it is not making your program unmanageable.
17:16:06 <hackriledge> And is Applicative and Foldable And a monad in the sense of Tree
17:16:32 <ReinH> Wait
17:16:38 <pavolzetor> dedgrant: I have made couple of things strict, but I might not do unpacking yet, as I would need mono-traversable instances
17:16:40 <johnw> but it's not a monad in the sense of Tree at all
17:16:49 <Nadrieril> why do you need it to be a monad so much ?
17:16:52 <nshepperd> hackriledge: that's ill kinded. what is (a [FreeTree a]) supposed to be
17:16:53 <pavolzetor> I think next I will try different partitioning schemes
17:17:05 <hackriledge> Are you sure it's Free [] a?
17:17:05 <ReinH> hackriledge: no it oisn't
17:17:11 <pavolzetor> https://vlebb.leeds.ac.uk/bbcswebdav/orgs/SCH_Computing/FYProj/reports/0910/Tsenov.pdf
17:17:19 <johnw> sorry, I didn't see that "a " there
17:17:21 <ReinH> hackriledge: it's nothing. It's a compiler error.
17:17:23 <johnw> that breaks t
17:17:43 <pavolzetor> this guy from my previous school seemed to get best results for tiles (and most renderers like blender, mitsuba do tiles too)
17:17:43 <dedgrant> pavolzetor: Just keep your evidence handy. You might stumble on some discoveries while exploring partitions. Also, getting a handle on call sites around the major gc clusters could be enlightening.
17:17:47 <hackriledge> Ok prefix with Either...
17:18:08 <Nadrieril> that could work: FreeTree a = Pure a | Roll a [FreeTree a] , but it's almost a rosetree
17:18:15 <ReinH> Surely that won't confuse everyone. Just tell us the correct thing.
17:18:17 <hackriledge> Or just remove the parenthesis
17:18:21 <Nadrieril> ^
17:18:23 <hackriledge> Yeh the latter
17:18:32 <hackriledge> (hackriledge) FreeTree a = Pure a | Roll a [FreeTree a]
17:18:41 <johnw> why is this being discussed?  I've completely lost the point
17:18:46 <pavolzetor> degrant: evidence is 500MB for a run ;). but I am writing notes so I can actually measure if I am improving or not.
17:18:51 <ReinH> Well, that version of FreeTree is a thing, but it isn't free afaik.
17:18:55 <dedgrant> pavolzetor: I also recall Simon M writing at some length about a thread local storage patch for GHC, but I'm not sure if it ever landed in recent versions. Might be something else to pursue.
17:18:56 <Nadrieril> hackriledge: why not FreeTree a = FreeTree a [FreeTree a] ?
17:18:59 <johnw> I'm just seeing types with the name "Free" in them, but nothing else is happening
17:19:06 <Nadrieril> ^
17:19:12 <ReinH> Nadrieril: That's just Data.Tree.Tree.
17:19:16 <Nadrieril> I know
17:19:16 <ReinH> Which isn't a free anything.
17:19:20 <ReinH> It's a Cofree [].
17:19:24 <hackriledge> johnw, I hadn't gotten to the point yet, I was ensuring the structure was sane to enable discussion
17:19:33 <pavolzetor> that's I am trying to explore, it seems that it computes (accumulates allocations) and then runs out of the spare space so needs to collect
17:19:40 <Nadrieril> ooh cofree **
17:19:59 <nolrai2> hackriledge: Without the point, we can't tell if the structure is sane.
17:20:01 <hackriledge> *gets coffee*
17:20:07 <Nadrieril> ^^
17:20:07 <ReinH> Cofree [] a is the exact same structure as Data.Tree.Tree with some things renamed.
17:20:16 <pavolzetor> do you have a link to that writing please?
17:20:27 <hackriledge> It's an attempt to rewrite Free Tree a
17:20:33 <nolrai2> Whats Cofree? The Free Comonad?
17:20:34 <dolio> It's actually not Data.Tree.Tree nor Cofree [] a, because of the extra Pure constructor.
17:20:36 <Nadrieril> my notion of "freeness" s limited to some intuition of "he most general thing that satisfies some laws"
17:21:14 <ReinH> dolio: I was referring to Nadrieril's FreeTree a = FreeTree a [FreeTree a]
17:21:16 <hackriledge> It's Free (Coffee []) a?
17:21:23 <dolio> Oh.
17:21:29 <Nadrieril> free coffee \o/
17:21:37 <ReinH> dolio: at this point I think we are all suitably confused.
17:21:44 <nolrai2> hackriledge: Then yes. That is what it is.
17:21:50 <ReinH> nolrai2: what?
17:21:54 <ReinH> no it isn't?
17:21:55 <pavolzetor> dedgrant: I am thinking of representing each tile as a vector and then have spark per tile and at the end accumulate all tiles
17:22:07 <pavolzetor> however, I am not sure if that is good way of partitioning
17:22:09 <Nadrieril> hackriledge: we are not sure what you want to achieve
17:22:15 <nolrai2> ReinH: Wrong it.
17:22:40 <dedgrant> pavolzetor: You could also try saying hi to the folks in #ghc for some specific gc tuning advice :)
17:22:46 <ReinH> nolrai2: there are a lot of it's floating around
17:22:49 <hackriledge> A graph containing graphs at each node infinity until a base case
17:22:58 <ReinH> hackriledge: what graph?
17:23:00 <ReinH> there are no graphs here
17:23:02 <hackriledge> Trees now actually
17:23:07 <hackriledge> Sry
17:23:15 <pavolzetor> dedgrant: after I have more information
17:23:17 <ReinH> a tree already contains trees.
17:23:18 <Nadrieril> well, your initial proposal was that I think
17:23:30 <ReinH> A rose tree contains a forest of more rose trees.
17:23:38 <hackriledge> As neighbors
17:23:38 <ReinH> a binary tree contains two binary trees
17:23:39 <ReinH> etc
17:23:52 <pavolzetor> I am still trying to figure out if it is better to have a function producing samples or just define an infinite list of them and then consume from that
17:23:57 <Nadrieril> he also had each node containing a tree, for some reason
17:24:07 <nshepperd> hackriledge: how many months have you been at this?
17:24:21 <nolrai2> Nadieril: He was applying Free to his "Graph" by hand.
17:24:22 <nshepperd> representing graphs with knot-tied trees does not work.
17:24:31 <ReinH> If you want to know what Free Tree a is, inline the definition of Tree into the definition of Free. Then say it 5 times fast.
17:24:31 <pavolzetor> I just do not know if GHC simply turns that long list into a for loop
17:24:34 <hackriledge> Oh, no I have an element Tree a at each branch as well ads a list of neighbouring FreeTrees
17:24:43 <nshepperd> it throws away everything that makes it a graph
17:25:00 <pavolzetor> and what is more haskell idiomatic code
17:25:02 <hackriledge> a Free Tree at each branch rather
17:25:10 <pavolzetor> but I would say something like 
17:25:18 <pavolzetor> iterate getSample is nicer
17:25:21 <nolrai2> hackriledge: what do you want the graphs for?
17:25:32 <ReinH> I can't make much sense out of this
17:25:36 <hackriledge> ReinH, I thought that's what I managed to do...
17:26:10 <hackriledge> (hackriledge) (hackriledge) FreeTree a = Pure a | Roll a [FreeTree a]
17:26:25 <ReinH> we have Free f a = Pure a | Free (f (Free f a)) and data Tree a = Tree a [Tree a]
17:26:30 <hackriledge> FreeTree a = Pure a | Roll a [FreeTree a]
17:26:43 <pavolzetor> I ahve other work to do, thanks for help, I will try to post result when I got some
17:26:56 <hackriledge> Oh, sorry so more like;
17:27:44 <hackriledge> Nono it's right
17:27:56 <ReinH> It is not right.
17:28:21 <Nadrieril> FreeTree a = Pure a | Free (Tree (FreeTree a))
17:28:37 <nolrai2> ReinH: huh?
17:28:39 <hackriledge> nolrai2 each level of the Free structure I require should be a monad
17:28:40 <Nadrieril> but I'm not sure how to interpret that
17:28:47 <Nadrieril> hackriledge: why ?
17:29:09 <hackriledge> Too be isomorphic to the structure which I'm studying
17:29:17 <hackriledge> ...
17:29:28 <Nadrieril> hackriledge: I think it would be easier to first desin the structure you want, and then find out if you can make it a monad/applicative/...
17:29:31 <nolrai2> hackriledge: What structure are you studying.
17:29:37 <ReinH> Roll does not contain an a.
17:29:53 <nolrai2> The a is from Tree.
17:30:00 <hackriledge> Monad m => Free m a
17:30:08 <ReinH> The Tree in Roll does not contain a's.
17:30:15 <nolrai2> Oh, right!
17:30:33 <ReinH> it contains Free Tree a's.
17:30:45 <nshepperd> FreeTree a = Pure a | Roll (FreeTree a) [Tree (FreeTree a)]
17:30:56 <nolrai2> hackriledge: its "Functor f => Free f a".
17:31:04 <nshepperd> Horrid useless structure
17:31:08 <nolrai2> That's kind of the whole point.
17:31:11 <ReinH> nshepperd: we hates it.
17:31:24 <hackriledge> As in; FreeTree a = Pure a | Roll (FreeTree a) [FreeTree a]
17:31:28 <hackriledge> ?
17:31:39 <nshepperd> particularly since Tree is already a monad
17:31:53 <hackriledge> That's the point
17:31:59 <ReinH> hackriledge: yes. I'm not sure why you want that or what you would use it for, but that's what it is.
17:32:06 <shachaf> What's wrong with a tree with a tree-shaped branches?
17:32:26 <hackriledge> A Free Monad of Monads had unique structure, I am required to classify
17:32:34 <nolrai2> ...
17:32:41 <ReinH> What does "a free monad of monads" mean?
17:32:42 <shachaf> A tree with (tree with list-shaped branches)-shaped branches.
17:32:47 <hackriledge> Has*
17:33:00 <hackriledge> (hackriledge) Monad m => Free m a
17:33:04 <nolrai2> Shachaf: if it turns up naturally, then sure..
17:33:04 <ReinH> Who is requiring you to classify it?
17:33:08 <hackriledge> Me
17:33:17 <ReinH> ...
17:33:28 <hackriledge> These questions are not relevant or helpful!
17:33:53 <ReinH> hackriledge: Well, I don't know what "a free monad of monads" means, so I can't offer any relevant or helpful advice about it.
17:34:05 <hackriledge> (hackriledge) (hackriledge) Monad m => Free m a
17:34:19 <hackriledge> Isn't that sufficient?
17:34:28 <nolrai2> Where is "Monad m => Free ma" coming from?
17:34:37 <nolrai2> *Free m a
17:34:38 <ReinH> Ok. I know what that means. It's a monad that throws away the monad structure of m and applies the monad structue of Free.
17:34:46 <nshepperd> presumably hackriledge means Free f where f happens to be already a monad
17:35:08 <Nadrieril> oh that's interesting
17:35:24 <hackriledge> I need to keep the original monad structure, it can b.s. A bimonad or something
17:35:31 <hackriledge> Be*
17:35:31 <ReinH> what?
17:35:43 <Nadrieril> well, you are not keeping the original monad structure that way
17:36:07 <nolrai2> I feel like I am trying to help someone with homework from an alternate dimension.
17:36:08 <Nadrieril> you are constructing a different monad structure based on its functor structure
17:36:11 <hackriledge> I'm motivating bomonad add a structure with two bind and return definitions
17:36:15 <hackriledge> As
17:36:22 <ReinH> what.
17:36:37 <hackriledge> Bimonad
17:36:43 <ReinH> That's not a thing.
17:36:51 <Nadrieril> you could try to start with some sort of bifunctor
17:37:00 <Nadrieril> and see if you can add properties
17:37:12 <hackriledge> It has 2 bind functions and 2 return functions in it's class definition
17:37:18 <Nadrieril> wut
17:37:29 <hackriledge> How is that not clear!?
17:37:45 <ReinH> Well, a bimonad is a thing, but it is not that thing.
17:37:52 <hackriledge> Ok
17:38:01 <hackriledge> So it's a new thing?
17:38:01 <ReinH> That thing can't exist.
17:38:06 <ReinH> It is an impossible thing
17:38:13 <hackriledge> Why?
17:38:15 <Nadrieril> are you just trying to define simultaneously 2 different monad instances on the same structure ?
17:38:21 <ReinH> If you have two returns that both satisfy the laws, they must be identical
17:38:22 <hackriledge> Yes
17:38:36 <ReinH> for exactly the same reason that you can't have more than one identity element in a monoid
17:38:48 * Nadrieril is gonna see what a bimonad is
17:38:49 <ReinH> you simply can't have two different returns.
17:38:57 <ReinH> Nadrieril: http://arxiv.org/pdf/0710.1163v3.pdf
17:39:09 <Nadrieril> thx
17:39:16 <hackriledge> It's just a way to retain the original monad structure with a flag to access it
17:39:41 <ReinH> Why? The original monad structure can be recovered whenever you want.
17:40:02 <ReinH> In exactly the same way that 1 + 2 + 3 + 4 can be given freely as [1,2,3,4] with the underlying structure recovered by foldr (+) 0
17:40:36 <ReinH> The structure is still present in m, it just isn't being used by Free m.
17:40:43 <Nadrieril> ReinH: a bit too categorical for me for the moment sry ^^
17:41:02 <hackriledge> So, i throw away the Tree Monad instance?
17:41:03 <ReinH> I sould say Sum 1 <> Sum 2 <> Sum 3 <> Sum 4 can be given freely by [Sum 1, Sum 2, Sum 3, Sum 4] and recovered by mconcat.
17:41:08 <hackriledge> What a waste!
17:41:20 <ReinH> *should
17:41:25 <ReinH> hackriledge: ok.
17:41:37 <hackriledge> That's what your saying?
17:42:10 <ReinH> Yes, a Free m a where m is a monad does not make use of the m's monad structure in the construction of the free structure.
17:42:38 <hackriledge> What class could retain this information?
17:42:56 <ReinH> No information has been lost.
17:43:25 <ReinH> m is still a Monad.
17:43:35 <ReinH> but its return and bind are not being used by the free construction
17:43:39 <ReinH> that's sort of the point of the free construction
17:43:41 <hackriledge> Aha! It has if I write out m
17:43:54 <ReinH> it provides its own return and bind
17:43:56 <hackriledge> Then we can't make an instance for it
17:44:36 <hackriledge> So expanding out the structure as i have ruins everything!
17:44:59 <ReinH> for some very small value of "everything", I guess.
17:45:08 <ReinH> i.e. one that means "this one thing"
17:45:25 <Nadrieril> x)
17:46:40 <hackriledge> What if I instead wrote a monad instance for FreeTree implementing the Tree Monad structure, and handle the monadic operations over Free seperately, using maybe freeBind and freeReturn as functions of the class FreeMonad
17:47:46 <ReinH> Sure, and while you're at it you can write SumMonoid and ProductMonoid classes for Nums rather than using Sum and Product newtypes to select the desired instance.
17:48:03 <hackriledge> I don't understand
17:48:16 <hackriledge> Is it superfluous what I am doing?
17:48:52 <ReinH> If a structure forms a monad in more than one way, why not use newtype wrappers to disambiguate?
17:49:02 <ReinH> that's the common practice in all other cases
17:49:30 <Nadrieril> instead of renaming some functions
17:49:47 <hackriledge> I should use Free Tree a and not write out the synonym and handle it's properties as a Free Monad outside it's Monad instance?
17:50:20 <hackriledge> Ah, maybe I'm not familiar with this technique with newtypes
17:50:52 <hackriledge> Ok I see how it would work
17:51:42 <ReinH> Sum, Product, Last, First, Backwards, etc
17:51:51 <ReinH> Last and Firt have Monad instances as well.
17:51:53 <ReinH> *First
17:52:05 <hackriledge> And then I specify which monad instance to use in the type signature?
17:52:25 <ReinH> yes, and by wrapping the value in the appropriate newtype constructor
17:53:12 <Nadrieril> like getSum $ mconcat [Sum 1, Sum 2, Sum 3]
17:53:15 <hackriledge> Referring to my structure as a FreeTreeFree or FreeTreeTree or something nicer...
17:53:22 <nshepperd> uh
17:53:32 <Nadrieril> > getSum $ mconcat [Sum 1, Sum 2, Sum 3]
17:53:33 <lambdabot>  6
17:53:37 <Nadrieril> :D
17:53:39 <ReinH> Well, I don't see why you're combining Free Tree into FreeTree in the first place.
17:54:09 <nshepperd> it's not really true that Free Tree has two monad instances
17:54:29 <hackriledge> So I don't lose the Tree Monad structure when writing the Treelike Monad instance
17:54:33 <nshepperd> i mean, any more than [Sum Int] has two monoid instance
17:54:50 <Nadrieril> ^ good example
17:55:38 <hackriledge> I don't see how, my container Tree is traverseable, it is clear I can fold it.
17:55:57 <hackriledge> It's more like [[a]]
17:56:10 <ReinH> What does folding it have to do with the question?
17:56:51 <hackriledge> well it's how I obtain the Free join, containing the trees
17:56:58 <ReinH> nshepperd: Sum Int has a monoid instance and [a] has a different monoid instance.
17:57:00 <hackriledge> Sum
17:57:09 <ReinH> hackriledge: then it isn't free.
17:57:09 <nshepperd> ReinH: yes
17:57:20 <nshepperd> ReinH: this is not the same as [Sum Int] having two
17:57:45 <ReinH> nshepperd: Free Tree has a monad instance and Tree has a monad instance.
17:57:48 <hackriledge> I would handle the Freelike functionality another way, using my FreeMonad class
17:58:01 <ReinH> In the same way that [Sum Int] doesn't use Sum Int's monoid instance, Free Tree doesn't use Tree's monad instance.
17:58:13 <hackriledge> Could also be called SecondMonad
17:58:14 <Nadrieril> that's the point
17:58:16 <nshepperd> there being no principled way to combine two [Sum Int]s using the monoid instance of Sum Int
17:58:24 <ReinH> But both have a canonical interpretation using the underlying instance (Sum Int and Tree respectively)
17:58:24 <nshepperd> ReinH: yes
17:59:04 <ReinH> hackriledge: if your join is aware that FreeTree contains a list, your structure is not free.
17:59:18 <hackriledge> Because FreeTree overwrites a desired Monad instance, this instance is written for FreeTree rather than Tree
17:59:39 <ReinH> FreeTree doesn't overwrite anything? It simply has a different instance.
17:59:42 <hackriledge> No it's tree
17:59:52 <hackriledge> Not free, by design
18:00:02 <ReinH> "well it's how I obtain the Free join, containing the trees"
18:00:04 <ReinH> Then why call it free?
18:00:11 <ReinH> Just to confuse things?
18:00:26 <hackriledge> Possibly that statement is confused sorry
18:01:23 <hackriledge> Free join uses the monads join
18:01:32 <nshepperd> i have no idea what any of you are talking about any more
18:01:32 <hackriledge> So it is not free?
18:01:51 <ReinH> nshepperd: I don't think I do either.
18:01:54 <EvanR> operation defining freedom
18:02:09 <nshepperd> Free f a is a different structure to f a, cannot be given the monad instance from f
18:02:29 <ReinH> Yes.
18:02:36 <nshepperd> there is only one monad instance for Free f in any sane way
18:03:17 <ReinH> It's the one that operates universally over any Functor f. That is why it is Free.
18:03:24 <hackriledge> Because I intend to use the monads join to implement the join in Free monad instance, I had ensure it is not lost, so I write my FreeTree.
18:03:38 <hackriledge> Had better*
18:03:53 <ReinH> hackriledge: but Free Tree doesn't have the same join as Tree. It isn't the same structure.
18:03:55 <nshepperd> what it gives you is a homomorphism Free f a -> f a, that preserves the monad behaviour (iirc)
18:04:11 <ReinH> nshepperd: Yes, since it is initial.
18:04:14 <Nadrieril> hackriledge: let me clarify: you want to use the join from Tree to define the join in FreeTree ?
18:04:24 <hackriledge> No
18:04:57 <hackriledge> I will write an instance of Monad for FreeTree which is not that of Free, but that of Tree
18:05:11 <Nadrieril> ok, you wish you could do that
18:05:14 <hackriledge> I will then use this join to define the join of free
18:05:22 <ReinH> hackriledge: that's like saying "I will write an instance of Monoid for [Sum Int] that is not that of [a] but that of Sum Int"
18:05:24 <hackriledge> I can do that
18:05:26 <ReinH> It doesn't make sense.
18:05:48 <nshepperd> hackriledge: that does not work
18:05:57 <Nadrieril> <nshepperd> there is only one monad instance for Free f in any sane way
18:06:19 <zachk> well that problem of infinite loop, from using re-refrencing of records, only seems to apply a record as a newtype, and not a data 
18:06:44 <hackriledge> Then this is insane, but I think it works. I may not end up with a Free like Monad
18:07:02 <ReinH> You might be able to write something that typechecks.
18:07:04 <ReinH> That does not mean it works.
18:07:13 <zachk> actually it seems fine with newtypes as well, must have had my types/functions wrong yesterday 
18:07:23 <Nadrieril> if you want to try to be sure, please go on
18:07:25 <hackriledge> How would using Trees join violate the monad laws?
18:07:39 <ReinH> hackriledge: how would it satisfy them?
18:08:30 <ReinH> How would it, in point of fact, work at all?
18:08:34 <ReinH> Since the structures are different
18:08:52 <Nadrieril> FreeTree is not a tree, it does not behave as one
18:09:00 <hackriledge> Using klieslie arrow I must show return >=> a = a = a >=> return
18:09:33 <hackriledge> Is that what you are asking me to do now?
18:09:52 <nshepperd> no, because we already know it won't work
18:10:00 <hackriledge> It would behave as one if I wrote it's Monad instance as one...
18:10:07 <Nadrieril> no
18:10:12 <nshepperd> what you are doing is futile
18:10:16 <hackriledge> Lol
18:10:20 <ReinH> Well, no, I'm not particularly interested in the result, but it's not my job to prove random propositions to be false. It's the job of the person proposing it to prove that it's true.
18:10:30 <hackriledge> If I understood why that would be helpful
18:10:48 <Nadrieril> we tried explaining
18:11:00 <Nadrieril> we were not successful apparently
18:11:03 <hackriledge> Ok, you have done great
18:11:09 <Nadrieril> sry
18:11:20 <hackriledge> You do fine, I'm sorry if I respond to indicate otherwise.
18:11:47 <hackriledge> I'll get snacks and find out why this does not with, thanks for letting me know how
18:11:54 <hackriledge> Work*
18:12:13 <hackriledge> I need something that does work though! I'll get it eventually
18:12:25 <ReinH> work for what?
18:13:05 <hackriledge> Ffs, your saying it's impossible! I don't understand why. I just have to go and cry now
18:13:20 <ReinH> Well, you're saying you need something that works.
18:13:35 <hackriledge> And your saying I'm not going to find out
18:13:39 <hackriledge> It
18:13:58 <Nadrieril> depends what you mean by "work"
18:14:19 <hackriledge> Because it's a broken concept. Which is fine I guess if it is indeed the truth I shall understand it and accept it, and continue to cry
18:14:40 <Nadrieril> or redefine what you want and find a way to solve your problem
18:14:43 <hackriledge> I mean I want to be able to define free monad join in terms of tree join
18:15:06 <hackriledge> It's illegal, I give up
18:15:10 <Nadrieril> that is indeed impossible, sorry
18:15:22 <dedgrant> pavolzeter: Ah fusion, the vexing ephemera of optimization... this is not a modular problem in haskell. You'll have to climb down a few abstraction layers. ;)
18:15:25 <hackriledge> Thanks for your help sorry it's painful!
18:15:35 <ReinH> I don't understand why you would expect to use one monad's implementation with a different monad at all.
18:15:50 <hackriledge> And I don't understand why not
18:15:58 <ReinH> Because they are different things
18:16:00 <zachk> monads don't naturally compose with other monads
18:16:07 <zachk> there are monad transformers though 
18:16:14 <hackriledge> Is there something that does?
18:16:29 <hackriledge> Hmm I'll check those out
18:16:32 <zachk> I think applicative does, but I don't have alot of experience with it 
18:16:39 <ReinH> I don't see how monad transformers are relevant
18:16:39 <zachk> maybe you want a monad transformer? 
18:16:46 <Nadrieril> applicative composes with applicative
18:16:58 <hackriledge> Maybe! I'll find out 1 sec
18:17:08 <argoneus> if I use >> instead of >>=, I can use other monads, right?
18:17:13 <Nadrieril> you cant get a monad from applicative.monad afaiu
18:17:19 <argoneus> since I don't need a function (a -> m b)
18:17:31 <hackriledge> I get the feeling the structure I require does not exist, I accept this may be reasonable
18:17:47 <argoneus> like, I can do mymonadfunc >>= mymonadfuncfollowup >> putstrln
18:17:49 <argoneus> right?
18:17:54 <ReinH> hackriledge: What you are saying is equivalent to: I have a list, which has an implementatio of mappend (++). I also have a Sum Int, which has an implementation of mappend (+). Why can't I use (+) to combine two lists instead?
18:18:00 <zachk> are they all IO ? 
18:18:04 <Nadrieril> argoneus: nope, you have to work in the same monad
18:18:09 <argoneus> oh
18:18:17 <zachk> you can nest down using do notation 
18:18:17 <hackriledge> Probably you would want >>= putStr
18:18:25 <ReinH> hackriledge: I don't know why you would expect to be able to use (+) to combine lists simply because it can be used to combine another monoid instance.
18:18:30 <argoneus> wait
18:18:34 <argoneus> with do notation you can use other monads?
18:18:37 <Nadrieril> no
18:18:47 <zachk> hackriledge how do you want to combine the two lists using (+) ? 
18:18:55 <Nadrieril> to be clear: mymonadfunc is some other monad than IO ?
18:18:56 <ReinH> zachk: you're missing a lot of context here
18:19:01 <argoneus> how do you tell from a do then, which monad it's using?
18:19:05 * zachk figures as much 
18:19:20 <ReinH> hackriledge: this is conceptually the same as wanting to use the Monad instance for a Tree on another structure which is not a tree.
18:19:28 <ReinH> There's absolutely no reason to expect it to work.
18:19:35 <zachk> would depend on the functions/actions in the do notation, though it could be generalized to any monad 
18:19:46 <hackriledge> It's for Monad m, do is polymorphic
18:19:52 <argoneus> I don't get how to combine my monads then
18:20:01 <Nadrieril> argoneus: do is only syntactic sugar for f >> g or f >>= g
18:20:02 <argoneus> if I have a custom monad that does something, how can I use the IO monad to print something inbetween?
18:20:16 <Nadrieril> with monad transformers
18:20:17 <ReinH> zachk: this is your cue.
18:20:20 <hackriledge> Free Monad seems, as it's Free, the one I'd prefer to discard
18:20:32 <Nadrieril> it does not make sense to use different monads together
18:20:33 <zachk> run that monad in an IO context and return the answer or use transformers 
18:20:55 <ReinH> hackriledge: you can't discard it. It's the only implementation!
18:21:05 <Nadrieril> you have to somehow explain how their actions combine
18:21:06 <ReinH> There is no other implementation you can use.
18:21:13 <hackriledge> which is why your list example is strange, it's a Free Monoid, I think that confused me
18:21:16 <argoneus> so my function will be :: IO (Monad Mymonad) ?
18:21:18 <argoneus> or is that invalid
18:21:30 <ReinH> and Free is a free monad.
18:21:33 <zachk> yea that looks pretty wrong 
18:21:35 <ReinH> Free f, that is
18:21:44 <zachk> what are you trying to do? 
18:21:50 <ReinH> The comparison between lists and free monads is quite apt.
18:21:55 <hackriledge> But I have an alternative join and return to hand
18:21:57 <argoneus> I was just wondering how to print something while executing my own monad
18:22:11 <argoneus> I don't have concrete code yet
18:22:14 <hackriledge> It's apt but I need snacks
18:22:17 <zachk> you can't do that 
18:22:22 <Jinxit> usually the better option is to return from your pure code and then do IO
18:22:30 <zachk> unless you made your monad over the IO monad 
18:22:37 <Nadrieril> argoneus: putStrLn (runMyMonad m) for example
18:22:37 <argoneus> okay
18:22:42 <argoneus> I guess that's good actually
18:22:48 <zachk> or you could....
18:22:55 <argoneus> the more restrictions a language has the less shitcode I can write
18:22:56 <argoneus> right
18:23:12 <zachk> import Debug.Trace , or use unsafePerformIO, the latter is not recommended much 
18:23:14 <ReinH> hackriledge: A structure might have more than one monad implementation.
18:23:25 <ReinH> But it can't have the monad implementatino for a completely different structure.
18:23:41 <Nadrieril> argoneus: yup, thats the power of it
18:23:48 <pilne> haskell isn't restricting, it just requires things to be done in a sound way.
18:24:01 <argoneus> yeah I was more jabbing at C++
18:24:04 <ReinH> iow it's restricting
18:24:08 <argoneus> where you have 10 solutions to the same problem and 7 of them are horrible
18:24:13 <pilne> oh, i'll join in there argoneus 
18:24:15 <pilne> (:
18:24:15 <ReinH> restricting isn't a negative property
18:24:22 <Nadrieril> argoneus: if you actually want to interleave actions from your monad and IO actions, because for example you do not want to discard some state, you can use monad transformers
18:24:33 <zachk> if you had working code from awhile ago, and want to add new features, once the new code compiles, it usually just works 
18:24:39 <pilne> i feel more like it is "programming with constraints" although now i'm just nitpicking semantics (and probably synonyms...)
18:24:39 <ReinH> Haskell restricts me from doing all sorts of things, like adding strings and numbers together.
18:24:53 <ReinH> And I am quite glad for it.
18:24:58 <zachk> unless you really want to though 
18:25:08 <zachk> you could make a num instance for string couldn't you? 
18:25:15 <ReinH> :t (+)
18:25:16 <lambdabot> Num a => a -> a -> a
18:25:18 <zachk> wait, it would still stop that 
18:25:21 <ReinH> yes, but you still can't add numbers and strings together
18:25:24 <Nadrieril> There's A GHCFlag For It (tm) ? ^^
18:25:41 <Nadrieril> #javascript
18:26:01 <Nadrieril> > 1+"3"
18:26:03 <lambdabot>      No instance for (Num [Char]) arising from a use of ‘+’
18:26:03 <lambdabot>      In the expression: 1 + "3"
18:26:03 <qmm> "Technically speaking, formal parameters (The Report calls these variables.) are also patterns---it's just that they never fail to match a value." from https://www.haskell.org/tutorial/patterns.html
18:26:09 <qmm> what are formal parameters?
18:26:20 <Nadrieril> patterns ? x)
18:26:33 <ReinH> qmm: in foo a = (), a is a "formal parameter".
18:26:47 * hackagebot io-streams 1.3.4.0 - Simple, composable, and easy-to-use stream I/O  https://hackage.haskell.org/package/io-streams-1.3.4.0 (GregoryCollins)
18:26:59 <ReinH> which is a weird term that, afaik, is only used on that page.
18:27:00 <geekosaur> "formal parameter" is terminology often found in other languages
18:27:10 <ReinH> and perhaps in other languages
18:27:30 <ReinH> If the report calls them variables, I think we should be happy to call them variables too. *shrug*
18:31:07 <hackriledge> Sorry battery died, on reserve battery
18:32:04 <hackriledge> return a = Roll a []
18:32:30 <pavolzetor> dedgrant: I have done more profiling and it seems that it hits theoretical max
18:32:44 <pavolzetor> of the memory bandwidth of the cpu
18:33:06 <qmm> http://www.cas.mcmaster.ca/~kahl/Publications/Conf/Kahl-2004a.pdf
18:34:24 <qmm> how is pattern matching typically modeled in lambda calculus?
18:34:50 <hackriledge> join (Roll a n) = Pure (join (a:n))
18:36:09 <dedgrant> pavolzetor: Not terribly surprising. But why? ;)
18:36:16 <hackriledge> Or maybe something like = Pure ( a 'mappend' (join n))
18:36:31 <hackriledge> Somehow violates associativoty
18:36:53 <pavolzetor> dedgrant: maybe because I use doubles and not unboxed types so it read much more memory?
18:37:22 <pavolzetor> I can imagine the cache is trashed a lot
18:38:23 <pavolzetor> however I do not know how to reduce the needed bandwidth without doing some ugly changes :/
18:38:41 <pavolzetor> for example I could have a local stack (as done in the original project)
18:38:53 <ReinH> hackriledge: I'm not sure what you're doing any more, but using Pure and Roll is just going to confuse things if your structure isn't the free monad.
18:38:53 <pavolzetor> and just write that piece in a ST monad
18:39:25 <ReinH> s/using/calling the constructors
18:40:03 <pavolzetor> essentially what the most expensive piece is doing is recursively calls and splits a boxes
18:40:22 <hackriledge> I was trying to write some kind of instance for my FreeTree above...
18:40:29 <pavolzetor> i.e. split into two -> recurse left -> recurse right
18:40:43 <hackriledge> That kind of naturally made both instances the same
18:41:14 <ReinH> hackriledge: Well, ok.
18:41:56 <pavolzetor> I am going to do first algorithmic improvements and then work on this optimization, in worst case, how difficult is it to write something like ISPC kernel and call it from Haskell?
18:42:38 <ReinH> hackriledge: it's still impossible for the reasons already mentioned, but go ahead I guess.
18:43:51 <hackriledge> I'm not sure why it can't satisfy the associative identity law
18:43:54 <argoneus> what exactly does it mean when a function returns IO ()? that it does some computation that involves IO and returns nothing?
18:44:04 <hackriledge> Yes
18:44:14 <hackriledge> Though () is a thing
18:44:22 <argoneus> an empty tuple
18:44:50 <hackriledge> Good representation of nothing
18:45:34 <hackriledge> Better than [] because you will struggle to grow it
18:46:21 <ReinH> :t putStrLn "foo"
18:46:23 <lambdabot> IO ()
18:46:37 <Nadrieril> > putStrLn "foo"
18:46:39 <lambdabot>  <IO ()>
18:46:48 <ReinH> argoneus: putStrLn "foo" is an IO action that is executed only for its effect. It doesn't have a meaningful result, so () is used to repreent this.
18:46:49 <Nadrieril> :(
18:46:54 <hackriledge> :t return ()
18:46:55 <lambdabot> Monad m => m ()
18:47:47 <argoneus> I found a function like printf in Text.Printf
18:47:56 <argoneus> and its definition is printf :: PrintfType r => String -> r
18:48:03 <argoneus> and it says the return value is either String or (IO a)
18:48:53 <argoneus> but I don't get how PrintfType is supposed to be a string or something like IO ()
18:48:57 <argoneus> does "a" qualify as "()"?
18:49:03 <argoneus> other way around
18:49:16 <argoneus> an empty tuple is a type like any other?
18:49:39 <EvanR> i didnt know printf could do IO
18:50:17 <EvanR> or is that its only way to output the answer
18:50:43 <hackriledge> Aha, the train I have hope is because it's not a Free Monad, it's Monad instance is more complex because it's a more complex datastructure than Free. It will not be like a Free Monad. It's like a FreeTree! In the same way Tree is more complex than the free Monoid
18:50:49 <hackriledge> This is what I'm getting at
18:50:51 <EvanR> the type is kind of opaque in this particular case
18:50:55 <acertain> is there a parser combinator library that has both choice with preference and choice without preference (try both, error if both or neither succeed, or let the user specify what to do if both succeed)?
18:51:05 <ReinH> argoneus: printf is a very weird function due to the magic of typeclasses.
18:51:51 <ReinH> hackriledge: but at this point it is neither free nor a tree.
18:52:04 <hackriledge> Console interaction is IO. It could fail unpredictably at runtime
18:52:19 <argoneus> anyway so if I get this right
18:52:27 <hackriledge> It's neither free or tree, but it's a monad!
18:52:38 <argoneus> when I have a do notation, whichever monad I use in the first expression is the one I have to keep until the end of the do?
18:52:46 <hackriledge> What the hell is it!?
18:52:57 <hackriledge> It's cool?
18:53:26 <ReinH> argoneus: do notation is sugar for (>>=) and friends
18:53:28 <ReinH> :t (>>=)
18:53:30 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:53:39 <ReinH> must have the same m throughout
18:53:43 <ReinH> as must do notation
18:53:47 <hackriledge> I guess you would need to see the instances. I'll work on it. Invaluable direction, really got somewhere today (I did at least) thanks a lot everyone
18:53:49 <argoneus> ReinH: yeah that's what I thought
18:53:56 <argoneus> I still don't get it though
18:54:06 <argoneus> you guys told me that stuff like IO (Maybe Int) is bad, but I see some code online use it
18:54:07 <ReinH> argoneus: get what?
18:54:15 <ReinH> what do you mean "bad"?
18:54:32 <argoneus> I don't know what they meant :<
18:54:35 <ReinH> Why would someone say IO (Maybe Int) is bad?
18:54:48 <hackriledge> :t traverseM
18:54:49 <lambdabot>     Not in scope: ‘traverseM’
18:54:49 <lambdabot>     Perhaps you meant one of these:
18:54:49 <lambdabot>       ‘traverse’ (imported from Data.Traversable),
18:54:50 <ReinH> "it's bad" is about the least useful criticism one can utter.
18:54:59 <nitrix> IO (Maybe Int) is perfectly fine; although there's more idiomatic ways to work with those types.
18:55:14 <argoneus> I'll give a quick example
18:55:16 <nitrix> Depending on the situation... but I still don't see anything inherently bad with them.
18:55:27 <ReinH> I can imagine some ways of using it that could be improved
18:55:31 <ReinH> but as a type, what's not to like?
18:55:44 <Clint> types are bad, mmmkay
18:55:46 <nitrix> ReinH: MaybeT for example, but I'm with you here.
18:55:51 <ReinH> nitrix: right.
18:56:05 <argoneus> say I want to check if a number is a prime using the naive implementation (check for mod from 2 until n), and for each number I test print out "Testing number x, works/doesn't work"
18:56:20 <argoneus> this will probably require me to combine some monads, no?
18:56:23 <hackriledge> I cant remember what has type (Traversable t, Monad m) => t (m a) -> m (t a)
18:56:45 <Rembane> hackriledge: sequenceA?
18:56:56 <ReinH> :t sequence
18:56:57 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
18:57:07 <ReinH> sequenceA is for Applicative
18:57:18 <hackriledge> Will that help argoneus?
18:57:21 <ReinH> sequence doesn't really use the Monad instance,  but it exists for historical reasons
18:57:33 <argoneus> hackriledge: I'm not sure :<
18:57:35 <Nadrieril> soon it will be free
18:57:41 <ReinH> well, it doesn't *need* to, at least.
18:58:01 <ReinH> argoneus: Well, that could be represented as Int -> IO Bool
18:58:23 <ReinH> or it could be represented as Int -> Writer [String] Bool, where the list of messages are created first and then can be printed later.
18:58:40 <ReinH> Neither of those require combining monads
18:58:59 <argoneus> hm, right
18:59:08 <ReinH> s/are created/is created
18:59:15 <hackriledge> :t mapM
18:59:16 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
19:00:05 <hackriledge> Maybe we could have for example what monads you would like to transform between
19:00:30 <ReinH> There aren't any yet.
19:00:32 <hackriledge> Oh sorry I didn't see your example
19:00:52 <argoneus> I'm trying to think of an example
19:00:52 <ReinH> and neither sequence nor mapM transform between monads
19:01:04 <argoneus> but I can't think of anything I want to write right now that demonstrates it
19:01:30 <hackriledge> Lol
19:02:06 <hackriledge> I think in any car you would define a function to do so
19:02:12 <hackriledge> Case*
19:03:29 <hackriledge> Of type (monad m1, monad m2) => a -> m1 -> m2
19:04:19 <hackriledge> You wouldn't expect ghc to know how you wanted to do it
19:04:30 <argoneus> well, for example if I had some sort of bot or crawler or whatever and I want it to print something, so I have my Bot or Crawler monad with some functions that do the log, and then I want something like printDebugMessage ::, though it would have to return IO () or such to be able to use IO, and then I run into a problem, no?
19:04:35 <argoneus> or maybe I'm still thinking wrong about this
19:04:42 <argoneus> that do the logic**
19:04:55 <hackriledge> Woah!
19:05:35 <ReinH> hackriledge: well, that's a kind error.
19:06:08 <hackriledge> Yeh sorry, with the monad applied to something sorry
19:06:09 <Jinxit> argoneus: resolve that problem when you get there
19:06:34 <hackriledge> > Just 1 >>= putStrLn
19:06:35 <lambdabot>      Couldn't match type ‘IO’ with ‘Maybe’
19:06:36 <lambdabot>      Expected type: String -> Maybe ()
19:06:36 <lambdabot>        Actual type: String -> IO ()
19:06:41 <argoneus> I don't want to solve a nonexisting problem, I just want to know what my options are
19:06:55 <argoneus> and this is close to something I might want to write soon
19:07:00 <argoneus> and maybe I'm thinking wrong about it
19:07:25 <hackriledge> > (putStrLn.fromJust) Just 1
19:07:26 <lambdabot>      Couldn't match expected type ‘Integer -> t’
19:07:27 <lambdabot>                  with actual type ‘IO ()’
19:07:27 <lambdabot>      The function ‘putStrLn . fromJust’ is applied to two arguments,
19:07:50 <Cale> argoneus: A common approach is to provide a function to translate an IO action into an action in your Bot or Crawler monad
19:07:59 <hackriledge> > (putStrLn.fromJust) (Just 1)
19:08:00 <lambdabot>      No instance for (Num String) arising from the literal ‘1’
19:08:00 <lambdabot>      In the first argument of ‘Just’, namely ‘1’
19:08:00 <lambdabot>      In the first argument of ‘putStrLn . fromJust’, namely ‘(Just 1)’
19:08:06 <hackriledge> Sorry
19:08:10 <Cale> argoneus: There is a type class for monads with such an operation called MonadIO, with the single method:
19:08:12 <Cale> :t liftIO
19:08:14 <lambdabot> MonadIO m => IO a -> m a
19:08:27 <argoneus> Cale: so I write a wrapper for putStrLn that returns Monad Bot?
19:08:45 <hackriledge> Brilliant!
19:08:52 <argoneus> actually wait, these are the.. monad transformers, right, I should read up on it
19:08:58 <Cale> argoneus: You could write  liftIO (putStrLn s) :: Bot ()
19:09:16 <Cale> argoneus: However, I'm not a huge fan of transforming IO lightly
19:09:45 <argoneus> Cale: how would you write a bot that has the option of printing stuff during runtime then?
19:10:00 <Cale> It depends. I might very well just use the IO monad directly.
19:10:07 <argoneus> or maybe I could have a dedicated BotLogger monad
19:10:13 <argoneus> or maybe I'm overcomplicating things with monads everywhere >_>
19:10:16 <Cale> Not everything needs its own new monad :P
19:10:46 <Cale> (you can get this impression easily looking at some people's code though)
19:10:56 <Cale> It's not necessarily wrong to have a new monad either
19:11:09 <argoneus> kinda smells like OOP
19:11:31 <Cale> One of the alternate approaches is literally OOP
19:11:34 <Cale> haha
19:11:57 <hackriledge> :t ((return :: a -> IO a) .  fromJust)
19:11:58 <lambdabot> Maybe a -> IO a
19:12:04 <Cale> Well, okay, I should say what I mean. It looks a bit weird and not much like OOP unless you're in my head.
19:12:49 <argoneus> I was actually looking at this before https://wiki.haskell.org/Roll_your_own_IRC_bot and already in the first code example under section 2 I didn't get how they figured out the function signature for write ::
19:13:03 <hackriledge> Aha so that is a monad transformer? And all monad transformers from IO are implementations of liftIO?
19:13:04 <Cale> One of the advantages of constructing a new monad to use rather than IO is that you can restrict the actions which are allowed to occur (if you don't provide liftIO outside of some module)
19:13:05 <argoneus> I get they need some sort of socket handle and 2 strings, but why return IO ()
19:13:55 <Clint> argoneus: what else would you return?
19:14:01 <argoneus> well
19:14:15 <Cale> argoneus: Well, that much is kind of obvious: it takes a Handle and the name of the IRC command, and the remainder of the line, and it produces an IO action which when executed will send the appropriate message.
19:14:21 <argoneus> in the main function, connectTo returns a Handle
19:14:32 <argoneus> which isn't a monad, it's some data type
19:14:41 <argoneus> I don't even get how they can use the do notation there >_>
19:14:48 <Cale> argoneus: It *must* be an IO action (or something built in terms of IO) because it literally performs I/O: it writes to the socket handle.
19:15:08 <Cale> hm?
19:15:13 <Cale> main is itself always an IO action
19:15:35 <Cale> connectTo is a function which produces an IO action for connecting to a server
19:15:45 <Cale> (on a given port)
19:15:46 <argoneus> yeah, it returns an IO Handle
19:16:01 <Cale> yeah the result of applying the function is an IO Handle
19:16:08 <Cale> and the result of executing that action, is then a Handle
19:16:10 <Cale> so h :: Handle
19:16:42 <Cale> Remember that "v <- x" means "execute the action x, and call its result v"
19:16:47 <Cale> If x :: IO t, then v :: t
19:17:06 <argoneus> how do you know if it gets executed or not?
19:17:37 <Cale> I'm not sure how to answer that question... it doesn't get executed unless we explicitly say to do so.
19:17:54 <Cale> In particular, evaluation never causes execution to occur.
19:18:06 <argoneus> oh wait
19:18:08 <Cale> main gets executed
19:18:20 <Cale> and in turn, it may execute other IO actions
19:18:24 <argoneus> if I rewrote this as connectTo server... >>= \x -> something
19:18:26 <Cale> which may execute yet others
19:18:32 <argoneus> then \x is a Handle, not an IO handle
19:18:36 <geekosaur> yes
19:18:37 <Cale> correct
19:18:40 <argoneus> because of the way >>= works
19:18:46 <geekosaur> in fact that;s what <- turns into
19:18:56 <Cale> Yeah, that's directly the desugaring of this :)
19:19:26 <argoneus> so every one of the functions called in the do returns an IO Handle?
19:19:32 <Cale> @undo do h <- connectTo server (PortNumber (fromIntegral port)); hSetBuffering h NoBuffering; write h "NICK" nick; listen h
19:19:33 <lambdabot> connectTo server (PortNumber (fromIntegral port)) >>= \ h -> hSetBuffering h NoBuffering >> write h "NICK" nick >> listen h
19:19:36 <argoneus> but
19:19:40 <argoneus> write returns IO ()
19:19:42 <argoneus> not an IO Handle
19:19:50 <argoneus> isn't that a different type?
19:19:56 <Cale> :t (>>=)
19:19:57 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:20:00 <Cale> :t (>>)
19:20:01 <lambdabot> Monad m => m a -> m b -> m b
19:20:03 <hackriledge> The Free Monoid is a list. A tree is not a Free Monoid, but it is a Monoid. My Free Tree is not Free but it is a Monad. It's ok, makes sense, is good a.t.c ???
19:20:13 <Cale> the m stays the same, the results of the actions may have different types
19:20:13 <qmm> is there a paper describing the origins of System Fc?
19:20:18 <argoneus> oh
19:20:23 <argoneus> write isn't saved anywhere
19:20:38 <qmm> sorry, I meant System Fw
19:20:38 <Cale> yeah, also, we don't give a name to the result of write, as it's an empty tuple anyway
19:20:54 <Cale> we could, but since it's an empty tuple, we kinda know what it's going to be
19:20:54 <qmm> System Fc is at http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/fc-normalization-rta.pdf
19:21:04 <qmm> nevermind, off topic
19:21:08 <argoneus> this hurts my head :( I'm kinda starting to get how you use monads, but I have no idea why or when I'd write my own
19:21:15 <Cale> qmm: I don't think that's off-topic
19:21:47 <geekosaur> argoneus, I think you don't worry about that at this point
19:21:48 <qmm> i figured it would be more appropriate in #ghc
19:21:56 <geekosaur> monads kinda have to be experienced / used
19:22:01 <qmm> i don't care where it goes :)
19:22:01 <cads> hey guys, has anyone done work with chrome in haskell?
19:22:14 <Cale> qmm: F_omega was one of Girard's original systems wasn't it? Maybe it wasn't his, but it's part of the lambda cube
19:22:18 <qmm> (as long as it's appropriate and not too annoying)
19:22:27 <geekosaur> as you gain experience in how monads "work", you'll start to see places where you might want to build your own
19:22:53 <Cale> errr
19:23:49 <Cale> Well, System F is Girard and Reynolds
19:24:06 <Cale> The idea of the lambda cube is Barendregt's apparently
19:24:08 <cads> I'm seeing a neat Test.WebDriver thing for interacting with chrome extensions
19:24:37 <argoneus> geekosaur: not sure what kind of stuff to write to figure it out, though
19:24:47 <argoneus> in mathematical exercises from euler or something you don't really need monads do you
19:24:49 <Cale> Thierry Coquand is responsible for the Calculus of Constructions which is at the far corner...
19:24:52 <cads> which is neat if that's what I think it is (I'm guessing it's part of a test building framework for development)
19:25:15 <geekosaur> cads, WebDriver is Selenium
19:25:27 <geekosaur> standard web testing framework
19:25:51 <geekosaur> that drives actual browsers instead of trying to pretend to be a browser itself
19:25:51 <cads> http://hackage.haskell.org/package/webdriver-0.3.1/docs/Test-WebDriver-Chrome-Extension.html
19:26:30 <hackriledge> If Tree is an extension to the free Monoid, what is a tree like extension to the Free Monad?
19:26:32 <Cale> argoneus: I wish you had been here for the long discussion I had earlier about building a monad of parsers
19:27:12 <argoneus> :(
19:27:17 <Cale> argoneus: Basically, the Monad class captures a pattern which reappears in many libraries in a style that functional programmers have been writing for many years before we learned the term "monad"
19:27:17 <argoneus> I feel kind of bad
19:27:44 <Cale> Don't feel bad, it's not obvious, you need to see lots of examples before you'll really get it
19:27:56 <Cale> https://wiki.haskell.org/Monads_as_computation
19:28:03 <qmm> thanks Cale for mentioning lamda cube, i'll remember that, and get back to the pattern matching section of a gentle intro, quite the detour i just had :)
19:28:05 <argoneus> yeah but every person on irc and every second blog on the internet explains monads >_>
19:28:08 <argoneus> and I still don't get it
19:28:15 <geekosaur> ...mostly poorly
19:28:16 <Cale> I have some paragraphs at the start of this which explain why we care
19:28:25 <Cale> Yeah, most monad tutorials are awful
19:28:25 <cads> geekosaur, I'm not exactly sure what I'm looking at in that link ^
19:28:26 <argoneus> ah yeah I read that before
19:28:45 <qmm> with haskell, you're so aware of the type system, it's easy to get lost in things like that and learn a little something extra :)
19:28:50 <Cale> Really the only way that anyone ever *actually* gets it is to see enough examples of monads.
19:29:27 <hackriledge> A monad is a functor with a method join to form a category, under the kliesli arrow with associative identity function return
19:29:36 <Cale> and/or to not overthink what the Monad class and its laws are, and just accept that it's something which shows up often enough that we can save writing some code whenever we see it
19:30:10 <hackriledge> Is my definition good?
19:30:24 <argoneus> the closest I've been to similar syntax is when I tried learning ruby and they loved doing stuff like program.configurer do ... setthis 1; setsomething else 10 ... end
19:30:32 <argoneus> but that's probably a different concept
19:30:39 <hackriledge> :t (>=>)
19:30:40 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
19:30:48 <Cale> hackriledge: I get what you're trying to say, the idea behind it is okay, but it's a bit word-salady and possibly unhelpful to a beginner :)
19:31:12 <qmm> why do formal paramters, or variables never fail to match a value as mentioned at https://www.haskell.org/tutorial/patterns.html 
19:31:16 <hackriledge> @src (>=>)
19:31:16 <lambdabot> Source not found. Where did you learn to type?
19:31:26 <geekosaur> cads, I'm not sure you are looking at anything. selenium webdriver starts out driving a plain browser. if you want it to test in a browser with an extension loaded, you use that to tell webdriver about the chrome extension by having it load the extension installer package (foo.crx on windows) into its browser session
19:31:35 <Cale> qmm: Why would they?
19:31:56 <geekosaur> qmm, it matches any pattern and binds it to a name
19:32:09 <geekosaur> it does not deconstruct the pattern, so it will match even undefined
19:32:17 <Cale> qmm: They match whatever is in that position, unconditionally. It's the data constructors which can fail to match, because there might be a different data constructor which could be there
19:32:22 <geekosaur> er, matches any value
19:33:19 <Cale> qmm: Think about the simplest example of a variable pattern: if I write something like  f x = x  you ought not to worry about whether my pattern "x" on the left hand side will match.
19:35:27 <cads> geekosaur, ah, okay. So the webdriver package is a haskell interface to the selenium server, which lets you write selenium tests in haskell.
19:35:28 <qmm> thanks geekosaur and Cale
19:35:36 <qmm> what are the main types of System Fc?
19:35:43 <cads> geekosaur, do I have that right?
19:36:08 <geekosaur> yes
19:36:56 <Cale> qmm: Wait, that's a question which is like 7 levels higher qualification rating than the one you immediately asked before it :D
19:37:14 <Cale> or something
19:37:40 <Cale> qmm: What's going on? What are you attempting to do?
19:37:51 <hackriledge> A Monad is a data type which takes a type parameter, and has functions to create and modify it as well as turn Monads of Monads of a into Monads of a, such that when used to define a function (>=>) :: (a -> m b) -> (b -> m c) (a -> m c) such that; return >=> f = f >=> return = f
19:37:57 <hackriledge> Better?
19:38:09 <Cale> hackriledge: "create and modify it"?
19:38:18 <Cale> also "monads of monads"?
19:38:24 <hackriledge> Return and fmap
19:38:43 <Cale> return isn't just any function
19:38:53 <qmm> Expr, Var, and Type
19:38:59 <Cale> also I wouldn't refer to what fmap does as modifying something
19:39:05 <hackriledge> Alternatively then just see the definition as the class deceleration
19:39:09 <Cale> yeah
19:39:13 <Cale> That's probably better :)
19:39:21 <Cale> Write the class declaration, write the laws :)
19:39:39 <hackriledge> Just associative identity right?
19:39:54 <hackriledge> For the laws...
19:40:41 <Cale> If you want to be fancy, you can say that return and (>=>) give the identity arrows and the composition for a category, whose objects are types, and whose arrows are functions a -> m b
19:41:04 <Cale> However, while this is nice, it's a bit of a departure from the real definition.
19:41:12 <hackriledge> A Monad is a Functor with return as the associative identity of the composition of Monad creation functions
19:41:25 <Cale> and kind of tricky to actually *use* in practical cases, unless you like to write everything with lots of (>=>) everywhere
19:41:42 <Cale> "monad creation functions" is weird
19:41:54 <Cale> The monad is the type constructor m
19:42:06 <hackriledge> I do
19:42:09 <Cale> You're not creating monads...
19:42:16 <hackriledge> Ok
19:42:25 <Cale> unless I totally misunderstand what you're trying to say :)
19:42:43 <hackriledge> No no, my terminology is misleading
19:42:44 <Cale> Monad transformers in some sense "create monads"
19:43:02 <hackriledge> Transform monads
19:43:02 <Cale> Like, you can apply StateT Integer to some monad to get another monad
19:43:24 <Cale> Maybe is a monad, Just 5 is not
19:43:39 <hackriledge> Monad parametrising functions?
19:43:41 <Cale> IO is a monad, getLine is not
19:43:51 <qmm> woah, it has univeral quantification built-in
19:44:09 <Cale> qmm: yes, System F has that too :)
19:44:14 <hackriledge> Functions which provide contents to a Monad?
19:44:44 <hackriledge> Is contents misleading?
19:44:48 <Cale> qmm: I'm curious what you're reading and what your goals are
19:44:52 <Cale> hackriledge: probably
19:44:57 <hackriledge> Yeah...
19:45:08 <hackriledge> It's hard
19:45:10 <Cale> What are the contents of IO?
19:45:15 <hackriledge> ()
19:45:23 <Cale> IO is a monad
19:45:28 <Cale> IO () isn't a monad
19:45:33 <Cale> IO String isn't a monad
19:45:46 <Cale> getLine isn't a monad
19:46:07 <hackriledge> A value of any type can be contained within a monad
19:46:14 <Cale> uh, what?
19:46:17 <Cale> No.
19:46:22 <hackriledge> Doh
19:46:30 <rcyr> Corrupted by the burrito analogy :P
19:46:37 <qmm> Cale: it's all about the journey, no end goal really
19:46:50 <Cale> If we say that some type t is "in the monad M", usually we mean that it's t = M s for some type s.
19:47:17 <Cale> qmm: Yeah, I'm just wondering how you're learning about Fc at the same time as variable patterns
19:47:39 <Cale> qmm: It seems like there would usually be at least a few months of stuff in between those two
19:47:44 <Cale> if not longer...
19:47:52 <Cale> for me it was probably several years
19:48:15 <hackriledge> 6 for me
19:48:41 <Cale> hackriledge: what? You know about System FC?
19:48:48 <hackriledge> And it's helping a lot to know I have fairly solid grounding
19:48:54 <Cale> oh, just learning Haskell
19:48:56 <Cale> I see
19:49:17 <hackriledge> Yeh and I'm just hitting this stuff now
19:49:30 <argoneus> mhm
19:49:38 <argoneus> I'll just look at applications of the common haskell monads
19:49:47 <argoneus> that should help a lot, anyway thanks guys, good night :)
19:49:58 <hackriledge> Ciao!
19:49:59 <Cale> argoneus: Yeah, looking at some examples is good
19:50:15 <Cale> argoneus: and maybe I can be convinced to give the Parser lecture again soon enough
19:50:24 <Cale> argoneus: ask me about it next time you're around
19:50:31 <argoneus> Cale: ping me like you mean it when you feel like it
19:50:41 <argoneus> I don't want to inject your schedule
19:50:52 <Cale> It's okay, I just won't answer if I'm busy
19:50:53 <Cale> haha
19:51:00 <qmm> Cale: you teach? i would love to listen, watch, or read a lecture
19:51:02 <argoneus> lel, fair enough))
19:51:27 <Cale> qmm: I've been teaching in a large fraction of my spare time on #haskell for over a decade now
19:51:40 <qmm> ah
19:51:46 <qmm> you've helped me out quite a bit too
19:51:58 <Cale> I don't usually get to do it live
19:52:05 * hackagebot wai-middleware-content-type 0.2.0 - Route to different middlewares based on the incoming Accept header.  https://hackage.haskell.org/package/wai-middleware-content-type-0.2.0 (athanclark)
19:52:42 <hackriledge> Can we see TypeFamiles in use on lambdabot?
19:52:50 <qmm> what a journey these past 10 years must have been
19:53:47 <Cale> Yeah, I started learning Haskell around 2001-2002, and participated in the old Haskell wiki a lot in the early portion of that
19:53:59 <hackriledge> I wish i could reward you and the others on here. I'm going to write something very fast and genetic hopefully!
19:54:19 <Cale> and I don't know exactly what year it was I joined #haskell, but there were a fair bit fewer than 100 people here
19:54:25 <MarcelineVQ> hackriledge: contribute to ghc :D
19:54:38 <hackriledge> I'll port out to android
19:54:42 <hackriledge> It
19:54:59 <hackriledge> Stgm to java
19:55:02 <Cale> There have been some efforts to get GHC compiling to Android, if not running on it.
19:55:11 <qmm> Cale: if you have a little time, and you don't mind sharing i would love hear from you and by all means, anyone else who's been in here a good while. have you seen any general trends in this community over the past 10, 20 years? what were some of the hard faught battles for the language and its community?
19:55:18 <hackriledge> I know then all, they are depreciated
19:55:23 <hackriledge> Them
19:55:29 <Cale> hackriledge: But they didn't involve the JVM at all, just using the underlying ARM
19:55:41 <hackriledge> llvm backend
19:55:44 <Cale> (well, maybe a bit of JVM stuff)
19:56:16 <hackriledge> Compiling c to arm is no good
19:56:32 <hackriledge> Need to use the android native compiler
19:56:43 <Cale> qmm: It has gotten a lot larger, but it's kind of self-similar. We've thankfully managed to keep things pretty friendly, and not turned into the sort which just tells people to RTFM at the drop of a hat.
19:56:50 <Jinxit> there was that one breakout game
19:57:05 <hackriledge> Push to play store etc from ide
19:57:33 <hackriledge> Jitnxit it used neurocyte, it's down
19:58:12 <hackriledge> Some other guys revamped it. That's down now too
19:58:32 <hackriledge> Strait to java will be more robust over time
19:58:44 <Cale> qmm: btw, given the stuff you've been asking about previously, have you seen the book "Types and Programming Languages" by Pierce?
19:59:38 <hackriledge> But jhc didn't support sufficient language extensions for the guys who wrote the game
19:59:41 <qmm> i have
19:59:48 <hackriledge> And the end of that search...
20:00:09 <qmm> Cale: i've heard it suggested about 10 times now, and it seems to be standard reading for several people
20:00:14 <Cale> qmm: It's a good book in that direction if you haven't read it, it covers System F and F_omega at least.
20:00:16 <Cale> yeah
20:00:16 <qmm> i haven't read it yet
20:00:35 <qmm> oh, i'll purchase it then
20:01:56 <hackriledge> MarcelineVQ do you know anyone I could find to supervise this?
20:02:38 <MarcelineVQ> that's a complete non-sequitur to me
20:03:27 <MarcelineVQ> What is needing supervision?
20:03:27 <hackriledge> The term non sequitur refers to a conclusion that is not aligned with previous premises or evidence.
20:03:35 <hackriledge> Work on ghc
20:03:48 <hackriledge> By me
20:03:50 <Cale> hackriledge: well, you should hang out in #ghc if you're not already
20:04:12 <MarcelineVQ> https://ghc.haskell.org/trac/ghc/wiki/Newcomers :>
20:05:02 <hackriledge> I meant more for a job, but if it's a community effort, fair enough. Could you clarify that? Is there a possibility of doing such work professionally?
20:05:22 <MarcelineVQ> If you work for a company that relies on ghc then quite possible
20:05:24 <MarcelineVQ> *possibly.
20:05:38 <hackriledge> But not in academia?
20:05:52 <MarcelineVQ> I've no idea
20:05:59 <hackriledge> Like in Glasgow or something...
20:06:00 <Cale> hackriledge: Well, Simon Peyton Jones has a job at MS Research working on it.
20:06:35 <Cale> and there are other functional programming language researchers in academia whose work involves Haskell in one way or another
20:06:37 <hackriledge> Wow! He is a bit better than me though... Probably requires less supervision...
20:06:59 <Cale> (many)
20:07:13 <Cale> I don't know how many of them are direct contributors to GHC
20:07:29 <erikd> hackriledge: well-typed (a consultancy) employs some people to work on GHC. i also spent about 6 months last year (50% of my work time) improving ARM and ARM64 support
20:07:45 <hackriledge> I was wondering if prof ghc was around some place
20:09:06 <hackriledge> Like mr top dog kind of think but maybe that's Phil Wadler, or one of his proteges
20:09:46 <erikd> SPJ would probably deny it but he's the closest thing we have to prof ghc
20:10:50 <hackriledge> erikd, thanks! Yeh, but like I say, most Android users don't want to have to use proot
20:11:55 <hackriledge> So it's work on extending jhc that is needed I think!
20:13:56 <hackriledge> ericd, do you get to arm via stgm to c?
20:14:46 <hackriledge> Oh he quit, does anyone else know?
20:16:45 <Cale> hackriledge: I don't know if anything uses compilation via C any more.
20:16:59 <Cale> Does that even still exist in GHC in any form?
20:17:03 <hackriledge> Oh... I'm miles off
20:17:08 <Cale> It's not available on x86
20:17:21 <hackriledge> I was basing this of the stgm paper
20:18:01 <hackriledge> It still goes through that right?
20:19:47 <v-xri> do write  REST clients in yesod or is it more common to use other packages for that?
20:19:54 <v-xri> do people write...
20:22:06 * hackagebot warp 3.2.1 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.2.1 (MichaelSnoyman)
20:23:30 <hackriledge> Id love to see a good answer to that question
20:23:43 <hackriledge> So I'm not going to answer it!
20:24:19 <hackriledge> Warp is under yesod?
20:26:34 <hackriledge> I never got yesod to work without nginx for port forwarding
20:28:01 <hackriledge> Most of these I have never heard of; https://wiki.haskell.org/Web/Frameworks
20:46:52 <qmm> why did simon et al not try to encode ADTs in system f?
20:48:31 <qmm> ease of use, i suppose
20:54:13 <johnw> does sbv-5.7 pass tests for others here?
20:57:34 <hodapp> johnw: I'll try it out here if I can figure out which button to push on cabal...
21:01:35 <qmm> "The pattern-matching rules can have subtle effects on the meaning of functions."
21:01:45 <qmm> to say the least! :)
21:01:54 <lamda_sage> I went to install haskell-platform on osx and the installer said it would take 3.09 GB of space to install. What the heck is taking so much space? Surely the compiler can't be more than a few mbs??
21:02:01 <johnw> hodapp: cabal test :)
21:02:11 <qmm> take  0 bot =>  [] ; take1 0 bot =>  _|_ ; take  bot []  =>  _|_ ; take1 bot []  =>  []
21:02:49 <qmm> what a powerful example in 4.2 of the tutorial
21:04:49 <hodapp> johnw: passes for me.
21:04:58 <johnw> on Linux?
21:05:13 <hodapp> yes
21:05:23 <johnw> ok, it's possible the failure is OS X specific then
21:05:29 <johnw> 7.10.3 also, I imagine?
21:05:30 <hodapp> need me to try on OS X too?
21:05:38 <johnw> oh, if it's easy for you to do, please!
21:05:44 <hodapp> yes, 7.10.3
21:05:58 <johnw> it just started failing in Nix today, so I wondered if it was failing for anyone else
21:06:07 <hodapp> I have 7.8.3 on OS X, is that still a meaningful test?
21:06:38 <johnw> not really, no
21:06:53 <johnw> I couldn't even get sbv building on 7.8 here, so I gave up caring
21:06:53 <kadoban> lamda_sage: It's pretty big. I'm not really sure why. It's mostly packages themselves I think. If I had to guess … it mostly just doesn't hurt anything, a few gigs here and there don't really add up to much in terms of hard-drives these days.
21:07:26 <kadoban> lamda_sage: haskell platform … I wouldn't really recommend, by the way. The best way to go currently is just install 'stack' and let it install GHC and whatever for you.
21:08:53 <qmm> Cale: i had the impression earlier that if you could learn the simple language underlying haskell, it would be easier to understand many of the concepts in haskell more concreteley. i believe that is the thought which stuck with me until i started reading about pattern matching and wondering about how it was parsed and modeled
21:09:19 <qmm> ...to answer your question belatedly
21:11:38 <hodapp> johnw: I'm updating to 7.10.3... it needed it anyhow. I'll test once that's downloaded.
21:11:46 <johnw> thanks, hodapp!
21:13:41 <hodapp> hrmph. one of these days I really want to learn SBV
21:13:56 <hodapp> or, use it enough that I have a good idea how I could apply it
21:17:47 <johnw> i can show you a simple example, if that helps
21:17:58 <Cale> qmm: Ah, well, there is a simple-ish language underlying Haskell, but most of the stuff you read about it won't be aimed at beginners, so unless you're already familiar with type theory, that's probably a hard route to take. On top of that, even once you know how FC works, there's the matter of how everything translates into it, which is pretty involved.
21:18:19 <Cale> qmm: (and probably hard to follow unless you already know what you're trying to implement)
21:19:25 <Cale> qmm: However, the simplicity of that core language does help all the things you might learn about separately feel like they work together nicely, even without looking at how the translation is actually done.
21:19:42 <qmm> Cale: what kind of familiarity with type theory roughly?
21:20:06 <qmm> what kind of familiarity with type theory is needed, roughly?*
21:21:16 <qmm> Cale: if you don't want to there now, i understand
21:21:57 <Cale> I guess if you already know about F_omega, and you know about algebraic data types, it's "just" adding on type equality constraints
21:23:24 <Cale> FC as presented in the paper doesn't discuss type class constraints though -- it's sort of assuming that those have already been translated away
21:23:46 <johnw> hodapp: https://seanhn.wordpress.com/2009/06/01/fun-uses-for-an-smt-solver/
21:24:11 <hodapp> ooh, thanks
21:24:17 <Cale> Well, to some extent -- it talks about how the functional dependencies on certain type classes get translated in terms of equality constraints
21:24:34 <Cale> But the rest of the instance resolution stuff is left out at that level
21:26:18 <johnw> hodapp: if you find yourself with a computable formula, and you are just "plugging in inputs" to try to find an answer, or you have an answer and you're looking for inputs that will lead to it, then you can use an SMT solver to automatically search the space of possibilities for you and make the computer do the work.
21:26:40 <Cale> There's this bigger paper which describes a type system generalised over certain sorts of constraints, which gets into more detail on that sort of thing http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/jfp-outsidein.pdf
21:27:38 <Cale> Probably not the easiest reading if you're just starting out though
21:27:45 <johnw> hodapp: once I wondered if a^4 + b^4 + c^4 + d^4 = e^4 had a solution, so I wrote a two-liner in SBV that found an answer for me (Googling would have answered too, but it gave me a reason to try out SBV)
21:28:51 <qmm> Cale: thank you for being willing to share that. 
21:29:57 <qmm> i'm sorry to everyone for all the terribly beginner questions to follow on Data and its libraries (if i feel stuck)
21:30:12 <Cale> that's cool
21:30:20 <qmm> s/Data/Haskell
21:30:27 <johnw> qmm: never worry about having beginner questions
21:30:42 <Cale> qmm: The OutsideIn(X) paper is pretty great when it comes to discussing the design space of possible type systems surrounding GHC Haskell's and why certain decisions were made the way they were.
21:31:53 <lamda_sage> Cale: What do you think about http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/about/ would you recommend using something like that?
21:32:20 <johnw> lamda_sage: for what kind of application?
21:33:09 <Cale> lamda_sage: It's probably worth looking at -- it's still pretty experimental.
21:33:30 <dolio> qmm: To answer your earlier question, encoding data types in System F is not the best way to implement them for all uses.
21:34:00 <Cale> lamda_sage: It takes a subset of Haskell, so there's a limited amount of stuff you can do with it in a practical setting yet.
21:34:31 <qmm> ease of use, in a sense?
21:34:41 <qmm> dolio ^
21:34:43 <lamda_sage> johnw: I see
21:34:59 <dolio> It's not about ease of use. It's about performance.
21:35:01 <lamda_sage> johnw: Maybe for a compiler?
21:35:02 <qmm> Cale: i almost can't wait to read that paper now 
21:35:06 <qmm> thanks again
21:35:15 <dolio> Although I guess ease is also a factor.
21:35:22 <Cale> lamda_sage: But if your properties are of the sort that it can handle, and you're really concerned about correctness of your program, maybe it's easier to formulate your question in a way that LiquidHaskell can get you an answer more easily than trying to translate your program into Coq or something.
21:35:46 <johnw> lamda_sage: if your need of it is right, then it can be quite useful. If you decide to do something real with it, write to rjhala about what you're up to. They're all very nice and helpful folks. gridaphobe works on that project
21:36:19 <johnw> if you decide to go the Coq route, let me know in #coq
21:36:45 <qmm> :t Data.List.length
21:36:47 <lambdabot> Foldable t => t a -> Int
21:36:53 <qmm> :t GHC.List.length
21:36:54 <lambdabot> [a] -> Int
21:37:15 <dolio> qmm: For instance, `case l of [] -> [] ; _:xs -> xs`
21:37:35 <dolio> Consider how expensive that is for a list encoded in System F.
21:38:08 <Cale> lamda_sage: I'm not sure about a whole compiler, but for something on the scale of a pure data structure implementation (like Data.Map, for example), it seems to do a pretty decent job of things.
21:38:10 <hodapp> johnw: tests passed on OS X.
21:38:55 <johnw> hodapp: OK, thanks, I'll track down why Nix is causing it to fail
21:39:11 <hodapp> alrighty
21:39:42 <hodapp> OS X 10.9.5, should that come up
21:39:55 <qmm> thank you dolio
21:41:15 <johnw> oh yeah, I suppose so
21:45:19 <mikek> what is the proper format for asking questions?
21:46:21 <johnw> no format, just ask what you need to know
21:46:34 <kadoban> mikek: iambic pentameter (whatever, just ask … no real format)
21:47:55 <mikek> ok, heh. so let's say I have: 'data T = A | B | C' and I want to write a function that returns True for A and otherwise False. Is there a better way than 'f A = True \n f B = False \n f C = False'?
21:48:24 <johnw> there are other ways
21:48:33 <johnw> but they aren't necessarily better; it depends on what kind of "better" you need
21:48:51 <johnw> the 'lens' package makes queries like this easily generated, so that you'd say: has _A x
21:49:00 <johnw> but that comes at the cost of pulling in the lens dependency
21:49:12 <KaneTW> i don't think that way is bad (the explicit one)
21:49:25 <kadoban> mikek: You can collpase the False cases into one at least:   f A = True\nf _ = False
21:49:43 <mikek> ah ok. yeah, I'm trying to define a semigroup where some <>'s cancel and others combine, without too much boilerplate
21:50:27 <mikek> So as long as the _ comes after, it will be checked last? 
21:50:37 <johnw> right
21:51:04 <mikek> ok great, thanks
21:51:13 <Majiir> Friend of mine is a bit put off by the Num typeclass, and wishes it were split up or composed of typeclasses like AdditiveGroup. I was wondering if anyone has some good rebuttals or thoughts on this? (Or a decent way to 'split up' a typeclass?) [Or even a link to something MAP-like but for Prelude numeric types?]
21:51:46 <Majiir> My response was mainly "it's fine, write your own classes" but I think he's the only person on Earth for whom Haskell is entirely too practical
21:52:01 <c_wraith> Majiir: nearly everyone spends some time objecting to Num
21:52:08 <kadoban> Majiir: I think it's widely believed that the Num typeclass is a bit of a mess. But AFAIK it's probably too late to change the thing.
21:52:26 <c_wraith> Majiir: But no one has proposed something that actually works better for writing code.
21:53:19 <kadoban> (It's also a bit hard to figure out exactly how it *should* be changed, even if you wanted to … everyone seems to have their opinion of what is obviously the only way to go, and few of them match)
21:53:20 <Majiir> I see, thanks. I've passed that along. Out of curiosity, what problems arise from decomposing Num into smaller typeclasses?
21:54:44 <c_wraith> Well, there's the super-obvious one, like..  AdditiveGroup and MultiplicativeGroup are obviously subclasses of group, but you can't actually implement them that way
21:55:01 <c_wraith> So you already can't do the "obvious" thing.
21:56:14 <c_wraith> But when you explore a bit further, you also find things like the expression \x -> 2 * x + 3 would infer (AdditiveGroup a, MultiplicativeGroup a) => a -> a instead of the (Ring a) => a -> a that you almost certainly want.
21:56:28 <c_wraith> And that difference isn't meaningless
21:56:39 <c_wraith> Ring adds laws relating to how the two groups interact
21:57:12 <c_wraith> Just being an Additive group and a Multiplicative group in different ways is weaker than being a Ring
21:59:56 <c_wraith> And a breakdown into group/ring isn't even the only potential way to go about it.  What if I want typed units on my numbers?  In that case, I need to support 2 meter * 2 meters = 4 (meters^2), and 2 * 2 meters = 4 meters
22:00:31 <c_wraith> That means you have to support types changing as the result of an operation!
22:00:48 <c_wraith> welcome to wonderful new worlds of complexity!
22:02:29 <c_wraith> Closely related, consider affine spaces like time.  10:00 - 4:00 = 6 hours.
22:02:57 <c_wraith> 10:00 * 5 is a type error.  6 hours * 5 makes perfect sense.
22:03:36 <Majiir> I've not been commenting but I've been furiously copy/pasting into another channel and adding some of my own notes, thank you!
22:03:49 <Majiir> ...my friend is still unconvinced
22:04:07 <Majiir> but he's difficult anyway.
22:04:35 <c_wraith> Points/Vectors is another affine space that people offine just...  ignore.  They have the same representation, they must mean the same thing!
22:06:48 <sssilver> What's the point of Haskell in a world that already has C++?
22:07:41 <kadoban> sssilver: To start #haskell, so sssilver has a place to try out flamebait?
22:07:54 <sssilver> kadoban sounds legitimate
22:08:30 <c_wraith> sssilver: If you check http://bartoszmilewski.com/ you'll find the purpose of haskell is readable documentation of C++. :)
22:08:39 <hackriledge> http://lpaste.net/148458
22:09:14 <sssilver> lol c_wraith gold
22:09:18 <c_wraith> Majiir: in the end, there are too many things numbers mean to be unified in one simple interface.  Num was created to be easy to use and support hardware types easily, and with luck, even a few others.
22:09:56 <Majiir> c_wraith, that was my core point as well, but it's nice to have more specific examples of where an alternative might  break down
22:15:42 <hackriledge> Does the monad instance look ok in that paste?
22:17:56 <hackriledge> Gurkenglas, check out my crazy non trivial FreeTree Monad http://lpaste.net/148458
22:18:21 <c_wraith> Your type is completely crazy. :)
22:18:50 <hackriledge> Have you ever seen anything like that before!?
22:19:01 <hackriledge> And does it look ok!?
22:19:10 <c_wraith> I've seen more general things that can be made to look like it.
22:19:21 <hackriledge> ooooh
22:19:42 <c_wraith> That looks like Free (Cofree Maybe) a
22:19:55 <hackriledge> With the same monad instance?
22:20:04 <c_wraith> I have no idea about that monad instance.
22:20:10 <hackriledge> Not if you use Free
22:20:18 <Majiir> c_wraith: For a moment I started looking up the Coffee typeclass...
22:20:21 <hackriledge> No this is a new and cool thing
22:20:38 <hackriledge> I think
22:21:39 <c_wraith> hackriledge: I..  does that even compile?  I can't figure out what the a on the RHS of the = on line 9 refers to
22:21:42 <hackriledge> It needs scrutinizing, but I thought I'd put it here before my battery dies for the evening. Charging in a coffee shop in the morning...
22:21:53 <c_wraith> hackriledge: should that be fa?
22:22:06 <hackriledge> I don't have a compiler! Hang on I'll check
22:23:00 <c_wraith> hackriledge: line 13 also has an obvious typo, but it's so simple I'll pretend it's not there
22:23:31 <hackriledge> The a was not used!
22:23:58 <hackriledge> I have edited it
22:24:22 <hackriledge> http://lpaste.net/148458
22:24:45 <c_wraith> hackriledge: I seriously doubt the monad laws hold
22:25:16 <c_wraith> hackriledge: I don't see how x >>= return === x could possibly hold
22:25:38 <hackriledge> Hang on I'll try and figure that out
22:26:17 <hackriledge> That's what I mean I have not checked it yet. My battery will die I wanted to at least paste my attempt before it does
22:26:33 <c_wraith> Yeah, I'm sure the monad laws don't hold for that.
22:26:52 <hackriledge> Seems fine to me
22:27:34 <hackriledge> Are you sure?
22:28:30 <parsnip> anyone use w3m-hackage.el? it's part of haskell-mode.el, and i'm just curious how it works. 
22:28:49 <c_wraith> hackriledge: if I'm reading it right....    Roll (Pure ()) [Pure ()] >>= return  ---evalutes-to--->  Roll (Pure ()) []
22:28:49 <parsnip> er, i meant w3m-haddock.el
22:30:10 <hackriledge> Doh
22:30:22 <hackriledge> Thanks at least I can see what's wrong now
22:30:53 <c_wraith> hackriledge: hmm.  I was reading that wrong.
22:31:04 <hackriledge> Yeh something funny
22:31:58 <hackriledge> Seems fine to me still...
22:33:44 <hackriledge> I think maybe it's totally freaking awesome!!!
22:36:28 <hackriledge> Can anyone confirm this?
22:36:38 <hackriledge> http://lpaste.net/148458
22:56:34 <roflha> I just asked something in #haskell-game and figured I would try here too, sorry if this is spammy.
22:56:51 <roflha> When working with netwire, the first parameter to Control.Wire.Session.countSession_ seems to be the time that gets passed along for the delta time.
22:56:58 <roflha> But am I missing something, or is that going to tie simulation to frame rate? Is there some way to separate those? Sorry if this is beginner stuff, just started looking into FRP for games.
22:58:06 <roflha> Or is that clockSession_
23:03:14 <roflha> Well I think I answered my question with clockSesion but if someone feels compelled to answer later I will check logs. Good night everyone!
23:12:11 * hackagebot hkdf 0.0.1.1 - Implementation of HKDF (RFC 5869)  https://hackage.haskell.org/package/hkdf-0.0.1.1 (JiriMarsicek)
23:22:11 * hackagebot language-thrift 0.6.2.0 - Parser and pretty printer for the Thrift IDL format.  https://hackage.haskell.org/package/language-thrift-0.6.2.0 (abhinav)
23:57:30 <Lokathor> http://lpaste.net/148472 does this look correct to everyone else?
23:58:05 <Lokathor> i'm a little fuzzy on if i did bind right. the types match up and it compiles, but i still feel just a little uneasy
