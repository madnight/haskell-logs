00:00:16 <julianleviston> If I have a list of values that are “things to do to a value”, some of which can “early exit” (as in, cause there to be no more changes to the value no matter what the rest of the list is), is a fold a good way to do that? It seems not… it’d be nice if I could also modify this so that it can work as an ErrorT or Either value later on… (Which I’ll probably do eventually, because the early exit *might* be 
00:00:16 <julianleviston> because of an error, or it might be because of a terminal value).
00:00:58 <julianleviston> It’s got the shape of a fold… I’m currently just using a recursive function where some of the cases recurse and others don't.
00:02:10 <julianleviston> This feels a lot like a monadic computation to me… 
00:02:58 <hunteriam> i want to make a server that just interacts wifth a database and returns json, is WAI a good choice?
00:03:09 <julianleviston> :t forM
00:03:11 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
00:03:31 <julianleviston> hunteriam: use scotty.
00:03:47 <julianleviston> hunteriam: or spock or whatever it’s called. It’s simple.
00:03:50 <hunteriam> ove been working in servant, scotty is better?
00:03:55 <dmj`> hunteri
00:04:00 <julianleviston> better for waht?
00:04:05 <dmj`> check out servant
00:04:08 <hunteriam> what ive described
00:04:20 <julianleviston> hunteriam: your needs are basic.
00:04:28 <hunteriam> youre basic
00:04:29 <julianleviston> hunteriam: so it doesn’t matter much. Use what you like :)
00:05:20 <dmj`> hunteriam: servant is good
00:05:31 <julianleviston> hunteriam: sorry, I didn’t mean to offend you.
00:05:35 <dmj`> more types = more maintainable
00:05:49 <hunteriam> sorry haha bad joke :
00:05:57 <julianleviston> hunteriam: your mum’s a bad joke
00:06:00 <julianleviston> hunteriam:  ;-) 
00:06:08 <julianleviston> hunteriam: couldn’t resist.
00:06:46 <julianleviston> hunteriam: using servant has the benefit that when you want to do something more, it’s capable :)
00:07:13 <hunteriam> well i need maximum performsnce
00:07:31 <julianleviston> hunteriam: oh, another requirement enters the mix!
00:12:59 <julianleviston> hunteriam: Well, the “buzz” is that warp is the fastest, but maybe it’s a good idea to try them all out and see which ones actually perform better…?
00:13:08 <jle`> c_wraith: i am not sure if it's possible to write an Applicative instance of StateT without constraining the m to be a Monad
00:13:31 <c_wraith> jle`: I've heard it is, but I never figured out how.
00:14:01 <`Guest00000> Svarog: just curiosity, why do you need that?
00:14:25 <Svarog> julianleviston, for early exit from a fold, have you tried Control.Monad.Cont?
00:14:34 <julianleviston> Svarog: no
00:14:42 <julianleviston> is it continuations?
00:14:51 <julianleviston> i’ll check
00:14:58 <Svarog> julianleviston, yes, use callCC for an early exit
00:15:06 <julianleviston> seems like overkill doesn’t it?
00:15:23 <julianleviston> given that a maybe monad would probably work … if I knew how to glue it together…
00:15:29 <julianleviston> some kind of monadic fold
00:15:31 <Svarog> don't know, depends on what you are doing - it's the most immediate thing that came to mind
00:15:55 * hackagebot parallel 3.2.1.0 - Parallel programming library  https://hackage.haskell.org/package/parallel-3.2.1.0 (HerbertValerioRiedel)
00:16:08 <julianleviston> Svarog: what I’m doing is essentially a fold across a list, using the elements as commands to do various things to a value… and I’d like it to either error or early exit, possibly.
00:16:43 <Svarog> `Guest00000, i've been playing with ideas from this paper http://arxiv.org/abs/1202.2917
00:16:59 <julianleviston> But, really, Maybe monad wouldn’t help… because it returns the failed value… I want the last success value. Something like Or monad coupled with ErrorT
00:17:07 <julianleviston> I forget what the Or monad is tho
00:17:31 <Svarog> `Guest00000, there is a library that implements them but it has problems and it also recreates a lot of things that are already available elsewhere such as profunctors
00:18:03 <julianleviston> Svarog: I thought CC were for when resuming computation was a requirement?
00:18:57 <wowdog> Hi I try to get curren directory in the WHERE causes       currDir <- getCurrentDirectory , it does't work, anyone know why?
00:19:22 <julianleviston> wowdog:  what is “the where clause”? pastie-bin code is a good idea
00:19:47 <wowdog> just the "where"
00:19:48 <Svarog> julianleviston, http://lpaste.net/148252
00:20:15 <julianleviston> hey look… foldM
00:20:15 <wowdog> displayPath str = if str == "myfile.txt"
00:20:15 <wowdog>                             then currDir ++ "/" str
00:20:16 <wowdog>                             else ""
00:20:17 <julianleviston> :t foldM
00:20:17 <wowdog>                                 where
00:20:18 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
00:20:19 <wowdog>                                     currDir <- getCurrentDirectory
00:20:43 <Svarog> can be simpler if you don't need a monad, you may be able to get away with just filtering the list before folding it
00:21:21 <julianleviston> wowdog: use this rather than pasting into channel: http://lpaste.net/new/haskell
00:21:22 <geekosaur> Svarog, isn't that pretty much http://hackage.haskell.org/package/categories-1.0.7/docs/Control-Categorical-Functor.html ?
00:21:53 <julianleviston> Svarog: can’t get away with filtering - it’s not commutative.
00:22:19 <julianleviston> Svarog: that seems overkill tho to me
00:22:21 <wowdog> http://lpaste.net/148254
00:22:50 <geekosaur> wowdog, <- is do syntax, when you are in "where" you are not in "do" syntax any more
00:22:59 <julianleviston> Svarog: I could probably use a StateT and an ErrorT, I guess… 
00:23:08 <Svarog> geekosaur, i just found ed kmett's indexed which seems to have exactly what i want - strangely enough it's not the same package that's on hackage
00:23:14 <geekosaur> and in any case you are not in IO so you can't do that 
00:23:28 <geekosaur> <- is not magic "let me do IO now"
00:23:38 <Svarog> geekosaur, looking at Control.Categorical.Functor and trying to see how it's different from Indexed.Functor
00:23:43 <Svarog> https://github.com/ekmett/indexed/blob/master/src/Indexed/Functor.hs
00:24:34 <wowdog> how to get the string from IO in getCurrentDirectory?
00:24:49 <julianleviston> wowdog:  you should put your IO stuff into the main function, and then pass a string into the displayPath function, that way you don’t muddy the displayPath function.
00:25:36 <wowdog> thx
00:25:57 <geekosaur> and the answer to your question, as asked, is "you don't"
00:26:21 <geekosaur> IO is not a container you can pull stuff out of
00:26:26 <julianleviston> wowdog:  that is… main :: IO () ; main = do { dirStr = getCurrentDirectory ; putStrLn (displayPath dirStr) }
00:26:28 <geekosaur> @quote shachaf ls
00:26:29 <lambdabot> shachaf says: <dmwit> CReal is the computable reals. <shachaf> Just like CInt is the computable integers!
00:26:31 <julianleviston> wowdog:  (unchecked)
00:26:34 <geekosaur> hm
00:26:58 <geekosaur> @quote /bin/ls
00:26:58 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
00:27:29 <julianleviston> that’s not helpful at all!
00:27:32 <wowdog> you guys are awesome
00:27:57 <geekosaur> basically, you must be in IO to do any I/O type stuff; String -> String is pure and cannot do IO
00:28:04 <geekosaur> String -> IO String can do IO
00:29:12 <geekosaur> and at that point you're not so much trying to pull something out of IO, as telling it how to modify something that IO might produce at some point
00:30:13 * geekosaur is too tired to describe this usefully, sigh
00:30:22 * julianleviston consoles geekosaur
00:30:28 <geekosaur> (did not intend to be up now, waiting out a sinus fit)
00:30:40 <julianleviston> geekosaur: apple cider vinegar.
00:36:45 <Svarog> Control.Categorical.Functor is a bit too general
00:36:53 <Svarog> Indexed.Functor was what i was after
00:41:02 <crocket> Is it desirable to bootstrap haskell runtime in haskell?
00:44:52 <ontop> Is there anyone that can convince me that IO/Imperative side of Haskell isn't horrible? It looks horrible :(
00:48:03 <Svarog> ontop, what's horrible about it?
00:49:02 <ontop> Svarog: I mean, all this clean beautiful functional awesomeness I've read for 80% of this book
00:49:22 <ontop> Then I get to this hangman example, and I just can't help but look at it like a syntactically terrible version of any other programming language
00:49:36 <ontop> With IO flying everywhere, and making everything into Monads etc.
00:50:43 <`Guest00000> what's that example?
00:51:02 <ontop> Hm. I don't know if it's generally available.
00:51:13 <ontop> It's in the book by bitemyapp.
00:51:13 <Svarog> what book are you reading?
00:51:38 <ontop> "Haskell Programming" -
00:51:40 <Svarog> introductory books try to get the basics across, not necessarily the cleanest possible way to do something
00:51:42 <ontop> From first principles.
00:51:57 <ontop> Ah.
00:53:30 <ontop> Also, are people supposed to use Stack now instead of Cabal?
00:53:35 <ontop> Is that the thing?
00:53:51 <Svarog> i switched to stack just recently
00:53:57 <ontop> Worth it?
00:54:00 <Svarog> so far
00:54:08 <Svarog> but i haven't used it enough yet
00:55:39 <crocket> Is Stack better?
00:56:17 <ontop> I think it's supposed to be.
00:56:28 <ontop> But I'm no expert. I just read some stuff about how Cabal was bad :D
00:57:13 <Cale> ontop: I think it's decidedly good, not even just not horrible :)
00:57:32 <Cale> ontop: The fact that IO happens to be a monad is a less big deal than the fact that IO actions are values in the first place.
00:57:50 <Cale> ontop: Being a monad just says something about the means that we have for combining together IO actions.
00:58:00 <ontop> IC
00:58:24 <Cale> The fact that IO actions are first class values is weird at first, but turns out to be very very convenient.
00:58:36 <Cale> In ways that more than make up for the initial strangeness.
00:58:41 <ontop> Hm.
00:58:45 <ontop> In what ways?
00:58:59 <Cale> First of all, it's very easy to write your own control structures.
00:59:26 <Cale> As a simple example, let's look at a function called sequence
01:00:01 <Cale> sequence :: [IO a] -> IO [a] -- it takes a list of IO actions, and glues them together into a single IO action which will run each of them in turn and collect the results
01:00:33 <Cale> sequence [] = return [] -- if the list is empty, we have it produce the action which does nothing except to return the empty list.
01:01:01 <Cale> sequence (x:xs) = ... -- if the list is nonempty, with some first action x, and the rest of the list being xs
01:01:18 <Cale> sequence (x:xs) = do v <- x; ... -- we first execute x, getting some result v
01:01:27 <ontop> Sounds like javascript promises.
01:01:37 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ... -- we then execute the rest of the list xs, getting some results vs
01:01:58 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs) -- and then combine the first result with the list of the rest of the results
01:03:13 <ontop> Sounds kind of convenient I guess.
01:03:21 <Cale> It's perhaps a little simpler -- the difference between an IO String and a String is like the difference between /bin/ls and a list of files
01:03:53 <Cale> Being able to precisely keep track of that difference, and pass around programs without having things execute before you want them to is really convenient
01:04:46 <Cale> Like, now with this sequence function, we have a primordial loop of sorts: if we can decide ahead of time what should happen on each iteration and form a list of actions, we can apply sequence to stitch the iterations together.
01:04:51 <roelof> Hello, I have a list comprehension and I want to do something with the outcome.The outcome can be a empty list or not. How does it look like with pattern matching ? 
01:05:57 <Cale> So, we can easily write a for-each loop:  forM xs f = sequence (map f xs) -- it takes a list of values, and a function from those values to actions to perform, applies the function to the elements of the list, and then uses sequence to form a single action which will run them all
01:06:11 <Cale> forM :: [a] -> (a -> IO b) -> IO [b]
01:06:39 <Cale> roelof: case ... list comprehension here ... of [] -> ...; (x:xs) -> ...
01:07:18 <roelof> Cale , thanks, I have not thought about a case 
01:07:41 <Cale> ontop: Besides that, you can e.g. put IO actions into channels used for concurrent communication between threads
01:08:18 <Cale> ontop: You can have IO actions which return other IO actions as (part of) their result -- e.g. something might allocate a resource and return an IO action which cleans it up.
01:08:26 <ontop> Cale: Hm
01:08:28 <ontop> It all sounds promising
01:08:29 <ontop> To be honest
01:08:33 <ontop> I guess I'll continue
01:08:38 <`Guest00000> 'promising'...
01:08:41 <Cale> heheh
01:09:25 <Cale> And yeah, indeed, there are libraries like Async, which implement something more like promises on top of this.
01:09:48 <Cale> async :: IO a -> IO (Async a)
01:09:54 <Cale> wait :: Async a -> IO a
01:10:13 <roelof> Cale : something like this : http://lpaste.net/148255
01:10:49 <Cale> roelof: Well, that's going to be a type error, because item is a list of items
01:10:57 * hackagebot language-thrift 0.6.0.0 - Parser and pretty printer for the Thrift IDL format.  https://hackage.haskell.org/package/language-thrift-0.6.0.0 (abhinav)
01:11:06 <jle`> c_wraith: if that's the case, i shall continue my search
01:11:07 <Cale> so the occurrence of item on the right hand side of  (x:xs) -> item
01:11:11 <Cale> seems inappropriate
01:11:36 <Cale> oh, but you did want to produce a list according to your type signature
01:11:55 <Cale> So, maybe the solution is to make it [] -> [("Unknown Item", 0)]
01:12:33 <`Guest00000> returning ("Unknown Item", 0) looks untyped
01:13:09 <`Guest00000> i'd use Maybe [(Name, Price)], or Either String [(Name, Price)]
01:13:29 <roelof> Cale : thanks, its working now 
01:13:55 <pdxleif> Why is this talking about "BIOS"? https://github.com/haskell/haskell-ide-engine
01:15:22 <Cale> pdxleif: I dunno, seems like a pretty rough analogy for what ghc-mod provides
01:17:06 <brh> help
01:17:18 <Skuzzzy> brh: please state the nature of your emergency
01:17:19 <pdxleif> Could they say "kernel" or something, instead?
01:19:12 <brh> Trying to access the help menu on irssi :)
01:19:39 <`Guest00000> is there a way to explicitly supply type arguments? e. g. i have f :: a -> a -> a, i don't want to type (f :: Foo Bar Baz -> Foo Bar Baz -> Foo Bar Baz), i'd rather something like (f :: a = Foo Bar Baz)
01:20:11 <mniip> (a ~ Foo Bar Baz) => a -> a -> a
01:20:18 <mniip> but that requires an extension
01:20:38 <`Guest00000> which
01:20:40 <Cale> ... and it's not always exactly the same as substituting by hand
01:20:46 <Skuzzzy> brh: switch to a real irc client like hexchat
01:20:58 <mniip> Cale, it shouldn't matter for purposes of inference or typechecking, should it
01:21:00 <Skuzzzy> irssi is for children who feel the need to use a terminal for everything
01:21:18 <Cale> Skuzzzy: that seems a bit confrontational :P
01:21:26 <mniip> unless you're talking about RankNTypes madness
01:21:41 <Skuzzzy> Cale: I rarely mean anything I say so I come off as an idiot a lot of the time
01:21:50 <Skuzzzy> That's why everyone hates me
01:21:56 <mniip> `Guest00000, TypeFamilies afaik
01:22:06 <ggole__> type BinOp a = a -> a -> a and then f :: BinOp (Foo Bar Baz)?
01:22:12 <mniip>     Illegal equational constraint a ~ b    (Use GADTs or TypeFamilies to permit this)
01:22:14 <Cale> I think GADTs will also turn on type equality, but I could be wrong
01:22:16 <Cale> yeah
01:22:30 <Cale> Using a type synonym might be better
01:22:33 <mniip> ggole__'s solution is cool too
01:23:06 <`Guest00000> hmm... is there type family $ ?
01:23:07 <pdxleif> `Guest00000: You'll be able to explicitly supply type args in GHC 8.
01:23:09 <Cale> mniip: I forget exactly where the difference made itself clear, but I was doing a bunch of that, and remember running into a case where I couldn't do it -- it might've involved higher rank things.
01:23:14 <`Guest00000> like, BinOp $ Foo Bar Baz
01:23:32 <mniip> no that requires TypeOperators
01:23:40 <Cale> `Guest00000: I believe there is an explicit type application extension in the pipeline...
01:23:44 <jle`> hm, i wonder if that works
01:23:53 <Cale> https://ghc.haskell.org/trac/ghc/wiki/ExplicitTypeApplication
01:24:00 <Cale> https://ghc.haskell.org/trac/ghc/wiki/TypeApplication
01:24:02 <`Guest00000> nice
01:24:02 <Cale> rather
01:24:08 <jle`> @let type family ($) where f $ x = f x
01:24:09 <lambdabot>  .L.hs:177:9:
01:24:09 <lambdabot>      Number of parameters must match family declaration; expected 0
01:24:09 <lambdabot>      In the type family declaration for ‘$’
01:24:19 <jle`> @let type family ($) f x where f $ x = f x
01:24:21 <lambdabot>  Defined.
01:24:30 <jle`> :t Just 1 :: Maybe $ Int
01:24:31 <lambdabot> Maybe Int
01:24:36 <`Guest00000> cool
01:24:44 <mniip> @let type family ($) (a :: k) (b :: k -> l) :: l where ($) a b = a b
01:24:45 <lambdabot>  .L.hs:179:1:
01:24:45 <lambdabot>      Multiple declarations of ‘$’
01:24:45 <lambdabot>      Declared at: .L.hs:176:1
01:24:47 <mniip> aw
01:24:47 <roelof> Can anyone help me with this problem  : http://lpaste.net/148256
01:24:51 <jle`> @undefine
01:24:51 <lambdabot> Undefined.
01:24:55 <jle`> begone with you
01:25:01 <mniip> yeah no it doen't wotk
01:25:02 <mniip> work
01:25:13 <roelof> I have no clue why ghci talks about a maybe 
01:25:20 <roelof> I do not use maybe 
01:25:26 <`Guest00000> so, i can finally get rid of those irritating brackets...
01:25:40 <`Guest00000> (nah, they're fine)
01:25:58 <mniip> yeah no, parentheses in types are hardly going anywhere
01:25:59 <ggole__> So the trend is increasingly more of the lambda calculus at type level
01:25:59 <jle`> roelof: look at the type of `lookup`
01:26:03 <Svarog> roelof, type :t lookup
01:26:03 <jle`> :t lookup
01:26:05 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
01:26:09 <ggole__> Are we going to get type-level let and fix?
01:27:12 <jle`> i missed an opportunity to say "look up the type of lookup"
01:27:19 <Svarog> haha
01:27:33 <roelof> Thanks, I had to use look instead of lookup. Why the author calls the functions almost the same I do not know. it's confuses me 
01:30:21 <c_wraith> ggole__: there are already type-level versions of fix.
01:30:50 <c_wraith> ggole__: https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html#t:Fix for instance
01:31:10 <c_wraith> ggole__: though Mu and Nu in there are additional ways to encode the same idea.
01:31:22 <ggole__> Of course.
01:34:01 <roelof> pff, still fighting types. How can I take care that [ (item, price)] is converted to (item, price)  ? 
01:34:20 <roelof> I tried fst but then still type errors 
01:34:50 <c_wraith> roelof: how do you convert an empty list to a pair?
01:35:50 <roelof> I do not. When it's a empty list I do this :   [] ->  ("Unknown Item",0)  
01:35:52 <julianleviston> roelof: can you have an empty item and an empty price? if so you can.
01:36:00 <julianleviston> roelof:  ok cool
01:36:05 <julianleviston> roelof: so that’s your empty list case
01:36:17 <roelof> yes, and that is working well 
01:36:30 <julianleviston> roelof: if you have more than one thing, how do you convert that to a single pair?
01:36:44 <julianleviston> roelof:  obviously [x] -> x
01:37:04 <julianleviston> roelof:  but (x:xs) -> ?
01:37:05 <roelof> but for a non-empty list the list comprehension provides this  [ (item, price)] 
01:37:21 <roelof> maybe use there otherwise ? 
01:37:24 <julianleviston> roelof: maybe I don’t understand what you’re taking about.
01:37:32 <julianleviston> roelof: what are you trying to do?
01:37:46 <julianleviston> roelof:  “I have … and I want … “ <- fill in, please.
01:38:43 <roelof> I have a barcode who looks like this :  1234  , Now I have to  make a function which looks in a database which is a list of tuples like this (barcode, item, price) 
01:39:09 <roelof> and I have to return the name and price like this (name, price) 
01:39:14 <julianleviston> roelof: you’re probably better off using a sum type than a 3-tuple.
01:39:47 <roelof> except when the item is not there , then I have to return ("unknown item",0) 
01:39:58 <julianleviston> roelof:  (,) is not (,,)
01:40:07 <julianleviston> roelof: that is, a 2-tuple is a different thing than a 3-tuple.
01:40:18 <julianleviston> roelof:  it sounds like you’re trying to do too many steps at once.
01:40:19 <roelof> julianleviston:  this is a exercise of the Craft book  so the database is given in this format 
01:40:29 <julianleviston> ok
01:41:04 <roelof> I can look up the item with this list comprehension :  [ (name,price) | (barcode, name , price) <- db, code == barcode ]
01:41:30 <julianleviston> roelof: erm.
01:41:33 <roelof> that can return a empty list which returns ("unknown item", 0)  
01:41:40 <julianleviston> roelof: that will filter it
01:41:43 <roelof> erm  ? 
01:42:09 <julianleviston> if it doesn’t find it, it won’t return anything.
01:42:13 <julianleviston> it will be []
01:42:20 <julianleviston> ohhhhh then you have a case statement. This is not great.
01:43:12 <roelof> yep, and when it's a empty list its will return the ("unknown item,0) 
01:43:17 <julianleviston> you’re better off using List’s find, I think.
01:43:22 <roelof> there is no problem 
01:43:32 <julianleviston> ok so what’s the problem then?
01:43:43 <Svarog> roelof, unless required for the assignment i'd suggest avoiding list comprehensions initially
01:43:57 <julianleviston> it’s a mis-use of a list comprehension.
01:44:12 <Svarog> so you get a better idea of what goes on behind the scenes
01:44:45 <julianleviston> because your list comprehension could return any number of elements… unless you just want the first one, in which case you CAN put a case of ((_,n,p):_) -> (n,p) in
01:44:58 <julianleviston> but it’s ugly as sin.
01:45:02 <roelof> when the item is found, the list comprehension will return [ (item, price)]  but I need to return the type (item, price) 
01:45:13 <julianleviston> roelof: use the case I just said
01:45:20 <roelof> there is the problem. I cannot figure out how to do so 
01:45:37 <julianleviston> roelof: ((_,n,p):_) will match on “first element, pull out name and price as n and p"
01:45:41 <roelof> oke, that way  
01:45:43 <julianleviston> yes.
01:45:45 <julianleviston> But don’t do it.
01:45:55 <julianleviston> use find instead.
01:46:38 <roelof> oke, I have to look how to use find. The list functions are not explained yet. there are mentioned and no further explanation 
01:46:45 <Cale> :t find
01:46:46 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
01:46:54 <julianleviston> case (find (\(b,n,p) -> b == barcode)) of {Just (_,n,p) -> (n,p) ; Nothing -> (“nothing”,0)}
01:46:58 <Cale> Imagine that the t a says [a]
01:47:24 <julianleviston> roelof:  but it SOUNDS like you’re supposed to write your own recursive function, so you should probably do that instead.
01:47:36 <mniip> so this is why map isn't fmap
01:47:49 <mniip> "Imagine that the t a says [a]"
01:47:52 <julianleviston> mniip: map isn’t fmap because map came first, I think
01:48:52 <puregreen> julianleviston: map originally was fmap, it got changed in some version of Haskell
01:48:57 <julianleviston> roelof: rather than using a list comperehension.
01:48:59 <roelof> julianleviston:  that is what I try the whole time. Writing a recursive function with the help of list comprehension 
01:49:13 <julianleviston> puregreen: are you sure? if so, please link me to where that’s the case.
01:49:24 <julianleviston> roelof: you should not use a list comprehension
01:49:26 <roelof> julianleviston:  oke, so use a recursive function  
01:49:49 <julianleviston> roelof: as I was explaining yesterday, list comprehensions are actually fairly advanced haskell even though the syntax is simple and they can be explained simply. 
01:50:33 <julianleviston> roelof: if you’re supposed to use a list comprehension, then go ahead, though. I don’t think it’s great, though.
01:50:42 <puregreen> julianleviston: https://www.cs.auckland.ac.nz/references/haskell/haskell-report-1.4-html/standard-prelude.html, Ctrl-F “map”
01:50:54 <roelof> IM exploring solutions so I can learn things 
01:51:09 <roelof> julianleviston:  the exercise is not saying what to use 
01:51:19 <julianleviston> roelof: well that’s just shoddy learning material then.
01:51:55 <julianleviston> puregreen: oh you meant fmap used to be map, not map used to be fmap.
01:52:14 <julianleviston> puregreen: thanks for that edification!
01:52:15 <roelof> I have not found a better book then the Craft of functional programming. Bitemyapp suggest it as a preperation for CIS194
01:52:36 <julianleviston> roelof: Bitemyapp should be suggesing his own book.
01:53:00 <julianleviston> @where book
01:53:00 <lambdabot> http://haskellbook.com/
01:53:04 <roelof> I think he will as soon as the book is ready 
01:53:17 <julianleviston> it is ready enough.
01:53:17 <roelof> for now he suggest this book 
01:54:45 <julianleviston> puregreen: do you know why they changed it?
01:58:12 <puregreen> julianleviston: well, I found this comment: “What happened was that the type of map was generalized to cover Functor in Haskell 1.3. I.e., in Haskell 1.3 fmap was called map. This change was then reverted in Haskell 1.4 and fmap was introduced. The reason for this change was pedagogical; when teaching Haskell to beginners the very general type of map made error messages more difficult to understand.”
01:58:53 <julianleviston> puregreen: and now ironically, we’ve introduced Foldable and Traversable.
01:59:12 <puregreen> several other things were simplified as well, including turning monad comprehensions into list comprehensions (and now we have them back as an extension)
01:59:14 <julianleviston> puregreen: so we end up with “just imagine f a == [a]”
02:00:24 <julianleviston> roelof: it’s important you understand what the shape of things are so you can recognise when you see something which pieces of Haskell you can use. So, if you’re dealing with the need to make lists (or lists of lists), or filter lists, then list comprehensions can be a good fit. However, what you’re doing is pulling something out of a list, then converting it from a 3-tuple to a 2-tuple. It’s not so much that a 
02:00:25 <julianleviston> comprehension won’t work or fit here, it’s just perhaps not the best thing.
02:01:06 <julianleviston> (best thing in that it might actually not increase your understanding)
02:01:22 <roelof> oke, no hard feelings 
02:02:20 <roelof> im still try to find out when to use which solution 
02:05:51 <roelof> julianleviston:  but on your code , I ran into this : http://lpaste.net/148257
02:06:45 <julianleviston> roelof: I didn’t check my code. I don’t know what BarCode is, or DataBase
02:07:24 <julianleviston> also you’re not passing db to find
02:07:56 <julianleviston> roelof: there’s a problem here, and I’m not sure if you want to address it, but it’s that you need to build up your understanding piece by piece, or you’ll end up annoyed, frustrated and not understanding stuff.
02:08:56 <roelof> I try that to do it that way , piece by piece,. That is why I read the stuff and doing the exercises one by one 
02:09:19 <Svarog> roelof, this is why i suggested not using list comprehensions at all initially
02:09:33 <julianleviston> roelof: ok… but at this point you don’t yet understand recursion, I think… but you’re doing things that require it.
02:09:40 <roelof> oke, the book has explained it just 
02:09:58 <Svarog> try to write code without using them first, and then when you understand how they work, then start using them
02:10:06 <Svarog> list comprehensions hide what really goes on
02:10:44 <roelof> oke, I try to figure out how to change my code so it looks into the database which is a list 
02:10:53 <julianleviston> sigh
02:14:27 <roelof> im giving up till I find a better book
02:14:50 <roelof> the Craft book makes me confused and frustated 
02:14:51 <Svarog> roelof, there is a lot of introductory material online, even books
02:15:37 <Svarog> https://wiki.haskell.org/Haskell_in_5_steps
02:15:53 <Svarog> scroll down to the bottom and follow the tutorials links
02:16:25 <roelof> Svarog:  I could not find any good books for a beginner, where exercises are included.  I have to do things to really get the the feeling how things are working 
02:16:59 <Svarog> have you tried http://learnyouahaskell.com/chapters
02:17:11 <suppi> roelof, have you tried www.haskellbook.com ?
02:17:55 <roelof> I did not tried because I do not have a debt card or a paypal account. so I cannot try it 
02:18:22 <roelof> Svarog:  as far as I can see no exercises in the learnyouahaskell 
02:18:59 <Svarog> roelof, try these https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems
02:19:12 <julianleviston> roelof:  you can use my exercises if you like - they might be helpful. They’re free
02:19:14 <julianleviston> http://www.genericoverlords.com/haskell_exercises
02:19:28 <julianleviston> Not AMAZING quality and they don’t explain much other than tell you what they do… 
02:19:34 <julianleviston> but it does go reasonably slowly.
02:19:53 <julianleviston> Svarog: 99 problems are kind of difficult for a beginner.
02:20:52 <Svarog> problem 1: find the last element of a list, problem 2: find the last but one element of a list
02:21:06 <Svarog> i don't know how much simpler they can be
02:21:44 <julianleviston> Svarog: if you don’t know recursion it’s not an easy problem.
02:21:57 <julianleviston> Svarog: but they get harder quickly.
02:22:16 <Svarog> those problems should help him learn what recursion is
02:22:23 <julianleviston> Svarog: ok.
02:22:25 <Svarog> along with things like learn you a haskell
02:22:43 <Svarog> and then there's this channel if he gets stuck
02:23:04 <Svarog> roelof, do you know any other programming languages?
02:23:18 <roelof> yes, some ruby and some node 
02:26:32 <roelof> Svarog:  but I do not like Rails , too much magic 
02:26:42 * julianleviston gives roelof a hi5
02:27:07 <roelof> so im looking for another language which I can understand and work with 
02:27:18 <khole> using STM and looking for a way to signal an event that causes /all/ threads waiting on that event to wake up
02:27:37 <julianleviston> roelof: switching from an incredibly dynamic language to a completely static language might be a bit of a trick :)
02:27:45 <julianleviston> roelof: not impossible, but tricky.
02:28:04 <roelof> I have noticed that is very hard 
02:28:12 <khole> STM doesn't have this concept of an 'event', any idea how I could build something that works like this?
02:28:25 <julianleviston> khole: have you read marlow’s book?
02:28:47 <roelof> Maybe look at a language as clojure or scala  
02:28:59 <Svarog> roelof, nah, haskell is better ;)
02:29:02 <julianleviston> roelof: I actually found Haskell immensely refreshing
02:29:20 <Svarog> roelof, and also you'll be fine, just need to stick with it
02:29:46 <khole> julianleviston: do you mean one of the papers or is there an actual book?
02:29:52 <julianleviston> khole: book.
02:29:56 <suppi> roelof, one more possible resource: https://en.wikibooks.org/wiki/Haskell
02:30:13 <julianleviston> khole: http://chimera.labs.oreilly.com/books/1230000000929
02:30:24 <roelof> I like Haskell also a lot but as soon as I get harder , I feel more frustating  and at this moment I like to quit and look for another language 
02:30:33 <julianleviston> khole: it’s… EXCELLENT.
02:30:59 <khole> julianleviston: thanks! I'll read it!
02:31:07 <julianleviston> roelof: it’s because you’re trying to do too much too quickly.
02:31:30 <Svarog> roelof, if your head doesn't hurt and you're not frustrated then you're not learning!
02:31:50 <roelof> that can be , and what I said not having a clue what to use when.  
02:31:58 <julianleviston> roelof: I don’t quite agree with Svarog on this one. I think if you do things in a good order, then you won’t get so frustrated.
02:32:06 <c_wraith> khole: STM transactions that aborted due to a conflict automatically restart whenever something that writes to a TVar they read from commits.  That's your broadcast mechanism.
02:32:18 <roelof> I have learned recursion, strings , list comprehension and all a litte bit 
02:32:41 <julianleviston> roelof: could you rattle off a reverse function ?
02:32:55 <roelof> the craft book has this order and I cannot change it 
02:33:04 <roelof> rattle off ? 
02:33:13 <julianleviston> roelof: write it down without difficulty.
02:33:25 * hackagebot fast-tags 1.2 - Fast incremental vi and emacs tags.  https://hackage.haskell.org/package/fast-tags-1.2 (EvanLaforge)
02:33:26 <roelof> with only recursion and a acc 
02:33:33 <roelof> yes, I think I can 
02:33:46 <c_wraith> khole: note that this is often a source of thundering herds issues when using STM, so be wary of overuse.
02:33:54 <c_wraith> *herd
02:34:00 <suppi> roelof, which parts are frustrating to you in learning Haskell?
02:34:02 <julianleviston> roelof:  the problem with all these books and things is they don’t provide you with practice. You need to do that yourself. To repeat until it’s second nature.
02:34:41 <roelof> julianleviston:  then I think I have to find more "easy" exercises on recursion and strings 
02:35:01 <julianleviston> suppi: s/he’s being frustrated by something like “I should be able to do simple programs by now, but I don’t know how to and I don’t know which parts to use, when, to do what”
02:35:09 <roelof> I looked at your site but the solutions are right under it. 
02:35:14 <suppi> oh
02:35:15 <julianleviston> roelof: yep. 
02:35:22 <roelof> im a he 
02:35:24 <khole> c_wraith: thanks for the heads up
02:35:37 <julianleviston> roelof:  they’re there so you can read them, and then take just the question, and cover the answer, and create the answer yourself from scratch.
02:35:50 <julianleviston> roelof: this is a very good way to learn.
02:36:22 <roelof> oke, then I will quit the craft book for some time and trying to do your exercises 
02:36:30 <julianleviston> roelof: first, read the answer and see if you understand every part of it. If you don’t ask until you do…then, take just the question and paste it into your editor… then try to do the exercise.
02:36:47 <julianleviston> roelof: I don’t recommend that either necessarily! the exercises aren’t a course.
02:36:51 <roelof> maybe I see the light and I can continue on the Craft book or with CIS194
02:37:34 <julianleviston> roelof: if you want, pick a project that you’d like to make yourself, and ask people how you could go about cutting it up into pieces…
02:37:52 <roelof> julianleviston:  I know. I want to use them so I can get the feeling and understanding when to use what 
02:38:41 <roelof> I have made a little pet project which updated a wallet with deposits and withdraws 
02:38:48 <julianleviston> roelof:  Cool! :)
02:39:18 <roelof> With a little help I got it running in 1 or 2 hours 
02:39:42 <roelof> it was a nice exercise to wotk with custom types also 
02:40:10 <julianleviston> I find the “pulling a problem into pieces” is one of the trickiest parts, but with equational reasoning and by using divide and conquer, you can pretty easily get there, more or less.
02:40:44 <roelof> julianleviston:  it's now looking like this : http://lpaste.net/148258
02:41:13 <roelof> I thought I could further on it when learning records or states 
02:42:27 <julianleviston> roelof: knowing when to use what is the biggest problem isn’t it.
02:42:28 <khole> c_wraith: I don't think the abort/retry semantics answer my question. An (incorrect) implemenation would be using a TVar Bool as the event type. Signalling the event would set the TVar to true and waiting on the event would check if the TVar is true or retry. The problem with this is that we need to write false to the TVar, but only after all the waiting threads have woken up.
02:42:59 <julianleviston> roelof: so, reading a lot of small solved problems is a good idea. (99 problems would fit this bill)
02:43:07 <roelof> julianleviston:  yep , that I find the most frustating part together sometimes with types problems 
02:43:25 * hackagebot language-thrift 0.6.0.1 - Parser and pretty printer for the Thrift IDL format.  https://hackage.haskell.org/package/language-thrift-0.6.0.1 (abhinav)
02:43:40 <julianleviston> roelof: do you like adventure games?
02:43:45 <julianleviston> roelof: or games at all?
02:43:58 <julianleviston> roelof: maybe you could design a small game piece by piece
02:44:15 <julianleviston> roelof: just a simple text based one.
02:44:47 <julianleviston> roelof: start with a game map that is a single corridoor (I know, boring game at first)… 
02:44:54 <julianleviston> roelof:  and let people move around in the corridoor
02:44:56 <roelof> never done it. IM more familair with financial things. Im a sort of accountant of proffession 
02:45:18 <julianleviston> roelof: ok..
02:45:30 <roelof> julianleviston:  thanks for thinkinhg with me 
02:45:40 <julianleviston> roelof: well, then perhaps you could embellish your accounting thing you’ve written
02:45:45 <julianleviston> roelof: It’s my absolute pleasure
02:45:54 <julianleviston> roelof: I’m very interested in this.
02:46:46 <julianleviston> roelof: let’s say you want to create a bank.
02:46:55 <julianleviston> roelof:  with accounts, and transactions, and whatnot.
02:47:13 <roelof> I could , but I think I have to learn about records. Then I could make it bigger with things like transactions with a date , a description and a amount 
02:47:26 <julianleviston> roelof: yes. this is good.
02:47:38 <roelof> The next step was to make it work  with that 
02:47:46 <julianleviston> roelof:  ok so let’s plan this.
02:47:53 <roelof> but someone said I  have to learn records 
02:48:05 <julianleviston> roelof: let’s just take it bit by bit.
02:48:12 <roelof> oke
02:48:22 <julianleviston> top down
02:48:44 <julianleviston> roelof: so how do you want the interface to go?
02:49:09 <julianleviston> roelof: to keep it simple, shall we just use GHCi for an interface at first?
02:49:22 <julianleviston> roelof: that way we don’t have to worry too much about IO
02:50:01 <roelof> at this moment, the user enters something like { date: 01-02-05, description :  "test", type: "withdraw" , amount : 100} 
02:50:29 <roelof> but we can also ask the user some questions 
02:51:20 <julianleviston> roelof: so this only has one account?
02:53:14 <julianleviston> roelof:  let’s build it up piece by piece. so we’ll need an account which will store the transactions, yes?
02:53:29 <julianleviston> roelof:  and for now, let’s say a transaction is just an integer - positive or negative.
02:53:41 <julianleviston> roelof: don’t worry, we’ll get more complicated soon.
02:54:10 <julianleviston> roelof: I might ping you privately to save the channel from being subjected to the pain of my verbose typing. :)
02:57:07 <lamefun> Is there a jQuery-like library for GHCJS-DOM?
03:03:07 <dimsuz> hello! I'm going through nicta course and having a bit of trouble understanding this ((->) t) thing. How could I picture it in my head? I mean mnemonically? Here's the relevant execrsice (please *don't* solve it for me!) http://lpaste.net/148262
03:03:41 <dimsuz> I understand that it represents a function application but still can't quite read 't, a' along with it. what's 't' and what's 'a'...
03:04:13 <lamefun> ((->) a b) is the same as (a -> b)
03:04:56 <dimsuz> haha, I always come here to ask something that turns out to be obvious after someone explains it :)
03:04:57 <dimsuz> thanks
03:05:26 <dimsuz> so ((->) t) is a curried function?
03:05:46 <ggole> a -> b is basically nice syntax for (->) a b
03:05:49 <srhb> dimsuz: Sort of, (->) is the type operator for creating functions
03:06:14 <srhb> dimsuz: So it's more that it's partial application of a type.
03:06:25 <dimsuz> srhb: like (+) is an operator for creating sums?
03:07:09 <ggole> Yes (although with no sections)
03:07:10 <srhb> dimsuz: (+ 2) is the function that, given another argument, adds two to it.
03:07:28 <srhb> dimsuz: ((->) t) is, given another type, a function from t to that.
03:07:31 <lamefun> eg. 'type Func a b = a -> b' is the same as type 'Func a = (->) a'
03:08:01 <srhb> dimsuz: Perhaps it's more clear if you allow sections and write it as (t ->)
03:08:01 <ggole> srhb: careful about argument order there
03:08:16 <srhb> ggole: Hmm, where did I screw up?
03:08:30 <ggole> In (+ 2), 2 is the second argument
03:08:37 <srhb> Oh, yes, sorry.
03:08:39 <srhb> ((+) 2
03:08:41 <srhb> ...
03:08:44 <srhb> You get it :P
03:08:45 <ggole> (I have done that *so* many times.)
03:09:10 <srhb> I didn't even think about it because it commutes... :P
03:09:10 <ggole> Commutative ops make it an overly pleasant mistake.
03:09:13 <srhb> Yeah.
03:10:15 <dimsuz> srhb: "((->) t) is, given another type, a function from t to that." this is what I wanted to hear! So "instance Applicative ((->) t)" basicly means specifying few properties for functions which take generic type t and return something back
03:11:03 <srhb> dimsuz: I'm not sure I understand the implication of calling it "generic" :-)
03:11:17 <dimsuz> I meant 'any'
03:14:28 <srhb> When it comes to actual instances the meaning is easier to decipher from the implementation. In this case, it's about functions that have the SAME type of first argument
03:17:49 <srhb> dimsuz: Try substituting in ((->) t) as f in the signature of <*>
03:17:53 <srhb> :t (<*>)
03:17:54 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:18:09 <joco42> I am playing around with phantom types and data kinds in the repl, and i get this error message, any idea how to fix this ?  https://usercontent.irccloud-cdn.com/file/dcsMTV5u/Screen%20Shot%202016-01-02%20at%2013.06.59.png
03:18:26 * hackagebot wai-route 0.3.1 - Minimalistic, efficient routing for WAI  https://hackage.haskell.org/package/wai-route-0.3.1 (romanb)
03:19:51 <dimsuz> srhb: yes, I did that. trying to figure <*> out now :)
03:28:49 <srhb> dimsuz: I don't know if it helps you, but I usually start with a skeleton like tab <*> ta = \t -> ...
03:31:06 <dimsuz> srhb: actually this hint was *just* what I needed! I might now be able to work it out, let's see
03:31:13 <srhb> :)
03:32:15 <dimsuz> I couldn't wrap my head where oh where could I get that t. after you hint I suddenly understood that <*> is supposed to return function which gets t as a parameter - so that's where! :)
03:32:26 <srhb> Yes indeed. :)
03:32:50 <srhb> The idea with the skeleton is to look at the return type and model the RHS after that, hence \t -> ...
03:33:40 <dimsuz> yes, this seems to be the key thing here. I mostly look at the parameters, but I can start from what is returned.
03:33:51 <srhb> I find that it helps, at least. :)
03:33:58 <dimsuz> thanks )
03:34:01 <srhb> You can't do anything with the others anyway, since they are just arguments :)
03:34:22 <srhb> (Anything but *use* them)
03:38:20 <srhb> dimsuz: If you haven't played around with holes yet, I find them great for this kind of thing, ie. `\t -> _whatgoeshere` -- and watch the compiler output. :-)
03:39:50 <dimsuz> srhb: didn't know about this. nice!
03:43:31 * hackagebot liblastfm 0.6.0 - Lastfm API interface  https://hackage.haskell.org/package/liblastfm-0.6.0 (DmitryMalikov)
03:43:49 <dimsuz> srhb: yay, solved it! 
03:43:57 <dimsuz> just followed the types :)
03:43:59 <srhb> dimsuz: Great job! :-)
03:44:21 <srhb> dimsuz: Now you should see the "from a common type" bit clearly :)
03:44:30 <dimsuz> "follow the types and hints of srhb, Luke" ;)
03:44:35 <srhb> :-)
03:44:42 <dimsuz> indeed
03:48:06 <joco42> any idea why this is not a type error?  https://usercontent.irccloud-cdn.com/file/7w2jYZCR/Screen%20Shot%202016-01-02%20at%2013.44.02.png
03:49:27 <roelof_> julianleviston:  im back 
03:49:37 <roelof_> how can we talk private again 
03:49:51 <srhb> roelof_: Most clients have /q name for that
03:50:10 <julianleviston> or you can type /msg julianleviston hi
03:51:12 <cdupont> Hi guys, happy new year :)
03:52:00 <cdupont> I have a Q: since a few month I'm looking for a good IDE
03:52:15 <cdupont> But I'm still not very satisfied
03:52:26 <cdupont> I was using Leksah, now atom
03:52:35 <cdupont> what are you using?
03:53:18 <cdupont> I also tried InteliJ idea, but didnt find it interresting
03:54:06 <srhb> cdupont: I don't know of any true IDE-like experience, but I think it's in the works for Emacs etc.
03:54:30 <cdupont> If possible I'd prefer vim...
03:54:43 <cdupont> I tried some packages for vim
03:55:28 <cdupont> The basic features I need are: code colors, code completion, code navigation, search in files, error highlighting when compiling
03:55:52 <cdupont> I don't know how to achieve that in vim
03:56:13 <cdupont> especially error highlighting and search in files
03:57:53 <cdupont> I use vim for small projects (few files)
03:58:46 <cdupont> for big projects it becomes tedious because I have to exit vim, compile, read the file/lines with errors and open again the corresponding file... not very useable
04:00:33 <srhb> cdupont: Well first thing you should probably set it up so you don't have to leave Vim to compile.
04:01:51 <cdupont> srhb: agreed
04:02:12 <joco42> i put up the question to sof, any quick feedback  on it ? http://stackoverflow.com/questions/34565655/how-to-use-data-kinds-phantom-types-to-encode-units-in-haskell
04:03:22 <joco42> really puzzles me
04:05:43 <cdupont> joco42: strange indeed
04:05:53 <joco42> ok, thanks :)
04:06:58 <joco42> type level programming is a mystery....
04:09:19 <cdupont> joco42: there is https://hackage.haskell.org/package/units
04:09:39 <srhb> joco42: I don't know, perhaps something funny is happening because you're using type aliases. It works fine if you actually make it a new type.
04:09:39 <joco42> thanks
04:09:47 <joco42> hmmm
04:11:14 <srhb> joco42: http://lpaste.net/7558485220769398784
04:11:58 <joco42> thanks srhb  that looks better
04:12:05 <joco42> if it works :)
04:12:11 <joco42> what is the 
04:12:14 <srhb> I don't see why it shouldn't...
04:12:21 <joco42>  ' in front of Km
04:12:30 <srhb> Oh oops, that's the lifted one
04:12:37 <srhb> It doesn't actually make a difference here, you can just get rid of it
04:12:44 <srhb> (You're not actually using that feature)
04:13:21 <joco42> ahh ok
04:13:25 <srhb> It only needs KindSignatures (and I think you shouldn't use it like that)
04:14:16 <joco42> on sof the suggestion is that the type is not generative
04:14:23 <joco42> the comment
04:14:27 <joco42> that is the reason
04:15:07 <srhb> That's what I meant. It's not a new type, just an alias, so your program compiled because it just said sure, Double is Double.
04:15:35 <srhb> (I've never heard it described as generative, though)
04:16:04 <srhb> But yeah, everything should be fine with just KindSignatures on
04:16:56 <moredhel> Hi, I'm looking for some good introductory resources to category theory. Di you have any links that I can follow up?
04:17:20 <joco42> ahh
04:17:22 <joco42> nice
04:18:42 <joco42> http://www.seas.upenn.edu/~sweirich/papers/popl163af-weirich.pdf
04:18:52 <joco42> this seems to be about generativity
04:19:01 <WJWH> I have a question about using stack while still actively developing. Most of the tutorials say you can just go "stack build" and it'll compile the whole thing, but it is not really ready for that.
04:19:27 <srhb> WJWH: How so?
04:19:35 <WJWH> Currently I test all new functions in ghci and regularly "cabal install" new libraries.
04:19:48 <srhb> Well, that's certainly not how you're supposed to use it.
04:20:00 <WJWH> I looked at a few stack tutorials but don't think I have a good mental model of how it works
04:20:03 <hsk3> Should I write my pure functions with lists, or is there some more general "collection" typeclass I can use instead?
04:20:03 <hsk3> So instead of:   processList :: [a] -> Double
04:20:04 <hsk3> something like: processCollection :: Collection c => c -> Double
04:20:05 <hsk3> I'm just wondering whether it's likely I'll have find out later that I don't wanna use lists but some other, more efficient collection type.
04:20:06 <hsk3> Your thoughts?
04:20:34 <WJWH> What would be the stack equivalent of introducing new libraries to an app in development?
04:20:58 <WJWH> hsk3: Ther are Foldable and Traversable
04:21:04 <srhb> hsk3: It's easy to switch usually, even without a general class. Some functions are indeed general, but since the various collections have vastly different data models underneath, there is no one class that fits all.
04:21:14 <srhb> hsk3: In short, "don't worry about it"
04:21:54 <hsk3> So you'd say lists are basically effcient enough for intensive scientific applications?
04:22:12 <srhb> WJWH: stack build, once you've added the package to the cabal file.
04:22:56 <WJWH> hsk3: not really, but that is a different question than whether you should write you functions to a certain typeclass
04:23:33 <WJWH> hsk3: As far as I know, unboxed Vector is the preferred datatype for serious number crunching
04:23:44 <srhb> hsk3: It really depends on what operations you're using
04:24:16 <srhb> hsk3: Lists are mostly used as a sort of control structure. You can construct them very cheaply as long as you consume it in a manner that works well with lists as well.
04:24:28 <WJWH> srhb: Thanks! I'll try that. Afterwards, stack ghci will open a ghci where I can :m + the library, is that correct?
04:24:30 <srhb> There is no "one size fits all" collection type (in any language)
04:24:49 <srhb> WJWH: I would think so. I think you can also do `stack build packagename`
04:24:57 <hsk3> Can you guys tell me about some of the most commonly used collectoin types out there? For future reference.
04:25:02 <hsk3> Would be good to know.
04:25:12 <srhb> hsk3: list, vector, map, set, arrays, ...
04:25:41 <srhb> ByteString is very common too, and Text for actual human-consumable text.
04:26:11 <hsk3> yeah LYAH talks about those
04:26:15 <hsk3> ok thanks
04:26:28 <srhb> WJWH: In fact, stack ghci packagename probably works too
04:27:01 <WJWH> srhb: Many thanks!
04:27:23 <EvanR> WJWH: see also IntMap
04:27:26 <the_2nd> I need some help with pseudo randomness. E.g. having an area of 5x5 units, I'd like to select 10 positions in it. But these should look rather random and organic
04:27:41 <the_2nd> they dont have to be truly random, just should seem unordered
04:27:45 <srhb> the_2nd: "Should look" <-- what does this entail
04:27:51 <srhb> Are they allowed to actually be random?
04:28:11 <the_2nd> srhb, just no real grid like a matrix or chess field
04:28:23 <the_2nd> I'd love a pure solution, not having to mix IO in there
04:28:45 <the_2nd> I could have some iteration index, which I could use as seed
04:28:50 <srhb> the_2nd: The standard random generator is pure, and you can optionally feed it an IO generated random seed
04:28:59 <the_2nd> e.g. depending on the index, move away from position in matrix
04:31:27 <srhb> > take 10 $ randomRs (0,24) (mkStdGen 1)
04:31:29 <lambdabot>  [10,1,15,17,8,2,14,10,10,3]
04:31:39 <srhb> Oh you want them to be exclusive
04:33:00 <the_2nd> srhb, well kinda
04:33:07 <the_2nd> just need a random number from 0 to 1
04:33:19 <the_2nd> which I can multiply with the sizes of the limits
04:33:31 <mniip> > random (mkStdGen 1) :: Double
04:33:32 <lambdabot>      Couldn't match expected type ‘Double’
04:33:32 <lambdabot>                  with actual type ‘(a0, StdGen)’
04:33:32 <lambdabot>      In the expression: random (mkStdGen 1) :: Double
04:33:51 <mniip> > randoms (mkStdGen 1) :: Double
04:33:53 <lambdabot>      Couldn't match expected type ‘Double’ with actual type ‘[a0]’
04:33:53 <lambdabot>      In the expression: randoms (mkStdGen 1) :: Double
04:34:05 <srhb> > randomR (0,1) (mkStdGen 1) :: Double
04:34:05 <mniip> damn
04:34:06 <mniip> > randoms (mkStdGen 1) :: [Double]
04:34:06 <lambdabot>      Couldn't match expected type ‘Double’
04:34:06 <lambdabot>                  with actual type ‘(Integer, StdGen)’
04:34:06 <lambdabot>      In the expression: randomR (0, 1) (mkStdGen 1) :: Double
04:34:08 <lambdabot>  [7.779037508334341e-2,0.8999100029453556,0.6185852686823881,0.20884236121592...
04:34:10 <srhb> ehehehe
04:34:45 <mniip> > fst $ random (mkStdGen 123) :: Double
04:34:46 <lambdabot>  0.7804356004944119
04:35:19 <the_2nd> mniip, 123 being the seed?
04:35:23 <mniip> yes
04:35:24 <srhb> Anyway, if you want to select 10 different cells, just use the first approach and nub the list before taking.
04:35:27 <mniip> you can use randomIO
04:35:32 <mniip> to use the IO stdgen
04:35:40 <the_2nd> mniip, nah its fine
04:35:47 <the_2nd> can create same random numbers at all runs
04:35:59 <mniip> consider passing the actual StdGen around then
04:36:16 <srhb> > take 10 . nub $ randomRs (0,24) (mkStdGen 1) -- like this
04:36:18 <lambdabot>  [10,1,15,17,8,2,14,3,16,19]
04:36:46 <hellomote> hey
04:36:55 <hellomote> someone here
04:37:00 <mniip> no
04:37:07 <hellomote> ...
04:37:08 <the_2nd> Either here
04:37:09 <mniip> (yes)
04:37:13 <hellomote> okay
04:37:50 <hellomote> irc first time LoL
04:38:15 <srhb> hellomote: This channel is full of people, it just gets very spammy in prime time if everyone is greeted when they enter -- sorry :-)
04:39:07 <hellomote> nothing It happens
04:40:01 <hellomote> I saw a post say this channel is active, so I am here
04:40:22 <mniip> it is rather active yes
04:41:03 <hellomote> all right LoL so where are you guys from. I am in TaiWan
04:41:06 <srhb> hellomote: http://ircbrowse.net/haskell
04:41:19 <srhb> hellomote: There's also #haskell-blah for off-topic chat :)
04:42:27 <hellomote> okay thanks
04:44:27 <julianleviston> srhb: dang. I’m the talkiest!
04:44:34 <srhb> julianleviston: I noticed!
04:44:47 <julianleviston> srhb: and I NEVER GO TO SLEEP! lol
04:44:54 <the_2nd> srhb, randomRs only creates integers, not floating
04:45:05 <the_2nd> is there a version which will create floating?
04:45:42 <srhb> the_2nd: The very same version will. Just change the type.
04:46:17 <srhb> nub might be less useful though, but I thought you were selecting indices, hence Int made more sense.
04:46:31 <the_2nd> I guess I'll use your approach
04:46:43 <the_2nd> from 0 to width and another from 0 to height
04:46:47 <the_2nd> this should be fine
04:47:03 <the_2nd> of the area of valid positions
04:47:15 <srhb> > take 10 . nub $ randomRs ((0,4),(0,4)) (mkStdGen 1) -- ?
04:47:17 <lambdabot>      No instance for (Show t0)
04:47:17 <lambdabot>        arising from a use of ‘show_M65068816775874105887466’
04:47:17 <lambdabot>      The type variable ‘t0’ is ambiguous
04:47:19 <srhb> Aw
04:47:26 <the_2nd> rndNumsW = take nCreeps $ nub $ randomRs (0,w) (mkStdGen seed)
04:47:34 <the_2nd> I can drop nub then aswell
04:47:43 <the_2nd> since x == x doesnt mean that y == y aswell
04:47:50 <mniip> julianleviston, http://i.imgur.com/y7sf9FA.png the hero #haskell needs
04:48:07 <srhb> I thought it had tuple instances as well..
04:48:31 <julianleviston> mniip: lf only :)
04:49:19 <srhb> the_2nd: Just zip the infinite lists together to get an infinite (x,y) list and nub that.
04:49:42 <the_2nd> srhb, nub seems expensive to me
04:49:55 <the_2nd> and if I need 20 positions in a 100x 200 area
04:50:04 <the_2nd> it's too unlikely to have double positions
04:50:05 <srhb> Well, either you want unique fast and easy, or you want a very different random generator.
04:50:35 <the_2nd> it's just for a game for enemy spawns
04:50:50 <the_2nd> so the rare case where to enemies spawn on same spot doesn't hurt
04:50:53 <the_2nd> two
04:51:00 <srhb> OK, I'll stop harping on about it. :-)
04:51:16 <the_2nd> since I gonna randomize their walking speed aswell, it's gonna divert pretty quickly :)
04:51:30 <the_2nd> yeah, thanks for the help
04:57:39 <predator317> the_2nd: are you using ghcjs for screeps?
05:06:47 <rubystallion> Why would the DeriveFunctor extension derive a Functor instance for Either, which maps a function only over Right b, but not over Left a? I think mapping the function also over Left a would also satisfy Functor laws; which other laws lead to this?
05:07:38 <the_2nd> predator317, ? no normal ghc
05:07:50 <the_2nd> srhb, http://lpaste.net/7739777349406687232
05:07:56 <predator317> the_2nd: wasn't screeps javascript only?
05:08:02 <the_2nd> *creeps
05:08:07 <cdupont> rubystallion: but Right and Left have different types
05:08:19 <cdupont> you're thinking of bifunctors
05:10:52 <rubystallion> cdupont: so functors are always covariant in the rightmost type and invariant in the others?
05:11:29 <mpickering> What do you mean by invariant? 
05:12:46 <rubystallion> mpickering: I mean that fmap f (Left a) = Left a.
05:14:42 <Nadrieril> I believe this choice was made because of the usage of Either as an error Functor/Applicative/Monad
05:14:42 <rubystallion> mpickering: That it's idempotent to morphisms?
05:15:59 <JazzyEagle> Hello, everyone.  I'm hoping someone can help me with a stack issue.  I'm creating a new project, and right now, all I'm trying to do is install the network-simple-tls library.  The issue seems to be that the lib needs base 4.7.0.2 and I have base 4.8.1.0 installed...
05:16:05 <srhb> rubystallion: DeriveFunctor works by applying applying id to all type arguments but the last, which has fmap applied to it
05:16:10 <Nadrieril> and by default DeriveFunctor indeed makes functors covariant in the rightmost type and invariant in the others
05:16:43 <JazzyEagle> I updated stack.yaml to tell it specifically to use base 4.7.0.2, but stack solver still complains about not finding 4.7.0.2, and trying to manually install it using stack install base-4.7.0.2 seems to yield no output, so I'm not sure what I'm doing wrong.
05:16:49 <mpickering> rubystallion: i don't understand what you are saying sorry
05:16:50 <JazzyEagle> Here's what I got thus far:  http://lpaste.net/224078459696054272
05:17:36 <mpickering> JazzyEagle: you can't install a new version of base
05:17:52 <JazzyEagle> Oh...
05:18:03 <JazzyEagle> So does that mean until the library is updated, I simply can't use it?
05:18:28 <mpickering> The version is locked to the versionof ghc you have
05:18:59 <srhb> JazzyEagle: You need to pick a resolver with that exact version of base.
05:19:00 * hackagebot fast-digits 0.2.0.0 - The fast library for integer-to-digits conversion.  https://hackage.haskell.org/package/fast-digits-0.2.0.0 (Bodigrim)
05:19:16 <srhb> JazzyEagle: I believe that's all the lts-1.x resolvers
05:19:38 <mpickering> You can try with --allow-newer in cabal land but I don't know what the stack equiv is
05:19:40 <JazzyEagle> shrb: I'm not sure I understand what you mean by lts resolvers.
05:20:07 <rubystallion> srhb: Nadrieril: OK thanks. I guess it's probably because Either is used for error handling indeed.
05:20:11 <srhb> JazzyEagle: stack uses resolvers to pick a fixed package set. They are tied to base versions.
05:20:37 <srhb> Or rather ghc versions (that are tied to base versions)
05:20:39 <mpickering> Maybe there is another up to date tls library? 
05:21:16 <JazzyEagle> Possibly..  I chose that one because it seemed relatively simple to get started with.
05:21:17 <Cale> rubystallion: It's impossible to define any other instance of Functor for Either.
05:21:27 <Cale> rubystallion: The order of type parameters matters
05:21:31 <JazzyEagle> It does appear that there are plenty of other ones out there.
05:21:46 <srhb> JazzyEagle: So using, for instance, lts-1.15 as your projects resolver gives you base 4.7.0.2
05:21:51 <Nadrieril> rubystallion: also, it wouldnt make sense for Either to be a functor in both its arguments, because that would force them to be equal 
05:22:08 <srhb> JazzyEagle: http://www.stackage.org/lts-1.15
05:22:12 <Cale> fmap :: (Functor f) => (a -> b) -> f a -> f b
05:22:19 <Cale> If we choose f = Either e
05:22:23 <Cale> then this becomes
05:22:30 <Cale> fmap :: (a -> b) -> Either e a -> Either e b
05:22:55 <JazzyEagle> srhb: Thank you very much!!  I'll look into that!!
05:23:06 <JazzyEagle> Yeah, I see in stack.yaml that it's currently set to lts-3.14.
05:23:07 <Cale> So it has to be applying the function to things constructed with Right, and leaving the Left things alone.
05:23:14 <srhb> JazzyEagle: Which is too new a GHC, hence too new a base. :)
05:23:42 <JazzyEagle> Yeah.  Do you know how to find out which lts package is needed?
05:24:06 <srhb> JazzyEagle: I just looked in 1.15 and it has base-4.7.0.2 which is the one OSM-server requires
05:24:10 <Cale> rubystallion: Since Haskell doesn't have type level lambda (and even if it did, it wouldn't interact very well with type classes), you can't write an instance for \t -> Either t b
05:24:17 <Nadrieril> indeed Cale
05:24:56 <Cale> Without introducing a newtype, anyway.
05:25:41 <JazzyEagle> Ok.  I'll look deeper into this.  Thank you very much!!
05:25:43 <srhb> JazzyEagle: I'm a bit puzzled where that constraint is introduced though.
05:25:54 <JazzyEagle> What constraint?
05:26:29 <srhb> JazzyEagle: (global constraint requires ==4.7.0.2)
05:27:05 <JazzyEagle> shrb:  IIRC, I believe it's the certificate package that network-simple-tls relies on.  It constrains base to (>=3 && <4.8)
05:27:05 <srhb> JazzyEagle: You seem to have it set in your stack.yaml file -- why?
05:27:31 <srhb> Oh ouch. That shouldn't happen in the lts resolver for some other base version, really. What is that package called?
05:27:38 <mpickering> JazzyEagle: 4.7 is quite old fwiw, within the next month there will be a new version on ghc with 4.9
05:27:47 <JazzyEagle> shrb:  At the time, I didn't realize about the lts setting, and I was trying to force base to 4.7.0.2, as that's how I learned to restrict package versions in another project that I've helped on.
05:28:06 <srhb> JazzyEagle: What happens if you remove that constraint entirely?
05:28:11 <JazzyEagle> srhb: http://hackage.haskell.org/package/certificate
05:28:22 <srhb> JazzyEagle: Perhaps we can find the CORRECT solution for upgrading it, rather than relying on this approach.
05:29:05 <srhb> JazzyEagle: Ah yes, I see. That makes it hard, since it's deprecated
05:29:43 <srhb> JazzyEagle: Well perhaps using lts-1.x is easier then :)
05:29:52 <JazzyEagle> Is there a way to possibly build network-simple-tls and tell it to ignore that dependency, since it uses the X509 package now, or do I need to send an e-mail to the dev team?
05:30:18 <srhb> JazzyEagle: What, it does?
05:30:34 <srhb> JazzyEagle: The hackage version appears to show it depending on certificate still, not x509
05:31:10 <JazzyEagle> Oh, I see.  It somehow uses an X509 datatype.  I got that confused with the package.  My apologies.
05:31:21 <srhb> No problem. :)
05:31:34 <srhb> Well, you could fix network-simple-tls to depend on x509 :-)
05:32:24 <JazzyEagle> I wonder how difficult that would be...
05:32:39 <rubystallion> Cale: Do you mean that in the type of fmap, the variable f needs to have type (a->b), so that if, in the definition for fmap, f was also applied to the a from Left a, it would give a type error?
05:32:40 <srhb> Sometimes it's a matter of search/replacing :-)
05:32:42 <srhb> Sometimes it's harder.
05:32:51 <JazzyEagle> Yeah.
05:34:18 <JazzyEagle> Ok.  I'll play around with using the lts first.  If I can't figure that out, then I'll try to update the package.  Or maybe I'll end up trying both.  :)
05:34:24 <JazzyEagle> Thank you very much for all your help!!!
05:34:54 <rubystallion> :cd ../635101
05:38:08 <beepbeep_> In this code sample https://gist.github.com/aaronmu/eb7477c0e34aa728040f Why does ghci load the Main module instead of the Learn module?
05:38:40 <the_2nd> I get a non-exhaustive pattern error here : http://lpaste.net/8642288744394653696
05:38:43 <the_2nd> line 3 to end
05:39:05 <the_2nd> I dont see why, since the Nothing case is already dealt with
05:39:23 <the_2nd> (the version with Creep instead of Maybe Creep worked before)
05:39:49 <rubystallion> Cale: OK, I checked it myself and it does indeed give a type error. Interesting, thanks for clearing that up!
05:41:58 <JazzyEagle> the_2nd: I don't think it's the Maybe causing the non-exhaustive pattern error, I think it's the case ac.  Without seeing the AimController datatype and the entire case statement, i can't confirm that, but that's where I recommend you look.
05:42:26 <the_2nd> JazzyEagle, it worked before, tho. Only added the maybe
05:42:28 <JazzyEagle> I'm guessing there's other AimController types that you didn't account for in your case statement.
05:42:55 <the_2nd> nope, 3 types and 3 cases
05:43:40 <JazzyEagle> the_2nd: Oh, I see...  Spelling error: decideAim ...  devicedAim _ Nothing
05:44:00 <JazzyEagle> So it doesn't see the Nothing pattern due to the spelling difference.
05:44:24 <the_2nd> JazzyEagle, oh boy
05:44:28 <the_2nd> thanks for catching that
05:44:29 <the_2nd> fixed it
05:44:34 <JazzyEagle> No problem.  I've done that before.  :)
05:44:40 <the_2nd> typical might-have-taken-days-to-notice-bug
05:44:45 <JazzyEagle> :)
05:45:05 <the_2nd> any compiler flags to throw a warning in that case?
05:45:46 <JazzyEagle> Not sure, honestly.  I've focused more attention on the language itself than its tools.
05:45:54 <JazzyEagle> I'm wondering if hlint might have been able to catch it?
05:46:19 <Cale> the_2nd: The compiler already gave you a warning :)
05:46:33 <Cale> oh, you were referring to runtime
05:46:37 <Cale> yes, there is a flag
05:47:11 <Cale> -fwarn-incomplete-patterns
05:47:46 <Cale> -W will turn that on as well
05:48:39 <the_2nd> thanks for the help everyone
05:49:43 <JazzyEagle> Sure!
06:25:19 <WarzoneCommand> is there a pragma to tell GHC that a particular function is total (i.e. to suppress the 'unmatched pattern' warning for a particular function?) 
06:25:35 <WarzoneCommand> or is s.t. like: f _ = absurd the only option?
06:27:43 <WarzoneCommand> (if so, does a soltuion like that induce a performance hit)
06:29:34 <mniip> you could try making the last pattern lazy
06:29:38 <mniip> I suppose
06:33:49 <WarzoneCommand> hmm
06:35:22 <maerwald> WarzoneCommand: how can the function be total if there are unmatched patterns?
06:35:37 <maerwald> do you mean "this function is always used in a safe way"?
06:37:13 <maerwald> for such a thing, you could try using liquidhaskell, which can prove that kind of thing, but it's highly experimental: https://github.com/ucsd-progsys/liquidhaskell#totality-check
06:38:01 <WarzoneCommand> maerwald: because the GHC totality pattern match checker is buggy 
06:38:35 <maerwald> that didn't happen to me yet
06:38:43 <WarzoneCommand> e.g. for some settings with GADTs, pattern synonyms, or view pattern GHC screws up 
06:38:50 <maerwald> ah
07:09:34 * hackagebot atp-haskell 1.10 - Translation from Ocaml to Haskell of John Harrison's ATP code  https://hackage.haskell.org/package/atp-haskell-1.10 (DavidFox)
07:37:02 <KaneTW> when writing bindings to a C api which has a set of _async functions available, does it make sense to bind them into Haskell?
07:42:51 <EvanR> they setup a callback? the callback can totally callback into haskell
07:43:39 <KaneTW> you're supposed to poll whether the operation is complete
07:45:14 <cocreature> do we have type level maps somewhere?
07:45:53 <cocreature> I feel kinda bad for using a list of tuple when I really want a map aka unique keys
07:46:23 <KaneTW> there are two functions EIB_Poll_Complete which checks whether the operation is complete and EIBComplete which completes it and returns the result (int) with the guarantee that EIBComplete won't block if EIB_Poll_Complete says the operation is complete
07:48:14 <EvanR> KaneTW: what does "_async" function refer to? that polling protocol?
07:48:33 <EvanR> (doesnt seem very async)
07:49:00 <KaneTW> apparently? the documentation doesn't seem very good
07:49:16 <EvanR> but exposing those polling routines directly seems like a very good basis to make something better on top in haskell
07:49:30 <EvanR> i mean, to hide the polling
07:49:36 <JonReed> Does anybody know how to do the following in Haskell. I need to have something like  "class Renderable a" which has a method like  `render :: r -> a -> m ()`. `r` is a resource which is specific to that type a. Each type a can have its own resource, its one per type.
07:49:37 <JonReed>  Now I want the class to have a const function "loadRes :: m (r)" which can load a resource so that I can then pass it to the "render" function. 
07:49:54 <EvanR> dont use type classes for that
07:50:13 <KaneTW> does the complete OS thread block if a haskell thread is in a FFI operation?
07:50:37 <EvanR> no
07:50:50 <exio4> KaneTW: using -threaded or not?
07:51:17 <EvanR> -threaded + "unsafe" will make the ffi stuff just work
07:51:41 <KaneTW> but there's a possibility it'll block if not -threaded but 'unsafe'
07:51:43 <KaneTW> +?
07:52:18 <JonReed> EvanR: What else to use if not typeclasses? Each type can be rendered in one unique way.
07:52:23 <EvanR> not having -threaded really makes things act weird
07:52:30 <KaneTW> i see
07:52:30 <EvanR> thats what i experienced
07:53:20 <EvanR> JonReed: to model the various renderable strategies (and so you can include one such strategy in your type as a field), use a record type with fields for each of these methods
07:53:37 <vxri> anyone using emacs w/ ghci?
07:54:23 <vxri> I'm not getting syntax highlighting with error messages from sourcing my buffer. I do get syntax highlighting, but only when I type into the repl. any ideas?
07:55:02 <JonReed> EvanR: Ah. That makes a lot more sense.
07:55:13 <bergmark> i've given up on using emacs with anything that is cpu heavy or uses networking...
07:55:27 <vxri> bergmark why?
07:55:51 <EvanR> JonReed: you can parameterize this type by r and m if you want. then at the use-site you specify what kind of monad and resource you will be using
07:56:06 <bergmark> sooner or later emacs freezes
07:57:59 <adas> what is the Proxy type used for?
07:58:47 <bergmark> adas: to pass around a type without needing a value
07:59:34 <adas> bergmark: when would we need to do something like that? when using type families?
07:59:40 <bergmark> adas: for example, we use it here to construct the schema of a type: https://github.com/silkapp/json-schema/blob/master/src/Data/JSON/Schema/Generic.hs
08:00:18 <geekosaur> adas, do you know about phantom types?
08:01:29 <EvanR> KaneTW: im trying to find the guide which goes through the mental hoops to classify how all these ffi things interact with the runtime
08:01:56 <KaneTW> http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/ this one?
08:03:45 <adas> geekosaur: yup. types whose type variable do not should up in any data constructor. thats all I know
08:04:28 <geekosaur> right, but sometimes you need to pass around the phantom. the old way is to use undefined but if you made a mistake that's a runtime crash waiting to happen. Proxy is a more principled way to do it
08:05:09 <EvanR> KaneTW: no that wasnt it
08:05:10 <geekosaur> (Proxy :: Proxy PhantomType) instead of (undefined :: PhantomType)
08:05:13 <geekosaur> as a simple usage
08:05:38 <EvanR> this seems in the right ballpark https://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml
08:05:54 <geekosaur> you can then go on to do more clever things with phantom types, since you can safely pass them around without needing to come up with possibly specious values
08:06:39 <KaneTW> ty
08:07:18 <KaneTW> i'm kind of tempted to just autogenerate the low-level bindings and then write high-level bindings after that
08:07:39 <vxri> anyone mind giving some feedback on my solutions to monoid exercises from chris and julie's book? http://lpaste.net/148292
08:08:00 <KaneTW> because https://github.com/knxd/knxd/blob/master/src/include/eibclient.h has a lot of functions that can be made into a single function acting on a sum adt
08:08:34 <EvanR> good idea
08:08:52 <EvanR> i mean auto generating
08:09:14 <adas> geekosaur: thanks for the clarification
08:09:17 <KaneTW> i tried using c2hsc and wasn't exactly impressed
08:09:30 <EvanR> though consolidating an api into one function that operates on an argument to choose which call to do is kind of the jquery / node / ruby anti-pattern
08:09:39 <KaneTW> well
08:09:41 <KaneTW> not the whole api
08:09:45 <vxri> KaneTW what was the problem with c2hsc?
08:10:09 <KaneTW> bindings-DSL felt too restrictive for me i think
08:10:22 <KaneTW> compared to c2hs at least
08:10:26 <jmcarthur> I like bindings-DSL for making low level bindings.
08:10:30 <EvanR> if use cases involving passing a constant in to make a call then it might indicate they are really separate functions
08:10:53 <jmcarthur> In fact, I always find myself writing something higher level on top of whatever generator I use.
08:11:13 <KaneTW> i'm mostly looking at stuff like EIBOpenBusmonitor/EIBOpenBusmonitorText
08:11:26 <hololeap> i'm trying to get started in functional programming. would haskell or erlang be better to learn first (i want to learn haskell eventually). i have mostly programmed in ruby and c#
08:11:34 <EvanR> i would still make those separate
08:11:39 <KaneTW> i see
08:11:50 <EvanR> and making the lowest level stuff exactly like C is probably simplest 
08:11:51 <jmcarthur> hololeap: I don't think learning Erlang is likely to make learning Haskell much easier.
08:11:56 <jmcarthur> Maybe a little.
08:11:57 <KaneTW> i'll prob do that then
08:12:02 <Jinxit> hololeap: depends on what you want to do
08:12:05 <EvanR> itll piss off the fewest people in the long run
08:12:07 <Jinxit> erlang is great for servers
08:12:18 <Jinxit> but for most other stuff I'd choose haskell
08:12:33 <vxri> is Hydra pretty much dead or has something succeeded it?
08:12:44 <EvanR> what does erlang have to do with haskell at all?
08:12:53 <Jinxit> they are both functional?
08:12:58 <EvanR> o_O
08:13:14 <EvanR> C is purely functional
08:13:15 <jmcarthur> EvanR: I think from afar most people related them because they are both "functional", even though once you learn them they are really different.
08:13:22 <jmcarthur> *relate
08:13:43 <hololeap> i am very interested in the actor model, but i've heard many good things about haskell
08:13:47 <jmcarthur> And most people don't realize exactly the ways C is and is not purely functional.
08:14:24 <jmcarthur> hololeap: From that point of view, Erlang is very focused on that particular model, while Haskell tries to be good at working with all sorts of different models.
08:14:29 <EvanR> in the case of haskell and erlang, this seems like a good evidence for "functional" being diluted out of existence
08:14:38 <argoneus> hello
08:14:46 <Jinxit> EvanR: you mean erlang is not functional?
08:14:50 <jmcarthur> EvanR: I thought it was "common knowledge" that Erlang is functional.
08:15:00 <EvanR> i guess i vaguely knew that but
08:15:05 <argoneus> I'm just starting with haskell, but why is appending to a list more expensive than prepending?
08:15:14 <EvanR> thinking about it, that means nothing
08:15:19 <argoneus> doesn't make sense to me why that should be, in a good implementation
08:15:35 <EvanR> to me erlang is an imperative language
08:15:36 <hololeap> jmcarthur: ok. maybe i should just dive into haskell. would you recommend any starting points?
08:15:38 <jmcarthur> argoneus: Haskell's standard linked list is purely functional. You can't just mutate the end. In fact, you have to *find* the end first.
08:15:46 <Jinxit> EvanR: it still gets you to think about higher-order functions, map/fold, immutability, recursion
08:15:48 <Jinxit> etc
08:15:49 <argoneus> oh, right
08:15:52 <argoneus> haskell loves immutable things
08:15:53 <argoneus> thanks :)
08:16:10 <EvanR> Jinxit: so its in the same family as javascript and python
08:16:11 <jmcarthur> @where learnhaskell
08:16:11 <lambdabot> https://github.com/bitemyapp/learnhaskell
08:16:14 <EvanR> and ruby
08:16:15 <jmcarthur> hololeap: ^^
08:16:21 <Jinxit> immutability?
08:16:46 <EvanR> sure
08:16:47 <jmcarthur> EvanR: Erlang also focuses on immutable data (within a process) and doesn't have imperative style loops, etc.
08:16:47 <hololeap> i think the idea of making everything immutable is awesome. its one of the things that has brought me here.
08:16:55 <EvanR> interesting
08:16:58 <Jinxit> and yeah no loops
08:17:15 <Jinxit> I would definitely distinguish erlang from js/py/ruby
08:17:19 <hololeap> jmcarthur: thanks
08:17:20 <EvanR> how do you do a forM_?
08:17:25 <EvanR> side effects during a map?
08:17:35 <Jinxit> as the former is functional, while the latter can be functional
08:17:46 <jmcarthur> EvanR: Erlang has more side effects by default than Haskell.
08:18:03 <EvanR> ok so its functional in the same way as lisp?
08:18:12 <jmcarthur> EvanR: But you can kind of think of all side effects in Erlang as communicating with other processes (though that's not literally true).
08:18:22 <Jinxit> is it not?
08:18:28 <jmcarthur> It's sort of true.
08:18:39 <Jinxit> I mean you have a state which you update by calling your recursive function with a new state
08:18:50 <EvanR> do you have IORefs
08:18:50 <Jinxit> but that's still functional
08:19:02 <jmcarthur> I meant to imply that mutability is not one of those side effects.
08:19:19 <jmcarthur> EvanR: You can implement something like an IORef by making another process.
08:19:22 <EvanR> ah
08:19:36 <Jinxit> and honestly you can throw things on the wire or filesystem at any time
08:19:43 <Jinxit> so that side effect is also available
08:19:44 <jmcarthur> There may be a local version of it, and having one wouldn't technically violate the model since you can implement it anyway.
08:20:31 <jmcarthur> EvanR: Basically an IORef would be a recursive process whose accumulator is the state of the ref and which responds to messages for getting and setting the state.
08:20:36 <EvanR> even if 100% of "unfunctional" things were implemented as process communication, they would leave you with a normal imperative language, in spirit
08:20:44 <jmcarthur> Kind of.
08:20:59 <EvanR> you can define C, or OOP, or whatever as one of those
08:21:03 <hc> iirc joe armstrong (erlang designer) said erlang is only functional "where appropriate"; it was not defined with being functional as a primary goal, just a necessity
08:21:03 <jmcarthur> If you reduce communication, you are reducing effects. It's a fairly easy knob to control.
08:21:18 <EvanR> sure thats how i reduce effect in ruby
08:21:56 <EvanR> less statements that "send a message to mutate" something
08:22:07 <Jinxit> the nice thing about erlang being functional is that when a process crashes you can see the current state very explicitly and just re-run that same state until you find the bug
08:22:14 <jmcarthur> Anyway, I'm not going to argue the point too hard, but I consider Erlang functional in the sense that it tries to limit side effects in a well defined way.
08:22:29 <EvanR> Jinxit: yeah thats a cool property, im not sure that functional is the right word for it
08:22:31 <jmcarthur> Even if only as a language "philosophy"
08:22:52 <jmcarthur> Like most ML languages or many lispy languages.
08:23:03 <EvanR> a sophisticated process manager maybe
08:23:29 <EvanR> we dont have that in most systems functional or not
08:24:36 <jmcarthur> hololeap: Sorry you got lost in the noise. You're welcome! And feel free to ask questions here if you are having trouble finding the answer yourself. We try to be friendly... :)
08:24:45 <parsnip> hmm, i deleted .ghc and .cabal, and `cabal install cabal-dev` is still now working. 
08:24:46 <parsnip> http://lpaste.net/148295
08:25:02 <parsnip> time to install from github? 
08:25:58 <hololeap> jmcarthur: alright, thanks again
08:26:32 <geekosaur> is cabal-dev still maintained?
08:26:39 <bergmark> geekosaur: no
08:27:24 <bergmark> our cabal-dev fork works at least up to 7.8, but we don't use cabal-dev anymore either: https://github.com/silkapp/cabal-dev
08:27:52 <parsnip> oh, i was watching Pandoc Part 2 on Code Deconstructed - Episode 2 - YouTube.html https://www.youtube.com/watch?v=nCwG9ijQMuQ, and he suggested cabal-dev to work with pandoc interactively. 
08:28:36 <parsnip> it /is/ from 3 years ago though. 
08:29:24 <jmcarthur> It stinks that in a fast moving community learning resources go stale so quickly.
08:29:58 <bergmark> cabal-dev still had a place until stack came out since it had more hacky behavior than cabal sandboxes allowed :)
08:30:22 <parsnip> any ideas how a newb might step into the pandoc source and mess around? 
08:31:07 <bergmark> parsnip: there's a stack.yaml in the repo so it's probably easiest to get going using stack then
08:31:24 <jmcarthur> parsnip: maybe something like `stack unpack pandoc; cd pandoc; stack build`?
08:31:43 <bergmark> you can run `stack setup' inside the repo to install the right GHC, and then `stack build' to compile it
08:31:50 <jmcarthur> ah stack setup, right
08:32:01 <jmcarthur> once you have enough ghcs installed you forget about that one
08:32:46 <the_loco> Hello everybody. I have a problem with the setEnv function. When I do something like setEnv "FOO" "" and then lookupEnv "FOO". I get Nothing. That's because the setEnv function does "unsetEnv key" when the values is empty. Do you know what could I do?
08:33:04 <jmcarthur> oh, and the `stack unpack pandoc` bit is just if you want the code and don't need to be able to commit and push. it doesn't pull the actual repo for you.
08:33:25 <jmcarthur> that'd be a nice feature
08:33:26 <bergmark> i was just wondering, is there no `cabal get -s' in stack?
08:34:07 <jmcarthur> there may be
08:34:08 <parsnip> thank you all :)
08:34:25 <jmcarthur> Not aware of one.
08:34:38 <bergmark> the_loco: that sounds nasty...
08:35:26 <jmcarthur> the_loco: sadness
08:35:32 <geekosaur> the_loco, are you on Windows?
08:36:02 <the_loco> No.
08:36:07 <jmcarthur> geekosaur: I just tried it on my linux box. It has the behavior the_loco described.
08:36:25 <geekosaur> yeh, I was thinking the wrong thing. Use System.Posix.Env
08:36:34 <jmcarthur> Ah. Maybe that's the solution.
08:36:39 <geekosaur> it's doing that so it does the same thing on Unix as on Windows
08:36:44 <geekosaur> (where empty envars do not exist)
08:36:51 <jmcarthur> But now that I know about it, I'm annoyed.
08:36:52 <jmcarthur> Ah.
08:36:56 <geekosaur> so you need the platform version
08:37:25 <the_loco> Yeah, but what if I want to use the code I'm writing on Windows?
08:37:39 <geekosaur> then you lose because there is no such thing as an empty envar on Windows
08:37:53 <geekosaur> if you set it empty¸the win32 api deletes it
08:40:03 <the_loco> :'(
08:41:24 <the_loco> Well, I'll see what can I do. Thanks.
08:41:40 <lamefun> Is there a jQuery-like library for GHCJS?
08:41:48 <lamefun> (ghcjs-dom)?
09:19:38 * hackagebot pred-trie 0.4.1 - Predicative tries  https://hackage.haskell.org/package/pred-trie-0.4.1 (athanclark)
09:26:13 <Ainieco> hello, what's up with overloaded record field?
09:27:28 <Ainieco> how many more years we're going to use silly typeField naming convention? 
09:28:47 <acertain> is there a principled/easy way to allow `withDict :: DictOf c -> (c => a) -> a` where DictOf is a compiler-generated data family, and forbid `withDict a Dict` (with a Dict similar to that in constraints), in a haskell-like language?
09:29:05 <acertain> i.e. a type system feature or something
09:30:14 <Jinxit> Ainieco: ghc 8 afaik
09:31:26 <Ainieco> Jinxit: sigh
09:31:40 <geekosaur> only partially in 8.0.1 as I understand it
09:33:19 <Ainieco> Jinxit: geekosaur ugh https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.0.1 it's on "won't make it" list actually
09:34:00 <jmcarthur> Ainieco: only magic type classes aren't making it
09:34:01 <geekosaur> "only partially" --- DuplicateRecordFields is in
09:34:31 <geekosaur> magic type classes to resolve conflicts not going to make it
09:34:42 <jmcarthur> overloaded labels will be making it apparently
09:34:56 <Ainieco> jmcarthur: geekosaur ah, got it, thanks! that's really great, been waiting for this literally for years
09:37:06 <Jinxit> what impact does this have on Lens?
09:37:12 <Jinxit> if any
09:37:42 <mag__> I'm starting to believe that Haskell is another C++. It's been like one entire week learning the language, every day there's another new concept, another way of doing things... The funny thing is, that I'm just scratching the surface.
09:38:12 <jmcarthur> mag__: I sort of agree. Haskell is a swiss army knife. I'm not super happy with that, but at least it's a much more principled swiss army knife.
09:39:08 <Ainieco> mag__: you're missing the point, with haskell you're not learning the langugage but learning the *concepts* and theories, with cpp you're in fact just learning language
09:39:41 <Ainieco> mag__: while concepts and theories could be applied outside of haskell, cpp cannot be applied outside cpp
09:39:42 <EvanR> try to ignore the myriad of haskell extensions until youre ready
09:39:45 <jmcarthur> Ainieco: The language itself (well, GHC's flavor of it) is also pretty big and featureful.
09:40:19 <EvanR> you can write lots of stuff without any signifiant extensions
09:40:45 <jmcarthur> In fact, a lot of stuff is better without the extensions.
09:40:57 <mag__> Sigh.. will do
09:41:36 <jmcarthur> Many extensions are a bit easier to design with, in my opinion, but with some additional work you can often design something simpler and more robust without them.
09:41:51 <mag__> Right know I feel a deep respect for Simon Peyton. The man is a genius! damn
09:41:51 <EvanR> GADTs is pretty cool
09:42:03 <mag__> :(
09:42:31 * mag__ break it's over, back to haskell
09:42:45 <EvanR> but you might not appreciated until you go into the mines and come back with experience and random gripes to sell in town
09:42:57 <EvanR> appreciate it*
09:44:08 <jmcarthur> I feel the same way about a lot of haskell libraries. transformers is a nice library, but not everything needs to be a transformer stack.
09:45:21 <EvanR> well, scaling a tower of transformer stacks might be a requisit quest for noobs. ;)
09:45:58 <EvanR> you cant have your desert without eating your vegetables
09:46:01 <Ainieco> jmcarthur: but what actually takes most of the time to learn is not the language itself but language agnostic conepts like immutability/monads/sum,prod types/etc
09:47:08 <EvanR> that being said most programming is not learning "the language itself" in that sense
09:47:32 <EvanR> the standard libraries, available other libraries, conventional solutions, how to get through your work day philosophy etc
09:47:41 <Ainieco> jmcarthur: that's what i wanted to say, haskell itself(syntax,keywords, prelude) IMO isn't really that big, put aside extensions
09:48:43 <Ainieco> oh, 8.0.1 realease is actually real soon, i thought it would be another year or so, awesome!
09:50:21 <acertain> could you do `withDict :: DictOf (c a) -> (forall r. (Coercible a (WithDict r c a), Coercible (WithDict r c a) a, c (WithDict r c a)) => a) -> a` where DictOf is a data family with reflection?
09:50:57 <lambda-11235> Are they gonna post a new spec for haskell 8, or is haskell 2010 still the standard?
09:53:02 <Ainieco> lambda-11235: do you mean haskell 8000? i'm not sure humanity will survive this long
09:53:52 <Ainieco> probably will be wiped out by robots powered by haskell 4000
09:54:13 <EvanR> in the year 9995
09:55:32 <lambda-11235> Ainieco: Put another way, how are haskell versions (7.x.x, 8.x.x, ...) related to the specifications (98, 2010, ?)?
09:55:59 <acertain> lambda-11235, GHC versions are unrelated
09:56:04 <geekosaur> they're not, mostly. and ghc 7.10 pretty much broke with the specifications
09:56:48 <monochrom> 7.x.x is a GHC version, not a Haskell version
10:39:11 <nomeata> Hi. What is the latest recommendation for CPP and warning free code involving imports of Control.Applicative and Data.Monoid? Hiding stuff from the Prelude?
10:43:14 <physixer> sort :: (List X) => (List Y) | (Y permutation X) & { a cmp b | a, b in consecutive-pairs X where cmp in { <, <=, >, >= } }
10:43:47 <physixer> s/consecutive-paris X/consecutive-pairs Y/
10:44:57 <physixer> can I do this in Haskell? (note: I only defined what sort is, this will eventually be checked against 'how I sort' later )
10:46:55 <Ainieco> !faq
10:47:20 <Ainieco> hm, probably different one, already forgot everything
10:49:38 <geekosaur>  @faq got changed anyway
10:50:30 <Ainieco> ah, sigh
10:54:01 <ij> I've a sudoku board and I want to calculate all possible numbers for each tiny square. Somewhere in the code I do this twice for the same board, but they're not very close in the dependency graph. Will the computation be reused?
10:55:01 <Ainieco> ij: do you mean memoization?
10:55:46 <ij> I guess sorta.
10:55:49 <EvanR> no
10:55:54 <EvanR> hes talking about lazy evaluation
10:56:42 <EvanR> the computation will probably not be reused
10:57:52 <EvanR> computations are reused if you have a parameter or a variable that is used in multiple places in a function body or let body
10:58:11 <ij> It would be if it would be close in the dep. graph? f x = (g (h x)) + (z (h x)) then "h x' reused.
10:58:14 <ij> It would be if it would be close in the dep. graph? f x = (g (h x)) + (z (h x)) then "h x" reused.
10:58:38 <EvanR> no
10:58:42 <EvanR> h x will be evaluated twice
10:58:51 <EvanR> at most
10:58:56 <EvanR> not a very good explanation
10:59:04 <ij> Hmm, I would've thought it would be.
10:59:08 <EvanR> the result of the two h x will not be shared
10:59:16 <Ainieco> ij: haskell doesn't have builtin memoization
10:59:17 <EvanR> youre thinking about "common subexpression elimination"
10:59:20 <biglama> hi guys, how can I use infix notation when doing a qualified import ?
10:59:27 <biglama> for example : import Data.List as L
10:59:39 <Ainieco> `L.foo` ?
10:59:39 <biglama> x `L.elem` [1,2] => does not work
11:00:13 <biglama> Ainieco: errr... it does work
11:00:13 <Ainieco> heh, haven't done any haskell in while, sorry
11:00:19 <biglama> sorry for the noise
11:00:23 <EvanR> ij: to get that to work, take the (h x) out and put it in a let 
11:00:24 <ij> EvanR, so since you can't be sure reuse will be faster, it's not done, right?
11:00:34 <Ainieco> biglama: ah, it works afterall, cool
11:00:54 <ij> Ah, so you can do it.
11:00:56 <EvanR> ij: someone else might know why its not done, im not sure
11:01:04 <ij> Ok, thanks.
11:01:13 <EvanR> f x = let foo = h x in g foo + z foo
11:20:01 * hackagebot option 0.1.0.1 - A strict version of Maybe  https://hackage.haskell.org/package/option-0.1.0.1 (georgerogers42)
11:20:09 <Ainieco> how that other "orm" for haskell was called where configuration was made via yaml kind of thing?
11:23:54 <Ainieco> that was groundhog
11:24:46 <Ainieco> love it, probably the best one out there for working with databases
11:27:01 <Ainieco> is there a way to configure cabal to use certain directory to store its sanboxes? by default it uses current directory but i don't want that because it makes difficult to back that stuff up efficiently
11:30:56 <Ainieco> ah, i there is i remember now
12:00:32 <JonReed> Hi, I'm trying to figure out how to use type families in this example (http://lpaste.net/148316)  I'm boiled down my struggle to a really simple example and for somebody who knows some type level programming it should be clear what is wrong. If somebody can look at it, it would be great. I think I'm missing something really basic, but I'm totally stuck. 
12:02:52 <Ainieco> how M-C-m function is called from http://www.mew.org/~kazu/proj/ghc-mod/en/emacs.html? i have really odd keybindings and i can't find it by keybinding
12:03:59 <gregolsen> Hi everybody. I'm learning Phantom types reading this article https://wiki.haskell.org/Phantom_type. "Simple examples" chapter first example assumes that constructor is not exported but still defines function like this http://lpaste.net/148317 – seems like constructor is in use. I probably missing something obvious here http://lpaste.net/148317 – could someone please explain this?
12:06:51 <tommd> gregolsen: That paste lacks context, but FormData does indeed appear to be used as a constructor.
12:07:21 <tommd> gregolsen: The comment makes me think this function appears in the same module as the FormData definition, and thus has access to the constructor.
12:08:11 <ReinH> Ainieco: C-h f will give you information on functions, including their bindings.
12:09:25 <Ainieco> ReinH: yup, but i don't know name or actual keybinding of that function alas
12:09:37 <ReinH> JonReed: the instance of HasResource a can't be inferred from the type.
12:09:39 <Ainieco> so C-h gives a little
12:09:45 <Ainieco> C-h f*
12:09:58 <gregolsen> tommd: I guess your right! That makes sense, thanks!
12:10:57 <JonReed> ReinH: How can I annotate it in away that will make the compiler happy?
12:11:58 <Ainieco> asked just in case someone has ghc-mod installed and have any clue what M-C-m actually calls
12:15:17 <elkorn> hello everyone. I have a simple problem with typeclasses, illustrated here http://sprunge.us/fPPG?haskell . The problem is that in the second definition, `selectUi` expects the type `u`, while the actual type is `DummyUI` - it seems as the typeclass constraint is not taken into account. What am I doing wrong?
12:16:56 <dmj`> hmw2: http://codepen.io/djohnsonm/pen/ZQLLRB
12:16:58 <dmj`> wrong channel sorry
12:17:55 <acertain> what's the status of Rep?
12:18:02 <acertain> from https://ghc.haskell.org/trac/ghc/wiki/Roles2
12:18:39 <acertain> class Representational f where rep :: Coercion f g -> Coercion a b -> Coercion (f a) (g b)
12:30:37 * hackagebot pandoc-types 1.16 - Types for representing a structured document  https://hackage.haskell.org/package/pandoc-types-1.16 (JohnMacFarlane)
12:33:29 <hi_there> hello
12:34:31 <hi_there> I have a question
12:34:46 <dmj`> hi_there: yes, go on
12:35:37 * hackagebot pandoc-citeproc 0.9 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.9 (JohnMacFarlane)
12:36:31 <hi_there> Do you have LYAH
12:36:40 <dmj`> @lyah
12:36:41 <lambdabot> Unknown command, try @list
12:36:56 <dmj`> http://learnyouahaskell.com/
12:37:34 <hi_there> I have a question on pg 41, book seems different then the online version
12:39:17 <hi_there> Im tying to think how to ask my question
12:39:38 <dmj`> hi_there: is it about the state monad?
12:39:45 <hi_there> no
12:40:42 <hi_there> it says 'where' bindings are not shared across function bodies of different patterns. What does this mean?
12:41:24 <hi_there> Ill link it's example
12:42:48 <dmj`> hi_there: I think when it says, 'pattern' it's referring to the predicate of the gaurd
12:43:04 <dmj`> also, if you look 2 sentences above it, "The names we define in the where section of a function are only visible to that function, so we don't have to worry about them polluting the namespace of other functions"
12:44:21 <hi_there> Oh, you have the book, so in the greet code example, why wont the function work. Why must the strings be defined globaly?
12:46:02 * hackagebot haskell-generate 0.2.4 - Typesafe generation of haskell source code  https://hackage.haskell.org/package/haskell-generate-0.2.4 (BennoFuenfstueck)
12:46:50 <dmj`> hi_there: those don't need to be defined globally, I think it's saying if you wanted to share the values bound in the where clause with other functions you'd need to define them at the top-level, i.e. globally
12:47:46 <JonReed> Hmm. I'm still struggling with this type level stuff. How can I do something as simple as having a "class :: HasResource a where; createResource :: r; useResource :: r -> a", where both r are of the same type. It seems that it should be done with type families or data families.
12:47:52 <monochrom> hi_there: here is an example. line 1 "f [] = c", line 2 "f (x:xs) = c". if you now try to add "where c = 42", it can only be for either line 1 or line 2, but not both.
12:48:44 <JonReed> So far I've tried this but it fails: http://lpaste.net/148316
12:50:24 <dmj`> hi_there: does that make sense?
12:51:07 <dmj`> hi_there: if you want to use bmi, skinny, normal, fat in different functions, then you should remove them from the where block and make them global. That's what I think the author is getting at. The Strings don't need to be defined top level
12:53:01 <hi_there> but I don't get why niceGreeting and bad greeting don't work here http://lpaste.net/148321
12:55:20 <monochrom> hi_there: it is like what I said and my example.
12:56:42 <argoneus> damn
12:56:45 <argoneus> higher order functions seem cool
12:58:29 <EvanR> theyre ok
12:59:24 <hi_there> It doesn't make sense to me, why can      "where c = 42" in you example only work with line 1 or line 2, not both?
13:02:08 <monochrom> that is correct.
13:02:28 <monochrom> you should empirically observe it, then accept it (because it is empirically tested).
13:02:38 <ReinH> argoneus: confirm
13:02:41 <ReinH> they are very cool
13:02:52 <monochrom> you can form an opinion on how this is not what you like.
13:03:08 <monochrom> but your opinion is not going to change the compiler immediately
13:07:36 <Gurkenglas> Is there a language extension that changes it? If not, you can do a "case asd of" match, those allow lets/wheres across the whole of them
13:15:24 <adas> is there some defacto help for type families? the haskell wiki pretty dense
13:16:35 <hodapp> adas: go ahead and ask here
13:17:45 <adas> am trying to wrap my head around type families. I get that they are functions on types. Not sure why or how I would use them?
13:35:15 <greg`> i keep getting : Exception: Prelude.foldr1: empty list , despite not using foldr1 anywhere in my code
13:35:34 <greg`> is does foldr use foldr1 internally?
13:35:46 <greg`> or does the list monad use foldr1?
13:36:04 * hackagebot hlint 1.9.26 - Source code suggestions  https://hackage.haskell.org/package/hlint-1.9.26 (NeilMitchell)
13:36:24 <mag__> @src foldr
13:36:24 <lambdabot> foldr f z []     = z
13:36:24 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:37:21 <greg`> thanks thats useful, i think i may try to install my own personal lambdabot
13:41:57 <ReinH> fwiw, @src is hand-curated and often gives inaccurate answers for pedagogic purposes.
13:42:38 <ReinH> This is even more true since 7.10 generalized a lot of these functions
13:43:06 <greg`> really? wheres does @src source  its sources?
13:43:29 <ReinH> From a hand-curated list
13:43:37 <greg`> ah
13:44:24 <greg`> a bit like scala in that respect then
13:44:44 <ReinH> @src foldl
13:44:44 <lambdabot> foldl f z []     = z
13:44:44 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:45:20 <ReinH> when in fact it is foldl k z0 xs = foldr (\(v::a) (fn::b->b) -> oneShot (\(z::b) -> fn (k z v))) (id :: b -> b) xs z0
13:46:03 <mag__> http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Foldable.html#foldr
13:46:21 <ReinH> which requires a bit more effort to explain http://stackoverflow.com/a/6172270/2225384
13:47:52 <ReinH> That's the default for instances defined with foldMap and not foldr
13:48:04 <ReinH> The definition for lists is in GHC.List
13:48:33 <ReinH> It does make it a bit more clear what is going on in the GHC.List definition though
13:49:16 <ReinH> Namely, a list of functions representing the steps of the foldl are being folded together using function composition with id as the identity element.
13:50:02 <ReinH> oh, sorry, I meant the definition of foldl in Foldable.
13:51:27 <Nadrieril> so @src can be quite nice if we are trying to understand a function
13:51:48 <Nadrieril> since the actual source can be quite hard to understand
13:51:54 <ReinH> Yeah, it gives an exemplary definition. The real one might be changed for performance reasons, etc.
13:52:08 <adas> type classes allow different types to have common behaviour/functionality. what's a one sentence description for type families?
13:53:53 <JonReed> ReinH: I still haven't figured out what you mean by "it can't infer a type" in this example: http://lpaste.net/148316 . Is it possible to write something like this in haskell "class HasResource a where; createResource :: r; useResource :: r -> a", where I can "(useResource createResource) :: a". 
13:54:45 <Nadrieril> I think I found the list :) https://github.com/lambdabot/lambdabot/blob/master/lambdabot%2FState%2Fsource
13:56:08 <ReinH> JonReed: what happens if you change it to testResource = theResource' (createResource' :: TheResource String) ?
13:56:28 <Nadrieril> I was typing the same thing ^^
13:56:35 * hackagebot postgresql-query 2.3.0 - Sql interpolating quasiquote plus some kind of primitive ORM  using it  https://hackage.haskell.org/package/postgresql-query-2.3.0 (AlekseyUymanov)
13:56:37 * hackagebot pred-trie 0.5.0 - Predicative tries  https://hackage.haskell.org/package/pred-trie-0.5.0 (athanclark)
13:59:01 <JonReed> ReinH: It still shows the same error
14:03:02 <ReinH> JonReed: I believe the issue is that GHC can't infer that you are using the String instance of HasResource. TheResource String = Int is not enough to infer that the Int you are using is TheResource String.
14:03:14 <ReinH> You could write another instance whose TheResource type is also Int.
14:04:28 <ReinH> I believe fundeps are often used for this: something like class HasResource a r | r -> a where ... and instance HasResource String Int
14:04:29 <JonReed> ReinH: I don't understand the last part :(
14:04:54 <ReinH> You could write instance HasResource Bool where type TheResource Bool = Int
14:05:22 <Nadrieril> yes but he is asking for useresource to be of type String
14:05:42 <Nadrieril> couldnt GHC infer the HasResource String instance ?
14:05:54 <ReinH> I'm not sure, but it sure seems to not be inferring it.
14:06:07 <argoneus> forgive this ignorant question, but what is Haskell good for?
14:06:15 <ReinH> argoneus: most programming tasks.
14:06:19 <argoneus> I get it's good for paralellized computations, academic stuff in general, but I want to write something useful in it
14:06:26 <argoneus> and I can't find anything where I wouldn't prefer e.g. Python or Java
14:06:30 <ReinH> It's a general purpose language.
14:06:39 <ReinH> Do you know Haskell?
14:06:39 <Nadrieril> ReinH:  actually he is, the error says "coulnt match TheResource String with TheResource a0"
14:06:41 <argoneus> yeah but if you want to write like an IRC bot, you end up doing procedural stuff anyway
14:06:44 <argoneus> no?
14:06:51 <Nadrieril> Haskell can do that very well
14:06:52 <argoneus> you don't use the language to its full potential
14:06:55 <ReinH> argoneus: Then how can you judge whether you'd prefer it to a language you do know?
14:07:20 <ReinH> I don't see how you can make confident value judgements about something you admittedly don't understand.
14:07:43 <argoneus> if I was confident I wouldn't be asking
14:07:53 <JonReed> argoneus: A good review is here: https://github.com/Gabriel439/post-rfc/blob/master/sotu.md Add to that the fact that Haskell can compile to javascript via ghcjs and starts get good front end libraries like Reflex.
14:07:53 <ReinH> You aren't asking, though. You're telling.
14:07:54 <Nadrieril> it's not that Haskell is bad at procedural stuff
14:08:00 <argoneus> nono
14:08:03 <ReinH> And I disagree with your assessment.
14:08:04 <argoneus> I didn't imply that
14:08:23 <argoneus> I just meant that I want to try writing something cool with Haskell specific features, instead of using things I can use in Python as well
14:08:31 <argoneus> to figure out the language better
14:08:43 <Nadrieril> you can totally make a very Haskell-y IRC bot
14:09:13 <argoneus> to be fair
14:09:17 <vxri> agroneus a lot of stuff that's written "procedurally" doesn't have to / p orbably shouldn't be
14:09:21 <argoneus> so far I only read up on the basic stuff that every decent language has
14:09:31 <argoneus> like map/filter, higher order functions, list comprehension etc.
14:09:41 <argoneus> there's probably a lot I don't know yet
14:09:44 <exio4> basic stuff? like a type system that gives you basic guarantees?
14:09:44 <argoneus> I'll just keep reading
14:10:06 <vxri> agroneus are you reading LYAH? because that's not what you should be reading.
14:10:07 <exio4> or lexical scoping, for that matter. 
14:10:16 <argoneus> vxri: um, yeah
14:10:20 <Nadrieril> why not ?
14:10:24 <argoneus> I remember someone recommending it to me a few years back
14:10:54 <vxri> it's terrible
14:10:58 <Nadrieril> is it ?
14:11:11 <argoneus> vxri: have any other suggestions?
14:11:16 <ReinH> It's not terrible, but it isn't very good.
14:11:34 <vxri> pedagogicallly, it's monkey see monkey do. you come away thinking that haskell is python + some abstract monad stuff. then you sit down to write a new program and realize you're incapable of doing so.
14:11:43 <argoneus> well
14:11:47 <ReinH> It is superficial, it doesn't have exercises, and it doesn't provide any practical instruction on writing haskell programs that aren't the toy examples it uses to explain concepts.
14:11:51 <argoneus> it's no secret that Guido is a big fan of haskell
14:11:56 <argoneus> so it is similar here and there I guess?
14:12:20 <Nadrieril> I believe it's good as a first overview of the language
14:12:25 <vxri> he is? in the other channel we were concluding that he's not into FP. they're really quite different
14:12:32 <ReinH> argoneus: I can recommend https://github.com/bitemyapp/learnhaskell and there are some good books as well
14:12:52 <vxri> Nadrieril ReinH I'd argue LYAH does more harm than good. there really needs to be a better cartooner first-encounter-friendly alternative
14:12:58 <ReinH> bitemyapp is writing a very good one
14:13:05 <Nadrieril> ok
14:13:15 <vxri> the best so far (but not perfect) is haskellbook.com
14:13:21 <argoneus> alright I'll read the bite thing instead
14:13:21 <ReinH> That's the one.
14:13:24 <argoneus> oh
14:13:25 <argoneus> that one then
14:13:27 <argoneus> lel
14:13:38 <vxri> even though it's a work in progress, (sadly) it's better than everything else available
14:13:44 <argoneus> what's wrong with LYAH then?
14:13:53 <ReinH> argoneus: if you want to see some of Haskell's unique selling points in action, I also recommend http://www.amazon.com/Thinking-Functionally-Haskell-Richard-Bird/dp/1107452643
14:13:54 <argoneus> that it's a dick measuring contest "well look at this great one liner"?
14:14:05 <vxri> if you want to something faster, follow https://github.com/bitemyapp/learnhaskell and do the CIS194 spring 2013 course
14:14:10 <ReinH> "It is superficial, it doesn't have exercises, and it doesn't provide any practical instruction on writing haskell programs that aren't the toy examples it uses to explain concepts."
14:14:16 <vxri> agroneus no, it just doesn't actually teach you anything
14:14:18 <argoneus> ah, I missed that, sorry
14:14:23 <ReinH> np
14:14:39 <argoneus> I'll look at the things you guys posted and pick one then
14:14:40 <argoneus> thanks!
14:14:41 <vxri> agroneus you type stuff it says to type, it works. but if you try to write something from scratch you'll get stuck.
14:15:28 <ReinH> rote learning and practice have a place in education, but it is not this place.
14:15:28 <bitemyapp> @where book
14:15:29 <lambdabot> http://haskellbook.com/
14:15:30 <bitemyapp> argoneus: ^^
14:15:31 <vxri> that's why it's harmful imo, it's a low barrier entry path to giving up.
14:15:44 <ReinH> vxri: pretty much
14:16:27 <ReinH> Automaticization is important, but rote practice reinforces known skills. It doesn't effectively teach new ones.
14:16:46 <ReinH> *Automatization
14:17:27 <ReinH> This is also why koans are not used to introduce langauge concepts: they are used to reinforce known concepts through practice.
14:17:29 <StoneToad> talking about practice, is there a cookbook for lens somewhere?
14:17:34 <vxri> ReinH yeah, i wish someone else would make a cartoony, welcoming, 5 page tutorial that we could point beginners to as an LYAH alternative.
14:17:56 <StoneToad> clippy introduces haskell?
14:18:02 <StoneToad> sounds like something out of a nightmare...
14:18:12 <vxri> "read these lecture notes" probably filters out a substantial fraction of potential people
14:18:40 <theDon> “it looks like you're trying to write a monad instance, would you like help?“
14:18:41 <vxri> stonetoad maybe that would work if clippy wasn't already so hated
14:18:55 <vxri> haha
14:19:08 <argoneus> why do you need cartoony tutorials
14:19:15 <argoneus> C is super simple and all you get is a 800 page reference book
14:19:30 <ReinH> It looks like you're trying to use fmap. Would you like some help with that?
14:19:33 <vxri> the funny thing is, (for the newbies) there's a huge amount of static information where you _could_ make a powerful clippy
14:19:48 <vxri> if you're willing to go with a 800 page reference book, read http://haskellbook.com
14:19:51 <ReinH> GHC's compiler errors are mostly just an inscrutable clippy
14:20:16 <ReinH> It looks like you're trying to use a Double where you meant to use an Int. Would you like some help with that/
14:20:20 <argoneus> vxri: I'm still at the stage where I'm trying to find motivation :<
14:20:22 <argoneus> C is used everywhere
14:20:39 <vxri> i'm saying cartoony because that's why people go to LYAH. it's inviting for a language with a fearsome reputation
14:21:08 <argoneus> the cis194 thing seems nice
14:21:28 <argoneus> it seems to go into the more tricky stuff early on
14:21:28 <vxri> (not that haskellbook is a reference book... but if you don't mind directness without frog cartoons to handhold your way through the tutorial)
14:21:34 <argoneus> instead of explaining what the head of a list is
14:21:37 <argoneus> noice
14:22:54 <vxri> yeah you don't need that how-do-i-do-the-same-stuff-i-do-in-python crap. you need the "whys" first. (this is part of why i don't like lyah)
14:23:30 <ReinH> To be fair, explaining what a list is in Haskell is pretty important.
14:25:23 <vxri> yeah but coming from another language, it's only legible as  "oh here's some new syntax for a list, can i do some slicing and comprehensions yet?"
14:32:27 <Cale> vxri: Yeah, the thing about lists in Haskell is that they sort of take the place of loops in most imperative languages to a large extent.
14:33:03 <Cale> vxri: Just as a loop either doesn't occur, or consists of a single iteration followed by another loop, a list is either empty or consists of a single element followed by another list.
14:33:59 <Cale> vxri: Since lists can be infinite, and are lazily produced (meaning that perhaps only the memory for a single cell might be live at any given moment), this connection is actually practical.
14:34:16 <vxri> cale understood my point is that context is going to be lost on an absolute beginner.
14:34:23 <vxri> first contact and first impressions are hugely important for adoption
14:34:29 <Cale> sure, I just felt like mentioning it
14:35:15 <vxri> so i would spend that very limited attention/energy on a legible path to adoption, LYAH squanders this
14:35:54 <Cale> Yeah, it wasn't really a comment about the approach that LYAH takes (I actually have only skimmed LYAH, and not read it in detail, since I learned Haskell long before it existed)
14:36:07 <vxri> Cale I agree... C/J had an interesting analogy between recursion and folds...
14:37:02 <vxri> where was that...
14:40:20 <ianhedoesit> I'm jumping into this conversation without knowing fully what's being discussed, but I would argue that one reason one can't ignore about why people use LYAH (including myself) is because it's freely available online.
14:41:37 <Cale> yes
14:42:26 <Cale> Graham Hutton's book "Programming in Haskell" is a really good introduction from what I've seen, but it's not free.
14:42:33 <ianhedoesit> this is the same reason I've looked at Real World Haskell. Even if neither are "the best," a free resource which isn't completely useless is far more inviting to me than a $60 book. I don't really have $60 in my budget for learning a language I'm interested in, unfortunately. I also wish there was a way for the authors of books to be compensated appropriately without me having to sacrifice a couple we
14:42:39 <ianhedoesit> eks worth of food. :(
14:45:24 <greg`> can anyone tell me how to use criterion with stack?
14:46:21 <Cale> ianhedoesit: More things need to move toward pay-what-you-want sort of models, where the people with the means to pay more have the opportunity to do so, and compensate for a bunch of people who can't.
14:46:31 <greg`> from looking at a tutorial theres a step that says : ghc -O --make Fibber
14:47:15 <greg`> however im not sure whether i can do that from within a stack codebase
14:47:35 <Cale> I guess it would be similar to however you would normally build a program with stack?
14:47:51 <ianhedoesit> Cale: I still am unsure about how well that model works. Mainly because there's not really a good example to look at, yet. Humble Bundle works quite well, from what I understand, but there's a lot more to Humble Bundle than what a single author could do.
14:47:52 <Cale> I don't know stack very well, I still haven't gotten around to trying it.
14:48:32 <Cale> ianhedoesit: Well, it seems to work out reasonably well for various musicians.
14:49:13 <exio4> Cale: I think that sums it up
14:49:25 <ianhedoesit> hm, I'm not sure if it would be a similar outcome for authors, especially authors who write technical books with an audience who probably don't have much money to spare.
14:49:29 <greg`> Cale: Ive just started getting my paws dirty with stack, its really good
14:49:32 <greg`> imo
14:49:43 <Cale> greg`: I've heard lots of good things about it
14:50:28 <Cale> But at work, we're using nix for build configuration, and my personal projects tend to require nothing more than ghc --make
14:51:08 <greg`> aye: migrating is pretty easy too..... install with cabal, go into a cabal project , stack init, stack build, then to run stack exec {module-name}
14:51:20 <greg`> its really that simple ......(for simple workflows)
14:52:01 <greg`> Cale: ah - well i'll try with criterion
14:52:27 <Cale> Like, you should be able to set it up as a cabal-built executable in that case, and then just run the resulting executable
14:54:03 <argoneus> thanks ReinH 
14:54:10 <Cale> You can apparently define something to be a benchmark and use stack bench instead of stack build
14:54:14 <argoneus> in the first lesson on cis194 I already read all I read in most of LYAH
14:55:46 <greg`> argoneus: i once read that the people who find FP tricky are spending a lot of mental effort on things they neednt worry about
14:56:40 <ianhedoesit> argoneus: is that the course from UPenn?
14:56:43 <greg`> i.e. theres a thought process change that needs to take place before it feels easier.....
14:57:18 <argoneus> ianhedoesit: yes
15:01:31 <zachk> so what can I do with these Arrow things from Control.Arrow that is cool? 
15:02:32 <c_wraith> zachk: I never figured that out. :P
15:02:47 <vxri> ianhedoesit
15:02:47 <vxri>  missed the earlier discussion, but this is why i was saying someone needs to throw up a welcomingm cartoony, 5 page starter tutorial we can point to instead of LYAH
15:03:01 <c_wraith> zachk: anything you can do with Arrow, you can do with the combination of Applicative and Category
15:04:02 <c_wraith> zachk: On the other hand, ArrowLoop is sometimes useful for creating circular dependencies.
15:04:06 <zachk> so what can I do with applicative or category that is cool ? 
15:04:18 * zachk is thinking along the way of multiuser gaming server 
15:04:30 <zachk> can it simplify my code with more composability? 
15:04:36 <ianhedoesit> vxri: hm, fair enough. I do think LYAH could be improved a bit. I think it's a reasonably helpful piece of work (especially for free), but I agree that I struggled with it somewhat. I did make some more connections once I went to other resources then back to LYAH.
15:05:25 <c_wraith> zachk: if you really want to dig into Arrow and its more interesting game services, check out auto
15:05:35 <zachk> auto what? 
15:05:39 <Cale> zachk: It's not so much that these things let you do anything which you couldn't do without them
15:05:42 <c_wraith> zachk: http://blog.jle.im/entry/introducing-the-auto-library
15:06:05 <Cale> zachk: They're structures which inevitably show up in your code if you program in a functional style, and if you recognise them, then you can save yourself a bit of work.
15:06:19 <lambda-11235> zachk: Arrow is used to raise to create data structures that act like functions. Netwire uses this for its FRP in the form of Wire.
15:06:57 <Cale> Arrow unfortunately undermines a lot of things which *almost* fit the interface by including arr and not including a bunch of other stuff which you'd normally rather have in place of arr
15:07:18 <Cale> (or alongside it at least)
15:07:31 <Nadrieril> like ?
15:07:57 <Cale> A major difference between Arrow-like interfaces vs. Monad-like interfaces to libraries is that with (>>=), the right hand argument is a black-box function.
15:08:15 <Cale> The definition of (>>=) can't possibly take advantage of which function it is to simplify the computation to be done
15:08:34 <Cale> Whereas both arguments to (>>>) are values of a datatype you have control over
15:08:34 <merijn> Nadrieril: The biggest problem is that you must be able to lift ANY function into an Arrow which frequently you don't want to preserve nice abstractions
15:08:46 <Cale> and so the definition of (>>>) might be able to do something clever
15:09:14 <Cale> However, arr means that you must be able to make any black-box function into a computation in your Arrow
15:09:22 <Nadrieril> oh ok
15:09:47 <Cale> and that screws with the ability to do this simplification -- which might not be so bad if there were only a few occurrences of arr, however...
15:10:00 <Cale> Arrow relies very heavily on arr to provide structural wirings
15:10:05 <merijn> Nadrieril: In practice arrow seems to have almost completely fallen out of favour with only some libraries using it
15:10:08 <Cale> like, reassociating or swapping pairs
15:10:09 <c_wraith> Cale: I recently discovered that behavior is really mandated by Functor.
15:10:16 <mgsloan> Cale: You might be interested in Stack's nix integration: http://docs.haskellstack.org/en/stable/nix_integration.html
15:10:43 <exio4> @type \f -> fmap f . Control.Category.id
15:10:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:10:44 <merijn> Nadrieril: The combination of Applicative + Category seems to subsume a lot use cases. And I think Profunctor is now also stealing ground from Arrow
15:10:58 <Nadrieril> indeed
15:11:00 <exio4> @type \f -> fmap f Control.Category.id
15:11:01 <lambdabot> (Functor (cat a), Category cat) => (a -> b) -> cat a b
15:11:12 <Cale> When I was working on Blood Knight, we ended up replacing the Arrow hierarchy for our arrowy proprietary FRP system 
15:11:24 <Nadrieril> "proprietary" ^^
15:11:30 <Cale> and added in a bunch of things inspired by the definition of symmetric monoidal categories
15:12:19 <zachk> whats Blood Knight?
15:12:23 <Cale> e.g. assocR :: (Arrow a) => a ((s,t),u) (s,(t,u)), and  swap :: (Arrow a) => a (s,t) (t,s)
15:12:47 <Cale> It was an action RPG which sadly didn't get released, but we got quite a long way with, and learned a lot
15:13:00 <zachk> was it a commercial venture? 
15:13:04 <Cale> Yeah
15:13:10 <Nadrieril> oh too bad :(
15:14:10 <Cale> It had pretty fun combat, and a big (but still pretty lonely) open world you could run around in and which would be dynamically loaded, and it performed reasonably well on desktop hardware (but was maybe still a bit too slow on some of the phones we originally wanted to target)
15:14:47 <Cale> But it still lacked a lot of the RPG elements and some of the game mechanics we wanted to have
15:15:01 <Cale> (and well, there was a lot of content still to make)
15:15:58 <Cale> It convinced *me* at least that it'll eventually be really nice to write games in Haskell, but currently it takes quite a lot of work carving a path through the jungle :)
15:16:17 <Nadrieril> what happens in those cases ? do you just store the code somewhere and keep it there ?
15:16:21 <Cale> Once we had the FRP system off the ground, it worked really well for defining AIs and the like
15:16:46 <Nadrieril> or are you planning another game based on the same work ?
15:17:13 <Cale> Well, I don't know if we'll ever actually get back to it, but a lot of the things we learned about FRP got incorporated into Reflex
15:17:42 <Cale> and several years later, I'm working for the same guy again (Ryan Trinkle), and doing web applications for clients using that.
15:17:42 <Nadrieril> that's cool
15:18:26 <JonReed> ReinH: Thx for help! Your advice really helped in the end. FTR, I've arrived at this: http://lpaste.net/148323 which uses functional dependencies. It needed both "r -> a" and "r -> a" for compiler to be happy with  inferring  types. 
15:18:40 <Nadrieril> are you a to-hire Haskell programmer of some sort ?
15:18:45 <Cale> yeah
15:18:48 <Nadrieril> noice
15:20:22 <Cale> I might do a much much simpler (turn based strategy) game with a web frontend using reflex-dom at some point in the near-ish future
15:20:36 <merijn> JonReed: Note that the current design means you can't have both "HasResource String Int" and "HasResource String Bool" or "HasResource Char Int"
15:20:56 <merijn> Cale: open source or closed?
15:21:03 <Cale> I'd probably make it open source
15:21:12 <Cale> I don't really need additional income from it
15:21:36 <merijn> Cool, I'd be curious to see how it fits together :)
15:21:36 <exio4> you could maybe add a pay-what-you-want option 
15:21:42 <Cale> exio4: haha, true
15:22:16 <Jinxit> Cale: I'm not very well versed in FRP, but I know AI, how did it help the AI?
15:22:44 <Cale> Jinxit: It's just a much nicer way to manage lots of state that changes over time
15:23:06 <Cale> Jinxit: A lot of the bugs that you can get in game code have to do with making updates incorrectly
15:23:18 <Jinxit> yeah okay that makes sense
15:23:24 <Cale> e.g. getting them in the wrong order, accidentally losing an update
15:23:54 <JonReed> merijn: Oh of course... I thought I finally figured it out. This sucks :(
15:24:08 <merijn> JonReed: You might want an associted type + proxy parameters
15:24:10 <Cale> and FRP forces all your definitions to specify all the things which could affect some value that's changing over time in one place, which takes some getting used to, but eliminates huge swathes of bugs
15:24:35 <merijn> JonReed: Although then you could still only have one type of resource for a certain type
15:24:37 <Cale> and ends up being quite expressive at the same time
15:24:57 <merijn> JonReed: Actually, just doing proxy parameters should be enough
15:26:42 <JonReed> merijn: I don't quite undestand how it would look in the end. 
15:26:53 <merijn> JonReed: Like this: http://lpaste.net/148323
15:27:13 <Cale> Jinxit: It's also "nice" in that you can move a lot of the work of optimising the code into optimising the FRP system, though I put nice in scare quotes there because while there's a huge surface area for implementing optimisations, it quickly becomes a lot of work.
15:27:25 <merijn> JonReed: The problem you're having is that not all functions refer to every type parameter of the typeclass, so GHC can't infer which instance you mean
15:27:48 <merijn> JonReed: By adding a dummy proxy parameter that refers to the "missing" type, you get GHC to go "ooh! that one"
15:28:08 <Cale> Jinxit: (it's very similar in nature to optimising compilers)
15:28:25 <merijn> JonReed: The lowercase proxy is just so that you're not forced to actually use "Proxy String" in situations where you happen to have a "Maybe String" lying around
15:30:31 <Cale> These days though, I think I could reasonably safely recommend trying out Reflex if you were really gung-ho about trying out FRP for a game, and that would save you a lot of effort -- Spider, the main implementation of Reflex, might not do everything which could be done, but it's doing a lot to be efficient already, and it would take quite a lot of work to get there again.
15:31:21 <JonReed> merijn: I think I get it now. Thx!
15:31:23 <vektor> What's FRP about anyways? Heard it quite often, but I've not got a clue. Can anyone give me a TL;DR?
15:31:23 <Cale> (and if it manages to be fast enough once compiled to Javascript by GHCJS, I can only imagine how efficient it must be when compiled to native code ;P)
15:32:23 <Cale> vektor: FRP is about specifying the way that things change over time in a more declarative way, and in particular, it comes along with some concepts about the sorts of ways that things can "change over time"
15:32:23 <StoneToad> vektor: functional reactive programing
15:32:46 <StoneToad> Cale: thx for the link for reflex
15:32:55 <Cale> There are two major conceptual types that FRP systems try to provide in some fashion:
15:33:29 <Cale> There are behaviours, which are things that always have a value whenever you care to look at them, and that value might vary continuously
15:33:55 <montanonic> vektor, lookup Elm and try out a few of their tutorials. That will give you a very quick and hands on example.
15:33:55 <Cale> Things like, the position of the mouse, the number of hitpoints that a monster has, the location of the player in the world, what ought to be drawn on the screen...
15:34:08 <Cale> Basically "the current X" for various X
15:34:30 <Cale> and then there are events, which are things that occur at specific points in time, and only have a value at those times
15:35:22 <Cale> things like the sequence of mouse clicks or key presses, or the sequence of attacks made by a monster, or the sequence of requests to make to a web service, or the sequence of responses coming back, or the sequence of sound clips to play...
15:35:25 <montanonic> Are there any examples of using Servant with websockets?
15:35:58 <Cale> and FRP systems will generally provide lots of ways to take existing behaviours and events and combine them to form new behaviours and events
15:36:03 <montanonic> I'm building a social-network prototype app using PureScript+Halogen, and I'm trying to implement a chat system using a Persistent backend.
15:36:05 <lambda-11235> vektor: This may be a bad description, but it allows you to use the tools you learned from Functors, Monads, etc. on time varying, stateful values.
15:36:37 <Cale> Well... yeah, I mean, these things often fit into those classes
15:36:44 <Cale> but that's really not the important thing
15:36:57 <Cale> I mean, Behavior and Event are Functors, usually.
15:37:10 <Cale> But the fact that they're instances of Functor is not *terribly* important.
15:37:20 <Cale> You certainly want that operation though.
15:37:38 <vektor> Cale: Thanks a lot. That sounds really cool. I'll look into it before I'm building something more dynamic next time.
15:38:04 <vektor> Right now, I'm just building a boring batch-computation style CLI app
15:38:30 <Cale> vektor: Unfortunately the documentation for Reflex is a bit sparse still, and learning it will probably require lots of human interaction with existing users.
15:39:01 <Cale> But the library itself is coming along nicely enough to be used in real live projects.
15:39:24 <Cale> (our company is using it for paid work anyway)
15:40:31 <vektor> On the topic of that, I just had the realization that if you could abstractly represent problem solving as a process, you might be able to do some machine learning magic on that kind of dataset.
15:41:29 <vektor> Read: We define a grammar or data type that represents the thought process of problem solving. Then we fill several of those data blobs with data gathered/written by people. Then, we'll see if machine learning can help.
15:43:15 <vektor> That's essentially a 5h old shower thought right now. I'm debating whether a specific directed graph for that problem is a good solution.
15:43:18 <Cale> I don't know much about machine learning, but the general approach of representing a space of problems with a data structure in such a way that the solutions to the problems can be encoded as a structural recursive function on the descriptions is the bread and butter of the functional programming style.
15:44:16 <Cale> and often you'll be able to build multiple "interpreters" or "solutions" on the back of the same "problem descriptions"
15:44:43 <Cale> there's a really nice talk by SPJ about this approach
15:45:04 <Cale> http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/
15:46:06 <vektor> My jumping-off point was Sequent Calculus: You either do some operation on your "problem" - those are of course more complex than simple SC steps. Or you split your problem up into several smaller problems.
15:46:49 <vektor> What you end up with is a bunch of independent solutions to the child problems you extracted, so you need to recombine them, and do so in the order you splitted them.
15:46:54 <Cale> I think it's probably a bit much to expect machine learning to handle too general a space of problems at this point.
15:47:48 <vektor> Sure thing. But for example if you have concrete, structured descriptions of the requirement of a function, et cetera... maybe you can pull off a program that implements a specification.
15:48:02 <Cale> Oh, and yeah, that exists
15:48:11 <vektor> i.e. a program that has learned to turn simple specs into programs.
15:48:24 <Cale> You don't even totally need machine learning
15:48:27 <vektor> Well, sure does. But never been done from that direction.
15:48:32 <Cale> Agda for example
15:48:46 <vektor> And I could see there being points where you can expand.
15:48:52 <Cale> You can write the type of your function, and then mash a key and often get Agda-mode to write your function definition for you
15:49:02 <Cale> Or at least the majority of it
15:49:24 <Cale> Idris has something similar I think
15:50:13 <Cale> This is something really nice about dependent types
15:50:45 <vektor> There's something for haskell. SOmeone linked me to it.
15:50:48 <vektor> Djinn or so?
15:50:49 <Cale> That pattern matching often unifies enough things that there's only one possible implementation in a given branch of the code and it can systematically be constructed
15:51:24 <bergey> https://github.com/imeckler/mote
15:51:25 <Cale> Oh, yeah, djinn operates on a subset of Haskell that corresponds to a solvable logic.
15:51:39 <Cale> That's somewhat similar, but far more restricted
15:51:39 <bergey> Readme says: "Mote brings the development style found in Agda to Haskell"
15:52:17 <Cale> and yeah, you can try to do some automatic case analysis and stuff for Haskell, but it doesn't work as well without the dependent matching
15:52:54 <Cale> Like, there's less information about what must be produced in each branch because the types of things in Haskell say a little bit less about what the function must be.
15:53:34 <Cale> In Haskell, you can always swap the branches of an if-expression without causing a type error.
15:53:41 <Cale> In Agda that is not true :)
15:53:47 <vektor> what?
15:53:50 <vektor> Whyy?
15:54:02 <Cale> Why what?
15:54:02 <vektor> Even if you negade the condition?
15:54:14 <vektor> Why would that result in a type err?
15:54:21 <Cale> I mean, if the expression  if foo then bar else quux  typechecks
15:54:30 <Cale> then   if foo then quux else bar  will also typecheck
15:54:45 <Cale> But in a dependently typed setting, that's no longer the case
15:55:01 <Cale> The type of the thing in each branch might depend on the result of the boolean condition
15:55:10 <vektor> I've got FP theory research to do it seems :D
15:55:14 <geekosaur> yep
15:55:44 <geekosaur> dependent types are "fun" that way, that's one reason haskell has not had them added and work to support them is proceeding cautiously
15:56:30 <geekosaur> btw exference might also be worth looking at, as an "upgraded djinn"
15:56:37 <geekosaur> https://github.com/lspitzner/exference also see exferenceBot that is often in here
15:56:40 <zachk> isn't one of the maine reasons for not adding dependent types to Haskell proper, is that type inference for dependent types is undecideable? 
15:57:07 <c_wraith> That's part of it
15:57:08 <geekosaur> yes
15:57:11 <c_wraith> But not the sole reason
15:58:09 <vektor> c_wraith: \forall I know, undecidability has never stopped practical implementation from happening anyways, no?
15:58:55 <c_wraith> I think the biggest factor is that when Haskell was being designed, it was clear it could be made efficient.  It wasn't yet clear that dependent types could be made efficient.
15:59:00 <zachk> whats the other reasons for not adding dep types to haskell then? 
15:59:28 <zachk> I looked at linear types the other day, no garbage collector needed, idris has unique types non, kind of linear types 
16:02:14 <mac10688> So I created a datatype and give it an instance of functor in it's own module. In a separate module for unit testing I give it an instance of Arbitrary. The compiler warns me of orphan instances, but is this still bad? Now my main module would need to take on an instance of quickCheck.
16:02:42 <mac10688> It seems odd to take on a dependency in my main source file for something that is only used for testing and not actual business logic
16:03:14 <vektor> If you need Arbitrary only for testing, an orphan would seem right to me... What does the class do though?
16:03:15 <Cale> zachk: It's also not so easy just to fit dependent types in now in a way which both looks really nice and is simultaneously backward compatible.
16:03:18 <c_wraith> mac10688: orphan instances for Arbitrary that are defined and used in the same place aren't a bit deal.
16:03:31 <c_wraith> err, *big* deal
16:03:54 <mac10688> thanks c_wraith that's what I figured too.
16:03:56 <geekosaur> mac10688, an orphan is really only a problem in a library. a test suite wouldn't infect unsuspecting code with it
16:04:01 <Cale> Dependent types aren't really just a feature you can just *add*, they really fundamentally affect how the language works.
16:04:22 <zachk> what about Linear types? 
16:04:22 <Cale> It's also very unclear at present how dependent types interact with lazy evaluation
16:04:34 <mac10688> I will see if there's a way to suppress these warnings for these specific instances
16:04:38 <geekosaur> you could always {-# OPTIONS_GHC -fno-warn-orphans #-} in that source
16:04:46 <Cale> Well, I don't know about linear types, but Clean has a nice story for uniqueness types at least.
16:04:47 <geekosaur> I think that's the option
16:04:56 <vektor> Are instances from imports exported too?
16:04:56 <Cale> So if you're interested in that, you might have a look at Clean.
16:05:06 <vektor> So would my module export the instances defined in Prelude?
16:05:10 <zachk> is Clean faster then ghc's code? 
16:05:19 <geekosaur> vektor, yes
16:05:28 <mac10688> thanks geekosaur, I will put that at the top of my unit testing file
16:05:31 <vektor> geekosaur: Yikes
16:05:40 <Cale> At one point it was competitive, and would sometimes get performance improvements over GHC. I'm not sure whether or not that is still the case.
16:06:04 <geekosaur> yep, that's the option, just doublechecking
16:06:08 <Cale> It might be in some instances, where the uniqueness typing opens up an optimisation which is very effective and which GHC misses.
16:06:11 <ianhedoesit> Cale: if you don't mind me asking, what sort of background do you have? Did you have much formal education? Where did you learn Haskell?
16:06:43 <Cale> I have a BMath in pure mathematics, and studied Haskell mostly in my spare time starting around 2001-2002
16:07:02 <ianhedoesit> Hm, okay. So you have quite a lot of experience with Haskell at this point.
16:07:06 <Cale> and have been programming in Haskell professionally for a lot of that time
16:07:08 <Cale> yeah
16:07:27 <mac10688> Cale, I imagine you were one of those kids studying Calculus as a freshman in high school
16:07:53 <mac10688> I may be slow, but I'll get there
16:07:56 <Cale> mac10688: I think I was in grade 11 when I started on Calculus, but yeah, kinda.
16:08:03 <Cale> I learned trig when I was in grade 4
16:08:17 <mac10688> I should give up now ;)
16:08:19 <Cale> But I was crap at multiplication tables
16:08:22 <Cale> lol
16:08:35 <ianhedoesit> Cale: do you do much work in languages other than Haskell?
16:08:57 <vektor> Cale: crap at multiplication tables here too.
16:08:58 <Cale> ianhedoesit: Not a lot, I know a lot of other languages, but I don't have much reason to use them.
16:09:37 <exio4> why not? don't you have any reason to write your programs in Coq?
16:10:05 <Cale> Oh, I've played around with Coq a bunch recently, and explored HoTT with it
16:10:18 <ianhedoesit> Cale: I only ask because I wonder if you end up programming in a more functional (or, ideally, Haskell) style in other languages.
16:10:29 <Cale> But I don't know if I think of that as writing programs as much as I think of it as writing formal proofs :)
16:10:38 <Cale> (obviously these two activities are pretty similar)
16:10:55 <vektor> Had a math teacher grill me when she was returning a 8th-grade test to the class - said she'd have to do an oral re-examination on me. "What's 4 * 9?" "Uhhhm, 36" "Yep, Vektor. Not 28. That's your only mistake though." One of those stories I always tend to remember.
16:11:04 <Cale> ianhedoesit: I would... but more often I'd just be frustrated at my inability to express things the way I wanted to.
16:12:21 <exio4> vektor: at least it wasn't 4 + 6 = 16 ...
16:12:49 <ianhedoesit> Cale: hm, okay. Thank you. I'm interested in how realistic it is when people talk about how learning functional languages will make one better at writing imperative code.
16:13:13 <Cale> It definitely teaches you what to watch out for
16:13:26 <Cale> and makes you way more cautious
16:13:40 <hiptobecubic> I'd agree with that
16:13:40 <Cale> because you realise all these things which the compiler is *not* going to do for you
16:14:02 <ianhedoesit> I agree.
16:14:18 <vektor> exio4: hahaha, I guess. Somehow my brain still gets short-circuited when I encounter 4*9. I tend to think it's 28 for a blink of an eye. Probably because I somehow link it to 18 as a multiple of 9, then think it must have an 8 as last digit, and I fill in the 2 in front because it's a multiple of 4 that way. Weird how the brain works on such simple things.
16:14:19 <zachk> C/java kinda looks like assembly after a bit of functional programming 
16:14:39 <Nadrieril> x)
16:14:43 <zachk> square times a square 
16:14:44 <Cale> It teaches you how to express your programs in a way which involves less mutation, and then when you are forced to use the extra mutation, it feels bad, and you pay close attention to what's going on.
16:14:52 <vektor> zachk: Don't remind me. I have to write a lot of java for uni.
16:15:06 <ianhedoesit> zachk: but, ideally, one should be able to learn more about functional programming (it is just a style, after all) and apply it to C/Java/whatever to make "better" programs.
16:15:31 <zachk> sometimes the functional approach, isn't really optimized for in those languages and they can run alot slower if you use that style
16:15:48 <exio4> it makes your programming style much more concise 
16:15:49 <Cale> Also, it has made what is really essential about OO design a lot clearer to me
16:15:56 <zachk> I used to write a bit of Java for uni with my own map function and stuff and had to use like 4 lines of code for 3 tokesn from haskell 
16:15:57 <Cale> At least, in my opinion, haha
16:16:05 <zachk> now it has real lambda's or so I have heard 
16:16:17 <vektor> zachk: It's weird.
16:16:25 <vektor> All the languages are picking up FP features.
16:16:33 <zachk> OO did not make full sense to me until I coded up my own really simple object system with mutable state using closures in Scheme 
16:16:34 <Nadrieril> still no TCO in java though
16:16:34 <Cale> You can do (at least what I consider) the essence of OO design perfectly well in Haskell, or in any language which is able to have records of first class functions.
16:16:37 <vektor> But what the hell? Why would I want half the cake if I can have all of it.
16:16:44 <Cale> yes
16:16:54 <zachk> lambdas are lovely and so are mapping over data structures 
16:16:59 <vektor> FP only makes sense if you go all the way WRT features. Immutability in Java? Hah!
16:17:05 <Cale> It's even a little more clarifying when you have the types there.
16:17:12 <exio4> vektor: 4*9 = (2*2)*9 = 2*(2*9) = 2*18 = 2*(10+8) = 2*10 + 2*8 = 20 + 8 + 8 = 20 + 16 = 36 <- this is how I do it
16:17:25 <Nadrieril> much easier indeed
16:17:46 <Nadrieril> :p
16:17:49 <ianhedoesit> vektor: Immutability in Java is relatively simple (although it is a bit of upfront work) - look at Clojure, for example.
16:17:50 <Cale> Because it makes you realise what the big mistake of almost every typed OO language is: they tie the implementations of the methods to the types of the objects and thus require subtyping to recover implementation polymorphism.
16:18:00 <c_wraith> I feel like languages lacking higher-kinded polymorphism are too restrictive.  If I can't write traverse, I have to work too hard. :)
16:18:05 <vektor> exio4: Yeah, that's probably better than my... more association-based approach. Though it is really fast for the most common cases.
16:18:10 <zachk> is there a unix that doesn't break horribly on updates, especially for dev work? I have tried arch, ubuntu, they both broke bad, and now freebsd seems half broken 
16:18:22 <Nadrieril> nixOS ?
16:18:33 <vektor> Another thing I recently missed a LOT in Java are ad-hoc tuples. It doesn't even sport normal tuples-
16:18:42 <Cale> and then subtyping ruins type inference, and makes the language horrible to use
16:18:45 <exio4> Cale: sadly, it'd be so much better without that misfeature
16:19:34 <vektor> zachk: How'd you break arch? I use it a lot. Works for me.
16:19:37 <Cale> and then people get it into their head that type systems are bad, and throw the baby out with the bathwater and program in Python
16:21:12 <hodapp> Cale: that's pretty much where I got my start...
16:22:05 <pikajude> is HaXml still maintained? would it be wise to make my library depend on HaXml?
16:22:31 <vektor> I mean... In Java, my problem recently was "alright, I need to store each object I'm attaching a listener to along with the listener I'm attaching so I can remove the listener on cleanup." (Don't ask about the API) - Easy enough, store some kind of Container with Tuples of (Obj, Listener) and dispose them later... Nope, no tuple. Alright, two Containers it is. Nope, Listeners have different...
16:22:33 <vektor> ...incompatible types. Oh, and the Objects I'm attaching to too. It got messy really fast from there.
16:22:46 <Cale> wow, HaXml... I haven't heard anything about that library in years, but I dunno -- check the Hackage upload date
16:23:13 <pikajude> jan 2015
16:23:18 <pikajude> is there any other comprehensive XML library that's more recent?
16:23:20 <ianhedoesit> on the topic of subtyping vs parametric polymorphism, SPJ goes into it a bit in these lectures: https://www.youtube.com/watch?v=6COvD8oynmI&list=PLs-L6w88OnEZzTtynMEEThz4LZY2HDP7g
16:23:21 <vektor> pikajude: Seems like Cale is saying "it's probably not"... at least to me.
16:23:32 <Cale> vektor: If I didn't know better, I would guess that Java was explicitly constructed as a strawman argument against type systems
16:23:44 <vektor> Cale: Hahahahaha
16:23:51 <vektor> Cale: What about c++?
16:23:53 <Cale> pikajude: Uh, Jan 2015 is actually a lot more recent than I would have guessed
16:23:54 <ianhedoesit> I thought they were pretty interesting and useful lectures for some of us who know programming but want to understand more about Haskell.
16:24:07 <Cale> pikajude: The chances are good that someone is making sure that it compiles
16:24:19 <exio4> Cale: :/ that's my experience "why do you dismiss type systems?" to my OOP TA, his argument were around the verbosity issue, and the "they're too restricting" (his examples would be solved with some forall a. and high order functions), a bit sad :( 
16:24:46 <Cale> vektor: C++ is just a nightmare
16:25:34 <vektor> Cale: I'm conflicted. Its type system is funny and template errors are truly a nightmare. But I find it less horrible than Java actually. STL is a bright light in a dark spot imo.
16:26:28 <hiptobecubic> I don't know. I wouldn't call it a nightmare
16:26:30 <vxri> vektor cale since C++11 it's gotten much better
16:26:36 <exio4> I actually found it to be "nicer" than what I thought it would be
16:26:37 <hiptobecubic> Well perhaps you might have nightmares about it
16:26:54 <Cale> @quote Cale child
16:26:54 <lambdabot> Cale says: One can create powerful abstractions in C++ in much the same way that a woman can produce a child. It's possible, and people do it, but it takes hours of labour and is extremely painful.
16:26:55 <vxri> almost pleasant if you use a subset of C++ and if it wasn't for the slow build times
16:27:15 <vxri> i miss the repl interaction though
16:27:36 <exio4> it feels like a functional programming language compared to Python, to me :p
16:27:41 <vektor> vxri: Oh yeah. A repl for c++ would be cool.
16:27:45 <vxri> but RAII, never use new, range based for, ...
16:28:00 <vxri> and eric neibler's ranges library looks sick from an FP perspective
16:28:07 <vektor> Cale: Well... I guess you have a point.
16:28:21 <hiptobecubic> C++ is getting better in part because it's adopting functional ideas 
16:28:22 <vxri> he and bartosz have been bromancing on that shit for a few years now
16:29:05 <vxri> exio4 yeah FP is much more feasible in c++ than python. there's also FTL and Atria which try to import haskell-isms wholesale, haven't tried myself though
16:29:36 <vxri> python i'm like .. can i just pipe one function into another without nested parentheses so i can pretend like i'm composing? nope
16:29:49 <vxri> vektor there are some but they're all clunky
16:30:08 <vektor> Also, is there any real solution to the diamond of death problem?
16:30:37 <vxri> vektor ROOT is the old one. there's some lightweight llvm one that i've forgotten (cint I think)then there's CLING which is the modern solution
16:31:10 <Cale> vektor: I would say to a large extent, the solution is "goodbye subtyping"
16:31:14 <vxri> vektor CLING  aims to replace ROOT. but it's still clunky. like what kind of repl lets you segfault out. apparently that's par for the course
16:31:58 <vxri> then there's CLASP which sounds awesome on paper
16:32:04 <Cale> But the remainder of cases it's just a real issue you have to think hard about in a domain-specific way
16:32:17 <vxri> lisp-based C++ repl
16:32:18 <exio4> vxri: well, unsafeCoerce# 34# in GHCi does segfault
16:32:37 <vxri> https://github.com/drmeister/clasp
16:32:39 <geekosaur> all safeties are off as soon as you invoke unsafeCoerce# though
16:32:39 <vektor> Cale: Come to think of it, you could probably aggregate instead, right? I think if you're making the implied "this" parameter explicit and aggregate instead of inherit, it becomes quite clear what to do...
16:32:56 <exio4> geekosaur: unsafeCoerce is safer, indeed! :p 
16:32:57 <vxri> but i'm afraid CLASP is so marginal it will disappear into academic vaporware so I'm not ready to invest in it
16:33:25 <vektor> Cale: That's probably a thought I got from FP. At least, in a epic case of treppenwitz I come up with this solution now, having had the problem years ago before starting haskell.
16:33:41 <vxri> exio4 I think with CLING anytime your program segfaults it segfaults the repl, but i'm not 100% positive. it's been a while since i tinkered with it.
16:34:24 <vxri> exio4 I spent a few hours setting it up, was like cool hello world works, but anything more complex feels hairy
16:34:48 <exio4> vxri: does it work with C++11/C++14? how does it work?
16:35:00 <Cale> vektor: Well... the situation is this, you have some types A, B, C, and you have specified inclusions b: A -> B and c: A -> C, and you want some type D with maps l: B -> D and r: C -> D such that for any x in A, l (b x) = r (c x)
16:35:17 <vxri> exio4 yeah in fact modern c++ is what makes it practical it all
16:35:32 <zachk> you can segfault out of ghci, with unsafe operations :D 
16:35:52 <zachk> I had ghci 6.6 on openBSD segfault on me using bigInts 
16:36:11 <vxri> exio4 if you like the idea you should just give it a try https://root.cern.ch/cling it's got reasonably good backing considering CERN and a big chunk of physics research is relying on its success
16:36:30 <Cale> vektor: If you didn't have this A, or if A is the empty type so that the equation is vacuous, then this problem is solved by Either
16:36:52 <Cale> with l = Left and r = Right
16:37:04 <vxri> exio4 there are some hacky things behind the scenes to make it work, don't expect ghci (or even python) level elegance
16:37:22 <Cale> Well, you want a universal such D :)
16:38:22 <vxri> exio4 btw if you like that, there's also some efforts to develop hot swap C++ workflows which look awesome in demos but are again clunky in practice
16:38:25 <Cale> i.e. for any other type D' and maps l': B -> D' and r': C -> D', you want there to be a unique map D -> D' making some equations happen
16:38:34 <vektor> Cale: I'm thinking of it in terms of data containers and functions: Each class, A, B, C, D have a data container *_d and functions *_f. B_f will take A_d and B_d as implicit parameters. Whenever I'm calling functions D_f, I can pass the same A_d into the all the functions *_f that result from that call, and I'm golden. I have faked diamond inheritance by not inheriting.
16:38:53 <vektor> Cale: Is what I just typed even remotely comprehensible?
16:39:20 <Cale> vektor: I think you're thinking about the opposite diamond from me
16:39:22 <Cale> but yeah
16:39:37 <Cale> If you turn all my arrows around, then Either becomes (,)
16:39:40 <vektor> D inherits from B and C, which in turn inherit from A.
16:40:07 <vektor> The problem being that in conventional c++ I now have two data instances of A on which I'm operating.
16:40:11 <Cale> and you don't really want (,), but you want some type which is like (,) but identifies the things in B and C which came from the same thing in A
16:40:14 <exio4> vxri: looks awfully cool 
16:40:48 <Cale> rather, it's restricted to things which came from the same thing in A :)
16:41:13 <Cale> You can think of it as the set of solutions to an equation
16:41:22 <Cale> (in the most general sense)
16:41:31 <vektor> No. I can't. You're about to go over my head :D
16:41:44 <vektor> I do appreciate the effort though :D
16:42:17 <Cale> Well, okay, so suppose we have these types B and C, and we have some maps B -> A and C -> A
16:42:21 <agocorona> talking about c++, haskell need better support for mutable structures that make good use of CPU caches. Long running haskell code produce a lot of cache faults. Try to run Leksah for a while, for example
16:42:39 <Cale> i.e. we have ways to generalise structures of types B and C to structures of type A
16:42:45 <vektor> I remember in c++ the go-to solution for Diamond of Death in gamedev was to not inherit at all and use component systems instead.
16:42:51 <Cale> B and C might be subtypes of A
16:43:07 <Cale> and these maps are then what happens when we up-cast
16:43:13 <Cale> yeah?
16:43:54 <Cale> So the challenge is to produce a type D, and maps D -> B and D -> C which are somehow compatible with the existing B -> A and C -> A, that's the diamond
16:44:37 <Cale> If A is a one-element type (i.e. () in Haskell), so that our maps B -> A and C -> A discard all information
16:44:50 <Cale> Then our universal solution to this problem will be the pair type
16:45:05 <Cale> (B,C)
16:45:22 <zachk> the diagram commutes QED it's a Monad, j/k 
16:45:23 <Cale> and there are maps (B,C) -> B and (B,C) -> C indeed, which are fst and snd
16:45:43 <Cale> not a monad, it's different categorical thing, a product
16:46:01 <Cale> But what we really want, when A is not trivial, is not a product, but a pushout
16:46:02 <zachk> isn't it like a product and a coproduct? 
16:46:12 <zachk> oh 
16:46:25 <Cale> er, pullback, sorry
16:46:34 <zachk> is that a coproduct? 
16:46:36 <Cale> (pushout was the other case, with the arrows the other way)
16:46:54 <Cale> yeah, a coproduct is a special case of a pushout and a product is a special case of a pullback
16:47:09 * hackagebot haskellscrabble 1.3.2 - A scrabble library capturing the core game logic of scrabble.  https://hackage.haskell.org/package/haskellscrabble-1.3.2 (happy0)
16:47:54 <sm> \o/
16:48:07 <vektor> Cale: I'm getting the trivial case. That seems doable.
16:48:20 <vektor> Beyond that, my lack of FP and type theory starts to show.
16:48:32 <Cale> So, we have maps b: B -> A and c: C -> A, and we want a type D with maps pi_B: D -> B and pi_C: D -> C, such that for every x in D, we have b (pi_B x) = c (pi_C x)
16:49:16 <Cale> So, the "obvious" thing to do, is to take pairs (u,v) with u in B and v in C such that b u = c v
16:49:33 <agocorona> I miss a channel for software engineering with haskell, that has little in common with Haskell for computer science
16:49:34 <Cale> i.e. restrict the pair type to only those pairs satisfying this equation
16:49:57 <Cale> agocorona: there is ##cs, but it is very very low traffic
16:50:11 <agocorona> Cale thanks
16:50:16 <Cale> agocorona: and there's #haskell-blah, but it's very much not just about CS
16:50:21 <Cale> (it's just random discussion)
16:50:33 <agocorona> I know the latter
16:50:34 <vektor> Cale: I think he wants to talk about coding without us talking about type theory :D
16:50:44 <Welkin> ah yes, agocorona knows it quite well
16:50:51 <Welkin> he used to troll us quite often
16:50:58 <vektor> what'd be the type of u and v?
16:51:11 <Cale> vektor: u is of type B, and v is of type C
16:51:36 <Cale> so we're only picking the compatible pairs of things in B and C which are sent to the same thing in A
16:51:59 <Cale> i.e. "once you up-cast, you can no longer tell the difference"
16:52:09 <Cale> But that's hard to do in an automatic way
16:52:20 <Welkin> wektor
16:52:25 <Cale> especially with typical object types which have lots of crazy functions
16:52:46 <vektor> Welkin: You talkin to me? *taxi driver*
16:53:36 <drewbert> Let's say I have a generic representation of an object.  I'm using aeson to encode that to json.  I want to conditionally add extra properties to the aeson object based on the contents.  Is the only way to do this using toPairs, fromPairs?
16:53:43 <Cale> vektor: So category theory frustratingly tells us exactly what problem we want to solve, but it moreso just makes it clear that the problem is difficult to solve than gives us an answer here.
16:53:49 <drewbert> Or rather pairs/object, I should say.
16:54:21 <Cale> drewbert: If you use Maybe, the derived instance should work
16:54:53 <drewbert> Cale: say it's a type in a third-party library and a derived Generic instance.
16:55:38 <Cale> drewbert: ah, okay, well, when you're constructing an aeson Value, you can just use pattern matching or an if-expression or something to decide which Value to produce.
16:55:49 <vektor> Hmm... the core problem I was trying to solve in c++ back in the days isn't really a theoretically hard problem. If you define that c++ must use only one object of the common ancestor types, my problem would be solved (though others would pop up)
16:56:19 <Cale> drewbert: and then in the other direction, you can use <|> when writing your parser
16:56:26 <drewbert> Cale: is there a way I can using the generic construction, but add my own markup?
16:56:35 <Cale> drewbert: assuming you're writing the encode/decode manually
16:56:47 <Cale> well, the generic construction should already do *something*
16:56:48 <drewbert> s/using/use/
16:57:00 <exio4> drewbert: can you give an example? 
16:57:16 <Cale> I'm not 100% sure what that something will be, but it should be able to account for all values of the type.
16:57:31 <vektor> The problem being: I have entities in a game world. They each implement some basic sets of functions, and there's a lot of extensions upon those basic functions: Entities that implement specific behaviors and add functionality and data.
16:57:32 <Cale> (and this is usually all you care about, if you're using aeson for everything)
16:58:09 <Cale> vektor: See, this sounds a lot like a setting where I would want to only use one type.
16:58:18 <vektor> Again, the c++ approach is to use a component system, which would roughly equate to having Maybe dataforatomicbehavior fields in your entities.
16:58:22 <zachk> can't you do that inheritance problem in haskell with a product type/record of Maybe (a1,a2...) and have something somewhat like an component system? 
16:58:40 <Cale> vektor: and then just have different *values* of that one type, but C++ is getting in the way by forcing us to tie our method implementations to the types of our objects
16:58:52 <vektor> zachk: More like (Maybe a1, Maybe a2, ...)
16:58:59 <drewbert> So I've got a back-end graph structure.  The nodes can have arbitrary properties. The properties have ByteString values and strings describing the type of value. Some of these properties will have a known types and therefor known decoding, others won't.  I want to conditionally add a decodedValue property.
16:59:12 <Cale> zachk: uh, the *real* inheritance problem is tricky in both directions
16:59:25 <vektor> Cale: But how would you abstract functionality with that Tuple of Maybes.
16:59:27 <vektor> ?
16:59:33 <Cale> zachk: you can turn it into runtime tests for equality in some cases, but that's not really the same thing
16:59:56 <zachk> is there an Xwindows channel on freenode? 
17:00:18 <Cale> Like, you could use Maybe (A,B) and a "smart constructor"  A -> B -> Maybe (A,B) which gave Nothing in the cases where the equation failed
17:00:35 <zachk> so with depdendent types the maybe over product type could be done at compile time? 
17:00:41 <Cale> yes!
17:00:54 <Cale> With dependent types, you can force the programmer to prove the equation holds
17:01:40 <Cale> and then in a real-world setting, the proof would often be too difficult to carry out within time constraints, but hey, at least in principle it's a solution
17:01:48 <agocorona> dependent typing is ortogonal to functional programming. Some people do not decouple both things
17:02:16 <Cale> We're not really talking about functional programming here so much as programming as a whole.
17:02:47 <agocorona> yep, it is just a general remark
17:03:21 <Cale> However, I think if you have Pi types (which is basically dependent typing), you kinda have potential for functional programming already
17:03:22 <agocorona> or a general consideration
17:03:35 <Cale> Maybe you can have Sigma types only
17:03:37 <Cale> hah
17:03:49 <Cale> But that's not so great, you really are going to want Pi types.
17:04:14 <Cale> Right?
17:05:12 <Cale> I don't even know how far it's possible to get without having any Pi types in your system. It seems like it would often be hard to really make use of Sigma types properly without the corresponding Pi. You can't even write the type of the second projection.
17:05:27 <Cale> It would kinda suck.
17:06:10 <Cale> and if you have Pi types, then you have function types as a special case, so hey, first class functions.
17:07:11 <zachk> pi is product/conjuction and sigma is sum/disjunction, correct? 
17:07:47 <Cale> Yeah, if you have a function P: A -> Type, then Pi (x:A), P(x) is the type of functions which accept an argument x of type A, and produce a result of type P(x)
17:08:15 <Cale> and Sigma (x:A), P(x) is the type of pairs (x,p) where x has type A, and p has type P(x).
17:09:11 <Cale> So if P is a constant function, say, P(x) = B for all x, then the Pi type reduces to the same thing as A -> B
17:09:27 <Cale> and the Sigma type reduces to the same thing as (A,B)
17:10:50 <Cale> So, if you want to write the corresponding first and second projection from a Sigma type, you might have
17:11:11 <Cale> fst :: (Sigma (x:A), P(x)) -> A, which is fine
17:11:16 <Cale> and then
17:12:22 <Cale> snd :: Pi (s: Sigma (x:A), P(x)) -> P(fst s)
17:12:26 <Cale> er, oops
17:12:27 <Cale> syntax
17:12:31 <Cale> snd :: Pi (s: Sigma (x:A), P(x)), P(fst s)
17:12:51 <Cale> I'm trying to be consistent about it, there are a lot of notations people use for this stuff :)
17:15:54 <Cale> So if we have our "base" type A, and our two specialisations B and C, and functions b: B -> A, and c: C -> A, which do the "up-casting"
17:16:50 <Cale> then the solution to the diamond problem is  Sigma ((x,y): (B,C)), b x = c y, and now I need to explain how equality works :)
17:17:25 * hackagebot language-thrift 0.6.1.0 - Parser and pretty printer for the Thrift IDL format.  https://hackage.haskell.org/package/language-thrift-0.6.1.0 (abhinav)
17:17:26 <Cale> For any type A, and any x, y: A, we have a type Id A x y which has a single data constructor refl : A x x
17:17:32 <exio4> with enough dependent types... 
17:17:50 <Cale> er, yeah, I should probably be more careful about the quantifiers on refl :)
17:18:25 <Cale> oops, also I missed the Id somehow :)
17:18:31 <Cale> It's really refl: Pi (A: Type), Pi (x:A), Id A x x
17:19:32 <Cale> and so in order to witness the fact that b x = c y, we might need to produce some recursive definition which depends on the definitions of b and c somehow and shows that the results really are the same
17:20:05 <Cale> (by pattern matching on x and y most likely, and letting evaluation take place)
17:20:36 <Cale> So, I should be clear, b x = c y is notation for Id A (b x) (c y)
17:21:12 <Cale> But for function types, it tends to be really really hard to get equality proofs
17:21:26 <Cale> HoTT makes the situation a little less dire
17:21:42 <Cale> But even with univalence, it's an uphill battle
17:21:54 <zachk> why is functional extensionality so difficult? 
17:22:07 <Cale> Because it's not true in some models :)
17:22:23 <Cale> It's possible to care about the difference between lambdas which implement the "same" functions
17:22:38 <Cale> because e.g. maybe they perform very differently
17:22:43 <zachk> ? oh
17:23:05 <zachk> can't you do fun ext piece by piece in my most proof/type theory, er function by function 
17:23:21 <Cale> A function which iterates the Collatz map on a natural number until it hits 1, might be equal to the constant map which produces 1
17:23:37 <Cale> Well, that's one which would be hard to prove in any case :)
17:23:53 <zachk> the collatz still isn't proved is it? 
17:24:05 <Cale> But let's say, even a function which just subtracts 1 iteratively until it hits 0, vs. the constant 0 map
17:24:08 <Cale> right
17:24:39 <Cale> These two functions accomplish the same thing, and so are equal by function extensionality, but the amount of time they take to compute will be different.
17:25:18 <zachk> if you had fun ext in general, couldn't the compiler just substitute in the constant map for that other function? 
17:25:21 <Cale> and so we *may* care about that, and our model of the language might distinguish them somehow -- in particular, a compiler for the language is not required to produce the same code for both
17:25:54 <Cale> Yeah, but how does the compiler automatically know that for all natural numbers, this function is equal to the constant 0 function? That requires proof.
17:26:16 <Cale> and while the proof for any individual natural number is trivial (requires only computation)
17:26:29 <Cale> the proof for all natural numbers can't be done through simple computation
17:26:45 <Cale> (it would take an infinite amount of time to do all the reductions)
17:26:45 <zachk> or like the collatz example, you could have something that proves something is less then 3 based on fermat's last theorem, would be kinda difficult to tackle with todays proof systems wouldn't it? 
17:26:50 <Cale> we need induction/recursion
17:27:14 <zachk> but you have to have provable termination, otherwise you can get False/Bottom, correct? 
17:27:21 <Cale> and while proof search is a thing, it's not an easy thing which we can just wait for
17:27:27 <Cale> in general
17:28:21 <Cale> Even if so, there's not necessarily a canonical form for functions up to function extensionality
17:28:33 <Cale> I suppose that's another way of looking at it
17:29:05 <Cale> So while in this case, we might hope that our magically clever compiler would be able to decide that the constant function is the best way to express this one
17:29:30 <Cale> In general, there isn't a unique canonical way to express a given function on an infinite domain like that
17:29:40 <A_B_C> a
17:29:44 <Cale> You can't just enumerate all the cases
17:30:08 <Cale> (because there are infinitely many, and so the resulting source code would be too large :)
17:31:09 <Cale> You can wish for one with the Axiom of Choice, but that doesn't make it computable :)
17:31:47 <zachk> isn't there a constructive limited axiom of choice 
17:32:24 <Cale> There's something which looks a bit like the axiom of choice, but which is an easily proved tautology
17:32:48 <Cale> and which doesn't have any of the original character of the axiom of choice, because you have to put in the decisions in the first place really
17:36:51 <Cale> i.e. you can write a function of type  Pi (A, B: Type), Pi (R: A -> B -> Type), (Pi (x:A), Sigma (y:B), R(x,y)) -> (Sigma (f: A -> B), Pi (x:A), R(x,f x))
17:37:40 <Cale> i.e. for any types A and B, and any binary relation R on A and B (expressed here as producing a Type for each pair which may or may not be inhabited)
17:37:57 <Cale> then if for every x in A, we have there is a y in B such that R(x,y)
17:38:03 <meoblast001> how do i get (- 1) as a function like (+ 1)?
17:38:15 <Cale> then there is a function f: A -> B such that for every x in A, we have R(x,f x), i.e. a choice function
17:38:56 <Cale> But once you look at how this is proved in MLTT or Coq or something, you see why it's a bit of a ruse -- the choices are really coming in as part of the precondition
17:39:07 <Cale> meoblast001: (\x -> x - 1)
17:39:13 <Cale> meoblast001: or (subtract 1)
17:39:13 <meoblast001> ;-;
17:39:15 <meoblast001> okay
17:39:25 <Cale> meoblast001: (- 1) means negative one of course
17:39:33 <meoblast001> yeah
17:40:07 <Cale> It's a bit of a concession of uniformity in the syntax to make it possible to write numbers and polynomials in a sensible way
17:40:36 <Cale> Like, it's nice to be able to write -x^2 + x - 1 or something.
17:41:32 <meoblast001> so subtract does what i want but i don't understand how
17:41:44 <meoblast001> let g = subtract 5 in g 7
17:41:49 <meoblast001> how is this 2 and not -2?
17:41:58 <meoblast001> shouldn't "subtract 5" fill the first parameter?
17:44:09 <ahihi> subtract a b = b - a
17:44:26 <pavonia> Read it as "subtract 5 [from] 7"
17:44:57 <ahihi> it exists specifically for the case of partially applying to the second parameter, which is cumbersome to write in terms of (-)
17:45:00 <has_been> hey guys
17:45:15 <ahihi> (5 -) is no problem though
17:45:24 <has_been> im running into a problem while trying to cabal install haskell-src-exts
17:45:36 <has_been> the installation is never finishing
17:46:02 <parsnip> should i remove the other pandoc before `stack build` in git cloned pandoc? 
17:46:16 <has_been> $ cabal install haskell-src-extsResolving dependencies... Configuring haskell-src-exts-1.17.1... Building haskell-src-exts-1.17.1...
17:46:29 <parsnip> i'm getting bunch of lines like: 
17:46:30 <parsnip> Warning: File listed in pandoc.cabal file does not exist: data/templates/default.html
17:46:31 <has_been> it stays at the "Building haskell-src-exts-1.17.1..."
17:46:39 <has_been> its been 17 minutes
17:47:41 <has_been> anyone knows why?
17:47:57 <mgsloan> parsnip: No, you don't need to remove the other pandoc.  "stack build" installs it locally so that it's availabe from "stack exec -- pandoc".  Use "stack install" if you want to put it in ~/.local/bin
17:48:39 <mgsloan> parsnip: The Warning just means that pandoc has some files listed in "extra-source-files" or "extra-data-files" which don't exist.  This will cause issues with "stack sdist" / "stack upload"
17:49:34 <parsnip> mgsloan: "why" :)
17:49:46 <parsnip> i mean, why did they list them, and why are they not there? 
17:50:49 <mgsloan> They listed them so that the would be put into the tarball that gets uploaded to hackage.  This can be used for files needed while compiling or running, or simply as documentation
17:51:10 <mgsloan> Based on the path "data/templates/default.html", in this case the files are likely needed by pandoc at runtime
17:52:02 <mgsloan> I've taken a look at the pandoc repo, and the templates folder is a submodule.  This explains why they are missing for you
17:52:15 <has_been> pls guys
17:52:43 <parsnip> mgsloan: ah, so maybe as an exercise i should see if i can add them? 
17:53:24 <mgsloan> When cloning a repo with submodules, you can do "git clone --recursive".  If you've already got one, I think "git submodule update --init" will do it, or maybe just "git submodule init" followed by "git submodule update"
17:53:41 <zachk> 17 minutes on build? somtimes It can take awhile on an older machine 
17:54:22 <mgsloan> Yeah, haskell-src-exts has a lot of derived instances for large ADTs and also takes a lot of memory while building.
17:54:23 <parsnip> mgsloan: thanks! 
17:54:33 <mgsloan> Welcome!
17:55:27 <parsnip> yeah, my laptop got kinda hot while building (stack build) in pandoc, for about 10 mins. though, it was showing what it was doing and regularly moving to the next step. 
17:58:51 <parsnip> nice, `M-x magit-status RET o C-u u` did it. :)
18:15:51 <xplat> is there a way to force a class to get derived with GeneralizedNewtypeDeriving when it would be derivable without?
18:17:56 <zachk> StandAloneDeriving? GenericDeriving or something 
18:18:28 <xplat> anyway, right now i'm getting this weird message
18:19:11 <xplat> Can't make a derived instance of ‘Traversable (MonMap k)’ (even with cunning newtype deriving): You need DeriveTraversable to derive an instance for this class In the stand-alone deriving instance for ‘Traversable (MonMap k)’
18:19:35 <xplat> MonMap is a newtype i made around Data.Map.Map to give it the Monoid instance it should have had in the first place
18:20:05 <xplat> if i use DeriveTraversable i'm not sure the instance will actually be correct
18:20:16 <xplat> maybe it will
18:20:28 <geekosaur> -ddump-deriv?
18:23:26 <zachk> have you added in Generics yet? usually it automagically works with them 
19:03:32 * Cale signs up to go to the Compose conference :)
19:04:09 <Cale> Hey, who was it that I talked to about the logo SVG having issues?
19:05:09 <Cale> Oh, mightybyte
19:06:02 <Cale> @tell mightybyte there are a bunch of instances of the Compose conference logo on the site (but not the one on the main page) which still render poorly for me (maybe referring to the old SVG file before you converted it to paths)
19:06:03 <lambdabot> Consider it noted.
19:06:32 <Cale> @tell mightybyte the one at the top of http://www.composeconference.org/2016/ in particular
19:06:32 <lambdabot> Consider it noted.
19:12:33 <luigy> @Cale https://cloudup.com/cCAIHjEcXwR how does it render for you?
19:12:33 <lambdabot> Unknown command, try @list
19:12:51 <Cale> like, not that :D
19:12:57 <Cale> It's in a different typeface altogether
19:12:58 <luigy> xD
19:13:00 <Cale> and cut off
19:13:53 <Cale> http://i.imgur.com/BxVA7B8.png
19:14:53 <Nadrieril> I have much smaller "o"s
19:15:03 <Cale> It's likely because the SVG specifies a typeface which I don't have
19:15:22 <Cale> or for which font selection otherwise doesn't work out
19:15:41 <Cale> rather than just providing the contours, like the SVG on the main page does
19:15:51 <Cale> (This came up before)
19:18:09 <MarcelineVQ> mine's like's cale's (little o) but properly aligned
19:18:26 <Jinxit> http://i.imgur.com/IfvQ9ua.png
19:18:54 <Nadrieril> ^ I have the same
19:19:38 <Nadrieril> also, if I resize the window, there is a white rectangle from the menu which crops the svg
19:20:05 <Nadrieril> that could explain at least the "cut off" part, Cale
19:21:52 <Cale> Nadrieril: It doesn't seem to change much for me what width my browser window is.
19:22:05 <Cale> in fact, http://www.composeconference.org/assets/img/compose_conference.svg looks about the same
19:22:26 <Cale> while http://www.composeconference.org/assets/img/logo-no-text.svg looks correct
19:22:52 <Nadrieril> indeed, to me too
20:14:13 <texasmynsted> Does anybody have experience with uninstalling haskell and re-installing on mac?  I am not sure how I installed originally but likely it was a minimal install described on www.haskell.org.  I want to now switch to macports...
20:15:00 <geekosaur> if it was the platform installer then it should have an uninstall-hs script somewhere under /Library/Haskell
20:15:25 <geekosaur> if it was the bindist tarball... people have been asking for an uninstaller for that for years :/ 
20:15:55 * texasmynsted searches for an un-installer
20:16:59 <lamda_sage> Can a seasoned haskeller give me a recommendation on an easy to use http(s) client lib?
20:17:12 <dmj`> servant-client
20:17:16 <dmj`> @package servant-client
20:17:17 <lambdabot> http://hackage.haskell.org/package/servant-client
20:17:50 <texasmynsted> looks like it is all based on ghc, I see no un-installer.
20:19:25 <lamda_sage> thanks
20:19:54 <dmj`> lamda_sage: it's easy to use imo
20:23:51 <lamda_sage> dmj`: Love it, deriving functions from the api is very cool. Thanks!
20:26:54 <texasmynsted> I guess I must have used the bindist tarball
20:27:05 <texasmynsted> grrrrrreat
21:35:20 <ReinH> lamda_sage: I'm a big fan of wreq
21:41:27 <wedens> texasmynsted: stack may save you some pain
21:41:49 <wedens> in the future ;)
21:42:43 <geekosaur> well, just not installing in the default path would have saved that pain. (personally I think the bindist should default to $HOME/.ghc instead of /usr/local)
21:43:00 <geekosaur> well, subdir of that
21:43:28 <geekosaur> $HOME/.ghc/ghcs/ and then you can just nuke the version subdir to uninstall
21:43:52 <geekosaur> default /ur/local with no uninstall mechanism is a recipe for pain
21:45:37 <wedens> (haskell platform contains uninstaller IIRC)
21:45:52 <geekosaur> yes, this is about the bindist
21:46:39 <geekosaur> and iirc the HP uninstaller is not always so good about cleaning up after non-HP installs
21:47:40 <geekosaur> (although maybe that's a recollection of someone having it nuke a homebrew installed ghc...)
21:48:57 <ReinH> texasmynsted: I don't think people use macports as much as homebrew fwiw
21:52:33 * hackagebot pandoc 1.16 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-1.16 (JohnMacFarlane)
21:52:34 <geekosaur> any more, anyone using homebrew is using macports by proxy --- macports commits show up in brew very shortly thereafter, often enough to make one wonder how active brew would be otherwise
21:56:40 <rcyr> Doesn't matter. Unless macports has binaries, it's shit.
23:22:35 * hackagebot yst 0.5.1 - Builds a static website from templates and data in YAML or  CSV files.  https://hackage.haskell.org/package/yst-0.5.1 (JohnMacFarlane)
23:37:41 <kopasetik> "I haven’t yet seen a loop that can’t be decomposed into a combination of map, filter, reduce." - @dustingetz
23:37:43 <kopasetik> Agree?
23:38:55 <KaneTW> not sure
23:43:58 <slava> any loop can be implemented as foldr 
23:53:12 <Gurkenglas> That sounds like the kind of theorem that's trivial to derive in exactly the sets of axioms/definitions where it applies.
23:57:20 <lambda-11235> How would you write a list range function with those three combinators?
23:57:36 <KaneTW> what do you mean by list range?
23:57:49 <KaneTW> [1..100]?
23:57:56 <lambda-11235> Yeah
