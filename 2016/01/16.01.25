00:00:39 <ThatTreeOverTher> it's late, talk to y'all later
00:07:42 * hackagebot binary-orphans 0.1.4.0 - Orphan instances for binary  https://hackage.haskell.org/package/binary-orphans-0.1.4.0 (phadej)
00:07:42 * hackagebot github 0.14.0 - Access to the GitHub API, v3.  https://hackage.haskell.org/package/github-0.14.0 (phadej)
00:22:36 * hackagebot inline-r 0.8.0.1 - Seamlessly call R from Haskell and vice versa. No FFI required.  https://hackage.haskell.org/package/inline-r-0.8.0.1 (MathieuBoespflug)
00:34:51 <Guest00000> i want to express that p is a pair: (f X, f Y -> Z), where f is SOME type which is Functor (unknown to the caller of p). i don't want to define additional datatypes. is it not possible?
00:36:01 <EvanR> Guest00000: sure
00:36:26 <Guest00000> EvanR: isn't?
00:36:43 <EvanR> oh caller of p
00:36:54 <EvanR> p is a pair, not a function so now im confused
00:37:48 <Guest00000> EvanR: i could add a parameter...   so p :: T -> (f X, f Y -> Z) -- for some f which is unknown but it is known that Functor f
00:37:50 <liste> p :: Functor f => (f a, f b -> c) ?
00:38:46 <Guest00000> so, i want something like type holes but
00:38:59 <Fylwind> I'm not sure you can conjure a (f a, f b -> Z) out of thin air for an arbitrary Functor
00:39:12 <cocreature> what is the caller of a datatype supposed to be?
00:40:05 <Guest00000> liste: your type says that caller can pick any f. i need a different thing - to tell caller that it can't pick any, but f is still Functor
00:40:28 <Fylwind> so … existential?
00:40:42 <cocreature> that or rankntypes, I still don’t completely understand the question
00:40:55 <EvanR> Guest00000: RankNTypes comes into this somehow
00:41:29 <Guest00000> Fylwind: also i don't want to define a new datatype just for my function
00:41:38 <Fylwind> cocreature: I think Guest00000 wants something like: exists f . (Functor f, (f X, f Y -> Z))
00:41:48 <Fylwind> (in loose terms)
00:42:00 <Guest00000> probably
00:42:43 <Fylwind> Try something like: p :: forall c . (forall f . Functor f => (f X, f Y -> Z) -> c) -> c
00:43:42 <EvanR> Guest00000: if you provide more details of the problem it might help avoid an XY problem
00:43:43 <Fylwind> It's the "continuation-passing" analog of an existential
00:44:07 <cocreature> it’s just a rankntype
00:45:08 <EvanR> Guest00000: if you want to provide a fmap-like thing, and a f Y -> Z thing, you can use a record with two function members and hide the details in a closure
00:45:58 <EvanR> the question about a function that is a pair doesnt make any sense though
00:50:50 <Guest00000> Fylwind: that's a clever thing
00:50:51 <Guest00000> thanks
00:51:01 <jle`> Guest00000: Fylwind's solution should be the literal implementation of what you want
00:51:15 <Guest00000> yes, it seems
00:52:18 <jle`> @let pp :: (forall f. Functor f => (f Int, f Bool -> String) -> c) -> c; pp f = f (Just 4, maybe "nothing" show)
00:52:21 <lambdabot>  Defined.
00:53:01 <jle`> > pp $ \(fx, fy2x) -> fy2x (even <$> fx) :: String
00:53:03 <lambdabot>  "True"
00:53:53 <jle`> you can treat the \(fx, fy2x) -> as "pattern matching" on your tuple, with the caveat that the only thing you can do with the fx and fy2x are things you can do polymorphically for all Functors
01:07:29 <Guest00000> so, can we simulate existentials with just continuations?
01:07:39 <Guest00000> fully?
01:09:48 <Unhammer> in (xml-)conduit, how do I connect two conduits sequentially, so one starts processing once the other is done, while using manyYield?
01:11:46 <Unhammer> e.g. I have <outer><inner1>…<inner2>…</outer>, and parseInner1 :: ConduitM Event o (ResourceT IO) (Maybe Inner1), similarly for inner2, and want to manyYield (parseInner1 somecombinator parseInner2)
01:22:23 <Athas> Huh, why isn't Double an instance of Bounded?
01:22:38 * hackagebot werewolf 0.3.4.0 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.3.4.0 (hjwylde)
01:23:03 <EvanR> Athas: what would be the bound?
01:23:13 <Athas> EvanR: The minimum and maximum numbers.
01:23:19 <EvanR> Infinity?
01:23:29 <Athas> For example.
01:23:38 <EvanR> eh...
01:23:43 <EvanR> choose your favorite bound?
01:23:57 <EvanR> also, NaN messes up lots of ordering laws
01:24:08 <Athas> But they are still instances of Ord.
01:24:13 <EvanR> yep
01:24:24 <EvanR> gotta have those <
01:24:35 <EvanR> also its Enum which makes no sense
01:24:57 <liste> > ((0/0) > 0, (0/0) < 0)
01:24:58 <lambdabot>  (False,False)
01:25:05 <Athas> Wow, the Enum instance is really weird.
01:25:08 <Athas> Not at all what I would expect.
01:25:20 <EvanR> i would expect no Enum
01:25:44 <Athas> Sure, but if you really wanted one, I'd expect it to be low-level.
01:25:58 <EvanR> subnormal incrementation!
01:26:03 <Athas> Yes!
01:26:05 <EvanR> useful
01:26:29 <Athas> Sometimes, yes.  Most languages make it weirdly hard to do low-level operations on floats.
01:26:37 <Athas> At least Haskell has decodeFloat, although it is a little awkward.
01:27:13 <EvanR> if typeclasses should have laws, Double and Float aren't great candidates
01:27:31 <EvanR> if typeclasses are convenience arithmetic hacks then 
01:27:40 <EvanR> you have the current situation 
01:27:59 <Athas> I'm okay with type classes as an elaborate operator overloading mechanism.
01:29:08 <EvanR> > ((0/0) <= (1/0)
01:29:09 <lambdabot>  <hint>:1:16:
01:29:10 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
01:29:13 <EvanR> > ((0/0) <= (1/0))
01:29:15 <lambdabot>  False
01:29:40 <EvanR> Infinity clearly breaks a candidate for a maxBound law
01:32:03 <m4tt3> :?
01:33:08 <liste> if the laws are formulated that for all x, "not (x > maxBound) and not (x < minBound)", then would NaNs be viable candidates?
01:33:25 <EvanR> lol
01:33:34 <liste> the Report just says that they are "the upper and lower limits of a type"
01:35:12 <EvanR> i wonder if that would make reasoning about boundedness easier
01:35:22 <EvanR> i meant to say insaner
01:36:09 <EvanR> liste: how do you reformulate the (nonexistent) Ord laws to work for floats?
01:39:28 <liste> no idea, I guess that's impossible ?
01:42:39 * hackagebot cabal-rpm 0.9.9 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-0.9.9 (JensPetersen)
01:45:43 <f-a> on linux, when you make a sandbox, a .cabal-sandbox is created. What happens on windows?
01:47:45 <f-a> (am on linux and can't verify this now)
01:48:38 <BernhardPosselt> i find it interesting how OOP architecture also evolves into something functional like, aka services (functions) and simple data objects. did you experience any downside of not being able to subclass stuff?
01:49:08 <BernhardPosselt> is it possible to sublcass records btw?
01:49:28 <BernhardPosselt> e.g. customer record could be a super type of shopcustomer
01:49:33 <EvanR> if subclassing is supposed to implement different implementations of the same interface, you can do that with records of functions
01:49:46 <EvanR> if subclassing is suppose to implement importing of commonly used code, there are modules
01:50:19 <chrisbarrett> Java-style subclassing conflates code reuse with ad-hoc polymorphism
01:50:40 <chrisbarrett> for code reuse, functions and modules are just fine ;)
01:51:09 <BernhardPosselt> chrisbarrett: thats why there is the composition over inheritance rule right?
01:51:15 <chrisbarrett> for polymorphism, Haskell has typeclasses, but usually the aforementioned record-with-functions is fine
01:51:56 <EvanR> record-with-functions is more flexible than typeclasses, which are better for other things
01:52:30 <chrisbarrett> I can't speak for the original reasons for that, but I guess composition-over-inheritance is all about avoiding painting yourself into a corner with brittle class heirarchies
01:52:54 <EvanR> BernhardPosselt: to make record types which can be "promoted" to a less granular form, theres no built in support for that
01:52:56 <chrisbarrett> plus making larger OO systems actually possible to reason about
01:53:46 <EvanR> BernhardPosselt: but if thats what you know youre trying to do, its possible to do directly... and generally for lots of record types you might need to use TH to generate them all from a schema
01:57:58 <Athas> > (-1) `shiftL` (-1)
01:57:59 <lambdabot>  Terminated
01:58:04 <Athas> Seriously?
01:58:34 <Athas> It segfaults my ghci here as well.
01:58:36 <EvanR> > (-1) `shiftL` (-1)
01:58:37 <lambdabot>  Terminated
01:58:49 <Athas> I mean, I know it "must be non-negative", but that is quite a tantrum!
01:59:04 <EvanR> one does not simply (-1) `shiftL` (-1)
02:00:22 <EvanR> that sounds like a vulnerability waiting to be exploited
02:00:35 <merijn> Wow...
02:00:40 <merijn> It segfaults ghci
02:00:48 <merijn> Might wanna file a bug report :p
02:00:52 <Athas> I'm curious how a bit-shift can even segfault.  Maybe it creates a negative size for an Integer?
02:01:07 <Athas> > (-1::Int) `shiftL` (-1)
02:01:09 <lambdabot>  -9223372036854775808
02:02:18 <merijn> Athas: oh, nice catch
02:03:06 <EvanR> it segfaults after compilation
02:03:12 <EvanR> (for Integer)
02:03:56 <EvanR> x `unsafeShiftL` i = x `shiftL` i
02:04:18 <Athas> Should I report this, or would someone who has a better idea of how to obtain more information take over?  I don't have much GHC hacking experience (and sadly little time to gain it).
02:04:56 <merijn> Athas: I would just file a ticket
02:05:05 <merijn> At the very least it shouldn't segfault
02:05:11 <EvanR> theres a bug report already
02:05:19 <EvanR> https://ghc.haskell.org/trac/ghc/ticket/10571
02:05:33 <merijn> ah
02:06:35 <EvanR> looks like it was fixed
02:07:20 <jle`> https://git.haskell.org/ghc.git/commitdiff/ea4df12f7f3fc4d1d2af335804b8ec893f45550c
02:07:22 <jle`> neat
02:07:39 * hackagebot cassava-conduit 0.3.0 - Conduit interface for cassava package  https://hackage.haskell.org/package/cassava-conduit-0.3.0 (domdere)
02:07:48 <EvanR> i have 7.10.2 though
02:08:04 <Athas> Alright, good.
02:09:22 <coconut> what is the IO version of zipWith?
02:09:30 <Athas> coconut: zipWithM
02:09:35 <coconut> great
02:09:36 <coconut> thx
02:09:44 <EvanR> :t zipWithM
02:09:45 <lambdabot> Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
02:11:57 <Guest00000> what sense does it make for <$> to be infixl?
02:12:28 <merijn> Guest00000: infixl is the default, I think? Why would you need infixr, though?
02:12:35 <Guest00000> in expression ((a <$> b) <$> c), the left <$> is monomorphic in functor
02:13:22 <jle`> well, from what i can tell, f <$> (g <$> x) should give the same results as (f <$> g) <$> x
02:13:34 <Guest00000> that is, <$> is Reader fmap
02:13:36 <jle`> assuming the functor is lawful
02:13:49 <jle`> (this is literally a functor law, heh)
02:14:34 <merijn> jle`: No, because the two aren't equivalent
02:15:07 <merijn> jle`: "f <$> (g <$> x)" == "f . g <$> x" whereas "(f <$> g) <$> x" fmaps a functor over 'x'
02:15:35 <merijn> Actually, I guess it must be the same, because th first <$> must be "."
02:15:36 <jle`> but (f <$> g) can only be an (a -> b) in that case
02:15:48 <jle`> because of :t fmap => fmap :: (a -> b) -> f a -> f b
02:15:59 <merijn> Guest00000: Ok, so we're back to my initial "I don't understand why you would ever need that?" question
02:16:10 <merijn> Since you can simply replace the first <$> with .
02:16:17 <jle`> which might lead to a very cute but misleading way of stating the second functor law
02:16:27 <jle`> f <$> (g <$> x) == (f <$> g) <$> x
02:16:29 <jle`> hehe
02:16:46 <quchen> Uuuuh.
02:16:53 <quchen> Creepy.
02:18:45 <merijn> quchen: You misspelled cute :)
02:20:35 <Guest00000> ah
02:20:41 <fractalsea> Does anyone know what this exception means in QuickCheck: “*** Failed! Exception: 'no default generator' (after 2 tests):
02:20:41 <fractalsea> Exception thrown while printing test case: 'no default generator’”? Or at least how to start investigating it
02:20:42 <Guest00000> i had an error in code
02:21:49 <Guest00000> and thought for a second that this law doesn't always hold
02:23:32 <fractalsea> Nevermind, it was because I left out “deriving” from “instance Arbitrary X”
02:24:00 <Guest00000> but still, maybe infixr <$> would be nicer for learning?
02:24:30 <EvanR> f <$> x <*> y <*> z might suffer
02:25:06 <EvanR> also (f . g . h) <$> x is more idiomatic i think
02:25:17 <EvanR> (or fmap)
02:30:50 <merijn> EvanR: Don't need parenthesis
02:30:59 <merijn> . has higher precedence than <$>
02:31:03 <EvanR> oh nice
02:31:06 <merijn> So just "f . g . h <$> x"
02:31:32 <EvanR> somehow that doesnt look right ;)
02:31:43 <merijn> I write code like that a lot...
02:31:50 <merijn> It's one of the main reasons I use <$>
02:32:02 <merijn> Looks identical to "f . g . h $ x" but with effects
02:35:18 <tdammers> merijn: it breaks sometimes when you mix <$> and $
02:35:56 <merijn> tdammers: Yes
02:36:02 <merijn> But I don't generally do that
02:36:10 <EvanR> heh <$> classified as effects
02:36:15 <jophish> Does anyone know if a nice "deriving Storable" package exists, I've not been able to find a Generic/TemplateHaskell based package for this.
02:36:44 <jophish> but whenever I write a storable instance it just feels boilerplatey
02:36:51 <EvanR> if you dont care how its serialized
02:37:07 <EvanR> then what about using Binary
02:37:38 <EvanR> which can be generated
02:37:45 <jophish> oh, of course
02:38:05 <merijn> Storable isn't for serialisation anyway
02:38:14 <merijn> It's for mutable access
02:39:14 <jophish> I've been using it for passing things to C
02:39:22 <jophish> (nothing complicated, just records of ints)
02:40:39 <merijn> jophish: You could try using c2hsc
02:40:45 <merijn> (not to be confused with c2hs)
02:40:56 <merijn> jophish: It generates boilerplate from C headers
02:41:09 <jophish> ah, here's the kicker. I don't actually have a header
02:41:14 <jophish> just the object file
02:41:27 <jophish> it's a C interface generated from the terra language
02:41:31 <merijn> jophish: Then I don't think you can avoid boilerplate?
02:41:53 <jophish> probably not :/
02:42:44 <jophish> sorry for that rather roundabout questioning. I know how annoying it can be when people don't ask the "real question" first :)
02:44:08 <aleator> I've got a problem. I need to make a remote GUI for a camera control system. The client-pc has to be windows and I've already got nice Haskell bindings for controlling the cameras. Any recommendations on how to proceed?
02:49:45 <Guest25092> Anyone here who use NN for mIRC? and knows how to make it auto join a channel ?
02:50:26 <jle`> you just need to tune your backpropagation
02:50:50 <liste> Guest25092: try ##mirc
02:57:08 <zd234> is there any reason to use hungarian notation in haskell, when instead, one can just use ":: " to tag with the actual type ?
02:57:42 <MasseR> No
02:57:49 <liste> people sometimes prefix record fields with record name to avoid clashes
02:58:03 <liste> I don't like that though
02:58:21 <MasseR> liste: ghc 8 :)
02:58:42 <liste> yeah, I'm looking forward to it (:
03:00:12 <EvanR> zd234: better use a type hole or :t to ask what the type is
03:01:05 <zd234> EvanR: I think you misunderstood my question. I know type. I'm thiking about var name convention.
03:01:17 <zd234> MasseR, liste: what's coming in ghc 8 ?
03:01:18 <EvanR> right, you already know
03:01:26 <EvanR> the future you and someone reading he code does not
03:01:30 <MasseR> zd234: overloaded record fields
03:01:32 <EvanR> therefore my answer
03:01:46 <zd234> EvanR: yeah, therefore the ":: ... " so it's in the code for those reading it
03:01:54 <EvanR> well thats clutter
03:02:20 <EvanR> someone in ghci can just ask
03:02:21 <MasseR> zd234: it's a bit unidiomatic to declare the types for variables
03:02:32 <MasseR> Top-level functions yes, but not variables
03:02:59 <zd234> let and "_ <-" can all be "::"-ed
03:03:20 <EvanR> yes, itll just increase code size alot (if you use another line)
03:03:27 <EvanR> otherwise increase noise
03:03:48 <EvanR> types can be pretty big
03:05:12 <zd234> oh man, strictness
03:05:17 <zd234> I'm looking forward to ghc 8
03:05:39 <zd234> EvanR: I'm not very smart. If I can't type out the type of a var, maybe I shouldn't be using that var.
03:05:52 <MasseR> zd234: I trust the compiler to do it for me
03:06:46 <EvanR> zd234: in some libs i agree, i have a hard time coming to grips with a giant complex type
03:07:04 <EvanR> but also im not going to be able to write it out in the code even if i have to
03:07:15 <EvanR> er even if i can
03:07:26 <EvanR> since itll look to insanet
03:07:41 <EvanR> my T key :(
03:17:19 <fuzzy_id> shouldn't this return 'm True': '(||) <$> return True <*> undefined' ?
03:17:41 * hackagebot jailbreak-cabal 1.3.1 - Strip version restrictions from build dependencies in Cabal files.  https://hackage.haskell.org/package/jailbreak-cabal-1.3.1 (PeterSimons)
03:17:59 <EvanR> > True || undefined
03:18:00 <lambdabot>  True
03:18:09 <fuzzy_id> is there a lazy version of (<$>) or is there something i don't understand?
03:18:31 <EvanR> > (||) <$> pure true <*> undefined
03:18:32 <lambdabot>      Not in scope: ‘true’
03:18:33 <lambdabot>      Perhaps you meant data constructor ‘True’ (imported from Data.Bool)
03:18:38 <EvanR> > (||) <$> pure True <*> undefined
03:18:40 <lambdabot>      No instance for (Show (f0 Bool))
03:18:40 <lambdabot>        arising from a use of ‘show_M68148600667420472508608’
03:18:40 <lambdabot>      The type variable ‘f0’ is ambiguous
03:18:50 <EvanR> > (||) <$> pure True <*> undefined :: Identity Bool
03:18:51 <lambdabot>  Identity True
03:19:43 <fuzzy_id> > (||) <$> return True <*> undefined :: Identity Bool
03:19:45 <lambdabot>  Identity True
03:19:59 <fuzzy_id> hmm, this is annoying
03:20:20 <fuzzy_id> in ghci this throws an error at me
03:20:49 <EvanR> its possible in some instances it evaluates the undefined before using the function
03:21:33 <EvanR> > (||) <$> pure True <*> undefined :: Stream Bool
03:21:35 <lambdabot>      Not in scope: type constructor or class ‘Stream’
03:22:00 <EvanR> well that should be not _|_ anyway...
03:22:17 <fuzzy_id> looks like IO is one of these cases
03:23:17 <EvanR> ah yeah
03:23:31 <EvanR> apply an IO (a -> b) to an IO a
03:24:09 <EvanR> you have to execute the IO (a -> b) and the IO a before doing the application, so you need to evaluate the IO a first
03:25:28 <EvanR> > (||) <$> pure True <*> undefined :: IO Bool
03:25:30 <lambdabot>  <IO Bool>
03:26:11 <EvanR> heh
03:26:19 <EvanR> the error is deferred until execution
03:26:38 <EvanR> which makes sense
03:27:18 <EvanR> fuzzy_id: this works
03:27:41 <EvanR> > (||) <$> pure True <*> pure undefined :: IO Bool
03:27:43 <lambdabot>  <IO Bool>
03:28:15 <EvanR> returns True when executed
03:28:54 <jle`> fuzzy_id: it depends on what instance you are talking about
03:28:56 <EvanR> i wonder if this is IO breaking the Applicative laws
03:29:17 <jle`> (||) <$> pure True <*> undefined throwing an error for IO Bool makes sense
03:29:19 <merijn> EvanR: Why?
03:29:35 <jle`> Applicative for IO *sequences* the actions, and applies the functions afterwards to their results
03:29:37 <merijn> <*> inspects the constructor of the Applicative
03:29:51 <EvanR> well, it can
03:30:01 <merijn> EvanR: No, it *has* too
03:30:06 <fuzzy_id> my actual use case is like this: alreadyExists <- (||) <$> doesFileExist f <*> isLineInFile l f
03:30:08 <jle`> so, foo <*> undefined :: IO Bool is an IO action that does foo first, then does undefined
03:30:15 <merijn> All applicative effects happen before the result
03:30:21 <jle`> and then at the end of it all, it applies (||) to their results
03:30:37 <merijn> EvanR: The inability to selectively run side effects is exactly what distinguishes Applicative from Monad
03:30:45 <merijn> fuzzy_id: That's a TOCTOU race
03:30:47 <EvanR> merijn: well then wouldnt this crash
03:31:03 <EvanR>  (||) <$> pure True <*> undefined :: Identity Bool
03:31:05 <merijn> We should seriously delete "doesFileExist" from the API
03:31:19 <merijn> EvanR: It should
03:31:26 <EvanR> but it doesnt
03:31:28 <quchen> merijn: What's bad about this function?
03:31:40 <jle`> it depends on the instance
03:31:46 <merijn> quchen: The only use it has is producing TOCTUO races
03:31:47 <arw> quchen: it can be abused.
03:31:50 <maerwald> merijn: while at it, remove the rest of System.Directory
03:32:04 <arw> merijn: nope. it can be used to check for e.g. lockfiles
03:32:16 <arw> merijn: there are legitimate use cases for this function
03:32:18 <jle`> fuzzy_id: with Applicative for IO, you give it two IO actions, doesFileExist f, and isLIneInFile l f, and it creates a new IO action that does one after the other, sequencing them
03:32:20 <fuzzy_id> ok, so i'm simply going to handle the exception…
03:32:28 <merijn> arw: No, with lockfiles you'd still get a TOCTOU
03:32:33 <jle`> fuzzy_id: and then, with Applicative, it applies (||) to the *results* after executing both actions
03:32:43 <maerwald> and System.FilePath with it :P
03:32:56 <jle`> "execute this action, then execute that action, and then, give a result that is (||) applied to the results of both"
03:32:57 <maerwald> all buggy libraries
03:33:03 <merijn> EvanR: I'd say that that Identity implementation is buggy
03:33:08 <arw> merijn: yes, but not one that would be bad in any way. the only error you can make is assume that stuff is still locked.
03:33:17 <merijn> arw: Oh?
03:33:29 <merijn> arw: What happens if the lockfile is made after I check and it doesn't exist?
03:33:38 <merijn> Then I wrongly assume it's unlocked
03:33:48 <EvanR> merijn: because its too lazy? or whats the issue. also i guess none of this is related to applicative laws
03:34:17 <arw> merijn: that depends on the kind of lock, if you want it to be advisory or not.
03:34:20 <merijn> EvanR: Too lazy, yes
03:34:51 <fuzzy_id> that would actually be my next question: why is IO different from e.g. Identity?
03:34:55 <arw> merijn: 'advisory' as in 'its not bad if things run in parallel, I just want to avoid it in most cases'
03:35:22 <merijn> fuzzy_id: Different in what way? As I just said, imo the Identity implementation is wrong
03:35:30 <EvanR> heh
03:35:32 <fuzzy_id> ah, ok
03:35:39 <quchen> IO has observable side effects, Identity does not. (Assuming no bottoms.)
03:35:40 <jle`> fuzzy_id: well, every Applicative gets to implement its own instance
03:35:53 <jle`> so it makes sense that <*> would behave differently for different instances
03:35:56 <jle`> that's sort of the whole point
03:36:00 <arw> merijn: you also need it to create locking mechanisms when link/unlink or open/write isn't atomic. then you do something like compare/exchange on the contents of the lockfile.
03:36:08 <quchen> You can't lazily leave a "readLine" away in "f <$> readLine <*> readLine" because "f" might ignore its second argument.
03:36:26 <jle`> fuzzy_id: the real question is, why are you expecting them to behave the same?
03:36:27 <merijn> EvanR: I suspect it's implemented "x <*> y = Identity $ getIdentity x (getIdentity y)" and the laziness of || is not actually applying getIdentity
03:36:48 <EvanR> right
03:37:08 <EvanR> whats the problem? ;)
03:37:27 <jle`> fuzzy_id: <$> for IO, and for Maybe, and for List, and for Map k, etc. are vastly different, each implemented differently, and giving different results
03:37:53 <merijn> EvanR: Wow...
03:38:02 <merijn> EvanR: The reason it works is because of worse voodo
03:38:17 <EvanR> it doesnt have to crash so why do we want it to, some law or
03:38:33 <merijn> EvanR: "instance Applicative Identity where (<*>) = coerce", so the only reason it works is because Identity does icky things
03:38:38 <EvanR> lol
03:38:55 <EvanR> some high speed Identitying
03:39:22 <joco42> is the author of https://github.com/nh2/call-haskell-from-anything here ?
03:39:56 <merijn> EvanR: The Applicative law requires all effects of the computation happen before a result is returned, so having a bottom as input to <*> shouldn't work, yes. The reason it does here is because Identity is basically making assumptions about it's own lack of side-effects in the implementation
03:40:02 <joco42> i would like compile it with 7.10.2
03:40:19 <joco42> i am looking for guidance on have to change it
03:40:22 <quchen> merijn: How does that instance work? With mf = Identity f, we have   mf <*> mx = coerce mf mx = (coerce mf) mx = f mx, and that looks like a type error
03:41:05 <fuzzy_id> ok, lesson learned: IO evaluates its argument before applying fmap
03:41:09 <fuzzy_id> back to work now :)
03:41:15 <jle`> quchen: coerce mf isn't f
03:41:18 <fuzzy_id> thanks for the insights!
03:41:33 <jle`> fuzzy_id: well, it doesn't evaluate the result, necessarily
03:41:37 <jle`> fuzzy_id: it *executes* the action
03:41:44 <jle`> that's the important part :)
03:41:48 <EvanR> it does evaluate the action first
03:41:51 <jle`> so it has to evaluate the IO action in order to execute it
03:41:58 <EvanR> so it can execute it
03:42:03 <kqr> jle`, is it just IO that does that or can it be observed for other functors?
03:42:03 <jle`> mhm
03:42:06 <fuzzy_id> ah?
03:42:16 <fuzzy_id> but isn't evaluation execution for the case of IO?
03:42:19 <EvanR> it crashes in the example before getting to the execution part
03:42:21 <merijn> quchen: I don't understand it either
03:42:27 <jle`> fuzzy_id: nope, that's the big deal(tm) about IO in haskell
03:42:29 <EvanR> fuzzy_id: no
03:42:37 <jle`> IO actions can be evaluated, and it doesn't execute anything
03:42:38 <quchen> jle`: What's coerce mf?
03:43:02 <jle`> quchen: it coerces an Identity (a -> b) to an Identity a -> b, presumably
03:43:02 <EvanR> :t coerce
03:43:03 <lambdabot> (Functor f, Contravariant f) => f a -> f b
03:43:11 <fuzzy_id> is there some wiki page explaining the difference?
03:43:18 <mniip> that's the wrong coerce
03:43:26 <merijn> quchen: https://hackage.haskell.org/package/base-4.8.2.0/docs/src/Data.Functor.Identity.html#line-85
03:43:42 <jle`> fuzzy_id: an IO action is a description of an action, so evaluating a description doesn't execute anything
03:43:48 <mniip> :t Data.Coerce.coerce
03:43:49 <lambdabot> GHC.Types.Coercible a b => a -> b
03:43:50 <merijn> Also, can I just say that hyperlinked source is freaking AWESOME?
03:43:53 <jle`> fuzzy_id: like, if you hexdump /bin/ls, that doesn't execute ls
03:44:17 <EvanR> fuzzy_id: its because a value of type IO Whatever can be produced by some computation, then passed around, stored in a container without ever executing it
03:44:22 <jle`> fuzzy_id: if you evaluate a string containing C source code, it doesn't magically compile and execute the C in the process of evaluating the string
03:44:46 <jle`> evaluating the description means you figure out what the description describes
03:44:54 <liste> > putStrLn -- not executing anything
03:44:57 <lambdabot>  <[Char] -> IO ()>
03:44:59 <jle`> but it doesn't mean things are magically executed in the process
03:45:06 <jle`> that's just crazy talk
03:45:12 <EvanR> > getChar -- not executing anything
03:45:14 <lambdabot>  <IO Char>
03:45:20 <merijn> quchen: Turns out coerce on functions is evil voodo
03:45:29 <merijn> quchen: See comment at the bottom here: https://hackage.haskell.org/package/base-4.8.2.0/docs/src/Data.Foldable.html
03:46:33 <fuzzy_id> ah, ok
03:47:05 <jle`> quchen: the way i'd guess it works is that it sees that Identity (a -> b) has the same rep as (a -> b), which has the same rep as Identity a -> b ?
03:47:26 <quchen> Woha.
03:47:31 <EvanR> they have the same rep??
03:47:47 <merijn> EvanR: newtype always have the same representation
03:47:49 <merijn> So yes
03:47:52 <EvanR> oh its a newtype
03:48:01 <merijn> EvanR: You can't coerce non-newtypes
03:48:13 <mniip> sure you can
03:48:14 <merijn> It's why it's coerce and not unsafeCoerce
03:48:19 <merijn> mniip: No
03:48:21 <mniip> you can change phantom type variables
03:48:28 <mniip> and coercible type variables
03:48:41 <merijn> mniip: You can coerce "contents", but not the outer type
03:48:53 <jle`> > Data.Coerce.coerce (Proxy :: Proxy Int) :: Proxy Bool
03:48:55 <lambdabot>  Not in scope: ‘Data.Coerce.coerce’
03:48:58 <EvanR> this is what i get as reward for staying up til 6AM
03:49:02 <kqr> is this only an optimisation or when does this arise? i've never felt the need to coerce something in my code
03:49:05 <EvanR> coerce voodoos
03:49:34 <mniip> merijn, you can coerce Proxy a -> Proxy b
03:49:35 <jle`> kqr: coerce xs is better than map runIdentity xs
03:49:40 <mniip> you can also coerce [Identity a] -> [a]
03:49:45 <merijn> kqr: "map Identity xs" is expensive because you traverse the spine
03:49:49 <merijn> kqr: "coerce xs" is cheap
03:49:59 <merijn> kqr: See also the GHC manual on "roles"
03:50:02 <kqr> so... an optimisation?
03:50:06 <merijn> Yes
03:50:29 <jle`> it's supposed to be an optimisation, but apparently the notes in the Foldable module suggest it can change semantics in weird ways
03:50:32 <EvanR> I should use more Identity in my code, its so fas
03:50:58 <jle`> oh,  it doesn't change semantics, it just can lead to inefficienter code
03:51:03 <EvanR> jle`: hence the <*> undefined weirdness
03:51:28 <jle`> EvanR: poor man's let block is do with identity
03:52:33 <EvanR> haha
03:53:05 <Gurkenglas_> Is there something like Prism s a: ??? (m s) (m a) with a -> EitherT a m s instead of m a -> Either (m a) (m s)?
03:59:20 <OverCoder> How can I declare a function to return anything?
03:59:29 <OverCoder> Or actually,
03:59:40 <fractalsea> How can I “run” inner monads of a transformer stack?
04:00:02 <frerich> OverCoder: You use a plain type variable, like 'a'.
04:00:06 <OverCoder> I have a function, say it shoudl return a list containing few strings and two lists that also contains few strings
04:00:11 <jle`> fractalsea: can you give an example?
04:00:13 <OverCoder> frerich, well it doesn't work
04:00:23 <OverCoder> /a is rigid type bla bla/
04:00:33 <OverCoder> I can paste the error if you like
04:00:42 <liste> OverCoder f :: Either [String] ([String], [String]) ?
04:00:48 <liste> or your own ADT
04:00:51 <frerich> OverCoder: Pasting the error and the code you used to trigger it to lpaste.net would be good.
04:00:52 <jle`> OverCoder: you can declare a function to return anything, but you'll also have to implement it to do so :P
04:01:23 <OverCoder> baby.hs:34:11:
04:01:23 <OverCoder>     Couldn't match expected type `b' with actual type `[Char]'
04:01:23 <OverCoder>       `b' is a rigid type variable bound by
04:01:24 <OverCoder>           the type signature for parse :: String -> b at baby.hs:33:10
04:01:24 <OverCoder>     Relevant bindings include
04:01:24 <OverCoder>       parse :: String -> b (bound at baby.hs:34:1)
04:01:26 <OverCoder>     In the expression: ""
04:01:28 <fractalsea> jle`, something like ReaderT r (StateT s) a -> s -> ReaderT r a
04:01:36 <OverCoder> OMG
04:01:38 <OverCoder> omg it's not my fault
04:01:42 <OverCoder> It's my Ctrl button's
04:01:44 <jle`> @where lpaste
04:01:45 <lambdabot> http://lpaste.net/
04:01:51 <OverCoder> http://p.samuraimanpurse.com/YjwkVXm7.txt
04:01:53 <OverCoder> ^ there
04:01:59 <EvanR> OverCoder: what is the type of function youre trying to write
04:02:12 <OverCoder> parse :: String -> anything-here
04:02:21 <EvanR> are you sure
04:02:34 <OverCoder> ?
04:02:45 <EvanR> or do you mean like
04:02:47 <EvanR> :t read
04:02:49 <lambdabot> Read a => String -> a
04:03:01 <OverCoder> um, no
04:03:13 <OverCoder> parse function should parse an IRC raw line
04:03:29 <LeCamarade> OverCoder: Notice that even read has type classes, which is the only way to get what you want properly.
04:03:38 <liste> fractalsea: is StateT s (ReaderTr ) a -> s -> ReaderT r a OK ?
04:03:45 <jle`> OverCoder: you should probably make a data type that has constructors for every type of thing you can return
04:03:49 <jle`> and then return a value of that type
04:03:49 <EvanR> OverCoder: maybe youre trying to return a list or list of lists of something
04:04:00 <EvanR> or a custom datatype ^
04:04:05 <OverCoder> ooh, hm, intersting
04:04:07 <OverCoder> I will do it
04:04:07 <jle`> data ParseResults = A [String] | B [String] [String] | C ...
04:04:37 <OverCoder> wow, bunch of thanks
04:04:40 * OverCoder codes
04:04:48 <jle`> np!
04:07:06 <fractalsea> liste, yes I guess I could try and turn it into that
04:07:17 <liste> :t runStateT
04:07:18 <lambdabot> StateT s m a -> s -> m (a, s)
04:07:28 <liste> :t evalStateT
04:07:29 <lambdabot> Monad m => StateT s m a -> s -> m a
04:07:43 * hackagebot lentil 0.1.9.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-0.1.9.0 (fffaaa)
04:07:55 <liste> wow, the former doesn't have Monad m => constraint
04:08:07 <jle`> yeah, it just unwraps the newtype wrapper
04:08:22 <jle`> the second has to liftM fst
04:08:45 <EvanR> heh lack of constraints like that kind of leak the implementation huh ;)
04:09:39 * liste is gonna play around with ZipList :D
04:10:15 <liste> couldn't the latter be technically Functor m?
04:10:24 <liste> if liftM is basically fmap
04:10:27 <jle`> yes, but this is from a pre-AMP world
04:10:32 <jle`> it should be Functor
04:11:20 <quchen> liftM's entire purpose is not having a Functor constraint.
04:11:45 <quchen> If it had a Functor constraint we could deprecate it, because it would be identical to fmap.
04:12:11 <quchen> But liftM is not identical to fmap, because it is implemented in terms of pure and >>=, so we can use it to specify a Functor instance in terms of a Monad.
04:12:33 <quchen> Similarly, <*> does not make `ap` redundant.
04:12:35 <kqr> can you define a monad without first having defined a functor though?
04:12:43 <EvanR> yeah
04:12:44 <jle`> yup, i do it all the time
04:12:50 <jle`> when i'm feeling lazy >_>
04:12:58 <quchen> kqr:  https://github.com/quchen/articles/blob/master/fbut.md#reversed-type-class-instances
04:13:03 <EvanR> its all nice an recursive
04:13:41 <EvanR> you can also define them in terms of each other in a way that loops at runtime
04:13:49 <EvanR> but better not
04:13:50 <kqr> quchen, oh that's great. did not know that
04:14:32 <kqr> also I should probably read through that entire document
04:15:40 <jle`> remember that one of the neat things about haskell is that there is no inherent ordering of declarations
04:15:45 <jle`> so you could write:
04:15:47 <jle`> foo = bar + 3
04:15:49 <jle`> bar = 6
04:15:51 <jle`> and it'd be fine :)
04:16:00 <jle`> declarations all refer to eachother
04:16:14 <jle`> it's not like you have to define bar *before* you define foo
04:16:27 <jle`> and it's not like you have to define a Functor instance "before" you define a Monad instance
04:16:34 <jle`> they're all just definitions, there is no before or after
04:17:01 <jle`> no sense of sequencing
04:17:25 <EvanR> jle`: which makes is very easy to write algorithms using equational reasoning
04:17:49 <EvanR> jle`: but not so easy to see that you didnt define an infinite loop or semi-infinite memory usage
04:17:57 <EvanR> when it gets complex
04:17:59 <EvanR> :(
04:18:03 <kqr> jle`, yeah I just for some reason assumed that since you had a Functor f => Applicative f constraint it would require a Functor instance that was "finished" before the Applicative instance was defined, but I see now how that doesn't even make sense
04:22:43 * hackagebot gore-and-ash-sdl 1.1.0.1 - Gore&Ash core module for integration with SDL library  https://hackage.haskell.org/package/gore-and-ash-sdl-1.1.0.1 (NCrashed)
04:24:03 <ReinH> The only exception is template haskell
04:30:17 <haskell222> I'm doing the monad challenges from mightybyte and I am having problems with the Chains of Failing Computations section
04:31:06 <haskell222> how do you use Just return values when the function requires just a plain value ?
04:31:38 <liste> :t fmap (+1) -- haskell222
04:31:39 <lambdabot> (Functor f, Num b) => f b -> f b
04:31:49 <liste> you can convert the function to take a Maybe (:
04:31:57 <liste> > fmap (+1) (Just 24)
04:31:59 <lambdabot>  Just 25
04:33:57 <liste> > fmap (\x -> "hello " ++ x) (Just "world")
04:33:59 <lambdabot>  Just "hello world"
04:34:03 <liste> > fmap (\x -> "hello " ++ x) Nothing
04:34:05 <lambdabot>  Nothing
04:35:25 <dsub> haskell222: You could stay within the Maybe monad ( or fmap-ing, as liste suggested ) or if you need to get out of Maybe, use the maybe function
04:35:55 <dsub> maybe 0 (\a -> a + 2) (Just 4)
04:36:06 <dsub> > maybe 0 (\a -> a + 2) (Just 4)
04:36:08 <lambdabot>  6
04:36:11 <dsub> > maybe 0 (\a -> a + 2) Nothing
04:36:13 <lambdabot>  0
04:36:18 <julianleviston> Why doesn’t List form a Monoid with a cartesian product, possibly?
04:37:15 <liste> julianleviston so [1, 2] <> [3, 4] would be [(1, 3), (1, 4), (2, 3), (2, 4)] ?
04:37:24 <julianleviston> liste: could be.
04:37:26 <julianleviston> could it not?
04:37:31 <tmerr|hardcore> i'm just dropping in to say damn you haskellers, i'm taking an abstract algebra course, and i'm going to finally figure out if you're just making up all of the words you use to confuse other programmers 
04:37:33 <julianleviston> I mean, in the same way numbers form a monoid with Sum or Product … 
04:37:42 <liste> julianleviston that'd not type check with the <> we know
04:37:44 <FireFly> quchen: https://github.com/quchen/articles/blob/master/fbut.md#line-comments it looks like the markdown parser works correctly now (unless I'm stupid and missing something), so might want to edit the parenthesis
04:37:50 <julianleviston> liste: obviously.
04:38:04 <julianleviston> liste: sorry didn’t mean to sound snarky. I mean I agree.
04:38:37 <liste> tmerr|hardcore: then get a category theory course after that ; )
04:38:41 <julianleviston> it just seems to me there are many “ways to combine things".
04:38:45 <quchen> FireFly: Oh, nice
04:39:03 <julianleviston> liste: this *is* what monoid is about isn’t it? ways to generically join things together?
04:39:14 <julianleviston> I should look up the definition of monoid again
04:39:39 <julianleviston> ah ok. that’s what I thought.
04:39:55 <julianleviston> I wonder what the binary operation for cartesian product would be there though....
04:39:55 <liste> julianleviston monoid is mempty and mappend (or whatever you want to call them) with associativity and identity laws
04:40:05 <phadej> carrier set a, unit element in that set, and associative binary operation for the elements of that set
04:40:13 <julianleviston> liste: a set closed under an associative binary operation
04:40:37 <julianleviston> liste: that kinda opens up a lot of possiblilties really
04:40:43 <julianleviston> depending on the binary operation.
04:42:03 <julianleviston> It seems using a newtype (a la Sum and Product) is a bit of a kludge to get around the need to tag the data type with the particular monoid one is using… because there are actually more than one monoid possible
04:42:05 <bergey> > (,) [1,2] <*> [3.4]
04:42:07 <lambdabot>      Couldn't match expected type ‘[Double -> b]’
04:42:07 <lambdabot>                  with actual type ‘b0 -> ([Integer], b0)’
04:42:07 <lambdabot>      Probable cause: ‘(,)’ is applied to too few arguments
04:42:24 <bergey> > (,) <$> [1,2] <*> [3.4]
04:42:26 <lambdabot>  [(1,3.4),(2,3.4)]
04:43:41 <phadej> julianleviston: well, groups has two operations which are monoidal;
04:43:41 <liste> julianleviston: so you mean that that the associativity law would be satisfied (if (a,(b,c))=((a,b),c)) and identity is preserved
04:44:00 <liste> so technically I guess it could be a monoid. not a Haskell Monoid though
04:44:16 <julianleviston> phadej: groups?
04:44:38 <phadej> julianleviston: https://en.wikipedia.org/wiki/Ring_(mathematics)
04:44:54 <julianleviston> phadej: sorry I thought you were talking haksell. Yeah, math. ok :)
04:45:01 <coconut> on windows can we use the same filepath package without problems with slash ?
04:45:13 <julianleviston> liste: I’m not sure.
04:45:16 <liste> julianleviston the what would be the identity element?
04:45:23 <phadej> julianleviston: well, one can define that class in Haskell too (and someone probably did)
04:45:29 <julianleviston> liste: oh yeah, semigroup rather than monoid.
04:45:40 <coconut> i get this error while readFile: txt\book.txt: hGetContents: invalid argument (invalid byte sequence)
04:46:00 <julianleviston> liste: I always forget that… I need to hammer down my understanding of these things better.
04:47:14 <liste> coconut I'm sure that's an encoding issue
04:47:50 <coconut> liste, i remember on linux machine i have to locale-gen
04:48:08 <coconut> but on windows how to do the equivalent?
04:48:12 * hackagebot gore-and-ash-network 1.1.0.1 - Core module for Gore&Ash engine with low level network API  https://hackage.haskell.org/package/gore-and-ash-network-1.1.0.1 (NCrashed)
04:49:22 <liste> coconut try hSetEncoding before reading
04:49:34 <liste> :t hSetEncoding
04:49:36 <lambdabot> Not in scope: ‘hSetEncoding’
04:49:51 <liste> (it's Handle -> TextEncoding -> IO ())
04:50:14 <liste> depending on system encoding is a bad idea
04:52:45 <coconut> OK
04:52:49 <coconut> LET ME TRY
04:53:00 <liste> though you can't use readFile then
04:53:09 <fr33domlover> Q: In gets, asks, ShowS - what does the S suffix mean?
04:53:27 <coconut> which TextEncoding should i pick 
04:53:28 <fr33domlover> what does the S stand for?
04:53:41 <liste> coconut the one used in your file
04:53:52 <liste> preferably save the file using UTF-8 and use that
04:54:34 <merijn> fr33domlover: ShowS is a synonym for "String -> String"
04:54:50 <fr33domlover> merijn, i know, but what does the 'S' mean?
04:54:56 <fr33domlover> like in asks, gets, etc.
04:55:59 <merijn> fr33domlover: Not sure, tbh
04:56:10 <julianleviston> wouldn’t it be String ?
04:56:18 <julianleviston> given that it uses String as a difference list?
04:56:36 <fr33domlover> julianleviston, maybe in the case of ShowS
04:56:36 <julianleviston> probably way too guessy tho
04:56:41 <fr33domlover> but what about asks and gets
04:56:59 <fr33domlover> ask = return the environment; asks = return a function of the environment
04:57:06 <fr33domlover> similar in get/gets
04:57:14 <merijn> fr33domlover: I would say no relation
04:57:31 <julianleviston> with asks it might be selector
04:57:39 <puregreen> I always read “asks f” as “asks for f” (which makes sense when f is a record accessor)
04:58:30 <merijn> Isn't there a version System.Process that works with Text instead of String?
05:00:53 <kqr> merijn, i think turtle does, but it probably doesn't count as "a version of system.process"
05:01:37 <bergey> I was going to say the same about shelly.
05:02:23 <merijn> I'm not really looking for shell scripting libraries but more just dealing with child process
05:04:46 <coconut> liste, can i : hSetEncoding inh utf8 ?
05:05:13 <coconut> "The TextEncoding for UTF-8 is utf8."
05:05:35 <coconut> so is utf8 a Text for its type?
05:06:03 <liste> coconut you can, if inh is a handle. the type of utf8 is TextEncoding, yes
05:06:08 <liste> (not Text)
05:06:12 <coconut> ok
05:06:13 <coconut> great
05:06:51 <coconut> so on windows do you often meet such situations? to manually set the encoding ?
05:07:34 <liste> coconut if you're dealing with text files, you always need to mind the encoding
05:08:00 <coconut> i also just used hFlush
05:08:06 <kqr> coconut, generally whenever you deal with text going in and out of your program you have to mind the ecoding – but windows is especially terrible at choosing bad defaults
05:08:12 <coconut> after that which readfile fucntion should i choose ?
05:08:29 <coconut> hGetContents
05:08:29 <coconut> ?
05:08:41 <liste> for example
05:08:44 <coconut> kqr, thanks
05:09:22 <liste> coconut make sure that the text file you're reading is the correct encoding too
05:10:23 <merijn> Is there a library that has a nice simple workflow for sending/receiving datagrams?
05:11:00 <liste> merijn using UDP?
05:11:23 <liste> or a higher-level library
05:11:26 <merijn> Don't particularly care. TCP I guess, but if it's UDP and takes care of retransmission
05:11:52 <jophish> zeromq might suit you, but it sounds like it'd be a little too high
05:11:54 <merijn> I need to hack together my own work distribution system because our cluster scheduler is retarded, so I just need to farm out packets
05:12:13 <merijn> Last I checked the ZeroMQ bindings were a bit iffy and I still haven't finished my own >.>
05:12:44 <kqr> merijn, data.conduit.network?
05:12:47 <jophish> merijn: ah, because that sounds like the ideal case for 0mq
05:12:48 <kqr> not sure if it's a perfect fit
05:12:59 <liste> @hackage network-transport -- is this too heavy? it's used by Cloud Haskell
05:12:59 <lambdabot> http://hackage.haskell.org/package/network-transport -- is this too heavy? it's used by Cloud Haskell
05:13:13 * hackagebot toysolver 0.4.0 - Assorted decision procedures for SAT, Max-SAT, PB, MIP, etc  https://hackage.haskell.org/package/toysolver-0.4.0 (MasahiroSakai)
05:13:24 <merijn> kqr: Which package is that?
05:13:28 <kqr> merijn, conduit-extra
05:14:35 <merijn> kqr: I don't see datagram support there?
05:15:50 <kqr> merijn, I guess I'm confused by your question. in my mind a datagram is a UDP message
05:16:12 <kqr> but then you said you wanted TCP so I should probably not reply
05:16:12 <merijn> A datagram is a discrete/delimited packet of data
05:16:26 <merijn> UDP packets *are* datagrams, but not all datagrams are UDP
05:16:44 <merijn> I need reliable transmission and don't want to implement it myself on top of UDP
05:17:48 <liste> network-transport apparently has tcp, zeromq and amqp implementations
05:18:40 <merijn> Basically, I have multiple threads talking to a server asking for datagrams and (in case of TCP) would like to piggyback them all over the same TCP connection to avoid the overhead of creating a zillion connections, but then I need to make sure their transmissions don't interleave eachother
05:20:29 <aweinstock> have one thread that handles the TCP connection and serializes the packets, and have the other theads talk to that thread over Chan/MVar?
05:21:54 <coconut> how to print newline or empty line on windows ? print "\n" doesnt work
05:21:58 <kqr> you could do that but I don't see how that's different from attaching a datagram producer to a conduit TCP sink 
05:22:02 <kqr> then again, I may be speaking out of my ass
05:22:20 <merijn> coconut: putStrLN ""
05:22:24 <merijn> Eh, lowercase n
05:22:34 <coconut> thanks
05:23:07 <LordBrain> putStr "\n" should work too
05:24:19 <LordBrain> also, putChar '\n'
05:25:12 <LordBrain> import Text.Printf ... main = printf "\n"
05:28:41 <ReinH> no reason to use printf
05:28:51 <LordBrain> no, but since we were listing all the ways
05:29:18 <LordBrain> or do you mean you morally object to using printf under any circumstances?
05:30:02 <ReinH> Well, I certainly object to using it to print a newline
05:30:08 <coconut> why
05:30:19 <coconut> i just print "\n"
05:30:23 <coconut> without f
05:30:40 <ReinH> you don't want print
05:30:49 <ReinH> print is putStrLn . show
05:31:08 <coconut> i have print all over
05:31:11 <coconut> the code
05:31:21 <ReinH> you don't want print "\n"
05:31:46 <kqr> LordBrain, for what it's worth, I think using it to print a newline is one of the better ways to use it (printf that is)
05:32:04 <maerwald> why not: printf "%s" "\n"
05:32:06 <maerwald> :o
05:32:15 <tdammers> ReinH: AFAIK, you'll technically get away with it, because outputting "\n" to a stream in text mode on a CRLF platform will output "\r\n" after all
05:32:21 <tdammers> it's just not pretty
05:32:32 <ReinH> tdammers: er, it will output "\\n"
05:32:41 <lambda-freezer> can anyone explain this type signature?
05:32:45 <lambda-freezer> > :type [1, 2, [1, 2], 3] [1, 2, [1, 2], 3] :: (Num t, Num [t]) => [[t]]
05:32:47 <lambdabot>  <hint>:1:1: parse error on input ‘:’
05:33:00 <ReinH> lambdabot: you are mixing numbers with lists of numbers
05:33:04 <tdammers> ReinH: ?
05:33:19 <ReinH> print "\n" = putStrLn "\\n"
05:33:53 <tdammers> oh, right, print, not putStr
05:33:56 <tdammers> I rest my case
05:34:01 <ahihi> "\"\\n\""
05:34:05 <ReinH> yeah
05:34:08 <ReinH> that
05:34:30 <ReinH> lambda-freezer: you are mixing numbers with lists of numbers
05:34:45 <ReinH> lists can only contain a single type of element
05:34:54 <lambda-freezer> right, but it has a valid type
05:35:04 <ggole> > :type [1, 2, [1, 2], 3]
05:35:06 <lambdabot>  <hint>:1:1: parse error on input ‘:’
05:35:56 <ggole> ReinH: it's good old Num making life fun
05:36:01 <ReinH> ggole: yes
05:36:29 <ReinH> GHC is telling you that you are trying to use a number as a list of numbers
05:36:32 <kqr> lambda-freezer, it has "a valid type" in the sense that it tries to convert the numbers to lists of numbers
05:36:57 <kqr> lambda-freezer, it knows it's a list-of-lists-of-numbers, so it tries to convert the first 1 to a list-of-numbers
05:37:04 <kqr> lambda-freezer, but unless you tell it how to it'll give you a type error
05:37:13 <ReinH> You are claiming that 1 is a list of numbers
05:37:25 <ReinH> GHC is trying to make sense of that
05:37:28 <lambda-freezer> i see. 
05:37:30 <ReinH> :t 1
05:37:31 <lambdabot> Num a => a
05:37:54 <quchen> :t 1 :: Num [a] => [a]
05:37:56 <lambdabot> Num [a] => [a]
05:38:11 <lambda-freezer> right thanks
05:38:58 <ReinH> what the hell?
05:39:22 <ReinH> How was I spamming?
05:39:37 <hodapp> I have no idea...
05:39:42 <ahihi> ReinH: the bot quit right after you, perhaps it went rogue
05:39:44 <lambda-freezer> neither do i
05:39:45 <hodapp> might have to ask #freenode or something.
05:40:32 <ReinH> I guess if it happens again
05:41:09 <hodapp> ReinH: NO I DO NOT WANT YOUR PENIS ENLARGEMENT
05:41:32 * hodapp runs off
05:41:36 <maerwald> errr wat?
05:41:48 <ReinH> ...
05:41:52 * maerwald looks what channel he is in
05:42:09 <hodapp> maerwald: a channel where ReinH gets kicked out for spamming!
05:42:27 <hodapp> ...sorta.
06:02:49 <Gurkenglas_> v DISREGARD THAT I SUCK COCKS v
06:03:03 <Gurkenglas_> umm.
06:04:15 <Gurkenglas_> "Freenode is not having problems", I guess?
06:04:16 <frerich> Gurkenglas_: Having fun with freenode webchat?
06:12:20 <NeverDie> LOL
06:17:22 <mniip> Gurkenglas_, there seems to be a bit of lag on one of the servers
06:28:26 * hackagebot number-length 0.1.0.0 - Number of digits in a number in decimal and hexadecimal representation.  https://hackage.haskell.org/package/number-length-0.1.0.0 (PeterTrsko)
06:44:28 <merijn> hmmm
06:44:54 <merijn> I have a package that has both a library and an executable depending on that library, but cabal seems to try to resolve imports directly, instead of linking to the compiler binary
06:45:04 <merijn> The end result is it complaining about missing build-depends
06:46:24 <bergmark> merijn: because the hs-source-dirs overlap?
06:46:57 <merijn> bergmark: So I need to split the source dirs? :\
06:47:33 <merijn> That's annoying...
06:49:39 <clintm> merijn: I'm doing the same thing without issue, with overlapping (4x) hs-source-dirs.  Only thing that comes to mind is that the library is defined last in the .cabal file.
06:49:56 <merijn> library is defined first in the file
06:50:01 <Strukks> [1,2,3,4] !! 3 is "3", but is there similar syntax for getting the first 3 elements for example?
06:50:10 <manwaz> //whoami
06:50:15 <Strukks> I tried [1,2,3,4] !! <3, that didn't work
06:50:24 <`Guest00000> Strukks: take 3 [1,2,3,4]
06:50:33 <`Guest00000> uhh
06:50:36 <`Guest00000> >_<
06:50:50 <Strukks> Cheers!
06:51:15 <clintm> merijn: Sorry, I meant in my cabal file it's defined last.
06:51:17 <mpickering> Strukks: !! is just an operator defined like any other. You should try to avoid using it though as it is partial 
06:51:25 <`Guest00000> Strukks: you can define
06:51:33 <mpickering> > [] !! 1
06:51:35 <lambdabot>  *Exception: Prelude.!!: index too large
06:52:05 <`Guest00000> you can define   l <!! n = take n l
06:52:09 <Strukks> > [1,2,3,4] !! 3
06:52:12 <lambdabot>  4
06:52:16 <Strukks> That's cool
06:52:18 <manwaz> Is anyone working on "The Monad Challenges"? http://mightybyte.github.io/monad-challenges/
06:52:38 <`Guest00000> then:   [1,2,3,4] <!! 3   =  [1,2,3]
06:53:06 <merijn> clintm: Did you duplicate the dependencies between your executable and library?
06:53:16 <dutchie> i wouldn't recommend defining such an operator though; take is a very well-known and idiomatic function
06:53:41 <Strukks> Thanks, Guest00000!
06:53:57 <clintm> merijn: no.  I just included what they needed to build.
06:54:27 <merijn> clintm: I moved the library last but that still fails by directly importing one of the files
06:54:39 <merijn> clintm: Do your executables/library share code? (Any source?)
06:55:08 <Shockk> > let takeBy = flip take in   [1,2,3,4] `takeBy` 3
06:55:10 <lambdabot>  [1,2,3]
06:56:31 <clintm> merijn: https://gist.github.com/cmoore/aa7c93e1ba3ff54ed1ae
06:58:22 <clintm> merijn: oh, crap, that's not going to help you.  I'm not using any of the code from the library - just sharing the source.
06:58:41 <clintm> Nothing that I use in the executables is in exposed-modules. :/ sorry about that.
06:59:16 <merijn> clintm: That was my point. My executables are importing from the libraries exposed-modules, and sadly that seems to ruin things :\
06:59:42 <OverCoder> data parsed = parsed { nick :: String, username :: String, host :: String, action :: String,actionArgs :: [String], botCommand :: String, botArgs :: [String],raw :: String, msg :: String, _botArgs :: String}
06:59:53 <OverCoder> No type constructor for parsed
07:00:04 <merijn> OverCoder: parsed is lowercase
07:00:11 <OverCoder> awwwww, gotcha
07:00:24 <merijn> OverCoder: Constructors (type and value) must start with uppercase
07:00:33 <OverCoder> Yeah I just forgot :v
07:20:48 <coconut> anyone recommend a good haskell full text search library or tool ?
07:22:21 <infandum> Is there a way to convert from Sequence to Map without the List intermediate? I feel like the number of times I need to convert back to list just to get to another structure is detrimental to efficiency
07:22:56 <tdammers> infandum: it's probably not; a list is secretly a generator function behind the scenes
07:23:16 <infandum> So it's not a linear O(n) function?
07:23:32 <tdammers> I believe the direct translation would also be O(n)
07:23:37 <tdammers> (at best)
07:23:51 <infandum> OK, I guess I don't feel as bad now
07:24:11 <infandum> What about Text.pack and Text.unpack though? Those transformations (from what I hear) are costly
07:24:24 <Gurkenglas_> I would like to extract some of the data from files like http://lpaste.net/5860176575504318464 , but much of it doesn't interest me. Do I have to include irrelevant fields in the newtypes i define?
07:24:31 <tdammers> yes, they are more costly, but that's because they do UTF-16 encoding/decoding
07:25:35 <Gurkenglas_> (Will that even work if my record field names are lowercase?)
07:25:35 <infandum> tdammers: So basically, Set, List, Sequence, and their family (is it Foldable?) have no real impact from converting between them throught the List intermediate?
07:25:50 <Mirry> I don't get why we can set the size of the index with IOUArray, could anyone explain this to me?
07:25:59 <kqr> Gurkenglas_, aeson does not require your types to contain all fields in the json
07:26:11 <tdammers> infandum: there is an overhead, but the trip through List doesn't add much
07:26:33 <kqr> infandum, the list intermediate itself has very little impact, because it'll never actually construct a list in memory
07:27:03 <kqr> infandum, when your map gets created it will continuously request the next element from the list, and only at that point will the list request the next element from the sequence
07:27:04 <tdammers> ^ this. it'll only construct a thunk that will produce a "current" value and a thunk for the rest of the list
07:27:09 <infandum> OK, I won't worry about it that much then :)
07:27:15 <kqr> infandum, then they throw away the element again because it knows it's not going to be needed
07:27:19 <tdammers> it's roughly comparable to unix pipes
07:27:39 <infandum> Cool, thank you!
07:27:39 <kqr> infandum, the reason Text packing/unpacking is expensive is not because the list is expensive, it's because when the Text object is unpacking itself it performs expensive operations
07:27:40 <tdammers> cat large-file | grep "hi" | head
07:28:01 <infandum> Then that would also have an overhead with Vector, right?
07:30:30 <puregreen> Gurkenglas_: if you're deriving your FromJSON instances automatically, you'd have to use fieldLabelModifier and/or some preprocessing
07:31:31 <OverCoder> Um, how do I do something like try/catch in Haskell? okay I know that I use the catch function, but, the thing is that it requires a handler and a function that does the operation, I need something simpler, I want to run some code, if it succeeds, return Just Parsed, and if it fails, return Nothing
07:31:36 <OverCoder> What can I do?
07:31:53 <infandum> kqr: Oh, you mean like Map.fromList is more expensive because it's actually creating a special structure with different properties than a pure list
07:32:11 <infandum> Like Set.toList should be nothing, while Set.fromList would be expensive?
07:32:28 <frerich> OverCoder: Can you post some code? One plausible way to model failure is to use 'Maybe', but it sounds like you're aware of Maybe already...
07:32:40 <kqr> infandum, not necessarily. i can't speak for those types specifically
07:32:57 <kqr> infandum, but the general idea is that converting to/from types can be expensive, but the list in between costs very little in comparison
07:32:58 <Gurkenglas_> puregreen: "constructorTagModifier :: String -> String -- Function applied to constructor tags which could be handy for lower-casing them for example." :D
07:33:17 <kqr> infandum, so even if you could convert directly from a sequence to a map, that would be roughly as expensive as converting with a list in between
07:33:22 <OverCoder> frerich, yeah but, I /want/ to use Maybe, but how do I?
07:33:27 <kqr> infandum, the bulk of the cost is in both ends
07:33:29 <OverCoder> how do I return Nothing when catch fails?
07:33:46 <puregreen> Gurkenglas_: for instance, if your field is called “transform” and in JSON it's “Transform”, you'd have to write parseJSON = genericParseJSON defaultOptions {fieldLabelModifier = over _head toUpper}
07:34:14 <coconut> if i find that several functions in my code use the same parameter, is this the moment to think of using a ReaderT ?
07:34:21 <kqr> OverCoder, what is throwing the exception?
07:34:56 <Gurkenglas_> puregreen, $(deriveJSON defaultOptions{constructorTagModifier = map toLower} ''MyRecord), using stuff from the page I found by searching for your fieldLabelModifier
07:35:03 <OverCoder> kqr, um, throw SomeException when something goes wrong
07:35:12 <OverCoder> But I don't want my function to throw an exception
07:35:15 <OverCoder> I want it to return Nothing
07:35:30 <OverCoder> Ugh my mind is still locked in the imperative programming
07:35:53 <frerich> OverCoder:  Do you throw that exception yourself?
07:36:06 <infandum> kqr: Got it, thanks
07:36:20 <OverCoder> frerich, um no
07:36:22 <OverCoder> Actually
07:36:25 <puregreen> Gurkenglas_: constructorTagModifier is for constructors of sum types, not for field names
07:36:42 <OverCoder> The function has to split a string and do some stuff on it, and then return a parsed string result
07:36:51 <OverCoder> Otherwise, return Nothing
07:37:02 <tdammers> OverCoder: Maybe is a Monad, maybe that helps
07:37:17 <OverCoder> hm, haven't learned about Monads yet haha :p
07:37:25 <kqr> OverCoder, can you show the code you have?
07:37:32 <OverCoder> kqr, yeah, just a second
07:37:41 <kqr> OverCoder, generally, you won't find simple haskell code that throws exceptions, so I suspect something has gone wrong earlier
07:38:25 <OverCoder> http://p.samuraimanpurse.com/pfDooWBs.txt
07:39:38 <fractalsea> Is there a way of transforming the type of the state in a StateT? In the same way that withReaderT let’s you modify the environment’s type
07:40:59 <kqr> OverCoder, ah so you haven't written any parsing code yet?
07:41:13 <puregreen> fractalsea: there's “zoom” in various lens libraries
07:41:26 <fractalsea> puregreen, ah thank you
07:41:27 <puregreen> I think there was also something else somewhere but I don't remember yet
07:41:29 <OverCoder> kqr, no, but I expect the code to sometimes fail, i.e. split on an empty string or something, cause you know, every IRC line is ifferent
07:41:54 <kqr> OverCoder, of course. the basic principle is that you can pattern match on your input data and based on that return Nothing
07:41:57 <kqr> OverCoder, so something like
07:42:28 <kqr> OverCoder, case user of { "" -> Nothing; "OverCoder!user@host" -> Just "OverCoder" }
07:42:45 <anohigisavay> is there multi-dimensional unboxed vectors?
07:43:56 <OverCoder> kqr, hm, okay I see but like, for example server could send "PING: some-string-here"
07:44:01 <OverCoder> Which can't be parsed at all, and not empty
07:44:07 <Jinxit> a single-dimensional vector can be made multidimensional with clever indexing
07:44:28 <OverCoder> In imperative langauges, I used to try the code and catch upon fails, and return an empty object
07:44:48 <kqr> OverCoder, and in Haskell, you'll have to check beforehand if it's going to fail, and then return Nothing
07:44:59 <anohigisavay> Jinxit: great. that makes sense
07:45:14 <OverCoder> kqr, there's no other way?
07:45:18 <Jinxit> OverCoder: if condition then Nothing else ...
07:45:37 <OverCoder> hm, okay many thanks guys
07:45:41 <kqr> OverCoder, well, (1) you *can* work with exceptions in Haskell, but I don't recommend it for a beginner
07:46:01 <kqr> OverCoder, and (2) I would suggest parsing with something like Attoparsec instead of hand-rolling your own parser, but that may be out of scope of what you're trying to learn
07:46:07 <Jinxit> keep in mind that the benefits of Maybe is not in its creation, but how you (don't) handle it later
07:46:34 <OverCoder> yeah I am trying to learn to use my first functional language, so no I won't use anything other than the main Haskell lib
07:46:50 <kqr> OverCoder, in Haskell we generally don't parse things manually by splitting strings; instead we build a description of the thing we want to parse, and then run a function that takes the description and an input and returns either a result or Nothing
07:47:07 <OverCoder> o
07:47:11 <OverCoder> Can you enlighten me a bit more?
07:47:22 <OverCoder> Like how would I search on how to do that? what's that called?
07:47:27 <Jinxit> I did it with Parsec
07:47:37 <Jinxit> it's reasonably easy to use
07:47:40 <frerich> OverCoder: Your 'parse' function already nicely communicates that it may fail to parse. It *Maybe* returns a 'Parsed'. You can use this in your 'handleIRC' function by ding something like 'case parse rawLine of Just msg -> <handle parsed message here>; Nothing -> return ()'
07:47:51 <Jinxit> it makes use of some higher concepts BUT you don't have to know them to use the lib itself
07:48:05 <kqr> OverCoder, the general concept is called "parser combinators". a popular library is called "attoparsec". another is called "parsec"
07:48:21 <OverCoder> hm, okay bunch of thanks
07:48:24 * OverCoder goes to search and code
07:48:40 <kqr> OverCoder, I personally prefer attoparsec over parsec because it clicks better with my mind in terms of backtracking (i.e. what does it do if the parsing fails – does it rewind until the last successful parse or does it try to go on)
07:49:01 <OverCoder> hm, awesome
07:49:54 <Jinxit> yeah, backtracking is a bit strange in parsec
07:50:10 <Jinxit> didn't know attoparsec did it differently - is it like a 'try' on everything?
07:50:18 <kqr> Jinxit, correct
07:50:25 <Jinxit> neat
07:50:30 <kqr> Jinxit, there is a try function in attoparsec but it's equal to id and is just there for compatibility
07:50:45 <Jinxit> ah
07:51:10 <Jinxit> isn't it a bit strange to provide compatibility shims when it works in a fundamentally different way? :)
07:51:24 <coconut> anybody uses sublime inside a stack sandbox ?
07:51:26 <`Guest00000> what about ReadP?
07:51:29 <kqr> Jinxit, haha maybe a little. i'm nowhere near smart enough to make decisions like that
07:51:43 <`Guest00000> it's simpler (it seems, about reading attoparsec's page on hackage)
07:51:51 <`Guest00000> s/about/after/ ...
07:52:08 <Jinxit> haven't heard of it
07:52:10 <kqr> `Guest00000, is that the thing in base?
07:52:18 <`Guest00000> yes
07:52:20 <Jinxit> easier is not always simpler btw
07:52:24 <kqr> then yes, that might be even better
07:52:27 <kqr> I should use it more often
07:52:29 <kqr> if it's good
07:52:49 <kqr> can't access hackage at the moment for some reason
07:54:01 <kqr> yeah I should start using readP much, much more
07:54:05 <kqr> I should probably write a tutorial for it too
07:55:40 <Cale> ReadP is nice because it has symmetric choice.
07:57:27 <kqr> i have no idea what that means but it's also nice because it's a simple parser combinator library with an understandable interface and it's in base
07:59:52 <anohigisavay> is it possible to use a monad with the same underlying monad transformer? say StateT X (State X)?
08:00:14 <anohigisavay> for the mtl version of monad transformers
08:00:36 <kqr> OverCoder, so... yeah. look at https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html
08:00:40 <kqr> OverCoder, it's part of the standard library
08:01:09 <OverCoder> amazing, thanks
08:02:48 <`Guest00000> anohigisavay: yes, but you will have to lift eveything you do with that monad
08:03:02 <`Guest00000> s/with/in/
08:04:36 <anohigisavay> ` it can distinguish the layer i'm operating with if i don't explicit call lift?
08:04:42 <anohigisavay> `Guest00000: 
08:04:55 <kqr> OverCoder, I'll throw up a quick example
08:05:25 <OverCoder> Would be great
08:05:47 <anohigisavay> `Guest00000: sorry, i mean it can tell that i'm working on the inner layer if no lift is called?
08:08:19 <pavonia> anohigisavay: It assumes you are working on the top-most layer if you don't use list
08:08:22 <pavonia> *lift
08:08:22 <`Guest00000> anohigisavay: no, it will use the topmost layer
08:09:14 * hackagebot console-program 0.4.1.0 - Interpret the command line and settings in a config file as commands and options  https://hackage.haskell.org/package/console-program-0.4.1.0 (AriePeterson)
08:09:16 <anohigisavay> `Guest00000: thanks. :) now i only need to know the way it works. will look into the implementation later
08:09:20 <`Guest00000> uh
08:09:41 <`Guest00000> if we say that StateT is topmost and State is lower level
08:09:44 <`Guest00000> .
08:11:06 <anohigisavay> `Guest00000: http://lpaste.net/150844
08:11:14 <anohigisavay> both versions work 
08:13:10 <`Guest00000> anohigisavay: try another combination of numbers / operations for testing... this way it's ambiguous
08:14:23 <dookie> hi, I was wondering if someone has examples using Partitioned arrays in Repa
08:14:59 <OverCoder> Um, how do I split something upon the /first/ occurrence of it? I am using Data.Text.splitOn for splitting, but it seems to split on every occurrence
08:16:28 <frerich> OverCoder: Maybe you are looking for 'span' or 'break'
08:16:37 <fractalsea> How do I combine the `at` function from lens to ignore `Maybe` values with fromJust? Basically I’m trying to modify the type of the state in a StateT with `zoom (at me . to fromJust)` but it’s failing with an error about functional dependencies, so I think I might be doing something stupid
08:16:40 <OverCoder> hm, let me check
08:17:07 <frerich> > span (/= ':') "foo:bar:yoyo"
08:17:09 <lambdabot>  ("foo",":bar:yoyo")
08:17:34 <OverCoder> hm, awesome, thanks
08:17:50 <`Guest00000> > break (== ':') "11:22:33"
08:17:52 <lambdabot>  ("11",":22:33")
08:18:09 <OverCoder> Is there a way I can make it omit the : ?
08:18:18 <OverCoder> like ("11", "22:33") ?
08:18:23 <diggle> Hi. Can anyone recommend me to any resources that comprehensibly cover haskell but having exercises? I followed the bitemyapp/learnhaskell thing on github, the first course has exercises which make my head hurt
08:18:53 <Ankhers> diggle: What issues were you having with the exercises? Maybe we can help you understand them.
08:19:19 <geekosaur> > fmap (drop 1) $ break (== ':') "11:22:33"
08:19:21 <lambdabot>  ("11","22:33")
08:19:36 <OverCoder> ooh thanks
08:20:20 <geekosaur> could also use tail there but then it errors if the second element is 1 character
08:20:21 <diggle> Like, the course explains a concept theoretically then there's an obrupt followup with a real world example,, it's just kind of confusing. I guess I just need to keep on trying though.
08:21:27 <nitrix> Any particuliar reason why fmap is implemented on the 2nd member of tuples?
08:21:38 <Ankhers> diggle: If you ever have questions, don't hesitate to ask.
08:22:33 <diggle> Ankhers: k, thanks :)
08:22:42 <Cale> nitrix: Work out the type
08:22:58 <Cale> nitrix: That's literally the only thing it can be, short of nonterminating
08:23:04 <nitrix> :t (,)
08:23:06 <lambdabot> a -> b -> (a, b)
08:23:11 <apsod> :k (,)
08:23:13 <lambdabot> * -> * -> *
08:23:13 <Cale> :t fmap
08:23:15 <Ankhers> nitrix: Same reason it operates on the Right of an Either.
08:23:15 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:23:26 <Cale> Substitute f t = (e,t)
08:23:38 <Cale> and you get  (a -> b) -> (e,a) -> (e,b)
08:24:03 <nitrix> Cale: Well, my question is why the substitute is (e,t) ?
08:24:14 * hackagebot plan-b 0.1.0 - Failure-tolerant file and directory editing  https://hackage.haskell.org/package/plan-b-0.1.0 (mrkkrp)
08:24:18 <Cale> Well, it's really (,) e which is the functor, right?
08:24:19 <haskell681> I am trying to the monad challenges from mightbyte and am stuck on implementing  maximumMay minimumMay from http://mightybyte.github.io/monad-challenges/pages/ex2-2.html and the functions from http://mightybyte.github.io/monad-challenges/pages/ex2-3.html that require you to use functions from the previous page that take give a Maybe value but the functions require a normal value.  The Maybe is not the normal Maybe monad but a cus
08:24:28 <frerich> Isn't it important to mention that the second argument to the type constructor (,) gives the type for the second tuple element?
08:24:36 <Cale> and it has to be that particular partial application because there's no type-level lambda
08:24:37 <nitrix> Cale: Oh, otherwise the kinds would be wrong?
08:24:41 <Cale> yep
08:24:56 <nitrix> That sounds limitating somehow.
08:25:04 <Cale> (and even if there were type lambda, it wouldn't interact well with type classes)
08:25:35 <Cale> Well, if you wanted it to apply to the other component, you could always make a newtype wrapper
08:25:45 <Cale> But that's kind of silly
08:25:47 <nitrix> Right.
08:26:05 <apsod> nitrix: Or, if you want more flexibility, use it as a bifunctor
08:26:07 <nitrix> Ah okay. Yeah, it might be silly but it's comforting to know that it's still possible.
08:26:29 <Cale> The end result is that you think of pairs as being like boxes with labels on them, and the label goes into the first component of the pair.
08:26:35 <nitrix> > (+1) <<$>> (1,1)
08:26:36 <Cale> For the same reason, we have:
08:26:37 <lambdabot>  Not in scope: ‘<<$>>’
08:26:43 <Cale> > length ("hello", "world")
08:26:45 <lambdabot>  1
08:26:55 <Cale> (using the Foldable instance)
08:26:57 <nitrix> Bifunctors doesn't seem to be in lambdabot :/
08:27:15 <`Guest00000> > (+1) *** (1,1)
08:27:16 <Ankhers> :t bimap
08:27:16 <lambdabot>      Couldn't match expected type ‘(b, c)’
08:27:17 <lambdabot>                  with actual type ‘Integer -> Integer’
08:27:17 <lambdabot>      In the first argument of ‘(***)’, namely ‘(+ 1)’
08:27:18 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
08:27:36 <`Guest00000> ah, wrong again.
08:27:50 <apsod> > first (+1) (1,"hello") 
08:27:52 <lambdabot>  (2,"hello")
08:27:53 <nitrix> Isn't *** an arrow?
08:27:56 <Cale> > bimap reverse (+1) ("hello", 5)
08:27:58 <lambdabot>  ("olleh",6)
08:28:09 <Cale> (***) is one of the Arrow operations
08:28:15 <Cale> :t (***)
08:28:16 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
08:28:29 <`Guest00000> is there synonym for \f -> f *** f   somewhere?
08:28:42 <Cale> No, but you can apply join if you like
08:28:58 <Cale> > join (***) reverse ("hello", "world")
08:29:00 <lambdabot>  ("olleh","dlrow")
08:29:31 <`Guest00000> ah, join for reader
08:29:38 <nitrix> @pl \f -> f *** f
08:29:38 <lambdabot> join (***)
08:31:04 <`Guest00000> so.
08:31:11 <`Guest00000> > join (***) (+1) (10, 20)
08:31:15 <lambdabot>  (11,21)
08:32:26 <kqr> OverCoder, http://lpaste.net/8153551397736939520
08:32:38 <kqr> OverCoder, scroll down for some usage notes
08:32:43 <OverCoder> kqr, whole bunch of thanks
08:32:44 <geoffreyiy> @pl (\n1 n2 n3 -> [n1,n2,n3])
08:32:45 <lambdabot> (. ((. return) . (:))) . (.) . (:)
08:32:49 <geoffreyiy> ugh
08:32:51 * OverCoder hugs kqr
08:34:26 <geoffreyiy> (Data.List.\\) [0..9] 5
08:34:38 <geoffreyiy> > (Data.List.\\) [0..9] 5
08:34:40 <lambdabot>      No instance for (Show a0)
08:34:40 <lambdabot>        arising from a use of ‘show_M516689811840982367714717’
08:34:40 <lambdabot>      The type variable ‘a0’ is ambiguous
08:35:03 <geoffreyiy> > [0..9] \\ 5
08:35:05 <lambdabot>      No instance for (Show a0)
08:35:05 <lambdabot>        arising from a use of ‘show_M27168347852688893214729’
08:35:05 <lambdabot>      The type variable ‘a0’ is ambiguous
08:35:17 <MarcelineVQ> :t (\\)
08:35:18 <puregreen> > [0..9] \\ [5]
08:35:19 <lambdabot> Eq a => [a] -> [a] -> [a]
08:35:20 <lambdabot>  [0,1,2,3,4,6,7,8,9]
08:35:27 <FPtje> Which wizards do I summon when I get linking errors of all things?
08:35:32 <geoffreyiy> ty
08:35:41 <puregreen> > delete 5 [0..9]
08:35:44 <lambdabot>  [0,1,2,3,4,6,7,8,9]
08:35:58 <nitrix> FPtje: which platfomr?
08:36:07 <FPtje> nitrix, Windows, ghc 7.10.1
08:36:15 <nitrix> FPtje: Which library?
08:36:26 <kqr> OverCoder, it's a bit dense because I've tried to give examples on as many possible use cases as I could come up with, but play around with it and ask a bunch of questions
08:36:38 <FPtje> nitrix, my own. I added a bunch of files to elm-compiler (which I´m editing)
08:36:46 <FPtje> that was fine. Importing it in an existing file was fine
08:37:00 <OverCoder> kqr, man, this paste is worth $$ to me :p
08:37:02 <FPtje> but using ANY of the functions or values from that library causes that to happen
08:37:15 <`Guest00000> i was thinking about
08:37:17 <OverCoder> It's awesome, I am reading it, and probably when i don't understand something, I'll ask about it
08:37:36 <`Guest00000> a way to write arbitrary expressions as infix operators
08:38:17 <`Guest00000> something like:   x `(foo bar)` y
08:38:37 <`Guest00000> so we could write:   x `(liftA2 (+))` y
08:38:46 <aweinstock> `Guest00000: how would x `(foo `bar` baz)` y work?
08:39:13 <`Guest00000> aweinstock: (foo `bar` baz) x y
08:39:17 <FPtje> Specifically, I made a bunch of modules called Type.Graph.*, Type.Graph.TypeGraph is the interface module there. I import qualified Type.Graph.TypeGraph as TG in Type.Solve in the elm-compiler project. The elm-compiler always builds, but when I use ANY of Type.Graph.TypeGraph´s exported functions in Type.Solve. A dependent project (elm-make) will fail to build with a linking error
08:39:29 <`Guest00000> i don't find that ambiguous
08:39:49 <aweinstock> I'm not saying it's ambiguous, I'm saying it might be hard to parse
08:40:06 <`Guest00000> sometimes i want to write a function infix
08:40:12 <`Guest00000> and that function is an expression
08:40:18 <OverCoder> kqr, I don't get it, what's the purpose of numberCommand?
08:41:21 <kqr> OverCoder, it's a parser that parses a numeric IRC command. it does this by first reading an integer, then ensuring the integer is not too big (IRC numeric commands can only be 000–999), and then converting it to the custom IRCCommand type
08:41:45 <FPtje> nitrix, any idea? :(
08:41:56 <`Guest00000> if i use let op = liftA2 (+) in x `op` y,    the op expression will be separated from x and y
08:42:17 <OverCoder> kqr, um, what numeric IRC commands? you mean like those who come from MOTD and stuff like that? (i.e. not PRIVMSG or similar?)
08:42:18 <`Guest00000> imagine x and y are larger expressions
08:42:23 <kqr> OverCoder, yes
08:42:26 <`Guest00000> larger than one letter
08:42:29 <OverCoder> Ooh, amazing
08:42:35 * OverCoder reads it more
08:42:52 <kqr> OverCoder, the IRC protocol specifies a few word commands like PRIVMSG, NOTICE, PING and such, but the majority of commands are number codes between 0 and 999
08:42:55 <OverCoder> kqr, sorry if I seem to read the examples somewhat slow but I am new to Haskell so it takes me a while to resolve stuff :>
08:43:02 <kqr> no that's fine
08:43:12 * OverCoder hugs kqr again
08:45:01 <geoffreyiy> @pl (\xs1 xs2 -> (take 2 xs1) == (take 2 xs2))
08:45:01 <lambdabot> (. take 2) . (==) . take 2
08:45:03 <kqr> rather slow and absorbing than fast and missing important details
08:45:03 <`Guest00000> let's hug, everybody...
08:45:18 <RyanGlScott> FPtje: I would make sure that Type.Graph.TypeGraph is declared in the export-modules file of the .cabal file
08:45:36 <`Guest00000> geoffreyiy: (==) `on` take 2
08:45:41 <RyanGlScott> If I have an unexplained linker error, that often is the cause
08:46:00 <RyanGlScott> (or other-modules, depending on if's exported or not)
08:47:04 <FPtje> RyanGlScott, Nasty. Thanks for the tip, I´m trying it out now
08:50:09 <haskell681> I am trying to the monad challenges from mightbyte and am stuck on implementing  maximumMay minimumMay from http://mightybyte.github.io/monad-challenges/pages/ex2-2.html and the functions from http://mightybyte.github.io/monad-challenges/pages/ex2-3.html that require you to use functions from the previous page that take give a Maybe value but the functions require a normal value.  The Maybe is not the normal Maybe monad but a cus
08:50:44 <fractalsea> Is there a version of the lens “at” function that throws an exception rather than returning Maybe when run?
08:51:13 <puregreen> fractalsea: use “ix” with ^?!
08:52:05 <fractalsea> puregreen, the problem is I’m trying to use it with `zoom`, and the value return by my monad is not a monoid, so I can’t use “ix”
08:52:21 <FPtje> RyanGlScott, That worked. Thanks! Nasty errors though!
08:52:42 <puregreen> then use singular
08:52:54 <Cale> haskell681: your message got cut off at "The Maybe is not the normal Maybe monad but a cu"
08:53:11 <`Guest00000> we have mappend in Prelude but not <>...
08:53:31 <puregreen> (I mean, “singular (ix key)” instead of “at key”)
08:54:00 <glguy> fractalcat: What you said about monoid might not make sense
08:54:00 <glguy> Prelude Control.Lens Control.Monad.State> runState (zoom (ix 'a') (put 'b')) (Data.Map.singleton 'z' 'z')
08:54:01 <glguy> ((),fromList [('z','z')])
08:54:15 <glguy> Maybe you could elaborate on the problem you're having?
08:54:44 <monochrom> haskell681: you can use pattern matching to say, for example: case lookupMay xxx yyy of { Nothing -> Nothing; Just v -> now go on to use maximumMay }
08:55:00 <glguy> not fractalcat, sorry, fractalsea
08:55:05 <`Guest00000> :t Max
08:55:07 <lambdabot>     Not in scope: data constructor ‘Max’
08:55:07 <lambdabot>     Perhaps you meant variable ‘max’ (imported from Data.Ord)
08:55:23 <OverCoder> kqr, okay so I was a bit confused in few stuff, first, what is readP_to_S ?
08:55:24 <`Guest00000> huh, no Max in Data.Monoid
08:55:41 <monochrom> and it is supposed to be a lot of these things, even nesting these things to deep levels. this is what they mean by "it will be annoying, this is the point".
08:55:55 <fractalsea> puregreen, ah great. I’ll try that. Thanks
08:56:27 <fractalsea> glguy, ha. Too much “cat”egorty theory?
08:56:28 <puregreen> fractalsea: now I'm wondering too what problem did you have with zoom and monoid, tho
08:56:49 <johnw> `Guest00000: there is a Max in the semigroups package
08:56:53 <fractalsea> OK hang on let me double check guys
08:57:21 <johnw> `Guest00000: and also in the monoids package
08:57:41 <Cale> OverCoder: It's the main way that you run ReadP parsers, it turns a parser of type ReadP a into a function String -> [(a,String)]
08:57:59 <OverCoder> Cale, ooh, hm, ty
08:58:34 <Cale> OverCoder: The reason for the name is that the Prelude contains a type synonym  type ReadS a = String -> [(a,String)]
08:59:04 <monochrom> yeah, the S stands for ReadS from Prelude
08:59:14 <OverCoder> awww
08:59:17 <OverCoder> gotcha
08:59:38 <monochrom> a java library author would say "FromReadPToReadS" :)
09:00:59 * puregreen is still weirded out by “writeList2Chan” in Control.Concurrent.Chan
09:02:15 <fractalsea> puregreen, glguy, using `singular worked. Thank you. I basically meant that I had a StateT over a monad that returned a Bool when run, and `zoom` requires the returned value to be a Monoid for Traversals, which Bool isn’t.
09:03:32 <geoffreyiy> writeList2Chan ^2 == writeList4Chan
09:04:10 <glguy> fractalsea: OK, makes sense :)
09:05:19 <kqr> OverCoder: readP_to_S is a confusingly named function that takes a parser, a string and returns all successful parses in a list
09:06:18 <kqr> OverCoder: so the list is empty if the parsing failed, contains many elements if the parser is ambiguous, and a single element otherwise
09:07:01 <OverCoder> hm, gotcha, thanks
09:09:35 <geoffreyiy> > compare '*' 'a'
09:09:37 <lambdabot>  LT
09:26:27 <nitrix> > [' '..'~'] :: [Char]
09:26:30 <lambdabot>  " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefgh...
09:29:34 <mjhoy> does anyone run into problems using ghc-mod and working on a test-suite?
09:30:06 <mjhoy> ...it doesn't seem to be correctly configuring hs-source-dirs
09:48:40 <Nsc_Code> hi all greetings, can u teach me about hack pp,cc,etc..
09:49:29 <hodapp> hack pp,cc,etc?
09:51:22 <Nsc_Code> yes ,, tutorial and carding 
09:51:26 <Nsc_Code> and tools
09:51:48 <saurabhnanda> hey, I have a bit of a philosophical question. I'm writing a Telegram bot which responds to certain commands. Those commands will be honored only if the have a valid auth-token with them. I have a data-type to represent the different types of commands. How do I incorporate the auth constraint into the haskell type system? Here's my approach: is it possible to make UserId a required field of all the command types AND have only one 
09:52:52 <Cale> saurabhnanda: your message was possibly cut off at "AND have only one"
09:53:13 <saurabhnanda> ... a Command object. The constructor will look-up the DB and ensure that the token is valid before allowing the Command object to be instantiated. Thus not allowing anyone to represent an un-authenticated command.
09:53:19 <Cale> saurabhnanda: But what I'd do there is just to make a new datatype pairing the UserId/auth-token with the command
09:53:47 <saurabhnanda> Cale: fair point
09:54:25 <saurabhnanda> the larger question is about using the type-system to make sure no Command can be instantiated without going through the auth-check
09:54:54 <saurabhnanda> basically, trying to see how exactly a strong type-system can be used to model business constraints
09:55:04 * hackagebot rank1dynamic 0.3.1.1 - Like Data.Dynamic/Data.Typeable but with support for rank-1 polymorphic types  https://hackage.haskell.org/package/rank1dynamic-0.3.1.1 (FacundoDominguez)
09:55:39 <saurabhnanda> is hackagebot talking to me?
09:56:01 <Nsc_Code> no ,, i english bad
09:56:44 <hodapp> saurabhnanda: hope, hackagebot is just giving announcements about updates
09:57:23 <saurabhnanda> Cale: any thoughts?
09:58:18 <Nsc_Code> i understand ,, i know that ,,, i hope a new trick about that
09:58:56 <Cale> Nsc_Code: I don't think anyone understands what you're looking for. Is it related to the programming language Haskell? If not, you're in the wrong place.
10:01:54 <Cale> saurabhnanda: I'm just saying to effectively change your definition of what a command is such that it includes that information.
10:02:51 <saurabhnanda> Cale: is that it?
10:03:31 <Cale> saurabhnanda: I mean, it can be... unless that for some reason doesn't immediately solve the problem.
10:04:02 <puregreen> saurabhnanda: how is the token transmitted? could you give a made-up log of a user talking to your bot?
10:04:17 <saurabhnanda> Cale: http://lpaste.net/150851  -- how do I make sure that that the ONLY way to create an AuthNightwatchCommand is via fromIncomingMsg :: NightwatchCommand -> AuthNightwatchCommand 
10:04:55 <saurabhnanda> puregreen: an incoming telegram message -- status <some-id> <token>
10:05:10 <saurabhnanda> puregreen: the token is validated against a DB table to ensure that it's still valid
10:05:47 <Nsc_Code> owh thanks for info
10:06:09 <puregreen> saurabhnanda: and if it's still valid, all subsequent commands from the user are accepted?
10:06:49 <puregreen> as for the AuthNightwatchCommand question, you could probably just hide the constructor in another module
10:07:20 <saurabhnanda> puregreen: everycommand that the user sends needs to have a the auth-token
10:07:24 <puregreen> ah
10:07:54 <saurabhnanda> puregreen: that occurred to me, but that seems like using convention to solve the problem, not compiler-enforced type-safety
10:08:32 <saurabhnanda> puregreen: it's like hiding the key under the doormat
10:08:41 <Cale> saurabhnanda: Put it in a module, and don't export the data constructors of that type, only export fromIncomingMsg
10:10:06 <saurabhnanda> Cale: puregreen: how do I not export a constructor?
10:11:17 <Cale> saurabhnanda: Write an explicit export list like  module Nightwatch (NightWatchCommand(..), AuthNightwatchCommand, fromIncomingMsg) where
10:11:31 <Cale> saurabhnanda: The (..) after the name of a type will export all its data constructors
10:11:39 <Cale> leaving that out will mean none are exported
10:12:19 <saurabhnanda> ah okay
10:12:34 <saurabhnanda> so that's a solution. But is it the philosophically correct solution?   :-)
10:12:40 <Cale> yes
10:13:18 <Cale> The module system is the primary way to hide and abstract the implementation details of data types in Haskell.
10:14:25 <mizu_no_oto> In particular, you can export a type from a module without also exporting its constructors
10:29:17 <mnoonan> Is there a commonly used type for 1 + X + Y?  Maybe (Either a b) works but feels a little tacky.
10:30:14 * hackagebot configifier 0.1.0 - parser for config files, shell variables, command line args.  https://hackage.haskell.org/package/configifier-0.1.0 (MatthiasFischmann)
10:31:04 <sm> configifier, eh
10:31:36 <sm> MatthiasFischmann, if you're here: you missed docopt
10:32:54 <killerstorm> Hi! I need some advice on polymorphism... I'm trying to make a toolkit kind of a thing which will have some generic structure and a number of different (very different) concrete implementations. Thus I think I could make use of polymorphism. In C++ I'd do that using templates and interfaces, seems to be quite straightforward. In haskell typeclasses are analogous to that. 
10:33:21 <killerstorm> Here's what I wrote so far: https://gist.github.com/killerstorm/ce39d7214a2015cedf8d it looks quite a bit weird... perhaps I'm approaching it from the wrong end?
10:35:14 * hackagebot distributed-process-tests 0.4.3.3 - Tests and test support tools for distributed-process.  https://hackage.haskell.org/package/distributed-process-tests-0.4.3.3 (FacundoDominguez)
10:44:48 <geekosaur> killerstorm, often records of functions are better for that
10:46:46 <geekosaur> typeclasses are similar yet different, and using them the way you'd use templates can lead you to unexpected type conundrums. (for one thing, Haskell can select a typeclass based on an expected return type. for another, type inference sometimes works backwards from what you'd expect from C++: a more inclusive result type does not mean your function can choose to return anything that could fit it, but that your function must be prepared to retur
10:46:46 <geekosaur> n anything the *caller* chooses.)
10:46:49 <IlanGodik> Is there an alias for liftA2 (,)?
10:48:35 <puregreen> IlanGodik: there doesn't seem to be any in base, according to Hoogle
10:48:44 <puregreen> Hayoo can't find anything like that either
10:48:53 <IlanGodik> kinda strange, eh?
10:51:16 <killerstorm> geekosaur, is there any article about "records of functions" approach? I'd like to learn more about potential drawbacks and limitations
11:04:04 <mizu_no_oto> killerstorm: see e.g. https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ 
11:06:22 <mizu_no_oto> Essentially, it's the classic way people do OO style stuff in C 
11:08:27 <mizu_no_oto> Compared with typeclasses, the main advantage is that it handles "heterogenous" collections well
11:09:12 <OverCoder> say I have ["abc", "def", "ghi", "jkl"]
11:09:23 <OverCoder> How do I get the second element and beyond?
11:09:30 <frerich> OverCoder: That's the "tail"
11:09:34 <OverCoder> ayyyyy
11:09:36 * OverCoder slaps himself
11:09:39 <OverCoder> How did I forget that
11:11:28 <geekosaur> could be worse; we could have used the lisp names >.>
11:11:31 <exio4> OverCoder: you want to pattern match though
11:11:40 <exio4> geekosaur: cddr? :D
11:11:53 <geekosaur> just cdr, here
11:12:11 <OverCoder> OverCoder, no
11:12:17 * geekosaur likes head and tail as names much better than car and cdr
11:12:48 <kazagistar> yeah, but then you cant have caaddaar :P
11:13:13 <geekosaur> I'll pattern match that one, thanks --- more likely to catch typoes
11:13:57 <geekosaur> (also arguably if you need that one, you're doing it wrong. we have this type system...)
11:15:32 <mizu_no_oto> I suppose you could also define hetatatahead or htth or something
11:16:01 <geekosaur> even with warts that inspired e.g. lens, it's better than cadadadddadadddaaaaaadadadadr
11:16:18 <sm> heh
11:16:46 * puregreen is so tempted right now to make a package containing functions like “hetatatahead” solely because then ne'd be able to call the package “hetatatahead” as well
11:17:02 <killerstorm> mizu_no_oto, thanks!
11:17:10 <sm> I can see that coming as a DSL. Simplify your lens operators! dramatic improvement!
11:17:37 <sm> we'll need more letters
11:17:40 <geekosaur> as impenetrable as lens stuff can be, I'll take it over that
11:17:53 <puregreen> sm: we already have this thing: http://hackage.haskell.org/package/tuple-lenses-0.1.0.2/docs/Data-Tuple-Lens.html
11:18:04 <puregreen> pretty close in spirit
11:18:05 <hpc> puregreen: name it heady-lamarr and make it a TH call that generates all the hetatatatatail functions of a given length
11:18:52 <sm> woah
11:19:11 <sm> I'm totally going to use that
11:19:19 <bergmark> you can also generate source files in Setup.hs, no TH needed!
11:19:27 <mizu_no_oto> killerstorm: the most interesting thing that typeclasses can do is return type polymorphism
11:19:30 <hpc> heh
11:19:30 <puregreen> also see http://hackage.haskell.org/package/acme-cadre-0.1/docs/Acme-Cadre.html
11:19:39 <hpc> have it decide how far to go from an environment variable
11:19:41 <puregreen> bergmark: nice, didn't know that
11:19:49 <mizu_no_oto> hpc: isn't that just asking to be sued, much like Blazing Saddles?
11:19:53 <mizu_no_oto> :p
11:20:32 <mizu_no_oto> killerstorm: what kind of generic structure are you trying to define, exactly?
11:20:44 <geekosaur> also one could take as evidence that even lispers are uncomfortable with that stuff, that they didn't provide a way to macro some other letter and use it in a c*r (defcmacro b 'ddda) (cabdbdaabr)
11:21:21 <hpc> wait, it's not arbitrary in lisps either?
11:22:47 <bergmark> i enjoyed it when my lisp professor read these function names of his slides
11:23:10 <hpc> "ca-duh-duh-duh-duh-dar"
11:23:53 <xnil> I'm using Pandoc + .lhs + Markdown. I want to add Haddock there. How do I structure Haddock comments, since I'm using Markdown? Or is this a good idea at all? Should I forego Haddock if I'm using lhs/markdown?
11:24:43 <xnil> hpc: cad^5r
11:26:11 <dsub> Anyone using the statusbar xmobar? I'm trying to launch it, but when I call xmobar from terminal I get "hGetContents: invalid argument (invalid byte sequence)". Any suggestions for how to troubleshoot?
11:27:38 <xnil> Is LHS/Markdown a bad idea, and I should stick with Haddock and typical Haskell comments?
11:28:21 <synthmeat> is it possible to force pandoc to include css file that does not exist?
11:28:57 <synthmeat> (markdown->html, --css someFileThatWillBePresentLater.css)
11:29:26 <xnil> I'm going to head over to StackOverflow since this answer is pretty urgent. Please let me know if you have an answer, anyone.
11:29:44 <sm> xnil: what's your goal ?
11:30:00 <xnil> "How do I structure Haddock comments, since I'm using Markdown?" that specifically
11:30:33 <sm> are you eg including some literate haskell in a markdown blog post ?
11:31:14 <puregreen> synthmeat: it seems to be possible
11:31:26 <xnil> sm: No. I want to use LHS and Markdown together because I enjoy the elegance and purity of Markdown
11:31:42 <xnil> I know LHS/MD is possible. Pandoc has a mode for it.
11:31:48 <synthmeat> puregreen: it fails to build the file for me with "no such file or directory" :/
11:31:50 <xnil> I want to know if LHS/MD + Haddock is feasible.
11:32:55 <puregreen> synthmeat: hm, it doesn't for me
11:33:26 <puregreen> synthmeat: here's the exact command I'm using: pandoc -f markdown -t html -o x.html --css doesnotexist.css x.md
11:34:26 <xnil> Nevermind. I think I'm going to JUST use Haddock and typical Haskell.
11:34:32 <synthmeat> puregreen: that's a fair bit different flags than mine...
11:34:36 <synthmeat> pandoc --toc --from=markdown --standalone --to=html5 --mathjax topics/calculus/apostol.md -o release/apostol.html
11:34:59 <OverCoder> ammm, how do I concat a list into a single string? foldl?
11:35:02 <synthmeat> (lol, forgot "-c style.css")
11:35:33 <kadoban> OverCoder: What do you have and what do you want?
11:36:16 <puregreen> synthmeat: no, still works for me
11:36:19 <puregreen> pandoc --toc --from=markdown --standalone --to=html5 --mathjax x.md -c doesnotexist.css -o x.html
11:37:05 <puregreen> does it work fine without “-c style.css”?
11:37:11 <synthmeat> yup, all fine
11:37:16 <OverCoder> kadoban, ["abc", "def", "fgh"], I want it to be "abcdefgh"
11:37:29 <opqdonut> > concat ["abc", "def", "fgh"]
11:37:30 <synthmeat> and i've just tested this on 3 OS', just to be sure is my pandoc install borked :/
11:37:31 <lambdabot>  "abcdeffgh"
11:37:37 <OverCoder> aw, ah right
11:37:39 <OverCoder> Thanks
11:37:41 <opqdonut> oh right, no double f?
11:37:43 <opqdonut> oh ok
11:38:09 <ed123> can someone help me understand and fix this Criterion benchmark code: http://lpaste.net/150793
11:38:17 <Gurkenglas> > nub "abcdeffgh" -- Overcoder, this? Not specified enough.
11:38:19 <lambdabot>  "abcdefgh"
11:38:34 <Gurkenglas> (Beware quadratic time.)
11:38:45 <synthmeat> puregreen: i apologize, i've interspersed it amongst filters list. brainfart. sorry to have taken your time. thank you
11:38:47 <hpc> > nub "aba"
11:38:49 <lambdabot>  "ab"
11:39:01 <puregreen> synthmeat: nevermind :)
11:39:03 <synthmeat> puregreen: (for being a rubber duck :)
11:39:09 <ed123> the code runs, but doesn't benchmark correctly: http://lpaste.net/150793
11:39:34 <OverCoder> Gurkenglas, nah never mind, got things to work
11:40:05 <Gurkenglas> Cmon you can't leave the ircbrowse readers of the future hanging like that!
11:40:08 * synthmeat thinks there should be #rubberduck, where you just rant about the error you're having until you solve it
11:41:16 <puregreen> that's a nice idea
11:41:46 <synthmeat> possibly good platform for interesting bots too
11:41:57 <Gurkenglas> ed123, define "doesn't benchmark correctly".
11:42:11 <Gurkenglas> synthmeat, you mean something like ELIZA, optimized for rubberducking usefully?
11:42:32 <synthmeat> Gurkenglas: never heard of it, but i assumed there's such things, yes
11:43:36 <Gurkenglas> ELIZA is a super old chatbot that does a decent impression of an amnesiac goldfish-memory child pretending to be a psychiatrist
11:44:57 <hpc> what if there was a #denvercoder9 channel, like https://xkcd.com/979/
11:45:20 <hpc> the only valid inputs are "program: had this problem and fixed it with <link>"
11:45:22 <hpc> and searching by program
11:45:54 <puregreen> hpc: shhhh, that's, like, my startup idea
11:45:57 <puregreen> was
11:46:00 <hpc> hah!
11:46:11 <synthmeat> :)
11:47:30 * geekosaur knows several people who were recently scooped on their theses... must be going around >.>
11:55:30 * hackagebot natural-transformation 0.3 - A natural transformation package.  https://hackage.haskell.org/package/natural-transformation-0.3 (AndyGill)
11:57:34 <Gurkenglas> hpc, supply would be minimal to the point where searching comes in priority after the dun dun dun second google page?
12:09:15 <cybot> helloo
12:10:07 <cybot> hello high
12:10:43 <cybot> yayyyyyyyyyyy
12:15:31 * hackagebot hscolour 1.24 - Colourise Haskell code.  https://hackage.haskell.org/package/hscolour-1.24 (MalcolmWallace)
12:24:33 <edwinpeguero> can someone help me understand why this Criterion benchmark code reports times of a few milliseconds? http://lpaste.net/150793 
12:26:18 <OverCoder> um, aw
12:26:39 <OverCoder> when I use concat, the list gets concatnated, it doesn't add spaces between elements
12:26:40 <OverCoder> like
12:26:48 <OverCoder> ah wait, I need unwords
12:34:08 <izohask> anyone knows what does it mean '[JSON] in Servant API
12:34:21 <izohask> why is that single-quot there ? 
12:34:35 <izohask>  Get '[JSON] [User]
12:34:41 <izohask> (e.g.) 
12:35:09 <izohask> why not "Get [JSON] [User]"
12:35:57 <exio4> izohask: it's a type-level list (I don't remember servant's API currently so I can't say what it exactly means for the program, though)
12:36:29 <Ankhers> That is the content types.
12:36:29 <izohask> aha... so I can consider this is diferent list type  ? 
12:36:49 <exio4> izohask: you need to specify it's a type-level list, because it could be either a type-level list (with a single element 'JSON') or "a list of JSONs"
12:37:10 <ed123> can someone help me with some Criterion benchmarking code?
12:37:25 <Ankhers> ed123: Feel free to just ask your question.
12:38:26 <ed123> ok; I have this code (http://lpaste.net/150793), but running it returns times that are too short (e.g., a microsecond).
12:38:29 <OverCoder> http://p.samuraimanpurse.com/6x4eHwMA.txt
12:38:40 <OverCoder> exio4, awww, you're the same guy I know?
12:38:50 <exio4> OverCoder: I think so
12:38:58 <OverCoder> haha nice
12:40:27 <izohask> exio4: thanks, I have to dig in type-level lists, OK I got it
12:40:47 <ed123> \msg Ankhers can you help me understand why the benchmark returns inaccurate (too small) numbers? (http://lpaste.net/150793)
12:41:29 <Ankhers> ed123: I haven't actually used criterion, so I'm not really the person to ask. But asking in the open here, if someone knows the answer, they would generally give you one.
12:42:08 <Gurkenglas> ed123, one way I can think of to approach this sort of problem is to insert undefined into your code somewhere, run it and see if it crashes, to see whether that part is even evaluated. If you want more of an inside view, I'll need more of your code. (What is defaultMain?)
12:42:29 <Welkin> the critter package :D
12:46:33 <Strukks> How do I get it to clean the "stack" or w/e for  " <- getChar" after the function finishes, so I can run it again?
12:47:14 <Jeanne-Kamikaze> you mean the trailing newline ?
12:47:19 <ed123> default main is part of the criterion package. defaultMain :: [Benchmark] -> IO ()
12:47:47 <ed123> I'll try inserting undefined in somewhere
12:53:01 <adam___> do you guys have any recommendation for good talks related to haskell?
12:54:17 <Gurkenglas> Oh right Debug.Trace is also good for that kinda thing
12:55:12 <Gurkenglas> (Although it does carry the risk of people thinking they can reliably use it for output)
13:02:16 <puregreen> Strukks: what do you mean?
13:02:31 <OverCoder> Can I try/catch on non-IO code?
13:02:45 <puregreen> OverCoder: you can if you use evaluate
13:02:58 <OverCoder> what's evaluate? and why?
13:03:01 <puregreen> http://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:evaluate
13:03:06 <OverCoder> hm, Okay
13:03:08 <Strukks> puregreen: I think I understood it wrong and the error was elsewhere, nvm ^^
13:03:30 <hiptobecubic> adam___, there are a zillion. look on skillsmatter or for anything from lambdaconf
13:03:31 <puregreen> OverCoder: because e.g. “return undefined” never evaluates undefined and it won't throw any errors
13:03:43 <Strukks> What is "$ !"?
13:04:02 <exio4> OverCoder: you can't catch arbitrary exceptions from non-IO code
13:04:04 <OverCoder> Well, actually I want to tail some list, but I don't know that list, so sometimes it throws an exception
13:04:06 <Clint> edwardk: is there some kind of magical plan to unify ansi-wl-pprint and wl-pprint-extras?
13:04:10 <OverCoder> I want to return Nothing upon that
13:04:18 <exio4> OverCoder: you should use pattern matching for that.
13:04:29 <puregreen> OverCoder: just check the list manually, or use something from the safe package
13:04:32 <puregreen> @hackage safe
13:04:33 <lambdabot> http://hackage.haskell.org/package/safe
13:04:33 <OverCoder> It's really more complicated that using pattern matching
13:04:40 <exio4> OverCoder: ... how so?
13:04:45 <OverCoder> exio4, let me show you
13:05:06 <OverCoder> exio4, http://p.samuraimanpurse.com/1BBYm6mN.txt
13:05:08 <exio4> fun xs@(_:ts) = {- code that uses xs for the whole list, ts for the tail -} 
13:05:11 <exio4> fun [] = Nothing
13:05:53 <exio4> OverCoder: that code is awful
13:06:02 <OverCoder> ..well I know
13:06:10 <exio4> OverCoder: and if you're writing a parser, you can use parser combinators.
13:06:32 <OverCoder> somebody here told me to use Parsec, but unfortunately I found it too hard to use, so I bookmarked it (and the guy's paste) for tomorrow or something
13:06:40 <puregreen> and you can also use “state” in this case
13:06:55 <Gurkenglas> :t tailMay
13:06:56 <exio4> OverCoder: I am not going to read the code there, but using !! is pretty much code smell, btw
13:06:56 <lambdabot> [a] -> Maybe [a]
13:06:57 <puregreen> which will handle chaining of “break”s for you
13:07:13 <exio4> OverCoder: you btw, don't really need to do any of this for IRC messages
13:07:14 <Gurkenglas> :t StateT uncons
13:07:16 <lambdabot> StateT [a] Maybe a
13:07:20 <OverCoder> exio4, um, so you think my only option is parser combinators?
13:07:27 <OverCoder> aw, how?
13:07:42 <exio4> OverCoder: you can just use an irc library which does the parsing for you, in a non-broken way.
13:07:51 <exio4> OverCoder: s/an irc library/a library/
13:08:06 <OverCoder> well yeah but I need to practice haskell, so no
13:08:22 <exio4> (by the way, your code is wrong per the IRC specification)
13:08:38 <OverCoder> exio4, really? how?
13:08:52 <exio4> a irc (raw) message might not have an "user" or an "ident", it doesn't need a :
13:09:05 <OverCoder> ayyyy
13:09:06 <OverCoder> ugh
13:09:08 <OverCoder> pfft
13:09:16 <OverCoder> Gonna use IRC parser lib >.>
13:09:22 <OverCoder> Any suggestions?
13:09:43 <kaizoku> not sure what you're doing OverCoder 
13:09:47 <kaizoku> i've been using irc-client recently
13:09:52 <kaizoku> but i'm not parsing irc really
13:09:58 <OverCoder> hm
13:09:58 <kaizoku> just using the library to build a bot
13:10:08 <OverCoder> No I want to only parse..
13:10:12 <exio4> OverCoder: my hand-written IRC parser (using attoparsec, which is a parser combinators library), is in the 50~ loc range
13:10:13 <kaizoku> Ah, kk
13:10:26 <exio4> there's 'irc', if I remember correctly, haven't used it myself.
13:10:43 <OverCoder> '50~ loc range' ?
13:10:49 <kaizoku> lines of code
13:11:00 <OverCoder> hm, okay if it works, link to me
13:11:08 <kaizoku> i would like to check it out as well actually
13:11:18 <kaizoku> this attoparsec stuff is magic to me, i still never really used it
13:11:21 <glguy> My favorite IRC format surprise is that there are a maximum of 14 "middle" parameters
13:11:56 <glguy> and then the : becomes optional for the final parameter
13:12:20 <exio4> glguy: really? the BNF I used didn't see that in the BNF spec I saw
13:12:24 <glguy> https://tools.ietf.org/html/rfc2812
13:12:50 <glguy> And the daemon Freenode uses respects that
13:13:12 <glguy> Look for section 2.3.1
13:13:20 <edwinpeguero> this Criterion stuff is killing me… I still can’t seem to figure out why it’s behaving as it is
13:13:45 <OverCoder> exio4, um, your own library name? link? something? :P
13:14:29 <epeg> I’ve placed undefined’s in several places, and it behaves as expected (exception with nf and no exception with whnf). Still, I get times that are way too small.
13:16:15 <exio4> glguy: oh, awful.
13:17:02 <exio4> OverCoder: it's not very usable without other big chunk of code, so I haven't released it (it's in github though, if you wanna peek, but still), you could use this as a way to learn parser combinators though
13:17:40 <OverCoder> hm, gotcha, thanks
13:17:56 <glguy> OverCoder: This is what I use https://github.com/glguy/irc-core/blob/master/src/Irc/Format.hs
13:18:04 <glguy> using the attoparsec parser combinator library
13:18:19 <OverCoder> well I found Network.IRC.Parser in irc package
13:18:23 <OverCoder> Seems cool enough
13:18:32 <OverCoder> But why would it require ByteString as input >.>
13:19:21 <puregreen> OverCoder: because IRC is a network protocol
13:19:28 <OverCoder> and?
13:19:34 <OverCoder> I get the input as a string
13:19:57 <puregreen> then you're probably also getting input wrong
13:20:28 <puregreen> Haskell libraries are often optimised for use in “production” more than for meddling
13:20:31 <frerich> glguy: I can see that the 14-parameter constant impressed you enough to give that number a dedicated definition :^)
13:20:40 <puregreen> an ideal library would support both strings and bytestrings, of course
13:21:05 <glguy> frerich: I expected that the next time I read that code I would find myself wondering why I tucked the number 14 in the middle of the parser :)
13:21:06 <puregreen> but people who actually write Haskell libraries seem to be leaning to the production side
13:22:49 <puregreen> “we'll stick a lens dependency here, who is going to care”, “there's no reason for Aeson to include a Text→JSON parser out of the box because people should be using bytestrings anyway”, etc
13:22:50 <Welkin> who came up with the purple color scheme used on the new haskell.org site?
13:23:09 <Welkin> and the purple logo
13:23:11 <Welkin> I like it
13:23:22 <OverCoder> puregreen, hGetLine is wrong?
13:25:03 <puregreen> OverCoder: yes, and so are most IO functions in base
13:25:11 <puregreen> “wrong” as in “not production-grade enough”
13:25:12 <OverCoder> awww
13:25:15 <OverCoder> What should I use?
13:26:14 <puregreen> probably hGetLine anyway, just convert it to bytestring
13:26:27 <OverCoder> Lazy one, right?
13:26:33 <puregreen> if you decide to use conduit/attoparsec/etc right now you'll probably end up being very frustrated and won't write anything
13:27:07 <OverCoder> Yeah I see, I haven't even learned about Monads
13:27:10 <Welkin> if you want a parser, use parsec
13:27:15 <Welkin> it is fun and easy to use
13:27:28 <OverCoder> Welkin, I've found it very difficult
13:27:57 <Welkin> OverCoder: you may want to go through the cis194 course then first
13:28:00 <Welkin> to cover the basics of haskell
13:28:16 <OverCoder> I've learned up to the part 9 in LYAH
13:28:23 <Welkin> lyah will not help you program
13:28:28 <OverCoder> (I still miss some stuff)
13:28:33 <Welkin> it is a fun introduction, but it is not enough to write real programs
13:28:44 <OverCoder> Well I usually learn by making stuff
13:28:51 <Welkin> cis194 has lots of exercises/homework
13:28:53 <OverCoder> So I decided to start with an IRC bot, as I used in other langauges
13:29:01 <OverCoder> But I don't seem to get it to at least work
13:29:05 <OverCoder> hm, interesting
13:29:14 <Welkin> @where learnhaskell
13:29:14 <lambdabot> https://github.com/bitemyapp/learnhaskell
13:29:16 <Welkin> go there
13:29:24 <Welkin> also, join #haskell-beginners for help with the course
13:29:37 <OverCoder> ooh, awesome
13:29:53 <Welkin> more specifically, https://github.com/bitemyapp/learnhaskell#how-should-i-learn-haskell
13:29:54 <puregreen> OverCoder: finish your IRC thing using whatever means available (errors everywhere, unsafe functions, incomplete IRC specification, anything you want), feel good about having finished something, then we'll help you see what's wrong with it and how it could be made better – and as a bonus, many solutions to common problems and annoyances are much easier to comprehend once you've actually suffered thru those annoyances
13:30:28 <OverCoder> hmmmm
13:30:30 <OverCoder> awesome
13:30:56 <Welkin> you actually write a parser as part of that course
13:31:04 <Welkin> so you will understand how parsec works
13:31:38 <Gurkenglas> > splitOneOf "!@/ " "SomeNick!SomeUsername@unaffiliated/SomeHost PRIVMSG #SomeChan :SomeCommand SomeArgument1 SomeArgument2" -- Overcoder
13:31:40 <OverCoder> But Parsec was so hard ;_;
13:31:40 <lambdabot>  ["SomeNick","SomeUsername","unaffiliated","SomeHost","PRIVMSG","#SomeChan","...
13:31:58 <OverCoder> Gurkenglas, :O
13:32:12 * OverCoder shrinks
13:32:22 <Welkin> OverCoder: also, you may find this helpful https://wiki.haskell.org/Roll_your_own_IRC_bot
13:32:34 <exio4> OverCoder: I'd say "Everything I know is hard"
13:32:40 <Welkin> I used that to write a simple irc bot in about 30 minutes
13:32:51 <OverCoder> hmmmmm
13:33:00 <OverCoder> Well, thank you all!
13:33:03 <Welkin> most of that time was understanding the irc protocol
13:33:53 <frerich> OverCoder: One thing which is somewhat independent of IRC but still useful and fun is to roll your own little parser combinator library. It's quite easy and makes it much easier to understand things like parsec and attoparsec and whatnot.
13:34:48 <Welkin> frerich: cis194 covers that
13:35:18 <OverCoder> hm
13:35:25 <OverCoder> Okay okay
13:35:26 <Gurkenglas> In fact, I'm still just using StateT String instead of parsec because I already knew monad transformers and lots of arcane libraries work with it
13:35:27 * OverCoder thinks
13:36:02 <OverCoder> Okay I think I am totally lost and missing lot of stuff, and especially mind being stuck in imperative thinking, I'll learn Haskell through the metioned tutorial
13:36:13 <puregreen> Welkin: I think the new page was designed by Chris Done: http://chrisdone.com/posts/haskell-lang
13:36:14 <OverCoder> s/learn Haskell/learn Haskell again/
13:36:23 <frerich> OverCoder: The first three pages of http://www.cs.nott.ac.uk/~pszgmh/pearl.pdf are like 75% of what you need to know.
13:36:38 <Welkin> OverCoder: I had to start many times, so it took a while
13:36:44 <OverCoder> hm
13:36:52 <puregreen> Welkin: here's the original mockup: http://chrisdone.com/comp.png
13:36:54 <Welkin> I just keep working at it and eventually it made sense
13:37:21 <OverCoder> hmm
13:37:32 <Welkin> but yes, LYAH is not enough
13:37:41 <Welkin> cis194 and the nicta course are what you need
13:37:54 <Welkin> and working on some kind of project and asing lots of questions
13:38:02 <Welkin> asking*
13:38:05 <OverCoder> .. Okay, starting with cis194
13:38:32 <OverCoder> yeah i tried to stick what I learned in LYAH to my mind through IRC, but seems like I can't make an IRC bot with such knowledge, so meh
13:39:18 <Welkin> the main problem is there are no exercises and many important things are mentioned only briefly
13:42:12 <Gurkenglas> > evalStateT (manyLazy $ StateT uncons) [1..] -- In this context, let me once again show off my lazy version of many http://lpaste.net/150561 , some version of which should be integrated into Alternative because many (Just 2) really should be many (repeat 2).
13:42:14 <lambdabot>  Just [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
13:42:33 <Gurkenglas> -many (repeat 2) + Just (repeat 2)
13:44:01 <kqr> kaizoku, ReadP is a parser combinator library in base. here are some examples on how to use it to go by while I try to find time to write the full tutorial: http://lpaste.net/8153551397736939520
13:47:54 <Gurkenglas> How is munch not many . satisfy?
13:50:23 <kqr> i assume it is
13:50:34 * hackagebot hOpenPGP 2.4.1 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.4.1 (ClintAdams)
13:50:46 <kqr> it is not!
13:50:58 <kqr> > Always succeds, exactly once having consumed all the characters Hence NOT the same as (many (satisfy p))
13:51:00 <lambdabot>  <hint>:1:15: parse error on input ‘,’
13:51:13 <Gurkenglas> Yes, I read that, didnt understand and thus came here
13:52:43 <kqr> > readP_to_S (munch (/= 'x')) "abcdefxghi"
13:52:45 <lambdabot>  Not in scope: ‘readP_to_S’Not in scope: ‘munch’
13:52:50 <kqr> well
13:52:55 <kqr> λ> readP_to_S (munch (/= 'x')) "abcdefxghi"
13:52:57 <kqr> [("abcdef","xghi")]
13:53:14 <kqr> λ> readP_to_S (many (satisfy (/= 'x'))) "abcdefxghi"
13:53:16 <kqr> [("","abcdefxghi"),("a","bcdefxghi"),("ab","cdefxghi"),("abc","defxghi"),("abcd","efxghi"),("abcde","fxghi"),("abcdef","xghi")]
13:53:32 <monochrom> interesting
13:54:08 <Gurkenglas> Ah. many is Alternative's many for StateT String [], and munch the many for StateT String Maybe
13:54:51 <Gurkenglas> (Although the one for StateT String [] would return the longest first.)
13:55:34 * hackagebot hopenpgp-tools 0.17 - hOpenPGP-based command-line tools  https://hackage.haskell.org/package/hopenpgp-tools-0.17 (ClintAdams)
13:55:46 <Gurkenglas> > evalStateT (manyLazy $ mapStateT maybeToList $ StateT uncons) [1..5]
13:55:48 <lambdabot>  [[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1],[]]
13:55:59 <kqr> pretty much all of ReadP works like (many . satisfy) so munch is definitely the odd one out there
13:56:22 <kqr> at least that's my impression from playing around with it earlier today
13:57:29 <augur> edwardk: do you know of any work on propagator networks that grow based on the propagated values?
13:58:41 <Gurkenglas> What should I call the class that relates [] to NonEmpty and Maybe to Identity?
13:59:47 <kqr> MonadMinus
13:59:58 <hpc> Point
14:01:13 <xnil> What do people see wrong with Cabal and is there a way to replace Cabal and fix those concerns?
14:04:05 <Welkin> xnil: cabal is a build system
14:04:11 <Welkin> there is nothing wrong with it
14:04:34 <Welkin> people only see a problem if they treat it like a package manager
14:04:41 <xnil> Is there a suitable package manager for Haskell? If not, why?
14:05:01 <Welkin> stack
14:05:18 <Welkin> it's the closest
14:05:56 <Welkin> stack uses the cabal library, but does not use the cabal program
14:06:44 <xnil> Welkin: Is it widely used?
14:06:53 <hpc> the funny thing is, ghc-pkg is the package manager
14:07:07 <hpc> stack is the apt of ghc-pkg's dpkg
14:07:48 <Welkin> xnil: yes, lots of people use it
14:08:00 <Welkin> I used to use cabal-install, but now I use stack exclusively
14:08:15 <Welkin> it makes everything much easier and requires less compiling
14:08:27 <Welkin> shared librariy binaries
14:08:41 <Welkin> also, using multiple versions of ghc for different projects
14:08:42 <kqr> i still try to use cabal-install when I come a cross a non-stackified project... but it usually doesn't take long until I stackify it because that's easier
14:10:52 <knupfer> Would it make sense to use unsafePerformIO on a idempotent function which changes something on the filesystem?
14:11:37 <kqr> no
14:12:00 <kqr> well maybe, but since you have to ask, probably no
14:12:02 <knupfer> kqr: Why not?
14:12:33 <kqr> better question is wy
14:12:34 <kqr> why*
14:12:41 <kqr> unsafeperformio is not a "why not" thing
14:12:43 <monochrom> the correct mindset is: don't do it unless you can justify why it is a correct thing to do.
14:13:00 <monochrom> the wrong mindset is: do it unless you can justify why it is wrong
14:13:16 <knupfer> It's only for convenience.
14:13:29 <monochrom> that is not going to be enough justification
14:13:29 <knupfer> I know that it is generally frowned upon.
14:14:08 <knupfer> I just wondered if it is considered bad practice even if it is provable that it behaves purely.
14:14:22 <knupfer> (in the same program invocation)
14:14:54 <monochrom> but that's what I said. "it is provable that it behaves purely" is why it is a correct thing to do.
14:15:07 <monochrom> but "for convenience" is not "it is provable that it behaves purely"
14:15:33 <knupfer> Yes.
14:15:47 <monochrom> I have said enough. I have no further comments.
14:15:47 <kqr> but is changing something on the file system ever pure?
14:18:24 <xnil> is there a haskell-offtopic channel?
14:18:28 <kqr> #haskell-blah
14:18:35 <xnil> thanks
14:19:01 <knupfer> kgr: my usecase is the following, I've got a yesod application and wrote a function, which takes the StaticRoute to an image and an Int and transforms the width of the image, saves it in the tmp dir and returns the StaticRoute to the new image.  The images name consists of a hash of all input.
14:19:32 <kqr> aha
14:19:44 <m1dnight_> https://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/ <- this explained a lot for me (re: xnil)
14:19:53 <kqr> that sounds like the kind of thing that may be pure enough, but I'm a bit too tired to think it through
14:20:06 <xnil> m1dnight_: i'm already aware.
14:20:09 <xnil> just didn't know about stack
14:20:20 <knupfer> So it returns always the same Route and creates the same file (if it doesn't already exist) and the route isn't used, it doesn't matter when it isn't generated in the first place.
14:20:22 <m1dnight_> Oh okay, sorry :)
14:20:43 <m1dnight_> I personally haven't used stack because I'm a noob haskeller.
14:21:22 <knupfer> kqr: The fun bit is, when I implement it with unsafePerformIO, I can use the function directly in the hamlet templates...
14:22:23 <kqr> knupfer, can you not do IO in hamlet templates? was a while since I used them
14:22:54 <knupfer> kqr: not to my knowledge, but you could lift in the handler
14:23:09 <kqr> ah I guess that was what I was thinking of
14:23:30 <knupfer> this would be also possible for my function, but lot less elegant
14:23:51 <knupfer> note that this is purely aesthetic/fast downloads
14:24:07 <kqr> yeah
14:25:28 <knupfer> and using unsafe... would be perhaps beneficial for the performance, because it can avoid some calls to imagemagick
14:25:39 <kqr> as long as you keep track of inlining and such
14:26:11 <knupfer> yes
14:28:57 <Gurkenglas> > evalState (manyLazy $ modifyT tailMay >> StateT uncons) [1..] -- http://lpaste.net/150858 I present PointedAlternative. Feel free to suggest better naming.
14:28:59 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
14:30:35 * hackagebot users 0.4.0.0 - A library simplifying user management for web applications  https://hackage.haskell.org/package/users-0.4.0.0 (AlexanderThiemann)
14:30:37 * hackagebot users-persistent 0.4.0.0 - A persistent backend for the users package  https://hackage.haskell.org/package/users-persistent-0.4.0.0 (AlexanderThiemann)
14:30:39 * hackagebot users-test 0.4.0.0 - Library to test backends for the users library  https://hackage.haskell.org/package/users-test-0.4.0.0 (AlexanderThiemann)
14:30:41 * hackagebot users-postgresql-simple 0.4.0.0 - A PostgreSQL backend for the users package  https://hackage.haskell.org/package/users-postgresql-simple-0.4.0.0 (AlexanderThiemann)
14:36:21 <frerich> Sometimes I find things so pretty that I write them from scratch every now and then, just for fun. For instance, table-driven state machines in C. Or parser combinators from scratch in Haskell.
14:36:31 <frerich> Of course, I always chicken out before it comes to performance critical stuff.
14:36:44 <frerich> Up to that point though, it's just plain glorious how everything fits together. :-)
14:37:19 <frerich> Somehow it never gets boring in its simplicity.
14:38:39 * frerich hears somebody in the back of the room yelling "freak!"
14:38:46 <kqr> the kind of stuff for beautiful code books
14:40:35 * hackagebot JuicyPixels 3.2.7 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  https://hackage.haskell.org/package/JuicyPixels-3.2.7 (VincentBerthoux)
14:40:38 <Gurkenglas> How do I search for instances of a class (using hayoo perhaps?) when lambdabot's standard imports are not enough for @instances to satisfy?
14:41:12 <Welkin> Gurkenglas: yeah, try hayoo
14:41:29 <hpc> the documentation for the type provides instances
14:41:31 <Gurkenglas> But what query?
14:41:44 <Welkin> just search instance classname
14:41:45 <Gurkenglas> hpc, moar instances!
14:42:09 <Gurkenglas> (Is JuicyPixel's Vincent Berthoux in this channel?)
14:42:58 <Gurkenglas> Oh that works when I first looked at that the results looked random but nope
14:44:14 <Gurkenglas> nvm they actually are unrelated, at least the first five results, and just use the word alternative or need Alternative as a precondition.
14:45:55 <byorgey> Gurkenglas: Vince used to come on IRC occasionally as Vince_Juicy but I haven't seen him in a while
14:54:40 <simony> What do people use for reading config files in haskell apps?
14:55:36 * hackagebot adler32 0.1.1.0 - An implementation of Adler-32, supporting rolling checksum operation  https://hackage.haskell.org/package/adler32-0.1.1.0 (MariosTitas)
14:55:44 <frerich> simony: I used Aeson for that, because JSON was easy enough to read/modify by hand and it's easy to make Aeson get me some nice data structure for a given piece of JSON data.
14:56:06 <monochrom> nice idea
14:57:44 <EvanR> who needs config files use acid-state!
14:58:25 <simony> ah, good idea! thanks
14:58:27 <ChristianS> simony: we use configifier which strongly types config files, but admittedly that's still somewhat experimental
14:59:49 <simony> oh fancy!
14:59:58 <simony> but looks pretty neat actually
15:02:24 <ChristianS> simony: configifier works well enough but the type errors you might get are not for the faint of heart
15:10:36 * hackagebot pipes-transduce 0.3.2.0 - Interfacing pipes with foldl folds.  https://hackage.haskell.org/package/pipes-transduce-0.3.2.0 (DanielDiazCarrete)
15:28:42 <crossroads1112> Would anyone mind taking a look at this and telling me if there is a more idiomatic way of doing the maxProd function (calling fmap twice seems off to me) http://0bin.net/paste/uGqY+yn4WN19Ihti#Wa9zcm1z8dRkGXFBcHDZ1LlQXH4paduk5sIuQB+h5vD
15:30:11 <crossroads1112> Also, just realized I forgot to add import Control.Monad at the top
15:33:41 <pavonia> "This pastebin uses client-side encryption. Therefore, it needs JavaScript enabled." What
15:33:57 <ggVGc> that's some crazy shit
15:34:03 <ggVGc> and highly suspect
15:34:22 <kqr> maxProd :: [[Integer]] -> Integer
15:34:25 <kqr> maxProd = maximum . concat . fmap (fmap product . csubs 4)
15:34:26 <EvanR> https
15:34:27 <kqr> is the essence of it
15:34:33 <crossroads1112> panovia it's an encrypted, open-source pastebin
15:34:36 <EvanR> client-side encryption
15:35:13 <kqr> EvanR, the point is that the server should be unable to decrypt the contents
15:35:25 <kqr> EvanR, since the encryption key is only handled locally among the visiting clients
15:35:39 <ggVGc> ah that's actually cool
15:35:41 <EvanR> but anyone going to the site to read the paste can?
15:35:55 <kqr> as long as they have the key
15:36:00 <kqr> which is included in the URL crossroads1112 posted
15:36:07 <crossroads1112> kqr: correct
15:36:08 <EvanR> keys in the url, brilliant
15:36:20 <EvanR> you know the server sees that url
15:36:31 <EvanR> as does google probably
15:36:46 <kqr> EvanR, generally the fragment isn't sent to the server
15:37:05 <crossroads1112> EvanR http://0bin.net/faq/
15:37:48 <crossroads1112> I wouldn't have posted my code there if I'd have known it was going to be so controversial. Sorry guys!
15:38:18 <sm> "The goal of 0bin is not to protect the user and their data.. it aims to protect the host from being sued for the content users pasted"
15:38:25 <EvanR> i see the point is to have plausible deniability for litigation against the bin
15:38:31 <sm> interesting
15:38:43 <EvanR> this is all probably good enough for that
15:38:50 <EvanR> law != crypto
15:41:14 <ggVGc> law == haskell?
15:41:21 <pavonia> crossroads1112: Re your question, using map instead of fmap is more idiomatic, I think. and then "concatMap" for "concat . fmap"
15:42:07 <crossroads1112> panvonia: Is it really? I can't remember where I read it, but I have read that using fmap over map is generally preferred
15:42:41 <crossroads1112> pavonia: Ahh:  here it is
15:42:43 <crossroads1112> http://dev.stephendiehl.com/hask/#prelude
15:42:56 <glguy> map is just fine to use instead of fmap when you're working with lists, and concatMap when you're going to concat is a potential efficiency win
15:42:57 <crossroads1112> I don't know how credible it is
15:44:31 <crossroads1112> glguy: I realize that it is just fine. fmap = map on lists. Though I do agree it is beneficial to simply use concatMap
15:44:47 <EvanR> when someone clicks on link to 0bin... it does what? how does it stop the key from being sent to the server
15:44:49 <glguy> I don't mean equivalent, but stylistically
15:45:18 <crossroads1112> EvanR: Your question is answered on the FAQ link I posted
15:45:31 <crossroads1112> http://0bin.net/faq/
15:45:36 <crossroads1112> Top question
15:45:39 <EvanR> i am asking a question about the last two sentences of the first section
15:46:05 <EvanR> you click a link, and the browser downloads the page with the sites js, which i know can remove a hash from a url but
15:46:14 <EvanR> but not before you get the js
15:47:23 <ggVGc> yeah this is weird
15:47:30 <ggVGc> how does the server not get the URL?
15:47:34 <ggVGc> with everything in it
15:47:41 <glguy> crossroads1112: You could untangle it a bit like this, perhaps: maximum . map product . concatMap (csubs 4)
15:47:42 <ggVGc> this is BS
15:48:03 <EvanR> OK
15:48:09 <EvanR> the key is after the #
15:48:13 <EvanR> got it
15:48:18 <kqr> EvanR, ggVGc the fragment is not sent to the server
15:48:23 <crossroads1112> EvanR: I was about to post that
15:48:26 <crossroads1112> You are correct
15:48:33 <kqr> you can test by visiting localhost:8000/test#fragment after setting up nc -lp 80
15:48:42 <ggVGc> ah, alright then
15:48:53 <glguy> The point isn't that your paste is safe, it's that they aren't handling the key so if someone sends them a legal request to turn over the key they can say they don't have it
15:48:54 <ggVGc> didn't know fragment was special like that
15:49:05 <glguy> and they intentionally don't send the key to themselves
15:49:15 <glguy> afaict
15:49:20 <crossroads1112> You could actually host your own 0bin btw
15:49:29 <crossroads1112> It's on github
15:49:40 <EvanR> heh, if everyone hosted their own 0bin
15:49:58 <EvanR> by default, and thats how people communicated
15:50:15 <kqr> technically javascript can highjack the request path these days too, but then of course you get the problem that you have to download the JS first
15:50:26 <ggVGc> EvanR: I'm not exactlu sure how that would work
15:51:26 <EvanR> me neither
15:55:33 <dmwit> If you host your own 0bin and use it to host your own content, I doubt you would legally be able to claim you don't have the key for that content.
15:55:54 <dmwit> So it's important that you find a friend, and each host 0bin, and only use your friend's instance.
15:56:54 <EvanR> they cant sue all of us
15:58:09 <frerich> crossroads1112: If you always deal with groups of 4 elements, you could condense things a bit with a list comprehension, e.g. you could define 'f x = maximum [product g | g@[_,_,_,_] <- map (take 4) (tails x)]' and then that would simplify 'maxProd' to 'maximum . map f'
15:59:23 <EvanR> http://sebsauvage.net is cool, option "burn after reading"
16:02:55 <frerich> crossroads1112: I just noticed I had 'maximum' twice there, it could also be 'maximum . concatMap (\x -> [product g | ...'
16:03:55 <Gurkenglas> I'd rather do maximum [product g | g <- mapMaybe (takeExact 4) (tails x)]
16:04:20 <crough> I'd recommend not using maximum, just in case though...
16:04:27 <crough> Maximum is partial
16:05:50 <dobq> does anyone have any working project examples that expose haskell functions to C?
16:06:11 <dobq> (i'm not getting it to link, and would like to see an example)
16:07:09 <glguy> dobq: Are you using ghc to do the final link or trying to do it manually yourself?
16:07:39 <kzhang> I'm looking at the memory usage of haskell data structures in this page: https://wiki.haskell.org/GHC/Memory_Footprint. It says the slices of vector take 3N words + N * sizeof(v). What does the N represent here, the length of original vector or the sliced vector?
16:07:44 <dobq> glguy: ghc, i guess. all i have is some haskell code and a .cabal file, and that doesn't seem to be enough (without advanced options that i don't understand)
16:08:53 <EvanR> kzhang: the slice, probably
16:09:14 <dcoutts> dobq: unfortunately this is not yet trivial, though we've added foreign library support to cabal-1.24 to make it much easier to do
16:10:03 <dobq> dcoutts: can i get it to build correctly with a "cabal build" at all?
16:10:42 <dobq> i mean, i was hopign it'd just be the right combination of "ghc-options". but i'm happy to change Setup.hs as well. as long as it's eventually convenient
16:10:46 <dcoutts> dobq: yes, at least with ghc-7.8, I've not checked if it's still true with 7.10. This relied on a bit of a hack to be able to do with just a .cabal file, otherwise it requires a manual step.
16:11:04 <kzhang> EvanR: I hope so. Anyone has a definite answer? I found vectors in my program use too much memory. I'm not sure whether it relates to slices
16:11:18 <glguy> dobq: I'm generating a library that I use from C using Haskell currently. I have a bit of a manually constructed step of combining the generated Haskell .a file with the other Haskell dependencies
16:11:27 <glguy> so that I get a single .a in the end that I link into the C project
16:11:38 <dcoutts> dobq: it was exactly this frustration that led us to implement "platform" or "native" lib support for cabal.
16:12:39 <dobq> dcoutts: so... do you have any suggestions for what i should do?
16:13:00 <kzhang> Looking at the definition of slice: basicUnsafeSlice j n (Vector i _ arr) = Vector (i+j) n arr. It sounds unlikely that the size of slices will be proportion to the length of slices.
16:13:06 <dobq> wait for cabal 1.24, ask again?
16:13:29 <dcoutts> dobq: windows or linux?
16:13:31 <dobq> linux
16:13:34 <EvanR> kzhang: the first element is the offset
16:13:40 <dcoutts> dobq: so, make it an executable, not library
16:13:49 <EvanR> kzhang: the n is the size
16:13:55 <dobq> ah, because libraries are just executables with a .so extension?
16:14:13 <kzhang> EvanR: Ideally, It should use zero extra space
16:14:15 <dcoutts> dobq: and use ghc-options: -shared -dynamic -fPIC -o dist/build/libfoo/libfoo.so
16:14:34 <dobq> that sounds easy enough, let me try that
16:14:35 <EvanR> kzhang: well the size of that vector slice object, which looks to be just 2 numbers and a pointer
16:14:44 <dcoutts> dobq: and you also need to link in the rts etc: extra-libraries: HSrts-ghc7.8.4 HSghc-prim-0.3.1.0-ghc7.8.4  HSbase-4.7.0.2-ghc7.8.4 HSinteger-gmp-0.5.1.0-ghc7.8.4 
16:14:48 <snhmib> i'm starting to write haskell interface for a C library, and they already have a python interface for it, so i'm thinking to basically copy that into haskell (is that a bad idea?) anyhow, they dynamically load the library and then check a symbol in it to decide between 2 options
16:14:50 <EvanR> plus constant object overhead
16:14:54 <snhmib> what would be the haskell way to do that?
16:15:02 <glguy> dcoutts: will that dynamically link the Haskell library dependencies?
16:15:13 <dcoutts> dobq: note that it'll link the thing twice, this is the cost of if being hacky, the proper cabal support does it nicely.
16:15:24 <dcoutts> glguy: yes
16:15:27 <kzhang> EvanR: That's what I thought, which is very small. I don't know where the 3N comes from.
16:15:31 <EvanR> kzhang: high memory usage could be caused by holding onto values too long, somehow not letting the GC get hem
16:15:46 <dobq> dcoutts: hmm, i can't just replace "library" by "executable" in my cabal... let's see how i can most efficiently reorganize this project :P
16:15:57 <kzhang> EvanR: but this can't be long. https://wiki.haskell.org/GHC/Memory_Footprint
16:16:02 <snhmib> i'm thinking i should just check at configure/compilation time for these symbols?
16:16:02 <glguy> dcoutts: Is there a way to get a static library out so that it can be used without the Haskell environment being around?
16:16:03 <EvanR> kzhang: maybe that is talking about doing a copy of a slice
16:16:04 <dcoutts> dobq: you can split it, an exe that depends on the Haskell lib
16:16:14 <dobq> ah that's the best option i guess
16:16:22 <dcoutts> dobq: e.g. a Haskell library foo, and a C export "libfoo.so"
16:16:52 <dcoutts> glguy: the other .so files can be shipped along with the thing, so it doesn't need a whole env
16:17:25 <EvanR> kzhang: otherwise not making sense to me, maybe someone else knows
16:17:31 <Strukks> Is there some sort of syntax that lets me do "S" * 5 = "SSSSS"?
16:17:46 <dcoutts> glguy: as for statically linking them in, no that's not currently easy because the static libs are not built with -fPIC. On the other hand on windows that's more or less the only way to do it.
16:17:47 <snhmib> repeat function?
16:17:53 <EvanR> :t replicate
16:17:55 <lambdabot> Int -> a -> [a]
16:18:06 <dcoutts> glguy: in principle either is possible on both platforms, but it would require rebuilding all the libs (including base)
16:18:09 <kzhang> EvanR: Let me do more research. Thanks
16:18:23 <glguy> dcoutts: currently to generate the static library (on Linux)I was using libtool to bundle all of the Haskell dependencies into a single lib_.a
16:18:34 <Strukks> snhmib tyvm
16:18:42 <glguy> and using Setup.hs to generate a makefile include to figure out what all those libraries were
16:18:48 <dcoutts> glguy: oh you mean a static lib, not one big .so
16:19:00 <glguy> yeah
16:19:23 <dobq> dcoutts: is there a smart way to pick the right version of that rts stuff?
16:19:27 <dobq> rather than hardcoding it
16:19:29 <dcoutts> glguy: right that should also be possible, either by generating some pkg-config thing to tell C code to use all the Haskell .a files, or your trick of trying to merge them all into one whopper
16:19:46 <dcoutts> dobq: yes, using the Cabal native library support :-)
16:19:59 <dcoutts> dobq: otherwise it's hacky
16:20:02 <dobq> dcoutts: okay, so i'll ask that question again in a few weeks :)
16:20:20 <dobq> now, where are my haskell libraries...
16:20:33 <dcoutts> dobq: actually I just checked the git repo, it's not clear it'll make it for 1.24, but next release
16:21:57 <dobq> dcoutts: uhh, my libraries have checksums in the filename. should i include those?
16:22:26 <dcoutts> dobq: sounds like you're using 7.10. I've not tested that combination. As I said, the hack is fragile.
16:22:36 <dobq> yes, 7.10 :P
16:22:38 <dobq> wish me luck
16:22:43 <dcoutts> so you can try it, but I can't promise anything
16:23:09 <dcoutts> what you need to arrange, one way or another, is to link the rts and the things it requires
16:24:03 <glguy> and don't forget that to use the threaded runtime you need a different Cffi and HSrts
16:24:22 <glguy> (or at least you need to keep that in mind the way I'm doing it)
16:24:39 <dobq> glguy: wait seriously?
16:25:37 <dcoutts> dobq: yes, this relies on linking against the right rts, and that's affected by -threaded -profiling -eventlog etc
16:25:44 <dcoutts> dobq: I said it was fragile
16:25:46 <dobq> oi, good to know
16:26:08 <dobq> hmm, i can't even convince cabal to find those libraries
16:26:16 <dcoutts> it's ghc, not cabal
16:26:22 <glguy> and if you're using your Haskell library from a C program, watch out for the default signal handlers GHC installs
16:26:27 <dobq> dcoutts: no, it's cabal
16:26:35 <dobq> cabal: Missing dependency on a foreign library:
16:26:36 <dobq> * Missing C library: HSghc-prim-0.4.0.0-8TmvWUcS1U1IKHT0levwg3-ghc7.10.3
16:26:51 <dcoutts> ah ok
16:27:15 <dcoutts> check the error that cabal gets when it probes
16:27:23 <dcoutts> use -v3 to see how cabal invokes ghc
16:27:36 <dcoutts> and run that manually, and experiment with variations
16:27:56 <dcoutts> in particular, you need all the libs together, since they depend on each other
16:28:03 <dcoutts> rts and base depend on each other recursively
16:28:34 <glguy> dcoutts: Any chance anything about the new native library support planned for Cabal is documented in a ticket or anything like that if I want to follow developments or learn more?
16:28:49 <dcoutts> glguy: https://github.com/haskell/cabal/pull/2540
16:28:53 <dobq> dcoutts: any chance you could help if i paste the error somewhere?
16:29:23 <dcoutts> dobq: possibly, but it's worth getting it working first with ghc, before working out what hacky way to persuade cabal to do that for you
16:29:33 <dobq> haha
16:29:47 <dobq> and this is already a big chunk of code, so yeah. too big of a target i suppose.
16:30:26 <dedgrant> Anyone try rewriting their Proxy APIs with visible type application in GHC 8 yet? 8-D
16:30:28 <dobq> dcoutts: in case you're willing to give it a try, http://dpaste.com/3AGQR7X
16:30:47 <dedgrant> (sort of curious about early results)
16:31:10 <dobq> oh. maybe it's just erroring out because my list is incomplete.
16:32:32 <dcoutts> dobq: wait, you're only specifying -lHSghc-prim-0.4.0.0-...
16:32:39 <dcoutts> you need them all
16:32:48 <dobq> yeah i know....
16:33:05 <dcoutts> ok, well, it's not going to work otherwise
16:33:18 <dcoutts> you can't specify just one, they depend on each other recursively
16:33:20 <dobq> dcoutts: this should be better http://dpaste.com/27C06S2
16:33:54 <dcoutts> -llibHSrts is wrong, there's no "lib" bit
16:33:55 <dobq> dcoutts: i think i know where this is going
16:34:09 <dobq> yeah, and there's another library missing i think
16:34:29 <dobq> HAHA YAY
16:34:36 <dobq> dcoutts: it configures! :)
16:34:44 <dobq> it builds...
16:35:11 <dobq> dcoutts: haha, this is awesome
16:35:15 <dobq> thanks a lot
16:35:19 <dcoutts> you're welcome
16:35:23 <dobq> (it doesn't work because my code is incomplete)
16:35:33 <dobq> (but at least it's resolving a few symbols)
16:36:49 <dobq> dcoutts: huh, that's funny. i defined a main function (because i expected cabal or ghc to complain, since it's an executable). but if i execute the .so, it dumps core
16:38:31 <dcoutts> dobq: no you don't need a main
16:39:03 <dobq> cabal: No 'main-is' field found for executable
16:39:42 <dobq> and with an empty Main.hs, it complains about a missing main
16:39:51 <dcoutts> dobq: I mean, the main-is, does not need to specify a module that is 'module Main'
16:40:25 <dcoutts> e.g. it can specify a .hs file (including generated from a .hsc) that just exports ffi things
16:41:00 <dobq> dcoutts: ah got it
16:41:04 <snhmib> what is the best way for #peeking and #poking at stdint.h types? can i use the standard haskell types?
16:41:45 <snhmib> i.e. C code uses a uint16_t, do i use a CUShort to read it or a Word16?
16:42:05 <dobq> snhmib: it is my belief that CUShort should always be the same thing
16:42:19 <snhmib> it's my understanding that short might or might not be always the same as uint16_t
16:42:21 <snhmib> oh
16:42:29 <snhmib> ok let's hope so :)
16:42:56 <jstimpfle> hey guys, what do you do if you have to annotate a monadic expression because the value "in" it can't be inferred?
16:43:01 <jstimpfle> I have         vm <- getValue m :: MagicMonad s IO String
16:43:16 <jstimpfle> but I can't do that because s needs to be bound to outer expression
16:43:31 <jstimpfle> but I need to tell it that "vm" is of type STring
16:44:23 <monochrom> I turn on ScopedTypeVariables and write "vm :: String <- getValue""
16:44:33 <jstimpfle> I did that, didn't work for some reason
16:44:44 <jstimpfle> oh
16:44:51 <ReinH> monochrom: ScopedTypeVariables would allow either, right?
16:44:52 <dobq> snhmib: regarding your earlier questions: well you should try not to be steered too much by other APIs. haskell is a very different language, and you shouldn't just copy APIs
16:45:08 <dobq> snhmib: and the FFI should have interface for dynamically loading libraries
16:45:10 <monochrom> yes but "vm :: String <-" is less work
16:45:18 <ReinH> monochrom: just checking
16:45:39 <dobq> snhmib: but it really depends on the application if you'd call that sane
16:45:43 <monochrom> the other way requires also adding a "forall" at a declaration far far away
16:45:59 <jstimpfle> it works! Last time i did "a :: TYPE <- monadval" it wasnt accepted for some reason
16:46:02 <jstimpfle> many thanks
16:46:09 <dobq> snhmib: maybe you should split up your code into three libraries: two for either case, and one wrapper to tie it all together, and then you only need to dynamically load either of the two libraries?
16:46:15 <dobq> (not sure if that works)
16:46:17 <monochrom> and "forall" is annoying because if you say it you have to list all type variables
16:46:51 <snhmib> dobq: oh no it's checking if the library is compiled with 32 or 64bit support (or both)
16:47:27 <snhmib> i dunno, i'll figure it out later :)
16:47:29 <ReinH> dobq: one library to rule them all, one library to find them.
16:53:15 <johnw> and in the darkness >>= them
16:53:29 <dmwit> It has often struck me as odd that ScopedTypeVariables is the right thing to turn on for annotating binding positions.
16:55:00 <monochrom> @quote one.*bind
16:55:00 <lambdabot> edwardk says: you can view Yoneda f as enforced fmap fusion and Codensity f as enforced bind fusion.
16:55:17 <monochrom> ah
16:55:20 <monochrom> @quote one.*darkness
16:55:21 <lambdabot> Takusen says: One install script to rule them all, and in the darkness build them...
16:55:31 <dobq> dcoutts: thanks again for your help. this would've taken me days without it. and this solution is acceptable for me for now, i'd say.
16:56:23 <geekosaur> folding PatternSignatures into ScopedTypeVars was weird, yes
17:00:22 <EvanR> where did the name bind come from for >>=
17:00:55 <monochrom> probably Wadler, even Moggi
17:01:44 <monochrom> because "m >>= \x -> mmm" binds the "return value" to x
17:02:12 <monochrom> Moggi even writes it as "let x <- m; mmm"
17:28:21 <synergistics> What's the intuition behind the S combinator? I get what it does literally, but not why it's defined the way it is/why it's so fundamental to combinatory logic
17:36:41 <Hwaldstein1997> Is there a recommended OS for haskell development? I'm currently using Windows, but I'm comfortable with Linux. The last time I tried haskell on Windows, I wasn't impressed. Does Ubuntu have decent haskell support? 
17:38:10 <synergistics> Hwaldstein1997: I can only speak for myself, but haskell is doing fine on Arch Linux
17:38:15 <Strukks> Why does "(\x-> (length . show) x < (10^99)) 9" say false? I don't get it, "5 < 10^99" works, "(\x-> (length . show) x < (5*3))" works too, but why won't the first work? 
17:39:21 <shachaf> :t length
17:39:23 <lambdabot> Foldable t => t a -> Int
17:39:29 <shachaf> > 10^99 :: Int
17:39:32 <lambdabot>  0
17:39:57 <Strukks> why does "5 < 10^99" work then?
17:40:19 <pavonia> > 10^99+1 :: Int
17:40:21 <lambdabot>  1
17:40:37 <geekosaur> :t 5 < 10^99
17:40:39 <lambdabot> Bool
17:40:41 <pavonia> Hhm, that is an interesting coincidence
17:40:43 <geekosaur> oh right
17:40:52 <geekosaur> anyway it's because it's inferred as Integer instead of Int
17:41:13 <geekosaur> (Int is roughly a machine word, Integer is arbitrary size)
17:41:44 <Strukks> geekosaur, any quick fix?
17:42:36 <geekosaur> possibly genericLength but I don't recall if that actually uses a larger type or just converts the result
17:43:16 <EvanR> genericLength is 1 + rest
17:43:36 <EvanR> 1 + length rest
17:43:43 <pavonia> Strukks: Does this question have any practical relevance?
17:44:22 <Strukks> I'm doing Haskell exercises, but I just realized I messed up, it should be just "< 100" because I'm already comparing lengths
17:44:44 <Strukks> not numbers that have those lengths
17:44:47 <shachaf> Don't use genericLength.
17:44:55 <shachaf> Better to use fromIntegral . length
17:45:25 <Strukks> I don't have to use it anyway, I messed up ^^^
17:47:26 <Sonarpulse> is there any library with gadt heterogenous lists?
17:47:46 <Sonarpulse> HList :: [*] -> *
17:48:50 <shachaf> @hackage HList
17:48:50 <lambdabot> http://hackage.haskell.org/package/HList
17:49:15 <Sonarpulse> yeah that one works ...differently, as far as I can tell
17:49:55 <Sonarpulse> existentials everywhere
17:50:19 <shachaf> Ah, it uses a data family.
17:51:17 <Sonarpulse> oh wait, that does look better than I thought
17:57:41 <Enigmagic> it has been improved over the years
18:11:00 <Lokathor> hey what's a combinator
18:11:14 <Lokathor> how is it classification-wise different from other sorts of haskell functions
18:14:07 <EvanR> Lokathor: https://wiki.haskell.org/Combinator
18:14:58 <Lokathor> ""There are two distinct uses of the word "combinator" in common usage.""
18:15:01 <Lokathor> this explains so much
18:15:25 <EvanR> also take anything on haskell wiki with a grain of salt ;)
18:16:06 <Lokathor> well, the first difinition, with free variables and all, doesn't make much sense in a haskell program
18:16:22 <Lokathor> you never actually have free variables of course, that can't compile
18:17:03 <Lokathor> i mean whatever binding is always defined in some outer scope, even if it's not strictly in that lambda, that is
18:17:04 <EvanR> eh... even if you think of the sum total of the program as being in a giant let
18:17:16 <EvanR> you still have undefined-in-the-language variables
18:17:25 <EvanR> id const flip, etc will compile
18:17:35 <EvanR> and have no free variables
18:17:55 <Lokathor> well specifically
18:18:04 <Lokathor> peolpe talk about "parser combinator libraries"
18:18:05 <Lokathor> and such
18:18:13 <Lokathor> they clearly mean that second definition
18:18:32 <EvanR> yes, but also combinators in combinator libraries can be considered combinators in the first sense someimes
18:19:52 <Lokathor> sometimes
18:19:57 <monochrom> at one level, you can say "const id" is full of free variables, they're called "const" and "id".
18:20:09 <monochrom> but that is usually not what people mean
18:20:32 <monochrom> so, at another level, since "const id" = "(\x y -> x) (\z -> z)", no free variable.
18:20:48 <mrlase> So I'm trying to use a data constructor to represent a choice of options, but I'm getting an error - "couldn't match expected type 'Payload' with actual type '[Entity Account]'
18:20:53 <mrlase> https://gist.github.com/acrognale/51ac096f8b923caf7665
18:21:05 <mrlase> what might I be doing wrong with regards to the Payload constructor?
18:21:24 <Lokathor> i will simply avoid the word myself whenever possible. i needed only to understand this "alternate" definition to make sense of other things
18:25:01 <EvanR> yeah by exposing a "DSL" of combinators you can get more safety and hopefully easy of use than if you exposed the inner machinery of the library
18:25:31 <EvanR> you also get the opportunity to write laws for your combinators in the documentation
18:25:55 * hackagebot beam 0.3.1.0 - A type-safe SQL mapper for Haskell that doesn't use Template Haskell  https://hackage.haskell.org/package/beam-0.3.1.0 (TravisAthougies)
18:35:51 <acertain> does anyone have references on unifing modules and inductive types?
18:36:22 <keshaa> No
18:37:35 <ReinH> keshaa: don't do that
18:39:04 <Strukks> I need to write an expression that takes "a few" elements from each endless list of endless lists
18:39:17 <Strukks> I don't know where to begin though
18:40:19 <pavonia> Strukks: map (take a_few)?
18:40:34 <ReinH> > take 10 . map (take 3) . map enumFrom $ [1..]
18:40:36 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11],...
18:40:45 <Strukks> I use "repeat [1..]" to get an endless list of endless lists
18:41:04 <EvanR> Strukks: so a merge
18:41:31 <catsup> maybeM :: Monad m => (a -> m b) -> Maybe a -> m (Maybe b)
18:41:32 <catsup> maybeM f = maybe (return Nothing) (fmap Just . f)
18:41:41 <catsup> ^ what's a better way to write that?
18:41:44 <Strukks> not really a merge, I just need to take "a few" of each
18:41:50 <jle`> catsup: that's mapM, or traverse
18:41:57 <jle`> maybeM = mapM
18:42:05 <ReinH> Strukks: so do that then
18:42:05 <jle`> maybeM = traverse
18:42:12 <catsup> thanks :)
18:42:29 <jle`> it's probably the second most common usage of mapM/traverse :)
18:44:07 <ReinH> Strukks: if you're always taking a few, why not just repeat [1..3] or whatever "a few" is.
18:44:44 <Strukks> ReinH: yeah it doesn't matter, it could be "repeat (repeat 's')" or w/e as well
18:45:04 <ReinH> then why not replicate aFew 's'
18:45:34 <Strukks> ReinH, that's not the exercise :D 
18:45:35 <catsup> jle`: what is the first most common usage?
18:45:53 <jle`> over lists
18:46:00 <jle`> mapM_ print [1,2,3]
18:46:07 <ReinH> Strukks: Ok, then is something wrong with the way I showed?
18:46:43 <Strukks> ReinH, I don't know, what does "enumFrom $ [1..]" do?
18:46:52 <ReinH> creates an infinite list of infinite lists
18:46:59 <ReinH> for demonstration purposes
18:47:32 <ReinH> map (take aFeW) is the important part.
18:47:40 <Strukks> why doesn't "take 10 . map (take 3) . repeat [1 ..]" work?
18:48:12 <ReinH> because that's (take 10) . map (take 3) . (repeat [1 ..])
18:48:31 <ReinH> not (take 10 . map (take 3) . repeat) [1 ..]
18:49:36 <acertain> > take 10 $ map (take 3) $ repeat [1..]
18:49:38 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,...
18:49:41 <ReinH> Strukks: see http://stackoverflow.com/questions/940382/haskell-difference-between-dot-and-dollar-sign
18:49:48 <Strukks> ReinH: yeah, that works, thanks! Although it says that creating an infinite list of infinite lists and the other expression should be separate, I think
18:50:34 <ReinH> Well, I don't know what your exercise is so I can't make my answer conform to what it says
18:51:34 <Strukks> Well exactly that, but it should be 2 separate expressions, but I think it isn't that important anyway and I'll just move on 
18:51:53 <monochrom> > (take 2 . fmap (take 2 . fmap (take 2))) (repeat (repeat (repeat ())))
18:51:55 <lambdabot>  [[[(),()],[(),()]],[[(),()],[(),()]]]
18:52:11 <EvanR> Strukks: are you looking at the answer and waiting until someone in here guesses it? ;)
18:52:23 <EvanR> without knowing exactly the question
18:52:25 <ReinH> Ok, make it two separate expressions then
18:52:51 <Strukks> EvanR, nope, I'm just studying for an exam and doing exercises in a row from our coursebook
18:53:27 <Strukks> Sometimes I get stuck, and it's kinda hard to express the tasks because they're written in another language than English
18:53:52 <kazagistar> … he says, while using irc from the phone under his desk in the exam hall
18:54:04 <Strukks> but monochrom nailed it I think, and ReinH answer was very helpful as well, so thanks!
18:54:16 <EvanR> lol
18:54:25 <ReinH> well, I answered the question you asked
18:54:30 <Strukks> You did!
18:54:34 <ReinH> monochrom apparently asked the question you meant to ask ;)
18:54:47 <ReinH> *answered
18:55:09 <monochrom> I don't know the question. I probably don't care either.
18:55:34 <monochrom> I only want to play with nesting many levels and then fmap the hell of it
18:56:26 <monochrom> "create a level-3 infinite list and then truncate every level anyway"
19:13:31 <ReinH> monochrom: now traverse an infinite-level infinite list and do the same
19:14:28 <xnil> Stack was developed by FP Complete? What happened to them? Didn't they just drop their whole web IDE thing?
19:14:43 <hodapp> I think so.
19:14:50 <ReinH> I think they're "pivoting".
19:17:09 <geekosaur> I am under the impression that the various folks working on IDE-like tools (fpcomplete, ghc-mod, etc.) are combining forces
19:17:30 <geekosaur> rather than the current fragmented situation
19:21:40 <athan> Are functions considered data?
19:21:49 <athan> I would consider them "values" maybe
19:22:54 <hodapp> is data considered values?
19:23:21 <mgsloan> xnil: Nothing happened to FPCO, infact we're quite a lot larger than when we were working on the IDE (development on that stopped quite a long time ago)
19:23:39 <xnil> mmk
19:24:04 <xnil> i'm confused as to why the installation process for Stack is so convoluted
19:24:09 <hodapp> xnil: never caught your answer in the other channel - where & what are you studying?
19:24:24 <hodapp> xnil: curious what type of engineering
19:24:24 <xnil> hodapp: computer engineering, wentworth institute of technology
19:24:53 <xnil> i grew up in poverty in rural georgia. was a stretch for me to even get here
19:24:55 <athan> hodapp: Conceptually, I'm not sure. I think of values as === distinguished inhabitants of a type / proposition
19:25:01 <mgsloan> I'm curious what you find convoluted about it.  On linux / mac it's just downloading and running an executable.
19:25:06 <athan> erm vales === proofs or something
19:25:40 <hodapp> athan: I don't know if a meaningful distinction of 'data' exists in this context
19:25:40 <xnil> mgsloan: i believe that this is just a result of me not being familiar with ubuntu/debian
19:25:48 <xnil> not you guys' fault
19:25:58 <hodapp> xnil: scholarships?
19:26:11 <xnil> hodapp: ?
19:26:14 <athan> hodapp: What about data constructors? Is a lambda expression really just a data constructor?
19:26:15 <xnil> yes
19:26:20 <hodapp> xnil: that's good
19:26:29 <xnil> working on transferring to a better school
19:26:29 <athan> I don't think so because we can't deconstruct a lambda
19:26:31 <hodapp> athan: hmmm, dunno
19:26:47 <athan> so it's not not... bijective? *ducks*
19:26:47 <xnil> what is this "FP Complete Key" thing, mgsloan?
19:26:58 <xnil> sorry nvm
19:27:09 <xnil> "RTFM"
19:27:37 <mgsloan> athan: Could treat it as a datatype with hidden constructor (and so cannot be destructed)
19:28:27 <drdo> athan: It depends on what you think a function is
19:28:54 <drdo> Is a function the λ-term?
19:29:21 <EvanR> an arrow in the category of haskell types!
19:29:27 <athan> Well, in the case of an infinite stream, we can't "have" all the data in memory at the same time
19:30:45 <hodapp> sounds more like codata!
19:31:11 <athan> hodapp: That would be the nature of a function? Or the... agh fudge
19:31:13 <EvanR> athan: you eliminate a lambda by applying it to a term
19:31:32 <athan> so _data_ is something terminating..?
19:31:45 <athan> EvanR: But is a lambda itself still data?
19:32:01 <athan> I'm trying to understand what the term is for _not_ lambdas haha
19:32:02 <EvanR> the lambda term? as syntax?
19:32:06 <athan> and all data constructors
19:32:08 <athan> normal form?
19:32:34 <drdo> The confusion here is probably that several meanings of "data" are being used
19:33:15 <athan> I just still don't want residual thunks left, everything evaluated, no functions, and only data constructor cells. You an store functions in data constructors, though - that's my point
19:34:03 <athan> so something like `Just 1 (3 : (4 : []))` is fine, but `(($ 1) <$> (\x -> x + 3))` is not
19:34:13 <EvanR> if you have functions tha arent applied, they can be reduced
19:34:20 <artemis> I am working through the new Monad transformers chapter, and it states that in the applicative instance of the first argument is (MaybeT (f (a -> b))). However because of the nature of MaybeT should it be (MaybeT (f (Maybe (a -b)))) or am I missing something?
19:34:34 <EvanR> if you have a data type that can be fully evaluated to normal form theres NFData class
19:34:42 <stevejb> Hello, I have a lens-aeson question. I have it stated here: http://ix.io/nVd
19:34:56 <athan> EvanR: What would you call "checking the expression tree to see if there's any lambdas" after reducing to as-normal-form-as-possoble?
19:35:16 <EvanR> i.e. normal form?
19:35:26 <EvanR> whats the problem with lambdas
19:35:40 <athan> EvanR: Are functions an instance of NFData? :s
19:36:07 <EvanR> er... not enough coffee tonight
19:36:27 <athan> EvanR: I'm just trying to consider what you would call "a bunch of only data constructors ya dig g", specifically
19:36:38 <athan> naamsayin?
19:37:08 <athan> sorry, watching too much trailer park boys.
19:37:13 <EvanR> athan: a lambda thats not applied is in normal form
19:37:40 <EvanR> a -> b is a NFDaa
19:37:47 <EvanR> NFData
19:38:35 <EvanR> this class is for supporting the deepseq operation, you can safely force evaluation of the whole thing without bottoming
19:39:06 <EvanR> if you dont want functions anywhere, then just dont include functions in your data type
19:39:32 <EvanR> not everything else is "data constructors" though
19:39:44 <athan> EvanR: Ahh derp okay I see
19:39:56 <EvanR> like Int#
19:40:16 <athan> by saying "I have a type `Foo`", it might be unevaluated, but in normal form I know that it will be a Foo, whatever it might be
19:40:29 <athan> (If I include a function in the type, like you said :P)
19:40:31 <athan> sorry haha
19:40:34 <EvanR> its Foo either way
19:40:48 <athan> yeah
19:41:04 <EvanR> _|_ : Foo
19:41:57 <athan> EvanR: In Idris is this `_|_ : forall k. k`?
19:42:08 <EvanR> theres no _|_ in idris
19:42:36 <EvanR> though it can surely crash and freeze up 
19:44:10 <EvanR> for codata in idris you are guaranteed to have a productive stream
19:44:22 <EvanR> so no _|_ there either
19:50:16 <ReinH> If there is, it's probably a bug, e.g., https://gist.github.com/gelisam/c4df02dc451d7ccf9307
19:50:55 <ReinH> Also you can turn the totality checker off, in which case you have bottoms again.
19:51:47 <EvanR> rather if you dont turn it on
19:51:53 <ReinH> or that
19:52:52 <EvanR> i feel like people ignore that bit, but i was thinking of bugs, division by zero, and what the heck does IO do when it fails
19:53:14 <ReinH> IO does whatever it wants. IO is the honeybadger monad.
19:54:04 <stevejb>   el <-  readProcess "java" jp_args []
19:54:04 <coconut> anyone knows a library to convert epub to txt?
19:54:22 <stevejb> oops wrong buffer, sorry
19:56:11 * hackagebot generic-deriving 1.10.0 - Generic programming library for generalised deriving.  https://hackage.haskell.org/package/generic-deriving-1.10.0 (ryanglscott)
19:56:43 <EvanR> ReinH: does that bug have to do with universes
19:56:54 <ReinH> EvanR: maybe?
19:57:30 <EvanR> i wonder if idris even has any
19:57:44 <EvanR> :t Type shows Type 1, but it might just be a placebo
19:57:46 <lambdabot> parse error on input ‘,’
19:58:42 <EvanR> for a function like Type -> Type, the first Type needs to be second Type + 1 ( i think )
19:59:43 <Bor0> your consistent capitalization makes it hard for me to distinguish between your nicknames :p
20:00:25 <lethjakman-l> How do you type check something that's broken? 
20:02:00 <pavonia> lethjakman-l: You could use holes '_' for parts of the expression
20:02:18 <lethjakman-l> Sorry, I mean check the type of something that's broken. 
20:02:25 <lethjakman-l> As in...it won't compile, but I need more details. 
20:02:30 <lethjakman-l> Is there some vodoo I shoudl know?
20:03:00 <Bor0> https://www.youtube.com/watch?v=52VsgyexS8Q is nice. you want so called noisy holes
20:05:36 <pavonia> lethjakman-l: What more details than the compiler error do you want?
20:08:23 <lingxiao> hey all
20:08:30 <lingxiao> anyone on #coq right now as well?
20:10:10 <lethjakman-l> pavonia: I want to be able to :t in ghci I guess.
20:10:35 <geekosaur> lethjakman-l, there's -fdefer-type-errors, and I think 8.0 has -fdefer-all-errors (these basically replace anything that it can't figure out with undefined, so you can :t or ghc-mod or whatever what does work)
20:11:05 <lethjakman-l> Oooo
20:11:07 <lethjakman-l> That helps. 
20:11:09 <lethjakman-l> Thank you!
20:11:25 <lethjakman-l> I didn't know 8.0 was out yet. 
20:11:31 <geekosaur> it's not
20:11:40 <lethjakman-l> Oh, Alpha?
20:11:41 <geekosaur> there's a somewhat broken prerelease
20:11:48 <lethjakman-l> Neat. 
20:12:27 <geekosaur> whichh ought to be called alpha but ghc hq calls it rc1, go figure
20:12:54 <geekosaur> (ghc release engineering is a bit ad hoc)
20:13:02 <lethjakman-l> Lol. Yeah, ruby does that too. 
20:13:08 <lethjakman-l> I guess it's not fully standardized yet?
20:13:12 <lethjakman-l> That's usually when I see that. 
20:13:31 <ReinH> rc1 is just as standard a term as alpha
20:13:36 <geekosaur> well, it's "feature complete, now we whack bugs"
20:13:41 <lethjakman-l> Ahhh. 
20:13:50 <lethjakman-l> My understanding was incorrect then. 
20:16:03 <lethjakman-l> Hm. So I'm having issues with what I think is a Reader monad. https://gist.github.com/lethjakman/ca12495a15cffe358916
20:16:24 <lethjakman-l> It's throwing an error that it's trying to match App with Auth. I'm assuming because it's digging one level too neat in the MForm. 
20:16:37 <lethjakman-l> I tried removing the do but I end with an indentation error...
20:17:00 <lethjakman-l> And that seemed to do nothing...
20:17:10 <lethjakman-l> Any clue why it'd be trying to match App with Auth?
20:22:06 <lethjakman-l> Hrm...seems like it's a free rwst. 
20:22:13 <lethjakman-l> I haven't seen super nested * -> * -> before. 
20:25:57 <acertain> so, what about a typeclass system that has `withDict :: DictOf c -> (c => r) -> r` and you can write `DictOf c`s as alternative instances, but no constraints in GADTs (you must do `DictOf c ->` instead of `c =>` in GADTs)?
20:27:48 <shachaf> What about it?
20:28:35 <acertain> does it do much better than normal implicit arguments for being predictable?
20:33:50 <noonan> hoogle suggests not, but is there an iterateM :: Monad m => [a -> m a] -> a -> m a sitting around somewhere?
20:35:25 <exio4> noonan: foldr (>=>) return ? 
20:35:34 <exio4> @type foldr (>=>) return 
20:35:36 <lambdabot> (Monad m, Foldable t) => t (c -> m c) -> c -> m c
20:35:46 <Strukks> "foldr (\x y -> (x+y)/2) 0 [12,4]", can someone tell me how the operations are done her?
20:35:50 <noonan> yeah, I guess it doesn't really need its own name
20:36:17 <Strukks> What does it set as x and y the first time and the second time?
20:36:45 <noonan> exio4: I guess I'm always expecting that for any foo, somebody has stuck a fooM somewhere that does foo in a Kleisi category
20:37:56 <exio4> noonan: heh, yeah, it'd be handy if it existed, either way :)
20:38:13 <exio4> (maybe it does, and I am just not aware of the package where it is defined)
20:38:44 <noonan> argh, "Kleisli". I always lose that last 'l'.
20:43:21 <ReinH> noonan: except that's not like iterate.
20:43:26 <ReinH> :t iterate
20:43:28 <lambdabot> (a -> a) -> a -> [a]
20:43:39 <noonan> do'h
20:43:50 <ReinH> :t fold
20:43:52 <lambdabot> (Foldable t, Monoid m) => t m -> m
20:44:30 <ReinH> :t ala Kleisli foldMap
20:44:32 <lambdabot> (Foldable t, Monoid (Kleisli m' a' b')) => t (a' -> m' b') -> a' -> m' b'
20:44:48 <noonan> so foldr (>=>) return is literally the analog of foldr (.) id here :)
20:44:53 <ReinH> Yes.
20:44:58 <ReinH> Kleisli and Endo
20:45:32 <Strukks> "foldr (\x y -> (x+y)/2) 2 [3,4]", how does it get 2 values from there? What is x and what is y? :D
20:45:33 <ReinH> if m ~ Identity, you get Endo (or something isomorphic to it, at least)
20:45:41 <ReinH> :t foldr
20:45:44 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
20:45:58 <ReinH> Strukks: x must be from the list and y must be from previous computations.
20:46:25 <ReinH> (well, y could also be the second argument to foldr every time, but that would be silly)
20:47:08 <noonan> It seems like I keep writing code where foldr (.) id comes in handy, and I keep being surprised that it isn't some named thing already. That makes me wonder if I'm doing something weird to keep needing it.
20:48:05 <Strukks> ReinH, I still don't get it, could you do a play by play for the first couple equations?
20:48:25 <Strukks> for "foldr (\x y -> (x+y)/2) 2 [3,4]" for example? 
20:51:23 <Strukks> ReinH: pretty please!
20:53:09 <cads> so is there a way to use haskell to do cool category theory experiments on a gpu?
20:54:36 <cads> also, can we use monads to do really good non-causal video games, where players get time portals and create multiple echos of themselves throughout the timelines?
20:57:52 * cads is looking up computationally heavy category theory problems :P
20:59:08 <kadoban> I'm parsing something that's very … linear I guess I'd say. The result is essentially [OPCODE], so when I get to the end of an OPCODE, there's no going back. Is there a way to get Parsec to give me the "partial" result if say it parses 20 OPCODEs correctly and then one fails, can I get the first 20?
20:59:53 <kadoban> Or is there something quite like parsec that'll let me do that maybe?
21:03:52 <kadoban> One fairly important part of parsec I'm using is the ability to get decent error messages about *where* the error is and what's wrong, and I'm also somewhat tied to the ability to query the current stream state like parsec lets you (like 'getPosition')
21:05:51 <EvanR> cads: heh, Category Experiments sounds like a bad anime
21:06:38 <kadoban> Category Experiments Lain?
21:07:11 <pavonia> kadoban: You could rewrite the parser to always succees and return a special value on failure
21:08:17 <johnw> kadoban: streaming parsers using pipes or conduit can do just that
21:08:54 <kadoban> pavonia: Hmm, that sounds somewhat interesting. I'll ponder how that would go. Only thing I immediately think is: I don't see how I'd recover good error messages that way "expecting blah or blah or blahity foobar"
21:09:21 <kadoban> johnw: Oh hmm, let me see if I can find what those are.
21:09:36 <pavonia> Hhm, true
21:10:02 <johnw> kadoban: pipes uses a parser to view an input as a stream of 'whatever'; so, when the parser fails the stream has ended, but meanwhile you'll have had the opportunity to consume whatever was available
21:10:33 <johnw> and consumption is inherently lazy, so you can do work as you parse
21:10:43 <johnw> even asynchronously, if you want
21:12:03 <kadoban> johnw: That sounds potentially quite nice (though the lazy part I don't think I could really take advantage of much in my case). Should I be looking at a specific package for that, is that pipes-parse maybe?
21:12:15 <johnw> yes, pipes-parse is the key package
21:12:52 <kadoban> Thanks, I'll poke at it and see how it goes.
21:13:13 <johnw> if you've never used any streaming library before, except a bit of rockiness at the start
21:13:21 <johnw> the pipes-parse tutorial assumes familiarity with the basic ideas
21:13:45 <johnw> if you know about Python generators, you can draw a lot of useful analogies, however
21:13:55 <johnw> s/except/expect
21:14:06 <kadoban> I've kind of vaguely played with conduit a bit, but I'll peek at some pipes basic first to make sure.
21:14:16 <johnw> conduit has an attoparsec tie-in
21:14:56 <johnw> (as does pipes, apparently)
21:15:27 <kadoban> Heh, hmm. I guess I have a few options then maybe. I'll try to compare for the features I use and see what looks nice, unless you have a strong recommendation of what to look at first?
21:16:27 <johnw> i'd need to know more about your problem
21:17:18 <kadoban> I can specify more if you're interested, it'd take a minute to write up coherently though.
21:17:36 <ReinH> > foldr (\x y -> (x+y)/2) a [b,c] -- Strukks 
21:17:38 <lambdabot>  (b + (c + a) / 2) / 2
21:17:42 <johnw> if your needs are simple, you can use ParsecT over a Writer, and just accumulate succesful parses as they happen; it might not be terribly efficient, but if the inputs are small it would be dead simple to do
21:18:16 <kadoban> johnw: Hmm, yeah they're pretty simple, and I had kind of considered that in the back of my mind but I wasn't sure if that was too big of a hack to actually use or not, heh.
21:19:02 <johnw> utility trumps beauty if you're the only one that sees the code ;)
21:20:13 <kadoban> Haha, well I'm probably going to open source it eventually, but … it'll give some people something to laugh at when I do XD I guess I'll start there and see how that turns out, it'll probably be the least-effort solution.
21:20:52 <kadoban> (if only because I already have a parser written in parsec … it needs to be refactored a bit anyway, but still)
21:23:06 <johnw> yeah, I'd do that, get the rest of the code working, and then come back to it if you still care
21:23:42 <kadoban> Sounds like a plan. Thanks for the advice.
21:24:30 <pumita> hello guys, I've been reading Richard Bird's book, and in one of the chapters (about parsing), he encourages through an exercise to give an instance of a Monad for a new type Parser defined in: http://lpaste.net/150883
21:24:53 <pumita> I'd reckon that his solution is wrong
21:25:19 <pumita> It also has a few mistakes
21:25:44 <pumita> Can anyone tell me whether or not my instance is OK>
21:25:45 <pumita> ?
21:25:57 <kadoban> pumita: Is it really >> in his?
21:26:19 <pumita> yes, I wrote it just like it is in the book
21:26:57 <EvanR> so his does not use the previous result
21:27:05 <EvanR> even if it fails, it continues
21:27:25 <pumita> also for example it has another error: `apply q s` should be `apply (q x) s`
21:27:37 <glguy> pumita: What page of the book are you looking it
21:28:05 <pumita> 295
21:28:33 <johnw> that instance ascribed to Bird fails the law "return >=> g = g"
21:28:56 <johnw> are you sure you have that right?
21:29:10 <glguy> The version of the book I'm looking at defines >>= in the solution to exercise B, not >>
21:29:24 <pumita> sorry
21:29:31 <pumita> yes, that was my mistake :P
21:29:46 <glguy> but in any case, that solution seems broken
21:29:51 <pumita> but the other part is the same as described in the book
21:30:16 <glguy> http://imgur.com/H2HTf8M
21:30:18 <johnw> pumita: it's strange that your version says "apply (q x) s", and not "apply (q x) s'"
21:30:20 <glguy> that's what I'm seeing
21:30:27 <pumita> I think he just left it to finish in another moment and he forgot to end up it
21:31:03 <glguy> another (minor) issue is that capital P argument :)
21:31:12 <cads> EvanR, i imagine many tentacles now, thanks
21:31:17 <pumita> johnw yes, that's another mistake
21:31:58 <pumita> now, with the errors corrected, it has sense?
21:32:15 <EvanR> and apply q s seems illtyped
21:32:35 <glguy> pumita: Yeah, your new version seems fine
21:33:31 <glguy> pumita: In case you haven't seen it, this won't be the first error you find https://www.cs.ox.ac.uk/publications/books/functional/errata.html
21:34:20 <pumita> glguy: oh nice! thanks :)
21:34:36 <pumita> though this one doesn't appear :(
21:35:00 <pumita> I'm going to send him an email
21:35:14 <glguy> err, "won't be the last" :)
21:36:04 <EvanR> shouldnt the supposely correct haskell parts of the book be checked by the compiler ;)
21:36:14 * hackagebot blaze-svg 0.3.6 - SVG combinator library  https://hackage.haskell.org/package/blaze-svg-0.3.6 (BrentYorgey)
21:46:48 <zeko> noteventime: hello, are you around? you were explaining f-algebras to me the other day (I was bollu)
21:46:58 <zeko> Cale: ping 
21:54:37 <zeko> noteventime: I was hoping we could continue if you were free
22:00:18 <dmj> /msg jle` ay
22:00:18 <dmj>  
22:11:15 * hackagebot scotty 0.11.0 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  https://hackage.haskell.org/package/scotty-0.11.0 (AndrewFarmer)
22:15:33 <johnw> where did the name "return" come from, in Monad?
22:16:20 <jle`> i think it's supposed to make do blocks look lexically/superficially similar to subroutine notation in c-like languages
22:16:30 <johnw> I know, but who used it first?
22:20:33 <dmj> johnw: maybe Wadler, I wonder if any precursors to Haskell had return, like Miranda
22:24:24 <CodeOn> Hi guys
22:25:07 <Cale> hello
22:25:30 <Cale> dmj: I don't think so. Early versions of Haskell didn't have it.
22:25:58 <Cale> dmj: It was around Haskell 1.3 (maybe 1.2?) which introduced the IO type.
22:26:04 <dmj> johnw, Cale: Wadler just kind of starts using it in "Monads for functional programming" ~2006. haskell came out in early 90's I think.
22:26:26 <dmj> Cale: Oh, so Monad *and* IO came around the same time?
22:26:32 <Cale> yeah
22:27:10 <zeko> it's only been a decade since monads?
22:27:11 <Cale> and for a while (maybe still?) people were a little bit overly focused on the fact that IO happened to be a monad
22:27:19 <zeko> how was IO before that? streams?
22:28:49 <Cale> Well, monads were around in category theory for longer
22:29:02 <Cale> (but no earlier than the 1960's)
22:29:40 <Cale> IO before that was managed by a continuation passing style [Response] -> [Request] function.
22:31:00 <Cale> Yeah, 1.2 still didn't have IO
22:31:18 <Cale> http://haskell.org/definition/haskell-report-1.2.ps.gz
22:31:29 <Cale> If you go to page 124
22:31:48 <Cale> You'll see the definition of Request and Response
22:31:54 <dmj> Cale: so Wadler got it from Moggi and then pitched it to spj on ghc?
22:32:20 <dmj> Seems like Moggi was at Edinburgh
22:32:24 <Cale> Well, yes on the first part... I don't know exactly what happened after Wadler started writing papers
22:33:00 <Cale> But there were like a dozen Haskell users back then
22:33:31 <Cale> (well, a few dozen maybe)
22:34:10 <zeko> Cale: were you using Haskell back then? :)
22:34:17 <Cale> no
22:34:28 <Cale> I started around 2001 or so
22:35:03 <Welkin> cale is super old
22:35:05 <dmj> Cale: did typeclasses exist then? (When monads were introduced)
22:35:43 <Welkin> dmj: which keyboard do you use?
22:36:02 <Cale> dmj: Well, there are some cases where the concept was used unwittingly before people knew about monads, and there are other cases where they clearly knew about monads and didn't have constructor classes yet.
22:36:33 <Cale> I know that as late as 2004-ish, there was some code in GHC which used a monad that was not an instance of the Monad class
22:36:49 <Cale> Just because nobody'd bothered to rework it like that yet
22:39:30 --- mode: ChanServ set +o Cale
22:40:56 --- mode: Cale set -q *!*@198.199.80.102
22:41:10 <Cale> did that work? bitemyapp say something
22:42:05 <bitemyapp> hi
22:42:07 <bitemyapp> > 2 + 2
22:42:08 <Cale> hi
22:42:10 <lambdabot>  4
22:42:11 <Welkin> lol haha
22:42:11 <Cale> okay
22:42:14 <bitemyapp> Cale: thank you
22:42:15 <Welkin> bitemyapp was silenced?
22:42:15 --- mode: Cale set -o Cale
22:42:16 <johnw> welcome back
22:42:16 <Welkin> hahaha
22:42:20 <Cale> yeah, he was
22:42:22 <bitemyapp> @karma+ Cale
22:42:22 <lambdabot> Cale's karma raised to 68.
22:42:30 <CodeOn> 6hello
22:42:36 <bitemyapp> asked a perf question earlier, nobody answered, wondered why
22:42:36 <dmj> \o/
22:42:44 <bitemyapp> didn't notice until I was giving dmj links/history on Monad
22:42:47 <bitemyapp> then I was like, wtf
22:42:50 <Welkin> bitemyapp: no magic for you!
22:42:58 <bitemyapp> Welkin: fuckin' a
22:46:16 * hackagebot beam 0.3.2.0 - A type-safe SQL mapper for Haskell that doesn't use Template Haskell  https://hackage.haskell.org/package/beam-0.3.2.0 (TravisAthougies)
22:48:01 <Welkin> ooh that looks interesting
22:48:09 <Welkin> another sql library
22:48:30 <tero-> nice sales pitch
22:49:48 <tero-> if I only weren't so heavily invested in persistent already..
22:52:11 <Welkin> yeah, I love persistent
22:54:25 <muzzle> hi
22:54:38 <dmj> muzzle: hey
22:55:00 <muzzle> i want to ask about something that has been bugging me for a while, say i want to write some software that deals with financial transactions.
22:55:15 <muzzle> i want to make sure that i can't mix amounts of cash from two different currencies
22:55:32 <muzzle> so my idea was to make types for each currency, say USD and GBP
22:55:48 <muzzle> and i make a datatype amount
22:55:53 <muzzle> something like
22:56:27 <muzzle> data Amount a where Amount :: Currency a => Double -> a -> Amount a
22:56:46 <Welkin> you could include the currency in the type for your amount
22:56:52 <muzzle> and it works out pretty nicely, until i get to parsing data into that system
22:57:15 <muzzle> because then type class is not clear when parsing the data
22:58:01 <muzzle> if e.g. i have a csv file of amounts in different currencies, then I'm in trouble, right?
22:59:07 <Welkin> you can use functional dependencies and place your methods for currency arithmetic in a typeclass
22:59:14 <liste> if you know the currencies statically, you can do something like "parse :: Text -> (Text, Currency USD, Currency GBP)"
22:59:32 <liste> Amount USD, Amount GBP*
23:00:17 <jle`> if you have a csv file with amounts that depend on data you parse, then you could make a data USDorGBP = U USD | G GBP
23:00:22 <muzzle> but is there something i can do if i don't really know my currencies statically?
23:00:32 <jle`> and write an Amount instance for USDorGBP
23:00:42 <jle`> or, you can go full-on dependent types
23:00:53 <geekosaur> another alternative is to choose one as your "base currency" (often you need this anyway because you need to track in a local currency) and convert
23:01:26 <geekosaur> possibly preserving the original somehow, e.g. a tuple. then instead of a typeclass you use data constructors
23:01:44 <geekosaur> but it depends on what your full needs are
23:02:16 <jle`> yeah, if you know ahead of time all of your currencies, you can ditch the typeclass altogether and make a sum type of possible currencies
23:02:29 <jle`> and then write a conversion from a base currency
23:03:22 <jle`> typeclasses are kind of weird anyway
23:03:33 <jle`> making your own typeclass is usually a code smell
23:03:54 <jle`> (there's usually a much simpler and easy to use solution to your problem than making a typeclass)
23:04:08 <jle`> 99% of the time
23:04:17 <muzzle> so there is no real way, that i can get the type system to exclude e.g. addition of a USD and a GBP amount? The way to go would be to do it via some kind of condtitional construction?
23:05:28 <geekosaur> in this case I don't think you actually want that
23:06:04 <geekosaur> again it depends onw hat you are doing --- but with currencies, you often need to do things like deal with tax based on the local value
23:06:26 <geekosaur> meaning at some point you need to do that addition (or subtraction)
23:08:26 <geekosaur> ifyou want to separate based on the type of currency, it often makes more sense to use data constructors and then e.g. collect values in a Map Currency Amount or similar
23:27:01 <roelof> bitemyapp:  can I ask you something ?  
23:31:26 <julianleviston> roelof: usually, just ask.
23:32:22 <roelof> julianleviston:  Do you ever sleep 
23:32:57 <roelof> julianleviston:  Do you want to check the commits or merge it ? 
23:33:03 <julianleviston> roelof: sure. :) I slept since we last talked! not much thought, I suppose. 
23:33:22 <roelof> Everythings compiles and works as expected when testing 
23:33:50 <roelof> I slept some 6 - 7 hours. Wife was late at home 
23:34:10 <julianleviston> roelof: It depends how picky you want me to be, I guess. I think non-picky is a good way to be at this stage.
23:34:18 <julianleviston> roelof: so yeah, just put it in. 
23:34:46 <roelof> julianleviston:  Still things that can be more the Haskell way ? 
23:35:10 <julianleviston> Is there a Haskell way? :)
23:36:22 <roelof> I do not know. Still learning.  I mean things that can be better ? 
23:36:29 <scshunt> what's the context?
23:36:33 <roelof> Everything is merged :)  
23:36:59 <roelof> scshunt:  I write a sort of accounting software to learn Haskell and julianleviston  helps me with that 
23:37:04 <julianleviston> roelof: it’d be a good thing for you to get other eyes on this, I’d say… with a view to “Hey, I’m learning Haskell, tell me what stinks”
23:37:29 <Lokathor> i might have a problem with my STM fancyness :(
23:37:39 <julianleviston> https://github.com/rwobben/paytime/
23:37:39 <roelof> oke, so make a topic on Reddit to ask for feedback :) 
23:38:34 <julianleviston> roelof: when you do this, you’ll need to stay self-motivated because it *may* be a little heart-breaking.
23:38:40 <roelof> julianleviston:  if I ask here someone could give feedback and I do not read it when im offline 
23:38:46 <Lokathor> I'm updating an STM var, but other threads aren't seeing the update it seems :/
23:38:57 <julianleviston> roelof: just rememeber it’s to improve (and you HAVE been making a lot of progress over the last 3 weeks, I have to say)
23:39:39 <roelof> julianleviston:  I think one of the feedback is that we use type , I think most people will say use newtype  
23:40:00 <julianleviston> roelof: for what? you mean Amount ?
23:40:03 <julianleviston> I doubt that.
23:40:11 <roelof> We see 
23:40:14 <julianleviston> :) yep
23:40:33 <roelof> We cross that brigde when we get there 
23:40:49 <roelof> julianleviston:   do you know a better way for asking feedback ? 
23:40:51 <julianleviston> roelof: well there’s no need to use a newtype yet for it as it just wraps an Integer
23:41:00 <julianleviston> roelof: no, what you’re doing seems good to me.
23:41:11 <julianleviston> but I’m no expert at asking for feedback.
23:41:12 <julianleviston> :)
23:41:31 <roelof> better ask on haskell-beginners or on the haskell reddit ? 
23:41:40 <julianleviston> roelof: best to ask when America is awake, whenever that is.
23:41:41 <Lokathor> if I have a TVar (Map Text (TVar ServerRoom)), and I just edit one of the inner TVar over and over, it seems like when someone else goes to get the TVar mapped by the map
23:41:44 <Lokathor> i get a different TVar
23:41:56 <Lokathor> so i have to pull the inner TVar out of the map each time?
23:42:30 <roelof> I think America is awake when I want to sleep.  As far as I know America is behind 8 hours or more on me. 
23:42:46 <roelof> As you are more then 8 hours ahead of me 
23:42:59 <liste>   Lokathor can you lpaste some code?
23:43:06 <roelof> Here it is early morning  8:43 hours
23:43:23 <Lokathor> liste one moment, i'm halfway through an update, let me put it back how it was
23:44:38 <Lokathor> liste, https://github.com/Strifepad/strifeserver/blob/master/src/Strife/WebSockets.hs
23:44:47 <roelof> Lokathor:  if I want to have feedback on some code as a beginner , can I better ask in haskell or in haskell-beginners reddit channel ? 
23:45:01 <Lokathor> more people here
23:46:13 <roelof> oke, then I will ask when it's evening here. Hopefully more people from Amrica are then here 
23:46:34 <Lokathor> liste, http://lpaste.net/150890 i got output like that
23:46:42 <roelof> julianleviston:  how late is it in your country now ? 
23:51:30 <Cale> roelof: Did you have a question?
23:52:10 <roelof> I had a question for bitemyapp about his book but I that can wait 
23:52:50 <roelof> but if you have time , could you give feedback on my code so far : https://github.com/rwobben/paytime/tree/master/paytime/src 
23:52:59 <Lokathor> Cale, you know much about STM?
23:53:01 <roelof> of course, only if you want to do it 
23:54:16 <Cale> Lokathor: sure
23:54:51 <Lokathor> i've got a TVar that doesn't seem to be updating across threads like I expect it
23:54:59 <Cale> Lokathor: huh
23:55:09 <Cale> Are you sure the transactions which are modifying it are succeeding?
23:56:02 <Lokathor> essentally, there'a a TVar (Map Text (TVar StateThing)), and what i'm doing is pulling out the TVar StateThing out, and then updating that, but then those changes don't seem to be seen if you go back to the Map and pull out what should be the same TVar
23:56:28 <Lokathor> i'm sure the transactions are completing though
23:56:45 <Lokathor> i guess, do i need to pull the TVar I want to edit out of the map and then write it back in every time i edit the sub-variable?
23:56:56 <Cale> That shouldn't be possible.
23:57:13 <Cale> and no you shouldn't need to do that
23:57:47 <Cale> As soon as the atomically block finishes, all threads should see the changes.
23:57:47 <Lokathor> http://lpaste.net/150890#line16 here's some example debug. on line 16, a new user connects and they see differnt lines content than was just there
23:57:57 <Cale> can I see the code?
23:58:30 <Lokathor> the main code is https://github.com/Strifepad/strifeserver/blob/master/src/Strife/WebSockets.hs there's also a Data.hs with datatypes in it
